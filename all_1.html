<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207872790.html">
                
                  <h1>小想法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>看了那么多前辈的博客，之前的博客也有从网上搜集资料，总结的博客。但总觉得程序员的成长还是需要由自己的思想来完成博客的搭建，而且由自己边写代码边完成博客，对自身的知识总结以及对知识的学以致用还是有很大帮助的。所以打算以后多多总结项目中的错误，也可以总结自身开发项目的经验，把知识总结归纳起来，帮助自身有更大的提高。</p>

<p>消停了一段时间，发现果然还是写代码更能给我带来快乐哈哈哈哈哈！！！</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E9%9A%8F%E6%89%8B%E8%AE%B0.html'>随手记</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872754.html">
                
                  <h1>Android-性能优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>性能检测与分析，一直在 APP 开发中相当重要，但又被我们常常忽略。很多 APP 或者开发者总是急功近利，总想着快速充实 APP 的相关功能，把开发进度放在首位没有问题，可很多时候就没有然后了，这在整个开发界屡见不鲜。<br/>
在这样的大背景下，加之我之前写的 RxJava 2.0 系列 收到较好的反馈，诱导我想出这么一个性能优化系列。</p>

<h2 id="toc_1">一些你可能需要知道的</h2>

<p>了解我的知道，我出的系列基本都是比较基础，而且侧重于常见必备。所以不一定全面，也不一定深入，所以希望理解。<br/>
性能优化大概可以概括为：</p>

<ul>
<li>性能优化说起来很简单，但做起来难。</li>
<li>性能优化点多并且繁杂，需要耐心和经验。也许每个优化点很小，但积累起来会从量变变成质的飞跃。</li>
<li>性能优化必须建立在产品设计之上，不能为了追求性能而忽略了产品设计。</li>
</ul>

<h2 id="toc_2">提供一些资源 ( 你可能需要梯子 )</h2>

<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fdeveloper.android.com%2Fintl%2Fzh-cn%2Ftraining%2Fbest-performance.html">性能优化最佳实践</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fdeveloper.android.com%2Fintl.zh-cn%2Ftools%2Fperformance%2Findex.html">性能优化工具</a></li>
</ul>

<h2 id="toc_3">善用 ArrayMap</h2>

<p>程序内存的管理是否合理高效对应用的性能有着很大的影响，有时候对容器的使用不当也会导致内存管理效率低下。想必已经有很多童鞋知道了 SparseArray，但它只是用于替代 List。<br/>
我们经常会在程序中用到 HashMap，它非常好用，这毋庸置疑。但它却非常耗内存。HashMap 的工作原理这里我们就不讲了，有兴趣的自行科普。</p>

<h3 id="toc_4">更高效的 ArrayMap 容器</h3>

<p>为了解决 HashMap 更占内存的弊端，Android 提供了内存效率更高的 ArrayMap。它内部使用两个数组进行工作，其中一个数组记录 key hash 过后的顺序列表，另外一个数组按 key 的顺序记录 Key - Value 的值。如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047249478577.png" alt="20171112151047249478577.png"/><figcaption>20171112151047249478577.png</figcaption></figure></p>

<p>当你想获取某个 Value 的时候，<code>ArrayMap</code> 会计算输入 key 转换过后的 hash 值，然后对 hash 数组使用二分查找法寻找到对应的 index，然后我们可以通过这个 index 在另外一个数组中直接访问到需要的键值对。如果在第二个数组键值对中的 key 和前面输入的查询 key 不一致，那么就认为是发生了碰撞冲突。为了解决这个问题，我们会以该 key 为中心点，分别上下展开，逐个去对比查找，直到找到匹配的值。如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047254836245.png" alt="20171112151047254836245.png"/><figcaption>20171112151047254836245.png</figcaption></figure></p>

<p>随着数组中的对象越来越多，查找访问单个对象的花费也会跟着增长，这是在内存占用与访问时间之间做权衡交换。<br/>
既然ArrayMap中的内存占用是连续不间断的，那么它是如何处理插入与删除操作的呢？请看下图所示，演示了Array的特性：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047290144965.png" alt="20171112151047290144965.png"/><figcaption>20171112151047290144965.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047306821392.png" alt="20171112151047306821392.png"/><figcaption>20171112151047306821392.png</figcaption></figure></p>

<p>很明显，ArrayMap 的插入与删除的效率是不够高的，但是如果数组的列表只是在一百这个数量级上，则完全不用担心这些插入与删除的效率问题。HashMap 与 ArrayMap 之间的内存占用效率对比图如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047311164769.png" alt="20171112151047311164769.png"/><figcaption>20171112151047311164769.png</figcaption></figure></p>

<p>与 <code>HashMap</code> 想必，<code>ArrayMap</code> 在循环遍历的时候也更加简单高效，因为其采用的是 fori 循环，而 <code>HashMap</code> 却使用的是糟糕的 <code>Iterator</code>。</p>

<h3 id="toc_5">并不是所有情况下都用 ArrayMap</h3>

<p><code>ArrayMap</code> 这么优秀，但并不是所有情况下都适合使用 <code>ArrayMap</code>，我们应该在满足下面两个条件的时候才考虑使用 <code>ArrayMap</code>：</p>

<ul>
<li>对象个数的数量级最好在 1000 以内。</li>
<li>数据组织形式包含 Map 结构。</li>
</ul>

<p>所以我们需要学会在特定清醒下选择相对更加高效的实现方式。</p>

<h2 id="toc_6">UI 性能确实很重要</h2>

<p>UI 界面是整个 APP 性能的最前端展示，也是最容易看出性能问题的地方。可以毫不夸张地说，UI 性能的好坏直接影响这用户的体验和留存。UI 性能的目标是：</p>

<ul>
<li>减少绘图的等待时间。</li>
<li>使帧率更加平稳、连贯。</li>
</ul>

<h3 id="toc_7">UI 布局的核心原则</h3>

<p>核心原则一句话，尽可能地减少 View 的数量！<br/><br/>
我们可以通过 <code>include</code>、<code>merge</code>、<code>viewstub</code> 进行布局复用，通过控件属性 DrawableLeft、DrawableRight 等方式进行控件整合。  </p>

<h3 id="toc_8">听说我们要尽可能地用 RelativeLayout ?</h3>

<p>想必一些资历较老的 Android 开发者都知道，一开始系统默认创建的布局是 LinearLayout，后面替换成了 RelativeLayout，现在又变成了 ConstraintLayout 。由于我对 ConstraintLayout 不是特别了解，所以这里我着重说说 RelativeLayout 和 LinearLayout 。<br/><br/>
我不知道在什么时候听说过，<code>如果我们能用 RelativeLayout 的地方，尽量不要用 LinearLayout</code> 。<br/><br/>
这种说法是不对的，实际开发中，决不能简单地说 RelativeLayout 和 LinearLayout 谁的性能更好，必须结合实际使用来进行分析。<br/><br/>
基本可以总结为：一般情况下，如果使用 LinearLayout，则一定要保证层级不能太深；如果使用 RelativeLayout，则需要尽量避免嵌套。  </p>

<h2 id="toc_9">正文</h2>

<p>提高 APP 的启动速度对我们意义深远，很显然，APP 的启动时间越短，使用它的用户越有耐心等待打开这个 APP 进行使用。反之，启动时间太长，用户则有可能还没等到 APP 打开就已经切换到其他 APP 了。</p>

<p>程序启动过程中那些复杂错误的操作很有可能导致严重的性能问题。Android 系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android 系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他 APP 界面切换回来）。</p>

<p>那么关键的问题是，<strong>用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他 APP 了。更严重的是，如果启动时间过长，可能导致程序出现 ANR。我们应该避免出现这两种糟糕的情况。</strong></p>

<p>从技术角度来说，当用户点击桌面图标开始，系统会立即为这个 APP 创建独立的专属进程，然后显示启动窗口，直到 APP 在自己的进程里面完成了程序的创建以及主线程完成了 Activity 的初始化显示操作，再然后系统进程就会把启动窗口替换成 APP 的显示窗口。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047382978489.png" alt="20171112151047382978489.png"/><figcaption>20171112151047382978489.png</figcaption></figure></p>

<p>上述流程里面的绝大多数步骤都是由系统控制的，一般来说不会出现什么问题，可是对于启动速度，我们能够控制并且需要特别关注的地方主要有三处：</p>

<ul>
<li>Activity 的 onCreate 流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题。</li>
<li>Application 的 onCreate 流程，对于大型的 APP 来说，通常会在这里做大量的通用组件的初始化操作。</li>
<li>目前有部分 APP 会提供自定义的启动窗口，这里可以做成品牌宣传界面或者是给用户提供一种程序已经启动的视觉效果。</li>
</ul>

<p>在正式着手解决问题之前，我们需要掌握一套正确测量评估启动性能的方法。所幸的是，Android 系统有提供一些工具来帮助我们定位问题。</p>

<h2 id="toc_10">有趣的启动时长定位</h2>

<h3 id="toc_11">display time</h3>

<p>从 Android KitKat 版本开始，Logcat 中会输出从程序启动到某个 Activity 显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017111215104739066103.png" alt="2017111215104739066103.png"/><figcaption>2017111215104739066103.png</figcaption></figure></p>

<h3 id="toc_12">reportFullyDrawn()</h3>

<p>我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用 <code>activity.reportFullyDrawn()</code> 方法来告诉系统此时的状态，以便获取整个加载的耗时。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047399580505.png" alt="20171112151047399580505.png"/><figcaption>20171112151047399580505.png</figcaption></figure></p>

<h3 id="toc_13">Method Tracing</h3>

<p>前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用 Method Tracing 工具来进行详细的测量。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047401087421.png" alt="20171112151047401087421.png"/><figcaption>20171112151047401087421.png</figcaption></figure></p>

<h3 id="toc_14">Systrace</h3>

<p>我们可以在 <code>onCreate()</code> 方法里面添加 <code>trace.beginSection()</code> 与 <code>trace.endSection()</code> 方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017111215104740573026.png" alt="2017111215104740573026.png"/><figcaption>2017111215104740573026.png</figcaption></figure></p>

<h2 id="toc_15">如果优化 APP 启动速度？</h2>

<h3 id="toc_16">提升 Activity 的创建速度</h3>

<p>提升 Activity 的创建速度是优化 APP 启动速度的首要关注目标。从桌面点击 APP 图标启动应用开始，程序会显示一个启动窗口等待 Activity 的创建加载完毕再进行显示。在 Activity 的创建加载过程中，会执行很多的操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写 Preference 等等。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047407664811.png" alt="20171112151047407664811.png"/><figcaption>20171112151047407664811.png</figcaption></figure></p>

<p>上述操作的任何一个环节出现性能问题都可能导致画面不能及时显示，影响了程序的启动速度。上一个段落我们介绍了使用 Method Tracing 来发现那些耗时占比相对较多的方法。假设我们发现某个方法执行时间过长，接下去就可以使用 Systrace 来帮忙定位到底是什么原因导致那个方法执行时间过长。</p>

<p>除了使用工具进行具体定位分析性能问题之外，以下两点经验可以帮助我们对 Activity 启动做性能优化：</p>

<ul>
<li>优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！</li>
<li>异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。</li>
</ul>

<h3 id="toc_17">别让 Application 初始化不必要的东西</h3>

<p>在 Application 初始化的地方做太多繁重的事情是可能导致严重启动性能问题的元凶之一。Application 里面的初始化操作不结束，其他任意的程序操作都无法进行。</p>

<p>有时候，我们会一股脑的把绝大多数全局组件的初始化操作都放在 Application 的 onCreate() 里面，但其实很多组件是需要做区队对待的，有些可以做延迟加载，有些可以放到其他的地方做初始化操作，特别需要留意包含 Disk IO 操作，网络访问等严重耗时的任务，他们会严重阻塞程序的启动。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047411112263.png" alt="20171112151047411112263.png"/><figcaption>20171112151047411112263.png</figcaption></figure></p>

<p>优化这些问题的解决方案是做延迟加载，可以在 Application 里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047412041394.png" alt="20171112151047412041394.png"/><figcaption>20171112151047412041394.png</figcaption></figure></p>

<h3 id="toc_18">恰当地使用闪屏</h3>

<p>启动闪屏不仅仅可以作为品牌宣传页，还能够减轻用户对启动耗时的感知，但是如果使用不恰当，将适得其反。前面介绍过当点击桌面图标启动 APP 的时候，程序会显示一个启动窗口，一直到页面的渲染加载完毕。如果程序的启动速度足够快，我们看的闪屏窗口停留显示的时间则会很短，但是当程序启动速度偏慢的时候，这个启动闪屏可以一定程度上减轻用户等待的焦虑感，避免用户过于轻易的关闭应用。</p>

<p>目前大多数开发者都会通过设置启动窗口主题的方式来替换系统默认的启动窗口，通过这种方式只是使用『障眼法』弱化了用户对启动时间的感知，但本质上并没有对启动速度做什么优化。也有些 APP 通过关闭启动窗口属性 android:windowDisablePreview 的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，这样的用户体验是十分糟糕的！</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047413813045.png" alt="20171112151047413813045.png"/><figcaption>20171112151047413813045.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047415075230.png" alt="20171112151047415075230.png"/><figcaption>20171112151047415075230.png</figcaption></figure></p>

<p>对于启动闪屏，正确的使用方法是自定义一张图片，把这张图片通过设置主题的方式显示为启动闪屏，代码执行到主页面的 <code>onCreate()</code> 的时候设置为程序正常的主题。</p>

<h2 id="toc_19">前言</h2>

<p>内存泄漏从来都是我们老生常谈的话题，无论是 Android Studio 自带的内存泄漏分析工具还是专业的 Eclipse MAT 抑或是备受青睐的第三方插件 <a href="https://github.com/square/leakcanary">LeakCanary</a>，都为我们的内存泄漏检测提供了便利。如果从根源上解决内存泄漏，内存优化必不可少。所以本章节我们参考扔物线胡凯的内存优化策略，直接拿出一章节来谈内存优化。</p>

<p>内存优化基本可以分为下面几个方面</p>

<ul>
<li>减少对象的内存占用</li>
<li>对内存对象进行复用</li>
<li>避免对象的内存泄漏</li>
<li>内存使用策略优化</li>
</ul>

<h2 id="toc_20">减少对象的内存占用</h2>

<h3 id="toc_21">避免在 Android 里面使用 Enum</h3>

<p>Enum 是 Java 中包含固定常量的数据类型，当需要知道预先定制的几个值，这几个值表示一些数据类，我们都可以使用 Enum。我们一般用 Enum 做一些编译时检查，以避免传入不合法的参数。</p>

<p>但 Enum 的每个对象都是 Object，在 Android 官网上就早已明确指出应该在 Android 开发中避免使用 Enum，因为与静态常量想必，它对内存的占用是要大很多的。</p>

<p>因此在实际开发中，我更加倾向于接口变量，因为接口会自动把成员变量设置为 static 和 final 的，这一点可以防止某些情况下错误地添加新的常量，这也使得代码看起来更加简单和清晰。</p>

<h3 id="toc_22">使用更加轻量的数据结构</h3>

<p>前面第一节已经说过，我们应该更加倾向于考虑使用 <code>ArrayMap</code> 和 <code>SparseArray</code> 而不是 <code>HashMap</code> 等传统数据结果，前面已经用图示演示了 <code>HashMap</code> 的简要工作原理，相比起 <code>Android</code> 系统专门为移动操作系统编写的 <code>ArrayMap</code> 容器，在大多数情况下，都显示效率低下，更占内存。通常的 <code>HashMap</code> 的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录 <code>Mapping</code> 操作。另外，<code>SparseArray</code> 更加高效在于他们避免了对 <code>key</code> 和 <code>value</code> 的 <code>autobox</code> 自动装箱，并且避免了装箱后的解箱。</p>

<h3 id="toc_23">使用更小的图片</h3>

<p>在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的 <code>InflationException</code>。假设有一张很大的图片被 XML 文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生 <code>InflationException</code>，这个问题的根本原因其实是发生了 OOM。</p>

<h3 id="toc_24">减少 Bitmap 对象的内存占用</h3>

<p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p>

<ul>
<li>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</li>
<li>decode format：解码格式，选择 ARGB_8888 / RBG_565 / ARGB_4444 / ALPHA_8，存在很大差异。</li>
</ul>

<h3 id="toc_25">尽量地采用 int 类型</h3>

<p>Android 系统中 float 类型的数据存取速度是 int 类型的一半，尽量优先采用 int 类型。而同样能作为整数的代名词，采用 int 替换 Integer 会让你的内存开销更小。</p>

<h2 id="toc_26">对内存对象进行复用</h2>

<h3 id="toc_27">复用系统自带的资源</h3>

<p>Android 系统本身内置了很多的资源，例如字符串 / 颜色 / 图片 / 动画 / 样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小 APK 的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意 Android 系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p>

<h3 id="toc_28">注意 ListView / GridView 的 Adapter 对 ConvertView 进行复用</h3>

<p>这个貌似没啥好说的，太基础了，而且我们可能现在更加青睐于 RecyclerView。</p>

<h3 id="toc_29">尽量的采用 StringBuilder</h3>

<p>这个也特别基础，我们点到为止。大概就是尽量的采用 StringBuilder / StringBuffer 来替换我们频繁的字符串拼接。</p>

<h3 id="toc_30">尽量使用原字符串的 subString</h3>

<p>当从已经存在的数据集中抽取出 String 的时候，尝试返回原数据的 subString 对象，而不要创建一个重复的对象。</p>

<h3 id="toc_31">避免在 onDraw() 里面执行对象的创建</h3>

<p>类似 onDraw() 等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的 gc，甚至是内存抖动。</p>

<h2 id="toc_32">避免对象的内存泄漏</h2>

<p>内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现 OOM。显然，这还使得每级 Generation 的内存区域可用空间变小，gc 就会更容易被触发，容易出现内存抖动，从而引起性能问题。</p>

<h3 id="toc_33">注意 Activity 的泄漏</h3>

<p>通常来说，Activity 的泄漏是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的 Activity 泄漏：</p>

<ul>
<li><p>内部类引用导致 Activity 的泄漏<br/><br/>
最典型的场景是 Handler 导致的 Activity 泄漏，如果 Handler 中有延迟的任务或者是等待执行的任务队列过长，都有可能因为 Handler 继续执行而导致 Activity 发生泄漏。此时的引用关系链是 Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity。为了解决这个问题，可以在 UI 退出之前，执行 remove Handler 消息队列中的消息与 runnable 对象。或者是使用 Static + WeakReference 的方式来达到断开 Handler 与 Activity 之间存在引用关系的目的。</p></li>
<li><p>Activity Context 被传递到其他实例中，这可能导致自身被引用而发生泄漏。<br/><br/>
内部类引起的泄漏不仅仅会发生在 Activity 上，其他任何内部类出现的地方，都需要特别留意！我们可以考虑尽量使用 static 类型的内部类，同时使用 WeakReference 的机制来避免因为互相引用而出现的泄露。</p></li>
</ul>

<h3 id="toc_34">尽量地采用 Application Context</h3>

<p>对于大部分非必须使用 Activity Context 的情况（Dialog 的 Context 就必须是Activity Context），我们都可以考虑使用 Application Context 而不是 Activity 的 Context，这样可以避免不经意的 Activity 泄露。</p>

<p>而且如果习惯 Glide 的童鞋可能会发现，<strong>Glide 需要传递的 Context 如果是 Activity 的 Context ，那么在 Activity 被销毁后还没加载出来的话还会引发崩溃。</strong>所以，请在使用 Glide 或者 Toast 等的时候，直接传递 Application Context 吧。</p>

<h3 id="toc_35">注意 Cursor 对象是否及时关闭</h3>

<p>在程序中我们经常会进行查询数据库的操作，但时常会存在不小心使用 Cursor 之后没有及时关闭的情况。这些 Cursor 的泄露，反复多次出现的话会对内存管理产生很大的负面影响，我们需要谨记对 Cursor 对象的及时关闭。</p>

<h3 id="toc_36">注意 WebView 的泄漏</h3>

<p>Android中 的 WebView 存在很大的兼容性问题，不仅仅是 Android 系统版本的不同对 WebView 产生很大的差异，另外不同的厂商出货的 ROM 里面 WebView 也存在着很大的差异。更严重的是标准的 WebView 存在内存泄露的问题，看这里。所以通常根治这个问题的办法是为 WebView 开启另外一个进程，通过 AIDL 与主进程进行通信，WebView 所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>

<h3 id="toc_37">注意临时 Bitmap 对象的及时回收</h3>

<p>虽然在大多数情况下，我们会对 Bitmap 增加缓存机制，但是在某些时候，部分 Bitmap 是需要及时回收的。例如临时创建的某个相对比较大的 Bitmap 对象，在经过变换得到新的 Bitmap 对象之后，应该尽快回收原始的 Bitmap，这样能够更快释放原始 Bitmap 所占用的空间。</p>

<p>需要特别留意的是 Bitmap 类里面提供的 createBitmap() 方法：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047477494165.png" alt="20171112151047477494165.png"/><figcaption>20171112151047477494165.png</figcaption></figure></p>

<p>这个函数返回的 Bitmap 有可能和 source bitmap 是同一个，在回收的时候，需要特别检查 source bitmap 与 return bitmap 的引用是否相同，只有在不等的情况下，才能够执行 source bitmap 的 recycle() 方法。</p>

<h3 id="toc_38">注意监听器的注销</h3>

<p>在 Android 程序里面存在很多需要 register 与 unregister 的监听器，我们需要确保在合适的时候及时 unregister 那些监听器。自己手动 add 的 listener，需要记得及时 remove 这个 listener。</p>

<h2 id="toc_39">内存使用策略优化</h2>

<h3 id="toc_40">谨慎使用 large heap</h3>

<p>Android 设备根据硬件与软件的设置差异而存在不同大小的内存空间，他们为应用程序设置了不同大小的 Heap 限制阈值。你可以通过调用 getMemoryClass() 来获取应用的可用 Heap 大小。在一些特殊的情景下，你可以通过在 manifest 的 application 标签下添加 <code>largeHeap = true</code> 的属性来为应用声明一个更大的 heap 空间。然后，你可以通过 <code>getLargeMemoryClass()</code> 来获取到这个更大的 <code>heap size</code> 阈值。然而，声明得到更大 Heap 阈值的本意是为了一小部分会消耗大量 RAM 的应用 ( 例如一个大图片的编辑应用 ) 。不要轻易的因为你需要使用更多的内存而去请求一个大的 Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用 large heap。因此请谨慎使用 large heap 属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次 gc 的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap 并不一定能够获取到更大的 heap。在某些有严格限制的机器上，large heap 的大小和通常的 heap size 是一样的。因此即使你申请了 large heap，你还是应该通过执行 <code>getMemoryClass()</code> 来检查实际获取到的 heap 大小。</p>

<h3 id="toc_41">资源文件需要选择合适的文件夹进行存放</h3>

<p>我们知道 hdpi / xhdpi / xxhdpi 等等不同 dpi 的文件夹下的图片在不同的设备上会经过 scale 的处理。例如我们只在 hdpi 的目录下放置了一张 100 x 100 的图片，那么根据换算关系，xxhdpi 的手机去引用那张图片就会被拉伸到 200 x 200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到 assets 或者 nodpi 的目录下。</p>

<h3 id="toc_42">Try catch某些大内存分配的操作</h3>

<p>在某些情况下，我们需要事先评估那些可能发生 OOM 的代码，对于这些可能发生 OOM 的代码，加入 catch 机制，可以考虑在 catch 里面尝试一次降级的内存分配操作。例如 decode bitmap 的时候，catch 到 OOM，可以尝试把采样比例再增加一倍之后，再次尝试 decode。</p>

<h3 id="toc_43">谨慎使用 static 对象</h3>

<p>因为 static 的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在 Android 中应该谨慎使用 static 对象。</p>

<h3 id="toc_44">特别留意单例对象中不合理的持有</h3>

<p>虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。特别是持有 Context 的引用，需要谨慎对待。</p>

<h3 id="toc_45">优化布局层次，减少内存消耗</h3>

<p>越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的 View 无法实现足够扁平的时候考虑使用自定义 View 来达到目的。</p>

<h3 id="toc_46">谨慎使用多进程</h3>

<p>使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p>

<p>一个典型的例子是创建一个可以长时间后台播放的 Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些 UI 资源也没有办法得到释放。类似这样的应用可以切分成 2 个进程：一个用来操作 UI，另外一个给后台的 Service。</p>

<h2 id="toc_47">写在最后</h2>

<p>内存优化并不就是说程序占用的内存越少就越好，如果因为想要保持更低的内存占用，而频繁触发执行 gc 操作，在某种程度上反而会导致应用性能整体有所下降，这里需要综合考虑做一定的权衡。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872718.html">
                
                  <h1>Android-自定义View播放Gif动画</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>GIF是一种很常见的动态图片格式，在Android中它的使用场景非常多，大到启动页动画、小到一个Loading展示，都可以用GIF动画来完成，使用也很方便，直接从美工那边拿过来用就成。如果项目赶时间或者自定义原生动画太麻烦，GIF都是一个很好的选择，相比于最新的WEBP格式的动画，也有更好的兼容性（毕竟已经出现很多年了）。<br/><br/>
关于图片加载我一直用的是Google推荐的Glide，图片加载和缓存都做的很好，同样也支持GIF动画。不过Glide默认就是循环播放Gif，没有开放相关的接口来控制Gif。这就使的我们不能很好地控制Gif的播放，比如控制播放开始时间、播放次数，播放暂停、播放开始、结束事件的监听，虽然用Glide可能做到（网上说可以，但我没找到方法），但操作也会很麻烦。  </p>

<h2 id="toc_1">分析</h2>

<p>除了第三方的库，Android自带的类android.graphics.Movie也可以用来加载播放Gif动画，而且实现起来很简单。按数据来源分别可以从Gif文件的输入流，文件路径，字节数组中得到Movie的实列。然后我们可以通过操作Movie对象来操作Gif文件。</p>

<ul>
<li>Movie decodeStream(InputStream is)</li>
<li>Movie decodeFile(String pathName)</li>
<li>Movie decodeByteArray(byte[] data, int offset,int length)</li>
</ul>

<p>下面介绍下几个movie的重要方法：</p>

<p><code>int width()</code>     movie的宽，值等于gif图片的宽，单位：px。<br/><br/>
<code>int height()</code>    movie的高，值等于gif图片的高，单位：px。<br/><br/>
<code>int duration()</code>  movie播放一次的时长，也就是gif播放一次的时长，单位：毫秒。boolean isOpaque() Gif图片是否带透明  <code>boolean setTime(int relativeMilliseconds)</code> 设置movie当前处在什么时间，然后找到对应时间的图片帧，范围0 ~ duration。返回是否成功找到那一帧。<br/>
<code>draw(Canvas canvas, float , float y)</code><br/><br/>
<code>draw(Canvas canvas, float x, float y, Paint paint)</code>在Canves中画出当前帧对应的图像。x，y对应Movie左上角在Canves中的坐标。以上就是Movie平常会用到大部分方法，下面就利用这些自定义VIew实现播放Gif动画。</p>

<h2 id="toc_2">实现</h2>

<p>首先定义一些需要的属性，用于在布局文件中设置gif</p>

<pre class="line-numbers"><code class="language-text">  &lt;declare-styleable name=&quot;GIFVIEW&quot;&gt;
        &lt;!--gif文件引用--&gt;
        &lt;attr name=&quot;gifSrc&quot; format=&quot;reference&quot;  /&gt;
        &lt;!--是否加载完自动播放--&gt;
        &lt;attr name=&quot;authPlay&quot; format=&quot;boolean&quot;  /&gt;
        &lt;!--播放次放，默认永远播放--&gt;
        &lt;attr name=&quot;playCount&quot; format=&quot;integer&quot;  /&gt;
    &lt;/declare-styleable&gt;
</code></pre>

<p>然后定义Gif的播放监听器,来监听各个时段的事件，命名的含义都很简单就不再介绍了：</p>

<pre class="line-numbers"><code class="language-java">public interface OnPlayListener {
        void onPlayStart();

        void onPlaying(int percent);

        void onPlayPause(boolean pauseSuccess);

        void onPlayRestart();

        void onPlayEnd();
    }
</code></pre>

<p>声明类，直接继承ImageView，这样我们不仅可以显示Gif动画，也可以显示普通图片：public class GifImageView extends AppCompatImageView然后加载Gif图片资源</p>

<pre class="line-numbers"><code class="language-java"> public void setGifResource(int movieResourceId, OnPlayListener onPlayListener) {
        mOnPlayListener = onPlayListener;
        movie = Movie.decodeStream(getResources().openRawResource(movieResourceId));
        if (movie == null) {
            //如果movie为空，那么就不是gif文件，尝试转换为bitmap显示
            Bitmap bitmap = BitmapFactory.decodeResource(getResources(), movieResourceId);
            if (bitmap != null) {
                setImageBitmap(bitmap);
                return;
            }
        }
        movieDuration = movie.duration() == 0 ? DEFAULT_DURATION : movie.duration();
        requestLayout();
    }
</code></pre>

<p>调用requestLayout重新计算View大小，并重新绘制。如果是gif格式则View宽高等于movie的宽高，不是则调用父类的测量方法。</p>

<pre class="line-numbers"><code class="language-text">   @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (movie != null) {
            int movieWidth = movie.width();
            int movieHeight = movie.height();
            setMeasuredDimension(movieWidth, movieHeight);
        } else {
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        }
    }
</code></pre>

<p>开始播放，其实就是调用invalidate从而调用onDraw方法就行UI绘制：</p>

<pre class="line-numbers"><code class="language-text">    public void play(int counts) {
        this.counts = counts;
        reset();
        if (mOnPlayListener != null) {
            mOnPlayListener.onPlayStart();
        }
        invalidate();
    }
</code></pre>

<p>不断调用onDraw方法来绘制Gif当前时间的图片帧（同样需要判断是否是gif格式，不是则调用父类的绘制方法）：</p>

<pre class="line-numbers"><code class="language-text"> @Override
    protected void onDraw(Canvas canvas) {
        if (movie != null) {
            if (!mPaused &amp;&amp; hasStart) {
                drawMovieFrame(canvas);
                invalidateView();
            } else {
                drawMovieFrame(canvas);
            }
        } else {
            super.onDraw(canvas);
        }
    }
    /**
     * 画出gif帧
     */
    private void drawMovieFrame(Canvas canvas) {
        movie.setTime(getCurrentFrameTime());
        movie.draw(canvas, 0.0f, 0.0f);
    }
</code></pre>

<p>最核心的方法就是计算当前时间需要绘制处于movie中的对应时间的图片帧。</p>

<pre class="line-numbers"><code class="language-text"> private int getCurrentFrameTime() {
        if (movieDuration == 0)
            return 0;
            //因为有暂停，所以需要减去暂停时间
        long now = SystemClock.uptimeMillis() - dealyTime;
        int nowCount = (int) ((now - mMovieStart) / movieDuration);
        if (counts != -1 &amp;&amp; nowCount &gt;= counts) {
            hasStart = false;
            if (mOnPlayListener != null) {
                mOnPlayListener.onPlayEnd();
            }
        }
        int currentTime = (int) ((now - mMovieStart) % movieDuration);
        int percent = currentTime * 100 / movieDuration;
        if (mOnPlayListener != null &amp;&amp; hasStart) {
            mOnPlayListener.onPlaying(percent);
        }
        return currentTime;
    }
</code></pre>

<p>暂停Gif播放：</p>

<pre class="line-numbers"><code class="language-text">   public void pause() {
        if (movie != null &amp;&amp; !mPaused &amp;&amp; hasStart) {
            mPaused = true;
            invalidate();
            mMoviePauseTime = SystemClock.uptimeMillis();
            if (mOnPlayListener != null) {
                mOnPlayListener.onPlayPause(true);
            }
        } else {
            if (mOnPlayListener != null) {
                mOnPlayListener.onPlayPause(false);
            }
        }
    }
</code></pre>

<p>继续Gif播放：</p>

<pre class="line-numbers"><code class="language-text">  if (mPaused &amp;&amp; mMoviePauseTime &gt; 0) {
                mPaused = false;
                dealyTime = dealyTime + SystemClock.uptimeMillis() - mMoviePauseTime;
                invalidate();
                if (mOnPlayListener != null) {
                    mOnPlayListener.onPlayRestart();
                }
            }
</code></pre>

<p>经过这些处理，我们就能更好地控制Gif的播放流程了。下面简单看下成品图：</p>

<h2 id="toc_3">进阶</h2>

<h3 id="toc_4">倒叙播放</h3>

<p>相信看了上面GifImageView的实现原理后，倒叙播放的实现也是很容易的。</p>

<pre class="line-numbers"><code class="language-text">    public void playReserver() {
        if (movie != null) {
            reset();
            reverse = true;
            if (mOnPlayListener != null) {
                mOnPlayListener.onPlayStart();
            }
            invalidate();
        }
    } if (reverse) {
                    movie.setTime(movieDuration - getCurrentFrameTime());
                } else {
                    movie.setTime(getCurrentFrameTime());
                }
</code></pre>

<p>如下图，狗子的头已经从原来的左边转到右边变成了现在的右边转到左边（ಠᴗಠ）。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041826167420.gif" alt="20171112151041826167420.gif"/><figcaption>20171112151041826167420.gif</figcaption></figure></p>

<p>像播放视频一样播放Gif动画<br/>
这部分是我在写完GifView后想到的一点进阶功能，既然我们已经实现了播放和暂停，即能控制在某个时间点播放指定的Gif图片帧，如果再加入进度条，快进等功能，那么不就能做到和视频播放器一样的功能了吗？限于篇幅，我只简单实现了进度条功能，更多功能实现请移步Github，地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Frenjianan%2FGifView">GifView</a></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041830828970.gif" alt="20171112151041830828970.gif"/><figcaption>20171112151041830828970.gif</figcaption></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872676.html">
                
                  <h1>Android-事件分发机制源码攻略</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>android事件分发算是自定义View不可缺失的一部分，事件分发是指那一类跟屏幕交互的操作等事件，例如滑动，点击，长按这类。这些事件都是由摁下、移动、抬起等基本事件组成的。那事件分发是指当你点击了屏幕，这个事件是如何从Activity传递到真正处理这个事件的View上的过程。例如，我们在做ListView跟ViewPager嵌套的时候，既能左右滑动，又能上下滑动，这些事件是如何避免彼此间的冲突的。下面我会分三节来介绍这一原理。<br/><br/>
首先，这次的源码分析是基于25.0.3版本进行的。</p>

<h2 id="toc_1">分发事件</h2>

<p>分发的事件主要是MotionEvent这个类所表示的点击、移动、抬起、取消等事件<br/><br/>
MotionEvent.ACTION_DOWN<br/><br/>
MotionEvent.ACTION_MOVE<br/><br/>
MotionEvent.ACTION_UP<br/><br/>
MotionEvent.ACTION_CANCEL<br/><br/>
…</p>

<h2 id="toc_2">分发的对象</h2>

<p>分发的对象是指收到上述事件的类</p>

<p>Activity<br/><br/>
ViewGroup<br/><br/>
View  </p>

<p>上述三个类是主要的事件分发对象，后期的讨论也是集中在这三个类里面。这里有个点得提一下就是ViewGroup是View的子类。这些事件会在这三者的dispatchTouchEvent、onTouchEvent这两个方法里面传递，还有一个ViewGroup特有的onInterceptTouchEvent方法。下面给出以上提到的类以及方法之间的关系。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041696377769.png" alt="20171112151041696377769.png"/><figcaption>20171112151041696377769.png</figcaption></figure></p>

<p>从这张图，我们可以看出，不同返回值，事件的分发方向不同，这里不做详细分析，这张图是否画得出来作为你对这次源码阅读的成绩。</p>

<h2 id="toc_3">Demo</h2>

<p><strong>Activity</strong></p>

<pre class="line-numbers"><code class="language-java">    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {

        Log.i(TAG,&quot;dispatchTouchEvent&quot;+ev.getAction());

        return super.dispatchTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        Log.i(TAG,&quot;onTouchEvent&quot;+event.getAction());
        return super.onTouchEvent(event);
    }
</code></pre>

<p><strong>CusViewGroup</strong></p>

<pre class="line-numbers"><code class="language-java">    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {

        Log.i(TAG,&quot;dispatchTouchEvent&quot;+ev.getAction());

        return super.dispatchTouchEvent(ev);
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {

        Log.i(TAG,&quot;onInterceptTouchEvent&quot;+ev.getAction());

        return super.onInterceptTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {

        Log.i(TAG,&quot;onTouchEvent&quot;+event.getAction());

        return super.onTouchEvent(event);
    }
</code></pre>

<p><strong>View</strong></p>

<pre class="line-numbers"><code class="language-java">    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {

        Log.i(TAG,&quot;dispatchTouchEvent&quot;+ev.getAction());

        return super.dispatchTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {

        Log.i(TAG,&quot;onTouchEvent&quot;+event.getAction());

        return super.onTouchEvent(event);
    }
</code></pre>

<p><strong>布局</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.example.coffeetime.cusviewdemo.CusLineaLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.example.coffeetime.cusviewdemo.MainActivity&quot;&gt;

    &lt;com.example.coffeetime.cusviewdemo.CusView
        android:layout_width=&quot;200dp&quot;
        android:layout_height=&quot;200dp&quot;
        android:background=&quot;@color/colorPrimary&quot;/&gt;

&lt;/com.example.coffeetime.cusviewdemo.CusLineaLayout&gt;
</code></pre>

<h2 id="toc_4">结果</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041703651591.png" alt="20171112151041703651591.png"/><figcaption>20171112151041703651591.png</figcaption></figure></p>

<blockquote>
<p>ACTION_DOWN的值为0 <br/>
ACTION_MOVE的值为1</p>
</blockquote>

<p>从输出的结果的第一行可以看出来最先获取事件的是Activity这一层，从倒数第三行可以看出，ACTION_DOWN这个事件最终消费是在Activity的onTouchEvent这个方法被消费。这个结果跟上面的图片是一致的。<br/><br/>
再看看输出结果的倒数两行，ACTION_MOVE事件从dispatchTouchEvent直接就传给了同级的onTouchEvent方法去了，说明ACTION_DOWN事件在哪里被消费了，后续事件也在那里消费，并且跳过中间传递。这个原因会在分析源码的时候给出解释。</p>

<h2 id="toc_5">Activity</h2>

<p>从上述的结果，我们可以得出事件最先被拦截的地方是从Activity的dispatchTouchEvent方法开始，那我们的源码攻略也从这里开始。</p>

<pre class="line-numbers"><code class="language-java"> /**
     * Called to process touch screen events.  You can override this to
     * intercept all touch screen events before they are dispatched to the
     * window.  Be sure to call this implementation for touch screen events
     * that should be handled normally.
     *
     * @param ev The touch screen event.
     *
     * @return boolean Return true if this event was consumed.
     */
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
</code></pre>

<p>这个方法首先判断事件类型，如果是ACTION_DOWN事件，则先执行onUserInteraction()方法；</p>

<pre class="line-numbers"><code class="language-text">public void onUserInteraction() {
}
</code></pre>

<blockquote>
<p>这个方法没有实现，根据文档注释，当有任意一个按键、触屏或者轨迹球事件发生时，栈顶Activity的onUserInteraction会被触发。如果我们需要知道用户是不是正在和设备交互，可以在子类中重写这个方法，去获取通知（比如取消屏保这个场景）。跟这个方法配对的还有onUserLeaveHint方法，这个方法是在用户离开设备的时候触发的。</p>
</blockquote>

<p>我们接着回到刚刚那个地方，判断完事件ACTION_DOWN事件之后，会执行getWindow().superDispatchTouchEvent(ev)这个方法，这个getWindow获取的是哪个Window呢，我们进去看看。</p>

<pre class="line-numbers"><code class="language-java">public Window getWindow() {
    return mWindow;
}
</code></pre>

<pre class="line-numbers"><code class="language-text">/**
 * Abstract base class for a top-level window look and behavior policy.  An
 * instance of this class should be used as the top-level view added to the
 * window manager. It provides standard UI policies such as a background, title
 * area, default key processing, etc.
 *
 * &lt;p&gt;The only existing implementation of this abstract class is
 * android.view.PhoneWindow, which you should instantiate when needing a
 * Window.
 */
public abstract class Window {}
</code></pre>

<p>通过这块注释，我们可以看出，window的实现类是phoneWindow。其实在Android里面很多都是可以通过阅读注释或者是官方文档去找出具体的实现类，不是只能依靠百度；好了，那我们可以直接进到phoneWindow类去看下superDispatchTouchEvent这个方法做了些什么</p>

<pre class="line-numbers"><code class="language-java">   @Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
    }
</code></pre>

<p>这个方法又是调用mDecor的同名方法去实现，mDecor又是什么</p>

<p><strong>phoneWindow</strong></p>

<pre class="line-numbers"><code class="language-text"> // This is the top-level view of the window, containing the window decor.
    private DecorView mDecor;
</code></pre>

<p><strong>DecorView</strong></p>

<pre class="line-numbers"><code class="language-text">    public boolean superDispatchTouchEvent(MotionEvent event) {
        return super.dispatchTouchEvent(event);
    }
</code></pre>

<p>DecorView 是window的顶级View，而DecorView是继承FrameLayout的布局，接着去FragmeLayout里面寻找dispatchTouchEvent方法，而FragmeLayout并没有实现这个方法，也即这个是直接交给ViewGroup去处理的。</p>

<h2 id="toc_6">小结</h2>

<p>在Activity层事件的传递过程如下图</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041706262125.png" alt="20171112151041706262125.png"/><figcaption>20171112151041706262125.png</figcaption></figure></p>

<p>从Activity的dispatchTouchEvent获取事件经过PhoneWindow、DecorView再到最终的ViewGroup，这一层代码比较简单，没有比较难分析的，只是经过的类比较多，其实只要把握的主线，分析起来还是比较简单的。这一篇比较少，下一篇是ViewGroup的分析，由于ViewGroup的源码比较多，所以才拆开来写，不然太长了。</p>

<h2 id="toc_7">ViewGroup</h2>

<blockquote>
<p>如果是ACTION_DOWN事件，就会去寻找子View来处理，如果找不到子View来处理，就自己处理。<br/><br/>
如果不是ACTION_DOWN事件，就会把这个事件传给处理了ACTION_DOWN事件的View来处理。</p>
</blockquote>

<p>大致就这两个逻辑，虽说比较粗略，不过，这对于接下来看源码就足够了，并且源码有比较多的注释，基本上大致的方向是可以弄懂了。</p>

<pre class="line-numbers"><code class="language-java">@Override
    public boolean dispatchTouchEvent(MotionEvent ev) {

        ... 
        //返回值的关键，注意留意handled的值发生改变的地方
        boolean handled = false;
        //判断当前window是否有被遮挡，true为分发这个事件，false为丢弃这个事件
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous
                // due to an app switch, ANR, or some other state change.
//在新的事件开始（即是新的ACTION_DOWN事件），需要清除掉之前的状态以及设置mFirstTouchTarget=null;
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }

            // Check for interception.
            final boolean intercepted;
            //子View唯一一个可以用来控制父类事件传递
            //只有ACTION_DOWN事件跟mFirstTouchTarget不为空的情况，后面的讨论大多是围绕着mFirstTouchTarget来进行的
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                //是否拦截事件，disallowIntercept为true是不拦截，false是拦截
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    //一般重写onInterceptTouchEvent方法
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            // If intercepted, start normal event dispatch. Also if there is already
            // a view that is handling the gesture, do normal event dispatch.
            if (intercepted || mFirstTouchTarget != null) {
                ev.setTargetAccessibilityFocus(false);
            }

            // Check for cancelation.
            final boolean canceled = resetCancelNextUpFlag(this)
                    || actionMasked == MotionEvent.ACTION_CANCEL;

            // Update list of touch targets for pointer down, if needed.
            //split是否分发给多个子View，默认为false
            final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;
            TouchTarget newTouchTarget = null;
            boolean alreadyDispatchedToNewTouchTarget = false;
            //如果不被拦截即可进入或者不是ACTION_CANCEL事件
            if (!canceled &amp;&amp; !intercepted) {

                // If the event is targeting accessiiblity focus we give it to the
                // view that has accessibility focus and if it does not handle it
                // we clear the flag and dispatch the event to all children as usual.
                // We are looking up the accessibility focused host to avoid keeping
                // state since these events are very rare.
                View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
                        ? findChildWithAccessibilityFocus() : null;
                //只有ACTION_DOWN等事件能够进入
                if (actionMasked == MotionEvent.ACTION_DOWN
                        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                    final int actionIndex = ev.getActionIndex(); // always 0 for down
                    final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                            : TouchTarget.ALL_POINTER_IDS;

                    // Clean up earlier touch targets for this pointer id in case they
                    // have become out of sync.
                    removePointersFromTouchTargets(idBitsToAssign);

                    final int childrenCount = mChildrenCount;
                    if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                        final float x = ev.getX(actionIndex);
                        final float y = ev.getY(actionIndex);
                        // Find a child that can receive the event.
                        // Scan children from front to back.
                        //获取按Z轴从大到小排序的子View列表
                        final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();
                        //是否有自定义顺序，一般为false
                        final boolean customOrder = preorderedList == null
                                &amp;&amp; isChildrenDrawingOrderEnabled();
                        final View[] children = mChildren;
                        for (int i = childrenCount - 1; i &gt;= 0; i--) {
                            //确认这个子View的下标
                            final int childIndex = getAndVerifyPreorderedIndex(
                                    childrenCount, i, customOrder);
                            //根据上面获得的下标，确认这个子View
                            final View child = getAndVerifyPreorderedView(
                                    preorderedList, children, childIndex);

                            // If there is a view that has accessibility focus we want it
                            // to get the event first and if not handled we will perform a
                            // normal dispatch. We may do a double iteration but this is
                            // safer given the timeframe.
                            // 如果当前视图无法获取用户焦点，则跳过本次循环
                            if (childWithAccessibilityFocus != null) {
                                if (childWithAccessibilityFocus != child) {
                                    continue;
                                }
                                childWithAccessibilityFocus = null;
                                i = childrenCount - 1;
                            }
                            //是否获得可见，并且落在child的布局范围内
                            if (!canViewReceivePointerEvents(child)
                                    || !isTransformedTouchPointInView(x, y, child, null)) {
                                ev.setTargetAccessibilityFocus(false);
                                continue;
                            }
                            //Child是否已经处理过事件了，有的话更改pointerIdBits值，并结束查找
                            newTouchTarget = getTouchTarget(child);
                            if (newTouchTarget != null) {
                                // Child is already receiving touch within its bounds.
                                // Give it the new pointer in addition to the ones it is handling.
                                newTouchTarget.pointerIdBits |= idBitsToAssign;
                                break;
                            }

                            resetCancelNextUpFlag(child);
                            //分发给View的dispatchTouchEvent
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                //给mFirstTouchTarget赋值，该事件已经被子View确认处理了
                                newTouchTarget = addTouchTarget(child, idBitsToAssign);
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }

                            // The accessibility focus didn&#39;t handle the event, so clear
                            // the flag and do a normal dispatch to all children.
                            ev.setTargetAccessibilityFocus(false);
                        }
                        if (preorderedList != null) preorderedList.clear();
                    }

                    if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                        // Did not find a child to receive the event.
                        // Assign the pointer to the least recently added target.
                        newTouchTarget = mFirstTouchTarget;
                        while (newTouchTarget.next != null) {
                            newTouchTarget = newTouchTarget.next;
                        }
                        newTouchTarget.pointerIdBits |= idBitsToAssign;
                    }
                }
            }

            // Dispatch to touch targets.
            // 没有子View处理，则自己处理
            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            } else {
                // Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                //处理除了ACTION_DOWN以外的事件
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        //如果这个事件被拦截了，intercepted为true
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        //如果事件被拦截掉，
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }

            // Update list of touch targets for pointer up or cancel, if needed.
            if (canceled
                    || actionMasked == MotionEvent.ACTION_UP
                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                resetTouchState();
            } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) {
                final int actionIndex = ev.getActionIndex();
                final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);
                removePointersFromTouchTargets(idBitsToRemove);
            }
        }

        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
        }
        return handled;
    }
</code></pre>

<p>像这么长的代码，很多地方是可以跳过的，不过仔仔细细分析，特别是像Google出品的（个人愚见），因为这些东西考虑的方方面面比较多，而我们这个只是为了了解事件的分发，绘制那块我们不会过多涉及。（说跑题了）回到正题来，像这么长的代码，之前学习的时候，有个牛人是这么写的（个人总结）。</p>

<blockquote>
<p>从结果出发，留意改变的结果的地方</p>
</blockquote>

<p>上面的dispatchTouchEvent返回值是由handle决定，我们先来看第一处第8行代码</p>

<pre class="line-numbers"><code class="language-java"> boolean handled = false;
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;
            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }
        ...
        }
        return false;
</code></pre>

<p>这个onFilterTouchEventForSecurity方法如果返回false的话，基本上里面的代码都不用分析了，直接返回false。那我们进去看看这个方法做了什么。</p>

<pre class="line-numbers"><code class="language-java">    /**
     * Filter the touch event to apply security policies.
     *
     * @param event The motion event to be filtered.
     * @return True if the event should be dispatched, false if the event should be dropped.
     *
     * @see #getFilterTouchesWhenObscured
     */
    public boolean onFilterTouchEventForSecurity(MotionEvent event) {
        //noinspection RedundantIfStatement
        if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0
                &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) {
            // Window is obscured, drop this touch.
            return false;
        }
        return true;
    }
</code></pre>

<p>这是一个安全策略方面的过滤，我们来看下这两个变量FILTER_TOUCHES_WHEN_OBSCURED、MotionEvent.FLAG_WINDOW_IS_OBSCURED是什么意思</p>

<pre class="line-numbers"><code class="language-text">    /**
     * Indicates that the view should filter touches when its window is obscured.
     * Refer to the class comments for more information about this security feature.
     * {@hide}
     */
    static final int FILTER_TOUCHES_WHEN_OBSCURED = 0x00000400;
</code></pre>

<pre class="line-numbers"><code class="language-text">    /**
     * This flag indicates that the window that received this motion event is partly
     * or wholly obscured by another visible window above it.  This flag is set to true
     * even if the event did not directly pass through the obscured area.
     * A security sensitive application can check this flag to identify situations in which
     * a malicious application may have covered up part of its content for the purpose
     * of misleading the user or hijacking touches.  An appropriate response might be
     * to drop the suspect touches or to take additional precautions to confirm the user&#39;s
     * actual intent.
     */
    public static final int FLAG_WINDOW_IS_OBSCURED = 0x1;
</code></pre>

<p>从上面的代码注释可以看出来，这个View不能被其他的window遮挡住，这是谷歌的一个安全策略，避免被恶意程序误导用户或劫持触摸。<br/><br/>
第二处handle的改变是在172行</p>

<pre class="line-numbers"><code class="language-java">        if (mFirstTouchTarget == null) {
               // No touch targets so treat this as an ordinary view.
               handled = dispatchTransformedTouchEvent(ev, canceled, null,
                    TouchTarget.ALL_POINTER_IDS);
        } else {
        ...
        while (target != null) {
                 final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child)
                            || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild,
                            target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                ...
</code></pre>

<p>很明显handled的值又跟mFirstTouchTarget、alreadyDispatchedToNewTouchTarget这两个值有关，另外还跟dispatchTransformedTouchEvent（）这个方法有关，dispatchTransformedTouchEvent（）方法，我们留在后面分析，我们先来看看这两个值是在什么时候在哪里被改变的。</p>

<pre class="line-numbers"><code class="language-java">         mLastTouchDownX = ev.getX();
         mLastTouchDownY = ev.getY();
         //给mFirstTouchTarget赋值，该事件已经被子View确认处理了
         newTouchTarget = addTouchTarget(child, idBitsToAssign);
         alreadyDispatchedToNewTouchTarget = true;
</code></pre>

<p>这个是第145行的代码，这里是找到处理事件的子View后，做的赋值，addTouchTarget这个方法里面会对 <br/>
mFirstTouchTarget赋值。</p>

<p>好了，如果是这样，我们再从上面的第13行开始分析。</p>

<pre class="line-numbers"><code class="language-text"> // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous
                // due to an app switch, ANR, or some other state change.
//在新的事件开始（即是新的ACTION_DOWN事件），需要清除掉之前的状态以及设置mFirstTouchTarget=null;
                cancelAndClearTouchTargets(ev);
                resetTouchState();
            }
</code></pre>

<p>这里先对该事件进行判断，如果是ACTION_DOWN事件会进到这个方法里面，做一些处理。我们来看下这两个方法都做了哪些。</p>

<pre class="line-numbers"><code class="language-text">    /**
     * Cancels and clears all touch targets.
     */
    private void cancelAndClearTouchTargets(MotionEvent event) {
        if (mFirstTouchTarget != null) {
            boolean syntheticEvent = false;
            //假如event为null,重新实例一个取消（MotionEvent）的事件
            if (event == null) {
                final long now = SystemClock.uptimeMillis();
                event = MotionEvent.obtain(now, now,
                        MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);
                event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
                syntheticEvent = true;
            }

            for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) {
                resetCancelNextUpFlag(target.child);
                //分发事件
                dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits);
            }
           //重置mFirstTouchTarget
            clearTouchTargets();

            if (syntheticEvent) {
                event.recycle();
            }
        }
    }
</code></pre>

<p>从这个方法的名字可以看出来，这个方法做了两件事取消跟清除TouchTarget，首先是取消，这里的取消是指分发ACTION_CANCEL事件，在我上面注释代码的第18行，dispatchTransformedTouchEvent（）这个方法的第二个参数为true，这个值会在更改事件为ACTION_CANCEL，并分发给上次处理事件的View。这个分发事件的方法，我们留在后面分析，现在继续分析清除。</p>

<pre class="line-numbers"><code class="language-text">    /**
     * Clears all touch targets.
     */
    private void clearTouchTargets() {
        TouchTarget target = mFirstTouchTarget;
        if (target != null) {
            do {
                TouchTarget next = target.next;
                target.recycle();
                target = next;
            } while (target != null);
            mFirstTouchTarget = null;
        }
    }
</code></pre>

<p>这个方法很简单了，就对TouchTarget的next是回收，最后再把mFirstTouchTarget置null。好了，这两个方法分析完，我们再回到刚刚的那个地方，看到还有一个方法resetTouchState（）</p>

<pre class="line-numbers"><code class="language-text">    /**
     * Resets all touch state in preparation for a new cycle.
     */
    private void resetTouchState() {
        clearTouchTargets();
        resetCancelNextUpFlag(this);
        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
        mNestedScrollAxes = SCROLL_AXIS_NONE;
    }
</code></pre>

<p>这个方法除了clearTouchTargets（）、resetCancelNextUpFlag()这两个方法外，还对 mGroupFlags 这个标志做一个拦截方面的修改，这个标志可以让子View请求父布局不要去拦截某个事件（ACTION_DOWN除外），并且可通过getParent().requestDisallowInterceptTouchEvent()去修改这个值。</p>

<pre class="line-numbers"><code class="language-text">  // Check for interception.
            final boolean intercepted;
            //子View唯一一个可以用来控制父类事件传递
            //只有ACTION_DOWN事件跟mFirstTouchTarget不为空的情况，后面的讨论大多是围绕着mFirstTouchTarget来进行的
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                //是否拦截事件，disallowIntercept为true是不拦截，false是拦截
                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    //一般重写onInterceptTouchEvent方法
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }
</code></pre>

<p>这里有个判断，只有ACTION_DOWN以及mFirstTouchTarget不为的空的情况下，才允许进入。我们来先说下，什么时候mFirstTouchTarget会不为空，我这边先简单说下，后面代码会提及；mFirstTouchTarget是在这个事件被所在的子View消费了，这个值才不会空，即使是本身ViewGroup消费了，这个值也是为空。按照这个思路的话，大家估计也不难理解我上面说的子View可以请求父布局对ACTION_DOWN以外的事件不做拦截，另外还有一点就是，一般重写只针对onInterceptTouchEvent这个方法，而dispatchTouchEvent这个方法倒是很少重写。像我们经常遇到的ViewPager跟ScrollView这个横竖滑动冲突的问题，你们去看这两个控件源码，就可以看到都是重写了onInterceptTouchEvent这个方法。</p>

<p>我们回到我上面提供的源码注解中，执行上述判断后，如果canceled跟intercepted都为false的话，并且这个事件为ACTION_DOWN事件，接下来将寻找满足消费条件的子View。我们来看下，是按照什么顺序来寻找View的。</p>

<p>按照我上面提供源码走下来，在87行处有着下面这个方法，这个方法主要是将子View按照Z轴的大小排序。</p>

<pre class="line-numbers"><code class="language-text">  ArrayList&lt;View&gt; buildOrderedChildList() {
        final int childrenCount = mChildrenCount;
        if (childrenCount &lt;= 1 || !hasChildWithZ()) return null;

        if (mPreSortedChildren == null) {
            mPreSortedChildren = new ArrayList&lt;&gt;(childrenCount);
        } else {
            // callers should clear, so clear shouldn&#39;t be necessary, but for safety...
            mPreSortedChildren.clear();
            mPreSortedChildren.ensureCapacity(childrenCount);
        }

        //自定义View排序
        final boolean customOrder = isChildrenDrawingOrderEnabled();
        for (int i = 0; i &lt; childrenCount; i++) {
            // add next child (in child order) to end of list
            final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            final View nextChild = mChildren[childIndex];
            final float currentZ = nextChild.getZ();

            // insert ahead of any Views with greater Z
            int insertIndex = i;
           //有点类似于插入排序，按Z轴从小到大排序
            while (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) {
                insertIndex--;
            }
            mPreSortedChildren.add(insertIndex, nextChild);
        }
        return mPreSortedChildren;
    }
</code></pre>

<p>其中getAndVerifyPreorderedIndex只是对View的下标进行再次确定。这里面提到一个自定义排序的问题，正常情况的布局排序是根据xml的顺序或者addView的顺序决定的。当然google也提供了setChildrenDrawingOrderEnabled（），getChildDrawingOrder（）这两个方法进行自定义排序，有需求的可以去自行了解下，我们就不深入探讨了。</p>

<pre class="line-numbers"><code class="language-text">  if (childWithAccessibilityFocus != null) {
        if (childWithAccessibilityFocus != child) {
              continue;
        }
        childWithAccessibilityFocus = null;
        i = childrenCount - 1;
  }
</code></pre>

<p>现在是取到了所有的子View，那么接下来就是筛选哪些View可以处理了。首先是先获取到哪个是获取焦点的View，并且这个View是否在这些子View里面。如果找到了就走到下一步。</p>

<pre class="line-numbers"><code class="language-text">//判断这个View是否具备处理的条件
if (!canViewReceivePointerEvents(child)
        || !isTransformedTouchPointInView(x, y, child, null)) {
    ev.setTargetAccessibilityFocus(false);
    continue;
}
</code></pre>

<p><strong>我们来看看第一个判断方法</strong></p>

<pre class="line-numbers"><code class="language-text">  /**
     * Returns true if a child view can receive pointer events.
     * @hide
     */
    private static boolean canViewReceivePointerEvents(@NonNull View child) {
        return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE
                || child.getAnimation() != null;
    }
</code></pre>

<p><strong>第二个方法</strong></p>

<pre class="line-numbers"><code class="language-text">/**
 * Returns true if a child view contains the specified point when transformed
 * into its coordinate space.
 * Child must not be null.
 * @hide
 */
protected boolean isTransformedTouchPointInView(float x, float y, View child,
        PointF outLocalPoint) {
    final float[] point = getTempPoint();
    point[0] = x;
    point[1] = y;
    transformPointToViewLocal(point, child);
    final boolean isInView = child.pointInView(point[0], point[1]);
    if (isInView &amp;&amp; outLocalPoint != null) {
        outLocalPoint.set(point[0], point[1]);
    }
    return isInView;
}
</code></pre>

<p>可见或者是正在执行动画的，并且位置是落在这个View的范围的。满足这些条件外，再判断这个View是否已经是在mFirstTouchTarget的子View里面了，如果是的话，也是结束循环了。</p>

<pre class="line-numbers"><code class="language-text">newTouchTarget = getTouchTarget(child);
if (newTouchTarget != null) {
    // Child is already receiving touch within its bounds.
    // Give it the new pointer in addition to the ones it is handling.
    newTouchTarget.pointerIdBits |= idBitsToAssign;
    break;
}
</code></pre>

<p>以上条件都满足的话，我们就进行分发事件的方法，我们来看下这个方法做了什么操作。</p>

<pre class="line-numbers"><code class="language-java">/**
     * Transforms a motion event into the coordinate space of a particular child view,
     * filters out irrelevant pointer ids, and overrides its action if necessary.
     * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.
     */
    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

        // Canceling motions is a special case.  We don&#39;t need to perform any transformations
        // or filtering.  The important part is the action, not the contents.
        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }

        // Calculate the number of pointers to deliver.
        final int oldPointerIdBits = event.getPointerIdBits();
        final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;

        // If for some reason we ended up in an inconsistent state where it looks like we
        // might produce a motion event with no pointers in it, then drop the event.
        if (newPointerIdBits == 0) {
            return false;
        }

        // If the number of pointers is the same and we don&#39;t need to perform any fancy
        // irreversible transformations, then we can reuse the motion event for this
        // dispatch as long as we are careful to revert any changes we make.
        // Otherwise we need to make a copy.
        final MotionEvent transformedEvent;
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                    handled = super.dispatchTouchEvent(event);
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event);

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }

        // Perform any necessary transformations and dispatch.
        if (child == null) {
            handled = super.dispatchTouchEvent(transformedEvent);
        } else {
            final float offsetX = mScrollX - child.mLeft;
            final float offsetY = mScrollY - child.mTop;
            transformedEvent.offsetLocation(offsetX, offsetY);
            if (! child.hasIdentityMatrix()) {
                transformedEvent.transform(child.getInverseMatrix());
            }

            handled = child.dispatchTouchEvent(transformedEvent);
        }

        // Done.
        transformedEvent.recycle();
        return handled;
    }
</code></pre>

<p>这个方法一看就有点长了，慌不慌~其实这个方法就做了两件事，第一件事，就是如果cancel为true的话，更改这个事件为ACTION_CANCEL；第二件事，就是child为null的话，调用super.dispatchTouchEvent(event);child不为空的话，就调用super.dispatchTouchEvent(event);好吧，其实这个方法，只需要看上面那部分就差不多了。</p>

<pre class="line-numbers"><code class="language-text">...
if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
                handled = super.dispatchTouchEvent(event);
            } else {
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }
...
</code></pre>

<p>精简版的分发~~~</p>

<p>如果dispatchTransformedTouchEvent方法返回true的话，就代表了这个事件已经被子View消费了，接下来关键的方法就是调用addTouchTarget（）这个方法，给mFirstTouchTarget赋值。</p>

<pre class="line-numbers"><code class="language-text"> /**
     * Adds a touch target for specified child to the beginning of the list.
     * Assumes the target child is not already present.
     */
    private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget;
        mFirstTouchTarget = target;
        return target;
    }
</code></pre>

<p>如果dispatchTransformedTouchEvent方法返回false的话，那么就代表这个事件没有View消费，那就是只能自己消费了</p>

<pre class="line-numbers"><code class="language-text"> if (mFirstTouchTarget == null) {
           // No touch targets so treat this as an ordinary view.
           handled = dispatchTransformedTouchEvent(ev, canceled, null,
                   ouchTarget.ALL_POINTER_IDS);
 }
</code></pre>

<p>其实到这里，整个ACTION_DOWN事件的传递就结束了。我们来做了小结，当有触摸事件传递过来时</p>

<ol>
<li><p>先对当前设备状态进行判断，是否没被遮挡</p></li>
<li><p>紧接着如果是ACTION_DOWN事件的话，就清除状态</p></li>
<li><p>如果onInterceptTouchEvent返回true，则事件交给自己处理</p></li>
<li><p>如果是ACTION_DOWN事件的话，先去寻找获得焦点的View，如果找到了，就分发给View去处理；如果找不到就交给自己处理。</p></li>
</ol>

<p>接着我们再来说下除了ACTION_DOWN以外的事件传递情况，从上面的demo我们可以得知，消费了ACTION_DOWN事件，后续的事件也将给这个View消费。也即是mFirstTouchTarget != null的情况。</p>

<pre class="line-numbers"><code class="language-java">// Dispatch to touch targets, excluding the new touch target if we already
                // dispatched to it.  Cancel touch targets if necessary.
                //处理除了ACTION_DOWN以外的事件
                TouchTarget predecessor = null;
                TouchTarget target = mFirstTouchTarget;
                while (target != null) {
                    final TouchTarget next = target.next;
                   //alreadyDispatchedToNewTouchTarget为true的话，说明已经被消费了
                    if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) {
                        handled = true;
                    } else {
                        final boolean cancelChild = resetCancelNextUpFlag(target.child)
                                || intercepted;
                        //如果这个事件被拦截了，intercepted为true
                        if (dispatchTransformedTouchEvent(ev, cancelChild,
                                target.child, target.pointerIdBits)) {
                            handled = true;
                        }
                        //如果事件被拦截掉，
                        if (cancelChild) {
                            if (predecessor == null) {
                                mFirstTouchTarget = next;
                            } else {
                                predecessor.next = next;
                            }
                            target.recycle();
                            target = next;
                            continue;
                        }
                    }
                    predecessor = target;
                    target = next;
                }
            }
</code></pre>

<p>上面代码的第9行，这一块的的判断我们可以回溯到之前的mFirstTouchTarget赋值，也即是addTouchTarget()这个方法。可以发现，上述的判断如果为true，说明这个事件已经被消费了，所以handled就为true了。</p>

<p>上面代码的第12行，如果intercepted为true的话，那cancelChild也就为true了。而dispatchTransformedTouchEvent（）上面已经分析过，cancelChild为true，会向之前消费事件的View发送ACTION_CANCEL事件。后面再把mFirstTouchTarget置成next，也即是null，那么接下来的事件将被本身给消费掉。这也验证了我们上面的demo。当然，大家也可以多做几个例子好好理解理解。</p>

<p>下面是整个dispatchTouchEvent()里面关键方法的调用流程，可以方便理解。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041743495516.png" alt="20171112151041743495516.png"/><figcaption>20171112151041743495516.png</figcaption></figure></p>

<p>好了，整个ViewGroup层dispatchTouchEvent传递到View层的dispatchTouchEvent或者传递给super.dispatchTouchEvent(event)，下一节将对View层的源码进行解析。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872628.html">
                
                  <h1>Android-自定义曲线路径动画框架</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>最近在一个项目中需要一个像QQ打开个人爱好那样的动画效果如下图:</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041618224358.gif" alt="20171112151041618224358.gif"/><figcaption>20171112151041618224358.gif</figcaption></figure></p>

<p>可以看出每个小球都是以顺时针旋转出来的,说明像这样的曲线动画用Android中自带的平移动画是很难实现的。</p>

<p>曲线动画怎么画???</p>

<p>我们先来看看Android自带的绘制曲线的方式是怎样的:</p>

<p>android自定义View中画图经常用到这几个什么什么To</p>

<h3 id="toc_1">moveTo</h3>

<p>moveTo 不会进行绘制，只用于移动移动画笔,也就是确定绘制的起始坐标点。结合以下方法进行使用。</p>

<h3 id="toc_2">lineTo</h3>

<p>lineTo 用于进行直线绘制。</p>

<pre class="line-numbers"><code class="language-java">mPath.lineTo(300, 300);
canvas.drawPath(mPath, mPaint);
</code></pre>

<p>默认从坐标(0,0)开始绘制。</p>

<p>刚才我们不是说了moveTo是用来移动画笔的吗？</p>

<pre class="line-numbers"><code class="language-java">mPath.moveTo(100, 100);
mPath.lineTo(300, 300);
canvas.drawPath(mPath, mPaint);
</code></pre>

<p>把画笔移动(100,100)处开始绘制</p>

<h3 id="toc_3">quadTo</h3>

<p>quadTo 用于绘制圆滑曲线，即贝塞尔曲线。</p>

<h3 id="toc_4">cubicTo</h3>

<p>cubicTo 同样是用来实现贝塞尔曲线的。mPath.cubicTo(x1, y1, x2, y2, x3, y3) (x1,y1) 为控制点，(x2,y2)为控制点，(x3,y3) 为结束点。那么，cubicTo 和 quadTo 有什么不一样呢？说白了，就是多了一个控制点而已。然后，我们想绘制和上一个一样的曲线，应该怎么写呢？</p>

<pre class="line-numbers"><code class="language-java">mPath.moveTo(100, 500);
mPath.cubicTo(100, 500, 300, 100, 600, 500);
</code></pre>

<p>一模一样！如果我们不加 moveTo 呢？</p>

<p>则以(0,0)为起点，(100,500)和(300,100)为控制点绘制贝塞尔曲线</p>

<p>受到上面的启发,我们也可以用同样的方法来实现一个曲线动画框架</p>

<p>在写框架之前我们必须要先了解一样东西:</p>

<h2 id="toc_5">贝塞尔曲线:</h2>

<p>维基百科中这样说到:</p>

<p>在数学的数值分析领域中，贝塞尔曲线（英语：Bézier curve）是计算机图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。</p>

<p>贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。</p>

<h3 id="toc_6">线性贝塞尔曲线</h3>

<p>给定点P0、P1，线性贝塞尔曲线只是一条两点之间的直线。这条线由下式给出：</p>

<p>B(t) = P0 + (P1 - P0)t = (1 - t)P0 + tP1,t-&gt;[0,1]</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041640123831.gif" alt="20171112151041640123831.gif"/><figcaption>20171112151041640123831.gif</figcaption></figure></p>

<h3 id="toc_7">二次方贝塞尔曲线</h3>

<p>二次方贝塞尔曲线的路径由给定点P0、P1、P2的函数B（t）追踪：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041650962507.png" alt="20171112151041650962507.png"/><figcaption>20171112151041650962507.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017111215104165256666.gif" alt="2017111215104165256666.gif"/><figcaption>2017111215104165256666.gif</figcaption></figure></p>

<h3 id="toc_8">三次方贝塞尔曲线</h3>

<p>P0、P1、P2、P3四个点在平面或在三维空间中定义了三次方贝塞尔曲线。曲线起始于P0走向P1，并从P2的方向来到P3。一般不会经过P1或P2；这两个点只是在那里提供方向资讯。P0和P1之间的间距，决定了曲线在转而趋进P2之前，走向P1方向的“长度有多长”。</p>

<p>曲线的参数形式为：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041654896085.png" alt="20171112151041654896085.png"/><figcaption>20171112151041654896085.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041656320256.gif" alt="20171112151041656320256.gif"/><figcaption>20171112151041656320256.gif</figcaption></figure></p>

<p>以上都是维基百科给出的定义,以及不同曲线的公式和效果图; 如果不清楚可以自己百度搜索或者维基百科搜索,么么哒!</p>

<h3 id="toc_9">一般贝塞尔曲线方程</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041657814861.png" alt="20171112151041657814861.png"/><figcaption>20171112151041657814861.png</figcaption></figure></p>

<p>对于四次曲线，可由线性贝塞尔曲线描述的中介点Q0、Q1、Q2、Q3，由二次贝塞尔曲线描述的点R0、R1、R2，和由三次贝塞尔曲线描述的点S0、S1所建构：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041659410068.gif" alt="20171112151041659410068.gif"/><figcaption>20171112151041659410068.gif</figcaption></figure></p>

<p>那么在上代码之前先看看我们最后实现出来的效果图:</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151041661322165.gif" alt="20171112151041661322165.gif"/><figcaption>20171112151041661322165.gif</figcaption></figure></p>

<p>PathPoint.java中的代码:</p>

<pre class="line-numbers"><code class="language-java">/**
 * Created by zhengliang on 2016/10/15 0015.
 * 记录view移动动作的坐标点
 */

public class PathPoint {
    /**
     * 起始点操作
     */
    public static final int MOVE=0;
    /**
     * 直线路径操作
     */
    public static final int LINE=1;
    /**
     * 二阶贝塞尔曲线操作
     */
    public static final int SECOND_CURVE =2;
    /**
     * 三阶贝塞尔曲线操作
     */
    public static final int THIRD_CURVE=3;
    /**
     * View移动到的最终位置
     */
    public float mX,mY;
    /**
     * 控制点
     */
    public float mContorl0X,mContorl0Y;
    public float mContorl1X,mContorl1Y;
    //操作符
    public int mOperation;

    /**
     * Line/Move都通过该构造函数来创建
     */
    public PathPoint(int mOperation,float mX, float mY ) {
        this.mX = mX;
        this.mY = mY;
        this.mOperation = mOperation;
    }

    /**
     * 二阶贝塞尔曲线
     * @param mX
     * @param mY
     * @param mContorl0X
     * @param mContorl0Y
     */
    public PathPoint(float mContorl0X, float mContorl0Y,float mX, float mY) {
        this.mX = mX;
        this.mY = mY;
        this.mContorl0X = mContorl0X;
        this.mContorl0Y = mContorl0Y;
        this.mOperation = SECOND_CURVE;
    }

    /**
     * 三阶贝塞尔曲线
     * @param mContorl0x
     * @param mContorl0Y
     * @param mContorl1x
     * @param mContorl1Y
     * @param mX
     * @param mY
     */
    public PathPoint(float mContorl0x, float mContorl0Y, float mContorl1x, float mContorl1Y,float mX, float mY) {
        this.mX = mX;
        this.mY = mY;
        this.mContorl0X = mContorl0x;
        this.mContorl0Y = mContorl0Y;
        this.mContorl1X = mContorl1x;
        this.mContorl1Y = mContorl1Y;
        this.mOperation = THIRD_CURVE;
    }

    /**
     * 为了方便使用都用静态的方法来返回路径点
     */
    public static PathPoint moveTo(float x, float y){
        return new PathPoint(MOVE,x,y);
    }
    public static PathPoint lineTo(float x,float y){
        return  new PathPoint(LINE,x,y);
    }
    public static PathPoint secondBesselCurveTo(float c0X, float c0Y,float x,float y){
        return new PathPoint(c0X,c0Y,x,y);
    }
    public static PathPoint thirdBesselCurveTo(float c0X, float c0Y, float c1X, float c1Y, float x, float y){
        return new PathPoint(c0X,c0Y,c1X,c1Y,x,y);
    }
}
</code></pre>

<p>这个类主要是用来记录View移动动作的坐标点,通过不同的构造函数传入不同的参数来区分不同的移动轨迹,注释写的很清楚的…</p>

<p>为了让不同类型的移动方式都能在使用时一次性使用我写了一个AnimatorPath类</p>

<pre class="line-numbers"><code class="language-java">import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Created by zhengliang on 2016/10/15 0015.
 * 客户端使用类,记录一系列的不同移动轨迹
 */

public class AnimatorPath {
    //一系列的轨迹记录动作
    private List&lt;PathPoint&gt; mPoints = new ArrayList&lt;&gt;();

    /**
     * 移动位置到:
     * @param x
     * @param y
     */
    public void moveTo(float x,float y){
        mPoints.add(PathPoint.moveTo(x,y));
    }

    /**
     * 直线移动
     * @param x
     * @param y
     */
    public void lineTo(float x,float y){
        mPoints.add(PathPoint.lineTo(x,y));
    }

    /**
     * 二阶贝塞尔曲线移动
     * @param c0X
     * @param c0Y
     * @param x
     * @param y
     */
    public void secondBesselCurveTo(float c0X, float c0Y,float x,float y){
        mPoints.add(PathPoint.secondBesselCurveTo(c0X,c0Y,x,y));
    }

    /**
     * 三阶贝塞尔曲线移动
     * @param c0X
     * @param c0Y
     * @param c1X
     * @param c1Y
     * @param x
     * @param y
     */
    public void thirdBesselCurveTo(float c0X, float c0Y, float c1X, float c1Y, float x, float y){
        mPoints.add(PathPoint.thirdBesselCurveTo(c0X,c0Y,c1X,c1Y,x,y));
    }
    /**
     *
     * @return  返回移动动作集合
     */
    public Collection&lt;PathPoint&gt; getPoints(){
        return mPoints;
    }
}
</code></pre>

<p>该类是最终在客户端使用的,记录一系列的不同移动轨迹,使用时调用里面的方法就可以添加不同的移动轨迹最后通过getPoints()来得到所有的移动轨迹集合</p>

<p>在Android自带的绘制曲线的方法中都是只是通过moveTo()方法设置起始点,在其它的方法中只是传入了终点或控制点坐标。实际上我们要画连续的曲线或连续的移动时,都需要知道起点到终点的之间所有的坐标,哪么怎么来的到这些点的坐标?</p>

<p>Android中为我们提供了一个泛型的接口:TypeEvaluator<T>可以很简单的实现这个难题。这里我就把它叫做”估值器”.我们只要创建一个类来实现这个接口,然后通过自己计算公式(就是我们上面的贝塞尔曲线公式)</p>

<p>下面来看看我项目中的估值器类:PathEvaluator</p>

<pre class="line-numbers"><code class="language-java">import android.animation.TypeEvaluator;

/**
 * Created by zhengliang on 2016/10/15 0015.
 * 估值器类,实现坐标点的计算
 */

public class PathEvaluator implements TypeEvaluator&lt;PathPoint&gt; {

    /**
     * @param t          :执行的百分比
     * @param startValue : 起点
     * @param endValue   : 终点
     * @return
     */
    @Override
    public PathPoint evaluate(float t, PathPoint startValue, PathPoint endValue) {
        float x, y;
        float oneMiunsT = 1 - t;
        //三阶贝塞尔曲线
        if (endValue.mOperation == PathPoint.THIRD_CURVE) {
            x = startValue.mX*oneMiunsT*oneMiunsT*oneMiunsT+3*endValue.mContorl0X*t*oneMiunsT*oneMiunsT+3*endValue.mContorl1X*t*t*oneMiunsT+endValue.mX*t*t*t;
            y = startValue.mY*oneMiunsT*oneMiunsT*oneMiunsT+3*endValue.mContorl0Y*t*oneMiunsT*oneMiunsT+3*endValue.mContorl1Y*t*t*oneMiunsT+endValue.mY*t*t*t;
        //二阶贝塞尔曲线
        }else if(endValue.mOperation == PathPoint.SECOND_CURVE){
            x = oneMiunsT*oneMiunsT*startValue.mX+2*t*oneMiunsT*endValue.mContorl0X+t*t*endValue.mX;
            y = oneMiunsT*oneMiunsT*startValue.mY+2*t*oneMiunsT*endValue.mContorl0Y+t*t*endValue.mY;
        //直线
        }else if (endValue.mOperation == PathPoint.LINE) {
            //x起始点+t*起始点和终点的距离
            x = startValue.mX + t * (endValue.mX - startValue.mX);
            y = startValue.mY + t * (endValue.mY - startValue.mY);
        } else {
            x = endValue.mX;
            y = endValue.mY;
        }
        return PathPoint.moveTo(x,y);
    }
}
</code></pre>

<p>泛型中传入我们自己的定义的PathPoint类;其实这些复杂的计算代码很简单,就是上面贝塞尔曲线的公式,将需要的点直接带入公式即可,我相信仔细看看会明白的!</p>

<p>核心代码到这里就没有了,下面看看MainActivity中的代码:</p>

<pre class="line-numbers"><code class="language-java">public class MainActivity extends AppCompatActivity implements View.OnClickListener {
    private FloatingActionButton fab;
    private AnimatorPath path;//声明动画集合
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        this.fab = (FloatingActionButton) findViewById(R.id.fab);

        setPath();

        fab.setOnClickListener(this);
    }
    /*设置动画路径*/
    public void setPath(){
        path = new AnimatorPath();
        path.moveTo(0,0);
        path.lineTo(400,400);
        path.secondBesselCurveTo(600, 200, 800, 400); //订单
        path.thirdBesselCurveTo(100,600,900,1000,200,1200);
    }

    /**
     * 设置动画
     * @param view
     * @param propertyName
     * @param path
     */
    private void startAnimatorPath(View view, String propertyName, AnimatorPath path) {
        ObjectAnimator anim = ObjectAnimator.ofObject(this, propertyName, new PathEvaluator(), path.getPoints().toArray());
        anim.setInterpolator(new DecelerateInterpolator());//动画插值器
        anim.setDuration(3000);
        anim.start();
    }

    /**
     * 设置View的属性通过ObjectAnimator.ofObject()的反射机制来调用
     * @param newLoc
     */
    public void setFab(PathPoint newLoc) {
        fab.setTranslationX(newLoc.mX);
        fab.setTranslationY(newLoc.mY);
    }

    @Override
    public void onClick(View view) {
        switch (view.getId()){
            case R.id.fab:
                startAnimatorPath(fab, &quot;fab&quot;, path);
                break;
        }
    }
}
</code></pre>

<p>上面代码中的:setPath()方法根据你自己项目的需要来设置不同的坐标 注意:(“这里的坐标是View以当前位置的偏移坐标,不是绝对坐标”)</p>

<p>上面代码中的:startAnimatorPath()参数就不介绍了注释中写的很清楚;这里直接看看ObjectAnimator.ofObject()方法的使用把:</p>

<p><code>ObjectAnimator.ofObject(this, propertyName, new PathEvaluator(), path.getPoints().toArray())</code></p>

<p>参数:this:View</p>

<p>参数:propertyName:属性名字 :起始这个名字是一个反射机制的调用,这样说不明白,看看这条代码:</p>

<p><code>ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 0f, 1f).setDuration(500).start();</code></p>

<p>相信这句代码都能看懂,其中”scaleX”就相当于参数:propertyName</p>

<p>项目代码中我们传入的参数是:</p>

<p><code>startAnimatorPath(fab, &quot;fab&quot;, path);</code></p>

<p>“fab”参数其实对应的就是setFab(PathPoint newLoc)方法,当我们在当前类中定义了该方法,就会自动通过反射的机制来调用该方法! ,如果还不懂,可以看看其它大神写的博客!</p>

<p>看看Xml中的代码:</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/activity_main&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;
    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;
    tools:context=&quot;zhengliang.com.customanimationframework.MainActivity&quot;&gt;

    &lt;zhengliang.com.customanimationframework.CustomView.PathView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        tools:targetApi=&quot;lollipop&quot; /&gt;
    &lt;android.support.design.widget.FloatingActionButton
        android:id=&quot;@+id/fab&quot;
        android:layout_width=&quot;40dp&quot;
        android:layout_height=&quot;40dp&quot;
        /&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>为了可以清晰的看见小球的移动轨迹,自定义了以个View来显示小球的运动轨迹:</p>

<pre class="line-numbers"><code class="language-java">public class PathView extends View {

    private Paint paint;


    public PathView(Context context, AttributeSet attrs) {
        super(context, attrs);
        initView();
    }

    private void initView() {
        paint = new Paint();
        //抗锯齿
        paint.setAntiAlias(true);
        //防抖动
        paint.setDither(true);
        //设置画笔未实心
        paint.setStyle(Paint.Style.STROKE);
        //设置颜色
        paint.setColor(Color.GREEN);
        //设置画笔宽度
        paint.setStrokeWidth(3);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        Path path = new Path();
        path.moveTo(60,60);
        path.lineTo(460,460);
        path.quadTo(660, 260, 860, 460); //订单
        path.cubicTo(160,660,960,1060,260,1260);
        canvas.drawPath(path,paint);
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872492.html">
                
                  <h1>Android-转场动画深度解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Android5.0之后新增了很多好看的转场动画，相比于以前的overridePendingTransition()丰富了很多，特别新增了共享元素跳转的方式。本篇文章介绍转场动画框架的基本概念，并着手自己实现转场动画。</p>

<h2 id="toc_0">Scene（场景）</h2>

<p>Scene保存了一个布局文件。我们可以通过以下方式生成一个Scene：</p>

<p><code>public static Scene getSceneForLayout(ViewGroup sceneRoot, int layoutId, Context context)</code></p>

<p>这个方法时静态的，传入一个根布局ViewGroup(作为显示场景的容器),一个layoutId(场景的显示内容),最后传入当前上下文。源码很短，我们一起来看一下：</p>

<pre class="line-numbers"><code class="language-java">public static Scene getSceneForLayout(ViewGroup sceneRoot, int layoutId, Context context) {
        SparseArray&lt;Scene&gt; scenes = (SparseArray&lt;Scene&gt;) sceneRoot.getTag(
                com.android.internal.R.id.scene_layoutid_cache);
        if (scenes == null) {
            scenes = new SparseArray&lt;Scene&gt;();
            sceneRoot.setTagInternal(com.android.internal.R.id.scene_layoutid_cache, scenes);
        }
        Scene scene = scenes.get(layoutId);
        if (scene != null) {
            return scene;
        } else {
            scene = new Scene(sceneRoot, layoutId, context);
            scenes.put(layoutId, scene);
            return scene;
        }
    }
</code></pre>

<ul>
<li>根据一个固定的Tag取得保存依附于这个ViewGroup的scene集合SparseArray<Scene> scenes,如果是空就先new一个。</li>
<li>以要显示场景的layoutId为Key，先尝试获取这个场景，如果已经有这个layoutId对应的场景就直接返回，没有就先调用构造方法生成一个再放入进去，然后返回。</li>
<li>一个scene只能对应一个布局，scene只是简单保存了sceneRoot, layoutId, context的值，并没有通过layoutId来分析处理里面的View信息（也没有必要）</li>
<li>可以通过<code>setEnterAction(Runnable action)</code>,<code>setExitAction(Runnable action)</code>，在场景被加载和移除时回调，做相应的操作。</li>
</ul>

<h2 id="toc_1">Transition(变换）</h2>

<p>上面的介绍scene将一个或多个布局和一个加载这些布局的根布局建立起关系。真正的动画是由Transition实现的。所以大致的流程是：</p>

<pre class="line-numbers"><code class="language-java">//为Scene创建scene root  
mSceneRoot = (ViewGroup) findViewById(R.id.scene_root);  
//创建 scenes  
Scene mAScene = Scene.getSceneForLayout(mSceneRoot, R.layout.a_scene, this);  
Scene mAnotherScene =  Scene.getSceneForLayout(mSceneRoot, R.layout.another_scene, this);
  //代码中创建Transition
Transition mFadeTransition = new Fade();  
//用TransitionManager负责场景变换
TransitionManager.go(mEndingScene, mFadeTransition);
</code></pre>

<h2 id="toc_2">自定义Transition</h2>

<p>Transition是个抽象类，必须要实现以下方法：</p>

<ul>
<li><code>public abstract void captureStartValues(TransitionValues transitionValues);</code>捕获当前场景的视图，这里会对视图树中所有的View调用，有几个View就会调用几次。</li>
<li><code>public abstract void captureEndValues(TransitionValues transitionValues);</code>捕获目标场景的视图，这里会对视图树中所有的View调用，有几个View就会调用几次。</li>
<li><code>public Animator createAnimator(ViewGroup sceneRoot, TransitionValues startValues,TransitionValues endValues)</code>（不实现方法这个就没动画效果）从命名就可以看到captureStartValues和captureStartValues分别用来捕获当前场景和目标场景。</li>
</ul>

<p>TransitionValues有三个重要属性，对理解Transition框架的机制有很大帮助。</p>

<ul>
<li><code>View view</code>:就是一个场景的一个View,在里面拿到View，我们可以从里面得到这个View我们所需要的属性。</li>
<li><code>Map&lt;String, Object&gt; values</code>：默认为空，我们拿到属性后需要放到里面，如果这个Transition需要改变多个属性，就可以放多次进去。</li>
<li><code>ArrayList&lt;Transition&gt; targetedTransitions</code>：默认为空，用来记录这个View执行了哪些Transition，我们可以在对这个View执行Transition的时候，把这个Transition存进去。</li>
</ul>

<p>createAnimator方法就是Transition真正的实现方法了，返回一个属性动画。<br/>
好了实战开始，我们就实现一个Transition来实现直角移动：</p>

<pre class="line-numbers"><code class="language-java">public class ChangeRect extends Transition {

    private static final String PROPNAME_BER =
            &quot;changeposition:Rect&quot;;

    // 开始的状态，这里会对视图树中所有的View调用，这里我们可以记录一下View的我们感兴趣的状态，比如这里：position
    @Override
    public void captureStartValues(TransitionValues transitionValues) {
        captureValues(transitionValues);

    }

    // 结束也会对所有的View进行调用
    @Override
    public void captureEndValues(TransitionValues transitionValues) {
        captureValues(transitionValues);
    }

    private void captureValues(TransitionValues transitionValues) {
        float[] location = new float[2];
        location[0] = transitionValues.view.getX();
        location[1] = transitionValues.view.getY();
        transitionValues.values.put(PROPNAME_BER, location);
    }

    //新建动画
    @Override
    public Animator createAnimator(ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues) {
        if (null == startValues || null == endValues) {
            return null;
        }
        final View view = endValues.view;
        float[] startPosition = (float[]) startValues.values.get(PROPNAME_BER);
        float[] endPosition = (float[]) endValues.values.get(PROPNAME_BER);

        if (startPosition[0] != endPosition[0] || startPosition[1] != endPosition[1]) {
            Path path=new Path();
            path.moveTo(startPosition[0],startPosition[1]);
            path.lineTo(endPosition[0],startPosition[1]);
            path.lineTo(endPosition[0],endPosition[1]);
            ObjectAnimator animator = ObjectAnimator.ofFloat(view, View.X, View.Y, path);
            animator.setDuration(getDuration());
            animator.start();

            return animator;
        }
        return null;
    }
}
</code></pre>

<h2 id="toc_3">总结</h2>

<p>简述下Transition框架的执行机制，我们定义了两个Scene，，当我们通过  <code>TransitionManager.go( scene , transition)</code>，从Scene跳转到目标Scene的时候，会去取得scene对应布局，遍历布局中的每一个View（包括根布局和容器View），获取我们需要的属性。通过View的Id我们建立起两个布局中View的对应关系，所以最终只会在目标场景执行原场景有相同Id的View的动画（满足startValues != null &amp;&amp;  endValues!= null）。这篇文章只是简单解析了转场动画的原理，详细的两个页面的跳转将会的下一篇展开。</p>

<h2 id="toc_4">Content Transition</h2>

<p>Content Transition就是最常见的转场动画了。为了方便大家理解，我们先来上个图。</p>

<p>部分代码：</p>

<h3 id="toc_5">源Activity：</h3>

<pre class="line-numbers"><code class="language-java">Slide slide=new Slide();
slide.setDuration(3000);
slide.setSlideEdge(Gravity.BOTTOM);
getWindow().setExitTransition(slide);

Explode explode = new Explode();
explode.setDuration(3000);
explode.setMode(Visibility.MODE_IN);
getWindow().setReenterTransition(explode);
</code></pre>

<h3 id="toc_6">目标Activity：</h3>

<pre class="line-numbers"><code class="language-java">Slide slideEnter=new Slide();
slideEnter.setDuration(1500);
slideEnter.setSlideEdge(Gravity.RIGHT);
getWindow().setEnterTransition(slideEnter);

Slide slide=new Slide();
slide.setDuration(1500);
slide.setSlideEdge(Gravity.RIGHT);
getWindow().setReturnTransition(slide);
</code></pre>

<p>然后在A页面调用方法跳到B页面：</p>

<pre class="line-numbers"><code class="language-java">Intent intent = new Intent(this, BActivity.class);
ActivityOptionsCompat activityOptionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(this);
startActivity(intent, activityOptionsCompat.toBundle());
</code></pre>

<p>可以看到一共可以设置四个Transition：</p>

<ul>
<li>(1)setExitTransition() - 当A 跳转到 B时,A中的View退出场景的效果（默认Null）</li>
<li>(2)setEnterTransition() - 当A 跳转到 B时，B中的View进入场景的效果（默认Fade）</li>
<li>(3)setReturnTransition() - 当B 返回 A时,B中的View退出场景的效果（默认同EnterTransition）</li>
<li>(4)setReenterTransition() - 当B 返回 A时,A中的View进入场景的效果（默认同ExitTransition）</li>
</ul>

<p>以上这个过程同样可以看做是Transition作用在Scene上的一系列效果，只不过这里的Scene从上一篇中的单一布局换成了Window。不过细心的同学可能发现了，明明我为四个过程都设置动画效果，可为什么ExitTransition没有生效呢？接下来我们为每个Transition加入监听，看看动画的执行流程。下面是其中一个的代码，其他三个都一样：</p>

<pre class="line-numbers"><code class="language-java">Explode explode = new Explode();
explode.setDuration(3000);
explode.setMode(Visibility.MODE_IN);
  explode.addListener(new Transition.TransitionListener(){
            @Override
            public void onTransitionStart(Transition transition) {

                Log.d(&quot;Transitions--&quot;,&quot;ReenterTransitionStart&quot;);
            }

            @Override
            public void onTransitionEnd(Transition transition) {

                Log.d(&quot;Transitions--&quot;,&quot;ReenterTransitionEnd&quot;);
            }

            @Override
            public void onTransitionCancel(Transition transition) {

            }

            @Override
            public void onTransitionPause(Transition transition) {

            }

            @Override
            public void onTransitionResume(Transition transition) {

            }
        });
   getWindow().setReenterTransition(explode);
</code></pre>

<p>再次执行程序，日志信息如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151041141118718.png" alt="20171111151041141118718.png"/><figcaption>20171111151041141118718.png</figcaption></figure></p>

<p>原来A页面的退出动画和B页面的进入动画、B页面的返回动画和A页面的重现动画是并行执行的。也就是说A页面的ExitTransition不是没有执行，而是在它执行的时候，B页面已经覆盖上来，并且EnterTransition已经同时在执行了，这时A页面已经不可见了。这也是Android默认的转场动画执行流程。<br/><br/>
那问题来了，如果想要并行执行该怎么办呢？<br/><br/>
有两种方法：<br/><br/>
在设置Transition的时候同时设置不允许Transition重叠，也就是并行执行：</p>

<pre class="line-numbers"><code class="language-java">getWindow().setAllowEnterTransitionOverlap(false);
getWindow().setWindowAllowReturnTransitionOverlap(false);
</code></pre>

<p>或者在主题文件全局设置这个属性，这样无疑更好，即减少了代码又保证了应用视觉效果的统一：</p>

<pre class="line-numbers"><code class="language-text">&lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;false&lt;/item&gt;
&lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;false&lt;/item&gt;
</code></pre>

<p>修改后效果如下：<br/>
日志也显示现在是串行执行了：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151041148016665.png" alt="20171111151041148016665.png"/><figcaption>20171111151041148016665.png</figcaption></figure></p>

<h2 id="toc_7">生命周期分析</h2>

<p>保持上面的打印信息不变，我们增加两个Activity的生命周期日志信息，串行结果如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151041150877583.png" alt="20171111151041150877583.png"/><figcaption>20171111151041150877583.png</figcaption></figure></p>

<p>并行如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151041153077770.png" alt="20171111151041153077770.png"/><figcaption>20171111151041153077770.png</figcaption></figure></p>

<p>可以得到如下信息：</p>

<ul>
<li>在A页面的onPause执行前，ExitTransition就已经开始执行了</li>
<li>Transition不会阻塞BActivity的生命周期，尽管是串行执行的，即使ExitTransition没结束，BActivity已经执行完OnResume了。</li>
<li>ReturnExitTransition需要等到AActivity OnStart执行完才开始执行，而且ReturnExitTransition会阻塞AActivity的生命周期，AActivity的OnResume会等到ReturnExitTransition执行完再执行。关于这点可以简要说明下：直接调用Finish不会有动画直接结束掉，需要执行onBackPressed()才会有ReturnExitTransition。看源码就很明显了：</li>
</ul>

<pre class="line-numbers"><code class="language-java"> public void onBackPressed() {
        if (mActionBar != null &amp;&amp; mActionBar.collapseActionView()) {
            return;
        }

        if (!mFragments.getFragmentManager().popBackStackImmediate()) {
            finishAfterTransition();
        }
    }
</code></pre>

<h2 id="toc_8">总结</h2>

<p>最后简单分析下转场动画的大致流程（以slide为例），看过上一篇文章的同学应该很好理解：</p>

<pre class="line-numbers"><code class="language-text">1.从DecoerView开始，依次遍历获得当前Window上的视图树里的所有View

2.执行captureStartValues(TransitionValues transitionValues)，捕获View开始状态的一些属性（visibility，Parent，LocationOnScree）

3.设置所有的VIew为INVISIBLE。

4.执行captureEndValues(TransitionValues transitionValues)，捕获View结束状态的一些属性（visibility，Parent，LocationOnScree）

5.比较属性的不同,创建属性动画。下一个过程就是返回属性动画并执行了。
</code></pre>

<p>这是ExitTransiton的流程，其他三个也差不多。下一篇将会讲带共享元素的转场动画，也是material design中很有特色的动画了。</p>

<p>终于到了material design转场动画中最好玩，最有特色的一部分了。我们沿用上一篇的图，不过将跳转Activity的代码作如下更改：</p>

<pre class="line-numbers"><code class="language-java">Intent intent = new Intent(this,BBBActivity.class);
ActivityOptionsCompat activityOptionsCompat =ActivityOptionsCompat.makeSceneTransitionAnimation(this
                , new Pair&lt;View, String&gt;(shared_image, &quot;shared_image_&quot;)
                , new Pair&lt;View, String&gt;(shared_text, &quot;shared_text_&quot;));
startActivity(intent, activityOptionsCompat.toBundle());
</code></pre>

<p>然后在BBBActivity的布局文件想要设置共享元素的部分设置android:transitionName，值和上个页面中设置的值要一一对应，比如：</p>

<pre class="line-numbers"><code class="language-text"> &lt;TextView
            android:id=&quot;@+id/tv_show&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是一行文字&quot;
            android:transitionName=&quot;shared_text_&quot;/&gt;         
</code></pre>

<p>当然也可以在代码中设置（注意要在调用时机，不能晚于OnResume）：<code>shared_image.setTransitionName(&quot;shared_image_&quot;);</code><br/>
这样简单两步，咱们的带共享元素的转场动画就改造完成了：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151041179398841.gif" alt="20171111151041179398841.gif"/><figcaption>20171111151041179398841.gif</figcaption></figure></p>

<h2 id="toc_9">自定义共享元素动画</h2>

<p>自带的共享元素动画很简单，可以通过如下代码定义进入和返回动画：</p>

<pre class="line-numbers"><code class="language-text"> getWindow().setSharedElementEnterTransition(Transition transition) 
 getWindow().setSharedElementReturnTransition(Transition transition)
</code></pre>

<p>仔细一看这两个方法都只需要一个transition作为动画，所以意味着自定义共享元素动画就是自定义Transition了。套用第一篇自定义的那个直角移动ChangeRect，效果如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151041183822484.gif" alt="20171111151041183822484.gif"/><figcaption>20171111151041183822484.gif</figcaption></figure></p>

<h2 id="toc_10">其他方法</h2>

<p>上面我们只用两个方法就完成了一次完整的共享元素进入到返回动画。但其实和普通的转场动画一样，设置共享元素的转场动画有四个，除了上面介绍的还有两个就是</p>

<pre class="line-numbers"><code class="language-text">setSharedElementExitTransition
setSharedElementReenterTransition
</code></pre>

<p>看命名方式和普通的转场动画非常相似，也就是共享元素离开和重现动画的方法。但是共享元素转场是为了表现两个页面相似内容连贯性而设计的，一组动画就足以完成了。但如果我们都加上后会怎么样呢？为了动画更明显，我们把普通动画设为串行：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017111115104118664268.gif" alt="2017111115104118664268.gif"/><figcaption>2017111115104118664268.gif</figcaption></figure></p>

<p>可以看到新增的两个并没有生效，通过日志打印也可以卡出这一点：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017111115104118919019.png" alt="2017111115104118919019.png"/><figcaption>2017111115104118919019.png</figcaption></figure></p>

<p>SharedElementExitTransition和SharedElementReenterTransition开始后立即就结束了。关于这一点，参看stackoverflow上的回答，简单来说这两个动画的设计只是为了作一些初始化而存在的。当我们点击跳转按钮的时候，马上就已经跳到了B（参看上一篇生命周期的分析），而共享元素动画没有所谓的串行机制，会马上执行SharedElementEnterTransition，所以转场动画内部会立即结束掉ExitTransition。而ReenterTransition我们也可以从gif图看到，SharedElementReturnTransition已经完成了动画，将目标View变为目标状态，所以不再进行SharedElementReturnTransition（也因为没必要），所以只进行了普通转场动画的ReenterTransition。</p>

<h2 id="toc_11">共享元素执行空间</h2>

<p>Window中有个关于共享元素的设置setSharedElementsUseOverlay(boolean sharedElementsUseOverlay)，我们将其设为false，重启App：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151041191716571.gif" alt="20171111151041191716571.gif"/><figcaption>20171111151041191716571.gif</figcaption></figure></p>

<p>可以看到动画执行流程没有变但是共享元素在移动过程中被遮住了，我们来看源码</p>

<pre class="line-numbers"><code class="language-text">  protected void moveSharedElementsToOverlay() {
        if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) {
            return;
        }
        setSharedElementMatrices();
        int numSharedElements = mSharedElements.size();
        ViewGroup decor = getDecor();
        if (decor != null) {
            boolean moveWithParent = moveSharedElementWithParent();
            Matrix tempMatrix = new Matrix();
            for (int i = 0; i &lt; numSharedElements; i++) {
                View view = mSharedElements.get(i);
                tempMatrix.reset();
                mSharedElementParentMatrices.get(i).invert(tempMatrix);
                GhostView.addGhost(view, decor, tempMatrix);
                ViewGroup parent = (ViewGroup) view.getParent();
                if (moveWithParent &amp;&amp; !isInTransitionGroup(parent, decor)) {
                    GhostViewListeners listener = new GhostViewListeners(view, parent, decor);
                    parent.getViewTreeObserver().addOnPreDrawListener(listener);
                    mGhostViewListeners.add(listener);
                }
            }
        }
    }
</code></pre>

<p>可以看到,如果<code>getSharedElementsUseOverlay==true</code>（也就是默认状态），系统会得到这个View，然后<code>GhostView.addGhost(view, decor, tempMatrix)</code>，放置在decorView的Overlay上，因为是decorView，所以也就是在整个view树结构的最上层。Overlay它是view的最上面的一个透明的层，添加到上面的和view不会被其他View遮挡住。</p>

<h2 id="toc_12">拓展：共享元素形变动画</h2>

<p>前面的动画效果都是操作View原有的一些属性，View的内容没有(或者内容没有改变），所以如果与Svg矢量动画配合一番，会产生怎么样的效果呢：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151041200523866.gif" alt="20171111151041200523866.gif"/><figcaption>20171111151041200523866.gif</figcaption></figure></p>

<p>其实很简单，监听SharedElementEnterTransition和SharedElementReturnTransition动画，在其执行的时候执行矢量动画就行了。在更多关于这个矢量动画实现的东西可以参考这篇文章。</p>

<h2 id="toc_13">写在最后</h2>

<p>好了关于Android转场动画的内容完结了，代码已上传<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Frenjianan%2Ftranslate">gitHub</a>，欢迎指正！</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/1</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872581.html">
                
                  <h1>Android-手势检测GestureDetector全面分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>　　在很多视频播放器中，都存在使用不同的手势来控制进度、亮度\音量和暂停播放等功能。Android提供了一个GestureDetector来帮助我们识别一些基本的触摸手势（还有ScaleGestureDetector可以识别缩放手势），让我们很方便地实现手势控制功能。下面我们就来学习一下GestureDetector的使用和通过源码（Android7.0）来分析一下它的实现，让我们对触摸事件处理的理解更加深入。</p>

<h2 id="toc_1">GestureDetector介绍</h2>

<p>　　Detector的意思就是探测者，所以GestureDetector就是用来监听手势的发生。它内部有3个Listener接口，用来回调不同类型的触摸事件，用一个简略的类图来显示：<br/>
　　<br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171111151037082648531.png" alt="20171111151037082648531.png"/><figcaption>20171111151037082648531.png</figcaption></figure></p>

<p>里面这些接口的方法，就是相应触摸事件的回调，实现了这些方法，就能实现传入触摸事件之后做出相应的回调。</p>

<h2 id="toc_2">一些回调接口：</h2>

<ol>
<li><p>OnGestureListener，这个Listener监听一些手势，如单击、滑动、长按等操作： </p>
<ul>
<li>onDown(MotionEvent e):用户按下屏幕的时候的回调。 </li>
<li>onShowPress(MotionEvent e)：用户按下按键后100ms（根据Android7.0源码）还没有松开或者移动就会回调，官方在源码的解释是说一般用于告诉用户已经识别按下事件的回调（我暂时想不出有什么用途，因为这个回调触发之后还会触发其他的，不像长按）。 </li>
<li>onLongPress(MotionEvent e)：用户长按后（好像不同手机的时间不同，源码里默认是100ms+500ms）触发，触发之后不会触发其他回调，直至松开（UP事件）。 </li>
<li>onScroll(MotionEvent e1, MotionEvent e2,float distanceX, float distanceY)：手指滑动的时候执行的回调（接收到MOVE事件，且位移大于一定距离），e1,e2分别是之前DOWN事件和当前的MOVE事件，distanceX和distanceY就是当前MOVE事件和上一个MOVE事件的位移量。 </li>
<li>onFling(MotionEvent e1, MotionEvent e2, float velocityX,float velocityY)：用户执行抛操作之后的回调，MOVE事件之后手松开（UP事件）那一瞬间的x或者y方向速度，如果达到一定数值（源码默认是每秒50px），就是抛操作（也就是快速滑动的时候松手会有这个回调，因此基本上有onFling必然有onScroll）。 </li>
<li>onSingleTapUp(MotionEvent e)：用户手指松开（UP事件）的时候如果没有执行onScroll()和onLongPress()这两个回调的话，就会回调这个，说明这是一个点击抬起事件，但是不能区分是否双击事件的抬起。</li>
</ul></li>
<li><p>OnDoubleTapListener，这个Listener监听双击和单击事件。 </p>
<ul>
<li>onSingleTapConfirmed(MotionEvent e)：可以确认（通过单击DOWN后300ms没有下一个DOWN事件确认）这不是一个双击事件，而是一个单击事件的时候会回调。 </li>
<li>onDoubleTap(MotionEvent e)：可以确认这是一个双击事件的时候回调。 </li>
<li>onDoubleTapEvent(MotionEvent e)：onDoubleTap()回调之后的输入事件（DOWN、MOVE、UP）都会回调这个方法（这个方法可以实现一些双击后的控制，如让View双击后变得可拖动等）。</li>
</ul></li>
<li><p>OnContextClickListener，很多人都不知道ContextClick是什么，我以前也不知道，直到我把平板接上了外接键盘——原来这就是鼠标右键。。。 </p>
<ul>
<li>onContextClick(MotionEvent e)：当鼠标/触摸板，右键点击时候的回调。</li>
</ul></li>
<li><p>SimpleOnGestureListener，实现了上面三个接口的类，拥有上面三个的所有回调方法。 </p>
<ul>
<li>由于SimpleOnGestureListener不是抽象类，所以继承它的时候只需要选取我们所需要的回调方法来重写就可以了，非常方便，也减少了代码量，符合接口隔离原则，也是模板方法模式的实现。而实现上面的三个接口中的一个都要全部重写里面的方法，所以我们一般都是选择SimpleOnGestureListener。</li>
</ul></li>
</ol>

<blockquote>
<p>ps:上面所有的回调方法的返回值都是boolean类型，和View的事件传递机制一样，返回true表示消耗了事件，flase表示没有消耗。</p>
</blockquote>

<h2 id="toc_3">GestureDetector的使用</h2>

<p>GestureDetector的使用很简单，因为它的功能就是定义为识别手势，所以使用的话就是输入完整的触摸事件（完整的意思就是用户所有的触摸操作都是输入给它。为什么要强调完整，因为我上一篇博客就是分享如何拦截子View的部分触摸事件），识别然后进行相应的回调：</p>

<pre class="line-numbers"><code class="language-java">    private void init(Context context){
        mOnGestureListener = new MyOnGestureListener();
        mGestureDetector = new GestureDetector(context,mOnGestureListener);
//        mGestureDetector.setIsLongpressEnabled(false);
        setOnTouchListener(new OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                //监听触摸事件
                return mGestureDetector.onTouchEvent(event);
            }
        });

        setOnGenericMotionListener(new OnGenericMotionListener() {
            @Override
            public boolean onGenericMotion(View v, MotionEvent event) {
                Log.d(TAG, &quot;onGenericMotion: &quot;);
                //监听鼠标右键点击事件
                return mGestureDetector.onGenericMotionEvent(event);
            }
        });
    }
</code></pre>

<blockquote>
<p>如上面的代码，要使用OnGestureListener和OnDoubleTapListener里面的回调需要调用GestureDetector.onTouchEvent()方法，而使用OnContextClickListener的话则是需要调用onGenericMotionEvent()方法，注意一个是在onTouch()方法一个是在onGenericMotion()方法。</p>
</blockquote>

<p>　　看完了上面一堆文字，其实你就会懂得如何使用GestureDetector了，这里有GestureDetector的实践。但是如果你想了解它的回调的时机为什么会是这样的，想具体了解它们的回调时机，可以继续看下去，下面是源码分析。</p>

<h2 id="toc_4">GestureDetector源码分析</h2>

<h3 id="toc_5">初始化处理</h3>

<p>　　GestureDetector的源码接近800行，这在Android源码中已经算是比较短的了（毕竟注释也占一两百行了），所以说它的实现也不是很复杂的。从它的构造方法开始：</p>

<pre class="line-numbers"><code class="language-java">    public GestureDetector(Context context, OnGestureListener listener) {
        this(context, listener, null);
    }

    public GestureDetector(Context context, OnGestureListener listener, Handler handler) {
        //初始化Handler
        if (handler != null) {
            mHandler = new GestureHandler(handler);
        } else {
            mHandler = new GestureHandler();
        }
        //设置Listener
        mListener = listener;
        if (listener instanceof OnDoubleTapListener) {
            setOnDoubleTapListener((OnDoubleTapListener) listener);
        }
        if (listener instanceof OnContextClickListener) {
            setContextClickListener((OnContextClickListener) listener);
        }

        init(context);
    }

    private void init(Context context) {
        if (mListener == null) {
            throw new NullPointerException(&quot;OnGestureListener must not be null&quot;);
        }
        mIsLongpressEnabled = true;

        // Fallback to support pre-donuts releases
        int touchSlop, doubleTapSlop, doubleTapTouchSlop;
        if (context == null) {
            //相当于下面的getScaledTouchSlop，表示滑动的时候，手的移动要大于这个距离才开始移动控件
            touchSlop = ViewConfiguration.getTouchSlop();
            //相当于下面的getScaledDoubleTapTouchSlop，表示点击的时候，手指移动大于这个距离，就被认为不可能是双击
            doubleTapTouchSlop = touchSlop; 
            //相当于下面的getScaledDoubleTapSlop，表示第二次点击的时候，和第一次的点击点位置距离如果大于这个，就被认为不是双击
            doubleTapSlop = ViewConfiguration.getDoubleTapSlop();
            mMinimumFlingVelocity = ViewConfiguration.getMinimumFlingVelocity();
            mMaximumFlingVelocity = ViewConfiguration.getMaximumFlingVelocity();
        } else {
            final ViewConfiguration configuration = ViewConfiguration.get(context);
            touchSlop = configuration.getScaledTouchSlop();
            doubleTapTouchSlop = configuration.getScaledDoubleTapTouchSlop();
            doubleTapSlop = configuration.getScaledDoubleTapSlop();
            mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity();
            mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity();
        }
        //做平方好计算距离，后面的距离对比也是用平方
        mTouchSlopSquare = touchSlop * touchSlop;
        mDoubleTapTouchSlopSquare = doubleTapTouchSlop * doubleTapTouchSlop;
        mDoubleTapSlopSquare = doubleTapSlop * doubleTapSlop;
    }
</code></pre>

<p>　　可见GestureDetector的创建就是初始化一些属性，然后就是把对应的Listener设置好，还有初始化Handler，而这里的GestureHandler，是控制onShowPress()，onLongPress()，onSingleTapConfirmed()`回调的关键：</p>

<pre class="line-numbers"><code class="language-java">  private class GestureHandler extends Handler {
        //省略构造函数...

        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
            case SHOW_PRESS:
                mListener.onShowPress(mCurrentDownEvent);
                break;

            case LONG_PRESS:
                dispatchLongPress();
                break;

            case TAP:
                // If the user&#39;s finger is still down, do not count it as a tap
                //这里控制SingleTapConfirmed的回调，
                if (mDoubleTapListener != null) {
                    if (!mStillDown) {
                        //如果已经松开，就立刻调用SingleTapConfirmed
                        mDoubleTapListener.onSingleTapConfirmed(mCurrentDownEvent);
                    } else {
                        //如果处理Message的时候还没松开，就设置mDeferConfirmSingleTap为true，在UP事件的时候调用SingleTapConfirme
                        mDeferConfirmSingleTap = true;
                    }
                }
                break;

            default:
                throw new RuntimeException(&quot;Unknown message &quot; + msg); //never
            }
        }
    }

    //长按处理
    private void dispatchLongPress() {
        mHandler.removeMessages(TAP);
        mDeferConfirmSingleTap = false;
        mInLongPress = true;
        mListener.onLongPress(mCurrentDownEvent);
    }
</code></pre>

<h3 id="toc_6">输入处理</h3>

<p>　　初始化完之后，就是看它的如何处理输入了，这是它的核心逻辑：</p>

<pre class="line-numbers"><code class="language-java">    public boolean onTouchEvent(MotionEvent ev) {
        //检查事件输入的一致性,log出来一致性的信息，如：有事件只有up没有down
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
        }

        final int action = ev.getAction();

        //开始速度检测
        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(ev);


        //检测是否非主要指针抬起动作（如果是多点触摸）
        final boolean pointerUp =
                (action &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;

        final int skipIndex = pointerUp ? ev.getActionIndex() : -1;

        // Determine focal point
        // 是非主要指针抬起动作的话会跳过
        float sumX = 0, sumY = 0;
        final int count = ev.getPointerCount();
        //把所有还在触摸的手指的位置x，y加起来，后面求平均数，算出中心焦点
        for (int i = 0; i &lt; count; i++) {
            if (skipIndex == i) continue;
            sumX += ev.getX(i);
            sumY += ev.getY(i);
        }
        final int div = pointerUp ? count - 1 : count;
        final float focusX = sumX / div;
        final float focusY = sumY / div;

        boolean handled = false;

        switch (action &amp; MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            //...
            break;

        case MotionEvent.ACTION_POINTER_UP:
            //...
            break;

        case MotionEvent.ACTION_DOWN:
            //...
            break;

        case MotionEvent.ACTION_MOVE:
            //...
            break;

        case MotionEvent.ACTION_UP:
            //...
            break;

        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
        }

        //对未被处理的事件进行一次一致性检测
        if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
        }
        return handled;
    }
</code></pre>

<p>　　上面的注释写得很清楚了，主要onTouchEvent()的主要思路就是先对输入事件做出统一处理，提取一些共有的信息，如多个点同时触摸时候的中心焦点和滑动速度等，然后根据事件的分类做出相应的处理。</p>

<blockquote>
<p>ps：InputEventConsistencyVerifier对输入事件进行的一致性检测的结果并不影响GestureDetector的运行，如果检测到一致性不符合的事件（只有UP事件而前面没有DOWN事件），就只会输出log告诉开发者。</p>
</blockquote>

<h4 id="toc_7">DOWN事件处理</h4>

<p>　　下面进入DOWN事件的处理：</p>

<pre class="line-numbers"><code class="language-java">    //...
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                //处理双击
                //取消TAP事件
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage) mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) &amp;&amp; (mPreviousUpEvent != null) &amp;&amp; hadTapMessage &amp;&amp;
                        isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    //回调双击
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    //延时发出单击事件，如果到了时间（300ms）还没有取消的话就确认是TAP事件了
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }

            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            //重置mCurrentDownEvent
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            //处理长按
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                //延时发送长按事件
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime()
                        + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            //延时发送showPress事件
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
    //...

    //判断第二次点击是否有效双击
    private boolean isConsideredDoubleTap(MotionEvent firstDown, MotionEvent firstUp,
            MotionEvent secondDown) {
        //第一次点击后是否有移动超出范围
        if (!mAlwaysInBiggerTapRegion) {

            return false;
        }

        final long deltaTime = secondDown.getEventTime() - firstUp.getEventTime();
        if (deltaTime &gt; DOUBLE_TAP_TIMEOUT || deltaTime &lt; DOUBLE_TAP_MIN_TIME) {
            return false;
        }

        int deltaX = (int) firstDown.getX() - (int) secondDown.getX();
        int deltaY = (int) firstDown.getY() - (int) secondDown.getY();
        //判断第二次点击是否在附近，在附近才被认为是双击
        return (deltaX * deltaX + deltaY * deltaY &lt; mDoubleTapSlopSquare);
    }
</code></pre>

<p>可见，对DOWN事件涉及： </p>

<ul>
<li>处理单击判断：如果收到一次DOWN事件，而且前段时间没有DOWN事件的话，会发送一个延时的TAP信息，而一段时间（300ms）之后没有被取消的话，就执行GestureHandler里面的TAP单击确认操作。 </li>
<li>处理双击判断：如果前面也有一次DOWN事件，而且也符合isConsideredDoubleTap()的条件（第一次点击后没有移动超出范围，第二次点击也在附近），就可以确认双击，执行onDoubleTap()和onDoubleTapEvent()的回调。 </li>
<li>处理长按判断：先看用户是否允许检测长按，然后就是发送一个延时的LONG_PRESS信息，如果到时候还没被取消的话就是回调长按方法了。 </li>
<li>处理showPress判断：这个和长按差不多，就是时间（100ms）短了一点而已。</li>
</ul>

<blockquote>
<p>PS：handled是boolean变量，|=符号是用符号右边的值跟左边的值进行或运算再赋值给左边。a |= b等价于a = a | b，这里使handled变量初始值为false，进行了多次|=操作，一旦有结果是true的话，handled最后的值就是true，所有结果都是false最后才会false，onTouchEvent()方法最后返回这个handled，就可以表示事件有没被处理，实现了对事件处理的封装。</p>
</blockquote>

<h4 id="toc_8">MOVE事件处理</h4>

<p>然后再看看对MOVE事件的处理：</p>

<pre class="line-numbers"><code class="language-java">    //...
        case MotionEvent.ACTION_MOVE:
            //如果是正在长按和点击了鼠标右键
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                //如果是第二次点击的话，把移动事件也当作双击，有点奇怪
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                //down才会使mAlwaysInTapRegion为true
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                //mTouchSlopSquare是一个距离的平方，表示滑动的时候，手的移动要大于这个距离才认为是Scroll事件
                if (distance &gt; mTouchSlopSquare) {
                    //进入Scroll模式
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance &gt; mDoubleTapTouchSlopSquare) {
                    //如果移动距离超过允许范围，则不再可能认为移动事件是双击
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) &gt;= 1) || (Math.abs(scrollY) &gt;= 1)) {
                //后续的Scroll移动，前面的是进入Scroll移动
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
    //...
</code></pre>

<p>可见，对MOVE事件涉及： </p>

<ul>
<li>onDoubleTapEvent()回调：只要确认是双击之后，mIsDoubleTapping为true，除了长按，后面的MOVE事件都会只回调onDoubleTapEvent()。 </li>
<li>onScroll()回调：当MOVE不是长按，不是DoubleTapEvent之后，当移动距离大于一定距离之后，就会进入Scroll模式，然后两个MOVE事件的位移距离scrollX或者scrollY大于1px，都会调用onScroll()。</li>
</ul>

<h4 id="toc_9">UP事件的处理</h4>

<p>接下来再看UP事件：</p>

<pre class="line-numbers"><code class="language-java">    //...
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                //双击事件
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                //长按结束
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion &amp;&amp; !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                //处理单击确认，具体逻辑看GestureHandler如何处理TAP事件
                if (mDeferConfirmSingleTap &amp;&amp; mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                //处理Fling，如果速度大于定义的最小速度（50），就回调Fling
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);

                if ((Math.abs(velocityY) &gt; mMinimumFlingVelocity)
                        || (Math.abs(velocityX) &gt; mMinimumFlingVelocity)){
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            //重置mPreviousUpEvent
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            //回收mVelocityTracker
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
    //...
</code></pre>

<p>可见，对MOVE事件涉及： </p>

<ul>
<li>onDoubleTapEvent()回调：只要确认是双击之后，mIsDoubleTapping为true，除了长按，后面的MOVE事件都会只回调onDoubleTapEvent()。 </li>
<li>onSingleTapUp()回调：DOWN事件之后没有MOVE，或者MOVE的距离没有超出范围，mAlwaysInTapRegion才不会变成false，回调onSingleTapUp()。 </li>
<li>onSingleTapConfirmed()回调：从前面GestureHandler里面的TAP消息的实现可以看到：</li>
</ul>

<pre class="line-numbers"><code class="language-java">            case TAP:
                // If the user&#39;s finger is still down, do not count it as a tap
                //这里控制SingleTapConfirmed的回调，
                if (mDoubleTapListener != null) {
                    if (!mStillDown) {
                        //如果已经松开，就立刻调用SingleTapConfirmed
                        mDoubleTapListener.onSingleTapConfirmed(mCurrentDownEvent);
                    } else {
                        //如果处理Message的时候还没松开，就设置mDeferConfirmSingleTap为true，在UP事件的时候调用SingleTapConfirme
                        mDeferConfirmSingleTap = true;
                    }
                }
                break;
</code></pre>

<p>　　之前看过，TAP消息是延时（300ms）发送的，然而实际逻辑中，是抬起手指才算是点击，所以这里处理TAP的时候就不一定立刻调用onSingleTapConfirmed()，而是判断手指是否松开了，是松开的话就立刻回调。如果还未松开那就把标志位mDeferConfirmSingleTap设置为true，等到收到UP事件的时候再回调。 </p>

<ul>
<li>onFling()回调：当UP事件的速度大于一定速度时，就会回调onFling()，至于mIgnoreNextUpEvent参数，是只有鼠标右键点击的时候才会为true，具体看后面。</li>
</ul>

<h4 id="toc_10">多点触摸的处理</h4>

<p>　　对于多个手指落下，前面的统一处理已经是把所有手指的坐标值加起来然后算平均值了，所以我们多根手指触摸的时候，其实滑动的实际点是这些手指的中心焦点。回看上面的MOVE事件处理，中心焦点的位置值FocusX和FocusY决定onScroll(onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY))的后两个参数值，所以处理多点触控的话就使用它们比较方便。因为MotionEvent是使用数组装着当前屏幕上所有指针的动作的，使用前两个参数的话还要循环用getX(int pointerIndex)和getY(int pointerIndex)方法取出各个指针的值再自己处理。</p>

<pre class="line-numbers"><code class="language-java">    //...
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            //如果有多根手指按下，取消长按和点击计时
            cancelTaps();
            break;

        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;

            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            //计算每一秒钟的滑动像素
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            //如果剩下的手指速度方向是和抬起那根手指的速度相反方向的，就说明不是fling，清空速度监听
            for (int i = 0; i &lt; count; i++) {
                if (i == upIndex) continue;

                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);

                final float dot = x + y;
                if (dot &lt; 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
    //...

    private void cancelTaps() {
        mHandler.removeMessages(SHOW_PRESS);
        mHandler.removeMessages(LONG_PRESS);
        mHandler.removeMessages(TAP);
        mIsDoubleTapping = false;
        mAlwaysInTapRegion = false;
        mAlwaysInBiggerTapRegion = false;
        mDeferConfirmSingleTap = false;
        mInLongPress = false;
        mInContextClick = false;
        mIgnoreNextUpEvent = false;
    }
</code></pre>

<p>　　这是对多个手指的UP和DOWN事件处理，其实就是做一些取消操作而让多点触摸不影响单点触摸的应用，例如在多个手指落下的时候取消点击信息等。</p>

<h4 id="toc_11">ContextClick的处理</h4>

<p>　　ContextClick的事件是由onGenericMotionEvent()传入：</p>

<pre class="line-numbers"><code class="language-java">    public boolean onGenericMotionEvent(MotionEvent ev) {
        if (mInputEventConsistencyVerifier != null) {
            mInputEventConsistencyVerifier.onGenericMotionEvent(ev, 0);
        }

        final int actionButton = ev.getActionButton();
        switch (ev.getActionMasked()) {
            case MotionEvent.ACTION_BUTTON_PRESS:
                //按下触控笔首选按钮或者鼠标右键
                if (mContextClickListener != null &amp;&amp; !mInContextClick &amp;&amp; !mInLongPress
                        &amp;&amp; (actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY
                        || actionButton == MotionEvent.BUTTON_SECONDARY)) {
                    if (mContextClickListener.onContextClick(ev)) {
                        mInContextClick = true;
                        mHandler.removeMessages(LONG_PRESS);
                        mHandler.removeMessages(TAP);
                        return true;
                    }
                }
                break;

            case MotionEvent.ACTION_BUTTON_RELEASE:
                if (mInContextClick &amp;&amp; (actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY
                        || actionButton == MotionEvent.BUTTON_SECONDARY)) {
                    mInContextClick = false;
                    //无视下一个UP事件，因为它是由鼠标右键或者触控笔键带起的
                    mIgnoreNextUpEvent = true;
                }
                break;
        }
        return false;
    }
</code></pre>

<p>由此可以，当按键按下（ACTION_BUTTON_PRESS）的时候已经回调onContextClick()。</p>

<h2 id="toc_12">总结</h2>

<p>读完源码，总结出来的每个回调的调用时机如下表：</p>

<p>PS：除去onContextClick()，因为它的按下鼠标右键时候是发出一系列的事件。</p>

<table>
<thead>
<tr>
<th style="text-align: center">回调/输入事件</th>
<th style="text-align: center">DOWN事件</th>
<th style="text-align: center">MOVE事件</th>
<th style="text-align: center">UP事件</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">onDown(MotionEvent e)</td>
<td style="text-align: center">√</td>
<td style="text-align: center">×</td>
<td style="text-align: center">×</td>
</tr>
<tr>
<td style="text-align: center">onShowPress(MotionEvent e)</td>
<td style="text-align: center">√</td>
<td style="text-align: center">×</td>
<td style="text-align: center">×</td>
</tr>
<tr>
<td style="text-align: center">onLongPress(MotionEvent e)</td>
<td style="text-align: center">√</td>
<td style="text-align: center">×</td>
<td style="text-align: center">×</td>
</tr>
<tr>
<td style="text-align: center">onScroll(MotionEvent e1, MotionEvent e2,float distanceX, float distanceY)</td>
<td style="text-align: center">×</td>
<td style="text-align: center">√</td>
<td style="text-align: center">×</td>
</tr>
<tr>
<td style="text-align: center">onFling(MotionEvent e1, MotionEvent e2, float velocityX,float velocityY))</td>
<td style="text-align: center">×</td>
<td style="text-align: center">×</td>
<td style="text-align: center">√</td>
</tr>
<tr>
<td style="text-align: center">onSingleTapUp(MotionEvent e)</td>
<td style="text-align: center">×</td>
<td style="text-align: center">×</td>
<td style="text-align: center">√</td>
</tr>
<tr>
<td style="text-align: center">onSingleTapConfirmed(MotionEvent e)</td>
<td style="text-align: center">×</td>
<td style="text-align: center">×</td>
<td style="text-align: center">√</td>
</tr>
<tr>
<td style="text-align: center">onDoubleTap(MotionEvent e)</td>
<td style="text-align: center">√</td>
<td style="text-align: center">×</td>
<td style="text-align: center">×</td>
</tr>
<tr>
<td style="text-align: center">onDoubleTapEvent(MotionEvent e)</td>
<td style="text-align: center">√</td>
<td style="text-align: center">√</td>
<td style="text-align: center">√</td>
</tr>
</tbody>
</table>

<p>　　<br/>
从上面的分析可以看出，虽然GestureDetector能识别很多手势，但是也是不能满足所有的需求的，如滑动和长按之后松开没有回调（这个可以重写onTouch()捕捉UP事件实现）、多点触控缩放手势的实现（这个可以用ScaleGestureDetector）等。</p>

<h2 id="toc_13">后话</h2>

<p>　　有人问我看GestureDetector源码这么仔细有什么用，它又不是很常用的东西，网上随便一搜一堆资料。我的回答是因为我觉得要用一个东西的话，首先就是要搞清楚它能干什么，它的限制是什么，为什么要选择它，关于这些方面，网上的很多关于GestureDetector的资料都没有达到我想了解的程度，加上GestureDetector并不复杂，所以写下了这篇博客，这样就可以从源码层面上了解到它的回调是什么时候调用，有bug的时候也能更快的找出。<br/><br/>
　　不管怎样，GestureDetector里面的SimpleOnGestureListener的设计，和对触摸事件的处理方式是很值得我学习的，记录分享至此，水平有限，如果错漏，欢迎指正和讨论。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/1</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872417.html">
                
                  <h1>Android-玩转PathMeasure</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171109151015906869351.gif" alt="20171109151015906869351.gif"/><figcaption>20171109151015906869351.gif</figcaption></figure></p>

<h2 id="toc_0">PathMeasure</h2>

<p><strong>Public constructors</strong></p>

<ul>
<li>PathMeasure 创建一个空的 pathmeasure 对象</li>
<li>PathMeasure(Path path,boolean forceClosed)创建一个带 path 参数的 PathMeasure,forceClosed控制 path 是否自动闭合</li>
</ul>

<p><strong>Public methods</strong></p>

<ul>
<li>getLength() 返回当前 Path 的总长度。</li>
<li>getMatrix(float distance, Matrix matrix, int flags)</li>
<li>getPosTan(float distance, float[] pos, float[] tan)获取distance长度的 point 值给 pos，point 点的正切值给 tan。</li>
<li>getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) 获取 path 的一个片段，即startD到 stopD 的线段，辅助给 dst。</li>
<li>isClosed() 是否自动闭合</li>
<li>nextContour() 移动到下一条曲线。如果 path 中含有不连续的线条，getLength、getPosTan等方法之会在第一条线上运行，需要使用这个方法跳到第二条线</li>
<li>setPath(Path path, boolean forceClosed)</li>
</ul>

<p>是不是很简单，就这么几个方法，现在去画光能使者阵有思路了么~~<br/>
接下来为了便于大家理解，我们再来简单回顾一下 path 的 api，因为静态的光能使者阵是需要 path 去绘制的。</p>

<p><strong>Path</strong></p>

<table>
<thead>
<tr>
<th style="text-align: center">方法名</th>
<th style="text-align: center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">moveTo</td>
<td style="text-align: center">移动到指定点</td>
</tr>
<tr>
<td style="text-align: center">setLastPoint</td>
<td style="text-align: center">重新设置当前Path的最后一个点，如果当前Path为空，则等同上个方法</td>
</tr>
<tr>
<td style="text-align: center">lineTo</td>
<td style="text-align: center">添加当前点到一个指定点的直线</td>
</tr>
<tr>
<td style="text-align: center">close</td>
<td style="text-align: center">连接当前点到起点，形成闭合路径</td>
</tr>
<tr>
<td style="text-align: center">addRect、addRoundRect、addOval、addCircle、addPath、addArc、arcTo</td>
<td style="text-align: center">添加各种图形</td>
</tr>
<tr>
<td style="text-align: center">isEmpty</td>
<td style="text-align: center">是否为空</td>
</tr>
<tr>
<td style="text-align: center">isRect</td>
<td style="text-align: center">是否为矩形</td>
</tr>
<tr>
<td style="text-align: center">set</td>
<td style="text-align: center">用一个新的path替换</td>
</tr>
<tr>
<td style="text-align: center">offset</td>
<td style="text-align: center">对当前的路径进行偏移，不会影响后续操作</td>
</tr>
<tr>
<td style="text-align: center">quadTo、cubicTo</td>
<td style="text-align: center">贝塞尔曲线</td>
</tr>
<tr>
<td style="text-align: center">rMoveTo、rLineTo、rQuaTo、rCubicTo</td>
<td style="text-align: center">带r的是基于当前点的偏移量，不带r基于坐标原点</td>
</tr>
<tr>
<td style="text-align: center">setFillType、getFillType</td>
<td style="text-align: center">设置填充模式</td>
</tr>
<tr>
<td style="text-align: center">transform</td>
<td style="text-align: center">矩阵变换</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">动画拆解</h2>

<p>好了，准备工作完成，我们开始撸代码</p>

<p><strong>第一步，绘制静态的光能使者阵</strong><br/>
首先绘制两个圆，然后就是中间的六角星（其实仔细看就是两个三角形）。<br/>
都是很简单的方法，同学们动手去画的时候可能会遇到一个这样的问题，就是三角形的三个点不好取。其实很简单，直接在圆上取0，1/3，2/3长度的点即可，刚刚我们不是说了 PathMeasure 的方法么，用getPosTan就可以实现。</p>

<p><strong>第二步，让光能使者阵动起来</strong><br/>
这里我们把这个动画效果分成三个阶段吧。</p>

<p><strong>第一阶段，绘制两个圆</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171109151015971189141.gif" alt="20171109151015971189141.gif"/><figcaption>20171109151015971189141.gif</figcaption></figure></p>

<p>如上图所示，这里两个圆是慢慢绘制出来的， 圆的 path 很容易绘制出来，这里我就不讲了，然后PathMeasure的getLength可以获取 path 总的长度，getSegment可以获取某个点到某个点的 Path。因此一个 ValueAnimator 就可以解决从0到100%长度的过程，具体实现看后面的代码。</p>

<p>然后问题来了，path画出来的圆的起点在哪里？怎么控制两个圆开始绘制的角度不一样。有同学可能想到了旋转90°再画第二个圆，当然这种方式是可以实现的，但是由于后面的三角形也需要旋转，这里我们就不用 path 画圆了，用 path 添加一个正方形 Rect 的圆弧也是一个圆，然后我们的圆弧可以控制开始的角度，弧度。<br/>
然后变成这样了</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171109151015974099352.gif" alt="20171109151015974099352.gif"/><figcaption>20171109151015974099352.gif</figcaption></figure></p>

<p>WTF？角度怎么不对了，我明明设置的开始角度的呀</p>

<pre class="line-numbers"><code class="language-text">innerCircle.addArc(innerRect, 150, -360);
outerCircle.addArc(outerRect, 60, -360);
</code></pre>

<p>最后有个大牛说你的圆变成闭环了，PathMeasure 找不到开始点，用了默认的。你把360度改成359.9让他不是一个闭环的圆就行了。</p>

<p><strong>第二阶段，两个点在圆里面弹射</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171109151015979584476.gif" alt="20171109151015979584476.gif"/><figcaption>20171109151015979584476.gif</figcaption></figure></p>

<p>看起来好像还要干什么碰撞反弹之类的事，一副高科技的样子，其实不是的。</p>

<p>轨迹就是两个三角形，怎么让两条线跟着三角形走呢，而且走的时候还要不段变化长度。</p>

<p>刚刚第一步我们用 ValueAnimator 来控制一个圆从0到100%的过程，</p>

<p><code>pathMeasure.getSegment(0, distance * pathMeasure.getLength(), drawPath, true);</code></p>

<p>不断截取起点到*%长度的 path 赋值给drawPath。</p>

<p>从里是从起点开始截取，那么我们不从起点开始截取，从当前点附近开始截取不就行了吗，哈哈哈哈~so easy</p>

<pre class="line-numbers"><code class="language-text">float stopD = distance * pathMeasure.getLength();
float startD = stopD - (0.5f - Math.abs(0.5f - distance)) * 200;
pathMeasure.getSegment(startD, stopD, drawPath, true);
</code></pre>

<p><strong>第三阶段绘制两个三角形</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171109151015984291399.gif" alt="20171109151015984291399.gif"/><figcaption>20171109151015984291399.gif</figcaption></figure></p>

<p>其实两个三角形就是第二步的运动轨迹，也是就是说直接用第阶段的 Path 即可，然后再用第一阶段一样的办法就可以实现效果。</p>

<h2 id="toc_2">代码实现</h2>

<pre class="line-numbers"><code class="language-java">public class GranzortView extends View {
    private Paint paint;
    private Path innerCircle;//内圆 path
    private Path outerCircle;//外圆 path
    private Path trangle1;  //第一个三角形的path
    private Path trangle2;  //第二个三角形的path
    private Path drawPath;  //用于截取路径的path

    private PathMeasure pathMeasure;

    private float mViewWidth;
    private float mViewHeight;

    private long duration = 3000;
    private ValueAnimator valueAnimator;

    private Handler mHandler;

    private float distance;//当前动画执行的百分比取值为0~1
    private ValueAnimator.AnimatorUpdateListener animatorUpdateListener;
    private Animator.AnimatorListener animatorListener;

    private State mCurrentState = State.CIRCLE_STATE;

    public GranzortView(Context context) {
        this(context,null);
    }

    public GranzortView(Context context, @Nullable AttributeSet attrs) {
        this(context, attrs,0);
    }

    public GranzortView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    //三个阶段的枚举
    private enum State {
        CIRCLE_STATE,
        TRANGLE_STATE,
        FINISH_STATE
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        mViewWidth = w;
        mViewHeight = h;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.drawColor(getResources().getColor(R.color.colorPrimary));
        canvas.save();
        canvas.translate(mViewWidth / 2, mViewHeight / 2);
        switch (mCurrentState){
            case CIRCLE_STATE:
                drawPath.reset();
                pathMeasure.setPath(innerCircle,false);
                pathMeasure.getSegment(0,distance * pathMeasure.getLength(),drawPath,true);
                canvas.drawPath(drawPath,paint);
                pathMeasure.setPath(outerCircle,false);
                drawPath.reset();
                pathMeasure.getSegment(0,distance * pathMeasure.getLength(),drawPath,true);
                canvas.drawPath(drawPath,paint);
                break;
            case TRANGLE_STATE:
                canvas.drawPath(innerCircle,paint);
                canvas.drawPath(outerCircle,paint);
                drawPath.reset();
                pathMeasure.setPath(trangle1,false);
                float stopD = distance * pathMeasure.getLength();
                float startD = stopD - (0.5f - Math.abs(0.5f - distance)) * 200;
                pathMeasure.getSegment(startD,stopD,drawPath,true);
                canvas.drawPath(drawPath,paint);
                drawPath.reset();
                pathMeasure.setPath(trangle2,false);
                pathMeasure.getSegment(startD,stopD,drawPath,true);
                canvas.drawPath(drawPath,paint);
                break;
            case FINISH_STATE:
                canvas.drawPath(innerCircle,paint);
                canvas.drawPath(outerCircle,paint);
                drawPath.reset();
                pathMeasure.setPath(trangle1,false);
                pathMeasure.getSegment(0, distance * pathMeasure.getLength(),drawPath,true);
                canvas.drawPath(drawPath,paint);
                drawPath.reset();
                pathMeasure.setPath(trangle2,false);
                pathMeasure.getSegment(0,distance*pathMeasure.getLength(),drawPath,true);
                canvas.drawPath(drawPath,paint);
                break;
        }
        canvas.restore();
    }

    private void init(){
        initPaint();
        initPath();
        initHandler();
        initAnimatorListener();
        initAnimator();
        mCurrentState = State.CIRCLE_STATE;
        valueAnimator.start();
    }

    private void initHandler(){
        mHandler = new Handler(){
            @Override
            public void handleMessage(Message msg) {
                switch (mCurrentState){
                    case CIRCLE_STATE:
                        mCurrentState = State.TRANGLE_STATE;
                        valueAnimator.start();
                        break;
                    case TRANGLE_STATE:
                        mCurrentState = State.FINISH_STATE;
                        valueAnimator.start();
                        break;
                }
            }
        };
    }

    private void initAnimatorListener(){
        animatorUpdateListener = new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                distance = animation.getAnimatedValue();
                invalidate();
            }
        };

        animatorListener = new Animator.AnimatorListener() {
            @Override
            public void onAnimationStart(Animator animation) {
                Log.e(&quot;start&quot;,mCurrentState + &quot;_&quot;);
            }

            @Override
            public void onAnimationEnd(Animator animation) {
                Log.e(&quot;end&quot;,mCurrentState+&quot;_&quot;);
                mHandler.sendEmptyMessage(0);
            }

            @Override
            public void onAnimationCancel(Animator animation) {

            }

            @Override
            public void onAnimationRepeat(Animator animation) {

            }
        }
    }

    private void initAnimator(){
        valueAnimator = ValueAnimator.ofFloat(0,1).setDuration(duration);
        valueAnimator.addUpdateListener(animatorUpdateListener);
        valueAnimator.addListener(animatorListener);
    }

    private void initPath(){
        innerCircle = new Path();
        outerCircle = new Path();
        trangle1 = new Path();
        trangle2 = new Path();
        drawPath = new Path();

        pathMeasure = new PathMeasure();
        RectF innerRect = new RectF(-220,-220,220,220);
        RectF outerRect = new RectF(-280,-280,280,280);
        innerCircle.addArc(innerRect,150,-359.9f);//不能取360f，否则可能造成测量到的值不准确
        outerCircle.addArc(outerRect,60,-359.9f);

        pathMeasure.setPath(innerCircle,false);

        float[] pos = new float[2];
        pathMeasure.getPosTan(0,pos,null);//获取开始位置的坐标
        trangle1.moveTo(pos[0],pos[1]);
        pathMeasure.getPosTan((1f / 3f) * pathMeasure.getLength(),pos,null);

        trangle1.lineTo(pos[0],pos[1]);
        pathMeasure.getPosTan((2f / 3f)*pathMeasure.getLength(),pos,null);
        trangle1.lineTo(pos[0],pos[1]);
        trangle1.close();

        pathMeasure.getPosTan((2f / 3f) * pathMeasure.getLength(),pos,null);
        Matrix matrix = new Matrix();
        matrix.postRotate(-180);
        trangle1.transform(matrix,trangle2);
    }

    private void initPaint(){
        paint = new Paint(Paint.ANTI_ALIAS_FLAG);
        paint.setColor(Color.WHITE);
        paint.setStyle(Paint.Style.STROKE);
        paint.setStrokeWidth(10);
        paint.setStrokeCap(Paint.Cap.ROUND);
        paint.setStrokeJoin(Paint.Join.BEVEL);
        paint.setShadowLayer(15,0,0,Color.WHITE);//白色光影效果
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872454.html">
                
                  <h1>Android-视频播放器开发</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>android中在实际的视频开发中多用即成的框架,或者自己封装相关的Manager来实现;下面介绍一个简单的android视频开发的过程: </p>

<ol>
<li>实现网络和本地视频播放 </li>
<li>点击控制播放,暂停 </li>
<li>支持进度条的拖动,实时跟新进度,时间 </li>
<li>支持横竖屏切换 </li>
<li>在横屏状态下,音量键显示并且可调节 </li>
<li>支持手势触摸,即:上下滑动左半屏,弹出dialog,控制屏幕亮度,并且显示进度条;上下滑动右半屏,弹出dialog,控制声音大小,并且显示进度条; </li>
</ol>

<h2 id="toc_0">First</h2>

<p>首先demo是基于videoView为基础,当然简单的开发,没有过多要求可以用原生的控制器可以可以解决,在这里控制都是自定义;首先为保证横竖屏幕的宽高不适配,需要自定义vieoView重写测量方法:</p>

<pre class="line-numbers"><code class="language-java">public class AlpshVideo extends VideoView {
    public AlpshVideo(Context context) {
        super(context);
    }

    public AlpshVideo(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public AlpshVideo(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        //我们重新计算高度
        int width = getDefaultSize(0, widthMeasureSpec);
        int height = getDefaultSize(0, heightMeasureSpec);
        setMeasuredDimension(width, height);
    }
}
</code></pre>

<p>接着xml中嵌入自定义的vieoView:</p>

<pre class="line-numbers"><code class="language-text">&lt;com.example.video.customView.AlpshVideo
            android:id=&quot;@+id/videoView&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;240dp&quot;
            /&gt;
</code></pre>

<p>在MainActivity中加载本地或者网络视频:</p>

<pre class="line-numbers"><code class="language-text"> //加载本地
mVideoView.setVideoPath(&quot;android.resource://&quot;+getPackageName()+&quot;/&quot;+R.raw.welcome);
mVideoView.start();

//加载网络url
//mVideoView.setVideoURI(Uri.parse(&quot;xxxx&quot;));
</code></pre>

<p>我们这里以本地为例;ok这样videoView就可以开始比方视频;</p>

<h2 id="toc_1">自定义控制器—-&gt;布局</h2>

<p>接下来看代码,xml比较简单,仅展示代码:</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot;
    android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;

    &lt;FrameLayout
        android:id=&quot;@+id/fr_video&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;240dp&quot;&gt;

        &lt;com.example.video.customView.AlpshVideo
            android:id=&quot;@+id/videoView&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;240dp&quot;
            /&gt;

        &lt;LinearLayout
            android:orientation=&quot;vertical&quot;
            android:layout_gravity=&quot;bottom&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;50dp&quot;&gt;

            &lt;SeekBar
                android:id=&quot;@+id/media_progress&quot;
                android:thumb=&quot;@null&quot;
                android:progressDrawable=&quot;@drawable/seekbar_style2&quot;
                android:max=&quot;100&quot;
                android:progress=&quot;20&quot;
                android:indeterminate=&quot;false&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;5dp&quot;
                android:layout_marginLeft=&quot;-20dp&quot;
                android:layout_marginRight=&quot;-20dp&quot;/&gt;

            &lt;RelativeLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                android:background=&quot;#101010&quot;
                android:gravity=&quot;center_vertical&quot;&gt;

                &lt;LinearLayout
                    android:layout_width=&quot;match_parent&quot;
                    android:layout_height=&quot;match_parent&quot;
                    android:gravity=&quot;center_vertical&quot;&gt;


                    &lt;ImageView
                        android:id=&quot;@+id/media_actions&quot;
                        android:layout_marginLeft=&quot;15dp&quot;
                        android:layout_width=&quot;20dp&quot;
                        android:layout_height=&quot;match_parent&quot;
                        android:src=&quot;@drawable/stop_btn&quot;/&gt;

                    &lt;TextView
                        android:id=&quot;@+id/media_time&quot;
                        android:layout_marginLeft=&quot;30dp&quot;
                        android:layout_width=&quot;wrap_content&quot;
                        android:layout_height=&quot;wrap_content&quot;
                        android:text=&quot;00:00:00&quot;
                        android:textColor=&quot;#fff&quot;
                        android:textSize=&quot;12sp&quot;/&gt;

                    &lt;TextView
                        android:layout_marginLeft=&quot;5dp&quot;
                        android:layout_width=&quot;wrap_content&quot;
                        android:layout_height=&quot;wrap_content&quot;
                        android:text=&quot;/&quot;
                        android:textColor=&quot;#fff&quot;
                        android:textSize=&quot;12sp&quot;/&gt;

                    &lt;TextView
                        android:id=&quot;@+id/media_total_time&quot;
                        android:layout_marginLeft=&quot;5dp&quot;
                        android:layout_width=&quot;wrap_content&quot;
                        android:layout_height=&quot;wrap_content&quot;
                        android:text=&quot;00:00:00&quot;
                        android:textColor=&quot;#fff&quot;
                        android:textSize=&quot;12sp&quot;/&gt;

                    &lt;ImageView
                        android:id=&quot;@+id/media_sounds&quot;
                        android:visibility=&quot;gone&quot;
                        android:layout_marginLeft=&quot;100dp&quot;
                        android:layout_width=&quot;20dp&quot;
                        android:layout_height=&quot;match_parent&quot;
                        android:src=&quot;@drawable/icon_sounds&quot;/&gt;


                    &lt;SeekBar
                        android:visibility=&quot;gone&quot;
                        android:id=&quot;@+id/media_sounds_progress&quot;
                        android:thumb=&quot;@null&quot;
                        android:progressDrawable=&quot;@drawable/seekbar_style&quot;
                        android:max=&quot;100&quot;
                        android:progress=&quot;20&quot;
                        android:indeterminate=&quot;false&quot;
                        android:layout_width=&quot;100dp&quot;
                        android:layout_height=&quot;5dp&quot;
                        android:layout_marginLeft=&quot;-10dp&quot;
                        /&gt;
                &lt;/LinearLayout&gt;

                &lt;ImageView
                    android:id=&quot;@+id/media_full_screen&quot;
                    android:layout_marginRight=&quot;15dp&quot;
                    android:layout_alignParentRight=&quot;true&quot;
                    android:layout_centerVertical=&quot;true&quot;
                    android:layout_width=&quot;20dp&quot;
                    android:layout_height=&quot;20dp&quot;
                    android:src=&quot;@drawable/ic_full_screen&quot;/&gt;
            &lt;/RelativeLayout&gt;
        &lt;/LinearLayout&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:gravity=&quot;center&quot;&gt;
            &lt;include layout=&quot;@layout/dialog&quot;
                android:visibility=&quot;gone&quot;/&gt;
        &lt;/LinearLayout&gt;

    &lt;/FrameLayout&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<h2 id="toc_2">控制器中播放暂停按钮的实现</h2>

<p>初始化音量进度条:</p>

<pre class="line-numbers"><code class="language-java">//获取音频管理器
mAudioManager = (AudioManager) getSystemService(AUDIO_SERVICE);
int streamMaxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
int streamVolume = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);

mMediaSoundsProgress.setMax(streamMaxVolume);
mMediaSoundsProgress.setProgress(streamVolume);
</code></pre>

<p>点击事件的普片切换比较简单,通过按钮的图形化切换来控制videoView的开始和暂停:在播放过程中要实时更新播放时间和进度,这里用handler来实现:</p>

<pre class="line-numbers"><code class="language-java">private void setPlayer() {
    mMediaActions.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            if (mVideoView.isPlaying()){
                mMediaActions.setImageResource(R.drawable.play_btn);
                mVideoView.pause();
                mHandler.removeMessages(UpDate);
            }else {
                mMediaActions.setImageResource(R.drawable.stop_btn);
                mVideoView.start();
                mHandler.sendEmptyMessage(UpDate);
            }
        }
    });
}
</code></pre>

<p>在上面代码中看到,由播放状态改变为暂停状态,实时跟新的hanler停止,切换为播放再次开启;下面看下线程中实时更新的代码:</p>

<pre class="line-numbers"><code class="language-java">private Handler mHandler = new Handler(){
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        if (msg.what == UpDate){
            //当前时间
            int currentPosition = mVideoView.getCurrentPosition();

            //总时间
            int duration = mVideoView.getDuration();
            //设置时间
            updateTime(mMediaTime,currentPosition);
            updateTime(mMediaTotalTime,duration);
          //设置进度
          mMediaProgress.setMax(duration);
          mMediaProgress.setProgress(currentPosition);

          mHandler.sendEmptyMessageDelayed(UpDate,500);
        }
    }
};
</code></pre>

<p>到这一步,视频可以播放,播放进度条实时跟新,播放时间可以实时更新;</p>

<p>当然在一个视频播放器中,必须实现进度条的拖动来实现进度的控制(就是快进和快退);那么需要监听播放进度条的拖动事件:</p>

<p>private void setScrollSeek() {<br/>
    //播放器的进度条监听<br/>
    mMediaProgress.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {<br/>
        @Override<br/>
        public void onProgressChanged(SeekBar seekBar, int progress, boolean b) {<br/>
            updateTime(mMediaTime,progress);<br/>
        }</p>

<pre class="line-numbers"><code class="language-text">    @Override
    public void onStartTrackingTouch(SeekBar seekBar) {
        mHandler.removeMessages(UpDate);
    }

    @Override
    public void onStopTrackingTouch(SeekBar seekBar) {
        int progress = seekBar.getProgress();
        mVideoView.seekTo(progress);
        mHandler.sendEmptyMessage(UpDate);
    }
</code></pre>

<p>});</p>

<h2 id="toc_3">横竖屏切换;</h2>

<h3 id="toc_4">VideoView重新测量</h3>

<p>手机翻转然后横竖屏自由切换,当然在第一步中有提到自定义videoView重新测量,也是为了横竖屏切换时候做准备,防止半屏显示不全的出现:首先在清单文件中配置:(而且切换横屏之后音量键开始显示)</p>

<pre class="line-numbers"><code class="language-text">&lt;activity
    android:configChanges=&quot;orientation|screenSize|keyboard|keyboardHidden&quot;
    android:name=&quot;.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>这样设置之后可以全屏,但是videoView并不可以适配,所以需要MainActivity中重写onConfigurationChanged:</p>

<pre class="line-numbers"><code class="language-text">@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    //当为横屏时候
    if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE){
        setConfigWh(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
        isFull = true;

        //音量键的显示
        mMediaSounds.setVisibility(View.VISIBLE);
        mMediaSoundsProgress.setVisibility(View.VISIBLE);
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);

    }else{
        //当为竖屏时候
        setConfigWh(ViewGroup.LayoutParams.MATCH_PARENT, DensityUtil.dp2px(this,240));
        isFull = false;

        mMediaSounds.setVisibility(View.GONE);
        mMediaSoundsProgress.setVisibility(View.GONE);
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
    }
}
</code></pre>

<h3 id="toc_5">全屏</h3>

<p>在竖屏状态下,点击右下角的全屏按钮 也会显示横屏,所以需要设置其点击事件:</p>

<pre class="line-numbers"><code class="language-java">private void setFullScreen() {
    //设置全屏播放
    mMediaFullScreen.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            if (isFull){
                //此时是全屏
                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);

            }else {
                //此时是半屏
                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);

            }
        }
    });
}
</code></pre>

<p>当这里横竖屏切换和适配就可以正常显示了</p>

<h2 id="toc_6">音量显示</h2>

<p>切换到横屏之后音量键显示,则需要显示器控制音量的功能:</p>

<pre class="line-numbers"><code class="language-java">//声音调节进度条
mMediaSoundsProgress.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
    @Override
    public void onProgressChanged(SeekBar seekBar, int progress, boolean b) {
        mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC,progress,0);
    }

    @Override
    public void onStartTrackingTouch(SeekBar seekBar) {
    }

    @Override
    public void onStopTrackingTouch(SeekBar seekBar) {
    }
});
</code></pre>

<p>当这里一个简单的播放器基本完备</p>

<h2 id="toc_7">手势</h2>

<p><strong>接下来来添加手势</strong></p>

<p>大概策略是这样:横屏状态下(需要添加boolean判断来限定横屏之下触发):当上下滑动屏幕左半边,亮度改变,弹出一个类似dialog显示连读进度条的改变,结束触摸,则弹窗消失;当上下滑动屏幕右半边,声音改变,弹出一个类似dialog显示连读进度条的改变,结束触摸,则弹窗消失,在这个过程中控制台区域的声音进度条也会实时改变; </p>

<h3 id="toc_8">手势添加</h3>

<p>先来看手势的添加:</p>

<pre class="line-numbers"><code class="language-java">private void setScrollScreen() {
    mVideoView.setOnTouchListener(new View.OnTouchListener() {
    @Override
    public boolean onTouch(View view, MotionEvent event) {
        float x = event.getX();
        float y = event.getY();
        switch (event.getAction()){
            case MotionEvent.ACTION_DOWN:
                lastX = x;
                lastY = y;
                break;
            case MotionEvent.ACTION_MOVE:
                //获取屏幕宽和高
                widthPixels = getResources().getDisplayMetrics().widthPixels;
                heightPixels = getResources().getDisplayMetrics().heightPixels;
                //偏移量的记录
                float dx = x - lastX;
                float dy = y - lastY;
                float absX = Math.abs(dx);
                float absY = Math.abs(dy);

                if (absX &gt; trueshold &amp;&amp; absY &gt; trueshold){
                    if (absX &gt;= absY){
                        isadjust = false;
                    }else if (absY &gt; absX){
                        isadjust = true;
                    }
                }else if (absX &gt;= trueshold &amp;&amp; absY &lt; trueshold){
                    isadjust = false;
                }else if(absX &lt; trueshold &amp;&amp; absY &gt;= trueshold){
                    isadjust = true;
                }

                //开始判断 音量调节 和 亮度调节
                if (isadjust){
                    //Log.i(&quot;==widthPixels&quot;,x + &quot;&quot;);
                    if (x &gt; widthPixels/2){
                        //声音
                        if (dy &gt; 0){
                            //降低声音
                        }else {
                            //增大声音
                        }
                        //改变声音
                        changeVoice(-dy);

                    }else if(x &lt; widthPixels/2){
                        //亮度
                        if (dy &gt; 0){
                            //降低亮度
                            //Log.i(&quot;==降低亮度&quot;,dy + &quot;&quot;);
                        }else {
                            //增大亮度
                            //Log.i(&quot;==增大亮度&quot;,dy + &quot;&quot;);
                        }

                        //改变亮度
                        changeBrightness(-dy);
                    }
                }
                lastX = x;
                lastY = y;
                break;
            case MotionEvent.ACTION_UP:
                mDialogLl.setVisibility(View.GONE);
                break;
            }
        return true;
        }
    });
}
</code></pre>

<p>就是一个onTouch的触摸事件,首先判断手势是否合法,规定一个偏移量,当,当dx dy全部超过偏移量,dy&gt;dx 手势触发 isadjust = true;<br/><br/>
当dx&lt;偏移量,dy大于偏移量手势触发 isadjust = true;<br/><br/>
触发之后判断 当x &gt; widthPixels/2,在屏幕右半边,触发音量控制<br/><br/>
当当x &lt; widthPixels/2,在屏幕左半边,触发屏幕亮度控制  </p>

<p>ok~接下来看屏幕亮度变化的代码:</p>

<pre class="line-numbers"><code class="language-java">//控制亮度
public void changeBrightness(float absY){
    mDialogLl.setVisibility(View.VISIBLE);

    WindowManager.LayoutParams attributes = getWindow().getAttributes();
    mScreenBrightness = attributes.screenBrightness;
    float index = absY / heightPixels;
    mScreenBrightness += index;
    //进行判断
    if (mScreenBrightness &gt; 1.0f){
        mScreenBrightness = 1.0f;
    }else if (mScreenBrightness &lt; 0.01f){
        mScreenBrightness = 0.01f;
    }
    attributes.screenBrightness = mScreenBrightness;
    getWindow().setAttributes(attributes);


    //设置弹窗
    mDialogPic.setImageResource(R.drawable.icon_media_screen);
    mDialogProgress.setMax(10);
    mDialogProgress.setProgress((int)(mScreenBrightness * 10));
    Log.i(&quot;==mScreenBrightness&quot;,mScreenBrightness * 100 + &quot;&quot;);
}
</code></pre>

<p><strong>声音变化的代码</strong>:</p>

<pre class="line-numbers"><code class="language-java">//控制声音
public void changeVoice(float absY){

    mDialogLl.setVisibility(View.VISIBLE);

    int maxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
    int volume = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);

    int dVoice = (int) (absY / heightPixels * maxVolume * 3);
    int max = Math.max(dVoice + volume, 0);
    //设置声音
    mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC,max,0);
    mMediaSoundsProgress.setProgress(max);
    //设置弹窗
    mDialogPic.setImageResource(R.drawable.icon_media_sounds);
    mDialogProgress.setMax(maxVolume);
    mDialogProgress.setProgress(max);
}
</code></pre>

<p>这样就实现声音,屏幕亮度和手势的交互;当然不要忘了结束触摸要隐藏dialog窗口:</p>

<pre class="line-numbers"><code class="language-text">case MotionEvent.ACTION_UP:
    mDialogLl.setVisibility(View.GONE);
    break;
</code></pre>

<p>到此为止,一个横竖屏切换自如,快进快退可实现,手势和声音,屏幕亮度可以实时交互,播放信息实时更新的android播放器就完成</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872529.html">
                
                  <h1>Android-最适合使用RxJava处理的四种场景</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>RxJava是非常热门的函数响应式编程库，在Android开发中已经非常流行了，刚开始上手会有点难，但只要理解了它，就再也回不去了；不使用RxJava写异步请求的话，就感觉各种不爽。</p>

<p>本文不准备讲RxJava的基础知识，如果你对RxJava不熟悉，这里有篇不错的教程可以参考《给 Android 开发者的 RxJava 详解》。</p>

<p>下面我们开始介绍RxJava最适合使用的四种场景，代码示例基于RxJava1</p>

<h2 id="toc_1">场景一： 单请求异步处理</h2>

<p>由于在Android UI线程中不能做一些耗时操作，比如网络请求，大文件保存等，所以在开发中经常会碰到异步处理的情况，我们最典型的使用场景是RxJava+Retrofit处理网络请求</p>

<pre class="line-numbers"><code class="language-java">MyService myService = retrofit.create(MyService.class);
myService.getSomething()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(this::updateUI, this::showError);
</code></pre>

<p>为了使代码看起来简洁点，这边还使用了lambda表达式，updateUI和showError需要在当前类中实现，比如：</p>

<pre class="line-numbers"><code class="language-java">public void updateUI(Data data){
      //TODO something
}

public void showError(throwable t){
      //show error msg
}
</code></pre>

<h2 id="toc_2">场景二： 多异步请求连续调用</h2>

<p>这种场景其实也很常见，我们做用户头像编辑的使用，一般就会有三个请求需要连续调用：</p>

<ol>
<li>请求头像上传的地址</li>
<li>上传头像</li>
<li>更新用户信息</li>
</ol>

<p>在平时的代码里，我们需要一步步callback嵌套下来，代码冗长太难看，而且不好维护，使用RxJava链式调用处理代码逻辑就会非常清晰</p>

<pre class="line-numbers"><code class="language-java">MyService myService = retrofit.create(MyService.class);
myService.getUploadUrl()
        .flatMap(this::uploadImageTask)
        .flatMap(this::updateUserInfo)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(this::updateUI, this::showError);
</code></pre>

<p>先获取请求，再上传头像，最后更新用户信息，后面的任务依赖上一步的处理结果，依次执行。</p>

<h2 id="toc_3">场景三： 多异步请求合并处理</h2>

<p>有时候在项目中，我们会碰到组合多个请求的结果后，再更新UI的情况，比如我们项目中就有一个从多个请求地址获取通知数据，然后在APP上再按时间顺序组合后展示的需求，这时候我们就可以用RxJava的zip函数来处理了</p>

<pre class="line-numbers"><code class="language-java">MyService myService = retrofit.create(MyService.class);
Observable o1 = myService.getNotification1();
Observable o2 = myService.getNotification2();
Observable.zip(o1,o2, this::combiNotification)
             .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(this::updateUI, this::showError);


public List&lt;Notification&gt; combiNotification(List&lt;Notification&gt; n1, List&lt;Notification&gt; n2){
      //TODO 合并通知列表
}
</code></pre>

<p>zip函数会等待两个请求都完成后，调用我们的合并方法combiNotification，等合并处理后再回调subscribe中的方法。</p>

<h2 id="toc_4">场景四： 定时轮询</h2>

<p>RxJava还特别适合对定时轮询任务的处理， 一种典型的例子就是APP提交了一个任务给后台异步处理，假设后台处理需要1-2分钟左右，我们需要定时到后台查询进度，并更新到UI上, 传统的做法是用Handler的postDelay方法，用RxJava实现的话就会非常简洁</p>

<pre class="line-numbers"><code class="language-java">Subscription subscription =  Observable.interval(2, TimeUnit.SECONDS)
                .map(this::getProgress)
                .takeUntil(progress -&gt; progress !=  100)
                .subscribeOn(Schedulers.newThread())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Subscriber&lt;Long&gt;() {
                    @Override
                    public void onCompleted() {
                        //TODO finished
                    }

                    @Override
                    public void onError(Throwable e) {
                    }

                    @Override
                    public void onNext(int progress) {
                         //TODO update progress
                    }
                });
</code></pre>

<p>我们以定时2秒查询一次，直到进度progress=100为止，自动终止轮询。<br/>
以上各种RxJava方法都是异步耗时调用，考虑到Activity的退出时请求还没有完成，我们需要在Activity的OnDestroy方法中取消RxJava调用<br/><br/>
<code>subscription.unsubscribe();</code></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15580646892750.html">发布Android库至JCenter仓库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576631048737.html">单例模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576630121534.html">23种设计模式全面解析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873148.html">Android RecyclerView性能优化</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873102.html">Android 基础复习</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
