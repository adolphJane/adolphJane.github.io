<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android%E6%BA%90%E7%A0%81.html">Android源码</a></li>
        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870570.html">
                
                  <h1>Android-自定义锁屏页</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、为什么需要自定义锁屏页</h2>

<p>　　锁屏作为一种黑白屏时代就存在的手机功能，至今仍发挥着巨大作用，特别是触屏时代的到来，锁屏的功用被发挥到了极致。多少人曾经在无聊的时候每隔几分钟划开锁屏再关上，孜孜不倦，其酸爽程度不亚于捏气泡膜。确实，一款漂亮的锁屏能为手机增色不少，但锁屏存在的核心目的主要是三个：保护自己手机的隐私，防止误操作，在不关闭系统软件的情况下节省电量。<br/>
　　当下，各个款式的手机自带的系统锁屏完全能够满足这些需求，而且美观程度非凡，那么开发者为什么仍然需要构建自定义锁屏呢？让我们试想一个场景，一位正在使用音乐播放器听歌的美女用户，在没有播放器自定义锁屏的情况下，切换一首歌需要几步（参考自同类文章）：</p>

<ol>
<li>点亮手机屏幕</li>
<li>解开系统锁屏</li>
<li>打开音乐播放器</li>
<li>切歌再熄灭屏幕</li>
</ol>

<p>　　这时的她估计已经被广场舞的歌曲骚扰了有10秒，续了10次命，这是我们程序员不愿意看到的，所以有必要依靠我们灵活的双手构建出自定义的音乐锁屏页，将切歌过程被压缩为两步：点亮屏幕和切歌，顺便可以看看歌词。如果再加个开启和关闭自定义锁屏的开关，就能完美解决用户的痛点。</p>

<h2 id="toc_1">二、自定义锁屏页的基本原理</h2>

<p>　　然而，要实现一个自定义锁屏是一件繁琐的事情，因为系统有100种方法让这个非本地的锁屏待不下去。但是，人类的智慧是无限的，程序员需要逆流而上。<br/><br/>
　　Android系统实现自定义锁屏页的思路很简单，即在App启动时开启一个service，在Service中时刻监听系统SCREEN_OFF的广播，当屏幕熄灭时，Service监听到广播，开启一个锁屏页Activity在屏幕最上层显示，该Activity创建的同时会去掉系统锁屏（当然如果有密码是禁不掉的）。示意图如下：</p>

<p><figure><img src="media/15561207870570/15713322679776.png" alt=""/></figure></p>

<p>道理很简单，我们这里需要讨论的是细节。</p>

<h3 id="toc_2">广播注册</h3>

<p>　　Service是普通的Service，在应用启动时直接startService，与应用同一个进程即可。此外，SCREEN_OFF广播监听必须是动态注册的，如果在AndroidManifest.xml中静态注册将无法接收到SCREEN_OFF广播，这点在Android官方文档中有明确说明，即需要通过如下代码注册：</p>

<pre class="line-numbers"><code class="language-java">IntentFilter mSereenOffFilter = new IntentFilter();
mScreenOffFilter.addAction(Intent.ACTION_SCREEN_OFF);
registerReceiver(mScreenOffReveiver,mScreenOffFilter);
</code></pre>

<p>　　对应的BroadcastReceiver定义如下：</p>

<pre class="line-numbers"><code class="language-java">private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver(){
    @SuppressWarnings(&quot;deprecation&quot;)
    @Override
    public void onReceive(Context context,Intent intent){
        if(intent.getAction().equals(NOTIFY_SCREEN_OFF)){
            Intent mLockIntent = new Intent(context, LockScreenActivity.class);
            mLockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
            startActivity(mLockIntent);
        }
    }
}
</code></pre>

<p>　　关于启动Activity时Intent的Flag问题，如果不添加FLAG_ACTIVITY_NEW_TASK的标志位，会出现“Calling startActivity() from outside of an Activity”的运行时异常，毕竟我们是从Service启动的Activity。Activity要存在于activity的栈中，而Service在启动activity时必然不存在一个activity的栈，所以要新起一个栈，并装入启动的activity。使用该标志位时，也需要在AndroidManifest中声明taskAffinity，即新task的名称，否则锁屏Activity实质上还是在建立在原来App的task栈中。<br/>
　　标志位FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS，是为了避免在最近使用程序列表出现Service所启动的Activity,但这个标志位不是必须的，其使用依情况而定。</p>

<h3 id="toc_3">Activity设置</h3>

<p>　　锁屏的activity内部也要做相应的配置，让activity在锁屏时也能够显示，同时去掉系统锁屏。当然如果设置了系统锁屏密码，系统锁屏是没有办法去掉的，这里考虑没有设置密码的情况。<br/><br/>
　　典型的去掉系统锁屏页的方法是使用KeyguardManager，具体代码如下：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">KeyguardManager mKeyguardManager = (KeyguardManager)getSystemService(Context.KEYGUARD_SERVICE);
KeyguardManager.KeyguardLock mKeyguardLock = mKeyguardManager.newKeyguardLock(&quot;CustomLockScreen&quot;);
mKeyguardLock.disableKeyguard();
</code></pre>

<p>　　其中，KeyguardManager是锁屏管理类，我们通过getSystemService()的方式获取实例对象mKeyguardManager，调用该对象的newKeyguardLock()方法获取KeyguardManager的内部类KeyguardLock的实例mKeyguardLock，该方法传入的字符串参数用于标识是谁隐藏了系统锁屏，最后调用mKeyguardLock的disableKeyguard()方法可以取消系统锁屏。<br/><br/>
　　上述方法已经不推荐使用，可以使用更好的方法来替代。我们在自定义锁屏Activity的onCreate()方法里设定以下标志位就能完全实现相同的功能：</p>

<pre class="line-numbers"><code class="language-java"> getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
 getWindow().addFlags(WindowManager.LayoutParams.FLAG_OW_WHEN_LOCKED);
</code></pre>

<p>　　FLAG_DISMISS_KEYGUARD用于去掉系统锁屏页，FLAG_SHOW_WHEN_LOCKED使Activity在锁屏时仍然能够显示。当然，不要忘记在Manifest中加入适当的权限：</p>

<pre class="line-numbers"><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot;/&gt;
</code></pre>

<h3 id="toc_4">屏蔽按键</h3>

<p>　　当自定义锁屏页最终出现在手机上时，我们总希望它像系统锁屏页那样屹立不倒，所有的按键都不能触动它，只有通过划瓶或者指纹才能解锁，因此有必要对按键进行一定程度上的屏蔽。针对只有虚拟按键的手机，我们可以通过隐藏虚拟按键的方式部分解决这个问题，具体方法在后文会介绍。但是当用户在锁屏页底部滑动，隐藏后的虚拟按键还是会滑出，而且如果用户是物理按键的话就必须进行屏蔽了。<br/><br/>
　　Back键和Menu键可以通过重写onKeyDown()方法进行屏蔽：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">public boolean onKeyDown(int keyCode, KeyEvent event){
    int key = event.getKeyCode();
    switch(key){
        case KeyEvent.KEYCODE_BACK:{
            return true;
        }
        case KeyEvent.KEYCODE_MENU:{
            return true;
        }
    }
    return super.onKeyDown(keyCode,event);
}
</code></pre>

<p>　　Home键与Recent键（调出最近打开应用的按键）的点击事件是在framework层进行处理的，因此onKeyDown与dispatchKeyEvent都捕获不到点击事件。关于这两个按键的屏蔽方法，网上相关的资料有很多，有的用到了反射，有的通过改变Window的标志位和Type等，总的来说这些方法只对部分android版本有效，有的则完全无法编译通过。其实，这么做的目的无非是为了实现一个纯粹的锁屏页，但是这种做法有些画蛇添足，容易造成锁屏页的异常崩溃，我们要满足的是用户在锁屏页的快捷操作，Home键和Recent键无关痛痒，完全可以不管,少一些套路，多一点真诚嘛。</p>

<h3 id="toc_5">划屏解锁</h3>

<p>　　做完以上几步，当屏幕熄灭后，再打开屏幕就能够看到我们的自定义锁屏页了，但是这时候，就算划破手指也无法解锁。所以，接下来要实现划屏解锁。<br/><br/>
　　划瓶解锁的基本思路很简单，当手指在屏幕上滑动时，拦截并处理滑动事件，使锁屏页面随着手指运动，当运动到达一定的阀值时，用户手指松开手指，锁屏页自动滑动到屏幕边界消失，如果没有达到运动阀值，就会自动滑动到起始位置，重新覆盖屏幕。<br/><br/>
　　为了将划屏逻辑与页面内容隔离开来，我们在锁屏页面布局中添加一个自定义的UnderView，这个UnderView填充整个屏幕，位于锁屏内容View（将其引用称之为mMoveView,并传入到UnderView中）的下方，所有划屏相关的事件都在这里拦截并处理。</p>

<p><figure><img src="media/15561207870570/15713322783529.png" alt=""/></figure></p>

<p>mMoveView是锁屏页的显示内容，除了处理一些简单的点击事件，其他非点击事件序列都由底层的UnderView进行处理。只需要重写UnderView的onTouchEvent方法就能够实现：</p>

<pre class="line-numbers"><code class="language-java">@Override
public boolean onTouchEvent(MotionEvent event){
    final int action = event.getAction();
    final float nx = event.getX();
    switch(action){
        case MotionEvent.ACTION_DOWN:
            mStartX = nx;
            onAnimationEnd();
        case MotionEvent.ACTION_MOVE:
            handleMoveView(nx);
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            doTriggerEvent(nx);
            break;
    }
    return true;
}
</code></pre>

<p>　　其中，mStartX记录滑动操作起始的x坐标，handleMoveView方法控制mMoveView随手指的移动，doTriggerEvent处理手指离开后mMoveView的移动动画。两个方法的定义如下：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">private void handleMoveView(float x){
    float movex = x - mStartX;
    if(movex &lt; 0)
        movex = 0;
    mMoveView.setTranslationX(movex);
    
    float mWidthFloat = (float) mWidth; // 屏幕显示宽度
    if(getBackground() != null){
        getBackground().setAlpha((int) ((mWidthFloat - mMoveView.getTranslationX()) / mWidthFloat * 200));  //初始透明度的值为200
    }
}
</code></pre>

<p>　　在handleMoveView()中，首先计算当前触点x坐标与初始x坐标mStartX的差值movex，然后调用mMoveView的setTranslationX方法移动。值得注意的是，目前setTranslationX方法只能在Android 3.0以上版本使用，如果采用动画兼容库nineoldandroid中ViewHelper类提供的setTranslation方法，则没有这个问题。scrollTo与scrollBy也可以实现移动，但是只是移动View的内容，并不能移动View本身。另外就是通过修改布局参数LayoutParams实现移动，虽然没有版本的限制，用起来相对复杂。这里我们采用setTranslationX，为了简洁，也是为了能够与后续使用的属性动画相统一。<br/><br/>
　　此外，我们可以通过getBackground()获取UnderView的背景，并根据已划开屏幕占整个屏幕的百分比调用setAlpha方法改变背景的透明度，做出抽屉拉开时的光影变化效果。</p>

<pre class="line-numbers"><code class="language-java">private void doTriggerEvent(float x){
    float movex = x - mStartX;
    if(movex &gt; (mWidth * 0.4)){
        moveMoveView(mWidth - mMoveView.getLeft(),true);//自动移动到屏幕右边界之外，并finish掉
    } else {
        moveMoveView(-mMoveView.getLeft(),false);//自动移动回初始位置，重新覆盖
    }
}

private void moveMoveView(float to,boolean exit){
    ObjectAnimator animator = ObjectAnimator.ofFloat(mMoveView, &quot;translationX&quot;,to);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
        @Override
        public void onAnimationUpdate(new ValueAnimator animation){
            if(getBackground() != null){
                getBackground().setAlpha((int)(((float)mWidth - mMoveView.getTranslationX()) / (float) mWidth * 200));
            }
        }
    });//随意动动画背景更新背景透明度
    animator.setDuration(250).start();
    if(exit){
        animator.addListener(new AnimatorListenerAdapter(){
            @Override
            public void onAnimationEnd(Animator animation){
                mainHandler.obtainMessage(LockScreenAcitvity.MSG_LAUNCH_HOME).sendToTarget();
                super.onAnimationEnd(animation);
            }
        });
    }//监听动画结束，利用Handler通知Activity退出
}
</code></pre>

<p>　　当手指离开屏幕，doTraiggerEvent方法会对滑动的距离与阀值进行一个比较，此处的阀值为0.4*屏幕宽度，如果低于阀值，则通过ObjectAnimator在0.25s将mMoveView移动到初始位置，同时在ObjectAnimator的AnimatorUpdateListener的onAnimationUpdate方法中更新背景透明度；如果低于阀值，以同样的方式将mMoveView移出屏幕右边界，然后将Activity干掉，具体做法是为animator增加一个AnimatorListenerAdapter的监听器，在该监听器的onAnimationEnd方法中使用在Activity中定义的mHandler发送finish消息，完成解锁，效果如下图：</p>

<h2 id="toc_6">三、透明栏与沉浸模式</h2>

<p>　　沉浸模式与透明栏是两个不同的概念，由于某些原因，国内一些开发或产品会把这两个概念混淆。不过没关系，在接下来的内容我们会对这两个概念进行详细的解释和区分，并应用这两种不同的模式进一步完善已经初具模样的锁屏页。</p>

<h3 id="toc_7">沉浸模式</h3>

<p>　　什么是沉浸模式？从4.4开始，Android 为 “setSystemUiVisibility()”方法提供了新的标记 “SYSTEM_UI_FLAG_IMMERSIVE”以及”SYSTEM_UI_FLAG_IMMERSIVE_STIKY”，就是我们所谈的沉浸模式，全称为 “Immersive Full-Screen Mode”，它可以使你的app隐藏状态栏和导航栏，实现真正意义上的全屏体验。<br/><br/>
　　之前 Android 也是有全屏模式的，主要通过”setSystemUiVisibility()”添加两个Flag，即”SYSTEM_UI_FLAG_FULLSCREEN”，”SYSTEM_UI_FLAG_HIDE_NAVIGATION”（仅适用于使用导航栏的设备，即虚拟按键）。<br/>
　　这两个标记都存在一些问题，例如使用第一个标记的时候，除非 App 提供暂时退出全屏模式的功能（例如部分电子书软件中点击一次屏幕中央位置），用户是一直都没法看见状态栏的。这样，如果用户想去看看通知中心有什么通知，那就必须点击一次屏幕，显示状态栏，然后才能调出通知中心。<br/><br/>
　　而第二个标记的问题在于，Google 认为导航栏对于用户来说是十分重要的，所以只会短暂隐藏导航栏。一旦用户做其他操作，例如点击一次屏幕，导航栏就会马上被重新调出。这样的设定对于看图软件，视频软件等等没什么大问题，但是对于游戏之类用户需要经常点击屏幕的 App，那就几乎是悲剧了——这也是为什么你在 Android 4.4 之前找不到什么全屏模式会自动隐藏导航栏的应用。<br/><br/>
　　Android 4.4 之后加入的Immersive Full-Screen Mode 允许用户在应用全屏的情况下，通过在原有的状态栏/导航栏区域内做向内滑动的手势来实现短暂调出状态栏和导航栏的操作，且不会影响应用的正常全屏，短暂调出的状态栏和导航栏会呈半透明状态，并且在一段时间内或者用户与应用内元素进行互动的情况下自动隐藏，沉浸模式的四种状态如下图。（<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0616/3047.html">参考</a>）</p>

<p><figure><img src="media/15561207870570/15713322917448.png" alt=""/></figure></p>

<p>　　状态1代表没有进入沉浸模式时页面的状态，仍然可以看到Status Bar和Navigation Bar；状态2代表用户第一次进入沉浸模式时，系统的提示弹窗，告诉用户如何在沉浸模式下呼出Status Bar和Navigation Bar；状态3代表沉浸模式，可以看到Status Bar和Navigation Bar都被隐藏；状态4代表用户在Sticky沉浸模式下呼出Status Bar和Navigation Bar，可以看到两个Bar重新出现，但是过一段时间能够自动隐藏。<br/><br/>
　　一般来说，沉浸模式的标记与其他Full Screen相关的Flag搭配起来才能达到我们想要的效果，即通过沉浸模式标记规定状态栏status bar和导航栏navigation bar显示和隐藏的运转逻辑，通过其他标签设定状态栏和导航栏显示或隐藏，以及显示或隐藏的样子。这些常见的Flag及相应功能如下表：<br/><br/>
　　<br/>
<figure><img src="media/15561207870570/15713323021382.png" alt=""/></figure></p>

<p>　　如此多的标签，看起来非常乱，但用起来却非常简单和明确，感兴趣的开发者可以自由搭配来测试一下。下面，我们通过一个例子，将这些标签应用于锁屏页，实现对Navigation Bar的自动隐藏，同时保留Status Bar。代码非常简单，在Activity的onCreate()方法中使用：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">getWindow().getDecorView().getSystemUiVisibility(
    View.SYSTEM_UI_FLAG_LAYOUT_STABLE
    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
)
</code></pre>

<p>　　总共用到了5个Flag：SYSTEM_UI_FLAG_LAYOUT_STABLE保持整个View稳定，使View不会因为SystemUI的变化而做layout；SYSTEM_UI_FLAG_IMMERSIVE_STIKY，能够在隐藏的bar被呼出时（比如从屏幕下边缘开始向上做滑动手势），使bar在无相关操作的情况下自动再次隐藏；对于SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION，开发者容易被其中的HIDE_NAVIGATION所迷惑，其实这个Flag没有隐藏导航栏的功能，只是控制导航栏浮在屏幕上层，不占据屏幕布局空间；SYSTEM_UI_FLAG_HIDE_NAVIGATION，才是能够隐藏导航栏的Flag；SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN，由上面可知，也不能隐藏状态栏，只是使状态栏浮在屏幕上层。<br/><br/>
　　需要注意的是，这段代码除了需要加在Activity的OnCreate()方法中，也要加在重写的onWindowFocusChanged()方法中，在窗口获取焦点时再将Flag设置一遍，否则可能导致无法达到预想的效果。<br/><br/>
　　</p>

<pre class="line-numbers"><code class="language-java">@Override
public void onWindowFocusChanged(boolean hasFocus){
    super.onWindowFocusChanged(hasFocus);
    if(hasFocus){
        getWindow().getDecorView().setSystemUiVisiblity(
            View.SYSTEM_UI_FLAG_LAYOUT_STABLE
            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
        )
    }
}
</code></pre>

<p>　　此外，有个部份要稍微留意一下，如果不希望界面的内容被上拉到状态栏(Status bar)的话，要记得在界面(Layout)XML文件中，在最外层Layout中将fitsSystemWindows属性设置为true。如下：</p>

<pre class="line-numbers"><code class="language-java">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>　　<br/>
手指在屏幕底端上划，Navigation Bar会弹出，悬浮于锁屏页底部，随后自动消失。Status Bar也按照我们预期的那样，悬浮在上方，没有隐藏。</p>

<h3 id="toc_8">透明栏</h3>

<p>　　什么是透明栏？Google 在 Android 4.4 的 API 描述页面里提到了“Translucent system UI styling”，即半透明化的系统UI风格。这个“半透明化”包括了状态栏和通知栏，当开发者让应用支持这个新特性的时候，状态栏和导航栏可以单独/同时变为渐变的半透明样式，如下图：</p>

<p><figure><img src="media/15561207870570/15713323115219.png" alt=""/></figure></p>

<p>　　在 Android 5.0 之后引入了 Material Design，状态栏和导航栏也玩出了更多花样。现在除了原有的“半透明”模式以外，还有“全透明”以及“变色”模式，一种会完全隐藏背景，另一种可以取色作为背景颜色，多种样式的透明栏如下图（上图为透明状态栏，下图为透明导航栏）：</p>

<p><figure><img src="media/15561207870570/15713323241444.png" alt=""/></figure></p>

<p><figure><img src="media/15561207870570/15713323362509.png" alt=""/></figure></p>

<p>　　所以，<strong>透明栏只是能够改变状态栏和导航栏的颜色，并不像沉浸模式那样隐藏状态栏和导航栏，两者是有本质区别的。</strong><br/><br/>
　　对于Android 4.4以上5.0以下的版本，设置透明状态栏的方式如下：</p>

<pre class="line-numbers"><code class="language-java">if(Build.VERSION&gt;SDK_INT &gt;= Build.VERSION_CODES.KITKAT){
    Window window = getWindow();
    window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
}
</code></pre>

<p>　　对于Android 5.0及以上版本，设置透明状态栏的方法如下：</p>

<pre class="line-numbers"><code class="language-java">if(Build.VERSION.SDK_INT &gt;= Build.VERSION.LOLLIPOP){
    Window window = getWindow();
    window.clearFlags(WindowManager.LayoutParams.FLAG_TrANSLUCENT_STATUS);
    window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
    window.addFlags(WindowManager.LayoutParams.Flag_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    window.setStatusBarColor(0);
}
</code></pre>

<p>　　除了要清理掉4.4的FLAG_TRANSLUCENT_STATUS外，还要配合SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE，添加标志位FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，并调用setStatusBarColor设置状态栏的颜色为透明。  </p>

<h2 id="toc_9">四、指纹解锁</h2>

<p>　　到这里，我们的锁屏页已经基本完工，完全能够非常优雅地解决用户的痛点，但是跟当下App自定义锁屏页的区别并不明显。接下来对新型号手机普遍具备的指纹解锁功能的考虑，则能够为锁屏页增色不少。</p>

<h3 id="toc_10">指纹识别无法解锁自定义锁屏页的问题</h3>

<p>　　持有指纹解锁手机的用户在使用App自定义锁屏页时会出现一种困惑，当你点亮屏幕，能够看到自定义锁屏页，在使用指纹解锁成功之后（部分机型指纹解锁操作只能在系统锁屏页进行），自定义锁屏页依然存在，你还是需要划开自定义锁屏页，才能看到手机主界面。<br/><br/>
　　解决这一问题的方案是一种取巧的方法，那就是在锁屏页的service中监听ACTION_USER_PRESENT广播。ACTION_USER_PRESENT广播是系统锁屏解锁广播，当系统锁屏页解锁时就会触发。如果在接收到这一广播时，将自定义锁屏页finish掉，就能避免在指纹解锁成功后自定义锁屏页仍然显示的问题。但是细心的读者会发现这种解法在逻辑上还存在问题，因为在用户没有设置锁屏密码的情况下，前文自定义锁屏页在onCreate()时设置的FLAG_DISMISS_KEYGUARD标志位能够轻易解锁系统的锁屏页，并触发ACTION_USER_PRESENT广播，此时自定义锁屏页的Service接收到这一广播后，发finish广播给自定义锁屏页，导致自定义锁屏页刚create就finish掉了，永远不可能出现。<br/><br/>
　　因此，我们必须对场景进行区分，只在有锁屏密码的情况下，才对接收到的ACTION_USER_PRESENT广播进行处理，finish自定义锁屏页。即在BroadcastReceiver的onReceive()方法中加入如下代码:</p>

<pre class="line-numbers"><code class="language-java">if(intent.getAction().equals(Intent.ACTION_USER_PRESENT)){
    if(VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN){
        if(km.isKeyguardSecure()){
            MLog.d(TAG,&quot;KeyguardSecure!&quot;);
            Intent i = new Intent(NOTIFY_USER_PRESENT);
            context.sendBroadcast(i);
        }
    }
}
</code></pre>

<p>　　这里KeyguardManager对象km的isKeyguardSecure()方法就是用来判断是否设置了锁屏密码。NOTIFY_USER_PRESENT是自定义广播，用来通知锁屏页Activity调用finish方法。<br/><br/>
　　这种做法是合理的，因为如果没有设置锁屏密码，FLAG_DISMISS_KEYGUARD标志位解锁系统锁屏之后，到达上述代码块，isKeyguardSecure()返回为false，不会导致自定义锁屏页Activity的finish操作。而如果设置了锁屏密码，FLAG_DISMISS_KEYGUARD必然无法解锁系统锁屏，到达不了上述代码块，也不会finish。这样就避免了自定义锁屏页刚创建出来就将自己finish掉的困境。另一方面，其他非FLAG_DISMISS_KEYGUARD方式触发的解锁，比如指纹解锁，都会使Activity消失，满足了需求。</p>

<h3 id="toc_11">自定义锁屏页下指纹识别无法使用的问题</h3>

<p>　　此外，有些手机型号，比如小米，在自定义锁屏页罩在系统锁屏页之上时（设置有锁屏密码），指纹解锁是无效的，也就是必须要划开自定义锁屏页，在系统锁屏页上才能进行指纹解锁。为了改善这种体验，我们可以在Activity中引入指纹解锁API，识别指纹并解锁，具体代码如下：</p>

<pre class="line-numbers"><code class="language-java">private void startFingerPrintListening(){
    if(!isFingerprintAuthAvailable()){
        return;
    } else {
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){
            if (checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED) {
                mFingerprintManager.authenticate(null,mCancellationSignal,0,new FingerprintManager.AuthenticationCallback(){
                    @Override
                    public void onAuthenticationError(int errorCode,CharSequence errString){
                        super.onAuthenticationError(errorCode,errString);
                    }
                    @Override
                    public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result){
                        super.onAuthenticationSucceeded(result);
                        finish();
                    }
                    
                    @Override
                    public void onAuthenticationFailed(){
                        super.onAuthenticationFailed();
                    }
                },null);
                return;
            }
        }
    }
}
</code></pre>

<pre class="line-numbers"><code class="language-java">public boolean isFingerprintAuthAvailable(){
    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){
        mKeyguardManager = (KeyguardManager) getSystemService(Activity.KEYGUARD_SERVICE);
        if(!mKeyguardManager.isKeyguardSecure()){
            return false;
        }
        if(checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED){
            mFingerprintManager = (FingerprintManager)getSystemService(Activity.FINGERPRINT_SERVICE);
            mCancellationSignal = new CancellationSignal();
            
            return mFingerprintManager.isHardwareDetected() &amp;&amp; mFingerprintManager.hasEnrolledFingerprints();
        } else {
         return false;
        }
    } else {
        return false;
    }
}
</code></pre>

<p>　　当然，不要忘记在Manifest中加入适当的权限：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.USEFINGERPRINT&quot;/&gt;
</code></pre>

<p>　　在调用指纹识别功能之前，我们需要判断指纹识别功能是否可用，以及APP是否有相应的权限。这一过程体现在isFingerprintAuthAvailable()中，第一步是获取KeyguardManager对象，调用isKeyguardSecure()判断是否设置有锁屏密码，如果有，则需进一步判断。checkSelfPermission用来判断APP是否有指纹识别的权限(SDK 23要求)，如果有则获取FingerprintManager对象，调用该对象的isHardwareDetected()方法判断指纹识别硬件是否可用，调用hasEnrolledFingerprints()判断是否有事先录入好的指纹，只有以上条件都满足，接下来才能调用指纹识别功能。<br/><br/>
　　指纹识别的调用体现在startFingerPrintListening()方法中，主要就是调用FingerprintManager的方法<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">authenticate(FingerprintManager.CryptoObject crypto,CancellationSignal cancel,int flags,FingerprintManager.AuthenticationCallback callback,Handler handler)
</code></pre>

<p>　　其中，crypto参数代表Android6.0中crypto objects的wrapper class，可以通过该对象使authenticate过程更加安全，也可以不使用，这里我们将其设为null；cancel用来取消anthenticate(),我们new出一个对象传入就可以；flags是标志位，设置为0；callback为指纹识别回调，包含指纹识别的核心方法：onAuthenticationError()是指纹匹配连续失败后的回调（几十秒后才能继续匹配），onAuthenticationSucceeded()是指纹匹配成功的回调，onAuthenticationFailed()是指纹匹配失败时的回调。我们在这几个方法中做相应的处理即可，在onAuthenticationSucceeded()方法中调用finish()，就能够在指纹识别成功后关闭Activity。</p>

<h2 id="toc_12">五、总结</h2>

<p>　　通过以上内容的分享，本鹅希望能够对大家的开发有所帮助，如果内容有问题，也希望大家指点。综上所述，在Android上实现自定义锁屏页并不是一件复杂的事情，关键是对一些技术点的把握要比较清楚。Service中启动Activity的正确方法，广播静态注册与动态注册的差别，touch事件的分发传播机制，透明栏与沉浸模式的综合运用，以及指纹识别新技术的应用，都有很多值得推敲的地方。笔者当初实现自定义锁屏页时，没有太多思考，有时照搬前人的做法，有时各种flag随便添加，有时新旧API混淆，虽然实现了需求，但是代码不够简洁，可读性也差。因此，在今后的开发过程中，除了要快速实现需求，还要在随后的维护中，多多思考和研究，使代码能够达到“少一行不行，多一行难受”的境界。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870533.html">
                
                  <h1>Android-ImageView详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">ScaleType</h2>

<ul>
<li><p><code>android:scaleType=&quot;center&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按照图片的原大小居中显示，不缩放，用ImageView的大小截取图片的居中部分。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerCrop&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按比例缩小图片，直到图片的宽高有一边等于ImageView的宽高，则对于另一边，图片的长度大于或等于ImageView的长度，最后用ImageView的大小居中截取该图片。</li>
<li>当图片小于ImageView的宽高：以图片的中心店和ImageView的中心点为基准，按比例扩大图片，直到图片的宽高大于或等于ImageView的宽高，并按ImageView的大小居中截取该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerInside&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心和ImageView的中心点为基准，按比例缩小图片，使图片宽高等于或者小于ImagevView的宽高，直到将图片的内容完整居中显示。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitCenter&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，居中显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitStart&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的上方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitEnd&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的下方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitXY&quot;</code></p>
<ul>
<li>表示把图片按指定的大小在ImageView中显示，拉伸或收缩图片，不保持原比例，填满ImageView。</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870497.html">
                
                  <h1>Android-Xfermode详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Xfermode</h2>

<p>Xfermode具体怎么翻译，说实话，我也不知道，我习惯叫它图片混合模式，随便了，管它叫什么，不妨碍我们使用它。关于Xfermode的说明，可以在Google文档中找到这样的描述：Xfermode是在绘图通道中自定义“传输模式”的基类。静态函数创建可以调用或者返回任意作为模式枚举指定的预定义子类实例。当Xfermode分配给Paint，然后绘制对象与Paint就具备了所添加的xfermode。读起来比较拗口，下面直接看Xfermode的源码：</p>

<pre class="line-numbers"><code class="language-java">public class Xfermode {  
    protected void finalize() throws Throwable {  
        try {  
            finalizer(native_instance);  
        } finally {  
            super.finalize();  
        }  
    }  
    private static native void finalizer(long native_instance);  
    long native_instance;  
}  
</code></pre>

<p>看，Xfermode就这么点代码，经验告诉我们，其下必有子类，擦，变元芳了~~~</p>

<p><figure><img src="media/15561207870497/15713323572183.png" alt=""/></figure></p>

<p>查看一下文档发现Xfermode确实有AvoidXfermode、PixelXorXfermode、PorterDuffXfermode，下面来继续学习一下3个子类的用法。</p>

<h2 id="toc_1">AvoidXfermode</h2>

<p>看这个子类之前告诉大家一个不幸的消息，AvoidXfermode不支持硬件加速，在高于API16的机器上不会适用，如果想测试这个子类。</p>

<ul>
<li>1，可以关闭手机的硬件加速模块；</li>
<li>2，在AndroidManifest.xml中Application节点上设置硬件加速为false。
<code>android:hardwareAccelerated=&quot;false&quot;</code></li>
</ul>

<p>在Android Studio下点击查看一下AvoidXfermode的构造方法：<br/>
<code>public AvoidXfermode(int opColor, int tolerance, Mode mode)</code></p>

<p><code>AvoidXfermode</code>的构造方法也特别简单，一共接收3个参数：第一个参数opColor是一个16进制的带透明度通道的颜色值，如0X12345678。第二个参数<code>tolerance</code>表示容差值，什么是容差值呢？可以理解成一个表示“精确”和“模糊”的概念，下面会解释一下。第三个参数是<code>AvoidXfermode</code>的模式，<code>AvoidXfermode</code>的模式一共有两种：<code>AvoidXfermode.Mode.TARGET</code>和<code>AvoidXfermode.Mode.AVOID</code>。</p>

<h2 id="toc_2">AvoidXfermode.Mode.TARGET</h2>

<p>在该模式下Android会判断画布上的颜色是否会有跟opColor不一样的颜色，比如我opColor是红色，那么在TARGET模式下就会去判断我们的画布上是否有存在红色的地方，如果有，则把该区域“染”上一层我们画笔定义的颜色，否则不“染”色，而tolerance容差值则表示画布上的像素和我们定义的红色之间的差别该是多少的时候才去“染”的，比如当前画布有一个像素的色值是(200, 20, 13)，而我们的红色值为(255, 0, 0)，当tolerance容差值为255时，即便(200, 20, 13)并不等于红色值也会被“染”色，容差值越大“染”色范围越广反之则反，空说无凭我们来看看具体的实现和效果：</p>

<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private AvoidXfermode avoidXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        avoidXfermode = new AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        mPaint.setARGB(255, 211, 53, 243);  
        mPaint.setXfermode(avoidXfermode);  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>

<p>下面来运行看效果，首先确定一下开启的模拟器是API16以下的，或者Application节点下设置了关闭“硬件加速”：</p>

<p><figure><img src="media/15561207870497/15713323776932.png" alt=""/></figure></p>

<p><code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET)：</code><br/>
大家可以看到，在我们的模式为TARGET容差值为0的时候此时只有当图片中像色颜色值为0XFFFFFFFF的地方才会被染色，而其他地方不会有改变</p>

<p>下面我们来修改一下容差值，将容差值改成255：</p>

<p><figure><img src="media/15561207870497/15713323877972.png" alt=""/></figure></p>

<p><code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.TARGET)</code><br/>
而当容差值为255的时候只要是跟0XFFFFFFFF有点接近的地方都会被染色</p>

<h2 id="toc_3">AvoidXfermode.Mode.AVOID</h2>

<p>则与TARGET恰恰相反，TARGET是我们指定的颜色是否与画布的颜色一样，而AVOID是我们指定的颜色是否与画布不一样，其他的都与TARGET类似<code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.AVOID)：</code></p>

<p><figure><img src="media/15561207870497/15713323978095.png" alt=""/></figure></p>

<p>当模式为AVOID容差值为0时，只有当图片中像素颜色值与0XFFFFFFFF完全不一样的地方才会被染色<code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.AVOID)：</code></p>

<p><figure><img src="media/15561207870497/15713324061116.png" alt=""/></figure></p>

<p>当容差值为255时，只要与0XFFFFFFFF稍微有点不一样的地方就会被染色</p>

<p>那么这玩意究竟有什么用呢？比如说当我们只想在白色的区域画点东西或者想把白色区域的地方替换为另一张图片的时候就可以采取这种方式！</p>

<h2 id="toc_4">PixelXorXfermode</h2>

<p>PixelXorXfermode是Xfermode下的另外一种图像混排模式，该类特别简单，不过呢，也很不幸的，在API16中已经过时了。我们来做一个简单的了解，先看PixelXorXfermode的构造方法：<br/>
<code>public PixelXorXfermode(int opColor)   </code></p>

<p>构造方法很简单，只要传递一个16进制带透明通道的颜色值即可，那么这个参数有什么用呢？我在Google文档中，找到了这样的一个算法：实际上PixelXorXfermode内部是按照“opColor ^ src ^ dst”这个异或算法运算的，得到一个不透明的(alpha = 255)的色彩值，设置到图像中，下面我们接着上面用到的图片Demo写个PixelXorXfermode的Demo：</p>

<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private PixelXorXfermode pixelXorXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        pixelXorXfermode = new PixelXorXfermode(0XFFFF0000);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //先绘制Bitmap，src  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        //随便设置一个纯色测试  
        mPaint.setARGB(255, 211, 53, 243);  
        //设置Xfermode  
        mPaint.setXfermode(pixelXorXfermode);  
        //在bitmap上混排一个纯色的矩形（dst）  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>

<p>混排后的图像是：</p>

<p><figure><img src="media/15561207870497/15713324266322.png" alt=""/></figure></p>

<p>PixelXorXfermode在底层已经取出src，dst每个像素点与opColor进行了opColor ^ src ^ dst运算了，结果输出就是上图所示的那样！好了，我只学这么多了，因为它已经过时了，同样上面的AvoidXfermode也是，过时了，了解即可。下面是对Xfermode的第三个子类，也是唯一一个还没有过时的，非常重要的子类PorterDuffXfermode的学习。</p>

<h2 id="toc_5">PorterDuffXfermode</h2>

<p>同样PorterDuffXfermode也是Xfermode的子类，我们先看看它的构造方法：<code>public PorterDuffXfermode(PorterDuff.Mode mode)</code></p>

<p><code>PorterDuffXfermode</code>的构造方法很简单，构造方法中需要传递一个<code>PorterDuff.Mode</code>参数，关于<code>PorterDuff.Mode</code>，我们在上篇博客中已经学习完了，其实跟<code>ColorFilter</code>的子类<code>PorterDuffColorFilter</code>的混排模式是一样的。Android系统一共提供了18种混排模式，在模拟器的<code>ApiDemos/Graphics/XferModes</code>，有张效果图：</p>

<p><figure><img src="media/15561207870497/15713324389852.png" alt=""/></figure></p>

<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式已经算法，其中比上图多了ADD和OVERLAY两种模式： </p>

<p><figure><img src="media/15561207870497/15713324526708.png" alt=""/></figure></p>

<p>Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面将会对照ApiDemos/Graphics/XferModes的程序进行修改，来测试各个模块的效果，测试程序如下：</p>

<pre class="line-numbers"><code class="language-java">public class XfermodeView extends View {  
  
    //PorterDuff模式常量 可以在此更改不同的模式测试  
    private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;  
    private PorterDuffXfermode porterDuffXfermode;  
    private int screenW, screenH; //屏幕宽高  
    private Bitmap srcBitmap, dstBitmap;  
    //源图和目标图宽高  
    private int width = 120;  
    private int height = 120;  
  
    public XfermodeView(Context context) {  
        this(context, null);  
    }  
  
    public XfermodeView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        screenW = ScreenUtil.getScreenW((Activity) context);  
        screenH = ScreenUtil.getScreenH((Activity) context);  
        //创建一个PorterDuffXfermode对象  
        porterDuffXfermode = new PorterDuffXfermode(MODE);  
        //创建原图和目标图  
        srcBitmap = makeSrc(width, height);  
        dstBitmap = makeDst(width, height);  
    }  
  
    //创建一个圆形bitmap，作为dst图  
    private Bitmap makeDst(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFFFFCC44);  
        c.drawOval(new RectF(0, 0, w  3 / 4, h  3 / 4), p);  
        return bm;  
    }  
  
    // 创建一个矩形bitmap，作为src图  
    private Bitmap makeSrc(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFF66AAFF);  
        c.drawRect(w / 3, h / 3, w  19 / 20, h  19 / 20, p);  
        return bm;  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        Paint paint = new Paint();  
        paint.setFilterBitmap(false);  
        paint.setStyle(Paint.Style.FILL);  
        //绘制“src”蓝色矩形原图  
        canvas.drawBitmap(srcBitmap, screenW / 8 - width / 4, screenH / 12 - height / 4, paint);  
        //绘制“dst”黄色圆形原图  
        canvas.drawBitmap(dstBitmap, screenW / 2, screenH / 12, paint);  
  
        //创建一个图层，在图层上演示图形混合后的效果  
        int sc = canvas.saveLayer(0, 0, screenW, screenH, null, Canvas.MATRIX_SAVE_FLAG |  
                Canvas.CLIP_SAVE_FLAG |  
                Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |  
                Canvas.FULL_COLOR_LAYER_SAVE_FLAG |  
                Canvas.CLIP_TO_LAYER_SAVE_FLAG);  
  
        //先绘制“dst”黄色圆形  
        canvas.drawBitmap(dstBitmap, screenW / 4, screenH / 3, paint);  
        //设置Paint的Xfermode  
        paint.setXfermode(porterDuffXfermode);  
        canvas.drawBitmap(srcBitmap, screenW / 4, screenH / 3, paint);  
        paint.setXfermode(null);  
        // 还原画布  
        canvas.restoreToCount(sc);  
    }  
}  
</code></pre>

<p>为了方便观察，需要将Activity_main.xml的背景色设置为黑色。</p>

<p><strong>1.PorterDuff.Mode.CLEAR</strong>。中文描述：所绘制源图像不会提交到画布上。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;</code></p>

<p><figure><img src="media/15561207870497/15713324799406.png" alt=""/></figure></p>

<p><strong>2.PorterDuff.Mode.SRC</strong>。中文描述：只显示源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC;</code></p>

<p><figure><img src="media/15561207870497/15713324920855.png" alt=""/></figure></p>

<p><strong>3.PorterDuff.Mode.DST</strong>。中文描述：只显示目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST;</code></p>

<p><figure><img src="media/15561207870497/15713325038512.png" alt=""/></figure></p>

<p><strong>4.PorterDuff.Mode.SRC_OVER</strong>。中文描述：正常绘制显示，源图像居上显示。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OVER;</code></p>

<p><figure><img src="media/15561207870497/15713325195114.png" alt=""/></figure></p>

<p><strong>5.PorterDuff.Mode.DST_OVER</strong>。中文描述： 上下层都显示。目标图像居上显示。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OVER;</code></p>

<p><figure><img src="media/15561207870497/15713325338664.png" alt=""/></figure></p>

<p><strong>6.PorterDuff.Mode.SRC_IN</strong>。中文描述： 取两层绘制交集中的源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_IN;</code></p>

<p><figure><img src="media/15561207870497/15713325520933.png" alt=""/></figure></p>

<p><strong>7.PorterDuff.Mode.DST_IN</strong>。中文描述：取两层绘制交集中的目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_IN;</code></p>

<p><figure><img src="media/15561207870497/15713325672134.png" alt=""/></figure></p>

<p><strong>8.PorterDuff.Mode.SRC_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OUT;</code></p>

<p><figure><img src="media/15561207870497/15713325797909.png" alt=""/></figure></p>

<p><strong>9.PorterDuff.Mode.DST_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OUT;</code></p>

<p><figure><img src="media/15561207870497/15713325970254.png" alt=""/></figure></p>

<p><strong>10.PorterDuff.Mode.SRC_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_ATOP;</code></p>

<p><figure><img src="media/15561207870497/15713326104118.png" alt=""/></figure></p>

<p><strong>11.PorterDuff.Mode.DST_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_ATOP;</code></p>

<p><figure><img src="media/15561207870497/15713326227426.png" alt=""/></figure></p>

<p><strong>12.PorterDuff.Mode.XOR</strong>。中文描述：异或：去除两图层交集部分<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.XOR;</code></p>

<p><figure><img src="media/15561207870497/15713326370757.png" alt=""/></figure></p>

<p><strong>13.PorterDuff.Mode.DARKEN</strong>。中文描述：取两图层全部区域，交集部分颜色加深<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DARKEN;</code></p>

<p><figure><img src="media/15561207870497/15713326508491.png" alt=""/></figure></p>

<p><strong>14.PorterDuff.Mode.LIGHTEN</strong>。中文描述：取两图层全部，点亮交集部分颜色<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.LIGHTEN;</code></p>

<p><figure><img src="media/15561207870497/15713326673606.png" alt=""/></figure></p>

<p><strong>15.PorterDuff.Mode.MULTIPLY</strong>。中文描述：取两图层交集部分叠加后颜色<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.MULTIPLY;</code></p>

<p><figure><img src="media/15561207870497/15713326778042.png" alt=""/></figure></p>

<p><strong>16.PorterDuff.Mode.SCREEN</strong>。中文描述：滤色。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SCREEN;</code></p>

<p><figure><img src="media/15561207870497/15713326858545.png" alt=""/></figure></p>

<p>以下是<a href="http://lib.csdn.net/base/android">android</a>中新加的两种模式：</p>

<p><strong>17.ADD</strong>。中文描述：饱和度相加。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.ADD;</code></p>

<p><figure><img src="media/15561207870497/15713326949445.png" alt=""/></figure></p>

<p><strong>18.OVERLAY</strong>。中文描述：叠加<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.OVERLAY;</code></p>

<p><figure><img src="media/15561207870497/15713327034956.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870461.html">
                
                  <h1>Android-Paint详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>的确平时开发中，用到画笔的地方还是不多的。但是一遇到自定义View，就会发现这玩意还真是不能不好好掌握，毕竟绘出我们想要的图形界面就靠它了。很多开发人员对画笔Paint的了解知之甚少，包括我自己在内，所以在今天在这里总结一下Paint的在 android图像处理中起到的作用和用法。</p>

<h2 id="toc_1">Paint的简单了解</h2>

<p>同样，我们学习Paint之前，首先查看一下Paint类的API，其中，我们最需要关注的地方就是Paint类给我们提供了很多的setter方法，可以通过调用setter方法来设置自己的偏好。下面是在Android Studio中查到的Paint类的部分setter：</p>

<p><figure><img src="media/15561207870461/15713327196078.png" alt=""/></figure></p>

<ul>
<li><code>Paint(int flags)</code>：构建Paint实例，常用的flags是ANTI_ALIAS_FLAG，消除锯齿。</li>
<li><code>set(Paint src)</code>：将另一个Paint复制给当前Paint实例，不多说了。</li>
<li><code>setColor(int color)</code>：设置画笔的颜色。</li>
<li><code>setColorFilter(ColorFilter filter)</code>：设置色彩过滤器，很重要，后面还会有一些总结。</li>
<li><code>setStyle(Paint.Style style)</code>：设置Paint的风格。 画笔样式分三种：1.Paint.Style.STROKE：描边 。2.Paint.Style.FILL_AND_STROKE：描边并填充 。3.Paint.Style.FILL：填充 。</li>
<li><code>setAlpha(int a)</code> : 设置绘制图形的透明度。</li>
<li><code>setAntiAlias(boolean aa)</code>：是否消除锯齿。</li>
<li><code>setARGB(int a,int r,int g,int b)</code> : 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。</li>
<li><code>setStrokeWidth(float width)</code>：设置Paint划线的宽度。</li>
<li><code>setDither(boolean dither)</code> : 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰</li>
<li><code>setElegantTextHeight(boolean elegant)</code> : //设置优雅的文字高度，这个设置可能会对FontMetrics产生影响</li>
<li><code>setFakeBoldText(boolean fakeBoldText)</code> : //设置文本粗体</li>
<li><code>setFilterBitmap(boolean filter)</code> : //对位图进行滤波处理，如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示</li>
<li><code>setFlags(int flags)</code> : //设置一些标志，比如抗锯齿，下划线等等。</li>
<li><code>setFontFeatureSettings(String settings)</code> : //设置字体样式，可以设置CSS样式</li>
<li><code>setHinting(int mode)</code> : 设置画笔的隐藏模式。可以是 <code>HINTING_OFF</code> or <code>HINTING_ON</code>之一。</li>
<li><code>setLetterSpacing(float letterSpacing)</code> : //设置行的间距，默认值是0，负值行间距会收缩</li>
<li><code>setLinearText(boolean linearText)</code> : //这个是文本缓存，设置线性文本，如果设置为true就不需要缓存</li>
<li><code>setMaskFilter(MaskFilter maskfilter)</code> : //对图像进行一定的处理，实现滤镜的效果，如滤化，立体等,有BlurMaskFilter，EmbossMaskFilter几种</li>
<li><code>setPathEffect(PathEffect effect)</code> : //设置绘制路径的效果，有ComposePathEffect，CornerPathEffect，DashPathEffect，DiscretePathEffect，PathDashPathEffect，SumPathEffect几种</li>
<li><code>setShader(Shader shader)</code> : //设置着色器，用来给图像着色的，绘制出各种渐变效果，有BitmapShader，ComposeShader，LinearGradient，RadialGradient，SweepGradient几种</li>
<li><code>setShadowLayer(float radius, float dx, float dy, int shadowColor)</code> : //设置阴影效果，radius为阴影角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 ，看一下演示效果，其中第一个是没有阴影的，第二个设置了黑色的阴影</li>
<li><code>setStrikeThruText(boolean strikeThruText)</code> : //设置文本的删除线</li>
<li><code>setStrokeCap(Cap cap)</code> : //设置线条末端形状<code>Paint.Cap.BUTT</code>、<code>Paint.Cap.ROUND</code>、<code>Paint.Cap.SQUARE</code></li>
<li><code>setStrokeJoin(Join join)</code> : //设置矩形连接时的效果<code>Paint.Join.BEVEL</code>、<code>Paint.Join.MITER</code>、<code>Paint.Join.ROUND</code></li>
<li><code>setStrokeMiter(float miter)</code> : //当style为Stroke或StrokeAndFill时设置连接处的倾斜度，这个值必须大于0</li>
<li><code>setSubpixelText(boolean subpixelText)</code> : //设置亚像素，是对文本的一种优化设置，可以让文字看起来更加清晰明显，可以参考一下PC端的控制面板-外观和个性化-调整ClearType文本</li>
<li><code>setTextAlign(Align align)</code> : //设置文本对齐<code>Paint.Align.CENTER</code>、<code>Paint.Align.LEFT</code>、<code>Paint.Align.RIGHT</code></li>
<li><code>setTextLocale(Locale locale)</code> ： //设置地理位置，比如显示中文，日文，韩文等，默认的显示Locale.getDefault()即可</li>
<li><code>setTextScaleX(float scaleX)</code> : //设置字体的水平方向的缩放因子，默认值为1，大于1时会沿X轴水平放大，小于1时会沿X轴水平缩小</li>
<li><code>setTextSize(float textSize)</code> : //设置字体大小</li>
<li><code>setTextSkewX(float skewX)</code> : //设置文本在水平方向上的倾斜，默认值为0，推荐的值为-0.25</li>
<li><code>setTypeface(Typeface typeface)</code> : //设置字体样式，可以是Typeface设置的样式，也可以通过Typeface的createFromAsset(AssetManager mgr, String path)方法加载样式</li>
<li><code>setUnderlineText(boolean underlineText)</code> : //设置文本的下划线</li>
<li><code>setXfermode(Xfermode xfermode)</code>：设置Paint的模式，后面有详细点的说明，很重要。</li>
<li><code>reset()</code> : //重置Paint</li>
<li><code>measureText(char[] text, int index, int count)</code>，<code>measureText(String text, int start, int end)</code>，<code>measureText(String text)</code>，<code>measureText(CharSequence text, int start, int end)</code> : //测量字体的长度</li>
<li><code>breakText(char[] text, int index, int count,float maxWidth, float[] measuredWidth)</code>，<code>breakText(CharSequence text, int start, int end,boolean measureForwards,  floatmaxWidth, float[] measuredWidth)</code>，<code>breakText(String text, boolean measureForwards,float maxWidth, float[] measuredWidth)</code> : //剪切显示，就是大于maxWidth的时候只截取指定长度的显示</li>
<li><code>getTextWidths(char[] text, int index, int count,float[] widths)</code>，<code>getTextWidths(CharSequence text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, float[] widths)</code> : //提取指定范围内的字符串，保存到widths中</li>
<li><code>getTextPath(char[] text, int index, int count, float x, float y, Path path)</code>，<code>getTextPath(String text, int start, int end, float x, float y, Path path)</code> : //获取文本绘制的路径，提取到Path中</li>
<li><code>getTextBounds(String text, int start, int end, Rect bounds)</code>，<code>getTextBounds(char[] text, int index, int count, Rect bounds)</code> : //得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870430.html">
                
                  <h1>Android-ColorFilter详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在Android Studio中点击进去看一下源码，可以看到ColorFilter里的代码量很少</p>

<pre class="line-numbers"><code class="language-java">public class ColorFilter {  
    /** 
     * Holds the pointer to the native SkColorFilter instance. 
     * 
     * @hide 
     */  
    public long native_instance;  
  
    @Override  
    protected void finalize() throws Throwable {  
        try {  
            super.finalize();  
        } finally {  
            destroyFilter(native_instance);  
        }  
    }  
  
    static native void destroyFilter(long native_instance);  
}
</code></pre>

<p>由此根据我们的经验，判断ColorFilter可能是个父类，具体实现可能下面还有子类完成的，于是再看Google的文档：</p>

<p><figure><img src="media/15561207870430/15713327420386.png" alt=""/></figure></p>

<p>一目了然了，ColorFilter下有3个子类ColorMatrixColorFilter, LightingColorFilter, PorterDuffColorFilter ，下面逐一学习一下。</p>

<h2 id="toc_1">ColorMatrixColorFilter</h2>

<p><code>ColorMatrixColorFilter</code>翻译为颜色矩阵过滤器，神马是颜色矩阵？实际上， 安卓中管理色彩矩阵是以RGBA像素点的方式加载到内存的，这些点统一使用<code>ColorMatrix</code>的矩阵来统一管理，矩阵定义为4*5的排列形式。那好，首先来看看<code>ColorMatrixColorFilter</code>的两个构造器：</p>

<pre class="line-numbers"><code class="language-java">public ColorMatrixColorFilter(ColorMatrix matrix) {  
        mMatrix.set(matrix);  
        update();  
}  
  
public ColorMatrixColorFilter(float[] array) {  
        if (array.length &lt; 20) {  
            throw new ArrayIndexOutOfBoundsException();  
        }  
        mMatrix.set(array);  
        update();  
}  
</code></pre>

<p>ColorMatrixColorFilter中一个构造器需要接收ColorMatrix对象，另一个需要接收一个4*5的float型数组，我们再打开Android Studio追踪一下mMatrix.set()方法，可以看到以上两个构造器里面调的set方法各自实现的方式</p>

<pre class="line-numbers"><code class="language-java">public void set(ColorMatrix src) {  
        System.arraycopy(src.mArray, 0, mArray, 0, 20);  
}  
  
public void set(float[] src) {  
        System.arraycopy(src, 0, mArray, 0, 20);  
}  
</code></pre>

<p>再追踪一下System.arraycopy()方法：</p>

<pre class="line-numbers"><code class="language-java">public static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length)
</code></pre>

<p>好了，到这里，其实已经很明白了，ColorMatrixColorFilter构造器中接收的两个不同的参数，实际上底层实现方式都是一样的，都是同样调用System.arraycopy()中带float数组参数的方法。所以我们不必再考虑怎么样去写一个ColorMatrix对象传递给ColorMatrixColorFilter了，实际上我们使用第二个构造器，传递一个float数组，会显得程序更加直观易懂，那么我们就尝试写一个ColorMatrixColorFilter，并且设置给Paint吧.</p>

<pre class="line-numbers"><code class="language-java">public class CustomView1 extends View {  
    private Paint mPaint;  
    private Context mContext;  
    public CustomView1(Context context) {  
        this(context, null);  
    }  
  
    public CustomView1(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initPaint();  
    }  
    private void initPaint() {  
        //初始化Paint，并且设置消除锯齿。  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        //设置画笔样式为描边  
        mPaint.setStyle(Paint.Style.FILL);  
        //设置描边的粗细，单位：像素px 注意：当setStrokeWidth(0)的时候描边宽度并不为0而是只占一个像素  
        mPaint.setStrokeWidth(20);  
        //设置画笔颜色为自定义颜色  
        mPaint.setColor(Color.argb(255, 255, 128, 102));  
        ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1, 0, 0, 0, 0,  
                0, 1, 0, 0, 0,  
                0, 0, 1, 0, 0,  
                0, 0, 0, 1, 0  
        });  
        mPaint.setColorFilter(colorFilter);  
    }  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //画一个圆形，取屏幕中心点为圆心  
        canvas.drawCircle(ScreenUtil.getScreenW(mContext) / 2,  
                ScreenUtil.getScreenH(mContext) / 2, 100, mPaint);  
    }  
}
</code></pre>

<p>看上面的例子程序，首先创建了一个ColorMatrixColorFilter对象，并且传递进去一个float型的4*5排列的数组，然后调用Paint的setColorFilter方法将ColorMatrixColorFilter对象传入，我们在模拟器上运行一下，duang~~，我去，什么变化都没有，还是岛国的旗帜。这是怎么回事？下面有必要在学习一下了：</p>

<p>其实一个4*5的float数组中分别对应的是RGBA的向量值，第一行代表的是R(红色)的向量值，第二行代表G(绿色)的向量值，第三行代表B(蓝色)的向量值，第四行代表A(透明度)的向量值，这4行分别代表不同的RGBA的向量值，并且值的取值范围是[0.0F , 2.0F]，当值为1.0F的时候，表示保持原有的色彩，不发生色彩便宜。so，如果我们想要将上面的红色的圈圈颜色变掉，就不能像上面的代码一样，将所有的向量值都设置为1.0F，下面我们修改一个：</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.5F, 0, 0, 0, 0,  
                0, 0.5F, 0, 0, 0,  
                0, 0, 0.5F, 0, 0,  
                0, 0, 0, 1, 0  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p>将上面的ColorMatrixColorFilter中的float数组替换成这样的<br/>
哎哟呵~颜色变深了，看起来神奇很多。那么，这个色彩矩阵以及这个float数组是怎样做到的呢？或者说是怎样通过计算后得到另外一个色彩值的呢？下面作图来说明一下，我们顶一个ColorMatrix的4*5的float型数组，然后定义一个我们自己MyColor，分别代表RGBA的值：</p>

<p><figure><img src="media/15561207870430/15713327557838.jpg" alt=""/></figure></p>

<p>实际上，安卓系统计算色彩值是用矩阵相乘的方式得出的，如上图的样子。这里的MyColor的各项值都要转换到[0,1]之间的值，下面就是我们实际转换的计算方式和结果了。</p>

<p><figure><img src="media/15561207870430/15713327650356.jpg" alt=""/></figure></p>

<p>通过上面的计算，我们得到了最终的RGBA的值是（0.5,0.25,0.2,1），说明RGB色彩值都发生了便宜，只有A未偏移，然后我们将这些值乘以255后还原一下看看，是不是跟上图的圈圈的色彩值是一致的呢，好吧，别看了，肯定必须一定是一样的。那么了解色彩矩阵有什么用呢？上面简单的更换一下色彩值而已，Paint类下也提供了setColor()方法，直接将色彩值设置上去，都TMD的方便，还搞什么玩意的矩阵，显得自己牛逼+蛋疼是不是？解释一下，上面的例子不过是个例子而已啊，真正开发的时候肯定是setColor比较简便嘛。问题来了，我们有可能处理的不是一个纯色彩的东西，而是一直图片呢？一张图片是有几十万中色彩值的，这时候setColor()就不可能让他们变色了吧，还是得用色彩矩阵来搞这玩意。下面我们从drawable目录下加载一张图片吧！</p>

<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>

<p><figure><img src="media/15561207870430/15713327784421.png" alt=""/></figure></p>

<p>好了图片加载完毕，代码没有难度，上面的Paint没有做任何的处理，下面我们为Paint设置色彩过滤器吧！</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0, 0, 0, 1, 0,  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p><figure><img src="media/15561207870430/15713327887731.png" alt=""/></figure></p>

<p>好吧图片变成黑白的了，难道setColor()也可以办吗？再改一个试试：</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                0, 0, 0, 1, 0,  
        });  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p><figure><img src="media/15561207870430/15713328018868.png" alt=""/></figure></p>

<p>这样的效果是不是有点像负片效果啊！好了，反正我也不懂图像学，ColorMatrixColorFilter想设置什么样的就改改矩阵就行了，到底需要什么效果，效果的值要设置成多少，我也不知道，问问美工吧！我们只负责写程序！呵呵~~</p>

<h2 id="toc_2">LightingColorFilter</h2>

<p>LightingColorFilter顾名思义就是“光照色彩过滤器”，就是模拟一个光照照过图像所产生的效果，构造器是这样的：<br/>
<code>public LightingColorFilter(int mul, int add)</code><br/><br/>
查看一下Google文档，是这样介绍滴：</p>

<p>光照色彩滤光片，可以用来模拟简单的照明效果。一个lightingcolorfilter定义了两个参数，一个用于与源颜色相乘（称为colormultiply）和一个用于添加到源颜色（称为coloradd）。alpha通道是原封不动的彩色滤光片。给定一个源颜色的RGB，由此产生的特定颜色计算如下：</p>

<pre class="line-numbers"><code class="language-text">R&#39; = R * colorMultiply.R + colorAdd.R
G&#39; = G * colorMultiply.G + colorAdd.G
B&#39; = B * colorMultiply.B + colorAdd.B
</code></pre>

<p>每个通道值的结果范围是0~255。上面的介绍写的比较明白， 算法也很简单，我们以上面的原图为例，看见蓝天了吗，我们现在去掉这个蓝色的天。根据这个短发描述呢，我们仅仅去掉蓝色，就要将蓝色的通道值改变，将B计算为其它值，这时候colorMultiply.B = 00，colorAdd.B =00，计算得到的B = 00，其它的通道R和G均不变，那么,colorAdd.R=0，colorAdd.G =0；colorMultiply.R = FF，colorMultiply.G =FF，Alpha通道A是忽略的，所以随便设置什么都不会有变化的。</p>

<pre class="line-numbers"><code class="language-java">LightingColorFilter colorFilter = new LightingColorFilter(0xFFFFFF00, 0x00000000);  
mPaint.setColorFilter(colorFilter);
</code></pre>

<p>运行之后的结果，蓝天没了。</p>

<p><figure><img src="media/15561207870430/15713328128205.png" alt=""/></figure></p>

<h2 id="toc_3">PorterDuffColorFilter</h2>

<p>ColorFilter下还有最后一个子类，PorterDuff混合模式的色彩过滤器，下面是其构造器：<br/>
<code>public PorterDuffColorFilter(int color, PorterDuff.Mode mode)</code></p>

<p>Google文档：PorterDuff滤光器可以用于点源像素使用一个单一的颜色和一个特定的波特达夫复合模式。</p>

<p>PorterDuffColorFilter的构造器也很简单，其中第一个参数表示一个16进制的色彩值，第二个参数是一个枚举值PorterDuff.Mode，表示图片混排的模式，PorterDuff.Mode在Android下一共有16种。下面我们先写一个小例子看一下，这里我们还是使用上面的图片，为原图添加图片混排模式，颜色值设置为红色0XFFFF0000，混排模式设置为PorterDuff.Mode.DARKEN。</p>

<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(0XFFFF0000, PorterDuff.Mode.DARKEN);  
        mPaint.setColorFilter(colorFilter);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>

<p>上面的图片就是运行之后的效果了，原图不仅变红了，而且还变暗了。其实我们这里将PorterDuffColorFilter的构造器参数拆开来分析一下，首先我们传递进去一个红色的颜色值0XFFFF0000，这里相当于创建了一张新的图层，图层的颜色就是0XFFFF0000，而我们的原图可以看作是第二张图层，我们先把这2个图片重叠放在一起，就会发现得到一个原图上很红的图片，然后我们看一下PorterDuff.Mode是DARKEN模式，表示在之前得到的“原图+很红”的图片上进一步将色调调成暗色，最终得到了如上所示的图片。</p>

<p>关于PorterDuff.Mode，Android系统一共提供了18种混排模式，在模拟器的ApiDemos/Graphics/XferModes，有张效果图：</p>

<p><figure><img src="media/15561207870430/15713328265702.png" alt=""/></figure></p>

<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式算法，其中比上图多了ADD和OVERLAY两种模式：</p>

<p><figure><img src="media/15561207870430/15713328371456.png" alt=""/></figure></p>

<p>其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面是在网上找到的汉字语言描述，感谢这位作者的总结。</p>

<p>注意：先绘制dst，再绘制src。</p>

<ul>
<li><strong>1.PorterDuff.Mode.CLEAR</strong>    所绘制源图像不会提交到画布上。</li>
<li><strong>2.PorterDuff.Mode.SRC</strong>    只显示源图像。</li>
<li><strong>3.PorterDuff.Mode.DST</strong>    只显示目标图像。</li>
<li><strong>4.PorterDuff.Mode.SRC_OVER</strong>    正常绘制显示，源图像居上显示。</li>
<li><strong>5.PorterDuff.Mode.DST_OVER</strong>    上下层都显示。目标图像居上显示。</li>
<li><strong>6.PorterDuff.Mode.SRC_IN</strong>    取两层绘制交集中的源图像。</li>
<li><strong>7.PorterDuff.Mode.DST_IN</strong>     取两层绘制交集中的目标图像。</li>
<li><strong>8.PorterDuff.Mode.SRC_OUT</strong>    只在源图像和目标图像不相交的地方绘制源图像。</li>
<li><strong>9.PorterDuff.Mode.DST_OUT</strong>    只在源图像和目标图像不相交的地方绘制目标图像。</li>
<li><strong>10.PorterDuff.Mode.SRC_ATOP</strong>    在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。</li>
<li><strong>11.PorterDuff.Mode.DST_ATOP</strong>   在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。</li>
<li><strong>12.PorterDuff.Mode.XOR</strong>    异或：去除两图层交集部分</li>
<li><strong>13.PorterDuff.Mode.DARKEN</strong>     取两图层全部区域，交集部分颜色加深</li>
<li><strong>14.PorterDuff.Mode.LIGHTEN</strong>   取两图层全部，点亮交集部分颜色</li>
<li><strong>15.PorterDuff.Mode.MULTIPLY</strong>    取两图层交集部分叠加后颜色</li>
<li><strong>16.PorterDuff.Mode.SCREEN</strong>    滤色。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870386.html">
                
                  <h1>Android-DataBinding详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>谷歌开发了一个非常厉害的新框架DataBinding， 数据绑定框架给我们带来了很大的方便，以前我们可能需要在每个Activity里写很多的findViewById，不仅麻烦，还增加了代码的耦合性，如果我们使用DataBinding，就可以抛弃那么多的findViewById，省时省力。说到这里，其实网上也有很多快速的注解框架，但是注解框架与DataBinding想比还是不好用，而且官网文档说DataBinding还能提高解析XML的速度，其实DataBinding的好用，不仅仅体现在可以省去使用很多啰嗦findViewById，还有很多。往下看你就会明白的。</p>

<p>在介绍DataBinding之前，肯定要先学会搭建使用它的环境。在Android Studio上Databinding的使用还是很简单的。</p>

<h2 id="toc_1">环境搭建</h2>

<p>Android 的 Gradle 插件版本不低于 1.5.0-alpha1：classpath &#39;com.android.tools.build:gradle:1.5.0&#39;然后修改对应模块（Module）的 build.grade：</p>

<pre class="line-numbers"><code class="language-java">android {
    ....
    dataBinding {
        enabled = true
    }
}
</code></pre>

<p>注意：Android stuido 的版本一定要大于1.3，而且Android Studio目前对binding对象没有自动代码提示，只会在编译时进行检查。<br/>
就是这么简单，但是1.3及以前的版本，对于环境的搭建，可能就会麻烦一点（没事1.3的环境搭建方法，网上多得是）。</p>

<h2 id="toc_2">基础展示</h2>

<p>我们在具体的讲解之前，先用一个简单的小例子来学习一下基础并展现一下DataBinding的巨大魅力，估计你会被其简单的特性所吸引哦。<br/><br/>
首先我们先建立一个java bean，就是一个非常简单的用户类吧。</p>

<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding.bean;
/**
 * Created by loongggdroid on 2016/3/14.
 */
public class User {
    private String name;
    private String age;
    public User(String name, String age) {
        this.name = name;
        this.age = age;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(String age) {
        this.age = age;
    }
    public String getName() {
        return this.name;
    }
    public String getAge() {
        return this.age;
    }
}
</code></pre>

<p>其次，来看看使用了DataBinding之后的布局文件是什么样子的呢？主要的变化是在layout布局文件之中。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.name}&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.age}&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p>看到这里，可能有的人就开始有点迷糊了，没有给控件定义id，而是用了@{ }的方法，到底是怎么回事？先不忙，一会再给你解释，我们再来看看怎么把值传进去的，在Activity中是如何使用的。</p>

<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding;

import android.app.Activity;
import android.databinding.DataBindingUtil;
import android.os.Bundle;

import loonggg.net.databinding.bean.User;
import loonggg.net.databinding.databinding.ActivityMainBinding;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
        User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
        binding.setUser(user);
    }

}
</code></pre>

<p>看到Activity是不是感觉很简洁，很清爽，没有了控件的初始化findViewById，然后再去setText(), 就仅仅只添加了两行代码。运行结果，不用说，显而易见，肯定会显示loonggg和23。</p>

<h2 id="toc_3">基础用法</h2>

<h3 id="toc_4">布局生命</h3>

<p>例子我们介绍完了，对于例子中出现的一些新东西，有必要解释一下，java bean那里就不解释了，大家肯定都懂，我们就从布局文件讲起。相比以前使用的xml，根节点由具体的某个layout（比如LinearLayout ）变成了layout，里面包括了data节点和传统的视图。这里的data节点就像是连接 View 和 Modle 的桥梁。在这个data节点中声明一个variable变量，那值就可以轻松传到布局文件中来了。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;!--type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user--&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt; 
    &lt;LinearLayout&gt;
     ……
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p>变量名为user变量类型为&quot;loonggg.net.databinding.bean.User &quot;</p>

<p>type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user，TextView中的@{user.name}就是把这个user中的名字展示出来，age同样如此。</p>

<h3 id="toc_5">绑定Variable</h3>

<p>虽然在布局文件中对应上了，但是值是怎么传进去的呢？这就是我们要将的Activity中的那两行代码了，它把实体类和布局文件进行了绑定。修改MainActivity中的onCreate，用 DatabindingUtil.setContentView() 来替换掉 setContentView()，然后创建一个 user 对象，通过 binding.setUser(user) 与 variable 进行绑定。</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
    binding.setUser(user);
}
</code></pre>

<p>ActivityLayoutDetailBinding这个类是自动生成的和你的布局文件名字一样，如果你想要去改变名字的话</p>

<pre class="line-numbers"><code class="language-markup">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;  
  
    &lt;!--这里你也可以为Binding类进行命名，有三种形式  
        1、Custom:会在databinding包下  
        2、.Custom:会在当前的包名下创建  
        3、com.andly.Custom:会在指定的包名下进行创建--&gt;  
    &lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt; //在app_package/databinding下生成CustomBinding；
    &lt;data class=&quot;.CustomBinding&quot;&gt;&lt;/data&gt; //在app_package下生成CustomBinding；
    &lt;data class=&quot;com.example.CustomBinding&quot;&gt;&lt;/data&gt; // 明确指定包名和类名。
</code></pre>

<h2 id="toc_6">高级用法</h2>

<h3 id="toc_7">import用法</h3>

<p>其实data节点也是支持import用法的，比如：</p>

<pre class="line-numbers"><code class="language-java">&lt;data&gt;
     &lt;import type=&quot;loonggg.net.databinding.bean.User &quot;/&gt;
     &lt;variablename=&quot;user&quot;type=&quot;User&quot; /&gt;
&lt;/data&gt;
</code></pre>

<p>这里需要注意的是：<code>import</code>并不能像java 一样可以 <code>import xx.xxx.*</code>，必须具体到写清楚每个要导入的类名。</p>

<h3 id="toc_8">类名相同</h3>

<p>到这里你可能会问如果import了两个相同名称的类咋办？别怕，人家想的很周到，可以起个别名或者昵称嘛！例如：</p>

<pre class="line-numbers"><code class="language-java">···
&lt;data&gt; 
  &lt;import type=&quot;xxx.User&quot; alias=&quot;MyUser&quot;&gt; 
  &lt;import type=&quot;xxx.xx.User&quot;&gt; 

   &lt;variable 
            name=&quot;user&quot; 
            type=&quot;User&quot; /&gt; 
    &lt;variable 
            name=&quot;myUser&quot; 
            type=&quot;MyUser&quot;/&gt; 
&lt;/data&gt; 
&lt;TextView xxx:@{myUser.getName()}&gt; 
&lt;TextView xxx:@{user.getName()}&gt;
···
</code></pre>

<h3 id="toc_9">变量定义的高级用法</h3>

<p>在上面，我们学会了如何去在xml中定义一些简单的变量。我们没有定义像List、Map等这样的集合变量。那这种集合变量该如何定义呢？其实定义的方式和我们上面的基本一致，区别就在于我们还需要为它定义key的变量，例如：</p>

<pre class="line-numbers"><code class="language-markup">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; 
    &lt;data&gt; 
        &lt;import type=&quot;android.graphics.Bitmap&quot; /&gt; 
        &lt;import type=&quot;java.util.ArrayList&quot; /&gt; 
        &lt;import type=&quot;java.util.HashMap&quot; /&gt;  
        &lt;!-- 集合的定义 --&gt;
        &lt;variable 
            name=&quot;list&quot; 
            type=&quot;ArrayList&amp;lt;String&gt;&quot; /&gt; // 左尖括号需要转义
        &lt;variable 
            name=&quot;map&quot; 
            type=&quot;HashMap&amp;lt;String, String&gt;&quot; /&gt; 
        &lt;variable 
            name=&quot;array&quot; 
            type=&quot;String[]&quot; /&gt; 
        &lt;!-- 为集合定义对应的索引 --&gt;
        &lt;variable 
            name=&quot;listKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;variable 
            name=&quot;mapKey&quot; 
            type=&quot;String&quot; /&gt; 
        &lt;variable 
            name=&quot;arrayKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;!-- 字符串，布尔值和int的用法--&gt;
        &lt;variable 
            name=&quot;str&quot; 
            type=&quot;String&quot;/&gt; 
        &lt;variable 
            name=&quot;error&quot; 
            type=&quot;boolean&quot;/&gt; 
        &lt;variable 
            name=&quot;num&quot; 
            type=&quot;int&quot; /&gt; 
    &lt;/data&gt; 
    &lt;LinearLayout 
        android:orientation=&quot;vertical&quot; 
        android:layout_width=&quot;match_parent&quot; 
        android:layout_height=&quot;wrap_content&quot;&gt; 

        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{list[listKey]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{map[`name`]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{array[0]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{str}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{String.valueOf(num)}&quot;/&gt; 
    &lt;/LinearLayout&gt; 
&lt;/layout&gt;
</code></pre>

<p>在引用的同时也可以加上简单的逻辑运算</p>

<pre class="line-numbers"><code class="language-markup">&lt;!--数据绑定将自动检测null异常，如果你的表达式为null，它将会给它赋值为(null)  
 如果为int类型则默认为0--&gt;  
 &lt;!--之前都是写三元运算符的形式，当然在数据绑定中也能够使用，但更推荐下面那种--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{boo?note:null}&quot; /&gt;  
 &lt;!--?? :null合并运算符，当左边为null会显示右边--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{note??null}&quot;  
     android:textColor=&quot;#00FF00&quot;  
     android:textSize=&quot;18sp&quot; /&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;!--引用资源文件--&gt;  
&lt;ImageView  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:paddingLeft=&quot;@{boo?@dimen/large_padding:@dimen/small_padding}&quot;  
    android:src=&quot;@{image}&quot; /&gt; 
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;TextView  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&#39;@{String.valueOf(map[`one`])}&#39;/&gt;  
</code></pre>

<h3 id="toc_10">Observable数据改变自动更新</h3>

<p><code>Observable</code>是一个接口，它的子类有<code>BaseObservable</code>,<code>ObservableField</code>,<code>ObservableBoolean</code>,<code>ObservableByte</code>, <code>ObservableChar</code>, <code>ObservableShort</code>, <code>ObservableInt</code>, <code>ObservableLong</code>, <code>ObservableFloat</code>, <code>ObservableDouble</code>, and <code>ObservableParcelable</code>，<code>ObservableArrayList</code>,<code>ObservableArrayMap</code><br/>
现在我们来看看 如何在数据改变时，不手动设置，让其自动改变：</p>

<p><strong>布局文件</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Person&quot; /&gt;
        &lt;variable
            name=&quot;person&quot;
            type=&quot;Person&quot; /&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`firstName:`+person.firstName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`lastName:`+person.lastName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`age:`+person.age}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/second_btn1&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;改变数据&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>Person类</strong></p>

<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding.model;

import android.databinding.BaseObservable;
import android.databinding.Bindable;

import www.zhang.com.databinding.BR;

public class Person extends BaseObservable {
    private String firstName;
    private String lastName;
    private int age;
    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    @Bindable
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
        notifyPropertyChanged(BR.firstName);
    }
    @Bindable
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
        notifyPropertyChanged(BR.lastName);
    }
    @Bindable
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
        notifyPropertyChanged(BR.age);
    }
}
</code></pre>

<p>Model类继承BaseObservable,BaseObservable实现 Android.databinding.Observable接口，Observable接口可以允许附加一个监听器到model对象以便监听对象上的所有属性的变化。<br/><br/>
Observable接口有一个机制来添加和删除监听器，但通知与否由开发人员管理。为了使开发更容易，BaseObservable实现了监听器注册机制。DataBinding实现类依然负责通知当属性改变时。这是通过指定一个Bindable注解给getter以及setter内通知来完成的。<br/><br/>
notifyPropertyChanged(BR.参数名)通知更新这一个参数，需要与@Bindable注解配合使用。notifyChange()通知更新所有参数，可以不用和@Bindable注解配合使用</p>

<p><strong>SecondActivity</strong></p>

<pre class="line-numbers"><code class="language-java">public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivitySecondBinding binding = DataBindingUtil.setContentView(SecondActivity.this, R.layout.activity_second);

        final Person person = new Person(&quot;zhang&quot;,&quot;san&quot;,38);
        binding.setPerson(person);

        binding.secondBtn1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                person.setFirstName(&quot;li&quot;);
                person.setLastName(&quot;si&quot;);
                person.setAge(40);
            }
        });
    }
}
</code></pre>

<h4 id="toc_11">示例</h4>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Animal&quot;/&gt;
        &lt;variable
            name=&quot;animal&quot;
            type=&quot;Animal&quot;/&gt;
        &lt;variable
            name=&quot;list&quot;
            type=&quot;android.databinding.ObservableArrayList&amp;lt;String&amp;gt;&quot;/&gt;
        &lt;variable
            name=&quot;map&quot;
            type=&quot;android.databinding.ObservableArrayMap&amp;lt;String,String&amp;gt;&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{animal.field}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{String.valueOf(animal.age)}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[0]}&quot; /&gt;
        &lt;!--Map集合既可以通过map[key]的方式，也可以通过调用API--&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[1]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`name`]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`age`]}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/four_btn&quot;
            android:layout_width=&quot;match_parent&quot;
            android:text=&quot;改变数据&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>Animal类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Animal {
    public final ObservableField&lt;String&gt; field = new ObservableField&lt;&gt;();
    public final ObservableInt age = new ObservableInt();
}
</code></pre>

<p><strong>FourActivity</strong></p>

<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding;

public class FourActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityFourBinding binding = DataBindingUtil.setContentView(FourActivity.this, R.layout.activity_four);
        final Animal animal = new Animal();

        animal.field.set(&quot;cat&quot;);
        animal.age.set(2);
        binding.setAnimal(animal);

        final ObservableArrayList&lt;String&gt; list = new ObservableArrayList&lt;&gt;();
        list.add(&quot;dog&quot;);
        list.add(&quot;mouse&quot;);
        binding.setList(list);

        final ObservableArrayMap&lt;String, String&gt; map = new ObservableArrayMap&lt;&gt;();
        map.put(&quot;name&quot;,&quot;Tom&quot;);
        map.put(&quot;age&quot;,&quot;4&quot;);
        binding.setMap(map);

        binding.fourBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                animal.field.set(&quot;dog&quot;);
                animal.age.set(4);
                list.set(0,&quot;cat&quot;);
                list.set(1,&quot;dog&quot;);
                map.put(&quot;name&quot;,&quot;Sam&quot;);
                map.put(&quot;age&quot;,&quot;5&quot;);
            }
        });

    }
}
</code></pre>

<p>当Animal属性数据改变，list/map集合数据改变，会自动更新数据，我们不需要自己手动设置，省去了一个操作，让我们更专注于业务逻辑。</p>

<h3 id="toc_12">事件的绑定</h3>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
    绑定事件的格式有两种：    
    1、方法引用：直接用handle.Click或者handle::Click  推荐后者  
--&gt;  
&lt;Button  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&quot;@{user.name}&quot;  
    android:onClick=&quot;@{handle::Click}&quot;/&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
     2、监听绑定：使用()组，括号里面所填的是你为参数起的名字，这样你就可以在后面的括号进行引用  
        如果你监听的事件需要返回值，那么你的方法也要返回一个相同类型  
 --&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{()-&gt;handle.eventHandler(user)}&quot;  
     android:text=&quot;传入布局文件中的数据&quot; /&gt;  
  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(thisView)-&gt;handle.eventHandlerView(thisView,user)}&quot;  
     android:text=&quot;传入此View&quot; /&gt;  
 &lt;!--如果你需要为一个点击事件设置一个断言，那么使用void作为一个标志,表示什么也不做--&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.isVisible(v)?handle.doSomething():void}&quot;  
     android:text=&quot;判断是否为visible&quot; /&gt;  
  
 &lt;!--对于一些控件有自己专门的单击事件，需要创建下面的属性进行避免  
    SearchView    android:onSearchClick  
    ZoomControls  android:onZoomIn  
    ZoomControls  android:onZoomOut--&gt;  
 &lt;SearchView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.searchClick(v)}&quot;  
     android:onSearchClick=&quot;@{(v)-&gt;handle.onSearchClick(v)}&quot;&gt;  
  
 &lt;/SearchView&gt;  
</code></pre>

<p>实现监听方法，保证参数个数、类型、返回值都要保证和你使用set时监听一样，不然就出报错。</p>

<pre class="line-numbers"><code class="language-java">public void checkChanged(View view, boolean isCheck) {  
    System.out.println(&quot;checkChanged:&quot; + view + &quot;    &quot; + isCheck);  
}  
  
public boolean longClick(View view) {  
    System.out.println(&quot;longClick:&quot; + view);  
    return true;  
}  
</code></pre>

<p>可以直接在 xml 导入android.view.View.OnClickListener，并制定其点击事件。</p>

<pre class="line-numbers"><code class="language-java">&lt;variable
    name=&quot;clickListener&quot;
    type=&quot;android.view.View.OnClickListener&quot; /&gt;
...
  android:onClick=&quot;@{clickListener}&quot;
...
</code></pre>

<pre class="line-numbers"><code class="language-java">holder.binding.setClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               //do something
        });
</code></pre>

<h3 id="toc_13">表达式</h3>

<p>其实在xml文件中还是支持表达式的，比如说如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&#39;@{error ? &quot;error&quot; : &quot;ok&quot;}&#39;/&gt;
</code></pre>

<p>这是一个布尔值的使用。</p>

<p><strong>下面我们就来看看表达式支持的一下语法和不支持的语法支持的表达式：</strong></p>

<ul>
<li>Mathematical + - / * %<br/></li>
<li>String concatenation +<br/></li>
<li>Logical &amp;&amp; ||<br/></li>
<li>Binary &amp; | ^<br/></li>
<li>Unary + - ! ~<br/></li>
<li>Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt;<br/></li>
<li>Comparison == &gt; &lt; &gt;= &lt;=<br/></li>
<li>instanceof<br/></li>
<li>Grouping ()<br/></li>
<li>Literals - character, String, numeric, null<br/></li>
<li>Cast<br/></li>
<li>Method calls</li>
<li>Field access</li>
<li>Array access []</li>
<li>Ternary operator ?:</li>
</ul>

<p><strong>不支持的表达式：</strong></p>

<ul>
<li>this</li>
<li>super</li>
<li>new</li>
<li>Explicit generic invocation</li>
</ul>

<h3 id="toc_14">在布局中使用include</h3>

<p>如果你需要用到从xml传过来的数据需要去使用bind:user属性，这里的user是你定义的实体类名</p>

<pre class="line-numbers"><code class="language-markup">&lt;!--当你使用include的时候，你可以使用命名空间和属性中的变量名  
来将数据传送到另一个布局中去,值得注意的是当include的父节点为merge时将不支持--&gt;  
&lt;include  
    layout=&quot;@layout/detail_include&quot;  
    bind:user=&quot;@{user}&quot; /&gt; 
</code></pre>

<p>然后只需要在include布局里面声明之后便可以直接使用了。</p>

<h4 id="toc_15">示例</h4>

<p><strong>activity_five.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
 &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;TextView
                android:text=&quot;@string/app_name&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>toolbar.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout &gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
      &lt;variable
          name=&quot;content&quot;
          type=&quot;Content&quot;/&gt;
    &lt;/data&gt;

&lt;android.support.v7.widget.Toolbar
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/toolbar&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_height=&quot;56dp&quot;
    android:layout_width=&quot;match_parent&quot;
    app:title=&quot;@{content.title}&quot;
    app:subtitle=&quot;@{content.subTitle}&quot;
    android:background=&quot;@color/colorPrimary&quot;
    app:titleTextColor=&quot;@android:color/white&quot;
    app:subtitleTextColor=&quot;@android:color/white&quot; /&gt;
&lt;/layout&gt;
</code></pre>

<p>在activity_five.xml中的include属性中定义了一个id,同时又在toolbar.xml中的Toolbar标签中又定义了一个id,其作用是通过binding.toolbar.toolbar等同于Toolbar控件，可以方便做一些操作等(不加id，同样能将变量参数传进去)<br/>
FiveActivity中</p>

<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        ActivityFiveBinding binding =DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;); 
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>

<p><strong>Content</strong></p>

<pre class="line-numbers"><code class="language-java">public class Content extends BaseObservable {
    private String title;
    private String subTitle;

    public Content(String title, String subTitle) {
        this.title = title;
        this.subTitle = subTitle;
    }

    @Bindable public String getSubTitle() {
        return subTitle;
    }

    public void setSubTitle(String subTitle) {
        this.subTitle = subTitle;
        notifyPropertyChanged(BR.subTitle);
    }

    @Bindable public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
        notifyPropertyChanged(BR.title);
    }
}
</code></pre>

<h3 id="toc_16">带id的控件的赋值方式</h3>

<p>对于xml文件中控件的赋值，其实也是可以在java文件中，用java来实现的。我就以最上面那个简单的小例子来说，假如给一个TextView设置的id如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:id=&quot;@+id/name&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    /&gt;
</code></pre>

<p>在Activity中这样赋值：</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    binding.name.setText(&quot;非著名程序员&quot;);
}
</code></pre>

<h3 id="toc_17">在布局中使用ViewStub</h3>

<pre class="line-numbers"><code class="language-java">/** 
 * 为ViewStub设置监听，当显示的时候为它绑定数据，因为当不显示的ViewStub会在视图中消失 
 */  
vs = (ViewStub) findViewById(R.id.viewstub);  
vs.setOnInflateListener(new ViewStub.OnInflateListener() {  
    @Override  
    public void onInflate(ViewStub stub, View inflated) {  
        ViewstubBinding viewstubBinding = ViewstubBinding.bind(inflated);  
        Info info = new Info();  
        info.setInfo(&quot;Andly Info&quot;);  
        viewstubBinding.setInfo(info);  
        Drawable d = getResources().getDrawable(R.mipmap.ic_launcher);  
        viewstubBinding.setDrawable(d);  
    }  
});  
  
public void toggleViewStub(View view) {  
    vs.inflate();  
}  
</code></pre>

<h3 id="toc_18">在布局中使用RecycleView控件</h3>

<h4 id="toc_19">1、添加RecycleView控件</h4>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
    这里使用到了自定义属性，因为RecycleView里面有setAdapter方法，所以这里可以直接用app:adapter  
--&gt;  
&lt;android.support.v7.widget.RecyclerView  
    android:id=&quot;@+id/rv&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    app:adapter=&quot;@{adapter}&quot; /&gt;  
</code></pre>

<h4 id="toc_20">2、为RecycleView定义适配器</h4>

<pre class="line-numbers"><code class="language-java">@Override  
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  
    ViewDataBinding viewDataBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), layoutId, parent, false);  
    return new ViewHolder(viewDataBinding);  
}  
@Override  
public void onBindViewHolder(ViewHolder holder, int position) {  
    holder.binding.setVariable(variable, list.get(position));  
    holder.binding.executePendingBindings();  
    //当然这里你也可以为其设置点击如：  
    //holder.binding.getRoot.setOnclickListener()  
}  
@Override  
public int getItemCount() {  
    return list.size();  
}  
  
class ViewHolder extends RecyclerView.ViewHolder {  
    ViewDataBinding binding;  
  
    public ViewHolder(ViewDataBinding binding) {  
        super(binding.getRoot());  
        this.binding = binding;  
    }  
}  
</code></pre>

<h4 id="toc_21">3、为RecycleView设置Adapter</h4>

<pre class="line-numbers"><code class="language-java">//这里注意的是一定要是BR.dataInfo不能是其它的常数  
MyAdapter adapter = new MyAdapter(list, R.layout.rv_item, BR.dataInfo);  
binding.setAdapter(adapter);  
binding.rv.setLayoutManager(new LinearLayoutManager(this));
</code></pre>

<p>这样就大功告成，然而在很多情况我们都需要去对每个Item进行处理，如显示网络图片等等，这里我们就需要使用数据绑定自定义属性的功能，看代码</p>

<pre class="line-numbers"><code class="language-markup">&lt;ImageView  
    android:layout_width=&quot;150dp&quot;  
    android:layout_height=&quot;90dp&quot;  
    app:imageError=&quot;@{@drawable/android}&quot;  
    app:imagePath=&quot;@{dataInfo.imageUrl}&quot; /&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-java">//当你在一个方法只需要一个参数的时候可以使用@BindingAdapter(&quot;imageUrlStr&quot;)，加上之后就可以在布局文件中直接使用imageUrlStr  
//运行之后就会调用loadImage方法  
@BindingAdapter(&quot;imageUrlStr&quot;)  
public static void loadImage(ImageView iv, String url) {  
    Glide.with(iv.getContext()).load(url).into(iv);//这里使用Glide库  
}  
  
//上面是为loadImage传入一个参数，当传入两个或多个参数的时候应使用@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
//这个的ImageView自定义了两个属性一个是imagePath传入的是url,一个是imageError为Drawable  
@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
public static void downloadImage(ImageView iv, String url, Drawable error) {  
    Glide.with(iv.getContext()).load(url).error(error).into(iv);  
}  
</code></pre>

<p>上面的方法使用的是静态方法，如果你不想使用静态方法你需要重写一个数据绑定组件类去实现DataBindingComponent</p>

<pre class="line-numbers"><code class="language-java">public class MyComponent implements android.databinding.DataBindingComponent {  
    private Utils utils;  
    @Override  
    public Utils getUtils() {  
        if (utils == null) {  
            utils = new Utils();  
        }  
        return utils;  
    }  
}  
</code></pre>

<p>然后你需要在Activity为其进行设置</p>

<pre class="line-numbers"><code class="language-java">//第一种方式  
DataBindingUtil.setDefaultComponent(new MyComponent());  
//第二种方式  
ActivityMyListViewBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_my_list_view,new MyComponent());  
//第三种方式  
DataBindingUtil.bind(root,new MyComponent());  
</code></pre>

<p>最后有个不起眼的小功能，就是当使用数据绑定的时候在预览界面不能看到显示的内容，这时你可以为你的控件设置默认显示内容<code>android:text=&quot;@{placeName,default=PLACEHOLDER}&quot;</code></p>

<h5 id="toc_22">示例</h5>

<p><strong>activity_five.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
        &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;android.support.v7.widget.RecyclerView
                android:id=&quot;@+id/recycler&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>recycler_item.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;str&quot;
            type=&quot;String&quot;/&gt;
    &lt;/data&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:text=&quot;@{str}&quot;
            android:gravity=&quot;center_vertical&quot;
            android:textColor=&quot;@android:color/black&quot;
            android:textSize=&quot;16sp&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;48dp&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>FiveActivity</strong></p>

<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {

    private ActivityFiveBinding binding;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        binding = DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        initToolbar();
        initRecyclerView();
    }

    private void initRecyclerView() {
        LinearLayoutManager manager = new LinearLayoutManager(FiveActivity.this);
        binding.recycler.setLayoutManager(manager);
        binding.recycler.setHasFixedSize(true);
        MyAdapter adapter = new MyAdapter(getApplicationContext());
        binding.recycler.setAdapter(adapter);
    }

    private void initToolbar() {
        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;);
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>

<p><strong>MyAdapter</strong></p>

<pre class="line-numbers"><code class="language-java">public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {

    private Context mContext;
    String[] datas;

    public MyAdapter(Context context) {
        mContext = context;
        datas = context.getResources().getStringArray(R.array.item_list);
    }

    @Override
    public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        RecyclerItemBinding binding = DataBindingUtil.inflate(LayoutInflater.from(mContext), R.layout.recycler_item, parent, false);
        return new MyViewHolder(binding);
    }

    @Override
    public void onBindViewHolder(MyAdapter.MyViewHolder holder, int position) {
        String name = datas[position];
        holder.getBinding().setVariable(www.zhang.com.databinding.BR.str,name);
        //holder.getBinding().setStr(name); //两者都可以

        //executePendingBindings()方法说明
        // When a variable or observable changes, the binding will be scheduled to change before the next frame. 
        // There are times, however, when binding must be executed immediately. 
        // To force execution, use the executePendingBindings() method.
        holder.getBinding().executePendingBindings();//此方法必须执行在UI线程，当绑定的数据修改时更新视图（不知道翻译的准不准）
    }

    @Override
    public int getItemCount() {
        return datas.length;
    }

    public class MyViewHolder extends RecyclerView.ViewHolder {
        private RecyclerItemBinding binding;

        public MyViewHolder(ViewDataBinding binding) {
            super(binding.getRoot());
            this.binding = (RecyclerItemBinding) binding;
        }

        public RecyclerItemBinding getBinding() {
            return binding;
        }

        public void setBinding(RecyclerItemBinding binding) {
            this.binding = binding;
        }
    }
}
</code></pre>

<h3 id="toc_23">@BindingAdapter</h3>

<p>@BindingAdapter用于修饰方法。<br/><br/>
一些属性需要定制绑定逻辑，一个用@BindingAdapter修饰的静态方法可以自定义属性的setter操作。<br/><br/>
android自身实现了大量的Adapter，你可以在项目module的android.databinding.adapters包下找到这些代码。</p>

<pre class="line-numbers"><code class="language-java">public class CardViewBindingAdapter {
    @BindingAdapter(&quot;contentPadding&quot;)
    public static void setContentPadding(CardView view, int padding) {
        view.setContentPadding(padding, padding, padding, padding);
    }
}
</code></pre>

<p><strong>方法内的参数可以设置多个，参数的传递在布局文件中使用自定义命名空间的属性传入。</strong></p>

<ul>
<li>1、默认的你的自定义的命名空间，在匹配时会被忽略。</li>
</ul>

<pre class="line-numbers"><code class="language-text">@BindingAdapter(&quot;contentPadding&quot;)
</code></pre>

<ul>
<li>2、允许重写android的命名空间。</li>
</ul>

<pre class="line-numbers"><code class="language-text"> @BindingAdapter(&quot;android:contentPadding&quot;)
</code></pre>

<p><code>app:contentPadding</code>与<code>android:contentPadding</code>处理行为可以不一样。<br/>
<code>app:contentPadding</code>与<code>custom:contentPadding</code>处理行为是一致的。（仅android是特殊的命名空间）。</p>

<h4 id="toc_24">示例</h4>

<pre class="line-numbers"><code class="language-java">@BindingAdapter({&quot;imageUrl&quot;, &quot;type&quot;, &quot;position&quot;, &quot;debrisfly&quot;, &quot;width&quot;, &quot;height&quot;})
public static void setImageUrl(SimpleDraweeView view, String url, int type, int position, boolean debrisfly, int width, int height) {
    if (url == null) {
        url = &quot;&quot;;
    }
    Uri uri = null;
    switch (type) {
        case 1:
            uri = Util.parse7(url, BocaiApplication.getInstance());
            break;
        case 2:
            uri = Util.parse2(url, BocaiApplication.getInstance());
            break;
        case 3:
            uri = Util.parse3(url, BocaiApplication.getInstance());
            break;

        case 8:
            uri = Util.parse(url, BocaiApplication.getInstance());
            break;
        case 10:
            uri = Util.parseUrlBy230(url, BocaiApplication.getInstance());
            break;
    }
    ControllerListener controllerListener = new BaseControllerListener&lt;ImageInfo&gt;() {
        @Override
        public void onFinalImageSet(
                String id,
                @Nullable ImageInfo imageInfo,
                @Nullable Animatable anim) {
            if (imageInfo == null) {
                return;
            }
            if (anim != null) {
                anim.start();
            }
        }

        @Override
        public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {
        }

        @Override
        public void onFailure(String id, Throwable throwable) {
        }
    };

    DraweeController controller = Fresco.newDraweeControllerBuilder()
            .setControllerListener(controllerListener)
            .setUri(uri)
            .setOldController(view.getController())
            // other setters
            .build();
    view.setController(controller);
    debrisflys(debrisfly, position,view,width,height);
}
</code></pre>

<p>需要注意，当你创建的适配器属性与系统默认的产生冲突时，你的自定义适配器将会覆盖掉系统原先定义的注解，这将会产生一些意外的问题。<br/>
假设需要对下面接口，做适配。</p>

<pre class="line-numbers"><code class="language-java">public interface ILogAction{
      void login();
      void logout();
}
</code></pre>

<p>则需要一个方法一个接口，这么做的原因是避免<code>login()</code>的修改影响到<code>logout()</code>。所以根据业务需要，可能需要排列组合适配这两个接口。</p>

<blockquote>
<p>1、适配 login<br/>
2、适配 logout<br/>
3、适配 login + logout</p>
</blockquote>

<h3 id="toc_25">@BindingBuildInfo</h3>

<pre class="line-numbers"><code class="language-java">@BindingBuildInfo(
buildId=&quot;3fefc6ba-1e95-4dcf-8ffa-278fe0f449bd&quot;,
modulePackage=&quot;com.ipudong.library&quot;,
sdkRoot=&quot;/Users/robert/Library/Android/sdk&quot;,
layoutInfoDir=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug&quot;,
exportClassListTo=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug/_generated.txt&quot;,
isLibrary=true,
minSdk=14,
enableDebugLogs=false,
printEncodedError=true
)
public class DataBindingInfo {}
</code></pre>

<p>在SOURCE阶段会自动生成DataBindingInfo.class，并标记注解如上。</p>

<h3 id="toc_26">@BindingConversion</h3>

<blockquote>
<p>Annotate methods that are used to automatically convert from the expression type to the value used in the setter.<br/><br/>
有时候会遇到类型不匹配的问题，比如<code>R.color.white</code>是<code>int</code>，但是通过Data Binding赋值给<code>android:background</code>属性后，需要把<code>int</code>转换为<code>ColorDrawable</code>。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">@BindingConversion
public static Drawable convertColorToDrawable(int drawable) {
  return new ColorDrawable(drawable);
}
</code></pre>

<h3 id="toc_27">@BindingMethod &amp;&amp; @BindingMethods</h3>

<blockquote>
<p>Used within an BindingMethods annotation to describe a renaming of an attribute to the setter used to set that attribute.Used to enumerate attribute-to-setter renaming.</p>
</blockquote>

<p><strong>@BindingMethods用于修饰类。</strong></p>

<p>一些属性虽然拥有setters但是并不与名字相匹配，这些方法的属性可以通过 @BindingMethod &amp;&amp; @BindingMethods 注释 setters。</p>

<pre class="line-numbers"><code class="language-java">@BindingMethods({
       @BindingMethod(type = &quot;android.widget.ImageView&quot;,
                      attribute = &quot;android:tint&quot;,
                      method = &quot;setImageTintList&quot;),
})
</code></pre>

<p>开发人员不太可能需要重命名 setters ，因为android框架属性已经实现了这一部分。<br/><br/>
事件的默认值是带有<code>AttrChanged</code>的属性名称。在上面的例子中，默认值是<code>android:textAttrChanged</code>，即使它没有提供。<br/><br/>
事件属性用于通知数据绑定系统值已更改。开发人员通常会创建一个<code>BindingAdapter</code>来分配事件。比如：  </p>

<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>

<p>如同<code>BindingAdapters</code>一样， <code>InverseBindingAdapter</code>方法 也可以将 <code>DataBindingComponent</code>作为第一个参数，可以是具有从<code>DataBindingComponent</code>检索的实例的实例方法。<br/><br/>
<code>InverseBindingListener</code>非常有用。  </p>

<p><a href="https://developer.android.com/reference/android/databinding/InverseBindingListener.html">参考 InverseBindingListener</a></p>

<h3 id="toc_28">@InverseBindingMethod</h3>

<p><code>InverseBindingMethod</code>用于标识如何监听对<code>View</code>属性的更改以及要调用的<code>getter</code>方法。<code>InverseBindingMethod</code> 应该与<code>InverseBindingMethods</code>的部分方法相关联。  </p>

<pre class="line-numbers"><code class="language-java">@InverseBindingMethods({@InverseBindingMethod(
     type = android.widget.TextView.class,
     attribute = &quot;android:text&quot;,
     event = &quot;android:textAttrChanged&quot;,
     method = &quot;getText&quot;)})
 public class MyTextViewBindingAdapters { ... }
</code></pre>

<p>@InverseBindingMethods中的属性method 是可选的。</p>

<blockquote>
<p>如果其没有提供， 属性名称会查找如下几种可能性：方法名称，前缀为is或者get的方法名称。 如属性android:text, 数据绑定框架会在TextView中搜索public CharSequence getText() 方法。</p>
</blockquote>

<p>@InverseBindingMethods中的属性event是可选的。</p>

<blockquote>
<p>如果其没有提供，默认会使用属性名+AttrChanged后缀。如属性android:text, 默认的事件名称android:textAttrChanged。</p>
</blockquote>

<p>这个事件也需要配置相关的<code>@BindingAdapter</code>，如下：</p>

<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>

<h3 id="toc_29">@InverseBindingMethods</h3>

<blockquote>
<p>用于枚举属性，<code>getter</code>和事件关联。</p>
</blockquote>

<h3 id="toc_30">@Untaggable</h3>

<p>Data Binding相关的jar包由四部分组成，</p>

<ol>
<li>baseLibrary-2.1.0-rc1.jar<br/>
    作为运行时类库被打进APK中；</li>
<li>DataBinderPlugin（gradle plugin）<br/>
    在编译期使用，利用gradle-api（之前叫transform-api，1.5生，2.0改名）处理xml文件，生成DataBindingInfo.java；</li>
<li>compiler-2.1.0-rc1.jar<br/>
    在编译器使用，入口类继承自AbstractProcessor，用于处理注解，并生成Binding类，DataBindingCompoent.java，DataBinderMapper.java类；</li>
<li>compilerCommon-2.1.0-rc1.jar<br/>
    被DataBinderPlugin和compiler-2.1.0-rc1.jar所依赖</li>
</ol>

<h3 id="toc_31">改变监听</h3>

<p><code>addOnPropertyChangedCallback： Model</code>属性改变时回调发生 <br/>
<code>OnRebindCallback: view</code>发生改变重复绑定时触发</p>

<pre class="line-numbers"><code class="language-java">mModel.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() {
    @Override
    public void onPropertyChanged(Observable observable, int i) {
        if (i == BR.name) {
            Toast.makeText(TwoWayActivity.this, &quot;name changed&quot;,
                    Toast.LENGTH_SHORT).show();
        } else if (i == BR.password) {
            Toast.makeText(TwoWayActivity.this, &quot;password changed&quot;,
                    Toast.LENGTH_SHORT).show();
        }
    }
});
</code></pre>

<h3 id="toc_32">Component</h3>

<p>通过<code>DataBindingUtil.setDefaultComponent</code>来设置不同环境下不同的<code>Component</code>， <br/>
设置之后就可以使用该<code>Component</code>提供的<code>Adapter</code>方法，默认不设置是全局使用，可以理解为作用域。</p>

<pre class="line-numbers"><code class="language-java">public interface TestableAdapter {
    @BindingAdapter(&quot;android:src&quot;)
    void setImageUrl(ImageView imageView, String url);
}

public interface DataBindingComponent {
    TestableAdapter getTestableAdapter();
}

DataBindingUtil.setDefaultComponent(myComponent); 
 ‐ or ‐
binding = MyLayoutBinding.inflate(layoutInflater, myComponent);
</code></pre>

<h2 id="toc_33">相关编译流程</h2>

<h3 id="toc_34">STEP1 资源处理</h3>

<p><code>aapt</code>或者<code>gradle</code>执行时，都会触发资源处理。在资源处理过程中，<code>DataBinding</code>都会扫描一遍现有的资源，生成不包含<code>&lt;layout&gt;</code>的<code>data-binding-layout-out</code>以及<code>DataBinding</code>所需要的<code>data-binding-info</code>；</p>

<h3 id="toc_35">STEP2 DataBindingInfo.class生成</h3>

<p>在完成资源处理后，<code>aapt</code>或者<code>gradle-api</code>都会去执行<code>DataBindingInfo.class</code>生成操作，把相关的信息写入<code>DataBindingInfo.class</code>的@BindingBuildInfo注解中；</p>

<h3 id="toc_36">STEP3 监听到注解变化</h3>

<p>生成<code>@BindingBuildInfo</code>注解，或者code中发现有新的注解写入，<code>AbstractProcessor</code>注解处理器就开始执行注解处理。<code>DataBinding</code>中有一个<code>ProcessDataBinding.jav</code>a类专门来处理<code>DataBinding</code>相关的注解；</p>

<h3 id="toc_37">STEP4 ProcessDataBinding处理注解，生成bin</h3>

<p><code>ProcessDataBinding</code>中处理注解永远会按顺执行3步，<code>ProcessMethodAdapter</code>，<code>ProcessExpressions</code>，<code>ProcessBindable</code>。每次执行都会从磁盘反序列化对应的bin文件，然后往bin中写入新的，完成后再序列化到磁盘；</p>

<h3 id="toc_38">STEP5 生成最终产物</h3>

<p>执行<code>ProcessMethodAdapter</code>生成<code>DataBindingComponents.class</code>；执行<code>ProcessExpressions</code>生成<code>ViewDataBinding.class</code>子类（ActivityDetail2Binding.class），并触发<code>DataBindingMapper.class</code>更新；执行<code>ProcessBindable</code>生成<code>BR.class</code>，并触发<code>DataBindingMapper.class</code>更新。</p>

<h2 id="toc_39">注意：</h2>

<p>不允许使用混合类型</p>

<pre class="line-numbers"><code class="language-java">&lt;!--值得注意的是  
    android:background=&quot;@{boo?@color/red:@drawable/background}&quot;  
    这么写将会发生错误，因为在BindingConversion默认实现为：  
    @BindingConversion  
    public static ColorDrawable convertColorToDrawable(int color) {  
            return new ColorDrawable(color);  
        }  
--&gt;  
&lt;ImageView  
    android:layout_width=&quot;100dp&quot;  
    android:layout_height=&quot;100dp&quot;  
    android:layout_marginTop=&quot;20dp&quot;  
    android:background=&quot;@{boo?@color/red:@color/green}&quot; /&gt;  
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/8</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870348.html">
                
                  <h1>Android-ViewStub详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在开发应用程序的时候，经常会遇到这样的情况，会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为<code>View.GONE</code>，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见<code>View.GONE</code>但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</p>

<h2 id="toc_1">ViewStub</h2>

<p>上面的问题，推荐的做法是使用 Android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了<code>ViewStub.inflate()</code>的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。<br/>
但ViewStub也不是万能的，下面总结下ViewStub能做的事儿和什么时候该用ViewStub，什么时候该用可见性的控制。</p>

<h2 id="toc_2">特点</h2>

<ul>
<li>ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不能够再通过ViewStub来控制它了。</li>
<li>ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</li>
</ul>

<h2 id="toc_3">可以考虑使用ViewStub的情况</h2>

<ul>
<li>在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要<em>在运行时不止一次的显示和隐藏某个布局</em>，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。</li>
<li>想要控制显示与隐藏的是一个布局文件，而非某个View。因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。</li>
</ul>

<h2 id="toc_4">下面来看一个实例</h2>

<p>在这个例子中，要显示二种不同的布局，一个是用TextView显示一段文字，另一个则是用ImageView显示一个图片。这二个是在onCreate()时决定是显示哪一个，这里就是应用ViewStub的最佳地点。</p>

<p>先来看看布局，一个是主布局，里面只定义二个ViewStub，一个用来控制TextView一个用来控制ImageView，另外就是一个是为显示文字的做的TextView布局，一个是为ImageView而做的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;fill_parent&quot;  
  android:layout_height=&quot;fill_parent&quot;  
  android:gravity=&quot;center_horizontal&quot;&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_text&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout_marginTop=&quot;10dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_text_layout&quot;/&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_image&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_image_layout&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>为TextView的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;TextView  
        android:id=&quot;@+id/viewstub_demo_textview&quot;  
        android:layout_width=&quot;fill_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:background=&quot;#aa664411&quot;  
        android:textSize=&quot;16sp&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>为ImageView的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;ImageView  
        android:id=&quot;@+id/viewstub_demo_imageview&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>下面来看代码，决定来显示哪一个，只需要找到相应的ViewStub然后调用其infalte()就可以获得相应想要的布局：</p>

<pre class="line-numbers"><code class="language-java">public class ViewStubDemoActivity extends Activity {  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.viewstub_demo_activity);  
        if ((((int) (Math.random() * 100)) &amp; 0x01) == 0) {  
            // to show text  
            // all you have to do is inflate the ViewStub for textview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_text);  
            stub.inflate();  
            TextView text = (TextView) findViewById(R.id.viewstub_demo_textview);  
            text.setText(&quot;The tree of liberty must be refreshed from time to time&quot; +  
                    &quot; with the blood of patroits and tyrants! Freedom is nothing but &quot; +  
                    &quot;a chance to be better!&quot;);  
        } else {  
            // to show image  
            // all you have to do is inflate the ViewStub for imageview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_image);  
            stub.inflate();  
            ImageView image = (ImageView) findViewById(R.id.viewstub_demo_imageview);  
            image.setImageResource(R.drawable.happy_running_dog);  
        }  
    }  
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/8</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870315.html">
                
                  <h1>Android-android:windowSoftInputMode属性详解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">android:windowSoftInputMode</h2>

<p>activity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题，Android1.5后的一个新特性。</p>

<p>这个属性能影响两件事情：</p>

<ul>
<li>当有焦点产生时，软键盘是隐藏还是显示</li>
<li>是否减少活动主窗口大小以便腾出空间放软键盘</li>
</ul>

<p>它的设置必须是下面列表中的一个值，或一个”state…”值加一个”adjust…”值的组合。在任一组设置多个值——多个”state…”values，例如＆mdash有未定义的结果。各个值之间用|分开。例如:<code>&lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot;. . . &gt;</code></p>

<p>在这设置的值(除&quot;stateUnspecified&quot;和&quot;adjustUnspecified&quot;以外)将覆盖在主题中设置的值。<br/><br/>
各值的含义：</p>

<ul>
<li><code>stateUnspecified</code>：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置</li>
<li><code>stateUnchanged</code>：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示</li>
<li><code>stateHidden</code>：用户选择activity时，软键盘总是被隐藏</li>
<li><code>stateAlwaysHidden</code>：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的</li>
<li><code>stateVisible</code>：软键盘通常是可见的</li>
<li><code>stateAlwaysVisible</code>：用户选择activity时，软键盘总是显示的状态</li>
<li><code>adjustUnspecified</code>：默认设置，通常由系统自行决定是隐藏还是显示</li>
<li><code>adjustResize</code>：该Activity总是调整屏幕的大小以便留出软键盘的空间</li>
<li><code>adjustPan</code>：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870279.html">
                
                  <h1>Android-getViewTreeObserver()</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>我们知道在<code>oncreate</code>中<code>View.getWidth</code>和<code>View.getHeight</code>无法获得一个view的高度和宽度，这是因为View组件布局要在<code>onResume</code>回调后完成。所以现在需要使用<code>getViewTreeObserver().addOnGlobalLayoutListener()</code>来获得宽度或者高度。这是获得一个view的宽度和高度的方法之一。</p>

<h2 id="toc_1">OnGlobalLayoutListener</h2>

<p><code>OnGlobalLayoutListener</code> 是<code>ViewTreeObserver</code>的内部类，当一个视图树的布局发生改变时，可以被<code>ViewTreeObserver</code>监听到，这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。<code>ViewTreeObserver</code>不能直接实例化，而是通过<code>getViewTreeObserver()</code>获得。</p>

<h2 id="toc_2">其他</h2>

<p>除了<code>OnGlobalLayoutListener</code> ，<code>ViewTreeObserver</code>还有如下内部类：</p>

<h3 id="toc_3">interface <code>ViewTreeObserver.OnGlobalFocusChangeListener</code></h3>

<p>当在一个视图树中的焦点状态发生改变时，所要调用的回调函数的接口类</p>

<h3 id="toc_4">interface <code>ViewTreeObserver.OnGlobalLayoutListener</code></h3>

<p>当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类</p>

<h3 id="toc_5">interface <code>ViewTreeObserver.OnPreDrawListener</code></h3>

<p>当一个视图树将要绘制时，所要调用的回调函数的接口类</p>

<h3 id="toc_6">interface <code>ViewTreeObserver.OnScrollChangedListener</code></h3>

<p>当一个视图树中的一些组件发生滚动时，所要调用的回调函数的接口类</p>

<h3 id="toc_7">interface <code>ViewTreeObserver.OnTouchModeChangeListener</code></h3>

<p>当一个视图树的触摸模式发生改变时，所要调用的回调函数的接口类</p>

<h2 id="toc_8">实例</h2>

<p>其中，我们可以利用<code>OnGlobalLayoutListener</code>来获得一个视图的真实高度。</p>

<pre class="line-numbers"><code class="language-java">int mHeaderViewHeight;  
mHeaderView.getViewTreeObserver().addOnGlobalLayoutListener(  
    new OnGlobalLayoutListener() {  
    @Override  
    public void onGlobalLayout() {  
                                                                                                                                                                                                                                        m    HeaderViewHeight = mHeaderView.getHeight();  
    getViewTreeObserver().removeGlobalOnLayoutListener(this);  
    }  
});
</code></pre>

<p><strong>但是需要注意的是OnGlobalLayoutListener可能会被多次触发，因此在得到了高度之后，要将OnGlobalLayoutListener注销掉。另外mHeaderViewHeight和mHeaderView都需要写在当前java文件类（比如Activity）的成员变量中。不能直接在onCreate中定义否则会编译不通过：</strong></p>

<p><code>Cannot refer to a non-final variable sHeight inside an inner class defined in a different method</code></p>

<p>有时候需要在<code>onCreate</code>方法中知道某个View组件的宽度和高度等信息，而直接调用View组件的<code>getWidth()</code>、<code>getHeight()</code>、<code>getMeasuredWidth()</code>、<code>getMeasuredHeight()</code>、<code>getTop()</code>、<code>getLeft()</code>等方法是无法获取到真实值的，只会得到0。这是因为View组件布局要在onResume回调后完成。下面提供实现方法，onGlobalLayout回调会在view布局完成时自动调用:</p>

<pre class="line-numbers"><code class="language-java">// This listener is used to get the final width of the GridView and then calculate the  
// number of columns and the width of each column. The width of each column is variable  
// as the GridView has stretchMode=columnWidth. The column width is used to set the height  
// of each view so we get nice square thumbnails.  
mGridView.getViewTreeObserver().addOnGlobalLayoutListener( //view 布局完成时调用，每次view改变时都会调用  
    new ViewTreeObserver.OnGlobalLayoutListener() {  
    @Override  
    public void onGlobalLayout() {  
        if (mAdapter.getNumColumns() == 0) {  
            final int numColumns = (int) Math.floor(mGridView.getWidth() / (mImageThumbSize + mImageThumbSpacing));  
            if (numColumns &gt; 0) {  
                final int columnWidth = (mGridView.getWidth() / numColumns) - mImageThumbSpacing;  
                mAdapter.setNumColumns(numColumns);   //设置 列数  
                mAdapter.setItemHeight(columnWidth);  //设置 高度  
            }  
        } 
    }  
});
</code></pre>

<p><strong>在gridview布局完成后，根据girdview的宽和高设置adapter列数和每个item高度</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870240.html">
                
                  <h1>Android-Retrofit详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Retrofit入门</h2>

<p>Retrofit 其实相当简单，简单到源码只有37个文件，其中22个文件是注解还都和HTTP有关，真正暴露给用户的类并不多。</p>

<h3 id="toc_1">创建Retrofit实例</h3>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;http://localhost:4567/&quot;)
        .build();
</code></pre>

<p>创建Retrofit实例时需要通过<code>Retrofit.Builder</code>,并调用<code>baseUrl</code>方法设置URL。注： Retrofit2 的baseUlr 必须以 /（斜线） 结束，不然会抛出一个<code>IllegalArgumentException</code>。</p>

<h3 id="toc_2">接口定义</h3>

<p>以获取指定id的Blog为例:</p>

<pre class="line-numbers"><code class="language-java">public interface BlogService {
    @GET(&quot;blog/{id}&quot;)
    Call&lt;ResponseBody&gt; getBlog(@Path(&quot;id&quot;) int id);
}
</code></pre>

<p>注意，这里是<code>interface</code>不是<code>class</code>，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个<code>BlogService</code>的代理对象。<br/>
<code>BlogService service = retrofit.create(BlogService.class);</code><br/>
拿到代理对象之后，就可以调用该方法啦。</p>

<h3 id="toc_3">接口调用</h3>

<pre class="line-numbers"><code class="language-java">Call&lt;ResponseBody&gt; call = service.getBlog(2);
// 用法和OkHttp的call如出一辙,
// 不同的是如果是Android系统回调方法执行在主线程
call.enqueue(new Callback&lt;ResponseBody&gt;() {
    @Override
    public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
        try {
            System.out.println(response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
        t.printStackTrace();
    }
});
</code></pre>

<p>打印结果:</p>

<p><code>{&quot;code&quot;:200,&quot;msg&quot;:&quot;OK&quot;,&quot;data&quot;:{&quot;id&quot;:2,&quot;date&quot;:&quot;2016-04-15 03:17:50&quot;,&quot;author&quot;:&quot;怪盗kidou&quot;,&quot;title&quot;:&quot;Retrofit2 测试2&quot;,&quot;content&quot;:&quot;这里是 Retrofit2 Demo 测试服务器2&quot;},&quot;count&quot;:0,&quot;page&quot;:0}</code></p>

<h2 id="toc_4">Retrofit注解详解</h2>

<p>上面提到Retrofit 共22个注解，这节就专门介绍这22个注解，为帮助大家更好理解我将这22个注解分为三类，并用表格的形式展现出来,表格上说得并不完整，具体的见源码上的例子注释。</p>

<h3 id="toc_5">第一类：HTTP请求方法</h3>

<p><figure><img src="media/15561207870240/15713328600715.png" alt=""/></figure></p>

<p>以上表格中的除HTTP以外都对应了HTTP标准中的请求方法，而HTTP注解则可以代替以上方法中的任意一个注解,有3个属性：<code>method</code>、<code>path</code>、<code>hasBody</code></p>

<pre class="line-numbers"><code class="language-java">public interface BlogService {
    /**
     * method 表示请求的方法，区分大小写
     * path表示路径
     * hasBody表示是否有请求体
     */
    @HTTP(method = &quot;GET&quot;, path = &quot;blog/{id}&quot;, hasBody = false)
    Call&lt;ResponseBody&gt; getBlog(@Path(&quot;id&quot;) int id);
}
public static void main(String[] args){
    Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;http://localhost:4567/&quot;)
        .build();
    BlogService service = retrofit.create(BlogService.class);
    Call&lt;ResponseBody&gt; call = service.getBlog(2);
    ResponseBodyPrinter.printResponseBody(call);
}
</code></pre>

<h3 id="toc_6">第二类：标记类</h3>

<p><figure><img src="media/15561207870240/15713328762764.png" alt=""/></figure></p>

<p>Field、FieldMap、Part和PartMap 示例</p>

<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap/Multipart/Part/PartMap注解]源码
 */
public class Example03 {
    public interface BlogService {

        /**
         * {@link FormUrlEncoded} 表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）
         * &lt;code&gt;Field(&quot;username&quot;)&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值
         */
        @POST(&quot;/form&quot;)
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field(&quot;username&quot;) String name, @Field(&quot;age&quot;) int age);

        /**
         * Map的key作为表单的键
         */
        @POST(&quot;/form&quot;)
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded2(@FieldMap Map&lt;String, Object&gt; map);


        /**
         * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型
         * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，
         */
        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload1(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;age&quot;) RequestBody age, @Part MultipartBody.Part file);

        /**
         * PartMap 注解支持一个Map作为参数，支持 {@link RequestBody } 类型，
         * 如果有其它的类型，会被{@link retrofit2.Converter}转换，如后面会介绍的 使用{@link com.google.gson.Gson} 的 {@link retrofit2.converter.gson.GsonRequestBodyConverter}
         * 所以{@link MultipartBody.Part} 就不适用了,所以文件只能用&lt;b&gt; @Part MultipartBody.Part &lt;/b&gt;
         */
        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload2(@PartMap Map&lt;String, RequestBody&gt; args, @Part MultipartBody.Part file);

        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload3(@PartMap Map&lt;String, RequestBody&gt; args);
    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);


        // 演示 @FormUrlEncoded 和 @Field
        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(&quot;怪盗kidou&quot;, 24);
        ResponseBodyPrinter.printResponseBody(call1);


        //===================================================

        // 演示 @FormUrlEncoded 和 @FieldMap
        // 实现的效果与上面想同
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;username&quot;, &quot;怪盗kidou&quot;);
        map.put(&quot;age&quot;, 24);
        Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map);
        ResponseBodyPrinter.printResponseBody(call2);


        //===================================================


        MediaType textType = MediaType.parse(&quot;text/plain&quot;);
        RequestBody name = RequestBody.create(textType, &quot;怪盗kidou&quot;);
        RequestBody age = RequestBody.create(textType, &quot;24&quot;);
        RequestBody file = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), &quot;这里是模拟文件的内容&quot;);

        // 演示 @Multipart 和 @Part
        MultipartBody.Part filePart = MultipartBody.Part.createFormData(&quot;file&quot;, &quot;test.txt&quot;, file);
        Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart);
        ResponseBodyPrinter.printResponseBody(call3);

        //===================================================
        // 演示 @Multipart 和 @PartMap
        // 实现和上面同样的效果
        Map&lt;String, RequestBody&gt; fileUpload2Args = new HashMap&lt;&gt;();
        fileUpload2Args.put(&quot;name&quot;, name);
        fileUpload2Args.put(&quot;age&quot;, age);
        //这里并不会被当成文件，因为没有文件名(包含在Content-Disposition请求头中)，但上面的 filePart 有
        //fileUpload2Args.put(&quot;file&quot;, file);
        Call&lt;ResponseBody&gt; call4 = service.testFileUpload2(fileUpload2Args, filePart); //单独处理文件
        ResponseBodyPrinter.printResponseBody(call4);

        //===================================================
        // 还有一种比较hack的方式可以实现文件上传，
        // 上面说过被当成文件上传的必要条件就是 Content-Disposition 请求头中必须要有 filename=&quot;xxx&quot; 才会被当成文件
        // 所有我们在写文件名的时候可以拼把 filename=&quot;XXX&quot; 也拼接上去，
        // 即文件名变成  表单键名&quot;; filename=&quot;文件名  （两端的引号会自动加，所以这里不加）也可以实现，但是不推荐方式

        Map&lt;String, RequestBody&gt; fileUpload3Args = new HashMap&lt;&gt;();
        fileUpload3Args.put(&quot;name&quot;,name);
        fileUpload3Args.put(&quot;age&quot;,age);
        fileUpload3Args.put(&quot;file\&quot;; filename=\&quot;test.txt&quot;,file);
        Call&lt;ResponseBody&gt; testFileUpload3 = service.testFileUpload3(fileUpload3Args);
        ResponseBodyPrinter.printResponseBody(testFileUpload3);
    }
}
</code></pre>

<h3 id="toc_7">第三类：参数类</h3>

<p><figure><img src="media/15561207870240/15713328860835.png" alt=""/></figure></p>

<p>注1：{占位符}和<code>PATH</code>尽量只用在URL的path部分，url中的参数使用<code>Query</code>和<code>QueryMap</code> 代替，保证接口定义的简洁注2：<code>Query</code>、<code>Field</code>和<code>Part</code>这三者都支持数组和实现了<code>Iterable</code>接口的类型，如<code>List</code>，<code>Set</code>等，方便向后台传递数组。</p>

<pre class="line-numbers"><code class="language-java">Call&lt;ResponseBody&gt; foo(@Query(&quot;ids[]&quot;) List&lt;Integer&gt; ids);
//结果：ids[]=0&amp;ids[]=1&amp;ids[]=2
</code></pre>

<p>Header和Headers例子</p>

<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap注解]源码
 */
public class Example04 {
    public interface BlogService {
        @GET(&quot;/headers?showAll=true&quot;)
        @Headers({&quot;CustomHeader1: customHeaderValue1&quot;, &quot;CustomHeader2: customHeaderValue2&quot;})
        Call&lt;ResponseBody&gt; testHeader(@Header(&quot;CustomHeader3&quot;) String customHeaderValue3);

    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);

        //演示 @Headers 和 @Header
        Call&lt;ResponseBody&gt; call1 = service.testHeader(&quot;ikidou&quot;);
        ResponseBodyPrinter.printResponseBody(call1);
    }
}
</code></pre>

<p>Query、QueryMap、Url 示例</p>

<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap注解]源码
 */
public class Example05 {
    public interface BlogService {
        /**
         * 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供
         * 对于Query和QueryMap，如果不是String（或Map的第二个泛型参数不是String）时
         * 会被默认会调用toString转换成String类型
         * Url支持的类型有 okhttp3.HttpUrl, String, java.net.URI, android.net.Uri
         * {@link retrofit2.http.QueryMap} 用法和{@link retrofit2.http.FieldMap} 用法一样，不再说明
         */
        @GET //当有URL注解时，这里的URL就省略了
        Call&lt;ResponseBody&gt; testUrlAndQuery(@Url String url, @Query(&quot;showAll&quot;) boolean showAll);

    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);

        //演示 @Headers 和 @Header
        Call&lt;ResponseBody&gt; call1 = service.testUrlAndQuery(&quot;headers&quot;,false);
        ResponseBodyPrinter.printResponseBody(call1);
    }
}
</code></pre>

<h2 id="toc_8">Gson与Converter</h2>

<p>在默认情况下Retrofit只支持将HTTP的响应体转换换为<code>ResponseBody</code>,这也是什么我在前面的例子接口的返回值都是 <code>Call&lt;ResponseBody&gt;</code>，但如果响应体只是支持转换为<code>ResponseBody</code>的话何必要引用泛型呢，返回值直接用一个<code>Call</code>就行了嘛，既然支持泛型，那说明泛型参数可以是其它类型的，而<code>Converter</code>就是Retrofit为我们提供用于将<code>ResponseBody</code>转换为我们想要的类型，有了<code>Converter</code>之后我们就可以写把我们的第一个例子的接口写成这个样子了：</p>

<pre class="line-numbers"><code class="language-java">public interface BlogService {
  @GET(&quot;blog/{id}&quot;)
  Call&lt;Result&lt;Blog&gt;&gt; getBlog(@Path(&quot;id&quot;) int id);
}
</code></pre>

<p>当然只改变泛型的类型是不行的，我们在创建Retrofit时需要明确告知用于将<code>ResponseBody</code>转换我们泛型中的类型时需要使用的<code>Converter</code>引入Gson支持:<br/>
<code>compile &#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;</code></p>

<p>通过<code>GsonConverterFactory</code>为<code>Retrofit</code>添加<code>Gson</code>支持：</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
      //配置你的Gson
      .setDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)
      .create();

Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      //可以接收自定义的Gson，当然也可以不传
      .addConverterFactory(GsonConverterFactory.create(gson))
      .build();
</code></pre>

<p>这样Retrofit就会使用Gson将<code>ResponseBody</code>转换我们想要的类型。这是时候我们终于可以演示如使创建一个Blog了！</p>

<pre class="line-numbers"><code class="language-java">@POST(&quot;blog&quot;)
Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog);
</code></pre>

<p>被<code>@Body</code>注解的的Blog将会被Gson转换成RequestBody发送到服务器。</p>

<pre class="line-numbers"><code class="language-java">BlogService service = retrofit.create(BlogService.class);
Blog blog = new Blog();
blog.content = &quot;新建的Blog&quot;;
blog.title = &quot;测试&quot;;
blog.author = &quot;怪盗kidou&quot;;
Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog);
</code></pre>

<p>结果：</p>

<p><code>Result{code=200, msg=&#39;OK&#39;, data=Blog{id=20, date=&#39;2016-04-21 05:29:58&#39;, author=&#39;怪盗kidou&#39;, title=&#39;测试&#39;, content=&#39;新建的Blog&#39;}, count=0, page=0}</code></p>

<h2 id="toc_9">RxJava与CallAdapter</h2>

<p>说到Retrofit就不得说到另一个火到不行的库<code>RxJava</code>，网上已经不少文章讲如何与Retrofit结合，但这里还是会有一个RxJava的例子，不过这里主要目的是介绍使用<code>CallAdapter</code>所带来的效果。</p>

<p>第3节介绍的<code>Converter</code>是对于<code>Call&lt;T&gt;</code>中<code>T</code>的转换，而<code>CallAdapter</code>则可以对<code>Call</code>转换，这样的话<code>Call&lt;T&gt;</code>中的<code>Call</code>也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个<code>CallAdapter</code>，这里以<code>RxJava</code>的为例，用<code>Observable</code>代替<code>Call</code>：</p>

<p>引入RxJava支持:</p>

<pre class="line-numbers"><code class="language-java">compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39;
// 针对rxjava2.x（adapter-rxjava2的版本要 &gt;= 2.2.0）
compile &#39;com.squareup.retrofit2:adapter-rxjava2:2.3.0&#39;
</code></pre>

<p>通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：</p>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
      // 针对rxjava2.x
      .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) 
      .build();
</code></pre>

<p>接口设计：</p>

<pre class="line-numbers"><code class="language-java">public interface BlogService {
  @POST(&quot;/blog&quot;)
  Observable&lt;Result&lt;List&lt;Blog&gt;&gt;&gt; getBlogs();
}
</code></pre>

<p>使用：</p>

<pre class="line-numbers"><code class="language-java">BlogService service = retrofit.create(BlogService.class);
service.getBlogs(1)
  .subscribeOn(Schedulers.io())
  .subscribe(new Subscriber&lt;Result&lt;List&lt;Blog&gt;&gt;&gt;() {
      @Override
      public void onCompleted() {
        System.out.println(&quot;onCompleted&quot;);
      }

      @Override
      public void onError(Throwable e) {
        System.err.println(&quot;onError&quot;);
      }

      @Override
      public void onNext(Result&lt;List&lt;Blog&gt;&gt; blogsResult) {
        System.out.println(blogsResult);
      }
  });
</code></pre>

<p>结果：</p>

<p><code>Result{code=200, msg=&#39;OK&#39;, data=[Blog{id=1, date=&#39;2016-04-15 03:17:50&#39;, author=&#39;怪盗kidou&#39;, title=&#39;Retrofit2 测试1&#39;, content=&#39;这里是 Retrofit2 Demo 测试服务器1&#39;},.....], count=20, page=1}</code></p>

<p>像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：</p>

<ol>
<li>用<code>Observable&lt;Response&lt;T&gt;&gt;</code> 代替 <code>Observable&lt;T&gt;</code> ,这里的<code>Response</code>指<code>retrofit2.Response</code></li>
<li>用<code>Observable&lt;Result&lt;T&gt;&gt;</code> 代替 <code>Observable&lt;T&gt;</code>，这里的<code>Result</code>是指<code>retrofit2.adapter.rxjava.Result</code>,这个Result中包含了<code>Response</code>的实例。</li>
</ol>

<h2 id="toc_10">自定义Converter</h2>

<p>本节的内容是教大家实现在一简易的Converter，这里以返回格式为<code>Call&lt;String&gt;</code>为例。<br/><br/>
在此之前先了解一下Converter接口及其作用：</p>

<pre class="line-numbers"><code class="language-java">public interface Converter&lt;F, T&gt; {
  // 实现从 F(rom) 到 T(o)的转换
  T convert(F value) throws IOException;

  // 用于向Retrofit提供相应Converter的工厂
  abstract class Factory {
    // 这里创建从ResponseBody其它类型的Converter，如果不能处理返回null
    // 主要用于对响应体的处理
    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) {
      return null;
    }

    // 在这里创建 从自定类型到ResponseBody 的Converter,不能处理就返回null，
    // 主要用于对Part、PartMap、Body注解的处理
    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,
    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
      return null;
    }

    // 这里用于对Field、FieldMap、Header、Path、Query、QueryMap注解的处理
    // Retrfofit对于上面的几个注解默认使用的是调用toString方法
    public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) {
      return null;
    }

  }
}
</code></pre>

<p>我们要想从<code>Call&lt;ResponseBody&gt;</code> 转换为 <code>Call&lt;String&gt;</code> 那么对应的F和T则分别对应<code>ResponseBody</code>和<code>String</code>，我们定义一个<code>StringConverter</code>并实现Converter接口。</p>

<pre class="line-numbers"><code class="language-java">public static class StringConverter implements Converter&lt;ResponseBody, String&gt; {

  public static final StringConverter INSTANCE = new StringConverter();

  @Override
  public String convert(ResponseBody value) throws IOException {
    return value.string();
  }
}
</code></pre>

<p>我们需要一个<code>Fractory</code>来向Retrofit注册<code>StringConverter</code></p>

<pre class="line-numbers"><code class="language-java">public static class StringConverterFactory extends Converter.Factory {

  public static final StringConverterFactory INSTANCE = new StringConverterFactory();

  public static StringConverterFactory create() {
    return INSTANCE;
  }

  // 我们只关实现从ResponseBody 到 String 的转换，所以其它方法可不覆盖
  @Override
  public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {
    if (type == String.class) {
      return StringConverter.INSTANCE;
    }
    //其它类型我们不处理，返回null就行
    return null;
  }
}
</code></pre>

<p>使用<code>Retrofit.Builder.addConverterFactory</code>向Retrofit注册我们<code>StringConverterFactory</code>：</p>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      // 如是有Gson这类的Converter 一定要放在其它前面
      .addConverterFactory(StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .build();
</code></pre>

<p>注：<code>addConverterFactory</code>是有先后顺序的，如果有多个ConverterFactory都支持同一种类型，那么就是只有第一个才会被使用，而<code>GsonConverterFactory</code>是不判断是否支持的，所以这里交换了顺序还会有一个异常抛出，原因是类型不匹配。</p>

<p>只要返回值类型的泛型参数就会由我们的<code>StringConverter</code>处理,不管是<code>Call&lt;String&gt;</code>还是<code>Observable&lt;String&gt;</code>有没有很简单?如果你有其它的需求处理的就自己实现吧。</p>

<h2 id="toc_11">自定义CallAdapter</h2>

<p>本节将介绍如何自定一个<code>CallAdapter</code>，并验证是否所有的String都会使用我们第5节中自定义的Converter。</p>

<p>先看一下CallAdapter接口定义及各方法的作用：</p>

<pre class="line-numbers"><code class="language-java">public interface CallAdapter&lt;T&gt; {

  // 直正数据的类型 如Call&lt;T&gt; 中的 T
  // 这个 T 会作为Converter.Factory.responseBodyConverter 的第一个参数
  // 可以参照上面的自定义Converter
  Type responseType();

  &lt;R&gt; T adapt(Call&lt;R&gt; call);

  // 用于向Retrofit提供CallAdapter的工厂类
  abstract class Factory {
    // 在这个方法中判断是否是我们支持的类型，returnType 即Call&lt;Requestbody&gt;和`Observable&lt;Requestbody&gt;`
    // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型
    // 不支持时返回null
    public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations,
    Retrofit retrofit);

    // 用于获取泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody
    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
      return Utils.getParameterUpperBound(index, type);
    }

    // 用于获取泛型的原始类型 如 Call&lt;Requestbody&gt; 中的 Call
    // 上面的get方法需要使用该方法。
    protected static Class&lt;?&gt; getRawType(Type type) {
      return Utils.getRawType(type);
    }
  }
}
</code></pre>

<p>了解了<code>CallAdapter</code>的结构和其作用之后，我们就可以开始自定义我们的<code>CallAdapter</code>了，本节以<code>CustomCall&lt;String&gt;</code>为例。<br/>
在此我们需要定义一个<code>CustomCall</code>，不过这里的<code>CustomCall</code>作为演示只是对<code>Call</code>的一个包装，并没有实际的用途。</p>

<pre class="line-numbers"><code class="language-java">public static class CustomCall&lt;R&gt; {

  public final Call&lt;R&gt; call;

  public CustomCall(Call&lt;R&gt; call) {
    this.call = call;
  }

  public R get() throws IOException {
    return call.execute().body();
  }
}
</code></pre>

<p>有了<code>CustomCall</code>，我们还需要一个<code>CustomCallAdapter</code>来实现 <code>Call&lt;T&gt;</code> 到 <code>CustomCall&lt;T&gt;</code>的转换，这里需要注意的是最后的泛型，是我们要返回的类型。</p>

<pre class="line-numbers"><code class="language-java">public static class CustomCallAdapter implements CallAdapter&lt;CustomCall&lt;?&gt;&gt; {

  private final Type responseType;

  // 下面的 responseType 方法需要数据的类型
  CustomCallAdapter(Type responseType) {
    this.responseType = responseType;
  }

  @Override
  public Type responseType() {
    return responseType;
  }

  @Override
  public &lt;R&gt; CustomCall&lt;R&gt; adapt(Call&lt;R&gt; call) {
    // 由 CustomCall 决定如何使用
    return new CustomCall&lt;&gt;(call);
  }
}
</code></pre>

<p>提供一个<code>CustomCallAdapterFactory</code>用于向Retrofit提供<code>CustomCallAdapter</code>：</p>

<pre class="line-numbers"><code class="language-java">public static class CustomCallAdapterFactory extends CallAdapter.Factory {
  public static final CustomCallAdapterFactory INSTANCE = new CustomCallAdapterFactory();

  @Override
  public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
    // 获取原始类型
    Class&lt;?&gt; rawType = getRawType(returnType);
    // 返回值必须是CustomCall并且带有泛型
    if (rawType == CustomCall.class &amp;&amp; returnType instanceof ParameterizedType) {
      Type callReturnType = getParameterUpperBound(0, (ParameterizedType) returnType);
      return new CustomCallAdapter(callReturnType);
    }
    return null;
  }
}
</code></pre>

<p>使用<code>addCallAdapterFactory</code>向Retrofit注册<code>CustomCallAdapterFactory</code>。</p>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(Example09.StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(CustomCallAdapterFactory.INSTANCE)
      .build();
</code></pre>

<p>注： <code>addCallAdapterFactory</code>与<code>addConverterFactory</code>同理，也有先后顺序。</p>

<h2 id="toc_12">其它说明</h2>

<h3 id="toc_13">Retrofit.Builder</h3>

<p>前面用到了 <code>Retrofit.Builder</code> 中的<code>baseUrl</code>、<code>addCallAdapterFactory</code>、<code>addConverterFactory</code>、<code>build</code>方法，还有<code>callbackExecutor</code>、<code>callFactory</code>、<code>client</code>、<code>validateEagerly</code>这四个方法没有用到，这里简单的介绍一下。</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>

<tbody>
<tr>
<td>callbackExecutor(Executor)</td>
<td>指定<code>Call.enqueue</code>时使用的<code>Executor</code>，所以该设置只对返回值为<code>Call</code>的方法有效</td>
</tr>
<tr>
<td>callFactory(Factory)</td>
<td>设置一个自定义的<code>okhttp3.Call.Factory</code>，那什么是Factory呢?<code>OkHttpClient</code>就实现了<code>okhttp3.Call.Factory</code>接口，下面的<code>client(OkHttpClient)</code>最终也是调用了该方法，也就是说两者不能共用</td>
</tr>
<tr>
<td>client(OkHttpClient)</td>
<td>设置自定义的<code>OkHttpClient</code>,以前的Retrofit版本中不同的<code>Retrofit</code>对象共用同<code>OkHttpClient</code>,在2.0各对象各自持有不同的<code>OkHttpClient</code>实例，所以当你需要共用<code>OkHttpClient</code>或需要自定义时则可以使用该方法，如：处理Cookie、使用 stetho  调式等<br/></td>
</tr>
<tr>
<td>validateEagerly(boolean)</td>
<td>是否在调用<code>create(Class)</code>时检测接口定义是否正确，而不是在调用方法才检测，适合在开发、测试时使用</td>
</tr>
</tbody>
</table>

<h3 id="toc_14">Retrofit的Url组合规则</h3>

<table>
<thead>
<tr>
<th>BaseUrl</th>
<th>和URL有关的注解中提供的值</th>
<th>最后结果</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td>/post</td>
<td><a href="http://localhost:4567/post">http://localhost:4567/post</a></td>
</tr>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td>post</td>
<td><a href="http://localhost:4567/path/to/other/post">http://localhost:4567/path/to/other/post</a></td>
</tr>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td><a href="https://github.com/ikidou">https://github.com/ikidou</a></td>
<td><a href="https://github.com/ikidou">https://github.com/ikidou</a></td>
</tr>
</tbody>
</table>

<p>从上面不能难看出以下规则：</p>

<ul>
<li>如果你在注解中提供的url是完整的url，则url将作为请求的url。</li>
<li>如果你在注解中提供的url是不完整的url，且不以 / 开头，则请求的url为baseUrl+注解中提供的值</li>
<li>如果你在注解中提供的url是不完整的url，且以 / 开头，则请求的url为baseUrl的主机部分+注解中提供的值</li>
</ul>

<h3 id="toc_15">Retrofit提供的Converter</h3>

<table>
<thead>
<tr>
<th>Converter</th>
<th>Gradle依赖</th>
</tr>
</thead>

<tbody>
<tr>
<td>Gson</td>
<td>com.squareup.retrofit2:converter-gson:2.0.2</td>
</tr>
<tr>
<td>Jackson</td>
<td>com.squareup.retrofit2:converter-jackson:2.0.2</td>
</tr>
<tr>
<td>Moshi</td>
<td>com.squareup.retrofit2:converter-moshi:2.0.2</td>
</tr>
<tr>
<td>Protobuf</td>
<td>com.squareup.retrofit2:converter-protobuf:2.0.2</td>
</tr>
<tr>
<td>Wire</td>
<td>com.squareup.retrofit2:converter-wire:2.0.2</td>
</tr>
<tr>
<td>Simple XML</td>
<td>com.squareup.retrofit2:converter-simplexml:2.0.2</td>
</tr>
<tr>
<td>Scalars</td>
<td>com.squareup.retrofit2:converter-scalars:2.0.2</td>
</tr>
</tbody>
</table>

<h3 id="toc_16">Retrofit提供的CallAdapter：</h3>

<table>
<thead>
<tr>
<th>CallAdapter</th>
<th>Gradle依赖</th>
</tr>
</thead>

<tbody>
<tr>
<td>guava</td>
<td>com.squareup.retrofit2:adapter-guava:2.0.2</td>
</tr>
<tr>
<td>Java8</td>
<td>com.squareup.retrofit2:adapter-java8:2.0.2</td>
</tr>
<tr>
<td>rxjava</td>
<td>com.squareup.retrofit2:adapter-rxjava:2.0.2</td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_7.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_9.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android%E6%BA%90%E7%A0%81.html"><strong>Android源码</strong></a>
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15818619982581.html">IDEA 远程一键部署Spring Boot到Docker</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813395132789.html">Flutter VsCode插件</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15809146907844.html">Flutter 组件小记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15808782889824.html">Flutter常用第三方库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15767453112302.html">添加环境变量</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_SVG-full"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
