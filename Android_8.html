<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207871413.html">
                
                  <h1>Android Studio 快速创建Activity、Fragment模板</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="media/15561207871413/2017110415097859584759.gif" alt=""/></figure></p>

<blockquote>
<p>自行复制粘贴在<code>Settings</code>&gt;<code>Editor</code>&gt;<code>File and Code Templates</code>新建一个</p>
</blockquote>

<p><figure><img src="media/15561207871413/15713366916509.png" alt=""/></figure></p>

<h2 id="toc_0">Activity</h2>

<p>可以自行将AppCompatActivity换成自己的BaseActivity，不要忘记更改import哦</p>

<pre class="line-numbers"><code class="language-text">#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME}

#end
import android.os.Bundle
import android.support.v7.app.AppCompatActivity
/**
* description-&gt;&lt;一句话功能简介&gt;
* @author SLJ
* @time ${DATE}
*/
class ${NAME} : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
    }
}
</code></pre>

<h2 id="toc_1">Fragment</h2>

<pre class="line-numbers"><code class="language-text">#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME}

#end
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.app.Fragment
/**
* description-&gt;&lt;一句话功能简介&gt;
* @author SLJ
* @time ${DATE}
*/
class ${NAME} : Fragment() {
    
    override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View {
        val view = inflater?.inflate(, container, false)
        return view!!
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871451.html">
                
                  <h1>Android 为什么不该使用Timer</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">概述</h2>

<p>在Java开发中，用过定时功能的同学一定不会对Timer感到陌生。不过，除了Timer，在Java 5之后又引入了一个定时工具ScheduledThreadPoolExecutor，那么我们应该如何在这两个定时工具之间进行选择呢？</p>

<p>一般情况下我们都建议使用ScheduledThreadPoolExecutor而不是Timer，主要原因有以下3点：</p>

<ol>
<li>Timer使用的是绝对时间，系统时间的改变会对Timer产生一定的影响；而ScheduledThreadPoolExecutor使用的是相对时间，所以不会有这个问题。</li>
<li>Timer使用单线程来处理任务，长时间运行的任务会导致其他任务的延时处理，而ScheduledThreadPoolExecutor可以自定义线程数量。</li>
<li>Timer没有对运行时异常进行处理，一旦某个任务触发运行时异常，会导致整个Timer崩溃，而ScheduledThreadPoolExecutor对运行时异常做了捕获（可以在afterExecute()回调方法中进行处理），所以更加安全。</li>
</ol>

<p>下面我们就来通过了解Timer与ScheduledThreadPoolExecutor的运行原理来理解上面几个问题出现的原因。</p>

<h2 id="toc_1">Timer的运行机制</h2>

<p><figure><img src="media/15561207871451/15713367067259.jpg" alt=""/></figure></p>

<ul>
<li>TimerTask：任务类。内部持有<code>nextExecutionTime</code>变量，表示任务实际执行时间点，单位为毫秒，使用<code>System.currentTimeMillis()</code> + <code>delay</code>计算得出。</li>
<li><code>TimerQueue</code>：使用小根堆实现的优先队列。按照<code>TimerTask</code>的实际执行时间点由小到大排序。</li>
<li><code>TimerThread</code>：顾名思义，这是实际执行任务的线程。</li>
</ul>

<p><code>TimerThread</code>会在<code>Timer</code>初始化后启动，之后会进入<code>mainLoop()</code>方法，该方法会不断从<code>TimerQueue</code>中取出时间点最小的<code>TimerTask</code>。如果该<code>TimerTask</code>的执行时间点已到，则直接调用<code>TimerTask.run()</code>执行；否则，调用<code>wait()</code>方法，等待相应的时间。</p>

<p>而我们调用<code>Timer.schedule()</code>方法，实际上是通过<code>TimerQueue.add()</code>方法，将TimerTask加入任务等待队列。</p>

<p>这里还有一个需要注意的地方是：当加入任务的执行时间点是优先队列中最小的时，就调用<code>notify()</code>方法唤醒<code>TimerThread</code>，而<code>TimerThread</code>在被唤醒后会重新调用<code>TimerQueue.getMin()</code>方法，再次调用<code>wait()</code>，不过这次的等待时间就变成了新加入任务的时间点。</p>

<h2 id="toc_2">ScheduledThreadPoolExecutor的运行机制</h2>

<p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，对线程池的原理不了解的同学，可以看一下我的这篇文章：<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2F1fe47a3e8f4c">从零实现ImageLoader（三）—— 线程池详解</a>。</p>

<p>ScheduledThreadPoolExecutor的实现比Timer要复杂一些，不过要是理解了线程池的运行原理，其实也不难。它只不过是在ThreadPoolExecutor的基础上使用自定义的阻塞队列DelayedWorkQueue来实现任务定时功能。所以ScheduledThreadPoolExecutor的运行流程其实和ThreadPoolExecutor是差不多的。</p>

<p><figure><img src="media/15561207871451/15713367175739.jpg" alt=""/></figure></p>

<ul>
<li><strong>ScheduledFutureTask</strong>：任务类。内部持有time变量，单位为纳秒，通过<code>System.nanoTime()</code> + <code>delay</code>计算得出。</li>
<li><strong>DelayedWorkQueue</strong>：使用小根堆实现的优先阻塞队列，将ScheduledFutureTask按照从小到大的顺序排列，同时在take()方法内实现阻塞操作。</li>
<li><strong>WorkerThread</strong>：这里为了简单起见，我将线程池的核心线程和临时线程统一写成WorkerThread，但需要注意的是<code>ScheduledThreadPoolExecutor</code>是线程池的一个子类，所以线程池的那一套东西在<code>ScheduledThreadPoolExecutor</code>里也是有的。</li>
</ul>

<p>光从这两个图上看，好像ScheduledThreadPoolExecutor和Timer的实现都大同小异，不过是换了一些名字，但实际上这两个的实现还是有很大的不同的，不止因为ScheduledThreadPoolExecutor使用的是多线程。</p>

<p>在Timer里定时功能的实现主要依靠TimerThread.mainLoop()的等待，而ScheduledThreadPoolExecutor使用的是多线程，在每个线程里都单独实现定时功能是不现实的，因此，<code>ScheduledThreadPoolExecutor</code>将定时功能放在了<code>DelayedWorkQueue</code>类里，而由于<code>DelayedWorkQueue</code>是阻塞队列，所以定时任务的实现实际上就在<code>DelayedWorkQueue.take()</code>方法中。下面我们就来分析一下<code>DelayedWorkQueue.take()</code>到底做了什么。</p>

<h3 id="toc_3">Leader/Follower模式</h3>

<p>在多线程网络编程中，我们一般使用一个线程监听端口，在接收到事件后再使用其他的线程去完成操作。这种情况下，在两个线程之间的上下文切换开销其实是很大的，于是我们有了Leader/Follower模式：</p>

<p><figure><img src="media/15561207871451/15713367286186.png" alt=""/></figure></p>

<p>在Leader/Follower模式中，不存在一个专门用来监听的线程，所有的线程都是等价的，而这些线程会不断在Leader、Follower和Processor这三个状态之间来回切换。</p>

<p>在程序中会保证每个时刻有且只有一个Leader，这个Leader就暂时充当了之前用来监听端口线程的作用。而当有一个新的事件发生时，Leader不再是重新找一个线程去处理连接，而是自己转化为Processor处理事件，并且重新指定一个Follower作为新的Leader。当事件处理完毕后，Processor又会转化为Follower等待重新成为Leader。</p>

<h3 id="toc_4">take()方法的原理</h3>

<p>这里的<code>take()</code>方法就借助了<code>Leader/Follower</code>模式的思想，同一时刻只有一个<code>Leader</code>线程，不过这里由于任务执行的时间点是已经确定了的，所以不再是等待一个触发事件，而是等待最小任务所对应的延迟时间。其他的<code>Follower</code>线程则处于无限等待的状态，直到当前<code>Leader</code>到达指定时间后转化为<code>Processor</code>去处理任务，这时就会唤醒一个<code>Follower</code>作为下一任的<code>Leader</code>。而Processor在处理完任务后又会重新加入<code>Follower</code>进行等待。</p>

<h2 id="toc_5">绝对时间与相对时间</h2>

<p>了解了Timer与ScheduledThreadPoolExecutor的运行机制，下面我们就来看一下Timer的这些缺陷究竟是怎么回事。</p>

<p>首先是绝对时间与相对时间的问题，可能有人已经发现，不管是TimerTask还是ScheduledFutureTask都是存储的实际执行时间点，只不过一个是毫秒，一个是纳秒，难道时间单位还会对这些有影响？确实，时间单位是不会对任务的执行有影响的，不过这里的玄机就在于这个时间的计算方式：<code>System.currentTimeMillis()</code>与<code>System.nanoTime()</code>。</p>

<p><code>System.currentTimeMillis()</code>大家已经很清楚了，就是当前时间与1970年1月1日午夜的时间差的毫秒数，而<code>System.nanoTime()</code>又是什么呢？官方文档里是这么说的：</p>

<blockquote>
<p>此方法只能用于测量已过的时间，与系统或钟表时间的其他任何时间概念无关。返回值表示从某一固定但任意的时间算起的毫微秒数。<br/>
这就是Timer与ScheduledThreadPoolExecutor一个是基于绝对时间而另一个是基于相对时间的原因。下面我们写个例子来测试一下：</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t&quot; + new Date());

    Executors.newSingleThreadScheduledExecutor().schedule(() -&gt; {
        System.out.println(&quot;Executor:\t&quot; + new Date());
    }, 60, TimeUnit.SECONDS);

    new Timer().schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer:\t&quot; + new Date());
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-text">Start:    Sun Oct 08 10:51:44 CST 2017
Executor:    Sun Oct 08 10:51:41 CST 2017
Timer:    Sun Oct 08 10:52:45 CST 2017
</code></pre>

<p>这里，我在启动之后将系统的时钟向后调了一分钟，所以实际的启动时间应该是10:50:44，由于ScheduledThreadPoolExecutor的等待时间与系统无关，所以在一分钟后执行；而Timer是基于绝对时间的所以在10:52:45执行，实际上这时已经过去两分钟了。</p>

<h2 id="toc_6">单线程与多线程</h2>

<p>Timer的第二个缺陷是，由于它使用的是单线程，所以长时间执行的任务会对其他任务产生影响。</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    ScheduledExecutorService service = Executors.newScheduledThreadPool(3);

    service.schedule(() -&gt; {
        System.out.println(&quot;Executor 任务1:\t&quot; + new Date());
        try {
            Thread.sleep(30000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, 60, TimeUnit.SECONDS);
    service.schedule(() -&gt; {
        System.out.println(&quot;Executor 任务2:\t&quot; + new Date());
        try {
            Thread.sleep(30000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, 60, TimeUnit.SECONDS);

    Timer timer = new Timer();

    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer 任务1:\t\t&quot; + new Date());
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, 60000);
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer 任务2:\t\t&quot; + new Date());
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-text">Start:            Sun Oct 08 11:10:34 CST 2017
Executor 任务1:    Sun Oct 08 11:11:34 CST 2017
Executor 任务2:    Sun Oct 08 11:11:34 CST 2017
Timer 任务1:        Sun Oct 08 11:11:34 CST 2017
Timer 任务2:        Sun Oct 08 11:12:04 CST 2017
</code></pre>

<p>可以看到ScheduledThreadPoolExecutor中的两个任务在等待一分钟之后同时执行；而在Timer中的任务2却因任务1长达半分钟的执行时间，总共等了一分半钟才得以执行。</p>

<h2 id="toc_7">异常处理</h2>

<p>最后我们来看一下Timer与ScheduledThreadPoolExecutor对异常的处理情况：</p>

<h3 id="toc_8">Timer</h3>

<p>Timer内部没有对异常做任何处理，如果任务执行发生运行时异常，整个TimerThread都会崩溃：</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    Timer timer = new Timer();

    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            throw new RuntimeException(&quot;Timer 任务1&quot;);
        }
    }, 60000);
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;Timer 任务2:\t\t&quot; + new Date());
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-text">Start:            Sun Oct 08 11:53:05 CST 2017
Exception in thread &quot;Timer-0&quot; java.lang.RuntimeException: Timer 任务1
    at main.Main$1.run(Main.java:32)
    at java.util.TimerThread.mainLoop(Timer.java:555)
    at java.util.TimerThread.run(Timer.java:505)
</code></pre>

<p>可以看到，任务1抛出的运行时异常导致整个Timer线程崩溃，任务2自然也没有执行。</p>

<h3 id="toc_9">ScheduledThreadPoolExecutor</h3>

<p>ScheduledThreadPoolExecutor中对异常的处理实际上是ThreadPoolExecutor类完成的，ThreadPoolExecutor在任务运行时对异常做了捕获，并且将异常传入了afterExecute()方法：</p>

<pre class="line-numbers"><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService {
    final void runWorker(Worker w) {
        ...
        Throwable thrown = null;
        try {
            task.run();
        } catch (RuntimeException x) {
            thrown = x; throw x;
        } catch (Error x) {
            thrown = x; throw x;
        } catch (Throwable x) {
            thrown = x; throw new Error(x);
        } finally {
            afterExecute(task, thrown);
        }
        ...
    }
}
</code></pre>

<p>我们来验证一下：</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();

    service.schedule(() -&gt; {
        throw new RuntimeException(&quot;Executor 任务1&quot;);
    }, 60, TimeUnit.SECONDS);
    service.schedule(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Executor 任务2:\t&quot; + new Date());
    }, 60, TimeUnit.SECONDS);
}
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-text">Start:            Sun Oct 08 11:33:35 CST 2017
Executor 任务2:    Sun Oct 08 11:34:36 CST 2017
</code></pre>

<p>可以看到这里虽然任务1抛出了运行时异常，但由于线程池内部完善的异常处理机制，任务2得以成功执行。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871379.html">
                
                  <h1>Android 四种启动模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>此博文用来介绍一下Activity的四种启动模式和应用的场景。</p>

<p>主要是对于Android Activity启动模式的梳理。</p>

<h2 id="toc_0">返回栈</h2>

<p>首先，在介绍之前，我们需要有一个返回栈的概念。栈，是一种数据结构，遵循的是先进后出的规则，而无论是什么APP，里面的N个Activity最终都会被压入栈（或弹出栈中），而与我们进行交互的就是处于栈顶的Activity，在这里就需要介绍一个返回栈的概念。上一张图。</p>

<p><figure><img src="media/15561207871379/15713366435881.png" alt=""/></figure></p>

<p>相信这张图片很清楚的说明，入栈的方式，所谓先进后出就是现在我们假设栈里面已经有abcd四个Activity了，并且都市默认的standard方式启动的。所谓先进后出就是，当我们不断按下back（返回键）的时候，后进去的d反而是最先谈栈的，a最后弹栈。</p>

<p><strong>压栈</strong>：a-&gt;b-&gt;c-&gt;d(入栈顺序)</p>

<p><strong>弹栈</strong>：b-&gt;c-&gt;b-&gt;a(弹出顺序)</p>

<p>先有一个返回栈的概念才能更好的进行分析。</p>

<h2 id="toc_1">为什么需要启动方式</h2>

<p>比如说，现在栈里面已经有四个activity abcd,这个时候的需求是需要到一个Activity a,如果我们只是使用默认的启动方式，那么就会形成abcda，当用户点击back按键的时候，弹出a，abcd。再按弹出d，abc。以此类推，然后又看到了a，是不是很烦人，而且这样的设计也的确很不人性化，所以设计了四种启动方式，来优化更好的体验，和满足特定场景下的用户需求。</p>

<h2 id="toc_2">四种启动的方式</h2>

<p><strong>(1) standard</strong>: 标准的方式，也是系统默认的方式，每次启动一个activity，都会去创建一个新的activity的实例，并让该实例出于activity的栈顶位置，与用户交互，不管该实例存在不存在。</p>

<pre class="line-numbers"><code class="language-java">button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Intent intent= new Intent(FirstActivity.this,FirstActivity.class);
        startActivity(intent);
    }
});
</code></pre>

<p>这是一个很典型的例子，就是由FirstActivity，跳转到FirstActivity，我们直观的思维会认为FirstActivity已经存在了，那么直接复用就好了啊，但是事实却不是这样子的。点击button两下，算上本身创建的FirstActivity，现在栈里面相当于有三个FirstActivity的实例，必须要点击三次返回键，才能回到桌面。这就是standard模式。</p>

<p><strong>(2) singleTop</strong> :栈顶复用模式，当一个新的Activity已经处于栈顶的时候，那么再次调用新的Activity将不会创建新的实例，因为新的Activity已经在栈顶了，可以直接复用。比如说是栈的情况是abcd，d的启动方式singleTop，那么当我们再次启动d的时候，并不会创建新的实例，还是abcd，因为栈顶已经是d了，如果是adbc那么创建以后就是adbcd。如果d是默认方式启动的话，得到的就是abcdd。</p>

<p><strong>(3) singleTask</strong> ：栈内复用的模式，只要activity在一个栈中，那么多次启动此activity都不会重新创建实例，比如说只要Activity以singleTask的方式启动，系统首先会去找寻是否有A需要的栈s，来存放A实例。如果没有s，就会创建栈s。然后做判断，如果s中有A，那么就直接把A置于栈顶，并且清空A上面的所有实例。如果A已经在栈顶，那么就直接复用A。如果存在S，就看S中是否有A的实例，没有A的实例就直接创建并且入栈，如果已经有A的实例并且没有处于栈顶，那就清楚A之前的所有实例，让A处于栈顶。举个例子(D都是以singleTask启动)：</p>

<ul>
<li>比如目前S1中的情况为ABC，D以singleTask的启动方式入栈，并且请求的任务栈为S2，那么很显然，并不存在S2，所以就会创建S2，并且把D压入S2中。S1：ABC，S2：D。</li>
<li>另一种情况，S1：ABC ，D请求的是S1，那么直接压入S1中。S1：ABCD.</li>
<li>S1：ADBC ，D请求的是S1，那么最终的S1：AD。因为栈内复用方式默认有一个clearTop的方法，会导致D上所有的实例出栈。让D置为栈顶。</li>
</ul>

<p><strong>(4) singleInstance</strong>: 单实例模式。这是一个加强版本的singleTask模式，它除了具有singleTask模式的所有特性之外，还加强的了一点，就是次方式启动的Activity只能单独的位于一个任务栈中，由于栈复用的特性，后续均不会创建新的Activity，除非这个任务栈被系统的销毁了。</p>

<h2 id="toc_3">特殊情况</h2>

<p>比如说现在有前台任务栈s1：AB(A底，B顶),后台任务栈S2:CD（都是以singleTask的方式启动）。当s1请求D入栈的时候，最终得到的是ABCD，但是如果只是请求C入栈的时候，得到的是ABC.</p>

<h2 id="toc_4">设置启动模式（两种）</h2>

<p><strong>第一种：Xml文件中配置</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;activity
    android:name=&quot;.FirstActivity&quot;
    android:label=&quot;hello My First Activity&quot;
    android:launchMode=&quot;singleTop&quot;/&gt;
</code></pre>

<p><strong>第二种：设置intent标志位的时候配置</strong></p>

<pre class="line-numbers"><code class="language-text">Intent intent= new Intent();
intent.setClass(FirstActivity.this,FirstActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
</code></pre>

<p>第二种的优先级方式是高于第一种的，当两种都存在的时候，以第二种为准。</p>

<h2 id="toc_5">指定栈和获取当前的activity的栈ID</h2>

<p>指定栈就是在设置activity的时候指定taskAffinity的属性，要求一个字符串，用.来分包，如果不写，栈就是默认的包名。在这里我指定为了，yanshui.site.task01配合上singleTask使用</p>

<pre class="line-numbers"><code class="language-text">&lt;activity
    android:name=&quot;.FirstActivity&quot;
    android:label=&quot;hello My First Activity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;yanshui.site.task01&quot;/&gt;
</code></pre>

<pre class="line-numbers"><code class="language-java">//当你想要知道你当前的activity处于栈的id的时候直接在该activity中调用此方法即可。
Log.d(TAG, &quot;task id is &quot;+getTaskId());
</code></pre>

<h2 id="toc_6">使用场景</h2>

<ul>
<li>Standard 默认启动方式，每次都会创建一个新的实例，如果开发中需要就使用。但应该注意具体的情况，优化设计体验。</li>
<li>singleTop 栈顶复用，适合接受推送消息的展示页。某些本应只展示一个的场景，比如一下子收到一堆推送消息，不能每个都弹出来吧。但凡是这样的都行。优酷的推荐视频，电商app推送一个活动。每次只是显示第一条消息。</li>
<li>singleTask 栈复用模式适合程序入口，不需要启动后activity的是的，只能用在启动页了吧，首页，这种只允许有一个instance，如果有其他就移除掉它顶上的。从这个Activity进入的其他activity都抛弃掉了。用户要再操作一次。</li>
<li>singleInstance 栈单实例模式，需要一个activity提供给多有的应用程序访问的，比如说闹钟，响过一次以后，不再提醒，然后就不会再响了。</li>
</ul>

<h2 id="toc_7">标志位</h2>

<ul>
<li><p>FLAG_ACTIVITY_NEW_TASK(xml中指定为singleTask)</p></li>
<li><p>FLAG_ACTIVITY_SINGLE_TOP(xml中指定为singleTop)</p></li>
</ul>

<p>​</p>

<h2 id="toc_8">简单小结一下</h2>

<h3 id="toc_9">使用方式：</h3>

<p>standard：怎么样都要创建<br/><br/>
singleTop：顶上不是target Activity，new一个<br/><br/>
singleTask：顶上不是target Activity，移除target之上的，把自己变成top。<br/><br/>
singleInstance：开辟私有的task，完全独立于程序的其他activity的task。  </p>

<h3 id="toc_10">使用场景：</h3>

<p>standard：普通activity<br/><br/>
singleTop：要展示推送过来的消息<br/><br/>
singleTask：程序入口等启动页面<br/><br/>
singleInstance：完全独立的，类似闹钟的提示  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871139.html">
                
                  <h1>Android-Fragment懒加载</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">生命周期</h2>

<p>附上生命周期，帮助下面的学习。</p>

<p><figure><img src="media/15561207871139/15713365181753.png" alt=""/></figure></p>

<h2 id="toc_1">何为懒加载</h2>

<p>Fragment 的 UI 对用户可见时才加载数据</p>

<h2 id="toc_2">为什么需要</h2>

<ul>
<li>需求要求，我们一般是等数据加载完毕之后才会初始化UI，但是可能需求会先让UI显示，再加载数据</li>
<li>与ViewPager搭配使用的时候，ViewPager有缓存机制，比如三个页面，0,1,2，当我们处于1页面的时候0,2也都会加载好，如果数据量较大的话，体验会很差</li>
</ul>

<h2 id="toc_3">实现原理</h2>

<p>核心的点是判断UI的可见，Fragment提供了一个setUserVisibleHint(boolean isVisibleToUser)方法可以用来判断；</p>

<h3 id="toc_4">setUserVisibleHint方法</h3>

<ul>
<li>单个 Fragment，setUserVisibleHint 是不会被调用的，只有该 Fragment 在 ViewPager 里才会被调用</li>
<li>执行顺序：setUserVisibleHint 方法在Fragment的生命周期函数之前执行一次，此时isVisibleToUser是false，后续还会执行一次，此时isVisibleToUser是true，但是这次的时间是不确定的 。参考官方note说明</li>
</ul>

<p><figure><img src="media/15561207871139/15713365285264.png" alt=""/></figure></p>

<h2 id="toc_5">实现代码</h2>

<pre class="line-numbers"><code class="language-java">public class FriendFragment extends Fragment {

    private boolean isVisible;
    // 标志位，标志已经初始化完成，防止空指针的异常
    private boolean isViewCreated;

    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
        super.onCreateView(inflater, container, savedInstanceState);
        isViewCreated = true;
        View chatView = inflater.inflate(R.layout.activity_tab_friend, container,false);
        return chatView;
    }


    @Override
    public void setUserVisibleHint(boolean isVisibleToUser) {
        super.setUserVisibleHint(isVisibleToUser);
              Log.e(&quot;hhp&quot;, &quot;setUserVisibleHint: isVisibleToUser--&quot;+isVisibleToUser+&quot;---isViewCreated---&quot;+isViewCreated );
        if (isVisibleToUser &amp;&amp; isViewCreated) {
            isVisible = true;
            lazyLoad();
        }else {
            isVisible = false;
        }
    }

    private void lazyLoad() {
        if (!isVisible || !isViewCreated) {
            return;
        }
        getData();
    }

    private void getData() {
        //加载数据
    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        if (getUserVisibleHint()) {
            getData();
        }
    }
}
</code></pre>

<h3 id="toc_6">几点说明</h3>

<p>分析两种情况：</p>

<p>1.进来就加载的这个Fragment，此时isVisibleToUser 和isViewCreated 两个标志位的值如下</p>

<p><figure><img src="media/15561207871139/15713365395269.png" alt=""/></figure></p>

<p>，无法加载数据 ，所以需要在onActivityCreated方法中调用加载数据</p>

<p>2.进来加载的不是这个Fragment，当该Fragment被缓存的时候，调用onActivityCreated方法getUserVisibleHint()值是false，不调用getData()方法；同理，isVisibleToUser和isViewCreated也是false，也不会调用getData()方法；滑动到该Fragment的时候，onActivityCreated方法不会再次执行，isVisibleToUser和isViewCreated都变为true，调用getData()方法加载数据。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871067.html">
                
                  <h1>Android App性能优化全方面解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">内存优化</h2>

<p>关于性能优化我们可以不知道其他的，但一定要知道内存优化。因为内存泄漏可以Android的常客。那么什么是内存泄漏呢？内存不在GC的掌控范围之内了。那么java的GC内存回收机制是什么？某对象不在有任何引用的时候才会进行回收。那么GC回收机制的原理是什么？又或者说可以作为GC　Root引用点的是啥？或许有人听不懂我在讲啥。我们先来看张图。</p>

<p><figure><img src="media/15561207871067/15713656808791.png" alt=""/></figure></p>

<p>当我们向上寻找，一直寻找到GC Root的时候，此对象不会进行回收，例如，一个Activity。那么如果我们向上寻找，直到找到GC Root对象的时候，就说明它是不可以回收的，例如，我定义了一个int a；但是这个数据，我整个页面或者说整个项目都没有用到，则这个对象会被GC掉。</p>

<h3 id="toc_1">GC的引用点</h3>

<ul>
<li>java栈中引用的对象</li>
<li>方法静态引用的对象</li>
<li>方法常量引用的对象</li>
<li>Native中JNI引用的对象</li>
<li>Thread——“活着的”线程</li>
</ul>

<h3 id="toc_2">如何判断</h3>

<p>那么我们如何判断一个对象是一个垃圾对象，可以讲他进行回收呢？举了小例子教你们如何区分：</p>

<blockquote>
<p>一般在学校吃饭，我们有两种情况，第一：吃完饭就直接走人，碗筷留给阿姨来收拾处理。<br/>
第二：吃完之后把碗筷放到收盘处直接进行回收。<br/>
但我们是个有素质的人，一般采用第二种情况，但根据想法，我们更倾向于第一种。<br/>
那么一般在饭店或者KFC中，都是第一种情况。<br/>
那么此时，问题来了，如果我已经吃完饭，然后我并没有离开饭店，做在位置上和朋友吹吹牛逼，谈谈理想，聊聊人生。<br/>
那么桌上那一堆碗筷是收还是不收？讲道理是不能收的。虽然实际也是不能收的。因为顾客是上帝~~~</p>
</blockquote>

<p>So，我们如何判断一个对象是一个可回收的垃圾对象呢？这是我们的一个主观的判断。但是有种情况我们是必须要考虑到的，没错，就是内存过多无法释放的时候，会直接导致OOM。整个项目boom炸了。什么鬼？outofmemory。没错就是它。</p>

<h2 id="toc_3">内存溢出</h2>

<h3 id="toc_4">分析原因</h3>

<p>我们需要分析内存溢出的原因，我们先来看一张图： </p>

<p><figure><img src="media/15561207871067/15713656930534.png" alt=""/></figure></p>

<p>内存泄漏一般导致应用卡顿，极端情况会导致项目boom。Boom的原因是因为超过内存的阈值。 <br/>
原因主要有两方面：</p>

<ul>
<li>代码存在泄漏，内存无法及时释放导致oom（这个我们后面说）</li>
<li>一些逻辑消耗了大量内存，无法及时释放或者超过导致oom</li>
</ul>

<p>所谓消耗大量的内存的，绝大多数是因为图片加载。这是我们oom出现最频繁的地方。我前面有写过图片加载的方法，一个是控制每次加载的数量，第二，保证每次滑动的时候不进行加载，滑动完进行加载。一般情况使用先进后出，而不是先进先出。不过一般我们图片加载都是使用fresco或者Glide等开源库。 </p>

<p>我们来看下下面两张图： </p>

<p><figure><img src="media/15561207871067/15713657020079.png" alt=""/></figure></p>

<p><figure><img src="media/15561207871067/15713657095476.png" alt=""/></figure></p>

<p>对比两张图，我们可以在第一张的情况出现了oom情况，我们通过log打印发现，处理的好像没什么问题，换句话说，如果我不放那0.8M的图片。然后继续不停的操作同样会出现OOM，然而我们就蒙了。没什么图片加载怎么就这么崩掉了。</p>

<h3 id="toc_5">如何查看</h3>

<p>首先，我们确定我们项目或者某几个类里面是否存在内存溢出的问题。我们可以通过如下方法：</p>

<ul>
<li>Android–&gt;System Information–&gt;MemoryUsage查看Object里面是否有没有被释放的Views和Activity</li>
<li>命令行模式：adb shell dumpsys meminfo 包名 -d</li>
</ul>

<p>就那我公司的项目举例把。首先，我们在这边可以看到memory。CPU和net的使用情况。 </p>

<p><figure><img src="media/15561207871067/15713657215613.png" alt=""/></figure></p>

<p>我们找到Object。看看我们内存的消耗情况。 </p>

<p><figure><img src="media/15561207871067/15713657297064.png" alt=""/></figure></p>

<p>随便这么一看，尼玛蛋，1300左右的view和一个Activity。还有3个context。可怕。。可以理解为一个Activity里面使用了将近1300个view。。。想都不敢想。。。</p>

<p>我们可以通过看Memory Monitor工具。 检查一个一个的动作。（比如Activity的跳转）。反复多次执行某一个操作，不断的通过这个工具查看内存的大概变化情况。 前后两个内存变化增加了不少。</p>

<p>我们可以更仔细的查找泄漏的位置，在AS里面使用 Heap SnapShot工具（堆栈快照）。如图所示： </p>

<p><figure><img src="media/15561207871067/15713657375160.png" alt=""/></figure></p>

<p>我们点击后，他会进行一段时间的监控，然后会生成一个文件。我们点击我们package tree view。 </p>

<p><figure><img src="media/15561207871067/15713657516723.png" alt=""/></figure></p>

<p>我们找到自己项目的包名。然后进行进一步的分析。首先看一下2个列表的列名到底指的什么。 </p>

<p>实例化对象的详细信息： </p>

<table>
<thead>
<tr>
<th style="text-align: center">名称</th>
<th style="text-align: center">意义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Total Count</td>
<td style="text-align: center">内存中该类的对象个数</td>
</tr>
<tr>
<td style="text-align: center">Heap Count</td>
<td style="text-align: center">堆内存中该类的对象个数</td>
</tr>
<tr>
<td style="text-align: center">Sizeof</td>
<td style="text-align: center">物理大小</td>
</tr>
<tr>
<td style="text-align: center">Shallow size</td>
<td style="text-align: center">该对象本身占有内存大小</td>
</tr>
<tr>
<td style="text-align: center">Retained Size</td>
<td style="text-align: center">释放该对象后，节省的内存大小</td>
</tr>
<tr>
<td style="text-align: center">depth</td>
<td style="text-align: center">深度</td>
</tr>
<tr>
<td style="text-align: center">Dominating Size</td>
<td style="text-align: center">管辖的内存大小</td>
</tr>
</tbody>
</table>

<p>我们来随便的看一下内存中的数量： </p>

<p><figure><img src="media/15561207871067/15713657609152.png" alt=""/></figure></p>

<p>这还是我们刚进手机，一个bean就被调用了这么多次。简直可怕。这个我们可以通过内存分析工具解决的。</p>

<h2 id="toc_6">内存分析工具</h2>

<p><strong>性能优化工具</strong>：</p>

<ul>
<li>Heap SnapShot工具</li>
<li>Heap Viewer工具</li>
<li>LeakCanary工具</li>
<li>MAT工具</li>
<li>TraceView工具（Device Monitor）</li>
</ul>

<p><strong>第三方分析工具</strong>：</p>

<ul>
<li>MemoryAnalyzer</li>
<li>GT Home</li>
<li>iTest <br/>
　　 <br/>
因为我没有这些工具，无法进行演示。</li>
</ul>

<h3 id="toc_7">注意事项</h3>

<ul>
<li><p>我们尽量不要使用Activity的上下文，而是使用application的上下文，因为application的生命周期长，进程退出时才会被销毁。所以，单例模式是最容易造成内存溢出的原本所在，因为单例模式的生命周期的应该和application的生命周期一样长，而不是和Activity的相同。</p></li>
<li><p>Animation也会导致内存溢出，为什么？因为我们是通过view来进行演示的，导致view被Activity持有，而Activity又持有view。最后因为Activity无法释放，导致内存泄漏。解决方法是在Activity的ondestory（）方法中调用Animation.cancle（）进行停止，当然一些简单的动画我们可以通过自定义view来解决。至少我现在已经很少使用Animation了。没有一个动画是自定义view解决不了的。如何有，那就是两个~~~。</p></li>
</ul>

<h2 id="toc_8">UI优化</h2>

<p>UI优化主要包括布局优化以及view的绘制优化。不急，我们接下来一个一个慢慢看~~。先说下UI的优化到底是什么？有些时候我们打开某个软件，会出现卡顿的情况。这就是UI的问题。那么我们想一下，什么情况会导致卡顿呢？一般是如下几种情况：</p>

<ul>
<li>人为在UI线程中做轻微耗时操作，导致UI线程卡顿；</li>
<li>布局Layout过于复杂，无法在16ms内完成渲染；</li>
<li>同一时间动画执行的次数过多，导致CPU或GPU负载过重；</li>
<li>View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；</li>
<li>View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；</li>
<li>内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；</li>
<li>冗余资源及逻辑等导致加载和执行缓慢；</li>
<li>臭名昭著的ANR；</li>
</ul>

<p>可以看见，上面这些导致卡顿的原因都是我们平时开发中非常常见的。有些人可能会觉得自己的应用用着还蛮OK的，其实那是因为你没进行一些瞬时测试和压力测试，一旦在这种环境下运行你的App你就会发现很多性能问题。</p>

<h2 id="toc_9">布局优化</h2>

<h3 id="toc_10">GPU绘制</h3>

<p>我们对于UI性能的优化还可以通过开发者选项中的GPU过度绘制工具来进行分析。在设置-&gt;开发者选项-&gt;调试GPU过度绘制（不同设备可能位置或者叫法不同）中打开调试后可以看见如下图（对settings当前界面过度绘制进行分析）： </p>

<p><figure><img src="media/15561207871067/15713657796585.png" alt=""/></figure></p>

<p><figure><img src="media/15561207871067/15713657891069.png" alt=""/></figure></p>

<p>这图看着太乱，我们来一张简洁明了的图： </p>

<p><figure><img src="media/15561207871067/15713657982645.png" alt=""/></figure></p>

<p>我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。</p>

<p>可以发现，开启后在我们想要调试的应用界面中可以看到各种颜色的区域，具体含义如下： </p>

<table>
<thead>
<tr>
<th style="text-align: center">颜色</th>
<th style="text-align: center">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">无色</td>
<td style="text-align: center">WebView等的渲染区域</td>
</tr>
<tr>
<td style="text-align: center">蓝色</td>
<td style="text-align: center">1* 过度绘制</td>
</tr>
<tr>
<td style="text-align: center">绿色</td>
<td style="text-align: center">2* 过度绘制</td>
</tr>
<tr>
<td style="text-align: center">淡红色</td>
<td style="text-align: center">3* 过度绘制</td>
</tr>
<tr>
<td style="text-align: center">红色</td>
<td style="text-align: center">4*(+) 过度绘制</td>
</tr>
</tbody>
</table>

<p>Overdraw有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。例如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色Overdraw区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。</p>

<p>如果布局中既能采用RealtiveLayout和LinearLayout，那么直接使用LinearLayout，因为Relativelayout的布局比较复杂，绘制的时候需要花费更多的CPU时间。如果需要多个LinearLayout或者Framelayout嵌套，那么可采用Relativelayout。因为多层嵌套导致布局的绘制有大部分是重复的，这会减少程序的性能。</p>

<h3 id="toc_11">GPU呈现模式分析</h3>

<p>我们依旧打开设置–&gt;开发者选项–&gt;GPU呈现模式分析–&gt;在屏幕上显示为条形图，如图所示： </p>

<p><figure><img src="media/15561207871067/15713658134293.png" alt=""/></figure></p>

<p><figure><img src="media/15561207871067/15713658216356.png" alt=""/></figure></p>

<p>当然，也可以在执行完UI滑动操作后在命令行输入如下命令查看命令行打印的GPU渲染数据（分析依据：Draw + Process + Execute = 完整的显示一帧时间 &lt; 16ms）：</p>

<p><code>adb shell dumpsys gfxinfo [应用包名]</code></p>

<p>随着界面的刷新，界面上会以实时柱状图来显示每帧的渲染时间，柱状图越高表示渲染时间越长，每个柱状图偏上都有一根代表16ms基准的绿色横线，每一条竖着的柱状线都包含三部分（蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间），只要我们每一帧的总时间低于基准线就不会发生UI卡顿问题（个别超出基准线其实也不算啥问题的）。就简单的看下我们公司项目刚启动的时候,超出基准线好多。 </p>

<p>突然就有那么一种想吐槽的感觉…..我记得之前我做了瘦身的优化，但是要让我做性能优化，我觉得应该没那么简单……..</p>

<h2 id="toc_12">代码优化</h2>

<p>Android Studio和IntellJ idead都有自带的代码检查工具。打开Analyze-&gt;Run Inspection by Name… –&gt;unused resource 点击开始检测，等待一下后会发现如下结果： </p>

<p><figure><img src="media/15561207871067/15713658334886.png" alt=""/></figure></p>

<p>我们还可以这样，将鼠标放在代码区点击右键-&gt;Analyze-&gt;Inspect Code–&gt;界面选择你要检测的模块-&gt;点击确认开始检测，等待一下后会发现如下结果： </p>

<p><figure><img src="media/15561207871067/15713658538715.png" alt=""/></figure></p>

<p>当然，我这只是截取了少一部分，我们看下下面那个提示：@param v tag description is missing 。意味着v的类型缺少了，要么补上介绍，要么直接删除。</p>

<p>上面那两种方法是最容易找到代码缺陷以及无用代码的地方。所以尽情的入坑去填坑把~~</p>

<h2 id="toc_13">绘制优化</h2>

<p>那么什么是绘制优化？绘制优化主要是指View的Ondraw方法需要避免执行大量的操作。我将分为了2个方面。</p>

<ul>
<li>ondraw方法不需要创建新的局部对象，这是因为ondraw方法是实时执行的，这样会产品大量的临时对象，导致占用了更多内存，并且使系统不断的GC。降低了执行效率。</li>
<li>Ondraw方法不需要执行耗时操作，在ondraw方法里少使用循环，因为循环会占用CPU的时间。导致绘制不流畅，卡顿等等。Google官方指出，view的绘制帧率稳定在60dps，这要求每帧的绘制时间不超过16ms（1000/60)。虽然很难保证，但我们需要尽可能的降低。</li>
</ul>

<p>60dps是目前最合适的图像显示速度，也是绝大部分Android设备设置的调试频率，如果在16ms内顺利完成界面刷新操作可以展示出流畅的画面，而由于任何原因导致接收到VSYNC信号的时候无法完成本次刷新操作，就会产生掉帧的现象，刷新帧率自然也就跟着下降(假定刷新帧率由正常的60fps降到30fps，用户就会明显感知到卡顿)。So，前面我们说GPU的时候也谈到了这个。总的而言，感觉还是蛮重要的…..</p>

<h2 id="toc_14">网络优化</h2>

<p>线程是我们项目中不可缺少的重要部分，因为我们大多数数据都是从网络获取的。So，线程这个是必备用品。 <br/>
我们依旧可以通过Memory下面的Net进行网络的监听： </p>

<p><figure><img src="media/15561207871067/15713658679996.png" alt=""/></figure></p>

<h2 id="toc_15">ANR问题</h2>

<p>相信这个问题在座的各种没少遇到过，那么什么是ANR？application not responding。应用程序无响应。那么一般什么时候会出现ANR。Android官方规定：activity如果5s内无响应事件（屏幕触摸事件或者键盘输入事件）。BroadcastReceiver如果在10s内无法处理完成。Service如果20s内无法处理完成。这三种情况会导致ANR。用张简洁的图来介绍把。看起来方便~~ </p>

<p><figure><img src="media/15561207871067/15713658773357.png" alt=""/></figure></p>

<h2 id="toc_16">线程优化</h2>

<p>上面说的三种导致ANR的情况，绝大多数就是因为线程阻塞导致的。那么我们应该如何处理呢？Android系统为我们提供了若干组工具类来解决此问题。</p>

<ul>
<li><p><strong>Asynctask</strong>：为UI线程与工作线程之间进行快速处理的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的场景。</p></li>
<li><p><strong>HandlerThread</strong>：为某些回调方法或者等待某些执行任务的执行设置一个专属的线程，并提供线程任务的调度机制。</p></li>
<li><p><strong>ThreadPool</strong>：把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</p></li>
<li><p><strong>IntentService</strong>：适合执行由Ui触发的后台任务。并可以把这些任务执行的情况通过一定的机制反馈给UI。</p></li>
</ul>

<p>网络请求耗时会给用户带来卡顿的产品体验，虽然可以使用Loading提升用户体验，但属于治标不治本。例如，当网络差的时候我们公司的项目一个loading就是10多s。甚至更多…..我就记得我当时面试之前下了一次我们公司的项目，因为网差的问题…一个loading一分多钟。。当时砸手机的冲动都有了，别说卸软件了….</p>

<p>一般多线程的情况我们可以通过Asynctask处理。（这玩意我真没怎么用过- -）我前面有说过annotation。这是google官方推出的注解。比bufferknife强大很多。这个可以快捷方便的处理多线程而且不会导致线程阻塞，而且你也可以控制线程的顺序，例如我要执行完线程A后，根据线程A的某个参数来执行线程B。以此类推…..</p>

<p>至于线程池么，最多的还是要说道图片加载了~~。图片加载用三方就行了~想看详细介绍，我前面有说，当然除了这个还有下载操作。这就和IntentService有关联了。一般下载我很少涉及到。。用过几次android原生的downloadmanager。。感觉略坑。</p>

<h2 id="toc_17">KO网络优化</h2>

<p>现在讲网络优化的重点了…重点..重点…，一般用到网最最最主要的是什么？时间！！速度！！成功率！！，时间！！速度！！成功率！！，时间！！速度！！成功率！！重要的事说三遍哈。</p>

<h3 id="toc_18">图片处理</h3>

<p>这已经不是第一次在此文提到图片了。可见图片的重要性！！</p>

<ul>
<li>使用WebP格式；同样的照片，采用WebP格式可大幅节省流量，相对于JPG格式的图片，流量能节省将近 25% 到 35 %；相对于 PNG 格式的图片，流量可以节省将近80%。最重要的是使用WebP之后图片质量也没有改变。So，去和后台的小伙伴们商量吧~~</li>
<li>使用缩略图，我在前面写图片加载有说过，就是控制他的inside和option。然后进行图片缩放。压缩？讲道理….我并不知道网络图片怎么压缩，but，我会缩放啊~~反正也不会失真。啦啦啦~咬我啊？</li>
</ul>

<h3 id="toc_19">网络请求处理</h3>

<p>我们可以对服务端返回数据进行缓存，设定有效时间，有效时间之内不走网络请求，减少流量消耗。对网络的缓存可以参见HttpResponseCache。</p>

<p>在某些情况，我们尽量少使用GPS定位，如果条件允许，尽可能使用网络定位。</p>

<p>下载、上传，我们尽可能使用断点，说个简单的，我在公司，准备下一个500M的游戏，但是下到200M的时候我下班了，此时没有了无线网，我们可以回家后用无线继续下载。So，断点续传，断点下载也是我们的必修课~，所以我前面单独提了一篇断点续传的文章。</p>

<p>刷新数据时，尽可能使用局部刷新，而不是全局刷新，第一、界面会闪屏一下，网差的界面直接白屏一段时间也不是不可能。第二、流量的使用！！我又要拿我们公司项目搞事情了。一个闪屏的缓存60+M。。。没错，就是60+M。简直可怕，我清个3、5次缓存，在打开个3、5次。好了，2分钟时间，我一个月流量就没了。。。So，我前面提到的网络缓存很重要，至于会不会加在项目中，我还是要看了在说- - 一个不小心，整个项目炸了都有可能。。。</p>

<h2 id="toc_20">启动优化</h2>

<p>众所周知，一个好的产品，除了功能强大，好的性能也必不可少。有调查显示，近50%的受访者因为apk太大而拒绝使用，近40%的受访者会因为APP性能差而卸载，性能也是造成APP用户沮丧的头号原因。</p>

<p>安卓应用的启动方式分为三种：冷启动、暖启动、热启动，不同的启动方式决定了应用UI对用户可见所需要花费的时间长短。顾名思义，冷启动消耗的时间最长。基于冷启动方式的优化工作也是最考验产品用户体验的地方。谈及优化之前，我们先看看这三种启动方式的应用场景，以及启动过程中系统都做了些什么工作。</p>

<h3 id="toc_21">冷启动</h3>

<p>为什么说冷启动是耗时最长的。冷启动是在启动应用前，系统没有获取到当前app的activity、Service等等。例如，第一次启动app。又或者说杀死进程后第一次启动。那么对比其他两种方式。冷启动自然是耗时最久的。</p>

<p>应用发生冷启动时，系统一定会执行下面的三个任务：</p>

<ul>
<li>开始加载并启动应用</li>
<li>应用启动后，显示一个空白的启动窗口（启动闪屏页）</li>
<li>创建应用信息</li>
</ul>

<p>那么创建应用信息，系统就需要做一屁股的事：</p>

<ul>
<li>application的初始化</li>
<li>启动UI线程</li>
<li>创建Activity</li>
<li>导入视图（inflate view）</li>
<li>计算视图大小（onmesure view）</li>
<li>得到视图排版（onlayout view）</li>
<li>绘制视图（ondraw view）</li>
</ul>

<p>这其中有两个 creation 工作，分别为 Application 和 Activity creation。他们均在 View 绘制展示之前。所以，在应用自定义的 Application 类和 第一个 Activity 类中，onCreate() 方法做的事情越多，冷启动消耗的时间越长。</p>

<h3 id="toc_22">暖启动</h3>

<p>当应用中的 Activities 被销毁，但在内存中常驻时，应用的启动方式就会变为暖启动。相比冷启动，暖启动过程减少了对象初始化、布局加载等工作，启动时间更短。但启动时，系统依然会展示闪屏页，直到第一个 Activity 的内容呈现为止。</p>

<h3 id="toc_23">热启动</h3>

<p>相比暖启动，热启动时应用做的工作更少，启动时间更短。热启动产生的场景很多，常见如：用户使用返回键退出应用，然后马上又重新启动应用。</p>

<h3 id="toc_24">如何优化</h3>

<p>我们先对比下三种启动的时间对比：<br/><br/>
冷启动： </p>

<p><figure><img src="media/15561207871067/15713658903891.png" alt=""/></figure></p>

<p>暖启动 ： </p>

<p><figure><img src="media/15561207871067/15713658986268.png" alt=""/></figure></p>

<p>热启动： </p>

<p><figure><img src="media/15561207871067/15713659065674.png" alt=""/></figure></p>

<p>我们可以看到三者的明显的差距，一个冷启动将近一分钟，反正我是不想看，每次跑项目都好慢~那么我们应该怎么做？看到有些人介绍说改变项目的theme。把它改成launcher的theme。但我觉得，这种做测试的确没问题。但是一般项目都会有闪屏页。然后从闪屏跳转到首页。我们可以按照大多数的项目来改善。怎么说的，我们可以看到一般项目都有倒计时显示。也就是说倒计时结束就自动进入首页。或者可以直接跳过进入首页。也就是说我们可以通过此方法来进行，也就是说只要他倒计时结束，不管请求是否全部获取完我们都直接进入首页。我们可以在闪屏页进行一些必要的加载，例如用户信息，定位等等，那么至于其他的，我们可以进入主页进行预加载。就和热更新一样，在用户不知情的情况下，默默的更新bug。So，对于一些网络请求，例如广告之类的。我们可以通过此方法进行预加载。</p>

<p>我们还可以这样，闪屏页我们把他当作一个fragment嵌套在MainActivity中，那么我们可以在进入闪屏时直接预加载主页的view。倒计时我们把闪屏页remove掉直接显示首页。</p>

<p>通过上面的介绍，我们对启动优化有了一定的了解，其实总结的话很简单。就是减少耗时操作，总结如下：</p>

<ul>
<li>主线程中涉及到Shareperference能否在非UI线程执行。</li>
<li>Application的创建过程中尽量少的进行耗时操作。</li>
<li>减少布局的层次,并且生命周期回调的方法中尽量减少耗时的操作。</li>
</ul>

<h2 id="toc_25">电量优化</h2>

<p>有了UI优化、内存优化、代码优化、网络优化之后我们在来说说应用开发中很重要的一个优化模块—–电量优化。</p>

<h3 id="toc_26">耗电概念</h3>

<p>其实大多数开发者对电量优化的重视程度极低，其实提到性能优化想到的就是内存优化，但我们不能忽视其他的优化，电量优化其实还是必要的，例如爱奇艺、优酷等等的视频播放器以及音乐播放器。众所周知，音乐和视频其实是耗电量最大的。如果用户一旦发现我们的应用非常耗电，不好意思，他们大多会选择卸载来解决此类问题。为此，我们需要进行优化。</p>

<h3 id="toc_27">如何优化</h3>

<p>其实我们把上面那四种优化解决了，就是最好的电量优化。So，对于电量优化，我在此提一些建议：</p>

<ul>
<li>需要进行网络请求时，我们需先判断网络当前的状态。</li>
<li>在多网络请求的情况下，最好进行批量处理，尽量避免频繁的间隔网络请求。</li>
<li>在同时有wifi和移动数据的情况下，我们应该直接屏幕移动数据的网络请求，只有当wifi断开时在调用，因为，wifi请求的耗电量远比移动数据的耗电量低的低。</li>
<li>后台任务要尽可能少的唤醒CPU。（比方说，锁屏时，QQ的消息提示行就是唤醒了CPU。但是它的提示只有在你打开锁屏或者进行充电时才会进行提示。）</li>
</ul>

<h2 id="toc_28">优化总结</h2>

<p>性能优化是我们进阶的毕竟之路。So，我们必须要会，至于“会”到什么程度，就要看个人理解了。其实，上面介绍的只是性能问题的冰山一角，真正的优化，我们是在项目中总结出来的。但，我们不能一味的追求优化，就例如我，现在只是在进行优化的总结，而对于真正的实行，并没有开始，因为，优化是有风险的，一个不小心，整个项目都可能炸了。所以这就需要你的经验，以及各种总结，在改进行优化的地方先进行优化，看看效果如何，例如，UI的优化以及代码的优化。可以先拿一些网上的开源项目进行优化等等。最后，尽情的享受优化把~~~</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871029.html">
                
                  <h1>Android Launcher启动Activity的工作过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Launcher</h2>

<p>手机桌面也是一个App，每一个应用的icon都罗列在Launcher上，点击icon触发onItemClick事件，下面例如我们要启动「淘宝」这个App，首先我们要在清单文件定义默认启动的Activity信息。</p>

<pre class="line-numbers"><code class="language-markup">&lt;activity android:name=&quot;.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>然后Launcher获取到该信息之后，启动淘宝App</p>

<pre class="line-numbers"><code class="language-java">//该应用的包名
String pkg = info.activityInfo.packageName;
//应用的主activity类
String cls = info.activityInfo.name;

ComponentName componet = new ComponentName(pkg, cls);

Intent i = new Intent();
i.setComponent(componet);
startActivity(i);
</code></pre>

<p>启动Activity这一工作不管是相同应用的2个不同Activity的启动，或者是不同进程不同应用的Activity启动，都是由Activity大管家ActivityManagerService（简称AMS）全权管理，而他们之间的通讯就要用到Binder，通过Binder与AMS多次通讯，才能启动淘宝App。 </p>

<h2 id="toc_1">整体流程</h2>

<blockquote>
<p>通过对Android操作系统的学习可以提高我们对操作系统在技术实现上的理解，这对于加强开发人员的内功是很有帮助的。 <br/>
但是由于Android内部实现多数都比较复杂，在研究内部实现上应该更加侧重对整体流程的把握，而不能深入到代码细节不能自拔。</p>
</blockquote>

<ol>
<li>Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。</li>
<li>AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。</li>
<li>Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。</li>
<li>淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。</li>
<li>淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。</li>
<li>AMS通知淘宝绑定Application并启动MainActivity。</li>
<li>淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</li>
</ol>

<h3 id="toc_2">startActivityForResult</h3>

<p>我们从Activity的startActivity方法开始分析。<br/><br/>
<code>startActivity</code>方法有好几种重载方式，但它们最终都会调用<code>startActivityForResult</code>方法。</p>

<pre class="line-numbers"><code class="language-java">@Override
public void startActivity(Intent intent, @Nullable Bundle options) {
    if (options != null) {
        startActivityForResult(intent, -1, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        startActivityForResult(intent, -1);
    }
}
</code></pre>

<p>在<code>startActivityForResult</code>方法内，会调用<code>Instrumentation</code>的<code>execStartActivity</code>方法。</p>

<pre class="line-numbers"><code class="language-java">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) {
    ......
    Instrumentation.ActivityResult ar =mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
    ......
}
</code></pre>

<h3 id="toc_3">Instrumentation</h3>

<blockquote>
<p>Instrumentation从字面上来看是仪器盘的意思，具体到程序中是管理activity的一个工具类，包括创建和启动Activity，activity的生命周期方法都是由Instrumentation这个仪器来控制，一个进程中只用一个Instrumentation实例。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">/**
 *
 *
 * @param who The Context from which the activity is being started.
 * @param contextThread The main thread of the Context from which the activity
 *                      is being started.
 * @param token Internal token identifying to the system who is starting 
 *              the activity; may be null.
 * @param target Which activity is performing the start (and thus receiving 
 *               any result);
 *               may be null if this call is no`t being made form an activity.
 * @param intent The actual Intent to start.
 * @param requestCode Identifier for this request&#39;s result; less than zero 
 *                    if the caller is not expecting a result.
 * @param options Addition options.
 *
 */
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,Intent intent, int requestCode, Bundle options) {
    IApplicationThread whoThread = (IApplicationThread) contextThread;

    ......

    try {
        int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent,intent.resolveTypeIfNeeded(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null,requestCode, 0, null, options);

        //检查启动Activity的结果（抛出异常，例如清单文件未注册Activity）
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException(&quot;Failure from system&quot;, e);
    }
    return null;
}
</code></pre>

<p>我们截取了比较关键的代码片段来分析<code>Instrumentation</code>的<code>execStartActivity</code>方法，方法参数注释中也有对该方法的几个参数进行简单描述。下面我们来分析一下比较重要的2个参数，<code>contextThread</code>和<code>token</code>。 </p>

<h3 id="toc_4">IBinder contextThread</h3>

<p>在上一个方法中传入为<code>mMainThread.getApplicationThread()</code> <br/>
我们可以看到这是一个<code>IBinder</code>对象，说明它的作用就是用于进程间通讯的<code>Binder</code>对象。</p>

<blockquote>
<p>mMainThread实际上是ActivityThread对象。ActivityThread，就是主线程，也就是UI线程，它是在App启动时创建的，它代表了App应用程序。<br/><br/>
啥？ActivityThread代表了App应用程序，那Application类岂不是被架空了？其实，Application对我们App开发人员来说也许很重要，但是在Android系统中还真的没那么重要，他就是个上下文。Activity不是有个Context上下文吗？Application就是整个ActivityThread的上下文。</p>
</blockquote>

<p>我们找到<code>ActivityThread</code>文件，其实这个<code>getApplicationThread</code>方法获取的是内部类<code>ApplicationThread</code>对象 <br/>
而且<code>ApplicationThread</code>继承<code>ApplicationThreadNative</code></p>

<pre class="line-numbers"><code class="language-java">public final class ActivityThread {//没有继承或者实现其他类。

    final ApplicationThread mAppThread = new ApplicationThread();

    public ApplicationThread getApplicationThread()
    {
        return mAppThread;
    }

    //ActivityThread的内部类ApplicationThread 
    private class ApplicationThread extends ApplicationThreadNative {
    ......
    }

}
</code></pre>

<p>我们打开<code>ApplicationThreadNative</code>类(需要通过sdk的源码找到，具体路径为Sdk\sources\android-25(sdk版本)\android\app\ApplicationThreadNative)<br/><br/>
通过构造方法我们就很清晰的可以得知原来这个<code>ApplicationThreadNative</code>就是相当于AIDL通讯中的Stub，也就是服务端，<code>ApplicationThreadProxy</code>即AIDL通讯中的Proxy，也就是客户端。所以ApplicationThread是通讯的具体实现类。<br/><br/>
上面的介绍中我们也说过，Activity的启动实际上是多次进程间通讯的成果，看到这里我们就可以得出结论：<strong>ActivityThread通过内部类ApplicationThread来进行进程间通讯</strong></p>

<pre class="line-numbers"><code class="language-java">public abstract class ApplicationThreadNative extends Binder implements IApplicationThread {

    static public IApplicationThread asInterface(IBinder obj) {...}

    @Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {...}

    public IBinder asBinder(){return this;}

}

class ApplicationThreadProxy implements IApplicationThread {
    private final IBinder mRemote;

    public ApplicationThreadProxy(IBinder remote) {
        mRemote = remote;
    }

    ...
}
</code></pre>

<p><code>public interface IApplicationThread extends IInterface {...}</code></p>

<h3 id="toc_5">IBinder token</h3>

<p>追溯到参数起源，这个<code>token</code>对象，是在<code>Activity</code>的<code>attach</code>方法中传入的，也就是<code>Activity</code>的创建与关联时候(下面的内容会提到)传入的<code>Activity</code>信息。<br/><br/>
这也是个<code>Binder</code>对象，它代表了<code>Launcher</code>这个<code>Activity</code>，这里也通过<code>Instrumentation</code>传给AMS，AMS查询后，就知道是谁向AMS发起请求了。</p>

<pre class="line-numbers"><code class="language-java">//Activity

    private IBinder mToken;

    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {

        mToken = token;
}
</code></pre>

<blockquote>
<p><code>contextThread</code>和<code>token</code>这两个参数是伏笔，传递给AMS，以后AMS想反过来通知<code>Launcher</code>，就能通过这两个参数，找到<code>Launcher</code>。</p>
</blockquote>

<h3 id="toc_6">startActivity</h3>

<p>在<code>Instrumentation</code>中，启动<code>Activity</code>真正的实现是由<code>ActivityManagerNative.getDefault()</code>的<code>startActivity</code>方法来完成。</p>

<pre class="line-numbers"><code class="language-java">int result = ActivityManagerNative.getDefault()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
</code></pre>

<blockquote>
<p>ActivityManagerService（下面简称AMS）继承自ActivityManagerNative（下面简称AMN），而AMN继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder，它是IActivityManager的具体实现，由于ActivityManagerNative.getDefault()其实是一个IActivityManager类型的Binder对象，因此它的具体实现是AMS。</p>
</blockquote>

<p>我们先看代码，捋一捋上述所说的关系。</p>

<pre class="line-numbers"><code class="language-java">public final class ActivityManagerService extends ActivityManagerNative {...}

public abstract class ActivityManagerNative extends Binder implements IActivityManager{...}

public interface IActivityManager extends IInterface {...}
</code></pre>

<p>首先我们来看这个命名方式，xxxNative，我们知道Stub持有Binder本地对象，Proxy持有的是Binder的代理对象。所以系统命名也是依据此因素（Native：本地的，土著的）作为命名规范。</p>

<pre class="line-numbers"><code class="language-java">/**
 * Retrieve the system&#39;s default/global activity manager.
 */
static public IActivityManager getDefault() {
    return gDefault.get();
}

private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {
    protected IActivityManager create() {
        IBinder b = ServiceManager.getService(&quot;activity&quot;);
        IActivityManager am = asInterface(b);
        return am;
    }
};

/**
 * Cast a Binder object into an activity manager interface, generating
 * a proxy if needed.
 */
static public IActivityManager asInterface(IBinder obj) {
    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);
    if (in != null) {
        return in;//同一进程，返回Stub本地对象。
    }
    return new ActivityManagerProxy(obj);//跨进程，返回代理对象。
}
</code></pre>

<blockquote>
<p>可以发现，在AMN 中，AMS这个Binder对象采用单例模式对外提供，Singleton是一个单例的封装类，第一次调用它的get方法时它会通过create方法来初始化AMS这个Binder对象，在后续的调用中则直接返回之前创建的对象（使用同一个AMS）。</p>
</blockquote>

<p>分析create方法，在IActivityManager内（相当于Client），通过应用程序中的0号引用，可以向SMgr获取服务端（Server）的Binder引用。<br/><br/>
AMN通过getDefault方法，从ServiceManager中获取AMS中Binder的引用对象，然后将它转换成ActivityManagerProxy对象（简称AMP），AMP就是AMS的代理对象。</p>

<p>类似AIDL中客户端的绑定代码，此时我们就可以通过ActivityManagerProxy（asInterface返回值为 IActivityManager），与AMS进行通讯。</p>

<pre class="line-numbers"><code class="language-java">//ActivityManagerProxy

public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {

    Parcel data = Parcel.obtain();//从Parcel池中获取Parcel对象（通讯载体），用来写入数据
    Parcel reply = Parcel.obtain();//如果方法有返回值，则写入返回值
    data.writeInterfaceToken(IActivityManager.descriptor);//Binder唯一标识

    //caller即上面提到的contextThread，AMS就可以通过它与Launcher通讯
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    data.writeString(callingPackage);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);

    //resultTo即上面提到的token,包含Launcher的Activity信息
    data.writeStrongBinder(resultTo);
    data.writeString(resultWho);
    data.writeInt(requestCode);
    data.writeInt(startFlags);

        ......
    //发送类型为START_ACTIVITY_TRANSACTION的请求给AMS，data包含Launcher和淘宝App的信息
    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
    reply.readException();

    //Instrumentation通过result来检查并抛出异常（Activity未在清单文件注册等）
    int result = reply.readInt();
    reply.recycle();
    data.recycle();
    return result;
}
</code></pre>

<p><figure><img src="media/15561207871029/15713362032570.png" alt=""/></figure></p>

<p>从上面的分析可以知道，Activity是由<code>AMN.getDefault()</code>来启动的，而<code>AMN.getDefault()</code>实际上是AMS，因此Activity的启动过程又转移到了AMS中，为了继续分析这个过程，只需要查看AMS的startActivity方法即可。</p>

<blockquote>
<p>Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。</p>
</blockquote>

<p><figure><img src="media/15561207871029/15713362127963.png" alt=""/></figure></p>

<h2 id="toc_7">AMS</h2>

<p>上个图，先通俗易懂的总结一下Activity启动的整体流程，对整体框架有一个大概认识。</p>

<p><figure><img src="media/15561207871029/15713362240020.png" alt=""/></figure></p>

<h3 id="toc_8">AMS分析</h3>

<p>再回顾一遍，通过对AMS 类的查看，我们可以知道AMS 也是一个Binder，并且它是<code>IActivityManager</code>的具体实现。</p>

<pre class="line-numbers"><code class="language-java">public final class ActivityManagerService extends ActivityManagerNative {...}

public abstract class ActivityManagerNative extends Binder implements IActivityManager{...}

public interface IActivityManager extends IInterface {...}
</code></pre>

<p>接着我们继续分析AMS的<code>startActivity</code>方法，这个阶段比较复杂和繁琐，一不小心就绕晕了，我们了解大致过程，不深入代码细节，对整体流程建立足够认识即可。</p>

<pre class="line-numbers"><code class="language-java">//AMS

@Override
public final int startActivity(IApplicationThread caller, String callingPackage,Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {

    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,resultWho, requestCode, startFlags, profilerInfo, bOptions,UserHandle.getCallingUserId());
}


@Override
public final int startActivityAsUser(IApplicationThread caller, String callingPackage,Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller(&quot;startActivity&quot;);
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);

    //7.0Acitivty启动管理类新增ActivityStarter(原本是ActivityStackSupervisor处理该过程)
    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,profilerInfo, null, null, bOptions, false, userId, null, null);
}
</code></pre>

<h3 id="toc_9">ActivityStarter</h3>

<pre class="line-numbers"><code class="language-java">//ActivityStarter

final int startActivityMayWait(IApplicationThread caller, int callingUid,String callingPackage, Intent intent, String resolvedType,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,IBinder resultTo, String resultWho, int requestCode, int startFlags,ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,Bundle bOptions, boolean ignoreTargetSecurity, int userId,IActivityContainer iContainer, TaskRecord inTask) {

            ``````

    //根据intent在系统中找到合适的应用的activity，如果有多个activity可选择，
    //则会弹出ResolverActivity让用户选择合适的应用。
    ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags,profileFile, profileFd, userId);

            ``````

    int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,aInfo, rInfo, voiceSession, voiceInteractor,resultTo, resultWho, requestCode, callingPid,callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,options, ignoreTargetSecurity, componentSpecified, outRecord, container,inTask);

            ``````

        return res;
    }



    //在startActivityLocked方法里，对传过来的参数做一些校验，然后创建ActivityRecord对象，再调用startActivityUnchecked(7.0前是startActivityUncheckedLocked)方法启动Activity。
   final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,String callingPackage, int realCallingPid, int realCallingUid, int startFlags,ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,TaskRecord inTask) {
        int err = ActivityManager.START_SUCCESS;

        ``````
        //创建ActivityRecord对象
        //ActivityRecord  :  在AMS中，将用ActivityRecord来作为Activity的记录者,每次启动一个Actvity会有一个对应的ActivityRecord对象，表示Activity的一个记录
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,requestCode, componentSpecified, voiceSession != null, mSupervisor, container,options, sourceRecord);

        ``````

        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,
                true, options, inTask);


        //此处将通知ActivityStarter, Activity对应的Task被移动到前台
        postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);

        return err;
    }
</code></pre>

<blockquote>
<p>在startActivityLocked方法里，对传过来的参数做一些校验，然后创建ActivityRecord对象，再调用startActivityUnchecked方法启动Activity。<br/>
startActivityUnchecked方法负责调度ActivityRecord和Task，理解该方法是理解Actvity启动模式的关键。<br/>
startActivityUnchecked方法调度task的算法非常复杂，和当前回退栈，要启动的acitivity的启动模式以及taskAffinity属性，启动activity时设置的intent的flag等诸多要素相关，intent的flag就有很多种情况，故此算法非常复杂，需要阅读源码并结合特定启动情况才能理解。</p>
</blockquote>

<p>接下来调用ActivityStack的startActivityLocked将ActivityRecord加入到回退栈里</p>

<pre class="line-numbers"><code class="language-java">//ActivityStarter

    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {

            ``````
        //ActivityStack的startActivityLocked,不要搞混了。
        //同时调用WindowManager准备App切换相关的工作
        mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);


        if (mDoResume) {

            final ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked();
            if (!mTargetStack.isFocusable()
                    || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay
                    &amp;&amp; mStartActivity != topTaskActivity)) {
                // If the activity is not focusable, we can&#39;t resume it, but still would like to
                // make sure it becomes visible as it starts (this will also trigger entry
                // animation). An example of this are PIP activities.
                // Also, we don&#39;t want to resume activities in a task that currently has an overlay
                // as the starting activity just needs to be in the visible paused state until the
                // over is removed.

            } else {
                //最终调用ActivityStackSupervisor的resumeFocusedStackTopActivityLocked
                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                        mOptions);
            }

}
</code></pre>

<h3 id="toc_10">ActivityStackSupervisor</h3>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor

    boolean resumeFocusedStackTopActivityLocked() {
        return resumeFocusedStackTopActivityLocked(null, null, null);
    }

    boolean resumeFocusedStackTopActivityLocked(
            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {
        if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) {
        //待启动Activity对应的Task为前台Task时，调用该Task对应ActivityStack的resumeTopActivityUncheckedLocked函数
            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }
        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        if (r == null || r.state != RESUMED) {
        //否则只是调用当前前台栈的resumeTopActivityUncheckedLocked
            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        }
        return false;
    }
</code></pre>

<h3 id="toc_11">ActivityStack</h3>

<p>接着跟进ActivityStack</p>

<pre class="line-numbers"><code class="language-java">//ActivityStack


    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {

        ``````
        result = resumeTopActivityInnerLocked(prev, options);

        return result;
    }


    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {


        //mResumedActivity指向上一次启动的Activity(Launcher)
        if (mResumedActivity != null) {
            ``````

           //通知Launcher进入pause状态
            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);
        }
         if (pausing) {//Launcher已经暂停了
            ``````

            if (next.app != null &amp;&amp; next.app.thread != null) {
                //如果app已经启动过
                //调用淘宝(待启动)Activity所在进程的优先级，保证其不被kill
                mService.updateLruProcessLocked(next.app, true, null);
            }

        } 
        ``````

        if (next.app != null &amp;&amp; next.app.thread != null) {

        //如果Intent不为空，调用NewIntent方法传入Intent
        next.app.thread.scheduleNewIntent(next.newIntents, next.appToken, false);

        //假设淘宝App已经启动，点击Home键返回到Launcher,再次从Launcher启动淘宝(或者第三方启动已开启的App)
        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,
                        mService.isNextTransitionForward(), resumeAnimOptions);
        ``````

        } else {
        ``````
           //创建进程，冷启动Activity。或者已启动App，重新启动Activity
           mStackSupervisor.startSpecificActivityLocked(next, true, true);
        }

        return true;
    }
</code></pre>

<p>resumeTopActivityInnerLocked函数非常繁琐，但整体来讲应该只有两个比较关键的地方：</p>

<ol>
<li>判断是否已有Activity(mResumedActivity)启动（即Launcher，通过Launcher启动淘宝的），有则暂停该Activity</li>
<li>判断是否需要重新启动目标Activity，即Activity是否已经启动过。（例如保存在后台，应用切换）</li>
</ol>

<blockquote>
<p>2.AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br/><br/>
3.Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。</p>
</blockquote>

<h3 id="toc_12">创建进程</h3>

<p>接下来的操作就比较重要了，创建进程，启动Activity。</p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


    void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {
        // Is this activity&#39;s application already running?
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                r.info.applicationInfo.uid, true);

        if (app != null &amp;&amp; app.thread != null) {
            try {
                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0
                        || !&quot;android&quot;.equals(r.info.packageName)) {

                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                            mService.mProcessStats);
                }
                //目标Activity的App已经启动（存在ActivityThread），则重启Activity
                realStartActivityLocked(r, app, andResume, checkConfig);
                return;
            } catch (RemoteException e) {
               ``````
            }
        }

        //如果进程不存在，则通过zygote创建应用进程。
        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                &quot;activity&quot;, r.intent.getComponent(), false, false, true);
    }
</code></pre>

<p>从上面代码可以了解到startSpecificActivityLocked为启动Activity的两种不同情况</p>

<ul>
<li>例如从Launcher冷启动淘宝，则需要创建新进程，通过AMS调用Zygote(孕育天地)孵化应用进程。</li>
<li>如果淘宝App已经启动，例如从MainActivity跳转到LoginActivity，则通过realStartActivityLocked启动。</li>
</ul>

<p>因为我们开头以Launcher启动淘宝为例子，所以我们硬着头皮继续分析AMS创建进程以及Activity的绑定过程。 <br/>
上面分析到mService.startProcessLocked,到了这里我们直接看启动线程的方法，中间的过程实在是略复杂。</p>

<blockquote>
<p>4.淘宝App未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">//ActivityServiceManager

        //Process.java的start函数，将通过socket发送消息给zygote
        //zygote将派生出一个子进程，子进程将通过反射调用ActivityThread的main函数
        Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;,
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                    app.info.dataDir, entryPointArgs);
</code></pre>

<p>Zygote进程孵化出新的应用进程后，通过反射执行ActivityThread类的main方法。在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到AMS，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread

public static void main(String[] args) {
    ``````
    //准备主线程的Looper，下篇博文分析Handler,Looper
    Looper.prepareMainLooper();

    //创建当前进程的ActivityThread
    ActivityThread thread = new ActivityThread();

    //将该进程绑定到AMS
    thread.attach(false);

    if (sMainThreadHandler == null) {
    //保存进程对应的主线程Handler
        sMainThreadHandler = thread.getHandler();
    }

    ``````
    //进入主线程的消息循环
    Looper.loop();

    ``````
}

//上面说过，ApplicationThread是ActivityThread用来与AMS通讯的中介
final ApplicationThread mAppThread = new ApplicationThread();

private void attach(boolean system) {
    if (!system) {
        final IActivityManager mgr = ActivityManagerNative.getDefault();

        //调用AMS的attachApplication方法，将ApplicationThread对象绑定至ActivityManagerService
        //这样AMS就可以通过ApplicationThread代理对象控制应用进程

            mgr.attachApplication(mAppThread);
    } else {
        ``````
    }
}
</code></pre>

<p>至此，进程创建完毕，并且也有了主线程，剩下的便是启动Activity和关联context等初始化操作了。</p>

<blockquote>
<p>5.淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。</p>
</blockquote>

<h3 id="toc_13">AMS启动Activity小结</h3>

<p>至此通过下图总结一下在AMS启动Activity的大致流程，各个方法函数像一台机器上的不同零件，各尽其责，分工明确。 <br/>
虽然错综复杂，但是耦合性低，比如说启动模式需要优化，重新完善startActivityUnchecked方法函数即可。</p>

<p><figure><img src="media/15561207871029/15713362340361.png" alt=""/></figure></p>

<h3 id="toc_14">关联Activity</h3>

<p>在这个时候，虽然有了app进程，和主线程，但是仍是一副空壳。 <br/>
没有activity信息，没有关联上下文，这时候就要请出AMS来进行指挥。</p>

<p>因为主线程main入口通过attach方法将 ApplicationThread 发送给 AMS ，所以通过applicationThread这个桥梁来通知ActivityThread创建/关联和启动Activity。</p>

<pre class="line-numbers"><code class="language-java">//AMS


    @Override
    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            //获取applicationThread的进程id(也就是淘宝应用进程)
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }
</code></pre>

<p>通过Binder获取proxy（ApplicationThread ）方的进程id，也就是获取目标(淘宝)进程的Pid。</p>

<pre class="line-numbers"><code class="language-java">//Binder


    /**
     * Return the ID of the process that sent you the current transaction
     * that is being processed.  This pid can be used with higher-level
     * system services to determine its identity and check permissions.
     * If the current thread is not currently executing an incoming transaction,
     * then its own pid is returned.
     */
    public static final native int getCallingPid(); 
</code></pre>

<p>接下来重点分析attachApplicationLocked方法</p>

<pre class="line-numbers"><code class="language-java">//AMS


    private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {

        // Find the application record that is being attached...  either via
        // the pid if we are running in multiple processes, or just pull the
        // next app record if we are emulating process with anonymous threads.
        ProcessRecord app;
        if (pid != MY_PID &amp;&amp; pid &gt;= 0) {
            synchronized (mPidsSelfLocked) {
                app = mPidsSelfLocked.get(pid);
            }
        } else {
            app = null;
        }

        //因为进程由AMS启动，所以在AMS中一定会有ProcessRecord（进程记录）
        //如果没有ProcessRecord，则需要杀死该进程并退出
        if (app == null) {
            ``````
            return false;
        }

        // If this application record is still attached to a previous
        // process, clean it up now.
        if (app.thread != null) {
            //如果从ProcessRecord中获取的IApplicationThread不为空，则需要处理该IApplicationThread
            //因为有可能此Pid为复用，旧应用进程刚释放，内部IApplicationThread尚未清空，
            //同时新进程又刚好使用了此Pid
            handleAppDiedLocked(app, true, true);
        }


        //创建死亡代理（进程kill后通知AMS）
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);

        //进程注册成功，移除超时通知
        mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);

        ``````
        try {
            //******绑定Application******
            thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode,
                    mBinderTransactionTrackingEnabled, enableTrackAllocation,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat,
                    getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked());

            updateLruProcessLocked(app, false, null);
        } catch (Exception e) {

            ``````
            //bindApplication失败后，重启进程
            startProcessLocked(app, &quot;bind fail&quot;, processName);
            return false;
        }

        try {
            //******启动Activity(启动淘宝MainActivity)******
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;//didSomething表示是否有启动四大组件
            }
        } catch (Exception e) {
            badApp = true;
        }

        ``````
        //绑定service和Broadcast的Application


        if (badApp) {
            //如果以上组件启动出错，则需要杀死进程并移除记录
            app.kill(&quot;error during init&quot;, true);
            handleAppDiedLocked(app, false, true);
            return false;
        }

        //如果以上没有启动任何组件，那么didSomething为false
        if (!didSomething) {
            //调整进程的oom_adj值， oom_adj相当于一种优先级
            //如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”
            updateOomAdjLocked();
        }
        return true;
    }
</code></pre>

<p>在<code>attachApplicationLocked</code>中有两个比较重要的方法函数，分析到这里我们的文章也要进入尾声了。</p>

<ol>
<li>thread.bindApplication（…） : 绑定Application到ActivityThread</li>
<li>mStackSupervisor.attachApplicationLocked（app） : 启动Activity（7.0前为mMainStack.realStartActivityLocked()）</li>
</ol>

<h3 id="toc_15">bindApplication</h3>

<p>在上面我们说道，ActivityThread通过ApplicationThread与AMS进行通讯，所以上面的thread.bindApplication（...）方法，就应该是通过ApplicationThread进行传达。<br/><br/>
在ActivityThread的内部类ApplicationThread中，我们找到bindApplication方法</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread

    //内部类ApplicationThread
    private class ApplicationThread extends ApplicationThreadNative {

        public final void bindApplication(...一大堆参数...) {
            AppBindData data = new AppBindData();
            //给data设置参数...
            ``````

            sendMessage(H.BIND_APPLICATION, data);
        }
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
        Message msg = Message.obtain();
        //给msg设置参数
        ``````
        mH.sendMessage(msg);
    }
</code></pre>

<p>发送消息是通过H的<code>Handler</code>类来完成的，这个命名贼个性，很令人印象深刻。PS : 我怀疑是编写这个类的工程师词穷了…</p>

<pre class="line-numbers"><code class="language-java">    private class H extends Handler {
        public static final int LAUNCH_ACTIVITY         = 100;
        public static final int PAUSE_ACTIVITY          = 101;
        ``````
        public static final int RESUME_ACTIVITY         = 107;

        public static final int DESTROY_ACTIVITY        = 109;
        public static final int BIND_APPLICATION        = 110;
        public static final int EXIT_APPLICATION        = 111;

        ``````

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ``````  
                //绑定application
                case BIND_APPLICATION:
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);
                    AppBindData data = (AppBindData)msg.obj;
                    handleBindApplication(data);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                    break;

            }

        }

    }
</code></pre>

<p>可以看出，这个H类相当于ActivityThread和ApplicationThread的中介人，也就是拉皮条的。<br/><br/>
<code>ActivityThread</code>通过<code>ApplicationThread</code>与<code>AMS</code>通讯。<br/><br/>
<code>ApplicationThread</code>通过<code>H</code>与<code>ActivityThread</code>通讯，处理Activity事务。  </p>

<p>那么既然<code>H</code>、<code>ApplicationThread</code>都在<code>ActivityThread</code>类里，为何<code>ApplicationThread</code>还要通过Handler来发送消息？</p>

<ul>
<li>便于集中管理，方便打印Log日志等，H就是这其中的大管家。</li>
<li><code>ActivityThread</code>通过<code>ApplicationThread</code>和AMS进行进程间通信，AMS以进程通讯的方式来完成<code>ActivityThread</code>的请求后调用<code>ApplicationThread</code>中的<code>Binder</code>方法，然后<code>ApplicationThread</code>会向H发送消息，H收到消息后会将<code>ApplicationThread</code>中的逻辑切换到<code>ActivityThread</code>中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。<br/>
而且有一点要注意的是，这个<code>ActivityThread</code>并不是一个线程Thread，它是final类并且无继承或者实现其它类，它的作用就是在main方法内消息循环，处理主线程事务。（还需了解Looper及消息机制）</li>
</ul>

<p>言归正传，上面ApplicationThread给H发送BIND_APPLICATION标识，在H中，通过handleBindApplication处理application的绑定事务。</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread



        private void handleBindApplication(AppBindData data) {

           ``````
          //根据传递过来的ApplicationInfo创建一个对应的LoadedApk对象
          data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);//获取LoadedApk


          /**
          * For apps targetting Honeycomb or later, we don&#39;t allow network usage
          * on the main event loop / UI thread. This is what ultimately throws
          * {@link NetworkOnMainThreadException}.
          */
          //禁止在主线程使用网络操作
          if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB) {
              StrictMode.enableDeathOnNetwork();
          }
          /**
           * For apps targetting N or later, we don&#39;t allow file:// Uri exposure.
           * This is what ultimately throws {@link FileUriExposedException}.
           */
           //7.0引入Fileprovide
          if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.N) {
              StrictMode.enableDeathOnFileUriExposure();
          }

          ``````    
          //创建进程对应的Android运行环境ContextImpl
          final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);


          if ((InstrumentationInfo)ii != null) {
               ``````
          } else {
               //注意Activity的所有生命周期方法都会被Instrumentation对象所监控，
               //也就说执行Activity的生命周期方法前后一定会调用Instrumentation对象的相关方法
               mInstrumentation = new Instrumentation();
          }

          try {
             ``````
             Application app = data.info.makeApplication(data.restrictedBackupMode, null);
             mInitialApplication = app;


             //加载进程对应Package中携带的ContentProvider
             installContentProviders(app, data.providers);

             ``````        
             mInstrumentation.onCreate(data.instrumentationArgs);

             try {
                  //这里会调用Application的onCreate方法
                  //故此Applcation对象的onCreate方法会比ActivityThread的main方法后调用
                  //但是会比这个应用的所有activity先调用
                  mInstrumentation.callApplicationOnCreate(app);
              } catch (Exception e) {
                  ``````
              }
            } finally {
                StrictMode.setThreadPolicy(savedPolicy);
            }
        }
</code></pre>

<p>如上文所述，handleBindApplication的目的是让一个Java进程融入到Android体系中。 <br/>
因此，该函数中的代码主要进行以下工作：</p>

<ol>
<li>按照Android的要求，完成对进程基本参数的设置置，包括设置进程名、时区、资源及兼容性配置； <br/>
同时也添加了一些限制，例如主线程不能访问网络等。</li>
<li>创建进程对应的ContextImpl、LoadedApk、Application等对象，同时加载Application中的ContentProvider，并初始化Application。</li>
<li>使用Instrumentation监控Activity的生命周期。（一个进程对应一个Instrumentation实例）</li>
</ol>

<p>当完成上述工作后，新建的进程终于加入到了Android体系。</p>

<blockquote>
<p>6.AMS通知淘宝绑定Application并启动MainActivity。</p>
</blockquote>

<h2 id="toc_16">启动Activity</h2>

<h3 id="toc_17">attachApplicationLocked</h3>

<p>在上述代码AMS的<code>attachApplicationLocked</code>方法中，我们说道：</p>

<blockquote>
<p>在<code>attachApplicationLocked</code>中有两个比较重要的方法函数，分析到这里我们的文章也要进入尾声了。  </p>

<ol>
<li>thread.bindApplication（…） : 绑定Application到ActivityThread</li>
<li>mStackSupervisor.attachApplicationLocked（app） : 启动Activity</li>
</ol>
</blockquote>

<p>绑定了Application之后，我们就可以启动Activity(淘宝MainActivity)。 </p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


    boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {
        final String processName = app.processName;
        boolean didSomething = false;

        //ActivityStackSupervisor维护着终端中所有ActivityStack
        //此处通过轮询，找出前台栈顶端的待启动Activity
        for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) {
            ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
            for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) {
                final ActivityStack stack = stacks.get(stackNdx);
                if (!isFocusedStack(stack)) {
                    continue;
                }

                ActivityRecord hr = stack.topRunningActivityLocked();
                if (hr != null) {
                    //前台待启动的Activity与当前新建的进程一致时，启动这个Activity
                    if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid
                            &amp;&amp; processName.equals(hr.processName)) {
                        try {

                            //realStartActivityLocked进行实际的启动工作
                            if (realStartActivityLocked(hr, app, true, true)) {
                                didSomething = true;
                            }
                        } catch (RemoteException e) {

                        }
                    }
                }
            }
        }

        return didSomething;
    }
</code></pre>

<p>大概系统工程师也觉得这个启动过程贼鸡儿绕了，最终启动的方法命名为realStartActivityLocked，意味着告诉你，大伙儿不要搞晕了，这个就是最后启动Activity的方法了。<br/><br/>
最后我们直捣黄龙，在<code>ActivityStackSupervisor</code>方法中，我们找到如下代码</p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),
                    new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,
                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,
                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);
</code></pre>

<p>看到这里想必大伙儿都明白了，AMS最后通过ApplicationThread通知ActivityThread启动Activity，感觉这一切的通讯都像发电报一样，鬼斧神工出神入化，皆出架构师之目营心匠。<br/><br/>
那么到这里我们就能推算出接下来的老套路了<br/><br/>
ApplicationThread—&gt; H—&gt; ActivityThread—&gt; 最终启动Activity的方法。  </p>

<h3 id="toc_18">ActivityThread</h3>

<pre class="line-numbers"><code class="language-java">//ActivityThread


    //内部类ApplicationThread
    private class ApplicationThread extends ApplicationThreadNative {
        @Override
        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
                int procState, Bundle state, PersistableBundle persistentState,
                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,
                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {

            updateProcessState(procState, false);

            ActivityClientRecord r = new ActivityClientRecord();
            //设置参数
            ``````

            //从LAUNCH_ACTIVITY这个标识我们就可以知道，它就是用来启动Activity
            sendMessage(H.LAUNCH_ACTIVITY, r);
        }
    }

    private class H extends Handler {
        ``````

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                    //利用ApplicationInfo等信息得到对应的LoadedApk，保存到ActivityClientRecord
                    //ActivityClientRecord包含Activity相关的信息
                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ``````  
            }
        }
    }
</code></pre>

<pre class="line-numbers"><code class="language-java">//ActivityThread


private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ``````

    Activity a = performLaunchActivity(r, customIntent);
    if (a != null) {
        ``````
        handleResumeActivity(r.token, false, r.isForward,
                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);

        ``````
    } 
    ``````
}
</code></pre>

<p><code>handleLaunchActivity</code>方法里有有两个重要的函数调用,</p>

<ul>
<li>performLaunchActivity : 会调用Activity的onCreate,onStart,onResotreInstanceState方法</li>
<li>handleResumeActivity : 会调用Activity的onResume方法.</li>
</ul>

<blockquote>
<p>从上面的源码可以看出，performLaunchActivity方法最终完成了Activity对象的创建和启动过程，并且ActivityThread通过handleResumeActivity方法来调用被启动Activity的onResume这一生命周期方法。</p>
</blockquote>

<h3 id="toc_19">performLaunchActivity</h3>

<p><code>【performLaunchActivity】</code> 这个方法主要完成了如下几件事。【摘自Android开发艺术探索】</p>

<h4 id="toc_20">从ActivityClientRecord中获取待启动的Activity的组件信息。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


        ActivityInfo aInfo = r.activityInfo;
        if (r.packageInfo == null) {
            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                    Context.CONTEXT_INCLUDE_CODE);
        }

        ComponentName component = r.intent.getComponent();
        if (component == null) {
            component = r.intent.resolveActivity(
                mInitialApplication.getPackageManager());
            r.intent.setComponent(component);
        }

        if (r.activityInfo.targetActivity != null) {
            component = new ComponentName(r.activityInfo.packageName,
                    r.activityInfo.targetActivity);
        }
</code></pre>

<h4 id="toc_21">通过Instrumentation的newActivity方法使用类加载器创建Activity对象。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


        Activity activity = null;
        try {
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            ``````
        }
</code></pre>

<h4 id="toc_22">通过LoadedApk的makeApplication方法来创建Application对象。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


Application app = r.packageInfo.makeApplication(false, mInstrumentation);//r.packageInfo为LoadedApk对象
</code></pre>

<p>其实在我们上面的bindApplication中，我们就有介绍到通过<code>LoadedApk</code>创建Application，并且创建完毕后，通过<code>Instrumentation的callApplicationOnCreate</code>来调用<code>Application</code>的onCreate方法</p>

<pre class="line-numbers"><code class="language-java"> Application app = data.info.makeApplication(data.restrictedBackupMode, null);

    ``````
 mInstrumentation.callApplicationOnCreate(app);
</code></pre>

<p>所以第三步是为了判断Application是否为空，而且我们从makeApplication方法中也能看出如果Application已经被创建过了，那么就不会再重复创建了。</p>

<h4 id="toc_23">创建ContextImpl对象，并通过Activity的attach方法来完成一些重要数据的初始化。</h4>

<pre class="line-numbers"><code class="language-java">
                Context appContext = createBaseContextForActivity(r, activity);//创建ContextImpl对象

                ``````
                Window window = null;
                if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
</code></pre>

<blockquote>
<p>ContextImpl是一个很重要的数据结构，它是Context的具体实现，Context中的大部分逻辑都是由ContextImpl来完成的。ContextImpl来完成的。ContextImpl是通过Activity的attach方法来和Activity建立关联的，除此之外<strong>，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Window接收到外部输入事件后就可以将事件传递给Activity</strong>。</p>
</blockquote>

<h4 id="toc_24">调用Activity的onCreate方法</h4>

<p><code>mInstrumentation.callActivityOnCreate(activity, r.state);</code></p>

<p>由于Activity的onCreate已经被调用，这也意味着Activity已经完成了整个启动过程。</p>

<h4 id="toc_25">调用Activity的onStart,onResotreInstanceState方法</h4>

<pre class="line-numbers"><code class="language-java">        mInstrumentation.callActivityOnCreate(activity, r.state);

        ``````
        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
</code></pre>

<h2 id="toc_26">总结</h2>

<p>至此从Launcher启动Activity的工作过程整个流程已经阐述完毕了，通过这次分析，对启动Activity的来龙去脉有了大致的掌控，但是也留下了几个知识点尚未探索清晰。（越深入探索，越发现不足）</p>

<ul>
<li>Looper，Handler的工作机制（Android的消息机制）</li>
<li>Context 到底是什么</li>
<li>Window的内部机制又是怎样的</li>
</ul>

<p>如果是淘宝MainActivity启动LoginActivity呢？<br/><br/>
其实原理和上述过程大体一致，只是在<code>ActivityStackSupervisor</code>的<code>startSpecificActivityLocked</code>方法中，发现进程已经启动，直接调用<code>realStartActivityLocked</code>启动Activity。</p>

<p><figure><img src="media/15561207871029/15713362420977.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870919.html">
                
                  <h1>Android学习路线</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android学习路线从4个阶段来对Android的学习过程做一个全面的分析:Android初级、中级、高级以及资深工程师。<br/>
只针对Android应用开发，不针对Rom开发和逆向工程等。方便起见虚拟“小D”为成长人物进行描述。</p>

<h2 id="toc_1">初级工程师</h2>

<p>小D之前完全没接触过Android开发，对编程基础、数据结构、C语言都有一定基础，Java语法什么的也都掌握的比较好，并不会搞Android。 </p>

<p>首先需要购买一本Android入门的书籍（现在更推荐直接看视频教程结合网上教程动手练习），为了更快地学习Android，小D业余时间也都用来一边看书一边照着书中的例子敲代码，结果2周时间小D就把这本书学了一遍。看完这本书后对Android的历史、结构、代码规范等都有了一个大概的了解，可以写出一些简单的Activity。这个时候在小D眼里，Android开发很简单很好玩，通过在xml中摆放一些按钮文本框什么的就可以做一些界面了。</p>

<p>小D开始跟着他的技术导师做需求，一些简单的小需求不在话下了。突然有一天来了一个需求，该需求要求在Activity中为一个button加一个动画效果，小D慌了：“完全没接触过，书上也没有讲，怎么办呢？”小D冷静了下，搜索“Android 动画”，打开前几个链接，恍然大悟，照着网上的例子把需求给实现了。 </p>

<p>后来导师告诉他：“学好Android，官方文档是必须看的，既全面又权威”。然后小D如获至宝，花了一年时间把上面的guide和training都看了一遍，并且他还动手抄了几个小例子。</p>

<p>有一天，小D又需要做一个动画相关的需求，又搜索“Android 动画”，突然他楞了一下：”总不能每次写动画都要搜索吧！“，于是他在CSDN开了一个博客，把动画相关的知识点都写上去，为的是后面再写动画相关的代码就不用去搜了，事实如何呢？后面再写动画相关的代码，的确不用再去搜了，因为通过写一篇动画博客，他把动画相关的细节都已经记住了，这样他就可以不用再去参考任何文档了，后来小D还学会了把一些琐碎的不方便放在博客上的东西写到了笔记上面，什么时候忘了10秒钟以内都可以快速找回来，而不是花10分钟去再次搜索一遍。</p>

<p>总结：Android入门的时候，需要有一本入门书（或者视频教程），好好学习书中的内容，同时花一年时间把Android官方文档中的training和guide看一遍，同时通过写博客和记笔记的方式来做总结，建议让自己的每篇博客都有价值些。通过一年时间的学习，相信每个人都可以达到中级工程师的水平。</p>

<p>技术要求：</p>

<ul>
<li>基本知识点<br/>
比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术</li>
<li>书籍推荐<br/>
《第一行代码 Android》、《疯狂Android》</li>
</ul>

<h2 id="toc_2">中级工程师</h2>

<p>小D经过一年的努力学习终于成为Android中级工程师了。到了中级工程师，已经可以在公司里干很多体力活了，但是一些很重要的任务小D还不能一个人承担起来，这个时候小D需要学习的内容就很多了，如下所示：</p>

<ul>
<li>AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；</li>
<li>Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；</li>
<li>多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；</li>
<li>事件分发：弹性滑动、滑动冲突等；</li>
<li>玩转View：View的绘制原理、各种自定义View；</li>
<li>动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；</li>
<li>懂性能优化、熟悉mat等工具</li>
<li>懂点常见的设计模式</li>
</ul>

<h3 id="toc_3">学习方法</h3>

<p>阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。<br/>
如何阅读源码呢？这是个头疼的问题，但是源码必须要读。阅读源码的时候不要深入代码细节不可自拔，要关注代码的流程并尽量挖掘出对应用层开发有用的结论。另外仔细阅读源码中对一个类或者方法的注释，在看不懂源码时，源码中的注释可以帮你更好地了解源码中的工作原理，这个过程虽然艰苦，但是别无他法。<br/>
如何玩转自定义View呢？我们要透过现象看本质，更多地去关注自定义view所需的知识点：</p>

<ul>
<li>搞懂view的滑动原理</li>
<li>搞懂如何实现弹性滑动</li>
<li>搞懂view的滑动冲突</li>
<li>搞懂view的measure、layout和draw</li>
<li>然后再学习几个已有的自定义view的例子</li>
<li>最后就可以搞定自定义view了，所谓万变不离其宗</li>
</ul>

<p>大概再需要1-2年时间，即可达到高级工程师的技术水平。我个人认为通过《Android开发艺术探索》和《Android群英传》可以缩短这个过程为0.5-1年。注意，达到高级工程师的技术水平不代表就可以立刻成为高级工程师（受机遇、是否跳槽的影响），但是技术达到了，成为高级工程师只是很简单的事。</p>

<h3 id="toc_4">技术要求：</h3>

<ul>
<li>稍微深入的知识点<br/>
AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等</li>
<li>书籍推荐<br/>
《Android开发艺术探索》、《Android群英传》</li>
</ul>

<h2 id="toc_5">高级工程师</h2>

<p>小D成为了梦寐以求的高级工程师。这个时候小D的Android水平已经不错了，但是小D的目标是资深工程师，小D听说资深工程师月薪可以达到30k+。<br/>
为了成为Android资深工程师，需要学习的东西就更多了，并且有些并不是那么具体了，如下所示：</p>

<ul>
<li>继续加深理解”稍微深入的知识点“中所定义的内容</li>
<li>了解系统核心机制：
<ol>
<li>了解SystemServer的启动过程</li>
<li>了解主线程的消息循环模型</li>
<li>了解AMS和PMS的工作原理</li>
<li>能够回答问题”一个应用存在多少个Window？“</li>
<li>了解四大组件的大概工作流程</li>
<li>…</li>
</ol></li>
<li>基本知识点的细节
<ol>
<li>Activity的启动模式以及异常情况下不同Activity的表现</li>
<li>Service的onBind和onReBind的关联</li>
<li>onServiceDisconnected(ComponentName className)和binderDied()的区别</li>
<li>AsyncTask在不同版本上的表现细节</li>
<li>线程池的细节和参数配置</li>
<li>…</li>
</ol></li>
<li>熟悉设计模式，有架构意识</li>
</ul>

<h3 id="toc_6">学习方法</h3>

<p>这个时候已经没有太具体的学习方法了，无非就是看书、看源码和做项目，平时多种总结，尽量将知识融会贯通从而形成一种体系化的感觉。<br/><br/>
同时这个阶段对架构是有一定要求的，架构是抽象的，但是设计模式是具体的，所以一定要加强下设计模式的学习。关于设计模式的学习，推荐《Android 源码设计模式解析与实战》，既可以学习设计模式，又可能体会到Android源码中的设计思想。  </p>

<h3 id="toc_7">技术要求：</h3>

<ul>
<li>稍微深入的知识点</li>
<li>系统核心机制</li>
<li>基本知识点的细节</li>
<li>设计模式和架构</li>
<li>书籍推荐<br/>
《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》</li>
</ul>

<h2 id="toc_8">资深工程师</h2>

<p>更多了解不同业务的架构问题，内核源码设计原理，整理并开源自己的组件</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870883.html">
                
                  <h1>Android学习目录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="media/15561207870883/15713359653854.png" alt=""/></figure></p>

<h2 id="toc_0">基础知识</h2>

<p><figure><img src="media/15561207870883/15713359733510.jpg" alt=""/></figure></p>

<p><figure><img src="media/15561207870883/15713359818799.jpg" alt=""/></figure></p>

<p><figure><img src="media/15561207870883/15713359891037.jpg" alt=""/></figure></p>

<p><figure><img src="media/15561207870883/15713359971568.jpg" alt=""/></figure></p>

<p>{% post_link android-learning-path Android学习路线 %}  </p>

<p>{% post_link android-study Android学习资源 %}</p>

<h3 id="toc_1">Java基础</h3>

<p><figure><img src="media/15561207870883/15713360098241.jpg" alt=""/></figure></p>

<h4 id="toc_2">Java字符串(String、StringBuilder、StringBuffer)</h4>

<h4 id="toc_3">Java线程池(newFixedThreadPool、newSingleThreadExecutor、newCacheThreadPool)</h4>

<ul>
<li><p><code>newFixedThreadPool</code>：newFixedThreadPool,创建固定大小的线程池，poolCoreSize和maxPoolSize 相等，到达coreSize,则将新的任务放到缓存队列，有线程执行完毕，直接去取。</p></li>
<li><p><code>newSingleThreadExecutor</code>：newSingleThreadExecutor,创建一个单线程的线程池，核心池的大小和最大池大小都为1.</p></li>
<li><p><code>newCacheThreadPool</code>：newCacheThreadPool,无大小限制的线程池，提交一个任务就创建一个线程执行。</p></li>
</ul>

<h4 id="toc_4">Java集合</h4>

<p><strong>Collection</strong>:</p>

<ul>
<li>List:
<ul>
<li>LinkedList</li>
<li>ArrayList</li>
<li>Vector</li>
</ul></li>
<li>Set
<ul>
<li>HashSet</li>
<li>TreeSet</li>
</ul></li>
</ul>

<p><strong>Map</strong>:</p>

<ul>
<li>HashMap</li>
<li>TreeMap</li>
<li>HashTable</li>
</ul>

<h4 id="toc_5">Java内存模型</h4>

<p>Java 内存模型这一块非常重要，因为它涉及到我们程序的性能，我们需要知道，内存是如何分配的，成员变量、静态变量、局部变量、对象等各自分配到哪一个区：栈内存、堆内存</p>

<h3 id="toc_6">数据结构</h3>

<h3 id="toc_7">面向对象思想</h3>

<p>OOP的的三大特性：封装、继承、多态。</p>

<h3 id="toc_8">设计模式</h3>

<h4 id="toc_9">程序设计6大原则</h4>

<ul>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特法则</li>
<li>开闭原则</li>
</ul>

<h3 id="toc_10">Android Studio</h3>

<p>{% post_link android-studio-plugin Android Studio插件 %}  </p>

<p>{% post_link android-studio-keywords Android Studio快捷键 %}</p>

<h3 id="toc_11">Android SDK</h3>

<h3 id="toc_12">Activity</h3>

<p>{% post_link android-activity-launcher Android-启动Acivity的工作流程 %}</p>

<h3 id="toc_13">Service</h3>

<h3 id="toc_14">BroadcastReceiver</h3>

<h3 id="toc_15">ContentProvider</h3>

<h3 id="toc_16">StatusBar</h3>

<p>{% post_link android-statusbar Android-StatusBar详细学习 %}</p>

<h3 id="toc_17">Fragment</h3>

<h4 id="toc_18">DialogFragment</h4>

<p>{% post_link android-dialogfragment Android-DialogFragment详细学习 %}</p>

<h2 id="toc_19">UI</h2>

<p>{% post_link android-xml Android-XML参数详细了解 %}</p>

<h3 id="toc_20">Layout</h3>

<p>{% post_link android-layout Android-Layout详细学习 %}</p>

<h4 id="toc_21">FrameLayout</h4>

<h4 id="toc_22">LinearLayout</h4>

<h4 id="toc_23">TableLayout</h4>

<h4 id="toc_24">GridLayout</h4>

<h4 id="toc_25">RelativeLayout</h4>

<h4 id="toc_26">DrawerLayout</h4>

<h4 id="toc_27">SlidingPaneLayout</h4>

<h4 id="toc_28">CoordinatorLayout</h4>

<p>{% post_link android-coordinatorLayout Android-CoordinatorLayout %}</p>

<h3 id="toc_29">View</h3>

<p>{% post_link android-view-workflow Android-View的工作流程 %}</p>

<h4 id="toc_30">Widgets</h4>

<h5 id="toc_31">TextView</h5>

<h5 id="toc_32">EditText</h5>

<p>{% post_link android-edittext Android-EditText详细学习 %}  </p>

<p>{% post_link android-windowSoftInputMode Android-WindowSoftInputMode详细学习 %}  </p>

<h5 id="toc_33">Button</h5>

<h5 id="toc_34">RadioButton</h5>

<h5 id="toc_35">CheckBox</h5>

<h5 id="toc_36">Switch</h5>

<h5 id="toc_37">ToggleButton</h5>

<h5 id="toc_38">ImageButton</h5>

<h5 id="toc_39">ImageView</h5>

<p>{% post_link android-imageview Android-ImageView详细学习 %}</p>

<h5 id="toc_40">ProgressBar</h5>

<h5 id="toc_41">SeekBar</h5>

<h5 id="toc_42">RatingBar</h5>

<h5 id="toc_43">Spinner</h5>

<h5 id="toc_44">WebView</h5>

<h4 id="toc_45">Containers</h4>

<h5 id="toc_46">RadioGroup</h5>

<h5 id="toc_47">ListView</h5>

<h5 id="toc_48">GridView</h5>

<h5 id="toc_49">ExpandableListView</h5>

<h5 id="toc_50">ScrollVeiw</h5>

<h5 id="toc_51">TabHost</h5>

<h5 id="toc_52">SlidingDrawer</h5>

<h5 id="toc_53">Gallery</h5>

<h5 id="toc_54">VideoView</h5>

<h5 id="toc_55">DialerFilter</h5>

<h5 id="toc_56">RecyclerView</h5>

<p>{% post_link android-recyclerview Android-RecyclerView详细学习 %}  </p>

<h5 id="toc_57">CardView</h5>

<h5 id="toc_58">PopuWindow</h5>

<p>{% post_link android-popupwindow Android-PopupWindow详细学习 %}</p>

<h5 id="toc_59">DialogFragment</h5>

<h4 id="toc_60">Date&amp;Time</h4>

<h5 id="toc_61">TextClock</h5>

<h5 id="toc_62">AnalogClock</h5>

<h5 id="toc_63">Chronometer</h5>

<h5 id="toc_64">DatePicker</h5>

<h5 id="toc_65">TimePicker</h5>

<h5 id="toc_66">CalendarView</h5>

<h4 id="toc_67">Expert</h4>

<h5 id="toc_68">Space</h5>

<h5 id="toc_69">CheckedTextView</h5>

<h5 id="toc_70">QuickContactBadge</h5>

<h5 id="toc_71">ExtractEditText</h5>

<h5 id="toc_72">AutoCompleteTextView</h5>

<h5 id="toc_73">MultiAutoCompleteText</h5>

<h5 id="toc_74">NumberPicker</h5>

<h5 id="toc_75">ZoomButton</h5>

<h5 id="toc_76">ZoomController</h5>

<h5 id="toc_77">GestureOverlayView</h5>

<h5 id="toc_78">SurfaceView</h5>

<h5 id="toc_79">TexttureView</h5>

<h5 id="toc_80">StackView</h5>

<h5 id="toc_81">ViewStub</h5>

<p>{% post_link android-viewstub Android-ViewStub详细学习 %}</p>

<h5 id="toc_82">ViewAnimator</h5>

<h5 id="toc_83">ViewFlipper</h5>

<h5 id="toc_84">ViewSwitcher</h5>

<h5 id="toc_85">ImageSwitcher</h5>

<h5 id="toc_86">TextSwitcher</h5>

<h5 id="toc_87">AdapterViewFlipper</h5>

<h5 id="toc_88">ViewPager</h5>

<p>{% post_link android-viewpager Android-Viewpager详细学习 %}</p>

<h4 id="toc_89">Custom</h4>

<h5 id="toc_90">include</h5>

<h5 id="toc_91">fragment</h5>

<h5 id="toc_92">requestFocus</h5>

<h3 id="toc_93">Custom View</h3>

<h4 id="toc_94">extend system View</h4>

<h4 id="toc_95">combination View</h4>

<h4 id="toc_96">extend View</h4>

<p>{% post_link android-view Android-View详细学习 %}  </p>

<p>{% post_link android-draw Android自定义控件——绘图 %}  </p>

<h5 id="toc_97">ViewTreeObserver</h5>

<p>{% post_link android-getViewTreeObserver Android-getViewTreeObserver() %}</p>

<h5 id="toc_98">ColorFilter</h5>

<p>{% post_link android-colorfilter Android-ColorFilter详细学习 %}</p>

<h5 id="toc_99">Xfermode</h5>

<p>{% post_link android-xfermode Android-Xfermode详细学习 %}</p>

<h5 id="toc_100">Paint</h5>

<p>{% post_link android-paint Android-Paint详细学习 %}  </p>

<p>{% post_link android-paints Android-Paint详细学习 %}</p>

<h5 id="toc_101">Matrix</h5>

<p>{% post_link android-matrix Android-Matrix详细学习 %}  </p>

<h5 id="toc_102">Scroller</h5>

<p>{% post_link android-scroller Android-Scroller详细学习 %}</p>

<h5 id="toc_103">ViewConfiguration</h5>

<p>{% post_link android-viewconfiguration Android-ViewConfiguration解析 %}</p>

<h5 id="toc_104">MotionEvent</h5>

<p>{% post_link android-motionevent Android-MotionEvent解析 %}</p>

<h5 id="toc_105">VelocityTracker</h5>

<p>{% post_link android-velocitytracker Android-VelocityTracker详细学习 %}</p>

<h5 id="toc_106">SpannableString</h5>

<p>{% post_link android-spannablestring Android-SpannableString设置复合文本 %}</p>

<h3 id="toc_107">animation</h3>

<p>{% post_link android-animation Android动画详细学习 %}  </p>

<p>{% post_link android-activity-handoff-animation Android切换动画 %}</p>

<h4 id="toc_108">ViewAnimation</h4>

<h5 id="toc_109">TweenAnimation</h5>

<h5 id="toc_110">FrameAnimation</h5>

<h4 id="toc_111">PropertyAnimation</h4>

<h5 id="toc_112">ValueAnimator</h5>

<h5 id="toc_113">ObjectAnimator</h5>

<h5 id="toc_114">AnimatorSet</h5>

<h4 id="toc_115">VectorAnimation</h4>

<h5 id="toc_116">SVG</h5>

<h5 id="toc_117">VectorDrawable</h5>

<h5 id="toc_118">AnimatedVectorDrawable</h5>

<h3 id="toc_119">Resource</h3>

<h4 id="toc_120">assets</h4>

<h5 id="toc_121">AssetManager</h5>

<h4 id="toc_122">res</h4>

<h5 id="toc_123">anim</h5>

<h5 id="toc_124">animator</h5>

<h5 id="toc_125">color</h5>

<h5 id="toc_126">drawable</h5>

<h5 id="toc_127">interpolator</h5>

<h5 id="toc_128">layout</h5>

<h5 id="toc_129">menu</h5>

<h5 id="toc_130">raw</h5>

<h5 id="toc_131">values</h5>

<h6 id="toc_132">arrays</h6>

<h6 id="toc_133">attrs</h6>

<h6 id="toc_134">bools</h6>

<h6 id="toc_135">colors</h6>

<h6 id="toc_136">string</h6>

<h6 id="toc_137">styles</h6>

<h4 id="toc_138">OpenGL</h4>

<h4 id="toc_139">Bitmap</h4>

<h5 id="toc_140">BitmapFactory</h5>

<p>{% post_link android-bitmapfactory Android-BitmapFactory详细学习 %}</p>

<h2 id="toc_141">Material Design 系列</h2>

<h3 id="toc_142">Toolbar的使用</h3>

<p>{% post_link android-toolbar Android-ToolBar详细学习 %}</p>

<h3 id="toc_143">AppbarLayout+CollapsingToolbarLayout</h3>

<p>{% post_link android-appbarlayout-collapsingtoolbar-toolbar Android-AppBarLayout&amp;CollapsingToolbar&amp;Toolbar组合使用 %}  </p>

<p>{% post_link android-appbarlayout Android-AppBarLayout %}</p>

<h3 id="toc_144">Behavior 相关：</h3>

<ul>
<li>BottomSheetBehavior</li>
<li>BottomSheetDialog</li>
<li>SwipeDismissBehavior</li>
<li>自定义Behavior</li>
</ul>

<h3 id="toc_145">TextInputLayout + TextInputEditText</h3>

<h3 id="toc_146">TabLayout</h3>

<h3 id="toc_147">BottomNavigationView</h3>

<h3 id="toc_148">CardView 阴影卡片</h3>

<h3 id="toc_149">Snackbar , FloatActionButton</h3>

<h2 id="toc_150">通信</h2>

<h3 id="toc_151">Http</h3>

<h3 id="toc_152">Socket</h3>

<h3 id="toc_153">Bluetooth</h3>

<h3 id="toc_154">NFC</h3>

<h3 id="toc_155">Headset</h3>

<h3 id="toc_156">USB</h3>

<h2 id="toc_157">数据持久化</h2>

<h3 id="toc_158">Sqlite</h3>

<h4 id="toc_159">SQLiteOpenHelper</h4>

<h4 id="toc_160">ContentProvider</h4>

<h3 id="toc_161">File</h3>

<p>{% post_link android-save-method Android存储方式以及路径API %}</p>

<h4 id="toc_162">InternalStorage</h4>

<h4 id="toc_163">ExternalStorage</h4>

<h3 id="toc_164">SharedPreferences</h3>

<h2 id="toc_165">多线程</h2>

<p>{% post_link android-thread Android Thread %}  </p>

<h2 id="toc_166">性能</h2>

<p>{% post_link android-performance-optimize Android性能优化 %}</p>

<h3 id="toc_167">UI优化</h3>

<h4 id="toc_168">布局层次结构</h4>

<p>{% post_link android-view-performance-optimizing Android界面性能调优 %}</p>

<h4 id="toc_169">抽象布局使用</h4>

<h4 id="toc_170">HierarchyViewer</h4>

<h4 id="toc_171">Lint工具</h4>

<h3 id="toc_172">内存优化</h3>

<h4 id="toc_173">OOM</h4>

<h4 id="toc_174">ANR</h4>

<h4 id="toc_175">分析</h4>

<h5 id="toc_176">Heap</h5>

<h5 id="toc_177">adb shell</h5>

<p>{% post_link android-adb Android-ADB命令 %}</p>

<h6 id="toc_178">dumpsys meminfo</h6>

<h6 id="toc_179">showmap</h6>

<h5 id="toc_180">TraceView</h5>

<h5 id="toc_181">Dalvik日志</h5>

<h5 id="toc_182">logcat</h5>

<h5 id="toc_183">MAT</h5>

<h3 id="toc_184">电量优化</h3>

<h3 id="toc_185">流量优化</h3>

<h2 id="toc_186">调试(Debug)</h2>

<p>{% post_link android-debug Android-Debug %}</p>

<h3 id="toc_187">Logcat</h3>

<h3 id="toc_188">adb</h3>

<h3 id="toc_189">HierarchyViewer</h3>

<h3 id="toc_190">TraceView</h3>

<h3 id="toc_191">Heap</h3>

<h3 id="toc_192">Lint</h3>

<h2 id="toc_193">适配</h2>

<h3 id="toc_194">OS Version</h3>

<h4 id="toc_195">min SDK</h4>

<h3 id="toc_196">UI界面适配</h3>

<p>{% post_link android-ui-adapt Android界面适配 %}</p>

<p>{% post_link android-screen-adapt Android屏幕适配 %}</p>

<h4 id="toc_197">drawable</h4>

<h2 id="toc_198">测试</h2>

<h3 id="toc_199">Monkey</h3>

<h3 id="toc_200">MonkeyRunner</h3>

<h3 id="toc_201">JUnit</h3>

<h3 id="toc_202">Robotium</h3>

<h3 id="toc_203">Appium</h3>

<h3 id="toc_204">Athrun(TMTS)</h3>

<h3 id="toc_205">UIAutomator</h3>

<h2 id="toc_206">安全</h2>

<h3 id="toc_207">服务器安全</h3>

<h3 id="toc_208">通信安全</h3>

<h4 id="toc_209">与服务器通信</h4>

<h4 id="toc_210">组件间通信</h4>

<h3 id="toc_211">反编译</h3>

<p>{% post_link android-decompile Android反编译 %}  </p>

<p>{% post_link android-get-sha1 Android-获取sha1 %}  </p>

<p>{% post_link android-smali Android-smali文件格式 %}</p>

<h3 id="toc_212">数据加密</h3>

<h3 id="toc_213">数据验签</h3>

<h3 id="toc_214">代码混淆</h3>

<h3 id="toc_215">WebView/JS安全调用</h3>

<h3 id="toc_216">MD5、DES、RSA、https、证书、权限</h3>

<h2 id="toc_217">NDK</h2>

<p>{% post_link android-ndk Android-NDK %}</p>

<h3 id="toc_218">JNI</h3>

<h3 id="toc_219">C语言</h3>

<h3 id="toc_220">C++</h3>

<h2 id="toc_221">Android 多媒体</h2>

<h3 id="toc_222">相机开发</h3>

<h4 id="toc_223">使用自带的相机APP拍照</h4>

<h4 id="toc_224">系统相册选择照片</h4>

<h4 id="toc_225">系统相机或相册获取的照片裁剪</h4>

<h4 id="toc_226">使用相机API 开发相机:</h4>

<ul>
<li>Android 5.0 （API 21 ）以下 使用Camera API </li>
<li>Android 5.0 以上使用 Camera2 API </li>
</ul>

<h4 id="toc_227">自定义相册开发</h4>

<h4 id="toc_228">自定义裁剪界面</h4>

<h3 id="toc_229">视频开发</h3>

<h4 id="toc_230">视频播放</h4>

<ul>
<li>MediaPlayer</li>
<li>VideoView</li>
</ul>

<h4 id="toc_231">视频编解码</h4>

<h3 id="toc_232">音频开发</h3>

<h4 id="toc_233">AudioPlayer</h4>

<h4 id="toc_234">音乐播放器</h4>

<h2 id="toc_235">Android权限配置</h2>

<h2 id="toc_236">Gradle</h2>

<h3 id="toc_237">自定义Gradle插件</h3>

<h3 id="toc_238">Gradle多渠道打包</h3>

<h2 id="toc_239">手机功能</h2>

<h3 id="toc_240">电话</h3>

<h4 id="toc_241">联系人</h4>

<h4 id="toc_242">通话记录</h4>

<h3 id="toc_243">短/彩信</h3>

<h3 id="toc_244">Audio</h3>

<h3 id="toc_245">SD卡</h3>

<h3 id="toc_246">感应器</h3>

<h4 id="toc_247">加速</h4>

<h4 id="toc_248">方向</h4>

<h4 id="toc_249">重力</h4>

<h4 id="toc_250">光线</h4>

<h4 id="toc_251">陀螺仪</h4>

<h4 id="toc_252">磁场</h4>

<h4 id="toc_253">接近</h4>

<h4 id="toc_254">温度</h4>

<h4 id="toc_255">压力</h4>

<h4 id="toc_256">线性加速度</h4>

<h4 id="toc_257">旋转</h4>

<h2 id="toc_258">第三方扩展</h2>

<h3 id="toc_259">地图</h3>

<h3 id="toc_260">语音识别</h3>

<h3 id="toc_261">支付</h3>

<h3 id="toc_262">统计分析</h3>

<h3 id="toc_263">广告</h3>

<h2 id="toc_264">其他</h2>

<h3 id="toc_265">Intent</h3>

<h3 id="toc_266">AndroidManifest</h3>

<h3 id="toc_267">AIDL</h3>

<h3 id="toc_268">Wifi</h3>

<p>{% post_link android-wifi Android-WiFi %}</p>

<h3 id="toc_269">国际化</h3>

<h3 id="toc_270">响应式编程</h3>

<p>{% post_link android-permissions Android权限机制 %}</p>

<h3 id="toc_271">其他</h3>

<p>{% post_link android-responsive-code Android响应式编程 %}  </p>

<p>{% post_link android-mvp Android MVP模式 %}  </p>

<p>{% post_link android-cold-launch Android冷启动实现APP秒开 %}  </p>

<p>{% post_link android-studio-bitbucket AndroidStudio关联Bitbucket %}  </p>

<p>{% post_link android-issues Android-Issues %}  </p>

<p>{% post_link android-base-class Android-基类实现 %}  </p>

<p>{% post_link android-modularization Android组件化学习%}</p>

<h2 id="toc_272">Library</h2>

<p>{% post_link android-library Android-开发中常用的支持库 %}  </p>

<p>{% post_link android-efficient-tools Android高效开发工具库 %}  </p>

<p>{% post_link android-quick-develop-frame Android快速开发框架 %}  </p>

<p>{% post_link android-picasso Android-Picasso图片框架 %}  </p>

<p>{% post_link android-greendao Android-GreenDao3.2.0的使用 %}  </p>

<p>{% post_link android-eventbus Android-EventBus3.0的使用 %}  </p>

<p>{% post_link android-common-android-library Android-常用的库 %}  </p>

<p>{% post_link android-fresco Android-Fresco详细学习 %}  </p>

<p>{% post_link android-rxjava Android-RxJava详细学习 %}  </p>

<p>{% post_link android-gson Android-Gson详细学习 %}  </p>

<p>{% post_link android-retrofit Android-Retrofit详细学习 %}  </p>

<p>{% post_link android-databinding Android-DataBinding详细学习 %}</p>

<h2 id="toc_273">实现</h2>

<p>{% post_link android-custom-lock-screen Android自定义锁屏页 %}  </p>

<p>{% post_link android-custom-skin Android自定义皮肤 %}</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870815.html">
                
                  <h1>Android-smali文件格式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">HelloWorld</h2>

<p>首先写一个 HelloWorld 类：</p>

<pre class="line-numbers"><code class="language-java">package jiuyou.hello.info;

public class HelloWorld {
    public static void main(String[] args){
        System.out.println(&quot;hello world&quot;);
    }
}
</code></pre>

<p>然后生成 apk 再用 apktool 工具转成 smali 文件：</p>

<pre class="line-numbers"><code class="language-text">.class public Ljiuyou/hello/info/HelloWorld;    #定义类名
.super Ljava/lang/Object;                       #定义父类
.source &quot;HelloWorld.java&quot;                       #源文件名

# direct methods      #直接方法  （# virtual methods 为虚方法）
.method public constructor &lt;init&gt;()V      #构造函数
    .locals 0     #方法中使用到的局部变量个数

    .prologue     #代码起始指令
    .line 8       #源代码所在行数
    invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V         #调用父类构造方法

    return-void     #返回空
.end method         #方法结束

.method public static main([Ljava/lang/String;)V      #对应 main 方法
    .locals 2       #方法包含两个局部 v0,v1
    .param p0, &quot;args&quot;    # [Ljava/lang/String;   # main 方法的参数 agrs 标记为 p0

    .prologue       #代码起始指令
    .line 10
    sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;  #将 System.out 这个静态变量赋给 v0

    const-string v1, &quot;hello world&quot;    #构造字符串

    #方法调用（调用 v0 的方法 println ，v1 是参数）
    invoke-virtual {v0, v1}, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V    

    .line 11
    return-void
.end method
</code></pre>

<h2 id="toc_1">字段</h2>

<p>静态字段格式如下：</p>

<pre class="line-numbers"><code class="language-text"># static fields
.field &lt;访问权限&gt; static [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre>

<p>实例字段格式如下：</p>

<pre class="line-numbers"><code class="language-text"># instance fields
.field &lt;访问权限&gt; [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;
</code></pre>

<p>举个栗子</p>

<p><strong>java</strong> ：</p>

<pre class="line-numbers"><code class="language-java">private String name;

private final String sex=&quot;男&quot;;

public static int age;
</code></pre>

<p><strong>smali</strong> :</p>

<pre class="line-numbers"><code class="language-text"># static fields
.field public static age:I

# instance fields
.field private name:Ljava/lang/String;

.field private final sex:Ljava/lang/String;
</code></pre>

<h2 id="toc_2">方法</h2>

<p>方法有直接方法和虚方法两种，两者格式基本相同：</p>

<pre class="line-numbers"><code class="language-text"># direct methods  (virtual methods)
.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;
    &lt;.locals&gt;
    [.parameter] or [.param]
    [.prologue]
    [.line]
    &lt;代码体&gt;
.end method
</code></pre>

<p><strong>.locals</strong>：局部变量个数<br/><br/>
<strong>.parameter or .param</strong>：指定每个参数<br/><br/>
<strong>.prologue</strong>：代码的开始处，混淆过的代码可能没有该指令<br/><br/>
<strong>.line</strong>：指定了该处指令在源代码中的行号，混淆过的代码可能没有该指令</p>

<p>举个栗子：<br/><br/>
<strong>java</strong></p>

<pre class="line-numbers"><code class="language-java">public String test(int a){
    int b=a+10;
    return &quot;test&quot;;
}
</code></pre>

<p><strong>smali</strong></p>

<pre class="line-numbers"><code class="language-text"># virtual methods
.method public test(I)Ljava/lang/String;
    .locals 2
    .param p1, &quot;a&quot;    # I

    .prologue
    .line 11
    add-int/lit8 v0, p1, 0xa

    .line 12
    .local v0, &quot;b&quot;:I
    const-string v1, &quot;test&quot;

    return-object v1
.end method
</code></pre>

<h2 id="toc_3">接口</h2>

<p>interface 格式如下：</p>

<pre class="line-numbers"><code class="language-text"># interfaces
.implements &lt;接口名&gt;
</code></pre>

<p>举个例子：<br/><br/>
<strong>java</strong></p>

<pre class="line-numbers"><code class="language-java">public interface If {
    int demo(String s);
}

public class InterfaceTest implements If {
    @Override
    public int demo(String s) {
        return 0;
    }
}
</code></pre>

<p><strong>smali</strong> ：</p>

<p>If.smali</p>

<pre class="line-numbers"><code class="language-text"># virtual methods
.method public abstract demo(Ljava/lang/String;)I
.end method
</code></pre>

<p>InterfaceTest.smali</p>

<pre class="line-numbers"><code class="language-text"># interfaces
.implements Ljiuyou/hello/info/If;

# virtual methods
.method public demo(Ljava/lang/String;)I
    .locals 1
    .param p1, &quot;s&quot;    # Ljava/lang/String;

    .prologue
    .line 11
    const/4 v0, 0x0

    return v0
.end method
</code></pre>

<h2 id="toc_4">注解</h2>

<p>格式如下：</p>

<pre class="line-numbers"><code class="language-text">.annotation [注解属性] &lt;注解类名&gt;
    [注解字段 = 值]
.end annotation
</code></pre>

<p>如果注解的作用范围是类， <strong>.annotation</strong> 指令会直接定义在 smali 文件中，如果作用范围是方法或者字段，则会包含在方法或字段定义中。  </p>

<p>举个栗子：<br/><br/>
<strong>java</strong>  </p>

<pre class="line-numbers"><code class="language-java">@Deprecated
public class AnnotationTest {
    @At(value = &quot;tom&quot;)
    public String name;
}
</code></pre>

<p><strong>smali</strong></p>

<pre class="line-numbers"><code class="language-text"># annotations
.annotation runtime Ljava/lang/Deprecated;
.end annotation


# instance fields
.field public name:Ljava/lang/String;
    .annotation runtime Ljiuyou/hello/info/At;
        value = &quot;tom&quot;
    .end annotation
.end field
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870745.html">
                
                  <h1>Android-CoordinatorLayout详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>曾在网上找了一些关于<code>CoordinatorLayout</code>的教程，大部分文章都是把<code>CoordinatorLayout</code>、<code>AppbarLayout</code>、<code>CollapsingToolbarLayout</code> 以及<code>Toolbar</code>等一起使用来介绍，这让我不知不觉在心中认为把这几个布局要一起使用，而且只是用于那种场景中。其实<code>CoordinatorLayout</code>的功能并不是局限于与<code>AppBarLayout</code>一起使用，它的功能强大着呢，本文主要对<code>CoordinatorLayout</code>的使用进行介绍，后面再写一篇文章将<code>AppBarLayout</code>和<code>CollapsingToolBarLayout</code>整合<code>CoordinatorLayout</code>一起。那么到底<code>CoordinatorLayout</code>有多好用，请往下感受吧~</p>

<h2 id="toc_0">CoordinatorLayout能做什么</h2>

<p>在学习<code>CoordinatorLayout</code>之前，很有必要了解<code>CoordinatorLayout</code>能帮我们做什么，从名字上可以看出，就是帮我们协调子View的。怎么个协调法呢?就是它根据我们的定制，帮助我们协调各个子View的布局。我们先看一组动画图~</p>

<p><figure><img src="media/15561207870745/20171014150799569357936.gif" alt=""/></figure></p>

<p>稍微解释一下这个动画，蓝色的矩形是我们一个普通<code>View</code>，黄色的Hello是一个<code>Button</code>。我们水平拖动蓝色矩形时，黄色Button查着与蓝色矩形相反方向移动；竖直移动蓝色矩形时，黄色也跟着竖直。简而言之：它们在竖直方向同步移动，在水平方向相反。</p>

<p>这个效果如果让你不用<code>CoordinatorLayout</code>去实现，应该没有任何问题，但是代码的耦合度应该非常大，你的代码必须要持有2个View的引用，然后在onTouchEvent里面做各种判断。如果我们想要实现的功能是，有更多的View要根据蓝色的View的移动相应作出响应，那么那就得在蓝色View的<code>onTounchEvent</code>里面针对其他的View处理各种逻辑。这耦合度未免太伤感了~</p>

<p>而<code>CoordinatorLayout</code>既然号称能帮我们协调子View的布局，我们接下来看看<code>CoordinatorLayout</code>如何实现~</p>

<h2 id="toc_1">CoordinatorLayout使用</h2>

<p><code>CoordinatorLayout</code>的使用核心是<code>Behavior</code>，<code>Behavior</code>就是执行你定制的动作。在讲<code>Behavior</code>之前必须先理解两个概念：<code>Child</code>和<code>Dependency</code>，什么意思呢？<code>Child</code>当然是子View的意思了，是谁的子View呢，当然是<code>CoordinatorLayout</code>的子<code>View</code>；其实<code>Child</code>是指要执行动作的<code>CoordinatorLayout</code>的子<code>View</code>。而<code>Dependency</code>是指<code>Child</code>依赖的<code>View</code>。比如上面的gif图中，蓝色的<code>View</code>就是<code>Dependency</code>，黄色的<code>View</code>就是<code>Child</code>，因为黄色的<code>View</code>的动作是依赖于蓝色的<code>View</code>。简而言之，就是如过<code>Dependency</code>这个View发生了变化，那么<code>Child</code>这个View就要相应发生变化。发生变化是具体发生什么变化呢？这里就要引入<code>Behavior</code>，<code>Child</code>发生变化的具体执行的代码都是放在<code>Behavior</code>这个类里面。</p>

<p>怎么使用<code>Behavior</code>呢，首先，我们定义一个类，继承<code>CoordinatorLayout.Behavior&lt;T&gt;</code>,其中，泛型参数T是我们要执行动作的<code>View</code>类，也就是<code>Child</code>。然后就是去实现<code>Behavior</code>的两个方法：</p>

<pre class="line-numbers"><code class="language-java">/**
* 判断child的布局是否依赖dependency
*/
   @Override
 public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) {
    boolean rs;
    //根据逻辑判断rs的取值
    //返回false表示child不依赖dependency，ture表示依赖
    return rs;  
}

/**
* 当dependency发生改变时（位置、宽高等），执行这个函数
* 返回true表示child的位置或者是宽高要发生改变，否则就返回false
*/
@Override
public boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) {
     //child要执行的具体动作
        return true;
}
</code></pre>

<p>有了上面的概念后，我们看看具体怎么去实现吧~</p>

<p>为了响应跟随手指移动的操作，我们定义一个非常简单的<code>View</code>，这个<code>View</code>只响应跟随手指移动，将这个<code>View</code>作为<code>Dependency</code>。由于过于简单，这个<code>View</code>源码不粘贴，我们只需知道这个<code>View</code>的类名叫：<code>TempView</code>。</p>

<p>我们看看<code>Behavior</code>的使用：</p>

<pre class="line-numbers"><code class="language-java">package com.hc.studyCoordinatorLayout;

import android.content.Context;
import android.support.design.widget.CoordinatorLayout;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.View;
import android.widget.Button;

/**
 * Package com.hc.studyCoordinatorLayout
 * Created by HuaChao on 2016/6/1.
 */
public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; {
    private int width;

    public MyBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
        DisplayMetrics display = context.getResources().getDisplayMetrics();
        width = display.widthPixels;
    }

    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) {
        //如果dependency是TempView的实例，说明它就是我们所需要的Dependency
        return dependency instanceof TempView;
    }

    //每次dependency位置发生变化，都会执行onDependentViewChanged方法
    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, Button btn, View dependency) {

        //根据dependency的位置，设置Button的位置

        int top = dependency.getTop();
        int left = dependency.getLeft();

        int x = width - left - btn.getWidth();
        int y = top;

        setPosition(btn, x, y);
        return true;
    }

    private void setPosition(View v, int x, int y) {
        CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) v.getLayoutParams();
        layoutParams.leftMargin = x;
        layoutParams.topMargin = y;
        v.setLayoutParams(layoutParams);
    }
}
</code></pre>

<p>OK，现在我们为<code>Button</code>类指定了<code>Dependency</code>，并且定义好了跟随<code>Dependency</code>一直变化的动作（<code>Behavior</code>），接下来我们就要指定好为哪个具体的<code>Button</code>实例来绑定这些。方法很简单，直接在布局文件指定就好：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.hc.studyCoordinatorLayout.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/btn&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#FFCC00&quot;
        android:text=&quot;Hello&quot;
        app:layout_behavior=&quot;com.hc.studyCoordinatorLayout.MyBehavior&quot; /&gt;

    &lt;com.hc.studyCoordinatorLayout.TempView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#3366CC&quot;  /&gt;
&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>是不是很简单呢？我们只需关注<code>Behavior</code>的编写就好了，把<code>Child</code>和<code>Dependency</code>之间的关系完全解耦了~</p>

<p>附上<a href="http://download.csdn.net/detail/huachao1001/9537636">源码地址</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_7.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_9.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16145671673295.html">多态</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
