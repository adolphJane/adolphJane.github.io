<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16432746488334.html">
                
                  <h1>基础组件之Container</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="container%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Container简介</h2>
<p>一个拥有绘制、定位、调整大小的 widget。</p>
<h2><a id="%E7%BB%84%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>组成</h2>
<p><strong>Container的组成</strong><br />
最里层的是child元素；child元素首先会被padding包着；然后添加额外的constraints限制；最后添加margin。</p>
<p><strong>Container的绘制的过程</strong><br />
首先会绘制transform效果；接着绘制decoration；然后绘制child；最后绘制foregroundDecoration。</p>
<p><strong>Container自身尺寸的调节分两种情况</strong><br />
Container在没有子节点（children）的时候，会试图去变得足够大。除非constraints是unbounded限制，在这种情况下，Container会试图去变得足够小。带子节点的Container，会根据子节点尺寸调节自身尺寸，但是Container构造器中如果包含了width、height以及constraints，则会按照构造器中的参数来进行尺寸的调节。</p>
<h2><a id="%E5%B8%83%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>布局</h2>
<p>由于Container组合了一系列的widget，这些widget都有自己的布局行为，因此Container的布局行为有时候是比较复杂的。</p>
<p>一般情况下，Container会遵循如下顺序去尝试布局：对齐（alignment）；调节自身尺寸适合子节点；采用width、height以及constraints布局；扩展自身去适应父节点；调节自身到足够小。进一步说：如果没有子节点、没有设置width、height以及constraints，并且父节点没有设置unbounded的限制，Container会将自身调整到足够小。</p>
<p>如果没有子节点、对齐方式（alignment），但是提供了width、height或者constraints，那么Container会根据自身以及父节点的限制，将自身调节到足够小。</p>
<p>如果没有子节点、width、height、constraints以及alignment，但是父节点提供了bounded限制，那么Container会按照父节点的限制，将自身调整到足够大。</p>
<p>如果有alignment，父节点提供了unbounded限制，那么Container将会调节自身尺寸来包住child；</p>
<p>如果有alignment，并且父节点提供了bounded限制，那么Container会将自身调整的足够大（在父节点的范围内），然后将child根据alignment调整位置；含有child，但是没有width、height、constraints以及alignment，Container会将父节点的constraints传递给child，并且根据child调整自身。</p>
<h2><a id="%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>属性</h2>
<ul>
<li><code>key</code>：Container唯一标识符，用于查找更新。</li>
<li><code>alignment</code>：控制child的对齐方式，如果container或者container父节点尺寸大于child的尺寸，这个属性设置会起作用，有很多种对齐方式。</li>
<li><code>padding</code>：decoration内部的空白区域，如果有child的话，child位于padding内部。padding与margin的不同之处在于，padding是包含在content内，而margin则是外部边界，设置点击事件的话，padding区域会响应，而margin区域不会响应。</li>
<li><code>color</code>：用来设置container背景色，如果foregroundDecoration设置的话，可能会遮盖color效果。</li>
<li><code>decoration</code>：绘制在child后面的装饰，设置了decoration的话，就不能设置color属性，否则会报错，此时应该在decoration中进行颜色的设置。</li>
<li><code>foregroundDecoration</code>：绘制在child前面的装饰。</li>
<li><code>width</code>：container的宽度，设置为double.infinity可以强制在宽度上撑满，不设置，则根据child和父节点两者一起布局。</li>
<li><code>height</code>：container的高度，设置为double.infinity可以强制在高度上撑满。</li>
<li><code>constraints</code>：添加到child上额外的约束条件。</li>
<li><code>margin</code>：围绕在decoration和child之外的空白区域，不属于内容区域。</li>
<li><code>transform</code>：设置container的变换矩阵，类型为Matrix4。</li>
<li><code>child</code>：container中的内容widget。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%BB%84%E4%BB%B6%E5%BA%93.html'>组件库</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16431658645321.html">
                
                  <h1>Flutter 语法小记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="future" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future</h2>
<p><code>future</code>是代表可能还没有发生的运算结果的对象。结果可能在未来的某个时间是可知的，因此被称为“future”。</p>
<p>简而言之，就是通过<code>future</code>来实现异步。正如<code>isolate</code>与进程类似，<code>future</code>也与线程类似。但也仅类似而已，毕竟<code>future</code>中还是与线程有很大区别的，比如线程既可执行IO密集型任务，也可执行计算密集型任务，而<code>future</code>仅能执行IO密集型任务。</p>
<p>Future和Stream会在耗时操作执行完毕前直接返回而不会等待耗时操作执行完毕。</p>
<p>可以通过下面两种方式，获得Future执行完成的结果：</p>
<ul>
<li>使用<code>async</code>和<code>await</code>；</li>
<li>使用Future API；</li>
</ul>
<h2><a id="async" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>async</h2>
<p>用于声明异步函数</p>
<p>定义异步函数只需在普通方法上加上async关键字即可。<br />
将关键字async添加到函数并让其返回一个Future 对象。假设有如下返回String对象的方法：</p>
<pre><code class="language-dart">String lookUpVersion() =&gt; '1.0.0';
</code></pre>
<p>将其改为异步函数，返回值是Future：</p>
<pre><code class="language-dart">Future&lt;String&gt; lookUpVersion() async =&gt; '1.0.0';
</code></pre>
<p>注意，函数体不需要使用Future API。如有必要，Dart会创建Future对象。<br />
如果函数没有返回有效值，需要设置其返回类型为 <code>Future&lt;void&gt;</code></p>
<h2><a id="await" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>await</h2>
<p>await表达式的返回值通常是一个Future对象；<br />
如果不是的话也会自动将其包裹在一个Future对象里。Future对象代表一个&quot;承诺&quot;,await表达式会阻塞直到需要的对象返回。</p>
<p>必须在带有async关键字的异步函数中使用 await：</p>
<pre><code class="language-dart">Future checkVersion() async {
  var version = await lookUpVersion();
  // 使用 version 继续处理逻辑
}
</code></pre>
<p>尽管异步函数可以处理耗时操作，但是它并不会等待这些耗时操作完成，异步函数执行时会在其遇到第一个 <code>await</code>表达式的时候返回一个Future对象，然后等待<code>await</code>表达式执行完毕后继续执行。</p>
<p>如果在使用await时导致编译错误，请确保await在一个异步函数中使用。</p>
<p>使用try、catch以及finally来处理使用await导致的异常：</p>
<pre><code class="language-dart">try {
  version = await lookUpVersion();
} catch (e) {
  // 无法找到版本时做出的反应
}
</code></pre>
<h2><a id="stream" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stream</h2>
<p><code>Stream</code>也是用于接收异步事件数据，和<code>Future</code>不同的是，它可以接收多个异步操作的结果（成功或失败）。 也就是说，在执行异步任务时，可以通过多次触发成功或失败事件来传递结果数据或错误异常。<code>Stream</code>常用于会多次读取数据的异步任务场景，如网络内容下载、文件读写等。举个例子：</p>
<pre><code class="language-dart">Stream.fromFutures([
  // 1秒后返回结果
  Future.delayed(new Duration(seconds: 1), () {
    return &quot;hello 1&quot;;
  }),
  // 抛出一个异常
  Future.delayed(new Duration(seconds: 2),(){
    throw AssertionError(&quot;Error&quot;);
  }),
  // 3秒后返回结果
  Future.delayed(new Duration(seconds: 3), () {
    return &quot;hello 3&quot;;
  })
]).listen((data){
   print(data);
}, onError: (e){
   print(e.message);
},onDone: (){

});
</code></pre>
<p>上面的代码依次会输出：</p>
<pre><code class="language-plain_text">hello 1
Error
hello 3
</code></pre>
<h2><a id="typedef" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>typedef</h2>
<p>首先<code>typedef</code>是一个关键字或修饰符，因为<code>dart</code>一切皆对象，方法也可理解为对象，所以<code>typedef</code>也可理解为对象的修饰符，具体意思为： 使用<code>typedef</code> 定义一个函数(或匿名函数)，可以使用此函数作为其他函数的参数或返回值.</p>
<pre><code class="language-dart">import 'package:flutter/material.dart';

class CallBackHomePage extends StatefulWidget {
  @override
  _CallBackHomePageState createState() =&gt; _CallBackHomePageState();
}

class _CallBackHomePageState extends State&lt;CallBackHomePage&gt; {
  String sexStr = '';
  int ageInt;
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('回调方法demo'),
      ),
      body: Column(
        children: [
          Container(
            child: Text('张三的性别是:$sexStr'),
          ),
          Container(
            child: Text(ageInt == null ? '张三的年龄是:' : '张三的年龄是:$ageInt'),
          ),
          BottomView('张三', (sex) {
            setState(() {
              sexStr = sex;
            });
          },
              (age) =&gt; setState(() {
                    ageInt = age;
                  }))
        ],
      ),
    );
  }
}

typedef SexFunc = void Function(String sex);
typedef AgeFunc(int age);

class BottomView extends StatelessWidget {
  final SexFunc sexCallBack;
  final AgeFunc ageCallBack;
  BottomView(String name, this.sexCallBack, this.ageCallBack);
  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.yellow,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceAround,
        children: [
          RaisedButton(
            onPressed: () {
              sexCallBack('男');
            },
            child: Text('调查性别'),
          ),
          RaisedButton(
            onPressed: () {
              ageCallBack(23);
            },
            child: Text('调查年龄'),
          ),
        ],
      ),
    );
  }
}
</code></pre>
<p>其中可以看到这两行：</p>
<pre><code class="language-dart">typedef SexFunc = void Function(String sex);
typedef AgeFunc(int age);
</code></pre>
<p>其实这是dart的语法糖，SexFuc方法的缩写就是下面的AgeFunc的写法，同样在回调传参的地方也是一个语法糖，如下</p>
<pre><code class="language-dart">BottomView('张三', 
        (sex) {
            setState(() {
              sexStr = sex;
            });
        },
          //等价于上面的写法
        (age) =&gt; setState(() {
                    ageInt = age;
                 })
          )
</code></pre>
<p>能做回调的还有<code>VoidCallback</code>、<code>ValueChanged</code>，但看源码可知</p>
<pre><code class="language-dart">typedef VoidCallback = void Function()

typedef ValueSetter&lt;T&gt; = void Function(T value)
</code></pre>
<p>本质上VoidCallback、ValueChanged 就是typedef的一种写法而已，只是Flutter帮我们做了一层封装</p>
<h2><a id="overlay%E5%92%8C-overlayentry" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overlay 和 OverlayEntry</h2>
<p><code>Overlay</code>是一个可以管理的堆栈。我们可以通过将一个<code>Widget</code>插入这个堆栈中，这样就可以让此<code>Widget</code>浮在其他的<code>Widget</code>之上，从而实现悬浮窗效果。我们可以通过<code>OverlayEntry</code>对象的配置来管理<code>Overlay</code>的层级关系。</p>
<p><img src="media/16431658645321/16432512578634.jpg" alt="" /></p>
<p>​通过追踪构造方法，我们可以发现它被<code>Navigator</code>所创建，而<code>Navigator</code>又被<code>WidgetsApp</code>所创建。通常我们<code>runApp</code>启动的<code>page</code>里会创建的<code>CupertinoApp</code>或者<code>MaterialApp</code>都会创建<code>WidgetsApp</code>，因此我们在项目中可以直接使用这个创建好的<code>Overlay</code>。<br />
​</p>
<pre><code class="language-dart">  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback(
      (timeStamp) {
        OverlayEntry entry = OverlayEntry(
          builder: (_) {
            return IgnorePointer(
              child: Center(
                child: Text('OverlayEntry'),
              ),
            );
          },
        );
        Overlay.of(context).insert(entry);
      },
    );
  }
</code></pre>
<p>​<code>Overlay</code>的使用很简单，通过<code>Overlay.of(context)</code>方法向上查找到<code>OverlayState</code>，然后通过<code>insert</code>或者<code>insertAll</code>方法插入一个或多个悬浮<code>Widget</code>。如果想要移除此悬浮<code>Widget</code>，我们可以通过<code>OverlayEntry</code>的<code>remove()</code>方法<br />
​</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Flutter.html'>Flutter</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16414464301864.html">
                
                  <h1>富文本编辑器内容描述Delta</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Delta属于Github著名富文本编辑器Quill，是Quill在DOM之上做了一层抽象，使用一种非常简洁的数据结构来描述编辑器的内容及其变化。</p>
<p>Delta是JSON的一个子集，只包含一个ops属性，它的值是一个对象数组，每个数组项代表对编辑器的一个操作。</p>
<p>比如编辑器里面有&quot;Hello World&quot;：</p>
<p><img src="media/16414464301864/16414466526635.jpg" alt="" /></p>
<p>用Delta进行描述</p>
<pre><code class="language-json">{
  &quot;ops&quot;: [
    { &quot;insert&quot;: &quot;Hello &quot; },
    { &quot;insert&quot;: &quot;World&quot;, &quot;attributes&quot;: { &quot;bold&quot;: true } },
    { &quot;insert&quot;: &quot;\n&quot; }
  ]
}
</code></pre>
<p>意思很明显，在空的编辑器里面插入&quot;Hello &quot;，在上一个操作后面插入加粗的&quot;World&quot;，最后插入一个换行&quot;\n&quot;。</p>
<h2><a id="delta%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E5%86%85%E5%AE%B9%E5%8F%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delta如何描述内容变化</h2>
<p>Delta非常简洁，但却极富表现力</p>
<p>它只有3种动作和1种属性，却足以描述任何富文本内容和任意内容的变化</p>
<p><strong>3种动作</strong></p>
<ul>
<li>insert: 插入</li>
<li>retain: 保留</li>
<li>delete: 删除</li>
</ul>
<p><strong>1种属性</strong></p>
<ul>
<li>attributes: 格式属性</li>
</ul>
<p>比如我们把加粗的&quot;World&quot;改成红色的文字&quot;World&quot;，这个动作用 Delta 描述如下：</p>
<pre><code class="language-json">{
  &quot;ops&quot;: [
    { &quot;retain&quot;: 6 },
    { &quot;retain&quot;: 5, &quot;attributes&quot;: { &quot;color&quot;: &quot;#ff0000&quot; } }
  ]
}
</code></pre>
<p>意思是：保留编辑器最前面的6个字符，即保留&quot;Hello &quot;不动，保留之后的5个字符&quot;World&quot;，并将这些字符设置为字体颜色为&quot;#ff0000&quot;。</p>
<p>如果要删除&quot;World&quot;，相信聪明的你也能猜到怎么用 Delta 描述，没错就是你猜到的：</p>
<pre><code class="language-json">{
  &quot;ops&quot;: [
    { &quot;retain&quot;: 6 },
    { &quot;delete&quot;: 5 }
  ]
}
</code></pre>
<h2><a id="delta%E5%A6%82%E4%BD%95%E6%8F%8F%E8%BF%B0%E5%AF%8C%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Delta如何描述富文本内容</h2>
<p>最常见的富文本内容就是图片，Quill 怎么用 Delta 描述图片呢？</p>
<p>insert 属性除了可以是用于描述普通字符的字符串格式之外，还可以是描述富文本内容的对象格式，比如图片：</p>
<pre><code class="language-json">{
  &quot;ops&quot;: [
    { &quot;insert&quot;: { &quot;image&quot;: &quot;https://quilljs.com/assets/images/logo.svg&quot; } },
    { &quot;insert&quot;: &quot;\n&quot; }
  ]
}
</code></pre>
<p>比如公式：</p>
<pre><code class="language-json">{ 
  &quot;ops&quot;: [ 
    { &quot;insert&quot;: { &quot;formula&quot;: &quot;e=mc^2&quot; } }, 
    { &quot;insert&quot;: &quot;\n&quot; } 
  ]
}
</code></pre>
<p>Delta 提供了极大的灵活性和可扩展性，可以自由定制富文本内容和格式，比如幻灯片、思维导图，甚至是3D模型。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/06</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Flutter.html'>Flutter</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16413600124903.html">
                
                  <h1>WindowManager</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="windowmanager-layoutparams" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>WindowManager.LayoutParams</h2>
<h3><a id="flag%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>flag类型</h3>
<h4><a id="flag-allow-lock-while-screen-on" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_ALLOW_LOCK_WHILE_SCREEN_ON</h4>
<p>只要这个window对用户是可见的,则允许在屏幕开启的时候锁定屏幕.这个flag可以单独的使用,也可以配合FLAG_KEEP_SCREEN_ON和(或者) FLAG_SHOW_WHEN_LOCKED使用</p>
<h4><a id="flag-dim-behind" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_DIM_BEHIND</h4>
<p>所有在这个window之后的界面都会变暗,使用dimAmount属性来控制变暗的程度(1.0不透明,0.0完全透明)</p>
<h4><a id="flag-not-focusable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_NOT_FOCUSABLE</h4>
<p>设置之后window永远不会获取焦点,所以用户不能给此window发送点击事件焦点会传递给在其下面的可获取焦点的window这个flag同时会启用 <strong>FLAG_NOT_TOUCH_MODAL</strong>flag , 不管你有没有手动设置设置这个flag同时表明了这个window不会和软键盘交互,(这句话的翻译我不知道对不对)所以window会独立于激活的软键盘之上(这句话的意思就是window会在Z轴上置于输入法之上,所以window可以全屏使用来覆盖住输入法,你可以使用<strong>FLAG_ALT_FOCUSABLE_IM</strong> 来修改这个行为)</p>
<h4><a id="flag-not-touchable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_NOT_TOUCHABLE</h4>
<p>这个window永远无法获取点击事件</p>
<h4><a id="flag-not-touch-modal" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_NOT_TOUCH_MODAL</h4>
<p>即使这个window是可获取焦点的,也允许window之外点击事件传递给其他在其之后的Window</p>
<p>如果不设置这个值,则window消费掉所有点击事件,不管这些点击事件是不是在window的范围之内。//如果要做悬浮框,我想这个flag肯定得设置,但api&gt;=23就别想了。这个flag简而言之就是说,当前window区域以外的点击事件传递给下层window,当前window区域以内的点击事件自己处理</p>
<h4><a id="flag-touchable-when-waking" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_TOUCHABLE_WHEN_WAKING</h4>
<p>当设置了这个值,则device休眠的时候,当触摸屏被点击,window会收到首次点击事件,通常当用户看不见东西时,首次点击事件会被系统消费</p>
<h4><a id="flag-keep-screen-on" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_KEEP_SCREEN_ON</h4>
<p>当这个window对用户是可见状态,则保持设备屏幕不关闭且不变暗</p>
<h4><a id="flag-layout-in-screen" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_LAYOUT_IN_SCREEN</h4>
<p>将window放置在整个屏幕之内,无视其他的装饰(比如状态栏)window要在考虑到屏幕的其他装饰来定位其中的内容这个flag通常使用Window类的setFlags(int, int)方法来设置</p>
<h4><a id="flag-layout-no-limits" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_LAYOUT_NO_LIMITS</h4>
<p>允许window扩展值屏幕之外</p>
<h4><a id="flag-fullscreen" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_FULLSCREEN</h4>
<p>当这个window显示的时候,隐藏所有的装饰物(比如状态栏)这个flag允许window使用整个屏幕区域当设置这个flag的window处于顶层的时候,状态栏会被隐藏全屏的时候会忽略 softInputMode 变量设置的SOFT_INPUT_ADJUST_RESIZE 效果,屏幕会不保持全屏且不会resize这个flag可以在主题属性(theme)中来控制通过 windowFullscreen 属性来控制</p>
<p>在一些常用的全屏主题中这个属性已经被设置好了</p>
<p>常用全屏主题:</p>
<ul>
<li>Theme_NoTitleBar_Fullscreen,</li>
<li>Theme_Black_NoTitleBar_Fullscreen,</li>
<li>Theme_Light_NoTitleBar_Fullscreen,</li>
<li>Theme_Holo_NoActionBar_Fullscreen,</li>
<li>Theme_Holo_Light_NoActionBar_Fullscreen,</li>
<li>Theme_DeviceDefault_NoActionBar_Fullscreen,</li>
<li>Theme_DeviceDefault_Light_NoActionBar_Fullscreen.</li>
</ul>
<h4><a id="flag-force-not-fullscreen" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_FORCE_NOT_FULLSCREEN</h4>
<p>覆盖FLAG_FULLSCREEN效果,并强制显示屏幕上的一些装饰(如状态栏)</p>
<h4><a id="flag-secure" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_SECURE</h4>
<p>把这个window中的内容看作需要保护的内容,防止被截屏,或防止内容显示在一些不安全的屏幕上</p>
<h4><a id="flag-ignore-cheek-presses" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_IGNORE_CHEEK_PRESSES</h4>
<p>这个flag一般用于,当用户把脸贴在屏幕上,它会过滤不需要的点击事件，当检测到一个事件流,这个程序会直接接收到一个CANCEL事件.这样程序可以正确的处理这种情况,直到手指离开屏幕</p>
<h4><a id="flag-layout-inset-decor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_LAYOUT_INSET_DECOR</h4>
<p>这个flag只能配合 FLAG_LAYOUT_IN_SCREEN 一起使用.当在屏幕中请求layout时,window可能在一些装饰物(如状态栏)之上或者之后当使用这个flag时,window manager会报告插入window的矩形大小,来确保你的内容不会被装饰物(如状态栏)掩盖.这个flag一般用Window类的 setFlags(int, int)方法来设置</p>
<h4><a id="flag-alt-focusable-im" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_ALT_FOCUSABLE_IM</h4>
<p>转变 <strong>FLAG_NOT_FOCUSABLE</strong> 设置的状态,关于这个window是怎么和当前的输入法交互</p>
<p>如果设置了<strong>FLAG_NOT_FOCUSABLE</strong>且<strong>FLAG_ALT_FOCUSABLE_IM</strong>也设置了,那么当这个window和input method交互的时候会被放置在input method后面或者旁边.如果FLAG_NOT_FOCUSABLE没有设置而设置了FLAG_ALT_FOCUSABLE_IM,那么window不需要和input method交互,可以放置在输入法上面</p>
<h4><a id="flag-watch-outside-touch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_WATCH_OUTSIDE_TOUCH</h4>
<p>如果你已经设置了<strong>FLAG_NOT_TOUCH_MODAL</strong>,那么你可以设置<strong>FLAG_WATCH_OUTSIDE_TOUCH</strong>这个flag,这样一个点击事件如果发生在你的window之外的范围,你就会接收到一个特殊的MotionEvent,MotionEvent.ACTION_OUTSIDE注意,你只会接收到点击事件的第一下,而之后的DOWN/MOVE/UP等手势全都不会接收到</p>
<h4><a id="flag-show-when-locked" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_SHOW_WHEN_LOCKED</h4>
<p>一个特殊的flag,使得window可以在锁屏状态下显示，这个flag会使得window比keyguard或其他锁屏界面具有更高的层级可以配合<strong>FLAG_KEEP_SCREEN_ON</strong>使用,点亮屏幕,在显示keyguard window之前显示你的window.可以配合<strong>FLAG_DISMISS_KEYGUARD</strong>使用来自动解锁没密码的keyguards这个flag只能应用在最顶层的全屏window上，用人话说就是可以让window显示在锁屏界面上</p>
<h4><a id="flag-turn-screen-on" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_TURN_SCREEN_ON</h4>
<p>当window被添加或者显示,系统会点亮屏幕,就好像用户唤醒屏幕一样</p>
<h4><a id="flag-dismiss-keyguard" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_DISMISS_KEYGUARD</h4>
<p>当使用的是无密码的锁屏界面,显示此window会使锁屏界面被自动解锁,其他废话就不翻译了</p>
<h4><a id="flag-split-touch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_SPLIT_TOUCH</h4>
<p>当window设置这个flag,window会接收来自window边界之外发送给其他window的点击事件,支持多点触控.当这个flag没有设置的时候,第一下点击则决定了哪个window会接收整个点击事件,直到手指拿开.当设置了这个flag,这每一个点击事件(不一定是第一个)都决定了那个window来接收剩下的点击事件,直到手指拿开.点击事件会被分开传递给多个window.貌似是关于多点触控的</p>
<h4><a id="flag-hardware-accelerated" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_HARDWARE_ACCELERATED</h4>
<p>表示这个window是否启动硬件加速,请求硬件加速但不能保证硬件加速生效。如果仅是用来启动硬件加速,可以在代码中控制,使用下面的代码给指定window启动硬件加速:</p>
<pre><code class="language-java">Window w = activity.getWindow(); // in Activity’s onCreate() for instance

w.setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,

WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
</code></pre>
<p>有一件很重要的事需要记住,这个flag需要在Activity和dialog添加view之前来配置。当你在manifest中设置了硬件加速后,这个flag不能用来取消硬件加速。当在Activity标签或者application标签中设置了 hardwareAccelerated = true属性这个flag就自动设置上了</p>
<h4><a id="flag-local-focus-mode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_LOCAL_FOCUS_MODE</h4>
<p>设置flag启用local focus模式(我也不知道local focus mode是什么),在这种模式下window可以不依赖windowmanager独立的控制焦点,使用window的 setLocalFocus(boolean, boolean) 方法即可通常在这种模式下,window不会通过windowmanager获取到touch/key event,但是会通过local injection(我不知道这是什么)得到event,by using injectInputEvent(InputEvent) 方法(貌似是手动的强行向一个window插入一个input event)</p>
<h4><a id="flag-draws-system-bar-backgrounds" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS</h4>
<p>这个flag表示window负责绘制状态栏的背景。当设置了这个flag,系统状态栏会变透明,同时这个相应的区域会被填满 getStatusBarColor() and getNavigationBarColor()的颜色</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16412884177749.html">
                
                  <h1>刚刚知道的KSP API</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="kotlin-compiler-plugin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kotlin Compiler Plugin</h2>
<p>Kotlin提供了编译器插件Compiler Plugin，可以在编译期通过分析和修改AST修改最终生成的字节码。相对于APT或者Transform等方式效率更高。Kotlin很多语法关键字以及注解都是基于KotlinCompilerPlugin实现的，例如<strong>data class</strong>、<strong>@Parcelize</strong>、<strong>kotlin-android-extension</strong> 等。</p>
<p>开发Compiler Plugin需要涉及一些编译器知识：例如需要了解编译器前、后端产物及相关API，有时需要还需要Gradle Plugin、IDEA Plugin等的配合，学习门槛较高，API也不够完善。普通开发者很难开发出自己的Compiler Plugin。</p>
<p>一个的Compiler Plugin的开发需要若干过程：<br />
<img src="media/16412884177749/16412886563549.jpg" alt="" /></p>
<p>而<strong>KSP API</strong>的出现可以帮助开发者<strong>降低</strong>开发Compiler Plugin的门槛。</p>
<p>更全面的一幅图</p>
<p><img src="media/16412884177749/16433626932174.jpg" alt="" /></p>
<ul>
<li><code>Plugin</code>：Gradle 插件用来读取 Gradle 配置传递给 KCP（Kotlin Plugin）</li>
<li><code>Subplugin</code>：为 KCP 提供自定义 KP 的 maven 库地址等配置信息</li>
<li><code>CommandLineProcessor</code>：将参数转换为 KP 可识别参数</li>
<li><code>ComponentRegistrar</code>：注册 Extension 到 KCP 不同流程中</li>
<li><code>Extension</code>：实现自定义的 KP 功能</li>
</ul>
<h2><a id="kotlin-symbol-processing-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kotlin Symbol Processing API</h2>
<p>KSP API 是一套可用来开发轻量级Kotlin Compiler Plugin 的API， 他屏蔽了很多编译器细节，大大降低了使用门槛。KSP甚至不用JVM强相关，理论上开发出的编译器插件可以跨平台使用。</p>
<p>KSP API 可以基于Kotlin访问AST上的元素节点，例如classes、class members、functions、parameters等，如同访问 Kotlin reflection的KType一样，基于这些元素节点生成自己的代码，然后一同参与编译。可以类比 PSI 中的 Kotlin AST。</p>
<p><img src="media/16412884177749/16433627649665.jpg" alt="" /></p>
<p>一个 Kotlin 源文件经 KSP 解析后的结果如下</p>
<ul>
<li>KSFile
<ul>
<li>packageName: KSName</li>
<li>fileName: String</li>
<li>annotations: List<KSAnnotation>  (File annotations)</li>
<li>declarations: List<KSDeclaration>
<ul>
<li>KSClassDeclaration // class, interface, object
<ul>
<li>simpleName: KSName</li>
<li>qualifiedName: KSName</li>
<li>containingFile: String</li>
<li>typeParameters: KSTypeParameter</li>
<li>parentDeclaration: KSDeclaration</li>
<li>classKind: ClassKind</li>
<li>primaryConstructor: KSFunctionDeclaration</li>
<li>superTypes: List<KSTypeReference><br />
// contains inner classes, member functions, properties, etc.</li>
<li>declarations: List<KSDeclaration></li>
</ul>
</li>
<li>KSFunctionDeclaration // top level function
<ul>
<li>simpleName: KSName</li>
<li>qualifiedName: KSName</li>
<li>containingFile: String</li>
<li>typeParameters: KSTypeParameter</li>
<li>parentDeclaration: KSDeclaration</li>
<li>functionKind: FunctionKind</li>
<li>extensionReceiver: KSTypeReference?</li>
<li>returnType: KSTypeReference</li>
<li>parameters: List<KSVariableParameter><br />
// contains local classes, local functions, local variables, etc.</li>
<li>declarations: List<KSDeclaration></li>
</ul>
</li>
<li>KSPropertyDeclaration // global variable
<ul>
<li>simpleName: KSName</li>
<li>qualifiedName: KSName</li>
<li>containingFile: String</li>
<li>typeParameters: KSTypeParameter</li>
<li>parentDeclaration: KSDeclaration</li>
<li>extensionReceiver: KSTypeReference?</li>
<li>type: KSTypeReference</li>
<li>getter: KSPropertyGetter</li>
<li>returnType: KSTypeReference</li>
<li>setter: KSPropertySetter</li>
<li>parameter: KSVariableParameter</li>
</ul>
</li>
<li>KSEnumEntryDeclaration<br />
// same as KSClassDeclaration</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这是 KSP 中的 Kotlin AST 抽象。 类似的， APT/KAPT 中有对 Java 的 AST 抽象，其中能找到一些对应关系，比如 Java 使用 Element 描述包、类、方法或者变量等， KSP 中使用 Declaration</p>
<table>
<thead>
<tr>
<th style="text-align: left">Java/APT</th>
<th style="text-align: left">Kotlin/KSP</th>
<th style="text-align: left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">PackageElement</td>
<td style="text-align: left">KSFile</td>
<td style="text-align: left">表示一个包程序元素。提供对有关包及其成员的信息的访问</td>
</tr>
<tr>
<td style="text-align: left">ExecuteableElement</td>
<td style="text-align: left">KSFunctionDeclaration</td>
<td style="text-align: left">表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素</td>
</tr>
<tr>
<td style="text-align: left">TypeElement</td>
<td style="text-align: left">KSClassDeclaration</td>
<td style="text-align: left">表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注解类型是一种接口</td>
</tr>
<tr>
<td style="text-align: left">VariableElement</td>
<td style="text-align: left">KSVariableParameter / KSPropertyDeclaration</td>
<td style="text-align: left">表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数</td>
</tr>
</tbody>
</table>
<p>Declaration 之下还有 Type 信息 ，比如函数的参数、返回值类型等，在 APT 中使用 TypeMirror 承载类型信息 ，KSP 中详细的能力由 KSType 实现。</p>
<p>KSP 的开发流程和 KAPT 类似：</p>
<ol>
<li>解析源码AST</li>
<li>生成代码</li>
<li>生成的代码与源码一起参与 Kotlin 编译</li>
</ol>
<blockquote>
<p>需要注意 KSP 不能用来修改原代码，只能用来生成新代码</p>
</blockquote>
<p>SymbolProcessorProvider作为KSP的入口，KSP通过SymbolProcessor来具体执行，SymbolProcessor 需要通过一个 SymbolProcessorProvider 来创建。因此 SymbolProcessorProvider 就是 KSP 执行的入口。</p>
<h2><a id="symbolprocessor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SymbolProcessor</h2>
<p>一般需要继承<strong>SymbolProcessor</strong>来创建自己的KSP</p>
<pre><code class="language-kotlin">interface SymbolProcessor {
    fun init(options: Map&lt;String, String&gt;,
             kotlinVersion: KotlinVersion,
             codeGenerator: CodeGenerator,
             logger: KSPLogger)
    fun process(resolver: Resolver) // Let's focus on this
    fun finish()
}
</code></pre>
<p>然后通过访问者模式，处理AST：</p>
<pre><code class="language-kotlin">class HelloFunctionFinderProcessor : SymbolProcessor() {
    ...
    val functions = mutableListOf&lt;String&gt;()
    val visitor = FindFunctionsVisitor()

    override fun process(resolver: Resolver) {
        resolver.getAllFiles().map { it.accept(visitor, Unit) }
    }

    inner class FindFunctionsVisitor : KSVisitorVoid() {
        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            classDeclaration.getDeclaredFunctions().map { it.accept(this, Unit) }
        }

        override fun visitFunctionDeclaration(function: KSFunctionDeclaration, data: Unit) {
            functions.add(function)
        }

        override fun visitFile(file: KSFile, data: Unit) {
            file.declarations.map { it.accept(this, Unit) }
        }
    }
    ...
}
</code></pre>
<h2><a id="ksp-api%E8%AE%BF%E9%97%AEast%E7%9A%84%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>KSP API访问AST的例子</h2>
<h3><a id="%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>访问类中的所有成员方法</h3>
<pre><code class="language-kotlin">fun KSClassDeclaration.getDeclaredFunctions(): List&lt;KSFunctionDeclaration&gt; {
    return this.declarations.filterIsInstance&lt;KSFunctionDeclaration&gt;()
}
</code></pre>
<h3><a id="%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E6%98%AF%E5%B1%80%E9%83%A8%E7%B1%BB%E6%88%96%E5%B1%80%E9%83%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判断一个类或者方法是否是局部类或局部方法</h3>
<pre><code class="language-kotlin">fun KSDeclaration.isLocal(): Boolean {
    return this.parentDeclaration != null &amp;&amp; this.parentDeclaration !is KSClassDeclaration
}
</code></pre>
<h3><a id="%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%88%90%E5%91%98%E6%98%AF%E5%90%A6%E5%AF%B9%E5%85%B6%E4%BB%96declaration%E5%8F%AF%E8%A7%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判断一个类成员是否对其他Declaration可见</h3>
<pre><code class="language-kotlin">fun KSDeclaration.isVisibleFrom(other: KSDeclaration): Boolean {
    return when {
        // locals are limited to lexical scope
        this.isLocal() -&gt; this.parentDeclaration == other
        // file visibility or member
        this.isPrivate() -&gt; {
            this.parentDeclaration == other.parentDeclaration
                    || this.parentDeclaration == other
                    || (
                        this.parentDeclaration == null
                            &amp;&amp; other.parentDeclaration == null
                            &amp;&amp; this.containingFile == other.containingFile
                    )
        }
        this.isPublic() -&gt; true
        this.isInternal() &amp;&amp; other.containingFile != null &amp;&amp; this.containingFile != null -&gt; true
        else -&gt; false
    }
}
</code></pre>
<h3><a id="%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注解处理</h3>
<pre><code class="language-kotlin">// Find out suppressed names in a file annotation:
// @file:kotlin.Suppress(&quot;Example1&quot;, &quot;Example2&quot;)
fun KSFile.suppressedNames(): List&lt;String&gt; {
    val ignoredNames = mutableListOf&lt;String&gt;()
    annotations.forEach {
        if (it.shortName.asString() == &quot;Suppress&quot; &amp;&amp; it.annotationType.resolve()?.declaration?.qualifiedName?.asString() == &quot;kotlin.Suppress&quot;) {
            it.arguments.forEach {
                (it.value as List&lt;String&gt;).forEach { ignoredNames.add(it) }
            }
        }
    }
    return ignoredNames
}
</code></pre>
<h2><a id="%E4%B8%8Ekapt%E6%AF%94%E8%BE%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与KAPT比较</h2>
<p>KSP API相对于KAPT的主要优势有两个</p>
<ol>
<li>KSP实在kotlinc的同时解析APT，而KAPT需要增加额外处理，所以前者的性能更高</li>
<li>KAPT让然依托Java的AST，而KSP更加聚焦Kotlin的AST，对Kotlin更友好</li>
</ol>
<p>为什么KAPT需要额外处理？KAPT发生在javac之前，所以需要基于源码而非字节码进行AST分析，重新写一套AST分析器显然工作量巨大。KAPT的做法是尽量复用APT的注解处理逻辑，APT只接受Java，这就需要增加将Kotlin预编成Java的处理，这个处理将会增加1/3的额外时间开销。</p>
<p>但是KAPT不依托Java的AST，所以不需要上述开销。性能方面的提升将会是KSP相对于KAPT的最大优势。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Gradle.html'>Gradle</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16302951494103.html">
                
                  <h1>WidgetsBindingObserver监测页面生命周期</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>通过实现WidgetsBindingObserver， 并且调用WidgetsBinding.instance.addObserver(this)添加观察者.</p>
<pre><code class="language-dart">class FlutterLifeCycleState extends State&lt;FlutterLifeCycle&gt;
    with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this); //添加观察者
  }

  ///生命周期变化时回调
//  resumed:应用可见并可响应用户操作
//  inactive:用户可见，但不可响应用户操作
//  paused:已经暂停了，用户不可见、不可操作
//  suspending：应用被挂起，此状态IOS永远不会回调
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    print(&quot;@@@@@@@@@  didChangeAppLifecycleState: $state&quot;);
  }

  ///当前系统改变了一些访问性活动的回调
  @override
  void didChangeAccessibilityFeatures() {
    super.didChangeAccessibilityFeatures();
    print(&quot;@@@@@@@@@ didChangeAccessibilityFeatures&quot;);
  }

  /// Called when the system is running low on memory.
  ///低内存回调
  @override
  void didHaveMemoryPressure() {
    super.didHaveMemoryPressure();
    print(&quot;@@@@@@@@@ didHaveMemoryPressure&quot;);
  }

  /// Called when the system tells the app that the user's locale has
  /// changed. For example, if the user changes the system language
  /// settings.
  ///用户本地设置变化时调用，如系统语言改变
  @override
  void didChangeLocales(List&lt;Locale&gt; locale) {
    super.didChangeLocales(locale);
    print(&quot;@@@@@@@@@ didChangeLocales&quot;);
  }

  /// Called when the application's dimensions change. For example,
  /// when a phone is rotated.
  ///应用尺寸改变时回调，例如旋转
  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    Size size = WidgetsBinding.instance.window.physicalSize;
    print(&quot;@@@@@@@@@ didChangeMetrics  ：宽：${size.width} 高：${size.height}&quot;);
  }

  /// {@macro on_platform_brightness_change}
  @override
  void didChangePlatformBrightness() {
    super.didChangePlatformBrightness();
    print(&quot;@@@@@@@@@ didChangePlatformBrightness&quot;);
  }

  ///文字系数变化
  @override
  void didChangeTextScaleFactor() {
    super.didChangeTextScaleFactor();
    print(
        &quot;@@@@@@@@@ didChangeTextScaleFactor  ：${WidgetsBinding.instance.window.textScaleFactor}&quot;);
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      child: Center(
        child: Text(&quot;flutter&quot;),
      ),
    );
  }

  @override
  void dispose() {
    super.dispose();
    WidgetsBinding.instance.removeObserver(this); //销毁观察者
  }
}
</code></pre>
<p><strong>日志</strong></p>
<pre><code class="language-plain_text">//屏幕旋转
//竖屏切横屏
//2019-05-22 09:04:58.350 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeLocales
//2019-05-22 09:04:58.353 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeTextScaleFactor  ：1.0
//2019-05-22 09:04:58.354 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangePlatformBrightness
//2019-05-22 09:04:58.401 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeLocales
//2019-05-22 09:04:58.402 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeTextScaleFactor  ：1.0
//2019-05-22 09:04:58.402 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangePlatformBrightness
//2019-05-22 09:04:58.404 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeMetrics  ：宽：1080.0 高：2280.0
//2019-05-22 09:04:58.405 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeMetrics  ：宽：2198.0 高：1080.0
//横屏切竖屏
//2019-05-22 09:05:05.714 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeLocales
//2019-05-22 09:05:05.715 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeTextScaleFactor  ：1.0
//2019-05-22 09:05:05.715 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangePlatformBrightness
//2019-05-22 09:05:05.766 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeLocales
//2019-05-22 09:05:05.767 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeTextScaleFactor  ：1.0
//2019-05-22 09:05:05.767 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangePlatformBrightness
//2019-05-22 09:05:05.768 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeMetrics  ：宽：2198.0 高：1080.0
//2019-05-22 09:05:05.769 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeMetrics  ：宽：1080.0 高：2280.0

//改变系统语言，回到应用才调用以下方法
//2019-05-22 09:08:04.428 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeLocales
//2019-05-22 09:08:04.429 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangeTextScaleFactor  ：1.0
//2019-05-22 09:08:04.429 27881-27901/com.yourcompany.test1 I/flutter: @@@@@@@@@ didChangePlatformBrightness


//  inactive:用户可见，但不可响应用户操作
//  resumed:应用可见并可响应用户操作
//  paused:已经暂停了，用户不可见、不可操作
//  suspending：应用被挂起，此状态IOS永远不会回调

//  Home键退出，锁屏
//  2019-05-22 08:29:26.321 27526-27546/com.yourcompany.test1 I/flutter:  AppLifecycleState.inactive
//  2019-05-22 08:29:26.378 27526-27546/com.yourcompany.test1 I/flutter: AppLifecycleState.paused
//  Home键退出后再点击应用图标启动，解锁屏幕
//  2019-05-22 08:30:37.533 27526-27546/com.yourcompany.test1 I/flutter: AppLifecycleState.inactive
//  2019-05-22 08:30:37.535 27526-27546/com.yourcompany.test1 I/flutter: AppLifecycleState.resumed
//  进入该页面或者back键退出该页面，没有调用didChangeAppLifecycleState方法
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Flutter.html'>Flutter</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16315844888626.html">
                
                  <h1>Android内存中的RSS、PSS、USS</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在dumpsys meminfo中经常能看到以下指标：</p>
<p><img src="media/16315844888626/16315845125048.jpg" alt="" /></p>
<p>可以看到有PSS的指标。而使用ps时，有时候还能看到RSS,USS。那这些指标代表什么意思呢？</p>
<h2><a id="%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E8%B6%B3%E8%BF%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算内存足迹</h2>
<p>首先，我们得知道kernel会追踪系统中所有的内存页面的内存分配。</p>
<p><img src="media/16315844888626/16315846525561.jpg" alt="" /></p>
<p>在计算app使用了多少内存时，系统需要统计共享页面（shared pages）。App在访问同一个service或者library的时候会共享内存页面。比如，Google地图和一个游戏app可能会共享一个定位服务。这使得在决定每个app独占多少内存时变得十分困难。</p>
<p><img src="media/16315844888626/16315847039260.jpg" alt="" /></p>
<p>因此在为一个app计算内存足迹时，可以使用以下任意指标。</p>
<ul>
<li><strong>Resident Set Size(RSS)</strong>:app使用的任意内存页面数量，包括shared 和 non-shared pages.</li>
<li><strong>Proportional Set Size(PSS)</strong>:app使用的non-shared pages，以及使用的shared page的平均值。比如，如果三个进程共享3MB，则认为每个进程平均占用1MB。也就是按比例的（Proportional）。</li>
<li><strong>Unique Set Size(USS)</strong>:app使用的non-shared pages，shared pages被排除在外。</li>
</ul>
<p>PSS在操作系统想知道所有进程使用了多少内存时是十分有用的。但在计算PSS时由于区分哪部分被共享，因此比较耗时。RSS的话不需要区分shared和non-shared pages的差异，因此计算起来更快。同时在追踪内存分配变化时会显得比较实用。最后，可以使用RSS-USS得出共享部分占用的内存大小，如果USS较小而计算得出来的差值很大，那么可以认为共享部分占用的内存过大了。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html'>性能优化</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16315849706434.html">
                
                  <h1>ProtoBuf入门</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>之前在IMSDK以及游戏开发的过程中接触并简单使用了ProtoBuf，作为网络通信的主要序列化手段。对其他大公司的Apk进行解包，发现基本都包含ProtoBuf的依赖库。对比了通用的Json与ProtoBuf在网络连接方面的性能数据，在有大量数据量的情况下，差距尤其明显。</p>
<p>接下来主要对ProtoBuf序列化、反序列化以及使用进行一些简单的了解。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="16315849706434.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Java.html'>Java</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16329857244371.html">
                
                  <h1>Flow入门</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>打开<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.android.com%2Fjetpack">Android架构组件页面</a>我们可以发现一些最新发布的JetPack组件，如<code>Room</code>、<code>DataStore</code>、<code>Paging3</code>、<code>DataBinding</code>等都支持了<code>Flow</code>。可以看出官方也在大力推广<code>Flow</code>。</p>
<h2><a id="flow%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Flow介绍</h2>
<p>Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流。<br />
<code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 <code>RxJava</code> 非常像，二者之间也有相互转换的 API，使用起来非常方便。</p>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5flow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么引入Flow</h3>
<ul>
<li><code>LiveData</code>不支持线程切换，所有数据转换都将在主线程上完成，有时需要频繁更改线程，面对复杂数据流时处理起来比较麻烦</li>
<li><code>RxJava</code>又有些过于麻烦了，有许多让人傻傻分不清的操作符，入门门槛较高，同时需要自己处理生命周期，在生命周期结束时取消订阅</li>
</ul>
<p>可以看出，<code>Flow</code>是介于<code>LiveData</code>与<code>RxJava</code>之间的一个解决方案，它有以下特点</p>
<ul>
<li><code>Flow</code> 支持线程切换、背压</li>
<li><code>Flow</code> 入门的门槛很低，没有那么多傻傻分不清楚的操作符</li>
<li>简单的数据转换与操作符，如 <code>map</code> 等等</li>
<li>冷数据流，不消费则不生产数据,这一点与<code>LiveData</code>不同：<code>LiveData</code>的发送端并不依赖于接收端。</li>
<li>属于<code>kotlin</code>协程的一部分，可以很好的与协程基础设施结合</li>
</ul>
<p>关于Flow的使用，比较简单，有兴趣的同学可参阅文档：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fcoroutines%2Fflow.html">Flow文档</a></p>
<h2><a id="sharedflow%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SharedFlow 介绍</h2>
<p>我们上面介绍过,Flow 是冷流，什么是冷流？</p>
<ul>
<li><strong>冷流:</strong> 只有订阅者订阅时，才开始执行发射数据流的代码。并且冷流和订阅者只能是一对一的关系，当有多个不同的订阅者时，消息是重新完整发送的。也就是说对冷流而言，有多个订阅者的时候，他们各自的事件是独立的。</li>
<li><strong>热流:</strong> 无论有没有订阅者订阅，事件始终都会发生。当 热流有多个订阅者时，热流与订阅者们的关系是一对多的关系，可以与多个订阅者共享信息。</li>
</ul>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5sharedflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么引入SharedFlow</h3>
<p>上面其实已经说得很清楚了，冷流和订阅者只能是一对一的关系，当我们要实现一个流，多个订阅者的需求时(这在开发中是很常见的)，就需要热流了<br />
从命名上也很容易理解，<code>SharedFlow</code>即共享的<code>Flow</code>，可以实现一对多关系,<code>SharedFlow</code>是一种热流。</p>
<h3><a id="sharedflow%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SharedFlow的使用</h3>
<p>SharedFlow的构造函数</p>
<pre><code class="language-kotlin">public fun &lt;T&gt; MutableSharedFlow(
    replay: Int = 0,
    extraBufferCapacity: Int = 0,
    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND
): MutableSharedFlow&lt;T&gt;
</code></pre>
<ol>
<li><code>replay</code>表示当新的订阅者Collect时，发送几个已经发送过的数据给它，默认为0，即默认新订阅者不会获取以前的数据</li>
<li><code>extraBufferCapacity</code>表示减去<code>replay</code>，<code>MutableSharedFlow</code>还缓存多少数据，默认为0</li>
<li><code>onBufferOverflow</code>表示缓存策略，即缓冲区满了之后Flow如何处理，默认为挂起</li>
</ol>
<p>简单使用如下：</p>
<pre><code class="language-kotlin">//ViewModel
val sharedFlow=MutableSharedFlow&lt;String&gt;()

viewModelScope.launch{
      sharedFlow.emit(&quot;Hello&quot;)
      sharedFlow.emit(&quot;SharedFlow&quot;)
}

//Activity
lifecycleScope.launch{
    viewMode.sharedFlow.collect { 
       print(it)
    }
}
</code></pre>
<h3><a id="%E5%B0%86%E5%86%B7%E6%B5%81%E8%BD%AC%E5%8C%96%E4%B8%BAsharedflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将冷流转化为SharedFlow</h3>
<p>普通<code>flow</code>可使用<code>shareIn</code>扩展方法，转化成<code>SharedFlow</code></p>
<pre><code class="language-kotlin">    val sharedFlow by lazy {
        flow&lt;Int&gt; {
        //...
        }.shareIn(viewModelScope, WhileSubscribed(500), 0)
    }
</code></pre>
<p>shareIn主要也有三个参数：</p>
<blockquote>
<p>@param scope 共享开始时所在的协程作用域范围<br />
@param started 控制共享的开始和结束的策略<br />
@param replay 状态流的重播个数</p>
</blockquote>
<p>started 接受以下的三个值:</p>
<ol>
<li><strong>Lazily:</strong> 当首个订阅者出现时开始，在scope指定的作用域被结束时终止。</li>
<li><strong>Eagerly:</strong> 立即开始，而在scope指定的作用域被结束时终止。</li>
<li><strong>WhileSubscribed:</strong> 这种情况有些复杂，后面会详细讲解</li>
</ol>
<p>对于那些只执行一次的操作，您可以使用<code>Lazily</code>或者<code>Eagerly</code>。然而，如果您需要观察其他的流，就应该使用<code>WhileSubscribed</code>来实现细微但又重要的优化工作</p>
<h3><a id="whilesubscribed%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Whilesubscribed策略</h3>
<p>WhileSubscribed策略会在没有收集器的情况下取消上游数据流,通过shareIn运算符创建的SharedFlow会把数据暴露给视图 (View)，同时也会观察来自其他层级或者是上游应用的数据流。</p>
<p>让这些流持续活跃可能会引起不必要的资源浪费，例如一直通过从数据库连接、硬件传感器中读取数据等等。当您的应用转而在后台运行时，您应当保持克制并中止这些协程。</p>
<pre><code class="language-kotlin">public fun WhileSubscribed(
   stopTimeoutMillis: Long = 0,
   replayExpirationMillis: Long = Long.MAX_VALUE
)
</code></pre>
<p>如上所示，它支持两个参数：</p>
<ol>
<li><code>stopTimeoutMillis</code> 控制一个以毫秒为单位的延迟值，指的是最后一个订阅者结束订阅与停止上游流的时间差。默认值是 0 (立即停止).这个值非常有用，因为您可能并不想因为视图有几秒钟不再监听就结束上游流。这种情况非常常见——比如当用户旋转设备时，原来的视图会先被销毁，然后数秒钟内重建。</li>
<li><code>replayExpirationMillis</code> 表示数据重播的过时时间，如果用户离开应用太久，此时您不想让用户看到陈旧的数据，你可以用到这个参数</li>
</ol>
<h2><a id="stateflow%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>StateFlow 介绍</h2>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5stateflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么引入StateFlow</h3>
<p><code>StateFlow</code> 是 <code>SharedFlow</code> 的一个比较特殊的变种，<code>StateFlow</code> 与 <code>LiveData</code> 是最接近的，因为:</p>
<ol>
<li>它始终是有值的。</li>
<li>它的值是唯一的。</li>
<li>它允许被多个观察者共用 (因此是共享的数据流)。</li>
<li>它永远只会把最新的值重现给订阅者，这与活跃观察者的数量是无关的。</li>
</ol>
<p>可以看出，<code>StateFlow</code>与<code>LiveData</code>是比较接近的，可以获取当前的值，可以想像之所以引入<code>StateFlow</code>就是为了替换<code>LiveData</code></p>
<p>总结如下：</p>
<ol>
<li><code>StateFlow</code>继承于<code>SharedFlow</code>,是<code>SharedFlow</code>的一个特殊变种</li>
<li><code>StateFlow</code>与<code>LiveData</code>比较相近，相信之所以推出就是为了替换<code>LiveData</code></li>
</ol>
<h3><a id="stateflow%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>StateFlow的简单使用</h3>
<pre><code class="language-kotlin">public fun &lt;T&gt; MutableStateFlow(value: T): MutableStateFlow&lt;T&gt; = StateFlowImpl(value ?: NULL)
</code></pre>
<ol>
<li><code>StateFlow</code>构造函数较为简单，只需要传入一个默认值</li>
<li><code>StateFlow</code> 本质上是一个replay为1，并且没有缓冲区的SharedFlow,因此第一次订阅时会先获得默认值</li>
<li><code>StateFlow</code> 仅在值已更新，并且值发生了变化时才会返回，即如果更新后的值没有变化，也没会回调<code>Collect</code>方法，这点与<code>LiveData</code>不同</li>
</ol>
<p>与<code>SharedFlow</code>类似，我们也可以用<code>stateIn</code>将普通流转化成<code>StateFlow</code></p>
<pre><code class="language-kotlin">val result: StateFlow&lt;Result&lt;UiState&gt;&gt; = someFlow
    .stateIn(
        scope = viewModelScope, 
        started = WhileSubscribed(5000), 
        initialValue = Result.Loading
    )
</code></pre>
<p>与shareIn类似，唯一不同的时需要传入一个默认值<br />
同时之所以WhileSubscribed中传入了5000，是为了实现等待5秒后仍然没有订阅者存在就终止协程的功能，这个方法有以下功能</p>
<ul>
<li>用户将您的应用转至后台运行，5 秒钟后所有来自其他层的数据更新会停止，这样可以节省电量。</li>
<li>最新的数据仍然会被缓存，所以当用户切换回应用时，视图立即就可以得到数据进行渲染。</li>
<li>订阅将被重启，新数据会填充进来，当数据可用时更新视图。</li>
<li>在屏幕旋转时，因为重新订阅的时间在5s内，因此上游流不会中止</li>
</ul>
<h3><a id="%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E8%A7%82%E5%AF%9Fstateflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在页面中观察StateFlow</h3>
<p>与LiveData类似，我们也需要经常在页面中观察StateFlow<br />
观察StateFlow需要在协程中，因此我们需要协程构建器，一般我们会使用下面几种</p>
<ol>
<li><code>lifecycleScope.launch</code> : 立即启动协程，并且在本 Activity或Fragment 销毁时结束协程。</li>
<li><code>LaunchWhenStarted</code> 和 <code>LaunchWhenResumed</code>,它会在<code>lifecycleOwner</code>进入X状态之前一直等待，又在离开X状态时挂起协程</li>
</ol>
<p><img src="media/16329857244371/16329896689258.jpg" alt="" /></p>
<p>1.使用<code>launch</code>是不安全的，在应用在后台时也会接收数据更新，可能会导致应用崩溃<br />
2.使用<code>launchWhenStarted</code>或<code>launchWhenResumed</code>会好一些，在后台时不会接收数据更新，但是，上游数据流会在应用后台运行期间保持活跃，因此可能浪费一定的资源</p>
<blockquote>
<p>官方推荐<code>repeatOnLifecycle</code>来构建协程</p>
</blockquote>
<p>在某个特定的状态满足时启动协程，并且在生命周期所有者退出该状态时停止协程,如下图所示。</p>
<p><img src="media/16329857244371/16329898715519.jpg" alt="" /></p>
<p>比如在某个Fragment的代码中:</p>
<pre><code class="language-kotlin">onCreateView(...) {
    viewLifecycleOwner.lifecycleScope.launch {
        viewLifecycleOwner.lifecycle.repeatOnLifecycle(STARTED) {
            myViewModel.myUiState.collect { ... }
        }
    }
}
</code></pre>
<p>当这个Fragment处于STARTED状态时会开始收集流，并且在RESUMED状态时保持收集，最终在Fragment进入STOPPED状态时结束收集过程。<br />
结合使用repeatOnLifecycle API和WhileSubscribed,可以帮助您的应用妥善利用设备资源的同时，发挥最佳性能</p>
<h2><a id="stateflow%E4%B8%8Esharedflow%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>StateFlow与SharedFlow有什么区别？</h2>
<ol>
<li>SharedFlow配置更为灵活，支持配置replay,缓冲区大小等，StateFlow是SharedFlow的特化版本，replay固定为1，缓冲区大小默认为0</li>
<li>StateFlow与LiveData类似，支持通过myFlow.value获取当前状态，如果有这个需求，必须使用StateFlow</li>
<li>SharedFlow支持发出和收集重复值，而StateFlow当value重复时，不会回调collect</li>
<li>对于新的订阅者，StateFlow只会重播当前最新值，SharedFlow可配置重播元素个数（默认为0，即不重播）</li>
</ol>
<p>可以看出,StateFlow为我们做了一些默认的配置，在SharedFlow上添加了一些默认约束，这些配置可能并不符合我们的要求</p>
<ol>
<li>它忽略重复的值，并且是不可配置的。这会带来一些问题，比如当往List中添加元素并更新时，StateFlow会认为是重复的值并忽略</li>
<li>它需要一个初始值，并且在开始订阅时会回调初始值，这有可能不是我们想要的</li>
<li>它默认是粘性的，新用户订阅会获得当前的最新值，而且是不可配置的,而SharedFlow可以修改replay</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16336597951988.html">
                
                  <h1>性能分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="app%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>APP启动时间分析</h2>
<pre><code class="language-plain_text">adb shell am start -S -R 10 -W com.weipaitang.wpt/com.weipaitang.wpt.wptnative.module.launch.SplashActivity
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html'>性能优化</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_14.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_16.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/16898402251241/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style><script>window.MathJax = {     tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } ,     startup: {     pageReady() {       return MathJax.startup.defaultPageReady().then(function () {          window.mweb_mathjax_ready_val = 'yes';          if(window.mweb_mathjax_ready !== undefined){ mweb_mathjax_ready(); }       });     }   }};document.addEventListener('DOMContentLoaded', function(event) {    if (typeof Prism != 'undefined') {         Prism.highlightAll();     }});window.mweb_mathjax_ready_val = '';function theMWebMathJaxRenderIsReady(key){ return window.mweb_mathjax_ready_val; }</script><script>window.MathJax = { tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } }; </script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
