<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.ifantastic.ink ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207869436.html">
                
                  <h1>Android-Issues</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>这篇文章主要记录一些在实际开发中遇到的问题，以及对其的解决措施。方便日后解决同样类型的问题。</p>
<h2><a id="activity%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Activity的使用</h2>
<h3><a id="1%E3%80%81onsaveinstance%E5%92%8C-onrestoreinstancestate" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、onSaveInstance 和 onRestoreInstanceState</h3>
<p>onSaveInstance方法在系统回收Activity之前会调用；Back键不会调用。onPause（）—&gt;<code>onSaveInstanceState( )</code>–&gt;onStop( );<code>onRestoreInstanceState()</code>会在onStart()和onResume()之间执行。</p>
<ul>
<li>1、当用户按下HOME键时。这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</li>
<li>2、长按HOME键，选择运行其他的程序时。</li>
<li>3、按下电源按键（关闭屏幕显示）时。</li>
<li>4、从activity A中启动一个新的activity时。</li>
<li>5、屏幕方向切换时，例如从竖屏切换到横屏时。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</li>
</ul>
<p>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和 onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提 是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。<br />
activity中保存数据有两种方式onPause()，onSaveInstance(bundle),  恢复数据也有两种途径onCreate(Bundle), onRestoreInstanceState(budle)，默认情况下onSaveInstanceSate()和onRestoreInstanceState()会对UI状态进行保存和恢复，如果需要保存其他数据可以在onSaveInstanceState()，onPause()保存，但是如果是持久化的数据得通过onPause()保存(google推荐)。</p>
<h2><a id="%E4%BA%8C%E3%80%81fragment%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、Fragment使用</h2>
<h3><a id="1%E3%80%81-java-lang-illegalstateexception-fragment-does-not-have-a-view" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、<code>java.lang.IllegalStateException: Fragment does not have a view</code></h3>
<p>先说明下出现这个异常的原因，这是在<code>fragment onCreateView()</code>中调用<code>getChildFragmentManager()</code>的时候出现的。解决办法就是不要再onCreateView()中调用<code>getChildFragmentManager()</code>。那么如果你要调用<code>getChildFragmentManager()</code>，那么必须onCreateView之后，view被创建了。</p>
<h2><a id="%E4%B8%89%E3%80%81ui%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、UI控件</h2>
<h3><a id="1%E3%80%81button%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、Button控件</h3>
<h4><a id="%EF%BC%881%EF%BC%89%E8%A7%A3%E5%86%B3android5-0%E7%89%88%E6%9C%AC%E4%BB%A5%E4%B8%8Abutton%E8%87%AA%E5%B8%A6%E9%98%B4%E5%BD%B1%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（1）解决Android5.0版本以上Button自带阴影问题</h4>
<p>设置Button的样式为<code>style=&quot;?android:attr/borderlessButtonStyle&quot;</code></p>
<h3><a id="2%E3%80%81textview%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、TextView控件</h3>
<h4><a id="%EF%BC%881%EF%BC%89text-view%E4%B8%AD%E4%BF%AE%E6%94%B9%E6%96%87%E5%AD%97%E6%AE%B5%E8%90%BD%E4%B8%AD%E9%83%A8%E5%88%86%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（1）Text View中修改文字段落中部分字体颜色</h4>
<p>使用ForegroundColorSpan来修改</p>
<h3><a id="3%E3%80%81checkbox%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、CheckBox控件</h3>
<h4><a id="%EF%BC%881%EF%BC%89%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%8D%E9%80%89%E6%A1%86%E7%9A%84%E6%A0%B7%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（1）如何修改复选框的样式</h4>
<ul>
<li>首先在drawable文件夹中添加drawable文件checkbox_style.xml。</li>
</ul>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  
    &lt;item android:drawable=&quot;@drawable/checkbox_pressed&quot; android:state_checked=&quot;true&quot;/&gt;  
    &lt;item android:drawable=&quot;@drawable/checkbox_normal&quot; android:state_checked=&quot;false&quot;/&gt;  
    &lt;item android:drawable=&quot;@drawable/checkbox_normal&quot;/&gt;  
&lt;/selector&gt;
</code></pre>
<ul>
<li>在values文件夹下的styles.xml文件中添加CustomCheckboxTheme样式。</li>
</ul>
<pre class="line-numbers"><code class="language-xml">&lt;style name=&quot;CustomCheckboxTheme&quot; parent=&quot;@android:style/Widget.CompoundButton.CheckBox&quot;&gt;  
    &lt;item name=&quot;android:button&quot;&gt;@drawable/checkbox_style&lt;/item&gt;  
&lt;/style&gt;
</code></pre>
<ul>
<li>在布局文件中使用CustomCheckboxTheme样式。</li>
</ul>
<pre class="line-numbers"><code class="language-xml">&lt;CheckBox  
    android:id=&quot;@+id/select_all&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    style=&quot;@style/CustomCheckboxTheme&quot; /&gt;
</code></pre>
<h3><a id="4%E3%80%81recyclerview%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、RecyclerView控件</h3>
<h4><a id="%EF%BC%881%EF%BC%89recyclerview%E5%88%A0%E9%99%A4item%E5%AF%BC%E8%87%B4%E4%BD%8D%E7%BD%AE%E9%94%99%E4%B9%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（1）RecyclerView删除Item导致位置错乱</h4>
<p>RecyclerView的刷新分为内容变化和结构变化，结构变化比如remove和insert等并不会导致viewholder的更新，所以有时候我们使用<code> notifyItemRemoved(position);</code>或者使用<code> notifyItemInserted(position);</code>item的位置并没有发生改变，或者位置发生错乱，很是奇怪诡异，需要重新调用<code> notifyDataSetChanged();</code>才能刷新整个List每个Item的位置，但这样做会使得RecyclerView增加和删除的动画效果没有了。那么要既想没有Bug的插入删除，又想有动画怎么搞呢，只需要刷新删除位置以下的List的Item位置即可，那么幸亏RecyclerView有一个局部刷新的方法：<code>notifyItemRangeChanged(int positionStart, int itemCount)</code>怎么使用呢？ 我们只需要在删除或插入时同时,刷新改变位置item下方的所有Item的位置： 插入动作：</p>
<pre class="line-numbers"><code class="language-java">notifyItemInserted(position);
if (position != mData.size()) {
   otifyItemRangeChanged(position, mData.size() - position);
 }
</code></pre>
<p>删除动作：</p>
<pre class="line-numbers"><code class="language-java"> notifyItemRemoved(position);
if (position != mData.size()) {
   otifyItemRangeChanged(position, mData.size() - position);
 }
</code></pre>
<h4><a id="%EF%BC%882%EF%BC%89recyclerview%E5%8F%AA%E6%98%BE%E7%A4%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（2）RecyclerView只显示第一个数据</h4>
<p>在<code>onCreateViewHolder</code>中获取View的时候不指定<code>ViewGroup</code></p>
<pre class="line-numbers"><code class="language-java">@Override  
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  
    LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext());  
    View convertView = layoutInflater.inflate(R.layout.item, null, false); // if use parent, only first line will show up  
    return new ViewHolder(convertView);  
}
</code></pre>
<h3><a id="5%E3%80%81edittext%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5、EditText控件</h3>
<h4><a id="%EF%BC%881%EF%BC%89%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80%E8%BD%AF%E9%94%AE%E7%9B%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（1）如何自动打开软键盘</h4>
<h2><a id="%E5%9B%9B%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、自定义View的实现</h2>
<h3><a id="1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89textview%E6%97%B6%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、自定义TextView时，自定义参数的设置</h3>
<p>自定义属性一般在<code>onMeasure()</code>方法后才能将XML文件中的自定义设置的属性数值传递进来，无法在<code>setBackground()</code>方法和<code>setText()</code>方法直接调用。如果是想要在代码中设置变量属性，还是直接在自定义控件扩展类中添加新方法进行使用。自定义控件的三个构造类</p>
<pre class="line-numbers"><code class="language-java">public GuideTextView(Context context) //在代码中直接使用
public GuideTextView(Context context, AttributeSet attrs) //在xml文件中直接使用时调用
public GuideTextView(Context context, AttributeSet attrs, int defStyleAttr) //xml文件中使用默认主题时调用
</code></pre>
<h3><a id="2%E3%80%81%E6%89%A9%E5%B1%95%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、扩展自定义View的实现</h3>
<p>在<code>onDraw()</code>方法中，将绘制代码写在<code>super.onDraw(canvas);</code>方法之前，绘制效果将显示在控件底层；将绘制代码写在<code>super.onDraw(canvas);</code>方法之后，绘制效果将显示在控件底层。</p>
<h3><a id="3%E3%80%81getdimension%E3%80%81-getdimensionpixeloffset%E5%92%8C-getdimensionpixelsize%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、getDimension()、getDimensionPixelOffset()和getDimensionPixelSize()的区别</h3>
<ul>
<li><code>getDimension()</code>是基于当前DisplayMetrics进行转换，获取指定资源id对应的尺寸。文档里并没说这里返回的就是像素，要注意这个函数的返回值是float，像素肯定是int。</li>
<li><code>getDimensionPixelSize()</code>与<code>getDimension()</code>功能类似，不同的是将结果转换为int，并且小数部分四舍五入。</li>
<li><code>getDimensionPixelOffset()</code>与<code>getDimension()</code>功能类似，不同的是将结果转换为int，并且偏移转换（offset conversion，函数命名中的offset是这个意思）是直接截断小数位，即取整（其实就是把float强制转化为int，注意不是四舍五入哦）。<br />
由此可见，这三个函数返回的都是绝对尺寸，而不是相对尺寸（dp/sp等）。如果getDimension()返回结果是20.5f，那么<code>getDimensionPixelSize()</code>返回结果就是21，<code>getDimensionPixelOffset()</code>返回结果就是20。</li>
</ul>
<h3><a id="4%E3%80%81displaymetrics%E6%98%BE%E7%A4%BA%E7%9A%84%E6%95%B0%E5%80%BC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4、DisplayMetrics显示的数值</h3>
<ul>
<li><em>density</em>: 显示的逻辑分辨率</li>
<li><em>width</em>及<em>height</em>: 屏幕分辨率(绝对宽高)</li>
<li><em>scaleDensity</em>: 字体显示的缩放因子</li>
<li><em>xdpi</em>及<em>ydpi</em>: 水平方向DPI和竖直方向DPI</li>
</ul>
<h3><a id="5%E3%80%81%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5、屏幕尺寸单位</h3>
<ul>
<li>屏幕尺寸: 屏幕尺寸指屏幕的对角线的长度，单位是英寸(in)，1英寸=2.54厘米</li>
<li>px: 是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素，一般以纵向像素*横向像素。</li>
<li>dpi: dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。</li>
<li>density: 屏幕密度，density和dpi的关系为 density = dpi/160</li>
<li>dp和dip: 设备独立像素，device independent pixels的缩写， <a href="http://lib.csdn.net/base/android">Android</a> 特有的单位，在屏幕密度dpi = 160屏幕上，1dp = 1px。dp和density的关系为 1dp = density px，dip值 =（dpi值/160）* pixel值</li>
<li>sp: 和dp很类似，一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。</li>
</ul>
<h3><a id="6%E3%80%81edittext%E5%90%AF%E5%8A%A8%E8%BD%AF%E9%94%AE%E7%9B%98%E6%80%8E%E4%B9%88%E5%92%8Cedittext%E5%B8%83%E5%B1%80%E4%B8%80%E8%B5%B7%E4%B8%8A%E7%A7%BB%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%83%8C%E6%99%AF%E4%B8%8D%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6、EditText启动软键盘怎么和EditText布局一起上移，并且背景不动</h3>
<p>在根布局中添加ScrollView来存放背景显示内容，中间必须添加一个RelativeLayout或者LinearLayout(如果添加RelativeLayout则ScrollView必须设置属性<code>android:fillViewport=&quot;true&quot;</code>)，在ScrollView控件底下添加EditText所在布局，设置AndroidManifest.xml中<code>android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot;</code>，在代码中设置RelativeLayout中的显示布局的布局属性。</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.jrm.adolph.test1.MainActivity&quot;&gt;
    &lt;ScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:fillViewport=&quot;true&quot;&gt;
        &lt;RelativeLayout
            android:id=&quot;@+id/layout&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;

            &lt;RelativeLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;64dp&quot;
                android:background=&quot;@color/colorAccent&quot;&gt;
                &lt;TextView
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_centerInParent=&quot;true&quot;
                    android:text=&quot;软键盘&quot;
                    android:textSize=&quot;20sp&quot;/&gt;
            &lt;/RelativeLayout&gt;
            &lt;RelativeLayout
                android:id=&quot;@+id/content_layout&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;&gt;
                &lt;TextView
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:text=&quot;Hello World!&quot;
                    android:layout_centerInParent=&quot;true&quot;
                    android:textSize=&quot;20sp&quot;/&gt;
            &lt;/RelativeLayout&gt;
        &lt;/RelativeLayout&gt;
    &lt;/ScrollView&gt;
    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;48dp&quot;
        android:layout_alignParentBottom=&quot;true&quot;&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;送礼&quot;/&gt;
        &lt;EditText
            android:id=&quot;@+id/et&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_weight=&quot;1&quot;/&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;发送&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/RelativeLayout&gt;
</code></pre>
<pre class="line-numbers"><code class="language-java">Rect outRect = new Rect();
getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect);
RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) layout.getLayoutParams();
params.height = outRect.bottom - outRect.top;
layout.setLayoutParams(params);
</code></pre>
<h3><a id="7%E3%80%81%E8%AE%BE%E7%BD%AEbutton%E7%9A%84selector%E6%8E%A7%E5%88%B6%E6%8C%89%E9%92%AE%E7%9A%84%E7%82%B9%E5%87%BB%E5%BD%A2%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7、设置Button的selector控制按钮的点击形态</h3>
<p>设置好press、enable属性的对应图片，点击按钮图片形态不响应。必须把默认的按钮图片样式放在最底下，才能实现。</p>
<pre class="line-numbers"><code class="language-xml">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_pressed_btn&quot; android:state_pressed=&quot;true&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_unable_btn&quot; android:state_enabled=&quot;false&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_focusable_btn&quot;/&gt;
&lt;/selector&gt;
</code></pre>
<h3><a id="8%E3%80%81dispatchtouchevent" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8、DispatchTouchEvent</h3>
<p>重写dispatchTouchEvent的时候，无论你是return true，亦或是return false都会导致child接受不到事件。<br />
<code>return true</code> ： 告诉parent，这个事件我消费了。如果这个是down事件，那么我就会作为一个target或者说handle(事件持有者)，后续的move事件或者up事件等，都会直接分发到我这里，不继续往下分发。 <br />
<code>return false</code>：告诉parent，这个事件我不需要，那么会交回给parent的onTouchEvnet处理。只有return <code>super.dispatchTouchEvent</code>的时候才会将事件继续往下传递。<br />
<figure><img src="media/15561207869436/15713067993235.jpg" alt="" /></figure></p>
<h2><a id="%E4%BA%94%E3%80%81android%E7%B1%BB%E5%BA%93%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、Android类库使用问题</h2>
<h3><a id="1%E3%80%81android-databinding" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、Android DataBinding</h3>
<h4><a id="%EF%BC%881%EF%BC%89include%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%98%E9%87%8F%E8%BF%9B%E5%8E%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（1）include布局使用，如何传变量进去</h4>
<p>include布局中同样用layout标签包裹，将父布局中的变量以</p>
<pre class="line-numbers"><code class="language-plain_text">app:XXX=&quot;@{XXX}&quot;
</code></pre>
<p>自定义属性的形式传进去,并在include布局中同样申明XXX相同的变量名以及变量类型，即可进行使用。注意使用在表达式中使用View.VISIBLE设置可视化的时候导入View类，否则会报错。</p>
<h4><a id="%EF%BC%882%EF%BC%89%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8include%E4%B8%AD%E7%9A%84%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（2）如何调用include中的控件</h4>
<p>普通调用include中的控件，直接使用<code>findViewById</code>可以直接获取控件。使用dataBinding时，有时会出现获取控件无法调用的情况，这种情况给include标签赋一个id，在类中通过<code>bind.&lt;include-id&gt;.&lt;widget-id&gt;</code>进行调用。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/05/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869292.html">
                
                  <h1>EventBus 3.0的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>一直用Handler来处理应用内的通信，但是发现局限性还是太大了。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。</p>
<h2><a id="%E4%BD%BF%E7%94%A8eventbus" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用EventBus</h2>
<h3><a id="%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加依赖库</h3>
<p><code>compile 'org.greenrobot:eventbus:3.0.0'</code></p>
<h3><a id="%E6%B3%A8%E5%86%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注册</h3>
<p>举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。</p>
<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    EventBus.getDefault().register(this);

}
@Override
protected void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
}
</code></pre>
<h3><a id="%E8%AE%A2%E9%98%85%E8%80%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>订阅者</h3>
<p>类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了:</p>
<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(String message){
    mText.setText(message);
}
</code></pre>
<p>该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：<br />
我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？</p>
<h3><a id="%E5%8F%91%E5%B8%83%E8%80%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发布者</h3>
<p>既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：</p>
<pre class="line-numbers"><code class="language-java">String json=&quot;&quot;;
EventBus.getDefault().post(json);
</code></pre>
<p>这样就OK了，你可以试下能否正常运行了！</p>
<h2><a id="%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原理初探</h2>
<p>你订阅了内容，所以你需要在该类注册EventBus，而你订阅的方法需要传入String,即你的接收信息为String类型，那么在post的时候，你post出去的也应该是String类型，其才会接收到消息。</p>
<h3><a id="%E5%A6%82%E6%9E%9C%E4%BD%A0post%E7%9A%84%E6%98%AF%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如果你post的是对象</h3>
<p>首先你需要定义一个类似pojo类：</p>
<pre class="line-numbers"><code class="language-java">public class MessageEvent {
  public final String name;
  public final String password;
  public MessageEvent(String name,String password) {
    this.name = name;
    this.password=password;
  }
}
</code></pre>
<h3><a id="%E7%84%B6%E5%90%8E%E4%BD%A0post%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>然后你post的时候：</h3>
<p><code>EventBus.getDefault().post(new MessageEvent(&quot;hello&quot;,&quot;world&quot;));</code></p>
<h3><a id="%E5%BD%93%E7%84%B6%EF%BC%8C%E4%BD%A0%E6%8E%A5%E6%94%B6%E7%9A%84%E6%96%B9%E6%B3%95%E4%B9%9F%E9%9C%80%E8%A6%81%E6%94%B9%E4%B8%BA%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>当然，你接收的方法也需要改为：</h3>
<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(MessageEvent message){
    mText.setText(message.name);
}
</code></pre>
<h2><a id="threadmode%E6%8F%90%E4%BE%9B%E4%BA%86%E5%9B%9B%E4%B8%AA%E5%B8%B8%E9%87%8F%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ThreadMode提供了四个常量：</h2>
<ul>
<li>MainThread 主线程</li>
<li>BackgroundThread 后台线程</li>
<li>Async 后台线程</li>
<li>PostThread 发送线程（默认）</li>
</ul>
<p>BackgroundThread:当事件是在UI线程发出，那么事件处理实际上是需要新建单独线程，如果是在后台线程发出，那么事件处理就在该线程。该事件处理方法应该是快速的，避免阻塞后台线程。<br />
Async：发送事件方不需要等待事件处理完毕。这种方式适用于该事件处理方法需要较长时间，例如网络请求。</p>
<h2><a id="eventbus%E9%BB%8F%E6%80%A7%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>EventBus黏性事件</h2>
<p>EventBus除了普通事件也支持粘性事件，这个有点类似广播分类中的粘性广播。本身粘性广播用的就比较少，为了方便理解成订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅函数有所不同，需要注解中添加<code>sticky = true</code></p>
<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true) //在ui线程执行
	public void onDataSynEvent(DataSynEvent event) {
		Log.e(TAG, &quot;event----&gt;&quot; + event.getCount());
}
</code></pre>
<h3><a id="%E5%8F%91%E9%80%81%E7%B2%98%E6%80%A7%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发送粘性事件</h3>
<p><code>EventBus.getDefault().postSticky(new DataSynEvent());</code></p>
<h3><a id="%E5%AF%B9%E4%BA%8E%E7%B2%98%E6%80%A7%E5%B9%BF%E6%92%AD%E6%88%91%E4%BB%AC%E9%83%BD%E6%AF%94%E8%BE%83%E6%B8%85%E6%A5%9A%E5%B1%9E%E4%BA%8E%E5%B8%B8%E9%A9%BB%E5%B9%BF%E6%92%AD%EF%BC%8C%E5%AF%B9%E4%BA%8Eeventbus%E7%B2%98%E6%80%A7%E4%BA%8B%E4%BB%B6%E4%B9%9F%E7%B1%BB%E4%BC%BC%EF%BC%8C%E6%88%91%E4%BB%AC%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E8%AF%A5%E7%B2%98%E6%80%A7%E4%BA%8B%E4%BB%B6%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%A7%BB%E9%99%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对于粘性广播我们都比较清楚属于常驻广播，对于EventBus粘性事件也类似，我们如果不再需要该粘性事件我们可以移除</h3>
<p><code>EventBus.getDefault().removeStickyEvent(new DataSynEvent());</code></p>
<h3><a id="%E6%88%96%E8%80%85%E8%B0%83%E7%94%A8%E7%A7%BB%E9%99%A4%E6%89%80%E6%9C%89%E7%B2%98%E6%80%A7%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>或者调用移除所有粘性事件</h3>
<p><code>EventBus.getDefault().removeAllStickyEvents();</code></p>
<p>默认情况下，其为false。什么情况下使用sticky呢？<br />
当你希望你的事件不被马上处理的时候，举个栗子，比如说，在一个详情页点赞之后，产生一个VoteEvent，VoteEvent并不立即被消费，而是等用户退出详情页回到商品列表之后，接收到该事件，然后刷新Adapter等。其实这就是之前我们用startActivityForResult和onActivityResult做的事情。</p>
<h2><a id="%E8%AE%A2%E9%98%85%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>订阅事件的优先级</h2>
<p>事件的优先级类似广播的优先级，优先级越高优先获得消息</p>
<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MAIN,priority = 100) //在ui线程执行 优先级100
	public void onDataSynEvent(DataSynEvent event) {
		Log.e(TAG, &quot;event----&gt;&quot; + event.getCount());
}
</code></pre>
<h2><a id="%E7%BB%88%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%BE%80%E4%B8%8B%E4%BC%A0%E9%80%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>终止事件往下传递</h2>
<p>发送有序广播可以终止广播的继续往下传递，EventBus也实现了此功能<br />
<code>EventBus.getDefault().cancelEventDelivery(event) ;//优先级高的订阅者可以终止事件往下传递</code></p>
<h2><a id="%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建议</h2>
<p>推荐大家在使用EventBus的时候，创建一个事件类，把你的每一个参数（或者可能发生冲突的参数），封装成一个类：</p>
<pre class="line-numbers"><code class="language-java">public class Event  {  
    public static class UserListEvent {  
        public List&lt;User&gt; users ;  
    }
    public static class ItemListEvent {  
        public List&lt;Item&gt; items;  
    }    
}
</code></pre>
<h2><a id="processor%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>processor使用</h2>
<p>按照Markus Junginger的说法（EventBus创作者），在3.0中，如果你想进一步提升你的app的性能.<br />
EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析,处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.<br />
其在编译的时候为注册类构建了一个索引，而不是在运行时，这样的结果是其让EventBus 3.0的性能提升了一倍，相比2.4来说，其会是它的3到6倍。大家可以感受下：<br />
<figure><img src="media/15561207869292/15713067794323.jpg" alt="" /></figure></p>
<h3><a id="%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%EF%BC%9A%E5%9C%A8build-gradle%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>具体使用：在build.gradle中添加如下配置</h3>
<pre class="line-numbers"><code class="language-plain_text">buildscript {
    dependencies {
        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
    }
}
apply plugin: 'com.neenbedankt.android-apt'

dependencies {
    compile 'org.greenrobot:eventbus:3.0.0'
    apt 'org.greenrobot:eventbus-annotation-processor:3.0.1'
}
apt {
    arguments {
        eventBusIndex &quot;com.whoislcj.eventbus.MyEventBusIndex&quot;
    }
}
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用索引</h3>
<p>此时编译一次，自动生成生成索引类。在\build\generated\source\apt\PakageName\下看到通过注解分析生成的索引类，这样我们便可以在初始化EventBus时应用我们生成的索引了。自动生成的代码。</p>
<pre class="line-numbers"><code class="language-java">/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();

        putIndex(new SimpleSubscriberInfo(com.whoislcj.testhttp.MainActivity.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo(&quot;onDataSynEvent&quot;, com.whoislcj.testhttp.eventBus.DataSynEvent.class,
                    ThreadMode.MAIN, 100, false),
            new SubscriberMethodInfo(&quot;onDataSynEvent1&quot;, com.whoislcj.testhttp.eventBus.TestEvent.class, ThreadMode.MAIN,
                    0, true),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    @Override
    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
</code></pre>
<p>添加索引到EventBus默认的单例中<br />
<code>EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();</code></p>
<h3><a id="%E5%AF%B9%E6%AF%94%E6%B7%BB%E5%8A%A0%E5%89%8D%E5%90%8E%E6%B3%A8%E5%86%8C%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对比添加前后注册效率对比</h3>
<p>分别EventBus.getDefault().register(this);</p>
<ul>
<li>添加之前：前后用了9毫秒</li>
<li>添加之后：前后用了2毫秒</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/04/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869255.html">
                
                  <h1>GreenDao3.2.0的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>我相信，在平时的开发过程中，大家一定会或多或少地接触到SQLite。然而在使用它时，我们往往需要做许多额外的工作，像编写 SQL语句与解析查询结果等。所以，适用于Android ORM框架也就孕育而生了，现在市面上主流的框架有OrmLite、SugarORM、Active Android、Realm与greenDAO。但是使用数量最多的还是Realm与greenDAO，所以为了目前的项目需要写个文档记录一下greenDAO的使用。简单的讲，greenDAO是一个将对象映射到SQLite 数据库中的轻量且快速的ORM解决方案。（greenDAO is a light &amp; fast ORM solution that maps objects to SQLite databases.）。</p>
<p><figure><img src="media/15561207869255/15713066502027.jpg" alt="" /></figure></p>
<p>这个图对于理解greenDAO是必不可少的。</p>
<h2><a id="greendao%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>greenDAO特点</h2>
<ul>
<li>性能最大化，可能是Android平台上最快的ORM框架</li>
<li>易于使用的API</li>
<li>最小的内存开销</li>
<li>依赖体积小</li>
<li>支持数据库加密</li>
<li>强大的社区支持</li>
</ul>
<h2><a id="%E9%85%8D%E7%BD%AEgreendao" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置greenDAO</h2>
<h3><a id="%E5%9C%A8app%E7%9A%84-gradle%E4%B8%AD%E9%85%8D%E7%BD%AE%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在<code>app</code>的Gradle中配置：</h3>
<p><code>apply plugin: 'org.greenrobot.greendao'</code></p>
<pre class="line-numbers"><code class="language-plain_text">dependencies {
        compile 'org.greenrobot:greendao:3.2.0'
}
</code></pre>
<h3><a id="%E5%9C%A8project%E7%9A%84-gradle%E4%B8%AD%E9%85%8D%E7%BD%AE%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在<code>project</code>的Gradle中配置：</h3>
<pre class="line-numbers"><code class="language-plain_text">buildscript {
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath 'org.greenrobot:greendao-gradle-plugin:3.2.1' 
    }
}
</code></pre>
<h3><a id="%E5%9C%A8app%E7%9A%84gradle%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AD%89%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在app的Gradle配置数据库版本等信息</h3>
<pre class="line-numbers"><code class="language-plain_text">greendao {
    schemaVersion 1   						//对应当前数据库版本c
    daoPackage 'com.koma.greendao.gen'  //由GreenDao自动生成代码所在的包名，默认的是在项目包下面新建一个gen。
    targetGenDir 'src/main/java'        //设置自动生成代码的目录
}
</code></pre>
<h2><a id="%E4%BD%BF%E7%94%A8greendao" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用greenDAO</h2>
<h3><a id="%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用流程</h3>
<p>在项目中新建一个表字段的实体类，不需要自己写get和set方法，在生成表的时候会自动生成。不要忘了在类名上标记@Entity注解如图：</p>
<p><figure><img src="media/15561207869255/15713066625628.jpg" alt="" /></figure></p>
<p>选择build ——Make Project 一切顺利的话则会在包名下生成数据库的操作类，如下图：</p>
<p><figure><img src="media/15561207869255/15713066721049.jpg" alt="" /></figure></p>
<p>Ps:新建一个实体类，对项目进行<code>Make Project</code>，成功之后会在daoPackage目录下自动生成代码</p>
<h3><a id="%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BD%93%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在项目中定义实体类</h3>
<pre class="line-numbers"><code class="language-java">@Entity
public class User  {
    @Id(autoincrement = true)
    private Long id;
    @Property(nameInDb = &quot;USERNAME&quot;)
    private String name;
    private int age;
}
</code></pre>
<h3><a id="%E6%B3%A8%E8%A7%A3%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注解：</h3>
<ul>
<li>@Entity——————————标识实体类，greenDAO会映射成sqlite的一个表，表名为实体类名的大写形式
<ul>
<li>schema：告知GreenDao当前实体属于哪个schema</li>
<li>active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法</li>
<li>nameInDb：在数据库中使用的别名，默认使用的是实体的类名</li>
<li>indexes：定义索引，可以跨越多个列</li>
<li>createInDb：标记创建数据库表</li>
</ul>
</li>
<li>基础属性注解
<ul>
<li>@Id——————————标识主键，该字段的类型为long或Long类型，autoincrement设置是否自动增长</li>
<li>@Property——————————标识该属性在表中对应的列名称, nameInDb设置名称</li>
<li>@Transient——————————标识该属性将不会映射到表中，也就是没有这列</li>
<li>@NotNull——————————设置表中当前列的值不可为空</li>
</ul>
</li>
<li>索引注解
<ul>
<li>@Unique——————————向数据库列添加了一个唯一的约束</li>
<li>@Index——————————使用@Index作为一个属性来创建一个索引；定义多列索引(@link Entity#indexes())</li>
</ul>
</li>
<li>关系注解
<ul>
<li>@ToMany——————————定义与多个实体对象的关系</li>
<li>@ToOne——————————定义与另一个实体（一个实体对象）的关系</li>
</ul>
</li>
<li>@Convert——————————指定自定义类型(@linkPropertyConverter)</li>
<li>@Generated——————————greenDAO运行所产生的构造函数或者方法，被此标注的代码可以变更或者下次运行时清除</li>
<li>@JoinEntity——————————定义表连接关系</li>
<li>@JoinProperty——————————定义名称和引用名称属性关系</li>
<li>@Keep——————————注解的代码段在GreenDao下次运行时保持不变
<ul>
<li>注解实体类：默认禁止修改此类</li>
<li>注解其他代码段，默认禁止修改注解的代码段</li>
</ul>
</li>
<li>@OrderBy——————————指定排序</li>
</ul>
<h3><a id="%E5%88%9D%E5%A7%8B%E5%8C%96greendao" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>初始化GreenDao</h3>
<p>一般建议在Application中初始化数据库</p>
<pre class="line-numbers"><code class="language-java">private void setupDataBase(Context context){
	DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(context,DATA_BASE_NAME);
	Database db = openHelper.getWritableDb();
	DaoMaster daoMaster = new DaoMaster(db);
	mDaoSession = daoMaster.new Session();
}

public static DaoSession getDaoSession(){
	return mDaoSession;
}
</code></pre>
<p><code>DevOpenHelper</code>有两个重载方法：</p>
<ul>
<li><code>DevOpenHelper(Context context,String name)</code></li>
<li><code>DevOpenHelper(Context context,String name,CursorFactory factory)</code><br />
<code>context</code>上下文这个不用多说，<code>name</code>数据库的名字，<code>cursorFactory</code>游标工厂，一般不用，传入null或者使用两个参数的方法即可。我们对外提供一个getDaoSession()的方法供外部使用。</li>
</ul>
<h3><a id="%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E3%80%81%E5%88%A0%E3%80%81%E6%94%B9%E3%80%81%E6%9F%A5%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对数据库的增、删、改、查操作</h3>
<h4><a id="%E9%A6%96%E5%85%88%E8%8E%B7%E5%BE%97userdao%E7%9A%84%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>首先获得UserDao的对象</h4>
<p><code>UserDao userDao = GreenDaoManager.getInstance().getNewSession().getUserDao();</code></p>
<h4><a id="%E5%A2%9E%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增：</h4>
<pre class="line-numbers"><code class="language-java">User user = new User(null, name, age, studentId);
userDao.insert(user);
insert(T entity)       当指定主键在表中存在时会发生异常
insertOrReplace(T entity)      当指定主键在表中存在时会覆盖数据
insertInTx(Iterable&lt;T&gt; entities)      批量插入数据
</code></pre>
<h4><a id="%E5%88%A0%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删：</h4>
<pre class="line-numbers"><code class="language-java">User user = new User(null, name, age, studentId);    
userDao.delete(user)
 
delete(T entity)       删除数据
deleteByKey(K key)     指定主键删除数据
deleteInTx(Iterable&lt;T&gt; entities)      批量删除数据
deleteByKeyInTx(Iterable&lt;K&gt; keys)      批量按数据删除数据        
deleteAll()    删除所有数据
</code></pre>
<h4><a id="%E6%94%B9%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>改：</h4>
<pre class="line-numbers"><code class="language-java">User user = new User(id, name, age, studentId);
userDao.update(user);
 
update(T entity)       修改数据，主键需相同
updateInTx(Iterable&lt;T&gt; entities)      批量更新数据
</code></pre>
<h4><a id="%E6%9F%A5%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查：</h4>
<pre class="line-numbers"><code class="language-java">userDao.load(id)
 
load(K key)    根据id查找数据
loadByRowId(long rowId)        根据行号查找数据
loadAll()      查找全部数据
</code></pre>
<h5><a id="%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查询功能</h5>
<p>GreeDAO提供了各种各种的查询API，参见<a href="http://greenrobot.org/greendao/documentation/queries/">http://greenrobot.org/greendao/documentation/queries/</a></p>
<p><figure><img src="media/15561207869255/15713066831882.jpg" alt="" /></figure></p>
<p>如果需要在控制台查看GreenDao是怎么拼装SQL语句的，在OnCreate()方法中打开下面的开关：<br />
<figure><img src="media/15561207869255/15713066943832.jpg" alt="" /></figure></p>
<h5><a id="%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>条件查询</h5>
<pre class="line-numbers"><code class="language-java">//查询所有数据  
public void queryAll() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().list();  
}  
  
//eq: equal 精确查询  名字等于jackie  
public void queryEq() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.eq(&quot;jackie&quot;)).unique();  
}  
  
//notEq: not equal 精确查询  名字不等于jackie  
public void queryNotEq() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.notEq(&quot;jackie&quot;)).unique();  
}  
  
//like  模糊查询  名字以jackie开头  
public void queryLike() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie&quot;)).unique();  
    //通配符  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).list();  
}  
  
//between 区间查询 年龄在20到30之间  
public void queryBetween() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.between(20, 30)).list();  
}  
  
//gt: greater than 半开区间查询，年龄大于18  
public void queryGt() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.gt(18)).list();  
}  
  
//ge: greater equal 半封闭区间查询，年龄大于或者等于18  
public void queryGe() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.ge(18)).list();  
}  
  
//lt: less than 半开区间查询，年龄小于18  
public void queryLt() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.lt(18)).list();  
}  
  
//le: less equal 半封闭区间查询，年龄小于或者等于18  
public void queryLe() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.le(18)).list();  
}  
  
//名字以jackie开头，年龄升序排序  
public void queryLikeAsc() {  
    //通配符  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).orderAsc(PersonDao.Properties.Age).list();  
}  
  
//名字以jackie开头，年龄降序排序  
public void queryLikeDesc() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).orderDesc(PersonDao.Properties.Age).list();  
}  
</code></pre>
<p>当上述查询满足不了业务逻辑时，可以自定义查询语句：</p>
<p><figure><img src="media/15561207869255/15713067068458.jpg" alt="" /></figure></p>
<h5><a id="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多线程查询</h5>
<p>首先来看错误的方法：<br />
<figure><img src="media/15561207869255/15713067155848.jpg" alt="" /></figure></p>
<p>错误截图：<br />
<figure><img src="media/15561207869255/15713067289369.jpg" alt="" /></figure></p>
<p>从上面可以看出，只能在创建Query对象的线程中调用查询方法！<br />
解决方法：<br />
<figure><img src="media/15561207869255/15713067386987.jpg" alt="" /></figure></p>
<h5><a id="%E4%B8%80%E5%AF%B9%E4%B8%80%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一对一查询</h5>
<p><figure><img src="media/15561207869255/15713067480106.jpg" alt="" /></figure></p>
<h4><a id="%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一对一、一对多关系</h4>
<p>greenDAO目前只支持一对一和一对多关系，并不支持多对多关系</p>
<h5><a id="%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一对一：</h5>
<pre class="line-numbers"><code class="language-java">private Long studentId;
@ToOne(joinProperty = &quot;studentId&quot;)
private Studentstudent;
</code></pre>
<pre class="line-numbers"><code class="language-java">@Generated(hash = 313494093)
public Student getStudent() {
    Long __key = this.studentId;
    if (student__resolvedKey == null || !student__resolvedKey.equals(__key)) {
        final DaoSession daoSession = this.daoSession;
        if (daoSession == null) {
            throw new DaoException(&quot;Entity is detached from DAO context&quot;);
        }
        StudentDao targetDao = daoSession.getStudentDao();
        Student studentNew = targetDao.load(__key);
        synchronized (this) {
            student = studentNew;
            student__resolvedKey = __key;
        }
    }
    return student;
}
</code></pre>
<p>使用<code>@ToOne</code>标记，<code>joinProperty</code>指定一个字段，如果没有定义，会自动生成一个字段，<code>get</code>方法时自动生成的，使用<code>@Generated</code>标记，代表自动生成的，无需动代码。</p>
<h5><a id="%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%88%E6%9C%89%E4%B8%89%E7%A7%8D%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一对多（有三种映射形式）</h5>
<pre class="line-numbers"><code class="language-java">@ToMany(referencedJoinProperty = &quot;teacherId&quot;)
private List&lt;Teacher&gt; teacherList;
</code></pre>
<p><code>referencedJoinProperty</code>：指定目标实体中与源实体相对应的外键。</p>
<pre class="line-numbers"><code class="language-java">@ToMany(joinProperties = {
        @JoinProperty(name=&quot;studentTag&quot;,referencedName = &quot;teacherTag&quot;)
})
private List&lt;Teacher&gt; teacherList;
</code></pre>
<p><code>JoinProperty</code>: 对于复杂一点的关系可以定义一组<code>@JoinProperty</code>注解。每个<code>@JoinProperty</code>注解都需要有源实体中的源属性和对应实体中的引用属性。</p>
<pre class="line-numbers"><code class="language-java">@ToMany
@JoinEntity(
        entity = Teacher.class,
        sourceProperty = &quot;teacherId&quot;,
        targetProperty = &quot;id&quot;
)
private List&lt;Teacher&gt; teacherList;
</code></pre>
<p>@JoinEntity：在做NM多对多映射的时候使用</p>
<h4><a id="%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8D%87%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据库的升级</h4>
<p>数据库升级最麻烦的就是数据保存的问题，下面是数据库升级时执行的代码。</p>
<pre class="line-numbers"><code class="language-java">/** WARNING: Drops all table on Upgrade! Use only during development. */
public static class DevOpenHelper extends OpenHelper {
    public DevOpenHelper(Context context, String name) {
        super(context, name);
    }

    public DevOpenHelper(Context context, String name, CursorFactory factory) {
        super(context, name, factory);
    }

    @Override
    public void onUpgrade(Database db, int oldVersion, int newVersion) {
        Log.i(&quot;greenDAO&quot;, &quot;Upgrading schema from version &quot; + oldVersion + &quot; to &quot; + newVersion + &quot; by dropping all tables&quot;);
        dropAllTables(db, true);
        onCreate(db);
    }
}
</code></pre>
<p>第一句注释的话已经告诉我们数据库升级时会删除所有的表，重新创建。所以我们可以自定义一个类继承<code>OpenHelper</code>，在升级时先生成临时表，删除旧表创建新表后，再把临时表的数据导入进去。有牛人已经做出这个项目来了，我就厚颜无耻选择直接用了。</p>
<h5><a id="%E5%9C%A8project%E7%9A%84gradle%E6%B7%BB%E5%8A%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在project的gradle添加</h5>
<pre class="line-numbers"><code class="language-java">allprojects {
    repositories {
        jcenter()
        maven { url &quot;https://jitpack.io&quot; }
    }
}
</code></pre>
<h5><a id="%E5%9C%A8app%E7%9A%84gradle%E6%B7%BB%E5%8A%A0%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在app的gradle添加：</h5>
<p><code>compile 'com.github.yuweiguocn:GreenDaoUpgradeHelper:v1.3.0'</code></p>
<h5><a id="%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新建一个类</h5>
<pre class="line-numbers"><code class="language-java">public class MySQLiteOpenHelper extends DaoMaster.OpenHelper{
    public MySQLiteOpenHelper(Contextcontext,Stringname){
        super(context,name);
    }
    public MySQLiteOpenHelper(Contextcontext,String name,SQLiteDatabase.CursorFactoryfactory) {
        super(context,name,factory);
    }
    @Override
    public void onUpgrade(SQLiteDatabasedb,int oldVersion,intnewVersion) {
        Log.d(&quot;SQLite&quot;,&quot;数据库从&quot;+oldVersion+&quot;升级到&quot;+newVersion);
        MigrationHelper.migrate(db,UserDao.class,StudentDao.class);
    }
}
</code></pre>
<p>使用时直接用MySQLiteOpenHelper代替DaoMaster.OpenHelper。</p>
<h2><a id="%E5%AE%9E%E6%88%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实战</h2>
<p>下面就以购物车的实战来使用GreenDao，这里的购物车展示图如下<br />
<figure><img src="media/15561207869255/15713067603164.jpg" alt="" /></figure></p>
<p>我们所知道的数据库操作需要：数据库名、表名、字段名，缺一不可，下面就是这三项的创建</p>
<h3><a id="%E4%B8%80%E3%80%81%E5%88%9B%E5%BB%BAbean%E5%AF%B9%E8%B1%A1%EF%BC%88%E8%A1%A8%E5%90%8D%E5%92%8C%E5%AD%97%E6%AE%B5%E5%90%8D%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、创建Bean对象（表名和字段名）</h3>
<p>GreenDao需要创建Bean对象之后，该Bean对象就是表名，而它的属性值就是字段名，其 实现是通过注释的方式来实现的，下面是购物车的Bean对象（每个Bean对象对应一张表）</p>
<pre class="line-numbers"><code class="language-java">@Entity
public class Shop{

    //表示为购物车列表
    public static final int TYPE_CART = 0x01;
    //表示为收藏列表
    public static final int TYPE_LOVE = 0x02;

    //不能用int
    @Id(autoincrement = true)
    private Long id;
    //商品名称
    @Unique
    private String name;
    //商品价格
    @Property(nameInDb = &quot;price&quot;)
    private String price;
    //已售数量
    private int sell_num;
    //图标url
    private String image_url;
    //商家地址
    private String address;
    //商品列表类型
    private int type;
}
</code></pre>
<p>之后进行<code>Make Project</code><br />
生成<code>Bean</code>实体的构造方法和<code>get</code>、<code>set</code>方法和<code>DaoMaster</code>、<code>DaoSession</code>、<code>DAOS</code>类</p>
<h3><a id="%E4%BA%8C%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、创建数据库</h3>
<pre class="line-numbers"><code class="language-java">public class BaseApplication extends Application {

    private static DaoSession daoSession;

    @Override
    public void onCreate() {
        super.onCreate();
        //配置数据库
        setupDatabase();
    }

    /**
     * 配置数据库
     */
    private void setupDatabase() {
        //创建数据库shop.db&quot;
        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;shop.db&quot;, null);
        //获取可写数据库
        SQLiteDatabase db = helper.getWritableDatabase();
        //获取数据库对象
        DaoMaster daoMaster = new DaoMaster(db);
        //获取Dao对象管理者
        daoSession = daoMaster.newSession();
    }

    public static DaoSession getDaoInstant() {
        return daoSession;
    }
}
</code></pre>
<p>GreenDao已经将我们的数据库创建缩成几句话，代码会自动将Bean对象创建成表，不再是传统的手写SQL语句。这里的数据库创建只需要在Application中执行一次即可，这里对几个类进行解释</p>
<ul>
<li><code>DevOpenHelper</code>：创建SQLite数据库的SQLiteOpenHelper的具体实现</li>
<li><code>DaoMaster</code>：GreenDao的顶级对象，作为数据库对象、用于创建表和删除表</li>
<li><code>DaoSession</code>：管理所有的Dao对象，Dao对象中存在着增删改查等API</li>
</ul>
<p>由于我们已经创建好了DaoSession和Shop的Bean对象，编译后会自动生成我们的ShopDao对象，可通过DaoSession获得<br />
<code>ShopDao dao = daoSession.getShopDao();</code><br />
这里的Dao（Data Access Object）是指数据访问接口，即提供了数据库操作一些API接口，可通过dao进行增删改查操作。</p>
<h3><a id="%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、数据库的增删改查</h3>
<pre class="line-numbers"><code class="language-java">public class LoveDao {

    /**
     * 添加数据，如果有重复则覆盖
     *
     * @param shop
     */
    public static void insertLove(Shop shop) {
        BaseApplication.getDaoInstant().getShopDao().insertOrReplace(shop);
    }

    /**
     * 删除数据
     *
     * @param id
     */
    public static void deleteLove(long id) {
        BaseApplication.getDaoInstant().getShopDao().deleteByKey(id);
    }

    /**
     * 更新数据
     *
     * @param shop
     */
    public static void updateLove(Shop shop) {
        BaseApplication.getDaoInstant().getShopDao().update(shop);
    }

    /**
     * 查询条件为Type=TYPE_LOVE的数据
     *
     * @return
     */
    public static List&lt;Shop&gt; queryLove() {
        return BaseApplication.getDaoInstant().getShopDao().queryBuilder().where(ShopDao.Properties.Type.eq(Shop.TYPE_LOVE)).list();
    }

    /**
     * 查询全部数据
     */
    public static List&lt;Shop&gt; queryAll() {
        return BaseApplication.getDaoInstant().getShopDao().loadAll();
    }
}
</code></pre>
<p>GreenDao的封装更加短小精悍，语义明朗，下面对GreenDao中Dao对象其他API的介绍</p>
<ul>
<li>增加单个数据
<ul>
<li><code>getShopDao().insert(shop);</code></li>
<li><code>getShopDao().insertOrReplace(shop);</code></li>
</ul>
</li>
<li>增加多个数据
<ul>
<li><code>getShopDao().insertInTx(shopList);</code></li>
<li><code>getShopDao().insertOrReplaceInTx(shopList);</code></li>
</ul>
</li>
<li>查询全部
<ul>
<li><code>List&lt; Shop&gt; list = getShopDao().loadAll();</code></li>
<li><code>List&lt; Shop&gt; list = getShopDao().queryBuilder().list();</code></li>
</ul>
</li>
<li>查询附加单个条件
<ul>
<li><code>.where()</code></li>
<li><code>.whereOr()</code></li>
</ul>
</li>
<li>查询附加多个条件
<ul>
<li><code>.where(, , ,)</code></li>
<li><code>.whereOr(, , ,)</code></li>
</ul>
</li>
<li>查询附加排序
<ul>
<li><code>.orderDesc()</code></li>
<li><code>.orderAsc()</code></li>
</ul>
</li>
<li>查询限制当页个数
<ul>
<li><code>.limit()</code></li>
</ul>
</li>
<li>查询总个数
<ul>
<li><code>.count()</code></li>
</ul>
</li>
<li>修改单个数据
<ul>
<li><code>getShopDao().update(shop);</code></li>
</ul>
</li>
<li>修改多个数据
<ul>
<li><code>getShopDao().updateInTx(shopList);</code></li>
</ul>
</li>
<li>删除单个数据
<ul>
<li><code>getTABUserDao().delete(user);</code></li>
</ul>
</li>
<li>删除多个数据
<ul>
<li><code>getUserDao().deleteInTx(userList);</code></li>
</ul>
</li>
<li>删除数据ByKey
<ul>
<li><code>getTABUserDao().deleteByKey();</code></li>
</ul>
</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/03/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869044.html">
                
                  <h1>Android ADB 命令</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本命令</h2>
<ul>
<li>进入指定设备 <code>adb -s serialNumber shell</code></li>
<li>查看版本 <code>adb version</code></li>
<li>查看日志 <code>adb logcat</code></li>
<li>查看设备 <code>adb devices</code></li>
<li>连接状态 <code>adb get-state</code></li>
<li>启动ADB服务 <code>adb start-server</code></li>
<li>停止ADB服务 <code>adb kill-server</code></li>
<li>电脑推送到手机 <code>adb push [local path] [remote path]</code></li>
<li>手机拉取到电脑 <code>adb pull [remote path] [local path]</code></li>
</ul>
<h2><a id="shell%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>shell环境</h2>
<ul>
<li>单个设备进入shell环境 <code>adb shell</code></li>
<li>多个设备进入shell环境 <code>adb -s [deviceId] shell</code></li>
<li>退出shell环境 <code>exit</code></li>
</ul>
<h2><a id="adb-shell%E4%B8%8B%E7%9A%84am%E4%B8%8E-pm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>adb shell下的am 与 pm</h2>
<blockquote>
<p>注:am和pm命令必须先切换到adb shell模式下才能使用</p>
</blockquote>
<h3><a id="am" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>am</h3>
<p>am全称activity manager，你能使用am去模拟各种系统的行为，例如去启动一个activity，强制停止进程，发送广播进程，修改设备屏幕属性等等。当你在adb shell命令下执行am命令:</p>
<p><strong>am <command></strong></p>
<ul>
<li>启动app <code>am start -n {packageName}/.{activityName}</code></li>
<li>杀app的进程 <code>am kill &lt;packageName&gt;</code></li>
<li>强制停止一切 <code>am force-stop &lt;packageName&gt;</code></li>
<li>启动服务 <code>am startservice</code></li>
<li>停止服务 <code>am stopservice</code></li>
<li>打开简书 <code>am start -a android.intent.action.VIEW -d http://www.jianshu.cn/</code></li>
<li>拨打10086 <code>am start -a android.intent.action.CALL -d tel:10086</code></li>
</ul>
<h3><a id="pm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>pm</h3>
<p>pm全称package manager，你能使用pm命令去模拟Android行为或者查询设备上的应用等，当你在adb shell命令下执行pm命令：</p>
<p><strong>pm <command></strong></p>
<ul>
<li>列出手机所有的包名 <code>pm list packages</code></li>
<li>安装/卸载 <code>pm install/uninstall</code></li>
</ul>
<h2><a id="%E6%A8%A1%E6%8B%9F%E7%94%A8%E6%88%B7%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模拟用户事件</h2>
<ul>
<li><strong>文本输入:</strong> <code>adb shell input text &lt;string&gt;</code><br />
例:手机端输出demo字符串，相应指令：<code>adb shell input &quot;demo&quot;</code>.</li>
<li><strong>键盘事件：</strong> <code>input keyevent &lt;KEYCODE&gt;</code>，其中KEYCODE见本文结尾的附表<br />
例:点击返回键，相应指令： <code>input keyevent 4</code>.</li>
<li><strong>点击事件：</strong> <code>input tap &lt;x&gt; &lt;y&gt;</code><br />
例: 点击坐标（500，500），相应指令： <code>input tap 500 500</code>.</li>
<li><strong>滑动事件：</strong> <code>input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; &lt;time&gt;</code><br />
例: 从坐标(300，500)滑动到(100，500)，相应指令： <code>input swipe 300 500 100 500</code>.<br />
例: 200ms时间从坐标(300，500)滑动到(100，500)，相应指令： <code>input swipe 300 500 100 500 200</code>.</li>
</ul>
<h2><a id="logcat%E6%97%A5%E5%BF%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>logcat日志</h2>
<ul>
<li>显示包含的<code>logcat logcat \| grep &lt;str&gt;</code></li>
<li>显示包含，并忽略大小写的<code>logcat logcat \| grep -i &lt;str&gt;</code></li>
<li>读完所有log后返回，而不会一直等待 <code>logcat -d</code></li>
<li>清空log并退出 <code>logcat -c</code></li>
<li>打印最近的<code>count logcat -t &lt;count&gt;</code></li>
<li>格式化输出Log，其中format有如下可选值： <code>logcat -v &lt;format&gt;</code>
<ul>
<li><strong>brief</strong> — 显示优先级/标记和原始进程的PID (默认格式)</li>
<li><strong>process</strong> — 仅显示进程PID</li>
<li><strong>tag</strong> — 仅显示优先级/标记</li>
<li><strong>thread</strong> — 仅显示进程：线程和优先级/标记</li>
<li><strong>raw</strong> — 显示原始的日志信息，没有其他的元数据字段</li>
<li><strong>time</strong> — 显示日期，调用时间，优先级/标记，PID</li>
<li><strong>long</strong> —显示所有的元数据字段并且用空行分隔消息内容</li>
</ul>
</li>
</ul>
<h2><a id="%E8%BF%9C%E7%A8%8Badb" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>远程ADB</h2>
<p>为避免使用数据线，可通过wifi通信，前提是手机与PC处于同一局域网</p>
<ul>
<li>
<p><strong>启动方法:</strong> <code>adb tcpip 5555  //这一步，必须通过数据线把手机与PC连接后再执行</code><br />
<code>adb connect &lt;手机IP&gt;</code></p>
</li>
<li>
<p>**停止方法: **<code>adb disconnect //断开wifi连接</code><br />
<code>adb usb //切换到usb模式</code></p>
</li>
</ul>
<h2><a id="%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他命令</h2>
<ul>
<li>查看当前 <code>ls</code></li>
<li>打印当前路径 <code>pwd</code></li>
<li>查看当前连接的设备 <code>adb devices</code></li>
<li>终止adb服务进程 <code>adb kill-server</code></li>
<li>重启adb服务进程 <code>adb start-server</code></li>
<li>PID是:8607 查看某个进程的日志 <code>adb logcat -v process |grep 8607</code></li>
<li>清理缓存 <code>logcat -c</code></li>
<li>打印xys标签log <code>adb logcat -s xys</code></li>
<li>打印192.168.56.101:5555设备里的xys标签log <code>adb -s 192.168.56.101:5555 logcat -s xys</code></li>
<li>打印在ActivityManager标签里包含start的日志 <code>adb logcat -s ActivityManager | findstr &quot;START&quot;</code>
<ul>
<li>&quot;-s&quot;选项 : 设置输出日志的标签, 只显示该标签的日志;</li>
<li>&quot;-f&quot;选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;</li>
<li>&quot;-r&quot;选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;</li>
<li>&quot;-n&quot;选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;</li>
<li>&quot;-v&quot;选项 : 设置日志的输出格式, 注意只能设置一项;</li>
<li>&quot;-c&quot;选项 : 清空所有的日志缓存信息;</li>
<li>&quot;-d&quot;选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;</li>
<li>&quot;-t&quot;选项 : 输出最近的几行日志, 输出完退出, 不阻塞;</li>
<li>&quot;-g&quot;选项 : 查看日志缓冲区信息;</li>
<li>&quot;-b&quot;选项 : 加载一个日志缓冲区, 默认是 main, 下面详解;</li>
<li>&quot;-B&quot;选项 : 以二进制形式输出日志;</li>
</ul>
</li>
<li>重启机器 <code>adb reboot</code></li>
<li>获取序列号 <code>adb get-serialno</code></li>
<li>重启到bootloader，即刷机模式 <code>adb reboot bootloader</code></li>
<li>重启到recovery，即恢复模式 <code>adb reboot recovery</code></li>
<li>安装APK：<code>adb install &lt;apkfile&gt; //比如：adb install baidu.apk</code></li>
<li>安装apk到sd卡： <code>adb install -s &lt;apkfile&gt; // 比如：adb install -s baidu.apk</code></li>
<li>卸载APK：<code>adb uninstall &lt;package&gt; //比如：adb uninstall com.baidu.search</code></li>
<li>获取机器MAC地址 <code>adb shell cat /sys/class/net/wlan0/address</code></li>
<li>启动应用：<code>adb shell am start -n &lt;package_name&gt;/.&lt;activity_class_name&gt; 例如:adb shell am start -n yf.o2o.store/yf.o2o.store.activity.LoginActivity</code></li>
<li>查看占用内存排序 <code>adb shell top</code></li>
<li>查看占用内存前6的app： <code>adb shell top -m 6</code></li>
<li>刷新一次内存信息，然后返回：<code>adb shell top -n 1</code></li>
<li>查询各进程内存使用情况：<code>adb shell procrank</code></li>
<li>杀死一个进程：<code>adb shell kill [pid]</code></li>
<li>查看进程列表：<code>adb shell ps</code></li>
<li>查看指定进程状态：<code>adb shell ps -x [PID]</code></li>
<li>查看后台services信息： <code>adb shell service list</code></li>
<li>查看当前内存占用： <code>adb shell cat /proc/meminfo</code></li>
<li>查看IO内存分区：<code>adb shell cat /proc/iomem</code></li>
<li>将system分区重新挂载为可读写分区：<code>adb remount</code></li>
<li>从本地复制文件到设备： <code>adb push &lt;local&gt; &lt;remote&gt;</code></li>
<li>从设备复制文件到本地： <code>adb pull &lt;remote&gt; &lt;local&gt;</code></li>
<li>列出目录下的文件和文件夹，等同于dos中的dir命令：<code>adb shell ls</code></li>
<li>进入文件夹，等同于dos中的cd 命令：<code>adb shell cd &lt;folder&gt;</code></li>
<li>重命名文件： <code>adb shell rename path/oldfilename path/newfilename</code></li>
<li>删除system/avi.apk： <code>adb shell rm /system/avi.apk</code></li>
<li>删除文件夹及其下面所有文件：<code>adb shell rm -r &lt;folder&gt;</code></li>
<li>移动文件：<code>adb shell mv path/file newpath/file</code></li>
<li>设置文件权限：<code>adb shell chmod 777 /system/fonts/DroidSansFallback.ttf</code></li>
<li>新建文件夹：<code>adb shell mkdir path/foldelname</code></li>
<li>查看文件内容：<code>adb shell cat &lt;file&gt;</code></li>
<li>查看wifi密码：<code>adb shell cat /data/misc/wifi/*.conf</code></li>
<li>清除log缓存：<code>adb logcat -c</code></li>
<li>查看bug报告：<code>adb bugreport</code></li>
<li>获取设备名称：<code>adb shell cat /system/build.prop</code></li>
<li>查看ADB帮助：<code>adb help</code></li>
<li>跑monkey：
<ul>
<li><code>adb shell monkey -v -p your.package.name 500</code></li>
<li><code>adb -s 192.168.244.151:5555 shell monkey -v -p com.bolexim 500</code></li>
</ul>
</li>
<li>查看当前运行Activity: <code>adb shell &quot;dumpsys window | grep mCurrentFocus&quot;</code></li>
</ul>
<h2><a id="%E9%99%84%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>附表</h2>
<p>下表中， 箭头左边为keycode值，箭头右边为keycode的含义，部分用中文标注</p>
<table>
<thead>
<tr>
<th style="text-align: left">KeyCode</th>
<th style="text-align: left">Value</th>
<th style="text-align: left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">0</td>
<td style="text-align: left">KEYCODE_UNKNOWN</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">1</td>
<td style="text-align: left">KEYCODE_MENU</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">2</td>
<td style="text-align: left">KEYCODE_SOFT_RIGHT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">3</td>
<td style="text-align: left">KEYCODE_HOME</td>
<td style="text-align: left">Home键</td>
</tr>
<tr>
<td style="text-align: left">4</td>
<td style="text-align: left">KEYCODE_BACK</td>
<td style="text-align: left">返回键</td>
</tr>
<tr>
<td style="text-align: left">5</td>
<td style="text-align: left">KEYCODE_CALL</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">6</td>
<td style="text-align: left">KEYCODE_ENDCALL</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">7</td>
<td style="text-align: left">KEYCODE_0</td>
<td style="text-align: left">数字键0</td>
</tr>
<tr>
<td style="text-align: left">8</td>
<td style="text-align: left">KEYCODE_1</td>
<td style="text-align: left">数字键1</td>
</tr>
<tr>
<td style="text-align: left">9</td>
<td style="text-align: left">KEYCODE_2</td>
<td style="text-align: left">数字键2</td>
</tr>
<tr>
<td style="text-align: left">10</td>
<td style="text-align: left">KEYCODE_3</td>
<td style="text-align: left">数字键3</td>
</tr>
<tr>
<td style="text-align: left">11</td>
<td style="text-align: left">KEYCODE_4</td>
<td style="text-align: left">数字键4</td>
</tr>
<tr>
<td style="text-align: left">12</td>
<td style="text-align: left">KEYCODE_5</td>
<td style="text-align: left">数字键5</td>
</tr>
<tr>
<td style="text-align: left">13</td>
<td style="text-align: left">KEYCODE_6</td>
<td style="text-align: left">数字键6</td>
</tr>
<tr>
<td style="text-align: left">14</td>
<td style="text-align: left">KEYCODE_7</td>
<td style="text-align: left">数字键7</td>
</tr>
<tr>
<td style="text-align: left">15</td>
<td style="text-align: left">KEYCODE_8</td>
<td style="text-align: left">数字键8</td>
</tr>
<tr>
<td style="text-align: left">16</td>
<td style="text-align: left">KEYCODE_9</td>
<td style="text-align: left">数字键9</td>
</tr>
<tr>
<td style="text-align: left">17</td>
<td style="text-align: left">KEYCODE_STAR</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">18</td>
<td style="text-align: left">KEYCODE_POUND</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">19</td>
<td style="text-align: left">KEYCODE_DPAD_UP</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">20</td>
<td style="text-align: left">KEYCODE_DPAD_DOWN</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">21</td>
<td style="text-align: left">KEYCODE_DPAD_LEFT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">22</td>
<td style="text-align: left">KEYCODE_DPAD_RIGHT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">23</td>
<td style="text-align: left">KEYCODE_DPAD_CENTER</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">24</td>
<td style="text-align: left">KEYCODE_VOLUME_UP</td>
<td style="text-align: left">音量键+</td>
</tr>
<tr>
<td style="text-align: left">25</td>
<td style="text-align: left">KEYCODE_VOLUME_DOWN</td>
<td style="text-align: left">音量键-</td>
</tr>
<tr>
<td style="text-align: left">26</td>
<td style="text-align: left">KEYCODE_POWER</td>
<td style="text-align: left">Power键</td>
</tr>
<tr>
<td style="text-align: left">27</td>
<td style="text-align: left">KEYCODE_CAMERA</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">28</td>
<td style="text-align: left">KEYCODE_CLEAR</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">29</td>
<td style="text-align: left">KEYCODE_A</td>
<td style="text-align: left">字母键A</td>
</tr>
<tr>
<td style="text-align: left">30</td>
<td style="text-align: left">KEYCODE_B</td>
<td style="text-align: left">字母键B</td>
</tr>
<tr>
<td style="text-align: left">31</td>
<td style="text-align: left">KEYCODE_C</td>
<td style="text-align: left">字母键C</td>
</tr>
<tr>
<td style="text-align: left">32</td>
<td style="text-align: left">KEYCODE_D</td>
<td style="text-align: left">字母键D</td>
</tr>
<tr>
<td style="text-align: left">33</td>
<td style="text-align: left">KEYCODE_E</td>
<td style="text-align: left">字母键E</td>
</tr>
<tr>
<td style="text-align: left">34</td>
<td style="text-align: left">KEYCODE_F</td>
<td style="text-align: left">字母键F</td>
</tr>
<tr>
<td style="text-align: left">35</td>
<td style="text-align: left">KEYCODE_G</td>
<td style="text-align: left">字母键G</td>
</tr>
<tr>
<td style="text-align: left">36</td>
<td style="text-align: left">KEYCODE_H</td>
<td style="text-align: left">字母键H</td>
</tr>
<tr>
<td style="text-align: left">37</td>
<td style="text-align: left">KEYCODE_I</td>
<td style="text-align: left">字母键I</td>
</tr>
<tr>
<td style="text-align: left">38</td>
<td style="text-align: left">KEYCODE_J</td>
<td style="text-align: left">字母键J</td>
</tr>
<tr>
<td style="text-align: left">39</td>
<td style="text-align: left">KEYCODE_K</td>
<td style="text-align: left">字母键K</td>
</tr>
<tr>
<td style="text-align: left">40</td>
<td style="text-align: left">KEYCODE_L</td>
<td style="text-align: left">字母键L</td>
</tr>
<tr>
<td style="text-align: left">41</td>
<td style="text-align: left">KEYCODE_M</td>
<td style="text-align: left">字母键M</td>
</tr>
<tr>
<td style="text-align: left">42</td>
<td style="text-align: left">KEYCODE_N</td>
<td style="text-align: left">字母键N</td>
</tr>
<tr>
<td style="text-align: left">43</td>
<td style="text-align: left">KEYCODE_O</td>
<td style="text-align: left">字母键O</td>
</tr>
<tr>
<td style="text-align: left">44</td>
<td style="text-align: left">KEYCODE_P</td>
<td style="text-align: left">字母键P</td>
</tr>
<tr>
<td style="text-align: left">45</td>
<td style="text-align: left">KEYCODE_Q</td>
<td style="text-align: left">字母键Q</td>
</tr>
<tr>
<td style="text-align: left">46</td>
<td style="text-align: left">KEYCODE_R</td>
<td style="text-align: left">字母键R</td>
</tr>
<tr>
<td style="text-align: left">47</td>
<td style="text-align: left">KEYCODE_S</td>
<td style="text-align: left">字母键S</td>
</tr>
<tr>
<td style="text-align: left">48</td>
<td style="text-align: left">KEYCODE_T</td>
<td style="text-align: left">字母键T</td>
</tr>
<tr>
<td style="text-align: left">49</td>
<td style="text-align: left">KEYCODE_U</td>
<td style="text-align: left">字母键U</td>
</tr>
<tr>
<td style="text-align: left">50</td>
<td style="text-align: left">KEYCODE_V</td>
<td style="text-align: left">字母键V</td>
</tr>
<tr>
<td style="text-align: left">51</td>
<td style="text-align: left">KEYCODE_W</td>
<td style="text-align: left">字母键W</td>
</tr>
<tr>
<td style="text-align: left">52</td>
<td style="text-align: left">KEYCODE_X</td>
<td style="text-align: left">字母键X</td>
</tr>
<tr>
<td style="text-align: left">53</td>
<td style="text-align: left">KEYCODE_Y</td>
<td style="text-align: left">字母键Y</td>
</tr>
<tr>
<td style="text-align: left">54</td>
<td style="text-align: left">KEYCODE_Z</td>
<td style="text-align: left">字母键Z</td>
</tr>
<tr>
<td style="text-align: left">55</td>
<td style="text-align: left">KEYCODE_COMMA</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">56</td>
<td style="text-align: left">KEYCODE_PERIOD</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">57</td>
<td style="text-align: left">KEYCODE_ALT_LEFT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">58</td>
<td style="text-align: left">KEYCODE_ALT_RIGHT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">59</td>
<td style="text-align: left">KEYCODE_SHIFT_LEFT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">60</td>
<td style="text-align: left">KEYCODE_SHIFT_RIGHT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">61</td>
<td style="text-align: left">KEYCODE_TAB</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">62</td>
<td style="text-align: left">KEYCODE_SPACE</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">63</td>
<td style="text-align: left">KEYCODE_SYM</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">64</td>
<td style="text-align: left">KEYCODE_EXPLORER</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">65</td>
<td style="text-align: left">KEYCODE_ENVELOPE</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">66</td>
<td style="text-align: left">KEYCODE_ENTER</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">67</td>
<td style="text-align: left">KEYCODE_DEL</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">68</td>
<td style="text-align: left">KEYCODE_GRAVE</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">69</td>
<td style="text-align: left">KEYCODE_MINUS</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">70</td>
<td style="text-align: left">KEYCODE_EQUALS</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">71</td>
<td style="text-align: left">KEYCODE_LEFT_BRACKET</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">72</td>
<td style="text-align: left">KEYCODE_RIGHT_BRACKET</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">73</td>
<td style="text-align: left">KEYCODE_BACKSLASH</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">74</td>
<td style="text-align: left">KEYCODE_SEMICOLON</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">75</td>
<td style="text-align: left">KEYCODE_APOSTROPHE</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">76</td>
<td style="text-align: left">KEYCODE_SLASH</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">77</td>
<td style="text-align: left">KEYCODE_AT</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">78</td>
<td style="text-align: left">KEYCODE_NUM</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">79</td>
<td style="text-align: left">KEYCODE_HEADSETHOOK</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">80</td>
<td style="text-align: left">KEYCODE_FOCUS</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">81</td>
<td style="text-align: left">KEYCODE_PLUS</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">82</td>
<td style="text-align: left">KEYCODE_MENU</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">83</td>
<td style="text-align: left">KEYCODE_NOTIFICATION</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">84</td>
<td style="text-align: left">KEYCODE_SEARCH</td>
<td style="text-align: left"></td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/03/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869006.html">
                
                  <h1>Mac安装配置appium</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>因为公司需求，需要安装Appium来实现对手机APP的自动化测试，提升工作效率。所以来学习并记录一下Appium的安装以及使用的步骤，方便自己以后对App测试环境搭建的操作。</p>
<h2><a id="%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85appium" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、安装Appium</h2>
<h3><a id="%E4%BA%8C%E5%AE%89%E8%A3%85homebrew" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(二) 安装Homebrew</h3>
<ul>
<li><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;  #下载</code></li>
<li><code>$ brew update #更新</code></li>
<li><code>$ brew -v #查看是否安装好，以及其版本号</code></li>
</ul>
<h3><a id="%E4%B8%89%E5%AE%89%E8%A3%85node-js" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(三) 安装Node.js</h3>
<p>使用homebrew来安装Node.js</p>
<ul>
<li><code>$ brew install node #安装</code></li>
<li><code>$ node -v #查看是否安装好，以及其版本号</code></li>
</ul>
<h3><a id="%E5%9B%9B%E5%AE%89%E8%A3%85npm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(四) 安装npm</h3>
<ul>
<li><code>$ brew install npm</code></li>
</ul>
<h3><a id="%E4%BA%94%E5%AE%89%E8%A3%85appium%E6%9C%8D%E5%8A%A1%E7%AB%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(五) 安装appium服务端</h3>
<p>推荐使用cnpm来安装：<a href="https://npm.taobao.org/">淘宝 NPM 镜像</a> 10分钟同步npmjs.org镜像，使用方式和npm完全一致</p>
<ul>
<li><code>$ npm install cnpm -g --registry=https://registry.npm.taobao.org</code></li>
<li><code>$ npm view appium versions #查看appium所有的版本号</code></li>
<li><code>$ cnpm install -g appium --no-cache $ cnpm install -g appium $ cnpm install -g appium-doctor</code></li>
</ul>
<h3><a id="%E5%85%AD%E6%A3%80%E6%9F%A5appium%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(六) 检查appium环境检测</h3>
<p>在环境监测中打叉的就是没安装成功或者环境没有配置完全的</p>
<ul>
<li><code>appium-doctor</code></li>
</ul>
<h4><a id="1%E3%80%81appium%E7%8E%AF%E5%A2%83%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、appium环境常见问题解决</h4>
<h5><a id="1-xcode-command-line-tools-are-not-installed" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(1) Xcode Command Line Tools are NOT installed!</h5>
<pre class="line-numbers"><code class="language-plain_text">- `xcode-select --install   #按照提示安装即可`
</code></pre>
<h5><a id="2-carthage-was-not-found" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(2) Carthage was NOT found</h5>
<pre class="line-numbers"><code class="language-plain_text">- `$ brew install carthage       #carthage：类似cocoapods管理第三方代码，自动将工程编译为动态库，所以仅支持iOS8以上`
</code></pre>
<h5><a id="3-android-home-is-not-set" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(3) ANDROID_HOME is NOT set!</h5>
<pre class="line-numbers"><code class="language-plain_text">- 使用最新版本Java
- 修改Mac的开发环境
- `vi .bash_profile`
- `export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk(版本记得改)/Contents/Home`
- `export ANDROID_HOME=/Users/YourMacName/Library/Android/sdk`
- `export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:${JAVA_HOME}/bin`
- 修改完配置文件记得保存退出，然后`source .bash_profile`
- 如果有问题记得修改在终端的Shall打开方式，调整为命令
</code></pre>
<h3><a id="%E4%B8%83%E5%AE%89%E8%A3%85appium%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88python%E4%B8%BA%E4%BE%8B%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(七) 安装appium客户端（Python为例）</h3>
<ul>
<li><code>brew search python	#查看可安装的python版本</code></li>
<li><code>brew install python3		#安装python3</code></li>
<li><code>pip install Appium-Python-Client   #安装python客户端</code>  </li>
</ul>
<h3><a id="%E5%85%AB%E5%AE%89%E8%A3%85%E6%94%AF%E6%8C%81ios%E6%B5%8B%E8%AF%95%E7%9A%84%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(八) 安装支持iOS测试的插件</h3>
<ul>
<li><code>$ brew install libimobiledevice --HEAD  # install from HEAD to get important updates</code></li>
<li><code>$ brew install ideviceinstaller         # 只是对iOS9有用</code></li>
<li><code>$ npm install -g ios-deploy                # iOS10 以后的版本安装ios-deploy</code></li>
<li><code>$ sudo gem install xcpretty            # 真机需要安装 xcpretty</code></li>
</ul>
<h2><a id="%E4%BA%8C%E3%80%81appium%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、Appium测试</h2>
<h3><a id="%E4%B8%80ios%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(一) iOS模拟器测试</h3>
<ul>
<li><code>xcodebuild -sdk iphonesimulator   #在xcodeproj项目工程目录下执行，编译生成build文件夹，并在其中生成app文件</code></li>
<li><code>npm install -g authorize-ios   #安装iOS模拟器启动器</code></li>
<li><code>sudo authorize-ios   #启动iOS模拟器</code></li>
<li><code>appium &amp;    #启动appium服务器</code></li>
<li><code>python ***.py     #另开一个终端执行python脚本</code></li>
<li>iOS模拟器自动开启，安装应用并开始执行测试脚本</li>
</ul>
<h3><a id="%E4%BA%8Candroid%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(二) Android模拟器测试</h3>
<ul>
<li><code>appium -a 127.0.0.1 -p 4723 -U db3489d --no-reset</code></li>
</ul>
<h2><a id="%E4%B8%89%E3%80%81appium%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、Appium命令</h2>
<h3><a id="%E4%B8%80%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(一) 服务端启动命令</h3>
<p><strong>服务器标志</strong><br />
所有的标志都是可选的，但是有一些标志需要组合在一起才能生效。</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>默认值</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>--shell</td>
<td>null</td>
<td>进入 REPL 模式</td>
<td></td>
</tr>
<tr>
<td>--localizable-strings-dir</td>
<td>en.lproj</td>
<td>IOS only: 定位 .strings所在目录的相对路径</td>
<td>--localizable-strings-dir en.lproj</td>
</tr>
<tr>
<td>--app</td>
<td>null</td>
<td>iOS: 基于模拟器编译的 app 的绝对路径或者设备目标的 bundle_id； Android: apk 文件的绝对路径--app /abs/path/to/my.app</td>
<td></td>
</tr>
<tr>
<td>--ipa</td>
<td>null</td>
<td>(IOS-only) .ipa 文件的绝对路径</td>
<td>--ipa /abs/path/to/my.ipa</td>
</tr>
<tr>
<td>-U, --udid</td>
<td>null</td>
<td>连接物理设备的唯一设备标识符</td>
<td>--udid 1adsf-sdfas-asdf-123sdf</td>
</tr>
<tr>
<td>-a, --address</td>
<td>0.0.0.0</td>
<td>监听的 ip 地址</td>
<td>--address 0.0.0.0</td>
</tr>
<tr>
<td>-p, --port</td>
<td>4723</td>
<td>监听的端口</td>
<td>--port 4723</td>
</tr>
<tr>
<td>-ca, --callback-address</td>
<td>null</td>
<td>回调IP地址 (默认: 相同的IP地址)</td>
<td>--callback-address 127.0.0.1</td>
</tr>
<tr>
<td>-cp, --callback-port</td>
<td>null</td>
<td>回调端口号 (默认: 相同的端口号)</td>
<td>--callback-port 4723</td>
</tr>
<tr>
<td>-bp, --bootstrap-port</td>
<td>4724</td>
<td>(Android-only) 连接设备的端口号</td>
<td>--bootstrap-port 4724</td>
</tr>
<tr>
<td>-k, --keep-artifacts</td>
<td>false</td>
<td>弃用，无效。trace信息现在保留tmp目录下，每次运行前会清除该目录中的信息。 也可以参考 –trace-dir 。</td>
<td></td>
</tr>
<tr>
<td>-r, --backend-retries</td>
<td>3</td>
<td>(iOS-only) 遇到 crash 或者 超时，Instrument 重新启动的次数。</td>
<td>--backend-retries 3</td>
</tr>
<tr>
<td>--session-override</td>
<td>false</td>
<td>允许 session 被覆盖 (冲突的话)</td>
<td></td>
</tr>
<tr>
<td>--full-reset</td>
<td>false</td>
<td>(iOS) 删除整个模拟器目录。 (Android) 通过卸载应用（而不是清除数据）重置应用状态。在 Android 上，session 完成后也会删除应用。</td>
<td></td>
</tr>
<tr>
<td>--no-reset</td>
<td>false</td>
<td>session 之间不重置应用状态 (iOS: 不删除应用的 plist 文件； Android: 在创建一个新的 session 前不删除应用。)</td>
<td></td>
</tr>
<tr>
<td>-l, --pre-launch</td>
<td>false</td>
<td>在第一个 session 前，预启动应用 (iOS 需要 –app 参数，Android 需要 –app-pkg 和 –app-activity)</td>
<td></td>
</tr>
<tr>
<td>-lt, --launch-timeout	90000	(iOS-only) 等待 Instruments 启动的时间</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g, --log</td>
<td>null</td>
<td>将日志输出到指定文件</td>
<td>--log /path/to/appium.log</td>
</tr>
<tr>
<td>--log-level</td>
<td>debug</td>
<td>日志级别; 默认 (console[:file]): debug[:debug]</td>
<td>--log-level debug</td>
</tr>
<tr>
<td>--log-timestamp</td>
<td>false</td>
<td>在终端输出里显示时间戳</td>
<td></td>
</tr>
<tr>
<td>--local-timezone</td>
<td>false</td>
<td>使用本地时间戳</td>
<td></td>
</tr>
<tr>
<td>--log-no-colors</td>
<td>false</td>
<td>不在终端输出中显示颜色</td>
<td></td>
</tr>
<tr>
<td>-G, --webhook</td>
<td>null</td>
<td>同时发送日志到 HTTP 监听器</td>
<td>--webhook localhost:9876</td>
</tr>
<tr>
<td>--native-instruments-lib</td>
<td>false</td>
<td>(IOS-only) iOS 内建了一个怪异的不可能避免的延迟。我们在 Appium 里修复了它。如果你想用原来的，你可以使用这个参数。</td>
<td></td>
</tr>
<tr>
<td>--app-pkg</td>
<td>null</td>
<td>(Android-only) 你要运行的apk的java包。 (例如， com.example.android.myApp)</td>
<td>--app-pkg com.example.android.myApp</td>
</tr>
<tr>
<td>--app-activity</td>
<td>null</td>
<td>(Android-only) 打开应用时，启动的 Activity 的名字(比如， MainActivity)</td>
<td>--app-activity MainActivity</td>
</tr>
<tr>
<td>--app-wait-package</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 的包名。(比如， com.example.android.myApp)</td>
<td>--app-wait-package com.example.android.myApp</td>
</tr>
<tr>
<td>--app-wait-activity</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 名字(比如， SplashActivity)</td>
<td>--app-wait-activity SplashActivity</td>
</tr>
<tr>
<td>--android-coverage</td>
<td>false</td>
<td>(Android-only) 完全符合条件的 instrumentation 类。 作为命令 adb shell am instrument -e coverage true -w 的 -w 的参数</td>
<td>--android-coverage com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td>
</tr>
<tr>
<td>--avd</td>
<td>null</td>
<td>(Android-only) 要启动的 avd 的名字</td>
<td></td>
</tr>
<tr>
<td>--avd-args</td>
<td>null</td>
<td>(Android-only) 添加额外的参数给要启动avd</td>
<td>--avd-args -no-snapshot-load</td>
</tr>
<tr>
<td>--device-ready-timeout</td>
<td>5</td>
<td>(Android-only) 等待设备准备好的时间，以秒为单位</td>
<td>--device-ready-timeout 5</td>
</tr>
<tr>
<td>--safari</td>
<td>false</td>
<td>(IOS-Only) 使用 Safari 应用</td>
<td></td>
</tr>
<tr>
<td>--device-name</td>
<td>null</td>
<td>待使用的移动设备名字</td>
<td>--device-name iPhone Retina (4-inch), Android Emulator</td>
</tr>
<tr>
<td>--platform-name</td>
<td>null</td>
<td>移动平台的名称: iOS, Android, or FirefoxOS</td>
<td>--platform-name iOS</td>
</tr>
<tr>
<td>--platform-version</td>
<td>null</td>
<td>移动平台的版本</td>
<td>--platform-version 7.1</td>
</tr>
<tr>
<td>--automation-name</td>
<td>null</td>
<td>自动化工具的名称: Appium or Selendroid</td>
<td>--automation-name Appium</td>
</tr>
<tr>
<td>--browser-name</td>
<td>null</td>
<td>移动浏览器的名称: Safari or Chrome</td>
<td>--browser-name Safari</td>
</tr>
<tr>
<td>--default-device, -dd</td>
<td>false</td>
<td>(IOS-Simulator-only) 使用instruments自己启动的默认模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-iphone</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPhone 模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-ipad</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPad 模拟器</td>
<td></td>
</tr>
<tr>
<td>--language</td>
<td>null</td>
<td>iOS / Android 模拟器的语言</td>
<td>--language en</td>
</tr>
<tr>
<td>--locale</td>
<td>null</td>
<td>Locale for the iOS simulator / Android Emulator</td>
<td>--locale en_US</td>
</tr>
<tr>
<td>--calendar-format</td>
<td>null</td>
<td>(IOS-only) iOS 模拟器的日历格式</td>
<td>--calendar-format gregorian</td>
</tr>
<tr>
<td>--orientation</td>
<td>null</td>
<td>(IOS-only) 初始化请求时，使用 LANDSCAPE (横屏) 或者 PORTRAIT (竖屏)</td>
<td>--orientation LANDSCAPE</td>
</tr>
<tr>
<td>--tracetemplate</td>
<td>null</td>
<td>(IOS-only) 指定 Instruments 使用的 tracetemplate 文件</td>
<td>--tracetemplate /Users/me/Automation.tracetemplate</td>
</tr>
<tr>
<td>--show-sim-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 模拟器的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--show-ios-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 系统的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--nodeconfig</td>
<td>null</td>
<td>指定 JSON 格式的配置文件 ，用来在 selenium grid 里注册 appiumd</td>
<td>--nodeconfig /abs/path/to/nodeconfig.json</td>
</tr>
<tr>
<td>-ra, --robot-address</td>
<td>0.0.0.0</td>
<td>robot 的 ip 地址</td>
<td>--robot-address 0.0.0.0</td>
</tr>
<tr>
<td>-rp, --robot-port</td>
<td>-1</td>
<td>robot 的端口地址</td>
<td>--robot-port 4242</td>
</tr>
<tr>
<td>--selendroid-port</td>
<td>8080</td>
<td>用来和 Selendroid 交互的本地端口</td>
<td>--selendroid-port 8080</td>
</tr>
<tr>
<td>--chromedriver-port</td>
<td>9515</td>
<td>ChromeDriver运行的端口</td>
<td>--chromedriver-port 9515</td>
</tr>
<tr>
<td>--chromedriver-executable</td>
<td>null</td>
<td>ChromeDriver 可执行文件的完整路径</td>
<td></td>
</tr>
<tr>
<td>--use-keystore</td>
<td>false</td>
<td>(Android-only) 设置签名 apk 的 keystore</td>
<td></td>
</tr>
<tr>
<td>--keystore-path</td>
<td>(Android-only) keystore 的路径</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--keystore-password</td>
<td>android</td>
<td>(Android-only) keystore 的密码</td>
<td></td>
</tr>
<tr>
<td>--key-alias</td>
<td>androiddebugkey</td>
<td>(Android-only) Key 的别名</td>
<td></td>
</tr>
<tr>
<td>--key-password</td>
<td>android</td>
<td>(Android-only) Key 的密码</td>
<td></td>
</tr>
<tr>
<td>--show-config</td>
<td>false</td>
<td>打印 Appium 服务器的配置信息，然后退出</td>
<td></td>
</tr>
<tr>
<td>--no-perms-check</td>
<td>false</td>
<td>跳过Appium对是否可以读/写必要文件的检查</td>
<td></td>
</tr>
<tr>
<td>--command-timeout</td>
<td>60</td>
<td>默认所有会话的接收命令超时时间 (在超时时间内没有接收到新命令，自动关闭会话)。 会被新的超时时间覆盖</td>
<td></td>
</tr>
<tr>
<td>--keep-keychains</td>
<td>false</td>
<td>(iOS) 当 Appium 启动或者关闭的时候，是否保留 keychains (Library/Keychains)</td>
<td></td>
</tr>
<tr>
<td>--strict-caps</td>
<td>false</td>
<td>如果所选设备是appium不承认的有效设备，会导致会话失败</td>
<td></td>
</tr>
<tr>
<td>--isolate-sim-device</td>
<td>false	Xcode 6存在一个bug，那就是一些平台上如果其他模拟器设备先被删除时某个特定的模拟器只能在没有任何错误的情况下被建立。这个选项导致了Appium不得不删除除了正在使用设备以外其他所有的设备。请注意这是永久性删除，你可以使用simctl或xcode管理被Appium使用的设备类别。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--tmp</td>
<td>null</td>
<td>可以被Appium用来管理临时文件的目录（绝对路径），比如存放需要移动的内置iOS应用程序。 默认的变量为 APPIUM_TMP_DIR ，在 *nix/Mac 为 /tmp 在windows上使用环境便令 TEMP 设定的目录。</td>
<td></td>
</tr>
<tr>
<td>--trace-dir</td>
<td>null</td>
<td>用于保存iOS instruments trace的 appium 目录，是绝对路径， 默认为 /appium-instruments</td>
<td></td>
</tr>
<tr>
<td>--intent-action</td>
<td>android.intent.action.MAIN</td>
<td>(Android-only) 用于启动 activity 的intent action</td>
<td>--intent-action android.intent.action.MAIN</td>
</tr>
<tr>
<td>--intent-category</td>
<td>android.intent.category.LAUNCHER</td>
<td>(Android-only) 用于启动 activity 的intent category</td>
<td>--intent-category android.intent.category.APP_CONTACTS</td>
</tr>
<tr>
<td>--intent-flags</td>
<td>0x10200000</td>
<td>(Android-only) 启动 activity 的标志</td>
<td>--intent-flags 0x10200000</td>
</tr>
<tr>
<td>--intent-args</td>
<td>null</td>
<td>(Android-only) 启动 activity 时附带额外的 intent 参数</td>
<td>--intent-args 0x10200000</td>
</tr>
<tr>
<td>--suppress-adb-kill-server</td>
<td>false</td>
<td>(Android-only) 如果被设定，阻止Appium杀掉adb实例。</td>
<td></td>
</tr>
</tbody>
</table>
<h3><a id="%E4%BA%8Candroid%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(二) Android测试用例编写</h3>
<h4><a id="1%E3%80%81%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、例子:</h4>
<pre class="line-numbers"><code class="language-python">import os

import unittest
from appium import webdriver
from time import sleep

PATH = lambda p: os.path.abspath(
	os.path.join(os.path.dirname(__file__),p)
)

class XingQiuAndroidTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps['deviceName'] = 'emulator-5554'  #adb devices查到的设备名
        desired_caps['platformName'] = 'Android'
        desired_caps['platformVersion'] = '4.4'
        desired_caps['app'] = PATH(
            '../../../Users/jiangruoming/Desktop/***.apk'
        )
        desired_caps['appPackage'] = 'com.***.***'  #被测App的包名
        desired_caps['appActivity'] = '.****' #启动时的Activity

        self.driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps)

    #earDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出
    def tearDown(self):
        self.driver.quit()

    #放置的就是我们的测试脚本了，这部分我们并不陌生；因为我们执行的脚本就在这里。
    def test_add_contacts(self):
        el = self.driver.find_element_by_id(&quot;com.***.***:id/sign_phone&quot;)
        el.click()

        phone_number = self.driver.find_element_by_id(&quot;com.***.***:id/et_user_phone&quot;)
        code = self.driver.find_element_by_id(&quot;com.***.***:id/et_smscode&quot;)
        phone_number.send_keys(&quot;*********&quot;)
        code.send_keys(&quot;****&quot;)

        btn = self.driver.find_element_by_id(&quot;com.***.***:id/btn_finish&quot;)
        btn.click()

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuAndroidTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>
<h4><a id="2%E3%80%81%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、测试流程</h4>
<h5><a id="1%E5%90%AF%E5%8A%A8-appium" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(1) 启动Appium</h5>
<p><code>appium -a 127.0.0.1 -p 4723 --log /path/to/appium.log</code></p>
<h5><a id="2%E5%90%AF%E5%8A%A8-android%E6%A8%A1%E6%8B%9F%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(2) 启动Android模拟器</h5>
<p>由于测试apk不支持X86平台，所以Genymotion无法支持运行，原生arm模拟器运行过慢(胃都等疼了)。试过多个模拟器后，最终选定了夜神模拟器，效果还是不错的。但是由于其主要用于PC平台运行Android游戏，所以用于开发平台还是需要进行配置。</p>
<h6><a id="a%E3%80%81adb%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>a、adb配置</h6>
<p>在Mac环境中加入adb的环境变量<br />
<code>vi .bash_profile</code><br />
<code>export PATH=/Users/Path/To/Android/sdk/platform-tools/:$PATH</code><br />
<code>source .bash_profile</code></p>
<h6><a id="b%E3%80%81adb%E8%BF%9E%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>b、adb连接</h6>
<p>之后进入夜神的包内容中在adb所在文件夹运行adb连接命令<br />
<code>adb connect 127.0.0.1:62001</code><br />
这样<code>adb devices</code>就能显示夜神模拟器的Device ID</p>
<h5><a id="3%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(3) 运行脚本</h5>
<h3><a id="%E4%B8%89ios%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%BC%96%E5%86%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(三) iOS测试用例编写</h3>
<h4><a id="1%E3%80%81%E4%BE%8B%E5%AD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、例子:</h4>
<pre class="line-numbers"><code class="language-python">import unittest
import os
from appium import webdriver
from time import sleep


PATH = lambda p: os.path.abspath(
	os.path.join(os.path.dirname(__file__),p)
)

class XingQiuiOSTests(unittest.TestCase):

	def setUp(self):
		desired_caps = {}
		desired_caps['platformName'] = 'iOS'
		desired_caps['platformVersion'] = '10.2'
		desired_caps['deviceName'] = 'iPhone Simulator'
		desired_caps['app'] = PATH('../../../Users/jiangruoming/Desktop/***.app')

		self.driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps)

	#def tearDown(self):
		#self.driver.quit()

	def test_add_contacts(self):

		el2 = self.driver.find_elements_by_accessibility_id('Allow')

		if el2:
			el2[0].click()

		el3 = self.driver.find_elements_by_class_name('XCUIElementTypeButton')[0]
		el3.click()

		el4 = self.driver.find_elements_by_class_name('XCUIElementTypeTextField')[0]
		el4.send_keys(&quot;15088678313&quot;)

		el5 = self.driver.find_elements_by_class_name('XCUIElementTypeTextField')[1]
		el5.send_keys(&quot;1234&quot;)

		el6 = self.driver.find_elements_by_class_name('XCUIElementTypeButton')[0]
		el6.click()

if __name__ == '__main__':
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuiOSTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>
<h4><a id="2%E3%80%81xcuielementtype" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、XCUIElementType</h4>
<pre class="line-numbers"><code class="language-python">XCUIElementTypeAny,
    XCUIElementTypeUnknown,
    XCUIElementTypeApplication,
    XCUIElementTypeGroup,
    XCUIElementTypeWindow,
    XCUIElementTypeSheet,
    XCUIElementTypeDrawer,
    XCUIElementTypeAlert,
    XCUIElementTypeDialog,
    XCUIElementTypeButton,
    XCUIElementTypeRadioButton,
    XCUIElementTypeRadioGroup,
    XCUIElementTypeCheckBox,
    XCUIElementTypeDisclosureTriangle,
    XCUIElementTypePopUpButton,
    XCUIElementTypeComboBox,
    XCUIElementTypeMenuButton,
    XCUIElementTypeToolbarButton,
    XCUIElementTypePopover,
    XCUIElementTypeKeyboard,
    XCUIElementTypeKey,
    XCUIElementTypeNavigationBar,
    XCUIElementTypeTabBar,
    XCUIElementTypeTabGroup,
    XCUIElementTypeToolbar,
    XCUIElementTypeStatusBar,
    XCUIElementTypeTable,
    XCUIElementTypeTableRow,
    XCUIElementTypeTableColumn,
    XCUIElementTypeOutline,
    XCUIElementTypeOutlineRow,
    XCUIElementTypeBrowser,
    XCUIElementTypeCollectionView,
    XCUIElementTypeSlider,
    XCUIElementTypePageIndicator,
    XCUIElementTypeProgressIndicator,
    XCUIElementTypeActivityIndicator,
    XCUIElementTypeSegmentedControl,
    XCUIElementTypePicker,
    XCUIElementTypePickerWheel,
    XCUIElementTypeSwitch,
    XCUIElementTypeToggle,
    XCUIElementTypeLink,
    XCUIElementTypeImage,
    XCUIElementTypeIcon,
    XCUIElementTypeSearchField,
    XCUIElementTypeScrollView,
    XCUIElementTypeScrollBar,
    XCUIElementTypeStaticText,
    XCUIElementTypeTextField,
    XCUIElementTypeDateField,
    XCUIElementTypeTimeField,
    XCUIElementTypeTextView,
    XCUIElementTypeMenu,
    XCUIElementTypeMenuItem,
    XCUIElementTypeMenuBar,
    XCUIElementTypeMenuBarItem,
    XCUIElementTypeMap,
    XCUIElementTypeWebView,
    XCUIElementTypeIncrementArrow,
    XCUIElementTypeDecrementArrow,
    XCUIElementTypeTimeline,
    XCUIElementTypeRatingIndicator,
    XCUIElementTypeValueIndicator,
    XCUIElementTypeSplitGroup,
    XCUIElementTypeSplitter,
    XCUIElementTypeRelevanceIndicator,
    XCUIElementTypeColorWell,
    XCUIElementTypeHelpTag,
    XCUIElementTypeMatte,
    XCUIElementTypeDockItem,
    XCUIElementTypeRuler,
    XCUIElementTypeRulerMarker,
    XCUIElementTypeGrid,
    XCUIElementTypeLevelIndicator,
    XCUIElementTypeCell,
    XCUIElementTypeLayoutArea,
    XCUIElementTypeLayoutItem,
    XCUIElementTypeHandle,
</code></pre>
<h4><a id="3%E3%80%81appium-python-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、Appium Python API</h4>
<h5><a id="1-contexts" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(1) contexts</h5>
<p><code>contexts(self)</code>:<br />
Returns the contexts within the current session.<br />
返回当前会话中的上下文，使用后可以识别H5页面的控件<br />
Usage:<br />
<code>driver.contexts</code><br />
用法:<br />
<code>driver.contexts</code></p>
<h5><a id="2-current-context" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(2) current_context</h5>
<p><code>current_context(self)</code>:<br />
Returns the current context of the current session.<br />
返回当前会话的当前上下文<br />
Usage:<br />
<code>driver.current_context</code><br />
用法:<br />
<code>driver. current_context</code></p>
<h5><a id="3-context" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(3) context</h5>
<p><code>context(self)</code>:<br />
Returns the current context of the current session.<br />
返回当前会话的当前上下文。<br />
Usage:<br />
<code>driver.context</code><br />
用法:<br />
<code>driver. Context</code></p>
<h5><a id="4-find-element-by-ios-uiautomation" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(4) find_element_by_ios_uiautomation</h5>
<p><code>find_element_by_ios_uiautomation(self, uia_string)</code>:<br />
Finds an element by uiautomation in iOS.<br />
通过iOS uiautomation查找元素<br />
Args:</p>
<ul>
<li>uia_string - The element name in the iOS UIAutomation library<br />
Usage:<br />
<code>driver.find_element_by_ios_uiautomation('.elements()[1].cells()[2]')</code><br />
用法:<br />
<code>dr. find_element_by_ios_uiautomation(‘elements’)</code></li>
</ul>
<h5><a id="5-find-element-by-accessibility-id" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(5) find_element_by_accessibility_id</h5>
<p><code>find_element_by_accessibility_id(self, id)</code>:<br />
Finds an element by accessibility id.<br />
通过accessibility id查找元素<br />
Args:<br />
- id - a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize<br />
Usage:<br />
<code>driver.find_element_by_accessibility_id()</code><br />
用法:<br />
<code>driver.find_element_by_accessibility_id(‘id’)</code></p>
<h5><a id="6-scroll" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(6) scroll</h5>
<p><code>scroll(self, origin_el, destination_el)</code>:<br />
Scrolls from one element to another<br />
从元素origin_el滚动至元素destination_el<br />
Args:</p>
<ul>
<li>originalEl - the element from which to being scrolling</li>
<li>destinationEl - the element to scroll to<br />
Usage:<br />
<code>driver.scroll(el1, el2)</code><br />
用法:<br />
<code>driver.scroll(el1,el2)</code></li>
</ul>
<h5><a id="7-drag-and-drop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(7) drag_and_drop</h5>
<p><code>drag_and_drop(self, origin_el, destination_el)</code>:<br />
Drag the origin element to the destination element<br />
将元素origin_el拖到目标元素destination_el<br />
Args:</p>
<ul>
<li>originEl - the element to drag</li>
<li>destinationEl - the element to drag to<br />
用法:<br />
<code>driver.drag_and_drop(el1,el2)</code></li>
</ul>
<h5><a id="8-tap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(8) tap</h5>
<p><code>tap(self, positions, duration=None)</code>:<br />
Taps on an particular place with up to five fingers, holding for a certain time<br />
模拟手指点击（最多五个手指），可设置按住时间长度（毫秒）<br />
Args:</p>
<ul>
<li>positions - an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five.</li>
<li>duration - (optional) length of time to tap, in ms<br />
Usage:<br />
<code>driver.tap([(100, 20), (100, 60), (100, 100)], 500)</code><br />
用法:<br />
<code>driver.tap([(x,y),(x1,y1)],500)</code></li>
</ul>
<h5><a id="9-swipe" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(9) swipe</h5>
<p><code>swipe(self, start_x, start_y, end_x, end_y, duration=None)</code>:<br />
Swipe from one point to another point, for an optional duration.<br />
从A点滑动至B点，滑动时间为毫秒<br />
Args:<br />
- start_x - x-coordinate at which to start<br />
- start_y - y-coordinate at which to start<br />
- end_x - x-coordinate at which to stop<br />
- end_y - y-coordinate at which to stop<br />
- duration - (optional) time to take the swipe, in ms.</p>
<p>Usage:<br />
<code>driver.swipe(100, 100, 100, 400)</code><br />
用法:<br />
<code>driver.swipe(x1,y1,x2,y2,500)</code></p>
<h5><a id="10-flick" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(10) flick</h5>
<p><code>flick(self, start_x, start_y, end_x, end_y)</code>:<br />
Flick from one point to another point.<br />
按住A点后快速滑动至B点<br />
Args:<br />
- start_x - x-coordinate at which to start<br />
- start_y - y-coordinate at which to start<br />
- end_x - x-coordinate at which to stop<br />
- end_y - y-coordinate at which to stop<br />
Usage:<br />
<code>driver.flick(100, 100, 100, 400)</code><br />
用法:<br />
<code>driver.flick(x1,y1,x2,y2)</code></p>
<h5><a id="11-pinch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(11) pinch</h5>
<p><code>pinch(self, element=None, percent=200, steps=50)</code>:<br />
Pinch on an element a certain amount<br />
在元素上执行模拟双指捏（缩小操作）<br />
Args:</p>
<ul>
<li>element - the element to pinch</li>
<li>percent - (optional) amount to pinch. Defaults to 200%</li>
<li>steps - (optional) number of steps in the pinch action</li>
</ul>
<p>Usage:<br />
<code>driver.pinch(element)</code><br />
用法:<br />
<code>driver.pinch(element)</code></p>
<h5><a id="12-zoom" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(12) zoom</h5>
<p><code>zoom(self, element=None, percent=200, steps=50)</code>:<br />
Zooms in on an element a certain amount<br />
在元素上执行放大操作<br />
Args:</p>
<ul>
<li>element - the element to zoom</li>
<li>percent - (optional) amount to zoom. Defaults to 200%</li>
<li>steps - (optional) number of steps in the zoom action</li>
</ul>
<p>Usage:<br />
<code>driver.zoom(element)</code><br />
用法:<br />
<code>driver.zoom(element)</code></p>
<h5><a id="13-reset" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(13) reset</h5>
<p><code>reset(self)</code>:<br />
Resets the current application on the device.<br />
重置应用(类似删除应用数据)<br />
用法:<br />
<code>driver.reset()</code></p>
<h5><a id="14-hide-keyboard" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(14) hide_keyboard</h5>
<p><code>hide_keyboard(self, key_name=None, key=None, strategy=None)</code>:<br />
Hides the software keyboard on the device. In iOS, use <code>key_name</code> to press a particular key, or <code>strategy</code>. In Android, no parameters are used.<br />
隐藏键盘,iOS使用key_name隐藏，安卓不使用参数<br />
Args:</p>
<ul>
<li>key_name - key to press</li>
<li>strategy - strategy for closing the keyboard (e.g., <code>tapOutside</code>)</li>
</ul>
<p><code>driver.hide_keyboard()</code></p>
<h5><a id="15-keyevent" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(15) keyevent</h5>
<p><code>keyevent(self, keycode, metastate=None)</code>:<br />
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br />
发送按键码（安卓仅有），按键码可以上网址中找到<br />
Args:</p>
<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>
<p>用法:<br />
<code>dr.keyevent(‘4’)</code></p>
<h5><a id="16-press-keycode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(16) press_keycode</h5>
<p><code>press_keycode(self, keycode, metastate=None)</code>:<br />
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br />
发送按键码（安卓仅有），按键码可以上网址中找到<br />
Args:</p>
<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>
<p>用法:<br />
<code>driver.press_ keycode(‘4’)</code></p>
<p>dr.keyevent(‘4’)与driver.press_ keycode(‘4’) 功能实现上一样的，都是按了返回键</p>
<h5><a id="17-long-press-keycode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(17) long_press_keycode</h5>
<p><code>long_press_keycode(self, keycode, metastate=None)</code>:<br />
Sends a long press of keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br />
发送一个长按的按键码（长按某键）<br />
Args:</p>
<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent<br />
用法:<br />
<code>driver.long_press_keycode(‘4’)</code></li>
</ul>
<h5><a id="18-current-activity" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(18) current_activity</h5>
<p><code>current_activity(self)</code>:<br />
Retrieves the current activity on the device.<br />
获取当前的activity<br />
用法:<br />
<code>print(driver.current_activity())</code></p>
<h5><a id="19-wait-activity" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(19) wait_activity</h5>
<p><code>wait_activity(self, activity, timeout, interval=1)</code>:<br />
Wait for an activity: block until target activity presents or time out.<br />
This is an Android-only method.<br />
等待指定的activity出现直到超时，interval为扫描间隔1秒<br />
即每隔几秒获取一次当前的activity<br />
返回的True 或 False<br />
Agrs:</p>
<ul>
<li>activity - target activity</li>
<li>timeout - max wait time, in seconds</li>
<li>interval - sleep interval between retries, in seconds</li>
</ul>
<p>用法:<br />
<code>driver.wait_activity(‘.activity.xxx’,5,2)</code></p>
<h5><a id="20-background-app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(20) background_app</h5>
<p><code>background_app(self, seconds)</code>:<br />
Puts the application in the background on the device for a certain duration.<br />
后台运行app多少秒<br />
Args:</p>
<ul>
<li>seconds - the duration for the application to remain in the background<br />
用法:<br />
<code>driver.background_app(5)</code><br />
置后台5秒后再运行</li>
</ul>
<h5><a id="21-is-app-installed" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(21) is_app_installed</h5>
<p><code>is_app_installed(self, bundle_id)</code>:<br />
Checks whether the application specified by <code>bundle_id</code> is installed on the device.<br />
检查app是否有安装<br />
返回 True or False<br />
Args:</p>
<ul>
<li>bundle_id - the id of the application to query</li>
</ul>
<p>用法:<br />
<code>driver.is_app_installed(“com.xxxx”)</code></p>
<h5><a id="22-install-app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(22) install_app</h5>
<p><code>install_app(self, app_path)</code>:<br />
Install the application found at <code>app_path</code> on the device.<br />
安装app,app_path为安装包路径<br />
Args:</p>
<ul>
<li>app_path - the local or remote path to the application to install</li>
</ul>
<p>用法:<br />
<code>driver.install_app(app_path)</code></p>
<h5><a id="23-remove-app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(23) remove_app</h5>
<p><code>remove_app(self, app_id)</code>:<br />
Remove the specified application from the device.<br />
删除app<br />
Args:</p>
<ul>
<li>app_id - the application id to be removed</li>
</ul>
<p>用法:<br />
<code>driver.remove_app(“com.xxx.”)</code></p>
<h5><a id="24-launch-app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(24) launch_app</h5>
<p><code>launch_app(self)</code>:<br />
Start on the device the application specified in the desired capabilities.<br />
启动app<br />
用法:<br />
<code>driver.launch_app()</code></p>
<h5><a id="25-close-app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(25) close_app</h5>
<p><code>close_app(self)</code>:<br />
Stop the running application, specified in the desired capabilities, on the device.<br />
关闭app<br />
用法:<br />
<code>driver.close_app()</code><br />
启动和关闭app运行好像会出错</p>
<h5><a id="26-start-activity" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(26) start_activity</h5>
<p><code>start_activity(self, app_package, app_activity, **opts)</code>:<br />
Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened.<br />
This is an Android-only method.<br />
在测试过程中打开任意活动。如果活动属于另一个应用程序，该应用程序的启动和活动被打开。<br />
这是一个安卓的方法<br />
Args:</p>
<ul>
<li>app_package - The package containing the activity to start.</li>
<li>app_activity - The activity to start.</li>
<li>app_wait_package - Begin automation after this package starts (optional).</li>
<li>app_wait_activity - Begin automation after this activity starts (optional).</li>
<li>intent_action - Intent to start (optional).</li>
<li>intent_category - Intent category to start (optional).</li>
<li>intent_flags - Flags to send to the intent (optional).</li>
<li>optional_intent_arguments - Optional arguments to the intent (optional).</li>
<li>stop_app_on_reset - Should the app be stopped on reset (optional)?</li>
</ul>
<p>用法:<br />
<code>driver.start_activity(app_package, app_activity)</code></p>
<h5><a id="27-lock" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(27) lock</h5>
<p><code>lock(self, seconds)</code>:<br />
Lock the device for a certain period of time. iOS only.<br />
锁屏一段时间  iOS专有<br />
Args:</p>
<ul>
<li>the duration to lock the device, in seconds</li>
</ul>
<p>用法:<br />
<code>driver.lock()</code></p>
<h5><a id="28-shake" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(28) shake</h5>
<p><code>shake(self)</code>:<br />
Shake the device.<br />
摇一摇手机<br />
用法:<br />
<code>driver.shake()</code></p>
<h5><a id="29-open-notifications" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(29) open_notifications</h5>
<p><code>open_notifications(self)</code>:<br />
Open notification shade in Android (API Level 18 and above)<br />
打系统通知栏（仅支持API 18 以上的安卓系统）<br />
用法:<br />
<code>driver.open_notifications()</code></p>
<h5><a id="30-network-connection" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(30) network_connection</h5>
<p><code>network_connection(self)</code>:<br />
Returns an integer bitmask specifying the network connection type.<br />
Android only.<br />
返回网络类型  数值<br />
Possible values are available through the enumeration <code>appium.webdriver.ConnectionType</code><br />
用法:<br />
<code>driver.network_connection</code></p>
<h5><a id="31-set-network-connection" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(31) set_network_connection</h5>
<p><code>set_network_connection(self, connectionType)</code>:<br />
Sets the network connection type. Android only.<br />
Possible values:</p>
<table>
<thead>
<tr>
<th>Value (Alias)</th>
<th>Data</th>
<th>Wifi</th>
<th>Airplane Mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 (None)</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1 (Airplane Mode)</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2 (Wifi only)</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4 (Data only)</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6 (All network on)</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>These are available through the enumeration appium.webdriver.ConnectionType`</p>
<p>设置网络类型<br />
Args:</p>
<ul>
<li>connectionType - a member of the enum appium.webdriver.ConnectionType</li>
</ul>
<p>用法:<br />
先加载from appium.webdriver.connectiontype import ConnectionType<br />
<code>dr.set_network_connection(ConnectionType.WIFI_ONLY)</code><br />
ConnectionType的类型有<br />
NO_CONNECTION = 0<br />
AIRPLANE_MODE = 1<br />
WIFI_ONLY = 2<br />
DATA_ONLY = 4<br />
ALL_NETWORK_ON = 6</p>
<h5><a id="32-available-ime-engines" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(32) available_ime_engines</h5>
<p><code>available_ime_engines(self)</code>:<br />
Get the available input methods for an Android device. Package and activity are returned (e.g., ['com.android.inputmethod.latin/.LatinIME'])<br />
Android only.<br />
返回安卓设备可用的输入法<br />
用法:<br />
<code>print(driver.available_ime_engines)</code></p>
<h5><a id="33-is-ime-active" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(33) is_ime_active</h5>
<p><code>is_ime_active(self)</code>:<br />
Checks whether the device has IME service active. Returns True/False.<br />
Android only.<br />
检查设备是否有输入法服务活动。返回真/假。<br />
安卓<br />
用法:<br />
<code>print(driver.is_ime_active())</code></p>
<h5><a id="34-activate-ime-engine" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(34) activate_ime_engine</h5>
<p><code>activate_ime_engine(self, engine)</code>:<br />
Activates the given IME engine on the device.<br />
Android only.<br />
激活安卓设备中的指定输入法，设备可用输入法可以从“available_ime_engines”获取<br />
Args:</p>
<ul>
<li>engine - the package and activity of the IME engine to activate (e.g.,'com.android.inputmethod.latin/.LatinIME')</li>
</ul>
<p>用法:<br />
<code>driver.activate_ime_engine(“com.android.inputmethod.latin/.LatinIME”)</code></p>
<h5><a id="35-deactivate-ime-engine" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(35) deactivate_ime_engine</h5>
<p><code>deactivate_ime_engine(self)</code>:<br />
Deactivates the currently active IME engine on the device.<br />
Android only.<br />
关闭安卓设备当前的输入法<br />
用法:<br />
<code>driver.deactivate_ime_engine()</code></p>
<h5><a id="36-active-ime-engine" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(36) active_ime_engine</h5>
<p><code>active_ime_engine(self)</code>:<br />
Returns the activity and package of the currently active IME engine (e.g.,'com.android.inputmethod.latin/.LatinIME').<br />
Android only.<br />
返回当前输入法的包名<br />
用法:<br />
<code>driver.active_ime_engine</code></p>
<h5><a id="37-toggle-location-services" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(37) toggle_location_services</h5>
<p><code>toggle_location_services(self)</code>:<br />
Toggle the location services on the device. Android only.<br />
打开安卓设备上的位置定位设置<br />
用法:<br />
<code>driver.toggle_location_services()</code></p>
<h5><a id="38-set-location" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(38) set_location</h5>
<p><code>set_location(self, latitude, longitude, altitude)</code>:<br />
Set the location of the device<br />
设置设备的经纬度<br />
Args:</p>
<ul>
<li>latitude纬度 - String or numeric value between -90.0 and 90.00</li>
<li>longitude经度 - String or numeric value between -180.0 and 180.0</li>
<li>altitude海拔高度- String or numeric value</li>
</ul>
<p>用法:<br />
<code>driver.set_location(纬度，经度，高度)</code></p>
<h5><a id="39-tag-name" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(39) tag_name</h5>
<p><code>tag_name(self)</code>:<br />
This element's \(tagName\) property.<br />
返回元素的tagName属性<br />
经实践返回的是class name<br />
用法:<br />
<code>element.tag_name()</code></p>
<h5><a id="40-text" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(40) text</h5>
<p><code>text(self)</code>:<br />
The text of the element.<br />
返回元素的文本值<br />
用法:<br />
<code>element.text()</code></p>
<h5><a id="41-click" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(41) click</h5>
<p><code>click(self)</code>:<br />
Clicks the element.<br />
点击元素<br />
用法:<br />
<code>element.click()</code></p>
<h5><a id="42-submit" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(42) submit</h5>
<p><code>submit(self)</code>:<br />
Submits a form.<br />
提交表单<br />
用法:<br />
暂无</p>
<h5><a id="43-clear" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(43) clear</h5>
<p><code>clear(self)</code>:<br />
Clears the text if it's a text entry element.<br />
清除输入的内容<br />
用法:<br />
<code>element.clear()</code></p>
<h5><a id="44-get-attribute" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(44) get_attribute</h5>
<p><code>get_attribute(self, name)</code>:<br />
详见@chenhengjie123 的超级链接<br />
Gets the given attribute or property of the element.</p>
<pre class="line-numbers"><code class="language-plain_text">1. 获取 content-desc 的方法为 get_attribute(&quot;name&quot;) ，而且还不能保证返回的一定是 content-desc （content-desc 为空时会返回 text 属性值）  
2. get_attribute 方法不是我们在 uiautomatorviewer 看到的所有属性都能获取的（此处的名称均为使用 get_attribute 时使用的属性名称)
可获取的：
字符串类型：
	`name(返回 content-desc 或 text)`
	`text(返回 text)`
	`className(返回 class，只有 API=&gt;18 才能支持)`
	`resourceId(返回 resource-id，只有 API=&gt;18 才能支持)`
</code></pre>
<p>This method will first try to return the value of a property with the given name. If a property with that name doesn't exist, it returns the value of the attribute with the same name. If there's no attribute with that name, \(None\) is returned.Values which are considered truthy, that is equals &quot;true&quot; or &quot;false&quot;,are returned as booleans.  All other non-\(None\) values are returned as strings.  For attributes or properties which do not exist, \(None\) is returned.</p>
<p>Args:</p>
<ul>
<li>name - Name of the attribute/property to retrieve.</li>
</ul>
<p>Example:<br />
# Check if the &quot;active&quot; CSS class is applied to an element.</p>
<p><code>is_active = &quot;active&quot; in target_element.get_attribute(&quot;class&quot;)</code></p>
<p>用法:<br />
暂无</p>
<h5><a id="45-is-selected" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(45) is_selected</h5>
<p><code>is_selected(self)</code>:<br />
Returns whether the element is selected.<br />
Can be used to check if a checkbox or radio button is selected.<br />
返回元素是否选择。<br />
可以用来检查一个复选框或单选按钮被选中。<br />
用法:<br />
<code>element.is_slected()</code></p>
<h5><a id="46-is-enabled" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(46) is_enabled</h5>
<p><code>is_enabled(self)</code>:<br />
Returns whether the element is enabled.<br />
返回元素是否可用True of False<br />
用法:<br />
<code>element.is_enabled()</code></p>
<h5><a id="47-find-element-by-id" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(47) find_element_by_id</h5>
<p><code>find_element_by_id(self, id_)</code>:<br />
Finds element within this element's children by ID.<br />
通过元素的ID定位元素<br />
Args:</p>
<ul>
<li>id_ - ID of child element to locate.</li>
</ul>
<p>用法:<br />
<code>driver. find_element_by_id(“id”)</code></p>
<h5><a id="48-find-elements-by-id" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(48) find_elements_by_id</h5>
<p><code>find_elements_by_id(self, id_)</code>:<br />
Finds a list of elements within this element's children by ID.<br />
通过元素ID定位,含有该属性的所有元素<br />
Args:</p>
<ul>
<li>id_ - Id of child element to find.</li>
</ul>
<p>用法:<br />
<code>driver. find_elements_by_id(“id”)</code></p>
<h5><a id="49-find-element-by-name" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(49) find_element_by_name</h5>
<p><code>find_element_by_name(self, name)</code>:<br />
Finds element within this element's children by name.<br />
通过元素Name定位（元素的名称属性text）.<br />
Args:</p>
<ul>
<li>name - name property of the element to find.</li>
</ul>
<p>用法:<br />
<code>driver.find_element_by_name(“name”)</code></p>
<h5><a id="50-find-elements-by-name" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(50) find_elements_by_name</h5>
<p><code>find_elements_by_name(self, name)</code>:<br />
Finds a list of elements within this element's children by name.<br />
通过元素Name定位（元素的名称属性text），含有该属性的所有元素.<br />
Args:</p>
<ul>
<li>name - name property to search for.</li>
</ul>
<p>用法:<br />
<code>driver.find_element_by_name(“name”)</code></p>
<h5><a id="51-find-element-by-link-text" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(51) find_element_by_link_text</h5>
<p><code>find_element_by_link_text(self, link_text)</code>:<br />
Finds element within this element's children by visible link text.<br />
通过元素可见链接文本定位.<br />
Args:</p>
<ul>
<li>link_text - Link text string to search for.</li>
</ul>
<p>用法:<br />
<code>driver.find_element_by_link_text(“text”)</code></p>
<h5><a id="52-find-elements-by-link-text" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(52) find_elements_by_link_text</h5>
<p><code>find_element_by_link_text(self, link_text)</code>:<br />
Finds a list of elements within this element's children by visible link text.<br />
通过元素可见链接文本定位,含有该属性的所有元素.<br />
Args:</p>
<ul>
<li>link_text - Link text string to search for.</li>
</ul>
<p>用法:<br />
<code>driver.find_elements_by_link_text(“text”)</code></p>
<h5><a id="53-find-element-by-partial-link-text" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(53) find_element_by_partial_link_text</h5>
<p><code>find_element_by_partial_link_text(self, link_text)</code>:<br />
Finds element within this element's children by partially visible link text.<br />
通过元素部分可见链接文本定位.<br />
Args:</p>
<ul>
<li>link_text - Link text string to search for.</li>
</ul>
<p><code>driver. find_element_by_partial_link_text(“text”)</code></p>
<h5><a id="54-find-elements-by-partial-link-text" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(54) find_elements_by_partial_link_text</h5>
<p><code>find_elements_by_partial_link_text(self, link_text)</code>:<br />
Finds a list of elements within this element's children by link text.<br />
通过元素部分可见链接文本定位,含有该属性的所有元素.<br />
Args:</p>
<ul>
<li>link_text - Link text string to search for.</li>
</ul>
<p><code>driver. find_elements_by_partial_link_text(“text”)</code></p>
<h5><a id="55-find-element-by-tag-name" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(55) find_element_by_tag_name</h5>
<p><code>find_element_by_tag_name(self, name)</code>:<br />
Finds element within this element's children by tag name.<br />
通过查找html的标签名称定位元素<br />
Args:</p>
<ul>
<li>name - name of html tag (eg: h1, a, span)</li>
</ul>
<p>用法:<br />
<code>driver.find_element_by_tag_name(“name”)</code></p>
<h5><a id="56-find-elements-by-tag-name" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(56) find_elements_by_tag_name</h5>
<p><code>find_elements_by_tag_name(self, name)</code>:<br />
Finds a list of elements within this element's children by tag name.<br />
通过查找html的标签名称定位所有元素<br />
Args:</p>
<ul>
<li>name - name of html tag (eg: h1, a, span).</li>
</ul>
<p>用法:<br />
<code>driver.find_elements_by_tag_name(“name”)</code></p>
<h5><a id="57-find-element-by-xpath" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(57) find_element_by_xpath</h5>
<p><code>find_element_by_xpath(self, xpath)</code>:<br />
Finds element by xpath.<br />
通过Xpath定位元素，详细方法可参阅<a href="http://www.w3school.com.cn/xpath/">http://www.w3school.com.cn/xpath/</a><br />
Args:<br />
xpath - xpath of element to locate.  &quot;//input[@class='myelement']&quot;<br />
Note: The base path will be relative to this element's location.<br />
This will select the first link under this element.<br />
<code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code><br />
However, this will select the first link on the page.<br />
<code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code></p>
<p>用法 <code>find_element_by_xpath(“//*”)</code></p>
<h5><a id="58-find-elements-by-xpath" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(58) find_elements_by_xpath</h5>
<p><code>find_elements_by_xpath(self, xpath)</code>:<br />
Finds elements within the element by xpath.<br />
Args:</p>
<ul>
<li>xpath - xpath locator string.</li>
</ul>
<p>Note: The base path will be relative to this element's location.<br />
This will select all links under this element.<br />
<code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code>.<br />
However, this will select all links in the page itself.<br />
<code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>.</p>
<p>用法:<br />
<code>find_elements_by_xpath(“//*”)</code></p>
<h5><a id="59-find-element-by-class-name" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(59) find_element_by_class_name</h5>
<p><code>find_element_by_class_name(self, name)</code>:<br />
Finds element within this element's children by class name.<br />
通过元素class name属性定位元素.<br />
Args:</p>
<ul>
<li>name - class name to search for.</li>
</ul>
<p>用法:<br />
<code>driver. find_element_by_class_name(“android.widget.LinearLayout”)</code></p>
<h5><a id="60-find-elements-by-class-name" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(60) find_elements_by_class_name</h5>
<p><code>find_elements_by_class_name(self, name)</code>:<br />
Finds a list of elements within this element's children by class name.<br />
通过元素class name属性定位所有含有该属性的元素.<br />
Args:</p>
<ul>
<li>name - class name to search for.</li>
</ul>
<p>用法:<br />
<code>driver. find_elements_by_class_name(“android.widget.LinearLayout”)</code>.</p>
<h5><a id="61-find-element-by-css-selector" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(61) find_element_by_css_selector</h5>
<p><code>find_element_by_css_selector(self, css_selector)</code>:<br />
Finds element within this element's children by CSS selector.<br />
通过CSS选择器定位元素.<br />
Args:</p>
<ul>
<li>css_selector - CSS selctor string, ex: 'a.nav#home'</li>
</ul>
<h5><a id="62-send-keys" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(62) send_keys</h5>
<p><code>send_keys(self, *value)</code>:<br />
Simulates typing into the element.<br />
在元素中模拟输入（开启appium自带的输入法并配置了appium输入法后，可以输入中英文）.<br />
Args:</p>
<ul>
<li>value - A string for typing, or setting form fields.  For setting file inputs, this could be a local file path.Use this to send simple key events or to fill out form fields:<br />
<code>form_textfield = driver.find_element_by_name('username')</code><br />
<code>form_textfield.send_keys(&quot;admin&quot;)</code><br />
This can also be used to set file inputs.<br />
<code>file_input = driver.find_element_by_name('profilePic')</code><br />
<code>file_input.send_keys(&quot;path/to/profilepic.gif&quot;)</code><br />
<code># Generally it's better to wrap the file path in one of the methods</code><br />
<code># in os.path to return the actual path to support cross OS testing.</code><br />
<code># file_input.send_keys(os.path.abspath(&quot;path/to/profilepic.gif&quot;))</code><br />
<code>driver.element.send_keys(“中英”)</code></li>
</ul>
<h5><a id="63-is-displayed" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(63) is_displayed</h5>
<p><code>is_displayed(self)</code>:<br />
Whether the element is visible to a user.<br />
此元素用户是否可见。简单地说就是隐藏元素和被控件挡住无法操作的元素（仅限 Selenium，appium是否实现了类似功能不是太确定）这一项都会返回 False.<br />
用法:<br />
<code>driver.element.is_displayed()</code></p>
<h5><a id="64-location-once-scrolled-into-view" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(64) location_once_scrolled_into_view</h5>
<p><code>location_once_scrolled_into_view(self)</code>:<br />
&quot;&quot;&quot;THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover. where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view.Returns the top lefthand corner location on the screen, or \(None\) if the element is not visible.</p>
<p>暂不知道用法</p>
<h5><a id="65-size" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(65) size</h5>
<p><code>size(self)</code>:<br />
The size of the element.<br />
获取元素的大小（高和宽）.<br />
<code>new_size[&quot;height&quot;] = size[&quot;height&quot;]</code><br />
<code>new_size[&quot;width&quot;] = size[&quot;width&quot;]</code></p>
<p>用法:<br />
<code>driver.element.size</code></p>
<h5><a id="66-value-of-css-property" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(66) value_of_css_property</h5>
<p><code>value_of_css_property(self, property_name)</code>:<br />
The value of a CSS property.<br />
CSS属性<br />
用法 暂不知</p>
<h5><a id="67-location" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(67) location</h5>
<p><code>location(self)</code>:<br />
The location of the element in the renderable canvas.<br />
获取元素左上角的坐标<br />
用法:<br />
<code>driver.element.location</code><br />
返回element的x坐标, int类型<br />
<code>driver.element.location.get('x')</code><br />
返回element的y坐标, int类型<br />
<code>driver.element.location.get('y')</code></p>
<h5><a id="68-rect" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(68) rect</h5>
<p><code>rect(self)</code>:<br />
A dictionary with the size and location of the element.<br />
元素的大小和位置的字典</p>
<h5><a id="69-screenshot-as-base64" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(69) screenshot_as_base64</h5>
<p><code>screenshot_as_base64(self)</code>:<br />
Gets the screenshot of the current element as a base64 encoded string.<br />
获取当前元素的截图为Base64编码的字符串<br />
Usage:<br />
<code>img_b64 = element.screenshot_as_base64</code></p>
<h5><a id="70-execute-script" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(70) execute_script</h5>
<p><code>execute_script(self, script, *args)</code>:<br />
Synchronously Executes JavaScript in the current window/frame.<br />
在当前窗口/框架（特指 Html 的 iframe ）同步执行 javascript 代码。你可以理解为如果这段代码是睡眠5秒，这五秒内主线程的 javascript 不会执行<br />
Args:</p>
<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.<br />
Usage:<br />
<code>driver.execute_script('document.title')</code></li>
</ul>
<h5><a id="71-execute-async-script" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(71) execute_async_script</h5>
<p><code>execute_async_script(self, script, *args)</code>:<br />
Asynchronously Executes JavaScript in the current window/frame.<br />
插入 javascript 代码，只是这个是异步的，也就是如果你的代码是睡眠5秒，那么你只是自己在睡，页面的其他 javascript 代码还是照常执行<br />
Args:</p>
<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.</li>
</ul>
<p>Usage:<br />
<code>driver.execute_async_script('document.title')</code></p>
<h5><a id="72-current-url" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(72) current_url</h5>
<p><code>current_url(self)</code>:<br />
Gets the URL of the current page.<br />
获取当前页面的网址。<br />
Usage:<br />
<code>driver.current_url</code><br />
用法<br />
<code>driver.current_url</code></p>
<h5><a id="73-page-source" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(73) page_source</h5>
<p><code>page_source(self)</code>:<br />
Gets the source of the current page.<br />
获取当前页面的源<br />
Usage:<br />
<code>driver.page_source</code></p>
<h5><a id="74-close" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(74) close</h5>
<p><code>close(self)</code>:<br />
Closes the current window.<br />
关闭当前窗口<br />
Usage:<br />
<code>driver.close()</code></p>
<h5><a id="75-quit" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(75) quit</h5>
<p><code>quit(self)</code>:<br />
Quits the driver and closes every associated window.<br />
退出脚本运行并关闭每个相关的窗口连接<br />
Usage:<br />
<code>driver.quit()</code></p>
<p>参考资料:<br />
<a href="http://debugtalk.com/post/build-ideal-app-automation-test-framework/">打造心目中理想的自动化测试框(AppiumBooster)</a></p>
<p><a href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/">从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用</a>  </p>
<p><a href="https://github.com/appium/python-client">Python-Client的github文档地址</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868936.html">
                
                  <h1>LaTeX表示方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%B8%80%E3%80%81%E6%8C%87%E6%95%B0%E5%92%8C%E4%B8%8B%E6%A0%87%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%92%8C%E5%90%8E%E5%8A%A0%E7%9B%B8%E5%BA%94%E5%AD%97%E7%AC%A6%E6%9D%A5%E5%AE%9E%E7%8E%B0%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、指数和下标可以用^和_后加相应字符来实现。</h2>
<p><figure><img src="media/15561207868936/15713264075302.png" alt="" /></figure></p>
<h2><a id="%E4%BA%8C%E3%80%81%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88square-root%EF%BC%89%E7%9A%84%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4%E4%B8%BA%EF%BC%9A-sqrt%EF%BC%8Cn%E6%AC%A1%E6%96%B9%E6%A0%B9%E7%9B%B8%E5%BA%94%E5%9C%B0%E4%B8%BA-sqrt-n%E3%80%82%E6%96%B9%E6%A0%B9%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%A4%A7%E5%B0%8F%E7%94%B1-latex%E8%87%AA%E5%8A%A8%E5%8A%A0%E4%BB%A5%E8%B0%83%E6%95%B4%E3%80%82%E4%B9%9F%E5%8F%AF%E7%94%A8-surd%E4%BB%85%E7%BB%99%E5%87%BA%E7%AC%A6%E5%8F%B7%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、平方根（square root）的输入命令为：\sqrt，n 次方根相应地为: \sqrt[n]。方根符号的大小由LATEX自动加以调整。也可用\surd 仅给出符号。</h2>
<p><figure><img src="media/15561207868936/15713264213005.png" alt="" /></figure></p>
<h2><a id="%E4%B8%89%E3%80%81%E5%91%BD%E4%BB%A4overline%E5%92%8C-underline%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%8A%E3%80%81%E4%B8%8B%E6%96%B9%E7%94%BB%E5%87%BA%E6%B0%B4%E5%B9%B3%E7%BA%BF%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、命令\overline 和\underline 在表达式的上、下方画出水平线。</h2>
<p><figure><img src="media/15561207868936/15713264358808.png" alt="" /></figure></p>
<h2><a id="%E5%9B%9B%E3%80%81%E5%91%BD%E4%BB%A4overbrace%E5%92%8C-underbrace%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%8A%E3%80%81%E4%B8%8B%E6%96%B9%E7%BB%99%E5%87%BA%E4%B8%80%E6%B0%B4%E5%B9%B3%E7%9A%84%E5%A4%A7%E6%8B%AC%E5%8F%B7%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、命令\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号。</h2>
<p><figure><img src="media/15561207868936/15713264468658.png" alt="" /></figure></p>
<h2><a id="%E4%BA%94%E3%80%81%E5%90%91%E9%87%8F%EF%BC%88vectors%EF%BC%89%E9%80%9A%E5%B8%B8%E7%94%A8%E4%B8%8A%E6%96%B9%E6%9C%89%E5%B0%8F%E7%AE%AD%E5%A4%B4%EF%BC%88arrow-symbols%EF%BC%89%E7%9A%84%E5%8F%98%E9%87%8F%E8%A1%A8%E7%A4%BA%E3%80%82%E8%BF%99%E5%8F%AF%E7%94%B1-vec%E5%BE%97%E5%88%B0%E3%80%82%E5%8F%A6%E4%B8%A4%E4%B8%AA%E5%91%BD%E4%BB%A4-overrightarrow%E5%92%8C-overleftarrow%E5%9C%A8%E5%AE%9A%E4%B9%89%E4%BB%8Ea%E5%88%B0-b%E7%9A%84%E5%90%91%E9%87%8F%E6%97%B6%E9%9D%9E%E5%B8%B8%E6%9C%89%E7%94%A8%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量时非常有用。</h2>
<p><figure><img src="media/15561207868936/15713264649982.png" alt="" /></figure></p>
<h2><a id="%E5%85%AD%E3%80%81%E5%88%86%E6%95%B0%EF%BC%88fraction%EF%BC%89%E4%BD%BF%E7%94%A8-frac%E6%8E%92%E7%89%88%E3%80%82%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%EF%BC%8C-12%E8%BF%99%E7%A7%8D%E5%BD%A2%E5%BC%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AF%B9%E4%BA%8E%E5%B0%91%E9%87%8F%E7%9A%84%E5%88%86%E5%BC%8F%EF%BC%8C%E5%AE%83%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9B%B4%E5%A5%BD%E4%BA%9B%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>六、分数（fraction）使用\frac{...}{...} 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。</h2>
<p><figure><img src="media/15561207868936/15713264772357.png" alt="" /></figure></p>
<h2><a id="%E4%B8%83%E3%80%81%E7%A7%AF%E5%88%86%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88integral-operator%EF%BC%89%E7%94%A8-int%E6%9D%A5%E7%94%9F%E6%88%90%E3%80%82%E6%B1%82%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-sum-operator%EF%BC%89%E7%94%B1-sum%E7%94%9F%E6%88%90%E3%80%82%E4%B9%98%E7%A7%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-product-operator%EF%BC%89%E7%94%B1-prod%E7%94%9F%E6%88%90%E3%80%82%E4%B8%8A%E9%99%90%E5%92%8C%E4%B8%8B%E9%99%90%E7%94%A8%E5%92%8C%E6%9D%A5%E7%94%9F%E6%88%90%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8E%E4%B8%8A%E6%A0%87%E5%92%8C%E4%B8%8B%E6%A0%87%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>七、积分运算符（integral operator）用\int 来生成。求和运算符（sum operator）由\sum 生成。乘积运算符（product operator）由\prod 生成。上限和下限用^ 和_来生成，类似于上标和下标。</h2>
<p><figure><img src="media/15561207868936/15713264928671.png" alt="" /></figure></p>
<h2><a id="%E4%BB%A5%E4%B8%8B%E6%8F%90%E4%BE%9B%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以下提供一些常用符号的表示方法</h2>
<p><figure><img src="media/15561207868936/15713265151036.png" alt="" /></figure><br />
<figure><img src="media/15561207868936/15713265355830.png" alt="" /></figure><br />
<figure><img src="media/15561207868936/15713265726366.png" alt="" /></figure><br />
<figure><img src="media/15561207868936/15713265959249.png" alt="" /></figure><br />
<figure><img src="media/15561207868936/15713266129558.png" alt="" /></figure><br />
<figure><img src="media/15561207868936/15713266264578.png" alt="" /></figure><br />
<figure><img src="media/15561207868936/15713266364253.png" alt="" /></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868826.html">
                
                  <h1>Android 冷启动实现APP秒开</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>在阅读这篇文章之前，首先需要理解几个东西：</p>
<ul>
<li>1、什么是Android的冷启动时间？<br />
冷启动时间是指用户从手机桌面点击APP的那一刻起到启动页面的Activity调用onCreate()方法之间的这个时间段。</li>
<li>2、在冷启动的时间段内发生了什么？<br />
首先我们要知道当打开一个Activity的时候发生了什么，在一个Activity打开时，如果该Activity所属的Application还没有启动，那么系统会为这个Activity创建一个进程（每创建一个进程都会调用一次Application，所以Application的onCreate()方法可能会被调用多次），在进程的创建和初始化中，势必会消耗一些时间，在这个时间里，WindowManager会先加载APP里的主题样式里的窗口背景（windowBackground）作为预览元素，然后才去真正的加载布局，如果这个时间过长，而默认的背景又是黑色或者白色，这样会给用户造成一种错觉，这个APP很卡，很不流畅，自然也影响了用户体验。</li>
</ul>
<p>来看下效果图：<br />
<strong>未优化：</strong><br />
<figure><img src="media/15561207868826/20170227548242189443-4a70e91b2e124b48.gif" alt="" /></figure></p>
<p><strong>优化方案一：</strong><br />
<figure><img src="media/15561207868826/20170227487382189443-4829eba35492d39b.gif" alt="" /></figure></p>
<p><strong>优化方案二：</strong><br />
<figure><img src="media/15561207868826/20170227662152189443-c861191c8a80cd94.gif" alt="" /></figure></p>
<h2><a id="%E5%8E%86%E5%8F%B2%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>历史原因</h2>
<p>当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态的，这就很尴尬了，因为用户会以为没有点到APP而再次点击，这极大的降低用户体验，Android需要及时做出反馈去避免这段迷之尴尬。于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是<strong>Preview Window</strong>,即预览窗口。</p>
<p>好了，现在我们明白了，Preview Window其实是为了提高用户体验而有意设定的。因此，其实如果不是强迫症，它可能并不是一个问题。</p>
<p>但是我猜大部分小伙伴应该是和我一样的强迫症患者：这么丑的黑屏怎么能出现在我的APP上呢？？？！！！</p>
<p>所以，下面我们就来聊聊这个问题的解决方案。</p>
<h2><a id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决方案</h2>
<p>既然决定解决这个问题，那么从哪里入手呢，Android在选择展示黑屏或者白屏的时候，是根据你设定的主题而不同的，也就是说，虽然你的代码没有被执行，你的配置文件却被提前读取了，用来作为展示Preview Window界面的依据。在用户点击手机桌面APP的时候，看到的黑屏或者白屏其实是界面渲染前的第一帧，如果你看懂了文章头的那2个问题，那么解决这个问题就非常轻松了，无非就是将Theme里的windowBackground设置成我们想要让用户看到的画面就可以了</p>
<p>所以，我们的解决方案的切入口就是整个APP的manifest文件，更确切的说应该是主题配置文件。</p>
<h3><a id="%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E5%BC%80%E5%8E%86%E5%8F%B2%E5%80%92%E8%BD%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案一 ：开历史倒车</h3>
<p>这个方案就是禁止加载Preview Window，具体做法如下：</p>
<p>style.xml</p>
<style name="APPTheme" parent="@android:style/Theme.Holo.NoActionBar">
   <item name="android:windowDisablePreview">true</item>
</style>
<p>将APPTheme设定为启动的Activity的主题，即可禁止Preview Window，当然，也有人通过把preview window设置为全透明，也达成了类似的效果。</p>
<p>结果就是，当你点击APP时，界面会无响应一段时间，然后进入APP。</p>
<p>我个人强烈不推荐这么做，因为Android想方设法提升的用户体验一下子被你打回解放前。</p>
<h3><a id="%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89preview-window" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案二：自定义Preview Window</h3>
<h4><a id="1%E3%80%81%E9%80%8F%E6%98%8E%E5%90%AF%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、透明启动</h4>
<p>将背景颜色设置为透明色，这样当用户点击桌面APP图片的时候，并不会&quot;立即&quot;进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦，哈哈），其实现在微信也是这样做的，不信你可以试试。<br />
<code>&lt;style name=&quot;Appwelcome&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot;/&gt;</code><br />
透明化这种做法需要注意的一点，如果直接把Theme引入Activity，在运行的时候可能会出现如下异常：</p>
<blockquote>
<p>java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.</p>
</blockquote>
<p>这个是因为使用了不兼容的Theme，例如我这里的Activity继承了AppCompatActivity，解决方案很简单：</p>
<ul>
<li>1、让其Activity集成Activity而不要集成兼容性的AppCompatActivity</li>
<li>2、在onCreate()方法里的super.onCreate(savedInstanceState)之前设置我们原来APP的Theme</li>
</ul>
<pre class="line-numbers"><code class="language-java">public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
            setTheme(R.style.AppTheme);
            super.onCreate(savedInstanceState);
    }
}
</code></pre>
<h4><a id="2%E3%80%81logo%E5%9B%BE%E7%89%87%E5%90%AF%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、Logo图片启动</h4>
<p>将背景图设置成我们APP的Logo图，作为APP启动的引导，现在市面上大部分的APP也是这么做的。<br />
具体方法如下：</p>
<p>style.xlm</p>
<pre class="line-numbers"><code class="language-xml">&lt;style name=&quot;APPTheme&quot; parent=&quot;@android:style/Theme.Holo.NoActionBar&quot;&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_icon&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>同样将主题设置到启动的Activity的主题中，windowBackground就是即将展示的preview window。其中splash_icon可以是一整张图片，网上很多小伙伴也都是这么做的。其实它也可以是一个能解析出图片资源的XML文件，好像只有layer-list这种能做得到,因为它能够将多个drawable叠加起来展示。</p>
<p>splash_icon.xml</p>
<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:opacity=&quot;opaque&quot;&gt;
    &lt;item android:drawable=&quot;@color/white&quot;/&gt;
    &lt;item&gt;
        &lt;bitmap
            android:gravity=&quot;center&quot;
            android:src=&quot;@drawable/qq&quot;/&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>
<p>这样设置之后，当你点击APP，会立马进入你配置的界面，然后启动欢迎页，效果如下<br />
<figure><img src="media/15561207868826/2017022724594838b008fdb18f761ede8.gif" alt="" /></figure></p>
<p>上面的2种做法，我们都需要将Theme引入对应的Activity</p>
<pre class="line-numbers"><code class="language-java">&lt;activity
	android:name=&quot;.app.main.MainActivity&quot;
	android:theme=&quot;@style/AppWelcome&quot;
	android:screenOrientation=&quot;portrait&quot;&gt;
	&lt;intent-filter&gt;
		&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
		&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
	&lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<p>那么，将preview window直接设置为图片和设置为xml文件有什么区别或者优劣呢？我先卖个关子。先谈谈这种方案的优劣，首先这种方案已经解决了原生preview window的单调难看的问题，在原来的基础上进一步提升了用户体验。可是我们的APP都是有欢（guang）迎（gao）页的，从preview window跳转到欢（guang）迎（gao）页是不可避免的，这样的话，两个界面的切换就会显得很突兀的，</p>
<p>所以强迫症的我们，尝试让这两个界面的切换变成一个界面的变化，从而进一步提升显示效果，怎么样才能让两个界面切换看起来像是在同一个界面里的变化呢？答案就是： 动画。</p>
<p>在这种需求下，图片和xml文件的区别就出来了，因为后者可以帮助我们更准确的实现动画。</p>
<h3><a id="%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89preview-window%E5%A2%9E%E5%BC%BA%E7%89%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案三：自定义Preview Window增强版</h3>
<p>废话少说，我们先来看效果<br />
<figure><img src="media/15561207868826/20170227597652f5ba2feffca1ca31a8c.gif" alt="" /></figure></p>
<p>有了动画之后，界面切换顺畅了许多。<br />
上面的动画实现其实非常简单，无非就是放缩，移动，渐变的组合使用（我仅仅用作范例给大家参考），具体的动画代码细节就不谈了，有兴趣可以去github上看<a href="https://github.com/ladingwu/Splash">本次项目的demo</a>，我们重点来聊一聊思路。</p>
<p>在这里我们需要明确一点的是，<strong>preview window</strong> 只能是静态图，它本身是不展示动画的，我们这里的动画，其实是在进入欢迎页之后的展示的。明确了这一点之后，整个动画效果的实现思路其实就已经摆在我们眼前了，那就是当界面从 <strong>Preview Window</strong> 跳转到 欢迎页 的时候，欢迎页必须首先展示一个和 <strong>Preview Window</strong> 一模一样的界面，让人看起来好像界面还没切换一样，然后再慢慢切换到欢迎页。</p>
<p>然后，我们再来谈谈为什么设置xml的方式可以帮助我们更准确的实现动画，就是因为要保证 <strong>Preview Window</strong> 和欢迎页最开始展示的界面保持绝对一致，只有通过xml的布局才是达到这种效果。</p>
<p>好了，启动页做到这个份儿上，应该就可以交货了，不过还有一个小问题需要大家注意的，那就是我们给Preview Window设置的背景图如果不做处理，图片就会一直存在于内存中，所以，当我们进入到欢迎页的时候，不要忘了把背景图设置为空：</p>
<p>SplashActivity.java</p>
<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
	//将window的背景图设置为空
	getWindow().setBackgroundDrawable(null);
	super.onCreate(savedInstanceState);
}
</code></pre>
<h2><a id="%E5%85%B3%E4%BA%8E%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于启动优化</h2>
<p>上面的做法其实可以达到&quot;秒开&quot;APP的效果，不过确不是真实的速度，在Activity创建过程中其实是会经过一系列framework层的操作，在日常开发中，我们都会去重写Application类，然后在Application里进行一些初始化操作，比如存放用户标识的静态化TOKEN，第三方SDK的初始化等。<br />
这里给出几点建议：</p>
<ul>
<li>1、不要让Application参与业务的操作</li>
<li>2、不要在APPlication进行耗时操作，比如有些开发者会在自己的APP里一系列文件夹或文件（比如我自己），这些I/O操作应该放到&quot;确实该使用的时候再去创建&quot;亦或者是数据库的一些操作。</li>
<li>3、不要以静态变量的方式在Application中保存数据等。</li>
</ul>
<p>当然这是绝对的理想主义，把上面的&quot;不要&quot;2字之前添上&quot;尽量&quot;2字吧，毕竟在实际开发中，这样做确实会让我们方便许多。</p>
<p>对了，补充一点，布局也是很重要的，尽量的去减少布局的复杂性，布局深度，因为在View绘制的过程中，测量也是很耗费性能的。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>到这里，关于Android启动页的相关问题就都讲完了。<br />
最终的高清的效果图：<br />
<figure><img src="media/15561207868826/201702274812409e2d6cccbbdf90fb06f.gif" alt="" /></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868861.html">
                
                  <h1>Android Studio 关联 Bitbucket</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>Github的确是一个开源代码浏览以及存放的好去处。但是当你想要创立一个私人仓库，存放自己的个人项目时，公开的仓库肯定是不行的，而私人账号必须要收费。对于那些手头紧，并且不想维护服务器的人来说，Bitbucket是个不错的选择。每个Bitbucket账号可以创立5个免费的私人仓库，够用了。最近在做毕业设计，需要将项目git到一个私人仓库，所以学习一下Android Studio和Bitbucket关联，毕竟能IDE中git，就觉得用SourceTree有点麻烦。</p>
<h2><a id="bitbucket%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bitbucket简介</h2>
<p>BitBucket 是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。常用的代码托管平台Github、SVN、Bitbucket中，Bitbucket具有以下优势：</p>
<ul>
<li>支持Hg，最易学易用（但不是最强大的）的分布式版本管理工具。同时也支持Git。他的网页端的git仓库不如github好用，但是作为远端仓库足够了。</li>
<li>完全免费的闭源项目，还支持5人以内的合作开发。</li>
<li>支持中文。</li>
<li>官方的git工具SourceTree比GitHub for windows好用。</li>
</ul>
<h2><a id="%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用步骤</h2>
<h3><a id="%E4%B8%80%E3%80%81%E5%AE%89%E8%A3%85git" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、安装Git</h3>
<p>安装步骤都是一路默认下一步，这里就不做说明了，安装好了后，需要将AndroidStudio与Git进行关联：</p>
<p>Android Studio–&gt; Preferences –&gt; Version Control –&gt; Git，在Path to Git executable栏找到Git安装目录中bin文件下的git文件。点击右侧的Test，如果出现如图中的成功提示框，表示AndroidStudio与Git已经关联成功。<br />
<figure><img src="media/15561207868861/15713246960472.png" alt="" /></figure></p>
<h3><a id="%E4%BA%8C%E3%80%81%E5%9C%A8bitbucket%E7%BD%91%E7%AB%99%E5%88%9B%E5%BB%BA%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、在Bitbucket网站创建远程仓库</h3>
<p>在Bitbucket网站上创建仓库<br />
<figure><img src="media/15561207868861/15713247073567.png" alt="" /></figure></p>
<p>记录下远程仓库的URL，后面会用到<br />
<figure><img src="media/15561207868861/15713247206326.png" alt="" /></figure></p>
<h3><a id="%E4%B8%89%E3%80%81%E5%9C%A8androidstudio%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A1%B9%E7%9B%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、在AndroidStudio中创建新项目</h3>
<p>首先新建一个项目,然后进入项目后首先选择VCS–&gt;Enable Version Control Integration,然后选择Git，此时代码文件会变成红色<br />
<figure><img src="media/15561207868861/15713247349739.png" alt="" /></figure></p>
<p><figure><img src="media/15561207868861/15713247482004.png" alt="" /></figure></p>
<p><figure><img src="media/15561207868861/15713247715529.png" alt="" /></figure></p>
<p>接下来设置项目需要忽略上传的文件File–&gt;Settings –&gt; Version Control –&gt;Ignore Files<br />
<figure><img src="media/15561207868861/15713247845617.png" alt="" /></figure></p>
<p>接下来将项目添加到Git本地仓库中，在Project视图下，右键工程Git–&gt;Add,添加成功后，代码文件会变成绿色的。<br />
<figure><img src="media/15561207868861/15713247974008.png" alt="" /></figure></p>
<p><figure><img src="media/15561207868861/15713248090123.png" alt="" /></figure></p>
<p>至此创建项目就完成了</p>
<h3><a id="%E5%9B%9B%E3%80%81androidstudio%E4%B8%AD%E5%B0%86%E9%A1%B9%E7%9B%AE%E6%8F%90%E4%BA%A4%E5%B9%B6%E6%8E%A8%E9%80%81%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、AndroidStudio中将项目提交并推送到远程仓库</h3>
<p>进入AS项目中，选择VCS–&gt;Git-&gt;Commit File<br />
<figure><img src="media/15561207868861/15713248252576.png" alt="" /></figure></p>
<p>填写提交信息后，选择commit and Push<br />
<figure><img src="media/15561207868861/15713248367087.png" alt="" /></figure></p>
<p>之后点击Define remote 填入第二步中的远程仓库URL，点击OK校验URL后就可以Push了。<br />
<figure><img src="media/15561207868861/15713248467219.png" alt="" /></figure></p>
<p><figure><img src="media/15561207868861/15713248552072.png" alt="" /></figure></p>
<p>到此项目构建者的工作就算完成了，其他小伙伴可以直接参照第六步，从远程仓库剪切项目代码。</p>
<h3><a id="%E4%BA%94%E3%80%81%E5%88%AB%E5%BF%98%E4%BA%86%E7%BB%99bitbucket%E6%B7%BB%E5%8A%A0ssh%E5%AF%86%E9%92%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、别忘了给Bitbucket添加SSH密钥</h3>
<p><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code><br />
使用你的邮件创建一个新的 SSH 密匙标签，将会生成 ~/.ssh/id_rsa 文件， 用于存储你的密匙。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868790.html">
                
                  <h1>Android Thread</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、线程简介</h2>
<p>现在操作系统在运行一个程序时，会自动为其创建一个进程，不论是 PC 还是 Android。</p>
<p>一个进程内可以有多个线程，这些线程作为操作系统调度的最小单元，负责执行各种各样的任务，这些线程都拥有各自的计数器、堆栈、局部变量等属性，并且可以访问共享内存。</p>
<p>想象一下，如果你的电脑里只有一条线程在执行任务，一旦遇到 I/O 密集的任务，CPU 只能长时等待，效率很低。</p>
<p>如果把一个进程比作一个外卖公司，CPU 就是外卖公司拥有的主要资源（可以当做电动车），那线程（Thread）就是外卖公司中的一位送餐员，Runnable 就是送餐员要执行的任务（一般情况下都是送饭）。</p>
<h2><a id="%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、线程创建的三种方式</h2>
<p>送餐员最重要的任务就是送餐，我们以代码来演示创建一个送餐员的三种方式：</p>
<h3><a id="%E4%B8%80%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(一) 实现 Runnable 接口</h3>
<pre class="line-numbers"><code class="language-java">public class ThreadTest0 {

    /**
     * 1.实现 Runnable 接口，在 run() 方法中写要执行的任务
     */
    static class Task implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
            Thread shixinzhang = new Thread(new Task(), &quot;外卖任务 &quot; + i);
            //3.命令送餐员出发！
            shixinzhang.start();
        }
    }
}
</code></pre>
<p>注意，上述代码中调用的是送餐员线程的 start() 方法，然后线程会调用 Task 对象的 run() 方法执行任务。运行结果如下：</p>
<p><code>外卖任务 3: 您的外卖已送达</code><br />
<code>外卖任务 1: 您的外卖已送达</code><br />
<code>外卖任务 0: 您的外卖已送达</code><br />
<code>外卖任务 2: 您的外卖已送达</code></p>
<p>可以看到执行任务的是各个线程。如果在 main() 方法中直接调用 run 方法，就相当于主线程直接执行任务，没有在子线程中进行。</p>
<p>直接在 main 中调用 run()：</p>
<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    for (int i = 0; i &lt; 4; i++) {
        //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
        Task task = new Task();
        Thread shixinzhang = new Thread(task, &quot;外卖任务 &quot; + i);
        //3.直接执行任务
        task.run();
    }
}
</code></pre>
<p>运行结果：</p>
<p><code>main: 您的外卖已送达</code><br />
<code>main: 您的外卖已送达</code><br />
<code>main: 您的外卖已送达</code><br />
<code>main: 您的外卖已送达</code></p>
<h3><a id="%E4%BA%8C%E7%BB%A7%E6%89%BFthread%EF%BC%8C%E9%87%8D%E5%86%99%E5%85%B6-run%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(二) 继承 Thread，重写其 run 方法</h3>
<pre class="line-numbers"><code class="language-java">public class ThreadTest1 {
    /**
     * 继承 Thread，重写 run 方法，在 run 方法中写要执行的任务
     */
    static class DeliverThread extends Thread{

        public DeliverThread(String name) {
            super(name);
        }

        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，同时起个名
            DeliverThread shixinzhang = new DeliverThread(&quot;外卖任务&quot; + i);
            shixinzhang.start();
        }
    }
}
</code></pre>
<p>运行结果：</p>
<p><code>外卖任务1: 您的外卖已送达</code><br />
<code>外卖任务3: 您的外卖已送达</code><br />
<code>外卖任务0: 您的外卖已送达</code><br />
<code>外卖任务2: 您的外卖已送达</code></p>
<p>为什么直接继承 Thread 也可以在子线程中执行任务呢？</p>
<p>从 Thread 源码中我们可以看到， Thread 其实也实现了 Runnable ：<br />
<code>public class Thread implements Runnable</code></p>
<p>它内部也有一个 Runnable 的引用，我们调用 start() 方法后送餐员小张就蓄势以待准备出发了，之所以没说“立即出发送餐”，是因为此时可能电动车（CPU）正在被别人使用。</p>
<p>线程 start() 后操作系统会给他分配相关的资源，包括单独的程序计数器（可以理解为送餐员的任务本，上面记录了当前送餐任务的地址和下一个任务的地址）和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行。</p>
<p>等线程被 CPU 调度后就会执行线程中的 run() 方法，因此我们通过重写 Thread 的 run() 方法就可以达到在子线程执行任务的目的。</p>
<h3><a id="%E4%B8%89%E5%AE%9E%E7%8E%B0callable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%87%8D%E5%86%99-call%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%A8-futuretask%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(三) 实现 Callable 接口，重写 call() 方法，用 FutureTask 获得结果</h3>
<pre class="line-numbers"><code class="language-java">public class CallableTest {
    /**
     * 实现 Callable 接口
     */
    static class DeliverCallable implements Callable&lt;String&gt; {
        /**
         * 执行方法，相当于 Runnable 的 run, 不过可以有返回值和抛出异常
         * @return
         * @throws Exception
         */
        @Override
        public String call() throws Exception {
            Thread.sleep(new Random().nextInt(10000));
            System.out.println(Thread.currentThread().getName() + &quot;：您的外卖已送达&quot;);
            return Thread.currentThread().getName() + &quot; 送达时间：&quot; + System.currentTimeMillis() + &quot;\n&quot;;
        }
    }

    /**
     * Callable 作为参数传递给 FutureTask，FutureTask 再作为参数传递给 Thread（类似 Runnable），然后就可以在子线程执行
     * @param args
     */
    public static void main(String[] args) {
        List&lt;FutureTask&lt;String&gt;&gt; futureTasks = new ArrayList&lt;&gt;(4);
        for (int i = 0; i &lt; 4; i++) {
            DeliverCallable callable = new DeliverCallable();
            FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
            futureTasks.add(futureTask);

            Thread thread = new Thread(futureTask, &quot;送餐员 &quot; + i);
            thread.start();
        }

        StringBuilder results = new StringBuilder();
        futureTasks.forEach(futureTask -&gt; {
            try {
                //获取线程返回结果，没返回就会阻塞
                results.append(futureTask.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        System.out.println(System.currentTimeMillis() + &quot; 得到结果：\n&quot; + results);
    }
}
</code></pre>
<p>第三种创建线程的方式与前两种的不同之处在于，以 Callable 作为任务，而不是 Runnable，这种方式的好处是可以获得结果和响应中断。</p>
<p>运行结果：</p>
<pre class="line-numbers"><code class="language-plain_text">送餐员 3：您的外卖已送达  
送餐员 1：您的外卖已送达  
送餐员 0：您的外卖已送达  
送餐员 2：您的外卖已送达  
1487998155430 得到结果： 
送餐员 0 送达时间：1487998155076 
送餐员 1 送达时间：1487998150453 
送餐员 2 送达时间：1487998155430 
送餐员 3 送达时间：1487998149779
</code></pre>
<h2><a id="%E4%B8%89%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、线程的基本属性</h2>
<h3><a id="%E4%B8%80%E4%BC%98%E5%85%88%E7%BA%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(一) 优先级</h3>
<p>Thread 有个优先级字段：private int priority</p>
<p>操作系统采用时间片（CPU 单次执行某线程的时间）的形式来调度线程的运行，线程被 CPU 调用的时间超过它的时间片后，就会发生线程调度。</p>
<p>线程的优先级可以在一定程度上影响它得到时间片的多少，也就是被处理的机会。</p>
<p>Java 中 Thread 的优先级为从 1 到 10 逐渐提高，默认为 5。</p>
<p>有长耗时操作的线程，一般建议设置低优先级，确保处理器不会被独占太久；<br />
频繁阻塞（休眠或者 I/O）的线程建议设置高优先级。</p>
<pre class="line-numbers"><code class="language-java"> public final static int MIN_PRIORITY = 1;

 //线程的默认优先级
 public final static int NORM_PRIORITY = 5;

 public final static int MAX_PRIORITY = 10;
</code></pre>
<blockquote>
<p>线程优先级只是对操作系统分配时间片的建议。<br />
虽然 Java 提供了 10 个优先级别，但不同的操作系统的优先级并不相同，不能很好的和 Java 的 10 个优先级别对应。&gt;所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>
<h3><a id="%E4%BA%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(二) 守护线程</h3>
<p>Java 中，线程也分三六九等。守护线程相当于小弟，做一些后台调度、支持性工作,比如 JVM 的垃圾回收、内存管理等线程都是守护线程。</p>
<p>Thread 中有个布尔值标识当前线程是否为守护线程：</p>
<p><code>private boolean     daemon = false;</code></p>
<p>同时也提供了设置和查看当前线程是否为守护线程的方法：</p>
<pre class="line-numbers"><code class="language-java">public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        throw new IllegalThreadStateException();
    }
    daemon = on;
}

public final boolean isDaemon() {
    return daemon;
}
</code></pre>
<blockquote>
<p>Daemon 属性需要在调用线程的 start() 方法之前调用。</p>
</blockquote>
<p>一个进程中，如果所有线程都退出了，Java 虚拟机就会退出。注意了，这里的“所有”就不包括守护线程，也就是说，当除守护线程外的其他线程都结束后，Java 虚拟机就会退出，然后将守护进程终止。</p>
<p><strong>这里需要注意的是，由于上述特性，Java 虚拟机退出后，在守护线程中的 finally 块中的代码不一定执行。</strong></p>
<p>举个例子：</p>
<pre class="line-numbers"><code class="language-java">public class DaemonTreadTest0 {
    static class DaemonThread extends Thread{
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                System.out.println(Thread.currentThread().getName() + &quot; finally is called!&quot;);
            }
        }
    }

    public static void main(String[] args) {
        DaemonThread thread = new DaemonThread();
        thread.setDaemon(true);
        thread.start();
    }
}
</code></pre>
<p>上述代码中将线程设置为守护线程，由于 main 线程启动 DaemonThread 后就结束，此时虚拟机中没有非守护线程，虚拟机也会退出，守护进程被终止，但是它的 finally 块中的内容却没有被调用。</p>
<p>如果将setDaemon方法注释掉，就会发现有运行结果:</p>
<p><code>Thread-0 finally is called!</code></p>
<p>因此，守护线程中不能依靠 finally 块进行资源关闭和清理。</p>
<h2><a id="%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、线程的生命周期</h2>
<p>线程具有如下几个状态：</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th style="text-align: center">介绍</th>
<th style="text-align: left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td style="text-align: center">新创建</td>
<td style="text-align: left">还未调用 start() 方法；还不是活着的 (alive)</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td style="text-align: center">就绪的</td>
<td style="text-align: left">调用了 start() ，此时线程已经准备好被执行，处于就绪队列；是活着的(alive)</td>
</tr>
<tr>
<td>RUNNING</td>
<td style="text-align: center">运行中</td>
<td style="text-align: left">线程获得 CPU 资源，正在执行任务；活着的</td>
</tr>
<tr>
<td>BLOCKED</td>
<td style="text-align: center">阻塞的</td>
<td style="text-align: left">线程阻塞于锁或者调用了 sleep；活着的</td>
</tr>
<tr>
<td>WAITING</td>
<td style="text-align: center">等待中</td>
<td style="text-align: left">线程由于某种原因等待其他线程；或者的</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td style="text-align: center">超时等待</td>
<td style="text-align: left">与 WAITING 的区别是可以在特定时间后自动返回；活着的</td>
</tr>
<tr>
<td>TERMINATED</td>
<td style="text-align: center">终止</td>
<td style="text-align: left">执行完毕或者被其他线程杀死；不是活着的</td>
</tr>
</tbody>
</table>
<p>有几点注意：</p>
<ul>
<li>Java 中的 Thread 运行状态没有 RUNNING 这一步，运行中的线程状态是 RUNNABLE</li>
<li>三个让线程进入 WAITING 状态的方法
<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
<li>Lock.lock()</li>
</ul>
</li>
</ul>
<p><strong>Java 中关于“线程是否活着”的定义</strong></p>
<p>Thread 中有个判断是否为活着的方法：<br />
<code>public final native boolean isAlive()</code></p>
<p>Java 中线程除了 NEW 和 TERMINITED 状态，其他状态下调用 isAlive() 方法均返回 true，也就是活着的。</p>
<h2><a id="%E4%BA%94%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、线程的关键方法</h2>
<h3><a id="%E4%B8%80thread-sleep" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(一) Thread.sleep()</h3>
<p>Thread.sleep() 是一个静态方法：</p>
<p><code>public static native void sleep(long millis) throws InterruptedException;</code></p>
<p>sleep() 方法：</p>
<ul>
<li>使当前所在线程进入阻塞</li>
<li>只是让出 CPU ，并没有释放对象锁</li>
<li>由于休眠时间结束后不一定会立即被 CPU 调度，因此线程休眠的时间可能大于传入参数</li>
<li>如果被中断会抛出 InterruptedException</li>
</ul>
<p><strong>注意上面的第一条！由于 sleep 是静态方法，它的作用时使当前所在线程祖舍。因此最好在线程内部直接调用 Thread.sleep()，如果你在主线程调用某个线程的 sleep() 方法，其实阻塞的是主线程！</strong></p>
<h3><a id="%E4%BA%8Cobject-wait" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(二) Object.wait()</h3>
<p>与 Thread.sleep() 容易混淆的是 Object.wait() 方法。</p>
<p>Object.wait() 方法：</p>
<ul>
<li>让出 CPU，释放对象锁</li>
<li>在调用前需要先拥有某对象的锁，所以一般在 synchronized 同步块中使用</li>
<li>使该线程进入该对象监视器的等待队列</li>
</ul>
<h3><a id="%E4%B8%89thread-yield" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(三) Thread.yield()</h3>
<p>Thread. yield() 也是一个静态方法：</p>
<p><code>public static native void yield();</code></p>
<p>“Thread.yield() 表示暂停当前线程，让出 CPU 给优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程。</p>
<ul>
<li>和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。</li>
<li>yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中。</li>
</ul>
<blockquote>
<p>yield() 一般使用较少。</p>
</blockquote>
<h3><a id="%E5%9B%9Bthread-join" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(四) Thread.join()</h3>
<p>Thread.join() 表示线程合并，调用线程会进入阻塞状态，需要等待被调用线程结束后才可以执行。</p>
<blockquote>
<p>线程的合并的含义就是将几个并发执行线程的线程合并为一个单线程执行。</p>
</blockquote>
<p>比如下述代码：</p>
<pre class="line-numbers"><code class="language-java">Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;thread is running!&quot;);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
thread.start();
thread.join();
System.out.println(&quot;main thread &quot;);
</code></pre>
<p>我们在主线程调用了 thread.join() 方法，该线程会在输出一句话后休眠 5 秒，等该线程结束后主线程才可以继续执行，输出最后一句结果：</p>
<blockquote>
<p>thread is running!<br />
main thread</p>
</blockquote>
<p>Thread.join 源码：</p>
<pre class="line-numbers"><code class="language-java">//无参方法
public final void join() throws InterruptedException {
    join(0);
}
//有参方法，表示等待 millis 毫秒后自动返回
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay &lt;= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
//有参方法，表示等待 millis + (nanos - 50000) 毫秒后结束
public final synchronized void join(long millis, int nanos)
throws InterruptedException {

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (nanos &lt; 0 || nanos &gt; 999999) {
        throw new IllegalArgumentException(
                            &quot;nanosecond timeout value out of range&quot;);
    }

    if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) {
        millis++;
    }

    join(millis);
}
</code></pre>
<p>通过源码可以发现，Thread.join 是通过 synchronized + Object.wait() 实现的。</p>
<p>Thread.join 的应用场景是：当一个线程必须等待其他线程执行完毕才能继续执行，比如合并计算。</p>
<h2><a id="%E5%85%AD%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>六、线程的中断</h2>
<p>有时候我们需要中断一个正在运行的线程，一种很容易想到的方法是在线程的 run() 方法中加一个循环条件：</p>
<pre class="line-numbers"><code class="language-java">public class ThreadInterruptTest1 {
    static class InterruptThread extends Thread{
        private boolean running;

        public InterruptThread(boolean running) {
            this.running = running;
        }

        public boolean isRunning() {
            return running;
        }

        public void setRunning(boolean running) {
            this.running = running;
        }

        @Override
        public void run() {
            while (running){
                System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptThread thread = new InterruptThread(true);
        thread.start();

        Thread.sleep(5000);
        thread.setRunning(false);
    }
}
</code></pre>
<p>上面的代码中线程 InterruptThread 有一个标志位 running，当这个标志位为 true 时才可以运行。<br />
因此我们可以通过修改这个标志位为 false 来中断该线程。</p>
<p>其实 Thread 内部也为我们提供了同样的机制 ：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align: center">方法介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void interrupt()</td>
<td style="text-align: center">试图中断调用线程，设置中断标志位为 false</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td style="text-align: center">返回调用线程是否被中断</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td style="text-align: center">返回当前线程是否被中断的状态值，同时将中断标志位复位（设为 false）</td>
</tr>
</tbody>
</table>
<h3><a id="%E4%B8%80public-void-interrupt" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(一) public void interrupt()</h3>
<p>它的作用是设置标志位为 false，能否达到中断调用线程的效果，还取决于该线程是否可以响应中断（说直白些就是吃不吃这套），比如 Runnable 的 run() 方法就无法响应中断。</p>
<p>因此我们对执行 Runnable 任务的线程调用 interrupt() 方法后，该线程也不会中断，举个例子：</p>
<pre class="line-numbers"><code class="language-java">public class ThreadInterruptTest2 {

    static class UnInterruptThread extends Thread{
        public UnInterruptThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    static class  UnInterruptRunnable implements Runnable{

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        UnInterruptThread thread = new UnInterruptThread(&quot;无法中断的线程&quot;);
//        Thread thread = new Thread(new UnInterruptRunnable(), &quot;无法中断&quot;);
        thread.start();

        //先让它执行一秒
        Thread.sleep(1000);

        thread.interrupt();

        //不立即退出
        Thread.sleep(3000);
    }
}
</code></pre>
<p>这两种方式创建的线程，在调用 thread.interrupt() 方法后仍然会继续执行！</p>
<p>这时就需要用到上面 Thread 提供的第二个关于中断的方法 isInterrupted() 了。</p>
<h3><a id="%E4%BA%8Cpublic-boolean-isinterrupted" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(二) public boolean isInterrupted()</h3>
<p>我们可以通过 isInterrupted() 知道调用线程是否被中断，以此来作为线程是否运行的判断标志。</p>
<blockquote>
<p>isInterrupted() 在刚创建时默认为 false 不用多说；<br />
线程有许多方法可以响应中断（比如 Thread.sleep()，Thread.wait()），这些方法在收到中断请求、抛出 InterruptedException 之前，JVM 会先把该线程的中断标志位复位，这时调用 isInterrupted 将会返回 false；<br />
线程结束后，线程的中断标志位也会复位为 false。</p>
</blockquote>
<p>举个例子：</p>
<pre class="line-numbers"><code class="language-java">/**
 * 线程中断练习
 * Created by zhangshixin on 17/2/25.
 * http://blog.csdn.net/u011240877
 */
public class ThreadInterruptTest {
    /**
     * 调用 Thread.sleep() 方法的线程，线程如果在 sleep 时被中断，会抛出 InterruptedException
     * 我们在代码中进行捕获，并且查看 JVM 是否将中断标志位重置
     */
    static class SleepThread extends Thread{
        public SleepThread(String s) {
            setName(s);
        }
        @Override
        public void run() {
            while (!isInterrupted()){
                try {
                    Thread.sleep(500);
                    System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    System.out.println(&quot;SleepRunner 在 sleep 时被中断了，此时中断标志位为：&quot; + isInterrupted());
                }
            }
        }
    }

    /**
     * 希望通过这个线程了解：线程运行结束后，中断标志位会重置
     */
    static class BusyThread extends Thread{

        public BusyThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (!isInterrupted()){
                System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SleepThread sleepThread = new SleepThread(&quot;SleepRunner：&quot;);
        BusyThread busyThread = new BusyThread(&quot;BusyRunner：&quot;);
        //新创建的线程 中断标志为 false
        System.out.println(&quot;SleepThread 新创建时的中断标志位：&quot; + sleepThread.isInterrupted());

        Thread.sleep(2000);
        //启动两个线程
        sleepThread.start();
        busyThread.start();
        //让它们运行一秒
        Thread.sleep(1000);
        //分别中断两个线程
        sleepThread.interrupt();
        busyThread.interrupt();
        //查看线程的中断标志位
        Thread.sleep(2000);
        System.out.println(&quot;由于中断标志位变为 true 导致运行结束的线程，中断标志位为: &quot; + busyThread.isInterrupted());

        Thread.sleep(1000);
    }
}
</code></pre>
<p>上述代码中 两个线程都使用 isInterrupted 作为循环执行任务的条件，其中 SleepThread 方法调用了 Thread.sleep，这个方法的会响应中断，抛出异常。</p>
<p>运行结果如下：</p>
<p><figure><img src="media/15561207868790/15713244513325.png" alt="" /></figure></p>
<p>可以看到：</p>
<ul>
<li>线程中，在抛出 InterruptedException 前 JVM 的确会重置中断标志位为 false</li>
<li>这将导致以 isInterrupted 方法作为循环执行任务的线程无法正确中断</li>
</ul>
<h3><a id="%E4%B8%89public-static-boolean-interrupted" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(三) public static boolean interrupted()</h3>
<p><code>Thread.interrupted()</code> 方法是一个静态方法，它会返回调用线程（而不是被调用线程）的中断标志位，返回后重置中断标志位。</p>
<p>因此 <code>Thread.interrupted()</code> 第二次调用永远返回 false。</p>
<p>源码：</p>
<pre class="line-numbers"><code class="language-java">public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}
</code></pre>
<h2><a id="%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>七、总结</h2>
<p>这篇文章总结了 线程的基本概念和关键方法，还有一些不建议使用的方法没有介绍，是因为它们有很多副作用，比如 suspend() 方法在调用后虽然线程会进入休眠状态，却不会释放资源，很容易引发死锁问题；同样，stop() 方法终结一个线程时无法保证这个线程有机会释放资源，也会导致一些不确定问题。</p>
<p>我们可以通过下面的图片整体分析线程的生命周期和主要方法：<br />
<figure><img src="media/15561207868790/15713244633003.png" alt="" /></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868717.html">
                
                  <h1>Android Wi-Fi 直连</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Wi-Fi直连是Android 4.0(API level 14)或更高的版本的才加入的新功能，使用Wi-Fi直连相关的API可以发现并连接支持Wi-Fi直连的设备，连接之后设备之间可以通信，传输的距离比蓝牙的传输距离要远很多</p>
<h2><a id="api%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API 概述</h2>
<ul>
<li>Wi-Fi直连的方法<br />
类WifiP2pManager提供了一些方法来使用Wi-Fi直连的相关的接口来发现连接设备</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align: center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>initialize()</td>
<td style="text-align: center">在Wi-Fi框架中注册，必须在其他方法之前调用</td>
</tr>
<tr>
<td>connect()</td>
<td style="text-align: center">和另外的直连设备连接</td>
</tr>
<tr>
<td>cancelConnect()</td>
<td style="text-align: center">取消正在连接的动作</td>
</tr>
<tr>
<td>requestConnectInfo()</td>
<td style="text-align: center">请求已经连接的信息</td>
</tr>
<tr>
<td>createGroup()</td>
<td style="text-align: center">创建直连的设备组</td>
</tr>
<tr>
<td>removeGroup()</td>
<td style="text-align: center">删除当前的设置组</td>
</tr>
<tr>
<td>requestGroupInfo()</td>
<td style="text-align: center">请求当前组的信息</td>
</tr>
<tr>
<td>discoverPeers()</td>
<td style="text-align: center">初始化搜索</td>
</tr>
<tr>
<td>requestPeers()</td>
<td style="text-align: center">请求已经发现的设备的列表</td>
</tr>
</tbody>
</table>
<ul>
<li>Wi-Fi直连的监听<br />
类WifiP2pManager中也提供了很多的监听接口，计时的通知当前的 activity相关的搜索和连接的<br />
结果</li>
</ul>
<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align: center">相关的操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>WifiP2pManager.ActionListener</td>
<td style="text-align: center">相关的操作：connect(), cancelConnect(), createGroup(), removeGroup(), and discoverPeers()</td>
</tr>
<tr>
<td>WifiP2pManager.ChannelListener</td>
<td style="text-align: center">相关的操作：initialize()</td>
</tr>
<tr>
<td>WifiP2pManager.ConnectionInfoListener</td>
<td style="text-align: center">相关的操作：requestConnectInfo()</td>
</tr>
<tr>
<td>WifiP2pManager.GroupInfoListener</td>
<td style="text-align: center">相关的操作：requestGroupInfo()</td>
</tr>
<tr>
<td>WifiP2pManager.PeerListListener</td>
<td style="text-align: center">相关的操作：requestPeers()</td>
</tr>
</tbody>
</table>
<ul>
<li>Wi-Fi直连的Intent</li>
</ul>
<table>
<thead>
<tr>
<th>Intent</th>
<th style="text-align: center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>WIFI_P2P_CONNECTION_CHANGED_ACTION</td>
<td style="text-align: center">当设备的Wi-Fi的连接状态发生变化时触发</td>
</tr>
<tr>
<td>WIFI_P2P_PEERS_CHANGED_ACTION</td>
<td style="text-align: center">在调用discoverPeers()时触发，可以调用requestPeers()方法更新设备列表</td>
</tr>
<tr>
<td>WIFI_P2P_STATE_CHANGED_ACTION</td>
<td style="text-align: center">Wi-Fi直连的状态发生变化时触发</td>
</tr>
<tr>
<td>WIFI_P2P_THIS_DEVICE_CHANGED_ACTION</td>
<td style="text-align: center">Wi-Fi直连的设备的详细信息发生变化时触发</td>
</tr>
</tbody>
</table>
<h2><a id="%E5%88%9B%E5%BB%BAwi-fi%E7%9B%B4%E8%BF%9E%E7%9A%84%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建Wi-Fi直连的应用</h2>
<ul>
<li>初始化设置<br />
首先要保证设置支持Wi-Fi直连相关的协议，如果支持，我们就可以获得WifiP2pManager的实例，创建并注册相关的广播，使用相关的<br />
api<br />
在AndroidManifest中必须声明相关的权限,Wi-Fi直连是在api level 14及更高的版本才能使用，还要声明<code>android:minSdkVersion=&quot;14&quot;</code></li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">&lt;uses-sdk android:minSdkVersion=&quot;14&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
</code></pre>
<ul>
<li>初始化WifiP2pManager的实例，并注册相关的广播，监听Wi-Fi直连的状态</li>
</ul>
<pre class="line-numbers"><code class="language-java">private WifiP2pManager mManager;
private Channel mChannel;
private IntentFilter directFilter;
private WiFiDirectReceiver directReceiver ;

@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);

  mManager = (WifiP2pManager)this.getSystemService(Context.WIFI_P2P_SERVICE);
  mChannel = mManager.initialize(this, this.getMainLooper(), null);
  directReceiver = new WiFiDirectReceiver(mManager, mChannel, this);

  directFilter = new IntentFilter();
  directFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
  directFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
  directFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
  directFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);

}

//注册广播监听
@Override
protected void onResume() {
  super.onResume();
  this.registerReceiver(directReceiver, directFilter);
}

//取消注册
@Override
protected void onPause() {
  super.onPause();
  this.unregisterReceiver(directReceiver);
}
</code></pre>
<ul>
<li>广播接受</li>
</ul>
<pre class="line-numbers"><code class="language-java">public class WiFiDirectReceiver extends BroadcastReceiver{

	private WifiP2pManager mManager;
	private Channel mChannel;
	private MainActivity mActivity;
	private PeerListListener mListener;
	private WifiP2pConfig mConfig = new WifiP2pConfig();

	public WiFiDirectReceiver(){}

	public WiFiDirectReceiver(WifiP2pManager manager,Channel channel,MainActivity activity){
		this.mManager = manager;
		this.mChannel = channel;
		this.mActivity = activity;
	}

	@Override
	public void onReceive(Context context, Intent intent) {
		String action = intent.getAction();
		Log.e(&quot;tag&quot;, &quot;===============wifi direct action: &quot;+action);
		if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)){
			int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1);
			if(state == WifiP2pManager.WIFI_P2P_STATE_ENABLED){
				//打开
			}else if(state == WifiP2pManager.WIFI_P2P_STATE_DISABLED){
				//关闭
			}
		}else if(action.equals(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)){

		}else if(action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)){

		}else if(action.equals(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)){

		}
	}
}
</code></pre>
<ul>
<li>发现设备</li>
</ul>
<p>在调用之后initialize()方法之后，会触发<code>WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION</code>的广播，在BroadcastReceiver<br />
中，如果WifiP2pManager.WIFI_P2P_STATE_ENABLED的状态已经打开，在BroadcastReceiver调用discoverPeers方法,如果发现设备.</p>
<p>会回调onSuccess方法</p>
<pre class="line-numbers"><code class="language-java">mManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() {
@Override
                    public void onSuccess() {
                        Log.e(&quot;tag&quot;, &quot;===================discovery success&quot;);
                    }

                    @Override
                    public void onFailure(int reason) {
                        Log.e(&quot;tag&quot;, &quot;===================discovery failed&quot;);
                    }
});
</code></pre>
<p>如果发现设备，系统会触发WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION这个广播，在这个广播中可以调用requestPeers方法可以列出所有的设备</p>
<pre class="line-numbers"><code class="language-java">if(null != mManager){
	mManager.requestPeers(mChannel, new WifiP2pManager.PeerListListener() {
		@Override
		public void onPeersAvailable(WifiP2pDeviceList peers) {
			Log.e(&quot;tag&quot;, &quot;==================peers list size: &quot;+peers.getDeviceList().size());
			for(WifiP2pDevice device: peers.getDeviceList()){
				Log.e(&quot;tag&quot;, &quot;==================device addr: &quot;+device.deviceName+&quot; name: &quot;+device.deviceName);
			}
		}
	});
}
</code></pre>
<ul>
<li>连接设备<br />
对于已经发现的设备我们可以调用connect()方法连接，需要初始化WifiP2pConfig,并设置config的deviceAddress</li>
</ul>
<pre class="line-numbers"><code class="language-java">private WifiP2pConfig mConfig = new WifiP2pConfig();  
mConfig.deviceAddress = device.deviceAddress;
mManager.connect(mChannel, mConfig, new WifiP2pManager.ActionListener() {
	@Override
	public void onSuccess() {
		Log.e(&quot;tag&quot;, &quot;==============connnect success&quot;);
	}
	@Override
	public void onFailure(int reason) {
		Log.e(&quot;tag&quot;, &quot;=================connect failed&quot;);
	}
});
</code></pre>
<p>连接成功会回调onSuccess方法</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_16.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_18.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/17043409056338/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/adolphJane" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:adolphdeveloper@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style><script>window.MathJax = {     tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } ,     startup: {     pageReady() {       return MathJax.startup.defaultPageReady().then(function () {          window.mweb_mathjax_ready_val = 'yes';          if(window.mweb_mathjax_ready !== undefined){ mweb_mathjax_ready(); }       });     }   }};document.addEventListener('DOMContentLoaded', function(event) {    if (typeof Prism != 'undefined') {         Prism.highlightAll();     }});window.mweb_mathjax_ready_val = '';function theMWebMathJaxRenderIsReady(key){ return window.mweb_mathjax_ready_val; }</script><script>window.MathJax = { tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } }; </script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
