<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870533.html">
                
                  <h1>Android-ImageView详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">ScaleType</h2>

<ul>
<li><p><code>android:scaleType=&quot;center&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按照图片的原大小居中显示，不缩放，用ImageView的大小截取图片的居中部分。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerCrop&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按比例缩小图片，直到图片的宽高有一边等于ImageView的宽高，则对于另一边，图片的长度大于或等于ImageView的长度，最后用ImageView的大小居中截取该图片。</li>
<li>当图片小于ImageView的宽高：以图片的中心店和ImageView的中心点为基准，按比例扩大图片，直到图片的宽高大于或等于ImageView的宽高，并按ImageView的大小居中截取该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerInside&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心和ImageView的中心点为基准，按比例缩小图片，使图片宽高等于或者小于ImagevView的宽高，直到将图片的内容完整居中显示。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitCenter&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，居中显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitStart&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的上方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitEnd&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的下方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitXY&quot;</code></p>
<ul>
<li>表示把图片按指定的大小在ImageView中显示，拉伸或收缩图片，不保持原比例，填满ImageView。</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870497.html">
                
                  <h1>Android-Xfermode详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Xfermode</h2>

<p>Xfermode具体怎么翻译，说实话，我也不知道，我习惯叫它图片混合模式，随便了，管它叫什么，不妨碍我们使用它。关于Xfermode的说明，可以在Google文档中找到这样的描述：Xfermode是在绘图通道中自定义“传输模式”的基类。静态函数创建可以调用或者返回任意作为模式枚举指定的预定义子类实例。当Xfermode分配给Paint，然后绘制对象与Paint就具备了所添加的xfermode。读起来比较拗口，下面直接看Xfermode的源码：</p>

<pre class="line-numbers"><code class="language-java">public class Xfermode {  
    protected void finalize() throws Throwable {  
        try {  
            finalizer(native_instance);  
        } finally {  
            super.finalize();  
        }  
    }  
    private static native void finalizer(long native_instance);  
    long native_instance;  
}  
</code></pre>

<p>看，Xfermode就这么点代码，经验告诉我们，其下必有子类，擦，变元芳了~~~</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781708859076.png" alt="20171012150781708859076.png"/><figcaption>20171012150781708859076.png</figcaption></figure></p>

<p>查看一下文档发现Xfermode确实有AvoidXfermode、PixelXorXfermode、PorterDuffXfermode，下面来继续学习一下3个子类的用法。</p>

<h2 id="toc_1">AvoidXfermode</h2>

<p>看这个子类之前告诉大家一个不幸的消息，AvoidXfermode不支持硬件加速，在高于API16的机器上不会适用，如果想测试这个子类。</p>

<ul>
<li>1，可以关闭手机的硬件加速模块；</li>
<li>2，在AndroidManifest.xml中Application节点上设置硬件加速为false。
<code>android:hardwareAccelerated=&quot;false&quot;</code></li>
</ul>

<p>在Android Studio下点击查看一下AvoidXfermode的构造方法：<br/>
<code>public AvoidXfermode(int opColor, int tolerance, Mode mode)</code></p>

<p><code>AvoidXfermode</code>的构造方法也特别简单，一共接收3个参数：第一个参数opColor是一个16进制的带透明度通道的颜色值，如0X12345678。第二个参数<code>tolerance</code>表示容差值，什么是容差值呢？可以理解成一个表示“精确”和“模糊”的概念，下面会解释一下。第三个参数是<code>AvoidXfermode</code>的模式，<code>AvoidXfermode</code>的模式一共有两种：<code>AvoidXfermode.Mode.TARGET</code>和<code>AvoidXfermode.Mode.AVOID</code>。</p>

<h2 id="toc_2">AvoidXfermode.Mode.TARGET</h2>

<p>在该模式下Android会判断画布上的颜色是否会有跟opColor不一样的颜色，比如我opColor是红色，那么在TARGET模式下就会去判断我们的画布上是否有存在红色的地方，如果有，则把该区域“染”上一层我们画笔定义的颜色，否则不“染”色，而tolerance容差值则表示画布上的像素和我们定义的红色之间的差别该是多少的时候才去“染”的，比如当前画布有一个像素的色值是(200, 20, 13)，而我们的红色值为(255, 0, 0)，当tolerance容差值为255时，即便(200, 20, 13)并不等于红色值也会被“染”色，容差值越大“染”色范围越广反之则反，空说无凭我们来看看具体的实现和效果：</p>

<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private AvoidXfermode avoidXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        avoidXfermode = new AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        mPaint.setARGB(255, 211, 53, 243);  
        mPaint.setXfermode(avoidXfermode);  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>

<p>下面来运行看效果，首先确定一下开启的模拟器是API16以下的，或者Application节点下设置了关闭“硬件加速”：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781712590760.png" alt="20171012150781712590760.png"/><figcaption>20171012150781712590760.png</figcaption></figure></p>

<p><code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET)：</code><br/>
大家可以看到，在我们的模式为TARGET容差值为0的时候此时只有当图片中像色颜色值为0XFFFFFFFF的地方才会被染色，而其他地方不会有改变</p>

<p>下面我们来修改一下容差值，将容差值改成255：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101215078171413544.png" alt="2017101215078171413544.png"/><figcaption>2017101215078171413544.png</figcaption></figure></p>

<p><code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.TARGET)</code><br/>
而当容差值为255的时候只要是跟0XFFFFFFFF有点接近的地方都会被染色</p>

<h2 id="toc_3">AvoidXfermode.Mode.AVOID</h2>

<p>则与TARGET恰恰相反，TARGET是我们指定的颜色是否与画布的颜色一样，而AVOID是我们指定的颜色是否与画布不一样，其他的都与TARGET类似<code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.AVOID)：</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781717380140.png" alt="20171012150781717380140.png"/><figcaption>20171012150781717380140.png</figcaption></figure></p>

<p>当模式为AVOID容差值为0时，只有当图片中像素颜色值与0XFFFFFFFF完全不一样的地方才会被染色<code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.AVOID)：</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781719055648.png" alt="20171012150781719055648.png"/><figcaption>20171012150781719055648.png</figcaption></figure></p>

<p>当容差值为255时，只要与0XFFFFFFFF稍微有点不一样的地方就会被染色</p>

<p>那么这玩意究竟有什么用呢？比如说当我们只想在白色的区域画点东西或者想把白色区域的地方替换为另一张图片的时候就可以采取这种方式！</p>

<h2 id="toc_4">PixelXorXfermode</h2>

<p>PixelXorXfermode是Xfermode下的另外一种图像混排模式，该类特别简单，不过呢，也很不幸的，在API16中已经过时了。我们来做一个简单的了解，先看PixelXorXfermode的构造方法：<br/>
<code>public PixelXorXfermode(int opColor)   </code></p>

<p>构造方法很简单，只要传递一个16进制带透明通道的颜色值即可，那么这个参数有什么用呢？我在Google文档中，找到了这样的一个算法：实际上PixelXorXfermode内部是按照“opColor ^ src ^ dst”这个异或算法运算的，得到一个不透明的(alpha = 255)的色彩值，设置到图像中，下面我们接着上面用到的图片Demo写个PixelXorXfermode的Demo：</p>

<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private PixelXorXfermode pixelXorXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        pixelXorXfermode = new PixelXorXfermode(0XFFFF0000);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //先绘制Bitmap，src  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        //随便设置一个纯色测试  
        mPaint.setARGB(255, 211, 53, 243);  
        //设置Xfermode  
        mPaint.setXfermode(pixelXorXfermode);  
        //在bitmap上混排一个纯色的矩形（dst）  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>

<p>混排后的图像是：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101215078172262468.png" alt="2017101215078172262468.png"/><figcaption>2017101215078172262468.png</figcaption></figure></p>

<p>PixelXorXfermode在底层已经取出src，dst每个像素点与opColor进行了opColor ^ src ^ dst运算了，结果输出就是上图所示的那样！好了，我只学这么多了，因为它已经过时了，同样上面的AvoidXfermode也是，过时了，了解即可。下面是对Xfermode的第三个子类，也是唯一一个还没有过时的，非常重要的子类PorterDuffXfermode的学习。</p>

<h2 id="toc_5">PorterDuffXfermode</h2>

<p>同样PorterDuffXfermode也是Xfermode的子类，我们先看看它的构造方法：<code>public PorterDuffXfermode(PorterDuff.Mode mode)</code></p>

<p><code>PorterDuffXfermode</code>的构造方法很简单，构造方法中需要传递一个<code>PorterDuff.Mode</code>参数，关于<code>PorterDuff.Mode</code>，我们在上篇博客中已经学习完了，其实跟<code>ColorFilter</code>的子类<code>PorterDuffColorFilter</code>的混排模式是一样的。Android系统一共提供了18种混排模式，在模拟器的<code>ApiDemos/Graphics/XferModes</code>，有张效果图：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781665919671.png" alt="20171012150781665919671.png"/><figcaption>20171012150781665919671.png</figcaption></figure></p>

<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式已经算法，其中比上图多了ADD和OVERLAY两种模式： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781667837297.png" alt="20171012150781667837297.png"/><figcaption>20171012150781667837297.png</figcaption></figure></p>

<p>Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面将会对照ApiDemos/Graphics/XferModes的程序进行修改，来测试各个模块的效果，测试程序如下：</p>

<pre class="line-numbers"><code class="language-java">public class XfermodeView extends View {  
  
    //PorterDuff模式常量 可以在此更改不同的模式测试  
    private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;  
    private PorterDuffXfermode porterDuffXfermode;  
    private int screenW, screenH; //屏幕宽高  
    private Bitmap srcBitmap, dstBitmap;  
    //源图和目标图宽高  
    private int width = 120;  
    private int height = 120;  
  
    public XfermodeView(Context context) {  
        this(context, null);  
    }  
  
    public XfermodeView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        screenW = ScreenUtil.getScreenW((Activity) context);  
        screenH = ScreenUtil.getScreenH((Activity) context);  
        //创建一个PorterDuffXfermode对象  
        porterDuffXfermode = new PorterDuffXfermode(MODE);  
        //创建原图和目标图  
        srcBitmap = makeSrc(width, height);  
        dstBitmap = makeDst(width, height);  
    }  
  
    //创建一个圆形bitmap，作为dst图  
    private Bitmap makeDst(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFFFFCC44);  
        c.drawOval(new RectF(0, 0, w  3 / 4, h  3 / 4), p);  
        return bm;  
    }  
  
    // 创建一个矩形bitmap，作为src图  
    private Bitmap makeSrc(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFF66AAFF);  
        c.drawRect(w / 3, h / 3, w  19 / 20, h  19 / 20, p);  
        return bm;  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        Paint paint = new Paint();  
        paint.setFilterBitmap(false);  
        paint.setStyle(Paint.Style.FILL);  
        //绘制“src”蓝色矩形原图  
        canvas.drawBitmap(srcBitmap, screenW / 8 - width / 4, screenH / 12 - height / 4, paint);  
        //绘制“dst”黄色圆形原图  
        canvas.drawBitmap(dstBitmap, screenW / 2, screenH / 12, paint);  
  
        //创建一个图层，在图层上演示图形混合后的效果  
        int sc = canvas.saveLayer(0, 0, screenW, screenH, null, Canvas.MATRIX_SAVE_FLAG |  
                Canvas.CLIP_SAVE_FLAG |  
                Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |  
                Canvas.FULL_COLOR_LAYER_SAVE_FLAG |  
                Canvas.CLIP_TO_LAYER_SAVE_FLAG);  
  
        //先绘制“dst”黄色圆形  
        canvas.drawBitmap(dstBitmap, screenW / 4, screenH / 3, paint);  
        //设置Paint的Xfermode  
        paint.setXfermode(porterDuffXfermode);  
        canvas.drawBitmap(srcBitmap, screenW / 4, screenH / 3, paint);  
        paint.setXfermode(null);  
        // 还原画布  
        canvas.restoreToCount(sc);  
    }  
}  
</code></pre>

<p>为了方便观察，需要将Activity_main.xml的背景色设置为黑色。</p>

<p><strong>1.PorterDuff.Mode.CLEAR</strong>。中文描述：所绘制源图像不会提交到画布上。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781738618202.png" alt="20171012150781738618202.png"/><figcaption>20171012150781738618202.png</figcaption></figure></p>

<p><strong>2.PorterDuff.Mode.SRC</strong>。中文描述：只显示源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781741288096.png" alt="20171012150781741288096.png"/><figcaption>20171012150781741288096.png</figcaption></figure></p>

<p><strong>3.PorterDuff.Mode.DST</strong>。中文描述：只显示目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781743260843.png" alt="20171012150781743260843.png"/><figcaption>20171012150781743260843.png</figcaption></figure></p>

<p><strong>4.PorterDuff.Mode.SRC_OVER</strong>。中文描述：正常绘制显示，源图像居上显示。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OVER;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781745710454.png" alt="20171012150781745710454.png"/><figcaption>20171012150781745710454.png</figcaption></figure></p>

<p><strong>5.PorterDuff.Mode.DST_OVER</strong>。中文描述： 上下层都显示。目标图像居上显示。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OVER;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781747937193.png" alt="20171012150781747937193.png"/><figcaption>20171012150781747937193.png</figcaption></figure></p>

<p><strong>6.PorterDuff.Mode.SRC_IN</strong>。中文描述： 取两层绘制交集中的源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_IN;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781749959273.png" alt="20171012150781749959273.png"/><figcaption>20171012150781749959273.png</figcaption></figure></p>

<p><strong>7.PorterDuff.Mode.DST_IN</strong>。中文描述：取两层绘制交集中的目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_IN;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781751720575.png" alt="20171012150781751720575.png"/><figcaption>20171012150781751720575.png</figcaption></figure></p>

<p><strong>8.PorterDuff.Mode.SRC_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OUT;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781754797222.png" alt="20171012150781754797222.png"/><figcaption>20171012150781754797222.png</figcaption></figure></p>

<p><strong>9.PorterDuff.Mode.DST_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OUT;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781757188938.png" alt="20171012150781757188938.png"/><figcaption>20171012150781757188938.png</figcaption></figure></p>

<p><strong>10.PorterDuff.Mode.SRC_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_ATOP;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781759284842.png" alt="20171012150781759284842.png"/><figcaption>20171012150781759284842.png</figcaption></figure></p>

<p><strong>11.PorterDuff.Mode.DST_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_ATOP;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781760731461.png" alt="20171012150781760731461.png"/><figcaption>20171012150781760731461.png</figcaption></figure></p>

<p><strong>12.PorterDuff.Mode.XOR</strong>。中文描述：异或：去除两图层交集部分<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.XOR;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781763121426.png" alt="20171012150781763121426.png"/><figcaption>20171012150781763121426.png</figcaption></figure></p>

<p><strong>13.PorterDuff.Mode.DARKEN</strong>。中文描述：取两图层全部区域，交集部分颜色加深<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DARKEN;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781764964832.png" alt="20171012150781764964832.png"/><figcaption>20171012150781764964832.png</figcaption></figure></p>

<p><strong>14.PorterDuff.Mode.LIGHTEN</strong>。中文描述：取两图层全部，点亮交集部分颜色<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.LIGHTEN;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781767494634.png" alt="20171012150781767494634.png"/><figcaption>20171012150781767494634.png</figcaption></figure></p>

<p><strong>15.PorterDuff.Mode.MULTIPLY</strong>。中文描述：取两图层交集部分叠加后颜色<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.MULTIPLY;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781769541182.png" alt="20171012150781769541182.png"/><figcaption>20171012150781769541182.png</figcaption></figure></p>

<p><strong>16.PorterDuff.Mode.SCREEN</strong>。中文描述：滤色。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SCREEN;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781776874733.png" alt="20171012150781776874733.png"/><figcaption>20171012150781776874733.png</figcaption></figure></p>

<p>以下是<a href="http://lib.csdn.net/base/android">android</a>中新加的两种模式：</p>

<p><strong>17.ADD</strong>。中文描述：饱和度相加。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.ADD;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781785445313.png" alt="20171012150781785445313.png"/><figcaption>20171012150781785445313.png</figcaption></figure></p>

<p><strong>18.OVERLAY</strong>。中文描述：叠加<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.OVERLAY;</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781786831311.png" alt="20171012150781786831311.png"/><figcaption>20171012150781786831311.png</figcaption></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870461.html">
                
                  <h1>Android-Paint详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>的确平时开发中，用到画笔的地方还是不多的。但是一遇到自定义View，就会发现这玩意还真是不能不好好掌握，毕竟绘出我们想要的图形界面就靠它了。很多开发人员对画笔Paint的了解知之甚少，包括我自己在内，所以在今天在这里总结一下Paint的在 android图像处理中起到的作用和用法。</p>

<h2 id="toc_1">Paint的简单了解</h2>

<p>同样，我们学习Paint之前，首先查看一下Paint类的API，其中，我们最需要关注的地方就是Paint类给我们提供了很多的setter方法，可以通过调用setter方法来设置自己的偏好。下面是在Android Studio中查到的Paint类的部分setter：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781677410193.png" alt="20171012150781677410193.png"/><figcaption>20171012150781677410193.png</figcaption></figure></p>

<ul>
<li><code>Paint(int flags)</code>：构建Paint实例，常用的flags是ANTI_ALIAS_FLAG，消除锯齿。</li>
<li><code>set(Paint src)</code>：将另一个Paint复制给当前Paint实例，不多说了。</li>
<li><code>setColor(int color)</code>：设置画笔的颜色。</li>
<li><code>setColorFilter(ColorFilter filter)</code>：设置色彩过滤器，很重要，后面还会有一些总结。</li>
<li><code>setStyle(Paint.Style style)</code>：设置Paint的风格。 画笔样式分三种：1.Paint.Style.STROKE：描边 。2.Paint.Style.FILL_AND_STROKE：描边并填充 。3.Paint.Style.FILL：填充 。</li>
<li><code>setAlpha(int a)</code> : 设置绘制图形的透明度。</li>
<li><code>setAntiAlias(boolean aa)</code>：是否消除锯齿。</li>
<li><code>setARGB(int a,int r,int g,int b)</code> : 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。</li>
<li><code>setStrokeWidth(float width)</code>：设置Paint划线的宽度。</li>
<li><code>setDither(boolean dither)</code> : 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰</li>
<li><code>setElegantTextHeight(boolean elegant)</code> : //设置优雅的文字高度，这个设置可能会对FontMetrics产生影响</li>
<li><code>setFakeBoldText(boolean fakeBoldText)</code> : //设置文本粗体</li>
<li><code>setFilterBitmap(boolean filter)</code> : //对位图进行滤波处理，如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示</li>
<li><code>setFlags(int flags)</code> : //设置一些标志，比如抗锯齿，下划线等等。</li>
<li><code>setFontFeatureSettings(String settings)</code> : //设置字体样式，可以设置CSS样式</li>
<li><code>setHinting(int mode)</code> : 设置画笔的隐藏模式。可以是 <code>HINTING_OFF</code> or <code>HINTING_ON</code>之一。</li>
<li><code>setLetterSpacing(float letterSpacing)</code> : //设置行的间距，默认值是0，负值行间距会收缩</li>
<li><code>setLinearText(boolean linearText)</code> : //这个是文本缓存，设置线性文本，如果设置为true就不需要缓存</li>
<li><code>setMaskFilter(MaskFilter maskfilter)</code> : //对图像进行一定的处理，实现滤镜的效果，如滤化，立体等,有BlurMaskFilter，EmbossMaskFilter几种</li>
<li><code>setPathEffect(PathEffect effect)</code> : //设置绘制路径的效果，有ComposePathEffect，CornerPathEffect，DashPathEffect，DiscretePathEffect，PathDashPathEffect，SumPathEffect几种</li>
<li><code>setShader(Shader shader)</code> : //设置着色器，用来给图像着色的，绘制出各种渐变效果，有BitmapShader，ComposeShader，LinearGradient，RadialGradient，SweepGradient几种</li>
<li><code>setShadowLayer(float radius, float dx, float dy, int shadowColor)</code> : //设置阴影效果，radius为阴影角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 ，看一下演示效果，其中第一个是没有阴影的，第二个设置了黑色的阴影</li>
<li><code>setStrikeThruText(boolean strikeThruText)</code> : //设置文本的删除线</li>
<li><code>setStrokeCap(Cap cap)</code> : //设置线条末端形状<code>Paint.Cap.BUTT</code>、<code>Paint.Cap.ROUND</code>、<code>Paint.Cap.SQUARE</code></li>
<li><code>setStrokeJoin(Join join)</code> : //设置矩形连接时的效果<code>Paint.Join.BEVEL</code>、<code>Paint.Join.MITER</code>、<code>Paint.Join.ROUND</code></li>
<li><code>setStrokeMiter(float miter)</code> : //当style为Stroke或StrokeAndFill时设置连接处的倾斜度，这个值必须大于0</li>
<li><code>setSubpixelText(boolean subpixelText)</code> : //设置亚像素，是对文本的一种优化设置，可以让文字看起来更加清晰明显，可以参考一下PC端的控制面板-外观和个性化-调整ClearType文本</li>
<li><code>setTextAlign(Align align)</code> : //设置文本对齐<code>Paint.Align.CENTER</code>、<code>Paint.Align.LEFT</code>、<code>Paint.Align.RIGHT</code></li>
<li><code>setTextLocale(Locale locale)</code> ： //设置地理位置，比如显示中文，日文，韩文等，默认的显示Locale.getDefault()即可</li>
<li><code>setTextScaleX(float scaleX)</code> : //设置字体的水平方向的缩放因子，默认值为1，大于1时会沿X轴水平放大，小于1时会沿X轴水平缩小</li>
<li><code>setTextSize(float textSize)</code> : //设置字体大小</li>
<li><code>setTextSkewX(float skewX)</code> : //设置文本在水平方向上的倾斜，默认值为0，推荐的值为-0.25</li>
<li><code>setTypeface(Typeface typeface)</code> : //设置字体样式，可以是Typeface设置的样式，也可以通过Typeface的createFromAsset(AssetManager mgr, String path)方法加载样式</li>
<li><code>setUnderlineText(boolean underlineText)</code> : //设置文本的下划线</li>
<li><code>setXfermode(Xfermode xfermode)</code>：设置Paint的模式，后面有详细点的说明，很重要。</li>
<li><code>reset()</code> : //重置Paint</li>
<li><code>measureText(char[] text, int index, int count)</code>，<code>measureText(String text, int start, int end)</code>，<code>measureText(String text)</code>，<code>measureText(CharSequence text, int start, int end)</code> : //测量字体的长度</li>
<li><code>breakText(char[] text, int index, int count,float maxWidth, float[] measuredWidth)</code>，<code>breakText(CharSequence text, int start, int end,boolean measureForwards,  floatmaxWidth, float[] measuredWidth)</code>，<code>breakText(String text, boolean measureForwards,float maxWidth, float[] measuredWidth)</code> : //剪切显示，就是大于maxWidth的时候只截取指定长度的显示</li>
<li><code>getTextWidths(char[] text, int index, int count,float[] widths)</code>，<code>getTextWidths(CharSequence text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, float[] widths)</code> : //提取指定范围内的字符串，保存到widths中</li>
<li><code>getTextPath(char[] text, int index, int count, float x, float y, Path path)</code>，<code>getTextPath(String text, int start, int end, float x, float y, Path path)</code> : //获取文本绘制的路径，提取到Path中</li>
<li><code>getTextBounds(String text, int start, int end, Rect bounds)</code>，<code>getTextBounds(char[] text, int index, int count, Rect bounds)</code> : //得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870430.html">
                
                  <h1>Android-ColorFilter详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在Android Studio中点击进去看一下源码，可以看到ColorFilter里的代码量很少</p>

<pre class="line-numbers"><code class="language-java">public class ColorFilter {  
    /** 
     * Holds the pointer to the native SkColorFilter instance. 
     * 
     * @hide 
     */  
    public long native_instance;  
  
    @Override  
    protected void finalize() throws Throwable {  
        try {  
            super.finalize();  
        } finally {  
            destroyFilter(native_instance);  
        }  
    }  
  
    static native void destroyFilter(long native_instance);  
}
</code></pre>

<p>由此根据我们的经验，判断ColorFilter可能是个父类，具体实现可能下面还有子类完成的，于是再看Google的文档：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781638185946.png" alt="20171012150781638185946.png"/><figcaption>20171012150781638185946.png</figcaption></figure></p>

<p>一目了然了，ColorFilter下有3个子类ColorMatrixColorFilter, LightingColorFilter, PorterDuffColorFilter ，下面逐一学习一下。</p>

<h2 id="toc_1">ColorMatrixColorFilter</h2>

<p><code>ColorMatrixColorFilter</code>翻译为颜色矩阵过滤器，神马是颜色矩阵？实际上， 安卓中管理色彩矩阵是以RGBA像素点的方式加载到内存的，这些点统一使用<code>ColorMatrix</code>的矩阵来统一管理，矩阵定义为4*5的排列形式。那好，首先来看看<code>ColorMatrixColorFilter</code>的两个构造器：</p>

<pre class="line-numbers"><code class="language-java">public ColorMatrixColorFilter(ColorMatrix matrix) {  
        mMatrix.set(matrix);  
        update();  
}  
  
public ColorMatrixColorFilter(float[] array) {  
        if (array.length &lt; 20) {  
            throw new ArrayIndexOutOfBoundsException();  
        }  
        mMatrix.set(array);  
        update();  
}  
</code></pre>

<p>ColorMatrixColorFilter中一个构造器需要接收ColorMatrix对象，另一个需要接收一个4*5的float型数组，我们再打开Android Studio追踪一下mMatrix.set()方法，可以看到以上两个构造器里面调的set方法各自实现的方式</p>

<pre class="line-numbers"><code class="language-java">public void set(ColorMatrix src) {  
        System.arraycopy(src.mArray, 0, mArray, 0, 20);  
}  
  
public void set(float[] src) {  
        System.arraycopy(src, 0, mArray, 0, 20);  
}  
</code></pre>

<p>再追踪一下System.arraycopy()方法：</p>

<pre class="line-numbers"><code class="language-java">public static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length)
</code></pre>

<p>好了，到这里，其实已经很明白了，ColorMatrixColorFilter构造器中接收的两个不同的参数，实际上底层实现方式都是一样的，都是同样调用System.arraycopy()中带float数组参数的方法。所以我们不必再考虑怎么样去写一个ColorMatrix对象传递给ColorMatrixColorFilter了，实际上我们使用第二个构造器，传递一个float数组，会显得程序更加直观易懂，那么我们就尝试写一个ColorMatrixColorFilter，并且设置给Paint吧.</p>

<pre class="line-numbers"><code class="language-java">public class CustomView1 extends View {  
    private Paint mPaint;  
    private Context mContext;  
    public CustomView1(Context context) {  
        this(context, null);  
    }  
  
    public CustomView1(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initPaint();  
    }  
    private void initPaint() {  
        //初始化Paint，并且设置消除锯齿。  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        //设置画笔样式为描边  
        mPaint.setStyle(Paint.Style.FILL);  
        //设置描边的粗细，单位：像素px 注意：当setStrokeWidth(0)的时候描边宽度并不为0而是只占一个像素  
        mPaint.setStrokeWidth(20);  
        //设置画笔颜色为自定义颜色  
        mPaint.setColor(Color.argb(255, 255, 128, 102));  
        ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1, 0, 0, 0, 0,  
                0, 1, 0, 0, 0,  
                0, 0, 1, 0, 0,  
                0, 0, 0, 1, 0  
        });  
        mPaint.setColorFilter(colorFilter);  
    }  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //画一个圆形，取屏幕中心点为圆心  
        canvas.drawCircle(ScreenUtil.getScreenW(mContext) / 2,  
                ScreenUtil.getScreenH(mContext) / 2, 100, mPaint);  
    }  
}
</code></pre>

<p>看上面的例子程序，首先创建了一个ColorMatrixColorFilter对象，并且传递进去一个float型的4*5排列的数组，然后调用Paint的setColorFilter方法将ColorMatrixColorFilter对象传入，我们在模拟器上运行一下，duang~~，我去，什么变化都没有，还是岛国的旗帜。这是怎么回事？下面有必要在学习一下了：</p>

<p>其实一个4*5的float数组中分别对应的是RGBA的向量值，第一行代表的是R(红色)的向量值，第二行代表G(绿色)的向量值，第三行代表B(蓝色)的向量值，第四行代表A(透明度)的向量值，这4行分别代表不同的RGBA的向量值，并且值的取值范围是[0.0F , 2.0F]，当值为1.0F的时候，表示保持原有的色彩，不发生色彩便宜。so，如果我们想要将上面的红色的圈圈颜色变掉，就不能像上面的代码一样，将所有的向量值都设置为1.0F，下面我们修改一个：</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.5F, 0, 0, 0, 0,  
                0, 0.5F, 0, 0, 0,  
                0, 0, 0.5F, 0, 0,  
                0, 0, 0, 1, 0  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p>将上面的ColorMatrixColorFilter中的float数组替换成这样的<br/>
哎哟呵~颜色变深了，看起来神奇很多。那么，这个色彩矩阵以及这个float数组是怎样做到的呢？或者说是怎样通过计算后得到另外一个色彩值的呢？下面作图来说明一下，我们顶一个ColorMatrix的4*5的float型数组，然后定义一个我们自己MyColor，分别代表RGBA的值：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781645122295.jpg" alt="20171012150781645122295.jpg"/><figcaption>20171012150781645122295.jpg</figcaption></figure></p>

<p>实际上，安卓系统计算色彩值是用矩阵相乘的方式得出的，如上图的样子。这里的MyColor的各项值都要转换到[0,1]之间的值，下面就是我们实际转换的计算方式和结果了。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781647527079.jpg" alt="20171012150781647527079.jpg"/><figcaption>20171012150781647527079.jpg</figcaption></figure></p>

<p>通过上面的计算，我们得到了最终的RGBA的值是（0.5,0.25,0.2,1），说明RGB色彩值都发生了便宜，只有A未偏移，然后我们将这些值乘以255后还原一下看看，是不是跟上图的圈圈的色彩值是一致的呢，好吧，别看了，肯定必须一定是一样的。那么了解色彩矩阵有什么用呢？上面简单的更换一下色彩值而已，Paint类下也提供了setColor()方法，直接将色彩值设置上去，都TMD的方便，还搞什么玩意的矩阵，显得自己牛逼+蛋疼是不是？解释一下，上面的例子不过是个例子而已啊，真正开发的时候肯定是setColor比较简便嘛。问题来了，我们有可能处理的不是一个纯色彩的东西，而是一直图片呢？一张图片是有几十万中色彩值的，这时候setColor()就不可能让他们变色了吧，还是得用色彩矩阵来搞这玩意。下面我们从drawable目录下加载一张图片吧！</p>

<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781650576419.png" alt="20171012150781650576419.png"/><figcaption>20171012150781650576419.png</figcaption></figure></p>

<p>好了图片加载完毕，代码没有难度，上面的Paint没有做任何的处理，下面我们为Paint设置色彩过滤器吧！</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0, 0, 0, 1, 0,  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781653146217.png" alt="20171012150781653146217.png"/><figcaption>20171012150781653146217.png</figcaption></figure></p>

<p>好吧图片变成黑白的了，难道setColor()也可以办吗？再改一个试试：</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                0, 0, 0, 1, 0,  
        });  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781655966867.png" alt="20171012150781655966867.png"/><figcaption>20171012150781655966867.png</figcaption></figure></p>

<p>这样的效果是不是有点像负片效果啊！好了，反正我也不懂图像学，ColorMatrixColorFilter想设置什么样的就改改矩阵就行了，到底需要什么效果，效果的值要设置成多少，我也不知道，问问美工吧！我们只负责写程序！呵呵~~</p>

<h2 id="toc_2">LightingColorFilter</h2>

<p>LightingColorFilter顾名思义就是“光照色彩过滤器”，就是模拟一个光照照过图像所产生的效果，构造器是这样的：<br/>
<code>public LightingColorFilter(int mul, int add)</code><br/><br/>
查看一下Google文档，是这样介绍滴：</p>

<p>光照色彩滤光片，可以用来模拟简单的照明效果。一个lightingcolorfilter定义了两个参数，一个用于与源颜色相乘（称为colormultiply）和一个用于添加到源颜色（称为coloradd）。alpha通道是原封不动的彩色滤光片。给定一个源颜色的RGB，由此产生的特定颜色计算如下：</p>

<pre class="line-numbers"><code class="language-text">R&#39; = R * colorMultiply.R + colorAdd.R
G&#39; = G * colorMultiply.G + colorAdd.G
B&#39; = B * colorMultiply.B + colorAdd.B
</code></pre>

<p>每个通道值的结果范围是0~255。上面的介绍写的比较明白， 算法也很简单，我们以上面的原图为例，看见蓝天了吗，我们现在去掉这个蓝色的天。根据这个短发描述呢，我们仅仅去掉蓝色，就要将蓝色的通道值改变，将B计算为其它值，这时候colorMultiply.B = 00，colorAdd.B =00，计算得到的B = 00，其它的通道R和G均不变，那么,colorAdd.R=0，colorAdd.G =0；colorMultiply.R = FF，colorMultiply.G =FF，Alpha通道A是忽略的，所以随便设置什么都不会有变化的。</p>

<pre class="line-numbers"><code class="language-java">LightingColorFilter colorFilter = new LightingColorFilter(0xFFFFFF00, 0x00000000);  
mPaint.setColorFilter(colorFilter);
</code></pre>

<p>运行之后的结果，蓝天没了。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781662212525.png" alt="20171012150781662212525.png"/><figcaption>20171012150781662212525.png</figcaption></figure></p>

<h2 id="toc_3">PorterDuffColorFilter</h2>

<p>ColorFilter下还有最后一个子类，PorterDuff混合模式的色彩过滤器，下面是其构造器：<br/>
<code>public PorterDuffColorFilter(int color, PorterDuff.Mode mode)</code></p>

<p>Google文档：PorterDuff滤光器可以用于点源像素使用一个单一的颜色和一个特定的波特达夫复合模式。</p>

<p>PorterDuffColorFilter的构造器也很简单，其中第一个参数表示一个16进制的色彩值，第二个参数是一个枚举值PorterDuff.Mode，表示图片混排的模式，PorterDuff.Mode在Android下一共有16种。下面我们先写一个小例子看一下，这里我们还是使用上面的图片，为原图添加图片混排模式，颜色值设置为红色0XFFFF0000，混排模式设置为PorterDuff.Mode.DARKEN。</p>

<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(0XFFFF0000, PorterDuff.Mode.DARKEN);  
        mPaint.setColorFilter(colorFilter);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>

<p>上面的图片就是运行之后的效果了，原图不仅变红了，而且还变暗了。其实我们这里将PorterDuffColorFilter的构造器参数拆开来分析一下，首先我们传递进去一个红色的颜色值0XFFFF0000，这里相当于创建了一张新的图层，图层的颜色就是0XFFFF0000，而我们的原图可以看作是第二张图层，我们先把这2个图片重叠放在一起，就会发现得到一个原图上很红的图片，然后我们看一下PorterDuff.Mode是DARKEN模式，表示在之前得到的“原图+很红”的图片上进一步将色调调成暗色，最终得到了如上所示的图片。</p>

<p>关于PorterDuff.Mode，Android系统一共提供了18种混排模式，在模拟器的ApiDemos/Graphics/XferModes，有张效果图：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781665919671.png" alt="20171012150781665919671.png"/><figcaption>20171012150781665919671.png</figcaption></figure></p>

<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式算法，其中比上图多了ADD和OVERLAY两种模式：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781667837297.png" alt="20171012150781667837297.png"/><figcaption>20171012150781667837297.png</figcaption></figure></p>

<p>其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面是在网上找到的汉字语言描述，感谢这位作者的总结。</p>

<p>注意：先绘制dst，再绘制src。</p>

<ul>
<li><strong>1.PorterDuff.Mode.CLEAR</strong>    所绘制源图像不会提交到画布上。</li>
<li><strong>2.PorterDuff.Mode.SRC</strong>    只显示源图像。</li>
<li><strong>3.PorterDuff.Mode.DST</strong>    只显示目标图像。</li>
<li><strong>4.PorterDuff.Mode.SRC_OVER</strong>    正常绘制显示，源图像居上显示。</li>
<li><strong>5.PorterDuff.Mode.DST_OVER</strong>    上下层都显示。目标图像居上显示。</li>
<li><strong>6.PorterDuff.Mode.SRC_IN</strong>    取两层绘制交集中的源图像。</li>
<li><strong>7.PorterDuff.Mode.DST_IN</strong>     取两层绘制交集中的目标图像。</li>
<li><strong>8.PorterDuff.Mode.SRC_OUT</strong>    只在源图像和目标图像不相交的地方绘制源图像。</li>
<li><strong>9.PorterDuff.Mode.DST_OUT</strong>    只在源图像和目标图像不相交的地方绘制目标图像。</li>
<li><strong>10.PorterDuff.Mode.SRC_ATOP</strong>    在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。</li>
<li><strong>11.PorterDuff.Mode.DST_ATOP</strong>   在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。</li>
<li><strong>12.PorterDuff.Mode.XOR</strong>    异或：去除两图层交集部分</li>
<li><strong>13.PorterDuff.Mode.DARKEN</strong>     取两图层全部区域，交集部分颜色加深</li>
<li><strong>14.PorterDuff.Mode.LIGHTEN</strong>   取两图层全部，点亮交集部分颜色</li>
<li><strong>15.PorterDuff.Mode.MULTIPLY</strong>    取两图层交集部分叠加后颜色</li>
<li><strong>16.PorterDuff.Mode.SCREEN</strong>    滤色。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870348.html">
                
                  <h1>Android-ViewStub详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在开发应用程序的时候，经常会遇到这样的情况，会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为<code>View.GONE</code>，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见<code>View.GONE</code>但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</p>

<h2 id="toc_1">ViewStub</h2>

<p>上面的问题，推荐的做法是使用 Android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了<code>ViewStub.inflate()</code>的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。<br/>
但ViewStub也不是万能的，下面总结下ViewStub能做的事儿和什么时候该用ViewStub，什么时候该用可见性的控制。</p>

<h2 id="toc_2">特点</h2>

<ul>
<li>ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不能够再通过ViewStub来控制它了。</li>
<li>ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</li>
</ul>

<h2 id="toc_3">可以考虑使用ViewStub的情况</h2>

<ul>
<li>在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要<em>在运行时不止一次的显示和隐藏某个布局</em>，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。</li>
<li>想要控制显示与隐藏的是一个布局文件，而非某个View。因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。</li>
</ul>

<h2 id="toc_4">下面来看一个实例</h2>

<p>在这个例子中，要显示二种不同的布局，一个是用TextView显示一段文字，另一个则是用ImageView显示一个图片。这二个是在onCreate()时决定是显示哪一个，这里就是应用ViewStub的最佳地点。</p>

<p>先来看看布局，一个是主布局，里面只定义二个ViewStub，一个用来控制TextView一个用来控制ImageView，另外就是一个是为显示文字的做的TextView布局，一个是为ImageView而做的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;fill_parent&quot;  
  android:layout_height=&quot;fill_parent&quot;  
  android:gravity=&quot;center_horizontal&quot;&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_text&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout_marginTop=&quot;10dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_text_layout&quot;/&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_image&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_image_layout&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>为TextView的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;TextView  
        android:id=&quot;@+id/viewstub_demo_textview&quot;  
        android:layout_width=&quot;fill_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:background=&quot;#aa664411&quot;  
        android:textSize=&quot;16sp&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>为ImageView的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;ImageView  
        android:id=&quot;@+id/viewstub_demo_imageview&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>下面来看代码，决定来显示哪一个，只需要找到相应的ViewStub然后调用其infalte()就可以获得相应想要的布局：</p>

<pre class="line-numbers"><code class="language-java">public class ViewStubDemoActivity extends Activity {  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.viewstub_demo_activity);  
        if ((((int) (Math.random() * 100)) &amp; 0x01) == 0) {  
            // to show text  
            // all you have to do is inflate the ViewStub for textview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_text);  
            stub.inflate();  
            TextView text = (TextView) findViewById(R.id.viewstub_demo_textview);  
            text.setText(&quot;The tree of liberty must be refreshed from time to time&quot; +  
                    &quot; with the blood of patroits and tyrants! Freedom is nothing but &quot; +  
                    &quot;a chance to be better!&quot;);  
        } else {  
            // to show image  
            // all you have to do is inflate the ViewStub for imageview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_image);  
            stub.inflate();  
            ImageView image = (ImageView) findViewById(R.id.viewstub_demo_imageview);  
            image.setImageResource(R.drawable.happy_running_dog);  
        }  
    }  
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/8</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870386.html">
                
                  <h1>Android-DataBinding详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>谷歌开发了一个非常厉害的新框架DataBinding， 数据绑定框架给我们带来了很大的方便，以前我们可能需要在每个Activity里写很多的findViewById，不仅麻烦，还增加了代码的耦合性，如果我们使用DataBinding，就可以抛弃那么多的findViewById，省时省力。说到这里，其实网上也有很多快速的注解框架，但是注解框架与DataBinding想比还是不好用，而且官网文档说DataBinding还能提高解析XML的速度，其实DataBinding的好用，不仅仅体现在可以省去使用很多啰嗦findViewById，还有很多。往下看你就会明白的。</p>

<p>在介绍DataBinding之前，肯定要先学会搭建使用它的环境。在Android Studio上Databinding的使用还是很简单的。</p>

<h2 id="toc_1">环境搭建</h2>

<p>Android 的 Gradle 插件版本不低于 1.5.0-alpha1：classpath &#39;com.android.tools.build:gradle:1.5.0&#39;然后修改对应模块（Module）的 build.grade：</p>

<pre class="line-numbers"><code class="language-java">android {
    ....
    dataBinding {
        enabled = true
    }
}
</code></pre>

<p>注意：Android stuido 的版本一定要大于1.3，而且Android Studio目前对binding对象没有自动代码提示，只会在编译时进行检查。<br/>
就是这么简单，但是1.3及以前的版本，对于环境的搭建，可能就会麻烦一点（没事1.3的环境搭建方法，网上多得是）。</p>

<h2 id="toc_2">基础展示</h2>

<p>我们在具体的讲解之前，先用一个简单的小例子来学习一下基础并展现一下DataBinding的巨大魅力，估计你会被其简单的特性所吸引哦。<br/><br/>
首先我们先建立一个java bean，就是一个非常简单的用户类吧。</p>

<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding.bean;
/**
 * Created by loongggdroid on 2016/3/14.
 */
public class User {
    private String name;
    private String age;
    public User(String name, String age) {
        this.name = name;
        this.age = age;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(String age) {
        this.age = age;
    }
    public String getName() {
        return this.name;
    }
    public String getAge() {
        return this.age;
    }
}
</code></pre>

<p>其次，来看看使用了DataBinding之后的布局文件是什么样子的呢？主要的变化是在layout布局文件之中。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.name}&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.age}&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p>看到这里，可能有的人就开始有点迷糊了，没有给控件定义id，而是用了@{ }的方法，到底是怎么回事？先不忙，一会再给你解释，我们再来看看怎么把值传进去的，在Activity中是如何使用的。</p>

<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding;

import android.app.Activity;
import android.databinding.DataBindingUtil;
import android.os.Bundle;

import loonggg.net.databinding.bean.User;
import loonggg.net.databinding.databinding.ActivityMainBinding;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
        User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
        binding.setUser(user);
    }

}
</code></pre>

<p>看到Activity是不是感觉很简洁，很清爽，没有了控件的初始化findViewById，然后再去setText(), 就仅仅只添加了两行代码。运行结果，不用说，显而易见，肯定会显示loonggg和23。</p>

<h2 id="toc_3">基础用法</h2>

<h3 id="toc_4">布局生命</h3>

<p>例子我们介绍完了，对于例子中出现的一些新东西，有必要解释一下，java bean那里就不解释了，大家肯定都懂，我们就从布局文件讲起。相比以前使用的xml，根节点由具体的某个layout（比如LinearLayout ）变成了layout，里面包括了data节点和传统的视图。这里的data节点就像是连接 View 和 Modle 的桥梁。在这个data节点中声明一个variable变量，那值就可以轻松传到布局文件中来了。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;!--type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user--&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt; 
    &lt;LinearLayout&gt;
     ……
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p>变量名为user变量类型为&quot;loonggg.net.databinding.bean.User &quot;</p>

<p>type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user，TextView中的@{user.name}就是把这个user中的名字展示出来，age同样如此。</p>

<h3 id="toc_5">绑定Variable</h3>

<p>虽然在布局文件中对应上了，但是值是怎么传进去的呢？这就是我们要将的Activity中的那两行代码了，它把实体类和布局文件进行了绑定。修改MainActivity中的onCreate，用 DatabindingUtil.setContentView() 来替换掉 setContentView()，然后创建一个 user 对象，通过 binding.setUser(user) 与 variable 进行绑定。</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
    binding.setUser(user);
}
</code></pre>

<p>ActivityLayoutDetailBinding这个类是自动生成的和你的布局文件名字一样，如果你想要去改变名字的话</p>

<pre class="line-numbers"><code class="language-markup">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;  
  
    &lt;!--这里你也可以为Binding类进行命名，有三种形式  
        1、Custom:会在databinding包下  
        2、.Custom:会在当前的包名下创建  
        3、com.andly.Custom:会在指定的包名下进行创建--&gt;  
    &lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt; //在app_package/databinding下生成CustomBinding；
    &lt;data class=&quot;.CustomBinding&quot;&gt;&lt;/data&gt; //在app_package下生成CustomBinding；
    &lt;data class=&quot;com.example.CustomBinding&quot;&gt;&lt;/data&gt; // 明确指定包名和类名。
</code></pre>

<h2 id="toc_6">高级用法</h2>

<h3 id="toc_7">import用法</h3>

<p>其实data节点也是支持import用法的，比如：</p>

<pre class="line-numbers"><code class="language-java">&lt;data&gt;
     &lt;import type=&quot;loonggg.net.databinding.bean.User &quot;/&gt;
     &lt;variablename=&quot;user&quot;type=&quot;User&quot; /&gt;
&lt;/data&gt;
</code></pre>

<p>这里需要注意的是：<code>import</code>并不能像java 一样可以 <code>import xx.xxx.*</code>，必须具体到写清楚每个要导入的类名。</p>

<h3 id="toc_8">类名相同</h3>

<p>到这里你可能会问如果import了两个相同名称的类咋办？别怕，人家想的很周到，可以起个别名或者昵称嘛！例如：</p>

<pre class="line-numbers"><code class="language-java">···
&lt;data&gt; 
  &lt;import type=&quot;xxx.User&quot; alias=&quot;MyUser&quot;&gt; 
  &lt;import type=&quot;xxx.xx.User&quot;&gt; 

   &lt;variable 
            name=&quot;user&quot; 
            type=&quot;User&quot; /&gt; 
    &lt;variable 
            name=&quot;myUser&quot; 
            type=&quot;MyUser&quot;/&gt; 
&lt;/data&gt; 
&lt;TextView xxx:@{myUser.getName()}&gt; 
&lt;TextView xxx:@{user.getName()}&gt;
···
</code></pre>

<h3 id="toc_9">变量定义的高级用法</h3>

<p>在上面，我们学会了如何去在xml中定义一些简单的变量。我们没有定义像List、Map等这样的集合变量。那这种集合变量该如何定义呢？其实定义的方式和我们上面的基本一致，区别就在于我们还需要为它定义key的变量，例如：</p>

<pre class="line-numbers"><code class="language-markup">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; 
    &lt;data&gt; 
        &lt;import type=&quot;android.graphics.Bitmap&quot; /&gt; 
        &lt;import type=&quot;java.util.ArrayList&quot; /&gt; 
        &lt;import type=&quot;java.util.HashMap&quot; /&gt;  
        &lt;!-- 集合的定义 --&gt;
        &lt;variable 
            name=&quot;list&quot; 
            type=&quot;ArrayList&amp;lt;String&gt;&quot; /&gt; // 左尖括号需要转义
        &lt;variable 
            name=&quot;map&quot; 
            type=&quot;HashMap&amp;lt;String, String&gt;&quot; /&gt; 
        &lt;variable 
            name=&quot;array&quot; 
            type=&quot;String[]&quot; /&gt; 
        &lt;!-- 为集合定义对应的索引 --&gt;
        &lt;variable 
            name=&quot;listKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;variable 
            name=&quot;mapKey&quot; 
            type=&quot;String&quot; /&gt; 
        &lt;variable 
            name=&quot;arrayKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;!-- 字符串，布尔值和int的用法--&gt;
        &lt;variable 
            name=&quot;str&quot; 
            type=&quot;String&quot;/&gt; 
        &lt;variable 
            name=&quot;error&quot; 
            type=&quot;boolean&quot;/&gt; 
        &lt;variable 
            name=&quot;num&quot; 
            type=&quot;int&quot; /&gt; 
    &lt;/data&gt; 
    &lt;LinearLayout 
        android:orientation=&quot;vertical&quot; 
        android:layout_width=&quot;match_parent&quot; 
        android:layout_height=&quot;wrap_content&quot;&gt; 

        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{list[listKey]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{map[`name`]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{array[0]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{str}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{String.valueOf(num)}&quot;/&gt; 
    &lt;/LinearLayout&gt; 
&lt;/layout&gt;
</code></pre>

<p>在引用的同时也可以加上简单的逻辑运算</p>

<pre class="line-numbers"><code class="language-markup">&lt;!--数据绑定将自动检测null异常，如果你的表达式为null，它将会给它赋值为(null)  
 如果为int类型则默认为0--&gt;  
 &lt;!--之前都是写三元运算符的形式，当然在数据绑定中也能够使用，但更推荐下面那种--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{boo?note:null}&quot; /&gt;  
 &lt;!--?? :null合并运算符，当左边为null会显示右边--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{note??null}&quot;  
     android:textColor=&quot;#00FF00&quot;  
     android:textSize=&quot;18sp&quot; /&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;!--引用资源文件--&gt;  
&lt;ImageView  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:paddingLeft=&quot;@{boo?@dimen/large_padding:@dimen/small_padding}&quot;  
    android:src=&quot;@{image}&quot; /&gt; 
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;TextView  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&#39;@{String.valueOf(map[`one`])}&#39;/&gt;  
</code></pre>

<h3 id="toc_10">Observable数据改变自动更新</h3>

<p><code>Observable</code>是一个接口，它的子类有<code>BaseObservable</code>,<code>ObservableField</code>,<code>ObservableBoolean</code>,<code>ObservableByte</code>, <code>ObservableChar</code>, <code>ObservableShort</code>, <code>ObservableInt</code>, <code>ObservableLong</code>, <code>ObservableFloat</code>, <code>ObservableDouble</code>, and <code>ObservableParcelable</code>，<code>ObservableArrayList</code>,<code>ObservableArrayMap</code><br/>
现在我们来看看 如何在数据改变时，不手动设置，让其自动改变：</p>

<p><strong>布局文件</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Person&quot; /&gt;
        &lt;variable
            name=&quot;person&quot;
            type=&quot;Person&quot; /&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`firstName:`+person.firstName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`lastName:`+person.lastName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`age:`+person.age}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/second_btn1&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;改变数据&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>Person类</strong></p>

<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding.model;

import android.databinding.BaseObservable;
import android.databinding.Bindable;

import www.zhang.com.databinding.BR;

public class Person extends BaseObservable {
    private String firstName;
    private String lastName;
    private int age;
    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    @Bindable
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
        notifyPropertyChanged(BR.firstName);
    }
    @Bindable
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
        notifyPropertyChanged(BR.lastName);
    }
    @Bindable
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
        notifyPropertyChanged(BR.age);
    }
}
</code></pre>

<p>Model类继承BaseObservable,BaseObservable实现 Android.databinding.Observable接口，Observable接口可以允许附加一个监听器到model对象以便监听对象上的所有属性的变化。<br/><br/>
Observable接口有一个机制来添加和删除监听器，但通知与否由开发人员管理。为了使开发更容易，BaseObservable实现了监听器注册机制。DataBinding实现类依然负责通知当属性改变时。这是通过指定一个Bindable注解给getter以及setter内通知来完成的。<br/><br/>
notifyPropertyChanged(BR.参数名)通知更新这一个参数，需要与@Bindable注解配合使用。notifyChange()通知更新所有参数，可以不用和@Bindable注解配合使用</p>

<p><strong>SecondActivity</strong></p>

<pre class="line-numbers"><code class="language-java">public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivitySecondBinding binding = DataBindingUtil.setContentView(SecondActivity.this, R.layout.activity_second);

        final Person person = new Person(&quot;zhang&quot;,&quot;san&quot;,38);
        binding.setPerson(person);

        binding.secondBtn1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                person.setFirstName(&quot;li&quot;);
                person.setLastName(&quot;si&quot;);
                person.setAge(40);
            }
        });
    }
}
</code></pre>

<h4 id="toc_11">示例</h4>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Animal&quot;/&gt;
        &lt;variable
            name=&quot;animal&quot;
            type=&quot;Animal&quot;/&gt;
        &lt;variable
            name=&quot;list&quot;
            type=&quot;android.databinding.ObservableArrayList&amp;lt;String&amp;gt;&quot;/&gt;
        &lt;variable
            name=&quot;map&quot;
            type=&quot;android.databinding.ObservableArrayMap&amp;lt;String,String&amp;gt;&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{animal.field}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{String.valueOf(animal.age)}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[0]}&quot; /&gt;
        &lt;!--Map集合既可以通过map[key]的方式，也可以通过调用API--&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[1]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`name`]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`age`]}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/four_btn&quot;
            android:layout_width=&quot;match_parent&quot;
            android:text=&quot;改变数据&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>Animal类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Animal {
    public final ObservableField&lt;String&gt; field = new ObservableField&lt;&gt;();
    public final ObservableInt age = new ObservableInt();
}
</code></pre>

<p><strong>FourActivity</strong></p>

<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding;

public class FourActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityFourBinding binding = DataBindingUtil.setContentView(FourActivity.this, R.layout.activity_four);
        final Animal animal = new Animal();

        animal.field.set(&quot;cat&quot;);
        animal.age.set(2);
        binding.setAnimal(animal);

        final ObservableArrayList&lt;String&gt; list = new ObservableArrayList&lt;&gt;();
        list.add(&quot;dog&quot;);
        list.add(&quot;mouse&quot;);
        binding.setList(list);

        final ObservableArrayMap&lt;String, String&gt; map = new ObservableArrayMap&lt;&gt;();
        map.put(&quot;name&quot;,&quot;Tom&quot;);
        map.put(&quot;age&quot;,&quot;4&quot;);
        binding.setMap(map);

        binding.fourBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                animal.field.set(&quot;dog&quot;);
                animal.age.set(4);
                list.set(0,&quot;cat&quot;);
                list.set(1,&quot;dog&quot;);
                map.put(&quot;name&quot;,&quot;Sam&quot;);
                map.put(&quot;age&quot;,&quot;5&quot;);
            }
        });

    }
}
</code></pre>

<p>当Animal属性数据改变，list/map集合数据改变，会自动更新数据，我们不需要自己手动设置，省去了一个操作，让我们更专注于业务逻辑。</p>

<h3 id="toc_12">事件的绑定</h3>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
    绑定事件的格式有两种：    
    1、方法引用：直接用handle.Click或者handle::Click  推荐后者  
--&gt;  
&lt;Button  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&quot;@{user.name}&quot;  
    android:onClick=&quot;@{handle::Click}&quot;/&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
     2、监听绑定：使用()组，括号里面所填的是你为参数起的名字，这样你就可以在后面的括号进行引用  
        如果你监听的事件需要返回值，那么你的方法也要返回一个相同类型  
 --&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{()-&gt;handle.eventHandler(user)}&quot;  
     android:text=&quot;传入布局文件中的数据&quot; /&gt;  
  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(thisView)-&gt;handle.eventHandlerView(thisView,user)}&quot;  
     android:text=&quot;传入此View&quot; /&gt;  
 &lt;!--如果你需要为一个点击事件设置一个断言，那么使用void作为一个标志,表示什么也不做--&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.isVisible(v)?handle.doSomething():void}&quot;  
     android:text=&quot;判断是否为visible&quot; /&gt;  
  
 &lt;!--对于一些控件有自己专门的单击事件，需要创建下面的属性进行避免  
    SearchView    android:onSearchClick  
    ZoomControls  android:onZoomIn  
    ZoomControls  android:onZoomOut--&gt;  
 &lt;SearchView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.searchClick(v)}&quot;  
     android:onSearchClick=&quot;@{(v)-&gt;handle.onSearchClick(v)}&quot;&gt;  
  
 &lt;/SearchView&gt;  
</code></pre>

<p>实现监听方法，保证参数个数、类型、返回值都要保证和你使用set时监听一样，不然就出报错。</p>

<pre class="line-numbers"><code class="language-java">public void checkChanged(View view, boolean isCheck) {  
    System.out.println(&quot;checkChanged:&quot; + view + &quot;    &quot; + isCheck);  
}  
  
public boolean longClick(View view) {  
    System.out.println(&quot;longClick:&quot; + view);  
    return true;  
}  
</code></pre>

<p>可以直接在 xml 导入android.view.View.OnClickListener，并制定其点击事件。</p>

<pre class="line-numbers"><code class="language-java">&lt;variable
    name=&quot;clickListener&quot;
    type=&quot;android.view.View.OnClickListener&quot; /&gt;
...
  android:onClick=&quot;@{clickListener}&quot;
...
</code></pre>

<pre class="line-numbers"><code class="language-java">holder.binding.setClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               //do something
        });
</code></pre>

<h3 id="toc_13">表达式</h3>

<p>其实在xml文件中还是支持表达式的，比如说如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&#39;@{error ? &quot;error&quot; : &quot;ok&quot;}&#39;/&gt;
</code></pre>

<p>这是一个布尔值的使用。</p>

<p><strong>下面我们就来看看表达式支持的一下语法和不支持的语法支持的表达式：</strong></p>

<ul>
<li>Mathematical + - / * %<br/></li>
<li>String concatenation +<br/></li>
<li>Logical &amp;&amp; ||<br/></li>
<li>Binary &amp; | ^<br/></li>
<li>Unary + - ! ~<br/></li>
<li>Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt;<br/></li>
<li>Comparison == &gt; &lt; &gt;= &lt;=<br/></li>
<li>instanceof<br/></li>
<li>Grouping ()<br/></li>
<li>Literals - character, String, numeric, null<br/></li>
<li>Cast<br/></li>
<li>Method calls</li>
<li>Field access</li>
<li>Array access []</li>
<li>Ternary operator ?:</li>
</ul>

<p><strong>不支持的表达式：</strong></p>

<ul>
<li>this</li>
<li>super</li>
<li>new</li>
<li>Explicit generic invocation</li>
</ul>

<h3 id="toc_14">在布局中使用include</h3>

<p>如果你需要用到从xml传过来的数据需要去使用bind:user属性，这里的user是你定义的实体类名</p>

<pre class="line-numbers"><code class="language-markup">&lt;!--当你使用include的时候，你可以使用命名空间和属性中的变量名  
来将数据传送到另一个布局中去,值得注意的是当include的父节点为merge时将不支持--&gt;  
&lt;include  
    layout=&quot;@layout/detail_include&quot;  
    bind:user=&quot;@{user}&quot; /&gt; 
</code></pre>

<p>然后只需要在include布局里面声明之后便可以直接使用了。</p>

<h4 id="toc_15">示例</h4>

<p><strong>activity_five.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
 &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;TextView
                android:text=&quot;@string/app_name&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>toolbar.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout &gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
      &lt;variable
          name=&quot;content&quot;
          type=&quot;Content&quot;/&gt;
    &lt;/data&gt;

&lt;android.support.v7.widget.Toolbar
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/toolbar&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_height=&quot;56dp&quot;
    android:layout_width=&quot;match_parent&quot;
    app:title=&quot;@{content.title}&quot;
    app:subtitle=&quot;@{content.subTitle}&quot;
    android:background=&quot;@color/colorPrimary&quot;
    app:titleTextColor=&quot;@android:color/white&quot;
    app:subtitleTextColor=&quot;@android:color/white&quot; /&gt;
&lt;/layout&gt;
</code></pre>

<p>在activity_five.xml中的include属性中定义了一个id,同时又在toolbar.xml中的Toolbar标签中又定义了一个id,其作用是通过binding.toolbar.toolbar等同于Toolbar控件，可以方便做一些操作等(不加id，同样能将变量参数传进去)<br/>
FiveActivity中</p>

<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        ActivityFiveBinding binding =DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;); 
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>

<p><strong>Content</strong></p>

<pre class="line-numbers"><code class="language-java">public class Content extends BaseObservable {
    private String title;
    private String subTitle;

    public Content(String title, String subTitle) {
        this.title = title;
        this.subTitle = subTitle;
    }

    @Bindable public String getSubTitle() {
        return subTitle;
    }

    public void setSubTitle(String subTitle) {
        this.subTitle = subTitle;
        notifyPropertyChanged(BR.subTitle);
    }

    @Bindable public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
        notifyPropertyChanged(BR.title);
    }
}
</code></pre>

<h3 id="toc_16">带id的控件的赋值方式</h3>

<p>对于xml文件中控件的赋值，其实也是可以在java文件中，用java来实现的。我就以最上面那个简单的小例子来说，假如给一个TextView设置的id如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:id=&quot;@+id/name&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    /&gt;
</code></pre>

<p>在Activity中这样赋值：</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    binding.name.setText(&quot;非著名程序员&quot;);
}
</code></pre>

<h3 id="toc_17">在布局中使用ViewStub</h3>

<pre class="line-numbers"><code class="language-java">/** 
 * 为ViewStub设置监听，当显示的时候为它绑定数据，因为当不显示的ViewStub会在视图中消失 
 */  
vs = (ViewStub) findViewById(R.id.viewstub);  
vs.setOnInflateListener(new ViewStub.OnInflateListener() {  
    @Override  
    public void onInflate(ViewStub stub, View inflated) {  
        ViewstubBinding viewstubBinding = ViewstubBinding.bind(inflated);  
        Info info = new Info();  
        info.setInfo(&quot;Andly Info&quot;);  
        viewstubBinding.setInfo(info);  
        Drawable d = getResources().getDrawable(R.mipmap.ic_launcher);  
        viewstubBinding.setDrawable(d);  
    }  
});  
  
public void toggleViewStub(View view) {  
    vs.inflate();  
}  
</code></pre>

<h3 id="toc_18">在布局中使用RecycleView控件</h3>

<h4 id="toc_19">1、添加RecycleView控件</h4>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
    这里使用到了自定义属性，因为RecycleView里面有setAdapter方法，所以这里可以直接用app:adapter  
--&gt;  
&lt;android.support.v7.widget.RecyclerView  
    android:id=&quot;@+id/rv&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    app:adapter=&quot;@{adapter}&quot; /&gt;  
</code></pre>

<h4 id="toc_20">2、为RecycleView定义适配器</h4>

<pre class="line-numbers"><code class="language-java">@Override  
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  
    ViewDataBinding viewDataBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), layoutId, parent, false);  
    return new ViewHolder(viewDataBinding);  
}  
@Override  
public void onBindViewHolder(ViewHolder holder, int position) {  
    holder.binding.setVariable(variable, list.get(position));  
    holder.binding.executePendingBindings();  
    //当然这里你也可以为其设置点击如：  
    //holder.binding.getRoot.setOnclickListener()  
}  
@Override  
public int getItemCount() {  
    return list.size();  
}  
  
class ViewHolder extends RecyclerView.ViewHolder {  
    ViewDataBinding binding;  
  
    public ViewHolder(ViewDataBinding binding) {  
        super(binding.getRoot());  
        this.binding = binding;  
    }  
}  
</code></pre>

<h4 id="toc_21">3、为RecycleView设置Adapter</h4>

<pre class="line-numbers"><code class="language-java">//这里注意的是一定要是BR.dataInfo不能是其它的常数  
MyAdapter adapter = new MyAdapter(list, R.layout.rv_item, BR.dataInfo);  
binding.setAdapter(adapter);  
binding.rv.setLayoutManager(new LinearLayoutManager(this));
</code></pre>

<p>这样就大功告成，然而在很多情况我们都需要去对每个Item进行处理，如显示网络图片等等，这里我们就需要使用数据绑定自定义属性的功能，看代码</p>

<pre class="line-numbers"><code class="language-markup">&lt;ImageView  
    android:layout_width=&quot;150dp&quot;  
    android:layout_height=&quot;90dp&quot;  
    app:imageError=&quot;@{@drawable/android}&quot;  
    app:imagePath=&quot;@{dataInfo.imageUrl}&quot; /&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-java">//当你在一个方法只需要一个参数的时候可以使用@BindingAdapter(&quot;imageUrlStr&quot;)，加上之后就可以在布局文件中直接使用imageUrlStr  
//运行之后就会调用loadImage方法  
@BindingAdapter(&quot;imageUrlStr&quot;)  
public static void loadImage(ImageView iv, String url) {  
    Glide.with(iv.getContext()).load(url).into(iv);//这里使用Glide库  
}  
  
//上面是为loadImage传入一个参数，当传入两个或多个参数的时候应使用@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
//这个的ImageView自定义了两个属性一个是imagePath传入的是url,一个是imageError为Drawable  
@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
public static void downloadImage(ImageView iv, String url, Drawable error) {  
    Glide.with(iv.getContext()).load(url).error(error).into(iv);  
}  
</code></pre>

<p>上面的方法使用的是静态方法，如果你不想使用静态方法你需要重写一个数据绑定组件类去实现DataBindingComponent</p>

<pre class="line-numbers"><code class="language-java">public class MyComponent implements android.databinding.DataBindingComponent {  
    private Utils utils;  
    @Override  
    public Utils getUtils() {  
        if (utils == null) {  
            utils = new Utils();  
        }  
        return utils;  
    }  
}  
</code></pre>

<p>然后你需要在Activity为其进行设置</p>

<pre class="line-numbers"><code class="language-java">//第一种方式  
DataBindingUtil.setDefaultComponent(new MyComponent());  
//第二种方式  
ActivityMyListViewBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_my_list_view,new MyComponent());  
//第三种方式  
DataBindingUtil.bind(root,new MyComponent());  
</code></pre>

<p>最后有个不起眼的小功能，就是当使用数据绑定的时候在预览界面不能看到显示的内容，这时你可以为你的控件设置默认显示内容<code>android:text=&quot;@{placeName,default=PLACEHOLDER}&quot;</code></p>

<h5 id="toc_22">示例</h5>

<p><strong>activity_five.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
        &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;android.support.v7.widget.RecyclerView
                android:id=&quot;@+id/recycler&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>recycler_item.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;str&quot;
            type=&quot;String&quot;/&gt;
    &lt;/data&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:text=&quot;@{str}&quot;
            android:gravity=&quot;center_vertical&quot;
            android:textColor=&quot;@android:color/black&quot;
            android:textSize=&quot;16sp&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;48dp&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>FiveActivity</strong></p>

<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {

    private ActivityFiveBinding binding;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        binding = DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        initToolbar();
        initRecyclerView();
    }

    private void initRecyclerView() {
        LinearLayoutManager manager = new LinearLayoutManager(FiveActivity.this);
        binding.recycler.setLayoutManager(manager);
        binding.recycler.setHasFixedSize(true);
        MyAdapter adapter = new MyAdapter(getApplicationContext());
        binding.recycler.setAdapter(adapter);
    }

    private void initToolbar() {
        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;);
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>

<p><strong>MyAdapter</strong></p>

<pre class="line-numbers"><code class="language-java">public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {

    private Context mContext;
    String[] datas;

    public MyAdapter(Context context) {
        mContext = context;
        datas = context.getResources().getStringArray(R.array.item_list);
    }

    @Override
    public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        RecyclerItemBinding binding = DataBindingUtil.inflate(LayoutInflater.from(mContext), R.layout.recycler_item, parent, false);
        return new MyViewHolder(binding);
    }

    @Override
    public void onBindViewHolder(MyAdapter.MyViewHolder holder, int position) {
        String name = datas[position];
        holder.getBinding().setVariable(www.zhang.com.databinding.BR.str,name);
        //holder.getBinding().setStr(name); //两者都可以

        //executePendingBindings()方法说明
        // When a variable or observable changes, the binding will be scheduled to change before the next frame. 
        // There are times, however, when binding must be executed immediately. 
        // To force execution, use the executePendingBindings() method.
        holder.getBinding().executePendingBindings();//此方法必须执行在UI线程，当绑定的数据修改时更新视图（不知道翻译的准不准）
    }

    @Override
    public int getItemCount() {
        return datas.length;
    }

    public class MyViewHolder extends RecyclerView.ViewHolder {
        private RecyclerItemBinding binding;

        public MyViewHolder(ViewDataBinding binding) {
            super(binding.getRoot());
            this.binding = (RecyclerItemBinding) binding;
        }

        public RecyclerItemBinding getBinding() {
            return binding;
        }

        public void setBinding(RecyclerItemBinding binding) {
            this.binding = binding;
        }
    }
}
</code></pre>

<h3 id="toc_23">@BindingAdapter</h3>

<p>@BindingAdapter用于修饰方法。<br/><br/>
一些属性需要定制绑定逻辑，一个用@BindingAdapter修饰的静态方法可以自定义属性的setter操作。<br/><br/>
android自身实现了大量的Adapter，你可以在项目module的android.databinding.adapters包下找到这些代码。</p>

<pre class="line-numbers"><code class="language-java">public class CardViewBindingAdapter {
    @BindingAdapter(&quot;contentPadding&quot;)
    public static void setContentPadding(CardView view, int padding) {
        view.setContentPadding(padding, padding, padding, padding);
    }
}
</code></pre>

<p><strong>方法内的参数可以设置多个，参数的传递在布局文件中使用自定义命名空间的属性传入。</strong></p>

<ul>
<li>1、默认的你的自定义的命名空间，在匹配时会被忽略。</li>
</ul>

<pre class="line-numbers"><code class="language-text">@BindingAdapter(&quot;contentPadding&quot;)
</code></pre>

<ul>
<li>2、允许重写android的命名空间。</li>
</ul>

<pre class="line-numbers"><code class="language-text"> @BindingAdapter(&quot;android:contentPadding&quot;)
</code></pre>

<p><code>app:contentPadding</code>与<code>android:contentPadding</code>处理行为可以不一样。<br/>
<code>app:contentPadding</code>与<code>custom:contentPadding</code>处理行为是一致的。（仅android是特殊的命名空间）。</p>

<h4 id="toc_24">示例</h4>

<pre class="line-numbers"><code class="language-java">@BindingAdapter({&quot;imageUrl&quot;, &quot;type&quot;, &quot;position&quot;, &quot;debrisfly&quot;, &quot;width&quot;, &quot;height&quot;})
public static void setImageUrl(SimpleDraweeView view, String url, int type, int position, boolean debrisfly, int width, int height) {
    if (url == null) {
        url = &quot;&quot;;
    }
    Uri uri = null;
    switch (type) {
        case 1:
            uri = Util.parse7(url, BocaiApplication.getInstance());
            break;
        case 2:
            uri = Util.parse2(url, BocaiApplication.getInstance());
            break;
        case 3:
            uri = Util.parse3(url, BocaiApplication.getInstance());
            break;

        case 8:
            uri = Util.parse(url, BocaiApplication.getInstance());
            break;
        case 10:
            uri = Util.parseUrlBy230(url, BocaiApplication.getInstance());
            break;
    }
    ControllerListener controllerListener = new BaseControllerListener&lt;ImageInfo&gt;() {
        @Override
        public void onFinalImageSet(
                String id,
                @Nullable ImageInfo imageInfo,
                @Nullable Animatable anim) {
            if (imageInfo == null) {
                return;
            }
            if (anim != null) {
                anim.start();
            }
        }

        @Override
        public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {
        }

        @Override
        public void onFailure(String id, Throwable throwable) {
        }
    };

    DraweeController controller = Fresco.newDraweeControllerBuilder()
            .setControllerListener(controllerListener)
            .setUri(uri)
            .setOldController(view.getController())
            // other setters
            .build();
    view.setController(controller);
    debrisflys(debrisfly, position,view,width,height);
}
</code></pre>

<p>需要注意，当你创建的适配器属性与系统默认的产生冲突时，你的自定义适配器将会覆盖掉系统原先定义的注解，这将会产生一些意外的问题。<br/>
假设需要对下面接口，做适配。</p>

<pre class="line-numbers"><code class="language-java">public interface ILogAction{
      void login();
      void logout();
}
</code></pre>

<p>则需要一个方法一个接口，这么做的原因是避免<code>login()</code>的修改影响到<code>logout()</code>。所以根据业务需要，可能需要排列组合适配这两个接口。</p>

<blockquote>
<p>1、适配 login<br/>
2、适配 logout<br/>
3、适配 login + logout</p>
</blockquote>

<h3 id="toc_25">@BindingBuildInfo</h3>

<pre class="line-numbers"><code class="language-java">@BindingBuildInfo(
buildId=&quot;3fefc6ba-1e95-4dcf-8ffa-278fe0f449bd&quot;,
modulePackage=&quot;com.ipudong.library&quot;,
sdkRoot=&quot;/Users/robert/Library/Android/sdk&quot;,
layoutInfoDir=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug&quot;,
exportClassListTo=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug/_generated.txt&quot;,
isLibrary=true,
minSdk=14,
enableDebugLogs=false,
printEncodedError=true
)
public class DataBindingInfo {}
</code></pre>

<p>在SOURCE阶段会自动生成DataBindingInfo.class，并标记注解如上。</p>

<h3 id="toc_26">@BindingConversion</h3>

<blockquote>
<p>Annotate methods that are used to automatically convert from the expression type to the value used in the setter.<br/><br/>
有时候会遇到类型不匹配的问题，比如<code>R.color.white</code>是<code>int</code>，但是通过Data Binding赋值给<code>android:background</code>属性后，需要把<code>int</code>转换为<code>ColorDrawable</code>。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">@BindingConversion
public static Drawable convertColorToDrawable(int drawable) {
  return new ColorDrawable(drawable);
}
</code></pre>

<h3 id="toc_27">@BindingMethod &amp;&amp; @BindingMethods</h3>

<blockquote>
<p>Used within an BindingMethods annotation to describe a renaming of an attribute to the setter used to set that attribute.Used to enumerate attribute-to-setter renaming.</p>
</blockquote>

<p><strong>@BindingMethods用于修饰类。</strong></p>

<p>一些属性虽然拥有setters但是并不与名字相匹配，这些方法的属性可以通过 @BindingMethod &amp;&amp; @BindingMethods 注释 setters。</p>

<pre class="line-numbers"><code class="language-java">@BindingMethods({
       @BindingMethod(type = &quot;android.widget.ImageView&quot;,
                      attribute = &quot;android:tint&quot;,
                      method = &quot;setImageTintList&quot;),
})
</code></pre>

<p>开发人员不太可能需要重命名 setters ，因为android框架属性已经实现了这一部分。<br/><br/>
事件的默认值是带有<code>AttrChanged</code>的属性名称。在上面的例子中，默认值是<code>android:textAttrChanged</code>，即使它没有提供。<br/><br/>
事件属性用于通知数据绑定系统值已更改。开发人员通常会创建一个<code>BindingAdapter</code>来分配事件。比如：  </p>

<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>

<p>如同<code>BindingAdapters</code>一样， <code>InverseBindingAdapter</code>方法 也可以将 <code>DataBindingComponent</code>作为第一个参数，可以是具有从<code>DataBindingComponent</code>检索的实例的实例方法。<br/><br/>
<code>InverseBindingListener</code>非常有用。  </p>

<p><a href="https://developer.android.com/reference/android/databinding/InverseBindingListener.html">参考 InverseBindingListener</a></p>

<h3 id="toc_28">@InverseBindingMethod</h3>

<p><code>InverseBindingMethod</code>用于标识如何监听对<code>View</code>属性的更改以及要调用的<code>getter</code>方法。<code>InverseBindingMethod</code> 应该与<code>InverseBindingMethods</code>的部分方法相关联。  </p>

<pre class="line-numbers"><code class="language-java">@InverseBindingMethods({@InverseBindingMethod(
     type = android.widget.TextView.class,
     attribute = &quot;android:text&quot;,
     event = &quot;android:textAttrChanged&quot;,
     method = &quot;getText&quot;)})
 public class MyTextViewBindingAdapters { ... }
</code></pre>

<p>@InverseBindingMethods中的属性method 是可选的。</p>

<blockquote>
<p>如果其没有提供， 属性名称会查找如下几种可能性：方法名称，前缀为is或者get的方法名称。 如属性android:text, 数据绑定框架会在TextView中搜索public CharSequence getText() 方法。</p>
</blockquote>

<p>@InverseBindingMethods中的属性event是可选的。</p>

<blockquote>
<p>如果其没有提供，默认会使用属性名+AttrChanged后缀。如属性android:text, 默认的事件名称android:textAttrChanged。</p>
</blockquote>

<p>这个事件也需要配置相关的<code>@BindingAdapter</code>，如下：</p>

<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>

<h3 id="toc_29">@InverseBindingMethods</h3>

<blockquote>
<p>用于枚举属性，<code>getter</code>和事件关联。</p>
</blockquote>

<h3 id="toc_30">@Untaggable</h3>

<p>Data Binding相关的jar包由四部分组成，</p>

<ol>
<li>baseLibrary-2.1.0-rc1.jar<br/>
    作为运行时类库被打进APK中；</li>
<li>DataBinderPlugin（gradle plugin）<br/>
    在编译期使用，利用gradle-api（之前叫transform-api，1.5生，2.0改名）处理xml文件，生成DataBindingInfo.java；</li>
<li>compiler-2.1.0-rc1.jar<br/>
    在编译器使用，入口类继承自AbstractProcessor，用于处理注解，并生成Binding类，DataBindingCompoent.java，DataBinderMapper.java类；</li>
<li>compilerCommon-2.1.0-rc1.jar<br/>
    被DataBinderPlugin和compiler-2.1.0-rc1.jar所依赖</li>
</ol>

<h3 id="toc_31">改变监听</h3>

<p><code>addOnPropertyChangedCallback： Model</code>属性改变时回调发生 <br/>
<code>OnRebindCallback: view</code>发生改变重复绑定时触发</p>

<pre class="line-numbers"><code class="language-java">mModel.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() {
    @Override
    public void onPropertyChanged(Observable observable, int i) {
        if (i == BR.name) {
            Toast.makeText(TwoWayActivity.this, &quot;name changed&quot;,
                    Toast.LENGTH_SHORT).show();
        } else if (i == BR.password) {
            Toast.makeText(TwoWayActivity.this, &quot;password changed&quot;,
                    Toast.LENGTH_SHORT).show();
        }
    }
});
</code></pre>

<h3 id="toc_32">Component</h3>

<p>通过<code>DataBindingUtil.setDefaultComponent</code>来设置不同环境下不同的<code>Component</code>， <br/>
设置之后就可以使用该<code>Component</code>提供的<code>Adapter</code>方法，默认不设置是全局使用，可以理解为作用域。</p>

<pre class="line-numbers"><code class="language-java">public interface TestableAdapter {
    @BindingAdapter(&quot;android:src&quot;)
    void setImageUrl(ImageView imageView, String url);
}

public interface DataBindingComponent {
    TestableAdapter getTestableAdapter();
}

DataBindingUtil.setDefaultComponent(myComponent); 
 ‐ or ‐
binding = MyLayoutBinding.inflate(layoutInflater, myComponent);
</code></pre>

<h2 id="toc_33">相关编译流程</h2>

<h3 id="toc_34">STEP1 资源处理</h3>

<p><code>aapt</code>或者<code>gradle</code>执行时，都会触发资源处理。在资源处理过程中，<code>DataBinding</code>都会扫描一遍现有的资源，生成不包含<code>&lt;layout&gt;</code>的<code>data-binding-layout-out</code>以及<code>DataBinding</code>所需要的<code>data-binding-info</code>；</p>

<h3 id="toc_35">STEP2 DataBindingInfo.class生成</h3>

<p>在完成资源处理后，<code>aapt</code>或者<code>gradle-api</code>都会去执行<code>DataBindingInfo.class</code>生成操作，把相关的信息写入<code>DataBindingInfo.class</code>的@BindingBuildInfo注解中；</p>

<h3 id="toc_36">STEP3 监听到注解变化</h3>

<p>生成<code>@BindingBuildInfo</code>注解，或者code中发现有新的注解写入，<code>AbstractProcessor</code>注解处理器就开始执行注解处理。<code>DataBinding</code>中有一个<code>ProcessDataBinding.jav</code>a类专门来处理<code>DataBinding</code>相关的注解；</p>

<h3 id="toc_37">STEP4 ProcessDataBinding处理注解，生成bin</h3>

<p><code>ProcessDataBinding</code>中处理注解永远会按顺执行3步，<code>ProcessMethodAdapter</code>，<code>ProcessExpressions</code>，<code>ProcessBindable</code>。每次执行都会从磁盘反序列化对应的bin文件，然后往bin中写入新的，完成后再序列化到磁盘；</p>

<h3 id="toc_38">STEP5 生成最终产物</h3>

<p>执行<code>ProcessMethodAdapter</code>生成<code>DataBindingComponents.class</code>；执行<code>ProcessExpressions</code>生成<code>ViewDataBinding.class</code>子类（ActivityDetail2Binding.class），并触发<code>DataBindingMapper.class</code>更新；执行<code>ProcessBindable</code>生成<code>BR.class</code>，并触发<code>DataBindingMapper.class</code>更新。</p>

<h2 id="toc_39">注意：</h2>

<p>不允许使用混合类型</p>

<pre class="line-numbers"><code class="language-java">&lt;!--值得注意的是  
    android:background=&quot;@{boo?@color/red:@drawable/background}&quot;  
    这么写将会发生错误，因为在BindingConversion默认实现为：  
    @BindingConversion  
    public static ColorDrawable convertColorToDrawable(int color) {  
            return new ColorDrawable(color);  
        }  
--&gt;  
&lt;ImageView  
    android:layout_width=&quot;100dp&quot;  
    android:layout_height=&quot;100dp&quot;  
    android:layout_marginTop=&quot;20dp&quot;  
    android:background=&quot;@{boo?@color/red:@color/green}&quot; /&gt;  
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/8</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870315.html">
                
                  <h1>Android-android:windowSoftInputMode属性详解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">android:windowSoftInputMode</h2>

<p>activity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题，Android1.5后的一个新特性。</p>

<p>这个属性能影响两件事情：</p>

<ul>
<li>当有焦点产生时，软键盘是隐藏还是显示</li>
<li>是否减少活动主窗口大小以便腾出空间放软键盘</li>
</ul>

<p>它的设置必须是下面列表中的一个值，或一个”state…”值加一个”adjust…”值的组合。在任一组设置多个值——多个”state…”values，例如＆mdash有未定义的结果。各个值之间用|分开。例如:<code>&lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot;. . . &gt;</code></p>

<p>在这设置的值(除&quot;stateUnspecified&quot;和&quot;adjustUnspecified&quot;以外)将覆盖在主题中设置的值。<br/><br/>
各值的含义：</p>

<ul>
<li><code>stateUnspecified</code>：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置</li>
<li><code>stateUnchanged</code>：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示</li>
<li><code>stateHidden</code>：用户选择activity时，软键盘总是被隐藏</li>
<li><code>stateAlwaysHidden</code>：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的</li>
<li><code>stateVisible</code>：软键盘通常是可见的</li>
<li><code>stateAlwaysVisible</code>：用户选择activity时，软键盘总是显示的状态</li>
<li><code>adjustUnspecified</code>：默认设置，通常由系统自行决定是隐藏还是显示</li>
<li><code>adjustResize</code>：该Activity总是调整屏幕的大小以便留出软键盘的空间</li>
<li><code>adjustPan</code>：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870279.html">
                
                  <h1>Android-getViewTreeObserver()</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>我们知道在<code>oncreate</code>中<code>View.getWidth</code>和<code>View.getHeight</code>无法获得一个view的高度和宽度，这是因为View组件布局要在<code>onResume</code>回调后完成。所以现在需要使用<code>getViewTreeObserver().addOnGlobalLayoutListener()</code>来获得宽度或者高度。这是获得一个view的宽度和高度的方法之一。</p>

<h2 id="toc_1">OnGlobalLayoutListener</h2>

<p><code>OnGlobalLayoutListener</code> 是<code>ViewTreeObserver</code>的内部类，当一个视图树的布局发生改变时，可以被<code>ViewTreeObserver</code>监听到，这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。<code>ViewTreeObserver</code>不能直接实例化，而是通过<code>getViewTreeObserver()</code>获得。</p>

<h2 id="toc_2">其他</h2>

<p>除了<code>OnGlobalLayoutListener</code> ，<code>ViewTreeObserver</code>还有如下内部类：</p>

<h3 id="toc_3">interface <code>ViewTreeObserver.OnGlobalFocusChangeListener</code></h3>

<p>当在一个视图树中的焦点状态发生改变时，所要调用的回调函数的接口类</p>

<h3 id="toc_4">interface <code>ViewTreeObserver.OnGlobalLayoutListener</code></h3>

<p>当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类</p>

<h3 id="toc_5">interface <code>ViewTreeObserver.OnPreDrawListener</code></h3>

<p>当一个视图树将要绘制时，所要调用的回调函数的接口类</p>

<h3 id="toc_6">interface <code>ViewTreeObserver.OnScrollChangedListener</code></h3>

<p>当一个视图树中的一些组件发生滚动时，所要调用的回调函数的接口类</p>

<h3 id="toc_7">interface <code>ViewTreeObserver.OnTouchModeChangeListener</code></h3>

<p>当一个视图树的触摸模式发生改变时，所要调用的回调函数的接口类</p>

<h2 id="toc_8">实例</h2>

<p>其中，我们可以利用<code>OnGlobalLayoutListener</code>来获得一个视图的真实高度。</p>

<pre class="line-numbers"><code class="language-java">int mHeaderViewHeight;  
mHeaderView.getViewTreeObserver().addOnGlobalLayoutListener(  
    new OnGlobalLayoutListener() {  
    @Override  
    public void onGlobalLayout() {  
                                                                                                                                                                                                                                        m    HeaderViewHeight = mHeaderView.getHeight();  
    getViewTreeObserver().removeGlobalOnLayoutListener(this);  
    }  
});
</code></pre>

<p><strong>但是需要注意的是OnGlobalLayoutListener可能会被多次触发，因此在得到了高度之后，要将OnGlobalLayoutListener注销掉。另外mHeaderViewHeight和mHeaderView都需要写在当前java文件类（比如Activity）的成员变量中。不能直接在onCreate中定义否则会编译不通过：</strong></p>

<p><code>Cannot refer to a non-final variable sHeight inside an inner class defined in a different method</code></p>

<p>有时候需要在<code>onCreate</code>方法中知道某个View组件的宽度和高度等信息，而直接调用View组件的<code>getWidth()</code>、<code>getHeight()</code>、<code>getMeasuredWidth()</code>、<code>getMeasuredHeight()</code>、<code>getTop()</code>、<code>getLeft()</code>等方法是无法获取到真实值的，只会得到0。这是因为View组件布局要在onResume回调后完成。下面提供实现方法，onGlobalLayout回调会在view布局完成时自动调用:</p>

<pre class="line-numbers"><code class="language-java">// This listener is used to get the final width of the GridView and then calculate the  
// number of columns and the width of each column. The width of each column is variable  
// as the GridView has stretchMode=columnWidth. The column width is used to set the height  
// of each view so we get nice square thumbnails.  
mGridView.getViewTreeObserver().addOnGlobalLayoutListener( //view 布局完成时调用，每次view改变时都会调用  
    new ViewTreeObserver.OnGlobalLayoutListener() {  
    @Override  
    public void onGlobalLayout() {  
        if (mAdapter.getNumColumns() == 0) {  
            final int numColumns = (int) Math.floor(mGridView.getWidth() / (mImageThumbSize + mImageThumbSpacing));  
            if (numColumns &gt; 0) {  
                final int columnWidth = (mGridView.getWidth() / numColumns) - mImageThumbSpacing;  
                mAdapter.setNumColumns(numColumns);   //设置 列数  
                mAdapter.setItemHeight(columnWidth);  //设置 高度  
            }  
        } 
    }  
});
</code></pre>

<p><strong>在gridview布局完成后，根据girdview的宽和高设置adapter列数和每个item高度</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870240.html">
                
                  <h1>Android-Retrofit详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Retrofit入门</h2>

<p>Retrofit 其实相当简单，简单到源码只有37个文件，其中22个文件是注解还都和HTTP有关，真正暴露给用户的类并不多。</p>

<h3 id="toc_1">创建Retrofit实例</h3>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;http://localhost:4567/&quot;)
        .build();
</code></pre>

<p>创建Retrofit实例时需要通过<code>Retrofit.Builder</code>,并调用<code>baseUrl</code>方法设置URL。注： Retrofit2 的baseUlr 必须以 /（斜线） 结束，不然会抛出一个<code>IllegalArgumentException</code>。</p>

<h3 id="toc_2">接口定义</h3>

<p>以获取指定id的Blog为例:</p>

<pre class="line-numbers"><code class="language-java">public interface BlogService {
    @GET(&quot;blog/{id}&quot;)
    Call&lt;ResponseBody&gt; getBlog(@Path(&quot;id&quot;) int id);
}
</code></pre>

<p>注意，这里是<code>interface</code>不是<code>class</code>，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个<code>BlogService</code>的代理对象。<br/>
<code>BlogService service = retrofit.create(BlogService.class);</code><br/>
拿到代理对象之后，就可以调用该方法啦。</p>

<h3 id="toc_3">接口调用</h3>

<pre class="line-numbers"><code class="language-java">Call&lt;ResponseBody&gt; call = service.getBlog(2);
// 用法和OkHttp的call如出一辙,
// 不同的是如果是Android系统回调方法执行在主线程
call.enqueue(new Callback&lt;ResponseBody&gt;() {
    @Override
    public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
        try {
            System.out.println(response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
        t.printStackTrace();
    }
});
</code></pre>

<p>打印结果:</p>

<p><code>{&quot;code&quot;:200,&quot;msg&quot;:&quot;OK&quot;,&quot;data&quot;:{&quot;id&quot;:2,&quot;date&quot;:&quot;2016-04-15 03:17:50&quot;,&quot;author&quot;:&quot;怪盗kidou&quot;,&quot;title&quot;:&quot;Retrofit2 测试2&quot;,&quot;content&quot;:&quot;这里是 Retrofit2 Demo 测试服务器2&quot;},&quot;count&quot;:0,&quot;page&quot;:0}</code></p>

<h2 id="toc_4">Retrofit注解详解</h2>

<p>上面提到Retrofit 共22个注解，这节就专门介绍这22个注解，为帮助大家更好理解我将这22个注解分为三类，并用表格的形式展现出来,表格上说得并不完整，具体的见源码上的例子注释。</p>

<h3 id="toc_5">第一类：HTTP请求方法</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781328418929.png" alt="20171012150781328418929.png"/><figcaption>20171012150781328418929.png</figcaption></figure></p>

<p>以上表格中的除HTTP以外都对应了HTTP标准中的请求方法，而HTTP注解则可以代替以上方法中的任意一个注解,有3个属性：<code>method</code>、<code>path</code>、<code>hasBody</code></p>

<pre class="line-numbers"><code class="language-java">public interface BlogService {
    /**
     * method 表示请求的方法，区分大小写
     * path表示路径
     * hasBody表示是否有请求体
     */
    @HTTP(method = &quot;GET&quot;, path = &quot;blog/{id}&quot;, hasBody = false)
    Call&lt;ResponseBody&gt; getBlog(@Path(&quot;id&quot;) int id);
}
public static void main(String[] args){
    Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;http://localhost:4567/&quot;)
        .build();
    BlogService service = retrofit.create(BlogService.class);
    Call&lt;ResponseBody&gt; call = service.getBlog(2);
    ResponseBodyPrinter.printResponseBody(call);
}
</code></pre>

<h3 id="toc_6">第二类：标记类</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781333064912.png" alt="20171012150781333064912.png"/><figcaption>20171012150781333064912.png</figcaption></figure></p>

<p>Field、FieldMap、Part和PartMap 示例</p>

<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap/Multipart/Part/PartMap注解]源码
 */
public class Example03 {
    public interface BlogService {

        /**
         * {@link FormUrlEncoded} 表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）
         * &lt;code&gt;Field(&quot;username&quot;)&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值
         */
        @POST(&quot;/form&quot;)
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field(&quot;username&quot;) String name, @Field(&quot;age&quot;) int age);

        /**
         * Map的key作为表单的键
         */
        @POST(&quot;/form&quot;)
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded2(@FieldMap Map&lt;String, Object&gt; map);


        /**
         * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型
         * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，
         */
        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload1(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;age&quot;) RequestBody age, @Part MultipartBody.Part file);

        /**
         * PartMap 注解支持一个Map作为参数，支持 {@link RequestBody } 类型，
         * 如果有其它的类型，会被{@link retrofit2.Converter}转换，如后面会介绍的 使用{@link com.google.gson.Gson} 的 {@link retrofit2.converter.gson.GsonRequestBodyConverter}
         * 所以{@link MultipartBody.Part} 就不适用了,所以文件只能用&lt;b&gt; @Part MultipartBody.Part &lt;/b&gt;
         */
        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload2(@PartMap Map&lt;String, RequestBody&gt; args, @Part MultipartBody.Part file);

        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload3(@PartMap Map&lt;String, RequestBody&gt; args);
    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);


        // 演示 @FormUrlEncoded 和 @Field
        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(&quot;怪盗kidou&quot;, 24);
        ResponseBodyPrinter.printResponseBody(call1);


        //===================================================

        // 演示 @FormUrlEncoded 和 @FieldMap
        // 实现的效果与上面想同
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;username&quot;, &quot;怪盗kidou&quot;);
        map.put(&quot;age&quot;, 24);
        Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map);
        ResponseBodyPrinter.printResponseBody(call2);


        //===================================================


        MediaType textType = MediaType.parse(&quot;text/plain&quot;);
        RequestBody name = RequestBody.create(textType, &quot;怪盗kidou&quot;);
        RequestBody age = RequestBody.create(textType, &quot;24&quot;);
        RequestBody file = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), &quot;这里是模拟文件的内容&quot;);

        // 演示 @Multipart 和 @Part
        MultipartBody.Part filePart = MultipartBody.Part.createFormData(&quot;file&quot;, &quot;test.txt&quot;, file);
        Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart);
        ResponseBodyPrinter.printResponseBody(call3);

        //===================================================
        // 演示 @Multipart 和 @PartMap
        // 实现和上面同样的效果
        Map&lt;String, RequestBody&gt; fileUpload2Args = new HashMap&lt;&gt;();
        fileUpload2Args.put(&quot;name&quot;, name);
        fileUpload2Args.put(&quot;age&quot;, age);
        //这里并不会被当成文件，因为没有文件名(包含在Content-Disposition请求头中)，但上面的 filePart 有
        //fileUpload2Args.put(&quot;file&quot;, file);
        Call&lt;ResponseBody&gt; call4 = service.testFileUpload2(fileUpload2Args, filePart); //单独处理文件
        ResponseBodyPrinter.printResponseBody(call4);

        //===================================================
        // 还有一种比较hack的方式可以实现文件上传，
        // 上面说过被当成文件上传的必要条件就是 Content-Disposition 请求头中必须要有 filename=&quot;xxx&quot; 才会被当成文件
        // 所有我们在写文件名的时候可以拼把 filename=&quot;XXX&quot; 也拼接上去，
        // 即文件名变成  表单键名&quot;; filename=&quot;文件名  （两端的引号会自动加，所以这里不加）也可以实现，但是不推荐方式

        Map&lt;String, RequestBody&gt; fileUpload3Args = new HashMap&lt;&gt;();
        fileUpload3Args.put(&quot;name&quot;,name);
        fileUpload3Args.put(&quot;age&quot;,age);
        fileUpload3Args.put(&quot;file\&quot;; filename=\&quot;test.txt&quot;,file);
        Call&lt;ResponseBody&gt; testFileUpload3 = service.testFileUpload3(fileUpload3Args);
        ResponseBodyPrinter.printResponseBody(testFileUpload3);
    }
}
</code></pre>

<h3 id="toc_7">第三类：参数类</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150781336489887.png" alt="20171012150781336489887.png"/><figcaption>20171012150781336489887.png</figcaption></figure></p>

<p>注1：{占位符}和<code>PATH</code>尽量只用在URL的path部分，url中的参数使用<code>Query</code>和<code>QueryMap</code> 代替，保证接口定义的简洁注2：<code>Query</code>、<code>Field</code>和<code>Part</code>这三者都支持数组和实现了<code>Iterable</code>接口的类型，如<code>List</code>，<code>Set</code>等，方便向后台传递数组。</p>

<pre class="line-numbers"><code class="language-java">Call&lt;ResponseBody&gt; foo(@Query(&quot;ids[]&quot;) List&lt;Integer&gt; ids);
//结果：ids[]=0&amp;ids[]=1&amp;ids[]=2
</code></pre>

<p>Header和Headers例子</p>

<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap注解]源码
 */
public class Example04 {
    public interface BlogService {
        @GET(&quot;/headers?showAll=true&quot;)
        @Headers({&quot;CustomHeader1: customHeaderValue1&quot;, &quot;CustomHeader2: customHeaderValue2&quot;})
        Call&lt;ResponseBody&gt; testHeader(@Header(&quot;CustomHeader3&quot;) String customHeaderValue3);

    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);

        //演示 @Headers 和 @Header
        Call&lt;ResponseBody&gt; call1 = service.testHeader(&quot;ikidou&quot;);
        ResponseBodyPrinter.printResponseBody(call1);
    }
}
</code></pre>

<p>Query、QueryMap、Url 示例</p>

<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap注解]源码
 */
public class Example05 {
    public interface BlogService {
        /**
         * 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供
         * 对于Query和QueryMap，如果不是String（或Map的第二个泛型参数不是String）时
         * 会被默认会调用toString转换成String类型
         * Url支持的类型有 okhttp3.HttpUrl, String, java.net.URI, android.net.Uri
         * {@link retrofit2.http.QueryMap} 用法和{@link retrofit2.http.FieldMap} 用法一样，不再说明
         */
        @GET //当有URL注解时，这里的URL就省略了
        Call&lt;ResponseBody&gt; testUrlAndQuery(@Url String url, @Query(&quot;showAll&quot;) boolean showAll);

    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);

        //演示 @Headers 和 @Header
        Call&lt;ResponseBody&gt; call1 = service.testUrlAndQuery(&quot;headers&quot;,false);
        ResponseBodyPrinter.printResponseBody(call1);
    }
}
</code></pre>

<h2 id="toc_8">Gson与Converter</h2>

<p>在默认情况下Retrofit只支持将HTTP的响应体转换换为<code>ResponseBody</code>,这也是什么我在前面的例子接口的返回值都是 <code>Call&lt;ResponseBody&gt;</code>，但如果响应体只是支持转换为<code>ResponseBody</code>的话何必要引用泛型呢，返回值直接用一个<code>Call</code>就行了嘛，既然支持泛型，那说明泛型参数可以是其它类型的，而<code>Converter</code>就是Retrofit为我们提供用于将<code>ResponseBody</code>转换为我们想要的类型，有了<code>Converter</code>之后我们就可以写把我们的第一个例子的接口写成这个样子了：</p>

<pre class="line-numbers"><code class="language-java">public interface BlogService {
  @GET(&quot;blog/{id}&quot;)
  Call&lt;Result&lt;Blog&gt;&gt; getBlog(@Path(&quot;id&quot;) int id);
}
</code></pre>

<p>当然只改变泛型的类型是不行的，我们在创建Retrofit时需要明确告知用于将<code>ResponseBody</code>转换我们泛型中的类型时需要使用的<code>Converter</code>引入Gson支持:<br/>
<code>compile &#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;</code></p>

<p>通过<code>GsonConverterFactory</code>为<code>Retrofit</code>添加<code>Gson</code>支持：</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
      //配置你的Gson
      .setDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)
      .create();

Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      //可以接收自定义的Gson，当然也可以不传
      .addConverterFactory(GsonConverterFactory.create(gson))
      .build();
</code></pre>

<p>这样Retrofit就会使用Gson将<code>ResponseBody</code>转换我们想要的类型。这是时候我们终于可以演示如使创建一个Blog了！</p>

<pre class="line-numbers"><code class="language-java">@POST(&quot;blog&quot;)
Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog);
</code></pre>

<p>被<code>@Body</code>注解的的Blog将会被Gson转换成RequestBody发送到服务器。</p>

<pre class="line-numbers"><code class="language-java">BlogService service = retrofit.create(BlogService.class);
Blog blog = new Blog();
blog.content = &quot;新建的Blog&quot;;
blog.title = &quot;测试&quot;;
blog.author = &quot;怪盗kidou&quot;;
Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog);
</code></pre>

<p>结果：</p>

<p><code>Result{code=200, msg=&#39;OK&#39;, data=Blog{id=20, date=&#39;2016-04-21 05:29:58&#39;, author=&#39;怪盗kidou&#39;, title=&#39;测试&#39;, content=&#39;新建的Blog&#39;}, count=0, page=0}</code></p>

<h2 id="toc_9">RxJava与CallAdapter</h2>

<p>说到Retrofit就不得说到另一个火到不行的库<code>RxJava</code>，网上已经不少文章讲如何与Retrofit结合，但这里还是会有一个RxJava的例子，不过这里主要目的是介绍使用<code>CallAdapter</code>所带来的效果。</p>

<p>第3节介绍的<code>Converter</code>是对于<code>Call&lt;T&gt;</code>中<code>T</code>的转换，而<code>CallAdapter</code>则可以对<code>Call</code>转换，这样的话<code>Call&lt;T&gt;</code>中的<code>Call</code>也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个<code>CallAdapter</code>，这里以<code>RxJava</code>的为例，用<code>Observable</code>代替<code>Call</code>：</p>

<p>引入RxJava支持:</p>

<pre class="line-numbers"><code class="language-java">compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39;
// 针对rxjava2.x（adapter-rxjava2的版本要 &gt;= 2.2.0）
compile &#39;com.squareup.retrofit2:adapter-rxjava2:2.3.0&#39;
</code></pre>

<p>通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：</p>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
      // 针对rxjava2.x
      .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) 
      .build();
</code></pre>

<p>接口设计：</p>

<pre class="line-numbers"><code class="language-java">public interface BlogService {
  @POST(&quot;/blog&quot;)
  Observable&lt;Result&lt;List&lt;Blog&gt;&gt;&gt; getBlogs();
}
</code></pre>

<p>使用：</p>

<pre class="line-numbers"><code class="language-java">BlogService service = retrofit.create(BlogService.class);
service.getBlogs(1)
  .subscribeOn(Schedulers.io())
  .subscribe(new Subscriber&lt;Result&lt;List&lt;Blog&gt;&gt;&gt;() {
      @Override
      public void onCompleted() {
        System.out.println(&quot;onCompleted&quot;);
      }

      @Override
      public void onError(Throwable e) {
        System.err.println(&quot;onError&quot;);
      }

      @Override
      public void onNext(Result&lt;List&lt;Blog&gt;&gt; blogsResult) {
        System.out.println(blogsResult);
      }
  });
</code></pre>

<p>结果：</p>

<p><code>Result{code=200, msg=&#39;OK&#39;, data=[Blog{id=1, date=&#39;2016-04-15 03:17:50&#39;, author=&#39;怪盗kidou&#39;, title=&#39;Retrofit2 测试1&#39;, content=&#39;这里是 Retrofit2 Demo 测试服务器1&#39;},.....], count=20, page=1}</code></p>

<p>像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：</p>

<ol>
<li>用<code>Observable&lt;Response&lt;T&gt;&gt;</code> 代替 <code>Observable&lt;T&gt;</code> ,这里的<code>Response</code>指<code>retrofit2.Response</code></li>
<li>用<code>Observable&lt;Result&lt;T&gt;&gt;</code> 代替 <code>Observable&lt;T&gt;</code>，这里的<code>Result</code>是指<code>retrofit2.adapter.rxjava.Result</code>,这个Result中包含了<code>Response</code>的实例。</li>
</ol>

<h2 id="toc_10">自定义Converter</h2>

<p>本节的内容是教大家实现在一简易的Converter，这里以返回格式为<code>Call&lt;String&gt;</code>为例。<br/><br/>
在此之前先了解一下Converter接口及其作用：</p>

<pre class="line-numbers"><code class="language-java">public interface Converter&lt;F, T&gt; {
  // 实现从 F(rom) 到 T(o)的转换
  T convert(F value) throws IOException;

  // 用于向Retrofit提供相应Converter的工厂
  abstract class Factory {
    // 这里创建从ResponseBody其它类型的Converter，如果不能处理返回null
    // 主要用于对响应体的处理
    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) {
      return null;
    }

    // 在这里创建 从自定类型到ResponseBody 的Converter,不能处理就返回null，
    // 主要用于对Part、PartMap、Body注解的处理
    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,
    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
      return null;
    }

    // 这里用于对Field、FieldMap、Header、Path、Query、QueryMap注解的处理
    // Retrfofit对于上面的几个注解默认使用的是调用toString方法
    public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) {
      return null;
    }

  }
}
</code></pre>

<p>我们要想从<code>Call&lt;ResponseBody&gt;</code> 转换为 <code>Call&lt;String&gt;</code> 那么对应的F和T则分别对应<code>ResponseBody</code>和<code>String</code>，我们定义一个<code>StringConverter</code>并实现Converter接口。</p>

<pre class="line-numbers"><code class="language-java">public static class StringConverter implements Converter&lt;ResponseBody, String&gt; {

  public static final StringConverter INSTANCE = new StringConverter();

  @Override
  public String convert(ResponseBody value) throws IOException {
    return value.string();
  }
}
</code></pre>

<p>我们需要一个<code>Fractory</code>来向Retrofit注册<code>StringConverter</code></p>

<pre class="line-numbers"><code class="language-java">public static class StringConverterFactory extends Converter.Factory {

  public static final StringConverterFactory INSTANCE = new StringConverterFactory();

  public static StringConverterFactory create() {
    return INSTANCE;
  }

  // 我们只关实现从ResponseBody 到 String 的转换，所以其它方法可不覆盖
  @Override
  public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {
    if (type == String.class) {
      return StringConverter.INSTANCE;
    }
    //其它类型我们不处理，返回null就行
    return null;
  }
}
</code></pre>

<p>使用<code>Retrofit.Builder.addConverterFactory</code>向Retrofit注册我们<code>StringConverterFactory</code>：</p>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      // 如是有Gson这类的Converter 一定要放在其它前面
      .addConverterFactory(StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .build();
</code></pre>

<p>注：<code>addConverterFactory</code>是有先后顺序的，如果有多个ConverterFactory都支持同一种类型，那么就是只有第一个才会被使用，而<code>GsonConverterFactory</code>是不判断是否支持的，所以这里交换了顺序还会有一个异常抛出，原因是类型不匹配。</p>

<p>只要返回值类型的泛型参数就会由我们的<code>StringConverter</code>处理,不管是<code>Call&lt;String&gt;</code>还是<code>Observable&lt;String&gt;</code>有没有很简单?如果你有其它的需求处理的就自己实现吧。</p>

<h2 id="toc_11">自定义CallAdapter</h2>

<p>本节将介绍如何自定一个<code>CallAdapter</code>，并验证是否所有的String都会使用我们第5节中自定义的Converter。</p>

<p>先看一下CallAdapter接口定义及各方法的作用：</p>

<pre class="line-numbers"><code class="language-java">public interface CallAdapter&lt;T&gt; {

  // 直正数据的类型 如Call&lt;T&gt; 中的 T
  // 这个 T 会作为Converter.Factory.responseBodyConverter 的第一个参数
  // 可以参照上面的自定义Converter
  Type responseType();

  &lt;R&gt; T adapt(Call&lt;R&gt; call);

  // 用于向Retrofit提供CallAdapter的工厂类
  abstract class Factory {
    // 在这个方法中判断是否是我们支持的类型，returnType 即Call&lt;Requestbody&gt;和`Observable&lt;Requestbody&gt;`
    // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型
    // 不支持时返回null
    public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations,
    Retrofit retrofit);

    // 用于获取泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody
    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
      return Utils.getParameterUpperBound(index, type);
    }

    // 用于获取泛型的原始类型 如 Call&lt;Requestbody&gt; 中的 Call
    // 上面的get方法需要使用该方法。
    protected static Class&lt;?&gt; getRawType(Type type) {
      return Utils.getRawType(type);
    }
  }
}
</code></pre>

<p>了解了<code>CallAdapter</code>的结构和其作用之后，我们就可以开始自定义我们的<code>CallAdapter</code>了，本节以<code>CustomCall&lt;String&gt;</code>为例。<br/>
在此我们需要定义一个<code>CustomCall</code>，不过这里的<code>CustomCall</code>作为演示只是对<code>Call</code>的一个包装，并没有实际的用途。</p>

<pre class="line-numbers"><code class="language-java">public static class CustomCall&lt;R&gt; {

  public final Call&lt;R&gt; call;

  public CustomCall(Call&lt;R&gt; call) {
    this.call = call;
  }

  public R get() throws IOException {
    return call.execute().body();
  }
}
</code></pre>

<p>有了<code>CustomCall</code>，我们还需要一个<code>CustomCallAdapter</code>来实现 <code>Call&lt;T&gt;</code> 到 <code>CustomCall&lt;T&gt;</code>的转换，这里需要注意的是最后的泛型，是我们要返回的类型。</p>

<pre class="line-numbers"><code class="language-java">public static class CustomCallAdapter implements CallAdapter&lt;CustomCall&lt;?&gt;&gt; {

  private final Type responseType;

  // 下面的 responseType 方法需要数据的类型
  CustomCallAdapter(Type responseType) {
    this.responseType = responseType;
  }

  @Override
  public Type responseType() {
    return responseType;
  }

  @Override
  public &lt;R&gt; CustomCall&lt;R&gt; adapt(Call&lt;R&gt; call) {
    // 由 CustomCall 决定如何使用
    return new CustomCall&lt;&gt;(call);
  }
}
</code></pre>

<p>提供一个<code>CustomCallAdapterFactory</code>用于向Retrofit提供<code>CustomCallAdapter</code>：</p>

<pre class="line-numbers"><code class="language-java">public static class CustomCallAdapterFactory extends CallAdapter.Factory {
  public static final CustomCallAdapterFactory INSTANCE = new CustomCallAdapterFactory();

  @Override
  public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
    // 获取原始类型
    Class&lt;?&gt; rawType = getRawType(returnType);
    // 返回值必须是CustomCall并且带有泛型
    if (rawType == CustomCall.class &amp;&amp; returnType instanceof ParameterizedType) {
      Type callReturnType = getParameterUpperBound(0, (ParameterizedType) returnType);
      return new CustomCallAdapter(callReturnType);
    }
    return null;
  }
}
</code></pre>

<p>使用<code>addCallAdapterFactory</code>向Retrofit注册<code>CustomCallAdapterFactory</code>。</p>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(Example09.StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(CustomCallAdapterFactory.INSTANCE)
      .build();
</code></pre>

<p>注： <code>addCallAdapterFactory</code>与<code>addConverterFactory</code>同理，也有先后顺序。</p>

<h2 id="toc_12">其它说明</h2>

<h3 id="toc_13">Retrofit.Builder</h3>

<p>前面用到了 <code>Retrofit.Builder</code> 中的<code>baseUrl</code>、<code>addCallAdapterFactory</code>、<code>addConverterFactory</code>、<code>build</code>方法，还有<code>callbackExecutor</code>、<code>callFactory</code>、<code>client</code>、<code>validateEagerly</code>这四个方法没有用到，这里简单的介绍一下。</p>

<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>

<tbody>
<tr>
<td>callbackExecutor(Executor)</td>
<td>指定<code>Call.enqueue</code>时使用的<code>Executor</code>，所以该设置只对返回值为<code>Call</code>的方法有效</td>
</tr>
<tr>
<td>callFactory(Factory)</td>
<td>设置一个自定义的<code>okhttp3.Call.Factory</code>，那什么是Factory呢?<code>OkHttpClient</code>就实现了<code>okhttp3.Call.Factory</code>接口，下面的<code>client(OkHttpClient)</code>最终也是调用了该方法，也就是说两者不能共用</td>
</tr>
<tr>
<td>client(OkHttpClient)</td>
<td>设置自定义的<code>OkHttpClient</code>,以前的Retrofit版本中不同的<code>Retrofit</code>对象共用同<code>OkHttpClient</code>,在2.0各对象各自持有不同的<code>OkHttpClient</code>实例，所以当你需要共用<code>OkHttpClient</code>或需要自定义时则可以使用该方法，如：处理Cookie、使用 stetho  调式等<br/></td>
</tr>
<tr>
<td>validateEagerly(boolean)</td>
<td>是否在调用<code>create(Class)</code>时检测接口定义是否正确，而不是在调用方法才检测，适合在开发、测试时使用</td>
</tr>
</tbody>
</table>

<h3 id="toc_14">Retrofit的Url组合规则</h3>

<table>
<thead>
<tr>
<th>BaseUrl</th>
<th>和URL有关的注解中提供的值</th>
<th>最后结果</th>
</tr>
</thead>

<tbody>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td>/post</td>
<td><a href="http://localhost:4567/post">http://localhost:4567/post</a></td>
</tr>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td>post</td>
<td><a href="http://localhost:4567/path/to/other/post">http://localhost:4567/path/to/other/post</a></td>
</tr>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td><a href="https://github.com/ikidou">https://github.com/ikidou</a></td>
<td><a href="https://github.com/ikidou">https://github.com/ikidou</a></td>
</tr>
</tbody>
</table>

<p>从上面不能难看出以下规则：</p>

<ul>
<li>如果你在注解中提供的url是完整的url，则url将作为请求的url。</li>
<li>如果你在注解中提供的url是不完整的url，且不以 / 开头，则请求的url为baseUrl+注解中提供的值</li>
<li>如果你在注解中提供的url是不完整的url，且以 / 开头，则请求的url为baseUrl的主机部分+注解中提供的值</li>
</ul>

<h3 id="toc_15">Retrofit提供的Converter</h3>

<table>
<thead>
<tr>
<th>Converter</th>
<th>Gradle依赖</th>
</tr>
</thead>

<tbody>
<tr>
<td>Gson</td>
<td>com.squareup.retrofit2:converter-gson:2.0.2</td>
</tr>
<tr>
<td>Jackson</td>
<td>com.squareup.retrofit2:converter-jackson:2.0.2</td>
</tr>
<tr>
<td>Moshi</td>
<td>com.squareup.retrofit2:converter-moshi:2.0.2</td>
</tr>
<tr>
<td>Protobuf</td>
<td>com.squareup.retrofit2:converter-protobuf:2.0.2</td>
</tr>
<tr>
<td>Wire</td>
<td>com.squareup.retrofit2:converter-wire:2.0.2</td>
</tr>
<tr>
<td>Simple XML</td>
<td>com.squareup.retrofit2:converter-simplexml:2.0.2</td>
</tr>
<tr>
<td>Scalars</td>
<td>com.squareup.retrofit2:converter-scalars:2.0.2</td>
</tr>
</tbody>
</table>

<h3 id="toc_16">Retrofit提供的CallAdapter：</h3>

<table>
<thead>
<tr>
<th>CallAdapter</th>
<th>Gradle依赖</th>
</tr>
</thead>

<tbody>
<tr>
<td>guava</td>
<td>com.squareup.retrofit2:adapter-guava:2.0.2</td>
</tr>
<tr>
<td>Java8</td>
<td>com.squareup.retrofit2:adapter-java8:2.0.2</td>
</tr>
<tr>
<td>rxjava</td>
<td>com.squareup.retrofit2:adapter-rxjava:2.0.2</td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870200.html">
                
                  <h1>Android-Gson详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>最近在项目中发现网络请求回来的Json数据都用Gson进行解析，以前没有对其进行一个系统的了解，所以这里做一个知识点的归纳整理。</p>

<p>Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。而JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。</p>

<h2 id="toc_1">基本概念</h2>

<ul>
<li>Serialization:序列化，使Java对象到Json字符串的过程。</li>
<li>Deserialization：反序列化，字符串转换成Java对象。</li>
<li>JSON数据中的<code>JsonElement</code>有下面这四种类型：  JsonPrimitive —— 例如一个字符串或整型JsonObject—— 一个以 JsonElement 名字（类型为           String）作为索引的集合。也就是说可以把 JsonObject 看作值为 JsonElement 的键值对集合。JsonArray—— JsonElement 的集合。注意数组的元素可以是四种类型中的任意一种，或者混合类型都支持。JsonNull—— 值为null</li>
</ul>

<h2 id="toc_2">Gson解决的问题</h2>

<ul>
<li>提供一种像toString()和构造方法的很简单的机制，来实现Java 对象和Json之间的互相转换。</li>
<li>允许已经存在的无法改变的对象，转换成Json，或者Json转换成已存在的对象。</li>
<li>允许自定义对象的表现形式</li>
<li>支持任意的复杂对象</li>
<li>能够生成可压缩和可读的Json的字符串输出。</li>
</ul>

<h2 id="toc_3">Gson处理对象的几个重要点</h2>

<ul>
<li>推荐把成员变量都声明称<code>private</code>的</li>
<li>没有必要用注解（<code>@Expose</code> 注解）指明某个字段是否会被序列化或者反序列化，所有包含在当前类（包括父类）中的字段都应该默认被序列化或者反序列化</li>
<li>如果某个字段被 <code>transient</code> 这个Java关键词修饰，就不会被序列化或者反序列化</li>
<li>下面的实现方式能够正确的处理<code>null</code>
<ul>
<li>当序列化的时候，如果对象的某个字段为<code>null</code>，是不会输出到Json字符串中的。</li>
<li>当反序列化的时候，某个字段在<code>Json</code>字符串中找不到对应的值，就会被赋值为<code>null</code></li>
</ul></li>
<li>如果一个字段是 <code>synthetic</code>的,他会被忽视，也即是不应该被序列化或者反序列化</li>
<li>内部类（或者<code>anonymous class</code>（匿名类），或者<code>local class</code>(局部类，可以理解为在方法内部声明的类)）的某个字段和外部类的某个字段一样的话，就会被忽视，不会被序列化或者反序列化</li>
</ul>

<h2 id="toc_4">Gson的基本用法</h2>

<p>Gson提供了<code>fromJson()</code> 和<code>toJson()</code>两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。</p>

<p>基本数据类型的解析</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
int i = gson.fromJson(&quot;100&quot;, int.class);              //100
double d = gson.fromJson(&quot;\&quot;99.99\&quot;&quot;, double.class);  //99.99
boolean b = gson.fromJson(&quot;true&quot;, boolean.class);     // true
String str = gson.fromJson(&quot;String&quot;, String.class);   // String
</code></pre>

<p><strong>注：不知道你是否注意到了第2、3行有什么不一样没</strong></p>

<p>基本数据类型的生成</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
String jsonNumber = gson.toJson(100);       // 100
String jsonBoolean = gson.toJson(false);    // false
String jsonString = gson.toJson(&quot;String&quot;); //&quot;String&quot;
</code></pre>

<p>POJO类的生成与解析</p>

<pre class="line-numbers"><code class="language-java">public class User {
    //省略其它
    public String name;
    public int age;
    public String emailAddress;
}
</code></pre>

<p>生成JSON：</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24);
String jsonObject = gson.toJson(user); // {&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24}
</code></pre>

<p>解析JSON：</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
String jsonString = &quot;{\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:24}&quot;;
User user = gson.fromJson(jsonString, User.class);
</code></pre>

<h3 id="toc_5">Gson中使用泛型</h3>

<p>上面了解的JSON中的Number、boolean、Object和String，现在说一下Array。<br/>
例：JSON字符串数组</p>

<pre class="line-numbers"><code class="language-java">[&quot;Android&quot;,&quot;Java&quot;,&quot;PHP&quot;]
</code></pre>

<p>当我们要通过Gson解析这个json时，一般有两种方式：使用数组，使用List。而List对于增删都是比较方便的，所以实际使用是还是List比较多。</p>

<p>数组比较简单</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
String jsonArray = &quot;[\&quot;Android\&quot;,\&quot;Java\&quot;,\&quot;PHP\&quot;]&quot;;
String[] strings = gson.fromJson(jsonArray, String[].class);
</code></pre>

<p>但对于List将上面的代码中的 <code>String[].class</code> 直接改为 <code>List&lt;String&gt;.class</code> 是行不通的。对于Java来说<code>List&lt;String&gt;</code> 和<code>List&lt;User&gt;</code> 这俩个的字节码文件只一个那就是<code>List.class</code>，这是Java泛型使用时要注意的问题 泛型擦除。<br/><br/>
为了解决的上面的问题，Gson为我们提供了<code>TypeToken</code>来实现对泛型的支持，所以当我们希望使用将以上的数据解析<code>List&lt;String&gt;</code>时需要这样写。</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
String jsonArray = &quot;[\&quot;Android\&quot;,\&quot;Java\&quot;,\&quot;PHP\&quot;]&quot;;
String[] strings = gson.fromJson(jsonArray, String[].class);
List&lt;String&gt; stringList = gson.fromJson(jsonArray, new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType());
</code></pre>

<p>注：<code>TypeToken</code>的构造方法是<code>protected</code>修饰的,所以上面才会写成<code>new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType()</code> 而不是  <code>new TypeToken&lt;List&lt;String&gt;&gt;().getType()</code>泛型解析对接口POJO的设计影响泛型的引入可以减少无关的代码，如我现在所在公司接口返回的数据分为两类：</p>

<pre class="line-numbers"><code class="language-javascript">{&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:{}}
</code></pre>

<pre class="line-numbers"><code class="language-javascript">{&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:[]}
</code></pre>

<p>我们真正需要的<code>data</code>所包含的数据，而<code>code</code>只使用一次，<code>message</code>则几乎不用。如果Gson不支持泛型或不知道Gson支持泛型的同学一定会这么定义POJO。</p>

<pre class="line-numbers"><code class="language-java">public class UserResponse {
    public int code;
    public String message;
    public User data;
}
</code></pre>

<p>当其它接口的时候又重新定义一个<code>XXResponse</code>将<code>data</code>的类型改成XX，很明显<code>code</code>，和<code>message</code>被重复定义了多次，通过泛型的话我们可以将<code>code</code>和<code>message</code>字段抽取到一个<code>Result</code>的类中，这样我们只需要编写<code>data</code>字段所对应的POJO即可，更专注于我们的业务逻辑。如：</p>

<pre class="line-numbers"><code class="language-java">public class Result&lt;T&gt; {
    public int code;
    public String message;
    public T data;
}
</code></pre>

<p>那么对于<code>data</code>字段是<code>User</code>时则可以写为 <code>Result&lt;User&gt;</code> ,当是个列表的时候为 <code>Result&lt;List&lt;User&gt;&gt;</code>，其它同理。</p>

<h3 id="toc_6">手动方式</h3>

<p>手动的方式就是使用<code>stream</code>包下的<code>JsonReader</code>类来手动实现反序列化，和Android中使用pull解析XML是比较类似的。</p>

<pre class="line-numbers"><code class="language-java">String json = &quot;{\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:\&quot;24\&quot;}&quot;;
User user = new User();
JsonReader reader = new JsonReader(new StringReader(json));
reader.beginObject(); // throws IOException
while (reader.hasNext()) {
    String s = reader.nextName();
    switch (s) {
        case &quot;name&quot;:
            user.name = reader.nextString();
            break;
        case &quot;age&quot;:
            user.age = reader.nextInt(); //自动转换
            break;
        case &quot;email&quot;:
            user.email = reader.nextString();
            break;
    }
}
reader.endObject(); // throws IOException
System.out.println(user.name);  // 怪盗kidou
System.out.println(user.age);   // 24
System.out.println(user.email); // ikidou@example.com
</code></pre>

<p>其实自动方式最终都是通过<code>JsonReader</code>来实现的，如果第一个参数是<code>String</code>类型，那么Gson会创建一个<code>StringReader</code>转换成流操作。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101215077695811912.png" alt="2017101215077695811912.png"/><figcaption>2017101215077695811912.png</figcaption></figure></p>

<h3 id="toc_7">Gson的流式序列化</h3>

<h4 id="toc_8">自动方式</h4>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150776961842252.png" alt="20171012150776961842252.png"/><figcaption>20171012150776961842252.png</figcaption></figure></p>

<p>所以啊，学会利用IDE的自动完成是多么重要这下知道了吧！<br/>
可以看出用红框选中的部分就是我们要找的东西。<br/><br/>
提示：<code>PrintStream</code>(System.out) 、<code>StringBuilder</code>、<code>StringBuffer</code>和<code>*Writer</code>都实现了<code>Appendable</code>接口。</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24,&quot;ikidou@example.com&quot;);
gson.toJson(user,System.out); // 写到控制台
</code></pre>

<h4 id="toc_9">手动方式</h4>

<pre class="line-numbers"><code class="language-java">JsonWriter writer = new JsonWriter(new OutputStreamWriter(System.out));
writer.beginObject() // throws IOException
        .name(&quot;name&quot;).value(&quot;怪盗kidou&quot;)
        .name(&quot;age&quot;).value(24)
        .name(&quot;email&quot;).nullValue() //演示null
        .endObject(); // throws IOException
writer.flush(); // throws IOException
//{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:null}
</code></pre>

<p>提示：除了<code>beginObject</code>、<code>endObject</code>还有<code>beginArray</code>和<code>endArray</code>，两者可以相互嵌套，注意配对即可。<code>beginArray</code>后不可以调用<code>name</code>方法，同样<code>beginObject</code>后在调用<code>value</code>之前必须要调用<code>name</code>方法。</p>

<h3 id="toc_10">使用GsonBuilder导出null值、格式化输出、日期时间</h3>

<p>一般情况下<code>Gson</code>类提供的 API已经能满足大部分的使用场景，但我们需要更多更特殊、更强大的功能时，这时候就引入一个新的类 <code>GsonBuilder</code>。<br/>
<code>GsonBuilder</code>从名上也能知道是用于构建Gson实例的一个类，要想改变Gson默认的设置必须使用该类配置Gson。</p>

<h4 id="toc_11"><strong>GsonBuilder用法</strong></h4>

<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
               //各种配置
               .create(); //生成配置好的Gson
</code></pre>

<p>Gson在默认情况下是不动导出值<code>null</code>的键的，如：</p>

<pre class="line-numbers"><code class="language-java">public class User {
    //省略其它
    public String name;
    public int age;
    public String email;
}
</code></pre>

<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24);
System.out.println(gson.toJson(user)); //{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24}
</code></pre>

<p>可以看出，<code>email</code>字段是没有在json中出现的，当我们在调试是、需要导出完整的json串时或API接中要求没有值必须用Null时，就会比较有用。</p>

<p>使用方法：</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
        .serializeNulls()
        .create();
User user = new User(&quot;怪盗kidou&quot;, 24);
System.out.println(gson.toJson(user)); //{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:null}
</code></pre>

<h4 id="toc_12">格式化输出、日期时间及其它：</h4>

<p>这些都比较简单就不一一分开写了。</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
        //序列化null
        .serializeNulls()
        // 设置日期时间格式，另有2个重载方法
        // 在序列化和反序化时均生效
        .setDateFormat(&quot;yyyy-MM-dd&quot;)
        // 禁此序列化内部类
        .disableInnerClassSerialization()
        //生成不可执行的Json（多了 )]}&#39; 这4个字符）
        .generateNonExecutableJson()
        //禁止转义html标签
        .disableHtmlEscaping()
        //格式化输出
        .setPrettyPrinting()
        .create();
</code></pre>

<p>注意：内部类(Inner Class)和嵌套类(Nested Class)的区别</p>

<h2 id="toc_13">Gson中的一些注解</h2>

<h3 id="toc_14">@SerializedName注解</h3>

<p>该注解能指定该字段在JSON中对应的字段名称</p>

<pre class="line-numbers"><code class="language-java">public class Box {

  @SerializedName(&quot;w&quot;)
  private int width;

  @SerializedName(&quot;h&quot;)
  private int height;

  @SerializedName(&quot;d&quot;)
  private int depth;

  // Methods removed for brevity
}
</code></pre>

<p>也就是说<code>{&quot;w&quot;:10,&quot;h&quot;:20,&quot;d&quot;:30}</code> 这个JSON 字符串能够被解析到上面的width，height和depth字段中。</p>

<h3 id="toc_15">@Expose注解</h3>

<p>该注解能够指定该字段是否能够序列化或者反序列化，默认的是都支持（true）。简单说来就是需要导出的字段上加上@Expose 注解，不导出的字段不加。注意是不导出的不加。</p>

<pre class="line-numbers"><code class="language-java">public class Account {

  @Expose(deserialize = false)
  private String accountNumber;

  @Expose
  private String iban;

  @Expose(serialize = false)
  private String owner;

  @Expose(serialize = false, deserialize = false)
  private String address;

  private String pin;
}
</code></pre>

<p>该注解在使用<code>new Gson()</code> 时是不会发生作用。毕竟最常用的API要最简单，所以该注解必须和<code>GsonBuilder</code>配合使用。需要注意的通过 <code>builder.excludeFieldsWithoutExposeAnnotation()</code>方法使该注解生效。</p>

<pre class="line-numbers"><code class="language-java">final GsonBuilder builder = new GsonBuilder();
builder.excludeFieldsWithoutExposeAnnotation();
final Gson gson = builder.create();
</code></pre>

<h3 id="toc_16">@Since和@Until注解</h3>

<p>Since代表“自从”，Until 代表”一直到”。它们都是针对该字段生效的版本。比如说<code>@Since(1.2)</code>代表从版本1.2之后才生效，<code>@Until(0.9)</code>代表着在0.9版本之前都是生效的。</p>

<pre class="line-numbers"><code class="language-java">public class SoccerPlayer {

  private String name;

  @Since(1.2)
  private int shirtNumber;

  @Until(0.9)
  private String country;

  private String teamName;

  // Methods removed for brevity
}
</code></pre>

<p>也就是说我们利用方法<code>builder.setVersion(1.0)</code>定义版本1.0，如下：</p>

<pre class="line-numbers"><code class="language-java">final GsonBuilder builder = new GsonBuilder();
    builder.setVersion(1.0);

    final Gson gson = builder.create();

    final SoccerPlayer account = new SoccerPlayer();
    account.setName(&quot;Albert Attard&quot;);
    account.setShirtNumber(10); // Since version 1.2
    account.setTeamName(&quot;Zejtun Corinthians&quot;);
    account.setCountry(&quot;Malta&quot;); // Until version 0.9

    final String json = gson.toJson(account);
    System.out.printf(&quot;Serialised (version 1.0)%n  %s%n&quot;, json);
</code></pre>

<p>由于<code>shirtNumber</code>和<code>country</code>作用版本分别是1.2之后，和0.9之前，所以在这里都不会得到序列化，所以输出结果是：</p>

<pre class="line-numbers"><code class="language-java">Serialised (version 1.0)
  {&quot;name&quot;:&quot;Albert Attard&quot;,&quot;teamName&quot;:&quot;Zejtun Corinthians&quot;}
</code></pre>

<h4 id="toc_17">基于访问修饰符</h4>

<p>什么是修饰符? <code>public</code>、<code>static</code> 、<code>final</code>、<code>private</code>、<code>protected</code> 这些就是，所以这种方式也是比较特殊的。使用方式：</p>

<pre class="line-numbers"><code class="language-java">class ModifierSample {
    final String finalField = &quot;final&quot;;
    static String staticField = &quot;static&quot;;
    public String publicField = &quot;public&quot;;
    protected String protectedField = &quot;protected&quot;;
    String defaultField = &quot;default&quot;;
    private String privateField = &quot;private&quot;;
}
</code></pre>

<p>使用<code>GsonBuilder.excludeFieldsWithModifiers</code>构建gson,支持<code>int</code>形的可变参数，值由<code>java.lang.reflect.Modifier</code>提供，下面的程序排除了<code>privateField</code> 、 <code>finalField</code> 和<code>staticField</code> 三个字段。</p>

<pre class="line-numbers"><code class="language-java">ModifierSample modifierSample = new ModifierSample();
Gson gson = new GsonBuilder()
        .excludeFieldsWithModifiers(Modifier.FINAL, Modifier.STATIC, Modifier.PRIVATE)
        .create();
System.out.println(gson.toJson(modifierSample));
// 结果：{&quot;publicField&quot;:&quot;public&quot;,&quot;protectedField&quot;:&quot;protected&quot;,&quot;defaultField&quot;:&quot;default&quot;}
</code></pre>

<p>到此为止，Gson提供的所有注解就还有一个<code>@JsonAdapter</code>没有介绍了，而<code>@JsonAdapter</code>将和<code>TypeAdapter</code>将作为该系列第4篇也是最后一篇文章的主要内容。</p>

<h4 id="toc_18">基于策略（自定义规则）</h4>

<p>上面介绍的了3种排除字段的方法，说实话我除了@Expose以外，其它的都是只在Demo用上过，用得最多的就是马上要介绍的自定义规则，好处是功能强大、灵活，缺点是相比其它3种方法稍麻烦一点，但也仅仅只是想对其它3种稍麻烦一点而已。</p>

<p>基于策略是利用Gson提供的<code>ExclusionStrategy</code>接口，同样需要使用<code>GsonBuilder</code>,相关API 2个，分别是<code>addSerializationExclusionStrategy</code> 和<code>addDeserializationExclusionStrategy</code> 分别针对序列化和反序化时。这里以序列化为例。<br/><br/>
例如：</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
        .addSerializationExclusionStrategy(new ExclusionStrategy() {
            @Override
            public boolean shouldSkipField(FieldAttributes f) {
                // 这里作判断，决定要不要排除该字段,return true为排除
                if (&quot;finalField&quot;.equals(f.getName())) return true; //按字段名排除
                Expose expose = f.getAnnotation(Expose.class); 
                if (expose != null &amp;&amp; expose.deserialize() == false) return true; //按注解排除
                return false;
            }
            @Override
            public boolean shouldSkipClass(Class&lt;?&gt; clazz) {
                // 直接排除某个类 ，return true为排除
                return (clazz == int.class || clazz == Integer.class);
            }
        })
        .create();
</code></pre>

<h2 id="toc_19">POJO与JSON的字段映射规则</h2>

<p>还是之前User的例子，已经去除所有注解：</p>

<pre class="line-numbers"><code class="language-java">User user = new User(&quot;怪盗kidou&quot;, 24);
user.emailAddress = &quot;ikidou@example.com&quot;;
</code></pre>

<p><code>GsonBuilder</code>提供了<code>FieldNamingStrategy</code>接口和<code>setFieldNamingPolicy</code>和<code>setFieldNamingStrategy</code> 两个方法。</p>

<p><strong>默认实现</strong><br/>
<code>GsonBuilder.setFieldNamingPolicy</code> 方法与Gson提供的另一个枚举类<code>FieldNamingPolicy</code>配合使用，该枚举类提供了5种实现方式分别为：</p>

<table>
<thead>
<tr>
<th>FieldNamingPolicy</th>
<th>结果（仅输出emailAddress字段）</th>
</tr>
</thead>

<tbody>
<tr>
<td>IDENTITY</td>
<td>{&quot;emailAddress&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
<tr>
<td>LOWER_CASE_WITH_DASHES</td>
<td>{&quot;email-address&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
<tr>
<td>LOWER_CASE_WITH_UNDERSCORES</td>
<td>{&quot;email_address&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
<tr>
<td>UPPER_CAMEL_CASE</td>
<td>{&quot;EmailAddress&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
<tr>
<td>UPPER_CAMEL_CASE_WITH_SPACES</td>
<td>{&quot;Email Address&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
</tbody>
</table>

<p><strong>自定义实现</strong><br/>
<code>GsonBuilder.setFieldNamingStrategy</code> 方法需要与Gson提供的<code>FieldNamingStrategy</code>接口配合使用，用于实现将POJO的字段与JSON的字段相对应。上面的<code>FieldNamingPolicy</code>实际上也实现了<code>FieldNamingStrategy</code>接口，也就是说<code>FieldNamingPolicy</code>也可以使用<code>setFieldNamingStrategy</code>方法。</p>

<p>用法：</p>

<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
        .setFieldNamingStrategy(new FieldNamingStrategy() {
            @Override
            public String translateName(Field f) {
                //实现自己的规则
                return null;
            }
        })
        .create();
</code></pre>

<p><strong>注意：</strong> <code>@SerializedName</code>注解拥有最高优先级，在加有<code>@SerializedName</code>注解的字段上<code>FieldNamingStrategy</code>不生效！</p>

<h2 id="toc_20">Gson 序列化</h2>

<p>英文Serialize和format都对应序列化，这是一个Java对象到JSON字符串的过程。接着看一个例子,下面分别是java类和以及我们期望的JSON数据：</p>

<pre class="line-numbers"><code class="language-java">public class Book {
  private String[] authors;
  private String isbn10;
  private String isbn13;
  private String title;
  //为了代码简洁，这里移除getter和setter方法等
}
</code></pre>

<pre class="line-numbers"><code class="language-javascript">{
  &quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,
  &quot;isbn-10&quot;: &quot;032133678X&quot;,
  &quot;isbn-13&quot;: &quot;978-0321336781&quot;,
  &quot;authors&quot;: [
    &quot;Joshua Bloch&quot;,
    &quot;Neal Gafter&quot;
  ]
}
</code></pre>

<p>你肯定能发现JSON数据中出现了<code>isbn-10</code>和<code>isbn-13</code>, 我们怎么把字段数据<code>isbn10</code>和<code>isbn13</code>转化为JSON数据需要的<code>isbn-10</code>和<code>isbn-13</code>,Gson当然为我们提供了对应的解决方案</p>

<h3 id="toc_21">序列化方案1</h3>

<p>采用上面提到的<code>@SerializedName</code>注解。</p>

<pre class="line-numbers"><code class="language-java">public class Book {
  private String[] authors;

  @SerializedName(&quot;isbn-10&quot;)
  private String isbn10;

  @SerializedName(&quot;isbn-13&quot;)
  private String isbn13;
  private String title;
  //为了代码简洁，这里移除getter和setter方法等
}
</code></pre>

<h3 id="toc_22">序列化方案2</h3>

<p>利用<code>JsonSerializer</code>类</p>

<pre class="line-numbers"><code class="language-java">public class BookSerialiser implements JsonSerializer {
    @Override
    public JsonElement serialize(final Book book, final Type typeOfSrc, final JsonSerializationContext context) {

        final JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty(&quot;title&quot;, book.getTitle());
        jsonObject.addProperty(&quot;isbn-10&quot;, book.getIsbn10());
        jsonObject.addProperty(&quot;isbn-13&quot;, book.getIsbn13());

        final JsonArray jsonAuthorsArray = new JsonArray();
        for (final String author : book.getAuthors()) {
            final JsonPrimitive jsonAuthor = new JsonPrimitive(author);
            jsonAuthorsArray.add(jsonAuthor);
        }
        jsonObject.add(&quot;authors&quot;, jsonAuthorsArray);

        return jsonObject;
    }
}
</code></pre>

<p>下面对序列化过程进行大致的分析：</p>

<ul>
<li>JsonSerializer是一个接口，我们需要提供自己的实现，来满足自己的序列化要求。</li>
</ul>

<pre class="line-numbers"><code class="language-java">public interface JsonSerializer&lt;T&gt; {

/**
 *Gson 会在解析指定类型T数据的时候触发当前回调方法进行序列化
 *
 * @param T 需要转化为Json数据的类型，对应上面的Book
 * @return 返回T指定的类对应JsonElement
 */
public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);
}
</code></pre>

<ul>
<li>首先在上面的代码中，我们需要创建的是一个JsonElement对象，这里对应Book是一个对象，所以创建一个JsonObject类型。<br/>
<code>final JsonObject jsonObject = new JsonObject();</code></li>
<li>然后我们将相应字段里面的数据填充到jsonObject里面。<br/>
<code>java
jsonObject.addProperty...<br/>
jsonObject.add...
</code></li>
<li>下面是jsonObject中的添加方法：<code>jsonObj.add(String property,JsonElement value)</code></li>
<li>所以最后返回的还是一个JsonElement 类型，这里对应的是jsonObject。完成了javaBean-&gt;JSON数据的转化。 </li>
<li>同样需要配置, </li>
</ul>

<pre class="line-numbers"><code class="language-java">// Configure GSON
  final GsonBuilder gsonBuilder = new GsonBuilder();
  gsonBuilder.registerTypeAdapter(Book.class, new BookSerialiser());
  gsonBuilder.setPrettyPrinting();
  final Gson gson = gsonBuilder.create();

  final Book javaPuzzlers = new Book();
  javaPuzzlers.setTitle(&quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;);
  javaPuzzlers.setIsbn10(&quot;032133678X&quot;);
  javaPuzzlers.setIsbn13(&quot;978-0321336781&quot;);
  javaPuzzlers.setAuthors(new String[] { &quot;Joshua Bloch&quot;, &quot;Neal Gafter&quot; });

  // Format to JSON
  final String json = gson.toJson(javaPuzzlers);
  System.out.println(json);
</code></pre>

<p>，这里对应的是<code>gsonBuilder.registerTypeAdapter(Book.class, new BookSerialiser())</code>方法进行JsonSerializer的配置。在上面例子中，通过调用<code>gsonBuilder.setPrettyPrinting();</code>方法还告诉了 Gson 对生成的 JSON 对象进行格式化</p>

<h2 id="toc_23">Gson 反序列化</h2>

<p>英文<code>parse</code>和<code>deserialise</code>对应反序列化，这是一个字符串转换成Java对象的过程。我们同样采用上面一小节的代码片段，只不过现在我们需要做的是将：</p>

<pre class="line-numbers"><code class="language-javascript">{
  &quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,
  &quot;isbn-10&quot;: &quot;032133678X&quot;,
  &quot;isbn-13&quot;: &quot;978-0321336781&quot;,
  &quot;authors&quot;: [
    &quot;Joshua Bloch&quot;,
    &quot;Neal Gafter&quot;
  ]
}
</code></pre>

<p>转化为对应的Book实体类。</p>

<h3 id="toc_24">反序列化方案1</h3>

<p>利用<code>@SerializedName</code> 注解也就是说我们的实体类Book.java可以这么写：</p>

<pre class="line-numbers"><code class="language-java">public class Book {
  private String[] authors;

  @SerializedName(&quot;isbn-10&quot;)
  private String isbn10;

  @SerializedName(value = &quot;isbn-13&quot;, alternate = {&quot;isbn13&quot;,&quot;isbn.13&quot;})
  private String isbn13;
  private String title;
  //为了代码简洁，这里移除getter和setter方法等
}
</code></pre>

<blockquote>
<p>可以看到这里我们在<code>@SerializedName</code>  注解使用了一个<code>value</code>, <code>alternate</code>字段,<code>value</code>也就是默认的字段，对序列化和反序列化都有效，<code>alternate</code>只有反序列化才有效果。也就是说一般服务器返回给我们JSON数据的时候可能同样的一个图片，表示&quot;image&quot;,&quot;img&quot;,&quot;icon&quot;等备选属性名，我们利用<code>@SerializedName</code>  中的<code>alternate</code>字段就能解决这个问题，全部转化为我们实体类中的图片字段。</p>
</blockquote>

<h3 id="toc_25">反序列化方案2</h3>

<p>我们在序列化的时候使用的是<code>JsonSerialize</code> ,这里对应使用<code>JsonDeserializer</code>我们将解析到的json数据传递给Book的setter方法即可。</p>

<pre class="line-numbers"><code class="language-java">public class BookDeserializer implements JsonDeserializer&lt;Book&gt; {

  @Override
  public Book deserialize(final JsonElement json, final Type typeOfT, final JsonDeserializationContext context)
      throws JsonParseException {
    final JsonObject jsonObject = json.getAsJsonObject();

    final JsonElement jsonTitle = jsonObject.get(&quot;title&quot;);
    final String title = jsonTitle.getAsString();

    final String isbn10 = jsonObject.get(&quot;isbn-10&quot;).getAsString();
    final String isbn13 = jsonObject.get(&quot;isbn-13&quot;).getAsString();

    final JsonArray jsonAuthorsArray = jsonObject.get(&quot;authors&quot;).getAsJsonArray();
    final String[] authors = new String[jsonAuthorsArray.size()];
    for (int i = 0; i &lt; authors.length; i++) {
      final JsonElement jsonAuthor = jsonAuthorsArray.get(i);
      authors[i] = jsonAuthor.getAsString();
    }

    final Book book = new Book();
    book.setTitle(title);
    book.setIsbn10(isbn10);
    book.setIsbn13(isbn13);
    book.setAuthors(authors);
    return book;
  }
}
</code></pre>

<p>和Gson序列化章节一样，我们这里接着分析我们是怎么将JSON数据解析（反序列化）为实体类的：</p>

<ul>
<li>因为我们可以发现上面的JSON数据是一个<code>{}</code>大括号包围的，也就意味着这是一个Json对象。所以首先我们通过<code>final JsonObject jsonObject = json.getAsJsonObject();</code>将我们的JsonElement转化为JsonObject</li>
<li>通过<code>jsonObject.get(&quot;xxx&quot;).getAsString()</code>的形式获取相应String的值</li>
<li>通过<code>jsonObject.get(&quot;xx&quot;).getAsJsonArray();</code>获取相应的json数组，并遍历出其中的相应字段值</li>
<li>通过setter方法，将获取到的值设置给Book类。</li>
<li>最终返回的是 Book的对象实例。完成了JSON-&gt;javaBean的转化</li>
<li>同样需要配置</li>
<li>关于从本地流中读取Json数据可以使用  <code>InputStreamReader</code>完成</li>
</ul>

<pre class="line-numbers"><code class="language-java">// Configure Gson
  GsonBuilder gsonBuilder = new GsonBuilder();
  gsonBuilder.registerTypeAdapter(Book.class, new BookDeserializer());
  Gson gson = gsonBuilder.create();

  // The JSON data
  try(Reader reader = new InputStreamReader(Main.class.getResourceAsStream(&quot;/part1/sample.json&quot;), &quot;UTF-8&quot;)){

    // Parse JSON to Java
    Book book = gson.fromJson(reader, Book.class);
    System.out.println(book);
  }
</code></pre>

<h2 id="toc_26">TypeAdapter</h2>

<h3 id="toc_27">TypeAdapter介绍</h3>

<p>之前在上一篇文中提到的<code>JsonSerializer</code>和<code>JsonDeserializer</code>解析的时候都利用到了一个中间件-<code>JsonElement</code>，比如下方的序列化过程。可以看到我们在把Java对象转化为JSON字符串的时候都会用到这个中间件<code>JsonElement</code></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150776994644553.png" alt="20171012150776994644553.png"/><figcaption>20171012150776994644553.png</figcaption></figure></p>

<p>而<code>TypeAdapter</code>的使用正是去掉了这个中间层，直接用流来解析数据，极大程度上提高了解析效率。</p>

<blockquote>
<p>New applications should prefer TypeAdapter, whose streaming API is more efficient than this interface’s tree API.应用中应当尽量使用<code>TypeAdapter</code>，它流式的API相比于之前的树形解析API将会更加高效。<br/>
<code>TypeAdapter</code>作为一个抽象类提供两个抽象方法。分别是<code>write()</code>和<code>read()</code>方法,也对应着序列化和反序列化,其它的方法都是<code>final</code>方法并最终调用这两个抽象方法。</p>
</blockquote>

<p>如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150776998438554.png" alt="20171012150776998438554.png"/><figcaption>20171012150776998438554.png</figcaption></figure></p>

<p>下面就让我们来一起使用和了解TypeAdapter吧。</p>

<h3 id="toc_28">TypeAdapter实例</h3>

<p>为了便于理解，这里还是统 一 一 下，采用和上面一篇文章同样的例子。<br/><br/>
<code>Book.java</code>实体类：</p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;

public class Book {

  private String[] authors;
  private String isbn;
  private String title;

//为了代码简洁，这里移除getter和setter方法等
}
</code></pre>

<p>直接贴代码，具体序列化和反序列化的<code>TypeAdapter</code>类，这里是<code>BookTypeAdapter.java</code>：  </p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;
import java.io.IOException;
import org.apache.commons.lang3.StringUtils;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

public class BookTypeAdapter extends TypeAdapter {

  @Override
  public Book read(final JsonReader in) throws IOException {
    final Book book = new Book();

    in.beginObject();
    while (in.hasNext()) {
      switch (in.nextName()) {
      case &quot;isbn&quot;:
        book.setIsbn(in.nextString());
        break;
      case &quot;title&quot;:
        book.setTitle(in.nextString());
        break;
      case &quot;authors&quot;:
        book.setAuthors(in.nextString().split(&quot;;&quot;));
        break;
      }
    }
    in.endObject();

    return book;
  }

  @Override
  public void write(final JsonWriter out, final Book book) throws IOException {
    out.beginObject();
    out.name(&quot;isbn&quot;).value(book.getIsbn());
    out.name(&quot;title&quot;).value(book.getTitle());
    out.name(&quot;authors&quot;).value(StringUtils.join(book.getAuthors(), &quot;;&quot;));
    out.endObject();
  }
}
</code></pre>

<p>同样这里设置<code>TypeAdapter</code>之后还是需要配置（注册）,可以注意到的是<code>gsonBuilder.registerTypeAdapter(xxx)</code>方法进行注册在我们之前的<code>JsonSerializer</code>和<code>JsonDeserializer</code>中也有使用：</p>

<pre class="line-numbers"><code class="language-java">final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(Book.class, new BookTypeAdapter());
    final Gson gson = gsonBuilder.create();
</code></pre>

<p>下面对两个write方法和read方法进行分别的阐述：</p>

<h4 id="toc_29">TypeAdapter中的write方法</h4>

<p><code>write()</code>方法中会传入<code>JsonWriter</code>，和需要被序列化的<code>Book</code>对象的实例，采用和<code>PrintStream</code>类似的方式 写入到<code>JsonWriter</code>中。</p>

<pre class="line-numbers"><code class="language-java">  @Override
  public void write(final JsonWriter out, final Book book) throws IOException {
    out.beginObject();
    out.name(&quot;isbn&quot;).value(book.getIsbn());
    out.name(&quot;title&quot;).value(book.getTitle());
    out.name(&quot;authors&quot;).value(StringUtils.join(book.getAuthors(), &quot;;&quot;));
    out.endObject();
  }
</code></pre>

<p>下面是上面代码的步骤：</p>

<ul>
<li><code>out.beginObject()</code>产生<code>{</code>,如果我们希望产生的是一个数组对象，对应的使用<code>beginArray()</code></li>
<li><code>out.name(&quot;isbn&quot;).value(book.getIsbn()); out.name(&quot;title&quot;).value(book.getTitle());</code>分别获取book中的isbn和title字段并且设置给Json对象中的isbn和title。也就是说上面这段代码，会在json对象中产生：<code>&quot;isbn&quot;: &quot;978-0321336781&quot;,&quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,</code></li>
<li><code>out.name(&quot;authors&quot;).value(StringUtils.join(book.getAuthors(), &quot;;&quot;));</code>则会对应着：<code>&quot;authors&quot;: &quot;Joshua Bloch;Neal Gafter&quot;</code></li>
<li>同理  <code>out.endObject()</code>则对应着<code>}</code></li>
<li>那么整个上面的代码也就会产生JSON对象：<code>{&quot;isbn&quot;: &quot;978-0321336781&quot;,&quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,&quot;authors&quot;: &quot;Joshua Bloch;Neal Gafter&quot;}</code></li>
</ul>

<blockquote>
<p>这里需要注意的是，如果没有调用 <code>out.endObject()</code>产生<code>}</code>,那么你的项目会报出 </p>
</blockquote>

<pre class="line-numbers"><code class="language-java">JsonSyntaxException`错误`Exception in thread &quot;main&quot; com.google.gson.JsonSyntaxException: java.io.EOFException: End of input at line 4 column 40  at com.google.gson.Gson.fromJson(Gson.java:813)  at com.google.gson.Gson.fromJson(Gson.java:768)  at com.google.gson.Gson.fromJson(Gson.java:717)  at com.google.gson.Gson.fromJson(Gson.java:689)  at com.javacreed.examples.gson.part1.Main.main(Main.java:41)Caused by: java.io.EOFException: End of input at line 4 column 40  at com.google.gson.stream.JsonReader.nextNonWhitespace(JsonReader.java:1377)  at com.google.gson.stream.JsonReader.doPeek(JsonReader.java:471)  at com.google.gson.stream.JsonReader.hasNext(JsonReader.java:403)  at com.javacreed.examples.gson.part1.BookTypeAdapter.read(BookTypeAdapter.java:33)  at com.javacreed.examples.gson.part1.BookTypeAdapter.read(BookTypeAdapter.java:1)  at com.google.gson.Gson.fromJson(Gson.java:803)  ... 4 more
</code></pre>

<h4 id="toc_30">TypeAdapter中的read方法</h4>

<p><code>read()</code>方法将会传入一个<code>JsonReader</code>对象实例并返回反序列化的对象。</p>

<pre class="line-numbers"><code class="language-java">  @Override
  public Book read(final JsonReader in) throws IOException {
    final Book book = new Book();

    in.beginObject();
    while (in.hasNext()) {
      switch (in.nextName()) {
      case &quot;isbn&quot;:
        book.setIsbn(in.nextString());
        break;
      case &quot;title&quot;:
        book.setTitle(in.nextString());
        break;
      case &quot;authors&quot;:
        book.setAuthors(in.nextString().split(&quot;;&quot;));
        break;
      }
    }
    in.endObject();

    return book;
  }
</code></pre>

<p>下面是这段代码的步骤：<br/>
同样是通过<code>in.beginObject();</code>和<code>in.endObject();</code>对应解析<code>{</code>,<code>}</code><br/>
通过<code>while (in.hasNext()) {switch (in.nextName()) {}}</code>来完成每个<code>JsonElement</code>的遍历,并且通过<code>switch...case</code>的方法获取Json对象中的键值对。并通过我们<code>Book实体类</code>的<code>Setter</code>方法进行设置。</p>

<pre class="line-numbers"><code class="language-java">while (in.hasNext()) {    
    switch (in.nextName()) {    
        case &quot;isbn&quot;:      
            book.setIsbn(in.nextString());      
            break;    
        case &quot;title&quot;:      
            book.setTitle(in.nextString());      
            break;    
        case &quot;authors&quot;:      
            book.setAuthors(in.nextString().split(&quot;;&quot;));      
            break;    
    }  
}
</code></pre>

<blockquote>
<p>同样需要注意的是,如果没有执行<code>in.endObject()</code>，将会出现<code>JsonIOException</code>的错误：</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">Exception in thread &quot;main&quot; com.google.gson.JsonIOException: JSON document was not fully consumed.  at   com.google.gson.Gson.assertFullConsumption(Gson.java:776)  at com.google.gson.Gson.fromJson(Gson.java:769)  at com.google.gson.Gson.fromJson(Gson.java:717)  at com.google.gson.Gson.fromJson(Gson.java:689)  at com.javacreed.examples.gson.part1.Main.main(Main.java:41)
</code></pre>

<p>下面给出使用<code>TypeAdapter</code>的完整代码：</p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;

import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(Book.class, new BookTypeAdapter());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final Book book = new Book();
    book.setAuthors(new String[] { &quot;Joshua Bloch&quot;, &quot;Neal Gafter&quot; });
    book.setTitle(&quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;);
    book.setIsbn(&quot;978-0321336781&quot;);

    final String json = gson.toJson(book);
    System.out.println(&quot;Serialised&quot;);
    System.out.println(json);

    final Book parsedBook = gson.fromJson(json, Book.class);
    System.out.println(&quot;\nDeserialised&quot;);
    System.out.println(parsedBook);
  }
}
</code></pre>

<p>对应的编译结果为：</p>

<pre class="line-numbers"><code class="language-java">Serialised
{
  &quot;isbn&quot;: &quot;978-0321336781&quot;,
  &quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,
  &quot;authors&quot;: &quot;Joshua Bloch;Neal Gafter&quot;
}

Deserialised
Java Puzzlers: Traps, Pitfalls, and Corner Cases [978-0321336781]
Written by:
  &gt;&gt; Joshua Bloch
  &gt;&gt; Neal Gafter
</code></pre>

<h3 id="toc_31">TypeAdapter处理简洁的JSON数据</h3>

<p>为了简化JSON数据，其实我们上面的JSON数据可以这么写：</p>

<pre class="line-numbers"><code class="language-javascript">[&quot;978-0321336781&quot;,&quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,&quot;Joshua Bloch&quot;,&quot;Neal Gafter&quot;]
</code></pre>

<p>可以看到的是，这样采用的直接是值的形式。当然这样操作简化了JSON数据但是可能就让整个数据的稳定性下降了许多的，你需要按照一定的顺序来解析这个数据。对应的<code>write</code>和<code>read</code>方法如下：</p>

<pre class="line-numbers"><code class="language-java">  @Override
  public void write(final JsonWriter out, final Book book) throws IOException {
    out.beginArray();
    out.value(book.getIsbn());
    out.value(book.getTitle());
    for (final String author : book.getAuthors()) {
      out.value(author);
    }
    out.endArray();
  }
</code></pre>

<pre class="line-numbers"><code class="language-java">  @Override
  public Book read(final JsonReader in) throws IOException {
    final Book book = new Book();

    in.beginArray();
    book.setIsbn(in.nextString());
    book.setTitle(in.nextString());
    final List authors = new ArrayList&lt;&gt;();
    while (in.hasNext()) {
      authors.add(in.nextString());
    }
    book.setAuthors(authors.toArray(new String[authors.size()]));
    in.endArray();

    return book;
  }
</code></pre>

<p>这里的解析原理和上面一致，不再赘述。</p>

<h3 id="toc_32">TypeAdapter解析内置对象</h3>

<p>（这里将nested objects翻译为内置对象，其实就是在Book类）<br/>
这里对上面的Book实体类进行修改如下，添加Author作者类，每本书可以有多个作者。</p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part3;

public class Book {

  private Author[] authors;
  private String isbn;
  private String title;

class Author {

  private int id;
  private String name;

//为了代码简洁，这里移除getter和setter方法等
}
//为了代码简洁，这里移除getter和setter方法等
}
</code></pre>

<p>这里提供JSON对象，</p>

<pre class="line-numbers"><code class="language-java">{
  &quot;isbn&quot;: &quot;978-0321336781&quot;,
  &quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,
  &quot;authors&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;name&quot;: &quot;Joshua Bloch&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;Neal Gafter&quot;
    }
  ]
}
</code></pre>

<p>下面分别展示write和read方法：</p>

<pre class="line-numbers"><code class="language-java">  @Override
  public void write(final JsonWriter out, final Book book) throws IOException {
    out.beginObject();
    out.name(&quot;isbn&quot;).value(book.getIsbn());
    out.name(&quot;title&quot;).value(book.getTitle());
    out.name(&quot;authors&quot;).beginArray();
    for (final Author author : book.getAuthors()) {
      out.beginObject();
      out.name(&quot;id&quot;).value(author.getId());
      out.name(&quot;name&quot;).value(author.getName());
      out.endObject();
    }
    out.endArray();
    out.endObject();
  }
</code></pre>

<pre class="line-numbers"><code class="language-java"> @Override
  public Book read(final JsonReader in) throws IOException {
    final Book book = new Book();

    in.beginObject();
    while (in.hasNext()) {
      switch (in.nextName()) {
      case &quot;isbn&quot;:
        book.setIsbn(in.nextString());
        break;
      case &quot;title&quot;:
        book.setTitle(in.nextString());
        break;
      case &quot;authors&quot;:
        in.beginArray();
        final List authors = new ArrayList&lt;&gt;();
        while (in.hasNext()) {
          in.beginObject();
          final Author author = new Author();
          while (in.hasNext()) {
            switch (in.nextName()) {
            case &quot;id&quot;:
              author.setId(in.nextInt());
              break;
            case &quot;name&quot;:
              author.setName(in.nextString());
              break;
            }
          }
          authors.add(author);
          in.endObject();
        }
        book.setAuthors(authors.toArray(new Author[authors.size()]));
        in.endArray();
        break;
      }
    }
    in.endObject();

    return book;
  }
</code></pre>

<h2 id="toc_33">Gson性能分析</h2>

<p>首先来看看我们提供一个大一点的数据来论证下面一些方法的优缺点。 这里提供类<code>LargeData.java</code>,并分为四个部分进行内存消耗的分析：</p>

<pre class="line-numbers"><code class="language-java">public class LargeData {

  private long[] numbers;

  public void create(final int length) {
    numbers = new long[length];
    for (int i = 0; i &lt; length; i++) {
      numbers[i] = i;
    }
  }

  public long[] getNumbers() {
    return numbers;
  }

}
</code></pre>

<h3 id="toc_34">第1部分 JsonSerializer的直接使用</h3>

<p>看看下面的<code>JsonSerializer</code>:</p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;

import java.lang.reflect.Type;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class LargeDataSerialiser implements JsonSerializer&lt;LargeData&gt; {

  @Override
  public JsonElement serialize(final LargeData data, final Type typeOfSrc, final JsonSerializationContext context) {
    final JsonArray jsonNumbers = new JsonArray();
    for (final long number : data.getNumbers()) {
      jsonNumbers.add(new JsonPrimitive(number));
    }

    final JsonObject jsonObject = new JsonObject();
    jsonObject.add(&quot;numbers&quot;, jsonNumbers);
    return jsonObject;
  }
}
</code></pre>

<p>上面的代码实现了从<strong>java对象&gt;转化&gt;JSON数组</strong>的序列化过程。下面的代码实现了配置和初始化的过程，被写入文件。这里可以看到的是对<code>LargeData</code>初始化了<code>10485760</code>个元素：</p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final String json = gson.toJson(data);

    final File dir = new File(&quot;target/part1&quot;);
    dir.mkdirs();

    try (PrintStream out = new PrintStream(new File(dir, &quot;output.json&quot;), &quot;UTF-8&quot;)) {
      out.println(json);
    }

    System.out.println(&quot;Done&quot;);
  }
}
</code></pre>

<p>这个例子实现了创建java对象并且转化为JSON字符串并写入文件的整个过程。下面的图标展示了内存的消耗情况：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150777023393682.png" alt="20171012150777023393682.png"/><figcaption>20171012150777023393682.png</figcaption></figure></p>

<p>上面的的LargeData在这里会消耗89MB的内存，从java对象转化为JSON字符串的过程将会消耗大概16s的时间并且需要超过1GB的内存。也就是说，序列化1MB的数据我们需要大约11MB的工作空间。1：11的确实是一个不小的比列。下面的 图片会展示整个过程的几个阶段。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150777025353382.png" alt="20171012150777025353382.png"/><figcaption>20171012150777025353382.png</figcaption></figure></p>

<p>可以看到的是，这里有四个方块分别代表不同的阶段，（但是IO 缓冲区并没有在这里得到使用，所以以灰色进行标注。）整个过程从java对象（蓝色方块），然后由<code>LargeDataSerialiser</code>类创建的JSONElement对象（红色方块），然后这些临时的对象又被转化为JSON 字符串（绿色方块），上面的示例代码使用<code>PrintStream</code>将内容输出到文件中并没有使用任何缓冲区。<br/>
完成了第1部分的分析，接下来下面的分析流程是一样的：</p>

<h3 id="toc_35">第2 部分 TypeAdapter的直接使用</h3>

<p>之前的系列文章中都对Gson基础的使用进行了很好的讲解，可以回顾一下。<br/>
<code>TypeAdapter</code>相比 于上面的方法，并没有使用JSONElement对象，而是直接将Java对象啊转化为了JSON对象。</p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part2;

import java.io.IOException;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

public class LargeDataTypeAdapter extends TypeAdapter&lt;LargeData&gt; {

  @Override
  public LargeData read(final JsonReader in) throws IOException {
    throw new UnsupportedOperationException(&quot;Coming soon&quot;);
  }

  @Override
  public void write(final JsonWriter out, final LargeData data) throws IOException {
    out.beginObject();
    out.name(&quot;numbers&quot;);
    out.beginArray();
    for (final long number : data.getNumbers()) {
      out.value(number);
    }
    out.endArray();
    out.endObject();
  }
}
</code></pre>

<p>同样会需要配置，这里主要使用的方法是<code>gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());</code>：</p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part2;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final String json = gson.toJson(data);

    final File dir = new File(&quot;target/part2&quot;);
    dir.mkdirs();

    try (PrintStream out = new PrintStream(new File(dir, &quot;output.json&quot;), &quot;UTF-8&quot;)) {
      out.println(json);
    }

    System.out.println(&quot;Done&quot;);
  }
}
</code></pre>

<p>上面的代码完成的是从<strong>java对象 &gt;转化&gt;JSON 字符串</strong>并最终写入文件的过程。看看下面的性能分析图表：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150777031491897.png" alt="20171012150777031491897.png"/><figcaption>20171012150777031491897.png</figcaption></figure></p>

<p>和最初的那个方法一样，这里的LargeData对象将会需要89MB的内存，从java对象转化为JSON字符串的过程需要消耗4s的时间，大概650MB的内存。也就是说，序列化1MB的数据，大概需要7.5MB的内存空间。相比于之前的第一种JsonSerializer方法，这里减少了接近一半的内存消耗。同样的，来看看这个方法的几个过程：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150777032621918.png" alt="20171012150777032621918.png"/><figcaption>20171012150777032621918.png</figcaption></figure></p>

<p>这里的序列化过程主要有两个阶段，相比于之前的<code>JSONSerializer</code>的序列化过程，这里没有了转化为JSONElement的过程，也就完成了内存消耗的减少。</p>

<h3 id="toc_36">第3部分 TypeAdapter的流式处理</h3>

<p>下面的代码，我们使用上面同样的TypeAdapter，只不过我们直接在main()方法中修改Gson的用法，以流的形式进行输出。</p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part3;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final File dir = new File(&quot;target/part3&quot;);
    dir.mkdirs();

    try (BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(dir,
        &quot;output.json&quot;)), &quot;UTF-8&quot;))) {
      gson.toJson(data, out);
    }

    System.out.println(&quot;Done&quot;);
  }
}
</code></pre>

<p>这个例子同样是将java对象转化为JSON字符串并且输出，也来看看下面的性能分析图表：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150777036368764.png" alt="20171012150777036368764.png"/><figcaption>20171012150777036368764.png</figcaption></figure></p>

<p>可以看到的是同样的最初产生的数据是89MB,序列化过程将java对象转化为JSON字符串花了大概三秒钟的时间，消耗大概160MB的内存。也就是说序列化1MB的数据我们需要大概2MB的内存空间。相比于之前的两种方法，有了很大的改进。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150777037225976.png" alt="20171012150777037225976.png"/><figcaption>20171012150777037225976.png</figcaption></figure></p>

<p>这个方法同样的是使用了两个阶段。不过在上面一个示例中的绿色方块部分在这里没有使用，这里直接完成了java对象到IO 缓冲区的转化并写入文件。<br/>
虽然这里并不是Gson的关系，但是我们使用Gson的方法极大的减少了内存消耗，所以说在使用开源库的时候，能够正确高效的使用API也显得尤为重要。</p>

<h3 id="toc_37">第4部分 JsonSerializer 的流式处理</h3>

<p>同样的使用第一个例子中的JsonSerializer，这里的配置需要注意的是<code>gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser());</code></p>

<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part4;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final File dir = new File(&quot;target/part4&quot;);
    dir.mkdirs();

    try (BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(dir,
        &quot;output.json&quot;)), &quot;UTF-8&quot;))) {
      gson.toJson(data, out);
    }

    System.out.println(&quot;Done&quot;);
  }
}
</code></pre>

<p>经过前面的分析，我们这里也可以这道这里主要分为三个阶段，下面提供性能分析图和JSONSerializer的阶段流程图：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150777041919731.png" alt="20171012150777041919731.png"/><figcaption>20171012150777041919731.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171012150777042722167.png" alt="20171012150777042722167.png"/><figcaption>20171012150777042722167.png</figcaption></figure></p>

<p>这里可以看到三个阶段完成的工作消耗了11s的时间，730MB的内存空间。也就是说1：8的比例。可以相比上面的例子，知道这里使用JSONSerializer产生了JSONElement对象消耗了很多的内存。</p>

<h3 id="toc_38">结论</h3>

<p>在上面的分析过程中，我们采用了GSON的两种不同的方然完成了序列化一个大数据的过程，并且比较了不同的方法之间的差异。上面的第三种方法（TypeAdapter的流式处理）被论证为最合适的，消耗最少内存的一种方法。<br/><br/>
Gson主要分成两部分,一个就是数据拆解,一个是数据封装。</p>

<h2 id="toc_39">参考</h2>

<p><a href="http://www.jianshu.com/p/e740196225a4"> 你真的会用Gson吗?Gson使用指南（一）</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_6.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_8.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15580646892750.html">发布Android库至JCenter仓库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576631048737.html">单例模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576630121534.html">23种设计模式全面解析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873148.html">Android RecyclerView性能优化</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873102.html">Android 基础复习</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
