<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  RecyclerView 源码解析流程 - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>RecyclerView 源码解析流程</h1>
     
        <div class="read-more clearfix">
          <span class="date">2020/07/20</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Android.html'>Android</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <h2 id="toc_0">主要方法</h2>

<h3 id="toc_1">构造函数</h3>

<ul>
<li>进行View相关配置属性设置，触摸范围、滑动速度等</li>
<li>设置Item动画监听器</li>
<li>初始化AdapterManager，创建AdapterHelper（负责Adapter里的数据集发生变化时的预处理操作）</li>
<li>初始化ChildHelper（负责管理和访问 RecyclerView 的子视图）</li>
<li>如果配置了LayoutManager 则通过反射方法创建它</li>
</ul>

<span id="more"></span><!-- more -->

<pre class="line-numbers"><code class="language-java">    public RecyclerView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        //设置为滚动容器
        setScrollContainer(true);
        setFocusableInTouchMode(true);

        //View配置相关属性设置
        final ViewConfiguration vc = ViewConfiguration.get(context);
        mTouchSlop = vc.getScaledTouchSlop();
        mScaledHorizontalScrollFactor =
                ViewConfigurationCompat.getScaledHorizontalScrollFactor(vc, context);
        mScaledVerticalScrollFactor =
                ViewConfigurationCompat.getScaledVerticalScrollFactor(vc, context);
        mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
        mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
        setWillNotDraw(getOverScrollMode() == View.OVER_SCROLL_NEVER);

        // 设置Item动画监听器
        mItemAnimator.setListener(mItemAnimatorListener);
        // 设置 AdapterManager
        initAdapterManager();
        // 设置 ChildrenHelper 
        initChildrenHelper();
        initAutofill();
        // If not explicitly specified this view is important for accessibility.
        // 硬件加速相关属性设置
        if (ViewCompat.getImportantForAccessibility(this)
                == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            ViewCompat.setImportantForAccessibility(this,
                    ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        mAccessibilityManager = (AccessibilityManager) getContext()
                .getSystemService(Context.ACCESSIBILITY_SERVICE);
        setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));

        //初始化attrs
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,
                defStyleAttr, 0);
        if (Build.VERSION.SDK_INT &gt;= 29) {
            saveAttributeDataForStyleable(context, R.styleable.RecyclerView, attrs, a,
                    defStyleAttr, 0);
        }
        String layoutManagerName = a.getString(R.styleable.RecyclerView_layoutManager);
        int descendantFocusability = a.getInt(
                R.styleable.RecyclerView_android_descendantFocusability, -1);
        if (descendantFocusability == -1) {
            setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
        }
        mClipToPadding = a.getBoolean(R.styleable.RecyclerView_android_clipToPadding, true);
        mEnableFastScroller = a.getBoolean(R.styleable.RecyclerView_fastScrollEnabled, false);
        if (mEnableFastScroller) {
            StateListDrawable verticalThumbDrawable = (StateListDrawable) a
                    .getDrawable(R.styleable.RecyclerView_fastScrollVerticalThumbDrawable);
            Drawable verticalTrackDrawable = a
                    .getDrawable(R.styleable.RecyclerView_fastScrollVerticalTrackDrawable);
            StateListDrawable horizontalThumbDrawable = (StateListDrawable) a
                    .getDrawable(R.styleable.RecyclerView_fastScrollHorizontalThumbDrawable);
            Drawable horizontalTrackDrawable = a
                    .getDrawable(R.styleable.RecyclerView_fastScrollHorizontalTrackDrawable);
            initFastScroller(verticalThumbDrawable, verticalTrackDrawable,
                    horizontalThumbDrawable, horizontalTrackDrawable);
        }
        a.recycle();

        // 反射方法创建 LayoutManager
        // Create the layoutManager if specified.
        createLayoutManager(context, layoutManagerName, attrs, defStyleAttr, 0);

        boolean nestedScrollingEnabled = true;
        if (Build.VERSION.SDK_INT &gt;= 21) {
            // SDK &gt;=21下 ，nestedScrollingEnabled状态支持变更
            a = context.obtainStyledAttributes(attrs, NESTED_SCROLLING_ATTRS,
                    defStyleAttr, 0);
            if (Build.VERSION.SDK_INT &gt;= 29) {
                saveAttributeDataForStyleable(
                        context, NESTED_SCROLLING_ATTRS, attrs, a, defStyleAttr, 0);
            }
            nestedScrollingEnabled = a.getBoolean(0, true);
            a.recycle();
        }
        // 重置nestedScrollingEnabled状态 SDK 21以下默认true
        setNestedScrollingEnabled(nestedScrollingEnabled);
    }
</code></pre>

<h3 id="toc_2">setLayoutManager</h3>

<ul>
<li>处理重新设置一个新的LayoutManager的一些逻辑</li>
<li>设置this给到LayoutManager，并如果attach了则执行LayoutManger的attach分发实践</li>
<li>更新缓存大小，并请求重新布局</li>
</ul>

<pre class="line-numbers"><code class="language-java">    public void setLayoutManager(@Nullable LayoutManager layout) {
        //过滤LayoutManager
        if (layout == mLayout) {
            return;
        }
        //停止滚动
        stopScroll();
        
        //mLayout有值，则进行mLayout的解除关联、销毁操作
        if (mLayout != null) {
            // end all running animations
            if (mItemAnimator != null) {
                mItemAnimator.endAnimations();
            }
            mLayout.removeAndRecycleAllViews(mRecycler);
            mLayout.removeAndRecycleScrapInt(mRecycler);
            mRecycler.clear();

            if (mIsAttached) {
                mLayout.dispatchDetachedFromWindow(this, mRecycler);
            }
            mLayout.setRecyclerView(null);
            mLayout = null;
        } else {
            mRecycler.clear();
        }
        // 对有缺陷的item animator一个防御措施
        mChildHelper.removeAllViewsUnfiltered();
        // 重新赋值
        mLayout = layout;
        if (layout != null) {
            //如果layout已经关联一个Recyclerview对象，则抛出异常
            if (layout.mRecyclerView != null) {
                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout
                        + &quot; is already attached to a RecyclerView:&quot;
                        + layout.mRecyclerView.exceptionLabel());
            }
            //LayoutManager关联当前RecyclerView
            mLayout.setRecyclerView(this);
            if (mIsAttached) {
                mLayout.dispatchAttachedToWindow(this);
            }
        }
        
        //重置Recycler的mCachedViews中的ViewHolder，并把其加入RecycledViewPool
        mRecycler.updateViewCacheSize();
        //请求刷新Layout
        requestLayout();
    }
</code></pre>

<h3 id="toc_3">setAdapter</h3>

<ul>
<li>解除frozen状态</li>
<li>设置新的Adapter，并触发一系列监听事件</li>
</ul>

<pre class="line-numbers"><code class="language-java">    public void setAdapter(@Nullable Adapter adapter) {
        // bail out if layout is frozen
        setLayoutFrozen(false);
        setAdapterInternal(adapter, false, true);
        processDataSetCompletelyChanged(false);
        requestLayout();
    }
</code></pre>

<p>setAdapter和swapAdapter实现方法相同，传的参数不同。<br/>
看看setAdapterInternal方法的传参</p>

<ul>
<li>compatibleWithPrevious: 设置为true则表示新的Adapter和老的Adapter使用相同的ViewHolder和itemType(可以避免缓存失效)</li>
<li>removeAndRecycleViews: 如果为true，将会删除并回收所有现有的视图。如果compatibleWithPrevious为false，则忽略此参数。</li>
</ul>

<pre class="line-numbers"><code class="language-java">    private void setAdapterInternal(@Nullable Adapter adapter, boolean compatibleWithPrevious,boolean removeAndRecycleViews) {
        //如果原先Adapter不为null，则解除关联
        if (mAdapter != null) {
            mAdapter.unregisterAdapterDataObserver(mObserver);
            mAdapter.onDetachedFromRecyclerView(this);
        }
        //compatibleWithPrevious为false或者removeAndRecycleViewstruetrue则移除所有View
        if (!compatibleWithPrevious || removeAndRecycleViews) {
            removeAndRecycleViews();
        }
        //AdapterHelper类reset
        mAdapterHelper.reset();
        //重新赋值新的Adapter给mAdapter并建立关联
        final Adapter oldAdapter = mAdapter;
        mAdapter = adapter;
        if (adapter != null) {
            adapter.registerAdapterDataObserver(mObserver);
            adapter.onAttachedToRecyclerView(this);
        }
        //LayoutManager进行Adapter更换
        if (mLayout != null) {
            mLayout.onAdapterChanged(oldAdapter, mAdapter);
        }
        //Recycler进行Adapter更换，并传入compatibleWithPrevious
        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);
        mState.mStructureChanged = true;
    }
</code></pre>

<p><code>processDataSetCompletelyChanged</code>方法 -&gt; <code>markKnownViewsInvalid</code>(将所有已知ViewHolder标志为无效) -&gt; <code>markItemDecorInsetsDirty</code>(将当前的ChildView以及Recycler中的ChildView的mInsetsDirty设置为true)、<code>mRecycler.markKnownViewsInvalid</code>(从Recycler的mCachedViews中的ViewHolder标志位无效) -&gt; <code>recycleAndClearCachedViews</code>(从mCachedViews中的ViewHolder移除添加进RecycledViewPool)</p>

<h2 id="toc_4">扩展方法</h2>

<h3 id="toc_5">addOnChildAttachStateChangeListener、removeOnChildAttachStateChangeListener、clearOnChildAttachStateChangeListeners</h3>

<p>监听子View的添加和释放，官方推荐使用过重的View资源可以在这个监听器里进行释放</p>

<pre class="line-numbers"><code class="language-java">    public interface OnChildAttachStateChangeListener {
        void onChildViewAttachedToWindow(@NonNull View view);

        void onChildViewDetachedFromWindow(@NonNull View view);
    }
</code></pre>

<h3 id="toc_6">setOnFlingListener、getOnFlingListener</h3>

<p>监听RecyclerView的快速滑动的事件，可以获取横向滑动或者纵向滑动的速度，并且可以进行拦截处理。</p>

<pre class="line-numbers"><code class="language-java">    public abstract static class OnFlingListener {
        public abstract boolean onFling(int velocityX, int velocityY);
    }
</code></pre>

<h3 id="toc_7">setRecycledViewPool(@Nullable RecycledViewPool pool)、getRecycledViewPool</h3>

<p>如果有多个相同数据类型的Adapter，可以设置RecycledViewPool共享池。</p>

<h3 id="toc_8">setViewCacheExtension(@Nullable ViewCacheExtension extension)</h3>

<p>自定义ViewCacheExtension</p>

<h3 id="toc_9">setItemViewCacheSize(int size)</h3>

<p>设置加入RecycledViewPool之前可缓存的数量</p>

<h3 id="toc_10">addItemDecoration(@NonNull ItemDecoration decor, int index)、addItemDecoration(@NonNull ItemDecoration decor)、getItemDecorationAt(int index)、getItemDecorationCount()、removeItemDecorationAt(int index)、removeItemDecoration(@NonNull ItemDecoration decor)</h3>

<p>添加ItemDecoration， ItemDecoration有层级关系， index值会影响ItemDecoration所在层级。index为-1，则添加到最后。</p>

<h3 id="toc_11">setChildDrawingOrderCallback(@Nullable ChildDrawingOrderCallback childDrawingOrderCallback)</h3>

<p>可用来更改RecyclerView子项的绘制顺序</p>

<pre class="line-numbers"><code class="language-java">    public interface ChildDrawingOrderCallback {
        int onGetChildDrawingOrder(int childCount, int i);
    }
</code></pre>

<h3 id="toc_12">addOnScrollListener(@NonNull OnScrollListener listener)、removeOnScrollListener(@NonNull OnScrollListener listener)、clearOnScrollListeners()</h3>

<p>用来监听RecyclerView的滚动状态和滚动距离</p>

<pre class="line-numbers"><code class="language-java">    public abstract static class OnScrollListener {
        
        public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState){}

        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy){}
    }
</code></pre>

<h3 id="toc_13">scrollToPosition(int position)</h3>

<p>滚动到指定位置</p>

<h3 id="toc_14">smoothScrollToPosition(int position)</h3>

<p>带动画滚动到指定位置</p>

<h3 id="toc_15">setEdgeEffectFactory(@NonNull EdgeEffectFactory edgeEffectFactory)、getEdgeEffectFactory()</h3>

<p>自定义边界UI</p>

<h3 id="toc_16">addOnItemTouchListener(@NonNull OnItemTouchListener listener)、removeOnItemTouchListener(@NonNull OnItemTouchListener listener)</h3>

<p>处理Item触摸事件</p>

<pre class="line-numbers"><code class="language-java">public interface OnItemTouchListener {
    
        boolean onInterceptTouchEvent(@NonNull RecyclerView rv, @NonNull MotionEvent e);

        void onTouchEvent(@NonNull RecyclerView rv, @NonNull MotionEvent e);

        void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept);
    }
</code></pre>

<h2 id="toc_17">View绘制三大流程</h2>

<h3 id="toc_18">measure</h3>

<pre class="line-numbers"><code class="language-java">    @Override
    protected void onMeasure(int widthSpec, int heightSpec) {
        //第一种情况当前LayoutManager为null
        if (mLayout == null) {
            defaultOnMeasure(widthSpec, heightSpec);
            return;
        }
        //第二种情况LayoutManager开启了自动测量
        if (mLayout.isAutoMeasureEnabled()) {
            final int widthMode = MeasureSpec.getMode(widthSpec);
            final int heightMode = MeasureSpec.getMode(heightSpec);

            //调用LayoutManager的onMeasure方法进行测量。
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);

            final boolean measureSpecModeIsExactly =
                    widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;
            if (measureSpecModeIsExactly || mAdapter == null) {
                return;
            }

            //mLayoutStep为State.STEP_START执行dispatchLayoutStep1
            if (mState.mLayoutStep == State.STEP_START) {
                dispatchLayoutStep1();
            }
            
            mLayout.setMeasureSpecs(widthSpec, heightSpec);
            mState.mIsMeasuring = true;
            //执行dispatchLayoutStep2
            dispatchLayoutStep2();

            // now we can get the width and height from the children.
            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);

            // if RecyclerView has non-exact width and height and if there is at least one child
            // which also has non-exact width &amp; height, we have to re-measure.
            if (mLayout.shouldMeasureTwice()) {
                mLayout.setMeasureSpecs(
                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
                mState.mIsMeasuring = true;
                dispatchLayoutStep2();
                // now we can get the width and height from the children.
                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);
            }
        } else {
            //第三种情况 LayoutManager没有开启自动测量
            if (mHasFixedSize) {
                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
                return;
            }
            // custom onMeasure
            if (mAdapterUpdateDuringMeasure) {
                startInterceptRequestLayout();
                onEnterLayoutOrScroll();
                processAdapterUpdatesAndSetAnimationFlags();
                onExitLayoutOrScroll();

                if (mState.mRunPredictiveAnimations) {
                    mState.mInPreLayout = true;
                } else {
                    // consume remaining updates to provide a consistent state with the layout pass.
                    mAdapterHelper.consumeUpdatesInOnePass();
                    mState.mInPreLayout = false;
                }
                mAdapterUpdateDuringMeasure = false;
                stopInterceptRequestLayout(false);
            } else if (mState.mRunPredictiveAnimations) {
                // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:
                // this means there is already an onMeasure() call performed to handle the pending
                // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout
                // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time
                // because getViewForPosition() will crash when LM uses a child to measure.
                setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());
                return;
            }

            if (mAdapter != null) {
                mState.mItemCount = mAdapter.getItemCount();
            } else {
                mState.mItemCount = 0;
            }
            startInterceptRequestLayout();
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
            stopInterceptRequestLayout(false);
            mState.mInPreLayout = false; // clear
        }
    }
</code></pre>

<h4 id="toc_19">第一种情况</h4>

<p>直接调用defaultOnMeasure方法</p>

<pre class="line-numbers"><code class="language-java">    void defaultOnMeasure(int widthSpec, int heightSpec) {
        // calling LayoutManager here is not pretty but that API is already public and it is better
        // than creating another method since this is internal.
        final int width = LayoutManager.chooseSize(widthSpec,
                getPaddingLeft() + getPaddingRight(),
                ViewCompat.getMinimumWidth(this));
        final int height = LayoutManager.chooseSize(heightSpec,
                getPaddingTop() + getPaddingBottom(),
                ViewCompat.getMinimumHeight(this));

        setMeasuredDimension(width, height);
    }
</code></pre>

<p>直接调用LayoutManager.chooseSize来获取宽高，然后直接setMeasuredDimension</p>

<pre class="line-numbers"><code class="language-java">        //通过RecyclerView的测量mode来获取不同的值
        public static int chooseSize(int spec, int desired, int min) {
            final int mode = View.MeasureSpec.getMode(spec);
            final int size = View.MeasureSpec.getSize(spec);
            switch (mode) {
                case View.MeasureSpec.EXACTLY:
                    return size;
                case View.MeasureSpec.AT_MOST:
                    return Math.min(size, Math.max(desired, min));
                case View.MeasureSpec.UNSPECIFIED:
                default:
                    return Math.max(desired, min);
            }
        }
</code></pre>

<h4 id="toc_20">第二种情况 当LayoutManager开启了自动测量</h4>

<table>
<thead>
<tr>
<th style="text-align: left">取值</th>
<th style="text-align: left">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">State.STEP_START</td>
<td style="text-align: left">mState.mLayoutStep的默认值，这种情况下，表示RecyclerView还未经历dispatchLayoutStep1，因为dispatchLayoutStep1调用之后mState.mLayoutStep会变为State.STEP_LAYOUT。</td>
</tr>
<tr>
<td style="text-align: left">State.STEP_LAYOUT</td>
<td style="text-align: left">当mState.mLayoutStep为State.STEP_LAYOUT时，表示此时处于layout阶段，这个阶段会调用dispatchLayoutStep2方法layout RecyclerView的children。调用dispatchLayoutStep2方法之后，此时mState.mLayoutStep变为了State.STEP_ANIMATIONS。</td>
</tr>
<tr>
<td style="text-align: left">State.STEP_ANIMATIONS</td>
<td style="text-align: left">当mState.mLayoutStep为State.STEP_ANIMATIONS时，表示RecyclerView处于第三个阶段，也就是执行动画的阶段，也就是调用dispatchLayoutStep3方法。当dispatchLayoutStep3方法执行完毕之后，mState.mLayoutStep又变为了State.STEP_START。</td>
</tr>
</tbody>
</table>

<h5 id="toc_21">dispatchLayoutStep1</h5>

<ul>
<li>第一步layout方法</li>
<li>处理adapter变更</li>
<li>确定需要执行的动画</li>
<li>针对当前的Views进行信息缓存</li>
<li>如有必要，则进行预布局并缓存信息</li>
</ul>

<pre class="line-numbers"><code class="language-java">    private void dispatchLayoutStep1() {
        mState.assertLayoutStep(State.STEP_START);
        fillRemainingScrollValues(mState);
        mState.mIsMeasuring = false;
        startInterceptRequestLayout();
        mViewInfoStore.clear();
        onEnterLayoutOrScroll();
        processAdapterUpdatesAndSetAnimationFlags();
        saveFocusInfo();
        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;
        mItemsAddedOrRemoved = mItemsChanged = false;
        mState.mInPreLayout = mState.mRunPredictiveAnimations;
        mState.mItemCount = mAdapter.getItemCount();
        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);

        if (mState.mRunSimpleAnimations) {
            // Step 0: Find out where all non-removed items are, pre-layout
            int count = mChildHelper.getChildCount();
            for (int i = 0; i &lt; count; ++i) {
                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) {
                    continue;
                }
                final ItemHolderInfo animationInfo = mItemAnimator
                        .recordPreLayoutInformation(mState, holder,
                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),
                                holder.getUnmodifiedPayloads());
                mViewInfoStore.addToPreLayout(holder, animationInfo);
                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()
                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) {
                    long key = getChangedHolderKey(holder);
                    // This is NOT the only place where a ViewHolder is added to old change holders
                    // list. There is another case where:
                    //    * A VH is currently hidden but not deleted
                    //    * The hidden item is changed in the adapter
                    //    * Layout manager decides to layout the item in the pre-Layout pass (step1)
                    // When this case is detected, RV will un-hide that view and add to the old
                    // change holders list.
                    mViewInfoStore.addToOldChangeHolders(key, holder);
                }
            }
        }
        if (mState.mRunPredictiveAnimations) {
            // Step 1: run prelayout: This will use the old positions of items. The layout manager
            // is expected to layout everything, even removed items (though not to add removed
            // items back to the container). This gives the pre-layout position of APPEARING views
            // which come into existence as part of the real layout.

            // Save old positions so that LayoutManager can run its mapping logic.
            saveOldPositions();
            final boolean didStructureChange = mState.mStructureChanged;
            mState.mStructureChanged = false;
            // temporarily disable flag because we are asking for previous layout
            mLayout.onLayoutChildren(mRecycler, mState);
            mState.mStructureChanged = didStructureChange;

            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) {
                final View child = mChildHelper.getChildAt(i);
                final ViewHolder viewHolder = getChildViewHolderInt(child);
                if (viewHolder.shouldIgnore()) {
                    continue;
                }
                if (!mViewInfoStore.isInPreLayout(viewHolder)) {
                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);
                    boolean wasHidden = viewHolder
                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                    if (!wasHidden) {
                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                    }
                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(
                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());
                    if (wasHidden) {
                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);
                    } else {
                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);
                    }
                }
            }
            // we don&#39;t process disappearing list because they may re-appear in post layout pass.
            clearOldPositions();
        } else {
            clearOldPositions();
        }
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(false);
        mState.mLayoutStep = State.STEP_LAYOUT;
    }
</code></pre>

<pre class="line-numbers"><code class="language-java">    private void processAdapterUpdatesAndSetAnimationFlags() {
        if (mDataSetHasChangedAfterLayout) {
            // Processing these items have no value since data set changed unexpectedly.
            // Instead, we just reset it.
            mAdapterHelper.reset();
            if (mDispatchItemsChangedEvent) {
                mLayout.onItemsChanged(this);
            }
        }
        // simple animations are a subset of advanced animations (which will cause a
        // pre-layout step)
        // If layout supports predictive animations, pre-process to decide if we want to run them
        if (predictiveItemAnimationsEnabled()) {
            mAdapterHelper.preProcess();
        } else {
            mAdapterHelper.consumeUpdatesInOnePass();
        }
        boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged;
        //判断是否是第一次加载布局
        mState.mRunSimpleAnimations = mFirstLayoutComplete
                &amp;&amp; mItemAnimator != null
                &amp;&amp; (mDataSetHasChangedAfterLayout
                || animationTypeSupported
                || mLayout.mRequestedSimpleAnimations)
                &amp;&amp; (!mDataSetHasChangedAfterLayout
                || mAdapter.hasStableIds());
        mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations
                &amp;&amp; animationTypeSupported
                &amp;&amp; !mDataSetHasChangedAfterLayout
                &amp;&amp; predictiveItemAnimationsEnabled();
    }
</code></pre>

<h5 id="toc_22">dispatchLayoutStep2</h5>

<pre class="line-numbers"><code class="language-java">    private void dispatchLayoutStep2() {
        startInterceptRequestLayout();
        onEnterLayoutOrScroll();
        mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);
        mAdapterHelper.consumeUpdatesInOnePass();
        mState.mItemCount = mAdapter.getItemCount();
        mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;

        mState.mInPreLayout = false;
        //调用LayoutManager的onLayoutChildren对children进行测量和布局
        mLayout.onLayoutChildren(mRecycler, mState);

        mState.mStructureChanged = false;
        mPendingSavedState = null;

        // onLayoutChildren may have caused client code to disable item animations; re-check
        mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null;
        //设置mLayoutStep为State.STEP_ANIMATIONS
        mState.mLayoutStep = State.STEP_ANIMATIONS;
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(false);
    }
</code></pre>

<h4 id="toc_23">没有开启自动测量</h4>

<ul>
<li>如果mHasFixedSize为true(也就是调用了setHasFixedSize方法)，将直接调用LayoutManager的onMeasure方法进行测量。</li>
<li>如果mHasFixedSize为false，同时此时如果有数据更新，先处理数据更新的事务，然后调用LayoutManager的onMeasure方法进行测量</li>
</ul>

<h3 id="toc_24">layout</h3>

<pre class="line-numbers"><code class="language-java">    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);
        dispatchLayout();
        TraceCompat.endSection();
        mFirstLayoutComplete = true;
    }
</code></pre>

<h4 id="toc_25">dispatchLayout</h4>

<p>这个方法保证RecyclerView必须经历三个过程--dispatchLayoutStep1、dispatchLayoutStep2、dispatchLayoutStep3。</p>

<pre class="line-numbers"><code class="language-java">    void dispatchLayout() {
        //这边如果mAdapter为null，就不进行展示了
        if (mAdapter == null) {
            Log.e(TAG, &quot;No adapter attached; skipping layout&quot;);
            // leave the state in START
            return;
        }
        //这边如果mLayout为null，就不进行展示了
        if (mLayout == null) {
            Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;);
            // leave the state in START
            return;
        }
        //更改mState.mIsMeasuring
        mState.mIsMeasuring = false;
        //如果mState.mLayoutStep为State.STEP_START再次调用dispatchLayoutStep1和dispatchLayoutStep2
        if (mState.mLayoutStep == State.STEP_START) {
            dispatchLayoutStep1();
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()
                || mLayout.getHeight() != getHeight()) {
            // First 2 steps are done in onMeasure but looks like we have to run again due to
            // changed size.
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else {
            // always make sure we sync them (to ensure mode is exact)
            mLayout.setExactMeasureSpecsFrom(this);
        }
        //执行dispatchLayoutStep3
        dispatchLayoutStep3();
    }
</code></pre>

<h4 id="toc_26">dispatchLayoutStep3</h4>

<p>这是最后一步</p>

<pre class="line-numbers"><code class="language-java">    private void dispatchLayoutStep3() {
        mState.assertLayoutStep(State.STEP_ANIMATIONS);
        startInterceptRequestLayout();
        onEnterLayoutOrScroll();
        //重新将mState.mLayoutStep的值赋值为State.STEP_START，保证下次dispatchLayout继续走3步
        mState.mLayoutStep = State.STEP_START;
        if (mState.mRunSimpleAnimations) {
            // Step 3: Find out where things are now, and process change animations.
            // traverse list in reverse because we may call animateChange in the loop which may
            // remove the target view holder.
            for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) {
                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
                if (holder.shouldIgnore()) {
                    continue;
                }
                long key = getChangedHolderKey(holder);
                final ItemHolderInfo animationInfo = mItemAnimator
                        .recordPostLayoutInformation(mState, holder);
                ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);
                if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) {
                    // run a change animation

                    // If an Item is CHANGED but the updated version is disappearing, it creates
                    // a conflicting case.
                    // Since a view that is marked as disappearing is likely to be going out of
                    // bounds, we run a change animation. Both views will be cleaned automatically
                    // once their animations finish.
                    // On the other hand, if it is the same view holder instance, we run a
                    // disappearing animation instead because we are not going to rebind the updated
                    // VH unless it is enforced by the layout manager.
                    final boolean oldDisappearing = mViewInfoStore.isDisappearing(
                            oldChangeViewHolder);
                    final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);
                    if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) {
                        // run disappear animation instead of change
                        mViewInfoStore.addToPostLayout(holder, animationInfo);
                    } else {
                        //ItemHolderInfo中保存ItemView的位置信息
                        final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(
                                oldChangeViewHolder);
                        // we add and remove so that any post info is merged.
                        mViewInfoStore.addToPostLayout(holder, animationInfo);
                        ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);
                        if (preInfo == null) {
                            handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);
                        } else {
                            animateChange(oldChangeViewHolder, holder, preInfo, postInfo,
                                    oldDisappearing, newDisappearing);
                        }
                    }
                } else {
                    mViewInfoStore.addToPostLayout(holder, animationInfo);
                }
            }

            // 执行动画
            // Step 4: Process view info lists and trigger animations
            mViewInfoStore.process(mViewInfoProcessCallback);
        }

        mLayout.removeAndRecycleScrapInt(mRecycler);
        mState.mPreviousLayoutItemCount = mState.mItemCount;
        mDataSetHasChangedAfterLayout = false;
        mDispatchItemsChangedEvent = false;
        mState.mRunSimpleAnimations = false;

        mState.mRunPredictiveAnimations = false;
        mLayout.mRequestedSimpleAnimations = false;
        if (mRecycler.mChangedScrap != null) {
            mRecycler.mChangedScrap.clear();
        }
        if (mLayout.mPrefetchMaxObservedInInitialPrefetch) {
            // Initial prefetch has expanded cache, so reset until next prefetch.
            // This prevents initial prefetches from expanding the cache permanently.
            mLayout.mPrefetchMaxCountObserved = 0;
            mLayout.mPrefetchMaxObservedInInitialPrefetch = false;
            mRecycler.updateViewCacheSize();
        }

        mLayout.onLayoutCompleted(mState);
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(false);
        mViewInfoStore.clear();
        if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) {
            dispatchOnScrolled(0, 0);
        }
        recoverFocusFromState();
        resetFocusInfo();
    }
</code></pre>

<p>RecyclerView跟其他ViewGroup不同的地方在于，如果开启了自动测量，在measure阶段，已经将Children布局完成了；如果没有开启自动测量，则在layout阶段才布局Children</p>

<h3 id="toc_27">在LayoutManager中的绘制</h3>

<h4 id="toc_28">LinearLayoutManager#onLayoutChildren</h4>

<pre class="line-numbers"><code class="language-java">@Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // ...
        // 找到锚点（具体过程等到分析 layout 时再说）
        // （1）
        detachAndScrapAttachedViews(recycler);
        
        if (mAnchorInfo.mLayoutFromEnd) {
            // ...
        } else {
            // （2）
            fill(recycler, mLayoutState, state, false);
            // ...
        }   
        // ...
    }
</code></pre>

<p>首先看（1）处，detachAndScrapAttachedViews 方法会根据情况将子 View 回收到相应缓存，具体过程之后再看，由于现在是第一次 layout，RecyclerView 中没有子 View，所以现在该方法没啥用。</p>

<p>接下来看（2）处，这里的 fill 方法比较重要，它的作用是填充布局。看一下该方法</p>

<h4 id="toc_29">LinearLayoutManager#fill</h4>

<pre class="line-numbers"><code class="language-java">    int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {

        // 进行 layout 时 layoutState.mScrollingOffset 的值被设置为
        // LayoutState.SCROLLING_OFFSET_NaN，不会进入此 if 块
        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            // ...
            recycleByLayoutState(recycler, layoutState);
        }
        
        // 需要填充的空间
        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
        // 还有需要填充的空间并且 item 数未满
        while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) {
            // ...
            
            // （1）
            layoutChunk(recycler, state, layoutState, layoutChunkResult);

            // 计算剩余空间

            // 同上，在 layout 时不会进入 if 块中
            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
                // ...
                recycleByLayoutState(recycler, layoutState);
            }
            
            // ...
        }
    }
</code></pre>

<h4 id="toc_30">LinearLayoutManager#layoutChunk</h4>

<pre class="line-numbers"><code class="language-java">    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
            LayoutState layoutState, LayoutChunkResult result) {
        // （1）
        View view = layoutState.next(recycler);

        // ...
        
        // 默认情况下，layoutState.mScrapList 等于 null
        if (layoutState.mScrapList == null) {
            if (mShouldReverseLayout == (layoutState.mLayoutDirection
                    == LayoutState.LAYOUT_START)) {
                // （2）
                addView(view);
            } else {
                addView(view, 0);
            }
        } else {
            // ...
        }
    }
</code></pre>

<p>（2）处的 addView 方法就不多说了，该方法将得到的子 View 添加到 RecyclerView 中。主要看（1）处，看看子 View 从何而来</p>

<pre class="line-numbers"><code class="language-java">    View next(RecyclerView.Recycler recycler) {
        // ...
        
        final View view = recycler.getViewForPosition(mCurrentPosition);

        return view;
    }
</code></pre>

<p>这个方法是不是很熟悉呢？没错，它就是之前分析的 Recycler 的 getViewForPosition 方法。</p>

<p>不过由于现在没有任何缓存，所以第一次 layout 的时候是通过 Adapter 的 createViewHolder 来创建子 View的，并且没有添加任何缓存。</p>

<h3 id="toc_31">draw</h3>

<ul>
<li>调用super.draw方法。这里主要做了两件事：
<ul>
<li>将Children的绘制分发给ViewGroup;</li>
<li>将分割线的绘制分发给ItemDecoration。</li>
</ul></li>
<li>如果需要的话，调用ItemDecoration的onDrawOver方法。通过这个方法，我们在每个ItemView上面画上很多东西。</li>
<li>如果RecyclerView调用了setClipToPadding,会实现一种特殊的滑动效果--每个ItemView可以滑动到padding区域。</li>
</ul>

<pre class="line-numbers"><code class="language-java">    @Override
    public void draw(Canvas c) {
        //第一步
        super.draw(c);

        //第二步
        final int count = mItemDecorations.size();
        for (int i = 0; i &lt; count; i++) {
            mItemDecorations.get(i).onDrawOver(c, this, mState);
        }
        // 第三步
        // TODO If padding is not 0 and clipChildrenToPadding is false, to draw glows properly, we
        // need find children closest to edges. Not sure if it is worth the effort.
        boolean needsInvalidate = false;
        if (mLeftGlow != null &amp;&amp; !mLeftGlow.isFinished()) {
            final int restore = c.save();
            final int padding = mClipToPadding ? getPaddingBottom() : 0;
            c.rotate(270);
            c.translate(-getHeight() + padding, 0);
            needsInvalidate = mLeftGlow != null &amp;&amp; mLeftGlow.draw(c);
            c.restoreToCount(restore);
        }
        if (mTopGlow != null &amp;&amp; !mTopGlow.isFinished()) {
            final int restore = c.save();
            if (mClipToPadding) {
                c.translate(getPaddingLeft(), getPaddingTop());
            }
            needsInvalidate |= mTopGlow != null &amp;&amp; mTopGlow.draw(c);
            c.restoreToCount(restore);
        }
        if (mRightGlow != null &amp;&amp; !mRightGlow.isFinished()) {
            final int restore = c.save();
            final int width = getWidth();
            final int padding = mClipToPadding ? getPaddingTop() : 0;
            c.rotate(90);
            c.translate(-padding, -width);
            needsInvalidate |= mRightGlow != null &amp;&amp; mRightGlow.draw(c);
            c.restoreToCount(restore);
        }
        if (mBottomGlow != null &amp;&amp; !mBottomGlow.isFinished()) {
            final int restore = c.save();
            c.rotate(180);
            if (mClipToPadding) {
                c.translate(-getWidth() + getPaddingRight(), -getHeight() + getPaddingBottom());
            } else {
                c.translate(-getWidth(), -getHeight());
            }
            needsInvalidate |= mBottomGlow != null &amp;&amp; mBottomGlow.draw(c);
            c.restoreToCount(restore);
        }

        // If some views are animating, ItemDecorators are likely to move/change with them.
        // Invalidate RecyclerView to re-draw decorators. This is still efficient because children&#39;s
        // display lists are not invalidated.
        if (!needsInvalidate &amp;&amp; mItemAnimator != null &amp;&amp; mItemDecorations.size() &gt; 0
                &amp;&amp; mItemAnimator.isRunning()) {
            needsInvalidate = true;
        }

        if (needsInvalidate) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }
</code></pre>

<p>关于Children的绘制和ItemDecoration的绘制，是在onDraw方法里面</p>

<pre class="line-numbers"><code class="language-java">    @Override
    public void onDraw(Canvas c) {
        super.onDraw(c);

        final int count = mItemDecorations.size();
        for (int i = 0; i &lt; count; i++) {
            mItemDecorations.get(i).onDraw(c, this, mState);
        }
    }
</code></pre>

<h2 id="toc_32">缓存机制</h2>

<h3 id="toc_33">四级缓存</h3>

<table>
<thead>
<tr>
<th style="text-align: left">缓存级别</th>
<th style="text-align: left">实际变量</th>
<th style="text-align: left">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">一级缓存</td>
<td style="text-align: left">mAttachedScrap和mChangedScrap</td>
<td style="text-align: left">这是优先级最高的缓存，RecyclerView在获取ViewHolder时,优先会到这两个缓存来找。其中mAttachedScrap存储的是当前还在屏幕中的ViewHolder，mChangedScrap存储的是数据被更新的ViewHolder,比如说调用了Adapter的notifyItemChanged方法。</td>
</tr>
<tr>
<td style="text-align: left">二级缓存</td>
<td style="text-align: left">mCachedViews</td>
<td style="text-align: left">默认大小为2，通常用来存储预取的ViewHolder，同时在回收ViewHolder时，也会可能存储一部分的ViewHolder，这部分的ViewHolder通常来说，意义跟一级缓存差不多。</td>
</tr>
<tr>
<td style="text-align: left">三级缓存</td>
<td style="text-align: left">ViewCacheExtension</td>
<td style="text-align: left">自定义缓存,通常用不到，在本文中先忽略</td>
</tr>
<tr>
<td style="text-align: left">四级缓存</td>
<td style="text-align: left">RecyclerViewPool</td>
<td style="text-align: left">根据ViewType来缓存ViewHolder，每个ViewType的数组大小为5，可以动态的改变。</td>
</tr>
</tbody>
</table>

<h3 id="toc_34">ViewHolder的几个状态值</h3>

<table>
<thead>
<tr>
<th style="text-align: left">方法名</th>
<th style="text-align: left">对应的Flag</th>
<th style="text-align: left">含义或者状态设置的时机</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">isInvalid</td>
<td style="text-align: left">FLAG_INVALID</td>
<td style="text-align: left">表示当前ViewHolder是否已经失效。通常来说，在3种情况下会出现这种情况：1.调用了Adapter的notifyDataSetChanged方法；2. 手动调用RecyclerView的invalidateItemDecorations方法；3. 调用RecyclerView的setAdapter方法或者swapAdapter方法。</td>
</tr>
<tr>
<td style="text-align: left">isRemoved</td>
<td style="text-align: left">FLAG_REMOVED</td>
<td style="text-align: left">表示当前的ViewHolder是否被移除。通常来说，数据源被移除了部分数据，然后调用Adapter的notifyItemRemoved方法。</td>
</tr>
<tr>
<td style="text-align: left">isBound</td>
<td style="text-align: left">FLAG_BOUND</td>
<td style="text-align: left">表示当前ViewHolder是否已经调用了onBindViewHolder。</td>
</tr>
<tr>
<td style="text-align: left">isTmpDetached</td>
<td style="text-align: left">FLAG_TMP_DETACHED</td>
<td style="text-align: left">表示当前的ItemView是否从RecyclerView(即父View)detach掉。通常来说有两种情况下会出现这种情况：1.手动了RecyclerView的detachView相关方法；2. 在从mHideViews里面获取ViewHolder,会先detach掉这个ViewHolder关联的ItemView。这里又多出来一个mHideViews，待会我会详细的解释它是什么。</td>
</tr>
<tr>
<td style="text-align: left">isScrap</td>
<td style="text-align: left">无Flag来表示该状态，用mScrapContainer是否为null来判断</td>
<td style="text-align: left">表示是否在mAttachedScrap或者mChangedScrap数组里面，进而表示当前ViewHolder是否被废弃。</td>
</tr>
<tr>
<td style="text-align: left">isUpdated</td>
<td style="text-align: left">FLAG_UPDATE</td>
<td style="text-align: left">表示当前ViewHolder是否已经更新。通常来说，在3种情况下会出现情况：1.isInvalid方法存在的三种情况；2.调用了Adapter的onBindViewHolder方法；3. 调用了Adapter的notifyItemChanged方法</td>
</tr>
</tbody>
</table>

<h3 id="toc_35">mChangedScrap和mAttachedScrap的区别</h3>

<p>首先，如果调用了Adapter的notifyItemChanged方法，会重新回调到LayoutManager的onLayoutChildren方法里面,而在onLayoutChildren方法里面，会将屏幕上所有的ViewHolder回收到mAttachedScrap和mChangedScrap。这个过程就是将ViewHolder分别放到mAttachedScrap和mChangedScrap，而什么条件下放在mAttachedScrap，什么条件放在mChangedScrap，这个就是他们俩的区别。</p>

<pre class="line-numbers"><code class="language-java">    void scrapView(View view) {
            final ViewHolder holder = getChildViewHolderInt(view);
            //1.被同时标记为remove或invalid；2.完全没有改变的ViewHolder。这里还有第三个判断，这个跟RecyclerView的ItemAnimator有关，如果ItemAnimator为空或者ItemAnimator的canReuseUpdatedViewHolder方法为true，也会放入到mAttachedScrap。
            if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
                    || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
                if (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) {
                    throw new IllegalArgumentException(&quot;Called scrap view with an invalid view.&quot;
                            + &quot; Invalid views cannot be reused from scrap, they should rebound from&quot;
                            + &quot; recycler pool.&quot; + exceptionLabel());
                }
                holder.setScrapContainer(this, false);
                mAttachedScrap.add(holder);
            } else {
                //ViewHolder的isUpdated方法返回为true时，会放入到mChangedScrap里面去。
                if (mChangedScrap == null) {
                    mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
                }
                holder.setScrapContainer(this, true);
                mChangedScrap.add(holder);
            }
        }
</code></pre>

<h3 id="toc_36">复用</h3>

<p>RecyclerView对ViewHolder的复用，我们得从LayoutState的next方法开始。LayoutManager在布局itemView时，需要获取一个ViewHolder对象，就是通过这个方法来获取，具体的复用逻辑也是在这个方面开始调用的。</p>

<pre class="line-numbers"><code class="language-java">    View next(RecyclerView.Recycler recycler) {
        final View view = recycler.getViewForPosition(mCurrentPosition);
        mCurrentPosition += mItemDirection;
        return view;
    }
</code></pre>

<p>再来看Recycler的getViewForPosition</p>

<pre class="line-numbers"><code class="language-java">    View getViewForPosition(int position, boolean dryRun) {
        return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;
    }
</code></pre>

<p>最后走到tryGetViewHolderForPositionByDeadline这个方法，RecyclerView真正复用的核心就在这个方法</p>

<pre class="line-numbers"><code class="language-java">        @Nullable
        ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
            //position和mState.getItemCount对不上就会抛出异常
            if (position &lt; 0 || position &gt;= mState.getItemCount()) {
                throw new IndexOutOfBoundsException(&quot;Invalid item position &quot; + position
                        + &quot;(&quot; + position + &quot;). Item count:&quot; + mState.getItemCount()
                        + exceptionLabel());
            }
            boolean fromScrapOrHiddenOrCache = false;
            ViewHolder holder = null;
            // 0) If there is a changed scrap, try to find from there
            //如果当前是预布局阶段，那么就从mChangedScrap里面去获取ViewHolder
            if (mState.isPreLayout()) {
                holder = getChangedScrapViewForPosition(position);
                fromScrapOrHiddenOrCache = holder != null;
            }
            // 1) Find by position from scrap/hidden list/cache
            //如果holder为null，分别从mAttachedScrap、 mHiddenViews、mCachedViews获取ViewHolder
            if (holder == null) {
                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
                if (holder != null) {
                    //检查ViewHolder是否有效
                    if (!validateViewHolderForOffsetPosition(holder)) {
                        // recycle holder (and unscrap if relevant) since it can&#39;t be used
                        //做一些清理操作，然后重新放入到缓存里面
                        if (!dryRun) {
                            // we would like to recycle this but need to make sure it is not used by
                            // animation logic etc.
                            holder.addFlags(ViewHolder.FLAG_INVALID);
                            if (holder.isScrap()) {
                                removeDetachedView(holder.itemView, false);
                                holder.unScrap();
                            } else if (holder.wasReturnedFromScrap()) {
                                holder.clearReturnedFromScrapFlag();
                            }
                            //做回收操作
                            recycleViewHolderInternal(holder);
                        }
                        holder = null;
                    } else {
                        fromScrapOrHiddenOrCache = true;
                    }
                }
            }
            
            //1. 如果Adapter的hasStableIds方法返回为true，优先通过ViewType和id两个条件来寻找。如果没有找到，那么就进行第2步。
            //2. 如果Adapter的hasStableIds方法返回为false，在这种情况下，首先会在ViewCacheExtension里面找，如果还没有找到的话，最后会在RecyclerViewPool里面来获取ViewHolder。
            //3. 如果以上的复用步骤都没有找到合适的ViewHolder，最后就会调用Adapter的onCreateViewHolder方法来创建一个新的ViewHolder。
            if (holder == null) {
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                //校验offsetPosition
                if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) {
                    throw new IndexOutOfBoundsException(&quot;Inconsistency detected. Invalid item &quot;
                            + &quot;position &quot; + position + &quot;(offset:&quot; + offsetPosition + &quot;).&quot;
                            + &quot;state:&quot; + mState.getItemCount() + exceptionLabel());
                }

                final int type = mAdapter.getItemViewType(offsetPosition);
                // 2) Find from scrap/cache via stable ids, if exists
                //通过ViewType和Id来查找
                if (mAdapter.hasStableIds()) {
                    //分别从mAttachedScrap和mCachedViews数组寻找合适的ViewHolder
                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                            type, dryRun);
                    if (holder != null) {
                        // update position
                        holder.mPosition = offsetPosition;
                        fromScrapOrHiddenOrCache = true;
                    }
                }
                //如果存在ViewCacheExtension，则从ViewCacheExtension中查找                这个玩意需要用户自定义，很少使用
                if (holder == null &amp;&amp; mViewCacheExtension != null) {
                    // We are NOT sending the offsetPosition because LayoutManager does not
                    // know it.
                    final View view = mViewCacheExtension
                            .getViewForPositionAndType(this, position, type);
                    if (view != null) {
                        holder = getChildViewHolder(view);
                        if (holder == null) {
                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;
                                    + &quot; a view which does not have a ViewHolder&quot;
                                    + exceptionLabel());
                        } else if (holder.shouldIgnore()) {
                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;
                                    + &quot; a view that is ignored. You must call stopIgnoring before&quot;
                                    + &quot; returning this view.&quot; + exceptionLabel());
                        }
                    }
                }
                //还没找到再到RecycledViewPool中进行查找
                if (holder == null) { // fallback to pool
                    if (DEBUG) {
                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline(&quot;
                                + position + &quot;) fetching from shared pool&quot;);
                    }
                    holder = getRecycledViewPool().getRecycledView(type);
                    if (holder != null) {
                        holder.resetInternal();
                        if (FORCE_INVALIDATE_DISPLAY_LIST) {
                            invalidateDisplayListInt(holder);
                        }
                    }
                }
                //实在没有只能通过createViewHolder进行创建
                if (holder == null) {
                    long start = getNanoTime();
                    if (deadlineNs != FOREVER_NS
                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) {
                        // abort - we have a deadline we can&#39;t meet
                        return null;
                    }
                    holder = mAdapter.createViewHolder(RecyclerView.this, type);
                    if (ALLOW_THREAD_GAP_WORK) {
                        // only bother finding nested RV if prefetching
                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);
                        if (innerView != null) {
                            holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);
                        }
                    }

                    long end = getNanoTime();
                    mRecyclerPool.factorInCreateTime(type, end - start);
                    if (DEBUG) {
                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;);
                    }
                }
            }

            // This is very ugly but the only place we can grab this information
            // before the View is rebound and returned to the LayoutManager for post layout ops.
            // We don&#39;t need this in pre-layout since the VH is not updated by the LM.
            if (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder
                    .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) {
                holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                if (mState.mRunSimpleAnimations) {
                    int changeFlags = ItemAnimator
                            .buildAdapterChangeFlagsForAnimations(holder);
                    changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                    final ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,
                            holder, changeFlags, holder.getUnmodifiedPayloads());
                    recordAnimationInfoIfBouncedHiddenView(holder, info);
                }
            }

            boolean bound = false;
            if (mState.isPreLayout() &amp;&amp; holder.isBound()) {
                // do not update unless we absolutely have to.
                holder.mPreLayoutPosition = position;
            } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
                if (DEBUG &amp;&amp; holder.isRemoved()) {
                    throw new IllegalStateException(&quot;Removed holder should be bound and it should&quot;
                            + &quot; come here only in pre-layout. Holder: &quot; + holder
                            + exceptionLabel());
                }
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
            }

            final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();
            final LayoutParams rvLayoutParams;
            if (lp == null) {
                rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();
                holder.itemView.setLayoutParams(rvLayoutParams);
            } else if (!checkLayoutParams(lp)) {
                rvLayoutParams = (LayoutParams) generateLayoutParams(lp);
                holder.itemView.setLayoutParams(rvLayoutParams);
            } else {
                rvLayoutParams = (LayoutParams) lp;
            }
            rvLayoutParams.mViewHolder = holder;
            rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;
            return holder;
        }
</code></pre>

<h4 id="toc_37">从RecyclerViewPool里面获取ViewHolder</h4>

<p>在RecyclerViewPool的内部，使用SparseArray来存储每个ViewType对应的ViewHolder数组，其中每个数组的最大size为5。</p>

<pre class="line-numbers"><code class="language-java">        static class ScrapData {
            final ArrayList&lt;ViewHolder&gt; mScrapHeap = new ArrayList&lt;&gt;();
            int mMaxScrap = DEFAULT_MAX_SCRAP;
            long mCreateRunningAverageNs = 0;
            long mBindRunningAverageNs = 0;
        }
        SparseArray&lt;ScrapData&gt; mScrap = new SparseArray&lt;&gt;();
</code></pre>

<h3 id="toc_38">回收</h3>

<h4 id="toc_39">scrap数组</h4>

<p>关于ViewHolder回收到scrap数组里面，其实我在前面已经简单的分析了，重点就在于Recycler的scrapView方法里面。我们来看看scrapView在哪里被调用了。有如下两个地方:</p>

<ul>
<li>在getScrapOrHiddenOrCachedHolderForPosition方法里面，如果从mHiddenViews获得一个ViewHolder的话，会先将这个ViewHolder从mHiddenViews数组里面移除，然后调用Recycler的scrapView方法将这个ViewHolder放入到scrap数组里面，并且标记FLAG_RETURNED_FROM_SCRAP和FLAG_BOUNCED_FROM_HIDDEN_LIST两个flag。</li>
<li>在LayoutManager里面的scrapOrRecycleView方法也会调用Recycler的scrapView方法。而有两种情形下会出现如此情况：1. 手动调用了LayoutManager相关的方法;2. RecyclerView进行了一次布局(调用了requestLayout方法)</li>
</ul>

<h4 id="toc_40">mCacheViews数组</h4>

<p>  mCacheViews数组作为二级缓存，回收的路径相较于一级缓存要多。关于mCacheViews数组，重点在于Recycler的recycleViewHolderInternal方法里面。<br/>
  </p>

<h4 id="toc_41">mHiddenViews数组</h4>

<p>一个ViewHolder回收到mHiddenView数组里面的条件比较简单，如果当前操作支持动画，就会调用到RecyclerView的addAnimatingView方法，在这个方法里面会将做动画的那个View添加到mHiddenView数组里面去。通常就是动画期间可以会进行复用，因为mHiddenViews只在动画期间才会有元素。</p>

<h4 id="toc_42">RecyclerViewPool</h4>

<p>RecyclerViewPool跟mCacheViews,都是通过recycleViewHolderInternal方法来进行回收，所以情景与mCacheViews差不多，只不过当不满足放入mCacheViews时，才会放入到RecyclerViewPool里面去。</p>

<h4 id="toc_43">为什么hasStableIds方法返回true会提高效率呢？</h4>

<p>了解了RecyclerView的复用和回收机制之后，这个问题就变得很简单了。我从两个方面来解释原因。</p>

<h5 id="toc_44">A. 复用方面</h5>

<pre class="line-numbers"><code class="language-java">                if (mAdapter.hasStableIds()) {
                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                            type, dryRun);
                    if (holder != null) {
                        // update position
                        holder.mPosition = offsetPosition;
                        fromScrapOrHiddenOrCache = true;
                    }
                }
</code></pre>

<p>在前面通过Position方式来获取一个ViewHolder失败之后，如果Adapter的hasStableIds方法返回为true，在进行通过ViewType方式来获取ViewHolder时，会优先到1级或者二级缓存里面去寻找，而不是直接去RecyclerViewPool里面去寻找。从这里，我们可以看到,在复用方面，hasStableIds方法提高了效率。</p>

<h5 id="toc_45">B. 回收方面</h5>

<pre class="line-numbers"><code class="language-java">        private void scrapOrRecycleView(Recycler recycler, int index, View view) {
            final ViewHolder viewHolder = getChildViewHolderInt(view);
            if (viewHolder.shouldIgnore()) {
                if (DEBUG) {
                    Log.d(TAG, &quot;ignoring view &quot; + viewHolder);
                }
                return;
            }
            if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                    &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
                removeViewAt(index);
                recycler.recycleViewHolderInternal(viewHolder);
            } else {
                detachViewAt(index);
                recycler.scrapView(view);
                mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);
            }
        }
</code></pre>

<p>从上面的代码中，我们可以看出，如果hasStableIds方法返回为true的话，这里所有的回收都进入scrap数组里面。这刚好与前面对应了。</p>

<h2 id="toc_46">Adapter源码解析</h2>

<p>先看Adapter源码</p>

<pre class="line-numbers"><code class="language-java">    public abstract static class Adapter&lt;VH extends ViewHolder&gt; {
        private final AdapterDataObservable mObservable = new AdapterDataObservable();
        private boolean mHasStableIds = false;

        //创建一个ViewHolder对象，主要作用是将数据保存在ViewHolder，以供后面bind操作使用
        @NonNull
        public abstract VH onCreateViewHolder(@NonNull ViewGroup parent, int viewType);

        //数据绑定方法
        public abstract void onBindViewHolder(@NonNull VH holder, int position);

        public void onBindViewHolder(@NonNull VH holder, int position,
                @NonNull List&lt;Object&gt; payloads) {
            onBindViewHolder(holder, position);
        }

        @NonNull
        public final VH createViewHolder(@NonNull ViewGroup parent, int viewType) {
            try {
                TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG);
                final VH holder = onCreateViewHolder(parent, viewType);
                if (holder.itemView.getParent() != null) {
                    throw new IllegalStateException(&quot;ViewHolder views must not be attached when&quot;
                            + &quot; created. Ensure that you are not passing &#39;true&#39; to the attachToRoot&quot;
                            + &quot; parameter of LayoutInflater.inflate(..., boolean attachToRoot)&quot;);
                }
                holder.mItemViewType = viewType;
                return holder;
            } finally {
                TraceCompat.endSection();
            }
        }

        public final void bindViewHolder(@NonNull VH holder, int position) {
            holder.mPosition = position;
            if (hasStableIds()) {
                holder.mItemId = getItemId(position);
            }
            holder.setFlags(ViewHolder.FLAG_BOUND,
                    ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID
                            | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);
            TraceCompat.beginSection(TRACE_BIND_VIEW_TAG);
            onBindViewHolder(holder, position, holder.getUnmodifiedPayloads());
            holder.clearPayload();
            final ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
            if (layoutParams instanceof RecyclerView.LayoutParams) {
                ((LayoutParams) layoutParams).mInsetsDirty = true;
            }
            TraceCompat.endSection();
        }

        //该方法带一个Position，主要是返回当前位置的ViewType。这个方法通常用于一个RecyclerView需要加载不同的布局。
        public int getItemViewType(int position) {
            return 0;
        }

        //设置当前RecyclerView的ItemView是否拥有固定id,跟getItemId方法一起使用。如果设置为true，会提高RecyclerView的缓存效率。
        public void setHasStableIds(boolean hasStableIds) {
            if (hasObservers()) {
                throw new IllegalStateException(&quot;Cannot change whether this adapter has &quot;
                        + &quot;stable IDs while the adapter has registered observers.&quot;);
            }
            mHasStableIds = hasStableIds;
        }

        //该方法表示的意思是返回当前位置Item的id，此方法只在setHasStableIds设置为true才会生效
        public long getItemId(int position) {
            return NO_ID;
        }

        //当前Adapter拥有数据的数量，该方法必须被重写，否则RecyclerView展示不了任何数据
        public abstract int getItemCount();

        public final boolean hasStableIds() {
            return mHasStableIds;
        }

        public void onViewRecycled(@NonNull VH holder) {
        }

        public boolean onFailedToRecycleView(@NonNull VH holder) {
            return false;
        }

        public void onViewAttachedToWindow(@NonNull VH holder) {
        }

        public void onViewDetachedFromWindow(@NonNull VH holder) {
        }

        public final boolean hasObservers() {
            return mObservable.hasObservers();
        }

        public void registerAdapterDataObserver(@NonNull AdapterDataObserver observer) {
            mObservable.registerObserver(observer);
        }

        public void unregisterAdapterDataObserver(@NonNull AdapterDataObserver observer) {
            mObservable.unregisterObserver(observer);
        }

        public void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) {
        }

        public void onDetachedFromRecyclerView(@NonNull RecyclerView recyclerView) {
        }

        public final void notifyDataSetChanged() {
            mObservable.notifyChanged();
        }

        public final void notifyItemChanged(int position) {
            mObservable.notifyItemRangeChanged(position, 1);
        }

        public final void notifyItemChanged(int position, @Nullable Object payload) {
            mObservable.notifyItemRangeChanged(position, 1, payload);
        }

        public final void notifyItemRangeChanged(int positionStart, int itemCount) {
            mObservable.notifyItemRangeChanged(positionStart, itemCount);
        }

        public final void notifyItemRangeChanged(int positionStart, int itemCount,
                @Nullable Object payload) {
            mObservable.notifyItemRangeChanged(positionStart, itemCount, payload);
        }

        public final void notifyItemInserted(int position) {
            mObservable.notifyItemRangeInserted(position, 1);
        }

        public final void notifyItemMoved(int fromPosition, int toPosition) {
            mObservable.notifyItemMoved(fromPosition, toPosition);
        }
        
        public final void notifyItemRangeInserted(int positionStart, int itemCount) {
            mObservable.notifyItemRangeInserted(positionStart, itemCount);
        }

        public final void notifyItemRemoved(int position) {
            mObservable.notifyItemRangeRemoved(position, 1);
        }

        public final void notifyItemRangeRemoved(int positionStart, int itemCount) {
            mObservable.notifyItemRangeRemoved(positionStart, itemCount);
        }
    }
</code></pre>

<h3 id="toc_47">onCreateViewHolder</h3>

<p>首先，我们来看一下onCreateViewHolder方法，从它的调用时机入手。</p>

<ul>
<li>一级缓存：scrap数组</li>
<li>二级缓存：CachedView</li>
<li>三级缓存：ViewCacheExtension</li>
<li>四级缓存：RecyclerViewPool</li>
</ul>

<p>LayoutManager会获取ViewHolder时，如果4级缓存都没有命中，就会调用Adapter的onCreateViewHolder方法来创建一个新的ViewHolder。</p>

<h3 id="toc_48">onBindViewHolder</h3>

<p>在之前的tryGetViewHolderForPositionByDeadline方法中</p>

<pre class="line-numbers"><code class="language-java">            boolean bound = false;
            if (mState.isPreLayout() &amp;&amp; holder.isBound()) {
                // do not update unless we absolutely have to.
                holder.mPreLayoutPosition = position;
            } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
                if (DEBUG &amp;&amp; holder.isRemoved()) {
                    throw new IllegalStateException(&quot;Removed holder should be bound and it should&quot;
                            + &quot; come here only in pre-layout. Holder: &quot; + holder
                            + exceptionLabel());
                }
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
            }
</code></pre>

<p>在tryBindViewHolderByDeadline中调用Adapter的bindViewHolder</p>

<pre class="line-numbers"><code class="language-java">            private boolean tryBindViewHolderByDeadline(@NonNull ViewHolder holder, int offsetPosition,
                int position, long deadlineNs) {
            //...
            mAdapter.bindViewHolder(holder, offsetPosition);
            //...
            return true;
        }
</code></pre>

<p>在执行onBindViewHolder方法前后，各自做了一些不同的操作。比如，在执行onBindViewHolder方法之前，更新了ViewHolder的mPosition属性和给ViewHolder设置了一些flag；在执行onBindViewHolder方法之后，清理了ViewHolder的payload，并且还是给ItemView的LayoutParams的mInsetsDirty属性设置为true。</p>

<pre class="line-numbers"><code class="language-java">            public final void bindViewHolder(@NonNull VH holder, int position) {
            holder.mPosition = position;
            if (hasStableIds()) {
                holder.mItemId = getItemId(position);
            }
            holder.setFlags(ViewHolder.FLAG_BOUND,
                    ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID
                            | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);
            TraceCompat.beginSection(TRACE_BIND_VIEW_TAG);
            onBindViewHolder(holder, position, holder.getUnmodifiedPayloads());
            holder.clearPayload();
            final ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
            if (layoutParams instanceof RecyclerView.LayoutParams) {
                ((LayoutParams) layoutParams).mInsetsDirty = true;
            }
            TraceCompat.endSection();
        }
</code></pre>

<h3 id="toc_49">ViewHolder的position</h3>

<p>这里主要分析两个方法，分别是getAdapterPosition和getLayoutPosition，对应着ViewHolder内部两个成员变量mPosition和mPreLayoutPosition两个属性。</p>

<p><strong>先来看下getAdapterPosition方法</strong></p>

<pre class="line-numbers"><code class="language-java">        public final int getAdapterPosition() {
            if (mOwnerRecyclerView == null) {
                return NO_POSITION;
            }
            return mOwnerRecyclerView.getAdapterPositionFor(this);
        }
</code></pre>

<p>别看getAdapterPosition方法比较麻烦，还调用了RecyclerView的getAdapterPositionFor方法进行位置的计算。但是它表达的意思是非常简单的，就是获取当前ViewHolder所绑定ItemView的真实位置。这里的真实位置说的比较笼统，这样来解释吧，当我们remove掉为position为0的item，正常来说，后面ViewHolder的position应该都减1。但是RecyclerView处理Adapter的更新采用的延迟处理策略，所以在正式处理之前获取ViewHolder的位置可能会出现误差，介于这个原因，getAdapterPosition方法就出现了。<br/>
  getAdapterPosition方法是怎样保证每次计算都是正确的呢？包括在正式处理之前呢？我们知道，在RecyclerView中，延迟处理的实现是在notify阶段往一个叫mPendingUpdates数组里面添加Operation，分别在dispatchLayoutStep1阶段或者dispatchLayoutStep2阶段进行处理。通过追踪getAdapterPositionFor方法，我们知道getAdapterPosition方法在计算位置时，考虑到mPendingUpdates数组的存在，所以在notify阶段和dispatchLayoutStep1阶段之间(这里假设dispatchLayoutStep1就会处理)，getAdapterPosition方法返回正确的位置。</p>

<p><strong>再来看看getLayoutPosition方法</strong></p>

<pre class="line-numbers"><code class="language-java">        public final int getLayoutPosition() {
            return mPreLayoutPosition == NO_POSITION ? mPosition : mPreLayoutPosition;
        }
</code></pre>

<p>getLayoutPosition方法返回的是mPosition或者mPreLayoutPosition,但是在dispatchLayoutStep1阶段之前，还未更新每个ViewHolder的position，所以获得不一定的是正确(只有在处理mPendingUpdates的操作时，position才会被更新，对应着的代码就是执行AdapterHelper$Callback接口的方法)。<br/>
  但是getLayoutPosition方法为什么还有存在的必要呢？我们发现getLayoutPosition方法不会每次都计算，也就是说，getLayoutPosition方法的效率比getAdapterPosition方法高。当我们在Adapter这种调用方法来获取ViewHolder的位置时，可以优先考虑getLayoutPosition方法，因为Adapter的方法回调阶段不在mPendingUpdates处理之前，所以此时getLayoutPosition方法跟getAdapterPosition方法没有任何区别了。<br/>
  但是需要注意，如果我们在其他地方获取ViewHolder的position，要特别注意这种情况，因为其他地方不能保证与RecyclerView状态同步，这种情况为了保证结果的正确性，我们应该优先考虑getAdapterPosition方法。</p>

<h3 id="toc_50">notifyDataSetChanged</h3>

<p>该方法最终调用了 RecyclerViewDataObserver 的 onChanged 方法</p>

<pre class="line-numbers"><code class="language-java">    @Override
    public void onChanged() {
        // ...

        // 该方法主要做了这两件事
        // 1. 给所有 ViewHolder 添加了 FLAG_UPDATE 和 FLAG_INVALID
        // 2. 默认情况下（mHasStableIds 为 false）清空 CacheViews
        processDataSetCompletelyChanged(true);
        
        if (!mAdapterHelper.hasPendingUpdates()) {
            // 进行视图重绘
            requestLayout();
        }
    }
</code></pre>

<p>该方法会进行视图重绘，又来到了 layout 过程，继续以 LinearLayoutManager 为例，从它的 onLayoutChildren 方法看起，由于分析第一次 layout 时已经看过一遍了，这次主要看下不同之处：</p>

<pre class="line-numbers"><code class="language-java">    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // ...
        
        detachAndScrapAttachedViews(recycler);
        
        // ...
    }
</code></pre>

<p>主要区别在于 detachAndScrapAttachedViews 方法，这次它开始起作用了，该方法在 RecyclerView 的 LayoutManager 中定义，看下它的实现：</p>

<h4 id="toc_51">LayoutManager#detachAndScrapAttachedViews</h4>

<pre class="line-numbers"><code class="language-java">    public void detachAndScrapAttachedViews(@NonNull Recycler recycler) {
        final int childCount = getChildCount();
        for (int i = childCount - 1; i &gt;= 0; i--) {
            final View v = getChildAt(i);
            scrapOrRecycleView(recycler, i, v);
        }
    }
</code></pre>

<p>由于不是第一次 layout，RecyclerView 这时已经有子 View 了，该方法遍历子 View，调用 scrapOrRecycleView 方法：</p>

<pre class="line-numbers"><code class="language-java">    private void scrapOrRecycleView(Recycler recycler, int index, View view) {
        final ViewHolder viewHolder = getChildViewHolderInt(view);
        // 不能回收添加了 FLAG_IGNORE 标记的 ViewHolder
        // 可通过 LayoutManager 的 ignoreView 为相应的 View 添加该标记
        if (viewHolder.shouldIgnore()) {
            return;
        }
        // 这些条件都满足，进入 if 块
        if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
            removeViewAt(index);
            recycler.recycleViewHolderInternal(viewHolder);
        } else {
            // ...
        }
    }
</code></pre>

<p>这里将子 View 移除并通过 Recycler 的 recycleViewHolderInternal 方法进行回收</p>

<h4 id="toc_52">Recycler#recycleViewHolderInternal</h4>

<pre class="line-numbers"><code class="language-java">        void recycleViewHolderInternal(ViewHolder holder) {
            // ...
            boolean cached = false;
            boolean recycled = false;

            if (forceRecycle || holder.isRecyclable()) {
                // 由于此时的 ViewHolder 有 FLAG_INVALID 标记，不会进入此 if 块
                if (mViewCacheMax &gt; 0
                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                        | ViewHolder.FLAG_REMOVED
                        | ViewHolder.FLAG_UPDATE
                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
                    //...
                }
                // cached 仍为 false，进入此 if 块
                if (!cached) {
                    // 通过 RecycledViewPool 的 putRecycledView 方法缓存该 ViewHolder
                    addViewHolderToRecycledViewPool(holder, true);
                    recycled = true;
                }
            } 
            
            // ...
        }
</code></pre>

<p>最终被移除的子 View 缓存到了 RecycledViewPool 中。</p>

<p>后面在调用 fill 方法进行布局填充时，就可以从 RecycledViewPool 中拿取缓存的 View。</p>

<h3 id="toc_53">notifyItemChanged</h3>

<p>该方法传入一个 int 参数，表示要数据有更新的 item 的 position。</p>

<pre class="line-numbers"><code class="language-java">    public final void notifyItemChanged(int position) {
        mObservable.notifyItemRangeChanged(position, 1);
    }
</code></pre>

<p>最终调用 RecyclerViewDataObserver 的 onItemRangeChanged 方法</p>

<pre class="line-numbers"><code class="language-java">    @Override
    public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {
        // 会在 mAdapterHelper 中创建一个 UpdateOp，将信息保存起来
        if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) {
            // 如果可以进行更新操作，执行该方法
            triggerUpdateProcessor();
        }
    }
</code></pre>

<p>继续看 triggerUpdateProcessor 方法</p>

<pre class="line-numbers"><code class="language-java">    void triggerUpdateProcessor() {
        // 判断条件默认为 false，执行 else 块
        if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) {
            // ...
        } else {
            mAdapterUpdateDuringMeasure = true;
            requestLayout();
        }
    }
</code></pre>

<p>在保存了一些信息后，还是进行视图重绘。来到了 layout 过程后，还是以 LinearLayoutManager 为例，这次先看下布局过程的 step1，也就是 dispatchLayoutStep1 方法</p>

<pre class="line-numbers"><code class="language-java">    private void dispatchLayoutStep1() {
        // ...
        
        processAdapterUpdatesAndSetAnimationFlags();
        
        // ...
    }
</code></pre>

<p>主要看 processAdapterUpdatesAndSetAnimationFlags 方法，从名字也可以看出，它负责更新 adapter 的信息</p>

<pre class="line-numbers"><code class="language-java">    private void processAdapterUpdatesAndSetAnimationFlags() {
        // ...

        if (predictiveItemAnimationsEnabled()) {
            mAdapterHelper.preProcess();
        } else {
            mAdapterHelper.consumeUpdatesInOnePass();
        }

        // ...
    }
</code></pre>

<p>这里借助了 mAdapterHelper，它最终又通过接口回调（回调了 markViewHoldersUpdated 方法）调用了 RecyclerView 的 viewRangeUpdate 方法</p>

<pre class="line-numbers"><code class="language-java">    void viewRangeUpdate(int positionStart, int itemCount, Object payload) {
        // ...

        for (int i = 0; i &lt; childCount; i++) {
            // ...
            
            if (holder.mPosition &gt;= positionStart &amp;&amp; holder.mPosition &lt; positionEnd) {
                // （1）
                holder.addFlags(ViewHolder.FLAG_UPDATE);
                // ...
            }
        }
    }
</code></pre>

<p>该方法就是遍历所有子 View，找到所有发生了改变的子 View，进行相关操作。这里重点看注释（1），为改变的 ViewHolder 添加了 FLAG_UPDATE 标记。先记住这点，在后面会用到。</p>

<p>接下来看 onLayoutChildren 方法，和 notifyDataSetChanged 一样，主要的不同之处也是在于 detachAndScrapAttachedViews 方法，该方法遍历子 View，调用 scrapOrRecycleView 方法，下面看一下该方法</p>

<h4 id="toc_54">LayoutManager#scrapOrRecycleView</h4>

<pre class="line-numbers"><code class="language-java">    private void scrapOrRecycleView(Recycler recycler, int index, View view) {
        final ViewHolder viewHolder = getChildViewHolderInt(view);
        // ...
        
        // 这次 ViewHolder 没有添加 FLAG_INVALID 标记，进入 else 块
        if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
            // ...
        } else {
            detachViewAt(index);
            recycler.scrapView(view);
            mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);
        }
    }
</code></pre>

<p>这里就和 notifyDataSetChanged 时不一样了，由于在视图重绘前没有给 ViewHolder 添加 FLAG_INVALID 标记，这次进入的是 else 块。</p>

<p>首先将 View 从 RecyclerView 中 detach 掉（而不是 remove 掉）。然后在回收时，调用的是 Recycler 的 scrapView 方法。该方法在前面也分析过了，这里再看一次</p>

<pre class="line-numbers"><code class="language-java">    void scrapView(View view) {
        final ViewHolder holder = getChildViewHolderInt(view);
        
        // 满足这几个条件中的一个就可以进入 if 循环
        // 1. ViewHolder 设置了 FLAG_REMOVED 或 FLAG_INVALID 
        // 2. ViewHolder 没有设置 FLAG_UPDATE 
        // 3. 没有设置动画或者动画可以重用该 ViewHolder 
        if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
            // ...
            
            mAttachedScrap.add(holder);
        } 
        // 不满足上述任意一个条件时，将 View 缓存到 mChangedScrap 中
        else {
            if (mChangedScrap == null) {
                mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
            }
            holder.setScrapContainer(this, true);
            mChangedScrap.add(holder);
        }
    }
</code></pre>

<p>重点看判断里面的条件 2，从前面的分析可以得知，对于发生改变的 ViewHolder，给它设置了 FLAG_UPDATE，所以它现在三个条件都不满足，进入 else 块，而对于其他的 ViewHolder，由于没有设置 FLAG_UPDATE，所以满足条件 2，进入 if 循环。</p>

<p>所以通过 notifyItemChanged 方法更新列表时，发生了改变的子 View 将被缓存到 ChangedScrap 中，而没有发生改变的子 View 则缓存到 AttachedScrap 中，之后通过填充布局的时候对于不同 item 就可以从相应的 Scrap 缓存中得到子 View。</p>

<p>另外，Scrap 缓存只作用于布局阶段，在 layout 的 step3 中将会清空 mAttachedScrap 和 mChangedScrap。</p>

<h2 id="toc_55">动画机制</h2>

<h2 id="toc_56">滑动机制</h2>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16000203391559.html" 
          title="Previous Post: Flutter中的滚动布局">&laquo; Flutter中的滚动布局</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15941201495783.html" 
          title="Next Post: MySQL学习笔记">MySQL学习笔记 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16145671673295.html">多态</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
