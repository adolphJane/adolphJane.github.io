<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Android - MagicalRice的Blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">MagicalRice的Blog</a></h1>
					<p class="subtitle">技术博客</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-19T12:22:27+08:00" itemprop="datePublished">2017/9/19</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207871208.html" itemprop="url">
		Android-自己封装DialogFragment</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171030150929495953693.gif" alt="20171030150929495953693.gif"/><figcaption>20171030150929495953693.gif</figcaption></figure></p>

<h2 id="toc_0">创建通用的 CommonDialogFragment</h2>

<p>这个类是 DialogFragment 的子类，对 DialogFragment 进行封装，依赖外部传入的 AlertDialog 来构建，同时也处理了 DialogFragment 中 AlertDialog 不能设置外部取消的问题</p>

<pre class="line-numbers"><code class="language-text">public class CommonDialogFragment extends DialogFragment {

    /**
     * 监听弹出窗是否被取消
     */
    private OnDialogCancelListener mCancelListener;

    /**
     * 回调获得需要显示的dialog
     */
    private OnCallDialog mOnCallDialog;

    public interface OnDialogCancelListener {
        void onCancel();
    }

    public interface OnCallDialog {
        Dialog getDialog(Context context);
    }

    public static CommonDialogFragment newInstance(OnCallDialog call, boolean cancelable) {
        return newInstance(call, cancelable, null);
    }

    public static CommonDialogFragment newInstance(OnCallDialog call, boolean cancelable, OnDialogCancelListener cancelListener) {
        CommonDialogFragment instance = new CommonDialogFragment();
        instance.setCancelable(cancelable);
        instance.mCancelListener = cancelListener;
        instance.mOnCallDialog = call;
        return instance;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        if (null == mOnCallDialog) {
            super.onCreateDialog(savedInstanceState);
        }
        return mOnCallDialog.getDialog(getActivity());
    }

    @Override
    public void onStart() {
        super.onStart();
        Dialog dialog = getDialog();
        if (dialog != null) {
            //在5.0以下的版本会出现白色背景边框，若在5.0以上设置则会造成文字部分的背景也变成透明
            if(Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT) {
                //目前只有这两个dialog会出现边框
                if(dialog instanceof ProgressDialog || dialog instanceof DatePickerDialog) {
                    getDialog().getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
                }
            }
            Window window = getDialog().getWindow();
            WindowManager.LayoutParams windowParams = window.getAttributes();
            windowParams.dimAmount = 0.0f;
            window.setAttributes(windowParams);
        }
    }

    @Override
    public void onCancel(DialogInterface dialog) {
        super.onCancel(dialog);
        if (mCancelListener != null) {
            mCancelListener.onCancel();
        }
    }
}
</code></pre>

<p>可以看到这个类的代码量也是很少的，先定义了两个接口 <code>OnDialogCancelListener</code>，<code>OnCallDialog</code>，前者用于监听弹出窗是否被取消，后者则可以让我们回调获得想要显示的 Dialog，可以看到在 onCreateDialog() 中我们返回的 是 <code>mOnCallDialog.getDialog(getActivity)</code>;，当我们在传入 Dialog 的时候，便会回调到此处，让 <code>onCreateDialog()</code> 返回我们传入的 Dialog。</p>

<p>接着在 <code>onStart()</code> 中进行了一些特殊性的处理，因为在 5.0 以下的版本，ProgressDialog 和 DatePickerDialog 会出现白色的边框，这使得用户体验非常不好，所以我们要在此处进行相应的处理</p>

<p>最后便是封装我们的构造函数<br/>
<code>newInstance(OnCallDialog call, boolean cancelable, OnDialogCancelListener cancelListener)</code>，当我们要使用这个 CommonDialogFragment 的时候，先 new 一个 OnCallDialog，将我们想要显示的 Dialog 传进去，<code>cancelable</code>，用于设置对话框是否能被取消，可以看到在 <code>onCancel()</code> 有这样一段代码</p>

<pre class="line-numbers"><code class="language-text">if(mCancelListener != null){
  mCancelListener.onCancel();
}
</code></pre>

<p>这便是我们在构造函数中传入 OnCancelListener 的原因，当我们想要做一些取消对话框后的处理时，只要在构造函数中传入 OnCancelListener，实现 onCancel() 方法就行了</p>

<h2 id="toc_1">实现各种类型的 DialogFragment</h2>

<p>既然前面我们创建了 CommonFragment 作为所有 DialogFragment 的基类，那么接下来我们当然要好好地来实现各种类型的 DialogFragment 了，我的思路是创建一个 DialogFragmentHelper 作为实现提示框的帮助类，帮我们把代码都封装起来，使用的时候只需要关注与 AlertDialog 的交互，Helper 会帮助我们用 DialogFragment 来进行显示，这样既能统一整个应用的 Dialog 风格，又能让我们实现各种各样的对话框变得相当的简单</p>

<p>在实现 DialogFragmentHelper 之前我们有两件事先要做一下</p>

<h3 id="toc_2">在 styles 文件中定义我们定义我们对话框的风格样式</h3>

<pre class="line-numbers"><code class="language-text">&lt;style name=&quot;Base_AlertDialog&quot; parent=&quot;Base.Theme.AppCompat.Light.Dialog&quot;&gt;

        &lt;!--不设置在6.0以上会出现，宽度不充满屏幕的情况--&gt;
        &lt;item name=&quot;windowMinWidthMinor&quot;&gt;90%&lt;/item&gt;

        &lt;!-- 取消标题栏，如果在代码中settitle的话会无效 --&gt;
        &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;

        &lt;!-- 标题的和Message的文字颜色 --&gt;
        &lt;!--&lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/black&lt;/item&gt;--&gt;

        &lt;!-- 修改顶部标题背景颜色，具体颜色自己定，可以是图片 --&gt;
        &lt;item name=&quot;android:topDark&quot;&gt;@color/app_main_color_deep&lt;/item&gt;

        &lt;!--&lt;item name=&quot;android:background&quot;&gt;@color/white&lt;/item&gt;--&gt;

        &lt;!-- 在某些系统上面设置背景颜色之后出现奇怪的背景，处这里设置背景为透明，为了隐藏边框 --&gt;
        &lt;!--&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;--&gt;
        &lt;!--&lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt;--&gt;

        &lt;!-- 进入和退出动画，左进右出（系统自带） --&gt;
        &lt;!--&lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@android:style/Animation.Translucent&lt;/item&gt;--&gt;

        &lt;!-- 按钮字体颜色,全部一起改，单个改需要在Java代码中修改 --&gt;
        &lt;item name=&quot;colorAccent&quot;&gt;@color/app_main_color&lt;/item&gt;
    &lt;/style&gt;
</code></pre>

<p>我已经打上了详细的注释，相信应该很容易理解</p>

<h3 id="toc_3">写一个接口，用于 DialogFragmentHelper 与逻辑层之间进行数据监听</h3>

<pre class="line-numbers"><code class="language-java">public interface IDialogResultListener&lt;T&gt; {
    void onDataResult(T result);
}
</code></pre>

<p>准备工作做完了，就让我们开工撸 DialogFragmentHelper 吧，因为篇幅有限，我只是代表性的选了其中的一些效果来讲，具体的代码，可以参考下 DialogFragmentDemos</p>

<pre class="line-numbers"><code class="language-java">public class DialogFragmentHelper {

    private static final String TAG_HEAD = DialogFragmentHelper.class.getSimpleName();

    /**
     * 加载中的弹出窗
     */
    private static final int PROGRESS_THEME = R.style.Base_AlertDialog;
    private static final String PROGRESS_TAG = TAG_HEAD + &quot;:progress&quot;;


    public static CommonDialogFragment showProgress(FragmentManager fragmentManager, String message){
        return showProgress(fragmentManager, message, true, null);
    }

    public static CommonDialogFragment showProgress(FragmentManager fragmentManager, String message, boolean cancelable){
        return showProgress(fragmentManager, message, cancelable, null);
    }

    public static CommonDialogFragment showProgress(FragmentManager fragmentManager, final String message, boolean cancelable
            , CommonDialogFragment.OnDialogCancelListener cancelListener){

        CommonDialogFragment dialogFragment = CommonDialogFragment.newInstance(new CommonDialogFragment.OnCallDialog() {
            @Override
            public Dialog getDialog(Context context) {
                ProgressDialog progressDialog = new ProgressDialog(context, PROGRESS_THEME);
                progressDialog.setMessage(message);
                return progressDialog;
            }
        }, cancelable, cancelListener);
        dialogFragment.show(fragmentManager, PROGRESS_TAG);
        return dialogFragment;
    }

    /**
     * 带输入框的弹出窗
     */
    private static final int INSERT_THEME = R.style.Base_AlertDialog;
    private static final String INSERT_TAG  = TAG_HEAD + &quot;:insert&quot;;

    public static void showInsertDialog(FragmentManager manager, final String title, final IDialogResultListener&lt;String&gt; resultListener, final boolean cancelable){

        CommonDialogFragment dialogFragment = CommonDialogFragment.newInstance(new CommonDialogFragment.OnCallDialog() {
            @Override
            public Dialog getDialog(Context context) {
                // ...
                AlertDialog.Builder builder = new AlertDialog.Builder(context, INSERT_THEME);
                builder.setPositiveButton(DIALOG_POSITIVE, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        if(resultListener != null){
                            resultListener.onDataResult(editText.getText().toString());
                        }
                    }
                });
                builder.setNegativeButton(DIALOG_NEGATIVE, null);
                return builder.create();
            }
        }, cancelable, null);
        dialogFragment.show(manager, INSERT_TAG);
    }
}
</code></pre>

<p>可以看到因为我们实现封装了 CommonFragment，所有这些效果的实现都变得相当的简单吗，这便是封装给我们带来的便利和好处。</p>

<p>就以 加载中的弹出窗 为例，来看看我们是怎么实现的</p>

<pre class="line-numbers"><code class="language-java">public static CommonDialogFragment showProgress(FragmentManager fragmentManager, final String message, boolean cancelable, CommonDialogFragment.OnDialogCancelListener cancelListener){
    CommonDialogFragment dialogFragment = CommonDialogFragment.newInstance(new CommonDialogFragment.OnCallDialog() {
        @Override
        public Dialog getDialog(Context context) {
            ProgressDialog progressDialog = new ProgressDialog(context, PROGRESS_THEME);
            progressDialog.setMessage(message);
            return progressDialog;
        }
    }, cancelable, cancelListener);
    dialogFragment.show(fragmentManager, PROGRESS_TAG);
    return dialogFragment;
}
</code></pre>

<p>我们先调用了 CommonDialogFragment 的构造函数，将一个 ProgressDialog 传进去，然后依次传入 cancelable 和 cancelListener，最后调用 show() 函数，将 DialogFragment 显示出来，因为我们使用了构造函数的重载，可以看到最简单的构造函数只需要传入两个参数就行了，是不是相当的简洁啊。</p>

<p>应该还没忘了我们上面创建了一个 IDialogResultListener<T> 用于 DialogFragment 与逻辑层之间进行数据监听吧，为了能传入各种各样类型的数据，这里我使用了 泛型 来进行处理，就以 带输入框的弹出窗 为例来看看究竟要怎么使用吧</p>

<pre class="line-numbers"><code class="language-java">public static void showInsertDialog(FragmentManager manager, final String title, final IDialogResultListener&lt;String&gt; resultListener, final boolean cancelable){

    CommonDialogFragment dialogFragment = CommonDialogFragment.newInstance(new CommonDialogFragment.OnCallDialog() {

        @Override
        public Dialog getDialog(Context context) {

            // ... 这里省略一部分代码
            AlertDialog.Builder builder = new AlertDialog.Builder(context, INSERT_THEME);
            builder.setPositiveButton(DIALOG_POSITIVE, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialog, int which) {
                    if(resultListener != null){
                        resultListener.onDataResult(editText.getText().toString());
                    }
                }
            });
            builder.setNegativeButton(DIALOG_NEGATIVE, null);
            return builder.create();

            }
    }, cancelable, null);
    dialogFragment.show(manager, INSERT_TAG);
}
</code></pre>

<p>可以看到我们在 showInsertDialog() 方法中传入了IDialogResultListener<String> resultListener，当我们想要处理输入的内容的时候，只要在外部调用的时候，new 一个 IDialogResultListener 传进去，然后实现 onDataResult() 方法就行了</p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FdeveloperHaoz%2FDialogFragmentDemos">DialogFragmentDemos</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-18T12:04:27+08:00" itemprop="datePublished">2017/9/18</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207871172.html" itemprop="url">
		程序员开源协议</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">自由软件</h2>

<p>自由软件是一种可以不受限制地自由使用、复制、研究、修改和分发的软件。注意，自由并不代表着免费。正是这种开放、开源的精神，计算机软件才得以如此飞快地发展。</p>

<h2 id="toc_1">开源协议</h2>

<p>为保护自由软件原作者的相关知识产权，在作者与用户之间设立的一种虚拟合同，或者称之为授权方式。其中的条款内容，就是用来限制软件使用者的使用方式等。他人如有违反协议，作者有权利发起诉讼，维护自身权益。</p>

<p>开源届定义有几百种不同的开源协议，宽松程度不一，用以满足开源项目的各种使用场景。比如，是否允许商用，是否允许修改，修改后是否需要继续开源，开源是否必须继续使用相同协议授权等。</p>

<p>不过，作为普通用户，无论你是作为开源作者造轮子，还是作为普通用户借轮子，我们只需要知道比较流行的那几种，并能够加以区分即可。否则，上百种协议真要细分的话，绝非易事。</p>

<p>早期一名乌克兰程序员画有一张分析图，简单明了地描述出六种流行开源协议的使用区分。阮一峰老师翻译如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171030150929343199353.png" alt="20171030150929343199353.png"/><figcaption>20171030150929343199353.png</figcaption></figure></p>

<p>更简单点的话，也可以参考这张图，更加通俗易懂：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171030150929351771005.png" alt="20171030150929351771005.png"/><figcaption>20171030150929351771005.png</figcaption></figure></p>

<p>更多的开源协议，我们还可以参考这张图（目前只发现英文版）：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171030150929356264898.png" alt="20171030150929356264898.png"/><figcaption>20171030150929356264898.png</figcaption></figure></p>

<p>至于使用的话，不妨借助 GcsSloop 制作的开源协议网站：</p>

<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fchoosealicense.online">choosealicense.online</a></p>

<p>如图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171030150929362375011.png" alt="20171030150929362375011.png"/><figcaption>20171030150929362375011.png</figcaption></figure></p>

<p>选择所需要的协议，一键复制即可。</p>

<p>说完这些，回过头来想想，估计很多人都会有疑惑：开源协议与我何干？但是，作为一名程序员，开源协议还真与你我关系紧密。</p>

<p>如果你是 GitHub 重度依赖者，如果你稍作留意，不难发现，基本上出名的开源项目根目录中都有一个协议文件：<strong>LICENSE.txt</strong>，而在 <strong>README.me</strong> 说明文件底部伴随着 License 内容。这就是你需要留意的地方，使用任意开源项目之前，记得阅读一下该项目的开源协议。</p>

<blockquote>
<p>市场上部分 App 也会在应用中增加第三方开源项目时的使用版权说明，比如支付宝安卓版。这也是一种查看优秀 App 都使用哪些开源项目的途径之一。</p>
</blockquote>

<p>如果你也是一个作者，准备开源自己的项目时，那就更得注意，想想自己需要选择哪一个开源协议更加合适。比如，大名鼎鼎的 Linux 系统采用便是 GPL 协议；作为安卓程序员，我们当然知道，我们赖以生存的 Android 开源系统，其内核采用的就是 Linux 内核。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-18T01:26:27+08:00" itemprop="datePublished">2017/9/18</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207871139.html" itemprop="url">
		Android-Fragment懒加载</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">生命周期</h2>

<p>附上生命周期，帮助下面的学习。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938445629591.png" alt="20171031150938445629591.png"/><figcaption>20171031150938445629591.png</figcaption></figure></p>

<h2 id="toc_1">何为懒加载</h2>

<p>Fragment 的 UI 对用户可见时才加载数据</p>

<h2 id="toc_2">为什么需要</h2>

<ul>
<li>需求要求，我们一般是等数据加载完毕之后才会初始化UI，但是可能需求会先让UI显示，再加载数据</li>
<li>与ViewPager搭配使用的时候，ViewPager有缓存机制，比如三个页面，0,1,2，当我们处于1页面的时候0,2也都会加载好，如果数据量较大的话，体验会很差</li>
</ul>

<h2 id="toc_3">实现原理</h2>

<p>核心的点是判断UI的可见，Fragment提供了一个setUserVisibleHint(boolean isVisibleToUser)方法可以用来判断；</p>

<h3 id="toc_4">setUserVisibleHint方法</h3>

<ul>
<li>单个 Fragment，setUserVisibleHint 是不会被调用的，只有该 Fragment 在 ViewPager 里才会被调用</li>
<li>执行顺序：setUserVisibleHint 方法在Fragment的生命周期函数之前执行一次，此时isVisibleToUser是false，后续还会执行一次，此时isVisibleToUser是true，但是这次的时间是不确定的 。参考官方note说明</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938453113981.png" alt="20171031150938453113981.png"/><figcaption>20171031150938453113981.png</figcaption></figure></p>

<h2 id="toc_5">实现代码</h2>

<pre class="line-numbers"><code class="language-java">public class FriendFragment extends Fragment {

    private boolean isVisible;
    // 标志位，标志已经初始化完成，防止空指针的异常
    private boolean isViewCreated;

    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
        super.onCreateView(inflater, container, savedInstanceState);
        isViewCreated = true;
        View chatView = inflater.inflate(R.layout.activity_tab_friend, container,false);
        return chatView;
    }


    @Override
    public void setUserVisibleHint(boolean isVisibleToUser) {
        super.setUserVisibleHint(isVisibleToUser);
              Log.e(&quot;hhp&quot;, &quot;setUserVisibleHint: isVisibleToUser--&quot;+isVisibleToUser+&quot;---isViewCreated---&quot;+isViewCreated );
        if (isVisibleToUser &amp;&amp; isViewCreated) {
            isVisible = true;
            lazyLoad();
        }else {
            isVisible = false;
        }
    }

    private void lazyLoad() {
        if (!isVisible || !isViewCreated) {
            return;
        }
        getData();
    }

    private void getData() {
        //加载数据
    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        if (getUserVisibleHint()) {
            getData();
        }
    }
}
</code></pre>

<h3 id="toc_6">几点说明</h3>

<p>分析两种情况：</p>

<p>1.进来就加载的这个Fragment，此时isVisibleToUser 和isViewCreated 两个标志位的值如下</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938465135328.png" alt="20171031150938465135328.png"/><figcaption>20171031150938465135328.png</figcaption></figure></p>

<p>，无法加载数据 ，所以需要在onActivityCreated方法中调用加载数据</p>

<p>2.进来加载的不是这个Fragment，当该Fragment被缓存的时候，调用onActivityCreated方法getUserVisibleHint()值是false，不调用getData()方法；同理，isVisibleToUser和isViewCreated也是false，也不会调用getData()方法；滑动到该Fragment的时候，onActivityCreated方法不会再次执行，isVisibleToUser和isViewCreated都变为true，调用getData()方法加载数据。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-11T22:13:27+08:00" itemprop="datePublished">2017/9/11</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207871105.html" itemprop="url">
		Android Gradle使用总结</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">Android Gradle</h2>

<p>Android项目使用 Gradle 作为构建框架，Gradle 又是以Groovy为脚本语言。所以学习Gradle之前需要先熟悉Groovy脚本语言。</p>

<p>Groovy是基于Java语言的脚本语言，所以它的语法和Java非常相似，但是具有比java更好的灵活性。下面就列举一些和Java的主要区别。</p>

<h2 id="toc_1">Android Gradle 的 Project 和 Tasks</h2>

<p>这个Gradle中最重要的两个概念。每次构建（build）至少由一个project构成，一个project 由一到多个task构成。项目结构中的每个build.gradle文件代表一个project，在这编译脚本文件中可以定义一系列的task；task 本质上又是由一组被顺序执行的Action`对象构成，Action其实是一段代码块，类似于Java中的方法。</p>

<h2 id="toc_2">Android Gradle 构建生命周期</h2>

<p>每次构建的执行本质上执行一系列的Task。某些Task可能依赖其他Task。哪些没有依赖的Task总会被最先执行，而且每个Task只会被执行一遍。每次构建的依赖关系是在构建的配置阶段确定的。每次构建分为3个阶段：</p>

<ul>
<li>Initialization: 初始化阶段</li>
</ul>

<p>这是创建Project阶段，构建工具根据每个build.gradle文件创建出一个Project实例。初始化阶段会执行项目根目录下的settings.gradle文件，来分析哪些项目参与构建。</p>

<p>所以这个文件里面的内容经常是：</p>

<pre class="line-numbers"><code class="language-text">include &#39;:app&#39;
include &#39;:libraries:someProject&#39;
</code></pre>

<p>这是告诉Gradle这些项目需要编译，所以我们引入一些开源的项目的时候，需要在这里填上对应的项目名称，来告诉Gradle这些项目需要参与构建。</p>

<ul>
<li>Configuration:配置阶段</li>
</ul>

<p>这个阶段，通过执行构建脚本来为每个project创建并配置Task。配置阶段会去加载所有参与构建的项目的build.gradle文件，会将每个build.gradle文件实例化为一个Gradle的project对象。然后分析project之间的依赖关系，下载依赖文件，分析project下的task之间的依赖关系。</p>

<ul>
<li>Execution:执行阶段</li>
</ul>

<p>这是Task真正被执行的阶段，Gradle会根据依赖关系决定哪些Task需要被执行，以及执行的先后顺序。 <br/>
task是Gradle中的最小执行单元，我们所有的构建，编译，打包，debug，test等都是执行了某一个task，一个project可以有多个task，task之间可以互相依赖。例如我有两个task，taskA和taskB，指定taskA依赖taskB，然后执行taskA，这时会先去执行taskB，taskB执行完毕后在执行taskA。</p>

<p>说到这可能会有疑问，我翻遍了build.gradle也没看见一个task长啥样，有一种被欺骗的赶脚！</p>

<p>其实不是，你点击AndroidStudio右侧的一个Gradle按钮，会打开一个面板，内容差不多是这样的：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920575828.png" alt="20171028150920575828.png"/><figcaption>20171028150920575828.png</figcaption></figure></p>

<p>里面的每一个条目都是一个task，那这些task是哪来的呢？</p>

<p>一个是根目录下的 build.gradle 中的</p>

<pre class="line-numbers"><code class="language-text">dependencies {
    classpath &#39;com.android.tools.build:gradle:2.2.2&#39;
}
</code></pre>

<p>一个是 app 目录下的 build.gradle 中的</p>

<p><code>apply plugin: &#39;com.android.application&#39;</code></p>

<p>这两段代码决定的。也就是说，Gradle提供了一个框架，这个框架有一些运行的机制可以让你完成编译，但是至于怎么编译是由插件决定的。还好Google已经给我们写好了Android对应的Gradle工具，我们使用就可以了。</p>

<p>根目录下的build.gradle中dependencies {classpath ‘com.android.tools.build:gradle:2.2.2’}是Android Gradle编译插件的版本。</p>

<p>app目录下的build.gradle中的apply plugin: ‘com.android.application’是引入了Android的应用构建项目，还有com.android.library和com.android.test用来构建library和测试。</p>

<p>所有Android构建需要执行的task都封装在工具里，如果你有一些特殊需求的话，也可以自己写一些task。那么对于开发一个Android应用来说，最关键的部分就是如何来用AndroidGradle的插件了。</p>

<h2 id="toc_3">认知Gradle Wrapper</h2>

<p>Android Studio中默认会使用 Gradle Wrapper 而不是直接使用Gradle。命令也是使用gradlew而不是gradle。这是因为gradle针对特定的开发环境的构建脚本，新的gradle可能不能兼容旧版的构建环境。为了解决这个问题，使用Gradle Wrapper 来间接使用 gradle。相当于在外边包裹了一个中间层。对开发者来说，直接使用Gradlew 即可，不需要关心 gradle的版本变化。Gradle Wrapper 会负责下载合适的的gradle版本来构建项目。</p>

<h2 id="toc_4">Android 三个文件重要的 gradle 文件</h2>

<p>Gradle项目有3个重要的文件需要深入理解：项目根目录的 build.gradle , settings.gradle 和模块目录的 build.gradle 。</p>

<ul>
<li><p>1.settings.gradle 文件会在构建的 initialization 阶段被执行，它用于告诉构建系统哪些模块需要包含到构建过程中。对于单模块项目， settings.gradle 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。</p></li>
<li><p>2.项目根目录的 build.gradle 文件用来配置针对所有模块的一些属性。它默认包含2个代码块：buildscript{…}和allprojects{…}。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性。</p></li>
</ul>

<pre class="line-numbers"><code class="language-text">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.3.2&#39;
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre>

<p>buildscript：定义了 Android 编译工具的类路径。repositories中, jCenter是一个著名的 Maven 仓库。</p>

<p>allprojects:中定义的属性会被应用到所有 moudle 中，但是为了保证每个项目的独立性，我们一般不会在这里面操作太多共有的东西。</p>

<ul>
<li>3.模块级配置文件 build.gradle 针对每个moudle 的配置，如果这里的定义的选项和顶层 build.gradle定义的相同。它有3个重要的代码块：plugin，android 和 dependencies。</li>
</ul>

<h2 id="toc_5">定制项目属性（project properties)</h2>

<p>在项目根目录的build.gradle配置文件中，我们可以定制适用于所有模块的属性，通过ext 代码块来实现。如下所示：</p>

<pre class="line-numbers"><code class="language-text">ext {
    compileSdkVersion = 22
    buildToolsVersion = &quot;22.0.1&quot;
}
</code></pre>

<p>然后我们可以在模块目录的build.gradle配置文件中引用这些属性,引用语法为rootProject.ext.{属性名}。如下：</p>

<pre class="line-numbers"><code class="language-text">android {
    compileSdkVersion rootProject.ext.compileSdkVersion
    buildToolsVersion rootProject.ext.buildToolsVersion
}
</code></pre>

<h2 id="toc_6">Android studio gradle Task</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920589712600.png" alt="20171028150920589712600.png"/><figcaption>20171028150920589712600.png</figcaption></figure></p>

<pre class="line-numbers"><code class="language-text">//构建
gradlew app:clean    //移除所有的编译输出文件，比如apk

gradlew app:build   //构建 app module ，构建任务，相当于同时执行了check任务和assemble任务

//检测
gradlew app:check   //执行lint检测编译。

//打包
gradlew app:assemble //可以编译出release包和debug包，可以使用gradlew assembleRelease或者gradlew assembleDebug来单独编译一种包

gradlew app:assembleRelease  //app module 打 release 包

gradlew app:assembleDebug  //app module 打 debug 包

//安装，卸载

gradlew app:installDebug  //安装 app 的 debug 包到手机上

gradlew app:uninstallDebug  //卸载手机上 app 的 debug 包

gradlew app:uninstallRelease  //卸载手机上 app 的 release 包

gradlew app:uninstallAll  //卸载手机上所有 app 的包
</code></pre>

<p>这些都是基本的命令，在实际项目中会根据不同的配置，会对这些task 设置不同的依赖。比如 默认的 assmeble 会依赖 assembleDebug 和assembleRelease，如果直接执行assmeble，最后会编译debug，和release 的所有版本出来。如果我们只需要编译debug 版本，我们可以运行assembleDebug。</p>

<p>除此之外还有一些常用的新增的其他命令，比如 install命令，会将编译后的apk 安装到连接的设备。</p>

<h2 id="toc_7">lint 检测</h2>

<ul>
<li>忽略编译器的 lint 检查</li>
</ul>

<pre class="line-numbers"><code class="language-text">android {

  lintOptions {
      abortOnError false
  }
}
</code></pre>

<h2 id="toc_8">buildTypes 定义了编译类型</h2>

<pre class="line-numbers"><code class="language-text">android{

  buildTypes {
       release {
           minifyEnabled true  //打开混淆
           proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
       }
        debug {
           minifyEnabled false //关闭混淆
           proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}
</code></pre>

<h2 id="toc_9">productFlavors 多渠道打包</h2>

<p>AndroidManifest.xml 里设置动态渠道变量</p>

<pre class="line-numbers"><code class="language-text">&lt;meta-data
    android:name=&quot;UMENG_CHANNEL&quot;
    android:value=&quot;${UMENG_CHANNEL_VALUE}&quot; /&gt;
</code></pre>

<p>在 build.gradle 设置 productFlavors , 这里假定我们需要打包的渠道为酷安市场、360、小米、百度、豌豆荚。</p>

<pre class="line-numbers"><code class="language-text">android {  

    productFlavors {
        kuan {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;kuan&quot;]
        }
        xiaomi {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;xiaomi&quot;]
        }
        qh360 {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;qh360&quot;]
        }
        baidu {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;baidu&quot;]
        }
        wandoujia {
            manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wandoujia&quot;]
        }
    } 
}
</code></pre>

<p>或者批量修改</p>

<pre class="line-numbers"><code class="language-text">android {  

    productFlavors {
        kuan {}
        xiaomi {}
        qh360 {}
        baidu {}
        wandoujia {}
    }  

    productFlavors.all { 
        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] 
    }
}
</code></pre>

<p>这样在打包的时候就可以选择渠道了</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920602392842.png" alt="20171028150920602392842.png"/><figcaption>20171028150920602392842.png</figcaption></figure></p>

<p>或者用命令打包 ，比如：</p>

<pre class="line-numbers"><code class="language-text">gradlew assembleWandoujiaRelease  //豌豆荚 release 包

gradlew assembleWandoujiaDebug //豌豆荚 debug 包
</code></pre>

<h2 id="toc_10">多渠道设置包名</h2>

<p>有时候我们需要分渠道设置 applicationId 、友盟的 appkey 、友盟渠道号。</p>

<pre class="line-numbers"><code class="language-text">productFlavors {
    google {
        applicationId &quot;com.wifi.cool&quot;
        manifestPlaceholders = [                
            UMENG_APPKEY_VALUE : &quot;456789456789&quot;,
            UMENG_CHANNEL_VALUE: &quot;google&quot;,            
        ]
    }

    baidu{
        applicationId &#39;com.wifi.hacker&#39;
        manifestPlaceholders = [
        UMENG_APPKEY_VALUE     : &quot;123456789789&quot;,
        UMENG_CHANNEL_VALUE    : &quot;baidu&quot;,          
        ]
    }
}
</code></pre>

<h2 id="toc_11">Signing 签名</h2>

<p>在 android 标签下添加 signingConfigs 标签，如下：</p>

<pre class="line-numbers"><code class="language-text">android {
    signingConfigs {
        config {
           keyAlias &#39;yiba&#39;
           keyPassword &#39;123456&#39;
           storeFile file(&#39;C:/work/Key.jks&#39;)
           storePassword &#39;1234567&#39;
       }
   }
} 
</code></pre>

<p>可以在 release 和 debug 包中定义签名，如下：</p>

<pre class="line-numbers"><code class="language-text">android {
    signingConfigs {
        config {
            keyAlias &#39;yiba&#39;
            keyPassword &#39;123456&#39;
            storeFile file(&#39;C:/work/Key.jks&#39;)
            storePassword &#39;1234567&#39;
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            signingConfig signingConfigs.config
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            signingConfig signingConfigs.config
        }
    }
}
</code></pre>

<h2 id="toc_12">依赖管理</h2>

<h3 id="toc_13">依赖 jcenter 包</h3>

<p>每个库名称包含三个元素：组名:库名称:版本号</p>

<p><code>compile &#39;com.android.support:appcompat-v7:25.0.0&#39;</code></p>

<h3 id="toc_14">依赖本地 module</h3>

<p><code>compile project(&#39;:YibaAnalytics&#39;)</code></p>

<h3 id="toc_15">依赖 jar 包</h3>

<ul>
<li>把 jar 包放在 libs 目录下</li>
<li>在 build.gradle 中添加依赖</li>
</ul>

<pre class="line-numbers"><code class="language-text">dependencies {
   compile files(&#39;libs/YibaAnalytics5.jar&#39;)
}
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920619455522.png" alt="20171028150920619455522.png"/><figcaption>20171028150920619455522.png</figcaption></figure></p>

<h3 id="toc_16">依赖 aar 包</h3>

<ul>
<li>把 aar 包放到 libs 目录下</li>
<li>在 build.gradle 中添加依赖</li>
</ul>

<pre class="line-numbers"><code class="language-text">repositories {
    flatDir {
        dirs &#39;libs&#39;
    }
}

dependencies {
    compile(name:&#39;YibaAnalytics-release&#39;, ext:&#39;aar&#39;)
}
</code></pre>

<p>如图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920622394032.png" alt="20171028150920622394032.png"/><figcaption>20171028150920622394032.png</figcaption></figure></p>

<ul>
<li>自定义依赖包目录</li>
</ul>

<p>当我们的 aar 包需要被多个 module 依赖时，我们就不能把 aar 包放在单一的 module 中，我们可以在项目的根目录创建一个目录，比如叫 aar 目录，然后把我们的 aar 包放进去，如图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920623519197.png" alt="20171028150920623519197.png"/><figcaption>20171028150920623519197.png</figcaption></figure></p>

<p>在项目的根目录的 build.gradle 的 allprojects 标签下的 repositories 添加 ：</p>

<pre class="line-numbers"><code class="language-text"> flatDir {
     dirs &#39;../aar&#39;
}
</code></pre>

<p>../aar 表示根目录下的 aar 文件夹。</p>

<p>如图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920625348073.png" alt="20171028150920625348073.png"/><figcaption>20171028150920625348073.png</figcaption></figure></p>

<p>然后就可以添加依赖了，如下所示：</p>

<p><code>compile(name:&#39;YibaAnalytics-release&#39;, ext:&#39;aar&#39;)</code></p>

<h3 id="toc_17">依赖配置</h3>

<p>有些时候，你可能需要和sdk协调工作。为了能顺利编译你的代码，你需要添加SDK到你的编译环境。你不需要将sdk包含在你的APK中，因为它早已经存在于设备中，所以配置来啦，我们会有5个不同的配置：</p>

<ul>
<li>compile</li>
<li>apk</li>
<li>provided</li>
<li>testCompile</li>
<li>androidTestCompile</li>
</ul>

<p>compile是默认的那个，其含义是包含所有的依赖包，即在APK里，compile的依赖会存在。</p>

<p>apk的意思是apk中存在，但是不会加入编译中，这个貌似用的比较少。</p>

<p>provided的意思是提供编译支持，但是不会写入apk。</p>

<h3 id="toc_18">排除依赖兼容包</h3>

<p>有时候我们在引入依赖包的时候，会额外的引入 v7, v4 的包，对我们的项目造成额外的负担，我们需要把这个兼容包排除，可以使用 exclude 就能做到。</p>

<pre class="line-numbers"><code class="language-text">compile(&#39;com.google.firebase:firebase-ads:11.0.4&#39;, {
      exclude group: &#39;com.android.support&#39;   //排除v7 , v4 包
})
</code></pre>

<h2 id="toc_19">native包（so包）</h2>

<p>用c或者c++写的library会被叫做so包，Android插件默认情况下支持native包，你需要把.so文件放在对应的文件夹中：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920630815374.png" alt="20171028150920630815374.png"/><figcaption>20171028150920630815374.png</figcaption></figure></p>

<p><strong>注意</strong></p>

<p>jniLibs 目录应该和 Java 目录在同一级</p>

<h2 id="toc_20">defaultConfig 详解</h2>

<p>defaultConfig 对应的是 ProductFlavor 类。</p>

<h2 id="toc_21">resConfigs ： 过滤语言</h2>

<p>如果你的app中仅支持1,2种语言，但是可能引用的lib库包含多种其他语言的strings资源，这个时候我们可以通过resConfig指定我们需要的strings资源。</p>

<pre class="line-numbers"><code class="language-text">android {

    defaultConfig {
        applicationId &quot;com.yiba.sharewe.lite.activity&quot;
        minSdkVersion 14
        targetSdkVersion 24
        versionCode 46
        versionName &quot;1.74&quot;
        resConfigs &#39;en&#39;, &#39;zh-rCN&#39; ,&#39;es&#39;  //本次打包，只把 en(英文)、zh-rCN(中文简体)、es（西班牙语）打进保内，其他语言忽略
    }
}
</code></pre>

<h2 id="toc_22">resConfigs ： 过滤 drawable文件夹的资源</h2>

<p>一般情况下，我们打完包，res 下面的资源如图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920635182429.png" alt="20171028150920635182429.png"/><figcaption>20171028150920635182429.png</figcaption></figure></p>

<p>现在加上资源过滤规则：</p>

<pre class="line-numbers"><code class="language-text">android {
    defaultConfig {
        applicationId &quot;com.wifi.analytics&quot;
        minSdkVersion 9
        targetSdkVersion 25
        versionCode 1
        versionName &quot;1.0&quot;
        resConfigs &quot;hdpi&quot;  //打包的时候只保留 drawable-xhdpi 文件夹里面的资源
    }
}
</code></pre>

<p>这次我们打包效果如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171028150920637414691.png" alt="20171028150920637414691.png"/><figcaption>20171028150920637414691.png</figcaption></figure></p>

<h2 id="toc_23">buildTypes 详解</h2>

<p><a href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html">官方文档</a></p>

<p>buildTypes{}对应的是 BuildType 类</p>

<p><strong>继承关系</strong></p>

<p>BuildType 继承 DefaultBuildType ； DefaultBuildType 继承 BaseConfigImpl ；</p>

<pre class="line-numbers"><code class="language-text">BaseConfigImpl
    --- DefaultBuildType 
          --- BuildType
</code></pre>

<p><strong>buildTypes的属性</strong>：</p>

<pre class="line-numbers"><code class="language-text">name：build type的名字

applicationIdSuffix：应用id后缀

versionNameSuffix：版本名称后缀

debuggable：是否生成一个debug的apk

minifyEnabled：是否混淆

proguardFiles：混淆文件

signingConfig：签名配置

manifestPlaceholders：清单占位符

shrinkResources：是否去除未利用的资源，默认false，表示不去除。

zipAlignEnable：是否使用zipalign工具压缩。

multiDexEnabled：是否拆成多个Dex

multiDexKeepFile：指定文本文件编译进主Dex文件中

multiDexKeepProguard：指定混淆文件编译进主Dex文件中
</code></pre>

<p><strong>buildType的方法</strong>：</p>

<pre class="line-numbers"><code class="language-text">1.buildConfigField(type,name,value)：添加一个变量生成BuildConfig类。

2.consumeProguardFile(proguardFile)：添加一个混淆文件进arr包。

3.consumeProguardFile(proguardFiles)：添加混淆文件进arr包。

4.externalNativeBuild(action)：配置本地的build选项。

5.initWith：复制这个build类型的所有属性。

6.proguardFile(proguardFile)：添加一个新的混淆配置文件。

7.proguradFiles(files):添加新的混淆文件

8.resValue(type,name,value)：添加一个新的生成资源

9.setProguardFiles(proguardFileIterable):设置一个混淆配置文件。
</code></pre>

<h2 id="toc_24">initWith ：复制属性</h2>

<pre class="line-numbers"><code class="language-text">android {
    compileSdkVersion 25
    buildToolsVersion &quot;25.0.2&quot;
    defaultConfig {
        applicationId &quot;com.wifi.analytics&quot;
        minSdkVersion 9
        targetSdkVersion 25
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }

        myType {
            initWith debug  //完全复制 debug 的所有属性‘
            minifyEnabled true //自定义打开混淆
        }
    }
}
</code></pre>

<h2 id="toc_25">applicationIdSuffix 、versionNameSuffix ：添加后缀</h2>

<pre class="line-numbers"><code class="language-text">android {
    compileSdkVersion 25
    buildToolsVersion &quot;25.0.2&quot;
    defaultConfig {
        applicationId &quot;com.wifi.analytics&quot;
        minSdkVersion 9
        targetSdkVersion 25
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            applicationIdSuffix &quot;zhao&quot;  //applicationId 追加后缀名 zhao
            versionNameSuffix &quot;debug&quot;  //versionName 追加后缀名 debug1.0
        }
    }
}
</code></pre>

<p>效果图，如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920649886369.png" alt="20171029150920649886369.png"/><figcaption>20171029150920649886369.png</figcaption></figure></p>

<h2 id="toc_26">buildConfigField： 自定义属性</h2>

<p>在 build.gradle 文件中定义 buildConfigField 属性</p>

<pre class="line-numbers"><code class="language-text">android {

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            buildConfigField &quot;String&quot;, &quot;API_ENV&quot;, &quot;\&quot;http://yiba.com\&quot;&quot;  //自定义String属性
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            buildConfigField &quot;String&quot;, &quot;API_ENV&quot;, &quot;\&quot;http://yiba.com\&quot;&quot;  //自定义String属性
        }
    }
}
</code></pre>

<p>然后点击同步按钮，然后就可以在 build 目录看到 debug 和 release 信息。</p>

<p>debug 环境下的 BuildConfig 如下： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920652322417.png" alt="20171029150920652322417.png"/><figcaption>20171029150920652322417.png</figcaption></figure></p>

<p>release 环境下的 BuildConfig 如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920653292275.png" alt="20171029150920653292275.png"/><figcaption>20171029150920653292275.png</figcaption></figure></p>

<p>当然我们也可以在代码中获取自定义的值：</p>

<pre class="line-numbers"><code class="language-text">//获取变量值
String API = BuildConfig.API_ENV ;
</code></pre>

<p>上面演示了自定义 String 变量，也可以 自定义 int 、boolean</p>

<pre class="line-numbers"><code class="language-text">android {

    buildTypes {
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            buildConfigField &quot;String&quot;, &quot;API_ENV&quot;, &quot;\&quot;http://www.baidu.com\&quot;&quot; //自定义 String 值
            buildConfigField &quot;Boolean&quot;, &quot;openLog&quot;, &quot;true&quot; //自定义 boolean 值
            buildConfigField &quot;int&quot;, &quot;age&quot;, &quot;10&quot;   //自定义 int 值
        }
    }
}
</code></pre>

<h2 id="toc_27">Gradle 实现差异化构建</h2>

<h3 id="toc_28">情景1</h3>

<p>LeakCanary 是 square 公司出品的一个检测内存泄漏的开源库。</p>

<p>GitHub ： <a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></p>

<p>我们一般这样集成</p>

<pre class="line-numbers"><code class="language-text">dependencies {
    compile &#39;com.squareup.leakcanary:leakcanary-android:1.5.2&#39;
}
</code></pre>

<p>然后我们在 Application 类中初始化：</p>

<pre class="line-numbers"><code class="language-text">public class MyApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        LeakCanary.install(this);
    }
}
</code></pre>

<p>但是这样集成有一个弊端，就是 debug 和 release 包都会把 LeakCanary 的源码打进去，如果我们在 release 包中不把 LeakCanary 源码打进去，怎么办？ 还好 LeakCanary 给我们提供了一个方法，方法如下：</p>

<pre class="line-numbers"><code class="language-text">dependencies {

 //打 debug 包
 debugCompile &#39;com.squareup.leakcanary:leakcanary-android:1.5.1&#39;

 //打 release 包
 releaseCompile &#39;com.squareup.leakcanary:leakcanary-android-no-op:1.5.1&#39;

}
</code></pre>

<p>leakcanary-android-no-op 是一个空壳，里面有2个空类，所以就可以避免把 LeakCanary 源码打进 release 包。但是这种方式有个缺陷，如果一些开源库没有提供 releaseCompile 库，那我们改怎么办了？下面的情景2 就会讲到解决方案。</p>

<h3 id="toc_29">情景2</h3>

<p>Stetho 是 Faceboo k开源的Andorid调试工具。当你的应用集成Stetho时，开发者可以访问Chrome，在Chrome Developer Tools中查看应用布局，网络请求，sqlite，preference 等等。</p>

<p>官网：<a href="http://facebook.github.io/stetho/">http://facebook.github.io/stetho/</a></p>

<p>从官网可以看到 stetho 没有提供 releaseCompile 包 ， 情景1 的方案就不能用了。新的思路集成方案如下：</p>

<pre class="line-numbers"><code class="language-text">dependencies {
    debugCompile &#39;com.facebook.stetho:stetho:1.5.0&#39;
}
</code></pre>

<p>在 src 目录下创建 debug 目录、release 目录 ，然后分别在 debug 目录 和 release 目录 创建 java 目录 ， 在 java 目录中创建包名，比如： com.app , 如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920663742117.png" alt="20171029150920663742117.png"/><figcaption>20171029150920663742117.png</figcaption></figure></p>

<p>debug 目录下创建 SDKManage 类 ，如下 ：</p>

<pre class="line-numbers"><code class="language-text">public class SDKManager {

    public static void init(Context context) {
        //初始化 Stetho
        Stetho.initializeWithDefaults(context);
    }
}
</code></pre>

<p>release 目录下创建 SDKManage 类 ，如下 ：</p>

<pre class="line-numbers"><code class="language-text">public class SDKManager {

    public static void init(Context context) { 
        //这是一个空方法，目的是不引入 Stetho 源码
    }
}
</code></pre>

<p>在住项目中的 MyApplication 类，并且完成 Stetho 的初始化，如下：</p>

<pre class="line-numbers"><code class="language-text">public class MyApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        SDKManager.init(this);
    }
}
</code></pre>

<p>这样我们便完成了简单的差异化构建, 打出来的 release 包就没有 Stetho 源码。</p>

<h2 id="toc_30">SourceSet</h2>

<h3 id="toc_31">SourceSet 简介</h3>

<p>SourceSet 可以定义项目结构，也可以修改项目结构。Java插件默认实现了两个SourceSet，main 和 test。每个 SourceSet 都提供了一系列的属性，通过这些属性，可以定义该 SourceSet 所包含的源文件。比如，java.srcDirs，resources.srcDirs 。Java 插件中定义的其他任务，就根据 main 和 test 的这两个 SourceSet 的定义来寻找产品代码和测试代码等。</p>

<h3 id="toc_32">SourceSet 定义源码目录</h3>

<p>在 Android 项目中，我们可以在 src/main/java 目录新建 Java 文件，如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920668425492.png" alt="20171029150920668425492.png"/><figcaption>20171029150920668425492.png</figcaption></figure></p>

<p>现在我们在 src 目录下，新建 test1 目录 ，发现不能在 test1 目录中新建 Java 文件，如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920669347940.png" alt="20171029150920669347940.png"/><figcaption>20171029150920669347940.png</figcaption></figure></p>

<p>为什么在 test1 目录不能新建 Java 文件，因为 Gradle 中 SourceSet 默认定义的源码文件路径是src/main/java , 其他的文件下下面的源码我们自然无法访问。解决这个问题也很简单，我们需要在 SourceSet 中增加一个源码路径即可。如下所示：</p>

<pre class="line-numbers"><code class="language-text">android {

    sourceSets {
        main {
            java {
                srcDir &#39;src/test1&#39; //指定源码目录
            }
        }
    }
}
</code></pre>

<p>然后同步一下，就可以在 test1 目录中新建 Java 文件了。如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920675182396.png" alt="20171029150920675182396.png"/><figcaption>20171029150920675182396.png</figcaption></figure></p>

<p>当然我们也可以同时指定多个源码目录，比如同时指定 test1 , test2 , test3 为源码目录。</p>

<pre class="line-numbers"><code class="language-text">android {

    sourceSets {
        main {
            java {
                srcDir &#39;src/test1&#39; //指定 test1 为源码目录
                srcDir &#39;src/test2&#39; //指定 test2 为源码目录
                srcDir &#39;src/test3&#39; //指定 test3 为源码目录
            }
        }
    }
}
</code></pre>

<p>或者 这样写 ：</p>

<pre class="line-numbers"><code class="language-text">android {
    sourceSets {
        main {
            java.srcDirs( &#39;src/test1&#39; , &#39;src/test2&#39; ,&#39;src/test3&#39; )
        }
    }
}
</code></pre>

<p>效果如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920677817619.png" alt="20171029150920677817619.png"/><figcaption>20171029150920677817619.png</figcaption></figure></p>

<h3 id="toc_33">SourceSet 定义资源目录</h3>

<p>定义 test1 目录 Java 源代码路径、res 资源目录。目录结构如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920679824349.png" alt="20171029150920679824349.png"/><figcaption>20171029150920679824349.png</figcaption></figure></p>

<pre class="line-numbers"><code class="language-text">android {

    sourceSets {
        main {
            java.srcDirs(&#39;src/test1/java&#39;)  //定义java 源代码
            res.srcDirs(&#39;src/test1/res&#39;)    //定义资源目录（layout , drawable,values）
        }
    }
}
</code></pre>

<h3 id="toc_34">SourceSet 实现 layout 分包</h3>

<p>对于一个大项目来说，页面太多，布局文件就很多，有时在众多布局文件中找某个模块的布局文件，很是痛苦，为了解决这个问题，我们可以在创建多个 layout 目录，不同模块的布局文件放在不同的 layout 目录中，这样查找起来，就容易很多。</p>

<p>例子：</p>

<p>比如我们的项目中，有两个模块分别为：登录、注册。</p>

<ul>
<li><p>第一步：把项目中 layout 文件夹改名字为 layouts</p></li>
<li><p>第二步：在 layouts 目录下，分别创建 login 、register 目录 。</p></li>
<li><p>第三步：分别在 login 、register 目录下创建 layout 目录。注意这一步是必须的，否则会报错。</p></li>
<li><p>第四步：把 登录布局文件、注册布局文件 分别放在 第三步创建的对应的 layout 目录下。</p></li>
</ul>

<p>效果图如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920685572520.png" alt="20171029150920685572520.png"/><figcaption>20171029150920685572520.png</figcaption></figure></p>

<p>SourceSet 实现如下：</p>

<pre class="line-numbers"><code class="language-text">android {

    sourceSets {
        main {
            res.srcDirs &#39;src/main/res/layouts/login&#39;  //定义登录布局目录
            res.srcDirs &#39;src/main/res/layouts/register&#39;  //定义注册布局目录
        }
    }
}
</code></pre>

<h3 id="toc_35">SourceSet 定义 AndroidManifest 文件</h3>

<p>指定 test1 目录下的 AndroidManifest 文件。项目结构如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920687997782.png" alt="20171029150920687997782.png"/><figcaption>20171029150920687997782.png</figcaption></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-text">android {

    sourceSets {
        main {
            manifest.srcFile &#39;src/test1/AndroidManifest.xml&#39;
        }
    }
}
</code></pre>

<p>在组件化开发中, 我们需要针对 debug 与 release 模式下, 指定不同的 Manifest 文件, 代码如下：</p>

<pre class="line-numbers"><code class="language-text">android {
    def appDebug = false;

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            appDebug = false;
        }

        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
            appDebug = false;
        }
    }

    sourceSets {
        main {
            if (appDebug) {
                manifest.srcFile &#39;src/test1/AndroidManifest.xml&#39;
            } else {
                manifest.srcFile &#39;src/main/AndroidManifest.xml&#39;
            }
        }
    }
}
</code></pre>

<h3 id="toc_36">SourceSet 定义 assets 目录</h3>

<p>Android Studio 项目目录中，assets 默认目录如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920691136995.png" alt="20171029150920691136995.png"/><figcaption>20171029150920691136995.png</figcaption></figure></p>

<p>如何重新定义 assets 目录 。在项目的根目录下创建 assets 目录，如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171029150920691863996.png" alt="20171029150920691863996.png"/><figcaption>20171029150920691863996.png</figcaption></figure></p>

<p>sourceSets 定义代码如下：</p>

<pre class="line-numbers"><code class="language-text">android {

    sourceSets {
        main {
            assets.srcDirs = [&#39;assets&#39;]
        }
    }
}
</code></pre>

<h3 id="toc_37">SourceSet 定义其他资源</h3>

<pre class="line-numbers"><code class="language-text">android {

    sourceSets {
        main {
            jniLibs.srcDirs  //定义 jni 目录
            aidl.srcDirs  //定义 aidl 目录
        }
    }
}
</code></pre>

<h2 id="toc_38">applicationVariants</h2>

<h3 id="toc_39">定义 versionName 、VersionCode</h3>

<p>在打包的时候分 debug 、release 版本 , 需要控制 versionName</p>

<pre class="line-numbers"><code class="language-text">android {

     applicationVariants.all { variant -&gt;
        def flavor = variant.mergedFlavor
        def versionName = flavor.versionName
        if (variant.buildType.isDebuggable()) {
            versionName += &quot;_debug&quot;  //debug 名字
        } else {
            versionName += &quot;_release&quot; //release 名字
        }
        flavor.versionName = versionName
    }
}
</code></pre>

<h3 id="toc_40">定义 APK 包的名字</h3>

<pre class="line-numbers"><code class="language-text">apply plugin: &#39;com.android.application&#39;

android {

    defaultConfig {
        applicationId &quot;android.plugin&quot;
        minSdkVersion 14
        targetSdkVersion 25
        versionCode 1
        versionName &quot;1.0&quot;
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }

    //定义渠道
    productFlavors {
        xiaomi {
            //小米
        }
        wandoujia {
            // 豌豆荚
        }
    }

    //打包命名
    applicationVariants.all {
        variant -&gt;
            variant.outputs.each {
                output -&gt;

                    //定义一个新的apk 名字。
                    // 新名字 = app 名字+ 渠道号 + 构建类型 + 版本号 + 当前构建时间
                    def apkName = &quot;appName_${variant.flavorName}_${buildType.name}_v${variant.versionName}_${getTime()}.apk&quot;;
                    output.outputFile = new File(output.outputFile.parent, apkName);
            }
    }

}

//获取当前时间
def getTime() {
    String today = new Date().format(&#39;YY年MM月dd日HH时mm分&#39;)
    return today
}
</code></pre>

<p>效果图如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017102915092069934597.png" alt="2017102915092069934597.png"/><figcaption>2017102915092069934597.png</figcaption></figure></p>

<h2 id="toc_41">Task</h2>

<h3 id="toc_42">定义 task</h3>

<pre class="line-numbers"><code class="language-text">//定义任务1
task task1&lt;&lt;{
    println &#39;task1&#39;
}

//定义任务2
task task2&lt;&lt;{
    println &#39;task2&#39;
}
</code></pre>

<h3 id="toc_43">mustRunAfter 定义 task 执行顺序</h3>

<pre class="line-numbers"><code class="language-text">//task2 的执行顺讯在 task1 之后
task2.mustRunAfter task1
</code></pre>

<ul>
<li>测试1 ： gradlew task1<br/></li>
</ul>

<p>效果如下：</p>

<pre class="line-numbers"><code class="language-text">:app:task1
task1
</code></pre>

<ul>
<li>测试2 ： gradlew task2<br/></li>
</ul>

<p>效果如下：</p>

<pre class="line-numbers"><code class="language-text">:app:task2
task2
</code></pre>

<ul>
<li>测试3 ： gradlew task1 task2<br/></li>
</ul>

<p>效果如下：</p>

<pre class="line-numbers"><code class="language-text">:app:task1
task1
:app:task2
task2
</code></pre>

<ul>
<li>测试4 ： gradlew task2 task1<br/></li>
</ul>

<p>效果如下：</p>

<pre class="line-numbers"><code class="language-text">:app:task1
task1
:app:task2
task2
</code></pre>

<h3 id="toc_44">结论</h3>

<p>如果单独执行 task1 就只会执行 task1 的任务；单独执行 task2 就只会执行 task2 的任务； <br/>
如果同时执行 task1、task2 , 一定会先执行 task1 , 等 task1 执行完后，就会执行 task2 内容。</p>

<h3 id="toc_45">扩展</h3>

<p>上面 mustRunAfter 我们还有一种写法，如下图所示：</p>

<p><code>task2 {}.mustRunAfter task1</code></p>

<p>这个写法的效果和 mustRunAfter 是一样的，当然我们还可以在 花括号里面写一些任务，比如 ：</p>

<pre class="line-numbers"><code class="language-text">task2 {
    println &#39;我最先执行&#39;
}.mustRunAfter task1
</code></pre>

<p>下面做个测试，测试命令如下：</p>

<p><code>gradlew task2 task1</code></p>

<p>效果如下：</p>

<pre class="line-numbers"><code class="language-text">我最先执行

:app:task1
task1
:app:task2
task2
</code></pre>

<h3 id="toc_46">dependsOn 定义 task 依赖</h3>

<p>task2 任务依赖于 task1 ,执行 task2 就会先执行 task1</p>

<p><code>task2.dependsOn task1</code></p>

<p>测试：</p>

<p><code>gradlew task2</code></p>

<p>效果如下：</p>

<pre class="line-numbers"><code class="language-text">:app:task1
task1
:app:task2
task2
</code></pre>

<h2 id="toc_47">常用 Gradlew 命令</h2>

<ul>
<li>1、gradlew -v : 查看版本号</li>
</ul>

<pre class="line-numbers"><code class="language-text">------------------------------------------------------------
Gradle 3.3
------------------------------------------------------------

Build time:   2017-01-03 15:31:04 UTC
Revision:     075893a3d0798c0c1f322899b41ceca82e4e134b

Groovy:       2.4.7
Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015
JVM:          1.8.0_112 (Oracle Corporation 25.112-b15)
OS:           Windows 10 10.0 amd64
</code></pre>

<ul>
<li>2、gradlew task ： 查看所有的 task</li>
</ul>

<h2 id="toc_48">参考资料</h2>

<p><a href="http://www.jianshu.com/p/80e1f4a80d06#">Android 利用Gradle实现差异化构建</a></p>

<p><a href="http://www.jianshu.com/p/011b8d63ba78">杨海 Android目录结构</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-04T22:09:27+08:00" itemprop="datePublished">2017/9/4</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207871067.html" itemprop="url">
		Android App性能优化全方面解析</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">内存优化</h2>

<p>关于性能优化我们可以不知道其他的，但一定要知道内存优化。因为内存泄漏可以Android的常客。那么什么是内存泄漏呢？内存不在GC的掌控范围之内了。那么java的GC内存回收机制是什么？某对象不在有任何引用的时候才会进行回收。那么GC回收机制的原理是什么？又或者说可以作为GC　Root引用点的是啥？或许有人听不懂我在讲啥。我们先来看张图。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938120277154.png" alt="20171031150938120277154.png"/><figcaption>20171031150938120277154.png</figcaption></figure></p>

<p>当我们向上寻找，一直寻找到GC Root的时候，此对象不会进行回收，例如，一个Activity。那么如果我们向上寻找，直到找到GC Root对象的时候，就说明它是不可以回收的，例如，我定义了一个int a；但是这个数据，我整个页面或者说整个项目都没有用到，则这个对象会被GC掉。</p>

<h3 id="toc_1">GC的引用点</h3>

<ul>
<li>java栈中引用的对象</li>
<li>方法静态引用的对象</li>
<li>方法常量引用的对象</li>
<li>Native中JNI引用的对象</li>
<li>Thread——“活着的”线程</li>
</ul>

<h3 id="toc_2">如何判断</h3>

<p>那么我们如何判断一个对象是一个垃圾对象，可以讲他进行回收呢？举了小例子教你们如何区分：</p>

<blockquote>
<p>一般在学校吃饭，我们有两种情况，第一：吃完饭就直接走人，碗筷留给阿姨来收拾处理。<br/>
第二：吃完之后把碗筷放到收盘处直接进行回收。<br/>
但我们是个有素质的人，一般采用第二种情况，但根据想法，我们更倾向于第一种。<br/>
那么一般在饭店或者KFC中，都是第一种情况。<br/>
那么此时，问题来了，如果我已经吃完饭，然后我并没有离开饭店，做在位置上和朋友吹吹牛逼，谈谈理想，聊聊人生。<br/>
那么桌上那一堆碗筷是收还是不收？讲道理是不能收的。虽然实际也是不能收的。因为顾客是上帝~~~</p>
</blockquote>

<p>So，我们如何判断一个对象是一个可回收的垃圾对象呢？这是我们的一个主观的判断。但是有种情况我们是必须要考虑到的，没错，就是内存过多无法释放的时候，会直接导致OOM。整个项目boom炸了。什么鬼？outofmemory。没错就是它。</p>

<h2 id="toc_3">内存溢出</h2>

<h3 id="toc_4">分析原因</h3>

<p>我们需要分析内存溢出的原因，我们先来看一张图： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938126840752.png" alt="20171031150938126840752.png"/><figcaption>20171031150938126840752.png</figcaption></figure></p>

<p>内存泄漏一般导致应用卡顿，极端情况会导致项目boom。Boom的原因是因为超过内存的阈值。 <br/>
原因主要有两方面：</p>

<ul>
<li>代码存在泄漏，内存无法及时释放导致oom（这个我们后面说）</li>
<li>一些逻辑消耗了大量内存，无法及时释放或者超过导致oom</li>
</ul>

<p>所谓消耗大量的内存的，绝大多数是因为图片加载。这是我们oom出现最频繁的地方。我前面有写过图片加载的方法，一个是控制每次加载的数量，第二，保证每次滑动的时候不进行加载，滑动完进行加载。一般情况使用先进后出，而不是先进先出。不过一般我们图片加载都是使用fresco或者Glide等开源库。 </p>

<p>我们来看下下面两张图： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938130233770.png" alt="20171031150938130233770.png"/><figcaption>20171031150938130233770.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938131538861.png" alt="20171031150938131538861.png"/><figcaption>20171031150938131538861.png</figcaption></figure></p>

<p>对比两张图，我们可以在第一张的情况出现了oom情况，我们通过log打印发现，处理的好像没什么问题，换句话说，如果我不放那0.8M的图片。然后继续不停的操作同样会出现OOM，然而我们就蒙了。没什么图片加载怎么就这么崩掉了。</p>

<h3 id="toc_5">如何查看</h3>

<p>首先，我们确定我们项目或者某几个类里面是否存在内存溢出的问题。我们可以通过如下方法：</p>

<ul>
<li>Android–&gt;System Information–&gt;MemoryUsage查看Object里面是否有没有被释放的Views和Activity</li>
<li>命令行模式：adb shell dumpsys meminfo 包名 -d</li>
</ul>

<p>就那我公司的项目举例把。首先，我们在这边可以看到memory。CPU和net的使用情况。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938135867093.png" alt="20171031150938135867093.png"/><figcaption>20171031150938135867093.png</figcaption></figure></p>

<p>我们找到Object。看看我们内存的消耗情况。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938138041717.png" alt="20171031150938138041717.png"/><figcaption>20171031150938138041717.png</figcaption></figure></p>

<p>随便这么一看，尼玛蛋，1300左右的view和一个Activity。还有3个context。可怕。。可以理解为一个Activity里面使用了将近1300个view。。。想都不敢想。。。</p>

<p>我们可以通过看Memory Monitor工具。 检查一个一个的动作。（比如Activity的跳转）。反复多次执行某一个操作，不断的通过这个工具查看内存的大概变化情况。 前后两个内存变化增加了不少。</p>

<p>我们可以更仔细的查找泄漏的位置，在AS里面使用 Heap SnapShot工具（堆栈快照）。如图所示： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938142116483.png" alt="20171031150938142116483.png"/><figcaption>20171031150938142116483.png</figcaption></figure></p>

<p>我们点击后，他会进行一段时间的监控，然后会生成一个文件。我们点击我们package tree view。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938144979816.png" alt="20171031150938144979816.png"/><figcaption>20171031150938144979816.png</figcaption></figure></p>

<p>我们找到自己项目的包名。然后进行进一步的分析。首先看一下2个列表的列名到底指的什么。 </p>

<p>实例化对象的详细信息： </p>

<table>
<thead>
<tr>
<th style="text-align: center">名称</th>
<th style="text-align: center">意义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Total Count</td>
<td style="text-align: center">内存中该类的对象个数</td>
</tr>
<tr>
<td style="text-align: center">Heap Count</td>
<td style="text-align: center">堆内存中该类的对象个数</td>
</tr>
<tr>
<td style="text-align: center">Sizeof</td>
<td style="text-align: center">物理大小</td>
</tr>
<tr>
<td style="text-align: center">Shallow size</td>
<td style="text-align: center">该对象本身占有内存大小</td>
</tr>
<tr>
<td style="text-align: center">Retained Size</td>
<td style="text-align: center">释放该对象后，节省的内存大小</td>
</tr>
<tr>
<td style="text-align: center">depth</td>
<td style="text-align: center">深度</td>
</tr>
<tr>
<td style="text-align: center">Dominating Size</td>
<td style="text-align: center">管辖的内存大小</td>
</tr>
</tbody>
</table>

<p>我们来随便的看一下内存中的数量： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938170331677.png" alt="20171031150938170331677.png"/><figcaption>20171031150938170331677.png</figcaption></figure></p>

<p>这还是我们刚进手机，一个bean就被调用了这么多次。简直可怕。这个我们可以通过内存分析工具解决的。</p>

<h2 id="toc_6">内存分析工具</h2>

<p><strong>性能优化工具</strong>：</p>

<ul>
<li>Heap SnapShot工具</li>
<li>Heap Viewer工具</li>
<li>LeakCanary工具</li>
<li>MAT工具</li>
<li>TraceView工具（Device Monitor）</li>
</ul>

<p><strong>第三方分析工具</strong>：</p>

<ul>
<li>MemoryAnalyzer</li>
<li>GT Home</li>
<li>iTest <br/>
　　 <br/>
因为我没有这些工具，无法进行演示。</li>
</ul>

<h3 id="toc_7">注意事项</h3>

<ul>
<li><p>我们尽量不要使用Activity的上下文，而是使用application的上下文，因为application的生命周期长，进程退出时才会被销毁。所以，单例模式是最容易造成内存溢出的原本所在，因为单例模式的生命周期的应该和application的生命周期一样长，而不是和Activity的相同。</p></li>
<li><p>Animation也会导致内存溢出，为什么？因为我们是通过view来进行演示的，导致view被Activity持有，而Activity又持有view。最后因为Activity无法释放，导致内存泄漏。解决方法是在Activity的ondestory（）方法中调用Animation.cancle（）进行停止，当然一些简单的动画我们可以通过自定义view来解决。至少我现在已经很少使用Animation了。没有一个动画是自定义view解决不了的。如何有，那就是两个~~~。</p></li>
</ul>

<h2 id="toc_8">UI优化</h2>

<p>UI优化主要包括布局优化以及view的绘制优化。不急，我们接下来一个一个慢慢看~~。先说下UI的优化到底是什么？有些时候我们打开某个软件，会出现卡顿的情况。这就是UI的问题。那么我们想一下，什么情况会导致卡顿呢？一般是如下几种情况：</p>

<ul>
<li>人为在UI线程中做轻微耗时操作，导致UI线程卡顿；</li>
<li>布局Layout过于复杂，无法在16ms内完成渲染；</li>
<li>同一时间动画执行的次数过多，导致CPU或GPU负载过重；</li>
<li>View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；</li>
<li>View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；</li>
<li>内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；</li>
<li>冗余资源及逻辑等导致加载和执行缓慢；</li>
<li>臭名昭著的ANR；</li>
</ul>

<p>可以看见，上面这些导致卡顿的原因都是我们平时开发中非常常见的。有些人可能会觉得自己的应用用着还蛮OK的，其实那是因为你没进行一些瞬时测试和压力测试，一旦在这种环境下运行你的App你就会发现很多性能问题。</p>

<h2 id="toc_9">布局优化</h2>

<h3 id="toc_10">GPU绘制</h3>

<p>我们对于UI性能的优化还可以通过开发者选项中的GPU过度绘制工具来进行分析。在设置-&gt;开发者选项-&gt;调试GPU过度绘制（不同设备可能位置或者叫法不同）中打开调试后可以看见如下图（对settings当前界面过度绘制进行分析）： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938187814302.png" alt="20171031150938187814302.png"/><figcaption>20171031150938187814302.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938189533910.png" alt="20171031150938189533910.png"/><figcaption>20171031150938189533910.png</figcaption></figure></p>

<p>这图看着太乱，我们来一张简洁明了的图： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017103115093819223109.png" alt="2017103115093819223109.png"/><figcaption>2017103115093819223109.png</figcaption></figure></p>

<p>我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。</p>

<p>可以发现，开启后在我们想要调试的应用界面中可以看到各种颜色的区域，具体含义如下： </p>

<table>
<thead>
<tr>
<th style="text-align: center">颜色</th>
<th style="text-align: center">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">无色</td>
<td style="text-align: center">WebView等的渲染区域</td>
</tr>
<tr>
<td style="text-align: center">蓝色</td>
<td style="text-align: center">1* 过度绘制</td>
</tr>
<tr>
<td style="text-align: center">绿色</td>
<td style="text-align: center">2* 过度绘制</td>
</tr>
<tr>
<td style="text-align: center">淡红色</td>
<td style="text-align: center">3* 过度绘制</td>
</tr>
<tr>
<td style="text-align: center">红色</td>
<td style="text-align: center">4*(+) 过度绘制</td>
</tr>
</tbody>
</table>

<p>Overdraw有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。例如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色Overdraw区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。</p>

<p>如果布局中既能采用RealtiveLayout和LinearLayout，那么直接使用LinearLayout，因为Relativelayout的布局比较复杂，绘制的时候需要花费更多的CPU时间。如果需要多个LinearLayout或者Framelayout嵌套，那么可采用Relativelayout。因为多层嵌套导致布局的绘制有大部分是重复的，这会减少程序的性能。</p>

<h3 id="toc_11">GPU呈现模式分析</h3>

<p>我们依旧打开设置–&gt;开发者选项–&gt;GPU呈现模式分析–&gt;在屏幕上显示为条形图，如图所示： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938208067517.png" alt="20171031150938208067517.png"/><figcaption>20171031150938208067517.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938209926269.png" alt="20171031150938209926269.png"/><figcaption>20171031150938209926269.png</figcaption></figure></p>

<p>当然，也可以在执行完UI滑动操作后在命令行输入如下命令查看命令行打印的GPU渲染数据（分析依据：Draw + Process + Execute = 完整的显示一帧时间 &lt; 16ms）：</p>

<p><code>adb shell dumpsys gfxinfo [应用包名]</code></p>

<p>随着界面的刷新，界面上会以实时柱状图来显示每帧的渲染时间，柱状图越高表示渲染时间越长，每个柱状图偏上都有一根代表16ms基准的绿色横线，每一条竖着的柱状线都包含三部分（蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间），只要我们每一帧的总时间低于基准线就不会发生UI卡顿问题（个别超出基准线其实也不算啥问题的）。就简单的看下我们公司项目刚启动的时候,超出基准线好多。 </p>

<p>突然就有那么一种想吐槽的感觉…..我记得之前我做了瘦身的优化，但是要让我做性能优化，我觉得应该没那么简单……..</p>

<h2 id="toc_12">代码优化</h2>

<p>Android Studio和IntellJ idead都有自带的代码检查工具。打开Analyze-&gt;Run Inspection by Name… –&gt;unused resource 点击开始检测，等待一下后会发现如下结果： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938218179898.png" alt="20171031150938218179898.png"/><figcaption>20171031150938218179898.png</figcaption></figure></p>

<p>我们还可以这样，将鼠标放在代码区点击右键-&gt;Analyze-&gt;Inspect Code–&gt;界面选择你要检测的模块-&gt;点击确认开始检测，等待一下后会发现如下结果： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938220134827.png" alt="20171031150938220134827.png"/><figcaption>20171031150938220134827.png</figcaption></figure></p>

<p>当然，我这只是截取了少一部分，我们看下下面那个提示：@param v tag description is missing 。意味着v的类型缺少了，要么补上介绍，要么直接删除。</p>

<p>上面那两种方法是最容易找到代码缺陷以及无用代码的地方。所以尽情的入坑去填坑把~~</p>

<h2 id="toc_13">绘制优化</h2>

<p>那么什么是绘制优化？绘制优化主要是指View的Ondraw方法需要避免执行大量的操作。我将分为了2个方面。</p>

<ul>
<li>ondraw方法不需要创建新的局部对象，这是因为ondraw方法是实时执行的，这样会产品大量的临时对象，导致占用了更多内存，并且使系统不断的GC。降低了执行效率。</li>
<li>Ondraw方法不需要执行耗时操作，在ondraw方法里少使用循环，因为循环会占用CPU的时间。导致绘制不流畅，卡顿等等。Google官方指出，view的绘制帧率稳定在60dps，这要求每帧的绘制时间不超过16ms（1000/60)。虽然很难保证，但我们需要尽可能的降低。</li>
</ul>

<p>60dps是目前最合适的图像显示速度，也是绝大部分Android设备设置的调试频率，如果在16ms内顺利完成界面刷新操作可以展示出流畅的画面，而由于任何原因导致接收到VSYNC信号的时候无法完成本次刷新操作，就会产生掉帧的现象，刷新帧率自然也就跟着下降(假定刷新帧率由正常的60fps降到30fps，用户就会明显感知到卡顿)。So，前面我们说GPU的时候也谈到了这个。总的而言，感觉还是蛮重要的…..</p>

<h2 id="toc_14">网络优化</h2>

<p>线程是我们项目中不可缺少的重要部分，因为我们大多数数据都是从网络获取的。So，线程这个是必备用品。 <br/>
我们依旧可以通过Memory下面的Net进行网络的监听： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938225451445.png" alt="20171031150938225451445.png"/><figcaption>20171031150938225451445.png</figcaption></figure></p>

<h2 id="toc_15">ANR问题</h2>

<p>相信这个问题在座的各种没少遇到过，那么什么是ANR？application not responding。应用程序无响应。那么一般什么时候会出现ANR。Android官方规定：activity如果5s内无响应事件（屏幕触摸事件或者键盘输入事件）。BroadcastReceiver如果在10s内无法处理完成。Service如果20s内无法处理完成。这三种情况会导致ANR。用张简洁的图来介绍把。看起来方便~~ </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017103115093823044615.png" alt="2017103115093823044615.png"/><figcaption>2017103115093823044615.png</figcaption></figure></p>

<h2 id="toc_16">线程优化</h2>

<p>上面说的三种导致ANR的情况，绝大多数就是因为线程阻塞导致的。那么我们应该如何处理呢？Android系统为我们提供了若干组工具类来解决此问题。</p>

<ul>
<li><p><strong>Asynctask</strong>：为UI线程与工作线程之间进行快速处理的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的场景。</p></li>
<li><p><strong>HandlerThread</strong>：为某些回调方法或者等待某些执行任务的执行设置一个专属的线程，并提供线程任务的调度机制。</p></li>
<li><p><strong>ThreadPool</strong>：把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。</p></li>
<li><p><strong>IntentService</strong>：适合执行由Ui触发的后台任务。并可以把这些任务执行的情况通过一定的机制反馈给UI。</p></li>
</ul>

<p>网络请求耗时会给用户带来卡顿的产品体验，虽然可以使用Loading提升用户体验，但属于治标不治本。例如，当网络差的时候我们公司的项目一个loading就是10多s。甚至更多…..我就记得我当时面试之前下了一次我们公司的项目，因为网差的问题…一个loading一分多钟。。当时砸手机的冲动都有了，别说卸软件了….</p>

<p>一般多线程的情况我们可以通过Asynctask处理。（这玩意我真没怎么用过- -）我前面有说过annotation。这是google官方推出的注解。比bufferknife强大很多。这个可以快捷方便的处理多线程而且不会导致线程阻塞，而且你也可以控制线程的顺序，例如我要执行完线程A后，根据线程A的某个参数来执行线程B。以此类推…..</p>

<p>至于线程池么，最多的还是要说道图片加载了~~。图片加载用三方就行了~想看详细介绍，我前面有说，当然除了这个还有下载操作。这就和IntentService有关联了。一般下载我很少涉及到。。用过几次android原生的downloadmanager。。感觉略坑。</p>

<h2 id="toc_17">KO网络优化</h2>

<p>现在讲网络优化的重点了…重点..重点…，一般用到网最最最主要的是什么？时间！！速度！！成功率！！，时间！！速度！！成功率！！，时间！！速度！！成功率！！重要的事说三遍哈。</p>

<h3 id="toc_18">图片处理</h3>

<p>这已经不是第一次在此文提到图片了。可见图片的重要性！！</p>

<ul>
<li>使用WebP格式；同样的照片，采用WebP格式可大幅节省流量，相对于JPG格式的图片，流量能节省将近 25% 到 35 %；相对于 PNG 格式的图片，流量可以节省将近80%。最重要的是使用WebP之后图片质量也没有改变。So，去和后台的小伙伴们商量吧~~</li>
<li>使用缩略图，我在前面写图片加载有说过，就是控制他的inside和option。然后进行图片缩放。压缩？讲道理….我并不知道网络图片怎么压缩，but，我会缩放啊~~反正也不会失真。啦啦啦~咬我啊？</li>
</ul>

<h3 id="toc_19">网络请求处理</h3>

<p>我们可以对服务端返回数据进行缓存，设定有效时间，有效时间之内不走网络请求，减少流量消耗。对网络的缓存可以参见HttpResponseCache。</p>

<p>在某些情况，我们尽量少使用GPS定位，如果条件允许，尽可能使用网络定位。</p>

<p>下载、上传，我们尽可能使用断点，说个简单的，我在公司，准备下一个500M的游戏，但是下到200M的时候我下班了，此时没有了无线网，我们可以回家后用无线继续下载。So，断点续传，断点下载也是我们的必修课~，所以我前面单独提了一篇断点续传的文章。</p>

<p>刷新数据时，尽可能使用局部刷新，而不是全局刷新，第一、界面会闪屏一下，网差的界面直接白屏一段时间也不是不可能。第二、流量的使用！！我又要拿我们公司项目搞事情了。一个闪屏的缓存60+M。。。没错，就是60+M。简直可怕，我清个3、5次缓存，在打开个3、5次。好了，2分钟时间，我一个月流量就没了。。。So，我前面提到的网络缓存很重要，至于会不会加在项目中，我还是要看了在说- - 一个不小心，整个项目炸了都有可能。。。</p>

<h2 id="toc_20">启动优化</h2>

<p>众所周知，一个好的产品，除了功能强大，好的性能也必不可少。有调查显示，近50%的受访者因为apk太大而拒绝使用，近40%的受访者会因为APP性能差而卸载，性能也是造成APP用户沮丧的头号原因。</p>

<p>安卓应用的启动方式分为三种：冷启动、暖启动、热启动，不同的启动方式决定了应用UI对用户可见所需要花费的时间长短。顾名思义，冷启动消耗的时间最长。基于冷启动方式的优化工作也是最考验产品用户体验的地方。谈及优化之前，我们先看看这三种启动方式的应用场景，以及启动过程中系统都做了些什么工作。</p>

<h3 id="toc_21">冷启动</h3>

<p>为什么说冷启动是耗时最长的。冷启动是在启动应用前，系统没有获取到当前app的activity、Service等等。例如，第一次启动app。又或者说杀死进程后第一次启动。那么对比其他两种方式。冷启动自然是耗时最久的。</p>

<p>应用发生冷启动时，系统一定会执行下面的三个任务：</p>

<ul>
<li>开始加载并启动应用</li>
<li>应用启动后，显示一个空白的启动窗口（启动闪屏页）</li>
<li>创建应用信息</li>
</ul>

<p>那么创建应用信息，系统就需要做一屁股的事：</p>

<ul>
<li>application的初始化</li>
<li>启动UI线程</li>
<li>创建Activity</li>
<li>导入视图（inflate view）</li>
<li>计算视图大小（onmesure view）</li>
<li>得到视图排版（onlayout view）</li>
<li>绘制视图（ondraw view）</li>
</ul>

<p>这其中有两个 creation 工作，分别为 Application 和 Activity creation。他们均在 View 绘制展示之前。所以，在应用自定义的 Application 类和 第一个 Activity 类中，onCreate() 方法做的事情越多，冷启动消耗的时间越长。</p>

<h3 id="toc_22">暖启动</h3>

<p>当应用中的 Activities 被销毁，但在内存中常驻时，应用的启动方式就会变为暖启动。相比冷启动，暖启动过程减少了对象初始化、布局加载等工作，启动时间更短。但启动时，系统依然会展示闪屏页，直到第一个 Activity 的内容呈现为止。</p>

<h3 id="toc_23">热启动</h3>

<p>相比暖启动，热启动时应用做的工作更少，启动时间更短。热启动产生的场景很多，常见如：用户使用返回键退出应用，然后马上又重新启动应用。</p>

<h3 id="toc_24">如何优化</h3>

<p>我们先对比下三种启动的时间对比：<br/><br/>
冷启动： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938245458902.png" alt="20171031150938245458902.png"/><figcaption>20171031150938245458902.png</figcaption></figure></p>

<p>暖启动 ： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938246619966.png" alt="20171031150938246619966.png"/><figcaption>20171031150938246619966.png</figcaption></figure></p>

<p>热启动： </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171031150938247843794.png" alt="20171031150938247843794.png"/><figcaption>20171031150938247843794.png</figcaption></figure></p>

<p>我们可以看到三者的明显的差距，一个冷启动将近一分钟，反正我是不想看，每次跑项目都好慢~那么我们应该怎么做？看到有些人介绍说改变项目的theme。把它改成launcher的theme。但我觉得，这种做测试的确没问题。但是一般项目都会有闪屏页。然后从闪屏跳转到首页。我们可以按照大多数的项目来改善。怎么说的，我们可以看到一般项目都有倒计时显示。也就是说倒计时结束就自动进入首页。或者可以直接跳过进入首页。也就是说我们可以通过此方法来进行，也就是说只要他倒计时结束，不管请求是否全部获取完我们都直接进入首页。我们可以在闪屏页进行一些必要的加载，例如用户信息，定位等等，那么至于其他的，我们可以进入主页进行预加载。就和热更新一样，在用户不知情的情况下，默默的更新bug。So，对于一些网络请求，例如广告之类的。我们可以通过此方法进行预加载。</p>

<p>我们还可以这样，闪屏页我们把他当作一个fragment嵌套在MainActivity中，那么我们可以在进入闪屏时直接预加载主页的view。倒计时我们把闪屏页remove掉直接显示首页。</p>

<p>通过上面的介绍，我们对启动优化有了一定的了解，其实总结的话很简单。就是减少耗时操作，总结如下：</p>

<ul>
<li>主线程中涉及到Shareperference能否在非UI线程执行。</li>
<li>Application的创建过程中尽量少的进行耗时操作。</li>
<li>减少布局的层次,并且生命周期回调的方法中尽量减少耗时的操作。</li>
</ul>

<h2 id="toc_25">电量优化</h2>

<p>有了UI优化、内存优化、代码优化、网络优化之后我们在来说说应用开发中很重要的一个优化模块—–电量优化。</p>

<h3 id="toc_26">耗电概念</h3>

<p>其实大多数开发者对电量优化的重视程度极低，其实提到性能优化想到的就是内存优化，但我们不能忽视其他的优化，电量优化其实还是必要的，例如爱奇艺、优酷等等的视频播放器以及音乐播放器。众所周知，音乐和视频其实是耗电量最大的。如果用户一旦发现我们的应用非常耗电，不好意思，他们大多会选择卸载来解决此类问题。为此，我们需要进行优化。</p>

<h3 id="toc_27">如何优化</h3>

<p>其实我们把上面那四种优化解决了，就是最好的电量优化。So，对于电量优化，我在此提一些建议：</p>

<ul>
<li>需要进行网络请求时，我们需先判断网络当前的状态。</li>
<li>在多网络请求的情况下，最好进行批量处理，尽量避免频繁的间隔网络请求。</li>
<li>在同时有wifi和移动数据的情况下，我们应该直接屏幕移动数据的网络请求，只有当wifi断开时在调用，因为，wifi请求的耗电量远比移动数据的耗电量低的低。</li>
<li>后台任务要尽可能少的唤醒CPU。（比方说，锁屏时，QQ的消息提示行就是唤醒了CPU。但是它的提示只有在你打开锁屏或者进行充电时才会进行提示。）</li>
</ul>

<h2 id="toc_28">优化总结</h2>

<p>性能优化是我们进阶的毕竟之路。So，我们必须要会，至于“会”到什么程度，就要看个人理解了。其实，上面介绍的只是性能问题的冰山一角，真正的优化，我们是在项目中总结出来的。但，我们不能一味的追求优化，就例如我，现在只是在进行优化的总结，而对于真正的实行，并没有开始，因为，优化是有风险的，一个不小心，整个项目都可能炸了。所以这就需要你的经验，以及各种总结，在改进行优化的地方先进行优化，看看效果如何，例如，UI的优化以及代码的优化。可以先拿一些网上的开源项目进行优化等等。最后，尽情的享受优化把~~~</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-04T12:39:27+08:00" itemprop="datePublished">2017/9/4</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207871029.html" itemprop="url">
		Android Launcher启动Activity的工作过程</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">Launcher</h2>

<p>手机桌面也是一个App，每一个应用的icon都罗列在Launcher上，点击icon触发onItemClick事件，下面例如我们要启动「淘宝」这个App，首先我们要在清单文件定义默认启动的Activity信息。</p>

<pre class="line-numbers"><code class="language-markup">&lt;activity android:name=&quot;.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>然后Launcher获取到该信息之后，启动淘宝App</p>

<pre class="line-numbers"><code class="language-java">//该应用的包名
String pkg = info.activityInfo.packageName;
//应用的主activity类
String cls = info.activityInfo.name;

ComponentName componet = new ComponentName(pkg, cls);

Intent i = new Intent();
i.setComponent(componet);
startActivity(i);
</code></pre>

<p>启动Activity这一工作不管是相同应用的2个不同Activity的启动，或者是不同进程不同应用的Activity启动，都是由Activity大管家ActivityManagerService（简称AMS）全权管理，而他们之间的通讯就要用到Binder，通过Binder与AMS多次通讯，才能启动淘宝App。 </p>

<h2 id="toc_1">整体流程</h2>

<blockquote>
<p>通过对Android操作系统的学习可以提高我们对操作系统在技术实现上的理解，这对于加强开发人员的内功是很有帮助的。 <br/>
但是由于Android内部实现多数都比较复杂，在研究内部实现上应该更加侧重对整体流程的把握，而不能深入到代码细节不能自拔。</p>
</blockquote>

<ol>
<li>Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。</li>
<li>AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。</li>
<li>Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。</li>
<li>淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。</li>
<li>淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。</li>
<li>AMS通知淘宝绑定Application并启动MainActivity。</li>
<li>淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。</li>
</ol>

<h3 id="toc_2">startActivityForResult</h3>

<p>我们从Activity的startActivity方法开始分析。<br/><br/>
<code>startActivity</code>方法有好几种重载方式，但它们最终都会调用<code>startActivityForResult</code>方法。</p>

<pre class="line-numbers"><code class="language-java">@Override
public void startActivity(Intent intent, @Nullable Bundle options) {
    if (options != null) {
        startActivityForResult(intent, -1, options);
    } else {
        // Note we want to go through this call for compatibility with
        // applications that may have overridden the method.
        startActivityForResult(intent, -1);
    }
}
</code></pre>

<p>在<code>startActivityForResult</code>方法内，会调用<code>Instrumentation</code>的<code>execStartActivity</code>方法。</p>

<pre class="line-numbers"><code class="language-java">public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) {
    ......
    Instrumentation.ActivityResult ar =mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
    ......
}
</code></pre>

<h3 id="toc_3">Instrumentation</h3>

<blockquote>
<p>Instrumentation从字面上来看是仪器盘的意思，具体到程序中是管理activity的一个工具类，包括创建和启动Activity，activity的生命周期方法都是由Instrumentation这个仪器来控制，一个进程中只用一个Instrumentation实例。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">/**
 *
 *
 * @param who The Context from which the activity is being started.
 * @param contextThread The main thread of the Context from which the activity
 *                      is being started.
 * @param token Internal token identifying to the system who is starting 
 *              the activity; may be null.
 * @param target Which activity is performing the start (and thus receiving 
 *               any result);
 *               may be null if this call is no`t being made form an activity.
 * @param intent The actual Intent to start.
 * @param requestCode Identifier for this request&#39;s result; less than zero 
 *                    if the caller is not expecting a result.
 * @param options Addition options.
 *
 */
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,Intent intent, int requestCode, Bundle options) {
    IApplicationThread whoThread = (IApplicationThread) contextThread;

    ......

    try {
        int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent,intent.resolveTypeIfNeeded(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null,requestCode, 0, null, options);

        //检查启动Activity的结果（抛出异常，例如清单文件未注册Activity）
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException(&quot;Failure from system&quot;, e);
    }
    return null;
}
</code></pre>

<p>我们截取了比较关键的代码片段来分析<code>Instrumentation</code>的<code>execStartActivity</code>方法，方法参数注释中也有对该方法的几个参数进行简单描述。下面我们来分析一下比较重要的2个参数，<code>contextThread</code>和<code>token</code>。 </p>

<h3 id="toc_4">IBinder contextThread</h3>

<p>在上一个方法中传入为<code>mMainThread.getApplicationThread()</code> <br/>
我们可以看到这是一个<code>IBinder</code>对象，说明它的作用就是用于进程间通讯的<code>Binder</code>对象。</p>

<blockquote>
<p>mMainThread实际上是ActivityThread对象。ActivityThread，就是主线程，也就是UI线程，它是在App启动时创建的，它代表了App应用程序。<br/><br/>
啥？ActivityThread代表了App应用程序，那Application类岂不是被架空了？其实，Application对我们App开发人员来说也许很重要，但是在Android系统中还真的没那么重要，他就是个上下文。Activity不是有个Context上下文吗？Application就是整个ActivityThread的上下文。</p>
</blockquote>

<p>我们找到<code>ActivityThread</code>文件，其实这个<code>getApplicationThread</code>方法获取的是内部类<code>ApplicationThread</code>对象 <br/>
而且<code>ApplicationThread</code>继承<code>ApplicationThreadNative</code></p>

<pre class="line-numbers"><code class="language-java">public final class ActivityThread {//没有继承或者实现其他类。

    final ApplicationThread mAppThread = new ApplicationThread();

    public ApplicationThread getApplicationThread()
    {
        return mAppThread;
    }

    //ActivityThread的内部类ApplicationThread 
    private class ApplicationThread extends ApplicationThreadNative {
    ......
    }

}
</code></pre>

<p>我们打开<code>ApplicationThreadNative</code>类(需要通过sdk的源码找到，具体路径为Sdk\sources\android-25(sdk版本)\android\app\ApplicationThreadNative)<br/><br/>
通过构造方法我们就很清晰的可以得知原来这个<code>ApplicationThreadNative</code>就是相当于AIDL通讯中的Stub，也就是服务端，<code>ApplicationThreadProxy</code>即AIDL通讯中的Proxy，也就是客户端。所以ApplicationThread是通讯的具体实现类。<br/><br/>
上面的介绍中我们也说过，Activity的启动实际上是多次进程间通讯的成果，看到这里我们就可以得出结论：<strong>ActivityThread通过内部类ApplicationThread来进行进程间通讯</strong></p>

<pre class="line-numbers"><code class="language-java">public abstract class ApplicationThreadNative extends Binder implements IApplicationThread {

    static public IApplicationThread asInterface(IBinder obj) {...}

    @Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {...}

    public IBinder asBinder(){return this;}

}

class ApplicationThreadProxy implements IApplicationThread {
    private final IBinder mRemote;

    public ApplicationThreadProxy(IBinder remote) {
        mRemote = remote;
    }

    ...
}
</code></pre>

<p><code>public interface IApplicationThread extends IInterface {...}</code></p>

<h3 id="toc_5">IBinder token</h3>

<p>追溯到参数起源，这个<code>token</code>对象，是在<code>Activity</code>的<code>attach</code>方法中传入的，也就是<code>Activity</code>的创建与关联时候(下面的内容会提到)传入的<code>Activity</code>信息。<br/><br/>
这也是个<code>Binder</code>对象，它代表了<code>Launcher</code>这个<code>Activity</code>，这里也通过<code>Instrumentation</code>传给AMS，AMS查询后，就知道是谁向AMS发起请求了。</p>

<pre class="line-numbers"><code class="language-java">//Activity

    private IBinder mToken;

    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {

        mToken = token;
}
</code></pre>

<blockquote>
<p><code>contextThread</code>和<code>token</code>这两个参数是伏笔，传递给AMS，以后AMS想反过来通知<code>Launcher</code>，就能通过这两个参数，找到<code>Launcher</code>。</p>
</blockquote>

<h3 id="toc_6">startActivity</h3>

<p>在<code>Instrumentation</code>中，启动<code>Activity</code>真正的实现是由<code>ActivityManagerNative.getDefault()</code>的<code>startActivity</code>方法来完成。</p>

<pre class="line-numbers"><code class="language-java">int result = ActivityManagerNative.getDefault()
                .startActivity(whoThread, who.getBasePackageName(), intent,
                        intent.resolveTypeIfNeeded(who.getContentResolver()),
                        token, target != null ? target.mEmbeddedID : null,
                        requestCode, 0, null, options);
</code></pre>

<blockquote>
<p>ActivityManagerService（下面简称AMS）继承自ActivityManagerNative（下面简称AMN），而AMN继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder，它是IActivityManager的具体实现，由于ActivityManagerNative.getDefault()其实是一个IActivityManager类型的Binder对象，因此它的具体实现是AMS。</p>
</blockquote>

<p>我们先看代码，捋一捋上述所说的关系。</p>

<pre class="line-numbers"><code class="language-java">public final class ActivityManagerService extends ActivityManagerNative {...}

public abstract class ActivityManagerNative extends Binder implements IActivityManager{...}

public interface IActivityManager extends IInterface {...}
</code></pre>

<p>首先我们来看这个命名方式，xxxNative，我们知道Stub持有Binder本地对象，Proxy持有的是Binder的代理对象。所以系统命名也是依据此因素（Native：本地的，土著的）作为命名规范。</p>

<pre class="line-numbers"><code class="language-java">/**
 * Retrieve the system&#39;s default/global activity manager.
 */
static public IActivityManager getDefault() {
    return gDefault.get();
}

private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() {
    protected IActivityManager create() {
        IBinder b = ServiceManager.getService(&quot;activity&quot;);
        IActivityManager am = asInterface(b);
        return am;
    }
};

/**
 * Cast a Binder object into an activity manager interface, generating
 * a proxy if needed.
 */
static public IActivityManager asInterface(IBinder obj) {
    IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);
    if (in != null) {
        return in;//同一进程，返回Stub本地对象。
    }
    return new ActivityManagerProxy(obj);//跨进程，返回代理对象。
}
</code></pre>

<blockquote>
<p>可以发现，在AMN 中，AMS这个Binder对象采用单例模式对外提供，Singleton是一个单例的封装类，第一次调用它的get方法时它会通过create方法来初始化AMS这个Binder对象，在后续的调用中则直接返回之前创建的对象（使用同一个AMS）。</p>
</blockquote>

<p>分析create方法，在IActivityManager内（相当于Client），通过应用程序中的0号引用，可以向SMgr获取服务端（Server）的Binder引用。<br/><br/>
AMN通过getDefault方法，从ServiceManager中获取AMS中Binder的引用对象，然后将它转换成ActivityManagerProxy对象（简称AMP），AMP就是AMS的代理对象。</p>

<p>类似AIDL中客户端的绑定代码，此时我们就可以通过ActivityManagerProxy（asInterface返回值为 IActivityManager），与AMS进行通讯。</p>

<pre class="line-numbers"><code class="language-java">//ActivityManagerProxy

public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {

    Parcel data = Parcel.obtain();//从Parcel池中获取Parcel对象（通讯载体），用来写入数据
    Parcel reply = Parcel.obtain();//如果方法有返回值，则写入返回值
    data.writeInterfaceToken(IActivityManager.descriptor);//Binder唯一标识

    //caller即上面提到的contextThread，AMS就可以通过它与Launcher通讯
    data.writeStrongBinder(caller != null ? caller.asBinder() : null);
    data.writeString(callingPackage);
    intent.writeToParcel(data, 0);
    data.writeString(resolvedType);

    //resultTo即上面提到的token,包含Launcher的Activity信息
    data.writeStrongBinder(resultTo);
    data.writeString(resultWho);
    data.writeInt(requestCode);
    data.writeInt(startFlags);

        ......
    //发送类型为START_ACTIVITY_TRANSACTION的请求给AMS，data包含Launcher和淘宝App的信息
    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
    reply.readException();

    //Instrumentation通过result来检查并抛出异常（Activity未在清单文件注册等）
    int result = reply.readInt();
    reply.recycle();
    data.recycle();
    return result;
}
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101915083468801232.png" alt="2017101915083468801232.png"/><figcaption>2017101915083468801232.png</figcaption></figure></p>

<p>从上面的分析可以知道，Activity是由<code>AMN.getDefault()</code>来启动的，而<code>AMN.getDefault()</code>实际上是AMS，因此Activity的启动过程又转移到了AMS中，为了继续分析这个过程，只需要查看AMS的startActivity方法即可。</p>

<blockquote>
<p>Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。</p>
</blockquote>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150834692326696.png" alt="20171019150834692326696.png"/><figcaption>20171019150834692326696.png</figcaption></figure></p>

<h2 id="toc_7">AMS</h2>

<p>上个图，先通俗易懂的总结一下Activity启动的整体流程，对整体框架有一个大概认识。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150834695813386.png" alt="20171019150834695813386.png"/><figcaption>20171019150834695813386.png</figcaption></figure></p>

<h3 id="toc_8">AMS分析</h3>

<p>再回顾一遍，通过对AMS 类的查看，我们可以知道AMS 也是一个Binder，并且它是<code>IActivityManager</code>的具体实现。</p>

<pre class="line-numbers"><code class="language-java">public final class ActivityManagerService extends ActivityManagerNative {...}

public abstract class ActivityManagerNative extends Binder implements IActivityManager{...}

public interface IActivityManager extends IInterface {...}
</code></pre>

<p>接着我们继续分析AMS的<code>startActivity</code>方法，这个阶段比较复杂和繁琐，一不小心就绕晕了，我们了解大致过程，不深入代码细节，对整体流程建立足够认识即可。</p>

<pre class="line-numbers"><code class="language-java">//AMS

@Override
public final int startActivity(IApplicationThread caller, String callingPackage,Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {

    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,resultWho, requestCode, startFlags, profilerInfo, bOptions,UserHandle.getCallingUserId());
}


@Override
public final int startActivityAsUser(IApplicationThread caller, String callingPackage,Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller(&quot;startActivity&quot;);
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null);

    //7.0Acitivty启动管理类新增ActivityStarter(原本是ActivityStackSupervisor处理该过程)
    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,profilerInfo, null, null, bOptions, false, userId, null, null);
}
</code></pre>

<h3 id="toc_9">ActivityStarter</h3>

<pre class="line-numbers"><code class="language-java">//ActivityStarter

final int startActivityMayWait(IApplicationThread caller, int callingUid,String callingPackage, Intent intent, String resolvedType,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,IBinder resultTo, String resultWho, int requestCode, int startFlags,ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,Bundle bOptions, boolean ignoreTargetSecurity, int userId,IActivityContainer iContainer, TaskRecord inTask) {

            ``````

    //根据intent在系统中找到合适的应用的activity，如果有多个activity可选择，
    //则会弹出ResolverActivity让用户选择合适的应用。
    ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags,profileFile, profileFd, userId);

            ``````

    int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,aInfo, rInfo, voiceSession, voiceInteractor,resultTo, resultWho, requestCode, callingPid,callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,options, ignoreTargetSecurity, componentSpecified, outRecord, container,inTask);

            ``````

        return res;
    }



    //在startActivityLocked方法里，对传过来的参数做一些校验，然后创建ActivityRecord对象，再调用startActivityUnchecked(7.0前是startActivityUncheckedLocked)方法启动Activity。
   final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,String callingPackage, int realCallingPid, int realCallingUid, int startFlags,ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,TaskRecord inTask) {
        int err = ActivityManager.START_SUCCESS;

        ``````
        //创建ActivityRecord对象
        //ActivityRecord  :  在AMS中，将用ActivityRecord来作为Activity的记录者,每次启动一个Actvity会有一个对应的ActivityRecord对象，表示Activity的一个记录
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,requestCode, componentSpecified, voiceSession != null, mSupervisor, container,options, sourceRecord);

        ``````

        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,
                true, options, inTask);


        //此处将通知ActivityStarter, Activity对应的Task被移动到前台
        postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);

        return err;
    }
</code></pre>

<blockquote>
<p>在startActivityLocked方法里，对传过来的参数做一些校验，然后创建ActivityRecord对象，再调用startActivityUnchecked方法启动Activity。<br/>
startActivityUnchecked方法负责调度ActivityRecord和Task，理解该方法是理解Actvity启动模式的关键。<br/>
startActivityUnchecked方法调度task的算法非常复杂，和当前回退栈，要启动的acitivity的启动模式以及taskAffinity属性，启动activity时设置的intent的flag等诸多要素相关，intent的flag就有很多种情况，故此算法非常复杂，需要阅读源码并结合特定启动情况才能理解。</p>
</blockquote>

<p>接下来调用ActivityStack的startActivityLocked将ActivityRecord加入到回退栈里</p>

<pre class="line-numbers"><code class="language-java">//ActivityStarter

    private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {

            ``````
        //ActivityStack的startActivityLocked,不要搞混了。
        //同时调用WindowManager准备App切换相关的工作
        mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);


        if (mDoResume) {

            final ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked();
            if (!mTargetStack.isFocusable()
                    || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay
                    &amp;&amp; mStartActivity != topTaskActivity)) {
                // If the activity is not focusable, we can&#39;t resume it, but still would like to
                // make sure it becomes visible as it starts (this will also trigger entry
                // animation). An example of this are PIP activities.
                // Also, we don&#39;t want to resume activities in a task that currently has an overlay
                // as the starting activity just needs to be in the visible paused state until the
                // over is removed.

            } else {
                //最终调用ActivityStackSupervisor的resumeFocusedStackTopActivityLocked
                mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,
                        mOptions);
            }

}
</code></pre>

<h3 id="toc_10">ActivityStackSupervisor</h3>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor

    boolean resumeFocusedStackTopActivityLocked() {
        return resumeFocusedStackTopActivityLocked(null, null, null);
    }

    boolean resumeFocusedStackTopActivityLocked(
            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {
        if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) {
        //待启动Activity对应的Task为前台Task时，调用该Task对应ActivityStack的resumeTopActivityUncheckedLocked函数
            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }
        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        if (r == null || r.state != RESUMED) {
        //否则只是调用当前前台栈的resumeTopActivityUncheckedLocked
            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        }
        return false;
    }
</code></pre>

<h3 id="toc_11">ActivityStack</h3>

<p>接着跟进ActivityStack</p>

<pre class="line-numbers"><code class="language-java">//ActivityStack


    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {

        ``````
        result = resumeTopActivityInnerLocked(prev, options);

        return result;
    }


    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {


        //mResumedActivity指向上一次启动的Activity(Launcher)
        if (mResumedActivity != null) {
            ``````

           //通知Launcher进入pause状态
            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);
        }
         if (pausing) {//Launcher已经暂停了
            ``````

            if (next.app != null &amp;&amp; next.app.thread != null) {
                //如果app已经启动过
                //调用淘宝(待启动)Activity所在进程的优先级，保证其不被kill
                mService.updateLruProcessLocked(next.app, true, null);
            }

        } 
        ``````

        if (next.app != null &amp;&amp; next.app.thread != null) {

        //如果Intent不为空，调用NewIntent方法传入Intent
        next.app.thread.scheduleNewIntent(next.newIntents, next.appToken, false);

        //假设淘宝App已经启动，点击Home键返回到Launcher,再次从Launcher启动淘宝(或者第三方启动已开启的App)
        next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,
                        mService.isNextTransitionForward(), resumeAnimOptions);
        ``````

        } else {
        ``````
           //创建进程，冷启动Activity。或者已启动App，重新启动Activity
           mStackSupervisor.startSpecificActivityLocked(next, true, true);
        }

        return true;
    }
</code></pre>

<p>resumeTopActivityInnerLocked函数非常繁琐，但整体来讲应该只有两个比较关键的地方：</p>

<ol>
<li>判断是否已有Activity(mResumedActivity)启动（即Launcher，通过Launcher启动淘宝的），有则暂停该Activity</li>
<li>判断是否需要重新启动目标Activity，即Activity是否已经启动过。（例如保存在后台，应用切换）</li>
</ol>

<blockquote>
<p>2.AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。<br/><br/>
3.Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。</p>
</blockquote>

<h3 id="toc_12">创建进程</h3>

<p>接下来的操作就比较重要了，创建进程，启动Activity。</p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


    void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {
        // Is this activity&#39;s application already running?
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                r.info.applicationInfo.uid, true);

        if (app != null &amp;&amp; app.thread != null) {
            try {
                if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0
                        || !&quot;android&quot;.equals(r.info.packageName)) {

                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                            mService.mProcessStats);
                }
                //目标Activity的App已经启动（存在ActivityThread），则重启Activity
                realStartActivityLocked(r, app, andResume, checkConfig);
                return;
            } catch (RemoteException e) {
               ``````
            }
        }

        //如果进程不存在，则通过zygote创建应用进程。
        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                &quot;activity&quot;, r.intent.getComponent(), false, false, true);
    }
</code></pre>

<p>从上面代码可以了解到startSpecificActivityLocked为启动Activity的两种不同情况</p>

<ul>
<li>例如从Launcher冷启动淘宝，则需要创建新进程，通过AMS调用Zygote(孕育天地)孵化应用进程。</li>
<li>如果淘宝App已经启动，例如从MainActivity跳转到LoginActivity，则通过realStartActivityLocked启动。</li>
</ul>

<p>因为我们开头以Launcher启动淘宝为例子，所以我们硬着头皮继续分析AMS创建进程以及Activity的绑定过程。 <br/>
上面分析到mService.startProcessLocked,到了这里我们直接看启动线程的方法，中间的过程实在是略复杂。</p>

<blockquote>
<p>4.淘宝App未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">//ActivityServiceManager

        //Process.java的start函数，将通过socket发送消息给zygote
        //zygote将派生出一个子进程，子进程将通过反射调用ActivityThread的main函数
        Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;,
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                    app.info.dataDir, entryPointArgs);
</code></pre>

<p>Zygote进程孵化出新的应用进程后，通过反射执行ActivityThread类的main方法。在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到AMS，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread

public static void main(String[] args) {
    ``````
    //准备主线程的Looper，下篇博文分析Handler,Looper
    Looper.prepareMainLooper();

    //创建当前进程的ActivityThread
    ActivityThread thread = new ActivityThread();

    //将该进程绑定到AMS
    thread.attach(false);

    if (sMainThreadHandler == null) {
    //保存进程对应的主线程Handler
        sMainThreadHandler = thread.getHandler();
    }

    ``````
    //进入主线程的消息循环
    Looper.loop();

    ``````
}

//上面说过，ApplicationThread是ActivityThread用来与AMS通讯的中介
final ApplicationThread mAppThread = new ApplicationThread();

private void attach(boolean system) {
    if (!system) {
        final IActivityManager mgr = ActivityManagerNative.getDefault();

        //调用AMS的attachApplication方法，将ApplicationThread对象绑定至ActivityManagerService
        //这样AMS就可以通过ApplicationThread代理对象控制应用进程

            mgr.attachApplication(mAppThread);
    } else {
        ``````
    }
}
</code></pre>

<p>至此，进程创建完毕，并且也有了主线程，剩下的便是启动Activity和关联context等初始化操作了。</p>

<blockquote>
<p>5.淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。</p>
</blockquote>

<h3 id="toc_13">AMS启动Activity小结</h3>

<p>至此通过下图总结一下在AMS启动Activity的大致流程，各个方法函数像一台机器上的不同零件，各尽其责，分工明确。 <br/>
虽然错综复杂，但是耦合性低，比如说启动模式需要优化，重新完善startActivityUnchecked方法函数即可。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150834779685560.png" alt="20171019150834779685560.png"/><figcaption>20171019150834779685560.png</figcaption></figure></p>

<h3 id="toc_14">关联Activity</h3>

<p>在这个时候，虽然有了app进程，和主线程，但是仍是一副空壳。 <br/>
没有activity信息，没有关联上下文，这时候就要请出AMS来进行指挥。</p>

<p>因为主线程main入口通过attach方法将 ApplicationThread 发送给 AMS ，所以通过applicationThread这个桥梁来通知ActivityThread创建/关联和启动Activity。</p>

<pre class="line-numbers"><code class="language-java">//AMS


    @Override
    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            //获取applicationThread的进程id(也就是淘宝应用进程)
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }
</code></pre>

<p>通过Binder获取proxy（ApplicationThread ）方的进程id，也就是获取目标(淘宝)进程的Pid。</p>

<pre class="line-numbers"><code class="language-java">//Binder


    /**
     * Return the ID of the process that sent you the current transaction
     * that is being processed.  This pid can be used with higher-level
     * system services to determine its identity and check permissions.
     * If the current thread is not currently executing an incoming transaction,
     * then its own pid is returned.
     */
    public static final native int getCallingPid(); 
</code></pre>

<p>接下来重点分析attachApplicationLocked方法</p>

<pre class="line-numbers"><code class="language-java">//AMS


    private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {

        // Find the application record that is being attached...  either via
        // the pid if we are running in multiple processes, or just pull the
        // next app record if we are emulating process with anonymous threads.
        ProcessRecord app;
        if (pid != MY_PID &amp;&amp; pid &gt;= 0) {
            synchronized (mPidsSelfLocked) {
                app = mPidsSelfLocked.get(pid);
            }
        } else {
            app = null;
        }

        //因为进程由AMS启动，所以在AMS中一定会有ProcessRecord（进程记录）
        //如果没有ProcessRecord，则需要杀死该进程并退出
        if (app == null) {
            ``````
            return false;
        }

        // If this application record is still attached to a previous
        // process, clean it up now.
        if (app.thread != null) {
            //如果从ProcessRecord中获取的IApplicationThread不为空，则需要处理该IApplicationThread
            //因为有可能此Pid为复用，旧应用进程刚释放，内部IApplicationThread尚未清空，
            //同时新进程又刚好使用了此Pid
            handleAppDiedLocked(app, true, true);
        }


        //创建死亡代理（进程kill后通知AMS）
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);

        //进程注册成功，移除超时通知
        mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);

        ``````
        try {
            //******绑定Application******
            thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode,
                    mBinderTransactionTrackingEnabled, enableTrackAllocation,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat,
                    getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked());

            updateLruProcessLocked(app, false, null);
        } catch (Exception e) {

            ``````
            //bindApplication失败后，重启进程
            startProcessLocked(app, &quot;bind fail&quot;, processName);
            return false;
        }

        try {
            //******启动Activity(启动淘宝MainActivity)******
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;//didSomething表示是否有启动四大组件
            }
        } catch (Exception e) {
            badApp = true;
        }

        ``````
        //绑定service和Broadcast的Application


        if (badApp) {
            //如果以上组件启动出错，则需要杀死进程并移除记录
            app.kill(&quot;error during init&quot;, true);
            handleAppDiedLocked(app, false, true);
            return false;
        }

        //如果以上没有启动任何组件，那么didSomething为false
        if (!didSomething) {
            //调整进程的oom_adj值， oom_adj相当于一种优先级
            //如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死”
            updateOomAdjLocked();
        }
        return true;
    }
</code></pre>

<p>在<code>attachApplicationLocked</code>中有两个比较重要的方法函数，分析到这里我们的文章也要进入尾声了。</p>

<ol>
<li>thread.bindApplication（…） : 绑定Application到ActivityThread</li>
<li>mStackSupervisor.attachApplicationLocked（app） : 启动Activity（7.0前为mMainStack.realStartActivityLocked()）</li>
</ol>

<h3 id="toc_15">bindApplication</h3>

<p>在上面我们说道，ActivityThread通过ApplicationThread与AMS进行通讯，所以上面的thread.bindApplication（...）方法，就应该是通过ApplicationThread进行传达。<br/><br/>
在ActivityThread的内部类ApplicationThread中，我们找到bindApplication方法</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread

    //内部类ApplicationThread
    private class ApplicationThread extends ApplicationThreadNative {

        public final void bindApplication(...一大堆参数...) {
            AppBindData data = new AppBindData();
            //给data设置参数...
            ``````

            sendMessage(H.BIND_APPLICATION, data);
        }
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
        Message msg = Message.obtain();
        //给msg设置参数
        ``````
        mH.sendMessage(msg);
    }
</code></pre>

<p>发送消息是通过H的<code>Handler</code>类来完成的，这个命名贼个性，很令人印象深刻。PS : 我怀疑是编写这个类的工程师词穷了…</p>

<pre class="line-numbers"><code class="language-java">    private class H extends Handler {
        public static final int LAUNCH_ACTIVITY         = 100;
        public static final int PAUSE_ACTIVITY          = 101;
        ``````
        public static final int RESUME_ACTIVITY         = 107;

        public static final int DESTROY_ACTIVITY        = 109;
        public static final int BIND_APPLICATION        = 110;
        public static final int EXIT_APPLICATION        = 111;

        ``````

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ``````  
                //绑定application
                case BIND_APPLICATION:
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);
                    AppBindData data = (AppBindData)msg.obj;
                    handleBindApplication(data);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                    break;

            }

        }

    }
</code></pre>

<p>可以看出，这个H类相当于ActivityThread和ApplicationThread的中介人，也就是拉皮条的。<br/><br/>
<code>ActivityThread</code>通过<code>ApplicationThread</code>与<code>AMS</code>通讯。<br/><br/>
<code>ApplicationThread</code>通过<code>H</code>与<code>ActivityThread</code>通讯，处理Activity事务。  </p>

<p>那么既然<code>H</code>、<code>ApplicationThread</code>都在<code>ActivityThread</code>类里，为何<code>ApplicationThread</code>还要通过Handler来发送消息？</p>

<ul>
<li>便于集中管理，方便打印Log日志等，H就是这其中的大管家。</li>
<li><code>ActivityThread</code>通过<code>ApplicationThread</code>和AMS进行进程间通信，AMS以进程通讯的方式来完成<code>ActivityThread</code>的请求后调用<code>ApplicationThread</code>中的<code>Binder</code>方法，然后<code>ApplicationThread</code>会向H发送消息，H收到消息后会将<code>ApplicationThread</code>中的逻辑切换到<code>ActivityThread</code>中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。<br/>
而且有一点要注意的是，这个<code>ActivityThread</code>并不是一个线程Thread，它是final类并且无继承或者实现其它类，它的作用就是在main方法内消息循环，处理主线程事务。（还需了解Looper及消息机制）</li>
</ul>

<p>言归正传，上面ApplicationThread给H发送BIND_APPLICATION标识，在H中，通过handleBindApplication处理application的绑定事务。</p>

<pre class="line-numbers"><code class="language-java">//ActivityThread



        private void handleBindApplication(AppBindData data) {

           ``````
          //根据传递过来的ApplicationInfo创建一个对应的LoadedApk对象
          data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);//获取LoadedApk


          /**
          * For apps targetting Honeycomb or later, we don&#39;t allow network usage
          * on the main event loop / UI thread. This is what ultimately throws
          * {@link NetworkOnMainThreadException}.
          */
          //禁止在主线程使用网络操作
          if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB) {
              StrictMode.enableDeathOnNetwork();
          }
          /**
           * For apps targetting N or later, we don&#39;t allow file:// Uri exposure.
           * This is what ultimately throws {@link FileUriExposedException}.
           */
           //7.0引入Fileprovide
          if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.N) {
              StrictMode.enableDeathOnFileUriExposure();
          }

          ``````    
          //创建进程对应的Android运行环境ContextImpl
          final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);


          if ((InstrumentationInfo)ii != null) {
               ``````
          } else {
               //注意Activity的所有生命周期方法都会被Instrumentation对象所监控，
               //也就说执行Activity的生命周期方法前后一定会调用Instrumentation对象的相关方法
               mInstrumentation = new Instrumentation();
          }

          try {
             ``````
             Application app = data.info.makeApplication(data.restrictedBackupMode, null);
             mInitialApplication = app;


             //加载进程对应Package中携带的ContentProvider
             installContentProviders(app, data.providers);

             ``````        
             mInstrumentation.onCreate(data.instrumentationArgs);

             try {
                  //这里会调用Application的onCreate方法
                  //故此Applcation对象的onCreate方法会比ActivityThread的main方法后调用
                  //但是会比这个应用的所有activity先调用
                  mInstrumentation.callApplicationOnCreate(app);
              } catch (Exception e) {
                  ``````
              }
            } finally {
                StrictMode.setThreadPolicy(savedPolicy);
            }
        }
</code></pre>

<p>如上文所述，handleBindApplication的目的是让一个Java进程融入到Android体系中。 <br/>
因此，该函数中的代码主要进行以下工作：</p>

<ol>
<li>按照Android的要求，完成对进程基本参数的设置置，包括设置进程名、时区、资源及兼容性配置； <br/>
同时也添加了一些限制，例如主线程不能访问网络等。</li>
<li>创建进程对应的ContextImpl、LoadedApk、Application等对象，同时加载Application中的ContentProvider，并初始化Application。</li>
<li>使用Instrumentation监控Activity的生命周期。（一个进程对应一个Instrumentation实例）</li>
</ol>

<p>当完成上述工作后，新建的进程终于加入到了Android体系。</p>

<blockquote>
<p>6.AMS通知淘宝绑定Application并启动MainActivity。</p>
</blockquote>

<h2 id="toc_16">启动Activity</h2>

<h3 id="toc_17">attachApplicationLocked</h3>

<p>在上述代码AMS的<code>attachApplicationLocked</code>方法中，我们说道：</p>

<blockquote>
<p>在<code>attachApplicationLocked</code>中有两个比较重要的方法函数，分析到这里我们的文章也要进入尾声了。  </p>

<ol>
<li>thread.bindApplication（…） : 绑定Application到ActivityThread</li>
<li>mStackSupervisor.attachApplicationLocked（app） : 启动Activity</li>
</ol>
</blockquote>

<p>绑定了Application之后，我们就可以启动Activity(淘宝MainActivity)。 </p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


    boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {
        final String processName = app.processName;
        boolean didSomething = false;

        //ActivityStackSupervisor维护着终端中所有ActivityStack
        //此处通过轮询，找出前台栈顶端的待启动Activity
        for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) {
            ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
            for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) {
                final ActivityStack stack = stacks.get(stackNdx);
                if (!isFocusedStack(stack)) {
                    continue;
                }

                ActivityRecord hr = stack.topRunningActivityLocked();
                if (hr != null) {
                    //前台待启动的Activity与当前新建的进程一致时，启动这个Activity
                    if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid
                            &amp;&amp; processName.equals(hr.processName)) {
                        try {

                            //realStartActivityLocked进行实际的启动工作
                            if (realStartActivityLocked(hr, app, true, true)) {
                                didSomething = true;
                            }
                        } catch (RemoteException e) {

                        }
                    }
                }
            }
        }

        return didSomething;
    }
</code></pre>

<p>大概系统工程师也觉得这个启动过程贼鸡儿绕了，最终启动的方法命名为realStartActivityLocked，意味着告诉你，大伙儿不要搞晕了，这个就是最后启动Activity的方法了。<br/><br/>
最后我们直捣黄龙，在<code>ActivityStackSupervisor</code>方法中，我们找到如下代码</p>

<pre class="line-numbers"><code class="language-java">//ActivityStackSupervisor


            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),
                    new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,
                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,
                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);
</code></pre>

<p>看到这里想必大伙儿都明白了，AMS最后通过ApplicationThread通知ActivityThread启动Activity，感觉这一切的通讯都像发电报一样，鬼斧神工出神入化，皆出架构师之目营心匠。<br/><br/>
那么到这里我们就能推算出接下来的老套路了<br/><br/>
ApplicationThread—&gt; H—&gt; ActivityThread—&gt; 最终启动Activity的方法。  </p>

<h3 id="toc_18">ActivityThread</h3>

<pre class="line-numbers"><code class="language-java">//ActivityThread


    //内部类ApplicationThread
    private class ApplicationThread extends ApplicationThreadNative {
        @Override
        public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,
                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,
                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,
                int procState, Bundle state, PersistableBundle persistentState,
                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,
                boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {

            updateProcessState(procState, false);

            ActivityClientRecord r = new ActivityClientRecord();
            //设置参数
            ``````

            //从LAUNCH_ACTIVITY这个标识我们就可以知道，它就是用来启动Activity
            sendMessage(H.LAUNCH_ACTIVITY, r);
        }
    }

    private class H extends Handler {
        ``````

        public void handleMessage(Message msg) {
            switch (msg.what) {
                case LAUNCH_ACTIVITY: {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                    //利用ApplicationInfo等信息得到对应的LoadedApk，保存到ActivityClientRecord
                    //ActivityClientRecord包含Activity相关的信息
                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                } break;

                ``````  
            }
        }
    }
</code></pre>

<pre class="line-numbers"><code class="language-java">//ActivityThread


private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ``````

    Activity a = performLaunchActivity(r, customIntent);
    if (a != null) {
        ``````
        handleResumeActivity(r.token, false, r.isForward,
                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);

        ``````
    } 
    ``````
}
</code></pre>

<p><code>handleLaunchActivity</code>方法里有有两个重要的函数调用,</p>

<ul>
<li>performLaunchActivity : 会调用Activity的onCreate,onStart,onResotreInstanceState方法</li>
<li>handleResumeActivity : 会调用Activity的onResume方法.</li>
</ul>

<blockquote>
<p>从上面的源码可以看出，performLaunchActivity方法最终完成了Activity对象的创建和启动过程，并且ActivityThread通过handleResumeActivity方法来调用被启动Activity的onResume这一生命周期方法。</p>
</blockquote>

<h3 id="toc_19">performLaunchActivity</h3>

<p><code>【performLaunchActivity】</code> 这个方法主要完成了如下几件事。【摘自Android开发艺术探索】</p>

<h4 id="toc_20">从ActivityClientRecord中获取待启动的Activity的组件信息。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


        ActivityInfo aInfo = r.activityInfo;
        if (r.packageInfo == null) {
            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                    Context.CONTEXT_INCLUDE_CODE);
        }

        ComponentName component = r.intent.getComponent();
        if (component == null) {
            component = r.intent.resolveActivity(
                mInitialApplication.getPackageManager());
            r.intent.setComponent(component);
        }

        if (r.activityInfo.targetActivity != null) {
            component = new ComponentName(r.activityInfo.packageName,
                    r.activityInfo.targetActivity);
        }
</code></pre>

<h4 id="toc_21">通过Instrumentation的newActivity方法使用类加载器创建Activity对象。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


        Activity activity = null;
        try {
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            ``````
        }
</code></pre>

<h4 id="toc_22">通过LoadedApk的makeApplication方法来创建Application对象。</h4>

<pre class="line-numbers"><code class="language-java">//ActivityThread的performLaunchActivity方法


Application app = r.packageInfo.makeApplication(false, mInstrumentation);//r.packageInfo为LoadedApk对象
</code></pre>

<p>其实在我们上面的bindApplication中，我们就有介绍到通过<code>LoadedApk</code>创建Application，并且创建完毕后，通过<code>Instrumentation的callApplicationOnCreate</code>来调用<code>Application</code>的onCreate方法</p>

<pre class="line-numbers"><code class="language-java"> Application app = data.info.makeApplication(data.restrictedBackupMode, null);

    ``````
 mInstrumentation.callApplicationOnCreate(app);
</code></pre>

<p>所以第三步是为了判断Application是否为空，而且我们从makeApplication方法中也能看出如果Application已经被创建过了，那么就不会再重复创建了。</p>

<h4 id="toc_23">创建ContextImpl对象，并通过Activity的attach方法来完成一些重要数据的初始化。</h4>

<pre class="line-numbers"><code class="language-java">
                Context appContext = createBaseContextForActivity(r, activity);//创建ContextImpl对象

                ``````
                Window window = null;
                if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
</code></pre>

<blockquote>
<p>ContextImpl是一个很重要的数据结构，它是Context的具体实现，Context中的大部分逻辑都是由ContextImpl来完成的。ContextImpl来完成的。ContextImpl是通过Activity的attach方法来和Activity建立关联的，除此之外<strong>，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Window接收到外部输入事件后就可以将事件传递给Activity</strong>。</p>
</blockquote>

<h4 id="toc_24">调用Activity的onCreate方法</h4>

<p><code>mInstrumentation.callActivityOnCreate(activity, r.state);</code></p>

<p>由于Activity的onCreate已经被调用，这也意味着Activity已经完成了整个启动过程。</p>

<h4 id="toc_25">调用Activity的onStart,onResotreInstanceState方法</h4>

<pre class="line-numbers"><code class="language-java">        mInstrumentation.callActivityOnCreate(activity, r.state);

        ``````
        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
</code></pre>

<h2 id="toc_26">总结</h2>

<p>至此从Launcher启动Activity的工作过程整个流程已经阐述完毕了，通过这次分析，对启动Activity的来龙去脉有了大致的掌控，但是也留下了几个知识点尚未探索清晰。（越深入探索，越发现不足）</p>

<ul>
<li>Looper，Handler的工作机制（Android的消息机制）</li>
<li>Context 到底是什么</li>
<li>Window的内部机制又是怎样的</li>
</ul>

<p>如果是淘宝MainActivity启动LoginActivity呢？<br/><br/>
其实原理和上述过程大体一致，只是在<code>ActivityStackSupervisor</code>的<code>startSpecificActivityLocked</code>方法中，发现进程已经启动，直接调用<code>realStartActivityLocked</code>启动Activity。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171019150834785338133.png" alt="20171019150834785338133.png"/><figcaption>20171019150834785338133.png</figcaption></figure></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-03T23:38:27+08:00" itemprop="datePublished">2017/9/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207870955.html" itemprop="url">
		Android项目从立项到上线</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>最近在组建项目组从0开始开发项目，从立项到上线，有一些心得，包括项目规范、结构、优化、三方等，与大家分享，一起修仙！</p>

<p>接下来我会以自己写的两个项目为例，结合起来分析。代码已经上传github：</p>

<ul>
<li>Material Design风格项目 <a href="https://github.com/shuaijia/MaterialDesignProject">点击前往</a> 喜欢就给个star<sup>_^</sup></li>
<li>UI、Base、网络等封装库项目 <a href="https://github.com/shuaijia/JSBaseDemo">点击前往</a> 喜欢也给个star喽</li>
</ul>

<p>先上图来看看吧：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981004338352.png" alt="20171104150981004338352.png"/><figcaption>20171104150981004338352.png</figcaption></figure></p>

<p>项目采用<strong>MVP+Retrofit+RxJava+Gson+Glide+Material Design</strong>设计</p>

<p>同时也使用了<strong>EventBus</strong>事件总线、<strong>GreenDao</strong>数据库、<strong>SurfaceView+MediaPlayer视频播放器</strong>等主要技术。</p>

<p>ok！项目就简单介绍到这里，接下来开始我们的修仙之路。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981008811224.png" alt="20171104150981008811224.png"/><figcaption>20171104150981008811224.png</figcaption></figure></p>

<h2 id="toc_0">项目整体分析</h2>

<h3 id="toc_1">UI风格</h3>

<h4 id="toc_2">logo</h4>

<h4 id="toc_3">主题风格：</h4>

<ul>
<li>Material Design</li>
<li>仿ios</li>
<li>主界面–侧拉</li>
<li>主界面–仿微信 选项卡等</li>
</ul>

<h3 id="toc_4">技术方案</h3>

<h4 id="toc_5">整体分析项目，确定整体技术方案，之后的开发中按照技术方案执行，同时编写相关文档。</h4>

<ul>
<li>项目架构</li>
<li>网络框架</li>
<li>图片处理</li>
<li>数据处理/接口格式</li>
<li>三方使用：统计、推送、更新等</li>
</ul>

<h3 id="toc_6">可行性分析</h3>

<p>邀请项目经理、技术负责人、产品经理、后端开发、测试等共同分析技术方案的可行性，并相应调整技术方案。</p>

<h3 id="toc_7">工期</h3>

<p>根据项目需求和技术方案，给出开发时长；</p>

<p>根据工期要求，可适当调整技术方案。</p>

<h3 id="toc_8">测试用例</h3>

<p>测试人员开始整理、编写测试用例和项目标准文档；</p>

<p>个人觉得开发人员应该参与到测试工作中，这样方便自己对业务逻辑和功能分析全面，也帮助测试人员分析项目功能和技术，便于写出更加全面的测试用例。</p>

<h2 id="toc_9">开发规范</h2>

<p>其实Android、Ios、Server等各端开发人员，都应该有完整的、严格的开发规范，这里我只说一下Android端的开发规范：</p>

<p>以自己项目为例，涉及到以下几项：</p>

<ul>
<li>文档规范</li>
<li>资源命名规范</li>
<li>代码命名规范</li>
<li>代码注释规范</li>
<li>代码风格规范</li>
<li>服务器数据规范 等</li>
</ul>

<h3 id="toc_10">文档</h3>

<p>重要有以下几个文档：</p>

<ul>
<li>需求文档</li>
<li>产品原型图</li>
<li>完整UI图</li>
<li>接口文档</li>
<li>核心技术文档</li>
<li>重点逻辑文档</li>
<li>程序框架图</li>
<li>ER图、数据字典、类图等</li>
<li>测试文档</li>
</ul>

<h3 id="toc_11">资源文件命名规范</h3>

<p>名字全部小写，最好不用数字，全部英文，单词中间下划线隔开</p>

<h4 id="toc_12">drawable、anim等文件夹下</h4>

<p>名称结构为“技术点模块点空间类型_功能名”结构，技术点主要有：selector、translate、alpha、scale等，模块名主要有：login、pay、mine、setting等，控件类型主要有：button、textview、imageview、dialog等，功能名主要有：findpwd、request、back、next等。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981042494432.png" alt="20171104150981042494432.png"/><figcaption>20171104150981042494432.png</figcaption></figure></p>

<h4 id="toc_13">drawable-xhdpi等图片资源</h4>

<p>名称为“技术点模块点功能名”结构，技术点主要有：activity、fragment、item、include等，模块点主要有：login、setting、mine、pay等，功能名主要有：head、title、back、sure等。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981047164097.png" alt="20171104150981047164097.png"/><figcaption>20171104150981047164097.png</figcaption></figure></p>

<h4 id="toc_14">layout</h4>

<p>布局名称为“技术点模块功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981050013389.png" alt="20171104150981050013389.png"/><figcaption>20171104150981050013389.png</figcaption></figure></p>

<h4 id="toc_15">values</h4>

<p>布局名称为“技术点模块功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981053458526.png" alt="20171104150981053458526.png"/><figcaption>20171104150981053458526.png</figcaption></figure></p>

<h3 id="toc_16">代码命名规范</h3>

<h4 id="toc_17">包名</h4>

<p>包名为“根包名.技术点名.模块名”结构，<strong>全部小写</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981056272553.png" alt="20171104150981056272553.png"/><figcaption>20171104150981056272553.png</figcaption></figure></p>

<h4 id="toc_18">类名</h4>

<p>采用 <strong>大驼峰</strong> 命名法，单词直接拼接，所有单词首字母大写</p>

<p>类名为“业务模块名 执行操作名 技术点名”结构，业务模块名主要有：home、lession、net、login，pay等，操作名主要有：Get、Set、Request、Login等，技术点名主要有：Activity、Fragment、View、Adapter等。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981070542458.png" alt="20171104150981070542458.png"/><figcaption>20171104150981070542458.png</figcaption></figure></p>

<h4 id="toc_19">普通变量</h4>

<p>采用 <strong>小驼峰</strong> 命名法，第一个单词首字母小写，其他单词首字母大写。</p>

<p>普通变量为“名字简写 类型 功能名”结构，名字简写有：js等，类型主要有：Int、Double、Boolean、String、Char等，功能名有：Login、Number、Content等。 </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110515098119341868.png" alt="2017110515098119341868.png"/><figcaption>2017110515098119341868.png</figcaption></figure></p>

<h4 id="toc_20">常亮</h4>

<p>所有字母全部大写，中间下划线隔开</p>

<p>常量为“功能名_标识”结构，功能名主要有：LOGIN、REQUEST、PERSONINFO等，标识有SUCCESS、ERROR、URL等。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981196443079.png" alt="20171105150981196443079.png"/><figcaption>20171105150981196443079.png</figcaption></figure></p>

<h3 id="toc_21">方法名</h3>

<p>名字能体现出功能即可。不再累赘重述。</p>

<h2 id="toc_22">数据/接口定义</h2>

<h3 id="toc_23">建议</h3>

<ul>
<li>服务器返回数据采用json格式</li>
<li>json数据中无数据，必须返回空数组或空字符串，不可返回null</li>
<li>Android端使用gson或fastjson或jackson等三方解析工具解析</li>
<li>不建议使用官方JSONObject解析，容易出错</li>
<li>实体类属性名与json中字段名完全一致</li>
<li>json中字段名全部使用英文，不可英文、拼音夹杂</li>
<li>用户表识建议使用Cookie</li>
<li>建议使用POST解析，它对参数数量没有要求，也比较安全</li>
<li>为了传输安全，使用https请求 等</li>
<li>完善接口文档，建议每一版对应一个完整接口文档</li>
</ul>

<h2 id="toc_24">屏幕适配</h2>

<p>安卓设备分辨率、屏幕尺寸五花八门，碎片化严重，重点对市面上主流的720 * 1280和1080 * 1920手机进行适配，同时对于其他类型手机也要适配。</p>

<p>关于屏幕适配，之前写过一个Android屏幕完美适配方案，<a href="http://blog.csdn.net/jiashuai94/article/details/77639511">点击前往</a>，这里不再重复表述。</p>

<h2 id="toc_25">程序架构MVP</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981206687113.png" alt="20171105150981206687113.png"/><figcaption>20171105150981206687113.png</figcaption></figure></p>

<h3 id="toc_26">上图介绍：</h3>

<p><strong>Contract</strong>：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。</p>

<p><strong>ViewInterface</strong>： view层接口，定义了view中的UI操作</p>

<p><strong>ModelInterface</strong>： model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等</p>

<p><strong>CallbackInterface</strong>： model层操作数据完成后的回调</p>

<p><strong>BasePersenter</strong>： Persenter父类，主要是对相关view的获取，销毁等操作</p>

<p><strong>View</strong>： view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应</p>

<p><strong>Model</strong>： model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack</p>

<p><strong>Persenter</strong>： persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示</p>

<h3 id="toc_27">MVP：</h3>

<p>MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。</p>

<p>使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要</p>

<p>现在比较流行MVVM架构，后续我会将MVVM总结，大家期待一下。。</p>

<h2 id="toc_28">package划分</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981211916250.png" alt="20171105150981211916250.png"/><figcaption>20171105150981211916250.png</figcaption></figure></p>

<p>如上：主体按功能模块划分，同一级的还有一些技术点，如adapter、util、pay等；在功能模块下，按照mvp模式，又分为contract、model、presenter、fragment和activity；而在其他技术点包下面同样也按功能模块划分。</p>

<p>总之，我们划分包时：以功能模块为主，以技术点为辅。</p>

<h2 id="toc_29">Base、Util、UI类封装</h2>

<h3 id="toc_30">Base类</h3>

<ul>
<li>BaseApplication</li>
<li>BaseActivity</li>
<li>BaseFragment</li>
<li>BasePresenter 等</li>
</ul>

<h4 id="toc_31">BaseApplication：</h4>

<p>主要进行一些例如：<strong>三方配置</strong>、<strong>热更新加载</strong>、<strong>文件配置</strong>、<strong>数据库配置</strong>等准备工作；同时也许定义全局性变量：如<strong>Application的Context</strong>、<strong>网络状态</strong>、<strong>主线程Looper</strong>、<strong>主线程Handler</strong>等。</p>

<h4 id="toc_32">BaseActivity：</h4>

<p>封装为抽象类，将各任务抽取成方法，有子类实现：比如<strong>findViewById(initView)</strong>、<strong>initData</strong>、<strong>setListener</strong>等；</p>

<p>对友盟统计的封装：因为友盟统计或别的统计需要在所有Activity的各生命周期方法中调用api，所以应该将其封装到BaseActivity中。</p>

<p>项目为MVP结构，所以设置了View和Presenter的泛型，如：</p>

<p>其中定义了屏幕宽高度等设备信息，也定义了BasePresenter对象、并抽取抽象方法，由子类返回其对应presenter。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981225588056.png" alt="20171105150981225588056.png"/><figcaption>20171105150981225588056.png</figcaption></figure></p>

<h4 id="toc_33">BaseFragment：</h4>

<p>BaseFragment的封装如BaseActivity一样，添加View和Presenter的泛型和presenter对象，创建返回Presenter的抽象方法供子类事项；</p>

<p>创建createView(创建跟视图view)、initChildView(子view findViewById)、initData(加载数据)抽象方法</p>

<h4 id="toc_34">BasePresenter：</h4>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981228211507.png" alt="20171105150981228211507.png"/><figcaption>20171105150981228211507.png</figcaption></figure></p>

<p>BasePresenter封装如上：内置view的软引用，在Activity或Fragment的onResume中调用presenter的attachView方法，将view实例传给presenter；在Activity或Fragment的onDestroy或onStop方法中调用detachView方法解除与view的绑定；而getView方法则是presenter在model返回数据后调用来操作对应view的展示UI方法。</p>

<h3 id="toc_35">Utils类</h3>

<h4 id="toc_36">只列举一些常用的工具类：</h4>

<ul>
<li>SharedPreferenceUtils</li>
<li>ToastUtils</li>
<li>StorageUtils</li>
<li>FileUtils</li>
<li>NetUtils</li>
<li>deviceUtils</li>
<li>DateUtils</li>
<li>LogUtils</li>
<li>AppUtils 等</li>
</ul>

<h3 id="toc_37">UI类</h3>

<h4 id="toc_38">只列举一些常用的View类</h4>

<ul>
<li>下拉刷新、上拉加载</li>
<li>圆形ImageView</li>
<li>自定义Dialog</li>
<li>Banner</li>
<li>自定义ScrollView</li>
<li>自定义RecyclerView</li>
<li>项目相关的自定义View 等</li>
</ul>

<h2 id="toc_39">数据库</h2>

<p>关于数据库操作，之前一直是自己写：也就是SQLiteOpenHelper结合相关SQL操作工具类来实现数据库操作。</p>

<p>但随着业务逻辑的增加和复杂，需要进行大量的数据库操作时，编写大量的代码，既费时间、还会避免不了地出bug；</p>

<p>所以我们只介绍几款流行的数据库框架：</p>

<ul>
<li>GreenDao</li>
<li>OrmLite</li>
<li>LitePal</li>
<li>Realm</li>
</ul>

<h3 id="toc_40">GreenDao：</h3>

<p><strong>特点</strong>：</p>

<ol>
<li>存取速度快; </li>
<li>支持数据库加密; </li>
<li>轻量级; </li>
<li>激活实体;</li>
<li>支持缓存; </li>
<li>代码自动生成</li>
</ol>

<p><strong>地址</strong>：<a href="https://github.com/greenrobot/greenDAO">https://github.com/greenrobot/greenDAO</a></p>

<h3 id="toc_41">OrmLite：</h3>

<p><strong>优点</strong>： </p>

<ol>
<li>轻量级；</li>
<li>使用简单，易上手；</li>
<li>封装完善；</li>
<li>文档全面。</li>
</ol>

<p><strong>缺点</strong>：</p>

<ol>
<li>基于反射，效率较低（本人还没有觉得效率低)</li>
<li>缺少中文翻译文档</li>
</ol>

<p><strong>jar包地址</strong>：<a href="http://ormlite.com/releases/">http://ormlite.com/releases/</a></p>

<h3 id="toc_42">LitePal：</h3>

<p>LitePal 框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。</p>

<p>地址：<a href="https://github.com/LitePalFramework/LitePal">https://github.com/LitePalFramework/LitePal</a></p>

<h3 id="toc_43">Realm：</h3>

<ol>
<li><p>易用：Ream 不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。</p></li>
<li><p>快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。</p></li>
<li><p>跨平台：Realm 支持 iOS &amp; OS X (Objective‑C &amp; Swift) &amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。</p></li>
<li><p>高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性</p></li>
<li><p>可视化</p></li>
</ol>

<p><a href="https://github.com/realm/realm-java">git地址</a></p>

<p><a href="https://realm.io/docs/java/latest/#getting-started">官网</a></p>

<p>自己项目中使用了GreenDao，它代码自动生成、存取速度快、支持加密、一个轻量级别的库，用着方便，推荐大家使用GreenDao。</p>

<h2 id="toc_44">图片处理</h2>

<p>之前有自己封装过图片处理框架，核心是使用HttpUrlConnection实现加载，仿LruCache（近期最少使用排序）算法实现图片缓存。</p>

<p>但我们用的最多的还是ImageLoader、Glide、Picasso和Fresco四大主流框架，接下来主要比较一下四个框架的各自特点：</p>

<h3 id="toc_45">ImageLoader：</h3>

<p><strong>优点</strong>:</p>

<ul>
<li>多线程下载，线程管理。</li>
<li>多级缓存架构设计和策略，内存缓存，磁盘缓存，缓存有效性处理。</li>
<li>图片压缩，特效处理，动画处理。</li>
<li>复杂网络情况下下载图片策略，例如弱网络等。</li>
<li>内存管理，lru 算法、对象引用、GC回收等优化。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>时间久，官方不再维护，出现bug需要自己修复。</li>
</ul>

<h3 id="toc_46">Glide：</h3>

<p><strong>优点</strong>：</p>

<ul>
<li>更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我建议传参的时候传递Activity 和 Fragment给Glide，而不是Context。</li>
<li>Glide可以加载GIF动态图。</li>
<li>Glide缓存的是跟ImageView尺寸相同的。Glide的这种方式优点是加载显示非常快。</li>
<li>默认使用HttpUrlConnection下载图片，可以配置为OkHttp或者Volley下载，也可以自定义下载方式。</li>
<li>默认使用手机内置存储进行磁盘缓存，可以配置为外部存储，可以配置缓存大小，图片池大小。</li>
<li>默认使用两个线程池来分别执行读取缓存和下载任务，都可以自定义。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>Glide加载的图片质量要差于Picasso，这是因为Glide默认的Bitmap格式是RGB_565，比ARGB_8888格式的内存开销要小一半。</li>
</ul>

<h3 id="toc_47">Picasso：</h3>

<p><strong>特点</strong>：</p>

<ul>
<li>在adapter中需要取消已经不在视野范围的ImageView图片资源的加载，否则会导致图片错位，Picasso已经解决了这个问题。</li>
<li>使用复杂的图片压缩转换来尽可能的减少内存消耗</li>
<li>自带内存和硬盘二级缓存功能</li>
</ul>

<h3 id="toc_48">Fresco：</h3>

<p><strong>优点</strong>：</p>

<ul>
<li>最大的优势便在于5.0以下(最低2.3) bitmap的加载，在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem)，而且图片不显示时，占用的内存会自动被释放，这会使APP更加流畅，减少因图片内存占用而引发的OOM。5.0以后的系统默认存储在Ashmem区了</li>
<li>图片的渐进式呈现，图片先呈现大致的轮廓，然后随着图片下载的继续，逐渐成仙清晰的图片，这对于慢网络对说，用户体验更好。</li>
<li>支持加载Git动态图和Webp格式的图片。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>框架体积比较大，3M左右，会增加APK的大小。</li>
</ul>

<p>总结：在项目开发中，要适当的选择图片框架，ImageLoader太老已过时，且官方不再维护，所以不再考虑使用ImageLoader；Picasso能做的，Glide都能做到，就是Glide的图片质量会稍差一些；而Fresco又体积偏大，但渐进式呈现，用户体验好。综上的话，一般项目建议使用Glide即可。</p>

<h2 id="toc_49">网络框架</h2>

<p>上一个项目中，网络框架自己封装：核心使用HttpUrlConnection实现，先封装请求参数相关类RequestVo，其中包含请求方式、url、参数、解析类、是否缓存、缓存时长等参数；缓存是将json字符串加密后与拼接过的url成对存储到File，并且设置有效时间，超过有效时间删除缓存并去网络请求，成功后重新保存。</p>

<p>但现在市面上最流行的是Retrofit+RxJava+Gson，接下来我们大概介绍一下：</p>

<h3 id="toc_50">添加依赖</h3>

<pre class="line-numbers"><code class="language-text">compile &#39;io.reactivex:rxjava:x.y.z&#39;
compile &#39;io.reactivex:rxandroid:1.0.1&#39;
compile &#39;com.squareup.retrofit2:retrofit:2.0.2&#39;
compile &#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;
compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39;
</code></pre>

<p>要注意：以上添加了Retrofit、RxJava和Gson依赖，版本号必须一致</p>

<h3 id="toc_51">登录Service</h3>

<pre class="line-numbers"><code class="language-text">interface BaseService {
  @GET(&quot;user/login&quot; )
  Observable&lt;User&gt; login(
          @Query(&quot;username&quot;) String username,
          @Query(&quot;password&quot;) String password
  );
}
</code></pre>

<p>login方法的返回值是Observable类型，就是RxJava中的被观察者。</p>

<h3 id="toc_52">网络请求</h3>

<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
    .addConverterFactory(GsonConverterFactory.create()           
    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())//新的配置
    .baseUrl(BASE_URL)
    .build();
BaseService service = retrofit.create(BaseService.class);

service.login(phone, password)               //获取Observable对象
    .subscribeOn(Schedulers.newThread())//请求在新的线程中执行
    .observeOn(Schedulers.io())         //请求完成后在io线程中执行
    .doOnNext(new Action1&lt;UserInfo&gt;() {
        @Override
        public void call(User user) {
            saveUserInfo(user);//保存用户信息到本地
        }
    })
    .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行
    .subscribe(new Subscriber&lt;User&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {
            //请求失败
        }

        @Override
        public void onNext(User user) {
            //请求成功
        }
});
</code></pre>

<p>RxJava + Retrofit 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。</p>

<p>可以看到，调用了service的login方法后得到Observable对象，在新的线程中执行网络请求，请求成功后切换到io线程执行保存用户信息的动作，最后再切换到主线程执行请求失败onError()、请求成功onNext()。整体的逻辑十分清晰都在一条链中，就算还有别的要求还可以往里面添加，丝毫不影响代码的简洁。</p>

<pre class="line-numbers"><code class="language-text">注意：Retrofit在创建的时候添了一下代码
addCallAdapterFactory(RxJavaCallAdapterFactory.create())
</code></pre>

<p>想了解更多关于RxJava，浏览<a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1">http://gank.io/post/560e15be2dca930e00da1083#toc_1</a></p>

<h2 id="toc_53">其他三方</h2>

<p>在自己的开发过程中，还用到了如EventBus、Zxing、Zbar、Volley、Gson、LeakCanary等三方框架；</p>

<p>也用到了如友盟统计、微信、支付宝支付、三方登录、极光推送、tinker热更新等三方sdk；</p>

<p>就不再一一列举，附上一张图，大家有时间多去学习、多去了解。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981301966614.png" alt="20171105150981301966614.png"/><figcaption>20171105150981301966614.png</figcaption></figure></p>

<h2 id="toc_54">混淆、加固、上线</h2>

<h3 id="toc_55">混淆</h3>

<p>大家可以参考我的<a href="http://blog.csdn.net/jiashuai94/article/details/77991077">另一篇文章</a></p>

<p>混淆是上线前挺重要的一个环节。Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。</p>

<h4 id="toc_56">坚持以下几项原则：</h4>

<ul>
<li>使用三方依赖，在混淆文件中添加官方提供的混淆代码，官方没有就google；</li>
<li>实体类不混淆，因为实体类涉及到与服务端的交互，各种gson的交互如此等等，是要保留的；</li>
<li>与js互调的类不混淆；</li>
<li>与反射有关的类不混淆 等。</li>
</ul>

<h4 id="toc_57">具体语法：</h4>

<pre class="line-numbers"><code class="language-text">-optimizationpasses 5 // 代码混淆的压缩比例，值在0-7之间
-dontusemixedcaseclassnames // 混淆后类名都为小写
-dontskipnonpubliclibraryclasses // 指定不去忽略非公共的库的类
-dontskipnonpubliclibraryclassmembers // 指定不去忽略非公共的库的类的成员
-dontpreverify // 不做预校验的操作

-verbose
-printmapping proguardMapping.txt // 生成原类名和混淆后的类名的映射文件

-optimizations !code/simplification/cast,!field/*,!class/merging/* // 指定混淆时采用的算法
-keepattributes *Annotation*,InnerClasses // 不混淆Annotation
-keepattributes Signature // 不混淆泛型
-keepattributes SourceFile,LineNumberTable // 抛出异常时保留代码行号
-keep class XXXX // 保留类名不变，也就是类名不混淆，而类中的成员名不保证。当然也可以是继承XXX类的所有类名不混淆，具体代码不贴了，重在理解。
-keepclasseswithmembers class XXXX // 保留类名和成员名。当然也可以是类中特定方法，代码不贴了，理由同上。
</code></pre>

<p><strong>加固</strong>：</p>

<p>加固一般都使用三方加固：如果apk上百度应用市场，则使用百度加固，其他情况建议使用360加固，当然，加固前一定是混淆过的、并且签过名的apk。</p>

<p>360加固还提供了一些其他服务，可根据项目情况操作（是需要花钱的..）</p>

<p><strong>上线</strong>：</p>

<p>也就是我们所说的发版，当你的apk测试通过，混淆过、签名过、也加固了，可以发版了。</p>

<p>每个公司上线的市场要求不同，一般主要有应用宝、360、豌豆荚、百度市场、小米市场、华为市场、魅族市场等，当然还有官网了。</p>

<p>发版时需要：apk当然要有、logo（第一次上线）、应用简介（第一次上线）、版本号、更新功能、介绍图、官网地址（第一次上线）等。</p>

<p>ok，到这里，我们的一个阶段算是完成了，接下来还会有更多的业务和bug等着大家，哈哈！希望这篇文章能对大家有一点点帮助。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-03T22:59:27+08:00" itemprop="datePublished">2017/9/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207870990.html" itemprop="url">
		Android机型适配</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">多机型 UI 适配</h2>

<p>在 Android 开发的工作日常中，UI 适配是一件比较重要的事情。一般开发新的功能，有新的页面，最终开发完成发布之前，都需要让设计师来审 UI 效果。</p>

<p>而有时候，明明我们已经在一款标准的 3 倍手机上，做到了让设计师小姐姐满意的效果，但是当换了另外一台手机的时候，效果又不那么如意。</p>

<p>传统的做法是，拿到效果不对的手机，单独适配看看是不是哪里布局写的不对导致效果不正确，然后改正它。但是总能碰到我们拿不到真实设备的情况。</p>

<p>本文就介绍一个命令，可以修改你当前设备的参数，来模拟出目标设备的显示效果，让你独立就把多机型 UI 效果确认的事情给做了。</p>

<h2 id="toc_1">WM 命令</h2>

<h3 id="toc_2">什么是 WM 命令</h3>

<p>说的这么厉害，实际上需要使用的就是一行 wm 命令，可以通过 <code>adb shell</code> 来操作它。</p>

<p>wm 命令主要用来帮助我们修改一些屏幕的参数，先来看看它的文档。使用 <code>adb shell wm</code> 命令，可以方便的查看 wm 的文档描述</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171016150816609742581.jpg" alt="20171016150816609742581.jpg"/><figcaption>20171016150816609742581.jpg</figcaption></figure></p>

<p>可以看到，wm 命令可以帮助我们修改当前设备的 size 、 density 等参数，而这两个参数就是决定了当前设备的显示效果。</p>

<h3 id="toc_3">WM 的命令</h3>

<p>从上面的文档可以看出，它其实支持的命令还是挺多的，但是有一些根本用不上，是需要系统权限的，所以正常来说我们是无法使用的。那么，还是介绍几个比较实用的命令。</p>

<p>以下例子都是在一款标准 density 为 3 的设备上运行的，屏幕像素为 1080px * 1920px。</p>

<h4 id="toc_4">wm size</h4>

<p><code>wm size</code> 命令，可以用来查询和修改当前设备的尺寸，如果想要修改尺寸，可以使用 <strong>px</strong> 或者 <strong>dp</strong> 为单位（默认为 px），使用 <strong>x</strong> 进行连接，这个其实看看 <code>wm size</code> 的输出，你就清楚了。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171016150816615239717.jpg" alt="20171016150816615239717.jpg"/><figcaption>20171016150816615239717.jpg</figcaption></figure></p>

<p>在这里的例子中，做了几件事情：</p>

<ul>
<li>使用 wm size 命令查看当前设备的尺寸。</li>
<li>使用 wm size 命令将当前尺寸修改成了 1000x2000。</li>
<li>再次使用 wm size 命令查看当前设备的尺寸。</li>
<li>最后使用 wm size reset 命令，将屏幕尺寸还原。</li>
<li>再用 wm size 命令，查看还原后的尺寸。</li>
</ul>

<p>这几个步骤就已经涵盖了 wm size 命令的所有使用步骤，可以使用它查看当前屏幕尺寸，并且修改屏幕尺寸和还原它。</p>

<h4 id="toc_5">wm density</h4>

<p><code>wm density</code> 命令，可以用来查看和修改当前设备的 density 参数。</p>

<p>使用起来很简单，直接上命令了。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171016150816618347092.jpg" alt="20171016150816618347092.jpg"/><figcaption>20171016150816618347092.jpg</figcaption></figure></p>

<p>在这个例子中，我做了几件事情：</p>

<ul>
<li>使用 wm density 查看当前设备的 density。</li>
<li>在使用 wm density 命令，修改当前设备的 density 为 420。</li>
<li>然后再使用 wm density 查看修改后的参数。</li>
<li>最后使用 wm density reset 将设备的 density 还原。</li>
<li>最后再查看一下还原后的值。</li>
</ul>

<h4 id="toc_6">wm overscan</h4>

<p><code>wm overscan</code> 命令，可以修改当前设备的屏幕内边距。其实我觉得这个命令没什么用处，但是还是演示一下如何使用。</p>

<pre class="line-numbers"><code class="language-shell">adb shell wm overscan 20,20,20,20
adb shell wm overscan reset
</code></pre>

<p>在这个例子中，做了几件事情：</p>

<ul>
<li>使用 wm overscan 修改边距为 20 。</li>
<li>然后使用 wm overscan reset 将其还原。</li>
</ul>

<h3 id="toc_7">WM 命令的原理</h3>

<p>wm 命令的逻辑非常的简单，它实际上是和 WindowManagerService 进行交互，通过 WMS 来修改屏幕相关的一些参数。</p>

<p>这里就不介绍完整的 wm 源码了，就以一个方法举例来看看 wm 的逻辑。这里就以 <code>wm size</code>命令举例好了。</p>

<p>首先，看看 wm 命令的入口。</p>

<pre class="line-numbers"><code class="language-java">@Override
public void onRun() throws Exception {
    mWm = IWindowManager.Stub.asInterface(ServiceManager.checkService(Context.WINDOW_SERVICE));
    if (mWm == null){
        System.err.println(NO_SYSTEM_ERROR_CODE);
        throw new AndroidException(&quot;Can`t connect to window manager;is the system running?&quot;);
    }
    
    String op = nextArgRequired();
    
    if (op.equals(&quot;size&quot;)) {
        runDisplaySize();
    } else if (op.equals(&quot;overscan&quot;)){
        runDisplayOverscan();
    } else if (op.equals(&quot;scaling&quot;)){
        runDisplayScaling();
    } else if (op.equals(&quot;screen-capture&quot;)){
        runSetScreenCapture();
    } else if (op.equals(&quot;dismiss-keyguard&quot;)){
        runDismissKeyguard();
    } else {
        showError(&quot;Error: unknown command ` &quot; + op + &quot;`&quot;);
        return;
    }
}
</code></pre>

<p>这里会初始化 mWm ，并且根据输入的参数，调用不同的方法，如果输入的是 size ，则会调用 <code>runDisplaySize()</code> 方法。</p>

<pre class="line-numbers"><code class="language-java">private void runDisplaySize() throws Exception {
    String size = nextArg();
    int w,h;
    if (size == null){
        Point initialSize = new Point();
        Point baseSize = new Point();
        try {
            mWm.getInitialDisplaySize(Display.DEFAULT_DISPLAY, initialSize);
            mWm.getBaseDisplaySize(Display.DEFAULT_DISPLAY, baseSize);
            System.out.println(&quot;Physical size:&quot; + initialSize.x + &quot;x&quot; + initialSize.y);
            if (!initialSize.equals(baseSize)){
                System.out.println(&quot;Override size:&quot; + baseSize.x + &quot;x&quot; + baseSize.y);
            }
        } catch (RemoteException e){
        }
        return;
    } else if (&quot;reset&quot;.equals(size)){
        w = h = -1;
    } else {
        int div = size.indexOf(&#39;x&#39;);
        if (div &lt;= 0 || div &gt;= (size.length() - 1)){
            System.err.println(&quot;Error: bad size&quot; + size);
            return;
        }
        String wstr = size.substring(0,div);
        String hstr = size.substring(div + 1);
        try {
            w = parseDimension(wstr);
            h = parseDimension(hstr);
        } catch (NumberFormatException e){
            System.err.println(&quot;Error: bad number&quot; + e);
            return;
        }
    }
    
    try {
        if (w &gt;= 0 &amp;&amp; h &gt;= 0){
            mWm.setForcedDisplaySize(Display.DEFAULT_DISPLAY, w, h);
        } else {
            mWm.clearForcedDisplaySize(Display.DEFAULT_DISPLAY);
        }
    } catch (RemoteException e) {
    }
}
</code></pre>

<p>在 <code>runDisplaySize()</code> 方法中，会先判断 size 命令后面有没有跟其它参数，如果没有，则认为是一次查询操作，会将查询到的结果输出。</p>

<p>而如果是 reset 方法的话，就将 w 、h 这两个代表宽高的值，设置为 -1，最终会通过 <code>mWm.clearForcedDisplaySize()</code> 方法，将屏幕的 size 还原。</p>

<p>否者就从输入的参数中，通过 x 进行分割，拿到我们输入的宽高。最终通过 <code>mWm.setForcedDisplaySize()</code> 方法，将当前屏幕的 size 修改成我们输入的结果。</p>

<p>在设置size 的时候，还会通过 <code>parseDimens()</code> 方法，重新计算一下输入的尺寸。</p>

<p>private int parseDimension(String s) throws NumberFormatException {<br/>
    if (s.endsWith(&quot;px&quot;)) {<br/>
        return Integer.parseInt(s.substring(0, s.length() - 2));<br/>
    }<br/>
    if (s.endsWith(&quot;dp&quot;)){<br/>
        int density;<br/>
        try {<br/>
            density = mWm.getBaseDisplayDensity(Display.DEFAULT_DISPLAY);<br/>
        } catch (RemoteException e) {<br/>
            density = DisplayMetrics.DENSITY_DEFAULT;<br/>
        }<br/>
        return Integer.parseInt(s.substring(0,s.length() - 2)) * density / DisplayMetrics.DENSITY_DEFAULT;<br/>
    }<br/>
    return Integer.parseInt(s);<br/>
}</p>

<p>从这里可以看出，它支持两个尺寸，px 和 dp ，如果如果不指定尺寸，则默认认为是 px 。</p>

<p>到这里就完成了一次通过 <code>wm size</code> 命令，修改设备屏幕参数的全过程，跟多细节可以自行查阅源码。</p>

<p>源码的在线地址：</p>

<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fandroidxref.com%2F7.1.1_r6%2Fxref%2Fframeworks%2Fbase%2Fcmds%2Fwm%2Fsrc%2Fcom%2Fandroid%2Fcommands%2Fwm%2FWm.java">androidxref.com/7.1.1_r6/xr…</a></p>

<h2 id="toc_8">实施修改设备参数</h2>

<p>既然已经讲清楚 wm 命令的所有细节了，那么我们只需要拿到我们需要适配的设备的 size 和 density。就可以在我们自己的设备上模拟出对应的效果。</p>

<p>我这里收集了一些比较常用的设备参数，可以供大家参考一下。</p>

<ul>
<li>魅族MX3：440，1080x1800</li>
<li>一加5：420，1080x1920</li>
<li>红米NOTE，320，720x1280</li>
<li>华为MATE7，480，1080x1812</li>
<li>MOTO-G5，480，1080x1920</li>
<li>Moto-tx1095，432，1080x1790</li>
<li>Nexus5x，420，1080x1794</li>
<li>Nexus6p，560，1440x2392</li>
<li>奇酷360，460，1080x1920</li>
<li>VivoX5，320，720x1280</li>
</ul>

<p>当然，最重要的是拿到公司各种 CEO、CTO、CxO 正在使用的手机参数，进行一波适配，哈哈。</p>

<p>下面，我们随便挑两个设备的参数进行修改，然后看看运行后的效果。</p>

<p>命令如下:</p>

<p>// 修改成 一加5</p>

<p>adb shell wm density 420</p>

<p>adb shell wm size 1080x1920</p>

<p>// 修改成 Moto-tx1095</p>

<p>adb shell wm density 432</p>

<p>adb shell wm size 1080x1790</p>

<p>下面，从做到右，分别是原本的尺寸、一加5、Moto-tx1095。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171016150816770425798.jpg" alt="20171016150816770425798.jpg"/><figcaption>20171016150816770425798.jpg</figcaption></figure></p>

<p>其实看着差异不大，只能说桌面布局写的挺好的，所以说，如果布局写的好的话，是可以避免在不同设备上看着很明显的不同的问题 ，就像现在这样。</p>

<h2 id="toc_9">题外话</h2>

<p>实际上 wm 命令，也是有一些其它问题的，例如有时候通过 wm 命令修改 UI 的的时候，刷新会不及时，会卡顿，所以选择一个性能比较好的手机是一个缓解的办法。或者修改参数之后，退出 App 重新进也是一个不错的办法。</p>

<p>如果调整到一个太特殊的参数，例如 200x1000 这种，可能渲染起来会很奇怪。但是如果只是做一些常规设备参数的修改，只要修改值在合理的范围内，一般都是可以的。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-02T22:49:27+08:00" itemprop="datePublished">2017/9/2</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207870919.html" itemprop="url">
		Android学习路线</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">前言</h2>

<p>Android学习路线从4个阶段来对Android的学习过程做一个全面的分析:Android初级、中级、高级以及资深工程师。<br/>
只针对Android应用开发，不针对Rom开发和逆向工程等。方便起见虚拟“小D”为成长人物进行描述。</p>

<h2 id="toc_1">初级工程师</h2>

<p>小D之前完全没接触过Android开发，对编程基础、数据结构、C语言都有一定基础，Java语法什么的也都掌握的比较好，并不会搞Android。 </p>

<p>首先需要购买一本Android入门的书籍（现在更推荐直接看视频教程结合网上教程动手练习），为了更快地学习Android，小D业余时间也都用来一边看书一边照着书中的例子敲代码，结果2周时间小D就把这本书学了一遍。看完这本书后对Android的历史、结构、代码规范等都有了一个大概的了解，可以写出一些简单的Activity。这个时候在小D眼里，Android开发很简单很好玩，通过在xml中摆放一些按钮文本框什么的就可以做一些界面了。</p>

<p>小D开始跟着他的技术导师做需求，一些简单的小需求不在话下了。突然有一天来了一个需求，该需求要求在Activity中为一个button加一个动画效果，小D慌了：“完全没接触过，书上也没有讲，怎么办呢？”小D冷静了下，搜索“Android 动画”，打开前几个链接，恍然大悟，照着网上的例子把需求给实现了。 </p>

<p>后来导师告诉他：“学好Android，官方文档是必须看的，既全面又权威”。然后小D如获至宝，花了一年时间把上面的guide和training都看了一遍，并且他还动手抄了几个小例子。</p>

<p>有一天，小D又需要做一个动画相关的需求，又搜索“Android 动画”，突然他楞了一下：”总不能每次写动画都要搜索吧！“，于是他在CSDN开了一个博客，把动画相关的知识点都写上去，为的是后面再写动画相关的代码就不用去搜了，事实如何呢？后面再写动画相关的代码，的确不用再去搜了，因为通过写一篇动画博客，他把动画相关的细节都已经记住了，这样他就可以不用再去参考任何文档了，后来小D还学会了把一些琐碎的不方便放在博客上的东西写到了笔记上面，什么时候忘了10秒钟以内都可以快速找回来，而不是花10分钟去再次搜索一遍。</p>

<p>总结：Android入门的时候，需要有一本入门书（或者视频教程），好好学习书中的内容，同时花一年时间把Android官方文档中的training和guide看一遍，同时通过写博客和记笔记的方式来做总结，建议让自己的每篇博客都有价值些。通过一年时间的学习，相信每个人都可以达到中级工程师的水平。</p>

<p>技术要求：</p>

<ul>
<li>基本知识点<br/>
比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术</li>
<li>书籍推荐<br/>
《第一行代码 Android》、《疯狂Android》</li>
</ul>

<h2 id="toc_2">中级工程师</h2>

<p>小D经过一年的努力学习终于成为Android中级工程师了。到了中级工程师，已经可以在公司里干很多体力活了，但是一些很重要的任务小D还不能一个人承担起来，这个时候小D需要学习的内容就很多了，如下所示：</p>

<ul>
<li>AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别；</li>
<li>Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用；</li>
<li>多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等；</li>
<li>事件分发：弹性滑动、滑动冲突等；</li>
<li>玩转View：View的绘制原理、各种自定义View；</li>
<li>动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理；</li>
<li>懂性能优化、熟悉mat等工具</li>
<li>懂点常见的设计模式</li>
</ul>

<h3 id="toc_3">学习方法</h3>

<p>阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。<br/>
如何阅读源码呢？这是个头疼的问题，但是源码必须要读。阅读源码的时候不要深入代码细节不可自拔，要关注代码的流程并尽量挖掘出对应用层开发有用的结论。另外仔细阅读源码中对一个类或者方法的注释，在看不懂源码时，源码中的注释可以帮你更好地了解源码中的工作原理，这个过程虽然艰苦，但是别无他法。<br/>
如何玩转自定义View呢？我们要透过现象看本质，更多地去关注自定义view所需的知识点：</p>

<ul>
<li>搞懂view的滑动原理</li>
<li>搞懂如何实现弹性滑动</li>
<li>搞懂view的滑动冲突</li>
<li>搞懂view的measure、layout和draw</li>
<li>然后再学习几个已有的自定义view的例子</li>
<li>最后就可以搞定自定义view了，所谓万变不离其宗</li>
</ul>

<p>大概再需要1-2年时间，即可达到高级工程师的技术水平。我个人认为通过《Android开发艺术探索》和《Android群英传》可以缩短这个过程为0.5-1年。注意，达到高级工程师的技术水平不代表就可以立刻成为高级工程师（受机遇、是否跳槽的影响），但是技术达到了，成为高级工程师只是很简单的事。</p>

<h3 id="toc_4">技术要求：</h3>

<ul>
<li>稍微深入的知识点<br/>
AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等</li>
<li>书籍推荐<br/>
《Android开发艺术探索》、《Android群英传》</li>
</ul>

<h2 id="toc_5">高级工程师</h2>

<p>小D成为了梦寐以求的高级工程师。这个时候小D的Android水平已经不错了，但是小D的目标是资深工程师，小D听说资深工程师月薪可以达到30k+。<br/>
为了成为Android资深工程师，需要学习的东西就更多了，并且有些并不是那么具体了，如下所示：</p>

<ul>
<li>继续加深理解”稍微深入的知识点“中所定义的内容</li>
<li>了解系统核心机制：
<ol>
<li>了解SystemServer的启动过程</li>
<li>了解主线程的消息循环模型</li>
<li>了解AMS和PMS的工作原理</li>
<li>能够回答问题”一个应用存在多少个Window？“</li>
<li>了解四大组件的大概工作流程</li>
<li>…</li>
</ol></li>
<li>基本知识点的细节
<ol>
<li>Activity的启动模式以及异常情况下不同Activity的表现</li>
<li>Service的onBind和onReBind的关联</li>
<li>onServiceDisconnected(ComponentName className)和binderDied()的区别</li>
<li>AsyncTask在不同版本上的表现细节</li>
<li>线程池的细节和参数配置</li>
<li>…</li>
</ol></li>
<li>熟悉设计模式，有架构意识</li>
</ul>

<h3 id="toc_6">学习方法</h3>

<p>这个时候已经没有太具体的学习方法了，无非就是看书、看源码和做项目，平时多种总结，尽量将知识融会贯通从而形成一种体系化的感觉。<br/><br/>
同时这个阶段对架构是有一定要求的，架构是抽象的，但是设计模式是具体的，所以一定要加强下设计模式的学习。关于设计模式的学习，推荐《Android 源码设计模式解析与实战》，既可以学习设计模式，又可能体会到Android源码中的设计思想。  </p>

<h3 id="toc_7">技术要求：</h3>

<ul>
<li>稍微深入的知识点</li>
<li>系统核心机制</li>
<li>基本知识点的细节</li>
<li>设计模式和架构</li>
<li>书籍推荐<br/>
《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》</li>
</ul>

<h2 id="toc_8">资深工程师</h2>

<p>更多了解不同业务的架构问题，内核源码设计原理，整理并开源自己的组件</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-09-02T22:06:27+08:00" itemprop="datePublished">2017/9/2</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207870883.html" itemprop="url">
		Android学习目录</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981318733039.png" alt="20171105150981318733039.png"/><figcaption>20171105150981318733039.png</figcaption></figure></p>

<h2 id="toc_0">基础知识</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981323655802.jpg" alt="20171105150981323655802.jpg"/><figcaption>20171105150981323655802.jpg</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110515098132948858.jpg" alt="2017110515098132948858.jpg"/><figcaption>2017110515098132948858.jpg</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110515098133212830.jpg" alt="2017110515098133212830.jpg"/><figcaption>2017110515098133212830.jpg</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981334056897.jpg" alt="20171105150981334056897.jpg"/><figcaption>20171105150981334056897.jpg</figcaption></figure></p>

<p>{% post_link android-learning-path Android学习路线 %}  </p>

<p>{% post_link android-study Android学习资源 %}</p>

<h3 id="toc_1">Java基础</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981320969279.jpg" alt="20171105150981320969279.jpg"/><figcaption>20171105150981320969279.jpg</figcaption></figure></p>

<h4 id="toc_2">Java字符串(String、StringBuilder、StringBuffer)</h4>

<h4 id="toc_3">Java线程池(newFixedThreadPool、newSingleThreadExecutor、newCacheThreadPool)</h4>

<ul>
<li><p><code>newFixedThreadPool</code>：newFixedThreadPool,创建固定大小的线程池，poolCoreSize和maxPoolSize 相等，到达coreSize,则将新的任务放到缓存队列，有线程执行完毕，直接去取。</p></li>
<li><p><code>newSingleThreadExecutor</code>：newSingleThreadExecutor,创建一个单线程的线程池，核心池的大小和最大池大小都为1.</p></li>
<li><p><code>newCacheThreadPool</code>：newCacheThreadPool,无大小限制的线程池，提交一个任务就创建一个线程执行。</p></li>
</ul>

<h4 id="toc_4">Java集合</h4>

<p><strong>Collection</strong>:</p>

<ul>
<li>List:
<ul>
<li>LinkedList</li>
<li>ArrayList</li>
<li>Vector</li>
</ul></li>
<li>Set
<ul>
<li>HashSet</li>
<li>TreeSet</li>
</ul></li>
</ul>

<p><strong>Map</strong>:</p>

<ul>
<li>HashMap</li>
<li>TreeMap</li>
<li>HashTable</li>
</ul>

<h4 id="toc_5">Java内存模型</h4>

<p>Java 内存模型这一块非常重要，因为它涉及到我们程序的性能，我们需要知道，内存是如何分配的，成员变量、静态变量、局部变量、对象等各自分配到哪一个区：栈内存、堆内存</p>

<h3 id="toc_6">数据结构</h3>

<h3 id="toc_7">面向对象思想</h3>

<p>OOP的的三大特性：封装、继承、多态。</p>

<h3 id="toc_8">设计模式</h3>

<h4 id="toc_9">程序设计6大原则</h4>

<ul>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特法则</li>
<li>开闭原则</li>
</ul>

<h3 id="toc_10">Android Studio</h3>

<p>{% post_link android-studio-plugin Android Studio插件 %}  </p>

<p>{% post_link android-studio-keywords Android Studio快捷键 %}</p>

<h3 id="toc_11">Android SDK</h3>

<h3 id="toc_12">Activity</h3>

<p>{% post_link android-activity-launcher Android-启动Acivity的工作流程 %}</p>

<h3 id="toc_13">Service</h3>

<h3 id="toc_14">BroadcastReceiver</h3>

<h3 id="toc_15">ContentProvider</h3>

<h3 id="toc_16">StatusBar</h3>

<p>{% post_link android-statusbar Android-StatusBar详细学习 %}</p>

<h3 id="toc_17">Fragment</h3>

<h4 id="toc_18">DialogFragment</h4>

<p>{% post_link android-dialogfragment Android-DialogFragment详细学习 %}</p>

<h2 id="toc_19">UI</h2>

<p>{% post_link android-xml Android-XML参数详细了解 %}</p>

<h3 id="toc_20">Layout</h3>

<p>{% post_link android-layout Android-Layout详细学习 %}</p>

<h4 id="toc_21">FrameLayout</h4>

<h4 id="toc_22">LinearLayout</h4>

<h4 id="toc_23">TableLayout</h4>

<h4 id="toc_24">GridLayout</h4>

<h4 id="toc_25">RelativeLayout</h4>

<h4 id="toc_26">DrawerLayout</h4>

<h4 id="toc_27">SlidingPaneLayout</h4>

<h4 id="toc_28">CoordinatorLayout</h4>

<p>{% post_link android-coordinatorLayout Android-CoordinatorLayout %}</p>

<h3 id="toc_29">View</h3>

<p>{% post_link android-view-workflow Android-View的工作流程 %}</p>

<h4 id="toc_30">Widgets</h4>

<h5 id="toc_31">TextView</h5>

<h5 id="toc_32">EditText</h5>

<p>{% post_link android-edittext Android-EditText详细学习 %}  </p>

<p>{% post_link android-windowSoftInputMode Android-WindowSoftInputMode详细学习 %}  </p>

<h5 id="toc_33">Button</h5>

<h5 id="toc_34">RadioButton</h5>

<h5 id="toc_35">CheckBox</h5>

<h5 id="toc_36">Switch</h5>

<h5 id="toc_37">ToggleButton</h5>

<h5 id="toc_38">ImageButton</h5>

<h5 id="toc_39">ImageView</h5>

<p>{% post_link android-imageview Android-ImageView详细学习 %}</p>

<h5 id="toc_40">ProgressBar</h5>

<h5 id="toc_41">SeekBar</h5>

<h5 id="toc_42">RatingBar</h5>

<h5 id="toc_43">Spinner</h5>

<h5 id="toc_44">WebView</h5>

<h4 id="toc_45">Containers</h4>

<h5 id="toc_46">RadioGroup</h5>

<h5 id="toc_47">ListView</h5>

<h5 id="toc_48">GridView</h5>

<h5 id="toc_49">ExpandableListView</h5>

<h5 id="toc_50">ScrollVeiw</h5>

<h5 id="toc_51">TabHost</h5>

<h5 id="toc_52">SlidingDrawer</h5>

<h5 id="toc_53">Gallery</h5>

<h5 id="toc_54">VideoView</h5>

<h5 id="toc_55">DialerFilter</h5>

<h5 id="toc_56">RecyclerView</h5>

<p>{% post_link android-recyclerview Android-RecyclerView详细学习 %}  </p>

<h5 id="toc_57">CardView</h5>

<h5 id="toc_58">PopuWindow</h5>

<p>{% post_link android-popupwindow Android-PopupWindow详细学习 %}</p>

<h5 id="toc_59">DialogFragment</h5>

<h4 id="toc_60">Date&amp;Time</h4>

<h5 id="toc_61">TextClock</h5>

<h5 id="toc_62">AnalogClock</h5>

<h5 id="toc_63">Chronometer</h5>

<h5 id="toc_64">DatePicker</h5>

<h5 id="toc_65">TimePicker</h5>

<h5 id="toc_66">CalendarView</h5>

<h4 id="toc_67">Expert</h4>

<h5 id="toc_68">Space</h5>

<h5 id="toc_69">CheckedTextView</h5>

<h5 id="toc_70">QuickContactBadge</h5>

<h5 id="toc_71">ExtractEditText</h5>

<h5 id="toc_72">AutoCompleteTextView</h5>

<h5 id="toc_73">MultiAutoCompleteText</h5>

<h5 id="toc_74">NumberPicker</h5>

<h5 id="toc_75">ZoomButton</h5>

<h5 id="toc_76">ZoomController</h5>

<h5 id="toc_77">GestureOverlayView</h5>

<h5 id="toc_78">SurfaceView</h5>

<h5 id="toc_79">TexttureView</h5>

<h5 id="toc_80">StackView</h5>

<h5 id="toc_81">ViewStub</h5>

<p>{% post_link android-viewstub Android-ViewStub详细学习 %}</p>

<h5 id="toc_82">ViewAnimator</h5>

<h5 id="toc_83">ViewFlipper</h5>

<h5 id="toc_84">ViewSwitcher</h5>

<h5 id="toc_85">ImageSwitcher</h5>

<h5 id="toc_86">TextSwitcher</h5>

<h5 id="toc_87">AdapterViewFlipper</h5>

<h5 id="toc_88">ViewPager</h5>

<p>{% post_link android-viewpager Android-Viewpager详细学习 %}</p>

<h4 id="toc_89">Custom</h4>

<h5 id="toc_90">include</h5>

<h5 id="toc_91">fragment</h5>

<h5 id="toc_92">requestFocus</h5>

<h3 id="toc_93">Custom View</h3>

<h4 id="toc_94">extend system View</h4>

<h4 id="toc_95">combination View</h4>

<h4 id="toc_96">extend View</h4>

<p>{% post_link android-view Android-View详细学习 %}  </p>

<p>{% post_link android-draw Android自定义控件——绘图 %}  </p>

<h5 id="toc_97">ViewTreeObserver</h5>

<p>{% post_link android-getViewTreeObserver Android-getViewTreeObserver() %}</p>

<h5 id="toc_98">ColorFilter</h5>

<p>{% post_link android-colorfilter Android-ColorFilter详细学习 %}</p>

<h5 id="toc_99">Xfermode</h5>

<p>{% post_link android-xfermode Android-Xfermode详细学习 %}</p>

<h5 id="toc_100">Paint</h5>

<p>{% post_link android-paint Android-Paint详细学习 %}  </p>

<p>{% post_link android-paints Android-Paint详细学习 %}</p>

<h5 id="toc_101">Matrix</h5>

<p>{% post_link android-matrix Android-Matrix详细学习 %}  </p>

<h5 id="toc_102">Scroller</h5>

<p>{% post_link android-scroller Android-Scroller详细学习 %}</p>

<h5 id="toc_103">ViewConfiguration</h5>

<p>{% post_link android-viewconfiguration Android-ViewConfiguration解析 %}</p>

<h5 id="toc_104">MotionEvent</h5>

<p>{% post_link android-motionevent Android-MotionEvent解析 %}</p>

<h5 id="toc_105">VelocityTracker</h5>

<p>{% post_link android-velocitytracker Android-VelocityTracker详细学习 %}</p>

<h5 id="toc_106">SpannableString</h5>

<p>{% post_link android-spannablestring Android-SpannableString设置复合文本 %}</p>

<h3 id="toc_107">animation</h3>

<p>{% post_link android-animation Android动画详细学习 %}  </p>

<p>{% post_link android-activity-handoff-animation Android切换动画 %}</p>

<h4 id="toc_108">ViewAnimation</h4>

<h5 id="toc_109">TweenAnimation</h5>

<h5 id="toc_110">FrameAnimation</h5>

<h4 id="toc_111">PropertyAnimation</h4>

<h5 id="toc_112">ValueAnimator</h5>

<h5 id="toc_113">ObjectAnimator</h5>

<h5 id="toc_114">AnimatorSet</h5>

<h4 id="toc_115">VectorAnimation</h4>

<h5 id="toc_116">SVG</h5>

<h5 id="toc_117">VectorDrawable</h5>

<h5 id="toc_118">AnimatedVectorDrawable</h5>

<h3 id="toc_119">Resource</h3>

<h4 id="toc_120">assets</h4>

<h5 id="toc_121">AssetManager</h5>

<h4 id="toc_122">res</h4>

<h5 id="toc_123">anim</h5>

<h5 id="toc_124">animator</h5>

<h5 id="toc_125">color</h5>

<h5 id="toc_126">drawable</h5>

<h5 id="toc_127">interpolator</h5>

<h5 id="toc_128">layout</h5>

<h5 id="toc_129">menu</h5>

<h5 id="toc_130">raw</h5>

<h5 id="toc_131">values</h5>

<h6 id="toc_132">arrays</h6>

<h6 id="toc_133">attrs</h6>

<h6 id="toc_134">bools</h6>

<h6 id="toc_135">colors</h6>

<h6 id="toc_136">string</h6>

<h6 id="toc_137">styles</h6>

<h4 id="toc_138">OpenGL</h4>

<h4 id="toc_139">Bitmap</h4>

<h5 id="toc_140">BitmapFactory</h5>

<p>{% post_link android-bitmapfactory Android-BitmapFactory详细学习 %}</p>

<h2 id="toc_141">Material Design 系列</h2>

<h3 id="toc_142">Toolbar的使用</h3>

<p>{% post_link android-toolbar Android-ToolBar详细学习 %}</p>

<h3 id="toc_143">AppbarLayout+CollapsingToolbarLayout</h3>

<p>{% post_link android-appbarlayout-collapsingtoolbar-toolbar Android-AppBarLayout&amp;CollapsingToolbar&amp;Toolbar组合使用 %}  </p>

<p>{% post_link android-appbarlayout Android-AppBarLayout %}</p>

<h3 id="toc_144">Behavior 相关：</h3>

<ul>
<li>BottomSheetBehavior</li>
<li>BottomSheetDialog</li>
<li>SwipeDismissBehavior</li>
<li>自定义Behavior</li>
</ul>

<h3 id="toc_145">TextInputLayout + TextInputEditText</h3>

<h3 id="toc_146">TabLayout</h3>

<h3 id="toc_147">BottomNavigationView</h3>

<h3 id="toc_148">CardView 阴影卡片</h3>

<h3 id="toc_149">Snackbar , FloatActionButton</h3>

<h2 id="toc_150">通信</h2>

<h3 id="toc_151">Http</h3>

<h3 id="toc_152">Socket</h3>

<h3 id="toc_153">Bluetooth</h3>

<h3 id="toc_154">NFC</h3>

<h3 id="toc_155">Headset</h3>

<h3 id="toc_156">USB</h3>

<h2 id="toc_157">数据持久化</h2>

<h3 id="toc_158">Sqlite</h3>

<h4 id="toc_159">SQLiteOpenHelper</h4>

<h4 id="toc_160">ContentProvider</h4>

<h3 id="toc_161">File</h3>

<p>{% post_link android-save-method Android存储方式以及路径API %}</p>

<h4 id="toc_162">InternalStorage</h4>

<h4 id="toc_163">ExternalStorage</h4>

<h3 id="toc_164">SharedPreferences</h3>

<h2 id="toc_165">多线程</h2>

<p>{% post_link android-thread Android Thread %}  </p>

<h2 id="toc_166">性能</h2>

<p>{% post_link android-performance-optimize Android性能优化 %}</p>

<h3 id="toc_167">UI优化</h3>

<h4 id="toc_168">布局层次结构</h4>

<p>{% post_link android-view-performance-optimizing Android界面性能调优 %}</p>

<h4 id="toc_169">抽象布局使用</h4>

<h4 id="toc_170">HierarchyViewer</h4>

<h4 id="toc_171">Lint工具</h4>

<h3 id="toc_172">内存优化</h3>

<h4 id="toc_173">OOM</h4>

<h4 id="toc_174">ANR</h4>

<h4 id="toc_175">分析</h4>

<h5 id="toc_176">Heap</h5>

<h5 id="toc_177">adb shell</h5>

<p>{% post_link android-adb Android-ADB命令 %}</p>

<h6 id="toc_178">dumpsys meminfo</h6>

<h6 id="toc_179">showmap</h6>

<h5 id="toc_180">TraceView</h5>

<h5 id="toc_181">Dalvik日志</h5>

<h5 id="toc_182">logcat</h5>

<h5 id="toc_183">MAT</h5>

<h3 id="toc_184">电量优化</h3>

<h3 id="toc_185">流量优化</h3>

<h2 id="toc_186">调试(Debug)</h2>

<p>{% post_link android-debug Android-Debug %}</p>

<h3 id="toc_187">Logcat</h3>

<h3 id="toc_188">adb</h3>

<h3 id="toc_189">HierarchyViewer</h3>

<h3 id="toc_190">TraceView</h3>

<h3 id="toc_191">Heap</h3>

<h3 id="toc_192">Lint</h3>

<h2 id="toc_193">适配</h2>

<h3 id="toc_194">OS Version</h3>

<h4 id="toc_195">min SDK</h4>

<h3 id="toc_196">UI界面适配</h3>

<p>{% post_link android-ui-adapt Android界面适配 %}</p>

<p>{% post_link android-screen-adapt Android屏幕适配 %}</p>

<h4 id="toc_197">drawable</h4>

<h2 id="toc_198">测试</h2>

<h3 id="toc_199">Monkey</h3>

<h3 id="toc_200">MonkeyRunner</h3>

<h3 id="toc_201">JUnit</h3>

<h3 id="toc_202">Robotium</h3>

<h3 id="toc_203">Appium</h3>

<h3 id="toc_204">Athrun(TMTS)</h3>

<h3 id="toc_205">UIAutomator</h3>

<h2 id="toc_206">安全</h2>

<h3 id="toc_207">服务器安全</h3>

<h3 id="toc_208">通信安全</h3>

<h4 id="toc_209">与服务器通信</h4>

<h4 id="toc_210">组件间通信</h4>

<h3 id="toc_211">反编译</h3>

<p>{% post_link android-decompile Android反编译 %}  </p>

<p>{% post_link android-get-sha1 Android-获取sha1 %}  </p>

<p>{% post_link android-smali Android-smali文件格式 %}</p>

<h3 id="toc_212">数据加密</h3>

<h3 id="toc_213">数据验签</h3>

<h3 id="toc_214">代码混淆</h3>

<h3 id="toc_215">WebView/JS安全调用</h3>

<h3 id="toc_216">MD5、DES、RSA、https、证书、权限</h3>

<h2 id="toc_217">NDK</h2>

<p>{% post_link android-ndk Android-NDK %}</p>

<h3 id="toc_218">JNI</h3>

<h3 id="toc_219">C语言</h3>

<h3 id="toc_220">C++</h3>

<h2 id="toc_221">Android 多媒体</h2>

<h3 id="toc_222">相机开发</h3>

<h4 id="toc_223">使用自带的相机APP拍照</h4>

<h4 id="toc_224">系统相册选择照片</h4>

<h4 id="toc_225">系统相机或相册获取的照片裁剪</h4>

<h4 id="toc_226">使用相机API 开发相机:</h4>

<ul>
<li>Android 5.0 （API 21 ）以下 使用Camera API </li>
<li>Android 5.0 以上使用 Camera2 API </li>
</ul>

<h4 id="toc_227">自定义相册开发</h4>

<h4 id="toc_228">自定义裁剪界面</h4>

<h3 id="toc_229">视频开发</h3>

<h4 id="toc_230">视频播放</h4>

<ul>
<li>MediaPlayer</li>
<li>VideoView</li>
</ul>

<h4 id="toc_231">视频编解码</h4>

<h3 id="toc_232">音频开发</h3>

<h4 id="toc_233">AudioPlayer</h4>

<h4 id="toc_234">音乐播放器</h4>

<h2 id="toc_235">Android权限配置</h2>

<h2 id="toc_236">Gradle</h2>

<h3 id="toc_237">自定义Gradle插件</h3>

<h3 id="toc_238">Gradle多渠道打包</h3>

<h2 id="toc_239">手机功能</h2>

<h3 id="toc_240">电话</h3>

<h4 id="toc_241">联系人</h4>

<h4 id="toc_242">通话记录</h4>

<h3 id="toc_243">短/彩信</h3>

<h3 id="toc_244">Audio</h3>

<h3 id="toc_245">SD卡</h3>

<h3 id="toc_246">感应器</h3>

<h4 id="toc_247">加速</h4>

<h4 id="toc_248">方向</h4>

<h4 id="toc_249">重力</h4>

<h4 id="toc_250">光线</h4>

<h4 id="toc_251">陀螺仪</h4>

<h4 id="toc_252">磁场</h4>

<h4 id="toc_253">接近</h4>

<h4 id="toc_254">温度</h4>

<h4 id="toc_255">压力</h4>

<h4 id="toc_256">线性加速度</h4>

<h4 id="toc_257">旋转</h4>

<h2 id="toc_258">第三方扩展</h2>

<h3 id="toc_259">地图</h3>

<h3 id="toc_260">语音识别</h3>

<h3 id="toc_261">支付</h3>

<h3 id="toc_262">统计分析</h3>

<h3 id="toc_263">广告</h3>

<h2 id="toc_264">其他</h2>

<h3 id="toc_265">Intent</h3>

<h3 id="toc_266">AndroidManifest</h3>

<h3 id="toc_267">AIDL</h3>

<h3 id="toc_268">Wifi</h3>

<p>{% post_link android-wifi Android-WiFi %}</p>

<h3 id="toc_269">国际化</h3>

<h3 id="toc_270">响应式编程</h3>

<p>{% post_link android-permissions Android权限机制 %}</p>

<h3 id="toc_271">其他</h3>

<p>{% post_link android-responsive-code Android响应式编程 %}  </p>

<p>{% post_link android-mvp Android MVP模式 %}  </p>

<p>{% post_link android-cold-launch Android冷启动实现APP秒开 %}  </p>

<p>{% post_link android-studio-bitbucket AndroidStudio关联Bitbucket %}  </p>

<p>{% post_link android-issues Android-Issues %}  </p>

<p>{% post_link android-base-class Android-基类实现 %}  </p>

<p>{% post_link android-modularization Android组件化学习%}</p>

<h2 id="toc_272">Library</h2>

<p>{% post_link android-library Android-开发中常用的支持库 %}  </p>

<p>{% post_link android-efficient-tools Android高效开发工具库 %}  </p>

<p>{% post_link android-quick-develop-frame Android快速开发框架 %}  </p>

<p>{% post_link android-picasso Android-Picasso图片框架 %}  </p>

<p>{% post_link android-greendao Android-GreenDao3.2.0的使用 %}  </p>

<p>{% post_link android-eventbus Android-EventBus3.0的使用 %}  </p>

<p>{% post_link android-common-android-library Android-常用的库 %}  </p>

<p>{% post_link android-fresco Android-Fresco详细学习 %}  </p>

<p>{% post_link android-rxjava Android-RxJava详细学习 %}  </p>

<p>{% post_link android-gson Android-Gson详细学习 %}  </p>

<p>{% post_link android-retrofit Android-Retrofit详细学习 %}  </p>

<p>{% post_link android-databinding Android-DataBinding详细学习 %}</p>

<h2 id="toc_273">实现</h2>

<p>{% post_link android-custom-lock-screen Android自定义锁屏页 %}  </p>

<p>{% post_link android-custom-skin Android自定义皮肤 %}</p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="Android_4.html">Prev</a>  
	 <a class="next" href="Android_6.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>