<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15626502775041.html">
                
                  <h1>Android项目从立项到上线</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>最近在组建项目组从0开始开发项目，从立项到上线，有一些心得，包括项目规范、结构、优化、三方等，与大家分享，一起修仙！</p>

<p>接下来我会以自己写的两个项目为例，结合起来分析。代码已经上传github：</p>

<ul>
<li>Material Design风格项目 <a href="https://github.com/shuaijia/MaterialDesignProject">点击前往</a> 喜欢就给个star<sup>_^</sup></li>
<li>UI、Base、网络等封装库项目 <a href="https://github.com/shuaijia/JSBaseDemo">点击前往</a> 喜欢也给个star喽</li>
</ul>

<p>先上图来看看吧：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981004338352.png" alt="20171104150981004338352.png"/></p>

<p>项目采用<strong>MVP+Retrofit+RxJava+Gson+Glide+Material Design</strong>设计</p>

<p>同时也使用了<strong>EventBus</strong>事件总线、<strong>GreenDao</strong>数据库、<strong>SurfaceView+MediaPlayer视频播放器</strong>等主要技术。</p>

<p>ok！项目就简单介绍到这里，接下来开始我们的修仙之路。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981008811224.png" alt="20171104150981008811224.png"/></p>

<h2 id="toc_0">项目整体分析</h2>

<h3 id="toc_1">UI风格</h3>

<h4 id="toc_2">logo</h4>

<h4 id="toc_3">主题风格：</h4>

<ul>
<li>Material Design</li>
<li>仿ios</li>
<li>主界面–侧拉</li>
<li>主界面–仿微信 选项卡等</li>
</ul>

<h3 id="toc_4">技术方案</h3>

<h4 id="toc_5">整体分析项目，确定整体技术方案，之后的开发中按照技术方案执行，同时编写相关文档。</h4>

<ul>
<li>项目架构</li>
<li>网络框架</li>
<li>图片处理</li>
<li>数据处理/接口格式</li>
<li>三方使用：统计、推送、更新等</li>
</ul>

<h3 id="toc_6">可行性分析</h3>

<p>邀请项目经理、技术负责人、产品经理、后端开发、测试等共同分析技术方案的可行性，并相应调整技术方案。</p>

<h3 id="toc_7">工期</h3>

<p>根据项目需求和技术方案，给出开发时长；</p>

<p>根据工期要求，可适当调整技术方案。</p>

<h3 id="toc_8">测试用例</h3>

<p>测试人员开始整理、编写测试用例和项目标准文档；</p>

<p>个人觉得开发人员应该参与到测试工作中，这样方便自己对业务逻辑和功能分析全面，也帮助测试人员分析项目功能和技术，便于写出更加全面的测试用例。</p>

<h2 id="toc_9">开发规范</h2>

<p>其实Android、Ios、Server等各端开发人员，都应该有完整的、严格的开发规范，这里我只说一下Android端的开发规范：</p>

<p>以自己项目为例，涉及到以下几项：</p>

<ul>
<li>文档规范</li>
<li>资源命名规范</li>
<li>代码命名规范</li>
<li>代码注释规范</li>
<li>代码风格规范</li>
<li>服务器数据规范 等</li>
</ul>

<h3 id="toc_10">文档</h3>

<p>重要有以下几个文档：</p>

<ul>
<li>需求文档</li>
<li>产品原型图</li>
<li>完整UI图</li>
<li>接口文档</li>
<li>核心技术文档</li>
<li>重点逻辑文档</li>
<li>程序框架图</li>
<li>ER图、数据字典、类图等</li>
<li>测试文档</li>
</ul>

<h3 id="toc_11">资源文件命名规范</h3>

<p>名字全部小写，最好不用数字，全部英文，单词中间下划线隔开</p>

<h4 id="toc_12">drawable、anim等文件夹下</h4>

<p>名称结构为“技术点模块点空间类型_功能名”结构，技术点主要有：selector、translate、alpha、scale等，模块名主要有：login、pay、mine、setting等，控件类型主要有：button、textview、imageview、dialog等，功能名主要有：findpwd、request、back、next等。 </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981042494432.png" alt="20171104150981042494432.png"/></p>

<h4 id="toc_13">drawable-xhdpi等图片资源</h4>

<p>名称为“技术点模块点功能名”结构，技术点主要有：activity、fragment、item、include等，模块点主要有：login、setting、mine、pay等，功能名主要有：head、title、back、sure等。 </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981047164097.png" alt="20171104150981047164097.png"/></p>

<h4 id="toc_14">layout</h4>

<p>布局名称为“技术点模块功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。 </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981050013389.png" alt="20171104150981050013389.png"/></p>

<h4 id="toc_15">values</h4>

<p>布局名称为“技术点模块功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。 </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981053458526.png" alt="20171104150981053458526.png"/></p>

<h3 id="toc_16">代码命名规范</h3>

<h4 id="toc_17">包名</h4>

<p>包名为“根包名.技术点名.模块名”结构，<strong>全部小写</strong></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981056272553.png" alt="20171104150981056272553.png"/></p>

<h4 id="toc_18">类名</h4>

<p>采用 <strong>大驼峰</strong> 命名法，单词直接拼接，所有单词首字母大写</p>

<p>类名为“业务模块名 执行操作名 技术点名”结构，业务模块名主要有：home、lession、net、login，pay等，操作名主要有：Get、Set、Request、Login等，技术点名主要有：Activity、Fragment、View、Adapter等。 </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150981070542458.png" alt="20171104150981070542458.png"/></p>

<h4 id="toc_19">普通变量</h4>

<p>采用 <strong>小驼峰</strong> 命名法，第一个单词首字母小写，其他单词首字母大写。</p>

<p>普通变量为“名字简写 类型 功能名”结构，名字简写有：js等，类型主要有：Int、Double、Boolean、String、Char等，功能名有：Login、Number、Content等。 </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110515098119341868.png" alt="2017110515098119341868.png"/></p>

<h4 id="toc_20">常亮</h4>

<p>所有字母全部大写，中间下划线隔开</p>

<p>常量为“功能名_标识”结构，功能名主要有：LOGIN、REQUEST、PERSONINFO等，标识有SUCCESS、ERROR、URL等。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981196443079.png" alt="20171105150981196443079.png"/></p>

<h3 id="toc_21">方法名</h3>

<p>名字能体现出功能即可。不再累赘重述。</p>

<h2 id="toc_22">数据/接口定义</h2>

<h3 id="toc_23">建议</h3>

<ul>
<li>服务器返回数据采用json格式</li>
<li>json数据中无数据，必须返回空数组或空字符串，不可返回null</li>
<li>Android端使用gson或fastjson或jackson等三方解析工具解析</li>
<li>不建议使用官方JSONObject解析，容易出错</li>
<li>实体类属性名与json中字段名完全一致</li>
<li>json中字段名全部使用英文，不可英文、拼音夹杂</li>
<li>用户表识建议使用Cookie</li>
<li>建议使用POST解析，它对参数数量没有要求，也比较安全</li>
<li>为了传输安全，使用https请求 等</li>
<li>完善接口文档，建议每一版对应一个完整接口文档</li>
</ul>

<h2 id="toc_24">屏幕适配</h2>

<p>安卓设备分辨率、屏幕尺寸五花八门，碎片化严重，重点对市面上主流的720 * 1280和1080 * 1920手机进行适配，同时对于其他类型手机也要适配。</p>

<p>关于屏幕适配，之前写过一个Android屏幕完美适配方案，<a href="http://blog.csdn.net/jiashuai94/article/details/77639511">点击前往</a>，这里不再重复表述。</p>

<h2 id="toc_25">程序架构MVP</h2>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981206687113.png" alt="20171105150981206687113.png"/></p>

<h3 id="toc_26">上图介绍：</h3>

<p><strong>Contract</strong>：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。</p>

<p><strong>ViewInterface</strong>： view层接口，定义了view中的UI操作</p>

<p><strong>ModelInterface</strong>： model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等</p>

<p><strong>CallbackInterface</strong>： model层操作数据完成后的回调</p>

<p><strong>BasePersenter</strong>： Persenter父类，主要是对相关view的获取，销毁等操作</p>

<p><strong>View</strong>： view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应</p>

<p><strong>Model</strong>： model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack</p>

<p><strong>Persenter</strong>： persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示</p>

<h3 id="toc_27">MVP：</h3>

<p>MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。</p>

<p>使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要</p>

<p>现在比较流行MVVM架构，后续我会将MVVM总结，大家期待一下。。</p>

<h2 id="toc_28">package划分</h2>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981211916250.png" alt="20171105150981211916250.png"/></p>

<p>如上：主体按功能模块划分，同一级的还有一些技术点，如adapter、util、pay等；在功能模块下，按照mvp模式，又分为contract、model、presenter、fragment和activity；而在其他技术点包下面同样也按功能模块划分。</p>

<p>总之，我们划分包时：以功能模块为主，以技术点为辅。</p>

<h2 id="toc_29">Base、Util、UI类封装</h2>

<h3 id="toc_30">Base类</h3>

<ul>
<li>BaseApplication</li>
<li>BaseActivity</li>
<li>BaseFragment</li>
<li>BasePresenter 等</li>
</ul>

<h4 id="toc_31">BaseApplication：</h4>

<p>主要进行一些例如：<strong>三方配置</strong>、<strong>热更新加载</strong>、<strong>文件配置</strong>、<strong>数据库配置</strong>等准备工作；同时也许定义全局性变量：如<strong>Application的Context</strong>、<strong>网络状态</strong>、<strong>主线程Looper</strong>、<strong>主线程Handler</strong>等。</p>

<h4 id="toc_32">BaseActivity：</h4>

<p>封装为抽象类，将各任务抽取成方法，有子类实现：比如<strong>findViewById(initView)</strong>、<strong>initData</strong>、<strong>setListener</strong>等；</p>

<p>对友盟统计的封装：因为友盟统计或别的统计需要在所有Activity的各生命周期方法中调用api，所以应该将其封装到BaseActivity中。</p>

<p>项目为MVP结构，所以设置了View和Presenter的泛型，如：</p>

<p>其中定义了屏幕宽高度等设备信息，也定义了BasePresenter对象、并抽取抽象方法，由子类返回其对应presenter。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981225588056.png" alt="20171105150981225588056.png"/></p>

<h4 id="toc_33">BaseFragment：</h4>

<p>BaseFragment的封装如BaseActivity一样，添加View和Presenter的泛型和presenter对象，创建返回Presenter的抽象方法供子类事项；</p>

<p>创建createView(创建跟视图view)、initChildView(子view findViewById)、initData(加载数据)抽象方法</p>

<h4 id="toc_34">BasePresenter：</h4>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981228211507.png" alt="20171105150981228211507.png"/></p>

<p>BasePresenter封装如上：内置view的软引用，在Activity或Fragment的onResume中调用presenter的attachView方法，将view实例传给presenter；在Activity或Fragment的onDestroy或onStop方法中调用detachView方法解除与view的绑定；而getView方法则是presenter在model返回数据后调用来操作对应view的展示UI方法。</p>

<h3 id="toc_35">Utils类</h3>

<h4 id="toc_36">只列举一些常用的工具类：</h4>

<ul>
<li>SharedPreferenceUtils</li>
<li>ToastUtils</li>
<li>StorageUtils</li>
<li>FileUtils</li>
<li>NetUtils</li>
<li>deviceUtils</li>
<li>DateUtils</li>
<li>LogUtils</li>
<li>AppUtils 等</li>
</ul>

<h3 id="toc_37">UI类</h3>

<h4 id="toc_38">只列举一些常用的View类</h4>

<ul>
<li>下拉刷新、上拉加载</li>
<li>圆形ImageView</li>
<li>自定义Dialog</li>
<li>Banner</li>
<li>自定义ScrollView</li>
<li>自定义RecyclerView</li>
<li>项目相关的自定义View 等</li>
</ul>

<h2 id="toc_39">数据库</h2>

<p>关于数据库操作，之前一直是自己写：也就是SQLiteOpenHelper结合相关SQL操作工具类来实现数据库操作。</p>

<p>但随着业务逻辑的增加和复杂，需要进行大量的数据库操作时，编写大量的代码，既费时间、还会避免不了地出bug；</p>

<p>所以我们只介绍几款流行的数据库框架：</p>

<ul>
<li>GreenDao</li>
<li>OrmLite</li>
<li>LitePal</li>
<li>Realm</li>
</ul>

<h3 id="toc_40">GreenDao：</h3>

<p><strong>特点</strong>：</p>

<ol>
<li>存取速度快; </li>
<li>支持数据库加密; </li>
<li>轻量级; </li>
<li>激活实体;</li>
<li>支持缓存; </li>
<li>代码自动生成</li>
</ol>

<p><strong>地址</strong>：<a href="https://github.com/greenrobot/greenDAO">https://github.com/greenrobot/greenDAO</a></p>

<h3 id="toc_41">OrmLite：</h3>

<p><strong>优点</strong>： </p>

<ol>
<li>轻量级；</li>
<li>使用简单，易上手；</li>
<li>封装完善；</li>
<li>文档全面。</li>
</ol>

<p><strong>缺点</strong>：</p>

<ol>
<li>基于反射，效率较低（本人还没有觉得效率低)</li>
<li>缺少中文翻译文档</li>
</ol>

<p><strong>jar包地址</strong>：<a href="http://ormlite.com/releases/">http://ormlite.com/releases/</a></p>

<h3 id="toc_42">LitePal：</h3>

<p>LitePal 框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。</p>

<p>地址：<a href="https://github.com/LitePalFramework/LitePal">https://github.com/LitePalFramework/LitePal</a></p>

<h3 id="toc_43">Realm：</h3>

<ol>
<li><p>易用：Ream 不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。</p></li>
<li><p>快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。</p></li>
<li><p>跨平台：Realm 支持 iOS &amp; OS X (Objective‑C &amp; Swift) &amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。</p></li>
<li><p>高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性</p></li>
<li><p>可视化</p></li>
</ol>

<p><a href="https://github.com/realm/realm-java">git地址</a></p>

<p><a href="https://realm.io/docs/java/latest/#getting-started">官网</a></p>

<p>自己项目中使用了GreenDao，它代码自动生成、存取速度快、支持加密、一个轻量级别的库，用着方便，推荐大家使用GreenDao。</p>

<h2 id="toc_44">图片处理</h2>

<p>之前有自己封装过图片处理框架，核心是使用HttpUrlConnection实现加载，仿LruCache（近期最少使用排序）算法实现图片缓存。</p>

<p>但我们用的最多的还是ImageLoader、Glide、Picasso和Fresco四大主流框架，接下来主要比较一下四个框架的各自特点：</p>

<h3 id="toc_45">ImageLoader：</h3>

<p><strong>优点</strong>:</p>

<ul>
<li>多线程下载，线程管理。</li>
<li>多级缓存架构设计和策略，内存缓存，磁盘缓存，缓存有效性处理。</li>
<li>图片压缩，特效处理，动画处理。</li>
<li>复杂网络情况下下载图片策略，例如弱网络等。</li>
<li>内存管理，lru 算法、对象引用、GC回收等优化。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>时间久，官方不再维护，出现bug需要自己修复。</li>
</ul>

<h3 id="toc_46">Glide：</h3>

<p><strong>优点</strong>：</p>

<ul>
<li>更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我建议传参的时候传递Activity 和 Fragment给Glide，而不是Context。</li>
<li>Glide可以加载GIF动态图。</li>
<li>Glide缓存的是跟ImageView尺寸相同的。Glide的这种方式优点是加载显示非常快。</li>
<li>默认使用HttpUrlConnection下载图片，可以配置为OkHttp或者Volley下载，也可以自定义下载方式。</li>
<li>默认使用手机内置存储进行磁盘缓存，可以配置为外部存储，可以配置缓存大小，图片池大小。</li>
<li>默认使用两个线程池来分别执行读取缓存和下载任务，都可以自定义。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>Glide加载的图片质量要差于Picasso，这是因为Glide默认的Bitmap格式是RGB_565，比ARGB_8888格式的内存开销要小一半。</li>
</ul>

<h3 id="toc_47">Picasso：</h3>

<p><strong>特点</strong>：</p>

<ul>
<li>在adapter中需要取消已经不在视野范围的ImageView图片资源的加载，否则会导致图片错位，Picasso已经解决了这个问题。</li>
<li>使用复杂的图片压缩转换来尽可能的减少内存消耗</li>
<li>自带内存和硬盘二级缓存功能</li>
</ul>

<h3 id="toc_48">Fresco：</h3>

<p><strong>优点</strong>：</p>

<ul>
<li>最大的优势便在于5.0以下(最低2.3) bitmap的加载，在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem)，而且图片不显示时，占用的内存会自动被释放，这会使APP更加流畅，减少因图片内存占用而引发的OOM。5.0以后的系统默认存储在Ashmem区了</li>
<li>图片的渐进式呈现，图片先呈现大致的轮廓，然后随着图片下载的继续，逐渐成仙清晰的图片，这对于慢网络对说，用户体验更好。</li>
<li>支持加载Git动态图和Webp格式的图片。</li>
</ul>

<p><strong>缺点</strong>：</p>

<ul>
<li>框架体积比较大，3M左右，会增加APK的大小。</li>
</ul>

<p>总结：在项目开发中，要适当的选择图片框架，ImageLoader太老已过时，且官方不再维护，所以不再考虑使用ImageLoader；Picasso能做的，Glide都能做到，就是Glide的图片质量会稍差一些；而Fresco又体积偏大，但渐进式呈现，用户体验好。综上的话，一般项目建议使用Glide即可。</p>

<h2 id="toc_49">网络框架</h2>

<p>上一个项目中，网络框架自己封装：核心使用HttpUrlConnection实现，先封装请求参数相关类RequestVo，其中包含请求方式、url、参数、解析类、是否缓存、缓存时长等参数；缓存是将json字符串加密后与拼接过的url成对存储到File，并且设置有效时间，超过有效时间删除缓存并去网络请求，成功后重新保存。</p>

<p>但现在市面上最流行的是Retrofit+RxJava+Gson，接下来我们大概介绍一下：</p>

<h3 id="toc_50">添加依赖</h3>

<pre><code class="language-text">compile &#39;io.reactivex:rxjava:x.y.z&#39;
compile &#39;io.reactivex:rxandroid:1.0.1&#39;
compile &#39;com.squareup.retrofit2:retrofit:2.0.2&#39;
compile &#39;com.squareup.retrofit2:converter-gson:2.0.2&#39;
compile &#39;com.squareup.retrofit2:adapter-rxjava:2.0.2&#39;
</code></pre>

<p>要注意：以上添加了Retrofit、RxJava和Gson依赖，版本号必须一致</p>

<h3 id="toc_51">登录Service</h3>

<pre><code class="language-text">interface BaseService {
  @GET(&quot;user/login&quot; )
  Observable&lt;User&gt; login(
          @Query(&quot;username&quot;) String username,
          @Query(&quot;password&quot;) String password
  );
}
</code></pre>

<p>login方法的返回值是Observable类型，就是RxJava中的被观察者。</p>

<h3 id="toc_52">网络请求</h3>

<pre><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
    .addConverterFactory(GsonConverterFactory.create()           
    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())//新的配置
    .baseUrl(BASE_URL)
    .build();
BaseService service = retrofit.create(BaseService.class);

service.login(phone, password)               //获取Observable对象
    .subscribeOn(Schedulers.newThread())//请求在新的线程中执行
    .observeOn(Schedulers.io())         //请求完成后在io线程中执行
    .doOnNext(new Action1&lt;UserInfo&gt;() {
        @Override
        public void call(User user) {
            saveUserInfo(user);//保存用户信息到本地
        }
    })
    .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行
    .subscribe(new Subscriber&lt;User&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {
            //请求失败
        }

        @Override
        public void onNext(User user) {
            //请求成功
        }
});
</code></pre>

<p>RxJava + Retrofit 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。</p>

<p>可以看到，调用了service的login方法后得到Observable对象，在新的线程中执行网络请求，请求成功后切换到io线程执行保存用户信息的动作，最后再切换到主线程执行请求失败onError()、请求成功onNext()。整体的逻辑十分清晰都在一条链中，就算还有别的要求还可以往里面添加，丝毫不影响代码的简洁。</p>

<pre><code class="language-text">注意：Retrofit在创建的时候添了一下代码
addCallAdapterFactory(RxJavaCallAdapterFactory.create())
</code></pre>

<p>想了解更多关于RxJava，浏览<a href="http://gank.io/post/560e15be2dca930e00da1083#toc_1">http://gank.io/post/560e15be2dca930e00da1083#toc_1</a></p>

<h2 id="toc_53">其他三方</h2>

<p>在自己的开发过程中，还用到了如EventBus、Zxing、Zbar、Volley、Gson、LeakCanary等三方框架；</p>

<p>也用到了如友盟统计、微信、支付宝支付、三方登录、极光推送、tinker热更新等三方sdk；</p>

<p>就不再一一列举，附上一张图，大家有时间多去学习、多去了解。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150981301966614.png" alt="20171105150981301966614.png"/></p>

<h2 id="toc_54">混淆、加固、上线</h2>

<h3 id="toc_55">混淆</h3>

<p>大家可以参考我的<a href="http://blog.csdn.net/jiashuai94/article/details/77991077">另一篇文章</a></p>

<p>混淆是上线前挺重要的一个环节。Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。</p>

<h4 id="toc_56">坚持以下几项原则：</h4>

<ul>
<li>使用三方依赖，在混淆文件中添加官方提供的混淆代码，官方没有就google；</li>
<li>实体类不混淆，因为实体类涉及到与服务端的交互，各种gson的交互如此等等，是要保留的；</li>
<li>与js互调的类不混淆；</li>
<li>与反射有关的类不混淆 等。</li>
</ul>

<h4 id="toc_57">具体语法：</h4>

<pre><code class="language-text">-optimizationpasses 5 // 代码混淆的压缩比例，值在0-7之间
-dontusemixedcaseclassnames // 混淆后类名都为小写
-dontskipnonpubliclibraryclasses // 指定不去忽略非公共的库的类
-dontskipnonpubliclibraryclassmembers // 指定不去忽略非公共的库的类的成员
-dontpreverify // 不做预校验的操作

-verbose
-printmapping proguardMapping.txt // 生成原类名和混淆后的类名的映射文件

-optimizations !code/simplification/cast,!field/*,!class/merging/* // 指定混淆时采用的算法
-keepattributes *Annotation*,InnerClasses // 不混淆Annotation
-keepattributes Signature // 不混淆泛型
-keepattributes SourceFile,LineNumberTable // 抛出异常时保留代码行号
-keep class XXXX // 保留类名不变，也就是类名不混淆，而类中的成员名不保证。当然也可以是继承XXX类的所有类名不混淆，具体代码不贴了，重在理解。
-keepclasseswithmembers class XXXX // 保留类名和成员名。当然也可以是类中特定方法，代码不贴了，理由同上。
</code></pre>

<p><strong>加固</strong>：</p>

<p>加固一般都使用三方加固：如果apk上百度应用市场，则使用百度加固，其他情况建议使用360加固，当然，加固前一定是混淆过的、并且签过名的apk。</p>

<p>360加固还提供了一些其他服务，可根据项目情况操作（是需要花钱的..）</p>

<p><strong>上线</strong>：</p>

<p>也就是我们所说的发版，当你的apk测试通过，混淆过、签名过、也加固了，可以发版了。</p>

<p>每个公司上线的市场要求不同，一般主要有应用宝、360、豌豆荚、百度市场、小米市场、华为市场、魅族市场等，当然还有官网了。</p>

<p>发版时需要：apk当然要有、logo（第一次上线）、应用简介（第一次上线）、版本号、更新功能、介绍图、官网地址（第一次上线）等。</p>

<p>ok，到这里，我们的一个阶段算是完成了，接下来还会有更多的业务和bug等着大家，哈哈！希望这篇文章能对大家有一点点帮助。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502775177.html">
                
                  <h1>Android-酷炫的Activity切换动画</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>毫无疑问，动画效果能提高用户体验。我们平时使用最多的动画基本上是属性动画和补间动画了，属性动画很强，基本能定制我们想要的动画，但是你是否知道，API 21（5.0）后系统内置了Activity之间的切换动画，而且非常酷炫，今天我跟大家一起分享一下。我们知道，在两个Activity之间切换，我们一般会写出类似下面的代码：</p>

<pre><code class="language-java">Intent intent=new Intent(this,SecondActivity.class);
startActivity(intent);
overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);
</code></pre>

<p>在API 21以后，我们可以使用内置的Activity切换动画啦。但是这样也就意味着只能兼容5.0之后的系统，我们先看一个效果图来压压惊：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799839139489.gif" alt="20171015150799839139489.gif"/></p>

<p>先看看第一个Activity，退出时用的是Explode效果，第二个Activity进入时用的是Slide效果。这些效果无需我们自己去实现，都是内置的效果，我们所编写的代码几乎为零，接下来我们一一看看内置了哪些效果。</p>

<h2 id="toc_1">使用内置Activity之间切换动画代码步骤</h2>

<p>Activity之间的切换期间，对于某个Activity来说，无非就是“进入”和“退出”两种情景下的动画。而“进入”分为“第一次进入Activity”和“返回当前Activity”这两种情况。另外系统还提供了一种动画，即共享元素，这是让两个Activity中的View有个过渡切换的效果。执行动画的状态如下所示：</p>

<blockquote>
<p><strong>enter</strong>：用于决定第一次打开当前Activity时的动画<br/><br/>
<strong>exit</strong> : 用于决定退出当前Activity时的动画<br/><br/>
<strong>reenter</strong>: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画<br/><br/>
<strong>shared elements</strong>:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果  </p>
</blockquote>

<p>那么应该怎么去使用Activity切换动画呢？我们看看使用步骤：</p>

<ul>
<li>首先在setContentView()之前执行，用于告诉Window页面切换需要使用动画<br/>
<code>getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</code></li>
<li>接下来就是加载切换动画<br/>
其中R.transition.explode就是要执行的动画，是在res/transition目录下的xml文件，我们使用的是系统内置的Explode效果动画，关于怎么去写explode.xml，我们接下来小节去讲解。<br/>
<code>Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode);</code></li>
<li>告诉Window，当前的Activity在什么情况下使用上面的动画<br/>
上面我们创建好了切换动画，接下来就是要告诉当前窗口，在什么情况下去使用动画效果啦，你可以根据你的需求在不同的切换情景中选择不同的效果:<br/></li>
</ul>

<pre><code class="language-java">//退出时使用
getWindow().setExitTransition(explode);
//第一次进入时使用
getWindow().setEnterTransition(explode);
//再次进入时使用
getWindow().setReenterTransition(explode);
</code></pre>

<p>当然了，你也可以不使用代码的方式，直接在你使用的主题<style>标签里添加类似如下代码：</p>

<pre><code class="language-markup">&lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt;
&lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@transition/explode&lt;/item&gt;
&lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/explode&lt;/item&gt;
</code></pre>

<ul>
<li>调用startActivity<br/>
跟我们之前使用的<code>startActivity(Intent intent);</code>不同，这里多了一个参数<code>Bundle</code>，我们是先通过<code>makeSceneTransitionAnimation</code>函数创建一个<code>ActivityOptions</code>对象，再将其转为<code>Bundle</code>对象:<br/>
<code>startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle());</code><br/>
整体使用步骤就是以上这些，是不是很简单？接下来我们去学习如何使用内置动画~</li>
</ul>

<h2 id="toc_2">Explode效果</h2>

<p>Explode即爆炸效果，使用Explode效果很简单，在<code>res/transition</code>目录下新建一个xml文件(如<code>explode.xml</code>)，内容如下：</p>

<pre><code class="language-markup">&lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot; /&gt;
</code></pre>

<p>其中<code>duration</code>表示Explode动画持续时间，由于是Activity之间的切换，最好不要把动画时间设置过大，一般取200~500毫秒比较合适。<br/>
我们看看效果吧~</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799868975358.gif" alt="20171015150799868975358.gif"/></p>

<h2 id="toc_3">Slide效果</h2>

<p>即滑动效果，使用Slide跟Explode类似，都是在res/transition目录下新建一个xml文件(如<code>slide.xml</code>)，内容如下：</p>

<pre><code class="language-markup">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;
    android:slideEdge=&quot;end&quot;/&gt;
</code></pre>

<p>其中，slideEdge表示起始滑动的侧边位置，end表示右侧，start表示左侧，top表示顶部，bottom表示底侧，各种效果你可以亲自试试~，一起看看滑动效果吧</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799873587032.gif" alt="20171015150799873587032.gif"/></p>

<p>GIF 效果看的比较死板，可以下载我的源码实际运行一下~</p>

<p>如果你不希望顶部的状态栏以及底部的导航栏一起执行动画，可以在xml中指定：</p>

<pre><code class="language-markup">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;
    android:slideEdge=&quot;end&quot;&gt;
    &lt;targets&gt;
        &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot; /&gt;
        &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot; /&gt;
    &lt;/targets&gt;
&lt;/slide&gt;
</code></pre>

<h2 id="toc_4">Fade效果</h2>

<p>Fade效果即淡化效果，使用淡化效果依然是很简单，在<code>res/transition</code>目录下新建一个xml文件(如<code>fade.xml</code>)，内容如下：</p>

<pre><code class="language-markup">&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot; /&gt;
</code></pre>

<p>Fade效果就是将View逐步淡化，这里不再贴效果啦，想看效果的可以下载我的源码运行看看~</p>

<h2 id="toc_5">Shared Element效果</h2>

<p>即共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果，我们先看看动态图感受一下：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799880319943.gif" alt="20171015150799880319943.gif"/></p>

<p>从动态图中看到，第一个Activity的小绿色方块到第二个Activity大绿色方块有个过渡效果~</p>

<p>接下来我们看看如何实现这个效果：</p>

<p><strong>1.将两个Activity中需要过渡的View加上<code>android:transitionName</code>属性</strong></p>

<p>两个View的<code>android:transitionName</code>属性取值要一致，比如：<br/><br/>
第一个Activity布局：</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;View
        android:id=&quot;@+id/firstSharedView&quot;
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:background=&quot;#00cc00&quot;
        android:onClick=&quot;onClick&quot;
        android:transitionName=&quot;sharedView&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>第二个Activity布局：</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;View
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;300dp&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:background=&quot;#00cc00&quot;
        android:onClick=&quot;onClick&quot;
        android:transitionName=&quot;sharedView&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>两个绿色的View都添加<code>android:transitionName</code>属性，并且取名一致。</p>

<p><strong>2.调用startActivity</strong><br/><br/>
<code>ActivityOptions</code>的<code>makeSceneTransitionAnimation</code>函数第一个参数<code>Activity</code>没啥解释的，第二个参数就是第一个<code>Activity</code>中的<code>View</code>对象，第三个参数就是两个Activity的View的 <code>android:transitionName</code>属性的值。</p>

<p><code>startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, firstSharedView,&quot;sharedView&quot;).toBundle());</code></p>

<p>现在就可以实现这种<code>Shared Element</code>效果啦，但是可能你会想实现同时让两个View有这样的效果，可是<code>makeSceneTransitionAnimation</code>函数却只能让我们设置一个<code>View</code>和一个<code>transitionName</code>属性。如何添加多个呢？接下来我们一起学习让多个View同时有切换效果。</p>

<p>除了需要将两个<code>Activity</code>中需要过渡的<code>View</code>对应取相同的名称外，还需将需要过渡的<code>View</code>和<code>transitionName</code>取值对应的String这两个对象封装到一个Pair对象中：</p>

<pre><code class="language-java">Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));
Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView));
</code></pre>

<p>然后调用<code>ActivityOptionsCompat</code>类的<code>makeSceneTransitionAnimation</code>的另一个重载函数<code>makeSceneTransitionAnimation(Activity activity,Pair&lt;View, String&gt;... sharedElements)</code>，第一个参数不解释，后面参数为不定长度的形参，即你可以传递任意多个Pair对象。</p>

<pre><code class="language-java"> ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, first, second);
</code></pre>

<p>最后调用startActivity</p>

<pre><code class="language-java"> ActivityCompat.startActivity(this,intent, transitionActivityOptions.toBundle());
</code></pre>

<p>说了这么多步骤，我们来看看效果吧~</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799903533027.gif" alt="20171015150799903533027.gif"/></p>

<h3 id="toc_6">1 自定义 Shared Element切换动画</h3>

<p>如果你对内置的 Shared Element还不够满意，你还可以定制View的过渡切换效果。步骤如下：</p>

<h4 id="toc_7">创建一个View的过渡移动的轨迹路径PathMotion类</h4>

<p>我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看<a href="https://developer.android.com/reference/android/transition/ArcMotion.html">【ArcMotion官方文档】</a></p>

<pre><code class="language-java">ArcMotion arcMotion = new ArcMotion();
arcMotion.setMinimumHorizontalAngle(50f);
arcMotion.setMinimumVerticalAngle(50f);
</code></pre>

<h4 id="toc_8">定义ChangeBounds类</h4>

<p>我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数：</p>

<blockquote>
<p>1.<code>ViewGroup  sceneRoot</code>：屏幕根View，即DecorView，第二个Activity的DecorView。<br/>
2.<code>TransitionValues  startValues</code>：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数<code>captureStartValues</code>里放置，因此你可以重写<code>captureStartValues</code>函数，并把你自定义的属性动画中的属性放进去。<br/>
3.<code>TransitionValues endValues</code> ：与<code>startValues</code>类似，表示属性动画结束时的属性值。可以通过重写<code>captureEndValues</code>函数，并把你自定义的属性动画里面的最终属性值放进去。</p>
</blockquote>

<p>我们先看一个最简单的示例：</p>

<pre><code class="language-java">package com.hc.util;

import android.animation.Animator;
import android.transition.ChangeBounds;
import android.transition.TransitionValues;
import android.view.ViewGroup;
import android.view.animation.AnimationUtils;


public class CustomChangeBounds extends ChangeBounds {

 @Override
  public Animator createAnimator(final ViewGroup sceneRoot,
                                 TransitionValues startValues,
                                 final TransitionValues endValues) {
      Animator changeBounds = super.createAnimator(sceneRoot, startValues, endValues);
      if (startValues == null || endValues == null || changeBounds == null) 
          return null;

      changeBounds.setDuration(300);
      changeBounds.setInterpolator(AnimationUtils.loadInterpolator(sceneRoot.getContext(),
              android.R.interpolator.fast_out_slow_in));
      return changeBounds;
  }
}
</code></pre>

<p>看看效果吧~</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799918618986.gif" alt="20171015150799918618986.gif"/></p>

<p>最后，再献上<a href="http://download.csdn.net/detail/huachao1001/9550440">源码</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502775529.html">
                
                  <h1>Android-自定义锁屏页</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、为什么需要自定义锁屏页</h2>

<p>　　锁屏作为一种黑白屏时代就存在的手机功能，至今仍发挥着巨大作用，特别是触屏时代的到来，锁屏的功用被发挥到了极致。多少人曾经在无聊的时候每隔几分钟划开锁屏再关上，孜孜不倦，其酸爽程度不亚于捏气泡膜。确实，一款漂亮的锁屏能为手机增色不少，但锁屏存在的核心目的主要是三个：保护自己手机的隐私，防止误操作，在不关闭系统软件的情况下节省电量。<br/>
　　当下，各个款式的手机自带的系统锁屏完全能够满足这些需求，而且美观程度非凡，那么开发者为什么仍然需要构建自定义锁屏呢？让我们试想一个场景，一位正在使用音乐播放器听歌的美女用户，在没有播放器自定义锁屏的情况下，切换一首歌需要几步（参考自同类文章）：</p>

<ol>
<li>点亮手机屏幕</li>
<li>解开系统锁屏</li>
<li>打开音乐播放器</li>
<li>切歌再熄灭屏幕</li>
</ol>

<p>　　这时的她估计已经被广场舞的歌曲骚扰了有10秒，续了10次命，这是我们程序员不愿意看到的，所以有必要依靠我们灵活的双手构建出自定义的音乐锁屏页，将切歌过程被压缩为两步：点亮屏幕和切歌，顺便可以看看歌词。如果再加个开启和关闭自定义锁屏的开关，就能完美解决用户的痛点。</p>

<h2 id="toc_1">二、自定义锁屏页的基本原理</h2>

<p>　　然而，要实现一个自定义锁屏是一件繁琐的事情，因为系统有100种方法让这个非本地的锁屏待不下去。但是，人类的智慧是无限的，程序员需要逆流而上。<br/><br/>
　　Android系统实现自定义锁屏页的思路很简单，即在App启动时开启一个service，在Service中时刻监听系统SCREEN_OFF的广播，当屏幕熄灭时，Service监听到广播，开启一个锁屏页Activity在屏幕最上层显示，该Activity创建的同时会去掉系统锁屏（当然如果有密码是禁不掉的）。示意图如下：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795013363128.png" alt="20171014150795013363128.png"/></p>

<p>道理很简单，我们这里需要讨论的是细节。</p>

<h3 id="toc_2">广播注册</h3>

<p>　　Service是普通的Service，在应用启动时直接startService，与应用同一个进程即可。此外，SCREEN_OFF广播监听必须是动态注册的，如果在AndroidManifest.xml中静态注册将无法接收到SCREEN_OFF广播，这点在Android官方文档中有明确说明，即需要通过如下代码注册：</p>

<pre><code class="language-java">IntentFilter mSereenOffFilter = new IntentFilter();
mScreenOffFilter.addAction(Intent.ACTION_SCREEN_OFF);
registerReceiver(mScreenOffReveiver,mScreenOffFilter);
</code></pre>

<p>　　对应的BroadcastReceiver定义如下：</p>

<pre><code class="language-java">private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver(){
    @SuppressWarnings(&quot;deprecation&quot;)
    @Override
    public void onReceive(Context context,Intent intent){
        if(intent.getAction().equals(NOTIFY_SCREEN_OFF)){
            Intent mLockIntent = new Intent(context, LockScreenActivity.class);
            mLockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
            startActivity(mLockIntent);
        }
    }
}
</code></pre>

<p>　　关于启动Activity时Intent的Flag问题，如果不添加FLAG_ACTIVITY_NEW_TASK的标志位，会出现“Calling startActivity() from outside of an Activity”的运行时异常，毕竟我们是从Service启动的Activity。Activity要存在于activity的栈中，而Service在启动activity时必然不存在一个activity的栈，所以要新起一个栈，并装入启动的activity。使用该标志位时，也需要在AndroidManifest中声明taskAffinity，即新task的名称，否则锁屏Activity实质上还是在建立在原来App的task栈中。<br/>
　　标志位FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS，是为了避免在最近使用程序列表出现Service所启动的Activity,但这个标志位不是必须的，其使用依情况而定。</p>

<h3 id="toc_3">Activity设置</h3>

<p>　　锁屏的activity内部也要做相应的配置，让activity在锁屏时也能够显示，同时去掉系统锁屏。当然如果设置了系统锁屏密码，系统锁屏是没有办法去掉的，这里考虑没有设置密码的情况。<br/><br/>
　　典型的去掉系统锁屏页的方法是使用KeyguardManager，具体代码如下：<br/>
　　</p>

<pre><code class="language-java">KeyguardManager mKeyguardManager = (KeyguardManager)getSystemService(Context.KEYGUARD_SERVICE);
KeyguardManager.KeyguardLock mKeyguardLock = mKeyguardManager.newKeyguardLock(&quot;CustomLockScreen&quot;);
mKeyguardLock.disableKeyguard();
</code></pre>

<p>　　其中，KeyguardManager是锁屏管理类，我们通过getSystemService()的方式获取实例对象mKeyguardManager，调用该对象的newKeyguardLock()方法获取KeyguardManager的内部类KeyguardLock的实例mKeyguardLock，该方法传入的字符串参数用于标识是谁隐藏了系统锁屏，最后调用mKeyguardLock的disableKeyguard()方法可以取消系统锁屏。<br/><br/>
　　上述方法已经不推荐使用，可以使用更好的方法来替代。我们在自定义锁屏Activity的onCreate()方法里设定以下标志位就能完全实现相同的功能：</p>

<pre><code class="language-java"> getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
 getWindow().addFlags(WindowManager.LayoutParams.FLAG_OW_WHEN_LOCKED);
</code></pre>

<p>　　FLAG_DISMISS_KEYGUARD用于去掉系统锁屏页，FLAG_SHOW_WHEN_LOCKED使Activity在锁屏时仍然能够显示。当然，不要忘记在Manifest中加入适当的权限：</p>

<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot;/&gt;
</code></pre>

<h3 id="toc_4">屏蔽按键</h3>

<p>　　当自定义锁屏页最终出现在手机上时，我们总希望它像系统锁屏页那样屹立不倒，所有的按键都不能触动它，只有通过划瓶或者指纹才能解锁，因此有必要对按键进行一定程度上的屏蔽。针对只有虚拟按键的手机，我们可以通过隐藏虚拟按键的方式部分解决这个问题，具体方法在后文会介绍。但是当用户在锁屏页底部滑动，隐藏后的虚拟按键还是会滑出，而且如果用户是物理按键的话就必须进行屏蔽了。<br/><br/>
　　Back键和Menu键可以通过重写onKeyDown()方法进行屏蔽：<br/>
　　</p>

<pre><code class="language-java">public boolean onKeyDown(int keyCode, KeyEvent event){
    int key = event.getKeyCode();
    switch(key){
        case KeyEvent.KEYCODE_BACK:{
            return true;
        }
        case KeyEvent.KEYCODE_MENU:{
            return true;
        }
    }
    return super.onKeyDown(keyCode,event);
}
</code></pre>

<p>　　Home键与Recent键（调出最近打开应用的按键）的点击事件是在framework层进行处理的，因此onKeyDown与dispatchKeyEvent都捕获不到点击事件。关于这两个按键的屏蔽方法，网上相关的资料有很多，有的用到了反射，有的通过改变Window的标志位和Type等，总的来说这些方法只对部分android版本有效，有的则完全无法编译通过。其实，这么做的目的无非是为了实现一个纯粹的锁屏页，但是这种做法有些画蛇添足，容易造成锁屏页的异常崩溃，我们要满足的是用户在锁屏页的快捷操作，Home键和Recent键无关痛痒，完全可以不管,少一些套路，多一点真诚嘛。</p>

<h3 id="toc_5">划屏解锁</h3>

<p>　　做完以上几步，当屏幕熄灭后，再打开屏幕就能够看到我们的自定义锁屏页了，但是这时候，就算划破手指也无法解锁。所以，接下来要实现划屏解锁。<br/><br/>
　　划瓶解锁的基本思路很简单，当手指在屏幕上滑动时，拦截并处理滑动事件，使锁屏页面随着手指运动，当运动到达一定的阀值时，用户手指松开手指，锁屏页自动滑动到屏幕边界消失，如果没有达到运动阀值，就会自动滑动到起始位置，重新覆盖屏幕。<br/><br/>
　　为了将划屏逻辑与页面内容隔离开来，我们在锁屏页面布局中添加一个自定义的UnderView，这个UnderView填充整个屏幕，位于锁屏内容View（将其引用称之为mMoveView,并传入到UnderView中）的下方，所有划屏相关的事件都在这里拦截并处理。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795122322931.png" alt="20171014150795122322931.png"/></p>

<p>mMoveView是锁屏页的显示内容，除了处理一些简单的点击事件，其他非点击事件序列都由底层的UnderView进行处理。只需要重写UnderView的onTouchEvent方法就能够实现：</p>

<pre><code class="language-java">@Override
public boolean onTouchEvent(MotionEvent event){
    final int action = event.getAction();
    final float nx = event.getX();
    switch(action){
        case MotionEvent.ACTION_DOWN:
            mStartX = nx;
            onAnimationEnd();
        case MotionEvent.ACTION_MOVE:
            handleMoveView(nx);
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            doTriggerEvent(nx);
            break;
    }
    return true;
}
</code></pre>

<p>　　其中，mStartX记录滑动操作起始的x坐标，handleMoveView方法控制mMoveView随手指的移动，doTriggerEvent处理手指离开后mMoveView的移动动画。两个方法的定义如下：<br/>
　　</p>

<pre><code class="language-java">private void handleMoveView(float x){
    float movex = x - mStartX;
    if(movex &lt; 0)
        movex = 0;
    mMoveView.setTranslationX(movex);
    
    float mWidthFloat = (float) mWidth; // 屏幕显示宽度
    if(getBackground() != null){
        getBackground().setAlpha((int) ((mWidthFloat - mMoveView.getTranslationX()) / mWidthFloat * 200));  //初始透明度的值为200
    }
}
</code></pre>

<p>　　在handleMoveView()中，首先计算当前触点x坐标与初始x坐标mStartX的差值movex，然后调用mMoveView的setTranslationX方法移动。值得注意的是，目前setTranslationX方法只能在Android 3.0以上版本使用，如果采用动画兼容库nineoldandroid中ViewHelper类提供的setTranslation方法，则没有这个问题。scrollTo与scrollBy也可以实现移动，但是只是移动View的内容，并不能移动View本身。另外就是通过修改布局参数LayoutParams实现移动，虽然没有版本的限制，用起来相对复杂。这里我们采用setTranslationX，为了简洁，也是为了能够与后续使用的属性动画相统一。<br/><br/>
　　此外，我们可以通过getBackground()获取UnderView的背景，并根据已划开屏幕占整个屏幕的百分比调用setAlpha方法改变背景的透明度，做出抽屉拉开时的光影变化效果。</p>

<pre><code class="language-java">private void doTriggerEvent(float x){
    float movex = x - mStartX;
    if(movex &gt; (mWidth * 0.4)){
        moveMoveView(mWidth - mMoveView.getLeft(),true);//自动移动到屏幕右边界之外，并finish掉
    } else {
        moveMoveView(-mMoveView.getLeft(),false);//自动移动回初始位置，重新覆盖
    }
}

private void moveMoveView(float to,boolean exit){
    ObjectAnimator animator = ObjectAnimator.ofFloat(mMoveView, &quot;translationX&quot;,to);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
        @Override
        public void onAnimationUpdate(new ValueAnimator animation){
            if(getBackground() != null){
                getBackground().setAlpha((int)(((float)mWidth - mMoveView.getTranslationX()) / (float) mWidth * 200));
            }
        }
    });//随意动动画背景更新背景透明度
    animator.setDuration(250).start();
    if(exit){
        animator.addListener(new AnimatorListenerAdapter(){
            @Override
            public void onAnimationEnd(Animator animation){
                mainHandler.obtainMessage(LockScreenAcitvity.MSG_LAUNCH_HOME).sendToTarget();
                super.onAnimationEnd(animation);
            }
        });
    }//监听动画结束，利用Handler通知Activity退出
}
</code></pre>

<p>　　当手指离开屏幕，doTraiggerEvent方法会对滑动的距离与阀值进行一个比较，此处的阀值为0.4*屏幕宽度，如果低于阀值，则通过ObjectAnimator在0.25s将mMoveView移动到初始位置，同时在ObjectAnimator的AnimatorUpdateListener的onAnimationUpdate方法中更新背景透明度；如果低于阀值，以同样的方式将mMoveView移出屏幕右边界，然后将Activity干掉，具体做法是为animator增加一个AnimatorListenerAdapter的监听器，在该监听器的onAnimationEnd方法中使用在Activity中定义的mHandler发送finish消息，完成解锁，效果如下图：</p>

<h2 id="toc_6">三、透明栏与沉浸模式</h2>

<p>　　沉浸模式与透明栏是两个不同的概念，由于某些原因，国内一些开发或产品会把这两个概念混淆。不过没关系，在接下来的内容我们会对这两个概念进行详细的解释和区分，并应用这两种不同的模式进一步完善已经初具模样的锁屏页。</p>

<h3 id="toc_7">沉浸模式</h3>

<p>　　什么是沉浸模式？从4.4开始，Android 为 “setSystemUiVisibility()”方法提供了新的标记 “SYSTEM_UI_FLAG_IMMERSIVE”以及”SYSTEM_UI_FLAG_IMMERSIVE_STIKY”，就是我们所谈的沉浸模式，全称为 “Immersive Full-Screen Mode”，它可以使你的app隐藏状态栏和导航栏，实现真正意义上的全屏体验。<br/><br/>
　　之前 Android 也是有全屏模式的，主要通过”setSystemUiVisibility()”添加两个Flag，即”SYSTEM_UI_FLAG_FULLSCREEN”，”SYSTEM_UI_FLAG_HIDE_NAVIGATION”（仅适用于使用导航栏的设备，即虚拟按键）。<br/>
　　这两个标记都存在一些问题，例如使用第一个标记的时候，除非 App 提供暂时退出全屏模式的功能（例如部分电子书软件中点击一次屏幕中央位置），用户是一直都没法看见状态栏的。这样，如果用户想去看看通知中心有什么通知，那就必须点击一次屏幕，显示状态栏，然后才能调出通知中心。<br/><br/>
　　而第二个标记的问题在于，Google 认为导航栏对于用户来说是十分重要的，所以只会短暂隐藏导航栏。一旦用户做其他操作，例如点击一次屏幕，导航栏就会马上被重新调出。这样的设定对于看图软件，视频软件等等没什么大问题，但是对于游戏之类用户需要经常点击屏幕的 App，那就几乎是悲剧了——这也是为什么你在 Android 4.4 之前找不到什么全屏模式会自动隐藏导航栏的应用。<br/><br/>
　　Android 4.4 之后加入的Immersive Full-Screen Mode 允许用户在应用全屏的情况下，通过在原有的状态栏/导航栏区域内做向内滑动的手势来实现短暂调出状态栏和导航栏的操作，且不会影响应用的正常全屏，短暂调出的状态栏和导航栏会呈半透明状态，并且在一段时间内或者用户与应用内元素进行互动的情况下自动隐藏，沉浸模式的四种状态如下图。（<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0616/3047.html">参考</a>）</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795293493925.png" alt="20171014150795293493925.png"/></p>

<p>　　状态1代表没有进入沉浸模式时页面的状态，仍然可以看到Status Bar和Navigation Bar；状态2代表用户第一次进入沉浸模式时，系统的提示弹窗，告诉用户如何在沉浸模式下呼出Status Bar和Navigation Bar；状态3代表沉浸模式，可以看到Status Bar和Navigation Bar都被隐藏；状态4代表用户在Sticky沉浸模式下呼出Status Bar和Navigation Bar，可以看到两个Bar重新出现，但是过一段时间能够自动隐藏。<br/><br/>
　　一般来说，沉浸模式的标记与其他Full Screen相关的Flag搭配起来才能达到我们想要的效果，即通过沉浸模式标记规定状态栏status bar和导航栏navigation bar显示和隐藏的运转逻辑，通过其他标签设定状态栏和导航栏显示或隐藏，以及显示或隐藏的样子。这些常见的Flag及相应功能如下表：<br/><br/>
　　<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795296598206.png" alt="20171014150795296598206.png"/></p>

<p>　　如此多的标签，看起来非常乱，但用起来却非常简单和明确，感兴趣的开发者可以自由搭配来测试一下。下面，我们通过一个例子，将这些标签应用于锁屏页，实现对Navigation Bar的自动隐藏，同时保留Status Bar。代码非常简单，在Activity的onCreate()方法中使用：<br/>
　　</p>

<pre><code class="language-java">getWindow().getDecorView().getSystemUiVisibility(
    View.SYSTEM_UI_FLAG_LAYOUT_STABLE
    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
)
</code></pre>

<p>　　总共用到了5个Flag：SYSTEM_UI_FLAG_LAYOUT_STABLE保持整个View稳定，使View不会因为SystemUI的变化而做layout；SYSTEM_UI_FLAG_IMMERSIVE_STIKY，能够在隐藏的bar被呼出时（比如从屏幕下边缘开始向上做滑动手势），使bar在无相关操作的情况下自动再次隐藏；对于SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION，开发者容易被其中的HIDE_NAVIGATION所迷惑，其实这个Flag没有隐藏导航栏的功能，只是控制导航栏浮在屏幕上层，不占据屏幕布局空间；SYSTEM_UI_FLAG_HIDE_NAVIGATION，才是能够隐藏导航栏的Flag；SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN，由上面可知，也不能隐藏状态栏，只是使状态栏浮在屏幕上层。<br/><br/>
　　需要注意的是，这段代码除了需要加在Activity的OnCreate()方法中，也要加在重写的onWindowFocusChanged()方法中，在窗口获取焦点时再将Flag设置一遍，否则可能导致无法达到预想的效果。<br/><br/>
　　</p>

<pre><code class="language-java">@Override
public void onWindowFocusChanged(boolean hasFocus){
    super.onWindowFocusChanged(hasFocus);
    if(hasFocus){
        getWindow().getDecorView().setSystemUiVisiblity(
            View.SYSTEM_UI_FLAG_LAYOUT_STABLE
            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
        )
    }
}
</code></pre>

<p>　　此外，有个部份要稍微留意一下，如果不希望界面的内容被上拉到状态栏(Status bar)的话，要记得在界面(Layout)XML文件中，在最外层Layout中将fitsSystemWindows属性设置为true。如下：</p>

<pre><code class="language-java">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>　　<br/>
手指在屏幕底端上划，Navigation Bar会弹出，悬浮于锁屏页底部，随后自动消失。Status Bar也按照我们预期的那样，悬浮在上方，没有隐藏。</p>

<h3 id="toc_8">透明栏</h3>

<p>　　什么是透明栏？Google 在 Android 4.4 的 API 描述页面里提到了“Translucent system UI styling”，即半透明化的系统UI风格。这个“半透明化”包括了状态栏和通知栏，当开发者让应用支持这个新特性的时候，状态栏和导航栏可以单独/同时变为渐变的半透明样式，如下图：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079538614391.png" alt="2017101415079538614391.png"/></p>

<p>　　在 Android 5.0 之后引入了 Material Design，状态栏和导航栏也玩出了更多花样。现在除了原有的“半透明”模式以外，还有“全透明”以及“变色”模式，一种会完全隐藏背景，另一种可以取色作为背景颜色，多种样式的透明栏如下图（上图为透明状态栏，下图为透明导航栏）：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795389627420.png" alt="20171014150795389627420.png"/></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079539225975.png" alt="2017101415079539225975.png"/></p>

<p>　　所以，<strong>透明栏只是能够改变状态栏和导航栏的颜色，并不像沉浸模式那样隐藏状态栏和导航栏，两者是有本质区别的。</strong><br/><br/>
　　对于Android 4.4以上5.0以下的版本，设置透明状态栏的方式如下：</p>

<pre><code class="language-java">if(Build.VERSION&gt;SDK_INT &gt;= Build.VERSION_CODES.KITKAT){
    Window window = getWindow();
    window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
}
</code></pre>

<p>　　对于Android 5.0及以上版本，设置透明状态栏的方法如下：</p>

<pre><code class="language-java">if(Build.VERSION.SDK_INT &gt;= Build.VERSION.LOLLIPOP){
    Window window = getWindow();
    window.clearFlags(WindowManager.LayoutParams.FLAG_TrANSLUCENT_STATUS);
    window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
    window.addFlags(WindowManager.LayoutParams.Flag_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    window.setStatusBarColor(0);
}
</code></pre>

<p>　　除了要清理掉4.4的FLAG_TRANSLUCENT_STATUS外，还要配合SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE，添加标志位FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，并调用setStatusBarColor设置状态栏的颜色为透明。  </p>

<h2 id="toc_9">四、指纹解锁</h2>

<p>　　到这里，我们的锁屏页已经基本完工，完全能够非常优雅地解决用户的痛点，但是跟当下App自定义锁屏页的区别并不明显。接下来对新型号手机普遍具备的指纹解锁功能的考虑，则能够为锁屏页增色不少。</p>

<h3 id="toc_10">指纹识别无法解锁自定义锁屏页的问题</h3>

<p>　　持有指纹解锁手机的用户在使用App自定义锁屏页时会出现一种困惑，当你点亮屏幕，能够看到自定义锁屏页，在使用指纹解锁成功之后（部分机型指纹解锁操作只能在系统锁屏页进行），自定义锁屏页依然存在，你还是需要划开自定义锁屏页，才能看到手机主界面。<br/><br/>
　　解决这一问题的方案是一种取巧的方法，那就是在锁屏页的service中监听ACTION_USER_PRESENT广播。ACTION_USER_PRESENT广播是系统锁屏解锁广播，当系统锁屏页解锁时就会触发。如果在接收到这一广播时，将自定义锁屏页finish掉，就能避免在指纹解锁成功后自定义锁屏页仍然显示的问题。但是细心的读者会发现这种解法在逻辑上还存在问题，因为在用户没有设置锁屏密码的情况下，前文自定义锁屏页在onCreate()时设置的FLAG_DISMISS_KEYGUARD标志位能够轻易解锁系统的锁屏页，并触发ACTION_USER_PRESENT广播，此时自定义锁屏页的Service接收到这一广播后，发finish广播给自定义锁屏页，导致自定义锁屏页刚create就finish掉了，永远不可能出现。<br/><br/>
　　因此，我们必须对场景进行区分，只在有锁屏密码的情况下，才对接收到的ACTION_USER_PRESENT广播进行处理，finish自定义锁屏页。即在BroadcastReceiver的onReceive()方法中加入如下代码:</p>

<pre><code class="language-java">if(intent.getAction().equals(Intent.ACTION_USER_PRESENT)){
    if(VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN){
        if(km.isKeyguardSecure()){
            MLog.d(TAG,&quot;KeyguardSecure!&quot;);
            Intent i = new Intent(NOTIFY_USER_PRESENT);
            context.sendBroadcast(i);
        }
    }
}
</code></pre>

<p>　　这里KeyguardManager对象km的isKeyguardSecure()方法就是用来判断是否设置了锁屏密码。NOTIFY_USER_PRESENT是自定义广播，用来通知锁屏页Activity调用finish方法。<br/><br/>
　　这种做法是合理的，因为如果没有设置锁屏密码，FLAG_DISMISS_KEYGUARD标志位解锁系统锁屏之后，到达上述代码块，isKeyguardSecure()返回为false，不会导致自定义锁屏页Activity的finish操作。而如果设置了锁屏密码，FLAG_DISMISS_KEYGUARD必然无法解锁系统锁屏，到达不了上述代码块，也不会finish。这样就避免了自定义锁屏页刚创建出来就将自己finish掉的困境。另一方面，其他非FLAG_DISMISS_KEYGUARD方式触发的解锁，比如指纹解锁，都会使Activity消失，满足了需求。</p>

<h3 id="toc_11">自定义锁屏页下指纹识别无法使用的问题</h3>

<p>　　此外，有些手机型号，比如小米，在自定义锁屏页罩在系统锁屏页之上时（设置有锁屏密码），指纹解锁是无效的，也就是必须要划开自定义锁屏页，在系统锁屏页上才能进行指纹解锁。为了改善这种体验，我们可以在Activity中引入指纹解锁API，识别指纹并解锁，具体代码如下：</p>

<pre><code class="language-java">private void startFingerPrintListening(){
    if(!isFingerprintAuthAvailable()){
        return;
    } else {
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){
            if (checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED) {
                mFingerprintManager.authenticate(null,mCancellationSignal,0,new FingerprintManager.AuthenticationCallback(){
                    @Override
                    public void onAuthenticationError(int errorCode,CharSequence errString){
                        super.onAuthenticationError(errorCode,errString);
                    }
                    @Override
                    public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result){
                        super.onAuthenticationSucceeded(result);
                        finish();
                    }
                    
                    @Override
                    public void onAuthenticationFailed(){
                        super.onAuthenticationFailed();
                    }
                },null);
                return;
            }
        }
    }
}
</code></pre>

<pre><code class="language-java">public boolean isFingerprintAuthAvailable(){
    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){
        mKeyguardManager = (KeyguardManager) getSystemService(Activity.KEYGUARD_SERVICE);
        if(!mKeyguardManager.isKeyguardSecure()){
            return false;
        }
        if(checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED){
            mFingerprintManager = (FingerprintManager)getSystemService(Activity.FINGERPRINT_SERVICE);
            mCancellationSignal = new CancellationSignal();
            
            return mFingerprintManager.isHardwareDetected() &amp;&amp; mFingerprintManager.hasEnrolledFingerprints();
        } else {
         return false;
        }
    } else {
        return false;
    }
}
</code></pre>

<p>　　当然，不要忘记在Manifest中加入适当的权限：<br/>
　　</p>

<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.USEFINGERPRINT&quot;/&gt;
</code></pre>

<p>　　在调用指纹识别功能之前，我们需要判断指纹识别功能是否可用，以及APP是否有相应的权限。这一过程体现在isFingerprintAuthAvailable()中，第一步是获取KeyguardManager对象，调用isKeyguardSecure()判断是否设置有锁屏密码，如果有，则需进一步判断。checkSelfPermission用来判断APP是否有指纹识别的权限(SDK 23要求)，如果有则获取FingerprintManager对象，调用该对象的isHardwareDetected()方法判断指纹识别硬件是否可用，调用hasEnrolledFingerprints()判断是否有事先录入好的指纹，只有以上条件都满足，接下来才能调用指纹识别功能。<br/><br/>
　　指纹识别的调用体现在startFingerPrintListening()方法中，主要就是调用FingerprintManager的方法<br/>
　　</p>

<pre><code class="language-java">authenticate(FingerprintManager.CryptoObject crypto,CancellationSignal cancel,int flags,FingerprintManager.AuthenticationCallback callback,Handler handler)
</code></pre>

<p>　　其中，crypto参数代表Android6.0中crypto objects的wrapper class，可以通过该对象使authenticate过程更加安全，也可以不使用，这里我们将其设为null；cancel用来取消anthenticate(),我们new出一个对象传入就可以；flags是标志位，设置为0；callback为指纹识别回调，包含指纹识别的核心方法：onAuthenticationError()是指纹匹配连续失败后的回调（几十秒后才能继续匹配），onAuthenticationSucceeded()是指纹匹配成功的回调，onAuthenticationFailed()是指纹匹配失败时的回调。我们在这几个方法中做相应的处理即可，在onAuthenticationSucceeded()方法中调用finish()，就能够在指纹识别成功后关闭Activity。</p>

<h2 id="toc_12">五、总结</h2>

<p>　　通过以上内容的分享，本鹅希望能够对大家的开发有所帮助，如果内容有问题，也希望大家指点。综上所述，在Android上实现自定义锁屏页并不是一件复杂的事情，关键是对一些技术点的把握要比较清楚。Service中启动Activity的正确方法，广播静态注册与动态注册的差别，touch事件的分发传播机制，透明栏与沉浸模式的综合运用，以及指纹识别新技术的应用，都有很多值得推敲的地方。笔者当初实现自定义锁屏页时，没有太多思考，有时照搬前人的做法，有时各种flag随便添加，有时新旧API混淆，虽然实现了需求，但是代码不够简洁，可读性也差。因此，在今后的开发过程中，除了要快速实现需求，还要在随后的维护中，多多思考和研究，使代码能够达到“少一行不行，多一行难受”的境界。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15713923056028.html">
                
                  <h1>学习ConstraintLayout</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">ConstraintLayout简介</h2>

<p>ConstraintLayout作为一款可以灵活调整view位置和大小的Viewgroup被Google疯狂推荐，以前创建布局，默认根元素都是LinearLayout,现在是ConstraintLayout了。ConstraintLayout能够以支持库的形式最小支持到API 9，同时也在不断的丰富ConstraintLayout的API和功能。ConstraintLayout在复杂布局中能够有效的，降低布局的层级，提高性能，使用更加灵活。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15713923056028.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15712984956484.html">
                
                  <h1>代理模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">代理模式介绍</h2>

<p>代理模式(Proxy Pattern)也称为委托模式，在我们日常生活中也不少见，对于程序员来说最常接触的莫过于代理上网，连上代理服务器地址，就可以轻松畅游全世界的网络；还有每天吃饭时赶进度是常事，叫公司的同事帮忙买饭也是一种代理；如果你碰到辞职老板不给你发工资，那么你还得请个律师帮你打官司，这也是一种代理。总而言之，也许你并不留意，但是代理的确无处不在，现实生活中如此，我们的Code世界也是如此。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15712984956484.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AE%97%E6%B3%95.html'>算法</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15712937841703.html">
                
                  <h1>备忘录模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">备忘录模式介绍</h2>

<p>备忘录模式是一种行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态，这有点像我们平时说的“后悔药”。备忘录模式实现的方式需要保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保护的这些对象状态的完整性以及内部实现不向外暴露。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15712937841703.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AE%97%E6%B3%95.html'>算法</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15711947460528.html">
                
                  <h1>观察者模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">观察者模式介绍</h2>

<p>观察者模式是一个使用率非常高的模式，它最常用的地方是GUI系统、订阅 —— 发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小，甚至做到毫无依赖。以GUI系统来说，应用的UI具有易变性，尤其是前期随着业务的改变或者产品的需求修改，应用界面也会经常性变化，但是业务逻辑基本变化不大，此时，GUI系统需要一套机制来应对这种情况，使得UI层与具体的业务逻辑解耦，观察者模式此时就派上用场了。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15711947460528.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/16</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AE%97%E6%B3%95.html'>算法</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15711314242192.html">
                
                  <h1>策略模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">策略模式介绍</h2>

<p>在软件开发中也常常遇到这样的情况：实现某一个功能可以有多种算法或策略，我们根绝实际情况选择不同的算法或者策略来完成该功能。<br/>
针对这种情况，一种常规的方法是将多种算法写在一个类中。但是当多个算法集中在一个类中时，这个类就会变得臃肿，这个类的维护成本会变高，在维护时也更容易引发错误。如果我们需要增加一种新的排序算法，需要修改封装算法类的源代码。这就明显违反了我们所说的OCP原则和单一职责原则。<br/>
如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性、可维护性也就更高，这就是策略模式。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15711314242192.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AE%97%E6%B3%95.html'>算法</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15711233221322.html">
                
                  <h1>适配器模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">适配器模式介绍</h2>

<p>适配器模式在我们的开发中使用率极高，从代码中随处可见的Adapter就可以判断出来。从最早的ListView、GridView到现在最新的RecyclerView都需要使用Adapter，并且在开发中我们遇到的优化问题、出错概率较大的地方也基本出自Adapter。</p>

<p>说到底，适配器是将两个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。例如，经常碰到要在两个没有关系的类型之间进行交互，第一个解决方案就是修改各自类的接口，但是如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时我们往往会使用一个Adapter，在这两种接口之间创建一个“混血儿”接口，这个Adapter会将这两个接口进行兼容，在不修改原有代码的情况下满足需求。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15711233221322.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AE%97%E6%B3%95.html'>算法</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15711208032276.html">
                
                  <h1>外观模式(门面模式)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">外观模式介绍</h2>

<p>外观模式(Facade)在开发过程中的运用频率非常高，尤其是在现阶段各种第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装API的常用手段，例如网络模块、ImageLoader模块等。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15711208032276.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AE%97%E6%B3%95.html'>算法</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_5.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_7.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16066640335833.html">Jetpack学习 - WorkManager</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
