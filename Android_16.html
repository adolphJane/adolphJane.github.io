<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870085.html">
                
                  <h1>Android-Fresco详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="android-fresco%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Android Fresco网络图片加载库</h2>
<p>Fresco是Facebook最新推出的一款用于Android应用中展示图片的强大图片库，可以从网络、本地存储和本地资源中加载图片。相对于ImageLoader，拥有更快的图片下载速度以及可以加载和显示gif图等诸多优势，是个很好的图片框架。</p>
<p><strong>github地址</strong>： <a href="https://github.com/facebook/fresco">https://github.com/facebook/fresco</a></p>
<h2><a id="%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本的用法：</h2>
<ol>
<li>导入 Android Studio 或者 Gradle</li>
</ol>
<pre><code class="language-plain_text">dependencies {
  compile 'com.facebook.fresco:fresco:0.9.0+'
}
</code></pre>
<ol start="2">
<li>在xml中引入SimpleDraweeView</li>
</ol>
<pre><code class="language-SQL">&lt;com.facebook.drawee.view.SimpleDraweeView
    android:id=&quot;@+id/image_view&quot;
    android:layout_width=&quot;20dp&quot;
    android:layout_height=&quot;20dp&quot;
    fresco:placeholderImage=&quot;@drawable/my_drawable&quot;
  /&gt;
</code></pre>
<p><strong>注意：1、在SimpleDraweeView的父控件或者根节点中配置xmlns:fresco=&quot;<a href="http://schemas.android.com/apk/res-auto">http://schemas.android.com/apk/res-auto</a>&quot;;</strong><br />
3. 配置网络权限<br />
4. 在Java代码中开始加载图片</p>
<pre><code class="language-plain_text">Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/fresco-logo.png&quot;);
SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);
draweeView.setImageURI(uri);
</code></pre>
<h2><a id="uris%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>URIs的使用</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>Scheme</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>远程图片</td>
<td>http:// 和 https://</td>
<td>HttpURLConnection 或者参考  <a href="http://fresco-cn.org/docs/using-other-network-layers.html">使用其他网络加载方案</a></td>
</tr>
<tr>
<td>本地文件</td>
<td>file://</td>
<td>FileInputStream</td>
</tr>
<tr>
<td>Content Provider</td>
<td>content://</td>
<td>ContentResolver</td>
</tr>
<tr>
<td>asset目录下的资源</td>
<td>asset://</td>
<td>AssetManager</td>
</tr>
<tr>
<td>res目录下的资源</td>
<td>res://</td>
<td>Resources.openRawResource</td>
</tr>
</tbody>
</table>
<p><em><em>res 示例:Uri uri = Uri.parse(&quot;res://包名(实际可以是任何字符串甚至留空)/&quot; + R.drawable.ic_launcher);</em><br />
<em>注意：Fresco 不支持 相对路径的URI. 所有的URI都必须是绝对路径，并且带上该URI的scheme。</em></em></p>
<h2><a id="%E5%9C%A8xml%E4%B8%AD%E4%BD%BF%E7%94%A8simpledraweeview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在XML中使用SimpleDraweeView</h2>
<pre><code class="language-xml">&lt;com.facebook.drawee.view.SimpleDraweeView
    android:id=&quot;@+id/my_image_view&quot;
    android:layout_width=&quot;20dp&quot;
    android:layout_height=&quot;20dp&quot;
    fresco:fadeDuration=&quot;300&quot; // 淡入淡出的持续时间  
    fresco:actualImageScaleType=&quot;focusCrop&quot;  // 实际图像的缩放类型  
    fresco:placeholderImage=&quot;@color/wait_color&quot;  //占位图  
    fresco:placeholderImageScaleType=&quot;fitCenter&quot; //占位图的缩放类型  
    fresco:failureImage=&quot;@drawable/error&quot; //下载失败显示的图片  
    fresco:failureImageScaleType=&quot;centerInside&quot; //失败图的缩放类型  
    fresco:retryImage=&quot;@drawable/retrying&quot; //图片加载失败时显示，提示用户点击重新加载，重复加载4次还是没有加载出来的时候才会显示failureImage的图片  
    fresco:retryImageScaleType=&quot;centerCrop&quot; //重新加载的图片缩放类型  
    fresco:progressBarImage=&quot;@drawable/progress_bar&quot; //进度条图片  
    fresco:progressBarImageScaleType=&quot;centerInside&quot;  
    fresco:progressBarAutoRotateInterval=&quot;1000&quot; //进度图自动旋转间隔时间(单位：毫秒ms)  
    fresco:backgroundImage=&quot;@color/blue&quot;  //背景图片，这里的背景图片首先被绘制  
    fresco:overlayImage=&quot;@drawable/watermark&quot;  // 设置叠加图，在xml中只能设置一张叠加图片，如果需要多张图片的话，需要在java代码中设置哦  
    fresco:pressedStateOverlayImage=&quot;@color/red&quot;  // 设置点击状态下的叠加图  
    fresco:roundAsCircle=&quot;false&quot; //设置为圆形图  
    fresco:roundedCornerRadius=&quot;1dp&quot; // 圆角半径  
    fresco:roundTopLeft=&quot;true&quot; // 左上角是否为圆角  
    fresco:roundTopRight=&quot;false&quot;  
    fresco:roundBottomLeft=&quot;false&quot;  
    fresco:roundBottomRight=&quot;true&quot;  
    fresco:roundWithOverlayColor=&quot;@color/corner_color&quot;  
    fresco:roundingBorderWidth=&quot;2dp&quot; //边框的宽度  
    fresco:roundingBorderColor=&quot;@color/border_color&quot; //边框颜色
  /&gt;
</code></pre>
<p>说明：必须声明 android:layout_width 和 android:layout_height，否则将无法正确加载图像，另外不支持 wrap_content 属性，但也有例外的时候，如果想固定控件的宽高比，则可以使用wrap_content,并通过在xml代码中设置fresco:viewAspectRatio=&quot;小数&quot;或者在Java代码中设置mSimpleDraweeView.setAspectRatio(1.33f);即可。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>center</td>
<td>居中，无缩放</td>
</tr>
<tr>
<td>centerCrop</td>
<td>保持宽高比缩小或放大，是的两边都大于或等于边界，且宽和高契合显示边界，居中显示</td>
</tr>
<tr>
<td>focusCrop</td>
<td>同centerCrop，但居中点不是中点，而是指定的某个点</td>
</tr>
<tr>
<td>centerInside</td>
<td>缩放图片使两边都在显示边界内，居中显示。和fitCenter不同，不会对图片进行放大。如果尺寸大于显示边界，则保持宽高比例缩小图片。</td>
</tr>
<tr>
<td>fitCenter</td>
<td>保持宽高比，缩小或者放大，使得图片完全显示在显示边界内，且宽或高契合显示边界，居中显示。</td>
</tr>
<tr>
<td>fitStart</td>
<td>同上，但不居中，和显示边界左上对齐。</td>
</tr>
<tr>
<td>fitEnd</td>
<td>同fitCenter，但不居中，和显示边界右下对齐。</td>
</tr>
<tr>
<td>fitXY</td>
<td>不保存宽高比，填充满显示边界。</td>
</tr>
<tr>
<td>none</td>
<td>如果要使用tile mode显示，则需要设置为none</td>
</tr>
</tbody>
</table>
<h2><a id="%E5%9C%A8java%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%98%BE%E7%A4%BA%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在Java中自定义显示图</h2>
<p>一般情况下，在XML设置显示效果即可, 如果想更多定制化，可以这样:<br />
创建一个 builder 然后设置给 SimpleDraweeView:</p>
<pre><code class="language-java">List&lt;Drawable&gt; backgroundsList;
List&lt;Drawable&gt; overlaysList;
GenericDraweeHierarchyBuilder builder =
    new GenericDraweeHierarchyBuilder(getResources());
GenericDraweeHierarchy hierarchy = builder
    .setFadeDuration(300)
    .setPlaceholderImage(new MyCustomDrawable())
    .setBackgrounds(backgroundList)
    .setOverlays(overlaysList)
    .build();
mSimpleDraweeView.setHierarchy(hierarchy);
</code></pre>
<p>注意：请不要多次调用setHierarchy，即使这个View是可回收的。创建 DraweeHierarchy 的较为耗时的一个过程，应该多次利用。</p>
<h2><a id="%E4%BF%AE%E6%94%B9draweehierarchy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改 DraweeHierarchy</h2>
<p>DraweeHierarchy 的一些属性可以在运行时改变。<br />
要改变这些属性，首先获取一个引用:<br />
<code>GenericDraweeHierarchy hierarchy = mSimpleDraweeView.getHierarchy();</code></p>
<h2><a id="%E4%BF%AE%E6%94%B9%E5%8D%A0%E4%BD%8D%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改占位图</h2>
<p>修改占位图为资源id:<code>hierarchy.setPlaceholderImage(R.drawable.placeholderId);</code><br />
或者修改为一个 <code>Drawable:Drawable drawable;</code><br />
<code>hierarchy.setPlaceholderImage(drawable);</code></p>
<h2><a id="%E6%94%B9%E5%8F%98%E5%9B%BE%E5%83%8F%E7%9A%84%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>改变图像的显示</h2>
<p>修改缩放类型:<br />
<code>hierarchy.setActualImageScaleType(ScalingUtils.ScaleType.CENTER_INSIDE);</code><br />
如果你选择缩放类型为 focusCrop，需要指定一个居中点:<code>hierarchy.setActualImageFocusPoint(point);</code><br />
你可以为图像添加一个 color filter:</p>
<pre><code class="language-java">ColorFilter filter;
// 创建filter
hierarchy.setActualImageColorFilter(filter);
</code></pre>
<h2><a id="%E5%9C%86%E8%A7%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>圆角</h2>
<p>除了圆角显示方式（原来为圆角的不能修改为圆圈，反之亦然），其他圆角相关的呈现参数, 具体参见这里 是可以动态修改的。<br />
如下: 获取DraweeHierarchy的圆角显示参数，修改圆角半径为10。</p>
<pre><code class="language-java">RoundingParams roundingParams = hierarchy.getRoundingParams();
roundingParams.setCornersRadius(10);
hierarchy.setRoundingParams(roundingParams);
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/07/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870050.html">
                
                  <h1>Android-AppBarLayout&CollapsingToolbar&Toolbar组合使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="toolbar" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Toolbar</h2>
<p>Toobar主要是用来替换ActionBar的，换句话说，ActionBar能做的，Toolbar都能做。如果你对ActionBar的使用比较熟悉，你会发现Toolbar使用起来非常简单。ok，既然是替换，<strong>当然用Toolbar的时候就得先去把ActionBar给隐藏掉啦</strong>~</p>
<p>隐藏ActionBar的方法有很多，可以通过代码的方式隐藏，也可以通过配置文件的方式，我们主要是通过配置文件的方式来隐藏。在我们的styles.xml文件中的AppTheme标签中加入如下两行：</p>
<pre><code class="language-xml">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
</code></pre>
<p>当然了，你也可以新建一个<code>&lt;style&gt;</code>标签，将上面两行代码加入，并且将这个新建的标签作为<code>&lt;application&gt;</code>的<code>theme</code>。还可以选择通过将AppTheme的parent设置为<code>Theme.AppCompat.Light.NoActionBar</code>的方式。方法很多，可以自己随便选。<br />
接下来就是将Toolbar放入到布局文件（没啥好解释的）：</p>
<pre><code class="language-xml">&lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;
        android:layout_height=&quot;?android:attr/actionBarSize&quot;  /&gt;
</code></pre>
<p>最后将Toobar作为<code>ActionBar</code>来用</p>
<pre><code class="language-java">Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        toolbar.setTitle(&quot;这里是Title&quot;);
        toolbar.setSubtitle(&quot;这里是子标题&quot;);
        toolbar.setLogo(R.drawable.icon); 
        setSupportActionBar(toolbar);
</code></pre>
<p>可以对Toolbar设置Logo、标题、子标题等等~还有很多其他的设置，自己去慢慢玩，这里不提啦~。当然了，也可以在布局文件中设置这些，在布局文件设置就不写啦。<br />
如果Toolbar仅仅是用来对以往的ActionBar做一次替换，那也太没创意啦！完全没必要去替换了，因为它们表现出来的都是一样的，而且并没有让我们觉得用起来比ActionBar方便。那为啥要替换呢，总应该有他的理由吧：ActionBar是固定在顶部，并不能移动，我觉得这是最大的不好，而我们的ToolBar可以让我们随便摆放，就就可以带来很多灵活性和效果啦！</p>
<p>的确Toolbar根本就不够看的，一点都不复杂。接下来我们继续学习在Toolbar上面再套一层父View，让Toolbar更有互动性。</p>
<p>ToolBar中包含Nav Icon , Logo , Title , Sub Title , Menu Items 。<br />
我们可以通过代码设置上述ToolBar中的控件：</p>
<pre><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
	super.onCreate(savedInstanceState);
   setContentView(R.layout.activity_main);

   Toolbar toolbar = (Toolbar) findViewById(R.id.id_toolbar);

   // App Logo
   toolbar.setLogo(R.mipmap.ic_launcher);
   // Title
   toolbar.setTitle(&quot;App Title&quot;);
   // Sub Title
   toolbar.setSubtitle(&quot;Sub title&quot;);

   setSupportActionBar(toolbar);
   //Navigation Icon
   toolbar.setNavigationIcon(R.drawable.ic_toc_white_24dp);
}
</code></pre>
<p><strong>可选方案</strong><br />
当然如果你喜欢，也可以在布局文件中去设置部分属性：</p>
<pre><code class="language-java">&lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/id_toolbar&quot;
        app:title=&quot;App Title&quot;
        app:subtitle=&quot;Sub Title&quot;
        app:navigationIcon=&quot;@drawable/ic_toc_white_24dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:minHeight=&quot;?attr/actionBarSize&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;/&gt;
</code></pre>
<p>至于Menu Item，依然支持在menu/menu_main.xml去声明，然后复写<code>onCreateOptionsMenu</code>和<code>onOptionsItemSelected</code>即可。</p>
<p><strong>可选方案</strong><br />
也可以通过<code>toolbar.setOnMenuItemClickListener</code>实现点击MenuItem的回调。</p>
<pre><code class="language-java">toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {
	@Override
   public boolean onMenuItemClick(MenuItem item) {
		return false;
   }
});
</code></pre>
<p>关于字体的样式，可以在布局文件设置属性<code>app:titleTextAppearance</code>、<code>app:subtitleTextAppearance</code>或者代码<code>setTitleTextAppearance</code>、<code>setSubTitleTextAppearance</code>设置。</p>
<h3><a id="layout-scrollflags" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>layout_scrollFlags</h3>
<p>根据官方文档，layout_scrollFlags的取值可以为以下几种。</p>
<h3><a id="scroll" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>scroll</h3>
<p>设成这个值的效果就好比本View和scrolling view是“一体”的。具体示例我们在上面已经给出。有一点特别需要我们的注意，为了其他的滚动行为生效，必须同时指定scroll和相应的标记，比如我们想要exitUntilCollapsed所表现的滚动行为，必须将layout_scrollFlags指定为“scroll|exitUntilCollapsed”。</p>
<h3><a id="exituntilcollapsed" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>exitUntilCollapsed</h3>
<p>当本View离开屏幕时，会被“折叠”直到达到其最小高度。我们可以这样理解这个效果：当我们开始向上滚动scrolling view时，本View会先接管滚动事件，这样本View会先进行滚动，直到滚动到了最小高度（折叠了），scrolling view才开始实际滚动。而当本View已完全折叠后，再向下滚动scrolling view，直到scrolling view顶部的内容完全显示后，本View才会开始向下滚动以显现出来。</p>
<h3><a id="enteralways" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>enterAlways</h3>
<p>当scrolling view向下滚动时，本View会一起跟着向下滚动。实际上就好比我们同时对scrolling view和本View进行向下滚动，与exitUntilCollapsed不同，当scrolling view一开始滚动，ToolBar便已开始跟着滚动，而无需scrolling view将其内容滚动到顶部。</p>
<h3><a id="enteralwayscollapsed" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>enterAlwaysCollapsed</h3>
<p>从名字上就可以看出，这是在enterAlways的基础上，加上了“折叠”的效果。当我们开始向下滚动scrolling view时，本View会一起跟着滚动直到达到其“折叠高度”（即最小高度）。然后当scrolling view滚动至顶部内容完全显示后，再向下滚动scrolling view，本View会继续滚动到完全显示出来。需要把layout_scrollFlags指定为“scroll|enterAlways|enterAlwaysCollapsed”。</p>
<h3><a id="snap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>snap</h3>
<p>在一次滚动结束时，本View很可能只处于“部分显示”的状态，加上这个标记能够达到“要么完全隐藏，要么完全显示”的效果。到了这里，我们就把AppBarLayout能够实现的滚动行为介绍完毕了，很简单有木有。</p>
<h2><a id="appbarlayout" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AppBarLayout</h2>
<blockquote>
<p>AppBarLayout继承自LinearLayout，布局方向为垂直方向。所以你可以把它当成垂直布局的LinearLayout来使用。AppBarLayout是在LinearLayou上加了一些材料设计的概念，它可以让你定制当某个可滚动View的滚动手势发生变化时，其内部的子View实现何种动作。</p>
</blockquote>
<p>请注意：上面提到的某个<code>可滚动View</code>，可以理解为某个ScrollView。怎么理解上面的话呢？就是说，当某个ScrollView发生滚动时，你可以定制你的“顶部栏”应该执行哪些动作（如跟着一起滚动、保持不动等等）。那某个可移动的View到底是哪个可移动的View呢？这是由你自己指定的！如何指定，我们后面说。</p>
<h3><a id="appbarlayout%E5%AD%90view%E7%9A%84%E5%8A%A8%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AppBarLayout子View的动作</h3>
<p>内部的子View通过在布局中加<code>app:layout_scrollFlags</code>设置执行的动作，那么<code>app:layout_scrollFlags</code>可以设置哪些动作呢？分别如下：</p>
<h4><a id="%EF%BC%881%EF%BC%89-scroll%E5%80%BC%E8%AE%BE%E4%B8%BA-scroll%E7%9A%84-view%E4%BC%9A%E8%B7%9F%E9%9A%8F%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E4%B8%80%E8%B5%B7%E5%8F%91%E7%94%9F%E7%A7%BB%E5%8A%A8%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（1）<code>scroll</code>:值设为<code>scroll</code>的View会跟随滚动事件一起发生移动。</h4>
<p>什么意思呢？简单的说，就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。</p>
<pre><code class="language-xml">&lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
&lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>
<p><img src="media/15561207870050/20171010150764973485968.gif" alt="" /></p>
<h4><a id="%EF%BC%882%EF%BC%89-enteralways%E5%80%BC%E8%AE%BE%E4%B8%BA-enteralways%E7%9A%84-view%E5%BD%93-scrollview%E5%BE%80%E4%B8%8B%E6%BB%9A%E5%8A%A8%E6%97%B6%EF%BC%8C%E8%AF%A5view%E4%BC%9A%E7%9B%B4%E6%8E%A5%E5%BE%80%E4%B8%8B%E6%BB%9A%E5%8A%A8%E3%80%82%E8%80%8C%E4%B8%8D%E7%94%A8%E8%80%83%E8%99%91scrollview%E6%98%AF%E5%90%A6%E5%9C%A8%E6%BB%9A%E5%8A%A8%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（2）<code>enterAlways</code>:值设为<code>enterAlways</code>的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。</h4>
<p>ToolBar高度设为：（<code>?android:attr/actionBarSize</code>）<br />
<code>app:layout_scrollFlags=&quot;scroll|enterAlways&quot;</code></p>
<p><img src="media/15561207870050/20171010150764977767320.gif" alt="" /></p>
<h4><a id="%EF%BC%883%EF%BC%89%C2%A0-exituntilcollapsed%EF%BC%9A%E5%80%BC%E8%AE%BE%E4%B8%BA-exituntilcollapsed%E7%9A%84-view%EF%BC%8C%E5%BD%93%E8%BF%99%E4%B8%AAview%E8%A6%81%E5%BE%80%E4%B8%8A%E9%80%90%E6%B8%90%E2%80%9C%E6%B6%88%E9%80%9D%E2%80%9D%E6%97%B6%EF%BC%8C%E4%BC%9A%E4%B8%80%E7%9B%B4%E5%BE%80%E4%B8%8A%E6%BB%91%E5%8A%A8%EF%BC%8C%E7%9B%B4%E5%88%B0%E5%89%A9%E4%B8%8B%E7%9A%84%E7%9A%84%E9%AB%98%E5%BA%A6%E8%BE%BE%E5%88%B0%E5%AE%83%E7%9A%84%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E5%90%8E%EF%BC%8C%E5%86%8D%E5%93%8D%E5%BA%94scrollview%E7%9A%84%E5%86%85%E9%83%A8%E6%BB%91%E5%8A%A8%E4%BA%8B%E4%BB%B6%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（3） <code>exitUntilCollapsed</code>：值设为<code>exitUntilCollapsed</code>的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。</h4>
<p>怎么理解呢？简单解释：在ScrollView往上滑动时，首先是View把滑动事件“夺走”，由View去执行滑动，直到滑动最小高度后，把这个滑动事件“还”回去，让ScrollView内部去上滑。看个gif感受一下 ,图中将高度设的比较大:200dp，并将最小高度设置为（<code>?android:attr/actionBarSize</code>）<br />
<code>app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code></p>
<p><img src="media/15561207870050/20171010150764983431424.gif" alt="" /></p>
<h4><a id="%EF%BC%884%EF%BC%89-enteralwayscollapsed%EF%BC%9A%E6%98%AF-enteralways%E7%9A%84%E9%99%84%E5%8A%A0%E9%80%89%E9%A1%B9%EF%BC%8C%E4%B8%80%E8%88%AC%E8%B7%9F-enteralways%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%AE%83%E6%98%AF%E6%8C%87%EF%BC%8C-view%E5%9C%A8%E5%BE%80%E4%B8%8B%E2%80%9C%E5%87%BA%E7%8E%B0%E2%80%9D%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E9%A6%96%E5%85%88%E6%98%AF-enteralways%E6%95%88%E6%9E%9C%EF%BC%8C%E5%BD%93-view%E7%9A%84%E9%AB%98%E5%BA%A6%E8%BE%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%97%B6%EF%BC%8Cview%E5%B0%B1%E6%9A%82%E6%97%B6%E4%B8%8D%E5%8E%BB%E5%BE%80%E4%B8%8B%E6%BB%9A%E5%8A%A8%EF%BC%8C%E7%9B%B4%E5%88%B0scrollview%E6%BB%91%E5%8A%A8%E5%88%B0%E9%A1%B6%E9%83%A8%E4%B8%8D%E5%86%8D%E6%BB%91%E5%8A%A8%E6%97%B6%EF%BC%8Cview%E5%86%8D%E7%BB%A7%E7%BB%AD%E5%BE%80%E4%B8%8B%E6%BB%91%E5%8A%A8%EF%BC%8C%E7%9B%B4%E5%88%B0%E6%BB%91%E5%88%B0view%E7%9A%84%E9%A1%B6%E9%83%A8%E7%BB%93%E6%9D%9F%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>（4） <code>enterAlwaysCollapsed</code>：是<code>enterAlways</code>的附加选项，一般跟<code>enterAlways</code>一起使用，它是指，View在往下“出现”的时候，首先是<code>enterAlways</code>效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。</h4>
<p>图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize</code>,<code>app:layout_scrollFlags=&quot;scroll|enerAlways|enterAlwaysCollapsed&quot;</code></p>
<p><img src="media/15561207870050/20171010150764986160489.gif" alt="" /></p>
<h3><a id="%E5%B0%86appbarlayout%E4%B8%8Escrollview%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将AppBarLayout与ScrollView关联起来</h3>
<p>前面说了一直反复说“当ScrollView发生滚动时”，那么怎么将AppBarLayout与ScrollView关联起来呢？我们注意到，AppBarLayout与ScrollView之间动作“相互依赖”，把ScrollView和AppBarLayout作为CoordinateLayout的子View，然后编写一个Behavior，在这个Behavior里面判断当前的操作是应该让ScrollView时刻保持在AppBarLayout之下（即只要改变AppBarLayout的位置就可以一起滑动），还是应该让ScrollView内部滚动而不让AppBarLayout位置发生变化等等这些需求，都是可以在Behavior里面处理的。你可以去针对你的ScrollView编写Behavior。然而，我们看到我们的AppBarLayout事先的功能比较复杂，如果我们自己去定义这样的效果，代码非常复杂，还要考虑很多方面，好在Android帮我们写好啦，我们直接用就是了，这个ScrollView就是NestedScrollView，请注意，它并没有继承ScrollView，它继承的是FrameLayout，但是它实现的效果把它可以看成是ScrollView。</p>
<p>把NestedScrollView放入到我们的layout文件里面就可以啦~~~，很方便~</p>
<pre><code class="language-plain_text">&lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

       &lt;!--将你的内容放在这里--&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;
</code></pre>
<p>有没有注意到有个属性：<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>,它就是指定Behavior的，<code>appbar_scrolling_view_behavior</code>对应的类的名称是：<code>android.support.design.widget.AppBarLayout$ScrollingViewBehavior</code>感兴趣的可以去分析源码。<br />
好了，我们现在会用AppBarLayout啦~是不是发现用起来so easy!接下来我们把剩下<code>CollapsingToolbarLayout</code>的给&quot;消化&quot;掉！</p>
<h3><a id="xml%E5%B8%83%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>XML 布局</h3>
<pre><code class="language-plain_text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/coordinator&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/appbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;
        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;
        &lt;WebView
            android:id=&quot;@+id/web_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;
        &lt;/WebView&gt;
    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>
<p>在上面的布局文件中，NestedScrollView充当了scrolling view的角色，实际上scrolling view需要支持嵌套滚动，通常我们使用NestedScrollView、RecyclerView等已经实现了嵌套滚动的UI控件。</p>
<h2><a id="coordinatorlayout" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CoordinatorLayout</h2>
<p>在学习<code>CoordinatorLayout</code>之前，很有必要了解<code>CoordinatorLayout</code>能帮我们做什么，从名字上可以看出，就是帮我们协调子<code>View</code>的。怎么个协调法呢?就是它根据我们的定制，帮助我们协调各个子<code>View</code>的布局。</p>
<p><img src="media/15561207870050/20171010150764992635490.gif" alt="" /></p>
<p>稍微解释一下这个动画，蓝色的矩形是我们一个普通<code>View</code>，黄色的Hello是一个<code>Button</code>。我们水平拖动蓝色矩形时，黄色<code>Button</code>查着与蓝色矩形相反方向移动；竖直移动蓝色矩形时，黄色也跟着竖直。简而言之：它们在竖直方向同步移动，在水平方向相反。<br />
这个效果如果让你不用<code>CoordinatorLayout</code>去实现，应该没有任何问题，但是代码的耦合度应该非常大，你的代码必须要持有2个<code>View</code>的引用，然后在<code>onTouchEvent</code>里面做各种判断。如果我们想要实现的功能是，有更多的<code>View</code>要根据蓝色的<code>View</code>的移动相应作出响应，那么那就得在蓝色<code>View</code>的<code>onTounchEvent</code>里面针对其他的View处理各种逻辑。这耦合度未免太伤感了~<br />
而<code>CoordinatorLayout</code>既然号称能帮我们协调子View的布局，我们接下来看看<code>CoordinatorLayout</code>如何实现~</p>
<h3><a id="coordinatorlayout%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CoordinatorLayout使用</h3>
<p><code>CoordinatorLayout</code>的使用核心是<code>Behavior</code>，<code>Behavior</code>就是执行你定制的动作。在讲<code>Behavior</code>之前必须先理解两个概念：<code>Child</code>和<code>Dependency</code>，什么意思呢？<code>Child</code>当然是子<code>View</code>的意思了，是谁的子<code>View</code>呢，当然是<code>CoordinatorLayout</code>的子<code>View</code>；其实<code>Child</code>是指要执行动作的<code>CoordinatorLayout</code>的子<code>View</code>。而<code>Dependency</code><br />
是指<code>Child</code>依赖的<code>View</code>。比如上面的gif图中，蓝色的<code>View</code>就是<code>Dependency</code>，黄色的<code>View</code>就是<code>Child</code>，因为黄色的View的动作是依赖于蓝色的<code>View</code>。简而言之，就是如过<code>Dependency</code>这个View发生了变化，那么<code>Child</code>这个<code>View</code>就要相应发生变化。发生变化是具体发生什么变化呢？这里就要引入<code>Behavior</code>，<code>Child</code>发生变化的具体执行的代码都是放在<code>Behavior</code>这个类里面。<br />
怎么使用<code>Behavior</code>呢，首先，我们定义一个类，继承<code>CoordinatorLayout.Behavior&lt;T&gt;</code>,其中，泛型参数T是我们要执行动作的<code>View</code>类，也就是<code>Child</code>。然后就是去实现<code>Behavior</code>的两个方法：</p>
<pre><code class="language-java">/**
* 判断child的布局是否依赖dependency
*/
   @Override
 public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) {
    boolean rs;
    //根据逻辑判断rs的取值
    //返回false表示child不依赖dependency，ture表示依赖
    return rs;  
}

/**
* 当dependency发生改变时（位置、宽高等），执行这个函数
* 返回true表示child的位置或者是宽高要发生改变，否则就返回false
*/
@Override
public boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) {
     //child要执行的具体动作
        return true;
}
</code></pre>
<p>有了上面的概念后，我们看看具体怎么去实现吧~</p>
<p>为了响应跟随手指移动的操作，我们定义一个非常简单的<code>View</code>，这个<code>View</code>只响应跟随手指移动，将这个<code>View</code>作为<code>Dependency</code>。由于过于简单，这个<code>View</code>源码不粘贴，我们只需知道这个<code>View</code>的类名叫：<code>TempView</code>。</p>
<p>我们看看Behavior的使用：</p>
<pre><code class="language-java">package com.hc.studyCoordinatorLayout;

import android.content.Context;
import android.support.design.widget.CoordinatorLayout;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.View;
import android.widget.Button;

/**
 * Package com.hc.studyCoordinatorLayout
 * Created by HuaChao on 2016/6/1.
 */
public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; {
    private int width;

    public MyBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
        DisplayMetrics display = context.getResources().getDisplayMetrics();
        width = display.widthPixels;
    }

    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) {
        //如果dependency是TempView的实例，说明它就是我们所需要的Dependency
        return dependency instanceof TempView;
    }

    //每次dependency位置发生变化，都会执行onDependentViewChanged方法
    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, Button btn, View dependency) {

        //根据dependency的位置，设置Button的位置

        int top = dependency.getTop();
        int left = dependency.getLeft();

        int x = width - left - btn.getWidth();
        int y = top;

        setPosition(btn, x, y);
        return true;
    }

    private void setPosition(View v, int x, int y) {
        CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) v.getLayoutParams();
        layoutParams.leftMargin = x;
        layoutParams.topMargin = y;
        v.setLayoutParams(layoutParams);
    }

}
</code></pre>
<p>OK，现在我们为<code>Button</code>类指定了<code>Dependency</code>，并且定义好了跟随<code>Dependency</code>一直变化的动作（<code>Behavior</code>），接下来我们就要指定好为哪个具体的<code>Button</code>实例来绑定这些。方法很简单，直接在布局文件指定就好：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.hc.studyCoordinatorLayout.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/btn&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#FFCC00&quot;
        android:text=&quot;Hello&quot;
        app:layout_behavior=&quot;com.hc.studyCoordinatorLayout.MyBehavior&quot; /&gt;

    &lt;com.hc.studyCoordinatorLayout.TempView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#3366CC&quot;  /&gt;
&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>
<p>是不是很简单呢？我们只需关注<code>Behavior</code>的编写就好了，把<code>Child</code>和<code>Dependency</code>之间的关系完全解耦了~</p>
<h2><a id="collapsingtoolbarlayout" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CollapsingToolbarLayout</h2>
<p><code>CollapsingToolbarLayout</code>是用来对<code>Toolbar</code>进行再次包装的<code>ViewGroup</code>，主要是用于实现折叠（其实就是看起来像伸缩~）的App Bar效果。它需要放在<code>AppBarLayout</code>布局里面，并且作为<code>AppBarLayout</code>的直接子<code>View</code>。<code>CollapsingToolbarLayout</code>主要包括几个功能（参照了官方网站上内容，略加自己的理解进行解释）：</p>
<blockquote>
<p>(1)  Collasping title（可折叠标题）：当布局完全可见时，这个标题比较大；当折叠起来时，标题也会变小。标题的外观可以通过expandedTextAppearance和collapsedTextAppearance属性来调整。<br />
(2)  Content scrim（内容纱布）：根据CollapsingToolbarLayout是否滚动到一个临界点，内容纱布会显示或隐藏。可以通过setContentScrim(Drawable)来设置内容纱布。<br />
(3)  Status bar scrim（状态栏纱布）：也是根据是否滚动到临界点，来决定是否显示。可以通过setStatusBarScrim(Drawable)方法来设置。这个特性只有在Android5.0及其以上版本，我们设置fitSystemWindows为ture时才能生效。<br />
(4)  Parallax scrolling children（视差滚动子View）：子View可以选择以“视差”的方式来进行滚动。（视觉效果上就是子View滚动的比其他View稍微慢些）<br />
(5)  Pinned position children：子View可以选择固定在某一位置上。子View可以选择是否在全局空间上固定位置，这对于Toolbar来说非常有用，因为当布局在移动时，可以将Toolbar固定位置而不受移动的影响。 将<code>app:layout_collapseMode</code>设为<code>pin</code>。<br />
了解这些概念后，我们来看看布局吧~</p>
</blockquote>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;

    &lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            app:expandedTitleMarginEnd=&quot;64dp&quot;
            app:expandedTitleMarginStart=&quot;48dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/main.backdrop&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;300dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/material_img&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;

            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?android:attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot;  /&gt;

        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingTop=&quot;50dp&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@string/my_txt&quot;
            android:textSize=&quot;20sp&quot; /&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>
<p>上面的都看得懂吧，每个陌生的属性都是讲过的哦，忘记了的话回头看，稍微解释一下，图片被设置为有视差的滑动，Toolbar设置为固定不动，另外，CollapsingToolbarLayout会对title进行放大和缩小，我们看看效果吧~</p>
<p><img src="media/15561207870050/20171010150765001948776.gif" alt="" /></p>
<p>如果你希望拖动过程中状态栏是透明的，可以在CollapsingToolbarLayout中加 <code>app:statusBarScrim=&quot;@android:color/transparent&quot;</code>，并且在onCreate中调用<code>getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)</code>将状态栏设置为透明就好啦~</p>
<h3><a id="xml%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>XML布局文件</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/coordinator&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/app_bar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;256dp&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;
        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:id=&quot;@+id/collapsing_toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            app:expandedTitleMarginEnd=&quot;50dp&quot;
            app:expandedTitleMarginStart=&quot;50dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;
            &lt;ImageView
                android:src=&quot;@mipmap/ic_launcher&quot;
                android:id=&quot;@+id/image&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                android:scaleType=&quot;centerCrop&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;
            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot; /&gt;
        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;
        &lt;WebView
            android:id=&quot;@+id/web_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;
        &lt;/WebView&gt;
 &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>
<p>我们在XML文件中为CollapsingToolbarLayout的layout_scrollFlags指定为“scroll|exitUntilCollapsed”，这样便实现了向上滚动scrolling view时的折叠效果。CollapsingToolbarLayout本质上是一个FrameLayout。我们在布局文件中为它指定了两个子View，分别是ImageView和Toolbar。ImageView的layout_collapseMode属性设为了parallax，也就是我们前面介绍的视差滚动；而<code>Toolbar</code>的<code>layout_collaspeMode</code>设为了pin，也就是Toolbar会始终固定在顶部。</p>
<h3><a id="contentscrim" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>contentScrim</h3>
<p>在上图中，我们看到Toolbar的背景一直都是我们指定的图片，即时图片向上滚动到消失后也是这样。那么可不可以让图片完全消失后，Toolbar显示一个另外的背景呢？答案是肯定的，只要使用我们上面提到的“内容纱布”即可。还记得我们上面关于内容纱布的介绍吗？当CollapsingToolbarLayout滚动到一个临界位置，内容纱布就会显现出来，我们通过一个例子感受下。<br />
当CollapsingToolbarLayout完全折叠后，ToolBar的背景变为了黑色，好像盖上了一层布，所以这个属性叫做“内容纱布”。这里我们发现，只有CollapsingToolbarLayout滚动到折叠后，内容纱布才显现出来，也就是说，默认的临界位置就是滚动到折叠。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/07/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870016.html">
                
                  <h1>Android-DialogFragment详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="dialogfragment%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%8F%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DialogFragment 设置全屏方法</h2>
<h3><a id="%E6%96%B9%E6%B3%95%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法一</h3>
<pre><code class="language-java">@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setStyle(STYLE_NO_FRAME, android.R.style.Theme_Holo_Light);
}
</code></pre>
<h3><a id="%E6%96%B9%E6%B3%95%E4%BA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法二</h3>
<p><strong>style</strong></p>
<pre><code class="language-java">&lt;style name=&quot;style_dialog&quot; parent=&quot;android:style/Theme.Dialog&quot;&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt;
    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;
    &lt;item name=&quot;android:scrollHorizontally&quot;&gt;true&lt;/item&gt;
    &lt;!-- Dialog进入及退出动画 --&gt;
    &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/BottomToTopAnim&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;BottomToTopAnim&quot; parent=&quot;android:Animation&quot;&gt;
    &lt;item name=&quot;@android:windowEnterAnimation&quot;&gt;@anim/bottom_in&lt;/item&gt;
    &lt;item name=&quot;@android:windowExitAnimation&quot;&gt;@anim/bottom_out&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p><strong>bottom_in bottom_out 进入进出动画</strong></p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;translate
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot;
    android:fromYDelta=&quot;100%p&quot;
    android:toYDelta=&quot;0&quot;/&gt;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot;
    android:fromYDelta=&quot;0&quot;
    android:toYDelta=&quot;100%p&quot;/&gt;
</code></pre>
<p><strong>代码</strong></p>
<pre><code class="language-java">@NonNull
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {

    LayoutInflater inflater = getActivity().getLayoutInflater();
    View view = inflater.inflate(R.layout.view, null);

    final Dialog dialog = new Dialog(getActivity(), R.style.style_dialog);
    dialog.setContentView(view);
    dialog.show();

    Window window = dialog.getWindow();
    window.setGravity(Gravity.BOTTOM); //可设置dialog的位置
    window.getDecorView().setPadding(0, 0, 0, 0); //消除边距

    WindowManager.LayoutParams lp = window.getAttributes();
    lp.width = WindowManager.LayoutParams.MATCH_PARENT;   //设置宽度充满屏幕
    lp.height = WindowManager.LayoutParams.WRAP_CONTENT;
    window.setAttributes(lp);
    return dialog;

}
</code></pre>
<h2><a id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生命周期</h2>
<ul>
<li>onAttach</li>
<li>onCreate</li>
<li>onCreateView</li>
<li>onStart</li>
<li>onStop</li>
<li>third activity on destroy</li>
<li>onDestroyView</li>
<li>onDetach</li>
<li>onAttach</li>
<li>onCreate</li>
<li>onCreateView</li>
<li>onStart</li>
</ul>
<h2><a id="%E8%AE%BE%E7%BD%AE%E8%83%8C%E6%99%AF%E4%B8%BA%E9%80%8F%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置背景为透明</h2>
<pre><code class="language-java">View decorView = getDialog().getWindow().getDecorView();
decorView.setBackground(new ColorDrawable(Color.TRANSPARENT));
</code></pre>
<p>(PS:Window -&gt; DecorView -&gt; FrameLayout -&gt; FrameLayout -&gt; 我们的自定义View) 这个逻辑大家应该都知道的，所以我们只需要改变底部的DecorView的背景色即可。</p>
<h2><a id="%E8%AE%BE%E7%BD%AE%E5%BC%B9%E6%A1%86%E4%BD%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置弹框位置</h2>
<p>因为View是在window下面的，我们只需要让window的Grivaty属性是Bottom，这样，里面的元素都是居于底部即可。</p>
<pre><code class="language-java">Window window = getDialog().getWindow();
WindowManager.LayoutParams layoutParams = window.getAttributes();
layoutParams.gravity = Gravity.BOTTOM;
window.setAttributes(layoutParams);
</code></pre>
<h2><a id="%E8%A7%A3%E5%86%B3dialogfragment%E4%B8%A4%E8%BE%B9%E7%9A%84%E9%97%B4%E9%9A%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决DialogFragment两边的间隙</h2>
<p>因为View都是被包含在window里面，虽然我们的自己的View的宽度已经设置成了match_parent，但是我们并没有对window设置宽度为最大。所以我们先来改变window的宽度。</p>
<p>改变window的宽度：</p>
<pre><code class="language-java">Window window = getDialog().getWindow();
WindowManager.LayoutParams layoutParams = window.getAttributes();
layoutParams.gravity = Gravity.BOTTOM;
layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
window.setAttributes(layoutParams);
</code></pre>
<p>我们在前面修改弹框位置的代码处，多添加一句：</p>
<p><code>layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;</code></p>
<p>设置之后虽然二边的间隙变小了很多。但是还是有间隙，既然我们都已经把window的宽度变为match_parent,还是没填充，说明应该是有padding值。那我们马上就想到了，难道是DecorView里面有padding值。毕竟我们的View也是被包含在DecorView里面。废话不多说，我们马上实验：</p>
<p><code>decorView.setPadding(0,0,0,0);</code></p>
<blockquote>
<p>PS:这里还有另外一种方法，不写这句decorView.setPadding(0,0,0,0);而是直接设置window的背景颜色，window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));源码中其实也给DecorView设置了padding值。所以效果相同。</p>
</blockquote>
<h2><a id="%E8%AE%BE%E7%BD%AE%E5%BC%B9%E6%A1%86%E4%BB%8E%E4%B8%8B%E8%80%8C%E4%B8%8A%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置弹框从下而上显示</h2>
<p>我们看过ios的弹框效果，是从底部从下而上升起，然后消失的时候也是从上而下消失。所以消失的时候我们不能单纯的让DialogFragment执行<code>dismiss()</code>，而是先让弹框执行下移的动画效果，然后再<code>dismiss()</code>。</p>
<p>既然谈到了上下的移动，大家肯定马上想到了用TranslateAnimation动画来做，我们就一步步来看如何用这个来实现：</p>
<ul>
<li>弹框出现动画：</li>
</ul>
<pre><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f
);
slide.setDuration(400);
slide.setFillAfter(true);
slide.setFillEnabled(true);
view.startAnimation(slide);
</code></pre>
<p>我们来看TranslateAnimation，这里我们传了八个参数，一般大家用到的是只传四个参数：</p>
<pre><code class="language-plain_text">TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)
</code></pre>
<p>也就是从坐标<code>(fromXDelta,fromYDelta)</code>到<code>(toXDelta,toYDelta)</code>。<br />
我们可以点进去这个构造函数查看：</p>
<pre><code class="language-java">public TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) {
      mFromXValue = fromXDelta;
      mToXValue = toXDelta;
      mFromYValue = fromYDelta;
      mToYValue = toYDelta;

      mFromXType = ABSOLUTE;
      mToXType = ABSOLUTE;
      mFromYType = ABSOLUTE;
      mToYType = ABSOLUTE;
}
</code></pre>
<p>之所以我们以前用的只传了四个参数，是因为他给我们把另外四个参数以及赋了默认值，也就是<code>ABSOLUTE</code>。我们继续看有哪几种可以选择：</p>
<pre><code class="language-plain_text">  /**
   * The specified dimension is an absolute number of pixels.
   */
  public static final int ABSOLUTE = 0;

  /**
   * The specified dimension holds a float and should be multiplied by the
   * height or width of the object being animated.
   */
  public static final int RELATIVE_TO_SELF = 1;

  /**
   * The specified dimension holds a float and should be multiplied by the
   * height or width of the parent of the object being animated.
   */
  public static final int RELATIVE_TO_PARENT = 2;
</code></pre>
<p>通过字面意思我们也能理解：<br />
<code>ABSOLUTE</code>是绝对坐标，<code>RELATIVE_TO_SELF</code>是相对于自身，<code>RELATIVE_TO_PARENT</code>是相对于父View。<br />
而我们只需要我们的弹框显示的位置，让的起始位置如下图所示：</p>
<p>刚开始超过屏幕，并且高度为弹框自身的高度，然后再回到原始位置,所以我们就用：</p>
<pre><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f
);
</code></pre>
<p>从原来的位置，增加了自身高度的距离为起始点，开始移动，然后再回到原来的位置。</p>
<ul>
<li>消失动画：</li>
</ul>
<p>只要跟上面反过来就可以了。同时这里我们要额外增加监听动画结束事件，因为我们让弹框往下移动结束后，要让这个弹框dismiss掉:</p>
<pre><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f
);
slide.setAnimationListener(new Animation.AnimationListener() {
  @Override
  public void onAnimationStart(Animation animation) {}

  @Override
  public void onAnimationEnd(Animation animation) {
      IOSDialogFragment.this.dismiss();
  }

  @Override
  public void onAnimationRepeat(Animation animation) {}
});
</code></pre>
<p>所以我们的动画的代码总结下就是：</p>
<pre><code class="language-java">@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
    getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE);
    rootView = inflater.inflate(R.layout.fragment_ios_dialog, container, false);
    slideToUp(rootView);
    return rootView;
}


public void slideToUp(View view){
    Animation slide = new TranslateAnimation(
        Animation.RELATIVE_TO_SELF, 0.0f,
        Animation.RELATIVE_TO_SELF, 0.0f, 
        Animation.RELATIVE_TO_SELF,1.0f, Animation.RELATIVE_TO_SELF, 0.0f);

	slide.setDuration(400);
	slide.setFillEnabled(true);
	slide.setFillAfter(true);
	view.startAnimation(slide);
}

public void slideToDown(View view){
	Animation slide = new TranslateAnimation(
		Animation.RELATIVE_TO_SELF, 0.0f,
		Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF,0.0f, Animation.RELATIVE_TO_SELF, 1.0f);

	slide.setDuration(400);
	slide.setFillEnabled(true);
	slide.setFillAfter(true);
	view.startAnimation(slide);

	slide.setAnimationListener(new Animation.AnimationListener() {
		@Override
		public void onAnimationStart(Animation animation) {

		}

		@Override
		public void onAnimationEnd(Animation animation) {
			IOSDialogFragment.this.dismiss();//弹框消失
		}

		@Override
		public void onAnimationRepeat(Animation animation) {

		}
	});
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869937.html">
                
                  <h1>Android-View详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="view%E6%9C%898%E4%B8%AA%E7%9B%B4%E6%8E%A5%E5%AD%90%E7%B1%BB%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>View有8个直接子类：</h2>
<p><code>AnalogClock</code>, <code>ImageView</code>, <code>KeyboardView</code>, <code>ProgressBar</code>, <code>SurfaceView</code>, <code>TextView</code>, <code>ViewGroup</code>, <code>ViewStub</code>。</p>
<h2><a id="view%E6%9C%8954%E4%B8%AA%E9%97%B4%E6%8E%A5%E5%AD%90%E7%B1%BB%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>View有54个间接子类：</h2>
<p><code>AbsListView</code>, <code>AbsSeekBar</code>,<code> AbsSpinner</code>, <code>AbsoluteLayout</code>, <code>AdapterView&lt;T extends Adapter&gt;</code>, <code>AppWidgetHostView</code>, <code>AutoCompleteTextView</code>,<code>Button</code>,<code>CheckBox</code>, <code>CheckedTextView</code>, <code>Chronometer</code>, <code>CompoundButton</code>,<code> DatePicker</code>, <code>DialerFilter</code>, <code>DigitalClock</code>,<code>EditText</code>, <code>ExpandableListView</code>, <code>ExtractEditText</code>,<code> FrameLayout</code>, <code>GLSurfaceView</code>,<code>Gallery</code>,<code>GestureOverlayView</code>,<code>GridView</code>, <code>HorizontalScrollView</code>, <code>ImageButton</code>, <code>ImageSwitcher</code>, <code>LinearLayout</code>,<code>ListView</code>,<code>MediaController</code>, <code>MultiAutoCompleteTextView</code>, <code>QuickContactBadge</code>,<code>RadioButton</code>,<code>RadioGroup</code>, <code>RatingBar</code>, <code>RelativeLayout</code>, <code>ScrollView</code>, <code>SeekBar</code>, <code>SlidingDrawer</code>, <code>Spinner</code>, <code>TabHost</code>, <code>TabWidget</code>, <code>TableLayout</code>, <code>TableRow</code>, <code>TextSwitcher</code>, <code>TimePicker</code>, <code>ToggleButton</code>, <code>TwoLineListItem</code>,<code>VideoView</code>, <code>ViewAnimator</code>, <code>ViewFlipper</code>, <code>ViewSwitcher</code>, <code>WebView</code>, <code>ZoomButton</code>, <code>ZoomControls</code></p>
<h2><a id="view%E7%9A%84%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>View的属性</h2>
<h3><a id="%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本属性</h3>
<ul>
<li>
<p><code>android:alpha</code>关联方法: <code>setAlpha(float)</code> 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。</p>
</li>
<li>
<p><code>android:background</code>关联方法: <code>setBackgroundResource(int)</code> 属性说明: 视图背景</p>
</li>
<li>
<p><code>android:clickable</code>关联方法: <code>setClickable(boolean)</code> 属性说明: 视图是否可点击</p>
</li>
<li>
<p><code>android:contentDescription</code>关联方法: <code>setContentDescription(CharSequence)</code> 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明</p>
</li>
<li>
<p><code>android:drawingCacheQuality</code>关联方法: <code>setDrawingCacheQuality(int)</code> 属性说明: &quot;设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存&quot;</p>
</li>
<li>
<p><code>android:duplicateParentState</code>关联方法: 属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）</p>
</li>
<li>
<p><code>android:fadeScrollbars</code>关联方法: <code>setScrollbarFadingEnabled(boolean)</code> 属性说明: 定义在ScrollBar没有使用时，是否褪色。</p>
</li>
<li>
<p><code>android:fadingEdgeLength</code>关联方法: <code>getVerticalFadingEdgeLength()</code> 属性说明: 设置边框渐变的长度。</p>
</li>
<li>
<p><code>android:filterTouchesWhenObscured</code>关联方法: <code>setFilterTouchesWhenObscured(boolean)</code> 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。</p>
</li>
<li>
<p><code>android:fitsSystemWindows</code>关联方法: <code>setFitsSystemWindows(boolean)</code> 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏）</p>
</li>
<li>
<p><code>android:focusable</code>关联方法: <code>setFocusable(boolean)</code> 属性说明: 设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。在Touch模式下获取焦点需要设置focusableInTouchMode为true。</p>
</li>
<li>
<p><code>android:focusableInTouchMode</code>关联方法: <code>setFocusableInTouchMode(boolean)</code> 属性说明: 设置在Touch模式下View是否能取得焦点。</p>
</li>
<li>
<p><code>android:hapticFeedbackEnabled</code>关联方法: <code>setHapticFeedbackEnabled(boolean)</code> 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果</p>
</li>
<li>
<p><code>android:id</code>关联方法: <code>setId(int)</code> 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用<code>View.findViewById()</code> 或<code>Activity.findViewById()</code>根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。</p>
</li>
<li>
<p><code>android:importantForAccessibility</code>关联方法: <code>setImportantForAccessibility(int)</code> 属性说明: 设置可达性的重要性</p>
</li>
<li>
<p><code>android:isScrollContainer</code>关联方法: <code>setScrollContainer(boolean)</code> 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条</p>
</li>
<li>
<p><code>android:keepScreenOn</code>关联方法: <code>setKeepScreenOn(boolean)</code> 属性说明: 视图在可见的情况下是否保持唤醒状态。</p>
</li>
<li>
<p><code>android:layerType</code>关联方法: <code>setLayerType(int,Paint)</code> 属性说明: &quot;设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。&quot;</p>
</li>
<li>
<p><code>android:layoutDirection</code>关联方法: <code>setLayoutDirection(int)</code> 属性说明: 定义布局图纸的方向</p>
</li>
<li>
<p><code>android:longClickable</code>关联方法: <code>setLongClickable(boolean)</code> 属性说明: 是否响应长点击事件</p>
</li>
<li>
<p><code>android:minHeight</code>关联方法: <code>setMinimumHeight(int)</code> 属性说明: 设置视图最小高度</p>
</li>
<li>
<p><code>android:minWidth</code>关联方法: <code>setMinimumWidth(int)</code> 属性说明: 设置视图最小宽度</p>
</li>
<li>
<p><code>android:nextFocusDown</code>关联方法: <code>setNextFocusDownId(int)</code> 属性说明: 向下移动焦点时，下一个获取焦点的view的id</p>
</li>
<li>
<p><code>android:nextFocusForward</code>关联方法: <code>setNextFocusForwardId(int)</code> 属性说明: 下一个获取焦点的view的id</p>
</li>
<li>
<p><code>android:nextFocusLeft</code>关联方法: <code>setNextFocusLeftId(int)</code> 属性说明: 向左移动焦点时，下一个获取焦点的view的id</p>
</li>
<li>
<p><code>android:nextFocusRight</code>关联方法: <code>setNextFocusRightId(int)</code> 属性说明: 向右移动焦点时，下一个获取焦点的view的id</p>
</li>
<li>
<p><code>android:nextFocusUp</code>关联方法: <code>setNextFocusUpId(int)</code> 属性说明: 向上移动焦点时，下一个获取焦点的view的id</p>
</li>
<li>
<p><code>android:onClick</code>关联方法: 属性说明: 点击时，要调用的方法的名称。</p>
</li>
<li>
<p><code>android:padding</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 设置上下左右的边距</p>
</li>
<li>
<p><code>android:paddingBottom</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 下边距</p>
</li>
<li>
<p><code>android:paddingEnd</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 与<code>android:paddingRight</code>相同</p>
</li>
<li>
<p><code>android:paddingLeft</code>关联方法: <code>setPadding(int,int,int,int)</code> 属性说明: 左边距</p>
</li>
<li>
<p><code>android:paddingRight</code>关联方法: <code>setPadding(int,int,int,int)</code> 属性说明: 右边距</p>
</li>
<li>
<p><code>android:paddingStart</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: <code>android:paddingLeft</code>相同</p>
</li>
<li>
<p><code>android:paddingTop</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 上边距</p>
</li>
<li>
<p><code>android:requiresFadingEdge</code>关联方法: <code>setVerticalFadingEdgeEnabled(boolean)</code> 属性说明: 定义滚动时边缘是否褪色</p>
</li>
<li>
<p><code>android:rotation</code>关联方法: <code>setRotation(float)</code> 属性说明: 旋转度数</p>
</li>
<li>
<p><code>android:rotationX</code>关联方法: <code>setRotationX(float)</code> 属性说明: 水平旋转度数</p>
</li>
<li>
<p><code>android:rotationY</code>关联方法: <code>setRotationY(float)</code> 属性说明: 竖直旋转度数</p>
</li>
<li>
<p><code>android:saveEnabled</code>关联方法: <code>setSaveEnabled(boolean)</code> 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。</p>
</li>
<li>
<p><code>android:scaleX</code>关联方法: <code>setScaleX(float)</code> 属性说明: 水平方向缩放比例</p>
</li>
<li>
<p><code>android:scaleY</code>关联方法: <code>setScaleY(float)</code> 属性说明: 竖直方向缩放比例</p>
</li>
<li>
<p><code>android:scrollX</code>关联方法: 属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离</p>
</li>
<li>
<p><code>android:scrollY</code>关联方法: 属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离</p>
</li>
<li>
<p><code>android:scrollbarAlwaysDrawHorizontalTrack</code>关联方法: 属性说明: 是否总是绘制水平滚动条的滚动轨道</p>
</li>
<li>
<p><code>android:scrollbarAlwaysDrawVerticalTrack</code>关联方法: 属性说明: 是否总是绘制竖直滚动条的滚动轨道</p>
</li>
<li>
<p><code>android:scrollbarDefaultDelayBeforeFade</code>关联方法: <code>setScrollBarDefaultDelayBeforeFade(int)</code> 属性说明: 滚动条在n毫秒后开始淡出。</p>
</li>
<li>
<p><code>android:scrollbarFadeDuration</code>关联方法: <code>setScrollBarFadeDuration(int)</code> 属性说明: 滚动条用多长时间淡出完毕。</p>
</li>
<li>
<p><code>android:scrollbarSize</code>关联方法: <code>setScrollBarSize(int)</code> 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度</p>
</li>
<li>
<p><code>android:scrollbarStyle</code>关联方法: <code>setScrollBarStyle(int)</code> 属性说明: &quot;滚动条的风格。共4组值： <code>insideOverlay</code>——内贴图 <code>insideInset</code>——内插图 <code>outsideOverlay</code>——外贴图 <code>outsideInset</code>——外插图。 <code>inside</code>就是滚动条在绘制在padding以内；<code>outside</code>就是不需要绘制在<code>padding</code>内（即view的边界处）；<code>Overlay</code>是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；<code>Inset</code>是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。&quot;</p>
</li>
<li>
<p><code>android:scrollbarThumbHorizontal</code>关联方法: 属性说明: 水平滚动块的drawable对象</p>
</li>
<li>
<p><code>android:scrollbarThumbVertical</code>关联方法: 属性说明: 竖直滚动块的drawable对象</p>
</li>
<li>
<p><code>android:scrollbarTrackHorizontal</code>关联方法: 属性说明: 水平滚动条滚动轨道的drawable对象</p>
</li>
<li>
<p><code>android:scrollbarTrackVertical</code>关联方法: 属性说明: 竖直滚动条滚动轨道的drawable对象</p>
</li>
<li>
<p><code>android:scrollbars</code>关联方法: 属性说明: &quot;设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条&quot;</p>
</li>
<li>
<p><code>android:soundEffectsEnabled</code>关联方法: <code>setSoundEffectsEnabled(boolean)</code> 属性说明: 点击或触摸该view时，是否需要有声音效果</p>
</li>
<li>
<p><code>android:tag</code>关联方法: 属性说明: string标识。类似id，id是整数标识。</p>
</li>
<li>
<p><code>android:textAlignment</code>关联方法: <code>setTextAlignment(int)</code> 属性说明: 设置文本的显示方式。</p>
</li>
<li>
<p><code>android:textDirection</code>关联方法: <code>setTextDirection(int)</code> 属性说明: 设置文本的显示方向。</p>
</li>
<li>
<p><code>android:transformPivotX</code>关联方法: <code>setPivotX(float)</code> 属性说明: 水平方向偏转量</p>
</li>
<li>
<p><code>android:transformPivotY</code>关联方法: <code>setPivotY(float)</code> 属性说明: 竖直方向偏转量</p>
</li>
<li>
<p><code>android:translationX</code>关联方法: <code>setTranslationX(float)</code> 属性说明: 水平方向的移动距离</p>
</li>
<li>
<p><code>android:translationY</code>关联方法: <code>setTranslationY(float)</code> 属性说明: 竖直方向的移动距离</p>
</li>
<li>
<p><code>android:visibility</code>关联方法: <code>setVisibility(int)</code> 属性说明: &quot;view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见&quot;</p>
</li>
</ul>
<h3><a id="textview%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TextView属性说明</h3>
<p>下面对TextView的属性进行说明<code>android:autoLink</code>关联方法: <code>setAutoLinkMask(int)</code>属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值(none/web/email/phone/map/all)</p>
<ul>
<li>
<p><code>android:autoText</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</p>
</li>
<li>
<p><code>android:bufferType</code>关联方法: <code>setText(CharSequence,TextView.BufferType)</code>属性说明: 指定<code>getText()</code>方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。</p>
</li>
<li>
<p><code>android:capitalize</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。</p>
</li>
<li>
<p><code>android:cursorVisible</code>关联方法: <code>setCursorVisible(boolean)</code>属性说明: 设定光标为显示/隐藏，默认显示。</p>
</li>
<li>
<p><code>android:digits</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\n()”</p>
</li>
<li>
<p><code>android:drawableBottom</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。</p>
</li>
<li>
<p><code>android:drawableEnd</code>关联方法: <code>setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，&quot;@[+][package:]type:name&quot;或者&quot;?[package:][type:]name&quot;；也可以是颜色值，如&quot;#rgb&quot;, &quot;#argb&quot;, &quot;#rrggbb&quot;, or &quot;#aarrggbb&quot;。</p>
</li>
<li>
<p><code>android:drawableLeft</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的左边输出一个drawable。</p>
</li>
<li>
<p><code>android:drawablePadding</code>关联方法: <code>setCompoundDrawablePadding(int)</code>属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。</p>
</li>
<li>
<p><code>android:drawableRight</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的右边输出一个drawable。</p>
</li>
<li>
<p><code>android:drawableStart</code>关联方法: <code>setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，&quot;@[+][package:]type:name&quot;或者&quot;?[package:][type:]name&quot;；也可以是颜色值，如&quot;#rgb&quot;, &quot;#argb&quot;, &quot;#rrggbb&quot;, or &quot;#aarrggbb&quot;。</p>
</li>
<li>
<p><code>android:drawableTop</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的正上方输出一个drawable。</p>
</li>
<li>
<p><code>android:editable</code>关联方法: 属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。</p>
</li>
<li>
<p><code>android:editorExtras</code>关联方法: <code>setInputExtras(int)</code>属性说明: 设置文本的额外的输入数据。在EditView中才有效果。</p>
</li>
<li>
<p><code>android:ellipsize</code>关联方法: <code>setEllipsize(TextUtils.TruncateAt)</code>属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动)</p>
</li>
<li>
<p><code>android:ems</code>关联方法: <code>setEms(int)</code>属性说明: 设置TextView的宽度为N个字符的宽度。</p>
</li>
<li>
<p><code>android:fontFamily</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 文本的字形体系。</p>
</li>
<li>
<p><code>android:freezesText</code>关联方法: <code>setFreezesText(boolean)</code>属性说明: 设置保存文本的内容以及光标的位置。</p>
</li>
<li>
<p><code>android:gravity</code>关联方法: <code>setGravity(int)</code>属性说明: 设置文本位置，如设置成“center”，文本将居中显示。</p>
</li>
<li>
<p><code>android:height</code>关联方法: <code>setHeight(int)</code>属性说明: 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)</p>
</li>
<li>
<p><code>android:hint</code>关联方法: <code>setHint(int)</code>属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。</p>
</li>
<li>
<p><code>android:imeActionId</code>关联方法: <code>setImeActionLabel(CharSequence,int)</code>属性说明: 设置IME动作ID。</p>
</li>
<li>
<p><code>android:imeActionLabel</code>关联方法: <code>setImeActionLabel(CharSequence,int)</code>属性说明: 设置IME动作标签。在EditView再做说明。</p>
</li>
<li>
<p><code>android:imeOptions</code>关联方法: <code>setImeOptions(int)</code>属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。</p>
</li>
<li>
<p><code>android:includeFontPadding</code>关联方法: <code>setIncludeFontPadding(boolean)</code>属性说明: 设置文本是否包含顶部和底部额外空白，默认为true。</p>
</li>
<li>
<p><code>android:inputMethod</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。</p>
</li>
<li>
<p><code>android:inputType</code>关联方法: <code>setRawInputType(int)</code>属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。</p>
</li>
<li>
<p><code>android:lineSpacingExtra</code>关联方法: <code>setLineSpacing(float,float)</code>属性说明: 设置行间距。</p>
</li>
<li>
<p><code>android:lineSpacingMultiplier</code>关联方法: <code>setLineSpacing(float,float)</code>属性说明: 设置行间距的倍数。如”1.2”</p>
</li>
<li>
<p><code>android:lines</code>关联方法: <code>setLines(int)</code>属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。</p>
</li>
<li>
<p><code>android:linksClickable</code>关联方法: <code>setLinksClickable(boolean)</code>属性说明: 设置链接是否点击连接，即使设置了autoLink。</p>
</li>
<li>
<p><code>android:marqueeRepeatLimit</code>关联方法: <code>setMarqueeRepeatLimit(int)</code>属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。</p>
</li>
<li>
<p><code>android:maxEms</code>关联方法: <code>setMaxEms(int)</code>属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。</p>
</li>
<li>
<p><code>android:maxHeight</code>关联方法: <code>setMaxHeight(int)</code>属性说明: 设置文本区域的最大高度</p>
</li>
<li>
<p><code>android:maxLength</code>关联方法: <code>setFilters(InputFilter)</code>属性说明: 限制显示的文本长度，超出部分不显示。</p>
</li>
<li>
<p><code>android:maxLines</code>关联方法: <code>setMaxLines(int)</code>属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</p>
</li>
<li>
<p><code>android:maxWidth</code>关联方法: <code>setMaxWidth(int)</code>属性说明: 设置文本区域的最大宽度</p>
</li>
<li>
<p><code>android:minEms</code>关联方法: <code>setMinEms(int)</code>属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。</p>
</li>
<li>
<p><code>android:minHeight</code>关联方法: <code>setMinHeight(int)</code>属性说明: 设置文本区域的最小高度</p>
</li>
<li>
<p><code>android:minLines</code>关联方法: <code>setMinLines(int)</code>属性说明: 设置文本的最小行数，与lines类似。</p>
</li>
<li>
<p><code>android:minWidth</code>关联方法: <code>setMinWidth(int)</code>属性说明: 设置文本区域的最小宽度</p>
</li>
<li>
<p><code>android:numeric</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。</p>
</li>
<li>
<p><code>android:password</code>关联方法: <code>setTransformationMethod(TransformationMethod)</code>属性说明: 以小点”.”显示文本</p>
</li>
<li>
<p><code>android:phoneNumber</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置为电话号码的输入方式。</p>
</li>
<li>
<p><code>android:privateImeOptions</code>关联方法: <code>setPrivateImeOptions(String)</code>属性说明: 设置输入法选项，在EditText中才有作用。</p>
</li>
<li>
<p><code>android:scrollHorizontally</code>关联方法: <code>setHorizontallyScrolling(boolean)</code>属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。</p>
</li>
<li>
<p><code>android:selectAllOnFocus</code>关联方法: <code>setSelectAllOnFocus(boolean)</code>属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。</p>
</li>
<li>
<p><code>android:shadowColor</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。</p>
</li>
<li>
<p><code>android:shadowDx</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影横向坐标开始位置。</p>
</li>
<li>
<p><code>android:shadowDy</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影纵向坐标开始位置。</p>
</li>
<li>
<p><code>android:shadowRadius</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。</p>
</li>
<li>
<p><code>android:singleLine</code>关联方法: <code>setTransformationMethod(TransformationMethod)</code>属性说明: 设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如<code>android:text=&quot;test_ singleLine&quot;</code> <code>android:singleLine=&quot;true&quot;</code> <code>android:layout_width=&quot;20dp&quot;</code>将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行</p>
</li>
<li>
<p><code>android:text</code>关联方法: <code>setText(CharSequence,TextView.BufferType)</code>属性说明: 设置显示文本.</p>
</li>
<li>
<p><code>android:textAllCaps</code>关联方法: <code>setAllCaps(boolean)</code>属性说明: 设置文本全为大写。值为&quot;true&quot;或&quot;false&quot;。</p>
</li>
<li>
<p><code>android:textAppearance</code>关联方法: 属性说明: 设置文字外观。如“?<code>android:attr/textAppearanceLargeInverse</code></p>
</li>
<li>
<p><code>android:textColor</code>关联方法: <code>setTextColor(int)</code>属性说明: 设置文本颜色</p>
</li>
<li>
<p><code>android:textColorHighlight</code>关联方法: <code>setHighlightColor(int)</code>属性说明: 被选中文字的底色，默认为蓝色</p>
</li>
<li>
<p><code>android:textColorHint</code>关联方法: <code>setHintTextColor(int)</code>属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。</p>
</li>
<li>
<p><code>android:textColorLink</code>关联方法: <code>setLinkTextColor(int)</code>属性说明: 文字链接的颜色.</p>
</li>
<li>
<p><code>android:textIsSelectable</code>关联方法: <code>isTextSelectable()</code>属性说明: 设置非编辑文本可否被选择。值为&quot;true&quot;或&quot;false&quot;。</p>
</li>
<li>
<p><code>android:textScaleX</code>关联方法: <code>setTextScaleX(float)</code>属性说明: 设置文字之间间隔，默认为1.0f。</p>
</li>
<li>
<p><code>android:textSize</code>关联方法: <code>setTextSize(int,float)</code>属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp”</p>
</li>
<li>
<p><code>android:textStyle</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开</p>
</li>
<li>
<p><code>android:typeface</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3]</p>
</li>
<li>
<p><code>android:width</code>关联方法: <code>setWidth(int)</code>属性说明: 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。</p>
</li>
</ul>
<h3><a id="other" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other</h3>
<p>由于这两天在做listView的东西，所以整理出来一些我个人认为比较特别的属性，通过设置这样的属性可以做出更加美观的列表</p>
<ul>
<li>首先是stackFromBottom属性，这只该属性之后你做好的列表就会显示你列表的最下面，值为true和false</li>
</ul>
<p><code>android:stackFromBottom=&quot;true&quot;</code></p>
<ul>
<li>
<p>第二是transciptMode属性，需要用ListView或者其它显示大量Items的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件transcriptMode属性可以将 android平台的控件（支持ScrollBar）自动滑动到最底部。 <code>android:transcriptMode=&quot;alwaysScroll&quot;</code></p>
</li>
<li>
<p>第三cacheColorHint属性，很多人希望能够改变一下它的背景，使他能够符合整体的UI设计，改变背景背很简单只需要准备一张图片然后指定属性 <code>android:background=&quot;@drawable/bg&quot;</code>，不过不要高兴地太早，当你这么做以后，发现背景是变了，但是当你拖动，或者点击list空白位置的时候发现ListItem都变成黑色的了，破坏了整体效果。</p>
</li>
</ul>
<p>如果你只是换背景的颜色的话，可以直接指定<code>android:cacheColorHint</code>为你所要的颜色，如果你是用图片做背景的话，那也只要将<code>android:cacheColorHint</code>指定为透明（#00000000）就可以了</p>
<ul>
<li>第四divider属性，该属性作用是每一项之间需要设置一个图片做为间隔，或是去掉item之间的分割线</li>
</ul>
<p><code>android:divider=&quot;@drawable/list_driver&quot;</code>  其中  @drawable/list_driver 是一个图片资源，如果不想显示分割线则只要设置为<code>android:divider=&quot;@drawable/@null&quot;</code> 就可以了</p>
<ul>
<li>第五fadingEdge属性，上边和下边有黑色的阴影</li>
</ul>
<p><code>android:fadingEdge=&quot;none&quot;</code> 设置后没有阴影了~</p>
<ul>
<li>第六scrollbars属性，作用是隐藏listView的滚动条，</li>
</ul>
<p><code>android:scrollbars=&quot;none&quot;</code>与<code>setVerticalScrollBarEnabled(true);</code>的效果是一样的，不活动的时候隐藏，活动的时候也隐藏</p>
<ul>
<li>第七fadeScrollbars属性，<code>android:fadeScrollbars=&quot;true&quot;</code>  配置ListView布局的时候，设置这个属性为true就可以实现滚动条的自动隐藏和显示。</li>
</ul>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义View的方法</h2>
<h3><a id="%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用方法</h3>
<ul>
<li><code>onFinishInflate()</code> 当View中所有的子控件均被映射成xml后触发</li>
<li><code>onMeasure(int, int)</code> 确定所有子元素的大小</li>
<li><code>onLayout(boolean, int, int, int, int)</code> 当View分配所有的子元素的大小和位置时触发</li>
<li><code>onSizeChanged(int, int, int, int)</code> 当view的大小发生变化时触发</li>
<li><code>onDraw(Canvas)</code> view渲染内容的细节</li>
<li><code>onKeyDown(int, KeyEvent)</code> 有按键按下后触发</li>
<li><code>onKeyUp(int, KeyEvent)</code> 有按键按下后弹起时触发</li>
<li><code>onTrackballEvent(MotionEvent)</code> 轨迹球事件</li>
<li><code>onTouchEvent(MotionEvent)</code> 触屏事件</li>
<li><code>onFocusChanged(boolean, int, Rect)</code> 当View获取或失去焦点时触发</li>
<li><code>onWindowFocusChanged(boolean)</code> 当窗口包含的view获取或失去焦点时触发</li>
<li><code>onAttachedToWindow()</code> 当view被附着到一个窗口时触发</li>
<li><code>onDetachedFromWindow()</code> 当view离开附着的窗口时触发，提示该方法和  onAttachedToWindow() 是相反的。</li>
<li><code>onWindowVisibilityChanged(int)</code> 当窗口中包含的可见的view发生变化时触发</li>
</ul>
<h3><a id="%E5%85%AC%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>公用方法</h3>
<ul>
<li><code>void addChildrenForAccessibility(ArrayList&lt;View&gt; outChildren)</code><br />
Adds the children of this View relevant for accessibility to the given list as output.</li>
<li><code>void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo info, String extraDataKey, Bundle arguments)</code><br />
Adds extra data to an AccessibilityNodeInfo based on an explicit request for the additional data.</li>
<li><code>void addFocusables(ArrayList&lt;View&gt; views, int direction)</code><br />
Add any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views.</li>
<li><code>void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode)</code><br />
Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views.</li>
<li><code>void addKeyboardNavigationClusters(Collection&lt;View&gt; views, int direction)</code><br />
Adds any keyboard navigation cluster roots that are descendants of this view (possibly including this view if it is a cluster root itself) to views.</li>
<li><code>void addOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)</code><br />
Add a listener for attach state changes.</li>
<li><code>void addOnLayoutChangeListener(View.OnLayoutChangeListener listener)</code><br />
Add a listener that will be called when the bounds of the view change due to layout processing.</li>
<li><code>void addTouchables(ArrayList&lt;View&gt; views)</code><br />
Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself) to views.</li>
<li><code>ViewPropertyAnimator animate()</code><br />
This method returns a ViewPropertyAnimator object, which can be used to animate specific properties on this View.</li>
<li><code>void announceForAccessibility(CharSequence text)</code><br />
Convenience method for sending a TYPE_ANNOUNCEMENT AccessibilityEvent to make an announcement which is related to some sort of a context change for which none of the events representing UI transitions is a good fit.</li>
<li><code>void autoFill(AutoFillValue value)</code><br />
Automatically fills the content of this view with the value.</li>
<li><code>void autoFillVirtual(int virtualId, AutoFillValue value)</code><br />
Automatically fills the content of a virtual view with the value<br />
See autoFill(AutoFillValue) and onProvideAutoFillVirtualStructure(ViewStructure, int) for more info.</li>
<li><code>void bringToFront()</code><br />
Change the view's z order in the tree, so it's on top of other sibling views.</li>
<li><code>void buildDrawingCache(boolean autoScale)</code><br />
Forces the drawing cache to be built if the drawing cache is invalid.</li>
<li><code>void buildDrawingCache()</code><br />
Calling this method is equivalent to calling buildDrawingCache(false).</li>
<li><code>void buildLayer()</code><br />
Forces this view's layer to be created and this view to be rendered into its layer.</li>
<li><code>boolean callOnClick()</code><br />
Directly call any attached OnClickListener.</li>
<li><code>boolean canResolveLayoutDirection()</code><br />
Check if layout direction resolution can be done.</li>
<li><code>boolean canResolveTextAlignment()</code><br />
Check if text alignment resolution can be done.</li>
<li><code>boolean canResolveTextDirection()</code><br />
Check if text direction resolution can be done.</li>
<li><code>boolean canScrollHorizontally(int direction)</code><br />
Check if this view can be scrolled horizontally in a certain direction.</li>
<li><code>boolean canScrollVertically(int direction)</code><br />
Check if this view can be scrolled vertically in a certain direction.</li>
<li><code>final void cancelDragAndDrop()</code><br />
Cancels an ongoing drag and drop operation.</li>
<li><code>void cancelLongPress()</code><br />
Cancels a pending long press.</li>
<li><code>final void cancelPendingInputEvents()</code><br />
Cancel any deferred high-level input events that were previously posted to the event queue.</li>
<li><code>boolean checkInputConnectionProxy(View view)</code><br />
Called by the InputMethodManager when a view who is not the current input connection target is trying to make a call on the manager.</li>
<li><code>void clearAnimation()</code><br />
Cancels any animations for this view.</li>
<li><code>void clearFocus()</code><br />
Called when this view wants to give up focus.<br />
static int combineMeasuredStates(int curState, int newState)<br />
Merge two states as returned by getMeasuredState().</li>
<li><code>void computeScroll()</code><br />
Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.</li>
<li><code>WindowInsets computeSystemWindowInsets(WindowInsets in, Rect outLocalInsets)</code><br />
Compute insets that should be consumed by this view and the ones that should propagate to those under it.</li>
<li><code>AccessibilityNodeInfo createAccessibilityNodeInfo()</code><br />
Returns an AccessibilityNodeInfo representing this view from the point of view of an AccessibilityService.</li>
<li><code>void createContextMenu(ContextMenu menu)</code><br />
Show the context menu for this view.</li>
<li><code>void destroyDrawingCache()</code><br />
Frees the resources used by the drawing cache.</li>
<li><code>WindowInsets dispatchApplyWindowInsets(WindowInsets insets)</code><br />
Request to apply the given window insets to this view or another view in its subtree.</li>
<li><code>boolean dispatchCapturedPointerEvent(MotionEvent event)</code><br />
Pass a captured pointer event down to the focused view.</li>
<li><code>void dispatchConfigurationChanged(Configuration newConfig)</code><br />
Dispatch a notification about a resource configuration change down the view hierarchy.</li>
<li><code>void dispatchDisplayHint(int hint)</code><br />
Dispatch a hint about whether this view is displayed.</li>
<li><code>boolean dispatchDragEvent(DragEvent event)</code><br />
Detects if this View is enabled and has a drag event listener.</li>
<li><code>void dispatchDrawableHotspotChanged(float x, float y)</code><br />
Dispatches drawableHotspotChanged to all of this View's children.</li>
<li><code>void dispatchFinishTemporaryDetach()</code><br />
Dispatch onFinishTemporaryDetach() to this View and its direct children if this is a container View.</li>
<li><code>boolean dispatchGenericMotionEvent(MotionEvent event)</code><br />
Dispatch a generic motion event.</li>
<li><code>boolean dispatchKeyEvent(KeyEvent event)</code><br />
Dispatch a key event to the next view on the focus path.</li>
<li><code>boolean dispatchKeyEventPreIme(KeyEvent event)</code><br />
Dispatch a key event before it is processed by any input method associated with the view hierarchy.</li>
<li><code>boolean dispatchKeyShortcutEvent(KeyEvent event)</code><br />
Dispatches a key shortcut event.</li>
<li><code>boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed)</code><br />
Dispatch a fling to a nested scrolling parent.</li>
<li><code>boolean dispatchNestedPreFling(float velocityX, float velocityY)</code><br />
Dispatch a fling to a nested scrolling parent before it is processed by this view.</li>
<li><code>boolean dispatchNestedPrePerformAccessibilityAction(int action, Bundle arguments)</code><br />
Report an accessibility action to this view's parents for delegated processing.</li>
<li><code>boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)</code><br />
Dispatch one step of a nested scroll in progress before this view consumes any portion of it.</li>
<li><code>boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)</code><br />
Dispatch one step of a nested scroll in progress.</li>
<li><code>void dispatchPointerCaptureChanged(boolean hasCapture)</code></li>
<li><code>boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event)</code><br />
Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.</li>
<li><code>void dispatchProvideAutoFillStructure(ViewStructure structure, int flags)</code><br />
Dispatch creation of ViewStructure down the hierarchy.</li>
<li><code>void dispatchProvideStructure(ViewStructure structure)</code><br />
Dispatch creation of ViewStructure down the hierarchy.</li>
<li><code>void dispatchStartTemporaryDetach()</code><br />
Dispatch onStartTemporaryDetach() to this View and its direct children if this is a container View.</li>
<li><code>void dispatchSystemUiVisibilityChanged(int visibility)</code><br />
Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener) down the view hierarchy.</li>
<li><code>boolean dispatchTouchEvent(MotionEvent event)</code><br />
Pass the touch screen motion event down to the target view, or this view if it is the target.</li>
<li><code>boolean dispatchTrackballEvent(MotionEvent event)</code><br />
Pass a trackball motion event down to the focused view.<br />
boolean dispatchUnhandledMove(View focused, int direction)<br />
This method is the last chance for the focused view and its ancestors to respond to an arrow key.</li>
<li><code>void dispatchWindowFocusChanged(boolean hasFocus)</code><br />
Called when the window containing this view gains or loses window focus.</li>
<li><code>void dispatchWindowSystemUiVisiblityChanged(int visible)</code><br />
Dispatch callbacks to onWindowSystemUiVisibilityChanged(int) down the view hierarchy.</li>
<li><code>void dispatchWindowVisibilityChanged(int visibility)</code><br />
Dispatch a window visibility change down the view hierarchy.</li>
<li><code>void draw(Canvas canvas)</code><br />
Manually render this view (and all of its children) to the given Canvas.</li>
<li><code>void drawableHotspotChanged(float x, float y)</code><br />
This function is called whenever the view hotspot changes and needs to be propagated to drawables or child views managed by the view.</li>
<li><code>View findFocus()</code><br />
Find the view in the hierarchy rooted at this view that currently has focus.</li>
<li><code>final &lt;T extends View&gt; T findViewById(int id)</code><br />
Look for a child view with the given id.</li>
<li><code>final &lt;T extends View&gt; T findViewWithTag(Object tag)</code><br />
Look for a child view with the given tag.</li>
<li><code>void findViewsWithText(ArrayList&lt;View&gt; outViews, CharSequence searched, int flags)</code><br />
Finds the Views that contain given text.</li>
<li><code>View focusSearch(int direction)</code><br />
Find the nearest view in the specified direction that can take focus.</li>
<li><code>void forceHasOverlappingRendering(boolean hasOverlappingRendering)</code><br />
Sets the behavior for overlapping rendering for this view (see hasOverlappingRendering() for more details on this behavior).</li>
<li><code>void forceLayout()</code><br />
Forces this view to be laid out during the next layout pass.</li>
<li><code>static int generateViewId()</code><br />
Generate a value suitable for use in setId(int).</li>
<li><code>CharSequence getAccessibilityClassName()</code><br />
Return the class name of this object to be used for accessibility purposes.</li>
<li><code>int getAccessibilityLiveRegion()</code><br />
Gets the live region mode for this View.</li>
<li><code>AccessibilityNodeProvider getAccessibilityNodeProvider()</code><br />
Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content.</li>
<li><code>int getAccessibilityTraversalAfter()</code><br />
Gets the id of a view after which this one is visited in accessibility traversal.</li>
<li><code>int getAccessibilityTraversalBefore()</code><br />
Gets the id of a view before which this one is visited in accessibility traversal.</li>
<li><code>float getAlpha()</code><br />
The opacity of the view.</li>
<li><code>Animation getAnimation()</code><br />
Get the animation currently associated with this view.</li>
<li><code>IBinder getApplicationWindowToken()</code><br />
Retrieve a unique token identifying the top-level &quot;real&quot; window of the window that this view is attached to.</li>
<li><code>int getAutoFillMode()</code><br />
Returns the auto-fill mode for this view.</li>
<li><code>AutoFillType getAutoFillType()</code><br />
Describes the auto-fill type that should be used on calls to autoFill(AutoFillValue) and autoFillVirtual(int, AutoFillValue).</li>
<li><code>AutoFillValue getAutoFillValue()</code><br />
Gets the View's current auto-fill value.</li>
<li><code>Drawable getBackground()</code><br />
Gets the background drawable</li>
<li><code>ColorStateList getBackgroundTintList()</code><br />
Return the tint applied to the background drawable, if specified.</li>
<li><code>PorterDuff.Mode getBackgroundTintMode()</code><br />
Return the blending mode used to apply the tint to the background drawable, if specified.</li>
<li><code>int getBaseline()</code><br />
Return the offset of the widget's text baseline from the widget's top boundary.</li>
<li><code>final int getBottom()</code><br />
Bottom position of this view relative to its parent.</li>
<li><code>float getCameraDistance()</code><br />
Gets the distance along the Z axis from the camera to this view.</li>
<li><code>boolean getClipBounds(Rect outRect)</code><br />
Populates an output rectangle with the clip bounds of the view, returning true if successful or false if the view's clip bounds are null.</li>
<li><code>Rect getClipBounds()</code><br />
Returns a copy of the current clipBounds.</li>
<li><code>final boolean getClipToOutline()</code><br />
Returns whether the Outline should be used to clip the contents of the View.</li>
<li><code>CharSequence getContentDescription()</code><br />
Returns the View's content description.</li>
<li><code>final Context getContext()</code><br />
Returns the context the view is running in, through which it can access the current theme, resources, etc.</li>
<li><code>static int getDefaultSize(int size, int measureSpec)</code><br />
Utility to return a default size.</li>
<li><code>Display getDisplay()</code><br />
Gets the logical display to which the view's window has been attached.</li>
<li><code>final int[] getDrawableState()</code><br />
Return an array of resource IDs of the drawable states representing the current state of the view.</li>
<li><code>Bitmap getDrawingCache()</code><br />
Calling this method is equivalent to calling getDrawingCache(false).</li>
<li><code>Bitmap getDrawingCache(boolean autoScale)</code><br />
Returns the bitmap in which this view drawing is cached.</li>
<li><code>int getDrawingCacheBackgroundColor()</code></li>
<li><code>int getDrawingCacheQuality()</code><br />
Returns the quality of the drawing cache.</li>
<li><code>void getDrawingRect(Rect outRect)</code><br />
Return the visible drawing bounds of your view.</li>
<li><code>long getDrawingTime()</code><br />
Return the time at which the drawing of the view hierarchy started.</li>
<li><code>float getElevation()</code><br />
The base elevation of this view relative to its parent, in pixels.</li>
<li><code>boolean getFilterTouchesWhenObscured()</code><br />
Gets whether the framework should discard touches when the view's window is obscured by another visible window.</li>
<li><code>boolean getFitsSystemWindows()</code><br />
Check for state of setFitsSystemWindows(boolean).</li>
<li><code>int getFocusable()</code><br />
Returns the focusable setting for this view.</li>
<li><code>ArrayList&lt;View&gt; getFocusables(int direction)</code><br />
Find and return all focusable views that are descendants of this view, possibly including this view if it is focusable itself.</li>
<li><code>void getFocusedRect(Rect r)</code><br />
When a view has focus and the user navigates away from it, the next view is searched for starting from the rectangle filled in by this method.</li>
<li><code>Drawable getForeground()</code><br />
Returns the drawable used as the foreground of this View.</li>
<li><code>int getForegroundGravity()</code><br />
Describes how the foreground is positioned.</li>
<li><code>ColorStateList getForegroundTintList()</code><br />
Return the tint applied to the foreground drawable, if specified.</li>
<li><code>PorterDuff.Mode getForegroundTintMode()</code><br />
Return the blending mode used to apply the tint to the foreground drawable, if specified.</li>
<li><code>final boolean getGlobalVisibleRect(Rect r)</code></li>
<li><code>boolean getGlobalVisibleRect(Rect r, Point globalOffset)</code><br />
If some part of this view is not clipped by any of its parents, then return that area in r in global (root) coordinates.</li>
<li><code>Handler getHandler()</code></li>
<li><code>final boolean getHasOverlappingRendering()</code><br />
Returns the value for overlapping rendering that is used internally.</li>
<li><code>final int getHeight()</code><br />
Return the height of your view.</li>
<li><code>void getHitRect(Rect outRect)</code><br />
Hit rectangle in parent's coordinates</li>
<li><code>int getHorizontalFadingEdgeLength()</code><br />
Returns the size of the horizontal faded edges used to indicate that more content in this view is visible.</li>
<li><code>int getId()</code><br />
Returns this view's identifier.<br />
int getImportantForAccessibility()<br />
Gets the mode for determining whether this View is important for accessibility.</li>
<li><code>boolean getKeepScreenOn()</code><br />
Returns whether the screen should remain on, corresponding to the current value of KEEP_SCREEN_ON.</li>
<li><code>KeyEvent.DispatcherState getKeyDispatcherState()</code><br />
Return the global KeyEvent.DispatcherState for this view's window.</li>
<li><code>int getLabelFor()</code><br />
Gets the id of a view for which this view serves as a label for accessibility purposes.</li>
<li><code>int getLayerType()</code><br />
Indicates what type of layer is currently associated with this view.</li>
<li><code>int getLayoutDirection()</code><br />
Returns the resolved layout direction for this view.</li>
<li><code>ViewGroup.LayoutParams getLayoutParams()</code><br />
Get the LayoutParams associated with this view.</li>
<li><code>final int getLeft()</code><br />
Left position of this view relative to its parent.</li>
<li><code>final boolean getLocalVisibleRect(Rect r)</code></li>
<li><code>void getLocationInWindow(int[] outLocation)</code><br />
Computes the coordinates of this view in its window.</li>
<li><code>void getLocationOnScreen(int[] outLocation)</code><br />
Computes the coordinates of this view on the screen.</li>
<li><code>Matrix getMatrix()</code><br />
The transform matrix of this view, which is calculated based on the current rotation, scale, and pivot properties.</li>
<li><code>final int getMeasuredHeight()</code><br />
Like getMeasuredHeightAndState(), but only returns the raw height component (that is the result is masked by MEASURED_SIZE_MASK).</li>
<li><code>final int getMeasuredHeightAndState()</code><br />
Return the full height measurement information for this view as computed by the most recent call to measure(int, int).</li>
<li><code>final int getMeasuredState()</code><br />
Return only the state bits of getMeasuredWidthAndState() and getMeasuredHeightAndState(), combined into one integer.</li>
<li><code>final int getMeasuredWidth()</code><br />
Like getMeasuredWidthAndState(), but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK).</li>
<li><code>final int getMeasuredWidthAndState()</code><br />
Return the full width measurement information for this view as computed by the most recent call to measure(int, int).</li>
<li><code>int getMinimumHeight()</code><br />
Returns the minimum height of the view.</li>
<li><code>int getMinimumWidth()</code><br />
Returns the minimum width of the view.</li>
<li><code>int getNextClusterForwardId()</code><br />
Gets the id of the root of the next keyboard navigation cluster.</li>
<li><code>int getNextFocusDownId()</code><br />
Gets the id of the view to use when the next focus is FOCUS_DOWN.</li>
<li><code>int getNextFocusForwardId()</code><br />
Gets the id of the view to use when the next focus is FOCUS_FORWARD.</li>
<li><code>int getNextFocusLeftId()</code><br />
Gets the id of the view to use when the next focus is FOCUS_LEFT.</li>
<li><code>int getNextFocusRightId()</code><br />
Gets the id of the view to use when the next focus is FOCUS_RIGHT.</li>
<li><code>int getNextFocusUpId()</code><br />
Gets the id of the view to use when the next focus is FOCUS_UP.<br />
View.OnFocusChangeListener getOnFocusChangeListener()<br />
Returns the focus-change callback registered for this view.</li>
<li><code>ViewOutlineProvider getOutlineProvider()</code><br />
Returns the current ViewOutlineProvider of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping.</li>
<li><code>int getOverScrollMode()</code><br />
Returns the over-scroll mode for this view.</li>
<li><code>ViewOverlay getOverlay()</code><br />
Returns the overlay for this view, creating it if it does not yet exist.</li>
<li><code>int getPaddingBottom()</code><br />
Returns the bottom padding of this view.</li>
<li><code>int getPaddingEnd()</code><br />
Returns the end padding of this view depending on its resolved layout direction.</li>
<li><code>int getPaddingLeft()</code><br />
Returns the left padding of this view.</li>
<li><code>int getPaddingRight()</code><br />
Returns the right padding of this view.</li>
<li><code>int getPaddingStart()</code><br />
Returns the start padding of this view depending on its resolved layout direction.</li>
<li><code>int getPaddingTop()</code><br />
Returns the top padding of this view.</li>
<li><code>final ViewParent getParent()</code><br />
Gets the parent of this view.</li>
<li><code>ViewParent getParentForAccessibility()</code><br />
Gets the parent for accessibility purposes.</li>
<li><code>float getPivotX()</code><br />
The x location of the point around which the view is rotated and scaled.</li>
<li><code>float getPivotY()</code><br />
The y location of the point around which the view is rotated and scaled.</li>
<li><code>PointerIcon getPointerIcon()</code><br />
Gets the pointer icon for the current view.</li>
<li><code>Resources getResources()</code><br />
Returns the resources associated with this view.</li>
<li><code>final boolean getRevealOnFocusHint()</code><br />
Returns this view's preference for reveal behavior when it gains focus.</li>
<li><code>final int getRight()</code><br />
Right position of this view relative to its parent.</li>
<li><code>View getRootView()</code><br />
Finds the topmost view in the current view hierarchy.</li>
<li><code>WindowInsets getRootWindowInsets()</code><br />
Provide original WindowInsets that are dispatched to the view hierarchy.</li>
<li><code>float getRotation()</code><br />
The degrees that the view is rotated around the pivot point.</li>
<li><code>float getRotationX()</code><br />
The degrees that the view is rotated around the horizontal axis through the pivot point.</li>
<li><code>float getRotationY()</code><br />
The degrees that the view is rotated around the vertical axis through the pivot point.</li>
<li><code>float getScaleX()</code><br />
The amount that the view is scaled in x around the pivot point, as a proportion of the view's unscaled width.</li>
<li><code>float getScaleY()</code><br />
The amount that the view is scaled in y around the pivot point, as a proportion of the view's unscaled height.</li>
<li><code>int getScrollBarDefaultDelayBeforeFade()</code><br />
Returns the delay before scrollbars fade.</li>
<li><code>int getScrollBarFadeDuration()</code><br />
Returns the scrollbar fade duration.</li>
<li><code>int getScrollBarSize()</code><br />
Returns the scrollbar size.</li>
<li><code>int getScrollBarStyle()</code><br />
Returns the current scrollbar style.</li>
<li><code>int getScrollIndicators()</code><br />
Returns a bitmask representing the enabled scroll indicators.</li>
<li><code>final int getScrollX()</code><br />
Return the scrolled left position of this view.</li>
<li><code>final int getScrollY()</code><br />
Return the scrolled top position of this view.</li>
<li><code>int getSolidColor()</code><br />
Override this if your view is known to always be drawn on top of a solid color background, and needs to draw fading edges.<br />
StateListAnimator getStateListAnimator()<br />
Returns the current StateListAnimator if exists.</li>
<li><code>int getSystemUiVisibility()</code><br />
Returns the last setSystemUiVisibility(int) that this view has requested.</li>
<li><code>Object getTag()</code><br />
Returns this view's tag.</li>
<li><code>Object getTag(int key)</code><br />
Returns the tag associated with this view and the specified key.</li>
<li><code>int getTextAlignment()</code><br />
Return the resolved text alignment.</li>
<li><code>int getTextDirection()</code><br />
Return the resolved text direction.</li>
<li><code>CharSequence getTooltipText()</code><br />
Returns the view's tooltip text.</li>
<li><code>final int getTop()</code><br />
Top position of this view relative to its parent.</li>
<li><code>TouchDelegate getTouchDelegate()</code><br />
Gets the TouchDelegate for this View.</li>
<li><code>ArrayList&lt;View&gt; getTouchables()</code><br />
Find and return all touchable views that are descendants of this view, possibly including this view if it is touchable itself.</li>
<li><code>String getTransitionName()</code><br />
Returns the name of the View to be used to identify Views in Transitions.</li>
<li><code>float getTranslationX()</code><br />
The horizontal location of this view relative to its left position.</li>
<li><code>float getTranslationY()</code><br />
The vertical location of this view relative to its top position.</li>
<li><code>float getTranslationZ()</code><br />
The depth location of this view relative to its elevation.</li>
<li><code>int getVerticalFadingEdgeLength()</code><br />
Returns the size of the vertical faded edges used to indicate that more content in this view is visible.</li>
<li><code>int getVerticalScrollbarPosition()</code></li>
<li><code>int getVerticalScrollbarWidth()</code><br />
Returns the width of the vertical scrollbar.</li>
<li><code>ViewTreeObserver getViewTreeObserver()</code><br />
Returns the ViewTreeObserver for this view's hierarchy.</li>
<li><code>int getVisibility()</code><br />
Returns the visibility status for this view.</li>
<li><code>final int getWidth()</code><br />
Return the width of the your view.</li>
<li><code>WindowId getWindowId()</code><br />
Retrieve the WindowId for the window this view is currently attached to.</li>
<li><code>int getWindowSystemUiVisibility()</code><br />
Returns the current system UI visibility that is currently set for the entire window.</li>
<li><code>IBinder getWindowToken()</code><br />
Retrieve a unique token identifying the window this view is attached to.</li>
<li><code>int getWindowVisibility()</code><br />
Returns the current visibility of the window this view is attached to (either GONE, INVISIBLE, or VISIBLE).</li>
<li><code>void getWindowVisibleDisplayFrame(Rect outRect)</code><br />
Retrieve the overall visible display size in which the window this view is attached to has been positioned in.</li>
<li><code>float getX()</code><br />
The visual x position of this view, in pixels.</li>
<li><code>float getY()</code><br />
The visual y position of this view, in pixels.</li>
<li><code>float getZ()</code><br />
The visual z position of this view, in pixels.</li>
<li><code>boolean hasExplicitFocusable()</code><br />
Returns true if this view is focusable or if it contains a reachable View for which hasExplicitFocusable() returns true.</li>
<li><code>boolean hasFocus()</code><br />
Returns true if this view has focus itself, or is the ancestor of the view that has focus.</li>
<li><code>boolean hasFocusable()</code><br />
Returns true if this view is focusable or if it contains a reachable View for which hasFocusable() returns true.</li>
<li><code>boolean hasNestedScrollingParent()</code><br />
Returns true if this view has a nested scrolling parent.</li>
<li><code>boolean hasOnClickListeners()</code><br />
Return whether this view has an attached OnClickListener.</li>
<li><code>boolean hasOverlappingRendering()</code><br />
Returns whether this View has content which overlaps.</li>
<li><code>boolean hasPointerCapture()</code><br />
Checks pointer capture status.</li>
<li><code>boolean hasTransientState()</code><br />
Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible.</li>
<li><code>boolean hasWindowFocus()</code><br />
Returns true if this view is in a window that currently has window focus.</li>
<li><code>static View inflate(Context context, int resource, ViewGroup root)</code><br />
Inflate a view from an XML resource.</li>
<li><code>void invalidate()</code><br />
Invalidate the whole view.</li>
<li><code>void invalidate(Rect dirty)</code><br />
Mark the area defined by dirty as needing to be drawn.</li>
<li><code>void invalidate(int l, int t, int r, int b)</code><br />
Mark the area defined by the rect (l,t,r,b) as needing to be drawn.</li>
<li><code>void invalidateDrawable(Drawable drawable)</code><br />
Invalidates the specified Drawable.</li>
<li><code>void invalidateOutline()</code><br />
Called to rebuild this View's Outline from its outline provider</li>
<li><code>boolean isAccessibilityFocused()</code><br />
Returns whether this View is accessibility focused.</li>
<li><code>boolean isActivated()</code><br />
Indicates the activation state of this view.</li>
<li><code>boolean isAttachedToWindow()</code><br />
Returns true if this view is currently attached to a window.</li>
<li><code>boolean isClickable()</code><br />
Indicates whether this view reacts to click events or not.</li>
<li><code>boolean isContextClickable()</code><br />
Indicates whether this view reacts to context clicks or not.</li>
<li><code>boolean isDirty()</code><br />
True if this view has changed since the last time being drawn.</li>
<li><code>boolean isDrawingCacheEnabled()</code><br />
Indicates whether the drawing cache is enabled for this view.</li>
<li><code>boolean isDuplicateParentStateEnabled()</code><br />
Indicates whether this duplicates its drawable state from its parent.</li>
<li><code>boolean isEnabled()</code><br />
Returns the enabled status for this view.</li>
<li><code>final boolean isFocusable()</code><br />
Returns whether this View is currently able to take focus.</li>
<li><code>final boolean isFocusableInTouchMode()</code><br />
When a view is focusable, it may not want to take focus when in touch mode.</li>
<li><code>boolean isFocused()</code><br />
Returns true if this view has focus</li>
<li><code>final boolean isFocusedByDefault()</code><br />
Returns whether this View should receive focus when the focus is restored for the view hierarchy containing this view.</li>
<li><code>boolean isHapticFeedbackEnabled()</code></li>
<li><code>boolean isHardwareAccelerated()</code><br />
Indicates whether this view is attached to a hardware accelerated window or not.</li>
<li><code>boolean isHorizontalFadingEdgeEnabled()</code><br />
Indicate whether the horizontal edges are faded when the view is scrolled horizontally.</li>
<li><code>boolean isHorizontalScrollBarEnabled()</code><br />
Indicate whether the horizontal scrollbar should be drawn or not.</li>
<li><code>boolean isHovered()</code><br />
Returns true if the view is currently hovered.</li>
<li><code>boolean isImportantForAccessibility()</code><br />
Computes whether this view should be exposed for accessibility.</li>
<li><code>boolean isInEditMode()</code><br />
Indicates whether this View is currently in edit mode.</li>
<li><code>boolean isInLayout()</code><br />
Returns whether the view hierarchy is currently undergoing a layout pass.</li>
<li><code>boolean isInTouchMode()</code><br />
Returns whether the device is currently in touch mode.</li>
<li><code>final boolean isKeyboardNavigationCluster()</code><br />
Returns whether this View is a root of a keyboard navigation cluster.</li>
<li><code>boolean isLaidOut()</code><br />
Returns true if this view has been through at least one layout since it was last attached to or detached from a window.</li>
<li><code>boolean isLayoutDirectionResolved()</code></li>
<li><code>boolean isLayoutRequested()</code><br />
Indicates whether or not this view's layout will be requested during the next hierarchy layout pass.</li>
<li><code>boolean isLongClickable()</code><br />
Indicates whether this view reacts to long click events or not.</li>
<li><code>boolean isNestedScrollingEnabled()</code><br />
Returns true if nested scrolling is enabled for this view.</li>
<li><code>boolean isOpaque()</code><br />
Indicates whether this View is opaque.</li>
<li><code>boolean isPaddingRelative()</code><br />
Return if the padding has been set through relative values setPaddingRelative(int, int, int, int) or through</li>
<li><code>boolean isPressed()</code><br />
Indicates whether the view is currently in pressed state.</li>
<li><code>boolean isSaveEnabled()</code><br />
Indicates whether this view will save its state (that is, whether its onSaveInstanceState() method will be called).</li>
<li><code>boolean isSaveFromParentEnabled()</code><br />
Indicates whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent.</li>
<li><code>boolean isScrollContainer()</code><br />
Indicates whether this view is one of the set of scrollable containers in its window.</li>
<li><code>boolean isScrollbarFadingEnabled()</code><br />
Returns true if scrollbars will fade when this view is not scrolling</li>
<li><code>boolean isSelected()</code><br />
Indicates the selection state of this view.</li>
<li><code>boolean isShown()</code><br />
Returns the visibility of this view and all of its ancestors</li>
<li><code>boolean isSoundEffectsEnabled()</code></li>
<li><code>final boolean isTemporarilyDetached()</code><br />
Tells whether the View is in the state between onStartTemporaryDetach() and onFinishTemporaryDetach().</li>
<li><code>boolean isTextAlignmentResolved()</code></li>
<li><code>boolean isTextDirectionResolved()</code></li>
<li><code>boolean isVerticalFadingEdgeEnabled()</code><br />
Indicate whether the vertical edges are faded when the view is scrolled horizontally.</li>
<li><code>boolean isVerticalScrollBarEnabled()</code><br />
Indicate whether the vertical scrollbar should be drawn or not.</li>
<li><code>void jumpDrawablesToCurrentState()</code><br />
Call Drawable.jumpToCurrentState() on all Drawable objects associated with this view.</li>
<li><code>View keyboardNavigationClusterSearch(View currentCluster, int direction)</code><br />
Find the nearest keyboard navigation cluster in the specified direction.</li>
<li><code>void layout(int l, int t, int r, int b)</code><br />
Assign a size and position to a view and all of its descendants<br />
This is the second phase of the layout mechanism.</li>
<li><code>final void measure(int widthMeasureSpec, int heightMeasureSpec)</code><br />
This is called to find out how big a view should be.</li>
<li><code>void offsetLeftAndRight(int offset)</code><br />
Offset this view's horizontal location by the specified amount of pixels.</li>
<li><code>void offsetTopAndBottom(int offset)</code><br />
Offset this view's vertical location by the specified number of pixels.</li>
<li><code>WindowInsets onApplyWindowInsets(WindowInsets insets)</code><br />
Called when the view should apply WindowInsets according to its internal policy.</li>
<li><code>void onCancelPendingInputEvents()</code><br />
Called as the result of a call to cancelPendingInputEvents() on this view or a parent view.</li>
<li><code>boolean onCapturedPointerEvent(MotionEvent event)</code><br />
Implement this method to handle captured pointer events</li>
<li><code>boolean onCheckIsTextEditor()</code><br />
Check whether the called view is a text editor, in which case it would make sense to automatically display a soft input window for it.</li>
<li><code>InputConnection onCreateInputConnection(EditorInfo outAttrs)</code><br />
Create a new InputConnection for an InputMethod to interact with the view.</li>
<li><code>boolean onDragEvent(DragEvent event)</code><br />
Handles drag events sent by the system following a call to startDragAndDrop().</li>
<li><code>void onDrawForeground(Canvas canvas)</code><br />
Draw any foreground content for this view.</li>
<li><code>boolean onFilterTouchEventForSecurity(MotionEvent event)</code><br />
Filter the touch event to apply security policies.</li>
<li><code>void onFinishTemporaryDetach()</code><br />
Called after onStartTemporaryDetach() when the container is done changing the view.</li>
<li><code>boolean onGenericMotionEvent(MotionEvent event)</code><br />
Implement this method to handle generic motion events.</li>
<li><code>void onHoverChanged(boolean hovered)</code><br />
Implement this method to handle hover state changes.</li>
<li><code>boolean onHoverEvent(MotionEvent event)</code><br />
Implement this method to handle hover events.</li>
<li><code>void onInitializeAccessibilityEvent(AccessibilityEvent event)</code><br />
Initializes an AccessibilityEvent with information about this View which is the event source.</li>
<li><code>void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info)</code><br />
Initializes an AccessibilityNodeInfo with information about this view.</li>
<li><code>boolean onKeyDown(int keyCode, KeyEvent event)</code><br />
Default implementation of KeyEvent.Callback.onKeyDown(): perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.</li>
<li><code>boolean onKeyLongPress(int keyCode, KeyEvent event)</code><br />
Default implementation of KeyEvent.Callback.onKeyLongPress(): always returns false (doesn't handle the event).</li>
<li><code>boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)</code><br />
Default implementation of KeyEvent.Callback.onKeyMultiple(): always returns false (doesn't handle the event).</li>
<li><code>boolean onKeyPreIme(int keyCode, KeyEvent event)</code><br />
Handle a key event before it is processed by any input method associated with the view hierarchy.</li>
<li><code>boolean onKeyShortcut(int keyCode, KeyEvent event)</code><br />
Called on the focused view when a key shortcut event is not handled.</li>
<li><code>boolean onKeyUp(int keyCode, KeyEvent event)</code><br />
Default implementation of KeyEvent.Callback.onKeyUp(): perform clicking of the view when KEYCODE_DPAD_CENTER, KEYCODE_ENTER or KEYCODE_SPACE is released.</li>
<li><code>void onMovedToDisplay(int displayId)</code><br />
Called by the system when the hosting activity is moved from one display to another without recreation.</li>
<li><code>void onPointerCaptureChange(boolean hasCapture)</code><br />
Called when the window has just acquired or lost pointer capture.</li>
<li><code>void onPopulateAccessibilityEvent(AccessibilityEvent event)</code><br />
Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent) giving a chance to this View to populate the accessibility event with its text content.</li>
<li><code>void onProvideAutoFillStructure(ViewStructure structure, int flags)</code><br />
Called when assist structure is being retrieved from a view as part of an auto-fill request.</li>
<li><code>void onProvideAutoFillVirtualStructure(ViewStructure structure, int flags)</code><br />
Called when assist structure is being retrieved from a view as part of an auto-fill request to generate additional virtual structure under this view.</li>
<li><code>void onProvideStructure(ViewStructure structure)</code><br />
Called when assist structure is being retrieved from a view as part of Activity.onProvideAssistData.</li>
<li><code>void onProvideVirtualStructure(ViewStructure structure)</code><br />
Called when assist structure is being retrieved from a view as part of Activity.onProvideAssistData to generate additional virtual structure under this view.</li>
<li><code>PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)</code><br />
Returns the pointer icon for the motion event, or null if it doesn't specify the icon.</li>
<li><code>void onRtlPropertiesChanged(int layoutDirection)</code><br />
Called when any RTL property (layout direction or text direction or text alignment) has been changed.</li>
<li><code>void onScreenStateChanged(int screenState)</code><br />
This method is called whenever the state of the screen this view is attached to changes.</li>
<li><code>void onStartTemporaryDetach()</code><br />
This is called when a container is going to temporarily detach a child, with ViewGroup.detachViewFromParent.</li>
<li><code>boolean onTouchEvent(MotionEvent event)</code><br />
Implement this method to handle touch screen motion events.</li>
<li><code>boolean onTrackballEvent(MotionEvent event)</code><br />
Implement this method to handle trackball motion events.</li>
<li><code>void onVisibilityAggregated(boolean isVisible)</code><br />
Called when the user-visibility of this View is potentially affected by a change to this view itself, an ancestor view or the window this view is attached to.</li>
<li><code>void onWindowFocusChanged(boolean hasWindowFocus)</code><br />
Called when the window containing this view gains or loses focus.</li>
<li><code>void onWindowSystemUiVisibilityChanged(int visible)</code><br />
Override to find out when the window's requested system UI visibility has changed, that is the value returned by getWindowSystemUiVisibility().</li>
<li><code>boolean performAccessibilityAction(int action, Bundle arguments)</code><br />
Performs the specified accessibility action on the view.</li>
<li><code>boolean performClick()</code><br />
Call this view's OnClickListener, if it is defined.</li>
<li><code>boolean performContextClick(float x, float y)</code><br />
Call this view's OnContextClickListener, if it is defined.</li>
<li><code>boolean performContextClick()</code><br />
Call this view's OnContextClickListener, if it is defined.</li>
<li><code>boolean performHapticFeedback(int feedbackConstant)</code><br />
Provide haptic feedback to the user for this view.</li>
<li><code>boolean performHapticFeedback(int feedbackConstant, int flags)</code><br />
Like performHapticFeedback(int), with additional options.</li>
<li><code>boolean performLongClick(float x, float y)</code><br />
Calls this view's OnLongClickListener, if it is defined.</li>
<li><code>boolean performLongClick()</code><br />
Calls this view's OnLongClickListener, if it is defined.</li>
<li><code>void playSoundEffect(int soundConstant)</code><br />
Play a sound effect for this view.</li>
<li><code>boolean post(Runnable action)</code><br />
Causes the Runnable to be added to the message queue.</li>
<li><code>boolean postDelayed(Runnable action, long delayMillis)</code><br />
Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses.</li>
<li><code>void postInvalidate()</code><br />
Cause an invalidate to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidate(int left, int top, int right, int bottom)</code><br />
Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom)</code><br />
Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateDelayed(long delayMilliseconds)</code><br />
Cause an invalidate to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateOnAnimation(int left, int top, int right, int bottom)</code><br />
Cause an invalidate of the specified area to happen on the next animation time step, typically the next display frame.</li>
<li><code>void postInvalidateOnAnimation()</code><br />
Cause an invalidate to happen on the next animation time step, typically the next display frame.</li>
<li><code>void postOnAnimation(Runnable action)</code><br />
Causes the Runnable to execute on the next animation time step.<br />
void postOnAnimationDelayed(Runnable action, long delayMillis)<br />
Causes the Runnable to execute on the next animation time step, after the specified amount of time elapses.</li>
<li><code>void refreshDrawableState()</code><br />
Call this to force a view to update its drawable state.</li>
<li><code>void releasePointerCapture()</code><br />
Releases the pointer capture.</li>
<li><code>boolean removeCallbacks(Runnable action)</code><br />
Removes the specified Runnable from the message queue.</li>
<li><code>void removeOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)</code><br />
Remove a listener for attach state changes.</li>
<li><code>void removeOnLayoutChangeListener(View.OnLayoutChangeListener listener)</code><br />
Remove a listener for layout changes.</li>
<li><code>void requestApplyInsets()</code><br />
Ask that a new dispatch of onApplyWindowInsets(WindowInsets) be performed.</li>
<li><code>void requestFitSystemWindows()</code><br />
This method was deprecated in API level 20. Use requestApplyInsets() for newer platform versions.</li>
<li><code>final boolean requestFocus(int direction)</code><br />
Call this to try to give focus to a specific view or to one of its descendants and give it a hint about what direction focus is heading.</li>
<li><code>final boolean requestFocus()</code><br />
Call this to try to give focus to a specific view or to one of its descendants.</li>
<li><code>boolean requestFocus(int direction, Rect previouslyFocusedRect)</code><br />
Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from.</li>
<li><code>final boolean requestFocusFromTouch()</code><br />
Call this to try to give focus to a specific view or to one of its descendants.</li>
<li><code>void requestLayout()</code><br />
Call this when something has changed which has invalidated the layout of this view.</li>
<li><code>void requestPointerCapture()</code><br />
Requests pointer capture mode.</li>
<li><code>boolean requestRectangleOnScreen(Rect rectangle)</code><br />
Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough.</li>
<li><code>boolean requestRectangleOnScreen(Rect rectangle, boolean immediate)</code><br />
Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough.</li>
<li><code>final void requestUnbufferedDispatch(MotionEvent event)</code><br />
Request unbuffered dispatch of the given stream of MotionEvents to this View.</li>
<li><code>static int resolveSize(int size, int measureSpec)</code><br />
Version of resolveSizeAndState(int, int, int) returning only the MEASURED_SIZE_MASK bits of the result.</li>
<li><code>static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState)</code><br />
Utility to reconcile a desired size and state, with constraints imposed by a MeasureSpec.</li>
<li><code>boolean restoreDefaultFocus()</code><br />
Gives focus to the default-focus view in the view hierarchy that has this view as a root.</li>
<li><code>void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container)</code><br />
Restore this view hierarchy's frozen state from the given container.</li>
<li><code>void saveHierarchyState(SparseArray&lt;Parcelable&gt; container)</code><br />
Store this view hierarchy's frozen state into the given container.</li>
<li><code>void scheduleDrawable(Drawable who, Runnable what, long when)</code><br />
Schedules an action on a drawable to occur at a specified time.</li>
<li><code>void scrollBy(int x, int y)</code><br />
Move the scrolled position of your view.</li>
<li><code>void scrollTo(int x, int y)</code><br />
Set the scrolled position of your view.</li>
<li><code>void sendAccessibilityEvent(int eventType)</code><br />
Sends an accessibility event of the given type.</li>
<li><code>void sendAccessibilityEventUnchecked(AccessibilityEvent event)</code><br />
This method behaves exactly as sendAccessibilityEvent(int) but takes as an argument an empty AccessibilityEvent and does not perform a check whether accessibility is enabled.</li>
<li><code>void setAccessibilityDelegate(View.AccessibilityDelegate delegate)</code><br />
Sets a delegate for implementing accessibility support via composition (as opposed to inheritance).</li>
<li><code>void setAccessibilityLiveRegion(int mode)</code><br />
Sets the live region mode for this view.</li>
<li><code>void setAccessibilityTraversalAfter(int afterId)</code><br />
Sets the id of a view after which this one is visited in accessibility traversal.</li>
<li><code>void setAccessibilityTraversalBefore(int beforeId)</code><br />
Sets the id of a view before which this one is visited in accessibility traversal.</li>
<li><code>void setActivated(boolean activated)</code><br />
Changes the activated state of this view.</li>
<li><code>void setAlpha(float alpha)</code><br />
Sets the opacity of the view to a value from 0 to 1, where 0 means the view is completely transparent and 1 means the view is completely opaque.</li>
<li><code>void setAnimation(Animation animation)</code><br />
Sets the next animation to play for this view.</li>
<li><code>void setAutoFillMode(int autoFillMode)</code><br />
Set auto-fill mode for the view.</li>
<li><code>void setBackground(Drawable background)</code><br />
Set the background to a given Drawable, or remove the background.</li>
<li><code>void setBackgroundColor(int color)</code><br />
Sets the background color for this view.</li>
<li><code>void setBackgroundDrawable(Drawable background)</code><br />
This method was deprecated in API level 16. use setBackground(Drawable) instead</li>
<li><code>void setBackgroundResource(int resid)</code><br />
Set the background to a given resource.</li>
<li><code>void setBackgroundTintList(ColorStateList tint)</code><br />
Applies a tint to the background drawable.</li>
<li><code>void setBackgroundTintMode(PorterDuff.Mode tintMode)</code><br />
Specifies the blending mode used to apply the tint specified by setBackgroundTintList(ColorStateList)} to the background drawable.</li>
<li><code>final void setBottom(int bottom)</code><br />
Sets the bottom position of this view relative to its parent.</li>
<li><code>void setCameraDistance(float distance)</code><br />
Sets the distance along the Z axis (orthogonal to the X/Y plane on which views are drawn) from the camera to this view.</li>
<li><code>void setClickable(boolean clickable)</code><br />
Enables or disables click events for this view.</li>
<li><code>void setClipBounds(Rect clipBounds)</code><br />
Sets a rectangular area on this view to which the view will be clipped when it is drawn.</li>
<li><code>void setClipToOutline(boolean clipToOutline)</code><br />
Sets whether the View's Outline should be used to clip the contents of the View.</li>
<li><code>void setContentDescription(CharSequence contentDescription)</code><br />
Sets the View's content description.</li>
<li><code>void setContextClickable(boolean contextClickable)</code><br />
Enables or disables context clicking for this view.</li>
<li><code>void setDrawingCacheBackgroundColor(int color)</code><br />
Setting a solid background color for the drawing cache's bitmaps will improve performance and memory usage.</li>
<li><code>void setDrawingCacheEnabled(boolean enabled)</code><br />
Enables or disables the drawing cache.</li>
<li><code>void setDrawingCacheQuality(int quality)</code><br />
Set the drawing cache quality of this view.</li>
<li><code>void setDuplicateParentStateEnabled(boolean enabled)</code><br />
Enables or disables the duplication of the parent's state into this view.</li>
<li><code>void setElevation(float elevation)</code><br />
Sets the base elevation of this view, in pixels.</li>
<li><code>void setEnabled(boolean enabled)</code><br />
Set the enabled state of this view.</li>
<li><code>void setFadingEdgeLength(int length)</code><br />
Set the size of the faded edge used to indicate that more content in this view is available.</li>
<li><code>void setFilterTouchesWhenObscured(boolean enabled)</code><br />
Sets whether the framework should discard touches when the view's window is obscured by another visible window.</li>
<li><code>void setFitsSystemWindows(boolean fitSystemWindows)</code><br />
Sets whether or not this view should account for system screen decorations such as the status bar and inset its content; that is, controlling whether the default implementation of fitSystemWindows(Rect) will be executed.</li>
<li><code>void setFocusable(boolean focusable)</code><br />
Set whether this view can receive the focus.</li>
<li><code>void setFocusable(int focusable)</code><br />
Sets whether this view can receive focus.</li>
<li><code>void setFocusableInTouchMode(boolean focusableInTouchMode)</code><br />
Set whether this view can receive focus while in touch mode.</li>
<li><code>void setFocusedByDefault(boolean isFocusedByDefault)</code><br />
Sets whether this View should receive focus when the focus is restored for the view hierarchy containing this view.</li>
<li><code>void setForeground(Drawable foreground)</code><br />
Supply a Drawable that is to be rendered on top of all of the content in the view.</li>
<li><code>void setForegroundGravity(int gravity)</code><br />
Describes how the foreground is positioned.</li>
<li><code>void setForegroundTintList(ColorStateList tint)</code><br />
Applies a tint to the foreground drawable.</li>
<li><code>void setForegroundTintMode(PorterDuff.Mode tintMode)</code><br />
Specifies the blending mode used to apply the tint specified by setForegroundTintList(ColorStateList)} to the background drawable.</li>
<li><code>void setHapticFeedbackEnabled(boolean hapticFeedbackEnabled)</code><br />
Set whether this view should have haptic feedback for events such as long presses.</li>
<li><code>void setHasTransientState(boolean hasTransientState)</code><br />
Set whether this view is currently tracking transient state that the framework should attempt to preserve when possible.</li>
<li><code>void setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled)</code><br />
Define whether the horizontal edges should be faded when this view is scrolled horizontally.</li>
<li><code>void setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled)</code><br />
Define whether the horizontal scrollbar should be drawn or not.</li>
<li><code>void setHovered(boolean hovered)</code><br />
Sets whether the view is currently hovered.</li>
<li><code>void setId(int id)</code><br />
Sets the identifier for this view.</li>
<li><code>void setImportantForAccessibility(int mode)</code><br />
Sets how to determine whether this view is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen.</li>
<li><code>void setKeepScreenOn(boolean keepScreenOn)</code><br />
Controls whether the screen should remain on, modifying the value of KEEP_SCREEN_ON.</li>
<li><code>void setKeyboardNavigationCluster(boolean isCluster)</code><br />
Set whether this view is a root of a keyboard navigation cluster.</li>
<li><code>void setLabelFor(int id)</code><br />
Sets the id of a view for which this view serves as a label for accessibility purposes.</li>
<li><code>void setLayerPaint(Paint paint)</code><br />
Updates the Paint object used with the current layer (used only if the current layer type is not set to LAYER_TYPE_NONE).</li>
<li><code>void setLayerType(int layerType, Paint paint)</code><br />
Specifies the type of layer backing this view.</li>
<li><code>void setLayoutDirection(int layoutDirection)</code><br />
Set the layout direction for this view.</li>
<li><code>void setLayoutParams(ViewGroup.LayoutParams params)</code><br />
Set the layout parameters associated with this view.</li>
<li><code>final void setLeft(int left)</code><br />
Sets the left position of this view relative to its parent.</li>
<li><code>void setLongClickable(boolean longClickable)</code><br />
Enables or disables long click events for this view.</li>
<li><code>void setMinimumHeight(int minHeight)</code><br />
Sets the minimum height of the view.</li>
<li><code>void setMinimumWidth(int minWidth)</code><br />
Sets the minimum width of the view.</li>
<li><code>void setNestedScrollingEnabled(boolean enabled)</code><br />
Enable or disable nested scrolling for this view.</li>
<li><code>void setNextClusterForwardId(int nextClusterForwardId)</code><br />
Sets the id of the view to use as the root of the next keyboard navigation cluster.</li>
<li><code>void setNextFocusDownId(int nextFocusDownId)</code><br />
Sets the id of the view to use when the next focus is FOCUS_DOWN.</li>
<li><code>void setNextFocusForwardId(int nextFocusForwardId)</code><br />
Sets the id of the view to use when the next focus is FOCUS_FORWARD.</li>
<li><code>void setNextFocusLeftId(int nextFocusLeftId)</code><br />
Sets the id of the view to use when the next focus is FOCUS_LEFT.</li>
<li><code>void setNextFocusRightId(int nextFocusRightId)</code><br />
Sets the id of the view to use when the next focus is FOCUS_RIGHT.</li>
<li><code>void setNextFocusUpId(int nextFocusUpId)</code><br />
Sets the id of the view to use when the next focus is FOCUS_UP.</li>
<li><code>void setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener listener)</code><br />
Set an View.OnApplyWindowInsetsListener to take over the policy for applying window insets to this view.</li>
<li><code>void setOnCapturedPointerListener(View.OnCapturedPointerListener l)</code><br />
Set a listener to receive callbacks when the pointer capture state of a view changes.</li>
<li><code>void setOnClickListener(View.OnClickListener l)</code><br />
Register a callback to be invoked when this view is clicked.</li>
<li><code>void setOnContextClickListener(View.OnContextClickListener l)</code><br />
Register a callback to be invoked when this view is context clicked.</li>
<li><code>void setOnCreateContextMenuListener(View.OnCreateContextMenuListener l)</code><br />
Register a callback to be invoked when the context menu for this view is being built.</li>
<li><code>void setOnDragListener(View.OnDragListener l)</code><br />
Register a drag event listener callback object for this View.</li>
<li><code>void setOnFocusChangeListener(View.OnFocusChangeListener l)</code><br />
Register a callback to be invoked when focus of this view changed.</li>
<li><code>void setOnGenericMotionListener(View.OnGenericMotionListener l)</code><br />
Register a callback to be invoked when a generic motion event is sent to this view.</li>
<li><code>void setOnHoverListener(View.OnHoverListener l)</code><br />
Register a callback to be invoked when a hover event is sent to this view.</li>
<li><code>void setOnKeyListener(View.OnKeyListener l)</code><br />
Register a callback to be invoked when a hardware key is pressed in this view.</li>
<li><code>void setOnLongClickListener(View.OnLongClickListener l)</code><br />
Register a callback to be invoked when this view is clicked and held.</li>
<li><code>void setOnScrollChangeListener(View.OnScrollChangeListener l)</code><br />
Register a callback to be invoked when the scroll X or Y positions of this view change.</li>
<li><code>void setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener l)</code><br />
Set a listener to receive callbacks when the visibility of the system bar changes.</li>
<li><code>void setOnTouchListener(View.OnTouchListener l)</code><br />
Register a callback to be invoked when a touch event is sent to this view.</li>
<li><code>void setOutlineProvider(ViewOutlineProvider provider)</code><br />
Sets the ViewOutlineProvider of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping.</li>
<li><code>void setOverScrollMode(int overScrollMode)</code><br />
Set the over-scroll mode for this view.</li>
<li><code>void setPadding(int left, int top, int right, int bottom)</code><br />
Sets the padding.</li>
<li><code>void setPaddingRelative(int start, int top, int end, int bottom)</code><br />
Sets the relative padding.</li>
<li><code>void setPivotX(float pivotX)</code><br />
Sets the x location of the point around which the view is rotated and scaled.</li>
<li><code>void setPivotY(float pivotY)</code><br />
Sets the y location of the point around which the view is rotated and scaled.</li>
<li><code>void setPointerIcon(PointerIcon pointerIcon)</code><br />
Set the pointer icon for the current view.</li>
<li><code>void setPressed(boolean pressed)</code><br />
Sets the pressed state for this view.</li>
<li><code>final void setRevealOnFocusHint(boolean revealOnFocus)</code><br />
Sets this view's preference for reveal behavior when it gains focus.</li>
<li><code>final void setRight(int right)</code><br />
Sets the right position of this view relative to its parent.</li>
<li><code>void setRotation(float rotation)</code><br />
Sets the degrees that the view is rotated around the pivot point.</li>
<li><code>void setRotationX(float rotationX)</code><br />
Sets the degrees that the view is rotated around the horizontal axis through the pivot point.</li>
<li><code>void setRotationY(float rotationY)</code><br />
Sets the degrees that the view is rotated around the vertical axis through the pivot point.</li>
<li><code>void setSaveEnabled(boolean enabled)</code><br />
Controls whether the saving of this view's state is enabled (that is, whether its onSaveInstanceState() method will be called).</li>
<li><code>void setSaveFromParentEnabled(boolean enabled)</code><br />
Controls whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent.</li>
<li><code>void setScaleX(float scaleX)</code><br />
Sets the amount that the view is scaled in x around the pivot point, as a proportion of the view's unscaled width.</li>
<li>void setScaleY(float scaleY)<br />
Sets the amount that the view is scaled in Y around the pivot point, as a proportion of the view's unscaled width.</li>
<li>void setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade)<br />
Define the delay before scrollbars fade.</li>
<li>void setScrollBarFadeDuration(int scrollBarFadeDuration)<br />
Define the scrollbar fade duration.</li>
<li>void setScrollBarSize(int scrollBarSize)<br />
Define the scrollbar size.</li>
<li>void setScrollBarStyle(int style)<br />
Specify the style of the scrollbars.</li>
<li>void setScrollContainer(boolean isScrollContainer)<br />
Change whether this view is one of the set of scrollable containers in its window.</li>
<li>void setScrollIndicators(int indicators, int mask)<br />
Sets the state of the scroll indicators specified by the mask.</li>
<li>void setScrollIndicators(int indicators)<br />
Sets the state of all scroll indicators.</li>
<li>void setScrollX(int value)<br />
Set the horizontal scrolled position of your view.</li>
<li>void setScrollY(int value)<br />
Set the vertical scrolled position of your view.</li>
<li>void setScrollbarFadingEnabled(boolean fadeScrollbars)<br />
Define whether scrollbars will fade when the view is not scrolling.</li>
<li>void setSelected(boolean selected)<br />
Changes the selection state of this view.</li>
<li>void setSoundEffectsEnabled(boolean soundEffectsEnabled)<br />
Set whether this view should have sound effects enabled for events such as clicking and touching.</li>
<li>void setStateListAnimator(StateListAnimator stateListAnimator)<br />
Attaches the provided StateListAnimator to this View.</li>
<li>void setSystemUiVisibility(int visibility)<br />
Request that the visibility of the status bar or other screen/window decorations be changed.</li>
<li>void setTag(int key, Object tag)<br />
Sets a tag associated with this view and a key.</li>
<li>void setTag(Object tag)<br />
Sets the tag associated with this view.</li>
<li>void setTextAlignment(int textAlignment)<br />
Set the text alignment.</li>
<li>void setTextDirection(int textDirection)<br />
Set the text direction.</li>
<li>void setTooltipText(CharSequence tooltipText)<br />
Sets the tooltip text which will be displayed in a small popup next to the view.</li>
<li>final void setTop(int top)<br />
Sets the top position of this view relative to its parent.</li>
<li>void setTouchDelegate(TouchDelegate delegate)<br />
Sets the TouchDelegate for this View.</li>
<li>final void setTransitionName(String transitionName)<br />
Sets the name of the View to be used to identify Views in Transitions.</li>
<li>void setTranslationX(float translationX)<br />
Sets the horizontal location of this view relative to its left position.</li>
<li>void setTranslationY(float translationY)<br />
Sets the vertical location of this view relative to its top position.</li>
<li>void setTranslationZ(float translationZ)<br />
Sets the depth location of this view relative to its elevation.</li>
<li>void setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled)<br />
Define whether the vertical edges should be faded when this view is scrolled vertically.</li>
<li><code>void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled)</code><br />
Define whether the vertical scrollbar should be drawn or not.</li>
<li><code>void setVerticalScrollbarPosition(int position)</code><br />
Set the position of the vertical scroll bar.</li>
<li><code>void setVisibility(int visibility)</code><br />
Set the visibility state of this view.</li>
<li><code>void setWillNotCacheDrawing(boolean willNotCacheDrawing)</code><br />
When a View's drawing cache is enabled, drawing is redirected to an offscreen bitmap.</li>
<li><code>void setWillNotDraw(boolean willNotDraw)</code><br />
If this view doesn't do any drawing on its own, set this flag to allow further optimizations.</li>
<li><code>void setX(float x)</code><br />
Sets the visual x position of this view, in pixels.</li>
<li><code>void setY(float y)</code><br />
Sets the visual y position of this view, in pixels.</li>
<li><code>void setZ(float z)</code><br />
Sets the visual z position of this view, in pixels.</li>
<li><code>boolean showContextMenu()</code><br />
Shows the context menu for this view.</li>
<li><code>boolean showContextMenu(float x, float y)</code><br />
Shows the context menu for this view anchored to the specified view-relative coordinate.</li>
<li><code>ActionMode startActionMode(ActionMode.Callback callback, int type)</code><br />
Start an action mode with the given type.</li>
<li><code>ActionMode startActionMode(ActionMode.Callback callback)</code><br />
Start an action mode with the default type TYPE_PRIMARY.</li>
<li><code>void startAnimation(Animation animation)</code><br />
Start the specified animation now.</li>
<li><code>final boolean startDrag(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)</code><br />
This method was deprecated in API level 24. Use startDragAndDrop() for newer platform versions.</li>
<li><code>final boolean startDragAndDrop(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)</code><br />
Starts a drag and drop operation.</li>
<li><code>boolean startNestedScroll(int axes)</code><br />
Begin a nestable scroll operation along the given axes.</li>
<li><code>void stopNestedScroll()</code><br />
Stop a nested scroll in progress.</li>
<li><code>String toString()</code><br />
Returns a string representation of the object.</li>
<li><code>void unscheduleDrawable(Drawable who, Runnable what)</code><br />
Cancels a scheduled action on a drawable.</li>
<li><code>void unscheduleDrawable(Drawable who)</code><br />
Unschedule any events associated with the given Drawable.</li>
<li><code>final void updateDragShadow(View.DragShadowBuilder shadowBuilder)</code><br />
Updates the drag shadow for the ongoing drag and drop operation.</li>
<li><code>boolean willNotCacheDrawing()</code><br />
Returns whether or not this View can cache its drawing or not.</li>
<li><code>boolean willNotDraw()</code><br />
Returns whether or not this View draws on its own.</li>
</ul>
<h2><a id="%E8%8E%B7%E5%8F%96%E4%B8%8A%E7%BA%A7view%E7%9A%84%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取上级View的方法汇总</h2>
<pre><code class="language-java">getParent()                                                    //获取上一级View
getRootView                                                    //获取跟布局
getWindow().getDecorView()                                     
findViewById(android.R.id.content)
((ViewGroup)findViewById(android.R.id.content)).getChildAt(0)
</code></pre>
<h3><a id="%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>方法介绍</h3>
<p><img src="media/15561207869937/15713203742240.jpg" alt="" /></p>
<h3><a id="getrootview%E7%89%B9%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getRootView特例</h3>
<p><strong>布局(R.layout.list_empty)：</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;#FFFFFF&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/name&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerVertical=&quot;true&quot;
        android:layout_marginLeft=&quot;15dp&quot;
        android:text=&quot;暂无数据&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>
<p><strong>代码：</strong></p>
<pre><code class="language-java">    final View view = View.inflate(this, R.layout.list_empty, null);
    final TextView name = (TextView) view.findViewById(R.id.name);
    System.out.println(&quot;before View.inflate name getParent &quot; + name.getParent());
    System.out.println(&quot;before View.inflate name getRootView &quot; + name.getRootView());
    addContentView(view, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
    System.out.println(&quot;after View.inflate name getParent &quot; + name.getParent());
    System.out.println(&quot;after View.inflate name getRootView &quot; + name.getRootView());
</code></pre>
<pre><code class="language-java">结果：
before View.inflate name getParent android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
before View.inflate name getRootView android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
after View.inflate name getParent android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
after View.inflate name getRootView com.android.internal.policy.impl.MultiPhoneWindow$MultiPhoneDecorView{c535bb V.E..... R.....ID 0,0-0,0}
</code></pre>
<p><em>结论：如果View在代码中通过View.inflate实例化，在没有添加到显示界面前，getRootView获得的是Xml的根布局。添加后getRootView获得的是MultiPhoneDecorView。</em></p>
<h3><a id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用场景</h3>
<p>用途：状态栏、标题栏、键盘的高度</p>
<p><em>注意：以下代码不能在onCreate里面使用，否则获取的高度为0，你可以放在onWindowFocusChanged等等</em></p>
<h4><a id="%E7%8A%B6%E6%80%81%E6%A0%8F%E9%AB%98%E5%BA%A6%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>状态栏高度：</h4>
<p><code>getDecorView</code>的<code>getWindowVisibleDisplayFrame</code>方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。 于是，我们就可以算出状态栏的高度了。</p>
<pre><code class="language-java">Rect frame = new Rect();  
getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);  
int statusBarHeight = frame.top;
</code></pre>
<h4><a id="%E6%A0%87%E9%A2%98%E6%A0%8F%E9%AB%98%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标题栏高度</h4>
<p><code>findViewById(Android.R.id.content)</code>是不包括标题栏的，我们可以通过它获取标题栏的高度。</p>
<pre><code class="language-java">int contentTop = findViewById(android.R.id.content).getTop();  
//statusBarHeight是上面所求的状态栏的高度  
int titleBarHeight = contentTop - statusBarHeight;
</code></pre>
<h4><a id="%E9%94%AE%E7%9B%98%E9%AB%98%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>键盘高度</h4>
<ul>
<li>键盘没打开时获取android.R.id.content的可见区域高度height1，</li>
<li>键盘打开时再获取android.R.id.content的可见区域高度height2，</li>
<li>键盘的高度height1-height2</li>
</ul>
<pre><code class="language-java">private View globalView;
private int firstHeight;
private boolean isFirst = true;

globalView = findViewById(android.R.id.content);
globalView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
    @Override
    public void onGlobalLayout() {
        Rect rect = new Rect();
        globalView.getWindowVisibleDisplayFrame(rect);
        if (isFirst) {
            isFirst = false;
            firstHeight = rect.height();
        } else {
            int height = rect.height();
            if (height &lt; firstHeight) {
                System.out.println(&quot;键盘打开 &quot; + (firstHeight - height));
            } else {
                System.out.println(&quot;键盘关闭 &quot;);
            }
        }
    }
});
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869850.html">
                
                  <h1>Android-VelocityTracker详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简介</h2>
<p>VelocityTracker是一个跟踪触摸事件滑动速度的帮助类，用于实现flinging以及其它类似的手势。它的原理是把触摸事件 MotionEvent 对象传递给VelocityTracker的 addMovement(MotionEvent) 方法，然后分析MotionEvent 对象在单位时间类发生的位移来计算速度。你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。</p>
<h2><a id="%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主要函数</h2>
<table>
<thead>
<tr>
<th style="text-align: left">Public Methods</th>
<th style="text-align: left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>addMovement(MotionEvent event)</code> <br>Add a users movement to the tracker.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>clear()</code> <br>Reset the velocity tracker back to its initial state.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>compute CurrentVelocity(int units,float maxVelocity)</code><br>Compute the current velocity based on the points that have been collected.<br><br>intunitis表示速率的基本时间单位。unitis值为1的表示是，一毫秒时间单位内运动了多少个像素， unitis值为1000表示一秒（1000毫秒）时间单位内运动了多少个像素<br><br>floatVelocity表示速率的最大值</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>computeCurrentVelocity(int units)</code><br>Equivalent to invoking computeCurrentVelocity(int, float)with a maximum velocity of Float.MAX_VALUE.</td>
</tr>
<tr>
<td style="text-align: left">abstract T</td>
<td style="text-align: left"><code>getNextPoolable()</code></td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getXVelocity()</code><br>Retrieve the last computed X velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getXVelocity(int id)</code><br>Retrieve the last computed X velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>float	getYVelocity(int id)</code><br>Retrieve the last computed Y velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getYVelocity()</code><br>Retrieve the last computed Y velocity.</td>
</tr>
<tr>
<td style="text-align: left">abstract boolean</td>
<td style="text-align: left"><code>isPooled()</code></td>
</tr>
<tr>
<td style="text-align: left">static VelocityTracker</td>
<td style="text-align: left"><code>obtain()</code><br>Retrieve a new VelocityTracker object to watch the velocity of a motion.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>recycle()</code><br>Return a VelocityTracker object back to be re-used by others.</td>
</tr>
<tr>
<td style="text-align: left">abstract void</td>
<td style="text-align: left"><code>setNextPoolable(T element)</code></td>
</tr>
<tr>
<td style="text-align: left">abstract void</td>
<td style="text-align: left"><code>setPooled(boolean isPooled)</code></td>
</tr>
</tbody>
</table>
<h2><a id="%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例</h2>
<pre><code class="language-java">private VelocityTracker mVelocityTracker;//生命变量  
//在onTouchEvent(MotionEvent ev)中  
if (mVelocityTracker == null) {  
    mVelocityTracker = VelocityTracker.obtain();//获得VelocityTracker类实例  
}  
mVelocityTracker.addMovement(ev);//将事件加入到VelocityTracker类实例中  
//判断当ev事件是MotionEvent.ACTION_UP时：计算速率  
final VelocityTracker velocityTracker = mVelocityTracker;  
// 1000 provides pixels per second  
velocityTracker.computeCurrentVelocity(1, (float)0.01);//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常  
Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getXVelocity());  
velocityTracker.computeCurrentVelocity(1000); //设置units的值为1000，意思为一秒时间内运动了多少个像素  
Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getXVelocity());

</code></pre>
<p>大体的使用是这样的：<br />
当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象<br />
在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象<br />
使用computeCurrentVelocity (int units)函数来计算当前的速度，使用getXVelocity ()、 getYVelocity ()函数来获得当前的速度</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869807.html">
                
                  <h1>Android-Toolbar详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="toolbar%E6%98%AF%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Toolbar是简单使用</h2>
<p>1、在应用的build.gradle中添加v7 appcompat支持库。<br />
<code>com.android.support:appcompat-v7:24.1.1</code></p>
<p>2、让Activity继承自AppCompatActivity。</p>
<pre><code class="language-java">public class MyActivity extends AppCompatActivity {
  // ...
}
</code></pre>
<p>3、在AndroidManifest.xml文件中，设置元素使用appcompat中的某个NoActionBar主题，从而来去除使用ActionBar来提供操作栏。</p>
<pre><code class="language-java">&lt;application android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;/&gt;
</code></pre>
<p>4、在activity的布局中添加Toolbar。</p>
<pre><code class="language-java">&lt;android.support.v7.widget.Toolbar
 android:id=&quot;@+id/my_toolbar&quot;
 android:layout_width=&quot;match_parent&quot;
 android:layout_height=&quot;?attr/actionBarSize&quot;
 android:background=&quot;?attr/colorPrimary&quot;
 android:elevation=&quot;4dp&quot;
 android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;  
 app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;
</code></pre>
<p>5、在activity的onCreate()方法中，调用setSupportActionBar()方法，并传入toolbar，这样就会将toolbar设置为activity的操作栏了。</p>
<pre><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_my);
  Toolbar toolbar = (Toolbar) findViewById(R.id.my_toolbar);
  setSupportActionBar(toolbar);
}
</code></pre>
<h2><a id="toolber%E5%A4%8D%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Toolber复用</h2>
<p>应用中有很多界面，每个Activity一般都需要操作栏，且大多数activity的操作栏的元素是一致的，那每个布局文件里面都写这么多资源文件是累赘的。因此可以对Toolbar进行复用，使得布局文件看起来更精炼，更改Toolbar整体效果，如背景之类的可以更方便。</p>
<p>首先，在布局文件toolbar.xml中定义Toolbar。</p>
<pre><code class="language-java">&lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/toolbar&quot;
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;?attr/actionBarSize&quot;
    android:background=&quot;?attr/colorPrimary&quot;
    android:contentInsetLeft=&quot;0dp&quot;
    android:contentInsetStart=&quot;0dp&quot;
    android:elevation=&quot;4dp&quot;
    android:theme=&quot;@style/ToolbarTheme&quot;
    app:navigationIcon=&quot;@drawable/icon_back&quot;
    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;
    app:titleTextAppearance=&quot;@style/Toolbar.TitleText&quot;&gt;

    &lt;!--  any custom view --&gt;

&lt;/android.support.v7.widget.Toolbar&gt;
</code></pre>
<p>之后，在需要添加Toolbar的地方引入这个布局资源。</p>
<pre><code class="language-java">&lt;include
  layout=&quot;@layout/toolbar&quot;/&gt;
</code></pre>
<p>最后，在BaseActivity(一般app都会有)中的onCreate()方法设置Toolbar。注意，这个时候Activity不再继承AppCompatActivity，而是继承BaseActivity，而BaseActivity继承AppCompatActivity。BaseActivity部分代码如下：</p>
<pre><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    if (toolbar != null) {
        setSupportActionBar(toolbar);

        mToolbarHelper = new ToolbarHelper(toolbar);

        hanldeToolbar(mToolbarHelper);
    }
}

protected void hanldeToolbar(ToolbarHelper toolbarHelper) {}

public static class ToolbarHelper {

    private Toolbar mToolbar;

    public ToolbarHelper(Toolbar toolbar) {
        this.mToolbar = toolbar;
    }

    public Toolbar getToolbar() {
        return mToolbar;
    }

    public void setTitle(String title) {
        TextView titleTV = (TextView) mToolbar.findViewById(R.id.toolbar_title);
        titleTV.setText(title);
    }
}
</code></pre>
<p>代码中首先获取到Toolbar将其设置为操作栏，之后创建了一个ToolbarHelper对象，ToobarHelper主要是封装了下Toolbar，并提供操作自定义View的方法。然后调用hanldeToolbar()方法，子Activity通过重写这个方法，可以对Toolbar进行定制操作。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869765.html">
                
                  <h1>Android-MotionEvent解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%B8%80%E4%BA%9B%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一些常量</h2>
<h3><a id="%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A8%E4%BD%9C%E5%B8%B8%E9%87%8F%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常见的动作常量：</h3>
<ul>
<li><code>public static final int ACTION_DOWN = 0;       //单点触摸动作</code></li>
<li><code>public static final int ACTION_UP  = 1;        //单点触摸离开动作</code></li>
<li><code>public static final int ACTION_MOVE = 2;       //触摸点移动动作</code></li>
<li><code>public static final int ACTION_CANCEL = 3;     //触摸动作取消</code></li>
<li><code>public static final int ACTION_OUTSIDE = 4;    //触摸动作超出边界</code></li>
<li><code>public static final int ACTION_POINTER_DOWN = 5;//多点触摸动作</code>   </li>
<li><code>public static final int ACTION_POINTER_UP = 6;  //多点离开动作</code> </li>
</ul>
<h3><a id="%E4%BB%A5%E4%B8%8B%E6%98%AF%E4%B8%80%E4%BA%9B%E9%9D%9Etouch%E4%BA%8B%E4%BB%B6%C2%A0%C2%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以下是一些非touch事件   </h3>
<ul>
<li><code>public static final int ACTION_HOVER_MOVE       = 7;</code></li>
<li><code>public static final int ACTION_SCROLL           = 8;</code>   </li>
<li><code>public static final int ACTION_HOVER_ENTER      = 9;</code>   </li>
<li><code>public static final int ACTION_HOVER_EXIT       = 10;</code></li>
</ul>
<h3><a id="%E6%8E%A9%E7%A0%81%E5%B8%B8%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>掩码常量</h3>
<p><code>ACTION_MASK = 0X000000ff</code></p>
<h3><a id="%E5%8A%A8%E4%BD%9C%E6%8E%A9%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动作掩码</h3>
<p><code>ACTION_POINTER_INDEX_MASK = 0X0000ff00</code></p>
<h3><a id="%E8%A7%A6%E6%91%B8%E7%82%B9%E7%B4%A2%E5%BC%95%E6%8E%A9%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>触摸点索引掩码</h3>
<p><code>ACTION_POINTER_INDEX_SHIFT = 8  //获取触摸点索引需要移动的位数</code></p>
<h3><a id="getrawx%E5%92%8C-getrawy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getRawX()和getRawY()</h3>
<p><code>相对于屏幕位置坐标</code></p>
<h3><a id="x-y%E7%9B%B8%E5%AF%B9%E4%BA%8E-view%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>X,Y 相对于View的位置坐标</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869720.html">
                
                  <h1>Android-ViewConfiguration解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>ViewConfiguration这个类主要定义了UI中所使用到的标准常量，像超时、尺寸、距离，如果我们需要得到这些常量的数据，我们就可以通过这个类来获取，具体方法如下： </p>
<ul>
<li>获取ViewConfiguration对象，由于ViewConfiguration的构造方法为私有的，只能通过这个静态方法来获取到该对象。 ViewConfiguration configure = ViewConfiguration.get(context); </li>
<li>通过该对象调用相关的函数，将返回相关的常量数据。</li>
</ul>
<p>最后附上一些这个类文件源码，这里面所有的方法基本都是用来获取常量数据的，没有什么业务操作。</p>
<pre><code class="language-java">import android.app.AppGlobals;
import android.content.Context;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Point;
import android.os.RemoteException;
import android.provider.Settings;
import android.util.DisplayMetrics;
import android.util.SparseArray;

/**
 * 主要用来获取一些在UI中所使用到的标准常量，像超时、尺寸、距离
 */
public class ViewConfiguration {
    /**
     * 定义了水平滚动条的宽度和垂直滚动条的高度，单位是dip
     */
    private static final int SCROLL_BAR_SIZE = 10;

    /**
     * 滚动条褪去所需要经历的时间，单位：milliseconds
     */
    private static final int SCROLL_BAR_FADE_DURATION = 250;

    /**
     * 滚动条褪去之前的默认时间延迟，单位：milliseconds
     */
    private static final int SCROLL_BAR_DEFAULT_DELAY = 300;

    /**
     * 定义褪去边缘的长度，单位：dip
     */
    private static final int FADING_EDGE_LENGTH = 12;

    /**
     * 按下状态在子控件上的持续时间，单位：milliseconds
     */
    private static final int PRESSED_STATE_DURATION = 64;

    /**
     * 定义一个按下状态转变成长按状态所需要持续的时间，单位：milliseconds
     */
    private static final int DEFAULT_LONG_PRESS_TIMEOUT = 500;

    /**
     * 定义连续重复按键间的时间延迟，单位：milliseconds
     */
    private static final int KEY_REPEAT_DELAY = 50;

    /**
     * 如果用户需要触发全局对话框，例如：关机，锁屏等，需要按下按钮所持续的事件，单位：milliseconds
     */
    private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500;

    /**
     * 定义一个触摸事件是点击还是滚动的事件间隔，如果在这个事件内没有移动，就认为这是一个点击，否则就是滚动，单位：milliseconds
     */
    private static final int TAP_TIMEOUT = 180;

    /**
     * Defines the duration in milliseconds we will wait to see if a touch event
     * is a jump tap. If the user does not complete the jump tap within this interval, it is
     * considered to be a tap.
     */
    private static final int JUMP_TAP_TIMEOUT = 500;

    /**
     * 定义双击的时间间隔，如果在这个时间内，就认为是双击
     */
    private static final int DOUBLE_TAP_TIMEOUT = 300;

    /**
     * 定义双击最小的时间间隔
     */
    private static final int DOUBLE_TAP_MIN_TIME = 40;

    /**
     * 定义一个触摸板触摸到释放可认为是一个点击事件而不是一个触摸移动手势的最大时间，
     * 也就是说在这个时间内进行一次触摸和释放操作就可以认为是一次点击事件，单位：milliseconds
     */
    private static final int HOVER_TAP_TIMEOUT = 150;

    /**
     * 定义一个触摸板在触摸释放之前可以移动的最大距离，
     * 如果在这个距离之内就可以认为是一个点击事件，否则就是一个移动手势，单位：pixels
     */
    private static final int HOVER_TAP_SLOP = 20;

    /**
     * 定义响应显示缩放控制的时间
     */
    private static final int ZOOM_CONTROLS_TIMEOUT = 3000;

    /**
     * Inset in dips to look for touchable content when the user touches the edge of the screen
     */
    private static final int EDGE_SLOP = 12;

    /**
     * 如果我们认为用户正在滚动，这里定义一个触摸事件可以滚动的距离，单位：dips
     * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。
     */
    private static final int TOUCH_SLOP = 8;

    /**
     * 定义双击事件之间可以移动的距离，单位：dips
     */
    private static final int DOUBLE_TAP_TOUCH_SLOP = TOUCH_SLOP;

    /**
     * 定义用户尝试翻页滚动的触摸移动距离，单位：dips
     *
     * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。
     *
     */
    private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2;

    /**
     * 定义第一次点击和第二次点击可以认为是一次双击之间的距离。单位：dips
     */
    private static final int DOUBLE_TAP_SLOP = 100;

    /**
     * Distance in dips a touch needs to be outside of a window's bounds for it to
     * count as outside for purposes of dismissing the window.
     */
    private static final int WINDOW_TOUCH_SLOP = 16;

    /**
     * 一个fling最小的速度，单位：dips/s
     */
    private static final int MINIMUM_FLING_VELOCITY = 50;

    /**
     * 一个fling最大的速度，单位：dips/s
     */
    private static final int MAXIMUM_FLING_VELOCITY = 8000;

    /**
     * 分发一个重复访问事件的延迟事件，单位：milliseconds
     */
    private static final long SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS = 100;

    /**
     * The maximum size of View's drawing cache, expressed in bytes. This size
     * should be at least equal to the size of the screen in ARGB888 format.
     */
    @Deprecated
    private static final int MAXIMUM_DRAWING_CACHE_SIZE = 480 * 800 * 4; // ARGB8888

    /**
     * 滚动和滑动的摩擦系数
     */
    private static final float SCROLL_FRICTION = 0.015f;

    /**
     * Max distance in dips to overscroll for edge effects
     */
    private static final int OVERSCROLL_DISTANCE = 0;

    /**
     * Max distance in dips to overfling for edge effects
     */
    private static final int OVERFLING_DISTANCE = 6;

    private final int mEdgeSlop;
    private final int mFadingEdgeLength;
    private final int mMinimumFlingVelocity;
    private final int mMaximumFlingVelocity;
    private final int mScrollbarSize;
    private final int mTouchSlop;
    private final int mDoubleTapTouchSlop;
    private final int mPagingTouchSlop;
    private final int mDoubleTapSlop;
    private final int mWindowTouchSlop;
    private final int mMaximumDrawingCacheSize;
    private final int mOverscrollDistance;
    private final int mOverflingDistance;
    private final boolean mFadingMarqueeEnabled;

    private boolean sHasPermanentMenuKey;
    private boolean sHasPermanentMenuKeySet;

    static final SparseArray&lt;ViewConfiguration&gt; sConfigurations =
            new SparseArray&lt;ViewConfiguration&gt;(2);

    /**
     * 这个方法被废除了，使用ViewConfiguration.get(Context)}替代
     */
    @Deprecated
    public ViewConfiguration() {
        mEdgeSlop = EDGE_SLOP;
        mFadingEdgeLength = FADING_EDGE_LENGTH;
        mMinimumFlingVelocity = MINIMUM_FLING_VELOCITY;
        mMaximumFlingVelocity = MAXIMUM_FLING_VELOCITY;
        mScrollbarSize = SCROLL_BAR_SIZE;
        mTouchSlop = TOUCH_SLOP;
        mDoubleTapTouchSlop = DOUBLE_TAP_TOUCH_SLOP;
        mPagingTouchSlop = PAGING_TOUCH_SLOP;
        mDoubleTapSlop = DOUBLE_TAP_SLOP;
        mWindowTouchSlop = WINDOW_TOUCH_SLOP;
        //noinspection deprecation
        mMaximumDrawingCacheSize = MAXIMUM_DRAWING_CACHE_SIZE;
        mOverscrollDistance = OVERSCROLL_DISTANCE;
        mOverflingDistance = OVERFLING_DISTANCE;
        mFadingMarqueeEnabled = true;
    }

    /**
     * 使用给定的context来创建一个新的配置。这个配置依赖于context里面不同的参数，例如显示的尺寸或者密度
     * @param context 用来初始化这个view配置的应用上下文环境
     *
     * @see #get(android.content.Context)
     * @see android.util.DisplayMetrics
     */
    private ViewConfiguration(Context context) {
        final Resources res = context.getResources();
        final DisplayMetrics metrics = res.getDisplayMetrics();
        final Configuration config = res.getConfiguration();
        final float density = metrics.density;
        final float sizeAndDensity;
        if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE)) {
            sizeAndDensity = density * 1.5f;
        } else {
            sizeAndDensity = density;
        }

        mEdgeSlop = (int) (sizeAndDensity * EDGE_SLOP + 0.5f);
        mFadingEdgeLength = (int) (sizeAndDensity * FADING_EDGE_LENGTH + 0.5f);
        mMinimumFlingVelocity = (int) (density * MINIMUM_FLING_VELOCITY + 0.5f);
        mMaximumFlingVelocity = (int) (density * MAXIMUM_FLING_VELOCITY + 0.5f);
        mScrollbarSize = (int) (density * SCROLL_BAR_SIZE + 0.5f);
        mDoubleTapSlop = (int) (sizeAndDensity * DOUBLE_TAP_SLOP + 0.5f);
        mWindowTouchSlop = (int) (sizeAndDensity * WINDOW_TOUCH_SLOP + 0.5f);

        // Size of the screen in bytes, in ARGB_8888 format
        final WindowManager win = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
        final Display display = win.getDefaultDisplay();
        final Point size = new Point();
        display.getRealSize(size);
        mMaximumDrawingCacheSize = 4 * size.x * size.y;

        mOverscrollDistance = (int) (sizeAndDensity * OVERSCROLL_DISTANCE + 0.5f);
        mOverflingDistance = (int) (sizeAndDensity * OVERFLING_DISTANCE + 0.5f);

        if (!sHasPermanentMenuKeySet) {
            IWindowManager wm = WindowManagerGlobal.getWindowManagerService();
            try {
                sHasPermanentMenuKey = !wm.hasNavigationBar();
                sHasPermanentMenuKeySet = true;
            } catch (RemoteException ex) {
                sHasPermanentMenuKey = false;
            }
        }

        mFadingMarqueeEnabled = res.getBoolean(
                com.android.internal.R.bool.config_ui_enableFadingMarquee);
        mTouchSlop = res.getDimensionPixelSize(
                com.android.internal.R.dimen.config_viewConfigurationTouchSlop);
        mPagingTouchSlop = mTouchSlop * 2;

        mDoubleTapTouchSlop = mTouchSlop;
    }

    /**
     * 跟上面一个函数一样，只不过上面一个是创建一个ViewConfiguration对象，这里是直接通过这个静态方法返回一个对象
     */
    public static ViewConfiguration get(Context context) {
        final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
        final int density = (int) (100.0f * metrics.density);

        ViewConfiguration configuration = sConfigurations.get(density);
        if (configuration == null) {
            configuration = new ViewConfiguration(context);
            sConfigurations.put(density, configuration);
        }

        return configuration;
    }

    /**
     * @return 获取水平滚动条的宽带和垂直滚动条的高度
     *
     * 这个函数被废除，使用getScaledScrollBarSize()来代替
     */
    @Deprecated
    public static int getScrollBarSize() {
        return SCROLL_BAR_SIZE;
    }

    /**
     * @return 获取水平滚动条的宽带和垂直滚动条的高度
     */
    public int getScaledScrollBarSize() {
        return mScrollbarSize;
    }

    /**
     * @return 滚动条褪去的持续时间
     */
    public static int getScrollBarFadeDuration() {
        return SCROLL_BAR_FADE_DURATION;
    }

    /**
     * @return 滚动条褪去的延迟时间
     */
    public static int getScrollDefaultDelay() {
        return SCROLL_BAR_DEFAULT_DELAY;
    }

    /**
     * @return 褪去边缘的长度
     *
     * 这个方法已经废弃，用getScaledFadingEdgeLength()替代.
     */
    @Deprecated
    public static int getFadingEdgeLength() {
        return FADING_EDGE_LENGTH;
    }

    /**
     * @return 褪去边缘的长度，单位：pixels
     */
    public int getScaledFadingEdgeLength() {
        return mFadingEdgeLength;
    }

    /**
     * @return 在子控件上按住状态的持续时间
     */
    public static int getPressedStateDuration() {
        return PRESSED_STATE_DURATION;
    }

    /**
     * @return 按住状态转变为长按状态需要的时间
     */
    public static int getLongPressTimeout() {
        return AppGlobals.getIntCoreSetting(Settings.Secure.LONG_PRESS_TIMEOUT,
                DEFAULT_LONG_PRESS_TIMEOUT);
    }

    /**
     * @return 重新按键时间
     */
    public static int getKeyRepeatTimeout() {
        return getLongPressTimeout();
    }

    /**
     * @return 重复按键延迟时间
     */
    public static int getKeyRepeatDelay() {
        return KEY_REPEAT_DELAY;
    }

    /**
     * @return 判断用户是单击还是滚动的时间，在这个时间内没有移动则是单击，否则是滚动
     */
    public static int getTapTimeout() {
        return TAP_TIMEOUT;
    }

    /**
     * @return the duration in milliseconds we will wait to see if a touch event
     * is a jump tap. If the user does not move within this interval, it is
     * considered to be a tap.
     */
    public static int getJumpTapTimeout() {
        return JUMP_TAP_TIMEOUT;
    }

    /**
     * @return 得到双击间隔时间，在这个时间内，则是双击，否则就是单击
     */
    public static int getDoubleTapTimeout() {
        return DOUBLE_TAP_TIMEOUT;
    }

    /**
     * @return the minimum duration in milliseconds between the first tap's
     * up event and the second tap's down event for an interaction to be considered a
     * double-tap.
     *
     * @hide
     */
    public static int getDoubleTapMinTime() {
        return DOUBLE_TAP_MIN_TIME;
    }

    /**
     * @return the maximum duration in milliseconds between a touch pad
     * touch and release for a given touch to be considered a tap (click) as
     * opposed to a hover movement gesture.
     * @hide
     */
    public static int getHoverTapTimeout() {
        return HOVER_TAP_TIMEOUT;
    }

    /**
     * @return the maximum distance in pixels that a touch pad touch can move
     * before being released for it to be considered a tap (click) as opposed
     * to a hover movement gesture.
     * @hide
     */
    public static int getHoverTapSlop() {
        return HOVER_TAP_SLOP;
    }

    /**
     * @return Inset in dips to look for touchable content when the user touches the edge of the
     *         screen
     *
     * @deprecated Use {@link #getScaledEdgeSlop()} instead.
     */
    @Deprecated
    public static int getEdgeSlop() {
        return EDGE_SLOP;
    }

    /**
     * @return Inset in pixels to look for touchable content when the user touches the edge of the
     *         screen
     */
    public int getScaledEdgeSlop() {
        return mEdgeSlop;
    }

    /**
     * @return Distance in dips a touch can wander before we think the user is scrolling
     *
     * @deprecated Use {@link #getScaledTouchSlop()} instead.
     */
    @Deprecated
    public static int getTouchSlop() {
        return TOUCH_SLOP;
    }

    /**
     * @return Distance in pixels a touch can wander before we think the user is scrolling
     */
    public int getScaledTouchSlop() {
        return mTouchSlop;
    }

    /**
     * @return Distance in pixels the first touch can wander before we do not consider this a
     * potential double tap event
     * @hide
     */
    public int getScaledDoubleTapTouchSlop() {
        return mDoubleTapTouchSlop;
    }

    /**
     * @return Distance in pixels a touch can wander before we think the user is scrolling a full
     * page
     */
    public int getScaledPagingTouchSlop() {
        return mPagingTouchSlop;
    }

    /**
     * @return Distance in dips between the first touch and second touch to still be
     *         considered a double tap
     * @deprecated Use {@link #getScaledDoubleTapSlop()} instead.
     * @hide The only client of this should be GestureDetector, which needs this
     *       for clients that still use its deprecated constructor.
     */
    @Deprecated
    public static int getDoubleTapSlop() {
        return DOUBLE_TAP_SLOP;
    }

    /**
     * @return Distance in pixels between the first touch and second touch to still be
     *         considered a double tap
     */
    public int getScaledDoubleTapSlop() {
        return mDoubleTapSlop;
    }

    /**
     * Interval for dispatching a recurring accessibility event in milliseconds.
     * This interval guarantees that a recurring event will be send at most once
     * during the {@link #getSendRecurringAccessibilityEventsInterval()} time frame.
     *
     * @return The delay in milliseconds.
     *
     * @hide
     */
    public static long getSendRecurringAccessibilityEventsInterval() {
        return SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS;
    }

    /**
     * @return Distance in dips a touch must be outside the bounds of a window for it
     * to be counted as outside the window for purposes of dismissing that
     * window.
     *
     * @deprecated Use {@link #getScaledWindowTouchSlop()} instead.
     */
    @Deprecated
    public static int getWindowTouchSlop() {
        return WINDOW_TOUCH_SLOP;
    }

    /**
     * @return Distance in pixels a touch must be outside the bounds of a window for it
     * to be counted as outside the window for purposes of dismissing that window.
     */
    public int getScaledWindowTouchSlop() {
        return mWindowTouchSlop;
    }

    /**
     * @return Minimum velocity to initiate a fling, as measured in dips per second.
     *
     * @deprecated Use {@link #getScaledMinimumFlingVelocity()} instead.
     */
    @Deprecated
    public static int getMinimumFlingVelocity() {
        return MINIMUM_FLING_VELOCITY;
    }

    /**
     * @return 得到滑动的最小速度, 以像素/每秒来进行计算
     */
    public int getScaledMinimumFlingVelocity() {
        return mMinimumFlingVelocity;
    }

    /**
     * @return Maximum velocity to initiate a fling, as measured in dips per second.
     *
     * @deprecated Use {@link #getScaledMaximumFlingVelocity()} instead.
     */
    @Deprecated
    public static int getMaximumFlingVelocity() {
        return MAXIMUM_FLING_VELOCITY;
    }

    /**
     * @return 得到滑动的最大速度, 以像素/每秒来进行计算
     */
    public int getScaledMaximumFlingVelocity() {
        return mMaximumFlingVelocity;
    }

    /**
     * The maximum drawing cache size expressed in bytes.
     *
     * @return the maximum size of View's drawing cache expressed in bytes
     *
     * @deprecated Use {@link #getScaledMaximumDrawingCacheSize()} instead.
     */
    @Deprecated
    public static int getMaximumDrawingCacheSize() {
        //noinspection deprecation
        return MAXIMUM_DRAWING_CACHE_SIZE;
    }

    /**
     * The maximum drawing cache size expressed in bytes.
     *
     * @return the maximum size of View's drawing cache expressed in bytes
     */
    public int getScaledMaximumDrawingCacheSize() {
        return mMaximumDrawingCacheSize;
    }

    /**
     * @return The maximum distance a View should overscroll by when showing edge effects (in
     * pixels).
     */
    public int getScaledOverscrollDistance() {
        return mOverscrollDistance;
    }

    /**
     * @return The maximum distance a View should overfling by when showing edge effects (in
     * pixels).
     */
    public int getScaledOverflingDistance() {
        return mOverflingDistance;
    }

    /**
     * The amount of time that the zoom controls should be
     * displayed on the screen expressed in milliseconds.
     *
     * @return the time the zoom controls should be visible expressed
     * in milliseconds.
     */
    public static long getZoomControlsTimeout() {
        return ZOOM_CONTROLS_TIMEOUT;
    }

    /**
     * The amount of time a user needs to press the relevant key to bring up
     * the global actions dialog.
     *
     * @return how long a user needs to press the relevant key to bring up
     *   the global actions dialog.
     */
    public static long getGlobalActionKeyTimeout() {
        return GLOBAL_ACTIONS_KEY_TIMEOUT;
    }

    /**
     * The amount of friction applied to scrolls and flings.
     *
     * @return A scalar dimensionless value representing the coefficient of
     *         friction.
     */
    public static float getScrollFriction() {
        return SCROLL_FRICTION;
    }

    /**
     * Report if the device has a permanent menu key available to the user.
     *
     * &lt;p&gt;As of Android 3.0, devices may not have a permanent menu key available.
     * Apps should use the action bar to present menu options to users.
     * However, there are some apps where the action bar is inappropriate
     * or undesirable. This method may be used to detect if a menu key is present.
     * If not, applications should provide another on-screen affordance to access
     * functionality.
     *
     * @return true if a permanent menu key is present, false otherwise.
     */
    public boolean hasPermanentMenuKey() {
        return sHasPermanentMenuKey;
    }

    /**
     * @hide
     * @return Whether or not marquee should use fading edges.
     */
    public boolean isFadingMarqueeEnabled() {
        return mFadingMarqueeEnabled;
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/07</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869583.html">
                
                  <h1>Android-ViewPager详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简介</h2>
<p>ViewPager是android扩展包v4包中的类，这个类可以让用户左右切换当前的view</p>
<ul>
<li>ViewPager类直接继承了ViewGroup类，所有它是一个容器类，可以在其中添加其他的view类。</li>
<li>ViewPager类需要一个PagerAdapter适配器类给它提供数据。</li>
<li>ViewPager经常和Fragment一起使用，并且提供了专门的FragmentPagerAdapter和FragmentStatePagerAdapter类供Fragment中的ViewPager使用。</li>
</ul>
<h2><a id="viewpager%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewPager的适配器</h2>
<p>简介中提到了PagerAdapter，和ListView等控件使用一样,需要ViewPager设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是一个基类适配器，我们经常用它来实现app引导图，它的子类有FragmentPagerAdapter和FragmentStatePagerAdapter,这两个子类适配器用于和Fragment一起使用，在安卓应用中它们就像listview一样出现的频繁。</p>
<h3><a id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84pageradapter%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E5%9B%9B%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9C%A8%E4%BB%A3%E7%A0%81%E9%87%8C%E6%9C%89%E6%B3%A8%E9%87%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现一个最基本的PagerAdapter,必须实现四个方法，在代码里有注释</h3>
<pre><code class="language-java">public class AdapterViewpager extends PagerAdapter {
    private List&lt;View&gt; mViewList;

    public AdapterViewpager(List&lt;View&gt; mViewList) {
        this.mViewList = mViewList;
    }

    @Override
    public int getCount() {//必须实现,返回要滑动的VIew的个数
        return mViewList.size();
    }

    @Override
    public boolean isViewFromObject(View view, Object object) {//必须实现,该函数用来判断instantiateItem(ViewGroup, int)函数所返回来的Key与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View)
        return view == object;
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {//必须实现，做了两件事，第一：将当前视图添加到container中，第二：返回当前View
        container.addView(mViewList.get(position));
        return mViewList.get(position);
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {//必须实现，从当前container中删除指定位置（position）的View
        container.removeView(mViewList.get(position));
    }
}
</code></pre>
<h3><a id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84fragmentpageradapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现一个最基本的FragmentPagerAdapter</h3>
<pre><code class="language-java">public class AdapterFragment extends FragmentPagerAdapter {
    private List&lt;Fragment&gt; mFragments;

    public AdapterFragment(FragmentManager fm, List&lt;Fragment&gt; mFragments) {
        super(fm);
        this.mFragments = mFragments;
    }

    @Override
    public Fragment getItem(int position) {//必须实现
        return mFragments.get(position);
    }

    @Override
    public int getCount() {//必须实现
        return mFragments.size();
    }

    @Override
    public CharSequence getPageTitle(int position) {//选择性实现
        return mFragments.get(position).getClass().getSimpleName();
    }
}
</code></pre>
<p>PagerAdapter是基类适配器是一个通用的ViewPager适配器，相比PagerAdapter，FragmentPagerAdapter和FragmentStatePagerAdapter更专注于每一页是Fragment的情况，而这两个子类适配器使用情况也是有区别的。FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况。为什么？简单分析下两个适配器的源码就可以知道了。</p>
<p><strong>源码略，查官网</strong></p>
<p>从源码中我们可以看出FragmentStatePagerAdapter中fragment实例在destroyItem的时候被真正释放，所以FragmentStatePagerAdapter省内存。FragmentPagerAdapter中的fragment实例在destroyItem的时候并没有真正释放fragment对象只是detach，所以FragmentPagerAdapter消耗更多的内存，带来的好处就是效率更高一些。所以得出这样的结论：FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况，因此不同的场合选择合适的适配器才是正确的做法。</p>
<h2><a id="viewpager%E7%9A%84%E7%BF%BB%E9%A1%B5%E5%8A%A8%E7%94%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewPager的翻页动画</h2>
<p>为ViewPager设置适配器后，就可以正常使用了，接下来我们为ViewPager增加翻页动画，毕竟人的审美会疲劳，加上一些动画交互会提高不少逼格~~，ViewPager提供了PageTransformer接口用于实现翻页动画。官方提供了PageTransformer的实现例子。</p>
<h3><a id="%E4%BE%8B%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>例一</h3>
<pre><code class="language-java"> public class DepthPageTransformer implements ViewPager.PageTransformer {
    private static final float MIN_SCALE = 0.75f;

    public void transformPage(View view, float position) {
        Log.d(&quot;DepthPageTransformer&quot;, view.getTag() + &quot; , &quot; + position + &quot;&quot;);
        int pageWidth = view.getWidth();

        if (position &lt; -1) { // [-Infinity,-1)
            // This page is way off-screen to the left.
            view.setAlpha(0);

        } else if (position &lt;= 0) { // [-1,0]
            // Use the default slide transition when moving to the left page
            view.setAlpha(1);
            view.setTranslationX(0);
            view.setScaleX(1);
            view.setScaleY(1);

        } else if (position &lt;= 1) { // (0,1]
            // Fade the page out.
            view.setAlpha(1 - position);

            // Counteract the default slide transition
            view.setTranslationX(pageWidth * -position);

            // Scale the page down (between MIN_SCALE and 1)
            float scaleFactor = MIN_SCALE
                    + (1 - MIN_SCALE) * (1 - Math.abs(position));
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);

        } else { // (1,+Infinity]
            // This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}
</code></pre>
<h3><a id="%E4%BE%8B%E4%BA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>例二</h3>
<pre><code class="language-java"> public class ZoomOutPageTransformer implements ViewPager.PageTransformer {
    private static final float MIN_SCALE = 0.85f;
    private static final float MIN_ALPHA = 0.5f;

    @SuppressLint(&quot;NewApi&quot;)
    public void transformPage(View view, float position) {
        int pageWidth = view.getWidth();
        int pageHeight = view.getHeight();

        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);

        if (position &lt; -1) { // [-Infinity,-1)
            // This page is way off-screen to the left.
            view.setAlpha(0);

        } else if (position &lt;= 1) 
        { // [-1,1]
            // Modify the default slide transition to shrink the page as well
            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
            float vertMargin = pageHeight * (1 - scaleFactor) / 2;
            float horzMargin = pageWidth * (1 - scaleFactor) / 2;
            if (position &lt; 0) {
                view.setTranslationX(horzMargin - vertMargin / 2);
            } else {
                view.setTranslationX(-horzMargin + vertMargin / 2);
            }

            // Scale the page down (between MIN_SCALE and 1)
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);

            // Fade the page relative to its size.
            view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE)
                    / (1 - MIN_SCALE) * (1 - MIN_ALPHA));

        } else { // (1,+Infinity]
            // This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}
</code></pre>
<p>实现翻页动画的关键就是重写transformPage方法，方法里有两个参数view和position,理解这两个参数非常重要。假设有三个页面view1，view2，view3从左至右在viewPager中显示</p>
<ul>
<li>往左滑动时：view1，view2，view3的position都是不断变小的。</li>
</ul>
<pre><code class="language-plain_text">               view1的position: 0 → -1 → 负无穷大
               view2的position: 1 → 0 → -1 
               view3的position: 1 → 0
</code></pre>
<ul>
<li>往右滑动时：view1，view2，view3的position都是不断变大的。</li>
</ul>
<pre><code class="language-plain_text">               view1的position: -1 → 0 
               view2的position: -1 → 0 → 1 
               view3的position: 0 → 1→ 正无穷大
</code></pre>
<p>当position是正负无穷大时view就离开屏幕视野了。因此最核心的控制逻辑是在[-1,0]和(0,1]这两个区间，通过设置透明度，平移，旋转，缩放等动画组合可以实现各式各样的页面变化效果。</p>
<h3><a id="%E7%AE%80%E5%8C%96viewpager%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简化ViewPager的使用</h3>
<ul>
<li>PagerAdapter简化</li>
</ul>
<pre><code class="language-java">public class QuickPageAdapter&lt;T extends View&gt; extends PagerAdapter {
  private List&lt;T&gt; mList;

  public QuickPageAdapter(List&lt;T&gt; mList) {
      this.mList = mList;
  }

  @Override
  public int getCount() {
      return mList.size();
  }

  @Override
  public boolean isViewFromObject(View view, Object object) {
      return object == view;
  }

  @Override
  public Object instantiateItem(ViewGroup container, int position) {
      container.addView(mList.get(position));
      return mList.get(position);
  }

  @Override
  public void destroyItem(ViewGroup container, int position, Object object) {
      container.removeView(mList.get(position));
  }
}
</code></pre>
<p>使用它，这样不用每次都写个适配器List<View> views = new ArrayList&lt;&gt;();...mViewPager.setAdapter(new QuickPageAdapter<View>(views));</p>
<ul>
<li>FragmentPagerAdapter简化</li>
</ul>
<pre><code class="language-java">public class QuickFragmentPageAdapter&lt;T extends Fragment&gt; extends FragmentPagerAdapter {
  private List&lt;T&gt; mList;
  private String[] mStrings;

  /**
   * @param fm
   * @param list
   * @param titles PageTitles
   */
  public QuickFragmentPageAdapter(FragmentManager fm, List&lt;T&gt; list, String[] titles) {
      super(fm);
      mList = list;
      mStrings = titles;
  }

  @Override
  public Fragment getItem(int position) {
      return mList.get(position);
  }

  @Override
  public int getCount() {
      return mList.size();
  }

  @Override
  public CharSequence getPageTitle(int position) {
      return mStrings == null ? super.getPageTitle(position) : mStrings[position];
  }
}
</code></pre>
<h2><a id="pagertitlestrip" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PagerTitleStrip</h2>
<ul>
<li>将它作为子控件添加在xml布局文件中的ViewPager中</li>
<li>标题的获取，是重写适配器的getPageTitle(int)函数来获取的。</li>
</ul>
<p>重写CharSequence <code>getPageTitle(int)</code>函数来对其进行实现</p>
<h2><a id="pagertabstrip" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PagerTabStrip</h2>
<ul>
<li>PagerTabStrip在当前页面下，会有一个下划线条来提示当前页面的Tab是哪个。</li>
<li>PagerTabStrip的Tab是可以点击的，当用户点击某一个Tab时，当前页面就会跳转到这个页面，而PagerTitleStrip则没这个功能。</li>
<li>将它作为子控件添加在xml布局文件中的ViewPager中</li>
<li>标题的获取，是重写适配器的getPageTitle(int)函数来获取的。</li>
</ul>
<h3><a id="%E6%89%A9%E5%B1%95%EF%BC%9Apagertabstrip%E5%B1%9E%E6%80%A7%E6%9B%B4%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩展：PagerTabStrip属性更改</h3>
<p><code>setTabIndicatorColorResource</code>——修改Tab颜色<br />
重写适配器CharSequence getPageTitle(int)方法——添加标题</p>
<h3><a id="%E6%80%BB%E7%BB%93pagertitlestrip%E5%92%8Cpagertabstrip" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结PagerTitleStrip和PagerTabStrip</h3>
<p>通过前面的讲解，我们应该清楚的认识到PagerTabStrip与PagerTitleStrip在添加标题栏的异同，但他们实现的标题栏效果很不好，不能指定一个页面一次显示一个，或者全部显示，而且标题还滑动。所以注定主流的App都没有用这个玩意的。所以这里也只是一个过渡，在开发中，我们也不建议使用这两个东东。</p>
<h2><a id="simpleonpagechangelistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SimpleOnPageChangeListener</h2>
<p>如果不想继承实现<code>ViewPager.OnPageChangeListener</code>的方法，可以直接继承SimpleOnPageChangeListener对ViewPager的页面滑动事件进行简单的处理。</p>
<ul>
<li>
<p><strong>onPageScrolled] (int position, float positionOffset, int positionOffsetPixels)：</strong></p>
<ul>
<li>position:当前的位置</li>
<li>positionoffset:当前滚动比例（左－右／0-1）（右－左／1-0）</li>
<li>positionOffsetPixels：当前实际滚动的像素（左－右／0-页宽） （右－左／页宽－0）<br />
被调用的场景： ViewPager滚动时总被回调，这个函数在操作ViewPager时被回调很多次。</li>
</ul>
</li>
<li>
<p>手指拖动 action_move 。n次</p>
</li>
<li>
<p>惯性还原 computeScroll()。n次<br />
使用场景：做view的动画效果时可以用这个回调函数。</p>
</li>
<li>
<p><strong>onPageSelected(int position)</strong><br />
被调用的场景：ViewPager确定页面是哪一页时。1次</p>
</li>
<li>
<p>手指拖动后抬起 action_up 。1次</p>
</li>
<li>
<p>或者手指滑动超出屏幕时 action_cancel。1次<br />
使用场景：页面切换后改变对应的tab的状态可以用这个回调函数。</p>
</li>
<li>
<p><strong>onPageScrollStateChange (int state):</strong><br />
被调用的场景：ViewPager状态切换时被调用。这个函数在操作ViewPager时被回调3次。</p>
<ul>
<li>开始滚动 dragging拖动状态。1次</li>
<li>惯性滚动 settling还原状态。1次</li>
<li>滚动结束 idle空闲状态。1次<br />
使用场景：做页面状态变化后引起的view特效时可以用这个回调函数</li>
</ul>
</li>
</ul>
<h2><a id="viewpager-onpagechangelistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewPager.OnPageChangeListener</h2>
<ul>
<li><code>onPageScrollStateChanged(int state)</code>//在状态改变的时候调用其中arg0这个参数有三种状态（0，1，2）。arg0 ==1表示正在滑动，arg0==2表示滑动完毕了，arg0==0表示什么都没做。当页面开始滑动的时候，三种状态的变化顺序为(1,2,0)</li>
<li><code>onPageScrolled(int position, float positionOffset, int positionOffsetPixels)</code>//当页面在滑动的时候会调用此方法，在滑动被停止之前，此方法回一直得到调用。其中三个参数的含义分别为：arg0 :当前页面，及你点击滑动的页面。arg1:当前页面偏移的百分比。arg2:当前页面偏移的像素位置</li>
<li><code>onPageSelected(int position)</code>//页面跳转完后得到调用，arg0是你当前选中的页面的position</li>
</ul>
<h2><a id="viewpager-onadapterchangelistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewPager.OnAdapterChangeListener</h2>
<p><code>void onAdapterChanged ( ViewPagerew viewPager, PagerAdapter oldAdapter,PagerAdapter newAdapter)</code></p>
<ul>
<li>viewPager:  ViewPager where the adapter change has happened(传入发生改变的ViewPager)</li>
<li>oldAdapter: the previously set adapter(老的adapter)</li>
<li>newAdapter: the newly set adapter(新的adapter)</li>
</ul>
<h2><a id="%E6%B3%A8%E6%84%8F%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意点</h2>
<p><code>mViewPager.setOffscreenPageLimit()</code>//这个方法是用来控制fragment不重新走生命周期的个数的，打个比方一共4个fragment页面，如果<code>mViewPager.setOffscreenPageLimit(3)</code>，那么所有的fragment都只走一次生命周期，如果是<code>mViewPager.setOffscreenPageLimit(2)</code>，那么其中有一个fragment会在切换的时候重新走一遍生命周期，<code>FragmentStatePagerAdapter</code>和<code>FragmentPagerAdapter</code>都是这样，但是<code>FragmentPagerAdapter</code>设置<code>setOffscreenPageLimit()</code>不影响fragment缓存的个数,而<code>FragmentStatePagerAdapter</code>缓存的fragment实例个数就是<code>setOffscreenPageLimit()</code>设置的值+1。另外<code>setOffscreenPageLimit()</code>的缺省值是1，设置0是无效的会被强制赋值成1。</p>
<h2><a id="%E6%8F%90%E9%AB%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提高</h2>
<h3><a id="viewpager%E7%BB%93%E5%90%88%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%B0%8F%E5%9C%86%E7%82%B9%E6%8C%87%E7%A4%BA%E5%99%A8%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewPager结合第三方库实现小圆点指示器效果</h3>
<p><a href="https://github.com/ongakuer/CircleIndicator">https://github.com/ongakuer/CircleIndicator</a></p>
<p><img src="media/15561207869583/20170221497391480849-687604baae5b6559.gif" alt="" /></p>
<p>使用看官方文档很简单。</p>
<p><strong>看一下实现思路</strong></p>
<pre><code class="language-java">public void setViewPager(ViewPager viewPager) {
        mViewpager = viewPager;
        if (mViewpager != null &amp;&amp; mViewpager.getAdapter() != null) {
            mLastPosition = -1;
            createIndicators();
            mViewpager.removeOnPageChangeListener(mInternalPageChangeListener);
            mViewpager.addOnPageChangeListener(mInternalPageChangeListener);//绑定上内部实现的PageChangeListener
            mInternalPageChangeListener.onPageSelected(mViewpager.getCurrentItem());
        }
    }

    private final OnPageChangeListener mInternalPageChangeListener = new OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        }

        @Override public void onPageSelected(int position) {//这里是动画的核心

            if (mViewpager.getAdapter() == null || mViewpager.getAdapter().getCount() &lt;= 0) {
                return;
            }

            if (mAnimatorIn.isRunning()) {
                mAnimatorIn.end();
                mAnimatorIn.cancel();
            }

            if (mAnimatorOut.isRunning()) {
                mAnimatorOut.end();
                mAnimatorOut.cancel();
            }

            View currentIndicator;
            if (mLastPosition &gt;= 0 &amp;&amp; (currentIndicator = getChildAt(mLastPosition)) != null) {//页面离开屏幕时指示器动画
                currentIndicator.setBackgroundResource(mIndicatorUnselectedBackgroundResId);
                mAnimatorIn.setTarget(currentIndicator);
                mAnimatorIn.start();
            }

            View selectedIndicator = getChildAt(position);
            if (selectedIndicator != null) {//页面进入屏幕时指示器动画
                selectedIndicator.setBackgroundResource(mIndicatorBackgroundResId);
                mAnimatorOut.setTarget(selectedIndicator);
                mAnimatorOut.start();
            }
            mLastPosition = position;
        }

        @Override public void onPageScrollStateChanged(int state) {
        }
    };
</code></pre>
<h3><a id="viewpager%E7%BB%93%E5%90%88design%E5%BA%93%E5%AE%9E%E7%8E%B0tab%E5%88%87%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewPager结合design库实现tab切换</h3>
<p>在design库中有个TabLayout可以为viewPager加上Tab标题头</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;com.example.administrator.viewpager.MainActivity&quot;&gt;

    &lt;android.support.design.widget.TabLayout
        android:id=&quot;@+id/mTabLayout&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;&lt;/android.support.design.widget.TabLayout&gt;

    &lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/mViewPager&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;&lt;/android.support.v4.view.ViewPager&gt;

&lt;/LinearLayout&gt;

mTabLayout.setupWithViewPager(mViewPager);//一行代码完成绑定
</code></pre>
<p>更多高级的用法包括tab中添加icon等请转至这里<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0731/3247.html">传送门</a></p>
<h3><a id="%E5%9F%BA%E4%BA%8Eviewpager%E5%AE%9E%E7%8E%B0%E5%B9%BF%E5%91%8A%E8%BD%AE%E6%92%AD%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于ViewPager实现广告轮播控件</h3>
<p><a href="https://github.com/daimajia/AndroidImageSlider">https://github.com/daimajia/AndroidImageSlider</a></p>
<p><img src="media/15561207869583/20170221497391480849-687604baae5b6559.gif" alt="" /></p>
<p><strong>源码分析，省略了部分代码</strong>：</p>
<pre><code class="language-java">public class SliderLayout extends RelativeLayout{

    private InfiniteViewPager mViewPager;//这个ViewPager只是修改了setPageTransformer方法去掉了if (Build.VERSION.SDK_INT &gt;= 11) 的限制，结合NineOldDroid库让动画兼容低版本

    /**
     * InfiniteViewPager adapter.
     */
    private SliderAdapter mSliderAdapter;//这个是PagerAdapter

    /**
     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} indicator.
     */
    private PagerIndicator mIndicator;//页面指示器


    /**
     * A timer and a TimerTask using to cycle the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}.
     */
    private Timer mCycleTimer;//用于轮播的定时器
    private TimerTask mCycleTask;

    /**
     * For resuming the cycle, after user touch or click the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}.
     */
    private Timer mResumingTimer;
    private TimerTask mResumingTask;

    /**
     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} 's transformer
     */
    private BaseTransformer mViewPagerTransformer;//PageTransformer的封装用于控制页面翻页效果

    public SliderLayout(Context context, AttributeSet attrs, int defStyle) {//核心代码，用于初始化ViewPager
        super(context, attrs, defStyle);
        mContext = context;
        LayoutInflater.from(context).inflate(R.layout.slider_layout, this, true);

        final TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs,R.styleable.SliderLayout,
                defStyle,0);

        mTransformerSpan = attributes.getInteger(R.styleable.SliderLayout_pager_animation_span, 1100);
        mTransformerId = attributes.getInt(R.styleable.SliderLayout_pager_animation, Transformer.Default.ordinal());
        mAutoCycle = attributes.getBoolean(R.styleable.SliderLayout_auto_cycle,true);
        int visibility = attributes.getInt(R.styleable.SliderLayout_indicator_visibility,0);
        for(PagerIndicator.IndicatorVisibility v: PagerIndicator.IndicatorVisibility.values()){
            if(v.ordinal() == visibility){
                mIndicatorVisibility = v;
                break;
            }
        }
        mSliderAdapter = new SliderAdapter(mContext);
        PagerAdapter wrappedAdapter = new InfinitePagerAdapter(mSliderAdapter);

        mViewPager = (InfiniteViewPager)findViewById(R.id.daimajia_slider_viewpager);
        mViewPager.setAdapter(wrappedAdapter);

        mViewPager.setOnTouchListener(new OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                int action = event.getAction();
                switch (action) {
                     case MotionEvent.ACTION_UP:
                        recoverCycle();
                        break;
                }
                return false;
            }
        });

        attributes.recycle();
        setPresetIndicator(PresetIndicators.Center_Bottom);
        setPresetTransformer(mTransformerId);
        setSliderTransformDuration(mTransformerSpan,null);
        setIndicatorVisibility(mIndicatorVisibility);
        if(mAutoCycle){
            startAutoCycle();
        }
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        int action = ev.getAction();
        switch (action) {
            case MotionEvent.ACTION_DOWN://手指按下时候暂停轮播
                pauseAutoCycle();
                break;
        }
        return false;
    }

    /**
     * preset transformers and their names
     */
    public enum Transformer{//PageTransformer枚举
        Default(&quot;Default&quot;),
        Accordion(&quot;Accordion&quot;),
        Background2Foreground(&quot;Background2Foreground&quot;),
        CubeIn(&quot;CubeIn&quot;),
        DepthPage(&quot;DepthPage&quot;),
        Fade(&quot;Fade&quot;),
        FlipHorizontal(&quot;FlipHorizontal&quot;),
        FlipPage(&quot;FlipPage&quot;),
        Foreground2Background(&quot;Foreground2Background&quot;),
        RotateDown(&quot;RotateDown&quot;),
        RotateUp(&quot;RotateUp&quot;),
        Stack(&quot;Stack&quot;),
        Tablet(&quot;Tablet&quot;),
        ZoomIn(&quot;ZoomIn&quot;),
        ZoomOutSlide(&quot;ZoomOutSlide&quot;),
        ZoomOut(&quot;ZoomOut&quot;);

        private final String name;

        private Transformer(String s){
            name = s;
        }
        public String toString(){
            return name;
        }

        public boolean equals(String other){
            return (other == null)? false:name.equals(other);
        }
    };
}
</code></pre>
<p><strong>通过分析我们可以对SliderLayout实现思路小结一下：</strong></p>
<ol>
<li>内部持有一个修改过的ViewPager控件，可以兼容低版本的页面转换动画</li>
<li>内部有一个实现了PagerAdapter的SliderAdapter适配器</li>
<li>内部持有一个PagerIndicator 页面指示器可供选择</li>
<li>维护一个定时任务用于控制轮播</li>
<li>对手势事件进行处理暂停轮播，继续轮播</li>
<li>提供了很多缺省的PageTransformer方便调用</li>
</ol>
<p>最后在构造函数中初始化ViewPager。</p>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89viewpager%E6%89%93%E9%80%A0%E5%8D%83%E5%8F%98%E4%B8%87%E5%8C%96%E7%9A%84%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义 ViewPager 打造千变万化的图片切换效果</h2>
<p>ViewPager使用时间长了，他的切换效果容易觉得枯燥，形成一种审美疲劳<del>我们需要改变，学习学习改变ViewPager切换时的效果，实现个性化的图片切换</del></p>
<p><img src="media/15561207869583/20170222778011406001554_7159.gif" alt="" /></p>
<p>是不是比传统的效果个性很多，嘿嘿<del>其实很简单，学习完这篇博客，保证你可以自定义切换效果，做出各种丧心病狂的切换</del></p>
<h3><a id="%E5%88%B6%E4%BD%9C%E5%89%8D%E7%9A%84%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>制作前的分析</h3>
<p>观察下效果图，实际上改变的就是切换时的动画，那么简单了，只需要用户在切换时，拿到当前的View和下一个View，然后添加动画是不是就可以了。好，第一步，获取用户切换时的当前View和切换至的目的View。我们再来看一下，如果获取了当前View和目的View，对于动画我们需要缓慢的变化，最好是根据用户的手势滑动。比如上述效果，用户滑动时，目的图片根据用户滑动距离缓缓出现和慢慢变大。好，第二步，设计动画的梯度变化。<br />
经过分析，我们总结出两个步骤，下面我们开始一步一步来打造~~</p>
<h3><a id="%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%88%87%E6%8D%A2%E6%97%B6%E5%BD%93%E5%89%8Dview%E5%92%8C%E5%88%87%E6%8D%A2%E8%87%B3%E7%9A%84%E7%9B%AE%E7%9A%84view%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取用户切换时当前View和切换至的目的View。</h3>
<p>ViewPager也需要监听用户的手势，所以肯定提供了某个方法。于是纵观ViewPager的方法，发现了一个叫做 onPageScrolled(int position, float positionOffset, int positionOffsetPixels)的方法~~<br />
没错就是这个方法：在页面滚动时调用~<br />
下面仔细研究下这几个参数：<br />
直接说测试结果：<br />
在非第一页与最后一页时，滑动到下一页，position为当前页位置；滑动到上一页：position为当前页-1<br />
positionOffset 滑动到下一页，[0,1)区间上变化；滑动到上一页：(1,0]区间上变化<br />
positionOffsetPixels这个和positionOffset很像：滑动到下一页，[0,宽度)区间上变化；滑动到上一页：(宽度,0]区间上变化<br />
第一页时：滑动到上一页position=0 ，其他基本为0 ；最后一页滑动到下一页 position为当前页位置，其他两个参数为0<br />
豁然发现，我们需要的步骤的第二步解决了，positionOffset很适合作为，渐变，缩放的控制参数；positionOffsetPixels则可以作为平移等的控制参数。</p>
<p><em><strong>那么如何获得当前View和目的View呢：</strong></em><br />
分享几个我的歧途：</p>
<ul>
<li>【错误】我通过getChildAt(position)，getChildAt(position+1)，getChildAt(position-1)获得滑动时，左右的两个View；乍一看，还真觉得不错<del>在代码写出来，再乍效果也出不来</del>错误原因：我们忽略一个特别大的东西，ViewPager的机制，滑动时动态加载和删除View，ViewPager其实只会维持2到3个View，而position的范围基本属于无限~~</li>
<li>【错误】我通过getCurrentItem获得当前的位置，然后+1，-1获得后一个或者前一个<del>正在窃喜，赶快代码改过来，效果怎么也不对，乱七八糟的</del>仔细观察日志，这个getCurrentItem当用户手指离开的屏幕，Page还在动画执行时，就改变了<del>难怪~整个滑动过程并不是固定的</del>唉，心都碎了~</li>
<li>【错误】position在整个滑动的过程中是不变化的，而且ViewPager会保存2个或3个View;那么我考虑，如果是第一页、或者最后一页那么我取getChildAt(0)和getChildAt(1)，如果在其他页面则为getChildAt(0),getChildAt(2),然后经过一系列的变化～我想这会总该对了吧，于是我遇到第一问题，第一页的时候，不管左右position都为0，尼玛，这哪个为左View，哪个为右View~~<br />
说了这么多错误，大家可以绕过这些弯路，也能从这些弯路里面看出点什么~<br />
下面说正确的，其实ViewPager在添加一个View或者销毁一个View时，是我们自己的PageAdapter中控制的，于是我们可以在ViewPager里面维系一个HashMap&lt;Position，View&gt;，然后滑动的时候，通过get（position）取出，比如上述效果，始终是右边的View变化，要么从小到大，要么从大到小<br />
那么滑倒下一页：左边的View:map.get(position) ，右边的View : map.get(position+1) .<br />
那么滑倒上一页：左边的View : map.get(position) ， 右边的View : map.get(position+1) ， 一样的，因为滑到上一页，position为当前页-1<br />
好了，至此，我们分析了且解决了所有步骤。</li>
</ul>
<h3><a id="%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码</h3>
<p><strong>MainActivity</strong></p>
<pre><code class="language-java">package com.example.zhy_jazzyviewpager;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.view.Menu;  
import android.view.View;  
import android.view.ViewGroup;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    protected static final String TAG = &quot;MainActivity&quot;;  
    private int[] mImgIds;  
    private MyJazzyViewPager mViewPager;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        mImgIds = new int[] { R.drawable.a, R.drawable.b, R.drawable.c,  
                R.drawable.d };  
        mViewPager = (MyJazzyViewPager) findViewById(R.id.id_viewPager);  
        mViewPager.setAdapter(new PagerAdapter()  
        {  
  
            @Override  
            public boolean isViewFromObject(View arg0, Object arg1)  
            {  
                return arg0 == arg1;  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
                container.removeView((View) object);  
            }  
  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
                ImageView imageView = new ImageView(MainActivity.this);  
                imageView.setImageResource(mImgIds[position]);  
                imageView.setScaleType(ScaleType.CENTER_CROP);  
                container.addView(imageView);  
                mViewPager.setObjectForPosition(imageView, position);  
                return imageView;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
  
}
</code></pre>
<p>这个很常见的代码，就是初始化ViewPager<del>就没啥可说的了</del>有一点需要注意：在instantiateItem方法，我们多调用了一个mViewPager.setObjectForPosition(imageView, position);其实就是为了给我们的Map存值</p>
<p><strong>主要看自定义的ViewPager</strong></p>
<pre><code class="language-java">package com.example.zhy_jazzyviewpager;  
  
import java.util.HashMap;  
import java.util.LinkedHashMap;  
  
import android.content.Context;  
import android.support.v4.view.ViewPager;  
import android.util.AttributeSet;  
import android.util.Log;  
import android.view.View;  
  
import com.nineoldandroids.view.ViewHelper;  
  
public class MyJazzyViewPager extends ViewPager  
{  
    private float mTrans;  
    private float mScale;  
    /** 
     * 最大的缩小比例 
     */  
    private static final float SCALE_MAX = 0.5f;  
    private static final String TAG = &quot;MyJazzyViewPager&quot;;  
    /** 
     * 保存position与对于的View 
     */  
    private HashMap&lt;Integer, View&gt; mChildrenViews = new LinkedHashMap&lt;Integer, View&gt;();  
    /** 
     * 滑动时左边的元素 
     */  
    private View mLeft;  
    /** 
     * 滑动时右边的元素 
     */  
    private View mRight;  
  
    public MyJazzyViewPager(Context context, AttributeSet attrs)  
    {  
        super(context, attrs);  
    }  
  
    @Override  
    public void onPageScrolled(int position, float positionOffset,  
            int positionOffsetPixels)  
    {  
  
//      Log.e(TAG, &quot;position=&quot; + position+&quot;, positionOffset = &quot;+positionOffset+&quot; ,positionOffsetPixels =  &quot; + positionOffsetPixels+&quot; , currentPos = &quot; + getCurrentItem());  
          
        //滑动特别小的距离时，我们认为没有动，可有可无的判断  
        float effectOffset = isSmall(positionOffset) ? 0 : positionOffset;  
          
        //获取左边的View  
        mLeft = findViewFromObject(position);  
        //获取右边的View  
        mRight = findViewFromObject(position + 1);  
          
        // 添加切换动画效果  
        animateStack(mLeft, mRight, effectOffset, positionOffsetPixels);  
        super.onPageScrolled(position, positionOffset, positionOffsetPixels);  
    }  
  
    public void setObjectForPosition(View view, int position)  
    {  
        mChildrenViews.put(position, view);  
    }  
  
    /** 
     * 通过过位置获得对应的View 
     *  
     * @param position 
     * @return 
     */  
    public View findViewFromObject(int position)  
    {  
        return mChildrenViews.get(position);  
    }  
  
    private boolean isSmall(float positionOffset)  
    {  
        return Math.abs(positionOffset) &lt; 0.0001;  
    }  
  
    protected void animateStack(View left, View right, float effectOffset,  
            int positionOffsetPixels)  
    {  
        if (right != null)  
        {  
            /** 
             * 缩小比例 如果手指从右到左的滑动（切换到后一个）：0.0~1.0，即从一半到最大 
             * 如果手指从左到右的滑动（切换到前一个）：1.0~0，即从最大到一半 
             */  
            mScale = (1 - SCALE_MAX) * effectOffset + SCALE_MAX;  
            /** 
             * x偏移量： 如果手指从右到左的滑动（切换到后一个）：0-720 如果手指从左到右的滑动（切换到前一个）：720-0 
             */  
            mTrans = -getWidth() - getPageMargin() + positionOffsetPixels;  
            ViewHelper.setScaleX(right, mScale);  
            ViewHelper.setScaleY(right, mScale);  
            ViewHelper.setTranslationX(right, mTrans);  
        }  
        if (left != null)  
        {  
            left.bringToFront();  
        }  
    }  
}
</code></pre>
<p>可以看到，核心代码都是onPageScrolled，我们通过findViewFromObject(position); findViewFromObject(position + 1);分别获取了左右两边的View，然后添加动画效果；当前这个例子添加了两个动画，一个是从0.5放大到1.0或者1.0缩小到0.5，没错由我们的positionOffset提供梯度的变化<del>还有个平移的动画：下一页直接移动到当前屏幕（默认是在右边，可以注释这个效果，怎么运行看看），然后不断的通过positionOffsetPixels抵消原来默认移动时的位移，让用户感觉它就在原地放大缩小</del><br />
好了，这样就实现了<del>你可以随便写自己喜欢的动画效果，比如在默认上面加个淡入淡出或者神马，随便</del>是不是很随意~~<br />
我们的布局文件：</p>
<pre><code class="language-xml">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
  &gt;  
  
    &lt;com.example.zhy_jazzyviewpager.MyJazzyViewPager  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:id=&quot;@+id/id_viewPager&quot; /&gt;  
  
&lt;/RelativeLayout&gt; 
</code></pre>
<h3><a id="jazzyviewpager%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>JazzyViewPager的使用</h3>
<p>其实上面的实现就是github上JazzyViewPager的源码，用法不用说了，就是我们的MainActivity，它内置了大概10来种效果，我们可以通过代码或者布局上面设置动画效果<del>我们上面的例子效果，它叫做Stack；<br />
使用JazzViewPager的代码：其实基本一样</del>最后也会贴上JazzyViewPager的源码的下载</p>
<p><strong>MainActivity</strong></p>
<pre><code class="language-java">package com.jfeinstein.jazzyviewpager;  
  
import com.jfeinstein.jazzyviewpager.JazzyViewPager.TransitionEffect;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.view.View;  
import android.view.ViewGroup;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    protected static final String TAG = &quot;MainActivity&quot;;  
    private int[] mImgIds;  
    private JazzyViewPager mViewPager;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        mImgIds = new int[] { R.drawable.a, R.drawable.b, R.drawable.c,  
                R.drawable.d };  
        mViewPager = (JazzyViewPager) findViewById(R.id.id_viewPager);  
        //设置切换效果  
        mViewPager.setTransitionEffect(TransitionEffect.Stack);  
          
          
        mViewPager.setAdapter(new PagerAdapter()  
        {  
  
            @Override  
            public boolean isViewFromObject(View arg0, Object arg1)  
            {  
                return arg0 == arg1;  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
                container.removeView((View) object);  
            }  
  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
                ImageView imageView = new ImageView(MainActivity.this);  
                imageView.setImageResource(mImgIds[position]);  
                imageView.setScaleType(ScaleType.CENTER_CROP);  
                container.addView(imageView);  
                mViewPager.setObjectForPosition(imageView, position);  
                return imageView;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
}
</code></pre>
<p>与我们的代码唯一区别就是：<br />
//设置切换效果<br />
mViewPager.setTransitionEffect(TransitionEffect.Stack);<br />
它有12中可选的切换效果，其实就是写了12个切换的动画~~~<br />
好了，最后附上一个我比较喜欢的效果：Tablet</p>
<p><img src="media/15561207869583/201702229727320140722145522928.gif" alt="" /></p>
<h2><a id="%E5%AE%9E%E7%8E%B0%E4%B8%AA%E6%80%A7%E7%9A%84viewpager%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB%E5%AE%9E%E6%88%98-pagetransformer%EF%BC%88%E5%85%BC%E5%AE%B9android3-0%E4%BB%A5%E4%B8%8B%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现个性的ViewPager切换动画 实战PageTransformer（兼容Android3.0以下）</h2>
<h3><a id="%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概述</h3>
<p>本篇博文，将：</p>
<ol>
<li>介绍如何使用setPageTransformer设置切换动画；</li>
<li>自定义PageTransformer实现个性的切换动画；</li>
<li>该方法在SDK11以下的版本不起作用，我们会对其做一定修改，让其向下兼容。<br />
官方示例地址：<a href="http://developer.Android.com/training/animation/screen-slide.html">http://developer.Android.com/training/animation/screen-slide.html</a> 有兴趣的可以去看看~~</li>
</ol>
<h3><a id="setpagetransformer%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setPageTransformer的使用</h3>
<p>首先我们迅速的实现一个传统的ViewPager效果~</p>
<h4><a id="%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>布局文件</h4>
<pre><code class="language-xml">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot; &gt;  
  
    &lt;android.support.v4.view.ViewPager  
        android:id=&quot;@+id/id_viewpager&quot;  
        android:layout_width=&quot;fill_parent&quot;  
        android:layout_height=&quot;fill_parent&quot; /&gt;  
  
&lt;/RelativeLayout&gt;
</code></pre>
<h4><a id="mainactivity" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MainActivity</h4>
<pre><code class="language-java">package com.zhy.demo_zhy_08_viewpageranim;  
  
import java.util.ArrayList;  
import java.util.List;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.support.v4.view.ViewPager;  
import android.view.View;  
import android.view.ViewGroup;  
import android.view.Window;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    private ViewPager mViewPager;  
    private int[] mImgIds = new int[] { R.drawable.guide_image1,  
            R.drawable.guide_image2, R.drawable.guide_image3 };  
    private List&lt;ImageView&gt; mImageViews = new ArrayList&lt;ImageView&gt;();  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        setContentView(R.layout.activity_main);  
  
        initData();  
  
        mViewPager = (ViewPager) findViewById(R.id.id_viewpager);  
  
        mViewPager.setAdapter(new PagerAdapter()  
        {  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
  
                container.addView(mImageViews.get(position));  
                return mImageViews.get(position);  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
  
                container.removeView(mImageViews.get(position));  
            }  
  
            @Override  
            public boolean isViewFromObject(View view, Object object)  
            {  
                return view == object;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
  
    private void initData()  
    {  
        for (int imgId : mImgIds)  
        {  
            ImageView imageView = new ImageView(getApplicationContext());  
            imageView.setScaleType(ScaleType.CENTER_CROP);  
            imageView.setImageResource(imgId);  
            mImageViews.add(imageView);  
        }  
    }  
  
}
</code></pre>
<p>好了，这样一个传统ViewPager就实现了<del>大家对上面代码应该不会有任何陌生的感觉~运行效果也不用贴图了，大家肯定知道</del></p>
<h4><a id="pagetransformer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PageTransformer</h4>
<p>ViewPager有个方法叫做：<br />
<code>setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer)</code><br />
用于设置ViewPager切换时的动画效果，并且google官方还给出了两个示例。<br />
只需要在上述代码中调用setPageTransformer即可添加切换动画效果~~下面演示google的两个PageTransformer的代码，以及运行效果。</p>
<h5><a id="depthpagetransformer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>DepthPageTransformer</h5>
<pre><code class="language-java">
public class DepthPageTransformer implements ViewPager.PageTransformer {  
    private static final float MIN_SCALE = 0.75f;  
  
    public void transformPage(View view, float position) {  
        int pageWidth = view.getWidth();  
  
        if (position &lt; -1) { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            view.setAlpha(0);  
  
        } else if (position &lt;= 0) { // [-1,0]  
            // Use the default slide transition when moving to the left page  
            view.setAlpha(1);  
            view.setTranslationX(0);  
            view.setScaleX(1);  
            view.setScaleY(1);  
  
        } else if (position &lt;= 1) { // (0,1]  
            // Fade the page out.  
            view.setAlpha(1 - position);  
  
            // Counteract the default slide transition  
            view.setTranslationX(pageWidth * -position);  
  
            // Scale the page down (between MIN_SCALE and 1)  
            float scaleFactor = MIN_SCALE  
                    + (1 - MIN_SCALE) * (1 - Math.abs(position));  
            view.setScaleX(scaleFactor);  
            view.setScaleY(scaleFactor);  
  
        } else { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            view.setAlpha(0);  
        }  
    }  
}
</code></pre>
<p>调用代码：<br />
<code>mViewPager.setPageTransformer(true, new DepthPageTransformer());</code><br />
效果：</p>
<p><img src="media/15561207869583/201702227053520141028231742399.gif" alt="" /></p>
<h5><a id="zoomoutpagetransformer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ZoomOutPageTransformer</h5>
<pre><code class="language-java">package com.zhy.view;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.util.Log;  
import android.view.View;  
  
public class ZoomOutPageTransformer implements ViewPager.PageTransformer  
{  
    private static final float MIN_SCALE = 0.85f;  
    private static final float MIN_ALPHA = 0.5f;  
  
    @SuppressLint(&quot;NewApi&quot;)  
    public void transformPage(View view, float position)  
    {  
        int pageWidth = view.getWidth();  
        int pageHeight = view.getHeight();  
  
        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            view.setAlpha(0);  
  
        } else if (position &lt;= 1) //a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0  
        { // [-1,1]  
            // Modify the default slide transition to shrink the page as well  
            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));  
            float vertMargin = pageHeight * (1 - scaleFactor) / 2;  
            float horzMargin = pageWidth * (1 - scaleFactor) / 2;  
            if (position &lt; 0)  
            {  
                view.setTranslationX(horzMargin - vertMargin / 2);  
            } else  
            {  
                view.setTranslationX(-horzMargin + vertMargin / 2);  
            }  
  
            // Scale the page down (between MIN_SCALE and 1)  
            view.setScaleX(scaleFactor);  
            view.setScaleY(scaleFactor);  
  
            // Fade the page relative to its size.  
            view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE)  
                    / (1 - MIN_SCALE) * (1 - MIN_ALPHA));  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            view.setAlpha(0);  
        }  
    }  
}
</code></pre>
<p>调用代码：<br />
<code>mViewPager.setPageTransformer(true, new ZoomOutPageTransformer());</code></p>
<p>效果：</p>
<p><img src="media/15561207869583/201702224016820141028231715785.gif" alt="" /></p>
<p>效果图都是google官网上的，我们的测试图会在兼容3.0以下贴出来，不然就重复了~~<br />
为ViewPager添加切换就一行代码是不是很happy，可惜是不兼容3.0以下的版本的，该方法的注释上写到：<br />
setting a PageTransformer prior to Android 3.0 (API 11) will have no effect 在3.0之前的版本设置此方法是没有效果的，那么下面我们就看如何让其兼容3.0以下版本。</p>
<h3><a id="%E7%89%88%E6%9C%AC%E7%9A%84%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>版本的向下兼容</h3>
<h4><a id="%E4%B8%8D%E5%85%BC%E5%AE%B9%E7%9A%84%E5%8E%9F%E5%9B%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>不兼容的原因</h4>
<p>首先看下为什么不兼容，3.0以下呢？<br />
看上面的两个示例代码，代码中View的动画使用的是属性动画，而属性动画是3.0才推出的，那么这么写肯定是不兼容3.0以下了~<br />
那么我们首先引入nineoldandroids，让动画先能在3.0以下跑再说：<br />
修改DepthPageTransformer</p>
<pre><code class="language-java">package com.zhy.view;  
  
import com.nineoldandroids.view.ViewHelper;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.view.View;  
  
public class DepthPageTransformer implements ViewPager.PageTransformer  
{  
    private static final float MIN_SCALE = 0.75f;  
  
    public void transformPage(View view, float position)  
    {  
        int pageWidth = view.getWidth();  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            // view.setAlpha(0);  
            ViewHelper.setAlpha(view, 0);  
        } else if (position &lt;= 0)// a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0  
        { // [-1,0]  
            // Use the default slide transition when moving to the left page  
            // view.setAlpha(1);  
            ViewHelper.setAlpha(view, 1);  
            // view.setTranslationX(0);  
            ViewHelper.setTranslationX(view, 0);  
            // view.setScaleX(1);  
            ViewHelper.setScaleX(view, 1);  
            // view.setScaleY(1);  
            ViewHelper.setScaleY(view, 1);  
  
        } else if (position &lt;= 1)  
        { // (0,1]  
            // Fade the page out.  
            // view.setAlpha(1 - position);  
            ViewHelper.setAlpha(view, 1 - position);  
  
            // Counteract the default slide transition  
            // view.setTranslationX(pageWidth * -position);  
            ViewHelper.setTranslationX(view, pageWidth * -position);  
  
            // Scale the page down (between MIN_SCALE and 1)  
            float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - position);  
            // view.setScaleX(scaleFactor);  
            ViewHelper.setScaleX(view, scaleFactor);  
            // view.setScaleY(1);  
            ViewHelper.setScaleY(view, scaleFactor);  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            // view.setAlpha(0);  
            ViewHelper.setAlpha(view, 1);  
        }  
    }  
}
</code></pre>
<p>很简单，把所有属性动画换成ViewHelper去设置就好了。现在我们去3.0以下的机子上去运行，发现还是没有效果~~<br />
为什么呢？<br />
我们再去看看setPageTransformer的源码：</p>
<pre><code class="language-java">public void setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) {  
       if (Build.VERSION.SDK_INT &gt;= 11) {  
           final boolean hasTransformer = transformer != null;  
           final boolean needsPopulate = hasTransformer != (mPageTransformer != null);  
           mPageTransformer = transformer;  
           setChildrenDrawingOrderEnabledCompat(hasTransformer);  
           if (hasTransformer) {  
               mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;  
           } else {  
               mDrawingOrder = DRAW_ORDER_DEFAULT;  
           }  
           if (needsPopulate) populate();  
       }  
   }
</code></pre>
<p>终于发现原因了，原来在此方法内部判断了如果是11以上的版本才让动画生效~~<br />
那么，没办法了，如果想兼容，必须修改ViewPager的源码了~~</p>
<h4><a id="%E5%AE%8C%E7%BE%8E%E5%90%91%E4%B8%8B%E5%85%BC%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>完美向下兼容</h4>
<p>我们将ViewPager的源码拷贝一份至我们的项目中，修改名称为ViewPagerCompat；然后注释掉SDK版本判断那一句</p>
<pre><code class="language-java">public class ViewPagerCompat extends ViewGroup {  
	public void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer) {  
//        if (Build.VERSION.SDK_INT &gt;= 11)   
        {  
            final boolean hasTransformer = transformer != null;  
            final boolean needsPopulate = hasTransformer != (mPageTransformer != null);  
            mPageTransformer = transformer;  
            setChildrenDrawingOrderEnabledCompat(hasTransformer);  
            if (hasTransformer) {  
                mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;  
            } else {  
                mDrawingOrder = DRAW_ORDER_DEFAULT;  
            }  
            if (needsPopulate) populate();  
        }  
    }
 }
</code></pre>
<p>注意，所有的PageTransformer使用ViewPager.PageTransformer<br />
然后我们把项目中的ViewPager改为ViewPagerCompat；记得修改布局文件，以及MainActivity中的ViewPager为ViewPagerCompat<br />
我们在2.3.3的模拟器上测试下效果：</p>
<p><img src="media/15561207869583/201702225837420141028231840899.gif" alt="" /></p>
<p>可以看到，我们的切换动画完美的运行在2.3.3的机器上<del>so happy <del>没有ViewPager源码的童鞋不要紧，我会在文末的源码下载中加入ViewPager源码，让你可以尽情去测试</del><br />
当然了，仅仅是兼容当然不能满足我们的好奇心，难道我们做到了兼容，还只能使用Google给的示例动画么</del>我们强大的创新呢~~下面带领大家分析setPageTransformer方法，然后设计一个个性的动画切换效果</p>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89pagetransformer%E5%AE%9E%E7%8E%B0%E4%B8%AA%E6%80%A7%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义PageTransformer实现个性切换动画</h4>
<pre><code class="language-java">
public interface PageTransformer {  
       /** 
        * Apply a property transformation to the given page. 
        * 
        * @param page Apply the transformation to this page 
        * @param position Position of page relative to the current front-and-center 
        *                 position of the pager. 0 is front and center. 1 is one full 
        *                 page position to the right, and -1 is one page position to the left. 
        */  
       public void transformPage(View page, float position);  
   }
</code></pre>
<p>可以看到该接口只有一个方法，第一个是我们的view，第二个是position~~<br />
当我们滑动时：会打印出当然ViewPager中存活的每个View以及它们的position的变化<del>注意是每一个，所以建议别只log position，不然你会觉得莫名其妙的输出</del><br />
position的可能性的值有，其实从官方示例的注释就能看出：<br />
[-Infinity,-1)  已经看不到了<br />
(1,+Infinity] 已经看不到了<br />
[-1,1]<br />
重点看[-1,1]这个区间 ， 其他两个的View都已经看不到了~~</p>
<p>假设现在ViewPager在A页现在滑出B页，则:<br />
A页的position变化就是( 0, -1]<br />
B页的position变化就是[ 1 , 0 ]<br />
知道了我们滑动时position的变化~~那么就开始设计我们的个性的切换效果；<br />
官方给的例子，有变化透明度、偏移量、缩放的，我们准备来个不一样的，我们变化角度，即rotation;<br />
大概的效果是这样的：</p>
<p><img src="media/15561207869583/20170222949151414293422_1593.gif" alt="" /></p>
<p>下面我们分析代码：<br />
我们设置View的旋转中心为：<br />
ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);<br />
ViewHelper.setPivotY(view, view.getMeasuredHeight());<br />
依然是ViewPager在A页现在滑出B页<br />
那么A页应当在滑动过程中0度到-20度的偏移，B页应当在滑动过程中+20度到0度的偏移<br />
结合<br />
A页的position变化就是( 0, -1]<br />
B页的position变化就是[ 1 , 0 ]<br />
那么旋转的角度即：mRot = (20 * position); A页 mRot :0 ,~ -20 ; B页 mRot :20 ~ 0  ;<br />
瞬间觉得好简单：</p>
<p><strong>完整代码</strong>：</p>
<pre><code class="language-java">package com.zhy.view;  
  
import com.nineoldandroids.view.ViewHelper;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.util.Log;  
import android.view.View;  
  
public class RotateDownPageTransformer implements ViewPager.PageTransformer  
{  
      
    private static final float ROT_MAX = 20.0f;  
    private float mRot;  
      
  
      
    public void transformPage(View view, float position)  
    {  
  
        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            ViewHelper.setRotation(view, 0);  
  
        } else if (position &lt;= 1) // a页滑动至b页 ； a页从 0.0 ~ -1 ；b页从1 ~ 0.0  
        { // [-1,1]  
            // Modify the default slide transition to shrink the page as well  
            if (position &lt; 0)  
            {  
  
                mRot = (ROT_MAX * position);  
                ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);  
                ViewHelper.setPivotY(view, view.getMeasuredHeight());  
                ViewHelper.setRotation(view, mRot);  
            } else  
            {  
  
                mRot = (ROT_MAX * position);  
                ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);  
                ViewHelper.setPivotY(view, view.getMeasuredHeight());  
                ViewHelper.setRotation(view, mRot);  
            }  
  
            // Scale the page down (between MIN_SCALE and 1)  
  
            // Fade the page relative to its size.  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            ViewHelper.setRotation(view, 0);  
        }  
    }  
}
</code></pre>
<p>你没看错，if else 里面代码是一样的，为了好理解特意没有合并到一起~~</p>
<p>到此，我们从setPageTransformer使用，到修改ViewPager做到向下兼容，直至自己定义出个性的切换效果 都已经介绍完毕～～<br />
大家可以发挥自己的创造力，做出各种神奇的动画效果，ok，就到这里！</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869535.html">
                
                  <h1>Android-Android Studio 快捷键</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用快捷键</h2>
<h3><a id="%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动补全</h3>
<ul>
<li>使用<code>Enter</code>会补全你选择的语句</li>
<li>使用<code>Tab</code>的话，会替换掉你之前在这里的内容（删除后面的语句直到遇到点号，逗号，分号）</li>
</ul>
<h3><a id="%E8%87%AA%E5%8A%A8%E7%BC%A9%E8%BF%9B%E5%AF%B9%E9%BD%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动缩进对齐</h3>
<p><code>ctr + alt + I</code></p>
<h3><a id="%E8%BF%94%E5%9B%9E%E7%BC%96%E8%BE%91%E5%99%A8%E7%AA%97%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>返回编辑器窗口</h3>
<ul>
<li><code>Esc</code>: 返回编辑器</li>
<li><code>Shift + Esc</code>: 返回编辑器并关闭当前窗口</li>
</ul>
<h3><a id="%E5%BF%AB%E6%8D%B7%E6%89%93%E5%BC%80%E7%AA%97%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快捷打开窗口</h3>
<ul>
<li>Mac: <code>Cmd + 数字</code></li>
<li>windows/Linux: <code>Alt + 数字</code></li>
</ul>
<h3><a id="%E4%BB%BB%E6%84%8F%E7%AA%97%E5%8F%A3%E5%88%87%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>任意窗口切换</h3>
<p><code>Ctrl + Tab</code>可以让你切换到任意窗口！<br />
在这个切换窗口打开的时候，你可以直接按数字切换到对应的工具窗口，或者输入字母搜索右边的编辑器窗口，如果你需要关闭某个窗口，在上面按<code>BackSpace</code>即可。</p>
<h3><a id="%E9%9A%90%E8%97%8F%E6%89%80%E6%9C%89%E7%AA%97%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐藏所有窗口</h3>
<ul>
<li>Mac: <code>CMD + Shift + F12</code></li>
<li>windows/Linux: <code>Ctrl + shift + F12</code><br />
如果需要恢复所有窗口，再按一次这个快捷键即可。</li>
</ul>
<h3><a id="%E5%8F%82%E6%95%B0%E6%8F%90%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数提示</h3>
<p>这个功能估计很多人知道了，但是还是提一下。在自动补全以后，如果某个方法参数超级长，你不知道参数是什么怎么办？可以试试这个。</p>
<ul>
<li>Mac: <code>CMD + P</code></li>
<li>win/Linux: <code>Ctrl + P</code></li>
</ul>
<h3><a id="%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动生成变量</h3>
<p>作为一门静态类型语言， <a href="http://lib.csdn.net/base/java">Java</a> 是有一定的类型推导能力的；那么你是否经常书写:</p>
<pre><code class="language-java">String testStr = &quot;testStr&quot;;
List&lt;String&gt; testStrings = new ArrayList&lt;String&gt;();
</code></pre>
<p>其实大可不必写那些恼火的类型声明的，一看就知道</p>
<pre><code class="language-plain_text">testStr, testStrings
</code></pre>
<p>就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。</p>
<ul>
<li>Mac: <code>Cmd + Alt + V</code></li>
<li>Win/Linux: <code>Ctrl + Alt + V</code></li>
</ul>
<p>有的童鞋可能会问了：我使用<code>ArrayList, HashMap</code>的时候，习惯类型声明为<code>List,Map</code>等接口，这个自动生成的类型声明还是具体的实现啊，怎么办？这一点IDE已经帮你想到了，试试<code>shift + tab</code>,他会给你一个可以选择的类型列表～</p>
<h3><a id="%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动提取参数</h3>
<p>有时候你正在写一个方法的时候发现。哎哟，这个变量最好是当作参数传递进来啊；要做成这么一件事，你必须把这个方法内部所有使用这个局部变量的地方替换，把所有调用这个函数的地方添加参数，繁琐至极！好了有了这个你可以随便玩了：</p>
<ul>
<li>Mac: <code>Cmd + Alt + P</code></li>
<li>Win/Linux: <code>Ctrl + Alt + P</code></li>
</ul>
<p>当然，如果你想保留原来的方法，只是搞一个参数不同的方法（重载）出来，可以在弹出的那个对话框里面打勾。</p>
<h3><a id="%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动提取方法</h3>
<p>写代码的时候是否会发现不知不觉的这个方法已经太长了，适合分解然后提取出一个个子方法；或者是重构的时候看到一个一两千的函数，你是不是头都大了？一般情况下，我们都是把要提取的代码copy出来，然后写一个方法（还要什么该死的方法签名）然后把这段代码复制进来；其实这个过程是机械的，完全可以由IDE完成：</p>
<ul>
<li>Mac: <code>Cmd + Alt + M</code></li>
<li>Win/Linux: <code>Ctrl + Alt + M</code></li>
</ul>
<p>如果想改变方法的签名，在对话框里面选择你需要的就可以了～</p>
<blockquote>
<p>上面提到了三个快捷键其实是比较类似的，如何记忆呢？</p>
<ul>
<li>首先组合键都是<code>Cmd/Ctrl + Alt</code></li>
<li>然后提取变量Variable=V，参数Parameters=P，方法Method=M</li>
</ul>
</blockquote>
<h3><a id="%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内联变量/参数/方法</h3>
<p>好了学会了上面那几个快捷键，万一玩high了，比如提取了太多的方法，想“弄回去”，该怎么办呢？这个操作叫他<code>Inline..</code></p>
<ul>
<li>Mac: <code>Cmd + Alt + N</code></li>
<li>Win/Linux: <code>Ctrl + Alt + N</code></li>
</ul>
<p>上面那个图只是参考，其实不仅可以作用于变量，还可以是方法/参数，个人觉得方法inline比较有用。</p>
<h3><a id="%E4%B8%87%E8%83%BD%E9%87%8D%E6%9E%84%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>万能重构键</h3>
<p>静态类型语言重构起来相对容易的，但是通常修改一个地方会牵扯到很多别的地方，我们只有一处一处找到这些编译错误然后手动修复。其实有好多工作是可以自动完成的，比如删除某个方法；先确认有没有人调用（Alt ＋ F7），没有的话把方法体删了，有的话去看看调用的地方再决定怎么办。<br />
但是重构的操作实在是太多了！我们没有办法也没有必要一个个记住，知道这个快捷键即可，我叫他万能重构键:</p>
<ul>
<li>Mac : <code>Ctrl + T</code></li>
<li>Win/Linux: <code>Ctrl + Alt + Shift + T</code></li>
</ul>
<p>在Win/ <a href="http://lib.csdn.net/base/linux">Linux</a> 上可以考虑把这个快捷键改一下键，一下按四个键臣妾很难做到啊。。</p>
<h3><a id="%E9%87%8D%E5%91%BD%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重命名</h3>
<p><code>shift + F6</code></p>
<h3><a id="%E6%9F%A5%E6%89%BE%E5%BD%93%E5%89%8D%E6%96%87%E4%BB%B6%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查找当前文件在项目中的位置</h3>
<p>快捷键: <code>Alt + F1</code></p>
<h3><a id="%E6%8B%93%E5%B1%95%E9%80%89%E6%8B%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拓展选择</h3>
<p>这个功能应该很多人都知道；但还是说明一下，因为跟下面两个功能跟这个结合起来才有威力。这个功能太强大了，自己去按几遍就能想到很多使用场景了；我相信有了这个功能，你使用鼠标的机会会少很多。</p>
<ul>
<li>Mac: <code>Alt + up/down</code></li>
<li>Win/Linux: <code>ctrl + w / ctrl + shift + w</code></li>
</ul>
<h3><a id="surround-with" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Surround With..</h3>
<p>如果你想把一段代码使用<code>if</code>语句包起来；又或者使用<code>try</code>包围一段可能有运行时异常的代码，你会怎么干？<br />
首先用光标定位到代码块开头，写上 <code>try {</code>然后，光标代码块末尾加<code>} catch (XXXRuntimeException e) {// todo}</code>？可以试试这个快捷键。</p>
<ul>
<li>Mac: <code>cmd + alt + t</code></li>
<li>Win/Linux: <code>ctrl + alt + t</code></li>
</ul>
<p>可以使用上面的拓展选择选择你需要的代码块，然后使用这个功能Surround With；如果你什么都不选择的话，那么默认选择的是光标所在行。</p>
<h3><a id="unwrapremove" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unwrap/Remove</h3>
<p>这个功能跟上面提到的是一对，有了Surround With自然就有Unsurround With;使用情况没有上面那个那么多，但是好歹一对，一起介绍吧。</p>
<h3><a id="%E9%AB%98%E4%BA%AE%E6%9F%90%E4%B8%9C%E8%A5%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高亮某东西</h3>
<p>有时候看代码的时候，看到某个变量想知道哪里使用了它；你还在用肉眼查找吗？或者你杀鸡用牛刀<br />
<code>Find Usgae</code>？其实你的需求就是把这个变量全部给我打个标签，我想直观的知道它在哪。</p>
<ul>
<li>Mac: <code>cmd + shift + F7</code></li>
<li>Win/Linux: <code>ctrl + shift + F7</code><br />
这个键功能远不止这个！</li>
<li>如果你高亮<code>return</code>或者<code>throw</code>，那么会把这个方法所有的返回点高亮出来！</li>
<li>高亮某个类的<code>extends</code>或者<code>implements</code>会把这个类Override的方法高亮出来</li>
<li>高亮<code>import</code>会把使用的地方显示出来<br />
如果不想要高亮了，按下Esc就行。</li>
</ul>
<h3><a id="%E6%98%BE%E7%A4%BA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%A0%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>显示方法调用树</h3>
<p>在看源码的时候，你还是使用<code>alt + F7</code>和<code>ctrl + B</code>在各个类之间来回穿梭吗？其实好多时候你就是想知道这个调用结构是怎么样的而已；谁是怎么一步一步滴调用谁的；这个快捷键会给你一个调用树。有了这个大菊观，继续探讨就很容易了。<br />
快捷键: <code>ctrl + alt + h</code></p>
<h3><a id="%E4%B8%87%E8%83%BD%E5%BF%AB%E6%8D%B7%E9%94%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>万能快捷键</h3>
<p>记得之前提到过一个万能重构键, 有关重构的一切操作都可通过它完成。那么Android Studio这么快捷键，这么多功能，臣妾怎么可能都记住！要是有万能钥匙就好了！That’s it!<br />
使用这个快捷键，你想到什么功能，打开它搜索就可以了；打个比方，我想看看 <a href="http://lib.csdn.net/base/java">Java</a> 的<code>for each</code>循环和普通的<code>for</code>循环底层是不是同一个实现;那么我就需要看虚拟机字节码了；我记得有这个功能但是不知道快捷键是啥；OK，<code>Cmd + shift + A</code>，输入<code>bytecode</code>:</p>
<h3><a id="%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除当前行</h3>
<ul>
<li>Mac: <code>ctrl + Y</code></li>
<li>Win/Linux: <code>Command + Y</code></li>
</ul>
<h3><a id="find-usage" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Find usage</h3>
<p><code>alt+F7</code></p>
<h3><a id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>格式化代码</h3>
<ul>
<li>Mac: <code>alt+command+L</code></li>
<li>Win/Linux: <code>ctrl+alt+L</code></li>
</ul>
<h3><a id="%E4%BC%98%E5%8C%96import" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化import</h3>
<ul>
<li>Mac: <code>alt+command+O</code></li>
<li>Win/Linux: <code>ctrl+alt+O</code></li>
</ul>
<h3><a id="declaration%E6%9F%A5%E7%9C%8B%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Declaration查看定义</h3>
<ul>
<li>Mac: <code>command+B</code></li>
<li>Win/Linux: <code>ctrl+B</code></li>
</ul>
<h3><a id="%E5%BF%AB%E9%80%92%E5%AE%9A%E4%BD%8D%E5%B9%B6%E9%AB%98%E4%BA%AE%E9%94%99%E8%AF%AF%EF%BC%88deprecate%EF%BC%8Cunused%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快递定位并高亮错误（deprecate，unused）</h3>
<ul>
<li>Mac: <code>(shift+)F2</code></li>
<li>Win/Linux: <code>F2</code></li>
</ul>
<h3><a id="override-methods" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Override Methods</h3>
<ul>
<li>Mac: <code>command+O</code></li>
<li>Win/Linux: <code>ctrl+O</code></li>
</ul>
<h3><a id="implement-methods" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implement Methods</h3>
<ul>
<li>Mac: <code>command+I</code></li>
<li>Win/Linux: <code>ctrl+I</code></li>
</ul>
<h3><a id="super-method%EF%BC%88class%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Super Method（Class）</h3>
<ul>
<li>Mac: <code>command+U</code></li>
<li>Win/Linux: <code>ctrl+U</code></li>
</ul>
<h3><a id="previousnext-method" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Previous/Next Method</h3>
<p><code>control+上下方向键</code></p>
<h3><a id="%E5%BC%95%E5%85%A5%E5%8C%85%EF%BC%8C%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%E2%80%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>引入包，添加注释…</h3>
<p><code>alt+enter</code></p>
<h3><a id="run" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run</h3>
<p>shift+F10 </p>
<h3><a id="debug%C2%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Debug </h3>
<p>shift+F9</p>
<h3><a id="make-project" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Make Project</h3>
<ul>
<li>Mac: <code>command+F9</code></li>
<li>Win/Linux: <code>ctrl+F9</code></li>
</ul>
<h3><a id="make-module" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Make Module</h3>
<ul>
<li>Mac: <code>shift+command+F9</code></li>
<li>Win/Linux: <code>shift+ctrl+F9</code></li>
</ul>
<h3><a id="%E5%85%B3%E9%97%AD%E5%BD%93%E5%89%8D%E7%9A%84%E6%89%A7%E8%A1%8C%E7%9A%84task" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关闭当前的执行的task</h3>
<ul>
<li>Mac: <code>command+F2</code></li>
<li>Win/Linux: <code>ctrl+F2</code></li>
</ul>
<h3><a id="%E6%B7%BB%E5%8A%A0%E5%8F%96%E6%B6%88%E6%96%AD%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加/取消断点</h3>
<ul>
<li>Mac: <code>command+F8</code></li>
<li>Win/Linux: <code>ctrl+F8</code></li>
</ul>
<h3><a id="%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E6%96%AD%E7%82%B9%C2%A0debug" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查看所有断点 Debug</h3>
<ul>
<li>Mac: <code>shift+command+F8</code></li>
<li>Win/Linux: <code>shift+ctrl+F8</code></li>
</ul>
<h3><a id="step-into" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step Into</h3>
<p> <code>F7</code></p>
<h3><a id="step-over" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step Over</h3>
<p><code>F8</code></p>
<h3><a id="step-out" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step out</h3>
<p><code>shift+F8</code> </p>
<h3><a id="resume%C2%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>resume </h3>
<p><code>F9</code></p>
<h3><a id="run-to-cursor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run to Cursor</h3>
<p><code>alt+F9</code></p>
<h3><a id="find" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Find</h3>
<ul>
<li>Mac: <code>command+F</code></li>
<li>Win/Linux: <code>command+F</code></li>
</ul>
<h3><a id="replace" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Replace</h3>
<ul>
<li>Mac: <code>command+R</code></li>
<li>Win/Linux: <code>command+R</code></li>
</ul>
<h3><a id="find-in-path" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Find in Path</h3>
<p><code>control+shift+F</code></p>
<h3><a id="replace-in-path" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Replace in Path</h3>
<p><code>control+shiftÏ+R</code></p>
<h3><a id="backforward%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Back/Forward操作</h3>
<ul>
<li>Mac: <code>alt+command+左右方向键</code></li>
<li>Win/Linux: <code>alt+ctrl+左右方向键</code></li>
</ul>
<h3><a id="recent-file" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recent File</h3>
<ul>
<li>Mac: <code>command+E</code></li>
<li>Win/Linux: <code>ctrl+E</code></li>
</ul>
<h3><a id="recently-change-files" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recently Change Files</h3>
<ul>
<li>Mac: <code>shift+command+E</code></li>
<li>Win/Linux: <code>shift+ctrl+E</code></li>
</ul>
<h3><a id="search-method%E6%88%96%E8%80%85class" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Search Method或者Class</h3>
<p>(Search Everywhere：<code>command+N</code>,<code>shift+command+N</code>,<code>shift+alt+command+N</code>)<br />
<code>shift+shift</code></p>
<h3><a id="search-class" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Search Class</h3>
<ul>
<li>Mac: <code>command+N</code></li>
<li>Win/Linux: <code>ctrl+N</code></li>
</ul>
<h3><a id="search-file" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Search File</h3>
<ul>
<li>Mac: <code>shift+command+N</code></li>
<li>Win/Linux: <code>shift+ctrl+N</code></li>
</ul>
<h3><a id="search-symbol" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Search Symbol</h3>
<ul>
<li>Mac: <code>shift+alt+command+N</code></li>
<li>Win/Linux: <code>shift+alt+ctrl+N</code></li>
</ul>
<h3><a id="move-line-upmove-line-down" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Move Line Up/Move Line Down</h3>
<ul>
<li>Mac: <code>shift+command+上下方向键</code></li>
<li>Win/Linux: <code>shift+ctrl+上下方向键</code></li>
</ul>
<h2><a id="%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>常用技巧</h2>
<h3><a id="%E4%B9%A6%E7%AD%BE%EF%BC%88bookmarks%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>书签（Bookmarks）</h3>
<ul>
<li><strong>描述</strong>：这是一个很有用的功能，让你可以在某处做个标记（书签），方便后面再跳转到此处。</li>
<li><strong>调用</strong>：Menu → Navigate → Bookmarks</li>
<li><strong>快捷键</strong>：
<ul>
<li>添加/移除书签：
<ul>
<li>OS X: <code>F3</code></li>
<li>Windows/Linux: <code>F11</code></li>
</ul>
</li>
<li>添加/移除书签(带标记)：
<ul>
<li>OS X: <code>Alt + F3</code></li>
<li>Windows/Linux: <code>Ctrl + F11</code></li>
</ul>
</li>
<li>显示全部书签显示所有的书签列表，并且是可以搜索的。
<ul>
<li>OS X: <code>Cmd + F3</code></li>
<li>Windows/Linux: <code>Shift + F11</code></li>
</ul>
</li>
<li>上一个/下一个书签：无，可以在设置中设置快捷键。</li>
</ul>
</li>
<li><strong>更多</strong>：当你为某个书签指定了标记，你可以使用快捷键 <code>Ctrl + 标记</code> 来快速跳转到标记处，比如输入<code>Ctrl + 1</code>，跳到标记为1的书签处</li>
</ul>
<p><img src="media/15561207869535/20171104150980563110691.gif" alt="" /></p>
<h3><a id="%E6%8A%98%E5%8F%A0%E5%B1%95%E5%BC%80%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88collapse-expand-code-block%EF%BC%89%C2%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>折叠/展开代码块（Collapse Expand Code Block） </h3>
<ul>
<li><strong>描述</strong>：该操作提供一种方法，让你隐藏你不关心的部分代码，以一种较为简洁的格式显示关键代码。一个有意思的用法是隐藏匿名内部类的代码，让其看起来像一个Lambda表达式。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + “+”/”-“</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + “+”/”-“</code></li>
</ul>
</li>
<li><strong>更多</strong>：可以在Settig → Editor → General → Code Folding 中设置折叠规则。</li>
</ul>
<p><img src="media/15561207869535/20171104150980566925324.gif" alt="" /></p>
<h3><a id="%E4%B8%8E%E5%88%86%E6%94%AF%E6%AF%94%E5%AF%B9%EF%BC%88compare-with-branch-git%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与分支比对（Compare With Branch (Git)）</h3>
<ul>
<li><strong>描述</strong>：假如你的项目是使用git来管理的，你可以将当前文件或者文件夹与其他的分支进行比对。比较有用的是可以让你了解到你与主分支有多少差别。</li>
<li><strong>调用</strong>：Menu → VCS → Git → Compare With Branch</li>
</ul>
<p><img src="media/15561207869535/20171104150980569269725.gif" alt="" /></p>
<h3><a id="%E4%B8%8E%E5%89%AA%E5%88%87%E6%9D%BF%E6%AF%94%E5%AF%B9%EF%BC%88compare-with-clipboard%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与剪切板比对（Compare With Clipboard）</h3>
<ul>
<li><strong>描述</strong>：将当前选中的部分与剪切板上的内容进行比对。</li>
<li><strong>调用</strong>：右键选中的部分，在右键菜单中选择“Compare With Clipboard”。</li>
</ul>
<p><img src="media/15561207869535/20171104150980574818952.gif" alt="" /></p>
<h3><a id="%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF%EF%BC%88context-info%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上下文信息（Context Info）</h3>
<ul>
<li><strong>描述</strong>：当前作用域定义超过滚动区域，执行该操作将显示所在的上下文信息，通常它显示的是类名或者内部类类名或者当前所在的方法名。该操作在xml文件中同样适用。</li>
<li><strong>调用</strong>：Menu → View → Context Info</li>
<li><strong>快捷键</strong>：Alt + Q (Windows/Linux)</li>
<li><strong>更多</strong>：个人认为，这个功能更好的用法是快速查看当前类继承的父类或者实现的接口。</li>
</ul>
<p><img src="media/15561207869535/20171104150980576930267.gif" alt="" /></p>
<h3><a id="%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C%EF%BC%88find-action%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查找操作（Find Action）</h3>
<ul>
<li><strong>描述</strong>：输入某个操作的名称，快速查找，对于没有快捷键的部分操作这是一个很有用的技巧。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd +Shift + A</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + A</code></li>
</ul>
</li>
<li><strong>更多</strong>：当某个操作是有快捷键的，会显示在旁边。</li>
</ul>
<p><img src="media/15561207869535/20171104150980579558685.gif" alt="" /></p>
<h3><a id="%E6%9F%A5%E6%89%BE%E8%A1%A5%E5%85%A8%EF%BC%88find-complection%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查找补全（Find Complection）</h3>
<ul>
<li><strong>描述</strong>：当你在一个文件中进行查找时，使用自动补全快捷键可以给出在当前文件中出现的建议单词；</li>
<li><strong>快捷键</strong>：输入一些字符，然后使用自动补全
<ul>
<li>OS X: <code>Cmd + F</code></li>
<li>Windows/Linux: <code>Ctrl + F</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980582766335.gif" alt="" /></p>
<h3><a id="%E9%9A%90%E8%97%8F%E6%89%80%E6%9C%89%E9%9D%A2%E6%9D%BF%EF%BC%88hide-all-panels%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隐藏所有面板（Hide All Panels）</h3>
<ul>
<li><strong>描述</strong>：切换编辑器铺满整个程序界面，隐藏其他的面板。再次执行该操作，将会回到隐藏前的状态。</li>
<li><strong>调用</strong>：Menu → Window → Active Tool Window → Hide All Windows；</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd +Shift + F12</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + F12</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980590796229.gif" alt="" /></p>
<h3><a id="%E9%AB%98%E4%BA%AE%E4%B8%80%E5%88%87%EF%BC%88hightlight-all-the-things%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高亮一切（Hightlight All the Things）</h3>
<ul>
<li><strong>描述</strong>：该操作将会高亮某个字符在当前文件中所有出现的地方。这不仅仅是简单的匹配，实际上它会分析当前的作用域，只高亮相关的部分。</li>
<li><strong>调用</strong>：Menu → Edit → Find → Highlight Usages in File；</li>
<li><strong>定位到上一处/下一处</strong>：Menu → Edit → Find → Find Next/Previous；</li>
<li><strong>快捷键</strong>：相关快捷键请在菜单中查看；</li>
<li><strong>更多</strong>：
<ul>
<li>如果高亮一个方法的return或throw语句，将会高亮这个方法的所有出口/结束点；</li>
<li>如果高亮某个类定义处的extend或implements语句，将会高亮继承的或实现的方法；</li>
<li>高亮一个import语句也会高亮使用到的地方；</li>
<li>按下Esc可以退出高亮模式；</li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980592566371.gif" alt="" /></p>
<h3><a id="%E5%9B%9E%E5%88%B0%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%E7%AA%97%E5%8F%A3%EF%BC%88jump-to-last-tool-window%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>回到上一个工具窗口（Jump to Last Tool Window）</h3>
<ul>
<li><strong>描述</strong>：有时候你会从某个工具窗口跳到编辑器里面，然后又需要重新回到刚才操作的那个工具窗，比如你查找使用情况的时，使用该操作可以在不使用鼠标的情况下跳转到之前的工具窗口。</li>
<li><strong>快捷键</strong>：F12</li>
</ul>
<p><img src="media/15561207869535/20171104150980594942504.gif" alt="" /></p>
<h3><a id="%E4%B8%8A%E4%B8%80%E4%B8%AA%E7%BC%96%E8%BE%91%E4%BD%8D%E7%BD%AE%EF%BC%88last-edit-location%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上一个编辑位置（Last Edit Location）</h3>
<ul>
<li><strong>描述</strong>：该操作将使得你导航到上一处你改动过的地方，这与点击工具栏上的返回箭头回到上一个定位位置是不一样的，该操作将会返回到上一个编辑的位置。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Backspace﻿</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980596825126.gif" alt="" /></p>
<h3><a id="%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%EF%BC%88move-between-methods-and-inner-classes%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在方法和内部类之间跳转（Move Between Methods and Inner Classes）</h3>
<ul>
<li><strong>描述</strong>：该操作让光标在当前文件的方法或内部类的名字间跳转。</li>
<li><strong>调用</strong>：Navigate → Next Method/Previous Method;</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + Up/Down﻿</code></li>
<li>Windows/Linux: <code>Alt + Up/Down</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980599666524.gif" alt="" /></p>
<h3><a id="%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%B5%8C%E5%A5%97%E6%96%87%E4%BB%B6%EF%BC%88navigate-to-nested-file%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定位到嵌套文件（Navigate to Nested File）</h3>
<ul>
<li><strong>描述</strong>：有时你有一堆存放在不同目录下的同名文件，例如不同模块下的AndroidManifest.xml文件，当你想定位到其中的一个文件，你会得到一堆搜索结果，你还得辨认哪个才是你需要的。通过在检索框中输入部分路径的前缀，并添加斜杠号，你就可以在第一次尝试的时候就找到正确的那个。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X：<code>Shift + Cmd + O</code></li>
<li>Windows/Linux: <code>Shift + Ctrl + N﻿</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980603928163.gif" alt="" /></p>
<h3><a id="%E5%AE%9A%E4%BD%8D%E5%88%B0%E7%88%B6%E7%B1%BB%EF%BC%88navigate-to-parent%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定位到父类（Navigate to parent）</h3>
<ul>
<li><strong>描述</strong>：如果光标是在一个继承父类重写的方法里，这个操作将定位到父类实现的地方。如果光标是在类名上，则定位到父类类名。</li>
<li>Menu → Navigate → Super Class/Method</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + U</code></li>
<li>Windows/Linux: <code>Ctrl + U</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/2017110415098060573045.gif" alt="" /></p>
<h3><a id="%E6%A0%B9%E6%8D%AE%E7%BC%96%E5%8F%B7%E6%89%93%E5%BC%80%E9%9D%A2%E6%9D%BF%EF%BC%88open-a-panel-by-its-number%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>根据编号打开面板（Open a Panel by Its Number）</h3>
<ul>
<li><strong>描述</strong>：你可能已经注意到某些面板的名称左边有一个数字，这里有个快捷操作可以打开它们。如果你没看到面板的名称，请点击IDE的左下角的切换按钮。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + 数字</code></li>
<li>Windows/Linux: <code>Alt + 数字</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980607694073.gif" alt="" /></p>
<h3><a id="%E5%9C%A8%E5%A4%96%E9%83%A8%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%EF%BC%88open-file-externally%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在外部打开文件（Open File Externally）</h3>
<ul>
<li><strong>描述</strong>：通过这个快捷键，简单地点击 Tab，就可以打开当前文件所在的位置或者该文件的任意上层路径。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + 单击Tab</code></li>
<li>Windows/Linux: <code>Ctrl + 点击Tab</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980611657644.gif" alt="" /></p>
<h3><a id="%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF%EF%BC%88parameter-info%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数信息（Parameter Info）</h3>
<ul>
<li><strong>描述</strong>：这个操作将显示和你在方法声明处写一样的参数列表，当你想看某个存在的方法的参数，这是一个很有用的操作。光标下的参数显示为黄色，如果没有参数显示黄色，意味着你的方法调用是无效的，很可能是某个参数分配不对。（例如一个浮点数赋值给了整型参数）。如果你正在写一个方法调用，突然离开编辑的地方，再返回的时候，输入一个逗号，就可以重新触发参数信息。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + P</code></li>
<li>Windows/Linux: <code>Ctrl + P</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980616259965.gif" alt="" /></p>
<h3><a id="%E5%BF%AB%E9%80%9F%E6%9F%A5%E7%9C%8B%E5%AE%9A%E4%B9%89%EF%BC%88quick-definition-lookup%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>快速查看定义（Quick Definition Lookup）</h3>
<ul>
<li><strong>描述</strong>：你曾经是否想查看一个方法或者类的具体实现，但是不想离开当前界面？ 该操作可以帮你搞定。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Alt + Space / Cmd + Y</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + I</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980618467849.gif" alt="" /></p>
<h3><a id="%E6%9C%80%E8%BF%91%E4%BF%AE%E6%94%B9%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%88recently-changed-files%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最近修改的文件（Recently Changed Files）</h3>
<ul>
<li><strong>描述</strong>：该操作类似于“最近访问（Recents）”弹窗，会显示最近本地修改过的文件列表，根据修改时间排列。可以输入字符来过滤列表结果。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + E</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + E</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980621570214.gif" alt="" /></p>
<h3><a id="%E6%9C%80%E8%BF%91%E8%AE%BF%E9%97%AE%EF%BC%88recents%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>最近访问（Recents）</h3>
<ul>
<li><strong>描述</strong>：该操作可以得到一个最近访问文件的可搜索的列表。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + E</code></li>
<li>Windows/Linux: <code>Ctrl + E</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980623538307.gif" alt="" /></p>
<h3><a id="%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%EF%BC%88related-file%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关文件（Related File）</h3>
<ul>
<li><strong>描述</strong>：该操作有助于在布局文件和Activity/Fragment之间轻松跳转。这也是一个快捷操作，在类名/布局顶端的左侧。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + Cmd + Up</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + Home</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980626239846.gif" alt="" /></p>
<h3><a id="%E8%BF%94%E5%9B%9E%E5%88%B0%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%88return-to-the-editor%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>返回到编辑器（Return to the Editor）</h3>
<ul>
<li><strong>描述</strong>：一大堆快捷键操作会把你从编辑器带走（type hierarchy, find usages, 等等）。如果你想返回到编辑器，你有两个选项：
<ul>
<li><code>Esc</code>：该操作仅仅把光标移回编辑器。</li>
<li><code>Shift + Esc</code>：该操作会关闭当前面板，然后把光标移回到编辑器。</li>
</ul>
</li>
<li><strong>快捷键</strong>：
<ul>
<li>返回但保留打开的面板：<code>Esc</code></li>
<li>关闭面板并返回：<code>Shift + Esc</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980627917706.gif" alt="" /></p>
<h3><a id="select-in" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Select In</h3>
<ul>
<li><strong>描述</strong>：拿着当前文件然后问你在哪里选中该文件。恕我直言，最有用的就是在项目结构或者资源管理器中打开该文件。每一个操作都有数字或者字母作为前缀，可以通过这个前缀来快速跳转。通常，我会 Alt + F1 然后 回车(Enter) 来打开项目视图，然后 再用 Alt + F1 在OS X的Finder里找到文件。你可以在文件中或者直接在项目视图里使用该操作。</li>
<li><strong>快捷键</strong>：<code>Alt + F1</code></li>
</ul>
<p><img src="media/15561207869535/20171104150980629875328.gif" alt="" /></p>
<h3><a id="%E6%89%A9%E5%A4%A7%E7%BC%A9%E5%B0%8F%E9%80%89%E6%8B%A9%EF%BC%88extendshrink-selection%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>扩大/缩小选择（Extend/Shrink Selection）</h3>
<ul>
<li><strong>描述</strong>：该操作会在上下文逐渐扩大/缩小当前选择范围。例如，它会先选中当前变量，再选中当前语句，然后选中整个方法，缩小选择则相反。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Alt + 上/下</code></li>
<li>Windows、Linux: <code>Ctrl+W / Ctrl + Shift + W﻿</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980631814449.gif" alt="" /></p>
<h3><a id="sublime-text%E5%BC%8F%E7%9A%84%E5%A4%9A%E5%A4%84%E9%80%89%E6%8B%A9%EF%BC%88sublime-text-multi-selection%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sublime Text式的多处选择（Sublime Text Multi Selection）</h3>
<ul>
<li><strong>描述</strong>：这个功能超级赞！该操作会识别当前选中字符串，选择下一个同样的字符串，并且添加一个光标。这意味着你可以在同一个文件里拥有多个光标，你可以同时在所有光标处输入任何东西。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + G</code></li>
<li>Windows、Linux: <code>Alt + Ｊ</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980633994665.gif" alt="" /></p>
<h3><a id="%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%BC%B9%E7%AA%97%EF%BC%88the-file-structure-popup%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件结构弹窗（The File Structure Popup）</h3>
<ul>
<li><strong>描述</strong>：该操作可以展示当前类的大纲，并且可以快速跳转。你还可以通过键盘输入来过滤结果。这是一种很高效的方法来跳转到指定方法。</li>
<li><strong>更多</strong>：
<ul>
<li>你在输入字符的时候可以用驼峰风格来过滤选项。比如输入”oCr”会找到”onCreate”</li>
<li>你可以通过勾选多选框来决定是否显示匿名类。这在某些情况下很有用，比如你想直接跳转到一个OnClickListener的onClick方法。</li>
</ul>
</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + F12</code></li>
<li>Windows/Linux: <code>Ctrl + F12</code></li>
</ul>
</li>
<li><strong>调用</strong>：Menu → Navigate → File Structure</li>
</ul>
<p><img src="media/15561207869535/20171104150980637886260.gif" alt="" /></p>
<h3><a id="%E5%88%87%E6%8D%A2%E5%99%A8%EF%BC%88the-switcher%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>切换器（The Switcher）</h3>
<ul>
<li><strong>描述</strong>：该快捷键基本上就是IDE的alt+tab/cmd+tab命令。你可以用它在导航tab或者面板切换。一旦打开这个窗口，只要一直按着ctrl键，你可以通过对应的数字或者字母快捷键快速选择。你也可以通过backspace键来关闭一个已选中的tab或者面板。</li>
<li><strong>快捷键</strong>：<code>Ctrl + Tab</code></li>
</ul>
<p><img src="media/15561207869535/20171104150980639938168.gif" alt="" /></p>
<h3><a id="%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C%E5%BC%B9%E7%AA%97%EF%BC%88vcs-operations-popup%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>版本控制操作弹窗（VCS Operations Popup）</h3>
<ul>
<li><strong>描述</strong>：该操作会给你显示最常用的版本控制操作。如果你的项目没有用git等版本控制软件进行管理，它至少会给你提供一个由IDE维护的本地历史记录。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + V</code></li>
<li>Windows/Linux: <code>Alt + 引号</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980642462619.gif" alt="" /></p>
<h2><a id="%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编码技巧</h2>
<h3><a id="%E5%88%97%E9%80%89%E6%8B%A9%E5%9D%97%E9%80%89%E6%8B%A9%EF%BC%88column-selection%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>列选择/块选择（Column Selection）</h3>
<ul>
<li><strong>描述</strong>：正常选择时，当你向下选择时，会直接将当前行到行尾都选中，而块选择模式下，则是根据鼠标选中的矩形区域来选择。</li>
<li><strong>调用</strong>：按住Alt，然后拖动鼠标选择。</li>
<li><strong>开启/关闭块选择</strong>：Menu → Edit → Column Selection Mode</li>
<li><strong>快捷键</strong>：切换块选择模式：
<ul>
<li>OS X：<code>Cmd + Shift + 8</code></li>
<li>Windows/Linux: <code>Shift + Alt + Insert﻿</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/2017110415098064433401.gif" alt="" /></p>
<h3><a id="%E8%AF%AD%E5%8F%A5%E8%A1%A5%E5%85%A8%EF%BC%88complete-statement%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语句补全（Complete Statement）</h3>
<ul>
<li><strong>描述</strong>：这个方法将会生成缺失的代码来补全语句，常用的使用场景如下：
<ul>
<li>在行末添加一个分号，即使光标不在行末；</li>
<li>为if、while、for 语句生成圆括号和大括号；</li>
<li>方法声明后，添加大括号；</li>
</ul>
</li>
<li><strong>调用</strong>：Menu → Edit → Compelete Current Statement</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + Enter</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Enter</code></li>
</ul>
</li>
<li><strong>更多</strong>：如果一个语句已经补全，当你执行该操作时，则会直接跳到下一行，即使光标不在当前行的行末。</li>
</ul>
<p><img src="media/15561207869535/20171104150980646813298.gif" alt="" /></p>
<h3><a id="%E5%88%A0%E9%99%A4%E8%A1%8C%EF%BC%88delete-line%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>删除行（Delete Line）</h3>
<ul>
<li><strong>描述</strong>：如果没选中，则删除光标所在行，如果选中，则会删除选中所在的所有行。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Y</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980648262822.gif" alt="" /></p>
<h3><a id="%E8%A1%8C%E5%A4%8D%E5%88%B6%EF%BC%88duplicate-line%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>行复制（Duplicate Line）</h3>
<ul>
<li><strong>描述</strong>：复制当前行，并粘贴到下一行，这个操作不会影响剪贴板的内容。这个命令配合移动行快捷键非常有用。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + D</code></li>
<li>Windows/Linux: <code>Ctrl + D</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980649696731.gif" alt="" /></p>
<h3><a id="%E7%BC%96%E5%86%99%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88edit-regex%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编写正则表达式（Edit Regex）</h3>
<ul>
<li><strong>描述</strong>：使用Java编写正则表达式是一件很困难的事，主要原因是：
<ul>
<li>你必须得避开反斜杠；</li>
<li>说实话，正则很难；</li>
<li>看第二条。</li>
</ul>
</li>
</ul>
<p>IDE能帮我们干点啥呢？当然是一个舒服的界面来编写和测试正则啦~</p>
<ul>
<li><strong>快捷键</strong>：Alt + Enter → check regexp</li>
</ul>
<p><img src="media/15561207869535/20171104150980651186804.gif" alt="" /></p>
<h3><a id="%E4%BD%BF%E7%94%A8enter%E5%92%8Ctab%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%88enter-vs-tab-for-code-completion%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用Enter和Tab进行代码补全的差别（Enter vs Tab for Code Completion）</h3>
<ul>
<li><strong>描述</strong>：代码补全时，可以使用Enter或Tab来进行补全操作，但是两者是有差别的。</li>
<li><strong>使用Enter时</strong>：从光标处插入补全的代码，对原来的代码不做任何操作。</li>
<li><strong>使用Tab时</strong>：从光标处插入补全的代码，并删除后面的代码，直到遇到点号、圆括号、分号或空格为止。</li>
</ul>
<p><img src="media/15561207869535/20171104150980653180946.gif" alt="" /></p>
<h3><a id="%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95%EF%BC%88extract-method%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提取方法（Extract Method）</h3>
<ul>
<li><strong>描述</strong>：提取一段代码块，生成一个新的方法。当你发现某个方法里面过于复杂，需要将某一段代码提取成单独的方法时，该技巧是很有用的。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Method</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + M</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + M</code></li>
</ul>
</li>
<li><strong>更多</strong>：在提取代码的对话框，你可以更改方法的修饰符和参数的变量名。</li>
</ul>
<p><img src="media/15561207869535/20171104150980654825229.gif" alt="" /></p>
<h3><a id="%E6%8F%90%E5%8F%96%E5%8F%82%E6%95%B0%EF%BC%88extract-parameter%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提取参数（Extract Parameter）</h3>
<ul>
<li><strong>描述</strong>：这是一个提取参数的快捷操作。当你觉得可以通过提取参数来优化某个方法的时候，这个技巧将很有用。该操作会将当前值作为一个方法的参数，将旧的值放到方法调用的地方，作为传进来的参数。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Parameter</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + P</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + P</code></li>
</ul>
</li>
<li><strong>更多</strong>：通过勾选“delegate”，可以保持旧的方法，重载生成一个新方法。</li>
</ul>
<p><img src="media/15561207869535/20171104150980656810471.gif" alt="" /></p>
<h3><a id="%E6%8F%90%E5%8F%96%E5%8F%98%E9%87%8F%EF%BC%88extract-variable%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提取变量（Extract Variable）</h3>
<ul>
<li><strong>描述</strong>：这是一个提取变量的快捷操作。当你在没有写变量声明的直接写下值的时候，这是一个很方便生成变量声明的操作，同时还会给出一个建议的变量命名。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Variable</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + V</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + V</code></li>
</ul>
</li>
<li><strong>更多</strong>：当你需要改变变量声明的类型，例如使用 List 替代 ArrayList，可以按下Shift + Tab，就会显示所有可用的变量类型。</li>
</ul>
<p><img src="media/15561207869535/2017110415098065961111.gif" alt="" /></p>
<h3><a id="%E5%86%85%E7%BD%AE%EF%BC%88inline%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内置（Inline）</h3>
<ul>
<li><strong>描述</strong>：当你开始对提取操作有点兴奋的时候，突然觉得东西太多了，怎么办呢？这是一个和提取相反的操作。该操作对方法、字段、参数和变量均有效。</li>
<li><strong>调用</strong>：Menu → Refactor → Inline</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + N</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + N</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980663164666.gif" alt="" /></p>
<h3><a id="%E5%90%88%E5%B9%B6%E8%A1%8C%E5%92%8C%E6%96%87%E6%9C%AC%EF%BC%88join-lines-and-literals%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>合并行和文本（Join Lines and Literals）</h3>
<ul>
<li><strong>描述</strong>：这个操作比起在行末使劲按删除键爽多了！该操作遵守格式化规则，同时：
<ul>
<li>合并两行注释，同时移除多余的//；</li>
<li>合并多行字符串，移除+和双引号；</li>
<li>合并字段的声明和初始化赋值；</li>
</ul>
</li>
<li><strong>快捷键</strong>：<code>Ctrl + Shift + J</code></li>
</ul>
<p><img src="media/15561207869535/20171104150980665059689.gif" alt="" /></p>
<h3><a id="%E5%8A%A8%E6%80%81%E6%A8%A1%E6%9D%BF%EF%BC%88live-templates%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态模板（Live Templates）</h3>
<ul>
<li><strong>描述</strong>：动态模板是一种快速插入代码片段的方法，使用动态模板比较有意思的是你可以使用合适的默认值将模板参数化，当你插入代码片段时，这可以指导你完成参数。</li>
<li><strong>更多</strong>：如果你知道模板的缩写，就可以不必使用快捷键，只需要键入缩写并使用Tab键补全即可。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + J</code></li>
<li>Windows/Linux: <code>Ctrl + J</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980666912326.gif" alt="" /></p>
<h3><a id="%E4%B8%8A%E4%B8%8B%E7%A7%BB%E5%8A%A8%E8%A1%8C%EF%BC%88move-lines-up-down%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上下移动行（Move Lines Up Down）</h3>
<ul>
<li><strong>描述</strong>：不需要复制粘贴就可以上下移动行了。</li>
<li><strong>快捷键</strong>：<code>Alt + Shift + Up/Down﻿</code></li>
</ul>
<p><img src="media/15561207869535/20171104150980669255942.gif" alt="" /></p>
<h3><a id="%E7%A7%BB%E5%8A%A8%E6%96%B9%E6%B3%95%EF%BC%88move-methods%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>移动方法（Move Methods）</h3>
<ul>
<li><strong>描述</strong>：这个操作和移动行操作很类似，不过该操作是应用于整个方法的，在不需要复制、粘贴的情况下，就可以将整个方法块移动到另一个方法的前面或后面。该操作的实际叫做“移动语句”，这意味着你可以移动任何类型的语句，你可以方便地调整字段或内部类的顺序。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + Up/Down</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Up/Down</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980671139565.gif" alt="" /></p>
<h3><a id="%E5%8F%96%E5%8F%8D%E8%A1%A5%E5%85%A8%EF%BC%88negation-completion%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>取反补全（Negation Completion）</h3>
<ul>
<li><strong>描述</strong>：有时你自动补全一个布尔值，然后回到该值的前面添加一个感叹号来完成取反操作，现在通过使用输入!代替enter完成补全操作，就可以跳过这些繁琐的操作了。</li>
<li><strong>快捷键</strong>：代码补全的时候，按下!即可（有时需要上下键选中候选项）；</li>
</ul>
<p><img src="media/15561207869535/20171104150980672883680.gif" alt="" /></p>
<h3><a id="%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8%EF%BC%88postfix-completion%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>后缀补全（Postfix Completion）</h3>
<ul>
<li><strong>描述</strong>：你可以认为该操作是一种代码补全，它会在点号之前生成代码，而不是在点号之后。实际上你调用这个操作和正常的代码补全操作一样：在一个表达式之后输入点号。</li>
</ul>
<p>例如对一个列表进行遍历，你可以输入myList.for，然后按下Tab键，就会自动生成for循环代码。</p>
<ul>
<li>
<p><strong>调用</strong>： 你可以在某个表达式后面输入点号，出现一个候选列表，在常规的代码补全提示就可以看到一系列后缀补全关键字，同样的，你也可以在Editor → Postfix Completion中看到一系列后缀补全关键字。</p>
</li>
<li>
<p>常用的有后缀补全关键字有：</p>
<ul>
<li>.for (补全foreach语句)</li>
<li>.format (使用String.format()包裹一个字符串)</li>
<li>.cast (使用类型转化包裹一个表达式)</li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980676555014.gif" alt="" /></p>
<h3><a id="%E9%87%8D%E6%9E%84%EF%BC%88refactor-this%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重构（Refactor This）</h3>
<ul>
<li><strong>描述</strong>：该操作可以显示所有对当前选中项可行的重构方法。这个列表可以用数字序号快速选择。</li>
<li><strong>快捷键</strong>：Ctrl + T(OS X)、Ctrl + Alt + Shift + T(Windows/Linux)</li>
</ul>
<p><img src="media/15561207869535/20171104150980678781403.gif" alt="" /></p>
<h3><a id="%E9%87%8D%E5%91%BD%E5%90%8D%EF%BC%88rename%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重命名（Rename）</h3>
<ul>
<li><strong>描述</strong>：你可以通过该操作重命名变量、字段、方法、类、包。当然了，该操作会确保重命名对上下文有意义，不会无脑替换掉所有文件中的名字；</li>
<li><strong>快捷键</strong>：<code>Shift + F6</code></li>
<li><strong>更多</strong>：如果你忘记了这个快捷键，你可以使用快速修复（Quick Fix）的快捷键，它通常包含重命名选项。</li>
</ul>
<p><img src="media/15561207869535/20171104150980681031115.gif" alt="" /></p>
<h3><a id="%E5%88%86%E5%8F%B7%E7%82%B9%E8%A1%A5%E5%85%A8%EF%BC%88semicolon-dot-completion%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分号/点 补全（Semicolon Dot Completion）</h3>
<ul>
<li><strong>描述</strong>：代码补全这个功能太棒啦！我们大概都对以下这种情况很熟悉：开始输入点什么东西，接着从IDE得到一些建议的选项，然后通过Enter或者Tab来选择我们想要的补全代码。其实还有另外一种方法来选择补全的代码：我们可以输入一个点(.)或者一个分号(;)。这样就会完成补全，添加所选字符。这在结束一条语句补全或者快速链式调用方法的时候特别有用。</li>
<li><strong>注意点</strong>：如果你要代码补全的方法需要参数，这些参数会被略过。</li>
<li><strong>快捷键</strong>：<code>Autocomplete + “.” 或者 “;”</code></li>
</ul>
<p><img src="media/15561207869535/20171104150980682566602.gif" alt="" /></p>
<h3><a id="%E5%8C%85%E8%A3%B9%E4%BB%A3%E7%A0%81%EF%BC%88surround-with%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>包裹代码（Surround With）</h3>
<ul>
<li>
<p><strong>描述</strong>： 该操作可以用特定代码结构包裹住选中的代码块，通常是if语句，循环，try/catch语句或者runnable语句。 如果你没有选中任何东西，该操作会包裹当前一整行。</p>
</li>
<li>
<p><strong>快捷键</strong>：</p>
<ul>
<li>OS X: <code>Cmd + Alt + T</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + T</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980684453567.gif" alt="" /></p>
<h3><a id="%E7%A7%BB%E9%99%A4%E5%8C%85%E8%A3%B9%E4%BB%A3%E7%A0%81%EF%BC%88unwrap-remove%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>移除包裹代码（Unwrap Remove）</h3>
<ul>
<li><strong>描述</strong>：该操作会移除周围的代码，它可能是一条if语句，一个while循环，一个try/catch语句甚至是一个runnable语句。该操作恰恰和包裹代码（Surround With）相反。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Delete</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980686388604.gif" alt="" /></p>
<h3><a id="%E6%89%8B%E5%8A%A8%E5%94%A4%E5%87%BA%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%EF%BC%88class-name-completion%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手动唤出自动补全（Class Name Completion）</h3>
<ul>
<li><strong>描述</strong>：一般使用 Android Studio 的时候，自动提示会在你想要提示的时候自动出现，比如输入 Log. ，就出现 Log.d()、Log.e、Log.i() 等提示。不过如果在自动提示的时候手一抖选错的话，比如想选 Log.d() 结果选了 Log.e() ，你可能会把 .e() 都删掉，然后再输入一个 . ， 然后弹出自动补全提示。其实这时候只需要删除 e() 然后手动唤出自动补全即可。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X/Windows/Linux: <code>Ctrl + Alt + Space</code> (可能存在快捷键冲突无法唤出，修改下快捷键即可)</li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980688325290.gif" alt="" /></p>
<h2><a id="%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调试技巧</h2>
<h3><a id="%E5%88%86%E6%9E%90%E4%BC%A0%E5%85%A5%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%88analyze-data-flow-to-here%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析传入数据流（Analyze data flow to here）</h3>
<ul>
<li><strong>描述</strong>：这个操作将会根据当前选中的变量、参数或者字段，分析出其传递到此处的路径。 当你进入某段陌生的代码，试图明白某个参数是怎么传递到此处的时候，这是一个非常有用的操作。</li>
<li><strong>调用</strong>：Menu → Analyze → Analyze Data Flow to Here</li>
<li><strong>快捷键</strong>：无，可以在设置中指定。</li>
<li><strong>相反的操作</strong>：分析传出数据流（Analyze data flow from here），这个将会分析当前选中的变量往下传递的路径，直到结束。</li>
</ul>
<p><img src="media/15561207869535/2017110415098069615710.gif" alt="" /></p>
<h3><a id="%E5%A0%86%E6%A0%88%E8%BF%BD%E8%B8%AA%E5%88%86%E6%9E%90%EF%BC%88analyze-stacktrace%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>堆栈追踪分析（Analyze Stacktrace）</h3>
<ul>
<li><strong>描述</strong>： 这个操作读取一份堆栈追踪信息，并且使它像logcat中那样可以点击。当你从bug报告中或者终端复制了一份堆栈追踪，使用该操作可以很方便地调试。</li>
<li><strong>调用</strong>：Menu → Analyze → Analyze Stacktrace</li>
<li><strong>快捷键</strong>：无，可以在设置中指定。</li>
<li><strong>更多</strong>：通过使用“ProGuard Unscramble Plugin”插件，也可以分析混淆过的堆栈追踪。</li>
</ul>
<p><img src="media/15561207869535/2017110415098070105942.gif" alt="" /></p>
<h3><a id="%E5%85%B3%E8%81%94%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%EF%BC%88attach-debugger%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关联调试程序（Attach Debugger）</h3>
<ul>
<li><strong>描述</strong>：随时启动调试程序，即使你没有以调试模式启动你的应用。这是一个很方便的操作，因为你不必为了调试程序而以调试模式重新部署你的应用。当别人正在测试应用，突然遇到一个bug而将设备交给你时，你也可以很快地进入调试模式。</li>
<li><strong>调用</strong>：点击工具栏图标或者Menu → Build → Attach to Android Process</li>
<li><strong>快捷键</strong>：无，可以在设置中指定，或者点击工具栏对应的图标。</li>
</ul>
<p><img src="media/15561207869535/20171104150980702475158.gif" alt="" /></p>
<h3><a id="%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9%EF%BC%88conditional-breakpoints%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>条件断点（Conditional Breakpoints）</h3>
<ul>
<li><strong>描述</strong>：简单说，就是当设定的条件满足时，才会触发断点。你可以基于当前范围输入一个java布尔表达式，并且条件输入框内是支持代码补全的。</li>
<li><strong>调用</strong>：右键需要填写表达式的断点，然后输入布尔表达式。</li>
</ul>
<p><img src="media/15561207869535/20171104150980704751679.gif" alt="" /></p>
<h3><a id="%E7%A6%81%E7%94%A8%E6%96%AD%E7%82%B9%EF%BC%88disable-breakpoints%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>禁用断点（Disable Breakpoints）</h3>
<ul>
<li>这个操作将使得断点。当你有一个设置过复杂条件的断点或者是日志断点，当前不需要，但是下次又不用重新创建，该操作是很方便的。</li>
<li><strong>调用</strong>：按住Alt，然后单击断点即可。</li>
</ul>
<p><img src="media/15561207869535/20171104150980707081458.gif" alt="" /></p>
<h3><a id="%E8%AE%A1%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88evaluate-expression%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算表达式（Evaluate Expression）</h3>
<ul>
<li><strong>描述</strong>：这个操作可以用来查看变量的内容并且计算几乎任何有效的java表达式。需要注意的是，如果你修改了变量的状态，这个状态在你恢复代码执行后依然会保留。</li>
<li><strong>快捷键</strong>：处在断点状态时，光标放在变量处，按Alt + F8，即可显示计算表达式对话框。</li>
</ul>
<p><img src="media/15561207869535/20171104150980709720976.gif" alt="" /></p>
<h3><a id="%E5%AE%A1%E6%9F%A5%E5%8F%98%E9%87%8F%EF%BC%88inspect-variable%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>审查变量（Inspect Variable）</h3>
<ul>
<li><strong>描述</strong>：该操作可以在不打开计算表达式对话框就能审查表达式的值。</li>
<li><strong>快捷键</strong>：调试状态下，按住Alt键，然后单击表达式即可。</li>
</ul>
<p><img src="media/15561207869535/2017110415098071175665.gif" alt="" /></p>
<h3><a id="%E6%97%A5%E5%BF%97%E6%96%AD%E7%82%B9%EF%BC%88logging-breakpoints%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>日志断点（Logging Breakpoints）</h3>
<ul>
<li><strong>描述</strong>：这是一种打印日志而不是暂停的断点，当你想打印一些日志信息但是不想添加log代码后重新部署项目，这是一个非常有用的操作。</li>
<li><strong>调用</strong>：在断点上右键，取消Suspend的勾选，然后勾选上Log evaluated Expression，并在输入框中输入你要打印的日志信息。</li>
</ul>
<p><img src="media/15561207869535/20171104150980717148789.gif" alt="" /></p>
<h3><a id="%E6%A0%87%E8%AE%B0%E5%AF%B9%E8%B1%A1%EF%BC%88mark-object%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标记对象（Mark Object）</h3>
<ul>
<li><strong>描述</strong>：当你在调试的时候，这个操作可以让你给某个特殊的对象添加一个标签，方便你后面很快地辨认。在调试时，当你从一堆相似的对象中查看某个对象是否和之前是一样的，这就是一个非常有用的操作。</li>
<li><strong>调用</strong>：右键你需要标记的对象，选中Mark Object，输入标签；</li>
<li><strong>快捷键</strong>：选中对象时
<ul>
<li>OS X: <code>F3 </code></li>
<li>Windows/Linux: <code>F11</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980728765306.gif" alt="" /></p>
<h3><a id="%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E7%82%B9%EF%BC%88show-execution-point%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>显示当前运行点（Show Execution Point）</h3>
<ul>
<li><strong>描述</strong>：该操作会立刻把你的光标移回到当前debug处。</li>
</ul>
<p>通常的情况是：</p>
<ol>
<li>你在某处触发了断点</li>
<li>然后在文件中随意浏览</li>
<li>直接调用这个快捷键，快速返回之前逐步调试的地方。</li>
</ol>
<ul>
<li>快捷键：（Debug时) <code>Alt + F10</code>；</li>
</ul>
<p><img src="media/15561207869535/20171104150980726232579.gif" alt="" /></p>
<h3><a id="%E7%BB%88%E6%AD%A2%E8%BF%9B%E7%A8%8B%EF%BC%88stop-process%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>终止进程（Stop Process）</h3>
<ul>
<li><strong>描述</strong>：该操作会终止当前正在运行的任务。如果任务数量大于一，则显示一个列表供你选择。在终止调试或者中止编译的时候特别有用！</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + F2</code></li>
<li>Windows、Linux: <code>Ctrl + F2</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980743452167.gif" alt="" /></p>
<h3><a id="%E4%B8%B4%E6%97%B6%E6%96%AD%E7%82%B9%EF%BC%88temporary-breakpoints%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>临时断点（Temporary Breakpoints）</h3>
<ul>
<li><strong>描述</strong>：通过该操作可以添加一个断点，这个断点会在第一次被命中的时候自动移除。</li>
<li><strong>快捷键</strong>：
<ul>
<li>鼠标: <code>Alt + 鼠标左键 点击代码左侧</code></li>
<li>OS X: <code>Cmd + Alt + Shift + F8</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + Shift + F8</code></li>
</ul>
</li>
</ul>
<p><img src="media/15561207869535/20171104150980746471135.gif" alt="" /></p>
<h3><a id="%E8%B0%83%E7%94%A8%E5%B1%82%E7%BA%A7%E6%A0%91%E5%BC%B9%E7%AA%97%EF%BC%88the-call-hierarchy-popup%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用层级树弹窗（The Call Hierarchy Popup）</h3>
<ul>
<li><strong>描述</strong>：该操作会给你展示 在一个方法的声明和调用之间所有可能的路径。</li>
<li><strong>快捷键</strong>：<code>Ctrl + Alt + H</code></li>
</ul>
<p><img src="media/15561207869535/20171104150980748531704.gif" alt="" /></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_15.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_17.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/16898402251241/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
