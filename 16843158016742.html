<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  VS Code插件开发教程 - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>VS Code插件开发教程</h1>
     
        <div class="read-more clearfix">
          <span class="date">2023/05/17</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='%E5%B7%A5%E5%85%B7-1-2.html'>工具</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <span id="more"></span><!-- more -->
<h2><a id="%E6%A6%82%E8%A7%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概览</h2>
<p>VS Code的设计思想就是<strong>突出拓展性</strong>，从界面到编辑体验，几乎VS Code的任何部分都可以自定义，并且通过<code>Extension API</code>做到功能强化。实际上VS Code的不少内部核心功能都是通过<code>Extension API</code>实现的</p>
<p><a href="https://code.visualstudio.com/api">官方开发指南</a><br />
<a href="https://www.bookstack.cn/read/VS-Code-Extension-Doc-ZH/README.md">开发指南</a></p>
<ul>
<li>
<p>通过阅读<a href="https://code.visualstudio.com/api">VS Code的官方文档</a>，可以获取以下信息：</p>
<ol>
<li>如何编写、运行、调试、测试、以及发布插件</li>
<li>如何使用VS Code提供的丰富的Extension API</li>
<li>知晓<a href="https://code.visualstudio.com/api/extension-guides/overview">开发手册</a>和<a href="https://github.com/microsoft/vscode-extension-samples">示例代码</a></li>
<li>从<a href="https://code.visualstudio.com/api/references/extension-guidelines">拓展手册</a>获取到插件的最佳编写实践</li>
</ol>
</li>
<li>
<p>插件的能力范围</p>
<ol>
<li>如何编写、运行、调试、测试、以及发布插件</li>
<li>主题：改变VS Code的颜色和文件图标</li>
<li>拓展工作台（Workbench）：在界面中增加自定义组件 &amp; 视图</li>
<li>视图（Webview）：利用HTML/CSS/JS创建Webview来展示自定义网页</li>
<li>编程语言：支持新的编程语言</li>
<li>调试：支持新的运行断点</li>
</ol>
</li>
<li>
<p>VS Code开发者文档的结构：</p>
<ol>
<li>起步（Get Started）：用一个Hello World示例来介绍插件的基本概念</li>
<li>插件能力（Extension Capabilities）：从功能角度分类介绍Extension  API</li>
<li>语言拓展（Language Extensions）：以说明手册以及示例代码的方式说明如何实现对新编程语言的支持</li>
<li>测试 &amp; 发布（Testing and Publishing）：对插件测试和发布做更详尽的介绍</li>
<li>进阶主题（Advanced Topics）：介绍Extension Host、远程开发、GitHub代码仓库整合、草案API</li>
<li>参考资料（References）：介绍VS Code API、Contribution Points等话题</li>
</ol>
</li>
<li>
<p>VS Code 更新频率是月更，需要留意以下两个文档</p>
<ol>
<li><a href="https://code.visualstudio.com/updates/v1_56#_extension-authoring">Extension authoring</a>:用于了解最新版本中的新API</li>
<li><a href="https://code.visualstudio.com/updates#_proposed-extension-apis">Proposed extension APIs</a> :用于了解草案API</li>
</ol>
</li>
</ul>
<h2><a id="%E8%B5%B7%E6%AD%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>起步</h2>
<h3><a id="hello-world" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World</h3>
<h4><a id="%E5%BB%BA%E7%AB%8B%E6%A1%86%E6%9E%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建立框架</h4>
<p>进行<strong>VS Code插件开发</strong>的前提是安装了<code>Node.js</code>和<code>Git</code>，并且需要安装官方提供的<code>Yeoman</code>和<code>VS Code Extension Generator</code>来生成插件框架</p>
<pre class="line-numbers"><code class="language-plain_text">npm install -g yo generator-code
</code></pre>
<p>然后可以通过执行<code>yo code</code>创建一个插件框架</p>
<pre class="line-numbers"><code class="language-plain_text"># ? What type of extension do you want to create? New Extension (TypeScript)
# ? What's the name of your extension? HelloWorld
### Press &lt;Enter&gt; to choose default for all options below ###

# ? What's the identifier of your extension? helloworld
# ? What's the description of your extension? LEAVE BLANK
# ? Initialize a git repository? Yes
# ? Bundle the source code with webpack? No
# ? Which package manager to use? npm
</code></pre>
<p>该框架具备基本的功能，我们用VS Code刚刚创建的项目，按下<code>F5键</code>（此时不要打开任何文件），会自动开启一个新的VS Code界面，在这个界面中我们按下<code>Ctrl+Shift+P</code>组合键唤醒<code>Command Palette</code>，然后输入Hello Word命令：</p>
<p><figure><img src="media/16843158016742/16843236834183.jpg" alt="" /></figure></p>
<p>之后我们会在页面的右下角见到<code>Hello World from HelloWord!</code>提示：</p>
<p><figure><img src="media/16843158016742/16843237235897.jpg" alt="" /></figure></p>
<h4><a id="%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改源码</h4>
<p>我们可以试着尝试修改下上述的框架里的代码</p>
<p>定位到<code>src/extension.ts</code>：</p>
<pre class="line-numbers"><code class="language-typescript">// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
import * as vscode from 'vscode';

// this method is called when your extension is activated
// your extension is activated the very first time the command is executed
export function activate(context: vscode.ExtensionContext) {

	// Use the console to output diagnostic information (console.log) and errors (console.error)
	// This line of code will only be executed once when your extension is activated
	  console.log('Congratulations, your extension &quot;helloword&quot; is now active!');

	// The command has been defined in the package.json file
	// Now provide the implementation of the command with registerCommand
	// The commandId parameter must match the command field in package.json
	let disposable = vscode.commands.registerCommand('helloword.helloWorld', () =&gt; {
	   // The code you place here will be executed every time your command is executed
         // Display a message box to the user
     vscode.window.showInformationMessage('Hello World from HelloWord!');
	});

	context.subscriptions.push(disposable);
}

// this method is called when your extension is deactivated
export function deactivate() {}
</code></pre>
<p>我们可以将<code>vscode.window.showInformationMessage('Hello World from HelloWord!');</code>做修改，改为<code>vscode.window.showInformationMessage('这是第一个插件!');</code>，保存修改后，在调试窗口里执行<code>Developer: Reload Window</code>命令:</p>
<p><figure><img src="media/16843158016742/16843239664524.jpg" alt="" /></figure></p>
<p>再次执行<code>Hello World</code>命令，可以看到提示信息发生了变化：</p>
<p><figure><img src="media/16843158016742/16843239807786.jpg" alt="" /></figure></p>
<p>除此之外，我们还可以通过修改<code>package.json</code>的<code>contributes</code>字段信息，来修改命令的名称，如：</p>
<pre class="line-numbers"><code class="language-plain_text">&quot;contributes&quot;: {
   &quot;commands&quot;: [{
      &quot;command&quot;: &quot;helloword.helloWorld&quot;,
+      &quot;title&quot;: &quot;Clock&quot;
   }]
},
</code></pre>
<p>将命令名称改为<code>Clock</code>，则执行命令时会看到<code>Command Palette</code>里的名称已经发生改变</p>
<p><figure><img src="media/16843158016742/16843240402438.jpg" alt="" /></figure></p>
<h4><a id="%E8%B0%83%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调试</h4>
<p>我们可以在源码上直接打断点，运行的时候会自动停止，而且我们可以将鼠标放在变量上，看到变量的具体取值。如果有过浏览器调试经验的话，应该不会感到困难</p>
<p><figure><img src="media/16843158016742/16843242312575.jpg" alt="" /></figure></p>
<h3><a id="hello-world%E8%BF%9B%E9%98%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World 进阶</h3>
<blockquote>
<p>我们在此继续对上面的hello world示例作进一步的分析</p>
</blockquote>
<h4><a id="%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>功能实现原理</h4>
<p>细看起来上面的<code>Hello World</code>插件干了三件事：</p>
<ul>
<li>在<code>package.json</code>中注册<code>onCommand</code>活动事件（<strong>Activation Event</strong>）,以便当用户运行<code>Hello World</code>命令时唤醒（<strong>activated</strong>）插件</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">&quot;activationEvents&quot;: [
   &quot;onCommand:helloword.helloWorld&quot;
]
</code></pre>
<ul>
<li>在<code>package.json</code>中注册<code>contributes.commands</code>（<strong>Contribution Point</strong>），以便可以在<code>Command Palette</code>中使用</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">&quot;contributes&quot;: {
   &quot;commands&quot;: [{
        &quot;command&quot;: &quot;helloword.helloWorld&quot;,
        &quot;title&quot;: &quot;Clock&quot;
    }]
 }  
</code></pre>
<ul>
<li>在<code>extension.ts</code>中用<code>commands.registerCommand</code>（<strong>VS Code API</strong>）给<code>Hello World</code>命令绑定一个具体的函数</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">let disposable = vscode.commands.registerCommand('helloword.helloWorld', () =&gt; {
 // The code you place here will be executed every time your command is executed

 // Display a message box to the user
 vscode.window.showErrorMessage(new Date().toLocaleString());
});
</code></pre>
<p>通过上述分析可知，通常一个插件就是<strong>Contribution Points</strong>、<strong>VS Code API</strong>的组合。官方的<a href="https://code.visualstudio.com/api/extension-capabilities/overview">Extensions Capabilities Overview文档</a>可以帮助你寻找到适合你自己插件的<strong>Contribution Points</strong>和<strong>VS Code API</strong></p>
<h4><a id="%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>项目结构</h4>
<p><code>Hello World</code>插件是以如下结构组织起来的：</p>
<pre class="line-numbers"><code class="language-plain_text">.
├── .vscode
│   ├── launch.json     // Config for launching and debugging the extension 启动/调试配置
│   └── tasks.json      // Config for build task that compiles TypeScript 构建任务配置
├── .gitignore          // Ignore build output and node_modules
├── README.md           // Readable description of your extension's functionality
├── src
│   └── extension.ts    // Extension source code 插件源代码
├── package.json        // Extension manifest 插件申明
├── tsconfig.json       // TypeScript configuration TS配置
</code></pre>
<p>这里我们要将目光集中在<code>package.json</code>、<code>extension.ts</code>，这里是理解<strong>Hello World插件</strong>的关键</p>
<h4><a id="%E6%8F%92%E4%BB%B6%E6%B8%85%E5%8D%95%EF%BC%88extension-manifest-https-code-visualstudio-comapireferencesextension-manifest%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插件清单（<a href="https://code.visualstudio.com/api/references/extension-manifest">Extension Manifest</a>）</h4>
<p>每个<strong>VS Code插件</strong>都必须有一个<code>package.json</code>作为它的 <a href="https://code.visualstudio.com/api/references/extension-manifest">Extension Manifest</a>，这个<code>package.json</code>文件除了包含常见的<strong>Node.js</strong>用到的<code>scripts</code>、<code>devDependencies</code>等字段外，还有<strong>VS Code插件</strong>所特有的<code>contributes</code>、<code>publisher</code>、<code>activationEvents</code>等字段。你可以在官方的 <a href="https://code.visualstudio.com/api/references/extension-manifest">Extension Manifest</a> 文档中找到所有的<strong>VS Code插件字段</strong>。</p>
<p>对于<code>Hello World</code>插件来说，<code>package.json</code>文件内容是这样的：</p>
<pre class="line-numbers"><code class="language-json">{
  // 插件的名字，必须全部小写且不能有空格
  &quot;name&quot;: &quot;helloword&quot;,
  // 用于显示在应用市场的名称，支持中文
  &quot;displayName&quot;: &quot;HelloWord&quot;,
  // 对于插件的描述
  &quot;description&quot;: &quot;&quot;,
  // 版本号
  &quot;version&quot;: &quot;0.0.1&quot;,
  // 表示插件最低支持的vscode版本
  &quot;engines&quot;: {
     &quot;vscode&quot;: &quot;^1.56.0&quot;
  },
  // 插件应用市场分类
  &quot;categories&quot;: [
     &quot;Other&quot;
  ],
  // 插件应用市场关键词
  &quot;keywords&quot;: [],
  // 插件的图标
  &quot;icon&quot;:&quot;&quot;,
  // 扩展的激活事件的数组，就是这个插件可以被哪些事件激活
  &quot;activationEvents&quot;: [
     &quot;onCommand:helloword.helloWorld&quot;
  ],
  // 插件的主入口
  &quot;main&quot;: &quot;./dist/extension.js&quot;,
  // 插件的配置项
  &quot;contributes&quot;: {
     &quot;commands&quot;: [{
        &quot;command&quot;: &quot;helloword.helloWorld&quot;,
        &quot;title&quot;: &quot;Clock&quot;
     }]
  },
  // 脚本文件
  &quot;scripts&quot;: {
     &quot;vscode:prepublish&quot;: &quot;yarn run package&quot;,
     &quot;compile&quot;: &quot;webpack&quot;,
     &quot;watch&quot;: &quot;webpack --watch&quot;,
     &quot;package&quot;: &quot;webpack --mode production --devtool hidden-source-map&quot;,
     &quot;test-compile&quot;: &quot;tsc -p ./&quot;,
     &quot;test-watch&quot;: &quot;tsc -watch -p ./&quot;,
     &quot;pretest&quot;: &quot;yarn run test-compile &amp;&amp; yarn run lint&quot;,
     &quot;lint&quot;: &quot;eslint src --ext ts&quot;,
     &quot;test&quot;: &quot;node ./out/test/runTest.js&quot;
  },
  // 开发依赖
  &quot;devDependencies&quot;: {
     &quot;@types/vscode&quot;: &quot;^1.56.0&quot;,
     &quot;@types/glob&quot;: &quot;^7.1.3&quot;,
     &quot;@types/mocha&quot;: &quot;^8.0.4&quot;,
     &quot;@types/node&quot;: &quot;14.x&quot;,
     &quot;eslint&quot;: &quot;^7.19.0&quot;,
     &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^4.14.1&quot;,
     &quot;@typescript-eslint/parser&quot;: &quot;^4.14.1&quot;,
     &quot;glob&quot;: &quot;^7.1.6&quot;,
     &quot;mocha&quot;: &quot;^8.2.1&quot;,
     &quot;typescript&quot;: &quot;^4.1.3&quot;,
     &quot;vscode-test&quot;: &quot;^1.5.0&quot;,
     &quot;ts-loader&quot;: &quot;^8.0.14&quot;,
     &quot;webpack&quot;: &quot;^5.19.0&quot;,
     &quot;webpack-cli&quot;: &quot;^4.4.0&quot;
  }
}
</code></pre>
<p>这些字段中有几个比较重要，这里单独说一说：</p>
<ul>
<li><code>name</code>、<code>publisher</code>：VS Code会把<code>&lt;publisher&gt;.&lt;name&gt;</code>作为插件的唯一ID，例如这个插件的ID就是<code>vscode-lamengduo-samples.helloword</code></li>
<li><code>main</code>：指明了插件的入口</li>
<li><code>activationEvents</code>、<code>contributes</code>：对应 <strong>Activation Events</strong> 和 <strong>Contribution Points</strong></li>
<li><code>engines.vscode</code>：标记当前插件需要的VS Code最低版本</li>
</ul>
<h5><a id="activationevents%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>activationEvents属性</h5>
<p><strong>1、onLanguage</strong><br />
每当打开解析为特定语言的文件时，就会触发激活事件</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
    // 可以声明多种语言
     &quot;onLanguage:javascript&quot;，
     &quot;onLanguage:json&quot;，
     &quot;onLanguage:python&quot;，
 ],
</code></pre>
<p><strong>2、onCommand</strong><br />
每次调用命令时，就会触发激活事件</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
     &quot;onCommand:test-extension.helloWorld&quot;
 ],
</code></pre>
<p>还需要在contributes进行配置</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
     &quot;commands&quot;: [{
          // 与激活事件中onCommand指令相对应
         &quot;command&quot;: &quot;test-extension.helloWorld&quot;,
         //激活插件的命令
         &quot;title&quot;: &quot;Hello World&quot;
     }]
 },
</code></pre>
<p><strong>3、onDebug</strong><br />
在启动调试会话之前，会触发激活事件</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
      &quot;onDebug&quot;
]
</code></pre>
<p><strong>4、workspaceContains</strong><br />
每当打开文件夹并且该文件夹包含至少一个与glob模式匹配的文件时，会激活事件</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
      &quot;workspaceContains:**/.editorconfig&quot;
]
</code></pre>
<p><strong>5、onFileSystem</strong><br />
以协议（scheme）打开文件或文件夹时触发激活事件。通常是file-协议，也可以用自定义的文件供应器函数替换掉，比如ftp、ssh。</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
      &quot;onFileSystem:sftp&quot;
]
</code></pre>
<p><strong>6、onView</strong><br />
只要在VSCode侧边栏中展开指定ID的视图时，就会触发激活事件</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
    &quot;onView:nodeDependencies&quot;
]
</code></pre>
<p><strong>７、onUri</strong><br />
只要打开该插件的系统范围URI，就会触发激活事件。这个URI协议需要带上vscode或者vscode-insiders协议。</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
    &quot;onUri&quot;
]
</code></pre>
<p><strong>8、onWebviewPanel</strong><br />
vscode需要恢复匹配到viewType的webview视图时触发</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
    &quot;onWebviewPanel:catCoding&quot;
]
</code></pre>
<p><strong>9、</strong>*<br />
当VSCode启动时，插件就会被激活</p>
<pre class="line-numbers"><code class="language-plain_text">&quot;activationEvents&quot;: [
    &quot;*&quot;
]
</code></pre>
<h5><a id="contributes%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>contributes属性</h5>
<p><strong>1、configuration</strong><br />
暴露给用户的配置，用户可以从”用户设置“和”工作区设置“中修改暴露的选项。<br />
可以通过<code>vscode.workspace.getConfiguration(“title”)</code>来读取配置</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;configuration&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;title&quot;: &quot;TypeScript configuration&quot;,
        &quot;properties&quot;: {
            &quot;typescript.useCodeSnippetsOnMethodSuggest&quot;: {
                &quot;type&quot;: &quot;boolean&quot;,
                &quot;default&quot;: false,
                &quot;description&quot;: &quot;Complete functions with their parameter signature.&quot;
            },
            &quot;typescript.tsdk&quot;: {
                &quot;type&quot;: [&quot;string&quot;, &quot;null&quot;],
                &quot;default&quot;: null,
                &quot;description&quot;: &quot;Specifies the folder path containing the tsserver and lib*.d.ts files to use.&quot;
            }
        }
    }
}
</code></pre>
<p><strong>2、configurationDefaults</strong><br />
为特定的语言配置编译器的默认值，修改这个配置会覆盖编译器已经为语言提供的默认配置</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;configurationDefaults&quot;: {
        // 修改markdown语言的默认配置
        &quot;[markdown]&quot;: {
            &quot;editor.wordWrap&quot;: &quot;on&quot;,
            &quot;editor.quickSuggestions&quot;: false
        }
    }
}
</code></pre>
<p><strong>3、commands</strong><br />
设置命令标题和命令体，然后这个命令会显示在命令面板中。<br />
category可以设置前缀，在命令面板中会以分类显示</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;commands&quot;: [{
        &quot;command&quot;: &quot;extension.sayHello&quot;,
        &quot;title&quot;: &quot;Hello World&quot;,// 在命令面板中显示的命令
        &quot;category&quot;: &quot;Hello&quot;
    }]
}
</code></pre>
<p><strong>4、menus</strong></p>
<ol>
<li>为编译器或者文件管理器设置命令的菜单项，即当点击菜单项时会触发命令。</li>
<li>至少包含两个属性：
<ul>
<li>选中时调用的命令 command</li>
<li>何时显示这个菜单项 when</li>
</ul>
</li>
<li>group：定义了菜单的分组，navigation值不同于普通的group值。</li>
<li>可以配置菜单项的地方有：
<ul>
<li>全局命令面板:<code>commandPalette</code></li>
<li>资源管理器上下文菜单：<code>explorer/context</code></li>
<li>编译器上下文菜单：<code>editor/context</code></li>
<li>编译器标题栏：<code>editor/title</code></li>
<li>编译器标题上下文菜单：<code>editor/title/context</code></li>
<li>调试栈视图的上下文菜单：<code>debug/callstack/context</code></li>
<li>SCM标题菜单：<code>scm/title</code></li>
<li>SCM 资源组：<code>scm/resourceGroup/context</code></li>
<li>SCM资源：<code>scm/resource/context</code></li>
<li>SCM改变标题：<code>scm/change/title</code></li>
<li>视图的标题菜单：<code>view/title</code></li>
<li>视图项的菜单：<code>view/item/context</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>示例：当打开文件为markdown类型时，在编译器标题栏添加菜单项</p>
</blockquote>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
     &quot;commands&quot;: [{
         &quot;command&quot;: &quot;extensionts.helloWorld&quot;,
         &quot;title&quot;: &quot;Hello World&quot;
     }],
     &quot;menus&quot;: {
         // 在哪里添加菜单项
         &quot;editor/title&quot;: [{
             // 何时触发
             &quot;when&quot;:&quot;resourceLangId == markdown&quot;,
             // 要触发的命令
             &quot;command&quot;: &quot;extensiondemo.helloWorld&quot;,
             // 分组
             &quot;group&quot;: &quot;navigation&quot;
         }]
     }
 }
</code></pre>
<p><strong>5、groupSorting</strong><br />
菜单项可以通过组来分类，具体的分类不再阐述。</p>
<p><strong>6、keybindings</strong><br />
设置快捷键</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;keybindings&quot;: [{
        // 要执行的命令
        &quot;command&quot;: &quot;extension.sayHello&quot;,
        // 在Windows和Linux下
        &quot;key&quot;: &quot;ctrl+f1&quot;,
        // 在mac下
        &quot;mac&quot;: &quot;cmd+f1&quot;,
        &quot;when&quot;: &quot;editorTextFocus&quot;
    }]
}
</code></pre>
<p><strong>7、languages</strong><br />
配置一门语言，引入一门新的语言或者加强VS Code已有的语言支持。</p>
<pre class="line-numbers"><code class="language-plain_text">...
&quot;contributes&quot;: {
    &quot;languages&quot;: [{
        &quot;id&quot;: &quot;python&quot;,
        &quot;extensions&quot;: [ &quot;.py&quot; ],
        // 包含这门语言的可读性
        &quot;aliases&quot;: [ &quot;Python&quot;, &quot;py&quot; ],
        &quot;filenames&quot;: [ ... ],
        &quot;firstLine&quot;: &quot;^#!/.*\\bpython[0-9.-]*\\b&quot;,
        // 语言配置文件的路径
        &quot;configuration&quot;: &quot;./language-configuration.json&quot;
    }]
}
</code></pre>
<p><strong>8、debuggers</strong><br />
配置VS Code的调试器</p>
<pre class="line-numbers"><code class="language-plain_text">&quot;contributes&quot;: {
    &quot;debuggers&quot;: [{
        // 用于加载配置的调试器唯一标识
        &quot;type&quot;: &quot;node&quot;,
        // 会在UI中显示的调试器名称
        &quot;label&quot;: &quot;Node Debug&quot;,
        // 调试适配的路径
        &quot;program&quot;: &quot;./out/node/nodeDebug.js&quot;,
        // 如果调试适配器的路径是不可执行程序，那么就会用到这个运行时
        &quot;runtime&quot;: &quot;node&quot;,
        &quot;languages&quot;: [&quot;javascript&quot;, &quot;typescript&quot;, &quot;javascriptreact&quot;, &quot;typescriptreact&quot;],
        // 调试器的启动配置参数
        &quot;configurationAttributes&quot;: {
            &quot;launch&quot;: {
                &quot;required&quot;: [ &quot;program&quot; ],
                &quot;properties&quot;: {
                    &quot;program&quot;: {
                        &quot;type&quot;: &quot;string&quot;,
                        &quot;description&quot;: &quot;The program to debug.&quot;
                    }
                }
            }
        },
        // 列出初始化lanuch.json需要加载的配置
        &quot;initialConfigurations&quot;: [{
            &quot;type&quot;: &quot;node&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Launch Program&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/app.js&quot;
        }],
        // 列出编译器launch.json文件可以提供的加载配置智能提示
        &quot;configurationSnippets&quot;: [
            {
                &quot;label&quot;: &quot;Node.js: Attach Configuration&quot;,
                &quot;description&quot;: &quot;A new configuration for attaching to a running node program.&quot;,
                &quot;body&quot;: {
                    &quot;type&quot;: &quot;node&quot;,
                    &quot;request&quot;: &quot;attach&quot;,
                    &quot;name&quot;: &quot;${2:Attach to Port}&quot;,
                    &quot;port&quot;: 9229
                }
            }
        ],
        // 引入替代变量，并绑定到调试器插件实现的命令上
        &quot;variables&quot;: {
            &quot;PickProcess&quot;: &quot;extension.node-debug.pickNodeProcess&quot;
        }
    }]
}
</code></pre>
<p><strong>9、breakpoints</strong><br />
通常调试器插件会有contributes.breakpoints入口，插件可以设置哪些语言可以设置断点</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;breakpoints&quot;: [
        {
            &quot;language&quot;: &quot;javascript&quot;
        },
        {
            &quot;language&quot;: &quot;javascriptreact&quot;
        }
    ]
}
</code></pre>
<p><strong>10、grammars</strong><br />
为一门语言配置TextMate语法，必须提供应用语法的language，Text Mate的scopeName确定了语法和文件路径</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;grammars&quot;: [{
        &quot;language&quot;: &quot;markdown&quot;,
        &quot;scopeName&quot;: &quot;text.html.markdown&quot;,
        &quot;path&quot;: &quot;./syntaxes/markdown.tmLanguage.json&quot;,
        &quot;embeddedLanguages&quot;: {
            &quot;meta.embedded.block.frontmatter&quot;: &quot;yaml&quot;,
            ...
        }
    }]
}
</code></pre>
<p><strong>11、themes</strong><br />
为VS Code添加Text Mate主题，必须添加label来指定主题</p>
<pre class="line-numbers"><code class="language-plain_text">&quot;contributes&quot;: {
    &quot;themes&quot;: [{
        &quot;label&quot;: &quot;Monokai&quot;,
        &quot;uiTheme&quot;: &quot;vs-dark&quot;,
        &quot;path&quot;: &quot;./themes/Monokai.tmTheme&quot;
    }]
}
</code></pre>
<p><strong>12、snippets</strong><br />
为语言添加代码片段，language是语言标识符，path是VSCode代码片段格式的代码片段文件的相对路径</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;snippets&quot;: [{
        &quot;language&quot;: &quot;go&quot;,
        &quot;path&quot;: &quot;./snippets/go.json&quot;
    }]
}
</code></pre>
<p><strong>13、view、viewsContainers</strong><br />
view属性为VSCode添加视图<br />
viewsContainers配置自定义视图的视图容器</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;viewsContainers&quot;: {
        //activitybar:配置活动栏
        &quot;activitybar&quot;: [
            {
                &quot;id&quot;: &quot;package-explorer&quot;,
                &quot;title&quot;: &quot;Package Explorer&quot;,
                &quot;icon&quot;: &quot;resources/package-explorer.svg&quot;
            }
        ]
    },
    &quot;views&quot;: {
        &quot;package-explorer&quot;: [
            {
                &quot;id&quot;: &quot;package-dependencies&quot;,
                &quot;name&quot;: &quot;Dependencies&quot;
            }
        ]
    }
}
</code></pre>
<p><strong>14、colors</strong><br />
状态栏的编译器装饰器，定义之后可以通过workspace.colorCustomization自定义颜色</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
  &quot;colors&quot;: [{
      &quot;id&quot;: &quot;superstatus.error&quot;,
      &quot;description&quot;: &quot;Color for error message in the status bar.&quot;,
      &quot;defaults&quot;: {
          &quot;dark&quot;: &quot;errorForeground&quot;,
          &quot;light&quot;: &quot;errorForeground&quot;,
          &quot;highContrast&quot;: &quot;#010203&quot;
      }
  }]
}
</code></pre>
<h4><a id="%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>入口文件</h4>
<p>每个<strong>VS Code插件</strong>都有一个入口文件（由<code>package.json</code>中的<code>main</code>字段指定），<strong>VS Code</strong>规范要求插件的入口文件需要导出两个函数<code>activate</code>、<code>deactivate</code>。当开发者注册的<strong>Activation Event</strong>被触发时，将会执行<code>activate</code>函数。<code>deactivate</code>函数则主要是给插件开发者一个在插件停止工作之前一个执行清理的机会。对很多应用来说，deactivate其实不是必须的，可以删掉。不过如果你希望当VS Code关闭、插件不可用、插件卸载时做点什么的话，这个方法就有用了。</p>
<p><strong>VS Code</strong>的插件API在 <code>@types/vscode</code> 包中做了类型声明，这个文件将会根据<code>package.json</code>文件中的<code>engines.vscode</code>提供智能提示等服务（如果插件框架是通过<code>yo</code>命令生成的，则<code>@types/vscode</code>会默认安装好）</p>
<h4><a id="%E6%A1%88%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>案例</h4>
<h5><a id="%E6%B7%BB%E5%8A%A0%E5%AD%90%E8%8F%9C%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加子菜单</h5>
<p>最终效果</p>
<p><figure><img src="media/16843158016742/16853589929944.jpg" alt="" /></figure></p>
<h5><a id="%E4%BB%A3%E7%A0%81%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码配置</h5>
<ol>
<li><code>explorerResourceIsFolder</code> 代表该菜单仅在文件夹右键时展示</li>
<li><code>config.fileTemplate.ts.active</code> 代表读取本地 setting 中的配置，true 时展示</li>
</ol>
<pre class="line-numbers"><code class="language-json">// setting 配置
&quot;fileTemplate&quot;: {
	&quot;js&quot;: { &quot;active&quot;: true },
	&quot;ts&quot;: { &quot;active&quot;: true },
	&quot;go&quot;: { &quot;active&quot;: true },
	&quot;vue&quot;: { &quot;active&quot;: true }
}
</code></pre>
<pre class="line-numbers"><code class="language-json">// 插件 package.json 中的配置
	&quot;contributes&quot;: {
        &quot;commands&quot;: [
            {
                &quot;command&quot;: &quot;customTsFileTemplate&quot;,
                &quot;title&quot;: &quot;自定义TS模板&quot;
            },
        ],
        &quot;menus&quot;: {
            &quot;explorer/context&quot;: [
                {
                    &quot;when&quot;: &quot;explorerResourceIsFolder&quot;,
                    &quot;submenu&quot;: &quot;fileTemplate&quot;,
                    &quot;group&quot;: &quot;navigation&quot;
                }
            ],
            &quot;fileTemplate&quot;: [
                {
                    &quot;when&quot;: &quot;config.fileTemplate.ts.active&quot;,
                    &quot;command&quot;: &quot;customTsFileTemplate&quot;,
                    &quot;group&quot;: &quot;navigation&quot;
                },
            ]
        },
        &quot;submenus&quot;: [
            {
                &quot;id&quot;: &quot;fileTemplate&quot;,
                &quot;label&quot;: &quot;生成自定义代码模板&quot;
            }
        ],
    },
</code></pre>
<h5><a id="%E4%BD%BF%E7%94%A8when%E6%97%B6%E7%9B%B8%E5%85%B3%E5%85%B3%E9%94%AE%E5%AD%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 when 时相关关键字</h5>
<p><a href="https://code.visualstudio.com/api/references/when-clause-contexts">官方文档</a></p>
<p><strong>逻辑操作符</strong></p>
<p><figure><img src="media/16843158016742/16853591069647.jpg" alt="" /></figure></p>
<p><strong>关键字（太多了，截图只是一部分，详情看看官方链接）</strong><br />
如下图 <code>explorerResourceIsFolder</code> 表示是否文件夹</p>
<p><figure><img src="media/16843158016742/16853591279629.jpg" alt="" /></figure></p>
<h5><a id="%E8%AE%BE%E7%BD%AEvscode-setting%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置 vscode setting 配置</h5>
<p><strong>配置</strong><br />
只有配置 <code>configuration</code> 之后才可以使用本地 vscode setting 的配置</p>
<pre class="line-numbers"><code class="language-json">// package.json 中 contributes 中 configuration 配置举例
&quot;configuration&quot;: {
    &quot;title&quot;: &quot;languageList&quot;,
    &quot;properties&quot;: {
        &quot;snippetType&quot;: {
            &quot;type&quot;: &quot;array&quot;,
            &quot;default&quot;: [],
            &quot;description&quot;: &quot;select language to use \n js =&gt; .js .jsx \n ts =&gt; .ts .tsx \n vue =&gt; .vue \n go =&gt; .go&quot;
        },
        &quot;fileTemplate&quot;: {
            &quot;type&quot;: &quot;object&quot;,
            &quot;default&quot;: {},
            &quot;description&quot;: &quot;select fileTemplate to use （ go js ts vue ）&quot;
        }
    }
}
</code></pre>
<pre class="line-numbers"><code class="language-json">// vscode setting 中配置
&quot;snippetType&quot;: [
    { &quot;language&quot;: &quot;js&quot; },
    { &quot;language&quot;: &quot;ts&quot; }
],
&quot;fileTemplate&quot;: {
    &quot;js&quot;: { &quot;active&quot;: true },
    &quot;ts&quot;: { &quot;active&quot;: true },
    &quot;go&quot;: { &quot;active&quot;: true },
    &quot;vue&quot;: { &quot;active&quot;: true }
}
</code></pre>
<p><strong>使用</strong></p>
<p>插件中读取<br />
<code>const config = vscode.workspace.getConfiguration().get('snippetType');</code></p>
<p>when 中使用的时候读取<br />
<code>config.fileTemplate.ts.active </code></p>
<h2><a id="%E6%8F%92%E4%BB%B6%E8%83%BD%E5%8A%9Bcapabilities" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插件能力 Capabilities</h2>
<h3><a id="%E9%80%9A%E7%94%A8%E8%83%BD%E5%8A%9Bcommon-capabilities" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>通用能力 Common Capabilities</h3>
<p>在任何插件中，通用能力都是核心功能，通用能力包括但不限于：</p>
<ul>
<li>注册命令，配置，快捷键，上下文菜单</li>
<li>存储工作区或全局的数据</li>
<li>展示提示信息</li>
<li>用Quick Pick收集用户输入</li>
<li>调用本地文件选择器以便用户选择文件</li>
<li>利用Progress API为用户展示长时间运行的操作进度</li>
</ul>
<p>通用能力主要有以下几种：</p>
<ul>
<li><strong>命令（Command）</strong>：命令在VS Code的运转中扮演极为重要的角色。你会通过Command Palette、绑定快捷键或者右键菜单来执行命令，而对于一个插件来说，应该做到下面这两点：
<ul>
<li>通过 <a href="https://code.visualstudio.com/api/references/vscode-api#commands">vscode.commands</a> API 来注册和执行命令</li>
<li>通过 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.commands">contributes.commands</a> (Contribution Point) 来让命令在Command Palette中可用</li>
</ul>
</li>
<li><strong>配置（Configuration）</strong>：一个插件如果需要用户配置（这是很常见的），那么可以通过 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.configuration">contributes.configuration</a> 实现插件配置项的声明（<code>contributes.configuration</code>定义了该插件的配置字段以及默认值等信息，用户可以实现工作区配置或全局配置，可以参考 ESLint插件的配置 ），然后通过 <a href="https://code.visualstudio.com/api/references/vscode-api#workspace.getConfiguration">workspace.getConfiguration</a> 接口实现获取用户实际的配置值</li>
<li><strong>快捷键（Keybinding）</strong>：一个插件可以添加自定义快捷键，详见 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.keybindings">contributes.keybindings</a></li>
<li><strong>上下文菜单（Context Menu）</strong>：插件可以添加自定义上线文菜单项，详见 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.menus">contributes.menus</a></li>
<li><strong>数据存储（Data Storage）</strong>：有4种数据存储的方式（注：<code>extension context</code>在入口文件的<code>activate</code>函数中可用，是该函数的第一个参数）
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.workspaceState">ExtensionContext.workspaceState</a>：工作空间（<a href="https://code.visualstudio.com/docs/editor/workspaces">workspace</a>）域，以键值对方式存储，由VS Code负责管理。当工作空间再次被打开时，存储的数据会被恢复。</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.globalState">ExtensionContext.globalState</a>：全局域，以键值对方式存储，由<code>VS Code</code>负责管理。当任何一个插件被激活时，存储的数据会被恢复。插件可以同步的读取到键值对数据并且通过<code>setKeysForSync</code>方法异步的赋值</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.storagePath">ExtensionContext.storagePath</a>：工作空间（<a href="https://code.visualstudio.com/docs/editor/workspaces">workspace</a>）域，可以为一个工作空间指定一个存储路径（一个本地的目录），当我们需要给一个工作空间存储较大的数据时（例如文件），该功能非常有用</li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#ExtensionContext.globalStoragePath">ExtensionContext.globalStoragePath</a>：全局域，可以为全局空间指定一个存储路径（一个本地的目录），当我们需要在不同的插件之间共用大的数据时（例如文件），该功能非常有用</li>
</ul>
</li>
<li><strong>展示通知（Display Notifications）</strong>：几乎所有的插件都会用到通知功能，<code>VS Code</code>提供了3个API用于不同级别的通知：
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showInformationMessage">window.showInformationMessage</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showWarningMessage">window.showWarningMessage</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.showErrorMessage">window.showErrorMessage</a></li>
</ul>
</li>
<li><strong>快速选择（Quick Pick）</strong>：通过 <a href="https://code.visualstudio.com/api/references/vscode-api#QuickPick">vscode.QuickPick</a> API ,提供给用户一些选项去选择，开发者可以很容易的获取到用户的选择，可以通过该 <a href="https://github.com/microsoft/vscode-extension-samples/tree/main/quickinput-sample">QuickInput Sample</a> 示例学习相关API的用法</li>
<li><strong>文件选择（File Picker）</strong>：通过 <a href="https://code.visualstudio.com/api/references/vscode-api#vscode.window.showOpenDialog">vscode.window.showOpenDialog</a> 接口可以让用户选择本地的文件</li>
<li><strong>输出通道（Output Channel）</strong>：输出面板（Output Panel）是一系列 <a href="https://code.visualstudio.com/api/references/vscode-api#OutputChannel">OutputChannel</a> 的集合，可以通过 <a href="https://code.visualstudio.com/api/references/vscode-api#window.createOutputChannel">window.createOutputChannel</a> 实现</li>
<li><strong>进度（Progress）</strong>：可以通过 <a href="https://code.visualstudio.com/api/references/vscode-api#Progress">vscode.Progress</a> 接口将进度展示给用户，同时可以通过 <a href="https://code.visualstudio.com/api/references/vscode-api#ProgressLocation">ProgressLocation</a>方法指定显示的位置  我们可以通过这个示例来学习</li>
</ul>
<h3><a id="%E4%B8%BB%E9%A2%98%EF%BC%88theming%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主题（Theming）</h3>
<p>主题影响<code>VS Code</code>的外观，包括<code>VS Code</code>以及编辑器中代码的配色，我们可以借助该特性做以下事情：</p>
<ul>
<li>改变编辑区代码的配色</li>
<li>改变<code>VS Code</code>界面的配色</li>
<li>增加自定义文件图标</li>
</ul>
<p>在<code>VS Code</code>中，有三种类型的主题：</p>
<ul>
<li>颜色主题（Color Theme）：UI组件的颜色以及文本字符的颜色，创建主颜色主题的方法可以参见 <a href="https://code.visualstudio.com/api/extension-guides/color-theme">Color Theme Guide</a> ,还可以参考这个示例 <a href="https://github.com/microsoft/vscode-extension-samples/tree/main/theme-sample">Color Theme Sample</a><br />
<figure><img src="media/16843158016742/16843952898088.jpg" alt="" /></figure>
<ul>
<li><code>colors</code>：标记了UI组件的控制色</li>
<li><code>tokenColors</code>：标记了编辑区域的颜色和样式,详见 <a href="https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide">Syntax Highlight Guide</a> 获取更多信息</li>
<li><code>semanticTokenColors</code>：编辑区域高亮的加强版，详见 <a href="https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide">Semantic Highlight Guide</a></li>
</ul>
</li>
<li>文件图标主题：将文件类型、名称对应为指定的图标（图片）,<a href="https://code.visualstudio.com/api/extension-guides/file-icon-theme">File Icon Theme Guide</a> 有对如何创建文件图标主题的详细介绍<br />
<figure><img src="media/16843158016742/16843953888782.jpg" alt="" /></figure></li>
<li>产品图标主题：用在<strong>UI</strong>、<strong>Side bar</strong>、<strong>Activity bar</strong>、<strong>status bar</strong>等处的图标，<a href="https://code.visualstudio.com/api/extension-guides/product-icon-theme">Product Icon Theme Guide</a> 详细介绍了如何创建产品图标主题</li>
</ul>
<h3><a id="%E5%A3%B0%E6%98%8E%E5%BC%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%EF%BC%88declarative-language-features%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明式语言特性（Declarative Language Features）</h3>
<p><a href="https://code.visualstudio.com/api/language-extensions/overview#declarative-language-features">Declarative Language Features</a> 包含了基本的编程语言文本编辑能力，比如小括号匹配、自动缩进以及语法高亮。这些都是采用声明式（declaratively）来实现，不用编写任何代码。不过声明语言特性不支持语法提示以及debug之类的高级特性。我们可以借助该特性做以下事情：</p>
<ul>
<li>给一个插件绑定通用JavaScript语法片段（snippets）</li>
<li>告知<strong>VS Code</strong>一种新的编程语言</li>
<li>增添或替换一种编程语言的语法</li>
<li>通过<strong>grammar injection</strong>拓展已经存在的语法</li>
</ul>
<h3><a id="%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%EF%BC%88programmatic-language-features%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编程式语言特性（Programmatic Language Features）</h3>
<p><a href="https://code.visualstudio.com/api/language-extensions/overview#programmatic-language-features">Programmatic language features</a> 提供了更加丰富的语言功能，例如<code>Hovers</code>、跳转到定义、错误诊断、智能感知、CodeLens（<a href="https://code.visualstudio.com/blogs/2017/02/12/code-lens-roundup">参考文章</a>）。这些特性都可以通过调用 <a href="https://code.visualstudio.com/api/references/vscode-api#languages">vscode.languages.*</a>接口实现，不过也可以通过编写<code>Language Server</code>来实现。我们可以借助编程式语言特性（Programmatic Language Features）做以下事情：</p>
<ul>
<li>通过悬浮来展示一个API的用法</li>
<li>通过错误诊断来报告源码中的拼写错误</li>
<li>注册一个新的HTML式化工具</li>
<li>提供一个强大的、上下文感知的智能提示器</li>
<li>给一个语言提供折叠、面包屑功能</li>
</ul>
<h3><a id="%E5%B7%A5%E4%BD%9C%E5%8F%B0%E6%8B%93%E5%B1%95%EF%BC%88workbench-extensions%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作台拓展（Workbench Extensions）</h3>
<p><a href="https://code.visualstudio.com/api/extension-capabilities/extending-workbench">Workbench Extensions</a> 可以用来扩展<strong>VS Code</strong>的工作台，还可以拓展鼠标右键，甚至通过<strong>VS Code</strong>的 <a href="https://code.visualstudio.com/api/extension-guides/tree-view">TreeView API</a> 建立一个自定义<code>explorer</code>（如果想要一个更加自定义的用户界面，可以通过 <a href="https://code.visualstudio.com/api/extension-guides/webview">Webview API</a>）。我们可以借助工作台拓展（Workbench Extensions）做以下事情：</p>
<ul>
<li>在文件浏览菜单增加一个自定义上下文菜单行为</li>
<li>在侧边栏（<code>Side Bar</code>）增加新的、可交互的树视图（<code>TreeView</code>）</li>
<li>定义一个新的<code>Activity Bar</code>视图</li>
<li>在<code>Status Bar</code>显示新的信息</li>
<li>通过 <a href="https://code.visualstudio.com/api/extension-guides/webview">Webview API</a> 实现自定义内容渲染</li>
</ul>
<p><strong>VS Code</strong>提供了一系列的API帮助开发者在<code>Workbench</code>（<code>Title Bar</code>、<code>Activity Bar</code>、<code>Side Bar</code>、<code>Panel</code>、<code>Editor Group</code>、<code>Status Bar</code>）里添加自己的组件，例如：</p>
<p><figure><img src="media/16843158016742/16844865909959.jpg" alt="" /></figure></p>
<ul>
<li><strong>Activity Bar</strong>：Azure App Service 插件增加了一个<code>View Container</code></li>
<li><strong>Side Bar</strong>：内置的 NPM 插件增加了一个<code>Tree View</code></li>
<li><strong>Editor Group</strong>：内置的 Markdown 插件增加了一个 <code>Webview</code></li>
<li><strong>Status Bar</strong>：VSCodeVim 插件增加了一个 <code>Status Bar Item</code>（可以用文字或图标来展示，并且在点击的时候执行命令， Status Bar的应用示例可以参见 <a href="https://github.com/microsoft/vscode-extension-samples/tree/main/statusbar-sample">statusbar-sample</a>）</li>
</ul>
<h3><a id="%E8%B0%83%E8%AF%95%EF%BC%88debugging%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调试（Debugging）</h3>
<p>你可以利用<strong>VS Code</strong>的 <a href="https://code.visualstudio.com/docs/editor/debugging">Debugging</a> 功能编写<a href="https://code.visualstudio.com/api/extension-guides/debugger-extension">Debugger Extension</a>，将<strong>VS Code</strong>的调试界面用于实现某种<code>debugger</code>。我们可以借助该特性做以下事情：</p>
<ul>
<li>通过 <a href="https://microsoft.github.io/debug-adapter-protocol/implementors/adapters/">Debug Adapter implementation</a> 将<strong>VS Code</strong>的调试UI和一个调试器链接</li>
<li>新增对某一种语言的调试支持</li>
<li>提供调试配置信息的自动补全</li>
</ul>
<p>另一方面，<strong>VS Code</strong>提供了一系列 <a href="https://code.visualstudio.com/api/references/vscode-api#debug">Debug Extension API</a> ,可以用来实现调试的自动化，我们可以借助该特性做以下事情：</p>
<ul>
<li>通过动态的调试配置来启动调试任务</li>
<li>跟踪调试任务的生命周期</li>
<li>以编程的方式创建和管理断点</li>
</ul>
<h3><a id="%E6%8B%93%E5%B1%95%E5%8E%9F%E5%88%99%EF%BC%88extension-guidelines%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>拓展原则（Extension Guidelines）</h3>
<p>为了帮助开发者编写合乎<strong>VS Code</strong>风格的插件，<strong>VS Code</strong>提供 <a href="https://code.visualstudio.com/api/references/extension-guidelines">Extension Guidelines</a> 来帮助开发者学会<strong>VS Code</strong>插件的最佳开发实践</p>
<h3><a id="%E9%99%90%E5%88%B6%EF%BC%88restrictions%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>限制（Restrictions）</h3>
<p>插件无法访问到<strong>VS Code</strong>界面的DOM，没法通过编写自己的CSS或HTML来改变<strong>VS Code</strong>的界面，<strong>VS Code</strong>通过<a href="https://code.visualstudio.com/api/advanced-topics/extension-host">Extension Host</a> 进程来管理插件，杜绝插件对界面的篡改以及可能的性能与稳定性影响。</p>
<h2><a id="%E6%8F%92%E4%BB%B6%E6%8C%87%E5%8D%97extension-guidesd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插件指南 Extension Guidesd</h2>
<h3><a id="%E4%B8%80%E8%88%AC%E6%8F%92%E4%BB%B6%E6%8C%87%E5%8D%97%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一般插件指南&amp;示例</h3>
<p>后续我们会介绍一系列的开发指南和示例，包含<strong>VS Code API</strong>和<strong>Contribution Points</strong>的用法，下面我们以列表的形式将这些指南和示例罗列出来</p>
<h4><a id="%E6%8C%87%E5%8D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>指南</h4>
<table>
<thead>
<tr>
<th>指南</th>
<th>API &amp; Contribution</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#commands">commands</a></td>
</tr>
<tr>
<td>Color Theme</td>
<td><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.themes">contributes.themes</a></td>
</tr>
<tr>
<td>File Icon Theme</td>
<td><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.iconThemes">contributes.iconThemes</a></td>
</tr>
<tr>
<td>Product Icon Theme</td>
<td><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.productIconThemes">contributes.productIconThemes</a></td>
</tr>
<tr>
<td>Tree View</td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTreeView">window.createTreeView</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerTreeDataProvider">window.registerTreeDataProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TreeView">TreeView</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider">TreeDataProvider</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.views">contributes.views</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.viewsContainers">contributes.viewsContainers</a></td>
</tr>
<tr>
<td>Webview</td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createWebviewPanel">window.createWebviewPanel</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerWebviewPanelSerializer">window.registerWebviewPanelSerializer</a></td>
</tr>
<tr>
<td>Custom Editors</td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerCustomEditorProvider">window.registerCustomEditorProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#CustomTextEditorProvider">CustomTextEditorProvider</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.customEditors">contributes.customEditors</a></td>
</tr>
<tr>
<td>Virtual Documents</td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.registerTextDocumentContentProvider">workspace.registerTextDocumentContentProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand">commands.registerCommand</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.showInputBox">window.showInputBox</a></td>
</tr>
<tr>
<td>Task Provider</td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#tasks.registerTaskProvider">tasks.registerTaskProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Task">Task</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#ShellExecution">ShellExecution</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.taskDefinitions">contributes.taskDefinitions</a></td>
</tr>
<tr>
<td>Source Control</td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders">workspace.workspaceFolders</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#SourceControl">SourceControl</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#SourceControlResourceGroup">SourceControlResourceGroup</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#scm.createSourceControl">scm.createSourceControl</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextDocumentContentProvider">TextDocumentContentProvider</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.menus">contributes.menus</a></td>
</tr>
<tr>
<td>Debugger Extension</td>
<td><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.breakpoints">contributes.breakpoints</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.debuggers">contributes.debuggers</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#debug">debug</a></td>
</tr>
<tr>
<td>Markdown Extension</td>
<td>markdown.previewStyles<br>markdown.markdownItPlugins<br>markdown.previewScripts</td>
</tr>
<tr>
<td>Custom Data Extension</td>
<td>contributes.html.customData<br>contributes.css.customData</td>
</tr>
</tbody>
</table>
<h4><a id="%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例</h4>
<blockquote>
<p>示例的源代码参见 <a href="https://github.com/microsoft/vscode-extension-samples">示例插件代码仓库</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>示例</th>
<th>API &amp; Contribution</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/webview-sample">Webview Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createWebviewPanel">window.createWebviewPanel</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerWebviewPanelSerializer">window.registerWebviewPanelSerializer</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/statusbar-sample">Status Bar Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem">window.createStatusBarItem</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem">StatusBarItem</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/tree-view-sample">Tree View Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTreeView">window.createTreeView</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerTreeDataProvider">window.registerTreeDataProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TreeView">TreeView</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider">TreeDataProvider</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.views">contributes.views</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.viewsContainers">contributes.viewsContainers</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/task-provider-sample">Task Provider Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#tasks.registerTaskProvider">tasks.registerTaskProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Task">Task</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#ShellExecution">ShellExecution</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.taskDefinitions">contributes.taskDefinitions</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/basic-multi-root-sample">Multi Root Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.getWorkspaceFolder">workspace.getWorkspaceFolder</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.onDidChangeWorkspaceFolders">workspace.onDidChangeWorkspaceFolders</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/completions-sample">Completion Provider Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider">languages.registerCompletionItemProvider</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#CompletionItem">CompletionItem</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#SnippetString">SnippetString</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/fsprovider-sample">File System Provider Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.registerFileSystemProvider">workspace.registerFileSystemProvider</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/decorator-sample">Editor Decoractor Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor.setDecorations">TextEditor.setDecorations</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#DecorationOptions">DecorationOptions</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#DecorationInstanceRenderOptions">DecorationInstanceRenderOptions</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#ThemableDecorationInstanceRenderOptions">ThemableDecorationInstanceRenderOptions</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTextEditorDecorationType">window.createTextEditorDecorationType</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorDecorationType">TextEditorDecorationType</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.colors">contributes.colors</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/i18n-sample">I18n Sample</a></td>
<td><strong>-</strong></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/terminal-sample">Terminal Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#window.createTerminal">window.createTerminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidChangeActiveTerminal">window.onDidChangeActiveTerminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidCloseTerminal">window.onDidCloseTerminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.onDidOpenTerminal">window.onDidOpenTerminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.Terminal">window.Terminal</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.terminals">window.terminals</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/vim-sample">Vim Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#commands">commands</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#StatusBarItem">StatusBarItem</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.createStatusBarItem">window.createStatusBarItem</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorCursorStyle">TextEditorCursorStyle</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#window.activeTextEditor">window.activeTextEditor</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Position">Position</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Range">Range</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#Selection">Selection</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditor">TextEditor</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextEditorRevealType">TextEditorRevealType</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextDocument">TextDocument</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/source-control-sample">Source Control Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#workspace.workspaceFolders">workspace.workspaceFolders</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#SourceControl">SourceControl</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#SourceControlResourceGroup">SourceControlResourceGroup</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#scm.createSourceControl">scm.createSourceControl</a><br><a href="https://code.visualstudio.com/api/references/vscode-api#TextDocumentContentProvider">TextDocumentContentProvider</a><br><a href="https://code.visualstudio.com/api/references/contribution-points#contributes.menus">contributes.menus</a></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/comment-sample">Commenting API Sample</a></td>
<td><strong>-</strong></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/document-editing-sample">Document Editing Sample</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#commands">commands</a></td>
</tr>
</tbody>
</table>
<h3><a id="%E8%AF%AD%E8%A8%80%E6%8F%92%E4%BB%B6%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语言插件示例</h3>
<table>
<thead>
<tr>
<th>示例</th>
<th>指南</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/snippet-sample">Snippet Sample</a></td>
<td>[Snippet Guide]</td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/language-configuration-sample">Language Configuration Sample</a></td>
<td>[Language Configuration Guide]</td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/lsp-sample">LSP Sample</a></td>
<td>[Language Server Extension Guide]</td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/lsp-log-streaming-sample">LSP Log Streaming Sample</a></td>
<td><strong>-</strong></td>
</tr>
<tr>
<td><a href="https://github.com/microsoft/vscode-extension-samples/tree/main/lsp-multi-server-sample">LSP Multi Root Server Sample</a></td>
<td><a href="https://github.com/microsoft/vscode/wiki/Adopting-Multi-Root-Workspace-APIs#language-client--language-server">language-client--language-server</a></td>
</tr>
</tbody>
</table>
<h2><a id="%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8command" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命令的使用 Command</h2>
<p>在<strong>Visual Studio Code</strong>中命令会触发一系列行为，如果你曾经配置过快捷键，那么你就算是和命令打过交道了，命令经常被插件用于给用户暴露某项功能，或是给UI绑定某些行为，又或是实现内部逻辑</p>
<h3><a id="%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命令的使用</h3>
<p><strong>VS Code</strong>包含一系列 <a href="https://code.visualstudio.com/api/references/commands">内置命令</a> ，通过这些内置命令你可以和编辑器交互、控制用户界面、执行后台任务，很多的插件通常也是通过命令导出它们的核心功能以便其它插件或使用者复用</p>
<h4><a id="%E7%BC%96%E7%A0%81%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编码执行命令</h4>
<p>通过 <a href="https://code.visualstudio.com/api/references/vscode-api#commands.executeCommand">vscode.commands.executeCommand</a> 接口可以编码方式执行命令，以便开发插件的时候可以使用到<strong>VS Code</strong>内置的功能或者利用内置的<strong>Git</strong>、<strong>Markdown</strong>插件。<br />
举例来说，<code>editor.action.addCommentLine</code>命令会把当前选中的行注释掉</p>
<pre class="line-numbers"><code class="language-plain_text">import * as vscode from 'vscode';

function commentLine() {
  vscode.commands.executeCommand('editor.action.addCommentLine');
}
</code></pre>
<p>有些命令会接收一些参数来控制行为，命令可能还会返回结果。例如<code>vscode.executeDefinitionProvider</code>命令，会接收一个<strong>文档URI</strong>和<strong>位置</strong>作为参数，返回一个定义列表</p>
<pre class="line-numbers"><code class="language-plain_text">import * as vscode from 'vscode';

async function printDefinitionsForActiveEditor() {
  const activeEditor = vscode.window.activeTextEditor;
  if (!activeEditor) {
    return;
  }

  const definitions = await vscode.commands.executeCommand&lt;vscode.Location[]&gt;(
    'vscode.executeDefinitionProvider',
    activeEditor.document.uri,
    activeEditor.selection.active
  );

  for (const definition of definitions) {
    console.log(definition);
  }
}
</code></pre>
<p>我们可以从下面两个地方找到有效的命令：</p>
<ul>
<li><a href="https://code.visualstudio.com/docs/getstarted/keybindings">Browse the keyboard shortcuts</a></li>
<li><a href="https://code.visualstudio.com/api/references/commands">Look through VS Code's built-in advanced commands api</a></li>
</ul>
<h4><a id="%E5%91%BD%E4%BB%A4uris" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命令URIs</h4>
<p>命令URI是若干链接，用于执行给定的命令，可以用在悬浮文案、webview中的的可点击连接上。一个命令URI用<code>command</code>协议，后面接着命令名称，例如对于<code>editor.action.addCommentLine</code>命令，它的命令URI是<code>command:editor.action.addCommentLine</code>。我们这里有个<code>hover provider</code>,展示了在链接中使用命令URI：</p>
<pre class="line-numbers"><code class="language-plain_text">const vscode = require('vscode');

function activate(context) {
    context.subscriptions.push(
        vscode.languages.registerHoverProvider(&quot;javascript&quot;, {
            provideHover: (document, position) =&gt; {
                const commentCommandUri = vscode.Uri.parse(`command:editor.action.addCommentLine`);
                const contents = new vscode.MarkdownString(`[Add comment](${commentCommandUri})`);
                // To enable command URIs in Markdown content, you must set the `isTrusted` flag.
                // When creating trusted Markdown string, make sure to properly sanitize all the
                // input content so that only expected command URIs can be executed
                contents.isTrusted = true;
                return new vscode.Hover(contents);
            },
        })
    );
}
</code></pre>
<p>当悬停时显示一个链接：</p>
<p><figure><img src="media/16843158016742/16845715705091.jpg" alt="" /></figure></p>
<p>点击该链接会执行<code>editor.action.addCommentLine</code>命令，将当前行变为注释</p>
<p><figure><img src="media/16843158016742/16845715921101.jpg" alt="" /></figure></p>
<p>对于需要给命令URI以JSON形式传递若干参数的情况，需要将参数URI编码，例如：</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  vscode.languages.registerHoverProvider(
    'javascript',
    new (class implements vscode.HoverProvider {
      provideHover(
        document: vscode.TextDocument,
        _position: vscode.Position,
        _token: vscode.CancellationToken
      ): vscode.ProviderResult&lt;vscode.Hover&gt; {
        const args = [{ resourceUri: document.uri }];
        const stageCommandUri = vscode.Uri.parse(
          `command:git.stage?${encodeURIComponent(JSON.stringify(args))}`
        );
        const contents = new vscode.MarkdownString(`[Stage file](${stageCommandUri})`);
        contents.isTrusted = true;
        return new vscode.Hover(contents);
      }
    })()
  );
}
</code></pre>
<p>你可以通过在<code>WebviewOptions</code>中设置<code>enableCommandUris</code>来实现在webview中使用命令URI</p>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建命令</h3>
<h4><a id="%E6%B3%A8%E5%86%8C%E6%96%B0%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注册新命令</h4>
<p><a href="https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand">vscode.commands.registerCommand</a> 方法在插件中负责将一个命令ID和处理函数绑定到一起：</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  const command = 'myExtension.sayHello';

  const commandHandler = (name: string = 'world') =&gt; {
    console.log(`Hello ${name}!!!`);
  };

  context.subscriptions.push(vscode.commands.registerCommand(command, commandHandler));
}
</code></pre>
<p><code>commandHandler</code>函数将会在<code>myExtension.sayHello</code>命令执行时（如通过<code>executeCommand</code>接口、界面上的操作或通过快捷键）被触发</p>
<h4><a id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%94%A8%E6%88%B7%E5%8F%AF%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建一个用户可用的命令</h4>
<p><a href="https://code.visualstudio.com/api/references/vscode-api#commands.registerCommand">vscode.commands.registerCommand</a> 方法仅能将命令ID和处理函数绑定，如果想让用户在<code>Command Palette</code>里使用这么个命令，还需要在<code>package.json</code>里设置“命令贡献”（command contribution）：</p>
<pre class="line-numbers"><code class="language-json">{
  &quot;contributes&quot;: {
    &quot;commands&quot;: [
      {
        &quot;command&quot;: &quot;myExtension.sayHello&quot;,
        &quot;title&quot;: &quot;Say Hello&quot;
      }
    ]
  }
}
</code></pre>
<p>“命令贡献”（command contribution）会告知<strong>VS Code</strong>当前的插件贡献出了一个命令：</p>
<p><figure><img src="media/16843158016742/16845720923157.jpg" alt="" /></figure></p>
<p>当然，我们还需要执行<code>registerCommand</code>方法将命令ID和处理函数绑定起来，这就意味着如果用户选中了<code>myExtension.sayHello</code>命令，而插件还没有激活（activated），那么注册的处理函数并不会执行，为了此类事情的发生，我们还需要注册<code>onCommand activationEvent</code>：</p>
<pre class="line-numbers"><code class="language-json">{
  &quot;activationEvents&quot;: [&quot;onCommand:myExtension.sayHello&quot;]
}
</code></pre>
<p>现在，当用户运行<code>myExtension.sayHello</code>命令时，插件将会被激活并执行<code>registerCommand</code>方法将命令ID和处理函数绑定在一起。<br />
如果出现以下情况，你必须注册<code>onCommand activationEvent</code>：</p>
<ul>
<li>命令可以从<code>Command Palette</code>被唤醒</li>
<li>命令可以被快捷键被唤醒</li>
<li>命令可以从界面被唤醒，如<code>title bar</code></li>
<li>被其它插件以API形式调用</li>
</ul>
<h4><a id="%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4%E5%9C%A8command-palette%E9%87%8C%E7%9A%84%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>控制命令在Command Palette里的显示</h4>
<p>通常情况下我们在<code>package.json</code>里设置<code>contributes.commands</code>来控制命令在<strong>Command Palette</strong>里的展示，不过有时候我们希望命令只在特定场景下作展示，比如只在特定语言或指定配置下展示命令给用户，这类需求我们可以用<code>contributes.menus.commandPalette</code>来实现，它会控制一个命令何时在<code>Command Palette</code>中显示：</p>
<pre class="line-numbers"><code class="language-json">{
    &quot;contributes&quot;: {
        &quot;commands&quot;: [{
            &quot;command&quot;: &quot;extension.sayHello&quot;,
            &quot;title&quot;: &quot;Hello World&quot;
        }],
        &quot;menus&quot;: {
            &quot;commandPalette&quot;: [{
                &quot;command&quot;: &quot;extension.sayHello&quot;,
                &quot;when&quot;: &quot;editorLangId == markdown&quot;
            }]
        }
    }
}
</code></pre>
<p>现在<code>Hello World</code>命令只会当用户在一个<code>Markdown</code>中时才会在<code>Command Palette</code>中显示出来，关于<code>when</code>的取值，可以参见 <a href="https://code.visualstudio.com/api/references/when-clause-contexts">when clause contexts</a></p>
<h4><a id="%E5%91%BD%E4%BB%A4%E7%9A%84enablement%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>命令的Enablement属性</h4>
<p>命令支持通过<code>contributes.commands.enablement</code>字段控制命令的可用性，它的取值和上文的<code>when</code>属性一致，其实二者的语义上有一定的重叠，<code>when</code>经常用来避免菜单中充满了不可用项，防止菜单的凌乱（在<strong>VS Code</strong>插件开发实践中这是被推荐的，比如我们实现一个分析JavaScript正则表达式的命令，用 when 来控制该命令只在当前是JavaScript文件时才展示，然后用 enablement 来控制只有鼠标悬浮在一个正则表达式上时才启用）</p>
<p>另外，<strong>VS Code</strong>在命令的显示上，<code>when</code>和<code>enablement</code>有所区别，在编辑器或explorer的上下文菜单中会显示<code>enablement/disablement</code>的菜单项，但是在<code>Command Palette</code>中会过滤掉</p>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89when%E3%80%81enablement%E5%8F%96%E5%80%BC%E6%9D%A1%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义when、enablement取值条件</h4>
<p><code>when</code>和<code>enablement</code>字段中的取值条件 <a href="https://code.visualstudio.com/api/references/when-clause-contexts">when clause contexts</a> 是可以通过<code>vscode.commands.executeCommand</code>方法自定义的：</p>
<pre class="line-numbers"><code class="language-js">vscode.commands.executeCommand('setContext', 'ext.supportedFolders', [
  'test',
  'foo',
  'bar'
]);

vscode.commands.executeCommand('setContext', 'jsonOutlineEnabled', false);

// package.json
{
    &quot;menus&quot;: {
        &quot;explorer/context&quot;: [{
            &quot;command&quot;: &quot;ext.doSpecial&quot;,
            &quot;when&quot;: &quot;explorerResourceIsFolder &amp;&amp; resourceFilename in ext:supportedFolders&quot;
        }],
        &quot;commandPalette&quot;: [{
            &quot;command&quot;: &quot;extension.sayHello&quot;,
            &quot;when&quot;: &quot;jsonOutlineEnabled&quot;
        }]
    }
}
</code></pre>
<p>注意，如果执行<code>executeCommand</code>时条件名称是<code>ext.supportedFolders</code>，则在<code>package.json</code>中应该改为<code>ext:supportedFolders</code>的形式</p>
<h2><a id="%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98%E4%B8%80%E8%A7%88color-theme" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>颜色主题一览 Color Theme</h2>
<p>Visual Studio Code用户界面中的颜色分为两类：</p>
<ul>
<li><strong>工作区（Workbench）颜色</strong>：用在视图和编辑器中，包含<code>Activity Bar</code>、<code>Status Bar</code>，完整的颜色清单可以在 <a href="https://code.visualstudio.com/api/references/theme-color">Theme Color</a> 查到</li>
<li><strong>语法颜色</strong>：用于编辑器中的源码高亮，这部分颜色和具体的语法以及语言的token有关</li>
</ul>
<h3><a id="%E5%B7%A5%E4%BD%9C%E5%8F%B0%E9%A2%9C%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作台颜色</h3>
<p>最简单的创建工作台颜色主题的方式是从一个已有的主题出发进行自定义改造，首先在<strong>颜色主题 -&gt; 首选项</strong>里选中一个你喜欢的颜色主题，然后打开<code>settings.json</code>文件，配置<code>workbench.colorCustomizations</code>字段，修改会实时生效。举例而言，下面这段代码将会改变<code>title bar</code>的颜色：</p>
<pre class="line-numbers"><code class="language-plain_text">{
  &quot;workbench.colorCustomizations&quot;: {
    &quot;titleBar.activeBackground&quot;: &quot;#ff0000&quot;
  }
}
</code></pre>
<p>完整的颜色配置项可以在此处查询 <a href="https://code.visualstudio.com/api/references/theme-color">Theme Color</a></p>
<h3><a id="%E8%AF%AD%E6%B3%95%E9%A2%9C%E8%89%B2%EF%BC%88syntax%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语法颜色（Syntax）</h3>
<p>有两种方式生成自己的语法颜色：</p>
<ol>
<li>从社区一个既有的 <code>TextMate</code> 主题（<code>.tmTheme</code>文件）的基础上进行修改，这是最简单的方式，类似上文中的工作台颜色主题的方式</li>
<li>从零开始，自己创建语法主题</li>
</ol>
<p>从已有的主题创建的话，首先切换到想要修改的颜色主题上，然后编辑<code>settings.json</code>文件，修改<code>editor.tokenColorCustomizations</code>字段，例如下段代码将会修改注释的颜色：</p>
<pre class="line-numbers"><code class="language-plain_text">{
  &quot;editor.tokenColorCustomizations&quot;: {
    &quot;comments&quot;: &quot;#FF0000&quot;
  }
}
</code></pre>
<p>更多信息可见 <a href="https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide">Syntax Highlight Guide</a></p>
<h3><a id="%E8%AF%AD%E4%B9%89%E9%A2%9C%E8%89%B2%EF%BC%88semantic%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语义颜色（Semantic）</h3>
<p>语义颜色是自<strong>VS Code 1.43</strong>发布的一个新功能，是根据<code>language service</code>提供的符号信息对语法颜色的增强。目前仅支持<code>TypeScript</code>、<code>JavaScript</code>，之后会增加对其它语言的支持。颜色的渲染是从<code>language service</code>启动、计算完毕语义符号开始的。</p>
<p>用户可以用<code>editor.tokenColorCustomizations</code>字段覆盖制定主题的语义高亮：</p>
<pre class="line-numbers"><code class="language-plain_text">&quot;editor.tokenColorCustomizations&quot;: {
    &quot;[Material Theme]&quot;: {
        &quot;semanticHighlighting&quot;: true
    }
}
</code></pre>
<p>更多的信息参见 <a href="https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide#semantic-theming">Syntax Highlight Guide</a></p>
<h3><a id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建一个颜色主题</h3>
<ol>
<li>通过<code>Command Palette</code>执行<code>Developer: Generate Color Theme from Current Settings</code>命令，以现有的主题为基础创建主题文件</li>
<li>用<code>generator-code</code>创建一个主题拓展</li>
</ol>
<pre class="line-numbers"><code class="language-plain_text">npm install -g yo generator-code
yo code
</code></pre>
<ol start="3">
<li>选择<code>Start fresh</code></li>
<li>拷贝主题文件到生成的插件项目里</li>
</ol>
<p>你可以在使用<code>generator-code</code>的时候导入一个已经存在的 <code>TextMate</code> 主题（<code>.tmTheme</code>文件），或者你可以下载一个主题文件，然后将<code>tokenColors</code>替换为文件（<code>.tmTheme</code>）路径：</p>
<pre class="line-numbers"><code class="language-plain_text">{
  &quot;type&quot;: &quot;dark&quot;,
  &quot;colors&quot;: {
    &quot;editor.background&quot;: &quot;#1e1e1e&quot;,
    &quot;editor.foreground&quot;: &quot;#d4d4d4&quot;,
    &quot;editorIndentGuide.background&quot;: &quot;#404040&quot;,
    &quot;editorRuler.foreground&quot;: &quot;#333333&quot;,
    &quot;activityBarBadge.background&quot;: &quot;#007acc&quot;,
    &quot;sideBarTitle.foreground&quot;: &quot;#bbbbbb&quot;
  },
  &quot;tokenColors&quot;: &quot;./Diner.tmTheme&quot;
}
</code></pre>
<blockquote>
<p>在编写主题时，将文件后缀写为 <code>-color-theme.json</code> 将会获得代码补全以及自动提示的功能。此外，在 <a href="https://colorsublime.github.io/">ColorSublime</a> 可以查阅到大量的 <code>TextMate</code> 主题，你可以将其下载链接（格式类似&quot;<code>https://raw.githubusercontent.com/Colorsublime/Colorsublime-Themes/master/themes/(name).tmTheme</code>&quot;）直接用在<code>generator-code</code>中或者拓展里</p>
</blockquote>
<h3><a id="%E6%B5%8B%E8%AF%95%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测试颜色主题</h3>
<p>按<code>F5键</code>启动调试模式，然后从 <code>File &gt; Preferences &gt; Color Theme</code> 选中自己创建的主题查看效果，调试状态下对主题文件的修改会实时生效</p>
<h3><a id="%E5%8F%91%E5%B8%83%E9%A2%9C%E8%89%B2%E4%B8%BB%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发布颜色主题</h3>
<p>你可以通过 <a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension">vsce publishing tool</a> 将主题发布到 <a href="https://marketplace.visualstudio.com/VSCode">插件集市</a> ，以便和大家分享你的主题，同时 <a href="https://code.visualstudio.com/api/references/extension-manifest#marketplace-presentation-tips">Marketplace Presentation Tips</a> 会对你发布到插件集市优化上有所帮助</p>
<blockquote>
<p>将<code>package.json</code>里的<code>Category</code>字段名称设置为<code>Themes</code>可以让用户更容易找到你的主题</p>
</blockquote>
<h3><a id="%E5%88%9B%E5%BB%BA%E9%A2%9C%E8%89%B2id" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建颜色ID</h3>
<p>你可以通过 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.colors">color contribution point</a> 来创建自己的颜色ID，这样颜色就可以用在<code>color contribution point</code>和颜色主题文件里的代码自动补全，用户可以在<code>Contributions tab</code>下看到该插件定义的颜色</p>
<h2><a id="%E6%A0%91%E8%A7%86%E5%9B%BEtree-view" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>树视图 Tree View</h2>
<p><code>Tree View API</code>允许插件在<code>sidebar</code>中渲染内容，这些内容以树的形状来展示</p>
<h3><a id="tree-view-api%E5%9F%BA%E7%A1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tree View API基础</h3>
<p>我们通过一个示例来介绍<code>Tree View API</code>相关用法，这个示例利用树视图来展示当前文件夹中所有的Node.js依赖。你可以在 <a href="https://github.com/microsoft/vscode-extension-samples/tree/main/tree-view-sample">tree-view-sample</a> 查阅此示例的完整代码</p>
<h4><a id="%E9%85%8D%E7%BD%AEpackage-json" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置package.json</h4>
<p>首先你要通过 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.views">contributes.views</a> 让<strong>VS Code</strong>知道你要“贡献出”一个视图，下面是<code>package.json</code>的一个初步配置：</p>
<pre class="line-numbers"><code class="language-json">{
    &quot;name&quot;: &quot;helloworld&quot;,
    &quot;displayName&quot;: &quot;HelloWorld&quot;,
    &quot;description&quot;: &quot;&quot;,
    &quot;version&quot;: &quot;0.0.1&quot;,
    &quot;engines&quot;: {
        &quot;vscode&quot;: &quot;^1.56.0&quot;
    },
    &quot;categories&quot;: [
        &quot;Other&quot;
    ],
    &quot;activationEvents&quot;: [&quot;onView:nodeDependencies&quot;],
    &quot;main&quot;: &quot;./extension.js&quot;,
    &quot;contributes&quot;: {
        &quot;views&quot;: {
            &quot;explorer&quot;: [{
                &quot;id&quot;: &quot;nodeDependencies&quot;,
                &quot;name&quot;: &quot;Node Dependencies&quot;
            }]
        }
    },
    &quot;scripts&quot;: {
        &quot;lint&quot;: &quot;eslint .&quot;,
        &quot;pretest&quot;: &quot;npm run lint&quot;,
        &quot;test&quot;: &quot;node ./test/runTest.js&quot;
    },
    &quot;devDependencies&quot;: {
        &quot;@types/vscode&quot;: &quot;^1.56.0&quot;,
        &quot;@types/glob&quot;: &quot;^7.1.3&quot;,
        &quot;@types/mocha&quot;: &quot;^8.0.4&quot;,
        &quot;@types/node&quot;: &quot;14.x&quot;,
        &quot;eslint&quot;: &quot;^7.19.0&quot;,
        &quot;glob&quot;: &quot;^7.1.6&quot;,
        &quot;mocha&quot;: &quot;^8.2.1&quot;,
        &quot;typescript&quot;: &quot;^4.1.3&quot;,
        &quot;vscode-test&quot;: &quot;^1.5.0&quot;
    }
}
</code></pre>
<p>仅当用户需要时再去激活插件是十分重要的，例如在本文的示例中，我们可以让插件在用户使用插件视图的时候再去激活。<strong>VS Code</strong>提供了 <a href="https://code.visualstudio.com/api/references/activation-events#onView">onView:${viewId}</a> 事件来告知程序当前用户打开的视图，我们可以在<code>package.json</code>注册一个激活事件<code>&quot;activationEvents&quot;: [&quot;onView:nodeDependencies&quot;]</code></p>
<h4><a id="%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成数据</h4>
<p>第二步是利用 <a href="https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider">TreeDataProvider</a> 生成树视图所需的<code>Node.js</code>依赖的数据，其中需要实现两个方法：</p>
<ul>
<li><code>getChildren(element?: T): ProviderResult&lt;T[]&gt;</code>：返回指定节点（如果没有指定就是根节点）的子节点</li>
<li><code>getTreeItem(element: T): TreeItem | Thenable&lt;TreeItem&gt;</code>：返回用于在视图里展示的UI节点</li>
</ul>
<p>每当用户打开树视图，<code>getChildren</code>会被自动调用（没有参数），你可以在这里返回树视图的第一层级内容。在示例中，我们用<code>TreeItemCollapsibleState.Collapsed</code>（折叠）、<code>TreeItemCollapsibleState.Expanded</code>（展开）、<code>TreeItemCollapsibleState.None</code>（无子节点，不会触发<code>getChildren</code>方法）控制节点的折叠状态，下面是一个<code>TreeDataProvider</code>的实现示例：</p>
<pre class="line-numbers"><code class="language-ts">import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

export class NodeDependenciesProvider implements vscode.TreeDataProvider&lt;Dependency&gt; {
    constructor(private workspaceRoot: string) { }

    getTreeItem(element: Dependency): vscode.TreeItem {
        return element;
    }

    getChildren(element?: Dependency): Thenable&lt;Dependency[]&gt; {
        if (!this.workspaceRoot) {
            vscode.window.showInformationMessage('No dependency in empty workspace');
            return Promise.resolve([]);
        }

        if (element) {
            return Promise.resolve(
                this.getDepsInPackageJson(
                    path.join(this.workspaceRoot, 'node_modules', element.label, 'package.json')
                )
            );
        } else {
            const packageJsonPath = path.join(this.workspaceRoot, 'package.json');
            if (this.pathExists(packageJsonPath)) {
                return Promise.resolve(this.getDepsInPackageJson(packageJsonPath));
            } else {
                vscode.window.showInformationMessage('Workspace has no package.json');
                return Promise.resolve([]);
            }
        }
    }

    /**
     * Given the path to package.json, read all its dependencies
     */
    private getDepsInPackageJson(packageJsonPath: string): Dependency[] {
        if (this.pathExists(packageJsonPath)) {
            const toDep = (moduleName: string, version: string): Dependency =&gt; {
                const depPackageJsonPath = path.join(this.workspaceRoot, 'node_modules', moduleName, 'package.json');
                let collapsibleState = vscode.TreeItemCollapsibleState.Collapsed;
                if (this.pathExists(depPackageJsonPath)) {
                    const depPackageJson = JSON.parse(fs.readFileSync(depPackageJsonPath, 'utf-8'));
                    // 如果依赖的代码包已经安装（node_modules有内容），且这个安装包本身有dependencies或devDependencies，才设置为可展开的
                    if ((!depPackageJson.dependencies || Object.keys(depPackageJson.dependencies).length === 0) &amp;&amp;
                        (!depPackageJson.devDependencies || Object.keys(depPackageJson.devDependencies).length === 0)) {
                        collapsibleState = vscode.TreeItemCollapsibleState.None;
                    }
                }
                return new Dependency(moduleName, version, collapsibleState);
            };
            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
            const deps = packageJson.dependencies
                ? Object.keys(packageJson.dependencies).map(dep =&gt;
                    toDep(dep, packageJson.dependencies[dep])
                )
                : [];
            const devDeps = packageJson.devDependencies
                ? Object.keys(packageJson.devDependencies).map(dep =&gt;
                    toDep(dep, packageJson.devDependencies[dep])
                )
                : [];
            return deps.concat(devDeps);
        } else {
            return [];
        }
    }

    private pathExists(p: string): boolean {
        try {
            fs.accessSync(p);
        } catch (err) {
            return false;
        }
        return true;
    }
}

class Dependency extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        private version: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState
    ) {
        super(label, collapsibleState);
        this.tooltip = `${this.label}-${this.version}`;
        this.description = this.version;
    }

    iconPath = {
        light: path.join(__filename, '..', '..', 'resources', 'light', 'dependency.svg'),
        dark: path.join(__filename, '..', '..', 'resources', 'dark', 'dependency.svg')
    };
}
</code></pre>
<h4><a id="%E6%B3%A8%E5%86%8Ctreedataprovider" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注册TreeDataProvider</h4>
<p>第三步是将生成的依赖数据提供给视图，可以通过两种方式实现：</p>
<ul>
<li><code>vscode.window.registerTreeDataProvider</code>：注册树数据的<code>provider</code>，需要提供<strong>视图ID</strong>和<strong>数据provider对象</strong></li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">vscode.window.registerTreeDataProvider(
    'nodeDependencies',
    new NodeDependenciesProvider(vscode.workspace.rootPath)
);
</code></pre>
<ul>
<li><code>vscode.window.createTreeView</code>：通过视图ID和数据provider来创建视树视图，这会提供访问 <a href="https://code.visualstudio.com/api/references/vscode-api#TreeView">树视图</a> 的能力，如果你需要使用<code>TreeView API</code>，可以使用<code>createTreeView</code>的方式</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">vscode.window.createTreeView('nodeDependencies', {
    treeDataProvider: new NodeDependenciesProvider(vscode.workspace.rootPath)
});
</code></pre>
<p>至此一个具备基本目标功能的插件就已经完成，可以看到实际效果如下：</p>
<p><figure><img src="media/16843158016742/16845903960247.jpg" alt="" /></figure></p>
<p>上述代码的完整示例参见 <a href="https://github.com/king-king/vscode-extension/tree/tree-view-v1-update1/packages/tree-view-test">tree-view-test v1</a></p>
<h4><a id="%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更新视图内容</h4>
<h5><a id="%E4%BB%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以命令行方式</h5>
<p>目前完成的这个插件仅具备最基本的功能，数依赖数据一经展示便无法更新。如果在视图中有一个刷新按钮将会是非常方便的，为了实现这个目标，我们需要利用 <a href="https://code.visualstudio.com/api/references/vscode-api#TreeDataProvider">onDidChangeTreeData</a> 事件：</p>
<ul>
<li><code>onDidChangeTreeData?: Event&lt;T | undefined | null | void&gt;</code>：当依赖数据变更并且你希望更新树视图的时候执行</li>
</ul>
<p>在<code>provider</code>中添加如下代码：</p>
<pre class="line-numbers"><code class="language-plain_text">    private _onDidChangeTreeData: vscode.EventEmitter&lt;Dependency | undefined | null | void&gt; = new vscode.EventEmitter&lt;Dependency | undefined | null | void&gt;();
    readonly onDidChangeTreeData: vscode.Event&lt;Dependency | undefined | null | void&gt; = this._onDidChangeTreeData.event;
    refresh(): void {
        this._onDidChangeTreeData.fire();
    }
</code></pre>
<p>此时我们有了更新函数，但没有调用它，我们可以在<code>package.json</code>中定义一条更新命令：</p>
<pre class="line-numbers"><code class="language-json">    &quot;commands&quot;: [
            {
                &quot;command&quot;: &quot;nodeDependencies.refreshEntry&quot;,
                &quot;title&quot;: &quot;Refresh Dependence&quot;,
                &quot;icon&quot;: {
                    &quot;light&quot;: &quot;resources/light/refresh.svg&quot;,
                    &quot;dark&quot;: &quot;resources/dark/refresh.svg&quot;
                }
            }
    ]
</code></pre>
<p>然后注册该命令：</p>
<pre class="line-numbers"><code class="language-plain_text">  vscode.commands.registerCommand('nodeDependencies.refreshEntry', () =&gt;
      nodeDependenciesProvider.refresh()
  );
</code></pre>
<p>此时我们会看到，当执行了<code>Refresh Dependence</code>命令后，<code>Node.js</code>依赖的树视图会被更新：</p>
<p><figure><img src="media/16843158016742/e325d3c95f54426ab0047b0a0550d42e_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0%20-1-.gif" alt="e325d3c95f54426ab0047b0a0550d42e_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0 -1-" /><figcaption>e325d3c95f54426ab0047b0a0550d42e_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0 -1-<figcaption></figure></p>
<h5><a id="%E4%BB%A5%E6%8C%89%E9%92%AE%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以按钮方式</h5>
<p>在前文的基础上，如果在视图中添加一个按钮或许操作的时候有会更加直观、友好。我们在<code>package.json</code>中添加：</p>
<pre class="line-numbers"><code class="language-plain_text">&quot;menus&quot;: {
    &quot;view/title&quot;: [
        {
            &quot;command&quot;: &quot;nodeDependencies.refreshEntry&quot;,
            &quot;when&quot;: &quot;view == nodeDependencies&quot;,
            &quot;group&quot;: &quot;navigation&quot;
        },
    ]
}
</code></pre>
<p>此时当我们将鼠标浮在视图上时就会看到刷新按钮，点击效果同执行<code>Refresh Dependence</code>命令：</p>
<p><figure><img src="media/16843158016742/16845924028809.jpg" alt="" /></figure></p>
<p><code>group</code>属性用于菜单项的排序和分类，其中值为<code>navigation</code>的<code>group</code>是用来将置顶的，如果不设置，则刷新按钮将会被隐藏在“...”里，效果如下所示：</p>
<p><figure><img src="media/16843158016742/16845924685839.jpg" alt="" /></figure></p>
<p>上述代码的完整示例参见 <a href="https://github.com/king-king/vscode-extension/tree/tree-view-v2/packages/tree-view-test">tree-view-test v2</a></p>
<h3><a id="%E6%B7%BB%E5%8A%A0%E5%88%B0%E8%A7%86%E5%9B%BE%E5%AE%B9%E5%99%A8%EF%BC%88view-container%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加到视图容器（View Container）</h3>
<h4><a id="%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE%E5%AE%B9%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建视图容器</h4>
<p>视图容器包含了一系列展示在<code>Activity Bar</code>或<code>Panel</code>中的视图，如果希望自己的插件自定义一个视图容器，我们可以用 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.viewsContainers">contributes.viewsContainers</a> 在<code>package.json</code>中注册：</p>
<pre class="line-numbers"><code class="language-json">    &quot;contributes&quot;: {
        &quot;viewsContainers&quot;: {
            &quot;activitybar&quot;: [{
                &quot;id&quot;: &quot;package-explorer&quot;,
                &quot;title&quot;: &quot;Package Explorer&quot;,
                &quot;icon&quot;: &quot;media/dep.svg&quot;
            }]
        }
    }
</code></pre>
<p>或者你也可以在<code>panel</code>字段下做配置</p>
<pre class="line-numbers"><code class="language-plain_text">    &quot;contributes&quot;: {
        &quot;viewsContainers&quot;: {
           &quot;panel&quot;: [{
                &quot;id&quot;: &quot;package-explorer&quot;,
                &quot;title&quot;: &quot;Package Explorer&quot;,
                &quot;icon&quot;: &quot;media/dep.svg&quot;
            }]
        }
    }
</code></pre>
<h4><a id="%E5%B0%86%E8%A7%86%E5%9B%BE%E5%92%8C%E8%A7%86%E5%9B%BE%E5%AE%B9%E5%99%A8%E7%BB%91%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将视图和视图容器绑定</h4>
<p>我们可以在<code>package.json</code>中用 <a href="https://code.visualstudio.com/api/references/contribution-points#contributes.views">contributes.views</a> 来实现</p>
<pre class="line-numbers"><code class="language-plain_text">    &quot;contributes&quot;: {
        &quot;views&quot;: {
            &quot;package-explorer&quot;: [{
                &quot;id&quot;: &quot;nodeDependencies&quot;,
                &quot;name&quot;: &quot;Node Dependencies&quot;,
                &quot;icon&quot;: &quot;media/dep.svg&quot;,
                &quot;contextualTitle&quot;: &quot;Package Explorer&quot;
            }]
        }
    }
</code></pre>
<p>需要注意的是，一个视图可以设置<code>visibility</code>属性，该属性有三个取值：<code>visible</code>、<code>collapsed</code>、<code>hidden</code>，这三个值仅在首次打开工作台的时候起作用，之后其取值取决于用户的控制。如果你的视图容器里有很多的视图，则可以利用该属性让你的界面更加简洁</p>
<p><figure><img src="media/16843158016742/16845932532499.jpg" alt="" /></figure></p>
<p>现在我们可以看到左侧的视图容器和树视图了：</p>
<p><figure><img src="media/16843158016742/16845932765958.jpg" alt="" /></figure></p>
<p>上述代码的完整示例参见 <a href="https://github.com/king-king/vscode-extension/tree/tree-view-v3/packages/tree-view-test">tree-view-test v3</a></p>
<h3><a id="%E8%A7%86%E5%9B%BE%E8%A1%8C%E4%B8%BA%E8%A7%A3%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>视图行为解读</h3>
<p>视图的行为附着在视图的内联图标上，这些图标可以在树视图中的每一个节点上、还可以在树视图顶端的标题栏上，我们可以在<code>package.json</code>中对其进行配置：</p>
<ul>
<li><code>view/title</code>：位置在视图标题栏上，可以用<code>&quot;group&quot;: &quot;navigation&quot;</code>来保证其优先级</li>
<li><code>view/item/context</code>：位置在树节点上，可以用<code>&quot;group&quot;: &quot;inline&quot;</code>让其内联显示</li>
</ul>
<blockquote>
<p>上述均可用 <a href="https://code.visualstudio.com/api/references/when-clause-contexts">when clause</a> 控制其生效条件</p>
</blockquote>
<p><figure><img src="media/16843158016742/16845973985051.jpg" alt="" /></figure></p>
<p>如果我们想实现上图的效果，可以用如下代码实现：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    &quot;contributes&quot;: {
        &quot;commands&quot;: [{
                &quot;command&quot;: &quot;nodeDependencies.refreshEntry&quot;,
                &quot;title&quot;: &quot;Refresh&quot;,
                &quot;icon&quot;: {
                    &quot;light&quot;: &quot;resources/light/refresh.svg&quot;,
                    &quot;dark&quot;: &quot;resources/dark/refresh.svg&quot;
                }
            },
            {
                &quot;command&quot;: &quot;nodeDependencies.addEntry&quot;,
                &quot;title&quot;: &quot;Add&quot;
            },
            {
                &quot;command&quot;: &quot;nodeDependencies.editEntry&quot;,
                &quot;title&quot;: &quot;Edit&quot;,
                &quot;icon&quot;: {
                    &quot;light&quot;: &quot;resources/light/edit.svg&quot;,
                    &quot;dark&quot;: &quot;resources/dark/edit.svg&quot;
                }
            },
            {
                &quot;command&quot;: &quot;nodeDependencies.deleteEntry&quot;,
                &quot;title&quot;: &quot;Delete&quot;
            }
        ],
        &quot;menus&quot;: {
            &quot;view/title&quot;: [{
                    &quot;command&quot;: &quot;nodeDependencies.refreshEntry&quot;,
                    &quot;when&quot;: &quot;view == nodeDependencies&quot;,
                    &quot;group&quot;: &quot;navigation&quot;
                },
                {
                    &quot;command&quot;: &quot;nodeDependencies.addEntry&quot;,
                    &quot;when&quot;: &quot;view == nodeDependencies&quot;
                }
            ],
            &quot;view/item/context&quot;: [{
                    &quot;command&quot;: &quot;nodeDependencies.editEntry&quot;,
                    &quot;when&quot;: &quot;view == nodeDependencies &amp;&amp; viewItem == dependency&quot;,
                    &quot;group&quot;: &quot;inline&quot;
                },
                {
                    &quot;command&quot;: &quot;nodeDependencies.deleteEntry&quot;,
                    &quot;when&quot;: &quot;view == nodeDependencies &amp;&amp; viewItem == dependency&quot;
                }
            ]
        }
    }
}
</code></pre>
<blockquote>
<p>我们可以在<code>when</code>字段中使用 <a href="https://code.visualstudio.com/api/references/vscode-api#TreeItem">TreeItem.contextValue</a> 的数据，来控制相应行为的显示</p>
</blockquote>
<p>上述代码的完整示例参见 <a href="https://github.com/king-king/vscode-extension/tree/tree-view-v4/packages/tree-view-test">tree-view-test v4</a></p>
<h3><a id="%E8%A7%86%E5%9B%BE%E6%AC%A2%E8%BF%8E%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>视图欢迎内容</h3>
<p>我们可以添加一个欢迎内容，以便当视图内容初始化或为空的时候显示：</p>
<pre class="line-numbers"><code class="language-plain_text">    &quot;contributes&quot;: {
        &quot;viewsWelcome&quot;: [{
            &quot;view&quot;: &quot;nodeDependencies&quot;,
            &quot;contents&quot;: &quot;没有发现依赖内容， [了解更多](https://www.npmjs.com/).\n[添加依赖](command:nodeDependencies.addEntry)&quot;
        }]
</code></pre>
<p><code>contributes.viewsWelcome.contents</code>支持链接，如果链接单起一行，会被渲染为按钮。每个<code>viewsWelcome</code>支持 <a href="https://code.visualstudio.com/api/references/when-clause-contexts">when clause</a></p>
<p><figure><img src="media/16843158016742/pic2.gif" alt="pic2" /><figcaption>pic2<figcaption></figure></p>
<p>上述代码的完整示例参见 <a href="https://github.com/king-king/vscode-extension/tree/tree-view-v5/packages/tree-view-test">tree-view-test v5</a></p>
<h2><a id="webview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Webview</h2>
<p><code>webview API</code>允许插件在 <strong>Visual Studio Code</strong>中创建高度定制化的视图，例如内置的<code>Markdown</code>插件就是利用<code>webview</code>来渲染<code>Markdown</code>预览页的。<code>webview</code>还可以创建出比<code>VS Code</code>原生API所直接支持的更加复杂的用户界面。</p>
<p>可以将<code>webview</code>视为<code>VS Code</code>下插件所控制的<code>iframe</code>，<code>webview</code>可以渲染出任意的<code>HTML</code>内容并通过信息（<code>message</code>）机制和插件通信，这种高度自由使得<code>webview</code>的能力十分强大，令其开启了插件可能性的新领域</p>
<p><code>webview</code>在以下一些场景中被使用：</p>
<ul>
<li>用<code>createWebviewPanel</code>创建一个<code>webview</code>面板，在<strong>VS Code</strong>中地位如同一个单独的编辑界面，这在展示自定义UI和自定义的可视化方面非常有用</li>
<li>作为 <a href="https://code.visualstudio.com/api/extension-guides/custom-editors">custom editor</a> 的一个视图存在， <a href="https://code.visualstudio.com/api/extension-guides/custom-editors">custom editor</a> 允许插件提供一个自定义UI去编辑工作区中的任何的文件，<code>custom editor API</code>提供了一系列编辑事件，如撤销、保存等</li>
<li>在<code>sidebar</code>或<code>panel</code>中渲染，查看 <a href="https://github.com/microsoft/vscode-extension-samples/tree/main/webview-view-sample">webview view sample</a> 获取更多信息</li>
</ul>
<h3><a id="api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API</h3>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.createWebviewPanel">window.createWebviewPanel</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerWebviewPanelSerializer">window.registerWebviewPanelSerializer</a></li>
</ul>
<h3><a id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用场景</h3>
<p><code>webview</code>功能十分强大，不过我们不应滥用，只有当<strong>VS Code</strong>原生API无法支持时才建议使用<code>webview</code>。<code>webview</code>涉及到的资源较多，和普通插件相比其运行在一个单独的环境里，这就使得一个设计不好的<code>webview</code>会感到和<strong>VS Code</strong>有些不相称。在使用<code>webview</code>前，请仔细考虑下面这些问题：</p>
<ul>
<li>该功能真的适合放在<strong>VS Code</strong>中而不是一个单独的app或网站么？</li>
<li><code>webview</code>是唯一实现的途径么？<strong>VS Code API</strong>能否直接支持？</li>
<li>是否评估过<code>webview</code>中的资源成本？</li>
</ul>
<h3><a id="%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用方法</h3>
<h4><a id="%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础示例</h4>
<p>为了说明<code>Webviews API</code>的用法，我们会创建一个简单的插件，这个插件将会利用一个<code>webview</code>来展示一幅图片。</p>
<p>下面是这个插件第一个版本的<code>package.json</code>，可以看到其定义了一个命令<code>catCoding.start</code>，当用户触发了这个命令，我们将会展示有猫咪图片的<code>webview</code></p>
<pre class="line-numbers"><code class="language-json">{
    &quot;name&quot;: &quot;webview-test&quot;,
    &quot;displayName&quot;: &quot;webviewTest&quot;,
    &quot;description&quot;: &quot;&quot;,
    &quot;version&quot;: &quot;0.0.1&quot;,
    &quot;engines&quot;: {
        &quot;vscode&quot;: &quot;^1.56.0&quot;
    },
    &quot;categories&quot;: [
        &quot;Other&quot;
    ],
    &quot;activationEvents&quot;: [&quot;onCommand:catCoding.start&quot;],
    &quot;main&quot;: &quot;./dist/extension.js&quot;,
    &quot;contributes&quot;: {
        &quot;commands&quot;: [{
            &quot;command&quot;: &quot;catCoding.start&quot;,
            &quot;title&quot;: &quot;Start new cat coding session&quot;,
            &quot;category&quot;: &quot;Cat Coding&quot;
        }]
    },
    &quot;scripts&quot;: {
        &quot;vscode:prepublish&quot;: &quot;yarn run package&quot;,
        &quot;compile&quot;: &quot;webpack&quot;,
        &quot;watch&quot;: &quot;webpack --watch&quot;,
        &quot;package&quot;: &quot;webpack --mode production --devtool hidden-source-map&quot;,
        &quot;test-compile&quot;: &quot;tsc -p ./&quot;,
        &quot;test-watch&quot;: &quot;tsc -watch -p ./&quot;,
        &quot;pretest&quot;: &quot;yarn run test-compile &amp;&amp; yarn run lint&quot;,
        &quot;lint&quot;: &quot;eslint src --ext ts&quot;,
        &quot;test&quot;: &quot;node ./out/test/runTest.js&quot;
    },
    &quot;devDependencies&quot;: {
        &quot;@types/vscode&quot;: &quot;^1.56.0&quot;,
        &quot;@types/glob&quot;: &quot;^7.1.3&quot;,
        &quot;@types/mocha&quot;: &quot;^8.0.4&quot;,
        &quot;@types/node&quot;: &quot;14.x&quot;,
        &quot;eslint&quot;: &quot;^7.19.0&quot;,
        &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^4.14.1&quot;,
        &quot;@typescript-eslint/parser&quot;: &quot;^4.14.1&quot;,
        &quot;glob&quot;: &quot;^7.1.6&quot;,
        &quot;mocha&quot;: &quot;^8.2.1&quot;,
        &quot;typescript&quot;: &quot;^4.1.3&quot;,
        &quot;vscode-test&quot;: &quot;^1.5.0&quot;,
        &quot;ts-loader&quot;: &quot;^8.0.14&quot;,
        &quot;webpack&quot;: &quot;^5.19.0&quot;,
        &quot;webpack-cli&quot;: &quot;^4.4.0&quot;
    }
}
</code></pre>
<p>接下来让我们注册<code>catCoding.start</code>命令去打开<code>webview</code>：</p>
<pre class="line-numbers"><code class="language-ts">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            // Create and show a new webview
            const panel = vscode.window.createWebviewPanel(
                'catCoding', // Identifies the type of the webview. Used internally
                'Cat Coding', // Title of the panel displayed to the user
                vscode.ViewColumn.One, // Editor column to show the new webview panel in.
                {} // Webview options. More on these later.
            );
        })
    );
}
</code></pre>
<p><code>vscode.window.createWebviewPanel</code>函数打开了一个<code>webview</code>，当我们执行完<code>catCoding.start</code>命令后，将会打开一个空白的<code>webview</code>：</p>
<p><figure><img src="media/16843158016742/16847199731319.jpg" alt="" /></figure></p>
<p>我们可以看到这个空白的<code>webview</code>已经有了正确的标题，为了渲染出想要的内容，我们还需要利用<code>webview.html</code>来指定内容的<code>html</code>：</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            // Create and show a new webview
            const panel = vscode.window.createWebviewPanel(
                'catCoding', // Identifies the type of the webview. Used internally
                'Cat Coding', // Title of the panel displayed to the user
                vscode.ViewColumn.One, // Editor column to show the new webview panel in.
                {} // Webview options. More on these later.
            );
            // And set its HTML content
+            panel.webview.html = getWebviewContent();
        })
    );
}

+ function getWebviewContent() {
+     return `&lt;!DOCTYPE html&gt;
+ &lt;html lang=&quot;en&quot;&gt;
+ &lt;head&gt;
+     &lt;meta charset=&quot;UTF-8&quot;&gt;
+     &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
+     &lt;title&gt;Cat Coding&lt;/title&gt;
+ &lt;/head&gt;
+ &lt;body&gt;
+     &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
+ &lt;/body&gt;
+ &lt;/html&gt;`;
+ }
</code></pre>
<p><code>webview.html</code>必须是完整的html文档，如果是html片段可能会引发意料之外的问题</p>
<h4><a id="%E5%88%B7%E6%96%B0%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>刷新内容</h4>
<p><code>webview.html</code>可以在创建完毕后进行更新，接下来让我们改进一下代码，增加动态切换图片的能力：</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

+const cats = {
+  'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
+  'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
+};

export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('catCoding.start', () =&gt; {
      const panel = vscode.window.createWebviewPanel(
        'catCoding',
        'Cat Coding',
        vscode.ViewColumn.One,
        {}
      );

+      let iteration = 0;
+      const updateWebview = () =&gt; {
+        const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
+        panel.title = cat;
+        panel.webview.html = getWebviewContent(cat);
+      };

      // Set initial content
      updateWebview();

+      // And schedule updates to the content every second
+      setInterval(updateWebview, 1000);
    })
  );
}

function getWebviewContent(cat: keyof typeof cats) {
  return `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
+    &lt;img src=&quot;${cats[cat]}&quot; width=&quot;300&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p><figure><img src="media/16843158016742/pic3%20-1-.gif" alt="pic3 -1-" /><figcaption>pic3 -1-<figcaption></figure></p>
<p>设置<code>webview.html</code>会替换掉整个webview的内容，类似重新加载<code>iframe</code>，如果你在<code>webview</code>中使用了<code>js</code>脚本这点就很重要，需要注意设置了<code>webview.html</code>会导致脚本的状态被重置。需要留意上文的示例还使用了<code>webview.title</code>来改变标题，重置标题不会导致webview的重新加载</p>
<h4><a id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生命周期</h4>
<p><strong>webview面板</strong>属于创建它的插件，通过获取<code>createWebviewPanel</code>的返回对象来操控<code>webview</code>。对于用户来说，可以随时关闭<strong>webview面板</strong>，一旦被关闭，则<code>webview</code>将会被销毁，尝试去引用一个被销毁的<code>webview</code>会报错，所以对于上述代码来说，<code>setInterval</code>的使用存在bug。当用户关闭了<strong>webview面板</strong>后<code>setInterval</code>依然会被不断地触发，下面让我们来看下如何处理这个问题。</p>
<p>当<strong>webview面板</strong>被销毁时会触发<code>onDidDispose</code>事件，我们可以在此来取消<code>setInterval</code>：</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

const cats = {
    'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
    'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif'
};

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            // Create and show a new webview
            const panel = vscode.window.createWebviewPanel(
                'catCoding', // Identifies the type of the webview. Used internally
                'Cat Coding', // Title of the panel displayed to the user
                vscode.ViewColumn.One, // Editor column to show the new webview panel in.
                {} // Webview options. More on these later.
            );
            let iteration = 0;
            const updateWebview = () =&gt; {
                const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
                panel.title = cat;
                panel.webview.html = getWebviewContent(cat);
            };

            // Set initial content
            updateWebview();

            // And schedule updates to the content every second
+            const interval = setInterval(updateWebview, 1000);

+            panel.onDidDispose(
+                () =&gt; {
+                    // When the panel is closed, cancel any future updates to the webview content
+                    clearInterval(interval);
+                },
+                null,
+                context.subscriptions
+            );
        })
    );
}

function getWebviewContent(cat: keyof typeof cats) {
    return `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;${cats[cat]}&quot; width=&quot;300&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p>对于插件来说，也可以通过调用<code>dispose</code>关闭<strong>webview面板</strong>，例如我们可以控制在五秒之后关闭<strong>webview面板</strong>：</p>
<pre class="line-numbers"><code class="language-js">export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            // Create and show a new webview
            const panel = vscode.window.createWebviewPanel(
                'catCoding', // Identifies the type of the webview. Used internally
                'Cat Coding', // Title of the panel displayed to the user
                vscode.ViewColumn.One, // Editor column to show the new webview panel in.
                {} // Webview options. More on these later.
            );
            let iteration = 0;
            const updateWebview = () =&gt; {
                const cat = iteration++ % 2 ? 'Compiling Cat' : 'Coding Cat';
                panel.title = cat;
                panel.webview.html = getWebviewContent(cat);
            };

            // Set initial content
            updateWebview();

            // And schedule updates to the content every second
            const interval = setInterval(updateWebview, 1000);
            // After 5sec, programmatically close the webview panel
+           const timeout = setTimeout(() =&gt; {
+               clearInterval(interval);
+               panel.dispose();
+           }, 5000);


            panel.onDidDispose(
                () =&gt; {
                    // When the panel is closed, cancel any future updates to the webview content
                    clearInterval(interval);
+                   clearTimeout(timeout);
                },
                null,
                context.subscriptions
            );
        })
    );
}
</code></pre>
<p>可以看到依次发生了：执行<code>panel.dispose</code>-&gt;触发<code>panel.onDidDispose</code>-&gt;<strong>webview面板</strong>关闭</p>
<h4><a id="%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E7%A7%BB%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可见性与移动</h4>
<p>当我们在编辑区切换<code>tab</code>，将<strong>webview面板</strong>置于不可见的状态时，<strong>webview面板</strong>实际上没有被销毁<strong>VS Code</strong>会将<code>webview</code>内容存储起来，当<strong>webview面板</strong>切换回来时继续使用。可以通过<code>visible</code>属性获取到当前<strong>webview面板</strong>可见性的状态。插件可以通过<code>reveal</code>方法将被切换到隐藏的<code>webview</code>重新切到可见状态，方法接受一个表明视图列的参数。</p>
<p>下面来优化下代码，如果<code>webview</code>已经被创建，则将其切换到可见状态（在前面的版本里，执行命令会不断生成新的<code>webview</code>）：</p>
<pre class="line-numbers"><code class="language-js">export function activate(context: vscode.ExtensionContext) {
    // Track currently webview panel
    let currentPanel: vscode.WebviewPanel | undefined = undefined;

    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            const columnToShowIn = vscode.window.activeTextEditor
                ? vscode.window.activeTextEditor.viewColumn
                : undefined;

            if (currentPanel) {
                // If we already have a panel, show it in the target column
                currentPanel.reveal(columnToShowIn);
            } else {
                // Otherwise, create a new panel
                currentPanel = vscode.window.createWebviewPanel(
                    'catCoding',
                    'Cat Coding',
                    columnToShowIn,
                    {}
                );
                currentPanel.webview.html = getWebviewContent('Coding Cat');

                // Reset when the current panel is closed
                currentPanel.onDidDispose(
                    () =&gt; {
                        currentPanel = undefined;
                        console.log('onDidDispose');
                    },
                    null,
                    context.subscriptions
                );
            }
        })
    );
}
</code></pre>
<p>当<code>webview</code>的可见性或所处的列发生变动时，会触发<code>onDidChangeViewState</code>事件，我们可以改造下插件，让它在所处不同视图列时展示不同的内容：</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

const cats = {
    'Coding Cat': 'https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif',
    'Compiling Cat': 'https://media.giphy.com/media/mlvseq9yvZhba/giphy.gif',
    'Testing Cat': 'https://media.giphy.com/media/3oriO0OEd9QIDdllqo/giphy.gif'
};

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            const panel = vscode.window.createWebviewPanel(
                'catCoding',
                'Cat Coding',
                vscode.ViewColumn.One,
                {}
            );
            panel.webview.html = getWebviewContent('Coding Cat');

            // Update contents based on view state changes
            panel.onDidChangeViewState(e =&gt; {
                const curPanel = e.webviewPanel;
                console.log(panel.viewColumn, curPanel.viewColumn);
                switch (curPanel.viewColumn) {
                    case vscode.ViewColumn.One:
                        updateWebviewForCat(curPanel, 'Coding Cat');
                        return;
                    case vscode.ViewColumn.Two:
                        updateWebviewForCat(curPanel, 'Compiling Cat');
                        return;
                    case vscode.ViewColumn.Three:
                        updateWebviewForCat(curPanel, 'Testing Cat');
                        return;
                }
            }, null, context.subscriptions);
        })
    );
}

function updateWebviewForCat(panel: vscode.WebviewPanel, catName: keyof typeof cats) {
    panel.title = catName;
    panel.webview.html = getWebviewContent(catName);
}

function getWebviewContent(cat: keyof typeof cats) {
    return `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;${cats[cat]}&quot; width=&quot;300&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p><figure><img src="media/16843158016742/pic4.gif" alt="pic4" /><figcaption>pic4<figcaption></figure></p>
<h4><a id="%E6%A3%80%E6%9F%A5%E5%92%8C%E8%B0%83%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>检查和调试</h4>
<p>运行<code>Developer: Toggle Developer Tools</code>命令可以调试<code>webview</code></p>
<p><figure><img src="media/16843158016742/16847374735696.jpg" alt="" /></figure></p>
<p>如果你的<strong>VS Code</strong>版本低于<strong>1.56</strong>或设置了<code>enableFindWidget</code>，则需要执行<code>Developer: Open Webview Developer Tools</code>命令，这个命令给每个<code>webview</code>开启了一个单独的<code>Developer Tools</code>而不是所有的<code>webview</code>共用同一个。</p>
<p>命令<code>Developer: Reload Webview</code>会重载所有已经开启的<code>webview</code>，当希望重置<code>webview</code>的内部状态或重新加载资源时可以用到。</p>
<h4><a id="%E5%8A%A0%E8%BD%BD%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>加载本地资源</h4>
<p><code>webview</code>通过<code>localResourceRoots</code>选项来控制哪些资源可以从用户本地加载，<code>localResourceRoots</code>定义了一系列允许本地加载的根URI。例如我们可以通过<code>localResourceRoots</code>来限制插件只能从本地的<code>media</code>文件夹加载资源：</p>
<pre class="line-numbers"><code class="language-js">export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            const panel = vscode.window.createWebviewPanel(
                'catCoding',
                'Cat Coding',
                vscode.ViewColumn.One,
                {
                    // Only allow the webview to access resources in our extension's media directory
                    localResourceRoots: [vscode.Uri.file(path.join(context.extensionPath, 'media'))]
                }
            );
            const onDiskPath = vscode.Uri.file(
                path.join(context.extensionPath, 'media', 'cat.gif')
            );
            const catGifSrc = panel.webview.asWebviewUri(onDiskPath);
            panel.webview.html = getWebviewContent(catGifSrc);
        })
    );
}
</code></pre>
<p>如果希望不允许加载本地任何资源，将<code>localResourceRoots</code>设置成空数组即可。总的来说在webview中我们还是应该尽可能的限制对本地资源的加载，<code>localResourceRoots</code>并不提供全面的安全保护，有关安全性方面我们后面会有所介绍。</p>
<h4><a id="%E9%80%82%E9%85%8D%E4%B8%BB%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>适配主题</h4>
<p>我们可以用<code>css</code>来给<code>webview</code>附加匹配当前主题对的样式，<strong>VS Code</strong>的主题有三大类：<code>vscode-light</code>、<code>vscode-dark</code>、<code>vscode-high-contrast</code>。<strong>VS Code</strong>会将当前主题的类别附加在<code>webview</code>的<code>body</code>元素的class上</p>
<p><figure><img src="media/16843158016742/16847384761046.jpg" alt="" /></figure></p>
<p>然后我们可以编写类似如下的代码适配不同的主题：</p>
<pre class="line-numbers"><code class="language-plain_text">body.vscode-light {
  color: black;
}

body.vscode-dark {
  color: white;
}

body.vscode-high-contrast {
  color: red;
}
</code></pre>
<p><strong>VS Code</strong>官方要求当开发一款<code>webview</code>应用时，需要确保其支持三种主题，并且一定要在<code>high-contrast</code>做好测试以便对于存在视力缺陷的用户也是可以使用的。</p>
<p>在编写<code>webview</code>样式文件时，我们可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties">css 变量</a> 来访问<strong>VS Code</strong>内置的主题色，这些变量是主题色变量附加<code>--vscode-</code>前缀并将<code>.</code>替换成<code>-</code>，例如<code>editor.foreground</code>的<code>css</code>变量是<code>var(--vscode-editor-foreground)</code>：</p>
<pre class="line-numbers"><code class="language-plain_text">code {
  color: var(--vscode-editor-foreground);
}
</code></pre>
<p>你可以在 <a href="https://code.visualstudio.com/api/references/theme-color">theme-color</a> 找到<strong>VS Code</strong>所支持的主题色，你可以通过安装 <a href="https://marketplace.visualstudio.com/items?itemName=connor4312.css-theme-completions">VS Code CSS Theme Completions</a>来得到变量名称的自动补全。</p>
<p>另外你要还需要知道一些和字体有关的变量：</p>
<ul>
<li><code>--vscode-editor-font-family</code>：数值同<code>editor.fontFamily</code></li>
<li><code>--vscode-editor-font-weight</code>：数值同<code>editor.fontWeight</code></li>
<li><code>--vscode-editor-font-size</code>：数值同<code>editor.fontSize</code></li>
</ul>
<p>如果你希望给某个具体的主题适配<code>css</code>样式，你可以利用<code>body</code>上的<code>vscode-theme-name</code>属性，该属性值是当前使用的主题名称</p>
<p><figure><img src="media/16843158016742/16847384761046.jpg" alt="" /></figure></p>
<pre class="line-numbers"><code class="language-plain_text">body[data-vscode-theme-name=&quot;Darktooth&quot;] {
    background: hotpink;
}
</code></pre>
<h4><a id="%E8%84%9A%E6%9C%AC%E5%92%8C%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚本和消息传递</h4>
<h5><a id="%E8%84%9A%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚本</h5>
<p><code>webview</code>和<code>iframe</code>很相似，你可以运行自己的脚本，默认情况下脚本是不可用状态，需要通过设置<code>enableScripts: true</code>来开启该功能，让我们编写一段简单的计数脚本，不过这仅是个示例，实际编写的时候不要使用内联的脚本（<strong>内联代码被视为是有害的</strong>）</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';
import * as path from 'path';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            const panel = vscode.window.createWebviewPanel(
                'catCoding',
                'Cat Coding',
                vscode.ViewColumn.One,
                {
                    // Enable scripts in the webview
                    enableScripts: true
                }
            );
            panel.webview.html = getWebviewContent();
        })
    );
}


function getWebviewContent() {
    return `&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
    &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

    &lt;script&gt;
        const counter = document.getElementById('lines-of-code-counter');

        let count = 0;
        setInterval(() =&gt; {
            counter.textContent = count++;
        }, 100);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p><code>webview</code>中的脚本使用起来和普通网页里的脚本一样，能干的事情也一样，没有区别。需要注意的是，<code>webview</code>中的脚本不能直接调用<strong>VS Code API</strong>，如有此类需要，需借助消息机制来实现</p>
<h5><a id="%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息传递</h5>
<p><strong>从插件向webview传递消息</strong></p>
<p>对于插件来说，可以通过<code>webview.postMessage()</code>函数向<code>webview</code>传递<code>JSON</code>数据，在<code>webview</code>中通过监听<code>message</code>事件（<code>window.addEventListener('message', event =&gt; { ... })</code>）来接收数据。为了演示数据传递的功能，我们增加一个新的命令<code>catCoding.doRefactor</code>，当执行这个新命令时传递给<code>webview</code>一条信息，让计数器计数减半：</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    // Only allow a single Cat Coder
    let currentPanel: vscode.WebviewPanel | undefined = undefined;

    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            if (currentPanel) {
                currentPanel.reveal(vscode.ViewColumn.One);
            } else {
                currentPanel = vscode.window.createWebviewPanel(
                    'catCoding',
                    'Cat Coding',
                    vscode.ViewColumn.One,
                    {
                        enableScripts: true
                    }
                );
                currentPanel.webview.html = getWebviewContent();
                currentPanel.onDidDispose(() =&gt; {
                    currentPanel = undefined;
                }, undefined, context.subscriptions);
            }
        })
    );

    // Our new command
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.doRefactor', () =&gt; {
            if (!currentPanel) {
                return;
            }
            // Send a message to our webview.
            // You can send any JSON serializable data.
            currentPanel.webview.postMessage({ command: 'refactor' });
        })
    );
}


function getWebviewContent() {
    return `
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
    &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

    &lt;script&gt;
        const counter = document.getElementById('lines-of-code-counter');
        let count = 0;
        setInterval(() =&gt; {
            counter.textContent = count++;
        }, 100);
        // Handle the message inside the webview
        window.addEventListener('message', event =&gt; {
            const message = event.data; // The JSON data our extension sent
            switch (message.command) {
                case 'refactor':
                    count = Math.ceil(count * 0.5);
                    counter.textContent = count;
                    break;
            }
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p><figure><img src="media/16843158016742/pic5.gif" alt="pic5" /><figcaption>pic5<figcaption></figure></p>
<p><strong>从webview向插件传递消息</strong></p>
<p><code>webview</code>可以给插件传递信息，利用<code>webview</code>内嵌的<strong>VS Code API</strong>对象来调用<code>postMessage</code>函数，为了获取到<strong>VS Code API</strong>对象需要调用<code>acquireVsCodeApi</code>函数。<code>acquireVsCodeApi</code>函数只能调用一次，所以你需要将其返回的内容保存好，以便其它脚本可以调用到：</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            const panel = vscode.window.createWebviewPanel(
                'catCoding',
                'Cat Coding',
                vscode.ViewColumn.One,
                {
                    enableScripts: true
                }
            );

            panel.webview.html = getWebviewContent();

            // Handle messages from the webview
            panel.webview.onDidReceiveMessage(message =&gt; {
                switch (message.command) {
                    case 'alert':
                        vscode.window.showErrorMessage(message.text);
                        return;
                }
            }, undefined, context.subscriptions);
        })
    );
}

function getWebviewContent() {
    return `
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
    &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

    &lt;script&gt;
        (function() {
            // 获取VS Code API 对象
            const vscode = acquireVsCodeApi();
            const counter = document.getElementById('lines-of-code-counter');

            let count = 0;
            setInterval(() =&gt; {
                counter.textContent = count++;

                // Alert the extension when our cat introduces a bug
                if (count % 100 === 0) {
                    vscode.postMessage({
                        command: 'alert',
                        text: '🐛  on line ' + count
                    })
                }
            }, 100);
        }())
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p>按照<strong>VS Code</strong>官方的建议，出于安全性考虑，<strong>VS Code API</strong>对象（上文代码里的<code>vscode</code>变量）应该是私有的，不要设置为全局变量</p>
<h3><a id="%E5%AE%89%E5%85%A8%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安全性</h3>
<p>在<code>webview</code>中编写代码有一些安全性的最佳实践，需要开发者知晓</p>
<h4><a id="%E9%99%90%E5%88%B6%E6%9D%83%E9%99%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>限制权限</h4>
<p><code>webview</code>应该仅收紧对各项能力权限的限制，比如说你的<code>webview</code>程序不需要运行<code>js</code>脚本，那么就不要设置<code>enableScripts: true</code>；如果你的程序不需要加载本地资源，那么就不要设置<code>localResourceRoots</code>开启对本地的访问权限</p>
<h4><a id="%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%94%BF%E7%AD%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内容安全政策</h4>
<p><a href="https://developers.google.com/web/fundamentals/security/csp/">内容安全政策</a> 更进一步的限制哪些内容可以在<code>webview</code>中被加载和执行，例如一个内容安全政策可以限制只有某个白名单内的脚本才能可以在<code>webview</code>中运行，或者告知<code>webview</code>只可以加载<code>https</code>协议的图片。</p>
<p>增加内容安全政策的方法是，在<code>webview</code>的<code>head</code>标签顶端增加<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code>指令：</p>
<pre class="line-numbers"><code class="language-plain_text">&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'none';&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
</code></pre>
<p>政策<code>default-src 'none'</code>;不允许任何内容，在此基础上逐步构建更完善的政策，下面这段表示仅允许加载本地脚本和样式文件，且图片加载协议应该是<code>https</code>的政策：</p>
<pre class="line-numbers"><code class="language-plain_text">&lt;meta
  http-equiv=&quot;Content-Security-Policy&quot;
  content=&quot;default-src 'none'; img-src ${webview.cspSource} https:; script-src ${webview.cspSource}; style-src ${webview.cspSource};&quot;
/&gt;
</code></pre>
<p><code>${webview.cspSource}</code>是一个占位符，关于这个变量的用法，可以参见 <a href="https://github.com/microsoft/vscode-extension-samples/blob/main/webview-sample/src/extension.ts#L196">extension.ts#L196</a></p>
<p>从安全策略上讲，不允许内嵌的脚本或样式，将所有的脚本和样式改为外部文件的方式是一种很好的实践，这样我们就可以用<code>csp</code>来控制其安全性</p>
<h4><a id="%E4%BB%85%E9%80%9A%E8%BF%87https%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>仅通过https加载资源</h4>
<p>如果你的<code>webview</code>允许加载资源，那么强烈推荐通过<code>https</code>加载而非<code>http</code></p>
<h4><a id="%E9%98%B2%E6%AD%A2%E5%86%85%E5%AE%B9%E6%B3%A8%E5%85%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>防止内容注入</h4>
<p>一定要控制好用户的输入防止内容注入，例如以下的情况就需要额外注意：</p>
<ul>
<li>文件内容</li>
<li>文件以及文件夹路径</li>
<li>用户设置</li>
</ul>
<h3><a id="%E8%BF%9B%E9%98%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶</h3>
<p>在通常的<code>webview</code>生命周期里，<code>webview</code>是被<code>createWebviewPanel</code>函数所创建并在用户关闭或调用了<code>dispose</code>方法时销毁，不过对于<code>webview</code>的内容来说不是这样，<code>tab</code>的切换会导致<code>webview</code>的可见性来回切换，当<code>webview</code>不可见时其内容会被销毁，当可见时内容又会被重新创建。例如上面示例中的计数器，当可见性在切换时其数据会因销毁而丢失</p>
<p><figure><img src="media/16843158016742/pic6.gif" alt="pic6" /><figcaption>pic6<figcaption></figure></p>
<p>解决这个的最佳实践是确保你的<code>webview</code>本身不存储状态，用消息机制来做<code>webview</code>状态的保存和恢复</p>
<h4><a id="getstate%E3%80%81setstate" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getState、setState</h4>
<p>在<code>webview</code>中可以使用<code>getState</code>、<code>setState</code>方法来解决数据的保存和恢复，保存的数据是JSON格式。保存的数据在<code>webview</code>切换为不可见状态、页面内容被销毁后依然可以保存，只有当<code>webview</code>本身被销毁（关闭或执行<code>dispose</code>）时才会销毁。</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            const panel = vscode.window.createWebviewPanel(
                'catCoding',
                'Cat Coding',
                vscode.ViewColumn.One,
                {
                    enableScripts: true
                }
            );
            panel.webview.html = getWebviewContent();
        })
    );
}

function getWebviewContent() {
    return `
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
    &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

    &lt;script&gt;
        (function() {
            // 获取VS Code API 对象
            const vscode = acquireVsCodeApi();
            const counter = document.getElementById('lines-of-code-counter');

            const previousState = vscode.getState();
            let count = previousState ? previousState.count : 0;
            counter.textContent = count;

            setInterval(() =&gt; {
                counter.textContent = count++;
                // Update the saved state
                vscode.setState({ count });
            }, 100);
        }())
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p><figure><img src="media/16843158016742/pic7.gif" alt="pic7" /><figcaption>pic7<figcaption></figure></p>
<p><code>getState</code>和<code>setState</code>是保存状态的最佳的实践方式，性能开销要远低于 <a href="https://code.visualstudio.com/api/references/vscode-api#WebviewPanelOptions">retainContextWhenHidden</a></p>
<h4><a id="%E5%BA%8F%E5%88%97%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>序列化</h4>
<p>通过<code>WebviewPanelSerializer</code>，当<strong>VS Code</strong>重启的时候你的<code>webview</code>可以自动实现数据的恢复，其底层依赖<code>getState</code>和<code>setState</code>，并且只有当你为<code>webview</code>注册<code>WebviewPanelSerializer</code>的时候才会发挥作用。</p>
<p>如果要确保你的代码在<code>webview</code>恢复可见后依然能够保持住之前的状态，首先你需要在<code>package.json</code>的<code>activation event</code>中增加一个<code>onWebviewPanel</code>：</p>
<pre class="line-numbers"><code class="language-json">&quot;activationEvents&quot;: [
    ...,
    &quot;onWebviewPanel:catCoding&quot;
]
</code></pre>
<p>这段代码确保了<strong>VS Code</strong>在任何时候想要恢复<code>webview</code>，插件都会被激活</p>
<p>然后在插件的<code>activate</code>方法中，通过<code>registerWebviewPanelSerializer</code>方法注册一个新的<code>WebviewPanelSerializer</code>，这个<code>WebviewPanelSerializer</code>就是负责存储<code>webview</code>内容里的状态，这个状态是一个在<code>webview</code>中调用<code>setState</code>存储的JSON格式的数据。</p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            const panel = vscode.window.createWebviewPanel(
                'catCoding',
                'Cat Coding',
                vscode.ViewColumn.One,
                {
                    enableScripts: true
                }
            );
            panel.webview.html = getWebviewContent();
        })
    );
    vscode.window.registerWebviewPanelSerializer('catCoding', new CatCodingSerializer());
}

class CatCodingSerializer implements vscode.WebviewPanelSerializer {
    async deserializeWebviewPanel(webviewPanel: vscode.WebviewPanel, state: any) {
        // `state` is the state persisted using `setState` inside the webview
        console.log(`Got state: ${state}`);
        // Restore the content of our webview.
        //
        // Make sure we hold on to the `webviewPanel` passed in here and
        // also restore any event listeners we need on it.
        webviewPanel.webview.html = getWebviewContent();
    }
}

function getWebviewContent() {
    return `
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
    &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

    &lt;script&gt;
        (function() {
            // 获取VS Code API 对象
            const vscode = acquireVsCodeApi();
            const counter = document.getElementById('lines-of-code-counter');

            const previousState = vscode.getState();
            let count = previousState ? previousState.count : 0;
            counter.textContent = count;

            setInterval(() =&gt; {
                counter.textContent = count++;
                // Update the saved state
                vscode.setState({ count });
            }, 100);
        }())
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p>现在如果重启打开一个<code>webview</code>的<strong>VS Code</strong>，我们会发现<code>webview</code>中的<code>state</code>没有丢失</p>
<p><figure><img src="media/16843158016742/pic8.gif" alt="pic8" /><figcaption>pic8<figcaption></figure></p>
<h4><a id="retaincontextwhenhidden" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>retainContextWhenHidden</h4>
<p>对于UI极为复杂不能在恢复可见性后快恢复的<code>webview</code>，我们可以<code>retainContextWhenHidden</code>选项来代替<code>getState</code>、<code>setState</code></p>
<pre class="line-numbers"><code class="language-js">import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
    context.subscriptions.push(
        vscode.commands.registerCommand('catCoding.start', () =&gt; {
            const panel = vscode.window.createWebviewPanel(
                'catCoding',
                'Cat Coding',
                vscode.ViewColumn.One,
                {
                    enableScripts: true,
                    retainContextWhenHidden: true
                }
            );
            panel.webview.html = getWebviewContent();
        })
    );
}

function getWebviewContent() {
    return `
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Cat Coding&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;
    &lt;h1 id=&quot;lines-of-code-counter&quot;&gt;0&lt;/h1&gt;

    &lt;script&gt;
        const counter = document.getElementById('lines-of-code-counter');

        let count = 0;
        setInterval(() =&gt; {
            counter.textContent = count++;
        }, 100);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`;
}
</code></pre>
<p>//TODO pic9</p>
<p>这个方式对内存性能损耗较大，尽量不要使用</p>
<blockquote>
<p>按照<strong>VS Code</strong>官方文档的说法，当<code>webview</code>页面不可见时脚本将会本挂起，当页面恢复可见性时脚本叫被唤醒，但在<code>1.57.0版本</code>的VS Code下，似乎页面不可见的时候计数器也没有停止，这点需要注意。</p>
</blockquote>
<h2><a id="%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8custom-editor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构建自定义编辑器 Custom Editor</h2>
<p>自定义编辑器允许插件创建一个基于<strong>VS Code</strong>标准文本编辑器的高度定制化的私人编辑器，这个编辑器可以用于特殊类型的资源，实际应用方面也有不少实际的应用：</p>
<ul>
<li>资源预览，例如3D模型的shader</li>
<li>创建所见即所得的编辑器，如<code>Markdown</code>或<code>XAML</code></li>
<li>提供<code>CVS</code>、<code>JSON</code>、<code>XML</code>文件数据的可视化渲染</li>
<li>为二进制或文本文件提供编辑能力</li>
</ul>
<p>本文提供自定义编辑器API的概括性描述，并且提供了一个自定义编辑器实现的基础知识。我们会关注两种类型的自定义编辑器，告诉你它们的差异以及适用场景。</p>
<p>尽管自定义编辑器功能非常强大，但实现一个基础的自定义编辑器却并不复杂。实现自定义编辑器对于初学者来说，最复杂的是要接触大量的概念，诸如<code>webview</code>以及<code>text document</code>等，这点对于初学者来说可能是比较头疼的。</p>
<p><strong>VS Code</strong>提供了官方的示例 <a href="https://github.com/microsoft/vscode-extension-samples/tree/main/custom-editor-sample">vscode-extension-samples</a> 也是很好的学习资料，可以了解<code>API</code>的使用方法</p>
<p>本文涉及到的API：</p>
<ul>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#window.registerCustomEditorProvider">registerCustomEditorProvider</a></li>
<li><a href="https://code.visualstudio.com/api/references/vscode-api#CustomTextEditorProvider">CustomTextEditorProvider</a></li>
</ul>
<h3><a id="api%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API基础用法</h3>
<p>自定义编辑器是替代<strong>VS Code</strong>的标准文本编辑器来显示特定资源的另一种视图，它包含两个部分：用户交互的视图和插件中用于与底层资源交互的文档模型</p>
<p>视图部分采用<code>webview</code>实现，开发者采用HTML、CSS、JavaScript来构建用户交互，<code>webview</code>可以通过<strong>VS Code API</strong>直接和组件相互传递信息</p>
<p>文档模型部分，模型的作用是让插件了解它所使用的资源。<code>CustomTextEditorProvider</code>利用<strong>VS Code</strong>的标准 <a href="https://code.visualstudio.com/api/references/vscode-api#TextDocument">纯文本文档</a> 作为它的文档模型，所有的文件变化都是用<strong>VS Code</strong>的标准文本编辑API。</p>
<p><code>CustomReadonlyEditorProvider</code>和<code>CustomEditorProvider</code>会让你创建自己的文档模型用于哪些非文本文件</p>
<p>自定义编辑器对每一种资源都有一个单独文档模型，不过对于同一个文档可能有多个编辑器实例，例如使用<code>View: Split editor</code>功能将同一个文档一分为二</p>
<h4><a id="customeditorcustomtexteditor%E6%A6%82%E8%A7%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CustomEditor/CustomTextEditor概览</h4>
<p>有两类自定义编辑器:自定义文本编辑器和自定义编辑器。二者之间最大的不同是它们定义文档模型的方式</p>
<p>一个<code>CustomTextEditorProvider</code>利用<strong>VS Code</strong>的标准 <a href="https://code.visualstudio.com/api/references/vscode-api#TextDocument">纯文本文档</a> 作为数据模型，你可以对任何基于文本的文件类型使用<code>CustomTextEditor</code>。<code>CustomTextEditor</code>使用起来颇为容易，因为<strong>VS Code</strong>已经知道如何处理文本文件，可以实现多种操作，如保存和备份文件热退出。</p>
<p><code>CustomEditorProvider</code>则是需要插件用自己的文档模型，这意味着你可以利用<code>CustomEditor</code>来处理独特的二进制文件如图片等，当然这也意味着插件需要做更多的工作，例如实现保存和后退（如果你的编辑器只用来读取预览文件，这些复杂的功能也可以省略）。</p>
<h4><a id="contribution-point" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contribution point</h4>
<p>我们需要利用<code>customEditors</code>来配置自定义编辑器所需要的信息，例如告知<strong>VS Code</strong>将哪种文件和自定义编辑器相关联，如下示例：</p>
<pre class="line-numbers"><code class="language-json">&quot;contributes&quot;: {
    &quot;customEditors&quot;: [{
        &quot;viewType&quot;: &quot;catEdit.catScratch&quot;,
        &quot;displayName&quot;: &quot;Cat Scratch&quot;,
        &quot;selector&quot;: [{
            &quot;filenamePattern&quot;: &quot;*.cscratch&quot;
        }],
        &quot;priority&quot;: &quot;default&quot;
    }]
}
</code></pre>
<p><code>customEditors</code>字段的取值是个数组，每个插件可以注册若干自定义编辑器，接下来我们将其逐个字段做介绍：</p>
<ul>
<li><code>viewType</code>：自定义编辑器的唯一标识符，<strong>VS Code</strong>据此来将<code>package.json</code>中注册的自定义编辑器和具体的代码对应，该取值必须是跨插件唯一的</li>
<li><code>displayName</code>：在<strong>VS Code's UI</strong>中用来展示自定义编辑器时使用，例如<code>View: Reopen with</code>命令的下拉框中显示</li>
<li><code>selector</code>：定义那种文件会激活自定义编辑器，取值是一个<code>glob patterns</code>数组，既可以定义具体的文件名称，如<code>*.png</code>匹配全部的PNG文件，也可以定义文件夹或路径，如<code>**/translations/*.json</code></li>
<li><code>priority</code>：可选，标示自定义编辑器何时启用，可取值有两个：
<ul>
<li><code>default</code>：根据<code>selector</code>为每个匹配的文件启用自定义编辑器，如果匹配成功了多个编辑器，则交由用户选择使用哪个</li>
<li><code>option</code>：默认不启用自定义编辑器，而是让用户决定</li>
</ul>
</li>
</ul>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义编辑器的启动</h4>
<p>当一个用户打开了自定义编辑器，<strong>VS Code</strong>会触发<code>onCustomEditor:VIEW_TYPE</code>激活事件，然后插件必须在代码里通过调用<code>registerCustomEditorProvider</code>方法来用指定的<code>viewType</code>注册自定义编辑器。<code>onCustomEditor:VIEW_TYPE</code>只在<strong>VS Code</strong>创建了编辑器实例的时候才会被触发，用<code>View: Reopen with</code>展示编辑器列表的时候不会触发。</p>
<h3><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义文本编辑器</h3>
<h4><a id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生命周期</h4>
<p>自定义编辑器的生命周期分为可视组件（<code>webview</code>）生命周期和模型组件（<code>TextDocument</code>）生命周期，都由<strong>VS Code</strong>负责控制，下面我们来梳理下从打开到关闭自定义文本编辑器的整个生命周期流程：</p>
<h5><a id="%E6%89%93%E5%BC%80%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打开自定义文本编辑器</h5>
<p>以 <a href="https://github.com/microsoft/vscode-extension-samples/tree/main/custom-editor-sample">官方示例</a> 为例，首次打开<code>.cscratch</code>文件将会发生下列事情：</p>
<ol>
<li><strong>VS Code</strong>触发<code>onCustomEditor:catCustoms.catScratch</code>事件，在激活期间，插件务必调用<code>registerCustomEditorProvider</code>为<code>catCustoms.catScratch</code>注册<code>CustomTextEditorProvider</code></li>
<li><strong>VS Code</strong>为<code>catCustoms.catScratch</code>调用<code>CustomTextEditorProvider</code>中的<code>resolveCustomTextEditor</code>，该方法接受两个参数<code>TextDocument</code>和<code>WebviewPanel</code>，插件需要为<code>webview</code>填充好初始化所必须的<code>HTML</code>内容</li>
</ol>
<p>一旦<code>resolveCustomTextEditor</code>返回，自定义编辑器就展示给了用户，<code>webview</code>中渲染的内容也完全渲染了</p>
<h5><a id="%E5%85%B3%E9%97%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关闭自定义文本编辑器</h5>
<p>当用户关闭了一个自定义文本编辑器时，<strong>VS Code</strong>会触发<code>webview</code>的<code>WebviewPanel.onDidDispose</code>事件，插件需要清理与此编辑器相关的资源如事件监听、文件监视器等</p>
<p>当指定资源的最后一个自定义编辑器关闭，此资源的<code>TextDocument</code>将会被销毁，可以通过读取<code>TextDocument.isClosed</code>获知<code>TextDocument</code>是否被关闭，一旦关闭了，则打开相关资源时会再重新启动一个<code>TextDocument</code></p>
<h4><a id="%E5%88%A9%E7%94%A8textdocument%E5%90%8C%E6%AD%A5%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>利用TextDocument同步修改</h4>
<ol>
<li>用户在<code>webview</code>中点击<code>Add scratch</code>按钮，给插件发送信息</li>
<li>插件接收到信息，更新<code>JSON</code>数据</li>
<li>插件创建<code>WorkspaceEdit</code>将更新完毕的JSON文件利用<code>vscode.workspace.applyEdit</code>写入磁盘文件</li>
</ol>
<h5><a id="%E4%BB%8Etextdocument%E5%88%B0webview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>从TextDocument到webview</h5>
<p>当一个<code>TextDocument</code>发生了变化，插件需要确保在<code>webview</code>中如实反映其中的变化，下面是示例代码中的相关实现：</p>
<ol>
<li>插件监听<code>vscode.workspace.onDidChangeTextDocument</code>事件，任何对<code>TextDocument</code>的改变都会触发该事件</li>
<li>当<code>TextDocument</code>发生改变，像<code>webview</code>传递信息，<code>webview</code>内容更新</li>
</ol>
<p>任何对磁盘文件的编辑都会触发<code>onDidChangeTextDocument</code>，一定要留意不要陷入更新的死循环。另外还需要对错误异常做好兼容，如处理结构化数据（<code>JSON</code>、<code>XML</code>）时的异常，务必做好兜底处理以及错误信息提示，让用户知道发生了错误以及如何修复。</p>
<p>最后，需要留意，如果<code>webview</code>更新过较频繁或更新代价较高，需要考虑节流措施</p>
<h3><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义编辑器</h3>
<p><code>CustomEditorProvider</code>和<code>CustomReadonlyEditorProvider</code>让开发者具备为二进制文件创建编辑器的能力，赋予了开发者对文件的完全控制（如果是纯文本文档，优先考虑 <code>CustomTextEditor</code>）</p>
<p>官方示例中包含一个简单的自定义二进制文件（其实就是一个以<code>.pawdraw</code>结尾的jpeg文件）编辑器示例，接下来我们一起看下如何创建一个二进制文件编辑器</p>
<h4><a id="customdocument" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CustomDocument</h4>
<p>对于自定义编辑器来说，插件需要用<code>CustomDocument</code>接口来实现自己的文档模型，相较于<code>TextDocument</code>需要我们自己实现诸如保存等操作。每个打开的文件都有一个<code>CustomDocument</code>，即便同一个文件被多个编辑器打开，其背后也是同一个<code>CustomDocument</code></p>
<h4><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义编辑器生命周期</h4>
<p>默认情况下，不能同时针对一个文件打开多个自定义编辑器，这个限制会让自定义编辑器的实现因不必考虑多编辑器之间的同步而更加简单，不过<strong>VS Code</strong>也允许通过设置<code>supportsMultipleEditorsPerDocument: true</code>来支持多编辑器模式，这和<strong>VS Code</strong>的普通文本编辑器行为是一致的。</p>
<h5><a id="%E6%89%93%E5%BC%80%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打开自定义编辑器</h5>
<p>当打开了一个符合<code>customEditor</code>配置规则的文件时，自定义编辑器会被打开，<strong>VS Code</strong>会触发 <a href="https://code.visualstudio.com/api/references/activation-events#onCustomEditor">onCustomEditor</a> 激活事件。针对 <a href="https://github.com/microsoft/vscode-extension-samples/tree/main/custom-editor-sample">官方示例github.com/microsoft/v…</a> ，下面是整个生命周期流程：</p>
<ol>
<li><strong>VS Code</strong>触发<code>onCustomEditor:catCustoms.pawDraw</code>激活事件。在激活状态下，插件需要为<code>catCustoms.pawDraw</code>注册<code>CustomReadonlyEditorProvider</code>或<code>CustomEditorProvider</code></li>
<li><strong>VS Code</strong>调用<code>CustomReadonlyEditorProvider</code>或<code>CustomEditorProvider</code>中的<code>openCustomDocument</code>方法。该方法可以获取到打开的资源<code>uri</code>，并且一定要给这个资源返回一个新的<code>CustomDocument</code>，这里就是插件实现自己文档模型的关键所在，这里可能会涉及到资源初始状态的读取和解析</li>
<li><strong>VS Code</strong>调用<code>resolveCustomEditor</code>，传递给该方法一个在第二步生成的<code>CustomDocument</code>以及一个<code>WebviewPanel</code>。在该函数中，我们必须为自定义编辑器的<code>webview</code>赋初始的<code>HTML</code>内容。如果有需要的话，可以保存针对<code>WebviewPanel</code>的引用以便接下来继续使用。</li>
</ol>
<p>一旦<code>resolveCustomEditor</code>执行完毕，自定义编辑器就展示给了用户</p>
<h5><a id="%E5%85%B3%E9%97%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关闭自定义编辑器</h5>
<p>假设同一个资源正在被两自定义编辑器打开，当用户关闭第一个编辑器时，<strong>VS Code</strong>触发<code>WebviewPanel.onDidDispose</code>事件，此时插件需要做好编辑器相关资源的清理工作。当第二个编辑器被关闭时，<strong>VS Code</strong>再次触发<code>WebviewPanel.onDidDispose</code>事件，此时我们已经关闭了所有与<code>CustomDocument</code>相关的编辑器，<strong>VS Code</strong>会触发<code>CustomDocument.dispose</code>，此时需要做好文档相关资源的清理工作。</p>
<h4><a id="%E5%8F%AA%E8%AF%BB%E5%9E%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>只读型自定义编辑器</h4>
<p>其实不少自定义编辑器根本不需要编辑功能，例如实现图片预览或内存快照文件的可视化，都不需要用到编辑功能，这就是<code>CustomReadonlyEditorProvider</code>的用武之地。</p>
<p><code>CustomReadonlyEditorProvider</code>让你可以创建一个不支持编辑的自定义编辑器，可以用来展示内容，但不支持撤销或保存等操作。和支持编辑功能的自定义编辑器相比，只读型实现起来更为简单。</p>
<h4><a id="%E5%8F%AF%E7%BC%96%E8%BE%91%E5%9E%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可编辑型自定义编辑器入门</h4>
<p>可编辑的自定义编辑器让你可以<code>hook</code>到标准的<strong>VS Code</strong>操作，如撤消、重做，保存和热退出。这使得可编辑自定义编辑器非常强大，但也意味着比只读自定义编辑器复杂得多，需要实现<code>openCustomDocument</code>、<code>resolveCustomEditor</code>等基本操作。</p>
<h5><a id="%E7%BC%96%E8%BE%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编辑</h5>
<p>可编辑文档的任何变化都用“编辑”来表达，一个编辑可以指文本变化、图片旋转或列表重排等，当用户做了一个编辑操作时，插件需要在<code>CustomEditorProvider</code>中触发<code>onDidChangeCustomDocument</code>事件。<code>onDidChangeCustomDocument</code>事件可按两种不同的类型被触发：<code>CustomDocumentContentChangeEvent</code>和<code>CustomDocumentEditEvent</code></p>
<ul>
<li>
<p><code>CustomDocumentContentChangeEvent</code>：最基础的编辑，告知<strong>VS Code</strong>一个文档被编辑了。当插件触发了<code>CustomDocumentContentChangeEvent</code>，<strong>VS Code</strong>会将对应的文档标记为<code>dirty</code>，用户可以通过保存或恢复操作来让文档恢复到<code>non-dirty</code>状态。使用<code>CustomDocumentContentChangeEvent</code>的自定义编辑器不支持撤销和恢复（<code>undo</code>/<code>redo</code>）</p>
</li>
<li>
<p><code>CustomDocumentEditEvent</code>：一个更加复杂的编辑，支持撤销和恢复（<code>undo</code>/<code>redo</code>）。使用场景更多（因为很少需要不支持撤销和恢复），该事件有四个字段：</p>
<ul>
<li><code>document</code>：编辑发生的<code>CustomDocument</code></li>
<li><code>label</code>：一个可选的描述性文案</li>
<li><code>undo</code>：一个函数，当<code>undone</code>时被<strong>VS Code</strong>调用</li>
<li><code>redo</code>：一个函数，当<code>undone</code>时被<strong>VS Code</strong>调用, 当插件触发了<code>CustomDocumentEditEvent</code>，<strong>VS Code</strong>会将对应的文档标记为<code>dirty</code>，执行保存、恢复或撤销可以让文档恢复到<code>non-dirty</code>状态。<code>undo</code>和<code>redo</code>被<strong>VS Code</strong>调用，<strong>VS Code</strong>维护着一个内部的编辑栈，如果插件触发三次<code>onDidChangeCustomDocument</code>（假设称之为a、b、c）</li>
</ul>
</li>
</ul>
<pre class="line-numbers"><code class="language-js">onDidChangeCustomDocument(a);
onDidChangeCustomDocument(b);
onDidChangeCustomDocument(c);
</code></pre>
<p>下面是用户操作和对应的函数调用</p>
<pre class="line-numbers"><code class="language-js">undo — c.undo()
undo — b.undo()
redo — b.redo()
redo — c.redo()
redo — no op, no more edits
</code></pre>
<p>为了实现<code>undo</code>和<code>redo</code>，你的编辑器要维护一个内部的状态，包括要更新所有的相关<code>webview</code>，留意一个资源可能有多个<code>webview</code>。例如多个图片编辑器实例必须展示相同的像素数据，但是允许每个编辑器有自己的缩放倍数和UI状态</p>
<h5><a id="%E4%BF%9D%E5%AD%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>保存</h5>
<p>当一个用户保存了一个自定义编辑器，你的插件负责将被保存的资源即时状态写入到磁盘，具体的行为很大程度上有赖于插件的<code>CustomDocument</code>类型以及你如何追踪编辑操作。</p>
<p>基本的保存操作包含以下要点：</p>
<ol>
<li>追踪资源的状态，以便可以迅速的序列化。例如一个基础的图片编辑器需要维护像素数据</li>
<li>重放自上次保存以来的编辑以生成新文件。一个更有效率的图片编辑器会追踪自上次编辑以来的操作，诸如剪裁、旋转、缩放等。待到保存的时候，它可以施加这些编辑在文件的上一次保存的状态上以便生成新的文件</li>
<li>需要留意的是，自定义编辑器可以被保存，即便他们还未可见。基于这个原因，推荐插件不要依赖<code>WebviewPanel</code>去实现保存。如果没法做到，你可以用<code>WebviewPanelOptions.retainContextWhenHidden</code>以确保<code>webview</code>在不可见状态时依然处于激活状态。</li>
</ol>
<p>获取到资源的数据之后，你通常会用到 <a href="https://code.visualstudio.com/api/references/vscode-api#FileSystem">文件API</a> 去写磁盘，文件API处理<code>UInt8Array</code>类型的数据，可以输出二进制或文本文件。对于二进制文件数据，简单的讲二进制数据放到<code>UInt8Array</code>中。对于纯文本文件数据，用<code>Buffer</code>将字符串转换为<code>UInt8Array</code>，如：</p>
<pre class="line-numbers"><code class="language-js">const writeData = Buffer.from('my text data', 'utf8');
vscode.workspace.fs.writeFile(fileUri, writeData);
</code></pre>
<h2><a id="%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7programmatic-language-features" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>编程式语言特性 Programmatic Language Features</h2>
<h3><a id="%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概述</h3>
<p>编程语言特性（Programmatic Language Features）是由 <a href="https://code.visualstudio.com/api/references/vscode-api#languages">vscode.languages.*</a> 系列接口提供的智能编辑能力，通常有两种方式来提供动态语言特性，以Hover为例：</p>
<pre class="line-numbers"><code class="language-js">vscode.languages.registerHoverProvider('javascript', {
    provideHover(document, position, token) {
        return {
            contents: ['Hover Content']
        };
    }
});
</code></pre>
<p>如上所见 <a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider">vscode.languages.registerHoverProvider</a> 接口实现了一个方便的为JavaScript文件提供<code>hover contents</code>的方式。本文第一章节的“语言特性列表”可以帮助你找到插件所需要的<code>API</code>/<code>LSP</code></p>
<p>除此之外，另一种方式是实现一个遵循语言服务器协议（<a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>，下文简称LSP）的语言服务器（Language Server），其原理如下：</p>
<ul>
<li>插件提供一个语言客户端（Language Client，下文简称LC）和一个语言服务器（Language Server，以下简称LS）</li>
<li><code>LC</code>可以看做是一个基本的<strong>VS Code</strong>插件，运行在Node.js插件上下文中，当<code>LC</code>被激活时它将会启动<code>LS</code>进程并利用<code>LSP</code>与之通信</li>
<li>用户在<strong>VS Code</strong> hover了一段JavaScript代码</li>
<li><strong>VS Code</strong>将hover告知<code>LC</code></li>
<li><code>LC</code>从<code>LS</code>处查询hover的结果，让后将其返回给<strong>VS Code</strong></li>
<li><strong>VS Code</strong>展示hover的结果</li>
</ul>
<p>上述过程比较繁琐，但有两个比较大的长处：</p>
<ul>
<li><code>LS</code>是语言无关的，可以用任何开发语言</li>
<li><code>LS</code>是可以在其它编辑器里被复用</li>
</ul>
<p>以后会有专门文章介绍更多关于<code>LS</code>的信息。本文将会重点介绍<strong>VS Code</strong>提供的各种编程语言特性</p>
<h3><a id="%E7%89%B9%E6%80%A7%E5%88%97%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>特性列表</h3>
<p>下面这个列表列出了<strong>VS Code API</strong>和对应的<code>LSP</code>，本文后面内容皆是根据此列表而来</p>
<table>
<thead>
<tr>
<th>VS Code API</th>
<th>LSP method</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.createDiagnosticCollection">createDiagnosticCollection</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_publishDiagnostics">PublishDiagnostics</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCompletionItemProvider">registerCompletionItemProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_completion">Completion</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#completionItem_resolve">Completion Resolve</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerHoverProvider">registerHoverProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_hover">Hover</a></td>
</tr>
<tr>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_hover">registerSignatureHelpProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_signatureHelp">SignatureHelp</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDefinitionProvider">registerDefinitionProvider</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDefinitionProvider">Definition</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerTypeDefinitionProvider">registerTypeDefinitionProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_typeDefinition">TypeDefinition</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerImplementationProvider">registerImplementationProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_implementation">Implementation</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerReferenceProvider">registerReferenceProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_references">References</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentHighlightProvider">registerDocumentHighlightProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight">DocumentHighlight</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentSymbolProvider">registerDocumentSymbolProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentSymbol">DocumentSymbol</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCodeActionsProvider">registerCodeActionsProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_codeAction">CodeAction</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerCodeLensProvider">registerCodeLensProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_codeLens">CodeLens</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#codeLens_resolve">CodeLens Resolve</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentLinkProvider">registerDocumentLinkProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentLink">DocumentLink</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#documentLink_resolve">DocumentLink Resolve</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerColorProvider">registerColorProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentColor">DocumentColor</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_colorPresentation">Color Presentation</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentFormattingEditProvider">registerDocumentFormattingEditProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting">Formatting</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerDocumentRangeFormattingEditProvider">registerDocumentRangeFormattingEditProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_rangeFormatting">RangeFormatting</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerOnTypeFormattingEditProvider">registerOnTypeFormattingEditProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_onTypeFormatting">OnTypeFormatting</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerRenameProvider">registerRenameProvider</a></td>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerRenameProvider">Rename</a> &amp; <a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_prepareRename">Prepare Rename</a></td>
</tr>
<tr>
<td><a href="https://code.visualstudio.com/api/references/vscode-api#languages.registerFoldingRangeProvider">registerFoldingRangeProvider</a></td>
<td><a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_foldingRange">FoldingRange</a></td>
</tr>
</tbody>
</table>
<h3><a id="%E7%89%B9%E6%80%A7%E8%AF%A6%E6%83%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>特性详情</h3>
<h4><a id="%E4%BB%A3%E7%A0%81%E8%AF%8A%E6%96%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码诊断</h4>
<p>我们利用代码诊断指出当前代码存在的问题</p>
<p><figure><img src="media/16843158016742/16853482449622.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p><code>LS</code>发送<code>textDocument/publishDiagnostics</code>消息给<code>LC</code>，消息是一个数组，每一项是诊断结果。需要注意的是，消息的传递不是<code>LC</code>发送请求，而是由<code>LS</code>主动推送给<code>LC</code></p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-js">let diagnosticCollection: vscode.DiagnosticCollection;

export function activate(ctx: vscode.ExtensionContext): void {
    // ...
    ctx.subscriptions.push(getDisposable());
    diagnosticCollection = vscode.languages.createDiagnosticCollection('go');
    ctx.subscriptions.push(diagnosticCollection);
    // ...
}

function onChange() {
    let uri = document.uri;
    check(uri.fsPath, goConfig).then(errors =&gt; {
        diagnosticCollection.clear();
        let diagnosticMap: Map&lt;string, vscode.Diagnostic[]&gt; = new Map();
        errors.forEach(error =&gt; {
            let canonicalFile = vscode.Uri.file(error.file).toString();
            let range = new vscode.Range(error.line - 1, error.startColumn, error.line - 1, error.endColumn);
            let diagnostics = diagnosticMap.get(canonicalFile);
            if (!diagnostics) { diagnostics = []; }
            diagnostics.push(new vscode.Diagnostic(range, error.msg, error.severity));
            diagnosticMap.set(canonicalFile, diagnostics);
        });
        diagnosticMap.forEach((diags, file) =&gt; {
            diagnosticCollection.set(vscode.Uri.parse(file), diags);
        });
    })
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>在每次保存的时候做最低限度的代码诊断，如果做的好一些的话，可以仅对本次保存更改的内容做诊断，仅针对打开的文件</p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶应用</h5>
<p>给文件夹下的每一个文件无论是否打开，都做代码诊断</p>
<h4><a id="%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E5%BB%BA%E8%AE%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码补全建议</h4>
<p>代码补全主要是为用户提供与上下文相关的建议</p>
<p><figure><img src="media/16843158016742/16853483551302.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p><code>LS</code>在<code>onInitialize</code>方法中申明支持代码补全以及是否支持<code>completionItem\resolve</code>方法提供额外的代码补全信息</p>
<pre class="line-numbers"><code class="language-js">{
    ...
    &quot;capabilities&quot; : {
        &quot;completionProvider&quot; : {
            &quot;resolveProvider&quot;: &quot;true&quot;,
            &quot;triggerCharacters&quot;: [ '.' ]
        }
        ...
    }
}
</code></pre>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-js">class GoSignatureHelpProvider implements SignatureHelpProvider {
    public provideSignatureHelp(
        document: TextDocument, position: Position, token: CancellationToken):
        Promise&lt;SignatureHelp&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerSignatureHelpProvider(
            GO_MODE, new GoSignatureHelpProvider(), '(', ','));
    ...
}
</code></pre>
<pre class="line-numbers"><code class="language-js">class GoCompletionItemProvider implements vscode.CompletionItemProvider {
    public provideCompletionItems(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        Thenable&lt;vscode.CompletionItem[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(getDisposable());
    ctx.subscriptions.push(
        vscode.languages.registerCompletionItemProvider(
            GO_MODE, new GoCompletionItemProvider(), '.', '\&quot;'));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>不提供<code>completionItem\resolve</code></p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶应用</h5>
<p>提供<code>completionItem\resolve</code>支持，给用户额外的复杂建议的附加信息</p>
<h4><a id="%E5%B1%95%E7%A4%BAhover" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>展示hover</h4>
<p>hover功能会展示当前鼠标下代码的信息，通常是描述或数据类型</p>
<p><figure><img src="media/16843158016742/16853485605286.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持hover功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;hoverProvider&quot; : &quot;true&quot;,
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/hover</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-js">class GoHoverProvider implements HoverProvider {
    public provideHover(
        document: TextDocument, position: Position, token: CancellationToken):
        Thenable&lt;Hover&gt; {
    // ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    //  ...
    ctx.subscriptions.push(
        vscode.languages.registerHoverProvider(
            GO_MODE, new GoHoverProvider()));
    // ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>展示类型信息，如果可能的话增加一些备注</p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶应用</h5>
<p>用与代码着色相同的样式着色方法签名</p>
<h4><a id="%E5%B1%95%E7%A4%BA%E5%87%BD%E6%95%B0%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>展示函数、方法的帮助信息</h4>
<p>当用户输入方法或函数时展示其信息</p>
<p><figure><img src="media/16843158016742/16853487849323.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持帮助功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;signatureHelpProvider&quot; : {
            &quot;triggerCharacters&quot;: [ '(' ]
        }
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/signatureHelp</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-plain_text">class GoSignatureHelpProvider implements SignatureHelpProvider {
    public provideSignatureHelp(
        document: TextDocument, position: Position, token: CancellationToken):
        Promise&lt;SignatureHelp&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerSignatureHelpProvider(
            GO_MODE, new GoSignatureHelpProvider(), '(', ','));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>为函数或class方法提供参数的文档</p>
<h4><a id="%E5%B1%95%E7%A4%BA%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>展示定义</h4>
<p>允许用户在变量、函数、方法使用的地方查看其定义</p>
<p><figure><img src="media/16843158016742/16853488817013.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持跳转到定义位置的功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;definitionProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/definition</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-plain_text">class GoDefinitionProvider implements vscode.DefinitionProvider {
    public provideDefinition(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        Thenable&lt;vscode.Location&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDefinitionProvider(
            GO_MODE, new GoDefinitionProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>支持展示多个定义</p>
<h4><a id="%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%95%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>找到所有的引用</h4>
<p>支持用户查看某个变量、函数、方法、符号的所有使用位置</p>
<p><figure><img src="media/16843158016742/16853489800414.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持符号引用定位的功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;referencesProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/references</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-js">class GoReferenceProvider implements vscode.ReferenceProvider {
    public provideReferences(
        document: vscode.TextDocument, position: vscode.Position,
        options: { includeDeclaration: boolean }, token: vscode.CancellationToken):
        Thenable&lt;vscode.Location[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerReferenceProvider(
            GO_MODE, new GoReferenceProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>返回所有的引用位置（文件URI和范围）</p>
<h4><a id="%E7%AC%A6%E5%8F%B7%E9%AB%98%E4%BA%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>符号高亮</h4>
<p>方便用户查看整个文档中同一个字符的使用情况</p>
<p><figure><img src="media/16843158016742/16853490575158.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持符号文档定位的功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentHighlightProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/documentHighlight</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-js">class GoDocumentHighlightProvider implements vscode.DocumentHighlightProvider {
    public provideDocumentHighlights(
        document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken):
        vscode.DocumentHighlight[] | Thenable&lt;vscode.DocumentHighlight[]&gt;;
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentHighlightProvider(
            GO_MODE, new GoDocumentHighlightProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>返回符号的引用位置</p>
<h4><a id="%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E6%96%87%E6%A1%A3%E7%9A%84%E5%85%A8%E9%83%A8%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>显示当前文档的全部定义</h4>
<p>支持用户快速浏览一个打开的文档里的全部符号定义</p>
<p><figure><img src="media/16843158016742/16853491460113.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持符号文档定位的功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentSymbolProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/documentSymbol</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-plain_text">class GoDocumentSymbolProvider implements vscode.DocumentSymbolProvider {
    public provideDocumentSymbols(
        document: vscode.TextDocument, token: vscode.CancellationToken):
        Thenable&lt;vscode.SymbolInformation[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentSymbolProvider(
            GO_MODE, new GoDocumentSymbolProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>返回一个文档里的全部应用，定义好符号的类型，如变量、函数、class、方法等</p>
<h4><a id="%E5%B1%95%E7%A4%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E9%87%8C%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>展示文件夹里的所有字符定义</h4>
<p>支持用户快速浏览工作区内的所有符号定义</p>
<p><figure><img src="media/16843158016742/16853492196169.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持全局符号定位的功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;workspaceSymbolProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/symbol</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-js">class GoWorkspaceSymbolProvider implements vscode.WorkspaceSymbolProvider {
    public provideWorkspaceSymbols(
        query: string, token: vscode.CancellationToken):
        Thenable&lt;vscode.SymbolInformation[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerWorkspaceSymbolProvider(
            new GoWorkspaceSymbolProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>返回工作区内全部的字符定义，定义好符号的类型，如变量、函数、class、方法等</p>
<h4><a id="%E6%8F%90%E4%BE%9B%E5%8F%AF%E8%83%BD%E7%9A%84%E9%94%99%E8%AF%AF%E6%88%96%E6%8A%A5%E8%AD%A6%E4%BF%AE%E5%A4%8D%E4%BF%A1%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提供可能的错误或报警修复信息</h4>
<p>在错误或警告旁边向用户提供可能的纠正措施，通过一个灯泡来提示用户，当用户点击了灯泡时显示一系列可用的修复措施</p>
<p><figure><img src="media/16843158016742/16853494877333.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持编码指导的功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;codeActionProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/codeAction</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-js">class GoCodeActionProvider implements vscode.CodeActionProvider {
    public provideCodeActions(
        document: vscode.TextDocument, range: vscode.Range,
        context: vscode.CodeActionContext, token: vscode.CancellationToken):
        Thenable&lt;vscode.Command[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerCodeActionsProvider(
            GO_MODE, new GoCodeActionProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>提供错误或告警的修复措施</p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶应用</h5>
<p>提供诸如代码重构等自动化措施</p>
<h4><a id="codelens" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CodeLens</h4>
<p>为用户提供可操作的上下文信息，显示在源代码中</p>
<p><figure><img src="media/16843158016742/16853496603516.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持<code>CodeLens</code>功能以及是否支持<code>codeLens\resolve</code>：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;codeLensProvider&quot; : {
            &quot;resolveProvider&quot;: &quot;true&quot;
        }
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/codeLens</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-plain_text">class GoCodeLensProvider implements vscode.CodeLensProvider {
    public provideCodeLenses(document: TextDocument, token: CancellationToken):
        CodeLens[] | Thenable&lt;CodeLens[]&gt; {
    ...
    }

    public resolveCodeLens?(codeLens: CodeLens, token: CancellationToken):
         CodeLens | Thenable&lt;CodeLens&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerCodeLensProvider(
            GO_MODE, new GoCodeLensProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>定义可用于文档的<code>CodeLens</code>结果</p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶应用</h5>
<p>将<code>CodeLens</code>结果绑定给一个命令作为对<code>codeLens/resolve</code>的回应</p>
<h4><a id="%E6%98%BE%E7%A4%BA%E5%8F%96%E8%89%B2%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>显示取色器</h4>
<p>支持用户预览和修改文档中的颜色</p>
<p><figure><img src="media/16843158016742/16853497545204.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明提供颜色信息的功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;colorProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/documentColor</code>和<code>textDocument/colorPresentation</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-plain_text">class GoColorProvider implements vscode.DocumentColorProvider {
    public provideDocumentColors(
        document: vscode.TextDocument, token: vscode.CancellationToken):
        Thenable&lt;vscode.ColorInformation[]&gt; {
    ...
    }
    public provideColorPresentations(
        color: Color, context: { document: TextDocument, range: Range }, token: vscode.CancellationToken):
        Thenable&lt;vscode.ColorPresentation[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerColorProvider(
            GO_MODE, new GoColorProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>返回文件中的所有颜色，为支持的颜色格式（如rgb、hsl）提供颜色表示</p>
<h4><a id="%E6%96%87%E6%A1%A3%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文档代码格式化</h4>
<p>提供用户格式化整个文档的能力</p>
<p><figure><img src="media/16843158016742/16853498257282.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持文档格式化功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentFormattingProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/formatting</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-plain_text">class GoDocumentFormatter implements vscode.DocumentFormattingEditProvider {
    public formatDocument(document: vscode.TextDocument):
        Thenable&lt;vscode.TextEdit[]&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentFormattingEditProvider(
            GO_MODE, new GoDocumentFormatter()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>不提供格式化支持</p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶功能</h5>
<p>返回尽可能小的导致源代码格式化的文本编辑。以确保如诊断结果的调整是正确的，而不是丢失</p>
<h4><a id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%80%89%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>格式化选中的内容</h4>
<p><figure><img src="media/16843158016742/16853499281428.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持格式化选中内容的功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentRangeFormattingProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/rangeFormatting</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-plain_text">class GoDocumentRangeFormatter implements vscode.DocumentRangeFormattingEditProvider{
    public provideDocumentRangeFormattingEdits(
        document: vscode.TextDocument, range: vscode.Range,
        options: vscode.FormattingOptions, token: vscode.CancellationToken):
        Thenable&lt;vscode.TextEdit[]&gt;;
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerDocumentRangeFormattingEditProvider(
            GO_MODE, new GoDocumentRangeFormatter()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>不提供格式化支持</p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶功能</h5>
<p>返回尽可能小的导致源代码格式化的文本编辑。以确保如诊断结果的调整是正确的，而不是丢失</p>
<h4><a id="%E6%B8%90%E8%BF%9B%E5%BC%8F%E8%87%AA%E5%8A%A8%E6%A0%BC%E5%BC%8F%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>渐进式自动格式化</h4>
<p>支持用户在键入一行后自动格式化，用户配置的<code>editor.formatOnType</code>是否启用此功能</p>
<p><figure><img src="media/16843158016742/16853500162421.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持自动格式化的功能，同时还需要告知<code>LC</code>哪个字符会触发自动格式化，<code>moreTriggerCharacters</code>是可选的：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;documentOnTypeFormattingProvider&quot; : {
            &quot;firstTriggerCharacter&quot;: &quot;}&quot;,
            &quot;moreTriggerCharacter&quot;: [&quot;;&quot;, &quot;,&quot;]
        }
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/onTypeFormatting</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-js">class GoOnTypingFormatter implements vscode.OnTypeFormattingEditProvider{
    public provideOnTypeFormattingEdits(
        document: vscode.TextDocument, position: vscode.Position,
        ch: string, options: vscode.FormattingOptions, token: vscode.CancellationToken):
        Thenable&lt;vscode.TextEdit[]&gt;;
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerOnTypeFormattingEditProvider(
            GO_MODE, new GoOnTypingFormatter()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>不提供格式化支持</p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶功能</h5>
<p>返回尽可能小的导致源代码格式化的文本编辑。以确保如诊断结果的调整是正确的，而不是丢失</p>
<h4><a id="%E9%87%8D%E5%91%BD%E5%90%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重命名</h4>
<p>允许用户重命名一个符号并且自动将所有引用都更新</p>
<p><figure><img src="media/16843158016742/16853501066137.jpg" alt="" /></figure></p>
<h5><a id="lsp%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LSP方式</h5>
<p>需要<code>LS</code>在<code>onInitialize</code>方法中申明支持重命名功能：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    ...
    &quot;capabilities&quot; : {
        &quot;renameProvider&quot; : &quot;true&quot;
        ...
    }
}
</code></pre>
<p>此外，<code>LS</code>需要对<code>textDocument/references</code>做出回应</p>
<h5><a id="api%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API方式</h5>
<pre class="line-numbers"><code class="language-plain_text">class GoRenameProvider implements vscode.RenameProvider {
    public provideRenameEdits(
        document: vscode.TextDocument, position: vscode.Position,
        newName: string, token: vscode.CancellationToken):
        Thenable&lt;vscode.WorkspaceEdit&gt; {
    ...
    }
}

export function activate(ctx: vscode.ExtensionContext): void {
    ...
    ctx.subscriptions.push(
        vscode.languages.registerRenameProvider(
            GO_MODE, new GoRenameProvider()));
    ...
}
</code></pre>
<h5><a id="%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础应用</h5>
<p>不提供重命名</p>
<h5><a id="%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶应用</h5>
<p>返回需要执行的所有工作空间编辑列表，例如，跨文件的字符引用编辑</p>
<h2><a id="%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%A5%E9%97%A8language-server-extension-guide" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>语言服务器入门 Language Server Extension Guide</h2>
<p>我们可以直接用<code>languages.*</code>接口来提供语言特性的支持，而语言服务器拓展则是另外一种实现途径，本文将介绍的主要内容有：</p>
<ul>
<li>语言服务器的优势</li>
<li>利用<code>Microsoft/vscode-languageserver-node</code>库实现一个简单的语言服务器</li>
<li>如何运行、调试、测试语言服务器</li>
<li>给出一些关于语言服务器的高级主题</li>
</ul>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么我们需要语言服务器</h3>
<p>语言服务器是<code>VS Code</code>插件体系中比较特殊的一种，解决的事不同编程语言的编辑，使之具备诸如自动补全、错误提示、跳转定义等功能。通常如果我们想要实现上述的语言特性，需要考虑三点问题。</p>
<ul>
<li>语言服务器本身有自己的实现架构和实现方式，如何与<strong>VS Code</strong>相互配合是个问题</li>
<li>有些语言特性的支持需要做跨文件分析，会耗费大量的CPU和内存，如何即支持了语言特性同时又不影响<strong>VS Code</strong>的正常使用是个问题</li>
<li>我们对语言的支持是建立在编辑器基础上的，当我们实现了对一种语言的支持后，自然而然的希望能够在更多的编辑器里也能使用，如何更好的跨编辑器复用是个问题，否则m种语言、n种编辑器会导致m*n种结果，这不是我们所希望的</li>
</ul>
<p>为了解决这个问题，<strong>VS Code</strong>给出的解决方案是 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>（下文中简称 <strong>LSP</strong>），该协议将语言特性的实现和编辑器之间的通信做了标准化，对语言特性的支持可以用任何语言来实现并运行在独立的进程中，不会影响到<strong>VS Code</strong>进程，而且由于和编辑器之间的通信协议是标准化的所以可以轻易的移植到其它编辑器上</p>
<p><figure><img src="media/16843158016742/16853503712336.jpg" alt="" /></figure></p>
<h3><a id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现一个语言服务器</h3>
<h4><a id="%E6%A6%82%E8%A7%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概览</h4>
<p>在<strong>VS Code</strong>中一个语言服务器有两部分组成：</p>
<ul>
<li>语言客户端（Language Client，下文简称<strong>LC</strong>）：一个用JavaScript或TypeScript编写的VS Code插件，可以访问所有的 VS Code API，负责启动语言服务器</li>
<li>语言服务器（Language Server，下文简称<strong>LS</strong>）：一个语言分析程序，负责提供支持语言特性所需信息，运行在单独的进程中，可以用任何的编程语言开发。</li>
</ul>
<p>以<code>HTML</code>语言服务和<code>PHP</code>语言服务为例，<code>HTML</code>的<code>LC</code>和<code>PHP</code>的<code>LC</code>分别实例化了各自的<code>LS</code>，<code>LS</code>和<code>LC</code>之间通过<code>LSP</code>通信，<code>HTML</code>的<code>LS</code>用<code>TypeScript</code>语言编写，<code>PHP</code>的<code>LS</code>用<code>PHP</code>语言编写。</p>
<p><figure><img src="media/16843158016742/16853504774379.jpg" alt="" /></figure></p>
<h4><a id="%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E7%BA%AF%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%AD%E8%A8%80%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8F%92%E4%BB%B6%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一个处理纯文本文件的语言服务器插件示例</h4>
<p>我们希望这个处理纯文本的语言服务器有代码自动补全和错误诊断的功能，我们讲项目名称命名为<code>LSP-Sample</code>，代码的目录结构如下：</p>
<pre class="line-numbers"><code class="language-plain_text">.
├── client // Language Client
│   ├── src
│   │   ├── test // End to End tests for Language Client / Server
│   │   └── extension.ts // Language Client entry point
├── package.json // The extension manifest
└── server // Language Server
    └── src
        └── server.ts // Language Server entry point
</code></pre>
<h5><a id="lc%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LC实现</h5>
<p>首先看下整个插件的的<code>/package.json</code>文件：</p>
<pre class="line-numbers"><code class="language-plain_text">{
	&quot;name&quot;: &quot;lsp-sample&quot;,
	&quot;description&quot;: &quot;A language server example&quot;,
	&quot;author&quot;: &quot;Microsoft Corporation&quot;,
	&quot;license&quot;: &quot;MIT&quot;,
	&quot;version&quot;: &quot;1.0.0&quot;,
	&quot;repository&quot;: {
		&quot;type&quot;: &quot;git&quot;,
		&quot;url&quot;: &quot;https://github.com/Microsoft/vscode-extension-samples&quot;
	},
	&quot;publisher&quot;: &quot;vscode-samples&quot;,
	&quot;categories&quot;: [],
	&quot;keywords&quot;: [
		&quot;multi-root ready&quot;
	],
	&quot;engines&quot;: {
		&quot;vscode&quot;: &quot;^1.43.0&quot;
	},
	&quot;activationEvents&quot;: [
		&quot;onLanguage:plaintext&quot;
	],
	&quot;main&quot;: &quot;./client/out/extension&quot;,
	&quot;contributes&quot;: {
		&quot;configuration&quot;: {
			&quot;type&quot;: &quot;object&quot;,
			&quot;title&quot;: &quot;Example configuration&quot;,
			&quot;properties&quot;: {
				&quot;languageServerExample.maxNumberOfProblems&quot;: {
					&quot;scope&quot;: &quot;resource&quot;,
					&quot;type&quot;: &quot;number&quot;,
					&quot;default&quot;: 100,
					&quot;description&quot;: &quot;Controls the maximum number of problems produced by the server.&quot;
				},
				&quot;languageServerExample.trace.server&quot;: {
					&quot;scope&quot;: &quot;window&quot;,
					&quot;type&quot;: &quot;string&quot;,
					&quot;enum&quot;: [
						&quot;off&quot;,
						&quot;messages&quot;,
						&quot;verbose&quot;
					],
					&quot;default&quot;: &quot;off&quot;,
					&quot;description&quot;: &quot;Traces the communication between VS Code and the language server.&quot;
				}
			}
		}
	},
	&quot;scripts&quot;: {
		&quot;vscode:prepublish&quot;: &quot;npm run compile&quot;,
		&quot;compile&quot;: &quot;tsc -b&quot;,
		&quot;watch&quot;: &quot;tsc -b -w&quot;,
		&quot;postinstall&quot;: &quot;cd client &amp;&amp; npm install &amp;&amp; cd ../server &amp;&amp; npm install &amp;&amp; cd ..&quot;,
		&quot;test&quot;: &quot;sh ./scripts/e2e.sh&quot;
	},
	&quot;devDependencies&quot;: {
		&quot;@types/mocha&quot;: &quot;^8.2.2&quot;,
		&quot;@types/node&quot;: &quot;^12.12.0&quot;,
		&quot;@typescript-eslint/eslint-plugin&quot;: &quot;^4.23.0&quot;,
		&quot;@typescript-eslint/parser&quot;: &quot;^4.23.0&quot;,
		&quot;eslint&quot;: &quot;^7.26.0&quot;,
		&quot;mocha&quot;: &quot;^8.3.2&quot;,
		&quot;typescript&quot;: &quot;^4.2.3&quot;
	}
}
</code></pre>
<p><code>activationEvents-onLanguage:plaintext</code>，这段代码告知<strong>VS Code</strong>当纯文本文件被打开时激活插件<code>onLanguage</code>事件接受一个语言标记符，在这里语言标记符是<code>plaintext</code>。每种语言有一个自己的标记符号，该符号大小写敏感，我们可以在 <a href="https://code.visualstudio.com/docs/languages/identifiers#_known-language-identifiers">Known language identifiers</a> 找到所有已知的语言标记，如果想创建一个自己的新语言，可以在<code>package.json</code>中配置：</p>
<pre class="line-numbers"><code class="language-plain_text">{
    &quot;contributes&quot;: {
        &quot;languages&quot;: [{
            &quot;id&quot;: &quot;python&quot;,
            &quot;extensions&quot;: [&quot;.py&quot;],
            &quot;aliases&quot;: [&quot;Python&quot;, &quot;py&quot;],
            &quot;filenames&quot;: [],
            &quot;firstLine&quot;: &quot;^#!/.*\\bpython[0-9.-]*\\b&quot;,
            &quot;configuration&quot;: &quot;./language-configuration.json&quot;
        }]
    }
}
</code></pre>
<p>接着看<code>configuration</code>部分：</p>
<pre class="line-numbers"><code class="language-json">&quot;configuration&quot;: {
    &quot;type&quot;: &quot;object&quot;,
    &quot;title&quot;: &quot;Example configuration&quot;,
    &quot;properties&quot;: {
        &quot;languageServerExample.maxNumberOfProblems&quot;: {
            &quot;scope&quot;: &quot;resource&quot;,
            &quot;type&quot;: &quot;number&quot;,
            &quot;default&quot;: 100,
            &quot;description&quot;: &quot;Controls the maximum number of problems produced by the server.&quot;
        }
    }
}
</code></pre>
<p>这部分配置我们会在<code>LS</code>中用到，主要是配置<code>LS</code>的参数</p>
<p><code>LC</code>的源代码如下：</p>
<pre class="line-numbers"><code class="language-js">/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

import * as path from 'path';
import { workspace, ExtensionContext } from 'vscode';

import {
	LanguageClient,
	LanguageClientOptions,
	ServerOptions,
	TransportKind
} from 'vscode-languageclient/node';

let client: LanguageClient;

export function activate(context: ExtensionContext) {
	// The server is implemented in node
	let serverModule = context.asAbsolutePath(
		path.join('server', 'out', 'server.js')
	);
	// The debug options for the server
	// --inspect=6009: runs the server in Node's Inspector mode so VS Code can attach to the server for debugging
	let debugOptions = { execArgv: ['--nolazy', '--inspect=6009'] };

	// If the extension is launched in debug mode then the debug server options are used
	// Otherwise the run options are used
	let serverOptions: ServerOptions = {
		run: { module: serverModule, transport: TransportKind.ipc },
		debug: {
			module: serverModule,
			transport: TransportKind.ipc,
			options: debugOptions
		}
	};

	// Options to control the language client
	let clientOptions: LanguageClientOptions = {
		// Register the server for plain text documents
		documentSelector: [{ scheme: 'file', language: 'plaintext' }],
		synchronize: {
			// Notify the server about file changes to '.clientrc files contained in the workspace
			fileEvents: workspace.createFileSystemWatcher('**/.clientrc')
		}
	};

	// Create the language client and start the client.
	client = new LanguageClient(
		'languageServerExample',
		'Language Server Example',
		serverOptions,
		clientOptions
	);

	// Start the client. This will also launch the server
	client.start();
}

export function deactivate(): Thenable&lt;void&gt; | undefined {
	if (!client) {
		return undefined;
	}
	return client.stop();
}
</code></pre>
<h5><a id="ls%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LS实现</h5>
<p>在本示例中，<code>LS</code>是用<code>typescript</code>编写的，运行在<code>Node.js</code>环境中，这样选择的好处是<strong>VS Code</strong>为我们提供了一个<code>Node.js</code>运行环境，不必为<code>LS</code>能否运行而担心。<code>LS</code>的源码位于<code>package.json</code>中，其引用了两个代码库：</p>
<pre class="line-numbers"><code class="language-json">&quot;dependencies&quot;: {
    &quot;vscode-languageserver&quot;: &quot;^7.0.0&quot;,
    &quot;vscode-languageserver-textdocument&quot;: &quot;^1.0.1&quot;
}
</code></pre>
<p>下面是一个<code>LS</code>的代码实现，其利用文本文档管理器来负责服务器和<strong>VS Code</strong>之间的文件内容同步</p>
<pre class="line-numbers"><code class="language-js">import {
    createConnection,
    TextDocuments,
    Diagnostic,
    DiagnosticSeverity,
    ProposedFeatures,
    InitializeParams,
    DidChangeConfigurationNotification,
    CompletionItem,
    CompletionItemKind,
    TextDocumentPositionParams,
    TextDocumentSyncKind,
    InitializeResult
} from 'vscode-languageserver/node';

import {
    TextDocument
} from 'vscode-languageserver-textdocument';

// Create a connection for the server, using Node's IPC as a transport.
// Also include all preview / proposed LSP features.
let connection = createConnection(ProposedFeatures.all);

// Create a simple text document manager.
let documents: TextDocuments &lt; TextDocument &gt; = new TextDocuments(TextDocument);

let hasConfigurationCapability: boolean = false;
let hasWorkspaceFolderCapability: boolean = false;
let hasDiagnosticRelatedInformationCapability: boolean = false;

connection.onInitialize((params: InitializeParams) =&gt; {
    let capabilities = params.capabilities;

    // Does the client support the `workspace/configuration` request?
    // If not, we fall back using global settings.
    hasConfigurationCapability = !!(
        capabilities.workspace &amp;&amp; !!capabilities.workspace.configuration
    );
    hasWorkspaceFolderCapability = !!(
        capabilities.workspace &amp;&amp; !!capabilities.workspace.workspaceFolders
    );
    hasDiagnosticRelatedInformationCapability = !!(
        capabilities.textDocument &amp;&amp;
        capabilities.textDocument.publishDiagnostics &amp;&amp;
        capabilities.textDocument.publishDiagnostics.relatedInformation
    );

    const result: InitializeResult = {
        capabilities: {
            textDocumentSync: TextDocumentSyncKind.Incremental,
            // Tell the client that this server supports code completion.
            completionProvider: {
                resolveProvider: true
            }
        }
    };
    if (hasWorkspaceFolderCapability) {
        result.capabilities.workspace = {
            workspaceFolders: {
                supported: true
            }
        };
    }
    return result;
});

connection.onInitialized(() =&gt; {
    if (hasConfigurationCapability) {
        // Register for all configuration changes.
        connection.client.register(DidChangeConfigurationNotification.type, undefined);
    }
    if (hasWorkspaceFolderCapability) {
        connection.workspace.onDidChangeWorkspaceFolders(_event =&gt; {
            connection.console.log('Workspace folder change event received.');
        });
    }
});

// The example settings
interface ExampleSettings {
    maxNumberOfProblems: number;
}

// The global settings, used when the `workspace/configuration` request is not supported by the client.
// Please note that this is not the case when using this server with the client provided in this example
// but could happen with other clients.
const defaultSettings: ExampleSettings = {
    maxNumberOfProblems: 1000
};
let globalSettings: ExampleSettings = defaultSettings;

// Cache the settings of all open documents
let documentSettings: Map &lt; string, Thenable &lt; ExampleSettings &gt;&gt; = new Map();

connection.onDidChangeConfiguration(change =&gt; {
    if (hasConfigurationCapability) {
        // Reset all cached document settings
        documentSettings.clear();
    } else {
        globalSettings = &lt; ExampleSettings &gt; (
            (change.settings.languageServerExample || defaultSettings)
        );
    }

    // Revalidate all open text documents
    documents.all().forEach(validateTextDocument);
});

function getDocumentSettings(resource: string): Thenable &lt; ExampleSettings &gt; {
    if (!hasConfigurationCapability) {
        return Promise.resolve(globalSettings);
    }
    let result = documentSettings.get(resource);
    if (!result) {
        result = connection.workspace.getConfiguration({
            scopeUri: resource,
            section: 'languageServerExample'
        });
        documentSettings.set(resource, result);
    }
    return result;
}

// Only keep settings for open documents
documents.onDidClose(e =&gt; {
    documentSettings.delete(e.document.uri);
});

// The content of a text document has changed. This event is emitted
// when the text document first opened or when its content has changed.
documents.onDidChangeContent(change =&gt; {
    validateTextDocument(change.document);
});

async function validateTextDocument(textDocument: TextDocument): Promise &lt; void &gt; {
    // In this simple example we get the settings for every validate run.
    let settings = await getDocumentSettings(textDocument.uri);

    // The validator creates diagnostics for all uppercase words length 2 and more
    let text = textDocument.getText();
    let pattern = /\b[A-Z]{2,}\b/g;
    let m: RegExpExecArray | null;

    let problems = 0;
    let diagnostics: Diagnostic[] = [];
    while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) {
        problems++;
        let diagnostic: Diagnostic = {
            severity: DiagnosticSeverity.Warning,
            range: {
                start: textDocument.positionAt(m.index),
                end: textDocument.positionAt(m.index + m[0].length)
            },
            message: `${m[0]} is all uppercase.`,
            source: 'ex'
        };
        if (hasDiagnosticRelatedInformationCapability) {
            diagnostic.relatedInformation = [{
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnostic.range)
                    },
                    message: 'Spelling matters'
                },
                {
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnostic.range)
                    },
                    message: 'Particularly for names'
                }
            ];
        }
        diagnostics.push(diagnostic);
    }

    // Send the computed diagnostics to VS Code.
    connection.sendDiagnostics({
        uri: textDocument.uri,
        diagnostics
    });
}

connection.onDidChangeWatchedFiles(_change =&gt; {
    // Monitored files have change in VS Code
    connection.console.log('We received a file change event');
});

// This handler provides the initial list of the completion items.
connection.onCompletion(
    (_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] =&gt; {
        // The pass parameter contains the position of the text document in
        // which code complete got requested. For the example we ignore this
        // info and always provide the same completion items.
        return [{
                label: 'TypeScript',
                kind: CompletionItemKind.Text,
                data: 1
            },
            {
                label: 'JavaScript',
                kind: CompletionItemKind.Text,
                data: 2
            }
        ];
    }
);

// This handler resolves additional information for the item selected in
// the completion list.
connection.onCompletionResolve(
    (item: CompletionItem): CompletionItem =&gt; {
        if (item.data === 1) {
            item.detail = 'TypeScript details';
            item.documentation = 'TypeScript documentation';
        } else if (item.data === 2) {
            item.detail = 'JavaScript details';
            item.documentation = 'JavaScript documentation';
        }
        return item;
    }
);

// Make the text document manager listen on the connection
// for open, change and close text document events
documents.listen(connection);

// Listen on the connection
connection.listen();
</code></pre>
<p>为了实现文档错误诊断功能，我们通过注册<code>documents.onDidChangeContent</code>来获知到纯本文文档发生变化并做校验。启动上述的插件后，我们创建一个文件<code>test.txt</code>：</p>
<pre class="line-numbers"><code class="language-plain_text">TypeScript lets you write JavaScript the way you really want to.
TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.
ANY browser. ANY host. ANY OS. Open Source.
</code></pre>
<p>当我们打开<code>test.txt</code>时效果如下：</p>
<p><figure><img src="media/16843158016742/16853508978861.jpg" alt="" /></figure></p>
<h5><a id="ls%E4%B8%8Elc%E7%9A%84%E8%B0%83%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LS与LC的调试</h5>
<p>对于<code>LC</code>来说，调试比较简单，和普通的插件一样。<code>LS</code>由于是<code>LC</code>启动的，所以我们需要给它绑定一个调试器。我们在<code>run view</code>中选择绑定给<code>LS</code>的<code>launch configuration</code>，这样就完成了调试器的绑定。</p>
<h5><a id="ls%E7%9A%84%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LS的日志服务</h5>
<p>如果<code>LC</code>用的是<code>vscode-languageclient</code>实现，则可以通过配置<code>[langId].trace.server</code>来让<code>LC</code>和<code>LS</code>之间通过LC的名称通道来通信，对于上述示例而言，则是配置<code>&quot;languageServerExample.trace.server&quot;: &quot;verbose&quot;</code>实现</p>
<p><figure><img src="media/16843158016742/16853510024962.jpg" alt="" /></figure></p>
<h5><a id="ls%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LS读取配置</h5>
<p>写<code>LC</code>的时候定义了问题最大上报数量，在<code>LS</code>中是这样读取该配置的：</p>
<pre class="line-numbers"><code class="language-js">function getDocumentSettings(resource: string): Thenable &lt; ExampleSettings &gt; {
    if (!hasConfigurationCapability) {
        return Promise.resolve(globalSettings);
    }
    let result = documentSettings.get(resource);
    if (!result) {
        result = connection.workspace.getConfiguration({
            scopeUri: resource,
            section: 'languageServerExample'
        });
        documentSettings.set(resource, result);
    }
    return result;
}
</code></pre>
<p>用户配置可能会发生变化，为了在<code>LS</code>监听这种变化并在发生变化时重新校验，我们需要将校验代码复用，提取出<code>validateTextDocument</code>函数：</p>
<pre class="line-numbers"><code class="language-js">async function validateTextDocument(textDocument: TextDocument): Promise &lt; void &gt; {
    // In this simple example we get the settings for every validate run.
    let settings = await getDocumentSettings(textDocument.uri);

    // The validator creates diagnostics for all uppercase words length 2 and more
    let text = textDocument.getText();
    let pattern = /\b[A-Z]{2,}\b/g;
    let m: RegExpExecArray | null;

    let problems = 0;
    let diagnostics: Diagnostic[] = [];
    while ((m = pattern.exec(text)) &amp;&amp; problems &lt; settings.maxNumberOfProblems) {
        problems++;
        let diagnostic: Diagnostic = {
            severity: DiagnosticSeverity.Warning,
            range: {
                start: textDocument.positionAt(m.index),
                end: textDocument.positionAt(m.index + m[0].length)
            },
            message: `${m[0]} is all uppercase.`,
            source: 'ex'
        };
        if (hasDiagnosticRelatedInformationCapability) {
            diagnostic.relatedInformation = [{
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnostic.range)
                    },
                    message: 'Spelling matters'
                },
                {
                    location: {
                        uri: textDocument.uri,
                        range: Object.assign({}, diagnostic.range)
                    },
                    message: 'Particularly for names'
                }
            ];
        }
        diagnostics.push(diagnostic);
    }

    // Send the computed diagnostics to VS Code.
    connection.sendDiagnostics({
        uri: textDocument.uri,
        diagnostics
    });
}
</code></pre>
<p>监听代码如下：</p>
<pre class="line-numbers"><code class="language-js">connection.onDidChangeConfiguration(change =&gt; {
    if (hasConfigurationCapability) {
        // Reset all cached document settings
        documentSettings.clear();
    } else {
        globalSettings = &lt; ExampleSettings &gt; (
            (change.settings.languageServerExample || defaultSettings)
        );
    }

    // Revalidate all open text documents
    documents.all().forEach(validateTextDocument);
});
</code></pre>
<p>启动插件，然后将最大报错数量改为1，校验结果可以看到变化：</p>
<p><figure><img src="media/16843158016742/16853510599652.jpg" alt="" /></figure></p>
<h5><a id="%E5%85%B6%E5%AE%83%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其它语言功能</h5>
<p>在<strong>VS Code</strong>中检测工具常以<code>LS</code>的形式实现，如<code>ESLint</code>、<code>jshint</code>，不过除此之外LS还可以实现其它的语言功能，示例中就提供了代码补全：</p>
<pre class="line-numbers"><code class="language-js">// This handler provides the initial list of the completion items.
connection.onCompletion(
    (_textDocumentPosition: TextDocumentPositionParams): CompletionItem[] =&gt; {
        // The pass parameter contains the position of the text document in
        // which code complete got requested. For the example we ignore this
        // info and always provide the same completion items.
        return [{
                label: 'TypeScript',
                kind: CompletionItemKind.Text,
                data: 1
            },
            {
                label: 'JavaScript',
                kind: CompletionItemKind.Text,
                data: 2
            }
        ];
    }
);

// This handler resolves additional information for the item selected in
// the completion list.
connection.onCompletionResolve(
    (item: CompletionItem): CompletionItem =&gt; {
        if (item.data === 1) {
            item.detail = 'TypeScript details';
            item.documentation = 'TypeScript documentation';
        } else if (item.data === 2) {
            item.detail = 'JavaScript details';
            item.documentation = 'JavaScript documentation';
        }
        return item;
    }
);
</code></pre>
<p>用<code>data</code>字段作为补全项的唯一标志，需要能够序列化成<code>JSON</code>。为了代码补全能够运行，还需要在<code>onInitialize</code>函数中作相应的配置：</p>
<pre class="line-numbers"><code class="language-js">connection.onInitialize((params): InitializeResult =&gt; {
    ...
    return {
        capabilities: {
            ...
            // Tell the client that the server supports code completion
            completionProvider: {
                resolveProvider: true
            }
        }
    };
});
</code></pre>
<p><figure><img src="media/16843158016742/16853511418995.jpg" alt="" /></figure></p>
<h4><a id="%E8%BF%9B%E9%98%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶</h4>
<h5><a id="%E5%A2%9E%E9%87%8F%E6%96%87%E6%A1%A3%E5%90%8C%E6%AD%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>增量文档同步</h5>
<p>本文中的示例采用的是<code>vscode-languageserver</code>提供的简单的文档管理器来做<code>VS Code</code>和<code>LS</code>之间的同步，这样做存在两个缺点：</p>
<ul>
<li>大量的数据被传输，因为文本文档的全部内容被重复发送到服务器</li>
<li>不支持增量文档更新，导致多余的解析和语法树创建</li>
</ul>
<p>对此，我们实现的时候应该解决文档增量更新的同步问题。对此需要用到三个钩子函数：</p>
<ul>
<li><code>onDidOpenTextDocument</code>：当文本文档被打开时调用</li>
<li><code>onDidChangeTextDocument</code>：当文本文档的内容发生变化时调用</li>
<li><code>onDidCloseTextDocument</code>：当文本文档被关闭时调用</li>
</ul>
<p>如下是其简单的使用示例：</p>
<pre class="line-numbers"><code class="language-js">connection.onInitialize((params): InitializeResult =&gt; {
    ...
    return {
        capabilities: {
            // Enable incremental document sync
            textDocumentSync: TextDocumentSyncKind.Incremental,
            ...
        }
    };
});

connection.onDidOpenTextDocument((params) =&gt; {
    // A text document was opened in VS Code.
    // params.uri uniquely identifies the document. For documents stored on disk, this is a file URI.
    // params.text the initial full content of the document.
});

connection.onDidChangeTextDocument((params) =&gt; {
    // The content of a text document has change in VS Code.
    // params.uri uniquely identifies the document.
    // params.contentChanges describe the content changes to the document.
});

connection.onDidCloseTextDocument((params) =&gt; {
    // A text document was closed in VS Code.
    // params.uri uniquely identifies the document.
});
</code></pre>
<h5><a id="%E5%AE%B9%E9%94%99%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>容错处理</h5>
<p>绝大多数时间，编辑器里的代码是处于非完全态的、是处于语法错误的状态（如输入中时），但我们希望依然可以实现自动补全等语言功能，因此需要做好错误的兼容处理。<strong>VS Code</strong>官方团队在实现对<code>PHP</code>语言支持的时候，发现官方的<code>PHP</code>解析器不支持错误兼容，没法直接用在<code>LS</code>中，因此<strong>VS Code</strong>官方团队自己实现了一个支持错误兼容的版本 <a href="https://github.com/microsoft/tolerant-php-parser">tolerant-php-parser</a>，并积累了很多关于这方面的细节 <a href="https://github.com/microsoft/tolerant-php-parser/blob/master/docs/HowItWorks.md">HowItWorks</a>，这对想开发<code>LS</code>的人来说很有帮助。</p>
<h2><a id="%E5%8F%91%E5%B8%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发布</h2>
<p>有以下方法使用</p>
<ol>
<li>直接把文件夹发给别人，让别人找到vscode的插件存放目录并放进去，然后重启vscode，一般不推荐；</li>
<li>打包成vsix插件，然后发送给别人安装，如果你的插件涉及机密不方便发布到应用市场，可以尝试采用这种方式；</li>
<li>注册开发者账号，发布到官网应用市场，这个发布和npm一样是不需要审核的。</li>
</ol>
<h3><a id="%E6%9C%AC%E5%9C%B0%E6%89%93%E5%8C%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>本地打包</h3>
<p>无论是本地打包还是发布到应用市场都需要借助vsce这个工具。</p>
<p>安装：<code>npm i vsce -g</code><br />
打包成vsix文件：<code>vsce package</code></p>
<p>生成好的vsix文件不能直接拖入安装，只能从扩展的右上角选择Install from VSIX安装。</p>
<blockquote>
<p><strong>注意</strong>:</p>
<ol>
<li>如果开发期间依赖库使用<code>npm</code>之外的工具加载，如<code>pnpm</code>。需要把<code>node_modules</code>目录删除，重新使用<code>npm install</code>加载依赖。</li>
<li>打包前需要修改<code>README.md</code>文件</li>
<li>可以选择是否配置<code>package.json</code>中的<code>repository</code>参数</li>
<li>可以选择是否配置<code>LICENSE</code></li>
</ol>
</blockquote>
<h3><a id="%E5%8F%91%E5%B8%83%E5%88%B0%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发布到应用市场</h3>
<h4><a id="%E6%B3%A8%E5%86%8C%E8%B4%A6%E5%8F%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注册账号</h4>
<p>访问 <a href="https://login.live.com/">https://login.live.com/</a> 登录你的Microsoft账号，然后访问： <a href="https://aka.ms/SignupAzureDevOps">https://aka.ms/SignupAzureDevOps</a>， 进入组织的主页后，点击右上角的Security。点击创建新的个人访问令牌，这里特别要注意Organization要选择<strong>all accessible organizations</strong>，Scopes要选择<strong>Full access</strong>，否则后面发布会失败。</p>
<h4><a id="%E5%88%9B%E5%BB%BA%E5%8F%91%E5%B8%83%E8%B4%A6%E5%8F%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建发布账号</h4>
<p>获得个人访问令牌后，使用vsce以下命令创建新的发布者：<code>vsce create-publisher your-publisher-name</code></p>
<h4><a id="%E5%8F%91%E5%B8%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发布</h4>
<pre class="line-numbers"><code class="language-plain_text">vsce publish // 发布
vsce publish patch // 增量发布
vsce unpublish (publisher name).(extension name) // 取消发布
</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16853405900025.html" 
          title="Previous Post: Systrace使用">&laquo; Systrace使用</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="16842229324486.html" 
          title="Next Post: Mac生成和查看SSH Key">Mac生成和查看SSH Key &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/16898402251241/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style><script>window.MathJax = {     tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } ,     startup: {     pageReady() {       return MathJax.startup.defaultPageReady().then(function () {          window.mweb_mathjax_ready_val = 'yes';          if(window.mweb_mathjax_ready !== undefined){ mweb_mathjax_ready(); }       });     }   }};document.addEventListener('DOMContentLoaded', function(event) {    if (typeof Prism != 'undefined') {         Prism.highlightAll();     }});window.mweb_mathjax_ready_val = '';function theMWebMathJaxRenderIsReady(key){ return window.mweb_mathjax_ready_val; }</script><script>window.MathJax = { tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } }; </script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
