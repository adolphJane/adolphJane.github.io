<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Kotlin学习笔记 - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>Kotlin学习笔记</h1>
     
        <div class="read-more clearfix">
          <span class="date">2019/10/31</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Android.html'>Android</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <h2 id="toc_0">前言</h2>

<p>Kotlin语言从问世到现在已经有很久的时间了，2017年终于Google将Kotlin列为开发Android应用的一级语言。而且Kotlin和Java具有高度可互操作性，并且相较于Java更加简单，精炼，还添加了Java在Android中尚不支持的一些必备功能。学习Kotlin与时俱进是必须的。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">Kotlin语言基础</h2>

<h3 id="toc_2">变量</h3>

<ul>
<li>var是可写的，在其生命周期中可以被多次赋值</li>
<li>val是只读的，仅能赋值一次</li>
<li>变量类型在大部分情况下无需申明</li>
<li>is 运算符可以对变量的类型进行判断，并且检测之后的分支中可以直接当做该类型使用，无需显式转换</li>
<li>三重引号内可以完整的输出原生字符串的格式</li>
<li>流程控制语句
<ul>
<li>分支语句（if,when）
<ul>
<li>if是一个表达式，可以将代码块的最后一行作为其返回值</li>
<li>如果if表达式只有一个分支，或者分支的结果是Unit，它的值就是Unit</li>
<li>when表达式类似switch-case表达式，可以用任意表达式作为判断条件，也可以检测（in）或者（!in）在一个区间中</li>
</ul></li>
<li>循环语句（for,while）
<ul>
<li>for循环可以对任何提供迭代器的对象进行遍历</li>
<li>for循环通过索引遍历一个数组或者一个list，可以<code>for(i in array.indices) print(array[i])</code></li>
<li>for循环可以使用库函数withIndux操作<code>for((index,value) in array.withIndex()) println(&quot;the element at $index is $value&quot;)</code></li>
</ul></li>
<li>跳转语句（break,continue,return,throw）
<ul>
<li>标签(abc@)可以定义跳转语句，直接跳转到标签位置</li>
</ul></li>
</ul></li>
</ul>

<h3 id="toc_3">修饰符</h3>

<ul>
<li>modifiers
<ul>
<li>(modifier | annotations)*</li>
</ul></li>
<li>typeModifiers
<ul>
<li>(suspendModifier | annotations)*</li>
</ul></li>
<li>modifier
<ul>
<li>classModifier</li>
<li>accessModifier</li>
<li>varianceAnnotation</li>
<li>memberModifier</li>
<li>parameterModifier</li>
<li>typeParameterModifier</li>
<li>functionModifier</li>
<li>propertyModifier</li>
</ul></li>
<li>classModifier 类修饰符
<ul>
<li>abstract 抽象类</li>
<li>final 不可被继承final类</li>
<li>enum 枚举类</li>
<li>open 可继承open类</li>
<li>annotation 注解类</li>
<li>sealed 密封类</li>
<li>data 数据类</li>
</ul></li>
<li>memberModifier
<ul>
<li>override 重写函数</li>
<li>open 可被重写</li>
<li>final 不可被重写</li>
<li>abstract 抽象函数</li>
<li>lateinit 后期初始化</li>
</ul></li>
<li>accessModifier 访问权限控制，默认是public
<ul>
<li>private</li>
<li>protected</li>
<li>public</li>
<li>internal</li>
</ul></li>
<li>varianceAnnotation 泛型可变类
<ul>
<li>in</li>
<li>out</li>
</ul></li>
<li>parameterModifier
<ul>
<li>noinline</li>
<li>crossinline</li>
<li>vararg 变长参数</li>
</ul></li>
<li>typeParameterModifier
<ul>
<li>reified</li>
</ul></li>
<li>functionModifier
<ul>
<li>tailrec 尾递归</li>
<li>operator</li>
<li>infix</li>
<li>inline</li>
<li>external</li>
<li>suspendModifier</li>
</ul></li>
<li>propertyModifier
<ul>
<li>const</li>
</ul></li>
<li>suspendModifier
<ul>
<li>suspend</li>
</ul></li>
</ul>

<h3 id="toc_4">关键字</h3>

<h4 id="toc_5">this关键字</h4>

<ul>
<li>在类的成员中，this指的是该类的对象</li>
<li>在扩展函数或者带接收者的函数字面值中，this表示在点左侧传递的接收者参数</li>
<li>在内部类中，它指的是最内层的包含它的作用域，如果我们想要引用其他作用域中的this，可以使用this@lable标签</li>
</ul>

<h4 id="toc_6">super关键字</h4>

<ul>
<li>super关键字持有指向其父类的引用</li>
</ul>

<h3 id="toc_7">操作符</h3>

<ul>
<li><p>重载操作符</p>
<ul>
<li>重载操作符的函数需要用operator修饰符标记</li>
<li>中缀操作符的函数使用infix修饰符标记 </li>
</ul></li>
<li><p>相等与不相等操作符</p>
<ul>
<li>引用相等 === !== ( 两个引用指向同一个对象 ) 如果a和b指向同一个对象，则a===b为true</li>
<li>结构相等 == != （ 使用equals()判断 ）<code>a==b --&gt; a?.equals(b)?:(b===null)</code></li>
</ul></li>
<li><p>Elvis操作符?:（二元运算符）</p>
<ul>
<li>Elvis操作符特定是跟null比较，主要用来作null安全检查。</li>
<li>Kotlin没有<code>true?1:0</code>三元运算符，取而代之是<code>if(true) 1 else 0</code></li>
</ul></li>
</ul>

<h3 id="toc_8">扩展函数和扩展属性</h3>

<ul>
<li>扩展函数
<ul>
<li><code>fun String.notEmpty():Boolean { return !this.isEmpty()}</code></li>
<li>this关键字在扩展函数内部对应到接收者对象</li>
</ul></li>
<li>扩展属性
<ul>
<li>扩展没有实际的将成员插入类中，它的行为只能由显式提供的getters/setters表示</li>
</ul></li>
</ul>

<h3 id="toc_9">空指针安全</h3>

<ul>
<li><code>?.</code>安全调用
<ul>
<li>如果变量为null，则返回null。</li>
</ul></li>
<li><code>!!.</code>非空断言调用
<ul>
<li>如果变量为null，则抛出kotlin.KotlinNullPointerException异常</li>
</ul></li>
</ul>

<h3 id="toc_10">标准库API</h3>

<h4 id="toc_11">Java和JS共用的公共库</h4>

<table>
<thead>
<tr>
<th style="text-align: left">包名</th>
<th style="text-align: left">功能说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">kotlin</td>
<td style="text-align: left">核心函数和数据类型，支持所有平台</td>
</tr>
<tr>
<td style="text-align: left">kotlin.annotation</td>
<td style="text-align: left">为kotlin注解功能提供支持</td>
</tr>
<tr>
<td style="text-align: left">kotlin.collections</td>
<td style="text-align: left">集合类型，入Iterable、Collection、List、Set、Map等</td>
</tr>
<tr>
<td style="text-align: left">kotlin.comparisons</td>
<td style="text-align: left">帮助函数用于创建Comparator比较器实例</td>
</tr>
<tr>
<td style="text-align: left">kotlin.coroutines.experimental(1.1)</td>
<td style="text-align: left">支持协程，包括支持延迟序列(lazy sequence)等</td>
</tr>
<tr>
<td style="text-align: left">kotlin.coroutines.experimental.intrinsics(1.1)</td>
<td style="text-align: left">基于协程的API库的底层构建块</td>
</tr>
<tr>
<td style="text-align: left">kotlin.experimental(1.1)</td>
<td style="text-align: left">实验API，将来版本可能会改变</td>
</tr>
<tr>
<td style="text-align: left">kotlin.io</td>
<td style="text-align: left">IO API用于处理文件和流</td>
</tr>
<tr>
<td style="text-align: left">kotlin.properties</td>
<td style="text-align: left">代理/委托属性的标准实现，帮助函数实现自定义代理/委托</td>
</tr>
<tr>
<td style="text-align: left">kotlin.ranges</td>
<td style="text-align: left">范围/区间，数列Progressions和相关扩展功能</td>
</tr>
<tr>
<td style="text-align: left">kotlin.reflect</td>
<td style="text-align: left">Kotlin反射的运行时API</td>
</tr>
<tr>
<td style="text-align: left">kotlin.sequences</td>
<td style="text-align: left">序列类型表示延迟求值的集合、实例化序列和扩展函数</td>
</tr>
<tr>
<td style="text-align: left">kotlin.text</td>
<td style="text-align: left">处理文本和正则表达式的函数</td>
</tr>
</tbody>
</table>

<h4 id="toc_12">Java平台的Kotlin库</h4>

<table>
<thead>
<tr>
<th style="text-align: left">包名</th>
<th style="text-align: left">功能说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">kotlin.concurrent</td>
<td style="text-align: left">并发（concurrent）编程Kotlin函数库</td>
</tr>
<tr>
<td style="text-align: left">kotlin.jvm</td>
<td style="text-align: left">Java平台特有的函数和注解</td>
</tr>
<tr>
<td style="text-align: left">kotlin.reflect.full(1.1)</td>
<td style="text-align: left">Kotlin反射库的扩展Extensions</td>
</tr>
<tr>
<td style="text-align: left">kotlin.reflect.jvm</td>
<td style="text-align: left">Kotlin与Java反射的互操作运行时API</td>
</tr>
<tr>
<td style="text-align: left">kotlin.streams(1.1,JRE8)</td>
<td style="text-align: left">处理Java8流的Kotlin函数库</td>
</tr>
<tr>
<td style="text-align: left">kotlin.system</td>
<td style="text-align: left">与系统相关的Kotlin函数库</td>
</tr>
</tbody>
</table>

<h4 id="toc_13">JavaScript平台的Kotlin库</h4>

<table>
<thead>
<tr>
<th style="text-align: left">包名</th>
<th style="text-align: left">功能说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">kotlin.browser</td>
<td style="text-align: left">在浏览器环境下访问顶层属性（如document、Window等）</td>
</tr>
<tr>
<td style="text-align: left">kotlin.dom</td>
<td style="text-align: left">处理浏览器DOM的Kotlin函数库</td>
</tr>
<tr>
<td style="text-align: left">kotlin.js</td>
<td style="text-align: left">JavaScript平台特有的一些函数和API</td>
</tr>
<tr>
<td style="text-align: left">org.khronos.webgl</td>
<td style="text-align: left">WebGL API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom</td>
<td style="text-align: left">DOM API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.css</td>
<td style="text-align: left">DOM CSS API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.events</td>
<td style="text-align: left">DOM events API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.parsing</td>
<td style="text-align: left">DOM parsing API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.svg</td>
<td style="text-align: left">DOM SVG API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.url</td>
<td style="text-align: left">DOM URL API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.xhr</td>
<td style="text-align: left">XML HttpRequest API 的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.files</td>
<td style="text-align: left">W3C file API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.notifications</td>
<td style="text-align: left">Web Notification API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.performance</td>
<td style="text-align: left">Navigation Timing API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.workers</td>
<td style="text-align: left">Web Workers API的Kotlin包装器</td>
</tr>
</tbody>
</table>

<h2 id="toc_14">基本数据类型与类型系统</h2>

<p>Kotlin是一门强类型、静态类型、支持隐士类型的显式类型语言。</p>

<ul>
<li>强类型：在运行时确保不会发生未经明确转换的类型转换。（一个语言的编译器引入越多的类型检查的限制，就可以称这个语言的类型检查越强）</li>
<li>静态类型：静态类型检查能让很多bug在编码早期就被捕捉到，并且它也能优化运行。（类型检查可发生在编译时期（静态检查）或运行时期（动态检查））</li>
<li>显式类型：定义变量时显式给出变量的类型（根据变量名是否需要显式给出类型的声明，分为显式类型语言和隐式类型语言）</li>
</ul>

<h3 id="toc_15">根类型 Any</h3>

<p>Kotlin中所有类都有一个共同的超类Any，同Java中java.lang.Object</p>

<h3 id="toc_16">基本类型</h3>

<p>Kotlin中一切皆是对象，所有类型都是引用类型。</p>

<h4 id="toc_17">数字类型（Number）</h4>

<table>
<thead>
<tr>
<th style="text-align: left">类型</th>
<th style="text-align: left">宽度(Bit)</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Double</td>
<td style="text-align: left">64</td>
</tr>
<tr>
<td style="text-align: left">Float</td>
<td style="text-align: left">32</td>
</tr>
<tr>
<td style="text-align: left">Long</td>
<td style="text-align: left">64</td>
</tr>
<tr>
<td style="text-align: left">Int</td>
<td style="text-align: left">32</td>
</tr>
<tr>
<td style="text-align: left">Short</td>
<td style="text-align: left">16</td>
</tr>
<tr>
<td style="text-align: left">Byte</td>
<td style="text-align: left">8</td>
</tr>
</tbody>
</table>

<ul>
<li>这些内置的数据类型，都继承了Number和Comparable类。</li>
<li>Kotlin的数字类型与Java基本相同。但Kotlin对于数字没有隐式拓宽转换（如Java中int可以隐式转换为long），因为值范围较小类型并不是较大类型的子类型。</li>
<li>val i: Int = b.toInt()
<ul>
<li>toDouble() : Double</li>
<li>toFloat() : Float</li>
<li>toLong() : Long</li>
<li>toInt() : Int</li>
<li>toChar() : Char</li>
<li>toShort() : Short</li>
<li>toByte() : Byte</li>
</ul></li>
<li>位运算，没有特殊字符来表示，只可用中缀方式调用命名函数</li>
</ul>

<p>位运算列表（只用于Int和Long）</p>

<ul>
<li>shl(bits)————有符号左移（Java的&lt;&lt;）</li>
<li>shr(bits)————有符号右移（Java的&gt;&gt;）</li>
<li>ushr(bits)————无符号右移（Java的&gt;&gt;&gt;）</li>
<li>and(bits)————位与</li>
<li>or(bits)————位或</li>
<li>xor(bits)————位异或</li>
<li>inv()————位非</li>
</ul>

<h4 id="toc_18">布尔类型</h4>

<ul>
<li>！逻辑非：not()</li>
<li>&amp;&amp;短路逻辑与：and()</li>
<li>||短路逻辑或：or()</li>
<li>异或（相同false，不同true）：xor</li>
</ul>

<h4 id="toc_19">字符串类型</h4>

<ul>
<li>索引运算符s[i]： 字符串元素————字符可以使用索引运算符s[i]来访问</li>
<li>for循环迭代字符串</li>
<li>字符串类重载了+操作符，作用对象可以是任何对象，包括null</li>
<li>截取字符串的子串（subSequence(0,1)）</li>
<li>trimMargin(marginPrefix:String = &quot;|&quot;):去除默认为边界字符为&quot;|&quot;的前导空格</li>
<li>trimIndent():把字符串行左边空白对齐切割</li>
<li>以美元符(\()开头做字符串模板:`val str = &quot;\)s.length is ${s.length}&quot;`</li>
</ul>

<h4 id="toc_20">数组类型</h4>

<ul>
<li>数组在Kotlin中使用Array类表示，定义了get和set函数以及size属性。<br/></li>
<li>可以使用arrayOf()来创建一个数组并传递元素值给Array</li>
<li>Kotlin还允许不同类型元素放到一个数组中</li>
<li>arrayOfNulls()可以用于创建一个指定大小、元素都为空的数组。这个特殊的空数组在创建时，需要指定元素的类型。<code>arrayOfNulls&lt;Int&gt;(10)</code></li>
<li>数组Array类还提供了一个构造函数<code>public inline constructor(size:Int,init:(Int) -&gt; T)</code>  例：<code>val square = Array(10,{i -&gt; (i*i)})</code></li>
<li>[]运算符代表调用成员函数get()和set()</li>
<li>原生数组类型
<ul>
<li>BooleanArray ———— booleanArrayOf(vararg elements: Boolean)</li>
<li>ByteArray ———— byteArrayOf(vararg elements: Byte)</li>
<li>CharArray ———— charArrayOf(vararg elements: Char)</li>
<li>ShortArray ———— shortArrayOf(vararg elements: Short)</li>
<li>IntArray ———— intArrayOf(vararg elements: Int)</li>
<li>LongArray ———— longArrayOf(vararg elements: Long)</li>
<li>FloatArray ———— floatArrayOf(vararg elements: Float)</li>
<li>DoubleArray ———— doubleArrayOf(vararg elements: Double)</li>
</ul></li>
</ul>

<h3 id="toc_21">可空类型</h3>

<ul>
<li>null 是 Nothing? 类型的</li>
<li>Any?是Kotlin的类型层次结构的最顶端</li>
</ul>

<h3 id="toc_22">Kotlin.Unit类型</h3>

<p>Kotlin中的Unit类型实现了与Java中的void一样的功能。当一个函数没有返回值时，我们用Unit来实现这个特征，而不是null</p>

<h3 id="toc_23">kotlin.Nothing类型</h3>

<p>在Kotlin类型层次结构的最底层就是类型Nothing</p>

<h3 id="toc_24">类型检测与类型转换</h3>

<h4 id="toc_25">is与!is运算符</h4>

<ul>
<li>is运算符类似于Java的instanceOf，用来检查对象是否属于某数据类型</li>
<li>is会自动对对象的数据类型进行安全的转换</li>
</ul>

<h4 id="toc_26">as运算符</h4>

<ul>
<li>as运算符用于执行引用类型的显式类型转换。如果兼容则转换成功，否则as?运算符返回null，as抛出异常</li>
</ul>

<h2 id="toc_27">集合类</h2>

<p>世间本无集合；<br/><br/>
有人想要，于是就用数组创造了集合类；<br/><br/>
有人想要可以自动扩展容量的数组，于是有了List；<br/><br/>
有人想要元素不重复的数组，于是有了Set；<br/><br/>
有人想要有序的数组，于是有了TreeSet，TreeList；<br/><br/>
有人想要通过复杂对象来查找另一个对象的关联数组，于是有了Map；</p>

<ul>
<li>几乎所有集合都是基于数组来实现的，所以数组比集合要快</li>
<li>集合是数组的高层次的抽象封装，集合的功能比数组要多</li>
<li>Kotlin集合类分为：可变集合类(Mutable)和不可变集合类(Immutable)</li>
<li>集合类型主要有3种：list(列表)、set(集)、map(映射)</li>
</ul>

<h3 id="toc_28">List</h3>

<p>List接口继承与Collectio接口，元素以线性方式存储，集合中可以存放重复对象。</p>

<ul>
<li><strong>不可变集合类List(ReadOnly,Immutable)</strong>:
<ul>
<li>使用listOf()函数来创建没有元素的空List</li>
<li>使用listOf(element: T)函数来创建只有一个元素的List</li>
<li>使用listOf(vararg elements: T)函数来创建有多个元素的List</li>
<li>asList()是Array的扩展函数</li>
<li>arrayListOf()函数可以直接创建一个Java中的ArrayList对象实例</li>
</ul></li>
<li><strong>可变集合MutableList</strong>
<ul>
<li>新增了add/addAll,remove/removeAll/removeAt,set,clear,retainAll</li>
<li>mutableListOf()函数来创建</li>
<li>mutableListOf()函数和直接使用arrayListOf()函数一样都是创建了一个ArrayList类</li>
<li>不可变的List可以通过调用转换函数toMutableList()来将其转换成可变的List</li>
</ul></li>
<li><strong>遍历List元素</strong>
<ul>
<li>使用Iterator迭代器（Kotlin中的Iterator功能比较简单，并且只能单向移动）
<ul>
<li>调用iterator()函数，容器返回一个Iterator实例</li>
<li>调用hasNext()函数检查序列中是否还有元素</li>
<li>第一次调用next()函数，返回序列的第一个元素，依次向后递推   - 使用forEach遍历List元素</li>
<li><code>list.forEach({println(it)})</code> </li>
</ul></li>
</ul></li>
<li><strong>List元素操作函数</strong>
<ul>
<li>add/remove 是MutableList的
<ul>
<li>添加一个元素<code>mutableList.add(4)</code></li>
<li>在下标为0的位置添加元素0<code>mutableList.add(0,0)</code></li>
<li>删除元素1<code>mutableList.remove(1)</code></li>
<li>删除下标为1的元素<code>mutableList.removeAt(1)</code></li>
<li>删除子集合<code>mutableList.removeAll(listOf(3,4))</code></li>
<li>添加子集合<code>mutableList.addAll(listOf(1,2,3))</code></li>
</ul></li>
<li>set/clear操作
<ul>
<li>更新设置下标为0的元素值为100<code>mutableList.set(0,100)</code></li>
<li>清空集合<code>mutableList.clear()</code></li>
<li>把可变集合转为不可变集合<code>mutableList.toList()</code></li>
</ul></li>
<li><code>retainAll</code>
<ul>
<li>取两个集合交集<code>mList1.retainAll(mList2)</code></li>
</ul></li>
<li><code>contains(element:T) Boolean</code>
<ul>
<li>判断集合中是否有指定元素<code>list.contains(1)</code></li>
</ul></li>
<li><code>elementAt(index: Int): T</code>
<ul>
<li>查找下标对应的元素<code>list.elementAt(6)</code></li>
<li>查找下标对应元素，如果越界根据方法返回默认值<code>list.elementAtOrElse(7,{0})</code></li>
<li>查找下标对应元素，如果越界就返回null<code>list.elementAtOrNull(7)</code></li>
</ul></li>
<li><code>first()</code>
<ul>
<li>返回集合第一个元素，如果是空集，抛出异常 <code>list.first()</code></li>
<li>对应的有针对异常处理的函数firstOrNull():T? <code>emptyList.firstOrNull()</code></li>
<li>返回符合条件的第一个元素，没有则抛出异常 <code>list.first(it % 2 == 0)</code></li>
<li>对应的有针对异常处理的函数firstOrNull(oerducate:(T)-&gt;Boolean):T?返回符合条件的第一个元素，没有就返回nul<code>list.firstOrNull({it &gt; 100})</code></li>
</ul></li>
<li><code>indexOf(element: T): Int</code>
<ul>
<li>返回指定下标的元素，没有就返回-1 <code>list.indexOf(&quot;c&quot;)</code></li>
</ul></li>
<li><code>indexOfFirst(predicate:(T) -&gt; Boolean):Int</code>
<ul>
<li>返回第一个符合条件的元素下标，没有就返回-1 <code>list.indexOfFirst({it.contains(&quot;x&quot;)})</code></li>
</ul></li>
<li><code>indexOfLast(predicate:(T) -&gt; Boolean):Int</code>
<ul>
<li>返回最后一个符合条件的元素下标，没有就返回-1 <code>list.indexOfLast(it.contains(&quot;k&quot;))</code></li>
</ul></li>
<li><code>last()</code>
<ul>
<li>返回集合最后一个元素，空集抛出异常 <code>list.last()</code></li>
</ul></li>
<li><code>last(predicate:(T) -&gt; Boolean): T</code>
<ul>
<li>返回符合条件的最后一个元素，没有就抛出异常 <code>list.last({it &gt; 10})</code></li>
<li>对应的针对越界处理的lastOrNull函数，返回符合条件的最后一个元素，没有则返回null <code>list.lastOrNull({it &gt; 10})</code></li>
</ul></li>
<li><code>lastIndexOf(element: T): Int</code>
<ul>
<li>返回符合条件的最后一个元素，没有就返回-1 <code>list.lastIndexOf(&quot;abc&quot;)</code></li>
</ul></li>
<li><code>single(): T</code>
<ul>
<li>该集合如果只剩下一个元素，则返回该元素，否则抛出异常 <code>list.single()</code></li>
</ul></li>
<li><code>single(predicate: (T) -&gt; Boolean): T</code>
<ul>
<li>返回符合条件的单个元素，否则抛出异常，或超过一个的抛异常 <code>list.single({it == 1})</code></li>
<li>对应的针对越界处理的singleOrNull函数，返回符合条件的单个元素，否则返回null <code>list.singleOrNull({it == 7})</code></li>
</ul></li>
</ul></li>
<li><strong>List集合的基本运算函数</strong>
<ul>
<li><code>any()</code>
<ul>
<li>判断该元素至少有一个元素 <code>list.any()</code></li>
</ul></li>
<li><code>any(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>判断集合中是否有满足条件的元素 <code>list.any({list &gt; 4})</code></li>
</ul></li>
<li><code>all(predicate: (T) -&gt; Boolean)</code>
<ul>
<li>判断集合中的元素是否都满足条件，当且仅当该集合中的所有元素都满足条件时，返回true。 <code>list.all({it &gt; 2})</code></li>
</ul></li>
<li><code>none()</code>
<ul>
<li>判断集合无元素，该集合没有任何元素，返回true <code>list.none()</code></li>
</ul></li>
<li><code>none(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>判断集合中所有元素都不满足条件 <code>list.none({it % 2 == 1})</code></li>
</ul></li>
<li><code>count()</code>
<ul>
<li>计算集合中的元素的个数 <code>list.count()</code></li>
</ul></li>
<li><code>count(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>计算集合中满足条件的元素的个数 <code>list.count({it % 2 == 0})</code></li>
</ul></li>
<li><code>reduce</code>
<ul>
<li>从第一想到最后一项进行累计运算，首先把第一个元素赋值给累加子accumulator,然后逐次向后取元素累加，新值继续赋值给累加子accumulator = operation(accumulator,iterator.next())，依次类推，最后返回累加子的值 <code>list.reduce({total,s -&gt; total + s})</code></li>
</ul></li>
<li><code>reduceRight</code>
<ul>
<li>从最后一项到第一项进行累计运算，从右边累计运算的累加子是放在后面的 <code>list.reduceRight({total,s -&gt; s + total})</code></li>
</ul></li>
<li><code>fold(initial:R,operation:(acc:R,T)-&gt;R):R</code>
<ul>
<li>是带初始值的reduce，fold函数给累加子赋了初始值initial <code>list.fold(100,{total,next -&gt; next + total})</code></li>
<li>foldRight 和 reduceRight类似，有初始值</li>
</ul></li>
<li><code>forEach(action:(T) -&gt; Unit):Unit</code>
<ul>
<li>循环遍历元素，元素是it <code>list.forEach{value -&gt; if (value &gt; 7) println(value)}</code></li>
</ul></li>
<li><code>forEachIndexed</code>
<ul>
<li>带index(下标)的元素遍历 <code>list.forEachIndexed(index,value -&gt; if(value &gt; 8) println(&quot;value of index $index is $value,greater than 8&quot;))</code></li>
</ul></li>
<li><code>max</code>、<code>min</code>
<ul>
<li>查询最大、最小的元素，空集返回null <code>list.max()</code></li>
</ul></li>
<li><code>maxBy(selector:(T)-&gt;R):T?、minBy(selector:(T)-&gt;R):T?</code>
<ul>
<li>获取函数映射结果的最大值、最小值对应的那个元素的值，如果没有则返回null。是通过selector函数的返回值来比较大小，获取最终的最大值和最小值。 <code>list.maxBy({it * (1 - it)})</code></li>
</ul></li>
<li><code>sumBy(selector:(T) -&gt; Int):Int</code>
<ul>
<li>获取函数映射值的总和 <code>list.sumBy({it * it})</code></li>
</ul></li>
</ul></li>
<li>过滤操作函数
<ul>
<li><code>take(n:Int):List&lt;T&gt;</code>
<ul>
<li>挑出该集合前n个元素的子集合，如果n=0，返回空集，如果n大于集合size，返回该集合。<code>list.take(10)</code></li>
</ul></li>
<li><code>takeWhile(predicate:(T) -&gt; Boolean):List&lt;T&gt;</code>
<ul>
<li>挑出满足条件的元素的子集合，从第一个元素开始，判断是否满足predicate为true，如果满足条件的元素就丢到返回ArrayList中，只要遇到任何一个不满足条件，就结束循环，返回list。 <code>list.takeWhile({it % 2 == 0})</code></li>
<li><code>takeLast</code>
<ul>
<li>挑出最后n个元素的子集合，从集合倒数n个元素起，取出到最后一个元素的子集合。如果传入0，返回空集。如果传入n大于集合size，返回整个集合。如果传入负数，抛出异常。<code>list.takeLast(2)</code></li>
</ul></li>
</ul></li>
<li><code>takeLastWhile(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>从最后开始挑出满足条件元素的子集合。反向取满足条件的元素，遇到不满足的元素，直接终止循环，并返回子集合。 <code>list.takeLastWhile({it % 2 == 0})</code></li>
</ul></li>
<li><code>drop(n:Int)</code>
<ul>
<li>去除前n个元素返回剩下的元素的子集合 <code>list.drop(5)</code></li>
</ul></li>
<li><code>dropWhile(predicate:(T)-&gt;Boolean)</code>
<ul>
<li>去除满足条件的元素返回剩下的元素的子集合。去除满足条件的元素，当遇到一个不满足条件的元素时，中止操作，返回剩下的元素子集合。 <code>list.dropWhile({it % 2 == 0})</code></li>
</ul></li>
<li><code>dropLast(n:Int)</code>
<ul>
<li>从最后去除n个元素 <code>list.dropLast(3)</code></li>
</ul></li>
<li><code>dropLastWhile(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>从最后去除满足条件的元素 <code>list.dropLastWhile({it % 2 == 0})</code></li>
</ul></li>
<li><code>slice(indices:IntRange)</code>
<ul>
<li>取开始下标至结束下标元素子集合 <code>list.slice(1..3)</code></li>
</ul></li>
<li><code>slice(indices:Iterable&lt;Int&gt;)</code>
<ul>
<li>返回指定下标的元素子集合 <code>list.slice(listOf(2,4,6))</code></li>
</ul></li>
<li><code>filterTo(destination:C,predicate:(T) -&gt; Boolean)</code>
<ul>
<li>过滤出满足条件的元素并赋值给destination。把满足过滤条件的元素组成的子集合赋值给入参destination。 <code>list.filterTo(dest,{it &gt; 3})</code></li>
</ul></li>
<li><code>filter(predicate:(T)-&gt;Boolean)</code>
<ul>
<li>过滤出满足条件的元素组成的子集合。相对于filterTo函数，filter函数更加简单易用。 <code>list.filter({it &gt; 3})</code></li>
</ul></li>
<li><code>filterNot(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>用来过滤所有不满足条件的元素</li>
</ul></li>
<li><code>filterNotNull()</code>
<ul>
<li>过滤掉null元素</li>
</ul></li>
</ul></li>
<li><strong>映射操作函数</strong>
<ul>
<li><code>map(transform:(T)-&gt;R):List&lt;R&gt;</code>
<ul>
<li>将集合中的元素通过转换函数transform映射后的结果，存到一个集合中返回。 <code>list.map({it * it})</code></li>
</ul></li>
<li><code>mapIndexed(transform:(kotlin.Int,T) -&gt; R)</code>
<ul>
<li>转换函数transform中带有下标参数。可以同时使用下标和元素的值来进行转换。 <code>list.mapIndexed({index,it -&gt; index * it})</code></li>
</ul></li>
<li><code>mapNotNull(transform:(T) -&gt; R?)</code>
<ul>
<li>遍历集合每个元素，得到通过函数算子transform映射之后的值，剔除掉这些值中的null，返回一个无null元素的集合。 <code>list.mapNotNull({it})</code> </li>
</ul></li>
<li><code>flatmap(transform:(T)-&gt;Iterable&lt;R&gt;):List&lt;R&gt;</code>
<ul>
<li>在原始集合的每个元素上调用transform转换函数，得到的映射结果组成的单个列表。与map相比，使用map是把list中的每一个元素都映射成一个List-n,然后以这些List-n为元素，组成一个大的嵌套的List返回。而使用flatMap则是把list中的第一个元素映射成一个List1，然后把第二个元素映射成的List2跟List1合并，最终返回一个扁平的List。</li>
</ul></li>
</ul></li>
<li><strong>分组操作函数</strong>
<ul>
<li>groupBy(keySelector:(T) -&gt; K):Map<K,List<T>&gt;
<ul>
<li>将集合中的元素按照条件选择器keySelector分组，并返回Map。<code>words.groupBy({it.length},{it.contains(&quot;b&quot;)})</code></li>
</ul></li>
<li>groupingBy(crossinline keySelector:(T)-&gt;K):Grouping<T,K>
<ul>
<li>可以通过该函数来创建一个Grouping,然后调用计数函数eachCount统计分组 <code>words.groupingBy({it.first()}).eachCount()</code></li>
</ul></li>
</ul></li>
<li><strong>排序操作符</strong>
<ul>
<li><code>reversed():List&lt;T&gt;</code>
<ul>
<li>倒序排列集合元素 <code>list.reversed()</code></li>
</ul></li>
<li><code>sorted</code>和<code>sortedDescending</code>
<ul>
<li>升序排序和降序排序 <code>list.sorted</code></li>
</ul></li>
<li><code>sortedBy</code>和<code>sortedByDescending</code>
<ul>
<li>可变集合MutableList的排序操作，根据函数映射的结果进行升序排序和降序排序 <code>mlist.sortBy({it.length})</code></li>
</ul></li>
</ul></li>
<li><strong>生产操作符</strong>
<ul>
<li><code>zip(other:Iterable&lt;R&gt;):List&lt;Pair&lt;T,R&gt;&gt;</code>
<ul>
<li>两个集合按照下标配对，组合成的每个Pair作为新的List集合中的元素，并返回。如果两个集合长度不一样，取短的长度。 <code>list1.zip(list2)</code></li>
</ul></li>
<li><code>partition(predicate:(T)-&gt;Boolean:Pair&lt;List&lt;T&gt;,List&lt;T&gt;&gt;)</code>
<ul>
<li>根据判断条件是否成立，将集合拆分成两个子集合组成的Pair。 <code>list.partition({it &gt; 5})</code></li>
</ul></li>
<li><code>plus(elements:Iterable&lt;T&gt;):List&lt;T&gt;</code>
<ul>
<li>合并两个List，这是一个操作符函数，可以用“+”代替。 <code>list.plus(list2)</code> , <code>list1+list2</code></li>
</ul></li>
<li><code>list.plusElement(element:T):List&lt;T&gt;</code>
<ul>
<li>在集合中添加一个元素。 <code>list.plusElement(10)</code> , <code>list.plus(10)</code></li>
</ul></li>
</ul></li>
</ul>

<h3 id="toc_29">Set</h3>

<p>含有不可变Set和可变MutableSet(支持添加和删除)</p>

<ul>
<li><strong>空集</strong>
<ul>
<li>空集继承了Serializable，表明是可被序列化的。它的size是0，isEmpty()返回true，hashCode()是0。</li>
</ul></li>
<li><strong>创建Set</strong>
<ul>
<li><code>setOf(vararg elements:T):Set&lt;T&gt;</code> 
<ul>
<li>使用元素elements创建一个Set。Set中的元素是不可重复的。<code>toSet()</code>是Array类的扩展函数，可以将Array类转变为Set。</li>
<li>使用<code>toSet()</code>可以对List去重。</li>
<li>使用<code>emptySet&lt;Int&gt;()</code>和<code>setOf()</code>来创建空集</li>
</ul></li>
<li><code>mutableSetOf():MutableSet&lt;T&gt;</code>
<ul>
<li>创建一个可变的Set</li>
</ul></li>
</ul></li>
<li><strong>使用Java中的Set类</strong>
<ul>
<li><code>hashSetOf</code>       ——  java.util.HashSet 该类按照哈希算法来存取集合中的对象，存取速度较快</li>
<li><code>linkedSetOf()</code>   ——  java.util.LinkedHashSet </li>
<li><code>mutableSetOf()</code>  ——  java.util.LinkedHashSet 具有HashSet的查询速度，且内部使用链表维护元素的顺序，在对Set元素进行频繁插入，删除的场景中使用</li>
<li><code>sortedSetOf()</code>   ——  java.util.TreeSet 该类实现了SortedSet接口，能够对集合中的对象进行排序</li>
</ul></li>
<li><strong>Set元素中的加减操作plus minus</strong>
<ul>
<li>针对Set做了一些加减运算的扩展函数。 <code>val ms = mutableSetOf(1,3,4,7)</code> , <code>ms + 10</code> , <code>ms - 1</code></li>
</ul></li>
</ul>

<h3 id="toc_30">Map</h3>

<p>Map是一种把键对象Key和值对象Value映射的集合。它的每一个元素都包含一对键对象和值对象。  Key可以看成是Value的索引，作为key的对象在集合中不可重复。<br/><br/>
Map和Set、List一样，Map也分为只读Map和可变的MutableMap。  </p>

<ul>
<li><strong>创建Map</strong>
<ul>
<li>HashMap HashMap是基于哈希表的Map接口的实现，系统会根据hash算法来计算key-value的存储位置，可以通过key快速地存取value。它允许使用null值和null键。</li>
<li>TreeMap 使用红黑二叉树的Map接口</li>
<li>LinkedHashMap 使用链表实现，保存了记录的插入顺序。</li>
<li><code>mapOf()</code>
<ul>
<li>创建一个只读空Map <code>mapOf&lt;String,Int&gt;()</code> 和 <code>emptyMap&lt;String,Int&gt;()</code>。</li>
</ul></li>
<li><code>mapOf(pair:Pair&lt;K,V&gt;):Map&lt;K,V&gt;</code>
<ul>
<li>使用二元组Pair创建一个只读Map <code>mapOf(1 to &quot;x&quot;,2 to &quot;y&quot;,3 to &quot;z&quot;)</code></li>
<li><code>map.get(1)</code></li>
<li><code>map.size</code></li>
<li><code>map.entries</code></li>
</ul></li>
<li><code>mutableMapOf()</code>
<ul>
<li>创建一个空的可变的Map，该函数是直接调用的LinkedHashMap()构造函数</li>
</ul></li>
<li><code>mutableMapOf(vararg pairs:Pair&lt;K,V&gt;):MutableMap&lt;K,V&gt;</code>
<ul>
<li>创建一个可编辑的MutableMap对象。如果有重复的key键，后面的会直接覆盖掉前面的</li>
</ul></li>
<li><code>hashMapOf():HashMap&lt;K,V&gt;</code>
<ul>
<li>创建HashMap对象</li>
</ul></li>
<li><code>linkedMapOf():LinkedHashMap&lt;K,V&gt;</code>
<ul>
<li>创建空对象LinkedHashMap</li>
</ul></li>
<li><code>linkedMapOf(vararg pairs:Pair&lt;K,V&gt;):LinkedHashMap&lt;K,V&gt;</code>
<ul>
<li>创建带二元组Pair元素的LinkedHashMap对象</li>
</ul></li>
<li><code>sortedMapOf(vararg pairs:Pair&lt;K,V&gt;):SortedMap&lt;K,V&gt;</code>
<ul>
<li>创建一个根据Key升序排序好的TreeMap</li>
</ul></li>
</ul></li>
<li><strong>访问Map的元素</strong>
<ul>
<li>Map的元素包含的属性有entries、keys、values size，还有一个操作符Map.get(key),等同于使用Map[Key]
<ul>
<li>entries属性 可直接访问entries属性</li>
<li>keys 属性</li>
<li>values 属性</li>
<li>size 属性</li>
<li>get(key:K)——对应的操作符的<code>[]</code>。如果这个key不在Map中，就返回null。如果不想返回null，可以使用<code>getOrDefault</code>函数</li>
</ul></li>
</ul></li>
<li><strong>Map操作函数</strong>
<ul>
<li><code>containsKey(key:K):Boolean</code>
<ul>
<li>是否包含该key</li>
</ul></li>
<li><code>containsValue(value:V):Boolean</code>
<ul>
<li>是否包含该value</li>
</ul></li>
<li><code>component1() component2()</code>
<ul>
<li>Map.Entry<K,V>的操作符函数，分别用来直接访问key和value</li>
</ul></li>
<li><code>Map.Entry&lt;K,V&gt;.toPair():Pair&lt;K,V&gt;</code>
<ul>
<li>把Map的Entry转换为Pair</li>
</ul></li>
<li><code>getOrElse(key:K,defaultValue:()-&gt;V):V</code>
<ul>
<li>通过key获取值，当没有值可以设置默认值</li>
</ul></li>
<li><code>getValue(key:K):V</code>
<ul>
<li>当Map中不存在这个key，调用get函数，如果不想返回null，直接抛出异常</li>
</ul></li>
<li><code>getOrPut(key:K,defaultValue:()-&gt;V):V</code>
<ul>
<li>如果不存在这个key，就添加这个key到Map中，对应的value是defaultValue</li>
</ul></li>
<li><code>iterator():Iterator&lt;Map.Entry&lt;K,V&gt;&gt;</code>
<ul>
<li>这个函数返回的是entries.iterator()</li>
</ul></li>
<li><code>mapKeys(transform:(Map.Entry&lt;K,V&gt;)-&gt;R):Map&lt;R,V&gt;</code>
<ul>
<li>把Map的Key设置为通过转换函数transform映射之后的值 <code>map.mapKeys{it.key * 10}</code></li>
</ul></li>
<li><code>mapValues(transform:(Map.Entry&lt;K,V&gt;)-&gt;R):Map&lt;K,R&gt;</code>
<ul>
<li>对应的这个函数是把Map的value设置为通过转换函数transform转换之后的新值。 <code>map.mapValues({it.value + &quot;$&quot;})</code></li>
</ul></li>
<li><code>filterKeys(predicate:(K) -&gt; Boolean):Map&lt;K,V&gt;</code>
<ul>
<li>返回过滤出满足key判断条件的元素组成的新Map。 <code>map.filterKeys({it &gt; 0})</code></li>
</ul></li>
<li><code>filterValues(predicate:(V)-&gt;Boolean):Map&lt;K,V&gt;</code>
<ul>
<li>返回过滤出满足value判断条件的元素组成的元素组成的新Map。 <code>map.filterValues({it &gt; &quot;b&quot;})</code></li>
</ul></li>
<li><code>filter(predicate:(Map.Entry&lt;K,V&gt;)-&gt;Boolean):Map&lt;K,V&gt;</code>
<ul>
<li>返回过滤出满足Entry判断条件的元素组成的新Map。 <code>map.filter({it.key &gt; 0 &amp;&amp; it.value &gt; &quot;b&quot;})</code></li>
</ul></li>
<li><code>Iterable&lt;Pair&lt;K,V&gt;&gt;.toMap(destination:M):M</code>
<ul>
<li>把持有Pair的Iterable集合转换为Map。 <code>pairList.toMap()</code></li>
</ul></li>
<li><code>Map&lt;out K,V&gt;.toMutableMap():MutableMap&lt;K,V&gt;</code>
<ul>
<li>把一个只读的Map转换为可编辑的MutableMap。 <code>map.toMutableMap()</code></li>
</ul></li>
<li><code>put(key:K,value:V):V?</code>
<ul>
<li>根据key设置元素的value。如果该key存在就更新value，不存在就添加，但是put的返回值是null</li>
</ul></li>
<li><code>MutableMap&lt;out K,V&gt;.remove(key:K):V?</code>
<ul>
<li>根据键值key来删除元素 <code>map.remove(-1)</code></li>
</ul></li>
<li><code>MutableMap&lt;K,V&gt;.clear():Unit</code>
<ul>
<li>清空MutableMap</li>
</ul></li>
</ul></li>
</ul>

<h2 id="toc_31">泛型</h2>

<p>Java中泛型PECS(Producer Extends Consumer Super)原则。</p>

<ul>
<li>频繁往外读取内容的，适合用上界Extends —— (? extends T)</li>
<li>经常往里插入的，适合用下界Super    —— (? super T)</li>
</ul>

<h3 id="toc_32">Kotlin中的泛型</h3>

<ul>
<li>out T与in T<br/>
out T 等价于 &lt;? extends T&gt; 和 in T 等价于 &lt;? super T&gt;</li>
<li>声明处型变</li>
<li>类型投影</li>
</ul>

<h3 id="toc_33">泛型类</h3>

<pre class="line-numbers"><code class="language-text">class Box&lt;T&gt;(t:T) {
    var value = t
}
</code></pre>

<h2 id="toc_34">面向对象编程</h2>

<h3 id="toc_35">类与构造函数</h3>

<h4 id="toc_36">构造函数</h4>

<ul>
<li>主构造函数（是类头的一部分，直接放在类后面。如果没有注解或者可见性修饰符，可以省略。主构造函数不能包含任何代码，初始化代码可以放到以init关键字作为前缀的初始化）</li>
<li>次构造函数（前缀用constructor声明）</li>
<li>私有主构造函数（<code>class DontCreateMe private constructor(){}</code>）</li>
</ul>

<h4 id="toc_37">类的属性</h4>

<p>类的属性必须要初始化或者具有抽象属性，并且kotlin中类的字段自动带有getter方法和setter方法。</p>

<h3 id="toc_38">接口</h3>

<p>使用interface作为接口的关键词</p>

<h4 id="toc_39">实现接口</h4>

<p>接口是没有构造函数的。使用冒号：语法来实现一个接口，如果有多个用逗号隔开</p>

<h4 id="toc_40">覆盖冲突</h4>

<p>如果一个类从他的直接父类继承了同一个函数的多个实现，那么它必须重写这个函数并且提供自己的实现。为表示使用父类中提供的方法，我们用super关键字实现。在重写print()时，比如我们实现的ProjectService、MilestoneService都有一个print()函数，当我们直接使用super.print()时，编译器是无法知道想要调用的是哪个里面的print函数，这个我们叫做<strong>覆盖冲突</strong>。这个时候，我们使用以下语法来调用<code>super&lt;ProjectService&gt;.print()</code> 或者 <code>super&lt;MilestoneService&gt;.print()</code>。</p>

<h3 id="toc_41">抽象类和接口的差异</h3>

<h4 id="toc_42">概念上的区别</h4>

<p>接口主要是对动作的抽象，定义了行为特性的规约。<br/><br/>
抽象类是对根源的抽象。<br/><br/>
当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>

<h4 id="toc_43">语法层面上的区别</h4>

<p>接口不能保存状态，可以有属性但必须是抽象的。<br/><br/>
一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br/><br/>
类如果要实现一个接口，它必须实现接口声明的所有方法。但类不可以实现抽象类声明的所有方法。<br/><br/>
接口中的所有方法隐含的都是抽象的。而抽象类则可以包含抽象和非抽象的方法。</p>

<h4 id="toc_44">设计层面上的区别</h4>

<p>抽象类是对一种事物的抽象。而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为。而接口却是对类局部行为进行抽象。</p>

<h3 id="toc_45">继承</h3>

<p>在Kotlin中，所有的类会默认继承Any整个父类，但Any并不完全等同于Java中的Object类，因为它只有equals()、hashCode()、toString()这三个方法。</p>

<h4 id="toc_46">open类</h4>

<p>除了抽象类、接口默认可以被继承，我们也可以把一个类声明为open，这样我们就可以继承这个open类。<br/><br/>
当我们想定义一个父类时，需要使用open关键字：<code>open class Base{}</code><br/><br/>
当然，抽象类是默认open的，然后在子类中使用冒号进行继承： <code>class SubClass : Base() {}</code><br/><br/>
如果父类有构造函数，那么必须在子类的主构造函数中进行继承，没有的话可以选择主构造函数或者二级构造函数。  </p>

<pre class="line-numbers"><code class="language-text">//父类
open class Base(type:String) {}
//子类
class SubClass(type:String) : Base(type) {}
</code></pre>

<p>Kotlin中的override()和Java中也有所不同，因为Kotlin提倡所有的操作都是明确的，因此需要将希望被重写的函数设为<code>open</code>,然后通过<code>override</code>标记实现重写。重写的函数也是open的，如果希望它不被重写， 可以再前面增加<code>final</code>:  </p>

<pre class="line-numbers"><code class="language-text">open class SubClass : Base {
    constructor(type:String) : super(type) {}
    final override fun doSomething() {
        super.doSomething()
    }
}
</code></pre>

<h3 id="toc_47">枚举类</h3>

<h4 id="toc_48">枚举类的基本用法</h4>

<pre class="line-numbers"><code class="language-text">enum class Direction {
    NORTH,SOUTH,WEST,EAST
}

&gt;&gt;&gt; val north = Direction.NORTH
</code></pre>

<p>每个枚举常量都是一个对象。枚举常量用逗号分隔。</p>

<h4 id="toc_49">初始化枚举值</h4>

<pre class="line-numbers"><code class="language-text">enum class Color(val rgb:Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}
</code></pre>

<p>另外，枚举常量也可以声明自己的匿名类：</p>

<pre class="line-numbers"><code class="language-text">enum class ActivityLifeState {
    onCreate {
        override fun signal() = onStart
    },
    
    onStart {
        override fun signal = onStop
    },
    
    onStop {
        override fun signal() = onStart
    },
    
    onDestroy {
        override fun signal() = onDestroy
    }
    
    abstract fun signal() : ActivityLifeState
}
</code></pre>

<h4 id="toc_50">使用枚举常量</h4>

<p>每个枚举常量，默认都有name 和 ordinal 的属性。</p>

<pre class="line-numbers"><code class="language-text">enum class RGB {RED,GREEN,BLUE}

&gt;&gt;&gt; val rgbs = enumValue&lt;RGB&gt;().joinToString {&quot;${it.name} : ${it.ordinal}&quot;}
&gt;&gt;&gt; rgbs
RED : 0 , GREEN : 1 , BLUE : 2
</code></pre>

<h3 id="toc_51">注解类</h3>

<h4 id="toc_52">元注解</h4>

<ul>
<li><code>@Target(AnnotationTarget.CLASS,AnnotationTarget.FUNCTION,AnnotationTarget.EXPRESSION,AnnotationTarget.FIELD,AnnotationTarget.LOCAL_VARIALBE,AnnotationTarget.TYPE,AnnotationTarget.TYPEALIAS,AnnotationTarget.TYPE_PARAMETER,AnnotationTarget.VALUE_PARAMETER,AnnotationTarget.CONSTRUCTOR)</code> 指定这个注解可用于哪些元素（类、函数、属性、表达式等等）</li>
<li><code>@Retention(AnnotationTarget.SOURCE)</code> 指定这个注解的信息是否被保存到编译后的class文件中，以及在运行时是否可以通过反射访问到它。</li>
<li><code>@Repeatable</code> 允许在单个元素上多次使用同一个注解</li>
<li><code>@MustBeDocumented</code> 表示这个注解是公开API的一部分，在自动产生的API文档中的类或者函数签名中，应该包含这个注解的信息</li>
</ul>

<h3 id="toc_53">单例模式</h3>

<p>Kotlin中没有“静态属性和方法”，但是也提供了实现类似于“单例”的功能</p>

<ul>
<li><code>object</code> 单例模式</li>
<li>匿名object 有时候需要的仅仅是一个简单对象，这个时候可以直接使用<code>val Porigin = object{var x = 0.0 var y = 0.0}</code></li>
<li><code>companion object</code> 伴生对象，一个类只能有一个伴生对象，伴生对象的初始化是在相应的类被加载解析时</li>
<li>如果想使用Java中的静态成员和静态方法
<ul>
<li>@JvmField注解： 生成与该属性相同的静态字段</li>
<li>@JvmStatic注解： 在单例对象和伴生对象中生成对应的静态方法</li>
</ul></li>
</ul>

<pre class="line-numbers"><code class="language-text">object User {
    val username : String = &quot;admin&quot;
    val password : String = &quot;admin&quot;
}

&gt;&gt;&gt; User.username
&gt;&gt;&gt; User.password
</code></pre>

<h3 id="toc_54">密封类</h3>

<p>sealed类是枚举类的扩展，枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。要声明一个密封类，需要在类名前面添加sealed修饰符。密封类的所有子类都必须与密封类在同一个文件中声明。</p>

<p>使用密封类的主要场景是在使用when表达式的时候，能够验证语句覆盖了所有情况，而无需再添加一个else子句。</p>

<h3 id="toc_55">数据类</h3>

<p>我们写Java代码时，会经常创建一些只保存数据的类。</p>

<ul>
<li>POJO类：普通Java类，具有一部分getter/setter方法就可以被称为POJO</li>
<li>DTO类：数据传输类，泛指用于展示层与服务层之间的数据传输对象</li>
<li>VO类：ViewObject</li>
<li>PO类：持久对象，是由一组属性和属性的get和set方法组成。用来封装原始数据。</li>
<li>BO类：业务对象层，表示应用程序领域内“事物”的所有实体类。</li>
<li>DO类：领域对象，从现实世界中抽象出来的有形或无形的业务实体</li>
</ul>

<p>Kotlin中使用data前缀来构建数据类，数据类有以下限制：</p>

<ul>
<li>主构造函数需要至少有一个参数</li>
<li>主构造函数的所有参数需要标记为val或var</li>
<li>数据类不能是抽象、开放、密封或者内部的(不能用abstract、open、sealed、inner作为前缀修饰)，只能是final的</li>
</ul>

<h4 id="toc_56">数据类的解构</h4>

<p>解构相当于Component函数的逆向映射</p>

<pre class="line-numbers"><code class="language-text">val helen = User(&quot;Helen&quot;,&quot;Female&quot;,15)
val (name,gender,age) = helen 
println(&quot;$name,$gender,$age years of age&quot;)
</code></pre>

<p>输出</p>

<pre class="line-numbers"><code class="language-text">Helen,Female,15 years of age
</code></pre>

<h3 id="toc_57">嵌套类</h3>

<p>类可以嵌套在其他类中，可以嵌套多层。<br/><br/>
访问嵌套类对的方式是直接使用“类名.”，有多少层嵌套，就用多少层类名加点号来访问。<br/><br/>
普通的嵌套类，没有持有外部类的引用，所以是无法访问外部类的变量的。  </p>

<h4 id="toc_58">内部类</h4>

<p>类可以标记为inner以便能访问外部类的成员，这样的类叫内部类。内部类会带有一个对外部类的对象的引用。</p>

<h4 id="toc_59">匿名内部类</h4>

<p>匿名内部类就是没有名字的内部类。既然是内部类，那么它自然也可以访问外部类的变量。比如Thread()、Runnable()。</p>

<pre class="line-numbers"><code class="language-text">//first
Thread({
    printlin(&quot;test&quot;)
}).start()

//second
val wait = Runnable {
    println(&quot;test2&quot;)
}
Thread(wait).start()

//third
val wait = {
    println(&quot;test3&quot;)
}

Thread(wait).start()
</code></pre>

<h3 id="toc_60">委托</h3>

<h4 id="toc_61">代理模式</h4>

<p>代理模式(Proxy Pattern) 也称为委托模式。在代理模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托（Delegation）给另一个对象来处理。代理模式使得我们可以通过聚合来替代继承，它还使我们可以模拟mixin（混合类型）。委托模式的作用是将委托者与实际实现代码分离出来，以达成解耦的目的。</p>

<h4 id="toc_62">暂时不理解</h4>

<h2 id="toc_63">函数式编程</h2>

<h3 id="toc_64">函数式编程概述</h3>

<p>“函数式编程” 又称泛函编程，是一种“编程范式”，也就是如何编写程序的方法论。它的基础是λ演算。函数式编程的主要思想是把问题的解决方案写成一系列嵌套的函数调用。</p>

<h3 id="toc_65">在Kotlin中使用函数式编程</h3>

<h4 id="toc_66">Kotlin中的函数</h4>

<p>在Kotlin中的函数使用<code>fun</code>关键字声明</p>

<pre class="line-numbers"><code class="language-text">fun double(x: Int): Int {
    return 2 * x
}
</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15626502769714.html" 
          title="Previous Post: Android-事件分发机制详解：史上最全面、最易懂">&laquo; Android-事件分发机制详解：史上最全面、最易懂</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15626502770577.html" 
          title="Next Post: Android-RecyclerView详细学习">Android-RecyclerView详细学习 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16145671673295.html">多态</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  













<script src="asset/prism.js"></script>


<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
