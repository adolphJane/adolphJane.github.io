<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="前言之前学习了Android自定义控件的动画，得到了很大的提升。所以赶紧学习学习自定义控件的绘图，把以前的知识整理整理，研究研究Android的各种特效，android的特效真是其它平台无法比拟的，而且一个漂亮的UI交互，会给APP增色不少。
一、概述及基本几何图形绘制一、Paint和Canvas像我们平时画图一样，需要两个工具，纸和笔。Paint就是相当于笔，而Canvas就是纸，这里叫画布。">
<meta property="og:type" content="article">
<meta property="og:title" content="Android自定义控件——绘图">
<meta property="og:url" content="http://adolph.cc/2016/01/11/android-draw/index.html">
<meta property="og:site_name" content="Magic">
<meta property="og:description" content="前言之前学习了Android自定义控件的动画，得到了很大的提升。所以赶紧学习学习自定义控件的绘图，把以前的知识整理整理，研究研究Android的各种特效，android的特效真是其它平台无法比拟的，而且一个漂亮的UI交互，会给APP增色不少。
一、概述及基本几何图形绘制一、Paint和Canvas像我们平时画图一样，需要两个工具，纸和笔。Paint就是相当于笔，而Canvas就是纸，这里叫画布。">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170211418620140830215001750.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702115560020140905091401375.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702111494020140905095358720.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170211919281355989830_7413.jpg">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702121882020140905170403218.jpeg">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702121098420140905172349030.jpeg">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702122188720151229090416052.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702127119520151229090636780.jpeg">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702124934520151229092331153.jpeg">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702126992720151229092943955.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702126981920151229094300488.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702126035920151229094618817.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702123259820151229094642115.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702127453820151229094808805.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702121570120160328094622304.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702126756520160328094655217.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170212447420160328202051449.jpeg">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702129696620160328202312248.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702124783720160328202422676.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702124254520160328202508739.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702127999920160328202609692.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702124041720160328202640208.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702127054120160328202826223.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702129754420160328202946178.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702123803920160328203123694.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702126389320160328203210900.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702125491520160328203834572.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170212919020160328203922416.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702127661020160328220950371.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702129684220160328205249349.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702125218320160328205647198.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702128185020160328205659876.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702138288820160328210844115.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702134262920160330083020037.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702134447020160330083821071.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702137191320160402201504245.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702131499120160402201548433.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702138363920160402201638339.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702146778420160402201734137.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702149814720160402202201451.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214471620160402202259482.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214312720160402202419967.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702141899420160403101637840.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702142629720160403102134342.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702148042620160419090010949.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702148173820160422211037563.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702141128020160419090113981.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702145630720160419090149826.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702142152920160419092847409.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700524743884.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702141487005956679.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700601486740.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700604489771.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700623263988.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700625229314.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700628579628.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700629899842.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700630970656.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700631867848.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700633067330.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700634190280.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702149524720160419094249915.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702146753120160419094322134.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702141791120160419094402991.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700658148451.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021414870066319677.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700668558611.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021414870067259251.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700689624454.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148700695150580.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214772920160419095222393.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703465130001.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703589425013.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703612776387.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703629241194.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021414870363224165.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021414870364118549.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703647526942.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703676868315.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702148063320160426230742070.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703689726848.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021414870370673745.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703716059147.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703723948421.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148703738585408.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148704021971161.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148704029774250.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148704030478886.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148704030981103.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148704066929879.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148704071326352.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148704071882068.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170214148704099660317.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725592682735.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725758848921.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725772438748.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725778099705.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725815717705.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725818017115.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725905356002.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725918989611.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725924055197.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725927596970.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021614872593145776.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725933137432.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725941021078.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725944050154.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725950442016.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725954269013.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725964213294.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725967524708.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021614872596928121.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148725990714554.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021614872599356866.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726007529092.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726009269370.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726010521981.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726017845506.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726020137845.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726027337083.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702165051220160430100622197.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726057113047.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726060436922.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702168245720160430100858813.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726073090392.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726077549074.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726010521981.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148726098181631.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170216148726017845506.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021714872611498488.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021714872611498488.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702178936520160430214851903.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729385240790.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702177244220160430221534260.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729574750396.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702171540320160430221825171.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729679339717.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729680591875.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729696823160.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729698370116.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729713216159.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729716676751.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729729368754.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148729735226243.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170217148732260567552.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021714873226349891.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148741974870433.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742142589995.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021814874216459105.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742173885362.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742220432348.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742296840865.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742300536373.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742306668570.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742316578128.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742402341933.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742406813772.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742428492797.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742436552801.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742446966878.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742459559982.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742508941855.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742514697242.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742626216035.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742631591725.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742679241010.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742681392967.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021814874268559257.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742687161169.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021814874269323579.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702189494520160608193514041.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702187186220160608193714683.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742741892833.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702182513420160608194604486.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742749081052.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742753162132.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021814874275656046.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702184308520160608195225845.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742799825207.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742833291808.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742853530753.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218652220160608200510256.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702184987720160608200638522.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702181548920160608200722976.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702182577120160608200752266.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702184796420160608200822361.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218896920160608200907257.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148742952616764.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148743109011232.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148743121047852.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148743122939228.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148743125075959.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148743126918158.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148743140235313.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702188115020160704092733132.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702183859120160704093008765.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021814874319725880.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170218148743198255118.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702192365620160704093251719.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747050158997.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702195512620160704093716317.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702199796720160704093846069.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702197042120160704093941925.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747120697471.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747127788398.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747141094317.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747143957685.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747145593850.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747147367559.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747149464734.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747192429637.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747196393407.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747220789400.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747253045201.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747272631952.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747393834010.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219664571469532269_6953.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747417321114.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747556992480.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747591721538.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747606052729.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747610135490.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747683989613.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747688447219.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747689784570.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747691232111.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747692478953.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747697328255.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747698789104.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747703149559.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747707595558.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747709652890.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874774868194.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747750471319.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148747756525042.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219664571469532269_6953.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748257725794.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748264221762.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748265774913.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748298271112.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748303784132.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748306720671.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219137201472431756_8442.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874878569594.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874879074974.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748794539950.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874881977801.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874882415260.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748827185995.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748830053945.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748834620681.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748836041948.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748844135403.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/201702191018820160829092349307.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748856029218.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748862533506.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874886493651.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021977001474722293_8182.gif">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748927476934.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874894175847.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874895153361.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/2017021914874895561684.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748960591118.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748961856008.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748966342983.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748985130220.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219148748989522643.png">
<meta property="og:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170219881101474724851_2084.gif">
<meta property="og:updated_time" content="2017-10-28T15:18:47.640Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android自定义控件——绘图">
<meta name="twitter:description" content="前言之前学习了Android自定义控件的动画，得到了很大的提升。所以赶紧学习学习自定义控件的绘图，把以前的知识整理整理，研究研究Android的各种特效，android的特效真是其它平台无法比拟的，而且一个漂亮的UI交互，会给APP增色不少。
一、概述及基本几何图形绘制一、Paint和Canvas像我们平时画图一样，需要两个工具，纸和笔。Paint就是相当于笔，而Canvas就是纸，这里叫画布。">
<meta name="twitter:image" content="http://ohtrrgyyd.bkt.clouddn.com/20170211418620140830215001750.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":true,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://adolph.cc/2016/01/11/android-draw/"/>





  <title> Android自定义控件——绘图 | Magic </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Magic</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://adolph.cc/2016/01/11/android-draw/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MagicalRice">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://ohtrrgyyd.bkt.clouddn.com/037c5bde749f737e107c8fb8e9321c9d.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Magic">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android自定义控件——绘图
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-11T10:06:08+08:00">
                2016-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前学习了Android自定义控件的动画，得到了很大的提升。所以赶紧学习学习自定义控件的绘图，把以前的知识整理整理，研究研究Android的各种特效，android的特效真是其它平台无法比拟的，而且一个漂亮的UI交互，会给APP增色不少。</p>
<h1 id="一、概述及基本几何图形绘制"><a href="#一、概述及基本几何图形绘制" class="headerlink" title="一、概述及基本几何图形绘制"></a>一、概述及基本几何图形绘制</h1><h2 id="一、Paint和Canvas"><a href="#一、Paint和Canvas" class="headerlink" title="一、Paint和Canvas"></a>一、Paint和Canvas</h2><p>像我们平时画图一样，需要两个工具，纸和笔。Paint就是相当于笔，而Canvas就是纸，这里叫画布。</p>
<p>所以，凡有跟要要画的东西的设置相关的，比如大小，粗细，画笔颜色，透明度，字体的样式等等，都是在Paint里设置；同样，凡是要画出成品的东西，比如圆形，矩形，文字等相关的都是在Canvas里生成。</p>
<h3 id="1、Paint的基本设置函数"><a href="#1、Paint的基本设置函数" class="headerlink" title="1、Paint的基本设置函数"></a>1、Paint的基本设置函数</h3><ul>
<li>paint.setAntiAlias(true);//抗锯齿功能</li>
<li>paint.setColor(Color.RED);  //设置画笔颜色    </li>
<li>paint.setStyle(Style.FILL);//设置填充样式<ul>
<li>Paint.Style.FILL    :填充内部</li>
<li>Paint.Style.FILL_AND_STROKE  ：填充内部和描边</li>
<li>Paint.Style.STROKE  ：仅描边</li>
</ul>
</li>
<li>paint.setStrokeWidth(30);//设置画笔宽度</li>
<li>paint.setShadowLayer(float radius, float dx, float dy, int color);//设置阴影，radius:阴影的倾斜度，dx:水平位移，dy:垂直位移</li>
</ul>
<h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><h4 id="1、首先新建一个工程，把默认的XML改成FrameLayout布局，布局代码如下："><a href="#1、首先新建一个工程，把默认的XML改成FrameLayout布局，布局代码如下：" class="headerlink" title="1、首先新建一个工程，把默认的XML改成FrameLayout布局，布局代码如下："></a>1、首先新建一个工程，把默认的XML改成FrameLayout布局，布局代码如下：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span>  </div><div class="line">    <span class="attr">android:id</span>=<span class="string">"@+id/root"</span>  </div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>  </div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.example.try_paint_blog.MainActivity"</span> &gt;  </div><div class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span> </div><div class="line">```  </div><div class="line">**这里有个特别要注意的地方，给根结点FrameLayout加一个ID号，后面用来在它的内部添加视图用的**</div><div class="line"></div><div class="line">#### 2、然后新建一个视图类，派生自View，想要自由实现的东西，都在onDraw()函数中绘制返回</div><div class="line"></div><div class="line">``` java</div><div class="line">public class MyView extends View &#123;  </div><div class="line">  </div><div class="line">    Context m_context;  </div><div class="line">    public MyView(Context context) &#123;  </div><div class="line">        super(context);  </div><div class="line">        // TODO Auto-generated constructor stub  </div><div class="line">          </div><div class="line">        m_context=context;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    //重写OnDraw（）函数，在每次重绘时自主实现绘图  </div><div class="line">    @Override  </div><div class="line">    protected void onDraw(Canvas canvas) &#123;  </div><div class="line">        // TODO Auto-generated method stub  </div><div class="line">        super.onDraw(canvas);  </div><div class="line">          </div><div class="line">          </div><div class="line">        //设置画笔基本属性  </div><div class="line">        Paint paint=new Paint();  </div><div class="line">        paint.setAntiAlias(true);//抗锯齿功能  </div><div class="line">        paint.setColor(Color.RED);  //设置画笔颜色      </div><div class="line">        paint.setStyle(Style.FILL);//设置填充样式   Style.FILL/Style.FILL_AND_STROKE/Style.STROKE  </div><div class="line">        paint.setStrokeWidth(5);//设置画笔宽度  </div><div class="line">        paint.setShadowLayer(10, 15, 15, Color.GREEN);//设置阴影  </div><div class="line">          </div><div class="line">        //设置画布背景颜色       </div><div class="line">        canvas.drawRGB(255, 255,255);  </div><div class="line">          </div><div class="line">        //画圆  </div><div class="line">        canvas.drawCircle(190, 200, 150, paint);      </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、视图类写好了，下面就要将其加入到Activity中，让它显示出来，在MainActiviy中添加如下代码："><a href="#3、视图类写好了，下面就要将其加入到Activity中，让它显示出来，在MainActiviy中添加如下代码：" class="headerlink" title="3、视图类写好了，下面就要将其加入到Activity中，让它显示出来，在MainActiviy中添加如下代码："></a>3、视图类写好了，下面就要将其加入到Activity中，让它显示出来，在MainActiviy中添加如下代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">          </div><div class="line">      setContentView(R.layout.activity_main);  </div><div class="line">        </div><div class="line">      FrameLayout root=(FrameLayout)findViewById(R.id.root);  </div><div class="line">      root.addView(<span class="keyword">new</span> MyView(MainActivity.<span class="keyword">this</span>));  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三、基本几何图形绘制"><a href="#三、基本几何图形绘制" class="headerlink" title="三、基本几何图形绘制"></a>三、基本几何图形绘制</h3><h4 id="1、画直线"><a href="#1、画直线" class="headerlink" title="1、画直线"></a>1、画直线</h4><pre><code>void drawLine (float startX, float startY, float stopX, float stopY, Paint paint)
</code></pre><ul>
<li>startX:开始点X坐标</li>
<li>startY:开始点Y坐标</li>
<li>stopX:结束点X坐标</li>
<li>stopY:结束点Y坐标</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.FILL);<span class="comment">//设置填充样式   </span></div><div class="line">paint.setStrokeWidth(<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">canvas.drawLine(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">200</span>, paint);</div></pre></td></tr></table></figure>
<h4 id="2、多条直线"><a href="#2、多条直线" class="headerlink" title="2、多条直线"></a>2、多条直线</h4><pre><code>void drawLines (float[] pts, Paint paint)
void drawLines (float[] pts, int offset, int count, Paint paint)
</code></pre><p>pts:是点的集合，大家下面可以看到，这里不是形成连接线，而是每两个点形成一条直线，pts的组织方式为｛x1,y1,x2,y2,x3,y3,……｝</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.FILL);<span class="comment">//设置填充样式   </span></div><div class="line">paint.setStrokeWidth(<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line"><span class="keyword">float</span> []pts=&#123;<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">400</span>&#125;;  </div><div class="line">canvas.drawLines(pts, paint);</div></pre></td></tr></table></figure>
<h4 id="3、点"><a href="#3、点" class="headerlink" title="3、点"></a>3、点</h4><pre><code>void drawPoint (float x, float y, Paint paint);
</code></pre><ul>
<li>float X：点的X坐标</li>
<li>float Y：点的Y坐标</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.FILL);<span class="comment">//设置填充样式   </span></div><div class="line">paint.setStrokeWidth(<span class="number">15</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">canvas.drawPoint(<span class="number">100</span>, <span class="number">100</span>, paint);</div></pre></td></tr></table></figure>
<h4 id="4、多个点"><a href="#4、多个点" class="headerlink" title="4、多个点"></a>4、多个点</h4><pre><code>void drawPoints (float[] pts, Paint paint)
void drawPoints (float[] pts, int offset, int count, Paint paint)
</code></pre><ul>
<li>float[] pts:点的合集，与上面直线一直，样式为｛x1,y1,x2,y2,x3,y3,……｝</li>
<li>int offset:集合中跳过的数值个数，注意不是点的个数！一个点是两个数值；</li>
<li>count:参与绘制的数值的个数，指pts[]里的数值个数，而不是点的个数，因为一个点是两个数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.FILL);<span class="comment">//设置填充样式   </span></div><div class="line">paint.setStrokeWidth(<span class="number">15</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line"><span class="keyword">float</span> []pts=&#123;<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">400</span>&#125;;  </div><div class="line">canvas.drawPoints(pts, <span class="number">2</span>, <span class="number">4</span>, paint);</div></pre></td></tr></table></figure>
<p><strong>同样是上面的四个点：（10，10）、（100，100），（200，200），（400，400），drawPoints里路过前两个数值，即第一个点跳过，画出后面四个数值代表的点，即第二，第三个点。最后第四个点没画。</strong></p>
<h4 id="5、矩形工具类RectF与Rect"><a href="#5、矩形工具类RectF与Rect" class="headerlink" title="5、矩形工具类RectF与Rect"></a>5、矩形工具类RectF与Rect</h4><p>这两个都是矩形辅助类，区别不大，用哪个都行，根据四个点构建一个矩形结构；在画图时，利用这个矩形结构可以画出对应的矩形或者与其它图形Region相交、相加等等；</p>
<p><strong>RectF</strong><br>构造函数有下面四个，但最常用的还是第二个，根据四个点构造出一个矩形；</p>
<pre><code>RectF() 
RectF(float left, float top, float right, float bottom)
RectF(RectF r)
RectF(Rect r)
</code></pre><p><strong>Rect</strong><br>构造函数如下，最常用的也是根据四个点来构造矩形</p>
<pre><code>Rect()
Rect(int left, int top, int right, int bottom)
Rect(Rect r)
</code></pre><h4 id="6、矩形"><a href="#6、矩形" class="headerlink" title="6、矩形"></a>6、矩形</h4><pre><code>void drawRect (float left, float top, float right, float bottom, Paint paint)
void drawRect (RectF rect, Paint paint)
void drawRect (Rect r, Paint paint)
</code></pre><ul>
<li>第一个的写法是直接传入矩形的四个点，画出矩形</li>
<li>第二、三个构造函数是根据传入RectF或者Rect矩形变量来指定所画的矩形的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.FILL);<span class="comment">//设置填充样式   </span></div><div class="line">paint.setStrokeWidth(<span class="number">15</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">canvas.drawRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>, paint);<span class="comment">//直接构造  </span></div><div class="line">  </div><div class="line">RectF rect = <span class="keyword">new</span> RectF(<span class="number">120</span>, <span class="number">10</span>, <span class="number">210</span>, <span class="number">100</span>);  </div><div class="line">canvas.drawRect(rect, paint);<span class="comment">//使用RectF构造  </span></div><div class="line">  </div><div class="line">Rect rect2 =  <span class="keyword">new</span> Rect(<span class="number">230</span>, <span class="number">10</span>, <span class="number">320</span>, <span class="number">100</span>);   </div><div class="line">canvas.drawRect(rect2, paint);<span class="comment">//使用Rect构造</span></div></pre></td></tr></table></figure>
<h4 id="7、圆角矩形"><a href="#7、圆角矩形" class="headerlink" title="7、圆角矩形"></a>7、圆角矩形</h4><pre><code>void drawRoundRect (RectF rect, float rx, float ry, Paint paint)
</code></pre><ul>
<li>RectF rect:要画的矩形</li>
<li>float rx:生成圆角的椭圆的X轴半径</li>
<li>float ry:生成圆角的椭圆的Y轴半径</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.FILL);<span class="comment">//设置填充样式   </span></div><div class="line">paint.setStrokeWidth(<span class="number">15</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">RectF rect = <span class="keyword">new</span> RectF(<span class="number">100</span>, <span class="number">10</span>, <span class="number">300</span>, <span class="number">100</span>);  </div><div class="line">canvas.drawRoundRect(rect, <span class="number">20</span>, <span class="number">10</span>, paint);</div></pre></td></tr></table></figure>
<h4 id="8、圆形"><a href="#8、圆形" class="headerlink" title="8、圆形"></a>8、圆形</h4><pre><code>void drawCircle (float cx, float cy, float radius, Paint paint)
</code></pre><ul>
<li>float cx：圆心点X轴坐标 </li>
<li>float cy：圆心点Y轴坐标</li>
<li>float radius：圆的半径</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.FILL);<span class="comment">//设置填充样式   </span></div><div class="line">paint.setStrokeWidth(<span class="number">15</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">canvas.drawCircle(<span class="number">150</span>, <span class="number">150</span>, <span class="number">100</span>, paint);</div></pre></td></tr></table></figure>
<h4 id="9、椭圆"><a href="#9、椭圆" class="headerlink" title="9、椭圆"></a>9、椭圆</h4><p>椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，矩形的宽为椭圆的Y轴，建立的椭圆图形</p>
<pre><code>void drawOval (RectF oval, Paint paint)
</code></pre><ul>
<li>RectF oval：用来生成椭圆的矩形</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.STROKE);<span class="comment">//填充样式改为描边   </span></div><div class="line">paint.setStrokeWidth(<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">RectF rect = <span class="keyword">new</span> RectF(<span class="number">100</span>, <span class="number">10</span>, <span class="number">300</span>, <span class="number">100</span>);  </div><div class="line">canvas.drawRect(rect, paint);<span class="comment">//画矩形  </span></div><div class="line">  </div><div class="line">paint.setColor(Color.GREEN);<span class="comment">//更改画笔颜色  </span></div><div class="line">canvas.drawOval(rect, paint);<span class="comment">//同一个矩形画椭圆</span></div></pre></td></tr></table></figure>
<h4 id="10、弧"><a href="#10、弧" class="headerlink" title="10、弧"></a>10、弧</h4><p>弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以弧当然也是根据矩形来生成的；</p>
<pre><code>void drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)
</code></pre><ul>
<li>RectF oval:生成椭圆的矩形</li>
<li>float startAngle：弧开始的角度，以X轴正方向为0度</li>
<li>float sweepAngle：弧持续的角度</li>
<li>boolean useCenter:是否有弧的两边，True，还两边，False，只有一条弧</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.STROKE);<span class="comment">//填充样式改为描边   </span></div><div class="line">paint.setStrokeWidth(<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">RectF rect1 = <span class="keyword">new</span> RectF(<span class="number">100</span>, <span class="number">10</span>, <span class="number">300</span>, <span class="number">100</span>);  </div><div class="line">canvas.drawArc(rect1, <span class="number">0</span>, <span class="number">90</span>, <span class="keyword">true</span>, paint);  </div><div class="line">  </div><div class="line">RectF rect2 = <span class="keyword">new</span> RectF(<span class="number">400</span>, <span class="number">10</span>, <span class="number">600</span>, <span class="number">100</span>);  </div><div class="line">canvas.drawArc(rect2, <span class="number">0</span>, <span class="number">90</span>, <span class="keyword">false</span>, paint);</div></pre></td></tr></table></figure>
<h3 id="四、路径及文字"><a href="#四、路径及文字" class="headerlink" title="四、路径及文字"></a>四、路径及文字</h3><h4 id="1、路径"><a href="#1、路径" class="headerlink" title="1、路径"></a>1、路径</h4><p>canvas中绘制路径利用：</p>
<pre><code>void drawPath (Path path, Paint paint);
</code></pre><h5 id="1、直线路径"><a href="#1、直线路径" class="headerlink" title="1、直线路径"></a>1、直线路径</h5><pre><code>void moveTo (float x1, float y1):直线的开始点；即将直线路径的绘制点定在（x1,y1）的位置；
void lineTo (float x2, float y2)：直线的结束点，又是下一次绘制直线路径的开始点；lineTo（）可以一直用；
void close ():如果连续画了几条直线，但没有形成闭环，调用Close()会将路径首尾点连接起来，形成闭环；
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.STROKE);<span class="comment">//填充样式改为描边   </span></div><div class="line">paint.setStrokeWidth(<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">Path path = <span class="keyword">new</span> Path();  </div><div class="line">  </div><div class="line">path.moveTo(<span class="number">10</span>, <span class="number">10</span>); <span class="comment">//设定起始点  </span></div><div class="line">path.lineTo(<span class="number">10</span>, <span class="number">100</span>);<span class="comment">//第一条直线的终点，也是第二条直线的起点  </span></div><div class="line">path.lineTo(<span class="number">300</span>, <span class="number">100</span>);<span class="comment">//画第二条直线  </span></div><div class="line">path.lineTo(<span class="number">500</span>, <span class="number">100</span>);<span class="comment">//第三条直线  </span></div><div class="line">path.close();<span class="comment">//闭环  </span></div><div class="line">  </div><div class="line">canvas.drawPath(path, paint);</div></pre></td></tr></table></figure>
<h5 id="2、矩形路径"><a href="#2、矩形路径" class="headerlink" title="2、矩形路径"></a>2、矩形路径</h5><pre><code>void addRect (float left, float top, float right, float bottom, Path.Direction dir)
void addRect (RectF rect, Path.Direction dir)
</code></pre><p>Path.Direction有两个值：</p>
<ul>
<li>Path.Direction.CCW：是counter-clockwise缩写，指创建逆时针方向的矩形路径；</li>
<li>Path.Direction.CW：是clockwise的缩写，指创建顺时针方向的矩形路径；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先创建两个大小一样的路径  </span></div><div class="line"><span class="comment">//第一个逆向生成  </span></div><div class="line">Path CCWRectpath = <span class="keyword">new</span> Path();  </div><div class="line">RectF rect1 =  <span class="keyword">new</span> RectF(<span class="number">50</span>, <span class="number">50</span>, <span class="number">240</span>, <span class="number">200</span>);  </div><div class="line">CCWRectpath.addRect(rect1, Direction.CCW);  </div><div class="line">  </div><div class="line"><span class="comment">//第二个顺向生成  </span></div><div class="line">Path CWRectpath = <span class="keyword">new</span> Path();  </div><div class="line">RectF rect2 =  <span class="keyword">new</span> RectF(<span class="number">290</span>, <span class="number">50</span>, <span class="number">480</span>, <span class="number">200</span>);  </div><div class="line">CWRectpath.addRect(rect2, Direction.CW);  </div><div class="line">  </div><div class="line"><span class="comment">//先画出这两个路径   </span></div><div class="line">canvas.drawPath(CCWRectpath, paint);  </div><div class="line">canvas.drawPath(CWRectpath, paint); </div><div class="line"></div><div class="line"><span class="comment">//依据路径写出文字  </span></div><div class="line">String text=<span class="string">"风萧萧兮易水寒，壮士一去兮不复返"</span>;  </div><div class="line">paint.setColor(Color.GRAY);  </div><div class="line">paint.setTextSize(<span class="number">35</span>);  </div><div class="line">canvas.drawTextOnPath(text, CCWRectpath, <span class="number">0</span>, <span class="number">18</span>, paint);<span class="comment">//逆时针生成  </span></div><div class="line">canvas.drawTextOnPath(text, CWRectpath, <span class="number">0</span>, <span class="number">18</span>, paint);<span class="comment">//顺时针生成</span></div></pre></td></tr></table></figure>
<p><strong>路径的顺序对文字的显示方向有影响</strong></p>
<h5 id="3、圆角矩形路径"><a href="#3、圆角矩形路径" class="headerlink" title="3、圆角矩形路径"></a>3、圆角矩形路径</h5><pre><code>void addRoundRect (RectF rect, float[] radii, Path.Direction dir)
void addRoundRect (RectF rect, float rx, float ry, Path.Direction dir)
</code></pre><ul>
<li>第一个构造函数：可以定制每个角的圆角大小：</li>
<li>第二个构造函数：只能构建统一圆角大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Path path = <span class="keyword">new</span> Path();  </div><div class="line">RectF rect1 =  <span class="keyword">new</span> RectF(<span class="number">50</span>, <span class="number">50</span>, <span class="number">240</span>, <span class="number">200</span>);  </div><div class="line">path.addRoundRect(rect1, <span class="number">10</span>, <span class="number">15</span> , Direction.CCW);  </div><div class="line">  </div><div class="line">RectF rect2 =  <span class="keyword">new</span> RectF(<span class="number">290</span>, <span class="number">50</span>, <span class="number">480</span>, <span class="number">200</span>);  </div><div class="line"><span class="keyword">float</span> radii[] =&#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">35</span>,<span class="number">40</span>,<span class="number">45</span>&#125;;  </div><div class="line">path.addRoundRect(rect2, radii, Direction.CCW);  </div><div class="line">  </div><div class="line">canvas.drawPath(path, paint);</div></pre></td></tr></table></figure>
<h5 id="4、圆形路径"><a href="#4、圆形路径" class="headerlink" title="4、圆形路径"></a>4、圆形路径</h5><pre><code>void addCircle (float x, float y, float radius, Path.Direction dir)
</code></pre><ul>
<li>float x：圆心X轴坐标 </li>
<li>float y：圆心Y轴坐标</li>
<li>float radius：圆半径</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Path path = <span class="keyword">new</span> Path();  </div><div class="line">path.addCircle(<span class="number">200</span>, <span class="number">200</span>, <span class="number">100</span>, Direction.CCW);  </div><div class="line">canvas.drawPath(path, paint);</div></pre></td></tr></table></figure>
<h5 id="5、椭圆路径"><a href="#5、椭圆路径" class="headerlink" title="5、椭圆路径"></a>5、椭圆路径</h5><pre><code>void addOval (RectF oval, Path.Direction dir)
</code></pre><ul>
<li>RectF oval：生成椭圆所对应的矩形</li>
<li>Path.Direction :生成方式，与矩形一样，分为顺时针与逆时针，意义完全相同，不再重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Path path = <span class="keyword">new</span> Path();  </div><div class="line">RectF rect =  <span class="keyword">new</span> RectF(<span class="number">50</span>, <span class="number">50</span>, <span class="number">240</span>, <span class="number">200</span>);  </div><div class="line">path.addOval(rect, Direction.CCW);  </div><div class="line">canvas.drawPath(path, paint);</div></pre></td></tr></table></figure>
<h5 id="6、弧形路径"><a href="#6、弧形路径" class="headerlink" title="6、弧形路径"></a>6、弧形路径</h5><pre><code>void addArc (RectF oval, float startAngle, float sweepAngle)
</code></pre><ul>
<li>RectF oval：弧是椭圆的一部分，这个参数就是生成椭圆所对应的矩形；</li>
<li>float startAngle：开始的角度，X轴正方向为0度</li>
<li>float sweepAngel：持续的度数；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">paint.setStyle(Style.STROKE);<span class="comment">//填充样式改为描边   </span></div><div class="line">paint.setStrokeWidth(<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">  </div><div class="line">Path path = <span class="keyword">new</span> Path();  </div><div class="line">RectF rect =  <span class="keyword">new</span> RectF(<span class="number">50</span>, <span class="number">50</span>, <span class="number">240</span>, <span class="number">200</span>);  </div><div class="line">path.addArc(rect, <span class="number">0</span>, <span class="number">100</span>);  </div><div class="line">  </div><div class="line">canvas.drawPath(path, paint);<span class="comment">//画出路径</span></div></pre></td></tr></table></figure>
<h5 id="7、线段轨迹"><a href="#7、线段轨迹" class="headerlink" title="7、线段轨迹"></a>7、线段轨迹</h5><pre><code>void quadTo (float x1, float y1, float x2, float y2)
</code></pre><h4 id="2、文字"><a href="#2、文字" class="headerlink" title="2、文字"></a>2、文字</h4><h5 id="1、Paint的相关设置"><a href="#1、Paint的相关设置" class="headerlink" title="1、Paint的相关设置"></a>1、Paint的相关设置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//普通设置  </span></div><div class="line">paint.setStrokeWidth (<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">paint.setAntiAlias(<span class="keyword">true</span>); <span class="comment">//指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢  </span></div><div class="line">paint.setStyle(Paint.Style.FILL);<span class="comment">//绘图样式，对于设文字和几何图形都有效  </span></div><div class="line">paint.setTextAlign(Align.CENTER);<span class="comment">//设置文字对齐方式，取值：align.CENTER、align.LEFT或align.RIGHT  </span></div><div class="line">paint.setTextSize(<span class="number">12</span>);<span class="comment">//设置文字大小  </span></div><div class="line">  </div><div class="line"><span class="comment">//样式设置  </span></div><div class="line">paint.setFakeBoldText(<span class="keyword">true</span>);<span class="comment">//设置是否为粗体文字  </span></div><div class="line">paint.setUnderlineText(<span class="keyword">true</span>);<span class="comment">//设置下划线  </span></div><div class="line">paint.setTextSkewX((<span class="keyword">float</span>) -<span class="number">0.25</span>);<span class="comment">//设置字体水平倾斜度，普通斜体字是-0.25  </span></div><div class="line">paint.setStrikeThruText(<span class="keyword">true</span>);<span class="comment">//设置带有删除线效果  </span></div><div class="line">  </div><div class="line"><span class="comment">//其它设置  </span></div><div class="line">paint.setTextScaleX(<span class="number">2</span>);<span class="comment">//只会将水平方向拉伸，高度不会变</span></div></pre></td></tr></table></figure>
<h5 id="2、canvas绘图方式"><a href="#2、canvas绘图方式" class="headerlink" title="2、canvas绘图方式"></a>2、canvas绘图方式</h5><h6 id="1、普通水平绘制"><a href="#1、普通水平绘制" class="headerlink" title="1、普通水平绘制"></a>1、普通水平绘制</h6><p>void drawText (String text, float x, float y, Paint paint)<br>void drawText (CharSequence text, int start, int end, float x, float y, Paint paint)<br>void drawText (String text, int start, int end, float x, float y, Paint paint)<br>void drawText (char[] text, int index, int count, float x, float y, Paint paint)</p>
<ul>
<li>第一个构造函数：最普通简单的构造函数；</li>
<li>第三、四个构造函数：实现截取一部分字体给图；</li>
<li>第二个构造函数：最强大，因为传入的可以是charSequence类型字体，但是并不可以实现绘制带图片的扩展文字</li>
</ul>
<h6 id="2、指定个个文字位置"><a href="#2、指定个个文字位置" class="headerlink" title="2、指定个个文字位置"></a>2、指定个个文字位置</h6><pre><code>void drawPosText (char[] text, int index, int count, float[] pos, Paint paint)
void drawPosText (String text, float[] pos, Paint paint)
</code></pre><ul>
<li>char[] text：要绘制的文字数组</li>
<li>int index:：第一个要绘制的文字的索引</li>
<li>int count：要绘制的文字的个数，用来算最后一个文字的位置，从第一个绘制的文字开始算起</li>
<li>float[] pos：每个字体的位置，同样两两一组，如｛x1,y1,x2,y2,x3,y3……｝</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">  </div><div class="line">paint.setStrokeWidth (<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">paint.setAntiAlias(<span class="keyword">true</span>); <span class="comment">//指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢  </span></div><div class="line">paint.setTextSize(<span class="number">80</span>);<span class="comment">//设置文字大小  </span></div><div class="line">paint.setStyle(Paint.Style.FILL);<span class="comment">//绘图样式，设置为填充     </span></div><div class="line">  </div><div class="line"><span class="keyword">float</span> []pos=<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">80</span>,<span class="number">100</span>,  </div><div class="line">                        <span class="number">80</span>,<span class="number">200</span>,  </div><div class="line">                        <span class="number">80</span>,<span class="number">300</span>,  </div><div class="line">                        <span class="number">80</span>,<span class="number">400</span>&#125;;  </div><div class="line">canvas.drawPosText(<span class="string">"画图示例"</span>, pos, paint);<span class="comment">//两个构造函数</span></div></pre></td></tr></table></figure>
<h6 id="3、沿路径绘制"><a href="#3、沿路径绘制" class="headerlink" title="3、沿路径绘制"></a>3、沿路径绘制</h6><pre><code>void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint)
void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint)
</code></pre><ul>
<li>float hOffset  : 与路径起始点的水平偏移距离</li>
<li>float vOffset  : 与路径中心的垂直偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">  </div><div class="line">paint.setStrokeWidth (<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">paint.setAntiAlias(<span class="keyword">true</span>); <span class="comment">//指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢  </span></div><div class="line">paint.setTextSize(<span class="number">45</span>);<span class="comment">//设置文字大小  </span></div><div class="line">paint.setStyle(Paint.Style.STROKE);<span class="comment">//绘图样式，设置为填充  </span></div><div class="line">  </div><div class="line">String string=<span class="string">"风萧萧兮易水寒，壮士一去兮不复返"</span>;  </div><div class="line">  </div><div class="line"><span class="comment">//先创建两个相同的圆形路径，并先画出两个路径原图  </span></div><div class="line">Path circlePath=<span class="keyword">new</span> Path();  </div><div class="line">circlePath.addCircle(<span class="number">220</span>,<span class="number">200</span>, <span class="number">180</span>, Path.Direction.CCW);<span class="comment">//逆向绘制,还记得吗,上篇讲过的  </span></div><div class="line">canvas.drawPath(circlePath, paint);<span class="comment">//绘制出路径原形  </span></div><div class="line">  </div><div class="line">Path circlePath2=<span class="keyword">new</span> Path();  </div><div class="line">circlePath2.addCircle(<span class="number">750</span>,<span class="number">200</span>, <span class="number">180</span>, Path.Direction.CCW);  </div><div class="line">canvas.drawPath(circlePath2, paint);<span class="comment">//绘制出路径原形  </span></div><div class="line">  </div><div class="line">paint.setColor(Color.GREEN);  </div><div class="line"><span class="comment">//hoffset、voffset参数值全部设为0，看原始状态是怎样的  </span></div><div class="line">canvas.drawTextOnPath(string, circlePath, <span class="number">0</span>, <span class="number">0</span>, paint);  </div><div class="line"><span class="comment">//第二个路径，改变hoffset、voffset参数值  </span></div><div class="line">canvas.drawTextOnPath(string, circlePath2, <span class="number">80</span>, <span class="number">30</span>, paint);</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170211418620140830215001750.png" alt="20170211418620140830215001750.png"></p>
<h5 id="3、字体样式设置（Typeface）"><a href="#3、字体样式设置（Typeface）" class="headerlink" title="3、字体样式设置（Typeface）"></a>3、字体样式设置（Typeface）</h5><pre><code>paint.setTypeface(typeface);
</code></pre><p>Typeface是专门用来设置字体样式的，通过paint.setTypeface()来指定。可以指定系统中的字体样式，也可以指定自定义的样式文件中获取。要构建Typeface时，可以指定所用样式的正常体、斜体、粗体等，如果指定样式中，没有相关文字的样式就会用系统默认的样式来显示，一般默认是宋体。</p>
<p><strong>创建Typeface：</strong></p>
<ul>
<li>Typeface    create(String familyName, int style) //直接通过指定字体名来加载系统中自带的文字样式</li>
<li>Typeface    create(Typeface family, int style)     //通过其它Typeface变量来构建文字样式</li>
<li>Typeface    createFromAsset(AssetManager mgr, String path) //通过从Asset中获取外部字体来显示字体样式</li>
<li>Typeface    createFromFile(String path)//直接从路径创建</li>
<li>Typeface    createFromFile(File path)//从外部路径来创建字体样式</li>
<li>Typeface    defaultFromStyle(int style)//创建默认字体<ul>
<li>Typeface.NORMAL  //正常体</li>
<li>Typeface.BOLD     //粗体</li>
<li>Typeface.ITALIC     //斜体</li>
<li>Typeface.BOLD_ITALIC //粗斜体</li>
</ul>
</li>
</ul>
<h6 id="1、使用系统中的字体"><a href="#1、使用系统中的字体" class="headerlink" title="1、使用系统中的字体"></a>1、使用系统中的字体</h6><pre><code>Typeface    defaultFromStyle(int style)//创建默认字体
Typeface    create(String familyName, int style) //直接通过指定字体名来加载系统中自带的文字样式
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用系统自带字体绘制          </span></div><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">  </div><div class="line">paint.setStrokeWidth (<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">paint.setAntiAlias(<span class="keyword">true</span>); <span class="comment">//指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢  </span></div><div class="line">paint.setTextSize(<span class="number">60</span>);<span class="comment">//设置文字大小  </span></div><div class="line">paint.setStyle(Paint.Style.STROKE);<span class="comment">//绘图样式，设置为填充  </span></div><div class="line">  </div><div class="line">String familyName = <span class="string">"宋体"</span>;  </div><div class="line">Typeface font = Typeface.create(familyName,Typeface.NORMAL);  </div><div class="line">paint.setTypeface(font);  </div><div class="line">canvas.drawText(<span class="string">"欢迎光临Harvic的博客"</span>,<span class="number">10</span>,<span class="number">100</span>, paint);</div></pre></td></tr></table></figure>
<h6 id="2、自字义字体"><a href="#2、自字义字体" class="headerlink" title="2、自字义字体"></a>2、自字义字体</h6><p>自定义字体的话，我们就需要从外部字体文件加载我们所需要的字形的，从外部文件加载字形所使用的Typeface构造函数如下面三个：</p>
<pre><code>Typeface    createFromAsset(AssetManager mgr, String path) //通过从Asset中获取外部字体来显示字体样式
Typeface    createFromFile(String path)//直接从路径创建
Typeface    createFromFile(File path)//从外部路径来创建字体样式
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义字体，，，迷你简罗卜  </span></div><div class="line">Paint paint=<span class="keyword">new</span> Paint();  </div><div class="line">paint.setColor(Color.RED);  <span class="comment">//设置画笔颜色      </span></div><div class="line">  </div><div class="line">paint.setStrokeWidth (<span class="number">5</span>);<span class="comment">//设置画笔宽度  </span></div><div class="line">paint.setAntiAlias(<span class="keyword">true</span>); <span class="comment">//指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢  </span></div><div class="line">paint.setTextSize(<span class="number">60</span>);<span class="comment">//设置文字大小  </span></div><div class="line">paint.setStyle(Paint.Style.FILL);<span class="comment">//绘图样式，设置为填充  </span></div><div class="line">  </div><div class="line">AssetManager mgr=m_context.getAssets();<span class="comment">//得到AssetManager  </span></div><div class="line">Typeface typeface=Typeface.createFromAsset(mgr, <span class="string">"fonts/jian_luobo.ttf"</span>);<span class="comment">//根据路径得到Typeface  </span></div><div class="line">paint.setTypeface(typeface);  </div><div class="line">Log.v(<span class="string">"msg"</span>,typeface.toString());  </div><div class="line">canvas.drawText(<span class="string">"欢迎光临Harvic的博客"</span>,<span class="number">10</span>,<span class="number">100</span>, paint);<span class="comment">//两个构造函数</span></div></pre></td></tr></table></figure>
<h3 id="五、区域-Range"><a href="#五、区域-Range" class="headerlink" title="五、区域(Range)"></a>五、区域(Range)</h3><h4 id="一、构造Region"><a href="#一、构造Region" class="headerlink" title="一、构造Region"></a>一、构造Region</h4><p>Region，中文意思即区域的意思，它表示的是canvas图层上的某一块封闭的区域。</p>
<h5 id="1、基本构造函数"><a href="#1、基本构造函数" class="headerlink" title="1、基本构造函数"></a>1、基本构造函数</h5><pre><code>public Region()  //创建一个空的区域  
public Region(Region region) //拷贝一个region的范围  
public Region(Rect r)  //创建一个矩形的区域  
public Region(int left, int top, int right, int bottom) //创建一个矩形的区域 
</code></pre><ul>
<li>第一个还要配合其它函数使用，暂时不提。</li>
<li>第二个构造函数是通过其它的Region来复制一个同样的Region变量</li>
<li>第三个，第四个才是正规常的，根据一个矩形或矩形的左上角和右下角点构造出一个矩形区域</li>
</ul>
<h5 id="2、间接构造函数"><a href="#2、间接构造函数" class="headerlink" title="2、间接构造函数"></a>2、间接构造函数</h5><ul>
<li>public void setEmpty()  //从某种意义上讲置空也是一个构造函数，即将原来的一个区域变量变成了一个空变量，要再利用其它的Set方法重新构造区域。</li>
<li>public boolean set(Region region)   //利用新的区域值来替换原来的区域</li>
<li>public boolean set(Rect r)   //利用矩形所代表的区域替换原来的区域</li>
<li>public boolean set(int left, int top, int right, int bottom)   //根据矩形的两个点构造出矩形区域来替换原来的区域值</li>
<li>public boolean setPath(Path path, Region clip)   //根据路径的区域与某区域的交集，构造出新区域，这个后面具体讲解</li>
</ul>
<p><strong>注意</strong>：无论调用Set系列函数的Region是不是有区域值，当调用Set系列函数后，原来的区域值就会被替换成Set函数里的区域。</p>
<h5 id="3、使用SetPath（）构造不规则区域"><a href="#3、使用SetPath（）构造不规则区域" class="headerlink" title="3、使用SetPath（）构造不规则区域"></a>3、使用SetPath（）构造不规则区域</h5><pre><code>boolean setPath (Path path, Region clip)
</code></pre><ul>
<li>Path path：用来构造的区域的路径</li>
<li>Region clip：与前面的path所构成的路径取交集，并将两交集设置为最终的区域</li>
</ul>
<p>指定另一个区域来取共同的交集，当然如果想显示路径构造的区域，Region clip参数可以传一个比Path范围大的多的区域，取完交集之后，当然是Path参数所对应的区域喽。</p>
<h4 id="二、矩形集枚举区域——RegionIterator类"><a href="#二、矩形集枚举区域——RegionIterator类" class="headerlink" title="二、矩形集枚举区域——RegionIterator类"></a>二、矩形集枚举区域——RegionIterator类</h4><p>RegionIterator类，实现了获取组成区域的矩形集的功能。</p>
<pre><code>RegionIterator(Region region) //根据区域构建对应的矩形集
boolean    next(Rect r) //获取下一个矩形，结果保存在参数Rect r中
</code></pre><h4 id="三、区域的合并、交叉等操作"><a href="#三、区域的合并、交叉等操作" class="headerlink" title="三、区域的合并、交叉等操作"></a>三、区域的合并、交叉等操作</h4><p>无论是区域还是矩形，都会涉及到与另一个区域的一些操作，比如取交集、取并集等，涉及到的函数有：</p>
<pre><code>public final boolean union(Rect r)   
public boolean op(Rect r, Op op)
public boolean op(int left, int top, int right, int bottom, Op op)   
public boolean op(Region region, Op op)   
public boolean op(Rect rect, Region region, Op op)   
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">假设用region1  去组合region2     </div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Op &#123;    </div><div class="line">        DIFFERENCE(<span class="number">0</span>), <span class="comment">//最终区域为region1 与 region2不同的区域    </span></div><div class="line">        INTERSECT(<span class="number">1</span>), <span class="comment">// 最终区域为region1 与 region2相交的区域    </span></div><div class="line">        UNION(<span class="number">2</span>),      <span class="comment">//最终区域为region1 与 region2组合一起的区域    </span></div><div class="line">        XOR(<span class="number">3</span>),        <span class="comment">//最终区域为region1 与 region2相交之外的区域    </span></div><div class="line">        REVERSE_DIFFERENCE(<span class="number">4</span>), <span class="comment">//最终区域为region2 与 region1不同的区域    </span></div><div class="line">        REPLACE(<span class="number">5</span>); <span class="comment">//最终区域为为region2的区域    </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702115560020140905091401375.png" alt="201702115560020140905091401375.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> android.content.Context;  </div><div class="line"><span class="keyword">import</span> android.graphics.Canvas;  </div><div class="line"><span class="keyword">import</span> android.graphics.Color;  </div><div class="line"><span class="keyword">import</span> android.graphics.Paint;  </div><div class="line"><span class="keyword">import</span> android.graphics.Rect;  </div><div class="line"><span class="keyword">import</span> android.graphics.Region;  </div><div class="line"><span class="keyword">import</span> android.graphics.Paint.Style;  </div><div class="line"><span class="keyword">import</span> android.graphics.Region.Op;  </div><div class="line"><span class="keyword">import</span> android.graphics.RegionIterator;  </div><div class="line"><span class="keyword">import</span> android.view.View;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRegionView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRegionView</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context);  </div><div class="line">        <span class="comment">// TODO Auto-generated constructor stub  </span></div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="comment">// TODO Auto-generated method stub  </span></div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">          </div><div class="line">        <span class="comment">//构造两个矩形  </span></div><div class="line">        Rect rect1 = <span class="keyword">new</span> Rect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">200</span>);  </div><div class="line">        Rect rect2 = <span class="keyword">new</span> Rect(<span class="number">200</span>,<span class="number">0</span>,<span class="number">300</span>,<span class="number">300</span>);  </div><div class="line">          </div><div class="line">        <span class="comment">//构造一个画笔，画出矩形轮廓  </span></div><div class="line">        Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">        paint.setColor(Color.RED);  </div><div class="line">        paint.setStyle(Style.STROKE);  </div><div class="line">        paint.setStrokeWidth(<span class="number">2</span>);  </div><div class="line">          </div><div class="line">        canvas.drawRect(rect1, paint);  </div><div class="line">        canvas.drawRect(rect2, paint);  </div><div class="line">          </div><div class="line">          </div><div class="line">          </div><div class="line">        <span class="comment">//构造两个Region  </span></div><div class="line">        Region region = <span class="keyword">new</span> Region(rect1);  </div><div class="line">        Region region2= <span class="keyword">new</span> Region(rect2);  </div><div class="line">  </div><div class="line">        <span class="comment">//取两个区域的交集        </span></div><div class="line">        region.op(region2, Op.INTERSECT);  </div><div class="line">          </div><div class="line">        <span class="comment">//再构造一个画笔,填充Region操作结果  </span></div><div class="line">        Paint paint_fill = <span class="keyword">new</span> Paint();  </div><div class="line">        paint_fill.setColor(Color.GREEN);  </div><div class="line">        paint_fill.setStyle(Style.FILL);  </div><div class="line">        drawRegion(canvas, region, paint_fill);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawRegion</span><span class="params">(Canvas canvas,Region rgn,Paint paint)</span>  </span></div><div class="line">&#123;  </div><div class="line">    RegionIterator iter = <span class="keyword">new</span> RegionIterator(rgn);  </div><div class="line">    Rect r = <span class="keyword">new</span> Rect();  </div><div class="line">      </div><div class="line">    <span class="keyword">while</span> (iter.next(r)) &#123;  </div><div class="line">      canvas.drawRect(r, paint);  </div><div class="line">    &#125;   </div><div class="line">&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702111494020140905095358720.png" alt="201702111494020140905095358720.png"></p>
<h4 id="四、其它一些方法"><a href="#四、其它一些方法" class="headerlink" title="四、其它一些方法"></a>四、其它一些方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**几个判断方法*/</span>    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//判断该区域是否为空    </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isRect</span><span class="params">()</span></span>; <span class="comment">//是否是一个矩阵    </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isComplex</span><span class="params">()</span></span>;<span class="comment">//是否是多个矩阵组合    </span></div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment">/**一系列的getBound方法，返回一个Region的边界*/</span>    </div><div class="line"><span class="function"><span class="keyword">public</span> Rect <span class="title">getBounds</span><span class="params">()</span>     </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBounds</span><span class="params">(Rect r)</span>     </div><div class="line"><span class="keyword">public</span> Path <span class="title">getBoundaryPath</span><span class="params">()</span>     </div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getBoundaryPath</span><span class="params">(Path path)</span>     </div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment">/**一系列的判断是否包含某点 和是否相交*/</span>    </div><div class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>;<span class="comment">//是否包含某点    </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quickContains</span><span class="params">(Rect r)</span>   <span class="comment">//是否包含某矩形  </span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">quickContains</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right,    </span></div><div class="line">                                        <span class="keyword">int</span> bottom) <span class="comment">//是否没有包含某矩阵形   </span></div><div class="line"> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quickReject</span><span class="params">(Rect r)</span> <span class="comment">//是否没和该矩形相交    </span></div><div class="line"> <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">quickReject</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span>; <span class="comment">//是否没和该矩形相交    </span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">quickReject</span><span class="params">(Region rgn)</span></span>;  <span class="comment">//是否没和该矩形相交    </span></div><div class="line">    </div><div class="line"><span class="comment">/**几个平移变换的方法*/</span>    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translate</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span>     </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">translate</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, Region dst)</span>;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scale</span><span class="params">(<span class="keyword">float</span> scale)</span> <span class="comment">//hide    </span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">scale</span><span class="params">(<span class="keyword">float</span> scale, Region dst)</span>;<span class="comment">//hide</span></div></pre></td></tr></table></figure>
<h4 id="五、裁剪"><a href="#五、裁剪" class="headerlink" title="五、裁剪"></a>五、裁剪</h4><h5 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h5><p>裁剪Clip，即裁剪Canvas图层，我们绘制的东西，只能在裁剪区域的范围能才能显示出来。<br>裁剪画布是利用Clip系列函数，通过与Rect、Path、Region取交、并、差等集合运算来获得最新的画布形状。除了调用Save、Restore函数以外，这个操作是不可逆的，一但Canvas画布被裁剪，就不能再被恢复！</p>
<p>Clip系列函数如下：</p>
<pre><code>boolean    clipPath(Path path)
boolean    clipPath(Path path, Region.Op op)
boolean    clipRect(Rect rect, Region.Op op)
boolean    clipRect(RectF rect, Region.Op op)
boolean    clipRect(int left, int top, int right, int bottom)
boolean    clipRect(float left, float top, float right, float bottom)
boolean    clipRect(RectF rect)
boolean    clipRect(float left, float top, float right, float bottom, Region.Op op)
boolean    clipRect(Rect rect)
boolean    clipRegion(Region region)
boolean    clipRegion(Region region, Region.Op op)
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span>  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">	Paint paint=<span class="keyword">new</span> Paint();   </div><div class="line">   canvas.save();   </div><div class="line">   canvas.clipRect(<span class="keyword">new</span> Rect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>));  </div><div class="line">   canvas.drawColor(Color.BLUE);<span class="comment">//裁剪区域的rect变为蓝色   </span></div><div class="line">   canvas.drawRect(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>), paint);<span class="comment">//在裁剪的区域之外，不能显示   </span></div><div class="line">   canvas.drawCircle(<span class="number">150</span>,<span class="number">150</span>, <span class="number">50</span>, paint);<span class="comment">//在裁剪区域之内，能显示  </span></div><div class="line">   canvas.restore();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>裁剪并不像Matrix变换，它相对于mutable bitmap的坐标是不会改变的。所以超出裁剪区域的绘制不会被显示</p>
<p>裁剪的保存和回滚：canvas.save()和canvas.restore()不仅对matrix有效，同样对clip有类似的效果。</p>
<h5 id="2、裁剪的方式"><a href="#2、裁剪的方式" class="headerlink" title="2、裁剪的方式"></a>2、裁剪的方式</h5><ul>
<li>最基本的clipRect，裁剪一个矩形</li>
<li>clipPath，裁剪Path包括的范围，Path所包括的范围不是空的才有效。</li>
<li>clipRegion。</li>
</ul>
<p>clipRegion与clipRect和clipPath要使用当前的matrix进行变换不同。clipRegion不会进行转换。也就是说canvas的matrix对clipRegion没有影响。</p>
<h5 id="3、示例"><a href="#3、示例" class="headerlink" title="3、示例"></a>3、示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClippingRegion</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">        setContentView(<span class="keyword">new</span> SampleView(<span class="keyword">this</span>));  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">  </div><div class="line">        <span class="keyword">private</span> Bitmap mBitmap;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> limitLength = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> width;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> heigth;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIP_HEIGHT = <span class="number">30</span>;  </div><div class="line">  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> status = HIDE;<span class="comment">//显示还是隐藏的状态，最开始为HIDE  </span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SHOW = <span class="keyword">true</span>;<span class="comment">//显示图片   </span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> HIDE = <span class="keyword">false</span>;<span class="comment">//隐藏图片  </span></div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SampleView</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">            <span class="keyword">super</span>(context);  </div><div class="line">            mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image1);  </div><div class="line">            limitLength = width = mBitmap.getWidth();  </div><div class="line">            heigth = mBitmap.getHeight();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">            Region region = <span class="keyword">new</span> Region();  </div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;  </div><div class="line">            <span class="keyword">while</span> (i * CLIP_HEIGHT &lt;= heigth) &#123;<span class="comment">//计算clip的区域  </span></div><div class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;  </div><div class="line">                    region.union(<span class="keyword">new</span> Rect(<span class="number">0</span>, i * CLIP_HEIGHT, limitLength, (i + <span class="number">1</span>) * CLIP_HEIGHT));  </div><div class="line">                &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                    region.union(<span class="keyword">new</span> Rect(width - limitLength, i * CLIP_HEIGHT, width, (i + <span class="number">1</span>)  </div><div class="line">                            * CLIP_HEIGHT));  </div><div class="line">                &#125;  </div><div class="line">                i++;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            canvas.clipRegion(region);  </div><div class="line">            canvas.drawBitmap(mBitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> Paint());  </div><div class="line">            <span class="keyword">if</span> (status == HIDE) &#123;<span class="comment">//如果此时是隐藏  </span></div><div class="line">                limitLength -= <span class="number">5</span>;  </div><div class="line">                <span class="keyword">if</span>(limitLength&lt;=<span class="number">0</span>)  </div><div class="line">                    status=SHOW;  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果此时是显示  </span></div><div class="line">                limitLength += <span class="number">5</span>;  </div><div class="line">                <span class="keyword">if</span>(limitLength&gt;=width)  </div><div class="line">                    status=HIDE;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            invalidate();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170211919281355989830_7413.jpg" alt="20170211919281355989830_7413.jpg"></p>
<h3 id="六、canvas变换与操作"><a href="#六、canvas变换与操作" class="headerlink" title="六、canvas变换与操作"></a>六、canvas变换与操作</h3><h4 id="一、平移-translate"><a href="#一、平移-translate" class="headerlink" title="一、平移(translate)"></a>一、平移(translate)</h4><p>canvas中有一个函数translate（）是用来实现画布平移的，画布的原状是以左上角为原点，向左是X轴正方向，向下是Y轴正方向.</p>
<p><strong>注意</strong>：canvas移动之前设置的(0,0)的图形位置和移动之后设置的(0,0)的图形位置显示结果不一样。</p>
<h4 id="二、屏幕显示与Canvas的关系"><a href="#二、屏幕显示与Canvas的关系" class="headerlink" title="二、屏幕显示与Canvas的关系"></a>二、屏幕显示与Canvas的关系</h4><ul>
<li>调用canvas.drawRect(rect1, paint_green);时，产生一个Canvas透明图层，由于当时还没有对坐标系平移，所以坐标原点是（0，0）；再在系统在Canvas上画好之后，覆盖到屏幕上显示出来，过程如下图：</li>
</ul>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702121882020140905170403218.jpeg" alt="201702121882020140905170403218.jpeg"></p>
<ul>
<li>然后再第二次调用canvas.drawRect(rect1, paint_red);时，又会重新产生一个全新的Canvas画布，但此时画布坐标已经改变了，即向右和向下分别移动了100像素，所以此时的绘图方式为：（合成视图，从上往下看的合成方式）</li>
</ul>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702121098420140905172349030.jpeg" alt="201702121098420140905172349030.jpeg"></p>
<ul>
<li>上图展示了，上层的Canvas图层与底部的屏幕的合成过程，由于Canvas画布已经平移了100像素，所以在画图时是以新原点来产生视图的，然后合成到屏幕上，这就是我们上面最终看到的结果了。我们看到屏幕移动之后，有一部分超出了屏幕的范围，那超出范围的图像显不显示呢，当然不显示了！也就是说，Canvas上虽然能画上，但超出了屏幕的范围，是不会显示的。</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>每次调用canvas.drawXXXX系列函数来绘图进，都会产生一个全新的Canvas画布。</li>
<li>如果在DrawXXX前，调用平移、旋转等函数来对Canvas进行了操作，那么这个操作是不可逆的！每次产生的画布的最新位置都是这些操作后的位置。（关于Save()、Restore()的画布可逆问题的后面再讲）</li>
<li>在Canvas与屏幕合成时，超出屏幕范围的图像是不会显示出来的。</li>
</ul>
<h4 id="三、旋转-Rotate"><a href="#三、旋转-Rotate" class="headerlink" title="三、旋转(Rotate)"></a>三、旋转(Rotate)</h4><p>画布的旋转是默认是围绕坐标原点来旋转的，这里容易产生错觉，看起来觉得是图片旋转了，其实我们旋转的是画布，以后在此画布上画的东西显示出来的时候全部看起来都是旋转的。其实Roate函数有两个构造函数：</p>
<pre><code>void rotate(float degrees)
void rotate (float degrees, float px, float py)
</code></pre><ul>
<li>第一个构造函数直接输入旋转的度数，正数是顺时针旋转，负数指逆时针旋转，它的旋转中心点是原点（0，0）</li>
<li>第二个构造函数除了度数以外，还可以指定旋转的中心点坐标（px,py）</li>
</ul>
<h4 id="四、缩放-scale"><a href="#四、缩放-scale" class="headerlink" title="四、缩放(scale)"></a>四、缩放(scale)</h4><pre><code>public void scale (float sx, float sy);
public final void scale (float sx, float sy, float px, float py);
</code></pre><h4 id="五、扭曲-skew"><a href="#五、扭曲-skew" class="headerlink" title="五、扭曲(skew)"></a>五、扭曲(skew)</h4><pre><code>void skew (float sx, float sy)
</code></pre><ul>
<li>float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值</li>
<li>float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值</li>
</ul>
<h4 id="六、画布的保存与恢复（save-、restore-）"><a href="#六、画布的保存与恢复（save-、restore-）" class="headerlink" title="六、画布的保存与恢复（save()、restore()）"></a>六、画布的保存与恢复（save()、restore()）</h4><p>我们为了实现一些效果不得不对画布进行操作，但操作完了，画布状态也改变了，这会严重影响到后面的画图操作。如果我们能对画布的大小和状态（旋转角度、扭曲等）进行实时保存和恢复就最好了。</p>
<pre><code>int save()   //每次调用Save()函数，都会把当前的画布的状态进行保存，然后放入特定的栈中；
void    restore()        //每当调用Restore()函数，就会把栈中最顶层的画布状态取出来，并按照这个状态恢复当前的画布，并在这个画布上做画。
</code></pre><h3 id="七、drawText-详解"><a href="#七、drawText-详解" class="headerlink" title="七、drawText()详解"></a>七、drawText()详解</h3><h4 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h4><p>在canvas在利用drawText绘制文字时，是有规则的，这个规则就是基线！<br>我们先来看一下什么是基线：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702122188720151229090416052.png" alt="201702122188720151229090416052.png"><br>也就是说，只要基线的位置定了，那文字的位置必然是定了的！</p>
<h4 id="2、canvas-drawText"><a href="#2、canvas-drawText" class="headerlink" title="2、canvas.drawText()"></a>2、canvas.drawText()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">* text:要绘制的文字 </div><div class="line">* x：绘制原点x坐标 </div><div class="line">* y：绘制原点y坐标 </div><div class="line">* paint:用来做画的画笔 </div><div class="line">*/  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(String text, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></span></div></pre></td></tr></table></figure>
<p>上面这个构造函数是最常用的drawText方法，传进去一个String对象就能画出对应的文字。<br>但这里有两个参数需要非常注意，表示原点坐标的x和y.很多同学可能会认为，这里传进去的原点参数(x,y)是所在绘制文字所在矩形的左上角的点。但实际上并不是！<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702127119520151229090636780.jpeg" alt="201702127119520151229090636780.jpeg"><br>在(x,y)中最让人捉急的是y坐标，一般而言，(x，y)所代表的位置是所画图形对应的矩形的左上角点。但在drawText中是非常例外的，y所代表的是基线的位置！</p>
<h4 id="3、paint-setTextAlign-Paint-Align-XXX"><a href="#3、paint-setTextAlign-Paint-Align-XXX" class="headerlink" title="3、paint.setTextAlign(Paint.Align.XXX)"></a>3、paint.setTextAlign(Paint.Align.XXX)</h4><p>paint.setTextAlign()来设置文字在矩形中的相对位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">* 其中Align的取值为：Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT </div><div class="line">*/  </div><div class="line">Paint::setTextAlign(Align align);</div></pre></td></tr></table></figure>
<ul>
<li>Panit.Align.LEFT:原点在所绘制文字的左边</li>
<li>Paint.Align.CENTER:原点在所绘制文字的中间</li>
<li>Paint.Align.RIGHT:原点在所绘制文字的右边</li>
</ul>
<h4 id="4、drawText的四线格与FontMetrics"><a href="#4、drawText的四线格与FontMetrics" class="headerlink" title="4、drawText的四线格与FontMetrics"></a>4、drawText的四线格与FontMetrics</h4><h5 id="1、Text的绘图四线格"><a href="#1、Text的绘图四线格" class="headerlink" title="1、Text的绘图四线格"></a>1、Text的绘图四线格</h5><p>前面我们讲了基线，其实除了基线，系统在绘制Text时，还是有其它线的，我们来看个图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702124934520151229092331153.jpeg" alt="201702124934520151229092331153.jpeg"><br>除了基线以外，如上图所示，另外还有四条线，分别是ascent,descent,top,bottom，他们的意义分别是：</p>
<ul>
<li>ascent: 系统建议的，绘制单个字符时，字符应当的最高高度所在线</li>
<li>descent:系统建议的，绘制单个字符时，字符应当的最低高度所在线</li>
<li>top: 可绘制的最高高度所在线</li>
<li>bottom: 可绘制的最低高度所在线</li>
</ul>
<p>我们在绘制文字时，ascent是推荐的绘制文字的最高高度，就表示在绘制文字时，尽力要在这个最高高度以下绘制文字。descent是推荐的绘制文字的最底高度线，同样表示是在绘制文字时尽量在这个descent线以上来绘制文字。而top线则指该文字可以绘制的最高高度线，bottom则是表示该文字可以绘制的最低高度线。ascent,descent是系统建议上的绘制高度，而top,bottom则是物理上屏幕最高，最低可以画的高度值。他们的差别与我们上面说的视频处理的安全框和屏幕的道理是一样的。</p>
<h5 id="2、FontMetrics"><a href="#2、FontMetrics" class="headerlink" title="2、FontMetrics"></a>2、FontMetrics</h5><h6 id="（1）、fontMetrics概述"><a href="#（1）、fontMetrics概述" class="headerlink" title="（1）、fontMetrics概述"></a>（1）、fontMetrics概述</h6><p>面我们讲了，系统在画文字时的五条线，baseline、ascent、descent、top、bottom我们知道baseline的位置是我们在构造drawText()时的参数y来决定的，那ascent,descent,top,bottom这些线的位置要怎么计算出来呢？<br>Android给我们提供了一个类：FontMetrics，它里面有四个成员变量：</p>
<pre><code>FontMetrics::ascent;  
FontMetrics::descent;  
FontMetrics::top;  
FontMetrics::bottom; 
</code></pre><ul>
<li>ascent = ascent线的y坐标 - baseline线的y坐标；</li>
<li>descent = descent线的y坐标 - baseline线的y坐标；</li>
<li>top = top线的y坐标 - baseline线的y坐标；</li>
<li>bottom = bottom线的y坐标 - baseline线的y坐标；</li>
</ul>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702126992720151229092943955.png" alt="201702126992720151229092943955.png"></p>
<ul>
<li><p>ascent = ascent线的y坐标 - baseline线的y坐标；<br>FontMetrics的这几个变量的值都是以baseline为基准的，对于ascent来说，baseline线在ascent线之下，所以必然baseline的y值要大于ascent线的y值，所以ascent变量的值是负的。</p>
</li>
<li><p>descent = descent线的y坐标 - baseline线的y坐标；<br>descent线在baseline线之下，所以必然descent线的y坐标要大于baseline线的y坐标，所以descent变量的值必然是正数。</p>
</li>
</ul>
<h6 id="（2）、得到Text四线格的各线位置"><a href="#（2）、得到Text四线格的各线位置" class="headerlink" title="（2）、得到Text四线格的各线位置"></a>（2）、得到Text四线格的各线位置</h6><ul>
<li>ascent线Y坐标 = baseline线Y坐标 + fontMetric.ascent; </li>
<li>descent线Y坐标 = baseline线的y坐标 + fontMetric.descent；</li>
<li>top线Y坐标 = baseline线的y坐标 + fontMetric.top；</li>
<li>bottom线Y坐标 = baseline线的y坐标 + fontMetric.bottom；</li>
</ul>
<h6 id="（3）、获取FontMetrics对象"><a href="#（3）、获取FontMetrics对象" class="headerlink" title="（3）、获取FontMetrics对象"></a>（3）、获取FontMetrics对象</h6><p>获取FontMetrics对象是根据paint对象来获取的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">Paint.FontMetrics fm = paint.getFontMetrics();  </div><div class="line">Paint.FontMetricsInt fmInt = paint.getFontMetricsInt();</div></pre></td></tr></table></figure>
<h6 id="（4）、实例：计算Text四线格位置"><a href="#（4）、实例：计算Text四线格位置" class="headerlink" title="（4）、实例：计算Text四线格位置"></a>（4）、实例：计算Text四线格位置</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">    <span class="keyword">int</span> baseLineY = <span class="number">200</span>;  </div><div class="line">    <span class="keyword">int</span> baseLineX = <span class="number">0</span> ;  </div><div class="line">  </div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">    <span class="comment">//写文字  </span></div><div class="line">    paint.setColor(Color.GREEN);  </div><div class="line">    paint.setTextSize(<span class="number">120</span>); <span class="comment">//以px为单位  </span></div><div class="line">    paint.setTextAlign(Paint.Align.LEFT);  </div><div class="line">    canvas.drawText(<span class="string">"harvic\'s blog"</span>, baseLineX, baseLineY, paint);  </div><div class="line">  </div><div class="line">    <span class="comment">//计算各线在位置  </span></div><div class="line">    Paint.FontMetrics fm = paint.getFontMetrics();  </div><div class="line">    <span class="keyword">float</span> ascent = baseLineY + fm.ascent;  </div><div class="line">    <span class="keyword">float</span> descent = baseLineY + fm.descent;  </div><div class="line">    <span class="keyword">float</span> top = baseLineY + fm.top;  </div><div class="line">    <span class="keyword">float</span> bottom = baseLineY + fm.bottom;  </div><div class="line">  </div><div class="line">    <span class="comment">//画基线  </span></div><div class="line">    paint.setColor(Color.RED);  </div><div class="line">    canvas.drawLine(baseLineX, baseLineY, <span class="number">3000</span>, baseLineY, paint);  </div><div class="line">  </div><div class="line">    <span class="comment">//画top  </span></div><div class="line">    paint.setColor(Color.BLUE);  </div><div class="line">    canvas.drawLine(baseLineX, top, <span class="number">3000</span>, top, paint);  </div><div class="line">  </div><div class="line">    <span class="comment">//画ascent  </span></div><div class="line">    paint.setColor(Color.GREEN);  </div><div class="line">    canvas.drawLine(baseLineX, ascent, <span class="number">3000</span>, ascent, paint);  </div><div class="line">  </div><div class="line">    <span class="comment">//画descent  </span></div><div class="line">    paint.setColor(Color.YELLOW);  </div><div class="line">    canvas.drawLine(baseLineX, descent, <span class="number">3000</span>, descent, paint);  </div><div class="line">  </div><div class="line">    <span class="comment">//画bottom  </span></div><div class="line">    paint.setColor(Color.RED);  </div><div class="line">    canvas.drawLine(baseLineX, bottom, <span class="number">3000</span>, bottom, paint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、所绘文字宽度、高度和最小矩形获取"><a href="#3、所绘文字宽度、高度和最小矩形获取" class="headerlink" title="3、所绘文字宽度、高度和最小矩形获取"></a>3、所绘文字宽度、高度和最小矩形获取</h5><p>这部分，我们将讲解如何获取所绘制字符串所占区域的高度、宽度和仅包裹字符串的最小矩形。</p>
<h6 id="1、字符串所占高度和宽度"><a href="#1、字符串所占高度和宽度" class="headerlink" title="1、字符串所占高度和宽度"></a>1、字符串所占高度和宽度</h6><p>字符串所占高度很容易得到，直接用bottom线所在位置的Y坐标减去top线所在位置的Y坐标就是字符串所占的高度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Paint.FontMetricsInt fm = paint.getFontMetricsInt();  </div><div class="line"><span class="keyword">int</span> top = baseLineY + fm.top;  </div><div class="line"><span class="keyword">int</span> bottom = baseLineY + fm.bottom;  </div><div class="line"><span class="comment">//所占高度  </span></div><div class="line"><span class="keyword">int</span> height = bottom - top;</div></pre></td></tr></table></figure></p>
<h6 id="（2）、宽度"><a href="#（2）、宽度" class="headerlink" title="（2）、宽度"></a>（2）、宽度</h6><p>宽度是非常容易得到的，直接利用下面的函数就可以得到</p>
<pre><code>int width = paint.measureText(String text);  
</code></pre><h6 id="（3）、最小矩形"><a href="#（3）、最小矩形" class="headerlink" title="（3）、最小矩形"></a>（3）、最小矩形</h6><ul>
<li>概述<br>要获取最小矩形，也是通过系统函数来获取的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 获取指定字符串所对应的最小矩形，以（0，0）点所在位置为基线 </div><div class="line"> * <span class="doctag">@param</span> text  要测量最小矩形的字符串 </div><div class="line"> * <span class="doctag">@param</span> start 要测量起始字符在字符串中的索引 </div><div class="line"> * <span class="doctag">@param</span> end   所要测量的字符的长度 </div><div class="line"> * <span class="doctag">@param</span> bounds 接收测量结果 </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTextBounds</span><span class="params">(String text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Rect bounds)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>得到最小矩形的实际位置</li>
</ul>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702126981920151229094300488.png" alt="201702126981920151229094300488.png"></p>
<p>在上面这个图中，我们将黑色矩形平行下移距离Y（黄色线依照的是基线的位置），那么平移后的左上角点的y坐标就是 y2 = y1 + Y;<br>同样的道理，由于paint.getTextBounds（）得到最小矩形的基线是y = 0;那我们直接将这个矩形移动baseline的距离就可以得到这个矩形实际应当在的位置了。<br>所以矩形应当所在实际位置的坐标是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Rect minRect = <span class="keyword">new</span> Rect();  </div><div class="line">paint.getTextBounds(text,<span class="number">0</span>,text.length(),minRect);  </div><div class="line"><span class="comment">//最小矩形，实际top位置  </span></div><div class="line"><span class="keyword">int</span> minTop = bounds.top + baselineY;  </div><div class="line"><span class="comment">//最小矩形，实际bottom位置  </span></div><div class="line"><span class="keyword">int</span> minBottom = bounds.bottom + baselineY;</div></pre></td></tr></table></figure>
<h5 id="4、定点写字"><a href="#4、定点写字" class="headerlink" title="4、定点写字"></a>4、定点写字</h5><p>讲完上面的三部分，这篇文章所要讲的知识点基本就结束了，这部分其实就是应用的范畴了，在这部分中，我们将讲述，当我们设定一个点，如何到得基线位置，进而画出字符串。</p>
<h6 id="1、给定左上顶点绘图"><a href="#1、给定左上顶点绘图" class="headerlink" title="1、给定左上顶点绘图"></a>1、给定左上顶点绘图</h6><p>这部分，我们假定给出所要绘制矩形的左上角顶点坐标，然后画出这个文字。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702126035920151229094618817.png" alt="201702126035920151229094618817.png"></p>
<p>在这个图中，我们给定左上角的位置，即(left,top)；我们知道要画文字，drawText（）中传进去的Y坐标是基线的位置，所以我们就必须根据top的位置计算出baseline的位置。<br>我们来看一个公式：<br>FontMetrics.top = top - baseline;<br>所以baseline = top - FontMetrics.top;<br>因为FontMetrics.top是可以得到的，又因为我们的top坐标是给定的，所以通过这个公式就能得到baseline的位置了。<br>下面举个例子来说明一下根据矩形左上项点绘制文字的过程：<br>先看下效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702123259820151229094642115.png" alt="201702123259820151229094642115.png"><br>在这个效果图中，因为我们会给定矩形左上角顶点(left,top)，所以们先画出top线的位置，然后计算出baseline的位置，并画出来。最后根据baseline把文字写出来。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">    String text = <span class="string">"harvic\'s blog"</span>;  </div><div class="line">    <span class="keyword">int</span> top = <span class="number">200</span>;  </div><div class="line">    <span class="keyword">int</span> baseLineX = <span class="number">0</span> ;  </div><div class="line">      </div><div class="line">    <span class="comment">//设置paint  </span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">    paint.setTextSize(<span class="number">120</span>); <span class="comment">//以px为单位  </span></div><div class="line">    paint.setTextAlign(Paint.Align.LEFT);  </div><div class="line">      </div><div class="line">    <span class="comment">//画top线  </span></div><div class="line">    paint.setColor(Color.YELLOW);  </div><div class="line">    canvas.drawLine(baseLineX, top, <span class="number">3000</span>, top, paint);  </div><div class="line">      </div><div class="line">    <span class="comment">//计算出baseLine位置  </span></div><div class="line">    Paint.FontMetricsInt fm = paint.getFontMetricsInt();  </div><div class="line">    <span class="keyword">int</span> baseLineY = top - fm.top;  </div><div class="line">      </div><div class="line">    <span class="comment">//画基线  </span></div><div class="line">    paint.setColor(Color.RED);  </div><div class="line">    canvas.drawLine(baseLineX, baseLineY, <span class="number">3000</span>, baseLineY, paint);  </div><div class="line">      </div><div class="line">    <span class="comment">//写文字  </span></div><div class="line">    paint.setColor(Color.GREEN);  </div><div class="line">    canvas.drawText(text, baseLineX, baseLineY, paint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码，比较简单，首先是我们给定top给的位置int top = 200;然后根据top线位置计算出baseline所在位置,并画出来。</p>
<h6 id="2、给定中间线位置绘图"><a href="#2、给定中间线位置绘图" class="headerlink" title="2、给定中间线位置绘图"></a>2、给定中间线位置绘图</h6><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702127453820151229094808805.png" alt="201702127453820151229094808805.png"></p>
<p>在这个图中，总共有四条线：top线，bottom线，baseline和center线；<br>图中center线正是在top线和bottom线的正中间。<br>为了方便推导公式，我另外标了三个距离A,B,C;<br>很显然，距离A和距离C是相等的，都等于文字所在矩形高度以的一半，即：<br>A = C = (bottom - top)/2;<br>又因为bottom = baseline + FontMetrics.bottom;<br>top = baseline+FontMetrics.top;<br>所以，将它们两个代入上面的公式，就可得到：<br>A = C = (FontMetrics.bottom - FontMetrics.top)/2;<br>而距离B,则表示Center线到baseline的距离。<br>很显然距离B = C - (bottom - baseline);<br>又因为<br>FontMetrics.bottom = bottom-baseline;<br>C = A;<br>所以，B = A - FontMetrics.bottom;<br>所以baseline = center + B = center + A - FontMetrics.bottom = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom;</p>
<p>根据上面的推导过程，我们最终可知，当给定中间线center位置以后，baseline的位置为：</p>
<p>baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">      </div><div class="line">    String text = <span class="string">"harvic\'s blog"</span>;  </div><div class="line">    <span class="keyword">int</span> center = <span class="number">200</span>;  </div><div class="line">    <span class="keyword">int</span> baseLineX = <span class="number">0</span> ;  </div><div class="line">  </div><div class="line">    <span class="comment">//设置paint  </span></div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">    paint.setTextSize(<span class="number">120</span>); <span class="comment">//以px为单位  </span></div><div class="line">    paint.setTextAlign(Paint.Align.LEFT);  </div><div class="line">  </div><div class="line">    <span class="comment">//画center线  </span></div><div class="line">    paint.setColor(Color.YELLOW);  </div><div class="line">    canvas.drawLine(baseLineX, center, <span class="number">3000</span>, center, paint);  </div><div class="line">  </div><div class="line">    <span class="comment">//计算出baseLine位置  </span></div><div class="line">    Paint.FontMetricsInt fm = paint.getFontMetricsInt();  </div><div class="line">    <span class="keyword">int</span> baseLineY = center + (fm.bottom - fm.top)/<span class="number">2</span> - fm.bottom;  </div><div class="line">      </div><div class="line">    <span class="comment">//画基线  </span></div><div class="line">    paint.setColor(Color.RED);  </div><div class="line">    canvas.drawLine(baseLineX, baseLineY, <span class="number">3000</span>, baseLineY, paint);  </div><div class="line">  </div><div class="line">    <span class="comment">//写文字  </span></div><div class="line">    paint.setColor(Color.GREEN);  </div><div class="line">    canvas.drawText(text, baseLineX, baseLineY, paint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二、Path之贝赛尔曲线和手势轨迹、水波纹效果"><a href="#二、Path之贝赛尔曲线和手势轨迹、水波纹效果" class="headerlink" title="二、Path之贝赛尔曲线和手势轨迹、水波纹效果"></a>二、Path之贝赛尔曲线和手势轨迹、水波纹效果</h2><h3 id="1、手势轨迹"><a href="#1、手势轨迹" class="headerlink" title="1、手势轨迹"></a>1、手势轨迹</h3><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702121570120160328094622304.gif" alt="201702121570120160328094622304.gif"><br>利用贝塞尔曲线，我们能实现平滑的手势轨迹效果 </p>
<h3 id="2、水波纹效果"><a href="#2、水波纹效果" class="headerlink" title="2、水波纹效果"></a>2、水波纹效果</h3><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702126756520160328094655217.gif" alt="201702126756520160328094655217.gif"><br>电池充电时，有些手机会显示水波纹效果，就是这样做出来的。 </p>
<h3 id="3、概述"><a href="#3、概述" class="headerlink" title="3、概述"></a>3、概述</h3><p>在Path中有四个函数与贝赛尔曲线有关：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//二阶贝赛尔  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quadTo</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2)</span>  </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rQuadTo</span><span class="params">(<span class="keyword">float</span> dx1, <span class="keyword">float</span> dy1, <span class="keyword">float</span> dx2, <span class="keyword">float</span> dy2)</span>  </div><div class="line"><span class="comment">//三阶贝赛尔  </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cubicTo</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2,<span class="keyword">float</span> x3, <span class="keyword">float</span> y3)</span>  </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rCubicTo</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2,<span class="keyword">float</span> x3, <span class="keyword">float</span> y3)</span></div></pre></td></tr></table></figure></p>
<h4 id="1、贝赛尔曲线来源"><a href="#1、贝赛尔曲线来源" class="headerlink" title="1、贝赛尔曲线来源"></a>1、贝赛尔曲线来源</h4><p>在数学的数值分析领域中，贝赛尔曲线（Bézier曲线）是电脑图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。<br>贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。</p>
<h4 id="2、贝赛尔曲线公式"><a href="#2、贝赛尔曲线公式" class="headerlink" title="2、贝赛尔曲线公式"></a>2、贝赛尔曲线公式</h4><h5 id="1、一阶贝赛尔曲线"><a href="#1、一阶贝赛尔曲线" class="headerlink" title="1、一阶贝赛尔曲线"></a>1、一阶贝赛尔曲线</h5><p>其公式可概括为：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170212447420160328202051449.jpeg" alt="20170212447420160328202051449.jpeg"></p>
<p>对应动画演示为：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702129696620160328202312248.gif" alt="201702129696620160328202312248.gif"></p>
<p>P0为起点、P1为终点，t表示当前时间，B(t)表示公式的结果值。<br>注意，曲线的意义就是公式结果B(t)随时间的变化，其取值所形成的轨迹。在动画中，黑色点表示在当前时间t下公式B(t)的取值。而红色的那条线就不在各个时间点下不同取值的B(t)所形成的轨迹。<br>总而言之：对于一阶贝赛尔曲线，大家可以理解为在起始点和终点形成的这条直线上，匀速移动的点。 </p>
<h5 id="2、二阶贝赛尔曲线"><a href="#2、二阶贝赛尔曲线" class="headerlink" title="2、二阶贝赛尔曲线"></a>2、二阶贝赛尔曲线</h5><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702124783720160328202422676.png" alt="201702124783720160328202422676.png"><br>对应的动画：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702124254520160328202508739.gif" alt="201702124254520160328202508739.gif"><br>首先，P0点和P1点形成了一条贝赛尔曲线，还记得我们上面对一阶贝赛尔曲线的总结么：就是一个点在这条直线上做匀速运动；所以P0-P1这条直线上的移动的点就是Q0；<br>同样，P1,P2形成了一条一阶贝赛尔曲线，在这条一阶贝赛尔曲线上，它们的随时间移动的点是Q1<br>最后，动态点Q0和Q1又形成了一条一阶贝赛尔曲线，在它们这条一阶贝赛尔曲线动态移动的点是B<br>而B的移动轨迹就是这个二阶贝赛尔曲线的最终形态。从上面的讲解大家也可以知道，之所以叫它二阶贝赛尔曲线是因为，B的移动轨迹是建立在两个一阶贝赛尔曲线的中间点Q0,Q1的基础上的。<br>在理解了二阶贝赛尔曲线的形成原理以后，我们就不难理解三阶贝赛尔曲线了 </p>
<h5 id="3、三阶贝赛尔曲线"><a href="#3、三阶贝赛尔曲线" class="headerlink" title="3、三阶贝赛尔曲线"></a>3、三阶贝赛尔曲线</h5><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702127999920160328202609692.png" alt="201702127999920160328202609692.png"><br>对应的动画：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702124041720160328202640208.gif" alt="201702124041720160328202640208.gif"><br>首先，这里有三条一阶贝赛尔曲线，分别是P0-P1,P1-P2,P2-P3;<br>他们随时间变化的点分别为Q0，Q1，Q2<br>然后是由Q0，Q1，Q2这三个点，再次连接，形成了两条一阶贝赛尔曲线，分别是Q0—Q1,Q1—Q2;他们随时间变化的点为R0,R1<br>同样，R0和R1同样可以连接形成一条一阶贝赛尔曲线，在R0—R1这条贝赛尔曲线上随时间移动的点是B<br>而B的移动轨迹就是这个三阶贝赛尔曲线的最终形状。<br>从上面的解析大家可以看出，所谓几阶贝赛尔曲线，全部是由一条条一阶贝赛尔曲线搭起来的；<br>在上图中，形成一阶贝赛尔曲线的直线是灰色的，形成二阶贝赛尔曲线线是绿色的，形成三阶贝赛尔曲线的线是蓝色的。 </p>
<h5 id="4、四阶贝赛尔曲线"><a href="#4、四阶贝赛尔曲线" class="headerlink" title="4、四阶贝赛尔曲线"></a>4、四阶贝赛尔曲线</h5><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702127054120160328202826223.gif" alt="201702127054120160328202826223.gif"></p>
<h5 id="5、五阶贝赛尔曲线"><a href="#5、五阶贝赛尔曲线" class="headerlink" title="5、五阶贝赛尔曲线"></a>5、五阶贝赛尔曲线</h5><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702129754420160328202946178.gif" alt="201702129754420160328202946178.gif"></p>
<h4 id="3、贝赛尔曲线与PhotoShop钢笔工具"><a href="#3、贝赛尔曲线与PhotoShop钢笔工具" class="headerlink" title="3、贝赛尔曲线与PhotoShop钢笔工具"></a>3、贝赛尔曲线与PhotoShop钢笔工具</h4><p>这么屌的贝赛尔曲线，在专业绘图工具PhotoShop中当然会有它的踪影，它就是钢笔工具，钢笔工具所使用的路径弯曲效果就是二阶贝赛尔曲线。<br>我来给大家演示一下钢笔工具的用法：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702123803920160328203123694.gif" alt="201702123803920160328203123694.gif"><br>我们拿最终成形的图形来看一下为什么钢笔工具是二阶贝赛尔曲线：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702126389320160328203210900.png" alt="201702126389320160328203210900.png"><br>右图演示的假设某一点t=0.25时，动态点B的位置图<br>同样，这里P0是起始点，P2是终点，P1是控制点；<br>P0-P1、P1-P2形成了第一层的一阶贝赛尔曲线。它们随时间的动态点分别是Q0,Q1<br>动态点Q0,Q1又形成了第二层的一阶贝赛尔曲线，它们的动态点是B.而B的轨迹跟钢笔工具的形状是完全一样的。所以钢笔工具的拉伸效果是使用的二阶贝赛尔曲线！<br>这个图与上面二阶贝赛尔曲线t=0.25时的曲线差不多，大家理解起来难度也不大。<br>这里需要注意的是，我们在使用钢笔工具时，拖动的是P5点。其实二阶贝赛尔曲线的控制点是其对面的P1点，钢笔工具这样设计是当然是因为操作起来比较方便。 </p>
<h3 id="4、Android中贝赛尔曲线之quadTo"><a href="#4、Android中贝赛尔曲线之quadTo" class="headerlink" title="4、Android中贝赛尔曲线之quadTo"></a>4、Android中贝赛尔曲线之quadTo</h3><pre><code>public void quadTo(float x1, float y1, float x2, float y2)  
public void rQuadTo(float dx1, float dy1, float dx2, float dy2)  
public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3)  
public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3)  
</code></pre><p>在这四个函数中quadTo、rQuadTo是二阶贝赛尔曲线，cubicTo、rCubicTo是三阶贝赛尔曲线。</p>
<h4 id="1、quadTo使用原理"><a href="#1、quadTo使用原理" class="headerlink" title="1、quadTo使用原理"></a>1、quadTo使用原理</h4><pre><code>public void quadTo(float x1, float y1, float x2, float y2)
</code></pre><p>参数中(x1,y1)是控制点坐标，(x2,y2)是终点坐标<br><strong>大家可能会有一个疑问：有控制点和终点坐标，那起始点是多少呢</strong><br>整条线的起始点是通过Path.moveTo(x,y)来指定的，而如果我们连续调用quadTo()，前一个quadTo()的终点，就是下一个quadTo()函数的起点；如果初始没有调用Path.moveTo(x,y)来指定起始点，则默认以控件左上角(0,0)为起始点；</p>
<h5 id="1、示例"><a href="#1、示例" class="headerlink" title="1、示例"></a>1、示例</h5><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702125491520160328203834572.png" alt="201702125491520160328203834572.png"><br>最关键的是如何来确定控制点的位置！前面讲过，PhotoShop中的钢笔工具是二阶贝赛尔曲线，所以我们可以利用钢笔工具来模拟画出这条波浪线来辅助确定控制点的位置。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170212919020160328203922416.gif" alt="20170212919020160328203922416.gif"><br>下面我们来看看这个路径轨迹中，控制点分别在哪个位置<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702127661020160328220950371.png" alt="201702127661020160328220950371.png"><br>我们先看P0-P2这条轨迹，P0是起点，假设位置坐标是(100,300)，P2是终点，假充位置坐标是(300,300)；在以P0为起始点，P2为终点这条二阶贝赛尔曲线上，P1是控制点，很明显P1大概在P0,P2中间的位置，所以它的X坐标应该是200，关于Y坐标，我们无法确定，但很明显的是P1在P0,P2点的上方，也就是它的Y值比它们的小，所以根据钢笔工具上面的位置，我们让P1的比P0,P2的小100;所以P1的坐标是（200，200）<br>同理，不难求出在P2,P4这条二阶贝赛尔曲线上，它们的控制点P3的坐标位置应该是(400,400)；P3的X坐标是400是，因为P3点是P2,P4的中间点；与P3与P1距离P0-P2-P4这条直线的距离应该是相等的。P1距离P0-P2的值为100；P3距离P2-P4的距离也应该是100，这样不难算出P3的坐标应该是(400,400)。</p>
<p><strong>自定义View</strong><br>我们知道在动画绘图时，会调用onDraw(Canvas canvas)函数，我们如果重写了onDraw(Canvas canvas)函数，那么我们利用canvas在上面画了什么，就会显示什么。所以我们自定义一个View<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">        paint.setStyle(Paint.Style.STROKE);  </div><div class="line">        paint.setColor(Color.GREEN);  </div><div class="line">  </div><div class="line">        Path path = <span class="keyword">new</span> Path();  </div><div class="line">        path.moveTo(<span class="number">100</span>,<span class="number">300</span>);  </div><div class="line">        path.quadTo(<span class="number">200</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">300</span>);  </div><div class="line">        path.quadTo(<span class="number">400</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">300</span>);  </div><div class="line">  </div><div class="line">        canvas.drawPath(path,paint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里最重要的就是在onDraw(Canvas canvas)中创建Path的过程，我们在上面已经提到，第一个起始点是需要调用path.moveTo(100,300)来指定的，之后后一个path.quadTo的起始点是以前一个path.quadTo的终点为起始点的。有关控制点的位置如何查找，我们上面已经利用钢笔工具给大家讲解了，这里就不再细讲。<br><strong>所以，大家在自定义控件的时候，要多跟UED沟通，看他们是如何来实现这个效果的，如果是用的钢笔工具，那我们也可以效仿使用二阶贝赛尔曲线来实现。</strong></p>
<p><strong>总结</strong><br>整条线的起始点是通过Path.moveTo(x,y)来指定的，如果初始没有调用Path.moveTo(x,y)来指定起始点，则默认以控件左上角(0,0)为起始点；<br>而如果我们连续调用quadTo()，前一个quadTo()的终点，就是下一个quadTo()函数的起点；</p>
<h3 id="5、手指轨迹"><a href="#5、手指轨迹" class="headerlink" title="5、手指轨迹"></a>5、手指轨迹</h3><p>要实现手指轨迹其实是非常简单的，我们只需要在自定义中拦截OnTouchEvent，然后根据手指的移动轨迹来绘制Path即可。<br>要实现把手指的移动轨迹连接起来，最简单的方法就是直接使用Path.lineTo()就能实现把各个点连接起来。</p>
<h4 id="1、实现方式一：Path-lineTo-x-y"><a href="#1、实现方式一：Path-lineTo-x-y" class="headerlink" title="1、实现方式一：Path.lineTo(x,y)"></a>1、实现方式一：Path.lineTo(x,y)</h4><p><strong>自定义View——MyView</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> Path mPath = <span class="keyword">new</span> Path();  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </div><div class="line">        <span class="keyword">switch</span> (event.getAction())&#123;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;  </div><div class="line">                mPath.moveTo(event.getX(), event.getY());  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:  </div><div class="line">                mPath.lineTo(event.getX(), event.getY());  </div><div class="line">                postInvalidate();  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            <span class="keyword">default</span>:  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">        paint.setColor(Color.GREEN);  </div><div class="line">        paint.setStyle(Paint.Style.STROKE);  </div><div class="line">  </div><div class="line">        canvas.drawPath(mPath,paint);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;  </div><div class="line">        mPath.reset();  </div><div class="line">        invalidate();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当用户点击屏幕的时候，我们调用mPath.moveTo(event.getX(), event.getY());然后在用户移动手指时使用mPath.lineTo(event.getX(), event.getY());将各个点串起来。然后调用postInvalidate()重绘；<br>Path.moveTo()和Path.lineTo()的用法，大家如果看了《android Graphics（二）：路径及文字》之后，理解起来应该没什么难度，但这里有两个地方需要注意<br><strong>第一：有关在case MotionEvent.ACTION_DOWN时return true的问题：return true表示当前控件已经消费了下按动作，之后的ACTION_MOVE、ACTION_UP动作也会继续传递到当前控件中；如果我们在case MotionEvent.ACTION_DOWN时return false，那么后序的ACTION_MOVE、ACTION_UP动作就不会再传到这个控件来了。有关动作拦截的知识，后续会在这个系列中单独来讲，大家先期待下吧。<br>第二：这里重绘控件使用的是postInvalidate();而我们以前也有用Invalidate()函数的。这两个函数的作用都是用来重绘控件的，但区别是Invalidate()一定要在UI线程执行，如果不是在UI线程就会报错。而postInvalidate()则没有那么多讲究，它可以在任何线程中执行，而不必一定要是主线程。其实在postInvalidate()就是利用handler给主线程发送刷新界面的消息来实现的，所以它是可以在任何线程中执行，而不会出错。而正是因为它是通过发消息来实现的，所以它的界面刷新可能没有直接调Invalidate()刷的那么快。所以在我们确定当前线程是主线程的情况下，还是以invalide()函数为主。当我们不确定当前要刷新页面的位置所处的线程是不是主线程的时候，还是用postInvalidate为好。</strong><br>这里我是故意用的postInvalidate()，因为onTouchEvent()本来就是在主线程中的，使用Invalidate()是更合适的。</p>
<p><strong>使用Path.lineTo()所存在问题</strong>：在画出来的两个点连接处有明显的转折，而且位置横纵坐标变化比较快的位置，看起来跟图片这大后的马赛克一样；利用Path绘图，是不可能出现马赛克的，因为除了Bitmap以外的任何canvas绘图全部都是矢量图，也就是利用数学公式来作出来的图，无论放在多大屏幕上，都不可能会出现马赛克！这里利用Path绘图，之所以看起来像是马赛克是因为这是由各个不同点之间连线写出来的，而之间并没有平滑过渡，所以当坐标变化比较剧烈时，线与线之间的转折就显得特别明显了。<br>所以要想优化这种效果，就得实现线与线之间的平滑过渡，很显然，二阶贝赛尔曲线就是干这个事的。下面我们就利用我们新学的Path.quadTo函数来重新实现下移动轨迹效果。</p>
<h4 id="2、实现方式二（优化）：使用Path-quadTo-函数实现过渡"><a href="#2、实现方式二（优化）：使用Path-quadTo-函数实现过渡" class="headerlink" title="2、实现方式二（优化）：使用Path.quadTo()函数实现过渡"></a>2、实现方式二（优化）：使用Path.quadTo()函数实现过渡</h4><h5 id="1-、原理概述"><a href="#1-、原理概述" class="headerlink" title="(1)、原理概述"></a>(1)、原理概述</h5><p>我们上面讲了，使用Path.lineTo()的最大问题就是线段转折处不够平滑。Path.quadTo()可以实现平滑过渡，但使用Path.quadTo()的最大问题是，如何找到起始点和结束点。<br>下图中，有用绿点表示的三个点，连成的两条直线，很明显他们转折处是有明显折痕的<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702129684220160328205249349.png" alt="201702129684220160328205249349.png"><br>下面我们在PhotoShop中利用钢笔工具，看如何才能实现这两条线之间的转折<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702125218320160328205647198.gif" alt="201702125218320160328205647198.gif"><br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702128185020160328205659876.png" alt="201702128185020160328205659876.png"><br>从这两个线段中可以看出，我们使用Path.lineTo（）的时候，是直接把手指触点A,B,C给连起来。<br>而钢笔工具要实现这三个点间的流畅过渡，就只能将这两个线段的中间点做为起始点和结束点，而将手指的倒数第二个触点B做为控制点。<br>大家可能会觉得，那这样，在结束的时候，A到P0和P1到C1的这段距离岂不是没画进去？是的，如果Path最终没有close的话，这两段距离是被抛弃掉的。因为手指间滑动时，每两个点间的距离很小，所以P1到C之间的距离可以忽略不计。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Path mPath = <span class="keyword">new</span> Path();  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mPreX,mPreY;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </div><div class="line">        <span class="keyword">switch</span> (event.getAction())&#123;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:&#123;  </div><div class="line">                mPath.moveTo(event.getX(),event.getY());  </div><div class="line">                mPreX = event.getX();  </div><div class="line">                mPreY = event.getY();  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:&#123;  </div><div class="line">                <span class="keyword">float</span> endX = (mPreX+event.getX())/<span class="number">2</span>;  </div><div class="line">                <span class="keyword">float</span> endY = (mPreY+event.getY())/<span class="number">2</span>;  </div><div class="line">                mPath.quadTo(mPreX,mPreY,endX,endY);  </div><div class="line">                mPreX = event.getX();  </div><div class="line">                mPreY =event.getY();  </div><div class="line">                invalidate();  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">            <span class="keyword">default</span>:  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">        paint.setStyle(Paint.Style.STROKE);  </div><div class="line">        paint.setColor(Color.GREEN);  </div><div class="line">        paint.setStrokeWidth(<span class="number">2</span>);  </div><div class="line">  </div><div class="line">        canvas.drawPath(mPath,paint);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;  </div><div class="line">        mPath.reset();  </div><div class="line">        postInvalidate();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6、Path-rQuadTo"><a href="#6、Path-rQuadTo" class="headerlink" title="6、Path.rQuadTo()"></a>6、Path.rQuadTo()</h3><h4 id="1、概述-2"><a href="#1、概述-2" class="headerlink" title="1、概述"></a>1、概述</h4><pre><code>public void rQuadTo(float dx1, float dy1, float dx2, float dy2)
</code></pre><ul>
<li>dx1:控制点X坐标，表示相对上一个终点X坐标的位移坐标，可为负值，正值表示相加，负值表示相减；</li>
<li>dy1:控制点Y坐标，相对上一个终点Y坐标的位移坐标。同样可为负值，正值表示相加，负值表示相减；</li>
<li>dx2:终点X坐标，同样是一个相对坐标，相对上一个终点X坐标的位移值，可为负值，正值表示相加，负值表示相减；</li>
<li>dy2:终点Y坐标，同样是一个相对，相对上一个终点Y坐标的位移值。可为负值，正值表示相加，负值表示相减；</li>
</ul>
<p>这四个参数都是传递的都是相对值，相对上一个终点的位移值。<br>比如，我们上一个终点坐标是(300,400)那么利用rQuadTo(100,-100,200,100)；<br>得到的控制点坐标是（300+100,400-100）即(500,300)<br>同样，得到的终点坐标是(300+200,400+100)即(500,500)<br>所以下面这两段代码是等价的：<br>利用quadTo定义绝对坐标</p>
<pre><code>path.moveTo(300,400);  
path.quadTo(500,300,500,500);  
</code></pre><p>与利用rQuadTo定义相对坐标</p>
<pre><code>path.moveTo(300,400);  
path.rQuadTo(100,-100,200,100)  
</code></pre><h4 id="2、使用rQuadTo实现波浪线"><a href="#2、使用rQuadTo实现波浪线" class="headerlink" title="2、使用rQuadTo实现波浪线"></a>2、使用rQuadTo实现波浪线</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">    Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">    paint.setStyle(Paint.Style.STROKE);  </div><div class="line">    paint.setColor(Color.GREEN);  </div><div class="line">  </div><div class="line">    Path path = <span class="keyword">new</span> Path();  </div><div class="line">    path.moveTo(<span class="number">100</span>,<span class="number">300</span>);  </div><div class="line">    path.rQuadTo(<span class="number">100</span>,-<span class="number">100</span>,<span class="number">200</span>,<span class="number">0</span>);  </div><div class="line">    path.rQuadTo(<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">0</span>);  </div><div class="line">    canvas.drawPath(path,paint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>第一句</strong>：path.rQuadTo(100,-100,200,0);是建立在（100,300）这个点基础上来计算相对坐标的。<br>所以<br>控制点X坐标=上一个终点X坐标+控制点X位移 = 100+100=200；<br>控制点Y坐标=上一个终点Y坐标+控制点Y位移 = 300-100=200；<br>终点X坐标 = 上一个终点X坐标+终点X位移 = 100+200=300；<br>终点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+0=300;<br>所以这句与path.quadTo(200,200,300,300);对等的<br><strong>第二句</strong>：path.rQuadTo(100,100,200,0);是建立在它的前一个终点即(300,300)的基础上来计算相对坐标的！<br>所以<br>控制点X坐标=上一个终点X坐标+控制点X位移 = 300+100=200；<br>控制点Y坐标=上一个终点Y坐标+控制点Y位移 = 300+100=200；<br>终点X坐标 = 上一个终点X坐标+终点X位移 = 300+200=500；<br>终点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+0=300;<br>所以这句与path.quadTo(400,400,500,300);对等的<br>最终效果也是一样的。<br>通过这个例子，只想让大家明白一点：rQuadTo(float dx1, float dy1, float dx2, float dy2)中的位移坐标，都是以上一个终点位置为基准来做偏移的！</p>
<h4 id="3、实现波浪效果"><a href="#3、实现波浪效果" class="headerlink" title="3、实现波浪效果"></a>3、实现波浪效果</h4><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702138288820160328210844115.gif" alt="201702138288820160328210844115.gif"></p>
<p><strong>完整的MyView代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Path mPath;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mItemWaveLength = <span class="number">400</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dx;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPath = <span class="keyword">new</span> Path();  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        mPath.reset();  </div><div class="line">        <span class="keyword">int</span> originY = <span class="number">300</span>;  </div><div class="line">        <span class="keyword">int</span> halfWaveLen = mItemWaveLength/<span class="number">2</span>;  </div><div class="line">        mPath.moveTo(-mItemWaveLength+dx,originY);  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -mItemWaveLength;i&lt;=getWidth()+mItemWaveLength;i+=mItemWaveLength)&#123;  </div><div class="line">            mPath.rQuadTo(halfWaveLen/<span class="number">2</span>,-<span class="number">100</span>,halfWaveLen,<span class="number">0</span>);  </div><div class="line">            mPath.rQuadTo(halfWaveLen/<span class="number">2</span>,<span class="number">100</span>,halfWaveLen,<span class="number">0</span>);  </div><div class="line">        &#125;  </div><div class="line">        mPath.lineTo(getWidth(),getHeight());  </div><div class="line">        mPath.lineTo(<span class="number">0</span>,getHeight());  </div><div class="line">        mPath.close();  </div><div class="line">  </div><div class="line">        canvas.drawPath(mPath,mPaint);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnim</span><span class="params">()</span></span>&#123;  </div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,mItemWaveLength);  </div><div class="line">        animator.setDuration(<span class="number">2000</span>);  </div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);  </div><div class="line">        animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());  </div><div class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;  </div><div class="line">                dx = (<span class="keyword">int</span>)animation.getAnimatedValue();  </div><div class="line">                postInvalidate();  </div><div class="line">            &#125;  </div><div class="line">        &#125;);  </div><div class="line">        animator.start();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>然后在MyActivity中开始动画：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * Called when the activity is first created. </div><div class="line">     */  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">        setContentView(R.layout.main);  </div><div class="line">        <span class="keyword">final</span> MyView myView = (MyView)findViewById(R.id.myview);  </div><div class="line">        myView.startAnim();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="三、Paint之函数大汇总"><a href="#三、Paint之函数大汇总" class="headerlink" title="三、Paint之函数大汇总"></a>三、Paint之函数大汇总</h2><h3 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h3><h4 id="1、概述-3"><a href="#1、概述-3" class="headerlink" title="1、概述"></a>1、概述</h4><p>paint中基本设置的函数</p>
<pre><code>reset() //重置画笔 
setColor(int color) //给画笔设置颜色值 
setARGB(int a, int r, int g, int b) //同样是设置颜色，但是利用ARGB分开设置 
setAlpha(int a) //设置画笔透明度 
setStyle(Paint.Style style) //设置画笔样式，取值有
    Paint.Style.FILL :填充内部
    Paint.Style.FILL_AND_STROKE ：填充内部和描边
    Paint.Style.STROKE ：仅描边
setStrokeWidth(float width) //设置画笔宽度 
setAntiAlias(boolean aa) //设置画笔是否抗锯齿 
</code></pre><p>上面这些函数，我们在前面几篇已经详细讲过了，难度也都不大，不再细讲。下面几个函数我们是没有讲到过的，下面做下补充 </p>
<pre><code>setStrokeCap(Paint.Cap cap) //设置线冒样式，取值有Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) 
</code></pre><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702134262920160330083020037.png" alt="201702134262920160330083020037.png"></p>
<pre><code>setStrokeJoin(Paint.Join join) //设置线段连接处样式，取值有：Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线) 
</code></pre><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702134447020160330083821071.png" alt="201702134447020160330083821071.png"></p>
<pre><code>setStrokeMiter(float miter) //设置笔画的倾斜度，90度拿画笔与30拿画笔，画出来的线条样式肯定是不一样的吧。（事实证明，根本看不出来什么区别好吗……囧……） 
setPathEffect(PathEffect effect) //设置路径样式;取值类型是所有派生自PathEffect的子类：ComposePathEffect, CornerPathEffect, DashPathEffect, DiscretePathEffect, PathDashPathEffect, SumPathEffect
</code></pre><h5 id="（1）、CornerPathEffect——圆形拐角效果"><a href="#（1）、CornerPathEffect——圆形拐角效果" class="headerlink" title="（1）、CornerPathEffect——圆形拐角效果"></a>（1）、CornerPathEffect——圆形拐角效果</h5><p>它的作用就是将原来Path生硬的直线拐角，变成圆形拐角：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702137191320160402201504245.png" alt="201702137191320160402201504245.png"></p>
<pre><code>public CornerPathEffect(float radius)
</code></pre><p>它只有一个参数radius：即当前连接两条直线所使用的圆的半径。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702131499120160402201548433.png" alt="201702131499120160402201548433.png"><br>上面这个图，很清晰的展示了利用半径R=50的圆来代替原来两条直线间的夹角。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Paint paint = <span class="keyword">new</span> Paint();  </div><div class="line">paint.setStrokeWidth(<span class="number">4</span>);  </div><div class="line">paint.setColor(Color.GREEN);  </div><div class="line">paint.setStyle(Paint.Style.STROKE);  </div><div class="line">  </div><div class="line">Path path = <span class="keyword">new</span> Path();  </div><div class="line">path.moveTo(<span class="number">100</span>,<span class="number">600</span>);  </div><div class="line">path.lineTo(<span class="number">400</span>,<span class="number">100</span>);  </div><div class="line">path.lineTo(<span class="number">700</span>,<span class="number">900</span>);  </div><div class="line">  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line">paint.setColor(Color.RED);  </div><div class="line">paint.setPathEffect(<span class="keyword">new</span> CornerPathEffect(<span class="number">100</span>));  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line">paint.setColor(Color.YELLOW);  </div><div class="line">paint.setPathEffect(<span class="keyword">new</span> CornerPathEffect(<span class="number">200</span>));  </div><div class="line">canvas.drawPath(path,paint);</div></pre></td></tr></table></figure></p>
<p>在这里，我利用Path构造了一个夹角，在同一个位置画了三遍，第一遍是没有添加任何PathEffect的;第二遍，CornerPathEffect的圆半径为100；第三遍CornerPathEffect的圆半径为200；<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702138363920160402201638339.png" alt="201702138363920160402201638339.png"><br>很明显能看出在半径不同情况下，连接位置也是不一样的。</p>
<h5 id="（2）、DashPathEffect——虚线效果"><a href="#（2）、DashPathEffect——虚线效果" class="headerlink" title="（2）、DashPathEffect——虚线效果"></a>（2）、DashPathEffect——虚线效果</h5><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702146778420160402201734137.png" alt="201702146778420160402201734137.png"></p>
<pre><code>public DashPathEffect(float intervals[], float phase)
</code></pre><p>intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[]中这些基本线段循环组成的。比如，我们定义new float[] {20,10}；那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10；</p>
<p>对于intervals[]数组的有两个限定：</p>
<ul>
<li>长度必须大于等于2；因为必须有一个实线段和一个空线段来组成虚线。</li>
<li>个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。</li>
</ul>
<h5 id="（3）、DiscretePathEffect——离散路径效果"><a href="#（3）、DiscretePathEffect——离散路径效果" class="headerlink" title="（3）、DiscretePathEffect——离散路径效果"></a>（3）、DiscretePathEffect——离散路径效果</h5><p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702149814720160402202201451.png" alt="201702149814720160402202201451.png"><br>同样，图中第一条线是原生的，第二条线加上离散路径效果后的样式。<br>DiscretePathEffect就是将原来路径分隔成定长的线段，然后将每条线段随机偏移一段位置，我们可以用它来模拟一种类似生锈铁丝的效果.</p>
<pre><code>public DiscretePathEffect(float segmentLength, float deviation)
</code></pre><ul>
<li>第一个参数segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为2的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。 </li>
<li>第二参数deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Paint paint = getPaint();  </div><div class="line">Path path = getPath();  </div><div class="line"><span class="comment">//第一条原生Path  </span></div><div class="line">canvas.drawPath(path,paint);  </div><div class="line"><span class="comment">//第二条Path  </span></div><div class="line">canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">paint.setPathEffect(<span class="keyword">new</span> DiscretePathEffect(<span class="number">2</span>,<span class="number">5</span>));  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line"><span class="comment">//第三条Path  </span></div><div class="line">canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">paint.setPathEffect(<span class="keyword">new</span> DiscretePathEffect(<span class="number">6</span>,<span class="number">5</span>));  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line"><span class="comment">//第四条Path  </span></div><div class="line">canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">paint.setPathEffect(<span class="keyword">new</span> DiscretePathEffect(<span class="number">6</span>,<span class="number">15</span>));  </div><div class="line">canvas.drawPath(path,paint);</div></pre></td></tr></table></figure>
<p>我们这里涉及到一个函数getPath函数就是随机生成一条路径；我们先来看效果，然后再回来看getPath（）的实现</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214471620160402202259482.png" alt="20170214471620160402202259482.png"></p>
<p>从第二条和第三条相比，可以明显看出，在仅增大segmentLength的情况下，很明显第三条线段所切的子线段要大一些，所以就没有第二条曲线的那么多线段相交所产生的折点，所以相比第二条更顺滑一些，当然铁锈效果就没有第二条那么明显了。<br>第三条和第四条相比，在segmentLength都是6的情况下，在第四条仅增大了deviation参数（偏移距离），从效果图中也明显可以看出每个子线段向外偏移的距离也增大了。 </p>
<h4 id="（4）、PathDashPathEffect——印章路径效果"><a href="#（4）、PathDashPathEffect——印章路径效果" class="headerlink" title="（4）、PathDashPathEffect——印章路径效果"></a>（4）、PathDashPathEffect——印章路径效果</h4><p>它的作用就是用另一个路径图案做为印章，沿着指定路径一个个盖上去。</p>
<pre><code>public PathDashPathEffect(Path shape, float advance, float phase,Style style)
</code></pre><ul>
<li>Path shape:表示印章路径，比如我们下面示例中的三角形加右上角一个点；</li>
<li>float advance：表示两个印章路径间的距离,很容易理解，印章间距离越大，间距就越大。</li>
<li>float phase：路径绘制偏移距离，与上面DashPathEffect中的float phase参数意义相同</li>
<li>Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE;Style.ROTATE表示通过旋转印章来过渡转角；Style.MORPH表示通过变形印章来过渡转角；Style.TRANSLATE表示通过位移来过渡转角。这三个效果的具体意义，上面会通过具体示例来分别讲解。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Paint paint = getPaint();  </div><div class="line">  </div><div class="line"><span class="comment">//画出原始路径  </span></div><div class="line">Path path  = <span class="keyword">new</span> Path();  </div><div class="line">path.moveTo(<span class="number">100</span>,<span class="number">600</span>);  </div><div class="line">path.lineTo(<span class="number">400</span>,<span class="number">100</span>);  </div><div class="line">path.lineTo(<span class="number">700</span>,<span class="number">900</span>);  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line"><span class="comment">//构建印章路径  </span></div><div class="line">Path stampPath  = <span class="keyword">new</span> Path();  </div><div class="line">stampPath.moveTo(<span class="number">0</span>,<span class="number">20</span>);  </div><div class="line">stampPath.lineTo(<span class="number">10</span>,<span class="number">0</span>);  </div><div class="line">stampPath.lineTo(<span class="number">20</span>,<span class="number">20</span>);  </div><div class="line">stampPath.close();  </div><div class="line">stampPath.addCircle(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>, Path.Direction.CCW);  </div><div class="line">  </div><div class="line"><span class="comment">//使用印章路径效果  </span></div><div class="line">canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">paint.setPathEffect(<span class="keyword">new</span> PathDashPathEffect(stampPath,<span class="number">35</span>,<span class="number">0</span>, PathDashPathEffect.Style.TRANSLATE));  </div><div class="line">canvas.drawPath(path,paint);</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214312720160402202419967.png" alt="20170214312720160402202419967.png"></p>
<p><strong>在Style不同的情况下，在转角处都如何处理的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPathDashPathEffect</span><span class="params">(Canvas canvas)</span></span>&#123;  </div><div class="line">    Paint paint = getPaint();  </div><div class="line">    Path path = getPath();  </div><div class="line">    canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">    paint.setPathEffect(<span class="keyword">new</span> PathDashPathEffect(getStampPath(),<span class="number">35</span>,<span class="number">0</span>, PathDashPathEffect.Style.MORPH));  </div><div class="line">    canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">    paint.setPathEffect(<span class="keyword">new</span> PathDashPathEffect(getStampPath(),<span class="number">35</span>,<span class="number">0</span>, PathDashPathEffect.Style.ROTATE));  </div><div class="line">    canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">    paint.setPathEffect(<span class="keyword">new</span> PathDashPathEffect(getStampPath(),<span class="number">35</span>,<span class="number">0</span>, PathDashPathEffect.Style.TRANSLATE));  </div><div class="line">    canvas.drawPath(path,paint);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">private</span> Path <span class="title">getStampPath</span><span class="params">()</span></span>&#123;  </div><div class="line">    Path path  = <span class="keyword">new</span> Path();  </div><div class="line">    path.moveTo(<span class="number">0</span>,<span class="number">20</span>);  </div><div class="line">    path.lineTo(<span class="number">10</span>,<span class="number">0</span>);  </div><div class="line">    path.lineTo(<span class="number">20</span>,<span class="number">20</span>);  </div><div class="line">    path.close();  </div><div class="line">  </div><div class="line">    path.addCircle(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>, Path.Direction.CCW);  </div><div class="line">    <span class="keyword">return</span> path;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码通过getPath()函数随机生成一条路径，并将原始路径和各个Style的路径画出来。第一条是原始路径，第二条的Style是Style.MORPH，第三条是Style.ROTATE，第四条是Style.TRANSLATE；</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702141899420160403101637840.png" alt="201702141899420160403101637840.png"></p>
<ul>
<li>当Style.MORPH时，就是通过对印章进行变形来过渡转角的</li>
<li>当Style为Style.ROTATE时就是靠旋转印章角度来过渡转角的</li>
<li>当Style为Style.TRANSLATE时，即不会对印章变形也不会对旋转印章角度，而只是通过变改印章的位置来过渡 </li>
</ul>
<h4 id="（5）、ComposePathEffect与SumPathEffect"><a href="#（5）、ComposePathEffect与SumPathEffect" class="headerlink" title="（5）、ComposePathEffect与SumPathEffect"></a>（5）、ComposePathEffect与SumPathEffect</h4><p>这两个都是用来合并两个特效的。但它们之间是有区别的：</p>
<pre><code>public ComposePathEffect(PathEffect outerpe, PathEffect innerpe) 
</code></pre><p>ComposePathEffect合并两个特效是有先后顺序的，它会先将第二个参数的PathEffect innerpe的特效作用于路径上，然后再在此加了特效的路径上作用第二个特效。</p>
<pre><code>public SumPathEffect(PathEffect first, PathEffect second)
</code></pre><p>而SumPathEffect是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//画原始路径  </span></div><div class="line">Paint paint = getPaint();  </div><div class="line">Path path = getPath();  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line"><span class="comment">//仅应用圆角特效的路径  </span></div><div class="line">canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">CornerPathEffect cornerPathEffect = <span class="keyword">new</span> CornerPathEffect(<span class="number">100</span>);  </div><div class="line">paint.setPathEffect(cornerPathEffect);  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line"><span class="comment">//仅应用虚线特效的路径  </span></div><div class="line">canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">DashPathEffect dashPathEffect = <span class="keyword">new</span> DashPathEffect(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>&#125;,<span class="number">0</span>);  </div><div class="line">paint.setPathEffect(dashPathEffect);  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line"><span class="comment">//利用ComposePathEffect先应用圆角特效,再应用虚线特效  </span></div><div class="line">canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">ComposePathEffect composePathEffect = <span class="keyword">new</span> ComposePathEffect(dashPathEffect,cornerPathEffect);  </div><div class="line">paint.setPathEffect(composePathEffect);  </div><div class="line">canvas.drawPath(path,paint);  </div><div class="line">  </div><div class="line"><span class="comment">//利用SumPathEffect,分别将圆角特效应用于原始路径,然后将生成的两条特效路径合并  </span></div><div class="line">canvas.translate(<span class="number">0</span>,<span class="number">200</span>);  </div><div class="line">paint.setStyle(Paint.Style.STROKE);  </div><div class="line">SumPathEffect sumPathEffect = <span class="keyword">new</span> SumPathEffect(cornerPathEffect,dashPathEffect);  </div><div class="line">paint.setPathEffect(sumPathEffect);  </div><div class="line">canvas.drawPath(path,paint);</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702142629720160403102134342.png" alt="201702142629720160403102134342.png"></p>
<h3 id="二、字体相关"><a href="#二、字体相关" class="headerlink" title="二、字体相关"></a>二、字体相关</h3><pre><code>setTextSize(float textSize) //设置文字大小 
setFakeBoldText(boolean fakeBoldText) //设置是否为粗体文字 
setStrikeThruText(boolean strikeThruText) //设置带有删除线效果 
setUnderlineText(boolean underlineText) //设置下划线 
setTextAlign(Paint.Align align) //设置开始绘图点位置 
setTextScaleX(float scaleX) //水平拉伸设置 
setTextSkewX(float skewX) //设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 
setTypeface(Typeface typeface) //字体样式 
</code></pre><h4 id="1、setLinearText-boolean-linearText"><a href="#1、setLinearText-boolean-linearText" class="headerlink" title="1、setLinearText(boolean linearText)"></a>1、setLinearText(boolean linearText)</h4><p>设置是否打开线性文本标识；由于文本想要快速绘制出来，必然是需要提前缓存在显存中的，一般而言每个文字需要一个字节的大小来存储它（当然具体需要多少字节与编码方式有关），那如果是长篇文章，可见所需的大小可想而知。我们可以通过setLinearText (true)告诉Android我们不需要这样的文本缓存。但如果我们不用文本缓存，虽然能够省去一些内存空间，但这是以显示速度为代价的。<br>由于这个是API 1的函数，由于当时的android手机的内存大小还是很小的，所以尽量减少内存使用是每个应用的头等大事，在当时的的环境下这个函数还是很有用的。<br>但在今天，内存动不动就是4G以上了，文本缓存的所占的那点内存就微不足道了，没有哪个APP会牺牲性能来减少这点这内存占用了，<strong>所以这个函数基本没用了。</strong><br>2、setSubpixelText(boolean subpixelText)<br>表示是否打开亚像素设置来绘制文本。亚像素的概念比较难理解，首先，我们都知道像素，比如一个android手机的分辨率是1280 <em> 720，那就是指它的屏幕在垂直方向有1280个像素点，水平方向上有720个像素点。我们知道每个像素点都是一个独立显示一个颜色的个体。所以如果一副图片，在一个屏幕上用了300 </em> 100个相素点，而在另一个屏幕上却用了450 <em> 150个像素来显示。那么，请问在哪个屏幕上这张图片显示的更清晰？当然是第二个屏幕，因为它使用的像素点更多，所显示的细节更精细。<br>那么问题来了，android设置在出厂时，设定的像素显示都是固定的几个范围：320 </em> 480，480 <em> 800，720 </em> 1280，1080 * 1920等等；那么如何在同样的分辨率的显示器中增强显示清晰度呢？<br>亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。<br>所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。注意：亚像素是通过程序计算出来模拟插入的，在没有改变硬件构造的情况下，来改善屏幕分辨率大小。<br>亚像素显示，是仅在液晶显示器上使用的一种增强字体清晰度的技术。但这种技术有时会出现问题，用投影仪投射到白色墙壁上，会出出字体显示不正常的情况，而且对于老式的CRT显示器是根本不支持的。<br>在android还没有出现时，windows已经能够支持亚像素显示了，在windows机器中，这个功能叫做ClearType，在以前讲述windows的GDI绘图时，也曾经讲过ClearType的应用效果。</p>
<p>三、其它<br>接下来还剩几个跟图片和测量相关的函数，我们接下来分篇慢慢讲解。<br>1、图像处理：</p>
<pre><code>setShader(Shader shader)  
setShadowLayer(float radius, float dx, float dy, int shadowColor)  
setDither(boolean dither)  
setColorFilter(ColorFilter filter)  
setXfermode(Xfermode xfermode)  
setFilterBitmap(boolean filter)  
clearShadowLayer()  
</code></pre><p>2、measure测量相关</p>
<pre><code>breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth)  
measureText(String text)  
</code></pre><h3 id="三、Paint之ColorMatrix与滤镜效果"><a href="#三、Paint之ColorMatrix与滤镜效果" class="headerlink" title="三、Paint之ColorMatrix与滤镜效果"></a>三、Paint之ColorMatrix与滤镜效果</h3><h4 id="一、矩阵概述"><a href="#一、矩阵概述" class="headerlink" title="一、矩阵概述"></a>一、矩阵概述</h4><p>学过线代的应该都清楚，就不记录了。</p>
<h4 id="二、色彩矩阵"><a href="#二、色彩矩阵" class="headerlink" title="二、色彩矩阵"></a>二、色彩矩阵</h4><p>对于色彩的存储，Bitmap类使用一个32位的数值来保存。红、绿、蓝及透明度各占8位，每一个色彩分量的取值范围是0-255。透明度为0表示完全透明，为255时，色彩完全可见。</p>
<h5 id="1、色彩信息的矩阵表示"><a href="#1、色彩信息的矩阵表示" class="headerlink" title="1、色彩信息的矩阵表示"></a>1、色彩信息的矩阵表示</h5><p><strong>四阶表示</strong><br>由于一个色彩信息包含R、G、B、Alpha信息，所以，我们必然要使用一个4阶色彩变换矩阵来修改色彩的每一个分量值：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702148042620160419090010949.png" alt="201702148042620160419090010949.png"><br>注意：对于色彩变换矩阵，这里的色彩顺序是R、G、B、A而不是A、R、G、B！！！<br>如果想将色彩（0，255，0，255）更改为半透明时，可以使用下面的的矩阵运算来表示：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702148173820160422211037563.gif" alt="201702148173820160422211037563.gif"></p>
<p><strong>为什么使用五阶矩阵</strong><br>上面使用四阶矩阵完全可以改变图片的RGBA值了，但考虑一种情况，如果我们只想在原有的R色上增加一些分量呢？<br>这时，我们就得再多加一阶来表示平移变换。所以，一个既包含线性变换，又包含平移变换的组合变换，称为仿射变换。使用四阶的色彩变换矩阵来修改色彩，只能够对色彩的每一个分量值进行乘（除）运算，如果要对这些分量值进行加减法的运算（平移变换），只能通过五阶矩阵来完成。<br>考虑下面这个变换：<br>1、红色分量值更改为原来的2倍；<br>2、绿色分量增加100；<br>则使用4阶矩阵的乘法无法实现，所以，应该在四阶色彩变换矩阵上增加一个“哑元坐标”，来实现所列的矩阵运算:<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702141128020160419090113981.png" alt="201702141128020160419090113981.png"></p>
<h4 id="三、Android中的色彩矩阵"><a href="#三、Android中的色彩矩阵" class="headerlink" title="三、Android中的色彩矩阵"></a>三、Android中的色彩矩阵</h4><h5 id="1、概述-4"><a href="#1、概述-4" class="headerlink" title="1、概述"></a>1、概述</h5><p>在上面的所有讲解之后，大家也应该看出来了，色彩变换矩阵的表示形式，肯定是五阶的那种，所以大家看一下，在默认情况下，色彩变换矩阵的形式：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702145630720160419090149826.png" alt="201702145630720160419090149826.png"><br>Android中的色彩矩阵是用ColorMatrics类来表示的。使用ColorMatrix的方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;    </div><div class="line">        <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,    </div><div class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,    </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,    </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>,    </div><div class="line">&#125;);    </div><div class="line">mPaint.setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(colorMatrix));</div></pre></td></tr></table></figure></p>
<h5 id="2、示例1（单个颜色的蓝色通道输出）"><a href="#2、示例1（单个颜色的蓝色通道输出）" class="headerlink" title="2、示例1（单个颜色的蓝色通道输出）"></a>2、示例1（单个颜色的蓝色通道输出）</h5><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">public class MyView extends View &#123;  </div><div class="line">    private Paint mPaint = new Paint();  </div><div class="line">    private Bitmap bitmap;// 位图  </div><div class="line">  </div><div class="line">    public MyView(Context context, AttributeSet attrs) &#123;  </div><div class="line">        super(context, attrs);     </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    protected void onDraw(Canvas canvas) &#123;  </div><div class="line">        super.onDraw(canvas);  </div><div class="line">        mPaint.setAntiAlias(true);  </div><div class="line">        mPaint.setARGB(255,200,100,100);  </div><div class="line">        // 绘制原始位图  </div><div class="line">        canvas.drawRect(0,0,500,600,mPaint);  </div><div class="line">  </div><div class="line">        canvas.translate(550,0);  </div><div class="line">        // 生成色彩矩阵  </div><div class="line">        ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;  </div><div class="line">                0, 0, 0, 0, 0,  </div><div class="line">                0, 0, 0, 0, 0,  </div><div class="line">                0, 0, 1, 0, 0,  </div><div class="line">                0, 0, 0, 1, 0,  </div><div class="line">        &#125;);  </div><div class="line">        mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));  </div><div class="line">        canvas.drawRect(0,0,500,600,mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line">```  </div><div class="line">在上面中，我们先将图笔颜色值设为(255,200,100,100)，然后对其进行ColorMatrix颜色值运算，把红色和绿色都去掉，仅显示蓝色值；只显示蓝色值的效果在Photoshop中叫做蓝色通道。效果图如下： </div><div class="line">左侧是原图，右侧是该图对应的蓝色通道</div><div class="line">![201702142952620160419090342953.png](http://ohtrrgyyd.bkt.clouddn.com/201702142952620160419090342953.png)</div><div class="line">这里只是对一个颜色值，而ColorMatrics的最厉害的地方在于，能够很批量地改变图像中的所有颜色值。下面我们就对图像应用ColorMatrics的例子来看看，如果只显示图像中的蓝色通道会怎样</div><div class="line"></div><div class="line">#### 3、示例2（图片多颜色的蓝色通道输出）</div><div class="line">下面我们就举个给Bitmap应用ColorMatrix的例子：</div><div class="line"></div><div class="line">``` java</div><div class="line">public class MyView extends View &#123;  </div><div class="line">    private Paint mPaint = new Paint();  </div><div class="line">    private Bitmap bitmap;// 位图  </div><div class="line">  </div><div class="line">    public MyView(Context context, AttributeSet attrs) &#123;  </div><div class="line">        super(context, attrs);  </div><div class="line">  </div><div class="line">        mPaint.setAntiAlias(true);  </div><div class="line">        // 获取位图  </div><div class="line">        bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    protected void onDraw(Canvas canvas) &#123;  </div><div class="line">        super.onDraw(canvas);  </div><div class="line">  </div><div class="line">        // 绘制原始位图  </div><div class="line">        canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint);  </div><div class="line">  </div><div class="line">        canvas.translate(510, 0);  </div><div class="line">        // 生成色彩矩阵  </div><div class="line">        ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;  </div><div class="line">                0, 0, 0, 0, 0,  </div><div class="line">                0, 0, 0, 0, 0,  </div><div class="line">                0, 0, 1, 0, 0,  </div><div class="line">                0, 0, 0, 1, 0,  </div><div class="line">        &#125;);  </div><div class="line">        mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix));  </div><div class="line">        canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line">```  </div><div class="line">这里分两次绘制了一个bitmap，第一次绘制了一个原始图像，然后利用ColorMatrix生成了一个仅包含蓝色的图像，用过PhotoShop的同学应该很清楚这个跟Photoshop中的蓝色通道的效果是一致的。效果图如下：</div><div class="line">![201702142204420160419090516432.png](http://ohtrrgyyd.bkt.clouddn.com/201702142204420160419090516432.png)</div><div class="line"></div><div class="line">**大家注意哦，不要在onDraw里new Paint对象，上节中我为了省事就直接在onDraw（）函数中直接new 了Paint对象，由于onDraw函数在刷新时会连续调用多次，所以如果在其中不断的new对象，会造成程序不断的GC(内存回收)，是会严重影响性能的！在程序中，我有时会了为了方便理解，就直接在onDraw（）中创建对象了，大家在实际应用中一定要杜绝这种应用哦。**</div><div class="line"></div><div class="line">#### 四、色彩的几种运算方式</div><div class="line"></div><div class="line">##### 1、色彩的平移运算</div><div class="line">色彩的平移运算，实际上就是色彩的加法运算。其实就是在色彩变换矩阵的最后一行加上某个值；这样可以增加特定色彩的饱和度</div><div class="line">![201702143469220160419090748183.png](http://ohtrrgyyd.bkt.clouddn.com/201702143469220160419090748183.png)</div><div class="line">比如，同样是上面的图片，我们给它应用下面的色彩值：</div><div class="line">``` java</div><div class="line">ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123;  </div><div class="line">        1, 0, 0, 0, 0,  </div><div class="line">        0, 1, 0, 0, 50,  </div><div class="line">        0, 0, 1, 0, 0,  </div><div class="line">        0, 0, 0, 1, 0,  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在绿色值上添加增量50，即增大绿色的饱和度。效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702142152920160419092847409.png" alt="201702142152920160419092847409.png"></p>
<p>同样，左侧是原图，右侧是增大绿色饱和度后的效果；大家要特别注意的是，由于图片是由一个个像素组成的，所以用每个像素所对应的色彩数组，来乘转换矩阵，结果就是转换后的当前点的颜色值；所以，在应用ColorMatrics后，图片中每个像素的绿色值都增加了50，从小狗脸上也可以看出来，狗脸也变绿了（它可能看到他女朋友跟人家跑了，哈哈）！<br>色彩平移除了增加指定颜色饱和度以外，另一个应用就是色彩反转(PhotoShop中的反相功能) </p>
<p><strong>色彩反转/反相功能</strong><br>色彩反转就是求出每个色彩的补值来做为目标图像的对应颜色值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">        -<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>,  </div><div class="line">        <span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">255</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> ,<span class="number">1</span>,<span class="number">0</span>  </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700524743884.png" alt="20170214148700524743884.png"></p>
<h5 id="2、色彩的缩放运算"><a href="#2、色彩的缩放运算" class="headerlink" title="2、色彩的缩放运算"></a>2、色彩的缩放运算</h5><p>色彩的缩放运算其实就是色彩的乘法运算。在色彩矩阵对角线上的分别代表R、G、B、A的几个值，将其分别乘以指定的值。这就是所谓的缩放变换。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702141487005956679.png" alt="201702141487005956679.png"><br>我们可以针对某一个颜色值进行放大缩小运算，但当对R、G、B、A同时进行放大缩小时，就是对亮度进行调节！<br>看下面的将亮度增大1.2倍的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">         <span class="number">1.2f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">1.2f</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">50</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.2f</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.2f</span>, <span class="number">0</span>,    </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700601486740.png" alt="20170214148700601486740.png"></p>
<h5 id="3、缩放变换的特殊应用（通道输出）"><a href="#3、缩放变换的特殊应用（通道输出）" class="headerlink" title="3、缩放变换的特殊应用（通道输出）"></a>3、缩放变换的特殊应用（通道输出）</h5><p>由于在色彩变换矩阵中，对角线上的数的取值范围是从0-1的，所以当取0时，这个色彩就完全不显示，所以当我们R、G都取0，而独有B取1时，就只显示了蓝色，所形成的图像也就是我们通常说的蓝色通道；看下几个通道输出的效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700604489771.png" alt="20170214148700604489771.png"><br><strong>红色通道矩阵</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">       <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">       <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,    </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>绿色通道矩阵</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,    </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><strong>蓝色通道矩阵</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,    </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h5 id="4、色彩的旋转运算"><a href="#4、色彩的旋转运算" class="headerlink" title="4、色彩的旋转运算"></a>4、色彩的旋转运算</h5><p>RGB色是如何旋转的呢，首先用R、G、B三色建立立体坐标系：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700623263988.png" alt="20170214148700623263988.png"><br>所以，我们可以把一个色彩值看成三维空间里的一个点，色彩值的三个分量可以看成该点的坐标（三维坐标）。我们先不考虑，在三个维度综合情况下是怎么旋转的，我们先看看，在某个轴做为Z轴，在另两个轴形成的平面上旋转的情况，下图分析了，在将蓝色轴做为Z轴，仅在红—绿平面上旋转a度的情况：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700625229314.png" alt="20170214148700625229314.png"><br>在图中，我们可以看到，在旋转后，原R在R轴的分量变为:原R <em> cosa，但原G分量在旋转后，在R轴上也有了分量，但分量落在了负轴上，所以我们要减去这部分分量，所以最终的结果是最终的R=原R </em> cosa-原G * sina;<br>下面就看下关于几种旋转计算及结果矩阵，（注意：这几个图只标记了原X轴色彩分量的旋转，没有把Y轴色彩分量的旋转标记出来） </p>
<p><strong>绕蓝色轴旋转a度</strong><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700628579628.png" alt="20170214148700628579628.png"></p>
<p>对应的色彩变换矩阵是</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700629899842.png" alt="20170214148700629899842.png"></p>
<p><strong>绕红色轴旋转a度</strong></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700630970656.png" alt="20170214148700630970656.png"></p>
<p>对应的色彩变换矩阵是</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700631867848.png" alt="20170214148700631867848.png"></p>
<p><strong>绕绿色轴旋转a度</strong></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700633067330.png" alt="20170214148700633067330.png"></p>
<p>对应的色彩变换矩阵是</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700634190280.png" alt="20170214148700634190280.png"></p>
<p>当围绕红色轴进行色彩旋转时，由于当前红色轴的色彩是不变的，而仅利用三角函数来动态的变更绿色和蓝色的颜色值。这种改变就叫做色相调节！当围绕红色轴旋转时，是对图片就行红色色相的调节；同理，当围绕蓝色颜色轴旋转时，就是对图片就行蓝色色相调节；当然，当围绕绿色轴旋转时，就是对图片进行绿色色相的调节.</p>
<p>下面我们做一个动态的调节，针对红色色相。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702149524720160419094249915.gif" alt="201702149524720160419094249915.gif"></p>
<p>这个效果图表示的是，在滚轮正中间位置时表示旋转角度为0度，最右侧位置表示向正方向旋转180，左侧到底表示负方向旋转180.<br>同理可以得到围绕绿色轴旋转的效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702146753120160419094322134.gif" alt="201702146753120160419094322134.gif"><br>最后是，围绕蓝色轴旋转的效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702141791120160419094402991.gif" alt="201702141791120160419094402991.gif"></p>
<h5 id="5、色彩的投射运算"><a href="#5、色彩的投射运算" class="headerlink" title="5、色彩的投射运算"></a>5、色彩的投射运算</h5><p>色彩矩阵运算的公式：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700658148451.png" alt="20170214148700658148451.png"><br>其中我把红色运算给单独拉了出来，红色标记的那几个元素a12,a13,a14,在运算中，是利用G、B、A的颜色值的分量来增加红色值的。<br>来看具体的运算：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021414870066319677.png" alt="2017021414870066319677.png"><br>注意：最终结果的220=0.2 <em> 100+1 </em> 200,可见绿色分量在原有绿色分量的基础上，增加了红色分量值的0.2倍；<strong>利用其它色彩分量的倍数来更改自己色彩分量的值，这种运算就叫投射运算。</strong><br>下图阴影部分；对这些值进行修改时，修改所使用的增加值来自于其它色彩分量的信息。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700668558611.png" alt="20170214148700668558611.png"><br>色彩投射的一个最简单应用就是变为黑白图片：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">        <span class="number">0.213f</span>, <span class="number">0.715f</span>, <span class="number">0.072f</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0.213f</span>, <span class="number">0.715f</span>, <span class="number">0.072f</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0.213f</span>, <span class="number">0.715f</span>, <span class="number">0.072f</span>, <span class="number">0</span>, <span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>,       <span class="number">0</span>,    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,  </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021414870067259251.png" alt="2017021414870067259251.png"><br>首先了解一下去色原理：只要把RGB三通道的色彩信息设置成一样；即：R＝G＝B，那么图像就变成了灰色，并且，为了保证图像亮度不变，同一个通道中的R+G+B=1:如：0.213+0.715+0.072＝1；<br>三个数字的由来：0.213, 0.715, 0.072；<br>按理说应该把RGB平分，都是0.3333333。三个数字应该是根据色彩光波频率及色彩心理学计算出来的（本人是这么认为，当然也查询了一些资料，目前尚未找到准确答案）。<br>在作用于人眼的光线中，彩色光要明显强于无色光。对一个图像按RGB平分理论给图像去色的话，人眼就会明显感觉到图像变暗了（当然可能有心理上的原因，也有光波的科学依据）另外，在彩色图像中能识别的一下细节也可能会丢失。<br>所以google最终给我们的颜色值就是上面的比例：0.213, 0.715, 0.072；<br>所以，在给图像去色时我们保留了大量的G通道信息，使得图像不至于变暗或者绿色信息不至于丢失（我猜想）。<br>投射运算的另一个应用是：色彩反色<br>当我们利用色彩矩阵将两个颜色反转，这种操作就叫做色彩反色<br>比如，下面的的将红色和绿色反色（红绿反色）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700689624454.png" alt="20170214148700689624454.png"><br>左侧的图为原图，右边为红绿反色以后的效果图;<br>从矩阵中可以看出红绿反色的关键在于，第一行用绿色来代替了红色，第二行用红色代替了绿色。<br>类似可以有红蓝反色，绿蓝反色等，对应矩阵难度不大，就不再细讲了。 </p>
<p><strong>变旧照片</strong><br>投射运算的另一个应用是照片变旧，对应矩阵如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">        <span class="number">1</span>/<span class="number">2f</span>,<span class="number">1</span>/<span class="number">2f</span>,<span class="number">1</span>/<span class="number">2f</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">1</span>/<span class="number">3f</span>,<span class="number">1</span>/<span class="number">3f</span>,<span class="number">1</span>/<span class="number">3f</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">1</span>/<span class="number">4f</span>,<span class="number">1</span>/<span class="number">4f</span>,<span class="number">1</span>/<span class="number">4f</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>  </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148700695150580.png" alt="20170214148700695150580.png"></p>
<h4 id="五、ColorMatrix函数"><a href="#五、ColorMatrix函数" class="headerlink" title="五、ColorMatrix函数"></a>五、ColorMatrix函数</h4><p>上面讲了利用色彩矩阵的来做一些运算，但这些都是需要特定的色彩设计基础的，Android中ColorMatrix自带了一些函数来帮我们完成一些调整饱和度、色彩旋转等操作的函数，我们就一一来看看</p>
<h5 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h5><p>ColorMatrix共有三个构造函数：</p>
<pre><code>ColorMatrix()  
ColorMatrix(float[] src)  
ColorMatrix(ColorMatrix src) 
</code></pre><h5 id="2、设置、重置函数"><a href="#2、设置、重置函数" class="headerlink" title="2、设置、重置函数"></a>2、设置、重置函数</h5><p>第一个构造函数ColorMatrix()，需要与其它函数共用才行：</p>
<pre><code>public void set(ColorMatrix src)  
public void set(float[] src)  
public void reset()
</code></pre><h5 id="3、setSaturation——设置饱和度"><a href="#3、setSaturation——设置饱和度" class="headerlink" title="3、setSaturation——设置饱和度"></a>3、setSaturation——设置饱和度</h5><p>上面我们讲过，我们可以通过色彩的平移运算单独增强R,G,B其中一个的饱和度，但当我们需要整体增强图像的饱和度时需要如何来做呢？ColorMatrics给我们提供了一个方法来整体增强图像的饱和度，函数如下：</p>
<pre><code>public void setSaturation(float sat)  //整体增强颜色饱和度，即同时增强R,G,B的色彩饱和度
</code></pre><p>参数float sat：表示把当前色彩饱和度放大的倍数。取值为0表示完全无色彩，即灰度图像（黑白图像）；取值为1时，表示色彩不变动；当取值大于1时，显示色彩过度饱和 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> SeekBar mSeekBar;  </div><div class="line">    <span class="keyword">private</span> ImageView mImageView;  </div><div class="line">    <span class="keyword">private</span> Bitmap mOriginBmp,mTempBmp;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">        setContentView(R.layout.main);  </div><div class="line">  </div><div class="line">        mImageView = (ImageView) findViewById(R.id.img);  </div><div class="line">        mSeekBar = (SeekBar)findViewById(R.id.seekbar);  </div><div class="line">        mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.dog);  </div><div class="line">        mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(),  </div><div class="line">                Bitmap.Config.ARGB_8888);  </div><div class="line">  </div><div class="line">  </div><div class="line">        mSeekBar.setMax(<span class="number">20</span>);  </div><div class="line">        mSeekBar.setProgress(<span class="number">1</span>);  </div><div class="line">  </div><div class="line">        mSeekBar.setOnSeekBarChangeListener(<span class="keyword">new</span> SeekBar.OnSeekBarChangeListener() &#123;  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProgressChanged</span><span class="params">(SeekBar seekBar, <span class="keyword">int</span> progress, <span class="keyword">boolean</span> fromUser)</span> </span>&#123;  </div><div class="line">  </div><div class="line">                Bitmap bitmap = handleColorMatrixBmp(progress);  </div><div class="line">                mImageView.setImageBitmap(bitmap);  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartTrackingTouch</span><span class="params">(SeekBar seekBar)</span> </span>&#123;  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopTrackingTouch</span><span class="params">(SeekBar seekBar)</span> </span>&#123;  </div><div class="line">  </div><div class="line">            &#125;  </div><div class="line">        &#125;);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> Bitmap  <span class="title">handleColorMatrixBmp</span><span class="params">(<span class="keyword">int</span> progress)</span></span>&#123;  </div><div class="line">        <span class="comment">// 创建一个相同尺寸的可变的位图区,用于绘制调色后的图片  </span></div><div class="line">        Canvas canvas = <span class="keyword">new</span> Canvas(mTempBmp); <span class="comment">// 得到画笔对象  </span></div><div class="line">        Paint paint = <span class="keyword">new</span> Paint(); <span class="comment">// 新建paint  </span></div><div class="line">        paint.setAntiAlias(<span class="keyword">true</span>); <span class="comment">// 设置抗锯齿,也即是边缘做平滑处理  </span></div><div class="line">        ColorMatrix mSaturationMatrix = <span class="keyword">new</span> ColorMatrix();  </div><div class="line">        mSaturationMatrix.setSaturation(progress);  </div><div class="line">  </div><div class="line">        paint.setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(mSaturationMatrix));<span class="comment">// 设置颜色变换效果  </span></div><div class="line">        canvas.drawBitmap(mOriginBmp, <span class="number">0</span>, <span class="number">0</span>, paint); <span class="comment">// 将颜色变化后的图片输出到新创建的位图区  </span></div><div class="line">        <span class="comment">// 返回新的位图，也即调色处理后的图片  </span></div><div class="line">        <span class="keyword">return</span> mTempBmp;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214772920160419095222393.gif" alt="20170214772920160419095222393.gif"><br>滑块默认在一倍的位置，向左到底是0，向右到底是20（即饱和度放大20倍） </p>
<h5 id="4、setScale——色彩缩放"><a href="#4、setScale——色彩缩放" class="headerlink" title="4、setScale——色彩缩放"></a>4、setScale——色彩缩放</h5><p>同样，对于色彩的缩放运算ColorMatrics也已经为我们封装了一个函数：</p>
<pre><code>public void setScale(float rScale, float gScale, float bScale,float aScale)
</code></pre><p>总共有四个参数，分别对应R,G,B,A颜色值的缩放倍数。<br>比如，在小狗图片中，绿色占大部分，所以我们仅将绿色放大1.3倍：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">canvas.drawBitmap(bitmap, <span class="keyword">null</span>, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span> * bitmap.getHeight() / bitmap.getWidth()), mPaint);  </div><div class="line">  </div><div class="line">canvas.save();  </div><div class="line">canvas.translate(<span class="number">510</span>, <span class="number">0</span>);  </div><div class="line"><span class="comment">// 生成色彩矩阵  </span></div><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix();  </div><div class="line">colorMatrix.setScale(<span class="number">1</span>,<span class="number">1.3f</span>,<span class="number">1</span>,<span class="number">1</span>);  </div><div class="line">mPaint.setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(colorMatrix));  </div><div class="line">  </div><div class="line">canvas.drawBitmap(bitmap, <span class="keyword">null</span>, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span> * bitmap.getHeight() / bitmap.getWidth()), mPaint);</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703465130001.png" alt="20170214148703465130001.png"><br>在仅将绿色放大1.3倍后，整个图片看起来更鲜艳了有没有。</p>
<h5 id="5、setRotate——色彩旋转"><a href="#5、setRotate——色彩旋转" class="headerlink" title="5、setRotate——色彩旋转"></a>5、setRotate——色彩旋转</h5><p>上面在讲解色彩旋转运算时，给大家列出了在色彩旋转时的效果和原理，由于涉及到正余弦函数的计算，而且这些公式推导起来相当具有难度，所以Android的大大们，已经给我们封装好了色彩旋转的函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 将旋转围绕某一个颜色轴旋转 </div><div class="line"> * axis=0 围绕红色轴旋转 </div><div class="line"> * axis=1 围绕绿色轴旋转 </div><div class="line"> * axis=2 围绕蓝色轴旋转 </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRotate</span><span class="params">(<span class="keyword">int</span> axis, <span class="keyword">float</span> degrees)</span>；</span></div></pre></td></tr></table></figure></p>
<ul>
<li>int axis：表示围绕哪个轴旋转，取值为0，1，2；取0时表示围绕红色轴旋转；取值1时，表示围绕绿色轴旋转；取值2时，表示围绕蓝色轴旋转；</li>
<li>float degrees：表示旋转的度数</li>
</ul>
<h5 id="6、ColorMatrics相乘"><a href="#6、ColorMatrics相乘" class="headerlink" title="6、ColorMatrics相乘"></a>6、ColorMatrics相乘</h5><p>矩阵相乘涉及到三个函数：</p>
<pre><code>public void setConcat(ColorMatrix matA, ColorMatrix matB)   //这个函数接收两个ColorMatrix矩阵matA和matB，乘法规则为matA*matB，然后将结果做为当前ColorMatrix的值。

public void preConcat(ColorMatrix prematrix)   //假如当前矩阵的A，而preConcat的意思就是将当前的矩阵A乘以prematrix

public void postConcat(ColorMatrix postmatrix)  //上面prematrix是当前矩阵A*prematrix；而postConcat函数的意义就是postmatrix*当前矩阵A;这就是一个前乘，一个是后乘的区别
</code></pre><h5 id="7、getArray-获取当前矩阵数组"><a href="#7、getArray-获取当前矩阵数组" class="headerlink" title="7、getArray()获取当前矩阵数组"></a>7、getArray()获取当前矩阵数组</h5><p>getArray函数的意义就是返回当前ColorMatrics对象中的所保存的矩阵</p>
<pre><code>public float[] getArray()
</code></pre><p>好啦，本篇到这里就结束了，有关矩阵的知识是比较有难度的，但是这篇对于图像处理是至关重要的，因为在有些相机软件中会有各种滤镜效果，这些滤镜效果大部分就是通过更改ColorMatrics矩阵来完成的！当然要完全会构造ColorMatrics矩阵是需要色彩设计相关的知识的；相信通过本篇知识，你也能写出些滤镜效果了，做出来一个简单的图片处理APP也不是问题了哦。</p>
<h3 id="四、Paint之setColorFilter"><a href="#四、Paint之setColorFilter" class="headerlink" title="四、Paint之setColorFilter"></a>四、Paint之setColorFilter</h3><p>上篇给大家讲了在setColorFilter中使用ColorMatrix的过程，其实setColorFilter除了使用ColorMatrix还有其它的用法，这节我们就具体来看看setColorFilter的用法。</p>
<h4 id="一、setColorFilter"><a href="#一、setColorFilter" class="headerlink" title="一、setColorFilter"></a>一、setColorFilter</h4><pre><code>public ColorFilter setColorFilter(ColorFilter filter)
</code></pre><p>参数是传入ColorFilter的对象，其实ColorFilter是一个空对象，其中什么也没有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFilter</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> native_instance;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * <span class="doctag">@hide</span> </div><div class="line">     */  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> nativeColorFilter;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            <span class="keyword">super</span>.finalize();  </div><div class="line">        &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">            finalizer(native_instance, nativeColorFilter);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">finalizer</span><span class="params">(<span class="keyword">int</span> native_instance, <span class="keyword">int</span> nativeColorFilter)</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是ColorFilter派生了几个子类，分别是：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703589425013.png" alt="20170214148703589425013.png"></p>
<h5 id="1、ColorMatrixColorFilter"><a href="#1、ColorMatrixColorFilter" class="headerlink" title="1、ColorMatrixColorFilter"></a>1、ColorMatrixColorFilter</h5><p>这个是色彩矩阵颜色过滤器，该类只有两个函数，也都是构造函数：</p>
<pre><code>ColorMatrixColorFilter(ColorMatrix matrix)  
ColorMatrixColorFilter(float[] array)
</code></pre><p><strong>示例</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">canvas.drawBitmap(bitmap, <span class="keyword">null</span>, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span> * bitmap.getHeight() / bitmap.getWidth()), mPaint);  </div><div class="line">  </div><div class="line">canvas.translate(<span class="number">510</span>, <span class="number">0</span>);  </div><div class="line"><span class="comment">// 生成色彩矩阵  </span></div><div class="line">ColorMatrix colorMatrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">        <span class="number">1</span>/<span class="number">2f</span>,<span class="number">1</span>/<span class="number">2f</span>,<span class="number">1</span>/<span class="number">2f</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">1</span>/<span class="number">3f</span>,<span class="number">1</span>/<span class="number">3f</span>,<span class="number">1</span>/<span class="number">3f</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">1</span>/<span class="number">4f</span>,<span class="number">1</span>/<span class="number">4f</span>,<span class="number">1</span>/<span class="number">4f</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>  </div><div class="line">&#125;);  </div><div class="line">mPaint.setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(colorMatrix));  </div><div class="line">  </div><div class="line">canvas.drawBitmap(bitmap, <span class="keyword">null</span>, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span> * bitmap.getHeight() / bitmap.getWidth()), mPaint);</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703612776387.png" alt="20170214148703612776387.png"></p>
<h5 id="2、LightingColorFilter"><a href="#2、LightingColorFilter" class="headerlink" title="2、LightingColorFilter"></a>2、LightingColorFilter</h5><p>前一篇，我们利用一篇的篇幅来讲解ColorMatrix的作用，所有需要完成色彩操作的都是可以利用ColorMatrix来完成的，只是有一点ColorMatrix纵然很强大，但太！过！难！用，所以Android为我们提供了一个简单过滤颜色和增强色彩的函数，就是LightingColorFilter<br>这个叫做光照颜色过滤器，可以简单的完成色彩过滤和色彩增强功能。<br>整个类就只有一个函数，还是构造函数：</p>
<pre><code>public LightingColorFilter(int mul, int add)
</code></pre><p>这里有两个参数,mul是乘法multiply的缩写，add是加法的意思。mul和add取值都是0xRRGGBB,分别对应R、G、B颜色，注意哦，这里是没有透明度A的，透明度在这里是不起作用的，LightingColorFilter只针对RGB色值起作用<br>比如，当前有一个颜色值为（r,g,b），对它应用LightingColorFilter(mul, add)效果后的颜色值为：</p>
<pre><code>结果R值 = (r*mul.R+add.R)%255;  
结果G值 = (g*mul.G+add.G)%255;  
结果B值 = (b*mul.B+add.B)%255;
</code></pre><p>作用LightingColorFilter(mul, add)效果后的R值等于，原来的r值乘以mul.R,然后再加上add.R做为最终结果。因为颜色值要的取值范围在0-255，所以要把结果对255取余，得到最终结果。<br>所以从公式中可以看出mul.R是对当前红色值进行放大的倍数；而add.R则表示对当前红色增加的数值；它们对应ColorMatrix的位置如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703629241194.png" alt="20170214148703629241194.png"></p>
<p>利用mul进行颜色值放大并不好控制，所以更多的是用来过滤颜色，即当对应的颜色值取0时，就不会将对应的颜色显示出来，而把要显示出来的颜色对应的mul值设置为ff,即255;从公式中可以知道设置为255不会对原始的这个颜色分量产生任何影响。所以这样就可以把想要的颜色给显示出来，把不想要的颜色给过滤掉<br>比如，下面这个蓝色按钮：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021414870363224165.png" alt="2017021414870363224165.png"><br>我们可以在点击时让它变成绿色，这要怎么做呢？直接使用LightingColorFilter把其它颜色都过滤掉，只显示绿色就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap mBmp;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.btn);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">        <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">        canvas.translate(<span class="number">0</span>,<span class="number">550</span>);  </div><div class="line">        mPaint.setColorFilter(<span class="keyword">new</span> LightingColorFilter(<span class="number">0x00ff00</span>,<span class="number">0x000000</span>));  </div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里把mul参数设置为0x00ff00，即把绿色显示出来，把R和B过滤掉。而add参数全部设置为0，即没有对原始图像色彩做任何改变<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021414870364118549.png" alt="2017021414870364118549.png"><br>好像这样会有点问题，因为普通我们在点击按钮的时候，不可能会直接把它改变成另一个颜色，而只是增加它的颜色深浅值。比如下面我们增强颜色的蓝色值，将整个图片变得更蓝<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">   <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">   mPaint.setAntiAlias(<span class="keyword">true</span>);  </div><div class="line">  </div><div class="line">   <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">   <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">   canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">   canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">   mPaint.setColorFilter(<span class="keyword">new</span> LightingColorFilter(<span class="number">0xffffff</span>,<span class="number">0x0000f0</span>));  </div><div class="line">   canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mul参数设置为0xffffff，即没有对颜色做任何改变；add参数设置为0x0000f0，即在每个像素的蓝色值在原来基础上增加0xf0，让原来的图像变得更蓝；这样会显得整个图片的颜色更深。更像按压后的效果。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703647526942.png" alt="20170214148703647526942.png"></p>
<h5 id="3、PorterDuffColorFilter"><a href="#3、PorterDuffColorFilter" class="headerlink" title="3、PorterDuffColorFilter"></a>3、PorterDuffColorFilter</h5><p>这个叫PorterDuff颜色滤镜，也叫图形混合滤镜；其名称是Tomas Proter和Tom Duff两个人名的缩写，他们提出的图形混合的概念极大地推动了图形图像学的发展。</p>
<pre><code>public PorterDuffColorFilter(int srcColor, PorterDuff.Mode mode)
</code></pre><ul>
<li>int srcColor：0xAARRGGBB类型的颜色值。</li>
<li>PorterDuff.Mode mode：表示混合模式，枚举值有18个，表示各种图形混合模式,有：<ul>
<li>Mode.CLEAR  </li>
<li>Mode.SRC  </li>
<li>Mode.DST  </li>
<li>Mode.SRC_OVER  </li>
<li>Mode.DST_OVER  </li>
<li>Mode.SRC_IN  </li>
<li>Mode.DST_IN  </li>
<li>Mode.SRC_OUT  </li>
<li>Mode.DST_OUT  </li>
<li>Mode.SRC_ATOP  </li>
<li>Mode.DST_ATOP  </li>
<li>Mode.XOR  </li>
<li>Mode.DARKEN (变暗)</li>
<li>Mode.LIGHTEN (变亮)</li>
<li>Mode.MULTIPLY (正片叠底)</li>
<li>Mode.SCREEN (滤色)</li>
<li>Mode.OVERLAY (叠加)</li>
<li>Mode.ADD (饱和度相加)</li>
</ul>
</li>
</ul>
<p>我们拿正片叠底来试下效果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap mBmp;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);  </div><div class="line">        drawPorterDuffFilter(canvas);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPorterDuffFilter</span><span class="params">(Canvas canvas)</span></span>&#123;  </div><div class="line">        <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">        <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">        canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">        mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.MULTIPLY));<span class="comment">//变暗  </span></div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703676868315.png" alt="20170214148703676868315.png"><br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702148063320160426230742070.gif" alt="201702148063320160426230742070.gif"></p>
<p>在录相中给大家演示了通过Photoshop来改变混合模式的过程，录相中分别更改了Mode.DARKEN（变暗），Mode.LIGHTEN（变亮），Mode.MULTIPLY（正片叠底），Mode.OVERLAY（叠加），Mode.SCREEN（滤色）这五种效果，大家可以尝试，我们通过代码得到的效果是与PhotoShop中的模式相同的。但PhotoShop中要比我们中强大的多，除了这些模式以外，还有其它的一些模式是我们所没有的；当然，PhotoShop中的所有这些效果都是可以通过ColorMetrix完成的，但前提是数学和色彩设计知识都要很棒才行哦。但Mode.ADD(饱和度)相加在Photoshop中是没有的。<br>下面我通过代码把这几个效果给大家分别画出来：<br>效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703689726848.png" alt="20170214148703689726848.png"></p>
<p>对应代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap mBmp;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        mPaint.setAntiAlias(<span class="keyword">true</span>);  </div><div class="line">  </div><div class="line">        drawPorterDuffFilter(canvas);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPorterDuffFilter</span><span class="params">(Canvas canvas)</span></span>&#123;  </div><div class="line">        <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">        <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">  </div><div class="line">        mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.ADD));<span class="comment">//饱和度相加  </span></div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">  </div><div class="line">        canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">        mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DARKEN));<span class="comment">//变暗  </span></div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">        canvas.translate(-<span class="number">550</span>,<span class="number">550</span>);  </div><div class="line">        mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.LIGHTEN));<span class="comment">//变亮  </span></div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">        canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">        mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.MULTIPLY));<span class="comment">//正片叠底  </span></div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">        canvas.translate(-<span class="number">550</span>,<span class="number">550</span>);  </div><div class="line">        mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.OVERLAY));<span class="comment">//叠加  </span></div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">        canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">        mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SCREEN));<span class="comment">//滤色  </span></div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里大家不必理解PorterDuff.Mode的具体算法，只需要知道应用哪个模式，对应效果是怎样的就可以了。<br>除了上面的六个Mode，还有其它的三组Mode，由于每组Mode的效果都是相同的，所以我们分组来讲 </p>
<p><strong>第一组：清空模式</strong></p>
<p>Mode.CLEAR和Mode.XOR他们在这里的效果是完成一致的，就是把图像清空，所以一旦应用他们两个中的任何一个，所得到的结果图像就是一个空图<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPorterDuffFilter</span><span class="params">(Canvas canvas)</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">    <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.CLEAR));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(-<span class="number">550</span>,<span class="number">550</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.XOR));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>第二组：目标图像模式</strong><br>在Mode模式中，有一组DST相关的模式，DST所代表的意义就是被应用模式的图像，即我们这里的小狗图片。这些模式有：Mode.DST、Mode.DST_IN、Mode.DST_OUT、Mode.DST_OVER、Mode.DST_ATOP下面我们来看看他们的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPorterDuffFilter</span><span class="params">(Canvas canvas)</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">    <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(-<span class="number">550</span>,<span class="number">550</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_IN));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_OUT));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(-<span class="number">550</span>,<span class="number">550</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_OVER));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_ATOP));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021414870370673745.png" alt="2017021414870370673745.png"><br>从效果图中可以看到，除了Mode.DST_OUT显示完全透明图片以外，其它全部显示目标图像；<br>所以这几个模式在PorterDuffColorFilter的实际应用中，并没什么用。 </p>
<p><strong>第三组：源图模式</strong></p>
<p>在Mode模式中，有一组SRC相关的模式,SRC表示的颜色值所代表的图像，这些模式有：Mode.SRC、Mode.SRC_IN、Mode.SRC_OUT、Mode.SRC_OVER、Mode.SRC_ATOP下面我们来看看他们的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPorterDuffFilter</span><span class="params">(Canvas canvas)</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">    <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(-<span class="number">550</span>,<span class="number">550</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_IN));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_OUT));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(-<span class="number">550</span>,<span class="number">550</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_OVER));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">550</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_ATOP));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703716059147.png" alt="20170214148703716059147.png"></p>
<p>从效果图中可以看出，除了Mode.SRC_OUT显示完全透明图片以外，其它全部显示源图像；<br>利用这个特性，我们可以在不同情况下，改变一个纯色图标的颜色。这个也是V4包中DrawableCompat类添加的一个setLint()函数所使用实现方法</p>
<pre><code>setTint(Drawable drawable, int tint)
</code></pre><p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703723948421.png" alt="20170214148703723948421.png"></p>
<p>即最左边是一原图，后面都是指定的各个颜色，利用setTint就可以把一个图片渲染为不同的颜色，这样就可以支持多主题，在不同的风格和不同的情境下使用不同的颜色的图片。由于仅使用一个图片就可以实现多个主题，就不必再引入多个颜色的切图，就可以在一定程度上缩小包的大小。<br>我们不必引入V4包，仅仅通过PorterDuffColorFilter就可以实现setTint的功能:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPorterDuffFilter</span><span class="params">(Canvas canvas)</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> width  = <span class="number">100</span>;  </div><div class="line">    <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">150</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(<span class="number">0xffff00ff</span>, PorterDuff.Mode.SRC));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">150</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(<span class="number">0xff00f0ff</span>, PorterDuff.Mode.SRC_ATOP));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">150</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(<span class="number">0xfff0f0ff</span>, PorterDuff.Mode.SRC_IN));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">150</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(<span class="number">0xffffff00</span>, PorterDuff.Mode.SRC_OVER));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">  </div><div class="line">  </div><div class="line">    canvas.translate(<span class="number">150</span>,<span class="number">0</span>);  </div><div class="line">    mPaint.setColorFilter(<span class="keyword">new</span> PorterDuffColorFilter(<span class="number">0xff000000</span>, PorterDuff.Mode.SRC_ATOP));  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148703738585408.png" alt="20170214148703738585408.png"></p>
<p>从效果图中可以看到，SRC相关的模式，只有Mode.SRC_ATOP和SRC_IN能够实现SetTint的功能，其它的是不行的。这里先记着就可以了，后面地讲原理时会具体讲原因。<br>所以这里的一个应用就是通过PorterDuffColorFilter的Mode.SRC_ATOP或SRC_IN模式实现SetTint()的功能；<br>有些同学可能会讲，这个功能是不是可以通过ColorMatrix来实现？当然是可以的，比如我们要将原图标改成第三个效果，即颜色为0xff00f0ff，所对应的矩阵为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ColorMatrix matrix = <span class="keyword">new</span> ColorMatrix(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">240</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>,  </div><div class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>  </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ul>
<li>1、PorterDuffColorFilter只能实现与一个特定颜色值的合成。 </li>
<li>2、通过Mode.ADD(饱和度相加)，Mode.DARKEN（变暗），Mode.LIGHTEN（变亮），Mode.MULTIPLY（正片叠底），Mode.OVERLAY（叠加），Mode.SCREEN（滤色）可以实现与指定颜色的复合。 </li>
<li>3、通过Mode.SRC、Mode.SRC_IN、Mode.SRC_ATOP能够实现setTint()的功能，可以改变纯色图标的颜色。</li>
</ul>
<h3 id="五、Paint之setXfermode-一"><a href="#五、Paint之setXfermode-一" class="headerlink" title="五、Paint之setXfermode(一)"></a>五、Paint之setXfermode(一)</h3><h4 id="一、GPU硬件加速"><a href="#一、GPU硬件加速" class="headerlink" title="一、GPU硬件加速"></a>一、GPU硬件加速</h4><h5 id="1、概述-5"><a href="#1、概述-5" class="headerlink" title="1、概述"></a>1、概述</h5><p>GPU英文全称Graphic Processing Unit，中文翻译为“图形处理器”。与CPU不同，GPU是专门为处理图形任务而产生的芯片。<br>在GPU出现之前，CPU一直负责着所有的运算工作，CPU的架构是有利于X86指令集的串行架构，CPU从设计思路上适合尽可能快的完成一个任务。但当面对类似多媒体、图形图像处理类型的任务时，就显得力不从心。因为在多媒体计算中通常要求更高的运算密度、多并发线程和频繁地存储器访问；显然当你打游戏时，屏幕上的动画是需要实时刷新的，这些都需要频繁的计算、存取动作；如果CPU不能及时响应，那么屏幕就会显得很卡……你的队友可能会发一句……我等的花都谢了，你咋还不动呢……<br>为了专门处理多媒体的计算、存储任务，GPU就应运而生了，GPU中自带处理器和存储器，以用来专门计算和存储多媒体任务。<br>对于Andorid来讲，在API 11之前是没有GPU的概念的，在API 11之后，在程序集中加入了对GPU加速的支持，在API 14之后，硬件加速是默认开启的！我们可以显式地强制图像计算时使用GPU而不使用CPU.<br>在CPU绘制和GPU绘制时，在流程上是有区别的：<br>在基于软件的绘制模型下，CPU主导绘图，视图按照两个步骤绘制：</p>
<ul>
<li>让View层次结构失效</li>
<li><p>绘制View层次结构<br>在基于硬件加速的绘制模式下，GPU主导绘图，绘制按照三个步骤绘制：</p>
</li>
<li><p>让View层次结构失效</p>
</li>
<li>记录、更新显示列表</li>
<li>绘制显示列表<br>可以看到在GPU加速时，流程中多了一项“记录、更新显示列表”，它表示在第一步View层次结构失效后，并不是直接开始逐层绘制，而是首先把这些View的绘制函数作为绘制指令记录一个显示列表中，然后再读取显示列表中的绘制指令调用OpenGL相关函数完成实际绘制。所以在GPU加速时，实际是使用OpenGL的函数来完成绘制的。<br>所以使用GPU加速的优点显而易见：硬件加速提高了Android系统显示和刷新的速度；<br>它有缺点也显而易见： </li>
<li>兼容性问题:由于是将绘制函数转换成OpenGL命令来绘制，定然会存在OpenGL并不能完全支持原始绘制函数的问题，所以这就会造成在打开GPU加速时，效果会失效的问题。 </li>
<li>内存消耗问题:由于需要OpenGL的指令，所以需要把系统中的OpenGL相关的包加载到内存中来，所以单纯OpenGL API调用就会占用8MB，而实际上会占用更多内存； </li>
<li>电量消耗问题:多使用了一个部件，当然会更耗电……</li>
</ul>
<p>下图显示了一些特殊函数硬件加速开始支持的平台等级：（红叉表示任何平台都不支持，不在列表中的默认在API 11就开始支持）<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148704021971161.png" alt="20170214148704021971161.png"><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148704029774250.png" alt="20170214148704029774250.png"><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148704030478886.png" alt="20170214148704030478886.png"><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148704030981103.png" alt="20170214148704030981103.png"><br><strong>上面我们涉及了两个API等级，在API 11以后，在程序集中加入了对GPU加速的支持，在API 14之后，硬件加速是默认开启的！也就是说在API 11——API 13虽然是支持硬件加速的，但是默认是关闭的。</strong></p>
<h5 id="2、禁用GPU硬件加速方法"><a href="#2、禁用GPU硬件加速方法" class="headerlink" title="2、禁用GPU硬件加速方法"></a>2、禁用GPU硬件加速方法</h5><p>那么问题就来了，如果你的APP跑在API 14版本以后，而你洽好要用那些不支持硬件加速的函数要怎么办？<br>那就只好禁用硬件加速喽，针对不同类型的东东，Android给我们提供了不同的禁用方法：<br>硬件加速分全局（Application）、Activity、Window、View 四个层级 </p>
<h6 id="1-在AndroidManifest-xml文件为application标签添加如下的属性即可为整个应用程序开启-关闭硬件加速："><a href="#1-在AndroidManifest-xml文件为application标签添加如下的属性即可为整个应用程序开启-关闭硬件加速：" class="headerlink" title="1.在AndroidManifest.xml文件为application标签添加如下的属性即可为整个应用程序开启/关闭硬件加速："></a>1.在AndroidManifest.xml文件为application标签添加如下的属性即可为整个应用程序开启/关闭硬件加速：</h6><pre><code>&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt;
</code></pre><h6 id="2-在Activity-标签下使用-hardwareAccelerated-属性开启或关闭硬件加速："><a href="#2-在Activity-标签下使用-hardwareAccelerated-属性开启或关闭硬件加速：" class="headerlink" title="2.在Activity 标签下使用 hardwareAccelerated 属性开启或关闭硬件加速："></a>2.在Activity 标签下使用 hardwareAccelerated 属性开启或关闭硬件加速：</h6><pre><code>&lt;activity android:hardwareAccelerated=&quot;false&quot; /&gt;
</code></pre><h6 id="3-在Window-层级使用如下代码开启硬件加速：-Window层级不支持关闭硬件加速"><a href="#3-在Window-层级使用如下代码开启硬件加速：-Window层级不支持关闭硬件加速" class="headerlink" title="3. 在Window 层级使用如下代码开启硬件加速：(Window层级不支持关闭硬件加速)"></a>3. 在Window 层级使用如下代码开启硬件加速：(Window层级不支持关闭硬件加速)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getWindow().setFlags(  </div><div class="line">WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,  </div><div class="line">WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</div></pre></td></tr></table></figure>
<h6 id="4-View-级别如下关闭硬件加速：（view-层级上不支持开启硬件加速）"><a href="#4-View-级别如下关闭硬件加速：（view-层级上不支持开启硬件加速）" class="headerlink" title="4.View 级别如下关闭硬件加速：（view 层级上不支持开启硬件加速）"></a>4.View 级别如下关闭硬件加速：（view 层级上不支持开启硬件加速）</h6><pre><code>setLayerType(View.LAYER_TYPE_SOFTWARE, null);
</code></pre><p>或者使用android:layerType=”software”来关闭硬件加速：比如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span>  </div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span>  </div><div class="line">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>  </div><div class="line">    <span class="attr">android:paddingLeft</span>=<span class="string">"2dp"</span>  </div><div class="line">    <span class="attr">android:layerType</span>=<span class="string">"software"</span>  </div><div class="line">    <span class="attr">android:paddingRight</span>=<span class="string">"2dp"</span> &gt;</div></pre></td></tr></table></figure>
<h4 id="二、setXfermode-Xfermode-xfermode-之AvoidXfermode"><a href="#二、setXfermode-Xfermode-xfermode-之AvoidXfermode" class="headerlink" title="二、setXfermode(Xfermode xfermode)之AvoidXfermode"></a>二、setXfermode(Xfermode xfermode)之AvoidXfermode</h4><p>这个函数是图像混合里最难的一个了，它的功能也是相当强大的，这个模式叫做图形混合模式。<br>与setColorFilter一样，派生自Xfermode的有三个类：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148704066929879.png" alt="20170214148704066929879.png"></p>
<h5 id="1、概述——基本流程"><a href="#1、概述——基本流程" class="headerlink" title="1、概述——基本流程"></a>1、概述——基本流程</h5><p>从上面可以看出，派生自Xfermode的有AvoidXfermode，PixelXorXfermode，PorterDuffXfermode;<br>从硬件加速不支持的函数列表中，我们可以看到AvoidXfermode，PixelXorXfermode是完全不支持的，而PorterDuffXfermode是部分不支持的。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148704071326352.png" alt="20170214148704071326352.png"><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148704071882068.png" alt="20170214148704071882068.png"></p>
<p>所以在使用Xfermode时，为了保险起见，我们需要做两件事：</p>
<ul>
<li>禁用硬件加速：<br>  <code>setLayerType(View.LAYER_TYPE_SOFTWARE, null);</code></li>
<li>使用离屏绘制  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//新建图层  </span></div><div class="line"><span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,width,height,mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line"> 	<span class="comment">//TODO 核心绘制代码</span></div><div class="line"><span class="comment">//还原图层  </span></div><div class="line">canvas.restoreToCount(layerID);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我们需要把绘制的核心代码放在saveLayer()和restoreToCount()之间即可。<br>下面我们先简单讲解AvoidXfermode的用法，然后写个例子，看下SetXfermode()的使用方法和效果<br>AvoidXfermode的声明如下：</p>
<pre><code>public AvoidXfermode(int opColor, int tolerance, Mode mode)
</code></pre><p>当Mode取Mode.TARGET时，它的意义表示将opColor参数所指定的颜色替换成画笔的颜色。</p>
<ul>
<li>第一个参数opColor：一个16进制的AARRGGBB的颜色值； </li>
<li>第二个参数tolerance：表示容差，这个概念我们后面再细讲 </li>
<li>第三个参数mode：取值有两个Mode.TARGET和Mode.AVOID；这里我们先知道Mode.TARGET的意义就可以了，Mode.TARGET表示将指定的颜色替换掉 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap mBmp;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">        <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,width,height,mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">new</span> AvoidXfermode(Color.WHITE,<span class="number">100</span>, AvoidXfermode.Mode.TARGET));  </div><div class="line">        canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,width,height,mPaint);  </div><div class="line">  </div><div class="line">        canvas.restoreToCount(layerID);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170214148704099660317.png" alt="20170214148704099660317.png"></p>
<pre><code>mPaint.setXfermode(new AvoidXfermode(Color.WHITE,100, AvoidXfermode.Mode.TARGET));
</code></pre><p>这一点与Photoshop是类似的，就是以白色为目标色，容差为100找到对应的选区；<br>容差是以颜色差异为基础的，任何两个颜色之间的颜色差异是从0-255的范围内的。具体两个颜色之间的差异的的数值为多少是需要靠公式来计算的，而容差的概念就是指与目标色所能容忍的最大颜色差异，所以容差越大，所覆盖的颜色区域就越大；所以当容差为0时，就表示只选择与目标色一模一样的颜色区域；当容差为100时，就表示与目标色值的颜色差异在100范围内的都是可以的；而由于最大的颜色差异是255，所以当我们的容差是255时，所有的颜色都将被选中。</p>
<h5 id="2、canvas脏区域更新原理"><a href="#2、canvas脏区域更新原理" class="headerlink" title="2、canvas脏区域更新原理"></a>2、canvas脏区域更新原理</h5><p>Android在绘图时会先检查该画笔Paint对象有没有设置Xfermode，如果没有设置Xfermode，那么直接将绘制的图形覆盖Canvas对应位置原有的像素；如果设置了Xfermode，那么会按照Xfermode具体的规则来更新Canvas中对应位置的像素颜色。所以对于AvoidXfermode而言，这个规则就是先把把目标区域（选区）中的颜色值先清空，然后再把目标颜色给替换上；<br>如果没有设置Xfermode，那么直接将绘制的图形覆盖Canvas对应位置原有的像素；如果设置了Xfermode，那么会按照Xfermode具体的规则来更新Canvas中对应位置的像素颜色。</p>
<h5 id="3、AvoidXfermode"><a href="#3、AvoidXfermode" class="headerlink" title="3、AvoidXfermode"></a>3、AvoidXfermode</h5><p>在讲解了AvoidXfermode的绘图流程和脏区域更新原理后，这里就开始具体的来看看AvoidXfermode这个函数了；<br>AvoidXfermode类已经在API 16弃用了，但目前还没有能替代它的方法，所以API 16以上的平台还是支持的。如果大家想在API 16以上使用这个类，唯一需要注意的是它不支持硬件加速，所以记得禁用硬件加速就可以了；<br>AvoidXfermode的声明如下：</p>
<pre><code>public AvoidXfermode(int opColor, int tolerance, Mode mode)
</code></pre><ul>
<li>第一个参数opColor：一个16进制的AARRGGBB的颜色值； </li>
<li>第二个参数tolerance：表示容差，这个概念我们后面再细讲 </li>
<li>第三个参数mode：取值有两个Mode.TARGET和Mode.AVOID；Mode.TARGET表示将指定的颜色替换掉，这个我们已经前面演示过了，而Mode.AVOID的意思就是Mode.TARGET所选区域的取反。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> width  = <span class="number">500</span>;  </div><div class="line">    <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();  </div><div class="line">    mPaint.setColor(Color.RED);  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,width,height,mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line">  </div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);  </div><div class="line">    mPaint.setXfermode(<span class="keyword">new</span> AvoidXfermode(Color.WHITE,<span class="number">100</span>, AvoidXfermode.Mode.AVOID));  </div><div class="line">    canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,width,height,mPaint);  </div><div class="line">  </div><div class="line">    canvas.restoreToCount(layerID);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725592682735.png" alt="20170216148725592682735.png"></p>
<p>因为Android里计算容差与Photoshop的不同，在Photoshop中容差为255时表示全图选区，而在Android中的选区却不是全图！就是因为在计算颜色差值计算时的差异导致的。 </p>
<h4 id="三、setXfermode-Xfermode-xfermode-之PixelXorXfermode"><a href="#三、setXfermode-Xfermode-xfermode-之PixelXorXfermode" class="headerlink" title="三、setXfermode(Xfermode xfermode)之PixelXorXfermode"></a>三、setXfermode(Xfermode xfermode)之PixelXorXfermode</h4><p>与AvoidXfermode一样也在API 16过时了,它是一个简单的异或运算(op ^ src ^ dst)，返回的alpha值始终等于255，所以对操作颜色混合不是特别的有效；<br>这个类的用法难度不大，而且基本上用不到，这里就不再细讲了，大家有兴趣的话，可以尝试一下。</p>
<h4 id="四、setXfermode-Xfermode-xfermode-之PorterDuffXfermode"><a href="#四、setXfermode-Xfermode-xfermode-之PorterDuffXfermode" class="headerlink" title="四、setXfermode(Xfermode xfermode)之PorterDuffXfermode"></a>四、setXfermode(Xfermode xfermode)之PorterDuffXfermode</h4><h5 id="1、概述-6"><a href="#1、概述-6" class="headerlink" title="1、概述"></a>1、概述</h5><p>PorterDuffXfermode的构造函数如下：</p>
<pre><code>public PorterDuffXfermode(PorterDuff.Mode mode)
</code></pre><p>它只有一个参数PorterDuff.Mode，对于PorterDuff.Mode大家应该比较熟悉，我们在讲解setColorFilter时已经用过它：</p>
<pre><code>mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.OVERLAY));  
</code></pre><p>前面我们讲过PorterDuff.Mode表示混合模式，枚举值有18个，表示各种图形混合模式,有：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725758848921.png" alt="20170216148725758848921.png"></p>
<p>比如LIGHTEN的计算方式为[Sa + Da - Sa <em> Da, Sc </em> (1 - Da) + Dc <em> (1 - Sa) + max(Sc, Dc)]，其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，在每个公式中，都会被分为两部分[……，……]，其中“,”前的部分为“Sa + Da - Sa </em> Da”这一部分的值代表计算后的Alpha通道而“,”后的部分为“Sc <em> (1 - Da) + Dc </em> (1 - Sa) + max(Sc, Dc)”这一部分的值代表计算后的颜色值，图形混合后的图片就是依据这个公式来对DST和SRC两张图像中每一个像素进行计算，得到最终的结果的。<br>Google给我们了一张图，显示的是两个图形一圆一方通过一定的计算产生不同的组合效果，其中圆形是底部的目标图像，方形是上方的源图像。</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725772438748.png" alt="20170216148725772438748.png"></p>
<p>在上面的公式中涉及到一个概念，目标图DST，源图SRC。那什么是源图，什么是目标图呢？我们简单举例子来说明一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width = <span class="number">400</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height = <span class="number">400</span>;  </div><div class="line">    <span class="keyword">private</span> Bitmap dstBmp;  </div><div class="line">    <span class="keyword">private</span> Bitmap srcBmp;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        dstBmp = makeDst(width,height);  </div><div class="line">        srcBmp = makeSrc(width,height);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,width*<span class="number">2</span>,height*<span class="number">2</span>,mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(dstBmp, <span class="number">0</span>, <span class="number">0</span>, mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));  </div><div class="line">        canvas.drawBitmap(srcBmp, width/<span class="number">2</span>, height/<span class="number">2</span>, mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">  </div><div class="line">        canvas.restoreToCount(layerID);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">static</span> Bitmap <span class="title">makeDst</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;  </div><div class="line">        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  </div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(bm);  </div><div class="line">        Paint p = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);  </div><div class="line">  </div><div class="line">        p.setColor(<span class="number">0xFFFFCC44</span>);  </div><div class="line">        c.drawOval(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, w, h), p);  </div><div class="line">        <span class="keyword">return</span> bm;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">static</span> Bitmap <span class="title">makeSrc</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;  </div><div class="line">        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  </div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(bm);  </div><div class="line">        Paint p = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);  </div><div class="line">  </div><div class="line">        p.setColor(<span class="number">0xFF66AAFF</span>);  </div><div class="line">        c.drawRect(<span class="number">0</span>, <span class="number">0</span>,w,h, p);  </div><div class="line">        <span class="keyword">return</span> bm;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725778099705.png" alt="20170216148725778099705.png"></p>
<p>它会在源图像所在区域与目标图像运算，在得到结果以后，将结果覆盖到目标图像上。整个过程如下：<br>首先在两个矩形的所在位置：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725815717705.png" alt="20170216148725815717705.png"></p>
<p>然后是源图像计算结果的覆盖过程：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725818017115.png" alt="20170216148725818017115.png"></p>
<p>其中蓝色小块是源图像所在区域与目标图像经过运算的结果（有关这个结果为什么是一小块蓝色，下篇会具体讲），在得到结果以后，把结果对应区域的图像先清空，然后把结果覆盖上去。（还记得我们在讲解canvas脏数据更新的时候提到，如果没有xfermode就直接覆盖上去，如果有xfermode则先清空对应的区域，然后再覆盖上去）；<br>这里还需要强调一点，源图像在运算时，只是在源图像所在区域与对应区域的目标图像做运算。所以目标图像与源图像不相交的地方是不会参与运算的！这一点非常重要！不相交的地方不会参与运算，所以不相交的地方的图像也不会是脏数据，也不会被更新，所以不相交地方的图像也永远显示的是目标图像。</p>
<h3 id="六、Paint之setXfermode-二"><a href="#六、Paint之setXfermode-二" class="headerlink" title="六、Paint之setXfermode(二)"></a>六、Paint之setXfermode(二)</h3><p>这篇文章将逐个讲解每个模式的意义。这里所讲的各种模式，在大家理解了之后可以回过头来看看setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.XXXX));中的混合过程，其实在PorterDuffColorFilter中的混合过程与这里的setXfermode()设置混合模式的计算方式和效果是完全相同的，只是在PorterDuffColorFilter中只能使用纯色彩，而且是完全覆盖在图片上方；而setXfermode()则不同，它只会在目标图像和源图像交合的位置起作用，而且源图像不一定是纯色的。<br>在开始讲解之前，我们随便拿一个效果图来看一下，我们在这个效果图中需要关注哪两点</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725905356002.png" alt="20170216148725905356002.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">canvas.drawBitmap(dstBmp, <span class="number">0</span>, <span class="number">0</span>, mPaint);  </div><div class="line">mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.LIGHTEN));  </div><div class="line">canvas.drawBitmap(srcBmp,width/<span class="number">2</span>,height/<span class="number">2</span>, mPaint);</div></pre></td></tr></table></figure>
<p>前面在讲canvas的脏区域更新时，已经提到，在最后一句计算效果图像时，是以源图像所在区域为计算目标的，把计算后的源图像更新到对应区域内。<br>所以如上图所示，我们在计算源图像所在区域效果图时，需要着重关注两个区域：<br>1、如图标示区域一：区域一是源图像和目标图像的相交区域，由于在这个区域源图像和目标图像像素都不是空白像素，所以可以明显看出颜色的计算效果。<br>2、如图标示区域二：在区域二中，源图像所在区域的目标图像是空白像素，所以这块区域所表示的意义就是，当某一方区域是空白像素时，此时的计算结果。<br><strong>总而言之：我们在下面的各个模式计算时，只需要关注图示中的区域一和区域二；其中区域一表示当源图像和目标图像像素都不是空白像素时的计算结果，而区域二则表示当某一方区域是空白像素时，此时的计算结果。</strong></p>
<h4 id="一、颜色叠加相关模式"><a href="#一、颜色叠加相关模式" class="headerlink" title="一、颜色叠加相关模式"></a>一、颜色叠加相关模式</h4><p>这部分涉及到的几个模式有Mode.ADD（饱和度相加）、Mode.DARKEN（变暗），Mode.LIGHTEN（变亮）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加），Mode.SCREEN（滤色）</p>
<h5 id="1、Mode-ADD（饱和度相加）"><a href="#1、Mode-ADD（饱和度相加）" class="headerlink" title="1、Mode.ADD（饱和度相加）"></a>1、Mode.ADD（饱和度相加）</h5><p>它的公式是Saturate(S + D)；ADD模式简单来说就是对SRC与DST两张图片相交区域的饱和度进行相加<br>同样使用上篇中的示例，一个矩形，一个圆形来做相加 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width = <span class="number">400</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height = <span class="number">400</span>;  </div><div class="line">    <span class="keyword">private</span> Bitmap dstBmp;  </div><div class="line">    <span class="keyword">private</span> Bitmap srcBmp;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);    </div><div class="line">        srcBmp = makeSrc(width, height);  </div><div class="line">        dstBmp = makeDst(width, height);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,width*<span class="number">2</span>,height*<span class="number">2</span>,mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(dstBmp, <span class="number">0</span>, <span class="number">0</span>, mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.ADD));  </div><div class="line">        canvas.drawBitmap(srcBmp,width/<span class="number">2</span>,height/<span class="number">2</span>, mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">  </div><div class="line">        canvas.restoreToCount(layerID);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// create a bitmap with a circle, used for the "dst" image  </span></div><div class="line">    <span class="function"><span class="keyword">static</span> Bitmap <span class="title">makeDst</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;  </div><div class="line">        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  </div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(bm);  </div><div class="line">        Paint p = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);  </div><div class="line">  </div><div class="line">        p.setColor(<span class="number">0xFFFFCC44</span>);  </div><div class="line">        c.drawOval(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, w, h), p);  </div><div class="line">        <span class="keyword">return</span> bm;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// create a bitmap with a rect, used for the "src" image  </span></div><div class="line">    <span class="function"><span class="keyword">static</span> Bitmap <span class="title">makeSrc</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;  </div><div class="line">        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  </div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(bm);  </div><div class="line">        Paint p = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);  </div><div class="line">  </div><div class="line">        p.setColor(<span class="number">0xFF66AAFF</span>);  </div><div class="line">        c.drawRect(<span class="number">0</span>, <span class="number">0</span>, w, h, p);  </div><div class="line">        <span class="keyword">return</span> bm;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725918989611.png" alt="20170216148725918989611.png"></p>
<p>从效果图中可以看出，只有源图与目标图像相交的部分的图像的饱和度产生了变化，没相交的部分是没有变的，因为对方的饱和度是0，当然不相交的位置饱和度是不会变的。<br>这个模式的应用范围比较少，暂时想不到哪里会用到；</p>
<h5 id="2、Mode-LIGHTEN（变亮）"><a href="#2、Mode-LIGHTEN（变亮）" class="headerlink" title="2、Mode.LIGHTEN（变亮）"></a>2、Mode.LIGHTEN（变亮）</h5><p>它的算法是： [Sa + Da - Sa <em> Da,Sc </em> (1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)]<br>圆形和矩形的效果图为：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725924055197.png" alt="20170216148725924055197.png"></p>
<p>这个效果比较容易理解，两个图像重合的区域才会有颜色值变化，所以只有重合区域才有变亮的效果，源图像非重合的区域，由于对应区域的目标图像是空白像素，所以直接显示源图像。 </p>
<p>我们在实际应用中，会有下面的这个情况，当选中一本书时，给这本书加上灯光效果</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725927596970.png" alt="20170216148725927596970.png"></p>
<p>其实它是两张图合成的：<br>DST:目标图像</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021614872593145776.png" alt="2017021614872593145776.png"></p>
<p>SRC:源图像</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725933137432.png" alt="20170216148725933137432.png"></p>
<p>可以看到，在这张图片的最上方中间的位置有些白色半透明的填充，其它位置都是透明的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightBookView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mBitPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpDST,BmpSRC;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightBookView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mBitPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.book_bg,<span class="keyword">null</span>);  </div><div class="line">        BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.book_light,<span class="keyword">null</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">        <span class="comment">//先画书架，做为目标图像  </span></div><div class="line">        canvas.drawBitmap(BmpDST,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.LIGHTEN));  </div><div class="line">        <span class="comment">//再图光点  </span></div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>意思就是先把书架做为目标图像画在底层，然后给mBitPaint设置上PorterDuffXfermode，然后将处理过的源图盖在目标图像上。代码难度不大，就不再细讲。</p>
<h5 id="3、Mode-DARKEN（变暗）"><a href="#3、Mode-DARKEN（变暗）" class="headerlink" title="3、Mode.DARKEN（变暗）"></a>3、Mode.DARKEN（变暗）</h5><p>对应公式是： [Sa + Da - Sa <em> Da,Sc </em> (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)]<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725941021078.png" alt="20170216148725941021078.png"><br>同样是对应photoshop中的混合模式中的变暗模式</p>
<h5 id="4、Mode-MULTIPLY-正片叠底"><a href="#4、Mode-MULTIPLY-正片叠底" class="headerlink" title="4、Mode.MULTIPLY(正片叠底)"></a>4、Mode.MULTIPLY(正片叠底)</h5><p>公式是：[Sa <em> Da, Sc </em> Dc] </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725944050154.png" alt="20170216148725944050154.png"></p>
<p>有些同学会奇怪了，Photoshop中也有正片叠底啊，相交区域正片叠底后的颜色确实是绿色的，但源图像的非相交区域怎么没了？<br>我们来看下他的计算公式：[Sa <em> Da, Sc </em> Dc]，在计算alpha值时的公式是Sa * Da，是用源图像的alpha值乘以目标图像的alpha值；由于源图像的非相交区域所对应的目标图像像素的alpha是0，所以结果像素的alpha值仍是0，所以源图像的非相交区域在计算后是透明的。<br>在两个图像的相交区域的混合方式是与photoshop中的正片叠底效果是一致的。</p>
<h5 id="5、Mode-OVERLAY（叠加）"><a href="#5、Mode-OVERLAY（叠加）" class="headerlink" title="5、Mode.OVERLAY（叠加）"></a>5、Mode.OVERLAY（叠加）</h5><p>这个没有给出公式…… </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725950442016.png" alt="20170216148725950442016.png"></p>
<p>虽然没有给出公式，但从效果图中可以看到，源图像交合部分有效果，非交合部分依然是存在的，这就可以肯定一点，当目标图像透明时，在这个模式下源图像的色值不会受到影响；</p>
<h5 id="6、Mode-SCREEN（滤色）"><a href="#6、Mode-SCREEN（滤色）" class="headerlink" title="6、Mode.SCREEN（滤色）"></a>6、Mode.SCREEN（滤色）</h5><p>对应公式是：[Sa + Da - Sa <em> Da, Sc + Dc - Sc </em> Dc] </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725954269013.png" alt="20170216148725954269013.png"></p>
<p>同样，只是源图像与目标图像交合部分有效果，源图像非交合部分保持原样。</p>
<p><strong>总结</strong></p>
<ul>
<li>这几种模式都是PhotoShop中存在的模式，是通过计算改变交合区域的颜色值的 </li>
<li>除了Mode.MULTIPLY(正片叠底)会在目标图像透明时将结果对应区域置为透明，其它图像都不受目标图像透明像素影响，即源图像非交合部分保持原样。</li>
</ul>
<h5 id="7、示例——twitter标识的描边效果"><a href="#7、示例——twitter标识的描边效果" class="headerlink" title="7、示例——twitter标识的描边效果"></a>7、示例——twitter标识的描边效果</h5><p>由于这些模式在photoshop中都存在，直接拿目标图像和源图像在photoshop中就可以演示出来，就没有多举例子，其实，在实现时实现两图像混合时，也经常会用到这些模式的，比如这里twitter的暗光效果。<br>图一：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725964213294.png" alt="20170216148725964213294.png"><br>图二：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725967524708.png" alt="20170216148725967524708.png"><br>然后完成的效果如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021614872596928121.png" alt="2017021614872596928121.png"></p>
<p>我们先想想这个要实现的效果有哪些特性：<br>首先，<br>在图一中，小鸟整个都是蓝色的<br>在图二中，只有小鸟的边缘部分是白色的，中间部分是透明的。<br>在最终的合成图中：图一和图二中小鸟与边缘的是显示的，而且还有某种效果，但小鸟中间的区域变透明了！显示的是底部Activity的背景色。<br>想到我们前面学到的几种样式中，只有Mode.MULTIPLY(正片叠底)会在两个图像的一方透明时，结果像素就是透明的。所以这里使用的模式就是Mode.MULTIPLY</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwitterView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mBitPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpDST,BmpSRC;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwitterView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mBitPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_bg,<span class="keyword">null</span>);  </div><div class="line">        BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_light,<span class="keyword">null</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(BmpDST,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));  </div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="二、SRC相关模式"><a href="#二、SRC相关模式" class="headerlink" title="二、SRC相关模式"></a>二、SRC相关模式</h4><p>在讲完了photoshop中存在的几个模式以后，还有几个是在处理结果时以源图像显示为主的几个模式，所以大家在遇到当图像相交时，需要显示源图像时，就需要从这几个模式中考虑了<br>这部分所涉及的模式有：<strong>Mode.SRC、Mode.SRC_IN、Mode.SRC_OUT、Mode.SRC_OVER、Mode.SRC_ATOP</strong></p>
<h5 id="1、Mode-SRC"><a href="#1、Mode-SRC" class="headerlink" title="1、Mode.SRC"></a>1、Mode.SRC</h5><p>计算公式为：[Sa, Sc]<br>从公式中也可以看出，在处理源图像所在区域的相交问题时，全部以源图像显示 </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148725990714554.png" alt="20170216148725990714554.png"></p>
<h5 id="2、Mode-SRC-IN"><a href="#2、Mode-SRC-IN" class="headerlink" title="2、Mode.SRC_IN"></a>2、Mode.SRC_IN</h5><p>计算公式为：[Sa <em> Da, Sc </em> Da]<br>在这个公式中结果值的透明度和颜色值都是由Sa,Sc分别乘以目标图像的Da来计算的。所以当目标图像为空白像素时，计算结果也将会为空白像素。 </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021614872599356866.png" alt="2017021614872599356866.png"></p>
<p>大家注意SRC_IN模式与SRC模式的区别，一般而言，是在相交区域时无论SRC_IN还是SRC模式都是显示源图像，而唯一不同的是，当目标图像是空白像素时，在SRC_IN所对应的区域也将会变成空白像素；<br>其实更严格的来讲，SRC_IN模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。当目标图像透明度为0时，源图像就完全不显示。 </p>
<p><strong>示例1：图形圆角</strong></p>
<p>图像一：（我们熟悉的小狗 ）</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726007529092.png" alt="20170216148726007529092.png"></p>
<p>图像二：（去角遮罩）</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726009269370.png" alt="20170216148726009269370.png"></p>
<p>效果为：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726010521981.png" alt="20170216148726010521981.png"></p>
<p>可以看到这个遮罩的四个角都是圆形切角，都是透明的。<br>现在我们需要利用SRC_IN的特性，显示SRC图像，但会把目标图像中空白像素的部分去掉的特性来做了。<br>由于我们需要最终显示小狗图像，所以这里需要将小狗 图像做为SRC，将遮罩做为目标图像 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundImageView_SRCIN</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mBitPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpDST,BmpSRC;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoundImageView_SRCIN</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mBitPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_shade,<span class="keyword">null</span>);  </div><div class="line">        BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,<span class="keyword">null</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(BmpDST,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));  </div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>示例2：图片倒影</strong><br>前面我们讲过，SRC_IN模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。所以当目标图像的透明度在0-255之间时，就会把源图像的透明度和颜色值都会变小。利用这个特性，我们可以做出倒影效果</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726017845506.png" alt="20170216148726017845506.png"></p>
<p>用到的遮罩为：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726020137845.png" alt="20170216148726020137845.png"></p>
<p>这个遮罩好像还不太清，它是一个从上到下的白色填充渐变；白色的透明度从49%到0； </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvertedImageView_SRCIN</span>  <span class="keyword">extends</span> <span class="title">View</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mBitPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpDST,BmpSRC,BmpRevert;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvertedImageView_SRCIN</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mBitPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_invert_shade,<span class="keyword">null</span>);  </div><div class="line">        BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,<span class="keyword">null</span>);  </div><div class="line">  </div><div class="line">        Matrix matrix = <span class="keyword">new</span> Matrix();  </div><div class="line">        matrix.setScale(<span class="number">1F</span>, -<span class="number">1F</span>);  </div><div class="line">        <span class="comment">// 生成倒影图  </span></div><div class="line">        BmpRevert = Bitmap.createBitmap(BmpSRC, <span class="number">0</span>, <span class="number">0</span>, BmpSRC.getWidth(), BmpSRC.getHeight(), matrix, <span class="keyword">true</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="comment">//先画出小狗图片  </span></div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        <span class="comment">//再画出倒影  </span></div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.translate(<span class="number">0</span>,BmpSRC.getHeight());  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(BmpDST,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));  </div><div class="line">        canvas.drawBitmap(BmpRevert,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、Mode-SRC-OUT"><a href="#3、Mode-SRC-OUT" class="headerlink" title="3、Mode.SRC_OUT"></a>3、Mode.SRC_OUT</h5><p>计算公式为：[Sa <em> (1 - Da), Sc </em> (1 - Da)]<br>从公式中可以看出，计算结果的透明度=Sa * (1 - Da)；也就是说当目标图像图像完全透明时，计算结果将是透明的；</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726027337083.png" alt="20170216148726027337083.png"></p>
<p>从示例图中也可以看出，源图像与目标图像的相交部分由于目标图像的透明度为100%，所以相交部分的计算结果为空白像素。在目标图像为空白像素时，完全以源图像显示。<br>所以这个模式的特性可以概括为：以目标图像的透明度的补值来调节源图像的透明度和色彩饱和度。即当目标图像为空白像素时，就完全显示源图像，当目标图像的透明度为100%时，交合区域为空像素。<br><strong>Mode.SRC_OUT简单来说，当目标图像有图像时结果显示空白像素，当目标图像没有图像时，结果显示源图像。</strong></p>
<p><strong>1、橡皮擦效果</strong><br>利用这个特性，我们可以实现橡皮擦效果<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702165051220160430100622197.gif" alt="201702165051220160430100622197.gif"></p>
<p>原理：我们说了简单来讲Mode.SRC_OUT模式，当目标图像有图像时计算结果为空白像素，当目标图像没有图像时，显示源图像；<br>所以我们把手指轨迹做为目标图像，在与源图像计算时，有手指轨迹的地方就变为空白像素了，看起来的效果就是被擦除了。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogView_SRCOUT</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mBitPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpDST,BmpSRC;  </div><div class="line">    <span class="keyword">private</span> Path mPath;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mPreX,mPreY;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DogView_SRCOUT</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mBitPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mBitPaint.setColor(Color.RED);  </div><div class="line">        mBitPaint.setStyle(Paint.Style.STROKE);  </div><div class="line">        mBitPaint.setStrokeWidth(<span class="number">45</span>);  </div><div class="line">  </div><div class="line">        BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,<span class="keyword">null</span>);  </div><div class="line">        BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888);  </div><div class="line">        mPath = <span class="keyword">new</span> Path();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">  </div><div class="line">        <span class="comment">//先把手指轨迹画到目标Bitmap上  </span></div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(BmpDST);  </div><div class="line">        c.drawPath(mPath,mBitPaint);  </div><div class="line">  </div><div class="line">        <span class="comment">//然后把目标图像画到画布上  </span></div><div class="line">        canvas.drawBitmap(BmpDST,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        <span class="comment">//计算源图像区域  </span></div><div class="line">        mBitPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));  </div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </div><div class="line">        <span class="keyword">switch</span> (event.getAction())&#123;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:  </div><div class="line">                mPath.moveTo(event.getX(),event.getY());  </div><div class="line">                mPreX = event.getX();  </div><div class="line">                mPreY = event.getY();  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:  </div><div class="line">                <span class="keyword">float</span> endX = (mPreX+event.getX())/<span class="number">2</span>;  </div><div class="line">                <span class="keyword">float</span> endY = (mPreY+event.getY())/<span class="number">2</span>;  </div><div class="line">                mPath.quadTo(mPreX,mPreY,endX,endY);  </div><div class="line">                mPreX = event.getX();  </div><div class="line">                mPreY =event.getY();  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">        postInvalidate();  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2、刮刮卡效果</strong><br>首先，搞一个刮刮卡图片：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726057113047.png" alt="20170216148726057113047.png"><br>然后再搞个中奖结果：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726060436922.png" alt="20170216148726060436922.png"><br>结果如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702168245720160430100858813.gif" alt="201702168245720160430100858813.gif"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuaGuaCardView_SRCOUT</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mBitPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpDST,BmpSRC,BmpText;  </div><div class="line">    <span class="keyword">private</span> Path mPath;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mPreX,mPreY;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GuaGuaCardView_SRCOUT</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mBitPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mBitPaint.setColor(Color.RED);  </div><div class="line">        mBitPaint.setStyle(Paint.Style.STROKE);  </div><div class="line">        mBitPaint.setStrokeWidth(<span class="number">45</span>);  </div><div class="line">  </div><div class="line">        BmpText = BitmapFactory.decodeResource(getResources(),R.drawable.guaguaka_text,<span class="keyword">null</span>);  </div><div class="line">        BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.guaguaka_pic,<span class="keyword">null</span>);  </div><div class="line">        BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888);  </div><div class="line">        mPath = <span class="keyword">new</span> Path();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(BmpText,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">  </div><div class="line">        <span class="comment">//先把手指轨迹画到目标Bitmap上  </span></div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(BmpDST);  </div><div class="line">        c.drawPath(mPath,mBitPaint);  </div><div class="line">  </div><div class="line">        <span class="comment">//然后把目标图像画到画布上  </span></div><div class="line">        canvas.drawBitmap(BmpDST,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        <span class="comment">//计算源图像区域  </span></div><div class="line">        mBitPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_OUT));  </div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mBitPaint);  </div><div class="line">  </div><div class="line">        mBitPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;  </div><div class="line">        <span class="keyword">switch</span> (event.getAction())&#123;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:  </div><div class="line">                mPath.moveTo(event.getX(),event.getY());  </div><div class="line">                mPreX = event.getX();  </div><div class="line">                mPreY = event.getY();  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:  </div><div class="line">                <span class="keyword">float</span> endX = (mPreX+event.getX())/<span class="number">2</span>;  </div><div class="line">                <span class="keyword">float</span> endY = (mPreY+event.getY())/<span class="number">2</span>;  </div><div class="line">                mPath.quadTo(mPreX,mPreY,endX,endY);  </div><div class="line">                mPreX = event.getX();  </div><div class="line">                mPreY =event.getY();  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">        postInvalidate();  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与上面橡皮擦效果不同的是，在绘图时，在特效前先把刮刮卡的中奖文字绘在底部，这时候当橡皮擦把刮刮卡的图片给擦除掉时，就露出底部的刮刮卡的中奖文字了。</p>
<h5 id="4、Mode-SRC-OVER"><a href="#4、Mode-SRC-OVER" class="headerlink" title="4、Mode.SRC_OVER"></a>4、Mode.SRC_OVER</h5><p>计算公式为：[Sa + (1 - Sa) <em> Da, Rc = Sc + (1 - Sa) </em> Dc]<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726073090392.png" alt="20170216148726073090392.png"><br>我们可以看到，在计算结果中，源图像没有变。它的意思就是在目标图像的顶部绘制源图像。从公式中也可以看出目标图像的透明度为Sa + (1 - Sa)*Da；即在源图像的透明度基础上增加一部分目标图像的透明度。增加的透明度是源图像透明度的补量；目标图像的色彩值的计算方式同理，所以当源图像透明度为100%时，就原样显示源图像；</p>
<h5 id="5、Mode-SRC-ATOP"><a href="#5、Mode-SRC-ATOP" class="headerlink" title="5、Mode.SRC_ATOP"></a>5、Mode.SRC_ATOP</h5><p>计算公式为：[Da, Sc <em> Da + (1 - Sa) </em> Dc]<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726077549074.png" alt="20170216148726077549074.png"><br>很奇怪，它的效果图竟然与SRC_IN模式是相同的，我们来对比一下它们的公式：<br>SRC_IN: [Sa <em> Da, Sc </em> Da]<br>SRC_ATOP:[Da, Sc <em> Da + (1 - Sa) </em> Dc]<br>先看透明度：在SRC_IN中是Sa <em> Da,在SRC_ATOP是Da<br>SRC_IN是源图像透明度乘以目标图像的透明度做为结果透明度，而SRC_ATOP是直接使用目标图像的透明度做为结果透明度<br>再看颜色值：<br>SRC_IN的颜色值为 Sc </em> Da，SRC_ATOP的颜色值为Sc <em> Da + (1 - Sa) </em> Dc；SRC_ATOP在SRC_IN的基础上还增加了(1 - Sa) * Dc； </p>
<p><strong>总结</strong></p>
<ul>
<li>当透明度只有100%和0%时，SRC_ATOP是SRC_IN是通用的 </li>
<li>当透明度不只有100%和0%时，SRC_ATOP相比SRC_IN源图像的饱和度会增加，即会显得更亮！</li>
</ul>
<p>所以，前面利用SRC_IN实现的圆角效果是完全可以使用SRC_ATOP模式来实现的。</p>
<p><strong>1、圆角效果（当透明度只有100%和0%时，SRC_ATOP是SRC_IN是通用的）</strong></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726010521981.png" alt="20170216148726010521981.png"></p>
<p>代码中仅将SRC_IN模式改为SRC_ATOP模式即可</p>
<p><strong>示例2：图片倒影(颜色饱和度增加)</strong><br>前面我们讲过，当目标图像的透明度不是100%和0%时，源图像的颜色值就会比SRC_IN模式的颜色值饱和度增加。<br>我们来对比下效果：<br>同样只需要在将原图片倒影代码的SRC_IN模式改成SRC_ATOP即可</p>
<p>效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148726098181631.png" alt="20170217148726098181631.png"><br>然后再来看看原来SRC_IN的效果图，对比一下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170216148726017845506.png" alt="20170216148726017845506.png"></p>
<p>明显亮度是有增加的。<br>所以对于SRC_ATOP的结论就出来了，一般而言SRC_ATOP是可以和SRC_IN通用的，但SRC_ATOP所产生的效果图在目标图不是透明度不是0或100%的时候，会比SRC_IN模式产生的图像更亮些；</p>
<h3 id="七、Paint之setXfermode-三"><a href="#七、Paint之setXfermode-三" class="headerlink" title="七、Paint之setXfermode(三)"></a>七、Paint之setXfermode(三)</h3><h4 id="一、DST相关模式"><a href="#一、DST相关模式" class="headerlink" title="一、DST相关模式"></a>一、DST相关模式</h4><p>在讲完了SRC相关的模式以后，我们知道SRC相关的模式，都是在相交区域优先显示源图像为主。<br>与之相对应的有DST相关的模式，在DST相关的模式中，在处理相交区域时，优先以目标图像显示为主。<br>这部分所涉及的模式有：Mode.DST、Mode.DST_IN、Mode.DST_OUT、Mode.DST_OVER、Mode.DST_ATOP</p>
<h5 id="1、Mode-DST"><a href="#1、Mode-DST" class="headerlink" title="1、Mode.DST"></a>1、Mode.DST</h5><p>计算公式为：[Da, Dc]<br>从公式中也可以看出，在处理源图像所在区域的相交问题时，正好与Mode.SRC相反，全部以目标图像显示<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021714872611498488.png" alt="2017021714872611498488.png"></p>
<h5 id="2、Mode-DST-IN"><a href="#2、Mode-DST-IN" class="headerlink" title="2、Mode.DST_IN"></a>2、Mode.DST_IN</h5><p>计算公式为：[Da <em> Sa,Dc </em> Sa]<br>我们与Mode.SRC_IN的公式对比一下：SRC_IN:[Sa <em> Da, Sc </em> Da]<br>正好与SRC_IN相反，Mode.DST_IN是在相交时利用源图像的透明度来改变目标图像的透明度和饱和度。当源图像透明度为0时，目标图像就完全不显示。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021714872611498488.png" alt="2017021714872611498488.png"><br>由于Mode.DST_IN的模式与SRC_IN正好是相反，所以我们利用Mode.SRC_IN实现的示例，只需要将源图像与目标图像对调就可以使用Mode.DST_IN来实现了。 </p>
<p><strong>示例1、区域波纹</strong><br>之前讲解了水波纹效果，但这个水波纹效果却只能是一固定在一个矩形区域，本例我们就利用xfermode来实现在不规则区域中显示水波纹效果，效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702178936520160430214851903.gif" alt="201702178936520160430214851903.gif"></p>
<p>这里使用到一张图片</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729385240790.png" alt="20170217148729385240790.png"></p>
<p>在这张图片中，只有文字部分是纯白色的，其它区域都是透明像素。<br>所以再加上我们需要自己绘制的水波纹效果的图片，这里就有两张图片了，一张是水波纹效果图，另一张是text_shade.png<br>那么问题来了，如果我们使用Mode.DST_IN模式的话，谁当目标图像，谁当源图像呢？<br>这就需要分析Mode.DST_IN模式的成像原理了，在Mode.DST_IN中，源图像所占区域计算结果图像时，相交区域显示的是DST目标图像；<br>所以我们要最终显示的被裁剪后的波纹图，所以DST目标图像就应该是波纹图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleWave_DSTIN</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Path mPath;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mItemWaveLength = <span class="number">1000</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dx;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpSRC,BmpDST;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleWave_DSTIN</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPath = <span class="keyword">new</span> Path();  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">        mPaint.setStyle(Paint.Style.FILL_AND_STROKE);  </div><div class="line">  </div><div class="line">        BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.text_shade,<span class="keyword">null</span>);  </div><div class="line">        BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888);  </div><div class="line">  </div><div class="line">        startAnim();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        generageWavePath();  </div><div class="line">  </div><div class="line">        <span class="comment">//先清空bitmap上的图像,然后再画上Path  </span></div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(BmpDST);  </div><div class="line">        c.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR);  </div><div class="line">        c.drawPath(mPath,mPaint);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.drawBitmap(BmpDST,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.DST_IN));  </div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 生成此时的Path </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generageWavePath</span><span class="params">()</span></span>&#123;  </div><div class="line">        mPath.reset();  </div><div class="line">        <span class="keyword">int</span> originY = BmpSRC.getHeight()/<span class="number">2</span>;  </div><div class="line">        <span class="keyword">int</span> halfWaveLen = mItemWaveLength/<span class="number">2</span>;  </div><div class="line">        mPath.moveTo(-mItemWaveLength+dx,originY);  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -mItemWaveLength;i&lt;=getWidth()+mItemWaveLength;i+=mItemWaveLength)&#123;  </div><div class="line">            mPath.rQuadTo(halfWaveLen/<span class="number">2</span>,-<span class="number">50</span>,halfWaveLen,<span class="number">0</span>);  </div><div class="line">            mPath.rQuadTo(halfWaveLen/<span class="number">2</span>,<span class="number">50</span>,halfWaveLen,<span class="number">0</span>);  </div><div class="line">        &#125;  </div><div class="line">        mPath.lineTo(BmpSRC.getWidth(),BmpSRC.getHeight());  </div><div class="line">        mPath.lineTo(<span class="number">0</span>,BmpSRC.getHeight());  </div><div class="line">        mPath.close();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnim</span><span class="params">()</span></span>&#123;  </div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,mItemWaveLength);  </div><div class="line">        animator.setDuration(<span class="number">2000</span>);  </div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);  </div><div class="line">        animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());  </div><div class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;  </div><div class="line">                dx = (<span class="keyword">int</span>)animation.getAnimatedValue();  </div><div class="line">                postInvalidate();  </div><div class="line">            &#125;  </div><div class="line">        &#125;);  </div><div class="line">        animator.start();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>2、心电图</strong></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702177244220160430221534260.gif" alt="201702177244220160430221534260.gif"></p>
<p>很明显，正规的心电图应该是利用Path把当前的实时的点连接起来，我这里只是一张图片(hearmap.png)通过使用动画来实现的</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729574750396.png" alt="20170217148729574750396.png"></p>
<p>中间是一条心电图线，其余位置都是透明像素；大家先想想我们要怎么利用这张图片实现上面的动画呢？<br>利用Mode.DST_IN模式，由于在这个模式中，相交区域优先显示目标图像，所以我们这里需要显示心电图，所以心电图就是目标图像。<br>那么问题来了，源图像是啥？<br>由于我们需要从右向左逐渐显示心电图图像，所以我们源图像就是自建的空白图像，在这个图像中，绘制一个矩形，逐渐增大矩形的区域，即相交区域也会跟着增大，由于相交区域会显示出目标图像，显示出来的结果就是心电图的动画</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartMap</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mItemWaveLength = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dx=<span class="number">0</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpSRC,BmpDST;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeartMap</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">  </div><div class="line">        BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.heartmap,<span class="keyword">null</span>);  </div><div class="line">        BmpSRC = Bitmap.createBitmap(BmpDST.getWidth(), BmpDST.getHeight(), Bitmap.Config.ARGB_8888);  </div><div class="line">  </div><div class="line">        mItemWaveLength = BmpDST.getWidth();  </div><div class="line">        startAnim();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(BmpSRC);  </div><div class="line">        <span class="comment">//清空bitmap  </span></div><div class="line">        c.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR);  </div><div class="line">        <span class="comment">//画上矩形  </span></div><div class="line">        c.drawRect(BmpDST.getWidth() - dx,<span class="number">0</span>,BmpDST.getWidth(),BmpDST.getHeight(),mPaint);  </div><div class="line">  </div><div class="line">        <span class="comment">//模式合成  </span></div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.drawBitmap(BmpDST,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.DST_IN));  </div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnim</span><span class="params">()</span></span>&#123;  </div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,mItemWaveLength);  </div><div class="line">        animator.setDuration(<span class="number">6000</span>);  </div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);  </div><div class="line">        animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());  </div><div class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;  </div><div class="line">                dx = (<span class="keyword">int</span>)animation.getAnimatedValue();  </div><div class="line">                postInvalidate();  </div><div class="line">            &#125;  </div><div class="line">        &#125;);  </div><div class="line">        animator.start();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>3、不规则波纹</strong></p>
<p>上面我们实现的波纹效果都是规则的，如果我们想实现如下图这样的不规则波纹要怎么办呢？</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702171540320160430221825171.gif" alt="201702171540320160430221825171.gif"></p>
<p>在这里我们需要用到两张图：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729679339717.png" alt="20170217148729679339717.png"></p>
<p>一张不规则的波浪图</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729680591875.png" alt="20170217148729680591875.png"></p>
<p>想必到这里，可能很多同学都知道要怎么做了<br>就是在圆形遮罩上绘制不断移动的不规则的波浪图。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IrregularWaveView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mItemWaveLength = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dx=<span class="number">0</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">private</span> Bitmap BmpSRC,BmpDST;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IrregularWaveView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">        BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.wave_bg,<span class="keyword">null</span>);  </div><div class="line">        BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.circle_shape,<span class="keyword">null</span>);  </div><div class="line">        mItemWaveLength = BmpDST.getWidth();  </div><div class="line">  </div><div class="line">        startAnim();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="comment">//先画上圆形  </span></div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">        <span class="comment">//再画上结果  </span></div><div class="line">        <span class="keyword">int</span> layerId = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="keyword">null</span>, Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.drawBitmap(BmpDST,<span class="keyword">new</span> Rect(dx,<span class="number">0</span>,dx+BmpSRC.getWidth(),BmpSRC.getHeight()),<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,BmpSRC.getWidth(),BmpSRC.getHeight()),mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.DST_IN));  </div><div class="line">        canvas.drawBitmap(BmpSRC,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerId);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAnim</span><span class="params">()</span></span>&#123;  </div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,mItemWaveLength);  </div><div class="line">        animator.setDuration(<span class="number">4000</span>);  </div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);  </div><div class="line">        animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());  </div><div class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;  </div><div class="line">            <span class="meta">@Override</span>  </div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;  </div><div class="line">                dx = (<span class="keyword">int</span>)animation.getAnimatedValue();  </div><div class="line">                postInvalidate();  </div><div class="line">            &#125;  </div><div class="line">        &#125;);  </div><div class="line">        animator.start();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、Mode-DST-OUT"><a href="#3、Mode-DST-OUT" class="headerlink" title="3、Mode.DST_OUT"></a>3、Mode.DST_OUT</h5><p>计算公式为：[Da <em> (1 - Sa), Dc </em> (1 - Sa)] </p>
<p>同样，我们拿这个公式与Mode.SRC_OUT对比一下，Mode.SRC_OUT：[Sa <em> (1 - Da), Sc </em> (1 - Da)]<br>可以看出Mode.SRC_OUT是利用目标图像的透明度的补值来改变源图像的透明度和饱和度。而Mode.DST_OUT反过来，是通过源图像的透明度补值来改变目标图像的透明度和饱和度。<br>简单来说，在Mode.DST_OUT模式下，就是相交区域显示的是目标图像，目标图像的透明度和饱和度与源图像的透明度相反，当源图像透明底是100%时，则相交区域为空值。当源图像透明度为0时，则完全显示目标图像。非相交区域完全显示目标图像。 </p>
<p>示例图像为：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729696823160.png" alt="20170217148729696823160.png"></p>
<p>有些同学对这个结果可能感觉很奇怪，我们来分析一下，上篇中我们提到在xfermode的示例图像中，我们主要需要关注两点：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729698370116.png" alt="20170217148729698370116.png"></p>
<p>图中编号1的相交区域：在DST_OUT模式下，由于源图像的透明度是100%，所以计算后的结果图像在这个区域是空像素。<br>图中编号2的非相交区域：在DST_OUT模式下，这个区域的源图像透明度仍为100%，所以计算后的结果图像在这个区域仍是空像素。<br>所以我们做下简单的总结，当源图像区域透明度为100%时，所在区域计算结果为透明像素，当源图像的区域透明时，计算结果就是目标图像；<br>这与SRC_OUT模式的结果正好相反，在SRC_OUT模式下，当目标图像区域透明度为100%时，所在区域计算结果为透明像素，当目标图像的区域透明时，计算结果就是源图像；<br>所以，在上篇中，使用SRC_OUT模式实现的橡皮擦效果和刮刮卡效果都是可以使用DST_OUT模式实现的，只需要将SRC和DST所对应的图像翻转一下就可以了；<br>这里就不再实现了，大家自己来试试吧。</p>
<h5 id="4、Mode-DST-OVER"><a href="#4、Mode-DST-OVER" class="headerlink" title="4、Mode.DST_OVER"></a>4、Mode.DST_OVER</h5><p><strong>计算公式为：[Sa + (1 - Sa) <em> Da, Rc = Dc + (1 - Da) </em> Sc]</strong><br>同样先写Mode.SRC_OVER对比一下，SRC_OVER：[Sa + (1 - Sa) <em> Da, Rc = Sc + (1 - Sa) </em> Dc]<br>所以它们的效果就是在SRC模式中以显示SRC图像为主变成了以显示DST图像为主。从SRC模式中的使用目标图像控制结果图像的透明度和饱和度变成了由源图像控件结果图像的透明度和饱和度。<br>示例图像为：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729713216159.png" alt="20170217148729713216159.png"></p>
<h5 id="5、Mode-DST-ATOP"><a href="#5、Mode-DST-ATOP" class="headerlink" title="5、Mode.DST_ATOP"></a>5、Mode.DST_ATOP</h5><p><strong>计算公式为：[Sa, Sa <em> Dc + Sc </em> (1 - Da)]</strong><br>示例图像为：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729716676751.png" alt="20170217148729716676751.png"></p>
<p>由于在SRC中，我们知道了Mode.SRC_ATOP与MODE.SRC_IN的区别：<br>一般而言SRC_ATOP是可以和SRC_IN通用的，但SRC_ATOP所产生的效果图在目标图的透明度不是0或100%的时候，会比SRC_IN模式产生的图像更亮些；<br>我们再来对比下DST中的两个模式与SRC中的这两个模式中公式中区别：<br>SRC_IN: [Sa <em> Da, Sc </em> Da]<br>SRC_ATOP:[Da, Sc <em> Da + (1 - Sa) </em> Dc]<br>DST_IN:[Da <em> Sa , Dc </em> Sa ]<br>DST_ATOP:[Sa, Sa <em> Dc + Sc </em> (1 - Da)]<br>从公式中可以看到，在SRC模式中，以显示源图像为主，透明度和饱和度利用Da来调节<br>而在DST模式中，以显示目标图像为主，透明度和饱和度利用Sa来调节   </p>
<p>所以Mode.DST_ATOP与Mode.DST_IN的关系也是：<br>一般而言DST_ATOP是可以和DST_IN通用的，但DST_ATOP所产生的效果图在源图像的透明度不是0或100%的时候，会比DST_IN模式产生的图像更亮些；<br>同样，大家也可以使用Mode.DST_ATOP实现上篇文章中Mode.SRC_ATOP的两个示例：圆角效果和图片倒影，这里就不再讲了</p>
<p><strong>总结</strong></p>
<ul>
<li>DST相关模式是完全可以使用SRC对应的模式来实现的，只不过需要将目标图像和源图像对调一下即可。 </li>
<li>在SRC模式中，是以显示源图像为主，通过目标图像的透明度来调节计算结果的透明度和饱和度，而在DST模式中，是以显示目标图像为主，通过源图像的透明度来调节计算结果的透明度和饱和度。</li>
</ul>
<h4 id="二、其它模式"><a href="#二、其它模式" class="headerlink" title="二、其它模式"></a>二、其它模式</h4><p>除了颜色叠加系列模式，SRC系列模式和DST系列模式以外，另外还有两个模式Mode.CLEAR和Mode.XOR,下面我们就来看看它们的用法</p>
<h5 id="1、Mode-CLEAR"><a href="#1、Mode-CLEAR" class="headerlink" title="1、Mode.CLEAR"></a>1、Mode.CLEAR</h5><p>计算公式：[0, 0] </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729729368754.png" alt="20170217148729729368754.png"></p>
<p>前面我们做清空图像的时候用过这个方法，从公式中可以看到，计算结果直接就是[0,0]即空像素。也就是说，源图像所在区域都会变成空像素！<br>这样就起到了清空源图像所在区域图像的功能了。上面示例中已经存在这个Mode的用法，这里就不再举例了。</p>
<h5 id="2、Mode-XOR"><a href="#2、Mode-XOR" class="headerlink" title="2、Mode.XOR"></a>2、Mode.XOR</h5><p><strong>计算公式为：[Sa + Da - Sa <em> Da,Sc </em> (1 - Da) + Dc * (1 - Sa) + min(Sc, Dc)]</strong></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148729735226243.png" alt="20170217148729735226243.png"></p>
<p>单从示例图像中，好像是异或的功能，即将源图像中除了相交区域以外的部分做为结果。但仔细看看公式，其实并没有这么简单。<br>首先看公式中透明度部分：Sa + Da - Sa <em> Da，就是将目标图像和源图像的透明度相加，然后减去它们的乘积，所以计算结果的透明度会增大（即比目标图像和源图像都大，当其中一个图像的透明度为1时，那结果图像的透明度肯定是1）<br>然后再看颜色值部分：Sc </em> (1 - Da) + Dc * (1 - Sa) + min(Sc, Dc)；表示源图像和目标图像分别以自己的透明度的补值乘以对方的颜色值，然后相加得到结果。最后再加上Sc, Dc中的最小值。 </p>
<p>在实际应用中，我们可以从下面三个方面来决定使用哪一个模式：</p>
<ul>
<li>首先，目标图像和源图像混合，需不需要生成颜色的叠加特效，如果需要叠加特效则从颜色叠加相关模式中选择，有Mode.ADD（饱和度相加）、Mode.DARKEN（变暗），Mode.LIGHTEN（变亮）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加），Mode.SCREEN（滤色） </li>
<li>当不需要特效，而需要根据某一张图像的透明像素来裁剪时，就需要使用SRC相关模式或DST相关模式了。由于SRC相关模式与DST相关模式是相通的，唯一不同的是决定当前哪个是目标图像和源图像； </li>
<li>当需要清空图像时，使用Mode.CLEAR</li>
</ul>
<h2 id="四、Canvas"><a href="#四、Canvas" class="headerlink" title="四、Canvas"></a>四、Canvas</h2><h3 id="八、Canvas与图层-一"><a href="#八、Canvas与图层-一" class="headerlink" title="八、Canvas与图层(一)"></a>八、Canvas与图层(一)</h3><h4 id="一、如何获得一个Canvas对象"><a href="#一、如何获得一个Canvas对象" class="headerlink" title="一、如何获得一个Canvas对象"></a>一、如何获得一个Canvas对象</h4><h5 id="方法一：自定义view时，-重写onDraw、dispatchDraw方法"><a href="#方法一：自定义view时，-重写onDraw、dispatchDraw方法" class="headerlink" title="方法一：自定义view时， 重写onDraw、dispatchDraw方法"></a>方法一：自定义view时， 重写onDraw、dispatchDraw方法</h5><h6 id="（1）、定义"><a href="#（1）、定义" class="headerlink" title="（1）、定义"></a>（1）、定义</h6><p>我们先来看一下onDraw、dispatchDraw方法的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到onDraw、dispatchDraw在传入的参数中都有一个canvas对象。这个canvas对象是View中的Canvas对象，利用这个canvas对象绘图，效果会直接反应在View中； </p>
<h6 id="（2）、onDraw、dispatchDraw区别"><a href="#（2）、onDraw、dispatchDraw区别" class="headerlink" title="（2）、onDraw、dispatchDraw区别"></a>（2）、onDraw、dispatchDraw区别</h6><ul>
<li>onDraw()的意思是绘制视图自身</li>
<li>dispatchDraw()是绘制子视图</li>
</ul>
<p>无论是View还是ViewGroup对它们俩的调用顺序都是onDraw()-&gt;dispatchDraw()<br>但在ViewGroup中，当它有背景的时候就会调用onDraw()方法，否则就会跳过onDraw()直接调用dispatchDraw()；所以如果要在ViewGroup中绘图时，往往是重写dispatchDraw()方法<br>在View中，onDraw()和dispatchDraw()都会被调用的，所以我们无论把绘图代码放在onDraw()或者dispatchDraw()中都是可以得到效果的，但是由于dispatchDraw()的含义是绘制子控件，所以原则来上讲，在绘制View控件时，我们是重新onDraw()函数。</p>
<p><strong>总结</strong><br>在绘制View控件时，需要重写onDraw()函数，在绘制ViewGroup时，需要重写dispatchDraw()函数。</p>
<h5 id="方法二：使用Bitmap创建"><a href="#方法二：使用Bitmap创建" class="headerlink" title="方法二：使用Bitmap创建"></a>方法二：使用Bitmap创建</h5><h6 id="1、构建方法"><a href="#1、构建方法" class="headerlink" title="1、构建方法"></a>1、构建方法</h6><pre><code>Canvas c = new Canvas(bitmap);
</code></pre><p>或</p>
<pre><code>Canvas c = new Canvas();   
c.setBitmap(bitmap);
</code></pre><p>其中bitmap可以从图片加载，也可以创建，有下面几种方法</p>
<pre><code>//方法一：新建一个空白bitmap  
Bitmap bmp = Bitmap.createBitmap(width ,height Bitmap.Config.ARGB_8888);  
//方法二：从图片中加载  
Bitmap bmp = BitmapFactory.decodeResource(getResources(),R.drawable.wave_bg,null); 
</code></pre><h6 id="2、在OnDraw（）中使用"><a href="#2、在OnDraw（）中使用" class="headerlink" title="2、在OnDraw（）中使用"></a>2、在OnDraw（）中使用</h6><p>我们一定要注意的是，如果我们用bitmap构造了一个canvas，那这个canvas上绘制的图像也都会保存在这个bitmap上，而不是画在View上，如果想画在View上就必须使用OnDraw（Canvas canvas）函数中传进来的canvas画一遍bitmap才能画到view上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapCanvasView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Bitmap mBmp;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Canvas mBmpCanvas;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapCanvasView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">        mBmp = Bitmap.createBitmap(<span class="number">500</span> ,<span class="number">500</span> , Bitmap.Config.ARGB_8888);  </div><div class="line">        mBmpCanvas = <span class="keyword">new</span> Canvas(mBmp);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        mPaint.setTextSize(<span class="number">100</span>);  </div><div class="line">        mBmpCanvas.drawText(<span class="string">"启舰大SB"</span>,<span class="number">0</span>,<span class="number">100</span>,mPaint);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(mBmp,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="方法三：SurfaceHolder-lockCanvas"><a href="#方法三：SurfaceHolder-lockCanvas" class="headerlink" title="方法三：SurfaceHolder.lockCanvas()"></a>方法三：SurfaceHolder.lockCanvas()</h5><p>Canvas除了save()和restore()以外，还有其它一些函数来保存和恢复画布状态，这部分我们就来看看。</p>
<h6 id="1、saveLayer"><a href="#1、saveLayer" class="headerlink" title="1、saveLayer()"></a>1、saveLayer()</h6><p>saveLayer()有两个函数：</p>
<pre><code>/** 
 * 保存指定矩形区域的canvas内容 
 */  
public int saveLayer(RectF bounds, Paint paint, int saveFlags)  
public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)
</code></pre><ul>
<li>RectF bounds：要保存的区域的矩形。</li>
<li>int saveFlags：取值有：ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG、HAS_ALPHA_LAYER_SAVE_FLAG、FULL_COLOR_LAYER_SAVE_FLAG、CLIP_TO_LAYER_SAVE_FLAG总共有这六个，其中ALL_SAVE_FLAG表示保存全部内容</li>
</ul>
<p>第二个构造函数实际与第一个是一样的，只不过是根据四个点来构造一个矩形。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XfermodeView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width = <span class="number">400</span>;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height = <span class="number">400</span>;  </div><div class="line">    <span class="keyword">private</span> Bitmap dstBmp;  </div><div class="line">    <span class="keyword">private</span> Bitmap srcBmp;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XfermodeView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        srcBmp = makeSrc(width, height);  </div><div class="line">        dstBmp = makeDst(width, height);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawColor(Color.GREEN);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, width * <span class="number">2</span>, height * <span class="number">2</span>, mPaint, Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.drawBitmap(dstBmp, <span class="number">0</span>, <span class="number">0</span>, mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));  </div><div class="line">        canvas.drawBitmap(srcBmp, width / <span class="number">2</span>, height / <span class="number">2</span>, mPaint);  </div><div class="line">        mPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">        canvas.restoreToCount(layerID);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// create a bitmap with a circle, used for the "dst" image  </span></div><div class="line">    <span class="function"><span class="keyword">static</span> Bitmap <span class="title">makeDst</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;  </div><div class="line">        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  </div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(bm);  </div><div class="line">        Paint p = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);  </div><div class="line">  </div><div class="line">        p.setColor(<span class="number">0xFFFFCC44</span>);  </div><div class="line">        c.drawOval(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, w, h), p);  </div><div class="line">        <span class="keyword">return</span> bm;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// create a bitmap with a rect, used for the "src" image  </span></div><div class="line">    <span class="function"><span class="keyword">static</span> Bitmap <span class="title">makeSrc</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;  </div><div class="line">        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  </div><div class="line">        Canvas c = <span class="keyword">new</span> Canvas(bm);  </div><div class="line">        Paint p = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);  </div><div class="line">  </div><div class="line">        p.setColor(<span class="number">0xFF66AAFF</span>);  </div><div class="line">        c.drawRect(<span class="number">0</span>, <span class="number">0</span>, w, h, p);  </div><div class="line">        <span class="keyword">return</span> bm;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170217148732260567552.png" alt="20170217148732260567552.png"></p>
<p>那么问题来了，如果我们把saveLayer给去掉，看看会怎样：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021714873226349891.png" alt="2017021714873226349891.png"></p>
<p>我们先回顾下Mode.SRC_IN的效果：在处理源图像时，以显示源图像为主，在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。当目标图像透明度为0时，源图像就完全不显示。<br>再回过来看结果，第一个结果是对的，因为不与圆相交以外的区域透明度都是0，而第二个图像怎么就变成了这屌样，源图像全部都显示出来了。 </p>
<h6 id="（1）、saveLayer的绘图流程"><a href="#（1）、saveLayer的绘图流程" class="headerlink" title="（1）、saveLayer的绘图流程"></a>（1）、saveLayer的绘图流程</h6><p>这是因为在调用saveLayer时，会生成了一个全新的bitmap，这个bitmap的大小就是我们指定的保存区域的大小，新生成的bitmap是全透明的，在调用saveLayer后所有的绘图操作都是在这个bitmap上进行的。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, width * <span class="number">2</span>, height * <span class="number">2</span>, mPaint, Canvas.ALL_SAVE_FLAG);  </div><div class="line">canvas.drawBitmap(dstBmp, <span class="number">0</span>, <span class="number">0</span>, mPaint);  </div><div class="line">mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));  </div><div class="line">canvas.drawBitmap(srcBmp, width / <span class="number">2</span>, height / <span class="number">2</span>, mPaint);</div></pre></td></tr></table></figure>
<p>我们讲过，在画源图像时，会把之前画布上所有的内容都做为目标图像，而在saveLayer新生成的bitmap上，只有dstBmp对应的圆形，所以除了与圆形相交之外的位置都是空像素。<br>在画图完成之后，会把saveLayer所生成的bitmap盖在原来的canvas上面。<br>所以此时的xfermode的合成过程如下图所示：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148741974870433.png" alt="20170218148741974870433.png"></p>
<p>savelayer新建的画布上的图像做为目标图像，矩形所在的透明图层与之相交，计算结果画在新建的透明画布上。最终将计算结果直接盖在原始画布上，形成最终的显示效果。</p>
<h6 id="（2）、没有saveLayer的绘图流程"><a href="#（2）、没有saveLayer的绘图流程" class="headerlink" title="（2）、没有saveLayer的绘图流程"></a>（2）、没有saveLayer的绘图流程</h6><p>然后我们再来看第二个示例，在第二个示例中，唯一的不同就是把saveLayer去掉了；<br>在saveLayer去掉后，所有的绘图操作都放在了原始View的Canvas所对应的Bitmap上了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">    canvas.drawColor(Color.GREEN);  </div><div class="line">    canvas.drawBitmap(dstBmp, <span class="number">0</span>, <span class="number">0</span>, mPaint);  </div><div class="line">    mPaint.setXfermode(<span class="keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.SRC_IN));  </div><div class="line">    canvas.drawBitmap(srcBmp, width / <span class="number">2</span>, height / <span class="number">2</span>, mPaint);  </div><div class="line">    mPaint.setXfermode(<span class="keyword">null</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于我们先把整个画布给染成了绿色，然后再画上了一个圆形，所以在应用xfermode来画源图像的时候，目标图像当前Bitmap上的所有图像了，也就是整个绿色的屏幕和一个圆形了。所以这时候源图像的相交区域是没有透明像素的，透明度全是100%，这也就不难解释结果是这样的原因了。<br>此时的xfermode合成过程如下：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742142589995.png" alt="20170218148742142589995.png"></p>
<p>由于没有调用saveLayer，所以圆形是直接画在原始画布上的，而当矩形与其相交时，就是直接与原始画布上的所有图像做计算的。<br><strong>总结</strong><br>saveLayer会创建一个全新透明的bitmap，大小与指定保存的区域一致，其后的绘图操作都放在这个bitmap上进行。在绘制结束后，会直接盖在上一层的Bitmap上显示。</p>
<h5 id="2、画布与图层"><a href="#2、画布与图层" class="headerlink" title="2、画布与图层"></a>2、画布与图层</h5><p>上面我们讲到了画布(Bitmap)、图层(Layer)和Canvas的概念，估计大家都会被绕晕了。<br>下面我们下面来具体讲解下它们之间的关系。<br><strong>图层(Layer)</strong>：每一次调用canvas.drawXXX系列函数时，都会生成一个透明图层来专门来画这个图形，比如我们上面在画矩形时的透明图层就是这个概念。<br><strong>画布(bitmap)</strong>：每一个画布都是一个bitmap，所有的图像都是画在bitmap上的！我们知道每一次调用canvas.drawxxx函数时，都会生成一个专用的透明图层来画这个图形，画完以后，就盖在了画布上。所以如果我们连续调用五个draw函数，那么就会生成五个透明图层，画完之后依次盖在画布上显示。<br>画布有两种，第一种是view的原始画布，是通过onDraw（Canvas canvas）函数传进来的，其中参数中的canvas就对应的是view的原始画布，控件的背景就是画在这个画布上的！<br>另一种是人造画布，通过saveLayer()、new Canvas(bitmap)这些方法来人为新建一个画布。尤其是saveLayer()，一旦调用saveLayer()新建一个画布以后，以后的所有draw函数所画的图像都是画在这个画布上的，只有当调用restore()、resoreToCount()函数以后，才会返回到原始画布上绘制。<br><strong>Canvas</strong>:这个概念比较难理解，我们可以把Canvas理解成画板，Bitmap理解成透明画纸，而Layer则理解成图层；每一个draw函数都对应一个图层，在一个图形画完以后，就放在画纸上显示。而一张张透明的画纸则一层层地叠加在画板上显示出来。我们知道画板和画纸都是用夹子夹在一起的，所以当我们旋转画板时，所有画纸都会跟着旋转！当我们把整个画板裁小时，所以的画纸也都会变小了！<br>这一点非常重要，当我们利用saveLayer来生成多个画纸时，然后最上层的画纸调用canvas.rotate(30)是把画板给旋转了，所有的画纸也都被旋转30度！这一点非常注意。<br>另外，如果最上层的画纸调用canvas.clipRect()将画板裁剪了，那么所有的画纸也都会被裁剪。唯一能够恢复的操作是调用canvas.revert()把上一次的动作给取消掉！<br>但在利用canvas绘图与画板不一样的是，画布的影响只体现在以后的操作上，以前画上去的图像已经显示在屏幕上是不会受到影响的。   </p>
<h4 id="三、save-、saveLayer-、saveLayerAlpha-中的用法"><a href="#三、save-、saveLayer-、saveLayerAlpha-中的用法" class="headerlink" title="三、save()、saveLayer()、saveLayerAlpha()中的用法"></a>三、save()、saveLayer()、saveLayerAlpha()中的用法</h4><h5 id="1、saveLayer的用法"><a href="#1、saveLayer的用法" class="headerlink" title="1、saveLayer的用法"></a>1、saveLayer的用法</h5><pre><code>public int saveLayer(RectF bounds, Paint paint, int saveFlags)  
public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)
</code></pre><p>我们前面提到了saveLayer会新建一个画布(bitmap)，后续的所有操作都是在这个画布上进行的。下面我们来分别看下saveLayer使用中的注意事项。</p>
<h6 id="（1）、saveLayer后的所有动作都只对新建画布有效"><a href="#（1）、saveLayer后的所有动作都只对新建画布有效" class="headerlink" title="（1）、saveLayer后的所有动作都只对新建画布有效"></a>（1）、saveLayer后的所有动作都只对新建画布有效</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveLayerUseExample_3_1</span> <span class="keyword">extends</span> <span class="title">View</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap mBitmap;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveLayerUseExample_3_1</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.dog);;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawBitmap(mBitmap,<span class="number">0</span>,<span class="number">0</span>,mPaint);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.skew(<span class="number">1.732f</span>,<span class="number">0</span>);  </div><div class="line">        canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">160</span>,mPaint);  </div><div class="line">        canvas.restoreToCount(layerID);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021814874216459105.png" alt="2017021814874216459105.png"></p>
<p>在onDraw中，我们先在view的原始画布上画上了小狗的图像，然后利用saveLayer新建了一个图层，然后利用canvas.skew将新建的图层水平斜切45度。所以之后画的矩形(0,0,150,160)就是斜切的。<br>而正是由于在新建画布后的各种操作都是针对新建画布来操作的，不会对以前的画布产生影响，从效果图中也明显可以看出，将画布水平斜切45度也只影响了saveLayer的新建画布，并没有对之前的原始画布产生影响。  </p>
<h6 id="（2）、通过Rect指定矩形大小就是新建的画布大小"><a href="#（2）、通过Rect指定矩形大小就是新建的画布大小" class="headerlink" title="（2）、通过Rect指定矩形大小就是新建的画布大小"></a>（2）、通过Rect指定矩形大小就是新建的画布大小</h6><p>在saveLayer的参数中，我们可以通过指定Rect对象或者指定四个点来来指定一个矩形，这个矩形的大小就是新建画布的大小，我们举例来看一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveLayerUseExample_3_1</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> Bitmap mBitmap;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveLayerUseExample_3_1</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog);  </div><div class="line">        ;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawBitmap(mBitmap, <span class="number">0</span>, <span class="number">0</span>, mPaint);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerID = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>, mPaint, Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">600</span>, mPaint);  </div><div class="line">        canvas.restoreToCount(layerID);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742173885362.png" alt="20170218148742173885362.png"></p>
<p>在绘图时，我们先把小狗图片绘制在原始画布上的，然后新建一个大小为(0,0,100,100)大小的透明画布，然后再在这个画布上画一个(0, 0, 500, 600)的矩形。由于画布大小只有(0,0,100,100)，所以(0, 0, 500, 600)这个矩形并不能完全显示出来，也只能显示出来(0,0,100,100)画布大小的部分。<br>那有些同学会说了，nnd，为了避免画布太小而出现问题，我每次都新建一个屏幕大小的画布多好，这样虽然是不会出现问题，但你想过没有，屏幕大小的画布需要多少空间吗，按一个像素需要8bit存储空间算，1024 <em> 768的机器，所使用的bit数就是1024 </em> 768 <em> 8=6.2M！所以我们在使用saveLayer新建画布时，一定要选择适当的大小，不然你的APP很可能OOM哦。<br><em>*注意，注意：在我的例子中都是直接新建全屏画布的，因为写例子比较方便！！！！但是我这只是示例，在现实使用中，一定要适量的创建画布的大小哦！</em></em></p>
<h5 id="2、saveLayerAlpha的用法"><a href="#2、saveLayerAlpha的用法" class="headerlink" title="2、saveLayerAlpha的用法"></a>2、saveLayerAlpha的用法</h5><pre><code>public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags)  
public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags)
</code></pre><p>相比saveLayer，多一个alpha参数，用以指定新建画布透明度,取值范围为0-255，可以用16进制的oxAA表示；<br>这个函数的意义也是在调用的时候会新建一个bitmap画布，以后的各种绘图操作都作用在这个画布上，但这个画布是有透明度的，透明度就是通过alpha值指定的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveLayerAlphaView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaveLayerAlphaView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>,mPaint);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> layerID = canvas.saveLayerAlpha(<span class="number">0</span>,<span class="number">0</span>,<span class="number">600</span>,<span class="number">600</span>,<span class="number">0x88</span>,Canvas.ALL_SAVE_FLAG);  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">        canvas.drawRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">400</span>,<span class="number">400</span>,mPaint);  </div><div class="line">        canvas.restoreToCount(layerID);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742220432348.png" alt="20170218148742220432348.png"></p>
<p>在saveLayerAlpha以后，我们画了一个绿色的矩形，由于把saveLayerAlpha新建的矩形的透明度是0x88（136）大概是50%透明度，从效果图中也可以看出在新建图像与上一画布合成后，是具有透明度的。</p>
<h3 id="九、Canvas与图层（二）"><a href="#九、Canvas与图层（二）" class="headerlink" title="九、Canvas与图层（二）"></a>九、Canvas与图层（二）</h3><h4 id="一、FLAG的具体意义"><a href="#一、FLAG的具体意义" class="headerlink" title="一、FLAG的具体意义"></a>一、FLAG的具体意义</h4><h5 id="1、FLAG概述"><a href="#1、FLAG概述" class="headerlink" title="1、FLAG概述"></a>1、FLAG概述</h5><p>有关save系列函数，在canvas中总共有如下几个：</p>
<pre><code>public int save()  
public int save(int saveFlags)  
public int saveLayer(RectF bounds, Paint paint, int saveFlags)  
public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)  
public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags)  
public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags)
</code></pre><p>这段我们先关注前四个，save的两个函数和saveLayer的两个函数；我们知道他们两个不同之处在于saveLayer会新建一个画布，而save函数则不会新建画布；它们都具有Flag标识，这些Flag标识的意义和使用范围如下：</p>
<table>
<thead>
<tr>
<th>FLAG</th>
<th style="text-align:center">意义</th>
<th style="text-align:center">适用范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>ALL_SAVE_FLAG</td>
<td style="text-align:center">保存所有的标识</td>
<td style="text-align:center">save()、saveLayer()</td>
</tr>
<tr>
<td>MATRIX_SAVE_FLAG</td>
<td style="text-align:center">仅保存canvas的matrix数组</td>
<td style="text-align:center">save()、saveLayer()</td>
</tr>
<tr>
<td>CLIP_SAVE_FLAG</td>
<td style="text-align:center">仅保存canvas的当前大小</td>
<td style="text-align:center">save()、saveLayer()</td>
</tr>
<tr>
<td>HAS_ALPHA_LAYER_SAVE_FLAG</td>
<td style="text-align:center">标识新建的bmp具有透明度，在与上层画布结合时，透明位置显示上图图像,与FULL_COLOR_LAYER_SAVE_FLAG冲突，若同时指定，则以HAS_ALPHA_LAYER_SAVE_FLAG为主</td>
<td style="text-align:center">saveLayer()</td>
</tr>
<tr>
<td>FULL_COLOR_LAYER_SAVE_FLAG</td>
<td style="text-align:center">标识新建的bmp颜色完全独立，在与上层画布结合时，先清空上层画布再覆盖上去</td>
<td style="text-align:center">saveLayer()</td>
</tr>
<tr>
<td>CLIP_TO_LAYER_SAVE_FLAG</td>
<td style="text-align:center">在保存图层前先把当前画布根据bounds裁剪，与CLIP_SAVE_FLAG冲突，若同时指定，则以CLIP_SAVE_FLAG为主</td>
<td style="text-align:center">saveLayer()</td>
</tr>
</tbody>
</table>
<p>从上面的表格中可以看到，ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG是save()、saveLayer()共用的。而另外三个是saveLayer()专用的；我们一个个来解析下它们的不同之处<br>在讲解之前，我们先考虑一下，如果让我们保存一个画布的状态，以便恢复，我们需要保存哪些内容呢？<br>第一个是位置信息，第二个是大小信息；好像除此之外也没什么了。所以，位置信息对应的是MATRIX_SAVE_FLAG，大小信息对应的是：CLIP_SAVE_FLAG，这也就是save\saveLayer所共用的，而另外的三个函数，则是指定saveLayer新建的bitmap具有哪种特性。已经不再是保存画布的范畴了。  </p>
<h5 id="2、FLAG之MATRIX-SAVE-FLAG"><a href="#2、FLAG之MATRIX-SAVE-FLAG" class="headerlink" title="2、FLAG之MATRIX_SAVE_FLAG"></a>2、FLAG之MATRIX_SAVE_FLAG</h5><h6 id="1-、save-int-flag-与MATRIX-SAVE-FLAG"><a href="#1-、save-int-flag-与MATRIX-SAVE-FLAG" class="headerlink" title="(1)、save(int flag)与MATRIX_SAVE_FLAG"></a>(1)、save(int flag)与MATRIX_SAVE_FLAG</h6><p>我们知道canvas.translate(平移)、canvas.rotate（旋转）、canvas.scale（缩放）、canvas.skew（扭曲）其实都是利用位置矩阵matrix实现的，而MATRIX_SAVE_FLAG标识就是指定只保存这个位置矩阵，除此之外的其它任何内容都不会被保存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MATRIX_SAVE_FLAG_View</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MATRIX_SAVE_FLAG_View</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.save(Canvas.MATRIX_SAVE_FLAG);  </div><div class="line">        canvas.rotate(<span class="number">40</span>);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.YELLOW);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们直接看OnDraw函数，先调用 canvas.save(Canvas.MATRIX_SAVE_FLAG)将canvas的位置矩阵保存起来，然后将画布旋转40度之后，画一个绿色矩形；<br>然后调用canvas.restore()之后将画布恢复，然后再在同一个位置画一个黄色的矩形。 </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742296840865.png" alt="20170218148742296840865.png"></p>
<p>很明显，在canvas.restore()后，画布的旋转给恢复到了原来了状态。<br>然后我们再来看看，如果我们给画布裁剪，看还能不能被恢复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MATRIX_SAVE_FLAG_View</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MATRIX_SAVE_FLAG_View</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.save(Canvas.MATRIX_SAVE_FLAG);  </div><div class="line">        canvas.clipRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>);  </div><div class="line">        canvas.drawColor(Color.GREEN);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.YELLOW);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742300536373.png" alt="20170218148742300536373.png"></p>
<p>从效果图来看，我们恢复画布后，把画布全部染成了黄色，但并没有染全屏幕的画布，而只是clip后的一部分，这说明，被裁剪的画布没有被还原！<br>前面我们说了调用 canvas.save(Canvas.MATRIX_SAVE_FLAG)只会保存了位置矩阵！恢复时，也只会恢复画布的位置信息，有关画布的大小，是不会被恢复的！   </p>
<h6 id="（2）、saveLayer-与MATRIX-SAVE-FLAG"><a href="#（2）、saveLayer-与MATRIX-SAVE-FLAG" class="headerlink" title="（2）、saveLayer()与MATRIX_SAVE_FLAG"></a>（2）、saveLayer()与MATRIX_SAVE_FLAG</h6><p>同样先来看旋转的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MATRIX_SAVE_FLAG_View</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MATRIX_SAVE_FLAG_View</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.rotate(<span class="number">40</span>);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.YELLOW);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742306668570.png" alt="20170218148742306668570.png"></p>
<p>这里在保存Flag时，多了一个Canvas.HAS_ALPHA_LAYER_SAVE_FLAG，表示在新建的画布在合成到上一个画布上时，直接覆盖，不清空所在区域原图像，这个标识这里先忽略，我们后面会具体讲。<br>效果与原因都是与save()相同，指定保存Canvas.MATRIX_SAVE_FLAG，即canvas的位置信息，当调用canvas.revert()后，原始画布的旋转被恢复。所以再次画图到原始画布上时，是没有旋转的。<br><strong>我们还是直接来看例子吧，裁剪：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MATRIX_SAVE_FLAG_View</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MATRIX_SAVE_FLAG_View</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.GREEN);  </div><div class="line">  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.clipRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.YELLOW);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742316578128.png" alt="20170218148742316578128.png"></p>
<p>与上面的例子一样，在saveLayer中也只是保存Canvas.MATRIX_SAVE_FLAG，即canvas的位置信息，之后调用canvas.clipRect(100,0,200,100);将画板裁剪，注意我们在讲解canvas时提到了，无论哪个图层调用canvas的位置变换和裁剪操作，所有的画布都会受到连累，这些连累也只表现在画布以后的绘图上，之前画过的图像不会受到影响。<br>所以在clipRect之前画出来的全屏绿色是不受影响的，当restore()以后，canvas只恢复了原始画布的位置信息而原始画布的大小却无法被恢复，所以当再调用 canvas.drawColor(Color.YELLOW)，也只能画出来一小块了。<br>注意：在上面的例子中用到了canvas.clipRect()，这个函数是不支持硬件加速的，所以需要添加setLayerType函数来禁用硬件加速。<br><strong>总结</strong>  </p>
<ul>
<li>当save\saveLayer调用Canvas.MATRIX_SAVE_FLAG标识时只会保存画布的位置矩阵信息，在canvas.restore()时也只会恢复位置信息，而改变过的画布大小是不会被恢复的。 </li>
<li>当使用canvas.saveLayer(Canvas.MATRIX_SAVE_FLAG)时，需要与Canvas.HAS_ALPHA_LAYER_SAVE_FLAG一起使用，不然新建画布所在区域原来的图像将被清空。</li>
</ul>
<h5 id="3、FLAG之CLIP-SAVE-FLAG"><a href="#3、FLAG之CLIP-SAVE-FLAG" class="headerlink" title="3、FLAG之CLIP_SAVE_FLAG"></a>3、FLAG之CLIP_SAVE_FLAG</h5><p>这个标识的意思是仅保存Canvas的裁剪信息，而对于位置信息则不管不问，所以在canvas.restore()时，会只恢复Canvas的大小，而对于Canvas的旋转、平移等位置改变的信息是不会恢复的。 </p>
<h6 id="1-、save-int-flag-与CLIP-SAVE-FLAG"><a href="#1-、save-int-flag-与CLIP-SAVE-FLAG" class="headerlink" title="(1)、save(int flag)与CLIP_SAVE_FLAG"></a>(1)、save(int flag)与CLIP_SAVE_FLAG</h6><p>我们先来看个裁剪的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIP_SAVE_FLAG_View</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLIP_SAVE_FLAG_View</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">        canvas.save(Canvas.CLIP_SAVE_FLAG);  </div><div class="line">        canvas.clipRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.YELLOW);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742402341933.png" alt="20170218148742402341933.png"></p>
<p>从效果图中可以看出在canvas.restore()后，canvas被恢复到初始化的全屏大小。<br>然后我们再看一个旋转的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIP_SAVE_FLAG_View</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLIP_SAVE_FLAG_View</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">  </div><div class="line">        canvas.save(Canvas.CLIP_SAVE_FLAG);  </div><div class="line">        canvas.rotate(<span class="number">40</span>);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.YELLOW);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742406813772.png" alt="20170218148742406813772.png"></p>
<p>我们先画了一个绿色的矩形，之后旋转画布，然后在调用 canvas.restore()恢复画布之后，再画上一个同样的黄色矩形。<br>从效果图中可以看出，canvas在恢复时，并没有恢复旋转的画布，这也就是Canvas.CLIP_SAVE_FLAG的意义所在，只保存裁剪信息，不保存位置信息，所以恢复时，位置信息是不会被恢复的！ </p>
<h6 id="2-、saveLayer-int-flag-与CLIP-SAVE-FLAG"><a href="#2-、saveLayer-int-flag-与CLIP-SAVE-FLAG" class="headerlink" title="(2)、saveLayer(int flag)与CLIP_SAVE_FLAG"></a>(2)、saveLayer(int flag)与CLIP_SAVE_FLAG</h6><p>在添加上Canvas.HAS_ALPHA_LAYER_SAVE_FLAG标识以后，效果与canvas.save相同，这里就简单讲解一下。<br>先看裁剪的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIP_SAVE_FLAG_View</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLIP_SAVE_FLAG_View</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">           canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.clipRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.YELLOW);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742428492797.png" alt="20170218148742428492797.png"></p>
<p>效果与canvas.save一样，原因也很简单，因为Canvas.CLIP_SAVE_FLAG标识是可以恢复裁剪信息的。<br>然后再来看看旋转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIP_SAVE_FLAG_View</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLIP_SAVE_FLAG_View</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.rotate(<span class="number">40</span>);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        mPaint.setColor(Color.YELLOW);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742436552801.png" alt="20170218148742436552801.png"></p>
<p>因为Canvas.CLIP_SAVE_FLAG不能保存位置信息，所以在canvas.restore()后，旋转并没有被恢复。   </p>
<p><strong>总结</strong>  </p>
<ul>
<li>当save/saveLayer调用 Canvas.CLIP_SAVE_FLAG时只会保存画布的裁剪信息，在canvas.restore()时也只会恢复裁剪信息，而改变过的画布位置信息是不会被恢复的。 </li>
<li>当使用canvas.saveLayer(Canvas.CLIP_SAVE_FLAG)时，需要与Canvas.HAS_ALPHA_LAYER_SAVE_FLAG一起使用，不然新建画布所在区域原来的图像将被清空。</li>
</ul>
<h5 id="4、FLAG之HAS-ALPHA-LAYER-SAVE-FLAG和FULL-COLOR-LAYER-SAVE-FLAG"><a href="#4、FLAG之HAS-ALPHA-LAYER-SAVE-FLAG和FULL-COLOR-LAYER-SAVE-FLAG" class="headerlink" title="4、FLAG之HAS_ALPHA_LAYER_SAVE_FLAG和FULL_COLOR_LAYER_SAVE_FLAG"></a>4、FLAG之HAS_ALPHA_LAYER_SAVE_FLAG和FULL_COLOR_LAYER_SAVE_FLAG</h5><p>这两个标识都是saveLayer()专用的<br>HAS_ALPHA_LAYER_SAVE_FLAG表示新建的bitmap画布在与上一个画布合成时，不会将上一层画布内容清空，直接盖在上一个画布内容上面。<br>FULL_COLOR_LAYER_SAVE_FLAG则表示新建的bimap画布在与上一个画布合成时，先将上一层画布对应区域清空，然后再盖在上面。<br>下面我们分别举例子来看<br>注意一定要在view中禁用掉硬件加速，因为在api 21之后，才支持saveLayer </p>
<h6 id="1-、FULL-COLOR-LAYER-SAVE-FLAG"><a href="#1-、FULL-COLOR-LAYER-SAVE-FLAG" class="headerlink" title="(1)、FULL_COLOR_LAYER_SAVE_FLAG"></a>(1)、FULL_COLOR_LAYER_SAVE_FLAG</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ALPHA_COLOR_FALG_VIEW</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ALPHA_COLOR_FALG_VIEW</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>,mPaint,Canvas.FULL_COLOR_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>,mPaint);  </div><div class="line">        canvas.restore();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742446966878.png" alt="20170218148742446966878.png"></p>
<p>我们在saveLayer时，新建bitmap画布的大小为(0,0,500,500)，然后在新建画布中画了一个矩形(100,100,300,300)，由于我们使用的标识是Canvas.FULL_COLOR_LAYER_SAVE_FLAG，所以新建画布在与上一层画布合成时，会先把上一层画布对应区域的图像清空掉，然后再盖上新建画布。由于新建画布中除了绿色矩形，其它位置都是透明像素，所以就显示出Activity的底色（黑色）。如果你把activity的背景色在xml中设置为白色，做出来的效果图中，露出来的就是白色了： </p>
<p><strong>main.xml</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>  </span></div><div class="line">	<span class="attr">android:orientation</span>=<span class="string">"vertical"</span>  </div><div class="line">	<span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span>  </div><div class="line">	<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span>  </div><div class="line">	<span class="attr">android:background</span>=<span class="string">"#ffffff"</span>  </div><div class="line"> &gt;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742459559982.png" alt="20170218148742459559982.png"></p>
<h6 id="2-、HAS-ALPHA-LAYER-SAVE-FLAG"><a href="#2-、HAS-ALPHA-LAYER-SAVE-FLAG" class="headerlink" title="(2)、HAS_ALPHA_LAYER_SAVE_FLAG"></a>(2)、HAS_ALPHA_LAYER_SAVE_FLAG</h6><p>我把简单把上面的示例代码改一下，把Canvas.FULL_COLOR_LAYER_SAVE_FLAG改成Canvas.HAS_ALPHA_LAYER_SAVE_FLAG：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ALPHA_COLOR_FALG_VIEW</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ALPHA_COLOR_FALG_VIEW</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>,mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>,mPaint);  </div><div class="line">        canvas.restore();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="（3）、共用时，以HAS-ALPHA-LAYER-SAVE-FLAG为主"><a href="#（3）、共用时，以HAS-ALPHA-LAYER-SAVE-FLAG为主" class="headerlink" title="（3）、共用时，以HAS_ALPHA_LAYER_SAVE_FLAG为主"></a>（3）、共用时，以HAS_ALPHA_LAYER_SAVE_FLAG为主</h6><p>很明显这两个标识是相互冲突的，因为Canvas.HAS_ALPHA_LAYER_SAVE_FLAG表示直接盖上去而不清空上一画布的图像，而Canvas.FULL_COLOR_LAYER_SAVE_FLAG则表示先将上一画布对应区域图像清空，然后再盖上去。当他们共用时，以哪个标识位为主呢？ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ALPHA_COLOR_FALG_VIEW</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ALPHA_COLOR_FALG_VIEW</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>,mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.FULL_COLOR_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>,mPaint);  </div><div class="line">        canvas.restore();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742508941855.png" alt="20170218148742508941855.png"><br>所以从效果图中也可以看出，当这两个标识同时使用时，以Canvas.HAS_ALPHA_LAYER_SAVE_FLAG为主。</p>
<h6 id="（4）、当saveLayer只指定MATRIX-SAVE-FLAG-CLIP-SAVE-FLAG的合成方式"><a href="#（4）、当saveLayer只指定MATRIX-SAVE-FLAG-CLIP-SAVE-FLAG的合成方式" class="headerlink" title="（4）、当saveLayer只指定MATRIX_SAVE_FLAG/CLIP_SAVE_FLAG的合成方式"></a>（4）、当saveLayer只指定MATRIX_SAVE_FLAG/CLIP_SAVE_FLAG的合成方式</h6><p>前面我们在讲解saveLayer的MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG标识时，都强制加上了Canvas.HAS_ALPHA_LAYER_SAVE_FLAG标识，意思是让其在合成时不清空上一画布图像。那么问题来了，当我们只指定MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG标识时，Android默认的合成方式哪一个呢？ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ALPHA_COLOR_FALG_VIEW</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ALPHA_COLOR_FALG_VIEW</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,<span class="number">500</span>,<span class="number">500</span>,mPaint,Canvas.MATRIX_SAVE_FLAG);  </div><div class="line">        canvas.rotate(<span class="number">40</span>);  </div><div class="line">        canvas.drawRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">300</span>, <span class="number">300</span>, mPaint);  </div><div class="line">        canvas.restore();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742514697242.png" alt="20170218148742514697242.png"></p>
<p>从效果图中可以看出，在默认情况下使用的是Canvas.FULL_COLOR_LAYER_SAVE_FLAG标识，即先清空上一层画布对应区域的图像，然后再合成，所以这也是我们在上面的例子中强制添加HAS_ALPHA_LAYER_SAVE_FLAG标识的原因</p>
<p><strong>总结</strong>  </p>
<ul>
<li>HAS_ALPHA_LAYER_SAVE_FLAG表示新建的bitmap画布在与上一个画布合成时，不会将上一层画布内容清空，直接盖在上一个画布内容上面。 </li>
<li>FULL_COLOR_LAYER_SAVE_FLAG则表示新建的bimap画布在与上一个画布合成时，先将上一层画布对应区域清空，然后再盖在上面。 </li>
<li>当HAS_ALPHA_LAYER_SAVE_FLAG与FULL_COLOR_LAYER_SAVE_FLAG两个标识同时指定时，以HAS_ALPHA_LAYER_SAVE_FLAG为主 </li>
<li>当即没有指定HAS_ALPHA_LAYER_SAVE_FLAG也没有指定FULL_COLOR_LAYER_SAVE_FLAG时，系统默认使用FULL_COLOR_LAYER_SAVE_FLAG；</li>
</ul>
<h5 id="5、FLAG之CLIP-TO-LAYER-SAVE-FLAG"><a href="#5、FLAG之CLIP-TO-LAYER-SAVE-FLAG" class="headerlink" title="5、FLAG之CLIP_TO_LAYER_SAVE_FLAG"></a>5、FLAG之CLIP_TO_LAYER_SAVE_FLAG</h5><h6 id="（1）、概述"><a href="#（1）、概述" class="headerlink" title="（1）、概述"></a>（1）、概述</h6><p>这个标识比较犯贱，它的意义是，在新建bitmap前，先把canvas给裁剪，前面我们讲过canvas代表的是画板的意思，一旦画板被裁剪，那么其中的各个画布都会被受到影响。而且由于它是在新建bitmap前做的裁剪，所以是无法恢复的！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIP_TO_LAYER_SAVE_FLAG_VIEW</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLIP_TO_LAYER_SAVE_FLAG_VIEW</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span>, mPaint, Canvas.CLIP_TO_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.YELLOW);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742626216035.png" alt="20170218148742626216035.png"></p>
<p>从效果图中可以看出，当我们调用canvas.saveLayer(0, 0, 500, 500, mPaint, Canvas.CLIP_TO_LAYER_SAVE_FLAG)时，canvas画板就被裁剪了，不仅影响了自己，而且还把view的原始画布给影响了，虽然在调用了canvas.restore()，但最后一句在将原始画布填充为黄色，也可以看出，原始画布没有被恢复！ </p>
<h6 id="（2）、与CLIP-SAVE-FLAG共用时，Canvas将被恢复"><a href="#（2）、与CLIP-SAVE-FLAG共用时，Canvas将被恢复" class="headerlink" title="（2）、与CLIP_SAVE_FLAG共用时，Canvas将被恢复"></a>（2）、与CLIP_SAVE_FLAG共用时，Canvas将被恢复</h6><p>我们知道，前面有一个保存裁剪信息的标识：CLIP_SAVE_FLAG，假如我们让它裁剪时，先保存裁剪区域，是不是可以恢复过来呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLIP_TO_LAYER_SAVE_FLAG_VIEW</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CLIP_TO_LAYER_SAVE_FLAG_VIEW</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span>, mPaint, Canvas.CLIP_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG);  </div><div class="line">        canvas.restore();  </div><div class="line">  </div><div class="line">        canvas.drawColor(Color.YELLOW);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742631591725.png" alt="20170218148742631591725.png"></p>
<p>从效果图中可以看出canvas被恢复了，不过canvas被恢复也，也就失去了Canvas.CLIP_TO_LAYER_SAVE_FLAG标识的意义了。<br><strong>总结</strong>  </p>
<ul>
<li>CLIP_TO_LAYER_SAVE_FLAG意义是在新建bitmap前，先把canvas给裁剪，一旦画板被裁剪，那么其中的各个画布都会被受到影响。而且由于它是在新建bitmap前做的裁剪，所以是无法恢复的； </li>
<li>当CLIP_TO_LAYER_SAVE_FLAG与CLIP_SAVE_FLAG标识共用时，在调用restore()后，画布将被恢复</li>
</ul>
<h5 id="6、FLAG之ALL-SAVE-FLAG"><a href="#6、FLAG之ALL-SAVE-FLAG" class="headerlink" title="6、FLAG之ALL_SAVE_FLAG"></a>6、FLAG之ALL_SAVE_FLAG</h5><p>这个标识是我们最常用的，它是所有标识的公共集合。<br>对于save(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG；即保存位置信息和裁剪信息<br>对于save(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG很容易理解，因为save(int flag)函数只能使用MATRIX_SAVE_FLAG 、CLIP_SAVE_FLAG这两个标识。<br>对于saveLayer(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG；即保存保存位置信息和裁剪信息，新建画布在与上一层画布合成时，不清空原画布内容。<br>原本来讲saveLayer的ALL_SAVE_FLAG标识应当是它所能使用的所有标识的集合，即应当是ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG|FULL_COLOR_LAYER_SAVE_FLAG|CLIP_TO_LAYER_SAVE_FLAG,但由于HAS_ALPHA_LAYER_SAVE_FLAG与FULL_COLOR_LAYER_SAVE_FLAG共用时以HAS_ALPHA_LAYER_SAVE_FLAG为主，CLIP_TO_LAYER_SAVE_FLAG与CLIP_SAVE_FLAG共用时，CLIP_TO_LAYER_SAVE_FLAG将无效，所以最终ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG；<br>在理解了上面各个TAG的样式以后，这个TAG的难度几乎没有，这里就不再举例了。  </p>
<h4 id="四、restore-与restoreToCount"><a href="#四、restore-与restoreToCount" class="headerlink" title="四、restore()与restoreToCount()"></a>四、restore()与restoreToCount()</h4><h5 id="1、restore"><a href="#1、restore" class="headerlink" title="1、restore()"></a>1、restore()</h5><p>restore()的作用就是把回退栈中的最上层画布状态出栈，恢复画布状态.</p>
<h5 id="2、restoreToCount-int-count"><a href="#2、restoreToCount-int-count" class="headerlink" title="2、restoreToCount(int count)"></a>2、restoreToCount(int count)</h5><pre><code>public int save()  
public int save(int saveFlags)  
public int saveLayer(RectF bounds, Paint paint, int saveFlags)  
public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags)  
public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags)  
public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags)
</code></pre><p>在save()、saveLayer()、saveLayerAlpha()保存画布后，都会返回一个ID值，这个ID值表示当前保存的画布信息的栈层索引（从0开始），比如保存在第三层，则返回2； </p>
<pre><code>public void restoreToCount(int saveCount);
</code></pre><p>它表示一直退栈，一直退到指定count的层数为栈顶为止；注意这个saveCount起始值是从1开始的，也就是说它比对应栈的索引要多1；<br>比如，我们开始的栈已经有两层，然后我们调用如下代码：</p>
<pre><code>int id = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG);  
canvas.restoreToCount(id);
</code></pre><p>调用canvas.saveLayer后，新保存的画布放在了第三层，返回的id的值是对应的索引即2<br>而canvas.restoreToCount(id);则表示一直退栈，把栈一直退到第二层在栈顶的位置，刚好把新建的第三层给退出掉。<br>所以利用这个特性，我们可以调用save函数的时候，把对应的id保存住，然后canvas.restoreToCount(id)就可以把栈的状态回退到生成这个id前的状态。<br>下面我们举个例子来看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestoreToCountView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> String TAG = <span class="string">"qijian"</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RestoreToCountView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> id1 = canvas.save();  </div><div class="line">        canvas.clipRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">800</span>,<span class="number">800</span>);  </div><div class="line">        canvas.drawColor(Color.RED);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount()+<span class="string">"  id1:"</span>+id1);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> id2 = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.clipRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">700</span>,<span class="number">700</span>);  </div><div class="line">        canvas.drawColor(Color.GREEN);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount()+<span class="string">"  id2:"</span>+id2);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> id3 = canvas.saveLayerAlpha(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),<span class="number">0xf0</span>,Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.clipRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">600</span>,<span class="number">600</span>);  </div><div class="line">        canvas.drawColor(Color.YELLOW);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount()+<span class="string">"  id3:"</span>+id3);  </div><div class="line">  </div><div class="line">        <span class="keyword">int</span> id4 = canvas.save(Canvas.ALL_SAVE_FLAG);  </div><div class="line">        canvas.clipRect(<span class="number">300</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">500</span>);  </div><div class="line">        canvas.drawColor(Color.BLUE);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount()+<span class="string">"  id4:"</span>+id4);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在onDraw函数中，我们连续对canvas做裁剪，并且在裁剪后，把当前画布画上一层不同的颜色，然后把当前的栈的层数和最高层的索引打出来<br>效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742679241010.png" alt="20170218148742679241010.png"></p>
<p>Log日志如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742681392967.png" alt="20170218148742681392967.png"></p>
<p>然后我们更改一下上面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">   <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">   <span class="keyword">int</span> id1 = canvas.save();  </div><div class="line">   canvas.clipRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">800</span>,<span class="number">800</span>);  </div><div class="line">   canvas.drawColor(Color.RED);  </div><div class="line">   Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount()+<span class="string">"  id1:"</span>+id1);  </div><div class="line">  </div><div class="line">   <span class="keyword">int</span> id2 = canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line">   canvas.clipRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">700</span>,<span class="number">700</span>);  </div><div class="line">   canvas.drawColor(Color.GREEN);  </div><div class="line">   Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount()+<span class="string">"  id2:"</span>+id2);  </div><div class="line">  </div><div class="line">   <span class="keyword">int</span> id3 = canvas.saveLayerAlpha(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),<span class="number">0xf0</span>,Canvas.ALL_SAVE_FLAG);  </div><div class="line">   canvas.clipRect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">600</span>,<span class="number">600</span>);  </div><div class="line">   canvas.drawColor(Color.YELLOW);  </div><div class="line">   Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount()+<span class="string">"  id3:"</span>+id3);  </div><div class="line">  </div><div class="line">   <span class="keyword">int</span> id4 = canvas.save(Canvas.ALL_SAVE_FLAG);  </div><div class="line">   canvas.clipRect(<span class="number">300</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">500</span>);  </div><div class="line">   canvas.drawColor(Color.BLUE);  </div><div class="line">   Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount()+<span class="string">"  id4:"</span>+id4);  </div><div class="line">  </div><div class="line">   canvas.restoreToCount(id3);  </div><div class="line">   canvas.drawColor(Color.GRAY);  </div><div class="line">   Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount());  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们在最后添加上canvas.restoreToCount(id3);，然后把画布整个绘成灰色。<br>效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021814874268559257.png" alt="2017021814874268559257.png"></p>
<p>Log日志如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742687161169.png" alt="20170218148742687161169.png"></p>
<p>从代码中可以看出调用canvas.restoreToCount(id3)后，将恢复到生成id3之前的画布状态，id3之前的画布状态就是(100,100,700,700)</p>
<h5 id="3、restore-与restoreToCount-int-count-关系"><a href="#3、restore-与restoreToCount-int-count-关系" class="headerlink" title="3、restore()与restoreToCount(int count)关系"></a>3、restore()与restoreToCount(int count)关系</h5><p>它们两个针对的都是同一个栈，所以是完全可以通用的，不同的是restore()是默认将栈顶内容退出还原画布，而restoreToCount(int count)则是一直退栈，直到指定层count做为栈顶，将此之前的所有动作都恢复。<br>大家可能还有个疑问，前面我们讲了各种FLAG，在应用不同FLAG时，都是保存在同一个栈中吗，我们下面试一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestoreToCountView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="keyword">private</span> String TAG = <span class="string">"qijian"</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RestoreToCountView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.save();  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount());  </div><div class="line">        canvas.save(Canvas.ALL_SAVE_FLAG);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount());  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount());  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount());  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount());  </div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG);  </div><div class="line">        Log.d(TAG,<span class="string">"count:"</span>+canvas.getSaveCount());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们多次调用不同的save函数和不同的FLAG，然后将栈中层数打出来，日志如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021814874269323579.png" alt="2017021814874269323579.png"></p>
<p>从效果图中可以明显看出，每save一次，栈的层数都在加一，所以无论哪种save方法，哪个FLAG标识，保存画布时都使用的是同一个栈<br>所以restore()与restoreToCount(int count)的结论来了：  </p>
<ul>
<li>restore的意义是把回退栈中的最上层画布状态出栈，恢复画布状态。restoreToCount(int count)的意义是一直退栈，直到指定层count做为栈顶，将此之前的所有动作都恢复。 </li>
<li>所以无论哪种save方法，哪个FLAG标识，保存画布时都使用的是同一个栈 </li>
<li>restore()与restoreToCount(int count)针对的都是同一个栈，所以是完全可以通用和混用的。</li>
</ul>
<p>好了，有关保存图层的知识到这里就结束了，这两篇内容理解起来可能会比较困难，多看两遍喽，有关FLAG标识的知识，如果看不懂就算了，会用ALL_SAVE_FLAG就行，其它标识用到的机会比较少。</p>
<h2 id="五、实例操作"><a href="#五、实例操作" class="headerlink" title="五、实例操作"></a>五、实例操作</h2><h3 id="一、QQ红点拖动删除效果实现（基本原理篇）"><a href="#一、QQ红点拖动删除效果实现（基本原理篇）" class="headerlink" title="一、QQ红点拖动删除效果实现（基本原理篇）"></a>一、QQ红点拖动删除效果实现（基本原理篇）</h3><p>前几篇给大家讲了有关绘图的知识，这篇我们稍微停一下，来看下手机QQ中拖动删除的效果是如何实现的；<br>这篇涉及到的知识有： </p>
<ul>
<li>saveLayer图层相关知识 </li>
<li>Path的贝赛尔曲线 </li>
<li>手势监听 </li>
<li>animationlist逐帧动画</li>
</ul>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702189494520160608193514041.gif" alt="201702189494520160608193514041.gif"></p>
<p>这里有三个效果点： </p>
<ul>
<li>拉长效果的实现 </li>
<li>拉的不够长时返回初始状态 </li>
<li>拉的够长后显示爆炸消除效果</li>
</ul>
<h4 id="一、拉伸效果实现"><a href="#一、拉伸效果实现" class="headerlink" title="一、拉伸效果实现"></a>一、拉伸效果实现</h4><h5 id="1、实现原理"><a href="#1、实现原理" class="headerlink" title="1、实现原理"></a>1、实现原理</h5><p>一上来先给大家讲本篇最难的部分，这点理解了，后面就轻松了<br>本节先实现一个圆圈的拉伸效果，效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702187186220160608193714683.gif" alt="201702187186220160608193714683.gif"></p>
<p>看起来是不是挺好玩的，跟拉弹弓一样，这里主要有两个效果组成：</p>
<ul>
<li>新加一个跟圆圈跟手指位置移动的圆</li>
<li>两个圆之间的连线填充用贝赛尔曲线</li>
</ul>
<p>拼接过程如下图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742741892833.png" alt="20170218148742741892833.png"></p>
<p>从上面的拼接图中可以看出，整个拉伸效果是由两个圆和中间的贝赛尔曲线连线所组成的矩形所组成的。<br>在贝赛尔曲线部分我们已经讲了，贝赛尔曲线关键地在于控件点的坐标如何动态的确定，我们已经说过贝赛尔曲线的控制点我们可以借助PhtotoShop的钢笔工具来找；<br>那我们就来借助钢笔工具来找一下，如下图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702182513420160608194604486.gif" alt="201702182513420160608194604486.gif"><br>我们单独拿出来最终的结果图来看一下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742749081052.png" alt="20170218148742749081052.png"><br>P0,P1是两个圆的切线的交点（切点），Q0是二阶贝赛尔曲线的控制点。从图中大概可以看出Q0的位置应该在两个圆心连线的中点。<br>在知道两个圆心点位置以后，Q0点的坐标很容易求得，但是P0,P1的坐标要怎么来求得现在的当务之急了。<br>先给大家画个图来看求下图中P0点的坐标<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742753162132.png" alt="20170218148742753162132.png"><br>这里演示的是圆形向右下拉的过程(为什么选择向右下拉为例来计算坐标我们后面会讲)，左上角的圆形是初始圆形（圆心坐标是x0,yo），右下角的圆形是拖动后的圆形（圆心坐标是x1,y1);<br>首先，在这个图中有四个切点P0,P1,P2,P3；这四个切点的坐标就是我们所要求的。我们这里以求P0为例来演示下求坐标的过程。<br>先看P0所在位置所形成的三角形，所在初始圆形的坐标是（x0,y0）<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021814874275656046.png" alt="2017021814874275656046.png"><br>我们单独把这个三角形拿出来，这里可以很明显的可以看出P0的坐标是：</p>
<pre><code>x = x0 + r * sina;
y = y0 - r * cosa;
</code></pre><p>由于屏幕坐标系是X轴向右为正，Y轴向下为正。所以P0的X坐标是比圆形x0坐标大的，所以要加上r <em> sina；而P0的Y坐标是在圆形y0坐标的上方，比y0小，所以要减去r </em> cosa;<br>用同样的方法可以求出P1,P2,P3的坐标公式:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">//P1</div><div class="line">x = x1 + r * sina;</div><div class="line">y = y1 - r * cosa;</div><div class="line"></div><div class="line">//P2</div><div class="line">x = x1 - r * sina;</div><div class="line">y = y1 + r * cosa;</div><div class="line"></div><div class="line">//P3</div><div class="line">x = x0 - r * sina;</div><div class="line">y = y0 + r * cosa;</div><div class="line">```  </div><div class="line">那么问题来了，角度a的值是多少呢？ </div><div class="line">我们再回过头来看一下我们的高清无码大图:  </div><div class="line">![20170218148742763582964.png](http://ohtrrgyyd.bkt.clouddn.com/20170218148742763582964.png)</div><div class="line">tan(a) = dy/dx;   </div><div class="line">所以a = arctan(dy/dx);   </div><div class="line">这样角度a的值就求到了，自然sina和cosa也就得到了。  </div><div class="line"></div><div class="line">##### 2、代码实现</div><div class="line">下面我们就来看一下如何用代码来实现这个手拖动的过程；</div><div class="line">&gt; 注意：这篇博客并不是要制造出来一个通用组件，而是主要为了讲解拖动消除的原理，后面我们会逐渐对这篇文章进行扩充，最终将产出一个通用控件！慢慢来吧</div><div class="line"></div><div class="line">###### （1）、新建类及初始化 </div><div class="line">由于我们这篇是讲解基本原理，所以我们新建一个类派生自FramLayout，然后在这个类中做绘图等等操作。</div><div class="line">``` java</div><div class="line">public class RedPointView extends FrameLayout &#123;</div><div class="line">    private PointF mStartPoint, mCurPoint;</div><div class="line">    private int mRadius = 20;</div><div class="line">    private Paint mPaint;</div><div class="line">    private Path mPath;</div><div class="line"></div><div class="line">    public RedPointView(Context context) &#123;</div><div class="line">        super(context);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RedPointView(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public RedPointView(Context context, AttributeSet attrs, int defStyle) &#123;</div><div class="line">        super(context, attrs, defStyle);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void initView() &#123;</div><div class="line"></div><div class="line">        mStartPoint = new PointF(100, 100);</div><div class="line">        mCurPoint = new PointF();</div><div class="line"></div><div class="line">        mPaint = new Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL);</div><div class="line"></div><div class="line">        mPath = new Path();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们新建了一个RedPointView类派生自FramLayout，然后添加了一个初始化函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    mStartPoint = <span class="keyword">new</span> PointF(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    mCurPoint = <span class="keyword">new</span> PointF();</div><div class="line"></div><div class="line">    mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    mPaint.setColor(Color.RED);</div><div class="line">    mPaint.setStyle(Paint.Style.FILL);</div><div class="line"></div><div class="line">    mPath = <span class="keyword">new</span> Path();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先是两个点坐标，分别表示两个圆的圆心位置。mStartPoint表示起始圆心位置，mCurPoint是当前手指的位置，也就是移动的圆心位置。然后是初始化Paint和Path。</p>
<h6 id="（2）、圆随着手指移动"><a href="#（2）、圆随着手指移动" class="headerlink" title="（2）、圆随着手指移动"></a>（2）、圆随着手指移动</h6><p>这部分的效果图如下：当手指移动时新画一个圆在随着手指移动<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702184308520160608195225845.gif" alt="201702184308520160608195225845.gif"><br>所以我们要先定义一个变量表示当前用户的手指是不是下按状态，如果是下按状态就根据当前手指的位置多画一个圆.<br>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">    canvas.saveLayer(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">    canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">    <span class="keyword">if</span> (mTouch) &#123;</div><div class="line">        canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">    canvas.restore();</div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">            mTouch = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">            mTouch = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mCurPoint.set(event.getX(), event.getY());</div><div class="line">    postInvalidate();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先来看看对onTouchEvent的拦截过程，在onTouchEvent中，在手指下按时将mTouch赋值为true，在手机抬起时赋值为false;<br>然后将当前手指的位置传给mCurPoint保存，然后调用postInvalidate()强制重绘；最后return true表示当前消息到此为止，就不再往父控件传了。<br>以前我们讲过postInvalidate()和invadite()的区别，这里再简单说一下：invadite()必须在主线程中调用，而postInvalidate()内部是由Handler的消息机制实现的，所以在任何线程都可以调用，但实时性没有invadite()强。所以一般为了保险起见，一般是使用postInvalidate()来刷新界面。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742799825207.png" alt="20170218148742799825207.png"></p>
<p>由于我们这里是继承自FrameLayout所以是重写dispatchDraw()函数来进行重绘<br>我们来看看dispatchDraw中实现代码，这里可谓是有难度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">    canvas.saveLayer(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">    canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">    <span class="keyword">if</span> (mTouch) &#123;</div><div class="line">        canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">    canvas.restore();</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>super.dispatchDraw(canvas)操作的位置问题。首先是super.dispatchDraw(canvas)放的位置很重要，我们有时把它写在绘图操作的最上方，有时把它写在所有绘图操作的最下方，关于这两个位置是有很大差别的，有关位置的问题，下面我们会再讲，这里放在哪里都不会有影响。</li>
<li>canvas.saveLayer()与canvas.restore()是Canvas的绘图操作</li>
<li>最后是画初始圆和移动圆的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line"><span class="keyword">if</span> (mTouch) &#123;</div><div class="line">    canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要是根据当前手指是不是在移动来判断是不是画出随手指移动的圆。代码难度不大就不再细讲了。<br>到这里，我们就实现了两个圆的显示了，最关键的部分来了——下面就是要看如何利用贝赛尔曲线把这两个圆连接起来。 </p>
<h6 id="3-、贝赛尔曲线连接两个圆"><a href="#3-、贝赛尔曲线连接两个圆" class="headerlink" title="(3)、贝赛尔曲线连接两个圆"></a>(3)、贝赛尔曲线连接两个圆</h6><p>首先，我们先看如何把路径给计算出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//圆半径</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mRadius = <span class="number">20</span>;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculatePath</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	 <span class="comment">//这里就是根据两个圆心坐标来计算出dx,dy，然后利用double a = Math.atan(dy / dx)得到夹角a的值，然后求得mRadius * Math.sin(a) 和 mRadius * Math.cos(a)的值； </span></div><div class="line">    <span class="keyword">float</span> x = mCurPoint.x;</div><div class="line">    <span class="keyword">float</span> y = mCurPoint.y;</div><div class="line">    <span class="keyword">float</span> startX = mStartPoint.x;</div><div class="line">    <span class="keyword">float</span> startY = mStartPoint.y;</div><div class="line">    <span class="comment">// 根据角度算出四边形的四个点</span></div><div class="line">    <span class="keyword">float</span> dx = x - startX;</div><div class="line">    <span class="keyword">float</span> dy = y - startY;</div><div class="line">    <span class="keyword">double</span> a = Math.atan(dy / dx);</div><div class="line">    <span class="keyword">float</span> offsetX = (<span class="keyword">float</span>) (mRadius * Math.sin(a));</div><div class="line">    <span class="keyword">float</span> offsetY = (<span class="keyword">float</span>) (mRadius * Math.cos(a));</div><div class="line"></div><div class="line">    <span class="comment">// 根据角度算出四边形的四个点</span></div><div class="line">    <span class="keyword">float</span> x1 = startX + offsetX;</div><div class="line">    <span class="keyword">float</span> y1 = startY - offsetY;</div><div class="line"></div><div class="line">    <span class="keyword">float</span> x2 = x + offsetX;</div><div class="line">    <span class="keyword">float</span> y2 = y - offsetY;</div><div class="line"></div><div class="line">    <span class="keyword">float</span> x3 = x - offsetX;</div><div class="line">    <span class="keyword">float</span> y3 = y + offsetY;</div><div class="line"></div><div class="line">    <span class="keyword">float</span> x4 = startX - offsetX;</div><div class="line">    <span class="keyword">float</span> y4 = startY + offsetY;</div><div class="line"></div><div class="line">    <span class="keyword">float</span> anchorX = (startX + x) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">float</span> anchorY = (startY + y) / <span class="number">2</span>;</div><div class="line"></div><div class="line">	 <span class="comment">//最后把这四个点连起来：</span></div><div class="line">    mPath.reset();</div><div class="line">    mPath.moveTo(x1, y1);</div><div class="line">    mPath.quadTo(anchorX, anchorY, x2, y2);</div><div class="line">    mPath.lineTo(x3, y3);</div><div class="line">    mPath.quadTo(anchorX, anchorY, x4, y4);</div><div class="line">    mPath.lineTo(x1, y1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据我们画的图中也可以知道，P0-P1，P2-P3是用贝赛尔曲线连起来的，P1-P2,P3-P0是用直线连起来的；<br>在我们得到当前的路径以后，下面就是画图的问题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">    canvas.saveLayer(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">    canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">    <span class="keyword">if</span> (mTouch) &#123;</div><div class="line">        calculatePath();</div><div class="line">        canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">    &#125;</div><div class="line">    canvas.restore();</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是添加在手指下按时，先用calculatePath()计算路径然后再利用canvas.drawPath(mPath, mPaint)把路径画出来的过程，难度不大就不再讲了。<br>到这里，我们这节开始时的效果就实现了，效果图如刚开始时所示。</p>
<p>贴出来完整代码给大家参考下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPointView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> PointF mStartPoint, mCurPoint;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRadius = <span class="number">20</span>;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Path mPath;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mTouch = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedPointView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedPointView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedPointView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        mStartPoint = <span class="keyword">new</span> PointF(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">        mCurPoint = <span class="keyword">new</span> PointF();</div><div class="line"></div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL);</div><div class="line"></div><div class="line">        mPath = <span class="keyword">new</span> Path();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculatePath</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> x = mCurPoint.x;</div><div class="line">        <span class="keyword">float</span> y = mCurPoint.y;</div><div class="line">        <span class="keyword">float</span> startX = mStartPoint.x;</div><div class="line">        <span class="keyword">float</span> startY = mStartPoint.y;</div><div class="line">        <span class="keyword">float</span> dx = x - startX;</div><div class="line">        <span class="keyword">float</span> dy = y - startY;</div><div class="line">        <span class="keyword">double</span> a = Math.atan(dy / dx);</div><div class="line">        <span class="keyword">float</span> offsetX = (<span class="keyword">float</span>) (mRadius * Math.sin(a));</div><div class="line">        <span class="keyword">float</span> offsetY = (<span class="keyword">float</span>) (mRadius * Math.cos(a));</div><div class="line"></div><div class="line">        <span class="comment">// 根据角度算出四边形的四个点</span></div><div class="line">        <span class="keyword">float</span> x1 = startX - offsetX;</div><div class="line">        <span class="keyword">float</span> y1 = startY + offsetY;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> x2 = x - offsetX;</div><div class="line">        <span class="keyword">float</span> y2 = y + offsetY;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> x3 = x + offsetX;</div><div class="line">        <span class="keyword">float</span> y3 = y - offsetY;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> x4 = startX + offsetX;</div><div class="line">        <span class="keyword">float</span> y4 = startY - offsetY;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> anchorX = (startX + x) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">float</span> anchorY = (startY + y) / <span class="number">2</span>;</div><div class="line"></div><div class="line">        mPath.reset();</div><div class="line">        mPath.moveTo(x1, y1);</div><div class="line">        mPath.quadTo(anchorX, anchorY, x2, y2);</div><div class="line">        mPath.lineTo(x3, y3);</div><div class="line">        mPath.quadTo(anchorX, anchorY, x4, y4);</div><div class="line">        mPath.lineTo(x1, y1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">        canvas.saveLayer(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">        canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">        <span class="keyword">if</span> (mTouch) &#123;</div><div class="line">            calculatePath();</div><div class="line">            canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line">            canvas.drawPath(mPath, mPaint);</div><div class="line">        &#125;</div><div class="line">        canvas.restore();</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                mTouch = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">                mTouch = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mCurPoint.set(event.getX(), event.getY());</div><div class="line">        postInvalidate();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="3、疑问：当手指拖动位置不同时，也能统一处理求得各个点坐标？"><a href="#3、疑问：当手指拖动位置不同时，也能统一处理求得各个点坐标？" class="headerlink" title="3、疑问：当手指拖动位置不同时，也能统一处理求得各个点坐标？"></a>3、疑问：当手指拖动位置不同时，也能统一处理求得各个点坐标？</h5><p>细心的同学可能会发现，同样是P0,P1,P2,P3四个切点，当移动圆的位置变化时，四个点的计算公式是会变化的，我们同样以P0点为例来看下<br>当手指移动点在右下方时的公式为<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742833291808.png" alt="20170218148742833291808.png"></p>
<pre><code>x = x0 + r * sina;
y = y0 - r * cosa;
</code></pre><p>那么当手指移动点在左上方时，它的公式又为：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742853530753.png" alt="20170218148742853530753.png"><br>在变为左上方时，P0点的X坐标就跑到了原点(x0,y0)的左侧，从图像中不难看出P0点的坐标为：</p>
<pre><code>x = x0 - r * sina;
y = y0 - r * cosa;
</code></pre><p>但是我们在计算时全部都是使用x = x0 + r * sina;这个公式来计算的，明明在这种情况下使用同一个公式是有问题的，但出来的效果为什么却是正确的呢？<br>这是因为Math的三角函数取值是有正有负的，当Math.atan(double value)的入参value是负值是，它对应的输出的角度值也是负值，同样，Math.sin(double a) 的输出值也是负值<br>所在因为在手指移动点在左上角时，dx正值，dy却是负值，所以利用a =Math.atan(dy/dx)求得的角度a是负值，进而sina和cos都是负值<br>这里其实是用到了正弦函数和余弦函数的几个性质：</p>
<pre><code>sin(-a) = - sina;
cos(-a) = cosa;
sin(π/2-α) = cosα
cos(π/2-α) = sinα
</code></pre><p>所以当a值为负值时：</p>
<pre><code>x = x0 + r * sin（-a）;
y = y0 - r * cosa;
</code></pre><p>也就变成了下面的公式了：</p>
<pre><code>x = x0 - r * sina;
y = y0 - r * cosa;
</code></pre><p>这也是我们为什么用同一个公式能解决所有情况的原因所在！<br>但我们在得到这个公式时，必须在保证dx,dy都为正值的情况下，因为此时夹角a必然是正值，不存在数学换算的问题；不然如果dx,dy中任意一个为负数时，夹角a也将是负值，此时你将算得头大……</p>
<h4 id="二、自定义文字与爆炸效果"><a href="#二、自定义文字与爆炸效果" class="headerlink" title="二、自定义文字与爆炸效果"></a>二、自定义文字与爆炸效果</h4><p>上面把最难的拉伸效果实现以后，下面就要完整的来实现开篇的功能了，再来看下最终的效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218652220160608200510256.gif" alt="20170218652220160608200510256.gif"><br>除了拉伸效果以后，还有一个TextView用来设置文字，另外在超出定长以后消失时会有爆炸效果<br>我们先来实现添加TextView，然后再添加爆炸效果.</p>
<h5 id="1、添加TextView"><a href="#1、添加TextView" class="headerlink" title="1、添加TextView"></a>1、添加TextView</h5><p>我们添加TextVIew后所实现的功能的效果图为：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702184987720160608200638522.gif" alt="201702184987720160608200638522.gif"><br>添加TextView后需要添加三个功能： </p>
<ul>
<li>初始只显示TextView，而不显示原来的圆圈 </li>
<li>点击TextView所在区域才能移动TextVIew </li>
<li>移动时，TextView跟随手指移动，同时显示原TextVIew所在的圆圈和贝赛尔连接线 </li>
</ul>
<p>本着上面几个功能点，我们一步步来实现</p>
<h6 id="（1）、添加并初始化TextView"><a href="#（1）、添加并初始化TextView" class="headerlink" title="（1）、添加并初始化TextView"></a>（1）、添加并初始化TextView</h6><p>首先，我们要在初始化的时候原布局中添加一个TextView控件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> TextView mTipTextView;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</div><div class="line">    mStartPoint = <span class="keyword">new</span> PointF(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    mCurPoint = <span class="keyword">new</span> PointF();</div><div class="line"></div><div class="line">    mPath = <span class="keyword">new</span> Path();</div><div class="line"></div><div class="line">    mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    mPaint.setColor(Color.RED);</div><div class="line">    mPaint.setStyle(Paint.Style.FILL);</div><div class="line"></div><div class="line">    LayoutParams params = <span class="keyword">new</span> LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">    mTipTextView = <span class="keyword">new</span> TextView(getContext());</div><div class="line">    mTipTextView.setLayoutParams(params);</div><div class="line">    mTipTextView.setPadding(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line">    mTipTextView.setBackgroundResource(R.drawable.tv_bg);</div><div class="line">    mTipTextView.setTextColor(Color.GREEN);</div><div class="line">    mTipTextView.setText(<span class="string">"99+"</span>);</div><div class="line">    addView(mTipTextView);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码难度不大，就是在原来初始化的基础上向ViewGroup中添加一个TextVIew控件，并做一些基本的设置。我们这里把TextView的一些设置都写死在类内部了，这样是为了讲解方便，但如果要集成为公用控件，当然要把这些设置文字内容和颜色暴露给外部，最简单的方法就向外部暴露一个getTextView()的方法，把当前TextView的对象直接返回给外部，让它直接可以设置TextView；<br>上面的代码中有一个设置TextView背景的代码： mTipTextView.setBackgroundResource(R.drawable.tv_bg)，对应的xml文件为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"10dp"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#ff0000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">stroke</span> <span class="attr">android:color</span>=<span class="string">"#0f000000"</span> <span class="attr">android:width</span>=<span class="string">"1dp"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>就是给TextView添加带有圆角的红色背景，另外还加了个不怎么黑的描边。</p>
<h6 id="（2）、点击TextView时才允许拖动"><a href="#（2）、点击TextView时才允许拖动" class="headerlink" title="（2）、点击TextView时才允许拖动"></a>（2）、点击TextView时才允许拖动</h6><p>我们需要在用户点击区域在TextView内部时才允许拖动TextView：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">            <span class="comment">// 判断触摸点是否在tipImageView中</span></div><div class="line">            <span class="comment">//拿到当前TextView所在屏幕的位置矩形 </span></div><div class="line">            Rect rect = <span class="keyword">new</span> Rect();</div><div class="line">            <span class="keyword">int</span>[] location = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">            mTipTextView.getLocationOnScreen(location);</div><div class="line">            rect.left = location[<span class="number">0</span>];</div><div class="line">            rect.top = location[<span class="number">1</span>];</div><div class="line">            rect.right = mTipTextView.getWidth() + location[<span class="number">0</span>];</div><div class="line">            rect.bottom = mTipTextView.getHeight() + location[<span class="number">1</span>];</div><div class="line">            <span class="comment">//然后就是判断当前手指所在位置是不是在这个矩形内了：</span></div><div class="line">            <span class="keyword">if</span> (rect.contains((<span class="keyword">int</span>) event.getRawX(), (<span class="keyword">int</span>) event.getRawY())) &#123;</div><div class="line">                mTouch = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">            <span class="comment">//抬起手指时还原位置</span></div><div class="line">            mTouch = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    mCurPoint.set(event.getX(), event.getY());</div><div class="line">    postInvalidate();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要是在MotionEvent.ACTION_DOWN的时候，判断当前当前手指区域是否在TextView内部，如果是就将mTouch赋值为true；<br>这里涉及的一个函数还没的一直没有提及这里给大家讲一下：</p>
<pre><code>public void getLocationOnScreen(int[] location)
</code></pre><p>该函数的功能是获取当前控件所在屏幕的位置，传进去一个location的数组，在执行以后会把left,top值赋给location[0]和location[1].<br>这里最主要注意的是，我们前面讲了getLocationOnScreen()函数得到的位置是屏幕坐标，所以我们也必须拿到手指的屏幕坐标，所以event.getRawX()得到的就是相对屏幕的坐标<br>以前在博客中也讲到过getX与getRawX的区别：getX()得到是相对当前控件左上角的坐标，而getRawX是得到在屏幕中的坐标，在第三部曲中会单独开一篇来讲解有关坐标的知识，大家这里先知道这两个函数的用法就好了，第三部曲中会深入地讲解。 </p>
<h6 id="（3）、绘图"><a href="#（3）、绘图" class="headerlink" title="（3）、绘图"></a>（3）、绘图</h6><p>在绘图部分，我们需要完成两个功能：当用户没点击时将TextView设置为原来的位置，当用户点击时一方面TextView要跟着手指移动，另一方面要画出初始圆形<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    canvas.saveLayer(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">    <span class="keyword">if</span> (mTouch) &#123;</div><div class="line">        calculatePath();</div><div class="line">        canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">        canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line">        canvas.drawPath(mPath, mPaint);<span class="comment">//将textview的中心放在当前手指位置</span></div><div class="line">        <span class="comment">//先看用户没有点击时，把TextView设置在初始的位置点</span></div><div class="line">        mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    canvas.restore();</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>画出初始的圆形，手指处的圆形，和两个圆之间的贝赛尔曲线连接矩形；最后把TextView盖在手指处的圆形上即可。代码难度不大就不再细讲了。 </p>
<h6 id="4-、拉伸时把圆半径缩小"><a href="#4-、拉伸时把圆半径缩小" class="headerlink" title="(4)、拉伸时把圆半径缩小"></a>(4)、拉伸时把圆半径缩小</h6><p>正常情况下，随着拉伸长度的增大，两个圆的半径是应该逐步就小的；这样才更符合力学原理是吧，效果图如下： </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702181548920160608200722976.gif" alt="201702181548920160608200722976.gif"></p>
<p>这个功能非常简单，只需要在拉伸时，跟根据用户的拉伸长度，动态的设置当前所画圆的半径即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">float</span> DEFAULT_RADIUS = <span class="number">20</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">float</span> mRadius = DEFAULT_RADIUS;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculatePath</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">float</span> x = mCurPoint.x;</div><div class="line">    <span class="keyword">float</span> y = mCurPoint.y;</div><div class="line">    <span class="keyword">float</span> startX = mStartPoint.x;</div><div class="line">    <span class="keyword">float</span> startY = mStartPoint.y;</div><div class="line">    <span class="keyword">float</span> dx = x - startX;</div><div class="line">    <span class="keyword">float</span> dy = y - startY;</div><div class="line">    <span class="keyword">double</span> a = Math.atan(dy / dx);</div><div class="line">    <span class="keyword">float</span> offsetX = (<span class="keyword">float</span>) (mRadius * Math.sin(a));</div><div class="line">    <span class="keyword">float</span> offsetY = (<span class="keyword">float</span>) (mRadius * Math.cos(a));</div><div class="line"></div><div class="line">    <span class="keyword">float</span> distance = (<span class="keyword">float</span>) Math.sqrt(Math.pow(y-startY, <span class="number">2</span>) + Math.pow(x-startX, <span class="number">2</span>));</div><div class="line">    mRadius = DEFAULT_RADIUS - distance/<span class="number">15</span>;</div><div class="line">    <span class="keyword">if</span>(mRadius&lt;<span class="number">9</span>)&#123;</div><div class="line">        mRadius = <span class="number">9</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 根据角度算出四边形的四个点</span></div><div class="line">    …………</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里代码很简单，就是根据勾股定理（a^2+b^2=c^2）求出两个圆心之间当前距离，然后按照一定的规则计算出当前的圆半径，我这里定的规则就是DEFAULT_RADIUS-distance/15；<br>但不要一直小到0，因为我们中间的连接线是两个相同半径的圆的切线来计算出来的，所以当圆心半径变小时，两个圆之间的连接矩形也在变小，所以小到一定程度后，就不能再小了，我这里这个临界值定为9.</p>
<h6 id="5-、答疑：super-dispatchDraw-canvas-的位置问题"><a href="#5-、答疑：super-dispatchDraw-canvas-的位置问题" class="headerlink" title="(5)、答疑：super.dispatchDraw(canvas)的位置问题"></a>(5)、答疑：super.dispatchDraw(canvas)的位置问题</h6><p>这里大家可能会有个疑问，为什么super.dispatchDraw(canvas)的位置有时候会直接写在dispatchDraw的下面呢？比如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">    …………<span class="comment">//其它绘图操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候又这么写：先做绘图操作再写super.dispatchDraw(canvas)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span></span>&#123;</div><div class="line">    …………<span class="comment">//其它绘图操作</span></div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个到底有什么差别呢？至于到底有什么差别，我们得先来看一下super.dispatchDraw(canvas);的作用是什么；<br>super.dispatchDraw(canvas);的作用是绘出该控件的所有子控件，所以这样结论就很明显了，如果是像第一个那样先做super.dispatchDraw(canvas);再做其它绘图操作的结果是，先把子控件绘制出来，然后再画自己，这样可能会造成自己把子控件给覆盖上；<br>相反，先做其它绘图操作然后再调用super.dispatchDraw(canvas)的结果是：先把自己给画出来，然后再画子控件，子控件会把自己的绘图结果给覆盖上；<br>所以，我们回过头来看看我们在上面的例子中的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">    canvas.saveLayer(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">    <span class="keyword">if</span> (mTouch) &#123;</div><div class="line">        calculatePath();</div><div class="line">        canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">        canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line">        canvas.drawPath(mPath, mPaint);<span class="comment">//将textview的中心放在当前手指位置</span></div><div class="line">        mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    canvas.restore();</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这段代码中，我们是先绘制自己，然后再绘制它的子控件（TextView）,这样的结果就是TextView会把当前的绘图内容覆盖上，如果我把绘图画笔改成绿色，就会很明显，我们来看下效果：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702182577120160608200752266.gif" alt="201702182577120160608200752266.gif"></p>
<p>然后我们再反过来看一下，如果我们先做super.dispatchDraw(canvas);然后再做自己的绘图操作，看下效果是怎么样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">    canvas.saveLayer(<span class="keyword">new</span> RectF(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">    <span class="keyword">if</span> (mTouch) &#123;</div><div class="line">        calculatePath();</div><div class="line">        canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">        canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line">        canvas.drawPath(mPath, mPaint);<span class="comment">//将textview的中心放在当前手指位置</span></div><div class="line">        mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    canvas.restore();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702184796420160608200822361.gif" alt="201702184796420160608200822361.gif"><br>很明显，后来的绘图操作把子控件给盖住了，这就是 super.dispatchDraw(canvas)在不同位置的区别！</p>
<h5 id="2、爆炸效果"><a href="#2、爆炸效果" class="headerlink" title="2、爆炸效果"></a>2、爆炸效果</h5><p>这里我们就差最后一个效果了：当用户手指拉到一定长度松手后，将出来爆炸效果，效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218896920160608200907257.gif" alt="20170218896920160608200907257.gif"></p>
<h6 id="（1）、定义逐帧动画"><a href="#（1）、定义逐帧动画" class="headerlink" title="（1）、定义逐帧动画"></a>（1）、定义逐帧动画</h6><p>首先，我们定义一个爆炸效果的动画（这些图片资源都是从手机QQ的apk里解压出来的，嘿嘿）<br>图片资源如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148742952616764.png" alt="20170218148742952616764.png"><br>先添加个逐帧动画，对应的代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">animation-list</span></span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">android:oneshot</span>=<span class="string">"true"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/idp"</span> <span class="attr">android:duration</span>=<span class="string">"300"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/idq"</span> <span class="attr">android:duration</span>=<span class="string">"300"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/idr"</span> <span class="attr">android:duration</span>=<span class="string">"300"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/ids"</span> <span class="attr">android:duration</span>=<span class="string">"300"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/idt"</span> <span class="attr">android:duration</span>=<span class="string">"300"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:color/transparent"</span> <span class="attr">android:duration</span>=<span class="string">"300"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h6 id="（2）、添加ImageView"><a href="#（2）、添加ImageView" class="headerlink" title="（2）、添加ImageView"></a>（2）、添加ImageView</h6><p>我们需要添加一个ImageView控件来单独来播放这个逐帧动画：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> ImageView exploredImageView;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</div><div class="line">    mStartPoint = <span class="keyword">new</span> PointF(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    mCurPoint = <span class="keyword">new</span> PointF();</div><div class="line"></div><div class="line">    mPath = <span class="keyword">new</span> Path();</div><div class="line"></div><div class="line">    mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    mPaint.setColor(Color.RED);</div><div class="line">    mPaint.setStyle(Paint.Style.FILL);</div><div class="line"></div><div class="line">    LayoutParams params = <span class="keyword">new</span> LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">    mTipTextView = <span class="keyword">new</span> TextView(getContext());</div><div class="line">    mTipTextView.setLayoutParams(params);</div><div class="line">    mTipTextView.setPadding(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line">    mTipTextView.setBackgroundResource(R.drawable.tv_bg);</div><div class="line">    mTipTextView.setTextColor(Color.WHITE);</div><div class="line">    mTipTextView.setText(<span class="string">"99+"</span>);</div><div class="line"></div><div class="line"></div><div class="line">    exploredImageView = <span class="keyword">new</span> ImageView(getContext());</div><div class="line">    exploredImageView.setLayoutParams(params);</div><div class="line">    exploredImageView.setImageResource(R.drawable.tip_anim);</div><div class="line">    exploredImageView.setVisibility(View.INVISIBLE);</div><div class="line"></div><div class="line">    addView(mTipTextView);</div><div class="line">    addView(exploredImageView);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="（3）、定值爆炸"><a href="#（3）、定值爆炸" class="headerlink" title="（3）、定值爆炸"></a>（3）、定值爆炸</h6><p>在绘图的时候，我们就要开启爆炸效果了，上面我们在半径小于9的时候，一直给它赋值9，现在我们当它小于9时，让它爆炸：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculatePath</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">float</span> x = mCurPoint.x;</div><div class="line">    <span class="keyword">float</span> y = mCurPoint.y;</div><div class="line">    <span class="keyword">float</span> startX = mStartPoint.x;</div><div class="line">    <span class="keyword">float</span> startY = mStartPoint.y;</div><div class="line">    <span class="keyword">float</span> dx = x - startX;</div><div class="line">    <span class="keyword">float</span> dy = y - startY;</div><div class="line">    <span class="keyword">double</span> a = Math.atan(dy / dx);</div><div class="line">    <span class="keyword">float</span> offsetX = (<span class="keyword">float</span>) (mRadius * Math.sin(a));</div><div class="line">    <span class="keyword">float</span> offsetY = (<span class="keyword">float</span>) (mRadius * Math.cos(a));</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">float</span> distance = (<span class="keyword">float</span>) Math.sqrt(Math.pow(y-startY, <span class="number">2</span>) + Math.pow(x-startX, <span class="number">2</span>));</div><div class="line">    mRadius = -distance/<span class="number">15</span>+DEFAULT_RADIUS;</div><div class="line">    <span class="keyword">if</span>(mRadius &lt; <span class="number">9</span>)&#123;</div><div class="line">        isAnimStart = <span class="keyword">true</span>;</div><div class="line">        exploredImageView.setX(mCurPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        exploredImageView.setY(mCurPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">        exploredImageView.setVisibility(View.VISIBLE);</div><div class="line">        ((AnimationDrawable) exploredImageView.getDrawable()).start();</div><div class="line"></div><div class="line">        mTipTextView.setVisibility(View.GONE);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//根据角度算出四边形的四个点</span></div><div class="line">    …………</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当半径小于9时，开始爆炸效果，然后声明一个变量isAnimStart来标识当前爆炸效果开始了；因为当爆炸效果开始以后，后面的绘图操作就不能再画圆和贝赛尔曲线了，应该清空当前画布，只显示ImageVIew的动画效果<br>然后利用setX和setY函数将当前ImageVIew的位置移动到手指的位置，最后是显示ImageView并开始动画；<br>最后是绘图操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">    canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!mTouch || isAnimStart) &#123;</div><div class="line">        mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        calculatePath();</div><div class="line">        canvas.drawPath(mPath, mPaint);</div><div class="line">        canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">        canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line"></div><div class="line">        <span class="comment">//将textview的中心放在当前手指位置</span></div><div class="line">        mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">        mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    canvas.restore();</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的绘图操作加上了isAnimStart变量的判断，当动画开始或者手指没在按的时候只显示TextView，之外的其它操作肯定是用户在点按TextView，此时需要画出拉伸效果。<br>最后，把整体控件的源码贴给大家，可以自己对照下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPointControlVIew</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> PointF mStartPoint, mCurPoint;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> DEFAULT_RADIUS = <span class="number">20</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mRadius = DEFAULT_RADIUS;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Path mPath;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mTouch = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isAnimStart = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">private</span> TextView mTipTextView;</div><div class="line">    <span class="keyword">private</span> ImageView exploredImageView;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedPointControlVIew</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedPointControlVIew</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedPointControlVIew</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        initView();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</div><div class="line">        mStartPoint = <span class="keyword">new</span> PointF(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">        mCurPoint = <span class="keyword">new</span> PointF();</div><div class="line"></div><div class="line">        mPath = <span class="keyword">new</span> Path();</div><div class="line"></div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setStyle(Paint.Style.FILL);</div><div class="line"></div><div class="line">        LayoutParams params = <span class="keyword">new</span> LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</div><div class="line">        mTipTextView = <span class="keyword">new</span> TextView(getContext());</div><div class="line">        mTipTextView.setLayoutParams(params);</div><div class="line">        mTipTextView.setPadding(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</div><div class="line">        mTipTextView.setBackgroundResource(R.drawable.tv_bg);</div><div class="line">        mTipTextView.setTextColor(Color.WHITE);</div><div class="line">        mTipTextView.setText(<span class="string">"99+"</span>);</div><div class="line"></div><div class="line"></div><div class="line">        exploredImageView = <span class="keyword">new</span> ImageView(getContext());</div><div class="line">        exploredImageView.setLayoutParams(params);</div><div class="line">        exploredImageView.setImageResource(R.drawable.tip_anim);</div><div class="line">        exploredImageView.setVisibility(View.INVISIBLE);</div><div class="line"></div><div class="line">        addView(mTipTextView);</div><div class="line">        addView(exploredImageView);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculatePath</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">float</span> x = mCurPoint.x;</div><div class="line">        <span class="keyword">float</span> y = mCurPoint.y;</div><div class="line">        <span class="keyword">float</span> startX = mStartPoint.x;</div><div class="line">        <span class="keyword">float</span> startY = mStartPoint.y;</div><div class="line">        <span class="keyword">float</span> dx = x - startX;</div><div class="line">        <span class="keyword">float</span> dy = y - startY;</div><div class="line">        <span class="keyword">double</span> a = Math.atan(dy / dx);</div><div class="line">        <span class="keyword">float</span> offsetX = (<span class="keyword">float</span>) (mRadius * Math.sin(a));</div><div class="line">        <span class="keyword">float</span> offsetY = (<span class="keyword">float</span>) (mRadius * Math.cos(a));</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">float</span> distance = (<span class="keyword">float</span>) Math.sqrt(Math.pow(y-startY, <span class="number">2</span>) + Math.pow(x-startX, <span class="number">2</span>));</div><div class="line">        mRadius = -distance/<span class="number">15</span>+DEFAULT_RADIUS;</div><div class="line">        <span class="keyword">if</span>(mRadius &lt; <span class="number">9</span>)&#123;</div><div class="line">            isAnimStart = <span class="keyword">true</span>;</div><div class="line">            exploredImageView.setX(mCurPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">            exploredImageView.setY(mCurPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">            exploredImageView.setVisibility(View.VISIBLE);</div><div class="line">            ((AnimationDrawable) exploredImageView.getDrawable()).start();</div><div class="line"></div><div class="line">            mTipTextView.setVisibility(View.GONE);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 根据角度算出四边形的四个点</span></div><div class="line">        <span class="keyword">float</span> x1 = startX + offsetX;</div><div class="line">        <span class="keyword">float</span> y1 = startY - offsetY;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> x2 = x + offsetX;</div><div class="line">        <span class="keyword">float</span> y2 = y - offsetY;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> x3 = x - offsetX;</div><div class="line">        <span class="keyword">float</span> y3 = y + offsetY;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> x4 = startX - offsetX;</div><div class="line">        <span class="keyword">float</span> y4 = startY + offsetY;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> anchorX = (startX + x) / <span class="number">2</span>;</div><div class="line">        <span class="keyword">float</span> anchorY = (startY + y) / <span class="number">2</span>;</div><div class="line"></div><div class="line">        mPath.reset();</div><div class="line">        mPath.moveTo(x1, y1);</div><div class="line">        mPath.quadTo(anchorX, anchorY, x2, y2);</div><div class="line">        mPath.lineTo(x3, y3);</div><div class="line">        mPath.quadTo(anchorX, anchorY, x4, y4);</div><div class="line">        mPath.lineTo(x1, y1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * onDraw:为什么要行绘制自己的,然后再调用super.onDraw</div><div class="line">     * <span class="doctag">@param</span> canvas</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">        canvas.saveLayer(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!mTouch || isAnimStart) &#123;</div><div class="line">            mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">            mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            calculatePath();</div><div class="line">            canvas.drawPath(mPath, mPaint);</div><div class="line">            canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);</div><div class="line">            canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);</div><div class="line"></div><div class="line">            <span class="comment">//将textview的中心放在当前手指位置</span></div><div class="line">            mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / <span class="number">2</span>);</div><div class="line">            mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / <span class="number">2</span>);</div><div class="line">        &#125;</div><div class="line">        canvas.restore();</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.dispatchDraw(canvas);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</div><div class="line">                <span class="comment">// 判断触摸点是否在tipImageView中</span></div><div class="line">                Rect rect = <span class="keyword">new</span> Rect();</div><div class="line">                <span class="keyword">int</span>[] location = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">                mTipTextView.getLocationOnScreen(location);</div><div class="line">                rect.left = location[<span class="number">0</span>];</div><div class="line">                rect.top = location[<span class="number">1</span>];</div><div class="line">                rect.right = mTipTextView.getWidth() + location[<span class="number">0</span>];</div><div class="line">                rect.bottom = mTipTextView.getHeight() + location[<span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span> (rect.contains((<span class="keyword">int</span>) event.getRawX(), (<span class="keyword">int</span>) event.getRawY())) &#123;</div><div class="line">                    mTouch = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</div><div class="line">                <span class="comment">//抬起手指时还原位置</span></div><div class="line">                mTouch = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        postInvalidate();</div><div class="line">        mCurPoint.set(event.getX(), event.getY());</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，这篇文章就到这了，通过这篇文章，简单复习了下前面学到的动画和绘图的知识，后面我们会这个控件进行扩充，逐步把它封装成共用的控件。 </p>
<h3 id="二、给控件添加阴影效果与发光效果"><a href="#二、给控件添加阴影效果与发光效果" class="headerlink" title="二、给控件添加阴影效果与发光效果"></a>二、给控件添加阴影效果与发光效果</h3><p>这节我们将学到如下内容：</p>
<ul>
<li>传统地给按钮添加阴影的方法</li>
<li>如何给已有控件添加阴影</li>
<li>如何给图片添加阴影</li>
</ul>
<h4 id="一、layerlist给按钮添加阴影效果"><a href="#一、layerlist给按钮添加阴影效果" class="headerlink" title="一、layerlist给按钮添加阴影效果"></a>一、layerlist给按钮添加阴影效果</h4><p>给控件添加阴影有很多方法，但平常我们给按钮添加阴影最常用的就是使用layerlist多层绘图来添加阴影效果，我们先来看一下给按钮添加的阴影效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148743109011232.png" alt="20170218148743109011232.png"></p>
<p>从效果图中可以明显看出，按钮的外围多了一圈灰色的阴影效果。<br>在开始做阴影效果之前，我们先讲解一下有关layerlist的知识。<br>在xml中，我们有常用的几个标签：shape、selector、layerlist; </p>
<ul>
<li>shape标签：以前我们讲过,就是利用代码绘制出背景效果，可以定义填充色、描边、圆角、渐变等。不了解的同学可以参考下：<a href="http://blog.csdn.net/harvic880925/article/details/41850723" target="_blank" rel="external">《详解shape标签》</a></li>
<li>selector标签：用于定义在用户不同的动作状态下，使用不同的背景值。有关selector的知识，博主没有讲过，也不打算再讲了，难度不大，自己搜几个帖子就能学会了。</li>
<li>layerlist标签：这个标签的主要作用就是将多个图层按照顺序叠起来，做为一个背景图来显示。</li>
</ul>
<h5 id="1、layerlist示例："><a href="#1、layerlist示例：" class="headerlink" title="1、layerlist示例："></a>1、layerlist示例：</h5><p>layerlist标签就是模拟Photoshop中图层的概念，把每一张图层按照顺序叠加起来，做为背景图来显示；<br>我们先来看一下简单的例子，我们要显示一下两只蜗牛的图片：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148743121047852.png" alt="20170218148743121047852.png"><br>它由三张图片组成：<br>一张纯蓝色的背景：(blog1_1.png)<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148743122939228.png" alt="20170218148743122939228.png"><br>一只黄蜗牛：(blog1_2.png)<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148743125075959.png" alt="20170218148743125075959.png"><br>一只土色蜗牛：(blog1_3.png)<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148743126918158.png" alt="20170218148743126918158.png"><br>我们先定义一个layerlist的文件（shade.xml）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/blog1_1"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/blog1_2"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@drawable/blog1_3"</span>/&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里分别将上面的三张图片做为item添加给layer-list；效果图就是一开始演示的那样。layer-list使用起来很简单，只需要把每一层设置为其中的item即可。<br>有一点需要注意，layer-list标签的Item中不仅可以设置drawable，也可以设置shape、selector，我们下面一一做下尝试。</p>
<h5 id="2、layer-list与shape标签"><a href="#2、layer-list与shape标签" class="headerlink" title="2、layer-list与shape标签"></a>2、layer-list与shape标签</h5><p><strong>编写控件阴影drawable代码</strong><br>上面我们使用使用的是layer-list中item的drawable属性来直接引入图片，其实除了drawable属性，item还有另外几个属性：</p>
<ul>
<li>android:top 顶部的偏移量</li>
<li>android:bottom 底部的偏移量</li>
<li>android:left 左边的偏移量</li>
<li>android:right 右边的偏移量<br>这四个偏移量和控件的margin设置差不多，都是外间距的效果。如果不设置偏移量，前面的图层就完全挡住了后面的图层，从而也看不到后面的图层效果了。<br>言归正转，先来看看如何在layer-list中使用shape标签：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#E4E4E4"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:left</span>=<span class="string">"2dp"</span> <span class="attr">android:top</span>=<span class="string">"2dp"</span>  </span></div><div class="line">          <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> <span class="attr">android:right</span>=<span class="string">"2dp"</span>&gt;  </div><div class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的代码实现的效果是这样的：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148743140235313.png" alt="20170218148743140235313.png"><br>大家看到类似阴影的效果了吧，不错，这段代码就是实现按钮阴影的代码，我们来仔细看一下<br>首先，它使用layer-list将两层shape叠加在一起，底部的shape代码为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#E4E4E4"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>底部是一个灰色的矩形，它的四个角被圆角化，并且填充为灰色。<br>上层绘制的shape对应的代码为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:left</span>=<span class="string">"2dp"</span> <span class="attr">android:top</span>=<span class="string">"2dp"</span>  </span></div><div class="line">      <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> <span class="attr">android:right</span>=<span class="string">"2dp"</span>&gt;  </div><div class="line">    <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>它同样绘制的是一个四个角都被圆角化的矩形，但填充颜色是纯白色。为了露出底层的灰色阴影，我们需要给上层的shape加上边距，这也就是item的 android:left=”2dp” android:top=”2dp” android:bottom=”2dp” android:right=”2dp”这四个属性的作用，相当于margin的作用。   </p>
<p><strong>使用阴影drawable</strong><br>在写好layer-list以后，我们需要在按钮控件中使用它：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Button</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:padding</span>=<span class="string">"10dp"</span>  </div><div class="line">        <span class="attr">android:layout_margin</span>=<span class="string">"10dp"</span>  </div><div class="line">        <span class="attr">android:background</span>=<span class="string">"@drawable/layer_shape_list"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"带阴影的按钮"</span>  </div><div class="line">        <span class="attr">android:textColor</span>=<span class="string">"#ff0000"</span>/&gt;</div><div class="line">```  </div><div class="line">我们来看下效果：</div><div class="line">![201702182509320160704092043807.gif](http://ohtrrgyyd.bkt.clouddn.com/201702182509320160704092043807.gif)  </div><div class="line">从效果图中可以看到，我们虽然实现了带阴影的按钮效果，但是在点击时却没有任何状态变化，这对于按钮是完全不能接受的，所以我们需要给按钮添加上状态变化，这就需要用到selector标签了</div><div class="line"></div><div class="line">##### 3、layer-list与selector标签</div><div class="line">**改造方法一：使用layer-list做根结点**  </div><div class="line">下面我们对上面shape的代码进行改造，当用户手指按下的时候，将前景色改为黄色，代码为：</div><div class="line">``` xml</div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#E4E4E4"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:left</span>=<span class="string">"2dp"</span> <span class="attr">android:top</span>=<span class="string">"2dp"</span>  </span></div><div class="line">          <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> <span class="attr">android:right</span>=<span class="string">"2dp"</span>&gt;  </div><div class="line">        <span class="tag">&lt;<span class="name">selector</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFF00"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">selector</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们先来看一下效果，然后再来看代码<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702188115020160704092733132.gif" alt="201702188115020160704092733132.gif"><br>这里明显实现了当用户点击时前景变化的功能。下面我们再来讲解下代码<br>首先，这里同样是绘制两层layer，第一层，依然是阴影层，代码没动：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#E4E4E4"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在第一层绘制完成以后，当绘制第二层时就出现问题了：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:left</span>=<span class="string">"2dp"</span> <span class="attr">android:top</span>=<span class="string">"2dp"</span>  </span></div><div class="line">      <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> <span class="attr">android:right</span>=<span class="string">"2dp"</span>&gt;  </div><div class="line">    <span class="tag">&lt;<span class="name">selector</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFF00"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">selector</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>第二层中，会对当前用户状态做判断，如果用户当前是按下状态，则绘制：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFF00"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果是其它状态，则绘制默认图像：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>所以对于layer-list标签，从这里也可以看出来：它的绘制是逐层绘制的，层与层之间是没有任何影响的，每一层可以单独设置selector标签来响应不同的用户操作状态。<br><strong>改造方法二：使用selector做根结点</strong><br>上面我们使用layer-list来做根结点来绘制出按钮的不同状态响应的效果，对selector、layer-list使用熟悉的同学，应该还可以想到另一种实现方式，使用selector做为根结点来实现响应不同用户操作。<br>我们先直接上代码吧：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">selector</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">layer-list</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#E4E4E4"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:left</span>=<span class="string">"2dp"</span> <span class="attr">android:top</span>=<span class="string">"2dp"</span>  </span></div><div class="line">                  <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> <span class="attr">android:right</span>=<span class="string">"2dp"</span>&gt;  </div><div class="line">                <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFF00"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">  </div><div class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">layer-list</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#E4E4E4"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:left</span>=<span class="string">"2dp"</span> <span class="attr">android:top</span>=<span class="string">"2dp"</span>  </span></div><div class="line">                  <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> <span class="attr">android:right</span>=<span class="string">"2dp"</span>&gt;  </div><div class="line">                <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">  </div><div class="line"><span class="tag">&lt;/<span class="name">selector</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>同样我们先来看一下使用代码与效果，然后再来讲解实现原理：<br>使用方法，同样是做为background引入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Button</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:padding</span>=<span class="string">"10dp"</span>  </div><div class="line">        <span class="attr">android:layout_margin</span>=<span class="string">"10dp"</span>  </div><div class="line">        <span class="attr">android:background</span>=<span class="string">"@drawable/selector_layer_list"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"Selector为根的按钮"</span>  </div><div class="line">        <span class="attr">android:textColor</span>=<span class="string">"#ff0000"</span>/&gt;</div></pre></td></tr></table></figure>
<p>效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702183859120160704093008765.gif" alt="201702183859120160704093008765.gif"><br>很明显，实现了与上面layer-list标签为根同样的效果，我们现在来看一下代码原理：<br>代码看起来很长，很唬人，其实原理很简单，它就是根据当前不同的状态，绘制不同的图形，当用户是按压状态时，通过layer-list绘制出一下最上层是黄色，底层是灰色的按钮背景图像：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">android:state_pressed</span>=<span class="string">"true"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">layer-list</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#E4E4E4"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:left</span>=<span class="string">"2dp"</span> <span class="attr">android:top</span>=<span class="string">"2dp"</span>  </span></div><div class="line">              <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> <span class="attr">android:right</span>=<span class="string">"2dp"</span>&gt;  </div><div class="line">            <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFF00"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在其它状态时，绘制一个前景色是白色，背景色是灰色的按钮背景图：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">layer-list</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#E4E4E4"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:left</span>=<span class="string">"2dp"</span> <span class="attr">android:top</span>=<span class="string">"2dp"</span>  </span></div><div class="line">              <span class="attr">android:bottom</span>=<span class="string">"2dp"</span> <span class="attr">android:right</span>=<span class="string">"2dp"</span>&gt;  </div><div class="line">            <span class="tag">&lt;<span class="name">shape</span>&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">"25dp"</span>/&gt;</span>  </div><div class="line">                <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">"#FFFFFF"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;/<span class="name">shape</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;/<span class="name">item</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">item</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h5 id="4、存在问题"><a href="#4、存在问题" class="headerlink" title="4、存在问题"></a>4、存在问题</h5><p>由于使用layer-list标签实现的阴影只能做为background引入，所以如果对你是文字时，它的阴影效果就变成了这样：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span>  </span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </div><div class="line">        <span class="attr">android:text</span>=<span class="string">"文字的阴影效果"</span>  </div><div class="line">        <span class="attr">android:layout_margin</span>=<span class="string">"10dp"</span>  </div><div class="line">        <span class="attr">android:padding</span>=<span class="string">"10dp"</span>  </div><div class="line">        <span class="attr">android:background</span>=<span class="string">"@drawable/layer_shape_list"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>对应效果图为：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021814874319725880.png" alt="2017021814874319725880.png"><br>看起来跟按钮一个样 - _ -!!! 很囧有没有，文字的阴影应该是这样的才对：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170218148743198255118.png" alt="20170218148743198255118.png"><br>所以我们下面就要开始讲解如何实现文字的阴影效果啦，嘿嘿  </p>
<h4 id="二、Paint-setShadowLayer实现阴影效果"><a href="#二、Paint-setShadowLayer实现阴影效果" class="headerlink" title="二、Paint.setShadowLayer实现阴影效果"></a>二、Paint.setShadowLayer实现阴影效果</h4><p>上面我们讲了利用layer-list只能实现按钮的阴影效果，对于文字和图片都无法实现阴影效果，除了layer-list，我们只能用自定义控件来实现阴影效果了，Paint中有一个专门用来实现阴影效果的函数setShadowLayer，我们先来看看这个函数实现的阴影效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702192365620160704093251719.gif" alt="201702192365620160704093251719.gif"><br>从效果图中可以看出setShadowLayer函数能够实现：</p>
<ul>
<li>定制阴影模糊程度</li>
<li>定制阴影偏移距离</li>
<li>清除阴影和显示阴影</li>
</ul>
<h5 id="1、setShadowLayer构造函数"><a href="#1、setShadowLayer构造函数" class="headerlink" title="1、setShadowLayer构造函数"></a>1、setShadowLayer构造函数</h5><p>看起来setShadowLayer好像能够完成阴影定制的方方面面，我们先来看看它的构造函数：</p>
<pre><code>public void setShadowLayer(float radius, float dx, float dy, int color)
</code></pre><ul>
<li>float radius：意思是模糊半径，radius越大越模糊，越小越清晰，但是如果radius设置为0，则阴影消失不见；有关清除阴影的问题，下面我们会专门讲。</li>
<li>float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移</li>
<li>float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移</li>
<li>int color：绘制阴影的画笔颜色，即阴影的颜色（对图片阴影无效）</li>
</ul>
<p>我们这里需要着重讲两个点：一个是模糊半径，另一个是绘制阴影的画笔颜色为什么对图片无效： </p>
<ul>
<li>模糊半径的具体意义：<br>setShadowLayer使用的是高斯模糊算法，高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的RGB值并且平均，然后这个平均值就是模糊处理过的像素，如果对图片中的所有像素都这么处理的话，处理完成的图片就会变得模糊。<br>取周围像素的半径就是模糊半径.很容易知道,模糊半径越大,所得平均像素与原始像素相差就越大,也就越模糊.</li>
<li>绘制阴影的画笔颜色为什么对图片无效<br>从上面的效果图中可以看出，使用setShadowLayer所产生的阴影，对于文字和绘制的图形的阴影都是使用自定义的阴影画笔颜色来画的，而图片的阴影则是直接产生一张相同的图片，仅对阴影图片的边缘进行模糊。<br>大家可能会疑问，会什么对图片的处理是生成一张相同的背景图片呢？这是因为为了给图片添加阴影，如果统一使用某一种颜色来做阴影可能会与图片的颜色相差很大，而且不协调，比如某张图片的色彩非常丰富，而阴影如果使用灰色来做，可能就会显得很突兀，所以为了解决这个问题，针对图片的阴影就不再是统一颜色了，而是复制出这张图片，把复制出的图片的边缘进行模糊，做为阴影；但这样又会引起一个问题，就是如果我们想把图片的阴影做成灰色怎么办？使用setShadowLayer自动生成阴影是没办法了，在下篇我们会具体来讲，如何给图片添加指定颜色的阴影。</li>
</ul>
<p><strong>注意：这里有一点需要非常注意的是setShadowLayer只有文字绘制阴影支持硬件加速，其它都不支持硬件加速，所以为了方便起见，我们需要在自定义控件中禁用硬件加速。</strong></p>
<h5 id="2、示例一：初步使用setShadowLayer"><a href="#2、示例一：初步使用setShadowLayer" class="headerlink" title="2、示例一：初步使用setShadowLayer"></a>2、示例一：初步使用setShadowLayer</h5><p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747050158997.png" alt="20170219148747050158997.png"></p>
<p>这里实现了对文本，图形，Image的阴影效果；具体的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowLayerView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">    <span class="keyword">private</span> Bitmap mDogBmp;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayerView</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayerView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayerView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//首先是初始化，在初始化时设置画笔的颜色</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </div><div class="line">        setLayerType( LAYER_TYPE_SOFTWARE , <span class="keyword">null</span>);  <span class="comment">//禁用硬件加速</span></div><div class="line">        <span class="comment">//设置paint的属性，由于我们需要画图片，所以先把要画的图片加载进来。</span></div><div class="line">        mPaint.setColor(Color.GREEN);  <span class="comment">//设置画笔的颜色是绿色，从效果图中也可以看出来画出来的字体和圆形都是绿色的 </span></div><div class="line">        mPaint.setTextSize(<span class="number">25</span>);  </div><div class="line">        mPaint.setShadowLayer(<span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, Color.GRAY);  <span class="comment">//指的是阴影的颜色，从效果图中也明显可以看出，字体和阴影的颜色都是灰色的。 </span></div><div class="line">        mDogBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.drawText(<span class="string">"启舰大SB"</span>,<span class="number">100</span>,<span class="number">100</span>,mPaint);  </div><div class="line">  </div><div class="line">        canvas.drawCircle(<span class="number">200</span>,<span class="number">200</span>,<span class="number">50</span>,mPaint);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(mDogBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">200</span>,<span class="number">300</span>,<span class="number">200</span>+mDogBmp.getWidth(),<span class="number">300</span>+mDogBmp.getHeight()),mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="3、示例二：setShadowLayer各参数意义"><a href="#3、示例二：setShadowLayer各参数意义" class="headerlink" title="3、示例二：setShadowLayer各参数意义"></a>3、示例二：setShadowLayer各参数意义</h5><p>下面我们就来实现一下这部分开篇时的效果，动态添加setShadowLayer中的各个参数，就可以明显看出来它们的作用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowLayerView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">    <span class="keyword">private</span> Bitmap mDogBmp;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRadius = <span class="number">1</span>,mDx = <span class="number">10</span>,mDy = <span class="number">10</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayerView</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayerView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShadowLayerView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </div><div class="line">        setLayerType( LAYER_TYPE_SOFTWARE , <span class="keyword">null</span>);  </div><div class="line">        mPaint.setColor(Color.GREEN);  </div><div class="line">        mPaint.setTextSize(<span class="number">25</span>);  </div><div class="line">        mDogBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeRadius</span><span class="params">()</span> </span>&#123;  </div><div class="line">        mRadius++;  </div><div class="line">        postInvalidate();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDx</span><span class="params">()</span> </span>&#123;  </div><div class="line">        mDx+=<span class="number">5</span>;  </div><div class="line">        postInvalidate();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeDy</span><span class="params">()</span> </span>&#123;  </div><div class="line">        mDy+=<span class="number">5</span>;  </div><div class="line">        postInvalidate();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY);  </div><div class="line">  </div><div class="line">        canvas.drawText(<span class="string">"启舰大SB"</span>,<span class="number">100</span>,<span class="number">100</span>,mPaint);  </div><div class="line">  </div><div class="line">        canvas.drawCircle(<span class="number">200</span>,<span class="number">200</span>,<span class="number">50</span>,mPaint);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(mDogBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">200</span>,<span class="number">300</span>,<span class="number">200</span>+mDogBmp.getWidth(),<span class="number">300</span>+mDogBmp.getHeight()),mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码难度并不大，只是将 mPaint.setShadowLayer中的各参数写成了变量，并向外暴露了几个接口changeRadius()、changeDx()、changeDy()；当外部调用这些接口时，增加对应的变量，并且重绘控件；<br>由于每次重绘控件都肯定会调用onDraw方法，所以，我们将mPaint.setShadowLayer的设置放到onDraw方法里来，以确保每次重绘时mPaint.setShadowLayer的设置都会被更新。 </p>
<p><strong>使用时</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;  </div><div class="line">    <span class="keyword">private</span> ShadowLayerView mShadowLayerView;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">        setContentView(R.layout.main);  </div><div class="line">        mShadowLayerView = (ShadowLayerView)findViewById(R.id.shadowlayerview);  </div><div class="line">        findViewById(R.id.radius_btn).setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">        findViewById(R.id.dx_btn).setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">        findViewById(R.id.dy_btn).setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">        <span class="keyword">switch</span> (v.getId())&#123;  </div><div class="line">            <span class="keyword">case</span> R.id.radius_btn:  </div><div class="line">                mShadowLayerView.changeRadius();  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            <span class="keyword">case</span> R.id.dx_btn:  </div><div class="line">                mShadowLayerView.changeDx();;  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">            <span class="keyword">case</span> R.id.dy_btn:  </div><div class="line">                mShadowLayerView.changeDy();  </div><div class="line">                <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702195512620160704093716317.gif" alt="201702195512620160704093716317.gif"></p>
<p>从效果图中可以明显看到各个参数的区别，但正是通过效果图，我们可以明显得看出两个结论：</p>
<ul>
<li>图片的阴影是不受阴影画笔颜色影响的，它是一张图片的副本；</li>
<li>无论是图片还是图形，模糊时，仅模糊边界部分，随着模糊半径的增大，向内、向外延伸；其实很好理解这个问题：由于模糊半径的增大，高斯模糊向周边取值的范围在增大，所以向内、向外延伸的距离就会更大</li>
</ul>
<h5 id="4、Paint-clearShadowLayer-清除阴影"><a href="#4、Paint-clearShadowLayer-清除阴影" class="headerlink" title="4、Paint.clearShadowLayer()清除阴影"></a>4、Paint.clearShadowLayer()清除阴影</h5><p>上面我们讲解了使用setShadowLayer添加阴影的问题，下面我们再来看看如何清除阴影的。清除阴影其实有两个方法，可以将setShadowLayer的radius的值设为0，也可以使用专门的清除阴影的函数：</p>
<pre><code>//Paint系函数：清除ShadowLayer阴影  
public void clearShadowLayer()  
</code></pre><p>将setShadowLayer的radius的值设为0来清除阴影的用法，我这里就不再演示了，大家可以自己试试，我们这里尝试下使用clearShadowLayer() 来清除阴影的用法。<br>在上面函数的基础上，我们另外添加一个变量来控制当前是否显示阴影：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowLayerView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    …………  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mSetShadow = <span class="keyword">true</span>;  </div><div class="line">    …………  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearShadow</span><span class="params">()</span></span>&#123;  </div><div class="line">        mSetShadow = <span class="keyword">false</span>;  </div><div class="line">        postInvalidate();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showShadow</span><span class="params">()</span></span>&#123;  </div><div class="line">        mSetShadow = <span class="keyword">true</span>;  </div><div class="line">        postInvalidate();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (mSetShadow) &#123;  </div><div class="line">            mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY);  </div><div class="line">        &#125;<span class="keyword">else</span> &#123;  </div><div class="line">            mPaint.clearShadowLayer();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        canvas.drawText(<span class="string">"启舰大SB"</span>,<span class="number">100</span>,<span class="number">100</span>,mPaint);  </div><div class="line">  </div><div class="line">        canvas.drawCircle(<span class="number">200</span>,<span class="number">200</span>,<span class="number">50</span>,mPaint);  </div><div class="line">  </div><div class="line">        canvas.drawBitmap(mDogBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">200</span>,<span class="number">300</span>,<span class="number">200</span>+mDogBmp.getWidth(),<span class="number">300</span>+mDogBmp.getHeight()),mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改的代码很简单，增加一个变量mSetShadow来控制当前是否显示阴影，如果需要显示阴影就调用mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY);设置阴影，如果不需要显示阴影就调用mPaint.clearShadowLayer();来清除阴影；<br>对于使用btn调用clearShadow()、showShadow()这两个接口的用法，就不再帖代码了，没啥难度，源码里也有；<br>效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702199796720160704093846069.gif" alt="201702199796720160704093846069.gif"></p>
<p>在目前的所有例子中，我们的定义控件在xml中使用时，layout_widht、layout_height都统一设置成match_parent或者fill_parent来强制全屏；是时间教大家如何使用wrap_content属性，如何让控件自已计算高度了，下篇我们就来看看这个问题。</p>
<h4 id="三、TextView及其派生类使用ShadowLayer添加阴影效果"><a href="#三、TextView及其派生类使用ShadowLayer添加阴影效果" class="headerlink" title="三、TextView及其派生类使用ShadowLayer添加阴影效果"></a>三、TextView及其派生类使用ShadowLayer添加阴影效果</h4><p>上面我们通过自定义控件来实现了自定义阴影效果，那么问题来了，如果我需要给已有的控件添加阴影效果，实现下面这样的效果：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702197042120160704093941925.gif" alt="201702197042120160704093941925.gif"></p>
<h5 id="1、XML实现"><a href="#1、XML实现" class="headerlink" title="1、XML实现"></a>1、XML实现</h5><p>从上面可以看到，TextView,Button,EditView中的文字都具有阴影效果。那是怎么实现的呢？难道我们需要在原生控件的甚而上派生一个类在onDraw里使用setShadowLayer来绘制阴影吗？<br>答案当然不是，setShadowLayer是API 1 就已经引入的方法，同样，对于TextView和从TextView派生的类都自然具体XML属性来设置阴影。这几个设置阴影的XML属性如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">TextView</span>  </span></div><div class="line">       …………  </div><div class="line">        <span class="attr">android:shadowRadius</span>=<span class="string">"3"</span>  </div><div class="line">        <span class="attr">android:shadowDx</span>=<span class="string">"5"</span>  </div><div class="line">        <span class="attr">android:shadowDy</span>=<span class="string">"5"</span>  </div><div class="line">        <span class="attr">android:shadowColor</span>=<span class="string">"@android:color/darker_gray"</span>/&gt;</div></pre></td></tr></table></figure></p>
<p>这几个属性的意义非常容易理解，直接对应setShadowLayer的几个参数setShadowLayer(float radius, float dx, float dy, int color)，但这几个属性只有TextVIew及其派生类才会有，其它类是没有的，TextVIew的派生类如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747120697471.png" alt="20170219148747120697471.png"><br>所以一般我们使用的Button和EditText是可以使用Xml来实现阴影的。</p>
<h5 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><p>既然能通过XML实现，当然也能会代码版了，TextView及其派生类，都有一个Paint.setShadowLayer的同名方法：</p>
<pre><code>//TextView中的设置阴影函数  
public void setShadowLayer(float radius, float dx, float dy, int color)   
</code></pre><p>通过该方法就很容易来实现TextView及其派生类的阴影了。<br>使用示例如下：</p>
<pre><code>TextView tv = (TextView)findViewById(R.id.tv);  
tv.setShadowLayer(2,5,5, Color.GREEN); 
</code></pre><h4 id="四、SetMaskFilter之BlurMaskFilter实现发光效果"><a href="#四、SetMaskFilter之BlurMaskFilter实现发光效果" class="headerlink" title="四、SetMaskFilter之BlurMaskFilter实现发光效果"></a>四、SetMaskFilter之BlurMaskFilter实现发光效果</h4><p>前面我们讲了如何给控件添加阴影效果，其它跟阴影效果类似的还有一个发光效果：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747127788398.png" alt="20170219148747127788398.png"></p>
<p>上面就是我们这节要讲的发光效果，在这个效果图中，总共涉及了三个内容的发光效果：文字、图形和Bitmap图像。<br>从最后一个小狗的Bitmap所形成的发光效果中可以看到，与setShadowLayer一样，发光效果也只会影响边缘部分图像，内部图像是不受影响的。<br>从第三个图形（红绿各一半的Bitmap）中可以看到：发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。<br>所以初步我们对发光效果有如下结论：</p>
<ul>
<li>与setShadowLayer一样，发光效果也是使用的高斯模糊，并且只会影响边缘部分图像，内部图像是不受影响的</li>
<li>发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。</li>
</ul>
<h5 id="1、SetMaskFilter之BlurMaskFilter概述"><a href="#1、SetMaskFilter之BlurMaskFilter概述" class="headerlink" title="1、SetMaskFilter之BlurMaskFilter概述"></a>1、SetMaskFilter之BlurMaskFilter概述</h5><p>Paint函数的的setMaskFilter声明如下：</p>
<pre><code>public MaskFilter setMaskFilter(MaskFilter maskfilter)  
</code></pre><p>前面我们讲到setColorFilter来设置颜色滤镜,与setColorFilter一样，setMaskFilter中的MaskFilter也是没有具体实现的，也是通过派生子类来实现具体的不同功能的，MaskFilter有两个派生类BlurMaskFilter和EmbossMaskFilter，其中BlurMaskFilter就是我们这段要讲的实现发光效果的子类，而EmbossMaskFilter是用来实现浮雕效果的，用处很少，这里就不再讲了。另一点需要注意的是，setMaskFilter是不支持硬件加速的，必须关闭硬件加速才可以。<br>BlurMaskFilter的构造函数如下：  </p>
<pre><code>public BlurMaskFilter(float radius, Blur style) 
</code></pre><p>其中：</p>
<ul>
<li>float radius：用来定义模糊半径，同样是高斯模糊算法。</li>
<li>Blur style：发光样式，有内发光、外发光、和内外发光，分别对应：Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)，这几个模式，后面我们会逐个来展示用法。<br>下面我们简单举一个例子来看看用法先，这个例子的代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlurMaskFilterView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Paint mPaint;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlurMaskFilterView</span><span class="params">(Context context)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlurMaskFilterView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlurMaskFilterView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);  </div><div class="line">        init();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);  </div><div class="line">        mPaint = <span class="keyword">new</span> Paint();  </div><div class="line">        mPaint.setColor(Color.RED);  </div><div class="line">        mPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(<span class="number">50</span>, Blur.INNER));  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);  </div><div class="line">  </div><div class="line">        canvas.drawCircle(<span class="number">200</span>,<span class="number">200</span>,<span class="number">100</span>,mPaint);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用起来非常容易，只需要在paint的时候调用setMaskFilter将BlurMaskFilter的实例设置进行就可以了。这里使用的内发光模式。我们来看下效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747141094317.png" alt="20170219148747141094317.png"></p>
<p>很明显的内发光效果。下面我们分别来看看各种模式下的发光效果。</p>
<h5 id="2、BlurStyle发光效果"><a href="#2、BlurStyle发光效果" class="headerlink" title="2、BlurStyle发光效果"></a>2、BlurStyle发光效果</h5><h6 id="1-、Blur-INNER——内发光"><a href="#1-、Blur-INNER——内发光" class="headerlink" title="(1)、Blur.INNER——内发光"></a>(1)、Blur.INNER——内发光</h6><p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747143957685.png" alt="20170219148747143957685.png"></p>
<h6 id="2-、Blur-SOLID——外发光"><a href="#2-、Blur-SOLID——外发光" class="headerlink" title="(2)、Blur.SOLID——外发光"></a>(2)、Blur.SOLID——外发光</h6><p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747145593850.png" alt="20170219148747145593850.png"></p>
<h6 id="3-、Blur-NORMAL——内外发光"><a href="#3-、Blur-NORMAL——内外发光" class="headerlink" title="(3)、Blur.NORMAL——内外发光"></a>(3)、Blur.NORMAL——内外发光</h6><p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747147367559.png" alt="20170219148747147367559.png"></p>
<h6 id="4-、Blur-OUTER——仅显示发光效果"><a href="#4-、Blur-OUTER——仅显示发光效果" class="headerlink" title="(4)、Blur.OUTER——仅显示发光效果"></a>(4)、Blur.OUTER——仅显示发光效果</h6><p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747149464734.png" alt="20170219148747149464734.png"></p>
<p>Blur.OUTER比较特殊，这种模式下仅会显示发光效果，会把原图像中除了发光部分，全部变为透明！<br>大家是否可以看出来发光效果与setShadowLayer所生成的阴影之间有什么联系？<br>setShadowLayer所生成的阴影，其实就是将新建的阴影图形副本进行发光效果并且位移一定的距离而已。下篇我们就会利用这个原理来生成图片指定颜色的阴影效果。<br>到这里，这篇文章就结束了，下篇将继续给大家讲解如何给图片添加指定颜色的阴影效果，并且初步教大家如何将其封装成一个控件。</p>
<h3 id="三、为Bitmap添加阴影并封装控件"><a href="#三、为Bitmap添加阴影并封装控件" class="headerlink" title="三、为Bitmap添加阴影并封装控件"></a>三、为Bitmap添加阴影并封装控件</h3><p>上篇给大家讲解了如何控件添加阴影效果，但是在为Bitmap图片添加阴影时，却没办法添加具有指定颜色的阴影，这篇我们就来使用自定义的控件及自定义属性来初步封装下控件。前方高能预警——本篇内容涉及内容较多，难度较大，需要多加思考。</p>
<h4 id="一、使用BlurMaskFilter为图片构造定色阴影效果"><a href="#一、使用BlurMaskFilter为图片构造定色阴影效果" class="headerlink" title="一、使用BlurMaskFilter为图片构造定色阴影效果"></a>一、使用BlurMaskFilter为图片构造定色阴影效果</h4><p>上面我们讲了通过setShadowLayer为图片添加阴影效果，但是图片的的阴影是用原图形的副本加上边缘发光效果组成的。我们怎么能给图片添加一个灰色的阴影呢？<br>我们来分析一下setShadowLayer的阴影形成过程（假定阴影画笔是灰色），对于文字和图形，它首先产生一个跟原型一样的灰色副本。然后对这个灰色副本应用BlurMaskFilter，使其内外发光；这样就形成了所谓的阴影！当然最后再偏移一段距离。<br>所以，我们要给图片添加灰色阴影效果，所以我们能不能仿一下这个过程：先绘制一个跟图片一样大小的灰色图形，然后给这个灰色图形应用BlurMaskFilter使其内外发光，然后偏移原图形绘制出来，不就可以了么<br>所以，这里涉及到三个点：  </p>
<ul>
<li>绘制出一个一样大小的灰色图形</li>
<li>对灰色图形应用BlurMaskFilter使其内外发光</li>
<li>偏移原图形一段距离绘制出来<br>下面我们就通过例子来一步步看是怎么实现出来的吧</li>
</ul>
<h5 id="1、绘制出一个一样大小的灰色图像"><a href="#1、绘制出一个一样大小的灰色图像" class="headerlink" title="1、绘制出一个一样大小的灰色图像"></a>1、绘制出一个一样大小的灰色图像</h5><p>首先，我们来看怎么能绘出一个指定Bitmap所对应的灰色图像。我们知道canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)中的paint的画笔颜色对画出来的bitmap是没有任何影响的，因为原来Bitmap长什么样，无论你画笔是什么颜色，画出来的图片还是跟原图片长的一样。所以如果我们需要画一张对应的灰色图像，我们需要新建一个一样大小的空白图，但是新图片的透明度要与原图片保持一致。所以如何从原图片中抽出Alpha值成为了关键。即我们只需要创建一个与原图片一样大小且Alpha相同的图片即可。<br>其实Bitmap中已经存在抽取出只具有Alpha值图片的函数：</p>
<pre><code>public Bitmap extractAlpha();
</code></pre><p>extraAlpha()函数的功能是：新建一张空白图片，图片具有与原图片一样的Alpha值，这个新建的Bitmap做为结果返回。这个空白图片中每个像素都具有与原图片一样的Alpha值，而且具体的颜色时，只有在使用canvas.drawBitmap绘制时，由传入的paint的颜色指定。<br><strong>总结</strong>   </p>
<ul>
<li>extractAlpha()新建一张仅具有Alpha值的空白图像</li>
<li>这张图像的颜色，是由canvas.drawBitmap时的画笔指定的。</li>
</ul>
<h6 id="（1）、extractAlpha-使用示例"><a href="#（1）、extractAlpha-使用示例" class="headerlink" title="（1）、extractAlpha()使用示例"></a>（1）、extractAlpha()使用示例</h6><p>下面，我们就用个例子先来看下extractAlpha()函数的用法<br>我们拿一张图片来做试验，下面这张PNG图片中，一只小猫和一只小狗，其余地方都是透明色。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747192429637.png" alt="20170219148747192429637.png"><br>下面我们分别利用extractAlpha()画出它对应的红色和绿色的阴影图<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747196393407.png" alt="20170219148747196393407.png"><br>对应的代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtractAlphaView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBitmap,mAlphaBmp;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtractAlphaView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtractAlphaView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtractAlphaView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    	 <span class="comment">//禁用硬件加速</span></div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.blog12);</div><div class="line">        mAlphaBmp = mBitmap.extractAlpha();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">		 <span class="comment">//分别将画笔的颜色设置为红色和绿色，然后两次把mAlphaBmp画出来。</span></div><div class="line">        <span class="keyword">int</span> width = <span class="number">200</span>;</div><div class="line">        <span class="keyword">int</span> height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth();</div><div class="line">         mPaint.setColor(Color.RED);</div><div class="line">        canvas.drawBitmap(mAlphaBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);</div><div class="line"></div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        canvas.drawBitmap(mAlphaBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,height,width,<span class="number">2</span>*height),mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先是禁用硬件加速，这基本上是我们做自定义控件的标配！为了防止功能不好用，记得每次都加上这个函数！然后是利用extratAlpha()来生成仅具有透明度的空白图像。 </p>
<h5 id="2、对灰色图形应用BlurMaskFilter使其内外发光"><a href="#2、对灰色图形应用BlurMaskFilter使其内外发光" class="headerlink" title="2、对灰色图形应用BlurMaskFilter使其内外发光"></a>2、对灰色图形应用BlurMaskFilter使其内外发光</h5><p>在第一步完成了之后，我们进行第二步，将阴影添加内外发光效果。就形成了阴影的模样。<br>代码很简单，只需要使用Paint.setMaskFilter函数添加发光效果即可，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> width = <span class="number">200</span>;</div><div class="line">    <span class="keyword">int</span> height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth();</div><div class="line">    mPaint.setColor(Color.RED);</div><div class="line">    mPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(<span class="number">10</span>, BlurMaskFilter.Blur.NORMAL));</div><div class="line">    canvas.drawBitmap(mAlphaBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);</div><div class="line"></div><div class="line">    mPaint.setColor(Color.GREEN);</div><div class="line">    canvas.drawBitmap(mAlphaBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,height,width,<span class="number">2</span>*height),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>明显可以看出这里只添加了一行代码：mPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL));就是添加内外发光效果，难度不大，不再细讲。</p>
<h5 id="3、偏移原图形一段距离绘制出来"><a href="#3、偏移原图形一段距离绘制出来" class="headerlink" title="3、偏移原图形一段距离绘制出来"></a>3、偏移原图形一段距离绘制出来</h5><p>这段比较简单了，只需要先把阴影画出来，然后再把原图像盖上去，但需要注意的是，阴影需要相对原图像偏移一段距离。完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtractAlphaView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBitmap,mAlphaBmp;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtractAlphaView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtractAlphaView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtractAlphaView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.blog12);</div><div class="line">        mAlphaBmp = mBitmap.extractAlpha();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> width = <span class="number">200</span>;</div><div class="line">        <span class="keyword">int</span> height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth();</div><div class="line"></div><div class="line">        <span class="comment">//绘制阴影</span></div><div class="line">        mPaint.setColor(Color.RED);</div><div class="line">        mPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(<span class="number">10</span>, BlurMaskFilter.Blur.NORMAL));</div><div class="line">        canvas.drawBitmap(mAlphaBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">10</span>,<span class="number">10</span>,width,height),mPaint);</div><div class="line">        mPaint.setColor(Color.GREEN);</div><div class="line">        canvas.drawBitmap(mAlphaBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">10</span>,height+<span class="number">10</span>,width,<span class="number">2</span>*height),mPaint);</div><div class="line"></div><div class="line">        <span class="comment">//绘制原图像</span></div><div class="line">        mPaint.setMaskFilter(<span class="keyword">null</span>);</div><div class="line">        canvas.drawBitmap(mBitmap,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);</div><div class="line">        canvas.drawBitmap(mBitmap,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,height,width,<span class="number">2</span>*height),mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关键部分在onDraw函数中，先画出来阴影，然后再画出来原图像，需要注意的是在画原图像时，需要利用mPaint.setMaskFilter(null);将发光效果去掉。只有阴影需要发光效果，原图像是不需要发光效果的。另一点注意的是，阴影要偏移一点位置，这里是偏移了10个像素。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747220789400.png" alt="20170219148747220789400.png"></p>
<h4 id="二、封装控件"><a href="#二、封装控件" class="headerlink" title="二、封装控件"></a>二、封装控件</h4><p>上面我们初步实现了图片的阴影效果，但这只是本篇内容的一小部分，最最重要的，如何将它封装成一个控件，具有如下功能：</p>
<ul>
<li>让用户定义图片内容</li>
<li>让用户定义偏移距离</li>
<li>让用户定义阴影颜色和阴影模糊程度</li>
<li>可以使用wrap_content属性自适应大小</li>
</ul>
<h5 id="1、自定义控件属性"><a href="#1、自定义控件属性" class="headerlink" title="1、自定义控件属性"></a>1、自定义控件属性</h5><p>有关自定义控件属性，大家首先需要看下这篇文章《PullScrollView详解（一）——自定义控件属性》，在这篇文章中讲解了自定义控件属性的方法与提取方法。下面将会直接用到自定义属性的内容，下面涉及到的时候就自认为大家已经学会了自定义控件属性的方法了。<br>在这里，我们需要自定义四个属性，分别对应： 自定义图片内容、自定义偏移距离、自定义阴影颜色、自定义阴影模糊程度 这四个需求，所以我们先利用declare-styleable标签来定义这些属性<br><strong>attr.xml</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"BitmapShadowView"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"src"</span> <span class="attr">format</span>=<span class="string">"reference"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"shadowDx"</span> <span class="attr">format</span>=<span class="string">"integer"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"shadowDy"</span> <span class="attr">format</span>=<span class="string">"integer"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"shadowColor"</span> <span class="attr">format</span>=<span class="string">"color"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"shadowRadius"</span> <span class="attr">format</span>=<span class="string">"float"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里定义了五个xml属性，src来引用图片资源，仿照setShadowLayer另外定义shadowDx、shadowDy、shadowColor、shadowRadius来定义阴影的边距、颜色和模糊半径。<br><strong>然后在布局中使用：(main.xml)</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow"</span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.BlogBitmapShadow.BitmapShadowView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"200dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></div><div class="line">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></div><div class="line">            <span class="attr">app:src</span>=<span class="string">"@drawable/blog12"</span></div><div class="line">            <span class="attr">app:shadowDx</span>=<span class="string">"10"</span></div><div class="line">            <span class="attr">app:shadowDy</span>=<span class="string">"10"</span></div><div class="line">            <span class="attr">app:shadowRadius</span>=<span class="string">"10.0"</span></div><div class="line">            <span class="attr">app:shadowColor</span>=<span class="string">"@android:color/holo_red_dark"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>在布局中使用很简单，直接定义控件所使用的图片资源、阴影相关参数就可以了，难度不大就不再讲了，下面我们来看如何在代码中中提取用户传入的这些属性。<br><strong>BitmapShadowView中提取属性值并绘阴影</strong><br>先列出完整代码，然后再细讲：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapShadowView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBmp,mShadowBmp;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDx = <span class="number">10</span>,mDy = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mRadius = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShadowColor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShadowView</span><span class="params">(Context context, AttributeSet attrs)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line"></div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShadowView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context,AttributeSet attrs)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 提取属性定义</div><div class="line">         */</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView);</div><div class="line">        <span class="keyword">int</span> BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (BitmapID == -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"BitmapShadowView 需要定义Src属性,而且必须是图像"</span>);</div><div class="line">        &#125;</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(),BitmapID);</div><div class="line">        mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,<span class="number">0</span>);</div><div class="line">        mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,<span class="number">0</span>);</div><div class="line">        mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,<span class="number">0</span>);</div><div class="line">        mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK);</div><div class="line"></div><div class="line">        typedArray.recycle();</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 其它定义</div><div class="line">         */</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mShadowBmp = mBmp.extractAlpha();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> width = getWidth()-mDx;</div><div class="line">        <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();</div><div class="line"></div><div class="line">        <span class="comment">//绘制阴影</span></div><div class="line">        mPaint.setColor(mShadowColor);</div><div class="line">        mPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL));</div><div class="line">        canvas.drawBitmap(mShadowBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(mDx,mDy,width,height),mPaint);</div><div class="line"></div><div class="line">        <span class="comment">//绘制原图像</span></div><div class="line">        mPaint.setMaskFilter(<span class="keyword">null</span>);</div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这段代码中分两部分，首先根据属性来初始化各变量，然后再利用这些变量画出bitmap与阴影。<br>首先看初始化部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context,AttributeSet attrs)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 提取属性定义</div><div class="line">     */</div><div class="line">    TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView);</div><div class="line">    <span class="keyword">int</span> BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (BitmapID == -<span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"BitmapShadowView 需要定义Src属性,而且必须是图像"</span>);</div><div class="line">    &#125;</div><div class="line">    mBmp = BitmapFactory.decodeResource(getResources(),BitmapID);</div><div class="line">    mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,<span class="number">0</span>);</div><div class="line">    mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,<span class="number">0</span>);</div><div class="line">    mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,<span class="number">0</span>);</div><div class="line">    mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK);</div><div class="line"></div><div class="line">    typedArray.recycle();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 其它定义</div><div class="line">     */</div><div class="line">    mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    mShadowBmp = mBmp.extractAlpha();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初始化的时候，首先是利用TypedArray来初始化各项参数，由于我们是做图片的阴影，所以图片资源必须赋值，所以我们在提取图片资源时，对其添加容错：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-<span class="number">1</span>);</div><div class="line"><span class="keyword">if</span> (BitmapID == -<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"BitmapShadowView 需要定义Src属性,而且必须是图像"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当提取失败时，抛出异常，终止程序，这样用户在写代码时就可以及时发现问题，而不必等上线以后才发现没有bitmap；<br>有关其它属性值的提取，这里就不再细讲了。<br>在提取完属性以后，就是定义画笔paint和根据源图像利用extractAlpha()来生成阴影图像；<br>在初始化以后就是利用这些属性来进行绘图了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> width = getWidth()-mDx;</div><div class="line">    <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();</div><div class="line"></div><div class="line">    <span class="comment">//绘制阴影</span></div><div class="line">    mPaint.setColor(mShadowColor);</div><div class="line">    mPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL));</div><div class="line">    canvas.drawBitmap(mShadowBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(mDx,mDy,width,height),mPaint);</div><div class="line"></div><div class="line">    <span class="comment">//绘制原图像</span></div><div class="line">    mPaint.setMaskFilter(<span class="keyword">null</span>);</div><div class="line">    canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，图片宽度与控件宽度操持一致（但需要把阴影的位置空出来），所以宽度为：<code>int width = getWidth()-mDx</code><br>根据图片的宽高比换算出图片的高度：<code>int height = width * mBmp.getHeight()/mBmp.getWidth()</code><br>我们依控件左上角（0，0）显示原图像，阴影在(mDx,mDy)处显示；<br>到这里自定义属性的定义与提取就结束了，最终效果图为：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747253045201.png" alt="20170219148747253045201.png"><br>从效果图中可以明显看出，明显给原图片添加了红色的阴影效果。<br>目前，我们初步实现了可以让用户自定义控件属性的功能，但我们在使用这个控件时，必须强制设置指定的宽高或者fill_parent来强制平屏，这样明显是不可取的，我们需要它能够让用户使用wrap_conetent时，自己计算宽高。</p>
<h5 id="2、wrap-content自适应宽高"><a href="#2、wrap-content自适应宽高" class="headerlink" title="2、wrap_content自适应宽高"></a>2、wrap_content自适应宽高</h5><p>在自适应宽高时，需要了解onMeasure()、onLayout()与onDraw()的知识；在第三篇中我还会重新讲解一遍onMeasure()、onLayout()与onDraw()，这里涉及内容不多，看完上一篇然后再理解以下内容应该不会有问题<br>在看完上面的文章，大家就应该知道，对于View控件的自适应宽高，只需要在上面的代码中重写onMeasure()方法就可以了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">   <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line"></div><div class="line">   <span class="keyword">int</span> measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">   <span class="keyword">int</span> measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">   <span class="keyword">int</span> measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">   <span class="keyword">int</span> measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">   <span class="keyword">int</span> width = mBmp.getWidth();</div><div class="line">   <span class="keyword">int</span> height = mBmp.getHeight();</div><div class="line">   setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在onMeasure方法中，当用户指定属性是wrap_content时，就使用图片的宽高做为控件的宽高。<br>此时整个自定义控件的完整代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapShadowView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBmp,mShadowBmp;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDx = <span class="number">10</span>,mDy = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mRadius = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShadowColor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShadowView</span><span class="params">(Context context, AttributeSet attrs)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line"></div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShadowView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context,AttributeSet attrs)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 提取属性定义</div><div class="line">         */</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView);</div><div class="line">        <span class="keyword">int</span> BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (BitmapID == -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"BitmapShadowView 需要定义Src属性,而且必须是图像"</span>);</div><div class="line">        &#125;</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(),BitmapID);</div><div class="line">        mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,<span class="number">0</span>);</div><div class="line">        mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,<span class="number">0</span>);</div><div class="line">        mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,<span class="number">0</span>);</div><div class="line">        mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK);</div><div class="line"></div><div class="line">        typedArray.recycle();</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 其它定义</div><div class="line">         */</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mShadowBmp = mBmp.extractAlpha();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">int</span> measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">        <span class="keyword">int</span> measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">        <span class="keyword">int</span> measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> width = mBmp.getWidth();</div><div class="line">        <span class="keyword">int</span> height = mBmp.getHeight();</div><div class="line">        setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> width = getWidth()-mDx;</div><div class="line">        <span class="keyword">int</span> height = width * mBmp.getHeight()/mBmp.getWidth();</div><div class="line"></div><div class="line">        <span class="comment">//绘制阴影</span></div><div class="line">        mPaint.setColor(mShadowColor);</div><div class="line">        mPaint.setMaskFilter(<span class="keyword">new</span> BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL));</div><div class="line">        canvas.drawBitmap(mShadowBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(mDx,mDy,width,height),mPaint);</div><div class="line"></div><div class="line">        <span class="comment">//绘制原图像</span></div><div class="line">        mPaint.setMaskFilter(<span class="keyword">null</span>);</div><div class="line">        canvas.drawBitmap(mBmp,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,width,height),mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以当我们对这个自定义的控件使用如下布局（使用wrap_content）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow"</span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.BlogBitmapShadow.BitmapShadowView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></div><div class="line">            <span class="attr">app:src</span>=<span class="string">"@drawable/blog12"</span></div><div class="line">            <span class="attr">app:shadowDx</span>=<span class="string">"10"</span></div><div class="line">            <span class="attr">app:shadowDy</span>=<span class="string">"10"</span></div><div class="line">            <span class="attr">app:shadowRadius</span>=<span class="string">"10.0"</span></div><div class="line">            <span class="attr">app:shadowColor</span>=<span class="string">"@android:color/holo_red_dark"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"test BTN"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747272631952.png" alt="20170219148747272631952.png"><br>所以，这时候如果我们需要产生灰色阴影，只需要把xml中的app:shadowColor的值改一下即可：(为了方便看阴影，我把Activiy背景改成了白色)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow"</span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">              <span class="attr">android:background</span>=<span class="string">"@android:color/white"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.BlogBitmapShadow.BitmapShadowView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></div><div class="line">            <span class="attr">app:src</span>=<span class="string">"@drawable/blog12"</span></div><div class="line">            <span class="attr">app:shadowDx</span>=<span class="string">"10"</span></div><div class="line">            <span class="attr">app:shadowDy</span>=<span class="string">"10"</span></div><div class="line">            <span class="attr">app:shadowRadius</span>=<span class="string">"10.0"</span></div><div class="line">            <span class="attr">app:shadowColor</span>=<span class="string">"@android:color/darker_gray"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"test BTN"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747393834010.png" alt="20170219148747393834010.png"></p>
<p>到这里，整个控件的封装就结束了，但细心的同学可以发现，BitmapShadowView的构造函数默认有三个，而我这里只写了两个具有AttributeSet attrs参数的，而下面这个构造函数却是没有实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BitmapShadowView</span><span class="params">(Context context)</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为当从XML中生成控件时，都会调用具有AttributeSet attrs参数的方法，而从代码中生成控件则会调用上面仅具有context函数的方法，所以如果需要从代码中生成需要添加上这个方法，并且需要在代码中提供接口供外部设置各种属性才好，我这里就略去了这部分内容了，大家可以自己来填充这个控件，使其更完整。</p>
<h3 id="四、BitmapShader与望远镜效果"><a href="#四、BitmapShader与望远镜效果" class="headerlink" title="四、BitmapShader与望远镜效果"></a>四、BitmapShader与望远镜效果</h3><p>上篇初步给大家展示了封装控件的方法，这篇我们继续Paint来看相关方法的用法，这篇我们将会讲一个很起来没啥用，但效果却很屌的方法setShader，这篇文章最后，我们将实现的效果是望远镜效果:（看起来有没有屌屌的）<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219664571469532269_6953.gif" alt="20170219664571469532269_6953.gif"><br>我们先来看看setShader函数的声明：</p>
<pre><code>//Paint类中的方法
public Shader setShader(Shader shader)
</code></pre><p>Shader在三维软件中称之为着色器，就是用来给空白图形上色用的。在PhotoShop中有一个工具叫印章工具，我们能够指定印章的样式来填充图形。印章的样式可以是图像、颜色、渐变色等。这里的Shader实现的效果与印章类似。我们也是通过给Shader指定对应的图像、渐变色等来填充图形的。<br>Shader类只是一个基类，它其中只有两个方法setLocalMatrix(Matrix localM)、getLocalMatrix(Matrix localM)用来设置坐标变换矩阵的，有关设置矩阵的内容，我们后面会单独讲解坐标矩阵用法的时候，会再次提，这里就先略过。<br>Shader类与ColorFiler一样，其实是一个空类，它的功能的实现，主要是靠它的派生类来实现的。继承关系如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747417321114.png" alt="20170219148747417321114.png"><br>下面我们就来逐个来看每个派生类的用法与效果。</p>
<h4 id="一、BitmapShader基本用法"><a href="#一、BitmapShader基本用法" class="headerlink" title="一、BitmapShader基本用法"></a>一、BitmapShader基本用法</h4><h5 id="1、概述-7"><a href="#1、概述-7" class="headerlink" title="1、概述"></a>1、概述</h5><p>我们这篇文章只看一个派生类：BitmapShader，它的构造函数如下：</p>
<pre><code>public BitmapShader(Bitmap bitmap, TileMode tileX, TileMode tileY)
</code></pre><p>这个就相当于PhotoShop中的图案印章工具，bitmap用来指定图案，tileX用来指定当X轴超出单个图片大小时时所使用的重复策略，同样tileY用于指定当Y轴超出单个图片大小时时所使用的重复策略<br>其中TileMode的取值有：</p>
<ul>
<li>TileMode.CLAMP:用边缘色彩填充多余空间</li>
<li>TileMode.REPEAT:重复原图像来填充多余空间</li>
<li>TileMode.MIRROR:重复使用镜像模式的图像来填充多余空间<br>只看这些还是啥都不懂，我们先来举个例子来看下用法</li>
</ul>
<h5 id="2、BitmapShader使用示例"><a href="#2、BitmapShader使用示例" class="headerlink" title="2、BitmapShader使用示例"></a>2、BitmapShader使用示例</h5><p>这里使用的印章图像是：(dog_edge.png)<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747556992480.png" alt="20170219148747556992480.png"><br>中间是我们熟悉的小狗，四周被四种不同的颜色给包围，这些颜色是我特地画上去的，后面自然有它的用处。<br>我们还是先直接来看完整代码吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapShaderView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBmp;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShaderView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShaderView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShaderView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge);</div><div class="line">        mPaint.setShader(<span class="keyword">new</span> BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">        <span class="comment">//getWidth()用于获取控件宽度，getHeight()用于获取控件高度</span></div><div class="line">        canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码其实很简单，在初始化的时候设置印章图片：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">    mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge);</div><div class="line">    mPaint.setShader(<span class="keyword">new</span> BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在绘图的时候，利用paint绘制一个矩形，这个矩形的大小与控件的大小一模一样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    <span class="comment">//getWidth()用于获取控件宽度，getHeight()用于获取控件高度</span></div><div class="line">    canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后在布局中使用时：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">            <span class="attr">android:text</span>=<span class="string">"test BTN"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.Blog_BitmapShader.BitmapShaderView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"200dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"400dp"</span></div><div class="line">            <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>给我们自定义的控件添加上宽高限制，为了方便看效果，我在它上面也另外加了一个按钮<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747591721538.png" alt="20170219148747591721538.png"><br>从效果图中可以看出：</p>
<ul>
<li>使用X轴和Y轴都使用REPEAT模式下，在超出单个图像的区域后，就会重复绘制这个图像</li>
<li>绘制是从控件的左上角开始的，而不是从屏幕原点开始的！这点很好理解，因为我们绘图也只会在自定义控件上绘图，不会在全屏幕上绘图。</li>
</ul>
<h5 id="3、TileMode模式解析"><a href="#3、TileMode模式解析" class="headerlink" title="3、TileMode模式解析"></a>3、TileMode模式解析</h5><p>上面初步看到了REPEAT模式的用法，现在我们分别来看在各个模式下的不同表现 </p>
<h6 id="（1）、TileMode-REPEAT模式：重复原图像来填充多余空间"><a href="#（1）、TileMode-REPEAT模式：重复原图像来填充多余空间" class="headerlink" title="（1）、TileMode.REPEAT模式：重复原图像来填充多余空间"></a>（1）、TileMode.REPEAT模式：重复原图像来填充多余空间</h6><p>在更改模式时，只需要更新setShader里的代码：<br><code>mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));</code><br>在这里，X轴、Y轴全部设置成REPEAT模式，所以当控件的显示范围超出了单个图的显示范围时，在X轴上将使用REPEAT模式,同样，在Y轴上也将使用REPEAT模式<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747606052729.png" alt="20170219148747606052729.png"></p>
<h6 id="（2）、TileMode-MIRROR模式：重复使用镜像模式的图像来填充多余空间"><a href="#（2）、TileMode-MIRROR模式：重复使用镜像模式的图像来填充多余空间" class="headerlink" title="（2）、TileMode.MIRROR模式：重复使用镜像模式的图像来填充多余空间"></a>（2）、TileMode.MIRROR模式：重复使用镜像模式的图像来填充多余空间</h6><p>同样，将X轴、Y轴全部改为MIRROR模式：<br><code>mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.MIRROR));</code><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747610135490.png" alt="20170219148747610135490.png"><br>先看效果图的X轴：在X轴上每两张图片的显示都像镜子一样翻转一下。<br>同样，在Y轴上每两张图片的显示也都像镜子一样翻转一下。<br>所以这就是镜相效果的作用，镜相效果其实就是在显示下一图片的时候，就相当于两张图片中间放了一个镜子一样。 </p>
<h6 id="（3）、TileMode-CLAMP-用边缘色彩填充多余空间"><a href="#（3）、TileMode-CLAMP-用边缘色彩填充多余空间" class="headerlink" title="（3）、TileMode.CLAMP:用边缘色彩填充多余空间"></a>（3）、TileMode.CLAMP:用边缘色彩填充多余空间</h6><p>同样，我们还是将X轴、Y轴全部改为CLAMP模式：<br><code>mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.CLAMP));</code><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747683989613.png" alt="20170219148747683989613.png"><br>CLAMP模式的意思就是当控件区域超过当前单个图片的大小时，空白位置的颜色填充就用图片的边缘颜色来填充。 </p>
<h6 id="（4）、TileMode-CLAMP与填充顺序"><a href="#（4）、TileMode-CLAMP与填充顺序" class="headerlink" title="（4）、TileMode.CLAMP与填充顺序"></a>（4）、TileMode.CLAMP与填充顺序</h6><p>我们还是先来看一下原图像：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747688447219.png" alt="20170219148747688447219.png"><br>按照我们上面讲的，当X轴、Y轴全部都是CLAMP模式时，X轴的空白区域会用图像的右侧边缘颜色来填充；Y轴的空白区域会用图像的底部的边缘颜色来填充，那效果应该是这样的：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747689784570.png" alt="20170219148747689784570.png"><br>明显右下角的空白位置根本与图像是不沾边的，那它要用什么颜色来填充呢？是填充上方的蓝色还是填充左侧的绿色呢？<br>从最终的效果图来看，这部分填充的颜色是绿色的，可为什么呢？<br>其实这是跟填充顺序有关的，因为我们同时要填充横向和竖向；那到底是先填充横向还是先填充竖向呢？<br>答案是先填充竖向！在填充竖向后的结果如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747691232111.png" alt="20170219148747691232111.png"><br>在填充竖向后，整个竖向都是有颜色的了，此时再根据竖向的边缘色彩来填充横向：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747692478953.png" alt="20170219148747692478953.png"><br>红色方框的区域就是根据竖向的边缘色彩来填充的，这样，当X轴Y轴全是CLAMP时，就理解为什么右下角是填充的绿色而不是蓝色的原因了。 </p>
<h6 id="（5）、当MIRROR与REPEAT混用时"><a href="#（5）、当MIRROR与REPEAT混用时" class="headerlink" title="（5）、当MIRROR与REPEAT混用时"></a>（5）、当MIRROR与REPEAT混用时</h6><p><strong>TileMode.MIRROR, TileMode.REPEAT</strong><br>上面我们在填充X轴 和Y轴的空白位置时，都是用的同一种模式，下面我们就来看一下当X轴与Y轴的填充模式不一样时，效果又是怎样的呢？<br>这里我们假设X轴填充空白区域时，使用MIRROR样式、在填充Y轴空白区域时，使用REPEAT样式：<br><code>mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.REPEAT));</code><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747697328255.png" alt="20170219148747697328255.png"><br>无论哪两种模式混合，我们在理解时只需要记着填充顺序是先填充Y轴，然后再填充X轴！这样效果图就很好理解了<br>首先，是先填充Y轴，在填充Y轴时使用的是REPEAT模式，此时的效果图是：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747698789104.png" alt="20170219148747698789104.png"><br>在填充Y轴以后再利用X轴的镜相模式来填充X轴，这样整个控件就被填充完毕了。<br><strong>TileMode.REPEAT，TileMode.MIRROR</strong><br>下面我们再反过来看一下当X轴使用REPEAT模式，Y轴使用MIRROR模式效果会怎样：<br><code>mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.MIRROR));</code><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747703149559.png" alt="20170219148747703149559.png"><br>同样是先使用镜相模式来填充Y轴，然后再使用REPEAT模式来填充X轴；所以从效果图中可以明显看出第一列的Y轴全部是镜相效果。然后再根据第一列的镜相效果来填充X轴，由于X轴使用的是REPEAT模式，所以X轴的图像全部都与左侧第一列的图像相同。 </p>
<h6 id="（6）、CLAMP模式与其它模式混用"><a href="#（6）、CLAMP模式与其它模式混用" class="headerlink" title="（6）、CLAMP模式与其它模式混用"></a>（6）、CLAMP模式与其它模式混用</h6><p>上面我们理解了填充顺序的意义以后，下面再来看一下最难的两种混用方式，就是当CLAMP模式与其它模式混用时的效果。<br>比如，当X轴使用CLAMP效果填充，而Y轴使用MIRROR效果填充时：<br><code>mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.MIRROR));</code><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747707595558.png" alt="20170219148747707595558.png"><br>从效果图中很好理解，先填充Y轴，填充以后的Y轴各个图像是镜相分布的。而此时再使用CLAMP模式来填充X轴，会拿Y轴图像最边缘的颜色来进行填充。理解难度不大，就不再细讲了。<br>下面再将这两种模式反过来，X轴使用MIRROR模式而Y轴使用CLAMP模式：<br><code>mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP));</code><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747709652890.png" alt="20170219148747709652890.png"><br>想必大家看到效果图以后，也理解为什么会出现这种效果了，这里就不再讲了，如果还不懂，把上面讲的再看一遍。</p>
<h5 id="4、绘图位置与模式的关系"><a href="#4、绘图位置与模式的关系" class="headerlink" title="4、绘图位置与模式的关系"></a>4、绘图位置与模式的关系</h5><p>在上面的例子中，我们利用drawRect把整个控件大小都给覆盖了，那假如我们只画一个小矩形而不完全覆盖整个控件，那我们SetShader的图片是从哪里开始画的呢？<br>是从开始drawRect所绘矩形的左上角开始画，还是在控件的左上角开始的呢？<br>我们举个例子来看下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitmapShaderView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBmp;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShaderView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShaderView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitmapShaderView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge);</div><div class="line">        mPaint.setShader(<span class="keyword">new</span> BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">20</span>,<span class="number">200</span>,<span class="number">200</span>,mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码并没有改变什么，我们需要注意的只有两点：<br>第一：设置的重复模式：<br><code>mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP));</code><br>第二：绘图时，仅绘制一小块矩形：<br><code>canvas.drawRect(100,20,200,200,mPaint);</code><br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874774868194.png" alt="2017021914874774868194.png"><br>这是个什么鬼……根本看不懂啊有木有……我们再回来看一下当所绘矩形覆盖整个控件时的效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747750471319.png" alt="20170219148747750471319.png"><br>而我们这里的效果图根本就是这个完整的图片上扣出来的一小块有没有……  </p>
<blockquote>
<p>其实这正说明了一个问题：无论你利用绘图函数绘多大一块，在哪绘制，与Shader无关。因为Shader总是在控件的左上角开始，而你绘制的部分只是显示出来的部分而已。没有绘制的部分虽然已经生成，但只是不会显示出来罢了。</p>
</blockquote>
<p>利用这个特性，我们就可绘制我们的最上面的望远镜效果了</p>
<h5 id="5、望远镜效果"><a href="#5、望远镜效果" class="headerlink" title="5、望远镜效果"></a>5、望远镜效果</h5><p>我们只需要按照控件大小平铺当前所要绘制的图形的Shader，然后再画出来一个圆圈来当做望远镜就可以了。<br>我们先用一张做为Shader的背景图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148747756525042.png" alt="20170219148747756525042.png"><br>在看完所使用的背景以后，我们再来看下效果图<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219664571469532269_6953.gif" alt="20170219664571469532269_6953.gif"><br>这里有两个功能：<br>首先，将图片拉伸来覆盖整个控件；<br>然后，首先给控件设置进BitmapShader，然后在手指的位置画一个半径为150的圆就可以了。<br>正是由于在Paint设置了Shader以后，无论我们绘图位置在哪，Shader中的图片都是从控件的左上角开始填充的，而我们所使用的绘图函数只是用来指定哪部分显示出来，所以当我们在手指按下位置画上一个圆形时，就会把圆形部分的图像显示出来了，看起来就是个望远镜效果。<br>然后完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelescopeView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBitmap,mBitmapBG;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDx = -<span class="number">1</span>, mDy = -<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TelescopeView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TelescopeView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TelescopeView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.scenery);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                mDx = (<span class="keyword">int</span>) event.getX();</div><div class="line">                mDy = (<span class="keyword">int</span>) event.getY();</div><div class="line">                postInvalidate();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                mDx = (<span class="keyword">int</span>) event.getX();</div><div class="line">                mDy = (<span class="keyword">int</span>) event.getY();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">                mDx = -<span class="number">1</span>;</div><div class="line">                mDy = -<span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        postInvalidate();</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">        <span class="keyword">if</span> (mBitmapBG == <span class="keyword">null</span>)&#123;</div><div class="line">            mBitmapBG = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">            Canvas canvasbg = <span class="keyword">new</span> Canvas(mBitmapBG);</div><div class="line">            canvasbg.drawBitmap(mBitmap,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight()),mPaint);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mDx != -<span class="number">1</span> &amp;&amp; mDy != -<span class="number">1</span>) &#123;</div><div class="line">            mPaint.setShader(<span class="keyword">new</span> BitmapShader(mBitmapBG, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">            canvas.drawCircle(mDx, mDy, <span class="number">150</span>, mPaint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们主要来看下OnDraw函数：<br>在onDraw函数中，第一部分，就是新建一个空白的bitmap，这个bitmap的大小与控件一样，然后把我们的背景图进行拉伸，画到这个空白的bitmap上。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mBitmapBG == <span class="keyword">null</span>)&#123;</div><div class="line">   mBitmapBG = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888);</div><div class="line">   Canvas canvasbg = <span class="keyword">new</span> Canvas(mBitmapBG);</div><div class="line">   canvasbg.drawBitmap(mBitmap,<span class="keyword">null</span>,<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight()),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于这里的canvasbg是用mBitmapBG创建的，所以所画的任何图像都会直接显示在mBitmapBG上，而我们创建的mBitmapBG是与控件一样大的，所以当把mBitmapBG做为Shader来设置给paint时，mBitmapBG会正好覆盖整个控件，而不会有多余的空白像素。<br>这里需要注意的就是我们在将原图像画到mBitmapBG时，进行了拉压缩，把它拉伸到根当前控件一样大小。<br>然后利用Shader的知识，利用OnMotionEvent来捕捉用户的手指位置，当用户手指下按时，在手指位置画一个半径为150的圆形，把对应的位置的图像显示出来就可以了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mDx != -<span class="number">1</span> &amp;&amp; mDy != -<span class="number">1</span>) &#123;</div><div class="line">    mPaint.setShader(<span class="keyword">new</span> BitmapShader(mBitmapBG, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT));</div><div class="line">    canvas.drawCircle(mDx, mDy, <span class="number">150</span>, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个控件的难度并不大，问题就在于理解Shader中图像的起始布局位置和显示图像的关系。</p>
<h4 id="二、利用BitmapShader生成不规则头像"><a href="#二、利用BitmapShader生成不规则头像" class="headerlink" title="二、利用BitmapShader生成不规则头像"></a>二、利用BitmapShader生成不规则头像</h4><p>这部分，我们还得利用Shader的从控件左上角开始布局的原理和显示图像的关系，来讲解一个我们平时经常用到的控件：不规则头像，效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748257725794.png" alt="20170219148748257725794.png">   </p>
<blockquote>
<p>前面我们已经教大家了一种生成不规则头像的方法，大家还记得不，使用xfermode。这篇我们就来讲解另一种生成不规则头像的方法，大家赶紧喜大普奔吧</p>
</blockquote>
<p>这里我们依然教大家如何将它封装成一个控件，这里所实现的效果有：圆形图像，方形带圆角的头像。</p>
<h5 id="1、初步实现圆形头像控件"><a href="#1、初步实现圆形头像控件" class="headerlink" title="1、初步实现圆形头像控件"></a>1、初步实现圆形头像控件</h5><p>这部分，我们先讲原理，初步实现下面的控件效果<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748264221762.png" alt="20170219148748264221762.png"><br>原始的头像是这样的：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748265774913.png" alt="20170219148748265774913.png"><br>很明显我们给头像加了个圆框效果；<br>我们直接来看代码吧：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatorViewDemo</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBitmap;</div><div class="line">    <span class="keyword">private</span> BitmapShader mBitmapShader;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AvatorViewDemo</span><span class="params">(Context context, AttributeSet attrs)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AvatorViewDemo</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.avator);</div><div class="line"></div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mBitmapShader = <span class="keyword">new</span> BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">        Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">        <span class="keyword">float</span> scale = (<span class="keyword">float</span>) getWidth()/mBitmap.getWidth();</div><div class="line">        matrix.setScale(scale,scale);</div><div class="line">        mBitmapShader.setLocalMatrix(matrix);</div><div class="line">        mPaint.setShader(mBitmapShader);</div><div class="line"></div><div class="line">        <span class="keyword">float</span> half = getWidth()/<span class="number">2</span>;</div><div class="line">        canvas.drawCircle(half,half,getWidth()/<span class="number">2</span>,mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先是初始化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.avator);</div><div class="line"></div><div class="line">    mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    mBitmapShader = <span class="keyword">new</span> BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在初始化时创建一个BitmapShader，填充模式分别是TileMode.CLAMP、TileMode.CLAMP，其实这里填充模式没什么用，因为我们只需要显示当前图片；所以不存在多余空白区域，所以使用哪种填充模式都无所谓。<br>最关键的部分在于绘图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">    <span class="keyword">float</span> scale = (<span class="keyword">float</span>) getWidth()/mBitmap.getWidth();</div><div class="line">    matrix.setScale(scale,scale);</div><div class="line">    mBitmapShader.setLocalMatrix(matrix);</div><div class="line">    mPaint.setShader(mBitmapShader);</div><div class="line"></div><div class="line">    <span class="keyword">float</span> half = getWidth()/<span class="number">2</span>;</div><div class="line">    canvas.drawCircle(half,half,getWidth()/<span class="number">2</span>,mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>绘图时，首先是将BitmapShader缩放到与控件宽高一致；由于我们要画的是一个圆形图像，所以我们必须将图像缩放成一个正方形，而边长就与控件的宽度一致即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line"><span class="keyword">float</span> scale = (<span class="keyword">float</span>) getWidth()/mBitmap.getWidth();</div><div class="line">matrix.setScale(scale,scale);</div><div class="line">mBitmapShader.setLocalMatrix(matrix);</div><div class="line">mPaint.setShader(mBitmapShader);</div></pre></td></tr></table></figure></p>
<p>这块就使用了位置矩阵的知识，同时也用上了我们开篇时所讲的mBitmapShader.setLocalMatrix(matrix)函数，有关位置矩阵我们会在后面的章节中涉及，这里只需要知道这块是用来缩放BitmapShader的即可。<br>然后利用BitmapShader是从控件左上角开始平铺的，利用canvas.drawXXX系列函数只是用来定义显示哪一块的原理，我们在图片的正中心画一个圆，半径是图片正方形半径的一半：<br><code>float half = getWidth()/2;</code><br><code>canvas.drawCircle(half,half,getWidth()/2,mPaint);</code><br>在理解了上面的原理之后，再理解这个就难度不大了。<br>我们这里只画了个圆形，如果我们画一个矩形，那显示的控件就是个矩形了，如果我们画一个五角形，那头像也就是个五角形效果了；<br>原理到这里就讲完了，下面我们先来看几个开源例子，然后再继续讲解如何将其封装成控件的知识。<br>下面我们来看一下几个开源的例子：<br>地址：<a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="external">https://github.com/hdodenhof/CircleImageView</a><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748298271112.png" alt="20170219148748298271112.png"><br>这个效果大家现在会做了没，它不仅实现了圆形头像效果，还而还在外边加了一个带颜色的边。<br>想必在头像外围加个描边不是什么给事吧……悄悄提醒一下，只需要在画圆时，将paint设置为mPaint.setStyle(Paint.Style.STROKE);即可画出来描边。大家自己试试怎么来实现这个控件吧。第二个开源例子：<br>地址：<a href="https://github.com/MostafaGazar/CustomShapeImageView" target="_blank" rel="external">https://github.com/MostafaGazar/CustomShapeImageView</a><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748303784132.png" alt="20170219148748303784132.png"><br>具体这些效果在这个控件中是怎么实现的，我也没有看。但敢肯定的是，通过BitmapShape是肯定可以实现的，只要我们利用Path可以做出各种图形（比如这里的五角形，这里的心形），然后利用canvas在Shape上显示出来这块区域就可以了。但明显难度是比较大的，所以对于这类复杂的图像显示，还是建议使用以前我们讲过的Xfermode来做图像混合即可。<br>好了，原理就讲到这了，下面我们把上面的圆形控件加以封装，做出来一个通用控件</p>
<h5 id="2、封装成控件"><a href="#2、封装成控件" class="headerlink" title="2、封装成控件"></a>2、封装成控件</h5><p>上篇文章已经教大家如何封装成控件了，这部分我们再来看这个例子是如何封装成控件的。<br>我们再重新来看一下效果图，看我们这部分要做哪些效果出来<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748306720671.png" alt="20170219148748306720671.png"><br>从效果图来看，我们要做两个效果：</p>
<ul>
<li>圆形图像</li>
<li>矩形图像，但带自定义大小的圆角</li>
</ul>
<h6 id="（1）、自定义属性"><a href="#（1）、自定义属性" class="headerlink" title="（1）、自定义属性"></a>（1）、自定义属性</h6><p>封装控件最难免的就是自定义属性了，这块是必会的。<br>根据我们需要做的两个效果，所以我们自定义属性时，首先要有一个属性来标识当前是做圆形头像还是做矩形图像<br>然后如果是矩形图像，还要有一个值来表示矩形图像的圆角有多大<br>最后，还需要一个src的属性来让用户引入Bitmap图像<br>所以，此时的定义属性应该是：（values/attrs.xml）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"AvatorView"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"src"</span> <span class="attr">format</span>=<span class="string">"reference"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"format"</span> <span class="attr">format</span>=<span class="string">"enum"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"circle"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">"rectTangle"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">attr</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"radius"</span> <span class="attr">format</span>=<span class="string">"integer"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里定义了三个属性：</p>
<ul>
<li>src：对应BitmapShader所需要使用的图片</li>
<li>format：是一个枚举值，用于指定当前是做圆形图像还是做矩形图像</li>
<li>radius：是矩形图像时的边角圆形半径</li>
</ul>
<h6 id="（2）、控件解析"><a href="#（2）、控件解析" class="headerlink" title="（2）、控件解析"></a>（2）、控件解析</h6><p>在自定义的属性之后，我们就开始我们自定义控件的Java代码征程了，首先是解析自定义属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvatorView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> Bitmap mBitmap;</div><div class="line">    <span class="keyword">private</span> BitmapShader mBitmapShader;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mEnumFormat =<span class="number">0</span>,mRadius = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AvatorView</span><span class="params">(Context context, AttributeSet attrs)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AvatorView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init(context,attrs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context,AttributeSet attrs)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 提取属性定义</div><div class="line">         */</div><div class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.AvatorView);</div><div class="line">        <span class="keyword">int</span> BitmapID = typedArray.getResourceId(R.styleable.AvatorView_src,-<span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (BitmapID == -<span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"AvatorView 需要定义Src属性,而且必须是图像"</span>);</div><div class="line">        &#125;</div><div class="line">        mBitmap = BitmapFactory.decodeResource(getResources(),BitmapID);</div><div class="line">        mEnumFormat = typedArray.getInt(R.styleable.AvatorView_format,<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (mEnumFormat == <span class="number">1</span>)&#123;</div><div class="line">            mRadius = typedArray.getInt(R.styleable.AvatorView_radius,<span class="number">5</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        typedArray.recycle();</div><div class="line"></div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">        mBitmapShader = <span class="keyword">new</span> BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);</div><div class="line">    &#125;</div><div class="line">    …………</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这部分与上篇相同，就不再讲了，无外乎就是在初始化的时候解析控件自定义属性，没什么难度。 </p>
<h6 id="（3）、自测量"><a href="#（3）、自测量" class="headerlink" title="（3）、自测量"></a>（3）、自测量</h6><p>然后我们需要在用户定义layout_width、layout_height的值为wrap_content时，自测量控件大小<br>即重写onMeasuer()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">int</span> measureWidth = MeasureSpec.getSize(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> measureHeight = MeasureSpec.getSize(heightMeasureSpec);</div><div class="line">    <span class="keyword">int</span> measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</div><div class="line">    <span class="keyword">int</span> measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> width = mBitmap.getWidth();</div><div class="line">    <span class="keyword">int</span> height = mBitmap.getHeight();</div><div class="line">    setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要就是当用户将控件的layout_with或者layout_heigt设置成wrap_content时，将宽高设置成图片的宽高。这块我们在上篇也已经讲过了，这里也就不再细讲了。不理解的同学自行翻看上一篇。 </p>
<h6 id="（4）、绘图"><a href="#（4）、绘图" class="headerlink" title="（4）、绘图"></a>（4）、绘图</h6><p>最后一部分，到了正式绘图了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">    <span class="keyword">float</span> scale = (<span class="keyword">float</span>) getWidth()/mBitmap.getWidth();</div><div class="line">    matrix.setScale(scale,scale);</div><div class="line">    mBitmapShader.setLocalMatrix(matrix);</div><div class="line">    mPaint.setShader(mBitmapShader);</div><div class="line"></div><div class="line">    <span class="keyword">float</span> half = getWidth()/<span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mEnumFormat == <span class="number">0</span>)&#123;</div><div class="line">        canvas.drawCircle(half,half,getWidth()/<span class="number">2</span>,mPaint);</div><div class="line">    &#125;<span class="keyword">else</span>  <span class="keyword">if</span>(mEnumFormat == <span class="number">1</span>)&#123;</div><div class="line">        canvas.drawRoundRect(<span class="keyword">new</span> RectF(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight()),mRadius,mRadius,mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>也没啥难度，就是先放大BitmapShader到与控件相同大小，然后根据用户要画的是圆形还是圆角矩形，调用不同的绘图函数即可。 </p>
<h6 id="（5）、XML中使用"><a href="#（5）、XML中使用" class="headerlink" title="（5）、XML中使用"></a>（5）、XML中使用</h6><p>然后我们来看如何在布局中使用这个控件(main.xml)：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">              <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res/com.harvic.Blog_BitmapShader"</span></div><div class="line">              <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">              <span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">              <span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.Blog_BitmapShader.AvatorView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"50dp"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"50dp"</span></div><div class="line">        <span class="attr">app:src</span>=<span class="string">"@drawable/avator"</span></div><div class="line">        <span class="attr">app:format</span>=<span class="string">"circle"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.Blog_BitmapShader.AvatorView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></div><div class="line">            <span class="attr">app:src</span>=<span class="string">"@drawable/avator"</span></div><div class="line">            <span class="attr">app:format</span>=<span class="string">"circle"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.Blog_BitmapShader.AvatorView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></div><div class="line">            <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></div><div class="line">            <span class="attr">app:src</span>=<span class="string">"@drawable/avator"</span></div><div class="line">            <span class="attr">app:format</span>=<span class="string">"rectTangle"</span></div><div class="line">            <span class="attr">app:radius</span>=<span class="string">"10"</span>/&gt;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.Blog_BitmapShader.AvatorView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"130dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"130dp"</span></div><div class="line">            <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></div><div class="line">            <span class="attr">app:src</span>=<span class="string">"@drawable/avator"</span></div><div class="line">            <span class="attr">app:format</span>=<span class="string">"rectTangle"</span></div><div class="line">            <span class="attr">app:radius</span>=<span class="string">"30"</span>/&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">com.harvic.Blog_BitmapShader.AvatorView</span></span></div><div class="line">            <span class="attr">android:layout_width</span>=<span class="string">"150dp"</span></div><div class="line">            <span class="attr">android:layout_height</span>=<span class="string">"150dp"</span></div><div class="line">            <span class="attr">android:layout_marginTop</span>=<span class="string">"10dp"</span></div><div class="line">            <span class="attr">app:src</span>=<span class="string">"@drawable/avator"</span></div><div class="line">            <span class="attr">app:format</span>=<span class="string">"rectTangle"</span></div><div class="line">            <span class="attr">app:radius</span>=<span class="string">"70"</span>/&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>效果图就是如开篇所示，从布局代码中可以看到，我们已经实现了这个自定义控件，我们不仅可以指定大小，而且还可以使用wrap_content来自适应大小。我这里没有使用wrap_content的主要原因在于图片太大，使用wrap_content的话就画不了几张图了，大家底下自已试试吧 </p>
<h6 id="（6）、存在问题"><a href="#（6）、存在问题" class="headerlink" title="（6）、存在问题"></a>（6）、存在问题</h6><p>有些同学每次都是拿博主控件直接用到项目中，这可是不行的哦，因为博主在这里讲的自定义控件都是抛砖引玉的，主要核心在原理讲解，并没有做太多的容错的……<br>这个控件也不例外，我们这里强制使用的正方的图像，当图像是矩形时，就会出现问题，大家需要自己做容错处理，判断图像的宽高，缩放图像以至在不改变图片比例的情况下，填充控件。<br>这篇文章就到这了，下篇继续来看Shader的其它派生类的用法和实例。</p>
<h3 id="五、LinearGradient与闪动文字效果"><a href="#五、LinearGradient与闪动文字效果" class="headerlink" title="五、LinearGradient与闪动文字效果"></a>五、LinearGradient与闪动文字效果</h3><p>这篇就给大家讲setShader的另一个参数，LinearGradient，使用过shape标签的同学，对这个方法估计都不莫生，就是线性渐变。跟PhotoShop中的线性渐变的原理和作用是一样的。这篇文章的最终会实现一个闪动文字效果控件：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219137201472431756_8442.gif" alt="20170219137201472431756_8442.gif"></p>
<h4 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h4><p><gradient>标签的用法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">gradient</span>   </span></div><div class="line">    <span class="attr">android:type</span>=<span class="string">[</span>"<span class="attr">linear</span>" | "<span class="attr">radial</span>" | "<span class="attr">sweep</span>"]    //共有<span class="attr">3</span>中渐变类型，线性渐变（默认）/放射渐变/扫描式渐变    </div><div class="line">    <span class="attr">android:angle</span>=<span class="string">"integer"</span>     //渐变角度，必须为<span class="attr">45</span>的倍数，<span class="attr">0</span>为从左到右，<span class="attr">90</span>为从上到下    </div><div class="line">    <span class="attr">android:centerX</span>=<span class="string">"float"</span>     //渐变中心<span class="attr">X</span>的相当位置，范围为<span class="attr">0</span>～<span class="attr">1</span>    </div><div class="line">    <span class="attr">android:centerY</span>=<span class="string">"float"</span>     //渐变中心<span class="attr">Y</span>的相当位置，范围为<span class="attr">0</span>～<span class="attr">1</span>    </div><div class="line">    <span class="attr">android:startColor</span>=<span class="string">"color"</span>   //渐变开始点的颜色    </div><div class="line">    <span class="attr">android:centerColor</span>=<span class="string">"color"</span>  //渐变中间点的颜色，在开始与结束点之间    </div><div class="line">    <span class="attr">android:endColor</span>=<span class="string">"color"</span>    //渐变结束点的颜色    </div><div class="line">    <span class="attr">android:gradientRadius</span>=<span class="string">"float"</span>  //渐变的半径，只有当渐变类型为<span class="attr">radial</span>时才能使用    </div><div class="line">    <span class="attr">android:useLevel</span>=<span class="string">[</span>"<span class="attr">true</span>" | "<span class="attr">false</span>"] /&gt;  //使用LevelListDrawable时就要设置为true。设为false时才有渐变效果</div></pre></td></tr></table></figure></gradient></p>
<p>其中的渐变类型有”linear” | “radial” | “sweep”,在代码中对应的类分别是LinearGradient、RaialGradient、SweepGradient；有关<gradient>各个渐变效果的用法，不知道的同学强烈建议你先看看这篇文章。<br>这篇我们要讲就是线性渐变的LinearGradient；  </gradient></p>
<h4 id="二、LinearGradient基本使用"><a href="#二、LinearGradient基本使用" class="headerlink" title="二、LinearGradient基本使用"></a>二、LinearGradient基本使用</h4><h5 id="1、构造函数-1"><a href="#1、构造函数-1" class="headerlink" title="1、构造函数"></a>1、构造函数</h5><p>我们先来看下LinearGradient的构造函数：<br><strong>第一个构造函数：</strong><br><code>public LinearGradient(float x0, float y0, float x1, float y1,int color0, int color1, TileMode tile)</code><br>用过PhotoShop的线性激变工具的同学，应该都知道，线性渐变其实是在指定的两个点之间填充渐变颜色。 </p>
<ul>
<li>参数中的(x0,y0)就是起始渐变点坐标，参数中(x1,y1)就是结束渐变点坐标； </li>
<li>color0就是起始颜色，color1就是终止颜色；颜色值必须使用0xAARRGGBB形式的16进制表示！表示透明度的AA一定不能少。 </li>
<li>TileMode tile：与BitmapShader一样，用于指定控件区域大于指定的渐变区域时，空白区域的颜色填充方法。</li>
</ul>
<p>很显然！这个方法，只能指定两种颜色之间的渐变。如果需要多种颜色之间的渐变，就需要使用下面的这个构造函数了。</p>
<p><strong>第二个构造函数：</strong><br><code>public LinearGradient(float x0, float y0, float x1, float y1,int colors[], float positions[], TileMode tile)</code><br>同样，(x0,y0)就是起始渐变点坐标，参数中(x1,y1)就是结束渐变点坐标<br>colors[]用于指定渐变的颜色值数组，同样，颜色值必须使用0xAARRGGBB形式的16进制表示！表示透明度的AA一定不能少。<br>positions[]与渐变的颜色相对应，取值是0-1的float类型，表示在每一个颜色在整条渐变线中的百分比位置  </p>
<h5 id="2、两色渐变使用示例"><a href="#2、两色渐变使用示例" class="headerlink" title="2、两色渐变使用示例"></a>2、两色渐变使用示例</h5><p>我们先来看看两色渐变的构造函数是如何来使用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearGradientView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearGradientView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearGradientView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearGradientView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">        mPaint.setShader(<span class="keyword">new</span> LinearGradient(<span class="number">0</span>,getHeight()/<span class="number">2</span>,getWidth(),getHeight()/<span class="number">2</span>,<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>, Shader.TileMode.CLAMP));</div><div class="line">        canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很简单，只需要在绘图的时候构造LinearGradient实例，通过Paint.setShader设置进去即可。<br>大家注意一下，我这里设置的渐变范围是从控件的左边中点到右边中点：<br><code>mPaint.setShader(new LinearGradient(0,getHeight()/2,getWidth(),getHeight()/2,0xffff0000,0xff00ff00, Shader.TileMode.CLAMP));</code><br>最后通过canvas.drawRect把整个控件区域画出来：<br><code>canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);</code><br>这里大家注意一下，上面我们也已经提到了，颜色值必须使用0xAARRGGBB的完整16进制的颜色样式表示，我们这里的颜色值就是0xffff0000和0xff00ff00；大家自己可以进行尝试，如果把红色的透明度值去掉，改写成0xff00000，是不会有任何显示的。<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874878569594.png" alt="2017021914874878569594.png"></p>
<h5 id="3、多色渐变使用示例"><a href="#3、多色渐变使用示例" class="headerlink" title="3、多色渐变使用示例"></a>3、多色渐变使用示例</h5><p>下面我们来看第二个构造函数，多色渐变的使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    <span class="keyword">int</span>[] colors = &#123;<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>,<span class="number">0xff0000ff</span>,<span class="number">0xffffff00</span>,<span class="number">0xff00ffff</span>&#125;;</div><div class="line">    <span class="keyword">float</span>[]  pos = &#123;<span class="number">0f</span>,<span class="number">0.2f</span>,<span class="number">0.4f</span>,<span class="number">0.6f</span>,<span class="number">1.0f</span>&#125;;</div><div class="line">    LinearGradient multiGradient = <span class="keyword">new</span> LinearGradient(<span class="number">0</span>,getHeight()/<span class="number">2</span>,getWidth(),getHeight()/<span class="number">2</span>,colors,pos, Shader.TileMode.CLAMP);</div><div class="line">    mPaint.setShader(multiGradient);</div><div class="line">    canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这里可以看出，渐变的开始点同样是控件左边中点，渐变的结束点也同样是控件右边中点；这里我们指定了五种渐变颜色，而且指定了每个颜色的位置，前四种颜色是按20%均匀分布的，最后两种颜色相距40%；最后通过canvas.drawRect把整个控件区域画出来<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874879074974.png" alt="2017021914874879074974.png"></p>
<blockquote>
<p><strong>注意</strong>:colors和pos的个数一定要相等，也就是说必须指定每一个颜色值的位置！如果多或少都会直接报错：（Signal 11是SO内部错误）<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748794539950.png" alt="20170219148748794539950.png"></p>
</blockquote>
<h5 id="4、渐变起始坐标与填充的关系——矩形填充"><a href="#4、渐变起始坐标与填充的关系——矩形填充" class="headerlink" title="4、渐变起始坐标与填充的关系——矩形填充"></a>4、渐变起始坐标与填充的关系——矩形填充</h5><p>我们上面的示例中都是从控件左边中间到控件右边中点；如果我们改成从左上角到右上角的填充方式，结果会怎样呢？<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">    int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;;</div><div class="line">    float[]  pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;;</div><div class="line">    LinearGradient multiGradient = new LinearGradient(0,0,getWidth(),getHeight(),colors,pos, Shader.TileMode.CLAMP);</div><div class="line">    mPaint.setShader(multiGradient);</div><div class="line">    canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">渐变线是从控件的左上角到控件的右下角位置：</div><div class="line">`LinearGradient multiGradient = new LinearGradient(0,0,getWidth(),getHeight(),colors,pos, Shader.TileMode.CLAMP);`  </div><div class="line">效果图：  </div><div class="line">![2017021914874880007490.png](http://ohtrrgyyd.bkt.clouddn.com/2017021914874880007490.png)  </div><div class="line">原理图：  </div><div class="line">![20170219148748802635587.png](http://ohtrrgyyd.bkt.clouddn.com/20170219148748802635587.png)  </div><div class="line"></div><div class="line">就是说，首先是两个渐变点之间连线，然后以连线为对角线形成一个矩形，各种颜色都是以这条对角线为矩形的填充的。</div><div class="line"></div><div class="line">##### 5、TileMode重复方式</div><div class="line">在讲到BitmapShader的时候，我们已经详细讲过TileMode的意义：当控件区域大小渐变区域时，用于填充空白位置的。   </div><div class="line">下面我们就逐个看一下TileMode不同时，对于线性渐变的有什么作用。   </div><div class="line"></div><div class="line">###### （1）、X、Y轴共用填充参数 </div><div class="line">首先，我们再回来看一下LinearGradient的构造函数：</div><div class="line">`public LinearGradient(float x0, float y0, float x1, float y1,int colors[], float positions[], TileMode tile)`  </div><div class="line">`public LinearGradient(float x0, float y0, float x1, float y1,int color0, int color1, TileMode tile)`  </div><div class="line">从构造函数中可以看出，LiearGradient只有一个TileMode参数，这说明X轴与Y轴共用这一个TileMode填充参数，而不能像BitmapShader那样分别指定X轴与Y轴的填充参数。 </div><div class="line"></div><div class="line">###### （2）、TileMode.CLAMP</div><div class="line">``` java</div><div class="line">protected void onDraw(Canvas canvas) &#123;</div><div class="line">    super.onDraw(canvas);</div><div class="line">////        多色渐变</div><div class="line">    int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;;</div><div class="line">    float[]  pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;;</div><div class="line">    LinearGradient multiGradient = new LinearGradient(0,0,getWidth()/2,getHeight()/2,colors,pos, Shader.TileMode.CLAMP);</div><div class="line">    mPaint.setShader(multiGradient);</div><div class="line">    canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里做了一个多色渐变，渐变点是从(0,0)到屏幕的中间点(width/2,height.2)；<br>效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874881977801.png" alt="2017021914874881977801.png"><br>从效果图中可以看到，效果很好理解，就是以(0,0)到(width/2,height.2)为矩形对角线，来填充各种颜色渐变，对于之外的区域，用边缘色彩来填充。   </p>
<h6 id="（3）、TileMode-REPEAT"><a href="#（3）、TileMode-REPEAT" class="headerlink" title="（3）、TileMode.REPEAT"></a>（3）、TileMode.REPEAT</h6><p>同样是上面的代码，渐变点是从(0,0)到屏幕的中间点(width/2,height.2)，当空白区域填充模式改为TileMode.REPEAT时，效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874882415260.png" alt="2017021914874882415260.png"><br>大家初次看到这个效果，可能一脸懵逼 —_—!!!, 其实也不难理解，我们需要先找到哪块是我们的渐变，哪块是空白像素的填充：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748827185995.png" alt="20170219148748827185995.png"><br>在这个图中，蓝色块是我们原始的渐变图形，从从(0,0)到屏幕的中间点(width/2,height.2)，另外的没有遮起来的部分是空白位置填充的。<br>在填充时，结束点做为填充点的起点，即填充的线性渐变的位置为从(width/2,height/2)到(width,height)，即从中间点到右下角点位置的填充。   </p>
<h6 id="（4）、TileMode-MIRROR"><a href="#（4）、TileMode-MIRROR" class="headerlink" title="（4）、TileMode.MIRROR"></a>（4）、TileMode.MIRROR</h6><p>同样，如果我们把填充模式改为镜像模式，效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748830053945.png" alt="20170219148748830053945.png"></p>
<h5 id="6、填充方式：从控件左上角开始填充"><a href="#6、填充方式：从控件左上角开始填充" class="headerlink" title="6、填充方式：从控件左上角开始填充"></a>6、填充方式：从控件左上角开始填充</h5><p>与BitmapShader一样，同样是从控件左上角开始填充整个控件，利用canvas.drawXXX系列函数只是用来指定显示哪一块<br>比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">     <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">     <span class="comment">//多色渐变</span></div><div class="line">     <span class="keyword">int</span>[] colors = &#123;<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>,<span class="number">0xff0000ff</span>,<span class="number">0xffffff00</span>,<span class="number">0xff00ffff</span>&#125;;</div><div class="line">     <span class="keyword">float</span>[]  pos = &#123;<span class="number">0f</span>,<span class="number">0.2f</span>,<span class="number">0.4f</span>,<span class="number">0.6f</span>,<span class="number">1.0f</span>&#125;;</div><div class="line">     LinearGradient multiGradient = <span class="keyword">new</span> LinearGradient(<span class="number">0</span>,<span class="number">0</span>,getWidth()/<span class="number">2</span>,getHeight()/<span class="number">2</span>,colors,pos, Shader.TileMode.MIRROR);</div><div class="line">     mPaint.setShader(multiGradient);</div><div class="line">     canvas.drawRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">200</span>,<span class="number">200</span>,mPaint);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>同样是使用镜像模式，但我们不再全屏绘制，而只是绘出其中一小部分：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748834620681.png" alt="20170219148748834620681.png"><br>我们再来看看全屏绘制的镜像模式的效果图：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748836041948.png" alt="20170219148748836041948.png"><br>很明显，这里所绘制的一小块，跟从全屏绘制的效果图上摘下来的一块一样。  </p>
<blockquote>
<p>这就说明了：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块</p>
</blockquote>
<p>我们说了如果利用drawXXX系列函数只是用来指定显示哪一块，那如果我们利用DrawText来显示，那是不是就会显示出彩色文字了？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">   <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">   <span class="comment">//多色渐变</span></div><div class="line">   <span class="keyword">int</span>[] colors = &#123;<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>,<span class="number">0xff0000ff</span>,<span class="number">0xffffff00</span>,<span class="number">0xff00ffff</span>&#125;;</div><div class="line">   <span class="keyword">float</span>[]  pos = &#123;<span class="number">0f</span>,<span class="number">0.2f</span>,<span class="number">0.4f</span>,<span class="number">0.6f</span>,<span class="number">1.0f</span>&#125;;</div><div class="line">   LinearGradient multiGradient = <span class="keyword">new</span> LinearGradient(<span class="number">0</span>,<span class="number">0</span>,getWidth()/<span class="number">2</span>,getHeight()/<span class="number">2</span>,colors,pos, Shader.TileMode.MIRROR);</div><div class="line">   mPaint.setShader(multiGradient);</div><div class="line">   mPaint.setTextSize(<span class="number">50</span>);</div><div class="line">   canvas.drawText(<span class="string">"欢迎关注启舰的blog"</span>,<span class="number">0</span>,<span class="number">200</span>,mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748844135403.png" alt="20170219148748844135403.png"></p>
<p>有没有感觉很酷炫……看似牛逼的效果其实就是这么简单……<br>如果我们把渐变效果移动起来，就直接实现了我们开篇时说的文字渐变的动画效果了。<br>下面我们加入动画，让颜色动起来吧  </p>
<h4 id="三、闪光字符串实现"><a href="#三、闪光字符串实现" class="headerlink" title="三、闪光字符串实现"></a>三、闪光字符串实现</h4><p>这部分我们要实现的效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/201702191018820160829092349307.gif" alt="201702191018820160829092349307.gif"></p>
<p>闪光效果有木有……看起来很碉堡吧，我们就来具体看下原理吧，这个控件只给大家讲基本原理，就不再封装成控件了。<br>我们先来看下原理图：</p>
<h5 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h5><h6 id="（1）、初始状态"><a href="#（1）、初始状态" class="headerlink" title="（1）、初始状态"></a>（1）、初始状态</h6><p>首先，我们要有一个渐变的LinearGradient,颜色是从文字颜色的黑色到中间的绿色，然后再到黑色，填充模式为 Shader.TileMode.CLAMP，初始的位置在文字的左侧；<br>对应图像为：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748856029218.png" alt="20170219148748856029218.png"></p>
<p>我这里为了表述文字效果，特地做了几个处理；   </p>
<ul>
<li>首先我把渐变图像用红边框了起来。由于填充模式是Shader.TileMode.CLAMP，所以右侧文字的位置会被填充为边缘颜色黑色 </li>
<li>为了表述当前文字的位置，我特地把文字写成了红色。而文字真正的颜色应该是其底部LinearGradient的填充色才对的，大家这点注意。<br>对应代码为：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mLinearGradient = <span class="keyword">new</span> LinearGradient(- getMeasuredWidth(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</div><div class="line">        getCurrentTextColor(),<span class="number">0xff00ff00</span>,getCurrentTextColor()&#125;,</div><div class="line">        <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">                <span class="number">0</span>,</div><div class="line">                <span class="number">0.5f</span>,</div><div class="line">                <span class="number">1</span></div><div class="line">        &#125;,</div><div class="line">        Shader.TileMode.CLAMP</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h6 id="（2）、运动中"><a href="#（2）、运动中" class="headerlink" title="（2）、运动中"></a>（2）、运动中</h6><p>下图显示的是当渐变的LinearGradient移动到文字部分的时的状态<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748862533506.png" alt="20170219148748862533506.png"><br>由于使用的是Shader.TileMode.CLAMP填充模式，所以两次空白区域都会被填充为LinearGradient的边缘颜色，即文字的黑色。<br>上面我们讲了，文字会显示其下方LinearGradient的填充颜色，所以现在文字的文字就会有一部分变绿了。</p>
<h6 id="（3）、终止状态"><a href="#（3）、终止状态" class="headerlink" title="（3）、终止状态"></a>（3）、终止状态</h6><p>在终止状态时，LinearGradient移动到文字的右侧<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874886493651.png" alt="2017021914874886493651.png"><br>同样是由于Shader.TileMode.CLAMP填充模式，文字会被填充为文字原本的颜色。</p>
<blockquote>
<p>从上面的原理中，我们需要理出来几个点：<br>第一：创建的LinearGradient渐变的构造方法，前面已经列出来代码了，初始位置是在文字左侧的，而且大小与文字所占位置相同，填充模式使用边缘填充<br>第二：从起始位置和终止位置可以看出，LinearGradient渐变的运动长度是两个文字的长度。  </p>
</blockquote>
<h5 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><p>其实看了原理之后，实现起来就没有什么难度了，我们还是列出完整代码，然后针对性的讲一点就可以了，如果大家还没看懂，可以把示例源码下下来，自己再研究研究<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShimmerTextView</span> <span class="keyword">extends</span> <span class="title">TextView</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mDx;</div><div class="line">    <span class="keyword">private</span> LinearGradient mLinearGradient;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShimmerTextView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShimmerTextView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShimmerTextView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        mPaint =getPaint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</div><div class="line"></div><div class="line">        ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">2</span>*getMeasuredWidth());</div><div class="line">        animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">                mDx = (Integer) animation.getAnimatedValue();</div><div class="line">                postInvalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        animator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">        animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">        animator.setDuration(<span class="number">2000</span>);</div><div class="line">        animator.start();</div><div class="line"></div><div class="line">        mLinearGradient = <span class="keyword">new</span> LinearGradient(- getMeasuredWidth(),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;</div><div class="line">                getCurrentTextColor(),<span class="number">0xff00ff00</span>,getCurrentTextColor()</div><div class="line">        &#125;,</div><div class="line">                <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</div><div class="line">                        <span class="number">0</span>,</div><div class="line">                        <span class="number">0.5f</span>,</div><div class="line">                        <span class="number">1</span></div><div class="line">                &#125;,</div><div class="line">                Shader.TileMode.CLAMP</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">        Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">        matrix.setTranslate(mDx,<span class="number">0</span>);</div><div class="line">        mLinearGradient.setLocalMatrix(matrix);</div><div class="line">        mPaint.setShader(mLinearGradient);</div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="1、派生自TextView"><a href="#1、派生自TextView" class="headerlink" title="1、派生自TextView"></a>1、派生自TextView</h6><p>首先需要注意的是，控件派生自TextView，所以可以使用TextView的自带方法getCurrentTextColor()来获取文字颜色。   </p>
<h6 id="2、如何移动LinearGradient"><a href="#2、如何移动LinearGradient" class="headerlink" title="2、如何移动LinearGradient"></a>2、如何移动LinearGradient</h6><p>然后，上面我们讲了如何给文字加上渐变效果，其实让它动起来办法很简单，还记得我们说过Shader有一个setLocalMatrix(Matrix localM) 方法可以设置位置矩阵么，我们只需要给LinearGradient设置上逐渐平移的矩阵就可以了。<br>比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line"></div><div class="line">    Matrix matrix = <span class="keyword">new</span> Matrix();</div><div class="line">    matrix.setTranslate(mDx,<span class="number">0</span>);</div><div class="line">    mLinearGradient.setLocalMatrix(matrix);</div><div class="line">    mPaint.setShader(mLinearGradient);</div><div class="line"></div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中向右偏移的距离mDx，是由ValueAnimator生成的； </p>
<h6 id="3、ValueAnimator的创建"><a href="#3、ValueAnimator的创建" class="headerlink" title="3、ValueAnimator的创建"></a>3、ValueAnimator的创建</h6><p>前面我们讲了LinearGradient移动距离是从0到两倍的text距离，我们通过getMeasuredWidth()可以得到TextView的宽度，乘以2就可以了，创建代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">ValueAnimator animator = ValueAnimator.ofInt(<span class="number">0</span>,<span class="number">2</span>*getMeasuredWidth());</div><div class="line">animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">        mDx = (Integer) animation.getAnimatedValue();</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">animator.setRepeatMode(ValueAnimator.RESTART);</div><div class="line">animator.setRepeatCount(ValueAnimator.INFINITE);</div><div class="line">animator.setDuration(<span class="number">2000</span>);</div><div class="line">animator.start();</div></pre></td></tr></table></figure></p>
<h2 id="六、RadialGradient与水波纹按钮效果"><a href="#六、RadialGradient与水波纹按钮效果" class="headerlink" title="六、RadialGradient与水波纹按钮效果"></a>六、RadialGradient与水波纹按钮效果</h2><p>这篇将是Shader的最后一篇，下部分，我们将讲述Canvas变换的知识。在讲完Canvas变换以后，就正式进入第三部曲啦，是不是有点小激动呢……</p>
<p>今天给大家讲的效果是使用RadialGradient来实现水波纹按钮效果，水波纹效果是Android L平台上自带的效果，这里我们就看看它是如何实现的，本篇的最终效果图如下<br><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021977001474722293_8182.gif" alt="2017021977001474722293_8182.gif"></p>
<h3 id="一、RadialGradient详解"><a href="#一、RadialGradient详解" class="headerlink" title="一、RadialGradient详解"></a>一、RadialGradient详解</h3><p>RadialGradient的意思是放射渐变，即它会向一个放射源一样，从一个点开始向外从一个颜色渐变成另一种颜色；</p>
<h4 id="1、构造函数-2"><a href="#1、构造函数-2" class="headerlink" title="1、构造函数"></a>1、构造函数</h4><p>RadialGradient有两个构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两色渐变</span></div><div class="line">RadialGradient(<span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY, <span class="keyword">float</span> radius, <span class="keyword">int</span> centerColor, <span class="keyword">int</span> edgeColor, Shader.TileMode tileMode)</div><div class="line"><span class="comment">//多色渐变</span></div><div class="line">RadialGradient(<span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY, <span class="keyword">float</span> radius, <span class="keyword">int</span>[] colors, <span class="keyword">float</span>[] stops, Shader.TileMode tileMode)</div></pre></td></tr></table></figure></p>
<h5 id="（1）、两色渐变构造函数使用实例"><a href="#（1）、两色渐变构造函数使用实例" class="headerlink" title="（1）、两色渐变构造函数使用实例"></a>（1）、两色渐变构造函数使用实例</h5><p>下面我们来看一下两色渐变构造函数的使用方法。<br><code>RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode)</code><br>这个两色渐变的构造函数的各项参数意义如下：  </p>
<ul>
<li>centerX：渐变中心点X坐标</li>
<li>centerY：渐变中心点Y坐标</li>
<li>radius：渐变半径</li>
<li>centerColor：渐变的起始颜色，即渐变中心点的颜色,取值类型必须是八位的0xAARRGGBB色值！透明底Alpha值不能省略，不然不会显示出颜色。</li>
<li>edgeColor：渐变结束时的颜色，即渐变圆边缘的颜色，同样，取值类型必须是八位的0xAARRGGBB色值！</li>
<li>TileMode：与我们前面讲的各个Shader一样，用于指定当控件区域大于指定的渐变区域时，空白区域的颜色填充方式。</li>
</ul>
<p>下面我们举个例子来看下用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleColorRadialGradientView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> RadialGradient mRadialGradient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRadius = <span class="number">100</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleColorRadialGradientView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleColorRadialGradientView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleColorRadialGradientView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line"></div><div class="line">        mRadialGradient = <span class="keyword">new</span> RadialGradient(w/<span class="number">2</span>,h/<span class="number">2</span>,mRadius,<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>, Shader.TileMode.REPEAT);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawCircle(getWidth()/<span class="number">2</span>,getHeight()/<span class="number">2</span>,mRadius,mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码量不大，这里首先在onSizeChange中，创建RadialGradient实例。onSizeChange会在布局发生改变时调用，onSizeChanged(int w, int h, int oldw, int oldh)传过来四个参数，前两个参数就代表当前控件所应显示的宽和高。有关onSizeChange的具体意义，我们会在第三部曲讲解回调函数流程中具体讲到，这里大家就先理解到这吧。<br>在onSizeChange中，我们创建了一个RadialGradient，以控件的中心点为圆点，创建一个半径为mRadius的，从0xffff0000到0xff00ff00的放射渐变。我们这里指定的空白填充方式为Shader.TileMode.REPEAT。<br>然后在绘图的时候：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    canvas.drawCircle(getWidth()/<span class="number">2</span>,getHeight()/<span class="number">2</span>,mRadius,mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在绘图时，依然是以控件中心点为圆心，画一个半径为mRadius的圆；注意我们画的圆的大小与所构造的放射渐变的大小是一样的，所以不存在空白区域的填充问题。 </p>
<p>效果图如下：<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748927476934.png" alt="20170219148748927476934.png"></p>
<h5 id="（2）、多色渐变构造函数使用实例"><a href="#（2）、多色渐变构造函数使用实例" class="headerlink" title="（2）、多色渐变构造函数使用实例"></a>（2）、多色渐变构造函数使用实例</h5><p>多色渐变的构造函数如下：<br><code>RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode)</code></p>
<p>这里与两色渐变不同的是两个函数：</p>
<ul>
<li>int[] colors：表示所需要的渐变颜色数组</li>
<li>float[] stops：表示每个渐变颜色所在的位置百分点，取值0-1，数量必须与colors数组保持一致，不然直接crash,一般第一个数值取0，最后一个数值取1；如果第一个数值和最后一个数值并没有取0和1，比如我们这里取一个位置数组：{0.2,0.5,0.8}，起始点是0.2百分比位置，结束点是0.8百分比位置，而0-0.2百分比位置和0.8-1.0百分比的位置都是没有指定颜色的。而这些位置的颜色就是根据我们指定的TileMode空白区域填充模式来自行填充！！！有时效果我们是不可控的。所以为了方便起见，建议大家stop数组的起始和终止数值设为0和1.</li>
</ul>
<p>下面我们举个例子来看下用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiColorRadialGradientView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line">    <span class="keyword">private</span> RadialGradient mRadialGradient;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRadius = <span class="number">100</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiColorRadialGradientView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiColorRadialGradientView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiColorRadialGradientView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[]   colors = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>,<span class="number">0xff0000ff</span>,<span class="number">0xffffff00</span>&#125;;</div><div class="line">        <span class="keyword">float</span>[] stops  = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">0f</span>,<span class="number">0.2f</span>,<span class="number">0.5f</span>,<span class="number">1f</span>&#125;;</div><div class="line">        mRadialGradient = <span class="keyword">new</span> RadialGradient(w/<span class="number">2</span>,h/<span class="number">2</span>,mRadius,colors,stops, Shader.TileMode.REPEAT);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawCircle(getWidth()/<span class="number">2</span>,getHeight()/<span class="number">2</span>,mRadius,mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里主要看下多色渐变的构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[]   colors = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>,<span class="number">0xff0000ff</span>,<span class="number">0xffffff00</span>&#125;;</div><div class="line"><span class="keyword">float</span>[] stops  = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;<span class="number">0f</span>,<span class="number">0.2f</span>,<span class="number">0.5f</span>,<span class="number">1f</span>&#125;;</div><div class="line">mRadialGradient = <span class="keyword">new</span> RadialGradient(w/<span class="number">2</span>,h/<span class="number">2</span>,mRadius,colors,stops, Shader.TileMode.REPEAT);</div></pre></td></tr></table></figure></p>
<p>这里构造了一个四色颜色数组，渐变位置对应{0f,0.2f,0.5f,1f}，然后创建RadialGradient实例。没什么难度。<br>然后在绘画的时候，同样以控件中心为半径，以放射渐变的半径为半径画圆。由于画的圆半径与放射渐变的大小相同，所以不存在空白位置填充的问题，所以TileMode.REPEAT并没有用到。 </p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874894175847.png" alt="2017021914874894175847.png"></p>
<h4 id="1、TileMode重复方式"><a href="#1、TileMode重复方式" class="headerlink" title="1、TileMode重复方式"></a>1、TileMode重复方式</h4><p>TileMode的问题，已经重复讲了几篇文章了，其实虽然每种Shader所表现出来的效果不一样，但是形成原理都是相同的。下面我们再来看一下RadialGradient在不同的TileMode下的具体表现。</p>
<h5 id="（1）、X、Y轴共用填充参数"><a href="#（1）、X、Y轴共用填充参数" class="headerlink" title="（1）、X、Y轴共用填充参数"></a>（1）、X、Y轴共用填充参数</h5><p>与LinearGradient一样，从构造函数中，可以明显看出RadialGradient只有一个填充模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//两色渐变</span></div><div class="line">RadialGradient(<span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY, <span class="keyword">float</span> radius, <span class="keyword">int</span> centerColor, <span class="keyword">int</span> edgeColor, Shader.TileMode tileMode)</div><div class="line"><span class="comment">//多色渐变</span></div><div class="line">RadialGradient(<span class="keyword">float</span> centerX, <span class="keyword">float</span> centerY, <span class="keyword">float</span> radius, <span class="keyword">int</span>[] colors, <span class="keyword">float</span>[] stops, Shader.TileMode tileMode)</div></pre></td></tr></table></figure>
<p>这就说明了，当填充空白区域时，X轴和Y轴使用同一种填充模式。而不能像BitmapShader那样分别指定X轴与Y轴的填充参数。</p>
<h5 id="（2）、TileMode-CLAMP——边缘填充"><a href="#（2）、TileMode-CLAMP——边缘填充" class="headerlink" title="（2）、TileMode.CLAMP——边缘填充"></a>（2）、TileMode.CLAMP——边缘填充</h5><p>我们依然使用双色渐变的示例来看下效果，为了显示填充效果，我们这次画一个屏幕大小的矩形：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line"></div><div class="line">    mRadialGradient = <span class="keyword">new</span> RadialGradient(w/<span class="number">2</span>,h/<span class="number">2</span>,mRadius,<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>, Shader.TileMode.CLAMP);</div><div class="line">    mPaint.setShader(mRadialGradient);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">    canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874895153361.png" alt="2017021914874895153361.png"><br>从效果图中可以明显看出，除了放渐渐变以外的空白区域都被边缘填充成为了绿色；  </p>
<h5 id="（3）、TileMode-REPEAT——重复填充"><a href="#（3）、TileMode-REPEAT——重复填充" class="headerlink" title="（3）、TileMode.REPEAT——重复填充"></a>（3）、TileMode.REPEAT——重复填充</h5><p>我们仍使用上面的代码，只是将填充模式改为重复填充：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line"></div><div class="line">    mRadialGradient = <span class="keyword">new</span> RadialGradient(w/<span class="number">2</span>,h/<span class="number">2</span>,mRadius,<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>, Shader.TileMode.REPEAT);</div><div class="line">    mPaint.setShader(mRadialGradient);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">    canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017021914874895561684.png" alt="2017021914874895561684.png"></p>
<p>这个图像乍看去有点辣眼睛，花花绿绿的……从效果图中可以看出，最内部的圆形是红到绿的原始放射渐变。其外面的圆就是空白区域填充模式了，在它的外围，从红到绿渐变。</p>
<h5 id="（4）、TileMode-MIRROR—镜像填充"><a href="#（4）、TileMode-MIRROR—镜像填充" class="headerlink" title="（4）、TileMode.MIRROR—镜像填充"></a>（4）、TileMode.MIRROR—镜像填充</h5><p>同样是使用上面的代码，只是将填充模式改为镜像填充：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line"></div><div class="line">    mRadialGradient = <span class="keyword">new</span> RadialGradient(w/<span class="number">2</span>,h/<span class="number">2</span>,mRadius,<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>, Shader.TileMode.MIRROR);</div><div class="line">    mPaint.setShader(mRadialGradient);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">    canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getWidth(),getHeight(),mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748960591118.png" alt="20170219148748960591118.png"></p>
<p>有些同学第一下看到这个图可能有点懵，所谓镜像，就是把原来的颜色的倒过来填充。即原始是红到绿渐变，第二圈就变成了绿到红渐变，第三圈就又是红到绿渐变，如此往复。<br>如果我把每一圈渐变的界限标出来，大家可能就容易看懂了：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748961856008.png" alt="20170219148748961856008.png"></p>
<p>图中白色线就是每一圈渐变的边界线，一次完整的填充就是两个白色圈中的部分。</p>
<h5 id="（5）、填充方式：从控件左上角开始填充"><a href="#（5）、填充方式：从控件左上角开始填充" class="headerlink" title="（5）、填充方式：从控件左上角开始填充"></a>（5）、填充方式：从控件左上角开始填充</h5><p>在讲BitmapShader和LinearShader时，我们就一再强调一个点：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块；<br>我们在RadialGradient中也做下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</div><div class="line"></div><div class="line">    mRadialGradient = <span class="keyword">new</span> RadialGradient(w/<span class="number">2</span>,h/<span class="number">2</span>,mRadius,<span class="number">0xffff0000</span>,<span class="number">0xff00ff00</span>, Shader.TileMode.REPEAT);</div><div class="line">    mPaint.setShader(mRadialGradient);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">    canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>,mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们这里使用TileMode.REPEAT来填充空白区域，在绘图时，我们只画出左上角的一部分；<br>效果图如下：</p>
<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748966342983.png" alt="20170219148748966342983.png"></p>
<blockquote>
<p>从效果图中明显可以看出结论了：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块</p>
</blockquote>
<h3 id="二、水波纹按钮效果"><a href="#二、水波纹按钮效果" class="headerlink" title="二、水波纹按钮效果"></a>二、水波纹按钮效果</h3><p>这部分就要利用RadialGradient来实现水波纹效果了，我们这里直接继承自Button类，做一个按钮的水波纹效果，其实这里继承自任何一个类都是可以在这个类原本的显示内容上显示水波纹效果的，比如，大家可以试验下在源码的基础上，将其改为派生自ImageView，当然要记得给它添加上src属性，是一样会有水波纹效果的。</p>
<h4 id="1、概述-8"><a href="#1、概述-8" class="headerlink" title="1、概述"></a>1、概述</h4><p>根据上面的的对RadialGradient的讲解，大家第一反应应该是，水波纹很好实现啊：不就是，画一个带有渐变效果的逐渐放大的圆不就得了。不错，思想确实就是这么简单。</p>
<h5 id="（1）、不过，第一个问题来了，从哪个颜色，渐变到哪个颜色呢？"><a href="#（1）、不过，第一个问题来了，从哪个颜色，渐变到哪个颜色呢？" class="headerlink" title="（1）、不过，第一个问题来了，从哪个颜色，渐变到哪个颜色呢？"></a>（1）、不过，第一个问题来了，从哪个颜色，渐变到哪个颜色呢？</h5><p>最理想的状态是，从按钮的背景色渐变到天蓝色（开篇效果图中颜色）。但是，怎么拿到按钮的背景色呢？因为按钮的android:background属性填充不一定是颜色，有可能是一个drawable，而这个drawable可以是图片，也可能是selector文件等，所以这条路根本走不通。<br>而我们讲过，RadialGradient中填充的渐变色彩必须是AARRGGBB形式的，所以我们只需要讲初始颜色的透明度设为0，不就露出了按钮的背景色了么。即类似下面的代码：<br><code>mRadialGradient = new RadialGradient(x, y,20 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP);</code></p>
<p>在这里我们将初始的渐变色改为0x00FFFFFF，由于透明度部分全部设置为0，所以整个颜色就是透明的。所以整个渐变过程就变为从零透明度逐渐变为纯天蓝色（0xFF58FAAC）。</p>
<h5 id="（2）、第二个问题，我们应该怎么安排RadialGradient的填充模式"><a href="#（2）、第二个问题，我们应该怎么安排RadialGradient的填充模式" class="headerlink" title="（2）、第二个问题，我们应该怎么安排RadialGradient的填充模式"></a>（2）、第二个问题，我们应该怎么安排RadialGradient的填充模式</h5><p>从效果图中是可以明显看出我们会逐渐放大绘制RadialGradient的圆的，那么，我们是让RadialGradient的渐变变径随着绘制的圆增大而增大，还是不改变RadialGradient的初始半径，空余部分使用Shader.TileMode.CLAMP填充来实现水波纹呢。  </p>
<p>答案是让RadialGradient的渐变变径随着绘制的圆增大而增大；下面我们分别举个例子来看下效果就知道区别了：  </p>
<p>我们将RadialGradient的初始半径设置为20，而假设当前绘制圆的半径是150，分别用模拟代码来展示在不同代码处理下的效果，以最终决定选用哪种方式来绘制RadialGradient渐变。  </p>
<p><strong>如果使用空余部分使用Shader.TileMode.CLAMP填充</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mRadialGradient == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> x = getWidth()/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> y = getHeight()/<span class="number">2</span>;</div><div class="line">        mRadialGradient = <span class="keyword">new</span> RadialGradient(x, y,<span class="number">20</span> , <span class="number">0x00FFFFFF</span>, <span class="number">0xFF58FAAC</span>, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">        canvas.drawCircle(x, y, <span class="number">150</span>, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里以控件中心为圆心，构造一个RadialGradient，这个RadialGradient的半径是20，从透明色，渐变到天蓝色<br><code>mRadialGradient = new RadialGradient(x, y,20 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP);</code><br>而在canvas画圆时，仍然以控件中心为圆心，但圆的半径却是150，明显要超出RadialGradient的半径，空白部分使用Shader.TileMode.CLAMP边缘模式填充<br><code>canvas.drawCircle(x, y, 150, mPaint);</code><br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748985130220.png" alt="20170219148748985130220.png"><br>从效果图中可以看出，在0-20的部分是从透明色到天蓝色的渐变，但是超出半径20的部分，都以边缘模式填充为完全不透明的天蓝色，感觉跟按钮完全没有融合在一起有没有<br><strong>如果让RadialGradient的渐变变径随着绘制的圆增大而增大</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mRadialGradient == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> x = getWidth()/<span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> y = getHeight()/<span class="number">2</span>;</div><div class="line">        mRadialGradient = <span class="keyword">new</span> RadialGradient(x, y,<span class="number">150</span> , <span class="number">0x00FFFFFF</span>, <span class="number">0xFF58FAAC</span>, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">        canvas.drawCircle(x, y, <span class="number">150</span>, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的代码跟上面的一样，唯一不同的是，构造的RadialGradient的渐变半径与canvas.drawCircle所画的圆的半径是一样的，都是150；这就演示了让RadialGradient的渐变变径随着绘制的圆增大而增大的效果<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219148748989522643.png" alt="20170219148748989522643.png"><br>很明显，这是我们想要的结果，渐变色与按钮的背景完全融合。</p>
<h4 id="2、代码实现-2"><a href="#2、代码实现-2" class="headerlink" title="2、代码实现"></a>2、代码实现</h4><p>上面在讲解了解决了核心问题，以后，下面我们就开始正式实战了<br><img src="http://ohtrrgyyd.bkt.clouddn.com/20170219881101474724851_2084.gif" alt="20170219881101474724851_2084.gif"><br>从效果图中，可以看到我们所需要完成的功能：</p>
<ul>
<li>在手指按下时，绘制一个默认大小的圆</li>
<li>在手指移动时，所绘制的默认圆的位置需要跟随手指移动</li>
<li>在手指放开时，圆逐渐变大</li>
<li>在动画结束时，波纹效果消失</li>
</ul>
<p><strong>按下和移动</strong><br>首先，我们来完成前两个功能：当首先按下时，绘制一个默认大小的圆，而且当手指移动时，可以跟随移动：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mX, mY;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_RADIUS = <span class="number">50</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mX != event.getX() || mY != mY) &#123;</div><div class="line">        mX = (<span class="keyword">int</span>) event.getX();</div><div class="line">        mY = (<span class="keyword">int</span>) event.getY();</div><div class="line">        setRadius(DEFAULT_RADIUS);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先，我们这里并没区分MotionEvent.ACTION_DOWN和MotionEvent.ACTION_UP的绘图操作，只是统一在当前手指位置与上次的不一样时，就调用setRadius(DEFAULT_RADIUS);重绘RadialGradient；很明显，mX、mY变量表示当前手指的位置，而DEFAULT_RADIUS变量表示默认的RadialGradient的渐变尺寸。但是必须在 MotionEvent.ACTION_DOWN时return true，因为如果不return true，就表示当前控件并不需要下按之后的消息，所以ACTION_MOVE、ACTION_UP消息都不会再传到这个控件里来了，有关这个问题，在前面的文章中已经不只一次提到，这里就不再缀述了。  </p>
<p>其中，setRadius(DEFAULT_RADIUS)函数的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//表示当前渐变半径</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> mCurRadius = <span class="number">0</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> radius)</span> </span>&#123;</div><div class="line">    mCurRadius = radius;</div><div class="line">    <span class="keyword">if</span> (mCurRadius &gt; <span class="number">0</span>) &#123;</div><div class="line">        mRadialGradient = <span class="keyword">new</span> RadialGradient(mX, mY, mCurRadius, <span class="number">0x00FFFFFF</span>, <span class="number">0xFF58FAAC</span>, Shader.TileMode.CLAMP);</div><div class="line">        mPaint.setShader(mRadialGradient);</div><div class="line">    &#125;</div><div class="line">    postInvalidate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">    canvas.drawCircle(mX, mY, mCurRadius, mPaint);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在setRadius中主要负责在手指位置和渐变半径改变时，重新创建RadialGradient，然后重绘。很明显mCurRadius变量表示当前的渐变半径。最后在OnDraw函数中重绘时，画一个跟渐变半径同样大小的圆即可。</p>
<p><strong>手指放开</strong><br>在手指放开时，主要是开始逐渐放大放射半径的动画，然后在动画结束的时候，清除RadialGradient。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ObjectAnimator mAnimator;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    …………</div><div class="line">    f (event.getAction() == MotionEvent.ACTION_UP) &#123;</div><div class="line">        <span class="keyword">if</span> (mAnimator != <span class="keyword">null</span> &amp;&amp; mAnimator.isRunning()) &#123;</div><div class="line">            mAnimator.cancel();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mAnimator == <span class="keyword">null</span>) &#123;</div><div class="line">            mAnimator = ObjectAnimator.ofInt(<span class="keyword">this</span>,<span class="string">"radius"</span>,DEFAULT_RADIUS, getWidth());</div><div class="line">        &#125;</div><div class="line">        mAnimator.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</div><div class="line">        mAnimator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                setRadius(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        mAnimator.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这段代码中，首先是在开始下一个动画前，先判断当前mAnimator是不是还在动画中，如果是正在动画就先取消:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mAnimator != <span class="keyword">null</span> &amp;&amp; mAnimator.isRunning()) &#123;</div><div class="line">    mAnimator.cancel();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是为了避免当用户连续点击多次的时候，下一次开始动画时，上一次动画还没结束，这样两次动画就会造成冲突，应该先把上次的动画取消掉，然后再重新开始这次的动画：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mAnimator = ObjectAnimator.ofInt(<span class="keyword">this</span>,<span class="string">"radius"</span>,DEFAULT_RADIUS, getWidth());</div><div class="line">&#125;</div><div class="line">mAnimator.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</div></pre></td></tr></table></figure></p>
<p>然后创建一个ObjectAnimator对象，这里动画操作的函数是setRadius(final int radius)函数，动画的区间是从默认半径到整个控件的宽度，之所以用当前控件的宽度来做为最大动画值，是因为，我们必须指定一个足够大的值，足以让波纹能够覆盖整个控件以后再结束。从效果图中可以看出，在这里控件的宽度是整个控件长度的最大值，所以，我们就以用户点击控件最边缘来算，当用户点击最左或最右边缘时，整个RadialGradient的半径是最大的，此时的最大值是控件宽度，所以我们就用控件宽度来做为动画的最大值即可。</p>
<p>其实这里还是不够严谨，因为在实际应用中，控件的宽度并不是整个控件的最大值，也有可能是控件的高度是最大的，所以最严谨的做法就是先判断控件的高度和宽度哪个最大，然后将最大值做为动画的半径。这里为了简化代码可读性，就不再对比了。</p>
<p>然后给mAnimator设置AccelerateInterpolator()插值器，因为我们需要让波纹的速度逐渐加快，如果不设置插值器的话，默认是使用LinearInterpolator插值器的，这样出来的效果是波纹的变大速度将是匀速的。<br><code>mAnimator.setInterpolator(new AccelerateInterpolator());</code><br>最后我们需要监听mAnimator结束的动作，当动画结束时，我们需要让RadialGradient消失，最简单的消失办法就是将所画圆的半径设置为0。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mAnimator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</div><div class="line">    …………</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">        setRadius(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    …………</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>到这里所有的代码就讲完了，完整的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RippleView</span> <span class="keyword">extends</span> <span class="title">Button</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mX, mY;</div><div class="line">    <span class="keyword">private</span> ObjectAnimator mAnimator;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> DEFAULT_RADIUS = <span class="number">50</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurRadius = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> RadialGradient mRadialGradient;</div><div class="line">    <span class="keyword">private</span> Paint mPaint;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RippleView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RippleView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RippleView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(context, attrs, defStyle);</div><div class="line">        init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        setLayerType(LAYER_TYPE_SOFTWARE,<span class="keyword">null</span>);</div><div class="line">        mPaint = <span class="keyword">new</span> Paint();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mX != event.getX() || mY != mY) &#123;</div><div class="line">            mX = (<span class="keyword">int</span>) event.getX();</div><div class="line">            mY = (<span class="keyword">int</span>) event.getY();</div><div class="line"></div><div class="line">            setRadius(DEFAULT_RADIUS);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mAnimator != <span class="keyword">null</span> &amp;&amp; mAnimator.isRunning()) &#123;</div><div class="line">                mAnimator.cancel();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mAnimator == <span class="keyword">null</span>) &#123;</div><div class="line">                mAnimator = ObjectAnimator.ofInt(<span class="keyword">this</span>,<span class="string">"radius"</span>,DEFAULT_RADIUS, getWidth());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mAnimator.setInterpolator(<span class="keyword">new</span> AccelerateInterpolator());</div><div class="line">            mAnimator.addListener(<span class="keyword">new</span> Animator.AnimatorListener() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                    setRadius(<span class="number">0</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            mAnimator.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRadius</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> radius)</span> </span>&#123;</div><div class="line">        mCurRadius = radius;</div><div class="line">        <span class="keyword">if</span> (mCurRadius &gt; <span class="number">0</span>) &#123;</div><div class="line">            mRadialGradient = <span class="keyword">new</span> RadialGradient(mX, mY, mCurRadius, <span class="number">0x00FFFFFF</span>, <span class="number">0xFF58FAAC</span>, Shader.TileMode.CLAMP);</div><div class="line">            mPaint.setShader(mRadialGradient);</div><div class="line">        &#125;</div><div class="line">        postInvalidate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDraw(canvas);</div><div class="line"></div><div class="line">        canvas.drawCircle(mX, mY, mCurRadius, mPaint);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/11/10/android-animation/" rel="next" title="自定义控件——动画">
                <i class="fa fa-chevron-left"></i> 自定义控件——动画
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/15/android-studio-plugin/" rel="prev" title="Android Studio必备插件整理">
                Android Studio必备插件整理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ohtrrgyyd.bkt.clouddn.com/037c5bde749f737e107c8fb8e9321c9d.jpg"
               alt="MagicalRice" />
          <p class="site-author-name" itemprop="name">MagicalRice</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">145</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/adolphJane" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一、概述及基本几何图形绘制"><span class="nav-number">2.</span> <span class="nav-text">一、概述及基本几何图形绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、Paint和Canvas"><span class="nav-number">2.1.</span> <span class="nav-text">一、Paint和Canvas</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、Paint的基本设置函数"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、Paint的基本设置函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、示例"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、首先新建一个工程，把默认的XML改成FrameLayout布局，布局代码如下："><span class="nav-number">2.1.2.1.</span> <span class="nav-text">1、首先新建一个工程，把默认的XML改成FrameLayout布局，布局代码如下：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、视图类写好了，下面就要将其加入到Activity中，让它显示出来，在MainActiviy中添加如下代码："><span class="nav-number">2.1.2.2.</span> <span class="nav-text">3、视图类写好了，下面就要将其加入到Activity中，让它显示出来，在MainActiviy中添加如下代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、基本几何图形绘制"><span class="nav-number">2.1.3.</span> <span class="nav-text">三、基本几何图形绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、画直线"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">1、画直线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、多条直线"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">2、多条直线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、点"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">3、点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、多个点"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">4、多个点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、矩形工具类RectF与Rect"><span class="nav-number">2.1.3.5.</span> <span class="nav-text">5、矩形工具类RectF与Rect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、矩形"><span class="nav-number">2.1.3.6.</span> <span class="nav-text">6、矩形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、圆角矩形"><span class="nav-number">2.1.3.7.</span> <span class="nav-text">7、圆角矩形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8、圆形"><span class="nav-number">2.1.3.8.</span> <span class="nav-text">8、圆形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9、椭圆"><span class="nav-number">2.1.3.9.</span> <span class="nav-text">9、椭圆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10、弧"><span class="nav-number">2.1.3.10.</span> <span class="nav-text">10、弧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、路径及文字"><span class="nav-number">2.1.4.</span> <span class="nav-text">四、路径及文字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、路径"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">1、路径</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、直线路径"><span class="nav-number">2.1.4.1.1.</span> <span class="nav-text">1、直线路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、矩形路径"><span class="nav-number">2.1.4.1.2.</span> <span class="nav-text">2、矩形路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、圆角矩形路径"><span class="nav-number">2.1.4.1.3.</span> <span class="nav-text">3、圆角矩形路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、圆形路径"><span class="nav-number">2.1.4.1.4.</span> <span class="nav-text">4、圆形路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、椭圆路径"><span class="nav-number">2.1.4.1.5.</span> <span class="nav-text">5、椭圆路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、弧形路径"><span class="nav-number">2.1.4.1.6.</span> <span class="nav-text">6、弧形路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、线段轨迹"><span class="nav-number">2.1.4.1.7.</span> <span class="nav-text">7、线段轨迹</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、文字"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">2、文字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Paint的相关设置"><span class="nav-number">2.1.4.2.1.</span> <span class="nav-text">1、Paint的相关设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、canvas绘图方式"><span class="nav-number">2.1.4.2.2.</span> <span class="nav-text">2、canvas绘图方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、普通水平绘制"><span class="nav-number">2.1.4.2.2.1.</span> <span class="nav-text">1、普通水平绘制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、指定个个文字位置"><span class="nav-number">2.1.4.2.2.2.</span> <span class="nav-text">2、指定个个文字位置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、沿路径绘制"><span class="nav-number">2.1.4.2.2.3.</span> <span class="nav-text">3、沿路径绘制</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、字体样式设置（Typeface）"><span class="nav-number">2.1.4.2.3.</span> <span class="nav-text">3、字体样式设置（Typeface）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、使用系统中的字体"><span class="nav-number">2.1.4.2.3.1.</span> <span class="nav-text">1、使用系统中的字体</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、自字义字体"><span class="nav-number">2.1.4.2.3.2.</span> <span class="nav-text">2、自字义字体</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、区域-Range"><span class="nav-number">2.1.5.</span> <span class="nav-text">五、区域(Range)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、构造Region"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">一、构造Region</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、基本构造函数"><span class="nav-number">2.1.5.1.1.</span> <span class="nav-text">1、基本构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、间接构造函数"><span class="nav-number">2.1.5.1.2.</span> <span class="nav-text">2、间接构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、使用SetPath（）构造不规则区域"><span class="nav-number">2.1.5.1.3.</span> <span class="nav-text">3、使用SetPath（）构造不规则区域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、矩形集枚举区域——RegionIterator类"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">二、矩形集枚举区域——RegionIterator类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、区域的合并、交叉等操作"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">三、区域的合并、交叉等操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、其它一些方法"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">四、其它一些方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、裁剪"><span class="nav-number">2.1.5.5.</span> <span class="nav-text">五、裁剪</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、概述"><span class="nav-number">2.1.5.5.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、裁剪的方式"><span class="nav-number">2.1.5.5.2.</span> <span class="nav-text">2、裁剪的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、示例"><span class="nav-number">2.1.5.5.3.</span> <span class="nav-text">3、示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、canvas变换与操作"><span class="nav-number">2.1.6.</span> <span class="nav-text">六、canvas变换与操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、平移-translate"><span class="nav-number">2.1.6.1.</span> <span class="nav-text">一、平移(translate)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、屏幕显示与Canvas的关系"><span class="nav-number">2.1.6.2.</span> <span class="nav-text">二、屏幕显示与Canvas的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#总结："><span class="nav-number">2.1.6.2.1.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、旋转-Rotate"><span class="nav-number">2.1.6.3.</span> <span class="nav-text">三、旋转(Rotate)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、缩放-scale"><span class="nav-number">2.1.6.4.</span> <span class="nav-text">四、缩放(scale)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、扭曲-skew"><span class="nav-number">2.1.6.5.</span> <span class="nav-text">五、扭曲(skew)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、画布的保存与恢复（save-、restore-）"><span class="nav-number">2.1.6.6.</span> <span class="nav-text">六、画布的保存与恢复（save()、restore()）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、drawText-详解"><span class="nav-number">2.1.7.</span> <span class="nav-text">七、drawText()详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、概述-1"><span class="nav-number">2.1.7.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、canvas-drawText"><span class="nav-number">2.1.7.2.</span> <span class="nav-text">2、canvas.drawText()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、paint-setTextAlign-Paint-Align-XXX"><span class="nav-number">2.1.7.3.</span> <span class="nav-text">3、paint.setTextAlign(Paint.Align.XXX)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、drawText的四线格与FontMetrics"><span class="nav-number">2.1.7.4.</span> <span class="nav-text">4、drawText的四线格与FontMetrics</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Text的绘图四线格"><span class="nav-number">2.1.7.4.1.</span> <span class="nav-text">1、Text的绘图四线格</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、FontMetrics"><span class="nav-number">2.1.7.4.2.</span> <span class="nav-text">2、FontMetrics</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、fontMetrics概述"><span class="nav-number">2.1.7.4.2.1.</span> <span class="nav-text">（1）、fontMetrics概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、得到Text四线格的各线位置"><span class="nav-number">2.1.7.4.2.2.</span> <span class="nav-text">（2）、得到Text四线格的各线位置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、获取FontMetrics对象"><span class="nav-number">2.1.7.4.2.3.</span> <span class="nav-text">（3）、获取FontMetrics对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（4）、实例：计算Text四线格位置"><span class="nav-number">2.1.7.4.2.4.</span> <span class="nav-text">（4）、实例：计算Text四线格位置</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、所绘文字宽度、高度和最小矩形获取"><span class="nav-number">2.1.7.4.3.</span> <span class="nav-text">3、所绘文字宽度、高度和最小矩形获取</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、字符串所占高度和宽度"><span class="nav-number">2.1.7.4.3.1.</span> <span class="nav-text">1、字符串所占高度和宽度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、宽度"><span class="nav-number">2.1.7.4.3.2.</span> <span class="nav-text">（2）、宽度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、最小矩形"><span class="nav-number">2.1.7.4.3.3.</span> <span class="nav-text">（3）、最小矩形</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、定点写字"><span class="nav-number">2.1.7.4.4.</span> <span class="nav-text">4、定点写字</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、给定左上顶点绘图"><span class="nav-number">2.1.7.4.4.1.</span> <span class="nav-text">1、给定左上顶点绘图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、给定中间线位置绘图"><span class="nav-number">2.1.7.4.4.2.</span> <span class="nav-text">2、给定中间线位置绘图</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、Path之贝赛尔曲线和手势轨迹、水波纹效果"><span class="nav-number">2.2.</span> <span class="nav-text">二、Path之贝赛尔曲线和手势轨迹、水波纹效果</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、手势轨迹"><span class="nav-number">2.2.1.</span> <span class="nav-text">1、手势轨迹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、水波纹效果"><span class="nav-number">2.2.2.</span> <span class="nav-text">2、水波纹效果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、概述"><span class="nav-number">2.2.3.</span> <span class="nav-text">3、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、贝赛尔曲线来源"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">1、贝赛尔曲线来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、贝赛尔曲线公式"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">2、贝赛尔曲线公式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、一阶贝赛尔曲线"><span class="nav-number">2.2.3.2.1.</span> <span class="nav-text">1、一阶贝赛尔曲线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、二阶贝赛尔曲线"><span class="nav-number">2.2.3.2.2.</span> <span class="nav-text">2、二阶贝赛尔曲线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、三阶贝赛尔曲线"><span class="nav-number">2.2.3.2.3.</span> <span class="nav-text">3、三阶贝赛尔曲线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、四阶贝赛尔曲线"><span class="nav-number">2.2.3.2.4.</span> <span class="nav-text">4、四阶贝赛尔曲线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、五阶贝赛尔曲线"><span class="nav-number">2.2.3.2.5.</span> <span class="nav-text">5、五阶贝赛尔曲线</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、贝赛尔曲线与PhotoShop钢笔工具"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">3、贝赛尔曲线与PhotoShop钢笔工具</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、Android中贝赛尔曲线之quadTo"><span class="nav-number">2.2.4.</span> <span class="nav-text">4、Android中贝赛尔曲线之quadTo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、quadTo使用原理"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">1、quadTo使用原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、示例"><span class="nav-number">2.2.4.1.1.</span> <span class="nav-text">1、示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、手指轨迹"><span class="nav-number">2.2.5.</span> <span class="nav-text">5、手指轨迹</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、实现方式一：Path-lineTo-x-y"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">1、实现方式一：Path.lineTo(x,y)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、实现方式二（优化）：使用Path-quadTo-函数实现过渡"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">2、实现方式二（优化）：使用Path.quadTo()函数实现过渡</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-、原理概述"><span class="nav-number">2.2.5.2.1.</span> <span class="nav-text">(1)、原理概述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6、Path-rQuadTo"><span class="nav-number">2.2.6.</span> <span class="nav-text">6、Path.rQuadTo()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、概述-2"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、使用rQuadTo实现波浪线"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">2、使用rQuadTo实现波浪线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、实现波浪效果"><span class="nav-number">2.2.6.3.</span> <span class="nav-text">3、实现波浪效果</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、Paint之函数大汇总"><span class="nav-number">2.3.</span> <span class="nav-text">三、Paint之函数大汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基本用法"><span class="nav-number">2.3.1.</span> <span class="nav-text">一、基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、概述-3"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">1、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）、CornerPathEffect——圆形拐角效果"><span class="nav-number">2.3.1.1.1.</span> <span class="nav-text">（1）、CornerPathEffect——圆形拐角效果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）、DashPathEffect——虚线效果"><span class="nav-number">2.3.1.1.2.</span> <span class="nav-text">（2）、DashPathEffect——虚线效果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）、DiscretePathEffect——离散路径效果"><span class="nav-number">2.3.1.1.3.</span> <span class="nav-text">（3）、DiscretePathEffect——离散路径效果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）、PathDashPathEffect——印章路径效果"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">（4）、PathDashPathEffect——印章路径效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（5）、ComposePathEffect与SumPathEffect"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">（5）、ComposePathEffect与SumPathEffect</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、字体相关"><span class="nav-number">2.3.2.</span> <span class="nav-text">二、字体相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、setLinearText-boolean-linearText"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">1、setLinearText(boolean linearText)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、Paint之ColorMatrix与滤镜效果"><span class="nav-number">2.3.3.</span> <span class="nav-text">三、Paint之ColorMatrix与滤镜效果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、矩阵概述"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">一、矩阵概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、色彩矩阵"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">二、色彩矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、色彩信息的矩阵表示"><span class="nav-number">2.3.3.2.1.</span> <span class="nav-text">1、色彩信息的矩阵表示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、Android中的色彩矩阵"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">三、Android中的色彩矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、概述-4"><span class="nav-number">2.3.3.3.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、示例1（单个颜色的蓝色通道输出）"><span class="nav-number">2.3.3.3.2.</span> <span class="nav-text">2、示例1（单个颜色的蓝色通道输出）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、色彩的缩放运算"><span class="nav-number">2.3.3.3.3.</span> <span class="nav-text">2、色彩的缩放运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、缩放变换的特殊应用（通道输出）"><span class="nav-number">2.3.3.3.4.</span> <span class="nav-text">3、缩放变换的特殊应用（通道输出）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、色彩的旋转运算"><span class="nav-number">2.3.3.3.5.</span> <span class="nav-text">4、色彩的旋转运算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、色彩的投射运算"><span class="nav-number">2.3.3.3.6.</span> <span class="nav-text">5、色彩的投射运算</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、ColorMatrix函数"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">五、ColorMatrix函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、构造函数"><span class="nav-number">2.3.3.4.1.</span> <span class="nav-text">1、构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、设置、重置函数"><span class="nav-number">2.3.3.4.2.</span> <span class="nav-text">2、设置、重置函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、setSaturation——设置饱和度"><span class="nav-number">2.3.3.4.3.</span> <span class="nav-text">3、setSaturation——设置饱和度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、setScale——色彩缩放"><span class="nav-number">2.3.3.4.4.</span> <span class="nav-text">4、setScale——色彩缩放</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、setRotate——色彩旋转"><span class="nav-number">2.3.3.4.5.</span> <span class="nav-text">5、setRotate——色彩旋转</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、ColorMatrics相乘"><span class="nav-number">2.3.3.4.6.</span> <span class="nav-text">6、ColorMatrics相乘</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、getArray-获取当前矩阵数组"><span class="nav-number">2.3.3.4.7.</span> <span class="nav-text">7、getArray()获取当前矩阵数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、Paint之setColorFilter"><span class="nav-number">2.3.4.</span> <span class="nav-text">四、Paint之setColorFilter</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、setColorFilter"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">一、setColorFilter</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、ColorMatrixColorFilter"><span class="nav-number">2.3.4.1.1.</span> <span class="nav-text">1、ColorMatrixColorFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、LightingColorFilter"><span class="nav-number">2.3.4.1.2.</span> <span class="nav-text">2、LightingColorFilter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、PorterDuffColorFilter"><span class="nav-number">2.3.4.1.3.</span> <span class="nav-text">3、PorterDuffColorFilter</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、Paint之setXfermode-一"><span class="nav-number">2.3.5.</span> <span class="nav-text">五、Paint之setXfermode(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、GPU硬件加速"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">一、GPU硬件加速</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、概述-5"><span class="nav-number">2.3.5.1.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、禁用GPU硬件加速方法"><span class="nav-number">2.3.5.1.2.</span> <span class="nav-text">2、禁用GPU硬件加速方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-在AndroidManifest-xml文件为application标签添加如下的属性即可为整个应用程序开启-关闭硬件加速："><span class="nav-number">2.3.5.1.2.1.</span> <span class="nav-text">1.在AndroidManifest.xml文件为application标签添加如下的属性即可为整个应用程序开启/关闭硬件加速：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-在Activity-标签下使用-hardwareAccelerated-属性开启或关闭硬件加速："><span class="nav-number">2.3.5.1.2.2.</span> <span class="nav-text">2.在Activity 标签下使用 hardwareAccelerated 属性开启或关闭硬件加速：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-在Window-层级使用如下代码开启硬件加速：-Window层级不支持关闭硬件加速"><span class="nav-number">2.3.5.1.2.3.</span> <span class="nav-text">3. 在Window 层级使用如下代码开启硬件加速：(Window层级不支持关闭硬件加速)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-View-级别如下关闭硬件加速：（view-层级上不支持开启硬件加速）"><span class="nav-number">2.3.5.1.2.4.</span> <span class="nav-text">4.View 级别如下关闭硬件加速：（view 层级上不支持开启硬件加速）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、setXfermode-Xfermode-xfermode-之AvoidXfermode"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">二、setXfermode(Xfermode xfermode)之AvoidXfermode</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、概述——基本流程"><span class="nav-number">2.3.5.2.1.</span> <span class="nav-text">1、概述——基本流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、canvas脏区域更新原理"><span class="nav-number">2.3.5.2.2.</span> <span class="nav-text">2、canvas脏区域更新原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、AvoidXfermode"><span class="nav-number">2.3.5.2.3.</span> <span class="nav-text">3、AvoidXfermode</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、setXfermode-Xfermode-xfermode-之PixelXorXfermode"><span class="nav-number">2.3.5.3.</span> <span class="nav-text">三、setXfermode(Xfermode xfermode)之PixelXorXfermode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、setXfermode-Xfermode-xfermode-之PorterDuffXfermode"><span class="nav-number">2.3.5.4.</span> <span class="nav-text">四、setXfermode(Xfermode xfermode)之PorterDuffXfermode</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、概述-6"><span class="nav-number">2.3.5.4.1.</span> <span class="nav-text">1、概述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、Paint之setXfermode-二"><span class="nav-number">2.3.6.</span> <span class="nav-text">六、Paint之setXfermode(二)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、颜色叠加相关模式"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">一、颜色叠加相关模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Mode-ADD（饱和度相加）"><span class="nav-number">2.3.6.1.1.</span> <span class="nav-text">1、Mode.ADD（饱和度相加）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、Mode-LIGHTEN（变亮）"><span class="nav-number">2.3.6.1.2.</span> <span class="nav-text">2、Mode.LIGHTEN（变亮）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、Mode-DARKEN（变暗）"><span class="nav-number">2.3.6.1.3.</span> <span class="nav-text">3、Mode.DARKEN（变暗）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、Mode-MULTIPLY-正片叠底"><span class="nav-number">2.3.6.1.4.</span> <span class="nav-text">4、Mode.MULTIPLY(正片叠底)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、Mode-OVERLAY（叠加）"><span class="nav-number">2.3.6.1.5.</span> <span class="nav-text">5、Mode.OVERLAY（叠加）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、Mode-SCREEN（滤色）"><span class="nav-number">2.3.6.1.6.</span> <span class="nav-text">6、Mode.SCREEN（滤色）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、示例——twitter标识的描边效果"><span class="nav-number">2.3.6.1.7.</span> <span class="nav-text">7、示例——twitter标识的描边效果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、SRC相关模式"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">二、SRC相关模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Mode-SRC"><span class="nav-number">2.3.6.2.1.</span> <span class="nav-text">1、Mode.SRC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、Mode-SRC-IN"><span class="nav-number">2.3.6.2.2.</span> <span class="nav-text">2、Mode.SRC_IN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、Mode-SRC-OUT"><span class="nav-number">2.3.6.2.3.</span> <span class="nav-text">3、Mode.SRC_OUT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、Mode-SRC-OVER"><span class="nav-number">2.3.6.2.4.</span> <span class="nav-text">4、Mode.SRC_OVER</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、Mode-SRC-ATOP"><span class="nav-number">2.3.6.2.5.</span> <span class="nav-text">5、Mode.SRC_ATOP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、Paint之setXfermode-三"><span class="nav-number">2.3.7.</span> <span class="nav-text">七、Paint之setXfermode(三)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、DST相关模式"><span class="nav-number">2.3.7.1.</span> <span class="nav-text">一、DST相关模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Mode-DST"><span class="nav-number">2.3.7.1.1.</span> <span class="nav-text">1、Mode.DST</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、Mode-DST-IN"><span class="nav-number">2.3.7.1.2.</span> <span class="nav-text">2、Mode.DST_IN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、Mode-DST-OUT"><span class="nav-number">2.3.7.1.3.</span> <span class="nav-text">3、Mode.DST_OUT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、Mode-DST-OVER"><span class="nav-number">2.3.7.1.4.</span> <span class="nav-text">4、Mode.DST_OVER</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、Mode-DST-ATOP"><span class="nav-number">2.3.7.1.5.</span> <span class="nav-text">5、Mode.DST_ATOP</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、其它模式"><span class="nav-number">2.3.7.2.</span> <span class="nav-text">二、其它模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Mode-CLEAR"><span class="nav-number">2.3.7.2.1.</span> <span class="nav-text">1、Mode.CLEAR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、Mode-XOR"><span class="nav-number">2.3.7.2.2.</span> <span class="nav-text">2、Mode.XOR</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、Canvas"><span class="nav-number">2.4.</span> <span class="nav-text">四、Canvas</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#八、Canvas与图层-一"><span class="nav-number">2.4.1.</span> <span class="nav-text">八、Canvas与图层(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、如何获得一个Canvas对象"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">一、如何获得一个Canvas对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方法一：自定义view时，-重写onDraw、dispatchDraw方法"><span class="nav-number">2.4.1.1.1.</span> <span class="nav-text">方法一：自定义view时， 重写onDraw、dispatchDraw方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、定义"><span class="nav-number">2.4.1.1.1.1.</span> <span class="nav-text">（1）、定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、onDraw、dispatchDraw区别"><span class="nav-number">2.4.1.1.1.2.</span> <span class="nav-text">（2）、onDraw、dispatchDraw区别</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法二：使用Bitmap创建"><span class="nav-number">2.4.1.1.2.</span> <span class="nav-text">方法二：使用Bitmap创建</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、构建方法"><span class="nav-number">2.4.1.1.2.1.</span> <span class="nav-text">1、构建方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、在OnDraw（）中使用"><span class="nav-number">2.4.1.1.2.2.</span> <span class="nav-text">2、在OnDraw（）中使用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法三：SurfaceHolder-lockCanvas"><span class="nav-number">2.4.1.1.3.</span> <span class="nav-text">方法三：SurfaceHolder.lockCanvas()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、saveLayer"><span class="nav-number">2.4.1.1.3.1.</span> <span class="nav-text">1、saveLayer()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、saveLayer的绘图流程"><span class="nav-number">2.4.1.1.3.2.</span> <span class="nav-text">（1）、saveLayer的绘图流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、没有saveLayer的绘图流程"><span class="nav-number">2.4.1.1.3.3.</span> <span class="nav-text">（2）、没有saveLayer的绘图流程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、画布与图层"><span class="nav-number">2.4.1.1.4.</span> <span class="nav-text">2、画布与图层</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、save-、saveLayer-、saveLayerAlpha-中的用法"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">三、save()、saveLayer()、saveLayerAlpha()中的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、saveLayer的用法"><span class="nav-number">2.4.1.2.1.</span> <span class="nav-text">1、saveLayer的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、saveLayer后的所有动作都只对新建画布有效"><span class="nav-number">2.4.1.2.1.1.</span> <span class="nav-text">（1）、saveLayer后的所有动作都只对新建画布有效</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、通过Rect指定矩形大小就是新建的画布大小"><span class="nav-number">2.4.1.2.1.2.</span> <span class="nav-text">（2）、通过Rect指定矩形大小就是新建的画布大小</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、saveLayerAlpha的用法"><span class="nav-number">2.4.1.2.2.</span> <span class="nav-text">2、saveLayerAlpha的用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#九、Canvas与图层（二）"><span class="nav-number">2.4.2.</span> <span class="nav-text">九、Canvas与图层（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、FLAG的具体意义"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">一、FLAG的具体意义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、FLAG概述"><span class="nav-number">2.4.2.1.1.</span> <span class="nav-text">1、FLAG概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、FLAG之MATRIX-SAVE-FLAG"><span class="nav-number">2.4.2.1.2.</span> <span class="nav-text">2、FLAG之MATRIX_SAVE_FLAG</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-、save-int-flag-与MATRIX-SAVE-FLAG"><span class="nav-number">2.4.2.1.2.1.</span> <span class="nav-text">(1)、save(int flag)与MATRIX_SAVE_FLAG</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、saveLayer-与MATRIX-SAVE-FLAG"><span class="nav-number">2.4.2.1.2.2.</span> <span class="nav-text">（2）、saveLayer()与MATRIX_SAVE_FLAG</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、FLAG之CLIP-SAVE-FLAG"><span class="nav-number">2.4.2.1.3.</span> <span class="nav-text">3、FLAG之CLIP_SAVE_FLAG</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-、save-int-flag-与CLIP-SAVE-FLAG"><span class="nav-number">2.4.2.1.3.1.</span> <span class="nav-text">(1)、save(int flag)与CLIP_SAVE_FLAG</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-、saveLayer-int-flag-与CLIP-SAVE-FLAG"><span class="nav-number">2.4.2.1.3.2.</span> <span class="nav-text">(2)、saveLayer(int flag)与CLIP_SAVE_FLAG</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、FLAG之HAS-ALPHA-LAYER-SAVE-FLAG和FULL-COLOR-LAYER-SAVE-FLAG"><span class="nav-number">2.4.2.1.4.</span> <span class="nav-text">4、FLAG之HAS_ALPHA_LAYER_SAVE_FLAG和FULL_COLOR_LAYER_SAVE_FLAG</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-、FULL-COLOR-LAYER-SAVE-FLAG"><span class="nav-number">2.4.2.1.4.1.</span> <span class="nav-text">(1)、FULL_COLOR_LAYER_SAVE_FLAG</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-、HAS-ALPHA-LAYER-SAVE-FLAG"><span class="nav-number">2.4.2.1.4.2.</span> <span class="nav-text">(2)、HAS_ALPHA_LAYER_SAVE_FLAG</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、共用时，以HAS-ALPHA-LAYER-SAVE-FLAG为主"><span class="nav-number">2.4.2.1.4.3.</span> <span class="nav-text">（3）、共用时，以HAS_ALPHA_LAYER_SAVE_FLAG为主</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（4）、当saveLayer只指定MATRIX-SAVE-FLAG-CLIP-SAVE-FLAG的合成方式"><span class="nav-number">2.4.2.1.4.4.</span> <span class="nav-text">（4）、当saveLayer只指定MATRIX_SAVE_FLAG/CLIP_SAVE_FLAG的合成方式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、FLAG之CLIP-TO-LAYER-SAVE-FLAG"><span class="nav-number">2.4.2.1.5.</span> <span class="nav-text">5、FLAG之CLIP_TO_LAYER_SAVE_FLAG</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、概述"><span class="nav-number">2.4.2.1.5.1.</span> <span class="nav-text">（1）、概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、与CLIP-SAVE-FLAG共用时，Canvas将被恢复"><span class="nav-number">2.4.2.1.5.2.</span> <span class="nav-text">（2）、与CLIP_SAVE_FLAG共用时，Canvas将被恢复</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、FLAG之ALL-SAVE-FLAG"><span class="nav-number">2.4.2.1.6.</span> <span class="nav-text">6、FLAG之ALL_SAVE_FLAG</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、restore-与restoreToCount"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">四、restore()与restoreToCount()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、restore"><span class="nav-number">2.4.2.2.1.</span> <span class="nav-text">1、restore()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、restoreToCount-int-count"><span class="nav-number">2.4.2.2.2.</span> <span class="nav-text">2、restoreToCount(int count)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、restore-与restoreToCount-int-count-关系"><span class="nav-number">2.4.2.2.3.</span> <span class="nav-text">3、restore()与restoreToCount(int count)关系</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、实例操作"><span class="nav-number">2.5.</span> <span class="nav-text">五、实例操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、QQ红点拖动删除效果实现（基本原理篇）"><span class="nav-number">2.5.1.</span> <span class="nav-text">一、QQ红点拖动删除效果实现（基本原理篇）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、拉伸效果实现"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">一、拉伸效果实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、实现原理"><span class="nav-number">2.5.1.1.1.</span> <span class="nav-text">1、实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、圆随着手指移动"><span class="nav-number">2.5.1.1.1.1.</span> <span class="nav-text">（2）、圆随着手指移动</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-、贝赛尔曲线连接两个圆"><span class="nav-number">2.5.1.1.1.2.</span> <span class="nav-text">(3)、贝赛尔曲线连接两个圆</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、疑问：当手指拖动位置不同时，也能统一处理求得各个点坐标？"><span class="nav-number">2.5.1.1.2.</span> <span class="nav-text">3、疑问：当手指拖动位置不同时，也能统一处理求得各个点坐标？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、自定义文字与爆炸效果"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">二、自定义文字与爆炸效果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、添加TextView"><span class="nav-number">2.5.1.2.1.</span> <span class="nav-text">1、添加TextView</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、添加并初始化TextView"><span class="nav-number">2.5.1.2.1.1.</span> <span class="nav-text">（1）、添加并初始化TextView</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、点击TextView时才允许拖动"><span class="nav-number">2.5.1.2.1.2.</span> <span class="nav-text">（2）、点击TextView时才允许拖动</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、绘图"><span class="nav-number">2.5.1.2.1.3.</span> <span class="nav-text">（3）、绘图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-、拉伸时把圆半径缩小"><span class="nav-number">2.5.1.2.1.4.</span> <span class="nav-text">(4)、拉伸时把圆半径缩小</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-、答疑：super-dispatchDraw-canvas-的位置问题"><span class="nav-number">2.5.1.2.1.5.</span> <span class="nav-text">(5)、答疑：super.dispatchDraw(canvas)的位置问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、爆炸效果"><span class="nav-number">2.5.1.2.2.</span> <span class="nav-text">2、爆炸效果</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、定义逐帧动画"><span class="nav-number">2.5.1.2.2.1.</span> <span class="nav-text">（1）、定义逐帧动画</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、添加ImageView"><span class="nav-number">2.5.1.2.2.2.</span> <span class="nav-text">（2）、添加ImageView</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、定值爆炸"><span class="nav-number">2.5.1.2.2.3.</span> <span class="nav-text">（3）、定值爆炸</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、给控件添加阴影效果与发光效果"><span class="nav-number">2.5.2.</span> <span class="nav-text">二、给控件添加阴影效果与发光效果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、layerlist给按钮添加阴影效果"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">一、layerlist给按钮添加阴影效果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、layerlist示例："><span class="nav-number">2.5.2.1.1.</span> <span class="nav-text">1、layerlist示例：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、layer-list与shape标签"><span class="nav-number">2.5.2.1.2.</span> <span class="nav-text">2、layer-list与shape标签</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、存在问题"><span class="nav-number">2.5.2.1.3.</span> <span class="nav-text">4、存在问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、Paint-setShadowLayer实现阴影效果"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">二、Paint.setShadowLayer实现阴影效果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、setShadowLayer构造函数"><span class="nav-number">2.5.2.2.1.</span> <span class="nav-text">1、setShadowLayer构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、示例一：初步使用setShadowLayer"><span class="nav-number">2.5.2.2.2.</span> <span class="nav-text">2、示例一：初步使用setShadowLayer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、示例二：setShadowLayer各参数意义"><span class="nav-number">2.5.2.2.3.</span> <span class="nav-text">3、示例二：setShadowLayer各参数意义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、Paint-clearShadowLayer-清除阴影"><span class="nav-number">2.5.2.2.4.</span> <span class="nav-text">4、Paint.clearShadowLayer()清除阴影</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、TextView及其派生类使用ShadowLayer添加阴影效果"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">三、TextView及其派生类使用ShadowLayer添加阴影效果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、XML实现"><span class="nav-number">2.5.2.3.1.</span> <span class="nav-text">1、XML实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、代码实现"><span class="nav-number">2.5.2.3.2.</span> <span class="nav-text">2、代码实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、SetMaskFilter之BlurMaskFilter实现发光效果"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">四、SetMaskFilter之BlurMaskFilter实现发光效果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、SetMaskFilter之BlurMaskFilter概述"><span class="nav-number">2.5.2.4.1.</span> <span class="nav-text">1、SetMaskFilter之BlurMaskFilter概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、BlurStyle发光效果"><span class="nav-number">2.5.2.4.2.</span> <span class="nav-text">2、BlurStyle发光效果</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-、Blur-INNER——内发光"><span class="nav-number">2.5.2.4.2.1.</span> <span class="nav-text">(1)、Blur.INNER——内发光</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-、Blur-SOLID——外发光"><span class="nav-number">2.5.2.4.2.2.</span> <span class="nav-text">(2)、Blur.SOLID——外发光</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-、Blur-NORMAL——内外发光"><span class="nav-number">2.5.2.4.2.3.</span> <span class="nav-text">(3)、Blur.NORMAL——内外发光</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-、Blur-OUTER——仅显示发光效果"><span class="nav-number">2.5.2.4.2.4.</span> <span class="nav-text">(4)、Blur.OUTER——仅显示发光效果</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、为Bitmap添加阴影并封装控件"><span class="nav-number">2.5.3.</span> <span class="nav-text">三、为Bitmap添加阴影并封装控件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、使用BlurMaskFilter为图片构造定色阴影效果"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">一、使用BlurMaskFilter为图片构造定色阴影效果</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、绘制出一个一样大小的灰色图像"><span class="nav-number">2.5.3.1.1.</span> <span class="nav-text">1、绘制出一个一样大小的灰色图像</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、extractAlpha-使用示例"><span class="nav-number">2.5.3.1.1.1.</span> <span class="nav-text">（1）、extractAlpha()使用示例</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、对灰色图形应用BlurMaskFilter使其内外发光"><span class="nav-number">2.5.3.1.2.</span> <span class="nav-text">2、对灰色图形应用BlurMaskFilter使其内外发光</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、偏移原图形一段距离绘制出来"><span class="nav-number">2.5.3.1.3.</span> <span class="nav-text">3、偏移原图形一段距离绘制出来</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、封装控件"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">二、封装控件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、自定义控件属性"><span class="nav-number">2.5.3.2.1.</span> <span class="nav-text">1、自定义控件属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、wrap-content自适应宽高"><span class="nav-number">2.5.3.2.2.</span> <span class="nav-text">2、wrap_content自适应宽高</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、BitmapShader与望远镜效果"><span class="nav-number">2.5.4.</span> <span class="nav-text">四、BitmapShader与望远镜效果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、BitmapShader基本用法"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">一、BitmapShader基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、概述-7"><span class="nav-number">2.5.4.1.1.</span> <span class="nav-text">1、概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、BitmapShader使用示例"><span class="nav-number">2.5.4.1.2.</span> <span class="nav-text">2、BitmapShader使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、TileMode模式解析"><span class="nav-number">2.5.4.1.3.</span> <span class="nav-text">3、TileMode模式解析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、TileMode-REPEAT模式：重复原图像来填充多余空间"><span class="nav-number">2.5.4.1.3.1.</span> <span class="nav-text">（1）、TileMode.REPEAT模式：重复原图像来填充多余空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、TileMode-MIRROR模式：重复使用镜像模式的图像来填充多余空间"><span class="nav-number">2.5.4.1.3.2.</span> <span class="nav-text">（2）、TileMode.MIRROR模式：重复使用镜像模式的图像来填充多余空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、TileMode-CLAMP-用边缘色彩填充多余空间"><span class="nav-number">2.5.4.1.3.3.</span> <span class="nav-text">（3）、TileMode.CLAMP:用边缘色彩填充多余空间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（4）、TileMode-CLAMP与填充顺序"><span class="nav-number">2.5.4.1.3.4.</span> <span class="nav-text">（4）、TileMode.CLAMP与填充顺序</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（5）、当MIRROR与REPEAT混用时"><span class="nav-number">2.5.4.1.3.5.</span> <span class="nav-text">（5）、当MIRROR与REPEAT混用时</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（6）、CLAMP模式与其它模式混用"><span class="nav-number">2.5.4.1.3.6.</span> <span class="nav-text">（6）、CLAMP模式与其它模式混用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、绘图位置与模式的关系"><span class="nav-number">2.5.4.1.4.</span> <span class="nav-text">4、绘图位置与模式的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、望远镜效果"><span class="nav-number">2.5.4.1.5.</span> <span class="nav-text">5、望远镜效果</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、利用BitmapShader生成不规则头像"><span class="nav-number">2.5.4.2.</span> <span class="nav-text">二、利用BitmapShader生成不规则头像</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、初步实现圆形头像控件"><span class="nav-number">2.5.4.2.1.</span> <span class="nav-text">1、初步实现圆形头像控件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、封装成控件"><span class="nav-number">2.5.4.2.2.</span> <span class="nav-text">2、封装成控件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、自定义属性"><span class="nav-number">2.5.4.2.2.1.</span> <span class="nav-text">（1）、自定义属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、控件解析"><span class="nav-number">2.5.4.2.2.2.</span> <span class="nav-text">（2）、控件解析</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、自测量"><span class="nav-number">2.5.4.2.2.3.</span> <span class="nav-text">（3）、自测量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（4）、绘图"><span class="nav-number">2.5.4.2.2.4.</span> <span class="nav-text">（4）、绘图</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（5）、XML中使用"><span class="nav-number">2.5.4.2.2.5.</span> <span class="nav-text">（5）、XML中使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（6）、存在问题"><span class="nav-number">2.5.4.2.2.6.</span> <span class="nav-text">（6）、存在问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、LinearGradient与闪动文字效果"><span class="nav-number">2.5.5.</span> <span class="nav-text">五、LinearGradient与闪动文字效果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、引言"><span class="nav-number">2.5.5.1.</span> <span class="nav-text">一、引言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、LinearGradient基本使用"><span class="nav-number">2.5.5.2.</span> <span class="nav-text">二、LinearGradient基本使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、构造函数-1"><span class="nav-number">2.5.5.2.1.</span> <span class="nav-text">1、构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、两色渐变使用示例"><span class="nav-number">2.5.5.2.2.</span> <span class="nav-text">2、两色渐变使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、多色渐变使用示例"><span class="nav-number">2.5.5.2.3.</span> <span class="nav-text">3、多色渐变使用示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、渐变起始坐标与填充的关系——矩形填充"><span class="nav-number">2.5.5.2.4.</span> <span class="nav-text">4、渐变起始坐标与填充的关系——矩形填充</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、TileMode-REPEAT"><span class="nav-number">2.5.5.2.4.1.</span> <span class="nav-text">（3）、TileMode.REPEAT</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（4）、TileMode-MIRROR"><span class="nav-number">2.5.5.2.4.2.</span> <span class="nav-text">（4）、TileMode.MIRROR</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、填充方式：从控件左上角开始填充"><span class="nav-number">2.5.5.2.5.</span> <span class="nav-text">6、填充方式：从控件左上角开始填充</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、闪光字符串实现"><span class="nav-number">2.5.5.3.</span> <span class="nav-text">三、闪光字符串实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、原理"><span class="nav-number">2.5.5.3.1.</span> <span class="nav-text">1、原理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#（1）、初始状态"><span class="nav-number">2.5.5.3.1.1.</span> <span class="nav-text">（1）、初始状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（2）、运动中"><span class="nav-number">2.5.5.3.1.2.</span> <span class="nav-text">（2）、运动中</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#（3）、终止状态"><span class="nav-number">2.5.5.3.1.3.</span> <span class="nav-text">（3）、终止状态</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、代码实现-1"><span class="nav-number">2.5.5.3.2.</span> <span class="nav-text">2、代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1、派生自TextView"><span class="nav-number">2.5.5.3.2.1.</span> <span class="nav-text">1、派生自TextView</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2、如何移动LinearGradient"><span class="nav-number">2.5.5.3.2.2.</span> <span class="nav-text">2、如何移动LinearGradient</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3、ValueAnimator的创建"><span class="nav-number">2.5.5.3.2.3.</span> <span class="nav-text">3、ValueAnimator的创建</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、RadialGradient与水波纹按钮效果"><span class="nav-number">2.6.</span> <span class="nav-text">六、RadialGradient与水波纹按钮效果</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、RadialGradient详解"><span class="nav-number">2.6.1.</span> <span class="nav-text">一、RadialGradient详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、构造函数-2"><span class="nav-number">2.6.1.1.</span> <span class="nav-text">1、构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）、两色渐变构造函数使用实例"><span class="nav-number">2.6.1.1.1.</span> <span class="nav-text">（1）、两色渐变构造函数使用实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）、多色渐变构造函数使用实例"><span class="nav-number">2.6.1.1.2.</span> <span class="nav-text">（2）、多色渐变构造函数使用实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1、TileMode重复方式"><span class="nav-number">2.6.1.2.</span> <span class="nav-text">1、TileMode重复方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）、X、Y轴共用填充参数"><span class="nav-number">2.6.1.2.1.</span> <span class="nav-text">（1）、X、Y轴共用填充参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）、TileMode-CLAMP——边缘填充"><span class="nav-number">2.6.1.2.2.</span> <span class="nav-text">（2）、TileMode.CLAMP——边缘填充</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）、TileMode-REPEAT——重复填充"><span class="nav-number">2.6.1.2.3.</span> <span class="nav-text">（3）、TileMode.REPEAT——重复填充</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）、TileMode-MIRROR—镜像填充"><span class="nav-number">2.6.1.2.4.</span> <span class="nav-text">（4）、TileMode.MIRROR—镜像填充</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（5）、填充方式：从控件左上角开始填充"><span class="nav-number">2.6.1.2.5.</span> <span class="nav-text">（5）、填充方式：从控件左上角开始填充</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、水波纹按钮效果"><span class="nav-number">2.6.2.</span> <span class="nav-text">二、水波纹按钮效果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、概述-8"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">1、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）、不过，第一个问题来了，从哪个颜色，渐变到哪个颜色呢？"><span class="nav-number">2.6.2.1.1.</span> <span class="nav-text">（1）、不过，第一个问题来了，从哪个颜色，渐变到哪个颜色呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）、第二个问题，我们应该怎么安排RadialGradient的填充模式"><span class="nav-number">2.6.2.1.2.</span> <span class="nav-text">（2）、第二个问题，我们应该怎么安排RadialGradient的填充模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、代码实现-2"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">2、代码实现</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MagicalRice</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  


  <script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"></script>
</body>
</html>
