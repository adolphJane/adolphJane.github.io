<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  RecyclerView源码解析 - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.ifantastic.ink ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>RecyclerView源码解析</h1>
     
        <div class="read-more clearfix">
          <span class="date">2020/07/07</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Android.html'>Android</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <p>Recyclerview是一个功能强大、好用，但复杂的控件。虽然其功能高度解耦，但所有的代码放在一个RecyclerView文件里也有高达1W3千多行代码。按模块分析源码，可以提高我们理解和阅读源码的效率。</p>
<span id="more"></span><!-- more -->
<h2><a id="recyclerview%E7%B1%BB%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView类图</h2>
<p><figure><img src="media/15941143181398/15951790156416.jpg" alt="" /></figure></p>
<h2><a id="recyclerview%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView绘制流程图</h2>
<p><figure><img src="media/15941143181398/15951790392948.jpg" alt="" /></figure></p>
<h2><a id="recyclerview%E6%BB%91%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView滑动流程图</h2>
<p><figure><img src="media/15941143181398/15951790559208.jpg" alt="" /></figure></p>
<h2><a id="recyclerview%E7%BC%93%E5%AD%98%E4%BB%8B%E7%BB%8D%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView缓存介绍图</h2>
<p><figure><img src="media/15941143181398/15951790783646.jpg" alt="" /></figure></p>
<h2><a id="recyclerview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView</h2>
<h3><a id="%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>构造方法</h3>
<ul>
<li>进行View相关配置属性设置，触摸范围、滑动速度等</li>
<li>设置Item动画监听器</li>
<li>初始化AdapterManager，创建AdapterHelper（负责Adapter里的数据集发生变化时的预处理操作）</li>
<li>初始化ChildHelper（负责管理和访问 RecyclerView 的子视图）</li>
<li>如果配置了LayoutManager 则通过反射方法创建它</li>
</ul>
<pre class="line-numbers"><code class="language-java"> public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        ...
        // View配置相关属性设置
        final ViewConfiguration vc = ViewConfiguration.get(context);
        mTouchSlop = vc.getScaledTouchSlop();
        mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
        mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
        setWillNotDraw(getOverScrollMode() == View.OVER_SCROLL_NEVER);
        
        // 设置Item动画监听器
        mItemAnimator.setListener(mItemAnimatorListener);
        // 设置 AdapterManager
        initAdapterManager();
        // 设置 ChildrenHelper 
        initChildrenHelper();
        // 硬件加速相关属性设置
        if (ViewCompat.getImportantForAccessibility(this)
                == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            ViewCompat.setImportantForAccessibility(this,
                    ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        mAccessibilityManager = (AccessibilityManager) getContext()
                .getSystemService(Context.ACCESSIBILITY_SERVICE);
        setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));
        
        // 如果attrs指定了LayoutManager，则创建LayoutManager
        boolean nestedScrollingEnabled = true;
        
        if (attrs != null) {
            int defStyleRes = 0;
            TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,
                    defStyle, defStyleRes);
            String layoutManagerName = a.getString(R.styleable.RecyclerView_layoutManager);
            int descendantFocusability = a.getInt(
                    R.styleable.RecyclerView_android_descendantFocusability, -1);
            if (descendantFocusability == -1) {
                setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            }
            a.recycle();
            // 反射方法创建 LayoutManager
            createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);

            if (Build.VERSION.SDK_INT &gt;= 21) {
                // SDK &gt;=21下 ，nestedScrollingEnabled状态支持变更
                a = context.obtainStyledAttributes(attrs, NESTED_SCROLLING_ATTRS,
                        defStyle, defStyleRes);
                nestedScrollingEnabled = a.getBoolean(0, true);
                a.recycle();
            }
        } else {
            setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
        }

        // 重置nestedScrollingEnabled状态 SDK 21以下默认true
        setNestedScrollingEnabled(nestedScrollingEnabled);
    }
</code></pre>
<h3><a id="setlayoutmanager" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setLayoutManager</h3>
<ul>
<li>处理重新设置一个新的LayoutManager的一些逻辑</li>
<li>设置this给到LayoutManager，并如果attach了则执行LayoutManger的attach分发实践</li>
<li>更新缓存大小，并请求重新布局</li>
</ul>
<pre class="line-numbers"><code class="language-java">public void setLayoutManager(LayoutManager layout) {
        if (layout == mLayout) {
            return;
        }
        stopScroll();
        // 设置新的layout情况下的一些处理逻辑
        ... 
        
        mChildHelper.removeAllViewsUnfiltered();
        mLayout = layout;
        if (layout != null) {
            // layout只能绑定一个mRecyclerView 
            if (layout.mRecyclerView != null) {
                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout +
                        &quot; is already attached to a RecyclerView: &quot; + layout.mRecyclerView);
            }
            // 设置this引用给LayoutManager
            mLayout.setRecyclerView(this);
            if (mIsAttached) {
                // 分发attach事件
                mLayout.dispatchAttachedToWindow(this);
            }
        }
        // 重新更新缓存大小 及请求重新布局
        mRecycler.updateViewCacheSize();
        requestLayout();
    }
</code></pre>
<h3><a id="setadapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setAdapter</h3>
<ul>
<li>接触frozen状态</li>
<li>设置新的Adapter，并触发一系列监听事件</li>
</ul>
<pre class="line-numbers"><code class="language-java">public void setAdapter(Adapter adapter) {
   // 解除frozen状态
   setLayoutFrozen(false);
   // 替换到当前Adapter，并触发监听
   setAdapterInternal(adapter, false, true);
   requestLayout();
}

private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,
            boolean removeAndRecycleViews) {
        // 旧Adapter进行解绑数据监听 和 RecyclerView的引用
        if (mAdapter != null) {
            mAdapter.unregisterAdapterDataObserver(mObserver);
            mAdapter.onDetachedFromRecyclerView(this);
        }
        if (!compatibleWithPrevious || removeAndRecycleViews) {
            removeAndRecycleViews(); // 移除缓存的View
        }
        mAdapterHelper.reset();
        final Adapter oldAdapter = mAdapter;
        mAdapter = adapter;
        if (adapter != null) {
            // 处理新设置的Adapter的关联监听和RecyclerView
            adapter.registerAdapterDataObserver(mObserver);
            adapter.onAttachedToRecyclerView(this);
        }
        // 通知LayoutManager Adapter变更
        if (mLayout != null) {
            mLayout.onAdapterChanged(oldAdapter, mAdapter);
        }
        // 触发Recycler Adapter变更事件
        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);
        // 状态置为 mStructureChanged 
        mState.mStructureChanged = true;
        markKnownViewsInvalid();
    }
</code></pre>
<h3><a id="onmeasure" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>onMeasure</h3>
<ul>
<li>未赋值layoutManager情况下，走默认measure，结果是无展示</li>
<li>系统提供的LayoutManager默认AutoMeasure。执行LayoutManger的onMeasure方法</li>
<li>如果未指定确定宽高的尺寸规格，则会进行布局，继而获得子View的大小。此过程可能执行两次</li>
</ul>
<pre class="line-numbers"><code class="language-java">   @Override
    protected void onMeasure(int widthSpec, int heightSpec) {
        // mLayout 是 LayoutManager，通过 setLayoutManager 方法设置，没有设置则为空
        if (mLayout == null) {
            defaultOnMeasure(widthSpec, heightSpec);
            return;
        }
        // 是否开启自动测量（RV 提供的几种 LM 都开启了自动测量）
        if (mLayout.isAutoMeasureEnabled()) {
            final int widthMode = MeasureSpec.getMode(widthSpec);
            final int heightMode = MeasureSpec.getMode(heightSpec);
            
            // 执行LayoutManager的onMeasure方法
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);

            final boolean measureSpecModeIsExactly =
                    widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;
            // 如果测量模式是 EXACTLY，退出
            if (measureSpecModeIsExactly || mAdapter == null) {
                return;
            }

            // 布局状态为 STEP_START 时，进行 step1
            if (mState.mLayoutStep == State.STEP_START) {
                dispatchLayoutStep1();
            }

            mLayout.setMeasureSpecs(widthSpec, heightSpec);
            mState.mIsMeasuring = true;
            // 进行 step2
            dispatchLayoutStep2();

            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);

            // 判断是否要测量两次
            if (mLayout.shouldMeasureTwice()) {
                mLayout.setMeasureSpecs(
                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
                mState.mIsMeasuring = true;
                dispatchLayoutStep2();
                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);
            }
        } else {
            // ...
        }
    }
</code></pre>
<p>RecyclerView 重写了 onMeasure 方法。该方法中，先判断是否有设置 LayoutManager，没有设置就执行 defaultOnMeasure。</p>
<p>设置了 LayoutManager 的话，就要判断 LayoutManager 是否开启了自动测量，开启的话就会使用默认的测量机制，否则就需要通过 LayoutManager 的 onMeasure 方法来完成测量工作。系统提供的几个 LayoutManager 都开启了自动测量。</p>
<p>自动测量时，涉及到一个重要的类：RecyclerView.State，这个类封装了当前 RecyclerView 的状态信息。其 mLayoutStep 变量表示当前 RecyclerView 的布局状态，状态有三种：</p>
<p>STEP_START<br />
STEP_LAYOUT<br />
STEP_ANIMATIONS<br />
一开始的状态为 STEP_START，调用完 dispatchLayoutStep1 方法后，状态变为 STEP_LAYOUT，表示接下来要进行布局，调用完 dispatchLayoutStep2 方法后，状态变为 State.STEP_ANIMATIONS，等待之后在 layout 时执行 dispatchLayoutStep3</p>
<p>这三个 step 负责不同的工作，step1 负责更新和记录状态，step2 真正进行布局，step3 执行动画并进行清理工作。</p>
<p>可以看到，在开启自动测量时，RecyclerView 如果是 WRAP_CONTENT 状态，就要根据子 View 所占空间大小动态调整自己的大小，这时它就将子 View 的 measure 和 layout 提前到 onMeasure 中，因为它需要确定子 View 的大小和位置后，再来设置自己的大小。所以就会在 onMeasure 中执行 step1 和 step2。</p>
<p>接下来看一下 RecyclerView 的 layout 过程</p>
<h3><a id="onlayout" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>onLayout</h3>
<ul>
<li>执行DispatchLayout方法</li>
<li>根据不同State状态，分别执行Step1、Step2、Step3方法</li>
</ul>
<pre class="line-numbers"><code class="language-java">    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);
        dispatchLayout();
        TraceCompat.endSection();
        mFirstLayoutComplete = true;
    }
</code></pre>
<p>调用 dispatchLayout</p>
<pre class="line-numbers"><code class="language-java">    void dispatchLayout() {
        // ...
        
        mState.mIsMeasuring = false;
        // 如果已经在 onMeasure 执行了 step1 和 step2，就不再执行 step1
        // 至于 step2，如果发现尺寸发生了改变，将会再执行一次
        if (mState.mLayoutStep == State.STEP_START) {
            dispatchLayoutStep1();
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()
                || mLayout.getHeight() != getHeight()) {
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else {
            mLayout.setExactMeasureSpecsFrom(this);
        }
        dispatchLayoutStep3();
    }
</code></pre>
<p>可以看到，如果已经在 onMeasure 执行了 step1 和 step2，就不再执行 step1，至于 step2，如果发现尺寸发生了改变，将会再执行一次，否则也不会执行。最后执行 step3。</p>
<p>下面分别看下这 3 个 step，首先看 step1</p>
<h4><a id="recyclerview-dispatchlayoutstep1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView#dispatchLayoutStep1</h4>
<ul>
<li>第一步layout方法</li>
<li>处理adapter变更</li>
<li>确定需要执行的动画</li>
<li>针对当前的Views进行信息缓存</li>
<li>如有必要，则进行预布局并缓存信息</li>
</ul>
<pre class="line-numbers"><code class="language-java">    private void dispatchLayoutStep1() {
        //  State状态断言 
        mState.assertLayoutStep(State.STEP_START);
        mState.mIsMeasuring = false;
        // 是否过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1
        eatRequestLayout();
        // 清楚 ViewInfo 所有状态和其存在的数据
        mViewInfoStore.clear();
        // 执行进入 layout或者scroll行为标志
        onEnterLayoutOrScroll();        
        // （1）执行Adapter变更及计算那些需要执行的动画
        processAdapterUpdatesAndSetAnimationFlags();
        // 存储焦点信息
        saveFocusInfo();
        // state状态信息设置
        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;
        mItemsAddedOrRemoved = mItemsChanged = false;
        mState.mInPreLayout = mState.mRunPredictiveAnimations;
        mState.mItemCount = mAdapter.getItemCount();
        // 寻找 layout过程中position的最大和最小值
        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);
        // （2）
        if (mState.mRunSimpleAnimations) {
            // ...
            int count = mChildHelper.getChildCount();
            for (int i = 0; i &lt; count; ++i) {
            // 遍历VieHolder
           final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
           if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) {
               continue;
           }
           // 创建 ItemHolderInfo
           final ItemHolderInfo animationInfo = mItemAnimator
                   .recordPreLayoutInformation(mState, holder,
                           ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),
                           holder.getUnmodifiedPayloads());
           // mViewInfoStore存储 holder及其对应animation信息
           mViewInfoStore.addToPreLayout(holder, animationInfo);
           if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()
               // 如果holder确定要更新，就把它添加到 oldChangeHolders 集合中
               mViewInfoStore.addToOldChangeHolders(key, holder);
           }  
        }
        if (mState.mRunPredictiveAnimations) {
            // 运行预布局
            // ...
        }
        // 执行退出 layout或者scroll行为标志
        onExitLayoutOrScroll();
        // 对应 mEatRequestLayout -1
        resumeRequestLayout(false);
        // 状态进入 State.STEP_LAYOUT
        mState.mLayoutStep = State.STEP_LAYOUT;
    }
</code></pre>
<p>先看注释（2），这里会根据 mRunSimpleAnimations 和 mRunPredictiveAnimations 的值来决定是否运行简单动画和预动画。这两个值是在哪里设置的呢？答案是在注释（1）的 processAdapterUpdatesAndSetAnimationFlags 方法处</p>
<h4><a id="recyclerview-processadapterupdatesandsetanimationflags" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView#processAdapterUpdatesAndSetAnimationFlags</h4>
<pre class="line-numbers"><code class="language-java">    private void processAdapterUpdatesAndSetAnimationFlags() {
        // ...
        
        // mItemsAddedOrRemoved：当有 item 添加或删除的时候设置为 ture
        // mItemsChanged：当有 item 的数据更新时设置为 true
        boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged;
        
        // 1. mFirstLayoutComplete：第一次 layout 完成后，设置为 true
        // 2. mItemAnimator：默认为 DefaultItemAnimator，可通过 RecyclerView 的 setItemAnimator 方法设置
        // 3. mDataSetHasChangedAfterLayout：调用 setAdapter、swapAdapter 或 notifyDateSetChanged 
        // 后设置为 true，在 layout 过程的 step3 中设置为 false
        // 4. mLayout.mRequestedSimpleAnimations：默认为 false，
        // 可以通过调用 LayoutManager 的 requestSimpleAnimationsInNextLayout 方法将该值设置为 true
        // 5. mAdapter.hasStableIds：默认为 false，可通过 Adapter 的 setHasStableIds 方法设置
        mState.mRunSimpleAnimations = mFirstLayoutComplete
                &amp;&amp; mItemAnimator != null
                &amp;&amp; (mDataSetHasChangedAfterLayout
                || animationTypeSupported
                || mLayout.mRequestedSimpleAnimations)
                &amp;&amp; (!mDataSetHasChangedAfterLayout
                || mAdapter.hasStableIds());
                
        // predictiveItemAnimationsEnabled：LinearLayoutManager 默认支持预动画，返回 true
        mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations
                &amp;&amp; animationTypeSupported
                &amp;&amp; !mDataSetHasChangedAfterLayout
                &amp;&amp; predictiveItemAnimationsEnabled();
    }
</code></pre>
<p>里面的一些属性在注释中已经有说明。这里以第一次 layout 为例，此时由于第一次 layout 过程还未完成，mFirstLayoutComplete 为 false，mRunSimpleAnimations 也就为 false，进而 mRunPredictiveAnimations 也为 false。</p>
<p>所以在第一次 layout 中，并不会进行简单动画和预动画。这里就先不分析了，详细过程在分析动画的时候再说。</p>
<p>下面重点看一下 step2</p>
<h4><a id="recyclerview-dispatchlayoutstep2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView#dispatchLayoutStep2</h4>
<ul>
<li>执行最终的View布局操作，该过程由LayoutManager完成</li>
<li>该方法可能会被多次执行</li>
</ul>
<pre class="line-numbers"><code class="language-java">private void dispatchLayoutStep2() {
   // 过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1。对应resumeRequestLayout方法进行消费
   eatRequestLayout();
   // 对应 onExitLayoutOrScroll
   onEnterLayoutOrScroll();
   mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);
   // 跳过预处理过程，一次性执行完所有的update
   mAdapterHelper.consumeUpdatesInOnePass();
   mState.mItemCount = mAdapter.getItemCount(); // 赋值 itemCOunt
   mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; 

   
   mState.mInPreLayout = false;
   // 执行 layout （执行 LayoutManager 布局）
   mLayout.onLayoutChildren(mRecycler, mState);

   mState.mStructureChanged = false;
   mPendingSavedState = null;
   mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null;
   // State状态进入 State.STEP_ANIMATIONS
   mState.mLayoutStep = State.STEP_ANIMATIONS;
   // 对应 onExitLayoutOrScroll
   onExitLayoutOrScroll();
   // 对应eatRequestLayout方法
   resumeRequestLayout(false);
}
</code></pre>
<p>step2 进行真正的布局，布局任务交由 LayoutManager 负责，调用其 onLayoutChildren 方法为所有子 View 布局。该方法交由具体的 LayoutManager 实现，这里以 LinearLayoutManager 为例，看一下它的 onLayoutChildren 实现</p>
<h4><a id="linearlayoutmanager-onlayoutchildren" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LinearLayoutManager#onLayoutChildren</h4>
<ul>
<li>Child布局执行核心方法</li>
<li>布局方式，通过确定锚点，首先以锚点为基准上到下布局，在以锚点为基准从下往上布局。如果还有空间，继续从上到下布局。最后确认整个间隙是正确的。（反向布局及横向反之则可）</li>
<li>该方法为LayoutManager布局核心执行方法，Child的测量和添加工作在fill这个重要方法执行，接下来会阐述</li>
</ul>
<pre class="line-numbers"><code class="language-java">    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // 确定是否需要反向布局
        // 确定锚点及偏移量 (1. 优先焦点child 2. 如果是反向布局，则找recycler里面最最接近尾部的child 3. 如果是正向，则找最接近头部的child)
        // 计算额外的偏移量（RecyclerView padding） 
        // ...

        // AnchorInfo 的 mValid 属性默认为 false 
        if (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION
                || mPendingSavedState != null) {
            mAnchorInfo.reset();
            // mShouldReverseLayout 和 mStackFromEnd 默认都为 false
            // 异或操作后结果仍为 false
            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
            // 找到锚点的位置，保存到 AnchorInfo 的 mPosition 中
            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);
            mAnchorInfo.mValid = true;
        }

        // ...
        
        // 锚点准备ready        
       onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
        // （1）临时 detach和回收当前的view 第一次 measure 的时候不会产生效果，因为此时 RecyclerView 还没有子 View。 而在第二第三次 layout 时，它会把子 View 从 RecyclerView 中 remove 或 detach ，并缓存子 View，以便之后重新 add 回来或 attach 回来，避免重复加载相同的子 View
        detachAndScrapAttachedViews(recycler);
        mLayoutState.mInfinite = resolveIsInfinite(); 
        mLayoutState.mIsPreLayout = state.isPreLayout();        
        
        // 开始填充view
        if (mAnchorInfo.mLayoutFromEnd) {
            // 反向填充
            // ...
        } else {
            // 正向填充
            // （基于锚点位置先 由上到下||由左到右）更新锚点信息
            updateLayoutStateToFillEnd(mAnchorInfo);
            // 额外的尾部偏移量
            mLayoutState.mExtra = extraForEnd;
            // 开始填充 View布局主要方法
            fill(recycler, mLayoutState, state, false);
            // 尾部位移
           endOffset = mLayoutState.mOffset;
           final int lastElement = mLayoutState.mCurrentPosition;
           if (mLayoutState.mAvailable &gt; 0) {
               extraForStart += mLayoutState.mAvailable;
           }

            // （基于锚点位置 由下到上||由右到左）更新锚点信息
            updateLayoutStateToFillStart(mAnchorInfo);
            mLayoutState.mExtra = extraForStart;
            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
            // 二次填充
            fill(recycler, mLayoutState, state, false);
            startOffset = mLayoutState.mOffset;
           // 仍有可用空间
           if (mLayoutState.mAvailable &gt; 0) {
               extraForEnd = mLayoutState.mAvailable;
               // 继续 （基于锚点位置先 由上到下||由左到右）更新信息并填充View
               updateLayoutStateToFillEnd(lastElement, endOffset);
               mLayoutState.mExtra = extraForEnd;
               fill(recycler, mLayoutState, state, false);
               endOffset = mLayoutState.mOffset;
           }
        }
        // 有滑动位置导致的gap间隙修复处理
       ...
       // 预布局动画处理
       ...
    }
</code></pre>
<p>注释（1）处调用了 detachAndScrapAttachedViews 方法，该方法会将子 View 移除并根据情况添加到相应缓存中。所以如果不是第一次 layout，RecyclerView 已经存在子 View 的话，在重新填充布局前，会将旧的子 View 添加到缓存中，这样之后填充布局时就可以直接从缓存中拿，不用再次创建子 View。</p>
<p>下面看下布局过程，主要分两步</p>
<h5><a id="1%E6%89%BE%E5%88%B0%E9%94%9A%E7%82%B9%EF%BC%88-auchor%E7%82%B9%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 找到锚点（auchor 点）</h5>
<p>该过程通过 updateAnchorInfoForLayout 方法实现</p>
<h6><a id="updateanchorinfoforlayout" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>updateAnchorInfoForLayout</h6>
<pre class="line-numbers"><code class="language-java">    private void updateAnchorInfoForLayout(RecyclerView.Recycler recycler, RecyclerView.State state,
            AnchorInfo anchorInfo) {
        // 一般这里都是返回 false
        if (updateAnchorFromPendingData(state, anchorInfo)) {
            return;
        }
        
        // 首先从子 View 中获取锚点
        if (updateAnchorFromChildren(recycler, state, anchorInfo)) {
            return;
        }

        // 没有从子 View 得到锚点，就将头或尾设置为锚点（默认将头设置为锚点）
        anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - 1 : 0;
    }
</code></pre>
<p>继续看下 updateAnchorFromChildren 方法，该方法从子 View 中获取锚点</p>
<h6><a id="updateanchorfromchildren" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>updateAnchorFromChildren</h6>
<pre class="line-numbers"><code class="language-java">    private boolean updateAnchorFromChildren(RecyclerView.Recycler recycler,
            RecyclerView.State state, AnchorInfo anchorInfo) {
        if (getChildCount() == 0) {
            return false;
        }
        // 将被 focus 的子 View 作为锚点
        final View focused = getFocusedChild();
        if (focused != null &amp;&amp; anchorInfo.isViewValidAsAnchor(focused, state)) {
            anchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
            return true;
        }
        
        if (mLastStackFromEnd != mStackFromEnd) {
            return false;
        }
        
        // 根据 layout 的方向决定锚点，默认从上往下，所以锚点在头部
        View referenceChild = anchorInfo.mLayoutFromEnd
                ? findReferenceChildClosestToEnd(recycler, state)
                : findReferenceChildClosestToStart(recycler, state);
        if (referenceChild != null) {
            anchorInfo.assignFromView(referenceChild, getPosition(referenceChild));
            // ...
            return true;
        }
        return false;
    }
</code></pre>
<p>可以看到，优先选择被 focus 的子 View 作为锚点，没有的话就根据布局方向决定锚点，默认从上往下布局，所以锚点选取头部。</p>
<p>如果想要从下往上布局，可以这样设置</p>
<pre class="line-numbers"><code class="language-java">    linearLayoutManager.setStackFromEnd(true);
</code></pre>
<p>这样的话，锚点会在尾部，数据加载完后首先显示的是底部的数据。</p>
<h5><a id="2%E5%A1%AB%E5%85%85%E5%B8%83%E5%B1%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 填充布局</h5>
<p>根据布局方向，先后填充满锚点上方和下方的所有区域</p>
<p>填充的过程调用 fill 方法</p>
<h6><a id="fill" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>fill</h6>
<ul>
<li>如果是滑动流程，则根据情况进行回收流程</li>
<li>LayoutState中部分成员变量含义，mOffset：填充起始坐标，mCurrentPosition：填充起始数据的position，mAvailable：本次滑动可填充的距离，mScrollingOffset：滑动过的总量循环依次加载子View</li>
<li>确定可布局大小，直至布局大小消费完成</li>
<li>加载子View在 layoutChunk 中执行</li>
</ul>
<pre class="line-numbers"><code class="language-java">    int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {
        // ...
        // 可布局的位移
        final int start = layoutState.mAvailable;
        // 滑动偏移的情况下        
        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            if (layoutState.mAvailable &lt; 0) {
                layoutState.mScrollingOffset += layoutState.mAvailable;
            }
            // 进行回收工作
            recycleByLayoutState(recycler, layoutState);
        }
        // 余量大小
        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
        // 每次布局结果中间记录 方便运算  
        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
        while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) {
            // ...
            layoutChunkResult.resetInternal();
            // （1）加载子View
            layoutChunk(recycler, state, layoutState, layoutChunkResult);

            if (layoutChunkResult.mFinished) {
                break;
            }
       
            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;
            // 计算布局使用过的大小值
            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null
               || !state.isPreLayout()) {
                layoutState.mAvailable -= layoutChunkResult.mConsumed;
                remainingSpace -= layoutChunkResult.mConsumed;
            }
            // 如果当前正在滚动屏幕
            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;
                if (layoutState.mAvailable &lt; 0) {
                    layoutState.mScrollingOffset += layoutState.mAvailable;
                }
                // 把移出屏幕的 View 缓存到 mCachedViews 里面
                recycleByLayoutState(recycler, layoutState);
            }
            if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) {
                break;
            }
        }
        return start - layoutState.mAvailable;
    }
</code></pre>
<p>看注释（1）处，在 while 循环里有一个 layoutChunk 方法，只要还有剩余空间，就不会不断执行该方法</p>
<h6><a id="layoutchunk" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>layoutChunk</h6>
<ul>
<li>通过layoutState.next(recycler)获取目标布局View</li>
<li>获取目标View完毕后，进行含装饰的Margin计算，并执行布局</li>
</ul>
<pre class="line-numbers"><code class="language-java">    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result) {
        // （1） 获取下一个布局View （核心方法）
        View view = layoutState.next(recycler);

        // ...
        
        // 除非特殊指定，否则mScrapList为null
        LayoutParams params = (LayoutParams) view.getLayoutParams();
        if (layoutState.mScrapList == null) {
            // mShouldReverseLayout 默认为 false，可通过 LLM 的 setReverseLayout 方法设置
            // 从上往下填充布局时，layoutState.mLayoutDirection 为 LayoutState.LAYOUT_END
            // 默认情况下，从上往下布局时进入 if 块
            if (mShouldReverseLayout == (layoutState.mLayoutDirection
                    == LayoutState.LAYOUT_START)) {
                // （2）添加到末尾
                addView(view);
            } else {
                // 添加到第一个位置
                addView(view, 0);
            }
        } else {
            // ...
        }

        measureChildWithMargins(view, 0, 0); // 测量子View的Margins
        // 计算 含装饰的Margin值的大小
        result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);
        int left, top, right, bottom;
        // 计算 r、l、t、b的值
        if (mOrientation == VERTICAL) {
            if (isLayoutRTL()) {
                right = getWidth() - getPaddingRight();
                left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);
            } else {
                left = getPaddingLeft();
                right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);
            }
            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
                bottom = layoutState.mOffset;
                top = layoutState.mOffset - result.mConsumed;
            } else {
                top = layoutState.mOffset;
                bottom = layoutState.mOffset + result.mConsumed;
            }
        } else {
            ...
        }
        
        // 对View进行布局
        layoutDecoratedWithMargins(view, left, top, right, bottom);
        // 部分状态改变 
        if (params.isItemRemoved() || params.isItemChanged()) {
            result.mIgnoreConsumed = true;
        }
        result.mFocusable = view.hasFocusable();
    }
</code></pre>
<p>先看注释（1）处，这里返回下一个要填充的 View，来看下具体过程</p>
<pre class="line-numbers"><code class="language-java">    View next(RecyclerView.Recycler recycler) {
        // ...
        // 除非定制View，不然为null
        if (mScrapList != null) { 
            return nextViewFromScrapList();
        }
        //通过RecyclerView.Recycler 获取目标position对应的View
        final View view = recycler.getViewForPosition(mCurrentPosition);
        // 当前pos 增加
        mCurrentPosition += mItemDirection;
        return view;
    }
</code></pre>
<p>可以看到，获取 View 的工作也是交给了 Recycler，通过 Recycler 的 getViewForPosition 来获取一个指定位置的子 View，该方法在 Recycler 已经分析过了。</p>
<p>继续看注释（2）处的 addView 方法</p>
<pre class="line-numbers"><code class="language-java">    private void addViewInt(View child, int index, boolean disappearing) {
        final ViewHolder holder = getChildViewHolderInt(child);
        
        // ...
        
        // 该 ViewHolder 从 ChangedScrap、AttachedScrap、HiddenViews 中得到
        // 或者该 ViewHolder 曾经通过 scrapView 方法缓存到 Scrap 缓存中 
        if (holder.wasReturnedFromScrap() || holder.isScrap()) {
            // 做些清理工作：删除 Scrap 缓存、清除标记等
            if (holder.isScrap()) {
                holder.unScrap();
            } else {
                holder.clearReturnedFromScrapFlag();
            }
            // 子 View 重新 attach 到 RecyclerView 中
            mChildHelper.attachViewToParent(child, index, child.getLayoutParams(), false);
            // DISPATCH_TEMP_DETACH：该值默认为 false，且没看到有地方将其设置为 true
            if (DISPATCH_TEMP_DETACH) {
                ViewCompat.dispatchFinishTemporaryDetach(child);
            }
        } 
        // 该子 View 一直是有效的，只是可能要移动下位置（对应滑动时没有滑出屏幕的子 View）
        else if (child.getParent() == mRecyclerView) {
            int currentIndex = mChildHelper.indexOfChild(child);
            if (index == -1) {
                index = mChildHelper.getChildCount();
            }
            // 将该子 View 移动到正确位置
            if (currentIndex != index) {
                mRecyclerView.mLayout.moveView(currentIndex, index);
            }
        } 
        // 其他情况，例如从 CahcedView 或 RecycledViewPool 得到的缓存 View，或者是新创建的 View
        else {
            mChildHelper.addView(child, index, false);
            lp.mInsetsDirty = true;
            if (mSmoothScroller != null &amp;&amp; mSmoothScroller.isRunning()) {
                mSmoothScroller.onChildAttachedToWindow(child);
            }
        }
        
        // ...
    }
</code></pre>
<p>该方法通过判断 View 的来源，利用不同的方式将子 View 添加到 RecyclerView 中，填充完布局。</p>
<p>最后看一下 step3</p>
<h4><a id="dispatchlayoutstep3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>dispatchLayoutStep3</h4>
<p>layout过程最后一步，执行相关动画和一些清理事项</p>
<pre class="line-numbers"><code class="language-java">    private void dispatchLayoutStep3() {
        // ...
        
        // 将 layout 状态重置回 State.STEP_START
        mState.mLayoutStep = State.STEP_START;
        
        // 执行动画
        if (mState.mRunSimpleAnimations) {
            // ...
        }

        // 清空 attachedScrap
        mLayout.removeAndRecycleScrapInt(mRecycler);
        // 重置一系列的变量
        mState.mPreviousLayoutItemCount = mState.mItemCount;
        mDataSetHasChangedAfterLayout = false;
        mDispatchItemsChangedEvent = false;
        mState.mRunSimpleAnimations = false;

        mState.mRunPredictiveAnimations = false;
        mLayout.mRequestedSimpleAnimations = false;
        // 清空 changedScrao
        if (mRecycler.mChangedScrap != null) {
            mRecycler.mChangedScrap.clear();
        }

        // 其它清理工作
    }
</code></pre>
<p>step3 主要是执行动画和进行一系列的清理工作，例如重置 layout 状态，清理 Scrap 缓存等等。由于在第一次布局时，mState.mRunSimpleAnimations 为 false，不会执行动画，动画部分就先不分析了。</p>
<h4><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h4>
<p>前面说了这么多，这里小结一下 onLayout 的过程：</p>
<p>layout 过程分为 3 个 step，step1 负责更新和记录状态，step2 真正进行布局，step 执行动画并进行清理工作。如果 RecyclerView 的宽高为 WRAP_CONTENT 模式，那么需要在 measure 过程提前进行 step1 和 step2，先获得子 View 的大小，才能确定自己的大小。而 step3 肯定是在 layout 过程执行。<br />
step2 真正进行布局，布局任务由 LayoutManager 负责，通过它的 onLayoutChildren 方法对子 View 进行布局。布局过程分两步：<br />
找到锚点，优先选择被 focus 的子 View 作为锚点，没有的话就根据布局方向决定锚点，默认头部为锚点。<br />
根据布局方向，先后填充满锚点上方和下方的区域，填充所需的 View 交由 Recycler 提供。</p>
<h3><a id="draw" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>draw</h3>
<ul>
<li>绘制ItemDecoration的onDraw部分</li>
<li>绘制Children</li>
<li>绘制ItemDecoration的drawOver部分</li>
<li>根据mClipToPadding的值来判断是否进行特殊绘制。</li>
</ul>
<p>主要涉及Item装饰的绘制和动画</p>
<pre class="line-numbers"><code class="language-java">public void draw(Canvas c) {
   super.draw(c);

   final int count = mItemDecorations.size();
   for (int i = 0; i &lt; count; i++) {
       mItemDecorations.get(i).onDrawOver(c, this, mState);
   }
  
   boolean needsInvalidate = false;
   ...
   if (!needsInvalidate &amp;&amp; mItemAnimator != null &amp;&amp; mItemDecorations.size() &gt; 0 &amp;&amp;
           mItemAnimator.isRunning()) {
       needsInvalidate = true;
   }

   if (needsInvalidate) {
       ViewCompat.postInvalidateOnAnimation(this);
   }
}
    
public void onDraw(Canvas c) {
   super.onDraw(c);

   final int count = mItemDecorations.size();
   for (int i = 0; i &lt; count; i++) {
       mItemDecorations.get(i).onDraw(c, this, mState);
   }
}
</code></pre>
<h2><a id="recycler" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recycler</h2>
<blockquote>
<p>A Recycler is responsible for managing scrapped or detached item views for reuse.</p>
</blockquote>
<p>意思就是 Recycler 负责管理废弃或被 detached 的 item 视图，以便重复利用。</p>
<h3><a id="%E4%B8%BB%E8%A6%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主要成员变量</h3>
<pre class="line-numbers"><code class="language-java">final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();

ArrayList&lt;ViewHolder&gt; mChangedScrap = null;

final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();

RecycledViewPool mRecyclerPool;

private ViewCacheExtension mViewCacheExtension;
</code></pre>
<p>这几个成员变量都和 RecyclerView 的缓存相关，如果按照四级缓存的话，它们可以这样划分:</p>
<blockquote>
<p>第一级缓存：mAttachedScrap、mChangedScrap<br />
第二级缓存：mCachedViews<br />
第三级缓存：ViewCacheExtension<br />
第四级缓存：RecycledViewPool</p>
</blockquote>
<h4><a id="recycledviewpool" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecycledViewPool</h4>
<blockquote>
<p>RecycledViewPool lets you share Views between multiple RecyclerViews.</p>
</blockquote>
<p>RecycledViewPool 用于在多个 RecyclerView 间共享 View。</p>
<p>在使用时，只需创建 RecycledViewPool 实例，然后调用 RecyclerView 的 setRecycledViewPool(RecycledViewPool) 方法即可。</p>
<p>RecycledViewPool 存储在 Recycler 中，通过 Recycler 存取。</p>
<h5><a id="%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>成员变量</h5>
<p>RecycledViewPool 有一个重要的成员变量</p>
<pre class="line-numbers"><code class="language-java">// SparseArray 类似于 key 为 int 类型 的 HashMap
SparseArray&lt;ScrapData&gt; mScrap = new SparseArray&lt;&gt;();
</code></pre>
<pre class="line-numbers"><code class="language-java">static class ScrapData {
    final ArrayList&lt;ViewHolder&gt; mScrapHeap = new ArrayList&lt;&gt;();
    int mMaxScrap = DEFAULT_MAX_SCRAP;
    long mCreateRunningAverageNs = 0;
    long mBindRunningAverageNs = 0;
}
</code></pre>
<p>mScrap 是一个 &lt;int, ScrapData&gt; 的映射，其中 int 代表了 viewType，ScrapData 则存储了一个 ViewHolder 集合。</p>
<h5><a id="%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主要方法</h5>
<p><code>getScrapDataForType</code>: 该方法根据 viewType 获取相应的 ScrapData，如果该 viewType 还没有绑定 ScrapData，就新创建一个 ScrapData 并绑定到该 viewType。</p>
<pre class="line-numbers"><code class="language-java">private ScrapData getScrapDataForType(int viewType) {
    ScrapData scrapData = mScrap.get(viewType);
    if (scrapData == null) {
        scrapData = new ScrapData();
        mScrap.put(viewType, scrapData);
    }
    return scrapData;
}
</code></pre>
<p><code>setMaxRecycledViews</code>: 该方法可以设置相应 viewType 的 View 容量，超出容量时，从后面开始删除，直到满足新的容量。</p>
<pre class="line-numbers"><code class="language-java">public void setMaxRecycledViews(int viewType, int max) {
    ScrapData scrapData = getScrapDataForType(viewType);
    scrapData.mMaxScrap = max;
    final ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;
    // 从后面开始删除，直到满足新的容量
    while (scrapHeap.size() &gt; max) {
        scrapHeap.remove(scrapHeap.size() - 1);
    }
}
</code></pre>
<p><code>getRecycledView</code>: 该方法根据 viewType 获取一个 ViewHolder，获取到的 ViewHolder 将会被移除出 Scrap 堆。获取不到则返回 null。</p>
<pre class="line-numbers"><code class="language-java">@Nullable
public ViewHolder getRecycledView(int viewType) {
    final ScrapData scrapData = mScrap.get(viewType);
    if (scrapData != null &amp;&amp; !scrapData.mScrapHeap.isEmpty()) {
        final ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;
        for (int i = scrapHeap.size() - 1; i &gt;= 0; i--) {
            if (!scrapHeap.get(i).isAttachedToTransitionOverlay()) {
                return scrapHeap.remove(i);
            }
        }
    }
    return null;
}
</code></pre>
<p><code>putRecycledView</code>: 该方法也很好理解，根据 ViewHolder 的 viewType 放入 RecycledViewPool 的相应集合中，如果集合已满，不再添加。</p>
<pre class="line-numbers"><code class="language-java">public void putRecycledView(ViewHolder scrap) {
    final int viewType = scrap.getItemViewType();
    final ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap;
    if (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) {
        return;
    }
    if (DEBUG &amp;&amp; scrapHeap.contains(scrap)) {
        throw new IllegalArgumentException(&quot;this scrap item already exists&quot;);
    }
    scrap.resetInternal();
    scrapHeap.add(scrap);
}
</code></pre>
<h4><a id="viewcacheextension" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewCacheExtension</h4>
<p>ViewCacheExtension 是一个由开发者控制的 View 缓存帮助类</p>
<pre class="line-numbers"><code class="language-java">public abstract static class ViewCacheExtension {
    /**
      * Returns a View that can be binded to the given Adapter position.
      */
    @Nullable
    public abstract View getViewForPositionAndType(@NonNull Recycler recycler, int position,int type);
}
</code></pre>
<p>开发者可以实现这个抽象类，通过调用 RecyclerView 的 setViewCacheExtension(ViewCacheExtension) 方法设置，最终将 ViewCacheExtension 存储在 Recycler 中。</p>
<p>当调用 Recycler 的 getViewForPosition 方法时，如果 attached scrap 和 已经缓存都没有找到合适的 View，就会调用 ViewCacheExtension 的 getViewForPositionAndType 方法来获取 View。</p>
<p>需要注意的是，Recycler 不会对这个类做任何缓存处理，是否需要缓存 View 由开发者自己控制。</p>
<h3><a id="%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主要方法</h3>
<h4><a id="getviewforposition" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getViewForPosition</h4>
<p>getViewForPosition 方法比较重要，用于获取某个位置需要展示的 View,最终执行tryGetViewHolderForPositionByDeadline获取View</p>
<pre class="line-numbers"><code class="language-java">public View getViewForPosition(int position) {
    return getViewForPosition(position, false);
}
    
View getViewForPosition(int position, boolean dryRun) {
    return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;
}
</code></pre>
<p>继续看 tryGetViewHolderForPositionByDeadline 方法，该方法会依次从几个缓存中获取</p>
<h4><a id="trygetviewholderforpositionbydeadline" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>tryGetViewHolderForPositionByDeadline</h4>
<ul>
<li>获取ViewHolder方法</li>
<li>如果是预布局，线通过ChangeScrap中获取</li>
<li>第一次尝试获取VH，依次从Scrap、Hidden、Cache中获取VH</li>
<li>第二次尝试获取VH，针对具有StableId的Adapter，根据id依次从Scrap和Cache获取</li>
<li>第三次尝试从自定义缓存中获取VH</li>
<li>第四次尝试从Recycler获取VH</li>
<li>最后直接创建VH</li>
</ul>
<pre class="line-numbers"><code class="language-java">ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
    boolean fromScrapOrHiddenOrCache = false;
    ViewHolder holder = null;
    // 0) 如果是预布局， 从mChangedScrap中获取 
    if (mState.isPreLayout()) {
        holder = getChangedScrapViewForPosition(position);
        fromScrapOrHiddenOrCache = holder != null;
    }
    // 1) 第一次尝试获取，依次从Scrap、Hidden、Cache中获取VH
    if (holder == null) {
        // 依次从Scrap、Hidden、Cache中获取VH
        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
        //... 
    }
    if (holder == null) {
        final int offsetPosition = mAdapterHelper.findPositionOffset(position);
        final int type = mAdapter.getItemViewType(offsetPosition);
        // 2) 第二次尝试获取，当Adapter具备StableIds情况
        if (mAdapter.hasStableIds()) {
            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                  type, dryRun);
            if (holder != null) {
                // update position
                holder.mPosition = offsetPosition;
                fromScrapOrHiddenOrCache = true;
            }
        }
        // 3) 第三次尝试从 自定义缓存获取
        if (holder == null &amp;&amp; mViewCacheExtension != null) {
            final View view = mViewCacheExtension
                  .getViewForPositionAndType(this, position, type);
            if (view != null) {
                holder = getChildViewHolder(view);
                //...
            }
        }
        // 4) 第四次尝试 从 RecyclerPool中获取
        if (holder == null) { // fallback to pool
            holder = getRecycledViewPool().getRecycledView(type);
            //...
        }
        // 5) 开始创建
        if (holder == null) {
            long start = getNanoTime();
            // 创建VH
            holder = mAdapter.createViewHolder(RecyclerView.this, type);
            //... 
        }
      
        boolean bound = false;
        if (mState.isPreLayout() &amp;&amp; holder.isBound()) {
            holder.mPreLayoutPosition = position;
        } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
            // 为bind过，执行bind方法
            final int offsetPosition = mAdapterHelper.findPositionOffset(position);
            bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
       }
    }

    private boolean tryBindViewHolderByDeadline(ViewHolder holder, int offsetPosition, int position, long deadlineNs) {
        //...
        // 执行Adapter bindViewHolder方法
        mAdapter.bindViewHolder(holder, offsetPosition);
        //...
        return true;
    }
</code></pre>
<pre class="line-numbers"><code class="language-java">    // 如果是处于预布局阶段（先简单理解为执行 dispatchLayoutStep1 方法）
    // （其实下面方法要返回 ture 还需要开启“预处理动画”，这跟动画有关，先不多说）
    if (mState.isPreLayout()) {
        holder = getChangedScrapViewForPosition(position);
        fromScrapOrHiddenOrCache = holder != null;
    }
</code></pre>
<h5><a id="%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%BB%8Emchangedscrap%E4%B8%AD%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%B0%B1%E8%BF%94%E5%9B%9E-null%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一步 从 mChangedScrap 中获取，获取不到就返回 null。</h5>
<p>针对的是预布局状态，从mChangedScrap中获取目标ViewHolder<br />
ScrapView：View仍然attach在其父RecyclerView上且可以被重复绑定数据及重复使用。将View标记为Scrap过程中分为两大类mAttachedScrap 和 mChangedScrap。<br />
mAttachedScrap：VH有ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID这两个Flag，或者VH是没有被更新过的，或者是可以被重新更新的VH。<br />
其它则是mChangedScrap</p>
<pre class="line-numbers"><code class="language-java">ViewHolder getChangedScrapViewForPosition(int position) {
  // 必须是预布局状态，取mChangedScrap中的ViewHolder
  final int changedScrapSize;
  if (mChangedScrap == null || (changedScrapSize = mChangedScrap.size()) == 0) {
      return null;
  }
  // 通过position获取
  for (int i = 0; i &lt; changedScrapSize; i++) {
      final ViewHolder holder = mChangedScrap.get(i);
      if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position) {
          holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
          return holder;
      }
  }
  // 如果Adapter是固定id，尝试从Adapter获取
  if (mAdapter.hasStableIds()) {
      final int offsetPosition = mAdapterHelper.findPositionOffset(position);
      if (offsetPosition &gt; 0 &amp;&amp; offsetPosition &lt; mAdapter.getItemCount()) {
          final long id = mAdapter.getItemId(offsetPosition);
          for (int i = 0; i &lt; changedScrapSize; i++) {
              final ViewHolder holder = mChangedScrap.get(i);
              if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getItemId() == id) {
                  holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
                  return holder;
              }
          }
      }
  }
  return null;
}

// Mark an attached view as scrap.
void scrapView(View view) {
       final ViewHolder holder = getChildViewHolderInt(view);
       if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
               || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
           holder.setScrapContainer(this, false);
           mAttachedScrap.add(holder);
       } else {
           if (mChangedScrap == null) {
               mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
           }
           holder.setScrapContainer(this, true);
           mChangedScrap.add(holder);
       }
}
</code></pre>
<h5><a id="%E7%AC%AC%E4%BA%8C%E6%AD%A5%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96vh%EF%BC%88attachscrap%E3%80%81hidden%E3%80%81cacheview%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二步 第一次尝试获取VH（AttachScrap、Hidden、CacheView）</h5>
<p>根据 position 依次从 mAttachedScrap、mHiddenViews（存储在 ChildHelper 类）、mCachedViews 中获取缓存的 ViewHolder。</p>
<p>可以从 mHiddenViews 获取到缓存的话，就将其从 mHiddenViews 移除并添加到 Scrap 缓存（根据情况添加到 mAttachedScrap 或 mChangedScrap）。可以从 mCacheViews 中获取到缓存的话，就将其从 mCacheViews 移除。</p>
<p>获取到后，发现无效的话，将对获取到的 ViewHolder 进行清理并回收（放入 mCachedViews 或 RecycledViewPool）。</p>
<ul>
<li>先从 mAttachedScrap中获取VH</li>
<li>从隐藏且未移出的View中获取 View</li>
<li>从一级缓存CacheView中获取</li>
</ul>
<pre class="line-numbers"><code class="language-java">ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) {
       final int scrapCount = mAttachedScrap.size();

       // 先从 mAttachedScrap中获取VH
       for (int i = 0; i &lt; scrapCount; i++) {
           final ViewHolder holder = mAttachedScrap.get(i);
           // 验证VH是否可用，若可用，则直接返回该VH
           if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position
                   &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) {
               holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
               return holder;
           }
       }
       // dryRun 传递是false（代表VH在scrap、cache中可以被Removed）
       if (!dryRun) {
           // 从隐藏且未移出的View中获取 View
           View view = mChildHelper.findHiddenNonRemovedView(position);
           if (view != null) {
               // View可用，则进行可视、detach、scrap缓存
               final ViewHolder vh = getChildViewHolderInt(view);
               mChildHelper.unhide(view);
               int layoutIndex = mChildHelper.indexOfChild(view);
               mChildHelper.detachViewFromParent(layoutIndex);
               scrapView(view);
               vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP
                       | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
               return vh;
           }
       }

       // 从第一级缓存View中获取
       final int cacheSize = mCachedViews.size();
       for (int i = 0; i &lt; cacheSize; i++) {
           final ViewHolder holder = mCachedViews.get(i);
           // VH是有效的
           if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) {
               if (!dryRun) {
                   mCachedViews.remove(i); // 移出获取的cache
               }
               return holder; // 返回VH
           }
       }
       return null;
}
</code></pre>
<h5><a id="%E7%AC%AC%E4%B8%89%E6%AD%A5%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%8F%96vh%EF%BC%88adapter%E6%9C%89%E7%A8%B3%E5%AE%9Aid%E6%83%85%E5%86%B5%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三步 第二次尝试获取VH（Adapter有稳定id情况）</h5>
<ul>
<li>Adapter配置的id是稳定的，稳定指数据集变化的时候，对于同一数据对应的id是唯一的</li>
<li>先尝试从Scrap获取VH，非dryRun下，将未命中的从Scrap中移出，并加入到Cache或Pool缓存</li>
<li>在尝试从Cache获取VH，将未命中的从Cache中移出，并加入到Pool缓存</li>
</ul>
<pre class="line-numbers"><code class="language-java">    // 如果用户设置了 ViewCacheExtension
    if (holder == null &amp;&amp; mViewCacheExtension != null) {
        // We are NOT sending the offsetPosition because LayoutManager does not
        // know it.
        final View view = mViewCacheExtension
                .getViewForPositionAndType(this, position, type);
        if (view != null) {
            holder = getChildViewHolder(view);
            // ...
        }
    }
</code></pre>
<h5><a id="%E7%AC%AC%E5%9B%9B%E6%AD%A5%E4%BB%8E%E7%94%A8%E6%88%B7%E8%AE%BE%E7%BD%AE%E7%9A%84viewcacheextension%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%BC%93%E5%AD%98%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%8E%B7%E5%8F%96%E5%88%B0%E5%B0%B1%E7%BB%A7%E7%BB%AD%E5%BE%80%E4%B8%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第四步 从用户设置的 ViewCacheExtension 中获取缓存，没有获取到就继续往下：</h5>
<pre class="line-numbers"><code class="language-java">    if (holder == null) { // fallback to pool
        holder = getRecycledViewPool().getRecycledView(type);
        // ...
    }
</code></pre>
<h5><a id="%E7%AC%AC%E4%BA%94%E6%AD%A5%E6%A0%B9%E6%8D%AEviewtype%E4%BB%8E-recycledviewpool%E4%B8%AD%E5%BE%97%E5%88%B0%E7%BC%93%E5%AD%98%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第五步 根据 viewType 从 RecycledViewPool 中得到缓存。</h5>
<p>RecycledViewPool 已经是最后一级缓存了，如果这里也没有获取到，只能通过 Adapter 的 createViewHolder 方法创建一个 ViewHolder：</p>
<pre class="line-numbers"><code class="language-java">    if (holder == null) {
        holder = mAdapter.createViewHolder(RecyclerView.this, type);
        // ...
    }
</code></pre>
<h5><a id="%E5%B0%8F%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小结</h5>
<p>获取某个位置的View的过程</p>
<ol>
<li>先后根据 position 或 id 从 mChangedScrap 中获取缓存</li>
<li>根据 position 依次从 mAttachedScrap、mHiddenViews（存储在 ChildHelper 类）、mCachedViews 中获取缓存</li>
<li>根据 id 依次从 mAttachedScrap、mCachedViews 中获取缓存</li>
<li>从用户设置的 ViewCacheExtension 中获取缓存</li>
<li>从 RecycledViewPool 中得到缓存的废弃 ViewHolder</li>
<li>通过 Adapter 的 createViewHolder 方法创建一个 ViewHolder</li>
</ol>
<h4><a id="recycleview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>recycleView</h4>
<p>既然叫 Recycler，那肯定要做回收工作了，recycleView 方法就完成了这些工作，下面看一下该方法的实现：</p>
<pre class="line-numbers"><code class="language-java">    public void recycleView(@NonNull View view) {
        ViewHolder holder = getChildViewHolderInt(view);
        // ...
        recycleViewHolderInternal(holder);
    }
</code></pre>
<p>继续看 recycleViewHolderInternal：</p>
<pre class="line-numbers"><code class="language-java">    void recycleViewHolderInternal(ViewHolder holder) {
        // ...

        if (forceRecycle || holder.isRecyclable()) {
            if (mViewCacheMax &gt; 0
                    &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                    | ViewHolder.FLAG_REMOVED
                    | ViewHolder.FLAG_UPDATE
                    | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
                        
                int cachedViewSize = mCachedViews.size();
                // 若 CacheViews 达到最大容量（2），将最老的缓存从 CacheViews 移除，并添加到 RecycledViewPool 中
                if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) {
                    recycleCachedViewAt(0);
                    cachedViewSize--;
                }

                // ...
                
                // 将 View 缓存到 mCachedViews 中
                mCachedViews.add(targetCacheIndex, holder);
                cached = true;
            }
            if (!cached) {
                // 没有添加到 mCachedViews 的话，就添加到 RecycledViewPool 中
                addViewHolderToRecycledViewPool(holder, true);
                recycled = true;
            }
        }

        // ...
    }
</code></pre>
<p>可以看到，回收过程主要涉及到两层缓存，第一层缓存是 CacheViews，在添加时，如果发现原来的 CacheViews 已经达到最大容量，就将最老的缓存从 CacheViews 移除，并添加到 RecycledViewPool。第二层缓存是 RecycledViewPool，如果不能添加到 mCacheViews，就会添加到 RecycledViewPool 中。</p>
<h4><a id="mchangedscrap%E5%92%8C-mattachedscrap%E4%B8%AD%E7%9A%84-view%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mChangedScrap 和 mAttachedScrap 中的 View 从何而来</h4>
<p>在执行 Recycler 的 recycleView 方法时，会将回收的 View 缓存到 mCahceViews 或 recycledViewPool 中，那么另外两个 Scrap 缓存（mChangedScrap 和 mAttachedScrap）中的 View 是何时添加进来的呢？</p>
<p>无论是 mAttachedScrap 还是 mChangedScrap ，它们获得 View 的途径都只有一个，那就是通过 Recycler 的 scrapView 方法。先看下该方法：</p>
<h4><a id="scrapview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>scrapView</h4>
<pre class="line-numbers"><code class="language-java">    void scrapView(View view) {
        final ViewHolder holder = getChildViewHolderInt(view);
        
        // 满足这几个条件中的一个就可以进入 if 循环，有机会将 View 缓存到 mAttachedScrap
        // 1. ViewHolder 设置了 FLAG_REMOVED 或 FLAG_INVALID
        // 2. ViewHolder 没有设置 FLAG_UPDATE
        // 3. 没有设置动画或者动画可以重用该 ViewHolder
        if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
            if (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) {
                throw new IllegalArgumentException(&quot;Called scrap view with an invalid view.&quot;
                        + &quot; Invalid views cannot be reused from scrap, they should rebound from&quot;
                        + &quot; recycler pool.&quot; + exceptionLabel());
            }
            // 给 ViewHolder 绑定 Recycler
            holder.setScrapContainer(this, false);
            mAttachedScrap.add(holder);
        } 
        // 不满足上述任意一个条件时，将 View 缓存到 mChangedScrap 中
        else {
            if (mChangedScrap == null) {
                mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
            }
            holder.setScrapContainer(this, true);
            mChangedScrap.add(holder);
        }
    }
</code></pre>
<p>该方法通过判断 ViewHolder 的 flag 以及是否设置 ItemAnimator 等，决定将 View 缓存到 mAttachedScrap 还是 mChangedScrap。</p>
<p>那么该方法在何时调用呢？有两种情况：</p>
<ul>
<li>以 LinearLayoutManager 为例，在它的 onLayoutChildren 方法中，会调用<code>detachAndScrapAttachedViews(recycler);</code>该方法定义在 RecyclerView 的 LayoutManager 中，它继续调用 scrapOrRecycleView 方法，如果在该方法符合条件就调用 Recycler 的 scrapView 方法。</li>
<li>通过 mHiddenViews 获取到缓存时，也会调用 scrapView 方法。</li>
</ul>
<h2><a id="%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>场景分析</h2>
<p>根据一些场景来分析下 Recycler 是如何进行回收和复用的。</p>
<h3><a id="%E7%AC%AC%E4%B8%80%E6%AC%A1layout" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一次 layout</h3>
<p>由于这里不是专门分析 layout 过程的，就不从 onLayout 开始说了，中间的过程省略掉，它最终会调用到 LayoutManager 的 onLayoutChildren。</p>
<h4><a id="linearlayoutmanager-onlayoutchildren" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LinearLayoutManager#onLayoutChildren</h4>
<pre class="line-numbers"><code class="language-java">@Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // ...
        // 找到锚点（具体过程等到分析 layout 时再说）
        // （1）
        detachAndScrapAttachedViews(recycler);
        
        if (mAnchorInfo.mLayoutFromEnd) {
            // ...
        } else {
            // （2）
            fill(recycler, mLayoutState, state, false);
            // ...
        }   
        // ...
    }
</code></pre>
<p>首先看（1）处，detachAndScrapAttachedViews 方法会根据情况将子 View 回收到相应缓存，具体过程之后再看，由于现在是第一次 layout，RecyclerView 中没有子 View，所以现在该方法没啥用。</p>
<p>接下来看（2）处，这里的 fill 方法比较重要，它的作用是填充布局。看一下该方法</p>
<h4><a id="linearlayoutmanager-fill" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LinearLayoutManager#fill</h4>
<pre class="line-numbers"><code class="language-java">    int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {

        // 进行 layout 时 layoutState.mScrollingOffset 的值被设置为
        // LayoutState.SCROLLING_OFFSET_NaN，不会进入此 if 块
        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            // ...
            recycleByLayoutState(recycler, layoutState);
        }
        
        // 需要填充的空间
        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
        // 还有需要填充的空间并且 item 数未满
        while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) {
            // ...
            
            // （1）
            layoutChunk(recycler, state, layoutState, layoutChunkResult);

            // 计算剩余空间

            // 同上，在 layout 时不会进入 if 块中
            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
                // ...
                recycleByLayoutState(recycler, layoutState);
            }
            
            // ...
        }
    }
</code></pre>
<h4><a id="linearlayoutmanager-layoutchunk" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LinearLayoutManager#layoutChunk</h4>
<pre class="line-numbers"><code class="language-java">    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
            LayoutState layoutState, LayoutChunkResult result) {
        // （1）
        View view = layoutState.next(recycler);

        // ...
        
        // 默认情况下，layoutState.mScrapList 等于 null
        if (layoutState.mScrapList == null) {
            if (mShouldReverseLayout == (layoutState.mLayoutDirection
                    == LayoutState.LAYOUT_START)) {
                // （2）
                addView(view);
            } else {
                addView(view, 0);
            }
        } else {
            // ...
        }
    }
</code></pre>
<p>（2）处的 addView 方法就不多说了，该方法将得到的子 View 添加到 RecyclerView 中。主要看（1）处，看看子 View 从何而来</p>
<pre class="line-numbers"><code class="language-java">    View next(RecyclerView.Recycler recycler) {
        // ...
        
        final View view = recycler.getViewForPosition(mCurrentPosition);

        return view;
    }
</code></pre>
<p>这个方法是不是很熟悉呢？没错，它就是之前分析的 Recycler 的 getViewForPosition 方法。</p>
<p>不过由于现在没有任何缓存，所以第一次 layout 的时候是通过 Adapter 的 createViewHolder 来创建子 View的，并且没有添加任何缓存。</p>
<h3><a id="%E6%9B%B4%E6%96%B0%E5%88%97%E8%A1%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更新列表</h3>
<p>更新列表可以使用 Adapter 的一系列 notify 方法，这里分析其中两个方法：notifyDataSetChanged 和 notifyItemChanged(int)。</p>
<h4><a id="adapter-notifydatasetchanged" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adapter#notifyDataSetChanged</h4>
<p>该方法最终调用了 RecyclerViewDataObserver 的 onChanged 方法</p>
<pre class="line-numbers"><code class="language-java">    @Override
    public void onChanged() {
        // ...

        // 该方法主要做了这两件事
        // 1. 给所有 ViewHolder 添加了 FLAG_UPDATE 和 FLAG_INVALID
        // 2. 默认情况下（mHasStableIds 为 false）清空 CacheViews
        processDataSetCompletelyChanged(true);
        
        if (!mAdapterHelper.hasPendingUpdates()) {
            // 进行视图重绘
            requestLayout();
        }
    }
</code></pre>
<p>该方法会进行视图重绘，又来到了 layout 过程，继续以 LinearLayoutManager 为例，从它的 onLayoutChildren 方法看起，由于分析第一次 layout 时已经看过一遍了，这次主要看下不同之处：</p>
<pre class="line-numbers"><code class="language-java">    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // ...
        
        detachAndScrapAttachedViews(recycler);
        
        // ...
    }
</code></pre>
<p>主要区别在于 detachAndScrapAttachedViews 方法，这次它开始起作用了，该方法在 RecyclerView 的 LayoutManager 中定义，看下它的实现：</p>
<h4><a id="layoutmanager-detachandscrapattachedviews" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LayoutManager#detachAndScrapAttachedViews</h4>
<pre class="line-numbers"><code class="language-java">    public void detachAndScrapAttachedViews(@NonNull Recycler recycler) {
        final int childCount = getChildCount();
        for (int i = childCount - 1; i &gt;= 0; i--) {
            final View v = getChildAt(i);
            scrapOrRecycleView(recycler, i, v);
        }
    }
</code></pre>
<p>由于不是第一次 layout，RecyclerView 这时已经有子 View 了，该方法遍历子 View，调用 scrapOrRecycleView 方法：</p>
<pre class="line-numbers"><code class="language-java">    private void scrapOrRecycleView(Recycler recycler, int index, View view) {
        final ViewHolder viewHolder = getChildViewHolderInt(view);
        // 不能回收添加了 FLAG_IGNORE 标记的 ViewHolder
        // 可通过 LayoutManager 的 ignoreView 为相应的 View 添加该标记
        if (viewHolder.shouldIgnore()) {
            return;
        }
        // 这些条件都满足，进入 if 块
        if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
            removeViewAt(index);
            recycler.recycleViewHolderInternal(viewHolder);
        } else {
            // ...
        }
    }
</code></pre>
<p>这里将子 View 移除并通过 Recycler 的 recycleViewHolderInternal 方法进行回收</p>
<h4><a id="recycler-recycleviewholderinternal" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recycler#recycleViewHolderInternal</h4>
<pre class="line-numbers"><code class="language-java">        void recycleViewHolderInternal(ViewHolder holder) {
            // ...
            boolean cached = false;
            boolean recycled = false;

            if (forceRecycle || holder.isRecyclable()) {
                // 由于此时的 ViewHolder 有 FLAG_INVALID 标记，不会进入此 if 块
                if (mViewCacheMax &gt; 0
                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                        | ViewHolder.FLAG_REMOVED
                        | ViewHolder.FLAG_UPDATE
                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
                    //...
                }
                // cached 仍为 false，进入此 if 块
                if (!cached) {
                    // 通过 RecycledViewPool 的 putRecycledView 方法缓存该 ViewHolder
                    addViewHolderToRecycledViewPool(holder, true);
                    recycled = true;
                }
            } 
            
            // ...
        }
</code></pre>
<p>最终被移除的子 View 缓存到了 RecycledViewPool 中。</p>
<p>后面在调用 fill 方法进行布局填充时，就可以从 RecycledViewPool 中拿取缓存的 View。</p>
<h4><a id="adapter-notifyitemchanged" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adapter#notifyItemChanged</h4>
<p>该方法传入一个 int 参数，表示要数据有更新的 item 的 position。</p>
<pre class="line-numbers"><code class="language-java">    public final void notifyItemChanged(int position) {
        mObservable.notifyItemRangeChanged(position, 1);
    }
</code></pre>
<p>最终调用 RecyclerViewDataObserver 的 onItemRangeChanged 方法</p>
<pre class="line-numbers"><code class="language-java">    @Override
    public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {
        // 会在 mAdapterHelper 中创建一个 UpdateOp，将信息保存起来
        if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) {
            // 如果可以进行更新操作，执行该方法
            triggerUpdateProcessor();
        }
    }
</code></pre>
<p>继续看 triggerUpdateProcessor 方法</p>
<pre class="line-numbers"><code class="language-java">    void triggerUpdateProcessor() {
        // 判断条件默认为 false，执行 else 块
        if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) {
            // ...
        } else {
            mAdapterUpdateDuringMeasure = true;
            requestLayout();
        }
    }
</code></pre>
<p>在保存了一些信息后，还是进行视图重绘。来到了 layout 过程后，还是以 LinearLayoutManager 为例，这次先看下布局过程的 step1，也就是 dispatchLayoutStep1 方法</p>
<pre class="line-numbers"><code class="language-java">    private void dispatchLayoutStep1() {
        // ...
        
        processAdapterUpdatesAndSetAnimationFlags();
        
        // ...
    }
</code></pre>
<p>主要看 processAdapterUpdatesAndSetAnimationFlags 方法，从名字也可以看出，它负责更新 adapter 的信息</p>
<pre class="line-numbers"><code class="language-java">    private void processAdapterUpdatesAndSetAnimationFlags() {
        // ...

        if (predictiveItemAnimationsEnabled()) {
            mAdapterHelper.preProcess();
        } else {
            mAdapterHelper.consumeUpdatesInOnePass();
        }

        // ...
    }
</code></pre>
<p>这里借助了 mAdapterHelper，它最终又通过接口回调（回调了 markViewHoldersUpdated 方法）调用了 RecyclerView 的 viewRangeUpdate 方法</p>
<pre class="line-numbers"><code class="language-java">    void viewRangeUpdate(int positionStart, int itemCount, Object payload) {
        // ...

        for (int i = 0; i &lt; childCount; i++) {
            // ...
            
            if (holder.mPosition &gt;= positionStart &amp;&amp; holder.mPosition &lt; positionEnd) {
                // （1）
                holder.addFlags(ViewHolder.FLAG_UPDATE);
                // ...
            }
        }
    }
</code></pre>
<p>该方法就是遍历所有子 View，找到所有发生了改变的子 View，进行相关操作。这里重点看注释（1），为改变的 ViewHolder 添加了 FLAG_UPDATE 标记。先记住这点，在后面会用到。</p>
<p>接下来看 onLayoutChildren 方法，和 notifyDataSetChanged 一样，主要的不同之处也是在于 detachAndScrapAttachedViews 方法，该方法遍历子 View，调用 scrapOrRecycleView 方法，下面看一下该方法</p>
<h4><a id="layoutmanager-scraporrecycleview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LayoutManager#scrapOrRecycleView</h4>
<pre class="line-numbers"><code class="language-java">    private void scrapOrRecycleView(Recycler recycler, int index, View view) {
        final ViewHolder viewHolder = getChildViewHolderInt(view);
        // ...
        
        // 这次 ViewHolder 没有添加 FLAG_INVALID 标记，进入 else 块
        if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
            // ...
        } else {
            detachViewAt(index);
            recycler.scrapView(view);
            mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);
        }
    }
</code></pre>
<p>这里就和 notifyDataSetChanged 时不一样了，由于在视图重绘前没有给 ViewHolder 添加 FLAG_INVALID 标记，这次进入的是 else 块。</p>
<p>首先将 View 从 RecyclerView 中 detach 掉（而不是 remove 掉）。然后在回收时，调用的是 Recycler 的 scrapView 方法。该方法在前面也分析过了，这里再看一次</p>
<pre class="line-numbers"><code class="language-java">    void scrapView(View view) {
        final ViewHolder holder = getChildViewHolderInt(view);
        
        // 满足这几个条件中的一个就可以进入 if 循环
        // 1. ViewHolder 设置了 FLAG_REMOVED 或 FLAG_INVALID 
        // 2. ViewHolder 没有设置 FLAG_UPDATE 
        // 3. 没有设置动画或者动画可以重用该 ViewHolder 
        if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
            // ...
            
            mAttachedScrap.add(holder);
        } 
        // 不满足上述任意一个条件时，将 View 缓存到 mChangedScrap 中
        else {
            if (mChangedScrap == null) {
                mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
            }
            holder.setScrapContainer(this, true);
            mChangedScrap.add(holder);
        }
    }
</code></pre>
<p>重点看判断里面的条件 2，从前面的分析可以得知，对于发生改变的 ViewHolder，给它设置了 FLAG_UPDATE，所以它现在三个条件都不满足，进入 else 块，而对于其他的 ViewHolder，由于没有设置 FLAG_UPDATE，所以满足条件 2，进入 if 循环。</p>
<p>所以通过 notifyItemChanged 方法更新列表时，发生了改变的子 View 将被缓存到 ChangedScrap 中，而没有发生改变的子 View 则缓存到 AttachedScrap 中，之后通过填充布局的时候对于不同 item 就可以从相应的 Scrap 缓存中得到子 View。</p>
<p>另外，Scrap 缓存只作用于布局阶段，在 layout 的 step3 中将会清空 mAttachedScrap 和 mChangedScrap。</p>
<h3><a id="recyclerview%E6%BB%91%E5%8A%A8%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView滑动机制分析</h3>
<p>根据View事件机制可以直接来看onTouchEvent方法。<br />
重点查看move事件。move事件执行了scrollByInternal方法。该方法最后会执行LayoutManager的Scroll方法，以LinearLayoutManager为例，它的ScrollBy方法最终执行到fill方法。也就是上文提到的ItemView填充方法，滑动过程中会不断执行获取对应位置的ViewHolder，然后进行View的展示。从而实现RecyclerView的滑动</p>
<pre class="line-numbers"><code class="language-java">public boolean onTouchEvent(MotionEvent e) {
   ...

   switch (action) {
       case MotionEvent.ACTION_DOWN: {
          ...
       case MotionEventCompat.ACTION_POINTER_DOWN: 
          ...

       case MotionEvent.ACTION_MOVE: { // 触摸时间-move
           ...
           if (mScrollState == SCROLL_STATE_DRAGGING) {
               mLastTouchX = x - mScrollOffset[0];
               mLastTouchY = y - mScrollOffset[1];
                // 执行内部滑动方法
               if (scrollByInternal(
                       canScrollHorizontally ? dx : 0,
                       canScrollVertically ? dy : 0,
                       vtev)) {
                   getParent().requestDisallowInterceptTouchEvent(true);
               }
               ...           }
       } break;

       case MotionEventCompat.ACTION_POINTER_UP: {
           onPointerUp(e);
       } break;

       case MotionEvent.ACTION_UP: { // 触摸事件-up
           // 执行 fling方法 ，主要做一些item和scroller动画等操作
           if (!((xvel != 0 || yvel != 0) &amp;&amp; fling((int) xvel, (int) yvel))) {
               setScrollState(SCROLL_STATE_IDLE);
           }
           resetTouch();
       } break;

       case MotionEvent.ACTION_CANCEL: {
           cancelTouch();
       } break;
   }
   ...
   return true;
}
</code></pre>
<h4><a id="scrollbyinternal" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>scrollByInternal</h4>
<ul>
<li>内部Scroll执行方法，此处会执行LayoutManager的Scroll方法</li>
<li>其它处罚Nested、OnScroll等事件</li>
</ul>
<pre class="line-numbers"><code class="language-java">
boolean scrollByInternal(int x, int y, MotionEvent ev) {
   int unconsumedX = 0, unconsumedY = 0;
   int consumedX = 0, consumedY = 0;

   consumePendingUpdateOperations();
   if (mAdapter != null) {
       eatRequestLayout();
       onEnterLayoutOrScroll();
       TraceCompat.beginSection(TRACE_SCROLL_TAG);
       if (x != 0) {
           consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);
           unconsumedX = x - consumedX;
       }
       if (y != 0) {
            // LinearLayout 竖向布局为例，走LayoutManager滑动放啊放
           consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);
           unconsumedY = y - consumedY;
       }
       TraceCompat.endSection();
       repositionShadowingViews();
       onExitLayoutOrScroll();
       resumeRequestLayout(false);
   }
   if (!mItemDecorations.isEmpty()) {
       invalidate();
   }
    // 分发 NestedScroll事件
   if (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) {
    ...
   }
   if (consumedX != 0 || consumedY != 0) {
       dispatchOnScrolled(consumedX, consumedY); // 分发onScrolled事件
   }
   if (!awakenScrollBars()) {
       invalidate();
   }
   return consumedX != 0 || consumedY != 0;
}
</code></pre>
<h4><a id="linearlayoutmanager%E6%89%A7%E8%A1%8C%E6%BB%91%E5%8A%A8%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LinearLayoutManager执行滑动处理</h4>
<ul>
<li>执行scrollBy方法</li>
<li>scrollBy方法最终走到 fill方法（上面提到的填充子View方法）</li>
<li>该方法则会进行 ItemView的填充。从而完成Recycler滑动时，View的重新创建或者重新绑定一系列过程</li>
<li>平移整个View的child，实现滑动效果</li>
</ul>
<pre class="line-numbers"><code class="language-java">public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,
       RecyclerView.State state) {
   if (mOrientation == HORIZONTAL) {
       return 0;
   }
   return scrollBy(dy, recycler, state);
}


int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {
   ...
   mLayoutState.mRecycle = true;
   ensureLayoutState();
   final int layoutDirection = dy &gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;
   final int absDy = Math.abs(dy);
   // 更新LayoutState，布局方向和偏移值。目的是让LayoutManager知道从开始还是末尾进行回收和填充
   updateLayoutState(layoutDirection, absDy, true, state);
   
   // 执行 LinearLayout的fill 方法
   final int consumed = mLayoutState.mScrollingOffset
           + fill(recycler, mLayoutState, state, false);
   ...
   // 平移整个view的child
   mOrientationHelper.offsetChildren(-scrolled);
   
   return scrolled;
}
</code></pre>
<pre class="line-numbers"><code class="language-java">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {
    ...
    // 执行回收流程
    recycleByLayoutState(recycler, layoutState);
    ...
    // 执行填充流程（参考上面layoutChunk方法）
    layoutChunk(recycler, state, layoutState,layoutChunkResult);
}
</code></pre>
<h3><a id="linearlayoutmanager%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LinearLayoutManager回收流程</h3>
<ul>
<li>根据不同的布局方向进行不同方向的回收。以Start为例介绍</li>
<li>计算位移limit值，根据limit</li>
</ul>
<pre class="line-numbers"><code class="language-java">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {
   // 假设是 初始方向布局，则开始末尾View回收。反之亦然
   if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
       recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);
   } else {
       recycleViewsFromStart(recycler, layoutState.mScrollingOffset);
   }
}

private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) {
   final int limit = dt;
   final int childCount = getChildCount();
   if (mShouldReverseLayout) {
       ...
   } else {
        for (int i = 0; i &lt; childCount; i++) {
           View child = getChildAt(i);
           // 遍历child，当超过限制大小时候，开始回收
           if (mOrientationHelper.getDecoratedEnd(child) &gt; limit
                   || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) {
               recycleChildren(recycler, 0, i); // 执行Children回收流程
               return;
           }
       }        }
}
    
private void recycleChildren(RecyclerView.Recycler recycler, int startIndex, int endIndex) {
   if (endIndex &gt; startIndex) {
       for (int i = endIndex - 1; i &gt;= startIndex; i--) {
           removeAndRecycleViewAt(i, recycler); // 执行RecyclerView的移出和回收方法
       }
   } else {
       for (int i = startIndex; i &gt; endIndex; i--) {
           removeAndRecycleViewAt(i, recycler);
       }
   }
}
</code></pre>
<h4><a id="recyclerview-removeandrecycleviewat" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView.removeAndRecycleViewAt</h4>
<ul>
<li>移出和回收View方法</li>
<li>执行ChildHelper的移出View方法。内部Bucket移出和回掉CallBack进行View移出</li>
<li>执行Recycler回收方法</li>
</ul>
<pre class="line-numbers"><code class="language-java">public void removeAndRecycleViewAt(int index, Recycler recycler) {
  final View view = getChildAt(index); // 获取目标View
  removeViewAt(index); // 执行ChildHelper移出
  recycler.recycleView(view); // 回收View
}

public void removeViewAt(int index) {
  final View child = getChildAt(index); 
  if (child != null) {
      mChildHelper.removeViewAt(index); // 执行ChildHelper移出
  }
}

public void recycleView(View view) {
  ViewHolder holder = getChildViewHolderInt(view); // 获取VH
  // ViewHolder 回收前，需要完全detach、且不是Scrap
  if (holder.isTmpDetached()) {
      removeDetachedView(view, false); 
  }
  if (holder.isScrap()) {
      holder.unScrap();
  } else if (holder.wasReturnedFromScrap()){
      holder.clearReturnedFromScrapFlag();
  }
  recycleViewHolderInternal(holder); // 执行回收
}
</code></pre>
<h4><a id="recyclerview-recycleviewholderinternal" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView.recycleViewHolderInternal</h4>
<ul>
<li>内部缓存VH方法</li>
<li>如果CacheView满了，则移出一个Cache到Pool中</li>
<li>将目标VH缓存到Cache末尾</li>
<li>如果没有Cache成功，则直接缓存到Pool中</li>
</ul>
<pre class="line-numbers"><code class="language-java"> void recycleViewHolderInternal(ViewHolder holder) {  
      if (mViewCacheMax &gt; 0
              &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
              | ViewHolder.FLAG_REMOVED
              | ViewHolder.FLAG_UPDATE
              | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
          // Cache缓存个数超了，则直接回收CacheView到RecyclerPool
          int cachedViewSize = mCachedViews.size();
          if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) {
              recycleCachedViewAt(0);
              cachedViewSize--;
          }

          int targetCacheIndex = cachedViewSize;
          // 将VH缓存到CacheView中
          mCachedViews.add(targetCacheIndex, holder);
          cached = true;
      }
      // 如果未CacheView缓存，则直接缓存RecyclerViewPool中
      if (!cached) {
          addViewHolderToRecycledViewPool(holder, true);
          recycled = true;
      }
      //...
}
</code></pre>
<h3><a id="%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>局部刷新</h3>
<h4><a id="adapter%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E5%AF%B9%E5%A4%96api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adapter数据操作对外API</h4>
<p>RecyclerView.Adapter提供局部数据变化通知方法，然后执行到RecyclerViewDataObserver对应的各种数据操作方法上。</p>
<h4><a id="recyclerviewdataobserver" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerViewDataObserver</h4>
<ul>
<li>通过mAdapterHelper进行数据变化处理操作</li>
<li>然后触发更新处理</li>
<li>下面介绍下 ItemChanged操作</li>
</ul>
<pre class="line-numbers"><code class="language-java">   public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {
       assertNotInLayoutOrScroll(null);
       if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) {
           triggerUpdateProcessor();
       }
   }

   public void onItemRangeInserted(int positionStart, int itemCount) {
       assertNotInLayoutOrScroll(null);
       if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) {
           triggerUpdateProcessor();
       }
   }

   public void onItemRangeRemoved(int positionStart, int itemCount) {
       assertNotInLayoutOrScroll(null);
       if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) {
           triggerUpdateProcessor();
       }
   }
</code></pre>
<h4><a id="adapterhelper-onitemrangechanged" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AdapterHelper.onItemRangeChanged</h4>
<pre class="line-numbers"><code class="language-java">boolean onItemRangeChanged(int positionStart, int itemCount, Object payload) {
   // 添加一个更新操作 ，标志为update、记录pos、item相关信息
   mPendingUpdates.add(obtainUpdateOp(UpdateOp.UPDATE, positionStart, itemCount, payload));
   mExistingUpdateTypes |= UpdateOp.UPDATE;
   // 如果只有一个待处理操作则为true，true则执行后续更新处理。如果是多个，则会忽略，因为在第一次出发后，就会集中处理
   return mPendingUpdates.size() == 1;
}
</code></pre>
<h4><a id="recyclerviewdataobserver-triggerupdateprocessor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerViewDataObserver.triggerUpdateProcessor</h4>
<ul>
<li>当RecyclerView有固定大小，且已经Attached了。则走Runnable更新</li>
<li>否则直接走requestLayout方式更新，即重新走绘制流程 onMeasure、onLayout等</li>
</ul>
<pre class="line-numbers"><code class="language-java">void triggerUpdateProcessor() {
  if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) {
      // RecyclerView有固定大小的时候 会执行mUpdateChildViewsRunnable 来处理更新
      ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);
  } else {
      // 直接走 requestLayout方式来处理
      mAdapterUpdateDuringMeasure = true;
      requestLayout();
  }
}
</code></pre>
<h4><a id="triggerupdateprocessor%E4%B8%8Brequestlayout" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>triggerUpdateProcessor下requestLayout</h4>
<p>requestLayout下 onMeasure -&gt; dispatchLayout -&gt; dispatchLayoutStep2 -&gt; layoutChildren -&gt; fill -&gt; layoutChunk -&gt; next -&gt; tryGetViewHolderForPositionByDeadline<br />
最终对Item进行重新绑定 实现局部刷新逻辑</p>
<pre class="line-numbers"><code class="language-java">ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
                
           if (mState.isPreLayout() &amp;&amp; holder.isBound()) {
                holder.mPreLayoutPosition = position;
            } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
                // 执行数据变化的Holder的重新bind，从而实现局部刷新              
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
            }               
}
</code></pre>
<h4><a id="triggerupdateprocessor%E4%B8%8Bmupdatechildviewsrunnable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>triggerUpdateProcessor下mUpdateChildViewsRunnable</h4>
<p>当RecyclerView有固定大小时，则不需要Measure，直接走dispatchLayout方法进行刷新操作</p>
<pre class="line-numbers"><code class="language-java">final Runnable mUpdateChildViewsRunnable = new Runnable() {
   @Override
   public void run() {
        ...
        // 消费 等待执行的操作 
        consumePendingUpdateOperations();
   }
}

void consumePendingUpdateOperations() {
        
      if (mAdapterHelper.hasAnyUpdateTypes(AdapterHelper.UpdateOp.UPDATE) &amp;&amp; !mAdapterHelper
           .hasAnyUpdateTypes(AdapterHelper.UpdateOp.ADD | AdapterHelper.UpdateOp.REMOVE
                   | AdapterHelper.UpdateOp.MOVE)) {
        // update 情况下 逻辑
       
       eatRequestLayout();
       onEnterLayoutOrScroll();
       // 数据预处理 
       mAdapterHelper.preProcess();
       if (!mLayoutRequestEaten) {
            // 执行 dispatchLayout 进行局部刷新处理
           if (hasUpdatedView()) {
               dispatchLayout();
           } else {
               // no need to layout, clean state
               mAdapterHelper.consumePostponedUpdates();
           }
       }
       ...
   } else if (mAdapterHelper.hasPendingUpdates()) {
       // add、remove等操作，直接执行dispatchLayout
       dispatchLayout();
       TraceCompat.endSection();
   }
}
</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15941201495783.html" 
          title="Previous Post: MySQL学习笔记">&laquo; MySQL学习笔记</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15917531926388.html" 
          title="Next Post: Centos7 Docker配置TLS认证的远程端口的证书生成教程（shell脚本一键生成）">Centos7 Docker配置TLS认证的远程端口的证书生成教程（shell脚本一键生成） &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/17043409056338/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/adolphJane" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:adolphdeveloper@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
