<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15626502775177.html">
                
                  <h1>Android-酷炫的Activity切换动画</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>毫无疑问，动画效果能提高用户体验。我们平时使用最多的动画基本上是属性动画和补间动画了，属性动画很强，基本能定制我们想要的动画，但是你是否知道，API 21（5.0）后系统内置了Activity之间的切换动画，而且非常酷炫，今天我跟大家一起分享一下。我们知道，在两个Activity之间切换，我们一般会写出类似下面的代码：</p>

<pre class="line-numbers"><code class="language-java">Intent intent=new Intent(this,SecondActivity.class);
startActivity(intent);
overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);
</code></pre>

<p>在API 21以后，我们可以使用内置的Activity切换动画啦。但是这样也就意味着只能兼容5.0之后的系统，我们先看一个效果图来压压惊：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799839139489.gif" alt="20171015150799839139489.gif"/><figcaption>20171015150799839139489.gif</figcaption></figure></p>

<p>先看看第一个Activity，退出时用的是Explode效果，第二个Activity进入时用的是Slide效果。这些效果无需我们自己去实现，都是内置的效果，我们所编写的代码几乎为零，接下来我们一一看看内置了哪些效果。</p>

<h2 id="toc_1">使用内置Activity之间切换动画代码步骤</h2>

<p>Activity之间的切换期间，对于某个Activity来说，无非就是“进入”和“退出”两种情景下的动画。而“进入”分为“第一次进入Activity”和“返回当前Activity”这两种情况。另外系统还提供了一种动画，即共享元素，这是让两个Activity中的View有个过渡切换的效果。执行动画的状态如下所示：</p>

<blockquote>
<p><strong>enter</strong>：用于决定第一次打开当前Activity时的动画<br/><br/>
<strong>exit</strong> : 用于决定退出当前Activity时的动画<br/><br/>
<strong>reenter</strong>: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画<br/><br/>
<strong>shared elements</strong>:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果  </p>
</blockquote>

<p>那么应该怎么去使用Activity切换动画呢？我们看看使用步骤：</p>

<ul>
<li>首先在setContentView()之前执行，用于告诉Window页面切换需要使用动画<br/>
<code>getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);</code></li>
<li>接下来就是加载切换动画<br/>
其中R.transition.explode就是要执行的动画，是在res/transition目录下的xml文件，我们使用的是系统内置的Explode效果动画，关于怎么去写explode.xml，我们接下来小节去讲解。<br/>
<code>Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode);</code></li>
<li>告诉Window，当前的Activity在什么情况下使用上面的动画<br/>
上面我们创建好了切换动画，接下来就是要告诉当前窗口，在什么情况下去使用动画效果啦，你可以根据你的需求在不同的切换情景中选择不同的效果:<br/></li>
</ul>

<pre class="line-numbers"><code class="language-java">//退出时使用
getWindow().setExitTransition(explode);
//第一次进入时使用
getWindow().setEnterTransition(explode);
//再次进入时使用
getWindow().setReenterTransition(explode);
</code></pre>

<p>当然了，你也可以不使用代码的方式，直接在你使用的主题<style>标签里添加类似如下代码：</p>

<pre class="line-numbers"><code class="language-markup">&lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/explode&lt;/item&gt;
&lt;item name=&quot;android:windowEnterAnimation&quot;&gt;@transition/explode&lt;/item&gt;
&lt;item name=&quot;android:windowReenterTransition&quot;&gt;@transition/explode&lt;/item&gt;
</code></pre>

<ul>
<li>调用startActivity<br/>
跟我们之前使用的<code>startActivity(Intent intent);</code>不同，这里多了一个参数<code>Bundle</code>，我们是先通过<code>makeSceneTransitionAnimation</code>函数创建一个<code>ActivityOptions</code>对象，再将其转为<code>Bundle</code>对象:<br/>
<code>startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle());</code><br/>
整体使用步骤就是以上这些，是不是很简单？接下来我们去学习如何使用内置动画~</li>
</ul>

<h2 id="toc_2">Explode效果</h2>

<p>Explode即爆炸效果，使用Explode效果很简单，在<code>res/transition</code>目录下新建一个xml文件(如<code>explode.xml</code>)，内容如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot; /&gt;
</code></pre>

<p>其中<code>duration</code>表示Explode动画持续时间，由于是Activity之间的切换，最好不要把动画时间设置过大，一般取200~500毫秒比较合适。<br/>
我们看看效果吧~</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799868975358.gif" alt="20171015150799868975358.gif"/><figcaption>20171015150799868975358.gif</figcaption></figure></p>

<h2 id="toc_3">Slide效果</h2>

<p>即滑动效果，使用Slide跟Explode类似，都是在res/transition目录下新建一个xml文件(如<code>slide.xml</code>)，内容如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;
    android:slideEdge=&quot;end&quot;/&gt;
</code></pre>

<p>其中，slideEdge表示起始滑动的侧边位置，end表示右侧，start表示左侧，top表示顶部，bottom表示底侧，各种效果你可以亲自试试~，一起看看滑动效果吧</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799873587032.gif" alt="20171015150799873587032.gif"/><figcaption>20171015150799873587032.gif</figcaption></figure></p>

<p>GIF 效果看的比较死板，可以下载我的源码实际运行一下~</p>

<p>如果你不希望顶部的状态栏以及底部的导航栏一起执行动画，可以在xml中指定：</p>

<pre class="line-numbers"><code class="language-markup">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot;
    android:slideEdge=&quot;end&quot;&gt;
    &lt;targets&gt;
        &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot; /&gt;
        &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot; /&gt;
    &lt;/targets&gt;
&lt;/slide&gt;
</code></pre>

<h2 id="toc_4">Fade效果</h2>

<p>Fade效果即淡化效果，使用淡化效果依然是很简单，在<code>res/transition</code>目录下新建一个xml文件(如<code>fade.xml</code>)，内容如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot; /&gt;
</code></pre>

<p>Fade效果就是将View逐步淡化，这里不再贴效果啦，想看效果的可以下载我的源码运行看看~</p>

<h2 id="toc_5">Shared Element效果</h2>

<p>即共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果，我们先看看动态图感受一下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799880319943.gif" alt="20171015150799880319943.gif"/><figcaption>20171015150799880319943.gif</figcaption></figure></p>

<p>从动态图中看到，第一个Activity的小绿色方块到第二个Activity大绿色方块有个过渡效果~</p>

<p>接下来我们看看如何实现这个效果：</p>

<p><strong>1.将两个Activity中需要过渡的View加上<code>android:transitionName</code>属性</strong></p>

<p>两个View的<code>android:transitionName</code>属性取值要一致，比如：<br/><br/>
第一个Activity布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;View
        android:id=&quot;@+id/firstSharedView&quot;
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:background=&quot;#00cc00&quot;
        android:onClick=&quot;onClick&quot;
        android:transitionName=&quot;sharedView&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>第二个Activity布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;View
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;300dp&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:background=&quot;#00cc00&quot;
        android:onClick=&quot;onClick&quot;
        android:transitionName=&quot;sharedView&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>两个绿色的View都添加<code>android:transitionName</code>属性，并且取名一致。</p>

<p><strong>2.调用startActivity</strong><br/><br/>
<code>ActivityOptions</code>的<code>makeSceneTransitionAnimation</code>函数第一个参数<code>Activity</code>没啥解释的，第二个参数就是第一个<code>Activity</code>中的<code>View</code>对象，第三个参数就是两个Activity的View的 <code>android:transitionName</code>属性的值。</p>

<p><code>startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, firstSharedView,&quot;sharedView&quot;).toBundle());</code></p>

<p>现在就可以实现这种<code>Shared Element</code>效果啦，但是可能你会想实现同时让两个View有这样的效果，可是<code>makeSceneTransitionAnimation</code>函数却只能让我们设置一个<code>View</code>和一个<code>transitionName</code>属性。如何添加多个呢？接下来我们一起学习让多个View同时有切换效果。</p>

<p>除了需要将两个<code>Activity</code>中需要过渡的<code>View</code>对应取相同的名称外，还需将需要过渡的<code>View</code>和<code>transitionName</code>取值对应的String这两个对象封装到一个Pair对象中：</p>

<pre class="line-numbers"><code class="language-java">Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));
Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView));
</code></pre>

<p>然后调用<code>ActivityOptionsCompat</code>类的<code>makeSceneTransitionAnimation</code>的另一个重载函数<code>makeSceneTransitionAnimation(Activity activity,Pair&lt;View, String&gt;... sharedElements)</code>，第一个参数不解释，后面参数为不定长度的形参，即你可以传递任意多个Pair对象。</p>

<pre class="line-numbers"><code class="language-java"> ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, first, second);
</code></pre>

<p>最后调用startActivity</p>

<pre class="line-numbers"><code class="language-java"> ActivityCompat.startActivity(this,intent, transitionActivityOptions.toBundle());
</code></pre>

<p>说了这么多步骤，我们来看看效果吧~</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799903533027.gif" alt="20171015150799903533027.gif"/><figcaption>20171015150799903533027.gif</figcaption></figure></p>

<h3 id="toc_6">1 自定义 Shared Element切换动画</h3>

<p>如果你对内置的 Shared Element还不够满意，你还可以定制View的过渡切换效果。步骤如下：</p>

<h4 id="toc_7">创建一个View的过渡移动的轨迹路径PathMotion类</h4>

<p>我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看<a href="https://developer.android.com/reference/android/transition/ArcMotion.html">【ArcMotion官方文档】</a></p>

<pre class="line-numbers"><code class="language-java">ArcMotion arcMotion = new ArcMotion();
arcMotion.setMinimumHorizontalAngle(50f);
arcMotion.setMinimumVerticalAngle(50f);
</code></pre>

<h4 id="toc_8">定义ChangeBounds类</h4>

<p>我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数：</p>

<blockquote>
<p>1.<code>ViewGroup  sceneRoot</code>：屏幕根View，即DecorView，第二个Activity的DecorView。<br/>
2.<code>TransitionValues  startValues</code>：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数<code>captureStartValues</code>里放置，因此你可以重写<code>captureStartValues</code>函数，并把你自定义的属性动画中的属性放进去。<br/>
3.<code>TransitionValues endValues</code> ：与<code>startValues</code>类似，表示属性动画结束时的属性值。可以通过重写<code>captureEndValues</code>函数，并把你自定义的属性动画里面的最终属性值放进去。</p>
</blockquote>

<p>我们先看一个最简单的示例：</p>

<pre class="line-numbers"><code class="language-java">package com.hc.util;

import android.animation.Animator;
import android.transition.ChangeBounds;
import android.transition.TransitionValues;
import android.view.ViewGroup;
import android.view.animation.AnimationUtils;


public class CustomChangeBounds extends ChangeBounds {

 @Override
  public Animator createAnimator(final ViewGroup sceneRoot,
                                 TransitionValues startValues,
                                 final TransitionValues endValues) {
      Animator changeBounds = super.createAnimator(sceneRoot, startValues, endValues);
      if (startValues == null || endValues == null || changeBounds == null) 
          return null;

      changeBounds.setDuration(300);
      changeBounds.setInterpolator(AnimationUtils.loadInterpolator(sceneRoot.getContext(),
              android.R.interpolator.fast_out_slow_in));
      return changeBounds;
  }
}
</code></pre>

<p>看看效果吧~</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799918618986.gif" alt="20171015150799918618986.gif"/><figcaption>20171015150799918618986.gif</figcaption></figure></p>

<p>最后，再献上<a href="http://download.csdn.net/detail/huachao1001/9550440">源码</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502775529.html">
                
                  <h1>Android-自定义锁屏页</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、为什么需要自定义锁屏页</h2>

<p>　　锁屏作为一种黑白屏时代就存在的手机功能，至今仍发挥着巨大作用，特别是触屏时代的到来，锁屏的功用被发挥到了极致。多少人曾经在无聊的时候每隔几分钟划开锁屏再关上，孜孜不倦，其酸爽程度不亚于捏气泡膜。确实，一款漂亮的锁屏能为手机增色不少，但锁屏存在的核心目的主要是三个：保护自己手机的隐私，防止误操作，在不关闭系统软件的情况下节省电量。<br/>
　　当下，各个款式的手机自带的系统锁屏完全能够满足这些需求，而且美观程度非凡，那么开发者为什么仍然需要构建自定义锁屏呢？让我们试想一个场景，一位正在使用音乐播放器听歌的美女用户，在没有播放器自定义锁屏的情况下，切换一首歌需要几步（参考自同类文章）：</p>

<ol>
<li>点亮手机屏幕</li>
<li>解开系统锁屏</li>
<li>打开音乐播放器</li>
<li>切歌再熄灭屏幕</li>
</ol>

<p>　　这时的她估计已经被广场舞的歌曲骚扰了有10秒，续了10次命，这是我们程序员不愿意看到的，所以有必要依靠我们灵活的双手构建出自定义的音乐锁屏页，将切歌过程被压缩为两步：点亮屏幕和切歌，顺便可以看看歌词。如果再加个开启和关闭自定义锁屏的开关，就能完美解决用户的痛点。</p>

<h2 id="toc_1">二、自定义锁屏页的基本原理</h2>

<p>　　然而，要实现一个自定义锁屏是一件繁琐的事情，因为系统有100种方法让这个非本地的锁屏待不下去。但是，人类的智慧是无限的，程序员需要逆流而上。<br/><br/>
　　Android系统实现自定义锁屏页的思路很简单，即在App启动时开启一个service，在Service中时刻监听系统SCREEN_OFF的广播，当屏幕熄灭时，Service监听到广播，开启一个锁屏页Activity在屏幕最上层显示，该Activity创建的同时会去掉系统锁屏（当然如果有密码是禁不掉的）。示意图如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795013363128.png" alt="20171014150795013363128.png"/><figcaption>20171014150795013363128.png</figcaption></figure></p>

<p>道理很简单，我们这里需要讨论的是细节。</p>

<h3 id="toc_2">广播注册</h3>

<p>　　Service是普通的Service，在应用启动时直接startService，与应用同一个进程即可。此外，SCREEN_OFF广播监听必须是动态注册的，如果在AndroidManifest.xml中静态注册将无法接收到SCREEN_OFF广播，这点在Android官方文档中有明确说明，即需要通过如下代码注册：</p>

<pre class="line-numbers"><code class="language-java">IntentFilter mSereenOffFilter = new IntentFilter();
mScreenOffFilter.addAction(Intent.ACTION_SCREEN_OFF);
registerReceiver(mScreenOffReveiver,mScreenOffFilter);
</code></pre>

<p>　　对应的BroadcastReceiver定义如下：</p>

<pre class="line-numbers"><code class="language-java">private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver(){
    @SuppressWarnings(&quot;deprecation&quot;)
    @Override
    public void onReceive(Context context,Intent intent){
        if(intent.getAction().equals(NOTIFY_SCREEN_OFF)){
            Intent mLockIntent = new Intent(context, LockScreenActivity.class);
            mLockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
            startActivity(mLockIntent);
        }
    }
}
</code></pre>

<p>　　关于启动Activity时Intent的Flag问题，如果不添加FLAG_ACTIVITY_NEW_TASK的标志位，会出现“Calling startActivity() from outside of an Activity”的运行时异常，毕竟我们是从Service启动的Activity。Activity要存在于activity的栈中，而Service在启动activity时必然不存在一个activity的栈，所以要新起一个栈，并装入启动的activity。使用该标志位时，也需要在AndroidManifest中声明taskAffinity，即新task的名称，否则锁屏Activity实质上还是在建立在原来App的task栈中。<br/>
　　标志位FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS，是为了避免在最近使用程序列表出现Service所启动的Activity,但这个标志位不是必须的，其使用依情况而定。</p>

<h3 id="toc_3">Activity设置</h3>

<p>　　锁屏的activity内部也要做相应的配置，让activity在锁屏时也能够显示，同时去掉系统锁屏。当然如果设置了系统锁屏密码，系统锁屏是没有办法去掉的，这里考虑没有设置密码的情况。<br/><br/>
　　典型的去掉系统锁屏页的方法是使用KeyguardManager，具体代码如下：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">KeyguardManager mKeyguardManager = (KeyguardManager)getSystemService(Context.KEYGUARD_SERVICE);
KeyguardManager.KeyguardLock mKeyguardLock = mKeyguardManager.newKeyguardLock(&quot;CustomLockScreen&quot;);
mKeyguardLock.disableKeyguard();
</code></pre>

<p>　　其中，KeyguardManager是锁屏管理类，我们通过getSystemService()的方式获取实例对象mKeyguardManager，调用该对象的newKeyguardLock()方法获取KeyguardManager的内部类KeyguardLock的实例mKeyguardLock，该方法传入的字符串参数用于标识是谁隐藏了系统锁屏，最后调用mKeyguardLock的disableKeyguard()方法可以取消系统锁屏。<br/><br/>
　　上述方法已经不推荐使用，可以使用更好的方法来替代。我们在自定义锁屏Activity的onCreate()方法里设定以下标志位就能完全实现相同的功能：</p>

<pre class="line-numbers"><code class="language-java"> getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
 getWindow().addFlags(WindowManager.LayoutParams.FLAG_OW_WHEN_LOCKED);
</code></pre>

<p>　　FLAG_DISMISS_KEYGUARD用于去掉系统锁屏页，FLAG_SHOW_WHEN_LOCKED使Activity在锁屏时仍然能够显示。当然，不要忘记在Manifest中加入适当的权限：</p>

<pre class="line-numbers"><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot;/&gt;
</code></pre>

<h3 id="toc_4">屏蔽按键</h3>

<p>　　当自定义锁屏页最终出现在手机上时，我们总希望它像系统锁屏页那样屹立不倒，所有的按键都不能触动它，只有通过划瓶或者指纹才能解锁，因此有必要对按键进行一定程度上的屏蔽。针对只有虚拟按键的手机，我们可以通过隐藏虚拟按键的方式部分解决这个问题，具体方法在后文会介绍。但是当用户在锁屏页底部滑动，隐藏后的虚拟按键还是会滑出，而且如果用户是物理按键的话就必须进行屏蔽了。<br/><br/>
　　Back键和Menu键可以通过重写onKeyDown()方法进行屏蔽：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">public boolean onKeyDown(int keyCode, KeyEvent event){
    int key = event.getKeyCode();
    switch(key){
        case KeyEvent.KEYCODE_BACK:{
            return true;
        }
        case KeyEvent.KEYCODE_MENU:{
            return true;
        }
    }
    return super.onKeyDown(keyCode,event);
}
</code></pre>

<p>　　Home键与Recent键（调出最近打开应用的按键）的点击事件是在framework层进行处理的，因此onKeyDown与dispatchKeyEvent都捕获不到点击事件。关于这两个按键的屏蔽方法，网上相关的资料有很多，有的用到了反射，有的通过改变Window的标志位和Type等，总的来说这些方法只对部分android版本有效，有的则完全无法编译通过。其实，这么做的目的无非是为了实现一个纯粹的锁屏页，但是这种做法有些画蛇添足，容易造成锁屏页的异常崩溃，我们要满足的是用户在锁屏页的快捷操作，Home键和Recent键无关痛痒，完全可以不管,少一些套路，多一点真诚嘛。</p>

<h3 id="toc_5">划屏解锁</h3>

<p>　　做完以上几步，当屏幕熄灭后，再打开屏幕就能够看到我们的自定义锁屏页了，但是这时候，就算划破手指也无法解锁。所以，接下来要实现划屏解锁。<br/><br/>
　　划瓶解锁的基本思路很简单，当手指在屏幕上滑动时，拦截并处理滑动事件，使锁屏页面随着手指运动，当运动到达一定的阀值时，用户手指松开手指，锁屏页自动滑动到屏幕边界消失，如果没有达到运动阀值，就会自动滑动到起始位置，重新覆盖屏幕。<br/><br/>
　　为了将划屏逻辑与页面内容隔离开来，我们在锁屏页面布局中添加一个自定义的UnderView，这个UnderView填充整个屏幕，位于锁屏内容View（将其引用称之为mMoveView,并传入到UnderView中）的下方，所有划屏相关的事件都在这里拦截并处理。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795122322931.png" alt="20171014150795122322931.png"/><figcaption>20171014150795122322931.png</figcaption></figure></p>

<p>mMoveView是锁屏页的显示内容，除了处理一些简单的点击事件，其他非点击事件序列都由底层的UnderView进行处理。只需要重写UnderView的onTouchEvent方法就能够实现：</p>

<pre class="line-numbers"><code class="language-java">@Override
public boolean onTouchEvent(MotionEvent event){
    final int action = event.getAction();
    final float nx = event.getX();
    switch(action){
        case MotionEvent.ACTION_DOWN:
            mStartX = nx;
            onAnimationEnd();
        case MotionEvent.ACTION_MOVE:
            handleMoveView(nx);
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_CANCEL:
            doTriggerEvent(nx);
            break;
    }
    return true;
}
</code></pre>

<p>　　其中，mStartX记录滑动操作起始的x坐标，handleMoveView方法控制mMoveView随手指的移动，doTriggerEvent处理手指离开后mMoveView的移动动画。两个方法的定义如下：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">private void handleMoveView(float x){
    float movex = x - mStartX;
    if(movex &lt; 0)
        movex = 0;
    mMoveView.setTranslationX(movex);
    
    float mWidthFloat = (float) mWidth; // 屏幕显示宽度
    if(getBackground() != null){
        getBackground().setAlpha((int) ((mWidthFloat - mMoveView.getTranslationX()) / mWidthFloat * 200));  //初始透明度的值为200
    }
}
</code></pre>

<p>　　在handleMoveView()中，首先计算当前触点x坐标与初始x坐标mStartX的差值movex，然后调用mMoveView的setTranslationX方法移动。值得注意的是，目前setTranslationX方法只能在Android 3.0以上版本使用，如果采用动画兼容库nineoldandroid中ViewHelper类提供的setTranslation方法，则没有这个问题。scrollTo与scrollBy也可以实现移动，但是只是移动View的内容，并不能移动View本身。另外就是通过修改布局参数LayoutParams实现移动，虽然没有版本的限制，用起来相对复杂。这里我们采用setTranslationX，为了简洁，也是为了能够与后续使用的属性动画相统一。<br/><br/>
　　此外，我们可以通过getBackground()获取UnderView的背景，并根据已划开屏幕占整个屏幕的百分比调用setAlpha方法改变背景的透明度，做出抽屉拉开时的光影变化效果。</p>

<pre class="line-numbers"><code class="language-java">private void doTriggerEvent(float x){
    float movex = x - mStartX;
    if(movex &gt; (mWidth * 0.4)){
        moveMoveView(mWidth - mMoveView.getLeft(),true);//自动移动到屏幕右边界之外，并finish掉
    } else {
        moveMoveView(-mMoveView.getLeft(),false);//自动移动回初始位置，重新覆盖
    }
}

private void moveMoveView(float to,boolean exit){
    ObjectAnimator animator = ObjectAnimator.ofFloat(mMoveView, &quot;translationX&quot;,to);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener(){
        @Override
        public void onAnimationUpdate(new ValueAnimator animation){
            if(getBackground() != null){
                getBackground().setAlpha((int)(((float)mWidth - mMoveView.getTranslationX()) / (float) mWidth * 200));
            }
        }
    });//随意动动画背景更新背景透明度
    animator.setDuration(250).start();
    if(exit){
        animator.addListener(new AnimatorListenerAdapter(){
            @Override
            public void onAnimationEnd(Animator animation){
                mainHandler.obtainMessage(LockScreenAcitvity.MSG_LAUNCH_HOME).sendToTarget();
                super.onAnimationEnd(animation);
            }
        });
    }//监听动画结束，利用Handler通知Activity退出
}
</code></pre>

<p>　　当手指离开屏幕，doTraiggerEvent方法会对滑动的距离与阀值进行一个比较，此处的阀值为0.4*屏幕宽度，如果低于阀值，则通过ObjectAnimator在0.25s将mMoveView移动到初始位置，同时在ObjectAnimator的AnimatorUpdateListener的onAnimationUpdate方法中更新背景透明度；如果低于阀值，以同样的方式将mMoveView移出屏幕右边界，然后将Activity干掉，具体做法是为animator增加一个AnimatorListenerAdapter的监听器，在该监听器的onAnimationEnd方法中使用在Activity中定义的mHandler发送finish消息，完成解锁，效果如下图：</p>

<h2 id="toc_6">三、透明栏与沉浸模式</h2>

<p>　　沉浸模式与透明栏是两个不同的概念，由于某些原因，国内一些开发或产品会把这两个概念混淆。不过没关系，在接下来的内容我们会对这两个概念进行详细的解释和区分，并应用这两种不同的模式进一步完善已经初具模样的锁屏页。</p>

<h3 id="toc_7">沉浸模式</h3>

<p>　　什么是沉浸模式？从4.4开始，Android 为 “setSystemUiVisibility()”方法提供了新的标记 “SYSTEM_UI_FLAG_IMMERSIVE”以及”SYSTEM_UI_FLAG_IMMERSIVE_STIKY”，就是我们所谈的沉浸模式，全称为 “Immersive Full-Screen Mode”，它可以使你的app隐藏状态栏和导航栏，实现真正意义上的全屏体验。<br/><br/>
　　之前 Android 也是有全屏模式的，主要通过”setSystemUiVisibility()”添加两个Flag，即”SYSTEM_UI_FLAG_FULLSCREEN”，”SYSTEM_UI_FLAG_HIDE_NAVIGATION”（仅适用于使用导航栏的设备，即虚拟按键）。<br/>
　　这两个标记都存在一些问题，例如使用第一个标记的时候，除非 App 提供暂时退出全屏模式的功能（例如部分电子书软件中点击一次屏幕中央位置），用户是一直都没法看见状态栏的。这样，如果用户想去看看通知中心有什么通知，那就必须点击一次屏幕，显示状态栏，然后才能调出通知中心。<br/><br/>
　　而第二个标记的问题在于，Google 认为导航栏对于用户来说是十分重要的，所以只会短暂隐藏导航栏。一旦用户做其他操作，例如点击一次屏幕，导航栏就会马上被重新调出。这样的设定对于看图软件，视频软件等等没什么大问题，但是对于游戏之类用户需要经常点击屏幕的 App，那就几乎是悲剧了——这也是为什么你在 Android 4.4 之前找不到什么全屏模式会自动隐藏导航栏的应用。<br/><br/>
　　Android 4.4 之后加入的Immersive Full-Screen Mode 允许用户在应用全屏的情况下，通过在原有的状态栏/导航栏区域内做向内滑动的手势来实现短暂调出状态栏和导航栏的操作，且不会影响应用的正常全屏，短暂调出的状态栏和导航栏会呈半透明状态，并且在一段时间内或者用户与应用内元素进行互动的情况下自动隐藏，沉浸模式的四种状态如下图。（<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0616/3047.html">参考</a>）</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795293493925.png" alt="20171014150795293493925.png"/><figcaption>20171014150795293493925.png</figcaption></figure></p>

<p>　　状态1代表没有进入沉浸模式时页面的状态，仍然可以看到Status Bar和Navigation Bar；状态2代表用户第一次进入沉浸模式时，系统的提示弹窗，告诉用户如何在沉浸模式下呼出Status Bar和Navigation Bar；状态3代表沉浸模式，可以看到Status Bar和Navigation Bar都被隐藏；状态4代表用户在Sticky沉浸模式下呼出Status Bar和Navigation Bar，可以看到两个Bar重新出现，但是过一段时间能够自动隐藏。<br/><br/>
　　一般来说，沉浸模式的标记与其他Full Screen相关的Flag搭配起来才能达到我们想要的效果，即通过沉浸模式标记规定状态栏status bar和导航栏navigation bar显示和隐藏的运转逻辑，通过其他标签设定状态栏和导航栏显示或隐藏，以及显示或隐藏的样子。这些常见的Flag及相应功能如下表：<br/><br/>
　　<br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795296598206.png" alt="20171014150795296598206.png"/><figcaption>20171014150795296598206.png</figcaption></figure></p>

<p>　　如此多的标签，看起来非常乱，但用起来却非常简单和明确，感兴趣的开发者可以自由搭配来测试一下。下面，我们通过一个例子，将这些标签应用于锁屏页，实现对Navigation Bar的自动隐藏，同时保留Status Bar。代码非常简单，在Activity的onCreate()方法中使用：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">getWindow().getDecorView().getSystemUiVisibility(
    View.SYSTEM_UI_FLAG_LAYOUT_STABLE
    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
)
</code></pre>

<p>　　总共用到了5个Flag：SYSTEM_UI_FLAG_LAYOUT_STABLE保持整个View稳定，使View不会因为SystemUI的变化而做layout；SYSTEM_UI_FLAG_IMMERSIVE_STIKY，能够在隐藏的bar被呼出时（比如从屏幕下边缘开始向上做滑动手势），使bar在无相关操作的情况下自动再次隐藏；对于SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION，开发者容易被其中的HIDE_NAVIGATION所迷惑，其实这个Flag没有隐藏导航栏的功能，只是控制导航栏浮在屏幕上层，不占据屏幕布局空间；SYSTEM_UI_FLAG_HIDE_NAVIGATION，才是能够隐藏导航栏的Flag；SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN，由上面可知，也不能隐藏状态栏，只是使状态栏浮在屏幕上层。<br/><br/>
　　需要注意的是，这段代码除了需要加在Activity的OnCreate()方法中，也要加在重写的onWindowFocusChanged()方法中，在窗口获取焦点时再将Flag设置一遍，否则可能导致无法达到预想的效果。<br/><br/>
　　</p>

<pre class="line-numbers"><code class="language-java">@Override
public void onWindowFocusChanged(boolean hasFocus){
    super.onWindowFocusChanged(hasFocus);
    if(hasFocus){
        getWindow().getDecorView().setSystemUiVisiblity(
            View.SYSTEM_UI_FLAG_LAYOUT_STABLE
            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
        )
    }
}
</code></pre>

<p>　　此外，有个部份要稍微留意一下，如果不希望界面的内容被上拉到状态栏(Status bar)的话，要记得在界面(Layout)XML文件中，在最外层Layout中将fitsSystemWindows属性设置为true。如下：</p>

<pre class="line-numbers"><code class="language-java">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>　　<br/>
手指在屏幕底端上划，Navigation Bar会弹出，悬浮于锁屏页底部，随后自动消失。Status Bar也按照我们预期的那样，悬浮在上方，没有隐藏。</p>

<h3 id="toc_8">透明栏</h3>

<p>　　什么是透明栏？Google 在 Android 4.4 的 API 描述页面里提到了“Translucent system UI styling”，即半透明化的系统UI风格。这个“半透明化”包括了状态栏和通知栏，当开发者让应用支持这个新特性的时候，状态栏和导航栏可以单独/同时变为渐变的半透明样式，如下图：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079538614391.png" alt="2017101415079538614391.png"/><figcaption>2017101415079538614391.png</figcaption></figure></p>

<p>　　在 Android 5.0 之后引入了 Material Design，状态栏和导航栏也玩出了更多花样。现在除了原有的“半透明”模式以外，还有“全透明”以及“变色”模式，一种会完全隐藏背景，另一种可以取色作为背景颜色，多种样式的透明栏如下图（上图为透明状态栏，下图为透明导航栏）：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171014150795389627420.png" alt="20171014150795389627420.png"/><figcaption>20171014150795389627420.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101415079539225975.png" alt="2017101415079539225975.png"/><figcaption>2017101415079539225975.png</figcaption></figure></p>

<p>　　所以，<strong>透明栏只是能够改变状态栏和导航栏的颜色，并不像沉浸模式那样隐藏状态栏和导航栏，两者是有本质区别的。</strong><br/><br/>
　　对于Android 4.4以上5.0以下的版本，设置透明状态栏的方式如下：</p>

<pre class="line-numbers"><code class="language-java">if(Build.VERSION&gt;SDK_INT &gt;= Build.VERSION_CODES.KITKAT){
    Window window = getWindow();
    window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
}
</code></pre>

<p>　　对于Android 5.0及以上版本，设置透明状态栏的方法如下：</p>

<pre class="line-numbers"><code class="language-java">if(Build.VERSION.SDK_INT &gt;= Build.VERSION.LOLLIPOP){
    Window window = getWindow();
    window.clearFlags(WindowManager.LayoutParams.FLAG_TrANSLUCENT_STATUS);
    window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
    window.addFlags(WindowManager.LayoutParams.Flag_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    window.setStatusBarColor(0);
}
</code></pre>

<p>　　除了要清理掉4.4的FLAG_TRANSLUCENT_STATUS外，还要配合SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE，添加标志位FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，并调用setStatusBarColor设置状态栏的颜色为透明。  </p>

<h2 id="toc_9">四、指纹解锁</h2>

<p>　　到这里，我们的锁屏页已经基本完工，完全能够非常优雅地解决用户的痛点，但是跟当下App自定义锁屏页的区别并不明显。接下来对新型号手机普遍具备的指纹解锁功能的考虑，则能够为锁屏页增色不少。</p>

<h3 id="toc_10">指纹识别无法解锁自定义锁屏页的问题</h3>

<p>　　持有指纹解锁手机的用户在使用App自定义锁屏页时会出现一种困惑，当你点亮屏幕，能够看到自定义锁屏页，在使用指纹解锁成功之后（部分机型指纹解锁操作只能在系统锁屏页进行），自定义锁屏页依然存在，你还是需要划开自定义锁屏页，才能看到手机主界面。<br/><br/>
　　解决这一问题的方案是一种取巧的方法，那就是在锁屏页的service中监听ACTION_USER_PRESENT广播。ACTION_USER_PRESENT广播是系统锁屏解锁广播，当系统锁屏页解锁时就会触发。如果在接收到这一广播时，将自定义锁屏页finish掉，就能避免在指纹解锁成功后自定义锁屏页仍然显示的问题。但是细心的读者会发现这种解法在逻辑上还存在问题，因为在用户没有设置锁屏密码的情况下，前文自定义锁屏页在onCreate()时设置的FLAG_DISMISS_KEYGUARD标志位能够轻易解锁系统的锁屏页，并触发ACTION_USER_PRESENT广播，此时自定义锁屏页的Service接收到这一广播后，发finish广播给自定义锁屏页，导致自定义锁屏页刚create就finish掉了，永远不可能出现。<br/><br/>
　　因此，我们必须对场景进行区分，只在有锁屏密码的情况下，才对接收到的ACTION_USER_PRESENT广播进行处理，finish自定义锁屏页。即在BroadcastReceiver的onReceive()方法中加入如下代码:</p>

<pre class="line-numbers"><code class="language-java">if(intent.getAction().equals(Intent.ACTION_USER_PRESENT)){
    if(VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN){
        if(km.isKeyguardSecure()){
            MLog.d(TAG,&quot;KeyguardSecure!&quot;);
            Intent i = new Intent(NOTIFY_USER_PRESENT);
            context.sendBroadcast(i);
        }
    }
}
</code></pre>

<p>　　这里KeyguardManager对象km的isKeyguardSecure()方法就是用来判断是否设置了锁屏密码。NOTIFY_USER_PRESENT是自定义广播，用来通知锁屏页Activity调用finish方法。<br/><br/>
　　这种做法是合理的，因为如果没有设置锁屏密码，FLAG_DISMISS_KEYGUARD标志位解锁系统锁屏之后，到达上述代码块，isKeyguardSecure()返回为false，不会导致自定义锁屏页Activity的finish操作。而如果设置了锁屏密码，FLAG_DISMISS_KEYGUARD必然无法解锁系统锁屏，到达不了上述代码块，也不会finish。这样就避免了自定义锁屏页刚创建出来就将自己finish掉的困境。另一方面，其他非FLAG_DISMISS_KEYGUARD方式触发的解锁，比如指纹解锁，都会使Activity消失，满足了需求。</p>

<h3 id="toc_11">自定义锁屏页下指纹识别无法使用的问题</h3>

<p>　　此外，有些手机型号，比如小米，在自定义锁屏页罩在系统锁屏页之上时（设置有锁屏密码），指纹解锁是无效的，也就是必须要划开自定义锁屏页，在系统锁屏页上才能进行指纹解锁。为了改善这种体验，我们可以在Activity中引入指纹解锁API，识别指纹并解锁，具体代码如下：</p>

<pre class="line-numbers"><code class="language-java">private void startFingerPrintListening(){
    if(!isFingerprintAuthAvailable()){
        return;
    } else {
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){
            if (checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED) {
                mFingerprintManager.authenticate(null,mCancellationSignal,0,new FingerprintManager.AuthenticationCallback(){
                    @Override
                    public void onAuthenticationError(int errorCode,CharSequence errString){
                        super.onAuthenticationError(errorCode,errString);
                    }
                    @Override
                    public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result){
                        super.onAuthenticationSucceeded(result);
                        finish();
                    }
                    
                    @Override
                    public void onAuthenticationFailed(){
                        super.onAuthenticationFailed();
                    }
                },null);
                return;
            }
        }
    }
}
</code></pre>

<pre class="line-numbers"><code class="language-java">public boolean isFingerprintAuthAvailable(){
    if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M){
        mKeyguardManager = (KeyguardManager) getSystemService(Activity.KEYGUARD_SERVICE);
        if(!mKeyguardManager.isKeyguardSecure()){
            return false;
        }
        if(checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED){
            mFingerprintManager = (FingerprintManager)getSystemService(Activity.FINGERPRINT_SERVICE);
            mCancellationSignal = new CancellationSignal();
            
            return mFingerprintManager.isHardwareDetected() &amp;&amp; mFingerprintManager.hasEnrolledFingerprints();
        } else {
         return false;
        }
    } else {
        return false;
    }
}
</code></pre>

<p>　　当然，不要忘记在Manifest中加入适当的权限：<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.USEFINGERPRINT&quot;/&gt;
</code></pre>

<p>　　在调用指纹识别功能之前，我们需要判断指纹识别功能是否可用，以及APP是否有相应的权限。这一过程体现在isFingerprintAuthAvailable()中，第一步是获取KeyguardManager对象，调用isKeyguardSecure()判断是否设置有锁屏密码，如果有，则需进一步判断。checkSelfPermission用来判断APP是否有指纹识别的权限(SDK 23要求)，如果有则获取FingerprintManager对象，调用该对象的isHardwareDetected()方法判断指纹识别硬件是否可用，调用hasEnrolledFingerprints()判断是否有事先录入好的指纹，只有以上条件都满足，接下来才能调用指纹识别功能。<br/><br/>
　　指纹识别的调用体现在startFingerPrintListening()方法中，主要就是调用FingerprintManager的方法<br/>
　　</p>

<pre class="line-numbers"><code class="language-java">authenticate(FingerprintManager.CryptoObject crypto,CancellationSignal cancel,int flags,FingerprintManager.AuthenticationCallback callback,Handler handler)
</code></pre>

<p>　　其中，crypto参数代表Android6.0中crypto objects的wrapper class，可以通过该对象使authenticate过程更加安全，也可以不使用，这里我们将其设为null；cancel用来取消anthenticate(),我们new出一个对象传入就可以；flags是标志位，设置为0；callback为指纹识别回调，包含指纹识别的核心方法：onAuthenticationError()是指纹匹配连续失败后的回调（几十秒后才能继续匹配），onAuthenticationSucceeded()是指纹匹配成功的回调，onAuthenticationFailed()是指纹匹配失败时的回调。我们在这几个方法中做相应的处理即可，在onAuthenticationSucceeded()方法中调用finish()，就能够在指纹识别成功后关闭Activity。</p>

<h2 id="toc_12">五、总结</h2>

<p>　　通过以上内容的分享，本鹅希望能够对大家的开发有所帮助，如果内容有问题，也希望大家指点。综上所述，在Android上实现自定义锁屏页并不是一件复杂的事情，关键是对一些技术点的把握要比较清楚。Service中启动Activity的正确方法，广播静态注册与动态注册的差别，touch事件的分发传播机制，透明栏与沉浸模式的综合运用，以及指纹识别新技术的应用，都有很多值得推敲的地方。笔者当初实现自定义锁屏页时，没有太多思考，有时照搬前人的做法，有时各种flag随便添加，有时新旧API混淆，虽然实现了需求，但是代码不够简洁，可读性也差。因此，在今后的开发过程中，除了要快速实现需求，还要在随后的维护中，多多思考和研究，使代码能够达到“少一行不行，多一行难受”的境界。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15713923056028.html">
                
                  <h1>学习ConstraintLayout</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">ConstraintLayout简介</h2>

<p>ConstraintLayout作为一款可以灵活调整view位置和大小的Viewgroup被Google疯狂推荐，以前创建布局，默认根元素都是LinearLayout,现在是ConstraintLayout了。ConstraintLayout能够以支持库的形式最小支持到API 9，同时也在不断的丰富ConstraintLayout的API和功能。ConstraintLayout在复杂布局中能够有效的，降低布局的层级，提高性能，使用更加灵活。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15713923056028.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15705014806732.html">
                
                  <h1>Android性能优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Profile GPU Rendering</h2>

<p>这是手机开发的一个辅助工具。</p>

<p>功能特点：</p>

<ul>
<li>它是一个图形检测工具，能实时反应当前绘制的耗时。</li>
<li>横轴表示时间，纵轴表示每一帧的耗时。</li>
<li>随着时间推移，从左到右的刷新呈现。</li>
<li>提供了一个标准的耗时，如果高于标准耗时，表示当前这一帧丢失。</li>
</ul>

<p>打开Profile GPU Rendering后可以看到实时刷新的彩色图，每一根竖线表示一帧，由多个颜色组成。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15705014806732.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15662718181666.html">
                
                  <h1>Android GRPC接入</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">安装Protobuf插件</h2>

<p>Protobuf Support插件可以支持Protobuf文件高亮语法显示</p>

<p><figure><img src="media/15662718181666/15662727464652.png" alt="" style="width:582px;"/></figure></p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15662718181666.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/08/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15620327900428.html">
                
                  <h1>Xposed开发</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Xposed原理</h2>

<p>Xposed的底层原理是通过替换/system/bin/app_precesss 程序控制zygote进程，使得它在系统启动的过程中会加载Xposed framework的一个jar文件即XposedBridge.jar，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持，并且能够允许开发者独立的替代任何class。</p>

<h2 id="toc_1">安装Xposed框架</h2>

<p>可以选择使用太极阴或者VirtualXposed软件，来支持Xposed框架运行，相对比较省力，无需重启或者root。如果爱折腾，可以考虑使用太极阳或者EdXposed，获取更多权限。</p>

<blockquote>
<p>注意VirtualXposed软件0.18.2版本之后不支持32位应用。</p>
</blockquote>

<h2 id="toc_2">编写Hook应用</h2>

<p>新建一个<code>Android</code>工程<code>XposedDemo</code></p>

<h3 id="toc_3">引入Xposed Api</h3>

<p>在<code>app build.gradle</code>文件中<br/>
添加<code>de.robv.android.xposed:api:82</code>和<code>de.robv.android.xposed:api:82:source</code>依赖</p>

<pre class="line-numbers"><code class="language-text">compileOnly &#39;de.robv.android.xposed:api:82&#39;
compileOnly &#39;de.robv.android.xposed:api:82:sources&#39;
</code></pre>

<h3 id="toc_4">在AndroidManifest.xml文件配置xposed信息</h3>

<pre class="line-numbers"><code class="language-text">&lt;!-- 标记xposed插件 start--&gt;
&lt;meta-data
    android:name=&quot;xposedmodule&quot;
    android:value=&quot;true&quot;/&gt;
&lt;!-- 模块描述 --&gt;
&lt;meta-data
    android:name=&quot;xposeddescription&quot;
    android:value=&quot;测试Xposed&quot;/&gt;
&lt;!-- 最低版本号 --&gt;
&lt;meta-data
    android:name=&quot;xposedminversion&quot;
    android:value=&quot;54&quot;/&gt;
&lt;!-- 标记xposed插件 end--&gt;
</code></pre>

<h3 id="toc_5">创建hook类，实现IXposedHookLoadPackage接口</h3>

<pre class="line-numbers"><code class="language-text">public class HelloHook implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
        XposedBridge.log(&quot;===包名===&quot; + lpparam.packageName);
       

        if (lpparam.packageName.equals(&quot;com.zhuliyi.xposedapplication&quot;)) {
            //混淆后方法名也变化了
            XposedHelpers.findAndHookMethod(&quot;com.zhuliyi.xposedapplication.MainActivity&quot;, lpparam.classLoader, &quot;verifyLogin&quot;, String.class, String.class, new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                }

                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                    super.afterHookedMethod(param);
                    param.setResult(true);
                }
            });
        }
    }
}
</code></pre>

<p>handleLoadPackage方法回调是在目标应用加载时候调用，先通过LoadPackageParam参与判断目标应用的包名，然后通过XposedHelpers.findAndHookMethod() hook调用的方法，第一个参数是包名，第二个是classLoader,第三个是方法名，后面是方法参数，最后是XC_MethodHook回调，beforeHookedMethod是方法执行前调用 ，afterHookedMethod是方法执行后调用，通过param.setResult(true)，设置返回值为true,当然也可以通过进行其他操作，这里就不介绍了</p>

<h3 id="toc_6">添加hook文件配置</h3>

<p>我们需要在assets目录下面新建一个xposed_init文件，写上我们Hook文件的路径。</p>

<p><figure><img src="media/15620327900428/16109471541886.jpg" alt=""/></figure></p>

<p>接着 编译，运行，安装apk，最后在Xposed软件模块中添加XposedDemo框架，然后重启设置。</p>

<p><a href="https://www.taichi-app.com/#/index">太极官网</a></p>

<p><a href="https://github.com/android-hacker/VirtualXposed">VirtualXposed GitHub首页</a></p>

<p><a href="http://dl-xda.xposed.info/framework/sdk21/x86/">Xposed SDK下载</a></p>

<p><a href="https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html">Xposed API</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/07/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15620314685082.html">
                
                  <h1>Genymotion-ARM-Translation.zip各安卓版本合集</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<table>
<thead>
<tr>
<th style="text-align: left">安卓版本</th>
<th style="text-align: left">代号</th>
<th style="text-align: left">Genymotion-ARM-Translation</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">8.0 – 8.1</td>
<td style="text-align: left">Oreo奥利奥</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Oreo8.0-8.1/ARM_Translation_Oreo.zip">ARM_Translation_Oreo.zip</a></td>
</tr>
<tr>
<td style="text-align: left">7.0 – 7.1.2</td>
<td style="text-align: left">Nougat牛轧糖</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">6.0 – 6.0.1</td>
<td style="text-align: left">Marshmallow棉花糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Marshmallow6.0-6.0.1/ARM_Translation_Marshmallow.zip">ARM_Translation_Marshmallow.zip</a></td>
</tr>
<tr>
<td style="text-align: left">5.0 – 5.1.1</td>
<td style="text-align: left">Lollipop棒棒糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Lollipop5.0-5.1.1/ARM_Translation_Lollipop_20160402.zip">ARM_Translation_Lollipop_20160402.zip</a></td>
</tr>
<tr>
<td style="text-align: left">5.0 – 5.1.1</td>
<td style="text-align: left">Lollipop棒棒糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Lollipop5.0-5.1.1/ARM_Translation_Lollipop.zip">ARM_Translation_Lollipop.zip</a></td>
</tr>
<tr>
<td style="text-align: left">4.4 – 4.4.4</td>
<td style="text-align: left">KitKat奇巧巧克力</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/KitKat4.4-4.4.4/ARM-4.4-libhoudini.zip">ARM-4.4-libhoudini.zip</a></td>
</tr>
<tr>
<td style="text-align: left">4.1 – 4.3.1</td>
<td style="text-align: left">Jelly Bean果冻豆</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/JellyBean4.1-4.3.1/Genymotion-ARM-Translation_v1.1.zip">Genymotion-ARM-Translation_v1.1.zip</a></td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/07/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15597152983017.html">
                
                  <h1>Android 开发小记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">应用签名查看</h2>

<h3 id="toc_1">查询keystore的MD5</h3>

<pre class="line-numbers"><code class="language-text">keytool -list -v -keystore ***.jks
</code></pre>

<p><figure><img src="media/15597152983017/15597154233468.jpg" alt="" style="width:570px;"/></figure><br/>
MD5值就是所要的应用签名，只是比下面提到的签名生成工具生成的多出了中间的冒号</p>

<h3 id="toc_2">通过APK工具进行查看</h3>

<p><a href="media/15597152983017/GenSignature.apk">GenSignature</a><br/>
在该手机上安装正式打包的APK并运行，通过签名生成工具输入包名get signature获取应用签名，copy to clipboard即可。<br/>
<figure><img src="media/15597152983017/15597160146245.jpg" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/06/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207873148.html">
                
                  <h1>Android RecyclerView性能优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>近期由于项目中使用RecyclerView加载的数据数量较大，所以必须对RecyclerView进行优化。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15561207873148.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2018/06/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207873102.html">
                
                  <h1>Android 基础复习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">AndroidManifest</h2>

<ul>
<li>uses-sdk 这个节点用于定义要想正确地运行应用程序，设备上必须具有的最低和最高SDK版本。</li>
<li>uses-configuration 指定应用程序支持的每个输入机制的组合。一般不需要，适合有特殊输入控制的游戏。</li>
</ul>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15561207873102.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2018/05/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_3.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_5.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16155265432695.html">混入（mixin）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16145671673295.html">多态</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
