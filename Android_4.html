<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207871631.html">
                
                  <h1>Android 使用 Palette 让你的 UI 色彩与内容更贴合</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>今天介绍一个 Android 下比较有意思的 Support v7 库，Palette，它翻译过来就是调色板。</p>

<p>Palette 可以从一张 Bitmap 中提取出它突出的颜色，这样我们就可以将提取出来的颜色设置在 App 的固定 UI 中（例如：ToolBar 的背景），使得 UI 页面的整体风格更加的美观和融洽。</p>

<p>比如，对于一些影视类的 App，视频详情页的主题都是视频的海报，那么对于页面背景，我们可以提取视频海报的颜色，设置在背景上，使得效果更佳柔和美观。</p>

<p>Palette 是一个 Support v7 的包，如果使用 Gradle 引入依赖，这里使用最新的 26.+。</p>

<p><code>compile &quot;com.android.support:palette-v7:26.+&quot;</code></p>

<h2 id="toc_1">Palette 的使用</h2>

<p>Palette 使用起来非常的简单，既然目的是从一个图片中提取颜色，它的步骤就有：</p>

<ol>
<li>传递一个 Bitmap，得到一个 Palette。</li>
<li>通过 Palette 提取需要的颜色。</li>
</ol>

<p>就是这么简单，如同要将大象放冰箱，需要几步一样清晰。</p>

<p>那么接下来我们先来了解它使用的细节。</p>

<h3 id="toc_2">传递 Bitmap 得到一个 Palette</h3>

<p>Palette 在旧版本上有一些 <code>generate()</code> 的方法，用于生成一个 <code>Palette</code> 对象，但是在新版本上已经被标记为 <code>@Depercated</code> 了，所以这里不推荐使用。</p>

<p>而在新版上，推荐使用 <code>Palette.Builder</code> 来创建我们的 <code>Palette</code> 对象，我们可以通过 <code>from()</code> 方法使用它。</p>

<p><figure><img src="media/15561207871631/15713329037910.jpg" alt=""/></figure></p>

<p>一般我们使用第一个方法即可，直接传递进去一个 Bitmap 对象。得到 Builder 之后，我们还可以配置一些规则，但是一般我们不需要进行额外的（后面会讲到）。再通过 <code>Builder.generate()</code> 即可得到我们需要的 Palette 对象了。</p>

<h3 id="toc_3">通过 Palette 提取颜色</h3>

<p>Palette 从图片中提取的颜色，有很多选择。这里又涉及到另外一个类，Swatch 。</p>

<p>Palette 可被提取的每个颜色，都被封装成一个 Swatch 对象，用来管理多种颜色。</p>

<p>这些 Swatch 有：</p>

<ul>
<li>DominantSwatch</li>
<li>VibrantSwatch</li>
<li>DarkVibrantSwatch</li>
<li>LightVibrantSwatch</li>
<li>MutedSwatch</li>
<li>DarkMutedSwatch</li>
<li>LightMutedSwatch</li>
</ul>

<p>其实这些 Swatch，真的不太好解释其意义，唯一特别一点的就是 DominantSwatch ，它是从图片中提取的最突出的颜色。</p>

<p>这些 Swatch 在 Palette 都提供了对应的 <code>getXxx()</code> 方法获得。不过需要注意的是，这些 <code>getXxx()</code> 方法可能会得到一个 <code>null</code> ，因为有些颜色是没有的。</p>

<p>如果只是需要得到一个颜色值，Palette 同时也提供了对应的 <code>getXxxColor()</code> 方法，方便我们使用。</p>

<p>得到 Swatch 对象之后，就可以通过对应的 Swatch 中对应的 Api 获取我们需要的颜色值。</p>

<ul>
<li><code>getPopulation()</code> ：Swatch 中的像素个数。</li>
<li><code>getRgb()</code>：颜色的 RGB 值。</li>
<li><code>getHsl()</code>：颜色的 HSL 值。</li>
<li><code>getBodyTextColor()</code>：对应的文字颜色值。</li>
<li><code>getTitleTextColor()</code>：对应的标题文字颜色值。</li>
</ul>

<p>通常来说，我们只需要通过 getRgb() 获取到对应的颜色设置在背景上，如果背景之上还有文字内容，可以通过 getBodyTextColor() 提取出与背景匹配的文字颜色值，这样可以显得更加的柔和，让文字看起来更清晰和舒服。比如，如果一个深色的背景，为它设置一个默认的深色文字，基本上就看不见了，因为对比对太弱。</p>

<h3 id="toc_4">举个例子</h3>

<p>到这里，基本上 Palette 的基本 Api 就讲解清楚了，下面举个实际的例子来看看。</p>

<p>这里找了三张 Eason 的海报，用于做 Palette 的 Demo 资源，间隔去替换图片，然后分别提取出对应的颜色和字体颜色，设置在下面按钮的背景上，然后每 3s 切换一张图片。</p>

<p>因为有一些图片，获取的 Swatch 可能会返回 null ，所以这里用了一个比价扎眼的红色，作为错误色。</p>

<p>以下是获取 Swatch 的代码。</p>

<p><figure><img src="media/15561207871631/15713329191405.jpg" alt=""/></figure></p>

<p>接下来通过 Swatch 提取我们需要的颜色。</p>

<p><figure><img src="media/15561207871631/15713329292415.jpg" alt=""/></figure></p>

<p>这里分别获取了需要的颜色以及字体颜色，下面看看运行的效果：</p>

<p><figure><img src="media/15561207871631/20171104150979178525822.gif" alt=""/></figure></p>

<p>可以看到，确实有一些颜色，被标记成了红色，说明当前图片有获取不到的对应颜色。</p>

<h2 id="toc_5">分析 Palette 的实现</h2>

<h3 id="toc_6">Palette 的主线逻辑</h3>

<p>继续深入看看 Palette 的实现原理，先从主线开始看。</p>

<p>从 <code>Builder.generate()</code> 开始。</p>

<p><figure><img src="media/15561207871631/15713329682785.jpg" alt=""/></figure></p>

<p>从代码中可以看到，在 <code>generate()</code> 中，主线逻辑：</p>

<ol>
<li>首先会通过 <code>scaleBitmapDown()</code> 方法，将图片压缩成一个小像素的，等于生成了一个新的 <code>Bitmap</code> 对象，这样有利于内存的管理，并且也减少了计算量。</li>
<li>然后再通过 <code>mRegion</code> 判断是否只是提取图片的某个区域，默认是完整的图片全部提取，当然也可以对 <code>mRegion</code> 进行配置。<br/>
之后再构造一个 <code>ColorCutQuantizer</code> 对象，使用它的 <code>getQuantizedColors()</code> 方法得到 Swatch。</li>
<li>使用完前面压缩的 <code>Bitmap</code> 对象之后，再使用 <code>recycle()</code> 将其回收掉。</li>
<li>最后，通过 <code>Palette</code> 本身的构造函数，去生成一个 <code>Palette</code> 对象，返回出去。</li>
</ol>

<p>接下来看看比较关键的 <code>ColorCutQuantizer</code> 中的实现逻辑。</p>

<p><figure><img src="media/15561207871631/15713329786480.jpg" alt=""/></figure></p>

<p>从代码中可以看到，其中的逻辑还是很清晰的。</p>

<ol>
<li>首先通过 <code>quantizeFromRgb888()</code> 方法，将每个像素的颜色进行量化，类似于将每个颜色取一个靠近的设置。举个不恰当的例子，将不同深度的红，都标记成红色。</li>
<li>再通过 <code>shouldIgnoreColor()</code> 过滤掉不需要的颜色。</li>
<li>最终获取到的颜色，如果小于等于我们设置的 <code>maxColors</code>，就可以通过 <code>approximateToRgb888()</code> 生成一批 Swatch。</li>
<li>如果大于 <code>maxColors</code>，就再通过 <code>quantizePixels()</code> 去掉一些杂色。</li>
<li>无论如何，最终操作的就是这里得到的 <code>mQuantizedColors</code> 对象。</li>
</ol>

<h3 id="toc_7">Swatch 的 Target</h3>

<p>所有需要的 Swatch ，都是被 Target 对象所标记。不同的 Swatch 都是通过 Target 中标记的常量值，进行运算，得到行的颜色。</p>

<p><figure><img src="media/15561207871631/15713329905077.jpg" alt=""/></figure></p>

<h3 id="toc_8">过滤掉不需要的颜色</h3>

<p>Palette 可以设置一些我们不需要的颜色，让它们不参与运算。这里的过滤条件，通过 Filter 来设定，并且 Palette 也提供给了一个 DEFAULT_FALTER 来标记默认的过滤颜色。</p>

<p><figure><img src="media/15561207871631/15713330027457.jpg" alt=""/></figure></p>

<p>可以看到，默认的 Filter 会过滤掉一些靠近黑和白的颜色。</p>

<p>当然，我们也可以自己定义 Filter ，并通过 Palette 中的 <code>addFilter()</code>、<code>clearFilters()</code> 来管理它。</p>

<p><figure><img src="media/15561207871631/15713330123084.jpg" alt=""/></figure></p>

<p>这里存储 Filter 的是一个 ArrayList ，所以我们是可以定义很多个 Filter 加入进去的，它们都会生效。</p>

<h3 id="toc_9">设置 MaxColor</h3>

<p>在 ColorCutQuantizer 中，被使用的 maxColor ，主要用于标记需要使用的颜色个数。它是可以通过 maximumColorCount() 方法，进行设置的，如果不对其进行设定，默认值为 16。</p>

<p><figure><img src="media/15561207871631/15713330244379.jpg" alt=""/></figure></p>

<p>理论上来说，这里设置的maxColor 的值越大，运算花费的时间就越长。而越小，可以被选择的色值也就越少。</p>

<p>所以最佳的做法是根据当前 Bitmap 的用途来决定，色彩越丰富的图，设置的 maxColor 越大，即可。不过正常来说也不需要额外的设定，默认的配置就挺好用了。</p>

<h2 id="toc_10">小结</h2>

<p>到这里就分析完 Palette 的所有相关的内容，不要仅仅满足使用。实际上看了 Palette 的源码，对色彩的运算，也有了更加深入的了解。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/6</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871588.html">
                
                  <h1>Android 自定义 LayoutInflate 实现酷炫引导页</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>今天，我们来搞点事情，自定义一个 LayoutInflate，搞点有意思的东西，实现一个酷炫的动画。<br/><br/>
首先，在自定义 LayoutInflate 之前，我们要先分析一下 LayoutInflate 的源码，了解了源码的实现方式，才能定制嘛~~~~<br/>
好了，怕你们无聊跑了，先放效果图出来镇贴</p>

<p><figure><img src="media/15561207871588/20171104150978927436317.gif" alt=""/></figure></p>

<p>好了，效果看完了，</p>

<p>那就先从LayoutInflate的源码开始吧。</p>

<h2 id="toc_0">LayoutInflate</h2>

<p><figure><img src="media/15561207871588/15713651711430.jpg" alt=""/></figure></p>

<p>还是提取一下关键信息吧。</p>

<ol>
<li><p>LayoutInflate 可以将 xml 文件解析成 View 对象。获取方式有两种getLayoutInflater()和getSystemService(Class)。</p></li>
<li><p>如果要创建一个新的 LayoutInflate去解析你自己的 xml，可以使用 cloneInContext，然后调用 setFactor()。</p></li>
</ol>

<p>好了，我们先来回顾一下平时我们是怎么把 xml 转换成 View 的吧。</p>

<ul>
<li>setContentView（）</li>
</ul>

<p>我们给 Activity 设置 布局 xml 都是调用这个方法，现在我们就来看看这个方法到底干了什么事。</p>

<pre class="line-numbers"><code class="language-java">public void setContentView(@LayoutRes int layoutResID) {
  getWindow().setContentView(layoutResID);
  initWindowDecorActionBar();
}
-----以上是 Activity 的方法，调用了 Window 的 steContentView
----手机上的 window 都是 PhoneWindow,就不饶弯了，直接看 PhoneWindow
----的setContentView方法。
public void setContentView(int layoutResID) {
    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
    // decor, when theme attributes and the like are crystalized. Do not check the feature
    // before this happens.
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                getContext());
        transitionTo(newScene);
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    mContentParent.requestApplyInsets();
    final Callback cb = getCallback();
    if (cb != null &amp;&amp; !isDestroyed()) {
        cb.onContentChanged();
    }
}
----在构造方法里面找到了mLayoutInflater 的赋值
public PhoneWindow(Context context) {
    super(context);
    mLayoutInflater = LayoutInflater.from(context);
}
</code></pre>

<ul>
<li>View.inflate()</li>
</ul>

<p>同样是调用了LayoutInflate.inflate()方法</p>

<pre class="line-numbers"><code class="language-java">public static View inflate(Context context, @LayoutRes int resource, ViewGroup root) {
    LayoutInflater factory = LayoutInflater.from(context);
    return factory.inflate(resource, root);
}
</code></pre>

<ul>
<li>LayoutInflate.from(context).inflate()  同上</li>
</ul>

<p>我们项目中所有的 Xml 转 View 都离不开这三个方法吧，这三个方法最终调用的都还是 LayoutInflate 的 inflate 方法。</p>

<p>我们再来看看怎么获取到 LayoutInflate 的实例。<br/>
上面三个xml 解析成 view 的方法都是用LayoutInflate.from(context)来获取 LayoutInflate 实例的。</p>

<pre class="line-numbers"><code class="language-java">public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
   if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
   }
   return LayoutInflater;
}
</code></pre>

<p>看到这个代码有木有觉得很眼熟啊，我们的 ActivityService、WindowService、NotificationService等等各种 Service 是不是都这样获取的。而我们都知道这些系统服务都是单例的，并且在应用启动的时候系统为其初始化的。好了，撤远了~~</p>

<p>回过头来，我们继续看 LayoutInflate 源码。</p>

<ul>
<li>inflate(@LayoutRes int resource, @Nullable ViewGroup root)<br/>
这个方法就是将xml 文件转换成 View 的方法，我们项目中所有的 xml 解析调用的都是这个方法。第一个参数是 xml 资源 id，第二个方法是解析后的 View 是否要添加到 root view里面去。</li>
</ul>

<p>通过 Resources 获取 xml 解析器XmlResourceParser。</p>

<pre class="line-numbers"><code class="language-java">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;
                + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre>

<p>XmlResourceParser解析 xml，并且返回 view</p>

<pre class="line-numbers"><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        //写入跟踪信息，用于 Debug 相关，先不关心这个
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);

        final Context inflaterContext = mContext;
        //用于读取 xml 节点
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
          // Look for the root node.
          int type;
          //空信息直接跳过
            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
                // Empty
            }
            //防错判断
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;);
            }
            //获取类名，比如说 TextView
          final String name = parser.getName();

          if (DEBUG) {
                System.out.println(&quot;**************************&quot;);
                System.out.println(&quot;Creating root view: &quot; + name);
                System.out.println(&quot;**************************&quot;);
            }
            //如果标签是merge
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                //merge作为顶级节点的时候必须添加的 rootview
                throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;);
                }
                //递归方法去掉不必要的节点，为什么 merge 可以优化布局
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp 是根节点
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;
               //如果不添加到 rootView 切 rootView 不等于空，则生成 LayoutParams
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(&quot;Creating params from root: &quot; + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

             if (DEBUG) {
                    System.out.println(&quot;-----&gt; start inflating children&quot;);
                }

                // 解析子节点
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; done inflating children&quot;);
                }

                // 如果要添加到 rootview。。
                // to root. Do that now.
                if (root != null &amp;&amp; attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
          ex.initCause(e);
          throw ex;
       } catch (Exception e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + &quot;: &quot; + e.getMessage());
            ex.initCause(e);
            throw ex;
       } finally {
            // Don&#39;t retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        //返回解析结果
        return result;
    }
}
</code></pre>

<p>在这个方法中，判断了是否使用 merge 优化布局，然后通过createViewFromTag解析的顶级 xml 节点的 view，并且处理了是否添加解析的布局到 rootView。调用rInflateChildren方法去解析子 View 并且添加到顶级节点 temp 里面。最后返回解析结果。</p>

<p>我们先来看看 createViewFromTag</p>

<pre class="line-numbers"><code class="language-java">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,boolean ignoreThemeAttr) {
    //获取命名空间
   if (name.equals(&quot;view&quot;)) {
        name = attrs.getAttributeValue(null, &quot;class&quot;);
   }
   // 给 view 设置主题。现在知道为什么colorPrimary等 theme 属性会影响控件颜色了吧
   if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
   }
    //让 view 闪烁，可以参考http://blog.csdn.net/qq_22644219/article/details/69367150
    if (name.equals(TAG_1995)) {
        // Let&#39;s party like it&#39;s 1995!
        return new BlinkLayout(context, attrs);
    }

   try {
        View view;
        //优先调用了mFactory2的 oncreateView 方法，创建了 temp View
        if (mFactory2 != null) {
            view = mFactory2.onCreateView(parent, name, context, attrs);
        } else if (mFactory != null) {
            view = mFactory.onCreateView(name, context, attrs);
        } else {
            view = null;
        }

        if (view == null &amp;&amp; mPrivateFactory != null) {
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        }

        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf(&#39;.&#39;)) {
                    view = onCreateView(parent, name, attrs);
                } else {
                    view = createView(name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }

        return view;
    } catch (InflateException e) {
        throw e;

    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + &quot;: Error inflating class &quot; + name);
        ie.initCause(e);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + &quot;: Error inflating class &quot; + name);
        ie.initCause(e);
        throw ie;
    }
}
</code></pre>

<p>这里我们可以知道，mFactor或者 mFactor 不为 null，则调用mFactor来创建 View，如果mFactor为 null 或者mFactor创建是失败，则最终调用LayoutInflate 的createView方法 来创建 View 的，它传入了 view 的 parent、name、context、 attrs。</p>

<p>接下来继续去看子 View 的解析rInflateChildren</p>

<pre class="line-numbers"><code class="language-java">void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {
//获取布局层级
    final int depth = parser.getDepth();
    int type;
    //没看懂没事，我们不是来纠结 xml 解析的
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }

        final String name = parser.getName();
        //requestFocus标签，http://blog.csdn.net/ouyang_peng/article/details/46957281
        if (TAG_REQUEST_FOCUS.equals(name)) {
            parseRequestFocus(parser, parent);
        } else if (TAG_TAG.equals(name)) {
        //tag标签，只能用于 api21以上，给父view 设置一个 tag
            parseViewTag(parser, parent, attrs);
       } else if (TAG_INCLUDE.equals(name)) {
       //include 节点
            if (parser.getDepth() == 0) {
                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
            }
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
        //merge 节点
            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);
        } else {
        //走了刚刚的那个方法，创建 view 设置 LayoutParams
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            rInflateChildren(parser, view, attrs, true);
            //添加到付 view
            viewGroup.addView(view, params);
        }
    }

    if (finishInflate) {
        parent.onFinishInflate();
    }
}
</code></pre>

<p>我们来整理一下思路吧，调用步骤</p>

<ol>
<li>LayoutInflater 的静态方法 form 获取LayoutInflater实力</li>
<li>inflate解析 xml 资源</li>
<li>inflate 调用createViewFromTag创建了顶级view</li>
<li>inflate 调用rInflateChildren 创建所有子 view</li>
<li>rInflateChildren递归调用rInflate创建所有子 view。</li>
<li>rInflate通过调用createViewFromTag真正创建一个 view。</li>
<li>createViewFromTag优先使用 mFactory2、mFactory、mPrivateFactory来创建 View，如果创建失败，则最终调用createView方法来创建。创建的过程中用了parent,name,context,attrs等参数，然后运用反射的方法，创建出 View，</li>
</ol>

<p>因此，我们所有的 View 的构造方法都是被 <code>LayoutInflate</code> 的Factory调用创建出来的。<br/>
如果要自定义 <code>LayoutInflate</code> 解析，只需要给调用<code>LayoutInflate</code>的 <code>setFactory</code>设置我们自定义的 <code>Factory</code> 即可。<br/>
但是问题来了，LayoutInflate是系统服务，而且是单例，我们直接调用LayoutInflate的 setFactory 方法，会影响后期所有 view 的创建。</p>

<p>所以我们需要用到<code>LayoutInflate</code>的<code>cloneInContext</code>方法<code>clone</code>一个新的 <code>LayoutInflate</code>，然后再设置自己的 <code>Factory</code>。至于<code>LayoutInflate</code>是一个抽象类，<code>cloneInContext</code>是一个抽象方法，我们根本不用关心，因为我们直接用系统创建好的<code>LayoutInflate</code>即可。</p>

<p>好了，<code>LayoutInflate</code>的源码分析完了，接下来我们来分析动画了。</p>

<h2 id="toc_1">动画分析</h2>

<p>源码看了很久，我们再来重新看一遍动画吧</p>

<p><figure><img src="media/15561207871588/20171104150979091135893.gif" alt=""/></figure></p>

<ol>
<li>翻页</li>
<li>翻页的时候天上的云，地上的建筑物移动速度和翻页速度不一样</li>
<li>不同的背景物移动速度不一样，最后一页背景物上下扩散</li>
<li>翻页的过程中，人一直在走路</li>
<li>最后一页人要消失。</li>
</ol>

<p>解决方案：</p>

<ol>
<li>ViewPager</li>
<li>给 viewPage设置PageChangeListener，在滚动的时候给各种 背景物体设置setTranslation。</li>
<li>不同的背景物设置不同的setTranslation系数。</li>
<li>人物走路用帧动画即可，在viewPage滑动处于SCROLL_STATE_DRAGGING状态的时候开启帧动画。</li>
<li>这个简单，监听onPageSelected，然后再设置人为 View.GONE即可。</li>
</ol>

<p>解决方案的问题：<br/><br/>
粗略数了一下，6个页面大概有50个左右的背景物。如果要一个一个去获取 id，然后再根据不同的 id，设置不同的滑动速度滑动方向，可能你会疯掉。</p>

<p>因此，我们需要想一个办法，去解决这个问题。可能有的童鞋会说，我写一个自定义 View，设置滑动速度系数属性就行了呀。这个方法可以实现，but，你还是需要一个一个去 <code>findViewbyid</code>。</p>

<p>那么，我们是不是可以给 xml 添加自定义标签，然后自定义解析。比如说，天上的云，滑进来的阻尼系数是0.4，滑出去的阻尼系数是0.6，只需要在 xml 里面设置好这两个参数，然后我们再在合适的时使用这两个参数即可啊。</p>

<h2 id="toc_2">自定义LayoutInflater.Factory</h2>

<p>咦，怎么变成自定义<code>LayoutInflater.Factory</code>了，哈哈哈，还记得刚刚<code>LayoutInflater</code>的源码分析么，View 的创建全部在<code>createViewFromTag</code>里面，而<code>createViewFromTag</code>优先使用 Factory 来 创建。然后我们来看看Factory到底是干嘛的。</p>

<p>Hook you can supply that is called when inflating from a LayoutInflater.<br/>
You can use this to customize the tag names available in your XML layout files.</p>

<ul>
<li>当LayoutInflater在解析布局的时候会被调用</li>
<li>可以用来读取 xml 中的自定义标签。</li>
</ul>

<p>这下迷惑都解开了吧，啊哈哈哈哈~~<br/><br/>
现在，我们就来定义这个 Factory<br/><br/>
思路很简单。  </p>

<ol>
<li>继承LayoutInflater.Factory2</li>
<li>实现抽象方法onCreateView</li>
<li>在onCreateView里面使用 LayoutInflate 的 createView方法创建View</li>
<li>创建成功之后，读取 view 的 attrs 属性，作为 tag 保持到 viewTag。</li>
</ol>

<p>关键代码如下：</p>

<pre class="line-numbers"><code class="language-java">@Override
public View onCreateView(String name, Context context, AttributeSet attrs) {
 //创建一个 View
    View view = createViewOrFailQuietly(name, context, attrs);

    //实例化完成
    if (view != null) {
        //获取自定义属性，通过标签关联到视图上
        setViewTag(view, context, attrs);
        //所有带有自定义属性的 View 保存起来，供动画切换的时候调用
        mParallaxView.getParallaxViews().add(view);
    }
    return view;
}
</code></pre>

<p>创建 view 的方法，这里注意一下，xml 标签里面系统的 view只有类名，自定义 view 是全路径。如：,而可以省略路径的 View 又分为 &quot;android.widget.&quot;和&quot;android.view.&quot;包下，所以对于只写缩写的 view，需要遍历这两个路径。</p>

<pre class="line-numbers"><code class="language-java">private View createViewOrFailQuietly(String name, Context context,
                                     AttributeSet attrs) {
    //1.自定义控件标签名称带点，所以创建时不需要前缀
    if (name.contains(&quot;.&quot;)) {
        createViewOrFailQuietly(name, null, context, attrs);
    }
    //2.系统视图需要加上前缀
    for (String prefix : sClassPrefix) {
        View view = createViewOrFailQuietly(name, prefix, context, attrs);
        if (view != null) {
            return view;
        }
    }
    return null;
}
private View createViewOrFailQuietly(String name, String prefix, Context context,
                                     AttributeSet attrs) {
    try {
        //通过系统的inflater创建视图，读取系统的属性
        return inflater.createView(name, prefix, attrs);
    } catch (Exception e) {
        return null;
    }
}
</code></pre>

<p>读取 attrs 里面的属性，给含有特点 attrs 属性的 view设置 tag 并保存起来。</p>

<pre class="line-numbers"><code class="language-java">private void setViewTag(View view, Context context, AttributeSet attrs) {
    //所有自定义的属性
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AnimationView);
    if (a != null &amp;&amp; a.length() &gt; 0) {
        //获取自定义属性的值
        ParallaxViewTag tag = new ParallaxViewTag();
       tag.xIn = a.getFloat(R.styleable.AnimationView_x_in, 0f);
       tag.xOut = a.getFloat(R.styleable.AnimationView_x_out, 0f);
       tag.yIn = a.getFloat(R.styleable.AnimationView_y_in, 0f);
       tag.yOut = a.getFloat(R.styleable.AnimationView_y_in, 0f);

       //index
       view.setTag(view.getId(), tag);
       a.recycle();
   }
}
</code></pre>

<p>好了，我们自定义LayoutInflater.Factory已经结束了，so，我们可以直接调用 LayoutInflate.cloneInContext(context)获取一个新的 LayoutInflate，然后再setFactor(customFactor)就可以了。代码如下：</p>

<pre class="line-numbers"><code class="language-java">@Override
public View onCreateView(LayoutInflater original, ViewGroup container,
                         Bundle savedInstanceState) {
    Bundle args = getArguments();
    int layoutId = args.getInt(&quot;layoutId&quot;);
    LayoutInflater layoutInflater = original.cloneInContext(getActivity());
    layoutInflater.setFactory(new ParallaxFactory(layoutInflater, this));
    return layoutInflater.inflate(layoutId, null);
}
</code></pre>

<p>接下来的代码就不写了吧，就是监听 ViewPager 的滑动事件，获取当前滑出滑进页面的自定义了 attrs 属性的 View 列表，然后再根据滑出屏幕的比例*属性参数做 view 的 TranslationY/TranslationX 操作。<br/><br/>
这里我贴一下代码仓库地址吧，有兴趣的小伙伴可以把代码跑起来看一下  </p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdiamondlin2016%2FParallaxlayoutinflater">github传送门</a></p>

<p>看起来好像并没有什么卵用，就是秀了一波骚操作。写一个自定义 view，继承 ImageView，设置几个自定义 attrs 属性，再在构造方法里面把属性读出来保存到类变量，对外提供读取方法，然后同样监听 viewpager 的滑动就行了。</p>

<p>哈哈哈哈~~分享这篇文章的最终目的不是为了实现这个动画，就是想看一下 LayoutInflate 的源码，了解一下 xml 文件是怎么解析成 view的过程。。。。</p>

<h2 id="toc_3">已知 bug：</h2>

<p>v4的版本升级到19.1.0之后动画会失效<br/><br/>
引入appcompat包会报 xml 解析错误。  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871543.html">
                
                  <h1>Android 用贝塞尔曲线绘制酷炫轮廓背景</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="media/15561207871543/15713367433328.png" alt=""/></figure></p>

<p>Github地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FOCNYang%2FContourView">github.com/OCNYang/Con…</a></p>

<p>今天就借助这个开源控件，来为大家梳理一下自定义 View 的整个流程：</p>

<ol>
<li>分析需求、功能，确定实现方法；</li>
<li>总结所需的参数属性以满足可定制性，较明确的属性归纳为自定义属性，不适合自定义属性的（比如传入数据，对象等）提供方法来设置；</li>
<li>有时自定义 View 会提供一种或几种默认及内置的样式，（这时可以根据内置的样式种类补充到自定义属性中），同时分析，使用内置样式或用户定制拓展时的流程；</li>
<li>开始根据分析，按流程依次重写： <code>构造函数（获取自定义属性，设置画笔等）</code> --&gt; <code>onMeasure()(测量大小)</code> --&gt; <code>onSizeChanged()(确定大小，一般我们在这里获取大小)</code> --&gt; <code>（onLayout()自定义View，因为没有子控件，这一步是不需要的）</code> --&gt; <code>onDraw()(按照需求和根据属性绘制实际内容)</code> --&gt; <code>其他</code></li>
</ol>

<p>如果有事件的需求，添加事件相关逻辑。<br/><br/>
那么现在我们就根据上面这个流程一步步来实现 ContourView。  </p>

<h2 id="toc_0">分析</h2>

<p><figure><img src="media/15561207871543/15713367536405.png" alt=""/></figure></p>

<p>根据上面的分析，实现的思路大概都有了。那么我们就开始寻找具体实现方法。<br/>
首先，我们选用三阶贝塞尔曲线，我们都知道三阶曲线的计算公式是：</p>

<pre class="line-numbers"><code class="language-text">path.moveTo(start.x, start.y);
path.cubicTo(control1.x, control1.y, control2.x,control2.y, end.x, end.y);
</code></pre>

<p><figure><img src="media/15561207871543/20171104150978744638463.gif" alt=""/></figure></p>

<p>也就是说绘制一段曲线，我们需要知道两个锚点的坐标以及两个控制点的坐标，为了保证曲线的弯曲度能够达到理想的状态，控制点的坐标也不能是随意取的，这就要求我们必须通过一种计算方法合理的得出控制点的坐标。Google 了一下，发现先驱们已经找到了很多种方法供我们选择。</p>

<p>最终经过对比我们选用了这样一种方法：</p>

<p><figure><img src="media/15561207871543/15713367665733.png" alt=""/></figure></p>

<p>这种方法大概的形式如上图，利用锚点集合，连续的4个锚点坐标Pi-1、Pi、Pi+1、Pi+2，通过具体公式来计算出中间两个锚点之间曲线的两个控制点坐标。</p>

<blockquote>
<p>详细的计算方法介绍请看 ContourView 的 WiKi：<br/>
<strong>Bézier-求贝塞尔曲线控制点</strong></p>
</blockquote>

<h2 id="toc_1">归纳自定义属性</h2>

<p>通过上面的分析，其实我们大概能总结出需要自定义的属性有哪些了。这里不着急，我们先总结一下自定义属性相关的内容和步骤？</p>

<ul>
<li><strong>创建自定义属性文件</strong></li>
</ul>

<p>在 res/values/ 下新建 attrs.xml 文件（默认新建项目没有这个文件）。文件内容类似如下：</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;attr name=&quot;custom_color&quot; format=&quot;color&quot;/&gt;

    &lt;declare-styleable name=&quot;ContourView&quot;&gt;
        &lt;attr name=&quot;shader_color&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;smoothness&quot; format=&quot;float&quot;/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre>

<p>其中 attr 和 declare-styleable 节点分别代表的意思如下：</p>

<p><strong>attr</strong>： 定义了一个属性，属性名为 custom_color 这个是可以随意起的，但是要注意不要和其他控件所冲突， format 所定义的是属性的格式，其中格式又分为好多种，下面会细说，这里定义的是颜色 color。</p>

<p><strong>declare-styleable</strong>：定义了一个属性组，在里面我们可以单独写 attr 属性，也可以引用直接在 resources 下定义的 attr，其中的区别就是引用的不用写 format。</p>

<p>需要注意的是，attr 并不依赖与 declare-styleable，declare-styleable 只是方便了 attr 的使用，使属性的使用更加明确。两者在代码中的获取方式并不相同，下面会细说。</p>

<p>在实际开发中，我们一般是采用 declare-styleable 方式，直接定义一组自己所编写的自定义控件需要用到的属性。</p>

<ul>
<li><strong>自定义属性的可以设置哪些属性</strong></li>
</ul>

<p>我们根据需要可以设置的自定义属性的格式一共有一下几种：</p>

<table>
<thead>
<tr>
<th style="text-align: center">format=&quot;格式&quot;</th>
<th style="text-align: center">说明</th>
<th style="text-align: center">app:myattr=&quot;使用值&quot;</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">reference</td>
<td style="text-align: center">参考某一资源ID</td>
<td style="text-align: center">&quot;@drawable/图片ID&quot;</td>
</tr>
<tr>
<td style="text-align: center">color</td>
<td style="text-align: center">颜色值</td>
<td style="text-align: center">&quot;#FFFFFFFF&quot; or &quot;@color/颜色ID&quot;</td>
</tr>
<tr>
<td style="text-align: center">boolean</td>
<td style="text-align: center">布尔值</td>
<td style="text-align: center">&quot;true&quot; or &quot;false&quot;</td>
</tr>
<tr>
<td style="text-align: center">dimension</td>
<td style="text-align: center">尺寸值</td>
<td style="text-align: center">&quot;0dp&quot;</td>
</tr>
<tr>
<td style="text-align: center">float</td>
<td style="text-align: center">浮点型</td>
<td style="text-align: center">&quot;1.2&quot;</td>
</tr>
<tr>
<td style="text-align: center">integer</td>
<td style="text-align: center">整型值</td>
<td style="text-align: center">&quot;10&quot;</td>
</tr>
<tr>
<td style="text-align: center">fraction</td>
<td style="text-align: center">百分数值</td>
<td style="text-align: center">&quot;50%&quot;</td>
</tr>
<tr>
<td style="text-align: center">string</td>
<td style="text-align: center">字符串</td>
<td style="text-align: center">&quot;OCN.Yang&quot;</td>
</tr>
<tr>
<td style="text-align: center">enum</td>
<td style="text-align: center">枚举值（详见下）</td>
<td style="text-align: center">&quot;自定义类型名称&quot;</td>
</tr>
<tr>
<td style="text-align: center">flag</td>
<td style="text-align: center">位或运算</td>
<td style="text-align: center">&quot;center</td>
</tr>
</tbody>
</table>

<blockquote>
<p>附：<br/><br/>
enum 枚举型定义：<br/>
<code>&lt;attr name=&quot;handsomeBoy&quot;&gt;</code><br/><br/>
    <code>&lt;enum name=&quot;OCNYang&quot; value=&quot;0x01&quot;/&gt;</code><br/><br/>
    <code>&lt;enum name=&quot;TFBOYS&quot; value=&quot;0x10&quot;/&gt;</code><br/><br/>
<code>&lt;/attr&gt;</code><br/><br/>
enum 使用：<br/><br/>
<code>app:handsomeBoy=&quot;OCNYang&quot;</code><br/><br/>
flag 定义：<br/><br/>
<code>&lt;attr name=&quot;gravity&quot;&gt;</code><br/><br/>
    <code>&lt;flag name=&quot;top&quot; value=&quot;0&quot;/&gt;</code><br/><br/>
    <code>&lt;flag name=&quot;center&quot; value=&quot;1&quot;/&gt;</code><br/><br/>
    <code>&lt;flag name=&quot;bottom&quot; value=&quot;2&quot;/&gt;</code><br/><br/>
<code>&lt;/attr&gt;</code><br/><br/>
flag 使用：<br/><br/>
<code>app:gravity=&quot;center|bottom&quot;</code><br/><br/>
混搭使用<br/><br/>
<code>&lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;</code><br/><br/>
这样，你传入资源ID或颜色值都是可以的了。</p>
</blockquote>

<ul>
<li><strong>获取自定义属性</strong></li>
</ul>

<p>那怎么获取这些自定义的属性呢，只需要在自定义 View 的构造方法（两个参数或两个以上的参数）里通过一下方式就能获取到了：</p>

<pre class="line-numbers"><code class="language-java">public ContourView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ContourView);
    //注意：获取时自定义的属性名有变动，例如：定义名：contour_style -&gt; 获取名：ContourView_contour_style（即：自定义属性组名_属性名）
    mStyle = typedArray.getInt(R.styleable.ContourView_contour_style, STYLE_SAND);
}
</code></pre>

<p>当然获取时，不同格式的属性需要通过 TypedArray 对应的不同的方法获取，那 TypedArray 都有哪些获取方法呢？如下图：</p>

<p><figure><img src="media/15561207871543/15713368060868.png" alt=""/></figure></p>

<p>通过方法名称，相信你能很轻易的知道，需要哪个对应方法获取了。</p>

<blockquote>
<p>如果你想更详细的了解每个方法的详细介绍，可以点击下面链接查看：<br/>
<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fcontent%2Fres%2FTypedArray.html">developer.android.com/reference/a…</a><br/>
另外，比较特殊的 enum 的获取方法：<br/>
由于 enum 的 value 值只能设置 int 型，所以，获取enum的方式是 getInt()。</p>
</blockquote>

<p>好了，关于自定义属性的介绍大概就是这么多内容了，那么回到原题，我们的 ContourView 需要哪几种 自定义属性呢？其实通过分析模块中我们就基本知道我们需要的属性有哪些了：</p>

<ul>
<li>内置轮廓样式： enum 类型，内置多少个 enum 就有多少类型；</li>
<li>绘制颜色：纯色绘制时，我们需要一个颜色值，Color 属性</li>
<li>Shader 相关：
<ol>
<li>采用哪种 Shader，enum 类型，有RadialGradient、SweepGradient、LinearGradient；</li>
<li>Shader 的颜色，Color 类型，需要两个一个startColor，一个endColor；</li>
<li>Shader 填充的控制，enum 类型，我们提供几种填充的方向，比如左上角到右下角，从上到下，然后我们再通过这个方向和传入的秒点集来动态计算起点和终点的坐标</li>
</ol></li>
</ul>

<p>具体如下：</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;ContourView&quot;&gt;
        &lt;attr name=&quot;shader_mode&quot;&gt;
            &lt;enum name=&quot;RadialGradient&quot; value=&quot;0x01&quot;/&gt;
            &lt;enum name=&quot;SweepGradient&quot; value=&quot;0x02&quot;/&gt;
            &lt;enum name=&quot;LinearGradient&quot; value=&quot;0x03&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;shader_startcolor&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;shader_endcolor&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;shader_style&quot;&gt;
            &lt;enum name=&quot;LeftToBottom&quot; value=&quot;0x00&quot;/&gt;
            &lt;enum name=&quot;RightToBottom&quot; value=&quot;0x11&quot;/&gt;
            &lt;enum name=&quot;TopToBottom&quot; value=&quot;0x12&quot;/&gt;
            &lt;enum name=&quot;Center&quot; value=&quot;0x13&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;contour_style&quot;&gt;
            &lt;enum name=&quot;Beach&quot; value=&quot;0x23&quot;/&gt;
            &lt;enum name=&quot;Ripples&quot; value=&quot;0x22&quot;/&gt;
            &lt;enum name=&quot;Clouds&quot; value=&quot;0x21&quot;/&gt;
            &lt;enum name=&quot;Sand&quot; value=&quot;0x00&quot;/&gt;
            &lt;enum name=&quot;Shell&quot; value=&quot;0x25&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;shader_color&quot; format=&quot;color&quot;/&gt;
        &lt;!--弯曲系数，在通过贝塞尔曲线绘制曲线时，来控制弯曲度--&gt;
        &lt;attr name=&quot;smoothness&quot; format=&quot;float&quot;/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre>

<h2 id="toc_2">内置样式</h2>

<p>既然自定义 View，那我们一定会为它提供一种或几种内置好的样式呀。这样别人在偷懒不想自己定制样式时，可以也有不错的显示效果呀！<br/><br/>
通过上面知道，ContourView 的轮廓样式主要是通过给出的锚点集控制的，所有的锚点围成的闭合曲线就是轮廓的大概样式了。<br/><br/>
所以，这里我们想内置几种样式，就等于内置几个锚点集就行了，这里的我们内置的锚点坐标为了使得不同大小显示效果相同，我们先在 onSizeChanged() 获得了 View 的宽高，然后根据宽高按照百分比来设置坐标。  </p>

<p>设置的内置轮廓有以下几种（丑爆了），只是轮廓，颜色是自己设置的：</p>

<table>
<thead>
<tr>
<th style="text-align: center">样式（contuor_style）</th>
<th style="text-align: center">效果</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Sand(默认)</td>
<td style="text-align: center"><figure><img src="media/15561207871543/15713368277148.png" alt=""/></figure></td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Clouds</td>
<td style="text-align: center"><figure><img src="media/15561207871543/15713368407348.png" alt=""/></figure></td>
</tr>
<tr>
<td style="text-align: center">Beach</td>
<td style="text-align: center"><figure><img src="media/15561207871543/15713368560128.png" alt=""/></figure></td>
</tr>
<tr>
<td style="text-align: center">Ripples</td>
<td style="text-align: center"><figure><img src="media/15561207871543/15713368665659.png" alt=""/></figure></td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Shell</td>
<td style="text-align: center"><figure><img src="media/15561207871543/15713368743740.png" alt=""/></figure></td>
</tr>
</tbody>
</table>

<h2 id="toc_3">重写各方法</h2>

<p>关于自定义 View 重写各方法的介绍，网上已经有太多太多，这里就不再啰嗦了。</p>

<blockquote>
<p>这里推荐一个关于自定义 View 尤其关于绘制方面讲解特别详细的系列博客：<br/>
<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FGcsSloop%2FAndroidNote">github.com/GcsSloop/An…</a><br/>
另外厚脸皮的放上一篇自己的关于讲解“自定义组合控件”的博客地址：<br/>
<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2F4bbc967214c9">www.jianshu.com/p/4bbc96721…</a></p>
</blockquote>

<p>我们知道，在自定义 View 时，必须要有构造函数的，对于4个构造函数，有时可能大家不确定到底该重写哪个，也不知道每个构造函数有什么区别，这里对常用的做法做下说明。</p>

<pre class="line-numbers"><code class="language-java">//在代码中直接 new 一个 Custom View 实例时,会调用第一个构造函数.这个没有任何争议.
public View(Context context);  
//在 xml 布局文件中使用自定义 View 时,会调用第二个构造函数.这个也没有争议.
public View(Context context, AttributeSet attrs);  
//关于这个构造函数的调用，网上真是众说纷纭，我也不说哪种说法正确，下面提供详解
public View(Context context, AttributeSet attrs, int defStyle);
//4个参数的构造函数这里不做考虑
</code></pre>

<p>关于内部这4个构造函数是怎么调用的，这里直接放源码图片，自己一目了然：</p>

<p><figure><img src="media/15561207871543/15713368833042.png" alt=""/></figure></p>

<p>大家在自定义 View 时，如果没有特别的需求，只要重写前两个构造函数就可以了，我习惯性的写成下面的形式：</p>

<pre class="line-numbers"><code class="language-java">public class MyView extends View {

    public MyView(Context context) {
        this(context, null);
    }

    public MyView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public MyView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        //初始化画笔，做一些属性的默认赋值等；
        //获取自定义的属性等；
    }
}
</code></pre>

<p>那，说了这么多还是没有提第3个参数到底是干什么的有什么用呀，这里我就不再为大家详细讲解了，这里找到了一片文章，讲解了第3个参数在什么时候怎么使用，大家可以看一下：</p>

<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fangeldevil%2Fp%2F3479431.html">www.cnblogs.com/angeldevil/…</a></p>

<p>回归到 ContourView，其实 ContourView 内部很简单，只对 onDraw() 进行了重写，毕竟 ContourView 的主要部分就是绘制。绘制的逻辑，就是遍历锚点集，然后利用上面 WiKi 里提到的公式求出各段曲线的控制点，然后用三阶贝塞尔曲线画出路径。当遍历完锚点集时，闭合曲线的轮廓基本上就得到了，然后就用Shader对路径进行绘制就行。</p>

<p>好了，本次的梳理内容就到这了，感兴趣的可以查看 ContourView 的源码进行分析，同时 ContourView 的这种背景效果还是不错的，需要的时候大家真的可以用到呢!</p>

<p><strong>ContourView GitHub</strong>:<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FOCNYang%2FContourView">github.com/OCNYang/Con…</a></p>

<p>如果大家想看一些高级的自定义 View 的例子可以查看上次开源的 App 的天气模块，其中的天气页面以及天气折线图等等控件都是通过自定义 ViewGroup 或自定义 View 实现的。地址是:<br/>
Qbox Github:<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FOCNYang%2FQBox">github.com/OCNYang/QBo…</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871499.html">
                
                  <h1>Android 带滑动效果的bottomBar</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>看到一个bottomBar的设计,感觉很好看,于是把它实现了出来</p>

<p><figure><img src="media/15561207871499/20171104150978644456283.gif" alt=""/></figure></p>

<p>可以看到这是一个常见的bottomBar<br/>
把它分解一下</p>

<ol>
<li>一共有5个item,每个item的背景颜色不一样</li>
<li>点击item时,item是通过滑动来移动到相应的item上的,这个移动也不是简单的线性移动,而是带有粘性的.</li>
<li>item移动时,item颜色的切换是有item之间过渡的,类似于加了一个遮罩</li>
<li>移到item时,item本身是伴随item的移动是有一个动画的.</li>
</ol>

<p>根据我们的分解,一步一步解决问题<br/><br/>
考虑到这是一个bottomBar,我选择了自定义ViewGroup来实现.因为用ViewGroup添加item会比较方便.</p>

<pre class="line-numbers"><code class="language-java">public class AnimationBottomBar extends ViewGroup {
    @Override
    protected void onDraw(Canvas canvas) {        
    super.onDraw(canvas);
    }
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
    }
}
</code></pre>

<p>另外item内的小动画我也选择用缩放的形式实现,所以个效果图会有一些出入</p>

<h2 id="toc_0">添加item</h2>

<p>通常来说,一个item会有一个图标和简短的标题.<br/>
举个例子,就像是知乎,即刻下方的bottomBar一样</p>

<p>所以一个item内有也要有一个图标和一个标题<br/><br/>
添加item的时候要足够方便,使用代码添加是个不错的选择,类似于这样<code>mAnimationBottomBar.addItem(item)</code>.<br/><br/>
我创建了一个简单的BottomItem类来包装item  </p>

<pre class="line-numbers"><code class="language-java">public class BottomItem {
    int drawableRes;//图标资源
    String title;//标题
    public BottomItem(@DrawableRes int drawableRes,String title){
        this.drawableRes=drawableRes;
        this.title=title;
    }
}
</code></pre>

<p>添加item之后,我将添加的BottomItem保存到一个list里</p>

<pre class="line-numbers"><code class="language-java">public AnimationBottomBar addItem(BottomItem bottomItem) {
    mBottomItemArrayList.add(bottomItem);
    return this;
}
</code></pre>

<p>添加item之后会返会对象本身,就可以继续<code>.addItem()</code>了,就像这样</p>

<pre class="line-numbers"><code class="language-java">mAnimationBottomBar.addItem(new BottomItem(R.drawable.h, &quot;zero&quot;))
                    .addItem(new BottomItem(R.drawable.h, &quot;one&quot;))
                    .addItem(new BottomItem(R.drawable.h, &quot;two&quot;))
                    .addItem(new BottomItem(R.drawable.h, &quot;four&quot;))
                    .addItem(new BottomItem(R.drawable.h, &quot;five&quot;))
</code></pre>

<p>好了,现在已经添加了item,嗯?球都没得.运行没有显示出来,当然啦添加了之后需要添加到ViewGroup里,在经过onMeasure和onLayout之后才会显示出来</p>

<pre class="line-numbers"><code class="language-java">public void build()  {
    itemCount = mBottomItemArrayList.size();
    itemWidth=getLayoutParams().width/itemCount;/*获得平均一个item的宽度,这里有个问题,因为这个时候还没有经过OnMeaSure(),width获取不到,在onMeasure里可以再次进行调整*/
    for (BottomItem bottomItem : mBottomItemArrayList) {/*添加图标*/
        ImageView imageView = new ImageView(mContext);
        imageView.setImageResource(bottomItem.drawableRes);
        addView(imageView, itemWidth, 20);
    }
    for (BottomItem bottomItem : mBottomItemArrayList) {/*添加标题/
        TextView textView=new TextView(mContext);
        textView.setTextSize(textSize);
        textView.setText(bottomItem.title);
        textView.setTextColor(textColor);
        textView.setGravity(Gravity.CENTER);
        addView(textView,itemWidth,20);
    }
}
</code></pre>

<p>onMeasure(),遍历刚刚所有添加子View,通知它们测量自己的长宽</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    childCount = getChildCount();/*获得所有子View的数量*/
    barWidth = getSize(300,widthMeasureSpec);//bottombar的宽度
    barHeight =  getSize(300,heightMeasureSpec);//--的高度
    for (int i = 0; i &lt; childCount; i++) {
        View childView = getChildAt(i);
        measureChild(childView, widthMeasureSpec, heightMeasureSpec);
        childView.getLayoutParams().width=itemWidth;/*调整子view的宽度*/
    }
}
</code></pre>

<p>onLayout(),确定所有的子View应该在的位置</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
  
    for (int i = 0; i &lt; itemCount; i++) {/*遍历每一个item,放置item的位置*/
        itemCenterX[i] = (int) (itemWidth * (i + 0.5));/*记录每个item的中心位置*/
        View childImageView = getChildAt(i);
        childImageView.layout(itemWidth * i, 0, itemWidth * (i + 1), 100);//放置图标,
        View childTextView=getChildAt(itemCount+i);
        childTextView.layout(itemWidth * i+childTextView.getWidth()/4,100,itemWidth * (i + 1),barHeight);/*放置标题*/
    }
}
</code></pre>

<p>此时的样子应该是这样的</p>

<p><figure><img src="media/15561207871499/15713659445009.png" alt=""/></figure></p>

<h2 id="toc_1">添加背景颜色</h2>

<p>你可能会想到用<code>setBackGroundColor()</code>来设置背景颜色,不过不要忘了,我们这个是要实现动画效果的,虽然使用<code>setBackGroundColor()</code>也能实现,但是要复杂一些.我决定使用<code>OnDraw()</code>画出来,在ViewGroup里默认是不调用<code>OnDraw()</code>的具体原因见这里解决方法也很简单</p>

<blockquote>
<p>如果我们要重写一个ViweGroup的onDraw方法，有两种方法：<br/>
1.在构造函数里面，给其设置一个颜色，如#00000000。<br/>
2.在构造函数里面，调用setWillNotDraw(false)，去掉其WILL_NOT_DRAW flag。</p>
</blockquote>

<p>我选择了第二个方法,因为我们要自己实现背景.</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onDraw(Canvas canvas) {
    /*绘制item颜色*/
    for (int i = 0; i &lt; 5; i++) {
        mPaint.setColor(itemcolors[i]);
        canvas.drawRect(itemWidth * i, 0, itemWidth * (i + 1), barHeight, mPaint);
        canvas.save();
    }
        
    /*画出背景,两个长方形*/
    mPaint.setColor(backGroundColor);
    canvas.drawRect(0, 0, itemMoveLeft, barHeight, mPaint);
    canvas.drawRect(itemMoveRight, 0, itemWidth * 5, barHeight, mPaint);
    canvas.save();
    super.onDraw(canvas);
}
</code></pre>

<p>这里我分了两部分来画,一是每个item的背景颜色,二是整体的背景颜色,注意画的先后顺序哦,我为了实现item的移动,把item部分画在下层,把背景画在了上层,通过改变背景来实现item的移动效果.<br/>
这时候的效果是这样的</p>

<p><figure><img src="media/15561207871499/15713659550522.png" alt=""/></figure></p>

<h2 id="toc_2">实现动画</h2>

<p>注意这里的动画其实分为两个部分,两部分是同时进行的</p>

<ol>
<li>item的移动动画</li>
<li>item的缩放动画</li>
</ol>

<pre class="line-numbers"><code class="language-java">@Override
protected void onDraw(Canvas canvas) {
    /绘制item颜色*/
    for (int i = 0; i &lt; 5; i++) {
        mPaint.setColor(itemcolors[i]);
        canvas.drawRect(itemWidth * i, 0, itemWidth * (i + 1), barHeight, mPaint);
        canvas.save();
    }
    /*画出背景,两个长方形*/
    mPaint.setColor(backGroundColor);
    canvas.drawRect(0, 0, itemMoveLeft, barHeight, mPaint);
    canvas.drawRect(itemMoveRight, 0, itemWidth * 5, barHeight, mPaint);
    canvas.save();
    /*遍历每个item位置,画出需要移动和缩放的item*/
    for (int i = 0; i &lt; itemCount; i++) {
        int deltaX=Math.abs(itemMoveCenter-itemCenterX[i]);/*获得当前item移动中心点和item固定中心点的距离*/
        if (deltaX&lt;itemWidth){
            itemScale[i]= (float) (-0.5*deltaX/itemWidth+1);/*当距离小于一个item的宽度时调整item的缩放系数*/
        }
        else itemScale[i]=0.5f;/*非选中的item的缩放系数固定为0.5*/
        
        /*对item的大小进行缩放*/
        View childImageView = getChildAt(i);
        childImageView.setScaleX(itemScale[i]);
        childImageView.setScaleY(itemScale[i]);
        View childTextView = getChildAt(itemCount+i);
        childTextView.setScaleX(itemScale[i]);
        childTextView.setScaleY(itemScale[i]);
    }
    super.onDraw(canvas);
}
</code></pre>

<p>我用了几个数组来记录每个item的固定中心位置,每个item的颜色,每个item的缩放系数.<br/>
缩放系数这里,默认的未选中item的缩放系数是0.5,选中的item的缩放系数就是1.0,移动的时候,越靠近选中的item就这个系数就越大.<br/>
既然是动画我们肯定要让她动起来,我继承了Animation类实现了自己的BottomAnimation类</p>

<pre class="line-numbers"><code class="language-java">private class BottomAnimation extends Animation {
    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        super.applyTransformation(interpolatedTime, t);
        int position = selectIndex - selectLastIndex;
        /*判断不同方向的移动*/
        if (position &lt; 0) {/*向左滑动*/
            itemMoveRight = (int) (itemMoveLastRight + interpolatedTime * itemWidth * position);
            itemMoveLeft = (int) (itemMoveLastLeft + setFirst(interpolatedTime) * itemWidth * position);
            itemMoveCenter = (int) (itemMoveLastRight + interpolatedTime * itemWidth * position) -itemWidth / 2;/*记录中心点移动的位置*/
        } else {/*向右滑动*/
            itemMoveRight = (int) (itemMoveLastRight + setFirst(interpolatedTime) * itemWidth * position);
            itemMoveLeft = (int) (itemMoveLastLeft + interpolatedTime * itemWidth * position);
            itemMoveCenter = (int) (itemMoveLastLeft + interpolatedTime * itemWidth * position) + itemWidth / 2;/*记录中心点移动的位置*/
        }
        postInvalidate();/*更新画面*/
    }
    /*为了实现果冻效果,先移动的一侧要有快速效果*/
    private float setFirst(float interpolatedTime) {
        return (float) Math.sin(interpolatedTime * 0.5 * Math.PI);
    }
}
</code></pre>

<p>在判断到有点击事件之后,启动这个动画就ok了</p>

<pre class="line-numbers"><code class="language-java">@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    int action = ev.getAction();
    switch (action) {
        case MotionEvent.ACTION_DOWN:
            touchDownX = ev.getX();
            break;
        case MotionEvent.ACTION_UP:
            if (ev.getX() / itemWidth == touchDownX / itemWidth) {
                selectIndex = (int) (ev.getX() / itemWidth);
                /*点击时开始动画*/
                startAnimation(mBottomAnimation);
            }
            break;
    }
    return true;
}
</code></pre>

<p>最后的效果是这个样子的</p>

<p><figure><img src="media/15561207871499/20171104150978699755982.gif" alt=""/></figure></p>

<p>最后完整的的代码在<a href="https://github.com/Mran/AnimationBottomBar">我的github</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871413.html">
                
                  <h1>Android Studio 快速创建Activity、Fragment模板</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="media/15561207871413/2017110415097859584759.gif" alt=""/></figure></p>

<blockquote>
<p>自行复制粘贴在<code>Settings</code>&gt;<code>Editor</code>&gt;<code>File and Code Templates</code>新建一个</p>
</blockquote>

<p><figure><img src="media/15561207871413/15713366916509.png" alt=""/></figure></p>

<h2 id="toc_0">Activity</h2>

<p>可以自行将AppCompatActivity换成自己的BaseActivity，不要忘记更改import哦</p>

<pre class="line-numbers"><code class="language-text">#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME}

#end
import android.os.Bundle
import android.support.v7.app.AppCompatActivity
/**
* description-&gt;&lt;一句话功能简介&gt;
* @author SLJ
* @time ${DATE}
*/
class ${NAME} : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
    }
}
</code></pre>

<h2 id="toc_1">Fragment</h2>

<pre class="line-numbers"><code class="language-text">#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME}

#end
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.app.Fragment
/**
* description-&gt;&lt;一句话功能简介&gt;
* @author SLJ
* @time ${DATE}
*/
class ${NAME} : Fragment() {
    
    override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View {
        val view = inflater?.inflate(, container, false)
        return view!!
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871451.html">
                
                  <h1>Android 为什么不该使用Timer</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">概述</h2>

<p>在Java开发中，用过定时功能的同学一定不会对Timer感到陌生。不过，除了Timer，在Java 5之后又引入了一个定时工具ScheduledThreadPoolExecutor，那么我们应该如何在这两个定时工具之间进行选择呢？</p>

<p>一般情况下我们都建议使用ScheduledThreadPoolExecutor而不是Timer，主要原因有以下3点：</p>

<ol>
<li>Timer使用的是绝对时间，系统时间的改变会对Timer产生一定的影响；而ScheduledThreadPoolExecutor使用的是相对时间，所以不会有这个问题。</li>
<li>Timer使用单线程来处理任务，长时间运行的任务会导致其他任务的延时处理，而ScheduledThreadPoolExecutor可以自定义线程数量。</li>
<li>Timer没有对运行时异常进行处理，一旦某个任务触发运行时异常，会导致整个Timer崩溃，而ScheduledThreadPoolExecutor对运行时异常做了捕获（可以在afterExecute()回调方法中进行处理），所以更加安全。</li>
</ol>

<p>下面我们就来通过了解Timer与ScheduledThreadPoolExecutor的运行原理来理解上面几个问题出现的原因。</p>

<h2 id="toc_1">Timer的运行机制</h2>

<p><figure><img src="media/15561207871451/15713367067259.jpg" alt=""/></figure></p>

<ul>
<li>TimerTask：任务类。内部持有<code>nextExecutionTime</code>变量，表示任务实际执行时间点，单位为毫秒，使用<code>System.currentTimeMillis()</code> + <code>delay</code>计算得出。</li>
<li><code>TimerQueue</code>：使用小根堆实现的优先队列。按照<code>TimerTask</code>的实际执行时间点由小到大排序。</li>
<li><code>TimerThread</code>：顾名思义，这是实际执行任务的线程。</li>
</ul>

<p><code>TimerThread</code>会在<code>Timer</code>初始化后启动，之后会进入<code>mainLoop()</code>方法，该方法会不断从<code>TimerQueue</code>中取出时间点最小的<code>TimerTask</code>。如果该<code>TimerTask</code>的执行时间点已到，则直接调用<code>TimerTask.run()</code>执行；否则，调用<code>wait()</code>方法，等待相应的时间。</p>

<p>而我们调用<code>Timer.schedule()</code>方法，实际上是通过<code>TimerQueue.add()</code>方法，将TimerTask加入任务等待队列。</p>

<p>这里还有一个需要注意的地方是：当加入任务的执行时间点是优先队列中最小的时，就调用<code>notify()</code>方法唤醒<code>TimerThread</code>，而<code>TimerThread</code>在被唤醒后会重新调用<code>TimerQueue.getMin()</code>方法，再次调用<code>wait()</code>，不过这次的等待时间就变成了新加入任务的时间点。</p>

<h2 id="toc_2">ScheduledThreadPoolExecutor的运行机制</h2>

<p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，对线程池的原理不了解的同学，可以看一下我的这篇文章：<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2F1fe47a3e8f4c">从零实现ImageLoader（三）—— 线程池详解</a>。</p>

<p>ScheduledThreadPoolExecutor的实现比Timer要复杂一些，不过要是理解了线程池的运行原理，其实也不难。它只不过是在ThreadPoolExecutor的基础上使用自定义的阻塞队列DelayedWorkQueue来实现任务定时功能。所以ScheduledThreadPoolExecutor的运行流程其实和ThreadPoolExecutor是差不多的。</p>

<p><figure><img src="media/15561207871451/15713367175739.jpg" alt=""/></figure></p>

<ul>
<li><strong>ScheduledFutureTask</strong>：任务类。内部持有time变量，单位为纳秒，通过<code>System.nanoTime()</code> + <code>delay</code>计算得出。</li>
<li><strong>DelayedWorkQueue</strong>：使用小根堆实现的优先阻塞队列，将ScheduledFutureTask按照从小到大的顺序排列，同时在take()方法内实现阻塞操作。</li>
<li><strong>WorkerThread</strong>：这里为了简单起见，我将线程池的核心线程和临时线程统一写成WorkerThread，但需要注意的是<code>ScheduledThreadPoolExecutor</code>是线程池的一个子类，所以线程池的那一套东西在<code>ScheduledThreadPoolExecutor</code>里也是有的。</li>
</ul>

<p>光从这两个图上看，好像ScheduledThreadPoolExecutor和Timer的实现都大同小异，不过是换了一些名字，但实际上这两个的实现还是有很大的不同的，不止因为ScheduledThreadPoolExecutor使用的是多线程。</p>

<p>在Timer里定时功能的实现主要依靠TimerThread.mainLoop()的等待，而ScheduledThreadPoolExecutor使用的是多线程，在每个线程里都单独实现定时功能是不现实的，因此，<code>ScheduledThreadPoolExecutor</code>将定时功能放在了<code>DelayedWorkQueue</code>类里，而由于<code>DelayedWorkQueue</code>是阻塞队列，所以定时任务的实现实际上就在<code>DelayedWorkQueue.take()</code>方法中。下面我们就来分析一下<code>DelayedWorkQueue.take()</code>到底做了什么。</p>

<h3 id="toc_3">Leader/Follower模式</h3>

<p>在多线程网络编程中，我们一般使用一个线程监听端口，在接收到事件后再使用其他的线程去完成操作。这种情况下，在两个线程之间的上下文切换开销其实是很大的，于是我们有了Leader/Follower模式：</p>

<p><figure><img src="media/15561207871451/15713367286186.png" alt=""/></figure></p>

<p>在Leader/Follower模式中，不存在一个专门用来监听的线程，所有的线程都是等价的，而这些线程会不断在Leader、Follower和Processor这三个状态之间来回切换。</p>

<p>在程序中会保证每个时刻有且只有一个Leader，这个Leader就暂时充当了之前用来监听端口线程的作用。而当有一个新的事件发生时，Leader不再是重新找一个线程去处理连接，而是自己转化为Processor处理事件，并且重新指定一个Follower作为新的Leader。当事件处理完毕后，Processor又会转化为Follower等待重新成为Leader。</p>

<h3 id="toc_4">take()方法的原理</h3>

<p>这里的<code>take()</code>方法就借助了<code>Leader/Follower</code>模式的思想，同一时刻只有一个<code>Leader</code>线程，不过这里由于任务执行的时间点是已经确定了的，所以不再是等待一个触发事件，而是等待最小任务所对应的延迟时间。其他的<code>Follower</code>线程则处于无限等待的状态，直到当前<code>Leader</code>到达指定时间后转化为<code>Processor</code>去处理任务，这时就会唤醒一个<code>Follower</code>作为下一任的<code>Leader</code>。而Processor在处理完任务后又会重新加入<code>Follower</code>进行等待。</p>

<h2 id="toc_5">绝对时间与相对时间</h2>

<p>了解了Timer与ScheduledThreadPoolExecutor的运行机制，下面我们就来看一下Timer的这些缺陷究竟是怎么回事。</p>

<p>首先是绝对时间与相对时间的问题，可能有人已经发现，不管是TimerTask还是ScheduledFutureTask都是存储的实际执行时间点，只不过一个是毫秒，一个是纳秒，难道时间单位还会对这些有影响？确实，时间单位是不会对任务的执行有影响的，不过这里的玄机就在于这个时间的计算方式：<code>System.currentTimeMillis()</code>与<code>System.nanoTime()</code>。</p>

<p><code>System.currentTimeMillis()</code>大家已经很清楚了，就是当前时间与1970年1月1日午夜的时间差的毫秒数，而<code>System.nanoTime()</code>又是什么呢？官方文档里是这么说的：</p>

<blockquote>
<p>此方法只能用于测量已过的时间，与系统或钟表时间的其他任何时间概念无关。返回值表示从某一固定但任意的时间算起的毫微秒数。<br/>
这就是Timer与ScheduledThreadPoolExecutor一个是基于绝对时间而另一个是基于相对时间的原因。下面我们写个例子来测试一下：</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t&quot; + new Date());

    Executors.newSingleThreadScheduledExecutor().schedule(() -&gt; {
        System.out.println(&quot;Executor:\t&quot; + new Date());
    }, 60, TimeUnit.SECONDS);

    new Timer().schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer:\t&quot; + new Date());
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-text">Start:    Sun Oct 08 10:51:44 CST 2017
Executor:    Sun Oct 08 10:51:41 CST 2017
Timer:    Sun Oct 08 10:52:45 CST 2017
</code></pre>

<p>这里，我在启动之后将系统的时钟向后调了一分钟，所以实际的启动时间应该是10:50:44，由于ScheduledThreadPoolExecutor的等待时间与系统无关，所以在一分钟后执行；而Timer是基于绝对时间的所以在10:52:45执行，实际上这时已经过去两分钟了。</p>

<h2 id="toc_6">单线程与多线程</h2>

<p>Timer的第二个缺陷是，由于它使用的是单线程，所以长时间执行的任务会对其他任务产生影响。</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    ScheduledExecutorService service = Executors.newScheduledThreadPool(3);

    service.schedule(() -&gt; {
        System.out.println(&quot;Executor 任务1:\t&quot; + new Date());
        try {
            Thread.sleep(30000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, 60, TimeUnit.SECONDS);
    service.schedule(() -&gt; {
        System.out.println(&quot;Executor 任务2:\t&quot; + new Date());
        try {
            Thread.sleep(30000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, 60, TimeUnit.SECONDS);

    Timer timer = new Timer();

    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer 任务1:\t\t&quot; + new Date());
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, 60000);
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer 任务2:\t\t&quot; + new Date());
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-text">Start:            Sun Oct 08 11:10:34 CST 2017
Executor 任务1:    Sun Oct 08 11:11:34 CST 2017
Executor 任务2:    Sun Oct 08 11:11:34 CST 2017
Timer 任务1:        Sun Oct 08 11:11:34 CST 2017
Timer 任务2:        Sun Oct 08 11:12:04 CST 2017
</code></pre>

<p>可以看到ScheduledThreadPoolExecutor中的两个任务在等待一分钟之后同时执行；而在Timer中的任务2却因任务1长达半分钟的执行时间，总共等了一分半钟才得以执行。</p>

<h2 id="toc_7">异常处理</h2>

<p>最后我们来看一下Timer与ScheduledThreadPoolExecutor对异常的处理情况：</p>

<h3 id="toc_8">Timer</h3>

<p>Timer内部没有对异常做任何处理，如果任务执行发生运行时异常，整个TimerThread都会崩溃：</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    Timer timer = new Timer();

    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            throw new RuntimeException(&quot;Timer 任务1&quot;);
        }
    }, 60000);
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;Timer 任务2:\t\t&quot; + new Date());
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-text">Start:            Sun Oct 08 11:53:05 CST 2017
Exception in thread &quot;Timer-0&quot; java.lang.RuntimeException: Timer 任务1
    at main.Main$1.run(Main.java:32)
    at java.util.TimerThread.mainLoop(Timer.java:555)
    at java.util.TimerThread.run(Timer.java:505)
</code></pre>

<p>可以看到，任务1抛出的运行时异常导致整个Timer线程崩溃，任务2自然也没有执行。</p>

<h3 id="toc_9">ScheduledThreadPoolExecutor</h3>

<p>ScheduledThreadPoolExecutor中对异常的处理实际上是ThreadPoolExecutor类完成的，ThreadPoolExecutor在任务运行时对异常做了捕获，并且将异常传入了afterExecute()方法：</p>

<pre class="line-numbers"><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService {
    final void runWorker(Worker w) {
        ...
        Throwable thrown = null;
        try {
            task.run();
        } catch (RuntimeException x) {
            thrown = x; throw x;
        } catch (Error x) {
            thrown = x; throw x;
        } catch (Throwable x) {
            thrown = x; throw new Error(x);
        } finally {
            afterExecute(task, thrown);
        }
        ...
    }
}
</code></pre>

<p>我们来验证一下：</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();

    service.schedule(() -&gt; {
        throw new RuntimeException(&quot;Executor 任务1&quot;);
    }, 60, TimeUnit.SECONDS);
    service.schedule(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Executor 任务2:\t&quot; + new Date());
    }, 60, TimeUnit.SECONDS);
}
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-text">Start:            Sun Oct 08 11:33:35 CST 2017
Executor 任务2:    Sun Oct 08 11:34:36 CST 2017
</code></pre>

<p>可以看到这里虽然任务1抛出了运行时异常，但由于线程池内部完善的异常处理机制，任务2得以成功执行。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871379.html">
                
                  <h1>Android 四种启动模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>此博文用来介绍一下Activity的四种启动模式和应用的场景。</p>

<p>主要是对于Android Activity启动模式的梳理。</p>

<h2 id="toc_0">返回栈</h2>

<p>首先，在介绍之前，我们需要有一个返回栈的概念。栈，是一种数据结构，遵循的是先进后出的规则，而无论是什么APP，里面的N个Activity最终都会被压入栈（或弹出栈中），而与我们进行交互的就是处于栈顶的Activity，在这里就需要介绍一个返回栈的概念。上一张图。</p>

<p><figure><img src="media/15561207871379/15713366435881.png" alt=""/></figure></p>

<p>相信这张图片很清楚的说明，入栈的方式，所谓先进后出就是现在我们假设栈里面已经有abcd四个Activity了，并且都市默认的standard方式启动的。所谓先进后出就是，当我们不断按下back（返回键）的时候，后进去的d反而是最先谈栈的，a最后弹栈。</p>

<p><strong>压栈</strong>：a-&gt;b-&gt;c-&gt;d(入栈顺序)</p>

<p><strong>弹栈</strong>：b-&gt;c-&gt;b-&gt;a(弹出顺序)</p>

<p>先有一个返回栈的概念才能更好的进行分析。</p>

<h2 id="toc_1">为什么需要启动方式</h2>

<p>比如说，现在栈里面已经有四个activity abcd,这个时候的需求是需要到一个Activity a,如果我们只是使用默认的启动方式，那么就会形成abcda，当用户点击back按键的时候，弹出a，abcd。再按弹出d，abc。以此类推，然后又看到了a，是不是很烦人，而且这样的设计也的确很不人性化，所以设计了四种启动方式，来优化更好的体验，和满足特定场景下的用户需求。</p>

<h2 id="toc_2">四种启动的方式</h2>

<p><strong>(1) standard</strong>: 标准的方式，也是系统默认的方式，每次启动一个activity，都会去创建一个新的activity的实例，并让该实例出于activity的栈顶位置，与用户交互，不管该实例存在不存在。</p>

<pre class="line-numbers"><code class="language-java">button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Intent intent= new Intent(FirstActivity.this,FirstActivity.class);
        startActivity(intent);
    }
});
</code></pre>

<p>这是一个很典型的例子，就是由FirstActivity，跳转到FirstActivity，我们直观的思维会认为FirstActivity已经存在了，那么直接复用就好了啊，但是事实却不是这样子的。点击button两下，算上本身创建的FirstActivity，现在栈里面相当于有三个FirstActivity的实例，必须要点击三次返回键，才能回到桌面。这就是standard模式。</p>

<p><strong>(2) singleTop</strong> :栈顶复用模式，当一个新的Activity已经处于栈顶的时候，那么再次调用新的Activity将不会创建新的实例，因为新的Activity已经在栈顶了，可以直接复用。比如说是栈的情况是abcd，d的启动方式singleTop，那么当我们再次启动d的时候，并不会创建新的实例，还是abcd，因为栈顶已经是d了，如果是adbc那么创建以后就是adbcd。如果d是默认方式启动的话，得到的就是abcdd。</p>

<p><strong>(3) singleTask</strong> ：栈内复用的模式，只要activity在一个栈中，那么多次启动此activity都不会重新创建实例，比如说只要Activity以singleTask的方式启动，系统首先会去找寻是否有A需要的栈s，来存放A实例。如果没有s，就会创建栈s。然后做判断，如果s中有A，那么就直接把A置于栈顶，并且清空A上面的所有实例。如果A已经在栈顶，那么就直接复用A。如果存在S，就看S中是否有A的实例，没有A的实例就直接创建并且入栈，如果已经有A的实例并且没有处于栈顶，那就清楚A之前的所有实例，让A处于栈顶。举个例子(D都是以singleTask启动)：</p>

<ul>
<li>比如目前S1中的情况为ABC，D以singleTask的启动方式入栈，并且请求的任务栈为S2，那么很显然，并不存在S2，所以就会创建S2，并且把D压入S2中。S1：ABC，S2：D。</li>
<li>另一种情况，S1：ABC ，D请求的是S1，那么直接压入S1中。S1：ABCD.</li>
<li>S1：ADBC ，D请求的是S1，那么最终的S1：AD。因为栈内复用方式默认有一个clearTop的方法，会导致D上所有的实例出栈。让D置为栈顶。</li>
</ul>

<p><strong>(4) singleInstance</strong>: 单实例模式。这是一个加强版本的singleTask模式，它除了具有singleTask模式的所有特性之外，还加强的了一点，就是次方式启动的Activity只能单独的位于一个任务栈中，由于栈复用的特性，后续均不会创建新的Activity，除非这个任务栈被系统的销毁了。</p>

<h2 id="toc_3">特殊情况</h2>

<p>比如说现在有前台任务栈s1：AB(A底，B顶),后台任务栈S2:CD（都是以singleTask的方式启动）。当s1请求D入栈的时候，最终得到的是ABCD，但是如果只是请求C入栈的时候，得到的是ABC.</p>

<h2 id="toc_4">设置启动模式（两种）</h2>

<p><strong>第一种：Xml文件中配置</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;activity
    android:name=&quot;.FirstActivity&quot;
    android:label=&quot;hello My First Activity&quot;
    android:launchMode=&quot;singleTop&quot;/&gt;
</code></pre>

<p><strong>第二种：设置intent标志位的时候配置</strong></p>

<pre class="line-numbers"><code class="language-text">Intent intent= new Intent();
intent.setClass(FirstActivity.this,FirstActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
</code></pre>

<p>第二种的优先级方式是高于第一种的，当两种都存在的时候，以第二种为准。</p>

<h2 id="toc_5">指定栈和获取当前的activity的栈ID</h2>

<p>指定栈就是在设置activity的时候指定taskAffinity的属性，要求一个字符串，用.来分包，如果不写，栈就是默认的包名。在这里我指定为了，yanshui.site.task01配合上singleTask使用</p>

<pre class="line-numbers"><code class="language-text">&lt;activity
    android:name=&quot;.FirstActivity&quot;
    android:label=&quot;hello My First Activity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;yanshui.site.task01&quot;/&gt;
</code></pre>

<pre class="line-numbers"><code class="language-java">//当你想要知道你当前的activity处于栈的id的时候直接在该activity中调用此方法即可。
Log.d(TAG, &quot;task id is &quot;+getTaskId());
</code></pre>

<h2 id="toc_6">使用场景</h2>

<ul>
<li>Standard 默认启动方式，每次都会创建一个新的实例，如果开发中需要就使用。但应该注意具体的情况，优化设计体验。</li>
<li>singleTop 栈顶复用，适合接受推送消息的展示页。某些本应只展示一个的场景，比如一下子收到一堆推送消息，不能每个都弹出来吧。但凡是这样的都行。优酷的推荐视频，电商app推送一个活动。每次只是显示第一条消息。</li>
<li>singleTask 栈复用模式适合程序入口，不需要启动后activity的是的，只能用在启动页了吧，首页，这种只允许有一个instance，如果有其他就移除掉它顶上的。从这个Activity进入的其他activity都抛弃掉了。用户要再操作一次。</li>
<li>singleInstance 栈单实例模式，需要一个activity提供给多有的应用程序访问的，比如说闹钟，响过一次以后，不再提醒，然后就不会再响了。</li>
</ul>

<h2 id="toc_7">标志位</h2>

<ul>
<li><p>FLAG_ACTIVITY_NEW_TASK(xml中指定为singleTask)</p></li>
<li><p>FLAG_ACTIVITY_SINGLE_TOP(xml中指定为singleTop)</p></li>
</ul>

<p>​</p>

<h2 id="toc_8">简单小结一下</h2>

<h3 id="toc_9">使用方式：</h3>

<p>standard：怎么样都要创建<br/><br/>
singleTop：顶上不是target Activity，new一个<br/><br/>
singleTask：顶上不是target Activity，移除target之上的，把自己变成top。<br/><br/>
singleInstance：开辟私有的task，完全独立于程序的其他activity的task。  </p>

<h3 id="toc_10">使用场景：</h3>

<p>standard：普通activity<br/><br/>
singleTop：要展示推送过来的消息<br/><br/>
singleTask：程序入口等启动页面<br/><br/>
singleInstance：完全独立的，类似闹钟的提示  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871347.html">
                
                  <h1>Android 动态更换桌面图标</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">简介</h2>

<p>最近看到有可以实现动态改变桌面图标这个功能，比如天猫等app在各种剁手节的时候基本都会换个应景的图标以及整体风格，而这里只讨论图标的更换，查阅了一些资料，这里就介绍一下我认为最便捷的方式。</p>

<h2 id="toc_1">原理</h2>

<p>原理其实很简单就是利用<activity-alias>标签，控制其enabled属性，用来显示与否。</p>

<h2 id="toc_2">实现</h2>

<p>实现之前，先简单描述一下需求：</p>

<p>App默认图标是Android机器人图标，然后还有另外两个图标icon_1和icon_2，通过按钮点击设置变成哪个图标，也有一个还原图标的功能。</p>

<h3 id="toc_3">实现步骤：</h3>

<ul>
<li>增加对应个数的<activity-alias>标签</li>
<li>增加布局喝对应点击事件</li>
<li>代码控制显示哪个图标</li>
</ul>

<p>接下来就一步一步的来实现：</p>

<p><strong>增加对应个数的<activity-alias>标签</strong></p>

<p>这里还有两个图标，所以我们再增加两个<activity-alias>标签，这个标签是在AndroidManifest.xml的<application>标签内的，和<activity>标签同一级，其中一个代码如下：</p>

<pre class="line-numbers"><code class="language-text">&lt;activity-alias
    android:name=&quot;.MainActivity1&quot;
    android:enabled=&quot;false&quot;
    android:icon=&quot;@mipmap/icon_1&quot;
    android:label=&quot;@string/app_name&quot;
    android:targetActivity=&quot;.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity-alias&gt;
</code></pre>

<p>这里需要注意一下他的这几个属性：</p>

<table>
<thead>
<tr>
<th style="text-align: center">属性</th>
<th style="text-align: center">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">name</td>
<td style="text-align: center">可任意取值，只要能保证是唯一标识即可，为了方便管理建议有规律一些</td>
</tr>
<tr>
<td style="text-align: center">targetActivity</td>
<td style="text-align: center">这个属性的值就是代表指向的是哪个Activity，而这个标签本身代表是该Activity的别名，记得指向的Activity要在该标签之前申明，否则可能运行不起来</td>
</tr>
<tr>
<td style="text-align: center">icon</td>
<td style="text-align: center">指的是该别名对应的应用图标</td>
</tr>
<tr>
<td style="text-align: center">label</td>
<td style="text-align: center">指的是该别名对应的应用名字</td>
</tr>
<tr>
<td style="text-align: center">enabled</td>
<td style="text-align: center">默认是true，true就会显示在桌面上，这里为了保证桌面只显示一个图标，则<activity-alias>中的属性都是false，而在之后代码中动态控制这个属性，来显示和隐藏对应的图标</td>
</tr>
</tbody>
</table>

<p>至于<intent-filter>，这个和Activity的没有区别,其实完全可以把<activity-alias>当作Activity组件来看，只是不是真身，是别名罢了。</p>

<p>另一个也是同理的，这里就不介绍了。</p>

<p><strong>增加布局和对应点击事件</strong></p>

<p>这一点其实没啥好说的，布局就是一个竖直方向的LinearLayout，里边有三个Button，通过其onClick属性，设置点击相应的方法，当然你也可以获取到这些Button再设置OnClickListener，代码比较简单，文末有Demo地址。</p>

<p><strong>代码控制显示哪个图标</strong></p>

<p>这一步其实也就是调用PackageManager中的一个方法即可，方法如下：</p>

<pre class="line-numbers"><code class="language-java">private void changeLauncher(String name) {
    PackageManager pm = getPackageManager();
    //隐藏之前显示的桌面组件
    pm.setComponentEnabledSetting(getComponentName(),
            PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
    //显示新的桌面组件
    pm.setComponentEnabledSetting(new ComponentName(MainActivity.this, name),
            PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
}
</code></pre>

<p>都是调用PackageManager的setComponentEnabledSetting方法，第一个参数表示操作的组件是哪个，第二个参数表示显示还是隐藏，第三个组件表示是否关掉app。</p>

<h2 id="toc_4">TIPS</h2>

<ol>
<li><p>这里有个技巧，建议不要直接点了切换按钮就去执行切换图标，因为执行切换图标之后始终会关闭这次打开的app，所以我们 可以点击之后先记录下要换成哪个图标，在程序退出的时候再切换图标，这样一来就不会关闭该app了。</p></li>
<li><p>细心的朋友会发现，在调试阶段，我改了这个app的启动图标，再执行代码启动，发现启动不了，其实这是因为代码中默认启动那个组件和修改后的那个组件不一致了，所以就启动不了，而对于程序的更新和安装是没有影响的。</p></li>
<li><p>这种方式动态更换图标，更换的时候不是，切换之后就马上生效的，据我观察应该和手机性能有关，在执行该操作之后，会在几秒钟之内改变图标，但是对于普通桌面图标的改变，该缺点还是可以接受的，毕竟不是用户手动触发，也不影响体验。</p></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871315.html">
                
                  <h1>Android Studio配置</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">显示行号</h2>

<p>当我首次启动我的 Android Studio 的时候，我想做的第一件事就是希望能看到文件中的行号。</p>

<p><strong>配置方法</strong></p>

<ul>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General | Appearance</li>
<li>勾选 Show line numbers</li>
</ul>

<h2 id="toc_1">驼峰选择</h2>

<p>Android 开发中，我们通常会使用驼峰命名法对变量进行命名，但是当我们通过 Ctrl + Left/ Right 键改变字符选择区域的时候 Android Studio 默认不支持‘驼峰’单词的选择。</p>

<p><strong>配置方法</strong></p>

<ul>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General | Smart Keys</li>
<li>选中 Use “CamelHumps” words</li>
</ul>

<p><strong>注意</strong>:如果你仍然希望当鼠标在单词上双击之后选中整个单词，需要作如下设置：</p>

<ul>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General</li>
<li>取消选中 ‘Honor Camel Humps words settings when selecting on double click’</li>
</ul>

<h2 id="toc_2">命名前缀</h2>

<p>我们通常会遵循 Android 官方关于编码风格的指导来进行字段命名。在 Android 源码中我们可以看到通常成员变量都是以‘m’开始。其实Android Studio 可以自动在帮我们生成字段名称的时候加上自定义的前缀，如:</p>

<ul>
<li>非共有，非静态的成员变量以’m’开始</li>
<li>静态成员变量以’s’开始</li>
</ul>

<p><strong>配置方法</strong></p>

<ul>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Code Style | Java</li>
<li>选择 Code Generation 标签</li>
<li>给普通 Field 添加一个’m’前缀，给 Static filed 添加一个’s’前缀</li>
</ul>

<h2 id="toc_3">快速导包</h2>

<p>在 Android Studio 中，我们可以通过 Alt + Enter 和 Control + Alt + O 进行导包和清除无用导包，但我们都希望这些事情应当快速自动完成。</p>

<p><strong>配置方法</strong></p>

<ul>
<li>File | Settings 打开设置</li>
<li>选择 Editor | General | Auto Import</li>
<li>勾选 Optimize imports on the fly</li>
<li>勾选 Add unambiguous imports on the fly</li>
</ul>

<h2 id="toc_4">Log 颜色</h2>

<p>Darcula 主题中 Logcat 的默认配色只有红白两种颜色，不太便于我们区分 Log 的类型。</p>

<p><strong>配置方法</strong></p>

<ul>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Color &amp; Fonts | Android Logcat</li>
<li>点击 Click on Save As…按钮创建一个新的配色 Scheme</li>
<li>按照下面的表格修改对应的颜色(修改之前需要取消勾选 Use inherited attributes)</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: center">Log级别</th>
<th style="text-align: center">颜色</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Assert:</td>
<td style="text-align: center">#AA66CC</td>
</tr>
<tr>
<td style="text-align: center">Debug:</td>
<td style="text-align: center">#33B5E5</td>
</tr>
<tr>
<td style="text-align: center">Error:</td>
<td style="text-align: center">#FF4444</td>
</tr>
<tr>
<td style="text-align: center">Info:</td>
<td style="text-align: center">#99CC00</td>
</tr>
<tr>
<td style="text-align: center">Verbose:</td>
<td style="text-align: center">#FFFFFF</td>
</tr>
<tr>
<td style="text-align: center">Warning:</td>
<td style="text-align: center">#FFBB33</td>
</tr>
</tbody>
</table>

<h2 id="toc_5">代码字体修改</h2>

<p>代码编辑区字体修改：选择菜单栏“File--settings--Editor--Colors&amp;Fonts--Font”</p>

<p>同样也可以修改控制台的字体(Console Font)</p>

<p>修改完之后发现AS的一些默认字体如侧边栏的工程目录的字体并没有发生变化，如果想改的话，那还是改一下吧（我个人一般是不改的），修改AS的默认字体(Appearance -&gt; Override default fonts by (not recommended))</p>

<h2 id="toc_6">活动模板</h2>

<p>Android Studio 中默认提供了很多非常方便的活动模板(Live Templates)，例如，我们输入sout 后按 enter 键， Android Studio 会自动帮我们写入 System.out.println();其实 sout 就是 AS 自带的一个活动模板。</p>

<p>Editor -&gt; Live Templates</p>

<p>由此可以看出，活动模板就是我们常用代码的一个缩写。开发中有很多代码都会重复出现，因此自定义合适的活动模板能很大程度上避免我们很多重复的体力劳动。那么问题来了，如何自定义？</p>

<p>这里我们实现一个AS不自带的方法，就是我们经常使用的switch用法作为例子。</p>

<ul>
<li>在Custom的自定义组下，创建一个swi的自定义活动模板</li>
<li>提示关键字设置为 swi ，描述为 switch的选择语句</li>
<li>然后设置四个参数CONTAINER, FIRST,SECOND,END,分别代表着参数，第一个选择，第二个选择，最后一个光标坐落点。</li>
<li>然后点击右边的Edit variabldes，然后进行对四个参数的作用进行赋值，第一个参数我们选择suggestFirstVariableName(“Object”)表示系统推荐的，第二、三是为了我们方便写入我们需要的值，换行只需要回车就可以切换，避免鼠标操作，纯键盘手打，第四个参数就是我们输入的最后。</li>
</ul>

<p><strong>配置方法</strong></p>

<ul>
<li>File | Settings 打开设置</li>
<li>选择 Editor | Code Style | Live Templates</li>
<li>点击最右侧的加号并选择 Template Group</li>
<li>在弹出的对话框中输入一个活动模板分组的名称，如 custom</li>
<li>在左侧选中上一步中创建的 custom 分组，点击右边的加号</li>
<li>选择 Live Template ，在 Abbreviation 中对输入 psh</li>
<li>在 Description 中输入这个活动模板的描述</li>
<li>在 Template text 中输入以下代码</li>
<li>点击下方的 Define 按钮，选中 java 表示这个模板用于java代码</li>
<li>点击右侧的 Edit variables</li>
<li>选择 Expression 下拉框中的 className 并勾选 Skip if…</li>
</ul>

<blockquote>
<p>这个操作的作用是，AS会自动将我们在上一步中用’$’符包裹的 className自动替换为当前类不含包名的类名</p>
</blockquote>

<ul>
<li>点击 Apply 和 Ok 让设置生效。</li>
</ul>

<h2 id="toc_7">类的头文件声明，标上自己的专注权</h2>

<p>类的头文件声明，因为我们写的代码，在开发程序的时候，我们一般都会给文件自动添加上一些关于文件的注释信息，比如开发者的名字，开发的时间，开发者的联系方式等等，效果图如下。</p>

<p><strong>设置步骤</strong></p>

<ul>
<li>点击菜单栏的“File“-&gt;“Settings”，打开Settings窗口</li>
<li>点击“IDE Settings”下面的“File and Code Templates”，然后选中Templates里面的Class</li>
<li>然后选中Includes tab下面的File Header。</li>
<li>在最右边的输入框中就可以输入我们想要设置的注释模板了。比如我们输入：</li>
</ul>

<pre class="line-numbers"><code class="language-text"> /**  
  * Created by OCN.Yang on ${DATE}. ${HOUR}:${MINUTE}  
  * mail:yangocn@163.com  
  */  
</code></pre>

<p>然后点击ok便大功告成了。</p>

<h2 id="toc_8">禁止自动打开上次的工程</h2>

<p>我喜欢自己选打开哪个工程，果断禁用，设置如下：<br/>
Preference -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Startup/shutdown -&gt; Reopen last project on startup</p>

<h2 id="toc_9">禁止代码折叠</h2>

<p>Intellij IDEA默认有很多地方的代码都会自动折叠，不过我看不惯，所以取消了，设置如下：</p>

<p>Preference -&gt; Editor -&gt; General -&gt; Code Folding -&gt; One-line methods | &quot;Closures&quot;(anonymous classes implementing one method,before Java 8) | Generic constructor and method parameters</p>

<h2 id="toc_10">全屏代码</h2>

<p>这个功能是Android studio自带的功能，但是需要你先手动设置一下：全屏代码的快捷键（默认情况下这个功能是没有快捷键的，即是关闭的）：Toggle Presentation mode</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871281.html">
                
                  <h1>Android-Lambda 表达式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Lambda 表达式</h2>

<p>编程中提到的 Lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。</p>

<p>Lambda 允许我们把行为传到函数里。之前把行为传到函数里我们采用的是匿名内部类，该方法导致行为最重要的方法夹杂在中间，不够突出，详见举例中代码。</p>

<pre class="line-numbers"><code class="language-java">//以前点击事件，使用了匿名内部类
mButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast.makeText(MainActivity.this, &quot;toast&quot;, Toast.LENGTH_LONG).show();
            }
        });
//新款Lambda 表达式，大家可以比较下上下的不同之处
mButton.setOnClickListener(view -&gt; Toast.makeText(MainActivity.this, &quot;toast&quot;, Toast.LENGTH_LONG).show());
</code></pre>

<p>因此Lambda 表达式可以理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</p>

<h2 id="toc_1">代码格式</h2>

<p>Lambda 表达式的基本格式是：() -&gt; {}</p>

<p>有下面三种具体表达：</p>

<pre class="line-numbers"><code class="language-text">//(params) -&gt; expression
//接收 x 和 y 这两个整形参数并返回它们的和； 
(int x, int y) -&gt; x + y

//(params) -&gt; statement   
//不接收参数，返回整数 ‘42’； 
() -&gt; 42

//(params) -&gt; {statement}
//接收一个字符串并把它打印到控制台，不返回值。
(String s) -&gt; { System.out.println(s); }
</code></pre>

<h2 id="toc_2">文字解释</h2>

<p>Lambda 表达式的语法由参数列表、箭头符号 -&gt; 和函数体组成。函数体既可以是一个表达式，也可以是一个语句块：</p>

<ul>
<li>表达式：表达式会被执行然后返回执行结果。</li>
<li>语句块：语句块中的语句会被依次执行，就像方法中的语句一样
<ul>
<li>return 语句会把控制权交给匿名方法的调用者</li>
<li>break 和 continue 只能在循环中使用</li>
<li>如果函数体有返回值，那么函数体内部的每一条路径都必须有返回值</li>
</ul></li>
</ul>

<p>Lambda 表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使 lambda 表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。</p>

<pre class="line-numbers"><code class="language-java">FileFilter java = (File f) -&gt; f.getName().endsWith(&quot;*.java&quot;);
String user = doPrivileged(() -&gt; System.getProperty(&quot;user.name&quot;));
new Thread(() -&gt; {
  connectToService();
  sendNotification();
}).start();
</code></pre>

<h2 id="toc_3">具体案例</h2>

<p><figure><img src="media/15561207871281/15713366296180.png" alt=""/></figure></p>

<h2 id="toc_4">方法引用（关键字 ::）</h2>

<blockquote>
<p>简单来说，方法引用就是 Lambda 表达式的一种简写。当你创建一个 Lambda 表达式时，你创建了一个匿名方法并提供方法体，但你使用方法引用时，你只需要提供已经存在的方法的名字，它本身已经包含方法体。</p>
</blockquote>

<p>做一个简单的解释，对集合进行排序，使用了Comparator的匿名内部类写法</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
        list.add(2);
        list.add(1);
    
        Collections.sort(list,new  Comparator&lt;Integer&gt;(){
            @Override
            public int compare(Integer a, Integer b) {
                return a - b;
            }
        });
    }

//用Lambda 进行表示
Collections.sort(list, (a, b) -&gt; a - b);

//使用Lamabda 的方法引用，可以让匿名内部类Comparator中方法的两个参数和Integer类中compare方法的两个参数自动对应起来，是不是简洁明了呢。
Collections.sort(list, Integer::compare);
</code></pre>

<p>方法引用的种类（Kinds of method references）</p>

<ul>
<li>静态方法引用：ClassName::methodName</li>
<li>实例上的实例方法引用：instanceReference::methodName</li>
<li>超类上的实例方法引用：super::methodName</li>
<li>类型上的实例方法引用：ClassName::methodName</li>
<li>构造方法引用：Class::new</li>
<li>数组构造方法引用：TypeName[]::new</li>
<li>对于静态方法引用，我们需要在类名和方法名之间加入 :: 分隔符，例如 Integer::sum</li>
</ul>

<h2 id="toc_5">使用 Lambda 的好处</h2>

<ul>
<li>Lambda 表达式不需要每次都要被实例化，对于 Java 来说，带来巨大的好处。不像实例化匿名类，对内存的影响可以降到最小。</li>
<li>Lambda 表达式不需要拷贝变量到它的运行环境中，从而 Lambda 表达式被当做是一个真正的方法来对待，而不是一个类的实例 。</li>
<li>因为是复制，变量必须声明为 final 类型，以保证在获取和使用时不会被改变。Java 使用了优雅的方式保证了变量不会被更新，所以我们不用显式地把变量加上 final 修饰。</li>
<li>Lambda 表达式函数体适合小型 Lambda 表达式，它消除了 return 关键字，使得语法更加简洁。</li>
<li>Lambda 表达式取代了匿名内部类，取消了模板，允许通过函数式风格编写代码，使代码的可读性更高，如果不想看不懂大佬的代码的话，赶紧学起来吧。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/9/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_3.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_5.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15712984956484.html">代理模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15712937841703.html">备忘录模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711947460528.html">观察者模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711314242192.html">策略模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711233221322.html">适配器模式</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
