<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207872056.html">
                
                  <h1>Android-OOM案例分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在Android（Java）开发中，基本都会遇到java.lang.OutOfMemoryError（本文简称OOM），这种错误解决起来相对于一般的Exception或者Error都要难一些，主要是由于错误产生的root cause不是很显而易见。由于没有办法能够直接拿到用户的内存dump文件，如果错误发生在线上的版本，分析起来就会更加困难。本文从一个具体的案例切入，介绍OOM分析的思路及相关工具的使用。</p>

<h2 id="toc_0">案例背景</h2>

<p>在美团App 7.4~7.7版本期间，美食业务的OOM数量居高不下，远高于历史水平，主要都是DECODE本地的资源出错。</p>

<p><figure><img src="media/15561207872056/15713351740374.png" alt=""/></figure></p>

<p>图中OOM数量为各版本发版后第一个月的统计量，包含新发版本及历史版本。对比了同时期其他业务的情况，也有类似OOM。由于美食业务的访问量占美团App的比重较大，因此，OOM的数量相对其他业务也多一些。</p>

<p>思路方案</p>

<p>在问题较为严重的7.6~7.7版本期间，团队对OOM频现的原因有过各种猜测。笔者怀疑过是否是业务上某些修改引起的，例如头图尺寸变大，或者是由页面模块加载方式引起的等等。但这些与OOM问题出现的时间并不吻合。其次也怀疑过是否由某些ROM的Bug导致，但此推断缺乏有力的证据支撑。因此，要找到OOM的root cause，根本途径还是找到谁占的内存最多，然后再根据具体case具体分析，为什么占了这么多。</p>

<p>采集用户手机内存信息</p>

<p>要分析内存的占用，需要内存的dump文件，但是dump文件一般都比较大，让用户配合上传dump文件不合适。所以希望能够运行时采集一些内存的特征然后随着crash日志上报上来。当用户发生OOM时，dump出用户的内存，然后基于com.squareup.haha:haha:2.0.3分析，得到一些关键数据（内存占用最多的实例及所占比例等）。但这个方案很快就被证明是不可行的。主要基于下面几个原因：</p>

<p>需要引入新的库。<br/>
dump和分析内存都很耗时，效率难以接受。<br/>
OOM时内存已经几乎耗尽，再加载内存dump文件并分析会导致二次OOM，得不偿失。<br/>
模拟复现OOM</p>

<p>采集用户手机内存信息的方案不可行，那么只能采取复现用户场景的方式。由于发生OOM时，用户操作路径的不确定性，无法精确复现线上的OOM，因此采取模拟复现的方式，最终发生OOM时的栈信息基本一致即可。为了能够尽量模拟用户发生OOM的场景，需要基本条件基本一致，即用户使用的手机的各种相关参数。</p>

<p>挖掘OOM特征</p>

<p>分析7.4以来的OOM，列出发生OOM的机器的特征，主要是内存和分辨率，适当考虑其它因素例如系统版本。</p>

<table>
<thead>
<tr>
<th style="text-align: center">机型</th>
<th style="text-align: center">内存</th>
<th style="text-align: center">分辨率</th>
<th style="text-align: center">OS</th>
<th style="text-align: center">stack log</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">OPPO N1(T/W)</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.2.2</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">HM 2LTE-CMCC</td>
<td style="text-align: center">1G</td>
<td style="text-align: center">1280 * 720</td>
<td style="text-align: center">4.4.4</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Newman CM810</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.4.4</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">LGL22</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1830 * 1080</td>
<td style="text-align: center">4.2.2</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">OPPO X909</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.2.2</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Lenovo K900</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.2.2</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">GiONEE E6</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.2.1</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>

<p>这些特征可以总结为：内存一般，分辨率偏高，OOM的堆栈log基本一致。其中，OPPO N1(T/W)上所发生的OOM比重较高，约为65%，因此选定这款机器作为复现OOM的机器。</p>

<h3 id="toc_1">关键数据（内存dump文件）</h3>

<p>需要复现OOM然后获取内存dump。思路是采取内存压力测试，让问题暴露的快速且充分。具体方案为：</p>

<ul>
<li>选取图片资源多且较为复杂的页面，比如美食的POI详情页。</li>
<li>加载30次该页面，为了增加OOM的几率，30个POI页面的ID是不同的。</li>
</ul>

<p>OOM发生后，使用Android Studio自带的Android Monitor dump出HPROF文件，然后使用SDK中的hprof-conv（位于sdk_root/platform-tools）工具转换为标准的Java堆转储文件格式，这样可以使用MAT（Eclipse Memory Analyzer）继续分析。</p>

<p>切到histogram视图，按shadow heap降序排列。</p>

<p>选取byte数组，右击-&gt;list objects-&gt;with incoming references，降序排列可以看到有很多大小一致的byte[]实例。</p>

<p><figure><img src="media/15561207872056/15713351847042.png" alt=""/></figure></p>

<p>右击其中一个数组-&gt;Path to GC Roots-&gt; exclude xxx references</p>

<p><figure><img src="media/15561207872056/15713351917312.png" alt=""/></figure></p>

<p>如上图所示，这些byte[]都是系统的EdgeEffect的drawable所持有，drawable对应的bitmap占用的空间为1566 * 406 * 4 = 2543184，与byte数组的大小一致。</p>

<p>再看另外一个：</p>

<p><figure><img src="media/15561207872056/15713352000259.png" alt=""/></figure></p>

<p>这些byte[]是被App的一个背景图所持有，如下图：</p>

<p><figure><img src="media/15561207872056/15713352074955.png" alt=""/></figure></p>

<p>通过ImageView的ID（如图）及build目录下的R.txt反查可知该ImageView的ID名称，即可知其设置的背景图的大小为720 * 200（xhdpi），加载到内存并考虑density，size刚好是1080 * 300 * 4 = 1296000，与byte数组大小一致。</p>

<h3 id="toc_2">数据分析</h3>

<p>为什么会出现这些大小一致的byte数组，或者说，为什么会创建多份EdgeEffect的drawable？查看EdgeEffect的源码（4.2.2）可知，其drawable成员也是通过<code>Resources.getDrawable</code>系统调用获取的。</p>

<pre class="line-numbers"><code class="language-java">/**
 * Construct a new EdgeEffect with a theme appropriate for the provided context.
 * @param context Context used to provide theming and resource information for the EdgeEffect
 */
public EdgeEffect(Context context) {
    final Resources res = context.getResources();
    mEdge = res.getDrawable(R.drawable.overscroll_edge);
    mGlow = res.getDrawable(R.drawable.overscroll_glow);

        ******

    mMinWidth = (int) (res.getDisplayMetrics().density * MIN_WIDTH + 0.5f);
    mInterpolator = new DecelerateInterpolator();
}
</code></pre>

<p>ImageView(View)获取background对应的drawable的过程类似。</p>

<pre class="line-numbers"><code class="language-text">for (int i = 0; i &lt; N; i++) {
    int attr = a.getIndex(i);
    switch (attr) {
        case com.android.internal.R.styleable.View_background:
            background = a.getDrawable(attr); // TypedArray.getDrawable
            break;
        ******
    }
}
</code></pre>

<p>不论是Resources.getDrawable还是TypedArray.getDrawable，最终都会调用Resources.loadDrawable。继续看<code>Resources.loadDrawable</code>的源码，发现的确是使用了缓存。对于同一个drawable资源，系统只会加载一次，之后都会从缓存去取。</p>

<p>既然drawable的加载机制并没有问题，那么drawable所在的缓存实例或者获取drawable的Resources实例是否是同一个呢？通过下面的代码，打印出每个Activity的Resources实例及Resources实例的drawable cache。</p>

<pre class="line-numbers"><code class="language-java">//noinspection unchecked
LongSparseArray&lt;WeakReference&lt;Drawable.ConstantState&gt;&gt; cache = (LongSparseArray&lt;WeakReference&lt;Drawable.ConstantState&gt;&gt;) Hack.into(Resources.class).field(&quot;mDrawableCache&quot;).get(getResources());
Object appCache = Hack.into(Resources.class).field(&quot;mDrawableCache&quot;).get(getApplication().getResources());
Log.e(&quot;oom&quot;, &quot;Resources: {application=&quot; + getApplication().getResources() + &quot;, activity=&quot; + getResources() + &quot;}&quot;);
Log.e(&quot;oom&quot;, &quot;Resources.mDrawableCache: {application=&quot; + appCache + &quot;, activity=&quot; + cache + &quot;}&quot;);
</code></pre>

<p><figure><img src="media/15561207872056/15713352192193.png" alt=""/></figure></p>

<p>这也进一步解释了另外一个现象，即这些大小相同的数组的个数基本和启动Activity的数量成正比。</p>

<p>通过数据分析可知，这些drawable之所以存在多份，是因为其所在的Resources实例并不是同一个。进一步debug可知，Resources实例存在多个的原因是开启了标志位<code>sCompatVectorFromResourcesEnabled</code>。<br/>
虽然最终造成OOM突然增多的原因只是开启一个标志位，但是这也告诫大家阅读API文档的重要性，其实很多时候API的使用说明已经明确告知了使用的限制条件甚至风险。</p>

<p>7.8版本关闭了此标志，发版后第一个月的OOM数量（包含历史版本）为153，如下图。</p>

<p><figure><img src="media/15561207872056/15713352268703.png" alt=""/></figure></p>

<p>其中新版本发生的OOM数量为22。</p>

<h2 id="toc_3">总结</h2>

<p>对于线上出现的OOM，如何分析和解决可以大致分为三个步骤：</p>

<ol>
<li>充分挖掘特征。在挖掘特征时，需要多方面考虑，此过程更多的是猜测怀疑，所以可能的方面都要考虑到，包括但不限于代码改动、机器特征、时间特征等，必要时还需要做一定的统计分析。</li>
<li>根据掌握的特征寻找稳定的复现的途径。一般需要做内存压力测试，这样比较容易达到OOM的临界值，只是简单的一些正常操作难以触发OOM。</li>
<li>获取可分析的数据（内存dump文件）。利用MAT分析dump文件，MAT可以方便的按照大小排序实例，可以查看某些实例到GC ROOT的路径。</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872019.html">
                
                  <h1>Android-全面解析 Application类</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Applicaiton类在 Android开发中非常常见，可是你真的了解Applicaiton类吗？<br/><br/>
本文将全面解析Applicaiton类，包括特点、方法介绍、应用场景和具体使用，希望你们会喜欢。</p>

<h2 id="toc_1">目录</h2>

<p><figure><img src="media/15561207872019/15713358440242.png" alt=""/></figure></p>

<h2 id="toc_2">定义</h2>

<ul>
<li>代表应用程序（即 Android App）的类，也属于Android中的一个系统组件</li>
<li>继承关系：继承自 ContextWarpper 类</li>
</ul>

<h2 id="toc_3">特点</h2>

<h3 id="toc_4">实例创建方式：单例模式</h3>

<ul>
<li>每个Android App运行时，会首先自动创建Application 类并实例化 Application 对象，且只有一个</li>
</ul>

<blockquote>
<p>即 Application类 是单例模式（singleton）类</p>
</blockquote>

<ul>
<li>也可通过 继承 Application 类自定义Application 类和实例</li>
</ul>

<h3 id="toc_5">实例形式：全局实例</h3>

<p>即不同的组件（如Activity、Service）都可获得Application对象且都是同一个对象</p>

<h3 id="toc_6">生命周期：等于 Android App 的生命周期</h3>

<p>Application 对象的生命周期是整个程序中最长的，即等于Android App的生命周期</p>

<h2 id="toc_7">方法介绍</h2>

<p>那么，该 Application 类有什么作用呢？下面，我将介绍Application 类的方法使用</p>

<p><figure><img src="media/15561207872019/15713358574307.png" alt=""/></figure></p>

<h3 id="toc_8">onCreate（）</h3>

<ul>
<li>调用时刻： Application 实例创建时调用</li>
</ul>

<blockquote>
<p>Android系统的入口是Application类的 onCreate（），默认为空实现</p>
</blockquote>

<ul>
<li>作用
<ul>
<li>初始化 应用程序级别 的资源，如全局对象、环境配置变量、图片资源初始化、推送服务的注册等<br/>
&gt; 注：请不要执行耗时操作，否则会拖慢应用程序启动速度</li>
<li>数据共享、数据缓存<br/>
设置全局共享数据，如全局共享变量、方法等</li>
</ul></li>
</ul>

<blockquote>
<p>注：这些共享数据只在应用程序的生命周期内有效，当该应用程序被杀死，这些数据也会被清空，所以只能存储一些具备 临时性的共享数据</p>
</blockquote>

<ul>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">// 复写方法需要在Application子类里实现

private static final String VALUE = &quot;Carson&quot;;
    // 初始化全局变量
    @Override
    public void onCreate()
    {
        super.onCreate();  
        VALUE = 1;
    }
}
</code></pre>

<h3 id="toc_9">registerComponentCallbacks（） &amp; unregisterComponentCallbacks（）</h3>

<ul>
<li>作用：注册和注销 ComponentCallbacks2回调接口</li>
</ul>

<blockquote>
<p>本质上是复写 ComponentCallbacks2回调接口里的方法从而实现更多的操作，具体下面会详细介绍</p>
</blockquote>

<ul>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">registerComponentCallbacks(new ComponentCallbacks2() {
// 接口里方法下面会继续介绍
            @Override
            public void onTrimMemory(int level) {

            }

            @Override
            public void onLowMemory() {

            }

            @Override
            public void onConfigurationChanged(Configuration newConfig) {

            }
        });
</code></pre>

<h3 id="toc_10">onTrimMemory（）</h3>

<ul>
<li>作用：通知 应用程序 当前内存使用情况（以内存级别进行识别）</li>
</ul>

<blockquote>
<p>Android 4.0 后提供的一个API</p>
</blockquote>

<p><figure><img src="media/15561207872019/15713358678777.png" alt=""/></figure></p>

<ul>
<li>应用场景：根据当前内存使用情况进行自身的内存资源的不同程度释放，以避免被系统直接杀掉 &amp; 优化应用程序的性能体验</li>
</ul>

<blockquote>
<ol>
<li>系统在内存不足时会按照LRU Cache中从低到高杀死进程；优先杀死占用内存较高的应用<br/></li>
<li>若应用占用内存较小 = 被杀死几率降低，从而快速启动（即热启动 = 启动速度快）</li>
<li>可回收的资源包括：
<ol>
<li>缓存，如文件缓存，图片缓存</li>
<li>动态生成 &amp; 添加的View</li>
</ol></li>
</ol>
</blockquote>

<p>典型的应用场景有两个：</p>

<p><figure><img src="media/15561207872019/15713358785812.png" alt=""/></figure></p>

<ul>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">registerComponentCallbacks(new ComponentCallbacks2() {

@Override
  public void onTrimMemory(int level) {

  // Android系统会根据当前内存使用的情况，传入对应的级别
  // 下面以清除缓存为例子介绍
    super.onTrimMemory(level);
  .   if (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) {

        mPendingRequests.clear();
        mBitmapHolderCache.evictAll();
        mBitmapCache.evictAll();
    }

        });
</code></pre>

<ul>
<li>可回调对象 &amp; 对应方法</li>
</ul>

<pre class="line-numbers"><code class="language-java">Application.onTrimMemory()
Activity.onTrimMemory()
Fragment.OnTrimMemory()
Service.onTrimMemory()
ContentProvider.OnTrimMemory()
</code></pre>

<p><strong>特别注意</strong>：<code>onTrimMemory()</code>中的TRIM_MEMORY_UI_HIDDEN与onStop（）的关系</p>

<ul>
<li>onTrimMemory()中的TRIM_MEMORY_UI_HIDDEN的回调时刻：当应用程序中的所有UI组件全部不可见时</li>
<li>Activity的onStop（）回调时刻：当一个Activity完全不可见的时候</li>
<li>使用建议：
<ul>
<li>在 onStop（）中释放与 Activity相关的资源，如取消网络连接或者注销广播接收器等</li>
<li>在onTrimMemory()中的TRIM_MEMORY_UI_HIDDEN中释放与UI相关的资源，从而保证用户在使用应用程序过程中，UI相关的资源不需要重新加载，从而提升响应速度</li>
</ul></li>
</ul>

<blockquote>
<p>注：onTrimMemory的TRIM_MEMORY_UI_HIDDEN等级是在onStop（）方法之前调用的</p>
</blockquote>

<h3 id="toc_11">onLowMemory（）</h3>

<ul>
<li>作用：监听 Android系统整体内存较低时刻</li>
<li>调用时刻：Android系统整体内存较低时</li>
</ul>

<pre class="line-numbers"><code class="language-java">registerComponentCallbacks(new ComponentCallbacks2() {

  @Override
            public void onLowMemory() {

            }

        });
</code></pre>

<ul>
<li>应用场景：Android 4.0前 检测内存使用情况，从而避免被系统直接杀掉 &amp; 优化应用程序的性能体验</li>
</ul>

<blockquote>
<p>类似于 OnTrimMemory（）</p>
</blockquote>

<ul>
<li>特别注意：OnTrimMemory（） &amp; OnLowMemory（） 关系
<ol>
<li>OnTrimMemory（）是 OnLowMemory（） Android 4.0后的替代 API</li>
<li>OnLowMemory（） = OnTrimMemory（）中的TRIM_MEMORY_COMPLETE级别</li>
<li>若想兼容Android 4.0前，请使用OnLowMemory（）；否则直接使用OnTrimMemory（）即可</li>
</ol></li>
</ul>

<h3 id="toc_12">onConfigurationChanged（）</h3>

<ul>
<li>作用：监听 应用程序 配置信息的改变，如屏幕旋转等</li>
<li>调用时刻：应用程序配置信息 改变时调用</li>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">registerComponentCallbacks(new ComponentCallbacks2() {

            @Override
            public void onConfigurationChanged(Configuration newConfig) {
              ...
            }

        });
</code></pre>

<ul>
<li>该配置信息是指 ：Manifest.xml文件下的 Activity标签属性android:configChanges的值，如下：</li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;activity android:name=&quot;.MainActivity&quot;&gt;
      android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;
// 设置该配置属性会使 Activity在配置改变时不重启，只执行onConfigurationChanged（）
// 上述语句表明，设置该配置属性可使 Activity 在屏幕旋转时不重启
 &lt;/activity&gt;
</code></pre>

<h3 id="toc_13">registerActivityLifecycleCallbacks（） &amp; unregisterActivityLifecycleCallbacks（）</h3>

<ul>
<li>作用：注册 / 注销对 应用程序内 所有Activity的生命周期监听</li>
<li>调用时刻：当应用程序内 Activity生命周期发生变化时就会调用</li>
</ul>

<blockquote>
<p>实际上是调用registerActivityLifecycleCallbacks（）里 ActivityLifecycleCallbacks接口里的方法</p>
</blockquote>

<ul>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">// 实际上需要复写的是ActivityLifecycleCallbacks接口里的方法
registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
            @Override
            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
                Log.d(TAG,&quot;onActivityCreated: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivityStarted(Activity activity) {
                Log.d(TAG,&quot;onActivityStarted: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivityResumed(Activity activity) {
                Log.d(TAG,&quot;onActivityResumed: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivityPaused(Activity activity) {
                Log.d(TAG,&quot;onActivityPaused: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivityStopped(Activity activity) {
                Log.d(TAG, &quot;onActivityStopped: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
            }

            @Override
            public void onActivityDestroyed(Activity activity) {
                Log.d(TAG,&quot;onActivityDestroyed: &quot; + activity.getLocalClassName());
            }
        });

&lt;-- 测试：把应用程序从前台切到后台再打开，看Activcity的变化 --&gt;
 onActivityPaused: MainActivity
 onActivityStopped: MainActivity
 onActivityStarted: MainActivity
 onActivityResumed: MainActivity
</code></pre>

<h3 id="toc_14">onTerminate（）</h3>

<p>调用时刻：应用程序结束时调用</p>

<blockquote>
<p>但该方法只用于Android仿真机测试，在Android产品机是不会调用的</p>
</blockquote>

<h2 id="toc_15">应用场景</h2>

<p>从Applicaiton类的方法可以看出，Applicaiton类的应用场景有：（已按优先级排序）</p>

<ul>
<li>初始化 应用程序级别 的资源，如全局对象、环境配置变量等</li>
<li>数据共享、数据缓存，如设置全局共享变量、方法等</li>
<li>获取应用程序当前的内存使用情况，及时释放资源，从而避免被系统杀死</li>
<li>监听 应用程序 配置信息的改变，如屏幕旋转等</li>
<li>监听应用程序内 所有Activity的生命周期</li>
</ul>

<h2 id="toc_16">具体使用</h2>

<ul>
<li>若需要复写实现上述方法，则需要自定义 Application类</li>
<li>具体过程如下</li>
</ul>

<p><strong>步骤1：新建Application子类</strong></p>

<p>即继承 Application 类</p>

<pre class="line-numbers"><code class="language-java">public class CarsonApplication extends Application
  {
    ...
    // 根据自身需求，并结合上述介绍的方法进行方法复写实现

    // 下面以onCreate()为例
  private static final String VALUE = &quot;Carson&quot;;
    // 初始化全局变量
    @Override
    public void onCreate()
    {
        super.onCreate();

        VALUE = 1;

    }

  }
</code></pre>

<p><strong>步骤2：配置自定义的Application子类</strong></p>

<p>在Manifest.xml文件中 <application>标签里进行配置</p>

<p>Manifest.xml</p>

<pre class="line-numbers"><code class="language-text">&lt;application

        android:name=&quot;.CarsonApplication&quot;
        // 此处自定义Application子类的名字 = CarsonApplication
    
&lt;/application&gt;
</code></pre>

<p><strong>步骤3：使用自定义的Application类实例</strong></p>

<pre class="line-numbers"><code class="language-java">private CarsonApplicaiton app;

// 只需要调用Activity.getApplication（） 或Context.getApplicationContext（）就可以获得一个Application对象
app = (CarsonApplication) getApplication();

// 然后再得到相应的成员变量 或方法 即可
app.exitApp();
</code></pre>

<p>至此，关于 Applicaiton 类已经讲解完毕。</p>

<h2 id="toc_17">总结</h2>

<p>我用一张图总结上述文章</p>

<p><figure><img src="media/15561207872019/15713358886403.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871979.html">
                
                  <h1>Android-过渡动画学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">概述</h2>

<p>Android 4.4.2 (API level 19)引入Transition框架，之后很多APP上都使用该框架做出很酷炫的效果，如 Google Play Newsstand app</p>

<p><figure><img src="media/15561207871979/20171105150989405862477.gif" alt=""/></figure></p>

<p>还有github上很火的plaid</p>

<p><figure><img src="media/15561207871979/20171105150989409049352.gif" alt=""/></figure></p>

<p>在app中适当得使用上Transition能带来较好的用户体验，视频中介绍了该框架的基本使用以及其中核心的一些类和方法，只有学会这些基本的API才能在之后的Activity/Fragment过渡定制一些自己想要的效果。</p>

<p>先看官网的一张关系图</p>

<p><figure><img src="media/15561207871979/15713352808456.png" alt=""/></figure></p>

<p>图中有三个核心的类，分别是Scene、Transition和TransitionManager，下面对这个三个核心类展开分析。</p>

<h3 id="toc_1">Scene</h3>

<p><figure><img src="media/15561207871979/15713352901896.png" alt=""/></figure></p>

<p>Scene场景，用于保存布局中所有View的属性值，创建Scene的方式可以通过getSceneForLayout方法</p>

<p>getSceneForLayout(ViewGroup sceneRoot, int layoutId, Context context)</p>

<p>比如：</p>

<pre class="line-numbers"><code class="language-java">mScene0 = Scene.getSceneForLayout(mSceneRoot, R.layout.scene0, getContext());
mScene1 = Scene.getSceneForLayout(mSceneRoot, R.layout.scene1, getContext());
</code></pre>

<p>也可以直接new Scene(ViewGroup sceneRoot, View layout)</p>

<pre class="line-numbers"><code class="language-java">View view0 = inflater.inflate(R.layout.scene0, container, false);
View view1 = inflater.inflate(R.layout.scene1, container, false);
mScene0 = new Scene(mSceneRoot, view0);
mScene1 = new Scene(mSceneRoot, view1);
</code></pre>

<p>两种方式都需要传SceneRoot，即该场景的根节点。</p>

<h3 id="toc_2">Transition</h3>

<p><figure><img src="media/15561207871979/15713353049060.png" alt=""/></figure></p>

<p>Transition过渡动画，前面创建了两个场景，分别保存了视图的一些属性，比如Visibility、position等，Transition就是对于这些属性值的改变定义过渡的效果。从上图可以看到系统内置了一些常用的Transition，Transition的创建可以通过加载xml，如：</p>

<p>res/transition/fade_transition.xml</p>

<p><code>&lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; /&gt;</code></p>

<p>然后在代码中：</p>

<pre class="line-numbers"><code class="language-java">Transition mFadeTransition =
        TransitionInflater.from(this).
        inflateTransition(R.transition.fade_transition);
</code></pre>

<p>或者直接在代码中：</p>

<p><code>Transition mFadeTransition = new Fade();</code></p>

<h3 id="toc_3">TransitionManager</h3>

<p>TransitionManeger用于将Scene和Transition联系起来，它提供了一系列的方法如setTransition(Scene fromScene, Scene toScene, Transition transition)指明起始场景和结束场景、他们的过渡动画是什么，go(Scene scene, Transition transition)，到指定的场景所使用的过渡动画是什么，beginDelayedTransition(ViewGroup sceneRoot, Transition transition)，在当前场景到下一帧的过渡效果是什么。比如这里使用go()方法，效果:</p>

<p><figure><img src="media/15561207871979/2017110515098942555933.gif" alt=""/></figure></p>

<p>注意这里两个Scene中红绿两个方块除了位置和大小不一样，id是一致的，transition记录下两个Scene前后属性值，根据属性值的改变执行过渡动画，默认情况下对SceneRoot下的所有View执行动画效果，我们可以通过Transition.addTarget和removeTarget方法选择性添加或移除执行动画的View。</p>

<h2 id="toc_4">常用API</h2>

<p>有时候我们只想改变当前已展示的视图层级中View的状态，可以通过beginDelayedTransition实现，下面列举系统内置的Transition的使用。</p>

<h3 id="toc_5">AutoTransition</h3>

<p>AutoTransition默认的动画效果，对应xml tag为autoTransition</p>

<p>其实是以下几个动画组合顺序执行：</p>

<pre class="line-numbers"><code class="language-text">&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:transitionOrdering=&quot;sequential&quot;&gt;
    &lt;fade android:fadingMode=&quot;fade_out&quot; /&gt;
    &lt;changeBounds /&gt;
    &lt;fade android:fadingMode=&quot;fade_in&quot; /&gt;
&lt;/transitionSet&gt;
</code></pre>

<p>在代码中使用：</p>

<pre class="line-numbers"><code class="language-java">TransitionManager.beginDelayedTransition(mRoot, new AutoTransition());
        if (mTextView.getVisibility() != View.VISIBLE) {
            mTextView.setVisibility(View.VISIBLE);
        } else {
            mTextView.setVisibility(View.GONE);
        }
</code></pre>

<p><figure><img src="media/15561207871979/20171105150989430739154.gif" alt=""/></figure></p>

<h3 id="toc_6">ChangeBounds</h3>

<p>ChangeBounds对应xml tag为changeBounds，根据前后布局界限的变化执行动画</p>

<pre class="line-numbers"><code class="language-java">TransitionManager.beginDelayedTransition(mRoot, new ChangeBounds());
FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mTarget.getLayoutParams();
if ((lp.gravity &amp; Gravity.START) == Gravity.START) {
    lp.gravity = Gravity.BOTTOM | Gravity.END;
} else {
    lp.gravity = Gravity.TOP | Gravity.START;
}
mTarget.setLayoutParams(lp);
</code></pre>

<p><figure><img src="media/15561207871979/2017110515098943515468.gif" alt=""/></figure></p>

<h3 id="toc_7">ChangeClipBounds</h3>

<p>ChangeClipBounds对应xml tag为changeClipBounds，作用对象：View的getClipBounds()值</p>

<pre class="line-numbers"><code class="language-java">Rect BOUNDS = new Rect(20, 20, 100, 100);
TransitionManager.beginDelayedTransition(mRoot, new ChangeClipBounds());
if (BOUNDS.equals(ViewCompat.getClipBounds(mImageView))) {
    ViewCompat.setClipBounds(mImageView, null);
} else {
    ViewCompat.setClipBounds(mImageView, BOUNDS);
}
</code></pre>

<p><figure><img src="media/15561207871979/20171105150989440946179.gif" alt=""/></figure></p>

<h3 id="toc_8">ChangeImageTransform</h3>

<p>对应xml tag为changeImageTransform，作用对象：ImageView的matrix</p>

<pre class="line-numbers"><code class="language-java">TransitionManager.beginDelayedTransition(mRoot, new ChangeImageTransform());
mImageView.setScaleType(ImageView.ScaleType.XXX);
</code></pre>

<p><figure><img src="media/15561207871979/2017110515098944414343.gif" alt=""/></figure></p>

<h3 id="toc_9">ChangeScroll</h3>

<p>对应xml tag为changeScroll，作用对象：View的scroll属性值</p>

<pre class="line-numbers"><code class="language-java">TransitionManager.beginDelayedTransition(mRoot, new ChangeScroll());
mTarget.scrollBy(-100, -100);
</code></pre>

<p><figure><img src="media/15561207871979/20171105150989447884273.gif" alt=""/></figure></p>

<h3 id="toc_10">ChangeTransform</h3>

<p>对应xml tag 为changeTransform，作用对象：View的scale和rotation</p>

<pre class="line-numbers"><code class="language-java">TransitionManager.beginDelayedTransition(mRoot, new ChangeTransform());
if (mContainer2.getChildCount() &gt; 0) {
    mContainer2.removeAllViews();
    showRedSquare(mContainer1);
} else {
    mContainer1.removeAllViews();
    showRedSquare(mContainer2);
    mContainer2.getChildAt(0).setRotation(45);
}
private void showRedSquare(FrameLayout container) {
        final View view = LayoutInflater.from(getContext())
                .inflate(R.layout.red_square, container, false);
        container.addView(view);
}
</code></pre>

<p><figure><img src="media/15561207871979/20171105150989451859396.gif" alt=""/></figure></p>

<h3 id="toc_11">Explode</h3>

<p>对应xml tag为explode，作用对象：View的Visibility</p>

<pre class="line-numbers"><code class="language-java">TransitionManager.beginDelayedTransition(mRoot, new Explode());
int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;
for (View view : mViews) {
    view.setVisibility(vis);
}
</code></pre>

<p><figure><img src="media/15561207871979/20171105150989454127663.gif" alt=""/></figure></p>

<h3 id="toc_12">Fade</h3>

<p>对应xml tag为fade，作用对象：View的Visibility</p>

<p>可以在初始化时指定IN或者OUT分别对应淡入和淡出，也可以通过fade.setMode方法设置，若不指定默认为淡入淡出效果</p>

<pre class="line-numbers"><code class="language-java">TransitionManager.beginDelayedTransition(mRoot, new Fade());
int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;
for (View view : mViews) {
    view.setVisibility(vis);
}
</code></pre>

<p><figure><img src="media/15561207871979/20171105150989462426664.gif" alt=""/></figure></p>

<h3 id="toc_13">Slide</h3>

<p>对应xml tag为slide，作用对象：View的Visibility</p>

<p>可以初始化时传入Gravity.XX，也可以通过slide.setSlideEdge方法设置，默认方向为Gravity.BOTTOM</p>

<pre class="line-numbers"><code class="language-java">TransitionManager.beginDelayedTransition(mRoot, new Slide());
int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;
for (View view : mViews) {
    view.setVisibility(vis);
}
</code></pre>

<p><figure><img src="media/15561207871979/20171105150989465258549.gif" alt=""/></figure></p>

<h3 id="toc_14">TransitionSet</h3>

<p>对应xml tag为transitionSet</p>

<p>可以在代码中创建transitionSet如：</p>

<pre class="line-numbers"><code class="language-java">mTransition = new TransitionSet();
mTransition.addTransition(new ChangeImageTransform());
mTransition.addTransition(new ChangeTransform());
TransitionManager.beginDelayedTransition(mOuterFrame, mTransition);
        if (mInnerFrame.getChildCount() &gt; 0) {
            mInnerFrame.removeAllViews();
            addImageView(mOuterFrame, ImageView.ScaleType.CENTER_CROP, mPhotoSize);
        } else {
            mOuterFrame.removeViewAt(1);
            addImageView(mInnerFrame, ImageView.ScaleType.FIT_XY,
                    FrameLayout.LayoutParams.MATCH_PARENT);
        }
</code></pre>

<p>也可以通过加载xml布局创建transitionSet：</p>

<p>xml布局长这样：</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:transitionOrdering=&quot;together&quot;&gt;
    &lt;changeImageTransform/&gt;
    &lt;changeTransform/&gt;
&lt;/transitionSet&gt;
</code></pre>

<p>通过transitionOrdering属性设置动画执行的顺序，together表示同时执行，sequential表示顺序执行，在代码中可以调用TransitionSet的setOrdering(int)方法，属性值传ORDERING_SEQUENTIAL或者ORDERING_TOGETHER</p>

<p>在代码中：</p>

<pre class="line-numbers"><code class="language-java">mTransition = (TransitionSet) TransitionInflater.from(getContext()).inflateTransition(R.transition.transition);
TransitionManager.beginDelayedTransition(mOuterFrame, mTransition);
        if (mInnerFrame.getChildCount() &gt; 0) {
            mInnerFrame.removeAllViews();
            addImageView(mOuterFrame, ImageView.ScaleType.CENTER_CROP, mPhotoSize);
        } else {
            mOuterFrame.removeViewAt(1);
            addImageView(mInnerFrame, ImageView.ScaleType.FIT_XY,
                    FrameLayout.LayoutParams.MATCH_PARENT);
        }
</code></pre>

<p>这里结合changeImageTransform和changeTransform，效果如下：</p>

<p><figure><img src="media/15561207871979/20171105150989470836625.gif" alt=""/></figure></p>

<h3 id="toc_15">PathMotion</h3>

<p><figure><img src="media/15561207871979/15713355623351.png" alt=""/></figure></p>

<p>Transition的辅助工具，以path的方式指定过渡效果，两个具体实现类ArcMotion和PatternPathMotion，看下ArcMotion的效果</p>

<pre class="line-numbers"><code class="language-java">mTransition = new AutoTransition();
mTransition.setPathMotion(new ArcMotion());
TransitionManager.beginDelayedTransition(mRoot, mTransition);
        FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mTarget.getLayoutParams();
        if ((lp.gravity &amp; Gravity.START) == Gravity.START) {
            lp.gravity = Gravity.END | Gravity.BOTTOM;
        } else {
            lp.gravity = Gravity.START | Gravity.TOP;
        }
        mTarget.setLayoutParams(lp);
</code></pre>

<p><figure><img src="media/15561207871979/20171105150989476785110.gif" alt=""/></figure></p>

<p>它的运动轨迹是条曲线，有兴趣的可以研究下它的实现算法，在源码中有个很萌的图如下：</p>

<p><figure><img src="media/15561207871979/15713355914588.png" alt=""/></figure></p>

<h3 id="toc_16">自定义Transition</h3>

<p>除了系统内置的Transition，我们还可以自定义Transition效果，需要继承Transition</p>

<pre class="line-numbers"><code class="language-java">public class CustomTransition extends Transition {
    @Override
    public void captureStartValues(TransitionValues values) {}
    @Override
    public void captureEndValues(TransitionValues values) {}
    @Override
    public Animator createAnimator(ViewGroup sceneRoot,
                                   TransitionValues startValues,
                                   TransitionValues endValues) {}
}
</code></pre>

<p>其工作原理是在captureStartValues和captureEndValues中分别记录View的属性值，官网建议确保属性值不冲突，属性值的命名格式参考：</p>

<p><code>package_name:transition_name:property_name</code></p>

<p>在createAnimator中创建动画，对比属性值的改变执行动画效果，如自定义修改颜色动画效果：</p>

<p><figure><img src="media/15561207871979/20171105150989483061249.gif" alt=""/></figure></p>

<p>在两个Scene中使用自定义过渡动画，效果如下：</p>

<p><figure><img src="media/15561207871979/20171105150989484813223.gif" alt=""/></figure></p>

<h2 id="toc_17">Note</h2>

<ol>
<li><p>Android 版本在4.0(API Level 14)到4.4.2(API Level 19)使用Android Support Library’s</p></li>
<li><p>对于 SurfaceView可能不起效果，因为SurfaceView的实例是在非UI线程更新的，因此会造成和其他视图动画不同步。</p></li>
<li><p>某些特定的转换类型在应用到TextureView时可能不会产生所需的动画效果。</p></li>
<li><p>继承自AdapterView的如ListView，与该框架不兼容。</p></li>
<li><p>不要对包含文本的视图的大小进行动画</p></li>
</ol>

<h2 id="toc_18">示例过渡动画</h2>

<p>在界面过渡上，Transition分为不带共享元素的Content Transition和带共享元素的ShareElement Transition。</p>

<h3 id="toc_19">Content Transition</h3>

<p>先看下content transition的一个例子，在Google Play Games上的应用：</p>

<p><figure><img src="media/15561207871979/20171105150989496665009.gif" alt=""/></figure></p>

<p>在经过学习后我们也可以设计出类似的效果，首先需要了解在界面过渡中涉及到的一些重要方法，从ActivtyA调用startActivity方法唤起ActivityB，到ActivityB按返回键返回ActivityA涉及到与Transition有关的方法</p>

<p><figure><img src="media/15561207871979/15713356682115.png" alt=""/></figure></p>

<ul>
<li>ActivityA.exitTransition()</li>
<li>ActivityB.enterTransition()</li>
</ul>

<p><figure><img src="media/15561207871979/15713356798222.png" alt=""/></figure></p>

<ul>
<li>ActivityB.returnTransition()</li>
<li>ActivityA.reenterTransition()</li>
</ul>

<p>因此，只要我们在对应的方法中设置了Transition就可以了。在默认没有设置对应Transition的情况下，Material-theme应用的exitTransition为null，enterTransition为Fade，如果reenterTransition和returnTransition未设定，则分别对应exitTransition和enterTransition。</p>

<h4 id="toc_20">使用</h4>

<p>在style中添加<code>android:windowContentTransitions</code> 属性启用窗口内容转换(Material-theme应用默认为true)，指定该Activity的Transition</p>

<pre class="line-numbers"><code class="language-text">&lt;!-- Base application theme. --&gt;
&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;
    &lt;!-- enable window content transitions --&gt;
    &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;

    &lt;!-- specify enter and exit transitions --&gt;
    &lt;!-- options are: explode, slide, fade --&gt;
    &lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/change_image_transform&lt;/item&gt;
    &lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/change_image_transform&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>也可以在代码中指定</p>

<pre class="line-numbers"><code class="language-text">// inside your activity (if you did not enable transitions in your theme)
getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);
// set an enter transition
getWindow().setEnterTransition(new Explode());
// set an exit transition
getWindow().setExitTransition(new Explode());
</code></pre>

<p>然后启动Acticity</p>

<pre class="line-numbers"><code class="language-text">startActivity(intent,
              ActivityOptions.makeSceneTransitionAnimation(this).toBundle());
</code></pre>

<h4 id="toc_21">例子</h4>

<p>这里在代码中指定ActivityA的exitTransition:</p>

<pre class="line-numbers"><code class="language-text">private void setupTransition() {
        Slide slide = new Slide(Gravity.LEFT);
        slide.setDuration(1000);
        slide.setInterpolator(new FastOutSlowInInterpolator());
        getWindow().setExitTransition(slide);
    }
</code></pre>

<p>使用xml方式指定ActivityB的enterTransition：</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;slide
        android:duration=&quot;1000&quot;
        android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;
        android:slideEdge=&quot;bottom&quot;&gt;
        &lt;targets&gt;
            &lt;target android:targetId=&quot;@id/content_container&quot;/&gt;
        &lt;/targets&gt;
    &lt;/slide&gt;
    &lt;slide
        android:duration=&quot;1000&quot;
        android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;
        android:slideEdge=&quot;top&quot;&gt;
        &lt;targets&gt;
            &lt;target android:targetId=&quot;@id/image_container&quot;/&gt;
        &lt;/targets&gt;
    &lt;/slide&gt;
&lt;/transitionSet&gt;
</code></pre>

<p>运行效果如下：</p>

<p><figure><img src="media/15561207871979/20171105150989524969946.gif" alt=""/></figure></p>

<p>上图动画有两个问题:</p>

<ol>
<li>ActivityA的exitTransition还没完全走完ActivityB的enterTransition就执行了，ActivityB的returnTransition还没完全走完ActivityA的reenterTransition就执行了；</li>
<li>状态栏和导航栏的动画不太协调;</li>
</ol>

<p>问题1是因为默认情况下enter/return transition会比exit/reenter transition完全结束前稍微快一点运行，如果想让前者完全运行完后者再进来，可以在代码中调用Window的</p>

<pre class="line-numbers"><code class="language-text">setWindowAllowEnterTransitionOverlap(false)
setWindowAllowReturnTransitionOverlap(false)
</code></pre>

<p>或者在xml中设置</p>

<pre class="line-numbers"><code class="language-text">&lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;false&lt;/item&gt; 
&lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;false&lt;/item&gt;
</code></pre>

<p>运行如下：</p>

<p><figure><img src="media/15561207871979/20171105150989532889905.gif" alt=""/></figure></p>

<p>再看下问题2，默认情况下状态栏和标题栏也会参与动画(如果有导航栏也会，测试机默认木有导航栏)，当我们把xxxoverlap属性设为false后就看得比较明显了，如果不想让它们参与动画通过excludeTarget()将其排除，在代码中：</p>

<pre class="line-numbers"><code class="language-java">private void setupTransition() {
    Slide slide = new Slide(Gravity.LEFT);
    slide.setDuration(1000);
    slide.setInterpolator(new FastOutSlowInInterpolator());
    slide.excludeTarget(android.R.id.statusBarBackground, true);
    slide.excludeTarget(android.R.id.navigationBarBackground, true);
    slide.excludeTarget(R.id.appbar,true);
    getWindow().setExitTransition(slide);
}
</code></pre>

<p>或者在xml中：</p>

<pre class="line-numbers"><code class="language-text">&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:slideEdge=&quot;left&quot;
    android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;
    android:duration=&quot;1000&quot;&gt;

    &lt;targets&gt;
        &lt;!-- if using a custom Toolbar container, specify the ID of the AppBarLayout --&gt;
        &lt;target android:excludeId=&quot;@id/appbar&quot; /&gt;
        &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot;/&gt;
        &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot;/&gt;
    &lt;/targets&gt;

&lt;/slide&gt;
</code></pre>

<p>效果如下：</p>

<p><figure><img src="media/15561207871979/2017110515098956444650.gif" alt=""/></figure></p>

<h4 id="toc_22">具体流程</h4>

<p>ActivityA startActivity()</p>

<ol>
<li>确定需要执行exit Transition的target View</li>
<li>Transition的captureStartValues()获取target View Visibility的值(此时为VISIBLE)</li>
<li>将target View Visibility的值设为INVISIBLE</li>
<li>Transition的captureEndValues()获取target View Visibility的值(此时为INVISIBLE)</li>
<li>Transition的createAnimator()根据前后Visibility的属性值变化创建动画</li>
</ol>

<p>ActivityB Activity 开始</p>

<ol>
<li>确定需要执行enter Transition的target View</li>
<li>Transition的captureStartValues()获取获取target View Visibility的，初始化为INVISIBLE</li>
<li>将target View Visibility的值设为VISIBLE</li>
<li>Transition的captureEndValues()获取target View Visibility的值(此时为VISIBLE)</li>
<li>Transition的createAnimator()根据前后Visibility的属性值变化创建动画</li>
</ol>

<h3 id="toc_23">ShareElement Transition</h3>

<p>shareElement Transition的例子</p>

<p><figure><img src="media/15561207871979/20171105150989573322645.gif" alt=""/></figure></p>

<p>shareElement Transition指的是共享元素从activity/fragment到其他activity/fragment时的动画</p>

<p><figure><img src="media/15561207871979/15713357845915.png" alt=""/></figure></p>

<p>有了上面的分析看名字应该也猜得出方法对应的功能了，如果没有设置exit/enter shared element transitions，默认为 @android:transition/move，上面的Content Transition是根据Visibility的变化创建动画，而shareElement Transition是根据大小，位置，和外观的变化创建动画，如chanageBounds、changeTransform、ChangeClipBounds、 ChangeImageTransform等，具体API使用和效果可以参考上篇。指定shareElement Transition可以通过代码形式：</p>

<pre class="line-numbers"><code class="language-text">getWindow().setSharedElementEnterTransition();
getWindow().setSharedElementExitTransition();
getWindow().setSharedElementReturnTransition();
getWindow().setSharedElementReenterTransition();
</code></pre>

<p>也可以通过xml形式：</p>

<pre class="line-numbers"><code class="language-text">&lt;!-- Base application theme. --&gt;
&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;
    &lt;!-- specify shared element transitions --&gt;
    &lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt;
      @transition/change_image_transform&lt;/item&gt;
    &lt;item name=&quot;android:windowSharedElementExitTransition&quot;&gt;
      @transition/change_image_transform&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>然后启动Acticity</p>

<pre class="line-numbers"><code class="language-text">Intent intent = new Intent(this, DetailsActivity.class);
// Pass data object in the bundle and populate details activity.
intent.putExtra(DetailsActivity.EXTRA_CONTACT, contact);
ActivityOptionsCompat options = ActivityOptionsCompat.
    makeSceneTransitionAnimation(this, (View)ivProfile, &quot;profile&quot;);
startActivity(intent, options.toBundle());
</code></pre>

<p>在布局文件中对于要共享的View添加android:transitionName且保持一致，如果要共享的View有点多，可以通过Pair，Pair<View,String> 存储着共享View和View的名称，使用如下</p>

<pre class="line-numbers"><code class="language-text">Intent intent = new Intent(context, DetailsActivity.class);
intent.putExtra(DetailsActivity.EXTRA_CONTACT, contact);
Pair&lt;View, String&gt; p1 = Pair.create((View)ivProfile, &quot;profile&quot;);
Pair&lt;View, String&gt; p2 = Pair.create(vPalette, &quot;palette&quot;);
Pair&lt;View, String&gt; p3 = Pair.create((View)tvName, &quot;text&quot;);
ActivityOptionsCompat options = ActivityOptionsCompat.
    makeSceneTransitionAnimation(this, p1, p2, p3);
startActivity(intent, options.toBundle());
</code></pre>

<h4 id="toc_24">例子</h4>

<p>在ActivityB的theme中添加SharedElementEnterTransition</p>

<pre class="line-numbers"><code class="language-text">&lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt;
@transition/change_image_transform
&lt;/item&gt;
</code></pre>

<p>change_image_transform.xml</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;changeBounds
        android:duration=&quot;1000&quot;
        android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;/&gt;
    &lt;changeImageTransform
        android:duration=&quot;1000&quot;
        android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;/&gt;
&lt;/transitionSet&gt;
</code></pre>

<p>执行效果：</p>

<p><figure><img src="media/15561207871979/20171105150989590151493.gif" alt=""/></figure></p>

<h3 id="toc_25">具体流程</h3>

<p>从图上看，好像图片是从一个ActivityA&quot;传递&quot;到另一个ActivityB，实际上真正负责绘制都发生在ActivityB上：</p>

<ol>
<li>ActivityA调用startActivity()后ActivityB处于透明状态</li>
<li>Transition收集ActivityA中共享View的初识状态，并传递给ActivityB</li>
<li>Transition收集ActivityB中共享View的最终状态</li>
<li>Transition根据状态改变创建动画</li>
<li>Transition隐藏ActivityA，随着ActivityB的共享View运动到指定位置，ActivityB的背景在ActivityA上淡入，并随着动画完成而完全可见。</li>
</ol>

<p>我们可以通过修改Activity背景淡入淡出时间来验证，在ActivityB中加入</p>

<p><code>getWindow().setTransitionBackgroundFadeDuration(2000);</code></p>

<p>为了更直观，把ActivityA的exitTransition先注释掉，运行效果：</p>

<p><figure><img src="media/15561207871979/20171105150989597967932.gif" alt=""/></figure></p>

<p>可以看到，ActivityB确实像盖在ActivityA上，这里用到了 ViewOverlay，原理简单来说就是在其他View上draw，共享View利用该技术可以实现画在其他View上。我们可以通过Window的setSharedElementsUseOverlay(false)来关闭该功能，不过这样一来会使最终结果和你预想的不一致，默认该值为true。</p>

<h3 id="toc_26">延迟加载</h3>

<p>上面分析Transition会获取共享视图前后的状态值来创建动画，如果我们的图片是网上下载的，那么很有可能图片的准确大小需要下载下来才能确定，Activity Transitions API提供了一对方法暂时推迟过渡，直到我们确切地知道共享元素已经被适当的渲染和放置。在onCreate中调用postponeEnterTransition()(API &gt;= 21)或者supportPostponeEnterTransition()（API &lt; 21）延迟过渡；当图片的状态确定后，调用startPostponedEnterTransition()（API &gt;= 21）或supportStartPostponedEnterTransition()（API &lt; 21）恢复过渡，常见处理：</p>

<pre class="line-numbers"><code class="language-text">// ... load remote image with Glide/Picasso here

supportPostponeEnterTransition();
ivBackdrop.getViewTreeObserver().addOnPreDrawListener(
    new ViewTreeObserver.OnPreDrawListener() {
        @Override
        public boolean onPreDraw() {
            ivBackdrop.getViewTreeObserver().removeOnPreDrawListener(this);
            supportStartPostponedEnterTransition();
            return true;
        }
    }
);
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871939.html">
                
                  <h1>Android-底部Tab菜单栏</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android开发中使用底部菜单栏的频次非常高，主要的实现手段有以下：</p>

<ul>
<li>TabWidget</li>
<li>隐藏TabWidget，使用RadioGroup和RadioButton</li>
<li>FragmentTabHost</li>
<li>5.0以后的TabLayout</li>
<li>最近推出的 Bottom navigation</li>
</ul>

<p>今天带大家来探索下如何用Fragment+FragmentTabHost++ViewPager<br/>
实现底部菜单栏</p>

<h2 id="toc_1">总体设计思路</h2>

<ul>
<li>Fragment：存放不同选项的页面内容</li>
<li>FragmentTabHost：点击切换选项卡</li>
<li>ViewPager：实现页面的左右滑动效果</li>
</ul>

<h2 id="toc_2">概念介绍</h2>

<h3 id="toc_3">FragmentTabHost</h3>

<p>用于实现点击选项进行切换选项卡的自定义效果</p>

<blockquote>
<p>使用FragmentTabHost，就是先用TabHost“装着”Fragment，然后放进MainActivity里面</p>
</blockquote>

<h3 id="toc_4">ViewPager</h3>

<ul>
<li>定义<br/>
ViewPager是android扩展包v4包中的类</li>
</ul>

<p><code>android.support.v4.view.ViewPager</code></p>

<ul>
<li>作用<br/>
左右切换当前的view，实现滑动切换的效果。</li>
</ul>

<blockquote>
<p>注：<br/><br/>
1.ViewPager类直接继承了ViewGroup类，和LinearLayout等布局一样，都是一个容器，需要在里面添加我们想要显示的内容。<br/><br/>
2.ViewPager类需要PagerAdapter适配器类提供数据，与ListView类似<br/><br/>
3.Google官方建议ViewPager配合Fragment使用   </p>
</blockquote>

<h3 id="toc_5">Fragment</h3>

<ul>
<li>定义<br/>
Fragment是activity的界面中的一部分或一种行为</li>
</ul>

<blockquote>
<p>1.把Fragment认为模块化的一段activity<br/><br/>
2.它具有自己的生命周期，接收它自己的事件，并可以在activity运行时被添加或删除<br/><br/>
3.Fragment不能独立存在，它必须嵌入到activity中，而且Fragment的生命周期直接受所在的activity的影响。例如：当activity暂停时，它拥有的所有的Fragment们都暂停了，当activity销毁时，它拥有的所有Fragment们都被销毁。  </p>
</blockquote>

<ul>
<li>作用<br/>
主要是为了支持更动态、更灵活的界面设计（从3.0开始引入）</li>
</ul>

<h2 id="toc_6">实现步骤</h2>

<ol>
<li>在主xml布局里面定义一个FragmentTabHost控件</li>
<li>定义底部菜单栏布局</li>
<li>定义每个Fragment布局</li>
<li>定义每个Fragment的Java类</li>
<li>定义适配器以关联页卡和ViewPage</li>
<li>定义MainActivity（具体实现请看注释）</li>
</ol>

<h2 id="toc_7">工程文件目录</h2>

<p><figure><img src="media/15561207871939/15713359310114.png" alt=""/></figure></p>

<h2 id="toc_8">具体实现实例</h2>

<h3 id="toc_9">步骤1：在主xml布局里面定义一个FragmentTabHost控件</h3>

<p>主xml布局：<strong>Main_tab_layout.xml</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;fill_parent&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;include layout=&quot;@layout/main_top&quot; /&gt;

    &lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/pager&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot; /&gt;&lt;!--装4个Fragment--&gt;

    &lt;FrameLayout
        android:visibility=&quot;gone&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot; /&gt;

    &lt;!--定义FragmentTabHost控件--&gt;
    &lt;android.support.v4.app.FragmentTabHost
        android:id=&quot;@android:id/tabhost&quot;
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:background=&quot;@android:color/black&quot; &gt;&lt;!--装4个Fragment--&gt;

        &lt;FrameLayout
            android:id=&quot;@android:id/tabcontent&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;0dp&quot;
            android:layout_weight=&quot;0&quot; /&gt;&lt;!--装Tab的内容--&gt;
    &lt;/android.support.v4.app.FragmentTabHost&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<h3 id="toc_10">步骤2：定义底部菜单栏布局</h3>

<p><strong>tab_content.xml</strong></p>

<p>一般是图片在上，文字在下</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    
android:layout_width=&quot;match_parent&quot;    
android:layout_height=&quot;match_parent&quot;    
android:gravity=&quot;center&quot;   
android:orientation=&quot;vertical&quot;    
android:background=&quot;#ffffff&quot;&gt;    
&lt;ImageView        
android:id=&quot;@+id/tab_imageview&quot;        
android:layout_width=&quot;wrap_content&quot;        
android:layout_height=&quot;wrap_content&quot;        
/&gt;    
&lt;TextView        
android:id=&quot;@+id/tab_textview&quot;        
android:layout_width=&quot;wrap_content&quot;        
android:layout_height=&quot;wrap_content&quot;        
android:text=&quot;&quot;        
android:textColor=&quot;@drawable/selector_text_background&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<h3 id="toc_11">步骤3：定义Fragment布局</h3>

<p>fragment_item1.xml&amp;fragment_item2.xml</p>

<blockquote>
<p>这里使用两个选项，由于fragment_item1.xml与fragment_item2.xml相同，这里只贴出一个</p>
</blockquote>

<p><strong>fragment_item1.xml</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/textView1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;fragment1&quot;
        android:textSize=&quot;20sp&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre>

<h3 id="toc_12">步骤4： 定义每个Fragment的Java类</h3>

<blockquote>
<p>1.这里使用两个选项：Fragment1.java&amp;fragmen2.java<br/><br/>
2.由于Fragment1.java&amp;fragmen2.java相同，这里只贴出一个</p>
</blockquote>

<p><strong>Fragment1.java</strong></p>

<pre class="line-numbers"><code class="language-java">package com.example.carson_ho.tab_menu_demo;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

/**
 * Created by Carson_Ho on 16/5/23.
 */
public class Fragment1 extends Fragment

    {
        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_item1, null);
        return view;
    }
}
</code></pre>

<h3 id="toc_13">步骤5： 定义适配器关联页卡和ViewPage</h3>

<p><strong>MyFragmentAdapter.java</strong></p>

<pre class="line-numbers"><code class="language-java">package com.example.carson_ho.tab_menu_demo;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;

import java.util.List;

/**
 * Created by Carson_Ho on 16/5/23.
 */
public class MyFragmentAdapter {extends FragmentPagerAdapter

    {

        List&lt;Fragment&gt; list;



        public MyFragmentAdapter(FragmentManager fm,List&lt;Fragment&gt; list) {
        super(fm);
        this.list=list;
    }//写构造方法，方便赋值调用
        @Override
        public Fragment getItem(int arg0) {
        return list.get(arg0);
    }//根据Item的位置返回对应位置的Fragment，绑定item和Fragment

        @Override
        public int getCount() {
        return list.size();
    }//设置Item的数量

    }
</code></pre>

<h3 id="toc_14">步骤6： 定义MainActivity</h3>

<p>具体实现看注释<br/><br/>
<strong>MainActivity.java</strong></p>

<pre class="line-numbers"><code class="language-text">package com.example.carson_ho.tab_menu_demo;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentTabHost;
import android.support.v4.view.ViewPager;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TabHost;
import android.widget.TabWidget;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.List;

public class MainActivity extends FragmentActivity implements
        ViewPager.OnPageChangeListener, TabHost.OnTabChangeListener {

    private FragmentTabHost mTabHost;
    private LayoutInflater layoutInflater;
    private Class fragmentArray[] = { Fragment1.class, Fragment2.class };
    private int imageViewArray[] = { R.drawable.tab_home_btn, R.drawable.tab_view_btn };
    private String textViewArray[] = { &quot;首页&quot;, &quot;分类&quot;};
    private List&lt;Fragment&gt; list = new ArrayList&lt;Fragment&gt;();
    private ViewPager vp;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();//初始化控件
        initPage();//初始化页面
    }

    //    控件初始化控件
    private void initView() {
        vp = (ViewPager) findViewById(R.id.pager);

        /*实现OnPageChangeListener接口,目的是监听Tab选项卡的变化，然后通知ViewPager适配器切换界面*/
        /*简单来说,是为了让ViewPager滑动的时候能够带着底部菜单联动*/

        vp.addOnPageChangeListener(this);//设置页面切换时的监听器
        layoutInflater = LayoutInflater.from(this);//加载布局管理器

        /*实例化FragmentTabHost对象并进行绑定*/
        mTabHost = (FragmentTabHost) findViewById(android.R.id.tabhost);//绑定tahost
        mTabHost.setup(this, getSupportFragmentManager(), R.id.pager);//绑定viewpager

        /*实现setOnTabChangedListener接口,目的是为监听界面切换），然后实现TabHost里面图片文字的选中状态切换*/
        /*简单来说,是为了当点击下面菜单时,上面的ViewPager能滑动到对应的Fragment*/
        mTabHost.setOnTabChangedListener(this);

        int count = textViewArray.length;

        /*新建Tabspec选项卡并设置Tab菜单栏的内容和绑定对应的Fragment*/
        for (int i = 0; i &lt; count; i++) {
            // 给每个Tab按钮设置标签、图标和文字
            TabHost.TabSpec tabSpec = mTabHost.newTabSpec(textViewArray[i])
                    .setIndicator(getTabItemView(i));
            // 将Tab按钮添加进Tab选项卡中，并绑定Fragment
            mTabHost.addTab(tabSpec, fragmentArray[i], null);
            mTabHost.setTag(i);
            mTabHost.getTabWidget().getChildAt(i)
                    .setBackgroundResource(R.drawable.selector_tab_background);//设置Tab被选中的时候颜色改变
        }
    }

    /*初始化Fragment*/
    private void initPage() {
        Fragment1 fragment1 = new Fragment1();
        Fragment2 fragment2 = new Fragment2();

        list.add(fragment1);
        list.add(fragment2);

        //绑定Fragment适配器
        vp.setAdapter(new MyFragmentAdapter(getSupportFragmentManager(), list));
        mTabHost.getTabWidget().setDividerDrawable(null);
    }

    private View getTabItemView(int i) {
        //将xml布局转换为view对象
        View view = layoutInflater.inflate(R.layout.tab_content, null);
        //利用view对象，找到布局中的组件,并设置内容，然后返回视图
        ImageView mImageView = (ImageView) view
                .findViewById(R.id.tab_imageview);
        TextView mTextView = (TextView) view.findViewById(R.id.tab_textview);
        mImageView.setBackgroundResource(imageViewArray[i]);
        mTextView.setText(textViewArray[i]);
        return view;
    }


    @Override
    public void onPageScrollStateChanged(int arg0) {

    }//arg0 ==1的时候表示正在滑动，arg0==2的时候表示滑动完毕了，arg0==0的时候表示什么都没做，就是停在那。

    @Override
    public void onPageScrolled(int arg0, float arg1, int arg2) {

    }//表示在前一个页面滑动到后一个页面的时候，在前一个页面滑动前调用的方法

    @Override
    public void onPageSelected(int arg0) {//arg0是表示你当前选中的页面位置Postion，这事件是在你页面跳转完毕的时候调用的。
        TabWidget widget = mTabHost.getTabWidget();
        int oldFocusability = widget.getDescendantFocusability();
        widget.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);//设置View覆盖子类控件而直接获得焦点
        mTabHost.setCurrentTab(arg0);//根据位置Postion设置当前的Tab
        widget.setDescendantFocusability(oldFocusability);//设置取消分割线

    }

    @Override
    public void onTabChanged(String tabId) {//Tab改变的时候调用
        int position = mTabHost.getCurrentTab();
        vp.setCurrentItem(position);//把选中的Tab的位置赋给适配器，让它控制页面切换
    }

}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871903.html">
                
                  <h1>Java-你应该知道的JDK知识</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>无论是从事Javaee开发或者是Android开发，JDK的基础知识都尤为重要。我们在代码里经常使用ArrayList、HashMap等，但却很少思考为什么是使用它，使用的时候需要注意什么。甚至有可能去面试的时候，人家一问HashMap的实现原理，但却只知道put和get，非常尴尬。</p>

<p>所以为了开发更高质量的程序，写出更优秀的代码，还是需要好好研究一下JDK的一些关键源码。本文主要对JDK进行一些重要的的知识的梳理及整理，便于学习及复习。</p>

<h2 id="toc_1">基础知识</h2>

<h3 id="toc_2">基础数据类型</h3>

<p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。<br/>
内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据</p>

<table>
<thead>
<tr>
<th style="text-align: center">类型</th>
<th style="text-align: center">位</th>
<th style="text-align: center">默认值</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">byte</td>
<td style="text-align: center">8(1字节)</td>
<td style="text-align: center">0</td>
</tr>
<tr>
<td style="text-align: center">short</td>
<td style="text-align: center">16(2字节)</td>
<td style="text-align: center">0</td>
</tr>
<tr>
<td style="text-align: center">int</td>
<td style="text-align: center">32(4字节)</td>
<td style="text-align: center">0</td>
</tr>
<tr>
<td style="text-align: center">long</td>
<td style="text-align: center">64(8字节)</td>
<td style="text-align: center">0L</td>
</tr>
<tr>
<td style="text-align: center">float</td>
<td style="text-align: center">32(4字节)</td>
<td style="text-align: center">0.0f</td>
</tr>
<tr>
<td style="text-align: center">double</td>
<td style="text-align: center">64(8字节)</td>
<td style="text-align: center">0.0d</td>
</tr>
<tr>
<td style="text-align: center">boolean</td>
<td style="text-align: center">1</td>
<td style="text-align: center">false</td>
</tr>
<tr>
<td style="text-align: center">char</td>
<td style="text-align: center">16 位 Unicode 字符</td>
<td style="text-align: center">“”</td>
</tr>
</tbody>
</table>

<h3 id="toc_3">equal hashcode ==的区别</h3>

<table>
<thead>
<tr>
<th style="text-align: center">==</th>
<th style="text-align: center">内存地址比较</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">equal</td>
<td style="text-align: center">Object默认内存地址比较，一般需要复写</td>
</tr>
<tr>
<td style="text-align: center">hashcode</td>
<td style="text-align: center">主要用于集合的散列表，Object默认为内存地址，一般不用设置，除非作用于散列集合。</td>
</tr>
</tbody>
</table>

<p>hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。当equals方法被重写时，通常有必要重写 hashCode 方法。但hashCode相等，不一定equals（）</p>

<h3 id="toc_4">String、StringBuffer与StringBuilder的区别。</h3>

<p>Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBulder类表示的字符串对象可以直接进行修改。StringBuilder是JDK1.5引入的，它和StringBuffer的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。</p>

<h3 id="toc_5">Java的四种引用，强弱软虚，用到的场景。</h3>

<p>JDK1.2之前只有强引用,其他几种引用都是在JDK1.2之后引入的.</p>

<p>强引用（Strong Reference） 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。</p>

<p>软引用（Soft Reference） 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。 当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null</p>

<p>弱引用（Weak Reference） 发生GC时必定回收弱引用指向的内存空间。 和软引用加入队列的时机相同</p>

<p>虚引用（Phantom Reference) 又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。 当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了. 虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有</p>

<h2 id="toc_6">Java集合框架</h2>

<p><figure><img src="media/15561207871903/15713359506284.png" alt=""/></figure></p>

<p>Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p>

<p>List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</p>

<p>Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。 我们看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。</p>

<p>Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。</p>

<p>Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。</p>

<p>Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。</p>

<h3 id="toc_7">Collection List Set Map 区别</h3>

<table>
<thead>
<tr>
<th style="text-align: center">接口</th>
<th style="text-align: center">是否有序</th>
<th style="text-align: center">允许元素重复</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">collection</td>
<td style="text-align: center">否</td>
<td style="text-align: center">是</td>
</tr>
<tr>
<td style="text-align: center">List</td>
<td style="text-align: center">是</td>
<td style="text-align: center">是</td>
</tr>
<tr>
<td style="text-align: center">AbstractSet</td>
<td style="text-align: center">否</td>
<td style="text-align: center">否</td>
</tr>
<tr>
<td style="text-align: center">HashSet</td>
<td style="text-align: center">否</td>
<td style="text-align: center">否</td>
</tr>
<tr>
<td style="text-align: center">TreeSet</td>
<td style="text-align: center">是（用二叉树排序）</td>
<td style="text-align: center">否</td>
</tr>
<tr>
<td style="text-align: center">AbstractMap</td>
<td style="text-align: center">否</td>
<td style="text-align: center">使用 key-value 来映射和存储数据， Key 必须惟一， value 可以重复</td>
</tr>
<tr>
<td style="text-align: center">HashMap</td>
<td style="text-align: center">否</td>
<td style="text-align: center">使用 key-value 来映射和存储数据， Key 必须惟一， value 可以重复</td>
</tr>
<tr>
<td style="text-align: center">TreeMap</td>
<td style="text-align: center">是（用二叉树排序）</td>
<td style="text-align: center">使用 key-value 来映射和存储数据， Key 必须惟一， value</td>
</tr>
</tbody>
</table>

<h3 id="toc_8">常用集合分析</h3>

<table>
<thead>
<tr>
<th style="text-align: center">集合</th>
<th style="text-align: center">主要算法</th>
<th style="text-align: center">源码分析</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">ArrayList</td>
<td style="text-align: center">基于数组的List，封装了动态增长的Object[] 数组</td>
<td style="text-align: center"><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-ArrayList%E3%80%81Vector/">链接</a></td>
</tr>
<tr>
<td style="text-align: center">Stack</td>
<td style="text-align: center">是Vector 的子类，栈 的结构（后进先出）</td>
<td style="text-align: center"><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-Stack/">链接</a></td>
</tr>
<tr>
<td style="text-align: center">LinkedList</td>
<td style="text-align: center">实现List，Deque；实现List，可以进行队列操作，可以通过索引来随机访问集合元素；实现Deque，也可当作双端队列，也可当作栈来使用</td>
<td style="text-align: center"><a href="http://huangjunbin.com/2016/11/14/%E7%BA%BF%E6%80%A7%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-LinkedList/">链接</a></td>
</tr>
<tr>
<td style="text-align: center">HashMap</td>
<td style="text-align: center">基于哈希表的 Map 接口的实现, 使用顺序存储及链式存储的结构</td>
<td style="text-align: center"><a href="http://huangjunbin.com/2016/11/24/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%B8%8E%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E9%9B%86%E5%90%88-HashMap%E3%80%81HashTable/">链接</a></td>
</tr>
<tr>
<td style="text-align: center">LinkedHashMap</td>
<td style="text-align: center">LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同</td>
<td style="text-align: center"><a href="https://github.com/francistao/LearningNotes/blob/master/Part2/JavaSE/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.md">链接</a></td>
</tr>
<tr>
<td style="text-align: center">TreeMap</td>
<td style="text-align: center">TreeMap的实现是红黑树算法的实现，支持排序</td>
<td style="text-align: center"><a href="http://blog.csdn.net/chenssy/article/details/26668941">链接</a></td>
</tr>
</tbody>
</table>

<h2 id="toc_9">并发</h2>

<h3 id="toc_10">Lists</h3>

<ul>
<li>ArrayList——基于泛型数组</li>
<li>LinkedList——不推荐使用</li>
<li>Vector——已废弃（deprecated）</li>
<li>CopyOnWriteArrayList——几乎不更新，常用来遍历</li>
</ul>

<h3 id="toc_11">Queues / deques</h3>

<ul>
<li>ArrayDeque——基于泛型数组</li>
<li>Stack——已废弃（deprecated）</li>
<li>PriorityQueue——读取操作的内容已排序</li>
<li>ArrayBlockingQueue——带边界的阻塞式队列</li>
<li>ConcurrentLinkedDeque / ConcurrentLinkedQueue——无边界的链表队列（CAS）</li>
<li>DelayQueue——元素带有延迟的队列</li>
<li>LinkedBlockingDeque / LinkedBlockingQueue——链表队列（带锁），可设定是否带边界</li>
<li>LinkedTransferQueue——可将元素transfer进行w/o存储</li>
<li>PriorityBlockingQueue——并发PriorityQueue</li>
<li>SynchronousQueue——使用Queue接口进行Exchanger</li>
</ul>

<h3 id="toc_12">Maps</h3>

<ul>
<li>HashMap——通用Map</li>
<li>EnumMap——键使用enum</li>
<li>Hashtable——已废弃（deprecated）</li>
<li>IdentityHashMap——键使用==进行比较</li>
<li>LinkedHashMap——保持插入顺序</li>
<li>TreeMap——键已排序</li>
<li>WeakHashMap——适用于缓存（cache）</li>
<li>ConcurrentHashMap——通用并发Map</li>
<li>ConcurrentSkipListMap——已排序的并发Map</li>
</ul>

<h3 id="toc_13">Sets</h3>

<ul>
<li>HashSet——通用set</li>
<li>EnumSet——enum Set</li>
<li>BitSet——比特或密集的整数Set</li>
<li>LinkedHashSet——保持插入顺序</li>
<li>TreeSet——排序Set</li>
<li>ConcurrentSkipListSet——排序并发Set</li>
<li>CopyOnWriteArraySet——几乎不更新，通常只做遍历</li>
</ul>

<h2 id="toc_14">总结</h2>

<h3 id="toc_15">Set的选择</h3>

<ol>
<li>HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet</li>
<li>对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快</li>
<li>EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</li>
<li>HashSet、TreeSet、EnumSet都是&quot;线程不安全&quot;的，通常可以通过Collections工具类的synchronizedSortedSet方法来&quot;包装&quot;该Set集合。<br/>
SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));</li>
</ol>

<h3 id="toc_16">List 选择</h3>

<ol>
<li>java提供的List就是一个&quot;线性表接口&quot;，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现</li>
<li>Queue代表了队列，Deque代表了双端队列(既可以作为队列使用、也可以作为栈使用)</li>
<li>因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。</li>
<li>内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能</li>
<li>进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好</li>
<li>当要大量的插入，删除，应当选用LinkedList；当需要快速随机访问则选用ArrayList;</li>
</ol>

<h3 id="toc_17">Map 的选择</h3>

<ol>
<li>HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制</li>
<li>TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对</li>
<li>使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作</li>
<li>HahMap 是利用hashCode 进行查找，而TreeMap 是保持者某种有序状态</li>
<li>所以，插入，删除，定位操作时，HashMap 是最好的选择；如果要按照自然排序或者自定义排序，那么就选择TreeMap</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871867.html">
                
                  <h1>Android-粒子变幻、隧道散列、组合文字</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">效果视频 &amp; 图片</h2>

<h3 id="toc_1">第一个视频，无散列</h3>

<p><figure><img src="media/15561207871867/20171105150982542062457.gif" alt=""/></figure></p>

<h3 id="toc_2">第二个视频，具备散列</h3>

<p><figure><img src="media/15561207871867/20171105150982545476983.gif" alt=""/></figure></p>

<p><figure><img src="media/15561207871867/15713656610386.png" alt=""/></figure></p>

<p><figure><img src="media/15561207871867/15713656692040.png" alt=""/></figure></p>

<h2 id="toc_3">概述</h2>

<p>跟随早前开源的 XView (<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faf913337456%2FXView">github.com/af913337456…</a>) 项目，本次在原基础上添加了 粒子变幻 自定义View。目前我在代码里面的设置它可以做到：</p>

<ol>
<li>根据你输入文字，将被粒子组合而成。</li>
<li>粒子流具备多种属性，目前我拓展了缩放，圆形与矩形，墙壁碰撞，等等。</li>
<li>粒子每个互不影响，可以分批设置粒子特性，视频中就有 方形 和 圆形</li>
<li>所有的半径，坐标什么的参数都是可自定义的。</li>
<li>因为锚边是根据 bitmap 而来的，也就是说，你可以输入图片，然后由粒子组合</li>
<li>XView 项目早前已经开源了碰撞球，可以加入粒子相互碰撞</li>
</ol>

<h2 id="toc_4">原理及其难点</h2>

<ol>
<li>根据 bitmap 找出文字或图像的边。这步骤要减少 o(n)</li>
<li>根据边路径，进行粒子填充</li>
<li>变幻算法，例如运动中的缩放</li>
<li>高效率的刷新，摒弃 View，采用 SurfaceView</li>
</ol>

<h2 id="toc_5">部分代码简述</h2>

<p><strong>调用</strong></p>

<pre class="line-numbers"><code class="language-java">// 粒子变幻
particleView.setConfigAndRefreshView(
    new ParticleView.Config()
            .setCanvasWidth(
                    // 设置画布宽度
                    getWindowManager().getDefaultDisplay().getWidth()
            )
            .setCanvasHeight(800) // 设置画布高度
            .setParticleRefreshTime(50) // 设置每帧刷新间隔
            .set_x_Step(15) // 设置 x 轴每次取像素点的间隔
            .set_y_Step(19) // 设置  轴每次取像素点的间隔
            .setParticleCallBack(
                new ParticleView.ParticleCallBack() {
                    @Override
                    public ParticleView.Particle setParticle(ParticleView.Particle p, int index, int x, int y) {
                        p.setX(x); // 设置获取回来的 x 为该 粒子的x坐标
                        p.setY(y); // 设置获取回来的 y 为该 粒子的y坐标
                        p.setIsZoom(true);  // 设置当前颗粒子是否启动缩放
                        p.setRadiusMax(12); // 设置当前颗粒子最大的缩放半径
                        p.setRadius(12);    // 设置当前颗粒子默认的半径

                        /** 下面的 %3 是我演示 分批次 显示不同效果而设置 **/
                        if(index % 3==0){
                            p.setRectParticle(true); // 这个粒子是 正方形 的
                            p.setIsHash(  // 设置它是否是散列的，即是随机移动
                                    true,
                                    new Random().nextInt(30)-15, // x 速率
                                    new Random().nextInt(30)-15  // y 速率
                            );
                        }
                        return p; // 返回这个粒子
                    }

                    @Override
                    public boolean drawText(Bitmap bg,Canvas c) {
                        /** 这里就是我们要自定义显示任意文字的地方 */
                        MainActivity.this.drawText(bg,c,s);
                        return true; /** 告诉它不要使用默认的 txt */
                    }
                }
            )
);
</code></pre>

<p><strong>源码地址</strong></p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faf913337456%2FXView">github.com/af913337456…</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871831.html">
                
                  <h1>Android-LayoutInflater（布局加载器）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>对于LayoutInflater之前一直只会用，却不知道LayoutInflater的加载原理，每次直接</p>

<pre class="line-numbers"><code class="language-java">LayoutInflater.from(context).inflate(R.layout.activity_test, root, false);

//不行就这样，反正有一种能实现我要的效果
LayoutInflater.from(context).inflate(R.layout.activity_test, null);
</code></pre>

<p>所以，想要趁这个整理博客的机会，顺便把LayoutInflater的内容好好学习学习。</p>

<h2 id="toc_1">概述</h2>

<ul>
<li>LayoutInflater的常见使用场景</li>
<li>LayoutInflater的介绍</li>
<li>LayoutInflater相关介绍中的相关概念分析</li>
</ul>

<h2 id="toc_2">LayoutInflater的常见使用场景</h2>

<p>在介绍之前，我们先回一下，我们在哪些地方都使用过LayoutInflater：</p>

<h3 id="toc_3">在Activity中</h3>

<pre class="line-numbers"><code class="language-java">LayoutInflater inflater = getLayoutInflater();
View view = inflater.inflate(R.layout.activity_main, null);
</code></pre>

<h3 id="toc_4">在Fragment中</h3>

<pre class="line-numbers"><code class="language-java">View view = inflater.inflate(R.layout.fragment_guide_one, container, false);
return view;
</code></pre>

<h3 id="toc_5">在Adapter中</h3>

<pre class="line-numbers"><code class="language-java">@Override
public View getView(int position, View convertView, ViewGroup parent) {
    View view = LayoutInflater.from(convertView.getContext()).inflate(R.layout.activity_main, parent, false);
    return view;
}
</code></pre>

<h3 id="toc_6">在某些特殊情况下，需要使用LayoutInflater，我们是这样获得它的</h3>

<p><code>LayoutInflater inflater  =(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</code></p>

<p>上述的使用，是我们平常常见的使用方式，而这些场景都有一个特点，因为这些场景都需要将一个XML布局文件转化成View，所以准确的说<strong>LayoutInflater</strong>的主要功能来说就是布局加载。</p>

<p>其实<strong>LayoutInflater</strong>还有一些扩展操作，可以通过我们自定义的方式来实现，在后面的实战篇会介绍。</p>

<h2 id="toc_7">LayoutInflater的介绍</h2>

<p>对于LayoutInflater的介绍性质的内容，博主认为，在网上查的任何内容，都不如查阅源码，API来的靠谱一些，因为API才是第一手的介绍资料，而且Android的源码中介绍的也比较完善。</p>

<p>LayoutInflater属于 android.view包下，在LayoutInflater的头部有一段关于LayoutInflater的介绍：</p>

<p><figure><img src="media/15561207871831/15713348568693.png" alt=""/></figure></p>

<p>由于篇幅原因，这里只截取了一部分图片，总结一下：</p>

<ul>
<li>LayoutInflater的主要作用将XML文件实例化成相应的View对象</li>
<li>LayoutInflater在Android开发过程中，获取的方式不是直接new出来的，都是经过这两个方法得到的关联上下文的LayoutInflater：</li>
</ul>

<pre class="line-numbers"><code class="language-java">//在Activity中
LayoutInflater inflater = Activity#getLayoutInflater()
//其他情况
LayoutInflater inflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)
</code></pre>

<ul>
<li>如果想使用新的LayoutInflater来加载View，需要使用cloneInContext()，而在新的LayoutInflater需要调用setFactory()设置<strong>视图处理器</strong></li>
<li>由于性能的原因，XML文件的预处理是在Build过程中进行的。</li>
<li>LayoutInflater不能加载未编译的XML文件，而且LayoutInflater只能加载，通过XmlPullParser解析的R文件资源。</li>
</ul>

<h2 id="toc_8">LayoutInflater介绍相应的解释</h2>

<p>经过上面的总结，大家对LayoutInflater有一个大致的认识，为了大家不是太懵逼，让我一一解释一波。</p>

<h3 id="toc_9">LayoutInflater的主要作用将XML文件实例化成相应的对象</h3>

<p>其实，大家在使用LayoutInflater时，也会注意到无非就是将布局资源通过LayoutInflater转换为相对应的View，然后在进行一些其他操作,就是<strong>LayoutInflater常见场景</strong>中的几种情况：</p>

<pre class="line-numbers"><code class="language-java">View view = inflater.inflate(R.layout.fragment_guide_one, container, false);
return view;
</code></pre>

<h3 id="toc_10">LayoutInflater在Android开发过程中，不是通过new出来获取到的？</h3>

<p>在上述场景中，除了介绍的两种方式Activity#getLayoutInflater()，以及getSystemService()，大家发现常见场景中还使用了</p>

<p><code>LayoutInflater inflater =LayoutInflater.from(convertView.getContext())；</code></p>

<p>其实LayoutInflater.from()这个方法是官方帮我们封装了一层而已，底层还是调用getSystemService()方法，目的是使LayoutInflater与Context对象相绑定：</p>

<pre class="line-numbers"><code class="language-java">public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre>

<h3 id="toc_11">如果想使用新的LayoutInflater来加载，需要使用cloneInContext()，而在新的LayoutInflater需要调用setFactory()设置视图处理器</h3>

<p>正常来说，这种使用方式的使用场景现在也是比较多的，比如：</p>

<ol>
<li>批量获取XML中自定义的属性</li>
<li>动态换肤的效果</li>
<li>动态改变布局中的元素</li>
</ol>

<p>这些都是通过LayoutInflater中的Factory来实现的，而介绍这部分内容会在实战篇来介绍。</p>

<h3 id="toc_12">由于性能的原因，XML文件的预处理是在Build过程中进行的</h3>

<p>举个例子，在编写XML布局资源时，如果漏写了结束符号，或者一些奇怪的操作，在运行程序之前的Build（构建阶段），就会弹出报错。</p>

<p>这里故意将结束符，写错</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;center_horizontal&quot;
    android:textSize=&quot;20sp&quot; /
</code></pre>

<p>这里就会收到报错信息提示，每个XML都会有一个预编译的过程，这个过程发生在构建阶段（Build），而不是运行时。</p>

<p><figure><img src="media/15561207871831/15713348644088.png" alt=""/></figure></p>

<h3 id="toc_13">LayoutInflater只能加载通过XmlPullParser解析的R文件资源</h3>

<p>这里的R文件资源就是指这些资源文件<br/><br/>
例如：</p>

<pre class="line-numbers"><code class="language-text">R.layout.xxxx
R.drawable.xxxx
R.color.xxx
R.string.xxx
</code></pre>

<h2 id="toc_14">二级概述</h2>

<ul>
<li>Activity 的 getSystemService的实现过程</li>
<li>LayoutInflater 如果将布局资源转换为 View 的过程</li>
<li>LayoutInflater的 Factory，Factory2是什么，在解析过程中的作用是什么？</li>
<li>LayoutInflater 的 inflater 方法的各个参数的含义，不同的情况的含义</li>
</ul>

<h2 id="toc_15">LayoutInflater的构造方法</h2>

<pre class="line-numbers"><code class="language-java">protected LayoutInflater(Context context) {
    mContext = context;
}
</code></pre>

<p>这种是LayoutInflater常规的构造方法，将Context传入，最后生成的LayoutInflater与对应的Context相绑定。</p>

<pre class="line-numbers"><code class="language-java">protected LayoutInflater(LayoutInflater original, Context newContext) {
    mContext = newContext;
    mFactory = original.mFactory;
    mFactory2 = original.mFactory2;
    mPrivateFactory = original.mPrivateFactory;
    setFilter(original.mFilter);
}
</code></pre>

<p>而这种构造方法来说，只是复制原LayoutInflater的内容，然后将Context对象替换，一般来说只会在cloneInContext()方法中使用。</p>

<h2 id="toc_16">LayoutInflater#form()方法分析</h2>

<p>根据介绍篇的内容，LayoutInflater在Android开发中一般是通过</p>

<pre class="line-numbers"><code class="language-java">context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

LayoutInflater.from(context);
</code></pre>

<p>因为第一种方式，已经是LayoutInflater介绍中声明获取的方式之一，那么这里我们看一下LayoutInflater#form的方法。</p>

<pre class="line-numbers"><code class="language-java">public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre>

<p>从源码上看，LayoutInflater#form()方法内部也是通过getSystemService()方法获得，那么接下来我们看一下context#getSystemService()这个方法：</p>

<p><code>public abstract Object getSystemService(@ServiceName @NonNull String name);</code></p>

<p>发现这个只是一个抽象方法，而我们知道Activity也是Context的一个实现。</p>

<p>Activity#getSystemService()这个方法：</p>

<pre class="line-numbers"><code class="language-java">@Override
public Object getSystemService(@ServiceName @NonNull String name) {
    if (getBaseContext() == null) {
        throw new IllegalStateException(
            &quot;System services not available to Activities before onCreate()&quot;);
    }
    //获取WindowManager
    if (WINDOW_SERVICE.equals(name)) {
        return mWindowManager;
        //系统的搜索框SearchManager
    } else if (SEARCH_SERVICE.equals(name)) {
        ensureSearchManager();
        return mSearchManager;
    }
    return super.getSystemService(name);
}
</code></pre>

<p>从上面看到，在Activity中只处理了两种类型的服务，分别是获取WindowManager、获取SearchManager，那我们接着看其父类的SystemService()方法：</p>

<pre class="line-numbers"><code class="language-java">@Override
public Object getSystemService(String name) {
    //找到我们要的东西，注意这是个单例
    if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        if (mInflater == null) {
            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);
        }
        return mInflater;
    }
    return getBaseContext().getSystemService(name);
}
</code></pre>

<p>在Activity的父类即ContextThemeWrapper的getSystemService()方法中，我们发现了LayoutInflater的创建过程，从上面的代码我们可以看出：</p>

<p>每个Activity内包含的LayoutInflater是一个单例。</p>

<p>Activity创建LayoutInflater时，是先使用最原始的BaseContext创建，然后在将Activity的父类ContextThemeWrapper的信息通过cloneInContext()方法与其绑定。</p>

<p>然后我们在看下LayoutInflater的cloneInContext的实现：</p>

<p><code>public abstract LayoutInflater cloneInContext(Context newContext);</code></p>

<p>先看下，这个方法的介绍：</p>

<p><figure><img src="media/15561207871831/15713349011719.png" alt=""/></figure></p>

<p>这个方法通过现有的LayoutInflater创建一个新的LayoutInflater副本，唯一变化的地方是指向不同的上下文对象。</p>

<p>在ContextThemeWrapper通过这个方法创建的新的LayoutInflater还包含了主题的信息。</p>

<p>在ContextThemeWrapper中使用cloneInContext是想将更多的信息，赋予LayoutInflater中，与其相互绑定。</p>

<h1 id="toc_17">Activity中LayoutInflater创建</h1>

<p>对于Activity的LayoutInflater，其实在Activity创建之时就已经创建完成，但是这一块内容属于FrameWork层的内容，博主道行太浅了，只想带大家看下from这个方法的实现过程。</p>

<p>这里如果大家想了解可以参考下这篇文章</p>

<p><a href="http://blog.csdn.net/u014486880/article/details/50707672">LayoutInflater源码解析</a></p>

<p>而Activity#getLayoutInflater方法：</p>

<pre class="line-numbers"><code class="language-java">@NonNull
public LayoutInflater getLayoutInflater() {
    return getWindow().getLayoutInflater();
}
</code></pre>

<p>这个Window对象即PhoneWindow，此时创建出来的LayoutInflater即PhoneLayoutInflater。</p>

<p>这里给大家看下PhoneLayoutInflater的cloneInContext()方法：</p>

<pre class="line-numbers"><code class="language-java">public LayoutInflater cloneInContext(Context newContext) {
    return new PhoneLayoutInflater(this, newContext);
}

protected PhoneLayoutInflater(LayoutInflater original, Context newContext) {
    super(original, newContext);
}
</code></pre>

<p>可以发现PhoneLayoutInflater中cloneInContext()的实现，调用了第二个构造方法。</p>

<p>这里在Android Studio是无法查阅的，有条件的可以下载源码，如果下载源码麻烦，可以在这里查阅。</p>

<p><a href="http://androidxref.com/">Android源码查看网址</a></p>

<h2 id="toc_18">将R.layout.xxx转换为View的过程分析</h2>

<p>其实这个过程即LayoutInflater.inflater()这个过程：</p>

<pre class="line-numbers"><code class="language-java">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {

    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre>

<p>在这个方法中，只是先拿到XmlResourceParser，用于后续节点的解析，我们接着往下看：</p>

<p>这里只看一些关键的信息，具体代码大家自行查看</p>

<pre class="line-numbers"><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {

    //》》》》》》》》》》》》》》》》》第一部分》》》》》》》》》》》》》》》》》》》
    try {
        while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
        // Empty
        }

        if (type != XmlPullParser.START_TAG) {
            throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;);
        }

        final String name = parser.getName()
        //》》》》》》》》》》》》》》》》》第二部分》》》》》》》》》》》》》》》》》》》
        if (TAG_MERGE.equals(name)) {
            if (root == null || !attachToRoot) {
                throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;);
            }

            rInflate(parser, root, inflaterContext, attrs, false);
        } else {
            //》》》》》》》》》》》》》》》》》第三部分》》》》》》》》》》》》》》》》》》》
            final View temp = createViewFromTag(root, name, inflaterContext, attrs);

            ViewGroup.LayoutParams params = null;

            if (root != null) {
                params = root.generateLayoutParams(attrs);
                if (!attachToRoot) {
                    temp.setLayoutParams(params);
                }
            }

            rInflateChildren(parser, temp, attrs, true);

            if (root != null &amp;&amp; attachToRoot) {
                root.addView(temp, params);
            }

            if (root == null || !attachToRoot) {
                result = temp;
            }
        }
        return result;
    }
}
</code></pre>

<h3 id="toc_19">第一部分：</h3>

<p>这里第一部分的内容，主要是一个XML文件的读取过程，这里有两个判断：</p>

<ul>
<li>遍历XML内容寻找XML标签的开始的标志或者文档结尾的标志才可以跳出循环。</li>
<li>如果该XML没有开始的标识，则抛出异常。</li>
</ul>

<p>下面给大家介绍下，几种常见的解析标识：</p>

<pre class="line-numbers"><code class="language-text">XmlPullParser.START_DOCUMENT                                    文档开始

XmlPullParser.END_DOCUMENT                                      文档结束

XmlPullParser.START_TAG                                         XML标签的开始

XmlPullParser.END_TAG                                           XML标签的结束

XmlPullParser.TEXT                                              XML标签的内容
</code></pre>

<h3 id="toc_20">第二部分</h3>

<p>这部分的一开始先进行了Merge标签的检验，如果发现该节点是Merge，必须满足父View存在，并且与父View绑定的状态。</p>

<p>转换为代码:</p>

<p><code>root ！= null &amp;&amp; attachToRoot ==true</code></p>

<p>这里Merge是减少布局层级存在的标签，通常和include标签一起使用，所以其必须存在父View，而且merge标签的内容必须与父View绑定。</p>

<p>这里调用rInflate()方法去解析Merge的标签，而rInflate()方法，在另一篇文章已经单独分析。</p>

<p><a href="http://blog.csdn.net/l540675759/article/details/78017065">Android 中LayoutInflater（布局加载器）源码篇之rInflate方法</a></p>

<h3 id="toc_21">第三部分</h3>

<p>我们再看一下第三部分的代码，代码中会有一些简要的说明：</p>

<pre class="line-numbers"><code class="language-java">//》》》》》》》》》》》》》》》》》第三部分》》》》》》》》》》》》》》》》》》》
//createViewFromTag是一个根据name来创建View的方法
                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                    ViewGroup.LayoutParams params = null;

                    if (root != null) {
                        params = root.generateLayoutParams(attrs);
                        if (!attachToRoot) {
                            temp.setLayoutParams(params);
                        }
                    }
                    //解析子标签
                    rInflateChildren(parser, temp, attrs, true);

                    if (root != null &amp;&amp; attachToRoot) {
                        root.addView(temp, params);
                    }

                    if (root == null || !attachToRoot) {
                        result = temp;
                    }
                }
            return result;
        }

</code></pre>

<p>将第三部分内容分拆一下主要分为以下几块内容：</p>

<ul>
<li>排除标签为include，或者merge之后，就会通过createViewFromTag()方法来创建View</li>
<li>root是inflater()方法的第二个参数，而attachToRoot是第三个参数，最后会根据这两个参数来决定返回的View</li>
</ul>

<p>在这部分中，<code>createViewFromTag()</code>是根据name（名称），来创建View的一个方法。</p>

<p>接下来，我们要介绍的是inflater()方法中的参数，到底有什么作用？</p>

<pre class="line-numbers"><code class="language-java">
                    ViewGroup.LayoutParams params = null;
                    //当Root存在
                    if (root != null) {
                        params = root.generateLayoutParams(attrs);
                        if (!attachToRoot) {
                            //设置View在父布局下Params
                            temp.setLayoutParams(params);
                        }
                    }
                    //遍历子节点
                    rInflateChildren(parser, temp, attrs, true);

                    //如果Root存在并且attachToRoot为true，即与父View绑定
                    //这里在解析的同时，就会将其添加至父View上
                    if (root != null &amp;&amp; attachToRoot) {
                        root.addView(temp, params);
                    }

                    //如果父Viewwe为null或者没有绑定父View都会将当前解析的View返回，否则返回父View
                    if (root == null || !attachToRoot) {
                        result = temp;
                    }
                }
</code></pre>

<p>仔细分析上述代码，可以得出如下结论：</p>

<p>从这段代码中，得出以下几个结论：</p>

<ol>
<li>当root为null时，attachToRoot参数无效，而解析出的View作为一个独立的View存在（不存在LayoutParams）。</li>
<li>当root不为null时，attactToRoot为false，那么会给该View设置一个父View的约束（LayoutParams），然后将其返回。</li>
<li>当root不为null时，attactToRoot为true，那么该View会被直接addView进父View，然后会将父View返回。</li>
<li>当root不为null的话，attactToRoot的默认值是true。</li>
</ol>

<pre class="line-numbers"><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root) {
    return inflate(parser, root, root != null);
}
</code></pre>

<p>上面的代码中，我们还少分析了一处代码rInflateChildren()，即解析子类：</p>

<pre class="line-numbers"><code class="language-java">final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,boolean finishInflate) throws XmlPullParserException, IOException {
    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);
}
</code></pre>

<p>如果你之前没看过这段代码，其实你会像博主之前一样，一直在试，而不知道这段代码正确的含义，但是有时候源码会是一个很好的老师，通过它能够得到你想要的。</p>

<h2 id="toc_22">流程图</h2>

<p><figure><img src="media/15561207871831/15713349276858.png" alt=""/></figure></p>

<h2 id="toc_23">CreateViewFromTag源码解析</h2>

<pre class="line-numbers"><code class="language-java">private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) {
    return createViewFromTag(parent, name, context, attrs, false);
}
</code></pre>

<p>createViewFromTag在LayoutInflater中存在重载，最终还是会调用5个参数的createViewFromTag方法。</p>

<pre class="line-numbers"><code class="language-java">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,boolean ignoreThemeAttr) {

    //解析view标签
    if (name.equals(&quot;view&quot;)) {
        name = attrs.getAttributeValue(null, &quot;class&quot;);
    }

    //如果需要该标签与主题相关，需要对context进行包装，将主题信息加入context包装类ContextWrapper
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
            ta.recycle();
        }

        //BlinkLayout是一种闪烁的FrameLayout，它包裹的内容会一直闪烁，类似QQ提示消息那种。
        if (name.equals(TAG_1995)) {
            return new BlinkLayout(context, attrs);
        }

        //设置Factory，来对View做额外的拓展，这块属于可定制的内容
        try {
            View view;
            if (mFactory2 != null) {
                view = mFactory2.onCreateView(parent, name, context, attrs);
            } else if (mFactory != null) {
                view = mFactory.onCreateView(name, context, attrs);
            } else {
                view = null;
            }
            if (view == null &amp;&amp; mPrivateFactory != null) {
                view = mPrivateFactory.onCreateView(parent, name, context, attrs);
            }

            //如果此时不存在Factory，不管Factory还是Factory2，还是mPrivateFactory都不存在，那么会直接对name直接进行解析
            if (view == null) {
                final Object lastContext = mConstructorArgs[0];
                mConstructorArgs[0] = context;
                try {
                    //如果name中包含.即为自定义View，否则为原生的View控件
                    if (-1 == name.indexOf(&#39;.&#39;)) {
                        view = onCreateView(parent, name, attrs);
                    } else {
                        view = createView(name, null, attrs);
                    }
                } finally {
                    mConstructorArgs[0] = lastContext;
                }
            }

        return view;
</code></pre>

<p>根据源码可以将createViewFromTag分为三个流程：</p>

<ul>
<li>对一些特殊标签，做分别处理，例如：view，TAG_1995(blink)</li>
<li>进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View</li>
<li>如果没有设置Factory或Factory2，那么就会使用LayoutInflater默认的生成方式，进行View的生成</li>
</ul>

<h3 id="toc_24">createViewFromTag分析过程：</h3>

<h4 id="toc_25">处理view标签</h4>

<p>如果标签的名称是view，注意是小写的view，这个标签一般大家不太常用，具体的使用情况如下：</p>

<pre class="line-numbers"><code class="language-text">&lt;view
    class=&quot;RelativeLayout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;&lt;/view&gt;
</code></pre>

<p>在使用时，相当于所有控件标签的父类一样，可以设置class属性，这个属性会决定view这个节点会变成什么控件。</p>

<h4 id="toc_26">如果该节点与主题相关，则需要特殊处理</h4>

<p>如果该节点与主题（Theme）相关，需要将context与theme信息包装至ContextWrapper类。</p>

<h4 id="toc_27">处理TAG_1995标签</h4>

<p>这就有意思了，TAG_1995指的是blink这个标签，这个标签感觉使用的很少，以至于大家根本不知道。</p>

<p>这个标签最后会被解析成BlinkLayout，BlinkLayout其实就是一个FrameLayout，这个控件最后会将包裹内容一直闪烁(就和电脑版QQ消息提示一样)，有空大家可以自行尝试下，很简单，下面贴一下用法：</p>

<pre class="line-numbers"><code class="language-text">&lt;blink
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;这个标签会一直闪烁&quot;/&gt;
&lt;/blink&gt;
</code></pre>

<h4 id="toc_28">判断其是否存在Factory或者Factory2</h4>

<p>在这里先对Factory进行判空，这里不管Factory还是Factory2（mPrivateFactory 就是Factory2），本质上都是一种扩展操作，提前解析name，然后直接将解析后的View返回。</p>

<h5 id="toc_29">Factory</h5>

<pre class="line-numbers"><code class="language-java">public interface Factory {
    public View onCreateView(String name, Context context, AttributeSet attrs);
}
</code></pre>

<h5 id="toc_30">Factory2</h5>

<pre class="line-numbers"><code class="language-java">public interface Factory2 extends Factory {
    public View onCreateView(View parent, String name, Context context, AttributeSet attrs);
}
</code></pre>

<p>从这里可以看出，Factory2和Factory都是一个接口，需要自己实现，而Factory2和Factory的区别是Factory2继承Factory，从而扩展出一个参数，就是增加了该节点的父View。</p>

<p>这里我自定义了一个Factory，下面自定义解析View的过程：</p>

<pre class="line-numbers"><code class="language-java">@Override
public View onCreateView(String name, Context context, AttributeSet attrs) {
    View view = null;
    try {
        if (-1 == name.lastIndexOf(&quot;.&quot;)) {
            if (name.equals(&quot;View&quot;) || name.equals(&quot;ViewGroup&quot;)) {
                view = mInflater.createView(name, &quot;android.view.&quot;, attrs);
            } else {
                view = mInflater.createView(name, &quot;android.widget.&quot;, attrs);
            }
        } else {
            if (name.contains(&quot;.&quot;)) {
                String checkName = name.substring(name.lastIndexOf(&quot;.&quot;));
                String prefix = name.substring(0, name.lastIndexOf(&quot;.&quot;));
                view = mInflater.createView(checkName, prefix, attrs);
            }
        }

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        if(view != null){
            //在这里可以对View做一些额外的操作，并且能够获得View的属性集，可以做一些自定义操作。
            view.xxxxxx
        }

        return view;
}
</code></pre>

<p>从上面可以看出，Factory和Factory2其实LayoutInflater解析View时的一种扩展实现，在这里可以额外的对View处理，设置Factory和Factory2需要通过setFactory()或者setFactory2()来实现。</p>

<p><strong>setFactory()</strong></p>

<pre class="line-numbers"><code class="language-java">public void setFactory(Factory factory) {
    //如果已经设置Factory，不可以继续设置Factory
    if (mFactorySet) {
        throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;);
    }
    if (factory == null) {
        throw new NullPointerException(&quot;Given factory can not be null&quot;);
    }
    //设置Factory会添加一个标记
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = factory;
    } else {
        mFactory = new FactoryMerger(factory, null, mFactory, mFactory2);
    }
}
</code></pre>

<p><strong>setFactory2()</strong></p>

<pre class="line-numbers"><code class="language-java">public void setFactory2(Factory2 factory) {
    if (mFactorySet) {
        throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;);
    }
    if (factory == null) {
        throw new NullPointerException(&quot;Given factory can not be null&quot;);
    }
    //注意设置Factory和Factory2的标记是共用的
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = mFactory2 = factory;
    } else {
        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);
    }
}
</code></pre>

<p>通过上面代码可以看出，Factory和Factory2只能够设置一次，并且Factory和Factory2二者互斥，只能存在一个。</p>

<p>所以一般setFactory()或者setFactory2()，一般在cloneInContext()之后设置，这样生成一个新的LayoutInflater，标记默认是false，才能够设置。</p>

<h4 id="toc_31">LayoutInflater内置的解析过程</h4>

<p>如果Factory或者Factory2没有设置，或者返回View为null，才会使用默认解析方式。</p>

<pre class="line-numbers"><code class="language-text">if (-1 == name.indexOf(&#39;.&#39;)) {
    view = onCreateView(parent, name, attrs);
} else {
    view = createView(name, null, attrs);
}
</code></pre>

<p>这段就是对自定义View和原生的控件进行判断，这里给大家说明下原生控件和自定义View的name区别：</p>

<pre class="line-numbers"><code class="language-text">原生 ：  RelativeLayout
自定义View ： com.demo.guidepagedemo.customview.CustomImageView
</code></pre>

<p>原生控件的解析方式 onCreateView ：</p>

<pre class="line-numbers"><code class="language-java">protected View onCreateView(View parent, String name, AttributeSet attrs) throws ClassNotFoundException {
    return onCreateView(name, attrs);
}
</code></pre>

<p>然后调用的还是2个参数的onCreateView()方法</p>

<pre class="line-numbers"><code class="language-java">protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {
    return createView(name, &quot;android.view.&quot;, attrs);
}
</code></pre>

<p>可以看到最终方法的指向还是调用createView方法：</p>

<pre class="line-numbers"><code class="language-java">public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException {
    //判断构造器是否存在    
    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);
    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class&lt;? extends View&gt; clazz = null;

    try {
        //如果构造器不存在，这个就相当于Class之前是否被加载过，sConstructorMap就是缓存这些Class的Map
        if (constructor == null) {
            //通过前缀+name的方式去加载
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            //通过过滤去设置一些不需要加载的对象
            if (mFilter != null &amp;&amp; clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            //缓存Class
            sConstructorMap.put(name, constructor);
        } else {
            //如果Class存在，并且加载Class的ClassLoader合法
            //这里先判断该Class是否应该被过滤
            if (mFilter != null) {
                //过滤器也有缓存之前的Class是否被允许加载，判断这个Class的过滤状态
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    //加载Class对象操作
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    //判断Class是否可被加载
                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }

        Object[] args = mConstructorArgs;
        args[1] = attrs;

        //如果过滤器不存在，直接实例化该View
        final View view = constructor.newInstance(args);
        //如果View属于ViewStub那么需要给ViewStub设置一个克隆过的LayoutInflater
        if (view instanceof ViewStub) {
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    }
}
</code></pre>

<p>上面代码有点长，就直接在代码里面加注释了，这里额外说一下这个方法：</p>

<p>判断ClassLoader是否安全的verifyClassLoader ：</p>

<pre class="line-numbers"><code class="language-java">private final boolean verifyClassLoader(Constructor&lt;? extends View&gt; constructor) {
    final ClassLoader constructorLoader = constructor.getDeclaringClass().getClassLoader();
    if (constructorLoader == BOOT_CLASS_LOADER) {
        //这里注意BootClassLoader是相当于所有派生出来的ClassLoader的原始基类，所有的ClassLoader都是根据其衍生的。
        return true;
    }
    //这里是一个遍历操作，一直在遍历加载mContext的ClassLoader的继承树，一直在往上寻找，如果
    //constructor的ClassLoader与继承树中某个ClassLoader相同就说明这个ClassLoader是安全的
    ClassLoader cl = mContext.getClassLoader();
    do {
        if (constructorLoader == cl) {
            return true;
        }
        cl = cl.getParent();
    } while (cl != null);
        return false;
    }
}
</code></pre>

<p>这里简单说明下，几种ClassLoader的作用：</p>

<ul>
<li>BootClassLoader 加载Android FrameWork层的一些字节码文件</li>
<li>PathClassLoader 加载已经安装到系统上的应用App（apk）上的字节码文件</li>
<li>DexClassLoader 加载指定目录中的Class字节码文件</li>
<li>BaseDexClassLoader 是PathClassloader和DexClassLoader的父类</li>
</ul>

<p>一般的App刚启动的时候，就会有两个ClassLoader被加载，分别是PathClassLoader、DexClassLoader而这两个ClassLoader都是继承BaseDexClassLoader.</p>

<p>而BaseDexClassLoader继承的是ClassLoader，但是在ClassLoader中getParent()方法赋予其Parent为BootClassLoader，这个如果大家感兴趣，可以自行查阅ClassLoader。</p>

<h2 id="toc_32">流程图</h2>

<p><figure><img src="media/15561207871831/15713350767455.jpg" alt=""/></figure></p>

<h2 id="toc_33">rInflate()的源码分析</h2>

<pre class="line-numbers"><code class="language-java">void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {

    //获取该标签的深度
    final int depth = parser.getDepth();
    int type;

    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {

        if (type != XmlPullParser.START_TAG) {
            continue;
        }

        final String name = parser.getName();

        //如果该节点为requestFocus
        if (TAG_REQUEST_FOCUS.equals(name)) {
            parseRequestFocus(parser, parent);
            //如果该节点为tag
        } else if (TAG_TAG.equals(name)) {
            parseViewTag(parser, parent, attrs);
            //如果该节点为include标签
        } else if (TAG_INCLUDE.equals(name)) {
            if (parser.getDepth() == 0) {
                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
            }
            //解析include标签
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
            //如果该节点为Merge
            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);
        } else {
            //否则属于正常的View
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            //接下来解析子View
            rInflateChildren(parser, view, attrs, true);
            //注意这里直接进行addView操作
            viewGroup.addView(view, params);
        }
    }

    //如果解析完成，需要通知父View，解析完成。
    if (finishInflate) {
        parent.onFinishInflate();
    }
}
</code></pre>

<p>在rInflate这里做的操作，就是识别这些节点，然后对应解析形成响应的元素，下面我们会根据代码，一段一段分析rInflate都做了什么.</p>

<ul>
<li>如果发现requestFocus标签，则调用父View的requestFocus()方法。</li>
</ul>

<p><strong>requestFocus标签使用</strong>：</p>

<pre class="line-numbers"><code class="language-text">&lt;EditText  
    android:id=&quot;@+id/text&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot; &gt;  
    &lt;!-- 当前控件处于焦点状态 --&gt;  
&lt;requestFocus /&gt;  
</code></pre>

<p><strong>parseRequestFocus方法</strong>：</p>

<pre class="line-numbers"><code class="language-java">private void parseRequestFocus(XmlPullParser parser, View view) throws XmlPullParserException, IOException {
    //调用其父View的requestFocus（）方法
    view.requestFocus();
    consumeChildElements(parser);
}
</code></pre>

<ul>
<li>如果发现tag标签，为其设置（key，value）模式的tag。</li>
</ul>

<p><strong>tag标签使用</strong>：</p>

<pre class="line-numbers"><code class="language-text">&lt;Button
    android:id=&quot;@+id/tag_btn&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:onClick=&quot;openClickNotification&quot;
    android:text=&quot;自定义带监听事件的通知&quot;&gt;

    &lt;tag
        android:id=&quot;@+id/tag_id&quot;
        android:value=&quot;@string/app_name&quot; /&gt;
&lt;/Button&gt;
</code></pre>

<p><strong>parseViewTag</strong>方法 ：</p>

<pre class="line-numbers"><code class="language-java">private void parseViewTag(XmlPullParser parser, View view, AttributeSet attrs) throws XmlPullParserException, IOException {
    final Context context = view.getContext();
    final TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.ViewTag);
    //这里设置tag的key
    final int key = ta.getResourceId(R.styleable.ViewTag_id, 0);
    //这里设置tag的value
    final CharSequence value = ta.getText(R.styleable.ViewTag_value);
    view.setTag(key, value);
    ta.recycle();
    consumeChildElements(parser);
}
</code></pre>

<p>在parseViewTag()方法中，会把（key，value）形式的tag赋予View。</p>

<p>Key指的是R.id.tag_id对应的int类型数据；</p>

<p>Value指的是R.string.app_name的String类型数据；</p>

<ul>
<li>如果是Include标签，这里开始先获取了Include的深度</li>
</ul>

<p><code>final int depth = parser.getDepth();</code></p>

<p>所谓深度就是XML的层级关系，例如这样：</p>

<pre class="line-numbers"><code class="language-text">&lt;!-- outside --&gt;     
&lt;root&gt;                     
   sometext                
   &lt;foobar&gt;                    
    &lt;/foobar&gt;                  
&lt;/root&gt;                    
&lt;!-- outside --&gt;     
</code></pre>

<p>判断该Include标签的深度是否是0，如果为0，则抛出异常，因为include不能为根元素。</p>

<ul>
<li><p>如果是Merge标签，那么会直接抛出异常，因为Merge必须为根元素，也就是深度为0的节点。</p></li>
<li><p>最后是其他标签，例如View，一起其他的一些标签</p></li>
</ul>

<pre class="line-numbers"><code class="language-java">final View view = createViewFromTag(parent, name, context, attrs);
final ViewGroup viewGroup = (ViewGroup) parent;
final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
rInflateChildren(parser, view, attrs, true);
viewGroup.addView(view, params);
</code></pre>

<p>在加载View的过程，大致分为三个阶段：</p>

<ul>
<li>createViewFromTag() 见名知意，根据节点名称创建View</li>
<li>rInflateChildren() 加载该节点内子类</li>
<li>parent.addView() 最后将该View添加进Parent布局</li>
</ul>

<h3 id="toc_34">第一阶段 : createViewFromTag()</h3>

<p>createViewFromTag()是根据name(节点名称)来解析出View的一个方法</p>

<h3 id="toc_35">第二阶段 ：rInflateChildren()</h3>

<pre class="line-numbers"><code class="language-java">final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,boolean finishInflate) throws XmlPullParserException, IOException {
    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);
}
</code></pre>

<p>这里可以看到，这里会将解析出来的View作为Root(父View)，继续进行子节点的解析，会继续调用，直到无法解析。</p>

<p>这里的无法解析是指：</p>

<ul>
<li>当前解析的标识为XmlPullParser.END_TAG（节点结束的标识符），并且深度不在父节点的标签内。</li>
<li>或者type 为 XmlPullParser.END_DOCUMENT（文档结束的标识符）。</li>
</ul>

<h3 id="toc_36">第三阶段 parent.addView()将View添加进父View中</h3>

<p><code>viewGroup.addView(view, params);</code></p>

<p>这段话，不难理解，就是将解析出的View，添加到父View中。</p>

<h2 id="toc_37">流程图</h2>

<p><figure><img src="media/15561207871831/15713350890413.jpg" alt=""/></figure></p>

<h2 id="toc_38">parseInclude()是在哪里使用的？</h2>

<pre class="line-numbers"><code class="language-java">void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {
    //----------------省略部分代码--------------------//

} else if (TAG_INCLUDE.equals(name)) {
    if (parser.getDepth() == 0) {
        throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
    }
    parseInclude(parser, context, parent, attrs);
}
//----------------省略部分代码--------------------//
}
</code></pre>

<p>从上来代码中，可以发现parseInclude()是在rInflate()中出现，作用是处理当前节点是Include标签时的状况。</p>

<h2 id="toc_39">parseInclude()源码解析</h2>

<pre class="line-numbers"><code class="language-java"> //参数说明：
 // parser      解析布局的解析器
 // context     当前加载布局的上下文对象
 // parent      父容器
 // attrs       属性集合（XML该节点的属性集合）
 private void parseInclude(XmlPullParser parser, Context context, View parent,
            AttributeSet attrs) throws XmlPullParserException, IOException {
        int type;

        // 判断 Include标签是否在 ViewGroup容器之内，因为 include 标签只能存在于 ViewGroup 容器之内。

        if (parent instanceof ViewGroup) {

            //------------------&lt;第一部分&gt;-------------------//

            //当开发者设置 include 主题属性时，可以覆盖被 include 包裹View的主题属性。
            //但是这种操作很少会使用。
            //所以如果被包裹 View 设置主题属性，我们在设置就会出现覆盖效果。
            //以 include 标签的主题属性为最终的主题属性

            //提取出 include 的 thme 属性，如果设置了 them 属性，那么include 包裹的View 设置的 theme 将会无效
            final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
            final int themeResId = ta.getResourceId(0, 0);
            final boolean hasThemeOverride = themeResId != 0;
            if (hasThemeOverride) {
                context = new ContextThemeWrapper(context, themeResId);
            }
            ta.recycle();


            //------------------&lt;第二部分&gt;-------------------//

            //如果这个属性是指向主题中的某个属性，我们必须设法得到主题中layout 的资源标识符
            //先获取 layout 属性（资源 id）是否设置
            int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
            if (layout == 0) {
            //如果没直接设置布局的资源 id，那么就检索?attr/name这一类的 layout 属性
                final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
                if (value == null || value.length() &lt;= 0) {
                    throw new InflateException(&quot;You must specify a layout in the&quot;
                            + &quot; include tag: &lt;include layout=\&quot;@layout/layoutID\&quot; /&gt;&quot;);
                }

                //从  ?attr/name 这一类的属性中，获取布局属性  
                layout = context.getResources().getIdentifier(value.substring(1), null, null);
            }

            //这个布局资源也许存在主题属性中，所以需要去主题属性中解析
            if (mTempValue == null) {
                mTempValue = new TypedValue();
            }
            if (layout != 0 &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, true)) {
                layout = mTempValue.resourceId;
            }


            //------------------&lt;第三部分&gt;-------------------//

            if (layout == 0) {
                final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
                throw new InflateException(&quot;You must specify a valid layout &quot;
                        + &quot;reference. The layout ID &quot; + value + &quot; is not valid.&quot;);
            } else {
                final XmlResourceParser childParser = context.getResources().getLayout(layout);

                try {
                    final AttributeSet childAttrs = Xml.asAttributeSet(childParser);

                    while ((type = childParser.next()) != XmlPullParser.START_TAG &amp;&amp;
                            type != XmlPullParser.END_DOCUMENT) {
                        // Empty.
                    }

                    if (type != XmlPullParser.START_TAG) {
                        throw new InflateException(childParser.getPositionDescription() +
                                &quot;: No start tag found!&quot;);
                    }

                    final String childName = childParser.getName();

                    if (TAG_MERGE.equals(childName)) {
                        //解析 Meger 标签
                        rInflate(childParser, parent, context, childAttrs, false);
                    } else {
                        //根据 name名称来创建View
                        final View view = createViewFromTag(parent, childName,
                                context, childAttrs, hasThemeOverride);
                        final ViewGroup group = (ViewGroup) parent;


                        //获取 View 的 id 和其 Visiable 属性
                        final TypedArray a = context.obtainStyledAttributes(
                                attrs, R.styleable.Include);
                        final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);
                        final int visibility = a.getInt(R.styleable.Include_visibility, -1);
                        a.recycle();

                        //需要将 Parent中的 LayoutParams 设置为其 Params 属性。
                        //如果 Parent 没有通用的 Params，那么就会抛出Runtime 异常

                        //然后会为其设置 include 包裹内容的通用 Params，

                        ViewGroup.LayoutParams params = null;
                        try {
                            params = group.generateLayoutParams(attrs);
                        } catch (RuntimeException e) {
                            // Ignore, just fail over to child attrs.
                        }
                        if (params == null) {
                            params = group.generateLayoutParams(childAttrs);
                        }
                        view.setLayoutParams(params);

                        // 解析子标签
                        rInflateChildren(childParser, view, childAttrs, true);

                        if (id != View.NO_ID) {
                            view.setId(id);
                        }

                        // 加载include内容时，需要直接设置其 可见性
                        switch (visibility) {
                            case 0:
                                view.setVisibility(View.VISIBLE);
                                break;
                            case 1:
                                view.setVisibility(View.INVISIBLE);
                                break;
                            case 2:
                                view.setVisibility(View.GONE);
                                break;
                        }
                        //添加至父容器中
                        group.addView(view);
                    }
                } finally {
                    childParser.close();
                }
            }
        } else {
            throw new InflateException(&quot;&lt;include /&gt; can only be used inside of a ViewGroup&quot;);
        }

LayoutInflater.consumeChildElements(parser);
    }
</code></pre>

<p>先把parseInclude()这个方法全景先看下，然后我们在进行分拆，一部分一部分分析。</p>

<h2 id="toc_40">parseInclude()参数解读</h2>

<p>parseInclude()中分别含义四个参数：</p>

<h3 id="toc_41">解析器 -&gt; XmlPullParser parser</h3>

<p>用来解析XML文件的解析器，通过解析器可以得到当前节点的相对应的AttributeSet（属性集）</p>

<h3 id="toc_42">上下文对象 - &gt; Context context</h3>

<p>当前加载该XML的上下文对象，并且这个Context与LayoutInflater属于相互绑定关系（一一对应）</p>

<h3 id="toc_43">父容器 - &gt; View parent</h3>

<p>包裹该节点的父容器，一般来说都是继承ViewGroup实现的视图组</p>

<h3 id="toc_44">属性集 -&gt; AttributeSet attrs</h3>

<p>该节点的属性集，包括所有该节点的相关属性</p>

<h2 id="toc_45">Include中的theme属性</h2>

<p>这里大家先了解一个相关的问题，关于include标签设置theme属性的情况：</p>

<p>一般来说theme（主题）一般出现在Activtiy的AndroidManifest文件下，来给Activity设置统一的布局效果，而且可以使用如下的操作来进行主题属性的使用。</p>

<pre class="line-numbers"><code class="language-text">//  ?attr这样的形式，使用主题中的设置参数
android:background=&quot;?attr/colorPrimary&quot;
</code></pre>

<p>如果Include标签下设置了新的theme，那么Include中的内容在使用主题属性时，使用的theme主题就是（include）设置的内容，而不是Activity默认下的主题，形成了一种覆盖效果。</p>

<p>也就是说Include标签设置的主题可以覆盖Activity设置的根主题，但是Include设置的主题只作用与Include内部。</p>

<h3 id="toc_46">举个栗子：</h3>

<p><strong>style.xml</strong></p>

<p>先定义好两个基础Theme，一个是作为App的基础主题，另一个是include中的主题。</p>

<pre class="line-numbers"><code class="language-text">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;!-- BaseApplication theme --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
&lt;/style&gt;


&lt;style name=&quot;IncludeTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;!-- Include Theme --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p><strong>AndroidManifest.xml</strong></p>

<p>设置Activity的基础主题为AppTheme</p>

<pre class="line-numbers"><code class="language-text">&lt;activity
    android:name=&quot;com.demo.MainActivity&quot;
    android:theme=&quot;@style/AppTheme&quot;&gt;&lt;/activity&gt;
</code></pre>

<p><strong>activity_main.xml</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;!-- 这里是使用基础Theme的Toolbar --&gt;
    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/activity_theme_tb&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;?attr/colorPrimary&quot; /&gt;

    &lt;!-- 这里是自带Theme Include的Toolbar --&gt;
    &lt;include
        layout=&quot;@layout/test_toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:theme=&quot;@style/IncludeTheme&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>接下来，我们在看一下Include包裹的布局 </p>

<p><strong>test_toolbar.xml</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/include_toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;?attr/colorPrimary&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>从上面的XML文件我们可以看出两个Toolbar调用的background都指向theme的colorPrimary属性，接下来看一下显示效果：</p>

<p><figure><img src="media/15561207871831/15713351026853.jpg" alt=""/></figure></p>

<p>从效果图可以发现，Include Toolbar显示的颜色是粉色的，也就是Include额外设置的theme，这里也是从正面证明了这个概念。</p>

<h2 id="toc_47">第一部分：Include Theme主题的设置</h2>

<pre class="line-numbers"><code class="language-java">//------------------&lt;第一部分&gt;-------------------//
//提取出Theme属性
final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
final int themeResId = ta.getResourceId(0, 0);
final boolean hasThemeOverride = themeResId != 0;
//如果存在Theme属性，那么Include包含的子标签都会使用该主题
if (hasThemeOverride) {
    context = new ContextThemeWrapper(context, themeResId);
}
ta.recycle();
</code></pre>

<p>通过上面的介绍，很明显这段代码含义，就是检测是否给Include标签设置了Theme属性，如果设置theme，就创建相应的ContextThemeWrapper，用于之后子标签的解析时theme的使用。</p>

<h2 id="toc_48">第二部分：Include 内容布局的设置</h2>

<pre class="line-numbers"><code class="language-java">//------------------&lt;第二部分&gt;-------------------//
//先获取 layout 属性（资源 id）是否设置
int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
if (layout == 0) {
    //如果没直接设置布局的资源 id，那么就检索?attr/name这一类的 layout 属性
    final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
    if (value == null || value.length() &lt;= 0) {
        throw new InflateException(&quot;You must specify a layout in the&quot; + &quot; include tag: &lt;include layout=\&quot;@layout/layoutID\&quot; /&gt;&quot;);
    }

    //从?attr/name 这一类的属性中，获取布局属性  
    layout = context.getResources().getIdentifier(value.substring(1), null, null);
}

//这个布局资源也许存在主题属性中，所以需要去主题属性中解析
if (mTempValue == null) {
    mTempValue = new TypedValue();
}
if (layout != 0 &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, true)) {
    layout = mTempValue.resourceId;
}
</code></pre>

<p>这部分的内容主要是提取Include的内容布局的提取，Include的内容布局的设置有两种：</p>

<h3 id="toc_49">第一种 ： 直接@layout 后面设置布局的XML</h3>

<p><code>layout=&quot;@layout/test_toolbar&quot;</code></p>

<h3 id="toc_50">第二种：通过引入theme的item设置的layout属性</h3>

<h4 id="toc_51">Include标签下：</h4>

<p><code>layout=&quot;?attr/theme_layout&quot;</code></p>

<h4 id="toc_52">包裹Include标签的布局Theme（注意：这里不是Include设置的主题）：</h4>

<pre class="line-numbers"><code class="language-text">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    //重点在这里！！！！！
    &lt;item name=&quot;theme_layout&quot;&gt;@layout/test_toolbar&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>而上面的代码的作用是检索layout属性，如果layout已经以第一种方式引入，就不需要在去theme中检索，如果layout第一种方式检索不到资源ID，那么就会去以第二种方式进行检索。</p>

<h3 id="toc_53">第三部分： Include标签的View处理</h3>

<pre class="line-numbers"><code class="language-text">            //------------------&lt;第三部分&gt;-------------------//
            //如果此时还找不到layout，那么必然异常~，会报找不到资源ID的layout异常
            if (layout == 0) {
                final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
                throw new InflateException(&quot;You must specify a valid layout &quot;
                        + &quot;reference. The layout ID &quot; + value + &quot; is not valid.&quot;);
            } else {
            //生成子解析器
                final XmlResourceParser childParser = context.getResources().getLayout(layout);

                try {
                    final AttributeSet childAttrs = Xml.asAttributeSet(childParser);
                    //----------------省略了XML一些规则的判断----------------//
                    //获取子节点的名称
                    final String childName = childParser.getName();
                    if (TAG_MERGE.equals(childName)) {
                        //解析 Meger 标签
                        rInflate(childParser, parent, context, childAttrs, false);
                    } else {
                        //根据 name名称来创建View
                        final View view = createViewFromTag(parent, childName,
                                context, childAttrs, hasThemeOverride);
                        final ViewGroup group = (ViewGroup) parent;
                        //获取 View 的 id 和其 Visiable 属性
                        final TypedArray a = context.obtainStyledAttributes(
                                attrs, R.styleable.Include);
                        final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);
                        final int visibility = a.getInt(R.styleable.Include_visibility, -1);
                        a.recycle();

                        //需要将 Parent中的 LayoutParams 设置为其 Params 属性。
                        //如果 Parent 没有通用的 Params，那么就会抛出Runtime 异常

                        //然后会为其设置 include 包裹内容的通用 Params，

                        ViewGroup.LayoutParams params = null;
                        try {
                            params = group.generateLayoutParams(attrs);
                        } catch (RuntimeException e) {
                            // Ignore, just fail over to child attrs.
                        }
                        if (params == null) {
                            params = group.generateLayoutParams(childAttrs);
                        }
                        view.setLayoutParams(params);

                        // 解析子标签
                        rInflateChildren(childParser, view, childAttrs, true);

                        if (id != View.NO_ID) {
                            view.setId(id);
                        }

                        // 加载include内容时，需要直接设置其 可见性
                        switch (visibility) {
                            case 0:
                                view.setVisibility(View.VISIBLE);
                                break;
                            case 1:
                                view.setVisibility(View.INVISIBLE);
                                break;
                            case 2:
                                view.setVisibility(View.GONE);
                                break;
                        }
                        //添加至父容器中
                        group.addView(view);
                    }
                } finally {
                    childParser.close();
                }
            }
        } else {
            throw new InflateException(&quot;&lt;include /&gt; can only be used inside of a ViewGroup&quot;);
        }
</code></pre>

<p>这部分主要的作用是解析Include包裹layout的根标签：</p>

<h4 id="toc_54">（1）先特别处理Merge标签 ：</h4>

<p>如果子节点是Merge标签，那么直接进行内容的解析，调用rInflater()方法。</p>

<p>而rInflater()这个方法的作用是，解析某个节点，根据节点的不同类型从而进行不同的处理</p>

<h4 id="toc_55">（2）解析Include的内容：</h4>

<p>在这之前先通过createViewFromTag()方法，根据名称来生成相对应的View</p>

<p>这里分成两块内容<br/><br/>
<strong>第一块是设置LayoutParams</strong>：</p>

<pre class="line-numbers"><code class="language-text">ViewGroup.LayoutParams params = null;
try {
    //加载Include的父ViewGroup的LayoutParams
    params = group.generateLayoutParams(attrs);
} catch (RuntimeException e) {
    // Ignore, just fail over to child attrs.
}
if (params == null) {
    //加载Include的子ViewGroup的LayoutParams
    params = group.generateLayoutParams(childAttrs);
}
view.setLayoutParams(params);
</code></pre>

<p>这段的作用是为Include的包裹的根View设置LayoutParams，使用的LayoutParams默认是Include外层的ViewGroup。</p>

<p>如果此时Params加载失败，那就会使用Include包裹的ViewGroup的LayoutParams，反正怎么都得设置一个。</p>

<p><strong>第二块是在这里设置子ViewGroup的显隐性</strong>：</p>

<pre class="line-numbers"><code class="language-java">// 加载include内容时，需要直接设置其 可见性
switch (visibility) {
    case 0:
        view.setVisibility(View.VISIBLE);
        break;
    case 1:
        view.setVisibility(View.INVISIBLE);
        break;
    case 2:
        view.setVisibility(View.GONE);
        break;
}
//添加至父容器中
group.addView(view);
</code></pre>

<p>设置ViewGroup的显隐性，之后就将其添加至父View中，至此parseInclude的分析就到此结束。</p>

<h2 id="toc_56">流程图</h2>

<p><figure><img src="media/15561207871831/15713351149148.jpg" alt=""/></figure></p>

<h2 id="toc_57">效果</h2>

<p><figure><img src="media/15561207871831/15713351244735.jpg" alt=""/></figure></p>

<p><figure><img src="media/15561207871831/20171105150982283383132.gif" alt=""/></figure></p>

<h2 id="toc_58">分析</h2>

<p>这个效果属于视觉差的效果，原理是根据ViewPager的滑动方向，页面内物理做同向偏移，只要偏移距离大于页面的偏移，就会产生速度差，那么就会实现该效果。</p>

<p>实现速度差，我们需要一个滑动的比例系数：</p>

<p>在页面进入时：</p>

<p><code>页面物体的移动距离 = (页面长度 - 滑动距离) * 滑动系数</code></p>

<p>在页面滑出时：</p>

<p><code>页面物体的移动距离 = （0 - 滑动距离 ） * 滑动系数</code></p>

<p>同时考虑第二张Gif上，发现物体Y轴也存在移动，所以也得需要考虑Y轴方向的滑动，整理下：</p>

<pre class="line-numbers"><code class="language-text">//进入时：
view.setTranslateX((vpWidth - positionOffsetPixels) * xIn);
view.setTranslateY((vpWidth - positionOffsetPixels) * yIn);

//退出时
view.setTranslateX((0 - positionOffsetPixels) * xOut);
view.setTranslateY((0 - positionOffsetPixels) * yOut);
</code></pre>

<p>这样就可以实现出：</p>

<ul>
<li>进入该界面时，界面上的物品快速飞进来。</li>
<li>退出该界面时，界面上的物理快速飞出去。</li>
</ul>

<h2 id="toc_59">实现思路</h2>

<p>对于上述的分析，这里的实现思路存在两种：</p>

<ol>
<li>自定义View，自定义xIn、yIn、xOut、yOut四个属性的系数，所有界面上的物体继承这个自定义View。</li>
<li>自定义LayoutInflater.Factory在解析时，将这些自定义属性提取，以Tag方式储存起来。</li>
</ol>

<h2 id="toc_60">优缺点分析</h2>

<p><strong>自定义View</strong>：</p>

<p>优点：可以对物体做更多层面的扩展，这个自定义LayoutInflater.Factory是不具备的。</p>

<p>缺点：由于界面的物体数量过多，在findViewById时需要处理的View元素过多，极大的增加代码量。</p>

<p><strong>自定义LayoutInflater.Factory</strong> :</p>

<p>优点：可以在解析过程中对View做统一操作，当出现大量的View时，能够缩减大量代码。</p>

<p>缺点：在解析时预处理View，但是就不能动态的改变View的属性，要对View进行扩展性操作，自定义LayoutInflater.Factory不具备这样的功能。</p>

<p><strong>自定义LayoutInflater.Factory</strong></p>

<p>上述的两种方案的优缺点已经分析完毕，但是本文作为实战篇，所以只会介绍自定义LayoutInflater.Factory这种方式。</p>

<p>在实际场景中，需要结合自身情况，以及上述的优缺点，进行合理选择。</p>

<p>在介绍之前，先看一段代码：</p>

<pre class="line-numbers"><code class="language-java">View view;
//如果Factory2存在，就会调用其onCreateView方法
if (mFactory2 != null) {
    view = mFactory2.onCreateView(parent, name, context, attrs);
    //如果Factory存在，就会调用其onCreateView方法，和Factory2不同的时，这里的参数没有父View
} else if (mFactory != null) {
    view = mFactory.onCreateView(name, context, attrs);
} else {
    view = null;
}
//如果没有Factory或者Factory2，就会寻找mPrivateFactory（本质上也是Factory2）
if (view == null &amp;&amp; mPrivateFactory != null) {
    view = mPrivateFactory.onCreateView(parent, name, context, attrs);
}
</code></pre>

<p>这段代码出自LayoutInflater中createViewFromTag()方法，作用是根据View的名称（name参数）来创建View.</p>

<p>在这里就简单描述下，这个方法的主要流程：</p>

<ul>
<li>对一些特殊标签，做分别处理，例如：view，TAG_1995(blink)</li>
<li>进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View</li>
<li>如果没有设置Factory或Factory2，那么就会使用LayoutInflater默认的生成方式，进行View的生成</li>
</ul>

<p>在实战篇中，只有第二部分和我们今天的内容是相关的，我们在看一遍第二条。</p>

<p><code>进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View</code></p>

<p>如果设置了Factory或者Factory2，那么就不会使用LayoutInflater默认的生成方式，那么生成View的过程，就由我们自主把控，这才是我们自定义LayoutInflater.Factory的主要原因。</p>

<h2 id="toc_61">自定义Factory还是Factory2 ？</h2>

<pre class="line-numbers"><code class="language-java">View view;
//如果Factory2存在，就会调用其onCreateView方法
if (mFactory2 != null) {
    view = mFactory2.onCreateView(parent, name, context, attrs);
    //如果Factory存在，就会调用其onCreateView方法，和Factory2不同的时，这里的参数没有父View
} else if (mFactory != null) {
    view = mFactory.onCreateView(name, context, attrs);
} else {
    view = null;
}
</code></pre>

<p>我们能够从这段代码中得出，Factory2比Factory的优先级要高，即Factory2存在Factory就不可能会被调用，同理可以得出结论：</p>

<pre class="line-numbers"><code class="language-text">优先级顺序:

mFactory2  &gt; mFactory &gt; mPrivateFactory &gt; LayoutInflater默认处理方式
</code></pre>

<p>而且我们还能够发现mFactory2的onCreateView()方法与mFactory是不相同的：</p>

<pre class="line-numbers"><code class="language-text">//mFactory2
mFactory2.onCreateView(parent, name, context, attrs);

//mFactory
view = mFactory.onCreateView(name, context, attrs);
</code></pre>

<p>根据上述的分析，我们可以得出结论：</p>

<pre class="line-numbers"><code class="language-text">(1)Factory2的调用优先级比Factory要高

(2)Factory2的onCreateView()方法，会比Factory多返回一个父View的参数。

(3)Factory2和Factory是互斥的，（如果不通过反射的话）只能设置一个。
</code></pre>

<p>第三条在CreateViewFromTag的那篇文章已经分析过了，这里不做过多的解释了。</p>

<p>实际选择的过程中，一般会选择自定义Factory2，因为Factory2本身也继承了Factory接口，而且Factory2的优先级比较高。</p>

<h2 id="toc_62">注意事项</h2>

<h3 id="toc_63">设置Factory但是发现无响应，是因为本身LayoutInflater中存在Factory2</h3>

<p>因为一般使用方式，是直接调用cloneInContext()方法，我们知道一般的默认解析器都是PhoneLayoutInflater，我们看下其实现方式：</p>

<pre class="line-numbers"><code class="language-java">protected PhoneLayoutInflater(LayoutInflater original, Context newContext) {
    super(original, newContext);
}
</code></pre>

<p>本质就是调用LayoutInflater的两参构造方法：</p>

<pre class="line-numbers"><code class="language-java">protected LayoutInflater(LayoutInflater original, Context newContext) {
    mContext = newContext;
    mFactory = original.mFactory;
    mFactory2 = original.mFactory2;
    mPrivateFactory = original.mPrivateFactory;
    setFilter(original.mFilter);
}
</code></pre>

<p>在这里可以看出，cloneInContext会把原LayoutInflater的Factory2和Factory一并复制。</p>

<p>因为Factory比Factory2的优先级低，所以才会不出现效果。</p>

<p><strong>解决方案</strong> ：</p>

<p>（1）自定义LayoutInflater，并且改写cloneInContext，使其不复制原LayoutInflater的Factory2以及Factory。</p>

<pre class="line-numbers"><code class="language-java">public class CustomLayoutInflater extends LayoutInflater {

    protected CustomLayoutInflater(Context context) {
        super(context);
    }

    @Override
    public LayoutInflater cloneInContext(Context newContext) {
        return new CustomLayoutInflater(newContext);
    }
}
</code></pre>

<p>（2）使用时，直接通过new出实例，然后setFactory</p>

<pre class="line-numbers"><code class="language-java">CustomLayoutInflater newInflater = new CustomLayoutInflater(getActivity());
newInflater.setFactory2(new CustomAppFactory(newInflater, this));
return newInflater.inflate(layoutId, null);
</code></pre>

<h3 id="toc_64">使用AppCompatActivity直接setFactory2或者setFactory为什么报错？</h3>

<p>这是因为 AppCompatActivity 在初始化的时候，已经设置了 Factory，下面来看下这部分代码</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    final AppCompatDelegate delegate = getDelegate();
    //注意这个方法
    delegate.installViewFactory();
    delegate.onCreate(savedInstanceState);
    //.....省略多余的代码..........
    super.onCreate(savedInstanceState);
}
</code></pre>

<p>继续查看 installViewFactory（）方法</p>

<pre class="line-numbers"><code class="language-java">@Override
public void installViewFactory() {
    LayoutInflater layoutInflater = LayoutInflater.from(mContext);
    if (layoutInflater.getFactory() == null) {
        //这句话是设置 Factory 的方法
        LayoutInflaterCompat.setFactory(layoutInflater, this);
    } else {
        //省略部分代码。。。。。。      
    }
}
</code></pre>

<p>可以发现，在onCreate 时 LayoutInflater 已经设置过一次 Factory 了，然后我再来看下 setFactory() 的源码：</p>

<pre class="line-numbers"><code class="language-java">public void setFactory(Factory factory) {
    if (mFactorySet) {
        //原因就是这一句
        throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;);
    }
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = factory;
    } else {
        mFactory = new FactoryMerger(factory, null, mFactory, mFactory2);
    }
}
</code></pre>

<p>根据上面代码，就可以发现报错原因了。</p>

<p><strong>解决方案</strong> ：</p>

<p>在使用前，先使用 cloneInContext()克隆出一个新的 LayoutInflater，然后在进行设置操作。</p>

<pre class="line-numbers"><code class="language-java">LayoutInflate  newInflater = LayoutInflater.cloneInContext(inflater,context);

newInflater.setFactory(new CustomFactory（）)；
</code></pre>

<p>这样就避开在原 LayoutInflater 设置 Factory 报错了。</p>

<h2 id="toc_65">自定义Factory2的实现 ——&gt; CustomAppFactory</h2>

<p>根据上面的展示效果，我们可以判断出是ViewPager + Fragment的风格，所以我们自定义Factory应该在Fragment的onCreateView中，更改LayoutInflater。</p>

<p>而且根据注意事项，我们一般会自定义优先级较高的Factory2，防止本身cloneInContext的LayoutInflater中已经存在Factory2，我们使用Factory会无效。</p>

<h3 id="toc_66">使用方式</h3>

<pre class="line-numbers"><code class="language-java">public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
    Bundle bundle = getArguments();
    int layoutId = bundle.getInt(LAYOUT_ID);
    //注意需要调用cloneInContext方法生成新的LayoutInflater
    LayoutInflater newInflater = inflater.cloneInContext(getActivity());
    //调用的是setFactory2而非setFactory
    newInflater.setFactory2(new CustomAppFactory(newInflater, this));
    return newInflater.inflate(layoutId, null);
}
</code></pre>

<h3 id="toc_67">自定义过程</h3>

<p>那么就创建一个类CustomAppFactory来实现Factory2的接口，复写onCreateView的方法。</p>

<pre class="line-numbers"><code class="language-java">@Override
public View onCreateView(String name, Context context, AttributeSet attrs) {
    View view = null;
    //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;第一部分&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
    try {
        if (name.contains(&quot;.&quot;)) {
            String checkName = name.substring(name.lastIndexOf(&quot;.&quot;));
            String prefix = name.substring(0, name.lastIndexOf(&quot;.&quot;));
            view = defaultInflater(checkName, prefix, attrs);
        }
        if (name.equals(&quot;View&quot;) || name.equals(&quot;ViewGroup&quot;)) {
            view = defaultInflater(name, sClassPrefix[1], attrs);
        } else {
            view = defaultInflater(name, sClassPrefix[0], attrs);
        }
        //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;第二部分&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
        //实例化完成
        if (view != null) {
            //获取自定义属性,通过标签关联到视图上
            setViewTag(view, context, attrs);
            mInflaterView.addView(view);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return view;
}

@Override
public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
    View view = onCreateView(name, context, attrs);
    return view;
}
</code></pre>

<p>其实如果我们采取自定义的方式，这里只会调用onCreateView()四位参数的方法，因为在比较Factory2和Factory的代码也介绍过了。</p>

<p>我们实现的逻辑是在onCreateView()三位逻辑里面，因为需要实现的效果不需要Parent（父View），所以这里逻辑实现全在三位参数的onCreateView()中。</p>

<p>在这里我们将onCreateView()中，分成2部分内容：</p>

<ul>
<li>根据名称解析出View</li>
<li>扩展操作，将额外的属性，提取出来储存在Tag中</li>
</ul>

<h2 id="toc_68">onCreateView第一部分内容</h2>

<pre class="line-numbers"><code class="language-java">if (name.contains(&quot;.&quot;)) {
    String checkName = name.substring(name.lastIndexOf(&quot;.&quot;));
    String prefix = name.substring(0, name.lastIndexOf(&quot;.&quot;));
    view = defaultInflater(checkName, prefix, attrs);
}
if (name.equals(&quot;View&quot;) || name.equals(&quot;ViewGroup&quot;)) {
    view = defaultInflater(name, sClassPrefix[1], attrs);
} else {
    view = defaultInflater(name, sClassPrefix[0], attrs);
}
</code></pre>

<p>这里判断了name中是否包含“.”，是用来判断生成的View是否是自定义View，下面来看下自定义View和Android自带的组件的区别：</p>

<pre class="line-numbers"><code class="language-text">//原生的组件
RelativeLayout
//自定义View
com.demo.guidepagedemo.customview.CustomImageView
</code></pre>

<p>可以发现区别为原生的View不带前缀，而自定义View是包括前缀的，所以会用name.contains(“.”)来区分。</p>

<p>而原生组件中View和ViewGroup是属于android.view包下，其他的例如：RelativeLayout，LinearLayout是属于android.widget包下。</p>

<pre class="line-numbers"><code class="language-text">private final String[] sClassPrefix = {
    &quot;android.widget.&quot;,
    &quot;android.view.&quot;
};
</code></pre>

<p>所以在之后会对View和ViewGroup作区分，上面把sClassPrefix贴出来了。</p>

<p>而这里真正的解析过程最后还是交给LayoutInflater，调用LayoutInflater的onCreateView方法：</p>

<pre class="line-numbers"><code class="language-java">private View defaultInflater(String name, String prefix, AttributeSet attrs) {
    View view = null;
    try {
        view = mInflater.createView(name, prefix, attrs);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    return view;
}
</code></pre>

<h2 id="toc_69">onCreateView第二部分内容</h2>

<pre class="line-numbers"><code class="language-java">//实例化完成
if (view != null) {
    //获取自定义属性,通过标签关联到视图上
    setViewTag(view, context, attrs);
    mInflaterView.addView(view);
}
</code></pre>

<p>在这里做拓展处理的，setViewTag方法是处理View的自定义属性，然后将这些属性包装成类，给View设置Tag</p>

<p><strong>setViewTag方法</strong></p>

<pre class="line-numbers"><code class="language-java">/**
 * 将View的属性信息存储在Tag中
 */
private void setViewTag(View view, Context context, AttributeSet attrs) {
    //解析自定义的属性
    TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.CustomImageView);
    if (attrs != null &amp;&amp; array.length() &gt; 0) {
        AttrTagBean bean = new AttrTagBean();
        bean.xIn = array.getFloat(R.styleable.CustomImageView_in_value_x, 0f);
        bean.xOut = array.getFloat(R.styleable.CustomImageView_out_value_x, 0f);
        bean.yIn = array.getFloat(R.styleable.CustomImageView_in_value_y, 0f);
        bean.yOut = array.getFloat(R.styleable.CustomImageView_out_value_y, 0f);
        //index
        view.setTag(bean);
    }
    array.recycle();
}
</code></pre>

<p>上面对应的是本文我们开始设置的4个系数：</p>

<pre class="line-numbers"><code class="language-java">R.styleable.CustomImageView_in_value_x              --&gt;   进入时 x方向的系数

R.styleable.CustomImageView_out_value_x             --&gt;   退出时 x方向的系数

R.styleable.CustomImageView_in_value_y              --&gt;   进入时 y方向的系数

R.styleable.CustomImageView_out_value_y             --&gt;   退出时 y方向的系数
</code></pre>

<p>而这里的mInflaterView是一个抽象接口，让Fragment来实现的，通过在Fragment中内置一个List《View》，到时候可以遍历统一操作这些View，下面是实现过程：</p>

<pre class="line-numbers"><code class="language-java">public interface InflaterViewImpl {

    /**
     * 获取View集合
     *
     * @return
     */
    List&lt;View&gt; getViews();


    /**
     * 添加元素
     */
    void addView(View view);
}
</code></pre>

<p><strong>Fragment中的实现过程</strong>：</p>

<pre class="line-numbers"><code class="language-java">public class PageFragment extends Fragment implements InflaterViewImpl {

    private List&lt;View&gt; views = new ArrayList&lt;&gt;();

    //**************篇幅原因省略了部分方法************************//

    @Override
    public List&lt;View&gt; getViews() {
        return views;
    }

    @Override
    public void addView(View view) {
        if (views.contains(view)) {
            return;
        }
        views.add(view);
    }
}
</code></pre>

<h2 id="toc_70">处理ViewPager的滑动</h2>

<p>这是实战篇的最后一部分内容，主要介绍的是ViewPager的滑动监听相关的处理，因为所有效果是基于ViewPager的滑动监听来显示的。</p>

<p>因为本文主要介绍内容是自定义LayoutInflater.Factory，所以这里会简单叙述下：</p>

<pre class="line-numbers"><code class="language-java">mInflaterVp.addOnPageChangeListener(new 
ViewPager.OnPageChangeListener() {
    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        //获取ViewPager的宽度
        int vpWidth = mInflaterVp.getWidth();
        //获取正在进入的界面
        PageFragment inFragment = getPosition(position - 1);
        if (inFragment != null) {
            List&lt;View&gt; views = inFragment.getViews();
            if (views != null &amp;&amp; views.size() &gt; 0) {
            for (View view : views) {
                AttrTagBean tag = (AttrTagBean) view.getTag();
                if (tag != null) {
                    view.setTranslationX((vpWidth - positionOffsetPixels) * tag.xIn);
                    view.setTranslationY((vpWidth - positionOffsetPixels) * tag.yIn);
                }
            }
        }
    }

    //当前正在滑动的界面
    PageFragment outFragment = getPosition(position);
    if (outFragment != null) {
        List&lt;View&gt; views = outFragment.getViews();
        if (views != null &amp;&amp; views.size() &gt; 0) {
            for (View view : views) {
                AttrTagBean tag = (AttrTagBean) view.getTag();
                if (tag != null) {
                    view.setTranslationX((0 - positionOffsetPixels) * tag.xOut);
                    view.setTranslationY((0 - positionOffsetPixels) * tag.yOut);
                }
            }
        }
    }


    @Override
    public void onPageSelected(int position) {
        //当划到最后一页时，小人的图标消失
        if (position == fragments.size() - 1) {
            mInflaterIv.setVisibility(View.GONE);
        } else {
            mInflaterIv.setVisibility(View.VISIBLE);
        }
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        //这里是处理图中的小人的帧动画过程
        Drawable anim = mInflaterIv.getBackground();
        if (!(anim instanceof AnimationDrawable)) {
            return;
        }
        AnimationDrawable animation = (AnimationDrawable) anim;
        Log.d(&quot;滑动状态&quot;, state + &quot;&quot;);
        switch (state) {
            //空闲状态
            case ViewPager.SCROLL_STATE_IDLE:
                animation.stop();
                break;
            //拖动状态
            case ViewPager.SCROLL_STATE_DRAGGING:
                animation.start();
                break;
            //惯性滑动状态
            case ViewPager.SCROLL_STATE_SETTLING:
                break;
        }
    }
});
</code></pre>

<p><strong>小红书引导页</strong></p>

<p><figure><img src="media/15561207871831/20171105150982288981203.gif" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871789.html">
                
                  <h1>Android-Camera和Matrix实现真正的3D(WheelView)日期,地址选择滚轮控件</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Camera和Matrix实现真正的3D(WheelView)日期,地址选择滚轮控件</p>

<h2 id="toc_1">先看效果图</h2>

<p><figure><img src="media/15561207871789/2017110515098153104205.gif" alt=""/></figure></p>

<p>垂直方向的3D旋转</p>

<p><figure><img src="media/15561207871789/2017110515098153351203.gif" alt=""/></figure></p>

<p>水平方向的3D旋转</p>

<h2 id="toc_2">功能分析</h2>

<h3 id="toc_3">3D旋转效果</h3>

<p>WheelView的实现方式已经有很多种方式, 而且网上也有实现好的旋转效果,不过只是2D的旋转,而且要处理滑动与单击item事件比较复杂,真正的旋转是要通过Matrix, Camera类来实现,这里的Camera不是照相机里的API,Camera可以实现x,y,z轴的旋转,不清楚的可以去也解这些API的使用, 这里不详细介绍, 配合RecyclerView.ItemDecoration,在每个item中将Canvas进行3D旋转并平移,产生3D视觉效果</p>

<p>这里拿垂直布局的一种状态来做示例</p>

<pre class="line-numbers"><code class="language-java">    /**
     * 画垂直布局时的item
     * @param c
     * @param rect
     * @param position
     * @param parentCenterX RecyclerView的中心X点
     * @param parentCenterY RecyclerView的中心Y点
     */
    void drawVerticalItem(Canvas c, Rect rect, int position, float parentCenterX, float parentCenterY) {
        int realPosition = position - itemCount;//数据中的实际位置
        float itemCenterY = rect.exactCenterY();
        float scrollOffY = itemCenterY - parentCenterY;
        float rotateDegreeX = scrollOffY * itemDegree / itemSize;//垂直布局时要以X轴为中心旋转
        int alpha = degreeAlpha(rotateDegreeX);
        if (alpha &lt;= 0) return;
        float rotateSinX = (float) Math.sin(Math.toRadians(rotateDegreeX));
        float rotateOffY = scrollOffY - wheelRadio * rotateSinX;//因旋转导致界面视角的偏移
        //Log.i(&quot;you&quot;, &quot;drawVerticalItem degree &quot; + rotateDegreeX);
        //计算中心item, 优先最靠近中心区域的为中心点
        boolean isCenterItem = false;
        if (!hasCenterItem) {
            isCenterItem = Math.abs(scrollOffY) &lt;= halfItemHeight;
            if (isCenterItem) {
                centerItemPosition = realPosition;
                hasCenterItem = true;
            }
        }
        //这里是旋转操作的核心,每个item在旋转成弧时，都要将item的中心在旋转后给人的视觉上的偏移计算好
        c.save();
        c.translate(0.0f, -rotateOffY);
        camera.save();
        camera.rotateX(-rotateDegreeX);
        camera.getMatrix(matrix);
        camera.restore();
        matrix.preTranslate(-parentCenterX, -itemCenterY);
        matrix.postTranslate(parentCenterX, itemCenterY);
        c.concat(matrix);
        drawItem(c, rect, realPosition, alpha, isCenterItem, true);
        c.restore();
    }
</code></pre>

<p>到这里基本已经实现了每个item距离中心点的旋转效果,接下来就是添加WheelView显示的数量在RecyclerView头与尾部的空的item</p>

<h3 id="toc_4">适配器定义</h3>

<p>滑动的时候,item要能滑动距中心点以上,也可以滑动到中心点以下,所以适配器中的item数量也要对应改变,直接上代码</p>

<pre class="line-numbers"><code class="language-java">class WheelViewAdapter extends RecyclerView.Adapter&lt;WheelViewHolder&gt; {

    ...伪代码

    @Override
    public void onBindViewHolder(WheelViewHolder holder, int position) {
    //由于里面的文本全是画的,这里只是绑定最原始的View
    }

    @Override
    public int getItemCount() {
      //  这里的totalItemCount就是滑轮控件距离中心点显示的item个数 乘2
        return totalItemCount + (adapter == null ? 0 : adapter.getItemCount());
    }

    @Override
    public WheelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        //适配器里根据垂直或水平布局显示
        View view = new View(parent.getContext());
        view.setLayoutParams(WheelUtils.createLayoutParams(orientation, itemSize));
        return new WheelViewHolder(view);
    }
}
</code></pre>

<h2 id="toc_5">总结：</h2>

<p>WheelView具体使用方法,示例代码中都有详细介绍,由于工作忙没有时间详细介绍里面的内容，源码里都有适当的注释，也可以一起讨论更佳的效果</p>

<p>后面有空再加上item点击与左右偏移时的立体效果,还有封装日期选择等...</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871754.html">
                
                  <h1>Android-实现dialog的3D翻转</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">效果图</h2>

<p>本文实现了 Android 中 dialog 的 3D 翻转效果。这里通过一个简单的应用场景记录下。</p>

<p><figure><img src="media/15561207871754/20171105150981489051639.gif" alt=""/></figure></p>

<h2 id="toc_1">分析</h2>

<blockquote>
<p>起初自己的思路是 Activity 进行界面跳转实现旋转效果，网上看了很多，写下来发现效果不对。之后又看到 Google 上面的 Card Flid Animation 效果是这样的。</p>
</blockquote>

<p><figure><img src="media/15561207871754/201711051509814926496.gif" alt=""/></figure></p>

<p>看着确实不错，然而拿下来 demo 放慢翻转速度后发现，不是我想要的。但是跟我看到的一个 app 里面的效果一样<br/>
然后想改成 dialog 试试效果，发现更是不行了。</p>

<blockquote>
<p>Card Flid Animation效果如下：<br/><br/>
这个是通过Activity来切换Fragment实现的，可以看到区别是翻转时候貌似会变大，其实没用，只是翻转后的视觉问题。</p>
</blockquote>

<p><figure><img src="media/15561207871754/20171105150981496621515.gif" alt=""/></figure></p>

<p>听说 openGl 比较麻烦，并且没有用过。然后就搜了下Rotate3DAnimaitons。<br/>
搜到了<a href="http://blog.csdn.net/growing_tree/article/details/50428148">这篇文章</a><br/>
所以这篇文章里的实现方法不是我的原创，是参考人家的。在这里感谢这位大神。<br/>
不过他这个是 activity 里的，我就想要一个 dialog 效果，因为电脑上TIM 的打开红包这个 3D 效果看着不错，其实大同小异，就拿过来改成Dialog。<br/>
对于 Rotate3DAnimaitons 这篇文章已经很详细了，有需要的可以参考下。</p>

<p><strong>Rotate3dAnimation</strong></p>

<pre class="line-numbers"><code class="language-java">/**
 * An animation that rotates the view on the Y axis between two specified angles.
 * This animation also adds a translation on the Z axis (depth) to improve the effect.
 */
public class Rotate3dAnimation extends Animation {
    private final float mFromDegrees;
    private final float mToDegrees;
    private final float mCenterX;
    private final float mCenterY;
    private final float mDepthZ;
    private final boolean mReverse;
    private Camera mCamera;

    /**
     * Creates a new 3D rotation on the Y axis. The rotation is defined by its
     * start angle and its end angle. Both angles are in degrees. The rotation
     * is performed around a center point on the 2D space, definied by a pair
     * of X and Y coordinates, called centerX and centerY. When the animation
     * starts, a translation on the Z axis (depth) is performed. The length
     * of the translation can be specified, as well as whether the translation
     * should be reversed in time.
     *
     * @param fromDegrees the start angle of the 3D rotation //起始角度
     * @param toDegrees the end angle of the 3D rotation //结束角度
     * @param centerX the X center of the 3D rotation //x中轴线
     * @param centerY the Y center of the 3D rotation //y中轴线
     * @param reverse true if the translation should be reversed, false otherwise//是否反转
     */
    public Rotate3dAnimation(float fromDegrees, float toDegrees,
            float centerX, float centerY, float depthZ, boolean reverse) {
        mFromDegrees = fromDegrees;
        mToDegrees = toDegrees;
        mCenterX = centerX;
        mCenterY = centerY;
        mDepthZ = depthZ;//Z轴移动的距离，这个来影响视觉效果，可以解决flip animation那个给人看似放大的效果
        mReverse = reverse;
    }

    @Override
    public void initialize(int width, int height, int parentWidth, int parentHeight) {
        super.initialize(width, height, parentWidth, parentHeight);
        mCamera = new Camera();
    }

    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        final float fromDegrees = mFromDegrees;
        float degrees = fromDegrees + ((mToDegrees - fromDegrees) * interpolatedTime);

        final float centerX = mCenterX;
        final float centerY = mCenterY;
        final Camera camera = mCamera;

        final Matrix matrix = t.getMatrix();

        Log.i(&quot;interpolatedTime&quot;, interpolatedTime+&quot;&quot;);
        camera.save();
        if (mReverse) {
            camera.translate(0.0f, 0.0f, mDepthZ * interpolatedTime);
        } else {
            camera.translate(0.0f, 0.0f, mDepthZ * (1.0f - interpolatedTime));
        }
        camera.rotateY(degrees);
        camera.getMatrix(matrix);
        camera.restore();

        matrix.preTranslate(-centerX, -centerY);
        matrix.postTranslate(centerX, centerY);
    }
}
</code></pre>

<h2 id="toc_2">dialog实现3D翻转代码</h2>

<pre class="line-numbers"><code class="language-java">public class MyDialog extends Dialog {

    @BindView(R.id.et_user_name)
    EditText etUserName;
    @BindView(R.id.et_password)
    EditText etPassword;
    @BindView(R.id.cb_auto_login)
    CheckBox cbAutoLogin;
    @BindView(R.id.tv_forget_pwd)
    TextView tvForgetPwd;
    @BindView(R.id.ll_content)
    LinearLayout llContent;
    @BindView(R.id.et_email)
    EditText etEmail;
    @BindView(R.id.btn_back)
    Button btnBack;
    @BindView(R.id.container)
    RelativeLayout container;
    private Context context;

    @BindView(R.id.ll_register)
    LinearLayout llRegister;

    //接口回调传递参数
    private OnClickListenerInterface mListener;
    private View view;
//
    private String strContent;

    private int centerX;
    private int centerY;
    private int depthZ = 700;//修改此处可以改变距离来达到你满意的效果
    private int duration = 300;//动画时间
    private Rotate3dAnimation openAnimation;
    private Rotate3dAnimation closeAnimation;

    private boolean isOpen = false;

    public interface OnClickListenerInterface {

        /**
         * 确认,
         */
        void doConfirm();

        /**
         * 取消
         */
//        public void doCancel();
    }

    public MyDialog(Context context) {
        super(context);
        this.context = context;
    }

    public MyDialog(Context context, String content) {
        super(context);
        this.context = context;
        this.strContent = content;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        //去掉系统的黑色矩形边框
        getWindow().setBackgroundDrawableResource(android.R.color.transparent);
        requestWindowFeature(Window.FEATURE_NO_TITLE);

        init();
    }

    public void init() {
        LayoutInflater inflater = LayoutInflater.from(context);
        view = inflater.inflate(R.layout.dialog_my, null);
        setContentView(view);
        ButterKnife.bind(this);
        etPassword.setTypeface(Typeface.DEFAULT);
        etPassword.setTransformationMethod(new PasswordTransformationMethod());
        tvForgetPwd.setOnClickListener(new OnWidgetClickListener());
        btnBack.setOnClickListener(new OnWidgetClickListener());
        Window dialogWindow = getWindow();
        WindowManager.LayoutParams lp = dialogWindow.getAttributes();
        DisplayMetrics d = context.getResources().getDisplayMetrics(); // 获取屏幕宽、高用
        lp.width = (int) (d.widthPixels * 0.8); // 宽度设置为屏幕的0.8
        lp.height = (int) (d.heightPixels * 0.6); // 高度设置为屏幕的0.6
        dialogWindow.setAttributes(lp);
        setCanceledOnTouchOutside(false);
        setCancelable(true);
    }

    public void setClicklistener(OnClickListenerInterface clickListenerInterface) {
        this.mListener = clickListenerInterface;
    }

    private class OnWidgetClickListener implements View.OnClickListener {
        @Override
        public void onClick(View v) {

            int id = v.getId();
            switch (id) {
                case R.id.tv_forget_pwd:
                    startAnimation();
                    break;
                case R.id.btn_back:
                    startAnimation();
                    break;
            }
        }
    }

    private void startAnimation() {
        //接口回调传递参数
        centerX = container.getWidth() / 2;
        centerY = container.getHeight() / 2;
        if (openAnimation == null) {
            initOpenAnim();
            initCloseAnim();
        }

        //用作判断当前点击事件发生时动画是否正在执行
        if (openAnimation.hasStarted() &amp;&amp; !openAnimation.hasEnded()) {
            return;
        }
        if (closeAnimation.hasStarted() &amp;&amp; !closeAnimation.hasEnded()) {
            return;
        }

        //判断动画执行
        if (isOpen) {

            container.startAnimation(openAnimation);

        } else {

            container.startAnimation(closeAnimation);

        }
        isOpen = !isOpen;
    }

    /**
     *注意旋转角度
     */
    private void initOpenAnim() {
        //从0到90度，顺时针旋转视图，此时reverse参数为true，达到90度时动画结束时视图变得不可见，
        openAnimation = new Rotate3dAnimation(0, 90, centerX, centerY, depthZ, true);
        openAnimation.setDuration(duration);
        openAnimation.setFillAfter(true);
        openAnimation.setInterpolator(new AccelerateInterpolator());
        openAnimation.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                llRegister.setVisibility(View.GONE);
                llContent.setVisibility(View.VISIBLE);
                //从270到360度，顺时针旋转视图，此时reverse参数为false，达到360度动画结束时视图变得可见
                Rotate3dAnimation rotateAnimation = new Rotate3dAnimation(270, 360, centerX, centerY, depthZ, false);
                rotateAnimation.setDuration(duration);
                rotateAnimation.setFillAfter(true);
                rotateAnimation.setInterpolator(new DecelerateInterpolator());
                container.startAnimation(rotateAnimation);
            }
        });
    }

    private void initCloseAnim() {
        closeAnimation = new Rotate3dAnimation(360, 270, centerX, centerY, depthZ, true);
        closeAnimation.setDuration(duration);
        closeAnimation.setFillAfter(true);
        closeAnimation.setInterpolator(new AccelerateInterpolator());
        closeAnimation.setAnimationListener(new Animation.AnimationListener() {

            @Override
            public void onAnimationStart(Animation animation) {

            }

            @Override
            public void onAnimationRepeat(Animation animation) {

            }

            @Override
            public void onAnimationEnd(Animation animation) {
                llRegister.setVisibility(View.VISIBLE);
                llContent.setVisibility(View.GONE);
                Rotate3dAnimation rotateAnimation = new Rotate3dAnimation(90, 0, centerX, centerY, depthZ, false);
                rotateAnimation.setDuration(duration);
                rotateAnimation.setFillAfter(true);
                rotateAnimation.setInterpolator(new DecelerateInterpolator());
                container.startAnimation(rotateAnimation);
            }
        });
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871715.html">
                
                  <h1>Android-SpannableString与SpannableStringBuilder</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">概述</h2>

<h3 id="toc_1">SpannableString、SpannableStringBuilder与String的关系</h3>

<p>首先SpannableString、SpannableStringBuilder基本上与String差不多，也是用来存储字符串，但它们俩的特殊就在于有一个SetSpan（）函数，能给这些存储的String添加各种格式或者称样式（Span），将原来的String以不同的样式显示出来，比如在原来String上加下划线、加背景色、改变字体颜色、用图片把指定的文字给替换掉，等等。所以，总而言之，SpannableString、SpannableStringBuilder与String一样， 首先也是传字符串，但SpannableString、SpannableStringBuilder可以对这些字符串添加额外的样式信息，但String则不行。<br/><br/>
注意：如果这些额外信息能被所用的方式支持，比如将SpannableString传给TextView；也有对这些额外信息不支持的，比如前一章讲到的Canvas绘制文字，对于不支持的情况，SpannableString和SpannableStringBuilder就是退化为String类型，直接显示原来的String字符串，而不会再显示这些附加的额外信息。  </p>

<h3 id="toc_2">SpannableString与SpannableStringBuilder区别</h3>

<p>它们的区别在于 SpannableString像一个String一样，构造对象的时候传入一个String，之后再无法更改String的内容，也无法拼接多个 SpannableString；而SpannableStringBuilder则更像是StringBuilder，它可以通过其append()方法来拼接多个String：</p>

<pre class="line-numbers"><code class="language-java">//使用SpannableString，必须一次传入，构造完成  
SpannableString word = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);  
  
//使用SpannableStringBuilder,可以使用append()再添加  
SpannableStringBuilder multiWord = new SpannableStringBuilder();  
multiWord.append(&quot;欢迎光临&quot;);  
multiWord.append(&quot;Harvic的&quot;);  
multiWord.append(&quot;博客&quot;);  
</code></pre>

<p><figure><img src="media/15561207871715/15713660426208.png" alt=""/></figure></p>

<p>因为Spannable等最终都实现了CharSequence接口，所以可以直接把SpannableString和SpannableStringBuilder通过TextView.setText()设置给TextView。</p>

<h3 id="toc_3">SetSpan（）</h3>

<p><code>void setSpan (Object what, int start, int end, int flags)</code></p>

<p>函数意义：给SpannableString或SpannableStringBuilder特定范围的字符串设定Span样式，可以设置多个（比如同时加上下划线和删除线等），Falg参数标识了当在所标记范围前和标记范围后紧贴着插入新字符时的动作，即是否对新插入的字符应用同样的样式。（这个后面会具体举例说明）</p>

<p><strong>参数说明</strong>：</p>

<ul>
<li>object what ：对应的各种Span，后面会提到；</li>
<li>int start：开始应用指定Span的位置，索引从0开始</li>
<li>int end：结束应用指定Span的位置，特效并不包括这个位置。比如如果这里数为3（即第4个字符），第4个字符不会有任何特效。从下面的例子也可以看出来。</li>
<li>int flags：取值有如下四个</li>
<li>Spannable.SPAN_EXCLUSIVE_EXCLUSIVE：前后都不包括，即在指定范围的前面和后面插入新字符都不会应用新样式 </li>
<li>Spannable.SPAN_EXCLUSIVE_INCLUSIVE    ：前面不包括，后面包括。即仅在范围字符的后面插入新字符时会应用新样式</li>
<li>Spannable.SPAN_INCLUSIVE_EXCLUSIVE    ：前面包括，后面不包括。</li>
<li>Spannable.SPAN_INCLUSIVE_INCLUSIVE    ：前后都包括。</li>
</ul>

<p>举个例子来说明这个前后包括的问题：<br/>
由于Flag的作用是用来指定范围前后输入新的字符时，会不会应用效果的，所以我们利用EditText来显示SpannableString</p>

<p>(1)、布局XML中加入一个EditText控件：</p>

<pre class="line-numbers"><code class="language-markup">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    tools:context=&quot;com.example.try_spannable_blog.MainActivity&quot; &gt;  
  
    &lt;EditText  
        android:id=&quot;@+id/edit&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot; /&gt;  
  
&lt;/RelativeLayout&gt;  
</code></pre>

<p>（2）、这里用一个改变字体颜色的Span来做下演示</p>

<pre class="line-numbers"><code class="language-markup">public class MainActivity extends Activity {  
      
    private EditText editText;    
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
          
        editText = (EditText)findViewById(R.id.edit);  
          
        //改变字体颜色  
        //先构造SpannableString  
        SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
       //再构造一个改变字体颜色的Span  
        ForegroundColorSpan span = new ForegroundColorSpan(Color.BLUE);    
        //将这个Span应用于指定范围的字体  
        spanString.setSpan(span, 1, 3, Spannable.SPAN_EXCLUSIVE_INCLUSIVE);    
        //设置给EditText显示出来  
        editText.setText(spanString);  
    }  
}  
</code></pre>

<p>初始化效果是这样的：</p>

<p><figure><img src="media/15561207871715/15713660525455.png" alt=""/></figure></p>

<p>分别在设置Span的前面和后面加入新文字，结果是这样的</p>

<p><figure><img src="media/15561207871715/15713660631876.png" alt=""/></figure></p>

<p>在前面和后面都加入虾米两个字，可见，前面的虾米没有任何效果，后面的则不同，添加上相同的Span特效，这是由于我们设置了Spannable.SPAN_EXCLUSIVE_INCLUSIVE的原因，即（前面不应用特效，后面应用特效），其它几个Flags参数的含义想必大家也都清楚了。在此就不再赘述。</p>

<h2 id="toc_4">各种Span设置</h2>

<p>在前面的一个小示例，大家应该也可以看出，要应用一个Span总共分三步：</p>

<ol>
<li>构造String</li>
<li>构造Span</li>
<li>利用SetSpan（）对指定范围的String应用这个Span</li>
</ol>

<h3 id="toc_5">字体颜色设置（ForegroundColorSpan）</h3>

<pre class="line-numbers"><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
//再构造一个改变字体颜色的Span  
ForegroundColorSpan span = new ForegroundColorSpan(Color.BLUE);    
//将这个Span应用于指定范围的字体  
spanString.setSpan(span, 1, 5, Spannable.SPAN_EXCLUSIVE_INCLUSIVE);    
//设置给EditText显示出来  
editText.setText(spanString);  
</code></pre>

<p>效果：</p>

<p><figure><img src="media/15561207871715/15713660755390.png" alt=""/></figure></p>

<h3 id="toc_6">字体背景颜色（BackgroundColorSpan）</h3>

<pre class="line-numbers"><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
BackgroundColorSpan span = new BackgroundColorSpan(Color.YELLOW);    
spanString.setSpan(span, 0, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString);    
</code></pre>

<p><figure><img src="media/15561207871715/15713660849900.png" alt=""/></figure></p>

<h3 id="toc_7">字体大小（AbsoluteSizeSpan）</h3>

<pre class="line-numbers"><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
AbsoluteSizeSpan span = new AbsoluteSizeSpan(16);    
spanString.setSpan(span, 2, 5, Spannable.SPAN_INCLUSIVE_INCLUSIVE);    
editText.setText(spanString); 
</code></pre>

<p><figure><img src="media/15561207871715/15713660949169.png" alt=""/></figure></p>

<h3 id="toc_8">粗体、斜体（StyleSpan）</h3>

<pre class="line-numbers"><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
StyleSpan span = new StyleSpan(Typeface.BOLD_ITALIC);    
spanString.setSpan(span, 1, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString);   
</code></pre>

<p><figure><img src="media/15561207871715/15713661033289.png" alt=""/></figure></p>

<h3 id="toc_9">删除线（StrikethroughSpan）</h3>

<pre class="line-numbers"><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
StrikethroughSpan span = new StrikethroughSpan();    
spanString.setSpan(span, 2, 5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString);
</code></pre>

<p><figure><img src="media/15561207871715/15713661144421.png" alt=""/></figure></p>

<h3 id="toc_10">下划线（UnderlineSpan）</h3>

<pre class="line-numbers"><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
UnderlineSpan span = new UnderlineSpan();    
spanString.setSpan(span, 1, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString); 
</code></pre>

<p><figure><img src="media/15561207871715/15713661239815.png" alt=""/></figure></p>

<h3 id="toc_11">图片置换（ImageSpan）</h3>

<p>ImagSpan有很多构造函数，一般是通过传入Drawableg来构造，详细的构造说明看这里：<a href="http://developer.android.com/reference/android/text/style/ImageSpan.html">http://developer.android.com/reference/android/text/style/ImageSpan.html</a></p>

<pre class="line-numbers"><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
Drawable d = getResources().getDrawable(R.drawable.ic_launcher);    
d.setBounds(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());    
ImageSpan span = new ImageSpan(d, ImageSpan.ALIGN_BASELINE);    
spanString.setSpan(span, 2, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString);  
</code></pre>

<p><figure><img src="media/15561207871715/15713661317230.png" alt=""/></figure></p>

<p>这个函数的不同之处在于，前几都是在原来文字的基础上加上特效，而这里却是利用图片将文字替换。如果遇到不支持显示图片的函数，比如前一篇中的canvas绘图。就会退化成String，即以原来的String字符串来显示。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_3.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_5.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15818619982581.html">IDEA 远程一键部署Spring Boot到Docker</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813395132789.html">Flutter VsCode插件</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15809146907844.html">Flutter 组件小记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15808782889824.html">Flutter常用第三方库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15767453112302.html">添加环境变量</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_SVG-full"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
