<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.ifantastic.ink ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="16315844888626.html">
                
                  <h1>Android内存中的RSS、PSS、USS</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在dumpsys meminfo中经常能看到以下指标：</p>
<p><figure><img src="media/16315844888626/16315845125048.jpg" alt="" /></figure></p>
<p>可以看到有PSS的指标。而使用ps时，有时候还能看到RSS,USS。那这些指标代表什么意思呢？</p>
<h2><a id="%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98%E8%B6%B3%E8%BF%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算内存足迹</h2>
<p>首先，我们得知道kernel会追踪系统中所有的内存页面的内存分配。</p>
<p><figure><img src="media/16315844888626/16315846525561.jpg" alt="" /></figure></p>
<p>在计算app使用了多少内存时，系统需要统计共享页面（shared pages）。App在访问同一个service或者library的时候会共享内存页面。比如，Google地图和一个游戏app可能会共享一个定位服务。这使得在决定每个app独占多少内存时变得十分困难。</p>
<p><figure><img src="media/16315844888626/16315847039260.jpg" alt="" /></figure></p>
<p>因此在为一个app计算内存足迹时，可以使用以下任意指标。</p>
<ul>
<li><strong>Resident Set Size(RSS)</strong>:app使用的任意内存页面数量，包括shared 和 non-shared pages.</li>
<li><strong>Proportional Set Size(PSS)</strong>:app使用的non-shared pages，以及使用的shared page的平均值。比如，如果三个进程共享3MB，则认为每个进程平均占用1MB。也就是按比例的（Proportional）。</li>
<li><strong>Unique Set Size(USS)</strong>:app使用的non-shared pages，shared pages被排除在外。</li>
</ul>
<p>PSS在操作系统想知道所有进程使用了多少内存时是十分有用的。但在计算PSS时由于区分哪部分被共享，因此比较耗时。RSS的话不需要区分shared和non-shared pages的差异，因此计算起来更快。同时在追踪内存分配变化时会显得比较实用。最后，可以使用RSS-USS得出共享部分占用的内存大小，如果USS较小而计算得出来的差值很大，那么可以认为共享部分占用的内存过大了。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html'>性能优化</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16329857244371.html">
                
                  <h1>Flow入门</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>打开<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.android.com%2Fjetpack">Android架构组件页面</a>我们可以发现一些最新发布的JetPack组件，如<code>Room</code>、<code>DataStore</code>、<code>Paging3</code>、<code>DataBinding</code>等都支持了<code>Flow</code>。可以看出官方也在大力推广<code>Flow</code>。</p>
<h2><a id="flow%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Flow介绍</h2>
<p>Flow 库是在 Kotlin Coroutines 1.3.2 发布之后新增的库，也叫做异步流。<br />
<code>Flow</code> 就是 Kotlin 协程与响应式编程模型结合的产物，你会发现它与 <code>RxJava</code> 非常像，二者之间也有相互转换的 API，使用起来非常方便。</p>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5flow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么引入Flow</h3>
<ul>
<li><code>LiveData</code>不支持线程切换，所有数据转换都将在主线程上完成，有时需要频繁更改线程，面对复杂数据流时处理起来比较麻烦</li>
<li><code>RxJava</code>又有些过于麻烦了，有许多让人傻傻分不清的操作符，入门门槛较高，同时需要自己处理生命周期，在生命周期结束时取消订阅</li>
</ul>
<p>可以看出，<code>Flow</code>是介于<code>LiveData</code>与<code>RxJava</code>之间的一个解决方案，它有以下特点</p>
<ul>
<li><code>Flow</code> 支持线程切换、背压</li>
<li><code>Flow</code> 入门的门槛很低，没有那么多傻傻分不清楚的操作符</li>
<li>简单的数据转换与操作符，如 <code>map</code> 等等</li>
<li>冷数据流，不消费则不生产数据,这一点与<code>LiveData</code>不同：<code>LiveData</code>的发送端并不依赖于接收端。</li>
<li>属于<code>kotlin</code>协程的一部分，可以很好的与协程基础设施结合</li>
</ul>
<p>关于Flow的使用，比较简单，有兴趣的同学可参阅文档：<a href="https://link.juejin.cn/?target=http%3A%2F%2Fwww.kotlincn.net%2Fdocs%2Freference%2Fcoroutines%2Fflow.html">Flow文档</a></p>
<h2><a id="sharedflow%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SharedFlow 介绍</h2>
<p>我们上面介绍过,Flow 是冷流，什么是冷流？</p>
<ul>
<li><strong>冷流:</strong> 只有订阅者订阅时，才开始执行发射数据流的代码。并且冷流和订阅者只能是一对一的关系，当有多个不同的订阅者时，消息是重新完整发送的。也就是说对冷流而言，有多个订阅者的时候，他们各自的事件是独立的。</li>
<li><strong>热流:</strong> 无论有没有订阅者订阅，事件始终都会发生。当 热流有多个订阅者时，热流与订阅者们的关系是一对多的关系，可以与多个订阅者共享信息。</li>
</ul>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5sharedflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么引入SharedFlow</h3>
<p>上面其实已经说得很清楚了，冷流和订阅者只能是一对一的关系，当我们要实现一个流，多个订阅者的需求时(这在开发中是很常见的)，就需要热流了<br />
从命名上也很容易理解，<code>SharedFlow</code>即共享的<code>Flow</code>，可以实现一对多关系,<code>SharedFlow</code>是一种热流。</p>
<h3><a id="sharedflow%E7%9A%84%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SharedFlow的使用</h3>
<p>SharedFlow的构造函数</p>
<pre class="line-numbers"><code class="language-kotlin">public fun &lt;T&gt; MutableSharedFlow(
    replay: Int = 0,
    extraBufferCapacity: Int = 0,
    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND
): MutableSharedFlow&lt;T&gt;
</code></pre>
<ol>
<li><code>replay</code>表示当新的订阅者Collect时，发送几个已经发送过的数据给它，默认为0，即默认新订阅者不会获取以前的数据</li>
<li><code>extraBufferCapacity</code>表示减去<code>replay</code>，<code>MutableSharedFlow</code>还缓存多少数据，默认为0</li>
<li><code>onBufferOverflow</code>表示缓存策略，即缓冲区满了之后Flow如何处理，默认为挂起</li>
</ol>
<p>简单使用如下：</p>
<pre class="line-numbers"><code class="language-kotlin">//ViewModel
val sharedFlow=MutableSharedFlow&lt;String&gt;()

viewModelScope.launch{
      sharedFlow.emit(&quot;Hello&quot;)
      sharedFlow.emit(&quot;SharedFlow&quot;)
}

//Activity
lifecycleScope.launch{
    viewMode.sharedFlow.collect { 
       print(it)
    }
}
</code></pre>
<h3><a id="%E5%B0%86%E5%86%B7%E6%B5%81%E8%BD%AC%E5%8C%96%E4%B8%BAsharedflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将冷流转化为SharedFlow</h3>
<p>普通<code>flow</code>可使用<code>shareIn</code>扩展方法，转化成<code>SharedFlow</code></p>
<pre class="line-numbers"><code class="language-kotlin">    val sharedFlow by lazy {
        flow&lt;Int&gt; {
        //...
        }.shareIn(viewModelScope, WhileSubscribed(500), 0)
    }
</code></pre>
<p>shareIn主要也有三个参数：</p>
<blockquote>
<p>@param scope 共享开始时所在的协程作用域范围<br />
@param started 控制共享的开始和结束的策略<br />
@param replay 状态流的重播个数</p>
</blockquote>
<p>started 接受以下的三个值:</p>
<ol>
<li><strong>Lazily:</strong> 当首个订阅者出现时开始，在scope指定的作用域被结束时终止。</li>
<li><strong>Eagerly:</strong> 立即开始，而在scope指定的作用域被结束时终止。</li>
<li><strong>WhileSubscribed:</strong> 这种情况有些复杂，后面会详细讲解</li>
</ol>
<p>对于那些只执行一次的操作，您可以使用<code>Lazily</code>或者<code>Eagerly</code>。然而，如果您需要观察其他的流，就应该使用<code>WhileSubscribed</code>来实现细微但又重要的优化工作</p>
<h3><a id="whilesubscribed%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Whilesubscribed策略</h3>
<p>WhileSubscribed策略会在没有收集器的情况下取消上游数据流,通过shareIn运算符创建的SharedFlow会把数据暴露给视图 (View)，同时也会观察来自其他层级或者是上游应用的数据流。</p>
<p>让这些流持续活跃可能会引起不必要的资源浪费，例如一直通过从数据库连接、硬件传感器中读取数据等等。当您的应用转而在后台运行时，您应当保持克制并中止这些协程。</p>
<pre class="line-numbers"><code class="language-kotlin">public fun WhileSubscribed(
   stopTimeoutMillis: Long = 0,
   replayExpirationMillis: Long = Long.MAX_VALUE
)
</code></pre>
<p>如上所示，它支持两个参数：</p>
<ol>
<li><code>stopTimeoutMillis</code> 控制一个以毫秒为单位的延迟值，指的是最后一个订阅者结束订阅与停止上游流的时间差。默认值是 0 (立即停止).这个值非常有用，因为您可能并不想因为视图有几秒钟不再监听就结束上游流。这种情况非常常见——比如当用户旋转设备时，原来的视图会先被销毁，然后数秒钟内重建。</li>
<li><code>replayExpirationMillis</code> 表示数据重播的过时时间，如果用户离开应用太久，此时您不想让用户看到陈旧的数据，你可以用到这个参数</li>
</ol>
<h2><a id="stateflow%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>StateFlow 介绍</h2>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5stateflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么引入StateFlow</h3>
<p><code>StateFlow</code> 是 <code>SharedFlow</code> 的一个比较特殊的变种，<code>StateFlow</code> 与 <code>LiveData</code> 是最接近的，因为:</p>
<ol>
<li>它始终是有值的。</li>
<li>它的值是唯一的。</li>
<li>它允许被多个观察者共用 (因此是共享的数据流)。</li>
<li>它永远只会把最新的值重现给订阅者，这与活跃观察者的数量是无关的。</li>
</ol>
<p>可以看出，<code>StateFlow</code>与<code>LiveData</code>是比较接近的，可以获取当前的值，可以想像之所以引入<code>StateFlow</code>就是为了替换<code>LiveData</code></p>
<p>总结如下：</p>
<ol>
<li><code>StateFlow</code>继承于<code>SharedFlow</code>,是<code>SharedFlow</code>的一个特殊变种</li>
<li><code>StateFlow</code>与<code>LiveData</code>比较相近，相信之所以推出就是为了替换<code>LiveData</code></li>
</ol>
<h3><a id="stateflow%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>StateFlow的简单使用</h3>
<pre class="line-numbers"><code class="language-kotlin">public fun &lt;T&gt; MutableStateFlow(value: T): MutableStateFlow&lt;T&gt; = StateFlowImpl(value ?: NULL)
</code></pre>
<ol>
<li><code>StateFlow</code>构造函数较为简单，只需要传入一个默认值</li>
<li><code>StateFlow</code> 本质上是一个replay为1，并且没有缓冲区的SharedFlow,因此第一次订阅时会先获得默认值</li>
<li><code>StateFlow</code> 仅在值已更新，并且值发生了变化时才会返回，即如果更新后的值没有变化，也没会回调<code>Collect</code>方法，这点与<code>LiveData</code>不同</li>
</ol>
<p>与<code>SharedFlow</code>类似，我们也可以用<code>stateIn</code>将普通流转化成<code>StateFlow</code></p>
<pre class="line-numbers"><code class="language-kotlin">val result: StateFlow&lt;Result&lt;UiState&gt;&gt; = someFlow
    .stateIn(
        scope = viewModelScope, 
        started = WhileSubscribed(5000), 
        initialValue = Result.Loading
    )
</code></pre>
<p>与shareIn类似，唯一不同的时需要传入一个默认值<br />
同时之所以WhileSubscribed中传入了5000，是为了实现等待5秒后仍然没有订阅者存在就终止协程的功能，这个方法有以下功能</p>
<ul>
<li>用户将您的应用转至后台运行，5 秒钟后所有来自其他层的数据更新会停止，这样可以节省电量。</li>
<li>最新的数据仍然会被缓存，所以当用户切换回应用时，视图立即就可以得到数据进行渲染。</li>
<li>订阅将被重启，新数据会填充进来，当数据可用时更新视图。</li>
<li>在屏幕旋转时，因为重新订阅的时间在5s内，因此上游流不会中止</li>
</ul>
<h3><a id="%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E8%A7%82%E5%AF%9Fstateflow" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在页面中观察StateFlow</h3>
<p>与LiveData类似，我们也需要经常在页面中观察StateFlow<br />
观察StateFlow需要在协程中，因此我们需要协程构建器，一般我们会使用下面几种</p>
<ol>
<li><code>lifecycleScope.launch</code> : 立即启动协程，并且在本 Activity或Fragment 销毁时结束协程。</li>
<li><code>LaunchWhenStarted</code> 和 <code>LaunchWhenResumed</code>,它会在<code>lifecycleOwner</code>进入X状态之前一直等待，又在离开X状态时挂起协程</li>
</ol>
<p><figure><img src="media/16329857244371/16329896689258.jpg" alt="" /></figure></p>
<p>1.使用<code>launch</code>是不安全的，在应用在后台时也会接收数据更新，可能会导致应用崩溃<br />
2.使用<code>launchWhenStarted</code>或<code>launchWhenResumed</code>会好一些，在后台时不会接收数据更新，但是，上游数据流会在应用后台运行期间保持活跃，因此可能浪费一定的资源</p>
<blockquote>
<p>官方推荐<code>repeatOnLifecycle</code>来构建协程</p>
</blockquote>
<p>在某个特定的状态满足时启动协程，并且在生命周期所有者退出该状态时停止协程,如下图所示。</p>
<p><figure><img src="media/16329857244371/16329898715519.jpg" alt="" /></figure></p>
<p>比如在某个Fragment的代码中:</p>
<pre class="line-numbers"><code class="language-kotlin">onCreateView(...) {
    viewLifecycleOwner.lifecycleScope.launch {
        viewLifecycleOwner.lifecycle.repeatOnLifecycle(STARTED) {
            myViewModel.myUiState.collect { ... }
        }
    }
}
</code></pre>
<p>当这个Fragment处于STARTED状态时会开始收集流，并且在RESUMED状态时保持收集，最终在Fragment进入STOPPED状态时结束收集过程。<br />
结合使用repeatOnLifecycle API和WhileSubscribed,可以帮助您的应用妥善利用设备资源的同时，发挥最佳性能</p>
<h2><a id="stateflow%E4%B8%8Esharedflow%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>StateFlow与SharedFlow有什么区别？</h2>
<ol>
<li>SharedFlow配置更为灵活，支持配置replay,缓冲区大小等，StateFlow是SharedFlow的特化版本，replay固定为1，缓冲区大小默认为0</li>
<li>StateFlow与LiveData类似，支持通过myFlow.value获取当前状态，如果有这个需求，必须使用StateFlow</li>
<li>SharedFlow支持发出和收集重复值，而StateFlow当value重复时，不会回调collect</li>
<li>对于新的订阅者，StateFlow只会重播当前最新值，SharedFlow可配置重播元素个数（默认为0，即不重播）</li>
</ol>
<p>可以看出,StateFlow为我们做了一些默认的配置，在SharedFlow上添加了一些默认约束，这些配置可能并不符合我们的要求</p>
<ol>
<li>它忽略重复的值，并且是不可配置的。这会带来一些问题，比如当往List中添加元素并更新时，StateFlow会认为是重复的值并忽略</li>
<li>它需要一个初始值，并且在开始订阅时会回调初始值，这有可能不是我们想要的</li>
<li>它默认是粘性的，新用户订阅会获得当前的最新值，而且是不可配置的,而SharedFlow可以修改replay</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16336597951988.html">
                
                  <h1>性能分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="app%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>APP启动时间分析</h2>
<pre class="line-numbers"><code class="language-plain_text">adb shell am start -S -R 10 -W com.weipaitang.wpt/com.weipaitang.wpt.wptnative.module.launch.SplashActivity
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2022/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html'>性能优化</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16300352865963.html">
                
                  <h1>Gradle Transform详解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E7%9F%A5%E8%AF%86%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>知识点</h2>
<p><figure><img src="media/16300352865963/16300353152791.jpg" alt="" /></figure></p>
<h2><a id="1%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. 打包过程</h2>
<p>要了解Transform，首先我们需要知道Gradle构建一个安卓应用，会经过哪些步骤。</p>
<p><figure><img src="media/16300352865963/16300354048922.jpg" alt="" /></figure></p>
<p>上图是谷歌官网给出的一个典型的apk构建的过程，比较概括。主要包括两个过程，首先是编译过程，编译的内容包括本工程的文件以及依赖的各种库文件，编译的输出包括dex文件和编译后的资源文件。然后是打包过程。配合Keystore对第一步的输出进行签名对齐，生成最终的apk文件。</p>
<p><figure><img src="media/16300352865963/16300354264468.jpg" alt="" /></figure></p>
<p>上面这张图对上面的步骤以及每步用到的工具进行了细分，概括如下：<br />
Java编译器对工程本身的java代码进行编译，这些java代码有三个来源：app的源代码，由资源文件生成的R文件(aapt工具)，以及有aidl文件生成的java接口文件(aidl工具)。产出为.class文件。<br />
.class文件和依赖的三方库文件通过dex工具生成Delvik虚拟机可执行的.dex文件，可能有一个或多个，包含了所有的class信息，包括项目自身的class和依赖的class。产出为.dex文件。<br />
apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分，一是由aapt编译产生的编译后的资源文件，二是依赖的三方库里的资源文件。产出为未经签名的.apk文件。<br />
分别由Jarsigner和zipalign对apk文件进行签名和对齐，生成最终的apk文件。</p>
<h2><a id="2%E4%BB%80%E4%B9%88%E6%98%AF-transform" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. 什么是Transform</h2>
<p><strong>简单介绍：</strong><br />
从android-build-tool:gradle:1.5开始，gradle插件包含了一个叫Transform的API，这个API允许第三方插件在class文件转为为dex文件前操作编译好的class文件，这个API的目标就是简化class文件的自定义的操作而不用对Task进行处理。</p>
<p><strong>作用域：</strong><br />
Transform是作用在.class编译后，打包成.dex前，可以对.class和resource进行再处理的部分。<br />
为了印证，我们随便建立一个项目Build的一次。</p>
<p><figure><img src="media/16300352865963/16300355925073.jpg" alt="" /></figure></p>
<p>可以很清楚的看到，原生就带了一系列Transform供使用。那么这些Transform是怎么组织在一起的呢，我们用一张图表示：</p>
<p><figure><img src="media/16300352865963/16300356033860.jpg" alt="" /></figure></p>
<p>每个Transform其实都是一个<code>gradle task</code>，Android编译器中的TaskManager将每个Transform串连起来，第一个Transform接收来自javac编译的结果，以及已经拉取到在本地的第三方依赖（jar. aar），还有resource资源，注意，这里的resource并非android项目中的res资源，而是asset目录下的资源。 这些编译的中间产物，在Transform组成的链条上流动，每个Transform节点可以对class进行处理再传递给下一个Transform。我们常见的混淆，Desugar等逻辑，它们的实现如今都是封装在一个个Transform中，而我们自定义的Transform，会插入到这个Transform链条的最前面。</p>
<p>但其实，上面这幅图，只是展示Transform的其中一种情况。而Transform其实可以有两种输入，一种是消费型的，当前Transform需要将消费型型输出给下一个Transform，另一种是引用型的，当前Transform可以读取这些输入，而不需要输出给下一个Transform，比如Instant Run就是通过这种方式，检查两次编译之间的diff的。</p>
<p>最终，我们定义的Transform会被转化成一个个TransformTask，在Gradle编译时调用。</p>
<pre class="line-numbers"><code class="language-java">TransformManager.class

  /**
     * Adds a Transform.
     *
     * &lt;p&gt;This makes the current transform consumes whatever Streams are currently available and
     * creates new ones for the transform output.
     *
     * &lt;p&gt;his also creates a {@link TransformTask} to run the transform and wire it up with the
     * dependencies of the consumed streams.
     *
     * @param taskFactory the task factory
     * @param scope the current scope
     * @param transform the transform to add
     * @param callback a callback that is run when the task is actually configured
     * @param &lt;T&gt; the type of the transform
     * @return {@code Optional&lt;AndroidTask&lt;Transform&gt;&gt;} containing the AndroidTask for the given
     *     transform task if it was able to create it
     */
    @NonNull
    public &lt;T extends Transform&gt; Optional&lt;TransformTask&gt; addTransform(
            @NonNull TaskFactory taskFactory,
            @NonNull TransformVariantScope scope,
            @NonNull T transform,
            @Nullable TransformTask.ConfigActionCallback&lt;T&gt; callback) {

        if (!validateTransform(transform)) {
            // validate either throws an exception, or records the problem during sync
            // so it's safe to just return null here.
            return Optional.empty();
        }

        List&lt;TransformStream&gt; inputStreams = Lists.newArrayList();
        String taskName = scope.getTaskName(getTaskNamePrefix(transform));

        // get referenced-only streams
        List&lt;TransformStream&gt; referencedStreams = grabReferencedStreams(transform);

        // find input streams, and compute output streams for the transform.
        IntermediateStream outputStream = findTransformStreams(
                transform,
                scope,
                inputStreams,
                taskName,
                scope.getGlobalScope().getBuildDir());

        if (inputStreams.isEmpty() &amp;&amp; referencedStreams.isEmpty()) {
            // didn't find any match. Means there is a broken order somewhere in the streams.
            issueReporter.reportError(
                    Type.GENERIC,
                    new EvalIssueException(
                            String.format(
                                    &quot;Unable to add Transform '%s' on variant '%s': requested streams not available: %s+%s / %s&quot;,
                                    transform.getName(),
                                    scope.getFullVariantName(),
                                    transform.getScopes(),
                                    transform.getReferencedScopes(),
                                    transform.getInputTypes())));
            return Optional.empty();
        }

        //noinspection PointlessBooleanExpression
        if (DEBUG &amp;&amp; logger.isEnabled(LogLevel.DEBUG)) {
            logger.debug(&quot;ADDED TRANSFORM(&quot; + scope.getFullVariantName() + &quot;):&quot;);
            logger.debug(&quot;\tName: &quot; + transform.getName());
            logger.debug(&quot;\tTask: &quot; + taskName);
            for (TransformStream sd : inputStreams) {
                logger.debug(&quot;\tInputStream: &quot; + sd);
            }
            for (TransformStream sd : referencedStreams) {
                logger.debug(&quot;\tRef'edStream: &quot; + sd);
            }
            if (outputStream != null) {
                logger.debug(&quot;\tOutputStream: &quot; + outputStream);
            }
        }

        transforms.add(transform);

        // create the task...
        TransformTask task =
                taskFactory.create(
                        new TransformTask.ConfigAction&lt;&gt;(
                                scope.getFullVariantName(),
                                taskName,
                                transform,
                                inputStreams,
                                referencedStreams,
                                outputStream,
                                recorder,
                                callback));

        return Optional.ofNullable(task);
    }
</code></pre>
<h2><a id="3-transform%E8%A7%A3%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.Transform解读</h2>
<p>我们首先先定义一个自定义的Transform，需要实现如下方法。</p>
<pre class="line-numbers"><code class="language-java">class AspectJTransform extends Transform {

    final String NAME =  &quot;AjcTransform&quot;

    @Override
    String getName() {
        return NAME
    }

    @Override
    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
        return TransformManager.CONTENT_CLASS
    }

    @Override
    Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT
    }

    @Override
    boolean isIncremental() {
        return true
    }

    @Override
    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        super.transform(transformInvocation)
    }
}
</code></pre>
<p>我们一项项分析：</p>
<h3><a id="1-getname" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(1)getName()</h3>
<pre class="line-numbers"><code class="language-plain_text">    @Override
    String getName() {
        return &quot;TraceLog&quot;    
    }
</code></pre>
<p>Name顾名思义，就是我们的Transform名称，再回到我们刚刚Build的流程里：<br />
<figure><img src="media/16299642191691/16300325934575.jpg" alt="" /></figure></p>
<blockquote>
<p>这个最终的名字是如何构成的呢？好像跟我们这边的定义的名字有区别。以transform开头，之后拼接ContentType，这个ContentType代表着这个Transform的输入文件的类型，类型主要有两种，一种是Classes，另一种是Resources，ContentType之间使用And连接，拼接完成后加上With，之后紧跟的就是这个Transform的Name，name在getName()方法中重写返回即可。代码如下</p>
</blockquote>
<pre class="line-numbers"><code class="language-plain_text">@NonNull
    static String getTaskNamePrefix(@NonNull Transform transform) {
        StringBuilder sb = new StringBuilder(100);
        sb.append(&quot;transform&quot;);

        sb.append(
                transform
                        .getInputTypes()
                        .stream()
                        .map(
                                inputType -&gt;
                                        CaseFormat.UPPER_UNDERSCORE.to(
                                                CaseFormat.UPPER_CAMEL, inputType.name()))
                        .sorted() // Keep the order stable.
                        .collect(Collectors.joining(&quot;And&quot;)));
        sb.append(&quot;With&quot;);
        StringHelper.appendCapitalized(sb, transform.getName());
        sb.append(&quot;For&quot;);

        return sb.toString();
    }
</code></pre>
<h3><a id="2-getinputtypes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(2)getInputTypes()</h3>
<pre class="line-numbers"><code class="language-plain_text">    @Override
    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
        return TransformManager.CONTENT_CLASS    
    }
</code></pre>
<p>先来看代码注释，注释写的很清晰了，必须是CLASSES(0x01),RESOURCES(0x02)之一，相当于Transform需要处理的类型。</p>
<pre class="line-numbers"><code class="language-plain_text">    /**
     * Returns the type(s) of data that is consumed by the Transform. This may be more than
     * one type.
     *
     * &lt;strong&gt;This must be of type {@link QualifiedContent.DefaultContentType}&lt;/strong&gt;
     */
    @NonNull
    public abstract Set&lt;ContentType&gt; getInputTypes();
    
    ----------------------------------
    
     /**
     * The type of of the content.
     */
    enum DefaultContentType implements ContentType {
        /**
         * The content is compiled Java code. This can be in a Jar file or in a folder. If
         * in a folder, it is expected to in sub-folders matching package names.
         */
        CLASSES(0x01),

        /** The content is standard Java resources. */
        RESOURCES(0x02);

        private final int value;

        DefaultContentType(int value) {
            this.value = value;
        }

        @Override
        public int getValue() {
            return value;
        }
    }
</code></pre>
<p><figure><img src="media/16300352865963/16300359463362.jpg" alt="" /></figure></p>
<h3><a id="3-getscopes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(3)getScopes()</h3>
<pre class="line-numbers"><code class="language-java">    @Override
    Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT    
    }
</code></pre>
<p>先来看源码注释，这个的作用相当于用来Transform表明作用域</p>
<pre class="line-numbers"><code class="language-java">    /**
     * Returns the scope(s) of the Transform. This indicates which scopes the transform consumes.
     */
    @NonNull
    public abstract Set&lt;Scope&gt; getScopes();
开发一共可以选如下几种：

    /**
     * The scope of the content.
     *
     * &lt;p&gt;
     * This indicates what the content represents, so that Transforms can apply to only part(s)
     * of the classes or resources that the build manipulates.
     */
    enum Scope implements ScopeType {
        /** Only the project (module) content */
        PROJECT(0x01),
        /** Only the sub-projects (other modules) */
        SUB_PROJECTS(0x04),
        /** Only the external libraries */
        EXTERNAL_LIBRARIES(0x10),
        /** Code that is being tested by the current variant, including dependencies */
        TESTED_CODE(0x20),
        /** Local or remote dependencies that are provided-only */
        PROVIDED_ONLY(0x40),

        /**
         * Only the project's local dependencies (local jars)
         *
         * @deprecated local dependencies are now processed as {@link #EXTERNAL_LIBRARIES}
         */
        @Deprecated        PROJECT_LOCAL_DEPS(0x02),
        /**
         * Only the sub-projects's local dependencies (local jars).
         *
         * @deprecated local dependencies are now processed as {@link #EXTERNAL_LIBRARIES}
         */
        @Deprecated        SUB_PROJECTS_LOCAL_DEPS(0x08);

</code></pre>
<p>一般来说如果是要处理所有class字节码，Scope我们一般使用TransformManager.SCOPE_FULL_PROJECT。即</p>
<pre class="line-numbers"><code class="language-java">public static final Set&lt;Scope&gt; SCOPE_FULL_PROJECT = Sets.immutableEnumSet(Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES);
</code></pre>
<p>还有一些其他的可以参考下。</p>
<p><figure><img src="media/16300352865963/16300359737625.jpg" alt="" /></figure></p>
<h3><a id="4-isincremental" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(4)isIncremental()</h3>
<pre class="line-numbers"><code class="language-java">@Override
boolean isIncremental() {
    return true
}
</code></pre>
<p>增量编译开关。当我们开启增量编译的时候，相当input包含了changed/removed/added三种状态，实际上还有notchanged。需要做的操作如下：</p>
<ul>
<li><strong>NOTCHANGED</strong>: 当前文件不需处理，甚至复制操作都不用；</li>
<li><strong>ADDED</strong>、<strong>CHANGED</strong>: 正常处理，输出给下一个任务；</li>
<li><strong>REMOVED</strong>: 移除outputProvider获取路径对应的文件。</li>
</ul>
<h3><a id="5-transform" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(5)transform()</h3>
<pre class="line-numbers"><code class="language-java">@Override
void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
    super.transform(transformInvocation)
    ......
}
</code></pre>
<p>先来看一下源码注释，它是Transform处理文件的核心代码：</p>
<pre class="line-numbers"><code class="language-java"> /**
     * Executes the Transform.
     *
     * &lt;p&gt;The inputs are packaged as an instance of {@link TransformInvocation}
     * &lt;ul&gt;
     *     &lt;li&gt;The &lt;var&gt;inputs&lt;/var&gt; collection of {@link TransformInput}. These are the inputs
     *     that are consumed by this Transform. A transformed version of these inputs must
     *     be written into the output. What is received is controlled through
     *     {@link #getInputTypes()}, and {@link #getScopes()}.&lt;/li&gt;
     *     &lt;li&gt;The &lt;var&gt;referencedInputs&lt;/var&gt; collection of {@link TransformInput}. This is
     *     for reference only and should be not be transformed. What is received is controlled
     *     through {@link #getReferencedScopes()}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * A transform that does not want to consume anything but instead just wants to see the content
     * of some inputs should return an empty set in {@link #getScopes()}, and what it wants to
     * see in {@link #getReferencedScopes()}.
     *
     * &lt;p&gt;Even though a transform's {@link Transform#isIncremental()} returns true, this method may
     * be receive &lt;code&gt;false&lt;/code&gt; in &lt;var&gt;isIncremental&lt;/var&gt;. This can be due to
     * &lt;ul&gt;
     *     &lt;li&gt;a change in secondary files ({@link #getSecondaryFiles()},
     *     {@link #getSecondaryFileOutputs()}, {@link #getSecondaryDirectoryOutputs()})&lt;/li&gt;
     *     &lt;li&gt;a change to a non file input ({@link #getParameterInputs()})&lt;/li&gt;
     *     &lt;li&gt;an unexpected change to the output files/directories. This should not happen unless
     *     tasks are improperly configured and clobber each other's output.&lt;/li&gt;
     *     &lt;li&gt;a file deletion that the transform mechanism could not match to a previous input.
     *     This should not happen in most case, except in some cases where dependencies have
     *     changed.&lt;/li&gt;
     * &lt;/ul&gt;
     * In such an event, when &lt;var&gt;isIncremental&lt;/var&gt; is false, the inputs will not have any
     * incremental change information:
     * &lt;ul&gt;
     *     &lt;li&gt;{@link JarInput#getStatus()} will return {@link Status#NOTCHANGED} even though
     *     the file may be added/changed.&lt;/li&gt;
     *     &lt;li&gt;{@link DirectoryInput#getChangedFiles()} will return an empty map even though
     *     some files may be added/changed.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param transformInvocation the invocation object containing the transform inputs.
     * @throws IOException if an IO error occurs.
     * @throws InterruptedException
     * @throws TransformException Generic exception encapsulating the cause.
     */
    public void transform(@NonNull TransformInvocation transformInvocation)
            throws TransformException, InterruptedException, IOException {
        // Just delegate to old method, for code that uses the old API.
        //noinspection deprecation
        transform(transformInvocation.getContext(), transformInvocation.getInputs(),
                transformInvocation.getReferencedInputs(),
                transformInvocation.getOutputProvider(),
                transformInvocation.isIncremental());
    }
</code></pre>
<p>大致意思如下，具体大家一定要仔细看注释：</p>
<ul>
<li>如果拿取了getInputs()的输入进行消费，则transform后必须再输出给下一级</li>
<li>如果拿取了getReferencedInputs()的输入，则不应该被transform。</li>
<li>是否增量编译要以transformInvocation.isIncremental()为准。</li>
</ul>
<p>在 transform 方法中主要做的事情就是把 Inputs 保存到 outProvider 提供的位置去。生成的位置见下图：<br />
<figure><img src="media/16299642191691/16300345809682.jpg" alt="" /></figure></p>
<p>后面会讲到代码，主要有两个 transform 方法，一个 transformJar 就是简单的拷贝，另一个 transformDirectory，我们就是在这里用 ASM 对字节码进行修改的。</p>
<h3><a id="6-getsecondaryfiles" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(6)getSecondaryFiles()</h3>
<p>上面transform函数这里还提到了一个东西叫</p>
<pre class="line-numbers"><code class="language-java">secondary files ({@link #getSecondaryFiles()}
</code></pre>
<p>网上Transform的讲解对它的提及比较少，先看看注释，它和我们之前介绍的一样，有一系列API：</p>
<pre class="line-numbers"><code class="language-java">    /**
     * Returns a list of additional file(s) that this Transform needs to run. Preferably, use
     * {@link #getSecondaryFiles()} API which allow eah secondary file to indicate if changes
     * can be handled incrementally or not. This API will treat all additional file change as
     * a non incremental event.
     *
     * &lt;p&gt;Changes to files returned in this list will trigger a new execution of the Transform
     * even if the qualified-content inputs haven't been touched.
     *
     * &lt;p&gt;Any changes to these files will trigger a non incremental execution.
     *
     * &lt;p&gt;The default implementation returns an empty collection.
     *
     * @deprecated replaced by {@link #getSecondaryFiles()}
     */
    @Deprecated
    @NonNull
    public Collection&lt;File&gt; getSecondaryFileInputs() {
        return ImmutableList.of();
    }

    /**
     * Returns a list of additional file(s) that this Transform needs to run.
     *
     * &lt;p&gt;Changes to files returned in this list will trigger a new execution of the Transform
     * even if the qualified-content inputs haven't been touched.
     *
     * &lt;p&gt;Each secondary input has the ability to be declared as necessitating a non incremental
     * execution in case of change. This Transform can therefore declare which secondary file
     * changes it supports in incremental mode.
     *
     * &lt;p&gt;The default implementation returns an empty collection.
     */
    @NonNull
    public Collection&lt;SecondaryFile&gt; getSecondaryFiles() {
        return ImmutableList.of();
    }

    /**
     * Returns a list of additional (out of streams) file(s) that this Transform creates.
     *
     * &lt;p&gt;These File instances can only represent files, not directories. For directories, use
     * {@link #getSecondaryDirectoryOutputs()}
     *
     *
     * &lt;p&gt;Changes to files returned in this list will trigger a new execution of the Transform
     * even if the qualified-content inputs haven't been touched.
     *
     * &lt;p&gt;Changes to these output files force a non incremental execution.
     *
     * &lt;p&gt;The default implementation returns an empty collection.
     */
    @NonNull
    public Collection&lt;File&gt; getSecondaryFileOutputs() {
        return ImmutableList.of();
    }

    /**
     * Returns a list of additional (out of streams) directory(ies) that this Transform creates.
     *
     * &lt;p&gt;These File instances can only represent directories. For files, use
     * {@link #getSecondaryFileOutputs()}
     *
     * &lt;p&gt;Changes to directories returned in this list will trigger a new execution of the Transform
     * even if the qualified-content inputs haven't been touched.
     *
     * &lt;p&gt;Changes to these output directories force a non incremental execution.
     *
     * &lt;p&gt;The default implementation returns an empty collection.
     */
    @NonNull
    public Collection&lt;File&gt; getSecondaryDirectoryOutputs() {
        return ImmutableList.of();
    }
</code></pre>
<p>跟据字面意思理解，除了主输入/输出流之外，Transform还可以额外定义另外的流供下个使用，不过我们平时用到的不多，可以根据系统自带的Transform源码看看它输出了啥，比如ProguardTransform:</p>
<pre class="line-numbers"><code class="language-java">public class ProGuardTransform extends BaseProguardAction {
  ......
  private final ImmutableList&lt;File&gt; secondaryFileOutputs;
  ......
   public ProGuardTransform(@NonNull VariantScope variantScope) {
        ......
        secondaryFileOutputs = ImmutableList.of(printMapping, printSeeds, printUsage);
    }
    @NonNull
    @Override
    public Collection&lt;SecondaryFile&gt; getSecondaryFiles() {
        final List&lt;SecondaryFile&gt; files = Lists.newArrayList();

        if (testedMappingFile != null &amp;&amp; testedMappingFile.isFile()) {
            files.add(SecondaryFile.nonIncremental(testedMappingFile));
        } else if (testMappingConfiguration != null) {
            files.add(SecondaryFile.nonIncremental(testMappingConfiguration));
        }

        // the config files
        files.add(SecondaryFile.nonIncremental(getAllConfigurationFiles()));

        return files;
    }

    @NonNull
    @Override
    public Collection&lt;File&gt; getSecondaryFileOutputs() {
        return secondaryFileOutputs;
    }
</code></pre>
<p>可以看到，它实际上是对mapping文件额外的配置，相当于如注释一样，是相对于主流额外新一个流，实际开发中我们用的较少。</p>
<h3><a id="7-iscacheable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(7)isCacheable()</h3>
<p>按照惯例，先看注释：</p>
<pre class="line-numbers"><code class="language-plain_text">/**
     * Returns if this transform's outputs should be cached. Please read {@link
     * org.gradle.api.tasks.CacheableTask} Javadoc if you would like to make your transform
     * cacheable.
     */
    public boolean isCacheable() {
        return false;
    }
</code></pre>
<p>如果我们的transform需要被缓存，则为true。<br />
它被TransformTask所用到：</p>
<pre class="line-numbers"><code class="language-java">@CacheableTask
public class TransformTask extends StreamBasedTask implements Context {

@Override
public void execute(@NonNull TransformTask task) {
        task.transform = transform;
        task.consumedInputStreams = consumedInputStreams;
        task.referencedInputStreams = referencedInputStreams;
        task.outputStream = outputStream;
        task.setVariantName(variantName);
        task.recorder = recorder;
        if (configActionCallback != null) {
            configActionCallback.callback(transform, task);
        }
        //这一句，如果设置为true，则缓存输出
        task.getOutputs().cacheIf(t -&gt; transform.isCacheable());
        
        task.registerConsumedAndReferencedStreamInputs();
        }
</code></pre>
<h2><a id="4-transform%E7%BC%96%E5%86%99%E6%A8%A1%E6%9D%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.Transform编写模板</h2>
<h3><a id="1%E6%97%A0%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(1)无增量编译：</h3>
<pre class="line-numbers"><code class="language-java">class AspectJTransform extends Transform {

    final String NAME =  &quot;AjcTransform&quot;

    @Override
    String getName() {
        return NAME
    }

    @Override
    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
        return TransformManager.CONTENT_CLASS
    }

    @Override
    Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT
    }

    @Override
    boolean isIncremental() {
        return false
    }

      @Override
    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        super.transform(transformInvocation)

        //OutputProvider管理输出路径，如果消费型输入为空，你会发现OutputProvider == null
        TransformOutputProvider outputProvider = transformInvocation.getOutputProvider();

        transformInvocation.inputs.each { TransformInput input -&gt;
            input.jarInputs.each { JarInput jarInput -&gt;
                //处理Jar
                processJarInput(jarInput, outputProvider)
            }

            input.directoryInputs.each { DirectoryInput directoryInput -&gt;
                //处理源码文件
                processDirectoryInputs(directoryInput, outputProvider)
            }
        }
    }

    void processJarInput(JarInput jarInput, TransformOutputProvider outputProvider) {
        File dest = outputProvider.getContentLocation(
                jarInput.getFile().getAbsolutePath(),
                jarInput.getContentTypes(),
                jarInput.getScopes(),
                Format.JAR)
        //TODO do some transform
        //将修改过的字节码copy到dest，就可以实现编译期间干预字节码的目的了        
        FileUtils.copyFiley(jarInput.getFile(), dest)
    }

    void processDirectoryInputs(DirectoryInput directoryInput, TransformOutputProvider outputProvider) {
        File dest = outputProvider.getContentLocation(directoryInput.getName(),
                directoryInput.getContentTypes(), directoryInput.getScopes(),
                Format.DIRECTORY)
        //建立文件夹        
        FileUtils.forceMkdir(dest)
        //TODO do some transform
        //将修改过的字节码copy到dest，就可以实现编译期间干预字节码的目的了        
        FileUtils.copyDirectory(directoryInput.getFile(), dest)
    }
}
</code></pre>
<p>这里只是实现了简单的拷贝，具体怎么处理可以根据需求出发</p>
<h3><a id="2%E5%B8%A6%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91%E6%8E%A8%E8%8D%90%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(2)带增量编译(推荐)：</h3>
<pre class="line-numbers"><code class="language-java">class AspectJTransform extends Transform {

    final String NAME = &quot;AjcTransform&quot;

    @Override
    String getName() {
        return NAME
    }

    @Override
    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
        return TransformManager.CONTENT_CLASS
    }

    @Override
    Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT
    }

    @Override
    boolean isIncremental() {
        return true
    }

    @Override
    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        super.transform(transformInvocation)

        boolean isIncremental = transformInvocation.isIncremental()

        //OutputProvider管理输出路径，如果消费型输入为空，你会发现OutputProvider == null
        TransformOutputProvider outputProvider = transformInvocation.getOutputProvider()

        if (!isIncremental) {
            //不需要增量编译，先清除全部
            outputProvider.deleteAll()
        }

        transformInvocation.getInputs().each { TransformInput input -&gt;
            input.jarInputs.each { JarInput jarInput -&gt;
                //处理Jar
                processJarInputWithIncremental(jarInput, outputProvider, isIncremental)
            }

            input.directoryInputs.each { DirectoryInput directoryInput -&gt;
                //处理文件
                processDirectoryInputWithIncremental(directoryInput, outputProvider, isIncremental)
            }
        }
    }

    void processJarInputWithIncremental(JarInput jarInput, TransformOutputProvider outputProvider, boolean isIncremental) {
        File dest = outputProvider.getContentLocation(
                jarInput.getFile().getAbsolutePath(),
                jarInput.getContentTypes(),
                jarInput.getScopes(),
                Format.JAR)
        if (isIncremental) {
            //处理增量编译
            processJarInputWhenIncremental(jarInput, dest)
        } else {
            //不处理增量编译
            processJarInput(jarInput, dest)
        }
    }

    void processJarInput(JarInput jarInput, File dest) {
        transformJarInput(jarInput, dest)
    }

    void processJarInputWhenIncremental(JarInput jarInput, File dest) {
        switch (jarInput.status) {
            case Status.NOTCHANGED:
                break
            case Status.ADDED:
            case Status.CHANGED:
                //处理有变化的
                transformJarInputWhenIncremental(jarInput.getFile(), dest, jarInput.status)
                break
            case Status.REMOVED:
                //移除Removed
                if (dest.exists()) {
                    FileUtils.forceDelete(dest)
                }
                break
        }
    }

    void transformJarInputWhenIncremental(JarInput jarInput, File dest, Status status) {
        if (status == Status.CHANGED) {
            //Changed的状态需要先删除之前的
            if (dest.exists()) {
                FileUtils.forceDelete(dest)
            }
        }
        //真正transform的地方
        transformJarInput(jarInput, dest)
    }

    void transformJarInput(JarInput jarInput, File dest) {
        //TODO do some transform
        //将修改过的字节码copy到dest，就可以实现编译期间干预字节码的目的了
        FileUtils.copyFile(jarInput.getFile(), dest)
    }

    void processDirectoryInputWithIncremental(DirectoryInput directoryInput, TransformOutputProvider outputProvider, boolean isIncremental) {
        File dest = outputProvider.getContentLocation(
                directoryInput.getFile().getAbsolutePath(),
                directoryInput.getContentTypes(),
                directoryInput.getScopes(),
                Format.DIRECTORY)
        if (isIncremental) {
            //处理增量编译
            processDirectoryInputWhenIncremental(directoryInput, dest)
        } else {
            processDirectoryInput(directoryInput, dest)
        }
    }

    void processDirectoryInputWhenIncremental(DirectoryInput directoryInput, File dest) {
        FileUtils.forceMkdir(dest)
        String srcDirPath = directoryInput.getFile().getAbsolutePath()
        String destDirPath = dest.getAbsolutePath()
        Map&lt;File, Status&gt; fileStatusMap = directoryInput.getChangedFiles()
        fileStatusMap.each { Map.Entry&lt;File, Status&gt; entry -&gt;
            File inputFile = entry.getKey()
            Status status = entry.getValue()
            String destFilePath = inputFile.getAbsolutePath().replace(srcDirPath, destDirPath)
            File destFile = new File(destFilePath)
            switch (status) {
                case Status.NOTCHANGED:
                    break
                case Status.REMOVED:
                    if (destFile.exists()) {
                        FileUtils.forceDelete(destFile)
                    }
                    break
                case Status.ADDED:
                case Status.CHANGED:
                    FileUtils.touch(destFile)
                    transformSingleFile(inputFile, destFile, srcDirPath)
                    break
            }
        }
    }

    void processDirectoryInput(DirectoryInput directoryInput, File dest) {
        transformDirectoryInput(directoryInput, dest)
    }

    void transformDirectoryInput(DirectoryInput directoryInput, File dest) {
        //TODO do some transform
        //将修改过的字节码copy到dest，就可以实现编译期间干预字节码的目的了
        FileUtils.copyDirectory(directoryInput.getFile(), dest)
    }

    void transformSingleFile(File inputFile, File destFile, String srcDirPath) {
        FileUtils.copyFile(inputFile, destFile)
    }
}
</code></pre>
<h2><a id="5-transform%E6%B3%A8%E5%86%8C%E5%92%8C%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.Transform注册和使用</h2>
<p>定义一个插件</p>
<pre class="line-numbers"><code class="language-java">class AspectJWeaverPlugin implements Plugin&lt;Project&gt; {

    @Override
    void apply(Project project) {
        boolean hasApp = project.getPlugins().hasPlugin(AppPlugin.class)
        if (hasApp) {
            def appExtension = project.getExtensions().getByType(AppExtension.class)
            appExtension.registerTransform(new AspectJTransform(), Collections.EMPTY_LIST)
        }
    }
}
</code></pre>
<h2><a id="6-transform%E4%BC%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.Transform优化</h2>
<p>一般就三种：</p>
<ol>
<li>增量编译</li>
<li>并发编译</li>
<li>include... exclude...缩小transform范围</li>
</ol>
<p>这里讲一下并发编译，简单实现如下：</p>
<pre class="line-numbers"><code class="language-java">  WaitableExecutor waitableExecutor = WaitableExecutor.useGlobalSharedThreadPool()
  
  ......
  transformInvocation.getInputs().each { TransformInput input -&gt;
            input.jarInputs.each { JarInput jarInput -&gt;
                //多线程处理Jar
                waitableExecutor.execute(new Callable&lt;Object&gt;() {
                    @Override
                    Object call() throws Exception {
                        processJarInputWithIncremental(jarInput, outputProvider, isIncremental)
                        return null
                    }
                })
            }

            input.directoryInputs.each { DirectoryInput directoryInput -&gt;
                //多线程处理文件
                waitableExecutor.execute(new Callable&lt;Object&gt;() {
                    @Override
                    Object call() throws Exception {
                        processDirectoryInputWithIncremental(directoryInput, outputProvider, isIncremental)
                        return null
                    }
                })
            }
        }

        //等待所有任务结束
        waitableExecutor.waitForTasksWithQuickFail(true)
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/08/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Gradle.html'>Gradle</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16299652966526.html">
                
                  <h1>自定义Gradle插件</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="android-gradle" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Android Gradle</h2>
<p>Android项目使用 Gradle 作为构建框架，Gradle 又是以Groovy为脚本语言。所以学习Gradle之前需要先熟悉Groovy脚本语言。</p>
<p>Groovy是基于Java语言的脚本语言，所以它的语法和Java非常相似，但是具有比java更好的灵活性。</p>
<h2><a id="android-gradle%E7%9A%84-project%E5%92%8C-tasks" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Android Gradle 的 Project 和 Tasks</h2>
<p>这个是Gradle中最重要的两个概念。每次构建（build）至少由一个project构成，一个project 由一到多个task构成。项目结构中的每个build.gradle文件代表一个project，在这编译脚本文件中可以定义一系列的task；task 本质上又是由一组被顺序执行的Action对象构成，Action其实是一段代码块，类似于Java中的方法。</p>
<h3><a id="android-gradle%E6%9E%84%E5%BB%BA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Android Gradle 构建生命周期</h3>
<p>每次构建的执行本质上执行一系列的Task。某些Task可能依赖其他Task。那些没有依赖的Task总会被最先执行，而且每个Task只会被执行一遍。每次构建的依赖关系是在构建的配置阶段确定的。每次构建分为3个阶段：</p>
<h3><a id="initialization%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initialization: 初始化阶段</h3>
<p>这是创建Project阶段，构建工具根据每个build.gradle文件创建出一个Project实例。初始化阶段会执行项目根目录下的settings.gradle文件，来分析哪些项目参与构建。</p>
<p>所以这个文件里面的内容经常是：</p>
<pre class="line-numbers"><code class="language-kotlin">include ':app'
include ':libraries'
</code></pre>
<p>这是告诉Gradle这些项目需要编译，所以我们引入一些开源的项目的时候，需要在这里填上对应的项目名称，来告诉Gradle这些项目需要参与构建。</p>
<h3><a id="configuration%E9%85%8D%E7%BD%AE%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration:配置阶段</h3>
<p>这个阶段，通过执行构建脚本来为每个project创建并配置Task。配置阶段会去加载所有参与构建的项目的build.gradle文件，会将每个build.gradle文件实例化为一个Gradle的project对象。然后分析project之间的依赖关系，下载依赖文件，分析project下的task之间的依赖关系。</p>
<h3><a id="execution%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Execution:执行阶段</h3>
<p>这是Task真正被执行的阶段，Gradle会根据依赖关系决定哪些Task需要被执行，以及执行的先后顺序。</p>
<p>task是Gradle中的最小执行单元，我们所有的构建，编译，打包，debug，test等都是执行了某一个task，一个project可以有多个task，task之间可以互相依赖。例如我有两个task，taskA和taskB，指定taskA依赖taskB，然后执行taskA，这时会先去执行taskB，taskB执行完毕后在执行taskA。</p>
<p>你点击AndroidStudio右侧的一个Gradle按钮，会打开一个面板，内容差不多是这样的：</p>
<p><figure><img src="media/16299652966526/16299663182714.jpg" alt="" /></figure></p>
<p>里面的每一个条目都是一个task，那这些task是哪来的呢？</p>
<p>一个是根目录下的 build.gradle 中的:</p>
<pre class="line-numbers"><code class="language-plain_text">dependencies {
   classpath 'com.android.tools.build:gradle:3.2.1'
}
</code></pre>
<p>一个是 app 目录下的 build.gradle 中的:</p>
<pre class="line-numbers"><code class="language-plain_text">apply plugin: 'com.android.application'
</code></pre>
<p>这两段代码决定的。也就是说，Gradle提供了一个框架，这个框架有一些运行的机制可以让你完成编译，但是至于怎么编译是由插件决定的。还好Google已经给我们写好了Android对应的Gradle工具，我们使用就可以了。</p>
<p>根目录下的<code>build.gradle</code>中 <code>dependencies { classpath ‘com.android.tools.build:gradle:3.2.1 }</code> 是Android Gradle编译插件的版本。</p>
<p>app目录下的<code>build.gradle</code>中的<code>apply plugin: ‘com.android.application’</code> 是引入了Android的应用构建项目，还有<code>com.android.library</code>和<code>com.android.application</code>用来构建library和应用。</p>
<p>所有Android构建需要执行的task都封装在工具里，如果你有一些特殊需求的话，也可以自己写一些task。那么对于开发一个Android应用来说，最关键的部分就是如何来用Android Gradle的插件了。</p>
<h2><a id="%E8%AE%A4%E7%9F%A5gradle-wrapper" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>认知Gradle Wrapper</h2>
<p>Android Studio中默认会使用 Gradle Wrapper 而不是直接使用Gradle。命令也是使用gradlew而不是gradle。这是因为gradle针对特定的开发环境的构建脚本，新的gradle可能不能兼容旧版的构建环境。为了解决这个问题，使用Gradle Wrapper 来间接使用 gradle。相当于在外边包裹了一个中间层。对开发者来说，直接使用Gradlew 即可，不需要关心 gradle的版本变化。Gradle Wrapper 会负责下载合适的的gradle版本来构建项目。</p>
<h2><a id="android%E4%B8%89%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8D%E8%A6%81%E7%9A%84-gradle%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Android 三个文件重要的 gradle 文件</h2>
<p>Gradle项目有3个重要的文件需要深入理解：项目根目录的 build.gradle , settings.gradle 和模块目录的 build.gradle 。</p>
<ul>
<li><code>settings.gradle</code> 文件会在构建的 <code>initialization</code> 阶段被执行，它用于告诉构建系统哪些模块需要包含到构建过程中。对于单模块项目，<code>settings.gradle</code> 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。</li>
<li>项目根目录的 <code>build.gradle</code> 文件用来配置针对所有模块的一些属性。它默认包含2个代码块：<code>buildscript{…}</code>和<code>allprojects{…}</code>。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性。</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">buildscript {
  repositories {
    jcenter()
  }
 
  dependencies {
     classpath 'com.android.tools.build:gradle:3.2.1'
  }
}
 
allprojects {
  repositories {
    jcenter()
  }
}
 
task clean(type: Delete) {
  delete rootProject.buildDir
}
</code></pre>
<ol>
<li>buildscript：定义了 Android 编译工具的类路径。repositories中, jCenter是一个著名的 Maven仓库。</li>
<li>allprojects：定义的属性会被应用到所有 moudle中，但是为了保证每个项目的独立性，我们一般不会在这里面操作太多共有的东西。</li>
</ol>
<ul>
<li>模块级配置文件 <code>build.gradle</code> 针对每个<code>moudle</code>的配置，这里的定义的选项和顶层<code>build.gradle</code>定义的相同。它有3个重要的代码块：<code>plugin</code>，<code>android</code> 和 <code>dependencies</code>。</li>
</ul>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89gradle%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义gradle插件</h2>
<p>编写Gradle插件主要有三种方法：</p>
<ul>
<li><code>build.gradle</code>脚本中直接使用。这种方式就是直接在<code>Android Studio app moudle</code>的<code>build.gradle</code>中进行插件的编写，优点是不用再上传插件到maven或者其它地方，项目就可以直接使用；缺点也很明显，就是只能在自己的项目中使用，不能复用，这个不是我们今天要说的。</li>
<li><code>buildSrc</code>中使用。这种方式需要在项目中新建一个<code>model</code>命名为<code>buildSrc</code>，这个目录就用来存放自定义插件。然后在<code>src/main</code>中建立两个目录，一个就是存放代码的groovy目录，一个是存放自定义插件名称的<code>resources</code>目录。这种定义方式也是只能在我们项目中进行使用，不好复用。</li>
<li>独立Module中使用。这种方式就是完全独立开发一个Module，可以随便用。</li>
</ul>
<h2><a id="%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置</h2>
<p>AS中新建一个Module接着就是配置目录了，和上面说的第二种方式其实一样的，配置好的目录如下，其中groovy目录就是放置代码的地方，resources里面放置的是一个配置文件。在gradle-plugins文件夹下新建一个文件<code>com.example.watson.plugin.properties</code>，文件的名字<code>com.example.watson.plugin</code>就是在使用这个插件的地方需要的名字，比如</p>
<pre class="line-numbers"><code class="language-plain_text">apply plugin:'com.example.watson.plugin'
</code></pre>
<p><figure><img src="media/16299652966526/16299683349608.jpg" alt="" /></figure></p>
<p>上面配置文件内容, 其实就是一个映射关系，找到我们定义的插件NetworkPlugin，com.example.watson.plugin是NetworkPlugin这个插件类所在的包名。</p>
<pre class="line-numbers"><code class="language-plain_text">implementation-class=com.example.watson.plugin.NetworkPlugin
</code></pre>
<h2><a id="%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>插件实现</h2>
<p>环境都配置好了，接下来就是实现NetworkPlugin这个插件了，在groovy文件夹下新建包名并在该名下新建文件NetworkPlugin.groovy。当然groovy也是完全兼容Java的，所以小伙伴们看起来完全无压力啊。</p>
<p>定义插件首先要实现Plugin接口，然后在apply方法中实现插件功能。</p>
<pre class="line-numbers"><code class="language-plain_text">class NetworkPlugin implements Plugin&lt;Project&gt;{

    @Override
    void apply(Project project) {
        println &quot;------network plugin begin-------&quot;
        project.tasks.create(&quot;networkTest&quot;, NetworkTask) {
            doLast {
                println &quot;doLast&quot;

            }
        }
        println &quot;------network plugin end-------&quot;
    }
}
</code></pre>
<p>为了直观感受，我添加了一个task，也就是networkTest，这个Task就是请求百度首页的网页代码并打印出来。在相同目录下新建文件NetworkTest.groovy，Task的具体工作就是@TaskAction这个注解标注的方法中了。</p>
<pre class="line-numbers"><code class="language-plain_text">class NetworkTask  extends DefaultTask {

    @TaskAction
    def testNetwork() {
        println &quot;------NetworkTask begin-------&quot;
        try {
            OkHttpClient mOkHttpClient = new OkHttpClient()
            Request request = new Request.Builder().url(&quot;http://www.baidu.com/&quot;).build()
            Call call = mOkHttpClient.newCall(request)
            Response mResponse = call.execute()
            if (mResponse.isSuccessful()) {
                println mResponse.body().string()
            }
        } catch (Exception e) {
            e.printStackTrace()
            println e.toString()
        }
        println &quot;------NetworkTask end-------&quot;
    }
}
</code></pre>
<p>到这里我们插件的代码工作基本就完成了，剩下最后一个问题，怎么用这个插件呢？当然就是上传Maven等等的仓库中了，这里为了方便我就上传到自己的本地了。</p>
<h2><a id="%E4%B8%8A%E4%BC%A0%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>上传插件</h2>
<p>上传插件就是在这个Module的build.gradle中写Task了，这里我就上传到本地D盘reponsitory目录下了。</p>
<pre class="line-numbers"><code class="language-plain_text">apply plugin: 'groovy'
//使用该插件，才能使用uploadArchives
apply plugin: 'maven'

repositories {
    jcenter()
}

dependencies {
    //使用gradle sdk
    compile gradleApi()
    //使用groovy sdk
    compile localGroovy()
    compile 'com.android.tools.build:gradle:3.0.1'
    //网络请求框架
    compile 'com.squareup.okhttp3:okhttp:3.7.0'
    compile 'com.squareup.okio:okio:1.9.0'
}

sourceCompatibility = &quot;1.8&quot;
targetCompatibility = &quot;1.8&quot;

uploadArchives {
    repositories.mavenDeployer {
        pom.version = '1.0.0'
        pom.artifactId = 'watsonPlugin'
        pom.groupId = 'com.example.watson.plugin'
        repository(url: &quot;file:///D:/repository/&quot;)
    }
}
</code></pre>
<p>点击下build就能在plugin模块看见我们定义的uploadArchives这个Task了</p>
<p><figure><img src="media/16299652966526/16299686048871.jpg" alt="" /></figure></p>
<p>点击下这个任务就能在对应的目录下生成这个插件。</p>
<p><figure><img src="media/16299652966526/16299686153341.jpg" alt="" /></figure></p>
<h2><a id="%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用插件</h2>
<p>首先在工程的根目录下的build.gradle文件下添加如下代码。maven仓库就是我们上面的仓库地址，添加依赖，其中com.example.watson.plugin就是groupId，watsonPlugin就是artifactId，1.0.0就是版本号了。</p>
<pre class="line-numbers"><code class="language-plain_text">// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        google()
        jcenter()
        maven {
            url uri('D:/repository')  //add
        }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.5.2'
        classpath 'com.example.watson.plugin:watsonPlugin:1.0.0' //add
    }
}

allprojects {
    repositories {
        google()
        jcenter()
        
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre>
<p>添加上面代码后Sync一下就能看见在引用Module的Tasks-&gt;other下面看到我们的Task了：</p>
<p><figure><img src="media/16299652966526/16299686431989.jpg" alt="" /></figure></p>
<p>到这一步就是大功告成了，点击下这个Task就能执行请求网络和打印日志了。</p>
<p><figure><img src="media/16299652966526/16299686531808.jpg" alt="" /></figure></p>
<h2><a id="%E8%B0%83%E8%AF%95%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调试插件</h2>
<h3><a id="%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建配置</h3>
<p><figure><img src="media/16299652966526/16593191062520.jpg" alt="" /></figure><br />
点击<strong>Edit Configurations</strong>，点击 <strong>+</strong> 号，然后点击<strong>Remote JVM Debug</strong>。</p>
<p><figure><img src="media/16299652966526/16593191693492.jpg" alt="" /></figure></p>
<p>生成一个<strong>Remote JVM Debug</strong>的配置，<strong>Name</strong>可以随意修改，但红框圈出来的地方不要修改， <strong>Use module classpath</strong>选择要调试的模块路径。</p>
<p><figure><img src="media/16299652966526/16593192854486.jpg" alt="" /></figure></p>
<h3><a id="%E5%88%9B%E5%BB%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建调试环境</h3>
<p>在工程的根目录下开启Gradle远程调试，如下所示： <code>export GRADLE_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005&quot;</code></p>
<h3><a id="%E8%B0%83%E8%AF%95%E9%98%B6%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调试阶段</h3>
<p>将需要调试的插件打上断点，然后在根目录下开始执行插件的任务，如下所示： <code>./gradlew [task](assembleDebug) -Dorg.gradle.daemon=false -Dorg.gradle.debug=true</code> 这个时候会提示<code>Listening for transport dt_socket at address: 5005</code>，表示调试环境已经创建完成了。</p>
<p><figure><img src="media/16299652966526/16593194237621.jpg" alt="" /></figure></p>
<p>下一步，我们需要点击<code>Debug</code>的断点，开始进入调试。</p>
<p><figure><img src="media/16299652966526/16593194411111.jpg" alt="" /></figure></p>
<h3><a id="%E7%BB%93%E6%9D%9F%E8%B0%83%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结束调试</h3>
<p>当调试结束后，我们需要关闭远程调试，即将GRADLE_OPTS置空。 <code>export GRADLE_OPTS=&quot;&quot;</code></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/08/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Gradle.html'>Gradle</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16299648825877.html">
                
                  <h1>Android的编译打包流程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%AE%98%E6%96%B9%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>官方说明</h2>
<p>下图的是官网对于Android编译打包流程的介绍。</p>
<p><figure><img src="media/16299648825877/16299649245435.jpg" alt="" /></figure></p>
<h2><a id="%E7%BB%86%E5%8C%96%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>细化流程</h2>
<p><figure><img src="media/16299648825877/16299649831040.jpg" alt="" /></figure></p>
<p>aapt是android中的资源打包工具，打包资源就用它。</p>
<h2><a id="%E6%89%93%E5%8C%85%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打包大致流程</h2>
<ol>
<li>aapt把resources目录下的资源生成R.java文件和resources.arsc ，并为AndroidManifest.xml生成Manifest.java类。</li>
<li>aidl把项目中自定义的aidl文件生成对应的java类。</li>
<li>JavaCompiler把所有的Java源文件编译成class文件，包括：aapt生成的、aidl生成的、项目中自有的java源文件</li>
<li>使用proguard混淆，并生成一个proguardMapping.xml文件（可选项：可以混淆也可以不混淆）</li>
<li>使用dex工具把所有的class文件生成.dex文件</li>
<li>使用aapt资源打包工具把resources、assets目录下的资源打包成一个_ap文件</li>
<li>使用apkbuilder把所有的dex、_ap文件、AndroidManifest.xml文件打包成一个未签名的apk</li>
<li>使用jarsinger生成一个签名过的apk包</li>
<li>使用zipalign工具对要发布的apk文件进行对齐操作，以便在运行时节约内存。</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/08/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16299642191691.html">
                
                  <h1>ASM字节码插桩</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>之前已经学习过了AspectJ的插桩形式。AspectJ是Java中流行的AOP编程扩展框架，从底层实现上来看，AspectJ内部使用的是BCEL框架来完成，在使用上来看，AspectJ框架有自己的一定优势：成熟稳定、使用简单。但是相比于ASM，它的功能无法满足某些场景的需求，如果想针对所有函数都做插桩，AspectJ会带来不少的性能影响。</p>
<h2><a id="asm" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ASM</h2>
<p>ASM 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。<br />
ASM的功能非常强大，它可以满足100%的场景，其主要特点有：</p>
<ul>
<li>操作灵活，可以根据需求自定义修改、插入、删除。</li>
<li>上手难， 需要对Java字节码有比较深入的了解。</li>
</ul>
<p>ASM更加高效直接，因而有时需要掌握一些必不可少的Java字节码知识以及Java虚拟机运行机制。</p>
<h2><a id="android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Android打包流程</h2>
<p>详见 <a href="16299648825877.html">Android的编译打包流程</a></p>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89gradle%E6%8F%92%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义Gradle插件</h2>
<p>详见 <a href="16299652966526.html">自定义Gradle插件</a></p>
<h2><a id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8transform-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何使用Transform API</h2>
<p>因为是编译期间搞事情，所以首先要在编译期间找一个时间点，这也就是本节 Transform 的内容，找到“作案”地点后，接下来就是“作案对象”了，这里选择的是对编译后的 .class 字节码下手，要用到的工具就是后面要介绍的 ASM 了。</p>
<p><figure><img src="media/16299642191691/16300316152463.jpg" alt="" /></figure></p>
<p>上面是官方出品的编译打包签名流程，我们要搞事情的位置就是 Java Compiler 编译成 .class Files 之到打包为 .dex Files 这之间。Google 官方在 Android Gradle 的 1.5.0 版本以后提供了 Transfrom API, 允许第三方自定义插件在打包 dex 文件之前的编译过程中操作 .class 文件，所以这里先要做的就是实现一个自定义的 Transform 进行.class文件遍历拿到所有方法，修改完成对原文件进行替换。</p>
<p>下面说一下如何引入 Transform 依赖，在 Android gradle 插件 1.5 版本以前，是有一个单独的 transform api 的；从 2.0 版本开始，就直接并入到 gradle api 中了。</p>
<p><strong>Gradle 1.5:</strong></p>
<pre class="line-numbers"><code class="language-plain_text">Compile ‘com.android.tools.build:transfrom-api:1.5.0’
</code></pre>
<p><strong>Gradle 2.0 开始:</strong></p>
<pre class="line-numbers"><code class="language-plain_text">implementation 'com.android.tools.build:gradle:3.5.2'
</code></pre>
<p>Transform是作用在.class编译后，打包成.dex前，可以对.class和resource进行再处理的部分。为了验证，我们建立一个项目Build的一次。</p>
<p><figure><img src="media/16299642191691/16300317711266.jpg" alt="" /></figure></p>
<p>可以很清楚的看到，原生就带了一系列Transform供使用。那么这些Transform是怎么组织在一起的呢，我们用一张图表示：</p>
<p><figure><img src="media/16299642191691/16300318396313.jpg" alt="" /></figure></p>
<p>每个Transform其实都是一个gradle task，Android编译器中的TaskManager将每个Transform串连起来，第一个Transform接收来自javac编译的结果，以及已经拉取到在本地的第三方依赖（jar. aar），还有resource资源，注意，这里的resource并非android项目中的res资源，而是asset目录下的资源。 这些编译的中间产物，在Transform组成的链条上流动，每个Transform节点可以对class进行处理再传递给下一个Transform。我们常见的混淆，Desugar等逻辑，它们的实现如今都是封装在一个个Transform中，而我们自定义的Transform，会插入到这个Transform链条的最前面。</p>
<p>但其实，上面这幅图，只是展示Transform的其中一种情况。而Transform其实可以有两种输入，一种是消费型的，当前Transform需要将消费型型输出给下一个Transform，另一种是引用型的，当前Transform可以读取这些输入，而不需要输出给下一个Transform，比如Instant Run就是通过这种方式，检查两次编译之间的diff的。</p>
<h2><a id="transform%E8%A7%A3%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transform解读</h2>
<pre class="line-numbers"><code class="language-java">class TraceTransform extends Transform {

    @Override
    String getName() {
        return &quot;TraceLog&quot;    }

    @Override
    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
        return TransformManager.CONTENT_CLASS    }

    @Override
    Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT    }

    @Override
    boolean isIncremental() {
        return true
    }

    @Override
    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        super.transform(transformInvocation)
        ......
    }
}
</code></pre>
<p>我们一项项分析：</p>
<h3><a id="1-getname" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.getName</h3>
<pre class="line-numbers"><code class="language-plain_text">    @Override
    String getName() {
        return &quot;TraceLog&quot;    
    }
</code></pre>
<p>Name顾名思义，就是我们的Transform名称，再回到我们刚刚Build的流程里：<br />
<figure><img src="media/16299642191691/16300325934575.jpg" alt="" /></figure><br />
这个最终的名字是如何构成的呢？好像跟我们这边的定义的名字有区别。以transform开头，之后拼接ContentType，这个ContentType代表着这个Transform的输入文件的类型，类型主要有两种，一种是Classes，另一种是Resources，ContentType之间使用And连接，拼接完成后加上With，之后紧跟的就是这个Transform的Name，name在getName()方法中重写返回即可。</p>
<h3><a id="2-getinputtypes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2.getInputTypes</h3>
<pre class="line-numbers"><code class="language-plain_text">    @Override
    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
        return TransformManager.CONTENT_CLASS    
    }
</code></pre>
<p>先来看代码注释，注释写的很清晰了，必须是CLASSES(0x01),RESOURCES(0x02)之一，相当于Transform需要处理的类型。</p>
<pre class="line-numbers"><code class="language-plain_text">    /**
     * Returns the type(s) of data that is consumed by the Transform. This may be more than
     * one type.
     *
     * &lt;strong&gt;This must be of type {@link QualifiedContent.DefaultContentType}&lt;/strong&gt;
     */
    @NonNull
    public abstract Set&lt;ContentType&gt; getInputTypes();
    
    ----------------------------------
    
     /**
     * The type of of the content.
     */
    enum DefaultContentType implements ContentType {
        /**
         * The content is compiled Java code. This can be in a Jar file or in a folder. If
         * in a folder, it is expected to in sub-folders matching package names.
         */
        CLASSES(0x01),

        /** The content is standard Java resources. */
        RESOURCES(0x02);

        private final int value;

        DefaultContentType(int value) {
            this.value = value;
        }

        @Override
        public int getValue() {
            return value;
        }
    }

</code></pre>
<h3><a id="3-getscopes" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.getScopes</h3>
<pre class="line-numbers"><code class="language-java">    @Override
    Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT    
    }
</code></pre>
<p>先来看源码注释，这个的作用相当于用来Transform表明作用域</p>
<pre class="line-numbers"><code class="language-java">    /**
     * Returns the scope(s) of the Transform. This indicates which scopes the transform consumes.
     */
    @NonNull
    public abstract Set&lt;Scope&gt; getScopes();
开发一共可以选如下几种：

    /**
     * The scope of the content.
     *
     * &lt;p&gt;
     * This indicates what the content represents, so that Transforms can apply to only part(s)
     * of the classes or resources that the build manipulates.
     */
    enum Scope implements ScopeType {
        /** Only the project (module) content */
        PROJECT(0x01),
        /** Only the sub-projects (other modules) */
        SUB_PROJECTS(0x04),
        /** Only the external libraries */
        EXTERNAL_LIBRARIES(0x10),
        /** Code that is being tested by the current variant, including dependencies */
        TESTED_CODE(0x20),
        /** Local or remote dependencies that are provided-only */
        PROVIDED_ONLY(0x40),

        /**
         * Only the project's local dependencies (local jars)
         *
         * @deprecated local dependencies are now processed as {@link #EXTERNAL_LIBRARIES}
         */
        @Deprecated        PROJECT_LOCAL_DEPS(0x02),
        /**
         * Only the sub-projects's local dependencies (local jars).
         *
         * @deprecated local dependencies are now processed as {@link #EXTERNAL_LIBRARIES}
         */
        @Deprecated        SUB_PROJECTS_LOCAL_DEPS(0x08);

</code></pre>
<p>一般来说如果是要处理所有class字节码，Scope我们一般使用TransformManager.SCOPE_FULL_PROJECT。即</p>
<pre class="line-numbers"><code class="language-java">public static final Set&lt;Scope&gt; SCOPE_FULL_PROJECT = Sets.immutableEnumSet(Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES);
</code></pre>
<h3><a id="4-isincremental" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4.isIncremental</h3>
<pre class="line-numbers"><code class="language-java">@Override
boolean isIncremental() {
    return true
}
</code></pre>
<p>增量编译开关。当我们开启增量编译的时候，相当input包含了changed/removed/added三种状态，实际上还有notchanged。需要做的操作如下：</p>
<ul>
<li><strong>NOTCHANGED</strong>: 当前文件不需处理，甚至复制操作都不用；</li>
<li><strong>ADDED</strong>、<strong>CHANGED</strong>: 正常处理，输出给下一个任务；</li>
<li><strong>REMOVED</strong>: 移除outputProvider获取路径对应的文件。</li>
</ul>
<h3><a id="5-transform" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>5.transform</h3>
<pre class="line-numbers"><code class="language-java">@Override
void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
    super.transform(transformInvocation)
    ......
}
</code></pre>
<p>先来看一下源码注释，它是Transform处理文件的核心代码：</p>
<pre class="line-numbers"><code class="language-java"> /**
     * Executes the Transform.
     *
     * &lt;p&gt;The inputs are packaged as an instance of {@link TransformInvocation}
     * &lt;ul&gt;
     *     &lt;li&gt;The &lt;var&gt;inputs&lt;/var&gt; collection of {@link TransformInput}. These are the inputs
     *     that are consumed by this Transform. A transformed version of these inputs must
     *     be written into the output. What is received is controlled through
     *     {@link #getInputTypes()}, and {@link #getScopes()}.&lt;/li&gt;
     *     &lt;li&gt;The &lt;var&gt;referencedInputs&lt;/var&gt; collection of {@link TransformInput}. This is
     *     for reference only and should be not be transformed. What is received is controlled
     *     through {@link #getReferencedScopes()}.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * A transform that does not want to consume anything but instead just wants to see the content
     * of some inputs should return an empty set in {@link #getScopes()}, and what it wants to
     * see in {@link #getReferencedScopes()}.
     *
     * &lt;p&gt;Even though a transform's {@link Transform#isIncremental()} returns true, this method may
     * be receive &lt;code&gt;false&lt;/code&gt; in &lt;var&gt;isIncremental&lt;/var&gt;. This can be due to
     * &lt;ul&gt;
     *     &lt;li&gt;a change in secondary files ({@link #getSecondaryFiles()},
     *     {@link #getSecondaryFileOutputs()}, {@link #getSecondaryDirectoryOutputs()})&lt;/li&gt;
     *     &lt;li&gt;a change to a non file input ({@link #getParameterInputs()})&lt;/li&gt;
     *     &lt;li&gt;an unexpected change to the output files/directories. This should not happen unless
     *     tasks are improperly configured and clobber each other's output.&lt;/li&gt;
     *     &lt;li&gt;a file deletion that the transform mechanism could not match to a previous input.
     *     This should not happen in most case, except in some cases where dependencies have
     *     changed.&lt;/li&gt;
     * &lt;/ul&gt;
     * In such an event, when &lt;var&gt;isIncremental&lt;/var&gt; is false, the inputs will not have any
     * incremental change information:
     * &lt;ul&gt;
     *     &lt;li&gt;{@link JarInput#getStatus()} will return {@link Status#NOTCHANGED} even though
     *     the file may be added/changed.&lt;/li&gt;
     *     &lt;li&gt;{@link DirectoryInput#getChangedFiles()} will return an empty map even though
     *     some files may be added/changed.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param transformInvocation the invocation object containing the transform inputs.
     * @throws IOException if an IO error occurs.
     * @throws InterruptedException
     * @throws TransformException Generic exception encapsulating the cause.
     */
    public void transform(@NonNull TransformInvocation transformInvocation)
            throws TransformException, InterruptedException, IOException {
        // Just delegate to old method, for code that uses the old API.
        //noinspection deprecation
        transform(transformInvocation.getContext(), transformInvocation.getInputs(),
                transformInvocation.getReferencedInputs(),
                transformInvocation.getOutputProvider(),
                transformInvocation.isIncremental());
    }
</code></pre>
<p>大致意思如下，具体大家一定要仔细看注释：</p>
<ul>
<li>如果拿取了getInputs()的输入进行消费，则transform后必须再输出给下一级</li>
<li>如果拿取了getReferencedInputs()的输入，则不应该被transform。</li>
<li>是否增量编译要以transformInvocation.isIncremental()为准。</li>
</ul>
<p>在 transform 方法中主要做的事情就是把 Inputs 保存到 outProvider 提供的位置去。生成的位置见下图：<br />
<figure><img src="media/16299642191691/16300345809682.jpg" alt="" /></figure></p>
<p>后面会讲到代码，主要有两个 transform 方法，一个 transformJar 就是简单的拷贝，另一个 transformDirectory，我们就是在这里用 ASM 对字节码进行修改的。</p>
<h2><a id="transform%E6%B3%A8%E5%86%8C%E5%92%8C%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transform注册和使用</h2>
<p>在gradle插件中注册</p>
<pre class="line-numbers"><code class="language-java">class TracePlugin implements Plugin&lt;Project&gt;{

    @Override
    void apply(Project project) {
        println &quot;------trace plugin begin-------&quot;
        def android = project.extensions.findByType(AppExtension.class)
        android.registerTransform(new TraceTransform(project))
        println &quot;------trace plugin end-------&quot;
    }

}
</code></pre>
<p>参考<a href="16300352865963.html">Gradle Transform详解</a></p>
<h2><a id="asm%E5%BA%93%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ASM库结构</h2>
<p>ASM 库是一款基于 Java 字节码层面的代码分析和修改工具。ASM 可以直接生产二进制的 class 文件，也可以在类被加载入 JVM 之前动态修改类行为。<br />
ASM 库的结构如下所示：</p>
<p><figure><img src="media/16299642191691/16300433538254.jpg" alt="" /></figure></p>
<ul>
<li><strong>Core</strong>：为其他包提供基础的读、写、转化Java字节码和定义的API，并且可以生成Java字节码和实现大部分字节码的转换，在 访问者模式和ASM 中介绍的几个重要的类就在 Core API 中：ClassReader、ClassVisitor 和 ClassWriter 类.</li>
<li><strong>Tree</strong>：提供了 Java 字节码在内存中的表现</li>
<li><strong>Commons</strong>：提供了一些常用的简化字节码生成、转换的类和适配器</li>
<li><strong>Util</strong>：包含一些帮助类和简单的字节码修改类，有利于在开发或者测试中使用</li>
<li><strong>XML</strong>：提供一个适配器将XML和SAX-comliant转化成字节码结构，可以允许使用XSLT去定义字节码转化</li>
</ul>
<h3><a id="core-api%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Core API 介绍</h3>
<p><figure><img src="media/16299642191691/16593607509568.jpg" alt="" /></figure></p>
<ul>
<li><strong>ClassReader类</strong>，负责读取.class文件里的内容，然后拆分成各个不同的部分。</li>
<li><strong>ClassVisitor类</strong>，负责对.class文件中某一部分里的信息进行修改。</li>
<li><strong>ClassWriter类</strong>，负责将各个不同的部分重新组合成一个完整的.class文件。</li>
</ul>
<p><figure><img src="media/16299642191691/16587520665262.jpg" alt="ASM调用时序" /><figcaption>ASM调用时序<figcaption></figure></p>
<p><figure><img src="media/16299642191691/16587521735794.jpg" alt="ASM核心类关系" /><figcaption>ASM核心类关系<figcaption></figure></p>
<h4><a id="1-classvisitor%E6%8A%BD%E8%B1%A1%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(1)ClassVisitor 抽象类</h4>
<p>如下所示，在 ClassVisitor 中提供了和类结构同名的一些方法，这些方法会对类中相应的部分进行操作，而且是有顺序的：</p>
<pre class="line-numbers"><code class="language-plain_text">visit
[ visitSource ] 
[ visitOuterClass ] 
( visitAnnotation | visitAttribute )* 
( visitInnerClass | visitField | visitMethod )* 
visitEnd
</code></pre>
<p>visit方法最先被调用，接着调用零次或一次visitSource方法，调用零次或一次visitOuterClass方法，接下来按任意顺序调用任意多次visitAnnotation和visitAttribute方法，再按任意顺序调用任意多次visitInnerClass、visitField、visitMethod方法，最后调用visitEnd。</p>
<pre class="line-numbers"><code class="language-java">public abstract class ClassVisitor {
    ......

    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces);
    public void visitSource(String source, String debug);
    public void visitOuterClass(String owner, String name, String desc);
    public AnnotationVisitor visitAnnotation(String desc, boolean visible);
    public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String desc, boolean visible);
    public void visitAttribute(Attribute attr);
    public void visitInnerClass(String name, String outerName, String innerName, int access);
    public FieldVisitor visitField(int access, String name, String desc, String signature, Object value);
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions);
    public void visitEnd();
}
</code></pre>
<ul>
<li><code>void visit(int version, int access, String name, String signature, String superName, String[] interfaces)</code> 该方法是当扫描类时第一个调用的方法，主要用于类声明使用。下面是对方法中各个参数的示意：visit( 类版本 , 修饰符 , 类名 ,泛型信息 , 继承的父类 , 实现的接口)</li>
<li><code>AnnotationVisitor visitAnnotation(String desc, boolean visible)</code> 该方法是当扫描器扫描到类注解声明时进行调用。下面是对方法中各个参数的示意：visitAnnotation(注解类型 , 注解是否可以在JVM 中可见)。</li>
<li><code>FieldVisitor visitField(int access, String name, String desc, String signature, Object value)</code> 该方法是当扫描器扫描到类中字段时进行调用。下面是对方法中各个参数的示意：visitField(修饰符 , 字段名 , 字段类型 , 泛型描述 , 默认值)</li>
<li><code>MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions)</code> 该方法是当扫描器扫描到类的方法时进行调用。下面是对方法中各个参数的示意：visitMethod(修饰符 , 方法名 , 方法签名 ,泛型信息 , 抛出的异常)</li>
<li><code>void visitEnd()</code> 该方法是当扫描器完成类扫描时才会调用，如果想在类中追加某些方法</li>
</ul>
<h4><a id="2-classreader%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(2)ClassReader类</h4>
<p>这个类会将 .class 文件读入到 ClassReader 中的字节数组中，它的 accept 方法接受一个 ClassVisitor 实现类，并按照顺序调用 ClassVisitor 中的方法。<br />
值得注意的是，ClassReader类accept方法的第二个参数flags是一个位掩码（bit-mask），可以选择组合的值有下面这些。</p>
<ul>
<li><strong>SKIP_DEBUG</strong>：跳过类文件中的调试信息，比如行号信息（LineNumberTable）等。</li>
<li><strong>SKIP_CODE</strong>：跳过方法体中的Code属性（方法字节码、异常表等）。</li>
<li><strong>EXPAND_FRAMES</strong>：展开StackMapTable属性。</li>
<li><strong>SKIP_FRAMES</strong>：跳过StackMapTable属性。</li>
</ul>
<h4><a id="3-classwriter%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(3)ClassWriter 类</h4>
<p>ClassWriter 是一个 ClassVisitor 的子类，是和 ClassReader 对应的类，ClassReader 是将 .class 文件读入到一个字节数组中，ClassWriter 是将修改后的类的字节码内容以字节数组的形式输出。在ClassVisitor的visit方法中可以对原始的字节码做修改，ClassWriter的toByteArray方法则把最终修改的字节码以byte数组的形式返回。</p>
<h4><a id="4-methodvisitor-adviceadapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(4)MethodVisitor &amp; AdviceAdapter</h4>
<p>MethodVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Method 时就转入 MethodVisitor 接口处理。<br />
AdviceAdapter 是 MethodVisitor 的子类，使用 AdviceAdapter 可以更方便的修改方法的字节码。其中比较重要的几个方法如下：</p>
<ul>
<li><code>void visitCode()</code>：表示 ASM 开始扫描这个方法</li>
<li><code>void onMethodEnter()</code>：进入这个方法</li>
<li><code>void onMethodExit()</code>：即将从这个方法出去</li>
<li><code>void onVisitEnd()</code>：表示方法扫码完毕</li>
</ul>
<p>用于生成和变转已编译方法的都是基于 <code>MethodVisitor</code> 抽象类的，它由 <code>ClassVisitor.visitMethod()</code> 方法返回。</p>
<p><a href="16594943664575.html">ASM - MethodVisitor</a></p>
<h4><a id="5-fieldvisitor%E6%8A%BD%E8%B1%A1%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>(5)FieldVisitor 抽象类</h4>
<p>FieldVisitor 是一个抽象类，当 ASM 的 ClassReader 读取到 Field 时就转入 FieldVisitor 接口处理。和分析 MethodVisitor 的方法一样，也可以查看源码注释进行学习，这里不再详细介绍。</p>
<h2><a id="%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>操作流程</h2>
<ol>
<li>需要创建一个 ClassReader 对象，将 .class 文件的内容读入到一个字节数组中</li>
<li>然后需要一个 ClassWriter 的对象将操作之后的字节码的字节数组回写</li>
<li>需要事件过滤器 ClassVisitor。在调用 ClassVisitor 的某些方法时会产生一个新的 XXXVisitor对象，当我们需要修改对应的内容时只要实现自己的 XXXVisitor 并返回就可以了</li>
</ol>
<pre class="line-numbers"><code class="language-java">input.directoryInputs.each { DirectoryInput directoryInput -&gt;
    if (directoryInput.file.isDirectory()) {
        directoryInput.file.eachFileRecurse { File file -&gt;
            def name = file.name
            if (name.endsWith(&quot;.class&quot;) &amp;&amp; !(name == (&quot;R.class&quot;)) &amp;&amp; !name.startsWith(&quot;R\$&quot;) &amp;&amp; !(name == (&quot;BuildConfig.class&quot;))) {

                ClassReader reader = new ClassReader(file.bytes)
                ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS)
                ClassVisitor visitor = new TraceVisitor(writer)
                reader.accept(visitor, ClassReader.EXPAND_FRAMES)

                byte[] code = writer.toByteArray()
                def classPath = file.parentFile.absolutePath + File.separator + name
                FileOutputStream fos = new FileOutputStream(classPath)
                fos.write(code)
                fos.close()
            }
        }
    }
</code></pre>
<p>虽然有了ASM这种框架，可以很方便的修改class文件，但是如果不熟悉框架的使用，写起来还是有点吃力<br />
人类总是懒惰的，试图找出一些捷径，于是有了一款Idea插件——<strong>ASM Bytecode Outline</strong></p>
<h2><a id="%E5%AE%9E%E8%B7%B5%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实践操作</h2>
<h3><a id="%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新增一个字段</h3>
<p>以以下代码为例，使用javac编译为class文件</p>
<pre class="line-numbers"><code class="language-java">public class MyMain {
}
</code></pre>
<p>这里采用<code>visitEnd</code>方法中进行添加字段的操作，使用下面的代码可以给<code>MyMain</code>新增一个String类型的<code>xyz</code>字段</p>
<pre class="line-numbers"><code class="language-kotlin">val bytes: ByteArray = FileUtils.readFileToByteArray(File(&quot;./MyMain.class&quot;))
val cr: ClassReader = ClassReader(bytes)
val cw: ClassWriter = ClassWriter(0)
val cv: ClassVisitor = object : ClassVisitor(ASM9, cw) {
    override fun visitEnd() {
        super.visitEnd()
        val fv: FieldVisitor = cv.visitField(Opcodes.ACC_PUBLIC, &quot;xyz&quot;, &quot;Ljava/lang/String;&quot;, null, null)
        if (fv != null) fv.visitEnd()
    }
}
cr.accept(cv, ClassReader.SKIP_CODE or ClassReader.SKIP_DEBUG)
val bytesModified: ByteArray = cw.toByteArray()
FileUtils.writeByteArrayToFile(File(&quot;./MyMain2.class&quot;), bytesModified)
</code></pre>
<p>使用javap查看<code>MyMain2</code>的字节码，可以看到已经多了一个类型为String的<code>xyz</code>变量。</p>
<h3><a id="%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新增方法</h3>
<p>同样以<code>MyMain</code>类为例，给这个类新增一个<code>xyz</code>方法。</p>
<pre class="line-numbers"><code class="language-kotlin">val bytes: ByteArray = FileUtils.readFileToByteArray(File(&quot;./MyMain.class&quot;))
val cr: ClassReader = ClassReader(bytes)
val cw: ClassWriter = ClassWriter(0)
val cv: ClassVisitor = object : ClassVisitor(ASM9, cw) {
    override fun visitEnd() {
        super.visitEnd()
        val mv: MethodVisitor = cv.visitMethod(Opcodes.ACC_PUBLIC, &quot;xyz&quot;, &quot;(ILjava/lang/String;)V&quot;, null, null)
        if (mv != null) mv.visitEnd()
    }
}
cr.accept(cv, ClassReader.SKIP_CODE or ClassReader.SKIP_DEBUG)
val bytesModified: ByteArray = cw.toByteArray()
FileUtils.writeByteArrayToFile(File(&quot;./MyMain2.class&quot;), bytesModified)
</code></pre>
<p>使用javap查看<code>MyMain2</code>的字节码，确认<code>xyz</code>方法已经生成。</p>
<h3><a id="%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95%E5%92%8C%E5%AD%97%E6%AE%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>移除方法和字段</h3>
<p>以下面<code>MyMain</code>类为例，删掉<code>abc</code>字段和<code>xyz</code>方法</p>
<pre class="line-numbers"><code class="language-plain_text">public class MyMain {
    private int abc = 0;
    private int def = 0;
    
    public void foo() {}
    
    public int xyz(int a, String b) {
        return 0;
    }
}
</code></pre>
<p>如果仔细观察<code>ClassVisitor</code>类的<code>visit</code>方法，会发现<code>visitField</code>、<code>visitMethod</code>等方法是有返回值的，如果这些方法直接返回<code>null</code>，这些字段、方法将从类中被移除，代码如下所示。</p>
<pre class="line-numbers"><code class="language-kotlin">val bytes: ByteArray = FileUtils.readFileToByteArray(File(&quot;./MyMain.class&quot;))
val cr: ClassReader = ClassReader(bytes)
val cw: ClassWriter = ClassWriter(0)
val cv: ClassVisitor = object : ClassVisitor(ASM9, cw) {
    override fun visitField(access: Int, name: String?, descriptor: String?, signature: String?, value: Any?): FieldVisitor? {
        if (&quot;abc&quot; == name) return null
        return super.visitField(access, name, descriptor, signature, value)
    }

    override fun visitMethod(access: Int, name: String?, descriptor: String?, signature: String?, exceptions: Array&lt;out String&gt;?): MethodVisitor? {
        if (&quot;xyz&quot; == name) return null

        return super.visitMethod(access, name, descriptor, signature, exceptions)
    }
}
cr.accept(cv, ClassReader.SKIP_CODE or ClassReader.SKIP_DEBUG)
val bytesModified: ByteArray = cw.toByteArray()
FileUtils.writeByteArrayToFile(File(&quot;./MyMain2.class&quot;), bytesModified)
</code></pre>
<h3><a id="%E4%BF%AE%E6%94%B9%E6%96%B9%E6%B3%95%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改方法内容</h3>
<p>MethodVisitor类主要用来处理访问一个方法触发的事件，与ClassVisitor一样，它也有很多<code>visit</code>方法，这些<code>visit</code>方法也有一定的调用时序。</p>
<pre class="line-numbers"><code class="language-plain_text">(visitParameter)* 
[visitAnnotationDefault] 
(visitAnnotation | visitParameterAnnotation | visitAttribute)*
[
    visitCode 
    (visitFrame | visit&lt;i&gt;X&lt;/i&gt;Insn | visitLabel | visitInsnAnnotation | visitTryCatchBlock | visitTryCatchAnnotation | visitLocalVariable | visitLocalVariableAnnotation | visitLineNumber )* 
    visitMaxs
]
</code></pre>
<p>其中<code>visitCode</code>和<code>visitMaxs</code>可以作为方法体中字节码的开始和结束，<code>visitEnd</code>是MethodVisitor所有事件的结束。</p>
<p>以下面的<code>foo</code>方法为例，把方法体的返回值改为<code>a+100</code></p>
<pre class="line-numbers"><code class="language-java">public class MyMain {
    public static void main(String[] args) {
        System.out.println(new MyMain().foo(1));
    }

    public int foo(int a) {
        return a; // 修改为 return a + 100;
    }
}
</code></pre>
<p>为了替换foo的方法体，一个可选的做法是在ClassVisitor的<code>visitMethod</code>方法返回<code>null</code>以删除原<code>foo</code>方法，然后在<code>visitEnd</code>方法中新增一个foo方法，如下面的代码所示：</p>
<pre class="line-numbers"><code class="language-plain_text">byte[] bytes = FileUtils.readFileToByteArray(new File(&quot;./MyMain.class&quot;));
ClassReader cr = new ClassReader(bytes);
ClassWriter cw = new ClassWriter(0);
ClassVisitor cv = new ClassVisitor(ASM7, cw) {
    @Override
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {

        if (&quot;foo&quot;.equals(name)) {
            // 删除 foo 方法
            return null;
        }
        return super.visitMethod(access, name, desc, signature, exceptions);
    }

    @Override
    public void visitEnd() {
        // 新增 foo 方法
        MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, &quot;foo&quot;, &quot;(I)I&quot;, null, null);

        mv.visitCode();
        mv.visitVarInsn(Opcodes.ILOAD, 1);
        mv.visitIntInsn(Opcodes.BIPUSH, 100);
        mv.visitInsn(Opcodes.IADD);
        mv.visitInsn(Opcodes.IRETURN);
        mv.visitEnd();
    }
};
cr.accept(cv, 0);
byte[] bytesModified = cw.toByteArray();
FileUtils.writeByteArrayToFile(new File(&quot;./MyMain.class&quot;), bytesModified);
</code></pre>
<p>使用javap查看生成的foo方法字节码，可以看到方法字节码已经被替换，如下所示。</p>
<pre class="line-numbers"><code class="language-plain_text">public int foo();
descriptor: ()I
flags: ACC_PUBLIC
Code:
stack=0, locals=0, args_size=1
 0: iload_1
 1: bipush        100
 3: iadd
 4: ireturn
</code></pre>
<p>使用java运行MyMain，会发现抛出了ClassFormatError异常，提示入参无法放到局部变量表locals中，详细的错误信息如下所示。</p>
<pre class="line-numbers"><code class="language-plain_text">java -cp . MyMain    
Error: A JNI error has occurred, please check your installation and try again
Exception in thread &quot;main&quot; java.lang.ClassFormatError: Arguments can't fit into locals in class file MyMain
</code></pre>
<p>再回过头来查看生成的字节码，会发现它的stack和locals都等于0，从前面的内容可以知道Java虚拟机根据字节码中stack和locals的值来分配操作数栈和局部变量表的空间，如果两个值都等于0则不能加载操作数和存储方法参数。</p>
<p>从源代码可以分析出，最大栈的大小为2（a，100），局部变量表的大小为2（this，a）。一个可选的办法是在<code>mv.visitEnd()</code>代码之前新增<code>mv.visitMaxs(2，2)</code>以手动指定stack和locals的大小。</p>
<p>另一个方法是让ASM自动计算stack和locals，这与ClassWriter构造器方法参数有关，如下所示。</p>
<ul>
<li><code>new ClassWriter(0)</code>：这种方式不会自动计算操作数栈和局部变量表的大小，需要我们手动指定。</li>
<li><code>new ClassWriter(ClassWriter.COMPUTE_MAXS)</code>：这种方式会自动计算操作数栈和局部变量表的大小，前提是需要调用<code>visitMaxs</code>来触发计算上述两个值，参数值可以随便指定。</li>
<li><code>new ClassWriter(ClassWriter.COMPUTE_FRAMES)</code>：不仅会计算操作数栈和局部变量表，还会自动计算StackMapFrames。在Java 6之后JVM在class文件的Code属性中引入了StackMapTable属性，作用是为了提高JVM在类型检查时验证过程的效率，里面记录的是一个方法中操作数栈与局部变量区的类型在一些特定位置的状态。</li>
</ul>
<p>虽然COMPUTE_FRAMES隐式地包含了COMPUTE_MAXS，一般在使用中还是会同时指定，调用的代码如下所示。</p>
<pre class="line-numbers"><code class="language-plain_text">new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES)
</code></pre>
<pre class="line-numbers"><code class="language-plain_text">byte[] bytes = FileUtils.readFileToByteArray(new File(&quot;./MyMain.class&quot;));
ClassReader cr = new ClassReader(bytes);
// 指定 ClassWriter 自动计算
ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);
ClassVisitor cv = new ClassVisitor(ASM7, cw) {
    @Override
    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {

        if (&quot;foo&quot;.equals(name)) {
            // 删除 foo 方法
            return null;
        }
        return super.visitMethod(access, name, desc, signature, exceptions);
    }

    @Override
    public void visitEnd() {
        // 新增 foo 方法
        MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, &quot;foo&quot;, &quot;(I)I&quot;, null, null);

        mv.visitCode();
        mv.visitVarInsn(Opcodes.ILOAD, 1);
        mv.visitIntInsn(Opcodes.BIPUSH, 100);
        mv.visitInsn(Opcodes.IADD);
        mv.visitInsn(Opcodes.IRETURN);
        // 触发计算
        mv.visitMaxs(0, 0);
        mv.visitEnd();
    }
};
cr.accept(cv, 0);
byte[] bytesModified = cw.toByteArray();
FileUtils.writeByteArrayToFile(new File(&quot;./MyMain.class&quot;), bytesModified);
</code></pre>
<p>这个时候使用java执行MyMain，就可以正常输出结果，如下所示。</p>
<pre class="line-numbers"><code class="language-plain_text">java -cp . MyMain
101
</code></pre>
<h3><a id="adviceadapter%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AdviceAdapter使用</h3>
<p>AdviceAdapter是一个抽象类，继承自MethodVisitor，可以很方便地在方法的开始和结束前插入代码，它的两个核心方法介绍如下所示。</p>
<ul>
<li><code>onMethodEnter</code>：方法开始或者构造器方法中父类的构造器调用以后被回调。</li>
<li><code>onMethodExit</code>：正常退出和异常退出时被调用。正常退出指的是遇到RETURN、ARETURN、LRETURN等方法正常返回的情况。异常退出指的是遇到ATHROW指令，有异常抛出方法返回的情况。</li>
</ul>
<h3><a id="%E7%BB%99%E6%96%B9%E6%B3%95%E5%8A%A0%E4%B8%8Atry-catch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>给方法加上try catch</h3>
<p>很显然上一个小节的代码无法在代码抛出未捕获异常时输出err quit，比如把foo代码做细微修改，如下所示。</p>
<pre class="line-numbers"><code class="language-plain_text">public void foo() {
    System.out.println(&quot;step 1&quot;);
    int a = 1 / 0;
    System.out.println(&quot;step 2&quot;);
}
</code></pre>
<p>这里需要介绍ASM的<code>Label</code>类，与它的英文含义一样，可以给字节码指令地址打标签，标记特定的字节码位置，用于后续跳转等。新增一个Label可以用MethodVisitor的visitLabel方法，如下所示。</p>
<pre class="line-numbers"><code class="language-plain_text">Label startLabel = new Label();
mv.visitLabel(startLabel);
</code></pre>
<p>JVM的异常处理是通过异常表来实现的，<code>try-catch-finally</code>语句块实际上是标定了异常处理的范围。ASM中可以用<code>visitTryCatchBlock</code>方法来给一段代码块增加异常表，它的方法签名如下所示。</p>
<pre class="line-numbers"><code class="language-plain_text">public void visitTryCatchBlock(Label start, Label end, Label handler, String type)
</code></pre>
<p>其中start、end表示异常表<strong>开始和结束的位置</strong>，handler表示<strong>异常发生后需要跳转到哪里继续执行</strong>，可以理解为catch语句块开始的位置，type是<strong>异常的类型</strong>。</p>
<p>为了给整个方法体包裹<code>try-catch</code>语句，<strong>start Label应该放在方法<code>visitCode</code>之后</strong>，<strong>end Label则放在<code>visitMaxs</code>调用之前</strong>，代码如下所示。</p>
<pre class="line-numbers"><code class="language-plain_text">Label startLabel = new Label();

@Override
protected void onMethodEnter() {
    super.onMethodEnter();
    mv.visitLabel(startLabel);

    mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
    mv.visitLdcInsn(&quot;enter &quot; + name);
    mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
}

@Override
public void visitMaxs(int maxStack, int maxLocals) {
    // 生成异常表
    Label endLabel = new Label();
    mv.visitTryCatchBlock(startLabel, endLabel, endLabel, null);
    mv.visitLabel(endLabel);
    
    // 生成异常处理代码块
    finallyBlock(ATHROW);
    mv.visitInsn(ATHROW);
    super.visitMaxs(maxStack, maxLocals);
}

private void finallyBlock(int opcode) {
    mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
    if (opcode == Opcodes.ATHROW) {
        mv.visitLdcInsn(&quot;err exit &quot; + name);
    } else {
        mv.visitLdcInsn(&quot;normal exit &quot; + name);
    }
    mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);
}

@Override
protected void onMethodExit(int opcode) {
    super.onMethodExit(opcode);
    // 处理正常返回的场景
    if (opcode != ATHROW) finallyBlock(opcode);
}
</code></pre>
<p>前面介绍过onMethodExit在方法正常退出和异常退出时都会被调用。添加完异常处理表以后，程序异常退出时都会进入异常代码处理模块，为了避免重复处理，在onMethodExit中只会处理正常退出的情况，不必处理ATHROW指令。</p>
<h2><a id="tracelog" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TraceLog</h2>
<p>使用自定义 Gradle 插件 + ASM 的方式实现了和 JakeWharton 的 hugo 库同样的功能的库，将特定注解的方法的传入参数、返回结果和执行时间打印到 Logcat 中，方便开发调试。</p>
<p><figure><img src="media/16299642191691/16300448202499.jpg" alt="" /></figure></p>
<p>整个工程分3个模块，主模块是调用方，就是使用@TraceLog的地方。plugin模块是自定义的gradle插件。因为打印日志和业务无关性，这里把打印日志的功能单独拆分成一个模块tracelibrary。plugin模块依赖traceLibrary，在字节码插桩时调用traceLibrary里面的方法打印日志。</p>
<h3><a id="%E8%87%AA%E5%AE%9A%E4%B9%89gradle-plugin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义gradle plugin</h3>
<p><strong>build.gradle</strong></p>
<pre class="line-numbers"><code class="language-java">apply plugin: 'groovy'
//使用该插件，才能使用uploadArchives
apply plugin: 'maven'

repositories {
    jcenter()
}

dependencies {
    //使用gradle sdk
    compile gradleApi()
    //使用groovy sdk
    compile localGroovy()
    implementation 'com.android.tools.build:gradle:3.5.2'
    implementation 'org.ow2.asm:asm-all:5.2'
}

sourceCompatibility = &quot;1.8&quot;
targetCompatibility = &quot;1.8&quot;

uploadArchives {
    repositories.mavenDeployer {
        pom.version = '1.0.0'
        pom.artifactId = 'tracePlugin'
        pom.groupId = 'com.example.watson.plugin'
        repository(url: &quot;file:///D:/repository/&quot;)
    }
}
</code></pre>
<p><strong>TracePlugin.groovy</strong></p>
<pre class="line-numbers"><code class="language-java">class TracePlugin implements Plugin&lt;Project&gt;{

    @Override
    void apply(Project project) {
        println &quot;------trace plugin begin-------&quot;
        def android = project.extensions.findByType(AppExtension.class)
        android.registerTransform(new TraceTransform(project))
        println &quot;------trace plugin end-------&quot;
    }

}
</code></pre>
<p><strong>TraceTransform.groovy</strong></p>
<pre class="line-numbers"><code class="language-java">class TraceTransform extends Transform {

    Project project

    TraceTransform(Project project) {
        this.project = project
    }

    @Override
    String getName() {
        return &quot;TraceLog&quot;
    }

    @Override
    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() {
        return TransformManager.CONTENT_CLASS
    }

    @Override
    Set&lt;? super QualifiedContent.Scope&gt; getScopes() {
        return TransformManager.SCOPE_FULL_PROJECT
    }

    @Override
    boolean isIncremental() {
        return false
    }

    @Override
    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {
        transformInvocation.inputs.each { TransformInput input -&gt;
            input.directoryInputs.each { DirectoryInput directoryInput -&gt;
                if (directoryInput.file.isDirectory()) {
                    directoryInput.file.eachFileRecurse { File file -&gt;
                        def name = file.name
                        if (name.endsWith(&quot;.class&quot;) &amp;&amp; !(name == (&quot;R.class&quot;))
                                &amp;&amp; !name.startsWith(&quot;R\$&quot;) &amp;&amp; !(name == (&quot;BuildConfig.class&quot;))) {

                            ClassReader reader = new ClassReader(file.bytes)
                            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS)
                            ClassVisitor visitor = new TraceVisitor(writer)
                            reader.accept(visitor, ClassReader.EXPAND_FRAMES)

                            byte[] code = writer.toByteArray()
                            def classPath = file.parentFile.absolutePath + File.separator + name
                            FileOutputStream fos = new FileOutputStream(classPath)
                            fos.write(code)
                            fos.close()
                        }
                    }
                }

                def dest = transformInvocation.outputProvider.getContentLocation(directoryInput.name,directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)

                FileUtils.copyDirectory(directoryInput.file, dest)
            }

            input.jarInputs.each { JarInput jarInput -&gt;
                def jarName = jarInput.name
                def md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())
                if (jarName.endsWith(&quot;.jar&quot;)) {
                    jarName = jarName.substring(0, jarName.length() - 4)
                }

                def dest = transformInvocation.outputProvider.getContentLocation(jarName + md5Name,jarInput.contentTypes, jarInput.scopes, Format.JAR)
                FileUtils.copyFile(jarInput.file, dest)
            }
        }
    }
}
</code></pre>
<p><strong>TraceVisitor.groovy</strong></p>
<pre class="line-numbers"><code class="language-java">class TraceVisitor extends ClassVisitor {

    private String mClassName

    TraceVisitor(ClassVisitor classVisitor) {
        super(Opcodes.ASM5, classVisitor)
    }

    @Override
    void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
        super.visit(version, access, name, signature, superName, interfaces);
        this.mClassName = name
    }

    @Override
    MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
        MethodVisitor methodVisitor = super.visitMethod(access, name, desc, signature, exceptions)
        methodVisitor = new TraceMethodVisitor(Opcodes.ASM5, methodVisitor, access, mClassName, name, desc)
        return methodVisitor
    }
}
</code></pre>
<p><strong>TraceMethodVisitor.groovy</strong></p>
<pre class="line-numbers"><code class="language-java">class TraceMethodVisitor extends AdviceAdapter {

    private static final String COST_ANNOTATION_DESC = &quot;Lcom/example/tracelibrary/TraceLog;&quot;

    private boolean isInjected = false

    private int startTimeId

    private int methodId

    private String className

    private String methodName

    private String desc

    private boolean isStaticMethod

    private Type[] argumentArrays

    TraceMethodVisitor(int api, MethodVisitor mv, int access, String className, String methodName, String desc) {
        super(api, mv, access, methodName, desc)
        this.className = className
        this.methodName = methodName
        this.desc = desc
        argumentArrays = Type.getArgumentTypes(desc)
        isStaticMethod = ((access &amp; Opcodes.ACC_STATIC) != 0)
    }

    @Override
    AnnotationVisitor visitAnnotation(String desc, boolean visible) {
        if (COST_ANNOTATION_DESC.equals(desc)) {
            isInjected = true
        }
        return super.visitAnnotation(desc, visible)
    }

    @Override
    protected void onMethodEnter() {
        if (isInjected) {
            methodId = newLocal(Type.INT_TYPE)
            mv.visitMethodInsn(INVOKESTATIC, &quot;com/example/tracelibrary/core/MethodCache&quot;, &quot;request&quot;, &quot;()I&quot;, false)
            mv.visitIntInsn(ISTORE, methodId)

            for (int i = 0; i &lt; argumentArrays.length; i++) {
                Type type = argumentArrays[i]
                int index = isStaticMethod ? i : (i + 1)
                switch (type.getSort()) {
                    case Type.BOOLEAN:
                    case Type.CHAR:
                    case Type.BYTE:
                    case Type.SHORT:
                    case Type.INT:
                        mv.visitVarInsn(ILOAD, index)
                        box(type)
                        break
                    case Type.FLOAT:
                        mv.visitVarInsn(FLOAD, index)
                        box(type)
                        break
                    case Type.LONG:
                        mv.visitVarInsn(LLOAD, index)
                        box(type)
                        break
                    case Type.DOUBLE:
                        mv.visitVarInsn(DLOAD, index)
                        box(type)
                        break
                    case Type.ARRAY:
                    case Type.OBJECT:
                        mv.visitVarInsn(ALOAD, index)
                        box(type)
                        break
                }
                mv.visitVarInsn(ILOAD, methodId)
                visitMethodInsn(INVOKESTATIC, &quot;com/example/tracelibrary/core/MethodCache&quot;, &quot;addMethodArgument&quot;,
                        &quot;(Ljava/lang/Object;I)V&quot;, false)
            }

            startTimeId = newLocal(Type.LONG_TYPE)
            mv.visitMethodInsn(INVOKESTATIC, &quot;java/lang/System&quot;, &quot;currentTimeMillis&quot;, &quot;()J&quot;, false)
            mv.visitIntInsn(LSTORE, startTimeId)
        }
    }

    @Override
    protected void onMethodExit(int opcode) {
        if (isInjected) {
            if (opcode == RETURN) {
                visitInsn(ACONST_NULL)
            } else if (opcode == ARETURN || opcode == ATHROW) {
                dup()
            } else {
                if (opcode == LRETURN || opcode == DRETURN) {
                    dup2()
                } else {
                    dup()
                }
                box(Type.getReturnType(this.methodDesc))
            }
            mv.visitLdcInsn(className)
            mv.visitLdcInsn(methodName)
            mv.visitLdcInsn(desc)
            mv.visitVarInsn(LLOAD, startTimeId)
            mv.visitVarInsn(ILOAD, methodId)
            mv.visitMethodInsn(INVOKESTATIC, &quot;com/example/tracelibrary/core/MethodCache&quot;, &quot;updateMethodInfo&quot;,
                    &quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;JI)V&quot;, false)

            mv.visitVarInsn(ILOAD, methodId)
            mv.visitMethodInsn(INVOKESTATIC, &quot;com/example/tracelibrary/core/MethodCache&quot;,
                    &quot;printMethodInfo&quot;, &quot;(I)V&quot;, false)
        }
    }
}
</code></pre>
<h3><a id="%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%87%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三方库文件</h3>
<p>看到，自定义gradle插件的TraceMethodVisitor会在方法执行前后织入需要的功能，这些功能就是第三方库的内容。</p>
<p><strong>build.gradle</strong></p>
<pre class="line-numbers"><code class="language-java">apply plugin: 'com.android.library'
//使用该插件，才能使用uploadArchives
apply plugin: 'maven'

android {
    compileSdkVersion 29
    buildToolsVersion &quot;29.0.2&quot;


    defaultConfig {
        minSdkVersion 15
        targetSdkVersion 29
        versionCode 1
        versionName &quot;1.0&quot;

        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;
        consumerProguardFiles 'consumer-rules.pro'
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }

}

dependencies {
    compile 'org.ow2.asm:asm-all:5.2'
}

uploadArchives {
    repositories.mavenDeployer {
        pom.version = '1.0.0'
        pom.artifactId = 'traceLibrary'
        pom.groupId = 'com.example.watson.library'
        repository(url: &quot;file:///D:/repository/&quot;)
    }
}
</code></pre>
<p><strong>MethodCache.java</strong></p>
<pre class="line-numbers"><code class="language-java">public class MethodCache {

    /**
     * 方法缓存默认大小
     */
    private static final int INIT_CACHE_SIZE = 1024;
    /**
     * 方法名缓存
     */
    private static Vector&lt;MethodInfo&gt; mCacheMethods = new Vector&lt;&gt;(INIT_CACHE_SIZE);

    /**
     * 占位并生成方法ID
     *
     * @return 返回 方法 Id
     */
    public static int request() {
        mCacheMethods.add(new MethodInfo());
        return mCacheMethods.size() - 1;
    }

    public static void addMethodArgument(Object argument, int id) {
        MethodInfo methodInfo = mCacheMethods.get(id);
        methodInfo.addArgument(argument);
    }

    public static void updateMethodInfo(Object result, String className, String methodName, String methodDesc, long startTime, int id) {
        MethodInfo methodInfo = mCacheMethods.get(id);
        methodInfo.setCost((System.currentTimeMillis() - startTime));
        methodInfo.setResult(result);
        methodInfo.setMethodDesc(methodDesc);
        methodInfo.setClassName(className);
        methodInfo.setMethodName(methodName);
    }

    public static void printMethodInfo(int id) {
        MethodInfo methodInfo = mCacheMethods.get(id);
        Printer.printMethodInfo(methodInfo);
    }
}
</code></pre>
<p><strong>MethodInfo.java</strong></p>
<pre class="line-numbers"><code class="language-java">public class MethodInfo {

    private static final String OUTPUT_FORMAT = &quot;The method's name is %s ,the cost is %dms and the result is &quot;;

    private String mClassName;              // 类名
    private String mMethodName;             // 方法名
    private String mMethodDesc;             // 方法描述符
    private Object mResult;                 // 方法执行结果
    private long mCost;                     // 方法执行耗时
    private List&lt;Object&gt; mArgumentList;     // 方法参数列表

    MethodInfo() {
        mArgumentList = new ArrayList&lt;&gt;();
    }

    @Override
    public String toString() {
        return String.format(Locale.CHINA, OUTPUT_FORMAT, getMethodName(), mCost) + mResult;
    }

    /**
     * @param className 设置类名
     */
    public void setClassName(String className) {
        mClassName = className;
    }

    /**
     * @return 返回类名
     */
    public String getClassName() {
        mClassName = mClassName.replace(&quot;/&quot;, &quot;.&quot;);
        return mClassName;
    }

    /**
     * @param methodName 设置方法名
     */
    public void setMethodName(String methodName) {
        mMethodName = methodName;
    }

    /**
     * @return 返回方法名
     */
    public String getMethodName() {
        StringBuilder msg = new StringBuilder();
        Type[] argumentTypes = Type.getArgumentTypes(mMethodDesc);
        msg.append('(');
        for (int i = 0; i &lt; argumentTypes.length; i++) {
            msg.append(argumentTypes[i].getClassName());
            if (i != argumentTypes.length - 1) {
                msg.append(&quot;, &quot;);
            }
        }
        msg.append(')');
        mMethodName = mMethodName + msg.toString();
        return mMethodName;
    }

    /**
     * @param cost 设置方法执行耗时
     */
    public void setCost(long cost) {
        this.mCost = cost;
    }

    /**
     * @return 返回方法执行耗时
     */
    public long getCost() {
        return mCost;
    }

    /**
     * @param result 设置方法执行结果
     */
    public void setResult(Object result) {
        this.mResult = result;
    }

    /**
     * @return 返回方法执行结果
     */
    public Object getResult() {
        return mResult;
    }

    /**
     * @param methodDesc 设置方法描述符
     */
    public void setMethodDesc(String methodDesc) {
        this.mMethodDesc = methodDesc;
    }

    /**
     * 添加方法参数
     *
     * @param argument 方法参数
     */
    public void addArgument(Object argument) {
        mArgumentList.add(argument);
    }

    /**
     * @return 得到方法参数列表
     */
    public List&lt;Object&gt; getArgumentList() {
        return mArgumentList;
    }
}
</code></pre>
<p><strong>Printer.java</strong></p>
<pre class="line-numbers"><code class="language-java">public class Printer {
    private static final String TAG = &quot;TraceLog&quot;;

    private static final char TOP_LEFT_CORNER = '┌';
    private static final char BOTTOM_LEFT_CORNER = '└';
    private static final char HORIZONTAL_LINE = '│';
    private static final String DOUBLE_DIVIDER = &quot;───────────────────────────────────------&quot;;
    private static final String TOP_BORDER = TOP_LEFT_CORNER + DOUBLE_DIVIDER + DOUBLE_DIVIDER;
    private static final String BOTTOM_BORDER = BOTTOM_LEFT_CORNER + DOUBLE_DIVIDER + DOUBLE_DIVIDER;

    private static final String CLASS_NAME_FORMAT = &quot;%s The class's name: %s&quot;;
    private static final String METHOD_NAME_FORMAT = &quot;%s The method's name: %s&quot;;
    private static final String ARGUMENT_FORMAT = &quot;%s The arguments: &quot;;
    private static final String RESULT_FORMAT = &quot;%s The result: &quot;;
    private static final String COST_TIME_FORMAT = &quot;%s The cost time: %dms&quot;;

    public static void printMethodInfo(MethodInfo methodInfo) {
        Log.i(String.valueOf(0) + TAG, TOP_BORDER);
        Log.i(String.valueOf(1) + TAG, String.format(CLASS_NAME_FORMAT, HORIZONTAL_LINE, methodInfo.getClassName()));
        Log.i(String.valueOf(2) + TAG, String.format(METHOD_NAME_FORMAT, HORIZONTAL_LINE, methodInfo.getMethodName()));
        Log.i(String.valueOf(3) + TAG, String.format(ARGUMENT_FORMAT, HORIZONTAL_LINE) + methodInfo.getArgumentList());
        Log.i(String.valueOf(4) + TAG, String.format(RESULT_FORMAT, HORIZONTAL_LINE) + methodInfo.getResult());
        Log.i(String.valueOf(5) + TAG, String.format(Locale.CHINA, COST_TIME_FORMAT, HORIZONTAL_LINE, methodInfo.getCost()));
        Log.i(String.valueOf(6) + TAG, BOTTOM_BORDER);
    }
}
</code></pre>
<p><strong>最后是注解的定义：</strong></p>
<pre class="line-numbers"><code class="language-java">@Target(ElementType.METHOD)
public @interface TraceLog {
}
</code></pre>
<h3><a id="%E4%B8%BBmodule" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>主Module</h3>
<p>主Module是使用方，使用方式：</p>
<p>(1)项目工程的gradle.build添加gradle编译脚本依赖：</p>
<pre class="line-numbers"><code class="language-java">buildscript {
    repositories {
        maven {
            url uri('D:/repository')
        }
    }
    dependencies {
        classpath 'com.example.watson.plugin:tracePlugin:1.0.0'
    }
}
</code></pre>
<p>这里我使用的仓库是本地文件夹，以后可以上传服务器，做到远程依赖</p>
<p>(2)在需要使用的 module 中的 build.gradle 中应用插件：</p>
<pre class="line-numbers"><code class="language-plain_text">apply plugin: com.example.watson.plugin.TracePlugin
</code></pre>
<p>同时添加第三方库依赖，这里同样使用的仓库是本地文件夹，以后可以上传服务器，做到远程依赖</p>
<pre class="line-numbers"><code class="language-java">repositories {
    maven {
        url uri('D:/repository')
    }
}
...
implementation 'com.example.watson.library:traceLibrary:1.0.0'
</code></pre>
<p>(3)添加注解<br />
在需要被hook的方法上添加@TraceLog注解</p>
<pre class="line-numbers"><code class="language-java">public class MainActivity extends AppCompatActivity {
    private static final String TAG = &quot;MainActivity&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                printPerson(new Person(66, &quot;watson&quot;), 100, true, (byte) 0, 'W');
            }
        });

    }

    @TraceLog
    private Person printPerson(Person person, int x, boolean flag, byte time, char temp) {
        Log.i(TAG, &quot;flag is &quot; + flag);
        Log.i(TAG, &quot;time is &quot; + time);
        Log.i(TAG, &quot;temp is &quot; + temp);
        person.setName(&quot;jack&quot;);
        person.setAge(x);
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return person;
    }
}
</code></pre>
<p>在编译后，我们可以找到被织入代码后的类文件方法：</p>
<p><strong>D:\project\plugin-master\app\build\intermediates\transforms\TraceLog\debug\28\com\example\watson\MainActivity.class</strong></p>
<pre class="line-numbers"><code class="language-java">@TraceLog
private Person printPerson(Person person, int x, boolean flag, byte time, char temp) {
    int var6 = MethodCache.request();
    MethodCache.addMethodArgument(person, var6);
    MethodCache.addMethodArgument(new Integer(x), var6);
    MethodCache.addMethodArgument(new Boolean(flag), var6);
    MethodCache.addMethodArgument(new Byte(time), var6);
    MethodCache.addMethodArgument(new Character(temp), var6);
    long var7 = System.currentTimeMillis();
    Log.i(&quot;MainActivity&quot;, &quot;flag is &quot; + flag);
    Log.i(&quot;MainActivity&quot;, &quot;time is &quot; + time);
    Log.i(&quot;MainActivity&quot;, &quot;temp is &quot; + temp);
    person.setName(&quot;jack&quot;);
    person.setAge(x);

    try {
        Thread.sleep(1000L);
    } catch (Exception var10) {
        var10.printStackTrace();
    }

    MethodCache.updateMethodInfo(person, &quot;com/example/watson/MainActivity&quot;, &quot;printPerson&quot;, &quot;(Lcom/example/watson/Person;IZBC)Lcom/example/watson/Person;&quot;, var7, var6);
    MethodCache.printMethodInfo(var6);
    return person;
}
</code></pre>
<p>点击按钮，测试结果：</p>
<p><figure><img src="media/16299642191691/16300464158614.jpg" alt="" /></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/08/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Gradle.html'>Gradle</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16214967125594.html">
                
                  <h1>OpenGL ES for Android 相机预览适配不同分辨率的手机</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>上一篇讲到OpenGL ES for Android 相机预览，相机的预览分辨率设置为1280*720，大家有没有想过如果将GLSurfaceView设置为正方形会如何？很明显画面会被拉伸导致变形，在想一下如果设置GLSurfaceView为全屏，但目前市场上的手机有很多种不同的分辨率，尤其是全面屏、折叠屏屏，这些手机并不是常见的16:9的手机，因此我们需要适配这些不同分辨率的手机。</p>
<p>有的同学可能可能会想根据不同分辨率的手机而设置不同的预览尺寸，是否可以呢？答案是 NO，因为camera的预览尺寸是需要硬件支持的，比如：camera支持640<em>480、1280</em>720，我们只能设置支持的分辨率，在项目中可以通过如下方式获取camera支持的预览尺寸：</p>
<pre class="line-numbers"><code class="language-kotlin">val mCamera = Camera.open(i)                
val parameters = mCamera.parameters
val supportSizeList = parameters.supportedPreviewSizes
</code></pre>
<p>既然相机的预览尺寸无法随便设置，那如何适配不同分辨率的手机呢？不知道大家对OpenGL ES for Android 视频缩放、旋转、平移是否还有印象，这篇文章中是视频对不同分辨率的适配，视频适配的效果和本文中相机适配的效果有一些不同，视频适配的最终效果是视频画面显示完全，保证不拉伸的前提下会出现黑色区域，而相机的适配最终的效果是保证不拉伸而且不能出现黑色区域，因此我们需要裁剪纹理（相机画面）来实现适配。</p>
<p>假设相机预览尺寸是比率3/4（640*480），渲染窗口比率是9/16，正常不拉伸的效果如下：</p>
<p><figure><img src="media/16214967125594/16214967654274.jpg" alt="w400" /><figcaption>w400<figcaption></figure></p>
<p>底下的浅红色表示渲染窗口，上面的浅蓝色表示相机预览画面，想要达到画面不拉伸而且铺满渲染窗口需要放大相机预览画面，放大到如下效果：</p>
<p><figure><img src="media/16214967125594/16214967887635.jpg" alt="w400" /><figcaption>w400<figcaption></figure></p>
<p>将纹理等比放大，如上图所示。因此我们只需要裁剪浅红色区域的纹理并显示就达到了适配的目的。</p>
<p>原理搞清楚了，接下来在OpenGL ES for Android 相机预览的基础上进行修改，顶点shader修改如下：</p>
<pre class="line-numbers"><code class="language-plain_text">attribute vec4 a_Position;
attribute vec4 a_TexCoordinate;
uniform mat4 mMatrix;
uniform mat4 mTextureMatrix;
varying vec4 v_TexCoord;
void main() {
    v_TexCoord = mTextureMatrix * a_TexCoordinate;
    gl_Position = mMatrix * a_Position;
}
</code></pre>
<p>增加mTextureMatrix纹理矩阵，mTextureMatrix作用在纹理坐标上。</p>
<p>片段shader修改如下：</p>
<pre class="line-numbers"><code class="language-plain_text">#extension GL_OES_EGL_image_external : require
precision mediump float;
uniform samplerExternalOES u_Texture;
varying vec4 v_TexCoord;
void main() {
    gl_FragColor = texture2D(u_Texture, v_TexCoord.xy);
}
</code></pre>
<p>v_TexCoord类型由vec2变为vec4，采样的时候使用v_TexCoord.xy。</p>
<p>获取mTextureMatrix纹理矩阵参数句柄，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">override fun onSurfaceCreated(p0: GL10?, p1: EGLConfig?) {
  ...
  mTextureMatrixLoc = GLES20.glGetUniformLocation(mProgramHandle, &quot;mTextureMatrix&quot;)
  ...
}
</code></pre>
<p>通过矩阵裁剪纹理，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">var mTextureMatrix = FloatArray(16)
private var screenWidth = 0
private var screenHeight = 0
private var cameraWidth = 640
private var cameraHeight = 480

override fun onSurfaceChanged(p0: GL10?, width: Int, height: Int) {
    ...
    screenWidth = width
    screenHeight = height
            
    computeTextureMatrix()
}

private fun computeTextureMatrix() {
    val cameraRatio = cameraWidth / cameraHeight.toFloat()
    val screenRatio = screenWidth / screenHeight.toFloat()
    Matrix.setIdentityM(mTextureMatrix, 0)
    if (cameraRatio &gt; screenRatio) {
        Matrix.scaleM(mTextureMatrix, 0, 1F, 1 - ((cameraRatio - screenRatio) / 2), 1F)
    } else if (cameraRatio &lt; screenRatio) {
        Matrix.scaleM(mTextureMatrix, 0, 1 - ((screenRatio - cameraRatio) / 2), 1F, 1F)
    }
}

//绘制时设置mTextureMatrix纹理矩阵数据：

override fun onDrawFrame(p0: GL10?) {
    ...
    GLES20.glUniformMatrix4fv(mTextureMatrixLoc, 1, false, mTextureMatrix, 0)
    ...
}
</code></pre>
<p>效果如下：<br />
<figure><img src="media/16214967125594/16214969723943.jpg" alt="" /></figure></p>
<p>在不同分辨率的手机上不会出现拉伸的问题。</p>
<blockquote>
<p>注意：我们手里面可能没有各种不同分辨率的手机，可以通过改变GLSurfaceView的大小来达到验证的目的</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/05/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16214961521467.html">
                
                  <h1>OpenGL ES for Android 相机预览</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E6%9D%83%E9%99%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>权限</h2>
<p>Android上打开摄像头需要camera权限，在Android 6.0及以上的版本需要动态申请权限，在<code>AndroidManifest.xml</code>中添加camera权限：</p>
<pre class="line-numbers"><code class="language-plain_text">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.arvr.sample&quot;&gt;
    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;
    &lt;application&gt;
    ...
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>
<p>动态申请camera权限代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">class CameraActivity : AppCompatActivity(), SurfaceTexture.OnFrameAvailableListener {
    private lateinit var mRenderer: MyRenderer
    override fun onFrameAvailable(surfaceTexture: SurfaceTexture?) {
        glSurfaceView.queueEvent {
            surfaceTexture?.updateTexImage()
            glSurfaceView.requestRender()
        }
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.surface)
        glSurfaceView.setEGLContextClientVersion(2)
        mRenderer = MyRenderer(context = baseContext, listener = this)
        glSurfaceView.setRenderer(mRenderer)
        glSurfaceView.renderMode = GLSurfaceView.RENDERMODE_WHEN_DIRTY
        if (ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.CAMERA
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            //没有权限
            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.CAMERA), 100)
        } else {
            mRenderer.cameraPermission = true
            mRenderer.startCamera()
        }
    }
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array&lt;out String&gt;,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == 100 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            mRenderer.cameraPermission = true
            mRenderer.startCamera()
        }
    }
    override fun onResume() {
        super.onResume()
        glSurfaceView.onResume()
    }
    override fun onPause() {
        super.onPause()
        glSurfaceView.onPause()
    }
}
</code></pre>
<p>在onCreate中先判断是否有camera权限，如果没有则申请权限权限 ， 如果有则打开camera。弹出权限申请对话框，用户点击是否允许，不管是同意还是拒绝都会回调onRequestPermissionsResult方法，用户点击同意后打开camera，和已经有权限的操作是一样的。</p>
<h2><a id="%E5%88%9B%E5%BB%BAprogram%E5%B9%B6%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%8F%A5%E6%9F%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建program并获取参数句柄</h2>
<p>顶点shader代码如下：</p>
<pre class="line-numbers"><code class="language-plain_text">attribute vec4 a_Position;
attribute vec2 a_TexCoordinate;
varying vec2 v_TexCoord;
void main() {
    v_TexCoord = a_TexCoordinate;
    gl_Position = a_Position;
}
</code></pre>
<p>片段shader代码如下：</p>
<pre class="line-numbers"><code class="language-plain_text">#extension GL_OES_EGL_image_external : require
precision mediump float;
uniform samplerExternalOES u_Texture;
varying vec2 v_TexCoord;
void main() {
    gl_FragColor = texture2D(u_Texture, v_TexCoord);
}
</code></pre>
<p>注意：顶点和片段shader是单独的文件，分别是camera_vs.glsl和camera_fs.glsl，存放于assets/glsl目录下。</p>
<p>在onSurfaceCreated回调中创建program并获取参数句柄，创建纹理，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">override fun onSurfaceCreated(p0: GL10?, p1: EGLConfig?) {
    createProgram()
    //获取vPosition索引
    vPositionLoc = GLES20.glGetAttribLocation(mProgramHandle, &quot;a_Position&quot;)
    texCoordLoc = GLES20.glGetAttribLocation(mProgramHandle, &quot;a_TexCoordinate&quot;)
    textureLoc = GLES20.glGetUniformLocation(mProgramHandle, &quot;u_Texture&quot;)
    textureId = GLTools.createOESTextureId()
    surfaceTexture = SurfaceTexture(textureId)
    surfaceTexture?.setOnFrameAvailableListener(listener)
}

private fun createProgram() {
    var vertexCode =
        AssetsUtils.readAssetsTxt(
            context = context,
            filePath = &quot;glsl/camera_vs.glsl&quot;
        )
    var fragmentCode =
        AssetsUtils.readAssetsTxt(
            context = context,
            filePath = &quot;glsl/camera_fs.glsl&quot;
        )
    mProgramHandle = GLTools.createAndLinkProgram(vertexCode, fragmentCode)
}

fun createOESTextureId(): Int {
    val textures = IntArray(1)
    GLES20.glGenTextures(1, textures, 0)
    glCheck(&quot;texture generate&quot;)
    GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textures[0])
    glCheck(&quot;texture bind&quot;)
    GLES20.glTexParameterf(
        GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
        GLES20.GL_TEXTURE_MIN_FILTER,
        GLES20.GL_LINEAR.toFloat()
    )
    GLES20.glTexParameterf(
        GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
        GLES20.GL_TEXTURE_MAG_FILTER,
        GLES20.GL_LINEAR.toFloat()
    )
    GLES20.glTexParameteri(
        GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
        GLES20.GL_TEXTURE_WRAP_S,
        GLES20.GL_CLAMP_TO_EDGE
    )
    GLES20.glTexParameteri(
        GLES11Ext.GL_TEXTURE_EXTERNAL_OES,
        GLES20.GL_TEXTURE_WRAP_T,
        GLES20.GL_CLAMP_TO_EDGE
    )
    return textures[0]
}
</code></pre>
<p>GLTools 为工具类，createOESTextureId方法是其中一个方法，创建一个OES纹理，OES纹理用于渲染相机、视频。</p>
<p>创建纹理id并创建SurfaceTexture，SurfaceTexture在打开相机方法中用到，用于预览相机。setOnFrameAvailableListener的回调是从Activity中传入，真正的实现在Activity中，</p>
<pre class="line-numbers"><code class="language-kotlin">class CameraActivity : AppCompatActivity(), SurfaceTexture.OnFrameAvailableListener {
    private lateinit var mRenderer: MyRenderer
    override fun onFrameAvailable(surfaceTexture: SurfaceTexture?) {
        glSurfaceView.queueEvent {
            surfaceTexture?.updateTexImage()
            glSurfaceView.requestRender()
        }
    }
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        mRenderer = MyRenderer(context = baseContext, listener = this)
    ...
  }
  ...
}
</code></pre>
<p>当有新的一帧数据时会回调此方法，更新数据并调用<code>glSurfaceView.requestRender()</code> 重新绘制，也就是重新调用Renderer的<code>onDrawFrame</code>方法。</p>
<h2><a id="%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%9D%90%E6%A0%87%E3%80%81%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87%E3%80%81%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置顶点坐标、纹理坐标、索引数据</h2>
<p>设置顶点坐标，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">var vertexBuffer = GLTools.array2Buffer(
            floatArrayOf(
                -1.0f, 1.0f, 0.0f,  // top left
                -1.0f, -1.0f, 0.0f,  // bottom left
                1.0f, -1.0f, 0.0f,  // bottom right
                1.0f, 1.0f, 0.0f  // top right
            )
        )
</code></pre>
<p>设置纹理坐标，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">var texBuffer = GLTools.array2Buffer(
            floatArrayOf(
                0.0f, 0.0f,
                0.0f, 1.0f,
                1.0f, 1.0f,
                1.0f, 0.0f
            )
        )
</code></pre>
<p>设置索引数据，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">var index = shortArrayOf(3, 2, 0, 0, 1, 2)
val indexBuffer = GLTools.array2Buffer(index)
</code></pre>
<h2><a id="%E7%BB%98%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>绘制</h2>
<pre class="line-numbers"><code class="language-kotlin">override fun onDrawFrame(p0: GL10?) {
    GLES20.glUseProgram(mProgramHandle)
    //设置顶点数据
    vertexBuffer.position(0)
    GLES20.glEnableVertexAttribArray(vPositionLoc)
    GLES20.glVertexAttribPointer(vPositionLoc, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer)
    //设置纹理顶点数据
    texBuffer.position(0)
    GLES20.glEnableVertexAttribArray(texCoordLoc)
    GLES20.glVertexAttribPointer(texCoordLoc, 2, GLES20.GL_FLOAT, false, 0, texBuffer)
    //设置纹理
    GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId)
    GLES20.glUniform1i(textureLoc, 0)
    GLES20.glDrawElements(
        GLES20.GL_TRIANGLES,
        index.size,
        GLES20.GL_UNSIGNED_SHORT,
        indexBuffer
    )
}
</code></pre>
<h2><a id="%E6%89%93%E5%BC%80%E7%9B%B8%E6%9C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打开相机</h2>
<p>打开相机有2个条件：相机权限和SurfaceTexture已经创建完成。相机权限申请的回调和Renderer中<code>onSurfaceCreated</code>（创建SurfaceTexture的方法）方法是异步的，也就是说无法知道这2个方法回调的前后顺序，因此需要保存相机权限状态cameraPermission和SurfaceTexture变量,在这2个回调中都调用打开相机方法，在打开相机方法中判断相机权限和SurfaceTexture是否都已经准备完成，是则打开，不是则返回，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">override fun onSurfaceCreated(p0: GL10?, p1: EGLConfig?) {
    ...
    startCamera()
}

fun startCamera() {
    if (!cameraPermission || surfaceTexture == null) {
        return
    }
    val cameraInfo = Camera.CameraInfo()
    val cameraCount = Camera.getNumberOfCameras()
    for (i in 0 until cameraCount) {
        Camera.getCameraInfo(i, cameraInfo)
        if (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
            val mCamera = Camera.open(i)
            mCamera.setPreviewTexture(surfaceTexture)
            //设置分辨率
            val parameters = mCamera.parameters
            parameters.setPreviewSize(1280, 720)
            mCamera.parameters = parameters
            //开始预览
            mCamera.startPreview()
            return
        }
    }
}
</code></pre>
<p>运行效果如下：<br />
<figure><img src="media/16214961521467/16214965387283.jpg" alt="" style="width:400px;" /></figure></p>
<p>运行后发现相机的画面是倒的，这是因为camera本身输出的预览流就是倒的，下面通过矩阵旋转解决此问题，顶点shader修改如下：</p>
<pre class="line-numbers"><code class="language-plain_text">attribute vec4 a_Position;
attribute vec2 a_TexCoordinate;
uniform mat4 mMatrix;
varying vec2 v_TexCoord;
void main() {
    v_TexCoord = a_TexCoordinate;
    gl_Position = mMatrix * a_Position;
}
</code></pre>
<p>增加了mMatrix矩阵。<br />
获取矩阵参数句柄，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">override fun onSurfaceCreated(p0: GL10?, p1: EGLConfig?) {
    createProgram()
    ...
    matrixLoc = GLES20.glGetUniformLocation(mProgramHandle, &quot;mMatrix&quot;)
    ...
}
</code></pre>
<p>旋转90度，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">var mMatrix = FloatArray(16)
override fun onSurfaceChanged(p0: GL10?, width: Int, height: Int) {
    GLES20.glViewport(0, 0, width, height)
    Matrix.setIdentityM(mMatrix, 0)
    Matrix.rotateM(mMatrix,0,90F,0F,0F,1F)
}
</code></pre>
<p>设置矩阵参数，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">override fun onDrawFrame(p0: GL10?) {
    ...
   GLES20.glUniformMatrix4fv(matrixLoc, 1, false, mMatrix, 0)
   ...
}
</code></pre>
<p>运行后发现画面调整正了，但左右镜像，这个时候需要画面绕y轴旋转180度，这样就解决了左右镜像问题，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">override fun onSurfaceChanged(p0: GL10?, width: Int, height: Int) {
    GLES20.glViewport(0, 0, width, height)
    Matrix.setIdentityM(mMatrix, 0)
    Matrix.rotateM(mMatrix,0,180F,0F,1F,0F)
    Matrix.rotateM(mMatrix,0,90F,0F,0F,1F)
}
</code></pre>
<p>注意，对预览流的操作是先绕z轴旋转90度，使画面调正，然后再绕y轴旋转180度，但写代码的时候要绕y轴旋转180度写在前面。</p>
<p>最终效果如下：</p>
<p><figure><img src="media/16214961521467/16214966889467.jpg" alt="w400" /><figcaption>w400<figcaption></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/05/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="16214955019940.html">
                
                  <h1>OpenGL ES for Android 视频缩放、旋转、平移</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在上一篇文章中我们介绍了<a href="16214944723657.html">为什么要使用OpenGL ES播放视频</a>，在末尾提到如果渲染视频的窗口宽高比和视频宽高比不一致会导致视频拉伸，这篇文章将会介绍如何通过视频的缩放来解决这个问题。</p>
<p>我们希望当视频的比例和窗口的比例不一样时，其中一边占满全屏，另一边等比缩放并居中，其余部分显示黑色，这个效果和我们平时使用的视频播放器的效果是一样的，效果如图：</p>
<p><figure><img src="media/16214955019940/16214955737188.jpg" alt="" /></figure></p>
<p>我们在之前的基础上进行修改，修改顶点shader</p>
<pre class="line-numbers"><code class="language-plain_text">attribute vec4 a_Position;
attribute vec2 a_TexCoordinate;
varying vec2 v_TexCoord;
uniform mat4 mvpMatrix;
void main() {
    v_TexCoord = a_TexCoordinate;
    gl_Position = mvpMatrix*a_Position;
}
</code></pre>
<p>在顶点shader中加入mvpMatrix（MVP矩阵）并与a_Position相乘。</p>
<h2><a id="%E8%8E%B7%E5%8F%96mvpmatrix%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取mvpMatrix索引</h2>
<pre class="line-numbers"><code class="language-kotlin">override fun onSurfaceCreated(p0: GL10?, p1: EGLConfig?) {
            GLES20.glClearColor(0F, 0F, 0F, 1F)
      ...
            mvpMatrixLoc = GLES20.glGetUniformLocation(mProgramHandle, &quot;mvpMatrix&quot;)
      ...
}
</code></pre>
<h2><a id="%E8%8E%B7%E5%8F%96%E8%A7%86%E9%A2%91%E5%8F%8A%E6%B8%B2%E6%9F%93%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AE%BD%E9%AB%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>获取视频及渲染窗口的宽高</h2>
<pre class="line-numbers"><code class="language-kotlin">override fun onSurfaceChanged(p0: GL10?, width: Int, height: Int) {
    GLES20.glViewport(0, 0, width, height)
    screenWidth = width
    screenHeight = height
    if (videoWidth &gt; 0 &amp;&amp; videoHeight &gt; 0) {
        computeMatrix()
    }
}
mediaPlayer.setOnVideoSizeChangedListener { mp, width, height -&gt;
    run {
        videoWidth = width
        videoHeight = height
        if (screenWidth &gt; 0 &amp;&amp; screenHeight &gt; 0) {
            computeMatrix()
        }
    }
}
</code></pre>
<p>渲染窗口的宽高在onSurfaceChanged中获取，视频的宽高需要给meidaplay添加OnVideoSizeChangedListener回调，由于视频的播放是在onSurfaceCreated中调用且这2个回调都是异步的，因此无法判断先后顺序，因此在这2个回调中都增加判断，只有当视频和渲染窗口的宽高都获取到才计算MVP矩阵，或者我们也可以在onSurfaceChanged中调用视频播放，这样就可以只在OnVideoSizeChangedListener回调中计算矩阵。</p>
<h2><a id="%E8%AE%A1%E7%AE%97%E7%9F%A9%E9%98%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算矩阵</h2>
<p>假设视频的宽高比小于屏幕的宽高比，那么视频则在高度上铺满窗口，在宽度上进行缩放，为了不拉伸视频，缩放的系数为<code>1 - ((屏幕的宽高比 - 视频的宽高比) / 2)</code>,反之如果视频的宽高比大于屏幕的宽高比，视频在高度上的缩放的系数为<code>1 - ((视频的宽高比 - 屏幕的宽高比 ) / 2)</code>，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">var modelMatrix = FloatArray(16)
fun computeMatrix() {
    val videoRatio = videoWidth / videoHeight.toFloat()
    val screenRatio = screenWidth / screenHeight.toFloat()
    Matrix.setIdentityM(modelMatrix, 0)
    if (videoRatio &gt; screenRatio) {
        Matrix.scaleM(modelMatrix, 0, 1F, 1 - ((videoRatio - screenRatio) / 2), 1F)
    } else if (videoRatio &lt; screenRatio) {
        Matrix.scaleM(modelMatrix, 0, 1 - ((screenRatio - videoRatio) / 2), 1F, 1F)
    }
}
</code></pre>
<h2><a id="%E7%BB%98%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>绘制</h2>
<p>在绘制的时候设置modelMatrix矩阵，代码如下：</p>
<pre class="line-numbers"><code class="language-kotlin">override fun onDrawFrame(p0: GL10?) {
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT or GLES20.GL_DEPTH_BUFFER_BIT)
    GLES20.glUseProgram(mProgramHandle)
    //设置顶点数据
    vertexBuffer.position(0)
    GLES20.glEnableVertexAttribArray(vPositionLoc)
    GLES20.glVertexAttribPointer(vPositionLoc, 3, GLES20.GL_FLOAT, false, 0, vertexBuffer)
    //设置纹理顶点数据
    texBuffer.position(0)
    GLES20.glEnableVertexAttribArray(texCoordLoc)
    GLES20.glVertexAttribPointer(texCoordLoc, 2, GLES20.GL_FLOAT, false, 0, texBuffer)
    //设置纹理
    GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId)
    GLES20.glUniform1i(textureLoc, 0)
    //设置mvp矩阵
    GLES20.glUniformMatrix4fv(mvpMatrixLoc, 1, false, modelMatrix, 0)
    GLES20.glDrawElements(
        GLES20.GL_TRIANGLES,
        index.size,
        GLES20.GL_UNSIGNED_SHORT,
        indexBuffer
    )
}
</code></pre>
<p>GLES20.glUniformMatrix4fv(mvpMatrixLoc, 1, false, modelMatrix, 0)为矩阵数据设置，其他已经在OpenGL ES 播放视频中介绍，这里不在介绍。</p>
<p>到这里我们介绍完了视频的缩放功能，想一想如果在欢迎界面播放视频，我们希望视频充满屏幕，而不是出现黑屏，但市场上的手机屏幕比例各种各样，尤其是全面屏、折叠屏的出现，有16:9的、2:1的，还有16:10的，那么如何使用同一个视频去适配所有的屏幕呢？其实一样可以通过视频缩放而解决，只不过一个缩放视频，一个是放大视频。</p>
<p>视频的旋转、平移和缩放是一样的，我们只需要对矩阵进行相应的操作，比如将视频旋转45度，代码如下：</p>
<pre class="line-numbers"><code class="language-plain_text">Matrix.rotateM(modelMatrix,0,45F,0F,0F,1F)
</code></pre>
<p>效果如下：<br />
<figure><img src="media/16214955019940/16214961236820.jpg" alt="" style="width:400px;" /></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2021/05/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_2.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_4.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/17043409056338/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/adolphJane" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:adolphdeveloper@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
