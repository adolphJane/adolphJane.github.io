<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15626502769714.html">
                
                  <h1>Android-事件分发机制详解：史上最全面、最易懂</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<ul>
<li>Android事件分发机制是Android开发者必须了解的基础</li>
<li>网上有大量关于Android事件分发机制的文章，但存在一些问题：内容不全、思路不清晰、无源码分析、简单问题复杂化等等</li>
<li>今天，我将全面总结Android的事件分发机制，我能保证这是市面上的最全面、最清晰、最易懂的</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15626502769714.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502769765.html">
                
                  <h1>Kotlin学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>Kotlin语言从问世到现在已经有很久的时间了，2017年终于Google将Kotlin列为开发Android应用的一级语言。而且Kotlin和Java具有高度可互操作性，并且相较于Java更加简单，精炼，还添加了Java在Android中尚不支持的一些必备功能。学习Kotlin与时俱进是必须的。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15626502769765.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502770577.html">
                
                  <h1>Android-RecyclerView详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="recyclerview" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView</h2>
<h3><a id="recyclerview%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView是什么？</h3>
<p>RecylerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字recylerview即回收view也可以看出。看到这也许有人会问，不是已经有ListView了吗，为什么还要RecylerView呢？这就牵扯到第二个问题了。</p>
<h3><a id="recyclerview%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView的优点是什么？</h3>
<p>根据官方的介绍RecylerView是ListView的升级版，既然如此那RecylerView必然有它的优点，现就RecylerView相对于ListView的优点罗列如下：</p>
<ul>
<li>RecylerView封装了viewholder的回收复用，也就是说RecylerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的   逻辑被封装了，写起来更加简单。</li>
<li>提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecylerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还有StaggeredGridLayoutManager等)，也就是说RecylerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。你想控制Item的分隔线，可以通过继承RecylerView的ItemDecoration这个类，然后针对自己的业务需求去抒写代码。</li>
<li>可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecylerView有其自己默认的实现。</li>
</ul>
<h3><a id="recyclerview%E7%9A%84%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView的用法</h3>
<h4><a id="recyclerview%E7%9A%84%E5%88%9D%E6%AD%A5%E7%94%A8%E6%B3%95%E5%8C%85%E6%8B%AC-recyclerview-adapter%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView的初步用法(包括RecyclerView.Adapter用法)</h4>
<pre class="line-numbers"><code class="language-java">recyclerView = (RecyclerView) findViewById(R.id.recyclerView);  
LinearLayoutManager layoutManager = new LinearLayoutManager(this );  
//设置布局管理器  
recyclerView.setLayoutManager(layoutManager);  
//设置为垂直布局，这也是默认的  
layoutManager.setOrientation(OrientationHelper. VERTICAL);  
//设置Adapter  
recyclerView.setAdapter( recycleAdapter);  
//设置分隔线  
recyclerView.addItemDecoration( new DividerGridItemDecoration(this ));  
//设置增加或删除条目的动画  
recyclerView.setItemAnimator( new DefaultItemAnimator());
</code></pre>
<p>可以看到对RecylerView的设置过程，比ListView要复杂一些，这也是RecylerView高度解耦的表现，虽然代码抒写上有点复杂，但它的扩展性是极高的。</p>
<h3><a id="recyclerview%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView的生命周期</h3>
<p>一个RecyclerView的Item加载是有顺序的，类似于Activity的生命周期（姑且这么叫把），具体可以对adapter的每个方法进行重写打下日志进行查看，具体大致为：</p>
<ul>
<li>getItemViewType(获取显示类型，返回值可在onCreateViewHolder中拿到，以决定加载哪种ViewHolder)</li>
<li>onCreateViewHolder(加载ViewHolder的布局)</li>
<li>onViewAttachedToWindow（当Item进入这个页面的时候调用）</li>
<li>onBindViewHolder(将数据绑定到布局上，以及一些逻辑的控制就写这啦)</li>
<li>onViewDetachedFromWindow（当Item离开这个页面的时候调用）</li>
<li>onViewRecycled(当Item被回收的时候调用)<br />
tips1:如果你调用了：</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">viewHolder.setIsRecyclable(false);
</code></pre>
<p>那么这个Item的onViewRecycled将永远不会调用。<br />
tips2:如果你的界面出现了错乱的现象，请调用如上代码可能能简单粗暴的解决，当然代价是损失少许的性能表现了。</p>
<h2><a id="recyclerview-adapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView.Adapter</h2>
<p>来看看它的Adapter的写法，RecyclerView的Adapter与ListView的Adapter还是有点区别的，RecyclerView.Adapter，需要实现3个方法：</p>
<ul>
<li>
<p><code>onCreateViewHolder()</code>这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。直接省去了当初的convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。</p>
</li>
<li>
<p><code>onBindViewHolder()</code>这个方法主要用于适配渲染数据到View中。方法提供给你了一个viewHolder，而不是原来的convertView。</p>
</li>
<li>
<p><code>getItemCount()</code>这个方法就类似于BaseAdapter的getCount方法了，即总共有多少个条目。</p>
</li>
<li>
<p><code>notifyDataSetChanged()</code>刷新所有,notifyDataSetChanged最终会使adapter的数据重新绑定，即会重新调用adapter里的onBindViewHolder方法，从而使item的position得到了更新。</p>
</li>
<li>
<p><code>notifyItemChanged(int position)</code>position数据发生了改变，那调用这个方法，就会回调对应position的onBindViewHolder()方法了</p>
</li>
<li>
<p><code>notifyItemRangeChanged(int positionStart, int itemCount)</code>刷新从positionStart开始itemCount数量的item了（这里的刷新指回调onBindViewHolder()方法）</p>
</li>
<li>
<p><code>notifyItemInserted(int position)</code>在第position位置被插入了一条数据的时候可以使用这个方法刷新，注意这个方法调用后会有插入的动画，这个动画可以使用默认的，也可以自己定义</p>
</li>
<li>
<p><code>notifyItemMoved(int fromPosition, int toPosition)</code>从fromPosition移动到toPosition为止的时候可以使用这个方法刷新</p>
</li>
<li>
<p><code>notifyItemRangeInserted(int positionStart, int itemCount)</code>批量添加</p>
</li>
<li>
<p><code>notifyItemRemoved(int position)</code>第position个被删除的时候刷新，同样会有动画</p>
</li>
<li>
<p><code>notifyItemRangeRemoved(int positionStart, int itemCount)</code>批量删除</p>
</li>
<li>
<p><code>onAttachedToRecyclerView (RecyclerView recyclerView)</code>在<code>RecyclerView.setAdapter(adapter)</code>时进行调用</p>
</li>
<li>
<p><code>onViewAttachedToWindow(VH holder)</code>当Item进入这个页面的时候调用</p>
</li>
<li>
<p><code>onViewDetachedFromWindow(VH holder)</code>当Item离开这个页面的时候调用</p>
</li>
<li>
<p><code>onViewRecycled(VH holder)</code>当Item被回收的时候调用</p>
</li>
</ul>
<h2><a id="recyclerview-itemdecoration" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView.ItemDecoration</h2>
<blockquote>
<p>An ItemDecoration allows the application to add a special drawing and layout offset to specific item views from the adapter's data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and more.</p>
</blockquote>
<blockquote>
<p>ItemDecoration允许应用结合adapter的数据集，对特定的item添加绘制一个周边图案。可以用于给items之间添加分割线、高亮装饰效果或者分组边界等等。</p>
</blockquote>
<p>从谷歌官方的介绍可以知道，ItemDecoration是用于给列表的item添加各种装饰效果，开发中最常见的就是为item添加分割线。<br />
ItemDecoration本身是一个抽象类，抛去废弃的方法，我们需要关心的方法只有三个：</p>
<pre class="line-numbers"><code class="language-java">public static abstract class ItemDecoration {
    public void onDraw(Canvas c, RecyclerView parent, State state) {
        onDraw(c, parent);
    }
    public void onDrawOver(Canvas c, RecyclerView parent, State state) {
        onDrawOver(c, parent);
    }
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) {
        getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),parent);
    }
}
</code></pre>
<p>从源码注释中，可以大概了解这三个方法的用途：</p>
<ul>
<li><code>onDraw</code>：在item绘制之前时被调用，将指定的内容绘制到item view内容之下；</li>
<li><code>onDrawOver</code>：在item被绘制之后调用，将指定的内容绘制到item view内容之上</li>
<li><code>getItemOffsets</code>：在每次测量item尺寸时被调用，将decoration的尺寸计算到item的尺寸中</li>
</ul>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799957749046.png" alt="20171015150799957749046.png" /><figcaption>20171015150799957749046.png<figcaption></figure></p>
<h3><a id="itemdecoration%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E6%B5%8B%E8%AF%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ItemDecoration三个方法的测试</h3>
<p>谷歌官方在support.v7包中提供了ItemDecoration的一个实现DividerItemDecoration，这里结合这个实现，来看看其三个需要实现的方法对UI的影响。</p>
<h4><a id="ondraw" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>onDraw</h4>
<pre class="line-numbers"><code class="language-java">private void drawVertical(Canvas canvas, RecyclerView parent) {
	canvas.save();
   final int left;
   final int right;
   if (parent.getClipToPadding()) {
		left = parent.getPaddingLeft();
		right = parent.getWidth() - parent.getPaddingRight();
		canvas.clipRect(left, parent.getPaddingTop(), right,parent.getHeight() - parent.getPaddingBottom());
   } else {
		left = 0;
		right = parent.getWidth();
	}

	final int childCount = parent.getChildCount();
	for (int i = 0; i &lt; childCount; i++) {
		final View child = parent.getChildAt(i);
		parent.getDecoratedBoundsWithMargins(child, mBounds);
		final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child));
		final int top = bottom - mDivider.getIntrinsicHeight();
		mDivider.setBounds(left, top, right, bottom);
       mDivider.draw(canvas);
	}
	canvas.restore();
}
</code></pre>
<p><code>drawVertical</code>方法实现了对<code>Orientation == VERTICAL</code>的RecyclerView绘制item之间的分割线。从传入的canvas参数可以推断，分割线的绘制是通过canvas机制绘制到屏幕上：<code>mDivider.draw(canvas)</code>;其中，mDivider是一个Drawable对象，可以通过setDrawable传入自定义对象，不传入时，会自动使用系统内置的分割线样式：<code>android.R.attr.listDivider</code>。通过遍历每一个可见的child view，计算mDivider对应的left、top、right、bottom值，从而绘制到正确的位置上。对于纵向的RecyclerView而言，mDivider的left和right是固定的，和parent的左右内容边界保持一致，也就是说，把parent的左右padding都计算进去，因而是代表了RecyclerView实际的内容区域。纵向的分割线一般位于每个item的底部，因此mDivider的top值理论上应该和child view的内容下边界保持贴合。实际上，计算top和bottom的代码，谷歌官方也有所调整，在最新的实现中，先通过<code>parent.getDecoratedBoundsWithMargins(child, mBounds)</code>;拿到之前在onMeasure过程中，通过调用<code>getItemOffsets</code>获取到的mBounds，mBounds是包括了整个child view以及其decoration的总边界，之后再计算mDivider的bottom、top值。</p>
<h4><a id="getitemoffsets" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getItemOffsets</h4>
<pre class="line-numbers"><code class="language-java">public void getItemOffsets(Rect outRect, View view, RecyclerView parent,RecyclerView.State state) {
	if (mOrientation == VERTICAL) {
		outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
	} else {
		outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
	}
}
</code></pre>
<p>官方实现的getItemOffsets比较简单，只是根据列表的方向，返回了分割线在相应方向的尺寸。这里可能有一个坑，即通过setDrawable设置自定义的分割线时，容易传入一个无尺寸的drawable对象，导致分割线无法显示出来的bug，典型的代码是这样：<br />
<code>decoration.setDrawable(new ColorDrawable(Color.RED));</code></p>
<p>DividerItemDecoration的实现中，是没有复写onDrawOver方法的，对于分割线场景而言，也确实不需要去实现它。接下来，通过几个例子，展示一下getItemOffsets对于ItemDecoration在UI上的影响。</p>
<h4><a id="getitemoffsets-ondraw" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getItemOffsets &amp; onDraw</h4>
<p>先上动图【注2】：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799983096582.gif" alt="20171015150799983096582.gif" /><figcaption>20171015150799983096582.gif<figcaption></figure></p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799985361609.gif" alt="20171015150799985361609.gif" /><figcaption>20171015150799985361609.gif<figcaption></figure></p>
<p>上图中，getItemOffsets方法里，返回outRect不同，而onDraw方法绘制的分割线高度初始值设为25，并通过外部增减来观察其UI效果。</p>
<pre class="line-numbers"><code class="language-java">public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
	outRect.set(0, 0, 0, 50);// outRect.set(50,50,50,50);
}

public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
	for (int i = 0; i &lt; childCount; i++) {
		final View view = parent.getChildAt(i);
		top = view.getBottom();
		left = view.getPaddingLeft() + mSize;
		right = view.getWidth() - view.getPaddingRight() - mSize ;
		bottom = top + mSize;
		divider.setBounds(left, top, right, bottom);
		divider.draw(c);
	}
}
</code></pre>
<p>从上面两个动图对比，可以得出以下几个结论：</p>
<ul>
<li>getItemOffsets返回的矩形outRect会被计算到child view的尺寸当中；</li>
<li>onDraw方法绘制的图形，可以超出outRect所规定的区域；</li>
<li>onDraw方法绘制的图形，确实是处于child view的底下，当两者发生重叠时，只会显示child view的内容；</li>
</ul>
<h4><a id="getitemoffsets-ondrawover" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getItemOffsets &amp; onDrawOver</h4>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171015150799996057841.gif" alt="20171015150799996057841.gif" /><figcaption>20171015150799996057841.gif<figcaption></figure></p>
<p>将之前onDraw方法内代码完整拷贝到onDrawOver下，并注释掉之前onDraw中的方法，很容易验证出onDrawOver与onDraw的唯一不同之处。</p>
<ul>
<li>onDrawOver绘制的图形，处于child view之上，当两者发生重叠时，会显示onDrawOver的内容；</li>
</ul>
<blockquote>
<p>ItemDecoration三个方法的含义，就介绍到这里。可以感觉到，三个方法都很简单而基础，可以十分优雅的实现item的分割线效果，然而简单的如DividerItemDecoration，往往是无法满足项目开发需求的。经常会遇到某几个item不想要分割线（如头部或者最后一个item），这就需要开发者自行来实现。</p>
</blockquote>
<h3><a id="%E6%B7%BB%E5%8A%A0%E5%88%86%E9%9A%94%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加分隔线</h3>
<p>我们可以创建一个继承RecyclerView.ItemDecoration类来绘制分隔线，通过ItemDecoration可以让我们每一个Item从视觉上面相互分开来，例如ListView的divider非常相似的效果。也可以不设置ItemDecoration，那说明ItemDecoration我们并不是强制需要使用，作为我们开发者可以设置或者不设置Decoration的。实现一个ItemDecoration，系统提供的ItemDecoration是一个抽象类，内部除去已经废弃的方法以外，我们主要实现以下三个方法:</p>
<pre class="line-numbers"><code class="language-java">public static abstract class ItemDecoration {   
    public void onDraw(Canvas c,RecyclerView parent,State state) {   
        onDraw(c,parent);   
    }   
    public void onDrawOver(Canvas c,RecyclerView parent,State state) {   
        onDrawOver(c,parent);   
    }   
    public void getItemOffsets(RectoutRect, View view,RecyclerView parent,State state) {   
        getItemOffsets(outRect,((LayoutParams)view.getLayoutParams()).getViewLayoutPosition(),parent);   
    }   
}
</code></pre>
<ul>
<li><code>onDraw</code>方法先于<code>drawChildren</code></li>
<li><code>onDrawOver</code>在<code>drawChildren</code>之后，一般我们选择复写其中一个即可。</li>
<li><code>getItemOffsets</code> 可以通过<code>outRect.set()</code>为每个<code>Item</code>设置一定的偏移量，主要用于绘制<code>Decorator</code>。</li>
</ul>
<p>又因为当我们RecyclerView在进行绘制的时候会进行绘制Decoration,那么会去调用onDraw和onDrawOver方法，那么这边我们其实只要去重写onDraw和getItemOffsets这两个方法就可以实现啦。然后LayoutManager会进行Item布局的时候，会去调用getItemOffset方法来计算每个Item的Decoration合适的尺寸，下面我们来具体实现一个</p>
<pre class="line-numbers"><code class="language-java">package com.example.reclerviewpractice;  
  
import android.content.Context;  
import android.content.res.TypedArray;  
import android.graphics.Canvas;  
import android.graphics.Rect;  
import android.graphics.drawable.Drawable;  
import android.support.v7.widget.LinearLayoutManager ;  
import android.support.v7.widget.RecyclerView;  
import android.view.View;  
  
public class DividerItemDecoration extends RecyclerView.ItemDecoration {  
  
    private static final int[] ATTRS = new int[]{  
        android.R.attr. listDivider  
    };  
    public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;  
    public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL;  
    private Drawable mDivider;
    private int mOrientation;  
  
    public DividerItemDecoration(Context context, int orientation) {  
        final TypedArray a = context.obtainStyledAttributes(ATTRS );  
        mDivider = a.getDrawable(0);  
        a.recycle();  
        setOrientation(orientation);  
    }  
  
    public void setOrientation( int orientation) {  
        if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) {  
            throw new IllegalArgumentException( &quot;invalid orientation&quot;);  
        }  
        mOrientation = orientation;  
    }  
  
    @Override  
    public void onDraw(Canvas c, RecyclerView parent) {  
        if (mOrientation == VERTICAL_LIST) {  
            drawVertical(c, parent);  
        } else {  
            drawHorizontal(c, parent);  
        }  
    }  
  
    public void drawVertical(Canvas c, RecyclerView parent) {  
        final int left = parent.getPaddingLeft();  
        final int right = parent.getWidth() - parent.getPaddingRight();  
        final int childCount = parent.getChildCount();  
        for (int i = 0; i &lt; childCount; i++) {  
            final View child = parent.getChildAt(i);  
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();  
            final int top = child.getBottom() + params.bottomMargin;  
            final int bottom = top + mDivider.getIntrinsicHeight();  
            mDivider.setBounds(left, top, right, bottom);  
            mDivider.draw(c);  
        }  
    }  
  
    public void drawHorizontal(Canvas c, RecyclerView parent) {  
        final int top = parent.getPaddingTop();  
        final int bottom = parent.getHeight() - parent.getPaddingBottom();  
  
        final int childCount = parent.getChildCount();  
        for (int i = 0; i &lt; childCount; i++) {  
            final View child = parent.getChildAt(i);  
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();  
            final int left = child.getRight() + params.rightMargin;  
            final int right = left + mDivider.getIntrinsicHeight();  
            mDivider.setBounds(left, top, right, bottom);  
            mDivider.draw(c);  
        }  
    }  
  
    @Override  
    public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) {  
        if (mOrientation == VERTICAL_LIST) {  
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());  
        }else{  
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);  
        }  
    }  
}
</code></pre>
<h3><a id="%E6%94%B9%E5%8F%98%E5%88%86%E9%9A%94%E7%BA%BF%E6%A0%B7%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>改变分隔线样式</h3>
<p>那么怎么更改分隔线的样式呢？在上面的DividerItemDecoration这个类中可以看到这个分隔线是跟ListView一样的，即系统的默认的样式，因此我们可以在styles的xml文件中进行更改，更改如下：</p>
<pre class="line-numbers"><code class="language-java">&lt;!-- Application theme. --&gt;  
&lt;style name =&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;  
    &lt;!-- All customizations that are NOT specific to a particular API-level can go here. --&gt;  
    &lt;item name= &quot;android:listDivider&quot;&gt;@drawable/divider &lt;/item &gt;   
&lt;/style &gt;
</code></pre>
<p>divider的内容如下：</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;  
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:shape=&quot;rectangle&quot; &gt;  
     
    &lt;!-- 填充的颜色 --&gt;  
    &lt;solid android:color =&quot;@color/color_red&quot;/&gt;  
       
    &lt;!--  线条大小 --&gt;  
    &lt;size android:height =&quot;1dp&quot; android:width =&quot;1dp&quot;/&gt;  
&lt;/shape&gt;
</code></pre>
<p>看到这肯定会有人说，这尼玛，好麻烦，还不如ListView简单呢，从上面的代码量看来确实是使用起来很复杂，但是如果此时你想将这个列表以GridView的形式展示出来，用RecylerView仅仅是换一行代码的事情.</p>
<h3><a id="%E7%AE%80%E5%8D%95%E7%9A%84%E5%B0%81%E8%A3%85mkitemdecoration" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简单的封装MKItemDecoration</h3>
<ul>
<li>支持简单颜色分割线</li>
<li>支持简单颜色分割线 + 文字：文字可以居左、居中</li>
<li>支持分割线跳过起始诺干个item，跳过最后一个item</li>
<li>支持分组悬停效果</li>
<li>支持自定义View作为Decoration</li>
</ul>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017101515080000957381.gif" alt="2017101515080000957381.gif" /><figcaption>2017101515080000957381.gif<figcaption></figure></p>
<p>上图hoverGroup.gif的使用代码如下：</p>
<pre class="line-numbers"><code class="language-java">recyclerView.addItemDecoration(new MKItemDecoration.Builder()
.height(50)
.color(Color.parseColor(&quot;#525D97&quot;))
.textSize(30)
.textColor(Color.WHITE)
.itemOffset(0)
.iHover(new IHover() {
	@Override
	public boolean isGroup(int position) {
		return position % 4 == 0;
	}

	@Override
	public String groupText(int position) {
		return adapter.data.get(4 * (position / 4));
	}
})
.textAlign(MKItemDecoration.Builder.ALIGN_MIDDLE)
.build());
</code></pre>
<p>通过封装，利用builder模式来更好的自定义需要的Decoration，其中，为了支持自定义View，需要外部传入相关的view的资源id和需要绑定的数据List，控件内部会通过view的measure,layout,draw的流程，将其绘制在屏幕上。</p>
<p><a href="https://github.com/Dragon-Boat/library">具体代码</a></p>
<h2><a id="recyclerview-viewholder" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView.ViewHolder</h2>
<ul>
<li>
<p><code>getPosition()</code>在API22的时候已经被废弃，因为它在异步处理器更新的时候不能准确表示数据，是模棱两可的。请根据你所使用的场景参照使用getLayoutPosition() 和 getAdapterPosition()</p>
</li>
<li>
<p><code>getAdapterPosition()</code>在调用<code>notifyDataSetChanged</code>之后并不能马上获取Adapter中的position, 要等布局结束之后才能获取到.在调用<code>notifyItemInserted(0)</code>之后能通过<code>getAdapterPosition()</code>获取适配器位置即使新的布局还没有计算。,如果你做一些用户点击,如果getAdapterPosition()返回NO_POSITION,最好忽略点击,因为你不知道用户点击(除非你有其他机制,如稳定的id查找条目)。</p>
</li>
<li>
<p><code>getLayoutPosition()</code>假设您正在使用LayoutManager或者想要访问ViewHolder当前点击的项目。在这种情况下,您应该使用<code>getLayoutPosition()</code>来获取当前布局位置。<code>mRecyclerView.findViewHolderForLayoutPosition(myViewHolder.getLayoutPosition() - 1)</code></p>
</li>
</ul>
<h2><a id="recyclerview-itemanimator" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView.ItemAnimator</h2>
<ul>
<li>
<p><code>animateAppearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br />
当RecyclerView中的item显示到屏幕上时调用此方法。传入的layout之后的ViewHolder对象。</p>
</li>
<li>
<p><code>animateDisappearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br />
当RecyclerView中的item在屏幕上由可见变为不可见时调用此方法。传入的layout之后的ViewHolder对象。</p>
</li>
<li>
<p><code>animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br />
当RecyclerView中的item状态发生改变时调用此方法(notifyItemChanged(position))。<br />
方法中传入了layout之前的ViewHolder和layout之后的ViewHolder对象，通过这两个ViewHolder对象获取其中的itemView进行动画效果。</p>
</li>
<li>
<p><code>runPendingAnimations()</code><br />
统筹RecyclerView中所有的动画，统一启动执行</p>
</li>
<li>
<p><code>setRemoveDuration(long removeDuration)</code>/<code>getRemoveDuration()</code><br />
 设置删除Item动画的延迟时间</p>
</li>
<li>
<p><code>setMoveDuration(long moveDuration)</code>/<code>getMoveDuration()</code><br />
设置移动Item动画的延迟时间</p>
</li>
<li>
<p><code>setChangeDuration(long changeDuration)</code>/<code>getChangeDuration()</code><br />
设置改变Item动画的延迟时间</p>
</li>
<li>
<p><code>setAddDuration(long addDuration)</code>/<code>getAddDuration()</code><br />
设置添加Item动画的延迟时间</p>
</li>
<li>
<p><code>recordPostLayoutInformation(RecyclerView.State state, RecyclerView.ViewHolder viewHolder)</code><br />
布局完成后对这个方法进行调用，记录view的必要信息。</p>
</li>
<li>
<p><code>onAnimationStarted(RecyclerView.ViewHolder viewHolder)</code><br />
当一个新动画添加到这个ViewHolder上，调用此方法</p>
</li>
<li>
<p><code>onAnimationFinished(RecyclerView.ViewHolder viewHolder)</code><br />
在<code>dispatchAnimationFinished(ViewHolder)</code>这个方法调用后调用</p>
</li>
<li>
<p><code>obtainHolderInfo()</code><br />
获取ViewHolder保存的<code>RecyclerView.ItemAnimator.ItemHolderInfo</code>信息</p>
</li>
<li>
<p><code>isRunning()</code><br />
判断是否有Item动画在运行</p>
</li>
<li>
<p><code>endAnimations()</code><br />
停止所有动画</p>
</li>
<li>
<p><code>endAnimation(RecyclerView.ViewHolder item)</code><br />
停止指定动画</p>
</li>
</ul>
<h2><a id="recyclerview-layoutmanager" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView.LayoutManager</h2>
<p>RecyclerView.LayoutManager是一个抽象类，系统为我们提供了三个实现类</p>
<ul>
<li>LinearLayoutManager即线性布局，这个是在上面的例子中我们用到的布局</li>
<li>GridLayoutManager即表格布局</li>
<li>StaggeredGridLayoutManager即流式布局，如瀑布流效果假如将上述例子换成GridView的效果，那么相应的代码应该这样改</li>
</ul>
<h2><a id="%E7%BB%99recyclerview%E7%9A%84item%E6%B7%BB%E5%8A%A0%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>给RecyclerView的Item添加点击事件</h2>
<p>ListView给我们提供了onItemClickListener的监听器，但对于RecyclerView来讲，非常可惜的是，该控件没有给我们提供这样的内置监听器方法，不过我们可以进行改造实现，可以这样实现Item的点击事件的监听，在我们的adapter中增加这两个方法</p>
<pre class="line-numbers"><code class="language-java">public interface OnItemClickListener{
    void onClick( int position);
    void onLongClick( int position);
}

public void setOnItemClickListener(OnItemClickListener onItemClickListener ){
    this. mOnItemClickListener=onItemClickListener;
}
</code></pre>
<p>然后onBindViewHolder方法要做如下更改</p>
<pre class="line-numbers"><code class="language-java">@Override  
public void onBindViewHolder(MyViewHolder holder, final int position) {  
    holder. tv.setText( mDatas.get(position));  
    if( mOnItemClickListener!= null){  
        holder. itemView.setOnClickListener( new OnClickListener() {  
        @Override  
        public void onClick(View v) {  
            mOnItemClickListener.onClick(position);  
        }  
    });  
                  
    holder. itemView.setOnLongClickListener( new OnLongClickListener() {  
        @Override  
        public boolean onLongClick(View v) {  
            mOnItemClickListener.onLongClick(position);  
            return false;  
        }  
    });  
}  
</code></pre>
<h2><a id="recyclerview%E5%B1%80%E9%83%A8%E5%88%B7%E6%96%B0%E7%95%8C%E9%9D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RecyclerView局部刷新界面</h2>
<h3><a id="%E6%9D%A5%E8%87%AA%E4%BA%8Erecyclerview%E7%9A%84%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>来自于RecyclerView的原理</h3>
<p>RecyclerView addView调用的时候ViewGroup addView的源码，源码如下(如无特殊说明，以下源码均为api 25)</p>
<pre class="line-numbers"><code class="language-java">public void addView(View child, int index, LayoutParams params) {
	if (DBG) {
		System.out.println(this + &quot; addView&quot;);
	}
	if (child == null) {
		throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;);
	}

	// addViewInner() will call child.requestLayout() when setting the new LayoutParams
	// therefore, we call requestLayout() on ourselves before, so that the child's request
	// will be blocked at our level
	requestLayout();
	invalidate(true);
	addViewInner(child, index, params, false);
}
</code></pre>
<p>也就是会调用requestLayout，这是一个全局刷新的函数，也就是说整个界面将会被刷新，有全局刷新在View层级较多较复杂的时必然存在卡顿<br />
那么RecyclerView 如何做到滑动时addView时不卡的呢，也就是说RecyclerView addView时候为什么没有引起RecyclerView 的onMeasure触发呢，答案就是RecyclerView 以下代码</p>
<pre class="line-numbers"><code class="language-java">@Override
public void requestLayout() {
	if (mEatRequestLayout == 0 &amp;&amp; !mLayoutFrozen) {
		super.requestLayout();
	} else {
		mLayoutRequestEaten = true;
	}
}
</code></pre>
<p>尼玛还有这种操作？？！复写requestLayout不向上报告，自己做内部处理，内部处理详见LayoutManager类的layoutChunk函数这里不细说。</p>
<p>好了，得到了黑科技的样本，接下来我就来实现一个黑科技的demo，改变View宽高时局部刷新界面。</p>
<h3><a id="%E9%BB%91%E7%A7%91%E6%8A%80%E7%9A%84%E5%BA%94%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>黑科技的应用</h3>
<p>MainActivity布局如下</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.zjw.appmethodtime.MyRelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.zjw.appmethodtime.MainActivity&quot;&gt;

    &lt;com.zjw.appmethodtime.MyLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;com.zjw.appmethodtime.MyTextView
            android:id=&quot;@+id/text_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;50dp&quot;
            android:background=&quot;@color/colorPrimary&quot;
            android:text=&quot;Click Me&quot;
            android:gravity=&quot;center&quot;
            android:textSize=&quot;25sp&quot;
            android:textStyle=&quot;bold&quot;/&gt;
    &lt;/com.zjw.appmethodtime.MyLayout&gt;
&lt;/com.zjw.appmethodtime.MyRelativeLayout&gt;
</code></pre>
<p>自定义一个RelativeLayout 用以看是否局部刷新是否生效，如果局部刷新无效则顶层onMeasure会调用（因为改变了控件大小嘛全局刷新肯定会调用到处于顶层的onMeasure）</p>
<pre class="line-numbers"><code class="language-java">public class MyRelativeLayout extends RelativeLayout {
    public MyRelativeLayout(Context context) {
        super(context);
    }

    public MyRelativeLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre>
<p>自定义一个MyLayout 继承自LinearLayout ，这里只是demo你想用什么ViewGroup可以自己改。<br />
这里MyLayout 就类似于RecyclerView 了，该子View宽高改变时会调用requestLayout，MyLayout 这里做拦截，然后自行处理。</p>
<pre class="line-numbers"><code class="language-java">public class MyLayout extends LinearLayout {
    private int mWidthMeasureSpec;
    private int mheightMeasureSpec;
    private int mLeft;
    private int mTop;
    private int mRight;
    private int mBottom;

    public static boolean shouldLocalIinvalidate = false;


    public MyLayout(Context context) {
        this(context, null);
    }

    public MyLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        mLeft = l;
        mTop = t;
        mRight = r;
        mBottom = b;
        super.onLayout(changed, l, t, r, b);
    }

    @Override
    public void requestLayout() {
        if (shouldLocalIinvalidate) {
            localRequestLayout();
        } else {
            super.requestLayout();
        }
    }

    @SuppressLint(&quot;WrongCall&quot;)
    void localRequestLayout() {
        onMeasure(mWidthMeasureSpec, mheightMeasureSpec);
        onLayout(true, mLeft, mTop, mRight, mBottom);
        invalidate();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        mWidthMeasureSpec = widthMeasureSpec;
        mheightMeasureSpec = widthMeasureSpec;
    }
}
</code></pre>
<p>以下代码就是在MainActivity里使用改变子View宽高局部刷新界面</p>
<pre class="line-numbers"><code class="language-java">package com.zjw.appmethodtime;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.TypedValue;
import android.view.View;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    protected MyRecycleView mListView;
    protected TextView mTextView;
    private float value;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        super.setContentView(R.layout.activity_main);
        initView();
    }

    private void initView() {
        Resources resources = this.getResources();
        value = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, resources.getDisplayMetrics());
        mTextView = (TextView) findViewById(R.id.text_view);
        mTextView.setOnClickListener(MainActivity.this);
    }

    @Override
    public void onClick(View view) {
        if (view.getId() == R.id.text_view) {
            view.getLayoutParams().height += value;
            //shouldLocalIinvalidate 为true 表示开启局部刷新 否则为关闭（MyLayout shouldLocalIinvalidate 默认为false）
            ((MyLayout) view.getParent()).shouldLocalIinvalidate = true;
            view.requestLayout();
            view.invalidate();
            //局部刷新完成及时恢复成可以全局刷新的状态
            ((MyLayout) view.getParent()).shouldLocalIinvalidate = false;
        }

    }
}
</code></pre>
<p>上面MainActivity 的onClick代码中开启了局部刷新（log代码自己加），效果图参见上文。<br />
把上面的<code>((MyLayout) view.getParent()).shouldLocalIinvalidate = true;</code>这句去掉，这就是相当于不启用局部刷新，然后看<code>MyRelativeLayout</code> 的<code>onMeasure</code>方法log（log代码自己加），不启用局部刷新效果图见上文。</p>
<h3><a id="%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用场景</h3>
<p>使用于某个ViewGroup宽高已定位置已定，该子view想改变宽高等场景。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502770700.html">
                
                  <h1>Android-基类实现及学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="baseactivity" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BaseActivity</h2>
<pre class="line-numbers"><code class="language-java">public abstract class BaseActivity extends FragmentActivity {

    /** 用来保存所有已打开的Activity */
    private static Stack&lt;Activity&gt; listActivity = new Stack&lt;Activity&gt;();

    /** 提示信息 **/
    private Toast mToast;

    /** 记录上次点击按钮的时间 **/
    private long lastClickTime;
    /** 按钮连续点击最低间隔时间 单位：毫秒 **/
    public final static int CLICK_TIME = 500;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(getContentViewId());

        // 设置activity为无标题栏
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        // 将activity推入栈中
        listActivity.push(this);
        // 初始化ui
        initUI();
        // 初始化数据
        initData();
        // 事件监听
        initListener();

    }

    protected void initToolbar(){
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        if(toolbar != null){
            setSupportActionBar(toolbar);
            getSupportActionBar.setDisplayShowTitleEnabled(false);
            handleToolbar(new ToolbarHelper(this));
        }
    }

    /** 初始化ui **/
    protected abstract void initUI();

    /** 初始化数据 **/
    protected abstract void initData();

    /** 初始化监听 **/
    protected abstract void initListener();

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        saveInstanceState(outState);
        super.onSaveInstanceState(outState);
    }
    // 设置activity为无标题栏
    protected void setBase(){
        requestWindowFeature(Window.FEATURE_NO_TITLE);
    }

    /** 保存activity状态 **/
    protected void saveInstanceState(Bundle outState) {

    }

    protected void handleToolbar(){
        
    }

    @Override
    public void onBackPressed() {
        super.onBackPressed();

    }

    public void onBack(View v) {
        finish();

    }

    @Override
    protected void onResume() {
        super.onResume();

    }

    protected abstract int getContentViewId();

    protected void showLongToast(String toastText){
        Toast.makeText(this,toastText,Toast.LENGTH_LONG).show();
    }
    
    protected void showShortToast(String toastText){
        Toast.makeText(this,toastText,Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 从栈中移除当前activity
        if (listActivity.contains(this)) {
            listActivity.remove(this);
        }

    }

    /********************** activity跳转 **********************************/
    public void openActivity(Class&lt;?&gt; targetActivityClass) {
        openActivity(targetActivityClass, null);
    }

    public void openActivity(Class&lt;?&gt; targetActivityClass, Bundle bundle) {
        Intent intent = new Intent(this, targetActivityClass);
        if (bundle != null) {
            intent.putExtras(bundle);
        }
        startActivity(intent);
    }

    public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass) {
        openActivity(targetActivityClass);
        this.finish();
    }

    public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass, Bundle bundle) {
        openActivity(targetActivityClass, bundle);
        this.finish();
    }

    /***************************************************************/

    /** 验证上次点击按钮时间间隔，防止重复点击 */
    public boolean verifyClickTime() {
        if (System.currentTimeMillis() - lastClickTime &lt;= CLICK_TIME) {
            return false;
        }
        lastClickTime = System.currentTimeMillis();
        return true;
    }

    /** 收起键盘 */
    public void closeInputMethod() {
        // 收起键盘
        View view = getWindow().peekDecorView();// 用于判断虚拟软键盘是否是显示的
        if (view != null) {
            InputMethodManager inputmanger = (InputMethodManager) getSystemService(Activity.INPUT_METHOD_SERVICE);
            inputmanger.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
        }
    }

    /**
     * 获取string
     * 
     * @param mRid
     * @return
     */
    public String getStringMethod(int mRid) {
        return this.getResources().getString(mRid);
    }

    /**
     * 获取demin
     * 
     * @param mRid
     * @return
     */
    protected int getDemonIntegerMethod(int mRid) {
        return (int) this.getResources().getDimension(mRid);
    }

    /**
     * 关闭所有(前台、后台)Activity,注意：请已BaseActivity为父类
     */
    protected static void finishAll() {
        int len = listActivity.size();
        for (int i = 0; i &lt; len; i++) {
            Activity activity = listActivity.pop();
            activity.finish();
        }
    }

    /***************** 双击退出程序 ************************************************/
    private long exitTime = 0;

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {

        if (KeyEvent.KEYCODE_BACK == keyCode) {
            // 判断是否在两秒之内连续点击返回键，是则退出，否则不退出
            if (System.currentTimeMillis() - exitTime &gt; 2000) {
                Toast.makeText(getApplicationContext(), &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show();
                // 将系统当前的时间赋值给exitTime
                exitTime = System.currentTimeMillis();
            } else {
                finishAll();
            }
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    /*
     * ************Fragement相关方法************************************************
     * 
     */
    private Fragment currentFragment;

    /** Fragment替换(当前destrory,新的create) */
    public void fragmentReplace(int target, Fragment toFragment, boolean backStack) {
        FragmentManager manager = getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        String toClassName = toFragment.getClass().getSimpleName();
        if (manager.findFragmentByTag(toClassName) == null) {
            transaction.replace(target, toFragment, toClassName);
            if (backStack) {
                transaction.addToBackStack(toClassName);
            }
            transaction.commit();
        }
    }

    /** Fragment替换(核心为隐藏当前的,显示现在的,用过的将不会destrory与create) */
    public void smartFragmentReplace(int target, Fragment toFragment) {
        FragmentManager manager = getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        // 如有当前在使用的-&gt;隐藏当前的
        if (currentFragment != null) {
            transaction.hide(currentFragment);
        }
        String toClassName = toFragment.getClass().getSimpleName();
        // toFragment之前添加使用过-&gt;显示出来
        if (manager.findFragmentByTag(toClassName) != null) {
            transaction.show(toFragment);
        } else {// toFragment还没添加使用过-&gt;添加上去
            transaction.add(target, toFragment, toClassName);
        }
        transaction.commit();
        // toFragment更新为当前的
        currentFragment = toFragment;
    }

    /***********************************************************************/
}
</code></pre>
<h2><a id="basefragment" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BaseFragment</h2>
<pre class="line-numbers"><code class="language-java">public abstract class BaseFragment extends Fragment {

    protected Activity mActivity;

    /**
     * 获得全局的，防止使用getActivity()为空
     * @param context
     */
    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
        this.mActivity = (Activity)context;
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container
            , Bundle savedInstanceState) {

        View view = LayoutInflater.from(mActivity)
                .inflate(getLayoutId(), container, false);
        initView(view, savedInstanceState);

        return view;
    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        initData();
    }

    /**
     * 该抽象方法就是 onCreateView中需要的layoutID
     * @return
     */
    protected abstract int getLayoutId();

    /**
     * 该抽象方法就是 初始化view
     * @param view
     * @param savedInstanceState
     */
    protected abstract void initView(View view, Bundle savedInstanceState);

    /**
     * 执行数据的加载
     */
    protected abstract void initData();
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502770827.html">
                
                  <h1>Android-Scroller详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>Scroller是一个专门用于处理滚动效果的工具类，可能在大多数情况下，我们直接使用Scroller的场景并不多，但是很多大家所熟知的控件在内部都是使用Scroller来实现的，如ViewPager、ListView等。先撇开Scroller类不谈，其实任何一个控件都是可以滚动的，因为在View类当中有scrollTo()和scrollBy()这两个方法。这两个方法都是用于对View进行滚动的，那么它们之间有什么区别呢？简单点讲，scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。<strong>注意，不管是scrollTo()还是scrollBy()方法，滚动的都是该View内部的内容</strong></p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017092315061662718986.jpg" alt="2017092315061662718986.jpg" /><figcaption>2017092315061662718986.jpg<figcaption></figure></p>
<p>第一个参数x表示相对于当前位置横向移动的距离，正值向左移动，负值向右移动，单位是像素。第二个参数y表示相对于当前位置纵向移动的距离，正值向上移动，负值向下移动，单位是像素。</p>
<h2><a id="scrollby" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>scrollBy()</h2>
<p><code>scrollBy()</code>方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直向右下方移动。</p>
<h2><a id="scrollto" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>scrollTo()</h2>
<p><code>scrollTo()</code>方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。</p>
<h2><a id="scroller" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scroller</h2>
<p>目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。<br />
Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p>
<ul>
<li>创建Scroller的实例</li>
<li>调用startScroll()方法来初始化滚动数据并刷新界面 </li>
<li>重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</li>
</ul>
<h2><a id="startscroll-int-startx-int-starty-int-dx-int-dy" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>startScroll(int startX,int startY,int dx,int dy)</h2>
<ul>
<li>第一个参数是滚动开始时X的坐标</li>
<li>第二个参数是滚动开始时Y的坐标</li>
<li>第三个参数是横向滚动的距离,正值表示向左滚动</li>
<li>第四个参数是纵向滚动的距离，正值表示向上滚动。</li>
<li>紧接着调用invalidate()方法来刷新界面。</li>
</ul>
<h2><a id="startscroll-int-startx-int-starty-int-dx-int-dy-int-duration" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>startScroll (int startX,  int startY, int dx, int dy, int duration)</h2>
<p>同上</p>
<ul>
<li>第五个参数是滑动时间</li>
</ul>
<h2><a id="computescroll" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>computeScroll()</h2>
<p>在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。</p>
<pre class="line-numbers"><code class="language-java">@Override
public void computeScroll() {
    // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        invalidate();
    }
}
</code></pre>
<h2><a id="getscrollx-getscrolly" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getScrollX() | getScrollY()</h2>
<p>返回当前view在x或者y方向上的滚动距离</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502771006.html">
                
                  <h1>Android-线程管理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="thread" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thread</h2>
<ul>
<li>继承Thread方式</li>
<li>实现Runnable接口</li>
</ul>
<h2><a id="thread%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thread主要函数：</h2>
<ul>
<li><code>run()</code>//包含线程运行时所执行的代码</li>
<li><code>start()</code>//用于启动线程</li>
<li><code>sleep()/sleep(long millis)</code>//线程休眠，交出CPU，让CPU去执行其他的任务，然后线程进入阻塞状态，sleep方法不会释放锁</li>
<li><code>yield()</code>//使当前线程交出CPU，让CPU去执行其他的任务，但不会是线程进入阻塞状态，而是重置为就绪状态，yield方法不会释放锁</li>
<li><code>join()/join(long millis)/join(long millis,int nanoseconds)</code>//等待线程终止，直白的说 就是发起该子线程的线程 只有等待该子线程运行结束才能继续往下运行</li>
<li><code>wait()</code>//交出cpu，让CPU去执行其他的任务，让线程进入阻塞状态，同时也会释放锁</li>
<li><code>interrupt()</code>//中断线程，自stop函数过时之后，我们通过interrupt方法和isInterrupted()方法来停止正在运行的线程，注意只能中断已经处于阻塞的线程</li>
<li><code>getId()</code>//获取当前线程的ID</li>
<li><code>getName()/setName()</code>//获取和设置线程的名字</li>
<li><code>getPriority()/setPriority()</code>//获取和这是线程的优先级 一般property用1-10的整数表示，默认优先级是5，优先级最高是10，优先级高的线程被执行的机率高</li>
<li><code>setDaemon()/isDaemo()</code>//设置和判断是否是守护线程</li>
<li><code>currentThread()</code>//静态函数获取当前线程</li>
</ul>
<h2><a id="thread%E7%BA%BF%E7%A8%8B%E4%B8%BB%E8%A6%81%E7%8A%B6%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thread线程主要状态</h2>
<ol>
<li>New  一旦被实例化之后就处于new状态</li>
<li>Runnable 调用了start函数之后就处于Runnable状态</li>
<li>Running 线程被cpu执行 调用run函数之后 就处于Running状态</li>
<li>Blocked 调用join()、sleep()、wait()使线程处于Blocked状态</li>
<li>Dead    线程的run()方法运行完毕或被中断或被异常退出，线程将会到达Dead状态</li>
</ol>
<h2><a id="%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何停止一个线程</h2>
<p>通过interrupt方法和isInterrupted()方法来停止正在运行的线程，首先必须先让线程处于阻塞状态</p>
<h2><a id="thread%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thread线程同步问题</h2>
<ul>
<li>同步函数</li>
<li>同步代码块</li>
<li>使用特殊域变量(volatile)实现线程同步</li>
</ul>
<h2><a id="executorservice%E7%BA%BF%E7%A8%8B%E6%B1%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ExecutorService线程池</h2>
<h3><a id="new-thread%E7%9A%84%E7%BC%BA%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>new Thread()的缺点</h3>
<ul>
<li>每次new Thread()耗费性能</li>
<li>调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。</li>
<li>不利于扩展，比如如定时执行、定期执行、线程中断</li>
</ul>
<h4><a id="%E9%87%87%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>采用线程池的优点</h4>
<ul>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>
<p><strong>ExecutorService</strong></p>
<pre class="line-numbers"><code class="language-java">public interface ExecutorService extends Executor{
    void shutdown();//顺次地关闭ExecutorService,停止接收新的任务，等待所有已经提交的任务执行完毕之后，关闭ExecutorService

    List&lt;Runnable&gt; shutdownNow();//阻止等待任务启动并试图停止当前正在执行的任务，停止接收新的任务，返回处于等待的任务列表

    boolean isShutdown();//判断线程池是否已经关闭

    boolean isTerminated();//如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。

    
    boolean awaitTermination(long timeout, TimeUnit unit)//等待（阻塞）直到关闭或最长等待时间或发生中断,timeout - 最长等待时间 ,unit - timeout 参数的时间单位  如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false 

 
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);//提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。

    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。

 
    Future&lt;?&gt; submit(Runnable task);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。
        throws InterruptedException;

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                  long timeout, TimeUnit unit)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。
        throws InterruptedException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。
        throws InterruptedException, ExecutionException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;   
}
</code></pre>
<p><strong>Executor接口</strong></p>
<pre class="line-numbers"><code class="language-java">public interface Executor {

    void execute(Runnable command);//执行已提交的 Runnable 任务对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法
}
</code></pre>
<p><strong>Executors工厂类</strong></p>
<ul>
<li><code>newFixedThreadPool()</code>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。(运行结果：总共只会创建5个线程， 开始执行五个线程，当五个线程都处于活动状态，再次提交的任务都会加入队列等到其他线程运行结束，当线程处于空闲状态时会被下一个任务复用)</li>
<li><code>newCachedThreadPool()</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程(运行结果：可以看出缓存线程池大小是不定值，可以需要创建不同数量的线程，在使用缓存型池时，先查看池中有没有以前创建的线程，如果有，就复用.如果没有，就新建新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务)</li>
<li><code>newScheduledThreadPool()</code>创建一个定长线程池，支持定时及周期性任务执行<code>schedule(Runnable command,long delay, TimeUnit unit)</code>创建并执行在给定延迟后启用的一次性操作(运行结果和newFixedThreadPool类似，不同的是newScheduledThreadPool是延时一定时间之后才执行<code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnitunit)</code>  创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 <code>initialDelay</code>后开始执行，然后在<code>initialDelay+period</code> 后执行，接着在 <code>initialDelay + 2 * period</code> 后执行，依此类推)<code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟</li>
<li><code>newSingleThreadExecutor()</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行(运行结果：只会创建一个线程，当上一个执行完之后才会执行第二个)通过<code>ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</code>实现延时的单线程线程池。</li>
</ul>
<h2><a id="threadpoolexecutor" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ThreadPoolExecutor</h2>
<p>ThreadPoolExecutor线程池用于管理线程任务队列、若干个线程。</p>
<h3><a id="1-threadpoolexecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1.ThreadPoolExecutor构造函数</h3>
<pre class="line-numbers"><code class="language-java">ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue);
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit,BlockingQueue workQueue,RejectedExecutionHandler handler);
ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler) ;
ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory, RejectedExecutionHandler handler);
</code></pre>
<ul>
<li><em>corePoolSize</em>： 线程池维护线程的最少数量　　</li>
<li><em>maximumPoolSize</em>：线程池维护线程的最大数量　　</li>
<li><em>keepAliveTime</em>： 线程池维护线程所允许的空闲时间　　</li>
<li><em>unit</em>： 线程池维护线程所允许的空闲时间的单位　　</li>
<li><em>workQueue</em>： 线程池所使用的缓冲队列　　</li>
<li><em>threadFactory</em>：线程池用于创建线程　　</li>
<li><em>handler</em>： 线程池对拒绝任务的处理策略</li>
</ul>
<h3><a id="asynctask" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AsyncTask</h3>
<p>Android的AsyncTask比Handler更轻量级一些，适用于简单的异步处理。同时在处理单个后台任务时，AsyncTask的代码量更少并且更加轻量级。<br />
AsyncTask定义了三种泛型类型 Params，Progress和Result。</p>
<ul>
<li>Params 启动任务执行的输入参数，比如HTTP请求的URL。</li>
<li>Progress 后台任务执行的百分比。</li>
<li>Result 后台执行任务最终返回的结果，比如String。<br />
使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法：</li>
<li>doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。</li>
<li>onPostExecute(Result)  相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回<br />
有必要的话你还得重写以下这三个方法，但不是必须的：</li>
<li>onProgressUpdate(Progress…)   可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。</li>
<li>onPreExecute()        这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。</li>
<li>onCancelled()             用户调用取消时，要做的操作<br />
使用AsyncTask类，以下是几条必须遵守的准则：</li>
<li>Task的实例必须在UI thread中创建；</li>
<li>execute方法必须在UI thread中调用；</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params...), onProgressUpdate(Progress...)这几个方法；</li>
<li>该task只能被执行一次，否则多次调用时将会出现异常；</li>
</ul>
<h3><a id="%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考</h3>
<p><a href="http://www.cnblogs.com/whoislcj/p/5603277.html">Android线程管理</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502771669.html">
                
                  <h1>Android Matrix</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="matrix%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Matrix的数学原理</h2>
<p>在Android中，如果你用Matrix进行过图像处理，那么一定知道Matrix这个类。Android中的Matrix是一个3 x 3的矩阵，其内容如下：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833750324849.png" alt="1.png" /><figcaption>1.png<figcaption></figure></p>
<p>Matrix的对图像的处理可分为四类基本变换：</p>
<ul>
<li>Translate	————	平移变换</li>
<li>Rotate		————	旋转变换</li>
<li>Scale		————	缩放变换</li>
<li>Skew			————	错切变换</li>
</ul>
<p>从字面上理解，矩阵中的MSCALE用于处理缩放变换，MSKEW用于处理错切变换，MTRANS用于处理平移变换，MPERSP用于处理透视变换。实际中当然不能完全按照字面上的说法去理解Matrix。同时，在Android的文档中，未见到用Matrix进行透视变换的相关说明，所以本文也不讨论这方面的问题。这里需要把矩阵根据他们的作用划分为4块：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616374765871.png" alt="20170923150616374765871.png" /><figcaption>20170923150616374765871.png<figcaption></figure></p>
<p>如上图所示，这四块区域各有作用。后面会详细讲解各个作用，先来看看这个矩阵是如何影响图像的。先看看屏幕的坐标系：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616379323870.png" alt="20170923150616379323870.png" /><figcaption>20170923150616379323870.png<figcaption></figure></p>
<p>看上图，这里表示了屏幕的坐标系，其中的x，y轴是大家所熟知的，但是其实，一个物体他是存在于一个三维空间的，所以必然会有z轴。我们的屏幕，就像是一个窗口，透过它，我们看到了屏幕后面的世界，那里面有各种物体，我们看到的是映射在x，y平面上的一个投射图像。屏幕就像是一个镜头一样，将里面的物体映射到x，y平面上，成为一个二维的图像。那么如果，我们把屏幕这个镜头沿着z轴，拉远或者拉进，那么图像会有什么变化呢，肯定会变小或者变大。就好比坐在飞机上透过窗口看地面的汽车，和在地面上看到的大小是不同的。</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616386136695.png" alt="20170923150616386136695.png" /><figcaption>20170923150616386136695.png<figcaption></figure></p>
<p>x，y分别代表x，y轴上的坐标，而1代表屏幕在z轴上的坐标为默认的。如果将1变大，那么屏幕会拉远， 图形会变小。</p>
<p>针对每种变换，Android提供了pre、set和post三种操作方式。其中</p>
<ul>
<li>set用于设置Matrix中的值。</li>
<li>pre是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。</li>
<li>post是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。</li>
</ul>
<p>除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。</p>
<p>下面我们来看看四种变换的具体情形。由于所有的图形都是有点组成，因此我们只需要考察一个点相关变换即可。</p>
<h3><a id="%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>平移变换</h3>
<p>假定有一个点的坐标是 P(\(x_{0}\),\(y_{0}\)) ，将其移动到 P(x,y) ，再假定在x轴和y轴方向移动的大小分别为: \(\Delta\)x = x - \(x_{0}\) and \(\Delta\)y = y - \(y_{0}\)</p>
<p>如下图所示：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833900863943.png" alt="20170301148833900863943.png" /><figcaption>20170301148833900863943.png<figcaption></figure></p>
<p>不难知道：<br />
x = \(x_{0}\) + \(\Delta\)x<br />
y = \(y_{0}\) + \(\Delta\)y</p>
<p>如果用矩阵来表示的话，就可以写成：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833910576102.png" alt="20170301148833910576102.png" /><figcaption>20170301148833910576102.png<figcaption></figure></p>
<h3><a id="%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>旋转变换</h3>
<h4><a id="%E5%9B%B4%E7%BB%95%E5%9D%90%E6%A0%87%E5%8E%9F%E7%82%B9%E6%97%8B%E8%BD%AC%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>围绕坐标原点旋转：</h4>
<p>假定有一个点 P(\(x_{0}\),\(y_{0}\)) ，相对坐标原点 \(\theta\) 顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833915872714.png" alt="20170301148833915872714.png" /><figcaption>20170301148833915872714.png<figcaption></figure></p>
<p>那么，<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833921797142.png" alt="20170301148833921797142.png" /><figcaption>20170301148833921797142.png<figcaption></figure></p>
<p>如果用矩阵，就可以表示为：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833923074578.png" alt="20170301148833923074578.png" /><figcaption>20170301148833923074578.png<figcaption></figure></p>
<h4><a id="%E5%9B%B4%E7%BB%95%E6%9F%90%E4%B8%AA%E7%82%B9%E6%97%8B%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>围绕某个点旋转</h4>
<p>如果是围绕某个点 P(\(x_{p}\),\(y_{p}\)) 顺时针旋转 \(\theta\) ，那么可以用矩阵表示为：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883392576953.png" alt="2017030114883392576953.png" /><figcaption>2017030114883392576953.png<figcaption></figure><br />
可以化为：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833927146486.png" alt="20170301148833927146486.png" /><figcaption>20170301148833927146486.png<figcaption></figure><br />
很显然<br />
1、<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833928967061.png" alt="20170301148833928967061.png" /><figcaption>20170301148833928967061.png<figcaption></figure>是将坐标原点移动到点 P(\(x_{p}\),\(y_{p}\)) 后， P(\(x_{0}\),\(y_{0}\)) 的新坐标。</p>
<p>2、<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833934213059.png" alt="20170301148833934213059.png" /><figcaption>20170301148833934213059.png<figcaption></figure>是将上一步变换后的 P(\(x_{0}\),\(y_{0}\)) ，围绕新的坐标原点顺时针旋转 \(\theta\) 。<br />
3、<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833940633954.png" alt="20170301148833940633954.png" /><figcaption>20170301148833940633954.png<figcaption></figure><br />
经过上一步旋转变换后，再将坐标原点移回到原来的坐标原点。<br />
所以，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。</p>
<p>同时，可以看到，上面的矩阵四块区域的切分也是因为矩阵乘法的操作决定的，由于这里的乘法运算中，左上角的四个值，可以和x，y值做乘法运算，所以可以影响到旋转等操作，而右上角的模块，只能做加法，所以只能影响到平移。右下角的模块主要管z轴，自然就可以进行等比的缩放了，左下角的模块一般不去动他，否则会把x，y值加入到z轴中来，会不可控。</p>
<h3><a id="%E7%BC%A9%E6%94%BE%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缩放变换</h3>
<p>理论上而言，一个点是不存在什么缩放变换的，但考虑到所有图像都是由点组成，因此，如果图像在x轴和y轴方向分别放大k1和k2倍的话，那么图像中的所有点的x坐标和y坐标均会分别放大k1和k2倍，即<br />
x = \(k_{1}\)x_{0}\(    y =\)k_{2}\(y_{0}\)<br />
用矩阵表示就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833944726575.png" alt="20170301148833944726575.png" /><figcaption>20170301148833944726575.png<figcaption></figure><br />
缩放变换比较好理解，就不多说了。</p>
<h3><a id="%E9%94%99%E5%88%87%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>错切变换</h3>
<p>错切变换(skew)在数学上又称为Shear mapping(可译为“剪切变换”)或者Transvection(缩并)，它是一种比较特殊的线性变换。错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对应的y坐标(或者x坐标)则按比例发生平移，且平移的大小和该点到x轴(或y轴)的垂直距离成正比。错切变换，属于等面积变换，即一个形状在错切变换的前后，其面积是相等的。<br />
比如下图，各点的y坐标保持不变，但其x坐标则按比例发生了平移。这种情况将水平错切。</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833947362086.png" alt="20170301148833947362086.png" /><figcaption>20170301148833947362086.png<figcaption></figure><br />
下图各点的x坐标保持不变，但其y坐标则按比例发生了平移。这种情况叫垂直错切。</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833948852458.png" alt="20170301148833948852458.png" /><figcaption>20170301148833948852458.png<figcaption></figure></p>
<p>假定一个点 P(\(x_{0}\),\(y_{0}\)) 经过错切变换后得到 P(x,y) ，对于水平错切而言，应该有如下关系：<br />
x = \(x_{0}\) + k\(y_{0}\)<br />
y = \(y_{0}\)<br />
用矩阵表示就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833957987910.png" alt="20170301148833957987910.png" /><figcaption>20170301148833957987910.png<figcaption></figure><br />
扩展到3 x 3的矩阵就是下面这样的形式：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833959011272.png" alt="20170301148833959011272.png" /><figcaption>20170301148833959011272.png<figcaption></figure><br />
同理，对于垂直错切，可以有：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833960187699.png" alt="20170301148833960187699.png" /><figcaption>20170301148833960187699.png<figcaption></figure><br />
在数学上严格的错切变换就是上面这样的。在Android中除了有上面说到的情况外，还可以同时进行水平、垂直错切，那么形式上就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833961263046.png" alt="20170301148833961263046.png" /><figcaption>20170301148833961263046.png<figcaption></figure></p>
<h3><a id="%E5%AF%B9%E7%A7%B0%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对称变换</h3>
<p>除了上面讲到的4中基本变换外，事实上，我们还可以利用Matrix，进行对称变换。所谓对称变换，就是经过变化后的图像和原图像是关于某个对称轴是对称的。比如，某点 P(\(x_{0}\),\(y_{0}\)) 经过对称变换后得到 P(x,y) ，</p>
<p>如果对称轴是x轴，那么，<br />
x = \(x_{0}\)<br />
y = -\(y_{0}\)<br />
用矩阵表示就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834373561338.png" alt="20170301148834373561338.png" /><figcaption>20170301148834373561338.png<figcaption></figure><br />
如果对称轴是y轴，那么，<br />
x = -\(x_{0}\)<br />
y = \(y_{0}\)<br />
用矩阵表示就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834375645689.png" alt="20170301148834375645689.png" /><figcaption>20170301148834375645689.png<figcaption></figure><br />
如果对称轴是y = x，如图：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834376584200.png" alt="20170301148834376584200.png" /><figcaption>20170301148834376584200.png<figcaption></figure><br />
那么，<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834377595408.png" alt="20170301148834377595408.png" /><figcaption>20170301148834377595408.png<figcaption></figure><br />
很容易可以解得：<br />
x = \(y_{0}\)<br />
y = \(x_{0}\)<br />
用矩阵表示就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883437925984.png" alt="2017030114883437925984.png" /><figcaption>2017030114883437925984.png<figcaption></figure><br />
同样的道理，如果对称轴是y = -x，那么用矩阵表示就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834380928745.png" alt="20170301148834380928745.png" /><figcaption>20170301148834380928745.png<figcaption></figure><br />
特殊地，如果对称轴是y = kx，如下图：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834381851581.png" alt="20170301148834381851581.png" /><figcaption>20170301148834381851581.png<figcaption></figure><br />
那么，<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834382842810.png" alt="20170301148834382842810.png" /><figcaption>20170301148834382842810.png<figcaption></figure><br />
很容易可解得：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834383638888.png" alt="20170301148834383638888.png" /><figcaption>20170301148834383638888.png<figcaption></figure><br />
用矩阵表示就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201703011488343844739.png" alt="201703011488343844739.png" /><figcaption>201703011488343844739.png<figcaption></figure></p>
<p>当k = 0时，即y = 0，也就是对称轴为x轴的情况；当k趋于无穷大时，即x = 0，也就是对称轴为y轴的情况；当k =1时，即y = x，也就是对称轴为y = x的情况；当k = -1时，即y = -x，也就是对称轴为y = -x的情况。不难验证，这和我们前面说到的4中具体情况是相吻合的。<br />
如果对称轴是y = kx + b这样的情况，只需要在上面的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834385747500.png" alt="20170301148834385747500.png" /><figcaption>20170301148834385747500.png<figcaption></figure><br />
需要特别注意：在实际编程中，我们知道屏幕的y坐标的正向和数学中y坐标的正向刚好是相反的，所以在数学上y = x和屏幕上的y = -x才是真正的同一个东西，反之亦然。也就是说，如果要使图片在屏幕上看起来像按照数学意义上y = x对称，那么需使用这种转换：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834387269783.png" alt="20170301148834387269783.png" /><figcaption>20170301148834387269783.png<figcaption></figure><br />
要使图片在屏幕上看起来像按照数学意义上y = -x对称，那么需使用这种转换：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883438827302.png" alt="2017030114883438827302.png" /><figcaption>2017030114883438827302.png<figcaption></figure><br />
关于对称轴为y = kx 或y = kx + b的情况，同样需要考虑这方面的问题。</p>
<h3><a id="%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三角函数</h3>
<pre class="line-numbers"><code class="language-plain_text">public void setSinCos(float sinValue, float cosValue, float px, float py)
public void setSinCos(float sinValue, float cosValue)
</code></pre>
<p>这个方法乍一看可能有点蒙，其实在前面的原理中，我们讲解了一个旋转的例子，他最终的矩阵效果是这样的：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616425357007.jpg" alt="20170923150616425357007.jpg" /><figcaption>20170923150616425357007.jpg<figcaption></figure></p>
<p>其实旋转，就是使用了这样的matrix，显而易见，这里的参数就清晰了。<br />
sinValue：对应图中的sin值<br />
cosValue：对应cos值<br />
px:中心的x坐标<br />
py：中心的y坐标<br />
看一个示例,我们把图像旋转90度，那么90度对应的sin和cos分别是1和0。</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616431122661.png" alt="20170923150616431122661.png" /><figcaption>20170923150616431122661.png<figcaption></figure></p>
<p>看代码如下：</p>
<pre class="line-numbers"><code class="language-java">Matrixmatrix = new Matrix();
matrix.setSinCos(1, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);
canvas.drawBitmap(bitmap, matrix, paint);123123
</code></pre>
<h3><a id="%E6%95%B0%E5%80%BC%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数值操作</h3>
<p>数值操作这一组方法可以帮助我们直接控制Matrix里面的数值。</p>
<h4><a id="set" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>set</h4>
<p><code>void set (Matrix src)</code>没有返回值，有一个参数，作用是将参数Matrix的数值复制到当前Matrix中。如果参数为空，则重置当前Matrix，相当于<code>reset()</code></p>
<h4><a id="reset" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>reset</h4>
<p><code>void reset ()</code>重置当前Matrix(将当前Matrix重置为单位矩阵)。</p>
<h4><a id="setvalues" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setValues</h4>
<p><code>void setValues (float[] values)</code>setValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</p>
<h4><a id="getvalues" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>getValues</h4>
<p><code>void getValues (float[] values)</code>很显然，getValues和setValues是一对方法，参数也是浮点型的一维数组，长度需要大于9，将Matrix中的数值拷贝进参数的前9位中。</p>
<h2><a id="%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本方法解析</h2>
<p>讲解完了matrix作用于像素点的原理之后，我们逐个讲解它的方法。</p>
<pre class="line-numbers"><code class="language-java">public Matrix()
public Matrix(Matrix src)
</code></pre>
<p>构造函数有两个，第一个是直接创建一个单位矩阵，第二个是根据提供的矩阵创建一个新的矩阵（采用deep copy）<br />
单位矩阵如下：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616404162667.png" alt="20170923150616404162667.png" /><figcaption>20170923150616404162667.png<figcaption></figure></p>
<pre class="line-numbers"><code class="language-java">public boolean isIdentity()//判断是否是单位矩阵
public boolean isAffine()//判断是否是仿射矩阵
</code></pre>
<p>是否是单位矩阵很简单，就不做讲解了，这里是否是仿射矩阵可能大家不好理解。<br />
首先来看看什么是仿射变换。仿射变换其实就是二维坐标到二维坐标的线性变换，保持二维图形的“平直性”（即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（指保持二维图形间的相对位置关系不变，平行线还是平行线，而直线上点的位置顺序不变），可以通过一系列的原子变换的复合来实现，原子变换就包括：平移、缩放、翻转、旋转和错切。这里除了透视可以改变z轴以外，其他的变换基本都是上述的原子变换，所以，只要最后一行是0,0,1则是仿射矩阵。<code>public boolean rectStaysRect()</code>判断该矩阵是否可以将一个矩形依然变换为一个矩形。当矩阵是单位矩阵，或者只进行平移，缩放，以及旋转90度的倍数的时候，返回true。<code>public void reset()</code>重置矩阵为单位矩阵。<br />
<code>public void setTranslate(float dx, float dy)</code>设置平移效果，参数分别是x，y上的平移量。<br />
效果图如下：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616415154198.png" alt="20170923150616415154198.png" /><figcaption>20170923150616415154198.png<figcaption></figure></p>
<p>代码如下：</p>
<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
canvas.drawBitmap(bitmap, matrix, paint);

matrix.setTranslate(100, 1000);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>
<h2><a id="%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>代码验证</h2>
<p>在第一部分中讲到的各种图像变换的验证代码如下，一共列出了10种情况。如果要验证其中的某一种情况，只需将相应的代码反注释即可。试验中用到的图片：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883438981398.png" alt="2017030114883438981398.png" /><figcaption>2017030114883438981398.png<figcaption></figure><br />
其尺寸为162 x 251。</p>
<p>每种变换的结果，请见代码之后的说明。</p>
<pre class="line-numbers"><code class="language-java">import android.app.Activity;  
import android.content.Context;  
import android.graphics.Bitmap;  
import android.graphics.BitmapFactory;  
import android.graphics.Canvas;  
import android.graphics.Matrix;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.MotionEvent;  
import android.view.View;  
import android.view.Window;  
import android.view.WindowManager;  
import android.view.View.OnTouchListener;  
import android.widget.ImageView;  
  
public class TestTransformMatrixActivity extends Activity  
implements  
OnTouchListener  
{  
    private TransformMatrixView view;  
    @Override  
    public void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);  
  
        view = new TransformMatrixView(this);  
        view.setScaleType(ImageView.ScaleType.MATRIX);  
        view.setOnTouchListener(this);  
          
        setContentView(view);  
    }  
      
    class TransformMatrixView extends ImageView  
    {  
        private Bitmap bitmap;  
        private Matrix matrix;  
        public TransformMatrixView(Context context)  
        {  
            super(context);  
            bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie);  
            matrix = new Matrix();  
        }  
  
        @Override  
        protected void onDraw(Canvas canvas)  
        {  
            // 画出原图像  
            canvas.drawBitmap(bitmap, 0, 0, null);  
            // 画出变换后的图像  
            canvas.drawBitmap(bitmap, matrix, null);  
            super.onDraw(canvas);  
        }  
  
        @Override  
        public void setImageMatrix(Matrix matrix)  
        {  
            this.matrix.set(matrix);  
            super.setImageMatrix(matrix);  
        }  
          
        public Bitmap getImageBitmap()  
        {  
            return bitmap;  
        }  
    }  
  
    public boolean onTouch(View v, MotionEvent e)  
    {  
        if(e.getAction() == MotionEvent.ACTION_UP)  
        {  
            Matrix matrix = new Matrix();  
            // 输出图像的宽度和高度(162 x 251)  
            Log.e(&quot;TestTransformMatrixActivity&quot;, &quot;image size: width x height = &quot; +  view.getImageBitmap().getWidth() + &quot; x &quot; + view.getImageBitmap().getHeight());  
            // 1. 平移  
            matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
            // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight()  
            view.setImageMatrix(matrix);  
              
            // 下面的代码是为了查看matrix中的元素  
            float[] matrixValues = new float[9];  
            matrix.getValues(matrixValues);  
            for(int i = 0; i &lt; 3; ++i)  
            {  
                String temp = new String();  
                for(int j = 0; j &lt; 3; ++j)  
                {  
                    temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
                }  
                Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
            }  
              
  
//          // 2. 旋转(围绕图像的中心点)  
//          matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
              
//          // 3. 旋转(围绕坐标原点) + 平移(效果同2)  
//          matrix.setRotate(45f);  
//          matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f);  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 4. 缩放  
//          matrix.setScale(2f, 2f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 5. 错切 - 水平  
//          matrix.setSkew(0.5f, 0f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠           
//          matrix.postTranslate(view.getImageBitmap().getWidth(), 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 6. 错切 - 垂直  
//          matrix.setSkew(0f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          7. 错切 - 水平 + 垂直  
//          matrix.setSkew(0.5f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 8. 对称 (水平对称)  
//          float matrix_values[] = {1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 9. 对称 - 垂直  
//          float matrix_values[] = {-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }     
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 10. 对称(对称轴为直线y = x)  
//          float matrix_values[] = {0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(),   
//                  view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
            view.invalidate();  
        }  
        return true;  
    }  
}
</code></pre>
<p>下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵</p>
<h3><a id="%E5%B9%B3%E7%A7%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>平移</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834397841218.png" alt="20170301148834397841218.png" /><figcaption>20170301148834397841218.png<figcaption></figure><br />
输出的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834399578654.png" alt="20170301148834399578654.png" /><figcaption>20170301148834399578654.png<figcaption></figure><br />
请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。</p>
<h3><a id="%E6%97%8B%E8%BD%AC%E5%9B%B4%E7%BB%95%E5%9B%BE%E5%83%8F%E7%9A%84%E4%B8%AD%E5%BF%83%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>旋转(围绕图像的中心点)</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834401523528.png" alt="20170301148834401523528.png" /><figcaption>20170301148834401523528.png<figcaption></figure><br />
输出的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834402755650.png" alt="20170301148834402755650.png" /><figcaption>20170301148834402755650.png<figcaption></figure></p>
<p><strong>它实际上是</strong><br />
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br />
<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code><br />
这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式,<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br />
所产生的转换矩阵就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834407336074.png" alt="20170301148834407336074.png" /><figcaption>20170301148834407336074.png<figcaption></figure><br />
而<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code>的意思就是在上述矩阵的左边再乘以下面的矩阵：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883440946965.png" alt="2017030114883440946965.png" /><figcaption>2017030114883440946965.png<figcaption></figure><br />
关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。<br />
所以它实际上就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834415832436.png" alt="20170301148834415832436.png" /><figcaption>20170301148834415832436.png<figcaption></figure><br />
出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。</p>
<h3><a id="%E6%97%8B%E8%BD%AC%E5%9B%B4%E7%BB%95%E5%9D%90%E6%A0%87%E5%8E%9F%E7%82%B9%E6%97%8B%E8%BD%AC%EF%BC%8C%E5%9C%A8%E5%8A%A0%E4%B8%8A%E4%B8%A4%E6%AC%A1%E5%B9%B3%E7%A7%BB%EF%BC%8C%E6%95%88%E6%9E%9C%E5%90%8C2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>旋转(围绕坐标原点旋转，在加上两次平移，效果同2)</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834419441235.png" alt="20170301148834419441235.png" /><figcaption>20170301148834419441235.png<figcaption></figure><br />
根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道：<br />
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br />
等价于<br />
<code>matrix.setRotate(45f);</code><br />
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br />
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br />
其中matrix.setRotate(45f)对应的矩阵是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834424050901.png" alt="20170301148834424050901.png" /><figcaption>20170301148834424050901.png<figcaption></figure></p>
<p>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight()/ 2f)对应的矩阵是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834425298280.png" alt="20170301148834425298280.png" /><figcaption>20170301148834425298280.png<figcaption></figure></p>
<p>由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。</p>
<p><code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f)</code>对应的矩阵是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834426293354.png" alt="20170301148834426293354.png" /><figcaption>20170301148834426293354.png<figcaption></figure><br />
这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。</p>
<p>所以综合起来，</p>
<p><code>matrix.setRotate(45f);</code><br />
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br />
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br />
对应的矩阵就是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834427273695.png" alt="20170301148834427273695.png" /><figcaption>20170301148834427273695.png<figcaption></figure><br />
这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834428250094.png" alt="20170301148834428250094.png" /><figcaption>20170301148834428250094.png<figcaption></figure><br />
因此，此处变换后的图像和2中变换后的图像时一样的。</p>
<h3><a id="%E7%BC%A9%E6%94%BE%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>缩放变换</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834429635851.png" alt="20170301148834429635851.png" /><figcaption>20170301148834429635851.png<figcaption></figure><br />
程序所输出的两个矩阵分别是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443077762.png" alt="2017030114883443077762.png" /><figcaption>2017030114883443077762.png<figcaption></figure><br />
其中第二个矩阵，其实是下面两个矩阵相乘的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834431597151.png" alt="20170301148834431597151.png" /><figcaption>20170301148834431597151.png<figcaption></figure><br />
大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。</p>
<h3><a id="%E9%94%99%E5%88%87%E5%8F%98%E6%8D%A2%E6%B0%B4%E5%B9%B3%E9%94%99%E5%88%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>错切变换(水平错切)</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443394822.png" alt="2017030114883443394822.png" /><figcaption>2017030114883443394822.png<figcaption></figure><br />
代码所输出的两个矩阵分别是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834434942666.png" alt="20170301148834434942666.png" /><figcaption>20170301148834434942666.png<figcaption></figure><br />
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443583409.png" alt="2017030114883443583409.png" /><figcaption>2017030114883443583409.png<figcaption></figure><br />
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。</p>
<h3><a id="%E9%94%99%E5%88%87%E5%8F%98%E6%8D%A2%E5%9E%82%E7%9B%B4%E9%94%99%E5%88%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>错切变换(垂直错切)</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834436740060.png" alt="20170301148834436740060.png" /><figcaption>20170301148834436740060.png<figcaption></figure></p>
<p>代码所输出的两个矩阵分别是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834438464295.png" alt="20170301148834438464295.png" /><figcaption>20170301148834438464295.png<figcaption></figure><br />
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834439581151.png" alt="20170301148834439581151.png" /><figcaption>20170301148834439581151.png<figcaption></figure><br />
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。</p>
<h3><a id="%E9%94%99%E5%88%87%E5%8F%98%E6%8D%A2%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E9%94%99%E5%88%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>错切变换(水平+垂直错切)</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834440579717.png" alt="20170301148834440579717.png" /><figcaption>20170301148834440579717.png<figcaption></figure><br />
代码所输出的两个矩阵分别是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834441593278.png" alt="20170301148834441593278.png" /><figcaption>20170301148834441593278.png<figcaption></figure><br />
其中，后者是下面两个矩阵相乘的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883444261979.png" alt="2017030114883444261979.png" /><figcaption>2017030114883444261979.png<figcaption></figure><br />
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。</p>
<h3><a id="%E5%AF%B9%E7%A7%B0%E5%8F%98%E6%8D%A2%E6%B0%B4%E5%B9%B3%E5%AF%B9%E7%A7%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对称变换(水平对称)</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834443981714.png" alt="20170301148834443981714.png" /><figcaption>20170301148834443981714.png<figcaption></figure></p>
<p>代码所输出的两个各矩阵分别是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883444616294.png" alt="2017030114883444616294.png" /><figcaption>2017030114883444616294.png<figcaption></figure><br />
其中，后者是下面两个矩阵相乘的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834447285645.png" alt="20170301148834447285645.png" /><figcaption>20170301148834447285645.png<figcaption></figure><br />
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。</p>
<h3><a id="%E5%AF%B9%E7%A7%B0%E5%8F%98%E6%8D%A2%E5%9E%82%E7%9B%B4%E5%AF%B9%E7%A7%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对称变换(垂直对称)</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834448061705.png" alt="20170301148834448061705.png" /><figcaption>20170301148834448061705.png<figcaption></figure></p>
<p>代码所输出的两个矩阵分别是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834449886306.png" alt="20170301148834449886306.png" /><figcaption>20170301148834449886306.png<figcaption></figure><br />
其中，后者是下面两个矩阵相乘的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834450718549.png" alt="20170301148834450718549.png" /><figcaption>20170301148834450718549.png<figcaption></figure><br />
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。</p>
<h3><a id="%E5%AF%B9%E7%A7%B0%E5%8F%98%E6%8D%A2%E5%AF%B9%E7%A7%B0%E8%BD%B4%E4%B8%BA%E7%9B%B4%E7%BA%BFy-x" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对称变换(对称轴为直线y = x)</h3>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834451545673.png" alt="20170301148834451545673.png" /><figcaption>20170301148834451545673.png<figcaption></figure><br />
代码所输出的两个矩阵分别是：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834452594988.png" alt="20170301148834452594988.png" /><figcaption>20170301148834452594988.png<figcaption></figure><br />
其中，后者是下面两个矩阵相乘的结果：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834453180954.png" alt="20170301148834453180954.png" /><figcaption>20170301148834453180954.png<figcaption></figure><br />
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。</p>
<h3><a id="%E5%85%B3%E4%BA%8E%E5%85%88%E4%B9%98%E5%92%8C%E5%90%8E%E4%B9%98%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>关于先乘和后乘的问题</h3>
<p>由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834454434026.png" alt="20170301148834454434026.png" /><figcaption>20170301148834454434026.png<figcaption></figure><br />
越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。</p>
<p>当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate(\(\theta\))，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。</p>
<h2><a id="%E8%BF%9B%E9%98%B6%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>进阶方法解析</h2>
<p>上面的基本方法中，有关于变换的set方法都可以带来不同的效果，但是每个set都会把上个效果清除掉，例如依次调用了setSkew,setTranslate，那么最终只有setTranslate会起作用，那么如何才和将两种效果复合呢。Matrix给我们提供了很多方法。但是主要都是2类：<br />
preXXXX:以pre开头，例如preTranslate<br />
postXXXX:以post开头，例如postScale<br />
他们分别代表了前乘，和后乘。看一段代码：</p>
<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
matrix.setTranslate(100, 1000);
matrix.preScale(0.5f, 0.5f);
</code></pre>
<p>这里matrix前乘了一个scale矩阵，换算成数学式如下：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017092315061645158599.png" alt="2017092315061645158599.png" /><figcaption>2017092315061645158599.png<figcaption></figure></p>
<p>从上面可以看出，最终得出的matrix既包含了缩放信息也有平移信息。<br />
后乘自然就是matrix在后面，而缩放矩阵在前面，由于矩阵前后乘并不等价，也就导致了他们的效果不同。我们来看看后乘的结果：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616454160642.png" alt="20170923150616454160642.png" /><figcaption>20170923150616454160642.png<figcaption></figure></p>
<p>可以看到，结果跟上面不同，并且这也不是我们想要的结果，这里缩放没有更改，但是平移被减半了，换句话说，平移的距离也被缩放了。所以需要注意前后乘法的关系。<br />
来看看他们对应的效果图：<br />
<strong>前乘：</strong></p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616460519787.png" alt="20170923150616460519787.png" /><figcaption>20170923150616460519787.png<figcaption></figure></p>
<p><strong>后乘：</strong></p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616463626763.png" alt="20170923150616463626763.png" /><figcaption>20170923150616463626763.png<figcaption></figure></p>
<p>可以明显看到，后乘的平移距离受了影响。<br />
了解清除了前后乘的意义，在使用的过程中，多个效果的叠加时，一样要注意，否则效果达不到预期。</p>
<h2><a id="%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他方法解析</h2>
<p>matrix除了上面的方法外，还有一些其他的方法，这里依次解析</p>
<h3><a id="setrecttorect" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setRectToRect</h3>
<p><code>public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf)</code>将rect变换成rect，上面的rectStaysRect已经说过，要保持rect只能做缩放平移和选择90度的倍数，那么这里其实也是一样，只是这几种变化，这里通过stf参数来控制。<br />
<code>ScaleToFit</code> 有如下四个值：<br />
<code>FILL</code>: 可能会变换矩形的长宽比，保证变换和目标矩阵长宽一致。<br />
<code>START</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。左上对齐。<br />
<code>CENTER</code>: 保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。<br />
<code>END</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。右下对齐。<br />
这里使用谷歌的api demo的图片作为例子：<br />
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616472114007.png" alt="20170923150616472114007.png" /><figcaption>20170923150616472114007.png<figcaption></figure></p>
<h3><a id="setpolytopoly" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>setPolyToPoly</h3>
<p><code>public boolean setPolyToPoly(float[] src, int srcIndex,float[] dst, int dstIndex,int pointCount)</code>通过指定的0-4个点，原始坐标以及变化后的坐标，来得到一个变换矩阵。如果指定0个点则没有效果。<br />
下面通过例子分别说明1到4个点的可以达到的效果：</p>
<h4><a id="1%E4%B8%AA%E7%82%B9%EF%BC%8C%E5%B9%B3%E7%A7%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1个点，平移</h4>
<p>只指定一个点，可以达到平移效果：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616478770235.png" alt="20170923150616478770235.png" /><figcaption>20170923150616478770235.png<figcaption></figure></p>
<p>代码如下：</p>
<pre class="line-numbers"><code class="language-java">float[] src = {0, 0};
int DX = 300;
float[] dst = {0 + DX, 0 + DX};
matrix.setPolyToPoly(src, 0, dst, 0, 1);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>
<h4><a id="2%E4%B8%AA%E7%82%B9%EF%BC%8C%E6%97%8B%E8%BD%AC%E6%88%96%E8%80%85%E7%BC%A9%E6%94%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2个点，旋转或者缩放</h4>
<p>两个点，可以达到旋转效果或者缩放效果，缩放比较简单，这里我们来看旋转效果，一个点指定中心，一点指出旋转的效果</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616485313647.png" alt="20170923150616485313647.png" /><figcaption>20170923150616485313647.png<figcaption></figure></p>
<p>代码如下</p>
<pre class="line-numbers"><code class="language-java">int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {bw / 2, bh / 2, bw, 0};
float[] dst = {bw / 2, bh / 2, bw / 2 + bh / 2, bh / 2 + bw / 2};
matrix.setPolyToPoly(src, 0, dst, 0, 2);
canvas.drawBitmap(bitmap, matrix, paint);123456123456
</code></pre>
<p>图片的中心点作为旋转的中心，前后不变，右上角变化到了下方，所以导致图片旋转了90度。</p>
<h4><a id="3%E4%B8%AA%E7%82%B9%EF%BC%8C%E9%94%99%E5%88%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3个点，错切</h4>
<p>使用3个点，可以产生错切效果，指定3个顶点，一个固定，另外两个移动。<br />
看图：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616492474600.png" alt="20170923150616492474600.png" /><figcaption>20170923150616492474600.png<figcaption></figure></p>
<p>代码如下：</p>
<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0,0, 0, bh,bw,bh};
float[] dst = {0, 0, 200, bh, bw + 200, bh};
matrix.setPolyToPoly(src, 0, dst, 0, 3);
canvas.drawBitmap(bitmap, matrix, paint);12345671234567
</code></pre>
<h4><a id="4%E4%B8%AA%E7%82%B9%EF%BC%8C%E9%80%8F%E8%A7%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>4个点，透视</h4>
<p>透视就是观察的角度变化了。导致投射到平面上的二维图像变化了。<br />
我们看下面的例子，更容易理解：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616497319034.png" alt="20170923150616497319034.png" /><figcaption>20170923150616497319034.png<figcaption></figure></p>
<p>图片看起来好像倾斜了，实现特别简单：</p>
<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0, 0, 0, bh, bw, bh, bw, 0};
int DX = 100;
float[] dst = {0 + DX, 0, 0, bh, bw, bh, bw - DX, 0};
matrix.setPolyToPoly(src, 0, dst, 0, 4);
canvas.drawBitmap(bitmap, matrix, paint);1234567812345678
</code></pre>
<p>可以看到，只是把左右两个顶点往里面收拢了，这样就得出了一个有3d效果的透视图。</p>
<h3><a id="invert" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>invert</h3>
<p><code>public boolean invert(Matrix inverse)</code>反转当前矩阵，如果能反转就返回true并将反转后的值写入inverse，否则返回false。当前矩阵*inverse=单位矩阵。<br />
反转前后有什么效果，我们来看看示例：</p>
<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616503373152.png" alt="20170923150616503373152.png" /><figcaption>20170923150616503373152.png<figcaption></figure></p>
<p>可以看到，反转之后，其实是对效果的一种反转。</p>
<h3><a id="mappoints" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mapPoints</h3>
<pre class="line-numbers"><code class="language-java">public void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex,int pointCount)
public void mapPoints(float[] dst, float[] src)
public void mapPoints(float[] pts)
</code></pre>
<p>映射点的值到指定的数组中，这个方法可以在矩阵变换以后，给出指定点的值。</p>
<ul>
<li>dst：指定写入的数组</li>
<li>dstIndex：写入的起始索引，x，y两个坐标算作一对，索引的单位是对，也就是经过两个值才加1</li>
<li>src：指定要计算的点</li>
<li>srcIndex：要计算的点的索引</li>
<li>pointCount：需要计算的点的个数，每个点有两个值，x和y。</li>
</ul>
<h3><a id="mapvectors" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mapVectors</h3>
<pre class="line-numbers"><code class="language-java">public void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex,int vectorCount)
public void mapVectors(float[] dst, float[] src)
public void mapVectors(float[] vecs)

</code></pre>
<p>与上面的mapPoionts基本类似，这里是将一个矩阵作用于一个向量，由于向量的平移前后是相等的，所以这个方法不会对translate相关的方法产生反应，如果只是调用了translate相关的方法，那么得到的值和原本的一致。</p>
<h3><a id="maprect" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mapRect</h3>
<pre class="line-numbers"><code class="language-java">public boolean mapRect(RectF dst, RectF src)
public boolean mapRect(RectF rect)
</code></pre>
<p>返回值即是调用的rectStaysRect()，这个方法前面有讲过，这里把src中指定的矩形的左上角和右下角的两个点的坐标，写入dst中。</p>
<h3><a id="mapradius" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>mapRadius</h3>
<p><code>public float mapRadius(float radius)</code>返回一个圆圈半径的平均值，将matrix作用于一个指定radius半径的圆，随后返回的平均半径。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502771839.html">
                
                  <h1>Android MVP模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>MVP 这种模式出现已经很久了，在网上有些关于 MVP 开源代码2014年就有了。近期由于面试都有问这方面的问题，所以来了解一下。网上关于 MVP 的资料其实也不少，通常都要把 MVP 和 MVC 做一下比较，MVC通常一般都会应用，这篇文章就来学习下MVP模式。</p>
<h2><a id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFmvp%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、什么是MVP？</h2>
<p>随着UI创建技术的功能日益增强，UI层也履行着越来越多的职责。为了更好地细分视图(View)与模型(Model)的功能，让View专注于处理数据的可视化以及与用户的交互，同时让Model只关系数据的处理，基于MVC概念的MVP(Model-View-Presenter)模式应运而生。<br />
MVP 是 Model、Presenter、View 的缩写，三个部分的关系如下图所示。<br />
<figure><img src="media/15626502771839/20170227148819849456583.png" alt="20170227148819849456583" /><figcaption>20170227148819849456583<figcaption></figure></p>
<p>在 Android 项目中，负责界面展示的模块（所有的 Activitiy 、Fragment以及 View 的子类）都可以划分到 View 这个层次，所有的业务逻辑处理（请求网络数据、数据库读取等）可以划分到 Model 这个层次，为了使得 View 和 Model 之间松耦合，用 Presenter 帮助解耦。所以可以猜测，在具体实现中 Presenter 类肯定要持有 View 和 Model 的引用。现在来说一下，上图中三个箭头的意思。流程是这样子的，从左到右看，比如我们刚进入一个 Activity，那么这个 Activity 做为 View 层，肯定需要通知 Presenter 加载数据，而Presenter会继续调用Model层加载数据，等Model加载完毕后，回调给 Presenter，Presenter 持有View引用，再通知View更新界面。</p>
<h3><a id="mvp%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A7%92%E8%89%B2%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MVP模式的三个角色的作用：</h3>
<ul>
<li>Presenter-中介<br />
主演沟通View和Model的桥梁，他从Model获取数据后返回给View层，是的View层和Model层之间没有耦合，从而奖业务逻辑从View层抽离。</li>
<li>Model-房主<br />
Model主要提供数据的存取、检索、操纵功能，Presenter需要通过Model层存储、获取数据，Model层就想是一个仓库。</li>
<li>View-用户<br />
负责绘制UI元素、与用户进行交互(在Android中体现为Activity)。View通常是指Activity、Fragment或者某个View控件。它含有一个Presenter成员变量，同时它需要实现一个逻辑接口，奖View上的操作转交割Presenter进行实现，最后Presenter调用View逻辑接口将结果返回给View元素。</li>
<li>View interface<br />
需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;</li>
</ul>
<h3><a id="%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8mvp%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为什么使用MVP模式</h3>
<p>在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由Presenter处理）.<br />
另外，回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明了什么？说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。</p>
<h3><a id="mvp%E4%B8%8Emvc%E7%9A%84%E5%BC%82%E5%90%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MVP与MVC的异同</h3>
<p>MVC模式与MVP模式都作为用来分离UI层与业务层的一种开发模式被应用了很多年。在我们选择一种开发模式时，首先需要了解一下这种模式的利弊：<br />
无论MVC或是MVP模式都不可避免地存在一个弊端：<br />
<strong>额外的代码复杂度及学习成本。</strong><br />
这就导致了这两种开发模式也许并不是很小型应用。<br />
但比起他们的优点，这点弊端基本可以忽略了：</p>
<ul>
<li>(1)降低耦合度</li>
<li>(2)模块职责划分明显</li>
<li>(3)利于测试驱动开发</li>
<li>(4)代码复用</li>
<li>(5)隐藏数据</li>
<li>(6)代码灵活性</li>
</ul>
<h4><a id="mvp%E6%A8%A1%E5%BC%8F%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MVP模式：</h4>
<ul>
<li>View不直接与Model交互，而是通过与Presenter交互来与Model间接交互</li>
<li>Presenter与View的交互是通过接口来进行的，更有利于添加单元测试</li>
<li>通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑</li>
</ul>
<h4><a id="mvc%E6%A8%A1%E5%BC%8F%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MVC模式：</h4>
<ul>
<li>View可以与Model直接交互</li>
<li>Controller是基于行为的，并且可以被多个View共享</li>
<li>可以负责决定显示哪个View</li>
</ul>
<h2><a id="%E4%BA%8C%E3%80%81mvp%E7%9A%84%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、MVP的效果</h2>
<p>现在我们来实现这样一个Android上的Demo(如图)：可以从EditText读取用户信息并存取，也可以根据ID来从后台读出用户信息并显示。<br />
<figure><img src="media/15626502771839/20170227148819875942251.png" alt="20170227148819875942251" /><figcaption>20170227148819875942251<figcaption></figure></p>
<p>页面布局很简单，就不介绍了。下面根据MVP原则来进行编码：<br />
先来看看java文件的目录结构：<br />
<figure><img src="media/15626502771839/20170227148819877439872.png" alt="20170227148819877439872" /><figcaption>20170227148819877439872<figcaption></figure></p>
<p>可以发现，Presenter与Model、View都是通过接口来进行交互的，既降低耦合也方便进行单元测试。</p>
<ul>
<li>(1)首先我们需要一个UserBean，用来保存用户信息</li>
</ul>
<pre class="line-numbers"><code class="language-java">public class UserBean {  
	private String mFirstName ;  
	private String mLastName ;  
	public UserBean (String firstName, String lastName) {  
		this.mFirstName = firstName;  
		this.mLastName = lastName;  
	}  
	public String getFirstName() {  
		return mFirstName ;  
	}  
	public String getLastName() {  
		return mLastName ;  
	}
}
</code></pre>
<ul>
<li>(2)再来看看View接口：<br />
根据需求可知，View可以对ID、FirstName、LastName这三个EditText进行读操作，对FirstName和LastName进行写操作，由此定义IUserView接口：</li>
</ul>
<pre class="line-numbers"><code class="language-java">public interface IUserView {  
       int getID();  
       String getFristName();  
       String getLastName();  
       void setFirstName (String firstName);  
       void setLastName (String lastName);  
}
</code></pre>
<ul>
<li>(3)Model接口：<br />
同样，Model也需要对这三个字段进行读写操作，并存储在某个载体内(这不是我们所关心的，可以存在内存、文件、数据库或者远程服务器，但对于Presenter及View无影响),定义IUserModel接口：</li>
</ul>
<pre class="line-numbers"><code class="language-java">public interface IUserModel {  
       void setID (int id);  
       void setFirstName (String firstName);  
       void setLastName (String lastName);  
       int getID();  
       UserBean load (int id);//通过id读取user信息,返回一个UserBean  
}
</code></pre>
<ul>
<li>(4)Presenter:<br />
至此，Presenter就能通过接口与View及Model进行交互了：</li>
</ul>
<pre class="line-numbers"><code class="language-java">public class UserPresenter {  
       private IUserView mUserView ;  
       private IUserModel mUserModel ;  
  
       public UserPresenter (IUserView view) {  
             mUserView = view;  
             mUserModel = new UserModel ();  
       }  
  
       public void saveUser( int id , String firstName , String lastName) {  
             mUserModel .setID (id );  
             mUserModel .setFirstName (firstName );  
             mUserModel .setLastName (lastName );  
       }  
  
       public void loadUser( int id ) {  
             UserBean user = mUserModel .load (id );  
             mUserrView .setFirstName (user .getFirstName ());//通过调用IUserView的方法来更新显示  
             mUserView .setLastName (user .getLastName ());  
       }  
}
</code></pre>
<ul>
<li>(5)UserActivity:<br />
UserActivity实现了IUserView及View.OnClickListener接口，同时有一个UserPresenter成员变量：</li>
</ul>
<pre class="line-numbers"><code class="language-java">public class UserActivity extends Activity implements OnClickListener,  
             IUserView {  
  
       private EditText mFirstNameEditText , mLastNameEditText , mIdEditText ;  
       private Button mSaveButton , mLoadButton ;  
       private UserPresenter mUserPresenter ; 
</code></pre>
<p>重写了OnClick方法：</p>
<pre class="line-numbers"><code class="language-java">@Override  
       public void onClick(View v) {  
             // TODO Auto-generated method stub  
             switch ( v. getId()) {  
             case R .id .saveButton :  
                   mUserPresenter .saveUser (getID (), getFristName (),  
                               getLastName ());  
                   break ;  
             case R .id .loadButton :  
                   mUserPresenter .loadUser (getID ());  
                   break ;  
             default :  
                   break ;  
             }  
       }
</code></pre>
<p>可以看到，View只负责处理与用户进行交互，并把数据相关的逻辑操作都扔给了Presenter去做。而Presenter调用Model处理完数据之后，再通过IUserView更新View显示的信息。</p>
<h2><a id="%E4%B8%89%E3%80%81mvp%E7%9A%84android%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、MVP的Android伪代码实现</h2>
<ul>
<li>
<p>首先需要一个Presenter，作为View和Model的中间人<br />
<figure><img src="media/15626502771839/20170227148819813736752.png" alt="20170227148819813736752" /><figcaption>20170227148819813736752<figcaption></figure></p>
</li>
<li>
<p>然后你还需要一个View以及ViewImpl接口<br />
<figure><img src="media/15626502771839/2017022714881981564410.png" alt="2017022714881981564410" /><figcaption>2017022714881981564410<figcaption></figure></p>
</li>
</ul>
<p><figure><img src="media/15626502771839/20170227148819816221120.png" alt="20170227148819816221120" /><figcaption>20170227148819816221120<figcaption></figure></p>
<ul>
<li>最后你还需要Model一个ModelImpl接口<br />
<figure><img src="media/15626502771839/20170227148819817269813.png" alt="20170227148819817269813" /><figcaption>20170227148819817269813<figcaption></figure></li>
</ul>
<h2><a id="%E5%9B%9B%E3%80%81%E4%B8%8D%E5%BF%85%E7%BA%A0%E7%BB%93%E6%98%AFmvc%E8%BF%98%E6%98%AFmvp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、不必纠结是MVC还是MVP</h2>
<blockquote>
<p>MVC和MVP的最终目的就是要数据和UI分离，互相不影响。那么如何能不必纠结而做到呢？？你听说过面向对象吗？听过再听听我的理解~</p>
</blockquote>
<ul>
<li>面向对象<br />
封装、多态，继承。老师好像也都是这么教的，那么到底说明是多态封装继承呢？</li>
<li>封装<br />
封装就是将用户不想看到的东西封装起来，可以用到面向对象中的 Private<br />
属性，将用户不想看到的内容写在这里面。比如收音机上的播放功能，用户不用知道收益及如何播放，它只需要知道摁下这个键能播放即可。</li>
<li>多态<br />
多态就是一个对象的多种表现形态，主要表现为：行为多态和状态多态。<br />
行为多态就好比一个父亲有多个孩子，每个孩子都不一样，但是都是同一个父亲；状态多态就好比每个孩子在一天中有好多个状态变现，有吃饭，学习，睡觉。</li>
<li>继承？不！我想说的是对象！<br />
我的一个朋友告诉我继承其实是对面向对象的最大误解。继承我们可以理解成一个对象他有多个小对象组成；比如人这个对象是由手脚，脑袋...等其它小对象组成。因此继承我们可以不去记住，我们只要对每个对象有深刻的认识即可把对象描述清楚！</li>
</ul>
<blockquote>
<p>那么MVC、MVP与面向对象有什么关系呢？？</p>
</blockquote>
<p>首先MVC和MVP都是要求数据和UI之间互不影响，那么面向对象不就是吗！？</p>
<ul>
<li>
<p>面向对象View?<br />
对象也就是我们说的用户也就是MC或者MVP中View，用户需要什么我们就展示给其什么，不需要的我们将其封装起来提供一个方法给你调用即可，这是不是和MVC或者MVP中很像！</p>
</li>
<li>
<p>面向对象Model?<br />
同时面向对象也是需要将对象的行为细分，比如人可以跑，可以游泳...这是不是和MVC中的Model一样，需要处理用户不同的操作。</p>
</li>
<li>
<p>面向对象Controller?<br />
最后面向对象也是需要一个状态去控制的，比如人的大脑。通过大脑去协调手和脚的平衡。</p>
</li>
</ul>
<h2><a id="%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、内存泄露问题</h2>
<p>由上可见，Presenter中持有View接口对象，这个接口对象实际为MainActivity.this，Modle中也同时拥有Presenter对象实例，当MainActivity要销毁时，Presenter中有Modle在获取数据，那么问题来了，这个Activity还能正常销毁吗？</p>
<p><strong>答案是不能！</strong></p>
<p>当Modle在获取数据时，不做处理，它就一直持有Presenter对象，而Presenter对象又持有Activity对象，这条GC链不剪断，Activity就无法被完整回收。<br />
换句话说：Presenter不销毁，Activity就无法正常被回收。</p>
<p>解决MVP的内存泄露</p>
<p>Presenter在Activity的onDestroy方法回调时执行资源释放操作，或者在Presenter引用View对象时使用更加容易回收的软引用，弱应用。<br />
比如示例代码：<br />
<strong>Activity</strong></p>
<pre class="line-numbers"><code class="language-java">@Override
    public void onDestroy() {
        super.onDestroy();
        mPresenter.destroy();
        mPresenter = null;
    }
</code></pre>
<p><strong>Presenter</strong></p>
<pre class="line-numbers"><code class="language-java">public void destroy() {
    view = null;
    if(modle != null) {
        modle.cancleTasks();
        modle = null;
    }
}
</code></pre>
<p><strong>Modle</strong></p>
<pre class="line-numbers"><code class="language-java">public void cancleTasks() {
    // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api
}
</code></pre>
<p>个人总结</p>
<p>因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！</p>
<h2><a id="%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>六、总结</h2>
<p>最后重新梳理一下 MVP 的编写方式。</p>
<ul>
<li>1、 根据项目需求，写一个 XXView 接口。然后让对应的 Activity/Fragment 实现这个接口。View 层基本搞定！</li>
<li>2、编写 Model 层，主要就是网络数据请求了或者其他什么耗时操作，实现方式尽情发挥你的想象，但是最后一定需要用 Presenter 层定义的接口，回调给 Presenter 通知 View 层 更新数据。</li>
<li>3、编写 Presenter 层，Presenter 层需要持有 View 层和 Model层的引用，并且实现 Presenter 层定义的回调接口。在回调接口中调用 View 层的代码 进行界面更新，最重要的是，有一个调用通过Model层的方法，在此方法中，调用 Model 层请求数据。</li>
<li>4、回到View 层的Activity ，调用 Presenter 层获取数据。到此完成。</li>
</ul>
<p><strong>因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！</strong><br />
**备注：**为了遵守面向接口编程的原则，做了一下接口的抽取。如Presenter 中 实现了 JokePresenter 接口，Model 层中实现了 JokeModel 接口。好了，如果在阅读中，发现了有错误的地方，还望指正。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502772268.html">
                
                  <h1>Android 快速开发框架</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E4%B8%80%E3%80%81afinal" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、Afinal</h2>
<ul>
<li><strong>官方介绍</strong>：</li>
</ul>
<p>Afinal是一个Android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对Android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。详情请通过以下网址查看。</p>
<p>Afinal 是一个android的sqlite orm 和 ioc 框架。同时封装了android中的http框架，使其更加简单易用；</p>
<p>使用finalBitmap，无需考虑bitmap在android中加载的时候oom的问题和快速滑动的时候图片加载位置错位等问题。</p>
<p>Afinal的宗旨是简洁，快速。约定大于配置的方式。尽量一行代码完成所有事情。</p>
<ul>
<li>
<p><strong>项目地址</strong>：<a href="https://github.com/yangfuhai/afinal">https://github.com/yangfuhai/afinal</a></p>
</li>
<li>
<p><strong>功能</strong>：</p>
</li>
</ul>
<p>一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。</p>
<p>优点：功能比较全面，文档完善，代码效率比较高。</p>
<p>缺点：没有项目demo，框架的时间比较久，代码冗余比较多（这也是无可避免的），文档比较老跟不上代码更新进度。</p>
<p>（这个评价是其他高人评的，他自己也有写了框架。我个人觉得以前Afinal算是经典了 用的人多）。</p>
<h2><a id="%E4%BA%8C%E3%80%81xutils" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、xUtils</h2>
<ul>
<li><strong>Git地址</strong>：<a href="https://github.com/wyouflf/xUtils">https://github.com/wyouflf/xUtils</a></li>
</ul>
<p>xUtils：可以说是Afinal的升级版。</p>
<p>xUtils 包含了很多实用的android工具。</p>
<p>xUtils 支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响...</p>
<p>xUitls 最低兼容android 2.2 (api level 8)</p>
<h2><a id="%E4%B8%89%E3%80%81thinkandroid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、ThinkAndroid</h2>
<ul>
<li>
<p><strong>项目地址</strong>：<a href="https://github.com/white-cat/ThinkAndroid">https://github.com/white-cat/ThinkAndroid</a></p>
</li>
<li>
<p><strong>官方介绍</strong>：</p>
</li>
</ul>
<p>ThinkAndroid是一个免费的开源的、简易的、遵循Apache2开源协议发布的Android开发框架，其开发宗旨是简单、快速的进行Android应用程序的开发，包含Android mvc、简易sqlite orm、ioc模块、封装Android httpclitent的http模块,具有快速构建文件缓存功能，无需考虑缓存文件的格式，都可以非常轻松的实现缓存，它还基于文件缓存模块实现了图片缓存功能，在android中加载的图片的时候，对oom的问题，和对加载图片错位的问题都轻易解决。他还包括了一个手机开发中经常应用的实用工具类，如日志管理，配置文件管理，android下载器模块，网络切换检测等等工具</p>
<ul>
<li>
<p><strong>优点</strong>：功能看起来比较完善。个人觉得名字起的好。</p>
</li>
<li>
<p><strong>缺点</strong>：从2013年就停止维护了，没有项目文档。</p>
</li>
</ul>
<h2><a id="%E5%9B%9B%E3%80%81loonandroid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、LoonAndroid</h2>
<ul>
<li><strong>官方介绍</strong>：</li>
</ul>
<p>如果你想看ui方面的东西，这里没有，想要看牛逼的效果这里也没有。这只是纯实现功能的框架，它的目标是节省代码量，降低耦合，让代码层次看起来更清晰。整个框架一部分是网上的，一部分是我改的，为了适应我的编码习惯，还有一部分像orm完全是网上的组件。在此感谢那些朋友们。 整个框架式的初衷是为了偷懒，之前都是一个功能一个jar，做项目的时候拉进去，这样对于我来说依然还是比较麻烦。最后就导致我把所有的jar做成了一个工具集合包。 有很多框架都含有这个工具集合里的功能，这些不一定都好用，因为这是根据我个人使用喜欢来实现的，如果你们有自己的想法，可以自己把架包解压了以后，源码拉出来改动下。 目前很多框架都用到了注解，除了androidannotations没有入侵我们应用的代码以外，其他的基本上都有，要么是必须继承框架里面的activity,要么是必须在activity的oncreat里面调用某个方法。 整个框架式不同于androidannotations，Roboguice等ioc框架，这是一个类似spring的实现方式。在整应用的生命周期中找到切入点，然后对activity的生命周期进行拦截，然后插入自己的功能。</p>
<ul>
<li>
<p><strong>开源地址</strong>：<a href="https://github.com/gdpancheng/LoonAndroid">https://github.com/gdpancheng/LoonAndroid</a></p>
</li>
<li>
<p><strong>功能</strong>：</p>
<ol>
<li>自动注入框架（只需要继承框架内的application既可）</li>
<li>图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）</li>
<li>网络请求模块（继承了基本上现在所有的http请求）</li>
<li>eventbus（集成一个开源的框架）</li>
<li>验证框架（集成开源框架）</li>
<li>json解析（支持解析成集合或者对象）</li>
<li>数据库（不知道是哪位写的 忘记了）</li>
<li>多线程断点下载（自动判断是否支持多线程，判断是否是重定向）</li>
<li>自动更新模块</li>
<li>一系列工具类</li>
</ol>
</li>
<li>
<p><strong>优点</strong>：功能多</p>
</li>
<li>
<p><strong>缺点</strong>：文档方面</p>
</li>
</ul>
<h2><a id="%E4%BA%94%E3%80%81kjframeforandroid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五、KJFrameForAndroid</h2>
<ul>
<li>
<p><strong>项目地址</strong>：<a href="https://github.com/kymjs/KJFrameForAndroid">https://github.com/kymjs/KJFrameForAndroid</a></p>
</li>
<li>
<p><strong>官方介绍</strong>：</p>
</li>
</ul>
<p>KJFrameForAndroid 又叫KJLibrary，是一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用；<br />
KJFrameForAndroid的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。我们提倡用最少的代码，完成最多的操作，用最高的效率，完成最复杂的功能。</p>
<ul>
<li><strong>功能</strong>：</li>
</ul>
<p>一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用； KJFrameForAndroid开发框架的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。总共分为五大模块：UILibrary，UtilsLibrary，HttpLibrary，BitmapLibrary，DBLibrary。</p>
<ul>
<li>
<p><strong>优点</strong>：功能比较全面，代码效率很高，文档完善，有项目demo，出来的比较晚借鉴了很多大型框架经验。</p>
</li>
<li>
<p><strong>缺点</strong>：项目文档是html页面，查看起来很不方便，项目交流平台没多少人说话（难道大神都是不说话的？）</p>
</li>
</ul>
<p>（这两个评价是KJFrameForAndroid的作者对自己的评价，个人觉得作者是个天才。他的评价可能刚写完网上发布后写的。我在给他更新评价。因为现在已经过去了几个月一直在时不时更新。功能很全，项目文档也很全面，而且代码里注释最多 这方面这个很难得。交流平台人很多挺热闹，作者希望更热闹这样框架越来越完善。对于初学者希望看到Demo更完善）</p>
<h2><a id="%E5%85%AD%E3%80%81dhroid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>六、dhroid</h2>
<ul>
<li><strong>官方介绍</strong>：</li>
</ul>
<p>dhroid 是基于android 平台, 极速开发框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展.使你更快,更好的开发商业级别应用</p>
<ul>
<li>
<p><strong>开源地址</strong>: <a href="http://git.oschina.net/tengzhinei/dhroid">http://git.oschina.net/tengzhinei/dhroid</a></p>
</li>
<li>
<p><strong>功能</strong>：</p>
<ol>
<li>Ioc容器: (用过spring的都知道)视图注入,对象注入,接口注入,解决类依赖关系</li>
<li>Eventbus: android平台事件总线框架,独创延时事件,事件管理轻松</li>
<li>Dhnet: 网络http请求的解决方案,使用简单,减少代码,自带多种网络访问缓存策略</li>
<li>adapter模块: 数据绑定轻松,不用写多余的adapter,天生网络支持(一行代码搞定加载,刷新问题)</li>
<li>DhDb: android中sqlite的最轻量orm框架(增删改查轻松搞定)</li>
<li>Perference: android自带Perference 升级版,让你的Perference更强大,更方便</li>
</ol>
</li>
</ul>
<p>工具集合 JSONUtil(安全处理json),ViewUtil(数据绑定更快) ThreadWorker(异步任务工具)...</p>
<ul>
<li><strong>优点</strong>：功能全面，有demo，作者也是为公司开发的框架。</li>
<li><strong>缺点</strong>：文档方面现在不是很好，就eoe上的那些。</li>
</ul>
<h2><a id="%E4%B8%83%E3%80%81smartandroid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>七、SmartAndroid</h2>
<ul>
<li>
<p><strong>项目地址</strong>：<a href="http://www.aplesson.com/smartAndroid/demos">http://www.aplesson.com/smartAndroid/demos</a></p>
</li>
<li>
<p><strong>官方介绍</strong>：</p>
</li>
</ul>
<p>SmartAndroid是一套给 Android开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库以及简单的接口和逻辑结构，其目的是使开发人员更快速地进行项目开发。使用 SmartAndroid可以减少代码的编写量，并将你的精力投入到项目的创造性开发上。</p>
<ul>
<li><strong>功能</strong>：</li>
</ul>
<p>SmartAndroid 拥有全范围的类库，可以完成大多数通常需要的APP开发任务，包括： 异步网络操作相关所有功能、强大的图片处理操作、轻量级ORM数据库Sqlite库、zip操作 、动画特效、Html等解析采集、事件总线EventBus/Otto、Gson(Json)、AQuery、主流所有UI控件（例如：ActionbarSherlock，SlidingMenu，BottomView，Actionbar，DragListView等10多种UI库）等。</p>
<ul>
<li>
<p><strong>优点</strong>：功能非常全，超出你索要、文档完善（作者很全面，官方网站是web响应式网站，框架里功能有UI各种特效应该最全了，一直更新中）</p>
</li>
<li>
<p><strong>缺点</strong>：jar包大点？（功能多不可避免，不是问题），在线文档（随响应式的手机访问也方便，但是网速慢就不好了，页面打开不是很流畅）</p>
</li>
</ul>
<h2><a id="%E5%85%AB%E3%80%81andbase" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>八、andBase</h2>
<ul>
<li><strong>官方介绍</strong>：</li>
</ul>
<p>andbase是为Android开发者量身打造的一款开源类库产品</p>
<ul>
<li>
<p><strong>开源地址</strong>：<a href="https://code.jd.com/zhaoqp2010_m/andbase">https://code.jd.com/zhaoqp2010_m/andbase</a></p>
</li>
<li>
<p><strong>功能</strong>：</p>
<ol>
<li>andbase中包含了大量的开发常用手段。如网络下载，多线程与线程池的管理，数据库ORM，图片缓存管理，图片文件下载上传，Http请求工具，常用工具类（字符串，日期，文件处理，图片处理工具类等），能够使您的应用在团队开发中减少冗余代码，很大的提高了代码的维护性与开发高效性，能很好的规避由于开发疏忽而导致常犯的错误。</li>
<li>andbase封装了大量的常用控件。如list分页，下拉刷新，图片轮播，表格，多线程下载器，侧边栏，图片上传，轮子选择，图表，Tab滑动，日历选择器等。</li>
<li>强大的AbActivity，您没有理由不继承它。继承它你能够获得一个简单强大可设置的操作栏，以及一系列的简单调用，如弹出框，提示框，进度框，副操作栏等。</li>
<li>提供效率较高图片缓存管理策略，使内存大幅度节省，利用率提高，效率提高。程序中要管理大量的图片资源，andbase提供简单的方法，几步完成下载与显示，并支持缩放，裁剪，缓存功能。</li>
<li>封装了大量常见工具类。包括日期，字符，文件，图片等各种处理函数，多而全。</li>
<li>用andbase大量减少handler的使用，而采用回调函数，代码更整洁。handler会产生大量代码，并且不好维护，andbase对handler进行了封装。</li>
<li>简单轻量支持注解自动建表的ORM框架（支持一/多对多的关联操作）。写sql，建表，工作量大，andbase提供更傻瓜异步增删改查工具类。</li>
<li>异步请求http框架，网络请求标准化，支持文件上传下载，get，post，进度显示。包含了异步与http请求的工具类，实用。</li>
<li>热情的支持群体。</li>
</ol>
</li>
<li>
<p><strong>优点</strong>：功能很全，demo做的好 、API文档完善、接近完美</p>
</li>
<li>
<p><strong>缺点</strong>：希望文档更详细些。</p>
</li>
</ul>
<h2><a id="%E4%B9%9D%E3%80%81androidannotations" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>九、AndroidAnnotations</h2>
<ul>
<li>
<p><strong>项目地址</strong>：<a href="https://github.com/excilys/androidannotations">https://github.com/excilys/androidannotations</a></p>
</li>
<li>
<p><strong>功能</strong>：</p>
</li>
</ul>
<p>完全注解框架，一切皆为注解：声明控件，绑定控件，设置监听，setcontentview，长按事件，异步线程，全部通过注解实现。</p>
<ul>
<li>
<p><strong>优点</strong>：完全的注解，使开发起来更加便利，程序员写的代码也更少。</p>
</li>
<li>
<p><strong>缺点</strong>：文档是全英文的加上功能比较少没有具体研究，由于一切都是注解，感觉效率不高，不过根据官方介绍说并不是使用的反射加载，所以效率比一般注解高很多。</p>
</li>
</ul>
<h2><a id="%E5%8D%81%E3%80%81volley" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十、volley</h2>
<ul>
<li>
<p><strong>项目地址</strong>： <a href="https://github.com/smanikandan14/Volley-demo">https://github.com/smanikandan14/Volley-demo</a></p>
</li>
<li>
<p><strong>功能</strong>：Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮异步加载网络图片、网络数据</p>
</li>
<li>
<p><strong>优点</strong>：Google官方推荐，请看去年的开发者大会介绍。</p>
</li>
<li>
<p><strong>缺点</strong>：功能比较少，只有网络数据加载和网络图片加载</p>
</li>
</ul>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>以上的开发框架网上都可以下载源码，也有demo实例的。当然我没分析和对比框架的效率性能，但是都非常实用，其作者大部分是个人，都是些牛人或天才。你可以直接使用，也可以把有用跳出来用，至少有很多使用工具。如果有发现Bug，作者希望把bug交给他。</p>
<p>Afinal 和 xUtils简单实用但是demo和更新的问题。</p>
<p>KJFrameForAndroid 算是新出的，功能也多，效率也应该好，代码也注释多 用起来也很方便。</p>
<p>Dhroid 作者自己公司的框架，也可以直接请教。</p>
<p>SmartAndroid 强劲的框架功能俱全。</p>
<p>andBase 出来早各个方面算是完整的吧。</p>
<p>转自：<a href="http://blog.csdn.net/buddyuu/article/details/40503471">http://blog.csdn.net/buddyuu/article/details/40503471</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502772407.html">
                
                  <h1>Android StatusBar学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>一直以来，iOS 设备上状态栏背景色和图标文字颜色的灵活可变性始终受到设计人员的青睐，有意地恰当地融入到 App 的各种界面设计当中，更好地提升用户体验。</p>
<p>由于系统的限制，在老版本的安卓系统中，Android App 无法做到这些，产生一些设计上的遗憾。幸运的是，自**4.4 版本（API 19)**以后，Android 系统开始支持状态栏的定制，并被纳入 Android 设计规范当中，Android App 在设计上迈出了重要的一步。</p>
<h2><a id="%E2%80%9C%E6%B2%89%E6%B5%B8%E5%BC%8F%E7%8A%B6%E6%80%81%E6%A0%8F%E2%80%9Dvs%E2%80%9C%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F%E2%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>“沉浸式状态栏” VS “透明状态栏”</h2>
<p>一般来说，Android 默认的状态栏样式表现为黑底白字，如果我们应用的标题栏背景色也为黑色，那就能与状态栏很好地衔接在一起，体验极佳。反之，如果为其他的颜色，整个界面的呈现效果就会大打折扣。</p>
<p>幸运的是，Android 4.4 版本开始，系统提供了相应的 API，支持状态栏全透明化，界面 Content View 可以延伸到状态栏上，填充状态栏背景色。而在 Android 5.0 版本开始，系统在此基础上做了进一步优化和规范，能够实现动态改变状态栏背景色，在透明度上默认呈现为半透明化，可定制化程度更高。</p>
<p>在此基础上，最终要做到我们的应用呈现在 Android 各个系统版本上的效果如图所示：<br />
<figure><img src="media/15626502772407/20170223148785204419031.png" alt="20170223148785204419031" /><figcaption>20170223148785204419031<figcaption></figure></p>
<p>关于 Android 4.4 版本开始的状态栏变化，许多人喜欢称之为“沉浸式状态栏”，但从系统提供的 API 命名上可以看出，核心词汇为 “Translucent”，故准确来讲，这种效果又应该称之为“透明状态栏”。知乎上对于这两种叫法也颇有争议，具体内容可参考话题：为什么在国内会有很多用户把「透明栏」（Translucent Bars）称作 「沉浸式顶栏」？。可能对于设计师而言，沉浸式还是透明式的称呼有所区别，但对于广大开发者而言，无足轻重，我们所关注的应该是如何实现这种效果，并能够很好的兼容到各个版本中。</p>
<h2><a id="%E7%9B%B8%E5%85%B3api%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关 API 介绍</h2>
<p>一般来说，目前在 Android 项目中我们都会使用 Toolbar 替代 ActionBar 来实现导航栏，除此之外，要实现透明状态栏效果，还需要了解两个相关 API，下面逐一介绍一下：</p>
<h3><a id="%E4%B8%80%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一：</h3>
<p><code>&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</code><br />
也可以在代码中实现（据说，在代码中实现兼容性更好，style 资源中设置的方式在某些国产手机厂商定制的系统中存在一些问题）:</p>
<pre class="line-numbers"><code class="language-java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
    WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes();
    local LayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);
}
</code></pre>
<p>顾名思义，该属性能够实现透明状态栏效果，是在 Android 4.4 版本引入的，也就是兼容至 API 19 及以上版本。使用该属性设置主题后，内容布局向上延伸至状态栏，并且在不同版本的系统中呈现效果也有所区别，如图所示：<br />
<figure><img src="media/15626502772407/20170223148785226694094.png" alt="20170223148785226694094" /><figcaption>20170223148785226694094<figcaption></figure></p>
<p>显然，在 API 19 及更高版本上，Toolbar 内容延伸至状态栏上去了，出现重叠问题，此时，就需要使用到另一个属性了。</p>
<h3><a id="%E4%BA%8C%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二：</h3>
<p><code>android:fitsSystemWindows=&quot;true&quot;</code></p>
<blockquote>
<p>Boolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity.</p>
</blockquote>
<p>用在 layout 布局文件中。官方文档给出了很明确的介绍，大致是说能够将使用该属性的视图与系统窗口（如状态栏）保持一定的 padding 间距。所以如果我们在 toolbar 中设置了该属性，就能够解决 <item name="android:windowTranslucentStatus">true</item> 配置带来的视图延伸问题，使呈现效果达到文章开始所示图中的效果。</p>
<h2><a id="%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用案例分析</h2>
<p><strong>res/values/styles 文件中定义基础主题样式：</strong></p>
<pre class="line-numbers"><code class="language-xml">	&lt;style name=&quot;BaseTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;/&gt;
   &lt;style name=&quot;AppTheme&quot; parent=&quot;BaseTheme&quot;&gt;
   &lt;/style&gt;
</code></pre>
<p><strong>res/values-v19/styles 文件中定义兼容主题样式：</strong></p>
<pre class="line-numbers"><code class="language-xml">	&lt;style name=&quot;AppTheme&quot; parent=&quot;BaseTheme&quot;&gt;
   &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;
   &lt;/style&gt;
</code></pre>
<p><strong>然后在 AndroidManifest.xml 文件中使用全局主题样式：</strong></p>
<pre class="line-numbers"><code class="language-xml">&lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;Samples&quot;
        android:supportsRtl=&quot;true&quot;
        android:name=&quot;.MyApplication&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
</code></pre>
<p>新建一个 layout 布局文件，单独定义 toolbar 内容，在应用中的其他 Activity 界面布局中使用 include 标签潜入引用：</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v7.widget.Toolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/tb_toolbar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:minHeight=&quot;?actionBarSize&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:fitsSystemWindows=&quot;true&quot;
    app:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;
    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;
    app:title=&quot;@string/app_name&quot;
    app:titleTextColor=&quot;@android:color/white&quot;&gt;

&lt;/android.support.v7.widget.Toolbar&gt;
</code></pre>
<p>这里使用<code>android:fitsSystemWindows=&quot;true&quot;</code>属性解决内容试图向上延伸的问题。实际上，也可以使用 <code>android:paddingTop=&quot;@dimen/toolbar_padding_top&quot;</code> 的方式解决，toolbar_padding_top 间距为状态栏高度，在大多数机器上状态栏高度为 25dp，当然也可以通过代码动态获取状态栏高度并设置到 Toolbar 的 paddingTop 属性上。需要注意的是，这里要做兼容判断，比如在 res/values/dimens.xml 中定义toolbar_padding_top 高度为 0dp，在 res/values-v19/dimens.xml 中为 25dp，确保兼容 Android 4.4 以下版本。</p>
<p>基本上，做到这些就能够实现文章开头处图中的效果。值得注意的是，有时候如果想在 Android 5.0 及以上版本的系统中也做到全透明效果，或者说状态栏与导航栏的颜色一致，还可以做进一步兼容处理，毕竟自 5.0 版本开始，系统对于状态栏背景色的定制提供了更好的 API。如 res/values-v21/styles.xml 中定义：</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;

    &lt;style name=&quot;AppTheme&quot; parent=&quot;BaseTheme&quot;&gt;
        &lt;item name=&quot;android:colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
        &lt;item name=&quot;android:colorPrimaryDark&quot;&gt;@color/colorPrimary&lt;/item&gt;
        &lt;item name=&quot;android:colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;/style&gt;

&lt;/resources&gt;
</code></pre>
<p>说明一点，使用这种处理方式后，5.0 系统中应用的状态栏背景色可随意定制，同时与使用 <code>&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</code> 样式有所不同的是，该处理方式不会引起内容视图的向上延伸，所以不需要在 layout 布局文件中额外添加 android:fitsSystemWindows=&quot;true&quot; 属性。当然，添加了也无所谓，毕竟还要兼容 4.4 到 5.0 之间的版本。</p>
<h2><a id="%E7%8A%B6%E6%80%81%E6%A0%8F%E7%99%BD%E5%BA%95%E9%BB%91%E5%AD%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>状态栏白底黑字</h2>
<p>前面我们说过，虽然说 4.4 版本开始，可以实现透明状态栏效果，也就是可以通过各种手段实现修改状态栏背景色，但是状态栏图标和文字的颜色默认为白色，这个是无法像 iOS 系统那样，根据应用的整体色调动态修改。如果恰好 Toolbar 的背景色为白色，为了保持一致，将状态栏背景色调为白色的话，就会与状态栏的白色内容发生冲突，导致其内容无法凸显，这个体验肯定无法被用户接受。</p>
<p>所以，遇见这种 Toolbar 或者说导航栏背景色为白色的情况，一般有两种处理方式：第一种，不修改状态栏背景色，通常默认为黑色背景白色内容；第二种，修改状态栏背景色为淡黑色，这样既能显示状态栏内容，又能与白色导航栏弱显衔接，比如支付宝 App 就是这么做的：<br />
<figure><img src="media/15626502772407/20170223148785322655441.png" alt="20170223148785322655441" /><figcaption>20170223148785322655441<figcaption></figure></p>
<p>像上图这种处理方式较黑色状态栏来说，相对缓和一些，那能不能做到修改状态栏内容的颜色呢，比如白底黑字？大家知道，Android 系统是开源的，国内的各家手机厂商都做了一些自己的定制，像部分厂商定制的系统就提供了相应的 API 供开发人员做适配工作。比如，部分厂商就提供了相应的 API 来修改状态栏内容颜色，实现状态栏白底黑字效果，如图：<br />
<figure><img src="media/15626502772407/20170223148785324052944.png" alt="20170223148785324052944" /><figcaption>20170223148785324052944<figcaption></figure></p>
<p>具体做法就是，在代码中判断系统类型，与提供修改状态内容颜色的系统匹配，使用其特定的 API 操作即可。目前开放这种定制 API 的系统已知有 MIUI 和 Flyme 系统，具体实现代码可参考：</p>
<ul>
<li><a href="http://dev.xiaomi.com/doc/p=4769/index.html">小米 MIUI 6 系统</a></li>
<li><a href="http://open-wiki.flyme.cn/index.php?title=%E7%8A%B6%E6%80%81%E6%A0%8F%E5%8F%98%E8%89%B2">魅族 Flyme 系统</a></li>
</ul>
<p>其实，在 Android 6.0（API 23）及更高的版本上，系统也开始提供了对应的 API 来实现浅色调背景的状态栏效果，可将状态栏图标和文字内容改为黑色样式，实现方式为：</p>
<pre class="line-numbers"><code class="language-java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
	getWindow().getDecorView().setSystemUiVisibility(
		View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);
		getWindow().setStatusBarColor(Color.TRANSPARENT);
}
</code></pre>
<p>但是不知国内厂商在定制系统时是否对此有做处理，能否兼容这个 API ？不过，貌似微博 App 是这么做的，大家感兴趣地不妨一试。</p>
<h2><a id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意事项</h2>
<p>除了上述 Toolbar 与 状态栏在背景色上的衔接，App 中常见还有这样一种设计，以微博个人主页为例，如图所示：<br />
<figure><img src="media/15626502772407/20170223148785341741351.png" alt="20170223148785341741351" /><figcaption>20170223148785341741351<figcaption></figure></p>
<p>页面顶部的图片内容延伸至状态栏中，这种做法其实就是单独使用 <code>&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</code> 样式，不在 layout 布局文件中添加 <code>android:fitsSystemWindows=&quot;true&quot;</code>属性即可。</p>
<p>还有一点，通常我们会在资源文件中定义不同版本的主题样式，再在 <application> 标签中统一设置，然后所有的 Activity 都能使用这个主题样式。但存在这样一种情况，Activity 由不同的 Fragment 组成，然后不同 Fragment 在状态栏的呈现上有所不同，比如有的 Fragment 顶部使用 Toolbar 与状态栏衔接，有的顶部直接使用图片延伸至状态栏上甚至不会用到 Toolbar，如图所示：<br />
<figure><img src="media/15626502772407/20170223148785345291771.png" alt="20170223148785345291771" /><figcaption>20170223148785345291771<figcaption></figure></p>
<p>由于 Fragment 是无法像 Activity 那样在 AndroidManifest.xml 中单独设置主题样式的，所以这里可以这样做：宿主 Activity 还是使用透明样式，以满足图片延伸的 Fragment 页面效果，其他使用 Toolbar 的 Fragment，在其 Layout 布局文件顶部单独定义一个 View，让其延伸至状态栏，然后在代码中根据不同版本系统设置其高度，4.4 版本以下设置该 View 高度为0，4.4 及以上版本设置为设备状态栏高度，通过代码获取状态高度的方式如下：</p>
<pre class="line-numbers"><code class="language-java">/**
 * 获取状态栏高度
 * @param activity
 * @return
 */
public static int getStatusBarHeight(Activity activity){
	Rect rect = new Rect();
	activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);
	return rect.top==0 ? 60 : rect.top;
}
</code></pre>
<p>最后再补充一点，大家知道，长按 Toolbar 中 Menu Item 时会显示一个 Toast 提示，内容来自 Item 定义时对应的 title 属性，通常显示如图所示：<br />
<figure><img src="media/15626502772407/20170223148785352797212.png" alt="20170223148785352797212" /><figcaption>20170223148785352797212<figcaption></figure></p>
<p>但是，如果你误将 fitsSystemWindows 属性设置在了 style 样式文件中，比如：</p>
<pre class="line-numbers"><code class="language-java">&lt;style name=&quot;BaseTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;item name=&quot;android:fitsSystemWindows&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>将会导致下图效果：<br />
<figure><img src="media/15626502772407/20170223148785356810318.png" alt="20170223148785356810318" /><figcaption>20170223148785356810318<figcaption></figure></p>
<p>可见，Menu Options Item 长按时弹出的 Toast 样式没了内容间距，显然很丑。所以，记得将该属性设置在正确的布局文件中，不要设置成全局的。</p>
<h2><a id="%E7%9B%B8%E5%85%B3%E6%8B%93%E5%B1%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关拓展</h2>
<p>以上便是有关 Android 4.4 开始的状态栏背景色相关知识，可以看出 4.4 、5.0 、6.0 版本作为三个分水岭，根据需要做好相关适配工作即可。还有一种通过 <code>setSystemUiVisibility()</code> 方法设置状态栏的方式，还能实现状态栏的显示与隐藏交互效果，具体可参考这篇文章：</p>
<ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/51763825">http://blog.csdn.net/guolin_blog/article/details/51763825</a></li>
</ul>
<p>GitHub 上对于 Android 4.4 版本开始的状态栏背景色的处理有一个开源库，感兴趣地朋友也可借鉴参考一番，地址如下：</p>
<ul>
<li><a href="https://github.com/jgilfelt/SystemBarTint">https://github.com/jgilfelt/SystemBarTint</a></li>
</ul>
<p>有关 Toolbar 替换 ActionBar 的使用，可以我之前总结的一篇文章，地址为：</p>
<ul>
<li><a href="http://yifeng.studio/2016/10/12/android-toolbar/">http://yifeng.studio/2016/10/12/android-toolbar/</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_6.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_8.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/16898402251241/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style><script>window.MathJax = {     tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } ,     startup: {     pageReady() {       return MathJax.startup.defaultPageReady().then(function () {          window.mweb_mathjax_ready_val = 'yes';          if(window.mweb_mathjax_ready !== undefined){ mweb_mathjax_ready(); }       });     }   }};document.addEventListener('DOMContentLoaded', function(event) {    if (typeof Prism != 'undefined') {         Prism.highlightAll();     }});window.mweb_mathjax_ready_val = '';function theMWebMathJaxRenderIsReady(key){ return window.mweb_mathjax_ready_val; }</script><script>window.MathJax = { tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } }; </script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
