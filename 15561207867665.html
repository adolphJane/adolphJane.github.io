<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	改善C++代码的建议 - MagicalRice的Blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">MagicalRice的Blog</a></h1>
					<p class="subtitle">技术博客</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">改善C++代码的建议</h1>
		<div class="entry-content" itemprop="articleBody">
			<h2 id="toc_0">学习C++代码的一些建议，记录一下</h2>

<ul>
<li><strong>不要让main函数返回void()</strong> ----<code>int main()</code>和<code>int main（int argc，char *argv[]）</code>这两个都是可行的;</li>
<li><strong>FALSE/TRUE是int型，false/true是bool型</strong></li>
<li><strong>表达式****<mark>****，最好写成number</mark>nValue，例0==nValue</strong></li>
<li><strong>运算符优先级问题要考虑清楚</strong></li>
<li><strong>使用宏定义时，要用括号完备地保护每一个参数</strong></li>
<li><strong>指针变量一定要初始化</strong></li>
<li><strong>将逗号分隔表达式一定要规范</strong>，在条件和循环语句中，表达式的值采用的是最右边的结果;</li>
<li><strong>时刻提防内存溢出。</strong>当信息来源不可靠时，要用到内存缓冲区时，必须提高警惕，必须知道内存缓冲区的总长度，并检验内存缓冲区；</li>
<li><strong>拒绝晦涩难懂的函数指针定义，拒绝函数定义中成堆的括号</strong>,使用typedef让函数指针更加直观，易维护；</li>
<li><strong>避免包含相同的头文件在不同文件中</strong></li>
</ul>

<pre>
{
   #ifndef _PROJECT_PATH_FILE_H_

   #define _PROJECT_PATH_FILE_H_
   ……//声明
   #endif 
};
</pre>

<ul>
<li><strong>优化结构体中元素的布局</strong></li>
</ul>

<pre>
{
    a.结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
    b.结构体每个成员相对于结构体首地址的偏移量（offset）都是成员自身大小的整数倍，如有需要编译器会在成员之间加上填充字节;
    c.结构体的总大小为结构体最宽基本类型大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。
*把结构体中得变量按照类型大小从小到大依次声明，尽量减少中间的填充字节。
}
#pragma pack(1)
struct A
{
   int a;
   char b;
   short c;
}
</pre>

<ul>
<li><strong>将强制转型减到最少</strong>  不同类型的指针之间不能相互转换（避免在内存访问时存在隐患）<br/>
<ul>
<li>const_cast<T*>(a)：目的简单明确，使用情形比较单一，易于掌握;</li>
<li>dynamic_cast<T*>(a):实现慢，代价大；</li>
<li>reinterpret_cast<T*>(a):不安全；</li>
<li>static_cast<T*>(a):不安全</li>
</ul></li>
<li><strong>优先使用前缀操作符</strong> 前缀操作符的效率要优于后缀操作符（整形，长整形可忽略；用户自定义类型，优先使用前缀操作符。）</li>
<li><strong>掌握变量定义的位置与时机</strong> 控制变量的作用域，适当位置可减少操作时间；</li>
<li><strong>小心typedef使用中的陷阱</strong> 容易与宏定义混淆，typedef声明多个指针对象，形式直观，方便省事。请注意区分typedef与#define之间的不同,不要用理解宏的思维方式对待typedef，typedef声明的新名字具有一定的封装性，更易定义变量。同时还要注意它是一个无“现实意义”的存储类关键字;</li>
<li><strong>尽量不要使用可变参数</strong> 缺乏类型检查，类型安全性无从谈起；必须通过其他方式告诉函数所传递的类型，以及参数个数；不支持自定义数据类型;</li>
<li><strong>慎用goto</strong> 没有带来太大的正面作用，相反却容易破坏程序的结构性，影响了程序的可读性;</li>
<li><strong>提防隐式转换带来的麻烦</strong> 影响数据的精确性，编译器无法正常接受；（为防止精度损失，类型总是被提升为较宽的类型；所有含有小于整形的算术表达式在计算之前其类型都会被转换成整形）
<ul>
<li>使用非C/C++关键字的具名函数，用operator as_T()替换operato  T();</li>
<li>为单参数的构造函数加上explicit关键字;</li>
</ul></li>
<li><strong>正确区分void与void</strong> 如果函数没有返回值，那么应将其声明为void类型（不加返回值类型限定的函数，就会被编译器作为返回整型值处理）；如果函数无参数，那么声明函数参数为void；任何类型的指针都可以赋值给void*；void指针进行算法操作是不合法的;</li>
<li><strong>明白在C++中如何使用C</strong> 要想在C++中使用大量现成的C程序库，实现C++与C的混编，必须了解extern“C”是怎么回事，明白“C”的使用方式;</li>
<li><strong>使用memcpy（）系列</strong> 包含memcpy（），memset（），memcmp（），要注意对象是不是POD。</li>
<li><strong>尽量用new/delete代替malloc/free</strong> malloc/free是语言的标准函数库，而new/delete是C++的运算符。malloc/free无法满足创建动态对象的要求；new不仅能够完成动态内存分配，还能完成初始化工作，稳妥的构造对象；delete不仅能完成内存的释放，还能对对象进行清理。</li>
<li><strong>灵活地使用不同风格的注释</strong> 版权和版本声明，使用C风格的/* */;内嵌注释用//；宏尾端的注释用/* */</li>
<li><strong>尽量使用C++标准的iostream</strong> C++ iostream程序库中的类与C stream函数虽然各有优点，但是一般推荐使用前者，为类型安全与可扩充性对于我们更有吸引力，所以建议使用iostream;</li>
<li><strong>尽量采用C++风格的强制类型转换</strong></li>
<li><strong>尽量用const、enum、inline替换#define</strong> 宏定义并不在编译范围内，使得程序难于分析，难于调试；使用常量可以避免目标码的多分复制；用const修饰指针建议使用更加高级的const string形式。对于简单的常量，应该尽量使用const对象或枚举类型的数据，避免使用#define。对于形似函数的宏，尽量使用内联函数，避免使用#define。尽量将工作交给编译器而不是预处理器;</li>
<li><strong>用引用代替指针</strong> 从编码实践角度来看，指针与引用并无太大不同。在大多数情况下，指针可用索引类型完美代替，并且其实现代码更简洁清晰，更加易于理解</li>
<li><strong>区分内存分配的方式</strong> 栈效率高一点，而堆较灵活</li>
<li><strong>new/delete与new[]/delete[]必须配对使用</strong></li>
<li><strong>区分new的三种形态</strong></li>
<li><strong>new内存失败后的正确处理</strong> 当使用new申请一块内存失败时，抛出异常std::bad_alloc是C++标准中规定的标准行为，所以推荐使用try{p=new int[SIZE];}catch(std::bad_alloc){…}的处理方式</li>
<li><strong>明晰class与struct之间的区别</strong> 
<ul>
<li>关于使用大括号初始化：class与struct定义了构造函数就不能用大括号初始化，如果没有定义struct可以用大括号初始化，而class只有在所有成员变量全是public情况下才能用大括号初始化;</li>
<li>class默认成员访问权限是private，struct中则是public</li>
<li>class继承是private，struct继承是public</li>
</ul></li>
</ul>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>