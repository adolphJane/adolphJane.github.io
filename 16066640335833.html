<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Jetpack学习 - WorkManager - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>Jetpack学习 - WorkManager</h1>
     
        <div class="read-more clearfix">
          <span class="date">2020/11/29</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Android.html'>Android</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <div class="mweb_toc"><ul>
<li><a href="#workmanager%E6%98%AF%E4%BB%80%E4%B9%88">WorkManager 是什么</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E7%B1%BB">核心类</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8workmanger">使用WorkManger</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89work">定义Work</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89workrequest">定义WorkRequest</a>
<ul>
<li><a href="#%E8%B0%83%E5%BA%A6%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BB%BB%E5%8A%A1">调度一次性任务</a></li>
<li><a href="#%E8%B0%83%E5%BA%A6%E5%AE%9A%E6%9C%9F%E5%B7%A5%E4%BD%9C">调度定期工作</a>
<ul>
<li><a href="#%E7%81%B5%E6%B4%BB%E7%9A%84%E8%BF%90%E8%A1%8C%E9%97%B4%E9%9A%94">灵活的运行间隔</a></li>
<li><a href="#%E7%BA%A6%E6%9D%9F%E5%AF%B9%E5%AE%9A%E6%9C%9F%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BD%B1%E5%93%8D">约束对定期工作的影响</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E7%BA%A6%E6%9D%9F">工作约束</a></li>
<li><a href="#%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C">延迟工作</a></li>
<li><a href="#%E9%87%8D%E8%AF%95%E5%92%8C%E9%80%80%E9%81%BF%E7%AD%96%E7%95%A5">重试和退避策略</a></li>
<li><a href="#%E6%A0%87%E8%AE%B0%E5%B7%A5%E4%BD%9C">标记工作</a></li>
<li><a href="#%E5%88%86%E9%85%8D%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE">分配输入数据</a></li>
</ul>
</li>
<li><a href="#workmanager">WorkManager</a>
<ul>
<li><a href="#%E5%94%AF%E4%B8%80%E5%B7%A5%E4%BD%9C">唯一工作</a></li>
<li><a href="#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%94%BF%E7%AD%96">冲突解决政策</a></li>
<li><a href="#%E8%A7%82%E5%AF%9F%E6%82%A8%E7%9A%84%E5%B7%A5%E4%BD%9C">观察您的工作</a></li>
<li><a href="#%E5%A4%8D%E6%9D%82%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9F%A5%E8%AF%A2">复杂的工作查询</a></li>
<li><a href="#%E5%8F%96%E6%B6%88%E5%92%8C%E5%81%9C%E6%AD%A2%E5%B7%A5%E4%BD%9C">取消和停止工作</a></li>
<li><a href="#%E5%81%9C%E6%AD%A2%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%99%A8">停止正在运行的工作器</a></li>
<li><a href="#onstopped%E5%9B%9E%E8%B0%83">onStopped() 回调</a></li>
</ul>
</li>
<li><a href="#%E9%93%BE%E6%8E%A5%E5%B7%A5%E4%BD%9C">链接工作</a></li>
<li><a href="#%E8%A7%82%E5%AF%9F%E5%B7%A5%E4%BD%9C%E5%99%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%BF%9B%E5%BA%A6">观察工作器的中间进度</a>
<ul>
<li><a href="#%E6%9B%B4%E6%96%B0%E8%BF%9B%E5%BA%A6">更新进度</a></li>
<li><a href="#%E8%A7%82%E5%AF%9F%E8%BF%9B%E5%BA%A6">观察进度</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2><a id="workmanager%E6%98%AF%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>WorkManager 是什么</h2>
<p>作为Android Jetpack中的新组件，WorkManager负责用来管理后台任务，可以轻松调度即使在应用退出或设备重启时仍应运行的可延迟异步任务，不适用于应用进程结束时能够安全终止的运行中的后台工作，也不适用于需要立即执行的任务。</p>
<span id="more"></span><!-- more --> 
<p><figure><img src="media/16066640335833/16066691224038.jpg" alt="" /></figure></p>
<p>当应用正在运行时，它会在当前的进程中启用一个子线程执行。应用没有运行的情况下启用，它则会自己选择一种合适的方式在后台运行。具体是什么方式和 Android 的版本和依赖环境有关：</p>
<p><figure><img src="media/16066640335833/16066687850496.png" alt="" /></figure></p>
<p><strong>优点</strong></p>
<ul>
<li>使用方便，内部会根据不同系统选择合适方案</li>
<li>能链式调度，让各任务按指定顺序执行</li>
<li>能配置各种执行状态，如有无网络、是否在充电</li>
<li>任务被存储进数据库，关机仍可执行</li>
<li>遵循低电耗模式等省电功能</li>
<li>监控和管理计划任务</li>
</ul>
<h2><a id="%E6%A0%B8%E5%BF%83%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>核心类</h2>
<p>WorkManager中涉及到的相关类</p>
<ul>
<li>
<p>Worker<br />
任务的执行者，是一个抽象类，需要继承它实现要执行的任务。</p>
</li>
<li>
<p>WorkRequest<br />
指定让哪个 Woker 执行任务，指定执行的环境，执行的顺序等。<br />
要使用它的子类 OneTimeWorkRequest 或 PeriodicWorkRequest。</p>
</li>
<li>
<p>WorkManager<br />
管理任务请求和任务队列，发起的 WorkRequest 会进入它的任务队列。</p>
</li>
<li>
<p>WorkStatus<br />
包含有任务的状态和任务的信息，以 LiveData 的形式提供给观察者，更新相关UI</p>
</li>
</ul>
<h2><a id="%E4%BD%BF%E7%94%A8workmanger" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用WorkManger</h2>
<p>在build.gradle中添加依赖:</p>
<pre class="line-numbers"><code class="language-plain_text">dependencies {
  def work_version = &quot;2.4.0&quot;

    // (Java only)
    implementation &quot;androidx.work:work-runtime:$work_version&quot;

    // Kotlin + coroutines
    implementation &quot;androidx.work:work-runtime-ktx:$work_version&quot;

    // optional - RxJava2 support
    implementation &quot;androidx.work:work-rxjava2:$work_version&quot;

    // optional - GCMNetworkManager support
    implementation &quot;androidx.work:work-gcm:$work_version&quot;

    // optional - Test helpers
    androidTestImplementation &quot;androidx.work:work-testing:$work_version&quot;
  }
</code></pre>
<p>添加依赖项并同步 Gradle 项目</p>
<h3><a id="%E5%AE%9A%E4%B9%89work" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义Work</h3>
<p>自定义Work类，继承Worker类。<code>doWork()</code> 方法在 <code>WorkManager</code> 提供的后台线程上同步运行。</p>
<pre class="line-numbers"><code class="language-kotlin">class UploadWorker(appContext: Context, workerParams: WorkerParameters):
       Worker(appContext, workerParams) {
   override fun doWork(): Result {

       // Do the work here--in this case, upload the images.
       uploadImages()

       // Indicate whether the work finished successfully with the Result
       return Result.success()
   }
}
</code></pre>
<p>从 <code>doWork()</code> 返回的 <code>Result</code> 会通知 <code>WorkManager</code> 服务工作是否成功，以及工作失败时是否应重试工作。</p>
<ul>
<li><code>Result.success()</code>：工作成功完成。</li>
<li><code>Result.failure()</code>：工作失败。</li>
<li><code>Result.retry()</code>：工作失败，应根据其重试策略在其他时间尝试。</li>
</ul>
<h3><a id="%E5%AE%9A%E4%B9%89workrequest" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义WorkRequest</h3>
<p>定义Work后，必须使用 <code>WorkManager</code> 服务进行调度该工作才能运行。对于如何调度Work，<code>WorkManager</code> 提供了很大的灵活性。您可以将其安排为在某段时间内定期运行，也可以将其安排为仅运行一次。</p>
<p><code>Worker</code> 定义工作单元，<code>WorkRequest</code>（及其子类）则定义工作运行方式和时间,包含 <code>WorkManager</code> 调度和运行工作所需的所有信息,其中包括运行工作必须满足的约束、调度信息（例如延迟或重复间隔）、重试配置，并且可能包含输入数据。</p>
<p><code>WorkRequest</code> 本身是抽象基类。该类有两个派生实现，可用于创建 <code>OneTimeWorkRequest</code> 和 <code>PeriodicWorkRequest</code> 请求。顾名思义，<code>OneTimeWorkRequest</code> 适用于调度非重复性工作，而 <code>PeriodicWorkRequest</code> 则更适合调度以一定间隔重复执行的工作。</p>
<pre class="line-numbers"><code class="language-java">Constraints constraints = new Constraints();
//设备存储空间充足的时候 才能执行 ,&gt;15%
constraints.setRequiresStorageNotLow(true);
//必须在执行的网络条件下才能好执行,不计流量 ,wifi
constraints.setRequiredNetworkType(NetworkType.UNMETERED);
//设备的充电量充足的才能执行 &gt;15%
constraints.setRequiresBatteryNotLow(true);
//只有设备在充电的情况下 才能允许执行
constraints.setRequiresCharging(true);
//只有设备在空闲的情况下才能被执行 比如息屏，cpu利用率不高
constraints.setRequiresDeviceIdle(true);
//workmanager利用contentObserver监控传递进来的这个uri对应的内容是否发生变化,当且仅当它发生变化了
//我们的任务才会被触发执行，以下三个api是关联的
constraints.setContentUriTriggers(null);
//设置从content变化到被执行中间的延迟时间，如果在这期间。content发生了变化，延迟时间会被重新计算
//这个content就是指 我们设置的setContentUriTriggers uri对应的内容
constraints.setTriggerContentUpdateDelay(0);
//设置从content变化到被执行中间的最大延迟时间  这个content就是指 我们设置的constraints.setContentUriTriggers uri对应的内容
constraints.setTriggerMaxContentDelay(0);
</code></pre>
<p>通过创建Constraints ，设置具体的约束条件，在创建Request的时候，调用.setConstraints(constraints)即可。</p>
<pre class="line-numbers"><code class="language-java"> OneTimeWorkRequest request = new OneTimeWorkRequest
                .Builder(UploadFileWorker.class)
                .setInputData(inputData)
                .setConstraints(constraints)
//                .setConstraints(constraints)
//                //设置一个拦截器，在任务执行之前 可以做一次拦截，去修改入参的数据然后返回新的数据交由worker使用
//                .setInputMerger(null)
//                //当一个任务被调度失败后，所要采取的重试策略，可以通过BackoffPolicy来执行具体的策略
//                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 10, TimeUnit.SECONDS)
//                //任务被调度执行的延迟时间
//                .setInitialDelay(10, TimeUnit.SECONDS)
//                //设置该任务尝试执行的最大次数
//                .setInitialRunAttemptCount(2)
//                //设置这个任务开始执行的时间
//                //System.currentTimeMillis()
//                .setPeriodStartTime(0, TimeUnit.SECONDS)
//                //指定该任务被调度的时间
//                .setScheduleRequestedAt(0, TimeUnit.SECONDS)
//                //当一个任务执行状态编程finish时，又没有后续的观察者来消费这个结果，难么workamnager会在
//                //内存中保留一段时间的该任务的结果。超过这个时间，这个结果就会被存储到数据库中
//                //下次想要查询该任务的结果时，会触发workmanager的数据库查询操作，可以通过uuid来查询任务的状态
//                .keepResultsForAtLeast(10, TimeUnit.SECONDS)
                .build();
</code></pre>
<h4><a id="%E8%B0%83%E5%BA%A6%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BB%BB%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度一次性任务</h4>
<p>对于无需额外配置的简单工作，请使用静态方法 from：</p>
<pre class="line-numbers"><code class="language-kotlin">val myWorkRequest = OneTimeWorkRequest.from(MyWork::class.java)
</code></pre>
<p>对于更复杂的工作，可以使用构建器。</p>
<pre class="line-numbers"><code class="language-kotlin">val uploadWorkRequest: WorkRequest =
   OneTimeWorkRequestBuilder&lt;MyWork&gt;()
       // Additional configuration
       .build()
</code></pre>
<h4><a id="%E8%B0%83%E5%BA%A6%E5%AE%9A%E6%9C%9F%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调度定期工作</h4>
<p>应用有时可能需要定期运行某些工作。例如，定期备份数据、定期下载应用中的新鲜内容或者定期上传日志到服务器。</p>
<p>使用 <code>PeriodicWorkRequest</code> 创建定期执行的 <code>WorkRequest</code> 对象</p>
<pre class="line-numbers"><code class="language-kotlin">val saveRequest =
       PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(1, TimeUnit.HOURS)
    // Additional configuration
           .build()
</code></pre>
<p>在此示例中，工作的运行时间间隔定为一小时。</p>
<p>时间间隔定义为两次重复执行之间的最短时间。工作器的确切执行时间取决于您在 <code>WorkRequest</code> 对象中设置的约束以及系统执行的优化。</p>
<h5><a id="%E7%81%B5%E6%B4%BB%E7%9A%84%E8%BF%90%E8%A1%8C%E9%97%B4%E9%9A%94" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>灵活的运行间隔</h5>
<p>如果您的工作的性质致使其对运行时间敏感，您可以将 <code>PeriodicWorkRequest</code> 配置为在每个时间间隔的灵活时间段内运行。</p>
<p><figure><img src="media/16066640335833/16066662472408.png" alt="" /></figure></p>
<p>如需定义具有灵活时间段的定期工作，请在创建 <code>PeriodicWorkRequest</code> 时传递 <code>flexInterval</code> 以及 <code>repeatInterval</code>。灵活时间段从 <code>repeatInterval - flexInterval</code> 开始，一直到间隔结束。</p>
<p>以下是可在每小时的最后 15 分钟内运行的定期工作的示例。</p>
<pre class="line-numbers"><code class="language-kotlin">val myUploadWork = PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(
       1, TimeUnit.HOURS, // repeatInterval (the period cycle)
       15, TimeUnit.MINUTES) // flexInterval
    .build()
</code></pre>
<p>重复间隔必须大于或等于 <code>PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS</code>，而灵活间隔必须大于或等于 <code>PeriodicWorkRequest.MIN_PERIODIC_FLEX_MILLIS</code>。</p>
<h5><a id="%E7%BA%A6%E6%9D%9F%E5%AF%B9%E5%AE%9A%E6%9C%9F%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BD%B1%E5%93%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>约束对定期工作的影响</h5>
<p>您可以对定期工作设置约束。例如，您可以为工作请求添加约束，以便工作仅在用户设备充电时运行。在这种情况下，除非满足约束条件，否则即使过了定义的重复间隔，PeriodicWorkRequest 也不会运行。这可能会导致工作在某次运行时出现延迟，甚至会因在相应间隔内未满足条件而被跳过。</p>
<h4><a id="%E5%B7%A5%E4%BD%9C%E7%BA%A6%E6%9D%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>工作约束</h4>
<p>约束可确保将工作延迟到满足最佳条件时运行。以下约束适用于 WorkManager。</p>
<table>
<thead>
<tr>
<th style="text-align: left">约束类型</th>
<th style="text-align: left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">NetworkType</td>
<td style="text-align: left">约束运行工作所需的网络类型。例如 Wi-Fi (UNMETERED)。</td>
</tr>
<tr>
<td style="text-align: left">BatteryNotLow</td>
<td style="text-align: left">如果设置为 true，那么当设备处于“电量不足模式”时，工作不会运行。</td>
</tr>
<tr>
<td style="text-align: left">RequiresCharging</td>
<td style="text-align: left">如果设置为 true，那么工作只能在设备充电时运行。</td>
</tr>
<tr>
<td style="text-align: left">DeviceIdle</td>
<td style="text-align: left">如果设置为 true，则要求用户的设备必须处于空闲状态，才能运行工作。如果您要运行批量操作，否则可能会降低用户设备上正在积极运行的其他应用的性能，建议您使用此约束。</td>
</tr>
<tr>
<td style="text-align: left">StorageNotLow</td>
<td style="text-align: left">如果设置为 true，那么当用户设备上的存储空间不足时，工作不会运行。</td>
</tr>
</tbody>
</table>
<p>如需创建一组约束并将其与某项工作相关联，请使用一个 Contraints.Builder() 创建 Constraints 实例，并将该实例分配给 WorkRequest.Builder()。</p>
<p>例如，以下代码会构建了一个工作请求，该工作请求仅在用户设备正在充电且连接到 Wi-Fi 网络时才会运行：</p>
<pre class="line-numbers"><code class="language-kotlin">val constraints = Constraints.Builder()
   .setRequiredNetworkType(NetworkType.UNMETERED)
   .setRequiresCharging(true)
   .build()

val myWorkRequest: WorkRequest =
   OneTimeWorkRequestBuilder&lt;MyWork&gt;()
       .setConstraints(constraints)
       .build()
</code></pre>
<p>如果指定了多个约束，工作将仅在满足所有约束时才会运行。</p>
<h4><a id="%E5%BB%B6%E8%BF%9F%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>延迟工作</h4>
<p>如果工作没有约束，或者当工作加入队列时所有约束都得到了满足，那么系统可能会选择立即运行该工作。如果您不希望工作立即运行，可以将工作指定为在经过一段最短初始延迟时间后再启动。</p>
<p>下面举例说明了如何将工作设置为在加入队列后至少经过 10 分钟后再运行。</p>
<pre class="line-numbers"><code class="language-kotlin">val myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()
   .setInitialDelay(10, TimeUnit.MINUTES)
   .build()
</code></pre>
<p>定期工作只有首次运行时会延迟。</p>
<h4><a id="%E9%87%8D%E8%AF%95%E5%92%8C%E9%80%80%E9%81%BF%E7%AD%96%E7%95%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重试和退避策略</h4>
<p>如果需要让 <code>WorkManager</code> 重试工作，可以从工作器返回 <code>Result.retry()</code>。然后，系统将根据退避延迟时间和退避政策重新调度工作。</p>
<p>退避延迟时间指定了首次尝试后重试工作前的最短等待时间。此值不能超过 10 秒（或 MIN_BACKOFF_MILLIS）。<br />
退避政策定义了在后续重试过程中，退避延迟时间随时间以怎样的方式增长。<code>WorkManager</code> 支持 2 个退避政策，即 <code>LINEAR</code> 和 <code>EXPONENTIAL</code>。<br />
每个工作请求都有退避政策和退避延迟时间。默认政策是 EXPONENTIAL，延迟时间为 10 秒，但您可以在工作请求配置中替换此设置。</p>
<p>以下是自定义退避延迟时间和政策的示例。</p>
<pre class="line-numbers"><code class="language-kotlin">val myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()
   .setBackoffCriteria(
       BackoffPolicy.LINEAR,
       OneTimeWorkRequest.MIN_BACKOFF_MILLIS,
       TimeUnit.MILLISECONDS)
   .build()
</code></pre>
<p>在本示例中，最短退避延迟时间设置为允许的最小值，即 10 秒。由于政策为 LINEAR，每次尝试重试时，重试间隔都会增加约 10 秒。例如，第一次运行以 Result.retry() 结束并在 10 秒后重试；然后，如果工作在后续尝试后继续返回 Result.retry()，那么接下来会在 20 秒、30 秒、40 秒后重试，以此类推。如果退避政策设置为 EXPONENTIAL，那么重试时长序列将接近 20、40、80 秒，以此类推。</p>
<blockquote>
<p>注意：退避延迟时间不精确，在两次重试之间可能会有几秒钟的差异，但绝不会低于配置中指定的初始退避延迟时间。</p>
</blockquote>
<h4><a id="%E6%A0%87%E8%AE%B0%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标记工作</h4>
<p>每个工作请求都有一个唯一标识符，该标识符可用于在以后标识该工作，以便取消工作或观察其进度。</p>
<p>如果有一组在逻辑上相关的工作，对这些工作项进行标记可能也会很有帮助。通过标记，您一起处理一组工作请求。</p>
<p>例如，WorkManager.cancelAllWorkByTag(String) 会取消带有特定标记的所有工作请求，WorkManager.getWorkInfosByTag(String) 会返回一个 WorkInfo 对象列表，该列表可用于确定当前工作状态。</p>
<p>以下代码展示了如何向工作添加“cleanup”标记：</p>
<pre class="line-numbers"><code class="language-kotlin">val myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()
   .addTag(&quot;cleanup&quot;)
   .build()
</code></pre>
<p>最后，可以向单个工作请求添加多个标记。这些标记在内部以一组字符串的形式进行存储。对于工作请求，您可以通过 WorkRequest.getTags() 检索其标记集。</p>
<h4><a id="%E5%88%86%E9%85%8D%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分配输入数据</h4>
<p>您的工作可能需要输入数据才能正常运行。例如，处理图片上传的工作可能需要使用待上传图片的 URI 作为输入数据。</p>
<p>输入值以键值对的形式存储在 Data 对象中，并且可以在工作请求中设置。WorkManager 会在执行工作时将输入 Data 传递给工作。Worker 类可通过调用 Worker.getInputData() 访问输入参数。以下代码展示了如何创建需要输入数据的 Worker 实例，以及如何在工作请求中发送该实例。</p>
<pre class="line-numbers"><code class="language-kotlin">// Define the Worker requiring input
class UploadWork(appContext: Context, workerParams: WorkerParameters)
   : Worker(appContext, workerParams) {

   override fun doWork(): Result {
       val imageUriInput =
           inputData.getString(&quot;IMAGE_URI&quot;) ?: return Result.failure()

       uploadFile(imageUriInput)
       return Result.success()
   }
   ...
}

// Create a WorkRequest for your Worker and sending it input
val myUploadWork = OneTimeWorkRequestBuilder&lt;UploadWork&gt;()
   .setInputData(workDataOf(
       &quot;IMAGE_URI&quot; to &quot;http://...&quot;
   ))
   .build()
</code></pre>
<h3><a id="workmanager" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>WorkManager</h3>
<p>定义 <code>Worker</code> 和 <code>WorkRequest</code> 后，最后一步是将工作加入队列。将工作加入队列的最简单方法是调用 <code>WorkManager enqueue()</code> 方法，然后传递要运行的 <code>WorkRequest</code>。</p>
<pre class="line-numbers"><code class="language-kotlin">val myWork: WorkRequest = // ... OneTime or PeriodicWork
WorkManager.getInstance(requireContext()).enqueue(myWork)
</code></pre>
<p>在将工作加入队列时请小心谨慎，以避免重复。例如，应用可能会每 24 小时尝试将其日志上传到后端服务。如果不谨慎，即使作业只需运行一次，您最终也可能会多次将同一作业加入队列。为了实现此目标，您可以将工作调度为唯一工作。</p>
<h4><a id="%E5%94%AF%E4%B8%80%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>唯一工作</h4>
<p>唯一工作是一个很实用的概念，可确保同一时刻只有一个具有特定名称的工作实例。</p>
<p>唯一工作既可用于一次性工作，也可用于定期工作。您可以通过调用以下方法之一创建唯一工作序列，具体取决于您是调度重复工作还是一次性工作。</p>
<ul>
<li><code>WorkManager.enqueueUniqueWork()</code>（用于一次性工作）</li>
<li><code>WorkManager.enqueueUniquePeriodicWork()</code>（用于定期工作）</li>
</ul>
<p>这两种方法都接受 3 个参数：</p>
<ul>
<li><em>uniqueWorkName</em> 用于唯一标识工作请求的 String。</li>
<li><em>existingWorkPolicy</em> 此 enum 可告知 WorkManager 如果已有使用该名称且尚未完成的唯一工作链，应执行什么操作。</li>
<li><em>work</em> 要调度的 <code>WorkRequest</code>。</li>
</ul>
<p>借助唯一工作，我们可以解决前面提到的重复调度问题。</p>
<pre class="line-numbers"><code class="language-kotiln">val sendLogsWorkRequest =
       PeriodicWorkRequestBuilder&lt;SendLogsWorker&gt;(24, TimeUnit.HOURS)
           .setConstraints(Constraints.Builder()
               .setRequiresCharging(true)
               .build()
            )
           .build()
WorkManager.getInstance(this).enqueueUniquePeriodicWork(
           &quot;sendLogs&quot;,
           ExistingPeriodicWorkPolicy.KEEP,
           sendLogsWorkRequest
)
</code></pre>
<p>现在，如果上述代码在 sendLogs 作业已处于队列中的情况下运行，系统会保留现有的作业，并且不会添加新的作业。</p>
<p>当您需要逐步构建一个长任务链时，也可以利用唯一工作序列。例如，照片编辑应用可能允许用户撤消一长串操作。其中的每一项撤消操作可能都需要一些时间来完成，但必须按正确的顺序执行。在这种情况下，应用可以创建一个“撤消”链，并根据需要将每个撤消操作附加到该链上。</p>
<h4><a id="%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%94%BF%E7%AD%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>冲突解决政策</h4>
<p>调度唯一工作时，您必须告知 WorkManager 在发生冲突时要执行的操作。您可以通过在将工作加入队列时传递一个枚举来实现此目的。</p>
<p>对于一次性工作，您需要提供一个 ExistingWorkPolicy，它支持用于处理冲突的 4 个选项。</p>
<ul>
<li>
<p><strong><code>REPLACE</code></strong>：用新工作替换现有工作。此选项将取消现有工作。</p>
</li>
<li>
<p><strong><code>KEEP</code></strong>：保留现有工作，并忽略新工作。</p>
</li>
<li>
<p><strong><code>APPEND</code></strong>：将新工作附加到现有工作的末尾，在现有工作完成后运行。<br />
现有工作将成为新工作的先决条件。如果现有工作变为 <code>CANCELLED</code> 或 <code>FAILED</code> 状态，新工作也会变为 <code>CANCELLED</code> 或 <code>FAILED</code>。如果您希望无论现有工作的状态如何都运行新工作，请改用 <code>APPEND_OR_REPLACE</code>。</p>
</li>
<li>
<p><strong><code>APPEND_OR_REPLACE</code></strong> 功能类似于 <code>APPEND</code>，不过它并不依赖于先决条件工作状态。即使现有工作变为 <code>CANCELLED</code> 或 <code>FAILED</code> 状态，新工作仍会运行。<br />
对于定期工作，您需要提供一个 <code>ExistingPeriodicWorkPolicy</code>，它支持 <code>REPLACE</code> 和 <code>KEEP</code> 这两个选项。这些选项的功能与其对应的 <code>ExistingWorkPolicy</code> 功能相同。</p>
</li>
</ul>
<h4><a id="%E8%A7%82%E5%AF%9F%E6%82%A8%E7%9A%84%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>观察您的工作</h4>
<p>在将工作加入队列后，您可以随时按其 <code>name</code>、<code>id</code> 或与其关联的 <code>tag</code> 在 <code>WorkManager</code> 中进行查询，以检查其状态。</p>
<pre class="line-numbers"><code class="language-kotlin">
// by id
workManager.getWorkInfoById(syncWorker.id) // ListenableFuture&lt;WorkInfo&gt;

// by name
workManager.getWorkInfosForUniqueWork(&quot;sync&quot;) // ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;

// by tag
workManager.getWorkInfosByTag(&quot;syncTag&quot;) // ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;
</code></pre>
<p>该查询会返回 WorkInfo 对象的 ListenableFuture，该值包含工作的 id、其标记、其当前的 State 以及通过 Result.success(outputData) 设置的任何输出数据。</p>
<p>利用每个方法的 LiveData 变种，您可以通过注册监听器来观察 WorkInfo 的变化。例如，如果您想要在某项工作成功完成后向用户显示消息，您可以进行如下设置：</p>
<pre class="line-numbers"><code class="language-kotlin">workManager.getWorkInfoByIdLiveData(syncWorker.id)
               .observe(viewLifecycleOwner) { workInfo -&gt;
   if(workInfo?.state == WorkInfo.State.SUCCEEDED) {
       Snackbar.make(requireView(),
      R.string.work_completed, Snackbar.LENGTH_SHORT)
           .show()
   }
}
</code></pre>
<h4><a id="%E5%A4%8D%E6%9D%82%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复杂的工作查询</h4>
<p>使用 WorkQuery 对象对已加入队列的作业进行复杂查询。WorkQuery 支持按工作的标记、状态和唯一工作名称的组合进行查询。</p>
<p>以下示例说明了如何查找带有“syncTag”标记、处于 FAILED 或 CANCELLED 状态，且唯一工作名称为“preProcess”或“sync”的所有工作。</p>
<pre class="line-numbers"><code class="language-kotlin">val workQuery = WorkQuery.Builder
       .fromTags(listOf(&quot;syncTag&quot;))
       .addStates(listOf(WorkInfo.State.FAILED, WorkInfo.State.CANCELLED))
       .addUniqueWorkNames(listOf(&quot;preProcess&quot;, &quot;sync&quot;)
    )
   .build()

val workInfos: ListenableFuture&lt;List&lt;WorkInfo&gt;&gt; = workManager.getWorkInfos(workQuery)
</code></pre>
<h4><a id="%E5%8F%96%E6%B6%88%E5%92%8C%E5%81%9C%E6%AD%A2%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>取消和停止工作</h4>
<p>如果您不再需要运行先前加入队列的工作，则可以要求将其取消。您可以按工作的 name、id 或与其关联的 tag 取消工作。</p>
<pre class="line-numbers"><code class="language-kotlin">// by id
workManager.cancelWorkById(syncWorker.id)

// by name
workManager.cancelUniqueWork(&quot;sync&quot;)

// by tag
workManager.cancelAllWorkByTag(&quot;syncTag&quot;)
</code></pre>
<p><code>WorkManager</code> 会在后台检查工作的 <code>State</code>。如果工作已经完成，系统不会执行任何操作。否则，工作的状态会更改为 <code>CANCELLED</code>，之后就不会运行这个工作。任何依赖于此工作的 <code>WorkRequest</code> 作业也将变为 <code>CANCELLED</code>。</p>
<h4><a id="%E5%81%9C%E6%AD%A2%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>停止正在运行的工作器</h4>
<p>正在运行的 Worker 可能会由于以下几种原因而停止运行：</p>
<ul>
<li>您明确要求取消它（例如，通过调用 WorkManager.cancelWorkById(UUID) 取消）。</li>
<li>如果是唯一工作，您明确地将 ExistingWorkPolicy 为 REPLACE 的新 WorkRequest 加入到了队列中。旧的 WorkRequest 会立即被视为已取消。</li>
<li>您的工作约束条件已不再满足。</li>
<li>系统出于某种原因指示您的应用停止工作。如果超过 10 分钟的执行期限，可能会发生这种情况。该工作会调度为在稍后重试。</li>
</ul>
<p>在这些情况下，您的工作器会停止。</p>
<p>您应该合作地取消正在进行的任何工作，并释放您的工作器保留的所有资源。例如，此时应该关闭所打开的数据库和文件句柄。有两种机制可让您了解工作器何时停止。</p>
<h4><a id="onstopped%E5%9B%9E%E8%B0%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>onStopped() 回调</h4>
<p>在您的工作器停止后，WorkManager 会立即调用 ListenableWorker.onStopped()。替换此方法可关闭您可能保留的所有资源。</p>
<p><strong>isStopped() 属性</strong><br />
您可以调用 ListenableWorker.isStopped() 方法以检查工作器是否已停止。如果您在工作器中执行长时间运行的操作或重复操作，您应经常检查此属性，并尽快将其用作停止工作的信号。</p>
<h3><a id="%E9%93%BE%E6%8E%A5%E5%B7%A5%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>链接工作</h3>
<p>使用 WorkManager 创建工作链并将其加入队列。工作链用于指定多个依存任务并定义这些任务的运行顺序。当您需要以特定顺序运行多个任务时，此功能尤其有用。</p>
<p>如需创建工作链，您可以使用 WorkManager.beginWith(OneTimeWorkRequest) 或 WorkManager.beginWith(List<OneTimeWorkRequest>)，这会返回 WorkContinuation 实例。</p>
<p>然后，可以使用 WorkContinuation 通过 then(OneTimeWorkRequest) 或 then(List<OneTimeWorkRequest>) 添加依存 OneTimeWorkRequest。 .</p>
<p>每次调用 WorkContinuation.then(...) 都会返回一个新的 WorkContinuation 实例。如果添加了 OneTimeWorkRequest 实例的 List，这些请求可能会并行运行。</p>
<p>最后，您可以使用 WorkContinuation.enqueue() 方法对 WorkContinuation 工作链执行 enqueue() 操作。</p>
<p>WorkManager 允许我们按照一定的顺序执行任务，比如我想 A、B、C 三个任务按先后顺序执行：</p>
<p><figure><img src="media/16066640335833/16066686325006.png" alt="" /></figure></p>
<pre class="line-numbers"><code class="language-java"> OneTimeWorkRequest requestA = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
        OneTimeWorkRequest requestB = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
        OneTimeWorkRequest requestC = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
        WorkManager.getInstance(PublishActivity.this).beginWith(requestA).then(requestB).then(requestC).enqueue();
</code></pre>
<p>这样的话，上一个任务的 outputData 会成为下一个任务的 inputData。</p>
<p>更复杂一点<br />
<figure><img src="media/16066640335833/16066686969137.png" alt="" /></figure></p>
<pre class="line-numbers"><code class="language-java">OneTimeWorkRequest requestA = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
OneTimeWorkRequest requestB = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
OneTimeWorkRequest requestC = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
OneTimeWorkRequest requestD = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
OneTimeWorkRequest requestE = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();

WorkContinuation chainA = WorkManager.getInstance(PublishActivity.this).beginWith(requestA).then(requestB);
WorkContinuation chainB = WorkManager.getInstance(PublishActivity.this).beginWith(requestC).then(requestD);

List&lt;WorkContinuation&gt; chains =new ArrayList&lt;&gt;();
        chains.add(chainA);
        chains.add(chainB);
        
WorkContinuation.combine(chains).then(requestE).enqueue();
</code></pre>
<h3><a id="%E8%A7%82%E5%AF%9F%E5%B7%A5%E4%BD%9C%E5%99%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%BF%9B%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>观察工作器的中间进度</h3>
<p>如果应用在前台运行时，工作器保持运行状态，也可以使用返回 WorkInfo 的 LiveData 的 API 向用户显示此信息。</p>
<h4><a id="%E6%9B%B4%E6%96%B0%E8%BF%9B%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更新进度</h4>
<p>对于使用 ListenableWorker 或 Worker 的 Java 开发者，setProgressAsync() API 会返回 ListenableFuture<Void>；更新进度是异步过程，因为更新过程包括将进度信息存储在数据库中。在 Kotlin 中，您可以使用 CoroutineWorker 对象的 setProgress() 扩展函数来更新进度信息。</p>
<p>此示例展示了一个简单的 ProgressWorker。该 Worker 启动时将进度设置为 0，完成时将进度值更新为 100。</p>
<pre class="line-numbers"><code class="language-kotlin">    import android.content.Context
    import androidx.work.CoroutineWorker
    import androidx.work.Data
    import androidx.work.WorkerParameters
    import kotlinx.coroutines.delay

    class ProgressWorker(context: Context, parameters: WorkerParameters) :
        CoroutineWorker(context, parameters) {

        companion object {
            const val Progress = &quot;Progress&quot;
            private const val delayDuration = 1L
        }

        override suspend fun doWork(): Result {
            val firstUpdate = workDataOf(Progress to 0)
            val lastUpdate = workDataOf(Progress to 100)
            setProgress(firstUpdate)
            delay(delayDuration)
            setProgress(lastUpdate)
            return Result.success()
        }
    }
</code></pre>
<h4><a id="%E8%A7%82%E5%AF%9F%E8%BF%9B%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>观察进度</h4>
<p>观察进度信息也很简单。您可以使用 getWorkInfoBy…() 或 getWorkInfoBy…LiveData() 方法，并引用 WorkInfo。</p>
<pre class="line-numbers"><code class="language-kotlin"> WorkManager.getInstance(applicationContext)
        // requestId is the WorkRequest id
        .getWorkInfoByIdLiveData(requestId)
        .observe(observer, Observer { workInfo: WorkInfo? -&gt;
                if (workInfo != null) {
                    val progress = workInfo.progress
                    val value = progress.getInt(Progress, 0)
                    // Do something with progress information
                }
        })
</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16084837942987.html" 
          title="Previous Post: Cocos Creator开发记录">&laquo; Cocos Creator开发记录</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="16039421034043.html" 
          title="Next Post: CentOS服务器维护">CentOS服务器维护 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/16898402251241/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
