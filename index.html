<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15663678647312.html">
                
                  <h1>Docker学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>最近要搞微服务，学习了很多，发现网上对使用Docker进行部署推崇备至，而且之前也用过Docker来搭建Maven私有仓库和Redis，觉得学习下整理一篇博客还是蛮有必要的哈哈。</p>

<h2 id="toc_0">应用场景</h2>

<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>

<h2 id="toc_1">CentOs安装Docker</h2>

<p>看了网上很多教程，发现没有说的那么麻烦，还是很传统的下载安装方式。</p>

<ul>
<li>先进行yum更新<code>yum update</code></li>
<li>使用yum命令进行安装<code>yum install -y docker</code>(备注：-y 表示不询问 使用默认配置进行安装，等待提示  完毕！)</li>
<li>查看是否安装成功<code>yum list installed | grep docker</code>(备注：命令为 查看yum安装完成文件列表 并 筛选docker安装信息)</li>
<li>启动docker服务<code>systemctl start docker</code></li>
<li>查看是否启动成功<code>systemctl status docker</code></li>
<li>使用docker命令 <code>docker images</code>(备注：查看docker已经安装的镜像 裸机状态下为空)</li>
</ul>

<h2 id="toc_2">Docker常用命令</h2>

<h3 id="toc_3">从docker仓库搜索镜像</h3>

<pre><code class="language-bash">docker search [镜像名称]
</code></pre>

<h3 id="toc_4">拉取镜像</h3>

<pre><code class="language-bash">docker image pull 镜像名称:版本号 # 不指定版本默认为最新版
</code></pre>

<h3 id="toc_5">删除镜像</h3>

<pre><code class="language-bash">docker image rm 镜像名称/镜像ID
</code></pre>

<h3 id="toc_6">查看本地镜像</h3>

<pre><code class="language-bash">docker images
</code></pre>

<h3 id="toc_7">重命名镜像</h3>

<pre><code class="language-bash">docker tag [old_name] [new_name]
</code></pre>

<h3 id="toc_8">创建容器</h3>

<pre><code class="language-bash">docker run [option] 镜像名 [向启动容器中传入的命令]
</code></pre>

<p>[option]常用可选参数说明：</p>

<ul>
<li>-i 表示以“交互模式”运行容器,与容器交互</li>
<li>-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</li>
<li>–name 为创建的容器命名</li>
<li>-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</li>
<li>-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</li>
<li>-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</li>
<li>-e 为容器设置环境变量</li>
<li>–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同 </li>
<li>-rm 在容器退出时，自动删除其缓存</li>
</ul>

<pre><code class="language-bash">sudo docker run -it –name=ubuntu1 113a43faa138 /bin/bash

# -it 创建一个伪终端交互界面，name指定容器名称，否则随机一个名字 113a43faa138 镜像id /bin/bash 创建后执行的命令 
</code></pre>

<pre><code class="language-bash">sudo docker run -dit --name=ubuntu -v ~/Desktop/ceshi:/ceshi ubuntu
# -v &lt;本机目录:容器目录&gt;创建一个共享目录，左边是本机的目录，右边是容器中的目录，在本机修改内容对应的容器中的目录内容也会改变, 目录不存在会自动创建
</code></pre>

<h3 id="toc_9">查看所有容器</h3>

<pre><code class="language-bash">sudo docker container ls #查看所有正在运行的容器
sudo docker container ls --all # 查看所有已创建的容器
</code></pre>

<ul>
<li>container id 容器id</li>
<li>image 镜像名称</li>
<li>command 创建后运行的命令</li>
<li>created 创建时间</li>
<li>status 关闭时间</li>
<li>ports 绑定的端口</li>
<li>names 容器名称</li>
</ul>

<h3 id="toc_10">运行已经开启的容器</h3>

<pre><code class="language-bash">sudo docker container exec -it &lt;容器名/id&gt; &lt;运行后使用的第一个命令&gt;
# 运行使用的第一个命令一般默认为 /bin/bash 否则无法进入交互界面
</code></pre>

<h3 id="toc_11">停止与启动容器</h3>

<pre><code class="language-bash"># 停止一个已经在运行的容器
sudo docker container stop [容器名或容器id]

# 启动一个已经停止的容器
sudo docker container start [容器名或容器id]

# kill掉一个已经在运行的容器
sudo docker container kill [容器名]
</code></pre>

<h3 id="toc_12">删除容器</h3>

<pre><code class="language-bash">docker container rm [容器名或容器id]
</code></pre>

<h3 id="toc_13">容器保存为镜像</h3>

<pre><code class="language-bash">sudo docker commit [容器名] [镜像]名
sudo docker commit ubuntu1 myubuntu  # 将容器名为ubuntu1的容器转换为叫myuntu的镜像，原本的容器并不会删除
</code></pre>

<h4 id="toc_14">镜像打包成文件</h4>

<pre><code class="language-bash">sudo docker save -o 保存的文件名 镜像名
sudo docker save -o ./ubuntu.tar ubuntu
</code></pre>

<h4 id="toc_15">将镜像加载到本地</h4>

<pre><code class="language-bash">sudo docker load -i  &lt;文件名&gt;
sudo docker load -i ./ubuntu.tar
</code></pre>

<h2 id="toc_16">Dockerfile</h2>

<p>Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。</p>

<h3 id="toc_17">Dockerfile的格式</h3>

<ol>
<li>#用来表示注释。</li>
<li>指令大小写不敏感，一般大写，参数小写。</li>
<li>Docker顺序执行Dockerfile中的指令来构建image。</li>
<li>第一个指令以&quot;From&quot;开始。</li>
<li>Dockerfile文件名首字母必须大写。</li>
</ol>

<h3 id="toc_18">工作目录</h3>

<p>Dockerfile在制作过程中，所有相关的文件都需要在一个文件夹中，这个文件夹叫做工作目录，Dockerfile所在的目录及其子目录。</p>

<pre><code class="language-text">mkdir /tmp/image1
cd /tmp/image1
</code></pre>

<h3 id="toc_19">Dockerfile指令</h3>

<h4 id="toc_20">FROM命令</h4>

<p>除了注释行外，Dockerfile的第一个命令。</p>

<pre><code class="language-text">FROM &lt;repository&gt;[:&lt;tag&gt;]
FROM &lt;repository&gt;@&lt;digest&gt;
  repository:指定base image的名称
  tag: 指定base image的标签
  digest：image的hashcode
</code></pre>

<h4 id="toc_21">LABLE命令</h4>

<p>用于提供Dockerfile制作者的信息，这个命令可以出现在任何位置，一般建议在FROM指令之后。用key value的形式来描述一个image的metadata。</p>

<pre><code class="language-text">LABLE &lt;key&gt;=&lt;value&gt;
例如：
LABLE maintainer=&quot;leveldc&lt;leveldc@126.com&gt;&quot;
</code></pre>

<h4 id="toc_22">COPY命令</h4>

<p>用于从宿主机复制文件到镜像文件。</p>

<pre><code class="language-text">COPY &lt;src&gt;...&lt;dist&gt;
COPY [&quot;&lt;src&gt;&quot;,...&quot;&lt;dist&gt;&quot;]
  src:  复制文件的源文件或目录，支持通配符
  dist: 目标路径
说明：
1. &lt;src&gt;必须是build的上下文中的路径，不能是其父目录的文件。
2. 如果&lt;src&gt;是目录，其内部文件及子目录会被递归复制，&lt;src&gt;本身不会被复制。
3. 如果指定了多个&lt;src&gt;或在&lt;src&gt;中使用了通配符，则&lt;dist&gt;必须是一个目录，且以/结束。
4. 如果&lt;dist&gt;不存在，会被自动创建，包括其父目录。
例如：
COPY index.html /data/web/html
</code></pre>

<h4 id="toc_23">ADD命令</h4>

<p>类似COPY命令， 支持TAR文件或者TAR.gz和URL路径。<br/>
TAR:拷贝本地的tar文件会自动解压缩到docker镜像中。<br/>
URL:拷贝服务器地址上的文件并将文件添加到docker 镜像中。</p>

<pre><code class="language-text">ADD &lt;src&gt;...&lt;dist&gt;
ADD [&quot;&lt;src&gt;&quot;,...&quot;&lt;dist&gt;&quot;]
  src:  添加文件的源文件或目录，支持通配符
  dist: 目标路径
说明：
1. 如果&lt;src&gt;为URL且&lt;dist&gt;不以/结尾则&lt;src&gt;指定的文件将被直接下载并创建为&lt;dist&gt;;如果以/结尾，则文件被拷贝至&lt;dist&gt;/&lt;filename&gt;
2. 如果&lt;src&gt;是本地tar文件，则被展开为一个目录，如果是一个URL的tar文件，则不会自动展开。
3. 如果&lt;src&gt;有多个，则dist需要以/结尾，否则将会把src的内容直接写进&lt;dist&gt;。
例如：
ADD http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.37/bin/apache-tomcat-8.5.37.tar.gz /usr/local/src/
ADD apache-tomcat-8.5.37.tar.gz /usr/local/src/
</code></pre>

<h4 id="toc_24">WORKDIR命令</h4>

<p>指定Docker镜像中的工作路径，可以定义多次，命令执行的时候以最新定义的一次为准。<br/>
例如:<code>WORKDIR /usr/local/</code></p>

<h4 id="toc_25">VOLUME命令</h4>

<p>Dockerfile中的卷只能设置容器中的挂载点目录，只能设置docker管理的卷。<br/>
例如:<code>VOLUME /data/mysql</code></p>

<h4 id="toc_26">EXPOSE命令</h4>

<p>为容器打开指定要监听的端口来和外部通信。</p>

<pre><code class="language-text">EXPOSE &lt;port&gt;[/&lt;protocol&gt;][&lt;port&gt;[&lt;/protocol&gt;]]
protocol:传输协议，tcp/udp, 默认tcp.
可以一次指定多个端口,例如:
`EXPOSE 32332/udp 32332/tcp`

这里的端口并不会直接暴露给宿主机，而是以启动docker容器时候的参数来决定。
docker run -p/-P
</code></pre>

<h4 id="toc_27">ENV命令</h4>

<p>定义Dockerfile的环境变量，可以被在Dockfile ENV命令后面的其他命令引用。</p>

<pre><code class="language-text"> ENV &lt;key&gt; &lt;value&gt;
  ENV &lt;key&gt;=&lt;value&gt; ...
  说明:
  1.第一种格式key后面的所有内容都被认为是value，只可以定义一个
  2.第二种格式可以定义多个&lt;key&gt;=&lt;value&gt;, 如果value中有空格，需要加&quot;\&quot;进行转义，也可以对value加双引号。另外反斜杠可以用来表示续行。
  建议使用第二种。
  3.Dockerfile中定义的ENV可以在启动容器以后直接使用，在运行为容器的时候通过-e参数可以重新给变量赋值。要分清什么参数是在build阶段的，什么是在容器启动阶段。
</code></pre>

<h4 id="toc_28">RUN命令</h4>

<p>RUN命令时基于基础镜像所提供的命令来运行，发生在创建镜像的过程中。目的是为了创建镜像。<br/>
RUN 命令如果执行了yum，需要在安装完成后删除缓存以减小镜像大小。</p>

<pre><code class="language-text">RUN &lt;command&gt;
RUN [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]

说明:
第一种默认启动为/bin/sh 子进程。
第二种执行方式是由linux直接来执行，没有/bin/sh,所以不支持shell的语法，如果需要可以使用:
RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;]来执行。
例如:
RUN cd /usr/local/src/ &amp;&amp; \
    tar -xf  ${WEB_SERVER_VERSION}
</code></pre>

<h4 id="toc_29">CMD命令</h4>

<p>CMD命令发生在容器启动时,当一个镜像文件被创建为容器的时候执行,一个容器默认只启动一个进程，所以一个Dockerfile中只可以有一个CMD,如果有多个，则最后一个生效用来指定容器启动时默认执行的程。</p>

<pre><code class="language-text">CMD &lt;command&gt;
CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
说明:
在执行docker run命令的时候，可以指定新的命来来覆盖CMD的内容。如果docker在启动的时候不希望接受命令行输入的命令，可以使用ENTRYPOINT.
</code></pre>

<h4 id="toc_30">ENTRYPOINT命令</h4>

<p>和CMD功能类似，但是不接受在docker run的时候修改启动命令，docker run的参数只能以变量的形式传给ENTRYPOINT定义的启动程序。</p>

<p>如果需要改变，需要在docker run的时候指定 --entrypoints参数。</p>

<p>ENTRYPOINT用来支持多环境</p>

<h4 id="toc_31">USER命令</h4>

<p>用于指定运行image或运行Dockerfile中的RUN CMD ENTRYPOINT指令指定的程序时的用户名或者UID。</p>

<pre><code class="language-text">USER &lt;UID&gt;|&lt;UserName&gt;
CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
</code></pre>

<h4 id="toc_32">HEALTHCHECK命令</h4>

<p>容器健康检测</p>

<pre><code class="language-text">HEALTHCHECK [OPTIONS] CMD command
OPTIONS：
  --interval=DURATION(间隔多久检测)
  --timeout=DURATION(检测超时)
  --start-period=DURATION(等待多久开始检测，default=0)
  --retries=N(default=3)
  returns:
  0:success
  1:unhealthy
  2:reserved
  例如:
  HEALTHCHECK --interval=5m --timeout=30s CMD curl -f http://localhost/ || exit 1
</code></pre>

<h4 id="toc_33">SHELL命令</h4>

<p>镜像默认的shell</p>

<pre><code class="language-text">SHELL [&quot;executable&quot;,&quot;parameters&quot;]
</code></pre>

<h4 id="toc_34">STOPSIGNAL命令</h4>

<p>进程为1的命令可以接受docker stop命令,主进程停止，容器就停止。</p>

<h4 id="toc_35">ARG命令</h4>

<p>在build的过程中起作用，使一个dockerfile可以适用多个环境，用法和ENV类似，但是起作用的时间不一样。该变量可以通过 build --arg参数修改。</p>

<h4 id="toc_36">ONBUILD命令</h4>

<p>在Dockerfile中定义一个并发器，当别的镜像是基于有ONBUILD的镜像构建新的镜像的时候，会触发ONBOUILD指令</p>

<pre><code class="language-text">ONBUILD&lt;INSTRUCTION&gt;
</code></pre>

<h4 id="toc_37">docker buld</h4>

<p>创建docker镜像</p>

<pre><code class="language-text">docker build [OPTIONS] PATH | URL | -
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15662718181666.html">
                
                  <h1>Android GRPC接入</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">安装Protobuf插件</h2>

<p>Protobuf Support插件可以支持Protobuf文件高亮语法显示</p>

<p><img src="media/15662718181666/15662727464652.png" alt="" style="width:582px;"/></p>

<h2 id="toc_1">添加Grpc依赖</h2>

<ul>
<li>项目根目录build.gradle添加</li>
</ul>

<pre><code class="language-groovy">buildscript {
    ext.kotlin_version = &#39;1.3.41&#39;
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.4.2&#39;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
        //添加这句
        classpath &quot;com.google.protobuf:protobuf-gradle-plugin:0.8.10&quot;
    }
}
</code></pre>

<ul>
<li>在Module下build.gradle添加<code>apply plugin: &#39;com.google.protobuf&#39;</code></li>
<li>设置proto文件位置(src/main/proto):</li>
</ul>

<pre><code class="language-groovy">android {
    sourceSets {
        main {
            proto {
                srcDir &#39;src/main/proto&#39;
            }
            java {
                srcDir &#39;src/main/java&#39;
            }
        }
    }
}
</code></pre>

<ul>
<li>自定义Protobuf编译项</li>
</ul>

<pre><code class="language-groovy">protobuf {
    protoc { artifact = &#39;com.google.protobuf:protoc:3.9.1&#39; }
    plugins {
        javalite { artifact = &quot;com.google.protobuf:protoc-gen-javalite:3.0.0&quot; }
        grpc { artifact = &#39;io.grpc:protoc-gen-grpc-java:1.22.1&#39; }
    }
    generateProtoTasks {
        all().each { task -&gt;
            task.plugins {
                javalite {}
                grpc { option &#39;lite&#39; }
            }
        }
    }
    generatedFilesBaseDir = &quot;$projectDir/src/generated&quot;
}

clean {
    delete &quot;${projectDir}/src/main/generated-proto&quot;
}
</code></pre>

<ul>
<li>加入grpc依赖</li>
</ul>

<pre><code class="language-groovy">implementation &#39;io.grpc:grpc-okhttp:1.22.1&#39;
implementation &#39;io.grpc:grpc-protobuf-lite:1.22.1&#39;
implementation &#39;io.grpc:grpc-stub:1.22.1&#39;
implementation &#39;javax.annotation:javax.annotation-api:1.3.2&#39;
</code></pre>

<ul>
<li>Rebuild Project之后就会自动生成代码</li>
</ul>

<h2 id="toc_2">Protobuf语法</h2>

<h3 id="toc_3">关键字</h3>

<ul>
<li>syntax：声明版本。例如上面syntax=&quot;proto3&quot;，如果没有声明，则默认是proto2。</li>
<li>package：声明包名.</li>
<li>import：导入包。类似于java，例如上面导入了timestamp.proto包。</li>
<li>java_package：指定生成的类应该放在什么Java包名下。如果你没有显式地指定这个值，则它简单地匹配由package 声明给出的Java包名，但这些名字通常都不是合适的Java包名 (由于它们通常不以一个域名打头)。</li>
<li>java_outer_classname：定义应该包含这个文件中所有类的类名。如果你没有显式地给定java_outer_classname ，则将通过把文件名转换为首字母大写来生成。例如上面例子编译生成的文件名和类名是AddressBookProtos。</li>
<li>message：类似于java中的class关键字。</li>
<li>repeated：用于修饰属性，表示对应的属性是个array。</li>
</ul>

<h3 id="toc_4">Android中使用</h3>

<p>创建Proto文件</p>

<pre><code class="language-protobuf">syntax = &quot;proto3&quot;;

option java_multiple_files = true;
option java_package = &quot;com.ifantastic.helloworld&quot;;
option java_outer_classname = &quot;HelloWorldProto&quot;;

package helloworld;

message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
}

service Greeter {
    rpc SayHello(HelloRequest) returns (HelloReply);
}
</code></pre>

<p>Rebuild之后开始调用</p>

<ul>
<li><p>创建连接通道</p>
<pre><code class="language-kotlin">val connectionChannel: ManagedChannel by lazy {
    OkHttpChannelBuilder.forAddress(&quot;192.168.6.104&quot;, 9090)<br/>
        .usePlaintext()<br/>
        .build()<br/>
}
</code></pre></li>
<li><p>声明Service</p>
<pre><code class="language-kotlin">val service = GreeterGrpc.newBlockingStub(connectionChannel)
</code></pre></li>
<li><p>Grpc请求</p>
<pre><code class="language-kotlin">val requestMessage = HelloRequest.newBuilder()
        .setName(name)<br/>
        .build()      <br/>
val response = service.sayHello(requestMessage)
</code></pre></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/8/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15662693410122.html">
                
                  <h1>Docker搭建Maven私服</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>由于Gradle和Maven依赖方式不一样，没法进行本地项目依赖，所以需要把Gradle项目打包发布到Maven仓库。发布到公共仓库又不太好，所以决定搭建个私有仓库，刚好家里有群辉Synology DS918+，可以通过Docker来搭建Maven私服。</p>

<h2 id="toc_0">安装Nexus</h2>

<p>群辉上的Docker通过图形化的界面进行操控，所以不需要进行命令行操作。</p>

<ul>
<li><p>在注册表中搜索Nexus，对sonatype/nexus3项目进行双击下载映像。<br/>
<img src="media/15662693410122/66FBF341-A2A8-43AC-8920-82E09879443C.png" alt=""/></p></li>
<li><p>在映像中双击sonatype/nexus3创建容器，编辑nexus设置，启用自动重新启动和创建桌面快捷方式<img src="media/15662693410122/07013229-CA0A-45AB-9035-DF3A95145BE2.png" alt=""/></p></li>
<li><p>在卷中添加映射文件夹 本地文件路径 / 装载路径(/var/nexus-data)<br/>
<img src="media/15662693410122/3E47DC7A-E1E8-4E8B-8325-5E482631797E.png" alt=""/></p></li>
<li><p>进行端口映射,将本地端口映射到容器端口.<img src="media/15662693410122/96660F1B-0E55-4DEB-AF78-BC29526F79E8.png" alt=""/></p></li>
<li><p>启动Nexus，点击桌面的Nexus快捷启动或者通过<code>http://ip:8081</code>，打开Nexus网址。<br/>
<img src="media/15662693410122/15662707547156.png" alt=""/></p></li>
<li><p>点击右上方的Sign in进行登录，初始账号为admin，初始密码通过容器的详情里终端查看admin.password里的密码.登录后修改密码<br/>
<img src="media/15662693410122/15662707441848.jpg" alt=""/></p></li>
<li><p>可以看到默认情况下<code>Nexus</code>会帮我们创建了几个仓库，仔细观察红色框住的地方，里面有几种仓库的类型，解释如下：</p>
<ul>
<li><code>proxy</code>远程仓库的代理，比如说<code>nexus</code>配置了一个<code>central repository</code>的<code>proxy</code>,当用户向这个proxy请求一个<code>artifact</code>的时候，会现在本地查找，如果找不到，则会从远程仓库下载，然后返回给用户。</li>
<li><code>hosted</code>宿主仓库，用户可以把自己的一些仓库<code>deploy</code>到这个仓库中</li>
<li><code>group</code>仓库组，是<code>nexus</code>特有的概念，目的是将多个仓库整合，对用户暴露统一的地址，这样就不需要配置多个仓库地址。</li>
</ul></li>
<li><p>下面我们仔细看一下里面的一些仓库。点击<code>maven-central</code>仓库: <br/>
<img src="media/15662693410122/15662710138140.jpg" alt=""/><br/>
可以看到是一个<code>proxy</code>类型的仓库，他代理的远程仓库地址是<code>https://repo1.maven.org/maven2/</code>。</p></li>
<li><p>后退，在进入<code>maven-public</code>查看: <br/>
<img src="media/15662693410122/15662710448726.png" alt=""/><br/>
可以看到这是一个<code>group</code>类型的仓库，里面包含了<code>maven-releases/maven-snapshots/maven-central</code>仓库，意思是我们只需要在本地添加这个仓库，则可以依赖到上述3个仓库中的库了。</p></li>
</ul>

<h2 id="toc_1">创建仓库</h2>

<ul>
<li><p><strong>创建仓库</strong><br/>
点击<code>Create repository</code>,然后选择<code>maven2(hosted)</code>然后输入仓库名称<code>（test-release）</code>。在<code>version policy</code>中选择这个仓库的类型，这里选择<code>release</code>,在<code>Deployment policy</code>中选择<code>Allow redeploy</code><br/>
<img src="media/15662693410122/15662711396304.png" alt=""/></p></li>
<li><p><strong>创建用户</strong><br/>
点击左侧菜单栏的Users菜单，然后点击Create local user.我这里创建了一个用户，账号密码都是：wangjianfeng <br/>
<img src="media/15662693410122/15662712072619.jpg" alt=""/></p></li>
</ul>

<h2 id="toc_2">Java Gradle项目上传</h2>

<p>在build.gradle中添加<code>maven-publish</code>插件</p>

<pre><code class="language-groovy">plugins {
    id &quot;maven-publish&quot;
}
</code></pre>

<p>设置插件参数</p>

<pre><code class="language-groovy">//打包源码
task sourceJar(type: Jar) {
    from sourceSets.main.allSource
}

publishing {
    publications {
        maven(MavenPublication) {
            //指定group/artifact/version信息，可以不填。默认使用项目group/name/version作为groupId/artifactId/version
            groupId project.group
            artifactId project.name
            version project.version
            //如果是war包填写components.web，如果是jar包填写components.java
            from components.java

            //配置上传源码
            artifact sourceJar {
                classifier &quot;sources&quot;
            }

        }
    }
    repositories {
        maven {
            //指定要上传的maven私服仓库
            url = &quot;http://你的maven私服地址/repository/maxrocky/&quot;
            //认证用户和密码
            credentials {
                username &#39;admin&#39;
                password &#39;admin123&#39;
            }
        }
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/8/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15639522586909.html">
                
                  <h1>Kotlin为序列化类生成serialVersionUID</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>一般在Intellij Idea使用过程中，为Java序列化类自动生成serialVersionUID可以通过Inspections配置来完成<br/>
<img src="media/15639522586909/15639527631359.jpg" alt=""/></p>

<pre><code class="language-text">Preferences -&gt; Inspections -&gt; Serialization issues -&gt; Serialization class without &#39;serialVersionUID&#39;
</code></pre>

<p>将光标放到类名上，按<code>atl＋enter</code>键，就会提示生成serialVersionUID了</p>

<p><img src="media/15639522586909/15639527944558.jpg" alt=""/></p>

<p>或者使用插件<strong>GenerateSerialVersionUID</strong>就能通过快捷键快速生成serialVersionUID</p>

<p>然而在Kotlin环境下，以上配置无效</p>

<p><strong>解决方案如下：</strong><br/>
利用serialver命令生成serialVersionUID</p>

<ul>
<li>Preferences -&gt; Tools -&gt; External Tools</li>
<li>添加新的tools</li>
<li>Name就设置为serialver</li>
<li>Program中选择serialver命令所在的路径，macOS下一般为<code>/usr/bin/serialver</code></li>
<li>Arguments设置为 <code>-classpath$OutputPath$:$Classpath$ $FileFQPackage$.$FileNameWithoutAllExtensions$</code></li>
<li>点击保存以上配置</li>
</ul>

<p>Ok,现在就可以生成serialVersionUID了。首先编译一下，让要生成serialVersionUID的类生成对应的class文件，然后在类的编辑窗口中右键选择external tools &gt; serialver，这时console窗口出就生成了这个类的serialVersionUID了。</p>

<blockquote>
<p>另：kotlin中没有Java的static关键字，所以serialVersionUID属性是以伴生对象属性存在的</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/7/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='JavaWeb.html'>JavaWeb</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15620327900428.html">
                
                  <h1>Xposed开发</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Xposed SDK下载</h2>

<p><a href="http://dl-xda.xposed.info/framework/sdk21/x86/">地址</a></p>

<h2 id="toc_1">Xposed API</h2>

<p><a href="https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html">地址</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/7/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15620314685082.html">
                
                  <h1>Genymotion-ARM-Translation.zip各安卓版本合集</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<table>
<thead>
<tr>
<th style="text-align: left">安卓版本</th>
<th style="text-align: left">代号</th>
<th style="text-align: left">Genymotion-ARM-Translation</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">8.0 – 8.1</td>
<td style="text-align: left">Oreo奥利奥</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Oreo8.0-8.1/ARM_Translation_Oreo.zip">ARM_Translation_Oreo.zip</a></td>
</tr>
<tr>
<td style="text-align: left">7.0 – 7.1.2</td>
<td style="text-align: left">Nougat牛轧糖</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">6.0 – 6.0.1</td>
<td style="text-align: left">Marshmallow棉花糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Marshmallow6.0-6.0.1/ARM_Translation_Marshmallow.zip">ARM_Translation_Marshmallow.zip</a></td>
</tr>
<tr>
<td style="text-align: left">5.0 – 5.1.1</td>
<td style="text-align: left">Lollipop棒棒糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Lollipop5.0-5.1.1/ARM_Translation_Lollipop_20160402.zip">ARM_Translation_Lollipop_20160402.zip</a></td>
</tr>
<tr>
<td style="text-align: left">5.0 – 5.1.1</td>
<td style="text-align: left">Lollipop棒棒糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Lollipop5.0-5.1.1/ARM_Translation_Lollipop.zip">ARM_Translation_Lollipop.zip</a></td>
</tr>
<tr>
<td style="text-align: left">4.4 – 4.4.4</td>
<td style="text-align: left">KitKat奇巧巧克力</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/KitKat4.4-4.4.4/ARM-4.4-libhoudini.zip">ARM-4.4-libhoudini.zip</a></td>
</tr>
<tr>
<td style="text-align: left">4.1 – 4.3.1</td>
<td style="text-align: left">Jelly Bean果冻豆</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/JellyBean4.1-4.3.1/Genymotion-ARM-Translation_v1.1.zip">Genymotion-ARM-Translation_v1.1.zip</a></td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/7/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15615956474579.html">
                
                  <h1>ReactNative打包与发布</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">iOS</h2>

<h3 id="toc_1">生成bundle文件</h3>

<pre><code class="language-text">react-native bundle --entry-file index.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/6/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html'>跨平台开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15615956237705.html">
                
                  <h1>CodePush集成与热更新</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。<br/>
CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。CodePush 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。</p>

<h2 id="toc_1">安装与使用</h2>

<p>使用CodePush之前首先要安装CodePush客户端。</p>

<h3 id="toc_2">安装 CodePush CLI</h3>

<ul>
<li>安装客户端<code>npm install -g code-push-cli</code></li>
<li>查看版本号<code>code-push -v</code></li>
<li>注册CodePush账号<code>code-push register</code>授权通过之后，CodePush会告诉你“access key”，复制此key到终端即可完成注册。</li>
<li>登录<code>code-push login</code>登陆成功后，你的session文件将会写在 /Users/你的用户名/.code-push.config。</li>
</ul>

<p>PS.相关命令</p>

<ul>
<li><code>code-push login</code> 登陆</li>
<li><code>code-push logout</code> 注销</li>
<li><code>code-push access-key ls</code> 列出登陆的token</li>
<li><code>code-push access-key rm &lt;accessKye&gt;</code> 删除某个 access-key</li>
</ul>

<h3 id="toc_3">在CodePush服务器注册app</h3>

<p>为了让CodePush服务器知道你的app，我们需要向它注册app</p>

<ul>
<li>添加应用平台<code>code-push app add &lt;app_name&gt; &lt;os&gt; &lt;platform&gt;</code></li>
<li>添加部署环境<code>code-push deployment add &lt;app_name&gt; test</code></li>
</ul>

<p>PS.相关命令</p>

<ul>
<li><code>code-push app add</code> 在账号里面添加一个新的app</li>
<li><code>code-push app remove</code> 或者 <code>rm</code> 在账号里移除一个app</li>
<li><code>code-push app rename</code> 重命名一个存在app</li>
<li><code>code-push app list</code> 或者 <code>ls</code> 列出账号下面的所有app</li>
<li><code>code-push app transfer</code> 把app的所有权转移到另外一个账号</li>
<li><code>code-push deployment list &lt;app_name&gt; --format json</code> 查看APP的环境信息</li>
<li><code>code-push deployment clear &lt;app-name&gt;</code> 部署环境</li>
</ul>

<h4 id="toc_4">发布CodePush更新包</h4>

<p><code>code-push release-react &lt;Appname&gt; &lt;Platform&gt; --t &lt;本更新包面向的旧版本号&gt; --des &lt;本次更新说明&gt;</code></p>

<blockquote>
<p>注意： CodePush默认是更新Staging 环境的，如果发布生产环境的更新包，需要指定--d参数：--d Production，如果发布的是强制更新包，需要加上 --m true强制更新</p>
</blockquote>

<p><code>$ code-push release-react iOSRNHybrid ios --t 1.0.0 --dev false --d Production --des &quot;这是第一个更新包&quot; --m true<br/>
</code></p>

<ul>
<li>发布更新包命令中的 -- t 对应的参数是和我们项目中的版本号一致的，这个不要误理解为是更新包的版本号，例如项目中的版本号为1.0.0， 这时如果我们需要对这个1.0.0 版本的项目进行第一次热更新，那么命令中的 -- t 也为1.0.0，第二次热更新任然为1.0.0, --dev为是否启用开发者模式(默认为false), --d是要发布更新的环境分Production与Staging(默认为Staging)；--des为更新说明；--m 是强制更新。</li>
<li>项目的版本号需要改为三位的，默认是两位的，但是CodePush需要三位数的版本号</li>
<li>发布更新应用时，应用的名称必须要和之前注册过的应用名称一致</li>
</ul>

<h5 id="toc_5">查询Production</h5>

<p><code>code-push deployment history projectName Production</code></p>

<h5 id="toc_6">查询Staging</h5>

<p><code>code-push deployment history projectName Staging</code></p>

<h3 id="toc_7">ReactNative集成code-push</h3>

<h4 id="toc_8">安装组件</h4>

<p>项目根目录下 <code>yarn add react-native-code-push</code></p>

<h4 id="toc_9">添加依赖</h4>

<p><code>react-native react-native-code-push</code></p>

<h4 id="toc_10">RN端代码</h4>

<pre><code class="language-text">import CodePush from &quot;react-native-code-push&quot;;
let codePushOptions = { checkFrequency: CodePush.CheckFrequency.ON_APP_RESUME };
const deploymentKey = Platform.select({
    ios: &#39;XgBtruRnRtJKOjkwEZub2Q60mFys4ksvOXqog&#39;,
    android: &#39;fmrp3d8KiGKSyp23cXe26a9xEkHF4ksvOXqog&#39;,
});

class App extends Component&lt;Props&gt; {

    componentWillMount() {
        CodePush.disallowRestart();//禁止重启
        this.syncImmediate(); //开始检查更新
    }

    componentDidMount() {
        CodePush.allowRestart();//在加载完了，允许重启
    }

    //如果有更新的提示
    syncImmediate() {
        CodePush.sync( {
                //安装模式
                //ON_NEXT_RESUME 下次恢复到前台时
                //ON_NEXT_RESTART 下一次重启时
                //IMMEDIATE 马上更新
                installMode : CodePush.InstallMode.ON_NEXT_RESUME ,
                //对话框
                updateDialog : {
                    //是否显示更新描述
                    appendReleaseDescription : true ,
                    //更新描述的前缀。 默认为&quot;Description&quot;
                    descriptionPrefix : &quot;更新内容：&quot; ,
                    //强制更新按钮文字，默认为continue
                    mandatoryContinueButtonLabel : &quot;立即更新&quot; ,
                    //强制更新时的信息. 默认为&quot;An update is available that must be installed.&quot;
                    mandatoryUpdateMessage : &quot;必须更新后才能使用&quot; ,
                    //非强制更新时，按钮文字,默认为&quot;ignore&quot;
                    optionalIgnoreButtonLabel : &#39;稍后&#39; ,
                    //非强制更新时，确认按钮文字. 默认为&quot;Install&quot;
                    optionalInstallButtonLabel : &#39;后台更新&#39; ,
                    //非强制更新时，检查到更新的消息文本
                    optionalUpdateMessage : &#39;有新版本了，是否更新？&#39; ,
                    //Alert窗口的标题
                    title : &#39;更新提示&#39;
                } ,
                deploymentKey: deploymentKey,
            } ,
        );
    }
}

App = CodePush(codePushOptions)(App);

export default App;
</code></pre>

<h5 id="toc_11">更新是否要求即时</h5>

<p>在更新配置中通过指定installMode来决定安装完成的重启时机，亦即更新生效时机</p>

<ul>
<li><code>codePush.InstallMode.IMMEDIATE</code> ：安装完成立即重启更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESTART</code> ：安装完成后会在下次重启后进行更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESUME</code> ：安装完成后会在应用进入后台后重启更新</li>
</ul>

<h4 id="toc_12">原生端配置</h4>

<p>通过之前的ReactNative添加依赖配置<code>react-native react-native-code-push</code>,原生代码会自动生成。<br/><br/>
无需手动配置。</p>

<h2 id="toc_13">私有化配置</h2>

<h3 id="toc_14">服务端</h3>

<p>参照文档进行配置<br/>
<a href="https://github.com/lisong/code-push-server">code-push-server</a></p>

<h3 id="toc_15">客户端</h3>

<ul>
<li>登录私有化服务器访问地址，端口号3000,输入账号密码(默认为admin,123456),获取token，登陆之后输入</li>
<li><code>code-push login http://api.code-push.com</code> login后面跟上服务端访问地址</li>
<li>Android配置(<code>MyApplication</code>类中<code>getPackages</code>方法中<code>CodePush</code>实例化的时候前面不变，自动从RN端获取deploymentKey,加上第四个参数，私有化服务器的访问地址)</li>
<li>iOS配置(info.plist文件中有<code>CodePushDeploymentKey</code>是<code>deploymentKey</code>，再添加一个参数<code>CodePushServerURL</code>，填上私有化服务器的访问地址)</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/6/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html'>跨平台开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15597152983017.html">
                
                  <h1>Android 开发小记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">应用签名查看</h2>

<h3 id="toc_1">查询keystore的MD5</h3>

<pre><code class="language-text">keytool -list -v -keystore ***.jks
</code></pre>

<p><img src="media/15597152983017/15597154233468.jpg" alt="" style="width:570px;"/><br/>
MD5值就是所要的应用签名，只是比下面提到的签名生成工具生成的多出了中间的冒号</p>

<h3 id="toc_2">通过APK工具进行查看</h3>

<p><a href="media/15597152983017/GenSignature.apk">GenSignature</a><br/>
在该手机上安装正式打包的APK并运行，通过签名生成工具输入包名get signature获取应用签名，copy to clipboard即可。<br/>
<img src="media/15597152983017/15597160146245.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/6/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15590521983066.html">
                
                  <h1>ReactiveNative开发历程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">搭建环境</h2>

<h3 id="toc_1">安装环境必备软件</h3>

<p>官方推荐使用Homebrew来安装node和Watchman</p>

<pre><code class="language-text">brew install node
brew install watchman
</code></pre>

<p>设置npm镜像来加速后面的过程</p>

<pre><code class="language-text">npm config set registry https://registry.npm.taobao.org --global
npm config set disturl https://npm.taobao.org/dist --global
</code></pre>

<p>Watchman则是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager 可以快速捕捉文件的变化从而实现实时刷新）。<br/>
Yarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p>

<pre><code class="language-text">npm install -g yarn react-native-cli
</code></pre>

<p>安装完 yarn 后同理也要设置镜像源：</p>

<pre><code class="language-text">yarn config set registry https://registry.npm.taobao.org --global
yarn config set disturl https://npm.taobao.org/dist --global
</code></pre>

<p>安装完 yarn 之后就可以用 yarn 代替 npm 了，例如用yarn代替npm install命令，用yarn add 某第三方库名代替npm install 某第三方库名。</p>

<h3 id="toc_2">创建新项目</h3>

<p>使用 React Native 命令行工具来创建一个为&quot;AwesomeProject&quot;的新项目：</p>

<pre><code class="language-text">react-native init AwesomeProject
</code></pre>

<h3 id="toc_3">运行项目</h3>

<pre><code class="language-text">cd AwesomeProject
react-native run-android
</code></pre>

<h2 id="toc_4">开发NovelProject</h2>

<h3 id="toc_5">使用第三方库</h3>

<h4 id="toc_6">React-navigation</h4>

<h5 id="toc_7">导入依赖库</h5>

<p>在项目Terminal中输入命令行：</p>

<pre><code class="language-text">yarn add react-navigation
</code></pre>

<p>然后在package.json文件中就可以看到，依赖库已经导入完毕：</p>

<pre><code class="language-text">&quot;react-native-tab-navigator&quot;: &quot;^0.3.4&quot;,
</code></pre>

<p><strong>注意</strong>适配IOS要导入<code>react-native-gesture-handler</code>库，并进行关联</p>

<pre><code class="language-text">yarn add react-native-gesture-handler
react-native link
</code></pre>

<h5 id="toc_8">配置Navigator</h5>

<p>在项目的入口中直接配置StackNavigator，StackNavigator中注册所有需要跳转的界面，在这个项目中还有注册登录功能，在效果图中没有展示，这里不作探讨。首先是入口文件：</p>

<pre><code class="language-text">import React from &#39;react&#39;;
import {StackNavigator} from &#39;react-navigation&#39;;
import {TabNav} from &quot;./RootPage&quot;;
import LoginPage from &quot;./page/Login/loginPage&quot;;
import RegPage from &quot;./page/Login/regPage&quot;;
import {FindAccountPage} from &quot;./page/Login/findAccountPage&quot;; // 路由导航

const App = StackNavigator({
        Login: {screen: LoginPage}, // 登录页
        Reg: {screen: RegPage}, // 注册页
        FindAccount: {screen: FindAccountPage}, // 找回密码页
        Main: {
            screen: TabNav,
            navigationOptions: ({navigation}) =&gt; ({
                header: null
            })
        }
    },
    {
        initialRouteName: &#39;Login&#39;,
        headerMode: &#39;screen&#39;
    });

export default App;
</code></pre>

<p>上面可以注意到TabNav，也就是TabNavigator，是作为一个screen参数的值传入到StackNavigator中，在上面提到的navigationOptions的配置中，我们将header设置为null，也就是不要标题栏。</p>

<p>接着进入到配置TabNavigator的RootPage中：</p>

<pre><code class="language-text">import React from &#39;react&#39;;
import {TabNavigator} from &#39;react-navigation&#39;;

import HomePage from &#39;./page/Home/HomePage&#39;;
import FriendPage from &#39;./page/Friend/FriendPage&#39;;
import TaskPage from &#39;./page/Task/TaskPage&#39;;
import MinePage from &#39;./page/Mine/MinePage&#39;;
import DealPage from &#39;./page/Deal/DealPage&#39;;

export const TabNav = TabNavigator(
    {
        Home: {
            screen: HomePage,
        },
        Task: {
            screen: TaskPage,
        },
        Friend: {
            screen: FriendPage,
        },
        Deal: {
            screen: DealPage,
        },
        Mine: {
            screen: MinePage,
        }
    },
    {
        tabBarOptions: {
            //当前选中的tab bar的文本颜色和图标颜色
            activeTintColor: &#39;#4BC1D2&#39;,
            //当前未选中的tab bar的文本颜色和图标颜色
            inactiveTintColor: &#39;#000&#39;,
            //是否显示tab bar的图标，默认是false
            showIcon: true,
            //showLabel - 是否显示tab bar的文本，默认是true
            showLabel: true,
            //是否将文本转换为大小，默认是true
            upperCaseLabel: false,
            //material design中的波纹颜色(仅支持Android &gt;= 5.0)
            pressColor: &#39;#788493&#39;,
            //按下tab bar时的不透明度(仅支持iOS和Android &lt; 5.0).
            pressOpacity: 0.8,
            //tab bar的样式
            style: {
                backgroundColor: &#39;#fff&#39;,
                paddingBottom: 1,
                borderTopWidth: 0.2,
                paddingTop:1,
                borderTopColor: &#39;#ccc&#39;,
            },
            //tab bar的文本样式
            labelStyle: {
                fontSize: 11,
                margin: 1
            },
            //tab 页指示符的样式 (tab页下面的一条线).
            indicatorStyle: {height: 0},
        },
        //tab bar的位置, 可选值： &#39;top&#39; or &#39;bottom&#39;
        tabBarPosition: &#39;bottom&#39;,
        //是否允许滑动切换tab页
        swipeEnabled: true,
        //是否在切换tab页时使用动画
        animationEnabled: false,
        //是否懒加载
        lazy: true,
        //返回按钮是否会导致tab切换到初始tab页？ 如果是，则设置为initialRoute，否则为none。 缺省为initialRoute。
        backBehavior: &#39;none&#39;,
    });
</code></pre>

<p>在这里我们可以看到，我们将底部导航的属性基本都用上了，这是为了方便大家在使用时作适合自己的选择，毕竟需求不一样，不过这个效果是可以接受的了~</p>

<p>在这个界面中导入了其他五个子界面，每个子界面效果可以设置成差不多，例如下面这样：</p>

<pre><code class="language-text">import React, {Component} from &#39;react&#39;;
import {
    View,
    Text,
    Image,
    StyleSheet,
} from &#39;react-native&#39;;

export default class FriendPage extends Component {
    static navigationOptions = {
        tabBarLabel: &#39;好友&#39;,
        tabBarIcon: ({focused}) =&gt; {
            if (focused) {
                return (
                    &lt;Image style={styles.tabBarIcon} source={require(&#39;../../img/fri_sel.png&#39;)}/&gt;
                );
            }
            return (
                &lt;Image style={styles.tabBarIcon} source={require(&#39;../../img/fri_nor.png&#39;)}/&gt;
            );
        },
    };

    render() {
        return (
            &lt;View style={styles.container}&gt;
                &lt;Text&gt;这是好友&lt;/Text&gt;
            &lt;/View&gt;
        );
    }
}
const styles = StyleSheet.create({
    container: {
        flex: 1,
        flexDirection: &#39;column&#39;,
        justifyContent: &#39;center&#39;,
        alignItems: &#39;center&#39;,
    },
    tabBarIcon: {
        width: 21,
        height: 21,
    }
});
</code></pre>

<p>在子界面中可以设置icon图标样式，表示在点击前后颜色的改变，效果如下：<br/>
<img src="media/15590521983066/15590527801185.jpg" alt=""/><br/>
<img src="media/15590521983066/15590527846918.jpg" alt=""/></p>

<p>当然，我们也可以设置标题栏，只需要在下面代码中添加headerTitle属性：</p>

<pre><code class="language-text">export default class FriendPage extends Component {
    static navigationOptions = {
        tabBarLabel: &#39;好友&#39;,
        headerTitle: &#39;好友&#39;,
        tabBarIcon: ({focused}) =&gt; { ...
</code></pre>

<p>别忘了，在StackNavigator配置TabNavigator时不要设置header为null即可。</p>

<pre><code class="language-text">Main: {
            screen: TabNav,
            navigationOptions: ({navigation}) =&gt; ({
             // header: null
            })
        }
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/5/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html'>跨平台开发</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15663678647312.html">Docker学习</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15662718181666.html">Android GRPC接入</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15662693410122.html">Docker搭建Maven私服</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15639522586909.html">Kotlin为序列化类生成serialVersionUID</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15620327900428.html">Xposed开发</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
