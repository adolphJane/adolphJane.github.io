<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870050.html">
                
                  <h1>Android-AppBarLayout&CollapsingToolbar&Toolbar组合使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Toolbar</h2>

<p>Toobar主要是用来替换ActionBar的，换句话说，ActionBar能做的，Toolbar都能做。如果你对ActionBar的使用比较熟悉，你会发现Toolbar使用起来非常简单。ok，既然是替换，<strong>当然用Toolbar的时候就得先去把ActionBar给隐藏掉啦</strong>~</p>

<p>隐藏ActionBar的方法有很多，可以通过代码的方式隐藏，也可以通过配置文件的方式，我们主要是通过配置文件的方式来隐藏。在我们的styles.xml文件中的AppTheme标签中加入如下两行：</p>

<pre class="line-numbers"><code class="language-markup">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
</code></pre>

<p>当然了，你也可以新建一个<code>&lt;style&gt;</code>标签，将上面两行代码加入，并且将这个新建的标签作为<code>&lt;application&gt;</code>的<code>theme</code>。还可以选择通过将AppTheme的parent设置为<code>Theme.AppCompat.Light.NoActionBar</code>的方式。方法很多，可以自己随便选。<br/><br/>
接下来就是将Toolbar放入到布局文件（没啥好解释的）：</p>

<pre class="line-numbers"><code class="language-markup">&lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;
        android:layout_height=&quot;?android:attr/actionBarSize&quot;  /&gt;
</code></pre>

<p>最后将Toobar作为<code>ActionBar</code>来用</p>

<pre class="line-numbers"><code class="language-java">Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        toolbar.setTitle(&quot;这里是Title&quot;);
        toolbar.setSubtitle(&quot;这里是子标题&quot;);
        toolbar.setLogo(R.drawable.icon); 
        setSupportActionBar(toolbar);
</code></pre>

<p>可以对Toolbar设置Logo、标题、子标题等等~还有很多其他的设置，自己去慢慢玩，这里不提啦~。当然了，也可以在布局文件中设置这些，在布局文件设置就不写啦。<br/><br/>
如果Toolbar仅仅是用来对以往的ActionBar做一次替换，那也太没创意啦！完全没必要去替换了，因为它们表现出来的都是一样的，而且并没有让我们觉得用起来比ActionBar方便。那为啥要替换呢，总应该有他的理由吧：ActionBar是固定在顶部，并不能移动，我觉得这是最大的不好，而我们的ToolBar可以让我们随便摆放，就就可以带来很多灵活性和效果啦！</p>

<p>的确Toolbar根本就不够看的，一点都不复杂。接下来我们继续学习在Toolbar上面再套一层父View，让Toolbar更有互动性。</p>

<p>ToolBar中包含Nav Icon , Logo , Title , Sub Title , Menu Items 。<br/>
我们可以通过代码设置上述ToolBar中的控件：</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
   setContentView(R.layout.activity_main);

   Toolbar toolbar = (Toolbar) findViewById(R.id.id_toolbar);

   // App Logo
   toolbar.setLogo(R.mipmap.ic_launcher);
   // Title
   toolbar.setTitle(&quot;App Title&quot;);
   // Sub Title
   toolbar.setSubtitle(&quot;Sub title&quot;);

   setSupportActionBar(toolbar);
   //Navigation Icon
   toolbar.setNavigationIcon(R.drawable.ic_toc_white_24dp);
}
</code></pre>

<p><strong>可选方案</strong><br/><br/>
当然如果你喜欢，也可以在布局文件中去设置部分属性：</p>

<pre class="line-numbers"><code class="language-java">&lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/id_toolbar&quot;
        app:title=&quot;App Title&quot;
        app:subtitle=&quot;Sub Title&quot;
        app:navigationIcon=&quot;@drawable/ic_toc_white_24dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:minHeight=&quot;?attr/actionBarSize&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;/&gt;
</code></pre>

<p>至于Menu Item，依然支持在menu/menu_main.xml去声明，然后复写<code>onCreateOptionsMenu</code>和<code>onOptionsItemSelected</code>即可。</p>

<p><strong>可选方案</strong><br/><br/>
也可以通过<code>toolbar.setOnMenuItemClickListener</code>实现点击MenuItem的回调。</p>

<pre class="line-numbers"><code class="language-java">toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {
    @Override
   public boolean onMenuItemClick(MenuItem item) {
        return false;
   }
});
</code></pre>

<p>关于字体的样式，可以在布局文件设置属性<code>app:titleTextAppearance</code>、<code>app:subtitleTextAppearance</code>或者代码<code>setTitleTextAppearance</code>、<code>setSubTitleTextAppearance</code>设置。</p>

<h3 id="toc_1">layout_scrollFlags</h3>

<p>根据官方文档，layout_scrollFlags的取值可以为以下几种。</p>

<h3 id="toc_2">scroll</h3>

<p>设成这个值的效果就好比本View和scrolling view是“一体”的。具体示例我们在上面已经给出。有一点特别需要我们的注意，为了其他的滚动行为生效，必须同时指定scroll和相应的标记，比如我们想要exitUntilCollapsed所表现的滚动行为，必须将layout_scrollFlags指定为“scroll|exitUntilCollapsed”。</p>

<h3 id="toc_3">exitUntilCollapsed</h3>

<p>当本View离开屏幕时，会被“折叠”直到达到其最小高度。我们可以这样理解这个效果：当我们开始向上滚动scrolling view时，本View会先接管滚动事件，这样本View会先进行滚动，直到滚动到了最小高度（折叠了），scrolling view才开始实际滚动。而当本View已完全折叠后，再向下滚动scrolling view，直到scrolling view顶部的内容完全显示后，本View才会开始向下滚动以显现出来。</p>

<h3 id="toc_4">enterAlways</h3>

<p>当scrolling view向下滚动时，本View会一起跟着向下滚动。实际上就好比我们同时对scrolling view和本View进行向下滚动，与exitUntilCollapsed不同，当scrolling view一开始滚动，ToolBar便已开始跟着滚动，而无需scrolling view将其内容滚动到顶部。</p>

<h3 id="toc_5">enterAlwaysCollapsed</h3>

<p>从名字上就可以看出，这是在enterAlways的基础上，加上了“折叠”的效果。当我们开始向下滚动scrolling view时，本View会一起跟着滚动直到达到其“折叠高度”（即最小高度）。然后当scrolling view滚动至顶部内容完全显示后，再向下滚动scrolling view，本View会继续滚动到完全显示出来。需要把layout_scrollFlags指定为“scroll|enterAlways|enterAlwaysCollapsed”。</p>

<h3 id="toc_6">snap</h3>

<p>在一次滚动结束时，本View很可能只处于“部分显示”的状态，加上这个标记能够达到“要么完全隐藏，要么完全显示”的效果。到了这里，我们就把AppBarLayout能够实现的滚动行为介绍完毕了，很简单有木有。</p>

<h2 id="toc_7">AppBarLayout</h2>

<blockquote>
<p>AppBarLayout继承自LinearLayout，布局方向为垂直方向。所以你可以把它当成垂直布局的LinearLayout来使用。AppBarLayout是在LinearLayou上加了一些材料设计的概念，它可以让你定制当某个可滚动View的滚动手势发生变化时，其内部的子View实现何种动作。</p>
</blockquote>

<p>请注意：上面提到的某个<code>可滚动View</code>，可以理解为某个ScrollView。怎么理解上面的话呢？就是说，当某个ScrollView发生滚动时，你可以定制你的“顶部栏”应该执行哪些动作（如跟着一起滚动、保持不动等等）。那某个可移动的View到底是哪个可移动的View呢？这是由你自己指定的！如何指定，我们后面说。</p>

<h3 id="toc_8">AppBarLayout子View的动作</h3>

<p>内部的子View通过在布局中加<code>app:layout_scrollFlags</code>设置执行的动作，那么<code>app:layout_scrollFlags</code>可以设置哪些动作呢？分别如下：</p>

<h4 id="toc_9">（1）<code>scroll</code>:值设为<code>scroll</code>的View会跟随滚动事件一起发生移动。</h4>

<p>什么意思呢？简单的说，就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。</p>

<pre class="line-numbers"><code class="language-markup">&lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
&lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<p><figure><img src="media/15561207870050/20171010150764973485968.gif" alt=""/></figure></p>

<h4 id="toc_10">（2）<code>enterAlways</code>:值设为<code>enterAlways</code>的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。</h4>

<p>ToolBar高度设为：（<code>?android:attr/actionBarSize</code>）<br/>
<code>app:layout_scrollFlags=&quot;scroll|enterAlways&quot;</code></p>

<p><figure><img src="media/15561207870050/20171010150764977767320.gif" alt=""/></figure></p>

<h4 id="toc_11">（3） <code>exitUntilCollapsed</code>：值设为<code>exitUntilCollapsed</code>的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。</h4>

<p>怎么理解呢？简单解释：在ScrollView往上滑动时，首先是View把滑动事件“夺走”，由View去执行滑动，直到滑动最小高度后，把这个滑动事件“还”回去，让ScrollView内部去上滑。看个gif感受一下 ,图中将高度设的比较大:200dp，并将最小高度设置为（<code>?android:attr/actionBarSize</code>）<br/>
<code>app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code></p>

<p><figure><img src="media/15561207870050/20171010150764983431424.gif" alt=""/></figure></p>

<h4 id="toc_12">（4） <code>enterAlwaysCollapsed</code>：是<code>enterAlways</code>的附加选项，一般跟<code>enterAlways</code>一起使用，它是指，View在往下“出现”的时候，首先是<code>enterAlways</code>效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。</h4>

<p>图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize</code>,<code>app:layout_scrollFlags=&quot;scroll|enerAlways|enterAlwaysCollapsed&quot;</code></p>

<p><figure><img src="media/15561207870050/20171010150764986160489.gif" alt=""/></figure></p>

<h3 id="toc_13">将AppBarLayout与ScrollView关联起来</h3>

<p>前面说了一直反复说“当ScrollView发生滚动时”，那么怎么将AppBarLayout与ScrollView关联起来呢？我们注意到，AppBarLayout与ScrollView之间动作“相互依赖”，把ScrollView和AppBarLayout作为CoordinateLayout的子View，然后编写一个Behavior，在这个Behavior里面判断当前的操作是应该让ScrollView时刻保持在AppBarLayout之下（即只要改变AppBarLayout的位置就可以一起滑动），还是应该让ScrollView内部滚动而不让AppBarLayout位置发生变化等等这些需求，都是可以在Behavior里面处理的。你可以去针对你的ScrollView编写Behavior。然而，我们看到我们的AppBarLayout事先的功能比较复杂，如果我们自己去定义这样的效果，代码非常复杂，还要考虑很多方面，好在Android帮我们写好啦，我们直接用就是了，这个ScrollView就是NestedScrollView，请注意，它并没有继承ScrollView，它继承的是FrameLayout，但是它实现的效果把它可以看成是ScrollView。</p>

<p>把NestedScrollView放入到我们的layout文件里面就可以啦~~~，很方便~</p>

<pre class="line-numbers"><code class="language-text">&lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

       &lt;!--将你的内容放在这里--&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;
</code></pre>

<p>有没有注意到有个属性：<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>,它就是指定Behavior的，<code>appbar_scrolling_view_behavior</code>对应的类的名称是：<code>android.support.design.widget.AppBarLayout$ScrollingViewBehavior</code>感兴趣的可以去分析源码。<br/>
好了，我们现在会用AppBarLayout啦~是不是发现用起来so easy!接下来我们把剩下<code>CollapsingToolbarLayout</code>的给&quot;消化&quot;掉！</p>

<h3 id="toc_14">XML 布局</h3>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/coordinator&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/appbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;
        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;
        &lt;WebView
            android:id=&quot;@+id/web_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;
        &lt;/WebView&gt;
    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>在上面的布局文件中，NestedScrollView充当了scrolling view的角色，实际上scrolling view需要支持嵌套滚动，通常我们使用NestedScrollView、RecyclerView等已经实现了嵌套滚动的UI控件。</p>

<h2 id="toc_15">CoordinatorLayout</h2>

<p>在学习<code>CoordinatorLayout</code>之前，很有必要了解<code>CoordinatorLayout</code>能帮我们做什么，从名字上可以看出，就是帮我们协调子<code>View</code>的。怎么个协调法呢?就是它根据我们的定制，帮助我们协调各个子<code>View</code>的布局。</p>

<p><figure><img src="media/15561207870050/20171010150764992635490.gif" alt=""/></figure></p>

<p>稍微解释一下这个动画，蓝色的矩形是我们一个普通<code>View</code>，黄色的Hello是一个<code>Button</code>。我们水平拖动蓝色矩形时，黄色<code>Button</code>查着与蓝色矩形相反方向移动；竖直移动蓝色矩形时，黄色也跟着竖直。简而言之：它们在竖直方向同步移动，在水平方向相反。<br/><br/>
这个效果如果让你不用<code>CoordinatorLayout</code>去实现，应该没有任何问题，但是代码的耦合度应该非常大，你的代码必须要持有2个<code>View</code>的引用，然后在<code>onTouchEvent</code>里面做各种判断。如果我们想要实现的功能是，有更多的<code>View</code>要根据蓝色的<code>View</code>的移动相应作出响应，那么那就得在蓝色<code>View</code>的<code>onTounchEvent</code>里面针对其他的View处理各种逻辑。这耦合度未免太伤感了~<br/>
而<code>CoordinatorLayout</code>既然号称能帮我们协调子View的布局，我们接下来看看<code>CoordinatorLayout</code>如何实现~</p>

<h3 id="toc_16">CoordinatorLayout使用</h3>

<p><code>CoordinatorLayout</code>的使用核心是<code>Behavior</code>，<code>Behavior</code>就是执行你定制的动作。在讲<code>Behavior</code>之前必须先理解两个概念：<code>Child</code>和<code>Dependency</code>，什么意思呢？<code>Child</code>当然是子<code>View</code>的意思了，是谁的子<code>View</code>呢，当然是<code>CoordinatorLayout</code>的子<code>View</code>；其实<code>Child</code>是指要执行动作的<code>CoordinatorLayout</code>的子<code>View</code>。而<code>Dependency</code><br/>
是指<code>Child</code>依赖的<code>View</code>。比如上面的gif图中，蓝色的<code>View</code>就是<code>Dependency</code>，黄色的<code>View</code>就是<code>Child</code>，因为黄色的View的动作是依赖于蓝色的<code>View</code>。简而言之，就是如过<code>Dependency</code>这个View发生了变化，那么<code>Child</code>这个<code>View</code>就要相应发生变化。发生变化是具体发生什么变化呢？这里就要引入<code>Behavior</code>，<code>Child</code>发生变化的具体执行的代码都是放在<code>Behavior</code>这个类里面。<br/><br/>
怎么使用<code>Behavior</code>呢，首先，我们定义一个类，继承<code>CoordinatorLayout.Behavior&lt;T&gt;</code>,其中，泛型参数T是我们要执行动作的<code>View</code>类，也就是<code>Child</code>。然后就是去实现<code>Behavior</code>的两个方法：</p>

<pre class="line-numbers"><code class="language-java">/**
* 判断child的布局是否依赖dependency
*/
   @Override
 public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) {
    boolean rs;
    //根据逻辑判断rs的取值
    //返回false表示child不依赖dependency，ture表示依赖
    return rs;  
}

/**
* 当dependency发生改变时（位置、宽高等），执行这个函数
* 返回true表示child的位置或者是宽高要发生改变，否则就返回false
*/
@Override
public boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) {
     //child要执行的具体动作
        return true;
}
</code></pre>

<p>有了上面的概念后，我们看看具体怎么去实现吧~</p>

<p>为了响应跟随手指移动的操作，我们定义一个非常简单的<code>View</code>，这个<code>View</code>只响应跟随手指移动，将这个<code>View</code>作为<code>Dependency</code>。由于过于简单，这个<code>View</code>源码不粘贴，我们只需知道这个<code>View</code>的类名叫：<code>TempView</code>。</p>

<p>我们看看Behavior的使用：</p>

<pre class="line-numbers"><code class="language-java">package com.hc.studyCoordinatorLayout;

import android.content.Context;
import android.support.design.widget.CoordinatorLayout;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.View;
import android.widget.Button;

/**
 * Package com.hc.studyCoordinatorLayout
 * Created by HuaChao on 2016/6/1.
 */
public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; {
    private int width;

    public MyBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
        DisplayMetrics display = context.getResources().getDisplayMetrics();
        width = display.widthPixels;
    }

    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) {
        //如果dependency是TempView的实例，说明它就是我们所需要的Dependency
        return dependency instanceof TempView;
    }

    //每次dependency位置发生变化，都会执行onDependentViewChanged方法
    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, Button btn, View dependency) {

        //根据dependency的位置，设置Button的位置

        int top = dependency.getTop();
        int left = dependency.getLeft();

        int x = width - left - btn.getWidth();
        int y = top;

        setPosition(btn, x, y);
        return true;
    }

    private void setPosition(View v, int x, int y) {
        CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) v.getLayoutParams();
        layoutParams.leftMargin = x;
        layoutParams.topMargin = y;
        v.setLayoutParams(layoutParams);
    }

}
</code></pre>

<p>OK，现在我们为<code>Button</code>类指定了<code>Dependency</code>，并且定义好了跟随<code>Dependency</code>一直变化的动作（<code>Behavior</code>），接下来我们就要指定好为哪个具体的<code>Button</code>实例来绑定这些。方法很简单，直接在布局文件指定就好：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.hc.studyCoordinatorLayout.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/btn&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#FFCC00&quot;
        android:text=&quot;Hello&quot;
        app:layout_behavior=&quot;com.hc.studyCoordinatorLayout.MyBehavior&quot; /&gt;

    &lt;com.hc.studyCoordinatorLayout.TempView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#3366CC&quot;  /&gt;
&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>是不是很简单呢？我们只需关注<code>Behavior</code>的编写就好了，把<code>Child</code>和<code>Dependency</code>之间的关系完全解耦了~</p>

<h2 id="toc_17">CollapsingToolbarLayout</h2>

<p><code>CollapsingToolbarLayout</code>是用来对<code>Toolbar</code>进行再次包装的<code>ViewGroup</code>，主要是用于实现折叠（其实就是看起来像伸缩~）的App Bar效果。它需要放在<code>AppBarLayout</code>布局里面，并且作为<code>AppBarLayout</code>的直接子<code>View</code>。<code>CollapsingToolbarLayout</code>主要包括几个功能（参照了官方网站上内容，略加自己的理解进行解释）：</p>

<blockquote>
<p>(1)  Collasping title（可折叠标题）：当布局完全可见时，这个标题比较大；当折叠起来时，标题也会变小。标题的外观可以通过expandedTextAppearance和collapsedTextAppearance属性来调整。<br/>
(2)  Content scrim（内容纱布）：根据CollapsingToolbarLayout是否滚动到一个临界点，内容纱布会显示或隐藏。可以通过setContentScrim(Drawable)来设置内容纱布。<br/>
(3)  Status bar scrim（状态栏纱布）：也是根据是否滚动到临界点，来决定是否显示。可以通过setStatusBarScrim(Drawable)方法来设置。这个特性只有在Android5.0及其以上版本，我们设置fitSystemWindows为ture时才能生效。<br/>
(4)  Parallax scrolling children（视差滚动子View）：子View可以选择以“视差”的方式来进行滚动。（视觉效果上就是子View滚动的比其他View稍微慢些）<br/>
(5)  Pinned position children：子View可以选择固定在某一位置上。子View可以选择是否在全局空间上固定位置，这对于Toolbar来说非常有用，因为当布局在移动时，可以将Toolbar固定位置而不受移动的影响。 将<code>app:layout_collapseMode</code>设为<code>pin</code>。<br/>
了解这些概念后，我们来看看布局吧~</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;

    &lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            app:expandedTitleMarginEnd=&quot;64dp&quot;
            app:expandedTitleMarginStart=&quot;48dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/main.backdrop&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;300dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/material_img&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;

            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?android:attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot;  /&gt;

        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingTop=&quot;50dp&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@string/my_txt&quot;
            android:textSize=&quot;20sp&quot; /&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>上面的都看得懂吧，每个陌生的属性都是讲过的哦，忘记了的话回头看，稍微解释一下，图片被设置为有视差的滑动，Toolbar设置为固定不动，另外，CollapsingToolbarLayout会对title进行放大和缩小，我们看看效果吧~</p>

<p><figure><img src="media/15561207870050/20171010150765001948776.gif" alt=""/></figure></p>

<p>如果你希望拖动过程中状态栏是透明的，可以在CollapsingToolbarLayout中加 <code>app:statusBarScrim=&quot;@android:color/transparent&quot;</code>，并且在onCreate中调用<code>getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)</code>将状态栏设置为透明就好啦~</p>

<h3 id="toc_18">XML布局文件</h3>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/coordinator&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/app_bar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;256dp&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;
        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:id=&quot;@+id/collapsing_toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            app:expandedTitleMarginEnd=&quot;50dp&quot;
            app:expandedTitleMarginStart=&quot;50dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;
            &lt;ImageView
                android:src=&quot;@mipmap/ic_launcher&quot;
                android:id=&quot;@+id/image&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                android:scaleType=&quot;centerCrop&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;
            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot; /&gt;
        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;
        &lt;WebView
            android:id=&quot;@+id/web_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;
        &lt;/WebView&gt;
 &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>我们在XML文件中为CollapsingToolbarLayout的layout_scrollFlags指定为“scroll|exitUntilCollapsed”，这样便实现了向上滚动scrolling view时的折叠效果。CollapsingToolbarLayout本质上是一个FrameLayout。我们在布局文件中为它指定了两个子View，分别是ImageView和Toolbar。ImageView的layout_collapseMode属性设为了parallax，也就是我们前面介绍的视差滚动；而<code>Toolbar</code>的<code>layout_collaspeMode</code>设为了pin，也就是Toolbar会始终固定在顶部。</p>

<h3 id="toc_19">contentScrim</h3>

<p>在上图中，我们看到Toolbar的背景一直都是我们指定的图片，即时图片向上滚动到消失后也是这样。那么可不可以让图片完全消失后，Toolbar显示一个另外的背景呢？答案是肯定的，只要使用我们上面提到的“内容纱布”即可。还记得我们上面关于内容纱布的介绍吗？当CollapsingToolbarLayout滚动到一个临界位置，内容纱布就会显现出来，我们通过一个例子感受下。<br/><br/>
当CollapsingToolbarLayout完全折叠后，ToolBar的背景变为了黑色，好像盖上了一层布，所以这个属性叫做“内容纱布”。这里我们发现，只有CollapsingToolbarLayout滚动到折叠后，内容纱布才显现出来，也就是说，默认的临界位置就是滚动到折叠。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870016.html">
                
                  <h1>Android-DialogFragment详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">DialogFragment 设置全屏方法</h2>

<h3 id="toc_1">方法一</h3>

<pre class="line-numbers"><code class="language-java">@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setStyle(STYLE_NO_FRAME, android.R.style.Theme_Holo_Light);
}
</code></pre>

<h3 id="toc_2">方法二</h3>

<p><strong>style</strong></p>

<pre class="line-numbers"><code class="language-java">&lt;style name=&quot;style_dialog&quot; parent=&quot;android:style/Theme.Dialog&quot;&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt;
    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;
    &lt;item name=&quot;android:scrollHorizontally&quot;&gt;true&lt;/item&gt;
    &lt;!-- Dialog进入及退出动画 --&gt;
    &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/BottomToTopAnim&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;BottomToTopAnim&quot; parent=&quot;android:Animation&quot;&gt;
    &lt;item name=&quot;@android:windowEnterAnimation&quot;&gt;@anim/bottom_in&lt;/item&gt;
    &lt;item name=&quot;@android:windowExitAnimation&quot;&gt;@anim/bottom_out&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p><strong>bottom_in bottom_out 进入进出动画</strong></p>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;translate
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot;
    android:fromYDelta=&quot;100%p&quot;
    android:toYDelta=&quot;0&quot;/&gt;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot;
    android:fromYDelta=&quot;0&quot;
    android:toYDelta=&quot;100%p&quot;/&gt;
</code></pre>

<p><strong>代码</strong></p>

<pre class="line-numbers"><code class="language-java">@NonNull
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {

    LayoutInflater inflater = getActivity().getLayoutInflater();
    View view = inflater.inflate(R.layout.view, null);

    final Dialog dialog = new Dialog(getActivity(), R.style.style_dialog);
    dialog.setContentView(view);
    dialog.show();

    Window window = dialog.getWindow();
    window.setGravity(Gravity.BOTTOM); //可设置dialog的位置
    window.getDecorView().setPadding(0, 0, 0, 0); //消除边距

    WindowManager.LayoutParams lp = window.getAttributes();
    lp.width = WindowManager.LayoutParams.MATCH_PARENT;   //设置宽度充满屏幕
    lp.height = WindowManager.LayoutParams.WRAP_CONTENT;
    window.setAttributes(lp);
    return dialog;

}
</code></pre>

<h2 id="toc_3">生命周期</h2>

<ul>
<li>onAttach</li>
<li> onCreate</li>
<li>onCreateView</li>
<li>onStart</li>
<li>onStop</li>
<li> third activity on destroy</li>
<li> onDestroyView</li>
<li> onDetach</li>
<li>onAttach</li>
<li>onCreate</li>
<li>onCreateView</li>
<li>onStart</li>
</ul>

<h2 id="toc_4">设置背景为透明</h2>

<pre class="line-numbers"><code class="language-java">View decorView = getDialog().getWindow().getDecorView();
decorView.setBackground(new ColorDrawable(Color.TRANSPARENT));
</code></pre>

<p>(PS:Window -&gt; DecorView -&gt; FrameLayout -&gt; FrameLayout -&gt; 我们的自定义View) 这个逻辑大家应该都知道的，所以我们只需要改变底部的DecorView的背景色即可。</p>

<h2 id="toc_5">设置弹框位置</h2>

<p>因为View是在window下面的，我们只需要让window的Grivaty属性是Bottom，这样，里面的元素都是居于底部即可。</p>

<pre class="line-numbers"><code class="language-java">Window window = getDialog().getWindow();
WindowManager.LayoutParams layoutParams = window.getAttributes();
layoutParams.gravity = Gravity.BOTTOM;
window.setAttributes(layoutParams);
</code></pre>

<h2 id="toc_6">解决DialogFragment两边的间隙</h2>

<p>因为View都是被包含在window里面，虽然我们的自己的View的宽度已经设置成了match_parent，但是我们并没有对window设置宽度为最大。所以我们先来改变window的宽度。</p>

<p>改变window的宽度：</p>

<pre class="line-numbers"><code class="language-java">Window window = getDialog().getWindow();
WindowManager.LayoutParams layoutParams = window.getAttributes();
layoutParams.gravity = Gravity.BOTTOM;
layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
window.setAttributes(layoutParams);
</code></pre>

<p>我们在前面修改弹框位置的代码处，多添加一句：</p>

<p><code>layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;</code></p>

<p>设置之后虽然二边的间隙变小了很多。但是还是有间隙，既然我们都已经把window的宽度变为match_parent,还是没填充，说明应该是有padding值。那我们马上就想到了，难道是DecorView里面有padding值。毕竟我们的View也是被包含在DecorView里面。废话不多说，我们马上实验：</p>

<p><code>decorView.setPadding(0,0,0,0);</code></p>

<blockquote>
<p>PS:这里还有另外一种方法，不写这句decorView.setPadding(0,0,0,0);而是直接设置window的背景颜色，window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));源码中其实也给DecorView设置了padding值。所以效果相同。</p>
</blockquote>

<h2 id="toc_7">设置弹框从下而上显示</h2>

<p>我们看过ios的弹框效果，是从底部从下而上升起，然后消失的时候也是从上而下消失。所以消失的时候我们不能单纯的让DialogFragment执行<code>dismiss()</code>，而是先让弹框执行下移的动画效果，然后再<code>dismiss()</code>。</p>

<p>既然谈到了上下的移动，大家肯定马上想到了用TranslateAnimation动画来做，我们就一步步来看如何用这个来实现：</p>

<ul>
<li>弹框出现动画：</li>
</ul>

<pre class="line-numbers"><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f
);
slide.setDuration(400);
slide.setFillAfter(true);
slide.setFillEnabled(true);
view.startAnimation(slide);
</code></pre>

<p>我们来看TranslateAnimation，这里我们传了八个参数，一般大家用到的是只传四个参数：</p>

<pre class="line-numbers"><code class="language-text">TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)
</code></pre>

<p>也就是从坐标<code>(fromXDelta,fromYDelta)</code>到<code>(toXDelta,toYDelta)</code>。<br/>
我们可以点进去这个构造函数查看：</p>

<pre class="line-numbers"><code class="language-java">public TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) {
      mFromXValue = fromXDelta;
      mToXValue = toXDelta;
      mFromYValue = fromYDelta;
      mToYValue = toYDelta;

      mFromXType = ABSOLUTE;
      mToXType = ABSOLUTE;
      mFromYType = ABSOLUTE;
      mToYType = ABSOLUTE;
}
</code></pre>

<p>之所以我们以前用的只传了四个参数，是因为他给我们把另外四个参数以及赋了默认值，也就是<code>ABSOLUTE</code>。我们继续看有哪几种可以选择：</p>

<pre class="line-numbers"><code class="language-text">  /**
   * The specified dimension is an absolute number of pixels.
   */
  public static final int ABSOLUTE = 0;

  /**
   * The specified dimension holds a float and should be multiplied by the
   * height or width of the object being animated.
   */
  public static final int RELATIVE_TO_SELF = 1;

  /**
   * The specified dimension holds a float and should be multiplied by the
   * height or width of the parent of the object being animated.
   */
  public static final int RELATIVE_TO_PARENT = 2;
</code></pre>

<p>通过字面意思我们也能理解：<br/><br/>
<code>ABSOLUTE</code>是绝对坐标，<code>RELATIVE_TO_SELF</code>是相对于自身，<code>RELATIVE_TO_PARENT</code>是相对于父View。<br/>
而我们只需要我们的弹框显示的位置，让的起始位置如下图所示：</p>

<p>刚开始超过屏幕，并且高度为弹框自身的高度，然后再回到原始位置,所以我们就用：</p>

<pre class="line-numbers"><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f
);
</code></pre>

<p>从原来的位置，增加了自身高度的距离为起始点，开始移动，然后再回到原来的位置。</p>

<ul>
<li>消失动画：</li>
</ul>

<p>只要跟上面反过来就可以了。同时这里我们要额外增加监听动画结束事件，因为我们让弹框往下移动结束后，要让这个弹框dismiss掉:</p>

<pre class="line-numbers"><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f
);
slide.setAnimationListener(new Animation.AnimationListener() {
  @Override
  public void onAnimationStart(Animation animation) {}

  @Override
  public void onAnimationEnd(Animation animation) {
      IOSDialogFragment.this.dismiss();
  }

  @Override
  public void onAnimationRepeat(Animation animation) {}
});
</code></pre>

<p>所以我们的动画的代码总结下就是：</p>

<pre class="line-numbers"><code class="language-java">@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
    getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE);
    rootView = inflater.inflate(R.layout.fragment_ios_dialog, container, false);
    slideToUp(rootView);
    return rootView;
}


public void slideToUp(View view){
    Animation slide = new TranslateAnimation(
        Animation.RELATIVE_TO_SELF, 0.0f,
        Animation.RELATIVE_TO_SELF, 0.0f, 
        Animation.RELATIVE_TO_SELF,1.0f, Animation.RELATIVE_TO_SELF, 0.0f);

    slide.setDuration(400);
    slide.setFillEnabled(true);
    slide.setFillAfter(true);
    view.startAnimation(slide);
}

public void slideToDown(View view){
    Animation slide = new TranslateAnimation(
        Animation.RELATIVE_TO_SELF, 0.0f,
        Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF,0.0f, Animation.RELATIVE_TO_SELF, 1.0f);

    slide.setDuration(400);
    slide.setFillEnabled(true);
    slide.setFillAfter(true);
    view.startAnimation(slide);

    slide.setAnimationListener(new Animation.AnimationListener() {
        @Override
        public void onAnimationStart(Animation animation) {

        }

        @Override
        public void onAnimationEnd(Animation animation) {
            IOSDialogFragment.this.dismiss();//弹框消失
        }

        @Override
        public void onAnimationRepeat(Animation animation) {

        }
    });
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869978.html">
                
                  <h1>Android-RecyclerView详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">RecyclerView</h2>

<h3 id="toc_1">RecyclerView是什么？</h3>

<p>RecylerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字recylerview即回收view也可以看出。看到这也许有人会问，不是已经有ListView了吗，为什么还要RecylerView呢？这就牵扯到第二个问题了。</p>

<h3 id="toc_2">RecyclerView的优点是什么？</h3>

<p>根据官方的介绍RecylerView是ListView的升级版，既然如此那RecylerView必然有它的优点，现就RecylerView相对于ListView的优点罗列如下：</p>

<ul>
<li>RecylerView封装了viewholder的回收复用，也就是说RecylerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的   逻辑被封装了，写起来更加简单。</li>
<li>提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecylerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还有StaggeredGridLayoutManager等)，也就是说RecylerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。你想控制Item的分隔线，可以通过继承RecylerView的ItemDecoration这个类，然后针对自己的业务需求去抒写代码。</li>
<li>可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecylerView有其自己默认的实现。</li>
</ul>

<h3 id="toc_3">RecyclerView的用法</h3>

<h4 id="toc_4">RecyclerView的初步用法(包括RecyclerView.Adapter用法)</h4>

<pre class="line-numbers"><code class="language-java">recyclerView = (RecyclerView) findViewById(R.id.recyclerView);  
LinearLayoutManager layoutManager = new LinearLayoutManager(this );  
//设置布局管理器  
recyclerView.setLayoutManager(layoutManager);  
//设置为垂直布局，这也是默认的  
layoutManager.setOrientation(OrientationHelper. VERTICAL);  
//设置Adapter  
recyclerView.setAdapter( recycleAdapter);  
//设置分隔线  
recyclerView.addItemDecoration( new DividerGridItemDecoration(this ));  
//设置增加或删除条目的动画  
recyclerView.setItemAnimator( new DefaultItemAnimator());
</code></pre>

<p>可以看到对RecylerView的设置过程，比ListView要复杂一些，这也是RecylerView高度解耦的表现，虽然代码抒写上有点复杂，但它的扩展性是极高的。</p>

<h3 id="toc_5">RecyclerView的生命周期</h3>

<p>一个RecyclerView的Item加载是有顺序的，类似于Activity的生命周期（姑且这么叫把），具体可以对adapter的每个方法进行重写打下日志进行查看，具体大致为：</p>

<ul>
<li>getItemViewType(获取显示类型，返回值可在onCreateViewHolder中拿到，以决定加载哪种ViewHolder)</li>
<li>onCreateViewHolder(加载ViewHolder的布局)</li>
<li>onViewAttachedToWindow（当Item进入这个页面的时候调用）</li>
<li>onBindViewHolder(将数据绑定到布局上，以及一些逻辑的控制就写这啦)</li>
<li>onViewDetachedFromWindow（当Item离开这个页面的时候调用）</li>
<li>onViewRecycled(当Item被回收的时候调用)<br/>
tips1:如果你调用了：</li>
</ul>

<pre class="line-numbers"><code class="language-text">viewHolder.setIsRecyclable(false);
</code></pre>

<p>那么这个Item的onViewRecycled将永远不会调用。<br/>
tips2:如果你的界面出现了错乱的现象，请调用如上代码可能能简单粗暴的解决，当然代价是损失少许的性能表现了。</p>

<h2 id="toc_6">RecyclerView.Adapter</h2>

<p>来看看它的Adapter的写法，RecyclerView的Adapter与ListView的Adapter还是有点区别的，RecyclerView.Adapter，需要实现3个方法：</p>

<ul>
<li><code>onCreateViewHolder()</code>这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。直接省去了当初的convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。</li>
<li><code>onBindViewHolder()</code>这个方法主要用于适配渲染数据到View中。方法提供给你了一个viewHolder，而不是原来的convertView。</li>
<li><p><code>getItemCount()</code>这个方法就类似于BaseAdapter的getCount方法了，即总共有多少个条目。</p></li>
<li><p><code>notifyDataSetChanged()</code>刷新所有,notifyDataSetChanged最终会使adapter的数据重新绑定，即会重新调用adapter里的onBindViewHolder方法，从而使item的position得到了更新。</p></li>
<li><p><code>notifyItemChanged(int position)</code>position数据发生了改变，那调用这个方法，就会回调对应position的onBindViewHolder()方法了</p></li>
<li><p><code>notifyItemRangeChanged(int positionStart, int itemCount)</code>刷新从positionStart开始itemCount数量的item了（这里的刷新指回调onBindViewHolder()方法）</p></li>
<li><p><code>notifyItemInserted(int position)</code>在第position位置被插入了一条数据的时候可以使用这个方法刷新，注意这个方法调用后会有插入的动画，这个动画可以使用默认的，也可以自己定义</p></li>
<li><p><code>notifyItemMoved(int fromPosition, int toPosition)</code>从fromPosition移动到toPosition为止的时候可以使用这个方法刷新</p></li>
<li><p><code>notifyItemRangeInserted(int positionStart, int itemCount)</code>批量添加</p></li>
<li><p><code>notifyItemRemoved(int position)</code>第position个被删除的时候刷新，同样会有动画</p></li>
<li><p><code>notifyItemRangeRemoved(int positionStart, int itemCount)</code>批量删除</p></li>
<li><p><code>onAttachedToRecyclerView (RecyclerView recyclerView)</code>在<code>RecyclerView.setAdapter(adapter)</code>时进行调用</p></li>
<li><p><code>onViewAttachedToWindow(VH holder)</code>当Item进入这个页面的时候调用</p></li>
<li><p><code>onViewDetachedFromWindow(VH holder)</code>当Item离开这个页面的时候调用</p></li>
<li><p><code>onViewRecycled(VH holder)</code>当Item被回收的时候调用</p></li>
</ul>

<h2 id="toc_7">RecyclerView.ItemDecoration</h2>

<blockquote>
<p>An ItemDecoration allows the application to add a special drawing and layout offset to specific item views from the adapter&#39;s data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and more.</p>

<p>ItemDecoration允许应用结合adapter的数据集，对特定的item添加绘制一个周边图案。可以用于给items之间添加分割线、高亮装饰效果或者分组边界等等。</p>
</blockquote>

<p>从谷歌官方的介绍可以知道，ItemDecoration是用于给列表的item添加各种装饰效果，开发中最常见的就是为item添加分割线。<br/><br/>
ItemDecoration本身是一个抽象类，抛去废弃的方法，我们需要关心的方法只有三个：</p>

<pre class="line-numbers"><code class="language-java">public static abstract class ItemDecoration {
    public void onDraw(Canvas c, RecyclerView parent, State state) {
        onDraw(c, parent);
    }
    public void onDrawOver(Canvas c, RecyclerView parent, State state) {
        onDrawOver(c, parent);
    }
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) {
        getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),parent);
    }
}
</code></pre>

<p>从源码注释中，可以大概了解这三个方法的用途：</p>

<ul>
<li><code>onDraw</code>：在item绘制之前时被调用，将指定的内容绘制到item view内容之下；</li>
<li><code>onDrawOver</code>：在item被绘制之后调用，将指定的内容绘制到item view内容之上</li>
<li><code>getItemOffsets</code>：在每次测量item尺寸时被调用，将decoration的尺寸计算到item的尺寸中</li>
</ul>

<p><figure><img src="media/15561207869978/15713203883056.jpg" alt=""/></figure></p>

<h3 id="toc_8">ItemDecoration三个方法的测试</h3>

<p>谷歌官方在support.v7包中提供了ItemDecoration的一个实现DividerItemDecoration，这里结合这个实现，来看看其三个需要实现的方法对UI的影响。</p>

<h4 id="toc_9">onDraw</h4>

<pre class="line-numbers"><code class="language-java">private void drawVertical(Canvas canvas, RecyclerView parent) {
    canvas.save();
   final int left;
   final int right;
   if (parent.getClipToPadding()) {
        left = parent.getPaddingLeft();
        right = parent.getWidth() - parent.getPaddingRight();
        canvas.clipRect(left, parent.getPaddingTop(), right,parent.getHeight() - parent.getPaddingBottom());
   } else {
        left = 0;
        right = parent.getWidth();
    }

    final int childCount = parent.getChildCount();
    for (int i = 0; i &lt; childCount; i++) {
        final View child = parent.getChildAt(i);
        parent.getDecoratedBoundsWithMargins(child, mBounds);
        final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child));
        final int top = bottom - mDivider.getIntrinsicHeight();
        mDivider.setBounds(left, top, right, bottom);
       mDivider.draw(canvas);
    }
    canvas.restore();
}
</code></pre>

<p><code>drawVertical</code>方法实现了对<code>Orientation == VERTICAL</code>的RecyclerView绘制item之间的分割线。从传入的canvas参数可以推断，分割线的绘制是通过canvas机制绘制到屏幕上：<code>mDivider.draw(canvas)</code>;其中，mDivider是一个Drawable对象，可以通过setDrawable传入自定义对象，不传入时，会自动使用系统内置的分割线样式：<code>android.R.attr.listDivider</code>。通过遍历每一个可见的child view，计算mDivider对应的left、top、right、bottom值，从而绘制到正确的位置上。对于纵向的RecyclerView而言，mDivider的left和right是固定的，和parent的左右内容边界保持一致，也就是说，把parent的左右padding都计算进去，因而是代表了RecyclerView实际的内容区域。纵向的分割线一般位于每个item的底部，因此mDivider的top值理论上应该和child view的内容下边界保持贴合。实际上，计算top和bottom的代码，谷歌官方也有所调整，在最新的实现中，先通过<code>parent.getDecoratedBoundsWithMargins(child, mBounds)</code>;拿到之前在onMeasure过程中，通过调用<code>getItemOffsets</code>获取到的mBounds，mBounds是包括了整个child view以及其decoration的总边界，之后再计算mDivider的bottom、top值。</p>

<h4 id="toc_10">getItemOffsets</h4>

<pre class="line-numbers"><code class="language-java">public void getItemOffsets(Rect outRect, View view, RecyclerView parent,RecyclerView.State state) {
    if (mOrientation == VERTICAL) {
        outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
    } else {
        outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
    }
}
</code></pre>

<p>官方实现的getItemOffsets比较简单，只是根据列表的方向，返回了分割线在相应方向的尺寸。这里可能有一个坑，即通过setDrawable设置自定义的分割线时，容易传入一个无尺寸的drawable对象，导致分割线无法显示出来的bug，典型的代码是这样：<br/>
<code>decoration.setDrawable(new ColorDrawable(Color.RED));</code></p>

<p>DividerItemDecoration的实现中，是没有复写onDrawOver方法的，对于分割线场景而言，也确实不需要去实现它。接下来，通过几个例子，展示一下getItemOffsets对于ItemDecoration在UI上的影响。</p>

<h4 id="toc_11">getItemOffsets &amp; onDraw</h4>

<p>先上动图【注2】：</p>

<p><figure><img src="media/15561207869978/20171015150799983096582.gif" alt=""/></figure></p>

<p><figure><img src="media/15561207869978/20171015150799985361609.gif" alt=""/></figure></p>

<p>上图中，getItemOffsets方法里，返回outRect不同，而onDraw方法绘制的分割线高度初始值设为25，并通过外部增减来观察其UI效果。</p>

<pre class="line-numbers"><code class="language-java">public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
    outRect.set(0, 0, 0, 50);// outRect.set(50,50,50,50);
}

public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
    for (int i = 0; i &lt; childCount; i++) {
        final View view = parent.getChildAt(i);
        top = view.getBottom();
        left = view.getPaddingLeft() + mSize;
        right = view.getWidth() - view.getPaddingRight() - mSize ;
        bottom = top + mSize;
        divider.setBounds(left, top, right, bottom);
        divider.draw(c);
    }
}
</code></pre>

<p>从上面两个动图对比，可以得出以下几个结论：</p>

<ul>
<li>getItemOffsets返回的矩形outRect会被计算到child view的尺寸当中；</li>
<li>onDraw方法绘制的图形，可以超出outRect所规定的区域；</li>
<li>onDraw方法绘制的图形，确实是处于child view的底下，当两者发生重叠时，只会显示child view的内容；</li>
</ul>

<h4 id="toc_12">getItemOffsets &amp; onDrawOver</h4>

<p><figure><img src="media/15561207869978/20171015150799996057841.gif" alt=""/></figure></p>

<p>将之前onDraw方法内代码完整拷贝到onDrawOver下，并注释掉之前onDraw中的方法，很容易验证出onDrawOver与onDraw的唯一不同之处。</p>

<ul>
<li>onDrawOver绘制的图形，处于child view之上，当两者发生重叠时，会显示onDrawOver的内容；</li>
</ul>

<blockquote>
<p>ItemDecoration三个方法的含义，就介绍到这里。可以感觉到，三个方法都很简单而基础，可以十分优雅的实现item的分割线效果，然而简单的如DividerItemDecoration，往往是无法满足项目开发需求的。经常会遇到某几个item不想要分割线（如头部或者最后一个item），这就需要开发者自行来实现。</p>
</blockquote>

<h3 id="toc_13">添加分隔线</h3>

<p>我们可以创建一个继承RecyclerView.ItemDecoration类来绘制分隔线，通过ItemDecoration可以让我们每一个Item从视觉上面相互分开来，例如ListView的divider非常相似的效果。也可以不设置ItemDecoration，那说明ItemDecoration我们并不是强制需要使用，作为我们开发者可以设置或者不设置Decoration的。实现一个ItemDecoration，系统提供的ItemDecoration是一个抽象类，内部除去已经废弃的方法以外，我们主要实现以下三个方法:</p>

<pre class="line-numbers"><code class="language-java">public static abstract class ItemDecoration {   
    public void onDraw(Canvas c,RecyclerView parent,State state) {   
        onDraw(c,parent);   
    }   
    public void onDrawOver(Canvas c,RecyclerView parent,State state) {   
        onDrawOver(c,parent);   
    }   
    public void getItemOffsets(RectoutRect, View view,RecyclerView parent,State state) {   
        getItemOffsets(outRect,((LayoutParams)view.getLayoutParams()).getViewLayoutPosition(),parent);   
    }   
}
</code></pre>

<ul>
<li><code>onDraw</code>方法先于<code>drawChildren</code></li>
<li><code>onDrawOver</code>在<code>drawChildren</code>之后，一般我们选择复写其中一个即可。</li>
<li><code>getItemOffsets</code> 可以通过<code>outRect.set()</code>为每个<code>Item</code>设置一定的偏移量，主要用于绘制<code>Decorator</code>。</li>
</ul>

<p>又因为当我们RecyclerView在进行绘制的时候会进行绘制Decoration,那么会去调用onDraw和onDrawOver方法，那么这边我们其实只要去重写onDraw和getItemOffsets这两个方法就可以实现啦。然后LayoutManager会进行Item布局的时候，会去调用getItemOffset方法来计算每个Item的Decoration合适的尺寸，下面我们来具体实现一个</p>

<pre class="line-numbers"><code class="language-java">package com.example.reclerviewpractice;  
  
import android.content.Context;  
import android.content.res.TypedArray;  
import android.graphics.Canvas;  
import android.graphics.Rect;  
import android.graphics.drawable.Drawable;  
import android.support.v7.widget.LinearLayoutManager ;  
import android.support.v7.widget.RecyclerView;  
import android.view.View;  
  
public class DividerItemDecoration extends RecyclerView.ItemDecoration {  
  
    private static final int[] ATTRS = new int[]{  
        android.R.attr. listDivider  
    };  
    public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;  
    public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL;  
    private Drawable mDivider;
    private int mOrientation;  
  
    public DividerItemDecoration(Context context, int orientation) {  
        final TypedArray a = context.obtainStyledAttributes(ATTRS );  
        mDivider = a.getDrawable(0);  
        a.recycle();  
        setOrientation(orientation);  
    }  
  
    public void setOrientation( int orientation) {  
        if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) {  
            throw new IllegalArgumentException( &quot;invalid orientation&quot;);  
        }  
        mOrientation = orientation;  
    }  
  
    @Override  
    public void onDraw(Canvas c, RecyclerView parent) {  
        if (mOrientation == VERTICAL_LIST) {  
            drawVertical(c, parent);  
        } else {  
            drawHorizontal(c, parent);  
        }  
    }  
  
    public void drawVertical(Canvas c, RecyclerView parent) {  
        final int left = parent.getPaddingLeft();  
        final int right = parent.getWidth() - parent.getPaddingRight();  
        final int childCount = parent.getChildCount();  
        for (int i = 0; i &lt; childCount; i++) {  
            final View child = parent.getChildAt(i);  
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();  
            final int top = child.getBottom() + params.bottomMargin;  
            final int bottom = top + mDivider.getIntrinsicHeight();  
            mDivider.setBounds(left, top, right, bottom);  
            mDivider.draw(c);  
        }  
    }  
  
    public void drawHorizontal(Canvas c, RecyclerView parent) {  
        final int top = parent.getPaddingTop();  
        final int bottom = parent.getHeight() - parent.getPaddingBottom();  
  
        final int childCount = parent.getChildCount();  
        for (int i = 0; i &lt; childCount; i++) {  
            final View child = parent.getChildAt(i);  
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();  
            final int left = child.getRight() + params.rightMargin;  
            final int right = left + mDivider.getIntrinsicHeight();  
            mDivider.setBounds(left, top, right, bottom);  
            mDivider.draw(c);  
        }  
    }  
  
    @Override  
    public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) {  
        if (mOrientation == VERTICAL_LIST) {  
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());  
        }else{  
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);  
        }  
    }  
}
</code></pre>

<h3 id="toc_14">改变分隔线样式</h3>

<p>那么怎么更改分隔线的样式呢？在上面的DividerItemDecoration这个类中可以看到这个分隔线是跟ListView一样的，即系统的默认的样式，因此我们可以在styles的xml文件中进行更改，更改如下：</p>

<pre class="line-numbers"><code class="language-java">&lt;!-- Application theme. --&gt;  
&lt;style name =&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;  
    &lt;!-- All customizations that are NOT specific to a particular API-level can go here. --&gt;  
    &lt;item name= &quot;android:listDivider&quot;&gt;@drawable/divider &lt;/item &gt;   
&lt;/style &gt;
</code></pre>

<p>divider的内容如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;  
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:shape=&quot;rectangle&quot; &gt;  
     
    &lt;!-- 填充的颜色 --&gt;  
    &lt;solid android:color =&quot;@color/color_red&quot;/&gt;  
       
    &lt;!--  线条大小 --&gt;  
    &lt;size android:height =&quot;1dp&quot; android:width =&quot;1dp&quot;/&gt;  
&lt;/shape&gt;
</code></pre>

<p>看到这肯定会有人说，这尼玛，好麻烦，还不如ListView简单呢，从上面的代码量看来确实是使用起来很复杂，但是如果此时你想将这个列表以GridView的形式展示出来，用RecylerView仅仅是换一行代码的事情.</p>

<h3 id="toc_15">简单的封装MKItemDecoration</h3>

<ul>
<li>支持简单颜色分割线</li>
<li>支持简单颜色分割线 + 文字：文字可以居左、居中</li>
<li>支持分割线跳过起始诺干个item，跳过最后一个item</li>
<li>支持分组悬停效果</li>
<li>支持自定义View作为Decoration</li>
</ul>

<p><figure><img src="media/15561207869978/2017101515080000957381.gif" alt=""/></figure></p>

<p>上图hoverGroup.gif的使用代码如下：</p>

<pre class="line-numbers"><code class="language-java">recyclerView.addItemDecoration(new MKItemDecoration.Builder()
.height(50)
.color(Color.parseColor(&quot;#525D97&quot;))
.textSize(30)
.textColor(Color.WHITE)
.itemOffset(0)
.iHover(new IHover() {
    @Override
    public boolean isGroup(int position) {
        return position % 4 == 0;
    }

    @Override
    public String groupText(int position) {
        return adapter.data.get(4 * (position / 4));
    }
})
.textAlign(MKItemDecoration.Builder.ALIGN_MIDDLE)
.build());
</code></pre>

<p>通过封装，利用builder模式来更好的自定义需要的Decoration，其中，为了支持自定义View，需要外部传入相关的view的资源id和需要绑定的数据List，控件内部会通过view的measure,layout,draw的流程，将其绘制在屏幕上。</p>

<p><a href="https://github.com/Dragon-Boat/library">具体代码</a></p>

<h2 id="toc_16">RecyclerView.ViewHolder</h2>

<ul>
<li><p><code>getPosition()</code>在API22的时候已经被废弃，因为它在异步处理器更新的时候不能准确表示数据，是模棱两可的。请根据你所使用的场景参照使用getLayoutPosition() 和 getAdapterPosition()</p></li>
<li><p><code>getAdapterPosition()</code>在调用<code>notifyDataSetChanged</code>之后并不能马上获取Adapter中的position, 要等布局结束之后才能获取到.在调用<code>notifyItemInserted(0)</code>之后能通过<code>getAdapterPosition()</code>获取适配器位置即使新的布局还没有计算。,如果你做一些用户点击,如果getAdapterPosition()返回NO_POSITION,最好忽略点击,因为你不知道用户点击(除非你有其他机制,如稳定的id查找条目)。</p></li>
<li><p><code>getLayoutPosition()</code>假设您正在使用LayoutManager或者想要访问ViewHolder当前点击的项目。在这种情况下,您应该使用<code>getLayoutPosition()</code>来获取当前布局位置。<code>mRecyclerView.findViewHolderForLayoutPosition(myViewHolder.getLayoutPosition() - 1)</code></p></li>
</ul>

<h2 id="toc_17">RecyclerView.ItemAnimator</h2>

<ul>
<li><p><code>animateAppearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br/>
当RecyclerView中的item显示到屏幕上时调用此方法。传入的layout之后的ViewHolder对象。</p></li>
<li><p><code>animateDisappearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br/>
当RecyclerView中的item在屏幕上由可见变为不可见时调用此方法。传入的layout之后的ViewHolder对象。</p></li>
<li><p><code>animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br/>
当RecyclerView中的item状态发生改变时调用此方法(notifyItemChanged(position))。<br/>
方法中传入了layout之前的ViewHolder和layout之后的ViewHolder对象，通过这两个ViewHolder对象获取其中的itemView进行动画效果。</p></li>
<li><p><code>runPendingAnimations()</code><br/>
统筹RecyclerView中所有的动画，统一启动执行</p></li>
<li><p><code>setRemoveDuration(long removeDuration)</code>/<code>getRemoveDuration()</code><br/>
 设置删除Item动画的延迟时间</p></li>
<li><p><code>setMoveDuration(long moveDuration)</code>/<code>getMoveDuration()</code><br/>
设置移动Item动画的延迟时间</p></li>
<li><p><code>setChangeDuration(long changeDuration)</code>/<code>getChangeDuration()</code><br/>
设置改变Item动画的延迟时间</p></li>
<li><p><code>setAddDuration(long addDuration)</code>/<code>getAddDuration()</code><br/>
设置添加Item动画的延迟时间</p></li>
<li><p><code>recordPostLayoutInformation(RecyclerView.State state, RecyclerView.ViewHolder viewHolder)</code><br/>
布局完成后对这个方法进行调用，记录view的必要信息。</p></li>
<li><p><code>onAnimationStarted(RecyclerView.ViewHolder viewHolder)</code><br/>
当一个新动画添加到这个ViewHolder上，调用此方法</p></li>
<li><p><code>onAnimationFinished(RecyclerView.ViewHolder viewHolder)</code><br/>
在<code>dispatchAnimationFinished(ViewHolder)</code>这个方法调用后调用</p></li>
<li><p><code>obtainHolderInfo()</code><br/>
获取ViewHolder保存的<code>RecyclerView.ItemAnimator.ItemHolderInfo</code>信息</p></li>
<li><p><code>isRunning()</code><br/>
判断是否有Item动画在运行</p></li>
<li><p><code>endAnimations()</code><br/>
停止所有动画</p></li>
<li><p><code>endAnimation(RecyclerView.ViewHolder item)</code><br/>
停止指定动画</p></li>
</ul>

<h2 id="toc_18">RecyclerView.LayoutManager</h2>

<p>RecyclerView.LayoutManager是一个抽象类，系统为我们提供了三个实现类</p>

<ul>
<li>LinearLayoutManager即线性布局，这个是在上面的例子中我们用到的布局</li>
<li>GridLayoutManager即表格布局</li>
<li>StaggeredGridLayoutManager即流式布局，如瀑布流效果假如将上述例子换成GridView的效果，那么相应的代码应该这样改</li>
</ul>

<h2 id="toc_19">给RecyclerView的Item添加点击事件</h2>

<p>ListView给我们提供了onItemClickListener的监听器，但对于RecyclerView来讲，非常可惜的是，该控件没有给我们提供这样的内置监听器方法，不过我们可以进行改造实现，可以这样实现Item的点击事件的监听，在我们的adapter中增加这两个方法</p>

<pre class="line-numbers"><code class="language-java">public interface OnItemClickListener{
    void onClick( int position);
    void onLongClick( int position);
}

public void setOnItemClickListener(OnItemClickListener onItemClickListener ){
    this. mOnItemClickListener=onItemClickListener;
}
</code></pre>

<p>然后onBindViewHolder方法要做如下更改</p>

<pre class="line-numbers"><code class="language-java">@Override  
public void onBindViewHolder(MyViewHolder holder, final int position) {  
    holder. tv.setText( mDatas.get(position));  
    if( mOnItemClickListener!= null){  
        holder. itemView.setOnClickListener( new OnClickListener() {  
        @Override  
        public void onClick(View v) {  
            mOnItemClickListener.onClick(position);  
        }  
    });  
                  
    holder. itemView.setOnLongClickListener( new OnLongClickListener() {  
        @Override  
        public boolean onLongClick(View v) {  
            mOnItemClickListener.onLongClick(position);  
            return false;  
        }  
    });  
}  
</code></pre>

<h2 id="toc_20">RecyclerView局部刷新界面</h2>

<h3 id="toc_21">来自于RecyclerView的原理</h3>

<p>RecyclerView addView调用的时候ViewGroup addView的源码，源码如下(如无特殊说明，以下源码均为api 25)</p>

<pre class="line-numbers"><code class="language-java">public void addView(View child, int index, LayoutParams params) {
    if (DBG) {
        System.out.println(this + &quot; addView&quot;);
    }
    if (child == null) {
        throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;);
    }

    // addViewInner() will call child.requestLayout() when setting the new LayoutParams
    // therefore, we call requestLayout() on ourselves before, so that the child&#39;s request
    // will be blocked at our level
    requestLayout();
    invalidate(true);
    addViewInner(child, index, params, false);
}
</code></pre>

<p>也就是会调用requestLayout，这是一个全局刷新的函数，也就是说整个界面将会被刷新，有全局刷新在View层级较多较复杂的时必然存在卡顿<br/>
那么RecyclerView 如何做到滑动时addView时不卡的呢，也就是说RecyclerView addView时候为什么没有引起RecyclerView 的onMeasure触发呢，答案就是RecyclerView 以下代码</p>

<pre class="line-numbers"><code class="language-java">@Override
public void requestLayout() {
    if (mEatRequestLayout == 0 &amp;&amp; !mLayoutFrozen) {
        super.requestLayout();
    } else {
        mLayoutRequestEaten = true;
    }
}
</code></pre>

<p>尼玛还有这种操作？？！复写requestLayout不向上报告，自己做内部处理，内部处理详见LayoutManager类的layoutChunk函数这里不细说。</p>

<p>好了，得到了黑科技的样本，接下来我就来实现一个黑科技的demo，改变View宽高时局部刷新界面。</p>

<h3 id="toc_22">黑科技的应用</h3>

<p>MainActivity布局如下</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.zjw.appmethodtime.MyRelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.zjw.appmethodtime.MainActivity&quot;&gt;

    &lt;com.zjw.appmethodtime.MyLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;com.zjw.appmethodtime.MyTextView
            android:id=&quot;@+id/text_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;50dp&quot;
            android:background=&quot;@color/colorPrimary&quot;
            android:text=&quot;Click Me&quot;
            android:gravity=&quot;center&quot;
            android:textSize=&quot;25sp&quot;
            android:textStyle=&quot;bold&quot;/&gt;
    &lt;/com.zjw.appmethodtime.MyLayout&gt;
&lt;/com.zjw.appmethodtime.MyRelativeLayout&gt;
</code></pre>

<p>自定义一个RelativeLayout 用以看是否局部刷新是否生效，如果局部刷新无效则顶层onMeasure会调用（因为改变了控件大小嘛全局刷新肯定会调用到处于顶层的onMeasure）</p>

<pre class="line-numbers"><code class="language-java">public class MyRelativeLayout extends RelativeLayout {
    public MyRelativeLayout(Context context) {
        super(context);
    }

    public MyRelativeLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre>

<p>自定义一个MyLayout 继承自LinearLayout ，这里只是demo你想用什么ViewGroup可以自己改。<br/>
这里MyLayout 就类似于RecyclerView 了，该子View宽高改变时会调用requestLayout，MyLayout 这里做拦截，然后自行处理。</p>

<pre class="line-numbers"><code class="language-java">public class MyLayout extends LinearLayout {
    private int mWidthMeasureSpec;
    private int mheightMeasureSpec;
    private int mLeft;
    private int mTop;
    private int mRight;
    private int mBottom;

    public static boolean shouldLocalIinvalidate = false;


    public MyLayout(Context context) {
        this(context, null);
    }

    public MyLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        mLeft = l;
        mTop = t;
        mRight = r;
        mBottom = b;
        super.onLayout(changed, l, t, r, b);
    }

    @Override
    public void requestLayout() {
        if (shouldLocalIinvalidate) {
            localRequestLayout();
        } else {
            super.requestLayout();
        }
    }

    @SuppressLint(&quot;WrongCall&quot;)
    void localRequestLayout() {
        onMeasure(mWidthMeasureSpec, mheightMeasureSpec);
        onLayout(true, mLeft, mTop, mRight, mBottom);
        invalidate();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        mWidthMeasureSpec = widthMeasureSpec;
        mheightMeasureSpec = widthMeasureSpec;
    }
}
</code></pre>

<p>以下代码就是在MainActivity里使用改变子View宽高局部刷新界面</p>

<pre class="line-numbers"><code class="language-java">package com.zjw.appmethodtime;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.TypedValue;
import android.view.View;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    protected MyRecycleView mListView;
    protected TextView mTextView;
    private float value;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        super.setContentView(R.layout.activity_main);
        initView();
    }

    private void initView() {
        Resources resources = this.getResources();
        value = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, resources.getDisplayMetrics());
        mTextView = (TextView) findViewById(R.id.text_view);
        mTextView.setOnClickListener(MainActivity.this);
    }

    @Override
    public void onClick(View view) {
        if (view.getId() == R.id.text_view) {
            view.getLayoutParams().height += value;
            //shouldLocalIinvalidate 为true 表示开启局部刷新 否则为关闭（MyLayout shouldLocalIinvalidate 默认为false）
            ((MyLayout) view.getParent()).shouldLocalIinvalidate = true;
            view.requestLayout();
            view.invalidate();
            //局部刷新完成及时恢复成可以全局刷新的状态
            ((MyLayout) view.getParent()).shouldLocalIinvalidate = false;
        }

    }
}
</code></pre>

<p>上面MainActivity 的onClick代码中开启了局部刷新（log代码自己加），效果图参见上文。<br/>
把上面的<code>((MyLayout) view.getParent()).shouldLocalIinvalidate = true;</code>这句去掉，这就是相当于不启用局部刷新，然后看<code>MyRelativeLayout</code> 的<code>onMeasure</code>方法log（log代码自己加），不启用局部刷新效果图见上文。</p>

<h3 id="toc_23">应用场景</h3>

<p>使用于某个ViewGroup宽高已定位置已定，该子view想改变宽高等场景。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869937.html">
                
                  <h1>Android-View详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">View有8个直接子类：</h2>

<p><code>AnalogClock</code>, <code>ImageView</code>, <code>KeyboardView</code>, <code>ProgressBar</code>, <code>SurfaceView</code>, <code>TextView</code>, <code>ViewGroup</code>, <code>ViewStub</code>。</p>

<h2 id="toc_1">View有54个间接子类：</h2>

<p><code>AbsListView</code>, <code>AbsSeekBar</code>,<code>AbsSpinner</code>, <code>AbsoluteLayout</code>, <code>AdapterView&lt;T extends Adapter&gt;</code>, <code>AppWidgetHostView</code>, <code>AutoCompleteTextView</code>,<code>Button</code>,<code>CheckBox</code>, <code>CheckedTextView</code>, <code>Chronometer</code>, <code>CompoundButton</code>,<code>DatePicker</code>, <code>DialerFilter</code>, <code>DigitalClock</code>,<code>EditText</code>, <code>ExpandableListView</code>, <code>ExtractEditText</code>,<code>FrameLayout</code>, <code>GLSurfaceView</code>,<code>Gallery</code>,<code>GestureOverlayView</code>,<code>GridView</code>, <code>HorizontalScrollView</code>, <code>ImageButton</code>, <code>ImageSwitcher</code>, <code>LinearLayout</code>,<code>ListView</code>,<code>MediaController</code>, <code>MultiAutoCompleteTextView</code>, <code>QuickContactBadge</code>,<code>RadioButton</code>,<code>RadioGroup</code>, <code>RatingBar</code>, <code>RelativeLayout</code>, <code>ScrollView</code>, <code>SeekBar</code>, <code>SlidingDrawer</code>, <code>Spinner</code>, <code>TabHost</code>, <code>TabWidget</code>, <code>TableLayout</code>, <code>TableRow</code>, <code>TextSwitcher</code>, <code>TimePicker</code>, <code>ToggleButton</code>, <code>TwoLineListItem</code>,<code>VideoView</code>, <code>ViewAnimator</code>, <code>ViewFlipper</code>, <code>ViewSwitcher</code>, <code>WebView</code>, <code>ZoomButton</code>, <code>ZoomControls</code></p>

<h2 id="toc_2">View的属性</h2>

<h3 id="toc_3">基本属性</h3>

<ul>
<li><p><code>android:alpha</code>关联方法: <code>setAlpha(float)</code> 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。</p></li>
<li><p><code>android:background</code>关联方法: <code>setBackgroundResource(int)</code> 属性说明: 视图背景</p></li>
<li><p><code>android:clickable</code>关联方法: <code>setClickable(boolean)</code> 属性说明: 视图是否可点击</p></li>
<li><p><code>android:contentDescription</code>关联方法: <code>setContentDescription(CharSequence)</code> 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明</p></li>
<li><p><code>android:drawingCacheQuality</code>关联方法: <code>setDrawingCacheQuality(int)</code> 属性说明: &quot;设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存&quot;</p></li>
<li><p><code>android:duplicateParentState</code>关联方法: 属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）</p></li>
<li><p><code>android:fadeScrollbars</code>关联方法: <code>setScrollbarFadingEnabled(boolean)</code> 属性说明: 定义在ScrollBar没有使用时，是否褪色。</p></li>
<li><p><code>android:fadingEdgeLength</code>关联方法: <code>getVerticalFadingEdgeLength()</code> 属性说明: 设置边框渐变的长度。</p></li>
<li><p><code>android:filterTouchesWhenObscured</code>关联方法: <code>setFilterTouchesWhenObscured(boolean)</code> 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。</p></li>
<li><p><code>android:fitsSystemWindows</code>关联方法: <code>setFitsSystemWindows(boolean)</code> 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏）</p></li>
<li><p><code>android:focusable</code>关联方法: <code>setFocusable(boolean)</code> 属性说明: 设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。在Touch模式下获取焦点需要设置focusableInTouchMode为true。</p></li>
<li><p><code>android:focusableInTouchMode</code>关联方法: <code>setFocusableInTouchMode(boolean)</code> 属性说明: 设置在Touch模式下View是否能取得焦点。</p></li>
<li><p><code>android:hapticFeedbackEnabled</code>关联方法: <code>setHapticFeedbackEnabled(boolean)</code> 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果</p></li>
<li><p><code>android:id</code>关联方法: <code>setId(int)</code> 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用<code>View.findViewById()</code> 或<code>Activity.findViewById()</code>根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。</p></li>
<li><p><code>android:importantForAccessibility</code>关联方法: <code>setImportantForAccessibility(int)</code> 属性说明: 设置可达性的重要性</p></li>
<li><p><code>android:isScrollContainer</code>关联方法: <code>setScrollContainer(boolean)</code> 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条</p></li>
<li><p><code>android:keepScreenOn</code>关联方法: <code>setKeepScreenOn(boolean)</code> 属性说明: 视图在可见的情况下是否保持唤醒状态。</p></li>
<li><p><code>android:layerType</code>关联方法: <code>setLayerType(int,Paint)</code> 属性说明: &quot;设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。&quot;</p></li>
<li><p><code>android:layoutDirection</code>关联方法: <code>setLayoutDirection(int)</code> 属性说明: 定义布局图纸的方向</p></li>
<li><p><code>android:longClickable</code>关联方法: <code>setLongClickable(boolean)</code> 属性说明: 是否响应长点击事件</p></li>
<li><p><code>android:minHeight</code>关联方法: <code>setMinimumHeight(int)</code> 属性说明: 设置视图最小高度</p></li>
<li><p><code>android:minWidth</code>关联方法: <code>setMinimumWidth(int)</code> 属性说明: 设置视图最小宽度</p></li>
<li><p><code>android:nextFocusDown</code>关联方法: <code>setNextFocusDownId(int)</code> 属性说明: 向下移动焦点时，下一个获取焦点的view的id</p></li>
<li><p><code>android:nextFocusForward</code>关联方法: <code>setNextFocusForwardId(int)</code> 属性说明: 下一个获取焦点的view的id</p></li>
<li><p><code>android:nextFocusLeft</code>关联方法: <code>setNextFocusLeftId(int)</code> 属性说明: 向左移动焦点时，下一个获取焦点的view的id</p></li>
<li><p><code>android:nextFocusRight</code>关联方法: <code>setNextFocusRightId(int)</code> 属性说明: 向右移动焦点时，下一个获取焦点的view的id</p></li>
<li><p><code>android:nextFocusUp</code>关联方法: <code>setNextFocusUpId(int)</code> 属性说明: 向上移动焦点时，下一个获取焦点的view的id</p></li>
<li><p><code>android:onClick</code>关联方法: 属性说明: 点击时，要调用的方法的名称。</p></li>
<li><p><code>android:padding</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 设置上下左右的边距</p></li>
<li><p><code>android:paddingBottom</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 下边距</p></li>
<li><p><code>android:paddingEnd</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 与<code>android:paddingRight</code>相同</p></li>
<li><p><code>android:paddingLeft</code>关联方法: <code>setPadding(int,int,int,int)</code> 属性说明: 左边距</p></li>
<li><p><code>android:paddingRight</code>关联方法: <code>setPadding(int,int,int,int)</code> 属性说明: 右边距</p></li>
<li><p><code>android:paddingStart</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: <code>android:paddingLeft</code>相同</p></li>
<li><p><code>android:paddingTop</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 上边距</p></li>
<li><p><code>android:requiresFadingEdge</code>关联方法: <code>setVerticalFadingEdgeEnabled(boolean)</code> 属性说明: 定义滚动时边缘是否褪色</p></li>
<li><p><code>android:rotation</code>关联方法: <code>setRotation(float)</code> 属性说明: 旋转度数</p></li>
<li><p><code>android:rotationX</code>关联方法: <code>setRotationX(float)</code> 属性说明: 水平旋转度数</p></li>
<li><p><code>android:rotationY</code>关联方法: <code>setRotationY(float)</code> 属性说明: 竖直旋转度数</p></li>
<li><p><code>android:saveEnabled</code>关联方法: <code>setSaveEnabled(boolean)</code> 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。</p></li>
<li><p><code>android:scaleX</code>关联方法: <code>setScaleX(float)</code> 属性说明: 水平方向缩放比例</p></li>
<li><p><code>android:scaleY</code>关联方法: <code>setScaleY(float)</code> 属性说明: 竖直方向缩放比例</p></li>
<li><p><code>android:scrollX</code>关联方法: 属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离</p></li>
<li><p><code>android:scrollY</code>关联方法: 属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离</p></li>
<li><p><code>android:scrollbarAlwaysDrawHorizontalTrack</code>关联方法: 属性说明: 是否总是绘制水平滚动条的滚动轨道</p></li>
<li><p><code>android:scrollbarAlwaysDrawVerticalTrack</code>关联方法: 属性说明: 是否总是绘制竖直滚动条的滚动轨道</p></li>
<li><p><code>android:scrollbarDefaultDelayBeforeFade</code>关联方法: <code>setScrollBarDefaultDelayBeforeFade(int)</code> 属性说明: 滚动条在n毫秒后开始淡出。</p></li>
<li><p><code>android:scrollbarFadeDuration</code>关联方法: <code>setScrollBarFadeDuration(int)</code> 属性说明: 滚动条用多长时间淡出完毕。</p></li>
<li><p><code>android:scrollbarSize</code>关联方法: <code>setScrollBarSize(int)</code> 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度</p></li>
<li><p><code>android:scrollbarStyle</code>关联方法: <code>setScrollBarStyle(int)</code> 属性说明: &quot;滚动条的风格。共4组值： <code>insideOverlay</code>——内贴图 <code>insideInset</code>——内插图 <code>outsideOverlay</code>——外贴图 <code>outsideInset</code>——外插图。 <code>inside</code>就是滚动条在绘制在padding以内；<code>outside</code>就是不需要绘制在<code>padding</code>内（即view的边界处）；<code>Overlay</code>是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；<code>Inset</code>是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。&quot;</p></li>
<li><p><code>android:scrollbarThumbHorizontal</code>关联方法: 属性说明: 水平滚动块的drawable对象</p></li>
<li><p><code>android:scrollbarThumbVertical</code>关联方法: 属性说明: 竖直滚动块的drawable对象</p></li>
<li><p><code>android:scrollbarTrackHorizontal</code>关联方法: 属性说明: 水平滚动条滚动轨道的drawable对象</p></li>
<li><p><code>android:scrollbarTrackVertical</code>关联方法: 属性说明: 竖直滚动条滚动轨道的drawable对象</p></li>
<li><p><code>android:scrollbars</code>关联方法: 属性说明: &quot;设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条&quot;</p></li>
<li><p><code>android:soundEffectsEnabled</code>关联方法: <code>setSoundEffectsEnabled(boolean)</code> 属性说明: 点击或触摸该view时，是否需要有声音效果</p></li>
<li><p><code>android:tag</code>关联方法: 属性说明: string标识。类似id，id是整数标识。</p></li>
<li><p><code>android:textAlignment</code>关联方法: <code>setTextAlignment(int)</code> 属性说明: 设置文本的显示方式。</p></li>
<li><p><code>android:textDirection</code>关联方法: <code>setTextDirection(int)</code> 属性说明: 设置文本的显示方向。</p></li>
<li><p><code>android:transformPivotX</code>关联方法: <code>setPivotX(float)</code> 属性说明: 水平方向偏转量</p></li>
<li><p><code>android:transformPivotY</code>关联方法: <code>setPivotY(float)</code> 属性说明: 竖直方向偏转量</p></li>
<li><p><code>android:translationX</code>关联方法: <code>setTranslationX(float)</code> 属性说明: 水平方向的移动距离</p></li>
<li><p><code>android:translationY</code>关联方法: <code>setTranslationY(float)</code> 属性说明: 竖直方向的移动距离</p></li>
<li><p><code>android:visibility</code>关联方法: <code>setVisibility(int)</code> 属性说明: &quot;view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见&quot;</p></li>
</ul>

<h3 id="toc_4">TextView属性说明</h3>

<p>下面对TextView的属性进行说明<code>android:autoLink</code>关联方法: <code>setAutoLinkMask(int)</code>属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值(none/web/email/phone/map/all)</p>

<ul>
<li><p><code>android:autoText</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</p></li>
<li><p><code>android:bufferType</code>关联方法: <code>setText(CharSequence,TextView.BufferType)</code>属性说明: 指定<code>getText()</code>方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。</p></li>
<li><p><code>android:capitalize</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。</p></li>
<li><p><code>android:cursorVisible</code>关联方法: <code>setCursorVisible(boolean)</code>属性说明: 设定光标为显示/隐藏，默认显示。</p></li>
<li><p><code>android:digits</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\n()”</p></li>
<li><p><code>android:drawableBottom</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。</p></li>
<li><p><code>android:drawableEnd</code>关联方法: <code>setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，&quot;@[+][package:]type:name&quot;或者&quot;?[package:][type:]name&quot;；也可以是颜色值，如&quot;#rgb&quot;, &quot;#argb&quot;, &quot;#rrggbb&quot;, or &quot;#aarrggbb&quot;。</p></li>
<li><p><code>android:drawableLeft</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的左边输出一个drawable。</p></li>
<li><p><code>android:drawablePadding</code>关联方法: <code>setCompoundDrawablePadding(int)</code>属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。</p></li>
<li><p><code>android:drawableRight</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的右边输出一个drawable。</p></li>
<li><p><code>android:drawableStart</code>关联方法: <code>setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，&quot;@[+][package:]type:name&quot;或者&quot;?[package:][type:]name&quot;；也可以是颜色值，如&quot;#rgb&quot;, &quot;#argb&quot;, &quot;#rrggbb&quot;, or &quot;#aarrggbb&quot;。</p></li>
<li><p><code>android:drawableTop</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的正上方输出一个drawable。</p></li>
<li><p><code>android:editable</code>关联方法: 属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。</p></li>
<li><p><code>android:editorExtras</code>关联方法: <code>setInputExtras(int)</code>属性说明: 设置文本的额外的输入数据。在EditView中才有效果。</p></li>
<li><p><code>android:ellipsize</code>关联方法: <code>setEllipsize(TextUtils.TruncateAt)</code>属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动)</p></li>
<li><p><code>android:ems</code>关联方法: <code>setEms(int)</code>属性说明: 设置TextView的宽度为N个字符的宽度。</p></li>
<li><p><code>android:fontFamily</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 文本的字形体系。</p></li>
<li><p><code>android:freezesText</code>关联方法: <code>setFreezesText(boolean)</code>属性说明: 设置保存文本的内容以及光标的位置。</p></li>
<li><p><code>android:gravity</code>关联方法: <code>setGravity(int)</code>属性说明: 设置文本位置，如设置成“center”，文本将居中显示。</p></li>
<li><p><code>android:height</code>关联方法: <code>setHeight(int)</code>属性说明: 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)</p></li>
<li><p><code>android:hint</code>关联方法: <code>setHint(int)</code>属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。</p></li>
<li><p><code>android:imeActionId</code>关联方法: <code>setImeActionLabel(CharSequence,int)</code>属性说明: 设置IME动作ID。</p></li>
<li><p><code>android:imeActionLabel</code>关联方法: <code>setImeActionLabel(CharSequence,int)</code>属性说明: 设置IME动作标签。在EditView再做说明。</p></li>
<li><p><code>android:imeOptions</code>关联方法: <code>setImeOptions(int)</code>属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。</p></li>
<li><p><code>android:includeFontPadding</code>关联方法: <code>setIncludeFontPadding(boolean)</code>属性说明: 设置文本是否包含顶部和底部额外空白，默认为true。</p></li>
<li><p><code>android:inputMethod</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。</p></li>
<li><p><code>android:inputType</code>关联方法: <code>setRawInputType(int)</code>属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。</p></li>
<li><p><code>android:lineSpacingExtra</code>关联方法: <code>setLineSpacing(float,float)</code>属性说明: 设置行间距。</p></li>
<li><p><code>android:lineSpacingMultiplier</code>关联方法: <code>setLineSpacing(float,float)</code>属性说明: 设置行间距的倍数。如”1.2”</p></li>
<li><p><code>android:lines</code>关联方法: <code>setLines(int)</code>属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。</p></li>
<li><p><code>android:linksClickable</code>关联方法: <code>setLinksClickable(boolean)</code>属性说明: 设置链接是否点击连接，即使设置了autoLink。</p></li>
<li><p><code>android:marqueeRepeatLimit</code>关联方法: <code>setMarqueeRepeatLimit(int)</code>属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。</p></li>
<li><p><code>android:maxEms</code>关联方法: <code>setMaxEms(int)</code>属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。</p></li>
<li><p><code>android:maxHeight</code>关联方法: <code>setMaxHeight(int)</code>属性说明: 设置文本区域的最大高度</p></li>
<li><p><code>android:maxLength</code>关联方法: <code>setFilters(InputFilter)</code>属性说明: 限制显示的文本长度，超出部分不显示。</p></li>
<li><p><code>android:maxLines</code>关联方法: <code>setMaxLines(int)</code>属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</p></li>
<li><p><code>android:maxWidth</code>关联方法: <code>setMaxWidth(int)</code>属性说明: 设置文本区域的最大宽度</p></li>
<li><p><code>android:minEms</code>关联方法: <code>setMinEms(int)</code>属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。</p></li>
<li><p><code>android:minHeight</code>关联方法: <code>setMinHeight(int)</code>属性说明: 设置文本区域的最小高度</p></li>
<li><p><code>android:minLines</code>关联方法: <code>setMinLines(int)</code>属性说明: 设置文本的最小行数，与lines类似。</p></li>
<li><p><code>android:minWidth</code>关联方法: <code>setMinWidth(int)</code>属性说明: 设置文本区域的最小宽度</p></li>
<li><p><code>android:numeric</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。</p></li>
<li><p><code>android:password</code>关联方法: <code>setTransformationMethod(TransformationMethod)</code>属性说明: 以小点”.”显示文本</p></li>
<li><p><code>android:phoneNumber</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置为电话号码的输入方式。</p></li>
<li><p><code>android:privateImeOptions</code>关联方法: <code>setPrivateImeOptions(String)</code>属性说明: 设置输入法选项，在EditText中才有作用。</p></li>
<li><p><code>android:scrollHorizontally</code>关联方法: <code>setHorizontallyScrolling(boolean)</code>属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。</p></li>
<li><p><code>android:selectAllOnFocus</code>关联方法: <code>setSelectAllOnFocus(boolean)</code>属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。</p></li>
<li><p><code>android:shadowColor</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。</p></li>
<li><p><code>android:shadowDx</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影横向坐标开始位置。</p></li>
<li><p><code>android:shadowDy</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影纵向坐标开始位置。</p></li>
<li><p><code>android:shadowRadius</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。</p></li>
<li><p><code>android:singleLine</code>关联方法: <code>setTransformationMethod(TransformationMethod)</code>属性说明: 设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如<code>android:text=&quot;test_ singleLine&quot;</code> <code>android:singleLine=&quot;true&quot;</code> <code>android:layout_width=&quot;20dp&quot;</code>将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行</p></li>
<li><p><code>android:text</code>关联方法: <code>setText(CharSequence,TextView.BufferType)</code>属性说明: 设置显示文本.</p></li>
<li><p><code>android:textAllCaps</code>关联方法: <code>setAllCaps(boolean)</code>属性说明: 设置文本全为大写。值为&quot;true&quot;或&quot;false&quot;。</p></li>
<li><p><code>android:textAppearance</code>关联方法: 属性说明: 设置文字外观。如“?<code>android:attr/textAppearanceLargeInverse</code></p></li>
<li><p><code>android:textColor</code>关联方法: <code>setTextColor(int)</code>属性说明: 设置文本颜色</p></li>
<li><p><code>android:textColorHighlight</code>关联方法: <code>setHighlightColor(int)</code>属性说明: 被选中文字的底色，默认为蓝色</p></li>
<li><p><code>android:textColorHint</code>关联方法: <code>setHintTextColor(int)</code>属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。</p></li>
<li><p><code>android:textColorLink</code>关联方法: <code>setLinkTextColor(int)</code>属性说明: 文字链接的颜色.</p></li>
<li><p><code>android:textIsSelectable</code>关联方法: <code>isTextSelectable()</code>属性说明: 设置非编辑文本可否被选择。值为&quot;true&quot;或&quot;false&quot;。</p></li>
<li><p><code>android:textScaleX</code>关联方法: <code>setTextScaleX(float)</code>属性说明: 设置文字之间间隔，默认为1.0f。</p></li>
<li><p><code>android:textSize</code>关联方法: <code>setTextSize(int,float)</code>属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp”</p></li>
<li><p><code>android:textStyle</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开</p></li>
<li><p><code>android:typeface</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3]</p></li>
<li><p><code>android:width</code>关联方法: <code>setWidth(int)</code>属性说明: 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。</p></li>
</ul>

<h3 id="toc_5">Other</h3>

<p>由于这两天在做listView的东西，所以整理出来一些我个人认为比较特别的属性，通过设置这样的属性可以做出更加美观的列表</p>

<ul>
<li>首先是stackFromBottom属性，这只该属性之后你做好的列表就会显示你列表的最下面，值为true和false</li>
</ul>

<p><code>android:stackFromBottom=&quot;true&quot;</code></p>

<ul>
<li><p>第二是transciptMode属性，需要用ListView或者其它显示大量Items的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件transcriptMode属性可以将 android平台的控件（支持ScrollBar）自动滑动到最底部。 <code>android:transcriptMode=&quot;alwaysScroll&quot;</code></p></li>
<li><p>第三cacheColorHint属性，很多人希望能够改变一下它的背景，使他能够符合整体的UI设计，改变背景背很简单只需要准备一张图片然后指定属性 <code>android:background=&quot;@drawable/bg&quot;</code>，不过不要高兴地太早，当你这么做以后，发现背景是变了，但是当你拖动，或者点击list空白位置的时候发现ListItem都变成黑色的了，破坏了整体效果。</p></li>
</ul>

<p>如果你只是换背景的颜色的话，可以直接指定<code>android:cacheColorHint</code>为你所要的颜色，如果你是用图片做背景的话，那也只要将<code>android:cacheColorHint</code>指定为透明（#00000000）就可以了</p>

<ul>
<li>第四divider属性，该属性作用是每一项之间需要设置一个图片做为间隔，或是去掉item之间的分割线</li>
</ul>

<p><code>android:divider=&quot;@drawable/list_driver&quot;</code>  其中  @drawable/list_driver 是一个图片资源，如果不想显示分割线则只要设置为<code>android:divider=&quot;@drawable/@null&quot;</code> 就可以了</p>

<ul>
<li>第五fadingEdge属性，上边和下边有黑色的阴影</li>
</ul>

<p><code>android:fadingEdge=&quot;none&quot;</code> 设置后没有阴影了~</p>

<ul>
<li>第六scrollbars属性，作用是隐藏listView的滚动条，</li>
</ul>

<p><code>android:scrollbars=&quot;none&quot;</code>与<code>setVerticalScrollBarEnabled(true);</code>的效果是一样的，不活动的时候隐藏，活动的时候也隐藏</p>

<ul>
<li>第七fadeScrollbars属性，<code>android:fadeScrollbars=&quot;true&quot;</code>  配置ListView布局的时候，设置这个属性为true就可以实现滚动条的自动隐藏和显示。</li>
</ul>

<h2 id="toc_6">自定义View的方法</h2>

<h3 id="toc_7">常用方法</h3>

<ul>
<li><code>onFinishInflate()</code> 当View中所有的子控件均被映射成xml后触发</li>
<li><code>onMeasure(int, int)</code> 确定所有子元素的大小</li>
<li><code>onLayout(boolean, int, int, int, int)</code> 当View分配所有的子元素的大小和位置时触发</li>
<li><code>onSizeChanged(int, int, int, int)</code> 当view的大小发生变化时触发</li>
<li><code>onDraw(Canvas)</code> view渲染内容的细节</li>
<li><code>onKeyDown(int, KeyEvent)</code> 有按键按下后触发</li>
<li><code>onKeyUp(int, KeyEvent)</code> 有按键按下后弹起时触发</li>
<li><code>onTrackballEvent(MotionEvent)</code> 轨迹球事件</li>
<li><code>onTouchEvent(MotionEvent)</code> 触屏事件</li>
<li><code>onFocusChanged(boolean, int, Rect)</code> 当View获取或失去焦点时触发 </li>
<li><code>onWindowFocusChanged(boolean)</code> 当窗口包含的view获取或失去焦点时触发</li>
<li><code>onAttachedToWindow()</code> 当view被附着到一个窗口时触发</li>
<li><code>onDetachedFromWindow()</code> 当view离开附着的窗口时触发，提示该方法和  onAttachedToWindow() 是相反的。</li>
<li><code>onWindowVisibilityChanged(int)</code> 当窗口中包含的可见的view发生变化时触发</li>
</ul>

<h3 id="toc_8">公用方法</h3>

<ul>
<li><code>void addChildrenForAccessibility(ArrayList&lt;View&gt; outChildren)</code> 
Adds the children of this View relevant for accessibility to the given list as output.</li>
<li><code>void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo info, String extraDataKey, Bundle arguments)</code>
Adds extra data to an AccessibilityNodeInfo based on an explicit request for the additional data.</li>
<li><code>void addFocusables(ArrayList&lt;View&gt; views, int direction)</code>
Add any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views.</li>
<li><code>void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode)</code>
Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views.</li>
<li><code>void addKeyboardNavigationClusters(Collection&lt;View&gt; views, int direction)</code>
Adds any keyboard navigation cluster roots that are descendants of this view (possibly including this view if it is a cluster root itself) to views.</li>
<li><code>void addOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)</code>
Add a listener for attach state changes.</li>
<li><code>void addOnLayoutChangeListener(View.OnLayoutChangeListener listener)</code>
Add a listener that will be called when the bounds of the view change due to layout processing.</li>
<li><code>void addTouchables(ArrayList&lt;View&gt; views)</code>
Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself) to views.</li>
<li><code>ViewPropertyAnimator animate()</code>
This method returns a ViewPropertyAnimator object, which can be used to animate specific properties on this View.</li>
<li><code>void announceForAccessibility(CharSequence text)</code>
Convenience method for sending a TYPE_ANNOUNCEMENT AccessibilityEvent to make an announcement which is related to some sort of a context change for which none of the events representing UI transitions is a good fit.</li>
<li><code>void autoFill(AutoFillValue value)</code>
Automatically fills the content of this view with the value.</li>
<li><code>void autoFillVirtual(int virtualId, AutoFillValue value)</code>
Automatically fills the content of a virtual view with the value<br/>
See autoFill(AutoFillValue) and onProvideAutoFillVirtualStructure(ViewStructure, int) for more info.</li>
<li><code>void bringToFront()</code>
Change the view&#39;s z order in the tree, so it&#39;s on top of other sibling views.</li>
<li><code>void buildDrawingCache(boolean autoScale)</code>
Forces the drawing cache to be built if the drawing cache is invalid.</li>
<li><code>void buildDrawingCache()</code>
Calling this method is equivalent to calling buildDrawingCache(false).</li>
<li><code>void buildLayer()</code>
Forces this view&#39;s layer to be created and this view to be rendered into its layer.</li>
<li><code>boolean callOnClick()</code>
Directly call any attached OnClickListener.</li>
<li><code>boolean canResolveLayoutDirection()</code>
Check if layout direction resolution can be done.</li>
<li><code>boolean canResolveTextAlignment()</code>
Check if text alignment resolution can be done.</li>
<li><code>boolean canResolveTextDirection()</code>
Check if text direction resolution can be done.</li>
<li><code>boolean canScrollHorizontally(int direction)</code>
Check if this view can be scrolled horizontally in a certain direction.</li>
<li><code>boolean canScrollVertically(int direction)</code>
Check if this view can be scrolled vertically in a certain direction.</li>
<li><code>final void cancelDragAndDrop()</code>
Cancels an ongoing drag and drop operation.</li>
<li><code>void cancelLongPress()</code>
Cancels a pending long press.</li>
<li><code>final void cancelPendingInputEvents()</code>
Cancel any deferred high-level input events that were previously posted to the event queue.</li>
<li><code>boolean checkInputConnectionProxy(View view)</code>
Called by the InputMethodManager when a view who is not the current input connection target is trying to make a call on the manager.</li>
<li><code>void clearAnimation()</code>
Cancels any animations for this view.</li>
<li><code>void clearFocus()</code>
Called when this view wants to give up focus.<br/>
static int combineMeasuredStates(int curState, int newState)<br/>
Merge two states as returned by getMeasuredState().</li>
<li><code>void computeScroll()</code>
Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.</li>
<li><code>WindowInsets computeSystemWindowInsets(WindowInsets in, Rect outLocalInsets)</code>
Compute insets that should be consumed by this view and the ones that should propagate to those under it.</li>
<li><code>AccessibilityNodeInfo createAccessibilityNodeInfo()</code>
Returns an AccessibilityNodeInfo representing this view from the point of view of an AccessibilityService.</li>
<li><code>void createContextMenu(ContextMenu menu)</code>
Show the context menu for this view.</li>
<li><code>void destroyDrawingCache()</code>
Frees the resources used by the drawing cache.</li>
<li><code>WindowInsets dispatchApplyWindowInsets(WindowInsets insets)</code>
Request to apply the given window insets to this view or another view in its subtree.</li>
<li><code>boolean dispatchCapturedPointerEvent(MotionEvent event)</code>
Pass a captured pointer event down to the focused view.</li>
<li><code>void dispatchConfigurationChanged(Configuration newConfig)</code>
Dispatch a notification about a resource configuration change down the view hierarchy.</li>
<li><code>void dispatchDisplayHint(int hint)</code>
Dispatch a hint about whether this view is displayed.</li>
<li><code>boolean dispatchDragEvent(DragEvent event)</code>
Detects if this View is enabled and has a drag event listener.</li>
<li><code>void dispatchDrawableHotspotChanged(float x, float y)</code>
Dispatches drawableHotspotChanged to all of this View&#39;s children.</li>
<li><code>void dispatchFinishTemporaryDetach()</code>
Dispatch onFinishTemporaryDetach() to this View and its direct children if this is a container View.</li>
<li><code>boolean dispatchGenericMotionEvent(MotionEvent event)</code>
Dispatch a generic motion event.</li>
<li><code>boolean dispatchKeyEvent(KeyEvent event)</code>
Dispatch a key event to the next view on the focus path.</li>
<li><code>boolean dispatchKeyEventPreIme(KeyEvent event)</code>
Dispatch a key event before it is processed by any input method associated with the view hierarchy.</li>
<li><code>boolean dispatchKeyShortcutEvent(KeyEvent event)</code>
Dispatches a key shortcut event.</li>
<li><code>boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed)</code>
Dispatch a fling to a nested scrolling parent.</li>
<li><code>boolean dispatchNestedPreFling(float velocityX, float velocityY)</code>
Dispatch a fling to a nested scrolling parent before it is processed by this view.</li>
<li><code>boolean dispatchNestedPrePerformAccessibilityAction(int action, Bundle arguments)</code>
Report an accessibility action to this view&#39;s parents for delegated processing.</li>
<li><code>boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)</code>
Dispatch one step of a nested scroll in progress before this view consumes any portion of it.</li>
<li><code>boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)</code>
Dispatch one step of a nested scroll in progress.</li>
<li><code>void dispatchPointerCaptureChanged(boolean hasCapture)</code></li>
<li><code>boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event)</code>
Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.</li>
<li><code>void dispatchProvideAutoFillStructure(ViewStructure structure, int flags)</code>
Dispatch creation of ViewStructure down the hierarchy.</li>
<li><code>void dispatchProvideStructure(ViewStructure structure)</code>
Dispatch creation of ViewStructure down the hierarchy.</li>
<li><code>void dispatchStartTemporaryDetach()</code>
Dispatch onStartTemporaryDetach() to this View and its direct children if this is a container View.</li>
<li><code>void dispatchSystemUiVisibilityChanged(int visibility)</code>
Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener) down the view hierarchy.</li>
<li><code>boolean dispatchTouchEvent(MotionEvent event)</code>
Pass the touch screen motion event down to the target view, or this view if it is the target.</li>
<li><code>boolean dispatchTrackballEvent(MotionEvent event)</code>
Pass a trackball motion event down to the focused view.<br/>
boolean dispatchUnhandledMove(View focused, int direction)<br/>
This method is the last chance for the focused view and its ancestors to respond to an arrow key.</li>
<li><code>void dispatchWindowFocusChanged(boolean hasFocus)</code>
Called when the window containing this view gains or loses window focus.</li>
<li><code>void dispatchWindowSystemUiVisiblityChanged(int visible)</code>
Dispatch callbacks to onWindowSystemUiVisibilityChanged(int) down the view hierarchy.</li>
<li><code>void dispatchWindowVisibilityChanged(int visibility)</code>
Dispatch a window visibility change down the view hierarchy.</li>
<li><code>void draw(Canvas canvas)</code>
Manually render this view (and all of its children) to the given Canvas.</li>
<li><code>void drawableHotspotChanged(float x, float y)</code>
This function is called whenever the view hotspot changes and needs to be propagated to drawables or child views managed by the view.</li>
<li><code>View findFocus()</code>
Find the view in the hierarchy rooted at this view that currently has focus.</li>
<li><code>final &lt;T extends View&gt; T findViewById(int id)</code>
Look for a child view with the given id.</li>
<li><code>final &lt;T extends View&gt; T findViewWithTag(Object tag)</code>
Look for a child view with the given tag.</li>
<li><code>void findViewsWithText(ArrayList&lt;View&gt; outViews, CharSequence searched, int flags)</code>
Finds the Views that contain given text.</li>
<li><code>View focusSearch(int direction)</code>
Find the nearest view in the specified direction that can take focus.</li>
<li><code>void forceHasOverlappingRendering(boolean hasOverlappingRendering)</code>
Sets the behavior for overlapping rendering for this view (see hasOverlappingRendering() for more details on this behavior).</li>
<li><code>void forceLayout()</code>
Forces this view to be laid out during the next layout pass.</li>
<li><code>static int generateViewId()</code>
Generate a value suitable for use in setId(int).</li>
<li><code>CharSequence getAccessibilityClassName()</code>
Return the class name of this object to be used for accessibility purposes.</li>
<li><code>int getAccessibilityLiveRegion()</code>
Gets the live region mode for this View.</li>
<li><code>AccessibilityNodeProvider getAccessibilityNodeProvider()</code>
Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content.</li>
<li><code>int getAccessibilityTraversalAfter()</code>
Gets the id of a view after which this one is visited in accessibility traversal.</li>
<li><code>int getAccessibilityTraversalBefore()</code>
Gets the id of a view before which this one is visited in accessibility traversal.</li>
<li><code>float getAlpha()</code>
The opacity of the view.</li>
<li><code>Animation getAnimation()</code>
Get the animation currently associated with this view.</li>
<li><code>IBinder getApplicationWindowToken()</code>
Retrieve a unique token identifying the top-level &quot;real&quot; window of the window that this view is attached to.</li>
<li><code>int getAutoFillMode()</code>
Returns the auto-fill mode for this view.</li>
<li><code>AutoFillType getAutoFillType()</code>
Describes the auto-fill type that should be used on calls to autoFill(AutoFillValue) and autoFillVirtual(int, AutoFillValue).</li>
<li><code>AutoFillValue getAutoFillValue()</code>
Gets the View&#39;s current auto-fill value.</li>
<li><code>Drawable getBackground()</code>
Gets the background drawable</li>
<li><code>ColorStateList getBackgroundTintList()</code>
Return the tint applied to the background drawable, if specified.</li>
<li><code>PorterDuff.Mode getBackgroundTintMode()</code>
Return the blending mode used to apply the tint to the background drawable, if specified.</li>
<li><code>int getBaseline()</code>
Return the offset of the widget&#39;s text baseline from the widget&#39;s top boundary.</li>
<li><code>final int getBottom()</code>
Bottom position of this view relative to its parent.</li>
<li><code>float getCameraDistance()</code>
Gets the distance along the Z axis from the camera to this view.</li>
<li><code>boolean getClipBounds(Rect outRect)</code>
Populates an output rectangle with the clip bounds of the view, returning true if successful or false if the view&#39;s clip bounds are null.</li>
<li><code>Rect getClipBounds()</code>
Returns a copy of the current clipBounds.</li>
<li><code>final boolean getClipToOutline()</code>
Returns whether the Outline should be used to clip the contents of the View.</li>
<li><code>CharSequence getContentDescription()</code>
Returns the View&#39;s content description.</li>
<li><code>final Context getContext()</code>
Returns the context the view is running in, through which it can access the current theme, resources, etc.</li>
<li><code>static int getDefaultSize(int size, int measureSpec)</code>
Utility to return a default size.</li>
<li><code>Display getDisplay()</code>
Gets the logical display to which the view&#39;s window has been attached.</li>
<li><code>final int[] getDrawableState()</code>
Return an array of resource IDs of the drawable states representing the current state of the view.</li>
<li><code>Bitmap getDrawingCache()</code>
Calling this method is equivalent to calling getDrawingCache(false).</li>
<li><code>Bitmap getDrawingCache(boolean autoScale)</code>
Returns the bitmap in which this view drawing is cached.</li>
<li><code>int getDrawingCacheBackgroundColor()</code></li>
<li><code>int getDrawingCacheQuality()</code>
Returns the quality of the drawing cache.</li>
<li><code>void getDrawingRect(Rect outRect)</code>
Return the visible drawing bounds of your view.</li>
<li><code>long getDrawingTime()</code>
Return the time at which the drawing of the view hierarchy started.</li>
<li><code>float getElevation()</code>
The base elevation of this view relative to its parent, in pixels.</li>
<li><code>boolean getFilterTouchesWhenObscured()</code>
Gets whether the framework should discard touches when the view&#39;s window is obscured by another visible window.</li>
<li><code>boolean getFitsSystemWindows()</code>
Check for state of setFitsSystemWindows(boolean).</li>
<li><code>int getFocusable()</code>
Returns the focusable setting for this view.</li>
<li><code>ArrayList&lt;View&gt; getFocusables(int direction)</code>
Find and return all focusable views that are descendants of this view, possibly including this view if it is focusable itself.</li>
<li><code>void getFocusedRect(Rect r)</code>
When a view has focus and the user navigates away from it, the next view is searched for starting from the rectangle filled in by this method.</li>
<li><code>Drawable getForeground()</code>
Returns the drawable used as the foreground of this View.</li>
<li><code>int getForegroundGravity()</code>
Describes how the foreground is positioned.</li>
<li><code>ColorStateList getForegroundTintList()</code>
Return the tint applied to the foreground drawable, if specified.</li>
<li><code>PorterDuff.Mode getForegroundTintMode()</code>
Return the blending mode used to apply the tint to the foreground drawable, if specified.</li>
<li><code>final boolean getGlobalVisibleRect(Rect r)</code></li>
<li><code>boolean getGlobalVisibleRect(Rect r, Point globalOffset)</code>
If some part of this view is not clipped by any of its parents, then return that area in r in global (root) coordinates.</li>
<li><code>Handler getHandler()</code></li>
<li><code>final boolean getHasOverlappingRendering()</code>
Returns the value for overlapping rendering that is used internally.</li>
<li><code>final int getHeight()</code>
Return the height of your view.</li>
<li><code>void getHitRect(Rect outRect)</code>
Hit rectangle in parent&#39;s coordinates</li>
<li><code>int getHorizontalFadingEdgeLength()</code>
Returns the size of the horizontal faded edges used to indicate that more content in this view is visible.</li>
<li><code>int getId()</code>
Returns this view&#39;s identifier.<br/>
int getImportantForAccessibility()<br/>
Gets the mode for determining whether this View is important for accessibility.</li>
<li><code>boolean getKeepScreenOn()</code>
Returns whether the screen should remain on, corresponding to the current value of KEEP_SCREEN_ON.</li>
<li><code>KeyEvent.DispatcherState getKeyDispatcherState()</code>
Return the global KeyEvent.DispatcherState for this view&#39;s window.</li>
<li><code>int getLabelFor()</code>
Gets the id of a view for which this view serves as a label for accessibility purposes.</li>
<li><code>int getLayerType()</code>
Indicates what type of layer is currently associated with this view.</li>
<li><code>int getLayoutDirection()</code>
Returns the resolved layout direction for this view.</li>
<li><code>ViewGroup.LayoutParams getLayoutParams()</code>
Get the LayoutParams associated with this view.</li>
<li><code>final int getLeft()</code>
Left position of this view relative to its parent.</li>
<li><code>final boolean getLocalVisibleRect(Rect r)</code></li>
<li><code>void getLocationInWindow(int[] outLocation)</code>
Computes the coordinates of this view in its window.</li>
<li><code>void getLocationOnScreen(int[] outLocation)</code>
Computes the coordinates of this view on the screen.</li>
<li><code>Matrix getMatrix()</code>
The transform matrix of this view, which is calculated based on the current rotation, scale, and pivot properties.</li>
<li><code>final int getMeasuredHeight()</code>
Like getMeasuredHeightAndState(), but only returns the raw height component (that is the result is masked by MEASURED_SIZE_MASK).</li>
<li><code>final int getMeasuredHeightAndState()</code>
Return the full height measurement information for this view as computed by the most recent call to measure(int, int).</li>
<li><code>final int getMeasuredState()</code>
Return only the state bits of getMeasuredWidthAndState() and getMeasuredHeightAndState(), combined into one integer.</li>
<li><code>final int getMeasuredWidth()</code>
Like getMeasuredWidthAndState(), but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK).</li>
<li><code>final int getMeasuredWidthAndState()</code>
Return the full width measurement information for this view as computed by the most recent call to measure(int, int).</li>
<li><code>int getMinimumHeight()</code>
Returns the minimum height of the view.</li>
<li><code>int getMinimumWidth()</code>
Returns the minimum width of the view.</li>
<li><code>int getNextClusterForwardId()</code>
Gets the id of the root of the next keyboard navigation cluster.</li>
<li><code>int getNextFocusDownId()</code>
Gets the id of the view to use when the next focus is FOCUS_DOWN.</li>
<li><code>int getNextFocusForwardId()</code>
Gets the id of the view to use when the next focus is FOCUS_FORWARD.</li>
<li><code>int getNextFocusLeftId()</code>
Gets the id of the view to use when the next focus is FOCUS_LEFT.</li>
<li><code>int getNextFocusRightId()</code>
Gets the id of the view to use when the next focus is FOCUS_RIGHT.</li>
<li><code>int getNextFocusUpId()</code>
Gets the id of the view to use when the next focus is FOCUS_UP.<br/>
View.OnFocusChangeListener getOnFocusChangeListener()<br/>
Returns the focus-change callback registered for this view.</li>
<li><code>ViewOutlineProvider getOutlineProvider()</code>
Returns the current ViewOutlineProvider of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping.</li>
<li><code>int getOverScrollMode()</code>
Returns the over-scroll mode for this view.</li>
<li><code>ViewOverlay getOverlay()</code>
Returns the overlay for this view, creating it if it does not yet exist.</li>
<li><code>int getPaddingBottom()</code>
Returns the bottom padding of this view.</li>
<li><code>int getPaddingEnd()</code>
Returns the end padding of this view depending on its resolved layout direction.</li>
<li><code>int getPaddingLeft()</code>
Returns the left padding of this view.</li>
<li><code>int getPaddingRight()</code>
Returns the right padding of this view.</li>
<li><code>int getPaddingStart()</code>
Returns the start padding of this view depending on its resolved layout direction.</li>
<li><code>int getPaddingTop()</code>
Returns the top padding of this view.</li>
<li><code>final ViewParent getParent()</code>
Gets the parent of this view.</li>
<li><code>ViewParent getParentForAccessibility()</code>
Gets the parent for accessibility purposes.</li>
<li><code>float getPivotX()</code>
The x location of the point around which the view is rotated and scaled.</li>
<li><code>float getPivotY()</code>
The y location of the point around which the view is rotated and scaled.</li>
<li><code>PointerIcon getPointerIcon()</code>
Gets the pointer icon for the current view.</li>
<li><code>Resources getResources()</code>
Returns the resources associated with this view.</li>
<li><code>final boolean getRevealOnFocusHint()</code>
Returns this view&#39;s preference for reveal behavior when it gains focus.</li>
<li><code>final int getRight()</code>
Right position of this view relative to its parent.</li>
<li><code>View getRootView()</code>
Finds the topmost view in the current view hierarchy.</li>
<li><code>WindowInsets getRootWindowInsets()</code>
Provide original WindowInsets that are dispatched to the view hierarchy.</li>
<li><code>float getRotation()</code>
The degrees that the view is rotated around the pivot point.</li>
<li><code>float getRotationX()</code>
The degrees that the view is rotated around the horizontal axis through the pivot point.</li>
<li><code>float getRotationY()</code>
The degrees that the view is rotated around the vertical axis through the pivot point.</li>
<li><code>float getScaleX()</code>
The amount that the view is scaled in x around the pivot point, as a proportion of the view&#39;s unscaled width.</li>
<li><code>float getScaleY()</code>
The amount that the view is scaled in y around the pivot point, as a proportion of the view&#39;s unscaled height.</li>
<li><code>int getScrollBarDefaultDelayBeforeFade()</code>
Returns the delay before scrollbars fade.</li>
<li><code>int getScrollBarFadeDuration()</code>
Returns the scrollbar fade duration.</li>
<li><code>int getScrollBarSize()</code>
Returns the scrollbar size.</li>
<li><code>int getScrollBarStyle()</code>
Returns the current scrollbar style.</li>
<li><code>int getScrollIndicators()</code>
Returns a bitmask representing the enabled scroll indicators.</li>
<li><code>final int getScrollX()</code>
Return the scrolled left position of this view.</li>
<li><code>final int getScrollY()</code>
Return the scrolled top position of this view.</li>
<li><code>int getSolidColor()</code>
Override this if your view is known to always be drawn on top of a solid color background, and needs to draw fading edges.<br/>
StateListAnimator getStateListAnimator()<br/>
Returns the current StateListAnimator if exists.</li>
<li><code>int getSystemUiVisibility()</code>
Returns the last setSystemUiVisibility(int) that this view has requested.</li>
<li><code>Object getTag()</code>
Returns this view&#39;s tag.</li>
<li><code>Object getTag(int key)</code>
Returns the tag associated with this view and the specified key.</li>
<li><code>int getTextAlignment()</code>
Return the resolved text alignment.</li>
<li><code>int getTextDirection()</code>
Return the resolved text direction.</li>
<li><code>CharSequence getTooltipText()</code>
Returns the view&#39;s tooltip text.</li>
<li><code>final int getTop()</code>
Top position of this view relative to its parent.</li>
<li><code>TouchDelegate getTouchDelegate()</code>
Gets the TouchDelegate for this View.</li>
<li><code>ArrayList&lt;View&gt; getTouchables()</code>
Find and return all touchable views that are descendants of this view, possibly including this view if it is touchable itself.</li>
<li><code>String getTransitionName()</code>
Returns the name of the View to be used to identify Views in Transitions.</li>
<li><code>float getTranslationX()</code>
The horizontal location of this view relative to its left position.</li>
<li><code>float getTranslationY()</code>
The vertical location of this view relative to its top position.</li>
<li><code>float getTranslationZ()</code>
The depth location of this view relative to its elevation.</li>
<li><code>int getVerticalFadingEdgeLength()</code>
Returns the size of the vertical faded edges used to indicate that more content in this view is visible.</li>
<li><code>int getVerticalScrollbarPosition()</code></li>
<li><code>int getVerticalScrollbarWidth()</code>
Returns the width of the vertical scrollbar.</li>
<li><code>ViewTreeObserver getViewTreeObserver()</code>
Returns the ViewTreeObserver for this view&#39;s hierarchy.</li>
<li><code>int getVisibility()</code>
Returns the visibility status for this view.</li>
<li><code>final int getWidth()</code>
Return the width of the your view.</li>
<li><code>WindowId getWindowId()</code>
Retrieve the WindowId for the window this view is currently attached to.</li>
<li><code>int getWindowSystemUiVisibility()</code>
Returns the current system UI visibility that is currently set for the entire window.</li>
<li><code>IBinder getWindowToken()</code>
Retrieve a unique token identifying the window this view is attached to.</li>
<li><code>int getWindowVisibility()</code>
Returns the current visibility of the window this view is attached to (either GONE, INVISIBLE, or VISIBLE).</li>
<li><code>void getWindowVisibleDisplayFrame(Rect outRect)</code>
Retrieve the overall visible display size in which the window this view is attached to has been positioned in.</li>
<li><code>float getX()</code>
The visual x position of this view, in pixels.</li>
<li><code>float getY()</code>
The visual y position of this view, in pixels.</li>
<li><code>float getZ()</code>
The visual z position of this view, in pixels.</li>
<li><code>boolean hasExplicitFocusable()</code>
Returns true if this view is focusable or if it contains a reachable View for which hasExplicitFocusable() returns true.</li>
<li><code>boolean hasFocus()</code>
Returns true if this view has focus itself, or is the ancestor of the view that has focus.</li>
<li><code>boolean hasFocusable()</code>
Returns true if this view is focusable or if it contains a reachable View for which hasFocusable() returns true.</li>
<li><code>boolean hasNestedScrollingParent()</code>
Returns true if this view has a nested scrolling parent.</li>
<li><code>boolean hasOnClickListeners()</code>
Return whether this view has an attached OnClickListener.</li>
<li><code>boolean hasOverlappingRendering()</code>
Returns whether this View has content which overlaps.</li>
<li><code>boolean hasPointerCapture()</code>
Checks pointer capture status.</li>
<li><code>boolean hasTransientState()</code>
Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible.</li>
<li><code>boolean hasWindowFocus()</code>
Returns true if this view is in a window that currently has window focus.</li>
<li><code>static View inflate(Context context, int resource, ViewGroup root)</code>
Inflate a view from an XML resource.</li>
<li><code>void invalidate()</code>
Invalidate the whole view.</li>
<li><code>void invalidate(Rect dirty)</code>
Mark the area defined by dirty as needing to be drawn.</li>
<li><code>void invalidate(int l, int t, int r, int b)</code>
Mark the area defined by the rect (l,t,r,b) as needing to be drawn.</li>
<li><code>void invalidateDrawable(Drawable drawable)</code>
Invalidates the specified Drawable.</li>
<li><code>void invalidateOutline()</code>
Called to rebuild this View&#39;s Outline from its outline provider</li>
<li><code>boolean isAccessibilityFocused()</code>
Returns whether this View is accessibility focused.</li>
<li><code>boolean isActivated()</code>
Indicates the activation state of this view.</li>
<li><code>boolean isAttachedToWindow()</code>
Returns true if this view is currently attached to a window.</li>
<li><code>boolean isClickable()</code>
Indicates whether this view reacts to click events or not.</li>
<li><code>boolean isContextClickable()</code>
Indicates whether this view reacts to context clicks or not.</li>
<li><code>boolean isDirty()</code>
True if this view has changed since the last time being drawn.</li>
<li><code>boolean isDrawingCacheEnabled()</code>
Indicates whether the drawing cache is enabled for this view.</li>
<li><code>boolean isDuplicateParentStateEnabled()</code>
Indicates whether this duplicates its drawable state from its parent.</li>
<li><code>boolean isEnabled()</code>
Returns the enabled status for this view.</li>
<li><code>final boolean isFocusable()</code>
Returns whether this View is currently able to take focus.</li>
<li><code>final boolean isFocusableInTouchMode()</code>
When a view is focusable, it may not want to take focus when in touch mode.</li>
<li><code>boolean isFocused()</code>
Returns true if this view has focus</li>
<li><code>final boolean isFocusedByDefault()</code>
Returns whether this View should receive focus when the focus is restored for the view hierarchy containing this view.</li>
<li><code>boolean isHapticFeedbackEnabled()</code></li>
<li><code>boolean isHardwareAccelerated()</code>
Indicates whether this view is attached to a hardware accelerated window or not.</li>
<li><code>boolean isHorizontalFadingEdgeEnabled()</code>
Indicate whether the horizontal edges are faded when the view is scrolled horizontally.</li>
<li><code>boolean isHorizontalScrollBarEnabled()</code>
Indicate whether the horizontal scrollbar should be drawn or not.</li>
<li><code>boolean isHovered()</code>
Returns true if the view is currently hovered.</li>
<li><code>boolean isImportantForAccessibility()</code>
Computes whether this view should be exposed for accessibility.</li>
<li><code>boolean isInEditMode()</code>
Indicates whether this View is currently in edit mode.</li>
<li><code>boolean isInLayout()</code>
Returns whether the view hierarchy is currently undergoing a layout pass.</li>
<li><code>boolean isInTouchMode()</code>
Returns whether the device is currently in touch mode.</li>
<li><code>final boolean isKeyboardNavigationCluster()</code>
Returns whether this View is a root of a keyboard navigation cluster.</li>
<li><code>boolean isLaidOut()</code>
Returns true if this view has been through at least one layout since it was last attached to or detached from a window.</li>
<li><code>boolean isLayoutDirectionResolved()</code></li>
<li><code>boolean isLayoutRequested()</code>
Indicates whether or not this view&#39;s layout will be requested during the next hierarchy layout pass.</li>
<li><code>boolean isLongClickable()</code>
Indicates whether this view reacts to long click events or not.</li>
<li><code>boolean isNestedScrollingEnabled()</code>
Returns true if nested scrolling is enabled for this view.</li>
<li><code>boolean isOpaque()</code>
Indicates whether this View is opaque.</li>
<li><code>boolean isPaddingRelative()</code>
Return if the padding has been set through relative values setPaddingRelative(int, int, int, int) or through</li>
<li><code>boolean isPressed()</code>
Indicates whether the view is currently in pressed state.</li>
<li><code>boolean isSaveEnabled()</code>
Indicates whether this view will save its state (that is, whether its onSaveInstanceState() method will be called).</li>
<li><code>boolean isSaveFromParentEnabled()</code>
Indicates whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent.</li>
<li><code>boolean isScrollContainer()</code>
Indicates whether this view is one of the set of scrollable containers in its window.</li>
<li><code>boolean isScrollbarFadingEnabled()</code>
Returns true if scrollbars will fade when this view is not scrolling</li>
<li><code>boolean isSelected()</code>
Indicates the selection state of this view.</li>
<li><code>boolean isShown()</code>
Returns the visibility of this view and all of its ancestors</li>
<li><code>boolean isSoundEffectsEnabled()</code></li>
<li><code>final boolean isTemporarilyDetached()</code>
Tells whether the View is in the state between onStartTemporaryDetach() and onFinishTemporaryDetach().</li>
<li><code>boolean isTextAlignmentResolved()</code></li>
<li><code>boolean isTextDirectionResolved()</code></li>
<li><code>boolean isVerticalFadingEdgeEnabled()</code>
Indicate whether the vertical edges are faded when the view is scrolled horizontally.</li>
<li><code>boolean isVerticalScrollBarEnabled()</code>
Indicate whether the vertical scrollbar should be drawn or not.</li>
<li><code>void jumpDrawablesToCurrentState()</code>
Call Drawable.jumpToCurrentState() on all Drawable objects associated with this view.</li>
<li><code>View keyboardNavigationClusterSearch(View currentCluster, int direction)</code>
Find the nearest keyboard navigation cluster in the specified direction.</li>
<li><code>void layout(int l, int t, int r, int b)</code>
Assign a size and position to a view and all of its descendants<br/>
This is the second phase of the layout mechanism.</li>
<li><code>final void measure(int widthMeasureSpec, int heightMeasureSpec)</code>
This is called to find out how big a view should be.</li>
<li><code>void offsetLeftAndRight(int offset)</code>
Offset this view&#39;s horizontal location by the specified amount of pixels.</li>
<li><code>void offsetTopAndBottom(int offset)</code>
Offset this view&#39;s vertical location by the specified number of pixels.</li>
<li><code>WindowInsets onApplyWindowInsets(WindowInsets insets)</code>
Called when the view should apply WindowInsets according to its internal policy.</li>
<li><code>void onCancelPendingInputEvents()</code>
Called as the result of a call to cancelPendingInputEvents() on this view or a parent view.</li>
<li><code>boolean onCapturedPointerEvent(MotionEvent event)</code>
Implement this method to handle captured pointer events</li>
<li><code>boolean onCheckIsTextEditor()</code>
Check whether the called view is a text editor, in which case it would make sense to automatically display a soft input window for it.</li>
<li><code>InputConnection onCreateInputConnection(EditorInfo outAttrs)</code>
Create a new InputConnection for an InputMethod to interact with the view.</li>
<li><code>boolean onDragEvent(DragEvent event)</code>
Handles drag events sent by the system following a call to startDragAndDrop().</li>
<li><code>void onDrawForeground(Canvas canvas)</code>
Draw any foreground content for this view.</li>
<li><code>boolean onFilterTouchEventForSecurity(MotionEvent event)</code>
Filter the touch event to apply security policies.</li>
<li><code>void onFinishTemporaryDetach()</code>
Called after onStartTemporaryDetach() when the container is done changing the view.</li>
<li><code>boolean onGenericMotionEvent(MotionEvent event)</code>
Implement this method to handle generic motion events.</li>
<li><code>void onHoverChanged(boolean hovered)</code>
Implement this method to handle hover state changes.</li>
<li><code>boolean onHoverEvent(MotionEvent event)</code>
Implement this method to handle hover events.</li>
<li><code>void onInitializeAccessibilityEvent(AccessibilityEvent event)</code>
Initializes an AccessibilityEvent with information about this View which is the event source.</li>
<li><code>void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info)</code>
Initializes an AccessibilityNodeInfo with information about this view.</li>
<li><code>boolean onKeyDown(int keyCode, KeyEvent event)</code>
Default implementation of KeyEvent.Callback.onKeyDown(): perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.</li>
<li><code>boolean onKeyLongPress(int keyCode, KeyEvent event)</code>
Default implementation of KeyEvent.Callback.onKeyLongPress(): always returns false (doesn&#39;t handle the event).</li>
<li><code>boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)</code>
Default implementation of KeyEvent.Callback.onKeyMultiple(): always returns false (doesn&#39;t handle the event).</li>
<li><code>boolean onKeyPreIme(int keyCode, KeyEvent event)</code>
Handle a key event before it is processed by any input method associated with the view hierarchy.</li>
<li><code>boolean onKeyShortcut(int keyCode, KeyEvent event)</code>
Called on the focused view when a key shortcut event is not handled.</li>
<li><code>boolean onKeyUp(int keyCode, KeyEvent event)</code>
Default implementation of KeyEvent.Callback.onKeyUp(): perform clicking of the view when KEYCODE_DPAD_CENTER, KEYCODE_ENTER or KEYCODE_SPACE is released.</li>
<li><code>void onMovedToDisplay(int displayId)</code>
Called by the system when the hosting activity is moved from one display to another without recreation.</li>
<li><code>void onPointerCaptureChange(boolean hasCapture)</code>
Called when the window has just acquired or lost pointer capture.</li>
<li><code>void onPopulateAccessibilityEvent(AccessibilityEvent event)</code>
Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent) giving a chance to this View to populate the accessibility event with its text content.</li>
<li><code>void onProvideAutoFillStructure(ViewStructure structure, int flags)</code>
Called when assist structure is being retrieved from a view as part of an auto-fill request.</li>
<li><code>void onProvideAutoFillVirtualStructure(ViewStructure structure, int flags)</code>
Called when assist structure is being retrieved from a view as part of an auto-fill request to generate additional virtual structure under this view.</li>
<li><code>void onProvideStructure(ViewStructure structure)</code>
Called when assist structure is being retrieved from a view as part of Activity.onProvideAssistData.</li>
<li><code>void onProvideVirtualStructure(ViewStructure structure)</code>
Called when assist structure is being retrieved from a view as part of Activity.onProvideAssistData to generate additional virtual structure under this view.</li>
<li><code>PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)</code>
Returns the pointer icon for the motion event, or null if it doesn&#39;t specify the icon.</li>
<li><code>void onRtlPropertiesChanged(int layoutDirection)</code>
Called when any RTL property (layout direction or text direction or text alignment) has been changed.</li>
<li><code>void onScreenStateChanged(int screenState)</code>
This method is called whenever the state of the screen this view is attached to changes.</li>
<li><code>void onStartTemporaryDetach()</code>
This is called when a container is going to temporarily detach a child, with ViewGroup.detachViewFromParent.</li>
<li><code>boolean onTouchEvent(MotionEvent event)</code>
Implement this method to handle touch screen motion events.</li>
<li><code>boolean onTrackballEvent(MotionEvent event)</code>
Implement this method to handle trackball motion events.</li>
<li><code>void onVisibilityAggregated(boolean isVisible)</code>
Called when the user-visibility of this View is potentially affected by a change to this view itself, an ancestor view or the window this view is attached to.</li>
<li><code>void onWindowFocusChanged(boolean hasWindowFocus)</code>
Called when the window containing this view gains or loses focus.</li>
<li><code>void onWindowSystemUiVisibilityChanged(int visible)</code>
Override to find out when the window&#39;s requested system UI visibility has changed, that is the value returned by getWindowSystemUiVisibility().</li>
<li><code>boolean performAccessibilityAction(int action, Bundle arguments)</code>
Performs the specified accessibility action on the view.</li>
<li><code>boolean performClick()</code>
Call this view&#39;s OnClickListener, if it is defined.</li>
<li><code>boolean performContextClick(float x, float y)</code>
Call this view&#39;s OnContextClickListener, if it is defined.</li>
<li><code>boolean performContextClick()</code>
Call this view&#39;s OnContextClickListener, if it is defined.</li>
<li><code>boolean performHapticFeedback(int feedbackConstant)</code>
Provide haptic feedback to the user for this view.</li>
<li><code>boolean performHapticFeedback(int feedbackConstant, int flags)</code>
Like performHapticFeedback(int), with additional options.</li>
<li><code>boolean performLongClick(float x, float y)</code>
Calls this view&#39;s OnLongClickListener, if it is defined.</li>
<li><code>boolean performLongClick()</code>
Calls this view&#39;s OnLongClickListener, if it is defined.</li>
<li><code>void playSoundEffect(int soundConstant)</code>
Play a sound effect for this view.</li>
<li><code>boolean post(Runnable action)</code>
Causes the Runnable to be added to the message queue.</li>
<li><code>boolean postDelayed(Runnable action, long delayMillis)</code>
Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses.</li>
<li><code>void postInvalidate()</code>
Cause an invalidate to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidate(int left, int top, int right, int bottom)</code>
Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom)</code>
Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateDelayed(long delayMilliseconds)</code>
Cause an invalidate to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateOnAnimation(int left, int top, int right, int bottom)</code>
Cause an invalidate of the specified area to happen on the next animation time step, typically the next display frame.</li>
<li><code>void postInvalidateOnAnimation()</code>
Cause an invalidate to happen on the next animation time step, typically the next display frame.</li>
<li><code>void postOnAnimation(Runnable action)</code>
Causes the Runnable to execute on the next animation time step.<br/>
void postOnAnimationDelayed(Runnable action, long delayMillis)<br/>
Causes the Runnable to execute on the next animation time step, after the specified amount of time elapses.</li>
<li><code>void refreshDrawableState()</code>
Call this to force a view to update its drawable state.</li>
<li><code>void releasePointerCapture()</code>
Releases the pointer capture.</li>
<li><code>boolean removeCallbacks(Runnable action)</code>
Removes the specified Runnable from the message queue.</li>
<li><code>void removeOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)</code>
Remove a listener for attach state changes.</li>
<li><code>void removeOnLayoutChangeListener(View.OnLayoutChangeListener listener)</code>
Remove a listener for layout changes.</li>
<li><code>void requestApplyInsets()</code>
Ask that a new dispatch of onApplyWindowInsets(WindowInsets) be performed.</li>
<li><code>void requestFitSystemWindows()</code>
This method was deprecated in API level 20. Use requestApplyInsets() for newer platform versions.</li>
<li><code>final boolean requestFocus(int direction)</code>
Call this to try to give focus to a specific view or to one of its descendants and give it a hint about what direction focus is heading.</li>
<li><code>final boolean requestFocus()</code>
Call this to try to give focus to a specific view or to one of its descendants.</li>
<li><code>boolean requestFocus(int direction, Rect previouslyFocusedRect)</code>
Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from.</li>
<li><code>final boolean requestFocusFromTouch()</code>
Call this to try to give focus to a specific view or to one of its descendants.</li>
<li><code>void requestLayout()</code>
Call this when something has changed which has invalidated the layout of this view.</li>
<li><code>void requestPointerCapture()</code>
Requests pointer capture mode.</li>
<li><code>boolean requestRectangleOnScreen(Rect rectangle)</code>
Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough.</li>
<li><code>boolean requestRectangleOnScreen(Rect rectangle, boolean immediate)</code>
Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough.</li>
<li><code>final void requestUnbufferedDispatch(MotionEvent event)</code>
Request unbuffered dispatch of the given stream of MotionEvents to this View.</li>
<li><code>static int resolveSize(int size, int measureSpec)</code>
Version of resolveSizeAndState(int, int, int) returning only the MEASURED_SIZE_MASK bits of the result.</li>
<li><code>static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState)</code>
Utility to reconcile a desired size and state, with constraints imposed by a MeasureSpec.</li>
<li><code>boolean restoreDefaultFocus()</code>
Gives focus to the default-focus view in the view hierarchy that has this view as a root.</li>
<li><code>void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container)</code>
Restore this view hierarchy&#39;s frozen state from the given container.</li>
<li><code>void saveHierarchyState(SparseArray&lt;Parcelable&gt; container)</code>
Store this view hierarchy&#39;s frozen state into the given container.</li>
<li><code>void scheduleDrawable(Drawable who, Runnable what, long when)</code>
Schedules an action on a drawable to occur at a specified time.</li>
<li><code>void scrollBy(int x, int y)</code>
Move the scrolled position of your view.</li>
<li><code>void scrollTo(int x, int y)</code>
Set the scrolled position of your view.</li>
<li><code>void sendAccessibilityEvent(int eventType)</code>
Sends an accessibility event of the given type.</li>
<li><code>void sendAccessibilityEventUnchecked(AccessibilityEvent event)</code>
This method behaves exactly as sendAccessibilityEvent(int) but takes as an argument an empty AccessibilityEvent and does not perform a check whether accessibility is enabled.</li>
<li><code>void setAccessibilityDelegate(View.AccessibilityDelegate delegate)</code>
Sets a delegate for implementing accessibility support via composition (as opposed to inheritance).</li>
<li><code>void setAccessibilityLiveRegion(int mode)</code>
Sets the live region mode for this view.</li>
<li><code>void setAccessibilityTraversalAfter(int afterId)</code>
Sets the id of a view after which this one is visited in accessibility traversal.</li>
<li><code>void setAccessibilityTraversalBefore(int beforeId)</code>
Sets the id of a view before which this one is visited in accessibility traversal.</li>
<li><code>void setActivated(boolean activated)</code>
Changes the activated state of this view.</li>
<li><code>void setAlpha(float alpha)</code>
Sets the opacity of the view to a value from 0 to 1, where 0 means the view is completely transparent and 1 means the view is completely opaque.</li>
<li><code>void setAnimation(Animation animation)</code>
Sets the next animation to play for this view.</li>
<li><code>void setAutoFillMode(int autoFillMode)</code>
Set auto-fill mode for the view.</li>
<li><code>void setBackground(Drawable background)</code>
Set the background to a given Drawable, or remove the background.</li>
<li><code>void setBackgroundColor(int color)</code>
Sets the background color for this view.</li>
<li><code>void setBackgroundDrawable(Drawable background)</code>
This method was deprecated in API level 16. use setBackground(Drawable) instead</li>
<li><code>void setBackgroundResource(int resid)</code>
Set the background to a given resource.</li>
<li><code>void setBackgroundTintList(ColorStateList tint)</code>
Applies a tint to the background drawable.</li>
<li><code>void setBackgroundTintMode(PorterDuff.Mode tintMode)</code>
Specifies the blending mode used to apply the tint specified by setBackgroundTintList(ColorStateList)} to the background drawable.</li>
<li><code>final void setBottom(int bottom)</code>
Sets the bottom position of this view relative to its parent.</li>
<li><code>void setCameraDistance(float distance)</code>
Sets the distance along the Z axis (orthogonal to the X/Y plane on which views are drawn) from the camera to this view.</li>
<li><code>void setClickable(boolean clickable)</code>
Enables or disables click events for this view.</li>
<li><code>void setClipBounds(Rect clipBounds)</code>
Sets a rectangular area on this view to which the view will be clipped when it is drawn.</li>
<li><code>void setClipToOutline(boolean clipToOutline)</code>
Sets whether the View&#39;s Outline should be used to clip the contents of the View.</li>
<li><code>void setContentDescription(CharSequence contentDescription)</code>
Sets the View&#39;s content description.</li>
<li><code>void setContextClickable(boolean contextClickable)</code>
Enables or disables context clicking for this view.</li>
<li><code>void setDrawingCacheBackgroundColor(int color)</code>
Setting a solid background color for the drawing cache&#39;s bitmaps will improve performance and memory usage.</li>
<li><code>void setDrawingCacheEnabled(boolean enabled)</code>
Enables or disables the drawing cache.</li>
<li><code>void setDrawingCacheQuality(int quality)</code>
Set the drawing cache quality of this view.</li>
<li><code>void setDuplicateParentStateEnabled(boolean enabled)</code>
Enables or disables the duplication of the parent&#39;s state into this view.</li>
<li><code>void setElevation(float elevation)</code>
Sets the base elevation of this view, in pixels.</li>
<li><code>void setEnabled(boolean enabled)</code>
Set the enabled state of this view.</li>
<li><code>void setFadingEdgeLength(int length)</code>
Set the size of the faded edge used to indicate that more content in this view is available.</li>
<li><code>void setFilterTouchesWhenObscured(boolean enabled)</code>
Sets whether the framework should discard touches when the view&#39;s window is obscured by another visible window.</li>
<li><code>void setFitsSystemWindows(boolean fitSystemWindows)</code>
Sets whether or not this view should account for system screen decorations such as the status bar and inset its content; that is, controlling whether the default implementation of fitSystemWindows(Rect) will be executed.</li>
<li><code>void setFocusable(boolean focusable)</code>
Set whether this view can receive the focus.</li>
<li><code>void setFocusable(int focusable)</code>
Sets whether this view can receive focus.</li>
<li><code>void setFocusableInTouchMode(boolean focusableInTouchMode)</code>
Set whether this view can receive focus while in touch mode.</li>
<li><code>void setFocusedByDefault(boolean isFocusedByDefault)</code>
Sets whether this View should receive focus when the focus is restored for the view hierarchy containing this view.</li>
<li><code>void setForeground(Drawable foreground)</code>
Supply a Drawable that is to be rendered on top of all of the content in the view.</li>
<li><code>void setForegroundGravity(int gravity)</code>
Describes how the foreground is positioned.</li>
<li><code>void setForegroundTintList(ColorStateList tint)</code>
Applies a tint to the foreground drawable.</li>
<li><code>void setForegroundTintMode(PorterDuff.Mode tintMode)</code>
Specifies the blending mode used to apply the tint specified by setForegroundTintList(ColorStateList)} to the background drawable.</li>
<li><code>void setHapticFeedbackEnabled(boolean hapticFeedbackEnabled)</code>
Set whether this view should have haptic feedback for events such as long presses.</li>
<li><code>void setHasTransientState(boolean hasTransientState)</code>
Set whether this view is currently tracking transient state that the framework should attempt to preserve when possible.</li>
<li><code>void setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled)</code>
Define whether the horizontal edges should be faded when this view is scrolled horizontally.</li>
<li><code>void setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled)</code>
Define whether the horizontal scrollbar should be drawn or not.</li>
<li><code>void setHovered(boolean hovered)</code>
Sets whether the view is currently hovered.</li>
<li><code>void setId(int id)</code>
Sets the identifier for this view.</li>
<li><code>void setImportantForAccessibility(int mode)</code>
Sets how to determine whether this view is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen.</li>
<li><code>void setKeepScreenOn(boolean keepScreenOn)</code>
Controls whether the screen should remain on, modifying the value of KEEP_SCREEN_ON.</li>
<li><code>void setKeyboardNavigationCluster(boolean isCluster)</code>
Set whether this view is a root of a keyboard navigation cluster.</li>
<li><code>void setLabelFor(int id)</code>
Sets the id of a view for which this view serves as a label for accessibility purposes.</li>
<li><code>void setLayerPaint(Paint paint)</code>
Updates the Paint object used with the current layer (used only if the current layer type is not set to LAYER_TYPE_NONE).</li>
<li><code>void setLayerType(int layerType, Paint paint)</code>
Specifies the type of layer backing this view.</li>
<li><code>void setLayoutDirection(int layoutDirection)</code>
Set the layout direction for this view.</li>
<li><code>void setLayoutParams(ViewGroup.LayoutParams params)</code>
Set the layout parameters associated with this view.</li>
<li><code>final void setLeft(int left)</code>
Sets the left position of this view relative to its parent.</li>
<li><code>void setLongClickable(boolean longClickable)</code>
Enables or disables long click events for this view.</li>
<li><code>void setMinimumHeight(int minHeight)</code>
Sets the minimum height of the view.</li>
<li><code>void setMinimumWidth(int minWidth)</code>
Sets the minimum width of the view.</li>
<li><code>void setNestedScrollingEnabled(boolean enabled)</code>
Enable or disable nested scrolling for this view.</li>
<li><code>void setNextClusterForwardId(int nextClusterForwardId)</code>
Sets the id of the view to use as the root of the next keyboard navigation cluster.</li>
<li><code>void setNextFocusDownId(int nextFocusDownId)</code>
Sets the id of the view to use when the next focus is FOCUS_DOWN.</li>
<li><code>void setNextFocusForwardId(int nextFocusForwardId)</code>
Sets the id of the view to use when the next focus is FOCUS_FORWARD.</li>
<li><code>void setNextFocusLeftId(int nextFocusLeftId)</code>
Sets the id of the view to use when the next focus is FOCUS_LEFT.</li>
<li><code>void setNextFocusRightId(int nextFocusRightId)</code>
Sets the id of the view to use when the next focus is FOCUS_RIGHT.</li>
<li><code>void setNextFocusUpId(int nextFocusUpId)</code>
Sets the id of the view to use when the next focus is FOCUS_UP.</li>
<li><code>void setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener listener)</code>
Set an View.OnApplyWindowInsetsListener to take over the policy for applying window insets to this view.</li>
<li><code>void setOnCapturedPointerListener(View.OnCapturedPointerListener l)</code>
Set a listener to receive callbacks when the pointer capture state of a view changes.</li>
<li><code>void setOnClickListener(View.OnClickListener l)</code>
Register a callback to be invoked when this view is clicked.</li>
<li><code>void setOnContextClickListener(View.OnContextClickListener l)</code>
Register a callback to be invoked when this view is context clicked.</li>
<li><code>void setOnCreateContextMenuListener(View.OnCreateContextMenuListener l)</code>
Register a callback to be invoked when the context menu for this view is being built.</li>
<li><code>void setOnDragListener(View.OnDragListener l)</code>
Register a drag event listener callback object for this View.</li>
<li><code>void setOnFocusChangeListener(View.OnFocusChangeListener l)</code>
Register a callback to be invoked when focus of this view changed.</li>
<li><code>void setOnGenericMotionListener(View.OnGenericMotionListener l)</code>
Register a callback to be invoked when a generic motion event is sent to this view.</li>
<li><code>void setOnHoverListener(View.OnHoverListener l)</code>
Register a callback to be invoked when a hover event is sent to this view.</li>
<li><code>void setOnKeyListener(View.OnKeyListener l)</code>
Register a callback to be invoked when a hardware key is pressed in this view.</li>
<li><code>void setOnLongClickListener(View.OnLongClickListener l)</code>
Register a callback to be invoked when this view is clicked and held.</li>
<li><code>void setOnScrollChangeListener(View.OnScrollChangeListener l)</code>
Register a callback to be invoked when the scroll X or Y positions of this view change.</li>
<li><code>void setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener l)</code>
Set a listener to receive callbacks when the visibility of the system bar changes.</li>
<li><code>void setOnTouchListener(View.OnTouchListener l)</code>
Register a callback to be invoked when a touch event is sent to this view.</li>
<li><code>void setOutlineProvider(ViewOutlineProvider provider)</code>
Sets the ViewOutlineProvider of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping.</li>
<li><code>void setOverScrollMode(int overScrollMode)</code>
Set the over-scroll mode for this view.</li>
<li><code>void setPadding(int left, int top, int right, int bottom)</code>
Sets the padding.</li>
<li><code>void setPaddingRelative(int start, int top, int end, int bottom)</code>
Sets the relative padding.</li>
<li><code>void setPivotX(float pivotX)</code>
Sets the x location of the point around which the view is rotated and scaled.</li>
<li><code>void setPivotY(float pivotY)</code>
Sets the y location of the point around which the view is rotated and scaled.</li>
<li><code>void setPointerIcon(PointerIcon pointerIcon)</code>
Set the pointer icon for the current view.</li>
<li><code>void setPressed(boolean pressed)</code>
Sets the pressed state for this view.</li>
<li><code>final void setRevealOnFocusHint(boolean revealOnFocus)</code>
Sets this view&#39;s preference for reveal behavior when it gains focus.</li>
<li><code>final void setRight(int right)</code>
Sets the right position of this view relative to its parent.</li>
<li><code>void setRotation(float rotation)</code>
Sets the degrees that the view is rotated around the pivot point.</li>
<li><code>void setRotationX(float rotationX)</code>
Sets the degrees that the view is rotated around the horizontal axis through the pivot point.</li>
<li><code>void setRotationY(float rotationY)</code>
Sets the degrees that the view is rotated around the vertical axis through the pivot point.</li>
<li><code>void setSaveEnabled(boolean enabled)</code>
Controls whether the saving of this view&#39;s state is enabled (that is, whether its onSaveInstanceState() method will be called).</li>
<li><code>void setSaveFromParentEnabled(boolean enabled)</code>
Controls whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent.</li>
<li><code>void setScaleX(float scaleX)</code>
Sets the amount that the view is scaled in x around the pivot point, as a proportion of the view&#39;s unscaled width.</li>
<li>void setScaleY(float scaleY)<br/>
Sets the amount that the view is scaled in Y around the pivot point, as a proportion of the view&#39;s unscaled width.</li>
<li>void setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade)<br/>
Define the delay before scrollbars fade.</li>
<li>void setScrollBarFadeDuration(int scrollBarFadeDuration)<br/>
Define the scrollbar fade duration.</li>
<li>void setScrollBarSize(int scrollBarSize)<br/>
Define the scrollbar size.</li>
<li>void setScrollBarStyle(int style)<br/>
Specify the style of the scrollbars.</li>
<li>void setScrollContainer(boolean isScrollContainer)<br/>
Change whether this view is one of the set of scrollable containers in its window.</li>
<li>void setScrollIndicators(int indicators, int mask)<br/>
Sets the state of the scroll indicators specified by the mask.</li>
<li>void setScrollIndicators(int indicators)<br/>
Sets the state of all scroll indicators.</li>
<li>void setScrollX(int value)<br/>
Set the horizontal scrolled position of your view.</li>
<li>void setScrollY(int value)<br/>
Set the vertical scrolled position of your view.</li>
<li>void setScrollbarFadingEnabled(boolean fadeScrollbars)<br/>
Define whether scrollbars will fade when the view is not scrolling.</li>
<li>void setSelected(boolean selected)<br/>
Changes the selection state of this view.</li>
<li>void setSoundEffectsEnabled(boolean soundEffectsEnabled)<br/>
Set whether this view should have sound effects enabled for events such as clicking and touching.</li>
<li>void setStateListAnimator(StateListAnimator stateListAnimator)<br/>
Attaches the provided StateListAnimator to this View.</li>
<li>void setSystemUiVisibility(int visibility)<br/>
Request that the visibility of the status bar or other screen/window decorations be changed.</li>
<li>void setTag(int key, Object tag)<br/>
Sets a tag associated with this view and a key.</li>
<li>void setTag(Object tag)<br/>
Sets the tag associated with this view.</li>
<li>void setTextAlignment(int textAlignment)<br/>
Set the text alignment.</li>
<li>void setTextDirection(int textDirection)<br/>
Set the text direction.</li>
<li>void setTooltipText(CharSequence tooltipText)<br/>
Sets the tooltip text which will be displayed in a small popup next to the view.</li>
<li>final void setTop(int top)<br/>
Sets the top position of this view relative to its parent.</li>
<li>void setTouchDelegate(TouchDelegate delegate)<br/>
Sets the TouchDelegate for this View.</li>
<li>final void setTransitionName(String transitionName)<br/>
Sets the name of the View to be used to identify Views in Transitions.</li>
<li>void setTranslationX(float translationX)<br/>
Sets the horizontal location of this view relative to its left position.</li>
<li>void setTranslationY(float translationY)<br/>
Sets the vertical location of this view relative to its top position.</li>
<li>void setTranslationZ(float translationZ)<br/>
Sets the depth location of this view relative to its elevation.</li>
<li>void setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled)<br/>
Define whether the vertical edges should be faded when this view is scrolled vertically.</li>
<li><code>void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled)</code>
Define whether the vertical scrollbar should be drawn or not.</li>
<li><code>void setVerticalScrollbarPosition(int position)</code>
Set the position of the vertical scroll bar.</li>
<li><code>void setVisibility(int visibility)</code>
Set the visibility state of this view.</li>
<li><code>void setWillNotCacheDrawing(boolean willNotCacheDrawing)</code>
When a View&#39;s drawing cache is enabled, drawing is redirected to an offscreen bitmap.</li>
<li><code>void setWillNotDraw(boolean willNotDraw)</code>
If this view doesn&#39;t do any drawing on its own, set this flag to allow further optimizations.</li>
<li><code>void setX(float x)</code>
Sets the visual x position of this view, in pixels.</li>
<li><code>void setY(float y)</code>
Sets the visual y position of this view, in pixels.</li>
<li><code>void setZ(float z)</code>
Sets the visual z position of this view, in pixels.</li>
<li><code>boolean showContextMenu()</code>
Shows the context menu for this view.</li>
<li><code>boolean showContextMenu(float x, float y)</code>
Shows the context menu for this view anchored to the specified view-relative coordinate.</li>
<li><code>ActionMode startActionMode(ActionMode.Callback callback, int type)</code>
Start an action mode with the given type.</li>
<li><code>ActionMode startActionMode(ActionMode.Callback callback)</code>
Start an action mode with the default type TYPE_PRIMARY.</li>
<li><code>void startAnimation(Animation animation)</code>
Start the specified animation now.</li>
<li><code>final boolean startDrag(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)</code>
This method was deprecated in API level 24. Use startDragAndDrop() for newer platform versions.</li>
<li><code>final boolean startDragAndDrop(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)</code>
Starts a drag and drop operation.</li>
<li><code>boolean startNestedScroll(int axes)</code>
Begin a nestable scroll operation along the given axes.</li>
<li><code>void stopNestedScroll()</code>
Stop a nested scroll in progress.</li>
<li><code>String toString()</code>
Returns a string representation of the object.</li>
<li><code>void unscheduleDrawable(Drawable who, Runnable what)</code>
Cancels a scheduled action on a drawable.</li>
<li><code>void unscheduleDrawable(Drawable who)</code>
Unschedule any events associated with the given Drawable.</li>
<li><code>final void updateDragShadow(View.DragShadowBuilder shadowBuilder)</code>
Updates the drag shadow for the ongoing drag and drop operation.</li>
<li><code>boolean willNotCacheDrawing()</code>
Returns whether or not this View can cache its drawing or not.</li>
<li><code>boolean willNotDraw()</code>
Returns whether or not this View draws on its own.</li>
</ul>

<h2 id="toc_9">获取上级View的方法汇总</h2>

<pre class="line-numbers"><code class="language-java">getParent()                                                    //获取上一级View
getRootView                                                    //获取跟布局
getWindow().getDecorView()                                     
findViewById(android.R.id.content)
((ViewGroup)findViewById(android.R.id.content)).getChildAt(0)
</code></pre>

<h3 id="toc_10">方法介绍</h3>

<p><figure><img src="media/15561207869937/15713203742240.jpg" alt=""/></figure></p>

<h3 id="toc_11">getRootView特例</h3>

<p><strong>布局(R.layout.list_empty)：</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;#FFFFFF&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/name&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerVertical=&quot;true&quot;
        android:layout_marginLeft=&quot;15dp&quot;
        android:text=&quot;暂无数据&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p><strong>代码：</strong></p>

<pre class="line-numbers"><code class="language-java">    final View view = View.inflate(this, R.layout.list_empty, null);
    final TextView name = (TextView) view.findViewById(R.id.name);
    System.out.println(&quot;before View.inflate name getParent &quot; + name.getParent());
    System.out.println(&quot;before View.inflate name getRootView &quot; + name.getRootView());
    addContentView(view, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
    System.out.println(&quot;after View.inflate name getParent &quot; + name.getParent());
    System.out.println(&quot;after View.inflate name getRootView &quot; + name.getRootView());
</code></pre>

<pre class="line-numbers"><code class="language-java">结果：
before View.inflate name getParent android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
before View.inflate name getRootView android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
after View.inflate name getParent android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
after View.inflate name getRootView com.android.internal.policy.impl.MultiPhoneWindow$MultiPhoneDecorView{c535bb V.E..... R.....ID 0,0-0,0}
</code></pre>

<p><em>结论：如果View在代码中通过View.inflate实例化，在没有添加到显示界面前，getRootView获得的是Xml的根布局。添加后getRootView获得的是MultiPhoneDecorView。</em></p>

<h3 id="toc_12">使用场景</h3>

<p>用途：状态栏、标题栏、键盘的高度</p>

<p><em>注意：以下代码不能在onCreate里面使用，否则获取的高度为0，你可以放在onWindowFocusChanged等等</em></p>

<h4 id="toc_13">状态栏高度：</h4>

<p><code>getDecorView</code>的<code>getWindowVisibleDisplayFrame</code>方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。 于是，我们就可以算出状态栏的高度了。</p>

<pre class="line-numbers"><code class="language-java">Rect frame = new Rect();  
getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);  
int statusBarHeight = frame.top;
</code></pre>

<h4 id="toc_14">标题栏高度</h4>

<p><code>findViewById(Android.R.id.content)</code>是不包括标题栏的，我们可以通过它获取标题栏的高度。</p>

<pre class="line-numbers"><code class="language-java">int contentTop = findViewById(android.R.id.content).getTop();  
//statusBarHeight是上面所求的状态栏的高度  
int titleBarHeight = contentTop - statusBarHeight;
</code></pre>

<h4 id="toc_15">键盘高度</h4>

<ul>
<li>键盘没打开时获取android.R.id.content的可见区域高度height1，</li>
<li>键盘打开时再获取android.R.id.content的可见区域高度height2，</li>
<li>键盘的高度height1-height2</li>
</ul>

<pre class="line-numbers"><code class="language-java">private View globalView;
private int firstHeight;
private boolean isFirst = true;

globalView = findViewById(android.R.id.content);
globalView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
    @Override
    public void onGlobalLayout() {
        Rect rect = new Rect();
        globalView.getWindowVisibleDisplayFrame(rect);
        if (isFirst) {
            isFirst = false;
            firstHeight = rect.height();
        } else {
            int height = rect.height();
            if (height &lt; firstHeight) {
                System.out.println(&quot;键盘打开 &quot; + (firstHeight - height));
            } else {
                System.out.println(&quot;键盘关闭 &quot;);
            }
        }
    }
});
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869891.html">
                
                  <h1>Android-基类实现及学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">BaseActivity</h2>

<pre class="line-numbers"><code class="language-java">public abstract class BaseActivity extends FragmentActivity {

    /** 用来保存所有已打开的Activity */
    private static Stack&lt;Activity&gt; listActivity = new Stack&lt;Activity&gt;();

    /** 提示信息 **/
    private Toast mToast;

    /** 记录上次点击按钮的时间 **/
    private long lastClickTime;
    /** 按钮连续点击最低间隔时间 单位：毫秒 **/
    public final static int CLICK_TIME = 500;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(getContentViewId());

        // 设置activity为无标题栏
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        // 将activity推入栈中
        listActivity.push(this);
        // 初始化ui
        initUI();
        // 初始化数据
        initData();
        // 事件监听
        initListener();

    }

    protected void initToolbar(){
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        if(toolbar != null){
            setSupportActionBar(toolbar);
            getSupportActionBar.setDisplayShowTitleEnabled(false);
            handleToolbar(new ToolbarHelper(this));
        }
    }

    /** 初始化ui **/
    protected abstract void initUI();

    /** 初始化数据 **/
    protected abstract void initData();

    /** 初始化监听 **/
    protected abstract void initListener();

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        saveInstanceState(outState);
        super.onSaveInstanceState(outState);
    }
    // 设置activity为无标题栏
    protected void setBase(){
        requestWindowFeature(Window.FEATURE_NO_TITLE);
    }

    /** 保存activity状态 **/
    protected void saveInstanceState(Bundle outState) {

    }

    protected void handleToolbar(){
        
    }

    @Override
    public void onBackPressed() {
        super.onBackPressed();

    }

    public void onBack(View v) {
        finish();

    }

    @Override
    protected void onResume() {
        super.onResume();

    }

    protected abstract int getContentViewId();

    protected void showLongToast(String toastText){
        Toast.makeText(this,toastText,Toast.LENGTH_LONG).show();
    }
    
    protected void showShortToast(String toastText){
        Toast.makeText(this,toastText,Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 从栈中移除当前activity
        if (listActivity.contains(this)) {
            listActivity.remove(this);
        }

    }

    /********************** activity跳转 **********************************/
    public void openActivity(Class&lt;?&gt; targetActivityClass) {
        openActivity(targetActivityClass, null);
    }

    public void openActivity(Class&lt;?&gt; targetActivityClass, Bundle bundle) {
        Intent intent = new Intent(this, targetActivityClass);
        if (bundle != null) {
            intent.putExtras(bundle);
        }
        startActivity(intent);
    }

    public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass) {
        openActivity(targetActivityClass);
        this.finish();
    }

    public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass, Bundle bundle) {
        openActivity(targetActivityClass, bundle);
        this.finish();
    }

    /***************************************************************/

    /** 验证上次点击按钮时间间隔，防止重复点击 */
    public boolean verifyClickTime() {
        if (System.currentTimeMillis() - lastClickTime &lt;= CLICK_TIME) {
            return false;
        }
        lastClickTime = System.currentTimeMillis();
        return true;
    }

    /** 收起键盘 */
    public void closeInputMethod() {
        // 收起键盘
        View view = getWindow().peekDecorView();// 用于判断虚拟软键盘是否是显示的
        if (view != null) {
            InputMethodManager inputmanger = (InputMethodManager) getSystemService(Activity.INPUT_METHOD_SERVICE);
            inputmanger.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
        }
    }

    /**
     * 获取string
     * 
     * @param mRid
     * @return
     */
    public String getStringMethod(int mRid) {
        return this.getResources().getString(mRid);
    }

    /**
     * 获取demin
     * 
     * @param mRid
     * @return
     */
    protected int getDemonIntegerMethod(int mRid) {
        return (int) this.getResources().getDimension(mRid);
    }

    /**
     * 关闭所有(前台、后台)Activity,注意：请已BaseActivity为父类
     */
    protected static void finishAll() {
        int len = listActivity.size();
        for (int i = 0; i &lt; len; i++) {
            Activity activity = listActivity.pop();
            activity.finish();
        }
    }

    /***************** 双击退出程序 ************************************************/
    private long exitTime = 0;

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {

        if (KeyEvent.KEYCODE_BACK == keyCode) {
            // 判断是否在两秒之内连续点击返回键，是则退出，否则不退出
            if (System.currentTimeMillis() - exitTime &gt; 2000) {
                Toast.makeText(getApplicationContext(), &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show();
                // 将系统当前的时间赋值给exitTime
                exitTime = System.currentTimeMillis();
            } else {
                finishAll();
            }
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    /*
     * ************Fragement相关方法************************************************
     * 
     */
    private Fragment currentFragment;

    /** Fragment替换(当前destrory,新的create) */
    public void fragmentReplace(int target, Fragment toFragment, boolean backStack) {
        FragmentManager manager = getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        String toClassName = toFragment.getClass().getSimpleName();
        if (manager.findFragmentByTag(toClassName) == null) {
            transaction.replace(target, toFragment, toClassName);
            if (backStack) {
                transaction.addToBackStack(toClassName);
            }
            transaction.commit();
        }
    }

    /** Fragment替换(核心为隐藏当前的,显示现在的,用过的将不会destrory与create) */
    public void smartFragmentReplace(int target, Fragment toFragment) {
        FragmentManager manager = getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        // 如有当前在使用的-&gt;隐藏当前的
        if (currentFragment != null) {
            transaction.hide(currentFragment);
        }
        String toClassName = toFragment.getClass().getSimpleName();
        // toFragment之前添加使用过-&gt;显示出来
        if (manager.findFragmentByTag(toClassName) != null) {
            transaction.show(toFragment);
        } else {// toFragment还没添加使用过-&gt;添加上去
            transaction.add(target, toFragment, toClassName);
        }
        transaction.commit();
        // toFragment更新为当前的
        currentFragment = toFragment;
    }

    /***********************************************************************/
}
</code></pre>

<h2 id="toc_1">BaseFragment</h2>

<pre class="line-numbers"><code class="language-java">public abstract class BaseFragment extends Fragment {

    protected Activity mActivity;

    /**
     * 获得全局的，防止使用getActivity()为空
     * @param context
     */
    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
        this.mActivity = (Activity)context;
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container
            , Bundle savedInstanceState) {

        View view = LayoutInflater.from(mActivity)
                .inflate(getLayoutId(), container, false);
        initView(view, savedInstanceState);

        return view;
    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        initData();
    }

    /**
     * 该抽象方法就是 onCreateView中需要的layoutID
     * @return
     */
    protected abstract int getLayoutId();

    /**
     * 该抽象方法就是 初始化view
     * @param view
     * @param savedInstanceState
     */
    protected abstract void initView(View view, Bundle savedInstanceState);

    /**
     * 执行数据的加载
     */
    protected abstract void initData();
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869850.html">
                
                  <h1>Android-VelocityTracker详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">简介</h2>

<p>VelocityTracker是一个跟踪触摸事件滑动速度的帮助类，用于实现flinging以及其它类似的手势。它的原理是把触摸事件 MotionEvent 对象传递给VelocityTracker的 addMovement(MotionEvent) 方法，然后分析MotionEvent 对象在单位时间类发生的位移来计算速度。你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。</p>

<h2 id="toc_1">主要函数</h2>

<table>
<thead>
<tr>
<th style="text-align: left">Public Methods</th>
<th style="text-align: left"></th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>addMovement(MotionEvent event)</code> <br>Add a users movement to the tracker.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>clear()</code> <br>Reset the velocity tracker back to its initial state.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>compute CurrentVelocity(int units,float maxVelocity)</code><br>Compute the current velocity based on the points that have been collected.<br><br>intunitis表示速率的基本时间单位。unitis值为1的表示是，一毫秒时间单位内运动了多少个像素， unitis值为1000表示一秒（1000毫秒）时间单位内运动了多少个像素<br><br>floatVelocity表示速率的最大值</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>computeCurrentVelocity(int units)</code><br>Equivalent to invoking computeCurrentVelocity(int, float)with a maximum velocity of Float.MAX_VALUE.</td>
</tr>
<tr>
<td style="text-align: left">abstract T</td>
<td style="text-align: left"><code>getNextPoolable()</code></td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getXVelocity()</code><br>Retrieve the last computed X velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getXVelocity(int id)</code><br>Retrieve the last computed X velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>float   getYVelocity(int id)</code><br>Retrieve the last computed Y velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getYVelocity()</code><br>Retrieve the last computed Y velocity.</td>
</tr>
<tr>
<td style="text-align: left">abstract boolean</td>
<td style="text-align: left"><code>isPooled()</code></td>
</tr>
<tr>
<td style="text-align: left">static VelocityTracker</td>
<td style="text-align: left"><code>obtain()</code><br>Retrieve a new VelocityTracker object to watch the velocity of a motion.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>recycle()</code><br>Return a VelocityTracker object back to be re-used by others.</td>
</tr>
<tr>
<td style="text-align: left">abstract void</td>
<td style="text-align: left"><code>setNextPoolable(T element)</code></td>
</tr>
<tr>
<td style="text-align: left">abstract void</td>
<td style="text-align: left"><code>setPooled(boolean isPooled)</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_2">示例</h2>

<pre class="line-numbers"><code class="language-java">private VelocityTracker mVelocityTracker;//生命变量  
//在onTouchEvent(MotionEvent ev)中  
if (mVelocityTracker == null) {  
    mVelocityTracker = VelocityTracker.obtain();//获得VelocityTracker类实例  
}  
mVelocityTracker.addMovement(ev);//将事件加入到VelocityTracker类实例中  
//判断当ev事件是MotionEvent.ACTION_UP时：计算速率  
final VelocityTracker velocityTracker = mVelocityTracker;  
// 1000 provides pixels per second  
velocityTracker.computeCurrentVelocity(1, (float)0.01);//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常  
Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getXVelocity());  
velocityTracker.computeCurrentVelocity(1000); //设置units的值为1000，意思为一秒时间内运动了多少个像素  
Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getXVelocity());

</code></pre>

<p>大体的使用是这样的：<br/>
当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象<br/>
在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象<br/>
使用computeCurrentVelocity (int units)函数来计算当前的速度，使用getXVelocity ()、 getYVelocity ()函数来获得当前的速度</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869807.html">
                
                  <h1>Android-Toolbar详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Toolbar是简单使用</h2>

<p>1、在应用的build.gradle中添加v7 appcompat支持库。<br/><br/>
<code>com.android.support:appcompat-v7:24.1.1</code></p>

<p>2、让Activity继承自AppCompatActivity。  </p>

<pre class="line-numbers"><code class="language-java">public class MyActivity extends AppCompatActivity {
  // ...
}
</code></pre>

<p>3、在AndroidManifest.xml文件中，设置元素使用appcompat中的某个NoActionBar主题，从而来去除使用ActionBar来提供操作栏。</p>

<pre class="line-numbers"><code class="language-java">&lt;application android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;/&gt;
</code></pre>

<p>4、在activity的布局中添加Toolbar。</p>

<pre class="line-numbers"><code class="language-java">&lt;android.support.v7.widget.Toolbar
 android:id=&quot;@+id/my_toolbar&quot;
 android:layout_width=&quot;match_parent&quot;
 android:layout_height=&quot;?attr/actionBarSize&quot;
 android:background=&quot;?attr/colorPrimary&quot;
 android:elevation=&quot;4dp&quot;
 android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;  
 app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;
</code></pre>

<p>5、在activity的onCreate()方法中，调用setSupportActionBar()方法，并传入toolbar，这样就会将toolbar设置为activity的操作栏了。</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_my);
  Toolbar toolbar = (Toolbar) findViewById(R.id.my_toolbar);
  setSupportActionBar(toolbar);
}
</code></pre>

<h2 id="toc_1">Toolber复用</h2>

<p>应用中有很多界面，每个Activity一般都需要操作栏，且大多数activity的操作栏的元素是一致的，那每个布局文件里面都写这么多资源文件是累赘的。因此可以对Toolbar进行复用，使得布局文件看起来更精炼，更改Toolbar整体效果，如背景之类的可以更方便。</p>

<p>首先，在布局文件toolbar.xml中定义Toolbar。</p>

<pre class="line-numbers"><code class="language-java">&lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/toolbar&quot;
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;?attr/actionBarSize&quot;
    android:background=&quot;?attr/colorPrimary&quot;
    android:contentInsetLeft=&quot;0dp&quot;
    android:contentInsetStart=&quot;0dp&quot;
    android:elevation=&quot;4dp&quot;
    android:theme=&quot;@style/ToolbarTheme&quot;
    app:navigationIcon=&quot;@drawable/icon_back&quot;
    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;
    app:titleTextAppearance=&quot;@style/Toolbar.TitleText&quot;&gt;

    &lt;!--  any custom view --&gt;

&lt;/android.support.v7.widget.Toolbar&gt;
</code></pre>

<p>之后，在需要添加Toolbar的地方引入这个布局资源。</p>

<pre class="line-numbers"><code class="language-java">&lt;include
  layout=&quot;@layout/toolbar&quot;/&gt;
</code></pre>

<p>最后，在BaseActivity(一般app都会有)中的onCreate()方法设置Toolbar。注意，这个时候Activity不再继承AppCompatActivity，而是继承BaseActivity，而BaseActivity继承AppCompatActivity。BaseActivity部分代码如下：</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    if (toolbar != null) {
        setSupportActionBar(toolbar);

        mToolbarHelper = new ToolbarHelper(toolbar);

        hanldeToolbar(mToolbarHelper);
    }
}

protected void hanldeToolbar(ToolbarHelper toolbarHelper) {}

public static class ToolbarHelper {

    private Toolbar mToolbar;

    public ToolbarHelper(Toolbar toolbar) {
        this.mToolbar = toolbar;
    }

    public Toolbar getToolbar() {
        return mToolbar;
    }

    public void setTitle(String title) {
        TextView titleTV = (TextView) mToolbar.findViewById(R.id.toolbar_title);
        titleTV.setText(title);
    }
}
</code></pre>

<p>代码中首先获取到Toolbar将其设置为操作栏，之后创建了一个ToolbarHelper对象，ToobarHelper主要是封装了下Toolbar，并提供操作自定义View的方法。然后调用hanldeToolbar()方法，子Activity通过重写这个方法，可以对Toolbar进行定制操作。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869765.html">
                
                  <h1>Android-MotionEvent解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一些常量</h2>

<h3 id="toc_1">常见的动作常量：</h3>

<ul>
<li><code>public static final int ACTION_DOWN = 0;       //单点触摸动作</code></li>
<li><code>public static final int ACTION_UP  = 1;        //单点触摸离开动作</code></li>
<li><code>public static final int ACTION_MOVE = 2;       //触摸点移动动作</code></li>
<li><code>public static final int ACTION_CANCEL = 3;     //触摸动作取消</code></li>
<li><code>public static final int ACTION_OUTSIDE = 4;    //触摸动作超出边界</code></li>
<li><code>public static final int ACTION_POINTER_DOWN = 5;//多点触摸动作</code>    </li>
<li><code>public static final int ACTION_POINTER_UP = 6;  //多点离开动作</code>  
### 以下是一些非touch事件    </li>
<li><code>public static final int ACTION_HOVER_MOVE       = 7;</code></li>
<li><code>public static final int ACTION_SCROLL           = 8;</code>    </li>
<li><code>public static final int ACTION_HOVER_ENTER      = 9;</code>    </li>
<li><code>public static final int ACTION_HOVER_EXIT       = 10;</code></li>
</ul>

<h3 id="toc_2">掩码常量</h3>

<p><code>ACTION_MASK = 0X000000ff</code></p>

<h3 id="toc_3">动作掩码</h3>

<p><code>ACTION_POINTER_INDEX_MASK = 0X0000ff00</code></p>

<h3 id="toc_4">触摸点索引掩码</h3>

<p><code>ACTION_POINTER_INDEX_SHIFT = 8  //获取触摸点索引需要移动的位数</code></p>

<h3 id="toc_5">getRawX()和getRawY()</h3>

<p><code>相对于屏幕位置坐标</code></p>

<h3 id="toc_6">X,Y 相对于View的位置坐标</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/8</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869720.html">
                
                  <h1>Android-ViewConfiguration解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>ViewConfiguration这个类主要定义了UI中所使用到的标准常量，像超时、尺寸、距离，如果我们需要得到这些常量的数据，我们就可以通过这个类来获取，具体方法如下： </p>

<ul>
<li>获取ViewConfiguration对象，由于ViewConfiguration的构造方法为私有的，只能通过这个静态方法来获取到该对象。 ViewConfiguration configure = ViewConfiguration.get(context); </li>
<li>通过该对象调用相关的函数，将返回相关的常量数据。</li>
</ul>

<p>最后附上一些这个类文件源码，这里面所有的方法基本都是用来获取常量数据的，没有什么业务操作。</p>

<pre class="line-numbers"><code class="language-java">import android.app.AppGlobals;
import android.content.Context;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Point;
import android.os.RemoteException;
import android.provider.Settings;
import android.util.DisplayMetrics;
import android.util.SparseArray;

/**
 * 主要用来获取一些在UI中所使用到的标准常量，像超时、尺寸、距离
 */
public class ViewConfiguration {
    /**
     * 定义了水平滚动条的宽度和垂直滚动条的高度，单位是dip
     */
    private static final int SCROLL_BAR_SIZE = 10;

    /**
     * 滚动条褪去所需要经历的时间，单位：milliseconds
     */
    private static final int SCROLL_BAR_FADE_DURATION = 250;

    /**
     * 滚动条褪去之前的默认时间延迟，单位：milliseconds
     */
    private static final int SCROLL_BAR_DEFAULT_DELAY = 300;

    /**
     * 定义褪去边缘的长度，单位：dip
     */
    private static final int FADING_EDGE_LENGTH = 12;

    /**
     * 按下状态在子控件上的持续时间，单位：milliseconds
     */
    private static final int PRESSED_STATE_DURATION = 64;

    /**
     * 定义一个按下状态转变成长按状态所需要持续的时间，单位：milliseconds
     */
    private static final int DEFAULT_LONG_PRESS_TIMEOUT = 500;

    /**
     * 定义连续重复按键间的时间延迟，单位：milliseconds
     */
    private static final int KEY_REPEAT_DELAY = 50;

    /**
     * 如果用户需要触发全局对话框，例如：关机，锁屏等，需要按下按钮所持续的事件，单位：milliseconds
     */
    private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500;

    /**
     * 定义一个触摸事件是点击还是滚动的事件间隔，如果在这个事件内没有移动，就认为这是一个点击，否则就是滚动，单位：milliseconds
     */
    private static final int TAP_TIMEOUT = 180;

    /**
     * Defines the duration in milliseconds we will wait to see if a touch event
     * is a jump tap. If the user does not complete the jump tap within this interval, it is
     * considered to be a tap.
     */
    private static final int JUMP_TAP_TIMEOUT = 500;

    /**
     * 定义双击的时间间隔，如果在这个时间内，就认为是双击
     */
    private static final int DOUBLE_TAP_TIMEOUT = 300;

    /**
     * 定义双击最小的时间间隔
     */
    private static final int DOUBLE_TAP_MIN_TIME = 40;

    /**
     * 定义一个触摸板触摸到释放可认为是一个点击事件而不是一个触摸移动手势的最大时间，
     * 也就是说在这个时间内进行一次触摸和释放操作就可以认为是一次点击事件，单位：milliseconds
     */
    private static final int HOVER_TAP_TIMEOUT = 150;

    /**
     * 定义一个触摸板在触摸释放之前可以移动的最大距离，
     * 如果在这个距离之内就可以认为是一个点击事件，否则就是一个移动手势，单位：pixels
     */
    private static final int HOVER_TAP_SLOP = 20;

    /**
     * 定义响应显示缩放控制的时间
     */
    private static final int ZOOM_CONTROLS_TIMEOUT = 3000;

    /**
     * Inset in dips to look for touchable content when the user touches the edge of the screen
     */
    private static final int EDGE_SLOP = 12;

    /**
     * 如果我们认为用户正在滚动，这里定义一个触摸事件可以滚动的距离，单位：dips
     * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。
     */
    private static final int TOUCH_SLOP = 8;

    /**
     * 定义双击事件之间可以移动的距离，单位：dips
     */
    private static final int DOUBLE_TAP_TOUCH_SLOP = TOUCH_SLOP;

    /**
     * 定义用户尝试翻页滚动的触摸移动距离，单位：dips
     *
     * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。
     *
     */
    private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2;

    /**
     * 定义第一次点击和第二次点击可以认为是一次双击之间的距离。单位：dips
     */
    private static final int DOUBLE_TAP_SLOP = 100;

    /**
     * Distance in dips a touch needs to be outside of a window&#39;s bounds for it to
     * count as outside for purposes of dismissing the window.
     */
    private static final int WINDOW_TOUCH_SLOP = 16;

    /**
     * 一个fling最小的速度，单位：dips/s
     */
    private static final int MINIMUM_FLING_VELOCITY = 50;

    /**
     * 一个fling最大的速度，单位：dips/s
     */
    private static final int MAXIMUM_FLING_VELOCITY = 8000;

    /**
     * 分发一个重复访问事件的延迟事件，单位：milliseconds
     */
    private static final long SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS = 100;

    /**
     * The maximum size of View&#39;s drawing cache, expressed in bytes. This size
     * should be at least equal to the size of the screen in ARGB888 format.
     */
    @Deprecated
    private static final int MAXIMUM_DRAWING_CACHE_SIZE = 480 * 800 * 4; // ARGB8888

    /**
     * 滚动和滑动的摩擦系数
     */
    private static final float SCROLL_FRICTION = 0.015f;

    /**
     * Max distance in dips to overscroll for edge effects
     */
    private static final int OVERSCROLL_DISTANCE = 0;

    /**
     * Max distance in dips to overfling for edge effects
     */
    private static final int OVERFLING_DISTANCE = 6;

    private final int mEdgeSlop;
    private final int mFadingEdgeLength;
    private final int mMinimumFlingVelocity;
    private final int mMaximumFlingVelocity;
    private final int mScrollbarSize;
    private final int mTouchSlop;
    private final int mDoubleTapTouchSlop;
    private final int mPagingTouchSlop;
    private final int mDoubleTapSlop;
    private final int mWindowTouchSlop;
    private final int mMaximumDrawingCacheSize;
    private final int mOverscrollDistance;
    private final int mOverflingDistance;
    private final boolean mFadingMarqueeEnabled;

    private boolean sHasPermanentMenuKey;
    private boolean sHasPermanentMenuKeySet;

    static final SparseArray&lt;ViewConfiguration&gt; sConfigurations =
            new SparseArray&lt;ViewConfiguration&gt;(2);

    /**
     * 这个方法被废除了，使用ViewConfiguration.get(Context)}替代
     */
    @Deprecated
    public ViewConfiguration() {
        mEdgeSlop = EDGE_SLOP;
        mFadingEdgeLength = FADING_EDGE_LENGTH;
        mMinimumFlingVelocity = MINIMUM_FLING_VELOCITY;
        mMaximumFlingVelocity = MAXIMUM_FLING_VELOCITY;
        mScrollbarSize = SCROLL_BAR_SIZE;
        mTouchSlop = TOUCH_SLOP;
        mDoubleTapTouchSlop = DOUBLE_TAP_TOUCH_SLOP;
        mPagingTouchSlop = PAGING_TOUCH_SLOP;
        mDoubleTapSlop = DOUBLE_TAP_SLOP;
        mWindowTouchSlop = WINDOW_TOUCH_SLOP;
        //noinspection deprecation
        mMaximumDrawingCacheSize = MAXIMUM_DRAWING_CACHE_SIZE;
        mOverscrollDistance = OVERSCROLL_DISTANCE;
        mOverflingDistance = OVERFLING_DISTANCE;
        mFadingMarqueeEnabled = true;
    }

    /**
     * 使用给定的context来创建一个新的配置。这个配置依赖于context里面不同的参数，例如显示的尺寸或者密度
     * @param context 用来初始化这个view配置的应用上下文环境
     *
     * @see #get(android.content.Context)
     * @see android.util.DisplayMetrics
     */
    private ViewConfiguration(Context context) {
        final Resources res = context.getResources();
        final DisplayMetrics metrics = res.getDisplayMetrics();
        final Configuration config = res.getConfiguration();
        final float density = metrics.density;
        final float sizeAndDensity;
        if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE)) {
            sizeAndDensity = density * 1.5f;
        } else {
            sizeAndDensity = density;
        }

        mEdgeSlop = (int) (sizeAndDensity * EDGE_SLOP + 0.5f);
        mFadingEdgeLength = (int) (sizeAndDensity * FADING_EDGE_LENGTH + 0.5f);
        mMinimumFlingVelocity = (int) (density * MINIMUM_FLING_VELOCITY + 0.5f);
        mMaximumFlingVelocity = (int) (density * MAXIMUM_FLING_VELOCITY + 0.5f);
        mScrollbarSize = (int) (density * SCROLL_BAR_SIZE + 0.5f);
        mDoubleTapSlop = (int) (sizeAndDensity * DOUBLE_TAP_SLOP + 0.5f);
        mWindowTouchSlop = (int) (sizeAndDensity * WINDOW_TOUCH_SLOP + 0.5f);

        // Size of the screen in bytes, in ARGB_8888 format
        final WindowManager win = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
        final Display display = win.getDefaultDisplay();
        final Point size = new Point();
        display.getRealSize(size);
        mMaximumDrawingCacheSize = 4 * size.x * size.y;

        mOverscrollDistance = (int) (sizeAndDensity * OVERSCROLL_DISTANCE + 0.5f);
        mOverflingDistance = (int) (sizeAndDensity * OVERFLING_DISTANCE + 0.5f);

        if (!sHasPermanentMenuKeySet) {
            IWindowManager wm = WindowManagerGlobal.getWindowManagerService();
            try {
                sHasPermanentMenuKey = !wm.hasNavigationBar();
                sHasPermanentMenuKeySet = true;
            } catch (RemoteException ex) {
                sHasPermanentMenuKey = false;
            }
        }

        mFadingMarqueeEnabled = res.getBoolean(
                com.android.internal.R.bool.config_ui_enableFadingMarquee);
        mTouchSlop = res.getDimensionPixelSize(
                com.android.internal.R.dimen.config_viewConfigurationTouchSlop);
        mPagingTouchSlop = mTouchSlop * 2;

        mDoubleTapTouchSlop = mTouchSlop;
    }

    /**
     * 跟上面一个函数一样，只不过上面一个是创建一个ViewConfiguration对象，这里是直接通过这个静态方法返回一个对象
     */
    public static ViewConfiguration get(Context context) {
        final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
        final int density = (int) (100.0f * metrics.density);

        ViewConfiguration configuration = sConfigurations.get(density);
        if (configuration == null) {
            configuration = new ViewConfiguration(context);
            sConfigurations.put(density, configuration);
        }

        return configuration;
    }

    /**
     * @return 获取水平滚动条的宽带和垂直滚动条的高度
     *
     * 这个函数被废除，使用getScaledScrollBarSize()来代替
     */
    @Deprecated
    public static int getScrollBarSize() {
        return SCROLL_BAR_SIZE;
    }

    /**
     * @return 获取水平滚动条的宽带和垂直滚动条的高度
     */
    public int getScaledScrollBarSize() {
        return mScrollbarSize;
    }

    /**
     * @return 滚动条褪去的持续时间
     */
    public static int getScrollBarFadeDuration() {
        return SCROLL_BAR_FADE_DURATION;
    }

    /**
     * @return 滚动条褪去的延迟时间
     */
    public static int getScrollDefaultDelay() {
        return SCROLL_BAR_DEFAULT_DELAY;
    }

    /**
     * @return 褪去边缘的长度
     *
     * 这个方法已经废弃，用getScaledFadingEdgeLength()替代.
     */
    @Deprecated
    public static int getFadingEdgeLength() {
        return FADING_EDGE_LENGTH;
    }

    /**
     * @return 褪去边缘的长度，单位：pixels
     */
    public int getScaledFadingEdgeLength() {
        return mFadingEdgeLength;
    }

    /**
     * @return 在子控件上按住状态的持续时间
     */
    public static int getPressedStateDuration() {
        return PRESSED_STATE_DURATION;
    }

    /**
     * @return 按住状态转变为长按状态需要的时间
     */
    public static int getLongPressTimeout() {
        return AppGlobals.getIntCoreSetting(Settings.Secure.LONG_PRESS_TIMEOUT,
                DEFAULT_LONG_PRESS_TIMEOUT);
    }

    /**
     * @return 重新按键时间
     */
    public static int getKeyRepeatTimeout() {
        return getLongPressTimeout();
    }

    /**
     * @return 重复按键延迟时间
     */
    public static int getKeyRepeatDelay() {
        return KEY_REPEAT_DELAY;
    }

    /**
     * @return 判断用户是单击还是滚动的时间，在这个时间内没有移动则是单击，否则是滚动
     */
    public static int getTapTimeout() {
        return TAP_TIMEOUT;
    }

    /**
     * @return the duration in milliseconds we will wait to see if a touch event
     * is a jump tap. If the user does not move within this interval, it is
     * considered to be a tap.
     */
    public static int getJumpTapTimeout() {
        return JUMP_TAP_TIMEOUT;
    }

    /**
     * @return 得到双击间隔时间，在这个时间内，则是双击，否则就是单击
     */
    public static int getDoubleTapTimeout() {
        return DOUBLE_TAP_TIMEOUT;
    }

    /**
     * @return the minimum duration in milliseconds between the first tap&#39;s
     * up event and the second tap&#39;s down event for an interaction to be considered a
     * double-tap.
     *
     * @hide
     */
    public static int getDoubleTapMinTime() {
        return DOUBLE_TAP_MIN_TIME;
    }

    /**
     * @return the maximum duration in milliseconds between a touch pad
     * touch and release for a given touch to be considered a tap (click) as
     * opposed to a hover movement gesture.
     * @hide
     */
    public static int getHoverTapTimeout() {
        return HOVER_TAP_TIMEOUT;
    }

    /**
     * @return the maximum distance in pixels that a touch pad touch can move
     * before being released for it to be considered a tap (click) as opposed
     * to a hover movement gesture.
     * @hide
     */
    public static int getHoverTapSlop() {
        return HOVER_TAP_SLOP;
    }

    /**
     * @return Inset in dips to look for touchable content when the user touches the edge of the
     *         screen
     *
     * @deprecated Use {@link #getScaledEdgeSlop()} instead.
     */
    @Deprecated
    public static int getEdgeSlop() {
        return EDGE_SLOP;
    }

    /**
     * @return Inset in pixels to look for touchable content when the user touches the edge of the
     *         screen
     */
    public int getScaledEdgeSlop() {
        return mEdgeSlop;
    }

    /**
     * @return Distance in dips a touch can wander before we think the user is scrolling
     *
     * @deprecated Use {@link #getScaledTouchSlop()} instead.
     */
    @Deprecated
    public static int getTouchSlop() {
        return TOUCH_SLOP;
    }

    /**
     * @return Distance in pixels a touch can wander before we think the user is scrolling
     */
    public int getScaledTouchSlop() {
        return mTouchSlop;
    }

    /**
     * @return Distance in pixels the first touch can wander before we do not consider this a
     * potential double tap event
     * @hide
     */
    public int getScaledDoubleTapTouchSlop() {
        return mDoubleTapTouchSlop;
    }

    /**
     * @return Distance in pixels a touch can wander before we think the user is scrolling a full
     * page
     */
    public int getScaledPagingTouchSlop() {
        return mPagingTouchSlop;
    }

    /**
     * @return Distance in dips between the first touch and second touch to still be
     *         considered a double tap
     * @deprecated Use {@link #getScaledDoubleTapSlop()} instead.
     * @hide The only client of this should be GestureDetector, which needs this
     *       for clients that still use its deprecated constructor.
     */
    @Deprecated
    public static int getDoubleTapSlop() {
        return DOUBLE_TAP_SLOP;
    }

    /**
     * @return Distance in pixels between the first touch and second touch to still be
     *         considered a double tap
     */
    public int getScaledDoubleTapSlop() {
        return mDoubleTapSlop;
    }

    /**
     * Interval for dispatching a recurring accessibility event in milliseconds.
     * This interval guarantees that a recurring event will be send at most once
     * during the {@link #getSendRecurringAccessibilityEventsInterval()} time frame.
     *
     * @return The delay in milliseconds.
     *
     * @hide
     */
    public static long getSendRecurringAccessibilityEventsInterval() {
        return SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS;
    }

    /**
     * @return Distance in dips a touch must be outside the bounds of a window for it
     * to be counted as outside the window for purposes of dismissing that
     * window.
     *
     * @deprecated Use {@link #getScaledWindowTouchSlop()} instead.
     */
    @Deprecated
    public static int getWindowTouchSlop() {
        return WINDOW_TOUCH_SLOP;
    }

    /**
     * @return Distance in pixels a touch must be outside the bounds of a window for it
     * to be counted as outside the window for purposes of dismissing that window.
     */
    public int getScaledWindowTouchSlop() {
        return mWindowTouchSlop;
    }

    /**
     * @return Minimum velocity to initiate a fling, as measured in dips per second.
     *
     * @deprecated Use {@link #getScaledMinimumFlingVelocity()} instead.
     */
    @Deprecated
    public static int getMinimumFlingVelocity() {
        return MINIMUM_FLING_VELOCITY;
    }

    /**
     * @return 得到滑动的最小速度, 以像素/每秒来进行计算
     */
    public int getScaledMinimumFlingVelocity() {
        return mMinimumFlingVelocity;
    }

    /**
     * @return Maximum velocity to initiate a fling, as measured in dips per second.
     *
     * @deprecated Use {@link #getScaledMaximumFlingVelocity()} instead.
     */
    @Deprecated
    public static int getMaximumFlingVelocity() {
        return MAXIMUM_FLING_VELOCITY;
    }

    /**
     * @return 得到滑动的最大速度, 以像素/每秒来进行计算
     */
    public int getScaledMaximumFlingVelocity() {
        return mMaximumFlingVelocity;
    }

    /**
     * The maximum drawing cache size expressed in bytes.
     *
     * @return the maximum size of View&#39;s drawing cache expressed in bytes
     *
     * @deprecated Use {@link #getScaledMaximumDrawingCacheSize()} instead.
     */
    @Deprecated
    public static int getMaximumDrawingCacheSize() {
        //noinspection deprecation
        return MAXIMUM_DRAWING_CACHE_SIZE;
    }

    /**
     * The maximum drawing cache size expressed in bytes.
     *
     * @return the maximum size of View&#39;s drawing cache expressed in bytes
     */
    public int getScaledMaximumDrawingCacheSize() {
        return mMaximumDrawingCacheSize;
    }

    /**
     * @return The maximum distance a View should overscroll by when showing edge effects (in
     * pixels).
     */
    public int getScaledOverscrollDistance() {
        return mOverscrollDistance;
    }

    /**
     * @return The maximum distance a View should overfling by when showing edge effects (in
     * pixels).
     */
    public int getScaledOverflingDistance() {
        return mOverflingDistance;
    }

    /**
     * The amount of time that the zoom controls should be
     * displayed on the screen expressed in milliseconds.
     *
     * @return the time the zoom controls should be visible expressed
     * in milliseconds.
     */
    public static long getZoomControlsTimeout() {
        return ZOOM_CONTROLS_TIMEOUT;
    }

    /**
     * The amount of time a user needs to press the relevant key to bring up
     * the global actions dialog.
     *
     * @return how long a user needs to press the relevant key to bring up
     *   the global actions dialog.
     */
    public static long getGlobalActionKeyTimeout() {
        return GLOBAL_ACTIONS_KEY_TIMEOUT;
    }

    /**
     * The amount of friction applied to scrolls and flings.
     *
     * @return A scalar dimensionless value representing the coefficient of
     *         friction.
     */
    public static float getScrollFriction() {
        return SCROLL_FRICTION;
    }

    /**
     * Report if the device has a permanent menu key available to the user.
     *
     * &lt;p&gt;As of Android 3.0, devices may not have a permanent menu key available.
     * Apps should use the action bar to present menu options to users.
     * However, there are some apps where the action bar is inappropriate
     * or undesirable. This method may be used to detect if a menu key is present.
     * If not, applications should provide another on-screen affordance to access
     * functionality.
     *
     * @return true if a permanent menu key is present, false otherwise.
     */
    public boolean hasPermanentMenuKey() {
        return sHasPermanentMenuKey;
    }

    /**
     * @hide
     * @return Whether or not marquee should use fading edges.
     */
    public boolean isFadingMarqueeEnabled() {
        return mFadingMarqueeEnabled;
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/7</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869675.html">
                
                  <h1>Android-Scroller详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Scroller是一个专门用于处理滚动效果的工具类，可能在大多数情况下，我们直接使用Scroller的场景并不多，但是很多大家所熟知的控件在内部都是使用Scroller来实现的，如ViewPager、ListView等。先撇开Scroller类不谈，其实任何一个控件都是可以滚动的，因为在View类当中有scrollTo()和scrollBy()这两个方法。这两个方法都是用于对View进行滚动的，那么它们之间有什么区别呢？简单点讲，scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。<strong>注意，不管是scrollTo()还是scrollBy()方法，滚动的都是该View内部的内容</strong></p>

<p><figure><img src="media/15561207869675/15713203555526.jpg" alt=""/></figure></p>

<p>第一个参数x表示相对于当前位置横向移动的距离，正值向左移动，负值向右移动，单位是像素。第二个参数y表示相对于当前位置纵向移动的距离，正值向上移动，负值向下移动，单位是像素。</p>

<h2 id="toc_1">scrollBy()</h2>

<p><code>scrollBy()</code>方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直向右下方移动。</p>

<h2 id="toc_2">scrollTo()</h2>

<p><code>scrollTo()</code>方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。</p>

<h2 id="toc_3">Scroller</h2>

<p>目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。<br/>
Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p>

<ul>
<li>创建Scroller的实例</li>
<li>调用startScroll()方法来初始化滚动数据并刷新界面 </li>
<li>重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</li>
</ul>

<h2 id="toc_4">startScroll(int startX,int startY,int dx,int dy)</h2>

<ul>
<li>第一个参数是滚动开始时X的坐标</li>
<li>第二个参数是滚动开始时Y的坐标</li>
<li>第三个参数是横向滚动的距离,正值表示向左滚动</li>
<li>第四个参数是纵向滚动的距离，正值表示向上滚动。</li>
<li>紧接着调用invalidate()方法来刷新界面。</li>
</ul>

<h2 id="toc_5">startScroll (int startX,  int startY, int dx, int dy, int duration)</h2>

<p>同上</p>

<ul>
<li>第五个参数是滑动时间</li>
</ul>

<h2 id="toc_6">computeScroll()</h2>

<p>在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。</p>

<pre class="line-numbers"><code class="language-java">@Override
public void computeScroll() {
    // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        invalidate();
    }
}
</code></pre>

<h2 id="toc_7">getScrollX() | getScrollY()</h2>

<p>返回当前view在x或者y方向上的滚动距离</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/6</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_13.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_15.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15826122642335.html">个人信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15818619982581.html">IDEA 远程一键部署Spring Boot到Docker</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813395132789.html">Flutter VsCode插件</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15809146907844.html">Flutter 组件小记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15808782889824.html">Flutter常用第三方库</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
