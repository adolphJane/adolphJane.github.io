<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870673.html">
                
                  <h1>Android-Debug</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、 进入 debug 模式的两种姿势</h2>

<p>第一种是点击运行按钮旁边的“绿色甲虫”(debug app)开始以调试模式编译运行。</p>

<p><figure><img src="media/15561207870673/15713320071550.png" alt=""/></figure></p>

<p>这个方式的特点是，一开始就进入了调试模式。适合希望尽早进入调试模式的场景，比如你想从头开始追踪问题，或者断点在启动页或首页之类的。它的弊端是每次需要从头跑一遍，且由于调试模式下应用程序略卡顿，等你到达调试页面时会觉得老费劲。</p>

<p><figure><img src="media/15561207870673/15713320153903.png" alt=""/></figure></p>

<p>第二种方式是在手机或模拟器已经跑起来应用程序后点击 <code>Run</code> -&gt; <code>Attach debugger to Android process</code>，选择应用程序主进程，即可进入调试模式。</p>

<p>这种方式的特点是，随时随地自由进入调试模式，不需要重头开始跑应用程序，该方式适合绝大多数调试场景。需要注意的是，假如跑的是 <code>release</code> 版本且有混淆加固之类的话，该方式就无法正常调试。</p>

<h2 id="toc_1">二、 常见的调试操作</h2>

<h3 id="toc_2">1 典型的调试场景</h3>

<p>一个最常见的调试场景如下：</p>

<ol>
<li>完成包括打开 Android Studio、打开需要调试的类、连接手机等准备工作</li>
<li>在关键位置打上普通断点，进入调试模式后触发断点，将当前线程阻塞在断点处</li>
<li>单步调试，一行一行往下运行</li>
<li>碰到方法调用时进入方法内部</li>
<li>用单步调试单步执行直到该方法结束回到方法调用的下一行，或者直接退出当前方法</li>
<li>通过观察观察区的相关变量，推断出问题所在，结束本次调试</li>
</ol>

<p>以上是最常规的 debug 场景，下面介绍下调试界面。</p>

<p><figure><img src="media/15561207870673/15713320235325.png" alt=""/></figure></p>

<p>在 Android Studio 的 debug 标签（假如一开始没有，等触发断点后自然会出现）中有两个面板 debugger 和 console。debugger 又分为 Frames、Threads 和 Variables 三块，分别是堆栈内容、线程、变量区。</p>

<p>在 debugger 标签右边有一些操作按钮，是我们常用的调试操作，下面会一一介绍。（可以用鼠标悬停在上面看每个按钮的具体名称）</p>

<h3 id="toc_3">2 设置断点</h3>

<p>断点有多种类型，我们这里先只谈普通断点。在每行的最前端单击一下即可<strong>添加断点</strong>，在断点上单击一下是<strong>取消断点</strong>。普通模式下断点只是一个普通的红点，但假如是在调试模式下，则红点上会有一个“√”或“✘”表示该行是否会被运行，例如，注释行前的断点会是“✘”。</p>

<p><figure><img src="media/15561207870673/15713320307577.png" alt=""/></figure></p>

<p>不管怎样，触发断点肯定是调试的起点。只有触发了断点，才会开始阻塞线程（注意是只会阻塞当前线程，这个后面会扩展一下详细介绍），此时当前代码行会被蓝色高亮，观察面板上的变量也会显示当前环境下的值。</p>

<h3 id="toc_4">3 跳到下一个断点（F9）</h3>

<p>一般情况下，在调试时我们可以根据我们的经验在几个关键的位置打上断点，这里就需要从一个断点直接跳到下一个断点。操作是继续以 debug 模式运行，快捷键是 F9（假如没改动的话应该都是这个快捷键，假如不同，可以把鼠标悬浮在该图标上看提示，下同）。</p>

<h3 id="toc_5">4 单步调试（F8）</h3>

<p>触发断点后，我们当然可以通过加 N 个断点来定位问题，但在较复杂的场景里可能没法判断出关键点。这时可以在比较靠前的位置添加断点作为起点，一行一行执行。操作是单步调试，快捷键是 F8。</p>

<h3 id="toc_6">5 进入方法内部（F7）</h3>

<p>在单步调试时方法调用语句会被看做一行，那么如何进入方法内部呢？用“进入内部”操作，快捷键是 F7.</p>

<h3 id="toc_7">6 退出当前方法（上档键+F8）</h3>

<p>既然有进入方法内部，就有退出当前方法的操作。当进入某个方法内部后觉得该方法后面的代码不需要看了，不需要猛按 F8 让它们跑完，可以直接退出当前方法去到该方法调用处的下一行。</p>

<p>有了这些操作，基本可以应付常见的 80% 的调试场景了。但仅仅了解这些，在面对复杂场景时难免效率低下。下面介绍几种非常高效的断点。</p>

<h2 id="toc_8">三、 几种高效断点</h2>

<h3 id="toc_9">1 条件成立时才触发的条件断点</h3>

<p>普通断点在每次运行到时都会被触发，这在多次调用、有“循环”的场景会比较麻烦，比如循环 100 次只希望停留在第 98 次。那么此刻就可以用上条件断点了。</p>

<p>添加条件断点：先在需要的行前左键单击添加普通断点，右键点击该断点出现对话框，在“Condition”处填入条件即可，条件语法同 Java，如 i == 98。点击 Done，完成添加。这样当条件未满足时，不会阻塞程序运行；当条件满足时断点被触发。</p>

<p><figure><img src="media/15561207870673/15713320404295.png" alt=""/></figure></p>

<h3 id="toc_10">2 不会阻塞应用程序的日志断点</h3>

<p>有时候我们仅仅希望在关键时刻输出一些 log，那么我们需要做这些工作：</p>

<ol>
<li>在代码里加上 log 代码</li>
<li>重新运行程序</li>
<li>重新触发断点</li>
</ol>

<p>那么有没有什么方法可以避免这些繁杂的操作呢？这时可以试试日志断点。</p>

<p>在条件断点弹出的对话框里，将“suspend”设置为未选中状态，断点触发时就不会被阻塞。此时对话框会多出一些选项。</p>

<p><figure><img src="media/15561207870673/15713320484306.png" alt=""/></figure></p>

<p>我们选中“Evaluated and log”，并在里面填写希望输出的日志，点击 Done 即可。注意，日志将输出到 Console 而非 LogCat。</p>

<h3 id="toc_11">3 被异常触发的异常断点</h3>

<p>我们做 debug，一般面对的都是未崩溃的异常，例如 UI 状态不对、数值不对、代码执行逻辑不对等等。碰到直接 crash 的情况，我们往往不会去 debug，而是根据报错信息定位到某某行，然后解决问题。最典型的就是空指针异常了，只要看到报错位置，基本手到擒来。</p>

<p>但日常开发难免碰到一些给出具体信息和抛异常的位置也没有头绪或者未给出具体位置的情况，比如某 API 抛了个状态异常，那么我们可能得去琢磨为何会状态不对。</p>

<p>这时还是得调试，但我们也不能眼睁睁看着抛出的异常让应用程序崩了，可以用上“异常断点”。</p>

<p>我们打开断点管理器，可以看到有一类是“Java Exception Breakpoints”，直接勾上是所有异常都会被触发。</p>

<p>假如只想被某种异常触发，我们可以点击“+”，选中“Java Exception Breakpoints”，然后输出该种异常即可。</p>

<p><figure><img src="media/15561207870673/15713320567239.png" alt=""/></figure></p>

<p>有朋友可能注意到除了 “Java Exception Breakpoints” 外还有一个 “Exception Breakpoints”，两者区别主要是前者只支持 Java 本身的异常，后者可以支持自定义异常。</p>

<h3 id="toc_12">4 追踪关键点的字段断点和方法断点</h3>

<p>在诸如多线程等复杂场景下，超多的变量和超多的类再加上一些 native 方法和第三方库，调试的复杂度也直线上升。</p>

<p><strong>这时可以尝试以点破面，抓住关键方法或字段来追踪应用程序的运行轨迹。</strong>于是关注某字段的字段断点和关注某方法的方法断点就派上用场了。</p>

<p>顾名思义，字段断点的触发条件是字段值被更改，方法断点是方法被调用。</p>

<p>添加方式：在字段那行、在方法声明的那行单击即可。</p>

<p><figure><img src="media/15561207870673/15713320679940.png" alt=""/></figure></p>

<h3 id="toc_13">5 注意事项</h3>

<p>除了以上这些，还有其他断点未列出来，比如临时断点等。考虑到这类断点实用性不强，就不多加说明，有需求的朋友自然会去了解。</p>

<p><strong>需要说明的是，给断点命名只是为了方便交流，各类型之间并没有特别边界。</strong> 实际上，断点只是某些操作的集合而已。比如日志断点是“不阻塞”和“输出日志”两个操作的集合，那么我们当然可以加上“设置条件”操作变成“条件日志断点”，诸如此类。我们设置断点的面板是允许我们将多种断点条件混合使用的。</p>

<p>所以，<strong>断点名称和类型不重要，重要的是针对现场选用合适的操作。</strong></p>

<h2 id="toc_14">四 调试中的变量</h2>

<p>在设置了合适的断点后，我们就可以进行下一步操作 —— 观察变量，准确的说是观察变量的值。</p>

<h3 id="toc_15">1 变量观测面板</h3>

<p>众所周知，应用程序在运行期间元素都处于一种动态状态，此刻你是无法观测到具体变量的值的。只有当动态变成静态，即阻塞住应用程序，才能开始变量观测。</p>

<p>这个“阻塞”操作也就是上文提到的断点触发。</p>

<p>这里需要特别指出的是，当需要追踪某一个特定变量时，字段断点是一大利器。</p>

<p><figure><img src="media/15561207870673/15713320794441.png" alt=""/></figure></p>

<p>如上图所示，变量观察面板会列出所有当前能访问到的成员变量和局部变量。</p>

<p>点击变量前的箭头，可以将该实例展开，列出所有字段。</p>

<h3 id="toc_16">2 Add New Watch</h3>

<p>将所有变量、所有字段列出来是比较直观，但当我们要去获取某些属性时就略蛋疼了。</p>

<p>比如，获取某成员变量 View 的第一个 <code>child</code> 的 <code>measuredHeight</code>。假如是靠手动去一个个“打开”属性列表，拿得多麻烦。</p>

<p>又比如，我们需要获取到两个属性相加后占另一个值的百分比。先去找到这两个属性的值然后额外拿计算器计算？</p>

<p>这时就可以用上 “Add New Watch”了，添加一个观察表达式。通俗点就是在变量观测区执行一个表达式并得到它的值。</p>

<p>在面试左侧点击绿色“+”，或者点击右键在菜单中选择“New Watch”, 就会出现一个框，输入表达式即可。</p>

<p>举个例子：</p>

<p>在示例中输入<code>toolbar.getChildAt(0).getMeasuredHeight()</code>，可得到如图的结果。</p>

<p><figure><img src="media/15561207870673/15713320865126.png" alt=""/></figure></p>

<h3 id="toc_17">3 设置变量的值</h3>

<p><strong>变量的值除了能被观察外，还可以在运行时改变。</strong> 这个可以说是超酷的黑科技了。试想，碰到一个 <code>if else</code> 时，我们可以很轻松无成本地通过更改变量的值，让应用程序能跑到我们期望的分支上。</p>

<p>设置变量的值有两种方式：方式一是在变量观测区右键单击变量，在菜单中选中“set value”；方式二是鼠标悬浮在代码区中的某个可访问的变量上，在弹出的浮层里更改值。</p>

<p><figure><img src="media/15561207870673/15713320950169.png" alt=""/></figure></p>

<h2 id="toc_18">五 犀利的小功能</h2>

<p>除了以上那些常规的操作，还有一些“还有这种操作”的小功能。</p>

<h3 id="toc_19">1 Force Run to Cursor</h3>

<p>该操作可以忽视已存在的断点，直接跳到光标所在的行。有种脱离断点、繁琐操作的束缚轻松自由的感觉有木有。</p>

<h3 id="toc_20">2 Drop frame</h3>

<p>经过不懈努力，终于快到出错的那个时刻啦，你眉飞色舞手指按得飞快，结果小手一抖，多按了几个 F8 （单步调试快捷键），错过了出错的那个时刻。<strong>如果能回退到方法执行前？</strong></p>

<p>Drop frame 功能能让你回到当前方法被调用的地方，并且当前上下文所有变量也都恢复到方法调用前 —— 时光回溯有木有？</p>

<p><strong>当然别太兴奋，由于 DalvikVM 和 Android Runtime (ART) 不支持，大部分情况下你是用不到的，那个按钮长期处于不可点击状态。</strong>但如果你是在跑 JUnit 测试的话，是可以用上的。</p>

<h3 id="toc_21">3 Log</h3>

<p>在多线程环境下，光靠 debug 是不行的。有时 debug 本身会带来一些问题混淆了现场，比如因为 debug 时的卡顿造成环境不一致等等，这时应该学会使用打日志的形式帮忙调试。</p>

<h3 id="toc_22">4 布局查看器</h3>

<p>在 Android Studio 的 Android Device Monitor 里有一个 “Dump View Hierarchy for UI Automator” 功能，可以看到当前手机上应用的具体布局情况 —— 甚至布局元素的属性都会一一给出（仅可用于可调试的应用）。对 UI 调试非常有帮助。</p>

<p><figure><img src="media/15561207870673/15713321037475.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870639.html">
                
                  <h1>Android-组件化学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>网上关于组件化的文章有很多了，大部分都知道实现的思路，不过还是要自己去实践一下才会发现问题。文章的<a href="https://github.com/zj-wukewei/ModularizationExample">项目地址</a>，项目用到CleanArchitecture框架，本文会介绍CleanArchitecture框架和dagger2在组件化的使用。</p>

<h2 id="toc_0">项目关系图</h2>

<p><figure><img src="media/15561207870639/15713321165510.png" alt=""/></figure></p>

<ul>
<li>sdk: 一些公用库，各种辅助类，和第三方view</li>
<li>basic: (依赖sdk) 网络访问初始化，本地缓存和第三方包等。</li>
<li>commonbusiness: (依赖basic) 这里为什么我会多出这一层，因为有很多公共的业务，好比公司的app是强登录的，我会把登录模块写在这里，里面也包含了一些baseActivity和BaseApplication和各个组件的一些公共方法还有组件各种的服务接口的定义。</li>
<li>module_archives和module_knowledge： 就是两个组件，可以单独运行。</li>
</ul>

<h2 id="toc_1">application和library切换</h2>

<p>想必大家都知道了，定义一个isBuildModule=false，在组件的build.gradle中加入</p>

<pre class="line-numbers"><code class="language-java">if (isBuildModule.toBoolean()) {
    apply plugin: &#39;com.android.application&#39;
} else {
    apply plugin: &#39;com.android.library&#39;
    apply from: &#39;maven-release-kline-aar.gradle&#39;
}

 sourceSets {
        main {
            if (isBuildModule.toBoolean()) {
                manifest.srcFile &#39;src/main/debug/AndroidManifest.xml&#39;
            } else {
                manifest.srcFile &#39;src/main/release/AndroidManifest.xml&#39;
                java {
                    exclude &#39;**/debug/**&#39;
                }
            }
        }
    }
</code></pre>

<p>maven-release-kline-aar.gradle是一个打包aar的文件，在切换的时候也会使用不同的AndroidManifest.xml，因为在组件是debug的时候它是单独单独运行的，还有就是代码可以在建立一个debug包，可以在单独运行的时候做些初始化app的，打包的时候回剔除这部分代码。</p>

<h2 id="toc_2">library依赖和资源问题</h2>

<p>我把所以的library都依赖在basic，每个组件都会依赖这个包，这样就不会存在library的版本问题，资源的问题就是</p>

<pre class="line-numbers"><code class="language-text"> defaultConfig {

        if (isBuildModule.toBoolean()) {
            applicationId &quot;com.wkw.archives&quot;
        }

        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode rootProject.ext.versionCode
        versionName rootProject.ext.versionName

        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;

        resourcePrefix &quot;archives&quot;
    }
</code></pre>

<h2 id="toc_3">组件之间的通信</h2>

<p>你可以选择阿里的<a href="https://github.com/alibaba/ARouter">ARouter</a>库，但是我的项目没有那么复杂，组件也就4个左右，所以没有使用阿里的库，我采用的是以下就是核心代码，</p>

<pre class="line-numbers"><code class="language-java">Object result = null;
Class&lt;?&gt; c = Class.forName(className);
if (c != null) {
    result = c.newInstance();
}
return result;
</code></pre>

<p>但是采用Class.forName会有个问题那就是在混淆的时候，className是指定的，所以要在类上加@Keep 。</p>

<h2 id="toc_4">CleanArchitecture框架和dagger在组件化的使用</h2>

<p><a href="https://github.com/android10/Android-CleanArchitecture">CleanArchitecture框架的github地址</a>，这里再介绍分享一篇文章小鄧子的<a href="http://www.jianshu.com/p/3edcf85539a6">Easy Clean architecture on Android</a>,我把data和domain会写在各自的业务模块中，自己的模块只要定义自己的就可以了，有个ApplicationModule会定义一些每个模块都需要的，</p>

<pre class="line-numbers"><code class="language-java">public class ApplicationModule {

    @Provides
    @Singleton
    Context provideContext(Application application) {
        return application;
    }

    @Provides
    @Singleton
    UserSystem provideUserSystem() {
        return new UserSystem();
    }

    @Provides
    @Singleton
    ThreadExecutor provideThreadExecutor(JobExecutor jobExecutor) {
        return jobExecutor;
    }

    @Provides
    @Singleton
    PostExecutionThread providePostExecutionThread(UIThread uiThread) {
        return uiThread;
    }

    @Provides
    @Singleton
    MrService provideMrService() {
        return new MrService();
    }

    @Provides
    @Singleton
    UserCache provideUserCache(UserCacheImpl userCache) {
        return userCache;
    }
}
</code></pre>

<p>然后在module_archives模块中会有ArchivesDataRepositoryModule和ArchivesActivityModule<br/>
其中KnowledgeDataRepositoryModule用于提供如下：</p>

<pre class="line-numbers"><code class="language-java">@Module
public class ArchivesDataRepositoryModule {

    @Provides
    @Singleton
    ArchivesApi providesArchivesApi(MrService mrService) {
        return mrService.createApi(ArchivesApi.class);
    }

    @Provides
    @Singleton
    ArchivesRepository prvidesArchivesRepository(ArchivesDataRepository archivesDataRepository) {
        return archivesDataRepository;
    }
}
</code></pre>

<p>ArchivesActivityModule的代码如下：</p>

<pre class="line-numbers"><code class="language-java">@Module
public abstract class ArchivesActivityModule {
   @PerActivity
   @ContributesAndroidInjector()
   abstract ArchivesActivity contributeArchivesActivity();
}
</code></pre>

<p>这样在主app的AppComponent类中加入：</p>

<pre class="line-numbers"><code class="language-java">@Singleton
@Component(modules = {
       AndroidInjectionModule.class, ApplicationModule.class,
       ArchivesDataRepositoryModule.class, ArchivesActivityModule.class,
       KnowledgeDataRepositoryModule.class, KnowledgeActivityModule.class
})
public interface AppComponent {
   @Component.Builder
   interface Builder {
       @BindsInstance
       Builder application(Application application);
       AppComponent build();
   }
   void inject(MrApplication mrApplication);
}
</code></pre>

<p>在module_archives为debug模式下也会有个AppComponent</p>

<pre class="line-numbers"><code class="language-java">@Singleton
@Component(modules = {
        AndroidInjectionModule.class, ApplicationModule.class,
        ArchivesDataRepositoryModule.class, ArchivesActivityModule.class
})
public interface AppComponent {
    @Component.Builder
    interface Builder {
        @BindsInstance
        Builder application(Application application);
        AppComponent build();
    }
    void inject(ArchivesApplication mrApplication);
}
</code></pre>

<p>各种模块初始化api和Repository，你要是嫌弃每个模块都要引入两个.class文件，你可以使用一个然后采用include的方式好比dagger中的AndroidSupportInjectionModule类方式</p>

<pre class="line-numbers"><code class="language-java">@Beta
@Module(includes = AndroidInjectionModule.class)
public abstract class AndroidSupportInjectionModule {
  @Multibinds
  abstract Map&lt;Class&lt;? extends Fragment&gt;, AndroidInjector.Factory&lt;? extends Fragment&gt;&gt;
      supportFragmentInjectorFactories();

  private AndroidSupportInjectionModule() {}
}
</code></pre>

<p>这样就会很清楚的知道自己模块需要初始化什么和使用什么，也不用考虑其它模块的初始化的数据，之后只需要在主app加入就行，也是比较方便的。</p>

<h2 id="toc_5">打包</h2>

<p>各种模块当为library是要打包成aar的，maven-release-kline-aar.gradle文件代码如下:</p>

<pre class="line-numbers"><code class="language-java">apply plugin: &#39;maven&#39;

ext {// ext is a gradle closure allowing the declaration of global properties
    PUBLISH_GROUP_ID = &#39;com.wkw&#39;
    PUBLISH_ARTIFACT_ID = &#39;archives&#39;
    PUBLISH_VERSION = rootProject.ext.versionName
}

uploadArchives {
    repositories.mavenDeployer {
        //这里就是最后输出地址，在自己电脑上新建个文件夹，把文件夹路径粘贴在此
        //注意”file://“ + 路径，有三个斜杠，别漏了
        repository(url: &quot;file:///Users/wukewei/Documents/android/ModularizationExample/repo&quot;)

        pom.project {
            groupId project.PUBLISH_GROUP_ID
            artifactId project.PUBLISH_ARTIFACT_ID
            version project.PUBLISH_VERSION
        }
    }
}

//以下代码会生成jar包源文件，如果是不开源码，请不要输入这段
//aar包内包含注释
task androidSourcesJar(type: Jar) {
    classifier = &#39;sources&#39;
    from android.sourceSets.main.java.sourceFiles
}

artifacts {
    archives androidSourcesJar
}
</code></pre>

<p>我只是打包到本地，你可以自己建立一个本地maven库。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870604.html">
                
                  <h1>Android-自定义皮肤</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">自定义Style和Theme</h2>

<p>  Style和Theme主要用来实现白天模式和夜间模式。<br/><br/>
  一个Style是一系列属性的集合，用来指定View或者Window的外观和格式。它可以指定的属性包括高度, Padding, 文字颜色，文字尺寸，背景颜色等等。<br/><br/>
  Style是在Xml资源文件中定义的，比如：</p>

<pre class="line-numbers"><code class="language-markup">&lt;style name=&quot;ListItemTitleStyle&quot; parent=&quot;TextAppearance.AppCompat.Body1&quot;&gt;
    &lt;item name=&quot;android:singleLine&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:ellipsize&quot;&gt;end&lt;/item&gt;
    &lt;item name=&quot;android:textColor&quot;&gt;?android:attr/textColorPrimary&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>  在布局文件中是这样使用的：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:id=&quot;@+id/text_item_title&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    style=&quot;@style/ListItemTitleStyle&quot; /&gt;
</code></pre>

<p>  这样一个Style就可以运用在多个地方，既可以统一样式，又可以减少代码量。<br/><br/>
  而Theme，其实就是一个Style，不同于我们上面提到对单一View的应用，Theme是应用于整个Activity或Application的。各位Android开发同学一定不陌生，在Manifest的Activity声明中就会经常看到。  </p>

<pre class="line-numbers"><code class="language-java">&lt;activity android:theme=&quot;@style/AppLightTheme.NoActionBar&quot;/&gt;
</code></pre>

<p>  这样，AppLightTheme.NoActionBar中的所有属性都会应用在整个Activity中。</p>

<p>  轻听这里，实现夜间模式分三步：</p>

<ul>
<li>自定义Style</li>
<li>应用Style中的属性</li>
<li>设置Theme</li>
</ul>

<h2 id="toc_1">自定义Style</h2>

<p>  我们这里，就是写两个Style ，然后各自有一套对应的颜色值。<br/>
  简单介绍一下几个主要的颜色值：</p>

<ul>
<li>colorPrimary: 主题色</li>
<li>colorAccent: 辅助色（或强调色）</li>
<li>textColorPrimary: 主要的文字颜色，一般TextView的文字都是这个颜色</li>
<li>textColorSecondary: 辅助的文字颜色，一般比textColorPrimary的颜色弱一点，用于一些弱化的表示</li>
<li>windowBackground: Window的背景色<br/>
  <br/>
  我们在资源文件中写对应的两套Style:</li>
</ul>

<pre class="line-numbers"><code class="language-markup">&lt;style name=&quot;AppLightTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/colorPrimaryTextBlack&lt;/item&gt;
    &lt;item name=&quot;android:textColorSecondary&quot;&gt;@color/colorSubTextBlack&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;AppDarkTheme&quot; parent=&quot;Theme.AppCompat.DayNight.DarkActionBar&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/darkColorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/darkColorAccent&lt;/item&gt;
    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/white&lt;/item&gt;
    &lt;item name=&quot;android:textColorSecondary&quot;&gt;@color/colorSubTextWhite&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/dark_bg&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>  细心的同学会发现，Style里的属性，有的前面会以“android:”开头，如<code>android:textColorPrimary</code>，有的则没有，如<code>colorPrimary</code>。<br/>
  以“android:”开头的属性，是系统的属性。而另一种属于自定义的属性，在资源文件中声明如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;attr name=&quot;minibar_background&quot; format=&quot;color&quot; /&gt;
</code></pre>

<p>  format包括boolean, color, dimension, enum, flag, float, fraction, integer, reference, string。 在此就不赘述了，这是它们的一个相当灵活的使用方式。</p>

<h2 id="toc_2">应用Style中的属性</h2>

<p>  比如，colorAccent是在design包中定义的，属于自定义属性，在使用的时候，直接“?attr/”+属性名就可以了。</p>

<pre class="line-numbers"><code class="language-markup">&lt;ImageView
    android:tint=&quot;?attr/colorAccent&quot; /&gt;
</code></pre>

<p>  系统属性要多加一个”android:”, 是”?android:attr/“+属性名。</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:textColor=&quot;?android:attr/textColorPrimary&quot;/&gt;
</code></pre>

<p>  这样，当指定了Theme之后，就会去相应的Style下面取对应的颜色值，从而呈现出不同的色彩。</p>

<h2 id="toc_3">设置Theme</h2>

<p>  在Manifest中设置是常见的方式。</p>

<p><code>&lt;activity android:theme=&quot;@style/AppLightTheme.NoActionBar&quot;/&gt;</code></p>

<p>  不过为了实现模式的切换，我们是在Activity的onCreate中进行的设置</p>

<pre class="line-numbers"><code class="language-java">protected void initTheme() {
    if (MusicPreferences.getInstance().isNightMode()) {
        setTheme(R.style.AppDarkTheme_NoActionBar);
    } else {
        setTheme(R.style.AppLightTheme_NoActionBar);
    }
}
</code></pre>

<p>  这样，通过给Activity设置不同的Theme，页面就能呈现出不同的颜色搭配。</p>

<h2 id="toc_4">问题</h2>

<p>  Style和Theme的方式实现简单，非常适用于模式较为固定的场景，如白天模式和夜间模式。<br/><br/>
  但是，轻听在白天的模式的时候的基础之上还有几种不同的主题色。</p>

<p>  简单聊一下主题色。<br/><br/>
  主题色，即colorPrimary，是根据品牌形象，为App定义的一个主色调，一般应用于AppBar。<br/><br/>
  同时，有一个强调色，即colorAccent，是用在Checkbox或下划线等需要给人以提示作用的地方，起辅助的作用。<br/><br/>
  还有一个颜色是colorPrimaryDark，就是比colorPrimary稍微深一些，主要用在状态栏。  </p>

<p><figure><img src="media/15561207870604/15713321794597.png" alt=""/></figure></p>

<p>  比如上图中，“蓝色”就是主题色，“红”色就是强调色。<br/><br/>
  主题色和强调色的色值可以不一样，也可以一样。在一般的设计中都是不同的。在轻听的设计中，为了突出品牌色，将强调色跟主题色统一设计成了一个颜色，所以你会看到，到处都是“绿”色。  </p>

<p><figure><img src="media/15561207870604/15713321901070.png" alt=""/></figure></p>

<p>  在强调色跟主题色统一的情况下，6个主题色，6套Style，似乎还可以接受。<br/><br/>
  但是，万一以后设计同学良心发现了呢？6在6套主题色的基础之上再出6套强调色，那可就是36个Style。如果以后的调色方式再更为灵活，如：</p>

<p><figure><img src="media/15561207870604/15713321976614.png" alt=""/></figure></p>

<p>  我数学不好，谁帮我算算，别忘了加上强调色还得再平方一下……<br/><br/>
  如果给每一个主题色都写一套Style，工作量会很大，而且不灵活。这个时候Style就玩不转了。<br/><br/>
  我们需要一种更为灵活的方案。  </p>

<h2 id="toc_5">动态配置主题色</h2>

<p>  动态配置主题色是借鉴了github开源控件app-theme-engine。在gradle中引入方式是:</p>

<pre class="line-numbers"><code class="language-text">compile(&#39;com.github.naman14:app-theme-engine:0.5.1@aar&#39;) {
    transitive = true
}
</code></pre>

<p>  由于找不到这个项目维护的地址，所以我们自己进行了扩展和优化。<br/><br/>
  主要由三个模块组成  </p>

<ul>
<li>颜色配置</li>
<li>颜色处理器</li>
<li>遍历逻辑控制器</li>
</ul>

<h2 id="toc_6">颜色配置</h2>

<p>  颜色配置主要负责存储颜色值。<br/><br/>
  因为这里存储数据较小，而且简单，所以用SharedPreference来存储，稍加封装就可以。</p>

<h2 id="toc_7">颜色处理器</h2>

<p>  颜色处理器Processor主要负责对每一个View的各种颜色进行设置。<br/><br/>
  首先，定义一个接口</p>

<pre class="line-numbers"><code class="language-java">public interface Processor&lt;T extends View, E&gt; {
    void process(@NonNull Context context, @Nullable String key, @Nullable T target, @Nullable E extra);
}
</code></pre>

<p>  process方法就是来处理视图颜色的。<br/><br/>
  其中target就是要传入的视图，这里使用泛型，在各个派生的Processor中具体实现。<br/><br/>
  以下是几个主要的Processor。</p>

<p><figure><img src="media/15561207870604/15713322118808.png" alt=""/></figure></p>

<p>  其中DefaultProcessor是默认Processor，可以处理绝大部分的变色情况。其他几种，如他们的名字一样，会额外再处理他们特定的情况。</p>

<p>Processor的处理方式分三步：</p>

<ul>
<li>给View设置tag</li>
<li>解析View的tag</li>
<li>根据具体的tag进行颜色的设置<br/>
  <br/>
  以DefaultProcessor为例。有一个TextView，我们要使他的文字颜色为强调色。<br/>
  首先，给View设置一个tag，”text_accent_color”。如果有多个tag，以逗号分隔。</li>
</ul>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:tag=&quot;text_accent_color&quot;
    /&gt;
</code></pre>

<p>  然后在process方法中将tag解析出来</p>

<pre class="line-numbers"><code class="language-java">public void process(@NonNull Context context, @Nullable String key, @Nullable View view, @Nullable Void extra) {
    if(view != null &amp;&amp; view.getTag() != null &amp;&amp; view.getTag() instanceof String) {
        String tag = (String)view.getTag();
        if(tag.contains(&quot;,&quot;)) {
            String[] splitTags = tag.split(&quot;,&quot;);
            int len = splitTags.length;

            for(int i = 0; i &lt; len; ++i) {
                String part = splitTags[i];
                processTagPart(context, view, part, key);
            }
        } else {
            processTagPart(context, view, tag, key);
        }

    }
}
</code></pre>

<p>  这里会根据分隔符（逗号）来对tag的数量进行解析，然后依次根据每个tag依次处理。<br/><br/>
  在处理方法processTagPart中，会找到”text_accent_color”相对应的处理逻辑</p>

<pre class="line-numbers"><code class="language-java">if (view instanceof  TextView) {
    ((TextView) view).setTextColor(Config.accentColor(context, key));
}
</code></pre>

<p>  Config.accentColor(context, key)的作用就是从颜色配置模块中读取当前的强调色。<br/><br/>
  其他一些稍微复杂一点的情况，则可以使用相对应的Processor去进行特殊的处理。<br/><br/>
  例如，ViewPagerProcessor。ViewPager在滑动边界的时候会有一个边界反馈的效果，如下图：  </p>

<p><figure><img src="media/15561207870604/15713322239841.png" alt=""/></figure></p>

<p>  这里需要特殊处理一下。ViewPager中，负责两个边缘效果的是EdgeEffectCompat。</p>

<pre class="line-numbers"><code class="language-java">private EdgeEffectCompat mLeftEdge;
private EdgeEffectCompat mRightEdge;
  EdgeEffectCompat是一个对系统版本做兼容性处理的类，里面有真正的边缘效果模块EdgeEffect

public final class EdgeEffectCompat {
    private Object mEdgeEffect;
}
</code></pre>

<p>  注意到，这两处都是私有的，所以我们必须通过两次反射来获取EdgeEffect，然后更改颜色。<br/><br/>
  首先，通过反射获取ViewPager的左右EdgeEffectCompat。</p>

<pre class="line-numbers"><code class="language-java">public static void setEdgeGlowColor(@NonNull ViewPager viewPager, @ColorInt int color) {
    if(Build.VERSION.SDK_INT &gt;= 21) {
        try {
            Field edgeLeft = ViewPager.class.getDeclaredField(&quot;mLeftEdge&quot;);
            edgeLeft.setAccessible(true);
            Field edgeRight = ViewPager.class.getDeclaredField(&quot;mRightEdge&quot;);
            edgeRight.setAccessible(true);
            EdgeEffectCompat ee = (EdgeEffectCompat)edgeLeft.get(viewPager);
            if (ee != null) {
                setEdgeGlowColor(ee, color);
            }
            ee = (EdgeEffectCompat)edgeRight.get(viewPager);
            if (ee != null) {
                setEdgeGlowColor(ee, color);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>  然后再获取真正的EdgeEffect，并更改颜色。</p>

<pre class="line-numbers"><code class="language-java">private static void setEdgeGlowColor(@NonNull EdgeEffectCompat edgeEffect, @ColorInt int color) throws Exception {
    if(Build.VERSION.SDK_INT &gt;= 21) {
        Field field = EdgeEffectCompat.class.getDeclaredField(&quot;mEdgeEffect&quot;);
        field.setAccessible(true);
        EdgeEffect effect = (EdgeEffect) field.get(edgeEffect);
        if (effect != null) {
            effect.setColor(color);
        }
    }
}
</code></pre>

<p>  这样边缘效果的颜色就修改好啦。</p>

<h2 id="toc_8">遍历逻辑</h2>

<p>  遍历逻辑控制器主要负责对整个页面的所有View进行遍历，并进行颜色处理。<br/>
  以下是遍历逻辑：</p>

<p><figure><img src="media/15561207870604/15713322369276.png" alt=""/></figure></p>

<ul>
<li>初始化Processor</li>
</ul>

<pre class="line-numbers"><code class="language-java">private static void initProcessors() {
    mProcessors = new HashMap();
    mProcessors.put(&quot;[default]&quot;, new DefaultProcessor());
    mProcessors.put(ScrollView.class.getName(), new MusicScrollViewProcessor());
    mProcessors.put(ListView.class.getName(), new MusicListViewProcessor());
    mProcessors.put(RecyclerView.class.getName(), new MusicRecyclerViewProcessor());
    mProcessors.put(Toolbar.class.getName(), new MusicToolbarProcessor());
    mProcessors.put(NavigationView.class.getName(), new MusicNavigationViewProcessor());
    mProcessors.put(TabLayout.class.getName(), new MusicTabLayoutProcessor());
    mProcessors.put(ViewPager.class.getName(), new MusicViewPagerProcessor());
}
</code></pre>

<p>  将各Processor实例化后存入HashMap，key为类名。</p>

<ul>
<li><p>开始刷新的时机是onStart，因为这个时候布局已经基本初始化完毕。我们会判断Activity之前是否start过，避免重复的进行处理。至于在此之后生成的布局，会单独对其进行一次刷新。</p></li>
<li><p>从流程图中可以看出，在处理ContentView之前，我们会单独处理几个特殊的布局。<br/><br/>
StatusBar是顶部状态栏，NavigationBar是底部导航栏，有时我们会希望让这两处也兼容主题色。<br/><br/>
    如果用到ActionBar，也需要处理一下。不过MD的实现中，一般都是NoActionBar的，而用我们自己布局的ToolBar来代替。<br/><br/>
    在有侧边栏的页面中，根布局一般都是DrawerLayout，在侧边栏滑出的时候，可以设置DrawerLayout的状态栏颜色。  </p></li>
<li><p>找我们自己的根布局：ContentView<br/><br/>
ContentView就是我们用setContentView设置的布局，它上面还有ContentParent，DecorView，Window。<br/><br/>
  直接根据资源id找？不现实，因为每个Activity的ContentView资源id基本都不一样的。<br/><br/>
  这里采取一种迂回的方式，先找到ContentView的父布局ContentParent。<br/><br/>
  我们看setContentView的代码：  </p></li>
</ul>

<pre class="line-numbers"><code class="language-java">@Override
public void setContentView(int resId) {
    ensureSubDecor();
    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);
    contentParent.removeAllViews();
    LayoutInflater.from(mContext).inflate(resId, contentParent);
    mOriginalWindowCallback.onContentChanged();
}
</code></pre>

<p>  可以看到，实际上ContentParent的资源id是固定的：android.R.id.content。<br/><br/>
  系统会先把ContentParent的子视图清除，然后通过LayoutInflater的inflate方法将我们指定布局的视图解析出来并添加到ContentParent中。<br/><br/>
  那么我们就可以根据android.R.id.content先找到ContentParent，进而找到ContentView<br/><br/>
  </p>

<pre class="line-numbers"><code class="language-java">ViewGroup contentView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(0);
</code></pre>

<ul>
<li>获取Processor</li>
</ul>

<p>  根据View的类名获取Processor</p>

<pre class="line-numbers"><code class="language-java">Processor processor = mProcessors.get(viewClass.getName());
if(processor != null) {
    return processor;
} else {
    Class current = viewClass;

    do {
        current = current.getSuperclass();
        if(current == null) {
            break;
        }

        processor = mProcessors.get(current.getName());
    } while(processor == null);

    if (processor == null) {
        mProcessors.get(&quot;[default]&quot;)
    }

    return processor;
}
</code></pre>

<p>  从HashMap中获取对应的Processor，如果找不到则根据父类的名字查找。找到之后就可以调用process方法进行处理。</p>

<ul>
<li>遍历</li>
</ul>

<p>  这里会从ContentView开始进行深度优先遍历，处理所有的视图。<br/><br/>
  有一些特殊的ViewGroup不需要遍历其子布局，例如TabLayout，因为其自己的方法已经满足绝大部分的情况。</p>

<h2 id="toc_9">结语</h2>

<p>  以上，就是两种变色方案的具体实现。</p>

<ul>
<li>自定义Style和Theme实现简单，整洁，适用于模式较为固定的场景。</li>
<li>动态配置主题色实现起来略微复杂，但是比较灵活，适用于主题色较多的场景。</li>
</ul>

<p>  将这两种方案结合，就实现了轻听的变色。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870533.html">
                
                  <h1>Android-ImageView详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">ScaleType</h2>

<ul>
<li><p><code>android:scaleType=&quot;center&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按照图片的原大小居中显示，不缩放，用ImageView的大小截取图片的居中部分。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerCrop&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按比例缩小图片，直到图片的宽高有一边等于ImageView的宽高，则对于另一边，图片的长度大于或等于ImageView的长度，最后用ImageView的大小居中截取该图片。</li>
<li>当图片小于ImageView的宽高：以图片的中心店和ImageView的中心点为基准，按比例扩大图片，直到图片的宽高大于或等于ImageView的宽高，并按ImageView的大小居中截取该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerInside&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心和ImageView的中心点为基准，按比例缩小图片，使图片宽高等于或者小于ImagevView的宽高，直到将图片的内容完整居中显示。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitCenter&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，居中显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitStart&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的上方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitEnd&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的下方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitXY&quot;</code></p>
<ul>
<li>表示把图片按指定的大小在ImageView中显示，拉伸或收缩图片，不保持原比例，填满ImageView。</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870497.html">
                
                  <h1>Android-Xfermode详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Xfermode</h2>

<p>Xfermode具体怎么翻译，说实话，我也不知道，我习惯叫它图片混合模式，随便了，管它叫什么，不妨碍我们使用它。关于Xfermode的说明，可以在Google文档中找到这样的描述：Xfermode是在绘图通道中自定义“传输模式”的基类。静态函数创建可以调用或者返回任意作为模式枚举指定的预定义子类实例。当Xfermode分配给Paint，然后绘制对象与Paint就具备了所添加的xfermode。读起来比较拗口，下面直接看Xfermode的源码：</p>

<pre class="line-numbers"><code class="language-java">public class Xfermode {  
    protected void finalize() throws Throwable {  
        try {  
            finalizer(native_instance);  
        } finally {  
            super.finalize();  
        }  
    }  
    private static native void finalizer(long native_instance);  
    long native_instance;  
}  
</code></pre>

<p>看，Xfermode就这么点代码，经验告诉我们，其下必有子类，擦，变元芳了~~~</p>

<p><figure><img src="media/15561207870497/15713323572183.png" alt=""/></figure></p>

<p>查看一下文档发现Xfermode确实有AvoidXfermode、PixelXorXfermode、PorterDuffXfermode，下面来继续学习一下3个子类的用法。</p>

<h2 id="toc_1">AvoidXfermode</h2>

<p>看这个子类之前告诉大家一个不幸的消息，AvoidXfermode不支持硬件加速，在高于API16的机器上不会适用，如果想测试这个子类。</p>

<ul>
<li>1，可以关闭手机的硬件加速模块；</li>
<li>2，在AndroidManifest.xml中Application节点上设置硬件加速为false。
<code>android:hardwareAccelerated=&quot;false&quot;</code></li>
</ul>

<p>在Android Studio下点击查看一下AvoidXfermode的构造方法：<br/>
<code>public AvoidXfermode(int opColor, int tolerance, Mode mode)</code></p>

<p><code>AvoidXfermode</code>的构造方法也特别简单，一共接收3个参数：第一个参数opColor是一个16进制的带透明度通道的颜色值，如0X12345678。第二个参数<code>tolerance</code>表示容差值，什么是容差值呢？可以理解成一个表示“精确”和“模糊”的概念，下面会解释一下。第三个参数是<code>AvoidXfermode</code>的模式，<code>AvoidXfermode</code>的模式一共有两种：<code>AvoidXfermode.Mode.TARGET</code>和<code>AvoidXfermode.Mode.AVOID</code>。</p>

<h2 id="toc_2">AvoidXfermode.Mode.TARGET</h2>

<p>在该模式下Android会判断画布上的颜色是否会有跟opColor不一样的颜色，比如我opColor是红色，那么在TARGET模式下就会去判断我们的画布上是否有存在红色的地方，如果有，则把该区域“染”上一层我们画笔定义的颜色，否则不“染”色，而tolerance容差值则表示画布上的像素和我们定义的红色之间的差别该是多少的时候才去“染”的，比如当前画布有一个像素的色值是(200, 20, 13)，而我们的红色值为(255, 0, 0)，当tolerance容差值为255时，即便(200, 20, 13)并不等于红色值也会被“染”色，容差值越大“染”色范围越广反之则反，空说无凭我们来看看具体的实现和效果：</p>

<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private AvoidXfermode avoidXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        avoidXfermode = new AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        mPaint.setARGB(255, 211, 53, 243);  
        mPaint.setXfermode(avoidXfermode);  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>

<p>下面来运行看效果，首先确定一下开启的模拟器是API16以下的，或者Application节点下设置了关闭“硬件加速”：</p>

<p><figure><img src="media/15561207870497/15713323776932.png" alt=""/></figure></p>

<p><code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET)：</code><br/>
大家可以看到，在我们的模式为TARGET容差值为0的时候此时只有当图片中像色颜色值为0XFFFFFFFF的地方才会被染色，而其他地方不会有改变</p>

<p>下面我们来修改一下容差值，将容差值改成255：</p>

<p><figure><img src="media/15561207870497/15713323877972.png" alt=""/></figure></p>

<p><code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.TARGET)</code><br/>
而当容差值为255的时候只要是跟0XFFFFFFFF有点接近的地方都会被染色</p>

<h2 id="toc_3">AvoidXfermode.Mode.AVOID</h2>

<p>则与TARGET恰恰相反，TARGET是我们指定的颜色是否与画布的颜色一样，而AVOID是我们指定的颜色是否与画布不一样，其他的都与TARGET类似<code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.AVOID)：</code></p>

<p><figure><img src="media/15561207870497/15713323978095.png" alt=""/></figure></p>

<p>当模式为AVOID容差值为0时，只有当图片中像素颜色值与0XFFFFFFFF完全不一样的地方才会被染色<code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.AVOID)：</code></p>

<p><figure><img src="media/15561207870497/15713324061116.png" alt=""/></figure></p>

<p>当容差值为255时，只要与0XFFFFFFFF稍微有点不一样的地方就会被染色</p>

<p>那么这玩意究竟有什么用呢？比如说当我们只想在白色的区域画点东西或者想把白色区域的地方替换为另一张图片的时候就可以采取这种方式！</p>

<h2 id="toc_4">PixelXorXfermode</h2>

<p>PixelXorXfermode是Xfermode下的另外一种图像混排模式，该类特别简单，不过呢，也很不幸的，在API16中已经过时了。我们来做一个简单的了解，先看PixelXorXfermode的构造方法：<br/>
<code>public PixelXorXfermode(int opColor)   </code></p>

<p>构造方法很简单，只要传递一个16进制带透明通道的颜色值即可，那么这个参数有什么用呢？我在Google文档中，找到了这样的一个算法：实际上PixelXorXfermode内部是按照“opColor ^ src ^ dst”这个异或算法运算的，得到一个不透明的(alpha = 255)的色彩值，设置到图像中，下面我们接着上面用到的图片Demo写个PixelXorXfermode的Demo：</p>

<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private PixelXorXfermode pixelXorXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        pixelXorXfermode = new PixelXorXfermode(0XFFFF0000);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //先绘制Bitmap，src  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        //随便设置一个纯色测试  
        mPaint.setARGB(255, 211, 53, 243);  
        //设置Xfermode  
        mPaint.setXfermode(pixelXorXfermode);  
        //在bitmap上混排一个纯色的矩形（dst）  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>

<p>混排后的图像是：</p>

<p><figure><img src="media/15561207870497/15713324266322.png" alt=""/></figure></p>

<p>PixelXorXfermode在底层已经取出src，dst每个像素点与opColor进行了opColor ^ src ^ dst运算了，结果输出就是上图所示的那样！好了，我只学这么多了，因为它已经过时了，同样上面的AvoidXfermode也是，过时了，了解即可。下面是对Xfermode的第三个子类，也是唯一一个还没有过时的，非常重要的子类PorterDuffXfermode的学习。</p>

<h2 id="toc_5">PorterDuffXfermode</h2>

<p>同样PorterDuffXfermode也是Xfermode的子类，我们先看看它的构造方法：<code>public PorterDuffXfermode(PorterDuff.Mode mode)</code></p>

<p><code>PorterDuffXfermode</code>的构造方法很简单，构造方法中需要传递一个<code>PorterDuff.Mode</code>参数，关于<code>PorterDuff.Mode</code>，我们在上篇博客中已经学习完了，其实跟<code>ColorFilter</code>的子类<code>PorterDuffColorFilter</code>的混排模式是一样的。Android系统一共提供了18种混排模式，在模拟器的<code>ApiDemos/Graphics/XferModes</code>，有张效果图：</p>

<p><figure><img src="media/15561207870497/15713324389852.png" alt=""/></figure></p>

<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式已经算法，其中比上图多了ADD和OVERLAY两种模式： </p>

<p><figure><img src="media/15561207870497/15713324526708.png" alt=""/></figure></p>

<p>Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面将会对照ApiDemos/Graphics/XferModes的程序进行修改，来测试各个模块的效果，测试程序如下：</p>

<pre class="line-numbers"><code class="language-java">public class XfermodeView extends View {  
  
    //PorterDuff模式常量 可以在此更改不同的模式测试  
    private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;  
    private PorterDuffXfermode porterDuffXfermode;  
    private int screenW, screenH; //屏幕宽高  
    private Bitmap srcBitmap, dstBitmap;  
    //源图和目标图宽高  
    private int width = 120;  
    private int height = 120;  
  
    public XfermodeView(Context context) {  
        this(context, null);  
    }  
  
    public XfermodeView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        screenW = ScreenUtil.getScreenW((Activity) context);  
        screenH = ScreenUtil.getScreenH((Activity) context);  
        //创建一个PorterDuffXfermode对象  
        porterDuffXfermode = new PorterDuffXfermode(MODE);  
        //创建原图和目标图  
        srcBitmap = makeSrc(width, height);  
        dstBitmap = makeDst(width, height);  
    }  
  
    //创建一个圆形bitmap，作为dst图  
    private Bitmap makeDst(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFFFFCC44);  
        c.drawOval(new RectF(0, 0, w  3 / 4, h  3 / 4), p);  
        return bm;  
    }  
  
    // 创建一个矩形bitmap，作为src图  
    private Bitmap makeSrc(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFF66AAFF);  
        c.drawRect(w / 3, h / 3, w  19 / 20, h  19 / 20, p);  
        return bm;  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        Paint paint = new Paint();  
        paint.setFilterBitmap(false);  
        paint.setStyle(Paint.Style.FILL);  
        //绘制“src”蓝色矩形原图  
        canvas.drawBitmap(srcBitmap, screenW / 8 - width / 4, screenH / 12 - height / 4, paint);  
        //绘制“dst”黄色圆形原图  
        canvas.drawBitmap(dstBitmap, screenW / 2, screenH / 12, paint);  
  
        //创建一个图层，在图层上演示图形混合后的效果  
        int sc = canvas.saveLayer(0, 0, screenW, screenH, null, Canvas.MATRIX_SAVE_FLAG |  
                Canvas.CLIP_SAVE_FLAG |  
                Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |  
                Canvas.FULL_COLOR_LAYER_SAVE_FLAG |  
                Canvas.CLIP_TO_LAYER_SAVE_FLAG);  
  
        //先绘制“dst”黄色圆形  
        canvas.drawBitmap(dstBitmap, screenW / 4, screenH / 3, paint);  
        //设置Paint的Xfermode  
        paint.setXfermode(porterDuffXfermode);  
        canvas.drawBitmap(srcBitmap, screenW / 4, screenH / 3, paint);  
        paint.setXfermode(null);  
        // 还原画布  
        canvas.restoreToCount(sc);  
    }  
}  
</code></pre>

<p>为了方便观察，需要将Activity_main.xml的背景色设置为黑色。</p>

<p><strong>1.PorterDuff.Mode.CLEAR</strong>。中文描述：所绘制源图像不会提交到画布上。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;</code></p>

<p><figure><img src="media/15561207870497/15713324799406.png" alt=""/></figure></p>

<p><strong>2.PorterDuff.Mode.SRC</strong>。中文描述：只显示源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC;</code></p>

<p><figure><img src="media/15561207870497/15713324920855.png" alt=""/></figure></p>

<p><strong>3.PorterDuff.Mode.DST</strong>。中文描述：只显示目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST;</code></p>

<p><figure><img src="media/15561207870497/15713325038512.png" alt=""/></figure></p>

<p><strong>4.PorterDuff.Mode.SRC_OVER</strong>。中文描述：正常绘制显示，源图像居上显示。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OVER;</code></p>

<p><figure><img src="media/15561207870497/15713325195114.png" alt=""/></figure></p>

<p><strong>5.PorterDuff.Mode.DST_OVER</strong>。中文描述： 上下层都显示。目标图像居上显示。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OVER;</code></p>

<p><figure><img src="media/15561207870497/15713325338664.png" alt=""/></figure></p>

<p><strong>6.PorterDuff.Mode.SRC_IN</strong>。中文描述： 取两层绘制交集中的源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_IN;</code></p>

<p><figure><img src="media/15561207870497/15713325520933.png" alt=""/></figure></p>

<p><strong>7.PorterDuff.Mode.DST_IN</strong>。中文描述：取两层绘制交集中的目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_IN;</code></p>

<p><figure><img src="media/15561207870497/15713325672134.png" alt=""/></figure></p>

<p><strong>8.PorterDuff.Mode.SRC_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OUT;</code></p>

<p><figure><img src="media/15561207870497/15713325797909.png" alt=""/></figure></p>

<p><strong>9.PorterDuff.Mode.DST_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OUT;</code></p>

<p><figure><img src="media/15561207870497/15713325970254.png" alt=""/></figure></p>

<p><strong>10.PorterDuff.Mode.SRC_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_ATOP;</code></p>

<p><figure><img src="media/15561207870497/15713326104118.png" alt=""/></figure></p>

<p><strong>11.PorterDuff.Mode.DST_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_ATOP;</code></p>

<p><figure><img src="media/15561207870497/15713326227426.png" alt=""/></figure></p>

<p><strong>12.PorterDuff.Mode.XOR</strong>。中文描述：异或：去除两图层交集部分<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.XOR;</code></p>

<p><figure><img src="media/15561207870497/15713326370757.png" alt=""/></figure></p>

<p><strong>13.PorterDuff.Mode.DARKEN</strong>。中文描述：取两图层全部区域，交集部分颜色加深<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DARKEN;</code></p>

<p><figure><img src="media/15561207870497/15713326508491.png" alt=""/></figure></p>

<p><strong>14.PorterDuff.Mode.LIGHTEN</strong>。中文描述：取两图层全部，点亮交集部分颜色<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.LIGHTEN;</code></p>

<p><figure><img src="media/15561207870497/15713326673606.png" alt=""/></figure></p>

<p><strong>15.PorterDuff.Mode.MULTIPLY</strong>。中文描述：取两图层交集部分叠加后颜色<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.MULTIPLY;</code></p>

<p><figure><img src="media/15561207870497/15713326778042.png" alt=""/></figure></p>

<p><strong>16.PorterDuff.Mode.SCREEN</strong>。中文描述：滤色。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SCREEN;</code></p>

<p><figure><img src="media/15561207870497/15713326858545.png" alt=""/></figure></p>

<p>以下是<a href="http://lib.csdn.net/base/android">android</a>中新加的两种模式：</p>

<p><strong>17.ADD</strong>。中文描述：饱和度相加。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.ADD;</code></p>

<p><figure><img src="media/15561207870497/15713326949445.png" alt=""/></figure></p>

<p><strong>18.OVERLAY</strong>。中文描述：叠加<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.OVERLAY;</code></p>

<p><figure><img src="media/15561207870497/15713327034956.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870461.html">
                
                  <h1>Android-Paint详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>的确平时开发中，用到画笔的地方还是不多的。但是一遇到自定义View，就会发现这玩意还真是不能不好好掌握，毕竟绘出我们想要的图形界面就靠它了。很多开发人员对画笔Paint的了解知之甚少，包括我自己在内，所以在今天在这里总结一下Paint的在 android图像处理中起到的作用和用法。</p>

<h2 id="toc_1">Paint的简单了解</h2>

<p>同样，我们学习Paint之前，首先查看一下Paint类的API，其中，我们最需要关注的地方就是Paint类给我们提供了很多的setter方法，可以通过调用setter方法来设置自己的偏好。下面是在Android Studio中查到的Paint类的部分setter：</p>

<p><figure><img src="media/15561207870461/15713327196078.png" alt=""/></figure></p>

<ul>
<li><code>Paint(int flags)</code>：构建Paint实例，常用的flags是ANTI_ALIAS_FLAG，消除锯齿。</li>
<li><code>set(Paint src)</code>：将另一个Paint复制给当前Paint实例，不多说了。</li>
<li><code>setColor(int color)</code>：设置画笔的颜色。</li>
<li><code>setColorFilter(ColorFilter filter)</code>：设置色彩过滤器，很重要，后面还会有一些总结。</li>
<li><code>setStyle(Paint.Style style)</code>：设置Paint的风格。 画笔样式分三种：1.Paint.Style.STROKE：描边 。2.Paint.Style.FILL_AND_STROKE：描边并填充 。3.Paint.Style.FILL：填充 。</li>
<li><code>setAlpha(int a)</code> : 设置绘制图形的透明度。</li>
<li><code>setAntiAlias(boolean aa)</code>：是否消除锯齿。</li>
<li><code>setARGB(int a,int r,int g,int b)</code> : 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。</li>
<li><code>setStrokeWidth(float width)</code>：设置Paint划线的宽度。</li>
<li><code>setDither(boolean dither)</code> : 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰</li>
<li><code>setElegantTextHeight(boolean elegant)</code> : //设置优雅的文字高度，这个设置可能会对FontMetrics产生影响</li>
<li><code>setFakeBoldText(boolean fakeBoldText)</code> : //设置文本粗体</li>
<li><code>setFilterBitmap(boolean filter)</code> : //对位图进行滤波处理，如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示</li>
<li><code>setFlags(int flags)</code> : //设置一些标志，比如抗锯齿，下划线等等。</li>
<li><code>setFontFeatureSettings(String settings)</code> : //设置字体样式，可以设置CSS样式</li>
<li><code>setHinting(int mode)</code> : 设置画笔的隐藏模式。可以是 <code>HINTING_OFF</code> or <code>HINTING_ON</code>之一。</li>
<li><code>setLetterSpacing(float letterSpacing)</code> : //设置行的间距，默认值是0，负值行间距会收缩</li>
<li><code>setLinearText(boolean linearText)</code> : //这个是文本缓存，设置线性文本，如果设置为true就不需要缓存</li>
<li><code>setMaskFilter(MaskFilter maskfilter)</code> : //对图像进行一定的处理，实现滤镜的效果，如滤化，立体等,有BlurMaskFilter，EmbossMaskFilter几种</li>
<li><code>setPathEffect(PathEffect effect)</code> : //设置绘制路径的效果，有ComposePathEffect，CornerPathEffect，DashPathEffect，DiscretePathEffect，PathDashPathEffect，SumPathEffect几种</li>
<li><code>setShader(Shader shader)</code> : //设置着色器，用来给图像着色的，绘制出各种渐变效果，有BitmapShader，ComposeShader，LinearGradient，RadialGradient，SweepGradient几种</li>
<li><code>setShadowLayer(float radius, float dx, float dy, int shadowColor)</code> : //设置阴影效果，radius为阴影角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 ，看一下演示效果，其中第一个是没有阴影的，第二个设置了黑色的阴影</li>
<li><code>setStrikeThruText(boolean strikeThruText)</code> : //设置文本的删除线</li>
<li><code>setStrokeCap(Cap cap)</code> : //设置线条末端形状<code>Paint.Cap.BUTT</code>、<code>Paint.Cap.ROUND</code>、<code>Paint.Cap.SQUARE</code></li>
<li><code>setStrokeJoin(Join join)</code> : //设置矩形连接时的效果<code>Paint.Join.BEVEL</code>、<code>Paint.Join.MITER</code>、<code>Paint.Join.ROUND</code></li>
<li><code>setStrokeMiter(float miter)</code> : //当style为Stroke或StrokeAndFill时设置连接处的倾斜度，这个值必须大于0</li>
<li><code>setSubpixelText(boolean subpixelText)</code> : //设置亚像素，是对文本的一种优化设置，可以让文字看起来更加清晰明显，可以参考一下PC端的控制面板-外观和个性化-调整ClearType文本</li>
<li><code>setTextAlign(Align align)</code> : //设置文本对齐<code>Paint.Align.CENTER</code>、<code>Paint.Align.LEFT</code>、<code>Paint.Align.RIGHT</code></li>
<li><code>setTextLocale(Locale locale)</code> ： //设置地理位置，比如显示中文，日文，韩文等，默认的显示Locale.getDefault()即可</li>
<li><code>setTextScaleX(float scaleX)</code> : //设置字体的水平方向的缩放因子，默认值为1，大于1时会沿X轴水平放大，小于1时会沿X轴水平缩小</li>
<li><code>setTextSize(float textSize)</code> : //设置字体大小</li>
<li><code>setTextSkewX(float skewX)</code> : //设置文本在水平方向上的倾斜，默认值为0，推荐的值为-0.25</li>
<li><code>setTypeface(Typeface typeface)</code> : //设置字体样式，可以是Typeface设置的样式，也可以通过Typeface的createFromAsset(AssetManager mgr, String path)方法加载样式</li>
<li><code>setUnderlineText(boolean underlineText)</code> : //设置文本的下划线</li>
<li><code>setXfermode(Xfermode xfermode)</code>：设置Paint的模式，后面有详细点的说明，很重要。</li>
<li><code>reset()</code> : //重置Paint</li>
<li><code>measureText(char[] text, int index, int count)</code>，<code>measureText(String text, int start, int end)</code>，<code>measureText(String text)</code>，<code>measureText(CharSequence text, int start, int end)</code> : //测量字体的长度</li>
<li><code>breakText(char[] text, int index, int count,float maxWidth, float[] measuredWidth)</code>，<code>breakText(CharSequence text, int start, int end,boolean measureForwards,  floatmaxWidth, float[] measuredWidth)</code>，<code>breakText(String text, boolean measureForwards,float maxWidth, float[] measuredWidth)</code> : //剪切显示，就是大于maxWidth的时候只截取指定长度的显示</li>
<li><code>getTextWidths(char[] text, int index, int count,float[] widths)</code>，<code>getTextWidths(CharSequence text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, float[] widths)</code> : //提取指定范围内的字符串，保存到widths中</li>
<li><code>getTextPath(char[] text, int index, int count, float x, float y, Path path)</code>，<code>getTextPath(String text, int start, int end, float x, float y, Path path)</code> : //获取文本绘制的路径，提取到Path中</li>
<li><code>getTextBounds(String text, int start, int end, Rect bounds)</code>，<code>getTextBounds(char[] text, int index, int count, Rect bounds)</code> : //得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870430.html">
                
                  <h1>Android-ColorFilter详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在Android Studio中点击进去看一下源码，可以看到ColorFilter里的代码量很少</p>

<pre class="line-numbers"><code class="language-java">public class ColorFilter {  
    /** 
     * Holds the pointer to the native SkColorFilter instance. 
     * 
     * @hide 
     */  
    public long native_instance;  
  
    @Override  
    protected void finalize() throws Throwable {  
        try {  
            super.finalize();  
        } finally {  
            destroyFilter(native_instance);  
        }  
    }  
  
    static native void destroyFilter(long native_instance);  
}
</code></pre>

<p>由此根据我们的经验，判断ColorFilter可能是个父类，具体实现可能下面还有子类完成的，于是再看Google的文档：</p>

<p><figure><img src="media/15561207870430/15713327420386.png" alt=""/></figure></p>

<p>一目了然了，ColorFilter下有3个子类ColorMatrixColorFilter, LightingColorFilter, PorterDuffColorFilter ，下面逐一学习一下。</p>

<h2 id="toc_1">ColorMatrixColorFilter</h2>

<p><code>ColorMatrixColorFilter</code>翻译为颜色矩阵过滤器，神马是颜色矩阵？实际上， 安卓中管理色彩矩阵是以RGBA像素点的方式加载到内存的，这些点统一使用<code>ColorMatrix</code>的矩阵来统一管理，矩阵定义为4*5的排列形式。那好，首先来看看<code>ColorMatrixColorFilter</code>的两个构造器：</p>

<pre class="line-numbers"><code class="language-java">public ColorMatrixColorFilter(ColorMatrix matrix) {  
        mMatrix.set(matrix);  
        update();  
}  
  
public ColorMatrixColorFilter(float[] array) {  
        if (array.length &lt; 20) {  
            throw new ArrayIndexOutOfBoundsException();  
        }  
        mMatrix.set(array);  
        update();  
}  
</code></pre>

<p>ColorMatrixColorFilter中一个构造器需要接收ColorMatrix对象，另一个需要接收一个4*5的float型数组，我们再打开Android Studio追踪一下mMatrix.set()方法，可以看到以上两个构造器里面调的set方法各自实现的方式</p>

<pre class="line-numbers"><code class="language-java">public void set(ColorMatrix src) {  
        System.arraycopy(src.mArray, 0, mArray, 0, 20);  
}  
  
public void set(float[] src) {  
        System.arraycopy(src, 0, mArray, 0, 20);  
}  
</code></pre>

<p>再追踪一下System.arraycopy()方法：</p>

<pre class="line-numbers"><code class="language-java">public static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length)
</code></pre>

<p>好了，到这里，其实已经很明白了，ColorMatrixColorFilter构造器中接收的两个不同的参数，实际上底层实现方式都是一样的，都是同样调用System.arraycopy()中带float数组参数的方法。所以我们不必再考虑怎么样去写一个ColorMatrix对象传递给ColorMatrixColorFilter了，实际上我们使用第二个构造器，传递一个float数组，会显得程序更加直观易懂，那么我们就尝试写一个ColorMatrixColorFilter，并且设置给Paint吧.</p>

<pre class="line-numbers"><code class="language-java">public class CustomView1 extends View {  
    private Paint mPaint;  
    private Context mContext;  
    public CustomView1(Context context) {  
        this(context, null);  
    }  
  
    public CustomView1(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initPaint();  
    }  
    private void initPaint() {  
        //初始化Paint，并且设置消除锯齿。  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        //设置画笔样式为描边  
        mPaint.setStyle(Paint.Style.FILL);  
        //设置描边的粗细，单位：像素px 注意：当setStrokeWidth(0)的时候描边宽度并不为0而是只占一个像素  
        mPaint.setStrokeWidth(20);  
        //设置画笔颜色为自定义颜色  
        mPaint.setColor(Color.argb(255, 255, 128, 102));  
        ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1, 0, 0, 0, 0,  
                0, 1, 0, 0, 0,  
                0, 0, 1, 0, 0,  
                0, 0, 0, 1, 0  
        });  
        mPaint.setColorFilter(colorFilter);  
    }  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //画一个圆形，取屏幕中心点为圆心  
        canvas.drawCircle(ScreenUtil.getScreenW(mContext) / 2,  
                ScreenUtil.getScreenH(mContext) / 2, 100, mPaint);  
    }  
}
</code></pre>

<p>看上面的例子程序，首先创建了一个ColorMatrixColorFilter对象，并且传递进去一个float型的4*5排列的数组，然后调用Paint的setColorFilter方法将ColorMatrixColorFilter对象传入，我们在模拟器上运行一下，duang~~，我去，什么变化都没有，还是岛国的旗帜。这是怎么回事？下面有必要在学习一下了：</p>

<p>其实一个4*5的float数组中分别对应的是RGBA的向量值，第一行代表的是R(红色)的向量值，第二行代表G(绿色)的向量值，第三行代表B(蓝色)的向量值，第四行代表A(透明度)的向量值，这4行分别代表不同的RGBA的向量值，并且值的取值范围是[0.0F , 2.0F]，当值为1.0F的时候，表示保持原有的色彩，不发生色彩便宜。so，如果我们想要将上面的红色的圈圈颜色变掉，就不能像上面的代码一样，将所有的向量值都设置为1.0F，下面我们修改一个：</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.5F, 0, 0, 0, 0,  
                0, 0.5F, 0, 0, 0,  
                0, 0, 0.5F, 0, 0,  
                0, 0, 0, 1, 0  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p>将上面的ColorMatrixColorFilter中的float数组替换成这样的<br/>
哎哟呵~颜色变深了，看起来神奇很多。那么，这个色彩矩阵以及这个float数组是怎样做到的呢？或者说是怎样通过计算后得到另外一个色彩值的呢？下面作图来说明一下，我们顶一个ColorMatrix的4*5的float型数组，然后定义一个我们自己MyColor，分别代表RGBA的值：</p>

<p><figure><img src="media/15561207870430/15713327557838.jpg" alt=""/></figure></p>

<p>实际上，安卓系统计算色彩值是用矩阵相乘的方式得出的，如上图的样子。这里的MyColor的各项值都要转换到[0,1]之间的值，下面就是我们实际转换的计算方式和结果了。</p>

<p><figure><img src="media/15561207870430/15713327650356.jpg" alt=""/></figure></p>

<p>通过上面的计算，我们得到了最终的RGBA的值是（0.5,0.25,0.2,1），说明RGB色彩值都发生了便宜，只有A未偏移，然后我们将这些值乘以255后还原一下看看，是不是跟上图的圈圈的色彩值是一致的呢，好吧，别看了，肯定必须一定是一样的。那么了解色彩矩阵有什么用呢？上面简单的更换一下色彩值而已，Paint类下也提供了setColor()方法，直接将色彩值设置上去，都TMD的方便，还搞什么玩意的矩阵，显得自己牛逼+蛋疼是不是？解释一下，上面的例子不过是个例子而已啊，真正开发的时候肯定是setColor比较简便嘛。问题来了，我们有可能处理的不是一个纯色彩的东西，而是一直图片呢？一张图片是有几十万中色彩值的，这时候setColor()就不可能让他们变色了吧，还是得用色彩矩阵来搞这玩意。下面我们从drawable目录下加载一张图片吧！</p>

<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>

<p><figure><img src="media/15561207870430/15713327784421.png" alt=""/></figure></p>

<p>好了图片加载完毕，代码没有难度，上面的Paint没有做任何的处理，下面我们为Paint设置色彩过滤器吧！</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0, 0, 0, 1, 0,  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p><figure><img src="media/15561207870430/15713327887731.png" alt=""/></figure></p>

<p>好吧图片变成黑白的了，难道setColor()也可以办吗？再改一个试试：</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                0, 0, 0, 1, 0,  
        });  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p><figure><img src="media/15561207870430/15713328018868.png" alt=""/></figure></p>

<p>这样的效果是不是有点像负片效果啊！好了，反正我也不懂图像学，ColorMatrixColorFilter想设置什么样的就改改矩阵就行了，到底需要什么效果，效果的值要设置成多少，我也不知道，问问美工吧！我们只负责写程序！呵呵~~</p>

<h2 id="toc_2">LightingColorFilter</h2>

<p>LightingColorFilter顾名思义就是“光照色彩过滤器”，就是模拟一个光照照过图像所产生的效果，构造器是这样的：<br/>
<code>public LightingColorFilter(int mul, int add)</code><br/><br/>
查看一下Google文档，是这样介绍滴：</p>

<p>光照色彩滤光片，可以用来模拟简单的照明效果。一个lightingcolorfilter定义了两个参数，一个用于与源颜色相乘（称为colormultiply）和一个用于添加到源颜色（称为coloradd）。alpha通道是原封不动的彩色滤光片。给定一个源颜色的RGB，由此产生的特定颜色计算如下：</p>

<pre class="line-numbers"><code class="language-text">R&#39; = R * colorMultiply.R + colorAdd.R
G&#39; = G * colorMultiply.G + colorAdd.G
B&#39; = B * colorMultiply.B + colorAdd.B
</code></pre>

<p>每个通道值的结果范围是0~255。上面的介绍写的比较明白， 算法也很简单，我们以上面的原图为例，看见蓝天了吗，我们现在去掉这个蓝色的天。根据这个短发描述呢，我们仅仅去掉蓝色，就要将蓝色的通道值改变，将B计算为其它值，这时候colorMultiply.B = 00，colorAdd.B =00，计算得到的B = 00，其它的通道R和G均不变，那么,colorAdd.R=0，colorAdd.G =0；colorMultiply.R = FF，colorMultiply.G =FF，Alpha通道A是忽略的，所以随便设置什么都不会有变化的。</p>

<pre class="line-numbers"><code class="language-java">LightingColorFilter colorFilter = new LightingColorFilter(0xFFFFFF00, 0x00000000);  
mPaint.setColorFilter(colorFilter);
</code></pre>

<p>运行之后的结果，蓝天没了。</p>

<p><figure><img src="media/15561207870430/15713328128205.png" alt=""/></figure></p>

<h2 id="toc_3">PorterDuffColorFilter</h2>

<p>ColorFilter下还有最后一个子类，PorterDuff混合模式的色彩过滤器，下面是其构造器：<br/>
<code>public PorterDuffColorFilter(int color, PorterDuff.Mode mode)</code></p>

<p>Google文档：PorterDuff滤光器可以用于点源像素使用一个单一的颜色和一个特定的波特达夫复合模式。</p>

<p>PorterDuffColorFilter的构造器也很简单，其中第一个参数表示一个16进制的色彩值，第二个参数是一个枚举值PorterDuff.Mode，表示图片混排的模式，PorterDuff.Mode在Android下一共有16种。下面我们先写一个小例子看一下，这里我们还是使用上面的图片，为原图添加图片混排模式，颜色值设置为红色0XFFFF0000，混排模式设置为PorterDuff.Mode.DARKEN。</p>

<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(0XFFFF0000, PorterDuff.Mode.DARKEN);  
        mPaint.setColorFilter(colorFilter);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>

<p>上面的图片就是运行之后的效果了，原图不仅变红了，而且还变暗了。其实我们这里将PorterDuffColorFilter的构造器参数拆开来分析一下，首先我们传递进去一个红色的颜色值0XFFFF0000，这里相当于创建了一张新的图层，图层的颜色就是0XFFFF0000，而我们的原图可以看作是第二张图层，我们先把这2个图片重叠放在一起，就会发现得到一个原图上很红的图片，然后我们看一下PorterDuff.Mode是DARKEN模式，表示在之前得到的“原图+很红”的图片上进一步将色调调成暗色，最终得到了如上所示的图片。</p>

<p>关于PorterDuff.Mode，Android系统一共提供了18种混排模式，在模拟器的ApiDemos/Graphics/XferModes，有张效果图：</p>

<p><figure><img src="media/15561207870430/15713328265702.png" alt=""/></figure></p>

<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式算法，其中比上图多了ADD和OVERLAY两种模式：</p>

<p><figure><img src="media/15561207870430/15713328371456.png" alt=""/></figure></p>

<p>其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面是在网上找到的汉字语言描述，感谢这位作者的总结。</p>

<p>注意：先绘制dst，再绘制src。</p>

<ul>
<li><strong>1.PorterDuff.Mode.CLEAR</strong>    所绘制源图像不会提交到画布上。</li>
<li><strong>2.PorterDuff.Mode.SRC</strong>    只显示源图像。</li>
<li><strong>3.PorterDuff.Mode.DST</strong>    只显示目标图像。</li>
<li><strong>4.PorterDuff.Mode.SRC_OVER</strong>    正常绘制显示，源图像居上显示。</li>
<li><strong>5.PorterDuff.Mode.DST_OVER</strong>    上下层都显示。目标图像居上显示。</li>
<li><strong>6.PorterDuff.Mode.SRC_IN</strong>    取两层绘制交集中的源图像。</li>
<li><strong>7.PorterDuff.Mode.DST_IN</strong>     取两层绘制交集中的目标图像。</li>
<li><strong>8.PorterDuff.Mode.SRC_OUT</strong>    只在源图像和目标图像不相交的地方绘制源图像。</li>
<li><strong>9.PorterDuff.Mode.DST_OUT</strong>    只在源图像和目标图像不相交的地方绘制目标图像。</li>
<li><strong>10.PorterDuff.Mode.SRC_ATOP</strong>    在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。</li>
<li><strong>11.PorterDuff.Mode.DST_ATOP</strong>   在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。</li>
<li><strong>12.PorterDuff.Mode.XOR</strong>    异或：去除两图层交集部分</li>
<li><strong>13.PorterDuff.Mode.DARKEN</strong>     取两图层全部区域，交集部分颜色加深</li>
<li><strong>14.PorterDuff.Mode.LIGHTEN</strong>   取两图层全部，点亮交集部分颜色</li>
<li><strong>15.PorterDuff.Mode.MULTIPLY</strong>    取两图层交集部分叠加后颜色</li>
<li><strong>16.PorterDuff.Mode.SCREEN</strong>    滤色。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870348.html">
                
                  <h1>Android-ViewStub详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在开发应用程序的时候，经常会遇到这样的情况，会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为<code>View.GONE</code>，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见<code>View.GONE</code>但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</p>

<h2 id="toc_1">ViewStub</h2>

<p>上面的问题，推荐的做法是使用 Android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了<code>ViewStub.inflate()</code>的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。<br/>
但ViewStub也不是万能的，下面总结下ViewStub能做的事儿和什么时候该用ViewStub，什么时候该用可见性的控制。</p>

<h2 id="toc_2">特点</h2>

<ul>
<li>ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不能够再通过ViewStub来控制它了。</li>
<li>ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</li>
</ul>

<h2 id="toc_3">可以考虑使用ViewStub的情况</h2>

<ul>
<li>在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要<em>在运行时不止一次的显示和隐藏某个布局</em>，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。</li>
<li>想要控制显示与隐藏的是一个布局文件，而非某个View。因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。</li>
</ul>

<h2 id="toc_4">下面来看一个实例</h2>

<p>在这个例子中，要显示二种不同的布局，一个是用TextView显示一段文字，另一个则是用ImageView显示一个图片。这二个是在onCreate()时决定是显示哪一个，这里就是应用ViewStub的最佳地点。</p>

<p>先来看看布局，一个是主布局，里面只定义二个ViewStub，一个用来控制TextView一个用来控制ImageView，另外就是一个是为显示文字的做的TextView布局，一个是为ImageView而做的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;fill_parent&quot;  
  android:layout_height=&quot;fill_parent&quot;  
  android:gravity=&quot;center_horizontal&quot;&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_text&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout_marginTop=&quot;10dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_text_layout&quot;/&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_image&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_image_layout&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>为TextView的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;TextView  
        android:id=&quot;@+id/viewstub_demo_textview&quot;  
        android:layout_width=&quot;fill_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:background=&quot;#aa664411&quot;  
        android:textSize=&quot;16sp&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>为ImageView的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;ImageView  
        android:id=&quot;@+id/viewstub_demo_imageview&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>下面来看代码，决定来显示哪一个，只需要找到相应的ViewStub然后调用其infalte()就可以获得相应想要的布局：</p>

<pre class="line-numbers"><code class="language-java">public class ViewStubDemoActivity extends Activity {  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.viewstub_demo_activity);  
        if ((((int) (Math.random() * 100)) &amp; 0x01) == 0) {  
            // to show text  
            // all you have to do is inflate the ViewStub for textview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_text);  
            stub.inflate();  
            TextView text = (TextView) findViewById(R.id.viewstub_demo_textview);  
            text.setText(&quot;The tree of liberty must be refreshed from time to time&quot; +  
                    &quot; with the blood of patroits and tyrants! Freedom is nothing but &quot; +  
                    &quot;a chance to be better!&quot;);  
        } else {  
            // to show image  
            // all you have to do is inflate the ViewStub for imageview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_image);  
            stub.inflate();  
            ImageView image = (ImageView) findViewById(R.id.viewstub_demo_imageview);  
            image.setImageResource(R.drawable.happy_running_dog);  
        }  
    }  
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870386.html">
                
                  <h1>Android-DataBinding详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>谷歌开发了一个非常厉害的新框架DataBinding， 数据绑定框架给我们带来了很大的方便，以前我们可能需要在每个Activity里写很多的findViewById，不仅麻烦，还增加了代码的耦合性，如果我们使用DataBinding，就可以抛弃那么多的findViewById，省时省力。说到这里，其实网上也有很多快速的注解框架，但是注解框架与DataBinding想比还是不好用，而且官网文档说DataBinding还能提高解析XML的速度，其实DataBinding的好用，不仅仅体现在可以省去使用很多啰嗦findViewById，还有很多。往下看你就会明白的。</p>

<p>在介绍DataBinding之前，肯定要先学会搭建使用它的环境。在Android Studio上Databinding的使用还是很简单的。</p>

<h2 id="toc_1">环境搭建</h2>

<p>Android 的 Gradle 插件版本不低于 1.5.0-alpha1：classpath &#39;com.android.tools.build:gradle:1.5.0&#39;然后修改对应模块（Module）的 build.grade：</p>

<pre class="line-numbers"><code class="language-java">android {
    ....
    dataBinding {
        enabled = true
    }
}
</code></pre>

<p>注意：Android stuido 的版本一定要大于1.3，而且Android Studio目前对binding对象没有自动代码提示，只会在编译时进行检查。<br/>
就是这么简单，但是1.3及以前的版本，对于环境的搭建，可能就会麻烦一点（没事1.3的环境搭建方法，网上多得是）。</p>

<h2 id="toc_2">基础展示</h2>

<p>我们在具体的讲解之前，先用一个简单的小例子来学习一下基础并展现一下DataBinding的巨大魅力，估计你会被其简单的特性所吸引哦。<br/><br/>
首先我们先建立一个java bean，就是一个非常简单的用户类吧。</p>

<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding.bean;
/**
 * Created by loongggdroid on 2016/3/14.
 */
public class User {
    private String name;
    private String age;
    public User(String name, String age) {
        this.name = name;
        this.age = age;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(String age) {
        this.age = age;
    }
    public String getName() {
        return this.name;
    }
    public String getAge() {
        return this.age;
    }
}
</code></pre>

<p>其次，来看看使用了DataBinding之后的布局文件是什么样子的呢？主要的变化是在layout布局文件之中。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.name}&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.age}&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p>看到这里，可能有的人就开始有点迷糊了，没有给控件定义id，而是用了@{ }的方法，到底是怎么回事？先不忙，一会再给你解释，我们再来看看怎么把值传进去的，在Activity中是如何使用的。</p>

<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding;

import android.app.Activity;
import android.databinding.DataBindingUtil;
import android.os.Bundle;

import loonggg.net.databinding.bean.User;
import loonggg.net.databinding.databinding.ActivityMainBinding;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
        User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
        binding.setUser(user);
    }

}
</code></pre>

<p>看到Activity是不是感觉很简洁，很清爽，没有了控件的初始化findViewById，然后再去setText(), 就仅仅只添加了两行代码。运行结果，不用说，显而易见，肯定会显示loonggg和23。</p>

<h2 id="toc_3">基础用法</h2>

<h3 id="toc_4">布局生命</h3>

<p>例子我们介绍完了，对于例子中出现的一些新东西，有必要解释一下，java bean那里就不解释了，大家肯定都懂，我们就从布局文件讲起。相比以前使用的xml，根节点由具体的某个layout（比如LinearLayout ）变成了layout，里面包括了data节点和传统的视图。这里的data节点就像是连接 View 和 Modle 的桥梁。在这个data节点中声明一个variable变量，那值就可以轻松传到布局文件中来了。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;!--type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user--&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt; 
    &lt;LinearLayout&gt;
     ……
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p>变量名为user变量类型为&quot;loonggg.net.databinding.bean.User &quot;</p>

<p>type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user，TextView中的@{user.name}就是把这个user中的名字展示出来，age同样如此。</p>

<h3 id="toc_5">绑定Variable</h3>

<p>虽然在布局文件中对应上了，但是值是怎么传进去的呢？这就是我们要将的Activity中的那两行代码了，它把实体类和布局文件进行了绑定。修改MainActivity中的onCreate，用 DatabindingUtil.setContentView() 来替换掉 setContentView()，然后创建一个 user 对象，通过 binding.setUser(user) 与 variable 进行绑定。</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
    binding.setUser(user);
}
</code></pre>

<p>ActivityLayoutDetailBinding这个类是自动生成的和你的布局文件名字一样，如果你想要去改变名字的话</p>

<pre class="line-numbers"><code class="language-markup">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;  
  
    &lt;!--这里你也可以为Binding类进行命名，有三种形式  
        1、Custom:会在databinding包下  
        2、.Custom:会在当前的包名下创建  
        3、com.andly.Custom:会在指定的包名下进行创建--&gt;  
    &lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt; //在app_package/databinding下生成CustomBinding；
    &lt;data class=&quot;.CustomBinding&quot;&gt;&lt;/data&gt; //在app_package下生成CustomBinding；
    &lt;data class=&quot;com.example.CustomBinding&quot;&gt;&lt;/data&gt; // 明确指定包名和类名。
</code></pre>

<h2 id="toc_6">高级用法</h2>

<h3 id="toc_7">import用法</h3>

<p>其实data节点也是支持import用法的，比如：</p>

<pre class="line-numbers"><code class="language-java">&lt;data&gt;
     &lt;import type=&quot;loonggg.net.databinding.bean.User &quot;/&gt;
     &lt;variablename=&quot;user&quot;type=&quot;User&quot; /&gt;
&lt;/data&gt;
</code></pre>

<p>这里需要注意的是：<code>import</code>并不能像java 一样可以 <code>import xx.xxx.*</code>，必须具体到写清楚每个要导入的类名。</p>

<h3 id="toc_8">类名相同</h3>

<p>到这里你可能会问如果import了两个相同名称的类咋办？别怕，人家想的很周到，可以起个别名或者昵称嘛！例如：</p>

<pre class="line-numbers"><code class="language-java">···
&lt;data&gt; 
  &lt;import type=&quot;xxx.User&quot; alias=&quot;MyUser&quot;&gt; 
  &lt;import type=&quot;xxx.xx.User&quot;&gt; 

   &lt;variable 
            name=&quot;user&quot; 
            type=&quot;User&quot; /&gt; 
    &lt;variable 
            name=&quot;myUser&quot; 
            type=&quot;MyUser&quot;/&gt; 
&lt;/data&gt; 
&lt;TextView xxx:@{myUser.getName()}&gt; 
&lt;TextView xxx:@{user.getName()}&gt;
···
</code></pre>

<h3 id="toc_9">变量定义的高级用法</h3>

<p>在上面，我们学会了如何去在xml中定义一些简单的变量。我们没有定义像List、Map等这样的集合变量。那这种集合变量该如何定义呢？其实定义的方式和我们上面的基本一致，区别就在于我们还需要为它定义key的变量，例如：</p>

<pre class="line-numbers"><code class="language-markup">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; 
    &lt;data&gt; 
        &lt;import type=&quot;android.graphics.Bitmap&quot; /&gt; 
        &lt;import type=&quot;java.util.ArrayList&quot; /&gt; 
        &lt;import type=&quot;java.util.HashMap&quot; /&gt;  
        &lt;!-- 集合的定义 --&gt;
        &lt;variable 
            name=&quot;list&quot; 
            type=&quot;ArrayList&amp;lt;String&gt;&quot; /&gt; // 左尖括号需要转义
        &lt;variable 
            name=&quot;map&quot; 
            type=&quot;HashMap&amp;lt;String, String&gt;&quot; /&gt; 
        &lt;variable 
            name=&quot;array&quot; 
            type=&quot;String[]&quot; /&gt; 
        &lt;!-- 为集合定义对应的索引 --&gt;
        &lt;variable 
            name=&quot;listKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;variable 
            name=&quot;mapKey&quot; 
            type=&quot;String&quot; /&gt; 
        &lt;variable 
            name=&quot;arrayKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;!-- 字符串，布尔值和int的用法--&gt;
        &lt;variable 
            name=&quot;str&quot; 
            type=&quot;String&quot;/&gt; 
        &lt;variable 
            name=&quot;error&quot; 
            type=&quot;boolean&quot;/&gt; 
        &lt;variable 
            name=&quot;num&quot; 
            type=&quot;int&quot; /&gt; 
    &lt;/data&gt; 
    &lt;LinearLayout 
        android:orientation=&quot;vertical&quot; 
        android:layout_width=&quot;match_parent&quot; 
        android:layout_height=&quot;wrap_content&quot;&gt; 

        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{list[listKey]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{map[`name`]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{array[0]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{str}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{String.valueOf(num)}&quot;/&gt; 
    &lt;/LinearLayout&gt; 
&lt;/layout&gt;
</code></pre>

<p>在引用的同时也可以加上简单的逻辑运算</p>

<pre class="line-numbers"><code class="language-markup">&lt;!--数据绑定将自动检测null异常，如果你的表达式为null，它将会给它赋值为(null)  
 如果为int类型则默认为0--&gt;  
 &lt;!--之前都是写三元运算符的形式，当然在数据绑定中也能够使用，但更推荐下面那种--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{boo?note:null}&quot; /&gt;  
 &lt;!--?? :null合并运算符，当左边为null会显示右边--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{note??null}&quot;  
     android:textColor=&quot;#00FF00&quot;  
     android:textSize=&quot;18sp&quot; /&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;!--引用资源文件--&gt;  
&lt;ImageView  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:paddingLeft=&quot;@{boo?@dimen/large_padding:@dimen/small_padding}&quot;  
    android:src=&quot;@{image}&quot; /&gt; 
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;TextView  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&#39;@{String.valueOf(map[`one`])}&#39;/&gt;  
</code></pre>

<h3 id="toc_10">Observable数据改变自动更新</h3>

<p><code>Observable</code>是一个接口，它的子类有<code>BaseObservable</code>,<code>ObservableField</code>,<code>ObservableBoolean</code>,<code>ObservableByte</code>, <code>ObservableChar</code>, <code>ObservableShort</code>, <code>ObservableInt</code>, <code>ObservableLong</code>, <code>ObservableFloat</code>, <code>ObservableDouble</code>, and <code>ObservableParcelable</code>，<code>ObservableArrayList</code>,<code>ObservableArrayMap</code><br/>
现在我们来看看 如何在数据改变时，不手动设置，让其自动改变：</p>

<p><strong>布局文件</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Person&quot; /&gt;
        &lt;variable
            name=&quot;person&quot;
            type=&quot;Person&quot; /&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`firstName:`+person.firstName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`lastName:`+person.lastName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`age:`+person.age}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/second_btn1&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;改变数据&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>Person类</strong></p>

<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding.model;

import android.databinding.BaseObservable;
import android.databinding.Bindable;

import www.zhang.com.databinding.BR;

public class Person extends BaseObservable {
    private String firstName;
    private String lastName;
    private int age;
    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    @Bindable
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
        notifyPropertyChanged(BR.firstName);
    }
    @Bindable
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
        notifyPropertyChanged(BR.lastName);
    }
    @Bindable
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
        notifyPropertyChanged(BR.age);
    }
}
</code></pre>

<p>Model类继承BaseObservable,BaseObservable实现 Android.databinding.Observable接口，Observable接口可以允许附加一个监听器到model对象以便监听对象上的所有属性的变化。<br/><br/>
Observable接口有一个机制来添加和删除监听器，但通知与否由开发人员管理。为了使开发更容易，BaseObservable实现了监听器注册机制。DataBinding实现类依然负责通知当属性改变时。这是通过指定一个Bindable注解给getter以及setter内通知来完成的。<br/><br/>
notifyPropertyChanged(BR.参数名)通知更新这一个参数，需要与@Bindable注解配合使用。notifyChange()通知更新所有参数，可以不用和@Bindable注解配合使用</p>

<p><strong>SecondActivity</strong></p>

<pre class="line-numbers"><code class="language-java">public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivitySecondBinding binding = DataBindingUtil.setContentView(SecondActivity.this, R.layout.activity_second);

        final Person person = new Person(&quot;zhang&quot;,&quot;san&quot;,38);
        binding.setPerson(person);

        binding.secondBtn1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                person.setFirstName(&quot;li&quot;);
                person.setLastName(&quot;si&quot;);
                person.setAge(40);
            }
        });
    }
}
</code></pre>

<h4 id="toc_11">示例</h4>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Animal&quot;/&gt;
        &lt;variable
            name=&quot;animal&quot;
            type=&quot;Animal&quot;/&gt;
        &lt;variable
            name=&quot;list&quot;
            type=&quot;android.databinding.ObservableArrayList&amp;lt;String&amp;gt;&quot;/&gt;
        &lt;variable
            name=&quot;map&quot;
            type=&quot;android.databinding.ObservableArrayMap&amp;lt;String,String&amp;gt;&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{animal.field}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{String.valueOf(animal.age)}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[0]}&quot; /&gt;
        &lt;!--Map集合既可以通过map[key]的方式，也可以通过调用API--&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[1]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`name`]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`age`]}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/four_btn&quot;
            android:layout_width=&quot;match_parent&quot;
            android:text=&quot;改变数据&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>Animal类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Animal {
    public final ObservableField&lt;String&gt; field = new ObservableField&lt;&gt;();
    public final ObservableInt age = new ObservableInt();
}
</code></pre>

<p><strong>FourActivity</strong></p>

<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding;

public class FourActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityFourBinding binding = DataBindingUtil.setContentView(FourActivity.this, R.layout.activity_four);
        final Animal animal = new Animal();

        animal.field.set(&quot;cat&quot;);
        animal.age.set(2);
        binding.setAnimal(animal);

        final ObservableArrayList&lt;String&gt; list = new ObservableArrayList&lt;&gt;();
        list.add(&quot;dog&quot;);
        list.add(&quot;mouse&quot;);
        binding.setList(list);

        final ObservableArrayMap&lt;String, String&gt; map = new ObservableArrayMap&lt;&gt;();
        map.put(&quot;name&quot;,&quot;Tom&quot;);
        map.put(&quot;age&quot;,&quot;4&quot;);
        binding.setMap(map);

        binding.fourBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                animal.field.set(&quot;dog&quot;);
                animal.age.set(4);
                list.set(0,&quot;cat&quot;);
                list.set(1,&quot;dog&quot;);
                map.put(&quot;name&quot;,&quot;Sam&quot;);
                map.put(&quot;age&quot;,&quot;5&quot;);
            }
        });

    }
}
</code></pre>

<p>当Animal属性数据改变，list/map集合数据改变，会自动更新数据，我们不需要自己手动设置，省去了一个操作，让我们更专注于业务逻辑。</p>

<h3 id="toc_12">事件的绑定</h3>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
    绑定事件的格式有两种：    
    1、方法引用：直接用handle.Click或者handle::Click  推荐后者  
--&gt;  
&lt;Button  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&quot;@{user.name}&quot;  
    android:onClick=&quot;@{handle::Click}&quot;/&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
     2、监听绑定：使用()组，括号里面所填的是你为参数起的名字，这样你就可以在后面的括号进行引用  
        如果你监听的事件需要返回值，那么你的方法也要返回一个相同类型  
 --&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{()-&gt;handle.eventHandler(user)}&quot;  
     android:text=&quot;传入布局文件中的数据&quot; /&gt;  
  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(thisView)-&gt;handle.eventHandlerView(thisView,user)}&quot;  
     android:text=&quot;传入此View&quot; /&gt;  
 &lt;!--如果你需要为一个点击事件设置一个断言，那么使用void作为一个标志,表示什么也不做--&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.isVisible(v)?handle.doSomething():void}&quot;  
     android:text=&quot;判断是否为visible&quot; /&gt;  
  
 &lt;!--对于一些控件有自己专门的单击事件，需要创建下面的属性进行避免  
    SearchView    android:onSearchClick  
    ZoomControls  android:onZoomIn  
    ZoomControls  android:onZoomOut--&gt;  
 &lt;SearchView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.searchClick(v)}&quot;  
     android:onSearchClick=&quot;@{(v)-&gt;handle.onSearchClick(v)}&quot;&gt;  
  
 &lt;/SearchView&gt;  
</code></pre>

<p>实现监听方法，保证参数个数、类型、返回值都要保证和你使用set时监听一样，不然就出报错。</p>

<pre class="line-numbers"><code class="language-java">public void checkChanged(View view, boolean isCheck) {  
    System.out.println(&quot;checkChanged:&quot; + view + &quot;    &quot; + isCheck);  
}  
  
public boolean longClick(View view) {  
    System.out.println(&quot;longClick:&quot; + view);  
    return true;  
}  
</code></pre>

<p>可以直接在 xml 导入android.view.View.OnClickListener，并制定其点击事件。</p>

<pre class="line-numbers"><code class="language-java">&lt;variable
    name=&quot;clickListener&quot;
    type=&quot;android.view.View.OnClickListener&quot; /&gt;
...
  android:onClick=&quot;@{clickListener}&quot;
...
</code></pre>

<pre class="line-numbers"><code class="language-java">holder.binding.setClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               //do something
        });
</code></pre>

<h3 id="toc_13">表达式</h3>

<p>其实在xml文件中还是支持表达式的，比如说如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&#39;@{error ? &quot;error&quot; : &quot;ok&quot;}&#39;/&gt;
</code></pre>

<p>这是一个布尔值的使用。</p>

<p><strong>下面我们就来看看表达式支持的一下语法和不支持的语法支持的表达式：</strong></p>

<ul>
<li>Mathematical + - / * %<br/></li>
<li>String concatenation +<br/></li>
<li>Logical &amp;&amp; ||<br/></li>
<li>Binary &amp; | ^<br/></li>
<li>Unary + - ! ~<br/></li>
<li>Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt;<br/></li>
<li>Comparison == &gt; &lt; &gt;= &lt;=<br/></li>
<li>instanceof<br/></li>
<li>Grouping ()<br/></li>
<li>Literals - character, String, numeric, null<br/></li>
<li>Cast<br/></li>
<li>Method calls</li>
<li>Field access</li>
<li>Array access []</li>
<li>Ternary operator ?:</li>
</ul>

<p><strong>不支持的表达式：</strong></p>

<ul>
<li>this</li>
<li>super</li>
<li>new</li>
<li>Explicit generic invocation</li>
</ul>

<h3 id="toc_14">在布局中使用include</h3>

<p>如果你需要用到从xml传过来的数据需要去使用bind:user属性，这里的user是你定义的实体类名</p>

<pre class="line-numbers"><code class="language-markup">&lt;!--当你使用include的时候，你可以使用命名空间和属性中的变量名  
来将数据传送到另一个布局中去,值得注意的是当include的父节点为merge时将不支持--&gt;  
&lt;include  
    layout=&quot;@layout/detail_include&quot;  
    bind:user=&quot;@{user}&quot; /&gt; 
</code></pre>

<p>然后只需要在include布局里面声明之后便可以直接使用了。</p>

<h4 id="toc_15">示例</h4>

<p><strong>activity_five.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
 &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;TextView
                android:text=&quot;@string/app_name&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>toolbar.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout &gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
      &lt;variable
          name=&quot;content&quot;
          type=&quot;Content&quot;/&gt;
    &lt;/data&gt;

&lt;android.support.v7.widget.Toolbar
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/toolbar&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_height=&quot;56dp&quot;
    android:layout_width=&quot;match_parent&quot;
    app:title=&quot;@{content.title}&quot;
    app:subtitle=&quot;@{content.subTitle}&quot;
    android:background=&quot;@color/colorPrimary&quot;
    app:titleTextColor=&quot;@android:color/white&quot;
    app:subtitleTextColor=&quot;@android:color/white&quot; /&gt;
&lt;/layout&gt;
</code></pre>

<p>在activity_five.xml中的include属性中定义了一个id,同时又在toolbar.xml中的Toolbar标签中又定义了一个id,其作用是通过binding.toolbar.toolbar等同于Toolbar控件，可以方便做一些操作等(不加id，同样能将变量参数传进去)<br/>
FiveActivity中</p>

<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        ActivityFiveBinding binding =DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;); 
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>

<p><strong>Content</strong></p>

<pre class="line-numbers"><code class="language-java">public class Content extends BaseObservable {
    private String title;
    private String subTitle;

    public Content(String title, String subTitle) {
        this.title = title;
        this.subTitle = subTitle;
    }

    @Bindable public String getSubTitle() {
        return subTitle;
    }

    public void setSubTitle(String subTitle) {
        this.subTitle = subTitle;
        notifyPropertyChanged(BR.subTitle);
    }

    @Bindable public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
        notifyPropertyChanged(BR.title);
    }
}
</code></pre>

<h3 id="toc_16">带id的控件的赋值方式</h3>

<p>对于xml文件中控件的赋值，其实也是可以在java文件中，用java来实现的。我就以最上面那个简单的小例子来说，假如给一个TextView设置的id如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:id=&quot;@+id/name&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    /&gt;
</code></pre>

<p>在Activity中这样赋值：</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    binding.name.setText(&quot;非著名程序员&quot;);
}
</code></pre>

<h3 id="toc_17">在布局中使用ViewStub</h3>

<pre class="line-numbers"><code class="language-java">/** 
 * 为ViewStub设置监听，当显示的时候为它绑定数据，因为当不显示的ViewStub会在视图中消失 
 */  
vs = (ViewStub) findViewById(R.id.viewstub);  
vs.setOnInflateListener(new ViewStub.OnInflateListener() {  
    @Override  
    public void onInflate(ViewStub stub, View inflated) {  
        ViewstubBinding viewstubBinding = ViewstubBinding.bind(inflated);  
        Info info = new Info();  
        info.setInfo(&quot;Andly Info&quot;);  
        viewstubBinding.setInfo(info);  
        Drawable d = getResources().getDrawable(R.mipmap.ic_launcher);  
        viewstubBinding.setDrawable(d);  
    }  
});  
  
public void toggleViewStub(View view) {  
    vs.inflate();  
}  
</code></pre>

<h3 id="toc_18">在布局中使用RecycleView控件</h3>

<h4 id="toc_19">1、添加RecycleView控件</h4>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
    这里使用到了自定义属性，因为RecycleView里面有setAdapter方法，所以这里可以直接用app:adapter  
--&gt;  
&lt;android.support.v7.widget.RecyclerView  
    android:id=&quot;@+id/rv&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    app:adapter=&quot;@{adapter}&quot; /&gt;  
</code></pre>

<h4 id="toc_20">2、为RecycleView定义适配器</h4>

<pre class="line-numbers"><code class="language-java">@Override  
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  
    ViewDataBinding viewDataBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), layoutId, parent, false);  
    return new ViewHolder(viewDataBinding);  
}  
@Override  
public void onBindViewHolder(ViewHolder holder, int position) {  
    holder.binding.setVariable(variable, list.get(position));  
    holder.binding.executePendingBindings();  
    //当然这里你也可以为其设置点击如：  
    //holder.binding.getRoot.setOnclickListener()  
}  
@Override  
public int getItemCount() {  
    return list.size();  
}  
  
class ViewHolder extends RecyclerView.ViewHolder {  
    ViewDataBinding binding;  
  
    public ViewHolder(ViewDataBinding binding) {  
        super(binding.getRoot());  
        this.binding = binding;  
    }  
}  
</code></pre>

<h4 id="toc_21">3、为RecycleView设置Adapter</h4>

<pre class="line-numbers"><code class="language-java">//这里注意的是一定要是BR.dataInfo不能是其它的常数  
MyAdapter adapter = new MyAdapter(list, R.layout.rv_item, BR.dataInfo);  
binding.setAdapter(adapter);  
binding.rv.setLayoutManager(new LinearLayoutManager(this));
</code></pre>

<p>这样就大功告成，然而在很多情况我们都需要去对每个Item进行处理，如显示网络图片等等，这里我们就需要使用数据绑定自定义属性的功能，看代码</p>

<pre class="line-numbers"><code class="language-markup">&lt;ImageView  
    android:layout_width=&quot;150dp&quot;  
    android:layout_height=&quot;90dp&quot;  
    app:imageError=&quot;@{@drawable/android}&quot;  
    app:imagePath=&quot;@{dataInfo.imageUrl}&quot; /&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-java">//当你在一个方法只需要一个参数的时候可以使用@BindingAdapter(&quot;imageUrlStr&quot;)，加上之后就可以在布局文件中直接使用imageUrlStr  
//运行之后就会调用loadImage方法  
@BindingAdapter(&quot;imageUrlStr&quot;)  
public static void loadImage(ImageView iv, String url) {  
    Glide.with(iv.getContext()).load(url).into(iv);//这里使用Glide库  
}  
  
//上面是为loadImage传入一个参数，当传入两个或多个参数的时候应使用@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
//这个的ImageView自定义了两个属性一个是imagePath传入的是url,一个是imageError为Drawable  
@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
public static void downloadImage(ImageView iv, String url, Drawable error) {  
    Glide.with(iv.getContext()).load(url).error(error).into(iv);  
}  
</code></pre>

<p>上面的方法使用的是静态方法，如果你不想使用静态方法你需要重写一个数据绑定组件类去实现DataBindingComponent</p>

<pre class="line-numbers"><code class="language-java">public class MyComponent implements android.databinding.DataBindingComponent {  
    private Utils utils;  
    @Override  
    public Utils getUtils() {  
        if (utils == null) {  
            utils = new Utils();  
        }  
        return utils;  
    }  
}  
</code></pre>

<p>然后你需要在Activity为其进行设置</p>

<pre class="line-numbers"><code class="language-java">//第一种方式  
DataBindingUtil.setDefaultComponent(new MyComponent());  
//第二种方式  
ActivityMyListViewBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_my_list_view,new MyComponent());  
//第三种方式  
DataBindingUtil.bind(root,new MyComponent());  
</code></pre>

<p>最后有个不起眼的小功能，就是当使用数据绑定的时候在预览界面不能看到显示的内容，这时你可以为你的控件设置默认显示内容<code>android:text=&quot;@{placeName,default=PLACEHOLDER}&quot;</code></p>

<h5 id="toc_22">示例</h5>

<p><strong>activity_five.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
        &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;android.support.v7.widget.RecyclerView
                android:id=&quot;@+id/recycler&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>recycler_item.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;str&quot;
            type=&quot;String&quot;/&gt;
    &lt;/data&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:text=&quot;@{str}&quot;
            android:gravity=&quot;center_vertical&quot;
            android:textColor=&quot;@android:color/black&quot;
            android:textSize=&quot;16sp&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;48dp&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>FiveActivity</strong></p>

<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {

    private ActivityFiveBinding binding;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        binding = DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        initToolbar();
        initRecyclerView();
    }

    private void initRecyclerView() {
        LinearLayoutManager manager = new LinearLayoutManager(FiveActivity.this);
        binding.recycler.setLayoutManager(manager);
        binding.recycler.setHasFixedSize(true);
        MyAdapter adapter = new MyAdapter(getApplicationContext());
        binding.recycler.setAdapter(adapter);
    }

    private void initToolbar() {
        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;);
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>

<p><strong>MyAdapter</strong></p>

<pre class="line-numbers"><code class="language-java">public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {

    private Context mContext;
    String[] datas;

    public MyAdapter(Context context) {
        mContext = context;
        datas = context.getResources().getStringArray(R.array.item_list);
    }

    @Override
    public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        RecyclerItemBinding binding = DataBindingUtil.inflate(LayoutInflater.from(mContext), R.layout.recycler_item, parent, false);
        return new MyViewHolder(binding);
    }

    @Override
    public void onBindViewHolder(MyAdapter.MyViewHolder holder, int position) {
        String name = datas[position];
        holder.getBinding().setVariable(www.zhang.com.databinding.BR.str,name);
        //holder.getBinding().setStr(name); //两者都可以

        //executePendingBindings()方法说明
        // When a variable or observable changes, the binding will be scheduled to change before the next frame. 
        // There are times, however, when binding must be executed immediately. 
        // To force execution, use the executePendingBindings() method.
        holder.getBinding().executePendingBindings();//此方法必须执行在UI线程，当绑定的数据修改时更新视图（不知道翻译的准不准）
    }

    @Override
    public int getItemCount() {
        return datas.length;
    }

    public class MyViewHolder extends RecyclerView.ViewHolder {
        private RecyclerItemBinding binding;

        public MyViewHolder(ViewDataBinding binding) {
            super(binding.getRoot());
            this.binding = (RecyclerItemBinding) binding;
        }

        public RecyclerItemBinding getBinding() {
            return binding;
        }

        public void setBinding(RecyclerItemBinding binding) {
            this.binding = binding;
        }
    }
}
</code></pre>

<h3 id="toc_23">@BindingAdapter</h3>

<p>@BindingAdapter用于修饰方法。<br/><br/>
一些属性需要定制绑定逻辑，一个用@BindingAdapter修饰的静态方法可以自定义属性的setter操作。<br/><br/>
android自身实现了大量的Adapter，你可以在项目module的android.databinding.adapters包下找到这些代码。</p>

<pre class="line-numbers"><code class="language-java">public class CardViewBindingAdapter {
    @BindingAdapter(&quot;contentPadding&quot;)
    public static void setContentPadding(CardView view, int padding) {
        view.setContentPadding(padding, padding, padding, padding);
    }
}
</code></pre>

<p><strong>方法内的参数可以设置多个，参数的传递在布局文件中使用自定义命名空间的属性传入。</strong></p>

<ul>
<li>1、默认的你的自定义的命名空间，在匹配时会被忽略。</li>
</ul>

<pre class="line-numbers"><code class="language-text">@BindingAdapter(&quot;contentPadding&quot;)
</code></pre>

<ul>
<li>2、允许重写android的命名空间。</li>
</ul>

<pre class="line-numbers"><code class="language-text"> @BindingAdapter(&quot;android:contentPadding&quot;)
</code></pre>

<p><code>app:contentPadding</code>与<code>android:contentPadding</code>处理行为可以不一样。<br/>
<code>app:contentPadding</code>与<code>custom:contentPadding</code>处理行为是一致的。（仅android是特殊的命名空间）。</p>

<h4 id="toc_24">示例</h4>

<pre class="line-numbers"><code class="language-java">@BindingAdapter({&quot;imageUrl&quot;, &quot;type&quot;, &quot;position&quot;, &quot;debrisfly&quot;, &quot;width&quot;, &quot;height&quot;})
public static void setImageUrl(SimpleDraweeView view, String url, int type, int position, boolean debrisfly, int width, int height) {
    if (url == null) {
        url = &quot;&quot;;
    }
    Uri uri = null;
    switch (type) {
        case 1:
            uri = Util.parse7(url, BocaiApplication.getInstance());
            break;
        case 2:
            uri = Util.parse2(url, BocaiApplication.getInstance());
            break;
        case 3:
            uri = Util.parse3(url, BocaiApplication.getInstance());
            break;

        case 8:
            uri = Util.parse(url, BocaiApplication.getInstance());
            break;
        case 10:
            uri = Util.parseUrlBy230(url, BocaiApplication.getInstance());
            break;
    }
    ControllerListener controllerListener = new BaseControllerListener&lt;ImageInfo&gt;() {
        @Override
        public void onFinalImageSet(
                String id,
                @Nullable ImageInfo imageInfo,
                @Nullable Animatable anim) {
            if (imageInfo == null) {
                return;
            }
            if (anim != null) {
                anim.start();
            }
        }

        @Override
        public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {
        }

        @Override
        public void onFailure(String id, Throwable throwable) {
        }
    };

    DraweeController controller = Fresco.newDraweeControllerBuilder()
            .setControllerListener(controllerListener)
            .setUri(uri)
            .setOldController(view.getController())
            // other setters
            .build();
    view.setController(controller);
    debrisflys(debrisfly, position,view,width,height);
}
</code></pre>

<p>需要注意，当你创建的适配器属性与系统默认的产生冲突时，你的自定义适配器将会覆盖掉系统原先定义的注解，这将会产生一些意外的问题。<br/>
假设需要对下面接口，做适配。</p>

<pre class="line-numbers"><code class="language-java">public interface ILogAction{
      void login();
      void logout();
}
</code></pre>

<p>则需要一个方法一个接口，这么做的原因是避免<code>login()</code>的修改影响到<code>logout()</code>。所以根据业务需要，可能需要排列组合适配这两个接口。</p>

<blockquote>
<p>1、适配 login<br/>
2、适配 logout<br/>
3、适配 login + logout</p>
</blockquote>

<h3 id="toc_25">@BindingBuildInfo</h3>

<pre class="line-numbers"><code class="language-java">@BindingBuildInfo(
buildId=&quot;3fefc6ba-1e95-4dcf-8ffa-278fe0f449bd&quot;,
modulePackage=&quot;com.ipudong.library&quot;,
sdkRoot=&quot;/Users/robert/Library/Android/sdk&quot;,
layoutInfoDir=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug&quot;,
exportClassListTo=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug/_generated.txt&quot;,
isLibrary=true,
minSdk=14,
enableDebugLogs=false,
printEncodedError=true
)
public class DataBindingInfo {}
</code></pre>

<p>在SOURCE阶段会自动生成DataBindingInfo.class，并标记注解如上。</p>

<h3 id="toc_26">@BindingConversion</h3>

<blockquote>
<p>Annotate methods that are used to automatically convert from the expression type to the value used in the setter.<br/><br/>
有时候会遇到类型不匹配的问题，比如<code>R.color.white</code>是<code>int</code>，但是通过Data Binding赋值给<code>android:background</code>属性后，需要把<code>int</code>转换为<code>ColorDrawable</code>。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">@BindingConversion
public static Drawable convertColorToDrawable(int drawable) {
  return new ColorDrawable(drawable);
}
</code></pre>

<h3 id="toc_27">@BindingMethod &amp;&amp; @BindingMethods</h3>

<blockquote>
<p>Used within an BindingMethods annotation to describe a renaming of an attribute to the setter used to set that attribute.Used to enumerate attribute-to-setter renaming.</p>
</blockquote>

<p><strong>@BindingMethods用于修饰类。</strong></p>

<p>一些属性虽然拥有setters但是并不与名字相匹配，这些方法的属性可以通过 @BindingMethod &amp;&amp; @BindingMethods 注释 setters。</p>

<pre class="line-numbers"><code class="language-java">@BindingMethods({
       @BindingMethod(type = &quot;android.widget.ImageView&quot;,
                      attribute = &quot;android:tint&quot;,
                      method = &quot;setImageTintList&quot;),
})
</code></pre>

<p>开发人员不太可能需要重命名 setters ，因为android框架属性已经实现了这一部分。<br/><br/>
事件的默认值是带有<code>AttrChanged</code>的属性名称。在上面的例子中，默认值是<code>android:textAttrChanged</code>，即使它没有提供。<br/><br/>
事件属性用于通知数据绑定系统值已更改。开发人员通常会创建一个<code>BindingAdapter</code>来分配事件。比如：  </p>

<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>

<p>如同<code>BindingAdapters</code>一样， <code>InverseBindingAdapter</code>方法 也可以将 <code>DataBindingComponent</code>作为第一个参数，可以是具有从<code>DataBindingComponent</code>检索的实例的实例方法。<br/><br/>
<code>InverseBindingListener</code>非常有用。  </p>

<p><a href="https://developer.android.com/reference/android/databinding/InverseBindingListener.html">参考 InverseBindingListener</a></p>

<h3 id="toc_28">@InverseBindingMethod</h3>

<p><code>InverseBindingMethod</code>用于标识如何监听对<code>View</code>属性的更改以及要调用的<code>getter</code>方法。<code>InverseBindingMethod</code> 应该与<code>InverseBindingMethods</code>的部分方法相关联。  </p>

<pre class="line-numbers"><code class="language-java">@InverseBindingMethods({@InverseBindingMethod(
     type = android.widget.TextView.class,
     attribute = &quot;android:text&quot;,
     event = &quot;android:textAttrChanged&quot;,
     method = &quot;getText&quot;)})
 public class MyTextViewBindingAdapters { ... }
</code></pre>

<p>@InverseBindingMethods中的属性method 是可选的。</p>

<blockquote>
<p>如果其没有提供， 属性名称会查找如下几种可能性：方法名称，前缀为is或者get的方法名称。 如属性android:text, 数据绑定框架会在TextView中搜索public CharSequence getText() 方法。</p>
</blockquote>

<p>@InverseBindingMethods中的属性event是可选的。</p>

<blockquote>
<p>如果其没有提供，默认会使用属性名+AttrChanged后缀。如属性android:text, 默认的事件名称android:textAttrChanged。</p>
</blockquote>

<p>这个事件也需要配置相关的<code>@BindingAdapter</code>，如下：</p>

<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>

<h3 id="toc_29">@InverseBindingMethods</h3>

<blockquote>
<p>用于枚举属性，<code>getter</code>和事件关联。</p>
</blockquote>

<h3 id="toc_30">@Untaggable</h3>

<p>Data Binding相关的jar包由四部分组成，</p>

<ol>
<li>baseLibrary-2.1.0-rc1.jar<br/>
    作为运行时类库被打进APK中；</li>
<li>DataBinderPlugin（gradle plugin）<br/>
    在编译期使用，利用gradle-api（之前叫transform-api，1.5生，2.0改名）处理xml文件，生成DataBindingInfo.java；</li>
<li>compiler-2.1.0-rc1.jar<br/>
    在编译器使用，入口类继承自AbstractProcessor，用于处理注解，并生成Binding类，DataBindingCompoent.java，DataBinderMapper.java类；</li>
<li>compilerCommon-2.1.0-rc1.jar<br/>
    被DataBinderPlugin和compiler-2.1.0-rc1.jar所依赖</li>
</ol>

<h3 id="toc_31">改变监听</h3>

<p><code>addOnPropertyChangedCallback： Model</code>属性改变时回调发生 <br/>
<code>OnRebindCallback: view</code>发生改变重复绑定时触发</p>

<pre class="line-numbers"><code class="language-java">mModel.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() {
    @Override
    public void onPropertyChanged(Observable observable, int i) {
        if (i == BR.name) {
            Toast.makeText(TwoWayActivity.this, &quot;name changed&quot;,
                    Toast.LENGTH_SHORT).show();
        } else if (i == BR.password) {
            Toast.makeText(TwoWayActivity.this, &quot;password changed&quot;,
                    Toast.LENGTH_SHORT).show();
        }
    }
});
</code></pre>

<h3 id="toc_32">Component</h3>

<p>通过<code>DataBindingUtil.setDefaultComponent</code>来设置不同环境下不同的<code>Component</code>， <br/>
设置之后就可以使用该<code>Component</code>提供的<code>Adapter</code>方法，默认不设置是全局使用，可以理解为作用域。</p>

<pre class="line-numbers"><code class="language-java">public interface TestableAdapter {
    @BindingAdapter(&quot;android:src&quot;)
    void setImageUrl(ImageView imageView, String url);
}

public interface DataBindingComponent {
    TestableAdapter getTestableAdapter();
}

DataBindingUtil.setDefaultComponent(myComponent); 
 ‐ or ‐
binding = MyLayoutBinding.inflate(layoutInflater, myComponent);
</code></pre>

<h2 id="toc_33">相关编译流程</h2>

<h3 id="toc_34">STEP1 资源处理</h3>

<p><code>aapt</code>或者<code>gradle</code>执行时，都会触发资源处理。在资源处理过程中，<code>DataBinding</code>都会扫描一遍现有的资源，生成不包含<code>&lt;layout&gt;</code>的<code>data-binding-layout-out</code>以及<code>DataBinding</code>所需要的<code>data-binding-info</code>；</p>

<h3 id="toc_35">STEP2 DataBindingInfo.class生成</h3>

<p>在完成资源处理后，<code>aapt</code>或者<code>gradle-api</code>都会去执行<code>DataBindingInfo.class</code>生成操作，把相关的信息写入<code>DataBindingInfo.class</code>的@BindingBuildInfo注解中；</p>

<h3 id="toc_36">STEP3 监听到注解变化</h3>

<p>生成<code>@BindingBuildInfo</code>注解，或者code中发现有新的注解写入，<code>AbstractProcessor</code>注解处理器就开始执行注解处理。<code>DataBinding</code>中有一个<code>ProcessDataBinding.jav</code>a类专门来处理<code>DataBinding</code>相关的注解；</p>

<h3 id="toc_37">STEP4 ProcessDataBinding处理注解，生成bin</h3>

<p><code>ProcessDataBinding</code>中处理注解永远会按顺执行3步，<code>ProcessMethodAdapter</code>，<code>ProcessExpressions</code>，<code>ProcessBindable</code>。每次执行都会从磁盘反序列化对应的bin文件，然后往bin中写入新的，完成后再序列化到磁盘；</p>

<h3 id="toc_38">STEP5 生成最终产物</h3>

<p>执行<code>ProcessMethodAdapter</code>生成<code>DataBindingComponents.class</code>；执行<code>ProcessExpressions</code>生成<code>ViewDataBinding.class</code>子类（ActivityDetail2Binding.class），并触发<code>DataBindingMapper.class</code>更新；执行<code>ProcessBindable</code>生成<code>BR.class</code>，并触发<code>DataBindingMapper.class</code>更新。</p>

<h2 id="toc_39">注意：</h2>

<p>不允许使用混合类型</p>

<pre class="line-numbers"><code class="language-java">&lt;!--值得注意的是  
    android:background=&quot;@{boo?@color/red:@drawable/background}&quot;  
    这么写将会发生错误，因为在BindingConversion默认实现为：  
    @BindingConversion  
    public static ColorDrawable convertColorToDrawable(int color) {  
            return new ColorDrawable(color);  
        }  
--&gt;  
&lt;ImageView  
    android:layout_width=&quot;100dp&quot;  
    android:layout_height=&quot;100dp&quot;  
    android:layout_marginTop=&quot;20dp&quot;  
    android:background=&quot;@{boo?@color/red:@color/green}&quot; /&gt;  
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870279.html">
                
                  <h1>Android-getViewTreeObserver()</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>我们知道在<code>oncreate</code>中<code>View.getWidth</code>和<code>View.getHeight</code>无法获得一个view的高度和宽度，这是因为View组件布局要在<code>onResume</code>回调后完成。所以现在需要使用<code>getViewTreeObserver().addOnGlobalLayoutListener()</code>来获得宽度或者高度。这是获得一个view的宽度和高度的方法之一。</p>

<h2 id="toc_1">OnGlobalLayoutListener</h2>

<p><code>OnGlobalLayoutListener</code> 是<code>ViewTreeObserver</code>的内部类，当一个视图树的布局发生改变时，可以被<code>ViewTreeObserver</code>监听到，这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。<code>ViewTreeObserver</code>不能直接实例化，而是通过<code>getViewTreeObserver()</code>获得。</p>

<h2 id="toc_2">其他</h2>

<p>除了<code>OnGlobalLayoutListener</code> ，<code>ViewTreeObserver</code>还有如下内部类：</p>

<h3 id="toc_3">interface <code>ViewTreeObserver.OnGlobalFocusChangeListener</code></h3>

<p>当在一个视图树中的焦点状态发生改变时，所要调用的回调函数的接口类</p>

<h3 id="toc_4">interface <code>ViewTreeObserver.OnGlobalLayoutListener</code></h3>

<p>当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类</p>

<h3 id="toc_5">interface <code>ViewTreeObserver.OnPreDrawListener</code></h3>

<p>当一个视图树将要绘制时，所要调用的回调函数的接口类</p>

<h3 id="toc_6">interface <code>ViewTreeObserver.OnScrollChangedListener</code></h3>

<p>当一个视图树中的一些组件发生滚动时，所要调用的回调函数的接口类</p>

<h3 id="toc_7">interface <code>ViewTreeObserver.OnTouchModeChangeListener</code></h3>

<p>当一个视图树的触摸模式发生改变时，所要调用的回调函数的接口类</p>

<h2 id="toc_8">实例</h2>

<p>其中，我们可以利用<code>OnGlobalLayoutListener</code>来获得一个视图的真实高度。</p>

<pre class="line-numbers"><code class="language-java">int mHeaderViewHeight;  
mHeaderView.getViewTreeObserver().addOnGlobalLayoutListener(  
    new OnGlobalLayoutListener() {  
    @Override  
    public void onGlobalLayout() {  
                                                                                                                                                                                                                                        m    HeaderViewHeight = mHeaderView.getHeight();  
    getViewTreeObserver().removeGlobalOnLayoutListener(this);  
    }  
});
</code></pre>

<p><strong>但是需要注意的是OnGlobalLayoutListener可能会被多次触发，因此在得到了高度之后，要将OnGlobalLayoutListener注销掉。另外mHeaderViewHeight和mHeaderView都需要写在当前java文件类（比如Activity）的成员变量中。不能直接在onCreate中定义否则会编译不通过：</strong></p>

<p><code>Cannot refer to a non-final variable sHeight inside an inner class defined in a different method</code></p>

<p>有时候需要在<code>onCreate</code>方法中知道某个View组件的宽度和高度等信息，而直接调用View组件的<code>getWidth()</code>、<code>getHeight()</code>、<code>getMeasuredWidth()</code>、<code>getMeasuredHeight()</code>、<code>getTop()</code>、<code>getLeft()</code>等方法是无法获取到真实值的，只会得到0。这是因为View组件布局要在onResume回调后完成。下面提供实现方法，onGlobalLayout回调会在view布局完成时自动调用:</p>

<pre class="line-numbers"><code class="language-java">// This listener is used to get the final width of the GridView and then calculate the  
// number of columns and the width of each column. The width of each column is variable  
// as the GridView has stretchMode=columnWidth. The column width is used to set the height  
// of each view so we get nice square thumbnails.  
mGridView.getViewTreeObserver().addOnGlobalLayoutListener( //view 布局完成时调用，每次view改变时都会调用  
    new ViewTreeObserver.OnGlobalLayoutListener() {  
    @Override  
    public void onGlobalLayout() {  
        if (mAdapter.getNumColumns() == 0) {  
            final int numColumns = (int) Math.floor(mGridView.getWidth() / (mImageThumbSize + mImageThumbSpacing));  
            if (numColumns &gt; 0) {  
                final int columnWidth = (mGridView.getWidth() / numColumns) - mImageThumbSpacing;  
                mAdapter.setNumColumns(numColumns);   //设置 列数  
                mAdapter.setItemHeight(columnWidth);  //设置 高度  
            }  
        } 
    }  
});
</code></pre>

<p><strong>在gridview布局完成后，根据girdview的宽和高设置adapter列数和每个item高度</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_13.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_15.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16145671673295.html">多态</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
