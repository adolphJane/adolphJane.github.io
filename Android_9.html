<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870161.html">
                
                  <h1>Android-SpannableString设置复合文本</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>TextView通常用来显示普通文本，但是有时候需要对其中某些文本进行样式、事件方面的设置。 Android系统通过SpannableString类来对指定文本进行相关处理，具体有以下功能：</p>

<ul>
<li><code>BackgroundColorSpan</code> 背景色 </li>
<li><code>ClickableSpan</code> 文本可点击，有点击事件</li>
<li><code>ForegroundColorSpan</code> 文本颜色（前景色）</li>
<li><code>MaskFilterSpan</code> 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)</li>
<li><code>MetricAffectingSpan</code> 父类，一般不用</li>
<li><code>RasterizerSpan</code> 光栅效果</li>
<li><code>StrikethroughSpan</code> 删除线（中划线）</li>
<li><code>SuggestionSpan</code> 相当于占位符</li>
<li><code>UnderlineSpan</code> 下划线</li>
<li><code>AbsoluteSizeSpan</code> 绝对大小（文本字体）</li>
<li><code>DynamicDrawableSpan</code> 设置图片，基于文本基线或底部对齐。</li>
<li><code>ImageSpan</code> 图片</li>
<li><code>RelativeSizeSpan</code> 相对大小（文本字体）</li>
<li><code>ReplacementSpan</code> 父类，一般不用</li>
<li><code>ScaleXSpan</code> 基于x轴缩放</li>
<li><code>StyleSpan</code> 字体样式：粗体、斜体等</li>
<li><code>SubscriptSpan</code> 下标（数学公式会用到）</li>
<li><code>SuperscriptSpan</code> 上标（数学公式会用到）</li>
<li><code>TextAppearanceSpan</code> 文本外貌（包括字体、大小、样式和颜色）</li>
<li><code>TypefaceSpan</code> 文本字体</li>
<li><code>URLSpan</code> 文本超链接</li>
</ul>

<h2 id="toc_0">一、BackgroundColorSpan 背景色</h2>

<pre class="line-numbers"><code class="language-java">SpannableString spanText = new SpannableString(&quot;萝卜白菜的博客 -- http://orgcent.com&quot;);
spanText.setSpan(new BackgroundColorSpan(Color.GREEN), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText); 
</code></pre>

<h2 id="toc_1">二、ClickableSpan 文本可点击，有点击事件</h2>

<h2 id="toc_2">三、ForegroundColorSpan 文本颜色（前景色）</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;萝卜白菜的博客 -- http://orgcent.com&quot;);
spanText.setSpan(new ForegroundColorSpan(Color.BLUE), 6, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<h2 id="toc_3">四、MaskFilterSpan 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;MaskFilterSpan -- http://orgcent.com&quot;);
int length = spanText.length();
//模糊(BlurMaskFilter)
MaskFilterSpan maskFilterSpan = new MaskFilterSpan(new BlurMaskFilter(3, Blur.OUTER));
spanText.setSpan(maskFilterSpan, 0, length - 10, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
//浮雕(EmbossMaskFilter)
maskFilterSpan = new MaskFilterSpan(new EmbossMaskFilter(new float[]{1,1,3}, 1.5f, 8, 3));
spanText.setSpan(maskFilterSpan, length - 10, length, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<p><strong>PS:从上图看，浮雕效果不明显。把字体设置大点后可以看得清晰些。需要其他效果可以继承MaskFilter来自定义。</strong></p>

<h2 id="toc_4">六、RasterizerSpan 光栅效果</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;StrikethroughSpan&quot;);
spanText.setSpan(new StrikethroughSpan(), 0, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<p><strong>PS:暂不清楚，效果不明显。</strong></p>

<h2 id="toc_5">七、StrikethroughSpan 删除线（中划线）</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;StrikethroughSpan&quot;);
spanText.setSpan(new StrikethroughSpan(), 0, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<h2 id="toc_6">八、SuggestionSpan</h2>

<p>相当于占位符，一般用在EditText输入框中。当双击此文本时，会弹出提示框选择一些建议（推荐的）文字，选中的文本将替换此占位符。在输入法上用的较多。</p>

<p><strong>PS：API 14新增，暂无示例。</strong></p>

<h2 id="toc_7">九、UnderlineSpan 下划线</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;UnderlineSpan&quot;);
spanText.setSpan(new UnderlineSpan(), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<h2 id="toc_8">十、AbsoluteSizeSpan 绝对大小（文本字体）</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;AbsoluteSizeSpan&quot;);
spanText.setSpan(new AbsoluteSizeSpan(20, true), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<p><strong>PS:把字体大小设置大点，效果硬朗。</strong></p>

<h2 id="toc_9">十一、DynamicDrawableSpan 设置图片，基于文本基线或底部对齐。</h2>

<pre class="line-numbers"><code class="language-java">DynamicDrawableSpan drawableSpan = new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BASELINE) {
    @Override    
    public Drawable getDrawable() {        
        Drawable d = getResources().getDrawable(R.drawable.ic_launcher);
        d.setBounds(0, 0, 50, 50);
        return d;
    }
};
DynamicDrawableSpan drawableSpan2 = new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BOTTOM) {
    @Override
    public Drawable getDrawable() {
        Drawable d = getResources().getDrawable(R.drawable.ic_launcher);
        d.setBounds(0, 0, 50, 50);
        return d;
    }
};
spanText.setSpan(drawableSpan, 3, 4, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
spanText.setSpan(drawableSpan2, 7, 8, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<p><strong>PS:左边图片基于基线对齐，右边图片基于底部对齐</strong></p>

<h2 id="toc_10">十二、ImageSpan 图片</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;ImageSpan&quot;);
Drawable d = getResources().getDrawable(R.drawable.ic_launcher);
d.setBounds(0, 0, 50, 50);
spanText.setSpan(new ImageSpan(d), 3, 4, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<p><strong>PS:和DynamicDrawableSpan差别不大</strong></p>

<h2 id="toc_11">十三、RelativeSizeSpan 相对大小（文本字体）</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;RelativeSizeSpan&quot;);
//参数proportion:比例大小
spanText.setSpan(new RelativeSizeSpan(2.5f), 3, 4,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<p><strong>PS:相对大小的比例是基于当前文本字体大小</strong></p>

<h2 id="toc_12">十四、ScaleXSpan 基于x轴缩放</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;ScaleXSpan -- 萝卜白菜的博客&quot;);
//参数proportion:比例大小
spanText.setSpan(new ScaleXSpan(3.8f), 3, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<h2 id="toc_13">十五、StyleSpan 字体样式：粗体、斜体等</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;StyleSpan -- 萝卜白菜的博客&quot;);
//Typeface.BOLD_ITALIC:粗体+斜体
spanText.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 3, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<h2 id="toc_14">十六、SubscriptSpan 下标（数学公式会用到）</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;SubscriptSpan -- 萝卜白菜的博客&quot;);
spanText.setSpan(new SubscriptSpan(), 6, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<h2 id="toc_15">十七、SuperscriptSpan 上标（数学公式会用到）</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;SuperscriptSpan -- 萝卜白菜的博客&quot;);
spanText.setSpan(new SuperscriptSpan(), 6, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<h2 id="toc_16">十八、TextAppearanceSpan 文本外貌（包括字体、大小、样式和颜色）</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;TextAppearanceSpan -- 萝卜白菜的博客&quot;);
//若需自定义TextAppearance，可以在系统样式上进行修改
spanText.setSpan(new TextAppearanceSpan(this, android.R.style.TextAppearance_Medium),6, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>

<p><strong>PS:系统还提供了相关值TextAppearance_Small, TextAppearance_Large等。如有需要可在以上样式基础上修改。</strong></p>

<h2 id="toc_17">十九、TypefaceSpan 文本字体</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;TypefaceSpan -- 萝卜白菜的博客&quot;);
//若需使用自定义字体，可能要重写类
TypefaceSpanspanText.setSpan(new TypefaceSpan(&quot;monospace&quot;), 3, 10,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);;
</code></pre>

<h2 id="toc_18">二十、URLSpan 文本超链接</h2>

<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;URLSpan -- 萝卜白菜的博客&quot;);
spanText.setSpan(new URLSpan(&quot;http://orgcent.com&quot;), 10, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
//让URLSpan可以点击
mTVText.setMovementMethod(new LinkMovementMethod());
</code></pre>

<p><a href="https://juejin.im/post/59bf91476fb9a00a583178d3">https://juejin.im/post/59bf91476fb9a00a583178d3</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870123.html">
                
                  <h1>Android-RxJava详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android开发已经进行了蛮久的一段时间了，基础部分都掌握的差不多了。所以需要跟进时代需要学习一直以来很火的RxJava来提升自己的开发效率以及代码的规范。</p>

<h2 id="toc_1">RxJava 到底是什么</h2>

<p>一个词：异步。</p>

<blockquote>
<p>a library for composing asynchronous and event-based programs using observable sequences for the Java VM解释：一个对于构成使用的Java虚拟机观察序列<code>异步</code>和基于事件的程序库</p>
</blockquote>

<p>RxJava 是一个非常著名的开源库，是ReactiveX响应式编程框架的一种Java实现，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。<br/><br/>
RxJava 是一个开源项目，地址： <a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a> <br/>
RxAndroid，用于 Android 开发，添加了 Android 用的接口。地址：  <a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a><br/><br/>
其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。</p>

<h2 id="toc_2">RxJava 好在哪</h2>

<p>换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / ... ？』</p>

<p>一个词：简洁。</p>

<p>异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 <code>AsyncTask</code> 和<code>Handler</code> ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。</p>

<p>假设有这样一个需求：界面上有一个自定义的视图 <code>imageCollectorView</code> ，它的作用是显示多张图片，并能使用 <code>addImage(Bitmap)</code> 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 <code>File[] folders</code> 中每个目录下的 png 图片都加载出来并显示在 <code>imageCollectorView</code> 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：</p>

<pre class="line-numbers"><code class="language-java">new Thread() {
    @Override
    public void run() {
        super.run();
        for (File folder : folders) {
            File[] files = folder.listFiles();
            for (File file : files) {
                if (file.getName().endsWith(&quot;.png&quot;)) {
                    final Bitmap bitmap = getBitmapFromFile(file);
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            imageCollectorView.addImage(bitmap);
                        }
                    });
                }
            }
        }
    }
}.start();
</code></pre>

<p>而如果使用 RxJava ，实现方式是这样的：</p>

<pre class="line-numbers"><code class="language-java">Observable.from(folders)
    .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() {
        @Override
        public Observable&lt;File&gt; call(File file) {
            return Observable.from(file.listFiles());
        }
    })
    .filter(new Func1&lt;File, Boolean&gt;() {
        @Override
        public Boolean call(File file) {
            return file.getName().endsWith(&quot;.png&quot;);
        }
    })
    .map(new Func1&lt;File, Bitmap&gt;() {
        @Override
        public Bitmap call(File file) {
            return getBitmapFromFile(file);
        }
    })
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Action1&lt;Bitmap&gt;() {
        @Override
        public void call(Bitmap bitmap) {
            imageCollectorView.addImage(bitmap);
        }
});
</code></pre>

<p>虽然代码看起来更多了，但观察一下你会发现， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显（试想如果还要求只选取前 10 张图片，常规方式要怎么办？如果有更多这样那样的要求呢？再试想，在这一大堆需求实现完两个月之后需要改功能，当你翻回这里看到自己当初写下的那一片迷之缩进，你能保证自己将迅速看懂，而不是对着代码重新捋一遍思路？）。</p>

<p>另外，如果你的 IDE 是 Android Studio ，其实每次打开某个 Java 文件的时候，你会看到被自动 Lambda 化的预览，这将让你更加清晰地看到程序逻辑：</p>

<pre class="line-numbers"><code class="language-java">Observable.from(folders)
    .flatMap((Func1) (folder) -&gt; { Observable.from(file.listFiles()) })
    .filter((Func1) (file) -&gt; { file.getName().endsWith(&quot;.png&quot;) })
    .map((Func1) (file) -&gt; { getBitmapFromFile(file) })
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe((Action1) (bitmap) -&gt; { imageCollectorView.addImage(bitmap) });
</code></pre>

<h2 id="toc_3">基本概念</h2>

<p><strong>Observable</strong>：发射源，英文释义“可观察的”，在观察者模式中称为“被观察者”或“可观察对象”；<br/><br/>
<strong>Observer</strong>：接收源，英文释义“观察者”，没错！就是观察者模式中的“观察者”，可接收Observable、Subject发射的数据；<br/><br/>
<strong>Subject</strong>：Subject是一个比较特殊的对象，既可充当发射源，也可充当接收源，为避免初学者被混淆，本章将不对Subject做过多的解释和使用，重点放在Observable和Observer上，先把最基本方法的使用学会，后面再学其他的都不是什么问题；<br/><br/>
<strong>Subscriber</strong>：“订阅者”，也是接收源，那它跟Observer有什么区别呢？Subscriber实现了Observer接口，比Observer多了一个最重要的方法<code>unsubscribe( )</code>，用来取消订阅，当你不再想接收数据了，可以调用<code>unsubscribe( )</code>方法停止接收，Observer 在 <code>subscribe()</code> 过程中,最终也会被转换成 Subscriber 对象，一般情况下，建议使用Subscriber作为接收源；<br/><br/>
<strong>Subscription</strong> ：Observable调用<code>subscribe( )</code>方法返回的对象，同样有<code>unsubscribe( )</code>方法，可以用来取消订阅事件；<br/><br/>
<strong>Action0</strong>：RxJava中的一个接口，它只有一个无参call（）方法，且无返回值，同样还有Action1，Action2...Action9等，Action1封装了含有 1 个参的call（）方法，即call（T t），Action2封装了含有 2 个参数的call方法，即call（T1 t1，T2 t2），以此类推；<br/><br/>
<strong>Func0</strong>：与Action0非常相似，也有call（）方法，但是它是有返回值的，同样也有Func0、Func1...Func9;  </p>

<h2 id="toc_4">API 介绍和原理简析</h2>

<h3 id="toc_5">RxJava 的观察者模式</h3>

<p>RxJava 有四个基本概念：<code>Observable</code><br/>
 (可观察者，即被观察者)、 <code>Observer</code> (观察者)、 <code>subscribe</code> (订阅)、事件。<code>Observable</code> 和 <code>Observer</code> 通过 <code>subscribe()</code> 方法实现订阅关系，从而 <code>Observable</code> 可以在需要的时候发出事件来通知 <code>Observer</code>。</p>

<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 <code>onNext()</code> （相当于 <code>onClick()</code> / <code>onEvent()</code>）之外，还定义了两个特殊的事件：<code>onCompleted()</code> 和 <code>onError()</code>。</p>

<ul>
<li><code>onCompleted()</code>: 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 <code>onNext()</code> 发出时，需要触发 <code>onCompleted()</code>方法作为标志。</li>
<li><code>onError()</code>: 事件队列异常。在事件处理过程中出异常时，<code>onError()</code>会被触发，同时队列自动终止，不允许再有事件发出。</li>
<li>在一个正确运行的事件序列中, <code>onCompleted()</code>和<code>onError()</code> 有且只有一个，并且是事件序列中的最后一个。需要注意的是，<code>onCompleted()</code> 和 <code>onError()</code> 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。<br/>
RxJava 的观察者模式大致如下图：</li>
</ul>

<p><figure><img src="media/15561207870123/15713053119606.jpg" alt=""/></figure></p>

<h3 id="toc_6">基本实现</h3>

<p>基于以上的概念， RxJava 的基本实现主要有三点：</p>

<h4 id="toc_7">创建 Observer</h4>

<p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 <code>Observer</code> 接口的实现方式：</p>

<pre class="line-numbers"><code class="language-java">Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }

    @Override
    public void onCompleted() {
        Log.d(tag, &quot;Completed!&quot;);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(tag, &quot;Error!&quot;);
    }
};
</code></pre>

<p>除了 <code>Observer</code> 接口之外，RxJava 还内置了一个实现了 <code>Observer</code> 的抽象类：<code>Subscriber</code>。 <code>Subscriber</code> 对 <code>Observer</code> 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>

<pre class="line-numbers"><code class="language-java">Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }

    @Override
    public void onCompleted() {
        Log.d(tag, &quot;Completed!&quot;);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(tag, &quot;Error!&quot;);
    }
};
</code></pre>

<p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，<code>Observer</code> 也总是会先被转换成一个 <code>Subscriber</code><br/>
 再使用。所以如果你只想使用基本功能，选择 <code>Observer</code> 和 <code>Subscriber</code> 是完全一样的。它们的区别对于使用者来说主要有两点：</p>

<ul>
<li><code>onStart()</code>: 这是 <code>Subscriber</code> 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， <code>onStart()</code>就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使<code>doOnSubscribe()</code>方法，具体可以在后面的文中看到。</li>
<li><code>unsubscribe()</code>: 这是 <code>Subscriber</code> 所实现的另一个接口 <code>Subscription</code>的方法，用于取消订阅。在这个方法被调用后，<code>Subscriber</code>将不再接收事件。一般在这个方法调用前，可以使用 <code>isUnsubscribed()</code> 先判断一下状态。 <code>unsubscribe()</code> 这个方法很重要，因为在 <code>subscribe()</code> 之后， <code>Observable</code> 会持有 <code>Subscriber</code>的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 <code>onPause()</code><code>onStop()</code> 等方法中）调用 <code>unsubscribe()</code> 来解除引用关系，以避免内存泄露的发生。</li>
</ul>

<h4 id="toc_8">创建 Observable</h4>

<p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 <code>create()</code> 方法来创建一个 Observable ，并为它定义事件触发规则：</p>

<pre class="line-numbers"><code class="language-java">Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {
        subscriber.onNext(&quot;Hello&quot;);
        subscriber.onNext(&quot;Hi&quot;);
        subscriber.onNext(&quot;Aloha&quot;);
        subscriber.onCompleted();
    }
});
</code></pre>

<p>可以看到，这里传入了一个 <code>OnSubscribe</code> 对象作为参数。<code>OnSubscribe</code> 会被存储在返回的 <code>Observable</code> 对象中，它的作用相当于一个计划表，当 <code>Observable</code> 被订阅的时候，<code>OnSubscribe</code> 的 <code>call()</code> 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者<code>Subscriber</code> 将会被调用三次 <code>onNext()</code> 和一次 <code>onCompleted()</code>）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>

<ul>
<li><p><code>create()</code> 方法是 RxJava 最基本的创造事件序列的方法。</p></li>
<li><p><code>just(T...)</code>: 将传入的参数依次发送出来。</p></li>
</ul>

<pre class="line-numbers"><code class="language-java">Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
</code></pre>

<ul>
<li><code>from(T[])</code>/ <code>from(Iterable&lt;? extends T&gt;)</code>: 将传入的数组或 <code>Iterable</code> 拆分成具体对象后，依次发送出来。</li>
</ul>

<pre class="line-numbers"><code class="language-java">String[] words = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;};
Observable observable = Observable.from(words);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
</code></pre>

<ul>
<li><code>defer( )</code>:有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable：</li>
</ul>

<pre class="line-numbers"><code class="language-java">deferObservable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() {
  @Override
  //注意此处的call方法没有Subscriber参数
  public Observable&lt;String&gt; call() {
      return Observable.just(&quot;deferObservable&quot;);
  }});
</code></pre>

<ul>
<li><code>interval( )</code>:创建一个按固定时间间隔发射整数序列的Observable，可用作定时器：</li>
</ul>

<pre class="line-numbers"><code class="language-java">intervalObservable = Observable.interval(1, TimeUnit.SECONDS);//每隔一秒发送一次
</code></pre>

<ul>
<li><code>range( )</code>:创建一个发射特定整数序列的Observable，第一个参数为起始值，第二个为发送的个数，如果为0则不发送，负数则抛异常：</li>
</ul>

<pre class="line-numbers"><code class="language-java">rangeObservable = Observable.range(10, 5);//将发送整数10，11，12，13，14
</code></pre>

<ul>
<li><code>timer( )</code>:创建一个Observable，它在一个给定的延迟后发射一个特殊的值，等同于Android中Handler的postDelay( )方法：</li>
</ul>

<pre class="line-numbers"><code class="language-java">timeObservable = Observable.timer(3, TimeUnit.SECONDS);  //3秒后发射一个值
</code></pre>

<ul>
<li><code>repeat( )</code>:创建一个重复发射特定数据的Observable:</li>
</ul>

<pre class="line-numbers"><code class="language-java">repeatObservable = Observable.just(&quot;repeatObservable&quot;).repeat(3);//重复发射3次
</code></pre>

<h4 id="toc_9">Subscribe (订阅)</h4>

<p>创建了 <code>Observable</code> 和 <code>Observer</code> 之后，再用 <code>subscribe()</code> 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p>

<pre class="line-numbers"><code class="language-java">observable.subscribe(observer);
// 或者：
observable.subscribe(subscriber);
</code></pre>

<p><code>subscriber()</code> 做了3件事：</p>

<ul>
<li>调用 <code>Subscriber.onStart()</code>。这个方法在前面已经介绍过，是一个可选的准备方法。</li>
<li>调用 <code>Observable</code> 中的 <code>OnSubscribe.call(Subscriber)</code>。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， <code>Observable</code> 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 <code>subscribe()</code>方法执行的时候。</li>
<li>将传入的 <code>Subscriber</code> 作为 <code>Subscription</code> 返回。这是为了方便 <code>unsubscribe()</code>.</li>
</ul>

<p>整个过程中对象间的关系如下图：</p>

<p><figure><img src="media/15561207870123/15713053244741.jpg" alt=""/></figure></p>

<p>或者可以看动图：</p>

<p><figure><img src="media/15561207870123/20171011150768262032561.gif" alt=""/></figure></p>

<p>除了 <code>subscribe(Observer)</code> 和<code>subscribe(Subscriber)</code> ，<code>subscribe()</code> 还支持不完整定义的回调，RxJava 会自动根据定义创建出 <code>Subscriber</code> 。形式如下：</p>

<pre class="line-numbers"><code class="language-java">Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() {
    // onNext()
    @Override
    public void call(String s) {
        Log.d(tag, s);
    }
};
Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() {
    // onError()
    @Override
    public void call(Throwable throwable) {
        // Error handling
    }
};
Action0 onCompletedAction = new Action0() {
    // onCompleted()
    @Override
    public void call() {
        Log.d(tag, &quot;completed&quot;);
    }
};

// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);
// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);
// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
</code></pre>

<p>简单解释一下这段代码中出现的 <code>Action1</code> 和 <code>Action0</code>。 <code>Action0</code> 是 RxJava 的一个接口，它只有一个方法 <code>call()</code>，这个方法是无参无返回值的；由于 <code>onCompleted()</code> 方法也是无参无返回值的，因此 <code>Action0</code> 可以被当成一个包装对象，将 <code>onCompleted()</code> 的内容打包起来将自己作为一个参数传入 <code>subscribe()</code> 以实现不完整定义的回调。这样其实也可以看做将 <code>onCompleted()</code> 方法作为参数传进了 <code>subscribe()</code>，相当于其他某些语言中的『闭包』。 <br/><br/>
<code>Action1</code> 也是一个接口，它同样只有一个方法 <code>call(T param)</code>，这个方法也无返回值，但有一个参数；与 <code>Action0</code> 同理，由于 <code>onNext(T obj)</code> 和 <code>onError(Throwable error)</code> 也是单参数无返回值的，因此 <code>Action1</code>可以将 <code>onNext(obj)</code> 和 <code>onError(error)</code> 打包起来传入 <code>subscribe()</code> 以实现不完整定义的回调。事实上，虽然 <code>Action0</code> 和 <code>Action1</code>在 API 中使用最广泛，但 RxJava 是提供了多个 <code>ActionX</code> 形式的接口 (例如 <code>Action2</code>, <code>Action3</code>) 的，它们可以被用以包装不同的无返回值的方法。  </p>

<h4 id="toc_10">Subscriptions(订阅者)</h4>

<p>当调用<code>Observable.subscribe()</code>，会返回一个<code>Subscription</code>对象。这个对象代表了被观察者和订阅者之间的联系。</p>

<pre class="line-numbers"><code class="language-java">Subscription subscription = Observable.just(&quot;Hello, World!&quot;)
.subscribe(s -&gt; System.out.println(s)); 
</code></pre>

<p>你可以在后面使用这个<code>Subscription</code>对象来操作被观察者和订阅者之间的联系.</p>

<pre class="line-numbers"><code class="language-java">subscription.unsubscribe();//接触订阅关系
System.out.println(&quot;Unsubscribed=&quot; + subscription.isUnsubscribed());
// Outputs &quot;Unsubscribed=true&quot; 
</code></pre>

<p>RxJava的另外一个好处就是它处理<code>unsubscribing</code>的时候，会停止整个调用链。如果你使用了一串很复杂的操作符，调用<code>unsubscribe</code>将会在他当前执行的地方终止。不需要做任何额外的工作！</p>

<h4 id="toc_11">场景示例</h4>

<h5 id="toc_12">打印字符串数组</h5>

<p>将字符串数组 <code>names</code> 中的所有字符串依次打印出来：</p>

<pre class="line-numbers"><code class="language-java">String[] names = ...;
Observable.from(names)
    .subscribe(new Action1&lt;String&gt;() {
        @Override
        public void call(String name) {
            Log.d(tag, name);
        }
});
</code></pre>

<h5 id="toc_13">由 id 取得图片并显示</h5>

<p>由指定的一个 drawable 文件 id <code>drawableRes</code> 取得图片，并显示在 <code>ImageView</code> 中，并在出现异常的时候打印 Toast 报错：</p>

<pre class="line-numbers"><code class="language-java">int drawableRes = ...;
ImageView imageView = ...;
Observable.create(new OnSubscribe&lt;Drawable&gt;() {
    @Override
    public void call(Subscriber&lt;? super Drawable&gt; subscriber) {
        Drawable drawable = getTheme().getDrawable(drawableRes));
        subscriber.onNext(drawable);
        subscriber.onCompleted();
    }
}).subscribe(new Observer&lt;Drawable&gt;() {
    @Override
    public void onNext(Drawable drawable) {
        imageView.setImageDrawable(drawable);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
        Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();
    }
});
</code></pre>

<p>正如上面两个例子这样，创建出 <code>Observable</code> 和 <code>Subscriber</code> ，再用 <code>subscribe()</code> 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。<br/>
然而，在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： <code>Scheduler</code> 。</p>

<h3 id="toc_14">线程控制 —— Scheduler (一)</h3>

<p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 <code>subscribe()</code>，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 <code>Scheduler</code> （调度器）。</p>

<h4 id="toc_15">Scheduler 的 API (一)</h4>

<p>在RxJava 中，<code>Scheduler</code> ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 <code>Scheduler</code> ，它们已经适合大多数的使用场景：</p>

<ul>
<li><code>Schedulers.trampoline( )</code>:当其它排队的任务完成后，在当前线程排队开始执行。</li>
<li><code>Schedulers.from(executor)</code>:使用指定的Executor作为调度器。</li>
<li><code>Schedulers.immediate()</code>: 直接在当前线程运行，相当于不指定线程。这是默认的 <code>Scheduler</code>。</li>
<li><code>Schedulers.newThread()</code>: 总是启用新线程，并在新线程执行操作。</li>
<li><code>Schedulers.io()</code>: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 <code>Scheduler</code>。行为模式和 <code>newThread()</code> 差不多，区别在于 <code>io()</code>的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 <code>io()</code> 比 <code>newThread()</code> 更有效率。不要把计算工作放在 <code>io()</code> 中，可以避免创建不必要的线程。</li>
<li><code>Schedulers.computation()</code>: 计算所使用的 <code>Scheduler</code>。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 <code>Scheduler</code>使用的固定的线程池，默认线程数等于处理器的数量。不要把 I/O 操作放在 <code>computation()</code> 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li>另外， Android 还有一个专用的 <code>AndroidSchedulers.mainThread()</code>，它指定的操作将在 Android 主线程运行。</li>
</ul>

<p>有了这几个 <code>Scheduler</code> ，就可以使用 <code>subscribeOn()</code> 和 <code>observeOn()</code> 两个方法来对线程进行控制了。 <code>subscribeOn()</code>: 指定 <code>subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程。或者叫做事件产生的线程。<code>observeOn()</code>: 指定 <code>Subscriber</code> 所运行在的线程。或者叫做事件消费的线程。<br/>
文字叙述总归难理解，上代码：</p>

<pre class="line-numbers"><code class="language-java">Observable.just(1, 2, 3, 4)
    .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
    .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
    .subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer number) {
            Log.d(tag, &quot;number:&quot; + number);
        }
});
</code></pre>

<p>上面这段代码中，由于 <code>subscribeOn(Schedulers.io())</code> 的指定，被创建的事件的内容 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 将会在 IO 线程发出；而由于 <code>observeOn(AndroidScheculers.mainThread()</code>) 的指定，因此 <code>subscriber</code> 数字的打印将发生在主线程 。事实上，这种在 <code>subscribe()</code> 之前写上两句 <code>subscribeOn(Scheduler.io())</code> 和 <code>observeOn(AndroidSchedulers.mainThread())</code> 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。<br/>
而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句：</p>

<pre class="line-numbers"><code class="language-java">int drawableRes = ...;
ImageView imageView = ...;
Observable.create(new OnSubscribe&lt;Drawable&gt;() {
    @Override
    public void call(Subscriber&lt;? super Drawable&gt; subscriber) {
        Drawable drawable = getTheme().getDrawable(drawableRes));
        subscriber.onNext(drawable);
        subscriber.onCompleted();
    }
})
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
.subscribe(new Observer&lt;Drawable&gt;() {
    @Override
    public void onNext(Drawable drawable) {
        imageView.setImageDrawable(drawable);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
        Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();
    }
});
</code></pre>

<p>那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p>

<h4 id="toc_16">Scheduler 的原理 (一)</h4>

<p>RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 <code>subscribe()</code> 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。</p>

<h3 id="toc_17">变换</h3>

<p>终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。</p>

<p>RxJava 提供了<em>对事件序列进行变换</em>的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。</p>

<h4 id="toc_18">API</h4>

<p>首先看一个 <code>map()</code> 的例一：</p>

<pre class="line-numbers"><code class="language-java">Observable.just(&quot;images/logo.png&quot;) // 输入类型 String
    .map(new Func1&lt;String, Bitmap&gt;() {
        @Override
        public Bitmap call(String filePath) { // 参数类型 String
            return getBitmapFromPath(filePath); // 返回类型 Bitmap
        }
    })
    .subscribe(new Action1&lt;Bitmap&gt;() {
        @Override
        public void call(Bitmap bitmap) { // 参数类型 Bitmap
            showBitmap(bitmap);
        }
    });
</code></pre>

<p>这里出现了一个叫做 <code>Func1</code> 的类。它和 <code>Action1</code> 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 <code>Func1</code> 和 <code>Action</code> 的区别在于， <code>Func1</code> 包装的是有返回值的方法。另外，和 <code>ActionX</code> 一样， <code>FuncX</code> 也有多个，用于不同参数个数的方法。<code>FuncX</code>和 <code>ActionX</code>的区别在 <code>FuncX</code>包装的是有返回值的方法。<br/><br/>
可以看到，<code>map()</code>方法将参数中的 <code>String</code>对象转换成一个 <code>Bitmap</code> 对象后返回，而在经过<code>map()</code>方法后，事件的参数类型也由 <code>String</code>转为了 <code>Bitmap</code>。这种直接变换对象并返回的，是最常见的也最容易理解的变换,将对象转换成另一个对象发射出去，应用范围非常广，如数据的转换，数据的预处理等。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换：  </p>

<p>例二：对数据进行预处理，最后得到理想型数据。实际开发过程中，从后台接口获取到的数据也许不符合我们想要的，这时候可以在获取过程中对得到的数据进行预处理（结合Retrofit）。</p>

<pre class="line-numbers"><code class="language-java">Observable.just(&quot;12345678&quot;).map(new Func1&lt;String, String&gt;() {
  @Override
  public String call(String s) {
      return s.substring(0,4);//只要前四位
  }})
.subscribe(new Action1&lt;String&gt;() {
  @Override
  public void call(String s) {
      Log.i(&quot;mytag&quot;,s);
  }});
</code></pre>

<ul>
<li><code>map()</code>: 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 <code>map()</code> 的示意图：</li>
</ul>

<p><figure><img src="media/15561207870123/15713053605523.jpg" alt=""/></figure></p>

<ul>
<li><code>flatMap()</code>: 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</li>
</ul>

<pre class="line-numbers"><code class="language-java">Student[] students = ...;
Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {
    @Override
    public void onNext(String name) {
        Log.d(tag, name);
    }
    ...
};
Observable.from(students)
    .map(new Func1&lt;Student, String&gt;() {
        @Override
        public String call(Student student) {
            return student.getName();
        }
    })
    .subscribe(subscriber);
</code></pre>

<p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：</p>

<pre class="line-numbers"><code class="language-java">Student[] students = ...;
Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() {
    @Override
    public void onNext(Student student) {
        List&lt;Course&gt; courses = student.getCourses();
        for (int i = 0; i &lt; courses.size(); i++) {
            Course course = courses.get(i);
            Log.d(tag, course.getName());
        }
    }
    ...
};
Observable.from(students)
    .subscribe(subscriber);
</code></pre>

<p>依然很简单。那么如果我不想在 <code>Subscriber</code> 中使用 for 循环，而是希望 <code>Subscriber</code> 中直接传入单个的 <code>Course</code> 对象呢（这对于代码复用很重要）？用 <code>map()</code> 显然是不行的，因为 <code>map()</code> 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？</p>

<p>这个时候，就需要用 <code>flatMap()</code> 了：</p>

<pre class="line-numbers"><code class="language-java">Student[] students = ...;
Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() {
    @Override
    public void onNext(Course course) {
        Log.d(tag, course.getName());
    }
    ...
};
Observable.from(students)
    .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() {
        @Override
        public Observable&lt;Course&gt; call(Student student) {
            return Observable.from(student.getCourses());
        }
    })
    .subscribe(subscriber);
</code></pre>

<p>从上面的代码可以看出， <code>flatMap()</code> 和 <code>map()</code> 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 <code>map()</code>不同的是， <code>flatMap()</code> 中返回的是个 <code>Observable</code> 对象，并且这个 <code>Observable</code> 对象并不是被直接发送到了 <code>Subscriber</code> 的回调方法中。 <code>flatMap()</code> 的原理是这样的：1. 使用传入的事件对象创建一个 <code>Observable</code> 对象；2. 并不发送这个 <code>Observable</code>, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 <code>Observable</code> 发送的事件，都被汇入同一个 <code>Observable</code> ，而这个 <code>Observable</code> 负责将这些事件统一交给 <code>Subscriber</code> 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 <code>Observable</code> 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 <code>flatMap()</code>所谓的 flat。<br/>
<code>flatMap()</code>示意图：</p>

<p><figure><img src="media/15561207870123/15713053760755.jpg" alt=""/></figure></p>

<p>扩展：由于可以在嵌套的 <code>Observable</code> 中添加异步代码， <code>flatMap()</code> 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）：</p>

<pre class="line-numbers"><code class="language-java">networkClient.token() // 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token
    .flatMap(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() {
        @Override
        public Observable&lt;Messages&gt; call(String token) {
            // 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表
            return networkClient.messages();
        }
    })
    .subscribe(new Action1&lt;Messages&gt;() {
        @Override
        public void call(Messages messages) {
            // 处理显示消息列表
            showMessages(messages);
        }
    });
</code></pre>

<p>传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 <code>flatMap()</code> ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。</p>

<ul>
<li><code>throttleFirst()</code>: 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器<code>RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber);</code>妈妈再也不怕我的用户手抖点开两个重复的界面啦。<br/>
此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。</li>
</ul>

<h4 id="toc_19">变换的原理：lift()</h4>

<p>这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： <code>lift(Operator)</code>。首先看一下 <code>lift()</code> 的内部实现（仅核心代码）：</p>

<pre class="line-numbers"><code class="language-java">// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) {
    return Observable.create(new OnSubscribe&lt;R&gt;() {
        @Override
        public void call(Subscriber subscriber) {
            Subscriber newSubscriber = operator.call(subscriber);
            newSubscriber.onStart();
            onSubscribe.call(newSubscriber);
        }
    });
}
</code></pre>

<p>这段代码很有意思：它生成了一个新的 <code>Observable</code> 并返回，而且创建新 <code>Observable</code> 所用的参数 <code>OnSubscribe</code> 的回调方法 <code>call()</code> 中的实现竟然看起来和前面讲过的 <code>Observable.subscribe()</code> 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 <code>onSubscribe.call(subscriber)</code> 中的 <code>onSubscribe</code> 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）</p>

<ul>
<li><code>subscribe()</code> 中这句话的 <code>onSubscribe</code> 指的是 <code>Observable</code> 中的 <code>onSubscribe</code> 对象，这个没有问题，但是 <code>lift()</code> 之后的情况就复杂了点。</li>
<li> 当含有 <code>lift()</code> 时： 
<ul>
<li>1.<code>lift()</code> 创建了一个 <code>Observable</code> 后，加上之前的原始 <code>Observable</code>，已经有两个 <code>Observable</code> 了； </li>
<li>2.而同样地，新 <code>Observable</code> 里的新 <code>OnSubscribe</code> 加上之前的原始 <code>Observable</code> 中的原始 <code>OnSubscribe</code>，也就有了两个 <code>OnSubscribe</code>； </li>
<li>3.当用户调用经过 <code>lift()</code> 后的 <code>Observable</code> 的 <code>subscribe()</code> 的时候，使用的是 <code>lift()</code> 所返回的新的 <code>Observable</code> ，于是它所触发的 <code>onSubscribe.call(subscriber)</code>，也是用的新 <code>Observable</code> 中的新 <code>OnSubscribe</code>，即在 <code>lift()</code> 中生成的那个 <code>OnSubscribe</code>； </li>
<li>4.而这个新 <code>OnSubscribe</code> 的 <code>call()</code> 方法中的 <code>onSubscribe</code> ，就是指的原始 <code>Observable</code> 中的原始 <code>OnSubscribe</code> ，在这个 <code>call()</code>方法里，新 <code>OnSubscribe</code> 利用 <code>operator.call(subscriber)</code> 生成了一个新的 <code>Subscriber</code>（<code>Operator</code> 就是在这里，通过自己的 <code>call()</code>方法将新 <code>Subscriber</code>和原始 <code>Subscriber</code> 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 <code>Subscriber</code> 向原始 <code>Observable</code> 进行订阅。 这样就实现了 <code>lift()</code>过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。</li>
</ul></li>
</ul>

<p>精简掉细节的话，也可以这么说：在 <code>Observable</code> 执行了 <code>lift(Operator)</code> 方法之后，会返回一个新的 <code>Observable</code>，这个新的 <code>Observable</code> 会像一个代理一样，负责接收原始的 <code>Observable</code> 发出的事件，并在处理后发送给 <code>Subscriber</code>。<br/><br/>
如果你更喜欢具象思维，可以看图：</p>

<p><figure><img src="media/15561207870123/15713053962421.jpg" alt=""/></figure></p>

<p>或者可以看动图：</p>

<p><figure><img src="media/15561207870123/20171011150768288754019.gif" alt=""/></figure></p>

<p>两次和多次的 <code>lift()</code> 同理，如下图：</p>

<p><figure><img src="media/15561207870123/15713054269632.jpg" alt=""/></figure></p>

<p>举一个具体的 <code>Operator</code> 的实现。下面这是一个将事件中的 <code>Integer</code> 对象转换成 <code>String</code> 的例子，仅供参考：</p>

<pre class="line-numbers"><code class="language-java">observable.lift(new Observable.Operator&lt;String, Integer&gt;() {
    @Override
    public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) {
        // 将事件序列中的 Integer 对象转换为 String 对象
        return new Subscriber&lt;Integer&gt;() {
            @Override
            public void onNext(Integer integer) {
                subscriber.onNext(&quot;&quot; + integer);
            }

            @Override
            public void onCompleted() {
                subscriber.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }
        };
    }
});
</code></pre>

<h4 id="toc_20">compose: 对 Observable 整体的变换</h4>

<p>除了 <code>lift()</code> 之外， <code>Observable</code> 还有一个变换方法叫做 <code>compose(Transformer)</code>。它和 <code>lift()</code> 的区别在于， <code>lift()</code> 是针对事件项和事件序列的，而 <code>compose()</code> 是针对 <code>Observable</code> 自身进行变换。举个例子，假设在程序中有多个 <code>Observable</code>，并且他们都需要应用一组相同的 <code>lift()</code> 变换。你可以这么写：</p>

<pre class="line-numbers"><code class="language-java">observable1
    .lift1()
    .lift2()
    .lift3()
    .lift4()
    .subscribe(subscriber1);
observable2
    .lift1()
    .lift2()
    .lift3()
    .lift4()
    .subscribe(subscriber2);
observable3
    .lift1()
    .lift2()
    .lift3()
    .lift4()
    .subscribe(subscriber3);
observable4
    .lift1()
    .lift2()
    .lift3()
    .lift4()
    .subscribe(subscriber1);
</code></pre>

<p>你觉得这样太不软件工程了，于是你改成了这样：</p>

<pre class="line-numbers"><code class="language-java">private Observable liftAll(Observable observable) {
    return observable
        .lift1()
        .lift2()
        .lift3()
        .lift4();
}
...
liftAll(observable1).subscribe(subscriber1);
liftAll(observable2).subscribe(subscriber2);
liftAll(observable3).subscribe(subscriber3);
liftAll(observable4).subscribe(subscriber4);
</code></pre>

<p>可读性、可维护性都提高了。可是 <code>Observable</code> 被一个方法包起来，这种方式对于 <code>Observale</code> 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 <code>compose()</code> 来解决了：</p>

<pre class="line-numbers"><code class="language-java">public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; {
    @Override
    public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) {
        return observable
            .lift1()
            .lift2()
            .lift3()
            .lift4();
    }
}
...
Transformer liftAll = new LiftAllTransformer();
observable1.compose(liftAll).subscribe(subscriber1);
observable2.compose(liftAll).subscribe(subscriber2);
observable3.compose(liftAll).subscribe(subscriber3);
observable4.compose(liftAll).subscribe(subscriber4);
</code></pre>

<p>像上面这样，使用 <code>compose()</code> 方法，<code>Observable</code> 可以利用传入的 <code>Transformer</code> 对象的 <code>call</code> 方法直接对自身进行处理，也就不必被包在方法的里面了。<code>compose()</code> 的原理比较简单，不附图喽。</p>

<h4 id="toc_21">Buffer：缓存</h4>

<p>可以设置缓存大小，缓存满后，以list的方式将数据发送出去；例：</p>

<pre class="line-numbers"><code class="language-java">Observable
.just(1,2,3)
.buffer(2)
.subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {  
    @Override  
    public void call(List&lt;Integer&gt; list) {      
        Log.i(&quot;mytag&quot;,&quot;size:&quot;+list.size());  
    }
});
</code></pre>

<p>运行打印结果如下：</p>

<pre class="line-numbers"><code class="language-text">11-02 20:49:58.370 23392-23392/? I/mytag: size:211-02 20:49:58.370 23392-23392/? I/mytag: size:1
</code></pre>

<p>在开发当中，个人经常将Buffer和Map一起使用，常发生在从后台取完数据，对一个List中的数据进行预处理后，再用Buffer缓存后一起发送，保证最后数据接收还是一个List，如下：</p>

<pre class="line-numbers"><code class="language-java">List&lt;School&gt; schoolList = new ArrayList&lt;&gt;();
Observable.from(schoolList).map(new Func1&lt;School, School&gt;() {  
    @Override  
    public School call(School school) {      
        school.setName(&quot;NB大学&quot;);  //将所有学校改名      
        return school;  
    }
}).buffer(schoolList.size())  //缓存起来，最后一起发送
.subscribe(new Action1&lt;List&lt;School&gt;&gt;() {  
    @Override  
    public void call(List&lt;School&gt; schools) {}
});
</code></pre>

<h4 id="toc_22">Take</h4>

<p>发射前n项数据，还是用上面的例子，假设不要改所有学校的名称了，就改前四个学校的名称：</p>

<pre class="line-numbers"><code class="language-java">Observable.from(schoolList).take(4).map(new Func1&lt;School, School&gt;() {  
    @Override  
    public School call(School school) {      
        school.setName(&quot;NB大学&quot;);      
        return school;  
    }}).buffer(4).subscribe(new Action1&lt;List&lt;School&gt;&gt;() {  
    @Override  
    public void call(List&lt;School&gt; schools) {}
});
</code></pre>

<h4 id="toc_23">Distinct</h4>

<p>去掉重复的项，比较好理解：</p>

<pre class="line-numbers"><code class="language-java">Observable.just(1, 2, 1, 1, 2, 3).distinct().subscribe(new Action1&lt;Integer&gt;() {          
    @Override          
    public void call(Integer item) {              
        System.out.println(&quot;Next: &quot; + item);          
    }      
});
</code></pre>

<p>输出</p>

<pre class="line-numbers"><code class="language-java">Next: 1Next: 2Next: 3
</code></pre>

<h4 id="toc_24">Filter：过滤</h4>

<p>通过谓词判断的项才会被发射，例如，发射小于4的数据：</p>

<pre class="line-numbers"><code class="language-java">Observable.just(1, 2, 3, 4, 5).filter(new Func1&lt;Integer, Boolean&gt;() {          
    @Override          
    public Boolean call(Integer item) {              
        return( item &lt; 4 );          
    }      
}).subscribe(new Action1&lt;Integer&gt;() {        
    @Override        
    public void call(Integer item) {              
        System.out.println(&quot;Next: &quot; + item);    
    }
});
</code></pre>

<p>输出：</p>

<pre class="line-numbers"><code class="language-java">Next: 1Next: 2Next: 3
</code></pre>

<h3 id="toc_25">线程控制：Scheduler (二)</h3>

<p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p>

<h4 id="toc_26">Scheduler 的 API (二)</h4>

<p>前面讲到了，可以利用 <code>subscribeOn()</code> 结合 <code>observeOn()</code> 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 <code>map()</code><code>flatMap()</code>等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</p>

<p>答案是：能。因为 <code>observeOn()</code> 指定的是 <code>Subscriber</code> 的线程，而这个 <code>Subscriber</code> 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）<code>subscribe()</code> 参数中的 <code>Subscriber</code> ，而是 <code>observeOn()</code> 执行时的当前 <code>Observable</code> 所对应的 <code>Subscriber</code> ，即它的直接下级 <code>Subscriber</code> 。换句话说，<code>observeOn()</code> 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 <code>observeOn()</code> 即可。上代码：</p>

<pre class="line-numbers"><code class="language-java">Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
    .subscribeOn(Schedulers.io())
    .observeOn(Schedulers.newThread())
    .map(mapOperator) // 新线程，由 observeOn() 指定
    .observeOn(Schedulers.io())
    .map(mapOperator2) // IO 线程，由 observeOn() 指定
    .observeOn(AndroidSchedulers.mainThread) 
    .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定
</code></pre>

<p>如上，通过 <code>observeOn()</code> 的多次调用，程序实现了线程的多次切换。<br/>
不过，不同于 <code>observeOn()</code> ， <code>subscribeOn()</code> 的位置放在哪里都可以，但它是只能调用一次的。<br/>
又有好事的（其实还是当初的我）问了：如果我非要调用多次 <code>subscribeOn()</code> 呢？会有什么效果？<br/>
这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。</p>

<h4 id="toc_27">Scheduler 的原理（二）</h4>

<p>其实， <code>subscribeOn()</code> 和 <code>observeOn()</code> 的内部实现，也是用的 <code>lift()</code>。具体看图（不同颜色的箭头表示不同的线程）：<br/>
<code>subscribeOn()</code> 原理图：</p>

<p><figure><img src="media/15561207870123/15713054408629.jpg" alt=""/></figure></p>

<p><code>observeOn()</code> 原理图：</p>

<p><figure><img src="media/15561207870123/15713054500040.jpg" alt=""/></figure></p>

<p>从图中可以看出，<code>subscribeOn()</code> 和 <code>observeOn()</code> 都做了线程切换的工作（图中的 &quot;schedule...&quot; 部位）。不同的是， <code>subscribeOn()</code>的线程切换发生在 <code>OnSubscribe</code> 中，即在它通知上一级 <code>OnSubscribe</code> 时，这时事件还没有开始发送，因此 <code>subscribeOn()</code> 的线程控制可以从事件发出的开端就造成影响；  而 <code>observeOn()</code> 的线程切换则发生在它内建的 <code>Subscriber</code> 中，即发生在它即将给下一级 <code>Subscriber</code> 发送事件时，因此 <code>observeOn()</code> 控制的是它后面的线程。</p>

<p>最后，我用一张图来解释当多个 <code>subscribeOn()</code> 和 <code>observeOn()</code> 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）：  </p>

<p><figure><img src="media/15561207870123/15713054782891.jpg" alt=""/></figure></p>

<p>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 <code>subscribeOn()</code> 影响，运行在红色线程；③和④处受第一个 <code>observeOn()</code> 的影响，运行在绿色线程；⑤处受第二个 <code>onserveOn()</code> 影响，运行在紫色线程；而第二个 <code>subscribeOn()</code> ，由于在通知过程中线程就被第一个 <code>subscribeOn()</code> 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 <code>subscribeOn()</code> 的时候，只有第一个 <code>subscribeOn()</code> 起作用。</p>

<h4 id="toc_28">延伸：doOnSubscribe()</h4>

<p>然而，虽然超过一个的 <code>subscribeOn()</code> 对事件处理的流程没有影响，但在流程之前却是可以利用的。</p>

<p>在前面讲 <code>Subscriber</code> 的时候，提到过 <code>Subscriber</code> 的 <code>onStart()</code> 可以用作流程开始前的初始化。然而 <code>onStart()</code> 由于在 <code>subscribe()</code> 发生时就被调用了，因此不能指定线程，而是只能执行在 <code>subscribe()</code> 被调用时的线程。这就导致如果 <code>onStart()</code> 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 <code>subscribe()</code> 将会在什么线程执行。</p>

<p>而与 <code>Subscriber.onStart()</code> 相对应的，有一个方法 <code>Observable.doOnSubscribe()</code> 。它和 <code>Subscriber.onStart()</code> 同样是在 <code>subscribe()</code> 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， <code>doOnSubscribe()</code> 执行在 <code>subscribe()</code> 发生的线程；而如果在 <code>doOnSubscribe()</code> 之后有 <code>subscribeOn()</code> 的话，它将执行在离它最近的 <code>subscribeOn()</code> 所指定的线程。</p>

<p>示例代码：</p>

<pre class="line-numbers"><code class="language-java">Observable.create(onSubscribe)
    .subscribeOn(Schedulers.io())
    .doOnSubscribe(new Action0() {
        @Override
        public void call() {
            progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行
        }
    })
    .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(subscriber);
</code></pre>

<p>如上，在 <code>doOnSubscribe()</code>的后面跟一个 <code>subscribeOn()</code> ，就能指定准备工作的线程了。</p>

<h2 id="toc_29">Subject</h2>

<p>关于Subject，官方文档的解释是这样的：Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。从官方解释中，我提取出三个要点：</p>

<ul>
<li>它可以充当Observable；</li>
<li>它可以充当Observer；</li>
<li>它是Observable和Observer之间的桥梁；</li>
</ul>

<p>接下来对这三个要点解释一下，但在解释之前，要先介绍一下Subject的种类， Subject是一个抽象类，不能通过new来实例化Subject，所以Subject有四个实现类，分别为AsyncSubject、BehaviorSubject、PublishSubject和ReplaySubject，每个实现类都有特定的“技能”，下面结合代码来介绍一下它们各自的“技能”。注意，所有的实现类都由<code>create()</code>方法实例化，无需new,所有的实现类调用<code>onCompleted()</code>或<code>onError()</code>,它的Observer将不再接收数据；</p>

<h2 id="toc_30">AsyncSubject</h2>

<p>Observer会接收AsyncSubject的<code>onComplete()</code>之前的最后一个数据，如果因异常而终止，AsyncSubject将不会释放任何数据，但是会向Observer传递一个异常通知。示例代码如下：  </p>

<pre class="line-numbers"><code class="language-java">AsyncSubject&lt;String&gt; asyncSubject = AsyncSubject.create();      asyncSubject.onNext(&quot;asyncSubject1&quot;);      
asyncSubject.onNext(&quot;asyncSubject2&quot;);      
asyncSubject.onNext(&quot;asyncSubject3&quot;);        
asyncSubject.onCompleted();      
asyncSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {              
        LogUtil.log(&quot;asyncSubject onCompleted&quot;);  //输出 asyncSubject onCompleted          
    }          
    @Override          
    public void onError(Throwable e) {              
        LogUtil.log(&quot;asyncSubject onError&quot;);  //不输出（异常才会输出）          
    }          
    @Override          
    public void onNext(String s) {              
        LogUtil.log(&quot;asyncSubject:&quot;+s);  //输出asyncSubject:asyncSubject3          
    }      
});
</code></pre>

<p>以上代码，Observer只会接收asyncSubject的onCompleted()被调用前的最后一个数据，即“asyncSubject3”，如果不调用onCompleted()，Subscriber将不接收任何数据。</p>

<h2 id="toc_31">BehaviorSubject</h2>

<p>Observer会接收到BehaviorSubject被订阅之前的最后一个数据，再接收其他发射过来的数据，如果BehaviorSubject被订阅之前没有发送任何数据，则会发送一个默认数据。（注意跟AsyncSubject的区别，AsyncSubject要手动调用onCompleted()，且它的Observer会接收到onCompleted()前发送的最后一个数据，之后不会再接收数据，而BehaviorSubject不需手动调用onCompleted()，它的Observer接收的是BehaviorSubject被订阅前发送的最后一个数据，两个的分界点不一样，且之后还会继续接收数据。）示例代码如下：</p>

<pre class="line-numbers"><code class="language-java">BehaviorSubject&lt;String&gt; behaviorSubject = BehaviorSubject.create(&quot;default&quot;);  behaviorSubject.onNext(&quot;behaviorSubject1&quot;);  
behaviorSubject.onNext(&quot;behaviorSubject2&quot;);      
behaviorSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {              
        LogUtil.log(&quot;behaviorSubject:complete&quot;);          
    }          
    @Override          
    public void onError(Throwable e) {              
        LogUtil.log(&quot;behaviorSubject:error&quot;);          
    }          
    @Override          
    public void onNext(String s) {              
        LogUtil.log(&quot;behaviorSubject:&quot;+s);          
    }
});      
behaviorSubject.onNext(&quot;behaviorSubject3&quot;);      
behaviorSubject.onNext(&quot;behaviorSubject4&quot;);
</code></pre>

<p>以上代码，Observer会接收到behaviorSubject2、behaviorSubject3、behaviorSubject4，如果在<code>behaviorSubject.subscribe()</code>之前不发送behaviorSubject1、behaviorSubject2，则Observer会先接收到default,再接收behaviorSubject3、behaviorSubject4。</p>

<h2 id="toc_32">PublishSubject</h2>

<p>PublishSubject比较容易理解，相对比其他Subject常用，它的Observer只会接收到PublishSubject被订阅之后发送的数据。示例代码如下：</p>

<pre class="line-numbers"><code class="language-java">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();  
publishSubject.onNext(&quot;publishSubject1&quot;);  
publishSubject.onNext(&quot;publishSubject2&quot;);  
publishSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {          }          
    @Override          
    public void onError(Throwable e) {          }          
    @Override          
    public void onNext(String s) {              
        LogUtil.log(&quot;publishSubject observer1:&quot;+s);          
    }      
});  
publishSubject.onNext(&quot;publishSubject3&quot;);  
publishSubject.onNext(&quot;publishSubject4&quot;);
</code></pre>

<p>以上代码，Observer只会接收到&quot;behaviorSubject3&quot;、&quot;behaviorSubject4&quot;。</p>

<h2 id="toc_33">ReplaySubject</h2>

<p>ReplaySubject会发射所有数据给观察者，无论它们是何时订阅的。也有其它版本的ReplaySubject，在重放缓存增长到一定大小的时候或过了一段时间后会丢弃旧的数据。示例代码如下：</p>

<pre class="line-numbers"><code class="language-java">ReplaySubject&lt;String&gt;replaySubject = ReplaySubject.create(); //创建默认初始缓存容量大小为16的ReplaySubject，当数据条目超过16会重新分配内存空间，使用这种方式，不论ReplaySubject何时被订阅，Observer都能接收到数据
//replaySubject = ReplaySubject.create(100);//创建指定初始缓存容量大小为100的ReplaySubject
//replaySubject = ReplaySubject.createWithSize(2);//只缓存订阅前最后发送的2条数据 
//replaySubject=ReplaySubject.createWithTime(1,TimeUnit.SECONDS,Schedulers.computation());  
//replaySubject被订阅前的前1秒内发送的数据才能被接收     
replaySubject.onNext(&quot;replaySubject:pre1&quot;);
replaySubject.onNext(&quot;replaySubject:pre2&quot;);
replaySubject.onNext(&quot;replaySubject:pre3&quot;);
replaySubject.subscribe(new Action1&lt;String&gt;() {      
    @Override      
    public void call(String s) {              
        LogUtil.log(&quot;replaySubject:&quot; + s);      
    }  
});
replaySubject.onNext(&quot;replaySubject:after1&quot;);
replaySubject.onNext(&quot;replaySubject:after2&quot;);
</code></pre>

<p>以上代码，由于情况比较多，注释也已解释的相当清楚，就不对输出结果一一表述了，有疑问的自行copy代码去测试一下。至此，四种Subject类型已经介绍完毕，但是需要注意，如果你把 Subject 当作一个 Subscriber 使用，不要从多个线程中调用它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。要避免此类问题，官方提出了“串行化”，你可以将 Subject 转换为一个 SerializedSubject ，类似于这样：<code>SerializedSubject&lt;String, Integer&gt; ser = new SerializedSubject(publishSubject);</code></p>

<h2 id="toc_34">Subject总结</h2>

<p>为什么说Subject既可充当Observable，又可充当Observer，是它们两个之间的桥梁呢？经过前面的例子，也许有些人已经大概理解了，不理解的且听我细细道来。首先，从理论上讲，Subject继承了Observable，又实现了Observer接口，所以说它既是Observable又是Observer，完全合理。从实际应用上讲，Subject也能实现Observable和Observer相同的功能，口说无凭，我们还是通过代码来证实比较有说服力。</p>

<h3 id="toc_35">创建Observable并发射数据：</h3>

<pre class="line-numbers"><code class="language-java">Observable.create(new Observable.OnSubscribe&lt;String&gt;() {          @Override          public void call(Subscriber&lt;? super String&gt; subscriber) {              subscriber.onNext(&quot;I&#39;m Observable&quot;);              subscriber.onCompleted();          }      });
</code></pre>

<p><em>用Subject实现为</em>：</p>

<pre class="line-numbers"><code class="language-java">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();publishSubject.onNext(&quot;as Observable&quot;);publishSubject.onCompleted();```

### 创建Observer订阅Observable并接收数据：

```java
mObservable.subscribe(new Observer&lt;String&gt;() {      
    @Override       
    public void onCompleted() {}      
    @Override      
    public void onError(Throwable e) {}      
    @Override      
    public void onNext(String s) {//接收数据      
    }
});
</code></pre>

<p><em>用Subject实现为</em>：</p>

<pre class="line-numbers"><code class="language-java">publishSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {}          
    @Override          
    public void onError(Throwable e) {}          
    @Override          
    public void onNext(String s) {}      
});
</code></pre>

<p>也许有人会问，不是说Subject也可以作为Observer，不能把Subject当作Observer传入subscribe()中吗？回答是：当然可以！就象这样：</p>

<pre class="line-numbers"><code class="language-java">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();
Observable.create(new Observable.OnSubscribe&lt;String&gt;() {      
    @Override      
    public void call(Subscriber&lt;? super String&gt; subscriber) {          
        subscriber.onNext(&quot;as Observer&quot;);           
        subscriber.onCompleted();      
    }
}).subscribe(publishSubject);
</code></pre>

<p>有没有发现问题？publishSubject没有重写onNext()方法啊，在哪接收的数据？这就是前面说的“桥梁”的问题了，尽管把Subject作为Observer传入<code>subscribe()</code>，但接收数据还是要通过Observer来接收，借用Subject来连接Observable和Observer，整体代码如下：</p>

<pre class="line-numbers"><code class="language-java">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();   
Observable.create(new Observable.OnSubscribe&lt;String&gt;() {          
    @Override          
    public void call(Subscriber&lt;? super String&gt; subscriber) {              
        subscriber.onNext(&quot;as Bridge&quot;);              
        subscriber.onCompleted();          
    }      
}).subscribe(publishSubject);      
publishSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {}          
    @Override          
    public void onError(Throwable e) {}          
    @Override          
    public void onNext(String s) {              
        LogUtil.log(&quot;subject:&quot;+s); //接收到 as Bridge          
    }      
});
</code></pre>

<h2 id="toc_36">RxJava 的适用场景和使用方式</h2>

<h3 id="toc_37">与 Retrofit 的结合</h3>

<p>Retrofit 除了提供了传统的 <code>Callback</code> 形式的 API，还有 RxJava 版本的 <code>Observable</code> 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。<br/>
以获取一个 <code>User</code>对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求：</p>

<pre class="line-numbers"><code class="language-java">@GET(&quot;/user&quot;)
public void getUser(@Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);
</code></pre>

<p>在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应：</p>

<pre class="line-numbers"><code class="language-java">getUser(userId, new Callback&lt;User&gt;() {
    @Override
    public void success(User user) {
        userView.setUser(user);
    }

    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
};
</code></pre>

<p>而使用 RxJava 形式的 API，定义同样的请求是这样的：</p>

<pre class="line-numbers"><code class="language-java">@GET(&quot;/user&quot;)
public Observable&lt;User&gt; getUser(@Query(&quot;userId&quot;) String userId);
</code></pre>

<p>使用的时候是这样的：</p>

<pre class="line-numbers"><code class="language-java">getUser(userId)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;User&gt;() {
        @Override
        public void onNext(User user) {
            userView.setUser(user);
        }

        @Override
        public void onCompleted() {
        }

        @Override
        public void onError(Throwable error) {
            // Error handling
            ...
        }
    });
</code></pre>

<p>看到区别了吗？</p>

<p>当 RxJava 形式的时候，Retrofit 把请求封装进 <code>Observable</code> ，在请求结束后调用 <code>onNext()</code> 或在请求失败后调用 <code>onError()</code>。</p>

<p>对比来看， <code>Callback</code> 形式和 <code>Observable</code> 形式长得不太一样，但本质都差不多，而且在细节上 <code>Observable</code> 形式似乎还比 <code>Callback</code>形式要差点。那 Retrofit 为什么还要提供 RxJava 的支持呢？</p>

<p>因为它好用啊！从这个例子看不出来是因为这只是最简单的情况。而一旦情景复杂起来， <code>Callback</code> 形式马上就会开始让人头疼。比如：<br/>
假设这么一种情况：你的程序取到的 <code>User</code> 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 <code>Callback</code>方式大概可以这么写：</p>

<pre class="line-numbers"><code class="language-java">getUser(userId, new Callback&lt;User&gt;() {
    @Override
    public void success(User user) {
        processUser(user); // 尝试修正 User 数据
        userView.setUser(user);
    }

    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
};
</code></pre>

<p>有问题吗？</p>

<p>很简便，但不要这样做。为什么？因为这样做会影响性能。数据库的操作很重，一次读写操作花费 10~20ms 是很常见的，这样的耗时很容易造成界面的卡顿。所以通常情况下，如果可以的话一定要避免在主线程中处理数据库。所以为了提升性能，这段代码可以优化一下：</p>

<pre class="line-numbers"><code class="language-java">getUser(userId, new Callback&lt;User&gt;() {
    @Override
    public void success(User user) {
        new Thread() {
            @Override
            public void run() {
                processUser(user); // 尝试修正 User 数据
                runOnUiThread(new Runnable() { // 切回 UI 线程
                    @Override
                    public void run() {
                        userView.setUser(user);
                    }
                });
            }).start();
    }

    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
};
</code></pre>

<p>性能问题解决，但……这代码实在是太乱了，迷之缩进啊！杂乱的代码往往不仅仅是美观问题，因为代码越乱往往就越难读懂，而如果项目中充斥着杂乱的代码，无疑会降低代码的可读性，造成团队开发效率的降低和出错率的升高。</p>

<p>这时候，如果用 RxJava 的形式，就好办多了。 RxJava 形式的代码是这样的：</p>

<pre class="line-numbers"><code class="language-java">getUser(userId)
    .doOnNext(new Action1&lt;User&gt;() {
        @Override
        public void call(User user) {
            processUser(user);
        })
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;User&gt;() {
        @Override
        public void onNext(User user) {
            userView.setUser(user);
        }

        @Override
        public void onCompleted() {
        }

        @Override
        public void onError(Throwable error) {
            // Error handling
            ...
        }
    });
</code></pre>

<p>后台代码和前台代码全都写在一条链中，明显清晰了很多。</p>

<p>再举一个例子：假设 <code>/user</code> 接口并不能直接访问，而需要填入一个在线获取的 <code>token</code>，代码应该怎么写？<br/>
<code>Callback</code> 方式，可以使用嵌套的 <code>Callback</code>：</p>

<pre class="line-numbers"><code class="language-java">@GET(&quot;/token&quot;)
public void getToken(Callback&lt;String&gt; callback);

@GET(&quot;/user&quot;)
public void getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);

...

getToken(new Callback&lt;String&gt;() {
    @Override
    public void success(String token) {
        getUser(token, userId, new Callback&lt;User&gt;() {
            @Override
            public void success(User user) {
                userView.setUser(user);
            }

            @Override
            public void failure(RetrofitError error) {
                // Error handling
                ...
            }
        };
    }

    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
});
</code></pre>

<p>倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。<br/>
而使用 RxJava 的话，代码是这样的：</p>

<pre class="line-numbers"><code class="language-java">@GET(&quot;/token&quot;)
public Observable&lt;String&gt; getToken();

@GET(&quot;/user&quot;)
public Observable&lt;User&gt; getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId);

...

getToken()
    .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() {
        @Override
        public Observable&lt;User&gt; onNext(String token) {
            return getUser(token, userId);
        })
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;User&gt;() {
        @Override
        public void onNext(User user) {
            userView.setUser(user);
        }

        @Override
        public void onCompleted() {
        }

        @Override
        public void onError(Throwable error) {
            // Error handling
            ...
        }
    });
</code></pre>

<p>用一个 <code>flatMap()</code> 就搞定了逻辑，依然是一条链。看着就很爽，是吧？</p>

<h3 id="toc_38">RxBinding</h3>

<p><a href="https://github.com/JakeWharton/RxBinding">RxBinding</a>  是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 <code>OnClickListener</code> 、设置 <code>TextWatcher</code> 这样的注册绑定对象的 API。</p>

<p>举个设置点击监听的例子。使用 <code>RxBinding</code> ，可以把事件监听用这样的方法来设置：</p>

<pre class="line-numbers"><code class="language-java">Button button = ...;
RxView.clickEvents(button) // 以 Observable 形式来反馈点击事件
    .subscribe(new Action1&lt;ViewClickEvent&gt;() {
        @Override
        public void call(ViewClickEvent event) {
            // Click handling
        }
    });
</code></pre>

<p>看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 <code>setOnClickListener()</code> 来实现的。然而，仅仅这一个形式的改变，却恰好就是 <code>RxBinding</code> 的目的：扩展性。通过 <code>RxBinding</code> 把点击监听转换成 <code>Observable</code> 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 <code>throttleFirst()</code> ，用于去抖动，也就是消除手抖导致的快速连环点击：</p>

<pre class="line-numbers"><code class="language-java">RxView.clickEvents(button)
    .throttleFirst(500, TimeUnit.MILLISECONDS)
    .subscribe(clickAction);
</code></pre>

<p>如果想对 <code>RxBinding</code> 有更多了解，可以去它的  <a href="https://github.com/JakeWharton/RxBinding">GitHub 项目</a>  下面看看。</p>

<h3 id="toc_39">各种异步操作</h3>

<p>前面举的 <code>Retrofit</code> 和 <code>RxBinding</code> 的例子，是两个可以提供现成的 <code>Observable</code> 的库。而如果你有某些异步操作无法用这些库来自动生成 <code>Observable</code>，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现，有了之前几章的例子，这里应该不用再举例了。</p>

<h3 id="toc_40">RxBus</h3>

<p>RxBus 名字看起来像一个库，但它并不是一个库，而是一种模式，它的思想是使用 RxJava 来实现了 EventBus ，而让你不再需要使用 <code>Otto</code> 或者 GreenRobot 的 <code>EventBus</code>。至于什么是 RxBus，可以看 <a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/">这篇文章</a> 。顺便说一句，Flipboard 已经用 RxBus 替换掉了 <code>Otto</code> ，目前为止没有不良反应。</p>

<h2 id="toc_41">参考</h2>

<p><a href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870085.html">
                
                  <h1>Android-Fresco详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Android Fresco网络图片加载库</h2>

<p>Fresco是Facebook最新推出的一款用于Android应用中展示图片的强大图片库，可以从网络、本地存储和本地资源中加载图片。相对于ImageLoader，拥有更快的图片下载速度以及可以加载和显示gif图等诸多优势，是个很好的图片框架。</p>

<p><strong>github地址</strong>： <a href="https://github.com/facebook/fresco">https://github.com/facebook/fresco</a></p>

<h2 id="toc_1">基本的用法：</h2>

<ol>
<li>导入 Android Studio 或者 Gradle
<code>
dependencies {<br/>
compile &#39;com.facebook.fresco:fresco:0.9.0+&#39;<br/>
}
</code></li>
<li>在xml中引入SimpleDraweeView
<code>SQL
&lt;com.facebook.drawee.view.SimpleDraweeView<br/>
android:id=&quot;@+id/image_view&quot;<br/>
android:layout_width=&quot;20dp&quot;<br/>
android:layout_height=&quot;20dp&quot;<br/>
fresco:placeholderImage=&quot;@drawable/my_drawable&quot;<br/>
/&gt;
</code>
<strong>注意：1、在SimpleDraweeView的父控件或者根节点中配置xmlns:fresco=&quot;<a href="http://schemas.android.com/apk/res-auto">http://schemas.android.com/apk/res-auto</a>&quot;;</strong></li>
<li>配置网络权限</li>
<li>在Java代码中开始加载图片
<code>
Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/fresco-logo.png&quot;);<br/>
SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);<br/>
draweeView.setImageURI(uri);
</code></li>
</ol>

<h2 id="toc_2">URIs的使用</h2>

<table>
<thead>
<tr>
<th>类型</th>
<th>Scheme</th>
<th>示例</th>
</tr>
</thead>

<tbody>
<tr>
<td>远程图片</td>
<td>http:// 和 https://</td>
<td>HttpURLConnection 或者参考  <a href="http://fresco-cn.org/docs/using-other-network-layers.html">使用其他网络加载方案</a></td>
</tr>
<tr>
<td>本地文件</td>
<td>file://</td>
<td>FileInputStream</td>
</tr>
<tr>
<td>Content Provider</td>
<td>content://</td>
<td>ContentResolver</td>
</tr>
<tr>
<td>asset目录下的资源</td>
<td>asset://</td>
<td>AssetManager</td>
</tr>
<tr>
<td>res目录下的资源</td>
<td>res://</td>
<td>Resources.openRawResource</td>
</tr>
</tbody>
</table>

<p><strong>res 示例:Uri uri = Uri.parse(&quot;res://包名(实际可以是任何字符串甚至留空)/&quot; + R.drawable.ic_launcher);*<br/>
*注意：Fresco 不支持 相对路径的URI. 所有的URI都必须是绝对路径，并且带上该URI的scheme。</strong></p>

<h2 id="toc_3">在XML中使用SimpleDraweeView</h2>

<pre class="line-numbers"><code class="language-markup">&lt;com.facebook.drawee.view.SimpleDraweeView
    android:id=&quot;@+id/my_image_view&quot;
    android:layout_width=&quot;20dp&quot;
    android:layout_height=&quot;20dp&quot;
    fresco:fadeDuration=&quot;300&quot; // 淡入淡出的持续时间  
    fresco:actualImageScaleType=&quot;focusCrop&quot;  // 实际图像的缩放类型  
    fresco:placeholderImage=&quot;@color/wait_color&quot;  //占位图  
    fresco:placeholderImageScaleType=&quot;fitCenter&quot; //占位图的缩放类型  
    fresco:failureImage=&quot;@drawable/error&quot; //下载失败显示的图片  
    fresco:failureImageScaleType=&quot;centerInside&quot; //失败图的缩放类型  
    fresco:retryImage=&quot;@drawable/retrying&quot; //图片加载失败时显示，提示用户点击重新加载，重复加载4次还是没有加载出来的时候才会显示failureImage的图片  
    fresco:retryImageScaleType=&quot;centerCrop&quot; //重新加载的图片缩放类型  
    fresco:progressBarImage=&quot;@drawable/progress_bar&quot; //进度条图片  
    fresco:progressBarImageScaleType=&quot;centerInside&quot;  
    fresco:progressBarAutoRotateInterval=&quot;1000&quot; //进度图自动旋转间隔时间(单位：毫秒ms)  
    fresco:backgroundImage=&quot;@color/blue&quot;  //背景图片，这里的背景图片首先被绘制  
    fresco:overlayImage=&quot;@drawable/watermark&quot;  // 设置叠加图，在xml中只能设置一张叠加图片，如果需要多张图片的话，需要在java代码中设置哦  
    fresco:pressedStateOverlayImage=&quot;@color/red&quot;  // 设置点击状态下的叠加图  
    fresco:roundAsCircle=&quot;false&quot; //设置为圆形图  
    fresco:roundedCornerRadius=&quot;1dp&quot; // 圆角半径  
    fresco:roundTopLeft=&quot;true&quot; // 左上角是否为圆角  
    fresco:roundTopRight=&quot;false&quot;  
    fresco:roundBottomLeft=&quot;false&quot;  
    fresco:roundBottomRight=&quot;true&quot;  
    fresco:roundWithOverlayColor=&quot;@color/corner_color&quot;  
    fresco:roundingBorderWidth=&quot;2dp&quot; //边框的宽度  
    fresco:roundingBorderColor=&quot;@color/border_color&quot; //边框颜色
  /&gt;
</code></pre>

<p>说明：必须声明 android:layout_width 和 android:layout_height，否则将无法正确加载图像，另外不支持 wrap_content 属性，但也有例外的时候，如果想固定控件的宽高比，则可以使用wrap_content,并通过在xml代码中设置fresco:viewAspectRatio=&quot;小数&quot;或者在Java代码中设置mSimpleDraweeView.setAspectRatio(1.33f);即可。</p>

<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>center</td>
<td>居中，无缩放</td>
</tr>
<tr>
<td>centerCrop</td>
<td>保持宽高比缩小或放大，是的两边都大于或等于边界，且宽和高契合显示边界，居中显示</td>
</tr>
<tr>
<td>focusCrop</td>
<td>同centerCrop，但居中点不是中点，而是指定的某个点</td>
</tr>
<tr>
<td>centerInside</td>
<td>缩放图片使两边都在显示边界内，居中显示。和fitCenter不同，不会对图片进行放大。如果尺寸大于显示边界，则保持宽高比例缩小图片。</td>
</tr>
<tr>
<td>fitCenter</td>
<td>保持宽高比，缩小或者放大，使得图片完全显示在显示边界内，且宽或高契合显示边界，居中显示。</td>
</tr>
<tr>
<td>fitStart</td>
<td>同上，但不居中，和显示边界左上对齐。</td>
</tr>
<tr>
<td>fitEnd</td>
<td>同fitCenter，但不居中，和显示边界右下对齐。</td>
</tr>
<tr>
<td>fitXY</td>
<td>不保存宽高比，填充满显示边界。</td>
</tr>
<tr>
<td>none</td>
<td>如果要使用tile mode显示，则需要设置为none</td>
</tr>
</tbody>
</table>

<h2 id="toc_4">在Java中自定义显示图</h2>

<p>一般情况下，在XML设置显示效果即可, 如果想更多定制化，可以这样:<br/>
创建一个 builder 然后设置给 SimpleDraweeView:</p>

<pre class="line-numbers"><code class="language-java">List&lt;Drawable&gt; backgroundsList;
List&lt;Drawable&gt; overlaysList;
GenericDraweeHierarchyBuilder builder =
    new GenericDraweeHierarchyBuilder(getResources());
GenericDraweeHierarchy hierarchy = builder
    .setFadeDuration(300)
    .setPlaceholderImage(new MyCustomDrawable())
    .setBackgrounds(backgroundList)
    .setOverlays(overlaysList)
    .build();
mSimpleDraweeView.setHierarchy(hierarchy);
</code></pre>

<p>注意：请不要多次调用setHierarchy，即使这个View是可回收的。创建 DraweeHierarchy 的较为耗时的一个过程，应该多次利用。</p>

<h2 id="toc_5">修改 DraweeHierarchy</h2>

<p>DraweeHierarchy 的一些属性可以在运行时改变。<br/>
要改变这些属性，首先获取一个引用:<br/>
<code>GenericDraweeHierarchy hierarchy = mSimpleDraweeView.getHierarchy();</code></p>

<h2 id="toc_6">修改占位图</h2>

<p>修改占位图为资源id:<code>hierarchy.setPlaceholderImage(R.drawable.placeholderId);</code><br/>
或者修改为一个 <code>Drawable:Drawable drawable;</code><br/><br/>
<code>hierarchy.setPlaceholderImage(drawable);</code></p>

<h2 id="toc_7">改变图像的显示</h2>

<p>修改缩放类型:<br/>
<code>hierarchy.setActualImageScaleType(ScalingUtils.ScaleType.CENTER_INSIDE);</code><br/><br/>
如果你选择缩放类型为 focusCrop，需要指定一个居中点:<code>hierarchy.setActualImageFocusPoint(point);</code><br/>
你可以为图像添加一个 color filter:</p>

<pre class="line-numbers"><code class="language-java">ColorFilter filter;
// 创建filter
hierarchy.setActualImageColorFilter(filter);
</code></pre>

<h2 id="toc_8">圆角</h2>

<p>除了圆角显示方式（原来为圆角的不能修改为圆圈，反之亦然），其他圆角相关的呈现参数, 具体参见这里 是可以动态修改的。<br/>
如下: 获取DraweeHierarchy的圆角显示参数，修改圆角半径为10。</p>

<pre class="line-numbers"><code class="language-java">RoundingParams roundingParams = hierarchy.getRoundingParams();
roundingParams.setCornersRadius(10);
hierarchy.setRoundingParams(roundingParams);
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870050.html">
                
                  <h1>Android-AppBarLayout&CollapsingToolbar&Toolbar组合使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Toolbar</h2>

<p>Toobar主要是用来替换ActionBar的，换句话说，ActionBar能做的，Toolbar都能做。如果你对ActionBar的使用比较熟悉，你会发现Toolbar使用起来非常简单。ok，既然是替换，<strong>当然用Toolbar的时候就得先去把ActionBar给隐藏掉啦</strong>~</p>

<p>隐藏ActionBar的方法有很多，可以通过代码的方式隐藏，也可以通过配置文件的方式，我们主要是通过配置文件的方式来隐藏。在我们的styles.xml文件中的AppTheme标签中加入如下两行：</p>

<pre class="line-numbers"><code class="language-markup">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
</code></pre>

<p>当然了，你也可以新建一个<code>&lt;style&gt;</code>标签，将上面两行代码加入，并且将这个新建的标签作为<code>&lt;application&gt;</code>的<code>theme</code>。还可以选择通过将AppTheme的parent设置为<code>Theme.AppCompat.Light.NoActionBar</code>的方式。方法很多，可以自己随便选。<br/><br/>
接下来就是将Toolbar放入到布局文件（没啥好解释的）：</p>

<pre class="line-numbers"><code class="language-markup">&lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;
        android:layout_height=&quot;?android:attr/actionBarSize&quot;  /&gt;
</code></pre>

<p>最后将Toobar作为<code>ActionBar</code>来用</p>

<pre class="line-numbers"><code class="language-java">Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        toolbar.setTitle(&quot;这里是Title&quot;);
        toolbar.setSubtitle(&quot;这里是子标题&quot;);
        toolbar.setLogo(R.drawable.icon); 
        setSupportActionBar(toolbar);
</code></pre>

<p>可以对Toolbar设置Logo、标题、子标题等等~还有很多其他的设置，自己去慢慢玩，这里不提啦~。当然了，也可以在布局文件中设置这些，在布局文件设置就不写啦。<br/><br/>
如果Toolbar仅仅是用来对以往的ActionBar做一次替换，那也太没创意啦！完全没必要去替换了，因为它们表现出来的都是一样的，而且并没有让我们觉得用起来比ActionBar方便。那为啥要替换呢，总应该有他的理由吧：ActionBar是固定在顶部，并不能移动，我觉得这是最大的不好，而我们的ToolBar可以让我们随便摆放，就就可以带来很多灵活性和效果啦！</p>

<p>的确Toolbar根本就不够看的，一点都不复杂。接下来我们继续学习在Toolbar上面再套一层父View，让Toolbar更有互动性。</p>

<p>ToolBar中包含Nav Icon , Logo , Title , Sub Title , Menu Items 。<br/>
我们可以通过代码设置上述ToolBar中的控件：</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
   setContentView(R.layout.activity_main);

   Toolbar toolbar = (Toolbar) findViewById(R.id.id_toolbar);

   // App Logo
   toolbar.setLogo(R.mipmap.ic_launcher);
   // Title
   toolbar.setTitle(&quot;App Title&quot;);
   // Sub Title
   toolbar.setSubtitle(&quot;Sub title&quot;);

   setSupportActionBar(toolbar);
   //Navigation Icon
   toolbar.setNavigationIcon(R.drawable.ic_toc_white_24dp);
}
</code></pre>

<p><strong>可选方案</strong><br/><br/>
当然如果你喜欢，也可以在布局文件中去设置部分属性：</p>

<pre class="line-numbers"><code class="language-java">&lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/id_toolbar&quot;
        app:title=&quot;App Title&quot;
        app:subtitle=&quot;Sub Title&quot;
        app:navigationIcon=&quot;@drawable/ic_toc_white_24dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:minHeight=&quot;?attr/actionBarSize&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;/&gt;
</code></pre>

<p>至于Menu Item，依然支持在menu/menu_main.xml去声明，然后复写<code>onCreateOptionsMenu</code>和<code>onOptionsItemSelected</code>即可。</p>

<p><strong>可选方案</strong><br/><br/>
也可以通过<code>toolbar.setOnMenuItemClickListener</code>实现点击MenuItem的回调。</p>

<pre class="line-numbers"><code class="language-java">toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {
    @Override
   public boolean onMenuItemClick(MenuItem item) {
        return false;
   }
});
</code></pre>

<p>关于字体的样式，可以在布局文件设置属性<code>app:titleTextAppearance</code>、<code>app:subtitleTextAppearance</code>或者代码<code>setTitleTextAppearance</code>、<code>setSubTitleTextAppearance</code>设置。</p>

<h3 id="toc_1">layout_scrollFlags</h3>

<p>根据官方文档，layout_scrollFlags的取值可以为以下几种。</p>

<h3 id="toc_2">scroll</h3>

<p>设成这个值的效果就好比本View和scrolling view是“一体”的。具体示例我们在上面已经给出。有一点特别需要我们的注意，为了其他的滚动行为生效，必须同时指定scroll和相应的标记，比如我们想要exitUntilCollapsed所表现的滚动行为，必须将layout_scrollFlags指定为“scroll|exitUntilCollapsed”。</p>

<h3 id="toc_3">exitUntilCollapsed</h3>

<p>当本View离开屏幕时，会被“折叠”直到达到其最小高度。我们可以这样理解这个效果：当我们开始向上滚动scrolling view时，本View会先接管滚动事件，这样本View会先进行滚动，直到滚动到了最小高度（折叠了），scrolling view才开始实际滚动。而当本View已完全折叠后，再向下滚动scrolling view，直到scrolling view顶部的内容完全显示后，本View才会开始向下滚动以显现出来。</p>

<h3 id="toc_4">enterAlways</h3>

<p>当scrolling view向下滚动时，本View会一起跟着向下滚动。实际上就好比我们同时对scrolling view和本View进行向下滚动，与exitUntilCollapsed不同，当scrolling view一开始滚动，ToolBar便已开始跟着滚动，而无需scrolling view将其内容滚动到顶部。</p>

<h3 id="toc_5">enterAlwaysCollapsed</h3>

<p>从名字上就可以看出，这是在enterAlways的基础上，加上了“折叠”的效果。当我们开始向下滚动scrolling view时，本View会一起跟着滚动直到达到其“折叠高度”（即最小高度）。然后当scrolling view滚动至顶部内容完全显示后，再向下滚动scrolling view，本View会继续滚动到完全显示出来。需要把layout_scrollFlags指定为“scroll|enterAlways|enterAlwaysCollapsed”。</p>

<h3 id="toc_6">snap</h3>

<p>在一次滚动结束时，本View很可能只处于“部分显示”的状态，加上这个标记能够达到“要么完全隐藏，要么完全显示”的效果。到了这里，我们就把AppBarLayout能够实现的滚动行为介绍完毕了，很简单有木有。</p>

<h2 id="toc_7">AppBarLayout</h2>

<blockquote>
<p>AppBarLayout继承自LinearLayout，布局方向为垂直方向。所以你可以把它当成垂直布局的LinearLayout来使用。AppBarLayout是在LinearLayou上加了一些材料设计的概念，它可以让你定制当某个可滚动View的滚动手势发生变化时，其内部的子View实现何种动作。</p>
</blockquote>

<p>请注意：上面提到的某个<code>可滚动View</code>，可以理解为某个ScrollView。怎么理解上面的话呢？就是说，当某个ScrollView发生滚动时，你可以定制你的“顶部栏”应该执行哪些动作（如跟着一起滚动、保持不动等等）。那某个可移动的View到底是哪个可移动的View呢？这是由你自己指定的！如何指定，我们后面说。</p>

<h3 id="toc_8">AppBarLayout子View的动作</h3>

<p>内部的子View通过在布局中加<code>app:layout_scrollFlags</code>设置执行的动作，那么<code>app:layout_scrollFlags</code>可以设置哪些动作呢？分别如下：</p>

<h4 id="toc_9">（1）<code>scroll</code>:值设为<code>scroll</code>的View会跟随滚动事件一起发生移动。</h4>

<p>什么意思呢？简单的说，就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。</p>

<pre class="line-numbers"><code class="language-markup">&lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
&lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<p><figure><img src="media/15561207870050/20171010150764973485968.gif" alt=""/></figure></p>

<h4 id="toc_10">（2）<code>enterAlways</code>:值设为<code>enterAlways</code>的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。</h4>

<p>ToolBar高度设为：（<code>?android:attr/actionBarSize</code>）<br/>
<code>app:layout_scrollFlags=&quot;scroll|enterAlways&quot;</code></p>

<p><figure><img src="media/15561207870050/20171010150764977767320.gif" alt=""/></figure></p>

<h4 id="toc_11">（3） <code>exitUntilCollapsed</code>：值设为<code>exitUntilCollapsed</code>的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。</h4>

<p>怎么理解呢？简单解释：在ScrollView往上滑动时，首先是View把滑动事件“夺走”，由View去执行滑动，直到滑动最小高度后，把这个滑动事件“还”回去，让ScrollView内部去上滑。看个gif感受一下 ,图中将高度设的比较大:200dp，并将最小高度设置为（<code>?android:attr/actionBarSize</code>）<br/>
<code>app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code></p>

<p><figure><img src="media/15561207870050/20171010150764983431424.gif" alt=""/></figure></p>

<h4 id="toc_12">（4） <code>enterAlwaysCollapsed</code>：是<code>enterAlways</code>的附加选项，一般跟<code>enterAlways</code>一起使用，它是指，View在往下“出现”的时候，首先是<code>enterAlways</code>效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。</h4>

<p>图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize</code>,<code>app:layout_scrollFlags=&quot;scroll|enerAlways|enterAlwaysCollapsed&quot;</code></p>

<p><figure><img src="media/15561207870050/20171010150764986160489.gif" alt=""/></figure></p>

<h3 id="toc_13">将AppBarLayout与ScrollView关联起来</h3>

<p>前面说了一直反复说“当ScrollView发生滚动时”，那么怎么将AppBarLayout与ScrollView关联起来呢？我们注意到，AppBarLayout与ScrollView之间动作“相互依赖”，把ScrollView和AppBarLayout作为CoordinateLayout的子View，然后编写一个Behavior，在这个Behavior里面判断当前的操作是应该让ScrollView时刻保持在AppBarLayout之下（即只要改变AppBarLayout的位置就可以一起滑动），还是应该让ScrollView内部滚动而不让AppBarLayout位置发生变化等等这些需求，都是可以在Behavior里面处理的。你可以去针对你的ScrollView编写Behavior。然而，我们看到我们的AppBarLayout事先的功能比较复杂，如果我们自己去定义这样的效果，代码非常复杂，还要考虑很多方面，好在Android帮我们写好啦，我们直接用就是了，这个ScrollView就是NestedScrollView，请注意，它并没有继承ScrollView，它继承的是FrameLayout，但是它实现的效果把它可以看成是ScrollView。</p>

<p>把NestedScrollView放入到我们的layout文件里面就可以啦~~~，很方便~</p>

<pre class="line-numbers"><code class="language-text">&lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

       &lt;!--将你的内容放在这里--&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;
</code></pre>

<p>有没有注意到有个属性：<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>,它就是指定Behavior的，<code>appbar_scrolling_view_behavior</code>对应的类的名称是：<code>android.support.design.widget.AppBarLayout$ScrollingViewBehavior</code>感兴趣的可以去分析源码。<br/>
好了，我们现在会用AppBarLayout啦~是不是发现用起来so easy!接下来我们把剩下<code>CollapsingToolbarLayout</code>的给&quot;消化&quot;掉！</p>

<h3 id="toc_14">XML 布局</h3>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/coordinator&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:fitsSystemWindows=&quot;true&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/appbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;
        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;
        &lt;WebView
            android:id=&quot;@+id/web_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;
        &lt;/WebView&gt;
    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>在上面的布局文件中，NestedScrollView充当了scrolling view的角色，实际上scrolling view需要支持嵌套滚动，通常我们使用NestedScrollView、RecyclerView等已经实现了嵌套滚动的UI控件。</p>

<h2 id="toc_15">CoordinatorLayout</h2>

<p>在学习<code>CoordinatorLayout</code>之前，很有必要了解<code>CoordinatorLayout</code>能帮我们做什么，从名字上可以看出，就是帮我们协调子<code>View</code>的。怎么个协调法呢?就是它根据我们的定制，帮助我们协调各个子<code>View</code>的布局。</p>

<p><figure><img src="media/15561207870050/20171010150764992635490.gif" alt=""/></figure></p>

<p>稍微解释一下这个动画，蓝色的矩形是我们一个普通<code>View</code>，黄色的Hello是一个<code>Button</code>。我们水平拖动蓝色矩形时，黄色<code>Button</code>查着与蓝色矩形相反方向移动；竖直移动蓝色矩形时，黄色也跟着竖直。简而言之：它们在竖直方向同步移动，在水平方向相反。<br/><br/>
这个效果如果让你不用<code>CoordinatorLayout</code>去实现，应该没有任何问题，但是代码的耦合度应该非常大，你的代码必须要持有2个<code>View</code>的引用，然后在<code>onTouchEvent</code>里面做各种判断。如果我们想要实现的功能是，有更多的<code>View</code>要根据蓝色的<code>View</code>的移动相应作出响应，那么那就得在蓝色<code>View</code>的<code>onTounchEvent</code>里面针对其他的View处理各种逻辑。这耦合度未免太伤感了~<br/>
而<code>CoordinatorLayout</code>既然号称能帮我们协调子View的布局，我们接下来看看<code>CoordinatorLayout</code>如何实现~</p>

<h3 id="toc_16">CoordinatorLayout使用</h3>

<p><code>CoordinatorLayout</code>的使用核心是<code>Behavior</code>，<code>Behavior</code>就是执行你定制的动作。在讲<code>Behavior</code>之前必须先理解两个概念：<code>Child</code>和<code>Dependency</code>，什么意思呢？<code>Child</code>当然是子<code>View</code>的意思了，是谁的子<code>View</code>呢，当然是<code>CoordinatorLayout</code>的子<code>View</code>；其实<code>Child</code>是指要执行动作的<code>CoordinatorLayout</code>的子<code>View</code>。而<code>Dependency</code><br/>
是指<code>Child</code>依赖的<code>View</code>。比如上面的gif图中，蓝色的<code>View</code>就是<code>Dependency</code>，黄色的<code>View</code>就是<code>Child</code>，因为黄色的View的动作是依赖于蓝色的<code>View</code>。简而言之，就是如过<code>Dependency</code>这个View发生了变化，那么<code>Child</code>这个<code>View</code>就要相应发生变化。发生变化是具体发生什么变化呢？这里就要引入<code>Behavior</code>，<code>Child</code>发生变化的具体执行的代码都是放在<code>Behavior</code>这个类里面。<br/><br/>
怎么使用<code>Behavior</code>呢，首先，我们定义一个类，继承<code>CoordinatorLayout.Behavior&lt;T&gt;</code>,其中，泛型参数T是我们要执行动作的<code>View</code>类，也就是<code>Child</code>。然后就是去实现<code>Behavior</code>的两个方法：</p>

<pre class="line-numbers"><code class="language-java">/**
* 判断child的布局是否依赖dependency
*/
   @Override
 public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) {
    boolean rs;
    //根据逻辑判断rs的取值
    //返回false表示child不依赖dependency，ture表示依赖
    return rs;  
}

/**
* 当dependency发生改变时（位置、宽高等），执行这个函数
* 返回true表示child的位置或者是宽高要发生改变，否则就返回false
*/
@Override
public boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) {
     //child要执行的具体动作
        return true;
}
</code></pre>

<p>有了上面的概念后，我们看看具体怎么去实现吧~</p>

<p>为了响应跟随手指移动的操作，我们定义一个非常简单的<code>View</code>，这个<code>View</code>只响应跟随手指移动，将这个<code>View</code>作为<code>Dependency</code>。由于过于简单，这个<code>View</code>源码不粘贴，我们只需知道这个<code>View</code>的类名叫：<code>TempView</code>。</p>

<p>我们看看Behavior的使用：</p>

<pre class="line-numbers"><code class="language-java">package com.hc.studyCoordinatorLayout;

import android.content.Context;
import android.support.design.widget.CoordinatorLayout;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.view.View;
import android.widget.Button;

/**
 * Package com.hc.studyCoordinatorLayout
 * Created by HuaChao on 2016/6/1.
 */
public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; {
    private int width;

    public MyBehavior(Context context, AttributeSet attrs) {
        super(context, attrs);
        DisplayMetrics display = context.getResources().getDisplayMetrics();
        width = display.widthPixels;
    }

    @Override
    public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) {
        //如果dependency是TempView的实例，说明它就是我们所需要的Dependency
        return dependency instanceof TempView;
    }

    //每次dependency位置发生变化，都会执行onDependentViewChanged方法
    @Override
    public boolean onDependentViewChanged(CoordinatorLayout parent, Button btn, View dependency) {

        //根据dependency的位置，设置Button的位置

        int top = dependency.getTop();
        int left = dependency.getLeft();

        int x = width - left - btn.getWidth();
        int y = top;

        setPosition(btn, x, y);
        return true;
    }

    private void setPosition(View v, int x, int y) {
        CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) v.getLayoutParams();
        layoutParams.leftMargin = x;
        layoutParams.topMargin = y;
        v.setLayoutParams(layoutParams);
    }

}
</code></pre>

<p>OK，现在我们为<code>Button</code>类指定了<code>Dependency</code>，并且定义好了跟随<code>Dependency</code>一直变化的动作（<code>Behavior</code>），接下来我们就要指定好为哪个具体的<code>Button</code>实例来绑定这些。方法很简单，直接在布局文件指定就好：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.hc.studyCoordinatorLayout.MainActivity&quot;&gt;

    &lt;Button
        android:id=&quot;@+id/btn&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#FFCC00&quot;
        android:text=&quot;Hello&quot;
        app:layout_behavior=&quot;com.hc.studyCoordinatorLayout.MyBehavior&quot; /&gt;

    &lt;com.hc.studyCoordinatorLayout.TempView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:layout_marginLeft=&quot;300dp&quot;
        android:layout_marginTop=&quot;300dp&quot;
        android:background=&quot;#3366CC&quot;  /&gt;
&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>是不是很简单呢？我们只需关注<code>Behavior</code>的编写就好了，把<code>Child</code>和<code>Dependency</code>之间的关系完全解耦了~</p>

<h2 id="toc_17">CollapsingToolbarLayout</h2>

<p><code>CollapsingToolbarLayout</code>是用来对<code>Toolbar</code>进行再次包装的<code>ViewGroup</code>，主要是用于实现折叠（其实就是看起来像伸缩~）的App Bar效果。它需要放在<code>AppBarLayout</code>布局里面，并且作为<code>AppBarLayout</code>的直接子<code>View</code>。<code>CollapsingToolbarLayout</code>主要包括几个功能（参照了官方网站上内容，略加自己的理解进行解释）：</p>

<blockquote>
<p>(1)  Collasping title（可折叠标题）：当布局完全可见时，这个标题比较大；当折叠起来时，标题也会变小。标题的外观可以通过expandedTextAppearance和collapsedTextAppearance属性来调整。<br/>
(2)  Content scrim（内容纱布）：根据CollapsingToolbarLayout是否滚动到一个临界点，内容纱布会显示或隐藏。可以通过setContentScrim(Drawable)来设置内容纱布。<br/>
(3)  Status bar scrim（状态栏纱布）：也是根据是否滚动到临界点，来决定是否显示。可以通过setStatusBarScrim(Drawable)方法来设置。这个特性只有在Android5.0及其以上版本，我们设置fitSystemWindows为ture时才能生效。<br/>
(4)  Parallax scrolling children（视差滚动子View）：子View可以选择以“视差”的方式来进行滚动。（视觉效果上就是子View滚动的比其他View稍微慢些）<br/>
(5)  Pinned position children：子View可以选择固定在某一位置上。子View可以选择是否在全局空间上固定位置，这对于Toolbar来说非常有用，因为当布局在移动时，可以将Toolbar固定位置而不受移动的影响。 将<code>app:layout_collapseMode</code>设为<code>pin</code>。<br/>
了解这些概念后，我们来看看布局吧~</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;

    &lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            app:expandedTitleMarginEnd=&quot;64dp&quot;
            app:expandedTitleMarginStart=&quot;48dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/main.backdrop&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;300dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/material_img&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;

            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?android:attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot;  /&gt;

        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingTop=&quot;50dp&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@string/my_txt&quot;
            android:textSize=&quot;20sp&quot; /&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>上面的都看得懂吧，每个陌生的属性都是讲过的哦，忘记了的话回头看，稍微解释一下，图片被设置为有视差的滑动，Toolbar设置为固定不动，另外，CollapsingToolbarLayout会对title进行放大和缩小，我们看看效果吧~</p>

<p><figure><img src="media/15561207870050/20171010150765001948776.gif" alt=""/></figure></p>

<p>如果你希望拖动过程中状态栏是透明的，可以在CollapsingToolbarLayout中加 <code>app:statusBarScrim=&quot;@android:color/transparent&quot;</code>，并且在onCreate中调用<code>getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)</code>将状态栏设置为透明就好啦~</p>

<h3 id="toc_18">XML布局文件</h3>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/coordinator&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/app_bar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;256dp&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;
        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:id=&quot;@+id/collapsing_toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            app:expandedTitleMarginEnd=&quot;50dp&quot;
            app:expandedTitleMarginStart=&quot;50dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;
            &lt;ImageView
                android:src=&quot;@mipmap/ic_launcher&quot;
                android:id=&quot;@+id/image&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;
                android:scaleType=&quot;centerCrop&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;
            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot; /&gt;
        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;
        &lt;WebView
            android:id=&quot;@+id/web_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;
        &lt;/WebView&gt;
 &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>我们在XML文件中为CollapsingToolbarLayout的layout_scrollFlags指定为“scroll|exitUntilCollapsed”，这样便实现了向上滚动scrolling view时的折叠效果。CollapsingToolbarLayout本质上是一个FrameLayout。我们在布局文件中为它指定了两个子View，分别是ImageView和Toolbar。ImageView的layout_collapseMode属性设为了parallax，也就是我们前面介绍的视差滚动；而<code>Toolbar</code>的<code>layout_collaspeMode</code>设为了pin，也就是Toolbar会始终固定在顶部。</p>

<h3 id="toc_19">contentScrim</h3>

<p>在上图中，我们看到Toolbar的背景一直都是我们指定的图片，即时图片向上滚动到消失后也是这样。那么可不可以让图片完全消失后，Toolbar显示一个另外的背景呢？答案是肯定的，只要使用我们上面提到的“内容纱布”即可。还记得我们上面关于内容纱布的介绍吗？当CollapsingToolbarLayout滚动到一个临界位置，内容纱布就会显现出来，我们通过一个例子感受下。<br/><br/>
当CollapsingToolbarLayout完全折叠后，ToolBar的背景变为了黑色，好像盖上了一层布，所以这个属性叫做“内容纱布”。这里我们发现，只有CollapsingToolbarLayout滚动到折叠后，内容纱布才显现出来，也就是说，默认的临界位置就是滚动到折叠。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870016.html">
                
                  <h1>Android-DialogFragment详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">DialogFragment 设置全屏方法</h2>

<h3 id="toc_1">方法一</h3>

<pre class="line-numbers"><code class="language-java">@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setStyle(STYLE_NO_FRAME, android.R.style.Theme_Holo_Light);
}
</code></pre>

<h3 id="toc_2">方法二</h3>

<p><strong>style</strong></p>

<pre class="line-numbers"><code class="language-java">&lt;style name=&quot;style_dialog&quot; parent=&quot;android:style/Theme.Dialog&quot;&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt;
    &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowIsFloating&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowContentOverlay&quot;&gt;@null&lt;/item&gt;
    &lt;item name=&quot;android:scrollHorizontally&quot;&gt;true&lt;/item&gt;
    &lt;!-- Dialog进入及退出动画 --&gt;
    &lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@style/BottomToTopAnim&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;BottomToTopAnim&quot; parent=&quot;android:Animation&quot;&gt;
    &lt;item name=&quot;@android:windowEnterAnimation&quot;&gt;@anim/bottom_in&lt;/item&gt;
    &lt;item name=&quot;@android:windowExitAnimation&quot;&gt;@anim/bottom_out&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p><strong>bottom_in bottom_out 进入进出动画</strong></p>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;translate
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot;
    android:fromYDelta=&quot;100%p&quot;
    android:toYDelta=&quot;0&quot;/&gt;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;translate
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;300&quot;
    android:fromYDelta=&quot;0&quot;
    android:toYDelta=&quot;100%p&quot;/&gt;
</code></pre>

<p><strong>代码</strong></p>

<pre class="line-numbers"><code class="language-java">@NonNull
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {

    LayoutInflater inflater = getActivity().getLayoutInflater();
    View view = inflater.inflate(R.layout.view, null);

    final Dialog dialog = new Dialog(getActivity(), R.style.style_dialog);
    dialog.setContentView(view);
    dialog.show();

    Window window = dialog.getWindow();
    window.setGravity(Gravity.BOTTOM); //可设置dialog的位置
    window.getDecorView().setPadding(0, 0, 0, 0); //消除边距

    WindowManager.LayoutParams lp = window.getAttributes();
    lp.width = WindowManager.LayoutParams.MATCH_PARENT;   //设置宽度充满屏幕
    lp.height = WindowManager.LayoutParams.WRAP_CONTENT;
    window.setAttributes(lp);
    return dialog;

}
</code></pre>

<h2 id="toc_3">生命周期</h2>

<ul>
<li>onAttach</li>
<li> onCreate</li>
<li>onCreateView</li>
<li>onStart</li>
<li>onStop</li>
<li> third activity on destroy</li>
<li> onDestroyView</li>
<li> onDetach</li>
<li>onAttach</li>
<li>onCreate</li>
<li>onCreateView</li>
<li>onStart</li>
</ul>

<h2 id="toc_4">设置背景为透明</h2>

<pre class="line-numbers"><code class="language-java">View decorView = getDialog().getWindow().getDecorView();
decorView.setBackground(new ColorDrawable(Color.TRANSPARENT));
</code></pre>

<p>(PS:Window -&gt; DecorView -&gt; FrameLayout -&gt; FrameLayout -&gt; 我们的自定义View) 这个逻辑大家应该都知道的，所以我们只需要改变底部的DecorView的背景色即可。</p>

<h2 id="toc_5">设置弹框位置</h2>

<p>因为View是在window下面的，我们只需要让window的Grivaty属性是Bottom，这样，里面的元素都是居于底部即可。</p>

<pre class="line-numbers"><code class="language-java">Window window = getDialog().getWindow();
WindowManager.LayoutParams layoutParams = window.getAttributes();
layoutParams.gravity = Gravity.BOTTOM;
window.setAttributes(layoutParams);
</code></pre>

<h2 id="toc_6">解决DialogFragment两边的间隙</h2>

<p>因为View都是被包含在window里面，虽然我们的自己的View的宽度已经设置成了match_parent，但是我们并没有对window设置宽度为最大。所以我们先来改变window的宽度。</p>

<p>改变window的宽度：</p>

<pre class="line-numbers"><code class="language-java">Window window = getDialog().getWindow();
WindowManager.LayoutParams layoutParams = window.getAttributes();
layoutParams.gravity = Gravity.BOTTOM;
layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
window.setAttributes(layoutParams);
</code></pre>

<p>我们在前面修改弹框位置的代码处，多添加一句：</p>

<p><code>layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;</code></p>

<p>设置之后虽然二边的间隙变小了很多。但是还是有间隙，既然我们都已经把window的宽度变为match_parent,还是没填充，说明应该是有padding值。那我们马上就想到了，难道是DecorView里面有padding值。毕竟我们的View也是被包含在DecorView里面。废话不多说，我们马上实验：</p>

<p><code>decorView.setPadding(0,0,0,0);</code></p>

<blockquote>
<p>PS:这里还有另外一种方法，不写这句decorView.setPadding(0,0,0,0);而是直接设置window的背景颜色，window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));源码中其实也给DecorView设置了padding值。所以效果相同。</p>
</blockquote>

<h2 id="toc_7">设置弹框从下而上显示</h2>

<p>我们看过ios的弹框效果，是从底部从下而上升起，然后消失的时候也是从上而下消失。所以消失的时候我们不能单纯的让DialogFragment执行<code>dismiss()</code>，而是先让弹框执行下移的动画效果，然后再<code>dismiss()</code>。</p>

<p>既然谈到了上下的移动，大家肯定马上想到了用TranslateAnimation动画来做，我们就一步步来看如何用这个来实现：</p>

<ul>
<li>弹框出现动画：</li>
</ul>

<pre class="line-numbers"><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f
);
slide.setDuration(400);
slide.setFillAfter(true);
slide.setFillEnabled(true);
view.startAnimation(slide);
</code></pre>

<p>我们来看TranslateAnimation，这里我们传了八个参数，一般大家用到的是只传四个参数：</p>

<pre class="line-numbers"><code class="language-text">TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)
</code></pre>

<p>也就是从坐标<code>(fromXDelta,fromYDelta)</code>到<code>(toXDelta,toYDelta)</code>。<br/>
我们可以点进去这个构造函数查看：</p>

<pre class="line-numbers"><code class="language-java">public TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) {
      mFromXValue = fromXDelta;
      mToXValue = toXDelta;
      mFromYValue = fromYDelta;
      mToYValue = toYDelta;

      mFromXType = ABSOLUTE;
      mToXType = ABSOLUTE;
      mFromYType = ABSOLUTE;
      mToYType = ABSOLUTE;
}
</code></pre>

<p>之所以我们以前用的只传了四个参数，是因为他给我们把另外四个参数以及赋了默认值，也就是<code>ABSOLUTE</code>。我们继续看有哪几种可以选择：</p>

<pre class="line-numbers"><code class="language-text">  /**
   * The specified dimension is an absolute number of pixels.
   */
  public static final int ABSOLUTE = 0;

  /**
   * The specified dimension holds a float and should be multiplied by the
   * height or width of the object being animated.
   */
  public static final int RELATIVE_TO_SELF = 1;

  /**
   * The specified dimension holds a float and should be multiplied by the
   * height or width of the parent of the object being animated.
   */
  public static final int RELATIVE_TO_PARENT = 2;
</code></pre>

<p>通过字面意思我们也能理解：<br/><br/>
<code>ABSOLUTE</code>是绝对坐标，<code>RELATIVE_TO_SELF</code>是相对于自身，<code>RELATIVE_TO_PARENT</code>是相对于父View。<br/>
而我们只需要我们的弹框显示的位置，让的起始位置如下图所示：</p>

<p>刚开始超过屏幕，并且高度为弹框自身的高度，然后再回到原始位置,所以我们就用：</p>

<pre class="line-numbers"><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f
);
</code></pre>

<p>从原来的位置，增加了自身高度的距离为起始点，开始移动，然后再回到原来的位置。</p>

<ul>
<li>消失动画：</li>
</ul>

<p>只要跟上面反过来就可以了。同时这里我们要额外增加监听动画结束事件，因为我们让弹框往下移动结束后，要让这个弹框dismiss掉:</p>

<pre class="line-numbers"><code class="language-java">Animation slide = new TranslateAnimation(
      Animation.RELATIVE_TO_SELF, 0.0f,
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 0.0f, 
      Animation.RELATIVE_TO_SELF, 1.0f
);
slide.setAnimationListener(new Animation.AnimationListener() {
  @Override
  public void onAnimationStart(Animation animation) {}

  @Override
  public void onAnimationEnd(Animation animation) {
      IOSDialogFragment.this.dismiss();
  }

  @Override
  public void onAnimationRepeat(Animation animation) {}
});
</code></pre>

<p>所以我们的动画的代码总结下就是：</p>

<pre class="line-numbers"><code class="language-java">@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
    getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE);
    rootView = inflater.inflate(R.layout.fragment_ios_dialog, container, false);
    slideToUp(rootView);
    return rootView;
}


public void slideToUp(View view){
    Animation slide = new TranslateAnimation(
        Animation.RELATIVE_TO_SELF, 0.0f,
        Animation.RELATIVE_TO_SELF, 0.0f, 
        Animation.RELATIVE_TO_SELF,1.0f, Animation.RELATIVE_TO_SELF, 0.0f);

    slide.setDuration(400);
    slide.setFillEnabled(true);
    slide.setFillAfter(true);
    view.startAnimation(slide);
}

public void slideToDown(View view){
    Animation slide = new TranslateAnimation(
        Animation.RELATIVE_TO_SELF, 0.0f,
        Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF,0.0f, Animation.RELATIVE_TO_SELF, 1.0f);

    slide.setDuration(400);
    slide.setFillEnabled(true);
    slide.setFillAfter(true);
    view.startAnimation(slide);

    slide.setAnimationListener(new Animation.AnimationListener() {
        @Override
        public void onAnimationStart(Animation animation) {

        }

        @Override
        public void onAnimationEnd(Animation animation) {
            IOSDialogFragment.this.dismiss();//弹框消失
        }

        @Override
        public void onAnimationRepeat(Animation animation) {

        }
    });
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869978.html">
                
                  <h1>Android-RecyclerView详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">RecyclerView</h2>

<h3 id="toc_1">RecyclerView是什么？</h3>

<p>RecylerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字recylerview即回收view也可以看出。看到这也许有人会问，不是已经有ListView了吗，为什么还要RecylerView呢？这就牵扯到第二个问题了。</p>

<h3 id="toc_2">RecyclerView的优点是什么？</h3>

<p>根据官方的介绍RecylerView是ListView的升级版，既然如此那RecylerView必然有它的优点，现就RecylerView相对于ListView的优点罗列如下：</p>

<ul>
<li>RecylerView封装了viewholder的回收复用，也就是说RecylerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的   逻辑被封装了，写起来更加简单。</li>
<li>提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecylerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还有StaggeredGridLayoutManager等)，也就是说RecylerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。你想控制Item的分隔线，可以通过继承RecylerView的ItemDecoration这个类，然后针对自己的业务需求去抒写代码。</li>
<li>可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecylerView有其自己默认的实现。</li>
</ul>

<h3 id="toc_3">RecyclerView的用法</h3>

<h4 id="toc_4">RecyclerView的初步用法(包括RecyclerView.Adapter用法)</h4>

<pre class="line-numbers"><code class="language-java">recyclerView = (RecyclerView) findViewById(R.id.recyclerView);  
LinearLayoutManager layoutManager = new LinearLayoutManager(this );  
//设置布局管理器  
recyclerView.setLayoutManager(layoutManager);  
//设置为垂直布局，这也是默认的  
layoutManager.setOrientation(OrientationHelper. VERTICAL);  
//设置Adapter  
recyclerView.setAdapter( recycleAdapter);  
//设置分隔线  
recyclerView.addItemDecoration( new DividerGridItemDecoration(this ));  
//设置增加或删除条目的动画  
recyclerView.setItemAnimator( new DefaultItemAnimator());
</code></pre>

<p>可以看到对RecylerView的设置过程，比ListView要复杂一些，这也是RecylerView高度解耦的表现，虽然代码抒写上有点复杂，但它的扩展性是极高的。</p>

<h3 id="toc_5">RecyclerView的生命周期</h3>

<p>一个RecyclerView的Item加载是有顺序的，类似于Activity的生命周期（姑且这么叫把），具体可以对adapter的每个方法进行重写打下日志进行查看，具体大致为：</p>

<ul>
<li>getItemViewType(获取显示类型，返回值可在onCreateViewHolder中拿到，以决定加载哪种ViewHolder)</li>
<li>onCreateViewHolder(加载ViewHolder的布局)</li>
<li>onViewAttachedToWindow（当Item进入这个页面的时候调用）</li>
<li>onBindViewHolder(将数据绑定到布局上，以及一些逻辑的控制就写这啦)</li>
<li>onViewDetachedFromWindow（当Item离开这个页面的时候调用）</li>
<li>onViewRecycled(当Item被回收的时候调用)<br/>
tips1:如果你调用了：</li>
</ul>

<pre class="line-numbers"><code class="language-text">viewHolder.setIsRecyclable(false);
</code></pre>

<p>那么这个Item的onViewRecycled将永远不会调用。<br/>
tips2:如果你的界面出现了错乱的现象，请调用如上代码可能能简单粗暴的解决，当然代价是损失少许的性能表现了。</p>

<h2 id="toc_6">RecyclerView.Adapter</h2>

<p>来看看它的Adapter的写法，RecyclerView的Adapter与ListView的Adapter还是有点区别的，RecyclerView.Adapter，需要实现3个方法：</p>

<ul>
<li><code>onCreateViewHolder()</code>这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。直接省去了当初的convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。</li>
<li><code>onBindViewHolder()</code>这个方法主要用于适配渲染数据到View中。方法提供给你了一个viewHolder，而不是原来的convertView。</li>
<li><p><code>getItemCount()</code>这个方法就类似于BaseAdapter的getCount方法了，即总共有多少个条目。</p></li>
<li><p><code>notifyDataSetChanged()</code>刷新所有,notifyDataSetChanged最终会使adapter的数据重新绑定，即会重新调用adapter里的onBindViewHolder方法，从而使item的position得到了更新。</p></li>
<li><p><code>notifyItemChanged(int position)</code>position数据发生了改变，那调用这个方法，就会回调对应position的onBindViewHolder()方法了</p></li>
<li><p><code>notifyItemRangeChanged(int positionStart, int itemCount)</code>刷新从positionStart开始itemCount数量的item了（这里的刷新指回调onBindViewHolder()方法）</p></li>
<li><p><code>notifyItemInserted(int position)</code>在第position位置被插入了一条数据的时候可以使用这个方法刷新，注意这个方法调用后会有插入的动画，这个动画可以使用默认的，也可以自己定义</p></li>
<li><p><code>notifyItemMoved(int fromPosition, int toPosition)</code>从fromPosition移动到toPosition为止的时候可以使用这个方法刷新</p></li>
<li><p><code>notifyItemRangeInserted(int positionStart, int itemCount)</code>批量添加</p></li>
<li><p><code>notifyItemRemoved(int position)</code>第position个被删除的时候刷新，同样会有动画</p></li>
<li><p><code>notifyItemRangeRemoved(int positionStart, int itemCount)</code>批量删除</p></li>
<li><p><code>onAttachedToRecyclerView (RecyclerView recyclerView)</code>在<code>RecyclerView.setAdapter(adapter)</code>时进行调用</p></li>
<li><p><code>onViewAttachedToWindow(VH holder)</code>当Item进入这个页面的时候调用</p></li>
<li><p><code>onViewDetachedFromWindow(VH holder)</code>当Item离开这个页面的时候调用</p></li>
<li><p><code>onViewRecycled(VH holder)</code>当Item被回收的时候调用</p></li>
</ul>

<h2 id="toc_7">RecyclerView.ItemDecoration</h2>

<blockquote>
<p>An ItemDecoration allows the application to add a special drawing and layout offset to specific item views from the adapter&#39;s data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and more.</p>

<p>ItemDecoration允许应用结合adapter的数据集，对特定的item添加绘制一个周边图案。可以用于给items之间添加分割线、高亮装饰效果或者分组边界等等。</p>
</blockquote>

<p>从谷歌官方的介绍可以知道，ItemDecoration是用于给列表的item添加各种装饰效果，开发中最常见的就是为item添加分割线。<br/><br/>
ItemDecoration本身是一个抽象类，抛去废弃的方法，我们需要关心的方法只有三个：</p>

<pre class="line-numbers"><code class="language-java">public static abstract class ItemDecoration {
    public void onDraw(Canvas c, RecyclerView parent, State state) {
        onDraw(c, parent);
    }
    public void onDrawOver(Canvas c, RecyclerView parent, State state) {
        onDrawOver(c, parent);
    }
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) {
        getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),parent);
    }
}
</code></pre>

<p>从源码注释中，可以大概了解这三个方法的用途：</p>

<ul>
<li><code>onDraw</code>：在item绘制之前时被调用，将指定的内容绘制到item view内容之下；</li>
<li><code>onDrawOver</code>：在item被绘制之后调用，将指定的内容绘制到item view内容之上</li>
<li><code>getItemOffsets</code>：在每次测量item尺寸时被调用，将decoration的尺寸计算到item的尺寸中</li>
</ul>

<p><figure><img src="media/15561207869978/15713203883056.jpg" alt=""/></figure></p>

<h3 id="toc_8">ItemDecoration三个方法的测试</h3>

<p>谷歌官方在support.v7包中提供了ItemDecoration的一个实现DividerItemDecoration，这里结合这个实现，来看看其三个需要实现的方法对UI的影响。</p>

<h4 id="toc_9">onDraw</h4>

<pre class="line-numbers"><code class="language-java">private void drawVertical(Canvas canvas, RecyclerView parent) {
    canvas.save();
   final int left;
   final int right;
   if (parent.getClipToPadding()) {
        left = parent.getPaddingLeft();
        right = parent.getWidth() - parent.getPaddingRight();
        canvas.clipRect(left, parent.getPaddingTop(), right,parent.getHeight() - parent.getPaddingBottom());
   } else {
        left = 0;
        right = parent.getWidth();
    }

    final int childCount = parent.getChildCount();
    for (int i = 0; i &lt; childCount; i++) {
        final View child = parent.getChildAt(i);
        parent.getDecoratedBoundsWithMargins(child, mBounds);
        final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child));
        final int top = bottom - mDivider.getIntrinsicHeight();
        mDivider.setBounds(left, top, right, bottom);
       mDivider.draw(canvas);
    }
    canvas.restore();
}
</code></pre>

<p><code>drawVertical</code>方法实现了对<code>Orientation == VERTICAL</code>的RecyclerView绘制item之间的分割线。从传入的canvas参数可以推断，分割线的绘制是通过canvas机制绘制到屏幕上：<code>mDivider.draw(canvas)</code>;其中，mDivider是一个Drawable对象，可以通过setDrawable传入自定义对象，不传入时，会自动使用系统内置的分割线样式：<code>android.R.attr.listDivider</code>。通过遍历每一个可见的child view，计算mDivider对应的left、top、right、bottom值，从而绘制到正确的位置上。对于纵向的RecyclerView而言，mDivider的left和right是固定的，和parent的左右内容边界保持一致，也就是说，把parent的左右padding都计算进去，因而是代表了RecyclerView实际的内容区域。纵向的分割线一般位于每个item的底部，因此mDivider的top值理论上应该和child view的内容下边界保持贴合。实际上，计算top和bottom的代码，谷歌官方也有所调整，在最新的实现中，先通过<code>parent.getDecoratedBoundsWithMargins(child, mBounds)</code>;拿到之前在onMeasure过程中，通过调用<code>getItemOffsets</code>获取到的mBounds，mBounds是包括了整个child view以及其decoration的总边界，之后再计算mDivider的bottom、top值。</p>

<h4 id="toc_10">getItemOffsets</h4>

<pre class="line-numbers"><code class="language-java">public void getItemOffsets(Rect outRect, View view, RecyclerView parent,RecyclerView.State state) {
    if (mOrientation == VERTICAL) {
        outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
    } else {
        outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
    }
}
</code></pre>

<p>官方实现的getItemOffsets比较简单，只是根据列表的方向，返回了分割线在相应方向的尺寸。这里可能有一个坑，即通过setDrawable设置自定义的分割线时，容易传入一个无尺寸的drawable对象，导致分割线无法显示出来的bug，典型的代码是这样：<br/>
<code>decoration.setDrawable(new ColorDrawable(Color.RED));</code></p>

<p>DividerItemDecoration的实现中，是没有复写onDrawOver方法的，对于分割线场景而言，也确实不需要去实现它。接下来，通过几个例子，展示一下getItemOffsets对于ItemDecoration在UI上的影响。</p>

<h4 id="toc_11">getItemOffsets &amp; onDraw</h4>

<p>先上动图【注2】：</p>

<p><figure><img src="media/15561207869978/20171015150799983096582.gif" alt=""/></figure></p>

<p><figure><img src="media/15561207869978/20171015150799985361609.gif" alt=""/></figure></p>

<p>上图中，getItemOffsets方法里，返回outRect不同，而onDraw方法绘制的分割线高度初始值设为25，并通过外部增减来观察其UI效果。</p>

<pre class="line-numbers"><code class="language-java">public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
    outRect.set(0, 0, 0, 50);// outRect.set(50,50,50,50);
}

public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
    for (int i = 0; i &lt; childCount; i++) {
        final View view = parent.getChildAt(i);
        top = view.getBottom();
        left = view.getPaddingLeft() + mSize;
        right = view.getWidth() - view.getPaddingRight() - mSize ;
        bottom = top + mSize;
        divider.setBounds(left, top, right, bottom);
        divider.draw(c);
    }
}
</code></pre>

<p>从上面两个动图对比，可以得出以下几个结论：</p>

<ul>
<li>getItemOffsets返回的矩形outRect会被计算到child view的尺寸当中；</li>
<li>onDraw方法绘制的图形，可以超出outRect所规定的区域；</li>
<li>onDraw方法绘制的图形，确实是处于child view的底下，当两者发生重叠时，只会显示child view的内容；</li>
</ul>

<h4 id="toc_12">getItemOffsets &amp; onDrawOver</h4>

<p><figure><img src="media/15561207869978/20171015150799996057841.gif" alt=""/></figure></p>

<p>将之前onDraw方法内代码完整拷贝到onDrawOver下，并注释掉之前onDraw中的方法，很容易验证出onDrawOver与onDraw的唯一不同之处。</p>

<ul>
<li>onDrawOver绘制的图形，处于child view之上，当两者发生重叠时，会显示onDrawOver的内容；</li>
</ul>

<blockquote>
<p>ItemDecoration三个方法的含义，就介绍到这里。可以感觉到，三个方法都很简单而基础，可以十分优雅的实现item的分割线效果，然而简单的如DividerItemDecoration，往往是无法满足项目开发需求的。经常会遇到某几个item不想要分割线（如头部或者最后一个item），这就需要开发者自行来实现。</p>
</blockquote>

<h3 id="toc_13">添加分隔线</h3>

<p>我们可以创建一个继承RecyclerView.ItemDecoration类来绘制分隔线，通过ItemDecoration可以让我们每一个Item从视觉上面相互分开来，例如ListView的divider非常相似的效果。也可以不设置ItemDecoration，那说明ItemDecoration我们并不是强制需要使用，作为我们开发者可以设置或者不设置Decoration的。实现一个ItemDecoration，系统提供的ItemDecoration是一个抽象类，内部除去已经废弃的方法以外，我们主要实现以下三个方法:</p>

<pre class="line-numbers"><code class="language-java">public static abstract class ItemDecoration {   
    public void onDraw(Canvas c,RecyclerView parent,State state) {   
        onDraw(c,parent);   
    }   
    public void onDrawOver(Canvas c,RecyclerView parent,State state) {   
        onDrawOver(c,parent);   
    }   
    public void getItemOffsets(RectoutRect, View view,RecyclerView parent,State state) {   
        getItemOffsets(outRect,((LayoutParams)view.getLayoutParams()).getViewLayoutPosition(),parent);   
    }   
}
</code></pre>

<ul>
<li><code>onDraw</code>方法先于<code>drawChildren</code></li>
<li><code>onDrawOver</code>在<code>drawChildren</code>之后，一般我们选择复写其中一个即可。</li>
<li><code>getItemOffsets</code> 可以通过<code>outRect.set()</code>为每个<code>Item</code>设置一定的偏移量，主要用于绘制<code>Decorator</code>。</li>
</ul>

<p>又因为当我们RecyclerView在进行绘制的时候会进行绘制Decoration,那么会去调用onDraw和onDrawOver方法，那么这边我们其实只要去重写onDraw和getItemOffsets这两个方法就可以实现啦。然后LayoutManager会进行Item布局的时候，会去调用getItemOffset方法来计算每个Item的Decoration合适的尺寸，下面我们来具体实现一个</p>

<pre class="line-numbers"><code class="language-java">package com.example.reclerviewpractice;  
  
import android.content.Context;  
import android.content.res.TypedArray;  
import android.graphics.Canvas;  
import android.graphics.Rect;  
import android.graphics.drawable.Drawable;  
import android.support.v7.widget.LinearLayoutManager ;  
import android.support.v7.widget.RecyclerView;  
import android.view.View;  
  
public class DividerItemDecoration extends RecyclerView.ItemDecoration {  
  
    private static final int[] ATTRS = new int[]{  
        android.R.attr. listDivider  
    };  
    public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;  
    public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL;  
    private Drawable mDivider;
    private int mOrientation;  
  
    public DividerItemDecoration(Context context, int orientation) {  
        final TypedArray a = context.obtainStyledAttributes(ATTRS );  
        mDivider = a.getDrawable(0);  
        a.recycle();  
        setOrientation(orientation);  
    }  
  
    public void setOrientation( int orientation) {  
        if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) {  
            throw new IllegalArgumentException( &quot;invalid orientation&quot;);  
        }  
        mOrientation = orientation;  
    }  
  
    @Override  
    public void onDraw(Canvas c, RecyclerView parent) {  
        if (mOrientation == VERTICAL_LIST) {  
            drawVertical(c, parent);  
        } else {  
            drawHorizontal(c, parent);  
        }  
    }  
  
    public void drawVertical(Canvas c, RecyclerView parent) {  
        final int left = parent.getPaddingLeft();  
        final int right = parent.getWidth() - parent.getPaddingRight();  
        final int childCount = parent.getChildCount();  
        for (int i = 0; i &lt; childCount; i++) {  
            final View child = parent.getChildAt(i);  
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();  
            final int top = child.getBottom() + params.bottomMargin;  
            final int bottom = top + mDivider.getIntrinsicHeight();  
            mDivider.setBounds(left, top, right, bottom);  
            mDivider.draw(c);  
        }  
    }  
  
    public void drawHorizontal(Canvas c, RecyclerView parent) {  
        final int top = parent.getPaddingTop();  
        final int bottom = parent.getHeight() - parent.getPaddingBottom();  
  
        final int childCount = parent.getChildCount();  
        for (int i = 0; i &lt; childCount; i++) {  
            final View child = parent.getChildAt(i);  
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();  
            final int left = child.getRight() + params.rightMargin;  
            final int right = left + mDivider.getIntrinsicHeight();  
            mDivider.setBounds(left, top, right, bottom);  
            mDivider.draw(c);  
        }  
    }  
  
    @Override  
    public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) {  
        if (mOrientation == VERTICAL_LIST) {  
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());  
        }else{  
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);  
        }  
    }  
}
</code></pre>

<h3 id="toc_14">改变分隔线样式</h3>

<p>那么怎么更改分隔线的样式呢？在上面的DividerItemDecoration这个类中可以看到这个分隔线是跟ListView一样的，即系统的默认的样式，因此我们可以在styles的xml文件中进行更改，更改如下：</p>

<pre class="line-numbers"><code class="language-java">&lt;!-- Application theme. --&gt;  
&lt;style name =&quot;AppTheme&quot; parent=&quot;AppBaseTheme&quot;&gt;  
    &lt;!-- All customizations that are NOT specific to a particular API-level can go here. --&gt;  
    &lt;item name= &quot;android:listDivider&quot;&gt;@drawable/divider &lt;/item &gt;   
&lt;/style &gt;
</code></pre>

<p>divider的内容如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding= &quot;utf-8&quot;?&gt;  
&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:shape=&quot;rectangle&quot; &gt;  
     
    &lt;!-- 填充的颜色 --&gt;  
    &lt;solid android:color =&quot;@color/color_red&quot;/&gt;  
       
    &lt;!--  线条大小 --&gt;  
    &lt;size android:height =&quot;1dp&quot; android:width =&quot;1dp&quot;/&gt;  
&lt;/shape&gt;
</code></pre>

<p>看到这肯定会有人说，这尼玛，好麻烦，还不如ListView简单呢，从上面的代码量看来确实是使用起来很复杂，但是如果此时你想将这个列表以GridView的形式展示出来，用RecylerView仅仅是换一行代码的事情.</p>

<h3 id="toc_15">简单的封装MKItemDecoration</h3>

<ul>
<li>支持简单颜色分割线</li>
<li>支持简单颜色分割线 + 文字：文字可以居左、居中</li>
<li>支持分割线跳过起始诺干个item，跳过最后一个item</li>
<li>支持分组悬停效果</li>
<li>支持自定义View作为Decoration</li>
</ul>

<p><figure><img src="media/15561207869978/2017101515080000957381.gif" alt=""/></figure></p>

<p>上图hoverGroup.gif的使用代码如下：</p>

<pre class="line-numbers"><code class="language-java">recyclerView.addItemDecoration(new MKItemDecoration.Builder()
.height(50)
.color(Color.parseColor(&quot;#525D97&quot;))
.textSize(30)
.textColor(Color.WHITE)
.itemOffset(0)
.iHover(new IHover() {
    @Override
    public boolean isGroup(int position) {
        return position % 4 == 0;
    }

    @Override
    public String groupText(int position) {
        return adapter.data.get(4 * (position / 4));
    }
})
.textAlign(MKItemDecoration.Builder.ALIGN_MIDDLE)
.build());
</code></pre>

<p>通过封装，利用builder模式来更好的自定义需要的Decoration，其中，为了支持自定义View，需要外部传入相关的view的资源id和需要绑定的数据List，控件内部会通过view的measure,layout,draw的流程，将其绘制在屏幕上。</p>

<p><a href="https://github.com/Dragon-Boat/library">具体代码</a></p>

<h2 id="toc_16">RecyclerView.ViewHolder</h2>

<ul>
<li><p><code>getPosition()</code>在API22的时候已经被废弃，因为它在异步处理器更新的时候不能准确表示数据，是模棱两可的。请根据你所使用的场景参照使用getLayoutPosition() 和 getAdapterPosition()</p></li>
<li><p><code>getAdapterPosition()</code>在调用<code>notifyDataSetChanged</code>之后并不能马上获取Adapter中的position, 要等布局结束之后才能获取到.在调用<code>notifyItemInserted(0)</code>之后能通过<code>getAdapterPosition()</code>获取适配器位置即使新的布局还没有计算。,如果你做一些用户点击,如果getAdapterPosition()返回NO_POSITION,最好忽略点击,因为你不知道用户点击(除非你有其他机制,如稳定的id查找条目)。</p></li>
<li><p><code>getLayoutPosition()</code>假设您正在使用LayoutManager或者想要访问ViewHolder当前点击的项目。在这种情况下,您应该使用<code>getLayoutPosition()</code>来获取当前布局位置。<code>mRecyclerView.findViewHolderForLayoutPosition(myViewHolder.getLayoutPosition() - 1)</code></p></li>
</ul>

<h2 id="toc_17">RecyclerView.ItemAnimator</h2>

<ul>
<li><p><code>animateAppearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br/>
当RecyclerView中的item显示到屏幕上时调用此方法。传入的layout之后的ViewHolder对象。</p></li>
<li><p><code>animateDisappearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br/>
当RecyclerView中的item在屏幕上由可见变为不可见时调用此方法。传入的layout之后的ViewHolder对象。</p></li>
<li><p><code>animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)</code><br/>
当RecyclerView中的item状态发生改变时调用此方法(notifyItemChanged(position))。<br/>
方法中传入了layout之前的ViewHolder和layout之后的ViewHolder对象，通过这两个ViewHolder对象获取其中的itemView进行动画效果。</p></li>
<li><p><code>runPendingAnimations()</code><br/>
统筹RecyclerView中所有的动画，统一启动执行</p></li>
<li><p><code>setRemoveDuration(long removeDuration)</code>/<code>getRemoveDuration()</code><br/>
 设置删除Item动画的延迟时间</p></li>
<li><p><code>setMoveDuration(long moveDuration)</code>/<code>getMoveDuration()</code><br/>
设置移动Item动画的延迟时间</p></li>
<li><p><code>setChangeDuration(long changeDuration)</code>/<code>getChangeDuration()</code><br/>
设置改变Item动画的延迟时间</p></li>
<li><p><code>setAddDuration(long addDuration)</code>/<code>getAddDuration()</code><br/>
设置添加Item动画的延迟时间</p></li>
<li><p><code>recordPostLayoutInformation(RecyclerView.State state, RecyclerView.ViewHolder viewHolder)</code><br/>
布局完成后对这个方法进行调用，记录view的必要信息。</p></li>
<li><p><code>onAnimationStarted(RecyclerView.ViewHolder viewHolder)</code><br/>
当一个新动画添加到这个ViewHolder上，调用此方法</p></li>
<li><p><code>onAnimationFinished(RecyclerView.ViewHolder viewHolder)</code><br/>
在<code>dispatchAnimationFinished(ViewHolder)</code>这个方法调用后调用</p></li>
<li><p><code>obtainHolderInfo()</code><br/>
获取ViewHolder保存的<code>RecyclerView.ItemAnimator.ItemHolderInfo</code>信息</p></li>
<li><p><code>isRunning()</code><br/>
判断是否有Item动画在运行</p></li>
<li><p><code>endAnimations()</code><br/>
停止所有动画</p></li>
<li><p><code>endAnimation(RecyclerView.ViewHolder item)</code><br/>
停止指定动画</p></li>
</ul>

<h2 id="toc_18">RecyclerView.LayoutManager</h2>

<p>RecyclerView.LayoutManager是一个抽象类，系统为我们提供了三个实现类</p>

<ul>
<li>LinearLayoutManager即线性布局，这个是在上面的例子中我们用到的布局</li>
<li>GridLayoutManager即表格布局</li>
<li>StaggeredGridLayoutManager即流式布局，如瀑布流效果假如将上述例子换成GridView的效果，那么相应的代码应该这样改</li>
</ul>

<h2 id="toc_19">给RecyclerView的Item添加点击事件</h2>

<p>ListView给我们提供了onItemClickListener的监听器，但对于RecyclerView来讲，非常可惜的是，该控件没有给我们提供这样的内置监听器方法，不过我们可以进行改造实现，可以这样实现Item的点击事件的监听，在我们的adapter中增加这两个方法</p>

<pre class="line-numbers"><code class="language-java">public interface OnItemClickListener{
    void onClick( int position);
    void onLongClick( int position);
}

public void setOnItemClickListener(OnItemClickListener onItemClickListener ){
    this. mOnItemClickListener=onItemClickListener;
}
</code></pre>

<p>然后onBindViewHolder方法要做如下更改</p>

<pre class="line-numbers"><code class="language-java">@Override  
public void onBindViewHolder(MyViewHolder holder, final int position) {  
    holder. tv.setText( mDatas.get(position));  
    if( mOnItemClickListener!= null){  
        holder. itemView.setOnClickListener( new OnClickListener() {  
        @Override  
        public void onClick(View v) {  
            mOnItemClickListener.onClick(position);  
        }  
    });  
                  
    holder. itemView.setOnLongClickListener( new OnLongClickListener() {  
        @Override  
        public boolean onLongClick(View v) {  
            mOnItemClickListener.onLongClick(position);  
            return false;  
        }  
    });  
}  
</code></pre>

<h2 id="toc_20">RecyclerView局部刷新界面</h2>

<h3 id="toc_21">来自于RecyclerView的原理</h3>

<p>RecyclerView addView调用的时候ViewGroup addView的源码，源码如下(如无特殊说明，以下源码均为api 25)</p>

<pre class="line-numbers"><code class="language-java">public void addView(View child, int index, LayoutParams params) {
    if (DBG) {
        System.out.println(this + &quot; addView&quot;);
    }
    if (child == null) {
        throw new IllegalArgumentException(&quot;Cannot add a null child view to a ViewGroup&quot;);
    }

    // addViewInner() will call child.requestLayout() when setting the new LayoutParams
    // therefore, we call requestLayout() on ourselves before, so that the child&#39;s request
    // will be blocked at our level
    requestLayout();
    invalidate(true);
    addViewInner(child, index, params, false);
}
</code></pre>

<p>也就是会调用requestLayout，这是一个全局刷新的函数，也就是说整个界面将会被刷新，有全局刷新在View层级较多较复杂的时必然存在卡顿<br/>
那么RecyclerView 如何做到滑动时addView时不卡的呢，也就是说RecyclerView addView时候为什么没有引起RecyclerView 的onMeasure触发呢，答案就是RecyclerView 以下代码</p>

<pre class="line-numbers"><code class="language-java">@Override
public void requestLayout() {
    if (mEatRequestLayout == 0 &amp;&amp; !mLayoutFrozen) {
        super.requestLayout();
    } else {
        mLayoutRequestEaten = true;
    }
}
</code></pre>

<p>尼玛还有这种操作？？！复写requestLayout不向上报告，自己做内部处理，内部处理详见LayoutManager类的layoutChunk函数这里不细说。</p>

<p>好了，得到了黑科技的样本，接下来我就来实现一个黑科技的demo，改变View宽高时局部刷新界面。</p>

<h3 id="toc_22">黑科技的应用</h3>

<p>MainActivity布局如下</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.zjw.appmethodtime.MyRelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.zjw.appmethodtime.MainActivity&quot;&gt;

    &lt;com.zjw.appmethodtime.MyLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;com.zjw.appmethodtime.MyTextView
            android:id=&quot;@+id/text_view&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;50dp&quot;
            android:background=&quot;@color/colorPrimary&quot;
            android:text=&quot;Click Me&quot;
            android:gravity=&quot;center&quot;
            android:textSize=&quot;25sp&quot;
            android:textStyle=&quot;bold&quot;/&gt;
    &lt;/com.zjw.appmethodtime.MyLayout&gt;
&lt;/com.zjw.appmethodtime.MyRelativeLayout&gt;
</code></pre>

<p>自定义一个RelativeLayout 用以看是否局部刷新是否生效，如果局部刷新无效则顶层onMeasure会调用（因为改变了控件大小嘛全局刷新肯定会调用到处于顶层的onMeasure）</p>

<pre class="line-numbers"><code class="language-java">public class MyRelativeLayout extends RelativeLayout {
    public MyRelativeLayout(Context context) {
        super(context);
    }

    public MyRelativeLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre>

<p>自定义一个MyLayout 继承自LinearLayout ，这里只是demo你想用什么ViewGroup可以自己改。<br/>
这里MyLayout 就类似于RecyclerView 了，该子View宽高改变时会调用requestLayout，MyLayout 这里做拦截，然后自行处理。</p>

<pre class="line-numbers"><code class="language-java">public class MyLayout extends LinearLayout {
    private int mWidthMeasureSpec;
    private int mheightMeasureSpec;
    private int mLeft;
    private int mTop;
    private int mRight;
    private int mBottom;

    public static boolean shouldLocalIinvalidate = false;


    public MyLayout(Context context) {
        this(context, null);
    }

    public MyLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        mLeft = l;
        mTop = t;
        mRight = r;
        mBottom = b;
        super.onLayout(changed, l, t, r, b);
    }

    @Override
    public void requestLayout() {
        if (shouldLocalIinvalidate) {
            localRequestLayout();
        } else {
            super.requestLayout();
        }
    }

    @SuppressLint(&quot;WrongCall&quot;)
    void localRequestLayout() {
        onMeasure(mWidthMeasureSpec, mheightMeasureSpec);
        onLayout(true, mLeft, mTop, mRight, mBottom);
        invalidate();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        mWidthMeasureSpec = widthMeasureSpec;
        mheightMeasureSpec = widthMeasureSpec;
    }
}
</code></pre>

<p>以下代码就是在MainActivity里使用改变子View宽高局部刷新界面</p>

<pre class="line-numbers"><code class="language-java">package com.zjw.appmethodtime;

import android.content.res.Resources;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.TypedValue;
import android.view.View;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    protected MyRecycleView mListView;
    protected TextView mTextView;
    private float value;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        super.setContentView(R.layout.activity_main);
        initView();
    }

    private void initView() {
        Resources resources = this.getResources();
        value = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, resources.getDisplayMetrics());
        mTextView = (TextView) findViewById(R.id.text_view);
        mTextView.setOnClickListener(MainActivity.this);
    }

    @Override
    public void onClick(View view) {
        if (view.getId() == R.id.text_view) {
            view.getLayoutParams().height += value;
            //shouldLocalIinvalidate 为true 表示开启局部刷新 否则为关闭（MyLayout shouldLocalIinvalidate 默认为false）
            ((MyLayout) view.getParent()).shouldLocalIinvalidate = true;
            view.requestLayout();
            view.invalidate();
            //局部刷新完成及时恢复成可以全局刷新的状态
            ((MyLayout) view.getParent()).shouldLocalIinvalidate = false;
        }

    }
}
</code></pre>

<p>上面MainActivity 的onClick代码中开启了局部刷新（log代码自己加），效果图参见上文。<br/>
把上面的<code>((MyLayout) view.getParent()).shouldLocalIinvalidate = true;</code>这句去掉，这就是相当于不启用局部刷新，然后看<code>MyRelativeLayout</code> 的<code>onMeasure</code>方法log（log代码自己加），不启用局部刷新效果图见上文。</p>

<h3 id="toc_23">应用场景</h3>

<p>使用于某个ViewGroup宽高已定位置已定，该子view想改变宽高等场景。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869937.html">
                
                  <h1>Android-View详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">View有8个直接子类：</h2>

<p><code>AnalogClock</code>, <code>ImageView</code>, <code>KeyboardView</code>, <code>ProgressBar</code>, <code>SurfaceView</code>, <code>TextView</code>, <code>ViewGroup</code>, <code>ViewStub</code>。</p>

<h2 id="toc_1">View有54个间接子类：</h2>

<p><code>AbsListView</code>, <code>AbsSeekBar</code>,<code>AbsSpinner</code>, <code>AbsoluteLayout</code>, <code>AdapterView&lt;T extends Adapter&gt;</code>, <code>AppWidgetHostView</code>, <code>AutoCompleteTextView</code>,<code>Button</code>,<code>CheckBox</code>, <code>CheckedTextView</code>, <code>Chronometer</code>, <code>CompoundButton</code>,<code>DatePicker</code>, <code>DialerFilter</code>, <code>DigitalClock</code>,<code>EditText</code>, <code>ExpandableListView</code>, <code>ExtractEditText</code>,<code>FrameLayout</code>, <code>GLSurfaceView</code>,<code>Gallery</code>,<code>GestureOverlayView</code>,<code>GridView</code>, <code>HorizontalScrollView</code>, <code>ImageButton</code>, <code>ImageSwitcher</code>, <code>LinearLayout</code>,<code>ListView</code>,<code>MediaController</code>, <code>MultiAutoCompleteTextView</code>, <code>QuickContactBadge</code>,<code>RadioButton</code>,<code>RadioGroup</code>, <code>RatingBar</code>, <code>RelativeLayout</code>, <code>ScrollView</code>, <code>SeekBar</code>, <code>SlidingDrawer</code>, <code>Spinner</code>, <code>TabHost</code>, <code>TabWidget</code>, <code>TableLayout</code>, <code>TableRow</code>, <code>TextSwitcher</code>, <code>TimePicker</code>, <code>ToggleButton</code>, <code>TwoLineListItem</code>,<code>VideoView</code>, <code>ViewAnimator</code>, <code>ViewFlipper</code>, <code>ViewSwitcher</code>, <code>WebView</code>, <code>ZoomButton</code>, <code>ZoomControls</code></p>

<h2 id="toc_2">View的属性</h2>

<h3 id="toc_3">基本属性</h3>

<ul>
<li><p><code>android:alpha</code>关联方法: <code>setAlpha(float)</code> 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。</p></li>
<li><p><code>android:background</code>关联方法: <code>setBackgroundResource(int)</code> 属性说明: 视图背景</p></li>
<li><p><code>android:clickable</code>关联方法: <code>setClickable(boolean)</code> 属性说明: 视图是否可点击</p></li>
<li><p><code>android:contentDescription</code>关联方法: <code>setContentDescription(CharSequence)</code> 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明</p></li>
<li><p><code>android:drawingCacheQuality</code>关联方法: <code>setDrawingCacheQuality(int)</code> 属性说明: &quot;设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存&quot;</p></li>
<li><p><code>android:duplicateParentState</code>关联方法: 属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等）</p></li>
<li><p><code>android:fadeScrollbars</code>关联方法: <code>setScrollbarFadingEnabled(boolean)</code> 属性说明: 定义在ScrollBar没有使用时，是否褪色。</p></li>
<li><p><code>android:fadingEdgeLength</code>关联方法: <code>getVerticalFadingEdgeLength()</code> 属性说明: 设置边框渐变的长度。</p></li>
<li><p><code>android:filterTouchesWhenObscured</code>关联方法: <code>setFilterTouchesWhenObscured(boolean)</code> 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。</p></li>
<li><p><code>android:fitsSystemWindows</code>关联方法: <code>setFitsSystemWindows(boolean)</code> 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏）</p></li>
<li><p><code>android:focusable</code>关联方法: <code>setFocusable(boolean)</code> 属性说明: 设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。在Touch模式下获取焦点需要设置focusableInTouchMode为true。</p></li>
<li><p><code>android:focusableInTouchMode</code>关联方法: <code>setFocusableInTouchMode(boolean)</code> 属性说明: 设置在Touch模式下View是否能取得焦点。</p></li>
<li><p><code>android:hapticFeedbackEnabled</code>关联方法: <code>setHapticFeedbackEnabled(boolean)</code> 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果</p></li>
<li><p><code>android:id</code>关联方法: <code>setId(int)</code> 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用<code>View.findViewById()</code> 或<code>Activity.findViewById()</code>根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。</p></li>
<li><p><code>android:importantForAccessibility</code>关联方法: <code>setImportantForAccessibility(int)</code> 属性说明: 设置可达性的重要性</p></li>
<li><p><code>android:isScrollContainer</code>关联方法: <code>setScrollContainer(boolean)</code> 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条</p></li>
<li><p><code>android:keepScreenOn</code>关联方法: <code>setKeepScreenOn(boolean)</code> 属性说明: 视图在可见的情况下是否保持唤醒状态。</p></li>
<li><p><code>android:layerType</code>关联方法: <code>setLayerType(int,Paint)</code> 属性说明: &quot;设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。&quot;</p></li>
<li><p><code>android:layoutDirection</code>关联方法: <code>setLayoutDirection(int)</code> 属性说明: 定义布局图纸的方向</p></li>
<li><p><code>android:longClickable</code>关联方法: <code>setLongClickable(boolean)</code> 属性说明: 是否响应长点击事件</p></li>
<li><p><code>android:minHeight</code>关联方法: <code>setMinimumHeight(int)</code> 属性说明: 设置视图最小高度</p></li>
<li><p><code>android:minWidth</code>关联方法: <code>setMinimumWidth(int)</code> 属性说明: 设置视图最小宽度</p></li>
<li><p><code>android:nextFocusDown</code>关联方法: <code>setNextFocusDownId(int)</code> 属性说明: 向下移动焦点时，下一个获取焦点的view的id</p></li>
<li><p><code>android:nextFocusForward</code>关联方法: <code>setNextFocusForwardId(int)</code> 属性说明: 下一个获取焦点的view的id</p></li>
<li><p><code>android:nextFocusLeft</code>关联方法: <code>setNextFocusLeftId(int)</code> 属性说明: 向左移动焦点时，下一个获取焦点的view的id</p></li>
<li><p><code>android:nextFocusRight</code>关联方法: <code>setNextFocusRightId(int)</code> 属性说明: 向右移动焦点时，下一个获取焦点的view的id</p></li>
<li><p><code>android:nextFocusUp</code>关联方法: <code>setNextFocusUpId(int)</code> 属性说明: 向上移动焦点时，下一个获取焦点的view的id</p></li>
<li><p><code>android:onClick</code>关联方法: 属性说明: 点击时，要调用的方法的名称。</p></li>
<li><p><code>android:padding</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 设置上下左右的边距</p></li>
<li><p><code>android:paddingBottom</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 下边距</p></li>
<li><p><code>android:paddingEnd</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 与<code>android:paddingRight</code>相同</p></li>
<li><p><code>android:paddingLeft</code>关联方法: <code>setPadding(int,int,int,int)</code> 属性说明: 左边距</p></li>
<li><p><code>android:paddingRight</code>关联方法: <code>setPadding(int,int,int,int)</code> 属性说明: 右边距</p></li>
<li><p><code>android:paddingStart</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: <code>android:paddingLeft</code>相同</p></li>
<li><p><code>android:paddingTop</code>关联方法: <code>setPaddingRelative(int,int,int,int)</code> 属性说明: 上边距</p></li>
<li><p><code>android:requiresFadingEdge</code>关联方法: <code>setVerticalFadingEdgeEnabled(boolean)</code> 属性说明: 定义滚动时边缘是否褪色</p></li>
<li><p><code>android:rotation</code>关联方法: <code>setRotation(float)</code> 属性说明: 旋转度数</p></li>
<li><p><code>android:rotationX</code>关联方法: <code>setRotationX(float)</code> 属性说明: 水平旋转度数</p></li>
<li><p><code>android:rotationY</code>关联方法: <code>setRotationY(float)</code> 属性说明: 竖直旋转度数</p></li>
<li><p><code>android:saveEnabled</code>关联方法: <code>setSaveEnabled(boolean)</code> 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。</p></li>
<li><p><code>android:scaleX</code>关联方法: <code>setScaleX(float)</code> 属性说明: 水平方向缩放比例</p></li>
<li><p><code>android:scaleY</code>关联方法: <code>setScaleY(float)</code> 属性说明: 竖直方向缩放比例</p></li>
<li><p><code>android:scrollX</code>关联方法: 属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离</p></li>
<li><p><code>android:scrollY</code>关联方法: 属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离</p></li>
<li><p><code>android:scrollbarAlwaysDrawHorizontalTrack</code>关联方法: 属性说明: 是否总是绘制水平滚动条的滚动轨道</p></li>
<li><p><code>android:scrollbarAlwaysDrawVerticalTrack</code>关联方法: 属性说明: 是否总是绘制竖直滚动条的滚动轨道</p></li>
<li><p><code>android:scrollbarDefaultDelayBeforeFade</code>关联方法: <code>setScrollBarDefaultDelayBeforeFade(int)</code> 属性说明: 滚动条在n毫秒后开始淡出。</p></li>
<li><p><code>android:scrollbarFadeDuration</code>关联方法: <code>setScrollBarFadeDuration(int)</code> 属性说明: 滚动条用多长时间淡出完毕。</p></li>
<li><p><code>android:scrollbarSize</code>关联方法: <code>setScrollBarSize(int)</code> 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度</p></li>
<li><p><code>android:scrollbarStyle</code>关联方法: <code>setScrollBarStyle(int)</code> 属性说明: &quot;滚动条的风格。共4组值： <code>insideOverlay</code>——内贴图 <code>insideInset</code>——内插图 <code>outsideOverlay</code>——外贴图 <code>outsideInset</code>——外插图。 <code>inside</code>就是滚动条在绘制在padding以内；<code>outside</code>就是不需要绘制在<code>padding</code>内（即view的边界处）；<code>Overlay</code>是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；<code>Inset</code>是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。&quot;</p></li>
<li><p><code>android:scrollbarThumbHorizontal</code>关联方法: 属性说明: 水平滚动块的drawable对象</p></li>
<li><p><code>android:scrollbarThumbVertical</code>关联方法: 属性说明: 竖直滚动块的drawable对象</p></li>
<li><p><code>android:scrollbarTrackHorizontal</code>关联方法: 属性说明: 水平滚动条滚动轨道的drawable对象</p></li>
<li><p><code>android:scrollbarTrackVertical</code>关联方法: 属性说明: 竖直滚动条滚动轨道的drawable对象</p></li>
<li><p><code>android:scrollbars</code>关联方法: 属性说明: &quot;设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条&quot;</p></li>
<li><p><code>android:soundEffectsEnabled</code>关联方法: <code>setSoundEffectsEnabled(boolean)</code> 属性说明: 点击或触摸该view时，是否需要有声音效果</p></li>
<li><p><code>android:tag</code>关联方法: 属性说明: string标识。类似id，id是整数标识。</p></li>
<li><p><code>android:textAlignment</code>关联方法: <code>setTextAlignment(int)</code> 属性说明: 设置文本的显示方式。</p></li>
<li><p><code>android:textDirection</code>关联方法: <code>setTextDirection(int)</code> 属性说明: 设置文本的显示方向。</p></li>
<li><p><code>android:transformPivotX</code>关联方法: <code>setPivotX(float)</code> 属性说明: 水平方向偏转量</p></li>
<li><p><code>android:transformPivotY</code>关联方法: <code>setPivotY(float)</code> 属性说明: 竖直方向偏转量</p></li>
<li><p><code>android:translationX</code>关联方法: <code>setTranslationX(float)</code> 属性说明: 水平方向的移动距离</p></li>
<li><p><code>android:translationY</code>关联方法: <code>setTranslationY(float)</code> 属性说明: 竖直方向的移动距离</p></li>
<li><p><code>android:visibility</code>关联方法: <code>setVisibility(int)</code> 属性说明: &quot;view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见&quot;</p></li>
</ul>

<h3 id="toc_4">TextView属性说明</h3>

<p>下面对TextView的属性进行说明<code>android:autoLink</code>关联方法: <code>setAutoLinkMask(int)</code>属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值(none/web/email/phone/map/all)</p>

<ul>
<li><p><code>android:autoText</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。</p></li>
<li><p><code>android:bufferType</code>关联方法: <code>setText(CharSequence,TextView.BufferType)</code>属性说明: 指定<code>getText()</code>方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。</p></li>
<li><p><code>android:capitalize</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。</p></li>
<li><p><code>android:cursorVisible</code>关联方法: <code>setCursorVisible(boolean)</code>属性说明: 设定光标为显示/隐藏，默认显示。</p></li>
<li><p><code>android:digits</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\n()”</p></li>
<li><p><code>android:drawableBottom</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。</p></li>
<li><p><code>android:drawableEnd</code>关联方法: <code>setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，&quot;@[+][package:]type:name&quot;或者&quot;?[package:][type:]name&quot;；也可以是颜色值，如&quot;#rgb&quot;, &quot;#argb&quot;, &quot;#rrggbb&quot;, or &quot;#aarrggbb&quot;。</p></li>
<li><p><code>android:drawableLeft</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的左边输出一个drawable。</p></li>
<li><p><code>android:drawablePadding</code>关联方法: <code>setCompoundDrawablePadding(int)</code>属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。</p></li>
<li><p><code>android:drawableRight</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的右边输出一个drawable。</p></li>
<li><p><code>android:drawableStart</code>关联方法: <code>setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，&quot;@[+][package:]type:name&quot;或者&quot;?[package:][type:]name&quot;；也可以是颜色值，如&quot;#rgb&quot;, &quot;#argb&quot;, &quot;#rrggbb&quot;, or &quot;#aarrggbb&quot;。</p></li>
<li><p><code>android:drawableTop</code>关联方法: <code>setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)</code>属性说明: 在text的正上方输出一个drawable。</p></li>
<li><p><code>android:editable</code>关联方法: 属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。</p></li>
<li><p><code>android:editorExtras</code>关联方法: <code>setInputExtras(int)</code>属性说明: 设置文本的额外的输入数据。在EditView中才有效果。</p></li>
<li><p><code>android:ellipsize</code>关联方法: <code>setEllipsize(TextUtils.TruncateAt)</code>属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动)</p></li>
<li><p><code>android:ems</code>关联方法: <code>setEms(int)</code>属性说明: 设置TextView的宽度为N个字符的宽度。</p></li>
<li><p><code>android:fontFamily</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 文本的字形体系。</p></li>
<li><p><code>android:freezesText</code>关联方法: <code>setFreezesText(boolean)</code>属性说明: 设置保存文本的内容以及光标的位置。</p></li>
<li><p><code>android:gravity</code>关联方法: <code>setGravity(int)</code>属性说明: 设置文本位置，如设置成“center”，文本将居中显示。</p></li>
<li><p><code>android:height</code>关联方法: <code>setHeight(int)</code>属性说明: 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)</p></li>
<li><p><code>android:hint</code>关联方法: <code>setHint(int)</code>属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。</p></li>
<li><p><code>android:imeActionId</code>关联方法: <code>setImeActionLabel(CharSequence,int)</code>属性说明: 设置IME动作ID。</p></li>
<li><p><code>android:imeActionLabel</code>关联方法: <code>setImeActionLabel(CharSequence,int)</code>属性说明: 设置IME动作标签。在EditView再做说明。</p></li>
<li><p><code>android:imeOptions</code>关联方法: <code>setImeOptions(int)</code>属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。</p></li>
<li><p><code>android:includeFontPadding</code>关联方法: <code>setIncludeFontPadding(boolean)</code>属性说明: 设置文本是否包含顶部和底部额外空白，默认为true。</p></li>
<li><p><code>android:inputMethod</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。</p></li>
<li><p><code>android:inputType</code>关联方法: <code>setRawInputType(int)</code>属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。</p></li>
<li><p><code>android:lineSpacingExtra</code>关联方法: <code>setLineSpacing(float,float)</code>属性说明: 设置行间距。</p></li>
<li><p><code>android:lineSpacingMultiplier</code>关联方法: <code>setLineSpacing(float,float)</code>属性说明: 设置行间距的倍数。如”1.2”</p></li>
<li><p><code>android:lines</code>关联方法: <code>setLines(int)</code>属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。</p></li>
<li><p><code>android:linksClickable</code>关联方法: <code>setLinksClickable(boolean)</code>属性说明: 设置链接是否点击连接，即使设置了autoLink。</p></li>
<li><p><code>android:marqueeRepeatLimit</code>关联方法: <code>setMarqueeRepeatLimit(int)</code>属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。</p></li>
<li><p><code>android:maxEms</code>关联方法: <code>setMaxEms(int)</code>属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。</p></li>
<li><p><code>android:maxHeight</code>关联方法: <code>setMaxHeight(int)</code>属性说明: 设置文本区域的最大高度</p></li>
<li><p><code>android:maxLength</code>关联方法: <code>setFilters(InputFilter)</code>属性说明: 限制显示的文本长度，超出部分不显示。</p></li>
<li><p><code>android:maxLines</code>关联方法: <code>setMaxLines(int)</code>属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。</p></li>
<li><p><code>android:maxWidth</code>关联方法: <code>setMaxWidth(int)</code>属性说明: 设置文本区域的最大宽度</p></li>
<li><p><code>android:minEms</code>关联方法: <code>setMinEms(int)</code>属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。</p></li>
<li><p><code>android:minHeight</code>关联方法: <code>setMinHeight(int)</code>属性说明: 设置文本区域的最小高度</p></li>
<li><p><code>android:minLines</code>关联方法: <code>setMinLines(int)</code>属性说明: 设置文本的最小行数，与lines类似。</p></li>
<li><p><code>android:minWidth</code>关联方法: <code>setMinWidth(int)</code>属性说明: 设置文本区域的最小宽度</p></li>
<li><p><code>android:numeric</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。</p></li>
<li><p><code>android:password</code>关联方法: <code>setTransformationMethod(TransformationMethod)</code>属性说明: 以小点”.”显示文本</p></li>
<li><p><code>android:phoneNumber</code>关联方法: <code>setKeyListener(KeyListener)</code>属性说明: 设置为电话号码的输入方式。</p></li>
<li><p><code>android:privateImeOptions</code>关联方法: <code>setPrivateImeOptions(String)</code>属性说明: 设置输入法选项，在EditText中才有作用。</p></li>
<li><p><code>android:scrollHorizontally</code>关联方法: <code>setHorizontallyScrolling(boolean)</code>属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。</p></li>
<li><p><code>android:selectAllOnFocus</code>关联方法: <code>setSelectAllOnFocus(boolean)</code>属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。</p></li>
<li><p><code>android:shadowColor</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。</p></li>
<li><p><code>android:shadowDx</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影横向坐标开始位置。</p></li>
<li><p><code>android:shadowDy</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影纵向坐标开始位置。</p></li>
<li><p><code>android:shadowRadius</code>关联方法: <code>setShadowLayer(float,float,float,int)</code>属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。</p></li>
<li><p><code>android:singleLine</code>关联方法: <code>setTransformationMethod(TransformationMethod)</code>属性说明: 设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如<code>android:text=&quot;test_ singleLine&quot;</code> <code>android:singleLine=&quot;true&quot;</code> <code>android:layout_width=&quot;20dp&quot;</code>将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行</p></li>
<li><p><code>android:text</code>关联方法: <code>setText(CharSequence,TextView.BufferType)</code>属性说明: 设置显示文本.</p></li>
<li><p><code>android:textAllCaps</code>关联方法: <code>setAllCaps(boolean)</code>属性说明: 设置文本全为大写。值为&quot;true&quot;或&quot;false&quot;。</p></li>
<li><p><code>android:textAppearance</code>关联方法: 属性说明: 设置文字外观。如“?<code>android:attr/textAppearanceLargeInverse</code></p></li>
<li><p><code>android:textColor</code>关联方法: <code>setTextColor(int)</code>属性说明: 设置文本颜色</p></li>
<li><p><code>android:textColorHighlight</code>关联方法: <code>setHighlightColor(int)</code>属性说明: 被选中文字的底色，默认为蓝色</p></li>
<li><p><code>android:textColorHint</code>关联方法: <code>setHintTextColor(int)</code>属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。</p></li>
<li><p><code>android:textColorLink</code>关联方法: <code>setLinkTextColor(int)</code>属性说明: 文字链接的颜色.</p></li>
<li><p><code>android:textIsSelectable</code>关联方法: <code>isTextSelectable()</code>属性说明: 设置非编辑文本可否被选择。值为&quot;true&quot;或&quot;false&quot;。</p></li>
<li><p><code>android:textScaleX</code>关联方法: <code>setTextScaleX(float)</code>属性说明: 设置文字之间间隔，默认为1.0f。</p></li>
<li><p><code>android:textSize</code>关联方法: <code>setTextSize(int,float)</code>属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp”</p></li>
<li><p><code>android:textStyle</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开</p></li>
<li><p><code>android:typeface</code>关联方法: <code>setTypeface(Typeface)</code>属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3]</p></li>
<li><p><code>android:width</code>关联方法: <code>setWidth(int)</code>属性说明: 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。</p></li>
</ul>

<h3 id="toc_5">Other</h3>

<p>由于这两天在做listView的东西，所以整理出来一些我个人认为比较特别的属性，通过设置这样的属性可以做出更加美观的列表</p>

<ul>
<li>首先是stackFromBottom属性，这只该属性之后你做好的列表就会显示你列表的最下面，值为true和false</li>
</ul>

<p><code>android:stackFromBottom=&quot;true&quot;</code></p>

<ul>
<li><p>第二是transciptMode属性，需要用ListView或者其它显示大量Items的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件transcriptMode属性可以将 android平台的控件（支持ScrollBar）自动滑动到最底部。 <code>android:transcriptMode=&quot;alwaysScroll&quot;</code></p></li>
<li><p>第三cacheColorHint属性，很多人希望能够改变一下它的背景，使他能够符合整体的UI设计，改变背景背很简单只需要准备一张图片然后指定属性 <code>android:background=&quot;@drawable/bg&quot;</code>，不过不要高兴地太早，当你这么做以后，发现背景是变了，但是当你拖动，或者点击list空白位置的时候发现ListItem都变成黑色的了，破坏了整体效果。</p></li>
</ul>

<p>如果你只是换背景的颜色的话，可以直接指定<code>android:cacheColorHint</code>为你所要的颜色，如果你是用图片做背景的话，那也只要将<code>android:cacheColorHint</code>指定为透明（#00000000）就可以了</p>

<ul>
<li>第四divider属性，该属性作用是每一项之间需要设置一个图片做为间隔，或是去掉item之间的分割线</li>
</ul>

<p><code>android:divider=&quot;@drawable/list_driver&quot;</code>  其中  @drawable/list_driver 是一个图片资源，如果不想显示分割线则只要设置为<code>android:divider=&quot;@drawable/@null&quot;</code> 就可以了</p>

<ul>
<li>第五fadingEdge属性，上边和下边有黑色的阴影</li>
</ul>

<p><code>android:fadingEdge=&quot;none&quot;</code> 设置后没有阴影了~</p>

<ul>
<li>第六scrollbars属性，作用是隐藏listView的滚动条，</li>
</ul>

<p><code>android:scrollbars=&quot;none&quot;</code>与<code>setVerticalScrollBarEnabled(true);</code>的效果是一样的，不活动的时候隐藏，活动的时候也隐藏</p>

<ul>
<li>第七fadeScrollbars属性，<code>android:fadeScrollbars=&quot;true&quot;</code>  配置ListView布局的时候，设置这个属性为true就可以实现滚动条的自动隐藏和显示。</li>
</ul>

<h2 id="toc_6">自定义View的方法</h2>

<h3 id="toc_7">常用方法</h3>

<ul>
<li><code>onFinishInflate()</code> 当View中所有的子控件均被映射成xml后触发</li>
<li><code>onMeasure(int, int)</code> 确定所有子元素的大小</li>
<li><code>onLayout(boolean, int, int, int, int)</code> 当View分配所有的子元素的大小和位置时触发</li>
<li><code>onSizeChanged(int, int, int, int)</code> 当view的大小发生变化时触发</li>
<li><code>onDraw(Canvas)</code> view渲染内容的细节</li>
<li><code>onKeyDown(int, KeyEvent)</code> 有按键按下后触发</li>
<li><code>onKeyUp(int, KeyEvent)</code> 有按键按下后弹起时触发</li>
<li><code>onTrackballEvent(MotionEvent)</code> 轨迹球事件</li>
<li><code>onTouchEvent(MotionEvent)</code> 触屏事件</li>
<li><code>onFocusChanged(boolean, int, Rect)</code> 当View获取或失去焦点时触发 </li>
<li><code>onWindowFocusChanged(boolean)</code> 当窗口包含的view获取或失去焦点时触发</li>
<li><code>onAttachedToWindow()</code> 当view被附着到一个窗口时触发</li>
<li><code>onDetachedFromWindow()</code> 当view离开附着的窗口时触发，提示该方法和  onAttachedToWindow() 是相反的。</li>
<li><code>onWindowVisibilityChanged(int)</code> 当窗口中包含的可见的view发生变化时触发</li>
</ul>

<h3 id="toc_8">公用方法</h3>

<ul>
<li><code>void addChildrenForAccessibility(ArrayList&lt;View&gt; outChildren)</code> 
Adds the children of this View relevant for accessibility to the given list as output.</li>
<li><code>void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo info, String extraDataKey, Bundle arguments)</code>
Adds extra data to an AccessibilityNodeInfo based on an explicit request for the additional data.</li>
<li><code>void addFocusables(ArrayList&lt;View&gt; views, int direction)</code>
Add any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views.</li>
<li><code>void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode)</code>
Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views.</li>
<li><code>void addKeyboardNavigationClusters(Collection&lt;View&gt; views, int direction)</code>
Adds any keyboard navigation cluster roots that are descendants of this view (possibly including this view if it is a cluster root itself) to views.</li>
<li><code>void addOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)</code>
Add a listener for attach state changes.</li>
<li><code>void addOnLayoutChangeListener(View.OnLayoutChangeListener listener)</code>
Add a listener that will be called when the bounds of the view change due to layout processing.</li>
<li><code>void addTouchables(ArrayList&lt;View&gt; views)</code>
Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself) to views.</li>
<li><code>ViewPropertyAnimator animate()</code>
This method returns a ViewPropertyAnimator object, which can be used to animate specific properties on this View.</li>
<li><code>void announceForAccessibility(CharSequence text)</code>
Convenience method for sending a TYPE_ANNOUNCEMENT AccessibilityEvent to make an announcement which is related to some sort of a context change for which none of the events representing UI transitions is a good fit.</li>
<li><code>void autoFill(AutoFillValue value)</code>
Automatically fills the content of this view with the value.</li>
<li><code>void autoFillVirtual(int virtualId, AutoFillValue value)</code>
Automatically fills the content of a virtual view with the value<br/>
See autoFill(AutoFillValue) and onProvideAutoFillVirtualStructure(ViewStructure, int) for more info.</li>
<li><code>void bringToFront()</code>
Change the view&#39;s z order in the tree, so it&#39;s on top of other sibling views.</li>
<li><code>void buildDrawingCache(boolean autoScale)</code>
Forces the drawing cache to be built if the drawing cache is invalid.</li>
<li><code>void buildDrawingCache()</code>
Calling this method is equivalent to calling buildDrawingCache(false).</li>
<li><code>void buildLayer()</code>
Forces this view&#39;s layer to be created and this view to be rendered into its layer.</li>
<li><code>boolean callOnClick()</code>
Directly call any attached OnClickListener.</li>
<li><code>boolean canResolveLayoutDirection()</code>
Check if layout direction resolution can be done.</li>
<li><code>boolean canResolveTextAlignment()</code>
Check if text alignment resolution can be done.</li>
<li><code>boolean canResolveTextDirection()</code>
Check if text direction resolution can be done.</li>
<li><code>boolean canScrollHorizontally(int direction)</code>
Check if this view can be scrolled horizontally in a certain direction.</li>
<li><code>boolean canScrollVertically(int direction)</code>
Check if this view can be scrolled vertically in a certain direction.</li>
<li><code>final void cancelDragAndDrop()</code>
Cancels an ongoing drag and drop operation.</li>
<li><code>void cancelLongPress()</code>
Cancels a pending long press.</li>
<li><code>final void cancelPendingInputEvents()</code>
Cancel any deferred high-level input events that were previously posted to the event queue.</li>
<li><code>boolean checkInputConnectionProxy(View view)</code>
Called by the InputMethodManager when a view who is not the current input connection target is trying to make a call on the manager.</li>
<li><code>void clearAnimation()</code>
Cancels any animations for this view.</li>
<li><code>void clearFocus()</code>
Called when this view wants to give up focus.<br/>
static int combineMeasuredStates(int curState, int newState)<br/>
Merge two states as returned by getMeasuredState().</li>
<li><code>void computeScroll()</code>
Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary.</li>
<li><code>WindowInsets computeSystemWindowInsets(WindowInsets in, Rect outLocalInsets)</code>
Compute insets that should be consumed by this view and the ones that should propagate to those under it.</li>
<li><code>AccessibilityNodeInfo createAccessibilityNodeInfo()</code>
Returns an AccessibilityNodeInfo representing this view from the point of view of an AccessibilityService.</li>
<li><code>void createContextMenu(ContextMenu menu)</code>
Show the context menu for this view.</li>
<li><code>void destroyDrawingCache()</code>
Frees the resources used by the drawing cache.</li>
<li><code>WindowInsets dispatchApplyWindowInsets(WindowInsets insets)</code>
Request to apply the given window insets to this view or another view in its subtree.</li>
<li><code>boolean dispatchCapturedPointerEvent(MotionEvent event)</code>
Pass a captured pointer event down to the focused view.</li>
<li><code>void dispatchConfigurationChanged(Configuration newConfig)</code>
Dispatch a notification about a resource configuration change down the view hierarchy.</li>
<li><code>void dispatchDisplayHint(int hint)</code>
Dispatch a hint about whether this view is displayed.</li>
<li><code>boolean dispatchDragEvent(DragEvent event)</code>
Detects if this View is enabled and has a drag event listener.</li>
<li><code>void dispatchDrawableHotspotChanged(float x, float y)</code>
Dispatches drawableHotspotChanged to all of this View&#39;s children.</li>
<li><code>void dispatchFinishTemporaryDetach()</code>
Dispatch onFinishTemporaryDetach() to this View and its direct children if this is a container View.</li>
<li><code>boolean dispatchGenericMotionEvent(MotionEvent event)</code>
Dispatch a generic motion event.</li>
<li><code>boolean dispatchKeyEvent(KeyEvent event)</code>
Dispatch a key event to the next view on the focus path.</li>
<li><code>boolean dispatchKeyEventPreIme(KeyEvent event)</code>
Dispatch a key event before it is processed by any input method associated with the view hierarchy.</li>
<li><code>boolean dispatchKeyShortcutEvent(KeyEvent event)</code>
Dispatches a key shortcut event.</li>
<li><code>boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed)</code>
Dispatch a fling to a nested scrolling parent.</li>
<li><code>boolean dispatchNestedPreFling(float velocityX, float velocityY)</code>
Dispatch a fling to a nested scrolling parent before it is processed by this view.</li>
<li><code>boolean dispatchNestedPrePerformAccessibilityAction(int action, Bundle arguments)</code>
Report an accessibility action to this view&#39;s parents for delegated processing.</li>
<li><code>boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)</code>
Dispatch one step of a nested scroll in progress before this view consumes any portion of it.</li>
<li><code>boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)</code>
Dispatch one step of a nested scroll in progress.</li>
<li><code>void dispatchPointerCaptureChanged(boolean hasCapture)</code></li>
<li><code>boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event)</code>
Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event.</li>
<li><code>void dispatchProvideAutoFillStructure(ViewStructure structure, int flags)</code>
Dispatch creation of ViewStructure down the hierarchy.</li>
<li><code>void dispatchProvideStructure(ViewStructure structure)</code>
Dispatch creation of ViewStructure down the hierarchy.</li>
<li><code>void dispatchStartTemporaryDetach()</code>
Dispatch onStartTemporaryDetach() to this View and its direct children if this is a container View.</li>
<li><code>void dispatchSystemUiVisibilityChanged(int visibility)</code>
Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener) down the view hierarchy.</li>
<li><code>boolean dispatchTouchEvent(MotionEvent event)</code>
Pass the touch screen motion event down to the target view, or this view if it is the target.</li>
<li><code>boolean dispatchTrackballEvent(MotionEvent event)</code>
Pass a trackball motion event down to the focused view.<br/>
boolean dispatchUnhandledMove(View focused, int direction)<br/>
This method is the last chance for the focused view and its ancestors to respond to an arrow key.</li>
<li><code>void dispatchWindowFocusChanged(boolean hasFocus)</code>
Called when the window containing this view gains or loses window focus.</li>
<li><code>void dispatchWindowSystemUiVisiblityChanged(int visible)</code>
Dispatch callbacks to onWindowSystemUiVisibilityChanged(int) down the view hierarchy.</li>
<li><code>void dispatchWindowVisibilityChanged(int visibility)</code>
Dispatch a window visibility change down the view hierarchy.</li>
<li><code>void draw(Canvas canvas)</code>
Manually render this view (and all of its children) to the given Canvas.</li>
<li><code>void drawableHotspotChanged(float x, float y)</code>
This function is called whenever the view hotspot changes and needs to be propagated to drawables or child views managed by the view.</li>
<li><code>View findFocus()</code>
Find the view in the hierarchy rooted at this view that currently has focus.</li>
<li><code>final &lt;T extends View&gt; T findViewById(int id)</code>
Look for a child view with the given id.</li>
<li><code>final &lt;T extends View&gt; T findViewWithTag(Object tag)</code>
Look for a child view with the given tag.</li>
<li><code>void findViewsWithText(ArrayList&lt;View&gt; outViews, CharSequence searched, int flags)</code>
Finds the Views that contain given text.</li>
<li><code>View focusSearch(int direction)</code>
Find the nearest view in the specified direction that can take focus.</li>
<li><code>void forceHasOverlappingRendering(boolean hasOverlappingRendering)</code>
Sets the behavior for overlapping rendering for this view (see hasOverlappingRendering() for more details on this behavior).</li>
<li><code>void forceLayout()</code>
Forces this view to be laid out during the next layout pass.</li>
<li><code>static int generateViewId()</code>
Generate a value suitable for use in setId(int).</li>
<li><code>CharSequence getAccessibilityClassName()</code>
Return the class name of this object to be used for accessibility purposes.</li>
<li><code>int getAccessibilityLiveRegion()</code>
Gets the live region mode for this View.</li>
<li><code>AccessibilityNodeProvider getAccessibilityNodeProvider()</code>
Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content.</li>
<li><code>int getAccessibilityTraversalAfter()</code>
Gets the id of a view after which this one is visited in accessibility traversal.</li>
<li><code>int getAccessibilityTraversalBefore()</code>
Gets the id of a view before which this one is visited in accessibility traversal.</li>
<li><code>float getAlpha()</code>
The opacity of the view.</li>
<li><code>Animation getAnimation()</code>
Get the animation currently associated with this view.</li>
<li><code>IBinder getApplicationWindowToken()</code>
Retrieve a unique token identifying the top-level &quot;real&quot; window of the window that this view is attached to.</li>
<li><code>int getAutoFillMode()</code>
Returns the auto-fill mode for this view.</li>
<li><code>AutoFillType getAutoFillType()</code>
Describes the auto-fill type that should be used on calls to autoFill(AutoFillValue) and autoFillVirtual(int, AutoFillValue).</li>
<li><code>AutoFillValue getAutoFillValue()</code>
Gets the View&#39;s current auto-fill value.</li>
<li><code>Drawable getBackground()</code>
Gets the background drawable</li>
<li><code>ColorStateList getBackgroundTintList()</code>
Return the tint applied to the background drawable, if specified.</li>
<li><code>PorterDuff.Mode getBackgroundTintMode()</code>
Return the blending mode used to apply the tint to the background drawable, if specified.</li>
<li><code>int getBaseline()</code>
Return the offset of the widget&#39;s text baseline from the widget&#39;s top boundary.</li>
<li><code>final int getBottom()</code>
Bottom position of this view relative to its parent.</li>
<li><code>float getCameraDistance()</code>
Gets the distance along the Z axis from the camera to this view.</li>
<li><code>boolean getClipBounds(Rect outRect)</code>
Populates an output rectangle with the clip bounds of the view, returning true if successful or false if the view&#39;s clip bounds are null.</li>
<li><code>Rect getClipBounds()</code>
Returns a copy of the current clipBounds.</li>
<li><code>final boolean getClipToOutline()</code>
Returns whether the Outline should be used to clip the contents of the View.</li>
<li><code>CharSequence getContentDescription()</code>
Returns the View&#39;s content description.</li>
<li><code>final Context getContext()</code>
Returns the context the view is running in, through which it can access the current theme, resources, etc.</li>
<li><code>static int getDefaultSize(int size, int measureSpec)</code>
Utility to return a default size.</li>
<li><code>Display getDisplay()</code>
Gets the logical display to which the view&#39;s window has been attached.</li>
<li><code>final int[] getDrawableState()</code>
Return an array of resource IDs of the drawable states representing the current state of the view.</li>
<li><code>Bitmap getDrawingCache()</code>
Calling this method is equivalent to calling getDrawingCache(false).</li>
<li><code>Bitmap getDrawingCache(boolean autoScale)</code>
Returns the bitmap in which this view drawing is cached.</li>
<li><code>int getDrawingCacheBackgroundColor()</code></li>
<li><code>int getDrawingCacheQuality()</code>
Returns the quality of the drawing cache.</li>
<li><code>void getDrawingRect(Rect outRect)</code>
Return the visible drawing bounds of your view.</li>
<li><code>long getDrawingTime()</code>
Return the time at which the drawing of the view hierarchy started.</li>
<li><code>float getElevation()</code>
The base elevation of this view relative to its parent, in pixels.</li>
<li><code>boolean getFilterTouchesWhenObscured()</code>
Gets whether the framework should discard touches when the view&#39;s window is obscured by another visible window.</li>
<li><code>boolean getFitsSystemWindows()</code>
Check for state of setFitsSystemWindows(boolean).</li>
<li><code>int getFocusable()</code>
Returns the focusable setting for this view.</li>
<li><code>ArrayList&lt;View&gt; getFocusables(int direction)</code>
Find and return all focusable views that are descendants of this view, possibly including this view if it is focusable itself.</li>
<li><code>void getFocusedRect(Rect r)</code>
When a view has focus and the user navigates away from it, the next view is searched for starting from the rectangle filled in by this method.</li>
<li><code>Drawable getForeground()</code>
Returns the drawable used as the foreground of this View.</li>
<li><code>int getForegroundGravity()</code>
Describes how the foreground is positioned.</li>
<li><code>ColorStateList getForegroundTintList()</code>
Return the tint applied to the foreground drawable, if specified.</li>
<li><code>PorterDuff.Mode getForegroundTintMode()</code>
Return the blending mode used to apply the tint to the foreground drawable, if specified.</li>
<li><code>final boolean getGlobalVisibleRect(Rect r)</code></li>
<li><code>boolean getGlobalVisibleRect(Rect r, Point globalOffset)</code>
If some part of this view is not clipped by any of its parents, then return that area in r in global (root) coordinates.</li>
<li><code>Handler getHandler()</code></li>
<li><code>final boolean getHasOverlappingRendering()</code>
Returns the value for overlapping rendering that is used internally.</li>
<li><code>final int getHeight()</code>
Return the height of your view.</li>
<li><code>void getHitRect(Rect outRect)</code>
Hit rectangle in parent&#39;s coordinates</li>
<li><code>int getHorizontalFadingEdgeLength()</code>
Returns the size of the horizontal faded edges used to indicate that more content in this view is visible.</li>
<li><code>int getId()</code>
Returns this view&#39;s identifier.<br/>
int getImportantForAccessibility()<br/>
Gets the mode for determining whether this View is important for accessibility.</li>
<li><code>boolean getKeepScreenOn()</code>
Returns whether the screen should remain on, corresponding to the current value of KEEP_SCREEN_ON.</li>
<li><code>KeyEvent.DispatcherState getKeyDispatcherState()</code>
Return the global KeyEvent.DispatcherState for this view&#39;s window.</li>
<li><code>int getLabelFor()</code>
Gets the id of a view for which this view serves as a label for accessibility purposes.</li>
<li><code>int getLayerType()</code>
Indicates what type of layer is currently associated with this view.</li>
<li><code>int getLayoutDirection()</code>
Returns the resolved layout direction for this view.</li>
<li><code>ViewGroup.LayoutParams getLayoutParams()</code>
Get the LayoutParams associated with this view.</li>
<li><code>final int getLeft()</code>
Left position of this view relative to its parent.</li>
<li><code>final boolean getLocalVisibleRect(Rect r)</code></li>
<li><code>void getLocationInWindow(int[] outLocation)</code>
Computes the coordinates of this view in its window.</li>
<li><code>void getLocationOnScreen(int[] outLocation)</code>
Computes the coordinates of this view on the screen.</li>
<li><code>Matrix getMatrix()</code>
The transform matrix of this view, which is calculated based on the current rotation, scale, and pivot properties.</li>
<li><code>final int getMeasuredHeight()</code>
Like getMeasuredHeightAndState(), but only returns the raw height component (that is the result is masked by MEASURED_SIZE_MASK).</li>
<li><code>final int getMeasuredHeightAndState()</code>
Return the full height measurement information for this view as computed by the most recent call to measure(int, int).</li>
<li><code>final int getMeasuredState()</code>
Return only the state bits of getMeasuredWidthAndState() and getMeasuredHeightAndState(), combined into one integer.</li>
<li><code>final int getMeasuredWidth()</code>
Like getMeasuredWidthAndState(), but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK).</li>
<li><code>final int getMeasuredWidthAndState()</code>
Return the full width measurement information for this view as computed by the most recent call to measure(int, int).</li>
<li><code>int getMinimumHeight()</code>
Returns the minimum height of the view.</li>
<li><code>int getMinimumWidth()</code>
Returns the minimum width of the view.</li>
<li><code>int getNextClusterForwardId()</code>
Gets the id of the root of the next keyboard navigation cluster.</li>
<li><code>int getNextFocusDownId()</code>
Gets the id of the view to use when the next focus is FOCUS_DOWN.</li>
<li><code>int getNextFocusForwardId()</code>
Gets the id of the view to use when the next focus is FOCUS_FORWARD.</li>
<li><code>int getNextFocusLeftId()</code>
Gets the id of the view to use when the next focus is FOCUS_LEFT.</li>
<li><code>int getNextFocusRightId()</code>
Gets the id of the view to use when the next focus is FOCUS_RIGHT.</li>
<li><code>int getNextFocusUpId()</code>
Gets the id of the view to use when the next focus is FOCUS_UP.<br/>
View.OnFocusChangeListener getOnFocusChangeListener()<br/>
Returns the focus-change callback registered for this view.</li>
<li><code>ViewOutlineProvider getOutlineProvider()</code>
Returns the current ViewOutlineProvider of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping.</li>
<li><code>int getOverScrollMode()</code>
Returns the over-scroll mode for this view.</li>
<li><code>ViewOverlay getOverlay()</code>
Returns the overlay for this view, creating it if it does not yet exist.</li>
<li><code>int getPaddingBottom()</code>
Returns the bottom padding of this view.</li>
<li><code>int getPaddingEnd()</code>
Returns the end padding of this view depending on its resolved layout direction.</li>
<li><code>int getPaddingLeft()</code>
Returns the left padding of this view.</li>
<li><code>int getPaddingRight()</code>
Returns the right padding of this view.</li>
<li><code>int getPaddingStart()</code>
Returns the start padding of this view depending on its resolved layout direction.</li>
<li><code>int getPaddingTop()</code>
Returns the top padding of this view.</li>
<li><code>final ViewParent getParent()</code>
Gets the parent of this view.</li>
<li><code>ViewParent getParentForAccessibility()</code>
Gets the parent for accessibility purposes.</li>
<li><code>float getPivotX()</code>
The x location of the point around which the view is rotated and scaled.</li>
<li><code>float getPivotY()</code>
The y location of the point around which the view is rotated and scaled.</li>
<li><code>PointerIcon getPointerIcon()</code>
Gets the pointer icon for the current view.</li>
<li><code>Resources getResources()</code>
Returns the resources associated with this view.</li>
<li><code>final boolean getRevealOnFocusHint()</code>
Returns this view&#39;s preference for reveal behavior when it gains focus.</li>
<li><code>final int getRight()</code>
Right position of this view relative to its parent.</li>
<li><code>View getRootView()</code>
Finds the topmost view in the current view hierarchy.</li>
<li><code>WindowInsets getRootWindowInsets()</code>
Provide original WindowInsets that are dispatched to the view hierarchy.</li>
<li><code>float getRotation()</code>
The degrees that the view is rotated around the pivot point.</li>
<li><code>float getRotationX()</code>
The degrees that the view is rotated around the horizontal axis through the pivot point.</li>
<li><code>float getRotationY()</code>
The degrees that the view is rotated around the vertical axis through the pivot point.</li>
<li><code>float getScaleX()</code>
The amount that the view is scaled in x around the pivot point, as a proportion of the view&#39;s unscaled width.</li>
<li><code>float getScaleY()</code>
The amount that the view is scaled in y around the pivot point, as a proportion of the view&#39;s unscaled height.</li>
<li><code>int getScrollBarDefaultDelayBeforeFade()</code>
Returns the delay before scrollbars fade.</li>
<li><code>int getScrollBarFadeDuration()</code>
Returns the scrollbar fade duration.</li>
<li><code>int getScrollBarSize()</code>
Returns the scrollbar size.</li>
<li><code>int getScrollBarStyle()</code>
Returns the current scrollbar style.</li>
<li><code>int getScrollIndicators()</code>
Returns a bitmask representing the enabled scroll indicators.</li>
<li><code>final int getScrollX()</code>
Return the scrolled left position of this view.</li>
<li><code>final int getScrollY()</code>
Return the scrolled top position of this view.</li>
<li><code>int getSolidColor()</code>
Override this if your view is known to always be drawn on top of a solid color background, and needs to draw fading edges.<br/>
StateListAnimator getStateListAnimator()<br/>
Returns the current StateListAnimator if exists.</li>
<li><code>int getSystemUiVisibility()</code>
Returns the last setSystemUiVisibility(int) that this view has requested.</li>
<li><code>Object getTag()</code>
Returns this view&#39;s tag.</li>
<li><code>Object getTag(int key)</code>
Returns the tag associated with this view and the specified key.</li>
<li><code>int getTextAlignment()</code>
Return the resolved text alignment.</li>
<li><code>int getTextDirection()</code>
Return the resolved text direction.</li>
<li><code>CharSequence getTooltipText()</code>
Returns the view&#39;s tooltip text.</li>
<li><code>final int getTop()</code>
Top position of this view relative to its parent.</li>
<li><code>TouchDelegate getTouchDelegate()</code>
Gets the TouchDelegate for this View.</li>
<li><code>ArrayList&lt;View&gt; getTouchables()</code>
Find and return all touchable views that are descendants of this view, possibly including this view if it is touchable itself.</li>
<li><code>String getTransitionName()</code>
Returns the name of the View to be used to identify Views in Transitions.</li>
<li><code>float getTranslationX()</code>
The horizontal location of this view relative to its left position.</li>
<li><code>float getTranslationY()</code>
The vertical location of this view relative to its top position.</li>
<li><code>float getTranslationZ()</code>
The depth location of this view relative to its elevation.</li>
<li><code>int getVerticalFadingEdgeLength()</code>
Returns the size of the vertical faded edges used to indicate that more content in this view is visible.</li>
<li><code>int getVerticalScrollbarPosition()</code></li>
<li><code>int getVerticalScrollbarWidth()</code>
Returns the width of the vertical scrollbar.</li>
<li><code>ViewTreeObserver getViewTreeObserver()</code>
Returns the ViewTreeObserver for this view&#39;s hierarchy.</li>
<li><code>int getVisibility()</code>
Returns the visibility status for this view.</li>
<li><code>final int getWidth()</code>
Return the width of the your view.</li>
<li><code>WindowId getWindowId()</code>
Retrieve the WindowId for the window this view is currently attached to.</li>
<li><code>int getWindowSystemUiVisibility()</code>
Returns the current system UI visibility that is currently set for the entire window.</li>
<li><code>IBinder getWindowToken()</code>
Retrieve a unique token identifying the window this view is attached to.</li>
<li><code>int getWindowVisibility()</code>
Returns the current visibility of the window this view is attached to (either GONE, INVISIBLE, or VISIBLE).</li>
<li><code>void getWindowVisibleDisplayFrame(Rect outRect)</code>
Retrieve the overall visible display size in which the window this view is attached to has been positioned in.</li>
<li><code>float getX()</code>
The visual x position of this view, in pixels.</li>
<li><code>float getY()</code>
The visual y position of this view, in pixels.</li>
<li><code>float getZ()</code>
The visual z position of this view, in pixels.</li>
<li><code>boolean hasExplicitFocusable()</code>
Returns true if this view is focusable or if it contains a reachable View for which hasExplicitFocusable() returns true.</li>
<li><code>boolean hasFocus()</code>
Returns true if this view has focus itself, or is the ancestor of the view that has focus.</li>
<li><code>boolean hasFocusable()</code>
Returns true if this view is focusable or if it contains a reachable View for which hasFocusable() returns true.</li>
<li><code>boolean hasNestedScrollingParent()</code>
Returns true if this view has a nested scrolling parent.</li>
<li><code>boolean hasOnClickListeners()</code>
Return whether this view has an attached OnClickListener.</li>
<li><code>boolean hasOverlappingRendering()</code>
Returns whether this View has content which overlaps.</li>
<li><code>boolean hasPointerCapture()</code>
Checks pointer capture status.</li>
<li><code>boolean hasTransientState()</code>
Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible.</li>
<li><code>boolean hasWindowFocus()</code>
Returns true if this view is in a window that currently has window focus.</li>
<li><code>static View inflate(Context context, int resource, ViewGroup root)</code>
Inflate a view from an XML resource.</li>
<li><code>void invalidate()</code>
Invalidate the whole view.</li>
<li><code>void invalidate(Rect dirty)</code>
Mark the area defined by dirty as needing to be drawn.</li>
<li><code>void invalidate(int l, int t, int r, int b)</code>
Mark the area defined by the rect (l,t,r,b) as needing to be drawn.</li>
<li><code>void invalidateDrawable(Drawable drawable)</code>
Invalidates the specified Drawable.</li>
<li><code>void invalidateOutline()</code>
Called to rebuild this View&#39;s Outline from its outline provider</li>
<li><code>boolean isAccessibilityFocused()</code>
Returns whether this View is accessibility focused.</li>
<li><code>boolean isActivated()</code>
Indicates the activation state of this view.</li>
<li><code>boolean isAttachedToWindow()</code>
Returns true if this view is currently attached to a window.</li>
<li><code>boolean isClickable()</code>
Indicates whether this view reacts to click events or not.</li>
<li><code>boolean isContextClickable()</code>
Indicates whether this view reacts to context clicks or not.</li>
<li><code>boolean isDirty()</code>
True if this view has changed since the last time being drawn.</li>
<li><code>boolean isDrawingCacheEnabled()</code>
Indicates whether the drawing cache is enabled for this view.</li>
<li><code>boolean isDuplicateParentStateEnabled()</code>
Indicates whether this duplicates its drawable state from its parent.</li>
<li><code>boolean isEnabled()</code>
Returns the enabled status for this view.</li>
<li><code>final boolean isFocusable()</code>
Returns whether this View is currently able to take focus.</li>
<li><code>final boolean isFocusableInTouchMode()</code>
When a view is focusable, it may not want to take focus when in touch mode.</li>
<li><code>boolean isFocused()</code>
Returns true if this view has focus</li>
<li><code>final boolean isFocusedByDefault()</code>
Returns whether this View should receive focus when the focus is restored for the view hierarchy containing this view.</li>
<li><code>boolean isHapticFeedbackEnabled()</code></li>
<li><code>boolean isHardwareAccelerated()</code>
Indicates whether this view is attached to a hardware accelerated window or not.</li>
<li><code>boolean isHorizontalFadingEdgeEnabled()</code>
Indicate whether the horizontal edges are faded when the view is scrolled horizontally.</li>
<li><code>boolean isHorizontalScrollBarEnabled()</code>
Indicate whether the horizontal scrollbar should be drawn or not.</li>
<li><code>boolean isHovered()</code>
Returns true if the view is currently hovered.</li>
<li><code>boolean isImportantForAccessibility()</code>
Computes whether this view should be exposed for accessibility.</li>
<li><code>boolean isInEditMode()</code>
Indicates whether this View is currently in edit mode.</li>
<li><code>boolean isInLayout()</code>
Returns whether the view hierarchy is currently undergoing a layout pass.</li>
<li><code>boolean isInTouchMode()</code>
Returns whether the device is currently in touch mode.</li>
<li><code>final boolean isKeyboardNavigationCluster()</code>
Returns whether this View is a root of a keyboard navigation cluster.</li>
<li><code>boolean isLaidOut()</code>
Returns true if this view has been through at least one layout since it was last attached to or detached from a window.</li>
<li><code>boolean isLayoutDirectionResolved()</code></li>
<li><code>boolean isLayoutRequested()</code>
Indicates whether or not this view&#39;s layout will be requested during the next hierarchy layout pass.</li>
<li><code>boolean isLongClickable()</code>
Indicates whether this view reacts to long click events or not.</li>
<li><code>boolean isNestedScrollingEnabled()</code>
Returns true if nested scrolling is enabled for this view.</li>
<li><code>boolean isOpaque()</code>
Indicates whether this View is opaque.</li>
<li><code>boolean isPaddingRelative()</code>
Return if the padding has been set through relative values setPaddingRelative(int, int, int, int) or through</li>
<li><code>boolean isPressed()</code>
Indicates whether the view is currently in pressed state.</li>
<li><code>boolean isSaveEnabled()</code>
Indicates whether this view will save its state (that is, whether its onSaveInstanceState() method will be called).</li>
<li><code>boolean isSaveFromParentEnabled()</code>
Indicates whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent.</li>
<li><code>boolean isScrollContainer()</code>
Indicates whether this view is one of the set of scrollable containers in its window.</li>
<li><code>boolean isScrollbarFadingEnabled()</code>
Returns true if scrollbars will fade when this view is not scrolling</li>
<li><code>boolean isSelected()</code>
Indicates the selection state of this view.</li>
<li><code>boolean isShown()</code>
Returns the visibility of this view and all of its ancestors</li>
<li><code>boolean isSoundEffectsEnabled()</code></li>
<li><code>final boolean isTemporarilyDetached()</code>
Tells whether the View is in the state between onStartTemporaryDetach() and onFinishTemporaryDetach().</li>
<li><code>boolean isTextAlignmentResolved()</code></li>
<li><code>boolean isTextDirectionResolved()</code></li>
<li><code>boolean isVerticalFadingEdgeEnabled()</code>
Indicate whether the vertical edges are faded when the view is scrolled horizontally.</li>
<li><code>boolean isVerticalScrollBarEnabled()</code>
Indicate whether the vertical scrollbar should be drawn or not.</li>
<li><code>void jumpDrawablesToCurrentState()</code>
Call Drawable.jumpToCurrentState() on all Drawable objects associated with this view.</li>
<li><code>View keyboardNavigationClusterSearch(View currentCluster, int direction)</code>
Find the nearest keyboard navigation cluster in the specified direction.</li>
<li><code>void layout(int l, int t, int r, int b)</code>
Assign a size and position to a view and all of its descendants<br/>
This is the second phase of the layout mechanism.</li>
<li><code>final void measure(int widthMeasureSpec, int heightMeasureSpec)</code>
This is called to find out how big a view should be.</li>
<li><code>void offsetLeftAndRight(int offset)</code>
Offset this view&#39;s horizontal location by the specified amount of pixels.</li>
<li><code>void offsetTopAndBottom(int offset)</code>
Offset this view&#39;s vertical location by the specified number of pixels.</li>
<li><code>WindowInsets onApplyWindowInsets(WindowInsets insets)</code>
Called when the view should apply WindowInsets according to its internal policy.</li>
<li><code>void onCancelPendingInputEvents()</code>
Called as the result of a call to cancelPendingInputEvents() on this view or a parent view.</li>
<li><code>boolean onCapturedPointerEvent(MotionEvent event)</code>
Implement this method to handle captured pointer events</li>
<li><code>boolean onCheckIsTextEditor()</code>
Check whether the called view is a text editor, in which case it would make sense to automatically display a soft input window for it.</li>
<li><code>InputConnection onCreateInputConnection(EditorInfo outAttrs)</code>
Create a new InputConnection for an InputMethod to interact with the view.</li>
<li><code>boolean onDragEvent(DragEvent event)</code>
Handles drag events sent by the system following a call to startDragAndDrop().</li>
<li><code>void onDrawForeground(Canvas canvas)</code>
Draw any foreground content for this view.</li>
<li><code>boolean onFilterTouchEventForSecurity(MotionEvent event)</code>
Filter the touch event to apply security policies.</li>
<li><code>void onFinishTemporaryDetach()</code>
Called after onStartTemporaryDetach() when the container is done changing the view.</li>
<li><code>boolean onGenericMotionEvent(MotionEvent event)</code>
Implement this method to handle generic motion events.</li>
<li><code>void onHoverChanged(boolean hovered)</code>
Implement this method to handle hover state changes.</li>
<li><code>boolean onHoverEvent(MotionEvent event)</code>
Implement this method to handle hover events.</li>
<li><code>void onInitializeAccessibilityEvent(AccessibilityEvent event)</code>
Initializes an AccessibilityEvent with information about this View which is the event source.</li>
<li><code>void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info)</code>
Initializes an AccessibilityNodeInfo with information about this view.</li>
<li><code>boolean onKeyDown(int keyCode, KeyEvent event)</code>
Default implementation of KeyEvent.Callback.onKeyDown(): perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable.</li>
<li><code>boolean onKeyLongPress(int keyCode, KeyEvent event)</code>
Default implementation of KeyEvent.Callback.onKeyLongPress(): always returns false (doesn&#39;t handle the event).</li>
<li><code>boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)</code>
Default implementation of KeyEvent.Callback.onKeyMultiple(): always returns false (doesn&#39;t handle the event).</li>
<li><code>boolean onKeyPreIme(int keyCode, KeyEvent event)</code>
Handle a key event before it is processed by any input method associated with the view hierarchy.</li>
<li><code>boolean onKeyShortcut(int keyCode, KeyEvent event)</code>
Called on the focused view when a key shortcut event is not handled.</li>
<li><code>boolean onKeyUp(int keyCode, KeyEvent event)</code>
Default implementation of KeyEvent.Callback.onKeyUp(): perform clicking of the view when KEYCODE_DPAD_CENTER, KEYCODE_ENTER or KEYCODE_SPACE is released.</li>
<li><code>void onMovedToDisplay(int displayId)</code>
Called by the system when the hosting activity is moved from one display to another without recreation.</li>
<li><code>void onPointerCaptureChange(boolean hasCapture)</code>
Called when the window has just acquired or lost pointer capture.</li>
<li><code>void onPopulateAccessibilityEvent(AccessibilityEvent event)</code>
Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent) giving a chance to this View to populate the accessibility event with its text content.</li>
<li><code>void onProvideAutoFillStructure(ViewStructure structure, int flags)</code>
Called when assist structure is being retrieved from a view as part of an auto-fill request.</li>
<li><code>void onProvideAutoFillVirtualStructure(ViewStructure structure, int flags)</code>
Called when assist structure is being retrieved from a view as part of an auto-fill request to generate additional virtual structure under this view.</li>
<li><code>void onProvideStructure(ViewStructure structure)</code>
Called when assist structure is being retrieved from a view as part of Activity.onProvideAssistData.</li>
<li><code>void onProvideVirtualStructure(ViewStructure structure)</code>
Called when assist structure is being retrieved from a view as part of Activity.onProvideAssistData to generate additional virtual structure under this view.</li>
<li><code>PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)</code>
Returns the pointer icon for the motion event, or null if it doesn&#39;t specify the icon.</li>
<li><code>void onRtlPropertiesChanged(int layoutDirection)</code>
Called when any RTL property (layout direction or text direction or text alignment) has been changed.</li>
<li><code>void onScreenStateChanged(int screenState)</code>
This method is called whenever the state of the screen this view is attached to changes.</li>
<li><code>void onStartTemporaryDetach()</code>
This is called when a container is going to temporarily detach a child, with ViewGroup.detachViewFromParent.</li>
<li><code>boolean onTouchEvent(MotionEvent event)</code>
Implement this method to handle touch screen motion events.</li>
<li><code>boolean onTrackballEvent(MotionEvent event)</code>
Implement this method to handle trackball motion events.</li>
<li><code>void onVisibilityAggregated(boolean isVisible)</code>
Called when the user-visibility of this View is potentially affected by a change to this view itself, an ancestor view or the window this view is attached to.</li>
<li><code>void onWindowFocusChanged(boolean hasWindowFocus)</code>
Called when the window containing this view gains or loses focus.</li>
<li><code>void onWindowSystemUiVisibilityChanged(int visible)</code>
Override to find out when the window&#39;s requested system UI visibility has changed, that is the value returned by getWindowSystemUiVisibility().</li>
<li><code>boolean performAccessibilityAction(int action, Bundle arguments)</code>
Performs the specified accessibility action on the view.</li>
<li><code>boolean performClick()</code>
Call this view&#39;s OnClickListener, if it is defined.</li>
<li><code>boolean performContextClick(float x, float y)</code>
Call this view&#39;s OnContextClickListener, if it is defined.</li>
<li><code>boolean performContextClick()</code>
Call this view&#39;s OnContextClickListener, if it is defined.</li>
<li><code>boolean performHapticFeedback(int feedbackConstant)</code>
Provide haptic feedback to the user for this view.</li>
<li><code>boolean performHapticFeedback(int feedbackConstant, int flags)</code>
Like performHapticFeedback(int), with additional options.</li>
<li><code>boolean performLongClick(float x, float y)</code>
Calls this view&#39;s OnLongClickListener, if it is defined.</li>
<li><code>boolean performLongClick()</code>
Calls this view&#39;s OnLongClickListener, if it is defined.</li>
<li><code>void playSoundEffect(int soundConstant)</code>
Play a sound effect for this view.</li>
<li><code>boolean post(Runnable action)</code>
Causes the Runnable to be added to the message queue.</li>
<li><code>boolean postDelayed(Runnable action, long delayMillis)</code>
Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses.</li>
<li><code>void postInvalidate()</code>
Cause an invalidate to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidate(int left, int top, int right, int bottom)</code>
Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom)</code>
Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateDelayed(long delayMilliseconds)</code>
Cause an invalidate to happen on a subsequent cycle through the event loop.</li>
<li><code>void postInvalidateOnAnimation(int left, int top, int right, int bottom)</code>
Cause an invalidate of the specified area to happen on the next animation time step, typically the next display frame.</li>
<li><code>void postInvalidateOnAnimation()</code>
Cause an invalidate to happen on the next animation time step, typically the next display frame.</li>
<li><code>void postOnAnimation(Runnable action)</code>
Causes the Runnable to execute on the next animation time step.<br/>
void postOnAnimationDelayed(Runnable action, long delayMillis)<br/>
Causes the Runnable to execute on the next animation time step, after the specified amount of time elapses.</li>
<li><code>void refreshDrawableState()</code>
Call this to force a view to update its drawable state.</li>
<li><code>void releasePointerCapture()</code>
Releases the pointer capture.</li>
<li><code>boolean removeCallbacks(Runnable action)</code>
Removes the specified Runnable from the message queue.</li>
<li><code>void removeOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)</code>
Remove a listener for attach state changes.</li>
<li><code>void removeOnLayoutChangeListener(View.OnLayoutChangeListener listener)</code>
Remove a listener for layout changes.</li>
<li><code>void requestApplyInsets()</code>
Ask that a new dispatch of onApplyWindowInsets(WindowInsets) be performed.</li>
<li><code>void requestFitSystemWindows()</code>
This method was deprecated in API level 20. Use requestApplyInsets() for newer platform versions.</li>
<li><code>final boolean requestFocus(int direction)</code>
Call this to try to give focus to a specific view or to one of its descendants and give it a hint about what direction focus is heading.</li>
<li><code>final boolean requestFocus()</code>
Call this to try to give focus to a specific view or to one of its descendants.</li>
<li><code>boolean requestFocus(int direction, Rect previouslyFocusedRect)</code>
Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from.</li>
<li><code>final boolean requestFocusFromTouch()</code>
Call this to try to give focus to a specific view or to one of its descendants.</li>
<li><code>void requestLayout()</code>
Call this when something has changed which has invalidated the layout of this view.</li>
<li><code>void requestPointerCapture()</code>
Requests pointer capture mode.</li>
<li><code>boolean requestRectangleOnScreen(Rect rectangle)</code>
Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough.</li>
<li><code>boolean requestRectangleOnScreen(Rect rectangle, boolean immediate)</code>
Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough.</li>
<li><code>final void requestUnbufferedDispatch(MotionEvent event)</code>
Request unbuffered dispatch of the given stream of MotionEvents to this View.</li>
<li><code>static int resolveSize(int size, int measureSpec)</code>
Version of resolveSizeAndState(int, int, int) returning only the MEASURED_SIZE_MASK bits of the result.</li>
<li><code>static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState)</code>
Utility to reconcile a desired size and state, with constraints imposed by a MeasureSpec.</li>
<li><code>boolean restoreDefaultFocus()</code>
Gives focus to the default-focus view in the view hierarchy that has this view as a root.</li>
<li><code>void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container)</code>
Restore this view hierarchy&#39;s frozen state from the given container.</li>
<li><code>void saveHierarchyState(SparseArray&lt;Parcelable&gt; container)</code>
Store this view hierarchy&#39;s frozen state into the given container.</li>
<li><code>void scheduleDrawable(Drawable who, Runnable what, long when)</code>
Schedules an action on a drawable to occur at a specified time.</li>
<li><code>void scrollBy(int x, int y)</code>
Move the scrolled position of your view.</li>
<li><code>void scrollTo(int x, int y)</code>
Set the scrolled position of your view.</li>
<li><code>void sendAccessibilityEvent(int eventType)</code>
Sends an accessibility event of the given type.</li>
<li><code>void sendAccessibilityEventUnchecked(AccessibilityEvent event)</code>
This method behaves exactly as sendAccessibilityEvent(int) but takes as an argument an empty AccessibilityEvent and does not perform a check whether accessibility is enabled.</li>
<li><code>void setAccessibilityDelegate(View.AccessibilityDelegate delegate)</code>
Sets a delegate for implementing accessibility support via composition (as opposed to inheritance).</li>
<li><code>void setAccessibilityLiveRegion(int mode)</code>
Sets the live region mode for this view.</li>
<li><code>void setAccessibilityTraversalAfter(int afterId)</code>
Sets the id of a view after which this one is visited in accessibility traversal.</li>
<li><code>void setAccessibilityTraversalBefore(int beforeId)</code>
Sets the id of a view before which this one is visited in accessibility traversal.</li>
<li><code>void setActivated(boolean activated)</code>
Changes the activated state of this view.</li>
<li><code>void setAlpha(float alpha)</code>
Sets the opacity of the view to a value from 0 to 1, where 0 means the view is completely transparent and 1 means the view is completely opaque.</li>
<li><code>void setAnimation(Animation animation)</code>
Sets the next animation to play for this view.</li>
<li><code>void setAutoFillMode(int autoFillMode)</code>
Set auto-fill mode for the view.</li>
<li><code>void setBackground(Drawable background)</code>
Set the background to a given Drawable, or remove the background.</li>
<li><code>void setBackgroundColor(int color)</code>
Sets the background color for this view.</li>
<li><code>void setBackgroundDrawable(Drawable background)</code>
This method was deprecated in API level 16. use setBackground(Drawable) instead</li>
<li><code>void setBackgroundResource(int resid)</code>
Set the background to a given resource.</li>
<li><code>void setBackgroundTintList(ColorStateList tint)</code>
Applies a tint to the background drawable.</li>
<li><code>void setBackgroundTintMode(PorterDuff.Mode tintMode)</code>
Specifies the blending mode used to apply the tint specified by setBackgroundTintList(ColorStateList)} to the background drawable.</li>
<li><code>final void setBottom(int bottom)</code>
Sets the bottom position of this view relative to its parent.</li>
<li><code>void setCameraDistance(float distance)</code>
Sets the distance along the Z axis (orthogonal to the X/Y plane on which views are drawn) from the camera to this view.</li>
<li><code>void setClickable(boolean clickable)</code>
Enables or disables click events for this view.</li>
<li><code>void setClipBounds(Rect clipBounds)</code>
Sets a rectangular area on this view to which the view will be clipped when it is drawn.</li>
<li><code>void setClipToOutline(boolean clipToOutline)</code>
Sets whether the View&#39;s Outline should be used to clip the contents of the View.</li>
<li><code>void setContentDescription(CharSequence contentDescription)</code>
Sets the View&#39;s content description.</li>
<li><code>void setContextClickable(boolean contextClickable)</code>
Enables or disables context clicking for this view.</li>
<li><code>void setDrawingCacheBackgroundColor(int color)</code>
Setting a solid background color for the drawing cache&#39;s bitmaps will improve performance and memory usage.</li>
<li><code>void setDrawingCacheEnabled(boolean enabled)</code>
Enables or disables the drawing cache.</li>
<li><code>void setDrawingCacheQuality(int quality)</code>
Set the drawing cache quality of this view.</li>
<li><code>void setDuplicateParentStateEnabled(boolean enabled)</code>
Enables or disables the duplication of the parent&#39;s state into this view.</li>
<li><code>void setElevation(float elevation)</code>
Sets the base elevation of this view, in pixels.</li>
<li><code>void setEnabled(boolean enabled)</code>
Set the enabled state of this view.</li>
<li><code>void setFadingEdgeLength(int length)</code>
Set the size of the faded edge used to indicate that more content in this view is available.</li>
<li><code>void setFilterTouchesWhenObscured(boolean enabled)</code>
Sets whether the framework should discard touches when the view&#39;s window is obscured by another visible window.</li>
<li><code>void setFitsSystemWindows(boolean fitSystemWindows)</code>
Sets whether or not this view should account for system screen decorations such as the status bar and inset its content; that is, controlling whether the default implementation of fitSystemWindows(Rect) will be executed.</li>
<li><code>void setFocusable(boolean focusable)</code>
Set whether this view can receive the focus.</li>
<li><code>void setFocusable(int focusable)</code>
Sets whether this view can receive focus.</li>
<li><code>void setFocusableInTouchMode(boolean focusableInTouchMode)</code>
Set whether this view can receive focus while in touch mode.</li>
<li><code>void setFocusedByDefault(boolean isFocusedByDefault)</code>
Sets whether this View should receive focus when the focus is restored for the view hierarchy containing this view.</li>
<li><code>void setForeground(Drawable foreground)</code>
Supply a Drawable that is to be rendered on top of all of the content in the view.</li>
<li><code>void setForegroundGravity(int gravity)</code>
Describes how the foreground is positioned.</li>
<li><code>void setForegroundTintList(ColorStateList tint)</code>
Applies a tint to the foreground drawable.</li>
<li><code>void setForegroundTintMode(PorterDuff.Mode tintMode)</code>
Specifies the blending mode used to apply the tint specified by setForegroundTintList(ColorStateList)} to the background drawable.</li>
<li><code>void setHapticFeedbackEnabled(boolean hapticFeedbackEnabled)</code>
Set whether this view should have haptic feedback for events such as long presses.</li>
<li><code>void setHasTransientState(boolean hasTransientState)</code>
Set whether this view is currently tracking transient state that the framework should attempt to preserve when possible.</li>
<li><code>void setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled)</code>
Define whether the horizontal edges should be faded when this view is scrolled horizontally.</li>
<li><code>void setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled)</code>
Define whether the horizontal scrollbar should be drawn or not.</li>
<li><code>void setHovered(boolean hovered)</code>
Sets whether the view is currently hovered.</li>
<li><code>void setId(int id)</code>
Sets the identifier for this view.</li>
<li><code>void setImportantForAccessibility(int mode)</code>
Sets how to determine whether this view is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen.</li>
<li><code>void setKeepScreenOn(boolean keepScreenOn)</code>
Controls whether the screen should remain on, modifying the value of KEEP_SCREEN_ON.</li>
<li><code>void setKeyboardNavigationCluster(boolean isCluster)</code>
Set whether this view is a root of a keyboard navigation cluster.</li>
<li><code>void setLabelFor(int id)</code>
Sets the id of a view for which this view serves as a label for accessibility purposes.</li>
<li><code>void setLayerPaint(Paint paint)</code>
Updates the Paint object used with the current layer (used only if the current layer type is not set to LAYER_TYPE_NONE).</li>
<li><code>void setLayerType(int layerType, Paint paint)</code>
Specifies the type of layer backing this view.</li>
<li><code>void setLayoutDirection(int layoutDirection)</code>
Set the layout direction for this view.</li>
<li><code>void setLayoutParams(ViewGroup.LayoutParams params)</code>
Set the layout parameters associated with this view.</li>
<li><code>final void setLeft(int left)</code>
Sets the left position of this view relative to its parent.</li>
<li><code>void setLongClickable(boolean longClickable)</code>
Enables or disables long click events for this view.</li>
<li><code>void setMinimumHeight(int minHeight)</code>
Sets the minimum height of the view.</li>
<li><code>void setMinimumWidth(int minWidth)</code>
Sets the minimum width of the view.</li>
<li><code>void setNestedScrollingEnabled(boolean enabled)</code>
Enable or disable nested scrolling for this view.</li>
<li><code>void setNextClusterForwardId(int nextClusterForwardId)</code>
Sets the id of the view to use as the root of the next keyboard navigation cluster.</li>
<li><code>void setNextFocusDownId(int nextFocusDownId)</code>
Sets the id of the view to use when the next focus is FOCUS_DOWN.</li>
<li><code>void setNextFocusForwardId(int nextFocusForwardId)</code>
Sets the id of the view to use when the next focus is FOCUS_FORWARD.</li>
<li><code>void setNextFocusLeftId(int nextFocusLeftId)</code>
Sets the id of the view to use when the next focus is FOCUS_LEFT.</li>
<li><code>void setNextFocusRightId(int nextFocusRightId)</code>
Sets the id of the view to use when the next focus is FOCUS_RIGHT.</li>
<li><code>void setNextFocusUpId(int nextFocusUpId)</code>
Sets the id of the view to use when the next focus is FOCUS_UP.</li>
<li><code>void setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener listener)</code>
Set an View.OnApplyWindowInsetsListener to take over the policy for applying window insets to this view.</li>
<li><code>void setOnCapturedPointerListener(View.OnCapturedPointerListener l)</code>
Set a listener to receive callbacks when the pointer capture state of a view changes.</li>
<li><code>void setOnClickListener(View.OnClickListener l)</code>
Register a callback to be invoked when this view is clicked.</li>
<li><code>void setOnContextClickListener(View.OnContextClickListener l)</code>
Register a callback to be invoked when this view is context clicked.</li>
<li><code>void setOnCreateContextMenuListener(View.OnCreateContextMenuListener l)</code>
Register a callback to be invoked when the context menu for this view is being built.</li>
<li><code>void setOnDragListener(View.OnDragListener l)</code>
Register a drag event listener callback object for this View.</li>
<li><code>void setOnFocusChangeListener(View.OnFocusChangeListener l)</code>
Register a callback to be invoked when focus of this view changed.</li>
<li><code>void setOnGenericMotionListener(View.OnGenericMotionListener l)</code>
Register a callback to be invoked when a generic motion event is sent to this view.</li>
<li><code>void setOnHoverListener(View.OnHoverListener l)</code>
Register a callback to be invoked when a hover event is sent to this view.</li>
<li><code>void setOnKeyListener(View.OnKeyListener l)</code>
Register a callback to be invoked when a hardware key is pressed in this view.</li>
<li><code>void setOnLongClickListener(View.OnLongClickListener l)</code>
Register a callback to be invoked when this view is clicked and held.</li>
<li><code>void setOnScrollChangeListener(View.OnScrollChangeListener l)</code>
Register a callback to be invoked when the scroll X or Y positions of this view change.</li>
<li><code>void setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener l)</code>
Set a listener to receive callbacks when the visibility of the system bar changes.</li>
<li><code>void setOnTouchListener(View.OnTouchListener l)</code>
Register a callback to be invoked when a touch event is sent to this view.</li>
<li><code>void setOutlineProvider(ViewOutlineProvider provider)</code>
Sets the ViewOutlineProvider of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping.</li>
<li><code>void setOverScrollMode(int overScrollMode)</code>
Set the over-scroll mode for this view.</li>
<li><code>void setPadding(int left, int top, int right, int bottom)</code>
Sets the padding.</li>
<li><code>void setPaddingRelative(int start, int top, int end, int bottom)</code>
Sets the relative padding.</li>
<li><code>void setPivotX(float pivotX)</code>
Sets the x location of the point around which the view is rotated and scaled.</li>
<li><code>void setPivotY(float pivotY)</code>
Sets the y location of the point around which the view is rotated and scaled.</li>
<li><code>void setPointerIcon(PointerIcon pointerIcon)</code>
Set the pointer icon for the current view.</li>
<li><code>void setPressed(boolean pressed)</code>
Sets the pressed state for this view.</li>
<li><code>final void setRevealOnFocusHint(boolean revealOnFocus)</code>
Sets this view&#39;s preference for reveal behavior when it gains focus.</li>
<li><code>final void setRight(int right)</code>
Sets the right position of this view relative to its parent.</li>
<li><code>void setRotation(float rotation)</code>
Sets the degrees that the view is rotated around the pivot point.</li>
<li><code>void setRotationX(float rotationX)</code>
Sets the degrees that the view is rotated around the horizontal axis through the pivot point.</li>
<li><code>void setRotationY(float rotationY)</code>
Sets the degrees that the view is rotated around the vertical axis through the pivot point.</li>
<li><code>void setSaveEnabled(boolean enabled)</code>
Controls whether the saving of this view&#39;s state is enabled (that is, whether its onSaveInstanceState() method will be called).</li>
<li><code>void setSaveFromParentEnabled(boolean enabled)</code>
Controls whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent.</li>
<li><code>void setScaleX(float scaleX)</code>
Sets the amount that the view is scaled in x around the pivot point, as a proportion of the view&#39;s unscaled width.</li>
<li>void setScaleY(float scaleY)<br/>
Sets the amount that the view is scaled in Y around the pivot point, as a proportion of the view&#39;s unscaled width.</li>
<li>void setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade)<br/>
Define the delay before scrollbars fade.</li>
<li>void setScrollBarFadeDuration(int scrollBarFadeDuration)<br/>
Define the scrollbar fade duration.</li>
<li>void setScrollBarSize(int scrollBarSize)<br/>
Define the scrollbar size.</li>
<li>void setScrollBarStyle(int style)<br/>
Specify the style of the scrollbars.</li>
<li>void setScrollContainer(boolean isScrollContainer)<br/>
Change whether this view is one of the set of scrollable containers in its window.</li>
<li>void setScrollIndicators(int indicators, int mask)<br/>
Sets the state of the scroll indicators specified by the mask.</li>
<li>void setScrollIndicators(int indicators)<br/>
Sets the state of all scroll indicators.</li>
<li>void setScrollX(int value)<br/>
Set the horizontal scrolled position of your view.</li>
<li>void setScrollY(int value)<br/>
Set the vertical scrolled position of your view.</li>
<li>void setScrollbarFadingEnabled(boolean fadeScrollbars)<br/>
Define whether scrollbars will fade when the view is not scrolling.</li>
<li>void setSelected(boolean selected)<br/>
Changes the selection state of this view.</li>
<li>void setSoundEffectsEnabled(boolean soundEffectsEnabled)<br/>
Set whether this view should have sound effects enabled for events such as clicking and touching.</li>
<li>void setStateListAnimator(StateListAnimator stateListAnimator)<br/>
Attaches the provided StateListAnimator to this View.</li>
<li>void setSystemUiVisibility(int visibility)<br/>
Request that the visibility of the status bar or other screen/window decorations be changed.</li>
<li>void setTag(int key, Object tag)<br/>
Sets a tag associated with this view and a key.</li>
<li>void setTag(Object tag)<br/>
Sets the tag associated with this view.</li>
<li>void setTextAlignment(int textAlignment)<br/>
Set the text alignment.</li>
<li>void setTextDirection(int textDirection)<br/>
Set the text direction.</li>
<li>void setTooltipText(CharSequence tooltipText)<br/>
Sets the tooltip text which will be displayed in a small popup next to the view.</li>
<li>final void setTop(int top)<br/>
Sets the top position of this view relative to its parent.</li>
<li>void setTouchDelegate(TouchDelegate delegate)<br/>
Sets the TouchDelegate for this View.</li>
<li>final void setTransitionName(String transitionName)<br/>
Sets the name of the View to be used to identify Views in Transitions.</li>
<li>void setTranslationX(float translationX)<br/>
Sets the horizontal location of this view relative to its left position.</li>
<li>void setTranslationY(float translationY)<br/>
Sets the vertical location of this view relative to its top position.</li>
<li>void setTranslationZ(float translationZ)<br/>
Sets the depth location of this view relative to its elevation.</li>
<li>void setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled)<br/>
Define whether the vertical edges should be faded when this view is scrolled vertically.</li>
<li><code>void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled)</code>
Define whether the vertical scrollbar should be drawn or not.</li>
<li><code>void setVerticalScrollbarPosition(int position)</code>
Set the position of the vertical scroll bar.</li>
<li><code>void setVisibility(int visibility)</code>
Set the visibility state of this view.</li>
<li><code>void setWillNotCacheDrawing(boolean willNotCacheDrawing)</code>
When a View&#39;s drawing cache is enabled, drawing is redirected to an offscreen bitmap.</li>
<li><code>void setWillNotDraw(boolean willNotDraw)</code>
If this view doesn&#39;t do any drawing on its own, set this flag to allow further optimizations.</li>
<li><code>void setX(float x)</code>
Sets the visual x position of this view, in pixels.</li>
<li><code>void setY(float y)</code>
Sets the visual y position of this view, in pixels.</li>
<li><code>void setZ(float z)</code>
Sets the visual z position of this view, in pixels.</li>
<li><code>boolean showContextMenu()</code>
Shows the context menu for this view.</li>
<li><code>boolean showContextMenu(float x, float y)</code>
Shows the context menu for this view anchored to the specified view-relative coordinate.</li>
<li><code>ActionMode startActionMode(ActionMode.Callback callback, int type)</code>
Start an action mode with the given type.</li>
<li><code>ActionMode startActionMode(ActionMode.Callback callback)</code>
Start an action mode with the default type TYPE_PRIMARY.</li>
<li><code>void startAnimation(Animation animation)</code>
Start the specified animation now.</li>
<li><code>final boolean startDrag(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)</code>
This method was deprecated in API level 24. Use startDragAndDrop() for newer platform versions.</li>
<li><code>final boolean startDragAndDrop(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)</code>
Starts a drag and drop operation.</li>
<li><code>boolean startNestedScroll(int axes)</code>
Begin a nestable scroll operation along the given axes.</li>
<li><code>void stopNestedScroll()</code>
Stop a nested scroll in progress.</li>
<li><code>String toString()</code>
Returns a string representation of the object.</li>
<li><code>void unscheduleDrawable(Drawable who, Runnable what)</code>
Cancels a scheduled action on a drawable.</li>
<li><code>void unscheduleDrawable(Drawable who)</code>
Unschedule any events associated with the given Drawable.</li>
<li><code>final void updateDragShadow(View.DragShadowBuilder shadowBuilder)</code>
Updates the drag shadow for the ongoing drag and drop operation.</li>
<li><code>boolean willNotCacheDrawing()</code>
Returns whether or not this View can cache its drawing or not.</li>
<li><code>boolean willNotDraw()</code>
Returns whether or not this View draws on its own.</li>
</ul>

<h2 id="toc_9">获取上级View的方法汇总</h2>

<pre class="line-numbers"><code class="language-java">getParent()                                                    //获取上一级View
getRootView                                                    //获取跟布局
getWindow().getDecorView()                                     
findViewById(android.R.id.content)
((ViewGroup)findViewById(android.R.id.content)).getChildAt(0)
</code></pre>

<h3 id="toc_10">方法介绍</h3>

<p><figure><img src="media/15561207869937/15713203742240.jpg" alt=""/></figure></p>

<h3 id="toc_11">getRootView特例</h3>

<p><strong>布局(R.layout.list_empty)：</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;#FFFFFF&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/name&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerVertical=&quot;true&quot;
        android:layout_marginLeft=&quot;15dp&quot;
        android:text=&quot;暂无数据&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p><strong>代码：</strong></p>

<pre class="line-numbers"><code class="language-java">    final View view = View.inflate(this, R.layout.list_empty, null);
    final TextView name = (TextView) view.findViewById(R.id.name);
    System.out.println(&quot;before View.inflate name getParent &quot; + name.getParent());
    System.out.println(&quot;before View.inflate name getRootView &quot; + name.getRootView());
    addContentView(view, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));
    System.out.println(&quot;after View.inflate name getParent &quot; + name.getParent());
    System.out.println(&quot;after View.inflate name getRootView &quot; + name.getRootView());
</code></pre>

<pre class="line-numbers"><code class="language-java">结果：
before View.inflate name getParent android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
before View.inflate name getRootView android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
after View.inflate name getParent android.widget.RelativeLayout{3d679e31 V.E..... ......ID 0,0-0,0}
after View.inflate name getRootView com.android.internal.policy.impl.MultiPhoneWindow$MultiPhoneDecorView{c535bb V.E..... R.....ID 0,0-0,0}
</code></pre>

<p><em>结论：如果View在代码中通过View.inflate实例化，在没有添加到显示界面前，getRootView获得的是Xml的根布局。添加后getRootView获得的是MultiPhoneDecorView。</em></p>

<h3 id="toc_12">使用场景</h3>

<p>用途：状态栏、标题栏、键盘的高度</p>

<p><em>注意：以下代码不能在onCreate里面使用，否则获取的高度为0，你可以放在onWindowFocusChanged等等</em></p>

<h4 id="toc_13">状态栏高度：</h4>

<p><code>getDecorView</code>的<code>getWindowVisibleDisplayFrame</code>方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。 于是，我们就可以算出状态栏的高度了。</p>

<pre class="line-numbers"><code class="language-java">Rect frame = new Rect();  
getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);  
int statusBarHeight = frame.top;
</code></pre>

<h4 id="toc_14">标题栏高度</h4>

<p><code>findViewById(Android.R.id.content)</code>是不包括标题栏的，我们可以通过它获取标题栏的高度。</p>

<pre class="line-numbers"><code class="language-java">int contentTop = findViewById(android.R.id.content).getTop();  
//statusBarHeight是上面所求的状态栏的高度  
int titleBarHeight = contentTop - statusBarHeight;
</code></pre>

<h4 id="toc_15">键盘高度</h4>

<ul>
<li>键盘没打开时获取android.R.id.content的可见区域高度height1，</li>
<li>键盘打开时再获取android.R.id.content的可见区域高度height2，</li>
<li>键盘的高度height1-height2</li>
</ul>

<pre class="line-numbers"><code class="language-java">private View globalView;
private int firstHeight;
private boolean isFirst = true;

globalView = findViewById(android.R.id.content);
globalView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
    @Override
    public void onGlobalLayout() {
        Rect rect = new Rect();
        globalView.getWindowVisibleDisplayFrame(rect);
        if (isFirst) {
            isFirst = false;
            firstHeight = rect.height();
        } else {
            int height = rect.height();
            if (height &lt; firstHeight) {
                System.out.println(&quot;键盘打开 &quot; + (firstHeight - height));
            } else {
                System.out.println(&quot;键盘关闭 &quot;);
            }
        }
    }
});
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869891.html">
                
                  <h1>Android-基类实现及学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">BaseActivity</h2>

<pre class="line-numbers"><code class="language-java">public abstract class BaseActivity extends FragmentActivity {

    /** 用来保存所有已打开的Activity */
    private static Stack&lt;Activity&gt; listActivity = new Stack&lt;Activity&gt;();

    /** 提示信息 **/
    private Toast mToast;

    /** 记录上次点击按钮的时间 **/
    private long lastClickTime;
    /** 按钮连续点击最低间隔时间 单位：毫秒 **/
    public final static int CLICK_TIME = 500;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(getContentViewId());

        // 设置activity为无标题栏
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        // 将activity推入栈中
        listActivity.push(this);
        // 初始化ui
        initUI();
        // 初始化数据
        initData();
        // 事件监听
        initListener();

    }

    protected void initToolbar(){
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        if(toolbar != null){
            setSupportActionBar(toolbar);
            getSupportActionBar.setDisplayShowTitleEnabled(false);
            handleToolbar(new ToolbarHelper(this));
        }
    }

    /** 初始化ui **/
    protected abstract void initUI();

    /** 初始化数据 **/
    protected abstract void initData();

    /** 初始化监听 **/
    protected abstract void initListener();

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        saveInstanceState(outState);
        super.onSaveInstanceState(outState);
    }
    // 设置activity为无标题栏
    protected void setBase(){
        requestWindowFeature(Window.FEATURE_NO_TITLE);
    }

    /** 保存activity状态 **/
    protected void saveInstanceState(Bundle outState) {

    }

    protected void handleToolbar(){
        
    }

    @Override
    public void onBackPressed() {
        super.onBackPressed();

    }

    public void onBack(View v) {
        finish();

    }

    @Override
    protected void onResume() {
        super.onResume();

    }

    protected abstract int getContentViewId();

    protected void showLongToast(String toastText){
        Toast.makeText(this,toastText,Toast.LENGTH_LONG).show();
    }
    
    protected void showShortToast(String toastText){
        Toast.makeText(this,toastText,Toast.LENGTH_SHORT).show();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 从栈中移除当前activity
        if (listActivity.contains(this)) {
            listActivity.remove(this);
        }

    }

    /********************** activity跳转 **********************************/
    public void openActivity(Class&lt;?&gt; targetActivityClass) {
        openActivity(targetActivityClass, null);
    }

    public void openActivity(Class&lt;?&gt; targetActivityClass, Bundle bundle) {
        Intent intent = new Intent(this, targetActivityClass);
        if (bundle != null) {
            intent.putExtras(bundle);
        }
        startActivity(intent);
    }

    public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass) {
        openActivity(targetActivityClass);
        this.finish();
    }

    public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass, Bundle bundle) {
        openActivity(targetActivityClass, bundle);
        this.finish();
    }

    /***************************************************************/

    /** 验证上次点击按钮时间间隔，防止重复点击 */
    public boolean verifyClickTime() {
        if (System.currentTimeMillis() - lastClickTime &lt;= CLICK_TIME) {
            return false;
        }
        lastClickTime = System.currentTimeMillis();
        return true;
    }

    /** 收起键盘 */
    public void closeInputMethod() {
        // 收起键盘
        View view = getWindow().peekDecorView();// 用于判断虚拟软键盘是否是显示的
        if (view != null) {
            InputMethodManager inputmanger = (InputMethodManager) getSystemService(Activity.INPUT_METHOD_SERVICE);
            inputmanger.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
        }
    }

    /**
     * 获取string
     * 
     * @param mRid
     * @return
     */
    public String getStringMethod(int mRid) {
        return this.getResources().getString(mRid);
    }

    /**
     * 获取demin
     * 
     * @param mRid
     * @return
     */
    protected int getDemonIntegerMethod(int mRid) {
        return (int) this.getResources().getDimension(mRid);
    }

    /**
     * 关闭所有(前台、后台)Activity,注意：请已BaseActivity为父类
     */
    protected static void finishAll() {
        int len = listActivity.size();
        for (int i = 0; i &lt; len; i++) {
            Activity activity = listActivity.pop();
            activity.finish();
        }
    }

    /***************** 双击退出程序 ************************************************/
    private long exitTime = 0;

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {

        if (KeyEvent.KEYCODE_BACK == keyCode) {
            // 判断是否在两秒之内连续点击返回键，是则退出，否则不退出
            if (System.currentTimeMillis() - exitTime &gt; 2000) {
                Toast.makeText(getApplicationContext(), &quot;再按一次退出程序&quot;, Toast.LENGTH_SHORT).show();
                // 将系统当前的时间赋值给exitTime
                exitTime = System.currentTimeMillis();
            } else {
                finishAll();
            }
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    /*
     * ************Fragement相关方法************************************************
     * 
     */
    private Fragment currentFragment;

    /** Fragment替换(当前destrory,新的create) */
    public void fragmentReplace(int target, Fragment toFragment, boolean backStack) {
        FragmentManager manager = getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        String toClassName = toFragment.getClass().getSimpleName();
        if (manager.findFragmentByTag(toClassName) == null) {
            transaction.replace(target, toFragment, toClassName);
            if (backStack) {
                transaction.addToBackStack(toClassName);
            }
            transaction.commit();
        }
    }

    /** Fragment替换(核心为隐藏当前的,显示现在的,用过的将不会destrory与create) */
    public void smartFragmentReplace(int target, Fragment toFragment) {
        FragmentManager manager = getSupportFragmentManager();
        FragmentTransaction transaction = manager.beginTransaction();
        // 如有当前在使用的-&gt;隐藏当前的
        if (currentFragment != null) {
            transaction.hide(currentFragment);
        }
        String toClassName = toFragment.getClass().getSimpleName();
        // toFragment之前添加使用过-&gt;显示出来
        if (manager.findFragmentByTag(toClassName) != null) {
            transaction.show(toFragment);
        } else {// toFragment还没添加使用过-&gt;添加上去
            transaction.add(target, toFragment, toClassName);
        }
        transaction.commit();
        // toFragment更新为当前的
        currentFragment = toFragment;
    }

    /***********************************************************************/
}
</code></pre>

<h2 id="toc_1">BaseFragment</h2>

<pre class="line-numbers"><code class="language-java">public abstract class BaseFragment extends Fragment {

    protected Activity mActivity;

    /**
     * 获得全局的，防止使用getActivity()为空
     * @param context
     */
    @Override
    public void onAttach(Context context) {
        super.onAttach(context);
        this.mActivity = (Activity)context;
    }

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container
            , Bundle savedInstanceState) {

        View view = LayoutInflater.from(mActivity)
                .inflate(getLayoutId(), container, false);
        initView(view, savedInstanceState);

        return view;
    }

    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        initData();
    }

    /**
     * 该抽象方法就是 onCreateView中需要的layoutID
     * @return
     */
    protected abstract int getLayoutId();

    /**
     * 该抽象方法就是 初始化view
     * @param view
     * @param savedInstanceState
     */
    protected abstract void initView(View view, Bundle savedInstanceState);

    /**
     * 执行数据的加载
     */
    protected abstract void initData();
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869850.html">
                
                  <h1>Android-VelocityTracker详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">简介</h2>

<p>VelocityTracker是一个跟踪触摸事件滑动速度的帮助类，用于实现flinging以及其它类似的手势。它的原理是把触摸事件 MotionEvent 对象传递给VelocityTracker的 addMovement(MotionEvent) 方法，然后分析MotionEvent 对象在单位时间类发生的位移来计算速度。你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。</p>

<h2 id="toc_1">主要函数</h2>

<table>
<thead>
<tr>
<th style="text-align: left">Public Methods</th>
<th style="text-align: left"></th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>addMovement(MotionEvent event)</code> <br>Add a users movement to the tracker.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>clear()</code> <br>Reset the velocity tracker back to its initial state.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>compute CurrentVelocity(int units,float maxVelocity)</code><br>Compute the current velocity based on the points that have been collected.<br><br>intunitis表示速率的基本时间单位。unitis值为1的表示是，一毫秒时间单位内运动了多少个像素， unitis值为1000表示一秒（1000毫秒）时间单位内运动了多少个像素<br><br>floatVelocity表示速率的最大值</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>computeCurrentVelocity(int units)</code><br>Equivalent to invoking computeCurrentVelocity(int, float)with a maximum velocity of Float.MAX_VALUE.</td>
</tr>
<tr>
<td style="text-align: left">abstract T</td>
<td style="text-align: left"><code>getNextPoolable()</code></td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getXVelocity()</code><br>Retrieve the last computed X velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getXVelocity(int id)</code><br>Retrieve the last computed X velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>float   getYVelocity(int id)</code><br>Retrieve the last computed Y velocity.</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left"><code>getYVelocity()</code><br>Retrieve the last computed Y velocity.</td>
</tr>
<tr>
<td style="text-align: left">abstract boolean</td>
<td style="text-align: left"><code>isPooled()</code></td>
</tr>
<tr>
<td style="text-align: left">static VelocityTracker</td>
<td style="text-align: left"><code>obtain()</code><br>Retrieve a new VelocityTracker object to watch the velocity of a motion.</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: left"><code>recycle()</code><br>Return a VelocityTracker object back to be re-used by others.</td>
</tr>
<tr>
<td style="text-align: left">abstract void</td>
<td style="text-align: left"><code>setNextPoolable(T element)</code></td>
</tr>
<tr>
<td style="text-align: left">abstract void</td>
<td style="text-align: left"><code>setPooled(boolean isPooled)</code></td>
</tr>
</tbody>
</table>

<h2 id="toc_2">示例</h2>

<pre class="line-numbers"><code class="language-java">private VelocityTracker mVelocityTracker;//生命变量  
//在onTouchEvent(MotionEvent ev)中  
if (mVelocityTracker == null) {  
    mVelocityTracker = VelocityTracker.obtain();//获得VelocityTracker类实例  
}  
mVelocityTracker.addMovement(ev);//将事件加入到VelocityTracker类实例中  
//判断当ev事件是MotionEvent.ACTION_UP时：计算速率  
final VelocityTracker velocityTracker = mVelocityTracker;  
// 1000 provides pixels per second  
velocityTracker.computeCurrentVelocity(1, (float)0.01);//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常  
Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getXVelocity());  
velocityTracker.computeCurrentVelocity(1000); //设置units的值为1000，意思为一秒时间内运动了多少个像素  
Log.i(&quot;test&quot;,&quot;velocityTraker&quot;+velocityTracker.getXVelocity());

</code></pre>

<p>大体的使用是这样的：<br/>
当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象<br/>
在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象<br/>
使用computeCurrentVelocity (int units)函数来计算当前的速度，使用getXVelocity ()、 getYVelocity ()函数来获得当前的速度</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869807.html">
                
                  <h1>Android-Toolbar详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Toolbar是简单使用</h2>

<p>1、在应用的build.gradle中添加v7 appcompat支持库。<br/><br/>
<code>com.android.support:appcompat-v7:24.1.1</code></p>

<p>2、让Activity继承自AppCompatActivity。  </p>

<pre class="line-numbers"><code class="language-java">public class MyActivity extends AppCompatActivity {
  // ...
}
</code></pre>

<p>3、在AndroidManifest.xml文件中，设置元素使用appcompat中的某个NoActionBar主题，从而来去除使用ActionBar来提供操作栏。</p>

<pre class="line-numbers"><code class="language-java">&lt;application android:theme=&quot;@style/Theme.AppCompat.Light.NoActionBar&quot;/&gt;
</code></pre>

<p>4、在activity的布局中添加Toolbar。</p>

<pre class="line-numbers"><code class="language-java">&lt;android.support.v7.widget.Toolbar
 android:id=&quot;@+id/my_toolbar&quot;
 android:layout_width=&quot;match_parent&quot;
 android:layout_height=&quot;?attr/actionBarSize&quot;
 android:background=&quot;?attr/colorPrimary&quot;
 android:elevation=&quot;4dp&quot;
 android:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;  
 app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;
</code></pre>

<p>5、在activity的onCreate()方法中，调用setSupportActionBar()方法，并传入toolbar，这样就会将toolbar设置为activity的操作栏了。</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_my);
  Toolbar toolbar = (Toolbar) findViewById(R.id.my_toolbar);
  setSupportActionBar(toolbar);
}
</code></pre>

<h2 id="toc_1">Toolber复用</h2>

<p>应用中有很多界面，每个Activity一般都需要操作栏，且大多数activity的操作栏的元素是一致的，那每个布局文件里面都写这么多资源文件是累赘的。因此可以对Toolbar进行复用，使得布局文件看起来更精炼，更改Toolbar整体效果，如背景之类的可以更方便。</p>

<p>首先，在布局文件toolbar.xml中定义Toolbar。</p>

<pre class="line-numbers"><code class="language-java">&lt;android.support.v7.widget.Toolbar
    android:id=&quot;@+id/toolbar&quot;
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;?attr/actionBarSize&quot;
    android:background=&quot;?attr/colorPrimary&quot;
    android:contentInsetLeft=&quot;0dp&quot;
    android:contentInsetStart=&quot;0dp&quot;
    android:elevation=&quot;4dp&quot;
    android:theme=&quot;@style/ToolbarTheme&quot;
    app:navigationIcon=&quot;@drawable/icon_back&quot;
    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;
    app:titleTextAppearance=&quot;@style/Toolbar.TitleText&quot;&gt;

    &lt;!--  any custom view --&gt;

&lt;/android.support.v7.widget.Toolbar&gt;
</code></pre>

<p>之后，在需要添加Toolbar的地方引入这个布局资源。</p>

<pre class="line-numbers"><code class="language-java">&lt;include
  layout=&quot;@layout/toolbar&quot;/&gt;
</code></pre>

<p>最后，在BaseActivity(一般app都会有)中的onCreate()方法设置Toolbar。注意，这个时候Activity不再继承AppCompatActivity，而是继承BaseActivity，而BaseActivity继承AppCompatActivity。BaseActivity部分代码如下：</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
    if (toolbar != null) {
        setSupportActionBar(toolbar);

        mToolbarHelper = new ToolbarHelper(toolbar);

        hanldeToolbar(mToolbarHelper);
    }
}

protected void hanldeToolbar(ToolbarHelper toolbarHelper) {}

public static class ToolbarHelper {

    private Toolbar mToolbar;

    public ToolbarHelper(Toolbar toolbar) {
        this.mToolbar = toolbar;
    }

    public Toolbar getToolbar() {
        return mToolbar;
    }

    public void setTitle(String title) {
        TextView titleTV = (TextView) mToolbar.findViewById(R.id.toolbar_title);
        titleTV.setText(title);
    }
}
</code></pre>

<p>代码中首先获取到Toolbar将其设置为操作栏，之后创建了一个ToolbarHelper对象，ToobarHelper主要是封装了下Toolbar，并提供操作自定义View的方法。然后调用hanldeToolbar()方法，子Activity通过重写这个方法，可以对Toolbar进行定制操作。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/9</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_8.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_10.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15818619982581.html">IDEA 远程一键部署Spring Boot到Docker</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15813395132789.html">Flutter VsCode插件</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15809146907844.html">Flutter 组件小记</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15808782889824.html">Flutter常用第三方库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15767453112302.html">添加环境变量</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
