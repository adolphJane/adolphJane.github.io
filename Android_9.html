<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207869720.html">
                
                  <h1>Android-ViewConfiguration解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>ViewConfiguration这个类主要定义了UI中所使用到的标准常量，像超时、尺寸、距离，如果我们需要得到这些常量的数据，我们就可以通过这个类来获取，具体方法如下： </p>

<ul>
<li>获取ViewConfiguration对象，由于ViewConfiguration的构造方法为私有的，只能通过这个静态方法来获取到该对象。 ViewConfiguration configure = ViewConfiguration.get(context); </li>
<li>通过该对象调用相关的函数，将返回相关的常量数据。</li>
</ul>

<p>最后附上一些这个类文件源码，这里面所有的方法基本都是用来获取常量数据的，没有什么业务操作。</p>

<pre><code class="language-java">import android.app.AppGlobals;
import android.content.Context;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Point;
import android.os.RemoteException;
import android.provider.Settings;
import android.util.DisplayMetrics;
import android.util.SparseArray;

/**
 * 主要用来获取一些在UI中所使用到的标准常量，像超时、尺寸、距离
 */
public class ViewConfiguration {
    /**
     * 定义了水平滚动条的宽度和垂直滚动条的高度，单位是dip
     */
    private static final int SCROLL_BAR_SIZE = 10;

    /**
     * 滚动条褪去所需要经历的时间，单位：milliseconds
     */
    private static final int SCROLL_BAR_FADE_DURATION = 250;

    /**
     * 滚动条褪去之前的默认时间延迟，单位：milliseconds
     */
    private static final int SCROLL_BAR_DEFAULT_DELAY = 300;

    /**
     * 定义褪去边缘的长度，单位：dip
     */
    private static final int FADING_EDGE_LENGTH = 12;

    /**
     * 按下状态在子控件上的持续时间，单位：milliseconds
     */
    private static final int PRESSED_STATE_DURATION = 64;

    /**
     * 定义一个按下状态转变成长按状态所需要持续的时间，单位：milliseconds
     */
    private static final int DEFAULT_LONG_PRESS_TIMEOUT = 500;

    /**
     * 定义连续重复按键间的时间延迟，单位：milliseconds
     */
    private static final int KEY_REPEAT_DELAY = 50;

    /**
     * 如果用户需要触发全局对话框，例如：关机，锁屏等，需要按下按钮所持续的事件，单位：milliseconds
     */
    private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500;

    /**
     * 定义一个触摸事件是点击还是滚动的事件间隔，如果在这个事件内没有移动，就认为这是一个点击，否则就是滚动，单位：milliseconds
     */
    private static final int TAP_TIMEOUT = 180;

    /**
     * Defines the duration in milliseconds we will wait to see if a touch event
     * is a jump tap. If the user does not complete the jump tap within this interval, it is
     * considered to be a tap.
     */
    private static final int JUMP_TAP_TIMEOUT = 500;

    /**
     * 定义双击的时间间隔，如果在这个时间内，就认为是双击
     */
    private static final int DOUBLE_TAP_TIMEOUT = 300;

    /**
     * 定义双击最小的时间间隔
     */
    private static final int DOUBLE_TAP_MIN_TIME = 40;

    /**
     * 定义一个触摸板触摸到释放可认为是一个点击事件而不是一个触摸移动手势的最大时间，
     * 也就是说在这个时间内进行一次触摸和释放操作就可以认为是一次点击事件，单位：milliseconds
     */
    private static final int HOVER_TAP_TIMEOUT = 150;

    /**
     * 定义一个触摸板在触摸释放之前可以移动的最大距离，
     * 如果在这个距离之内就可以认为是一个点击事件，否则就是一个移动手势，单位：pixels
     */
    private static final int HOVER_TAP_SLOP = 20;

    /**
     * 定义响应显示缩放控制的时间
     */
    private static final int ZOOM_CONTROLS_TIMEOUT = 3000;

    /**
     * Inset in dips to look for touchable content when the user touches the edge of the screen
     */
    private static final int EDGE_SLOP = 12;

    /**
     * 如果我们认为用户正在滚动，这里定义一个触摸事件可以滚动的距离，单位：dips
     * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。
     */
    private static final int TOUCH_SLOP = 8;

    /**
     * 定义双击事件之间可以移动的距离，单位：dips
     */
    private static final int DOUBLE_TAP_TOUCH_SLOP = TOUCH_SLOP;

    /**
     * 定义用户尝试翻页滚动的触摸移动距离，单位：dips
     *
     * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。
     *
     */
    private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2;

    /**
     * 定义第一次点击和第二次点击可以认为是一次双击之间的距离。单位：dips
     */
    private static final int DOUBLE_TAP_SLOP = 100;

    /**
     * Distance in dips a touch needs to be outside of a window&#39;s bounds for it to
     * count as outside for purposes of dismissing the window.
     */
    private static final int WINDOW_TOUCH_SLOP = 16;

    /**
     * 一个fling最小的速度，单位：dips/s
     */
    private static final int MINIMUM_FLING_VELOCITY = 50;

    /**
     * 一个fling最大的速度，单位：dips/s
     */
    private static final int MAXIMUM_FLING_VELOCITY = 8000;

    /**
     * 分发一个重复访问事件的延迟事件，单位：milliseconds
     */
    private static final long SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS = 100;

    /**
     * The maximum size of View&#39;s drawing cache, expressed in bytes. This size
     * should be at least equal to the size of the screen in ARGB888 format.
     */
    @Deprecated
    private static final int MAXIMUM_DRAWING_CACHE_SIZE = 480 * 800 * 4; // ARGB8888

    /**
     * 滚动和滑动的摩擦系数
     */
    private static final float SCROLL_FRICTION = 0.015f;

    /**
     * Max distance in dips to overscroll for edge effects
     */
    private static final int OVERSCROLL_DISTANCE = 0;

    /**
     * Max distance in dips to overfling for edge effects
     */
    private static final int OVERFLING_DISTANCE = 6;

    private final int mEdgeSlop;
    private final int mFadingEdgeLength;
    private final int mMinimumFlingVelocity;
    private final int mMaximumFlingVelocity;
    private final int mScrollbarSize;
    private final int mTouchSlop;
    private final int mDoubleTapTouchSlop;
    private final int mPagingTouchSlop;
    private final int mDoubleTapSlop;
    private final int mWindowTouchSlop;
    private final int mMaximumDrawingCacheSize;
    private final int mOverscrollDistance;
    private final int mOverflingDistance;
    private final boolean mFadingMarqueeEnabled;

    private boolean sHasPermanentMenuKey;
    private boolean sHasPermanentMenuKeySet;

    static final SparseArray&lt;ViewConfiguration&gt; sConfigurations =
            new SparseArray&lt;ViewConfiguration&gt;(2);

    /**
     * 这个方法被废除了，使用ViewConfiguration.get(Context)}替代
     */
    @Deprecated
    public ViewConfiguration() {
        mEdgeSlop = EDGE_SLOP;
        mFadingEdgeLength = FADING_EDGE_LENGTH;
        mMinimumFlingVelocity = MINIMUM_FLING_VELOCITY;
        mMaximumFlingVelocity = MAXIMUM_FLING_VELOCITY;
        mScrollbarSize = SCROLL_BAR_SIZE;
        mTouchSlop = TOUCH_SLOP;
        mDoubleTapTouchSlop = DOUBLE_TAP_TOUCH_SLOP;
        mPagingTouchSlop = PAGING_TOUCH_SLOP;
        mDoubleTapSlop = DOUBLE_TAP_SLOP;
        mWindowTouchSlop = WINDOW_TOUCH_SLOP;
        //noinspection deprecation
        mMaximumDrawingCacheSize = MAXIMUM_DRAWING_CACHE_SIZE;
        mOverscrollDistance = OVERSCROLL_DISTANCE;
        mOverflingDistance = OVERFLING_DISTANCE;
        mFadingMarqueeEnabled = true;
    }

    /**
     * 使用给定的context来创建一个新的配置。这个配置依赖于context里面不同的参数，例如显示的尺寸或者密度
     * @param context 用来初始化这个view配置的应用上下文环境
     *
     * @see #get(android.content.Context)
     * @see android.util.DisplayMetrics
     */
    private ViewConfiguration(Context context) {
        final Resources res = context.getResources();
        final DisplayMetrics metrics = res.getDisplayMetrics();
        final Configuration config = res.getConfiguration();
        final float density = metrics.density;
        final float sizeAndDensity;
        if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE)) {
            sizeAndDensity = density * 1.5f;
        } else {
            sizeAndDensity = density;
        }

        mEdgeSlop = (int) (sizeAndDensity * EDGE_SLOP + 0.5f);
        mFadingEdgeLength = (int) (sizeAndDensity * FADING_EDGE_LENGTH + 0.5f);
        mMinimumFlingVelocity = (int) (density * MINIMUM_FLING_VELOCITY + 0.5f);
        mMaximumFlingVelocity = (int) (density * MAXIMUM_FLING_VELOCITY + 0.5f);
        mScrollbarSize = (int) (density * SCROLL_BAR_SIZE + 0.5f);
        mDoubleTapSlop = (int) (sizeAndDensity * DOUBLE_TAP_SLOP + 0.5f);
        mWindowTouchSlop = (int) (sizeAndDensity * WINDOW_TOUCH_SLOP + 0.5f);

        // Size of the screen in bytes, in ARGB_8888 format
        final WindowManager win = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
        final Display display = win.getDefaultDisplay();
        final Point size = new Point();
        display.getRealSize(size);
        mMaximumDrawingCacheSize = 4 * size.x * size.y;

        mOverscrollDistance = (int) (sizeAndDensity * OVERSCROLL_DISTANCE + 0.5f);
        mOverflingDistance = (int) (sizeAndDensity * OVERFLING_DISTANCE + 0.5f);

        if (!sHasPermanentMenuKeySet) {
            IWindowManager wm = WindowManagerGlobal.getWindowManagerService();
            try {
                sHasPermanentMenuKey = !wm.hasNavigationBar();
                sHasPermanentMenuKeySet = true;
            } catch (RemoteException ex) {
                sHasPermanentMenuKey = false;
            }
        }

        mFadingMarqueeEnabled = res.getBoolean(
                com.android.internal.R.bool.config_ui_enableFadingMarquee);
        mTouchSlop = res.getDimensionPixelSize(
                com.android.internal.R.dimen.config_viewConfigurationTouchSlop);
        mPagingTouchSlop = mTouchSlop * 2;

        mDoubleTapTouchSlop = mTouchSlop;
    }

    /**
     * 跟上面一个函数一样，只不过上面一个是创建一个ViewConfiguration对象，这里是直接通过这个静态方法返回一个对象
     */
    public static ViewConfiguration get(Context context) {
        final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
        final int density = (int) (100.0f * metrics.density);

        ViewConfiguration configuration = sConfigurations.get(density);
        if (configuration == null) {
            configuration = new ViewConfiguration(context);
            sConfigurations.put(density, configuration);
        }

        return configuration;
    }

    /**
     * @return 获取水平滚动条的宽带和垂直滚动条的高度
     *
     * 这个函数被废除，使用getScaledScrollBarSize()来代替
     */
    @Deprecated
    public static int getScrollBarSize() {
        return SCROLL_BAR_SIZE;
    }

    /**
     * @return 获取水平滚动条的宽带和垂直滚动条的高度
     */
    public int getScaledScrollBarSize() {
        return mScrollbarSize;
    }

    /**
     * @return 滚动条褪去的持续时间
     */
    public static int getScrollBarFadeDuration() {
        return SCROLL_BAR_FADE_DURATION;
    }

    /**
     * @return 滚动条褪去的延迟时间
     */
    public static int getScrollDefaultDelay() {
        return SCROLL_BAR_DEFAULT_DELAY;
    }

    /**
     * @return 褪去边缘的长度
     *
     * 这个方法已经废弃，用getScaledFadingEdgeLength()替代.
     */
    @Deprecated
    public static int getFadingEdgeLength() {
        return FADING_EDGE_LENGTH;
    }

    /**
     * @return 褪去边缘的长度，单位：pixels
     */
    public int getScaledFadingEdgeLength() {
        return mFadingEdgeLength;
    }

    /**
     * @return 在子控件上按住状态的持续时间
     */
    public static int getPressedStateDuration() {
        return PRESSED_STATE_DURATION;
    }

    /**
     * @return 按住状态转变为长按状态需要的时间
     */
    public static int getLongPressTimeout() {
        return AppGlobals.getIntCoreSetting(Settings.Secure.LONG_PRESS_TIMEOUT,
                DEFAULT_LONG_PRESS_TIMEOUT);
    }

    /**
     * @return 重新按键时间
     */
    public static int getKeyRepeatTimeout() {
        return getLongPressTimeout();
    }

    /**
     * @return 重复按键延迟时间
     */
    public static int getKeyRepeatDelay() {
        return KEY_REPEAT_DELAY;
    }

    /**
     * @return 判断用户是单击还是滚动的时间，在这个时间内没有移动则是单击，否则是滚动
     */
    public static int getTapTimeout() {
        return TAP_TIMEOUT;
    }

    /**
     * @return the duration in milliseconds we will wait to see if a touch event
     * is a jump tap. If the user does not move within this interval, it is
     * considered to be a tap.
     */
    public static int getJumpTapTimeout() {
        return JUMP_TAP_TIMEOUT;
    }

    /**
     * @return 得到双击间隔时间，在这个时间内，则是双击，否则就是单击
     */
    public static int getDoubleTapTimeout() {
        return DOUBLE_TAP_TIMEOUT;
    }

    /**
     * @return the minimum duration in milliseconds between the first tap&#39;s
     * up event and the second tap&#39;s down event for an interaction to be considered a
     * double-tap.
     *
     * @hide
     */
    public static int getDoubleTapMinTime() {
        return DOUBLE_TAP_MIN_TIME;
    }

    /**
     * @return the maximum duration in milliseconds between a touch pad
     * touch and release for a given touch to be considered a tap (click) as
     * opposed to a hover movement gesture.
     * @hide
     */
    public static int getHoverTapTimeout() {
        return HOVER_TAP_TIMEOUT;
    }

    /**
     * @return the maximum distance in pixels that a touch pad touch can move
     * before being released for it to be considered a tap (click) as opposed
     * to a hover movement gesture.
     * @hide
     */
    public static int getHoverTapSlop() {
        return HOVER_TAP_SLOP;
    }

    /**
     * @return Inset in dips to look for touchable content when the user touches the edge of the
     *         screen
     *
     * @deprecated Use {@link #getScaledEdgeSlop()} instead.
     */
    @Deprecated
    public static int getEdgeSlop() {
        return EDGE_SLOP;
    }

    /**
     * @return Inset in pixels to look for touchable content when the user touches the edge of the
     *         screen
     */
    public int getScaledEdgeSlop() {
        return mEdgeSlop;
    }

    /**
     * @return Distance in dips a touch can wander before we think the user is scrolling
     *
     * @deprecated Use {@link #getScaledTouchSlop()} instead.
     */
    @Deprecated
    public static int getTouchSlop() {
        return TOUCH_SLOP;
    }

    /**
     * @return Distance in pixels a touch can wander before we think the user is scrolling
     */
    public int getScaledTouchSlop() {
        return mTouchSlop;
    }

    /**
     * @return Distance in pixels the first touch can wander before we do not consider this a
     * potential double tap event
     * @hide
     */
    public int getScaledDoubleTapTouchSlop() {
        return mDoubleTapTouchSlop;
    }

    /**
     * @return Distance in pixels a touch can wander before we think the user is scrolling a full
     * page
     */
    public int getScaledPagingTouchSlop() {
        return mPagingTouchSlop;
    }

    /**
     * @return Distance in dips between the first touch and second touch to still be
     *         considered a double tap
     * @deprecated Use {@link #getScaledDoubleTapSlop()} instead.
     * @hide The only client of this should be GestureDetector, which needs this
     *       for clients that still use its deprecated constructor.
     */
    @Deprecated
    public static int getDoubleTapSlop() {
        return DOUBLE_TAP_SLOP;
    }

    /**
     * @return Distance in pixels between the first touch and second touch to still be
     *         considered a double tap
     */
    public int getScaledDoubleTapSlop() {
        return mDoubleTapSlop;
    }

    /**
     * Interval for dispatching a recurring accessibility event in milliseconds.
     * This interval guarantees that a recurring event will be send at most once
     * during the {@link #getSendRecurringAccessibilityEventsInterval()} time frame.
     *
     * @return The delay in milliseconds.
     *
     * @hide
     */
    public static long getSendRecurringAccessibilityEventsInterval() {
        return SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS;
    }

    /**
     * @return Distance in dips a touch must be outside the bounds of a window for it
     * to be counted as outside the window for purposes of dismissing that
     * window.
     *
     * @deprecated Use {@link #getScaledWindowTouchSlop()} instead.
     */
    @Deprecated
    public static int getWindowTouchSlop() {
        return WINDOW_TOUCH_SLOP;
    }

    /**
     * @return Distance in pixels a touch must be outside the bounds of a window for it
     * to be counted as outside the window for purposes of dismissing that window.
     */
    public int getScaledWindowTouchSlop() {
        return mWindowTouchSlop;
    }

    /**
     * @return Minimum velocity to initiate a fling, as measured in dips per second.
     *
     * @deprecated Use {@link #getScaledMinimumFlingVelocity()} instead.
     */
    @Deprecated
    public static int getMinimumFlingVelocity() {
        return MINIMUM_FLING_VELOCITY;
    }

    /**
     * @return 得到滑动的最小速度, 以像素/每秒来进行计算
     */
    public int getScaledMinimumFlingVelocity() {
        return mMinimumFlingVelocity;
    }

    /**
     * @return Maximum velocity to initiate a fling, as measured in dips per second.
     *
     * @deprecated Use {@link #getScaledMaximumFlingVelocity()} instead.
     */
    @Deprecated
    public static int getMaximumFlingVelocity() {
        return MAXIMUM_FLING_VELOCITY;
    }

    /**
     * @return 得到滑动的最大速度, 以像素/每秒来进行计算
     */
    public int getScaledMaximumFlingVelocity() {
        return mMaximumFlingVelocity;
    }

    /**
     * The maximum drawing cache size expressed in bytes.
     *
     * @return the maximum size of View&#39;s drawing cache expressed in bytes
     *
     * @deprecated Use {@link #getScaledMaximumDrawingCacheSize()} instead.
     */
    @Deprecated
    public static int getMaximumDrawingCacheSize() {
        //noinspection deprecation
        return MAXIMUM_DRAWING_CACHE_SIZE;
    }

    /**
     * The maximum drawing cache size expressed in bytes.
     *
     * @return the maximum size of View&#39;s drawing cache expressed in bytes
     */
    public int getScaledMaximumDrawingCacheSize() {
        return mMaximumDrawingCacheSize;
    }

    /**
     * @return The maximum distance a View should overscroll by when showing edge effects (in
     * pixels).
     */
    public int getScaledOverscrollDistance() {
        return mOverscrollDistance;
    }

    /**
     * @return The maximum distance a View should overfling by when showing edge effects (in
     * pixels).
     */
    public int getScaledOverflingDistance() {
        return mOverflingDistance;
    }

    /**
     * The amount of time that the zoom controls should be
     * displayed on the screen expressed in milliseconds.
     *
     * @return the time the zoom controls should be visible expressed
     * in milliseconds.
     */
    public static long getZoomControlsTimeout() {
        return ZOOM_CONTROLS_TIMEOUT;
    }

    /**
     * The amount of time a user needs to press the relevant key to bring up
     * the global actions dialog.
     *
     * @return how long a user needs to press the relevant key to bring up
     *   the global actions dialog.
     */
    public static long getGlobalActionKeyTimeout() {
        return GLOBAL_ACTIONS_KEY_TIMEOUT;
    }

    /**
     * The amount of friction applied to scrolls and flings.
     *
     * @return A scalar dimensionless value representing the coefficient of
     *         friction.
     */
    public static float getScrollFriction() {
        return SCROLL_FRICTION;
    }

    /**
     * Report if the device has a permanent menu key available to the user.
     *
     * &lt;p&gt;As of Android 3.0, devices may not have a permanent menu key available.
     * Apps should use the action bar to present menu options to users.
     * However, there are some apps where the action bar is inappropriate
     * or undesirable. This method may be used to detect if a menu key is present.
     * If not, applications should provide another on-screen affordance to access
     * functionality.
     *
     * @return true if a permanent menu key is present, false otherwise.
     */
    public boolean hasPermanentMenuKey() {
        return sHasPermanentMenuKey;
    }

    /**
     * @hide
     * @return Whether or not marquee should use fading edges.
     */
    public boolean isFadingMarqueeEnabled() {
        return mFadingMarqueeEnabled;
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/7</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869675.html">
                
                  <h1>Android-Scroller详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Scroller是一个专门用于处理滚动效果的工具类，可能在大多数情况下，我们直接使用Scroller的场景并不多，但是很多大家所熟知的控件在内部都是使用Scroller来实现的，如ViewPager、ListView等。先撇开Scroller类不谈，其实任何一个控件都是可以滚动的，因为在View类当中有scrollTo()和scrollBy()这两个方法。这两个方法都是用于对View进行滚动的，那么它们之间有什么区别呢？简单点讲，scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。<strong>注意，不管是scrollTo()还是scrollBy()方法，滚动的都是该View内部的内容</strong></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017092315061662718986.jpg" alt="2017092315061662718986.jpg"/></p>

<p>第一个参数x表示相对于当前位置横向移动的距离，正值向左移动，负值向右移动，单位是像素。第二个参数y表示相对于当前位置纵向移动的距离，正值向上移动，负值向下移动，单位是像素。</p>

<h2 id="toc_1">scrollBy()</h2>

<p><code>scrollBy()</code>方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直向右下方移动。</p>

<h2 id="toc_2">scrollTo()</h2>

<p><code>scrollTo()</code>方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。</p>

<h2 id="toc_3">Scroller</h2>

<p>目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。<br/>
Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p>

<ul>
<li>创建Scroller的实例</li>
<li>调用startScroll()方法来初始化滚动数据并刷新界面 </li>
<li>重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</li>
</ul>

<h2 id="toc_4">startScroll(int startX,int startY,int dx,int dy)</h2>

<ul>
<li>第一个参数是滚动开始时X的坐标</li>
<li>第二个参数是滚动开始时Y的坐标</li>
<li>第三个参数是横向滚动的距离,正值表示向左滚动</li>
<li>第四个参数是纵向滚动的距离，正值表示向上滚动。</li>
<li>紧接着调用invalidate()方法来刷新界面。</li>
</ul>

<h2 id="toc_5">startScroll (int startX,  int startY, int dx, int dy, int duration)</h2>

<p>同上</p>

<ul>
<li>第五个参数是滑动时间</li>
</ul>

<h2 id="toc_6">computeScroll()</h2>

<p>在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。</p>

<pre><code class="language-java">@Override
public void computeScroll() {
    // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        invalidate();
    }
}
</code></pre>

<h2 id="toc_7">getScrollX() | getScrollY()</h2>

<p>返回当前view在x或者y方向上的滚动距离</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/6</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869629.html">
                
                  <h1>Android-XML参数详细了解</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li><code>android:layout_width</code>    设置组件的宽度   </li>
<li><code>android:layout_height</code>   设置组件的高度   </li>
<li><code>android:id</code>                       给组件定义一个id值，供后期使用   </li>
<li><code>android:background</code>       设置组件的背景颜色或背景图片   </li>
<li><code>android:text</code>                   设置组件的显示文字   </li>
<li><code>android:textColor</code>           设置组件的显示文字的颜色   </li>
<li><code>android:layout_below</code>     组件在参考组件的下面   </li>
<li><code>android:alignTop</code>            同指定组件的顶平行</li>
<li><code>android:maxLength=&quot;6&quot;</code>           限制输入字数</li>
<li><code>android:digits=&#39;012356789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code>                          限制输入数字和大写小写字母</li>
<li><code>android:password=&#39;true&#39;</code>                        这条可以让EditText显示的内容自动为 星号，输入时内容会在1秒内变成*字样。</li>
<li><code>android:numeric=&#39;true&#39;</code>         这条可以让输入法自动变为数字输入键盘，同时仅允许0-9的数字输入</li>
<li><code>android:capitalize=&#39;cwj1987&#39;</code>           这样仅允许接受输入cwj1987，一般用于密码验证</li>
<li><code>android:editable=&#39;false&#39;</code>          设置EditText不可编辑</li>
<li><code>android:singleLine=&#39;true&#39;</code>          强制输入的内容在单行</li>
<li><code>android:ellipsize=&#39;end&#39;</code>               自动隐藏尾部溢出数据，一般用于文字内容过长一行无法全部显示时。</li>
<li><code>android:autoLink</code>               设置是否当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接。可选值(none/web/email/phone/map/all) </li>
<li><code>android:autoText</code>             如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。 </li>
<li><code>android:bufferType</code>               指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。spannable 则可在给定的字符区域使用样式，参见这里1、这里2。 </li>
<li><code>android:capitalize</code>             设置英文字母大写类型。此处无效果，需要弹出输入法才能看得到，参见EditText此属性说明。 </li>
<li><code>android:cursorVisible</code>              设定光标为显示/隐藏，默认显示。 </li>
<li><code>android:digits</code>           设置允许输入哪些字符。如“1234567890.+-*/%\n()” </li>
<li><code>android:drawableBottom</code>                 在text的下方输出一个drawable，如图片。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。 </li>
<li><code>android:drawableLeft</code>          在text的左边输出一个drawable，如图片。 </li>
<li><code>android:drawablePadding</code>         设置text与drawable(图片)的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。 </li>
<li><code>android:drawableRight</code>             在text的右边输出一个drawable，如图片。 </li>
<li><code>android:drawableTop</code>                在text的正上方输出一个drawable，如图片。 </li>
<li><code>android:editable</code>              设置是否可编辑。这里无效果，参见EditView。 </li>
<li><code>android:editorExtras</code>          设置文本的额外的输入数据。在EditView再讨论。 </li>
<li><code>android:ellipsize</code>                    设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动) </li>
<li><code>android:freezesText</code>         设置保存文本的内容以及光标的位置。参见：这里。 </li>
<li><code>android:gravity</code>             设置文本位置，如设置成“center”，文本将居中显示。 </li>
<li><code>android:hint</code>                 Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。此属性在EditView中使用，但是这里也可以用。 </li>
<li><code>android:imeOptions</code>                        附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。这个在EditText中再详细说明，此处无用。 </li>
<li><code>android:imeActionId</code>               设置IME动作ID。在EditText再做说明，可以先看这篇帖子：这里。 </li>
<li><code>android:imeActionLabel</code>                设置IME动作标签。在EditText再做说明。 </li>
<li><code>android:includeFontPadding</code>                  设置文本是否包含顶部和底部额外空白，默认为true。 </li>
<li><code>android:inputMethod</code>                    为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。 </li>
<li><code>android:inputType</code>             设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditText中再详细说明，这里无效果。 </li>
<li><code>android:linksClickable</code> 设置链接是否点击连接，即使设置了autoLink。 </li>
<li><code>android:marqueeRepeatLimit</code> 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。 </li>
<li><code>android:ems</code> 设置TextView的宽度为N个字符的宽度。</li>
<li><code>android:maxEms</code> 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。 </li>
<li><code>android:minEms</code> 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。 </li>
<li><code>android:maxLength</code> 限制显示的文本长度，超出部分不显示。 </li>
<li><code>android:lines</code> 设置文本的行数，设置两行就显示两行，即使第二行没有数据。 </li>
<li><code>android:maxLines</code> 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。 </li>
<li><code>android:minLines</code> 设置文本的最小行数，与lines类似。 </li>
<li><code>android:lineSpacingExtra</code> 设置行间距。 </li>
<li><code>android:lineSpacingMultiplier</code> 设置行间距的倍数。如”1.2” </li>
<li><code>android:numeric</code> 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EditText将详细说明。 </li>
<li><code>android:password</code> 以小点”.”显示文本 </li>
<li><code>android:phoneNumber</code> 设置为电话号码的输入方式。 </li>
<li><code>android:privateImeOptions</code> 设置输入法选项，此处无用，在EditText将进一步讨论。 </li>
<li><code>android:scrollHorizontally</code> 设置文本超出TextView的宽度的情况下，是否出现横拉条。 </li>
<li><code>android:selectAllOnFocus</code> 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。EditText中设置后无效果。 </li>
<li><code>android:shadowColor</code> 指定文本阴影的颜色，需要与shadowRadius一起使用。</li>
<li><code>android:shadowDx</code> 设置阴影横向坐标开始位置。 </li>
<li><code>android:shadowDy</code> 设置阴影纵向坐标开始位置。 </li>
<li><code>android:shadowRadius</code> 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。 </li>
<li><code>android:singleLine</code> 设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=&quot;test_ singleLine &quot; android:singleLine=&quot;true&quot; android:layout_width=&quot;20dp&quot;将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行 android:text 设置显示文本. </li>
<li><code>android:textAppearance</code> 设置文字外观。如“?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，？表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/textAppearanceMediumInverse/textAppearanceSmall/textAppearanceSmallInverse </li>
<li><code>android:textColor</code> 设置文本颜色 </li>
<li><code>android:textColorHighlight</code> 被选中文字的底色，默认为蓝色 </li>
<li><code>android:textColorHint</code> 设置提示信息文字的颜色，默认为灰色。与hint一起使用。 </li>
<li><code>android:textColorLink</code> 文字链接的颜色. </li>
<li><code>android:textScaleX</code> 设置文字之间间隔，默认为1.0f。分别设置0.5f/1.0f/1.5f/2.0f</li>
<li><code>android:textSize</code>           设置文字大小，推荐度量单位”sp”，如”15sp” </li>
<li><code>android:textStyle</code>                设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开 android:typeface 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3] </li>
<li><code>android:height</code> 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米) </li>
<li><code>android:maxHeight</code>            设置文本区域的最大高度 </li>
<li><code>android:minHeight</code>         设置文本区域的最小高度 </li>
<li><code>android:width</code>                   设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)，与layout_width的区别看这里。 </li>
<li><code>android:maxWidth</code>           设置文本区域的最大宽度 </li>
<li><code>android:minWidth</code>          设置文本区域的最小宽度</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869583.html">
                
                  <h1>Android-ViewPager详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">简介</h2>

<p>ViewPager是android扩展包v4包中的类，这个类可以让用户左右切换当前的view</p>

<ul>
<li>ViewPager类直接继承了ViewGroup类，所有它是一个容器类，可以在其中添加其他的view类。</li>
<li>ViewPager类需要一个PagerAdapter适配器类给它提供数据。</li>
<li>ViewPager经常和Fragment一起使用，并且提供了专门的FragmentPagerAdapter和FragmentStatePagerAdapter类供Fragment中的ViewPager使用。</li>
</ul>

<h2 id="toc_1">ViewPager的适配器</h2>

<p>简介中提到了PagerAdapter，和ListView等控件使用一样,需要ViewPager设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是一个基类适配器，我们经常用它来实现app引导图，它的子类有FragmentPagerAdapter和FragmentStatePagerAdapter,这两个子类适配器用于和Fragment一起使用，在安卓应用中它们就像listview一样出现的频繁。</p>

<h3 id="toc_2">实现一个最基本的PagerAdapter,必须实现四个方法，在代码里有注释</h3>

<pre><code class="language-java">public class AdapterViewpager extends PagerAdapter {
    private List&lt;View&gt; mViewList;

    public AdapterViewpager(List&lt;View&gt; mViewList) {
        this.mViewList = mViewList;
    }

    @Override
    public int getCount() {//必须实现,返回要滑动的VIew的个数
        return mViewList.size();
    }

    @Override
    public boolean isViewFromObject(View view, Object object) {//必须实现,该函数用来判断instantiateItem(ViewGroup, int)函数所返回来的Key与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View)
        return view == object;
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {//必须实现，做了两件事，第一：将当前视图添加到container中，第二：返回当前View
        container.addView(mViewList.get(position));
        return mViewList.get(position);
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {//必须实现，从当前container中删除指定位置（position）的View
        container.removeView(mViewList.get(position));
    }
}
</code></pre>

<h3 id="toc_3">实现一个最基本的FragmentPagerAdapter</h3>

<pre><code class="language-java">public class AdapterFragment extends FragmentPagerAdapter {
    private List&lt;Fragment&gt; mFragments;

    public AdapterFragment(FragmentManager fm, List&lt;Fragment&gt; mFragments) {
        super(fm);
        this.mFragments = mFragments;
    }

    @Override
    public Fragment getItem(int position) {//必须实现
        return mFragments.get(position);
    }

    @Override
    public int getCount() {//必须实现
        return mFragments.size();
    }

    @Override
    public CharSequence getPageTitle(int position) {//选择性实现
        return mFragments.get(position).getClass().getSimpleName();
    }
}
</code></pre>

<p>PagerAdapter是基类适配器是一个通用的ViewPager适配器，相比PagerAdapter，FragmentPagerAdapter和FragmentStatePagerAdapter更专注于每一页是Fragment的情况，而这两个子类适配器使用情况也是有区别的。FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况。为什么？简单分析下两个适配器的源码就可以知道了。</p>

<p><strong>源码略，查官网</strong></p>

<p>从源码中我们可以看出FragmentStatePagerAdapter中fragment实例在destroyItem的时候被真正释放，所以FragmentStatePagerAdapter省内存。FragmentPagerAdapter中的fragment实例在destroyItem的时候并没有真正释放fragment对象只是detach，所以FragmentPagerAdapter消耗更多的内存，带来的好处就是效率更高一些。所以得出这样的结论：FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况，因此不同的场合选择合适的适配器才是正确的做法。</p>

<h2 id="toc_4">ViewPager的翻页动画</h2>

<p>为ViewPager设置适配器后，就可以正常使用了，接下来我们为ViewPager增加翻页动画，毕竟人的审美会疲劳，加上一些动画交互会提高不少逼格~~，ViewPager提供了PageTransformer接口用于实现翻页动画。官方提供了PageTransformer的实现例子。</p>

<h3 id="toc_5">例一</h3>

<pre><code class="language-java"> public class DepthPageTransformer implements ViewPager.PageTransformer {
    private static final float MIN_SCALE = 0.75f;

    public void transformPage(View view, float position) {
        Log.d(&quot;DepthPageTransformer&quot;, view.getTag() + &quot; , &quot; + position + &quot;&quot;);
        int pageWidth = view.getWidth();

        if (position &lt; -1) { // [-Infinity,-1)
            // This page is way off-screen to the left.
            view.setAlpha(0);

        } else if (position &lt;= 0) { // [-1,0]
            // Use the default slide transition when moving to the left page
            view.setAlpha(1);
            view.setTranslationX(0);
            view.setScaleX(1);
            view.setScaleY(1);

        } else if (position &lt;= 1) { // (0,1]
            // Fade the page out.
            view.setAlpha(1 - position);

            // Counteract the default slide transition
            view.setTranslationX(pageWidth * -position);

            // Scale the page down (between MIN_SCALE and 1)
            float scaleFactor = MIN_SCALE
                    + (1 - MIN_SCALE) * (1 - Math.abs(position));
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);

        } else { // (1,+Infinity]
            // This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}
</code></pre>

<h3 id="toc_6">例二</h3>

<pre><code class="language-java"> public class ZoomOutPageTransformer implements ViewPager.PageTransformer {
    private static final float MIN_SCALE = 0.85f;
    private static final float MIN_ALPHA = 0.5f;

    @SuppressLint(&quot;NewApi&quot;)
    public void transformPage(View view, float position) {
        int pageWidth = view.getWidth();
        int pageHeight = view.getHeight();

        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);

        if (position &lt; -1) { // [-Infinity,-1)
            // This page is way off-screen to the left.
            view.setAlpha(0);

        } else if (position &lt;= 1) 
        { // [-1,1]
            // Modify the default slide transition to shrink the page as well
            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
            float vertMargin = pageHeight * (1 - scaleFactor) / 2;
            float horzMargin = pageWidth * (1 - scaleFactor) / 2;
            if (position &lt; 0) {
                view.setTranslationX(horzMargin - vertMargin / 2);
            } else {
                view.setTranslationX(-horzMargin + vertMargin / 2);
            }

            // Scale the page down (between MIN_SCALE and 1)
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);

            // Fade the page relative to its size.
            view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE)
                    / (1 - MIN_SCALE) * (1 - MIN_ALPHA));

        } else { // (1,+Infinity]
            // This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}
</code></pre>

<p>实现翻页动画的关键就是重写transformPage方法，方法里有两个参数view和position,理解这两个参数非常重要。假设有三个页面view1，view2，view3从左至右在viewPager中显示</p>

<ul>
<li>往左滑动时：view1，view2，view3的position都是不断变小的。
<code>
           view1的position: 0 → -1 → 负无穷大<br/>
           view2的position: 1 → 0 → -1 <br/>
           view3的position: 1 → 0
</code></li>
<li>往右滑动时：view1，view2，view3的position都是不断变大的。
<code>
           view1的position: -1 → 0 <br/>
           view2的position: -1 → 0 → 1 <br/>
           view3的position: 0 → 1→ 正无穷大
</code>
当position是正负无穷大时view就离开屏幕视野了。因此最核心的控制逻辑是在[-1,0]和(0,1]这两个区间，通过设置透明度，平移，旋转，缩放等动画组合可以实现各式各样的页面变化效果。</li>
</ul>

<h3 id="toc_7">简化ViewPager的使用</h3>

<ul>
<li>PagerAdapter简化</li>
</ul>

<pre><code class="language-java">public class QuickPageAdapter&lt;T extends View&gt; extends PagerAdapter {
  private List&lt;T&gt; mList;

  public QuickPageAdapter(List&lt;T&gt; mList) {
      this.mList = mList;
  }

  @Override
  public int getCount() {
      return mList.size();
  }

  @Override
  public boolean isViewFromObject(View view, Object object) {
      return object == view;
  }

  @Override
  public Object instantiateItem(ViewGroup container, int position) {
      container.addView(mList.get(position));
      return mList.get(position);
  }

  @Override
  public void destroyItem(ViewGroup container, int position, Object object) {
      container.removeView(mList.get(position));
  }
}
</code></pre>

<p>使用它，这样不用每次都写个适配器List<View> views = new ArrayList&lt;&gt;();...mViewPager.setAdapter(new QuickPageAdapter<View>(views));</p>

<ul>
<li>FragmentPagerAdapter简化</li>
</ul>

<pre><code class="language-java">public class QuickFragmentPageAdapter&lt;T extends Fragment&gt; extends FragmentPagerAdapter {
  private List&lt;T&gt; mList;
  private String[] mStrings;

  /**
   * @param fm
   * @param list
   * @param titles PageTitles
   */
  public QuickFragmentPageAdapter(FragmentManager fm, List&lt;T&gt; list, String[] titles) {
      super(fm);
      mList = list;
      mStrings = titles;
  }

  @Override
  public Fragment getItem(int position) {
      return mList.get(position);
  }

  @Override
  public int getCount() {
      return mList.size();
  }

  @Override
  public CharSequence getPageTitle(int position) {
      return mStrings == null ? super.getPageTitle(position) : mStrings[position];
  }
}
</code></pre>

<h2 id="toc_8">PagerTitleStrip</h2>

<ul>
<li>将它作为子控件添加在xml布局文件中的ViewPager中</li>
<li>标题的获取，是重写适配器的getPageTitle(int)函数来获取的。</li>
</ul>

<p>重写CharSequence <code>getPageTitle(int)</code>函数来对其进行实现</p>

<h2 id="toc_9">PagerTabStrip</h2>

<ul>
<li>PagerTabStrip在当前页面下，会有一个下划线条来提示当前页面的Tab是哪个。</li>
<li>PagerTabStrip的Tab是可以点击的，当用户点击某一个Tab时，当前页面就会跳转到这个页面，而PagerTitleStrip则没这个功能。</li>
<li>将它作为子控件添加在xml布局文件中的ViewPager中</li>
<li>标题的获取，是重写适配器的getPageTitle(int)函数来获取的。</li>
</ul>

<h3 id="toc_10">扩展：PagerTabStrip属性更改</h3>

<p><code>setTabIndicatorColorResource</code>——修改Tab颜色<br/><br/>
重写适配器CharSequence getPageTitle(int)方法——添加标题</p>

<h3 id="toc_11">总结PagerTitleStrip和PagerTabStrip</h3>

<p>通过前面的讲解，我们应该清楚的认识到PagerTabStrip与PagerTitleStrip在添加标题栏的异同，但他们实现的标题栏效果很不好，不能指定一个页面一次显示一个，或者全部显示，而且标题还滑动。所以注定主流的App都没有用这个玩意的。所以这里也只是一个过渡，在开发中，我们也不建议使用这两个东东。</p>

<h2 id="toc_12">SimpleOnPageChangeListener</h2>

<p>如果不想继承实现<code>ViewPager.OnPageChangeListener</code>的方法，可以直接继承SimpleOnPageChangeListener对ViewPager的页面滑动事件进行简单的处理。</p>

<ul>
<li> <strong>onPageScrolled] (int position, float positionOffset, int positionOffsetPixels)：</strong>
<ul>
<li>position:当前的位置</li>
<li>positionoffset:当前滚动比例（左－右／0-1）（右－左／1-0）</li>
<li>positionOffsetPixels：当前实际滚动的像素（左－右／0-页宽） （右－左／页宽－0）<br/>
被调用的场景： ViewPager滚动时总被回调，这个函数在操作ViewPager时被回调很多次。</li>
</ul></li>
<li>手指拖动 action_move 。n次</li>
<li><p>惯性还原 computeScroll()。n次<br/>
使用场景：做view的动画效果时可以用这个回调函数。</p></li>
<li><p><strong>onPageSelected(int position)</strong><br/>
被调用的场景：ViewPager确定页面是哪一页时。1次</p></li>
<li><p>手指拖动后抬起 action_up 。1次</p></li>
<li><p>或者手指滑动超出屏幕时 action_cancel。1次<br/>
使用场景：页面切换后改变对应的tab的状态可以用这个回调函数。</p></li>
<li><p><strong>onPageScrollStateChange (int state):</strong><br/>
被调用的场景：ViewPager状态切换时被调用。这个函数在操作ViewPager时被回调3次。</p>
<ul>
<li>开始滚动 dragging拖动状态。1次</li>
<li>惯性滚动 settling还原状态。1次</li>
<li>滚动结束 idle空闲状态。1次<br/>
使用场景：做页面状态变化后引起的view特效时可以用这个回调函数</li>
</ul></li>
</ul>

<h2 id="toc_13">ViewPager.OnPageChangeListener</h2>

<ul>
<li><code>onPageScrollStateChanged(int state)</code>//在状态改变的时候调用其中arg0这个参数有三种状态（0，1，2）。arg0 <mark>1表示正在滑动，arg0</mark>2表示滑动完毕了，arg0==0表示什么都没做。当页面开始滑动的时候，三种状态的变化顺序为(1,2,0)</li>
<li><code>onPageScrolled(int position, float positionOffset, int positionOffsetPixels)</code>//当页面在滑动的时候会调用此方法，在滑动被停止之前，此方法回一直得到调用。其中三个参数的含义分别为：arg0 :当前页面，及你点击滑动的页面。arg1:当前页面偏移的百分比。arg2:当前页面偏移的像素位置</li>
<li><code>onPageSelected(int position)</code>//页面跳转完后得到调用，arg0是你当前选中的页面的position</li>
</ul>

<h2 id="toc_14">ViewPager.OnAdapterChangeListener</h2>

<p><code>void onAdapterChanged ( ViewPagerew viewPager, PagerAdapter oldAdapter,PagerAdapter newAdapter)</code></p>

<ul>
<li>viewPager:  ViewPager where the adapter change has happened(传入发生改变的ViewPager)</li>
<li>oldAdapter: the previously set adapter(老的adapter)</li>
<li>newAdapter: the newly set adapter(新的adapter)</li>
</ul>

<h2 id="toc_15">注意点</h2>

<p><code>mViewPager.setOffscreenPageLimit()</code>//这个方法是用来控制fragment不重新走生命周期的个数的，打个比方一共4个fragment页面，如果<code>mViewPager.setOffscreenPageLimit(3)</code>，那么所有的fragment都只走一次生命周期，如果是<code>mViewPager.setOffscreenPageLimit(2)</code>，那么其中有一个fragment会在切换的时候重新走一遍生命周期，<code>FragmentStatePagerAdapter</code>和<code>FragmentPagerAdapter</code>都是这样，但是<code>FragmentPagerAdapter</code>设置<code>setOffscreenPageLimit()</code>不影响fragment缓存的个数,而<code>FragmentStatePagerAdapter</code>缓存的fragment实例个数就是<code>setOffscreenPageLimit()</code>设置的值+1。另外<code>setOffscreenPageLimit()</code>的缺省值是1，设置0是无效的会被强制赋值成1。</p>

<h2 id="toc_16">提高</h2>

<h3 id="toc_17">ViewPager结合第三方库实现小圆点指示器效果</h3>

<p><a href="https://github.com/ongakuer/CircleIndicator">https://github.com/ongakuer/CircleIndicator</a></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170221497391480849-687604baae5b6559.gif" alt="20170221497391480849-687604baae5b6559.gif"/></p>

<p>使用看官方文档很简单。</p>

<p><strong>看一下实现思路</strong></p>

<pre><code class="language-java">public void setViewPager(ViewPager viewPager) {
        mViewpager = viewPager;
        if (mViewpager != null &amp;&amp; mViewpager.getAdapter() != null) {
            mLastPosition = -1;
            createIndicators();
            mViewpager.removeOnPageChangeListener(mInternalPageChangeListener);
            mViewpager.addOnPageChangeListener(mInternalPageChangeListener);//绑定上内部实现的PageChangeListener
            mInternalPageChangeListener.onPageSelected(mViewpager.getCurrentItem());
        }
    }

    private final OnPageChangeListener mInternalPageChangeListener = new OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        }

        @Override public void onPageSelected(int position) {//这里是动画的核心

            if (mViewpager.getAdapter() == null || mViewpager.getAdapter().getCount() &lt;= 0) {
                return;
            }

            if (mAnimatorIn.isRunning()) {
                mAnimatorIn.end();
                mAnimatorIn.cancel();
            }

            if (mAnimatorOut.isRunning()) {
                mAnimatorOut.end();
                mAnimatorOut.cancel();
            }

            View currentIndicator;
            if (mLastPosition &gt;= 0 &amp;&amp; (currentIndicator = getChildAt(mLastPosition)) != null) {//页面离开屏幕时指示器动画
                currentIndicator.setBackgroundResource(mIndicatorUnselectedBackgroundResId);
                mAnimatorIn.setTarget(currentIndicator);
                mAnimatorIn.start();
            }

            View selectedIndicator = getChildAt(position);
            if (selectedIndicator != null) {//页面进入屏幕时指示器动画
                selectedIndicator.setBackgroundResource(mIndicatorBackgroundResId);
                mAnimatorOut.setTarget(selectedIndicator);
                mAnimatorOut.start();
            }
            mLastPosition = position;
        }

        @Override public void onPageScrollStateChanged(int state) {
        }
    };
</code></pre>

<h3 id="toc_18">ViewPager结合design库实现tab切换</h3>

<p>在design库中有个TabLayout可以为viewPager加上Tab标题头</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;com.example.administrator.viewpager.MainActivity&quot;&gt;

    &lt;android.support.design.widget.TabLayout
        android:id=&quot;@+id/mTabLayout&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;&lt;/android.support.design.widget.TabLayout&gt;

    &lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/mViewPager&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;&lt;/android.support.v4.view.ViewPager&gt;

&lt;/LinearLayout&gt;

mTabLayout.setupWithViewPager(mViewPager);//一行代码完成绑定
</code></pre>

<p>更多高级的用法包括tab中添加icon等请转至这里<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0731/3247.html">传送门</a></p>

<h3 id="toc_19">基于ViewPager实现广告轮播控件</h3>

<p><a href="https://github.com/daimajia/AndroidImageSlider">https://github.com/daimajia/AndroidImageSlider</a></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170222397961480849-687604baae5b6559.gif" alt="20170222397961480849-687604baae5b6559.gif"/></p>

<p><strong>源码分析，省略了部分代码</strong>：</p>

<pre><code class="language-java">public class SliderLayout extends RelativeLayout{

    private InfiniteViewPager mViewPager;//这个ViewPager只是修改了setPageTransformer方法去掉了if (Build.VERSION.SDK_INT &gt;= 11) 的限制，结合NineOldDroid库让动画兼容低版本

    /**
     * InfiniteViewPager adapter.
     */
    private SliderAdapter mSliderAdapter;//这个是PagerAdapter

    /**
     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} indicator.
     */
    private PagerIndicator mIndicator;//页面指示器


    /**
     * A timer and a TimerTask using to cycle the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}.
     */
    private Timer mCycleTimer;//用于轮播的定时器
    private TimerTask mCycleTask;

    /**
     * For resuming the cycle, after user touch or click the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}.
     */
    private Timer mResumingTimer;
    private TimerTask mResumingTask;

    /**
     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} &#39;s transformer
     */
    private BaseTransformer mViewPagerTransformer;//PageTransformer的封装用于控制页面翻页效果

    public SliderLayout(Context context, AttributeSet attrs, int defStyle) {//核心代码，用于初始化ViewPager
        super(context, attrs, defStyle);
        mContext = context;
        LayoutInflater.from(context).inflate(R.layout.slider_layout, this, true);

        final TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs,R.styleable.SliderLayout,
                defStyle,0);

        mTransformerSpan = attributes.getInteger(R.styleable.SliderLayout_pager_animation_span, 1100);
        mTransformerId = attributes.getInt(R.styleable.SliderLayout_pager_animation, Transformer.Default.ordinal());
        mAutoCycle = attributes.getBoolean(R.styleable.SliderLayout_auto_cycle,true);
        int visibility = attributes.getInt(R.styleable.SliderLayout_indicator_visibility,0);
        for(PagerIndicator.IndicatorVisibility v: PagerIndicator.IndicatorVisibility.values()){
            if(v.ordinal() == visibility){
                mIndicatorVisibility = v;
                break;
            }
        }
        mSliderAdapter = new SliderAdapter(mContext);
        PagerAdapter wrappedAdapter = new InfinitePagerAdapter(mSliderAdapter);

        mViewPager = (InfiniteViewPager)findViewById(R.id.daimajia_slider_viewpager);
        mViewPager.setAdapter(wrappedAdapter);

        mViewPager.setOnTouchListener(new OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                int action = event.getAction();
                switch (action) {
                     case MotionEvent.ACTION_UP:
                        recoverCycle();
                        break;
                }
                return false;
            }
        });

        attributes.recycle();
        setPresetIndicator(PresetIndicators.Center_Bottom);
        setPresetTransformer(mTransformerId);
        setSliderTransformDuration(mTransformerSpan,null);
        setIndicatorVisibility(mIndicatorVisibility);
        if(mAutoCycle){
            startAutoCycle();
        }
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        int action = ev.getAction();
        switch (action) {
            case MotionEvent.ACTION_DOWN://手指按下时候暂停轮播
                pauseAutoCycle();
                break;
        }
        return false;
    }

    /**
     * preset transformers and their names
     */
    public enum Transformer{//PageTransformer枚举
        Default(&quot;Default&quot;),
        Accordion(&quot;Accordion&quot;),
        Background2Foreground(&quot;Background2Foreground&quot;),
        CubeIn(&quot;CubeIn&quot;),
        DepthPage(&quot;DepthPage&quot;),
        Fade(&quot;Fade&quot;),
        FlipHorizontal(&quot;FlipHorizontal&quot;),
        FlipPage(&quot;FlipPage&quot;),
        Foreground2Background(&quot;Foreground2Background&quot;),
        RotateDown(&quot;RotateDown&quot;),
        RotateUp(&quot;RotateUp&quot;),
        Stack(&quot;Stack&quot;),
        Tablet(&quot;Tablet&quot;),
        ZoomIn(&quot;ZoomIn&quot;),
        ZoomOutSlide(&quot;ZoomOutSlide&quot;),
        ZoomOut(&quot;ZoomOut&quot;);

        private final String name;

        private Transformer(String s){
            name = s;
        }
        public String toString(){
            return name;
        }

        public boolean equals(String other){
            return (other == null)? false:name.equals(other);
        }
    };
}
</code></pre>

<p><strong>通过分析我们可以对SliderLayout实现思路小结一下：</strong></p>

<ol>
<li>内部持有一个修改过的ViewPager控件，可以兼容低版本的页面转换动画</li>
<li>内部有一个实现了PagerAdapter的SliderAdapter适配器</li>
<li>内部持有一个PagerIndicator 页面指示器可供选择</li>
<li>维护一个定时任务用于控制轮播</li>
<li>对手势事件进行处理暂停轮播，继续轮播</li>
<li>提供了很多缺省的PageTransformer方便调用</li>
</ol>

<p>最后在构造函数中初始化ViewPager。</p>

<h2 id="toc_20">自定义 ViewPager 打造千变万化的图片切换效果</h2>

<p>ViewPager使用时间长了，他的切换效果容易觉得枯燥，形成一种审美疲劳<del>我们需要改变，学习学习改变ViewPager切换时的效果，实现个性化的图片切换</del></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170222778011406001554_7159.gif" alt="20170222778011406001554_7159.gif"/></p>

<p>是不是比传统的效果个性很多，嘿嘿<del>其实很简单，学习完这篇博客，保证你可以自定义切换效果，做出各种丧心病狂的切换</del></p>

<h3 id="toc_21">制作前的分析</h3>

<p>观察下效果图，实际上改变的就是切换时的动画，那么简单了，只需要用户在切换时，拿到当前的View和下一个View，然后添加动画是不是就可以了。好，第一步，获取用户切换时的当前View和切换至的目的View。我们再来看一下，如果获取了当前View和目的View，对于动画我们需要缓慢的变化，最好是根据用户的手势滑动。比如上述效果，用户滑动时，目的图片根据用户滑动距离缓缓出现和慢慢变大。好，第二步，设计动画的梯度变化。<br/><br/>
经过分析，我们总结出两个步骤，下面我们开始一步一步来打造~~</p>

<h3 id="toc_22">获取用户切换时当前View和切换至的目的View。</h3>

<p>ViewPager也需要监听用户的手势，所以肯定提供了某个方法。于是纵观ViewPager的方法，发现了一个叫做 onPageScrolled(int position, float positionOffset, int positionOffsetPixels)的方法~~<br/><br/>
没错就是这个方法：在页面滚动时调用~<br/><br/>
下面仔细研究下这几个参数：<br/><br/>
直接说测试结果：<br/><br/>
在非第一页与最后一页时，滑动到下一页，position为当前页位置；滑动到上一页：position为当前页-1<br/><br/>
positionOffset 滑动到下一页，[0,1)区间上变化；滑动到上一页：(1,0]区间上变化<br/><br/>
positionOffsetPixels这个和positionOffset很像：滑动到下一页，[0,宽度)区间上变化；滑动到上一页：(宽度,0]区间上变化<br/>
第一页时：滑动到上一页position=0 ，其他基本为0 ；最后一页滑动到下一页 position为当前页位置，其他两个参数为0<br/><br/>
豁然发现，我们需要的步骤的第二步解决了，positionOffset很适合作为，渐变，缩放的控制参数；positionOffsetPixels则可以作为平移等的控制参数。  </p>

<p><strong><em>那么如何获得当前View和目的View呢：</em></strong><br/><br/>
分享几个我的歧途：</p>

<ul>
<li>【错误】我通过getChildAt(position)，getChildAt(position+1)，getChildAt(position-1)获得滑动时，左右的两个View；乍一看，还真觉得不错<del>在代码写出来，再乍效果也出不来</del>错误原因：我们忽略一个特别大的东西，ViewPager的机制，滑动时动态加载和删除View，ViewPager其实只会维持2到3个View，而position的范围基本属于无限~~</li>
<li>【错误】我通过getCurrentItem获得当前的位置，然后+1，-1获得后一个或者前一个<del>正在窃喜，赶快代码改过来，效果怎么也不对，乱七八糟的</del>仔细观察日志，这个getCurrentItem当用户手指离开的屏幕，Page还在动画执行时，就改变了<del>难怪~整个滑动过程并不是固定的</del>唉，心都碎了~</li>
<li>【错误】position在整个滑动的过程中是不变化的，而且ViewPager会保存2个或3个View;那么我考虑，如果是第一页、或者最后一页那么我取getChildAt(0)和getChildAt(1)，如果在其他页面则为getChildAt(0),getChildAt(2),然后经过一系列的变化～我想这会总该对了吧，于是我遇到第一问题，第一页的时候，不管左右position都为0，尼玛，这哪个为左View，哪个为右View~~<br/>
说了这么多错误，大家可以绕过这些弯路，也能从这些弯路里面看出点什么~<br/>
下面说正确的，其实ViewPager在添加一个View或者销毁一个View时，是我们自己的PageAdapter中控制的，于是我们可以在ViewPager里面维系一个HashMap<Position，View>，然后滑动的时候，通过get（position）取出，比如上述效果，始终是右边的View变化，要么从小到大，要么从大到小<br/>
那么滑倒下一页：左边的View:map.get(position) ，右边的View : map.get(position+1) .<br/>
那么滑倒上一页：左边的View : map.get(position) ， 右边的View : map.get(position+1) ， 一样的，因为滑到上一页，position为当前页-1<br/>
好了，至此，我们分析了且解决了所有步骤。<br/></li>
</ul>

<h3 id="toc_23">代码</h3>

<p><strong>MainActivity</strong>  </p>

<pre><code class="language-java">package com.example.zhy_jazzyviewpager;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.view.Menu;  
import android.view.View;  
import android.view.ViewGroup;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    protected static final String TAG = &quot;MainActivity&quot;;  
    private int[] mImgIds;  
    private MyJazzyViewPager mViewPager;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        mImgIds = new int[] { R.drawable.a, R.drawable.b, R.drawable.c,  
                R.drawable.d };  
        mViewPager = (MyJazzyViewPager) findViewById(R.id.id_viewPager);  
        mViewPager.setAdapter(new PagerAdapter()  
        {  
  
            @Override  
            public boolean isViewFromObject(View arg0, Object arg1)  
            {  
                return arg0 == arg1;  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
                container.removeView((View) object);  
            }  
  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
                ImageView imageView = new ImageView(MainActivity.this);  
                imageView.setImageResource(mImgIds[position]);  
                imageView.setScaleType(ScaleType.CENTER_CROP);  
                container.addView(imageView);  
                mViewPager.setObjectForPosition(imageView, position);  
                return imageView;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
  
}
</code></pre>

<p>这个很常见的代码，就是初始化ViewPager<del>就没啥可说的了</del>有一点需要注意：在instantiateItem方法，我们多调用了一个mViewPager.setObjectForPosition(imageView, position);其实就是为了给我们的Map存值</p>

<p><strong>主要看自定义的ViewPager</strong>  </p>

<pre><code class="language-java">package com.example.zhy_jazzyviewpager;  
  
import java.util.HashMap;  
import java.util.LinkedHashMap;  
  
import android.content.Context;  
import android.support.v4.view.ViewPager;  
import android.util.AttributeSet;  
import android.util.Log;  
import android.view.View;  
  
import com.nineoldandroids.view.ViewHelper;  
  
public class MyJazzyViewPager extends ViewPager  
{  
    private float mTrans;  
    private float mScale;  
    /** 
     * 最大的缩小比例 
     */  
    private static final float SCALE_MAX = 0.5f;  
    private static final String TAG = &quot;MyJazzyViewPager&quot;;  
    /** 
     * 保存position与对于的View 
     */  
    private HashMap&lt;Integer, View&gt; mChildrenViews = new LinkedHashMap&lt;Integer, View&gt;();  
    /** 
     * 滑动时左边的元素 
     */  
    private View mLeft;  
    /** 
     * 滑动时右边的元素 
     */  
    private View mRight;  
  
    public MyJazzyViewPager(Context context, AttributeSet attrs)  
    {  
        super(context, attrs);  
    }  
  
    @Override  
    public void onPageScrolled(int position, float positionOffset,  
            int positionOffsetPixels)  
    {  
  
//      Log.e(TAG, &quot;position=&quot; + position+&quot;, positionOffset = &quot;+positionOffset+&quot; ,positionOffsetPixels =  &quot; + positionOffsetPixels+&quot; , currentPos = &quot; + getCurrentItem());  
          
        //滑动特别小的距离时，我们认为没有动，可有可无的判断  
        float effectOffset = isSmall(positionOffset) ? 0 : positionOffset;  
          
        //获取左边的View  
        mLeft = findViewFromObject(position);  
        //获取右边的View  
        mRight = findViewFromObject(position + 1);  
          
        // 添加切换动画效果  
        animateStack(mLeft, mRight, effectOffset, positionOffsetPixels);  
        super.onPageScrolled(position, positionOffset, positionOffsetPixels);  
    }  
  
    public void setObjectForPosition(View view, int position)  
    {  
        mChildrenViews.put(position, view);  
    }  
  
    /** 
     * 通过过位置获得对应的View 
     *  
     * @param position 
     * @return 
     */  
    public View findViewFromObject(int position)  
    {  
        return mChildrenViews.get(position);  
    }  
  
    private boolean isSmall(float positionOffset)  
    {  
        return Math.abs(positionOffset) &lt; 0.0001;  
    }  
  
    protected void animateStack(View left, View right, float effectOffset,  
            int positionOffsetPixels)  
    {  
        if (right != null)  
        {  
            /** 
             * 缩小比例 如果手指从右到左的滑动（切换到后一个）：0.0~1.0，即从一半到最大 
             * 如果手指从左到右的滑动（切换到前一个）：1.0~0，即从最大到一半 
             */  
            mScale = (1 - SCALE_MAX) * effectOffset + SCALE_MAX;  
            /** 
             * x偏移量： 如果手指从右到左的滑动（切换到后一个）：0-720 如果手指从左到右的滑动（切换到前一个）：720-0 
             */  
            mTrans = -getWidth() - getPageMargin() + positionOffsetPixels;  
            ViewHelper.setScaleX(right, mScale);  
            ViewHelper.setScaleY(right, mScale);  
            ViewHelper.setTranslationX(right, mTrans);  
        }  
        if (left != null)  
        {  
            left.bringToFront();  
        }  
    }  
}
</code></pre>

<p>可以看到，核心代码都是onPageScrolled，我们通过findViewFromObject(position); findViewFromObject(position + 1);分别获取了左右两边的View，然后添加动画效果；当前这个例子添加了两个动画，一个是从0.5放大到1.0或者1.0缩小到0.5，没错由我们的positionOffset提供梯度的变化<del>还有个平移的动画：下一页直接移动到当前屏幕（默认是在右边，可以注释这个效果，怎么运行看看），然后不断的通过positionOffsetPixels抵消原来默认移动时的位移，让用户感觉它就在原地放大缩小</del><br/><br/>
好了，这样就实现了<del>你可以随便写自己喜欢的动画效果，比如在默认上面加个淡入淡出或者神马，随便</del>是不是很随意~~<br/><br/>
我们的布局文件：  </p>

<pre><code class="language-markup">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
  &gt;  
  
    &lt;com.example.zhy_jazzyviewpager.MyJazzyViewPager  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:id=&quot;@+id/id_viewPager&quot; /&gt;  
  
&lt;/RelativeLayout&gt; 
</code></pre>

<h3 id="toc_24">JazzyViewPager的使用</h3>

<p>其实上面的实现就是github上JazzyViewPager的源码，用法不用说了，就是我们的MainActivity，它内置了大概10来种效果，我们可以通过代码或者布局上面设置动画效果<del>我们上面的例子效果，它叫做Stack；<br/><br/>
使用JazzViewPager的代码：其实基本一样</del>最后也会贴上JazzyViewPager的源码的下载  </p>

<p><strong>MainActivity</strong>  </p>

<pre><code class="language-java">package com.jfeinstein.jazzyviewpager;  
  
import com.jfeinstein.jazzyviewpager.JazzyViewPager.TransitionEffect;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.view.View;  
import android.view.ViewGroup;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    protected static final String TAG = &quot;MainActivity&quot;;  
    private int[] mImgIds;  
    private JazzyViewPager mViewPager;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        mImgIds = new int[] { R.drawable.a, R.drawable.b, R.drawable.c,  
                R.drawable.d };  
        mViewPager = (JazzyViewPager) findViewById(R.id.id_viewPager);  
        //设置切换效果  
        mViewPager.setTransitionEffect(TransitionEffect.Stack);  
          
          
        mViewPager.setAdapter(new PagerAdapter()  
        {  
  
            @Override  
            public boolean isViewFromObject(View arg0, Object arg1)  
            {  
                return arg0 == arg1;  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
                container.removeView((View) object);  
            }  
  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
                ImageView imageView = new ImageView(MainActivity.this);  
                imageView.setImageResource(mImgIds[position]);  
                imageView.setScaleType(ScaleType.CENTER_CROP);  
                container.addView(imageView);  
                mViewPager.setObjectForPosition(imageView, position);  
                return imageView;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
}
</code></pre>

<p>与我们的代码唯一区别就是：<br/><br/>
//设置切换效果<br/><br/>
mViewPager.setTransitionEffect(TransitionEffect.Stack);<br/><br/>
它有12中可选的切换效果，其实就是写了12个切换的动画~~~<br/><br/>
好了，最后附上一个我比较喜欢的效果：Tablet  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702229727320140722145522928.gif" alt="201702229727320140722145522928.gif"/></p>

<h2 id="toc_25">实现个性的ViewPager切换动画 实战PageTransformer（兼容Android3.0以下）</h2>

<h3 id="toc_26">概述</h3>

<p>本篇博文，将：</p>

<ol>
<li>介绍如何使用setPageTransformer设置切换动画；</li>
<li>自定义PageTransformer实现个性的切换动画；</li>
<li>该方法在SDK11以下的版本不起作用，我们会对其做一定修改，让其向下兼容。<br/>
官方示例地址：<a href="http://developer.Android.com/training/animation/screen-slide.html">http://developer.Android.com/training/animation/screen-slide.html</a> 有兴趣的可以去看看~~</li>
</ol>

<h3 id="toc_27">setPageTransformer的使用</h3>

<p>首先我们迅速的实现一个传统的ViewPager效果~</p>

<h4 id="toc_28">布局文件</h4>

<pre><code class="language-markup">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot; &gt;  
  
    &lt;android.support.v4.view.ViewPager  
        android:id=&quot;@+id/id_viewpager&quot;  
        android:layout_width=&quot;fill_parent&quot;  
        android:layout_height=&quot;fill_parent&quot; /&gt;  
  
&lt;/RelativeLayout&gt;
</code></pre>

<h4 id="toc_29">MainActivity</h4>

<pre><code class="language-java">package com.zhy.demo_zhy_08_viewpageranim;  
  
import java.util.ArrayList;  
import java.util.List;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.support.v4.view.ViewPager;  
import android.view.View;  
import android.view.ViewGroup;  
import android.view.Window;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    private ViewPager mViewPager;  
    private int[] mImgIds = new int[] { R.drawable.guide_image1,  
            R.drawable.guide_image2, R.drawable.guide_image3 };  
    private List&lt;ImageView&gt; mImageViews = new ArrayList&lt;ImageView&gt;();  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        setContentView(R.layout.activity_main);  
  
        initData();  
  
        mViewPager = (ViewPager) findViewById(R.id.id_viewpager);  
  
        mViewPager.setAdapter(new PagerAdapter()  
        {  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
  
                container.addView(mImageViews.get(position));  
                return mImageViews.get(position);  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
  
                container.removeView(mImageViews.get(position));  
            }  
  
            @Override  
            public boolean isViewFromObject(View view, Object object)  
            {  
                return view == object;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
  
    private void initData()  
    {  
        for (int imgId : mImgIds)  
        {  
            ImageView imageView = new ImageView(getApplicationContext());  
            imageView.setScaleType(ScaleType.CENTER_CROP);  
            imageView.setImageResource(imgId);  
            mImageViews.add(imageView);  
        }  
    }  
  
}
</code></pre>

<p>好了，这样一个传统ViewPager就实现了<del>大家对上面代码应该不会有任何陌生的感觉~运行效果也不用贴图了，大家肯定知道</del></p>

<h4 id="toc_30">PageTransformer</h4>

<p>ViewPager有个方法叫做：<br/><br/>
<code>setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer)</code><br/><br/>
用于设置ViewPager切换时的动画效果，并且google官方还给出了两个示例。<br/><br/>
只需要在上述代码中调用setPageTransformer即可添加切换动画效果~~下面演示google的两个PageTransformer的代码，以及运行效果。  </p>

<h5 id="toc_31">DepthPageTransformer</h5>

<pre><code class="language-java">
public class DepthPageTransformer implements ViewPager.PageTransformer {  
    private static final float MIN_SCALE = 0.75f;  
  
    public void transformPage(View view, float position) {  
        int pageWidth = view.getWidth();  
  
        if (position &lt; -1) { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            view.setAlpha(0);  
  
        } else if (position &lt;= 0) { // [-1,0]  
            // Use the default slide transition when moving to the left page  
            view.setAlpha(1);  
            view.setTranslationX(0);  
            view.setScaleX(1);  
            view.setScaleY(1);  
  
        } else if (position &lt;= 1) { // (0,1]  
            // Fade the page out.  
            view.setAlpha(1 - position);  
  
            // Counteract the default slide transition  
            view.setTranslationX(pageWidth * -position);  
  
            // Scale the page down (between MIN_SCALE and 1)  
            float scaleFactor = MIN_SCALE  
                    + (1 - MIN_SCALE) * (1 - Math.abs(position));  
            view.setScaleX(scaleFactor);  
            view.setScaleY(scaleFactor);  
  
        } else { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            view.setAlpha(0);  
        }  
    }  
}
</code></pre>

<p>调用代码：<br/><br/>
<code>mViewPager.setPageTransformer(true, new DepthPageTransformer());</code><br/><br/>
效果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/201702227053520141028231742399.gif" alt="201702227053520141028231742399.gif"/>  </p>

<h5 id="toc_32">ZoomOutPageTransformer</h5>

<pre><code class="language-java">package com.zhy.view;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.util.Log;  
import android.view.View;  
  
public class ZoomOutPageTransformer implements ViewPager.PageTransformer  
{  
    private static final float MIN_SCALE = 0.85f;  
    private static final float MIN_ALPHA = 0.5f;  
  
    @SuppressLint(&quot;NewApi&quot;)  
    public void transformPage(View view, float position)  
    {  
        int pageWidth = view.getWidth();  
        int pageHeight = view.getHeight();  
  
        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            view.setAlpha(0);  
  
        } else if (position &lt;= 1) //a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0  
        { // [-1,1]  
            // Modify the default slide transition to shrink the page as well  
            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));  
            float vertMargin = pageHeight * (1 - scaleFactor) / 2;  
            float horzMargin = pageWidth * (1 - scaleFactor) / 2;  
            if (position &lt; 0)  
            {  
                view.setTranslationX(horzMargin - vertMargin / 2);  
            } else  
            {  
                view.setTranslationX(-horzMargin + vertMargin / 2);  
            }  
  
            // Scale the page down (between MIN_SCALE and 1)  
            view.setScaleX(scaleFactor);  
            view.setScaleY(scaleFactor);  
  
            // Fade the page relative to its size.  
            view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE)  
                    / (1 - MIN_SCALE) * (1 - MIN_ALPHA));  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            view.setAlpha(0);  
        }  
    }  
}
</code></pre>

<p>调用代码：<br/><br/>
<code>mViewPager.setPageTransformer(true, new ZoomOutPageTransformer());</code>  </p>

<p>效果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/201702224016820141028231715785.gif" alt="201702224016820141028231715785.gif"/></p>

<p>效果图都是google官网上的，我们的测试图会在兼容3.0以下贴出来，不然就重复了~~<br/><br/>
为ViewPager添加切换就一行代码是不是很happy，可惜是不兼容3.0以下的版本的，该方法的注释上写到：<br/><br/>
setting a PageTransformer prior to Android 3.0 (API 11) will have no effect 在3.0之前的版本设置此方法是没有效果的，那么下面我们就看如何让其兼容3.0以下版本。  </p>

<h3 id="toc_33">版本的向下兼容</h3>

<h4 id="toc_34">不兼容的原因</h4>

<p>首先看下为什么不兼容，3.0以下呢？<br/><br/>
看上面的两个示例代码，代码中View的动画使用的是属性动画，而属性动画是3.0才推出的，那么这么写肯定是不兼容3.0以下了~<br/><br/>
那么我们首先引入nineoldandroids，让动画先能在3.0以下跑再说：<br/><br/>
修改DepthPageTransformer  </p>

<pre><code class="language-java">package com.zhy.view;  
  
import com.nineoldandroids.view.ViewHelper;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.view.View;  
  
public class DepthPageTransformer implements ViewPager.PageTransformer  
{  
    private static final float MIN_SCALE = 0.75f;  
  
    public void transformPage(View view, float position)  
    {  
        int pageWidth = view.getWidth();  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            // view.setAlpha(0);  
            ViewHelper.setAlpha(view, 0);  
        } else if (position &lt;= 0)// a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0  
        { // [-1,0]  
            // Use the default slide transition when moving to the left page  
            // view.setAlpha(1);  
            ViewHelper.setAlpha(view, 1);  
            // view.setTranslationX(0);  
            ViewHelper.setTranslationX(view, 0);  
            // view.setScaleX(1);  
            ViewHelper.setScaleX(view, 1);  
            // view.setScaleY(1);  
            ViewHelper.setScaleY(view, 1);  
  
        } else if (position &lt;= 1)  
        { // (0,1]  
            // Fade the page out.  
            // view.setAlpha(1 - position);  
            ViewHelper.setAlpha(view, 1 - position);  
  
            // Counteract the default slide transition  
            // view.setTranslationX(pageWidth * -position);  
            ViewHelper.setTranslationX(view, pageWidth * -position);  
  
            // Scale the page down (between MIN_SCALE and 1)  
            float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - position);  
            // view.setScaleX(scaleFactor);  
            ViewHelper.setScaleX(view, scaleFactor);  
            // view.setScaleY(1);  
            ViewHelper.setScaleY(view, scaleFactor);  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            // view.setAlpha(0);  
            ViewHelper.setAlpha(view, 1);  
        }  
    }  
}
</code></pre>

<p>很简单，把所有属性动画换成ViewHelper去设置就好了。现在我们去3.0以下的机子上去运行，发现还是没有效果~~<br/><br/>
为什么呢？<br/><br/>
我们再去看看setPageTransformer的源码：  </p>

<pre><code class="language-java">public void setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) {  
       if (Build.VERSION.SDK_INT &gt;= 11) {  
           final boolean hasTransformer = transformer != null;  
           final boolean needsPopulate = hasTransformer != (mPageTransformer != null);  
           mPageTransformer = transformer;  
           setChildrenDrawingOrderEnabledCompat(hasTransformer);  
           if (hasTransformer) {  
               mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;  
           } else {  
               mDrawingOrder = DRAW_ORDER_DEFAULT;  
           }  
           if (needsPopulate) populate();  
       }  
   }
</code></pre>

<p>终于发现原因了，原来在此方法内部判断了如果是11以上的版本才让动画生效~~<br/><br/>
那么，没办法了，如果想兼容，必须修改ViewPager的源码了~~  </p>

<h4 id="toc_35">完美向下兼容</h4>

<p>我们将ViewPager的源码拷贝一份至我们的项目中，修改名称为ViewPagerCompat；然后注释掉SDK版本判断那一句  </p>

<pre><code class="language-java">public class ViewPagerCompat extends ViewGroup {  
    public void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer) {  
//        if (Build.VERSION.SDK_INT &gt;= 11)   
        {  
            final boolean hasTransformer = transformer != null;  
            final boolean needsPopulate = hasTransformer != (mPageTransformer != null);  
            mPageTransformer = transformer;  
            setChildrenDrawingOrderEnabledCompat(hasTransformer);  
            if (hasTransformer) {  
                mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;  
            } else {  
                mDrawingOrder = DRAW_ORDER_DEFAULT;  
            }  
            if (needsPopulate) populate();  
        }  
    }
 }
 ```
 
注意，所有的PageTransformer使用ViewPager.PageTransformer  
然后我们把项目中的ViewPager改为ViewPagerCompat；记得修改布局文件，以及MainActivity中的ViewPager为ViewPagerCompat
我们在2.3.3的模拟器上测试下效果：  
![201702225837420141028231840899.gif](http://ohtrrgyyd.bkt.clouddn.com/201702225837420141028231840899.gif)

可以看到，我们的切换动画完美的运行在2.3.3的机器上~~so happy ~~没有ViewPager源码的童鞋不要紧，我会在文末的源码下载中加入ViewPager源码，让你可以尽情去测试~~  
当然了，仅仅是兼容当然不能满足我们的好奇心，难道我们做到了兼容，还只能使用Google给的示例动画么~~我们强大的创新呢~~下面带领大家分析setPageTransformer方法，然后设计一个个性的动画切换效果  

#### 自定义PageTransformer实现个性切换动画

``` java

public interface PageTransformer {  
       /** 
        * Apply a property transformation to the given page. 
        * 
        * @param page Apply the transformation to this page 
        * @param position Position of page relative to the current front-and-center 
        *                 position of the pager. 0 is front and center. 1 is one full 
        *                 page position to the right, and -1 is one page position to the left. 
        */  
       public void transformPage(View page, float position);  
   }
</code></pre>

<p>可以看到该接口只有一个方法，第一个是我们的view，第二个是position~~<br/><br/>
当我们滑动时：会打印出当然ViewPager中存活的每个View以及它们的position的变化<del>注意是每一个，所以建议别只log position，不然你会觉得莫名其妙的输出</del><br/><br/>
position的可能性的值有，其实从官方示例的注释就能看出：<br/><br/>
[-Infinity,-1)  已经看不到了<br/><br/>
(1,+Infinity] 已经看不到了<br/><br/>
 [-1,1] <br/>
重点看[-1,1]这个区间 ， 其他两个的View都已经看不到了~~  </p>

<p>假设现在ViewPager在A页现在滑出B页，则:<br/><br/>
A页的position变化就是( 0, -1]<br/><br/>
B页的position变化就是[ 1 , 0 ]<br/><br/>
知道了我们滑动时position的变化~~那么就开始设计我们的个性的切换效果；<br/><br/>
官方给的例子，有变化透明度、偏移量、缩放的，我们准备来个不一样的，我们变化角度，即rotation;<br/><br/>
大概的效果是这样的：  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170222949151414293422_1593.gif" alt="20170222949151414293422_1593.gif"/>  </p>

<p>下面我们分析代码：<br/><br/>
我们设置View的旋转中心为：<br/><br/>
ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);<br/><br/>
ViewHelper.setPivotY(view, view.getMeasuredHeight());<br/><br/>
依然是ViewPager在A页现在滑出B页<br/><br/>
那么A页应当在滑动过程中0度到-20度的偏移，B页应当在滑动过程中+20度到0度的偏移<br/><br/>
结合<br/><br/>
A页的position变化就是( 0, -1]<br/><br/>
B页的position变化就是[ 1 , 0 ]<br/><br/>
那么旋转的角度即：mRot = (20 * position); A页 mRot :0 ,~ -20 ; B页 mRot :20 ~ 0  ;<br/><br/>
瞬间觉得好简单： </p>

<p><strong>完整代码</strong>：  </p>

<pre><code class="language-java">package com.zhy.view;  
  
import com.nineoldandroids.view.ViewHelper;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.util.Log;  
import android.view.View;  
  
public class RotateDownPageTransformer implements ViewPager.PageTransformer  
{  
      
    private static final float ROT_MAX = 20.0f;  
    private float mRot;  
      
  
      
    public void transformPage(View view, float position)  
    {  
  
        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            ViewHelper.setRotation(view, 0);  
  
        } else if (position &lt;= 1) // a页滑动至b页 ； a页从 0.0 ~ -1 ；b页从1 ~ 0.0  
        { // [-1,1]  
            // Modify the default slide transition to shrink the page as well  
            if (position &lt; 0)  
            {  
  
                mRot = (ROT_MAX * position);  
                ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);  
                ViewHelper.setPivotY(view, view.getMeasuredHeight());  
                ViewHelper.setRotation(view, mRot);  
            } else  
            {  
  
                mRot = (ROT_MAX * position);  
                ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);  
                ViewHelper.setPivotY(view, view.getMeasuredHeight());  
                ViewHelper.setRotation(view, mRot);  
            }  
  
            // Scale the page down (between MIN_SCALE and 1)  
  
            // Fade the page relative to its size.  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            ViewHelper.setRotation(view, 0);  
        }  
    }  
}
</code></pre>

<p>你没看错，if else 里面代码是一样的，为了好理解特意没有合并到一起~~  </p>

<p>到此，我们从setPageTransformer使用，到修改ViewPager做到向下兼容，直至自己定义出个性的切换效果 都已经介绍完毕～～<br/><br/>
大家可以发挥自己的创造力，做出各种神奇的动画效果，ok，就到这里！  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869535.html">
                
                  <h1>Android-Android Studio 快捷键</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">常用快捷键</h2>

<h3 id="toc_1">自动补全</h3>

<ul>
<li>使用<code>Enter</code>会补全你选择的语句</li>
<li>使用<code>Tab</code>的话，会替换掉你之前在这里的内容（删除后面的语句直到遇到点号，逗号，分号）</li>
</ul>

<h3 id="toc_2">自动缩进对齐</h3>

<p><code>ctr + alt + I</code></p>

<h3 id="toc_3">返回编辑器窗口</h3>

<ul>
<li><code>Esc</code>: 返回编辑器</li>
<li><code>Shift + Esc</code>: 返回编辑器并关闭当前窗口</li>
</ul>

<h3 id="toc_4">快捷打开窗口</h3>

<ul>
<li>Mac: <code>Cmd + 数字</code></li>
<li>windows/Linux: <code>Alt + 数字</code></li>
</ul>

<h3 id="toc_5">任意窗口切换</h3>

<p><code>Ctrl + Tab</code>可以让你切换到任意窗口！<br/>
在这个切换窗口打开的时候，你可以直接按数字切换到对应的工具窗口，或者输入字母搜索右边的编辑器窗口，如果你需要关闭某个窗口，在上面按<code>BackSpace</code>即可。</p>

<h3 id="toc_6">隐藏所有窗口</h3>

<ul>
<li>Mac: <code>CMD + Shift + F12</code></li>
<li>windows/Linux: <code>Ctrl + shift + F12</code><br/>
如果需要恢复所有窗口，再按一次这个快捷键即可。</li>
</ul>

<h3 id="toc_7">参数提示</h3>

<p>这个功能估计很多人知道了，但是还是提一下。在自动补全以后，如果某个方法参数超级长，你不知道参数是什么怎么办？可以试试这个。</p>

<ul>
<li>Mac: <code>CMD + P</code></li>
<li>win/Linux: <code>Ctrl + P</code></li>
</ul>

<h3 id="toc_8">自动生成变量</h3>

<p>作为一门静态类型语言， <a href="http://lib.csdn.net/base/java">Java</a> 是有一定的类型推导能力的；那么你是否经常书写:</p>

<pre><code class="language-java">String testStr = &quot;testStr&quot;;
List&lt;String&gt; testStrings = new ArrayList&lt;String&gt;();
</code></pre>

<p>其实大可不必写那些恼火的类型声明的，一看就知道</p>

<pre><code class="language-text">testStr, testStrings
</code></pre>

<p>就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。</p>

<ul>
<li>Mac: <code>Cmd + Alt + V</code></li>
<li>Win/Linux: <code>Ctrl + Alt + V</code></li>
</ul>

<p>有的童鞋可能会问了：我使用<code>ArrayList, HashMap</code>的时候，习惯类型声明为<code>List,Map</code>等接口，这个自动生成的类型声明还是具体的实现啊，怎么办？这一点IDE已经帮你想到了，试试<code>shift + tab</code>,他会给你一个可以选择的类型列表～</p>

<h3 id="toc_9">自动提取参数</h3>

<p>有时候你正在写一个方法的时候发现。哎哟，这个变量最好是当作参数传递进来啊；要做成这么一件事，你必须把这个方法内部所有使用这个局部变量的地方替换，把所有调用这个函数的地方添加参数，繁琐至极！好了有了这个你可以随便玩了：</p>

<ul>
<li>Mac: <code>Cmd + Alt + P</code></li>
<li>Win/Linux: <code>Ctrl + Alt + P</code></li>
</ul>

<p>当然，如果你想保留原来的方法，只是搞一个参数不同的方法（重载）出来，可以在弹出的那个对话框里面打勾。</p>

<h3 id="toc_10">自动提取方法</h3>

<p>写代码的时候是否会发现不知不觉的这个方法已经太长了，适合分解然后提取出一个个子方法；或者是重构的时候看到一个一两千的函数，你是不是头都大了？一般情况下，我们都是把要提取的代码copy出来，然后写一个方法（还要什么该死的方法签名）然后把这段代码复制进来；其实这个过程是机械的，完全可以由IDE完成：</p>

<ul>
<li>Mac: <code>Cmd + Alt + M</code></li>
<li>Win/Linux: <code>Ctrl + Alt + M</code></li>
</ul>

<p>如果想改变方法的签名，在对话框里面选择你需要的就可以了～</p>

<blockquote>
<p>上面提到了三个快捷键其实是比较类似的，如何记忆呢？</p>

<ul>
<li>首先组合键都是<code>Cmd/Ctrl + Alt</code></li>
<li>然后提取变量Variable=V，参数Parameters=P，方法Method=M</li>
</ul>
</blockquote>

<h3 id="toc_11">内联变量/参数/方法</h3>

<p>好了学会了上面那几个快捷键，万一玩high了，比如提取了太多的方法，想“弄回去”，该怎么办呢？这个操作叫他<code>Inline..</code></p>

<ul>
<li>Mac: <code>Cmd + Alt + N</code></li>
<li>Win/Linux: <code>Ctrl + Alt + N</code></li>
</ul>

<p>上面那个图只是参考，其实不仅可以作用于变量，还可以是方法/参数，个人觉得方法inline比较有用。</p>

<h3 id="toc_12">万能重构键</h3>

<p>静态类型语言重构起来相对容易的，但是通常修改一个地方会牵扯到很多别的地方，我们只有一处一处找到这些编译错误然后手动修复。其实有好多工作是可以自动完成的，比如删除某个方法；先确认有没有人调用（Alt ＋ F7），没有的话把方法体删了，有的话去看看调用的地方再决定怎么办。<br/>
但是重构的操作实在是太多了！我们没有办法也没有必要一个个记住，知道这个快捷键即可，我叫他万能重构键:</p>

<ul>
<li>Mac : <code>Ctrl + T</code></li>
<li>Win/Linux: <code>Ctrl + Alt + Shift + T</code></li>
</ul>

<p>在Win/ <a href="http://lib.csdn.net/base/linux">Linux</a> 上可以考虑把这个快捷键改一下键，一下按四个键臣妾很难做到啊。。</p>

<h3 id="toc_13">重命名</h3>

<p><code>shift + F6</code></p>

<h3 id="toc_14">查找当前文件在项目中的位置</h3>

<p>快捷键: <code>Alt + F1</code></p>

<h3 id="toc_15">拓展选择</h3>

<p>这个功能应该很多人都知道；但还是说明一下，因为跟下面两个功能跟这个结合起来才有威力。这个功能太强大了，自己去按几遍就能想到很多使用场景了；我相信有了这个功能，你使用鼠标的机会会少很多。</p>

<ul>
<li>Mac: <code>Alt + up/down</code></li>
<li>Win/Linux: <code>ctrl + w / ctrl + shift + w</code></li>
</ul>

<h3 id="toc_16">Surround With..</h3>

<p>如果你想把一段代码使用<code>if</code>语句包起来；又或者使用<code>try</code>包围一段可能有运行时异常的代码，你会怎么干？<br/>
首先用光标定位到代码块开头，写上 <code>try {</code>然后，光标代码块末尾加<code>} catch (XXXRuntimeException e) {// todo}</code>？可以试试这个快捷键。</p>

<ul>
<li>Mac: <code>cmd + alt + t</code></li>
<li>Win/Linux: <code>ctrl + alt + t</code></li>
</ul>

<p>可以使用上面的拓展选择选择你需要的代码块，然后使用这个功能Surround With；如果你什么都不选择的话，那么默认选择的是光标所在行。</p>

<h3 id="toc_17">Unwrap/Remove</h3>

<p>这个功能跟上面提到的是一对，有了Surround With自然就有Unsurround With;使用情况没有上面那个那么多，但是好歹一对，一起介绍吧。</p>

<h3 id="toc_18">高亮某东西</h3>

<p>有时候看代码的时候，看到某个变量想知道哪里使用了它；你还在用肉眼查找吗？或者你杀鸡用牛刀<br/>
<code>Find Usgae</code>？其实你的需求就是把这个变量全部给我打个标签，我想直观的知道它在哪。</p>

<ul>
<li>Mac: <code>cmd + shift + F7</code></li>
<li>Win/Linux: <code>ctrl + shift + F7</code><br/>
这个键功能远不止这个！</li>
<li>如果你高亮<code>return</code>或者<code>throw</code>，那么会把这个方法所有的返回点高亮出来！</li>
<li>高亮某个类的<code>extends</code>或者<code>implements</code>会把这个类Override的方法高亮出来</li>
<li>高亮<code>import</code>会把使用的地方显示出来<br/>
如果不想要高亮了，按下Esc就行。 </li>
</ul>

<h3 id="toc_19">显示方法调用树</h3>

<p>在看源码的时候，你还是使用<code>alt + F7</code>和<code>ctrl + B</code>在各个类之间来回穿梭吗？其实好多时候你就是想知道这个调用结构是怎么样的而已；谁是怎么一步一步滴调用谁的；这个快捷键会给你一个调用树。有了这个大菊观，继续探讨就很容易了。<br/>
快捷键: <code>ctrl + alt + h</code></p>

<h3 id="toc_20">万能快捷键</h3>

<p>记得之前提到过一个万能重构键, 有关重构的一切操作都可通过它完成。那么Android Studio这么快捷键，这么多功能，臣妾怎么可能都记住！要是有万能钥匙就好了！That’s it!<br/>
使用这个快捷键，你想到什么功能，打开它搜索就可以了；打个比方，我想看看 <a href="http://lib.csdn.net/base/java">Java</a> 的<code>for each</code>循环和普通的<code>for</code>循环底层是不是同一个实现;那么我就需要看虚拟机字节码了；我记得有这个功能但是不知道快捷键是啥；OK，<code>Cmd + shift + A</code>，输入<code>bytecode</code>:</p>

<h3 id="toc_21">删除当前行</h3>

<ul>
<li>Mac: <code>ctrl + Y</code></li>
<li>Win/Linux: <code>Command + Y</code></li>
</ul>

<h3 id="toc_22">Find usage</h3>

<p><code>alt+F7</code></p>

<h3 id="toc_23">格式化代码</h3>

<ul>
<li>Mac: <code>alt+command+L</code></li>
<li>Win/Linux: <code>ctrl+alt+L</code></li>
</ul>

<h3 id="toc_24">优化import</h3>

<ul>
<li>Mac: <code>alt+command+O</code></li>
<li>Win/Linux: <code>ctrl+alt+O</code></li>
</ul>

<h3 id="toc_25">Declaration查看定义</h3>

<ul>
<li>Mac: <code>command+B</code></li>
<li>Win/Linux: <code>ctrl+B</code></li>
</ul>

<h3 id="toc_26">快递定位并高亮错误（deprecate，unused）</h3>

<ul>
<li>Mac: <code>(shift+)F2</code></li>
<li>Win/Linux: <code>F2</code></li>
</ul>

<h3 id="toc_27">Override Methods</h3>

<ul>
<li>Mac: <code>command+O</code></li>
<li>Win/Linux: <code>ctrl+O</code></li>
</ul>

<h3 id="toc_28">Implement Methods</h3>

<ul>
<li>Mac: <code>command+I</code></li>
<li>Win/Linux: <code>ctrl+I</code></li>
</ul>

<h3 id="toc_29">Super Method（Class）</h3>

<ul>
<li>Mac: <code>command+U</code></li>
<li>Win/Linux: <code>ctrl+U</code></li>
</ul>

<h3 id="toc_30">Previous/Next Method</h3>

<p><code>control+上下方向键</code></p>

<h3 id="toc_31">引入包，添加注释…</h3>

<p><code>alt+enter</code></p>

<h3 id="toc_32">Run</h3>

<p>shift+F10 </p>

<h3 id="toc_33">Debug </h3>

<p>shift+F9</p>

<h3 id="toc_34">Make Project</h3>

<ul>
<li>Mac: <code>command+F9</code></li>
<li>Win/Linux: <code>ctrl+F9</code></li>
</ul>

<h3 id="toc_35">Make Module</h3>

<ul>
<li>Mac: <code>shift+command+F9</code></li>
<li>Win/Linux: <code>shift+ctrl+F9</code></li>
</ul>

<h3 id="toc_36">关闭当前的执行的task</h3>

<ul>
<li>Mac: <code>command+F2</code></li>
<li>Win/Linux: <code>ctrl+F2</code></li>
</ul>

<h3 id="toc_37">添加/取消断点</h3>

<ul>
<li>Mac: <code>command+F8</code></li>
<li>Win/Linux: <code>ctrl+F8</code></li>
</ul>

<h3 id="toc_38">查看所有断点 Debug</h3>

<ul>
<li>Mac: <code>shift+command+F8</code></li>
<li>Win/Linux: <code>shift+ctrl+F8</code></li>
</ul>

<h3 id="toc_39">Step Into</h3>

<p> <code>F7</code></p>

<h3 id="toc_40">Step Over</h3>

<p><code>F8</code></p>

<h3 id="toc_41">Step out</h3>

<p><code>shift+F8</code> </p>

<h3 id="toc_42">resume </h3>

<p><code>F9</code></p>

<h3 id="toc_43">Run to Cursor</h3>

<p><code>alt+F9</code></p>

<h3 id="toc_44">Find</h3>

<ul>
<li>Mac: <code>command+F</code></li>
<li>Win/Linux: <code>command+F</code></li>
</ul>

<h3 id="toc_45">Replace</h3>

<ul>
<li>Mac: <code>command+R</code></li>
<li>Win/Linux: <code>command+R</code></li>
</ul>

<h3 id="toc_46">Find in Path</h3>

<p><code>control+shift+F</code></p>

<h3 id="toc_47">Replace in Path</h3>

<p><code>control+shiftÏ+R</code></p>

<h3 id="toc_48">Back/Forward操作</h3>

<ul>
<li>Mac: <code>alt+command+左右方向键</code></li>
<li>Win/Linux: <code>alt+ctrl+左右方向键</code></li>
</ul>

<h3 id="toc_49">Recent File</h3>

<ul>
<li>Mac: <code>command+E</code></li>
<li>Win/Linux: <code>ctrl+E</code></li>
</ul>

<h3 id="toc_50">Recently Change Files</h3>

<ul>
<li>Mac: <code>shift+command+E</code></li>
<li>Win/Linux: <code>shift+ctrl+E</code></li>
</ul>

<h3 id="toc_51">Search Method或者Class</h3>

<p>(Search Everywhere：<code>command+N</code>,<code>shift+command+N</code>,<code>shift+alt+command+N</code>)<br/>
<code>shift+shift</code></p>

<h3 id="toc_52">Search Class</h3>

<ul>
<li>Mac: <code>command+N</code></li>
<li>Win/Linux: <code>ctrl+N</code></li>
</ul>

<h3 id="toc_53">Search File</h3>

<ul>
<li>Mac: <code>shift+command+N</code></li>
<li>Win/Linux: <code>shift+ctrl+N</code></li>
</ul>

<h3 id="toc_54">Search Symbol</h3>

<ul>
<li>Mac: <code>shift+alt+command+N</code></li>
<li>Win/Linux: <code>shift+alt+ctrl+N</code></li>
</ul>

<h3 id="toc_55">Move Line Up/Move Line Down</h3>

<ul>
<li>Mac: <code>shift+command+上下方向键</code></li>
<li>Win/Linux: <code>shift+ctrl+上下方向键</code></li>
</ul>

<h2 id="toc_56">常用技巧</h2>

<h3 id="toc_57">书签（Bookmarks）</h3>

<ul>
<li><strong>描述</strong>：这是一个很有用的功能，让你可以在某处做个标记（书签），方便后面再跳转到此处。</li>
<li><strong>调用</strong>：Menu → Navigate → Bookmarks</li>
<li><strong>快捷键</strong>：
<ul>
<li>添加/移除书签：
<ul>
<li>OS X: <code>F3</code></li>
<li>Windows/Linux: <code>F11</code></li>
</ul></li>
<li>添加/移除书签(带标记)：
<ul>
<li>OS X: <code>Alt + F3</code></li>
<li>Windows/Linux: <code>Ctrl + F11</code></li>
</ul></li>
<li>显示全部书签显示所有的书签列表，并且是可以搜索的。
<ul>
<li>OS X: <code>Cmd + F3</code></li>
<li>Windows/Linux: <code>Shift + F11</code></li>
</ul></li>
<li>上一个/下一个书签：无，可以在设置中设置快捷键。</li>
</ul></li>
<li><strong>更多</strong>：当你为某个书签指定了标记，你可以使用快捷键 <code>Ctrl + 标记</code> 来快速跳转到标记处，比如输入<code>Ctrl + 1</code>，跳到标记为1的书签处</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980563110691.gif" alt="20171104150980563110691.gif"/></p>

<h3 id="toc_58">折叠/展开代码块（Collapse Expand Code Block） </h3>

<ul>
<li><strong>描述</strong>：该操作提供一种方法，让你隐藏你不关心的部分代码，以一种较为简洁的格式显示关键代码。一个有意思的用法是隐藏匿名内部类的代码，让其看起来像一个Lambda表达式。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + “+”/”-“</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + “+”/”-“</code></li>
</ul></li>
<li><strong>更多</strong>：可以在Settig → Editor → General → Code Folding 中设置折叠规则。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980566925324.gif" alt="20171104150980566925324.gif"/></p>

<h3 id="toc_59">与分支比对（Compare With Branch (Git)）</h3>

<ul>
<li><strong>描述</strong>：假如你的项目是使用git来管理的，你可以将当前文件或者文件夹与其他的分支进行比对。比较有用的是可以让你了解到你与主分支有多少差别。</li>
<li><strong>调用</strong>：Menu → VCS → Git → Compare With Branch</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980569269725.gif" alt="20171104150980569269725.gif"/></p>

<h3 id="toc_60">与剪切板比对（Compare With Clipboard）</h3>

<ul>
<li><strong>描述</strong>：将当前选中的部分与剪切板上的内容进行比对。</li>
<li><strong>调用</strong>：右键选中的部分，在右键菜单中选择“Compare With Clipboard”。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980574818952.gif" alt="20171104150980574818952.gif"/></p>

<h3 id="toc_61">上下文信息（Context Info）</h3>

<ul>
<li><strong>描述</strong>：当前作用域定义超过滚动区域，执行该操作将显示所在的上下文信息，通常它显示的是类名或者内部类类名或者当前所在的方法名。该操作在xml文件中同样适用。</li>
<li><strong>调用</strong>：Menu → View → Context Info</li>
<li><strong>快捷键</strong>：Alt + Q (Windows/Linux)</li>
<li><strong>更多</strong>：个人认为，这个功能更好的用法是快速查看当前类继承的父类或者实现的接口。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980576930267.gif" alt="20171104150980576930267.gif"/></p>

<h3 id="toc_62">查找操作（Find Action）</h3>

<ul>
<li><strong>描述</strong>：输入某个操作的名称，快速查找，对于没有快捷键的部分操作这是一个很有用的技巧。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd +Shift + A</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + A</code></li>
</ul></li>
<li><strong>更多</strong>：当某个操作是有快捷键的，会显示在旁边。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980579558685.gif" alt="20171104150980579558685.gif"/></p>

<h3 id="toc_63">查找补全（Find Complection）</h3>

<ul>
<li><strong>描述</strong>：当你在一个文件中进行查找时，使用自动补全快捷键可以给出在当前文件中出现的建议单词；</li>
<li><strong>快捷键</strong>：输入一些字符，然后使用自动补全
<ul>
<li>OS X: <code>Cmd + F</code></li>
<li>Windows/Linux: <code>Ctrl + F</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980582766335.gif" alt="20171104150980582766335.gif"/></p>

<h3 id="toc_64">隐藏所有面板（Hide All Panels）</h3>

<ul>
<li><strong>描述</strong>：切换编辑器铺满整个程序界面，隐藏其他的面板。再次执行该操作，将会回到隐藏前的状态。</li>
<li><strong>调用</strong>：Menu → Window → Active Tool Window → Hide All Windows；</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd +Shift + F12</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + F12</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980590796229.gif" alt="20171104150980590796229.gif"/></p>

<h3 id="toc_65">高亮一切（Hightlight All the Things）</h3>

<ul>
<li><strong>描述</strong>：该操作将会高亮某个字符在当前文件中所有出现的地方。这不仅仅是简单的匹配，实际上它会分析当前的作用域，只高亮相关的部分。</li>
<li><strong>调用</strong>：Menu → Edit → Find → Highlight Usages in File；</li>
<li><strong>定位到上一处/下一处</strong>：Menu → Edit → Find → Find Next/Previous；</li>
<li><strong>快捷键</strong>：相关快捷键请在菜单中查看；</li>
<li><strong>更多</strong>：
<ul>
<li>如果高亮一个方法的return或throw语句，将会高亮这个方法的所有出口/结束点；</li>
<li>如果高亮某个类定义处的extend或implements语句，将会高亮继承的或实现的方法；</li>
<li>高亮一个import语句也会高亮使用到的地方；</li>
<li>按下Esc可以退出高亮模式；</li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980592566371.gif" alt="20171104150980592566371.gif"/></p>

<h3 id="toc_66">回到上一个工具窗口（Jump to Last Tool Window）</h3>

<ul>
<li><strong>描述</strong>：有时候你会从某个工具窗口跳到编辑器里面，然后又需要重新回到刚才操作的那个工具窗，比如你查找使用情况的时，使用该操作可以在不使用鼠标的情况下跳转到之前的工具窗口。</li>
<li><strong>快捷键</strong>：F12</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980594942504.gif" alt="20171104150980594942504.gif"/></p>

<h3 id="toc_67">上一个编辑位置（Last Edit Location）</h3>

<ul>
<li><strong>描述</strong>：该操作将使得你导航到上一处你改动过的地方，这与点击工具栏上的返回箭头回到上一个定位位置是不一样的，该操作将会返回到上一个编辑的位置。</li>
<li><strong>快捷键</strong>： 
<ul>
<li>OS X: <code>Cmd + Shift + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Backspace﻿</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980596825126.gif" alt="20171104150980596825126.gif"/></p>

<h3 id="toc_68">在方法和内部类之间跳转（Move Between Methods and Inner Classes）</h3>

<ul>
<li><strong>描述</strong>：该操作让光标在当前文件的方法或内部类的名字间跳转。</li>
<li><strong>调用</strong>：Navigate → Next Method/Previous Method;</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + Up/Down﻿</code></li>
<li>Windows/Linux: <code>Alt + Up/Down</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980599666524.gif" alt="20171104150980599666524.gif"/></p>

<h3 id="toc_69">定位到嵌套文件（Navigate to Nested File）</h3>

<ul>
<li><strong>描述</strong>：有时你有一堆存放在不同目录下的同名文件，例如不同模块下的AndroidManifest.xml文件，当你想定位到其中的一个文件，你会得到一堆搜索结果，你还得辨认哪个才是你需要的。通过在检索框中输入部分路径的前缀，并添加斜杠号，你就可以在第一次尝试的时候就找到正确的那个。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X：<code>Shift + Cmd + O</code></li>
<li>Windows/Linux: <code>Shift + Ctrl + N﻿</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980603928163.gif" alt="20171104150980603928163.gif"/></p>

<h3 id="toc_70">定位到父类（Navigate to parent）</h3>

<ul>
<li><strong>描述</strong>：如果光标是在一个继承父类重写的方法里，这个操作将定位到父类实现的地方。如果光标是在类名上，则定位到父类类名。</li>
<li>Menu → Navigate → Super Class/Method</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + U</code></li>
<li>Windows/Linux: <code>Ctrl + U</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110415098060573045.gif" alt="2017110415098060573045.gif"/></p>

<h3 id="toc_71">根据编号打开面板（Open a Panel by Its Number）</h3>

<ul>
<li><strong>描述</strong>：你可能已经注意到某些面板的名称左边有一个数字，这里有个快捷操作可以打开它们。如果你没看到面板的名称，请点击IDE的左下角的切换按钮。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + 数字</code></li>
<li>Windows/Linux: <code>Alt + 数字</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980607694073.gif" alt="20171104150980607694073.gif"/></p>

<h3 id="toc_72">在外部打开文件（Open File Externally）</h3>

<ul>
<li><strong>描述</strong>：通过这个快捷键，简单地点击 Tab，就可以打开当前文件所在的位置或者该文件的任意上层路径。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + 单击Tab</code></li>
<li>Windows/Linux: <code>Ctrl + 点击Tab</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980611657644.gif" alt="20171104150980611657644.gif"/></p>

<h3 id="toc_73">参数信息（Parameter Info）</h3>

<ul>
<li><strong>描述</strong>：这个操作将显示和你在方法声明处写一样的参数列表，当你想看某个存在的方法的参数，这是一个很有用的操作。光标下的参数显示为黄色，如果没有参数显示黄色，意味着你的方法调用是无效的，很可能是某个参数分配不对。（例如一个浮点数赋值给了整型参数）。如果你正在写一个方法调用，突然离开编辑的地方，再返回的时候，输入一个逗号，就可以重新触发参数信息。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + P</code></li>
<li>Windows/Linux: <code>Ctrl + P</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980616259965.gif" alt="20171104150980616259965.gif"/></p>

<h3 id="toc_74">快速查看定义（Quick Definition Lookup）</h3>

<ul>
<li><strong>描述</strong>：你曾经是否想查看一个方法或者类的具体实现，但是不想离开当前界面？ 该操作可以帮你搞定。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Alt + Space / Cmd + Y</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + I</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980618467849.gif" alt="20171104150980618467849.gif"/></p>

<h3 id="toc_75">最近修改的文件（Recently Changed Files）</h3>

<ul>
<li><strong>描述</strong>：该操作类似于“最近访问（Recents）”弹窗，会显示最近本地修改过的文件列表，根据修改时间排列。可以输入字符来过滤列表结果。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + E</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + E</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980621570214.gif" alt="20171104150980621570214.gif"/></p>

<h3 id="toc_76">最近访问（Recents）</h3>

<ul>
<li><strong>描述</strong>：该操作可以得到一个最近访问文件的可搜索的列表。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + E</code></li>
<li>Windows/Linux: <code>Ctrl + E</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980623538307.gif" alt="20171104150980623538307.gif"/></p>

<h3 id="toc_77">相关文件（Related File）</h3>

<ul>
<li><strong>描述</strong>：该操作有助于在布局文件和Activity/Fragment之间轻松跳转。这也是一个快捷操作，在类名/布局顶端的左侧。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + Cmd + Up</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + Home</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980626239846.gif" alt="20171104150980626239846.gif"/></p>

<h3 id="toc_78">返回到编辑器（Return to the Editor）</h3>

<ul>
<li><strong>描述</strong>：一大堆快捷键操作会把你从编辑器带走（type hierarchy, find usages, 等等）。如果你想返回到编辑器，你有两个选项：
<ul>
<li><code>Esc</code>：该操作仅仅把光标移回编辑器。</li>
<li><code>Shift + Esc</code>：该操作会关闭当前面板，然后把光标移回到编辑器。</li>
</ul></li>
<li><strong>快捷键</strong>：
<ul>
<li>返回但保留打开的面板：<code>Esc</code></li>
<li>关闭面板并返回：<code>Shift + Esc</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980627917706.gif" alt="20171104150980627917706.gif"/></p>

<h3 id="toc_79">Select In</h3>

<ul>
<li><strong>描述</strong>：拿着当前文件然后问你在哪里选中该文件。恕我直言，最有用的就是在项目结构或者资源管理器中打开该文件。每一个操作都有数字或者字母作为前缀，可以通过这个前缀来快速跳转。通常，我会 Alt + F1 然后 回车(Enter) 来打开项目视图，然后 再用 Alt + F1 在OS X的Finder里找到文件。你可以在文件中或者直接在项目视图里使用该操作。</li>
<li><strong>快捷键</strong>：<code>Alt + F1</code></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980629875328.gif" alt="20171104150980629875328.gif"/></p>

<h3 id="toc_80">扩大/缩小选择（Extend/Shrink Selection）</h3>

<ul>
<li><strong>描述</strong>：该操作会在上下文逐渐扩大/缩小当前选择范围。例如，它会先选中当前变量，再选中当前语句，然后选中整个方法，缩小选择则相反。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Alt + 上/下</code></li>
<li>Windows、Linux: <code>Ctrl+W / Ctrl + Shift + W﻿</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980631814449.gif" alt="20171104150980631814449.gif"/></p>

<h3 id="toc_81">Sublime Text式的多处选择（Sublime Text Multi Selection）</h3>

<ul>
<li><strong>描述</strong>：这个功能超级赞！该操作会识别当前选中字符串，选择下一个同样的字符串，并且添加一个光标。这意味着你可以在同一个文件里拥有多个光标，你可以同时在所有光标处输入任何东西。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + G</code></li>
<li>Windows、Linux: <code>Alt + Ｊ</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980633994665.gif" alt="20171104150980633994665.gif"/></p>

<h3 id="toc_82">文件结构弹窗（The File Structure Popup）</h3>

<ul>
<li><strong>描述</strong>：该操作可以展示当前类的大纲，并且可以快速跳转。你还可以通过键盘输入来过滤结果。这是一种很高效的方法来跳转到指定方法。</li>
<li><strong>更多</strong>：
<ul>
<li>你在输入字符的时候可以用驼峰风格来过滤选项。比如输入”oCr”会找到”onCreate”</li>
<li>你可以通过勾选多选框来决定是否显示匿名类。这在某些情况下很有用，比如你想直接跳转到一个OnClickListener的onClick方法。</li>
</ul></li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + F12</code></li>
<li>Windows/Linux: <code>Ctrl + F12</code></li>
</ul></li>
<li><strong>调用</strong>：Menu → Navigate → File Structure</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980637886260.gif" alt="20171104150980637886260.gif"/></p>

<h3 id="toc_83">切换器（The Switcher）</h3>

<ul>
<li><strong>描述</strong>：该快捷键基本上就是IDE的alt+tab/cmd+tab命令。你可以用它在导航tab或者面板切换。一旦打开这个窗口，只要一直按着ctrl键，你可以通过对应的数字或者字母快捷键快速选择。你也可以通过backspace键来关闭一个已选中的tab或者面板。</li>
<li><strong>快捷键</strong>：<code>Ctrl + Tab</code></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980639938168.gif" alt="20171104150980639938168.gif"/></p>

<h3 id="toc_84">版本控制操作弹窗（VCS Operations Popup）</h3>

<ul>
<li><strong>描述</strong>：该操作会给你显示最常用的版本控制操作。如果你的项目没有用git等版本控制软件进行管理，它至少会给你提供一个由IDE维护的本地历史记录。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + V</code></li>
<li>Windows/Linux: <code>Alt + 引号</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980642462619.gif" alt="20171104150980642462619.gif"/></p>

<h2 id="toc_85">编码技巧</h2>

<h3 id="toc_86">列选择/块选择（Column Selection）</h3>

<ul>
<li><strong>描述</strong>：正常选择时，当你向下选择时，会直接将当前行到行尾都选中，而块选择模式下，则是根据鼠标选中的矩形区域来选择。</li>
<li><strong>调用</strong>：按住Alt，然后拖动鼠标选择。</li>
<li><strong>开启/关闭块选择</strong>：Menu → Edit → Column Selection Mode</li>
<li><strong>快捷键</strong>：切换块选择模式：
<ul>
<li>OS X：<code>Cmd + Shift + 8</code></li>
<li>Windows/Linux: <code>Shift + Alt + Insert﻿</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110415098064433401.gif" alt="2017110415098064433401.gif"/></p>

<h3 id="toc_87">语句补全（Complete Statement）</h3>

<ul>
<li><strong>描述</strong>：这个方法将会生成缺失的代码来补全语句，常用的使用场景如下：
<ul>
<li>在行末添加一个分号，即使光标不在行末；</li>
<li>为if、while、for 语句生成圆括号和大括号；</li>
<li>方法声明后，添加大括号；</li>
</ul></li>
<li><strong>调用</strong>：Menu → Edit → Compelete Current Statement</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + Enter</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Enter</code></li>
</ul></li>
<li><strong>更多</strong>：如果一个语句已经补全，当你执行该操作时，则会直接跳到下一行，即使光标不在当前行的行末。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980646813298.gif" alt="20171104150980646813298.gif"/></p>

<h3 id="toc_88">删除行（Delete Line）</h3>

<ul>
<li><strong>描述</strong>：如果没选中，则删除光标所在行，如果选中，则会删除选中所在的所有行。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Y</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980648262822.gif" alt="20171104150980648262822.gif"/></p>

<h3 id="toc_89">行复制（Duplicate Line）</h3>

<ul>
<li><strong>描述</strong>：复制当前行，并粘贴到下一行，这个操作不会影响剪贴板的内容。这个命令配合移动行快捷键非常有用。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + D</code></li>
<li>Windows/Linux: <code>Ctrl + D</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980649696731.gif" alt="20171104150980649696731.gif"/></p>

<h3 id="toc_90">编写正则表达式（Edit Regex）</h3>

<ul>
<li><strong>描述</strong>：使用Java编写正则表达式是一件很困难的事，主要原因是：
<ul>
<li>你必须得避开反斜杠；</li>
<li>说实话，正则很难；</li>
<li>看第二条。</li>
</ul></li>
</ul>

<p>IDE能帮我们干点啥呢？当然是一个舒服的界面来编写和测试正则啦~</p>

<ul>
<li><strong>快捷键</strong>：Alt + Enter → check regexp</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980651186804.gif" alt="20171104150980651186804.gif"/></p>

<h3 id="toc_91">使用Enter和Tab进行代码补全的差别（Enter vs Tab for Code Completion）</h3>

<ul>
<li><strong>描述</strong>：代码补全时，可以使用Enter或Tab来进行补全操作，但是两者是有差别的。</li>
<li><strong>使用Enter时</strong>：从光标处插入补全的代码，对原来的代码不做任何操作。</li>
<li><strong>使用Tab时</strong>：从光标处插入补全的代码，并删除后面的代码，直到遇到点号、圆括号、分号或空格为止。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980653180946.gif" alt="20171104150980653180946.gif"/></p>

<h3 id="toc_92">提取方法（Extract Method）</h3>

<ul>
<li><strong>描述</strong>：提取一段代码块，生成一个新的方法。当你发现某个方法里面过于复杂，需要将某一段代码提取成单独的方法时，该技巧是很有用的。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Method</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + M</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + M</code></li>
</ul></li>
<li><strong>更多</strong>：在提取代码的对话框，你可以更改方法的修饰符和参数的变量名。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980654825229.gif" alt="20171104150980654825229.gif"/></p>

<h3 id="toc_93">提取参数（Extract Parameter）</h3>

<ul>
<li><strong>描述</strong>：这是一个提取参数的快捷操作。当你觉得可以通过提取参数来优化某个方法的时候，这个技巧将很有用。该操作会将当前值作为一个方法的参数，将旧的值放到方法调用的地方，作为传进来的参数。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Parameter</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + P</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + P</code></li>
</ul></li>
<li><strong>更多</strong>：通过勾选“delegate”，可以保持旧的方法，重载生成一个新方法。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980656810471.gif" alt="20171104150980656810471.gif"/></p>

<h3 id="toc_94">提取变量（Extract Variable）</h3>

<ul>
<li><strong>描述</strong>：这是一个提取变量的快捷操作。当你在没有写变量声明的直接写下值的时候，这是一个很方便生成变量声明的操作，同时还会给出一个建议的变量命名。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Variable</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + V</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + V</code></li>
</ul></li>
<li><strong>更多</strong>：当你需要改变变量声明的类型，例如使用 List 替代 ArrayList，可以按下Shift + Tab，就会显示所有可用的变量类型。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110415098065961111.gif" alt="2017110415098065961111.gif"/></p>

<h3 id="toc_95">内置（Inline）</h3>

<ul>
<li><strong>描述</strong>：当你开始对提取操作有点兴奋的时候，突然觉得东西太多了，怎么办呢？这是一个和提取相反的操作。该操作对方法、字段、参数和变量均有效。</li>
<li><strong>调用</strong>：Menu → Refactor → Inline</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + N</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + N</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980663164666.gif" alt="20171104150980663164666.gif"/></p>

<h3 id="toc_96">合并行和文本（Join Lines and Literals）</h3>

<ul>
<li><strong>描述</strong>：这个操作比起在行末使劲按删除键爽多了！该操作遵守格式化规则，同时：
<ul>
<li>合并两行注释，同时移除多余的//；</li>
<li>合并多行字符串，移除+和双引号；</li>
<li>合并字段的声明和初始化赋值；</li>
</ul></li>
<li><strong>快捷键</strong>：<code>Ctrl + Shift + J</code></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980665059689.gif" alt="20171104150980665059689.gif"/></p>

<h3 id="toc_97">动态模板（Live Templates）</h3>

<ul>
<li><strong>描述</strong>：动态模板是一种快速插入代码片段的方法，使用动态模板比较有意思的是你可以使用合适的默认值将模板参数化，当你插入代码片段时，这可以指导你完成参数。</li>
<li><strong>更多</strong>：如果你知道模板的缩写，就可以不必使用快捷键，只需要键入缩写并使用Tab键补全即可。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + J</code></li>
<li>Windows/Linux: <code>Ctrl + J</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980666912326.gif" alt="20171104150980666912326.gif"/></p>

<h3 id="toc_98">上下移动行（Move Lines Up Down）</h3>

<ul>
<li><strong>描述</strong>：不需要复制粘贴就可以上下移动行了。</li>
<li><strong>快捷键</strong>：<code>Alt + Shift + Up/Down﻿</code></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980669255942.gif" alt="20171104150980669255942.gif"/></p>

<h3 id="toc_99">移动方法（Move Methods）</h3>

<ul>
<li><strong>描述</strong>：这个操作和移动行操作很类似，不过该操作是应用于整个方法的，在不需要复制、粘贴的情况下，就可以将整个方法块移动到另一个方法的前面或后面。该操作的实际叫做“移动语句”，这意味着你可以移动任何类型的语句，你可以方便地调整字段或内部类的顺序。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + Up/Down</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Up/Down</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980671139565.gif" alt="20171104150980671139565.gif"/></p>

<h3 id="toc_100">取反补全（Negation Completion）</h3>

<ul>
<li><strong>描述</strong>：有时你自动补全一个布尔值，然后回到该值的前面添加一个感叹号来完成取反操作，现在通过使用输入!代替enter完成补全操作，就可以跳过这些繁琐的操作了。</li>
<li><strong>快捷键</strong>：代码补全的时候，按下!即可（有时需要上下键选中候选项）；</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980672883680.gif" alt="20171104150980672883680.gif"/></p>

<h3 id="toc_101">后缀补全（Postfix Completion）</h3>

<ul>
<li><strong>描述</strong>：你可以认为该操作是一种代码补全，它会在点号之前生成代码，而不是在点号之后。实际上你调用这个操作和正常的代码补全操作一样：在一个表达式之后输入点号。</li>
</ul>

<p>例如对一个列表进行遍历，你可以输入myList.for，然后按下Tab键，就会自动生成for循环代码。</p>

<ul>
<li><p><strong>调用</strong>： 你可以在某个表达式后面输入点号，出现一个候选列表，在常规的代码补全提示就可以看到一系列后缀补全关键字，同样的，你也可以在Editor → Postfix Completion中看到一系列后缀补全关键字。</p></li>
<li><p>常用的有后缀补全关键字有：</p>
<ul>
<li>.for (补全foreach语句)</li>
<li>.format (使用String.format()包裹一个字符串)</li>
<li>.cast (使用类型转化包裹一个表达式)</li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980676555014.gif" alt="20171104150980676555014.gif"/></p>

<h3 id="toc_102">重构（Refactor This）</h3>

<ul>
<li><strong>描述</strong>：该操作可以显示所有对当前选中项可行的重构方法。这个列表可以用数字序号快速选择。</li>
<li><strong>快捷键</strong>：Ctrl + T(OS X)、Ctrl + Alt + Shift + T(Windows/Linux)</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980678781403.gif" alt="20171104150980678781403.gif"/></p>

<h3 id="toc_103">重命名（Rename）</h3>

<ul>
<li><strong>描述</strong>：你可以通过该操作重命名变量、字段、方法、类、包。当然了，该操作会确保重命名对上下文有意义，不会无脑替换掉所有文件中的名字；</li>
<li><strong>快捷键</strong>：<code>Shift + F6</code></li>
<li><strong>更多</strong>：如果你忘记了这个快捷键，你可以使用快速修复（Quick Fix）的快捷键，它通常包含重命名选项。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980681031115.gif" alt="20171104150980681031115.gif"/></p>

<h3 id="toc_104">分号/点 补全（Semicolon Dot Completion）</h3>

<ul>
<li><strong>描述</strong>：代码补全这个功能太棒啦！我们大概都对以下这种情况很熟悉：开始输入点什么东西，接着从IDE得到一些建议的选项，然后通过Enter或者Tab来选择我们想要的补全代码。其实还有另外一种方法来选择补全的代码：我们可以输入一个点(.)或者一个分号(;)。这样就会完成补全，添加所选字符。这在结束一条语句补全或者快速链式调用方法的时候特别有用。</li>
<li><strong>注意点</strong>：如果你要代码补全的方法需要参数，这些参数会被略过。</li>
<li><strong>快捷键</strong>：<code>Autocomplete + “.” 或者 “;”</code></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980682566602.gif" alt="20171104150980682566602.gif"/></p>

<h3 id="toc_105">包裹代码（Surround With）</h3>

<ul>
<li><p><strong>描述</strong>： 该操作可以用特定代码结构包裹住选中的代码块，通常是if语句，循环，try/catch语句或者runnable语句。 如果你没有选中任何东西，该操作会包裹当前一整行。</p></li>
<li><p><strong>快捷键</strong>：</p>
<ul>
<li>OS X: <code>Cmd + Alt + T</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + T</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980684453567.gif" alt="20171104150980684453567.gif"/></p>

<h3 id="toc_106">移除包裹代码（Unwrap Remove）</h3>

<ul>
<li><strong>描述</strong>：该操作会移除周围的代码，它可能是一条if语句，一个while循环，一个try/catch语句甚至是一个runnable语句。该操作恰恰和包裹代码（Surround With）相反。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Delete</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980686388604.gif" alt="20171104150980686388604.gif"/></p>

<h3 id="toc_107">手动唤出自动补全（Class Name Completion）</h3>

<ul>
<li><strong>描述</strong>：一般使用 Android Studio 的时候，自动提示会在你想要提示的时候自动出现，比如输入 Log. ，就出现 Log.d()、Log.e、Log.i() 等提示。不过如果在自动提示的时候手一抖选错的话，比如想选 Log.d() 结果选了 Log.e() ，你可能会把 .e() 都删掉，然后再输入一个 . ， 然后弹出自动补全提示。其实这时候只需要删除 e() 然后手动唤出自动补全即可。</li>
<li><strong>快捷键</strong>： 
<ul>
<li>OS X/Windows/Linux: <code>Ctrl + Alt + Space</code> (可能存在快捷键冲突无法唤出，修改下快捷键即可)</li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980688325290.gif" alt="20171104150980688325290.gif"/></p>

<h2 id="toc_108">调试技巧</h2>

<h3 id="toc_109">分析传入数据流（Analyze data flow to here）</h3>

<ul>
<li><strong>描述</strong>：这个操作将会根据当前选中的变量、参数或者字段，分析出其传递到此处的路径。 当你进入某段陌生的代码，试图明白某个参数是怎么传递到此处的时候，这是一个非常有用的操作。</li>
<li><strong>调用</strong>：Menu → Analyze → Analyze Data Flow to Here</li>
<li><strong>快捷键</strong>：无，可以在设置中指定。</li>
<li><strong>相反的操作</strong>：分析传出数据流（Analyze data flow from here），这个将会分析当前选中的变量往下传递的路径，直到结束。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110415098069615710.gif" alt="2017110415098069615710.gif"/></p>

<h3 id="toc_110">堆栈追踪分析（Analyze Stacktrace）</h3>

<ul>
<li><strong>描述</strong>： 这个操作读取一份堆栈追踪信息，并且使它像logcat中那样可以点击。当你从bug报告中或者终端复制了一份堆栈追踪，使用该操作可以很方便地调试。</li>
<li><strong>调用</strong>：Menu → Analyze → Analyze Stacktrace</li>
<li><strong>快捷键</strong>：无，可以在设置中指定。</li>
<li><strong>更多</strong>：通过使用“ProGuard Unscramble Plugin”插件，也可以分析混淆过的堆栈追踪。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110415098070105942.gif" alt="2017110415098070105942.gif"/></p>

<h3 id="toc_111">关联调试程序（Attach Debugger）</h3>

<ul>
<li><strong>描述</strong>：随时启动调试程序，即使你没有以调试模式启动你的应用。这是一个很方便的操作，因为你不必为了调试程序而以调试模式重新部署你的应用。当别人正在测试应用，突然遇到一个bug而将设备交给你时，你也可以很快地进入调试模式。</li>
<li><strong>调用</strong>：点击工具栏图标或者Menu → Build → Attach to Android Process</li>
<li><strong>快捷键</strong>：无，可以在设置中指定，或者点击工具栏对应的图标。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980702475158.gif" alt="20171104150980702475158.gif"/></p>

<h3 id="toc_112">条件断点（Conditional Breakpoints）</h3>

<ul>
<li><strong>描述</strong>：简单说，就是当设定的条件满足时，才会触发断点。你可以基于当前范围输入一个java布尔表达式，并且条件输入框内是支持代码补全的。</li>
<li><strong>调用</strong>：右键需要填写表达式的断点，然后输入布尔表达式。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980704751679.gif" alt="20171104150980704751679.gif"/></p>

<h3 id="toc_113">禁用断点（Disable Breakpoints）</h3>

<ul>
<li>这个操作将使得断点。当你有一个设置过复杂条件的断点或者是日志断点，当前不需要，但是下次又不用重新创建，该操作是很方便的。</li>
<li><strong>调用</strong>：按住Alt，然后单击断点即可。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980707081458.gif" alt="20171104150980707081458.gif"/></p>

<h3 id="toc_114">计算表达式（Evaluate Expression）</h3>

<ul>
<li><strong>描述</strong>：这个操作可以用来查看变量的内容并且计算几乎任何有效的java表达式。需要注意的是，如果你修改了变量的状态，这个状态在你恢复代码执行后依然会保留。</li>
<li><strong>快捷键</strong>：处在断点状态时，光标放在变量处，按Alt + F8，即可显示计算表达式对话框。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980709720976.gif" alt="20171104150980709720976.gif"/></p>

<h3 id="toc_115">审查变量（Inspect Variable）</h3>

<ul>
<li><strong>描述</strong>：该操作可以在不打开计算表达式对话框就能审查表达式的值。</li>
<li><strong>快捷键</strong>：调试状态下，按住Alt键，然后单击表达式即可。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110415098071175665.gif" alt="2017110415098071175665.gif"/></p>

<h3 id="toc_116">日志断点（Logging Breakpoints）</h3>

<ul>
<li><strong>描述</strong>：这是一种打印日志而不是暂停的断点，当你想打印一些日志信息但是不想添加log代码后重新部署项目，这是一个非常有用的操作。</li>
<li><strong>调用</strong>：在断点上右键，取消Suspend的勾选，然后勾选上Log evaluated Expression，并在输入框中输入你要打印的日志信息。</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980717148789.gif" alt="20171104150980717148789.gif"/></p>

<h3 id="toc_117">标记对象（Mark Object）</h3>

<ul>
<li><strong>描述</strong>：当你在调试的时候，这个操作可以让你给某个特殊的对象添加一个标签，方便你后面很快地辨认。在调试时，当你从一堆相似的对象中查看某个对象是否和之前是一样的，这就是一个非常有用的操作。</li>
<li><strong>调用</strong>：右键你需要标记的对象，选中Mark Object，输入标签；</li>
<li><strong>快捷键</strong>：选中对象时
<ul>
<li>OS X: <code>F3</code></li>
<li>Windows/Linux: <code>F11</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980728765306.gif" alt="20171104150980728765306.gif"/></p>

<h3 id="toc_118">显示当前运行点（Show Execution Point）</h3>

<ul>
<li><strong>描述</strong>：该操作会立刻把你的光标移回到当前debug处。</li>
</ul>

<p>通常的情况是：</p>

<ol>
<li>你在某处触发了断点</li>
<li>然后在文件中随意浏览</li>
<li><p>直接调用这个快捷键，快速返回之前逐步调试的地方。</p></li>
</ol>

<ul>
<li>快捷键：（Debug时) <code>Alt + F10</code>；</li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980726232579.gif" alt="20171104150980726232579.gif"/></p>

<h3 id="toc_119">终止进程（Stop Process）</h3>

<ul>
<li><strong>描述</strong>：该操作会终止当前正在运行的任务。如果任务数量大于一，则显示一个列表供你选择。在终止调试或者中止编译的时候特别有用！</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + F2</code></li>
<li>Windows、Linux: <code>Ctrl + F2</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980743452167.gif" alt="20171104150980743452167.gif"/></p>

<h3 id="toc_120">临时断点（Temporary Breakpoints）</h3>

<ul>
<li><strong>描述</strong>：通过该操作可以添加一个断点，这个断点会在第一次被命中的时候自动移除。</li>
<li><strong>快捷键</strong>：
<ul>
<li>鼠标: <code>Alt + 鼠标左键 点击代码左侧</code></li>
<li>OS X: <code>Cmd + Alt + Shift + F8</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + Shift + F8</code></li>
</ul></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980746471135.gif" alt="20171104150980746471135.gif"/></p>

<h3 id="toc_121">调用层级树弹窗（The Call Hierarchy Popup）</h3>

<ul>
<li><strong>描述</strong>：该操作会给你展示 在一个方法的声明和调用之间所有可能的路径。</li>
<li><strong>快捷键</strong>：<code>Ctrl + Alt + H</code></li>
</ul>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20171104150980748531704.gif" alt="20171104150980748531704.gif"/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/6/1</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869484.html">
                
                  <h1>Android-线程管理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Thread</h2>

<ul>
<li>继承Thread方式</li>
<li>实现Runnable接口</li>
</ul>

<h2 id="toc_1">Thread主要函数：</h2>

<ul>
<li><code>run()</code>//包含线程运行时所执行的代码</li>
<li><code>start()</code>//用于启动线程</li>
<li><code>sleep()/sleep(long millis)</code>//线程休眠，交出CPU，让CPU去执行其他的任务，然后线程进入阻塞状态，sleep方法不会释放锁</li>
<li><code>yield()</code>//使当前线程交出CPU，让CPU去执行其他的任务，但不会是线程进入阻塞状态，而是重置为就绪状态，yield方法不会释放锁</li>
<li><code>join()/join(long millis)/join(long millis,int nanoseconds)</code>//等待线程终止，直白的说 就是发起该子线程的线程 只有等待该子线程运行结束才能继续往下运行</li>
<li><code>wait()</code>//交出cpu，让CPU去执行其他的任务，让线程进入阻塞状态，同时也会释放锁</li>
<li><code>interrupt()</code>//中断线程，自stop函数过时之后，我们通过interrupt方法和isInterrupted()方法来停止正在运行的线程，注意只能中断已经处于阻塞的线程</li>
<li><code>getId()</code>//获取当前线程的ID</li>
<li><code>getName()/setName()</code>//获取和设置线程的名字</li>
<li><code>getPriority()/setPriority()</code>//获取和这是线程的优先级 一般property用1-10的整数表示，默认优先级是5，优先级最高是10，优先级高的线程被执行的机率高</li>
<li><code>setDaemon()/isDaemo()</code>//设置和判断是否是守护线程</li>
<li><code>currentThread()</code>//静态函数获取当前线程</li>
</ul>

<h2 id="toc_2">Thread线程主要状态</h2>

<ol>
<li>New  一旦被实例化之后就处于new状态</li>
<li>Runnable 调用了start函数之后就处于Runnable状态</li>
<li>Running 线程被cpu执行 调用run函数之后 就处于Running状态</li>
<li>Blocked 调用join()、sleep()、wait()使线程处于Blocked状态</li>
<li>Dead    线程的run()方法运行完毕或被中断或被异常退出，线程将会到达Dead状态</li>
</ol>

<h2 id="toc_3">如何停止一个线程</h2>

<p>通过interrupt方法和isInterrupted()方法来停止正在运行的线程，首先必须先让线程处于阻塞状态</p>

<h2 id="toc_4">Thread线程同步问题</h2>

<ul>
<li>同步函数</li>
<li>同步代码块</li>
<li>使用特殊域变量(volatile)实现线程同步</li>
</ul>

<h2 id="toc_5">ExecutorService线程池</h2>

<h3 id="toc_6">new Thread()的缺点</h3>

<ul>
<li>每次new Thread()耗费性能</li>
<li>调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。</li>
<li>不利于扩展，比如如定时执行、定期执行、线程中断<br/>
#### 采用线程池的优点</li>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>

<p><strong>ExecutorService</strong></p>

<pre><code class="language-java">public interface ExecutorService extends Executor{
    void shutdown();//顺次地关闭ExecutorService,停止接收新的任务，等待所有已经提交的任务执行完毕之后，关闭ExecutorService

    List&lt;Runnable&gt; shutdownNow();//阻止等待任务启动并试图停止当前正在执行的任务，停止接收新的任务，返回处于等待的任务列表

    boolean isShutdown();//判断线程池是否已经关闭

    boolean isTerminated();//如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。

    
    boolean awaitTermination(long timeout, TimeUnit unit)//等待（阻塞）直到关闭或最长等待时间或发生中断,timeout - 最长等待时间 ,unit - timeout 参数的时间单位  如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false 

 
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);//提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。

    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。

 
    Future&lt;?&gt; submit(Runnable task);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。
        throws InterruptedException;

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                  long timeout, TimeUnit unit)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。
        throws InterruptedException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。
        throws InterruptedException, ExecutionException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;   
}
</code></pre>

<p><strong>Executor接口</strong></p>

<pre><code class="language-java">public interface Executor {

    void execute(Runnable command);//执行已提交的 Runnable 任务对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法
}
</code></pre>

<p><strong>Executors工厂类</strong></p>

<ul>
<li><code>newFixedThreadPool()</code>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。(运行结果：总共只会创建5个线程， 开始执行五个线程，当五个线程都处于活动状态，再次提交的任务都会加入队列等到其他线程运行结束，当线程处于空闲状态时会被下一个任务复用)</li>
<li><code>newCachedThreadPool()</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程(运行结果：可以看出缓存线程池大小是不定值，可以需要创建不同数量的线程，在使用缓存型池时，先查看池中有没有以前创建的线程，如果有，就复用.如果没有，就新建新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务)</li>
<li><code>newScheduledThreadPool()</code>创建一个定长线程池，支持定时及周期性任务执行<code>schedule(Runnable command,long delay, TimeUnit unit)</code>创建并执行在给定延迟后启用的一次性操作(运行结果和newFixedThreadPool类似，不同的是newScheduledThreadPool是延时一定时间之后才执行<code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnitunit)</code>  创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 <code>initialDelay</code>后开始执行，然后在<code>initialDelay+period</code> 后执行，接着在 <code>initialDelay + 2 * period</code> 后执行，依此类推)<code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟</li>
<li><code>newSingleThreadExecutor()</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行(运行结果：只会创建一个线程，当上一个执行完之后才会执行第二个)通过<code>ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</code>实现延时的单线程线程池。</li>
</ul>

<h2 id="toc_7">ThreadPoolExecutor</h2>

<p>ThreadPoolExecutor线程池用于管理线程任务队列、若干个线程。</p>

<h3 id="toc_8">1.ThreadPoolExecutor构造函数</h3>

<pre><code class="language-java">ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue);
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit,BlockingQueue workQueue,RejectedExecutionHandler handler);
ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler) ;
ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory, RejectedExecutionHandler handler);
</code></pre>

<ul>
<li><em>corePoolSize</em>： 线程池维护线程的最少数量　　</li>
<li><em>maximumPoolSize</em>：线程池维护线程的最大数量　　</li>
<li><em>keepAliveTime</em>： 线程池维护线程所允许的空闲时间　　</li>
<li><em>unit</em>： 线程池维护线程所允许的空闲时间的单位　　</li>
<li><em>workQueue</em>： 线程池所使用的缓冲队列　　</li>
<li><em>threadFactory</em>：线程池用于创建线程　　</li>
<li><em>handler</em>： 线程池对拒绝任务的处理策略</li>
</ul>

<h3 id="toc_9">AsyncTask</h3>

<p>Android的AsyncTask比Handler更轻量级一些，适用于简单的异步处理。同时在处理单个后台任务时，AsyncTask的代码量更少并且更加轻量级。<br/>
AsyncTask定义了三种泛型类型 Params，Progress和Result。</p>

<ul>
<li>Params 启动任务执行的输入参数，比如HTTP请求的URL。</li>
<li>Progress 后台任务执行的百分比。</li>
<li>Result 后台执行任务最终返回的结果，比如String。<br/>
使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法：</li>
<li>doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。</li>
<li>onPostExecute(Result)  相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回<br/>
有必要的话你还得重写以下这三个方法，但不是必须的：</li>
<li>onProgressUpdate(Progress…)   可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。</li>
<li>onPreExecute()        这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。</li>
<li>onCancelled()             用户调用取消时，要做的操作<br/>
使用AsyncTask类，以下是几条必须遵守的准则：</li>
<li>Task的实例必须在UI thread中创建；</li>
<li>execute方法必须在UI thread中调用；</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params...), onProgressUpdate(Progress...)这几个方法；</li>
<li>该task只能被执行一次，否则多次调用时将会出现异常；</li>
</ul>

<h3 id="toc_10">参考</h3>

<p><a href="http://www.cnblogs.com/whoislcj/p/5603277.html">Android线程管理</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869436.html">
                
                  <h1>Android-Issues</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>这篇文章主要记录一些在实际开发中遇到的问题，以及对其的解决措施。方便日后解决同样类型的问题。</p>

<h2 id="toc_1">Activity的使用</h2>

<h3 id="toc_2">1、onSaveInstance 和 onRestoreInstanceState</h3>

<p>onSaveInstance方法在系统回收Activity之前会调用；Back键不会调用。onPause（）—&gt;<code>onSaveInstanceState( )</code>–&gt;onStop( );<code>onRestoreInstanceState()</code>会在onStart()和onResume()之间执行。</p>

<ul>
<li>1、当用户按下HOME键时。这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</li>
<li>2、长按HOME键，选择运行其他的程序时。</li>
<li>3、按下电源按键（关闭屏幕显示）时。</li>
<li>4、从activity A中启动一个新的activity时。</li>
<li>5、屏幕方向切换时，例如从竖屏切换到横屏时。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</li>
</ul>

<p>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和 onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提 是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。<br/>
activity中保存数据有两种方式onPause()，onSaveInstance(bundle),  恢复数据也有两种途径onCreate(Bundle), onRestoreInstanceState(budle)，默认情况下onSaveInstanceSate()和onRestoreInstanceState()会对UI状态进行保存和恢复，如果需要保存其他数据可以在onSaveInstanceState()，onPause()保存，但是如果是持久化的数据得通过onPause()保存(google推荐)。</p>

<h2 id="toc_3">二、Fragment使用</h2>

<h3 id="toc_4">1、<code>java.lang.IllegalStateException: Fragment does not have a view</code></h3>

<p>先说明下出现这个异常的原因，这是在<code>fragment onCreateView()</code>中调用<code>getChildFragmentManager()</code>的时候出现的。解决办法就是不要再onCreateView()中调用<code>getChildFragmentManager()</code>。那么如果你要调用<code>getChildFragmentManager()</code>，那么必须onCreateView之后，view被创建了。</p>

<h2 id="toc_5">三、UI控件</h2>

<h3 id="toc_6">1、Button控件</h3>

<h4 id="toc_7">（1）解决Android5.0版本以上Button自带阴影问题</h4>

<p>设置Button的样式为<code>style=&quot;?android:attr/borderlessButtonStyle&quot;</code></p>

<h3 id="toc_8">2、TextView控件</h3>

<h4 id="toc_9">（1）Text View中修改文字段落中部分字体颜色</h4>

<p>使用ForegroundColorSpan来修改</p>

<h3 id="toc_10">3、CheckBox控件</h3>

<h4 id="toc_11">（1）如何修改复选框的样式</h4>

<ul>
<li><p>首先在drawable文件夹中添加drawable文件checkbox_style.xml。</p>
<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  <br/>
&lt;item android:drawable=&quot;@drawable/checkbox_pressed&quot; android:state_checked=&quot;true&quot;/&gt;  <br/>
&lt;item android:drawable=&quot;@drawable/checkbox_normal&quot; android:state_checked=&quot;false&quot;/&gt;  <br/>
&lt;item android:drawable=&quot;@drawable/checkbox_normal&quot;/&gt;  <br/>
&lt;/selector&gt;
</code></pre></li>
<li><p>在values文件夹下的styles.xml文件中添加CustomCheckboxTheme样式。</p></li>
</ul>

<pre><code class="language-markup">&lt;style name=&quot;CustomCheckboxTheme&quot; parent=&quot;@android:style/Widget.CompoundButton.CheckBox&quot;&gt;  
    &lt;item name=&quot;android:button&quot;&gt;@drawable/checkbox_style&lt;/item&gt;  
&lt;/style&gt;
</code></pre>

<ul>
<li>在布局文件中使用CustomCheckboxTheme样式。
<code>xml
&lt;CheckBox  <br/>
android:id=&quot;@+id/select_all&quot;  <br/>
android:layout_width=&quot;wrap_content&quot;  <br/>
android:layout_height=&quot;wrap_content&quot;  <br/>
style=&quot;@style/CustomCheckboxTheme&quot; /&gt;
</code></li>
</ul>

<h3 id="toc_12">4、RecyclerView控件</h3>

<h4 id="toc_13">（1）RecyclerView删除Item导致位置错乱</h4>

<p>RecyclerView的刷新分为内容变化和结构变化，结构变化比如remove和insert等并不会导致viewholder的更新，所以有时候我们使用<code>notifyItemRemoved(position);</code>或者使用<code>notifyItemInserted(position);</code>item的位置并没有发生改变，或者位置发生错乱，很是奇怪诡异，需要重新调用<code>notifyDataSetChanged();</code>才能刷新整个List每个Item的位置，但这样做会使得RecyclerView增加和删除的动画效果没有了。那么要既想没有Bug的插入删除，又想有动画怎么搞呢，只需要刷新删除位置以下的List的Item位置即可，那么幸亏RecyclerView有一个局部刷新的方法：<code>notifyItemRangeChanged(int positionStart, int itemCount)</code>怎么使用呢？ 我们只需要在删除或插入时同时,刷新改变位置item下方的所有Item的位置： 插入动作：</p>

<pre><code class="language-java">notifyItemInserted(position);
if (position != mData.size()) {
   otifyItemRangeChanged(position, mData.size() - position);
 }
</code></pre>

<p>删除动作：</p>

<pre><code class="language-java"> notifyItemRemoved(position);
if (position != mData.size()) {
   otifyItemRangeChanged(position, mData.size() - position);
 }
</code></pre>

<h4 id="toc_14">（2）RecyclerView只显示第一个数据</h4>

<p>在<code>onCreateViewHolder</code>中获取View的时候不指定<code>ViewGroup</code></p>

<pre><code class="language-java">@Override  
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  
    LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext());  
    View convertView = layoutInflater.inflate(R.layout.item, null, false); // if use parent, only first line will show up  
    return new ViewHolder(convertView);  
}
</code></pre>

<h3 id="toc_15">5、EditText控件</h3>

<h4 id="toc_16">（1）如何自动打开软键盘</h4>

<h2 id="toc_17">四、自定义View的实现</h2>

<h3 id="toc_18">1、自定义TextView时，自定义参数的设置</h3>

<p>自定义属性一般在<code>onMeasure()</code>方法后才能将XML文件中的自定义设置的属性数值传递进来，无法在<code>setBackground()</code>方法和<code>setText()</code>方法直接调用。如果是想要在代码中设置变量属性，还是直接在自定义控件扩展类中添加新方法进行使用。自定义控件的三个构造类</p>

<pre><code class="language-java">public GuideTextView(Context context) //在代码中直接使用
public GuideTextView(Context context, AttributeSet attrs) //在xml文件中直接使用时调用
public GuideTextView(Context context, AttributeSet attrs, int defStyleAttr) //xml文件中使用默认主题时调用
</code></pre>

<h3 id="toc_19">2、扩展自定义View的实现</h3>

<p>在<code>onDraw()</code>方法中，将绘制代码写在<code>super.onDraw(canvas);</code>方法之前，绘制效果将显示在控件底层；将绘制代码写在<code>super.onDraw(canvas);</code>方法之后，绘制效果将显示在控件底层。</p>

<h3 id="toc_20">3、getDimension()、getDimensionPixelOffset()和getDimensionPixelSize()的区别</h3>

<ul>
<li><code>getDimension()</code>是基于当前DisplayMetrics进行转换，获取指定资源id对应的尺寸。文档里并没说这里返回的就是像素，要注意这个函数的返回值是float，像素肯定是int。</li>
<li><code>getDimensionPixelSize()</code>与<code>getDimension()</code>功能类似，不同的是将结果转换为int，并且小数部分四舍五入。</li>
<li><code>getDimensionPixelOffset()</code>与<code>getDimension()</code>功能类似，不同的是将结果转换为int，并且偏移转换（offset conversion，函数命名中的offset是这个意思）是直接截断小数位，即取整（其实就是把float强制转化为int，注意不是四舍五入哦）。
由此可见，这三个函数返回的都是绝对尺寸，而不是相对尺寸（dp/sp等）。如果getDimension()返回结果是20.5f，那么<code>getDimensionPixelSize()</code>返回结果就是21，<code>getDimensionPixelOffset()</code>返回结果就是20。</li>
</ul>

<h3 id="toc_21">4、DisplayMetrics显示的数值</h3>

<ul>
<li><em>density</em>: 显示的逻辑分辨率</li>
<li><em>width</em>及<em>height</em>: 屏幕分辨率(绝对宽高)</li>
<li><em>scaleDensity</em>: 字体显示的缩放因子</li>
<li><em>xdpi</em>及<em>ydpi</em>: 水平方向DPI和竖直方向DPI</li>
</ul>

<h3 id="toc_22">5、屏幕尺寸单位</h3>

<ul>
<li>屏幕尺寸: 屏幕尺寸指屏幕的对角线的长度，单位是英寸(in)，1英寸=2.54厘米</li>
<li>px: 是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素，一般以纵向像素*横向像素。</li>
<li>dpi: dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。</li>
<li>density: 屏幕密度，density和dpi的关系为 density = dpi/160</li>
<li>dp和dip: 设备独立像素，device independent pixels的缩写， <a href="http://lib.csdn.net/base/android">Android</a> 特有的单位，在屏幕密度dpi = 160屏幕上，1dp = 1px。dp和density的关系为 1dp = density px，dip值 =（dpi值/160）* pixel值</li>
<li>sp: 和dp很类似，一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。</li>
</ul>

<h3 id="toc_23">6、EditText启动软键盘怎么和EditText布局一起上移，并且背景不动</h3>

<p>在根布局中添加ScrollView来存放背景显示内容，中间必须添加一个RelativeLayout或者LinearLayout(如果添加RelativeLayout则ScrollView必须设置属性<code>android:fillViewport=&quot;true&quot;</code>)，在ScrollView控件底下添加EditText所在布局，设置AndroidManifest.xml中<code>android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot;</code>，在代码中设置RelativeLayout中的显示布局的布局属性。</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.jrm.adolph.test1.MainActivity&quot;&gt;
    &lt;ScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:fillViewport=&quot;true&quot;&gt;
        &lt;RelativeLayout
            android:id=&quot;@+id/layout&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;

            &lt;RelativeLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;64dp&quot;
                android:background=&quot;@color/colorAccent&quot;&gt;
                &lt;TextView
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_centerInParent=&quot;true&quot;
                    android:text=&quot;软键盘&quot;
                    android:textSize=&quot;20sp&quot;/&gt;
            &lt;/RelativeLayout&gt;
            &lt;RelativeLayout
                android:id=&quot;@+id/content_layout&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;&gt;
                &lt;TextView
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:text=&quot;Hello World!&quot;
                    android:layout_centerInParent=&quot;true&quot;
                    android:textSize=&quot;20sp&quot;/&gt;
            &lt;/RelativeLayout&gt;
        &lt;/RelativeLayout&gt;
    &lt;/ScrollView&gt;
    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;48dp&quot;
        android:layout_alignParentBottom=&quot;true&quot;&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;送礼&quot;/&gt;
        &lt;EditText
            android:id=&quot;@+id/et&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_weight=&quot;1&quot;/&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;发送&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<pre><code class="language-java">Rect outRect = new Rect();
getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect);
RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) layout.getLayoutParams();
params.height = outRect.bottom - outRect.top;
layout.setLayoutParams(params);
</code></pre>

<h3 id="toc_24">7、设置Button的selector控制按钮的点击形态</h3>

<p>设置好press、enable属性的对应图片，点击按钮图片形态不响应。必须把默认的按钮图片样式放在最底下，才能实现。</p>

<pre><code class="language-markup">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_pressed_btn&quot; android:state_pressed=&quot;true&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_unable_btn&quot; android:state_enabled=&quot;false&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_focusable_btn&quot;/&gt;
&lt;/selector&gt;
</code></pre>

<h3 id="toc_25">8、DispatchTouchEvent</h3>

<p>重写dispatchTouchEvent的时候，无论你是return true，亦或是return false都会导致child接受不到事件。<br/>
<code>return true</code> ： 告诉parent，这个事件我消费了。如果这个是down事件，那么我就会作为一个target或者说handle(事件持有者)，后续的move事件或者up事件等，都会直接分发到我这里，不继续往下分发。 <br/>
<code>return false</code>：告诉parent，这个事件我不需要，那么会交回给parent的onTouchEvnet处理。只有return <code>super.dispatchTouchEvent</code>的时候才会将事件继续往下传递。<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616205533627.jpg" alt="20170923150616205533627.jpg"/></p>

<h2 id="toc_26">五、Android类库使用问题</h2>

<h3 id="toc_27">1、Android DataBinding</h3>

<h4 id="toc_28">（1）include布局使用，如何传变量进去</h4>

<p>include布局中同样用layout标签包裹，将父布局中的变量以</p>

<pre><code class="language-text">app:XXX=&quot;@{XXX}&quot;
</code></pre>

<p>自定义属性的形式传进去,并在include布局中同样申明XXX相同的变量名以及变量类型，即可进行使用。注意使用在表达式中使用View.VISIBLE设置可视化的时候导入View类，否则会报错。</p>

<h4 id="toc_29">（2）如何调用include中的控件</h4>

<p>普通调用include中的控件，直接使用<code>findViewById</code>可以直接获取控件。使用dataBinding时，有时会出现获取控件无法调用的情况，这种情况给include标签赋一个id，在类中通过<code>bind.&lt;include-id&gt;.&lt;widget-id&gt;</code>进行调用。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869386.html">
                
                  <h1>Android-常用的Android库</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android开发中常用的以及想要尝试的库，在这里还是记录下。</p>

<h2 id="toc_1"><a href="https://github.com/airbnb/lottie-android">Lottie</a></h2>

<p>这是一个能解析Adobe After Effects动画导出的JSON文件并把它们渲染成本地动画的库。在Google Play Store上有一个示例app。</p>

<h2 id="toc_2"><a href="https://github.com/GrenderG/Toasty">Toasty</a></h2>

<p>一个创建自定义Toast的库。</p>

<h2 id="toc_3"><a href="https://github.com/Muddz/StyleableToast">StyleableToast</a></h2>

<p>这是另外一个创建自定义Toast的库。</p>

<h2 id="toc_4"><a href="https://github.com/NYTimes/Store">Store</a></h2>

<p>Store是一个异步加载和缓存库。文档描述：</p>

<blockquote>
<p>Store是一个简化数据的请求，解析，保存，以及数据重试的类。一个Store类似于 仓库模式 ，不过用RxJava封装成了响应式的API，以支持单向数据流 。</p>
</blockquote>

<p>文档非常易懂，这个库值得尝试。你可以尝试各种flows，比如数据请求，缓存，解析等。</p>

<h2 id="toc_5"><a href="https://github.com/rubensousa/PreviewSeekBar">PreviewSeekBar</a></h2>

<p>如果你使用Google Play Movies，你可能注意到了这个动画效果很棒，可以预览电影的SeekBar。 Rúben Sousa 实现了这种效果并开源。</p>

<h2 id="toc_6"><a href="https://github.com/jgilfelt/chuck">Chuck</a></h2>

<p>如果你使用 OkHttp的话，这个库可以帮助你拦截并记录所有的HTTP请求与响应。它还提供了一个来显示内容。</p>

<h2 id="toc_7"><a href="https://github.com/hugeterry/CoordinatorTabLayout">CoordinatorTabLayout</a></h2>

<p>CoordinatorTabLayout是一个自定义的组合控件，帮助你快速实现TabLayout与CoordinatorLayout相结合的样式。</p>

<h2 id="toc_8"><a href="https://github.com/Bilibili/boxing">Boxing</a></h2>

<p>Boxing是一个基于MVP模式的Android多媒体选择器，你可以：</p>

<ul>
<li>图片选择（单／多选），</li>
<li>预览或者剪裁图片。</li>
</ul>

<p>它还支持gif，视图选择，图片压缩以及自定义UI：</p>

<h2 id="toc_9"><a href="https://github.com/zhouchaoyuan/excelPanel">excelPanel</a></h2>

<p>RecyclerView实现的二维表格，不仅可以加载历史数据，还能加载新数据。</p>

<h2 id="toc_10"><a href="https://github.com/Mulham-Raee/HorizontalCalendar">Horizontal Calendar</a></h2>

<p>又一个用RecyclerView实现的Material横向日历视图。</p>

<h2 id="toc_11"><a href="https://github.com/florent37/CameraFragment">CameraFragment</a></h2>

<p>一个集成了拍照功能的Fragment ，根据README：</p>

<blockquote>
<p>CameraFragment直接预览camera视图，并提供简单的API来捕获或者管理设备。你可以使用CameraFragment设置自己的布局以及控制camera。</p>
</blockquote>

<h2 id="toc_12"><a href="https://github.com/sharish/ShimmerRecyclerView">ShimmerRecyclerView</a></h2>

<p>一个可以在加载数据的时候显示闪烁（Shimmer）的RecyclerView。这个RecyclerView内置一个adapter，控制shimmer的外观。</p>

<h2 id="toc_13"><a href="https://github.com/andremion/CounterFab">CounterFab</a></h2>

<p>这是一个在浮动操作按钮的右上角显示数字标识的库。可以从Google Play上下载demo app。</p>

<h2 id="toc_14"><a href="https://github.com/rosenpin/FadingTextView">FadingTextView</a></h2>

<p>一个可以让TextView以淡如淡出的形式不断改变自己内容的库。</p>

<h2 id="toc_15"><a href="https://github.com/afollestad/bridge">Bridge</a></h2>

<blockquote>
<p>Bridge是一个简单但是强大的HTTP网络操作库。提供链式调用的API，为了最大的兼容性和最快的速度，用 Java/Android的URLConnection类实现。</p>
</blockquote>

<p>这个库文档非常齐全，绝对值得一试。</p>

<h2 id="toc_16"><a href="https://github.com/afollestad/ason">Ason</a></h2>

<p>这是Aidan Follestad的第二个library。其主要目的是简化和JSON的交互。</p>

<blockquote>
<p>also makes (de)serialization painless.</p>
</blockquote>

<h2 id="toc_17"><a href="https://github.com/greenrobot/ObjectBox">ObjectBox</a></h2>

<p>大家都应该知道greenrobot，不知道的话也应该知道他们开发的 GreenDAO 和 EventBus。这次要介绍的是一个面向对象的数据库。greenrobot宣称：</p>

<blockquote>
<p>性能是我们创建ObjectBox的首要因素。之前我们创建了安卓和SQLite上最快的对象关系映射 (ORM) greenDAO。自从2011年第一个版本发布以来，我们对对象持久化－以及SQLite的缺陷有了许多认识。我们意识到， 要显著提高移动端的性能，需要从内核开始，创建一个基于对象的数据库。</p>
</blockquote>

<h2 id="toc_18"><a href="https://github.com/nex3z/FlowLayout">FlowLayout</a></h2>

<p>一个让子view在空间不够的情况下自动跳到下一行的布局。子view之间的间隔由FlowLayout计算出来，以便让view是均匀分布的。</p>

<h2 id="toc_19"><a href="https://github.com/MatthiasRobbers/shortbread">Shortbread</a></h2>

<p>这是一个这样的库</p>

<blockquote>
<p>为使用了@Shortcut注解的Activity和方法生成app shortcuts。无需动用manifest, XML以及shortcut manager。只需为想要shortcut调用的代码添加注释。</p>
</blockquote>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869292.html">
                
                  <h1>EventBus 3.0的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>一直用Handler来处理应用内的通信，但是发现局限性还是太大了。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。</p>

<h2 id="toc_1">使用EventBus</h2>

<h3 id="toc_2">添加依赖库</h3>

<p><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;</code></p>

<h3 id="toc_3">注册</h3>

<p>举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。</p>

<pre><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    EventBus.getDefault().register(this);

}
@Override
protected void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
}
</code></pre>

<h3 id="toc_4">订阅者</h3>

<p>类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了:</p>

<pre><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(String message){
    mText.setText(message);
}
</code></pre>

<p>该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：<br/>
我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？</p>

<h3 id="toc_5">发布者</h3>

<p>既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：</p>

<pre><code class="language-java">String json=&quot;&quot;;
EventBus.getDefault().post(json);
</code></pre>

<p>这样就OK了，你可以试下能否正常运行了！</p>

<h2 id="toc_6">原理初探</h2>

<p>你订阅了内容，所以你需要在该类注册EventBus，而你订阅的方法需要传入String,即你的接收信息为String类型，那么在post的时候，你post出去的也应该是String类型，其才会接收到消息。</p>

<h3 id="toc_7">如果你post的是对象</h3>

<p>首先你需要定义一个类似pojo类：</p>

<pre><code class="language-java">public class MessageEvent {
  public final String name;
  public final String password;
  public MessageEvent(String name,String password) {
    this.name = name;
    this.password=password;
  }
}
</code></pre>

<h3 id="toc_8">然后你post的时候：</h3>

<p><code>EventBus.getDefault().post(new MessageEvent(&quot;hello&quot;,&quot;world&quot;));</code></p>

<h3 id="toc_9">当然，你接收的方法也需要改为：</h3>

<pre><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(MessageEvent message){
    mText.setText(message.name);
}
</code></pre>

<h2 id="toc_10">ThreadMode提供了四个常量：</h2>

<ul>
<li>MainThread 主线程</li>
<li>BackgroundThread 后台线程</li>
<li>Async 后台线程</li>
<li>PostThread 发送线程（默认）</li>
</ul>

<p>BackgroundThread:当事件是在UI线程发出，那么事件处理实际上是需要新建单独线程，如果是在后台线程发出，那么事件处理就在该线程。该事件处理方法应该是快速的，避免阻塞后台线程。<br/><br/>
Async：发送事件方不需要等待事件处理完毕。这种方式适用于该事件处理方法需要较长时间，例如网络请求。</p>

<h2 id="toc_11">EventBus黏性事件</h2>

<p>EventBus除了普通事件也支持粘性事件，这个有点类似广播分类中的粘性广播。本身粘性广播用的就比较少，为了方便理解成订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅函数有所不同，需要注解中添加<code>sticky = true</code></p>

<pre><code class="language-java">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true) //在ui线程执行
    public void onDataSynEvent(DataSynEvent event) {
        Log.e(TAG, &quot;event----&gt;&quot; + event.getCount());
}
</code></pre>

<h3 id="toc_12">发送粘性事件</h3>

<p><code>EventBus.getDefault().postSticky(new DataSynEvent());</code>  </p>

<h3 id="toc_13">对于粘性广播我们都比较清楚属于常驻广播，对于EventBus粘性事件也类似，我们如果不再需要该粘性事件我们可以移除</h3>

<p><code>EventBus.getDefault().removeStickyEvent(new DataSynEvent());</code>  </p>

<h3 id="toc_14">或者调用移除所有粘性事件</h3>

<p><code>EventBus.getDefault().removeAllStickyEvents();</code>  </p>

<p>默认情况下，其为false。什么情况下使用sticky呢？<br/><br/>
当你希望你的事件不被马上处理的时候，举个栗子，比如说，在一个详情页点赞之后，产生一个VoteEvent，VoteEvent并不立即被消费，而是等用户退出详情页回到商品列表之后，接收到该事件，然后刷新Adapter等。其实这就是之前我们用startActivityForResult和onActivityResult做的事情。  </p>

<h2 id="toc_15">订阅事件的优先级</h2>

<p>事件的优先级类似广播的优先级，优先级越高优先获得消息</p>

<pre><code class="language-java">@Subscribe(threadMode = ThreadMode.MAIN,priority = 100) //在ui线程执行 优先级100
    public void onDataSynEvent(DataSynEvent event) {
        Log.e(TAG, &quot;event----&gt;&quot; + event.getCount());
}
</code></pre>

<h2 id="toc_16">终止事件往下传递</h2>

<p>发送有序广播可以终止广播的继续往下传递，EventBus也实现了此功能<br/>
<code>EventBus.getDefault().cancelEventDelivery(event) ;//优先级高的订阅者可以终止事件往下传递</code></p>

<h2 id="toc_17">建议</h2>

<p>推荐大家在使用EventBus的时候，创建一个事件类，把你的每一个参数（或者可能发生冲突的参数），封装成一个类：</p>

<pre><code class="language-java">public class Event  {  
    public static class UserListEvent {  
        public List&lt;User&gt; users ;  
    }
    public static class ItemListEvent {  
        public List&lt;Item&gt; items;  
    }    
}
</code></pre>

<h2 id="toc_18">processor使用</h2>

<p>按照Markus Junginger的说法（EventBus创作者），在3.0中，如果你想进一步提升你的app的性能.<br/>
EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析,处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.<br/><br/>
其在编译的时候为注册类构建了一个索引，而不是在运行时，这样的结果是其让EventBus 3.0的性能提升了一倍，相比2.4来说，其会是它的3到6倍。大家可以感受下：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149145841588866.png" alt="20170406149145841588866.png"/>  </p>

<h3 id="toc_19">具体使用：在build.gradle中添加如下配置</h3>

<pre><code class="language-text">buildscript {
    dependencies {
        classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39;
    }
}
apply plugin: &#39;com.neenbedankt.android-apt&#39;

dependencies {
    compile &#39;org.greenrobot:eventbus:3.0.0&#39;
    apt &#39;org.greenrobot:eventbus-annotation-processor:3.0.1&#39;
}
apt {
    arguments {
        eventBusIndex &quot;com.whoislcj.eventbus.MyEventBusIndex&quot;
    }
}
</code></pre>

<h3 id="toc_20">使用索引</h3>

<p>此时编译一次，自动生成生成索引类。在\build\generated\source\apt\PakageName\下看到通过注解分析生成的索引类，这样我们便可以在初始化EventBus时应用我们生成的索引了。自动生成的代码。</p>

<pre><code class="language-java">/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();

        putIndex(new SimpleSubscriberInfo(com.whoislcj.testhttp.MainActivity.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo(&quot;onDataSynEvent&quot;, com.whoislcj.testhttp.eventBus.DataSynEvent.class,
                    ThreadMode.MAIN, 100, false),
            new SubscriberMethodInfo(&quot;onDataSynEvent1&quot;, com.whoislcj.testhttp.eventBus.TestEvent.class, ThreadMode.MAIN,
                    0, true),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    @Override
    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
</code></pre>

<p>添加索引到EventBus默认的单例中<br/><br/>
<code>EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();</code>  </p>

<h3 id="toc_21">对比添加前后注册效率对比</h3>

<p>分别EventBus.getDefault().register(this);</p>

<ul>
<li>添加之前：前后用了9毫秒</li>
<li>添加之后：前后用了2毫秒</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869255.html">
                
                  <h1>GreenDao3.2.0的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>我相信，在平时的开发过程中，大家一定会或多或少地接触到SQLite。然而在使用它时，我们往往需要做许多额外的工作，像编写 SQL语句与解析查询结果等。所以，适用于Android ORM框架也就孕育而生了，现在市面上主流的框架有OrmLite、SugarORM、Active Android、Realm与greenDAO。但是使用数量最多的还是Realm与greenDAO，所以为了目前的项目需要写个文档记录一下greenDAO的使用。简单的讲，greenDAO是一个将对象映射到SQLite 数据库中的轻量且快速的ORM解决方案。（greenDAO is a light &amp; fast ORM solution that maps objects to SQLite databases.）。<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144616018213.png" alt="20170406149144616018213.png"/><br/>
这个图对于理解greenDAO是必不可少的。</p>

<h2 id="toc_1">greenDAO特点</h2>

<ul>
<li>性能最大化，可能是Android平台上最快的ORM框架</li>
<li>易于使用的API</li>
<li>最小的内存开销</li>
<li>依赖体积小</li>
<li>支持数据库加密</li>
<li>强大的社区支持</li>
</ul>

<h2 id="toc_2">配置greenDAO</h2>

<h3 id="toc_3">在<code>app</code>的Gradle中配置：</h3>

<p><code>apply plugin: &#39;org.greenrobot.greendao&#39;</code>  </p>

<pre><code class="language-text">dependencies {
        compile &#39;org.greenrobot:greendao:3.2.0&#39;
}
</code></pre>

<h3 id="toc_4">在<code>project</code>的Gradle中配置：</h3>

<pre><code class="language-text">buildscript {
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath &#39;org.greenrobot:greendao-gradle-plugin:3.2.1&#39; 
    }
}
</code></pre>

<h3 id="toc_5">在app的Gradle配置数据库版本等信息</h3>

<pre><code class="language-text">greendao {
    schemaVersion 1                         //对应当前数据库版本c
    daoPackage &#39;com.koma.greendao.gen&#39;  //由GreenDao自动生成代码所在的包名，默认的是在项目包下面新建一个gen。
    targetGenDir &#39;src/main/java&#39;        //设置自动生成代码的目录
}
</code></pre>

<h2 id="toc_6">使用greenDAO</h2>

<h3 id="toc_7">使用流程</h3>

<p>在项目中新建一个表字段的实体类，不需要自己写get和set方法，在生成表的时候会自动生成。不要忘了在类名上标记@Entity注解如图：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144836199963.png" alt="20170406149144836199963.png"/>  </p>

<p>选择build ——Make Project 一切顺利的话则会在包名下生成数据库的操作类，如下图：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144839868744.png" alt="20170406149144839868744.png"/></p>

<p>Ps:新建一个实体类，对项目进行<code>Make Project</code>，成功之后会在daoPackage目录下自动生成代码</p>

<h3 id="toc_8">在项目中定义实体类</h3>

<pre><code class="language-java">@Entity
public class User  {
    @Id(autoincrement = true)
    private Long id;
    @Property(nameInDb = &quot;USERNAME&quot;)
    private String name;
    private int age;
}
</code></pre>

<h3 id="toc_9">注解：</h3>

<ul>
<li>@Entity——————————标识实体类，greenDAO会映射成sqlite的一个表，表名为实体类名的大写形式
<ul>
<li>schema：告知GreenDao当前实体属于哪个schema</li>
<li>active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法</li>
<li>nameInDb：在数据库中使用的别名，默认使用的是实体的类名</li>
<li>indexes：定义索引，可以跨越多个列</li>
<li>createInDb：标记创建数据库表</li>
</ul></li>
<li>基础属性注解
<ul>
<li>@Id——————————标识主键，该字段的类型为long或Long类型，autoincrement设置是否自动增长</li>
<li>@Property——————————标识该属性在表中对应的列名称, nameInDb设置名称</li>
<li>@Transient——————————标识该属性将不会映射到表中，也就是没有这列</li>
<li>@NotNull——————————设置表中当前列的值不可为空</li>
</ul></li>
<li>索引注解
<ul>
<li>@Unique——————————向数据库列添加了一个唯一的约束</li>
<li>@Index——————————使用@Index作为一个属性来创建一个索引；定义多列索引(@link Entity#indexes())</li>
</ul></li>
<li>关系注解
<ul>
<li>@ToMany——————————定义与多个实体对象的关系</li>
<li>@ToOne——————————定义与另一个实体（一个实体对象）的关系</li>
</ul></li>
<li>@Convert——————————指定自定义类型(@linkPropertyConverter)</li>
<li>@Generated——————————greenDAO运行所产生的构造函数或者方法，被此标注的代码可以变更或者下次运行时清除</li>
<li>@JoinEntity——————————定义表连接关系</li>
<li>@JoinProperty——————————定义名称和引用名称属性关系</li>
<li>@Keep——————————注解的代码段在GreenDao下次运行时保持不变
<ul>
<li>注解实体类：默认禁止修改此类</li>
<li>注解其他代码段，默认禁止修改注解的代码段</li>
</ul></li>
<li>@OrderBy——————————指定排序</li>
</ul>

<h3 id="toc_10">初始化GreenDao</h3>

<p>一般建议在Application中初始化数据库  </p>

<pre><code class="language-java">private void setupDataBase(Context context){
    DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(context,DATA_BASE_NAME);
    Database db = openHelper.getWritableDb();
    DaoMaster daoMaster = new DaoMaster(db);
    mDaoSession = daoMaster.new Session();
}

public static DaoSession getDaoSession(){
    return mDaoSession;
}
</code></pre>

<p><code>DevOpenHelper</code>有两个重载方法：  </p>

<ul>
<li><code>DevOpenHelper(Context context,String name)</code></li>
<li><code>DevOpenHelper(Context context,String name,CursorFactory factory)</code>
<code>context</code>上下文这个不用多说，<code>name</code>数据库的名字，<code>cursorFactory</code>游标工厂，一般不用，传入null或者使用两个参数的方法即可。我们对外提供一个getDaoSession()的方法供外部使用。</li>
</ul>

<h3 id="toc_11">对数据库的增、删、改、查操作</h3>

<h4 id="toc_12">首先获得UserDao的对象</h4>

<p><code>UserDao userDao = GreenDaoManager.getInstance().getNewSession().getUserDao();</code></p>

<h4 id="toc_13">增：</h4>

<pre><code class="language-java">User user = new User(null, name, age, studentId);
userDao.insert(user);
insert(T entity)       当指定主键在表中存在时会发生异常
insertOrReplace(T entity)      当指定主键在表中存在时会覆盖数据
insertInTx(Iterable&lt;T&gt; entities)      批量插入数据
</code></pre>

<h4 id="toc_14">删：</h4>

<pre><code class="language-java">User user = new User(null, name, age, studentId);    
userDao.delete(user)
 
delete(T entity)       删除数据
deleteByKey(K key)     指定主键删除数据
deleteInTx(Iterable&lt;T&gt; entities)      批量删除数据
deleteByKeyInTx(Iterable&lt;K&gt; keys)      批量按数据删除数据        
deleteAll()    删除所有数据
</code></pre>

<h4 id="toc_15">改：</h4>

<pre><code class="language-java">User user = new User(id, name, age, studentId);
userDao.update(user);
 
update(T entity)       修改数据，主键需相同
updateInTx(Iterable&lt;T&gt; entities)      批量更新数据
</code></pre>

<h4 id="toc_16">查：</h4>

<pre><code class="language-java">userDao.load(id)
 
load(K key)    根据id查找数据
loadByRowId(long rowId)        根据行号查找数据
loadAll()      查找全部数据
</code></pre>

<h5 id="toc_17">查询功能</h5>

<p>GreeDAO提供了各种各种的查询API，参见<a href="http://greenrobot.org/greendao/documentation/queries/">http://greenrobot.org/greendao/documentation/queries/</a><br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144856315135.png" alt="20170406149144856315135.png"/></p>

<p>如果需要在控制台查看GreenDao是怎么拼装SQL语句的，在OnCreate()方法中打开下面的开关：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144860095322.png" alt="20170406149144860095322.png"/>  </p>

<h5 id="toc_18">条件查询</h5>

<pre><code class="language-java">//查询所有数据  
public void queryAll() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().list();  
}  
  
//eq: equal 精确查询  名字等于jackie  
public void queryEq() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.eq(&quot;jackie&quot;)).unique();  
}  
  
//notEq: not equal 精确查询  名字不等于jackie  
public void queryNotEq() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.notEq(&quot;jackie&quot;)).unique();  
}  
  
//like  模糊查询  名字以jackie开头  
public void queryLike() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie&quot;)).unique();  
    //通配符  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).list();  
}  
  
//between 区间查询 年龄在20到30之间  
public void queryBetween() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.between(20, 30)).list();  
}  
  
//gt: greater than 半开区间查询，年龄大于18  
public void queryGt() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.gt(18)).list();  
}  
  
//ge: greater equal 半封闭区间查询，年龄大于或者等于18  
public void queryGe() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.ge(18)).list();  
}  
  
//lt: less than 半开区间查询，年龄小于18  
public void queryLt() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.lt(18)).list();  
}  
  
//le: less equal 半封闭区间查询，年龄小于或者等于18  
public void queryLe() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.le(18)).list();  
}  
  
//名字以jackie开头，年龄升序排序  
public void queryLikeAsc() {  
    //通配符  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).orderAsc(PersonDao.Properties.Age).list();  
}  
  
//名字以jackie开头，年龄降序排序  
public void queryLikeDesc() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).orderDesc(PersonDao.Properties.Age).list();  
}  
</code></pre>

<p>当上述查询满足不了业务逻辑时，可以自定义查询语句：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144866729492.png" alt="20170406149144866729492.png"/>  </p>

<h5 id="toc_19">多线程查询</h5>

<p>首先来看错误的方法：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017040614914487051050.png" alt="2017040614914487051050.png"/></p>

<p>错误截图：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017040614914487315508.png" alt="2017040614914487315508.png"/>  </p>

<p>从上面可以看出，只能在创建Query对象的线程中调用查询方法！<br/><br/>
解决方法：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144875721207.png" alt="20170406149144875721207.png"/></p>

<h5 id="toc_20">一对一查询</h5>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144879034921.png" alt="20170406149144879034921.png"/></p>

<h4 id="toc_21">一对一、一对多关系</h4>

<p>greenDAO目前只支持一对一和一对多关系，并不支持多对多关系  </p>

<h5 id="toc_22">一对一：</h5>

<pre><code class="language-java">private Long studentId;
@ToOne(joinProperty = &quot;studentId&quot;)
private Studentstudent;
</code></pre>

<pre><code class="language-java">@Generated(hash = 313494093)
public Student getStudent() {
    Long __key = this.studentId;
    if (student__resolvedKey == null || !student__resolvedKey.equals(__key)) {
        final DaoSession daoSession = this.daoSession;
        if (daoSession == null) {
            throw new DaoException(&quot;Entity is detached from DAO context&quot;);
        }
        StudentDao targetDao = daoSession.getStudentDao();
        Student studentNew = targetDao.load(__key);
        synchronized (this) {
            student = studentNew;
            student__resolvedKey = __key;
        }
    }
    return student;
}
</code></pre>

<p>使用<code>@ToOne</code>标记，<code>joinProperty</code>指定一个字段，如果没有定义，会自动生成一个字段，<code>get</code>方法时自动生成的，使用<code>@Generated</code>标记，代表自动生成的，无需动代码。</p>

<h5 id="toc_23">一对多（有三种映射形式）</h5>

<pre><code class="language-java">@ToMany(referencedJoinProperty = &quot;teacherId&quot;)
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p><code>referencedJoinProperty</code>：指定目标实体中与源实体相对应的外键。</p>

<pre><code class="language-java">@ToMany(joinProperties = {
        @JoinProperty(name=&quot;studentTag&quot;,referencedName = &quot;teacherTag&quot;)
})
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p><code>JoinProperty</code>: 对于复杂一点的关系可以定义一组<code>@JoinProperty</code>注解。每个<code>@JoinProperty</code>注解都需要有源实体中的源属性和对应实体中的引用属性。</p>

<pre><code class="language-java">@ToMany
@JoinEntity(
        entity = Teacher.class,
        sourceProperty = &quot;teacherId&quot;,
        targetProperty = &quot;id&quot;
)
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p>@JoinEntity：在做NM多对多映射的时候使用</p>

<h4 id="toc_24">数据库的升级</h4>

<p>数据库升级最麻烦的就是数据保存的问题，下面是数据库升级时执行的代码。</p>

<pre><code class="language-java">/** WARNING: Drops all table on Upgrade! Use only during development. */
public static class DevOpenHelper extends OpenHelper {
    public DevOpenHelper(Context context, String name) {
        super(context, name);
    }

    public DevOpenHelper(Context context, String name, CursorFactory factory) {
        super(context, name, factory);
    }

    @Override
    public void onUpgrade(Database db, int oldVersion, int newVersion) {
        Log.i(&quot;greenDAO&quot;, &quot;Upgrading schema from version &quot; + oldVersion + &quot; to &quot; + newVersion + &quot; by dropping all tables&quot;);
        dropAllTables(db, true);
        onCreate(db);
    }
}
</code></pre>

<p>第一句注释的话已经告诉我们数据库升级时会删除所有的表，重新创建。所以我们可以自定义一个类继承<code>OpenHelper</code>，在升级时先生成临时表，删除旧表创建新表后，再把临时表的数据导入进去。有牛人已经做出这个项目来了，我就厚颜无耻选择直接用了。</p>

<h5 id="toc_25">在project的gradle添加</h5>

<pre><code class="language-java">allprojects {
    repositories {
        jcenter()
        maven { url &quot;https://jitpack.io&quot; }
    }
}
</code></pre>

<h5 id="toc_26">在app的gradle添加：</h5>

<p><code>compile &#39;com.github.yuweiguocn:GreenDaoUpgradeHelper:v1.3.0&#39;</code></p>

<h5 id="toc_27">新建一个类</h5>

<pre><code class="language-java">public class MySQLiteOpenHelper extends DaoMaster.OpenHelper{
    public MySQLiteOpenHelper(Contextcontext,Stringname){
        super(context,name);
    }
    public MySQLiteOpenHelper(Contextcontext,String name,SQLiteDatabase.CursorFactoryfactory) {
        super(context,name,factory);
    }
    @Override
    public void onUpgrade(SQLiteDatabasedb,int oldVersion,intnewVersion) {
        Log.d(&quot;SQLite&quot;,&quot;数据库从&quot;+oldVersion+&quot;升级到&quot;+newVersion);
        MigrationHelper.migrate(db,UserDao.class,StudentDao.class);
    }
}
</code></pre>

<p>使用时直接用MySQLiteOpenHelper代替DaoMaster.OpenHelper。</p>

<h2 id="toc_28">实战</h2>

<p>下面就以购物车的实战来使用GreenDao，这里的购物车展示图如下<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170406149144890188892.jpg" alt="20170406149144890188892.jpg"/><br/><br/>
我们所知道的数据库操作需要：数据库名、表名、字段名，缺一不可，下面就是这三项的创建  </p>

<h3 id="toc_29">一、创建Bean对象（表名和字段名）</h3>

<p>GreenDao需要创建Bean对象之后，该Bean对象就是表名，而它的属性值就是字段名，其 实现是通过注释的方式来实现的，下面是购物车的Bean对象（每个Bean对象对应一张表）  </p>

<pre><code class="language-java">@Entity
public class Shop{

    //表示为购物车列表
    public static final int TYPE_CART = 0x01;
    //表示为收藏列表
    public static final int TYPE_LOVE = 0x02;

    //不能用int
    @Id(autoincrement = true)
    private Long id;
    //商品名称
    @Unique
    private String name;
    //商品价格
    @Property(nameInDb = &quot;price&quot;)
    private String price;
    //已售数量
    private int sell_num;
    //图标url
    private String image_url;
    //商家地址
    private String address;
    //商品列表类型
    private int type;
}
</code></pre>

<p>之后进行<code>Make Project</code> <br/>
生成<code>Bean</code>实体的构造方法和<code>get</code>、<code>set</code>方法和<code>DaoMaster</code>、<code>DaoSession</code>、<code>DAOS</code>类</p>

<h3 id="toc_30">二、创建数据库</h3>

<pre><code class="language-java">public class BaseApplication extends Application {

    private static DaoSession daoSession;

    @Override
    public void onCreate() {
        super.onCreate();
        //配置数据库
        setupDatabase();
    }

    /**
     * 配置数据库
     */
    private void setupDatabase() {
        //创建数据库shop.db&quot;
        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;shop.db&quot;, null);
        //获取可写数据库
        SQLiteDatabase db = helper.getWritableDatabase();
        //获取数据库对象
        DaoMaster daoMaster = new DaoMaster(db);
        //获取Dao对象管理者
        daoSession = daoMaster.newSession();
    }

    public static DaoSession getDaoInstant() {
        return daoSession;
    }
}
</code></pre>

<p>GreenDao已经将我们的数据库创建缩成几句话，代码会自动将Bean对象创建成表，不再是传统的手写SQL语句。这里的数据库创建只需要在Application中执行一次即可，这里对几个类进行解释  </p>

<ul>
<li><code>DevOpenHelper</code>：创建SQLite数据库的SQLiteOpenHelper的具体实现</li>
<li><code>DaoMaster</code>：GreenDao的顶级对象，作为数据库对象、用于创建表和删除表</li>
<li><code>DaoSession</code>：管理所有的Dao对象，Dao对象中存在着增删改查等API</li>
</ul>

<p>由于我们已经创建好了DaoSession和Shop的Bean对象，编译后会自动生成我们的ShopDao对象，可通过DaoSession获得<br/><br/>
<code>ShopDao dao = daoSession.getShopDao();</code><br/><br/>
这里的Dao（Data Access Object）是指数据访问接口，即提供了数据库操作一些API接口，可通过dao进行增删改查操作。</p>

<h3 id="toc_31">三、数据库的增删改查</h3>

<pre><code class="language-java">public class LoveDao {

    /**
     * 添加数据，如果有重复则覆盖
     *
     * @param shop
     */
    public static void insertLove(Shop shop) {
        BaseApplication.getDaoInstant().getShopDao().insertOrReplace(shop);
    }

    /**
     * 删除数据
     *
     * @param id
     */
    public static void deleteLove(long id) {
        BaseApplication.getDaoInstant().getShopDao().deleteByKey(id);
    }

    /**
     * 更新数据
     *
     * @param shop
     */
    public static void updateLove(Shop shop) {
        BaseApplication.getDaoInstant().getShopDao().update(shop);
    }

    /**
     * 查询条件为Type=TYPE_LOVE的数据
     *
     * @return
     */
    public static List&lt;Shop&gt; queryLove() {
        return BaseApplication.getDaoInstant().getShopDao().queryBuilder().where(ShopDao.Properties.Type.eq(Shop.TYPE_LOVE)).list();
    }

    /**
     * 查询全部数据
     */
    public static List&lt;Shop&gt; queryAll() {
        return BaseApplication.getDaoInstant().getShopDao().loadAll();
    }
}
</code></pre>

<p>GreenDao的封装更加短小精悍，语义明朗，下面对GreenDao中Dao对象其他API的介绍  </p>

<ul>
<li>增加单个数据
<ul>
<li><code>getShopDao().insert(shop);</code></li>
<li><code>getShopDao().insertOrReplace(shop);</code></li>
</ul></li>
<li>增加多个数据
<ul>
<li><code>getShopDao().insertInTx(shopList);</code></li>
<li><code>getShopDao().insertOrReplaceInTx(shopList);</code></li>
</ul></li>
<li>查询全部
<ul>
<li><code>List&lt; Shop&gt; list = getShopDao().loadAll();</code></li>
<li><code>List&lt; Shop&gt; list = getShopDao().queryBuilder().list();</code></li>
</ul></li>
<li>查询附加单个条件
<ul>
<li><code>.where()</code></li>
<li><code>.whereOr()</code></li>
</ul></li>
<li>查询附加多个条件
<ul>
<li><code>.where(, , ,)</code></li>
<li><code>.whereOr(, , ,)</code></li>
</ul></li>
<li>查询附加排序
<ul>
<li><code>.orderDesc()</code></li>
<li><code>.orderAsc()</code></li>
</ul></li>
<li>查询限制当页个数
<ul>
<li><code>.limit()</code></li>
</ul></li>
<li>查询总个数
<ul>
<li><code>.count()</code></li>
</ul></li>
<li>修改单个数据
<ul>
<li><code>getShopDao().update(shop);</code></li>
</ul></li>
<li>修改多个数据
<ul>
<li><code>getShopDao().updateInTx(shopList);</code></li>
</ul></li>
<li>删除单个数据
<ul>
<li><code>getTABUserDao().delete(user);</code></li>
</ul></li>
<li>删除多个数据
<ul>
<li><code>getUserDao().deleteInTx(userList);</code></li>
</ul></li>
<li>删除数据ByKey
<ul>
<li><code>getTABUserDao().deleteByKey();</code></li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/3/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_8.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_10.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15663678647312.html">Docker学习</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15662718181666.html">Android GRPC接入</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15662693410122.html">Docker搭建Maven私服</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15639522586909.html">Kotlin为序列化类生成serialVersionUID</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15620327900428.html">Xposed开发</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
