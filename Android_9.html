<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870778.html">
                
                  <h1>Android-NDK图片高斯模糊</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">CMake</h2>

<p>CMake是一款项目构建工具，通过编写简单明了的在CmakeLists.txt来生成makefile，简单来说就是一个makefile生成器。</p>

<p>在Android Studio中安装CMake非常简单，打开Tools-&gt;Android-&gt;SDK Manager，选择SDK Tools标签页，勾选CMake、LLDB、NDK，OK自动安装即可。其中LLDB可以使我们在Android Studio中调试C/C++程序。NDK为原生开发工具包，必不可少。</p>

<p><figure><img src="media/15561207870778/15713317710825.png" alt=""/></figure></p>

<h2 id="toc_1">为什么要做JNI/NDK开发</h2>

<p>众所周知，Java/Android程序是运行在JVM/Dalvik VM中，所以Java程序远没有C/C++程序性能高，尤其是在CPU密集型运算时，所以Java平台提供了JNI（Java Native Interface），可通过JNI调用C/C++等编写的so动态链接库。</p>

<p><strong>注：Google在Android L以后用ART彻底代替了Dalvik VM，但ART本质上仍是一个虚拟机，并支持所有Dalvik VM指令集。</strong></p>

<p>Java API中几乎所有与硬件相关的方法都是native的，比如I/O操作、网络访问、手机传感器、串口读写等。<br/><br/>
本文涉及的图片处理是一种CPU密集型任务，在Android开发中使用native方法最为合适。</p>

<h2 id="toc_2">如何使用CMake做JNI/NDK开发</h2>

<h3 id="toc_3">新建工程</h3>

<p>选中Include C++ Support，意为引入C++支持。</p>

<h3 id="toc_4">配置C++支持</h3>

<p><figure><img src="media/15561207870778/15713317834823.png" alt=""/></figure></p>

<p>在Customize C++ Support界面默认即可,意为CMake/C++11环境</p>

<h3 id="toc_5">认识CMakeLists.txt</h3>

<p>工程创建完毕之后Android Studio会在app目录下生成CMakeLists.txt文件。CMakeLists.txt是CMake的配置文件，用于表明版本、依赖、等信息，以下为Android Studio生成的CMakeLists（过滤注释）</p>

<pre class="line-numbers"><code class="language-text">cmake_minimum_required(VERSION 3.4.1)

add_library(native-lib SHARED src/main/cpp/native-lib.cpp)

find_library(log-lib log)

target_link_libraries(native-lib ${log-lib})
</code></pre>

<ul>
<li>cmake_minimum_required(VERSION 3.4.1)<br/>
CMake最小版本使用的是3.4.1。</li>
<li>add_library()<br/>
配置so库信息（为当前当前脚本文件添加库）
<ul>
<li>native-lib<br/>
这个是声明引用so库的名称，在项目中，如果需要使用这个so文件，引用的名称就是这个。值得注意的是，实际上生成的so文件名称是libnative-lib。</li>
<li>SHARED<br/>
这个参数表示共享so库文件，也就是在Run项目或者build项目时会在目录intermediates\transforms\mergeJniLibs\debug\folders\2000\1f\main下生成so文件。</li>
<li>src/main/cpp/native-lib.cpp<br/>
构建so库的源文件。</li>
</ul></li>
<li>find_library()查找一个库文件
<ul>
<li>log-lib<br/>
这个指定的是在NDK库中每个类型的库会存放一个特定的位置，而log库存放在log-lib中</li>
<li>log<br/>
指定使用log库</li>
</ul></li>
<li>target_link_libraries()<br/>
如果你本地的库（native-lib）想要调用log库的方法，那么就需要配置这个属性，意思是把NDK库关联到本地库。
<ul>
<li>native-lib<br/>
要被关联的库名称</li>
<li>\({log-lib}  <br/>
要关联的库名称，要用大括号包裹，前面还要有\)符号去引用。</li>
</ul></li>
</ul>

<h3 id="toc_6">了解JNI的C/C++规范</h3>

<h4 id="toc_7">数据类型</h4>

<p>JNI的数据类型包含两种，分别是基本类型和引用类型，它们和Java中的数据类型对应关系如下两表所示。</p>

<h5 id="toc_8">基本数据类型</h5>

<table>
<thead>
<tr>
<th style="text-align: left">JNI类型</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">jboolean</td>
<td style="text-align: center">boolean</td>
<td style="text-align: center">无符号8位整型</td>
</tr>
<tr>
<td style="text-align: left">jbyte</td>
<td style="text-align: center">byte</td>
<td style="text-align: center">无符号8位整型</td>
</tr>
<tr>
<td style="text-align: left">jchar</td>
<td style="text-align: center">char</td>
<td style="text-align: center">无符号16位整型</td>
</tr>
<tr>
<td style="text-align: left">jshort</td>
<td style="text-align: center">short</td>
<td style="text-align: center">有符号16位整型</td>
</tr>
<tr>
<td style="text-align: left">jint</td>
<td style="text-align: center">int</td>
<td style="text-align: center">32位整型</td>
</tr>
<tr>
<td style="text-align: left">jlong</td>
<td style="text-align: center">long</td>
<td style="text-align: center">64位整型</td>
</tr>
<tr>
<td style="text-align: left">jfloat</td>
<td style="text-align: center">float</td>
<td style="text-align: center">32位浮点型</td>
</tr>
<tr>
<td style="text-align: left">jdouble</td>
<td style="text-align: center">double</td>
<td style="text-align: center">64位浮点型</td>
</tr>
<tr>
<td style="text-align: left">void</td>
<td style="text-align: center">void</td>
<td style="text-align: center">无类型</td>
</tr>
</tbody>
</table>

<h5 id="toc_9">引用数据类型</h5>

<table>
<thead>
<tr>
<th style="text-align: left">JNI类型</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">jobject</td>
<td style="text-align: center">Object</td>
<td style="text-align: center">Object类型</td>
</tr>
<tr>
<td style="text-align: left">jclass</td>
<td style="text-align: center">Class</td>
<td style="text-align: center">Class类型</td>
</tr>
<tr>
<td style="text-align: left">jstring</td>
<td style="text-align: center">String</td>
<td style="text-align: center">String类型</td>
</tr>
<tr>
<td style="text-align: left">jobjectArray</td>
<td style="text-align: center">Object[]</td>
<td style="text-align: center">对象数组</td>
</tr>
<tr>
<td style="text-align: left">jbooleanArray</td>
<td style="text-align: center">boolean[]</td>
<td style="text-align: center">boolean数组</td>
</tr>
<tr>
<td style="text-align: left">jbyteArray</td>
<td style="text-align: center">byte[]</td>
<td style="text-align: center">byte数组</td>
</tr>
<tr>
<td style="text-align: left">jcharArray</td>
<td style="text-align: center">char[]</td>
<td style="text-align: center">char数组</td>
</tr>
<tr>
<td style="text-align: left">jshortArray</td>
<td style="text-align: center">short[]</td>
<td style="text-align: center">short数组</td>
</tr>
<tr>
<td style="text-align: left">jintArray</td>
<td style="text-align: center">int[]</td>
<td style="text-align: center">int数组</td>
</tr>
<tr>
<td style="text-align: left">jlongArray</td>
<td style="text-align: center">long[]</td>
<td style="text-align: center">long数组</td>
</tr>
<tr>
<td style="text-align: left">jfloatArray</td>
<td style="text-align: center">float[]</td>
<td style="text-align: center">float数组</td>
</tr>
<tr>
<td style="text-align: left">jdoubleArray</td>
<td style="text-align: center">double[]</td>
<td style="text-align: center">double数组</td>
</tr>
<tr>
<td style="text-align: left">jthrowable</td>
<td style="text-align: center">Throwable</td>
<td style="text-align: center">Throwable</td>
</tr>
</tbody>
</table>

<h4 id="toc_10">JNI的类型签名</h4>

<p>JNI的类型签名标识了一个特定的Java类型，这个类型既可以是类也可以是方法，也可以是数据类型。</p>

<ul>
<li>类的签名比较简单，它采用 L+包名+类型+; 的形式，只需要将其中的.替换为/即可。例如java.lang.String， 它的签名为Ljava/lang/String; ，注意末尾的;也是签名一部分。<br/></li>
<li>基本数据类型的签名采用一系列大写字母来表示, 如下表所示</li>
</ul>

<h5 id="toc_11">基本数据类型的签名</h5>

<table>
<thead>
<tr>
<th style="text-align: left">Java类型</th>
<th style="text-align: center">签名</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">签名</th>
<th style="text-align: center">Java类型</th>
<th style="text-align: center">签名</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">boolean</td>
<td style="text-align: center">Z</td>
<td style="text-align: center">byte</td>
<td style="text-align: center">B</td>
<td style="text-align: center">char</td>
<td style="text-align: center">C</td>
</tr>
<tr>
<td style="text-align: left">short</td>
<td style="text-align: center">S</td>
<td style="text-align: center">int</td>
<td style="text-align: center">I</td>
<td style="text-align: center">long</td>
<td style="text-align: center">J</td>
</tr>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: center">F</td>
<td style="text-align: center">double</td>
<td style="text-align: center">D</td>
<td style="text-align: center">void</td>
<td style="text-align: center">V</td>
</tr>
</tbody>
</table>

<h4 id="toc_12">JNI C/C++函数编写</h4>

<p>先来看看Android Studio为我们生成的示例</p>

<pre class="line-numbers"><code class="language-java">JNIEXPORT jstring JNICALL
Java_com_glee_myapplication_MainActivity_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    std::string hello = &quot;Hello from C++&quot;;
    return env-&gt;NewStringUTF(hello.c_str());
}
</code></pre>

<ul>
<li>JNIEXPORT &amp; JNICALL<br/>
JNIEXPORT和JNICALL这两个宏（被定义在jni.h）确保这个函数在本地库外可见，并且编译器会进行正确的调用转换。</li>
<li>函数规范<br/>
在JNI中C/C++的函数名是有规范要求的，由以下几部分串接而成
<ul>
<li>Java_前缀</li>
<li>完全限定的类名，并用下划线“_”作为分隔符</li>
<li>第一参数JNIEnv* env</li>
<li>第二个参数jobject或jclass</li>
<li>其他参数按类型映射</li>
<li>返回参数按类型映射</li>
</ul></li>
</ul>

<h2 id="toc_13">JNI层操作Bitmap对象</h2>

<h3 id="toc_14">原理</h3>

<p>Android中JNI层处理Bitmap通常有两种方法</p>

<ul>
<li>获取到Bitmap中的byte数组并传入native方法，JNI层处理得到的byte数组后返回一个新的byte数组，Java层重建Bitmap对象。（不推荐）</li>
<li>Java层直接向JNI层传入Bitmap的引用，JNI层得到Bitmap对象的图像数据的地址，直接修改Bitmap的byte数组。</li>
</ul>

<p>阅读了很多篇博客，很多开发者都会采用第一种方法，本人是极不推荐的。这种方法会在内存中重建一个byte数组，会造成内存的浪费，性能低下。<br/><br/>
第二种方法是性能最优的，JNI层充分利用的C/C++指针的特性，直接获取到Bitmap中byte数组在内存中的地址，通过指针直接修改图像数据，所以用到了NDK中的android/bitmap.h。  </p>

<p><strong>android/bitmap.h</strong></p>

<p>android/bitmap.h这个头文件用于在JNI层操作Bitmap对象的，其包含于jnigraphics库中，所以要在CMakeLists.txt中的target_link_libraries加入-ljnigraphics，如下</p>

<p><code>target_link_libraries(native-lib -ljnigraphics ${log-lib})</code></p>

<p><strong>三个常用函数</strong></p>

<ul>
<li>AndroidBitmap_getInfo() 从位图句柄获得信息（宽度、高度、像素格式）</li>
<li>AndroidBitmap_lockPixels() 对像素缓存上锁，即获得该缓存的指针。</li>
<li>AndroidBitmap_unlockPixels() 解锁</li>
</ul>

<h3 id="toc_15">JNI接口函数</h3>

<p>请看注释</p>

<pre class="line-numbers"><code class="language-java">JNIEXPORT void JNICALL
Java_com_glee_ndkroad1006_MainActivity_gaussBlur(JNIEnv *env, jobject /* this */, jobject bmp) {
    AndroidBitmapInfo info = {0};//初始化BitmapInfo结构体
    int *data=NULL;//初始化Bitmap图像数据指针
    AndroidBitmap_getInfo(env, bmp, &amp;info);
    AndroidBitmap_lockPixels(env, bmp, (void **) &amp;data);//锁定Bitmap，并且获得指针
    /**********高斯模糊算法作对int数组进行处理***********/
    //调用gaussBlur函数，把图像数据指针、图片长宽和模糊半径传入
    gaussBlur(data,info.width,info.height,80);
    /****************************************************/
    AndroidBitmap_unlockPixels(env,bmp);//解锁
}
</code></pre>

<p>这里用到的gaussBlur函数代码将在文章最后列出。</p>

<h3 id="toc_16">Java层代码</h3>

<p>请看注释</p>

<pre class="line-numbers"><code class="language-java">public class MainActivity extends AppCompatActivity {

    static {
        //通过静态代码块加载so库
        System.loadLibrary(&quot;native-lib&quot;);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //初始化两个ImageView
        ImageView iv1 = (ImageView) findViewById(R.id.img1);
        ImageView iv2 = (ImageView) findViewById(R.id.img2);
        //iv1设置图片
        iv1.setImageResource(R.drawable.test);
        //生成bitmap对象
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);
        //调用native方法，传入Bitmap对象，对Bitmap进行高斯迷糊处理
        gaussBlur(bitmap);
        //把Bitmap对象设置给iv2
        iv2.setImageBitmap(bitmap);
    }
    //native方法声明
    public native void gaussBlur(Bitmap bitmap);
}
</code></pre>

<h3 id="toc_17">运行效果</h3>

<p>上方的ImageView是没有进行高斯模糊处理的，下方的ImageView调用了JNI方法进行高斯模糊处理。</p>

<p><figure><img src="media/15561207870778/15713317952653.png" alt=""/></figure></p>

<h3 id="toc_18">高斯模糊算法</h3>

<pre class="line-numbers"><code class="language-c">void gaussBlur1(int* pix, int w, int h, int radius)
{
    float sigma = (float) (1.0 * radius / 2.57);
    float deno  = (float) (1.0 / (sigma * sqrt(2.0 * PI)));
    float nume  = (float) (-1.0 / (2.0 * sigma * sigma));
    float* gaussMatrix = (float*)malloc(sizeof(float)* (radius + radius + 1));
    float gaussSum = 0.0;
    for (int i = 0, x = -radius; x &lt;= radius; ++x, ++i)
    {
        float g = (float) (deno * exp(1.0 * nume * x * x));
        gaussMatrix[i] = g;
        gaussSum += g;
    }
    int len = radius + radius + 1;
    for (int i = 0; i &lt; len; ++i)
        gaussMatrix[i] /= gaussSum;
    int* rowData  = (int*)malloc(w * sizeof(int));
    int* listData = (int*)malloc(h * sizeof(int));
    for (int y = 0; y &lt; h; ++y)
    {
        memcpy(rowData, pix + y * w, sizeof(int) * w);
        for (int x = 0; x &lt; w; ++x)
        {
            float r = 0, g = 0, b = 0;
            gaussSum = 0;
            for (int i = -radius; i &lt;= radius; ++i)
            {
                int k = x + i;
                if (0 &lt;= k &amp;&amp; k &lt;= w)
                {
                    //得到像素点的rgb值
                    int color = rowData[k];
                    int cr = (color &amp; 0x00ff0000) &gt;&gt; 16;
                    int cg = (color &amp; 0x0000ff00) &gt;&gt; 8;
                    int cb = (color &amp; 0x000000ff);
                    r += cr * gaussMatrix[i + radius];
                    g += cg * gaussMatrix[i + radius];
                    b += cb * gaussMatrix[i + radius];
                    gaussSum += gaussMatrix[i + radius];
                }
            }
            int cr = (int)(r / gaussSum);
            int cg = (int)(g / gaussSum);
            int cb = (int)(b / gaussSum);
            pix[y * w + x] = cr &lt;&lt; 16 | cg &lt;&lt; 8 | cb | 0xff000000;
        }
    }
    for (int x = 0; x &lt; w; ++x)
    {
        for (int y = 0; y &lt; h; ++y)
            listData[y] = pix[y * w + x];
        for (int y = 0; y &lt; h; ++y)
        {
            float r = 0, g = 0, b = 0;
            gaussSum = 0;
            for (int j = -radius; j &lt;= radius; ++j)
            {
                int k = y + j;
                if (0 &lt;= k &amp;&amp; k &lt;= h)
                {
                    int color = listData[k];
                    int cr = (color &amp; 0x00ff0000) &gt;&gt; 16;
                    int cg = (color &amp; 0x0000ff00) &gt;&gt; 8;
                    int cb = (color &amp; 0x000000ff);
                    r += cr * gaussMatrix[j + radius];
                    g += cg * gaussMatrix[j + radius];
                    b += cb * gaussMatrix[j + radius];
                    gaussSum += gaussMatrix[j + radius];
                }
            }
            int cr = (int)(r / gaussSum);
            int cg = (int)(g / gaussSum);
            int cb = (int)(b / gaussSum);
            pix[y * w + x] = cr &lt;&lt; 16 | cg &lt;&lt; 8 | cb | 0xff000000;
        }
    }
    free(gaussMatrix);
    free(rowData);
    free(listData);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870710.html">
                
                  <h1>Android-AppBarLayout</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Toolbar</h2>

<p>Toobar主要是用来替换ActionBar的，换句话说，ActionBar能做的，Toolbar都能做。如果你对ActionBar的使用比较熟悉，你会发现Toolbar使用起来非常简单。ok，既然是替换，当然用Toolbar的时候就得先去把ActionBar给隐藏掉啦~</p>

<p>隐藏ActionBar的方法有很多，可以通过代码的方式隐藏，也可以通过配置文件的方式，我们主要是通过配置文件的方式来隐藏。在我们的styles.xml文件中的AppTheme标签中加入如下两行：</p>

<pre class="line-numbers"><code class="language-markup">&lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
&lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
</code></pre>

<p>当然了，你也可以新建一个<code>&lt;style&gt;</code>标签，将上面两行代码加入，并且将这个新建的标签作为<code>&lt;application&gt;</code>的<code>theme</code>。还可以选择通过将<code>AppTheme</code>的<code>parent</code>设置为<code>Theme.AppCompat.Light.NoActionBar</code>的方式。方法很多，可以自己随便选。</p>

<p>接下来就是将Toolbar放入到布局文件（没啥好解释的）：</p>

<pre class="line-numbers"><code class="language-markup">  &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:background=&quot;?attr/colorPrimary&quot;
        android:layout_height=&quot;?android:attr/actionBarSize&quot;  /&gt;
</code></pre>

<p>最后将Toobar作为“ActionBar”来用</p>

<pre class="line-numbers"><code class="language-java"> Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        toolbar.setTitle(&quot;这里是Title&quot;);
        toolbar.setSubtitle(&quot;这里是子标题&quot;);
        toolbar.setLogo(R.drawable.icon); 
        setSupportActionBar(toolbar);
</code></pre>

<p>可以对Toolbar设置Logo、标题、子标题等等~还有很多其他的设置，自己去慢慢玩，这里不提啦~。当然了，也可以在布局文件中设置这些，在布局文件设置就不写啦，hongyang大神有篇博客写的挺好的<a href="http://blog.csdn.net/lmj623565791/article/details/45303349">《 Android 5.x Theme 与 ToolBar 实战 》</a>可以去参考一下。</p>

<p>如果Toolbar仅仅是用来对以往的ActionBar做一次替换，那也太没创意啦！完全没必要去替换了，因为它们表现出来的都是一样的，而且并没有让我们觉得用起来比ActionBar方便。那为啥要替换呢，总应该有他的理由吧：ActionBar是固定在顶部，并不能移动，我觉得这是最大的不好，而我们的ToolBar可以让我们随便摆放，就就可以带来很多灵活性和效果啦！</p>

<p>正如你所看的这样，Toolbar根本就不够看的，一点都不复杂。接下来我们继续学习在Toolbar上面再套一层父View，让Toolbar更有互动性。</p>

<h2 id="toc_1">AppBarLayout</h2>

<blockquote>
<p>AppBarLayout继承自LinearLayout，布局方向为垂直方向。所以你可以把它当成垂直布局的LinearLayout来使用。AppBarLayout是在LinearLayou上加了一些材料设计的概念，它可以让你定制当<strong>某个可滚动View</strong>的滚动手势发生变化时，其内部的子View实现何种动作。</p>
</blockquote>

<p>请注意：上面提到的<strong>某个可滚动View</strong>，可以理解为某个ScrollView。怎么理解上面的话呢？就是说，当某个ScrollView发生滚动时，你可以定制你的“顶部栏”应该执行哪些动作（如跟着一起滚动、保持不动等等）。那某个可移动的View到底是哪个可移动的View呢？这是由你自己指定的！如何指定，我们后面说。</p>

<h3 id="toc_2">AppBarLayout子View的动作</h3>

<p>内部的子View通过在布局中加<code>app:layout_scrollFlags</code>设置执行的动作，那么<code>app:layout_scrollFlags</code>可以设置哪些动作呢？分别如下：</p>

<blockquote>
<p>（1） scroll:值设为scroll的View会跟随滚动事件一起发生移动。</p>
</blockquote>

<p>什么意思呢？简单的说，就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。</p>

<p>一张gif足以说明：</p>

<p><figure><img src="media/15561207870710/20171014150799488071606.gif" alt=""/></figure></p>

<p>对应的布局文件</p>

<pre class="line-numbers"><code class="language-markup">&lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            android:id=&quot;@+id/toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;?android:attr/actionBarSize&quot;
            android:background=&quot;?attr/colorPrimary&quot;
            app:layout_scrollFlags=&quot;scroll&quot; /&gt;
&lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<blockquote>
<p>（2） enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。</p>
</blockquote>

<p>看个动画片（Y(<sup>o<sup>)Y）（ToolBar高度设为：<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enterAlways&quot;</code>）：</sup></sup></p>

<p><figure><img src="media/15561207870710/20171014150799493830006.gif" alt=""/></figure></p>

<blockquote>
<p>（3） <code>exitUntilCollapsed</code>：值设为<code>exitUntilCollapsed</code>的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。</p>
</blockquote>

<p>怎么理解呢？简单解释：在ScrollView往上滑动时，首先是View把滑动事件“夺走”，由View去执行滑动，直到滑动最小高度后，把这个滑动事件“还”回去，让ScrollView内部去上滑。看个gif感受一下（图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;</code>）：</p>

<p><figure><img src="media/15561207870710/20171014150799499853731.gif" alt=""/></figure></p>

<blockquote>
<p>（4） <code>enterAlwaysCollapsed</code>：是<code>enterAlways</code>的附加选项，一般跟<code>enterAlways</code>一起使用，它是指，View在往下“出现”的时候，首先是<code>enterAlways</code>效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。<br/>
来个gif感受一下（图中将高度设的比较大:200dp，并将最小高度设置为<code>?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enerAlways|enterAlwaysCollapsed&quot;</code>）：</p>
</blockquote>

<p><figure><img src="media/15561207870710/20171014150799505696205.gif" alt=""/></figure></p>

<h3 id="toc_3">将AppBarLayout与ScrollView关联起来</h3>

<p>前面说了一直反复说“当ScrollView发生滚动时”，那么怎么将AppBarLayout与ScrollView关联起来呢？我们注意到，AppBarLayout与ScrollView之间动作“相互依赖”，这不就是我们上一篇<a href="http://blog.csdn.net/huachao1001/article/details/51554608">《CoordinateLayout的使用如此简单 》</a>所学的内容吗？把ScrollView和AppBarLayout作为CoordinateLayout的子View，然后编写一个Behavior，在这个Behavior里面判断当前的操作是应该让ScrollView时刻保持在AppBarLayout之下（即只要改变AppBarLayout的位置就可以一起滑动），还是应该让ScrollView内部滚动而不让AppBarLayout位置发生变化等等这些需求，都是可以在Behavior里面处理的。你可以去针对你的ScrollView编写Behavior。然而，我们看到我们的AppBarLayout事先的功能比较复杂，如果我们自己去定义这样的效果，代码非常复杂，还要考虑很多方面，好在Android帮我们写好啦，我们直接用就是了，这个ScrollView就是NestedScrollView，请注意，它并没有继承ScrollView，它继承的是FrameLayout，但是它实现的效果把它可以看成是ScrollView。</p>

<p>把NestedScrollView放入到我们的layout文件里面就可以啦~~~，很方便~</p>

<pre class="line-numbers"><code class="language-markup"> &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

       &lt;!--将你的内容放在这里--&gt;

&lt;/android.support.v4.widget.NestedScrollView&gt;
</code></pre>

<p>有没有注意到有个属性：<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code>,它就是指定Behavior的，<code>appbar_scrolling_view_behavior</code>对应的类的名称是：<code>android.support.design.widget.AppBarLayout$ScrollingViewBehavior</code>感兴趣的可以去分析源码。</p>

<p>好了，我们现在会用AppBarLayout啦~是不是发现用起来so easy!接下来我们把剩下<code>CollapsingToolbarLayout</code>的给&quot;消化&quot;掉！</p>

<h2 id="toc_4">CollapsingToolbarLayout</h2>

<p>CollapsingToolbarLayout是用来对Toolbar进行再次包装的ViewGroup，主要是用于实现折叠（其实就是看起来像伸缩~）的App Bar效果。它需要放在AppBarLayout布局里面，并且作为AppBarLayout的直接子View。CollapsingToolbarLayout主要包括几个功能（参照了官方网站上内容，略加自己的理解进行解释）：</p>

<blockquote>
<p>(1) 折叠Title（Collapsing title）：当布局内容全部显示出来时，title是最大的，但是随着View逐步移出屏幕顶部，title变得越来越小。你可以通过调用<code>setTitle</code>函数来设置title。  </p>

<p>(2)内容纱布（Content scrim）：根据滚动的位置是否到达一个阀值，来决定是否对View“盖上纱布”。可以通过<code>setContentScrim(Drawable)</code>来设置纱布的图片.  </p>

<p>(3)状态栏纱布（Status bar scrim)：根据滚动位置是否到达一个阀值决定是否对状态栏“盖上纱布”，你可以通过<code>setStatusBarScrim(Drawable)</code>来设置纱布图片，但是只能在LOLLIPOP设备上面有作用。  </p>

<p>(4)视差滚动子<code>View(Parallax scrolling children)</code>:子View可以选择在当前的布局当时是否以“视差”的方式来跟随滚动。<strong>（PS:其实就是让这个View的滚动的速度比其他正常滚动的View速度稍微慢一点）</strong>。将布局参数<code>app:layout_collapseMode</code>设为<code>parallax</code> </p>

<p>(5)将子View位置固定(Pinned position children)：子View可以选择是否在全局空间上固定位置，这对于Toolbar来说非常有用，因为当布局在移动时，可以将Toolbar固定位置而不受移动的影响。 将app:layout_collapseMode设为pin。</p>
</blockquote>

<p>了解这些概念后，我们来看看布局吧~</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;


    &lt;android.support.design.widget.AppBarLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.design.widget.CollapsingToolbarLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            app:expandedTitleMarginEnd=&quot;64dp&quot;
            app:expandedTitleMarginStart=&quot;48dp&quot;
            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/main.backdrop&quot;
                android:layout_width=&quot;wrap_content&quot;
                android:layout_height=&quot;300dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/material_img&quot;
                app:layout_collapseMode=&quot;parallax&quot; /&gt;

            &lt;android.support.v7.widget.Toolbar
                android:id=&quot;@+id/toolbar&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;?android:attr/actionBarSize&quot;
                app:layout_collapseMode=&quot;pin&quot;  /&gt;

        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
    &lt;/android.support.design.widget.AppBarLayout&gt;

    &lt;android.support.v4.widget.NestedScrollView

        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingTop=&quot;50dp&quot;
        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@string/my_txt&quot;
            android:textSize=&quot;20sp&quot; /&gt;

    &lt;/android.support.v4.widget.NestedScrollView&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>

<p>上面的都看得懂吧，每个陌生的属性都是讲过的哦，忘记了的话回头看，稍微解释一下，图片被设置为有视差的滑动，Toolbar设置为固定不动，另外，CollapsingToolbarLayout会对title进行放大和缩小，我们看看效果吧~</p>

<p><figure><img src="media/15561207870710/20171014150799532425417.gif" alt=""/></figure></p>

<p>如果你希望拖动过程中状态栏是透明的，可以在<code>CollapsingToolbarLayout</code>中加 <code>app:statusBarScrim=&quot;@android:color/transparent</code>&quot;，并且在onCreate中调用<code>getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)</code>将状态栏设置为透明就好啦~</p>

<p>献上<a href="http://download.csdn.net/detail/huachao1001/9538934">源码</a></p>

<h2 id="toc_5">AppBarLayout的ScrollFlags属性</h2>

<p>在前面两篇MD系列的文章中，通过两个案例基本上能够掌握了CoordinatorLayout与AppBarLayout的配合使用。本文我们回过头来详细聊聊AppBarLayout的ScrollFlags属性，了解一下不同值之间的区别。至此，Android Material Design系列的学习已进行到第七篇，大家可以点击以下链接查看之前的文章：</p>

<ul>
<li><a href="http://www.jianshu.com/p/39a66373498c">Android TabLayout 分分钟打造一个滑动标签页</a></li>
<li><a href="http://www.jianshu.com/p/9eb3b17b0e77">Android 一文告诉你到底是用Dialog，Snackbar，还是Toast</a></li>
<li><a href="http://www.jianshu.com/p/5328b2eee827">Android FloatingActionButton 重要的操作不要太多，一个就好</a></li>
<li><a href="http://www.jianshu.com/p/ab04627cce58">Android 初识AppBarLayout 和 CoordinatorLayout</a></li>
<li><a href="http://www.jianshu.com/p/4b0f3c80ebc9">Android CoordinatorLayout实战案例学习《一》</a></li>
<li><a href="http://www.jianshu.com/p/360fd368936d">Android CoordinatorLayout 实战案例学习《二》</a></li>
</ul>

<p>ScrollFlags共有五种常量值供AppBarLayout的Children View使用，在xml布局文件中通过<code>app:layout_scrollFlags</code>设置，对应的值为：scroll，enterAlways，enterAlwaysCollapsed，snap，exitUntilCollapsed；也可以在代码中通过<code>setScrollFlags(int)</code>方法使用，比如：</p>

<pre class="line-numbers"><code class="language-java">Toolbar toolbar = ... // your toolbar within an AppBarLayout
AppBarLayout.LayoutParams params = 
    (AppBarLayout.LayoutParams) toolbar.getLayoutParams();
params.setScrollFlags(AppBarLayout.LayoutParams.SCROLL_FLAG_SCROLL
    | AppBarLayout.LayoutParams.SCROLL_FLAG_ENTER_ALWAYS);
</code></pre>

<p>下面我们通过官网介绍、XML代码和对应的效果图分别分析这五种值的使用（备注：代码中设置也一样，不再赘述）：</p>

<h3 id="toc_6">scroll</h3>

<blockquote>
<p>The view will be scroll in direct relation to scroll events. This flag needs to be set for any of the other flags to take effect. If any sibling views before this one do not have this flag, then this value has no effect.</p>
</blockquote>

<p>Child View 伴随着滚动事件而滚出或滚进屏幕。注意两点：第一点，如果使用了其他值，必定要使用这个值才能起作用；第二点：如果在这个child View前面的任何其他Child View没有设置这个值，那么这个Child View的设置将失去作用。</p>

<p>示例XML代码：</p>

<pre class="line-numbers"><code class="language-markup">    &lt;android.support.design.widget.AppBarLayout
        android:id=&quot;@+id/appbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;

        &lt;android.support.v7.widget.Toolbar
            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
            android:id=&quot;@+id/tb_toolbar&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;@dimen/dp_56&quot;
            app:titleTextColor=&quot;@color/white&quot;
            app:title=&quot;@string/app_name&quot;
            app:theme=&quot;@style/OverFlowMenuTheme&quot;
            app:popupTheme=&quot;@style/AppTheme&quot;
            android:background=&quot;@color/blue&quot;
            app:layout_scrollFlags=&quot;scroll|enterAlways&quot;/&gt;

    &lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842247229844.gif" alt=""/></figure></p>

<h3 id="toc_7">enterAlways</h3>

<blockquote>
<p>When entering (scrolling on screen) the view will scroll on any downwards scroll event, regardless of whether the scrolling view is also scrolling. This is commonly referred to as the &#39;quick return&#39; pattern.</p>
</blockquote>

<p>快速返回模式。其实就是向下滚动时Scrolling View和Child View之间的滚动优先级问题。对比<code>scroll</code>和<code>scroll | enterAlways</code>设置，发生向下滚动事件时，前者优先滚动Scrolling View，后者优先滚动Child View，当优先滚动的一方已经全部滚进屏幕之后，另一方才开始滚动。</p>

<p>示例XML代码：</p>

<pre class="line-numbers"><code class="language-java">...
app:layout_scrollFlags=&quot;scroll|enterAlways&quot;
...

</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842251698266.gif" alt=""/></figure></p>

<h3 id="toc_8">enterAlwaysCollapsed</h3>

<blockquote>
<p>An additional flag for &#39;enterAlways&#39; which modifies the returning view to only initially scroll back to it&#39;s collapsed height. Once the scrolling view has reached the end of it&#39;s scroll range, the remainder of this view will be scrolled into view. The collapsed height is defined by the view&#39;s minimum height.</p>
</blockquote>

<p>enterAlways的附加值。这里涉及到Child View的高度和最小高度，向下滚动时，Child View先向下滚动最小高度值，然后Scrolling View开始滚动，到达边界时，Child View再向下滚动，直至显示完全。</p>

<p>示例XML代码：</p>

<pre class="line-numbers"><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
android:minHeight=&quot;@dimen/dp_56&quot;
...
app:layout_scrollFlags=&quot;scroll|enterAlways|enterAlwaysCollapsed&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842256217688.gif" alt=""/></figure></p>

<h3 id="toc_9">exitUntilCollapsed</h3>

<blockquote>
<p>When exiting (scrolling off screen) the view will be scrolled until it is &#39;collapsed&#39;. The collapsed height is defined by the view&#39;s minimum height.</p>
</blockquote>

<p>这里也涉及到最小高度。发生向上滚动事件时，Child View向上滚动退出直至最小高度，然后Scrolling View开始滚动。也就是，Child View不会完全退出屏幕。</p>

<p>示例SML代码：</p>

<pre class="line-numbers"><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
android:minHeight=&quot;@dimen/dp_56&quot;
...
app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842260265572.gif" alt=""/></figure></p>

<h3 id="toc_10">snap</h3>

<blockquote>
<p>Upon a scroll ending, if the view is only partially visible then it will be snapped and scrolled to it&#39;s closest edge. For example, if the view only has it&#39;s bottom 25% displayed, it will be scrolled off screen completely. Conversely, if it&#39;s bottom 75% is visible then it will be scrolled fully into view.</p>
</blockquote>

<p>简单理解，就是Child View滚动比例的一个吸附效果。也就是说，Child View不会存在局部显示的情况，滚动Child View的部分高度，当我们松开手指时，Child View要么向上全部滚出屏幕，要么向下全部滚进屏幕，有点类似ViewPager的左右滑动。</p>

<p>示例XML代码：</p>

<pre class="line-numbers"><code class="language-markup">...
android:layout_height=&quot;@dimen/dp_200&quot;
...
app:layout_scrollFlags=&quot;scroll|snap&quot;
...
</code></pre>

<p>对应效果图：</p>

<p><figure><img src="media/15561207870710/20171019150842265497458.gif" alt=""/></figure></p>

<h3 id="toc_11">示例源码</h3>

<p>我在GitHub上建立了一个Repository，用来存放整个Android Material Design系列控件的学习案例，会伴随着文章逐渐更新完善，欢迎大家补充交流，Star地址：</p>

<p><a href="https://github.com/Mike-bel/MDStudySamples">https://github.com/Mike-bel/MDStudySamples</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870673.html">
                
                  <h1>Android-Debug</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、 进入 debug 模式的两种姿势</h2>

<p>第一种是点击运行按钮旁边的“绿色甲虫”(debug app)开始以调试模式编译运行。</p>

<p><figure><img src="media/15561207870673/15713320071550.png" alt=""/></figure></p>

<p>这个方式的特点是，一开始就进入了调试模式。适合希望尽早进入调试模式的场景，比如你想从头开始追踪问题，或者断点在启动页或首页之类的。它的弊端是每次需要从头跑一遍，且由于调试模式下应用程序略卡顿，等你到达调试页面时会觉得老费劲。</p>

<p><figure><img src="media/15561207870673/15713320153903.png" alt=""/></figure></p>

<p>第二种方式是在手机或模拟器已经跑起来应用程序后点击 <code>Run</code> -&gt; <code>Attach debugger to Android process</code>，选择应用程序主进程，即可进入调试模式。</p>

<p>这种方式的特点是，随时随地自由进入调试模式，不需要重头开始跑应用程序，该方式适合绝大多数调试场景。需要注意的是，假如跑的是 <code>release</code> 版本且有混淆加固之类的话，该方式就无法正常调试。</p>

<h2 id="toc_1">二、 常见的调试操作</h2>

<h3 id="toc_2">1 典型的调试场景</h3>

<p>一个最常见的调试场景如下：</p>

<ol>
<li>完成包括打开 Android Studio、打开需要调试的类、连接手机等准备工作</li>
<li>在关键位置打上普通断点，进入调试模式后触发断点，将当前线程阻塞在断点处</li>
<li>单步调试，一行一行往下运行</li>
<li>碰到方法调用时进入方法内部</li>
<li>用单步调试单步执行直到该方法结束回到方法调用的下一行，或者直接退出当前方法</li>
<li>通过观察观察区的相关变量，推断出问题所在，结束本次调试</li>
</ol>

<p>以上是最常规的 debug 场景，下面介绍下调试界面。</p>

<p><figure><img src="media/15561207870673/15713320235325.png" alt=""/></figure></p>

<p>在 Android Studio 的 debug 标签（假如一开始没有，等触发断点后自然会出现）中有两个面板 debugger 和 console。debugger 又分为 Frames、Threads 和 Variables 三块，分别是堆栈内容、线程、变量区。</p>

<p>在 debugger 标签右边有一些操作按钮，是我们常用的调试操作，下面会一一介绍。（可以用鼠标悬停在上面看每个按钮的具体名称）</p>

<h3 id="toc_3">2 设置断点</h3>

<p>断点有多种类型，我们这里先只谈普通断点。在每行的最前端单击一下即可<strong>添加断点</strong>，在断点上单击一下是<strong>取消断点</strong>。普通模式下断点只是一个普通的红点，但假如是在调试模式下，则红点上会有一个“√”或“✘”表示该行是否会被运行，例如，注释行前的断点会是“✘”。</p>

<p><figure><img src="media/15561207870673/15713320307577.png" alt=""/></figure></p>

<p>不管怎样，触发断点肯定是调试的起点。只有触发了断点，才会开始阻塞线程（注意是只会阻塞当前线程，这个后面会扩展一下详细介绍），此时当前代码行会被蓝色高亮，观察面板上的变量也会显示当前环境下的值。</p>

<h3 id="toc_4">3 跳到下一个断点（F9）</h3>

<p>一般情况下，在调试时我们可以根据我们的经验在几个关键的位置打上断点，这里就需要从一个断点直接跳到下一个断点。操作是继续以 debug 模式运行，快捷键是 F9（假如没改动的话应该都是这个快捷键，假如不同，可以把鼠标悬浮在该图标上看提示，下同）。</p>

<h3 id="toc_5">4 单步调试（F8）</h3>

<p>触发断点后，我们当然可以通过加 N 个断点来定位问题，但在较复杂的场景里可能没法判断出关键点。这时可以在比较靠前的位置添加断点作为起点，一行一行执行。操作是单步调试，快捷键是 F8。</p>

<h3 id="toc_6">5 进入方法内部（F7）</h3>

<p>在单步调试时方法调用语句会被看做一行，那么如何进入方法内部呢？用“进入内部”操作，快捷键是 F7.</p>

<h3 id="toc_7">6 退出当前方法（上档键+F8）</h3>

<p>既然有进入方法内部，就有退出当前方法的操作。当进入某个方法内部后觉得该方法后面的代码不需要看了，不需要猛按 F8 让它们跑完，可以直接退出当前方法去到该方法调用处的下一行。</p>

<p>有了这些操作，基本可以应付常见的 80% 的调试场景了。但仅仅了解这些，在面对复杂场景时难免效率低下。下面介绍几种非常高效的断点。</p>

<h2 id="toc_8">三、 几种高效断点</h2>

<h3 id="toc_9">1 条件成立时才触发的条件断点</h3>

<p>普通断点在每次运行到时都会被触发，这在多次调用、有“循环”的场景会比较麻烦，比如循环 100 次只希望停留在第 98 次。那么此刻就可以用上条件断点了。</p>

<p>添加条件断点：先在需要的行前左键单击添加普通断点，右键点击该断点出现对话框，在“Condition”处填入条件即可，条件语法同 Java，如 i == 98。点击 Done，完成添加。这样当条件未满足时，不会阻塞程序运行；当条件满足时断点被触发。</p>

<p><figure><img src="media/15561207870673/15713320404295.png" alt=""/></figure></p>

<h3 id="toc_10">2 不会阻塞应用程序的日志断点</h3>

<p>有时候我们仅仅希望在关键时刻输出一些 log，那么我们需要做这些工作：</p>

<ol>
<li>在代码里加上 log 代码</li>
<li>重新运行程序</li>
<li>重新触发断点</li>
</ol>

<p>那么有没有什么方法可以避免这些繁杂的操作呢？这时可以试试日志断点。</p>

<p>在条件断点弹出的对话框里，将“suspend”设置为未选中状态，断点触发时就不会被阻塞。此时对话框会多出一些选项。</p>

<p><figure><img src="media/15561207870673/15713320484306.png" alt=""/></figure></p>

<p>我们选中“Evaluated and log”，并在里面填写希望输出的日志，点击 Done 即可。注意，日志将输出到 Console 而非 LogCat。</p>

<h3 id="toc_11">3 被异常触发的异常断点</h3>

<p>我们做 debug，一般面对的都是未崩溃的异常，例如 UI 状态不对、数值不对、代码执行逻辑不对等等。碰到直接 crash 的情况，我们往往不会去 debug，而是根据报错信息定位到某某行，然后解决问题。最典型的就是空指针异常了，只要看到报错位置，基本手到擒来。</p>

<p>但日常开发难免碰到一些给出具体信息和抛异常的位置也没有头绪或者未给出具体位置的情况，比如某 API 抛了个状态异常，那么我们可能得去琢磨为何会状态不对。</p>

<p>这时还是得调试，但我们也不能眼睁睁看着抛出的异常让应用程序崩了，可以用上“异常断点”。</p>

<p>我们打开断点管理器，可以看到有一类是“Java Exception Breakpoints”，直接勾上是所有异常都会被触发。</p>

<p>假如只想被某种异常触发，我们可以点击“+”，选中“Java Exception Breakpoints”，然后输出该种异常即可。</p>

<p><figure><img src="media/15561207870673/15713320567239.png" alt=""/></figure></p>

<p>有朋友可能注意到除了 “Java Exception Breakpoints” 外还有一个 “Exception Breakpoints”，两者区别主要是前者只支持 Java 本身的异常，后者可以支持自定义异常。</p>

<h3 id="toc_12">4 追踪关键点的字段断点和方法断点</h3>

<p>在诸如多线程等复杂场景下，超多的变量和超多的类再加上一些 native 方法和第三方库，调试的复杂度也直线上升。</p>

<p><strong>这时可以尝试以点破面，抓住关键方法或字段来追踪应用程序的运行轨迹。</strong>于是关注某字段的字段断点和关注某方法的方法断点就派上用场了。</p>

<p>顾名思义，字段断点的触发条件是字段值被更改，方法断点是方法被调用。</p>

<p>添加方式：在字段那行、在方法声明的那行单击即可。</p>

<p><figure><img src="media/15561207870673/15713320679940.png" alt=""/></figure></p>

<h3 id="toc_13">5 注意事项</h3>

<p>除了以上这些，还有其他断点未列出来，比如临时断点等。考虑到这类断点实用性不强，就不多加说明，有需求的朋友自然会去了解。</p>

<p><strong>需要说明的是，给断点命名只是为了方便交流，各类型之间并没有特别边界。</strong> 实际上，断点只是某些操作的集合而已。比如日志断点是“不阻塞”和“输出日志”两个操作的集合，那么我们当然可以加上“设置条件”操作变成“条件日志断点”，诸如此类。我们设置断点的面板是允许我们将多种断点条件混合使用的。</p>

<p>所以，<strong>断点名称和类型不重要，重要的是针对现场选用合适的操作。</strong></p>

<h2 id="toc_14">四 调试中的变量</h2>

<p>在设置了合适的断点后，我们就可以进行下一步操作 —— 观察变量，准确的说是观察变量的值。</p>

<h3 id="toc_15">1 变量观测面板</h3>

<p>众所周知，应用程序在运行期间元素都处于一种动态状态，此刻你是无法观测到具体变量的值的。只有当动态变成静态，即阻塞住应用程序，才能开始变量观测。</p>

<p>这个“阻塞”操作也就是上文提到的断点触发。</p>

<p>这里需要特别指出的是，当需要追踪某一个特定变量时，字段断点是一大利器。</p>

<p><figure><img src="media/15561207870673/15713320794441.png" alt=""/></figure></p>

<p>如上图所示，变量观察面板会列出所有当前能访问到的成员变量和局部变量。</p>

<p>点击变量前的箭头，可以将该实例展开，列出所有字段。</p>

<h3 id="toc_16">2 Add New Watch</h3>

<p>将所有变量、所有字段列出来是比较直观，但当我们要去获取某些属性时就略蛋疼了。</p>

<p>比如，获取某成员变量 View 的第一个 <code>child</code> 的 <code>measuredHeight</code>。假如是靠手动去一个个“打开”属性列表，拿得多麻烦。</p>

<p>又比如，我们需要获取到两个属性相加后占另一个值的百分比。先去找到这两个属性的值然后额外拿计算器计算？</p>

<p>这时就可以用上 “Add New Watch”了，添加一个观察表达式。通俗点就是在变量观测区执行一个表达式并得到它的值。</p>

<p>在面试左侧点击绿色“+”，或者点击右键在菜单中选择“New Watch”, 就会出现一个框，输入表达式即可。</p>

<p>举个例子：</p>

<p>在示例中输入<code>toolbar.getChildAt(0).getMeasuredHeight()</code>，可得到如图的结果。</p>

<p><figure><img src="media/15561207870673/15713320865126.png" alt=""/></figure></p>

<h3 id="toc_17">3 设置变量的值</h3>

<p><strong>变量的值除了能被观察外，还可以在运行时改变。</strong> 这个可以说是超酷的黑科技了。试想，碰到一个 <code>if else</code> 时，我们可以很轻松无成本地通过更改变量的值，让应用程序能跑到我们期望的分支上。</p>

<p>设置变量的值有两种方式：方式一是在变量观测区右键单击变量，在菜单中选中“set value”；方式二是鼠标悬浮在代码区中的某个可访问的变量上，在弹出的浮层里更改值。</p>

<p><figure><img src="media/15561207870673/15713320950169.png" alt=""/></figure></p>

<h2 id="toc_18">五 犀利的小功能</h2>

<p>除了以上那些常规的操作，还有一些“还有这种操作”的小功能。</p>

<h3 id="toc_19">1 Force Run to Cursor</h3>

<p>该操作可以忽视已存在的断点，直接跳到光标所在的行。有种脱离断点、繁琐操作的束缚轻松自由的感觉有木有。</p>

<h3 id="toc_20">2 Drop frame</h3>

<p>经过不懈努力，终于快到出错的那个时刻啦，你眉飞色舞手指按得飞快，结果小手一抖，多按了几个 F8 （单步调试快捷键），错过了出错的那个时刻。<strong>如果能回退到方法执行前？</strong></p>

<p>Drop frame 功能能让你回到当前方法被调用的地方，并且当前上下文所有变量也都恢复到方法调用前 —— 时光回溯有木有？</p>

<p><strong>当然别太兴奋，由于 DalvikVM 和 Android Runtime (ART) 不支持，大部分情况下你是用不到的，那个按钮长期处于不可点击状态。</strong>但如果你是在跑 JUnit 测试的话，是可以用上的。</p>

<h3 id="toc_21">3 Log</h3>

<p>在多线程环境下，光靠 debug 是不行的。有时 debug 本身会带来一些问题混淆了现场，比如因为 debug 时的卡顿造成环境不一致等等，这时应该学会使用打日志的形式帮忙调试。</p>

<h3 id="toc_22">4 布局查看器</h3>

<p>在 Android Studio 的 Android Device Monitor 里有一个 “Dump View Hierarchy for UI Automator” 功能，可以看到当前手机上应用的具体布局情况 —— 甚至布局元素的属性都会一一给出（仅可用于可调试的应用）。对 UI 调试非常有帮助。</p>

<p><figure><img src="media/15561207870673/15713321037475.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870639.html">
                
                  <h1>Android-组件化学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>网上关于组件化的文章有很多了，大部分都知道实现的思路，不过还是要自己去实践一下才会发现问题。文章的<a href="https://github.com/zj-wukewei/ModularizationExample">项目地址</a>，项目用到CleanArchitecture框架，本文会介绍CleanArchitecture框架和dagger2在组件化的使用。</p>

<h2 id="toc_0">项目关系图</h2>

<p><figure><img src="media/15561207870639/15713321165510.png" alt=""/></figure></p>

<ul>
<li>sdk: 一些公用库，各种辅助类，和第三方view</li>
<li>basic: (依赖sdk) 网络访问初始化，本地缓存和第三方包等。</li>
<li>commonbusiness: (依赖basic) 这里为什么我会多出这一层，因为有很多公共的业务，好比公司的app是强登录的，我会把登录模块写在这里，里面也包含了一些baseActivity和BaseApplication和各个组件的一些公共方法还有组件各种的服务接口的定义。</li>
<li>module_archives和module_knowledge： 就是两个组件，可以单独运行。</li>
</ul>

<h2 id="toc_1">application和library切换</h2>

<p>想必大家都知道了，定义一个isBuildModule=false，在组件的build.gradle中加入</p>

<pre class="line-numbers"><code class="language-java">if (isBuildModule.toBoolean()) {
    apply plugin: &#39;com.android.application&#39;
} else {
    apply plugin: &#39;com.android.library&#39;
    apply from: &#39;maven-release-kline-aar.gradle&#39;
}

 sourceSets {
        main {
            if (isBuildModule.toBoolean()) {
                manifest.srcFile &#39;src/main/debug/AndroidManifest.xml&#39;
            } else {
                manifest.srcFile &#39;src/main/release/AndroidManifest.xml&#39;
                java {
                    exclude &#39;**/debug/**&#39;
                }
            }
        }
    }
</code></pre>

<p>maven-release-kline-aar.gradle是一个打包aar的文件，在切换的时候也会使用不同的AndroidManifest.xml，因为在组件是debug的时候它是单独单独运行的，还有就是代码可以在建立一个debug包，可以在单独运行的时候做些初始化app的，打包的时候回剔除这部分代码。</p>

<h2 id="toc_2">library依赖和资源问题</h2>

<p>我把所以的library都依赖在basic，每个组件都会依赖这个包，这样就不会存在library的版本问题，资源的问题就是</p>

<pre class="line-numbers"><code class="language-text"> defaultConfig {

        if (isBuildModule.toBoolean()) {
            applicationId &quot;com.wkw.archives&quot;
        }

        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode rootProject.ext.versionCode
        versionName rootProject.ext.versionName

        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;

        resourcePrefix &quot;archives&quot;
    }
</code></pre>

<h2 id="toc_3">组件之间的通信</h2>

<p>你可以选择阿里的<a href="https://github.com/alibaba/ARouter">ARouter</a>库，但是我的项目没有那么复杂，组件也就4个左右，所以没有使用阿里的库，我采用的是以下就是核心代码，</p>

<pre class="line-numbers"><code class="language-java">Object result = null;
Class&lt;?&gt; c = Class.forName(className);
if (c != null) {
    result = c.newInstance();
}
return result;
</code></pre>

<p>但是采用Class.forName会有个问题那就是在混淆的时候，className是指定的，所以要在类上加@Keep 。</p>

<h2 id="toc_4">CleanArchitecture框架和dagger在组件化的使用</h2>

<p><a href="https://github.com/android10/Android-CleanArchitecture">CleanArchitecture框架的github地址</a>，这里再介绍分享一篇文章小鄧子的<a href="http://www.jianshu.com/p/3edcf85539a6">Easy Clean architecture on Android</a>,我把data和domain会写在各自的业务模块中，自己的模块只要定义自己的就可以了，有个ApplicationModule会定义一些每个模块都需要的，</p>

<pre class="line-numbers"><code class="language-java">public class ApplicationModule {

    @Provides
    @Singleton
    Context provideContext(Application application) {
        return application;
    }

    @Provides
    @Singleton
    UserSystem provideUserSystem() {
        return new UserSystem();
    }

    @Provides
    @Singleton
    ThreadExecutor provideThreadExecutor(JobExecutor jobExecutor) {
        return jobExecutor;
    }

    @Provides
    @Singleton
    PostExecutionThread providePostExecutionThread(UIThread uiThread) {
        return uiThread;
    }

    @Provides
    @Singleton
    MrService provideMrService() {
        return new MrService();
    }

    @Provides
    @Singleton
    UserCache provideUserCache(UserCacheImpl userCache) {
        return userCache;
    }
}
</code></pre>

<p>然后在module_archives模块中会有ArchivesDataRepositoryModule和ArchivesActivityModule<br/>
其中KnowledgeDataRepositoryModule用于提供如下：</p>

<pre class="line-numbers"><code class="language-java">@Module
public class ArchivesDataRepositoryModule {

    @Provides
    @Singleton
    ArchivesApi providesArchivesApi(MrService mrService) {
        return mrService.createApi(ArchivesApi.class);
    }

    @Provides
    @Singleton
    ArchivesRepository prvidesArchivesRepository(ArchivesDataRepository archivesDataRepository) {
        return archivesDataRepository;
    }
}
</code></pre>

<p>ArchivesActivityModule的代码如下：</p>

<pre class="line-numbers"><code class="language-java">@Module
public abstract class ArchivesActivityModule {
   @PerActivity
   @ContributesAndroidInjector()
   abstract ArchivesActivity contributeArchivesActivity();
}
</code></pre>

<p>这样在主app的AppComponent类中加入：</p>

<pre class="line-numbers"><code class="language-java">@Singleton
@Component(modules = {
       AndroidInjectionModule.class, ApplicationModule.class,
       ArchivesDataRepositoryModule.class, ArchivesActivityModule.class,
       KnowledgeDataRepositoryModule.class, KnowledgeActivityModule.class
})
public interface AppComponent {
   @Component.Builder
   interface Builder {
       @BindsInstance
       Builder application(Application application);
       AppComponent build();
   }
   void inject(MrApplication mrApplication);
}
</code></pre>

<p>在module_archives为debug模式下也会有个AppComponent</p>

<pre class="line-numbers"><code class="language-java">@Singleton
@Component(modules = {
        AndroidInjectionModule.class, ApplicationModule.class,
        ArchivesDataRepositoryModule.class, ArchivesActivityModule.class
})
public interface AppComponent {
    @Component.Builder
    interface Builder {
        @BindsInstance
        Builder application(Application application);
        AppComponent build();
    }
    void inject(ArchivesApplication mrApplication);
}
</code></pre>

<p>各种模块初始化api和Repository，你要是嫌弃每个模块都要引入两个.class文件，你可以使用一个然后采用include的方式好比dagger中的AndroidSupportInjectionModule类方式</p>

<pre class="line-numbers"><code class="language-java">@Beta
@Module(includes = AndroidInjectionModule.class)
public abstract class AndroidSupportInjectionModule {
  @Multibinds
  abstract Map&lt;Class&lt;? extends Fragment&gt;, AndroidInjector.Factory&lt;? extends Fragment&gt;&gt;
      supportFragmentInjectorFactories();

  private AndroidSupportInjectionModule() {}
}
</code></pre>

<p>这样就会很清楚的知道自己模块需要初始化什么和使用什么，也不用考虑其它模块的初始化的数据，之后只需要在主app加入就行，也是比较方便的。</p>

<h2 id="toc_5">打包</h2>

<p>各种模块当为library是要打包成aar的，maven-release-kline-aar.gradle文件代码如下:</p>

<pre class="line-numbers"><code class="language-java">apply plugin: &#39;maven&#39;

ext {// ext is a gradle closure allowing the declaration of global properties
    PUBLISH_GROUP_ID = &#39;com.wkw&#39;
    PUBLISH_ARTIFACT_ID = &#39;archives&#39;
    PUBLISH_VERSION = rootProject.ext.versionName
}

uploadArchives {
    repositories.mavenDeployer {
        //这里就是最后输出地址，在自己电脑上新建个文件夹，把文件夹路径粘贴在此
        //注意”file://“ + 路径，有三个斜杠，别漏了
        repository(url: &quot;file:///Users/wukewei/Documents/android/ModularizationExample/repo&quot;)

        pom.project {
            groupId project.PUBLISH_GROUP_ID
            artifactId project.PUBLISH_ARTIFACT_ID
            version project.PUBLISH_VERSION
        }
    }
}

//以下代码会生成jar包源文件，如果是不开源码，请不要输入这段
//aar包内包含注释
task androidSourcesJar(type: Jar) {
    classifier = &#39;sources&#39;
    from android.sourceSets.main.java.sourceFiles
}

artifacts {
    archives androidSourcesJar
}
</code></pre>

<p>我只是打包到本地，你可以自己建立一个本地maven库。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870604.html">
                
                  <h1>Android-自定义皮肤</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">自定义Style和Theme</h2>

<p>  Style和Theme主要用来实现白天模式和夜间模式。<br/><br/>
  一个Style是一系列属性的集合，用来指定View或者Window的外观和格式。它可以指定的属性包括高度, Padding, 文字颜色，文字尺寸，背景颜色等等。<br/><br/>
  Style是在Xml资源文件中定义的，比如：</p>

<pre class="line-numbers"><code class="language-markup">&lt;style name=&quot;ListItemTitleStyle&quot; parent=&quot;TextAppearance.AppCompat.Body1&quot;&gt;
    &lt;item name=&quot;android:singleLine&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:ellipsize&quot;&gt;end&lt;/item&gt;
    &lt;item name=&quot;android:textColor&quot;&gt;?android:attr/textColorPrimary&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>  在布局文件中是这样使用的：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:id=&quot;@+id/text_item_title&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    style=&quot;@style/ListItemTitleStyle&quot; /&gt;
</code></pre>

<p>  这样一个Style就可以运用在多个地方，既可以统一样式，又可以减少代码量。<br/><br/>
  而Theme，其实就是一个Style，不同于我们上面提到对单一View的应用，Theme是应用于整个Activity或Application的。各位Android开发同学一定不陌生，在Manifest的Activity声明中就会经常看到。  </p>

<pre class="line-numbers"><code class="language-java">&lt;activity android:theme=&quot;@style/AppLightTheme.NoActionBar&quot;/&gt;
</code></pre>

<p>  这样，AppLightTheme.NoActionBar中的所有属性都会应用在整个Activity中。</p>

<p>  轻听这里，实现夜间模式分三步：</p>

<ul>
<li>自定义Style</li>
<li>应用Style中的属性</li>
<li>设置Theme</li>
</ul>

<h2 id="toc_1">自定义Style</h2>

<p>  我们这里，就是写两个Style ，然后各自有一套对应的颜色值。<br/>
  简单介绍一下几个主要的颜色值：</p>

<ul>
<li>colorPrimary: 主题色</li>
<li>colorAccent: 辅助色（或强调色）</li>
<li>textColorPrimary: 主要的文字颜色，一般TextView的文字都是这个颜色</li>
<li>textColorSecondary: 辅助的文字颜色，一般比textColorPrimary的颜色弱一点，用于一些弱化的表示</li>
<li>windowBackground: Window的背景色<br/>
  <br/>
  我们在资源文件中写对应的两套Style:</li>
</ul>

<pre class="line-numbers"><code class="language-markup">&lt;style name=&quot;AppLightTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/colorPrimaryTextBlack&lt;/item&gt;
    &lt;item name=&quot;android:textColorSecondary&quot;&gt;@color/colorSubTextBlack&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/white&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;AppDarkTheme&quot; parent=&quot;Theme.AppCompat.DayNight.DarkActionBar&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/darkColorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/darkColorAccent&lt;/item&gt;
    &lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/white&lt;/item&gt;
    &lt;item name=&quot;android:textColorSecondary&quot;&gt;@color/colorSubTextWhite&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/dark_bg&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>  细心的同学会发现，Style里的属性，有的前面会以“android:”开头，如<code>android:textColorPrimary</code>，有的则没有，如<code>colorPrimary</code>。<br/>
  以“android:”开头的属性，是系统的属性。而另一种属于自定义的属性，在资源文件中声明如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;attr name=&quot;minibar_background&quot; format=&quot;color&quot; /&gt;
</code></pre>

<p>  format包括boolean, color, dimension, enum, flag, float, fraction, integer, reference, string。 在此就不赘述了，这是它们的一个相当灵活的使用方式。</p>

<h2 id="toc_2">应用Style中的属性</h2>

<p>  比如，colorAccent是在design包中定义的，属于自定义属性，在使用的时候，直接“?attr/”+属性名就可以了。</p>

<pre class="line-numbers"><code class="language-markup">&lt;ImageView
    android:tint=&quot;?attr/colorAccent&quot; /&gt;
</code></pre>

<p>  系统属性要多加一个”android:”, 是”?android:attr/“+属性名。</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:textColor=&quot;?android:attr/textColorPrimary&quot;/&gt;
</code></pre>

<p>  这样，当指定了Theme之后，就会去相应的Style下面取对应的颜色值，从而呈现出不同的色彩。</p>

<h2 id="toc_3">设置Theme</h2>

<p>  在Manifest中设置是常见的方式。</p>

<p><code>&lt;activity android:theme=&quot;@style/AppLightTheme.NoActionBar&quot;/&gt;</code></p>

<p>  不过为了实现模式的切换，我们是在Activity的onCreate中进行的设置</p>

<pre class="line-numbers"><code class="language-java">protected void initTheme() {
    if (MusicPreferences.getInstance().isNightMode()) {
        setTheme(R.style.AppDarkTheme_NoActionBar);
    } else {
        setTheme(R.style.AppLightTheme_NoActionBar);
    }
}
</code></pre>

<p>  这样，通过给Activity设置不同的Theme，页面就能呈现出不同的颜色搭配。</p>

<h2 id="toc_4">问题</h2>

<p>  Style和Theme的方式实现简单，非常适用于模式较为固定的场景，如白天模式和夜间模式。<br/><br/>
  但是，轻听在白天的模式的时候的基础之上还有几种不同的主题色。</p>

<p>  简单聊一下主题色。<br/><br/>
  主题色，即colorPrimary，是根据品牌形象，为App定义的一个主色调，一般应用于AppBar。<br/><br/>
  同时，有一个强调色，即colorAccent，是用在Checkbox或下划线等需要给人以提示作用的地方，起辅助的作用。<br/><br/>
  还有一个颜色是colorPrimaryDark，就是比colorPrimary稍微深一些，主要用在状态栏。  </p>

<p><figure><img src="media/15561207870604/15713321794597.png" alt=""/></figure></p>

<p>  比如上图中，“蓝色”就是主题色，“红”色就是强调色。<br/><br/>
  主题色和强调色的色值可以不一样，也可以一样。在一般的设计中都是不同的。在轻听的设计中，为了突出品牌色，将强调色跟主题色统一设计成了一个颜色，所以你会看到，到处都是“绿”色。  </p>

<p><figure><img src="media/15561207870604/15713321901070.png" alt=""/></figure></p>

<p>  在强调色跟主题色统一的情况下，6个主题色，6套Style，似乎还可以接受。<br/><br/>
  但是，万一以后设计同学良心发现了呢？6在6套主题色的基础之上再出6套强调色，那可就是36个Style。如果以后的调色方式再更为灵活，如：</p>

<p><figure><img src="media/15561207870604/15713321976614.png" alt=""/></figure></p>

<p>  我数学不好，谁帮我算算，别忘了加上强调色还得再平方一下……<br/><br/>
  如果给每一个主题色都写一套Style，工作量会很大，而且不灵活。这个时候Style就玩不转了。<br/><br/>
  我们需要一种更为灵活的方案。  </p>

<h2 id="toc_5">动态配置主题色</h2>

<p>  动态配置主题色是借鉴了github开源控件app-theme-engine。在gradle中引入方式是:</p>

<pre class="line-numbers"><code class="language-text">compile(&#39;com.github.naman14:app-theme-engine:0.5.1@aar&#39;) {
    transitive = true
}
</code></pre>

<p>  由于找不到这个项目维护的地址，所以我们自己进行了扩展和优化。<br/><br/>
  主要由三个模块组成  </p>

<ul>
<li>颜色配置</li>
<li>颜色处理器</li>
<li>遍历逻辑控制器</li>
</ul>

<h2 id="toc_6">颜色配置</h2>

<p>  颜色配置主要负责存储颜色值。<br/><br/>
  因为这里存储数据较小，而且简单，所以用SharedPreference来存储，稍加封装就可以。</p>

<h2 id="toc_7">颜色处理器</h2>

<p>  颜色处理器Processor主要负责对每一个View的各种颜色进行设置。<br/><br/>
  首先，定义一个接口</p>

<pre class="line-numbers"><code class="language-java">public interface Processor&lt;T extends View, E&gt; {
    void process(@NonNull Context context, @Nullable String key, @Nullable T target, @Nullable E extra);
}
</code></pre>

<p>  process方法就是来处理视图颜色的。<br/><br/>
  其中target就是要传入的视图，这里使用泛型，在各个派生的Processor中具体实现。<br/><br/>
  以下是几个主要的Processor。</p>

<p><figure><img src="media/15561207870604/15713322118808.png" alt=""/></figure></p>

<p>  其中DefaultProcessor是默认Processor，可以处理绝大部分的变色情况。其他几种，如他们的名字一样，会额外再处理他们特定的情况。</p>

<p>Processor的处理方式分三步：</p>

<ul>
<li>给View设置tag</li>
<li>解析View的tag</li>
<li>根据具体的tag进行颜色的设置<br/>
  <br/>
  以DefaultProcessor为例。有一个TextView，我们要使他的文字颜色为强调色。<br/>
  首先，给View设置一个tag，”text_accent_color”。如果有多个tag，以逗号分隔。</li>
</ul>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:tag=&quot;text_accent_color&quot;
    /&gt;
</code></pre>

<p>  然后在process方法中将tag解析出来</p>

<pre class="line-numbers"><code class="language-java">public void process(@NonNull Context context, @Nullable String key, @Nullable View view, @Nullable Void extra) {
    if(view != null &amp;&amp; view.getTag() != null &amp;&amp; view.getTag() instanceof String) {
        String tag = (String)view.getTag();
        if(tag.contains(&quot;,&quot;)) {
            String[] splitTags = tag.split(&quot;,&quot;);
            int len = splitTags.length;

            for(int i = 0; i &lt; len; ++i) {
                String part = splitTags[i];
                processTagPart(context, view, part, key);
            }
        } else {
            processTagPart(context, view, tag, key);
        }

    }
}
</code></pre>

<p>  这里会根据分隔符（逗号）来对tag的数量进行解析，然后依次根据每个tag依次处理。<br/><br/>
  在处理方法processTagPart中，会找到”text_accent_color”相对应的处理逻辑</p>

<pre class="line-numbers"><code class="language-java">if (view instanceof  TextView) {
    ((TextView) view).setTextColor(Config.accentColor(context, key));
}
</code></pre>

<p>  Config.accentColor(context, key)的作用就是从颜色配置模块中读取当前的强调色。<br/><br/>
  其他一些稍微复杂一点的情况，则可以使用相对应的Processor去进行特殊的处理。<br/><br/>
  例如，ViewPagerProcessor。ViewPager在滑动边界的时候会有一个边界反馈的效果，如下图：  </p>

<p><figure><img src="media/15561207870604/15713322239841.png" alt=""/></figure></p>

<p>  这里需要特殊处理一下。ViewPager中，负责两个边缘效果的是EdgeEffectCompat。</p>

<pre class="line-numbers"><code class="language-java">private EdgeEffectCompat mLeftEdge;
private EdgeEffectCompat mRightEdge;
  EdgeEffectCompat是一个对系统版本做兼容性处理的类，里面有真正的边缘效果模块EdgeEffect

public final class EdgeEffectCompat {
    private Object mEdgeEffect;
}
</code></pre>

<p>  注意到，这两处都是私有的，所以我们必须通过两次反射来获取EdgeEffect，然后更改颜色。<br/><br/>
  首先，通过反射获取ViewPager的左右EdgeEffectCompat。</p>

<pre class="line-numbers"><code class="language-java">public static void setEdgeGlowColor(@NonNull ViewPager viewPager, @ColorInt int color) {
    if(Build.VERSION.SDK_INT &gt;= 21) {
        try {
            Field edgeLeft = ViewPager.class.getDeclaredField(&quot;mLeftEdge&quot;);
            edgeLeft.setAccessible(true);
            Field edgeRight = ViewPager.class.getDeclaredField(&quot;mRightEdge&quot;);
            edgeRight.setAccessible(true);
            EdgeEffectCompat ee = (EdgeEffectCompat)edgeLeft.get(viewPager);
            if (ee != null) {
                setEdgeGlowColor(ee, color);
            }
            ee = (EdgeEffectCompat)edgeRight.get(viewPager);
            if (ee != null) {
                setEdgeGlowColor(ee, color);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>  然后再获取真正的EdgeEffect，并更改颜色。</p>

<pre class="line-numbers"><code class="language-java">private static void setEdgeGlowColor(@NonNull EdgeEffectCompat edgeEffect, @ColorInt int color) throws Exception {
    if(Build.VERSION.SDK_INT &gt;= 21) {
        Field field = EdgeEffectCompat.class.getDeclaredField(&quot;mEdgeEffect&quot;);
        field.setAccessible(true);
        EdgeEffect effect = (EdgeEffect) field.get(edgeEffect);
        if (effect != null) {
            effect.setColor(color);
        }
    }
}
</code></pre>

<p>  这样边缘效果的颜色就修改好啦。</p>

<h2 id="toc_8">遍历逻辑</h2>

<p>  遍历逻辑控制器主要负责对整个页面的所有View进行遍历，并进行颜色处理。<br/>
  以下是遍历逻辑：</p>

<p><figure><img src="media/15561207870604/15713322369276.png" alt=""/></figure></p>

<ul>
<li>初始化Processor</li>
</ul>

<pre class="line-numbers"><code class="language-java">private static void initProcessors() {
    mProcessors = new HashMap();
    mProcessors.put(&quot;[default]&quot;, new DefaultProcessor());
    mProcessors.put(ScrollView.class.getName(), new MusicScrollViewProcessor());
    mProcessors.put(ListView.class.getName(), new MusicListViewProcessor());
    mProcessors.put(RecyclerView.class.getName(), new MusicRecyclerViewProcessor());
    mProcessors.put(Toolbar.class.getName(), new MusicToolbarProcessor());
    mProcessors.put(NavigationView.class.getName(), new MusicNavigationViewProcessor());
    mProcessors.put(TabLayout.class.getName(), new MusicTabLayoutProcessor());
    mProcessors.put(ViewPager.class.getName(), new MusicViewPagerProcessor());
}
</code></pre>

<p>  将各Processor实例化后存入HashMap，key为类名。</p>

<ul>
<li><p>开始刷新的时机是onStart，因为这个时候布局已经基本初始化完毕。我们会判断Activity之前是否start过，避免重复的进行处理。至于在此之后生成的布局，会单独对其进行一次刷新。</p></li>
<li><p>从流程图中可以看出，在处理ContentView之前，我们会单独处理几个特殊的布局。<br/><br/>
StatusBar是顶部状态栏，NavigationBar是底部导航栏，有时我们会希望让这两处也兼容主题色。<br/><br/>
    如果用到ActionBar，也需要处理一下。不过MD的实现中，一般都是NoActionBar的，而用我们自己布局的ToolBar来代替。<br/><br/>
    在有侧边栏的页面中，根布局一般都是DrawerLayout，在侧边栏滑出的时候，可以设置DrawerLayout的状态栏颜色。  </p></li>
<li><p>找我们自己的根布局：ContentView<br/><br/>
ContentView就是我们用setContentView设置的布局，它上面还有ContentParent，DecorView，Window。<br/><br/>
  直接根据资源id找？不现实，因为每个Activity的ContentView资源id基本都不一样的。<br/><br/>
  这里采取一种迂回的方式，先找到ContentView的父布局ContentParent。<br/><br/>
  我们看setContentView的代码：  </p></li>
</ul>

<pre class="line-numbers"><code class="language-java">@Override
public void setContentView(int resId) {
    ensureSubDecor();
    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);
    contentParent.removeAllViews();
    LayoutInflater.from(mContext).inflate(resId, contentParent);
    mOriginalWindowCallback.onContentChanged();
}
</code></pre>

<p>  可以看到，实际上ContentParent的资源id是固定的：android.R.id.content。<br/><br/>
  系统会先把ContentParent的子视图清除，然后通过LayoutInflater的inflate方法将我们指定布局的视图解析出来并添加到ContentParent中。<br/><br/>
  那么我们就可以根据android.R.id.content先找到ContentParent，进而找到ContentView<br/><br/>
  </p>

<pre class="line-numbers"><code class="language-java">ViewGroup contentView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(0);
</code></pre>

<ul>
<li>获取Processor</li>
</ul>

<p>  根据View的类名获取Processor</p>

<pre class="line-numbers"><code class="language-java">Processor processor = mProcessors.get(viewClass.getName());
if(processor != null) {
    return processor;
} else {
    Class current = viewClass;

    do {
        current = current.getSuperclass();
        if(current == null) {
            break;
        }

        processor = mProcessors.get(current.getName());
    } while(processor == null);

    if (processor == null) {
        mProcessors.get(&quot;[default]&quot;)
    }

    return processor;
}
</code></pre>

<p>  从HashMap中获取对应的Processor，如果找不到则根据父类的名字查找。找到之后就可以调用process方法进行处理。</p>

<ul>
<li>遍历</li>
</ul>

<p>  这里会从ContentView开始进行深度优先遍历，处理所有的视图。<br/><br/>
  有一些特殊的ViewGroup不需要遍历其子布局，例如TabLayout，因为其自己的方法已经满足绝大部分的情况。</p>

<h2 id="toc_9">结语</h2>

<p>  以上，就是两种变色方案的具体实现。</p>

<ul>
<li>自定义Style和Theme实现简单，整洁，适用于模式较为固定的场景。</li>
<li>动态配置主题色实现起来略微复杂，但是比较灵活，适用于主题色较多的场景。</li>
</ul>

<p>  将这两种方案结合，就实现了轻听的变色。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870533.html">
                
                  <h1>Android-ImageView详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">ScaleType</h2>

<ul>
<li><p><code>android:scaleType=&quot;center&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按照图片的原大小居中显示，不缩放，用ImageView的大小截取图片的居中部分。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerCrop&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按比例缩小图片，直到图片的宽高有一边等于ImageView的宽高，则对于另一边，图片的长度大于或等于ImageView的长度，最后用ImageView的大小居中截取该图片。</li>
<li>当图片小于ImageView的宽高：以图片的中心店和ImageView的中心点为基准，按比例扩大图片，直到图片的宽高大于或等于ImageView的宽高，并按ImageView的大小居中截取该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;centerInside&quot;</code></p>
<ul>
<li>当图片大于ImageView的宽高：以图片的中心和ImageView的中心点为基准，按比例缩小图片，使图片宽高等于或者小于ImagevView的宽高，直到将图片的内容完整居中显示。</li>
<li>当图片小于ImageView的宽高：直接居中显示该图片。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitCenter&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，居中显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitStart&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的上方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitEnd&quot;</code></p>
<ul>
<li>表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的下方显示。</li>
</ul></li>
<li><p><code>android:scaleType=&quot;fitXY&quot;</code></p>
<ul>
<li>表示把图片按指定的大小在ImageView中显示，拉伸或收缩图片，不保持原比例，填满ImageView。</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870497.html">
                
                  <h1>Android-Xfermode详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Xfermode</h2>

<p>Xfermode具体怎么翻译，说实话，我也不知道，我习惯叫它图片混合模式，随便了，管它叫什么，不妨碍我们使用它。关于Xfermode的说明，可以在Google文档中找到这样的描述：Xfermode是在绘图通道中自定义“传输模式”的基类。静态函数创建可以调用或者返回任意作为模式枚举指定的预定义子类实例。当Xfermode分配给Paint，然后绘制对象与Paint就具备了所添加的xfermode。读起来比较拗口，下面直接看Xfermode的源码：</p>

<pre class="line-numbers"><code class="language-java">public class Xfermode {  
    protected void finalize() throws Throwable {  
        try {  
            finalizer(native_instance);  
        } finally {  
            super.finalize();  
        }  
    }  
    private static native void finalizer(long native_instance);  
    long native_instance;  
}  
</code></pre>

<p>看，Xfermode就这么点代码，经验告诉我们，其下必有子类，擦，变元芳了~~~</p>

<p><figure><img src="media/15561207870497/15713323572183.png" alt=""/></figure></p>

<p>查看一下文档发现Xfermode确实有AvoidXfermode、PixelXorXfermode、PorterDuffXfermode，下面来继续学习一下3个子类的用法。</p>

<h2 id="toc_1">AvoidXfermode</h2>

<p>看这个子类之前告诉大家一个不幸的消息，AvoidXfermode不支持硬件加速，在高于API16的机器上不会适用，如果想测试这个子类。</p>

<ul>
<li>1，可以关闭手机的硬件加速模块；</li>
<li>2，在AndroidManifest.xml中Application节点上设置硬件加速为false。
<code>android:hardwareAccelerated=&quot;false&quot;</code></li>
</ul>

<p>在Android Studio下点击查看一下AvoidXfermode的构造方法：<br/>
<code>public AvoidXfermode(int opColor, int tolerance, Mode mode)</code></p>

<p><code>AvoidXfermode</code>的构造方法也特别简单，一共接收3个参数：第一个参数opColor是一个16进制的带透明度通道的颜色值，如0X12345678。第二个参数<code>tolerance</code>表示容差值，什么是容差值呢？可以理解成一个表示“精确”和“模糊”的概念，下面会解释一下。第三个参数是<code>AvoidXfermode</code>的模式，<code>AvoidXfermode</code>的模式一共有两种：<code>AvoidXfermode.Mode.TARGET</code>和<code>AvoidXfermode.Mode.AVOID</code>。</p>

<h2 id="toc_2">AvoidXfermode.Mode.TARGET</h2>

<p>在该模式下Android会判断画布上的颜色是否会有跟opColor不一样的颜色，比如我opColor是红色，那么在TARGET模式下就会去判断我们的画布上是否有存在红色的地方，如果有，则把该区域“染”上一层我们画笔定义的颜色，否则不“染”色，而tolerance容差值则表示画布上的像素和我们定义的红色之间的差别该是多少的时候才去“染”的，比如当前画布有一个像素的色值是(200, 20, 13)，而我们的红色值为(255, 0, 0)，当tolerance容差值为255时，即便(200, 20, 13)并不等于红色值也会被“染”色，容差值越大“染”色范围越广反之则反，空说无凭我们来看看具体的实现和效果：</p>

<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private AvoidXfermode avoidXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        avoidXfermode = new AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        mPaint.setARGB(255, 211, 53, 243);  
        mPaint.setXfermode(avoidXfermode);  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>

<p>下面来运行看效果，首先确定一下开启的模拟器是API16以下的，或者Application节点下设置了关闭“硬件加速”：</p>

<p><figure><img src="media/15561207870497/15713323776932.png" alt=""/></figure></p>

<p><code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET)：</code><br/>
大家可以看到，在我们的模式为TARGET容差值为0的时候此时只有当图片中像色颜色值为0XFFFFFFFF的地方才会被染色，而其他地方不会有改变</p>

<p>下面我们来修改一下容差值，将容差值改成255：</p>

<p><figure><img src="media/15561207870497/15713323877972.png" alt=""/></figure></p>

<p><code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.TARGET)</code><br/>
而当容差值为255的时候只要是跟0XFFFFFFFF有点接近的地方都会被染色</p>

<h2 id="toc_3">AvoidXfermode.Mode.AVOID</h2>

<p>则与TARGET恰恰相反，TARGET是我们指定的颜色是否与画布的颜色一样，而AVOID是我们指定的颜色是否与画布不一样，其他的都与TARGET类似<code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.AVOID)：</code></p>

<p><figure><img src="media/15561207870497/15713323978095.png" alt=""/></figure></p>

<p>当模式为AVOID容差值为0时，只有当图片中像素颜色值与0XFFFFFFFF完全不一样的地方才会被染色<code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.AVOID)：</code></p>

<p><figure><img src="media/15561207870497/15713324061116.png" alt=""/></figure></p>

<p>当容差值为255时，只要与0XFFFFFFFF稍微有点不一样的地方就会被染色</p>

<p>那么这玩意究竟有什么用呢？比如说当我们只想在白色的区域画点东西或者想把白色区域的地方替换为另一张图片的时候就可以采取这种方式！</p>

<h2 id="toc_4">PixelXorXfermode</h2>

<p>PixelXorXfermode是Xfermode下的另外一种图像混排模式，该类特别简单，不过呢，也很不幸的，在API16中已经过时了。我们来做一个简单的了解，先看PixelXorXfermode的构造方法：<br/>
<code>public PixelXorXfermode(int opColor)   </code></p>

<p>构造方法很简单，只要传递一个16进制带透明通道的颜色值即可，那么这个参数有什么用呢？我在Google文档中，找到了这样的一个算法：实际上PixelXorXfermode内部是按照“opColor ^ src ^ dst”这个异或算法运算的，得到一个不透明的(alpha = 255)的色彩值，设置到图像中，下面我们接着上面用到的图片Demo写个PixelXorXfermode的Demo：</p>

<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private PixelXorXfermode pixelXorXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        pixelXorXfermode = new PixelXorXfermode(0XFFFF0000);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //先绘制Bitmap，src  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        //随便设置一个纯色测试  
        mPaint.setARGB(255, 211, 53, 243);  
        //设置Xfermode  
        mPaint.setXfermode(pixelXorXfermode);  
        //在bitmap上混排一个纯色的矩形（dst）  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>

<p>混排后的图像是：</p>

<p><figure><img src="media/15561207870497/15713324266322.png" alt=""/></figure></p>

<p>PixelXorXfermode在底层已经取出src，dst每个像素点与opColor进行了opColor ^ src ^ dst运算了，结果输出就是上图所示的那样！好了，我只学这么多了，因为它已经过时了，同样上面的AvoidXfermode也是，过时了，了解即可。下面是对Xfermode的第三个子类，也是唯一一个还没有过时的，非常重要的子类PorterDuffXfermode的学习。</p>

<h2 id="toc_5">PorterDuffXfermode</h2>

<p>同样PorterDuffXfermode也是Xfermode的子类，我们先看看它的构造方法：<code>public PorterDuffXfermode(PorterDuff.Mode mode)</code></p>

<p><code>PorterDuffXfermode</code>的构造方法很简单，构造方法中需要传递一个<code>PorterDuff.Mode</code>参数，关于<code>PorterDuff.Mode</code>，我们在上篇博客中已经学习完了，其实跟<code>ColorFilter</code>的子类<code>PorterDuffColorFilter</code>的混排模式是一样的。Android系统一共提供了18种混排模式，在模拟器的<code>ApiDemos/Graphics/XferModes</code>，有张效果图：</p>

<p><figure><img src="media/15561207870497/15713324389852.png" alt=""/></figure></p>

<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式已经算法，其中比上图多了ADD和OVERLAY两种模式： </p>

<p><figure><img src="media/15561207870497/15713324526708.png" alt=""/></figure></p>

<p>Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面将会对照ApiDemos/Graphics/XferModes的程序进行修改，来测试各个模块的效果，测试程序如下：</p>

<pre class="line-numbers"><code class="language-java">public class XfermodeView extends View {  
  
    //PorterDuff模式常量 可以在此更改不同的模式测试  
    private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;  
    private PorterDuffXfermode porterDuffXfermode;  
    private int screenW, screenH; //屏幕宽高  
    private Bitmap srcBitmap, dstBitmap;  
    //源图和目标图宽高  
    private int width = 120;  
    private int height = 120;  
  
    public XfermodeView(Context context) {  
        this(context, null);  
    }  
  
    public XfermodeView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        screenW = ScreenUtil.getScreenW((Activity) context);  
        screenH = ScreenUtil.getScreenH((Activity) context);  
        //创建一个PorterDuffXfermode对象  
        porterDuffXfermode = new PorterDuffXfermode(MODE);  
        //创建原图和目标图  
        srcBitmap = makeSrc(width, height);  
        dstBitmap = makeDst(width, height);  
    }  
  
    //创建一个圆形bitmap，作为dst图  
    private Bitmap makeDst(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFFFFCC44);  
        c.drawOval(new RectF(0, 0, w  3 / 4, h  3 / 4), p);  
        return bm;  
    }  
  
    // 创建一个矩形bitmap，作为src图  
    private Bitmap makeSrc(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFF66AAFF);  
        c.drawRect(w / 3, h / 3, w  19 / 20, h  19 / 20, p);  
        return bm;  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        Paint paint = new Paint();  
        paint.setFilterBitmap(false);  
        paint.setStyle(Paint.Style.FILL);  
        //绘制“src”蓝色矩形原图  
        canvas.drawBitmap(srcBitmap, screenW / 8 - width / 4, screenH / 12 - height / 4, paint);  
        //绘制“dst”黄色圆形原图  
        canvas.drawBitmap(dstBitmap, screenW / 2, screenH / 12, paint);  
  
        //创建一个图层，在图层上演示图形混合后的效果  
        int sc = canvas.saveLayer(0, 0, screenW, screenH, null, Canvas.MATRIX_SAVE_FLAG |  
                Canvas.CLIP_SAVE_FLAG |  
                Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |  
                Canvas.FULL_COLOR_LAYER_SAVE_FLAG |  
                Canvas.CLIP_TO_LAYER_SAVE_FLAG);  
  
        //先绘制“dst”黄色圆形  
        canvas.drawBitmap(dstBitmap, screenW / 4, screenH / 3, paint);  
        //设置Paint的Xfermode  
        paint.setXfermode(porterDuffXfermode);  
        canvas.drawBitmap(srcBitmap, screenW / 4, screenH / 3, paint);  
        paint.setXfermode(null);  
        // 还原画布  
        canvas.restoreToCount(sc);  
    }  
}  
</code></pre>

<p>为了方便观察，需要将Activity_main.xml的背景色设置为黑色。</p>

<p><strong>1.PorterDuff.Mode.CLEAR</strong>。中文描述：所绘制源图像不会提交到画布上。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;</code></p>

<p><figure><img src="media/15561207870497/15713324799406.png" alt=""/></figure></p>

<p><strong>2.PorterDuff.Mode.SRC</strong>。中文描述：只显示源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC;</code></p>

<p><figure><img src="media/15561207870497/15713324920855.png" alt=""/></figure></p>

<p><strong>3.PorterDuff.Mode.DST</strong>。中文描述：只显示目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST;</code></p>

<p><figure><img src="media/15561207870497/15713325038512.png" alt=""/></figure></p>

<p><strong>4.PorterDuff.Mode.SRC_OVER</strong>。中文描述：正常绘制显示，源图像居上显示。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OVER;</code></p>

<p><figure><img src="media/15561207870497/15713325195114.png" alt=""/></figure></p>

<p><strong>5.PorterDuff.Mode.DST_OVER</strong>。中文描述： 上下层都显示。目标图像居上显示。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OVER;</code></p>

<p><figure><img src="media/15561207870497/15713325338664.png" alt=""/></figure></p>

<p><strong>6.PorterDuff.Mode.SRC_IN</strong>。中文描述： 取两层绘制交集中的源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_IN;</code></p>

<p><figure><img src="media/15561207870497/15713325520933.png" alt=""/></figure></p>

<p><strong>7.PorterDuff.Mode.DST_IN</strong>。中文描述：取两层绘制交集中的目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_IN;</code></p>

<p><figure><img src="media/15561207870497/15713325672134.png" alt=""/></figure></p>

<p><strong>8.PorterDuff.Mode.SRC_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OUT;</code></p>

<p><figure><img src="media/15561207870497/15713325797909.png" alt=""/></figure></p>

<p><strong>9.PorterDuff.Mode.DST_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OUT;</code></p>

<p><figure><img src="media/15561207870497/15713325970254.png" alt=""/></figure></p>

<p><strong>10.PorterDuff.Mode.SRC_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_ATOP;</code></p>

<p><figure><img src="media/15561207870497/15713326104118.png" alt=""/></figure></p>

<p><strong>11.PorterDuff.Mode.DST_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_ATOP;</code></p>

<p><figure><img src="media/15561207870497/15713326227426.png" alt=""/></figure></p>

<p><strong>12.PorterDuff.Mode.XOR</strong>。中文描述：异或：去除两图层交集部分<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.XOR;</code></p>

<p><figure><img src="media/15561207870497/15713326370757.png" alt=""/></figure></p>

<p><strong>13.PorterDuff.Mode.DARKEN</strong>。中文描述：取两图层全部区域，交集部分颜色加深<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DARKEN;</code></p>

<p><figure><img src="media/15561207870497/15713326508491.png" alt=""/></figure></p>

<p><strong>14.PorterDuff.Mode.LIGHTEN</strong>。中文描述：取两图层全部，点亮交集部分颜色<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.LIGHTEN;</code></p>

<p><figure><img src="media/15561207870497/15713326673606.png" alt=""/></figure></p>

<p><strong>15.PorterDuff.Mode.MULTIPLY</strong>。中文描述：取两图层交集部分叠加后颜色<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.MULTIPLY;</code></p>

<p><figure><img src="media/15561207870497/15713326778042.png" alt=""/></figure></p>

<p><strong>16.PorterDuff.Mode.SCREEN</strong>。中文描述：滤色。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SCREEN;</code></p>

<p><figure><img src="media/15561207870497/15713326858545.png" alt=""/></figure></p>

<p>以下是<a href="http://lib.csdn.net/base/android">android</a>中新加的两种模式：</p>

<p><strong>17.ADD</strong>。中文描述：饱和度相加。<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.ADD;</code></p>

<p><figure><img src="media/15561207870497/15713326949445.png" alt=""/></figure></p>

<p><strong>18.OVERLAY</strong>。中文描述：叠加<br/>
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.OVERLAY;</code></p>

<p><figure><img src="media/15561207870497/15713327034956.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870461.html">
                
                  <h1>Android-Paint详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>的确平时开发中，用到画笔的地方还是不多的。但是一遇到自定义View，就会发现这玩意还真是不能不好好掌握，毕竟绘出我们想要的图形界面就靠它了。很多开发人员对画笔Paint的了解知之甚少，包括我自己在内，所以在今天在这里总结一下Paint的在 android图像处理中起到的作用和用法。</p>

<h2 id="toc_1">Paint的简单了解</h2>

<p>同样，我们学习Paint之前，首先查看一下Paint类的API，其中，我们最需要关注的地方就是Paint类给我们提供了很多的setter方法，可以通过调用setter方法来设置自己的偏好。下面是在Android Studio中查到的Paint类的部分setter：</p>

<p><figure><img src="media/15561207870461/15713327196078.png" alt=""/></figure></p>

<ul>
<li><code>Paint(int flags)</code>：构建Paint实例，常用的flags是ANTI_ALIAS_FLAG，消除锯齿。</li>
<li><code>set(Paint src)</code>：将另一个Paint复制给当前Paint实例，不多说了。</li>
<li><code>setColor(int color)</code>：设置画笔的颜色。</li>
<li><code>setColorFilter(ColorFilter filter)</code>：设置色彩过滤器，很重要，后面还会有一些总结。</li>
<li><code>setStyle(Paint.Style style)</code>：设置Paint的风格。 画笔样式分三种：1.Paint.Style.STROKE：描边 。2.Paint.Style.FILL_AND_STROKE：描边并填充 。3.Paint.Style.FILL：填充 。</li>
<li><code>setAlpha(int a)</code> : 设置绘制图形的透明度。</li>
<li><code>setAntiAlias(boolean aa)</code>：是否消除锯齿。</li>
<li><code>setARGB(int a,int r,int g,int b)</code> : 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。</li>
<li><code>setStrokeWidth(float width)</code>：设置Paint划线的宽度。</li>
<li><code>setDither(boolean dither)</code> : 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰</li>
<li><code>setElegantTextHeight(boolean elegant)</code> : //设置优雅的文字高度，这个设置可能会对FontMetrics产生影响</li>
<li><code>setFakeBoldText(boolean fakeBoldText)</code> : //设置文本粗体</li>
<li><code>setFilterBitmap(boolean filter)</code> : //对位图进行滤波处理，如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示</li>
<li><code>setFlags(int flags)</code> : //设置一些标志，比如抗锯齿，下划线等等。</li>
<li><code>setFontFeatureSettings(String settings)</code> : //设置字体样式，可以设置CSS样式</li>
<li><code>setHinting(int mode)</code> : 设置画笔的隐藏模式。可以是 <code>HINTING_OFF</code> or <code>HINTING_ON</code>之一。</li>
<li><code>setLetterSpacing(float letterSpacing)</code> : //设置行的间距，默认值是0，负值行间距会收缩</li>
<li><code>setLinearText(boolean linearText)</code> : //这个是文本缓存，设置线性文本，如果设置为true就不需要缓存</li>
<li><code>setMaskFilter(MaskFilter maskfilter)</code> : //对图像进行一定的处理，实现滤镜的效果，如滤化，立体等,有BlurMaskFilter，EmbossMaskFilter几种</li>
<li><code>setPathEffect(PathEffect effect)</code> : //设置绘制路径的效果，有ComposePathEffect，CornerPathEffect，DashPathEffect，DiscretePathEffect，PathDashPathEffect，SumPathEffect几种</li>
<li><code>setShader(Shader shader)</code> : //设置着色器，用来给图像着色的，绘制出各种渐变效果，有BitmapShader，ComposeShader，LinearGradient，RadialGradient，SweepGradient几种</li>
<li><code>setShadowLayer(float radius, float dx, float dy, int shadowColor)</code> : //设置阴影效果，radius为阴影角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 ，看一下演示效果，其中第一个是没有阴影的，第二个设置了黑色的阴影</li>
<li><code>setStrikeThruText(boolean strikeThruText)</code> : //设置文本的删除线</li>
<li><code>setStrokeCap(Cap cap)</code> : //设置线条末端形状<code>Paint.Cap.BUTT</code>、<code>Paint.Cap.ROUND</code>、<code>Paint.Cap.SQUARE</code></li>
<li><code>setStrokeJoin(Join join)</code> : //设置矩形连接时的效果<code>Paint.Join.BEVEL</code>、<code>Paint.Join.MITER</code>、<code>Paint.Join.ROUND</code></li>
<li><code>setStrokeMiter(float miter)</code> : //当style为Stroke或StrokeAndFill时设置连接处的倾斜度，这个值必须大于0</li>
<li><code>setSubpixelText(boolean subpixelText)</code> : //设置亚像素，是对文本的一种优化设置，可以让文字看起来更加清晰明显，可以参考一下PC端的控制面板-外观和个性化-调整ClearType文本</li>
<li><code>setTextAlign(Align align)</code> : //设置文本对齐<code>Paint.Align.CENTER</code>、<code>Paint.Align.LEFT</code>、<code>Paint.Align.RIGHT</code></li>
<li><code>setTextLocale(Locale locale)</code> ： //设置地理位置，比如显示中文，日文，韩文等，默认的显示Locale.getDefault()即可</li>
<li><code>setTextScaleX(float scaleX)</code> : //设置字体的水平方向的缩放因子，默认值为1，大于1时会沿X轴水平放大，小于1时会沿X轴水平缩小</li>
<li><code>setTextSize(float textSize)</code> : //设置字体大小</li>
<li><code>setTextSkewX(float skewX)</code> : //设置文本在水平方向上的倾斜，默认值为0，推荐的值为-0.25</li>
<li><code>setTypeface(Typeface typeface)</code> : //设置字体样式，可以是Typeface设置的样式，也可以通过Typeface的createFromAsset(AssetManager mgr, String path)方法加载样式</li>
<li><code>setUnderlineText(boolean underlineText)</code> : //设置文本的下划线</li>
<li><code>setXfermode(Xfermode xfermode)</code>：设置Paint的模式，后面有详细点的说明，很重要。</li>
<li><code>reset()</code> : //重置Paint</li>
<li><code>measureText(char[] text, int index, int count)</code>，<code>measureText(String text, int start, int end)</code>，<code>measureText(String text)</code>，<code>measureText(CharSequence text, int start, int end)</code> : //测量字体的长度</li>
<li><code>breakText(char[] text, int index, int count,float maxWidth, float[] measuredWidth)</code>，<code>breakText(CharSequence text, int start, int end,boolean measureForwards,  floatmaxWidth, float[] measuredWidth)</code>，<code>breakText(String text, boolean measureForwards,float maxWidth, float[] measuredWidth)</code> : //剪切显示，就是大于maxWidth的时候只截取指定长度的显示</li>
<li><code>getTextWidths(char[] text, int index, int count,float[] widths)</code>，<code>getTextWidths(CharSequence text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, float[] widths)</code> : //提取指定范围内的字符串，保存到widths中</li>
<li><code>getTextPath(char[] text, int index, int count, float x, float y, Path path)</code>，<code>getTextPath(String text, int start, int end, float x, float y, Path path)</code> : //获取文本绘制的路径，提取到Path中</li>
<li><code>getTextBounds(String text, int start, int end, Rect bounds)</code>，<code>getTextBounds(char[] text, int index, int count, Rect bounds)</code> : //得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870430.html">
                
                  <h1>Android-ColorFilter详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在Android Studio中点击进去看一下源码，可以看到ColorFilter里的代码量很少</p>

<pre class="line-numbers"><code class="language-java">public class ColorFilter {  
    /** 
     * Holds the pointer to the native SkColorFilter instance. 
     * 
     * @hide 
     */  
    public long native_instance;  
  
    @Override  
    protected void finalize() throws Throwable {  
        try {  
            super.finalize();  
        } finally {  
            destroyFilter(native_instance);  
        }  
    }  
  
    static native void destroyFilter(long native_instance);  
}
</code></pre>

<p>由此根据我们的经验，判断ColorFilter可能是个父类，具体实现可能下面还有子类完成的，于是再看Google的文档：</p>

<p><figure><img src="media/15561207870430/15713327420386.png" alt=""/></figure></p>

<p>一目了然了，ColorFilter下有3个子类ColorMatrixColorFilter, LightingColorFilter, PorterDuffColorFilter ，下面逐一学习一下。</p>

<h2 id="toc_1">ColorMatrixColorFilter</h2>

<p><code>ColorMatrixColorFilter</code>翻译为颜色矩阵过滤器，神马是颜色矩阵？实际上， 安卓中管理色彩矩阵是以RGBA像素点的方式加载到内存的，这些点统一使用<code>ColorMatrix</code>的矩阵来统一管理，矩阵定义为4*5的排列形式。那好，首先来看看<code>ColorMatrixColorFilter</code>的两个构造器：</p>

<pre class="line-numbers"><code class="language-java">public ColorMatrixColorFilter(ColorMatrix matrix) {  
        mMatrix.set(matrix);  
        update();  
}  
  
public ColorMatrixColorFilter(float[] array) {  
        if (array.length &lt; 20) {  
            throw new ArrayIndexOutOfBoundsException();  
        }  
        mMatrix.set(array);  
        update();  
}  
</code></pre>

<p>ColorMatrixColorFilter中一个构造器需要接收ColorMatrix对象，另一个需要接收一个4*5的float型数组，我们再打开Android Studio追踪一下mMatrix.set()方法，可以看到以上两个构造器里面调的set方法各自实现的方式</p>

<pre class="line-numbers"><code class="language-java">public void set(ColorMatrix src) {  
        System.arraycopy(src.mArray, 0, mArray, 0, 20);  
}  
  
public void set(float[] src) {  
        System.arraycopy(src, 0, mArray, 0, 20);  
}  
</code></pre>

<p>再追踪一下System.arraycopy()方法：</p>

<pre class="line-numbers"><code class="language-java">public static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length)
</code></pre>

<p>好了，到这里，其实已经很明白了，ColorMatrixColorFilter构造器中接收的两个不同的参数，实际上底层实现方式都是一样的，都是同样调用System.arraycopy()中带float数组参数的方法。所以我们不必再考虑怎么样去写一个ColorMatrix对象传递给ColorMatrixColorFilter了，实际上我们使用第二个构造器，传递一个float数组，会显得程序更加直观易懂，那么我们就尝试写一个ColorMatrixColorFilter，并且设置给Paint吧.</p>

<pre class="line-numbers"><code class="language-java">public class CustomView1 extends View {  
    private Paint mPaint;  
    private Context mContext;  
    public CustomView1(Context context) {  
        this(context, null);  
    }  
  
    public CustomView1(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initPaint();  
    }  
    private void initPaint() {  
        //初始化Paint，并且设置消除锯齿。  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        //设置画笔样式为描边  
        mPaint.setStyle(Paint.Style.FILL);  
        //设置描边的粗细，单位：像素px 注意：当setStrokeWidth(0)的时候描边宽度并不为0而是只占一个像素  
        mPaint.setStrokeWidth(20);  
        //设置画笔颜色为自定义颜色  
        mPaint.setColor(Color.argb(255, 255, 128, 102));  
        ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1, 0, 0, 0, 0,  
                0, 1, 0, 0, 0,  
                0, 0, 1, 0, 0,  
                0, 0, 0, 1, 0  
        });  
        mPaint.setColorFilter(colorFilter);  
    }  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //画一个圆形，取屏幕中心点为圆心  
        canvas.drawCircle(ScreenUtil.getScreenW(mContext) / 2,  
                ScreenUtil.getScreenH(mContext) / 2, 100, mPaint);  
    }  
}
</code></pre>

<p>看上面的例子程序，首先创建了一个ColorMatrixColorFilter对象，并且传递进去一个float型的4*5排列的数组，然后调用Paint的setColorFilter方法将ColorMatrixColorFilter对象传入，我们在模拟器上运行一下，duang~~，我去，什么变化都没有，还是岛国的旗帜。这是怎么回事？下面有必要在学习一下了：</p>

<p>其实一个4*5的float数组中分别对应的是RGBA的向量值，第一行代表的是R(红色)的向量值，第二行代表G(绿色)的向量值，第三行代表B(蓝色)的向量值，第四行代表A(透明度)的向量值，这4行分别代表不同的RGBA的向量值，并且值的取值范围是[0.0F , 2.0F]，当值为1.0F的时候，表示保持原有的色彩，不发生色彩便宜。so，如果我们想要将上面的红色的圈圈颜色变掉，就不能像上面的代码一样，将所有的向量值都设置为1.0F，下面我们修改一个：</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.5F, 0, 0, 0, 0,  
                0, 0.5F, 0, 0, 0,  
                0, 0, 0.5F, 0, 0,  
                0, 0, 0, 1, 0  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p>将上面的ColorMatrixColorFilter中的float数组替换成这样的<br/>
哎哟呵~颜色变深了，看起来神奇很多。那么，这个色彩矩阵以及这个float数组是怎样做到的呢？或者说是怎样通过计算后得到另外一个色彩值的呢？下面作图来说明一下，我们顶一个ColorMatrix的4*5的float型数组，然后定义一个我们自己MyColor，分别代表RGBA的值：</p>

<p><figure><img src="media/15561207870430/15713327557838.jpg" alt=""/></figure></p>

<p>实际上，安卓系统计算色彩值是用矩阵相乘的方式得出的，如上图的样子。这里的MyColor的各项值都要转换到[0,1]之间的值，下面就是我们实际转换的计算方式和结果了。</p>

<p><figure><img src="media/15561207870430/15713327650356.jpg" alt=""/></figure></p>

<p>通过上面的计算，我们得到了最终的RGBA的值是（0.5,0.25,0.2,1），说明RGB色彩值都发生了便宜，只有A未偏移，然后我们将这些值乘以255后还原一下看看，是不是跟上图的圈圈的色彩值是一致的呢，好吧，别看了，肯定必须一定是一样的。那么了解色彩矩阵有什么用呢？上面简单的更换一下色彩值而已，Paint类下也提供了setColor()方法，直接将色彩值设置上去，都TMD的方便，还搞什么玩意的矩阵，显得自己牛逼+蛋疼是不是？解释一下，上面的例子不过是个例子而已啊，真正开发的时候肯定是setColor比较简便嘛。问题来了，我们有可能处理的不是一个纯色彩的东西，而是一直图片呢？一张图片是有几十万中色彩值的，这时候setColor()就不可能让他们变色了吧，还是得用色彩矩阵来搞这玩意。下面我们从drawable目录下加载一张图片吧！</p>

<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>

<p><figure><img src="media/15561207870430/15713327784421.png" alt=""/></figure></p>

<p>好了图片加载完毕，代码没有难度，上面的Paint没有做任何的处理，下面我们为Paint设置色彩过滤器吧！</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0, 0, 0, 1, 0,  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p><figure><img src="media/15561207870430/15713327887731.png" alt=""/></figure></p>

<p>好吧图片变成黑白的了，难道setColor()也可以办吗？再改一个试试：</p>

<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                0, 0, 0, 1, 0,  
        });  
mPaint.setColorFilter(colorFilter);  
</code></pre>

<p><figure><img src="media/15561207870430/15713328018868.png" alt=""/></figure></p>

<p>这样的效果是不是有点像负片效果啊！好了，反正我也不懂图像学，ColorMatrixColorFilter想设置什么样的就改改矩阵就行了，到底需要什么效果，效果的值要设置成多少，我也不知道，问问美工吧！我们只负责写程序！呵呵~~</p>

<h2 id="toc_2">LightingColorFilter</h2>

<p>LightingColorFilter顾名思义就是“光照色彩过滤器”，就是模拟一个光照照过图像所产生的效果，构造器是这样的：<br/>
<code>public LightingColorFilter(int mul, int add)</code><br/><br/>
查看一下Google文档，是这样介绍滴：</p>

<p>光照色彩滤光片，可以用来模拟简单的照明效果。一个lightingcolorfilter定义了两个参数，一个用于与源颜色相乘（称为colormultiply）和一个用于添加到源颜色（称为coloradd）。alpha通道是原封不动的彩色滤光片。给定一个源颜色的RGB，由此产生的特定颜色计算如下：</p>

<pre class="line-numbers"><code class="language-text">R&#39; = R * colorMultiply.R + colorAdd.R
G&#39; = G * colorMultiply.G + colorAdd.G
B&#39; = B * colorMultiply.B + colorAdd.B
</code></pre>

<p>每个通道值的结果范围是0~255。上面的介绍写的比较明白， 算法也很简单，我们以上面的原图为例，看见蓝天了吗，我们现在去掉这个蓝色的天。根据这个短发描述呢，我们仅仅去掉蓝色，就要将蓝色的通道值改变，将B计算为其它值，这时候colorMultiply.B = 00，colorAdd.B =00，计算得到的B = 00，其它的通道R和G均不变，那么,colorAdd.R=0，colorAdd.G =0；colorMultiply.R = FF，colorMultiply.G =FF，Alpha通道A是忽略的，所以随便设置什么都不会有变化的。</p>

<pre class="line-numbers"><code class="language-java">LightingColorFilter colorFilter = new LightingColorFilter(0xFFFFFF00, 0x00000000);  
mPaint.setColorFilter(colorFilter);
</code></pre>

<p>运行之后的结果，蓝天没了。</p>

<p><figure><img src="media/15561207870430/15713328128205.png" alt=""/></figure></p>

<h2 id="toc_3">PorterDuffColorFilter</h2>

<p>ColorFilter下还有最后一个子类，PorterDuff混合模式的色彩过滤器，下面是其构造器：<br/>
<code>public PorterDuffColorFilter(int color, PorterDuff.Mode mode)</code></p>

<p>Google文档：PorterDuff滤光器可以用于点源像素使用一个单一的颜色和一个特定的波特达夫复合模式。</p>

<p>PorterDuffColorFilter的构造器也很简单，其中第一个参数表示一个16进制的色彩值，第二个参数是一个枚举值PorterDuff.Mode，表示图片混排的模式，PorterDuff.Mode在Android下一共有16种。下面我们先写一个小例子看一下，这里我们还是使用上面的图片，为原图添加图片混排模式，颜色值设置为红色0XFFFF0000，混排模式设置为PorterDuff.Mode.DARKEN。</p>

<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(0XFFFF0000, PorterDuff.Mode.DARKEN);  
        mPaint.setColorFilter(colorFilter);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>

<p>上面的图片就是运行之后的效果了，原图不仅变红了，而且还变暗了。其实我们这里将PorterDuffColorFilter的构造器参数拆开来分析一下，首先我们传递进去一个红色的颜色值0XFFFF0000，这里相当于创建了一张新的图层，图层的颜色就是0XFFFF0000，而我们的原图可以看作是第二张图层，我们先把这2个图片重叠放在一起，就会发现得到一个原图上很红的图片，然后我们看一下PorterDuff.Mode是DARKEN模式，表示在之前得到的“原图+很红”的图片上进一步将色调调成暗色，最终得到了如上所示的图片。</p>

<p>关于PorterDuff.Mode，Android系统一共提供了18种混排模式，在模拟器的ApiDemos/Graphics/XferModes，有张效果图：</p>

<p><figure><img src="media/15561207870430/15713328265702.png" alt=""/></figure></p>

<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式算法，其中比上图多了ADD和OVERLAY两种模式：</p>

<p><figure><img src="media/15561207870430/15713328371456.png" alt=""/></figure></p>

<p>其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面是在网上找到的汉字语言描述，感谢这位作者的总结。</p>

<p>注意：先绘制dst，再绘制src。</p>

<ul>
<li><strong>1.PorterDuff.Mode.CLEAR</strong>    所绘制源图像不会提交到画布上。</li>
<li><strong>2.PorterDuff.Mode.SRC</strong>    只显示源图像。</li>
<li><strong>3.PorterDuff.Mode.DST</strong>    只显示目标图像。</li>
<li><strong>4.PorterDuff.Mode.SRC_OVER</strong>    正常绘制显示，源图像居上显示。</li>
<li><strong>5.PorterDuff.Mode.DST_OVER</strong>    上下层都显示。目标图像居上显示。</li>
<li><strong>6.PorterDuff.Mode.SRC_IN</strong>    取两层绘制交集中的源图像。</li>
<li><strong>7.PorterDuff.Mode.DST_IN</strong>     取两层绘制交集中的目标图像。</li>
<li><strong>8.PorterDuff.Mode.SRC_OUT</strong>    只在源图像和目标图像不相交的地方绘制源图像。</li>
<li><strong>9.PorterDuff.Mode.DST_OUT</strong>    只在源图像和目标图像不相交的地方绘制目标图像。</li>
<li><strong>10.PorterDuff.Mode.SRC_ATOP</strong>    在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。</li>
<li><strong>11.PorterDuff.Mode.DST_ATOP</strong>   在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。</li>
<li><strong>12.PorterDuff.Mode.XOR</strong>    异或：去除两图层交集部分</li>
<li><strong>13.PorterDuff.Mode.DARKEN</strong>     取两图层全部区域，交集部分颜色加深</li>
<li><strong>14.PorterDuff.Mode.LIGHTEN</strong>   取两图层全部，点亮交集部分颜色</li>
<li><strong>15.PorterDuff.Mode.MULTIPLY</strong>    取两图层交集部分叠加后颜色</li>
<li><strong>16.PorterDuff.Mode.SCREEN</strong>    滤色。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870348.html">
                
                  <h1>Android-ViewStub详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在开发应用程序的时候，经常会遇到这样的情况，会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为<code>View.GONE</code>，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见<code>View.GONE</code>但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</p>

<h2 id="toc_1">ViewStub</h2>

<p>上面的问题，推荐的做法是使用 Android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了<code>ViewStub.inflate()</code>的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。<br/>
但ViewStub也不是万能的，下面总结下ViewStub能做的事儿和什么时候该用ViewStub，什么时候该用可见性的控制。</p>

<h2 id="toc_2">特点</h2>

<ul>
<li>ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不能够再通过ViewStub来控制它了。</li>
<li>ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</li>
</ul>

<h2 id="toc_3">可以考虑使用ViewStub的情况</h2>

<ul>
<li>在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要<em>在运行时不止一次的显示和隐藏某个布局</em>，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。</li>
<li>想要控制显示与隐藏的是一个布局文件，而非某个View。因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。</li>
</ul>

<h2 id="toc_4">下面来看一个实例</h2>

<p>在这个例子中，要显示二种不同的布局，一个是用TextView显示一段文字，另一个则是用ImageView显示一个图片。这二个是在onCreate()时决定是显示哪一个，这里就是应用ViewStub的最佳地点。</p>

<p>先来看看布局，一个是主布局，里面只定义二个ViewStub，一个用来控制TextView一个用来控制ImageView，另外就是一个是为显示文字的做的TextView布局，一个是为ImageView而做的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;fill_parent&quot;  
  android:layout_height=&quot;fill_parent&quot;  
  android:gravity=&quot;center_horizontal&quot;&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_text&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout_marginTop=&quot;10dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_text_layout&quot;/&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_image&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_image_layout&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>为TextView的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;TextView  
        android:id=&quot;@+id/viewstub_demo_textview&quot;  
        android:layout_width=&quot;fill_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:background=&quot;#aa664411&quot;  
        android:textSize=&quot;16sp&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>为ImageView的布局：</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;ImageView  
        android:id=&quot;@+id/viewstub_demo_imageview&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>

<p>下面来看代码，决定来显示哪一个，只需要找到相应的ViewStub然后调用其infalte()就可以获得相应想要的布局：</p>

<pre class="line-numbers"><code class="language-java">public class ViewStubDemoActivity extends Activity {  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.viewstub_demo_activity);  
        if ((((int) (Math.random() * 100)) &amp; 0x01) == 0) {  
            // to show text  
            // all you have to do is inflate the ViewStub for textview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_text);  
            stub.inflate();  
            TextView text = (TextView) findViewById(R.id.viewstub_demo_textview);  
            text.setText(&quot;The tree of liberty must be refreshed from time to time&quot; +  
                    &quot; with the blood of patroits and tyrants! Freedom is nothing but &quot; +  
                    &quot;a chance to be better!&quot;);  
        } else {  
            // to show image  
            // all you have to do is inflate the ViewStub for imageview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_image);  
            stub.inflate();  
            ImageView image = (ImageView) findViewById(R.id.viewstub_demo_imageview);  
            image.setImageResource(R.drawable.happy_running_dog);  
        }  
    }  
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_8.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_10.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16155265432695.html">混入（mixin）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16145671673295.html">多态</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
