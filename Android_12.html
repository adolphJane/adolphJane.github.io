<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207869006.html">
                
                  <h1>Mac安装配置appium</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>因为公司需求，需要安装Appium来实现对手机APP的自动化测试，提升工作效率。所以来学习并记录一下Appium的安装以及使用的步骤，方便自己以后对App测试环境搭建的操作。</p>

<h2 id="toc_1">一、安装Appium</h2>

<h3 id="toc_2">(二) 安装Homebrew</h3>

<ul>
<li><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;  #下载</code></li>
<li><code>$ brew update #更新</code></li>
<li><code>$ brew -v #查看是否安装好，以及其版本号</code></li>
</ul>

<h3 id="toc_3">(三) 安装Node.js</h3>

<p>使用homebrew来安装Node.js </p>

<ul>
<li><code>$ brew install node #安装</code></li>
<li><code>$ node -v #查看是否安装好，以及其版本号</code></li>
</ul>

<h3 id="toc_4">(四) 安装npm</h3>

<ul>
<li><code>$ brew install npm</code></li>
</ul>

<h3 id="toc_5">(五) 安装appium服务端</h3>

<p>推荐使用cnpm来安装：<a href="https://npm.taobao.org/">淘宝 NPM 镜像</a> 10分钟同步npmjs.org镜像，使用方式和npm完全一致</p>

<ul>
<li><code>$ npm install cnpm -g --registry=https://registry.npm.taobao.org</code></li>
<li><code>$ npm view appium versions #查看appium所有的版本号</code></li>
<li><code>$ cnpm install -g appium --no-cache $ cnpm install -g appium $ cnpm install -g appium-doctor</code></li>
</ul>

<h3 id="toc_6">(六) 检查appium环境检测</h3>

<p>在环境监测中打叉的就是没安装成功或者环境没有配置完全的</p>

<ul>
<li><code>appium-doctor</code></li>
</ul>

<h4 id="toc_7">1、appium环境常见问题解决</h4>

<h5 id="toc_8">(1) Xcode Command Line Tools are NOT installed!</h5>

<pre><code class="language-text">- `xcode-select --install   #按照提示安装即可`
</code></pre>

<h5 id="toc_9">(2) Carthage was NOT found</h5>

<pre><code class="language-text">- `$ brew install carthage       #carthage：类似cocoapods管理第三方代码，自动将工程编译为动态库，所以仅支持iOS8以上`
</code></pre>

<h5 id="toc_10">(3) ANDROID_HOME is NOT set!</h5>

<pre><code class="language-text">- 使用最新版本Java
- 修改Mac的开发环境
- `vi .bash_profile`
- `export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk(版本记得改)/Contents/Home`
- `export ANDROID_HOME=/Users/YourMacName/Library/Android/sdk`
- `export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:${JAVA_HOME}/bin`
- 修改完配置文件记得保存退出，然后`source .bash_profile`
- 如果有问题记得修改在终端的Shall打开方式，调整为命令
</code></pre>

<h3 id="toc_11">(七) 安装appium客户端（Python为例）</h3>

<ul>
<li><code>brew search python   #查看可安装的python版本</code></li>
<li><code>brew install python3     #安装python3</code></li>
<li><code>pip install Appium-Python-Client   #安装python客户端</code>  </li>
</ul>

<h3 id="toc_12">(八) 安装支持iOS测试的插件</h3>

<ul>
<li><code>$ brew install libimobiledevice --HEAD  # install from HEAD to get important updates</code></li>
<li><code>$ brew install ideviceinstaller         # 只是对iOS9有用</code></li>
<li><code>$ npm install -g ios-deploy                # iOS10 以后的版本安装ios-deploy</code></li>
<li><code>$ sudo gem install xcpretty            # 真机需要安装 xcpretty</code></li>
</ul>

<h2 id="toc_13">二、Appium测试</h2>

<h3 id="toc_14">(一) iOS模拟器测试</h3>

<ul>
<li><code>xcodebuild -sdk iphonesimulator   #在xcodeproj项目工程目录下执行，编译生成build文件夹，并在其中生成app文件</code></li>
<li><code>npm install -g authorize-ios   #安装iOS模拟器启动器</code> </li>
<li><code>sudo authorize-ios   #启动iOS模拟器</code> </li>
<li><code>appium &amp;    #启动appium服务器</code> </li>
<li><code>python ***.py     #另开一个终端执行python脚本</code> </li>
<li>iOS模拟器自动开启，安装应用并开始执行测试脚本</li>
</ul>

<h3 id="toc_15">(二) Android模拟器测试</h3>

<ul>
<li><code>appium -a 127.0.0.1 -p 4723 -U db3489d --no-reset</code></li>
</ul>

<h2 id="toc_16">三、Appium命令</h2>

<h3 id="toc_17">(一) 服务端启动命令</h3>

<p><strong>服务器标志</strong><br/>
所有的标志都是可选的，但是有一些标志需要组合在一起才能生效。</p>

<table>
<thead>
<tr>
<th>标志</th>
<th>默认值</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>

<tbody>
<tr>
<td>--shell</td>
<td>null</td>
<td>进入 REPL 模式</td>
<td></td>
</tr>
<tr>
<td>--localizable-strings-dir</td>
<td>en.lproj</td>
<td>IOS only: 定位 .strings所在目录的相对路径</td>
<td>--localizable-strings-dir en.lproj</td>
</tr>
<tr>
<td>--app</td>
<td>null</td>
<td>iOS: 基于模拟器编译的 app 的绝对路径或者设备目标的 bundle_id； Android: apk 文件的绝对路径--app /abs/path/to/my.app</td>
<td></td>
</tr>
<tr>
<td>--ipa</td>
<td>null</td>
<td>(IOS-only) .ipa 文件的绝对路径</td>
<td>--ipa /abs/path/to/my.ipa</td>
</tr>
<tr>
<td>-U, --udid</td>
<td>null</td>
<td>连接物理设备的唯一设备标识符</td>
<td>--udid 1adsf-sdfas-asdf-123sdf</td>
</tr>
<tr>
<td>-a, --address</td>
<td>0.0.0.0</td>
<td>监听的 ip 地址</td>
<td>--address 0.0.0.0</td>
</tr>
<tr>
<td>-p, --port</td>
<td>4723</td>
<td>监听的端口</td>
<td>--port 4723</td>
</tr>
<tr>
<td>-ca, --callback-address</td>
<td>null</td>
<td>回调IP地址 (默认: 相同的IP地址)</td>
<td>--callback-address 127.0.0.1</td>
</tr>
<tr>
<td>-cp, --callback-port</td>
<td>null</td>
<td>回调端口号 (默认: 相同的端口号)</td>
<td>--callback-port 4723</td>
</tr>
<tr>
<td>-bp, --bootstrap-port</td>
<td>4724</td>
<td>(Android-only) 连接设备的端口号</td>
<td>--bootstrap-port 4724</td>
</tr>
<tr>
<td>-k, --keep-artifacts</td>
<td>false</td>
<td>弃用，无效。trace信息现在保留tmp目录下，每次运行前会清除该目录中的信息。 也可以参考 –trace-dir 。</td>
<td></td>
</tr>
<tr>
<td>-r, --backend-retries</td>
<td>3</td>
<td>(iOS-only) 遇到 crash 或者 超时，Instrument 重新启动的次数。</td>
<td>--backend-retries 3</td>
</tr>
<tr>
<td>--session-override</td>
<td>false</td>
<td>允许 session 被覆盖 (冲突的话)</td>
<td></td>
</tr>
<tr>
<td>--full-reset</td>
<td>false</td>
<td>(iOS) 删除整个模拟器目录。 (Android) 通过卸载应用（而不是清除数据）重置应用状态。在 Android 上，session 完成后也会删除应用。</td>
<td></td>
</tr>
<tr>
<td>--no-reset</td>
<td>false</td>
<td>session 之间不重置应用状态 (iOS: 不删除应用的 plist 文件； Android: 在创建一个新的 session 前不删除应用。)</td>
<td></td>
</tr>
<tr>
<td>-l, --pre-launch</td>
<td>false</td>
<td>在第一个 session 前，预启动应用 (iOS 需要 –app 参数，Android 需要 –app-pkg 和 –app-activity)</td>
<td></td>
</tr>
<tr>
<td>-lt, --launch-timeout  90000   (iOS-only) 等待 Instruments 启动的时间</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g, --log</td>
<td>null</td>
<td>将日志输出到指定文件</td>
<td>--log /path/to/appium.log</td>
</tr>
<tr>
<td>--log-level</td>
<td>debug</td>
<td>日志级别; 默认 (console[:file]): debug[:debug]</td>
<td>--log-level debug</td>
</tr>
<tr>
<td>--log-timestamp</td>
<td>false</td>
<td>在终端输出里显示时间戳</td>
<td></td>
</tr>
<tr>
<td>--local-timezone</td>
<td>false</td>
<td>使用本地时间戳</td>
<td></td>
</tr>
<tr>
<td>--log-no-colors</td>
<td>false</td>
<td>不在终端输出中显示颜色</td>
<td></td>
</tr>
<tr>
<td>-G, --webhook</td>
<td>null</td>
<td>同时发送日志到 HTTP 监听器</td>
<td>--webhook localhost:9876</td>
</tr>
<tr>
<td>--native-instruments-lib</td>
<td>false</td>
<td>(IOS-only) iOS 内建了一个怪异的不可能避免的延迟。我们在 Appium 里修复了它。如果你想用原来的，你可以使用这个参数。</td>
<td></td>
</tr>
<tr>
<td>--app-pkg</td>
<td>null</td>
<td>(Android-only) 你要运行的apk的java包。 (例如， com.example.android.myApp)</td>
<td>--app-pkg com.example.android.myApp</td>
</tr>
<tr>
<td>--app-activity</td>
<td>null</td>
<td>(Android-only) 打开应用时，启动的 Activity 的名字(比如， MainActivity)</td>
<td>--app-activity MainActivity</td>
</tr>
<tr>
<td>--app-wait-package</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 的包名。(比如， com.example.android.myApp)</td>
<td>--app-wait-package com.example.android.myApp</td>
</tr>
<tr>
<td>--app-wait-activity</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 名字(比如， SplashActivity)</td>
<td>--app-wait-activity SplashActivity</td>
</tr>
<tr>
<td>--android-coverage</td>
<td>false</td>
<td>(Android-only) 完全符合条件的 instrumentation 类。 作为命令 adb shell am instrument -e coverage true -w 的 -w 的参数</td>
<td>--android-coverage com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td>
</tr>
<tr>
<td>--avd</td>
<td>null</td>
<td>(Android-only) 要启动的 avd 的名字</td>
<td></td>
</tr>
<tr>
<td>--avd-args</td>
<td>null</td>
<td>(Android-only) 添加额外的参数给要启动avd</td>
<td>--avd-args -no-snapshot-load</td>
</tr>
<tr>
<td>--device-ready-timeout</td>
<td>5</td>
<td>(Android-only) 等待设备准备好的时间，以秒为单位</td>
<td>--device-ready-timeout 5</td>
</tr>
<tr>
<td>--safari</td>
<td>false</td>
<td>(IOS-Only) 使用 Safari 应用</td>
<td></td>
</tr>
<tr>
<td>--device-name</td>
<td>null</td>
<td>待使用的移动设备名字</td>
<td>--device-name iPhone Retina (4-inch), Android Emulator</td>
</tr>
<tr>
<td>--platform-name</td>
<td>null</td>
<td>移动平台的名称: iOS, Android, or FirefoxOS</td>
<td>--platform-name iOS</td>
</tr>
<tr>
<td>--platform-version</td>
<td>null</td>
<td>移动平台的版本</td>
<td>--platform-version 7.1</td>
</tr>
<tr>
<td>--automation-name</td>
<td>null</td>
<td>自动化工具的名称: Appium or Selendroid</td>
<td>--automation-name Appium</td>
</tr>
<tr>
<td>--browser-name</td>
<td>null</td>
<td>移动浏览器的名称: Safari or Chrome</td>
<td>--browser-name Safari</td>
</tr>
<tr>
<td>--default-device, -dd</td>
<td>false</td>
<td>(IOS-Simulator-only) 使用instruments自己启动的默认模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-iphone</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPhone 模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-ipad</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPad 模拟器</td>
<td></td>
</tr>
<tr>
<td>--language</td>
<td>null</td>
<td>iOS / Android 模拟器的语言</td>
<td>--language en</td>
</tr>
<tr>
<td>--locale</td>
<td>null</td>
<td>Locale for the iOS simulator / Android Emulator</td>
<td>--locale en_US</td>
</tr>
<tr>
<td>--calendar-format</td>
<td>null</td>
<td>(IOS-only) iOS 模拟器的日历格式</td>
<td>--calendar-format gregorian</td>
</tr>
<tr>
<td>--orientation</td>
<td>null</td>
<td>(IOS-only) 初始化请求时，使用 LANDSCAPE (横屏) 或者 PORTRAIT (竖屏)</td>
<td>--orientation LANDSCAPE</td>
</tr>
<tr>
<td>--tracetemplate</td>
<td>null</td>
<td>(IOS-only) 指定 Instruments 使用的 tracetemplate 文件</td>
<td>--tracetemplate /Users/me/Automation.tracetemplate</td>
</tr>
<tr>
<td>--show-sim-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 模拟器的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--show-ios-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 系统的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--nodeconfig</td>
<td>null</td>
<td>指定 JSON 格式的配置文件 ，用来在 selenium grid 里注册 appiumd</td>
<td>--nodeconfig /abs/path/to/nodeconfig.json</td>
</tr>
<tr>
<td>-ra, --robot-address</td>
<td>0.0.0.0</td>
<td>robot 的 ip 地址</td>
<td>--robot-address 0.0.0.0</td>
</tr>
<tr>
<td>-rp, --robot-port</td>
<td>-1</td>
<td>robot 的端口地址</td>
<td>--robot-port 4242</td>
</tr>
<tr>
<td>--selendroid-port</td>
<td>8080</td>
<td>用来和 Selendroid 交互的本地端口</td>
<td>--selendroid-port 8080</td>
</tr>
<tr>
<td>--chromedriver-port</td>
<td>9515</td>
<td>ChromeDriver运行的端口</td>
<td>--chromedriver-port 9515</td>
</tr>
<tr>
<td>--chromedriver-executable</td>
<td>null</td>
<td>ChromeDriver 可执行文件的完整路径</td>
<td></td>
</tr>
<tr>
<td>--use-keystore</td>
<td>false</td>
<td>(Android-only) 设置签名 apk 的 keystore</td>
<td></td>
</tr>
<tr>
<td>--keystore-path</td>
<td>(Android-only) keystore 的路径</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--keystore-password</td>
<td>android</td>
<td>(Android-only) keystore 的密码</td>
<td></td>
</tr>
<tr>
<td>--key-alias</td>
<td>androiddebugkey</td>
<td>(Android-only) Key 的别名</td>
<td></td>
</tr>
<tr>
<td>--key-password</td>
<td>android</td>
<td>(Android-only) Key 的密码</td>
<td></td>
</tr>
<tr>
<td>--show-config</td>
<td>false</td>
<td>打印 Appium 服务器的配置信息，然后退出</td>
<td></td>
</tr>
<tr>
<td>--no-perms-check</td>
<td>false</td>
<td>跳过Appium对是否可以读/写必要文件的检查</td>
<td></td>
</tr>
<tr>
<td>--command-timeout</td>
<td>60</td>
<td>默认所有会话的接收命令超时时间 (在超时时间内没有接收到新命令，自动关闭会话)。 会被新的超时时间覆盖</td>
<td></td>
</tr>
<tr>
<td>--keep-keychains</td>
<td>false</td>
<td>(iOS) 当 Appium 启动或者关闭的时候，是否保留 keychains (Library/Keychains)</td>
<td></td>
</tr>
<tr>
<td>--strict-caps</td>
<td>false</td>
<td>如果所选设备是appium不承认的有效设备，会导致会话失败</td>
<td></td>
</tr>
<tr>
<td>--isolate-sim-device</td>
<td>false  Xcode 6存在一个bug，那就是一些平台上如果其他模拟器设备先被删除时某个特定的模拟器只能在没有任何错误的情况下被建立。这个选项导致了Appium不得不删除除了正在使用设备以外其他所有的设备。请注意这是永久性删除，你可以使用simctl或xcode管理被Appium使用的设备类别。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--tmp</td>
<td>null</td>
<td>可以被Appium用来管理临时文件的目录（绝对路径），比如存放需要移动的内置iOS应用程序。 默认的变量为 APPIUM_TMP_DIR ，在 *nix/Mac 为 /tmp 在windows上使用环境便令 TEMP 设定的目录。</td>
<td></td>
</tr>
<tr>
<td>--trace-dir</td>
<td>null</td>
<td>用于保存iOS instruments trace的 appium 目录，是绝对路径， 默认为 /appium-instruments</td>
<td></td>
</tr>
<tr>
<td>--intent-action</td>
<td>android.intent.action.MAIN</td>
<td>(Android-only) 用于启动 activity 的intent action</td>
<td>--intent-action android.intent.action.MAIN</td>
</tr>
<tr>
<td>--intent-category</td>
<td>android.intent.category.LAUNCHER</td>
<td>(Android-only) 用于启动 activity 的intent category</td>
<td>--intent-category android.intent.category.APP_CONTACTS</td>
</tr>
<tr>
<td>--intent-flags</td>
<td>0x10200000</td>
<td>(Android-only) 启动 activity 的标志</td>
<td>--intent-flags 0x10200000</td>
</tr>
<tr>
<td>--intent-args</td>
<td>null</td>
<td>(Android-only) 启动 activity 时附带额外的 intent 参数</td>
<td>--intent-args 0x10200000</td>
</tr>
<tr>
<td>--suppress-adb-kill-server</td>
<td>false</td>
<td>(Android-only) 如果被设定，阻止Appium杀掉adb实例。</td>
<td></td>
</tr>
</tbody>
</table>

<h3 id="toc_18">(二) Android测试用例编写</h3>

<h4 id="toc_19">1、例子:</h4>

<pre><code class="language-python">import os

import unittest
from appium import webdriver
from time import sleep

PATH = lambda p: os.path.abspath(
    os.path.join(os.path.dirname(__file__),p)
)

class XingQiuAndroidTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps[&#39;deviceName&#39;] = &#39;emulator-5554&#39;  #adb devices查到的设备名
        desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
        desired_caps[&#39;platformVersion&#39;] = &#39;4.4&#39;
        desired_caps[&#39;app&#39;] = PATH(
            &#39;../../../Users/jiangruoming/Desktop/***.apk&#39;
        )
        desired_caps[&#39;appPackage&#39;] = &#39;com.***.***&#39;  #被测App的包名
        desired_caps[&#39;appActivity&#39;] = &#39;.****&#39; #启动时的Activity

        self.driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

    #earDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出
    def tearDown(self):
        self.driver.quit()

    #放置的就是我们的测试脚本了，这部分我们并不陌生；因为我们执行的脚本就在这里。
    def test_add_contacts(self):
        el = self.driver.find_element_by_id(&quot;com.***.***:id/sign_phone&quot;)
        el.click()

        phone_number = self.driver.find_element_by_id(&quot;com.***.***:id/et_user_phone&quot;)
        code = self.driver.find_element_by_id(&quot;com.***.***:id/et_smscode&quot;)
        phone_number.send_keys(&quot;*********&quot;)
        code.send_keys(&quot;****&quot;)

        btn = self.driver.find_element_by_id(&quot;com.***.***:id/btn_finish&quot;)
        btn.click()

if __name__ == &#39;__main__&#39;:
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuAndroidTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>

<h4 id="toc_20">2、测试流程</h4>

<h5 id="toc_21">(1) 启动Appium</h5>

<p><code>appium -a 127.0.0.1 -p 4723 --log /path/to/appium.log</code></p>

<h5 id="toc_22">(2) 启动Android模拟器</h5>

<p>由于测试apk不支持X86平台，所以Genymotion无法支持运行，原生arm模拟器运行过慢(胃都等疼了)。试过多个模拟器后，最终选定了夜神模拟器，效果还是不错的。但是由于其主要用于PC平台运行Android游戏，所以用于开发平台还是需要进行配置。</p>

<h6 id="toc_23">a、adb配置</h6>

<p>在Mac环境中加入adb的环境变量<br/><br/>
<code>vi .bash_profile</code><br/><br/>
<code>export PATH=/Users/Path/To/Android/sdk/platform-tools/:$PATH</code><br/><br/>
<code>source .bash_profile</code>  </p>

<h6 id="toc_24">b、adb连接</h6>

<p>之后进入夜神的包内容中在adb所在文件夹运行adb连接命令<br/><br/>
<code>adb connect 127.0.0.1:62001</code><br/>
这样<code>adb devices</code>就能显示夜神模拟器的Device ID</p>

<h5 id="toc_25">(3) 运行脚本</h5>

<h3 id="toc_26">(三) iOS测试用例编写</h3>

<h4 id="toc_27">1、例子:</h4>

<pre><code class="language-python">import unittest
import os
from appium import webdriver
from time import sleep


PATH = lambda p: os.path.abspath(
    os.path.join(os.path.dirname(__file__),p)
)

class XingQiuiOSTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps[&#39;platformName&#39;] = &#39;iOS&#39;
        desired_caps[&#39;platformVersion&#39;] = &#39;10.2&#39;
        desired_caps[&#39;deviceName&#39;] = &#39;iPhone Simulator&#39;
        desired_caps[&#39;app&#39;] = PATH(&#39;../../../Users/jiangruoming/Desktop/***.app&#39;)

        self.driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

    #def tearDown(self):
        #self.driver.quit()

    def test_add_contacts(self):

        el2 = self.driver.find_elements_by_accessibility_id(&#39;Allow&#39;)

        if el2:
            el2[0].click()

        el3 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeButton&#39;)[0]
        el3.click()

        el4 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeTextField&#39;)[0]
        el4.send_keys(&quot;15088678313&quot;)

        el5 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeTextField&#39;)[1]
        el5.send_keys(&quot;1234&quot;)

        el6 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeButton&#39;)[0]
        el6.click()

if __name__ == &#39;__main__&#39;:
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuiOSTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>

<h4 id="toc_28">2、XCUIElementType</h4>

<pre><code class="language-python">XCUIElementTypeAny,
    XCUIElementTypeUnknown,
    XCUIElementTypeApplication,
    XCUIElementTypeGroup,
    XCUIElementTypeWindow,
    XCUIElementTypeSheet,
    XCUIElementTypeDrawer,
    XCUIElementTypeAlert,
    XCUIElementTypeDialog,
    XCUIElementTypeButton,
    XCUIElementTypeRadioButton,
    XCUIElementTypeRadioGroup,
    XCUIElementTypeCheckBox,
    XCUIElementTypeDisclosureTriangle,
    XCUIElementTypePopUpButton,
    XCUIElementTypeComboBox,
    XCUIElementTypeMenuButton,
    XCUIElementTypeToolbarButton,
    XCUIElementTypePopover,
    XCUIElementTypeKeyboard,
    XCUIElementTypeKey,
    XCUIElementTypeNavigationBar,
    XCUIElementTypeTabBar,
    XCUIElementTypeTabGroup,
    XCUIElementTypeToolbar,
    XCUIElementTypeStatusBar,
    XCUIElementTypeTable,
    XCUIElementTypeTableRow,
    XCUIElementTypeTableColumn,
    XCUIElementTypeOutline,
    XCUIElementTypeOutlineRow,
    XCUIElementTypeBrowser,
    XCUIElementTypeCollectionView,
    XCUIElementTypeSlider,
    XCUIElementTypePageIndicator,
    XCUIElementTypeProgressIndicator,
    XCUIElementTypeActivityIndicator,
    XCUIElementTypeSegmentedControl,
    XCUIElementTypePicker,
    XCUIElementTypePickerWheel,
    XCUIElementTypeSwitch,
    XCUIElementTypeToggle,
    XCUIElementTypeLink,
    XCUIElementTypeImage,
    XCUIElementTypeIcon,
    XCUIElementTypeSearchField,
    XCUIElementTypeScrollView,
    XCUIElementTypeScrollBar,
    XCUIElementTypeStaticText,
    XCUIElementTypeTextField,
    XCUIElementTypeDateField,
    XCUIElementTypeTimeField,
    XCUIElementTypeTextView,
    XCUIElementTypeMenu,
    XCUIElementTypeMenuItem,
    XCUIElementTypeMenuBar,
    XCUIElementTypeMenuBarItem,
    XCUIElementTypeMap,
    XCUIElementTypeWebView,
    XCUIElementTypeIncrementArrow,
    XCUIElementTypeDecrementArrow,
    XCUIElementTypeTimeline,
    XCUIElementTypeRatingIndicator,
    XCUIElementTypeValueIndicator,
    XCUIElementTypeSplitGroup,
    XCUIElementTypeSplitter,
    XCUIElementTypeRelevanceIndicator,
    XCUIElementTypeColorWell,
    XCUIElementTypeHelpTag,
    XCUIElementTypeMatte,
    XCUIElementTypeDockItem,
    XCUIElementTypeRuler,
    XCUIElementTypeRulerMarker,
    XCUIElementTypeGrid,
    XCUIElementTypeLevelIndicator,
    XCUIElementTypeCell,
    XCUIElementTypeLayoutArea,
    XCUIElementTypeLayoutItem,
    XCUIElementTypeHandle,
</code></pre>

<h4 id="toc_29">3、Appium Python API</h4>

<h5 id="toc_30">(1) contexts</h5>

<p><code>contexts(self)</code>:<br/><br/>
Returns the contexts within the current session.<br/>
返回当前会话中的上下文，使用后可以识别H5页面的控件<br/>
Usage:<br/><br/>
    <code>driver.contexts</code><br/><br/>
用法:<br/><br/>
    <code>driver.contexts</code></p>

<h5 id="toc_31">(2) current_context</h5>

<p><code>current_context(self)</code>:<br/><br/>
Returns the current context of the current session.<br/><br/>
返回当前会话的当前上下文<br/><br/>
Usage:<br/><br/>
    <code>driver.current_context</code><br/><br/>
用法:<br/><br/>
    <code>driver. current_context</code></p>

<h5 id="toc_32">(3) context</h5>

<p><code>context(self)</code>:<br/><br/>
Returns the current context of the current session.<br/><br/>
返回当前会话的当前上下文。<br/><br/>
Usage:<br/><br/>
    <code>driver.context</code><br/><br/>
用法:<br/><br/>
    <code>driver. Context</code></p>

<h5 id="toc_33">(4) find_element_by_ios_uiautomation</h5>

<p><code>find_element_by_ios_uiautomation(self, uia_string)</code>:<br/><br/>
Finds an element by uiautomation in iOS.<br/><br/>
通过iOS uiautomation查找元素<br/><br/>
Args:  </p>

<ul>
<li>uia_string - The element name in the iOS UIAutomation library<br/>
Usage:<br/>
<code>driver.find_element_by_ios_uiautomation(&#39;.elements()[1].cells()[2]&#39;)</code>
用法:<br/>
<code>dr. find_element_by_ios_uiautomation(‘elements’)</code></li>
</ul>

<h5 id="toc_34">(5) find_element_by_accessibility_id</h5>

<p><code>find_element_by_accessibility_id(self, id)</code>:<br/><br/>
Finds an element by accessibility id.<br/><br/>
通过accessibility id查找元素<br/><br/>
Args:<br/><br/>
    - id - a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize<br/><br/>
Usage:<br/><br/>
    <code>driver.find_element_by_accessibility_id()</code><br/><br/>
用法:<br/><br/>
    <code>driver.find_element_by_accessibility_id(‘id’)</code></p>

<h5 id="toc_35">(6) scroll</h5>

<p><code>scroll(self, origin_el, destination_el)</code>:<br/>
Scrolls from one element to another<br/><br/>
从元素origin_el滚动至元素destination_el<br/><br/>
Args:  </p>

<ul>
<li>originalEl - the element from which to being scrolling</li>
<li>destinationEl - the element to scroll to<br/>
Usage:<br/>
<code>driver.scroll(el1, el2)</code>
用法:<br/>
<code>driver.scroll(el1,el2)</code></li>
</ul>

<h5 id="toc_36">(7) drag_and_drop</h5>

<p><code>drag_and_drop(self, origin_el, destination_el)</code>:<br/><br/>
Drag the origin element to the destination element<br/><br/>
将元素origin_el拖到目标元素destination_el<br/><br/>
Args:  </p>

<ul>
<li>originEl - the element to drag</li>
<li>destinationEl - the element to drag to<br/>
用法:<br/>
<code>driver.drag_and_drop(el1,el2)</code></li>
</ul>

<h5 id="toc_37">(8) tap</h5>

<p><code>tap(self, positions, duration=None)</code>:<br/><br/>
Taps on an particular place with up to five fingers, holding for a certain time<br/><br/>
模拟手指点击（最多五个手指），可设置按住时间长度（毫秒）<br/><br/>
Args:</p>

<ul>
<li>positions - an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five.</li>
<li>duration - (optional) length of time to tap, in ms<br/>
Usage:<br/>
<code>driver.tap([(100, 20), (100, 60), (100, 100)], 500)</code>
用法:<br/>
<code>driver.tap([(x,y),(x1,y1)],500)</code></li>
</ul>

<h5 id="toc_38">(9) swipe</h5>

<p><code>swipe(self, start_x, start_y, end_x, end_y, duration=None)</code>:<br/><br/>
Swipe from one point to another point, for an optional duration.<br/><br/>
从A点滑动至B点，滑动时间为毫秒<br/><br/>
Args:<br/><br/>
    - start_x - x-coordinate at which to start<br/>
    - start_y - y-coordinate at which to start<br/>
    - end_x - x-coordinate at which to stop<br/>
    - end_y - y-coordinate at which to stop<br/>
    - duration - (optional) time to take the swipe, in ms.  </p>

<p>Usage:<br/><br/>
    <code>driver.swipe(100, 100, 100, 400)</code><br/>
用法:<br/><br/>
    <code>driver.swipe(x1,y1,x2,y2,500)</code></p>

<h5 id="toc_39">(10) flick</h5>

<p><code>flick(self, start_x, start_y, end_x, end_y)</code>:<br/><br/>
Flick from one point to another point.<br/><br/>
按住A点后快速滑动至B点<br/><br/>
Args:<br/><br/>
    - start_x - x-coordinate at which to start<br/>
    - start_y - y-coordinate at which to start<br/>
    - end_x - x-coordinate at which to stop<br/>
    - end_y - y-coordinate at which to stop<br/><br/>
Usage:<br/><br/>
    <code>driver.flick(100, 100, 100, 400)</code><br/>
用法:<br/><br/>
    <code>driver.flick(x1,y1,x2,y2)</code></p>

<h5 id="toc_40">(11) pinch</h5>

<p><code>pinch(self, element=None, percent=200, steps=50)</code>:<br/><br/>
Pinch on an element a certain amount<br/><br/>
在元素上执行模拟双指捏（缩小操作）<br/><br/>
Args:  </p>

<ul>
<li>element - the element to pinch</li>
<li>percent - (optional) amount to pinch. Defaults to 200%</li>
<li>steps - (optional) number of steps in the pinch action</li>
</ul>

<p>Usage:<br/><br/>
    <code>driver.pinch(element)</code><br/>
用法:<br/>
    <code>driver.pinch(element)</code></p>

<h5 id="toc_41">(12) zoom</h5>

<p><code>zoom(self, element=None, percent=200, steps=50)</code>:<br/>
Zooms in on an element a certain amount<br/><br/>
在元素上执行放大操作<br/><br/>
Args:  </p>

<ul>
<li>element - the element to zoom</li>
<li>percent - (optional) amount to zoom. Defaults to 200%</li>
<li>steps - (optional) number of steps in the zoom action</li>
</ul>

<p>Usage:<br/>
    <code>driver.zoom(element)</code><br/>
用法: <br/>
    <code>driver.zoom(element)</code></p>

<h5 id="toc_42">(13) reset</h5>

<p><code>reset(self)</code>:<br/><br/>
Resets the current application on the device.<br/><br/>
重置应用(类似删除应用数据)<br/><br/>
用法:<br/>
<code>driver.reset()</code></p>

<h5 id="toc_43">(14) hide_keyboard</h5>

<p><code>hide_keyboard(self, key_name=None, key=None, strategy=None)</code>:<br/>
Hides the software keyboard on the device. In iOS, use <code>key_name</code> to press a particular key, or <code>strategy</code>. In Android, no parameters are used.<br/>
隐藏键盘,iOS使用key_name隐藏，安卓不使用参数<br/>
Args:  </p>

<ul>
<li>key_name - key to press</li>
<li>strategy - strategy for closing the keyboard (e.g., <code>tapOutside</code>)</li>
</ul>

<p><code>driver.hide_keyboard()</code></p>

<h5 id="toc_44">(15) keyevent</h5>

<p><code>keyevent(self, keycode, metastate=None)</code>:<br/><br/>
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送按键码（安卓仅有），按键码可以上网址中找到<br/><br/>
Args:  </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>

<p>用法:<br/>
<code>dr.keyevent(‘4’)</code></p>

<h5 id="toc_45">(16) press_keycode</h5>

<p><code>press_keycode(self, keycode, metastate=None)</code>:<br/><br/>
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送按键码（安卓仅有），按键码可以上网址中找到<br/>
Args:   </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>

<p>用法: <br/>
<code>driver.press_ keycode(‘4’)</code>  </p>

<p>dr.keyevent(‘4’)与driver.press_ keycode(‘4’) 功能实现上一样的，都是按了返回键</p>

<h5 id="toc_46">(17) long_press_keycode</h5>

<p><code>long_press_keycode(self, keycode, metastate=None)</code>:<br/><br/>
Sends a long press of keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送一个长按的按键码（长按某键）<br/><br/>
Args:   </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent<br/>
用法:<br/>
<code>driver.long_press_keycode(‘4’)</code></li>
</ul>

<h5 id="toc_47">(18) current_activity</h5>

<p><code>current_activity(self)</code>:<br/><br/>
Retrieves the current activity on the device.<br/><br/>
获取当前的activity<br/><br/>
用法:<br/>
<code>print(driver.current_activity())</code></p>

<h5 id="toc_48">(19) wait_activity</h5>

<p><code>wait_activity(self, activity, timeout, interval=1)</code>:<br/><br/>
Wait for an activity: block until target activity presents or time out.<br/><br/>
This is an Android-only method.<br/><br/>
等待指定的activity出现直到超时，interval为扫描间隔1秒<br/><br/>
即每隔几秒获取一次当前的activity<br/><br/>
返回的True 或 False<br/><br/>
Agrs:</p>

<ul>
<li>activity - target activity</li>
<li>timeout - max wait time, in seconds</li>
<li>interval - sleep interval between retries, in seconds</li>
</ul>

<p>用法:<br/>
    <code>driver.wait_activity(‘.activity.xxx’,5,2)</code></p>

<h5 id="toc_49">(20) background_app</h5>

<p><code>background_app(self, seconds)</code>:<br/>
Puts the application in the background on the device for a certain duration.<br/><br/>
后台运行app多少秒<br/><br/>
Args:  </p>

<ul>
<li>seconds - the duration for the application to remain in the background<br/>
用法:
<code>driver.background_app(5)</code><br/>
置后台5秒后再运行</li>
</ul>

<h5 id="toc_50">(21) is_app_installed</h5>

<p><code>is_app_installed(self, bundle_id)</code>:<br/><br/>
Checks whether the application specified by <code>bundle_id</code> is installed on the device.<br/><br/>
检查app是否有安装<br/><br/>
返回 True or False<br/><br/>
Args:  </p>

<ul>
<li>bundle_id - the id of the application to query<br/></li>
</ul>

<p>用法: <br/>
<code>driver.is_app_installed(“com.xxxx”)</code></p>

<h5 id="toc_51">(22) install_app</h5>

<p><code>install_app(self, app_path)</code>:<br/><br/>
Install the application found at <code>app_path</code> on the device.<br/><br/>
安装app,app_path为安装包路径<br/><br/>
Args:  </p>

<ul>
<li>app_path - the local or remote path to the application to install</li>
</ul>

<p>用法:<br/><br/>
<code>driver.install_app(app_path)</code></p>

<h5 id="toc_52">(23) remove_app</h5>

<p><code>remove_app(self, app_id)</code>:<br/><br/>
Remove the specified application from the device.<br/><br/>
删除app<br/><br/>
Args:  </p>

<ul>
<li>app_id - the application id to be removed<br/></li>
</ul>

<p>用法: <br/>
<code>driver.remove_app(“com.xxx.”)</code></p>

<h5 id="toc_53">(24) launch_app</h5>

<p><code>launch_app(self)</code>:<br/><br/>
Start on the device the application specified in the desired capabilities.<br/><br/>
启动app<br/><br/>
用法:<br/><br/>
<code>driver.launch_app()</code></p>

<h5 id="toc_54">(25) close_app</h5>

<p><code>close_app(self)</code>:<br/><br/>
Stop the running application, specified in the desired capabilities, on the device.<br/><br/>
关闭app<br/><br/>
用法:<br/><br/>
<code>driver.close_app()</code><br/><br/>
启动和关闭app运行好像会出错</p>

<h5 id="toc_55">(26) start_activity</h5>

<p><code>start_activity(self, app_package, app_activity, **opts)</code>:<br/><br/>
Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened.<br/><br/>
This is an Android-only method.<br/><br/>
在测试过程中打开任意活动。如果活动属于另一个应用程序，该应用程序的启动和活动被打开。<br/><br/>
这是一个安卓的方法<br/><br/>
Args:</p>

<ul>
<li>app_package - The package containing the activity to start.</li>
<li>app_activity - The activity to start.</li>
<li>app_wait_package - Begin automation after this package starts (optional).</li>
<li>app_wait_activity - Begin automation after this activity starts (optional).</li>
<li>intent_action - Intent to start (optional).</li>
<li>intent_category - Intent category to start (optional).</li>
<li>intent_flags - Flags to send to the intent (optional).</li>
<li>optional_intent_arguments - Optional arguments to the intent (optional).</li>
<li>stop_app_on_reset - Should the app be stopped on reset (optional)?</li>
</ul>

<p>用法:<br/><br/>
<code>driver.start_activity(app_package, app_activity)</code></p>

<h5 id="toc_56">(27) lock</h5>

<p><code>lock(self, seconds)</code>:<br/><br/>
Lock the device for a certain period of time. iOS only.<br/><br/>
锁屏一段时间  iOS专有<br/><br/>
Args:  </p>

<ul>
<li>the duration to lock the device, in seconds</li>
</ul>

<p>用法:<br/><br/>
<code>driver.lock()</code></p>

<h5 id="toc_57">(28) shake</h5>

<p><code>shake(self)</code>:<br/><br/>
Shake the device.<br/><br/>
摇一摇手机<br/><br/>
用法:<br/><br/>
<code>driver.shake()</code></p>

<h5 id="toc_58">(29) open_notifications</h5>

<p><code>open_notifications(self)</code>:<br/><br/>
Open notification shade in Android (API Level 18 and above)<br/><br/>
打系统通知栏（仅支持API 18 以上的安卓系统）<br/><br/>
用法:<br/><br/>
<code>driver.open_notifications()</code></p>

<h5 id="toc_59">(30) network_connection</h5>

<p><code>network_connection(self)</code>:<br/><br/>
Returns an integer bitmask specifying the network connection type.<br/><br/>
Android only.<br/><br/>
返回网络类型  数值<br/><br/>
Possible values are available through the enumeration <code>appium.webdriver.ConnectionType</code><br/><br/>
用法:<br/><br/>
<code>driver.network_connection</code>  </p>

<h5 id="toc_60">(31) set_network_connection</h5>

<p><code>set_network_connection(self, connectionType)</code>:<br/><br/>
Sets the network connection type. Android only.<br/><br/>
Possible values:  </p>

<table>
<thead>
<tr>
<th>Value (Alias)</th>
<th>Data</th>
<th>Wifi</th>
<th>Airplane Mode</th>
</tr>
</thead>

<tbody>
<tr>
<td>0 (None)</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1 (Airplane Mode)</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2 (Wifi only)</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4 (Data only)</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6 (All network on)</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

<p>These are available through the enumeration appium.webdriver.ConnectionType`</p>

<p>设置网络类型<br/><br/>
Args:  </p>

<ul>
<li>connectionType - a member of the enum appium.webdriver.ConnectionType</li>
</ul>

<p>用法:<br/><br/>
先加载from appium.webdriver.connectiontype import ConnectionType<br/><br/>
<code>dr.set_network_connection(ConnectionType.WIFI_ONLY)</code><br/><br/>
ConnectionType的类型有<br/><br/>
NO_CONNECTION = 0<br/><br/>
AIRPLANE_MODE = 1<br/><br/>
WIFI_ONLY = 2<br/><br/>
DATA_ONLY = 4<br/><br/>
ALL_NETWORK_ON = 6  </p>

<h5 id="toc_61">(32) available_ime_engines</h5>

<p><code>available_ime_engines(self)</code>:<br/><br/>
Get the available input methods for an Android device. Package and activity are returned (e.g., [&#39;com.android.inputmethod.latin/.LatinIME&#39;])<br/><br/>
Android only.<br/><br/>
返回安卓设备可用的输入法<br/><br/>
用法:<br/><br/>
<code>print(driver.available_ime_engines)</code></p>

<h5 id="toc_62">(33) is_ime_active</h5>

<p><code>is_ime_active(self)</code>:<br/><br/>
Checks whether the device has IME service active. Returns True/False.<br/><br/>
Android only.<br/><br/>
检查设备是否有输入法服务活动。返回真/假。<br/><br/>
安卓<br/><br/>
用法: <br/>
    <code>print(driver.is_ime_active())</code></p>

<h5 id="toc_63">(34) activate_ime_engine</h5>

<p><code>activate_ime_engine(self, engine)</code>:<br/><br/>
Activates the given IME engine on the device.<br/><br/>
Android only.<br/><br/>
激活安卓设备中的指定输入法，设备可用输入法可以从“available_ime_engines”获取<br/><br/>
Args:  </p>

<ul>
<li>engine - the package and activity of the IME engine to activate (e.g.,&#39;com.android.inputmethod.latin/.LatinIME&#39;)<br/></li>
</ul>

<p>用法:<br/><br/>
    <code>driver.activate_ime_engine(“com.android.inputmethod.latin/.LatinIME”)</code></p>

<h5 id="toc_64">(35) deactivate_ime_engine</h5>

<p><code>deactivate_ime_engine(self)</code>:<br/><br/>
Deactivates the currently active IME engine on the device.<br/><br/>
Android only.<br/><br/>
关闭安卓设备当前的输入法<br/><br/>
用法:<br/>
    <code>driver.deactivate_ime_engine()</code></p>

<h5 id="toc_65">(36) active_ime_engine</h5>

<p><code>active_ime_engine(self)</code>:<br/><br/>
Returns the activity and package of the currently active IME engine (e.g.,&#39;com.android.inputmethod.latin/.LatinIME&#39;).<br/><br/>
Android only.<br/><br/>
返回当前输入法的包名<br/><br/>
用法:<br/><br/>
<code>driver.active_ime_engine</code>  </p>

<h5 id="toc_66">(37) toggle_location_services</h5>

<p><code>toggle_location_services(self)</code>:<br/><br/>
Toggle the location services on the device. Android only.<br/><br/>
打开安卓设备上的位置定位设置<br/><br/>
用法:<br/>
<code>driver.toggle_location_services()</code></p>

<h5 id="toc_67">(38) set_location</h5>

<p><code>set_location(self, latitude, longitude, altitude)</code>:<br/><br/>
Set the location of the device<br/><br/>
设置设备的经纬度<br/><br/>
Args:  </p>

<ul>
<li>latitude纬度 - String or numeric value between -90.0 and 90.00</li>
<li>longitude经度 - String or numeric value between -180.0 and 180.0</li>
<li>altitude海拔高度- String or numeric value</li>
</ul>

<p>用法:<br/><br/>
<code>driver.set_location(纬度，经度，高度)</code></p>

<h5 id="toc_68">(39) tag_name</h5>

<p><code>tag_name(self)</code>:<br/><br/>
This element&#39;s <code>tagName</code> property.<br/><br/>
返回元素的tagName属性<br/><br/>
经实践返回的是class name<br/><br/>
用法:<br/><br/>
<code>element.tag_name()</code></p>

<h5 id="toc_69">(40) text</h5>

<p><code>text(self)</code>:<br/><br/>
The text of the element.<br/><br/>
返回元素的文本值<br/><br/>
用法:<br/><br/>
<code>element.text()</code></p>

<h5 id="toc_70">(41) click</h5>

<p><code>click(self)</code>:<br/><br/>
Clicks the element.<br/><br/>
点击元素<br/><br/>
用法:<br/><br/>
<code>element.click()</code></p>

<h5 id="toc_71">(42) submit</h5>

<p><code>submit(self)</code>:<br/><br/>
Submits a form.<br/><br/>
提交表单<br/><br/>
用法:<br/><br/>
暂无</p>

<h5 id="toc_72">(43) clear</h5>

<p><code>clear(self)</code>:<br/><br/>
Clears the text if it&#39;s a text entry element.<br/><br/>
清除输入的内容<br/><br/>
用法:<br/><br/>
<code>element.clear()</code></p>

<h5 id="toc_73">(44) get_attribute</h5>

<p><code>get_attribute(self, name)</code>:<br/><br/>
详见@chenhengjie123 的超级链接<br/><br/>
Gets the given attribute or property of the element.  </p>

<pre><code class="language-text">1. 获取 content-desc 的方法为 get_attribute(&quot;name&quot;) ，而且还不能保证返回的一定是 content-desc （content-desc 为空时会返回 text 属性值）  
2. get_attribute 方法不是我们在 uiautomatorviewer 看到的所有属性都能获取的（此处的名称均为使用 get_attribute 时使用的属性名称)
可获取的：
字符串类型：
    `name(返回 content-desc 或 text)`
    `text(返回 text)`
    `className(返回 class，只有 API=&gt;18 才能支持)`
    `resourceId(返回 resource-id，只有 API=&gt;18 才能支持)`
</code></pre>

<p>This method will first try to return the value of a property with the given name. If a property with that name doesn&#39;t exist, it returns the value of the attribute with the same name. If there&#39;s no attribute with that name, <code>None</code> is returned.Values which are considered truthy, that is equals &quot;true&quot; or &quot;false&quot;,are returned as booleans.  All other non-<code>None</code> values are returned as strings.  For attributes or properties which do not exist, <code>None</code> is returned.</p>

<p>Args:</p>

<ul>
<li>name - Name of the attribute/property to retrieve.</li>
</ul>

<p>Example:<br/>
    # Check if the &quot;active&quot; CSS class is applied to an element.</p>

<p><code>is_active = &quot;active&quot; in target_element.get_attribute(&quot;class&quot;)</code></p>

<p>用法:<br/><br/>
暂无</p>

<h5 id="toc_74">(45) is_selected</h5>

<p><code>is_selected(self)</code>:<br/><br/>
Returns whether the element is selected.<br/><br/>
Can be used to check if a checkbox or radio button is selected.<br/><br/>
返回元素是否选择。<br/><br/>
可以用来检查一个复选框或单选按钮被选中。<br/><br/>
用法:<br/><br/>
<code>element.is_slected()</code></p>

<h5 id="toc_75">(46) is_enabled</h5>

<p><code>is_enabled(self)</code>:<br/><br/>
Returns whether the element is enabled.<br/><br/>
返回元素是否可用True of False<br/><br/>
用法:<br/><br/>
<code>element.is_enabled()</code></p>

<h5 id="toc_76">(47) find_element_by_id</h5>

<p><code>find_element_by_id(self, id_)</code>:<br/><br/>
Finds element within this element&#39;s children by ID.<br/><br/>
通过元素的ID定位元素<br/><br/>
Args:  </p>

<ul>
<li>id_ - ID of child element to locate.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_element_by_id(“id”)</code></p>

<h5 id="toc_77">(48) find_elements_by_id</h5>

<p><code>find_elements_by_id(self, id_)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by ID.<br/><br/>
通过元素ID定位,含有该属性的所有元素<br/><br/>
Args:   </p>

<ul>
<li>id_ - Id of child element to find.</li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_elements_by_id(“id”)</code></p>

<h5 id="toc_78">(49) find_element_by_name</h5>

<p><code>find_element_by_name(self, name)</code>:<br/><br/>
Finds element within this element&#39;s children by name.<br/><br/>
通过元素Name定位（元素的名称属性text）. <br/>
Args:  </p>

<ul>
<li>name - name property of the element to find.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_name(“name”)</code></p>

<h5 id="toc_79">(50) find_elements_by_name</h5>

<p><code>find_elements_by_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by name.<br/><br/>
通过元素Name定位（元素的名称属性text），含有该属性的所有元素. <br/>
Args:  </p>

<ul>
<li>name - name property to search for.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_name(“name”)</code></p>

<h5 id="toc_80">(51) find_element_by_link_text</h5>

<p><code>find_element_by_link_text(self, link_text)</code>:<br/><br/>
Finds element within this element&#39;s children by visible link text.<br/><br/>
通过元素可见链接文本定位. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_link_text(“text”)</code></p>

<h5 id="toc_81">(52) find_elements_by_link_text</h5>

<p><code>find_element_by_link_text(self, link_text)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by visible link text. <br/>
通过元素可见链接文本定位,含有该属性的所有元素. <br/>
Args:    </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p>用法: <br/>
<code>driver.find_elements_by_link_text(“text”)</code></p>

<h5 id="toc_82">(53) find_element_by_partial_link_text</h5>

<p><code>find_element_by_partial_link_text(self, link_text)</code>:<br/><br/>
Finds element within this element&#39;s children by partially visible link text.<br/><br/>
通过元素部分可见链接文本定位. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p><code>driver. find_element_by_partial_link_text(“text”)</code></p>

<h5 id="toc_83">(54) find_elements_by_partial_link_text</h5>

<p><code>find_elements_by_partial_link_text(self, link_text)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by link text.<br/><br/>
通过元素部分可见链接文本定位,含有该属性的所有元素. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p><code>driver. find_elements_by_partial_link_text(“text”)</code></p>

<h5 id="toc_84">(55) find_element_by_tag_name</h5>

<p><code>find_element_by_tag_name(self, name)</code>:<br/>
Finds element within this element&#39;s children by tag name.<br/><br/>
通过查找html的标签名称定位元素<br/><br/>
Args:</p>

<ul>
<li>name - name of html tag (eg: h1, a, span)</li>
</ul>

<p>用法:<br/><br/>
    <code>driver.find_element_by_tag_name(“name”)</code></p>

<h5 id="toc_85">(56) find_elements_by_tag_name</h5>

<p><code>find_elements_by_tag_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by tag name.<br/>
通过查找html的标签名称定位所有元素<br/><br/>
Args:  </p>

<ul>
<li>name - name of html tag (eg: h1, a, span). </li>
</ul>

<p>用法:<br/>
    <code>driver.find_elements_by_tag_name(“name”)</code></p>

<h5 id="toc_86">(57) find_element_by_xpath</h5>

<p><code>find_element_by_xpath(self, xpath)</code>:<br/><br/>
Finds element by xpath.<br/><br/>
通过Xpath定位元素，详细方法可参阅<a href="http://www.w3school.com.cn/xpath/">http://www.w3school.com.cn/xpath/</a><br/>
Args:<br/>
    xpath - xpath of element to locate.  &quot;//input[@class=&#39;myelement&#39;]&quot;<br/>
    Note: The base path will be relative to this element&#39;s location.<br/>
    This will select the first link under this element.<br/>
    <code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code><br/>
    However, this will select the first link on the page.<br/>
    <code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>  </p>

<p>用法 <code>find_element_by_xpath(“//*”)</code></p>

<h5 id="toc_87">(58) find_elements_by_xpath</h5>

<p><code>find_elements_by_xpath(self, xpath)</code>:<br/>
Finds elements within the element by xpath.<br/><br/>
Args:</p>

<ul>
<li>xpath - xpath locator string.</li>
</ul>

<p>Note: The base path will be relative to this element&#39;s location.<br/><br/>
This will select all links under this element.<br/><br/>
<code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code>. <br/>
However, this will select all links in the page itself.<br/><br/>
<code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>. </p>

<p>用法:<br/><br/>
<code>find_elements_by_xpath(“//*”)</code></p>

<h5 id="toc_88">(59) find_element_by_class_name</h5>

<p><code>find_element_by_class_name(self, name)</code>:<br/><br/>
Finds element within this element&#39;s children by class name.<br/><br/>
通过元素class name属性定位元素.<br/><br/>
Args:  </p>

<ul>
<li>name - class name to search for.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_element_by_class_name(“android.widget.LinearLayout”)</code></p>

<h5 id="toc_89">(60) find_elements_by_class_name</h5>

<p><code>find_elements_by_class_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by class name.<br/><br/>
通过元素class name属性定位所有含有该属性的元素. <br/>
Args:  </p>

<ul>
<li>name - class name to search for.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_elements_by_class_name(“android.widget.LinearLayout”)</code>. </p>

<h5 id="toc_90">(61) find_element_by_css_selector</h5>

<p><code>find_element_by_css_selector(self, css_selector)</code>:<br/><br/>
Finds element within this element&#39;s children by CSS selector.<br/><br/>
通过CSS选择器定位元素. <br/>
Args:  </p>

<ul>
<li>css_selector - CSS selctor string, ex: &#39;a.nav#home&#39;</li>
</ul>

<h5 id="toc_91">(62) send_keys</h5>

<p><code>send_keys(self, *value)</code>:<br/><br/>
Simulates typing into the element.<br/><br/>
在元素中模拟输入（开启appium自带的输入法并配置了appium输入法后，可以输入中英文）. <br/>
Args:</p>

<ul>
<li>value - A string for typing, or setting form fields.  For setting file inputs, this could be a local file path.Use this to send simple key events or to fill out form fields:<br/>
<code>form_textfield = driver.find_element_by_name(&#39;username&#39;)</code><br/>
<code>form_textfield.send_keys(&quot;admin&quot;)</code><br/>
This can also be used to set file inputs.<br/>
<code>file_input = driver.find_element_by_name(&#39;profilePic&#39;)</code><br/>
<code>file_input.send_keys(&quot;path/to/profilepic.gif&quot;)</code><br/>
<code># Generally it&#39;s better to wrap the file path in one of the methods</code><br/>
<code># in os.path to return the actual path to support cross OS testing.</code><br/>
<code># file_input.send_keys(os.path.abspath(&quot;path/to/profilepic.gif&quot;))</code><br/>
<code>driver.element.send_keys(“中英”)</code></li>
</ul>

<h5 id="toc_92">(63) is_displayed</h5>

<p><code>is_displayed(self)</code>:<br/><br/>
Whether the element is visible to a user.<br/><br/>
此元素用户是否可见。简单地说就是隐藏元素和被控件挡住无法操作的元素（仅限 Selenium，appium是否实现了类似功能不是太确定）这一项都会返回 False. <br/>
用法:<br/><br/>
<code>driver.element.is_displayed()</code></p>

<h5 id="toc_93">(64) location_once_scrolled_into_view</h5>

<p><code>location_once_scrolled_into_view(self)</code>:<br/><br/>
 &quot;&quot;&quot;THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover. where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view.Returns the top lefthand corner location on the screen, or <code>None</code> if the element is not visible.</p>

<p>暂不知道用法</p>

<h5 id="toc_94">(65) size</h5>

<p><code>size(self)</code>:<br/><br/>
The size of the element.<br/><br/>
获取元素的大小（高和宽）.<br/><br/>
<code>new_size[&quot;height&quot;] = size[&quot;height&quot;]</code><br/><br/>
<code>new_size[&quot;width&quot;] = size[&quot;width&quot;]</code>   </p>

<p>用法:<br/><br/>
<code>driver.element.size</code></p>

<h5 id="toc_95">(66) value_of_css_property</h5>

<p><code>value_of_css_property(self, property_name)</code>:<br/><br/>
The value of a CSS property.<br/><br/>
CSS属性<br/><br/>
用法 暂不知  </p>

<h5 id="toc_96">(67) location</h5>

<p><code>location(self)</code>:<br/><br/>
The location of the element in the renderable canvas.<br/><br/>
获取元素左上角的坐标<br/><br/>
用法:<br/><br/>
<code>driver.element.location</code><br/><br/>
返回element的x坐标, int类型<br/><br/>
<code>driver.element.location.get(&#39;x&#39;)</code><br/><br/>
返回element的y坐标, int类型<br/><br/>
<code>driver.element.location.get(&#39;y&#39;)</code></p>

<h5 id="toc_97">(68) rect</h5>

<p><code>rect(self)</code>:<br/><br/>
A dictionary with the size and location of the element.<br/><br/>
元素的大小和位置的字典  </p>

<h5 id="toc_98">(69) screenshot_as_base64</h5>

<p><code>screenshot_as_base64(self)</code>:<br/><br/>
Gets the screenshot of the current element as a base64 encoded string.<br/><br/>
获取当前元素的截图为Base64编码的字符串<br/><br/>
Usage:<br/><br/>
<code>img_b64 = element.screenshot_as_base64</code></p>

<h5 id="toc_99">(70) execute_script</h5>

<p><code>execute_script(self, script, *args)</code>:<br/><br/>
Synchronously Executes JavaScript in the current window/frame.<br/><br/>
在当前窗口/框架（特指 Html 的 iframe ）同步执行 javascript 代码。你可以理解为如果这段代码是睡眠5秒，这五秒内主线程的 javascript 不会执行<br/><br/>
Args:  </p>

<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.<br/>
Usage:<br/>
<code>driver.execute_script(&#39;document.title&#39;)</code></li>
</ul>

<h5 id="toc_100">(71) execute_async_script</h5>

<p><code>execute_async_script(self, script, *args)</code>:<br/><br/>
Asynchronously Executes JavaScript in the current window/frame.<br/><br/>
插入 javascript 代码，只是这个是异步的，也就是如果你的代码是睡眠5秒，那么你只是自己在睡，页面的其他 javascript 代码还是照常执行<br/><br/>
Args:  </p>

<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.</li>
</ul>

<p>Usage:<br/><br/>
<code>driver.execute_async_script(&#39;document.title&#39;)</code></p>

<h5 id="toc_101">(72) current_url</h5>

<p><code>current_url(self)</code>:<br/><br/>
Gets the URL of the current page.<br/><br/>
获取当前页面的网址。<br/><br/>
Usage:<br/><br/>
<code>driver.current_url</code><br/>
用法<br/><br/>
<code>driver.current_url</code></p>

<h5 id="toc_102">(73) page_source</h5>

<p><code>page_source(self)</code>:<br/><br/>
Gets the source of the current page.<br/><br/>
获取当前页面的源<br/><br/>
Usage:<br/><br/>
<code>driver.page_source</code></p>

<h5 id="toc_103">(74) close</h5>

<p><code>close(self)</code>:<br/>
Closes the current window.<br/><br/>
关闭当前窗口<br/><br/>
Usage:<br/><br/>
<code>driver.close()</code></p>

<h5 id="toc_104">(75) quit</h5>

<p><code>quit(self)</code>:<br/><br/>
Quits the driver and closes every associated window.<br/><br/>
退出脚本运行并关闭每个相关的窗口连接<br/><br/>
Usage:<br/><br/>
<code>driver.quit()</code></p>

<p>参考资料:<br/><br/>
<a href="http://debugtalk.com/post/build-ideal-app-automation-test-framework/">打造心目中理想的自动化测试框(AppiumBooster)</a>   </p>

<p><a href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/">从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用</a>  </p>

<p><a href="https://github.com/appium/python-client">Python-Client的github文档地址</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868936.html">
                
                  <h1>LaTeX表示方法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、指数和下标可以用<sup>和_后加相应字符来实现。</sup></h2>

<p><img src="media/15561207868936/15713264075302.png" alt=""/></p>

<h2 id="toc_1">二、平方根（square root）的输入命令为：\sqrt，n 次方根相应地为: \sqrt[n]。方根符号的大小由LATEX自动加以调整。也可用\surd 仅给出符号。</h2>

<p><img src="media/15561207868936/15713264213005.png" alt=""/></p>

<h2 id="toc_2">三、命令\overline 和\underline 在表达式的上、下方画出水平线。</h2>

<p><img src="media/15561207868936/15713264358808.png" alt=""/></p>

<h2 id="toc_3">四、命令\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号。</h2>

<p><img src="media/15561207868936/15713264468658.png" alt=""/></p>

<h2 id="toc_4">五、向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量时非常有用。</h2>

<p><img src="media/15561207868936/15713264649982.png" alt=""/></p>

<h2 id="toc_5">六、分数（fraction）使用\frac{...}{...} 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。</h2>

<p><img src="media/15561207868936/15713264772357.png" alt=""/></p>

<h2 id="toc_6">七、积分运算符（integral operator）用\int 来生成。求和运算符（sum operator）由\sum 生成。乘积运算符（product operator）由\prod 生成。上限和下限用^ 和_来生成，类似于上标和下标。</h2>

<p><img src="media/15561207868936/15713264928671.png" alt=""/></p>

<h2 id="toc_7">以下提供一些常用符号的表示方法</h2>

<p><img src="media/15561207868936/15713265151036.png" alt=""/> <br/>
<img src="media/15561207868936/15713265355830.png" alt=""/><br/>
<img src="media/15561207868936/15713265726366.png" alt=""/> <br/>
<img src="media/15561207868936/15713265959249.png" alt=""/> <br/>
<img src="media/15561207868936/15713266129558.png" alt=""/> <br/>
<img src="media/15561207868936/15713266264578.png" alt=""/><br/>
<img src="media/15561207868936/15713266364253.png" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868826.html">
                
                  <h1>Android 冷启动实现APP秒开</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在阅读这篇文章之前，首先需要理解几个东西：  </p>

<ul>
<li>1、什么是Android的冷启动时间？<br/>
冷启动时间是指用户从手机桌面点击APP的那一刻起到启动页面的Activity调用onCreate()方法之间的这个时间段。</li>
<li>2、在冷启动的时间段内发生了什么？<br/>
首先我们要知道当打开一个Activity的时候发生了什么，在一个Activity打开时，如果该Activity所属的Application还没有启动，那么系统会为这个Activity创建一个进程（每创建一个进程都会调用一次Application，所以Application的onCreate()方法可能会被调用多次），在进程的创建和初始化中，势必会消耗一些时间，在这个时间里，WindowManager会先加载APP里的主题样式里的窗口背景（windowBackground）作为预览元素，然后才去真正的加载布局，如果这个时间过长，而默认的背景又是黑色或者白色，这样会给用户造成一种错觉，这个APP很卡，很不流畅，自然也影响了用户体验。<br/></li>
</ul>

<p>来看下效果图：<br/><br/>
<strong>未优化：</strong><br/><br/>
<img src="media/15561207868826/20170227548242189443-4a70e91b2e124b48.gif" alt=""/></p>

<p><strong>优化方案一：</strong><br/><br/>
<img src="media/15561207868826/20170227487382189443-4829eba35492d39b.gif" alt=""/></p>

<p><strong>优化方案二：</strong><br/><br/>
<img src="media/15561207868826/20170227662152189443-c861191c8a80cd94.gif" alt=""/></p>

<h2 id="toc_1">历史原因</h2>

<p>当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态的，这就很尴尬了，因为用户会以为没有点到APP而再次点击，这极大的降低用户体验，Android需要及时做出反馈去避免这段迷之尴尬。于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是<strong>Preview Window</strong>,即预览窗口。</p>

<p>好了，现在我们明白了，Preview Window其实是为了提高用户体验而有意设定的。因此，其实如果不是强迫症，它可能并不是一个问题。</p>

<p>但是我猜大部分小伙伴应该是和我一样的强迫症患者：这么丑的黑屏怎么能出现在我的APP上呢？？？！！！</p>

<p>所以，下面我们就来聊聊这个问题的解决方案。</p>

<h2 id="toc_2">解决方案</h2>

<p>既然决定解决这个问题，那么从哪里入手呢，Android在选择展示黑屏或者白屏的时候，是根据你设定的主题而不同的，也就是说，虽然你的代码没有被执行，你的配置文件却被提前读取了，用来作为展示Preview Window界面的依据。在用户点击手机桌面APP的时候，看到的黑屏或者白屏其实是界面渲染前的第一帧，如果你看懂了文章头的那2个问题，那么解决这个问题就非常轻松了，无非就是将Theme里的windowBackground设置成我们想要让用户看到的画面就可以了</p>

<p>所以，我们的解决方案的切入口就是整个APP的manifest文件，更确切的说应该是主题配置文件。</p>

<h3 id="toc_3">方案一 ：开历史倒车</h3>

<p>这个方案就是禁止加载Preview Window，具体做法如下：</p>

<p>style.xml</p>

<style name="APPTheme" parent="@android:style/Theme.Holo.NoActionBar">
   <item name="android:windowDisablePreview">true</item>
</style>

<p>将APPTheme设定为启动的Activity的主题，即可禁止Preview Window，当然，也有人通过把preview window设置为全透明，也达成了类似的效果。</p>

<p>结果就是，当你点击APP时，界面会无响应一段时间，然后进入APP。</p>

<p>我个人强烈不推荐这么做，因为Android想方设法提升的用户体验一下子被你打回解放前。</p>

<h3 id="toc_4">方案二：自定义Preview Window</h3>

<h4 id="toc_5">1、透明启动</h4>

<p>将背景颜色设置为透明色，这样当用户点击桌面APP图片的时候，并不会&quot;立即&quot;进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦，哈哈），其实现在微信也是这样做的，不信你可以试试。<br/>
<code>&lt;style name=&quot;Appwelcome&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot;/&gt;</code><br/>
透明化这种做法需要注意的一点，如果直接把Theme引入Activity，在运行的时候可能会出现如下异常：</p>

<blockquote>
<p>java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.</p>
</blockquote>

<p>这个是因为使用了不兼容的Theme，例如我这里的Activity继承了AppCompatActivity，解决方案很简单：</p>

<ul>
<li>1、让其Activity集成Activity而不要集成兼容性的AppCompatActivity</li>
<li>2、在onCreate()方法里的super.onCreate(savedInstanceState)之前设置我们原来APP的Theme</li>
</ul>

<pre><code class="language-java">public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
            setTheme(R.style.AppTheme);
            super.onCreate(savedInstanceState);
    }
}
</code></pre>

<h4 id="toc_6">2、Logo图片启动</h4>

<p>将背景图设置成我们APP的Logo图，作为APP启动的引导，现在市面上大部分的APP也是这么做的。<br/><br/>
具体方法如下：</p>

<p>style.xlm</p>

<pre><code class="language-markup">&lt;style name=&quot;APPTheme&quot; parent=&quot;@android:style/Theme.Holo.NoActionBar&quot;&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_icon&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>同样将主题设置到启动的Activity的主题中，windowBackground就是即将展示的preview window。其中splash_icon可以是一整张图片，网上很多小伙伴也都是这么做的。其实它也可以是一个能解析出图片资源的XML文件，好像只有layer-list这种能做得到,因为它能够将多个drawable叠加起来展示。</p>

<p>splash_icon.xml</p>

<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:opacity=&quot;opaque&quot;&gt;
    &lt;item android:drawable=&quot;@color/white&quot;/&gt;
    &lt;item&gt;
        &lt;bitmap
            android:gravity=&quot;center&quot;
            android:src=&quot;@drawable/qq&quot;/&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>

<p>这样设置之后，当你点击APP，会立马进入你配置的界面，然后启动欢迎页，效果如下<br/><br/>
<img src="media/15561207868826/2017022724594838b008fdb18f761ede8.gif" alt=""/></p>

<p>上面的2种做法，我们都需要将Theme引入对应的Activity</p>

<pre><code class="language-java">&lt;activity
    android:name=&quot;.app.main.MainActivity&quot;
    android:theme=&quot;@style/AppWelcome&quot;
    android:screenOrientation=&quot;portrait&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>那么，将preview window直接设置为图片和设置为xml文件有什么区别或者优劣呢？我先卖个关子。先谈谈这种方案的优劣，首先这种方案已经解决了原生preview window的单调难看的问题，在原来的基础上进一步提升了用户体验。可是我们的APP都是有欢（guang）迎（gao）页的，从preview window跳转到欢（guang）迎（gao）页是不可避免的，这样的话，两个界面的切换就会显得很突兀的，</p>

<p>所以强迫症的我们，尝试让这两个界面的切换变成一个界面的变化，从而进一步提升显示效果，怎么样才能让两个界面切换看起来像是在同一个界面里的变化呢？答案就是： 动画。</p>

<p>在这种需求下，图片和xml文件的区别就出来了，因为后者可以帮助我们更准确的实现动画。</p>

<h3 id="toc_7">方案三：自定义Preview Window增强版</h3>

<p>废话少说，我们先来看效果<br/><br/>
<img src="media/15561207868826/20170227597652f5ba2feffca1ca31a8c.gif" alt=""/></p>

<p>有了动画之后，界面切换顺畅了许多。<br/>
上面的动画实现其实非常简单，无非就是放缩，移动，渐变的组合使用（我仅仅用作范例给大家参考），具体的动画代码细节就不谈了，有兴趣可以去github上看<a href="https://github.com/ladingwu/Splash">本次项目的demo</a>，我们重点来聊一聊思路。</p>

<p>在这里我们需要明确一点的是，<strong>preview window</strong> 只能是静态图，它本身是不展示动画的，我们这里的动画，其实是在进入欢迎页之后的展示的。明确了这一点之后，整个动画效果的实现思路其实就已经摆在我们眼前了，那就是当界面从 <strong>Preview Window</strong> 跳转到 欢迎页 的时候，欢迎页必须首先展示一个和 <strong>Preview Window</strong> 一模一样的界面，让人看起来好像界面还没切换一样，然后再慢慢切换到欢迎页。</p>

<p>然后，我们再来谈谈为什么设置xml的方式可以帮助我们更准确的实现动画，就是因为要保证 <strong>Preview Window</strong> 和欢迎页最开始展示的界面保持绝对一致，只有通过xml的布局才是达到这种效果。</p>

<p>好了，启动页做到这个份儿上，应该就可以交货了，不过还有一个小问题需要大家注意的，那就是我们给Preview Window设置的背景图如果不做处理，图片就会一直存在于内存中，所以，当我们进入到欢迎页的时候，不要忘了把背景图设置为空：</p>

<p>SplashActivity.java</p>

<pre><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    //将window的背景图设置为空
    getWindow().setBackgroundDrawable(null);
    super.onCreate(savedInstanceState);
}
</code></pre>

<h2 id="toc_8">关于启动优化</h2>

<p>上面的做法其实可以达到&quot;秒开&quot;APP的效果，不过确不是真实的速度，在Activity创建过程中其实是会经过一系列framework层的操作，在日常开发中，我们都会去重写Application类，然后在Application里进行一些初始化操作，比如存放用户标识的静态化TOKEN，第三方SDK的初始化等。<br/><br/>
这里给出几点建议：  </p>

<ul>
<li>1、不要让Application参与业务的操作</li>
<li>2、不要在APPlication进行耗时操作，比如有些开发者会在自己的APP里一系列文件夹或文件（比如我自己），这些I/O操作应该放到&quot;确实该使用的时候再去创建&quot;亦或者是数据库的一些操作。</li>
<li>3、不要以静态变量的方式在Application中保存数据等。</li>
</ul>

<p>当然这是绝对的理想主义，把上面的&quot;不要&quot;2字之前添上&quot;尽量&quot;2字吧，毕竟在实际开发中，这样做确实会让我们方便许多。</p>

<p>对了，补充一点，布局也是很重要的，尽量的去减少布局的复杂性，布局深度，因为在View绘制的过程中，测量也是很耗费性能的。</p>

<h2 id="toc_9">总结</h2>

<p>到这里，关于Android启动页的相关问题就都讲完了。<br/><br/>
最终的高清的效果图：<br/><br/>
<img src="media/15561207868826/201702274812409e2d6cccbbdf90fb06f.gif" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868861.html">
                
                  <h1>Android Studio 关联 Bitbucket</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Github的确是一个开源代码浏览以及存放的好去处。但是当你想要创立一个私人仓库，存放自己的个人项目时，公开的仓库肯定是不行的，而私人账号必须要收费。对于那些手头紧，并且不想维护服务器的人来说，Bitbucket是个不错的选择。每个Bitbucket账号可以创立5个免费的私人仓库，够用了。最近在做毕业设计，需要将项目git到一个私人仓库，所以学习一下Android Studio和Bitbucket关联，毕竟能IDE中git，就觉得用SourceTree有点麻烦。</p>

<h2 id="toc_1">Bitbucket简介</h2>

<p>BitBucket 是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。常用的代码托管平台Github、SVN、Bitbucket中，Bitbucket具有以下优势：</p>

<ul>
<li>支持Hg，最易学易用（但不是最强大的）的分布式版本管理工具。同时也支持Git。他的网页端的git仓库不如github好用，但是作为远端仓库足够了。</li>
<li>完全免费的闭源项目，还支持5人以内的合作开发。</li>
<li>支持中文。</li>
<li>官方的git工具SourceTree比GitHub for windows好用。</li>
</ul>

<h2 id="toc_2">使用步骤</h2>

<h3 id="toc_3">一、安装Git</h3>

<p>安装步骤都是一路默认下一步，这里就不做说明了，安装好了后，需要将AndroidStudio与Git进行关联：</p>

<p>Android Studio–&gt; Preferences –&gt; Version Control –&gt; Git，在Path to Git executable栏找到Git安装目录中bin文件下的git文件。点击右侧的Test，如果出现如图中的成功提示框，表示AndroidStudio与Git已经关联成功。<br/>
<img src="media/15561207868861/15713246960472.png" alt=""/></p>

<h3 id="toc_4">二、在Bitbucket网站创建远程仓库</h3>

<p>在Bitbucket网站上创建仓库<br/><br/>
<img src="media/15561207868861/15713247073567.png" alt=""/></p>

<p>记录下远程仓库的URL，后面会用到<br/>
<img src="media/15561207868861/15713247206326.png" alt=""/></p>

<h3 id="toc_5">三、在AndroidStudio中创建新项目</h3>

<p>首先新建一个项目,然后进入项目后首先选择VCS–&gt;Enable Version Control Integration,然后选择Git，此时代码文件会变成红色<br/><br/>
<img src="media/15561207868861/15713247349739.png" alt=""/></p>

<p><img src="media/15561207868861/15713247482004.png" alt=""/></p>

<p><img src="media/15561207868861/15713247715529.png" alt=""/></p>

<p>接下来设置项目需要忽略上传的文件File–&gt;Settings –&gt; Version Control –&gt;Ignore Files<br/><br/>
<img src="media/15561207868861/15713247845617.png" alt=""/></p>

<p>接下来将项目添加到Git本地仓库中，在Project视图下，右键工程Git–&gt;Add,添加成功后，代码文件会变成绿色的。<br/><br/>
<img src="media/15561207868861/15713247974008.png" alt=""/></p>

<p><img src="media/15561207868861/15713248090123.png" alt=""/> </p>

<p>至此创建项目就完成了</p>

<h3 id="toc_6">四、AndroidStudio中将项目提交并推送到远程仓库</h3>

<p>进入AS项目中，选择VCS–&gt;Git-&gt;Commit File<br/><br/>
<img src="media/15561207868861/15713248252576.png" alt=""/></p>

<p>填写提交信息后，选择commit and Push<br/><br/>
<img src="media/15561207868861/15713248367087.png" alt=""/></p>

<p>之后点击Define remote 填入第二步中的远程仓库URL，点击OK校验URL后就可以Push了。<br/>
<img src="media/15561207868861/15713248467219.png" alt=""/></p>

<p><img src="media/15561207868861/15713248552072.png" alt=""/></p>

<p>到此项目构建者的工作就算完成了，其他小伙伴可以直接参照第六步，从远程仓库剪切项目代码。</p>

<h3 id="toc_7">五、别忘了给Bitbucket添加SSH密钥</h3>

<p><code>ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</code><br/><br/>
使用你的邮件创建一个新的 SSH 密匙标签，将会生成 ~/.ssh/id_rsa 文件， 用于存储你的密匙。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/09</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868790.html">
                
                  <h1>Android Thread</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、线程简介</h2>

<p>现在操作系统在运行一个程序时，会自动为其创建一个进程，不论是 PC 还是 Android。</p>

<p>一个进程内可以有多个线程，这些线程作为操作系统调度的最小单元，负责执行各种各样的任务，这些线程都拥有各自的计数器、堆栈、局部变量等属性，并且可以访问共享内存。</p>

<p>想象一下，如果你的电脑里只有一条线程在执行任务，一旦遇到 I/O 密集的任务，CPU 只能长时等待，效率很低。</p>

<p>如果把一个进程比作一个外卖公司，CPU 就是外卖公司拥有的主要资源（可以当做电动车），那线程（Thread）就是外卖公司中的一位送餐员，Runnable 就是送餐员要执行的任务（一般情况下都是送饭）。</p>

<h2 id="toc_1">二、线程创建的三种方式</h2>

<p>送餐员最重要的任务就是送餐，我们以代码来演示创建一个送餐员的三种方式：</p>

<h3 id="toc_2">(一) 实现 Runnable 接口</h3>

<pre><code class="language-java">public class ThreadTest0 {

    /**
     * 1.实现 Runnable 接口，在 run() 方法中写要执行的任务
     */
    static class Task implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
            Thread shixinzhang = new Thread(new Task(), &quot;外卖任务 &quot; + i);
            //3.命令送餐员出发！
            shixinzhang.start();
        }
    }
}
</code></pre>

<p>注意，上述代码中调用的是送餐员线程的 start() 方法，然后线程会调用 Task 对象的 run() 方法执行任务。运行结果如下：</p>

<p><code>外卖任务 3: 您的外卖已送达</code><br/><br/>
<code>外卖任务 1: 您的外卖已送达</code><br/><br/>
<code>外卖任务 0: 您的外卖已送达</code><br/><br/>
<code>外卖任务 2: 您的外卖已送达</code>  </p>

<p>可以看到执行任务的是各个线程。如果在 main() 方法中直接调用 run 方法，就相当于主线程直接执行任务，没有在子线程中进行。</p>

<p>直接在 main 中调用 run()：</p>

<pre><code class="language-java">public static void main(String[] args) {
    for (int i = 0; i &lt; 4; i++) {
        //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
        Task task = new Task();
        Thread shixinzhang = new Thread(task, &quot;外卖任务 &quot; + i);
        //3.直接执行任务
        task.run();
    }
}
</code></pre>

<p>运行结果：</p>

<p><code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code>  </p>

<h3 id="toc_3">(二) 继承 Thread，重写其 run 方法</h3>

<pre><code class="language-java">public class ThreadTest1 {
    /**
     * 继承 Thread，重写 run 方法，在 run 方法中写要执行的任务
     */
    static class DeliverThread extends Thread{

        public DeliverThread(String name) {
            super(name);
        }

        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，同时起个名
            DeliverThread shixinzhang = new DeliverThread(&quot;外卖任务&quot; + i);
            shixinzhang.start();
        }
    }
}
</code></pre>

<p>运行结果：</p>

<p><code>外卖任务1: 您的外卖已送达</code><br/><br/>
<code>外卖任务3: 您的外卖已送达</code><br/><br/>
<code>外卖任务0: 您的外卖已送达</code><br/><br/>
<code>外卖任务2: 您的外卖已送达</code>  </p>

<p>为什么直接继承 Thread 也可以在子线程中执行任务呢？</p>

<p>从 Thread 源码中我们可以看到， Thread 其实也实现了 Runnable ：<br/><br/>
<code>public class Thread implements Runnable</code>  </p>

<p>它内部也有一个 Runnable 的引用，我们调用 start() 方法后送餐员小张就蓄势以待准备出发了，之所以没说“立即出发送餐”，是因为此时可能电动车（CPU）正在被别人使用。</p>

<p>线程 start() 后操作系统会给他分配相关的资源，包括单独的程序计数器（可以理解为送餐员的任务本，上面记录了当前送餐任务的地址和下一个任务的地址）和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行。</p>

<p>等线程被 CPU 调度后就会执行线程中的 run() 方法，因此我们通过重写 Thread 的 run() 方法就可以达到在子线程执行任务的目的。</p>

<h3 id="toc_4">(三) 实现 Callable 接口，重写 call() 方法，用 FutureTask 获得结果</h3>

<pre><code class="language-java">public class CallableTest {
    /**
     * 实现 Callable 接口
     */
    static class DeliverCallable implements Callable&lt;String&gt; {
        /**
         * 执行方法，相当于 Runnable 的 run, 不过可以有返回值和抛出异常
         * @return
         * @throws Exception
         */
        @Override
        public String call() throws Exception {
            Thread.sleep(new Random().nextInt(10000));
            System.out.println(Thread.currentThread().getName() + &quot;：您的外卖已送达&quot;);
            return Thread.currentThread().getName() + &quot; 送达时间：&quot; + System.currentTimeMillis() + &quot;\n&quot;;
        }
    }

    /**
     * Callable 作为参数传递给 FutureTask，FutureTask 再作为参数传递给 Thread（类似 Runnable），然后就可以在子线程执行
     * @param args
     */
    public static void main(String[] args) {
        List&lt;FutureTask&lt;String&gt;&gt; futureTasks = new ArrayList&lt;&gt;(4);
        for (int i = 0; i &lt; 4; i++) {
            DeliverCallable callable = new DeliverCallable();
            FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
            futureTasks.add(futureTask);

            Thread thread = new Thread(futureTask, &quot;送餐员 &quot; + i);
            thread.start();
        }

        StringBuilder results = new StringBuilder();
        futureTasks.forEach(futureTask -&gt; {
            try {
                //获取线程返回结果，没返回就会阻塞
                results.append(futureTask.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        System.out.println(System.currentTimeMillis() + &quot; 得到结果：\n&quot; + results);
    }
}
</code></pre>

<p>第三种创建线程的方式与前两种的不同之处在于，以 Callable 作为任务，而不是 Runnable，这种方式的好处是可以获得结果和响应中断。</p>

<p>运行结果：  </p>

<pre><code class="language-text">送餐员 3：您的外卖已送达  
送餐员 1：您的外卖已送达  
送餐员 0：您的外卖已送达  
送餐员 2：您的外卖已送达  
1487998155430 得到结果： 
送餐员 0 送达时间：1487998155076 
送餐员 1 送达时间：1487998150453 
送餐员 2 送达时间：1487998155430 
送餐员 3 送达时间：1487998149779
</code></pre>

<h2 id="toc_5">三、线程的基本属性</h2>

<h3 id="toc_6">(一) 优先级</h3>

<p>Thread 有个优先级字段：private int priority</p>

<p>操作系统采用时间片（CPU 单次执行某线程的时间）的形式来调度线程的运行，线程被 CPU 调用的时间超过它的时间片后，就会发生线程调度。</p>

<p>线程的优先级可以在一定程度上影响它得到时间片的多少，也就是被处理的机会。</p>

<p>Java 中 Thread 的优先级为从 1 到 10 逐渐提高，默认为 5。</p>

<p>有长耗时操作的线程，一般建议设置低优先级，确保处理器不会被独占太久； <br/>
频繁阻塞（休眠或者 I/O）的线程建议设置高优先级。  </p>

<pre><code class="language-java"> public final static int MIN_PRIORITY = 1;

 //线程的默认优先级
 public final static int NORM_PRIORITY = 5;

 public final static int MAX_PRIORITY = 10;
</code></pre>

<blockquote>
<p>线程优先级只是对操作系统分配时间片的建议。 <br/>
虽然 Java 提供了 10 个优先级别，但不同的操作系统的优先级并不相同，不能很好的和 Java 的 10 个优先级别对应。&gt;所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>

<h3 id="toc_7">(二) 守护线程</h3>

<p>Java 中，线程也分三六九等。守护线程相当于小弟，做一些后台调度、支持性工作,比如 JVM 的垃圾回收、内存管理等线程都是守护线程。</p>

<p>Thread 中有个布尔值标识当前线程是否为守护线程：</p>

<p><code>private boolean     daemon = false;</code></p>

<p>同时也提供了设置和查看当前线程是否为守护线程的方法：</p>

<pre><code class="language-java">public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        throw new IllegalThreadStateException();
    }
    daemon = on;
}

public final boolean isDaemon() {
    return daemon;
}
</code></pre>

<blockquote>
<p>Daemon 属性需要在调用线程的 start() 方法之前调用。</p>
</blockquote>

<p>一个进程中，如果所有线程都退出了，Java 虚拟机就会退出。注意了，这里的“所有”就不包括守护线程，也就是说，当除守护线程外的其他线程都结束后，Java 虚拟机就会退出，然后将守护进程终止。</p>

<p><strong>这里需要注意的是，由于上述特性，Java 虚拟机退出后，在守护线程中的 finally 块中的代码不一定执行。</strong></p>

<p>举个例子：</p>

<pre><code class="language-java">public class DaemonTreadTest0 {
    static class DaemonThread extends Thread{
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                System.out.println(Thread.currentThread().getName() + &quot; finally is called!&quot;);
            }
        }
    }

    public static void main(String[] args) {
        DaemonThread thread = new DaemonThread();
        thread.setDaemon(true);
        thread.start();
    }
}
</code></pre>

<p>上述代码中将线程设置为守护线程，由于 main 线程启动 DaemonThread 后就结束，此时虚拟机中没有非守护线程，虚拟机也会退出，守护进程被终止，但是它的 finally 块中的内容却没有被调用。</p>

<p>如果将setDaemon方法注释掉，就会发现有运行结果:</p>

<p><code>Thread-0 finally is called!</code></p>

<p>因此，守护线程中不能依靠 finally 块进行资源关闭和清理。</p>

<h2 id="toc_8">四、线程的生命周期</h2>

<p>线程具有如下几个状态：</p>

<table>
<thead>
<tr>
<th>线程状态</th>
<th style="text-align: center">介绍</th>
<th style="text-align: left">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>NEW</td>
<td style="text-align: center">新创建</td>
<td style="text-align: left">还未调用 start() 方法；还不是活着的 (alive)</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td style="text-align: center">就绪的</td>
<td style="text-align: left">调用了 start() ，此时线程已经准备好被执行，处于就绪队列；是活着的(alive)</td>
</tr>
<tr>
<td>RUNNING</td>
<td style="text-align: center">运行中</td>
<td style="text-align: left">线程获得 CPU 资源，正在执行任务；活着的</td>
</tr>
<tr>
<td>BLOCKED</td>
<td style="text-align: center">阻塞的</td>
<td style="text-align: left">线程阻塞于锁或者调用了 sleep；活着的</td>
</tr>
<tr>
<td>WAITING</td>
<td style="text-align: center">等待中</td>
<td style="text-align: left">线程由于某种原因等待其他线程；或者的</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td style="text-align: center">超时等待</td>
<td style="text-align: left">与 WAITING 的区别是可以在特定时间后自动返回；活着的</td>
</tr>
<tr>
<td>TERMINATED</td>
<td style="text-align: center">终止</td>
<td style="text-align: left">执行完毕或者被其他线程杀死；不是活着的</td>
</tr>
</tbody>
</table>

<p>有几点注意：</p>

<ul>
<li>Java 中的 Thread 运行状态没有 RUNNING 这一步，运行中的线程状态是 RUNNABLE</li>
<li>三个让线程进入 WAITING 状态的方法 
<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
<li>Lock.lock()</li>
</ul></li>
</ul>

<p><strong>Java 中关于“线程是否活着”的定义</strong></p>

<p>Thread 中有个判断是否为活着的方法：<br/><br/>
<code>public final native boolean isAlive()</code></p>

<p>Java 中线程除了 NEW 和 TERMINITED 状态，其他状态下调用 isAlive() 方法均返回 true，也就是活着的。</p>

<h2 id="toc_9">五、线程的关键方法</h2>

<h3 id="toc_10">(一) Thread.sleep()</h3>

<p>Thread.sleep() 是一个静态方法：</p>

<p><code>public static native void sleep(long millis) throws InterruptedException;</code></p>

<p>sleep() 方法：</p>

<ul>
<li>使当前所在线程进入阻塞</li>
<li>只是让出 CPU ，并没有释放对象锁</li>
<li>由于休眠时间结束后不一定会立即被 CPU 调度，因此线程休眠的时间可能大于传入参数</li>
<li>如果被中断会抛出 InterruptedException</li>
</ul>

<p><strong>注意上面的第一条！由于 sleep 是静态方法，它的作用时使当前所在线程祖舍。因此最好在线程内部直接调用 Thread.sleep()，如果你在主线程调用某个线程的 sleep() 方法，其实阻塞的是主线程！</strong></p>

<h3 id="toc_11">(二) Object.wait()</h3>

<p>与 Thread.sleep() 容易混淆的是 Object.wait() 方法。</p>

<p>Object.wait() 方法：</p>

<ul>
<li>让出 CPU，释放对象锁</li>
<li>在调用前需要先拥有某对象的锁，所以一般在 synchronized 同步块中使用</li>
<li>使该线程进入该对象监视器的等待队列</li>
</ul>

<h3 id="toc_12">(三) Thread.yield()</h3>

<p>Thread. yield() 也是一个静态方法：</p>

<p><code>public static native void yield();</code></p>

<p>“Thread.yield() 表示暂停当前线程，让出 CPU 给优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程。</p>

<ul>
<li>和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。</li>
<li>yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中。</li>
</ul>

<blockquote>
<p>yield() 一般使用较少。</p>
</blockquote>

<h3 id="toc_13">(四) Thread.join()</h3>

<p>Thread.join() 表示线程合并，调用线程会进入阻塞状态，需要等待被调用线程结束后才可以执行。</p>

<blockquote>
<p>线程的合并的含义就是将几个并发执行线程的线程合并为一个单线程执行。</p>
</blockquote>

<p>比如下述代码：</p>

<pre><code class="language-java">Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;thread is running!&quot;);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
thread.start();
thread.join();
System.out.println(&quot;main thread &quot;);
</code></pre>

<p>我们在主线程调用了 thread.join() 方法，该线程会在输出一句话后休眠 5 秒，等该线程结束后主线程才可以继续执行，输出最后一句结果：</p>

<blockquote>
<p>thread is running! <br/>
main thread</p>
</blockquote>

<p>Thread.join 源码：</p>

<pre><code class="language-java">//无参方法
public final void join() throws InterruptedException {
    join(0);
}
//有参方法，表示等待 millis 毫秒后自动返回
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay &lt;= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
//有参方法，表示等待 millis + (nanos - 50000) 毫秒后结束
public final synchronized void join(long millis, int nanos)
throws InterruptedException {

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (nanos &lt; 0 || nanos &gt; 999999) {
        throw new IllegalArgumentException(
                            &quot;nanosecond timeout value out of range&quot;);
    }

    if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) {
        millis++;
    }

    join(millis);
}
</code></pre>

<p>通过源码可以发现，Thread.join 是通过 synchronized + Object.wait() 实现的。</p>

<p>Thread.join 的应用场景是：当一个线程必须等待其他线程执行完毕才能继续执行，比如合并计算。</p>

<h2 id="toc_14">六、线程的中断</h2>

<p>有时候我们需要中断一个正在运行的线程，一种很容易想到的方法是在线程的 run() 方法中加一个循环条件：</p>

<pre><code class="language-java">public class ThreadInterruptTest1 {
    static class InterruptThread extends Thread{
        private boolean running;

        public InterruptThread(boolean running) {
            this.running = running;
        }

        public boolean isRunning() {
            return running;
        }

        public void setRunning(boolean running) {
            this.running = running;
        }

        @Override
        public void run() {
            while (running){
                System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptThread thread = new InterruptThread(true);
        thread.start();

        Thread.sleep(5000);
        thread.setRunning(false);
    }
}
</code></pre>

<p>上面的代码中线程 InterruptThread 有一个标志位 running，当这个标志位为 true 时才可以运行。 <br/>
因此我们可以通过修改这个标志位为 false 来中断该线程。</p>

<p>其实 Thread 内部也为我们提供了同样的机制 ：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align: center">方法介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td>public void interrupt()</td>
<td style="text-align: center">试图中断调用线程，设置中断标志位为 false</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td style="text-align: center">返回调用线程是否被中断</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td style="text-align: center">返回当前线程是否被中断的状态值，同时将中断标志位复位（设为 false）</td>
</tr>
</tbody>
</table>

<h3 id="toc_15">(一) public void interrupt()</h3>

<p>它的作用是设置标志位为 false，能否达到中断调用线程的效果，还取决于该线程是否可以响应中断（说直白些就是吃不吃这套），比如 Runnable 的 run() 方法就无法响应中断。</p>

<p>因此我们对执行 Runnable 任务的线程调用 interrupt() 方法后，该线程也不会中断，举个例子：</p>

<pre><code class="language-java">public class ThreadInterruptTest2 {

    static class UnInterruptThread extends Thread{
        public UnInterruptThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    static class  UnInterruptRunnable implements Runnable{

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        UnInterruptThread thread = new UnInterruptThread(&quot;无法中断的线程&quot;);
//        Thread thread = new Thread(new UnInterruptRunnable(), &quot;无法中断&quot;);
        thread.start();

        //先让它执行一秒
        Thread.sleep(1000);

        thread.interrupt();

        //不立即退出
        Thread.sleep(3000);
    }
}
</code></pre>

<p>这两种方式创建的线程，在调用 thread.interrupt() 方法后仍然会继续执行！</p>

<p>这时就需要用到上面 Thread 提供的第二个关于中断的方法 isInterrupted() 了。</p>

<h3 id="toc_16">(二) public boolean isInterrupted()</h3>

<p>我们可以通过 isInterrupted() 知道调用线程是否被中断，以此来作为线程是否运行的判断标志。</p>

<blockquote>
<p>isInterrupted() 在刚创建时默认为 false 不用多说； <br/>
线程有许多方法可以响应中断（比如 Thread.sleep()，Thread.wait()），这些方法在收到中断请求、抛出 InterruptedException 之前，JVM 会先把该线程的中断标志位复位，这时调用 isInterrupted 将会返回 false； <br/>
线程结束后，线程的中断标志位也会复位为 false。</p>
</blockquote>

<p>举个例子：</p>

<pre><code class="language-java">/**
 * 线程中断练习
 * Created by zhangshixin on 17/2/25.
 * http://blog.csdn.net/u011240877
 */
public class ThreadInterruptTest {
    /**
     * 调用 Thread.sleep() 方法的线程，线程如果在 sleep 时被中断，会抛出 InterruptedException
     * 我们在代码中进行捕获，并且查看 JVM 是否将中断标志位重置
     */
    static class SleepThread extends Thread{
        public SleepThread(String s) {
            setName(s);
        }
        @Override
        public void run() {
            while (!isInterrupted()){
                try {
                    Thread.sleep(500);
                    System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    System.out.println(&quot;SleepRunner 在 sleep 时被中断了，此时中断标志位为：&quot; + isInterrupted());
                }
            }
        }
    }

    /**
     * 希望通过这个线程了解：线程运行结束后，中断标志位会重置
     */
    static class BusyThread extends Thread{

        public BusyThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (!isInterrupted()){
                System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SleepThread sleepThread = new SleepThread(&quot;SleepRunner：&quot;);
        BusyThread busyThread = new BusyThread(&quot;BusyRunner：&quot;);
        //新创建的线程 中断标志为 false
        System.out.println(&quot;SleepThread 新创建时的中断标志位：&quot; + sleepThread.isInterrupted());

        Thread.sleep(2000);
        //启动两个线程
        sleepThread.start();
        busyThread.start();
        //让它们运行一秒
        Thread.sleep(1000);
        //分别中断两个线程
        sleepThread.interrupt();
        busyThread.interrupt();
        //查看线程的中断标志位
        Thread.sleep(2000);
        System.out.println(&quot;由于中断标志位变为 true 导致运行结束的线程，中断标志位为: &quot; + busyThread.isInterrupted());

        Thread.sleep(1000);
    }
}
</code></pre>

<p>上述代码中 两个线程都使用 isInterrupted 作为循环执行任务的条件，其中 SleepThread 方法调用了 Thread.sleep，这个方法的会响应中断，抛出异常。</p>

<p>运行结果如下：</p>

<p><img src="media/15561207868790/15713244513325.png" alt=""/></p>

<p>可以看到：</p>

<ul>
<li>线程中，在抛出 InterruptedException 前 JVM 的确会重置中断标志位为 false</li>
<li>这将导致以 isInterrupted 方法作为循环执行任务的线程无法正确中断</li>
</ul>

<h3 id="toc_17">(三) public static boolean interrupted()</h3>

<p><code>Thread.interrupted()</code> 方法是一个静态方法，它会返回调用线程（而不是被调用线程）的中断标志位，返回后重置中断标志位。</p>

<p>因此 <code>Thread.interrupted()</code> 第二次调用永远返回 false。</p>

<p>源码：</p>

<pre><code class="language-java">public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}
</code></pre>

<h2 id="toc_18">七、总结</h2>

<p>这篇文章总结了 线程的基本概念和关键方法，还有一些不建议使用的方法没有介绍，是因为它们有很多副作用，比如 suspend() 方法在调用后虽然线程会进入休眠状态，却不会释放资源，很容易引发死锁问题；同样，stop() 方法终结一个线程时无法保证这个线程有机会释放资源，也会导致一些不确定问题。</p>

<p>我们可以通过下面的图片整体分析线程的生命周期和主要方法：<br/><br/>
<img src="media/15561207868790/15713244633003.png" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868717.html">
                
                  <h1>Android Wi-Fi 直连</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Wi-Fi直连是Android 4.0(API level 14)或更高的版本的才加入的新功能，使用Wi-Fi直连相关的API可以发现并连接支持Wi-Fi直连的设备，连接之后设备之间可以通信，传输的距离比蓝牙的传输距离要远很多</p>

<h2 id="toc_0">API 概述</h2>

<ul>
<li>Wi-Fi直连的方法<br/>
类WifiP2pManager提供了一些方法来使用Wi-Fi直连的相关的接口来发现连接设备<br/></li>
</ul>

<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>initialize()</td>
<td style="text-align: center">在Wi-Fi框架中注册，必须在其他方法之前调用</td>
</tr>
<tr>
<td>connect()</td>
<td style="text-align: center">和另外的直连设备连接</td>
</tr>
<tr>
<td>cancelConnect()</td>
<td style="text-align: center">取消正在连接的动作</td>
</tr>
<tr>
<td>requestConnectInfo()</td>
<td style="text-align: center">请求已经连接的信息</td>
</tr>
<tr>
<td>createGroup()</td>
<td style="text-align: center">创建直连的设备组</td>
</tr>
<tr>
<td>removeGroup()</td>
<td style="text-align: center">删除当前的设置组</td>
</tr>
<tr>
<td>requestGroupInfo()</td>
<td style="text-align: center">请求当前组的信息</td>
</tr>
<tr>
<td>discoverPeers()</td>
<td style="text-align: center">初始化搜索</td>
</tr>
<tr>
<td>requestPeers()</td>
<td style="text-align: center">请求已经发现的设备的列表</td>
</tr>
</tbody>
</table>

<ul>
<li>Wi-Fi直连的监听<br/>
类WifiP2pManager中也提供了很多的监听接口，计时的通知当前的 activity相关的搜索和连接的<br/>
结果</li>
</ul>

<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align: center">相关的操作</th>
</tr>
</thead>

<tbody>
<tr>
<td>WifiP2pManager.ActionListener</td>
<td style="text-align: center">相关的操作：connect(), cancelConnect(), createGroup(), removeGroup(), and discoverPeers()</td>
</tr>
<tr>
<td>WifiP2pManager.ChannelListener</td>
<td style="text-align: center">相关的操作：initialize()</td>
</tr>
<tr>
<td>WifiP2pManager.ConnectionInfoListener</td>
<td style="text-align: center">相关的操作：requestConnectInfo()</td>
</tr>
<tr>
<td>WifiP2pManager.GroupInfoListener</td>
<td style="text-align: center">相关的操作：requestGroupInfo()</td>
</tr>
<tr>
<td>WifiP2pManager.PeerListListener</td>
<td style="text-align: center">相关的操作：requestPeers()</td>
</tr>
</tbody>
</table>

<ul>
<li>Wi-Fi直连的Intent</li>
</ul>

<table>
<thead>
<tr>
<th>Intent</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>WIFI_P2P_CONNECTION_CHANGED_ACTION</td>
<td style="text-align: center">当设备的Wi-Fi的连接状态发生变化时触发</td>
</tr>
<tr>
<td>WIFI_P2P_PEERS_CHANGED_ACTION</td>
<td style="text-align: center">在调用discoverPeers()时触发，可以调用requestPeers()方法更新设备列表</td>
</tr>
<tr>
<td>WIFI_P2P_STATE_CHANGED_ACTION</td>
<td style="text-align: center">Wi-Fi直连的状态发生变化时触发</td>
</tr>
<tr>
<td>WIFI_P2P_THIS_DEVICE_CHANGED_ACTION</td>
<td style="text-align: center">Wi-Fi直连的设备的详细信息发生变化时触发</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">创建Wi-Fi直连的应用</h2>

<ul>
<li>初始化设置<br/>
首先要保证设置支持Wi-Fi直连相关的协议，如果支持，我们就可以获得WifiP2pManager的实例，创建并注册相关的广播，使用相关的<br/>
api<br/>
在AndroidManifest中必须声明相关的权限,Wi-Fi直连是在api level 14及更高的版本才能使用，还要声明<code>android:minSdkVersion=&quot;14&quot;</code></li>
</ul>

<pre><code class="language-text">&lt;uses-sdk android:minSdkVersion=&quot;14&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
</code></pre>

<ul>
<li>初始化WifiP2pManager的实例，并注册相关的广播，监听Wi-Fi直连的状态<br/>
``` java<br/>
private WifiP2pManager mManager;<br/>
private Channel mChannel;<br/>
private IntentFilter directFilter;<br/>
private WiFiDirectReceiver directReceiver ;</li>
</ul>

<p>@Override<br/>
protected void onCreate(Bundle savedInstanceState) {<br/>
  super.onCreate(savedInstanceState);<br/>
  setContentView(R.layout.activity_main);</p>

<p>mManager = (WifiP2pManager)this.getSystemService(Context.WIFI_P2P_SERVICE);<br/>
  mChannel = mManager.initialize(this, this.getMainLooper(), null);<br/>
  directReceiver = new WiFiDirectReceiver(mManager, mChannel, this);</p>

<p>directFilter = new IntentFilter();<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);</p>

<p>}</p>

<p>//注册广播监听<br/>
@Override<br/>
protected void onResume() {<br/>
  super.onResume();<br/>
  this.registerReceiver(directReceiver, directFilter);<br/>
}</p>

<p>//取消注册<br/>
@Override<br/>
protected void onPause() {<br/>
  super.onPause();<br/>
  this.unregisterReceiver(directReceiver);<br/>
}</p>

<pre><code class="language-text">
- 广播接受

``` java
public class WiFiDirectReceiver extends BroadcastReceiver{

    private WifiP2pManager mManager;
    private Channel mChannel;
    private MainActivity mActivity;
    private PeerListListener mListener;
    private WifiP2pConfig mConfig = new WifiP2pConfig();

    public WiFiDirectReceiver(){}

    public WiFiDirectReceiver(WifiP2pManager manager,Channel channel,MainActivity activity){
        this.mManager = manager;
        this.mChannel = channel;
        this.mActivity = activity;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        Log.e(&quot;tag&quot;, &quot;===============wifi direct action: &quot;+action);
        if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)){
            int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1);
            if(state == WifiP2pManager.WIFI_P2P_STATE_ENABLED){
                //打开
            }else if(state == WifiP2pManager.WIFI_P2P_STATE_DISABLED){
                //关闭
            }
        }else if(action.equals(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)){

        }else if(action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)){

        }else if(action.equals(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)){

        }
    }
}
</code></pre>

<ul>
<li>发现设备</li>
</ul>

<p>在调用之后initialize()方法之后，会触发<code>WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION</code>的广播，在BroadcastReceiver<br/>
中，如果WifiP2pManager.WIFI_P2P_STATE_ENABLED的状态已经打开，在BroadcastReceiver调用discoverPeers方法,如果发现设备.</p>

<p>会回调onSuccess方法  </p>

<pre><code class="language-java">mManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() {
@Override
                    public void onSuccess() {
                        Log.e(&quot;tag&quot;, &quot;===================discovery success&quot;);
                    }

                    @Override
                    public void onFailure(int reason) {
                        Log.e(&quot;tag&quot;, &quot;===================discovery failed&quot;);
                    }
});
</code></pre>

<p>如果发现设备，系统会触发WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION这个广播，在这个广播中可以调用requestPeers方法可以列出所有的设备</p>

<pre><code class="language-java">if(null != mManager){
    mManager.requestPeers(mChannel, new WifiP2pManager.PeerListListener() {
        @Override
        public void onPeersAvailable(WifiP2pDeviceList peers) {
            Log.e(&quot;tag&quot;, &quot;==================peers list size: &quot;+peers.getDeviceList().size());
            for(WifiP2pDevice device: peers.getDeviceList()){
                Log.e(&quot;tag&quot;, &quot;==================device addr: &quot;+device.deviceName+&quot; name: &quot;+device.deviceName);
            }
        }
    });
}
</code></pre>

<ul>
<li>连接设备<br/>
对于已经发现的设备我们可以调用connect()方法连接，需要初始化WifiP2pConfig,并设置config的deviceAddress</li>
</ul>

<pre><code class="language-java">private WifiP2pConfig mConfig = new WifiP2pConfig();  
mConfig.deviceAddress = device.deviceAddress;
mManager.connect(mChannel, mConfig, new WifiP2pManager.ActionListener() {
    @Override
    public void onSuccess() {
        Log.e(&quot;tag&quot;, &quot;==============connnect success&quot;);
    }
    @Override
    public void onFailure(int reason) {
        Log.e(&quot;tag&quot;, &quot;=================connect failed&quot;);
    }
});
</code></pre>

<p>连接成功会回调onSuccess方法</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868648.html">
                
                  <h1>Android 权限机制</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15561207868648/15713243037328.png" alt=""/></p>

<h2 id="toc_0">一、概要</h2>

<p>Android M已经发布一段时间了，市面上很多应用都已经适配Android M。权限机制，作为Android M的一大特性，受到了很多开发者的关注。本文主要分享了以下几个知识点的内容，1、Android权限机制关键知识点；2、QQ音乐对于权限的适配经验；3、近段时间以来遇到的一些Android权限方面的问题。OK，下面进入主题。</p>

<h2 id="toc_1">二、Android权限机制</h2>

<p>已经了解过基本知识的，建议直接跳到第三点（QQ音乐的权限适配经验）。</p>

<p>Android6.0以前，Android的权限机制比较简单，开发者在AndroidManifest文件中声明需要的权限，APP安装时，系统提示用户APP将获取的权限，需要用户同意授权才能继续安装，从此APP便永久的获得了授权。然而，同期的iOS对于权限的处理会更加灵活，权限的授予并不是在安装时，而是在APP运行时，用户可以根据自身的需要，决定是否授予APP某一权限，同时，用户也可以很方便回收授予的权限。显然，动态权限管理的机制，对于用户的隐私保护是更加适用的，Android过于简单的权限机制也受到了不少人的吐槽。终于，Android6.0也发布了动态权限的机制。</p>

<h3 id="toc_2">(一) 开始适配和如何兼容</h3>

<p>APP要适配Android6.0非常简单，只需要将targetSdkVersion和compileSdkVersion都升级到23及以上，同时加入权限检查申请等代码逻辑即可。这里很多人会有一些疑惑，如果针对旧版本的APP在Android6.0机型上运行或者针对Android6.0适配了的APP在Android6.0以下机型上运行，会有什么表现呢？是如何兼容的呢？</p>

<p>1、首先，旧版本APP（targetSdkVersion低于23），因为没有适配权限的申请相关逻辑，在Android6.0以上机型运行的时候，仍然采用安装时授权的方案。</p>

<p>2、适配了Android6.0的APP，在低版本Android系统上运行的时候，仍然采用安装时授权的方案，但是开发者需要注意的是，权限申请的代码逻辑只应该在Android6.0及以上的机型被执行。</p>

<h3 id="toc_3">(二) 危险权限与普通权限</h3>

<p>一开始，听到要加入权限判断和申请代码逻辑的程序员内心可能是崩溃的：正常的一个有一定规模的APP，很容易就七七八八的声明了很多权限，如果每个权限都申请岂不是非常麻烦？</p>

<p>好歹，Google还算比较明智，并不是所有的权限都需要运行时申请才能使用。Google对每个权限的隐私危害性进行了评估。将权限分为了两大类：普通权限和危险权限。举个例子，控制手机震动的权限对于用户并没有什么危害，只要开发者声明了这个权限，安装后就可以一直被授权，也不能被回收，但是，像读取sd卡数据这类权限，很显然就是危险权限了，APP必须向用户申请这个权限。</p>

<p>Google还是很体贴我们开发者的，为了进一步减少开发的工作量和申请权限对用户的骚扰，对危险权限根据各自的属性进行了分组。举个例子，读sd卡和写sd卡，这两个权限通常都是成对声明和使用的，因此，它们被分为一组，而且，只要我们获取了这个权限组里面的任意一个权限，就可以获取整个权限组的权限。Google对于危险权限的定义和分组见下图。<br/><br/>
<img src="media/15561207868648/15713243171181.png" alt=""/></p>

<h3 id="toc_4">(三) 权限相关API说明</h3>

<p>首先，在动态权限申请的流程中，开发者主要关注流程和API如下：</p>

<h4 id="toc_5">1、检查权限是否授予。</h4>

<p>Activity.java<br/>
<code>public int checkSelfPermission(permission)</code></p>

<h4 id="toc_6">2、申请权限。</h4>

<p>Activity.java<br/><br/>
<code>public final void requestPermissions( new String[permission1,permission2,...], requestCode)</code></p>

<p>这个时候，会弹出系统授权弹窗<strong>（授权弹窗是不支持自定义的，原因理所当然）</strong>。</p>

<h4 id="toc_7">3、权限回调。</h4>

<p>用户在系统弹窗里面选择后，结果会通过Activity的<code>onRequestPermissionsResult</code>方法回调APP。</p>

<pre><code class="language-text">public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    //继续执行逻辑或者提示权限获取失败
}
</code></pre>

<h4 id="toc_8">4、权限说明。</h4>

<p>用户如果选择了拒绝，下一次在需要声明该权限的时候，Google建议APP开发者给予用户更多的说明，因此提供了下面这个API,<strong>这个方法返回值在使用过程中会发现有点纠结（具体解析见下面代码块说明）。</strong>  </p>

<pre><code class="language-java">public boolean shouldShowRequestPermissionRationale(permission)
{
    1、APP没有申请这个权限的话，返回false
    2、用户拒绝时，勾选了不再提示的话，返回false
    3、用户拒绝，但是没有勾选不再提示的话，返回true
    因此如果想在第一次就给用户提示，需要记录权限是否申请过，没有申请过的话，强制弹窗提示，而不能根据这个方法的返回值来。
}
</code></pre>

<h2 id="toc_9">三、QQ音乐的权限适配经验</h2>

<h3 id="toc_10">(一) 不同权限，申请的时机不同</h3>

<p>QQ音乐作为一个比较复杂的流媒体应用，也需要不少权限，但是究竟在什么时候来申请这些权限就成了适配6.0时首当其冲问题。针对这个问题，我们也对需要的权限进行了思考，大致认为申请权限需要分为两个时机。</p>

<p><strong>用户触发：</strong>这个很好理解，有些和特性相关的权限，比如说听歌识曲的录音权限、自建歌单封面拍照权限等，这类权限平时APP运行时并不需要，那么我们选择在用户触发或者进入该功能的时候，进行授权受阻逻辑。</p>

<p><strong>应用启动时：</strong>我们在梳理的时候发现，有些权限（读取设备信息，读写sd卡等）并不是由用户或者特性触发的，而是网络免流，登录安全，日志系统这些底层逻辑无时不刻触发的。对于这些权限，就比较纠结了。不过回过头来看，这些权限通常是开发者或者APP不能妥协的权限，因为如果用户不授权的话，将会影响整个APP的功能和数据。所以，我们选择比较暴力的方式，在应用启动的时候，就受阻。这也是Google建议的一种方式。</p>

<p>但是需要注意的是，一开始就申请授权也不要冷冰冰地直接拉起系统弹窗授权，建议先用APP自己的弹窗向用户礼貌地说明为什么需要这几个权限，比如，读取不到设备信息无法联通免流，无法保证登录安全，读取不到SD卡无法播放歌曲等，避免太生硬引起用户的反感。特别是，因为本地化翻译的原因，Google对于权限的弹窗说明很不local，例如我们申请读取设备信息的权限时，系统的弹窗是“电话权限”，这里很容易引起用户的误解，所以，合理的引导和解释是必不可少的。</p>

<h3 id="toc_11">(二) 应用启动授权，需要一个壳</h3>

<p>刚刚已经说到了，很多隐形的权限和特性无关。那么，如果我们直接启动APP，用户又还没有授权的情况下，很多初始化逻辑很容易就因为没有权限crash了，即使没有crash，后面也可能会有或多或少其他的问题。因此，我们需要在这些权限完全授予前，禁止这些逻辑的执行。</p>

<p>做过启动相关的同学都知道，拦截一个APP正常的启动后面再恢复，是很复杂的一件事情，往往我们需要一个外壳来把业务逻辑的内壳隔绝开。就QQ音乐而言，我们很容易的就想到了dex加载的壳，需求也很类似，dex加载也需要优先于业务来做。顺着这个思路，很自然地，我们就选择了在dex的壳里面做权限的受阻逻辑，而且也很快很好的达到了预期的效果。相信现在大部分APP都是分dex的了，因此建议按照这个方式来做，可以节省很多的工作量。</p>

<h2 id="toc_12">四、Android权限机制“乱象”</h2>

<p>这里要说的乱象，其实是和Android严重的碎片化有一定的关系。随着国产ROM越来越个性，很多ROM在尝试建立自己的权限机制，有些甚至基于Android5.x就开放了原生的或者开发了自己的权限机制。而面对这些情况，我们往往能做的非常有限，举几个例子。</p>

<h3 id="toc_13">(一) 读取运动数据权限</h3>

<p>开发QQ音乐跑步电台的过程中发现，在某国产ROM的一些机型上会提示“应用读取运动数据权限”的系统弹窗。可是，反复查阅相关API发现，我们使用的计步相关的Sensor并不需要申请什么权限。可如果用户选择了拒绝，即使APP注册了Sensor，也收不到系统的回调。后来联系该厂商的相关人员后，给出的答复是，第三方APP无法检查和申请这个权限，这个权限本身也属于该厂商ROM自己的权限机制。</p>

<p>类似的案例还有一个，就是在某厂商的手机管家，会一直提示QQ音乐尝试读取应用程序列表。其实，我们并没有读取应用程序列表，只是调用了PackageManager相关的一些API，就是触发这个告警。</p>

<p>对于这类问题，我们怀疑，第三方ROM是在运行时检测到了APP调用了相关的API后，进行权限阻断。这里开发同学需要注意的是，被阻断的API不一定会导致crash，但是可能导致我们获取不到正确的返回值或者收不到系统的一些消息回调。</p>

<h3 id="toc_14">(二) 无法添加快捷方式</h3>

<p>本来<code>&lt;uses-permission android:name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot;/&gt;</code>声明后，我们就可以在桌面上创建快捷方式了，而且这个权限也不是危险权限。可是某些国产ROM，对于APP添加快捷方式限制的比较严，必须要用户在设置里面手动允许添加快捷方式后，APP才能最终成功的添加。这种情况，APP也不能知道是否能添加快捷方式，只能默默的添加失败了。不过好在这里受影响并不是主快捷方式，而且某些功能的快捷方式入口。</p>

<h3 id="toc_15">(三) 消失的桌面歌词，悬浮窗权限</h3>

<p>QQ音乐桌面歌词采用了向WindowManager里面添加View的方式实现。可是很多国产ROM很早就具备了悬浮窗权限。一开始，我们将type改为LayoutParams.TYPE_TOAST同时声明<code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;</code>这个普通权限，躲避了大多数系统的问题。可是，2016年底，随着某ROM系统的升级，这一招也没用了，大批用户反馈爆发。</p>

<p>我们继续尝试检测悬浮窗权限，发现<code>checkPermission（&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;）</code>返回的结果永远是true，因此这条路也走不通。</p>

<p>最终，经过各种查阅，发现这个悬浮窗权限并不在Android6.0标准的权限机制内，而是AppOpsManager里面已经被隐藏了的一个开关位，对应于第24个开关。需要注意的是，AppOpsManager这个类很早就有了，但是很多ROM隐藏了checkOp的方法，好在最后发现通过反射仍旧可以调用这个方法检测权限是否打开。  </p>

<pre><code class="language-java"> AppOpsManager manager = (AppOpsManager) context.getSystemService(&quot;appops&quot;);
try {
    Object object = invokeMethod(manager, &quot;checkOp&quot;, op, Binder.getCallingUid(), getPackageName(context));
    return AppOpsManager.MODE_ALLOWED == (Integer) object;
} catch (Exception e) {
    MLog.e(TAG, &quot;CheckPermission &quot; + e.toString());
}
</code></pre>

<p>不过，要打开悬浮窗权限，不同ROM的路径还不一样，有的是在设置里面，有的是在系统自带的管家里面，最后我们只能根据不同的ROM，给予用户不同的引导，终于将反馈量降了下去。</p>

<p><strong>转载自<a href="http://mp.weixin.qq.com/s/YL-NooJmsqbGSUlpNmpqbw">Android权限机制与适配经验</a></strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868683.html">
                
                  <h1>Android 存储方式以及路径API</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>首先说一句,平时说的存储分成了内部存储和外部存储。注意内部存储又叫做机身内存，而且内存又包含了两个部分RAM(运行时内存,这个和运行速度有关系，是手机运行时存储数据和指令的地方)、ROM(这个才算是真正存储东西的内部存储范围，是应用配置和其他数据的地方);而外部存储就很明确了,用户的外部挂载存储设备,如SD卡,手机的内部存储卡。</p>

<p>来介绍几个概念:</p>

<h2 id="toc_0">一、内存</h2>

<p>全称内部存储,英文名(InternalStorage)。当我们在打开DDMS下的File Explorer面板的时候，/data目录就是所谓的内部存储 (ROM )。<br/><br/>
但是注意，当手机没有root的时候不能打开此文件夹。<br/><br/>
当打开data文件夹的时候，目录结构如下:<br/><br/>
<img src="media/15561207868683/15713243301697.png" alt=""/></p>

<p>这里一般都是关注两个最重要的文件夹: </p>

<ul>
<li>app文件夹里存放着我们所有安装的app的apk文件，并且当我们调试一个app的时候，可以看到控制台输出的内容，有一项是uploading …..就是上传我们的apk到这个文件夹，上传成功之后才开始安装。 <br/>
这里写图片描述 </li>
<li>第二个文件夹是data,也就是我们常说的/data/data目录(存储包私有数据)。此目录下将每一个APP的存储内容按照包名分类存放好。 <br/>
比如: 
<ul>
<li>data/data/包名/shared_prefs 存放该APP内的SP信息 </li>
<li>data/data/包名/databases 存放该APP的数据库信息 </li>
<li>data/data/包名/files 将APP的文件信息存放在files文件夹 </li>
<li>data/data/包名/cache 存放的是APP的缓存信息 </li>
</ul></li>
</ul>

<p>多扯一句,下面的代码就会在files文件夹先创建一个hello_file文件并写入了数据:</p>

<pre><code class="language-java">String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;
FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_APPEND|Context.MODE_WORLD_READABLE);
fos.write(string.getBytes());
fos.close();
</code></pre>

<h2 id="toc_1">二、外存</h2>

<p>/storage/sdcard/Android/data目录或者说/storage/emulated/0/Android/data包目录属于外部存储。比如我们的内部存储卡。 <br/>
注意,Google官方建议开发者将App的数据存储在私有目录即/storage/emulated/0/Android/data包下，这样卸载App时数据会随之被系统清除，不会造成数据残留。 </p>

<h2 id="toc_2">三、除了/data之外的存储目录</h2>

<ol>
<li><strong>/mnt</strong>:这个目录专门用来当作挂载点(MountPoint)。通俗点说,/mnt就是来挂载外部存储设备的(如sdcard),我们的sdcard将会被手机系统视作一个文件夹,这个文件夹将会被系统嵌入到收集系统的mnt目录 </li>
<li><strong>/dev包</strong>:Linux系统的常规文件夹。 </li>
<li><p><strong>/system包</strong>:系统配置的文件夹，比如Android系统框架（framework）、底层类库（lib）、字体（font）等。 </p></li>
</ol>

<ul>
<li>1、下面说一下路径API和对以上的文件的操作:<br/>
<code>context.getFilesDir().getAbsolutePath()</code><br/>
<code>context.getFilesDir().getPath()</code><br/></li>
</ul>

<p>上面的两个API都是得到应用程序私有目录下的文件路径:<br/><br/>
<code>/data/data/包名/files</code></p>

<ul>
<li><p>2、<code>context.getCacheDir().getPath()</code><br/><br/>
取得应用程序的缓存文件在内部存储上的存储路径<br/><br/>
<code>/data/data/包名/cache</code>  </p></li>
<li><p>3、<code>context.getExternalCacheDir().getAbsolutePath()</code>和<code>context.getExternalCacheDir().getCanonicalPath()</code><br/>
取得应用程序的缓存文件在外部存储上的存储路径<br/><br/>
<code>/storage/sdcard/Android/data/包名/cache</code></p></li>
<li><p>4、<code>context.getObbDir().getAbsolutePath()</code><br/>
取得外部存储obb目录的根路径<br/><br/>
<code>/storage/sdcard/Android/obb/包名</code></p></li>
<li><p>5、<code>Environment.getExternalStorageState()</code><br/><br/>
得到外部存储卡(sdcard)的存储状态<br/><br/>
<code>mounted</code>  </p></li>
<li><p>6、<code>Environment.getExternalStorageDirectory().getAbsolutePath()</code><br/><br/>
得到外部存储的整个根路径<br/><br/>
<code>/storage/sdcard</code>  </p></li>
<li><p>7、<code>Environment.getDownloadCacheDirectory().getAbsolutePath()</code><br/><br/>
得到外部存储的下载文件的缓存路径<br/>
<code>/cache</code></p></li>
<li><p>8、<code>Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getAbsolutePath()</code><br/><br/>
得到外部存储的图片的根路径<br/><br/>
<code>/storage/sdcard/Pictures</code></p></li>
<li><p>9、<code>Environment.getRootDirectory().getAbsolutePath()</code><br/><br/>
<code>/system</code></p></li>
<li><p>10、<code>Environment.getDataDirectory().getAbsolutePath()</code></p></li>
</ul>

<p><code>/data</code></p>

<h2 id="toc_3">最后总结一下:</h2>

<ul>
<li>内部数据：/data/data/包名/XXX </li>
<li>外部私有数据：/storage/emulated/0/Android/data/包名/XXX </li>
<li>外部公有数据：/storage/emulated/0/包名/XXX</li>
</ul>

<p>当用应用管理来清除数据的时候: </p>

<ul>
<li>清除缓存：将外部私有数据下的cache包（/storage/emulated/0/Android/data/包名/cache）清除，将内部数据下的cache包下的内容（/data/data/包名/cache/XXX）清除 。 </li>
<li>清楚数据：将外部私有数据包（/storage/emulated/0/Android/data/包名）清除，将内部数据下的所有内容（/data/data/包名/XXX）清除；</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868614.html">
                
                  <h1>Android 响应式编程的应用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">响应式编程简介</h2>

<ul>
<li>响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</li>
<li>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们更改电子表（变化的传播）中的一些数值时，我们需要更新整个表格或者我们的机器人碰到墙时会转弯（响应事件）。</li>
<li>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</li>
</ul>

<h2 id="toc_1">响应式编程的具体实现-RxJava</h2>

<h3 id="toc_2">基本概念</h3>

<h4 id="toc_3">RxJava的四种角色</h4>

<ul>
<li>Observable</li>
<li>Observer</li>
<li>Subscriber</li>
<li>Subject</li>
<li>Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。</li>
</ul>

<h4 id="toc_4">热Observable和冷Observable</h4>

<p>从发射物的角度来看，有两种不同的Observable:热的和冷的。一个”热”的Observable典型的只要一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。</p>

<h4 id="toc_5">Observable创建符</h4>

<ul>
<li>Observable.create()</li>
</ul>

<pre><code class="language-java">Observable.create(new Observable.OnSubscribe&lt;Object&gt;(){
    @Override
    public void call(Subscriber&lt;? super Object&gt; subscriber{
    }
});
</code></pre>

<ul>
<li>Observable.from()<br/>
from() 创建符可以从一个列表/数组来创建Observable,并一个接一个的从列表/数组中发射出来每一个对象，或者也可以从Java Future 类来创建Observable，并发射Future对象的 .get() 方法返回的结果值。传入 Future 作为参数时，我们可以指定一个超时的值。Observable将等待来自 Future 的结果；如果在超时之前仍然没有结果返回，Observable将会触发 onError() 方法通知观察者有错误发生了。</li>
</ul>

<pre><code class="language-java">List&lt;Integer&gt; items = new ArrayList&lt;Integer&gt;();
items.add(1);
items.add(10);
items.add(100);
items.add(200);

Observable&lt;Integer&gt; observableString = Observable.from(items);
Subscription subscriptionPrint = observableString.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onCompleted() {
    System.out.println(&quot;Observable completed&quot;);
    }
    @Override
    public void onError(Throwable e) {
    System.out.println(&quot;Oh,no! Something wrong happened！&quot;);
    }
    @Override
    public void onNext(Integer item) {
    System.out.println(&quot;Item is &quot; + item);
    }
});
</code></pre>

<ul>
<li>Observable.just()<br/>
just() 方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们。 just() 方法也可以接受列表或数组，就像 from() 方法，但是它不会迭代列表发射每个值,它将会发射整个列表。通常，当我们想发射一组已经定义好的值时会用到它。但是如果我们的函数不是时变性的，我们可以用just来创建一个更有组织性和可测性的代码库。</li>
</ul>

<pre><code class="language-java">Observable&lt;String&gt; observableString = Observable.just(helloWorld
());
Subscription subscriptionPrint = observableString.subscribe(new
Observer&lt;String&gt;() {
    @Override
    public void onCompleted() {
    System.out.println(&quot;Observable completed&quot;);
    }
    @Override
    public void onError(Throwable e) {
    System.out.println(&quot;Oh,no! Something wrong happened!&quot;);
    }
    @Override
    public void onNext(String message) {
    System.out.println(message);
    }
});
</code></pre>

<p>helloWorld() 方法比较简单，像这样：</p>

<pre><code class="language-java">private String helloWorld(){
    return &quot;Hello World&quot;;
}
</code></pre>

<h3 id="toc_6">Subject</h3>

<p>Subject 既可以是 Observable，也可以是 Observer。 <br/>
RxJava 提供四种不同的 Subject :</p>

<ul>
<li>PublishSubject</li>
<li>BehaviorSubject<br/>
BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。<br/></li>
</ul>

<p><code>BehaviorSubject&lt;Integer&gt; behaviorSubject = BehaviorSubject.create(1);</code>  </p>

<p>在这个短例子中，我们创建了一个能发射整形(Integer)的BehaviorSubject。由于每当Observes订阅它时就会发射最新的数据，所以它需要一个初始值。</p>

<ul>
<li>ReplaySubject<br/>
ReplaySubject 会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发:<br/></li>
</ul>

<p><code>ReplaySubject&lt;Integer&gt; replaySubject = ReplaySubject.create();</code></p>

<ul>
<li>AsyncSubject<br/>
当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。<br/></li>
</ul>

<p><code>AsyncSubject&lt;Integer&gt; asyncSubject = AsyncSubject.create();</code></p>

<h3 id="toc_7">直接创建 Observable</h3>

<p>在我们的第一个列子里，我们将检索安装的应用列表并填充RecycleView的item来展示它们。我们也设想一个下拉刷新的功能和一个进度条来告知用户当前任务正在执行。</p>

<p>首先，我们创建Observable。我们需要一个函数来检索安装的应用程序列表并把它提供给我们的观察者。我们一个接一个的发射这些应用程序数据，将它们分组到一个单独的列表中，以此来展示响应式方法的灵活性。</p>

<pre><code class="language-java">private Observable&lt;AppInfo&gt; getApps(){
    return Observable.create(subscriber -&gt; {
        List&lt;AppInfoRich&gt; apps = new ArrayList&lt;AppInfoRich&gt;();
        final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
        mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        List&lt;ResolveInfo&gt; infos = getActivity().queryIntentActivities(mainIntent, 0);
        for(ResolveInfo info : infos){
            apps.add(new AppInfoRich(getActivity(),info));
        }
        for (AppInfoRich appInfo:apps) {
            Bitmap icon = Utils.drawableToBitmap(appInfo.getIcon());
            String name = appInfo.getName();
            String iconPath = mFilesDir + &quot;/&quot; + name;
            Utils.storeBitmap(App.instance, icon,name);
            if (subscriber.isUnsubscribed()){
                return;
            }
            subscriber.onNext(new AppInfo(name, iconPath, appInfo.getLastUpdateTime()));
        }
        if (!subscriber.isUnsubscribed()){
            subscriber.onCompleted();
        }
    });
}
</code></pre>

<p>AppInfo为App信息的实体类，包括上次更新时间、图标、名字三个属性，此处省略。</p>

<p><strong>需要重点注意的是在发射新的数据或者完成序列之前要检测观察者的订阅情况。这样的话代码会更高效，因为如果没有观察者等待时我们就不生成没有必要的数据项。</strong></p>

<p>接下来，我们来定义下拉刷新的方法：  </p>

<pre><code class="language-java">private void refreshTheList() {
    getApps().toSortedList()
    .subscribe(new Observer&lt;List&lt;AppInfo&gt;&gt;() {
    @Override
    public void onCompleted() {
        Toast.makeText(getActivity(), &quot;Here is the list!&quot;, Toast.LENGTH_LONG).show();
    }
    @Override
    public void onError(Throwable e) {
        Toast.makeText(getActivity(), &quot;Something went wrong!&quot;, Toast.LENGTH_SHORT).show();
        mSwipeRefreshLayout.setRefreshing(false);
    }
    @Override
    public void onNext(List&lt;AppInfo&gt; appInfos) {
        mRecyclerView.setVisibility(View.VISIBLE);
        mAdapter.addApplications(appInfos);
        mSwipeRefreshLayout.setRefreshing(false);
    }
    });
}
</code></pre>

<h3 id="toc_8">从列表创建 Observable</h3>

<p>在这个例子中，我们将引入 from() 函数。使用这个特殊的“创建”函数，我们可以从一个列表中创建一个Observable。Observable将发射出列表中的每一个元素，我们可以通过订阅它们来对这些发出的元素做出响应。  </p>

<pre><code class="language-java">private void loadList(List&lt;AppInfo&gt; apps) {
    mRecyclerView.setVisibility(View.VISIBLE);
    Observable.from(apps).subscribe(new Observer&lt;AppInfo&gt;() {
        @Override
        public void onCompleted() {
            mSwipeRefreshLayout.setRefreshing(false);
            Toast.makeText(getActivity(), &quot;Here is the list!&quot;, Toast.LENGTH_LONG).show();
        }
        @Override
        public void onError(Throwable e) {
            Toast.makeText(getActivity(), &quot;Something went wrong!&quot;, Toast.LENGTH_SHORT).show();
            mSwipeRefreshLayout.setRefreshing(false);
        }
        @Override
        public void onNext(AppInfo appInfo) {
            mAddedApps.add(appInfo);
            mAdapter.addApplication(mAddedApps.size() - 1, appInfo);
        }
    });
}
</code></pre>

<p>和第一个例子一个主要的不同是我们在 onCompleted() 函数中停掉进度条是因为我们一个一个的发射元素；<br/><br/>
第一个例子中的Observable发射的是整个list,因此在 onNext() 函数中停掉进度条的做法是安全的。  </p>

<h3 id="toc_9">具有特殊功能的创建符</h3>

<ul>
<li>just()<br/>
你可以将一个函数作为参数传给 just() 方法，你将会得到一个已存在代码的原始Observable版本。在一个新的响应式架构的基础上迁移已存在的代码，这个方法可能是一个有用的开始点。</li>
<li>repeat()<br/>
假如你想对一个Observable重复发射三次数据 :
<code>java
Observable.just(appOne,appTwo,appThree)<br/>
.repeat(3)<br/>
.subscribe();
</code></li>
</ul>

<p>我们在 just() 创建Observable后追加了 repeat(3) ，它将会创建9个元素的序列，每一个都单独发射。</p>

<ul>
<li>defer()<br/>
有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。看下面的 getInt() 函数：
<code>java
private Observable&lt;Integer&gt; getInt(){<br/>
return Observable.create(subscriber -&gt; {<br/>
    if(subscriber.isUnsubscribed()){<br/>
        return;<br/>
    }<br/>
    App.L.debug(&quot;GETINT&quot;);<br/>
    subscriber.onNext(42);<br/>
    subscriber.onCompleted();<br/>
});<br/>
}
</code></li>
</ul>

<p>这比较简单，并且它没有做太多事情，但是它正好为我们服务。现在，我们可以创建一个新的Observable并且应用 defer() :</p>

<p><code>Observable&lt;Integer&gt; deferred = Observable.defer(this::getInt);</code>  </p>

<p>这次， deferred 存在，但是 getInt() create() 方法还没有调用 : logcat日志也没有“GETINT”打印出来 :</p>

<pre><code class="language-java">deferred.subscribe(number -&gt; {
    App.L.debug(String.valueOf(number));
});
</code></pre>

<p>但是一旦我们订阅了， create() 方法就会被调用并且我们也可以在logcat日志中打印出两个值：GETINT 和 42。</p>

<ul>
<li><p>range()<br/><br/>
从一个指定的数字X开始发射N个数字。range() 函数用两个数字作为参数：第一个是起始点，第二个是我们想发射数字的个数。</p></li>
<li><p>interval()<br/><br/>
interval() 函数在你需要创建一个轮询程序时非常好用。interval() 函数的两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。</p></li>
<li><p>timer()<br/><br/>
如果你需要一个一段时间之后才发射的Observable，你可以使用 timer()。</p></li>
</ul>

<h2 id="toc_10">过滤Observables</h2>

<h3 id="toc_11">过滤序列</h3>

<p>RxJava让我们使用 filter() 方法来过滤我们观测序列中不想要的值。</p>

<p>我们从发出的每个元素中过滤掉开头字母不是C的 :</p>

<pre><code class="language-java">.filter(new Func1&lt;AppInfo,Boolean&gt;(){
    @Override
    public Boolean call(AppInfo appInfo){
        return appInfo.getName().startsWith(&quot;C&quot;);
    }
})
</code></pre>

<p>我们传一个新的 Func1 对象给 filter() 函数，即只有一个参数的函数。 Func1 有一个 AppInfo 对象来作为它的参数类型并且返回 Boolean 对象。只要条件符合 filter() 函数就会返回 true 。此时，值会发射出去并且所有的观察者都会接收到。</p>

<p>filter() 函数最常用的用法之一时过滤 null 对象：</p>

<pre><code class="language-java">.filter(new Func1&lt;AppInfo,Boolean&gt;(){
    @Override
    public Boolean call(AppInfo appInfo){
        return appInfo != null;
    }
})
</code></pre>

<p>它帮我们免去了在 onNext() 函数调用中再去检测 null 值，让我们把注意力集中在应用业务逻辑上。</p>

<h3 id="toc_12">获取我们需要的数据</h3>

<p>当我们不需要整个序列时，而是只想取开头或结尾的几个元素，我们可以用 take() 或 takeLast() 。</p>

<ul>
<li><p>take()<br/><br/>
take() 函数用整数N来作为一个参数，从原始的序列中发射前N个元素，然后完成：</p>
<pre><code class="language-java">Observable.from(apps)
.take(3)<br/>
.subscribe(...);
</code></pre></li>
<li><p>takeLast()<br/><br/>
如果我们想要最后N个元素，我们只需使用 takeLast() 函数：</p>
<pre><code class="language-java">Observable.from(apps)
.takeLast(3)<br/>
.subscribe(...);
</code></pre></li>
</ul>

<h3 id="toc_13">有且仅有一次</h3>

<ul>
<li>distinct()<br/>
就像 takeLast() 一样， distinct() 作用于一个完整的序列，然后得到重复的过滤项，它需要记录每一个发射的值。如果你在处理一大堆序列或者大的数据记得关注内存使用情况。</li>
</ul>

<pre><code class="language-java">Observable&lt;AppInfo&gt; fullOfDuplicates = Observable.from(apps)
    .take(3)
    .repeat(3);
fullOfDuplicates.distinct()
    .subscribe(...);
</code></pre>

<ul>
<li>ditinctUntilChanged()<br/>
如果在一个可观测序列发射一个不同于之前的一个新值时让我们得到通知这时候该怎么做？ditinctUntilChanged() 过滤函数能做到这一点。它能轻易的忽略掉所有的重复并且只发射出新的值。</li>
</ul>

<h3 id="toc_14">First and last</h3>

<p>first() 方法和 last() 方法很容易弄明白。它们从Observable中只发射第一个元素或者最后一个元素。这两个都可以传 Func1 作为参数。 <br/>
与 first() 和 last() 相似的变量有： firstOrDefault() 和 lastOrDefault() 。这两个函数当可观测序列完成时不再发射任何值时用得上。在这种场景下，如果Observable不再发射任何值时我们可以指定发射一个默认的值。</p>

<h3 id="toc_15">Skip and SkipLast</h3>

<p>skip() 和 skipLast() 函数与 take() 和 takeLast() 相对应。它们用整数N作参数，从本质上来说，它们不让Observable发射前N个或者后N个值。</p>

<h3 id="toc_16">ElementAt</h3>

<p>如果我们只想要可观测序列发射的第五个元素该怎么办？ elementAt() 函数仅从一个序列中发射第n个元素然后就完成了。 <br/>
如果我们想查找第五个元素但是可观测序列只有三个元素可供发射时该怎么办？我们可以使用 elementAtOrDefault() 。</p>

<h3 id="toc_17">Sampling</h3>

<p>在Observable后面加一个 sample() ，我们将创建一个新的可观测序列，它将在一个指定的时间间隔里由Observable发射最近一次的数值： </p>

<pre><code class="language-java">Observable&lt;Integer&gt; sensor = [...]
sensor.sample(30,TimeUnit.SECONDS)
    .subscribe(...);
</code></pre>

<p>如果我们想让它定时发射第一个元素而不是最近的一个元素，我们可以使用 throttleFirst() 。</p>

<h3 id="toc_18">Timeout</h3>

<p>我们可以使用 timeout() 函数来监听源可观测序列,就是在我们设定的时间间隔内如果没有得到一个值则发射一个错误。我们可以认为 timeout() 为一个Observable的限时的副本。如果在指定的时间间隔内Observable不发射值的话，它监听的原始的Observable时就会触发 onError() 函数。</p>

<pre><code class="language-java">Subscription subscription = getCurrentTemperature()
    .timeout(2,TimeUnit.SECONDS)
    .subscribe(...);
</code></pre>

<h3 id="toc_19">Debounce</h3>

<p>debounce() 函数过滤掉由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。  </p>

<p>下图展示了多久从Observable发射一次新的数据， debounce() 函数开启一个内部定时器，如果在这个时间间隔内没有新的据发射，则新的Observable发射出最后一个数据：  </p>

<p><img src="media/15561207868614/15713241823890.png" alt=""/></p>

<h2 id="toc_20">变换Observables</h2>

<h3 id="toc_21">*map家族</h3>

<p>RxJava提供了几个mapping函数： map() , flatMap() , concatMap() , flatMapIterable() 以及 switchMap() .所有这些函数都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。</p>

<ul>
<li>Map<br/>
RxJava的 map 函数接收一个指定的 Func 对象然后将它应用到每一个由Observable发射的值上。</li>
</ul>

<pre><code class="language-java">Observable.from(apps)
    .map(new Func1&lt;AppInfo,AppInfo&gt;(){
        @Override
        public Appinfo call(AppInfo appInfo){
            String currentName = appInfo.getName();
            String lowerCaseName = currentName.toLowerCase();
            appInfo.setName(lowerCaseName);
            return appInfo;
        }
    })
    .subscribe(...);
</code></pre>

<p>正如你看到的，像往常一样创建我们发射的Observable之后，我们追加一个 map 调用，我们创建一个简单的函数来更新 AppInfo对象并提供一个名字小写的新版本给观察者。</p>

<ul>
<li>FlatMap<br/>
在复杂的场景中，我们有一个这样的Observable：它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的 flatMap() 函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。<br/>
<img src="media/15561207868614/15713242041015.png" alt=""/></li>
</ul>

<p>当我们在处理可能有大量的Observables时，重要是记住任何一个Observables发生错误的情况， flatMap() 将会触发它自己的 onError() 函数并放弃整个链。重要的一点提示是关于合并部分：它允许交叉。正如上图所示，这意味着 flatMap() 不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p>

<ul>
<li><p>ConcatMap<br/><br/>
RxJava的 concatMap() 函数解决了 flatMap() 的交叉问题，提供了一种能够把发射的值连续在一起的铺平函数，而不是合并它们，如下图所示：<br/><br/>
<img src="media/15561207868614/15713242157322.png" alt=""/></p></li>
<li><p>FlatMapIterable<br/><br/>
作为*map家族的一员， flatMapInterable() 和 flatMap() 很像。仅有的本质不同是它将源数据两两结成对并生成Iterable，而不是原始数据项和生成的Observables。</p></li>
<li><p>SwitchMap<br/><br/>
switchMap() 和 flatMap() 很像，除了一点：每当源Observable发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的Observable，并开始监视当前发射的这一个。</p></li>
<li><p>Scan<br/><br/>
RxJava的 scan() 函数可以看做是一个累积函数。 scan() 函数对原始Observable发射的每一项数据都应用一个函数，计算出函数的结果值，并将该值填充回可观测序列，等待和下一次发射的数据一起使用。</p></li>
</ul>

<p>作为一个通用的例子，给出一个累加器：</p>

<pre><code class="language-java">Observable.just(1,2,3,4,5)
    .scan((sum,item) -&gt; sum + item)
    .subscribe(new Subscriber&lt;Integer&gt;() {
        @Override
        public void onCompleted() {
            Log.d(&quot;RXJAVA&quot;, &quot;Sequence completed.&quot;);
        }
        @Override
        public void onError(Throwable e) {
            Log.e(&quot;RXJAVA&quot;, &quot;Something went south!&quot;);
        }
        @Override
        public void onNext(Integer item) {
            Log.d(&quot;RXJAVA&quot;, &quot;item is: &quot; + item);
        }
    });
</code></pre>

<p>我们得到的结果是：</p>

<p><code>RXJAVA: item is: 1</code><br/><br/>
<code>RXJAVA: item is: 3</code><br/><br/>
<code>RXJAVA: item is: 6</code><br/><br/>
<code>RXJAVA: item is: 10</code><br/><br/>
<code>RXJAVA: item is: 15</code><br/><br/>
<code>RXJAVA: Sequence completed.</code>  </p>

<h3 id="toc_22">GroupBy</h3>

<p>RxJava提供了一个有用的函数从列表中按照指定的规则： groupBy() 来分组元素。下图中的例子展示了 groupBy() 如何将发射的值根据他们的形状来进行分组。</p>

<p><img src="media/15561207868614/15713242370442.png" alt=""/></p>

<p>这个函数将源Observable变换成一个发射Observables的新的Observable。它们中的每一个新的Observable都发射一组指定的数据。</p>

<p>为了创建一个分组了的已安装应用列表，我们在 loadList() 函数中引入了一个新的元素：</p>

<pre><code class="language-java">Observable&lt;GroupedObservable&lt;String,AppInfo&gt;&gt; groupedItems = Observable.from(apps)
            .groupBy(new Func1&lt;AppInfo,String&gt;(){
                @Override
                public String call(AppInfo appInfo){
                    SimpleDateFormat formatter = new SimpleDateFormat(&quot;MM/yyyy&quot;);
                    return formatter.format(new Date(appInfo.getLastUpdateTime()));
                }
            });
</code></pre>

<p>现在我们创建了一个新的Observable， groupedItems ，它将会发射一个带有 GroupedObservable 的序列。 GroupedObservable 是一个特殊的Observable，它源自一个分组的key。在这个例子中，key就是 String ，代表的意思是 Month/Year 格式化的最近更新日期。</p>

<h3 id="toc_23">Buffer</h3>

<p>RxJava中的 buffer() 函数将源Observable变换一个新的Observable，这个新的Observable每次发射一组列表值而不是一个一个发射。</p>

<p>buffer() 函数有几种变体。其中有一个是允许你指定一个 skip 值：此后每 skip 项数据，用count项数据填充缓冲区。另一个是buffer() 带一个 timespan 的参数，会创建一个每隔timespan时间段就会发射一个列表的Observable。</p>

<h3 id="toc_24">Window</h3>

<p>RxJava的 window() 函数和 buffer() 很像，但是它发射的是Observable而不是列表。</p>

<p>正如 buffer() 一样, window() 也有一个 skip 变体。</p>

<h3 id="toc_25">Cast</h3>

<p>cast() 函数是 map() 操作符的特殊版本。它将源Observable中的每一项数据都转换为新的类型，把它变成了不同的 Class 。</p>

<h2 id="toc_26">组合Observables</h2>

<h3 id="toc_27">Merge</h3>

<p>在”异步的世界“中经常会创建这样的场景，我们有多个来源但是又只想有一个结果：多输入，单输出。RxJava的 merge() 方法将帮助你把两个甚至更多的Observables合并到他们发射的数据项里。下图给出了把两个序列合并在一个最终发射的Observable。</p>

<p><img src="media/15561207868614/15713242485369.png" alt=""/></p>

<p>正如你看到的那样，发射的数据被交叉合并到一个Observable里面。注意如果你同步的合并Observable，它们将连接在一起并且不会交叉。</p>

<pre><code class="language-java">Observable&lt;AppInfo&gt; mergedObserbable = Observable.merge(observableApps,observableReversedApps);
mergedObserbable.subscribe(...);
</code></pre>

<p>注意错误时的toast消息，你可以认为每个Observable抛出的错误都将会打断合并。如果你需要避免这种情况，RxJava提供了 mergeDelayError() ，它能从一个Observable中继续发射数据即便是其中有一个抛出了错误。当所有的Observables都完成时， mergeDelayError() 将会发射 onError()。</p>

<h3 id="toc_28">ZIP</h3>

<p>在一种新的可能场景中处理多个数据来源时会带来：多从个Observables接收数据，处理它们，然后将它们合并成一个新的可观测序列来使用。RxJava有一个特殊的方法可以完成： zip() 合并两个或者多个Observables发射出的数据项，根据指定的函数Func* 变换它们，并发射一个新值。下图展示了 zip() 方法如何处理发射的“numbers”和“letters”然后将它们合并一个新的数据项：</p>

<p><img src="media/15561207868614/15713242603739.png" alt=""/></p>

<pre><code class="language-java">Observable.zip(observableApp, tictoc, (AppInfo appInfo, Long time) -&gt; updateTitle(appInfo, time))
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(...);
</code></pre>

<p>zip() 函数有三个参数：两个Observables和一个 Func2 。</p>

<h3 id="toc_29">Join</h3>

<p>前面两个方法， zip() 和 merge() 方法作用在发射数据的范畴内，在决定如何操作值之前有些场景我们需要考虑时间的。RxJava的 join() 函数基于时间窗口将两个Observables发射的数据结合在一起。</p>

<p><img src="media/15561207868614/15713242707235.png" alt=""/></p>

<p>为了正确的理解上一张图，我们解释下 join() 需要的参数：</p>

<ul>
<li>第二个Observable和源Observable结合。</li>
<li>Func1 参数：在指定的由时间窗口定义时间间隔内，源Observable发射的数据和从第二个Observable发射的数据相互配合返回的Observable。</li>
<li>Func1 参数：在指定的由时间窗口定义时间间隔内，第二个Observable发射的数据和从源Observable发射的数据相互配合返回的Observable。</li>
<li>Func2 参数：定义已发射的数据如何与新发射的数据项相结合。</li>
</ul>

<h3 id="toc_30">combineLatest</h3>

<p>RxJava的 combineLatest() 函数有点像 zip() 函数的特殊形式。正如我们已经学习的， zip() 作用于最近未打包的两个Observables。相反， combineLatest() 作用于最近发射的数据项：如果 Observable1 发射了A并且 Observable2 发射了B和C， combineLatest() 将会分组处理AB和AC，如下图所示：</p>

<p><img src="media/15561207868614/15713242799691.png" alt=""/></p>

<h3 id="toc_31">And,Then和When</h3>

<p>在将来还有一些 zip() 满足不了的场景。如复杂的架构，或者是仅仅为了个人爱好，你可以使用And/Then/When解决方案。它们在RxJava的joins包下，使用Pattern和Plan作为中介，将发射的数据集合并到一起。</p>

<p><img src="media/15561207868614/15713242911755.png" alt=""/></p>

<h3 id="toc_32">Switch</h3>

<p>给出一个发射多个Observables序列的源Observable， switch() 订阅到源Observable然后开始发射由第一个发射的Observable发射的一样的数据。当源Observable发射一个新的Observable时， switch() 立即取消订阅前一个发射数 <br/>
据的Observable（因此打断了从它那里发射的数据流）然后订阅一个新的Observable，并开始发射它的数据。</p>

<h3 id="toc_33">StartWith</h3>

<p>RxJava的 startWith() 是 concat() 的对应部分。正如 concat() 向发射数据的Observable追加数据那样，在Observable开始发射他们的数据之前，startWith() 通过传递一个参数来先发射一个数据序列。</p>

<h2 id="toc_34">Schedulers-解决Android主线程问题</h2>

<h3 id="toc_35">Schedulers</h3>

<p>调度器以一种最简单的方式将多线程用在你的Apps的中。它们时RxJava重要的一部分并能很好地与Observables协同工作。它们无需处理实现、同步、线程、平台限制、平台变化而可以提供一种灵活的方式来创建并发程序。</p>

<p>RxJava提供了5种调度器：</p>

<ul>
<li>.io()</li>
<li>.computation()</li>
<li>.immediate()</li>
<li>.newThread()</li>
<li>.trampoline()</li>
</ul>

<h4 id="toc_36">Schedulers.io()</h4>

<p>这个调度器时用于I/O操作。它基于根据需要，增长或缩减来自适应的线程池。我们将使用它来修复我们之前看到的 StrictMode 违规做法。由于它专用于I/O操作，所以并不是RxJava的默认方法；正确的使用它是由开发者决定的。</p>

<p><strong>重点需要注意的是线程池是无限制的，大量的I/O调度操作将创建许多个线程并占用内存。一如既往的是，我们需要在性能和简捷两者之间找到一个有效的平衡点。</strong></p>

<h4 id="toc_37">Schedulers.computation()</h4>

<p>这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器： buffer() , debounce() , delay() , interval() , sample() , skip()。</p>

<h4 id="toc_38">Schedulers.immediate()</h4>

<p>这个调度器允许你立即在当前线程执行你指定的工作。它是 timeout() , timeInterval() ,以及 timestamp() 方法默认的调度器。</p>

<h4 id="toc_39">Schedulers.newThread()</h4>

<p>这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。</p>

<h4 id="toc_40">Schedulers.trampoline()</h4>

<p>当我们想在当前线程执行一个任务时，并不是立即，我们可以用 .trampoline() 将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是 repeat() 和 retry() 方法默认的调度器。</p>

<h3 id="toc_41">非阻塞I/O操作</h3>

<p>使用 Schedulers.io() 创建非阻塞的版本：</p>

<pre><code class="language-java">public static void storeBitmap(Context context, Bitmap bitmap, String filename) {
    Schedulers.io().createWorker().schedule(() -&gt; {
        blockingStoreBitmap(context, bitmap, filename);
    });
}
</code></pre>

<h3 id="toc_42">SubscribeOn and ObserveOn</h3>

<p>我们学到了如何在一个调度器上运行一个任务。但是我们如何利用它来和Observables一起工作呢？RxJava提供了 subscribeOn() 方法来用于每个Observable对象。 subscribeOn() 方法用 Scheduler 来作为参数并在这个Scheduler上执行Observable调用。</p>

<p>首先，我们需要一个新的 getApps() 方法来检索已安装的应用列表：</p>

<pre><code class="language-java">private Observable&lt;AppInfo&gt; getApps() {
    return Observable.create(subscriber -&gt; {
        List&lt;AppInfo&gt; apps = new ArrayList&lt;&gt;();
        SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);
        Type appInfoType = new TypeToken&lt;List&lt;AppInfo&gt;&gt;(){}.getType();
        String serializedApps = sharedPref.getString(&quot;APPS&quot;, &quot;&quot;);
        if (!&quot;&quot;.equals(serializedApps)) {
            apps = new Gson().fromJson(serializedApps,appInfoType);
        }
        for (AppInfo app : apps) {
            subscriber.onNext(app);
        }
        subscriber.onCompleted();
    });
}
</code></pre>

<p>然后，我们所需要做的是指定 getApps() 需要在调度器上执行：</p>

<pre><code class="language-java">getApps().subscribeOn(Schedulers.io())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<p>最后，我们只需在 loadList() 函数添加几行代码，那么每一项就都准备好了：</p>

<pre><code class="language-java">getApps()
    .onBackpressureBuffer()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<p>observeOn() 方法将会在指定的调度器上返回结果：如例子中的UI线程。 onBackpressureBuffer() 方法将告诉Observable发射的数据如果比观察者消费的数据要更快的话，它必须把它们存储在缓存中并提供一个合适的时间给它们。</p>

<h3 id="toc_43">处理耗时的任务</h3>

<p>一个与I/O无关的耗时的任务： </p>

<pre><code class="language-java">getObservableApps(apps)
    .onBackpressureBuffer()
    .subscribeOn(Schedulers.computation())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<h1 id="toc_44">总结</h1>

<p>RxJava提供了一种以面向时序的方式考虑数据的机会：所有事情都是持续变化的，数据在更新，事件在触发，然后你就可以创建事件响应式的、灵活的、运行流畅的App。</p>

<p><strong>转载自<a href="http://blog.csdn.net/cmder1000/article/details/54848060">响应式编程在Android中的应用</a></strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868578.html">
                
                  <h1>Android 图片加载框架－Picasso的使用指南</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android 中有几个比较有名的图片加载框架，Universal ImageLoader、Picasso、Glide和Fresco。它们各有优点，以前一直用的是ImageLoader 做项目中的图片加载，由于作者宣布ImageLoader 不会在更新了，因此新的项目打算换一个图片加载框架－Picasso, Picasso 是Square 公司开源的Android 端的图片加载和缓存框架。<strong>Square</strong> 真是一家良心公司啊，为我们Android开发者贡献了很多优秀的开源项目有木有！像什么Rerefoit 、OkHttp、LeakCanary、Picasso等等都是非常火的开源项目。扯远了，回到正题，除了使用简单方便，Picasso还能自动帮我们做以下事情：</p>

<ul>
<li>处理Adapter 中ImageView的回收和取消下载。</li>
<li>使用最小的内存 来做复杂的图片变换。比如高斯模糊，圆角、圆形等处理。</li>
<li>自动帮我们缓存图片。内存和磁盘缓存。<br/>
以上只是列出了Picasso 比较核心的几点，其实它的优点远远不止这些，接下来就看一下如何使用Picasso。</li>
</ul>

<p><img src="media/15561207868578/15713237941280.png" alt=""/></p>

<h2 id="toc_1">一、添加依赖</h2>

<p>要使用Picasso,首先我们要添加版本依赖，去官网或者Github 看一下当前的最新版本(截止本文最新版本为2.5.2)，然后在build.gradle中添加依赖：</p>

<pre><code class="language-text">compile &#39;com.squareup.picasso:picasso:2.5.2&#39;
</code></pre>

<h2 id="toc_2">二、加载显示图片</h2>

<p>将Picasso添加到项目之后，我们就可以用它来加载图片了，使用方法非常简单：</p>

<pre><code class="language-java">Picasso.with(this)
        .load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;)
        .into(mImageView);
</code></pre>

<p>只需要一行代码就完成了加载图片到显示的整个过程，链式调用，非常简洁，其实有三步，一次调用了三个方法：</p>

<ul>
<li>with(Context) 获取一个Picasso单例，参数是一个Context上下文</li>
<li>load(String) 调用load 方法加载图片</li>
<li>into (ImageView) 将图片显示在对应的View上，可以是ImageView，也可以是实现了Target j接口的自定义View。<br/>
上面演示了加载一张网络图片，它还支持其它形式的图片加载，加载文件图片，加载本地资源图片，加载一个Uri 路径给的图片，提供了几个重载的方法：</li>
</ul>

<h3 id="toc_3">(一) load(Uri uri) 加载一个以Uri路径给的图片</h3>

<pre><code class="language-java">Uri uri = Uri.parse(ANDROID_RESOURCE + context.getPackageName() + FOREWARD_SLASH + resourceId)
Picasso.with(this).load(uri).into(mImageView);
</code></pre>

<h3 id="toc_4">(二) load(File file) 加载File中的图片</h3>

<p><code>Picasso.with(this).load(file).into(mImageView);</code></p>

<h3 id="toc_5">(三) load(int resourceId) 加载本地资源图片</h3>

<p><code>Picasso.with(this).load(R.mipmap.ic_launcher).into(mImageView);</code></p>

<blockquote>
<p>提醒：上面介绍了load的几个重载方法，加载不同资源的图片，另外提醒注意一下load(String path)接受String 参数的这个方法，参数String 可以是一个网络图片url,也可以是file 路径、content资源 和Android Resource。看一下源码的注释。</p>

<pre><code class="language-java">/**
   * Start an image request using the specified path. This is a convenience method for calling
   * {@link #load(Uri)}.
   * &lt;p&gt;
   * This path may be a remote URL, file resource (prefixed with {@code file:}), content resource
   * (prefixed with {@code content:}), or android resource (prefixed with {@code
   * android.resource:}.
   * &lt;p&gt;
   * Passing {@code null} as a {@code path} will not trigger any request but will set a
   * placeholder, if one is specified.
   *
   * @see #load(Uri)
   * @see #load(File)
   * @see #load(int)
   * @throws IllegalArgumentException if {@code path} is empty or blank string.
   */
  public RequestCreator load(String path) {
    if (path == null) {
      return new RequestCreator(this, null, 0);
    }
    if (path.trim().length() == 0) {
      throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);
    }
    return load(Uri.parse(path));
  }
</code></pre>

<p>要使用string 参数加载上面的几种资源，除了网络url,其它几种需要加上对应前缀，file文件路径前缀：file: , content 添加前缀：content: ,Android Resource 添加：android.resource:</p>
</blockquote>

<h2 id="toc_6">三、placeholder&amp; error &amp; noPlaceholder &amp; noFade</h2>

<p>通过上面的第一步我们就可以通过Picasso 加载图片了，我们的项目中通常最常用的就是加载网络图片，但是由于网络环境的差异，有时侯加载网络图片的过程有点慢，这样界面上就会显示空ImageView什么也看不见，用户体验非常不好。其实以前用过ImageLoader的同学都知道，ImageLoader 是可以设置加载中显示默认图片的，Picasso当然也给我们提供了这个功能，这就是我们要说的placeholder(占位图)。</p>

<h3 id="toc_7">(一) placeholder</h3>

<p>placeholder提供一张在网络请求还没有完成时显示的图片，它必须是本地图片，代码如下：</p>

<pre><code class="language-java"> Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .into(mImageView);
</code></pre>

<p>设置placeholder之后，在加载图片的时候，就可以显示设置的默认图了，提升用户体验。</p>

<h3 id="toc_8">(二) error</h3>

<p>和placeholder 的用法一样，error 提供一张在加载图片出错的情况下显示的默认图</p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .into(mImageView);
</code></pre>

<h3 id="toc_9">(三) noPlaceholder</h3>

<p>这个方法的意思就是：在调用into的时候明确告诉你没有占位图设置。根据这个方法签名的解释是阻止View被回收的时候Picasso清空target或者设置一个应用的占位图。需要注意的是placeholder和noPlaceholder 不能同时应用在同一个请求上，会抛异常。</p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .noPlaceholder()
                .error(R.drawable.error_iamge)
                .into(mImageView);
</code></pre>

<h3 id="toc_10">(四) noFade</h3>

<p>无论你是否设置了占位图，Picasso 从磁盘或者网络加载图片时，into 显示到ImageView 都会有一个简单的渐入过度效果，让你的UI视觉效果更柔顺丝滑一点，如果你不要这个渐入的效果（没有这么坑爹的需求吧！！！），就调用noFade方法。</p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .noFade()
                .into(mImageView);
</code></pre>

<h2 id="toc_11">四、设置图片尺寸(Resize)、缩放(Scale)和裁剪(Crop)</h2>

<h3 id="toc_12">(一) Resize(int w,int h)</h3>

<p>在项目中，为了带宽、内存使用和下载速度等考虑，服务端给我们的图片的size 应该和我们View 实际的size一样的，但是实际情况并非如此，服务端可能给我们一些奇怪的尺寸的图片，我们可以使用resize(int w,int hei) 来重新设置尺寸。  </p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .into(mImageView);
</code></pre>

<p>resize()方法接受的参数的单位是pixels,还有一个可以设置dp单位的方法，将你的尺寸写在dimens.xml文件中，然后用<code>resizeDimen(int targetWidthResId, int targetHeightResId)</code>方法   </p>

<pre><code class="language-markup">&lt;dimen name=&quot;image_width&quot;&gt;300dp&lt;/dimen&gt;
&lt;dimen name=&quot;image_height&quot;&gt;200dp&lt;/dimen&gt;
</code></pre>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resizeDimen(R.dimen.image_width,R.dimen.image_height)
                .into(mImageView);
</code></pre>

<h3 id="toc_13">(二) onlyScaleDown</h3>

<p>当调用了resize 方法重新设置图片尺寸的时候，调用onlyScaleDown 方法，只有当原始图片的尺寸大于我们指定的尺寸时，resize才起作用,如：  </p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(4000,2000)
                .onlyScaleDown()
                .into(mImageView);
</code></pre>

<p>只有当原来的图片尺寸大于4000 x 2000的时候，resize 才起作用。</p>

<h3 id="toc_14">(三) 图片裁剪 centerCrop()</h3>

<p>这个属性应该不陌生吧！ImageView 的ScaleType 就有这个属性。当我们使用resize 来重新设置图片的尺寸的时候，你会发现有些图片拉伸或者扭曲了（使用ImageView的时候碰到过吧），我要避免这种情况，Picasso 同样给我们提供了一个方法，centerCrop，<strong>充满ImageView 的边界，居中裁剪</strong>。</p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .centerCrop()
                .into(mImageView);
</code></pre>

<h3 id="toc_15">(四) centerInside</h3>

<p>上面的centerCrop是可能看不到全部图片的，如果你想让View将图片展示完全，可以用centerInside，但是如果图片尺寸小于View尺寸的话，是不能充满View边界的。</p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .centerInside()
                .into(mImageView);
</code></pre>

<h3 id="toc_16">(五) fit</h3>

<p>fit 是干什的呢？上面我们需要用resize()来指定我们需要的图片的尺寸，那就是说在程序中需要我们计算我们需要的尺寸（固定大小的除外），这样很麻烦，fit 方法就帮我们解决了这个问题。fit 它会自动测量我们的View的大小，然后内部调用reszie方法把图片裁剪到View的大小，这就帮我们做了计算size和调用resize 这2步。非常方便。代码如下：</p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .into(mImageView);
</code></pre>

<p>使用fit 还是会出现拉伸扭曲的情况，因此最好配合前面的centerCrop使用，代码如下：</p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .centerCrop()
                .into(mImageView);
</code></pre>

<p>看一下对比图:<br/><br/>
<strong>fit(会拉伸):</strong><br/><br/>
<img src="media/15561207868578/15713238082013.png" alt=""/></p>

<p><strong>fit &amp; centerCrop (不会拉伸):</strong><br/><br/>
<img src="media/15561207868578/15713238181812.png" alt=""/></p>

<blockquote>
<p>注意：特别注意，  </p>

<ol>
<li>fit 只对ImageView 有效<br/></li>
<li>使用fit时，ImageView 宽和高不能为wrap_content,很好理解，因为它要测量宽高。</li>
</ol>
</blockquote>

<h2 id="toc_17">五、图片旋转Rotation()</h2>

<p>在图片显示到ImageView 之前，还可以对图片做一些旋转操作，调用<code>rotate(int degree)</code>方法  </p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .rotate(180)
                .into(mImageView);
</code></pre>

<p>这个方法它是以（0，0）点旋转，但是有些时候我们并不想以（0,0）点旋转，还提供了另外一个方法可以指定原点：</p>

<ul>
<li>rotate(float degrees, float pivotX, float pivotY) 以(pivotX, pivotY)为原点旋转</li>
</ul>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .rotate(180,200,100)
                .into(mImageView);
</code></pre>

<h2 id="toc_18">六、转换器Transformation</h2>

<p>Transformation 这就是Picasso的一个非常强大的功能了，它允许你在load图片 -&gt; into ImageView 中间这个过成对图片做一系列的变换。比如你要做图片高斯模糊、添加圆角、做度灰处理、圆形图片等等都可以通过Transformation来完成。</p>

<p>来看一个高斯模糊的例子：</p>

<h3 id="toc_19">(一) 首先定义一个转换器继承 Transformation</h3>

<pre><code class="language-java">public static class BlurTransformation implements Transformation{

        RenderScript rs;

        public BlurTransformation(Context context) {
            super();
            rs = RenderScript.create(context);
        }

        @Override
        public Bitmap transform(Bitmap bitmap) {
            // Create another bitmap that will hold the results of the filter.
            Bitmap blurredBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);

            // Allocate memory for Renderscript to work with
            Allocation input = Allocation.createFromBitmap(rs, blurredBitmap, Allocation.MipmapControl.MIPMAP_FULL, Allocation.USAGE_SHARED);
            Allocation output = Allocation.createTyped(rs, input.getType());

            // Load up an instance of the specific script that we want to use.
            ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));
            script.setInput(input);

            // Set the blur radius
            script.setRadius(25);

            // Start the ScriptIntrinisicBlur
            script.forEach(output);

            // Copy the output to the blurred bitmap
            output.copyTo(blurredBitmap);

            bitmap.recycle();

            return blurredBitmap;
        }

        @Override
        public String key() {
            return &quot;blur&quot;;
        }
    }
</code></pre>

<h3 id="toc_20">(二) 加载图片的时候，在into 方法前面调用 transform方法 应用Transformation</h3>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .transform(new BlurTransformation(this))
                .into(mBlurImage);
</code></pre>

<p>看一下效果图：<br/><br/>
<img src="media/15561207868578/15713238282149.png" alt=""/> </p>

<p>上面为原图，下面为高斯模糊图<br/><br/>
是不是很强大，任何复杂的变换都可以通过Transformation 来做。<br/><br/>
还不止于此，还有更强大的功能。可以在一个请求上应用多个Transformation<br/><br/>
比如：我想先做个灰度处理然后在做一个高斯模糊图：  </p>

<h4 id="toc_21">1.灰度的Transformation</h4>

<pre><code class="language-java">public static class GrayTransformation implements Transformation{

        @Override
        public Bitmap transform(Bitmap source) {
            int width, height;
            height = source.getHeight();
            width = source.getWidth();

            Bitmap bmpGrayscale = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);
            Canvas c = new Canvas(bmpGrayscale);
            Paint paint = new Paint();
            ColorMatrix cm = new ColorMatrix();
            cm.setSaturation(0);
            ColorMatrixColorFilter f = new ColorMatrixColorFilter(cm);
            paint.setColorFilter(f);
            c.drawBitmap(source, 0, 0, paint);

            if(source!=null &amp;&amp; source!=bmpGrayscale){
                source.recycle();
            }
            return bmpGrayscale;
        }

        @Override
        public String key() {
            return &quot;gray&quot;;
        }
    }
</code></pre>

<h4 id="toc_22">2.如果是多个Transformation操作，有2种方式应用</h4>

<p><strong>方式一：直接调用多次transform 方法，不会覆盖的。它只是保存到了一个List 里面</strong></p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .centerCrop()
                .transform(new GrayTransformation())//度灰处理
                .transform(new BlurTransformation(this))//高斯模糊
                .into(mBlurImage);
</code></pre>

<p>需要注意调用的顺序<br/>
<strong>方式二：接受一个List，将Transformation 放大list 里</strong></p>

<pre><code class="language-java">List&lt;Transformation&gt; transformations = new ArrayList&lt;&gt;();
transformations.add(new GrayTransformation());
transformations.add(new BlurTransformation(this));
Picasso.with(this).load(URL)
        .placeholder(R.drawable.default_bg)
        .error(R.drawable.error_iamge)
        .fit()
        .centerCrop()
        .transform(transformations)
        .into(mBlurImage);
</code></pre>

<p>效果图：<br/><br/>
<img src="media/15561207868578/15713238380282.png" alt=""/></p>

<p>如上图，第一张为灰度操作，第二张为 灰度＋高斯模糊<br/><br/>
另外发现了一个开源库，专门写了很多好玩的Transformation，有兴趣的可以看一下：<br/>
<a href="https://github.com/wasabeef/picasso-transformations">picasso-transformations</a></p>

<h2 id="toc_23">七、请求优先级</h2>

<p>Picasso 为请求设置有优先级，有三种优先级，LOW、NORMAL、HIGH。默认情况下都是NORMAL，除了调用fetch 方法，fetch 方法的优先级是LOW。</p>

<pre><code class="language-java">public enum Priority {
    LOW,
    NORMAL,
    HIGH
}
</code></pre>

<p>可以通过priority方法设置请求的优先级，这会影响请求的执行顺序，但是这是不能保证的，它只会往高的优先级靠拢。代码如下：</p>

<pre><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .priority(Picasso.Priority.HIGH)
               // .priority(Picasso.Priority.LOW)
                .into(mImageView);
</code></pre>

<h2 id="toc_24">八、Tag管理请求</h2>

<p>Picasso 允许我们为一个请求设置tag来管理请求，看一下对应的几个方法：<br/><br/>
下面3个方法是Picasso这个类的：  </p>

<ul>
<li>cancelTag(Object tag) 取消设置了给定tag的所有请求</li>
<li>pauseTag(Object tag) 暂停设置了给定tag 的所有请求</li>
<li>resumeTag(Object tag) resume 被暂停的给定tag的所有请求<br/></li>
</ul>

<p>还有一个方法是RequestCreator的:</p>

<ul>
<li>tag(Object tag) 为请求设置tag</li>
</ul>

<p>几个方法的意思也很明确，就是我们可以暂停、resume、和取消请求，可以用在哪些场景呢？</p>

<p><strong>场景一：</strong> 比如一个照片流列表，当我们快速滑动列表浏览照片的时候，后台会一直发起请求加载照片的，这可能会导致卡顿，那么我们就可以为每个请求设置一个相同的Tag，在快速滑动的时候，调用pauseTag暂停请求，当滑动停止的时候，调用resumeTag恢复请求，这样的体验是不是就会更好一些呢。</p>

<p><strong>Adapter中添加如下代码：</strong>  </p>

<pre><code class="language-java">Picasso.with(this).load(mData.get(position))
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .tag(&quot;PhotoTag&quot;)
                .into(holder.mImageView);
</code></pre>

<p><strong>Activity中为RecyclerView添加滑动监听：</strong>  </p>

<pre><code class="language-java">mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
                final Picasso picasso = Picasso.with(MainActivity.this);

                if (newState == SCROLL_STATE_IDLE) {
                    picasso.resumeTag(&quot;PhotoTag&quot;);
                } else {
                    picasso.pauseTag(&quot;PhotoTag&quot;);
                }
            }
        });
</code></pre>

<p><strong>场景二</strong>： 比如一个照片流列表界面，在弱网环境下，加载很慢，退出这个界面时可能会有很多请求没有完成，这个时候我们就可 以通过tag 来取消请求了。</p>

<h2 id="toc_25">九、同步／异步加载图片</h2>

<p>Picasso 加载图片也有同步／异步两种方式</p>

<h3 id="toc_26">(一) get() 同步</h3>

<p>很简单，同步加载使用get() 方法，返回一个Bitmap 对象，代码如下：</p>

<pre><code class="language-java">try {
    Bitmap bitmap =  Picasso.with(this).load(URL).get();
    } catch (IOException e) {
    e.printStackTrace();
}
</code></pre>

<blockquote>
<p>注意：使用同步方式加载，不能放在主线程来做。</p>
</blockquote>

<h3 id="toc_27">(二) 异步的方式加载图片，fetch()</h3>

<p>一般直接加载图片通过into显示到ImageView 是异步的方式，除此之外，还提供了2个异步的方法：</p>

<ul>
<li>fetch() 异步方式加载图片</li>
<li>fetch(Callback callback) 异步方式加载图片并给一个回调接口。</li>
</ul>

<pre><code class="language-java">Picasso.with(this).load(URL).fetch(new Callback() {
    @Override
    public void onSuccess() {
    //加载成功
    }

    @Override
    public void onError() {
    //加载失败
    }
});
</code></pre>

<p>这里就要吐槽一下接口设计了，回调并没有返回Bitmap, 不知道作者是怎么考虑的，只是一个通知效果，知道请求失败还是成功。<br/>
fetch 方法异步加载图片并没有返回Bitmap，这个方法在请求成功之后，将结果存到了缓存，包括磁盘和内存缓存。所以使用这种方式加载图片适用于这种场景：知道稍后会加载图片，使用fetch 先加载缓存，起到一个预加载的效果。</p>

<h2 id="toc_28">十、缓存（Disk 和 Memory）</h2>

<p>Picasso 有内存缓存(Memory)和磁盘缓存（ Disk）, 首先来看一下源码中对于缓存的介绍：</p>

<ul>
<li>LRU memory cache of 15% the available application RAM</li>
<li>Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is only<br/>
available on API 14+ or if you are using a standalone library that provides a disk cache on all API levels like OkHttp)</li>
<li>Three download threads for disk and network access.</li>
</ul>

<p>可以看出，内存缓存是使用的LRU 策略的缓存实现，它的大小是内存大小的15%,可以自定义它的大小，最后在扩展那一章节再讲，磁盘缓存是磁盘容量的2%但是不超过50M,不少于5M。处理一个请求的时候，按照这个顺讯检查：memory-&gt;disk-&gt;network 。先检查有木有内存缓存，如果命中，直接返回结果，否则检查磁盘缓存，命中则返回结果，没有命中则从网上获取。</p>

<p><strong>默认情况下，Picasso 内存缓存和磁盘缓存都开启了的，也就是加载图片的时候，内存和磁盘都缓存了，但是有些时候，我们并不需要缓存，比如说：加载一张大图片的时候，如果再内存中保存一份，很容易造成OOM,这时候我们只希望有磁盘缓存，而不希望缓存到内存，因此就需要我们设置缓存策略了。Picasso 提供了这样的方法。</strong></p>

<h3 id="toc_29">(一) memoryPolicy 设置内存缓存策略</h3>

<p>就像上面所说的，有时候我们不希望有内存缓存，我们可以通过 memoryPolicy 来设置。MemoryPolicy是一个枚举，有两个值</p>

<p><strong>NO_CACHE</strong>：表示处理请求的时候跳过检查内存缓存<br/>
<strong>NO_STORE</strong>: 表示请求成功之后，不将最终的结果存到内存。</p>

<p>示例代码如下：  </p>

<pre><code class="language-java">with(this).load(URL)
    .placeholder(R.drawable.default_bg)
    .error(R.drawable.error_iamge)
    .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE) //静止内存缓存
    .into(mBlurImage);
</code></pre>

<h3 id="toc_30">(二) networkPolicy 设置磁盘缓存策略</h3>

<p>和内存缓存一样，加载一张图片的时候，你也可以跳过磁盘缓存，和内存缓存策略的控制方式一样，磁盘缓存调用方法networkPolicy(NetworkPolicy policy, NetworkPolicy... additional) , NetworkPolicy是一个枚举类型，有三个值：</p>

<ul>
<li>NO_CACHE: 表示处理请求的时候跳过处理磁盘缓存</li>
<li>NO_STORE: 表示请求成功后，不将结果缓存到Disk,但是这个只对OkHttp有效。</li>
<li>OFFLINE: 这个就跟 上面两个不一样了，如果networkPolicy方法用的是这个参数，那么Picasso会强制这次请求从缓存中获取结果，不会发起网络请求，不管缓存中能否获取到结果。</li>
</ul>

<p>使用示例： </p>

<pre><code class="language-java">with(this).load(URL)
            .placeholder(R.drawable.default_bg)
            .error(R.drawable.error_iamge)
            .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE)//跳过内存缓存
            .networkPolicy(NetworkPolicy.NO_CACHE)//跳过磁盘缓存
            .into(mBlurImage);
</code></pre>

<p>强制从缓存获取：  </p>

<pre><code class="language-java">with(this).load(URL)
            .placeholder(R.drawable.default_bg)
            .error(R.drawable.error_iamge)
            .networkPolicy(NetworkPolicy.OFFLINE)//强制从缓存获取结果
            .into(mBlurImage);
</code></pre>

<h2 id="toc_31">十一、Debug 和日志</h2>

<h3 id="toc_32">(一) 缓存指示器</h3>

<p>上一节说了，Picasso 有内存缓存和磁盘缓存，先从内存获取，没有再去磁盘缓存获取，都有就从网络加载，网络加载是比较昂贵和耗时的。因此，作为一个开发者，我们往往需要加载的图片是从哪儿来的（内存、Disk还是网络），Picasso让我们很容易就实现了。只需要调用一个方法setIndicatorsEnabled(boolean)就可以了,它会在图片的左上角出现一个带色块的三角形标示，有3种颜色，绿色表示从内存加载、蓝色表示从磁盘加载、红色表示从网络加载。<br/><br/>
<code>Picasso.with(this).setIndicatorsEnabled(true);//显示指示器</code><br/><br/>
效果图：<br/><br/>
<img src="media/15561207868578/15713238477229.png" alt=""/></p>

<p>如上图所示，第一张图从网络获取，第二张从磁盘获取，第三张图从内存获取。<br/><br/>
看一下源码中定义指示器的颜色：  </p>

<pre><code class="language-java">/** Describes where the image was loaded from. */
public enum LoadedFrom {
    MEMORY(Color.GREEN),
   DISK(Color.BLUE),
   NETWORK(Color.RED);

    final int debugColor;

    private LoadedFrom(int debugColor) {
        this.debugColor = debugColor;
    }
}
</code></pre>

<p>可以很清楚看出，对应三种颜色代表着图片的来源。</p>

<h3 id="toc_33">(二) 日志</h3>

<p>上面的指示器能够很好的帮助我们看出图片的来源，但是有时候我们需要更详细的信息，Picasso,可以打印一些日志，比如一些关键方法的执行时间等等，我们只需要调用setLoggingEnabled(true)方法，然后App在加载图片的过程中，我们就可以从logcat 看到一些关键的日志信息。<br/><br/>
<code>Picasso.with(this).setLoggingEnabled(true);//开启日志打印</code>  </p>

<h2 id="toc_34">十二、Picasso 扩展</h2>

<p>到目前为止，Picasso的基本使用已经讲得差不多了，但是在实际项目中我们这可能还满足不了我们的需求，我们需要对它做一些自己的扩展，比如我们需要换缓存的位置、我们需要扩大缓存、自定义线程池、自定义下载器等等。这些都是可以的，接下来我们来看一下可以做哪些方面的扩展。  </p>

<h3 id="toc_35">(一) 用Builder 自己构造一个Picasso Instance</h3>

<p>我们来回顾一下前面是怎么用Picasso加载图片的：  </p>

<pre><code class="language-java">Picasso.with(this)
       .load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;)
       .into(mImageView);
</code></pre>

<p><strong>总共3步：</strong></p>

<ol>
<li>用with方法获取一个Picasso 示例</li>
<li>用load方法加载图片</li>
<li>用into 放法显示图片</li>
</ol>

<p>首先Picasso是一个单例模式，我们每一次获取的示例都是默认提供给我们的实例。但是也可以不用它给的Instance,我们直接用builder来构造一个Picasso:  </p>

<pre><code class="language-java">Picasso.Builder builder = new Picasso.Builder(this);
//构造一个Picasso
Picasso picasso = builder.build();
//加载图片
picasso.load(URL)
.into(mImageView);
</code></pre>

<p>这样我们就构造了一个局部的Picasso实例，当然了，我们直接用new 了一个builder，然后build()生成了一个Picasso。这跟默认的通过with方法获取的实例是一样的。那么现在我们就可以配置一些自定义的功能了。</p>

<h3 id="toc_36">(二) 配置自定义下载器 downLoader</h3>

<p>如果我们不想用默认提供的Downloader,那么我们可以自定义一个下载器然后配置进去。举个例子：</p>

<h4 id="toc_37">1、先自定义一个Downloader(只是举个例子，并没有实现):</h4>

<pre><code class="language-java">/**
 * Created by zhouwei on 17/2/26.
 */

public class CustomDownloader implements Downloader {

    @Override
    public Response load(Uri uri, int networkPolicy) throws IOException {
        return null;
    }

    @Override
    public void shutdown() {

    }
}
</code></pre>

<h4 id="toc_38">2、然后通过builder配置：</h4>

<pre><code class="language-java"> //配置下载器
builder.downloader(new CustomDownloader());
//构造一个Picasso
Picasso picasso = builder.build();
</code></pre>

<p>这样配置后，我们用build()生成的Picasso 实例来加载图片就会使用自定义的下载器来下载图片了。</p>

<h3 id="toc_39">(三) 配置缓存</h3>

<p>前面说过，内存缓存是用的LRU Cahce ,大小是手机内存的15% ，如果你想缓存大小更大一点或者更小一点，可以自定义，然后配置。</p>

<pre><code class="language-java">//配置缓存
LruCache cache = new LruCache(5 * 1024 * 1024);// 设置缓存大小
builder.memoryCache(cache);
</code></pre>

<p>上面只是一个简单的举例，当然了你可以自定义，也可以使用LRUCache,改变大小，改变存储路径等等。</p>

<blockquote>
<p>提示： 很遗憾，好像没有提供改变磁盘缓存的接口，那就只能用默认的了。</p>
</blockquote>

<h3 id="toc_40">(四) 配置线程池</h3>

<p>Picasso 默认的线程池的核心线程数为3，如果你觉得不够用的话，可以配置自己需要的线程池，举个列子：  </p>

<pre><code class="language-java">//配置线程池
ExecutorService executorService = Executors.newFixedThreadPool(8);
builder.executor(executorService);
</code></pre>

<h3 id="toc_41">(五) 配置全局的 Picasso Instance</h3>

<p>上面说的这些自定义配置项目都是应用在一个局部的Picasso instance 上的，我们不可能每一次使用都要重新配置一下，这样就太麻烦了。我们希望我们的这些自定义配置能在整个项目都应用上，并且只配置一次。其实Picasso 给我们提供了这样的方法。可以调用<code>setSingletonInstance(Picasso picasso)</code>就可以了，看一下这个方法的源码：  </p>

<pre><code class="language-java">/**
  * Set the global instance returned from {@link #with}.
  * &lt;p&gt;
  * This method must be called before any calls to {@link #with} and may only be called once.
  */
public static void setSingletonInstance(Picasso picasso) {
    synchronized (Picasso.class) {
        if (singleton != null) {
            throw new IllegalStateException(&quot;Singleton instance already exists.&quot;);
        }
        singleton = picasso;
    }
}
</code></pre>

<p>设置一个通过with方法返回的全局instance。我们只希望配置一次，所以，我们应该在Application 的onCreate方法中做全局配置就可以了。app一启动就配置好，然后直接和前面的使用方法一样，调用with方法获取Picasso instance 加载图片就OK了。</p>

<p>因此在Application 中添加如下代码：</p>

<pre><code class="language-java">@Override
public void onCreate() {
    super.onCreate();

    // 配置全局的Picasso instance 

    Picasso.Builder builder = new Picasso.Builder(this);
    //配置下载器
    builder.downloader(new CustomDownloader());
    //配置缓存
    LruCache cache = new LruCache(5*1024*1024);// 设置缓存大小
    builder.memoryCache(cache);
    //配置线程池
    ExecutorService executorService = Executors.newFixedThreadPool(8);
    builder.executor(executorService);

    //构造一个Picasso
    Picasso picasso = builder.build();
    // 设置全局单列instance 
    Picasso.setSingletonInstance(picasso);
}
</code></pre>

<p>然后应用这些自定义配置加载图片  </p>

<p><code>Picasso.with(this).load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;).into(mImageView);</code><br/><br/>
用法和以前的一样，但是我们已经将我们的自定义配置应用上了。</p>

<h2 id="toc_42">结尾</h2>

<p>以上就是对Picasso 用法的全部总结，如有什么问题，欢迎留言指正。Picasso真的是一个强大的图片加载缓存库，API 简单好用，而且是链式调用的（这点我特别喜欢）。官方文档写的比较简单，很多用法都要看源码和注释才知道。希望本文能给才开始使用Picasso 的同学一点帮助。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_11.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_13.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16066640335833.html">Jetpack学习 - WorkManager</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
