<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android RecyclerView性能优化]]></title>
      <url>%2F2018%2F06%2F15%2Fandroid-RecyclerView%E4%BC%98%E5%8C%96%2F</url>
      <content type="text"><![CDATA[前言近期由于项目中使用RecyclerView加载的数据数量较大，所以必须对RecyclerView进行优化。 数据处理和视图加载分离数据加载一般都是异步加载，有时候可能加载完数据就直接丢给VH进行处理。其实，数据的处理逻辑我们也应该放在异步处理，这样Adapter在notify change后，ViewHolder就可以简单无压力地做数据与视图的绑定逻辑。将数据处理逻辑与网络异步线程放在一起，粘在用户角度，最多就是网络刷新时间稍长一点。 数据优化 远端数据量较大时，我们采取分页拉取的方式，并对其进行缓存，提升二次加载熟读。 对于新增或者删除数据，通过DiffUtil来进行局部刷新数据，而不是一味地全局刷新数据。 123456void onNewDataArrived(List&lt;News&gt; news) &#123; List&lt;News&gt; oldNews = myAdapter.getItems(); DiffResult result = DiffUtil.calculateDiff(new MyCallback(oldNews, news)); myAdapter.setNews(news); result.dispatchUpdatesTo(myAdapter);&#125; 布局优化减少过渡绘制减少布局层级，可以考虑使用自定义 View 来减少层级，或者更合理地设置布局来减少层级 减少 xml 文件 inflate 时间这里的 xml 文件不仅包括 layout 的 xml，还包括 drawable 的 xml，xml 文件 inflate 出 ItemView 是通过耗时的 IO 操作，尤其当 Item 的复用几率很低的情况下，随着 Type 的增多，这种 inflate 带来的损耗是相当大的，此时我们可以用代码去生成布局，即 new View() 的方式，只要搞清楚 xml 中每个节点的属性对应的 API 即可。使用StaticLayout和DynamicLayout代替TextView，使用自定义View代替LayoutInflater.inflate(xml)文件 减少 View 对象的创建一个稍微复杂的 Item 会包含大量的 View，而大量的 View 的创建也会消耗大量时间，所以要尽可能简化 ItemView；设计 ItemType 时，对多 ViewType 能够共用的部分尽量设计成自定义 View，减少 View 的构造和嵌套。 Bitmap传递Android以OpenGL Texture的形式来展示bitmap，当bitmap第一次展示时，它会以width height大小的Texture形式传递到GPU上，所以要保证bitmap的大小不会大于其展示大小，要知道上传过程是阻塞主线程的。一般传递一张1920 1080的Texture不会超过10ms。 对象分配和垃圾回收虽然Android 5.0上使用ART来减少GC停顿时间，但仍然会造成卡顿。尽量避免在循环内创建对象导致GC。要知道，创建对象需要分配内存，而这个时机会检查内存是否足够来决定需不需要进行GC。 预加载123456// 通过复写指定预加载的像素值。LinearLayoutManager.getExtraLayoutSpace();和// 设置预加载itemview数目。RecycleView.setItemViewCacheSize(size); 其他 升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能 如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout 浪费资源 设置 RecyclerView.addOnScrollListener(listener); 来对滑动过程中停止加载的操作 如果不要求动画，可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭来提升效率 对 TextView 使用 String.toUpperCase 来替代 android:textAllCaps=&quot;true&quot; 通过重写 RecyclerView.onViewRecycled(holder) 来回收资源 通过 RecycleView.setItemViewCacheSize(size); 来加大 RecyclerView 的缓存，用空间换时间来提高滚动的流畅性 如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool 对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗 值相同避免再次刷新,TextView的text相同，就不需要再调用setText方法，对比的损耗往往小于绘制 通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示： 123456new LinearLayoutManager(this) &#123; @Override protected int getExtraLayoutSpace(RecyclerView.State state) &#123; return size; &#125;&#125;; 参考《RecyclerView 性能优化》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 基础复习]]></title>
      <url>%2F2018%2F05%2F18%2Fandroid-%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[AndroidManifest uses-sdk 这个节点用于定义要想正确地运行应用程序，设备上必须具有的最低和最高SDK版本。 uses-configuration 指定应用程序支持的每个输入机制的组合。一般不需要，适合有特殊输入控制的游戏。 uses-feature Android可以在各种各样的硬件平台上运行。可以使用多个uses-feature节点来指定应用程序需要的每个硬件功能。这可以避免将应用程序安装到不包含必要的硬件功能的设备上。 音频 用于要求低延迟音频管道的应用程序 蓝牙 用于需要蓝牙传输的应用程序 摄像头 用于要求有摄像头的应用程序。还可以要求具有自动聚焦功能、闪光灯或前摄像头 位置 用于需要基于位置的服务的应用程序。还可以显式指定要求网络或GPS支持 麦克风 用于需要音频输入的应用程序 NFC 要求NFC支持 传感器 指定对任何潜在可用的硬件传感器的要求 电话服务 指定需要一般性的电话服务 触摸屏 指定应用程序需要的触摸屏类型 USB 用于需要支持USB host或accessory模式的应用程序 Wi-Fi 用于需要支持Wi-Fi网络的应用程序 supports-screens 应用程序支持的屏幕 smallScreens 分辨率比传统的HVGA小的屏幕 normalScreens 用于指定典型的手机屏幕 largeScrees 比普通屏幕大的屏幕 xlargeScreens 比普通大屏幕更大的屏幕 requiresSmallestWidthDp 允许使用设备无关的像素指定支持的最小屏幕宽度 compatibleWidthLimitDp 指定一个上限，超出此值后应用程序可能无法扩展。使用该属性可以使系统在屏幕分辨率大于你指定的值得设备上启动兼容模式 largestWidthLimitDp 指定一个绝对上限。在屏幕分辨率大于你指定的值得设备上，这回导致系统强制应用程序在兼容模式下运行。 supports-texture 用于声明应用程序能够提供以一种特定的GL纹理压缩格式压缩的纹理资源。 uses-permission 声明应用程序所需要的权限，并告诉给用户。 permission 应用程序组件也可以创建权限来限制对共享应用程序组件的访问 instrumentation instrumentation类提供一个测试框架，用来在应用程序运行时测试应用程序组件。对于应用程序所创建的每一个测试类，都需要创建一个新的节点。 application 一个Manifest只能包含一个application节点。它使用各种属性来指定应用程序的各种元数据。包含了Activity、Service、Content Provider和Broadcst Receiver节点的容器。 activity 应用程序内的每一个Activity都要求有一个activity标签 运行时配置更改添加(android:configChanges属性)，添加该属性可以阻止由于特定配置改变而造成的重启，并会触发Activity中的onConfigurationChanged处理程序。可以通过重写这个方法来处理配置的改变，并使用传入Configuration对象来确定新的配置值。 mcc和mnc 检测到SIM，并且预支关联的国家或网络的代码发生了变化 locale 用于改变了设备的语言设置 keyboardHidden 显示或者隐藏了键盘、d-pad或其他输入设置 keyboard 对键盘的类型进行了更改。 fontScale 用户修改了首选的字体大小 uiMode 整体UI模式发生了变化。 orientation 屏幕在纵向和横向之间进行了旋转 screenLayout 屏幕布局发生了变化，比如激活了另外一个屏幕 screenSize 当可用屏幕尺寸改变 smallestScreenSize当物理屏幕尺寸改变 service provider 指定应用程序中的每一个Content Provider。 receiver 注册Broadcast Receiver。 uses-library 用于指定应用程序需要的共享库。 应用程序的进程 Active 进程 指那些有组件正在和用户进行交互的应用程序的进程。只有在最后关头才会被系统终止回收。 处于活动状态的Activity 正在执行onReceive事件处理程序的Broadcast Receiver 正在执行onStart、onCreate或者onDestroy事件处理程序的Service 正在运行、且已被标记为在前台运行的Service 可见进程 当一个Activity被部分遮挡时就会出现这种情况 启动Service进程 已经启动的Service进程。因为后台Service没有直接和用户交互，所以优先级比可见Activity或前台Service低一些。当系统终止一个运行的Service后，会在资源可用时尝试重新启动Service 后台进程 不可见、并且没有任何正在运行的Service的Activity进程。 空进程 为了提高系统整体性能。Android经常在应用程序的生存期结束之后仍然把它们保存在内存中。Android通过维护这个缓存来减少应用程序被再次启动时的启动时间。通常这些进程会根据需要被定期终止 Application每次应用程序运行时，应用程序的Application类都保持实例化状态。与Activity不同，配置改变并不会导致应用程序重启。 扩展Application类，可以完成以下3项工作 在Android运行时广播的应用程序级事件做出响应 在应用程序组件之间传递对象 管理和维护多个应用程序组件使用的资源 重写应用程序的生命周期事件 onCreate 在创建应用程序时调用。可以重写这个方法来实例化应用程序单态，以及创建和实例化任何应用程序状态变量或共享资源 onLowMemory 当系统处于资源匮乏的状态时，具有良好行为的应用程序可以释放额外的内存。这个方法一般只会在后台进程已经终止，但是前台应用程序仍然缺少内存时调用。可以重写这个处理程序来清空缓存或释放不必要的资源 onTrimMemory 当运行时决定当前应用程序应该尝试减少其内存开销时(通常在它进入后台时)调用 onConfigurationChanged 与Activity不同，在配置改变时，应用程序对象不会被终止或重启个。如果应用程序使用的值依赖于特定的配置，则重写这个方法来重新加载这些值，或者在应用程序级别处理配置改变 Activity生命周期 onCreate() ———— 当活动首次被创建时调用。此时Activity还在后台，不可见。用于创建和实例化将在应用程序中使用的对象。 onRestoreInstanceState() ———— 用于恢复UI状态 onStart() ———— 当活动对用户可见时调用，启动动画、线程、传感器监听器、GPS查找、定时器、Service或其他用于更新用户界面的进程，注册Broadcast Receiver。 onResume() ———— 当活动与用户开始交互时调用。启动当活动位于前台时需要运行的任何服务或代码。 onSaveInstanceState() ———— 把UI状态改变保存到savedInstanceState onPause() ———— 当当前活动被暂停并恢复以前的活动时调用。停止当活动不在前台时不需要运行的任何服务或代码。 onStop() ———— 当活动不再对用户可见时调用，用来暂停或停止动画、线程、传感器监听器、GPS查找、定时器、Service或其他用于更新用户界面的进程，注销Broadcast Receiver。 onDestroy() ———— 当活动被系统销毁时调用。在活动销毁前释放资源。 onRestart() ———— 在活动已停止并要再次启动时调用。 Activity的状态 活动状态 当一个Activity位于栈顶的时候，它是可见的、具有焦点的前台Activity，这时它可以接收用户输入。Android将会不惜一切代价来保持它处于活动状态，并根据需要来销毁栈下面部分的Activity，以保证这个Activity拥有它所需要的资源。 暂停状态 当Activity是可见的，但是没有获得焦点，此时它就处于暂停状态。 停止状态 当一个Activity不可见的时候，它就处于停止状态。此时，Activity仍然会停留在内存中，保存所有的状态信息，然而当系统的其他地方要求使用内存的时候，它们就会成为被终止的首要候选对象。 非活动状态 当一个Activity被终止之后，在启动之前它就处于非活动状态。处于非活动状态的Activity已经从Activity栈中移除了。管理屏幕发生变化当设备的屏幕方向发生改变时，会把活动销毁，并重建。所以需要确保采取必要的措施来保持方向改变之前活动的状态。在包含视图的活动被销毁时，只有那些在活动中被命名的视图(android:id属性)才能保持它们的状态。(例:命名过id的EditText视图中的任何文本都会在活动创建时自动恢复，而没有命名id的EditText视图，不会保持视图中当前所含文本) 当终止一个活动，将在以下两个方法中保存数据: onPause() ———— 利用数据库、内部或外部的文件存储器存储持久化数据。 onSaveInstanceState() ———— 提供Bundle对象作为一个参数，可以用它保存活动的状态。可以在onCreate或随后的onRestoreInstanceState()方法中恢复Bundle中保存的状态。但通过Bundle对象保存状态信息具有局限性，无法保存更复杂的数据结构。 onRetainNonConfigurationInstance()方法。当一个活动由于配置改变将要销毁时会触发这一方法。可以在方法中返回保存当前的数据。并在onCreate()使用getLastNonCOnfigurationInstance()方法进行提取。 检测方向改变1234567WindowManager wm = getWindowManager();Display dp = wm.getDefaultDisplay();if (dp.getWidth() &gt; dp.getHeight()) &#123; Log.d(&quot;Orientation&quot;,&quot;Landscape mode&quot;);&#125; else &#123; Log.d(&quot;Orientation&quot;,&quot;Portrait mode&quot;);&#125; 控制活动方向 Activity类 setRequestOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE/ActivityInfo.SCREEN_ORIENTATION_PORTRAIT) AndroidManifest.xml中元素上使用android:screenOrientation属性。 侦听用户界面通知 onKeyDown 当一个按键按下并且没有被活动中的任何视图处理时调用 onKeyUp 当一个键被释放并且没有被活动中的任何视图处理时调用 onMenuItemSelected 当用户选择了面板的菜单时调用 onMenuOpened 当用户打开了面板的菜单时调用 Fragment生命周期 onAttached() ———— 当碎片与活动建立关联时调用 onCreateView() ———— 用于创建碎片的视图 onActivityCreated() ———— 当活动的onCreate()方法被返回时调用 onDestroyView() ———— 当碎片的视图被移除时调用 onDetach() ———— 当碎片与活动的关联被移除时调用 IntentIntent是一种消息传递机制，可以在应用程序内使用，也可以在应用程序间使用。 使用类名显式启动一个特定的Service或Activity 启动Activity或Service来执行一个动作的Intent，通常需要使用特定的数据，或者对特定的数据执行动作 广播某个事件已经发生 显式启动新Activity要显式地选择要启动的Activity类，可以创建一个新的Intent来指定当前Activity的上下文以及要启动的Activity的类，然后把这个Intent传递给startActivity 12Intent intent = new Intent(MyActivity.this,MyOtherActivity.class);startActivity(intent); 在调用startActivity之后，新的Activity将会被创建、启动和恢复运行，他会移动到Activity栈的顶部调用新的Activity的finish或按下设备的返回按钮将关闭该Activity，并把它从栈中移除。开发人员可以通过调用startActivity导航到其他Activity。每次调用startActivity时，会有一个新的Activity添加到栈中，而按下后退按钮则依次删除每个Activity。 隐式的Intent隐式的Intent提供了一种机制，可以让匿名的应用程序组件响应动作请求。这意味着可以要求系统启动一个可执行给定动作的Activity，而不必知道需要启动哪个应用程序或Activity。当构建一个新的隐式的Intent时，需要指定一个要执行的动作，也可以提供执行那个动作需要的数据的URI。还可以通过向Intent添加extra来向目标Activity发送额外的数据。Extra是一种向Intent附加基本类型值得机制。可以在热河Intent上使用重载后的putExtra方法来附加一个新的名称/值对，以后在启动的Activity中使用对应的getExtra方法来检索它。Extra作为一个Bundle对象存储在Intent中，可以使用getExtras方法检索。如果多个Activity都能够执行指定的动作，则会向用户呈现各种选项。 使用Intent调用内置应用程序打开Web浏览器 12Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(&quot;http://www.amazon.com&quot;));startActivity(i); 打开拨号界面 12Intent i = new Intent(android.content.Intent.ACTION_DIAL,Uri.parse(&quot;tel:+651234567&quot;));startActivity(i); 打开Maps应用 12Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(&quot;geo:37.827500,-122.481670&quot;));startActivity(i); 打开联系人列表 12Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(&quot;content://contacts&quot;));startActivity(i); 选择联系人 12Intent i = new Intent(android.content.Intent.ACTION_PICK,Uri.parse(&quot;content://contacts&quot;));startActivity(i); 注意: 当有多个活动匹配Intent对象时会出现Complete action using对话框，通过使用Intent类的createChooser()方法来对该对话框进行自定义。 12Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(&quot;http://www.amazon&quot;));startActivity(Intent.createChooser(i,&quot;Open URL Using...&quot;)); 使用了createChooser()方法将对话框的标题改为“Open URL using…”，没有Use by default for this action选项，的另一个好处是当没有活动与您的Intent对象匹配时，不会崩溃。 确定Intent能否解析通过调用Intent的resolveActivity方法，并向该方法传入包管理器，可以对包管理器进行查询，确定是否有Activity能够启动以响应该Intent。 12345678910111213141516171819202122//Create the impliciy Intent to use to start a new ActivityIntent intent = new Intent(Intent.ACTION_DIAL,Uri.parse(&quot;tel:555-2368&quot;));//Check if an Activity exists to perform this actionPackageManager pm = getPackageManager();ComponentName cn = intent.resolveActivity(pm);if (cn == null) &#123; //If there is no Activity available to perform the action //Check to see if the Google Play Store is available Uri marketUri = Uri.parse(&quot;market://search?q=pname:com.myapp.packagename&quot;); Intent marketIntent = new Intent(Intent.ACTION_VIEW).setData(marketUri); //If the Google Play Store is available,use it to download an application //capable of performing the required action.Otherwise log an error. if (marketIntent.resolveActivity(pm) != null) &#123; startActivity(marketIntent); &#125; else &#123; Log.d(TAG,&quot;Market client not available&quot;); &#125;&#125; else &#123; startActivity(intent);&#125; 如果没有找到Activity，可以选择禁用相关的功能，也可以引导用户找到Google Play Store中合适的应用程序。要注意Google Play并不是在所有的设备和模拟器上都可用的，所以最好也对此进行检查。 原生Android动作 Action 说明 输入 ACTION_ALL_APPS 打开一个列出所有已安装应用程序的Activity。通常，此操作由启动器处理 无 ACTION_ANSWER 打开一个处理来电的Activity，通常这个动作是由本地电话拨号程序进行处理的。 无 ACTION_BUG_REPORT 显示一个可以报告BUG的Activity，通常由本地bug报告机制处理。 无 ACTION_CALL 打开一个电话拨号程序，并立即使用Intent的数据URI所提供的号码拨打一个电话,直接进入系统拨打电话界面，开始拨打电话。此动作只应用于替代本地拨号程序的Activity。大多数情况下，使用ACTION_DIAL是一种更好的方式。 tel:// +phone number ACTION_CALL_BUTTON 当用户按下硬件的“拨打按钮”时触发，通常会调用拨号Activity ACTION_DELETE 启动一个Activity，允许删除Intent的数据URI中指定的数据 ACTION_DIAL 打开一个拨号程序，要拨打的号码由Intent的数据URI预先提供,直接进入系统拨号界面。默认情况下，这是由本地Android电话拨号程序进行处理的。拨号程序可以规范化大部分号码样式。 tel: +phone number ACTION_EDIT 请求一个Activity，要求该Activity可以编辑Intent的数据URI中的数据 ACTION_INSERT 打开一个能够在Intent的数据URI指定的游标处插入新项的Activity，当作为子Activity调用的时候，它应该返回一个指向新插入项的URI ACTION_PICK 启动一个子Activity，它可以让你从Intent的数据URI指定的Content Provider中选择一个项。当关闭的时候，它应该返回所选择的项的URI。启动的Activity与选择的数据有关，例如，传递 content://contacts/people将会调用本地联系人列表 content://contacts/people ACTION_SEARCH 通常用于启动特定的搜索Activity。如果没有在特定的Activity上触发它，就会提示用户从所有支持搜索的应用程序中做出选择。可以使用SearchManager.QUERY键把搜索词作为一个Intent的extra中的字符串来提供 ACTION_SEARCH_LONG_PRESS 允许截获对硬件搜索键的长按操作。通常由系统处理，以提供语音搜索的快捷方式。 ACTION_SENDTO 启动一个Activity来向Intent的数据URI所指定的联系人发送一条信息 ACTION_SEND 启动一个Activity,该Activity会发送Intent中指定的数据。接收人需要由解析的Activity来选择。使用setType可以设置要传输的数据的MIME类型。数据本身应该根据它的类型，使用EXTRA_TEXT或者EXTRA_STREAM存储为extra。对于E-mail，本地应用程序也可以使用EXTRA_EMAIL、EXTRA_CC、EXTRA_BCC和EXTRA_SUBJECT键来接收extra。应该只使用ACTION_SEND动作向远程接收人发送数据 ACTION_VIEW 这是最常用的通用动作。视图要求以最合适的方式查看Intent的数据URI中提供的数据。不同的应用程序将会根据所提供的数据的URI模式来处理视图请求。一般情况下，http:地址将会打开浏览器，tel:地址将会打开拨号程序以拨打该号码，geo:地址会在Google地图应用程序中显示出来，而联系人将会在联系人管理器中显示出来 ACTION_WEB_SEARCH 打开一个浏览器，根据SearchManager.QUERY键提供的查询执行Web搜索 使用Intent广播事件Broadcast Intent用于向监听器通知系统的应用程序或应用程序事件，从而可以扩展应用程序间的事件驱动的编程模型。Broadcast Intent可以使应用程序更加开放，通过使用Intent来广播一个事件，可以在不用修改原始的应用程序的情况下，让你和第三方开发人员对事件作出反应。在应用程序中，可以通过监听Broadcast Intent来对设备状态变化和第三方应用程序事件作出反应。 intent-filter使用Intent Filter，应用程序组件可以声明它们支持的动作和数据。 action使用android:name属性指定要为之服务的动作的名称。每个Intent Filter必须要有至少一个action标签。Action应该是一个描述性的唯一的字符串。所以最好的做法使用基于Java的包命名约定的命名系统。 category使用android:name属性来指定应该在哪种情况下为action提供服务。每个Intent Filter标签可以包含多个category标签。既可以指定自己的category也可以使用以下Android提供的标准值: ALTERNATIVE 可以把这个动作指定为在特定数据类型上执行的默认动作的可选项。 SELECTED_ALTERNATIVE 与ALTERNATIVE相似，但是ALTERNATIVE总是使用后面将描述的intent resolution解析为一个动作，而当要求有很多可能性的时候，则可以使用SELECTED_ALTERNATIVE BROWSABLE 指定一个在浏览器内部可用的动作。如果想让应用程序相应浏览器内触发的动作，那么必须包含BROWSABLE类别。 DEFAULT 通过设置这个类型可以使一个组件成为Intent Filter内指定的数据类型的默认动作。对于那些使用一个显式的Intent启动的Activity，这个类别是很有必要的。 HOME 通过讲一个Intent Filter的类别设置为HOME，而不指定一个action，就可以把它作为本地屏幕的可选项。 LAUNCHER 使用这个类别会让一个Activity出现在应用程序的启动器中。 datadata标签允许指定组件可以执行的数据类型；根据情况，也可以包含多个数据标签。可以使用以下属性的任意组合来指定你的组件所支持的数据: android:host 指定一个幼小的主机名 android:mimetype 指定组件可以执行的数据类型 android:path 指定URI的有效路径值 android:port 指定主机的有效端口 android:scheme 指定一种特定的模式 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;bolg.radioactiveyak.com&quot;/&gt;&lt;/intent-filter&gt; 在Android设备上点击YouTubu视频的链接时，会提示使用YouTube应用。这是通过在Intent Filter的data标签下指定scheme、host和path属性来实现。 Android 如何解析 Intent Filter Android将已安装包的可用的Intent Filter放到一个列表中 那些鱼解析Intent时相关联的动作或者类别不匹配的Intent Filter将会从列表中移除 如果Intent Filter包含了指定的动作，那么就认为动作匹配了。 对于category匹配来说，Intent Filter必须包含待解析的Intent中的所有category，但可以包含Intent中所不包含的其他的category。一个没有指定的category的Intent Filter只能和没有任何category的Intent相匹配。 Intent的数据URI的每一个部分都和Intent Filter的data标签进行比较。如果Intent Filter指定了scheme、host/authority、path或者MIME类型，呢么这些值都要和Intent的URI比较。任意一个不匹配都会把Intent Filter从列表中衣橱。没有指定数据值的Intent Filter将会和所有的Intent数据值匹配。 MIME类型是指要匹配的数据的数据类型。如果不指定数据类型，它会和所有的Intent匹配。 scheme是URI的“协议”部分(例如，http: mailto: 或者 tel:) hostname 或者 data authority是URI位于scheme和path之间的部分 数据path是authority之后的内容。只有数据的scheme和hostname都匹配的时候，path才匹配。 当隐式启动一个Activity时，如果这个进程解析出多个组件，那么所有可能匹配的组件都会呈现给用户。对于Broadcast Receiver，每个匹配的接收器将接收Broadcast Intent。 使用Intent Filter作为插件和扩展Android 提供一个插件模型，可以让你的应用程序利用由你自己或者第三方应用程序组件所匿名提供的功能。 想应用程序提供匿名的动作Category 必须是ALTERNATIVE 或者 SELECTED_ALETERNATIVE 12345678&lt;activity android:name=&quot;.NOstromoController&quot;&gt; &lt;intent-filter android:label=&quot;@string/Nuke_From_Orbit&quot;&gt; &lt;action android:name=&quot;com.pad.nostromo.NUMKE_FROM_ORBIT&quot;/&gt; &lt;data android:mimeType=&quot;vnd.moonbase.cursor.item/*&quot;/&gt; &lt;category android:name=&quot;android.intent.category. ALTERNATIVE&quot;/&gt; &lt;category android:name=&quot;android.intent.category. SELECTED_ALETERNATIVE&quot;/&gt;&lt;/activity&gt; 从第三方Intent Receiver中发现新的动作通过Package Manager，可以创建一个指定了数据类型和action类别的Intent，让系统能返回一个能够在该数据上执行该动作的Activity的列表。 1234567891011121314151617181920PackageManager packageManager = getPackageManager();//创建一个Intent用来解析哪个动作应该出现在菜单中Intent intent = new Intent();intent.setData(MoonBaseProvider.CONTENT_URI);intent.addCategory(Intent.CATEGORY_SELECTED_SLTERNSTIVE);//指定标识。int flags = PackageManager.MATCH_DEFAULT_ONLY;//生成列表List&lt;ResolveInfo&gt; actions;actions = packageManager.queryIntentActivities(intent,flags);//获取动作名称的列表ArrayList&lt;String&gt; labels = new ArrayList&lt;String&gt;();Resources r = getResources();for (ResolveInfo action : actions) &#123; labels.add(r.getString(action.labelRes));&#125; #####把匿名的动作作为菜单项集成Menu类中可用的addIntentOptions方法可以指定一个描述了在Activity中所操作的数据的Intent。然而，和只简单地返回一个可用的Receiver的列表不同，会为每个动作创建一个新的菜单项，并使用匹配的Intent Filter的标签填充其文本。 123456789101112131415161718192021222324252627@Overridepublic boolean onCreateOptionMenu(Menu menu) &#123; super.onCreateOptionsMenu(menu); //创建一个Intent用来解析哪个动作应该出现在菜单中 Intent intent = new Intent(); intent.setData(MoonBaseProvider.CONTENT_URI); intent.addCategory(Intent.CATEGORY_SELECTED_ALTERNATIVE); //正常的菜单选项用来为要添加的菜单项设置group和ID值 int menuGroup = 0; int menuItemId = 0; int menuItemOrder = Menu.NONE; //提供调用动作的组建的名称————通常为当前的Activity ComponentName caller = getComponentName(); //首先定义应该添加的一些Intent Intent[] specificIntents = null; //通过前面Intent创建的菜单项将填充这个数组 MenuItem[] outSpecificItems = null; //填充菜单 menu.addIntentOptions(menuGroup,menuItemId,menuItemOrder,caller,specificIntents,intent,flags,outSpecificItems); return true;&#125; Pending IntentPendingIntent类提供了一种创建可由其他应用程序在稍晚的时候触发的Intent的机制。Pending Intent通常用于包装在响应将来的事件时触发的Intent。 1234567891011121314int requestCode = 0;int flags = 0;//启动一个ActivityIntent startActivityIntent = new Intent(this,MyOtherActivity.class);PendingIntent.getActivity(this,requestCode,startActivityIntent,flags);//启动一个ServiceIntent startServiceIntent = new Intent(this,MyService.class);PendingIntent.getService(this, requestCode, startServiceIntent,flags);//广播一个IntentIntent broadcastIntent = new Intent(NEW_LIFEORM_DETECTED);PendingIntent.getBroadcast(this, requestCode, broadcastIntent,flags); 显示通知Notification视图基础视图Chronometer一个TextView的扩展，实现了一个简单的计时器 ViewFlipper允许将一组View定义为一个水平行的ViewGroup，其中任意时刻只有一个View可见，并且可见View之间切换会通过动画形式表现出来，可以自动切换 QuickContactBadge显示一个徽标，该徽标显示了一个图片，该图片关联了通过电话号码、姓名、电子邮件或URI所指定的联系人信息。单击图片会显示一个快速联系人栏，它提供了联系选中的联系人的多种快捷方式————包括打电话和发送短消息、电子邮件及IM等。 复合控件复合控件即是指不可分割的，自包含的视图组，其中包含了多个排列和连接在一起的子视图。当创建复合控件时，必须对它包含的视图的布局、外观和交互进行定义。复合控件时通过扩展一个ViewGroup来创建。 123456789101112131415161718192021222324252627282930&lt;LinearLayout xmlns:android=&quot;http:/schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:id=&quot;@+id/editText&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;Button android:id=&quot;@+id/clearButton&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Clear&quot;/&gt;&lt;/LinearLayout&gt;public class ClearableEditText extends LinearLayout &#123; EditText editText; Button clearButton; public ClearableEditText(Context context) &#123; super(context); LayoutInflater.inflate(R.layout.clearable_edit_text,this,true); //获得对子控件的引用 editText = (EditText) findViewById(R.id.editText); clearButton = (Button) findViewById(R.id.clearButton); &#125;&#125; 自定义视图一般分别对onMeasure和onDraw方法进行重写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context,AttributeSet ats,int defaultStyle) &#123; super(context,ats,defaultStyle); &#125; public MyView(Context context,AttributeSet attrs) &#123; super(context,attrs); &#125; @Override protected void onMeasure(int wMeasureSpec,int hMeasureSpec) &#123; int measuredHeight = measureHeight(hMeasureSpec); int measuredWidth = measureWidth(wMeasureSpec); //必须调用setMeasuredDimension //否则在布局控件的时候 //会造成运行时异常 setMeasuredDimension(measuredWidth, measuredHeight); &#125; private int measureHeight(int measureSpec) &#123; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); //如果不指定限制，就是默认大小 int result = 500; if (specMode == MeasureSpec.AT_MOST) &#123; //Calculate the ideal size of your //计算控件在这个最大尺寸范围内的理想大小 //如果控件填充了可用空间，则返回外边界 result = specSize; &#125; else if (specMode == MeasureSpec.EXCATLY) &#123; //如果控件可以放置在这个边界内，则返回该值 result = specSize; &#125; return specSize; &#125; private int measureWidth(int measureSpec) &#123; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); //如果不指定限制，就是默认大小 int result = 500; if (specMode == MeasureSpec.AT_MOST) &#123; //Calculate the ideal size of your //计算控件在这个最大尺寸范围内的理想大小 //如果控件填充了可用空间，则返回外边界 result = specSize; &#125; else if (specMode == MeasureSpec.EXCATLY) &#123; //如果控件可以放置在这个边界内，则返回该值 result = specSize; &#125; return specSize; &#125; @Override protected void onDraw(Canvas canvas) &#123; //绘制背景 super(canvas) //绘制表面内容 &#125;&#125; 处理用户交互事件 onKeyDown 当任何设备按键被按下时，就会调用它 onKeyUp 当用户释放一个按键时调用 onTrackballEvent 当设备的轨迹球被移动的时候调用 onTouchEvent 当触摸屏被按下或者释放时调用，或者当检测到运动时调用 123456789101112131415161718192021222324252627@Overridepublic boolean onKeyDown(int keyCode,KeyEvent keyEvent) &#123; //如果事件得到处理，返回true return true;&#125;@Overridepublic boolean onKeyUp(int keyCode,KeyEvent keyEvent) &#123; //如果事件得到处理，返回true return true;&#125;@Overridepublic boolean onTrackballEvent(MotionEvent event) &#123; //获得这个事件代表的动作类型 int actionPerformed = event.getAction(); //如果事件得到处理，返回true return true;&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; //获得这个事件代表的动作类型 int actionPerformed = event.getAction(); //如果事件得到处理，返回true return true;&#125; Broadcast Receiver广播事件在应用程序组件中，可以构建希望广播的Intent，然后使用sendBroadcast方法来发送它。可以对Intent的动作、数据和分类进行设置，从而使Broadcast Receiver能够精确地确定它们的需求。在这种方案中，Intent动作字符串可以用来标识要广播的事件，所以它应该是能够标识事件的唯一的字符串。习惯上，动作字符串使用于Java包名相同的构建方式。public static final String NEW_LIFEFORM_DETECTED = &quot;com.paad.action.NEW_LIFEFORM&quot;;如果希望在Intent中包含数据，那么可以使用Intent的data属性指定一个URI，也可以包含extras来添加额外的基本值。 12345Intent intent = new Intent(LifeformDetectedReceiver.NEW_LIFEFORM);intent.putExtra(LifeformDetectedReceiver.EXTRA_LIFEFORM_NAME,detectedLifeform);intent.putExtra(LifeformDetectedReceiver.EXTRA_LONGTUDE,currentLongitude);intent.putExtra(LifeformDetectedReceiver.EXTRA_LATITUDE,currentLatitude);sendBroadcast(intent); 监听广播Boradcast Receiver 可以用来监听Broadcast Intent。要使Broadcast Receiver能够接收广播，就需要对其进行注册，既可以使用diamante，也可以在应用程序的manifest文件中注册。但无论怎么注册，都需要使用一个Intent Filter来指定它要监听哪些Intent和数据。对于包含manifest接收器的应用程序，在Intent被广播出去的时候，应用程序不一定非要处于运行状态才能执行接收。当匹配的Intent被广播出去的时候，它们会被自动地启动。即使被关闭或销毁了，也仍然能够对广播事件作出响应。要创建一个新的Brocast Receiver，需要扩展BroadcastReceiver类并重写onReceive事件处理程序。 123456public class MyBoradcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context,Intent intent) &#123; //响应接收到的Intent &#125;&#125; 当接收到一个与在注册接收器时使用的Intent Filter相匹配的Broadcast Intent的时候，就会执行onReceive方法。onReceive处理程序必须在5秒钟内完成，否则就会显示Force Close对话框。Broadcast Receiver将会更新内容、启动Service、更新Activity UI，或者使用Notification Manager来通知用户。 1234567891011121314151617181920212223242526public class LifeformDetectedReceiver extends BroadcastReceiver &#123; public final static String EXTRA_LIFEFORM_NAME = “EXTRA_LIFEFORM_NAME”； public final static String EXTRA_LATITUDE = &quot;EXTRA_LATITUDE&quot;; public final static String EXTRA_LONGTUDE = &quot;EXTRA_LONGTUDE&quot;; public final static String ACTION_BURN = &quot;com.paad.alien.action.BURN_IT_WITH_FIRE&quot;; public final static String NEW_LIFEFORM = &quot;com.paad.alien.action.NEW_LIFEFORM&quot;; @Override public void onReceive(Context context,Intent intent) &#123; //从Intent获得lifeform的细节 Uri data = intent.getData(); String type = intent.getStringExtra(EXTRA_LIFEFORM_NAME); double lat = intent.getDoubleExtra(EXTRA_LATITUDE,0); double lng = intent.getDoubleExtra(EXTRA_LONGTUDE,0); Location loc = new Location(&quot;gps&quot;); loc.setLatitude(lat); loc.setLongitude(lng); if (type.equals(&quot;facehugger&quot;)) &#123; Intent startIntent = new Intent(ACTION_BURN,data); startIntent.putExtra(EXTRA_LATITUDE,lat); startIntent.putExtra(EXTRA_LONGTUDE,lng); context.startService(startIntent); &#125; &#125;&#125; 在manifest中注册Broadcast Receiver在application节点中添加一个receiver标签，以指定要注册的Broadcast Receiver的类名。接收器节点需要包含一个intent-filter标签来指定要监听的动作字符串。 12345&lt;receiver android:name=&quot;.LifeformDetectedReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.paad.alien.action.NEW_LIFEFORM&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 通过这种方式注册的Broadcast Receiver总是活动的，并且即时当应用程序被终止或未启动时，也可以接收Broadcast Receiver。 在代码中注册Broadcast Receiver影响特定Activity的UI的Broadcast Receiver通常在代码中注册。在代码中注册的接收器只会在包含它的应用程序组件运行时响应Broadcast Intent。在接收器用来更新一个Activity中的UI元素时，这样做很有帮助。在这种情况下，在onResume处理程序中注册接收器，并在onPause中注销它。 12345678910111213141516private IntentFilter filter = new IntentFilter(LifeformDetectedReceiver.NEW_LIFEFORM);private LifeformDetectedReceiver receiver = new LifeformDetectedReceiver();@Overridepublic void onResume() &#123; super.onResume(); //注册Broadcast Receiver registerReceiver(receiver,filter);&#125;@Overridepublic void onPause() &#123; //注销Broadcast Receiver unregisterReceiver(receiver); super.onPause();&#125; 广播有序的Intent当Broadcast Receiver接收Intent的顺序十分重要时，特别是当需要接收器能够影响将来的接收器收到的Broadcast Intent时，可以使用sendOrderedBroadcast方法。 12String requiredPermission = &quot;com.paad.MY_BROADCAST_PERMISSION&quot;;sendOrderedBroadcast(intent,requiredPermission); 使用这个方法时，Intent将会按照优先级顺序被传递给所有具有合适权限的已注册的接收器，可以在Broadcast Recevier的Intent Filter manifest节点中使用android:priority属性指定其权限，值越大，优先级越高。 12345678&lt;receiver android:name=&quot;.MyOrderedReceiver&quot; android:permission=&quot;com.paad.MY_BROADCAST_PERMISSION&quot;&gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.paad.action.ORDERED_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 广播Sticky IntentSticky Intent是Broadcast Intent的有用变体，可以保存它们最后一次广播的值，并且当有一个新的接收器被注册为接收该广播时，它们会把这些值作为Intent返回。当调用registerReceiver来指定一个匹配Sticky Broadcast Intent的Intent Filter时，返回值将是最后一次Intent广播，例如电池电量变化的广播: 12IntentFilter battery = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);Intent currentBatteryCharge = registerReceiver(null,battery); 不是必须指定一个接收器来获得Sticky Intent当前值。要广播自己的Sticky Intent，应用程序必须具有BROADCAST_STICKY用户权限，然后需要调用sendStickyBroadcast并传入相关的Intent:sendStickyBroadcast(intent);要删除一个Sticky Intent，可以调用removeStickyBroadcast，并传入要删除的Sticky Intent:removeStickyBroadcast(intent); 监听本地Broadcast Intent很多的系统Service都会广播Intent来指示一种变化。可以使用这些信息来向自己的项目中添加基于系统事件的功能。下列动作用来跟踪设备状态的变化: ACTION_BOOT_COMPLETED 一旦系统完成了它的启动序列之后，就会触发这个动作。要想接收这个广播，应用程序需要具有RECEIVE_BOOT_COMPLETED权限 ACTION_CAMERA_BUTTON 当单机拍照按键的时候触发 ACTION_DATE_CHANGED 和 ACTION_TIME_CHANGED 如果设备的日期和时间被手动修改了，这些动作就会被广播。 ACTION_MEDIA_MOUNTED 和 ACTION_MEDIA_UNMOUNTED 任何时候，当新的外部存储介质被成功地添加或者从设备移除的时候，都会触发这两个事件。 ACTION_NEW_OUTGOING_CALL 当将要向外拨打电话的时候就会进行广播。监听这个广播可以截获播出的电话呼叫。拨打的电话号码存储在EXTRA_PHONE_NUMBER extra中，而返回的Intent中的resultData则是实际拨打的号码。要为这个动作注册一个Broadcast Receiver，应用程序必须声明PROCESS_OUTGOING_CALLS使用权限。 ACTION_SCREEN_OFF 和 ACTION_SCREEN_ON 当屏幕关闭或者打开时就分别对其广播。 ACTION_TIMEZONE_CHANGED 当手机当前的时区发生改变的时候就会广播这个动作。 使用Broadcast Intent监控设备的状态变化监控设备状态是创建高效和动态的应用程序的重要的一部分，该应用程序的行为根据连接性、电量状态和dock状态发生变化。 监听电量变化1234IntentFilter batIntentFilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);Intent battery = context.registerReceiver(null,batIntentFilter);int status = battery.getIntExtra(BatteryManager.EXTRA_STATUS,-1);boolean is Charging = status == BatteryManager.BATTERY_STATUS_CHANGING || status == BatteryManager.BATTERY_STATUS_FULL; 不能再manifest文件的Receiver中注册电量变化的动作。然而可以使用下面的动作字符串监控和电源的连接情况以及低电量情况。 ACTION_BATTERY_LOW ACTION_BATTERY_OKAY ACTION_POWER_CONNECTED ACTION_POWER_DISCONNECTED 监听连接变化连接的变化，包括贷款、延迟和Intent连接是否可用等信息。想要监听连接的变化，注册一个Broadcast Receiver用来监听 android.net.conn.CONNECTIVITY_CHANGE(ConnectivityManager.CONNECTIVITY_ACTION)动作。连接变化的广播不是sticky的而且也不包含任何和变化相关的额外信息。想要获得当前连接状态的详细信息，需要使用Connectivity Manager。 123456String svcName = Context.CONNECTIVITY_SERVICE;ConnectivityManager cm = (ConnectivityManager)context.getSystemService(svcName);NetworkInfo activeNetwork = cm.getActiveNetworkInfo();boolean isConnected = activeNetwork.isConnectedOrConnecting();boolean isMobile = activeNetwork.getType() == ConnectivityManager.TYPE_MOBILE; 监听Dock变化通过注册一个Receiver来监听Intent.ACTION_DOCK_EVENT，可以确定docking的状态和类型。和电池状态一样，dock事件的Broadcast Intent也是sticky的。 1234IntentFilter dockIntentFilter = new IntentFilter(Intent.ACTION_DOCK_EVENT);Intent dock = registerReceiver(null,dockIntentFilter);int dockState = dock.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);boolean isDocked = dockState != Intent.EXTRA_DOCK_STATE_UNDOCKED; 在运行时管理Manifest Receiver使用Package Manager的setComponentEnabledSetting方法，可以在运行时启用和禁用应用程序的manifest Receiver。想要减少应用程序的开销，当应用程序不需要响应一些系统事件时，最好禁用监听这些常见系统事件的manifest Receiver。这项技术也能够让你定时执行一个基于系统事件的动作，如当设备连接到Wi-Fi时去下载一个大文件。 12345678ComponentName myReceiverName = new ComponentName(this,MyReceiver.class);PackageManager pm = getPackageManager();//启用一个manifest receiverpm.setComponentEnabledSetting(myReceiverName,PackageManager.COMPONENT_ENABLED_STATE_ENABLED,PackageManager.DONT_KILL_APP);//禁用一个manifest receiverpm.setComponentEnabledSetting(myReceiverName,PackageManager.COMPONENT_ENABLED_STATE_DISABLED,PackageManager.DONT_KILL_APP); Local Broadcast Manager用于简化注册Broadcast Intent，以及在应用程序内的组件之间发送Broadcast Intent的工作。因为局部广播的作用域要小一些，所以使用Local Broadcast Manager比发送全局广播更加高效。而且使用Local Broadcast Manager也确保了应用程序外部的任何组件都收不到你广播的Intent，所以不会有私人数据或敏感数据泄露出去的风险。LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this); 要注册一个局部Broadcast Receiver，与注册全局接收器时类似。需要使用Local Broadcast Manager的registerReceiver方法，并传入一个Broadcast Receiver 和一个 Intent Filter 123456lbm.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; &#125;&#125;, new IntentFilter(LOCAL_ACTION)); 要发送一个局部Broadcast Intent，可以使用Local Broadcast Manager的sendBroadcast方法，并传入要广播的Intent:lbm.sendBroadcast(new Intent(LOCAL_ACTION)); Content Provider在Android中推荐使用Content Provider来实现跨包的数据共享。其行为方式和数据库很像，可以进行增删改查等操作。但是其可以将数据存储在数据库、文件甚至是网络上。Content Provider提供了一个接口用来发布数据，通过Content Resolver来使用数据。它们允许将使用数据的应用程序组件和底层的数据源分离开来，并提供了一种通用的机制来允许一个应用程序共享它们的数据或者使用其他应用程序提供的数据。Android附带了许多有用的Content Provider Browser ———— 存储诸如浏览器书签、浏览器历史记录等数据 CallLog ———— 存储诸如未接电话、通话详细信息等数据 Contacts ———— 存储联系人详细信息 MediaStore ———— 存储媒体文件，如音频、视频和图像 Settings ———— 存储设备的设置和首选项 查询URL的格式: ://// standard_prefix始终是content:// authority 指定了Provider的名称，如内置的Contacts 内容提供者的名称为contacts。对于第三方内容提供者，将采用其完全限定的名称。 data path 指定了请求数据的类型。如果从Contacts获取联系人，那么data path就是people id 指定了请求的特定记录。 如果从Contacts获取二号联系人，那么id值为2 代码实现 123456789101112Uri allContacts = Uri.parse(&quot;content://contacts/people&quot;);Cursor c;CursorLoader cursorLoader = new CursorLoader ( this,allContacts,null,null,null,null);c = cursorLoader.loadInBackground();if (c.moveToFirst) &#123; do &#123; String contactID = c.getString(c.getColumnIndex(ContactsContract.Contacts._ID)); String contactDisplayName = c.getString(c.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)); &#125; while (c.moveToNext());&#125; 创建自己的ContentProvider扩展ContentProvider抽象类public class MyContentProvider extends ContentProvider 注册Content Provider同Activity和Service一样，Content Resolver必须在应用程序清单文件中进行注册，注册是通过provider标记实现的。使用authorities标记来设定Content Provider的基本URI，找到想要交互的数据库。每个Content Resolver的授权必须是唯一的，因此最好用包名作为URI的基本路径com.{CompanyName}.provider.&lt;ApplicationName&gt; 发布Content Provider的URI地址每个Content Provider都应该使用一个公有的静态CONTENT_URI属性来公开他们的授权。这个CONTENT_URI应该包含一个主要内容的数据路径。public static final Uri CONTENT_URI = Uri.parse(&quot;content://com.paad.skeletondatabaseprovider/elements&quot;);直接使用这种形式的查询表示请求所有行，而在结尾附加/的查询请求表示请求一条记录。最好同时支持使用这两种形式的提供程序，可以通过UriMatcher实现。 Content Provider的实现框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183public class MyContentProvider extends ContentProvider &#123; public static final Uri CONTENT_URI = Uri.parse(&quot;content://com.paad.skeletondatabaseprovider/elements&quot;) //创建两个常量来区分不同的URI请求 private static final int ALLROWS = 1; private static final int SINGLE_ROW = 2; private static final UriMatcher uriMatcher; //填充UriMatcher对象，以&apos;element&apos;结尾的URI对应请求全部数据 //以&apos;elements/[rowID]&apos;结尾的URI代表请求单行数据 static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(&quot;com.paad.skeletondatabaseprovider&quot;,&quot;elements&quot;,ALLROWS); uriMatcher.addURI(&quot;com.paad.skeletondatabaseprovider&quot;,&quot;elements/#&quot;,SINGLE_ROW); &#125; //where 子句中使用的索引列的名称 public static final String KEY_ID = &quot;_id&quot;; //数据库中每个列的列名和索引。这些内容应该是描述性的。 public static final String KEY_COLUMN_1_NAME = &quot;KEY_COLUMN_1_NAME&quot;; //SQLiteOpenHelper变量 private MySQLiteOpenHelper myOpenHelper; @Override public boolean onCreate() &#123; //构造底层的数据库 //延迟打开数据库，直到需要执行一个查询或者事务时再打开 myOpenHelper = new MySQLiteOpenHelper(getContext(),MySQLiteOpenHelper.DATABASE_NAME,null, MySQLiteOpenHelper.DATABASE_VERSION); return true; &#125; @Override public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder) &#123; //打开数据库 SQLiteDatabase db = myOpenHelper.getWriteableDatabase(); //必要的话，使用有效的SQL语句替换这些语句 String groupBy = null; String having = null; SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder(); queryBuilder.setTables(MySQLiteOpenHelper.DATABASE_TABLE); //如果是行查询，用传入的行限制结果 switch(uriMatcher.match(uri)) &#123; case SINGLE_ROW: String rowID = uri.getPathSegments().get(1); queryBuilder.appendWhere(KEY_ID + &quot;=&quot; + rowID); break; default: break; &#125; Cursor cursor = queryBuilder.query(db,projection,selection,selectionArgs,groupBy,having,sortOrder); return cursor; &#125; @Override public int delete(Uri uri,String selection,String[] selectionArgs) &#123; //打开一个可读/可写的数据库来支持事务 SQLiteDatabase db = myOpenHelper.getWritableDatabase(); //如果是行URI，限定删除的行为指定的行 switch(uriMatcher.match(uri)) &#123; case SINGLE_ROW: String rowID = uri.getPathSegments().get(1); selection = KEY_ID + &quot;=&quot; + rowID + (!TextUtils.isEmpty(selection) ? &quot;AND (&quot; + selection + &apos;)&apos; : &quot;&quot;); break; default: break; &#125; //想要返回删除的项的数量，必须指定一条where子句。删除所有的行并返回一个值，同时传入&quot;1&quot;。 if (selection == null) &#123; selection = &quot;1&quot;; &#125; int deleteCount = db.delete(MySQLiteOpenHelper.DATABASE_TABLE,selection,selectionArgs); //通知所有观察者，数据集已经改变 getContext().getContentResolver().notifyChange(uri,null); return deleteCount; &#125; @Override public Uri insert(Uri uri,ContentValues values) &#123; //打开一个可读/可写的数据库来支持事务 SQLiteDatabase db = myOpenHelper.getWritableDatabase(); //要想通过传入一个空Content Value对象的方式向数据库中添加一个空行 //必须使用nullColumnHack参数来指定可以设置为null的列名 String nullColumnHack = null; long id = db.insert(MySQLiteOpenHelper.DATABASE_TABLE,nullColumnHack,values); //构造并返回新插入行的URI if (id &gt; -1) &#123; //构造并返回新插入行的URI Uri insertedId = ContentUris.withAppendedId(CONTENT_URI,id); //通知所有的观察者，数据集已经改变 getContext().getContentResolver().notifyChange(insertId,null); return insertedId; &#125; else &#123; return null; &#125; &#125; @Override public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs) &#123; //打开一个可读/可写的数据库来支持事务 switch(uriMatcher.match(uri)) &#123; case SINGLE_ROW: String rowID = uri.getPathSegments().get(1); selection = KEY_ID + &quot;=&quot; + rowID + (!TextUtils.isEmpty(selection) ? &quot;AND (&quot; + selection + &apos;)&apos; : &quot;&quot;); break; defalut: break; &#125; //执行更新 int updateCount = db.update(MySQLiteOpenHelper.DATABASE_TABLE,values,selection,selectionArgs); //通知所有的观察者，数据集已经改变 getContext().getContentResolver().notifyChange(uri,null); return updateCount; &#125; @Override public ParcelFileDescriptor openFile(Uri uri,String mode) throws FileNotFoundException&#123; //找到行ID并把它作为一个文件名使用 String rowID = uri.getPathSegments().get(1); //在应用程序的外部文件目录中创建一个文件对象 String picsDir = Environment.DIRECTORY_PICTURES; File file = new File(getContext().getExternalFilesDir(picsDir),rowID); //如果文件不存在，则直接创建它 if (!file.exists()) &#123; try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; Log.d(TAG,&quot;File creation failed:&quot; + e.getMessage()); &#125; &#125; //将mode参数转换为对应的ParcelFileDescriptor打开模式 int fileMode = 0; if (mode.contains(&quot;w&quot;)) &#123; fileMode |= ParcelFileDescriptor.MODE_WRITE_ONLY; &#125; if (mode.contains(&quot;r&quot;)) &#123; fileMode |= ParcelFileDescriptor.MODE_READ_ONLY; &#125; if (mode.contains(&quot;+&quot;)) &#123; fileMode |= ParcelFileDescriptor.MODE_APPEND; &#125; //返回一个代表了文件的ParcelFileDescriptor return ParcelFileDescriptor.open(file,fileMode); &#125; @Override public String getType(Uri uri) &#123; //为一个Content Provider URI返回一个字符串，它标识了MIME类型 switch(uriMatcher.match(uri)) &#123; case ALLROWS: return &quot;vnd.android.cursor.dir/vnd.paad.elemental&quot;; case SINGLE_ROW: return &quot;vnd.android.cursor.item/vnd.paad.elemental&quot;; default: throw new IllegalArgumentException(&quot;Unsupported URI:&quot; + uri); &#125; &#125; private static class MySQLiteOpenHelper extends SQLiteOpenHelper &#123; &#125;&#125; 使用Content ProviderContent Resolver简介每一个程序都有一个ContentResolver实例，可以使用getContentResolver方法来对其进行访问。当使用Content Provider公开数据时，Content Resolver是用来在这些Content Provider上进行查询和执行事务的对应类。Content Resolver包含了一些查询和事务方法，它们与Content Provider中定义的查询和事务方法相对应。 查询Content Provider查询结果是作为结果集的Cursor返回的。对ContentResolver对象使用query方法并传递给它以下参数: 希望查询的Content Provider的URI 一个投影，列出了希望包含在结果集中的列 一条where子句，定义了要返回的行。可以在其中包含”?”通配符，它将会被传入选择参数的值代替 将代替where子句中”?”通配符的选择参数字符串数组 一个字符串，用来描述返回的行的顺序 查询特定行可以使用ContentUris类的withAppendedId 123456789101112131415161718192021//获得Content ResolverContentResolver cr = getContentResolver();//指定结果列投影//返回满足要求所需的最小列表String[] result_columns = new String[] &#123; MyHoardContentProvider.KEY_ID, MyHoardContentProvider.KEY_GOLD_HOARD_NAME_COLUMN, MyHoardContentProvider.KEY_GOLD_HOARD_COLUMN,&#125;//将一个行ID附加到URI以定位特定的行Uri rowAddress = ContentUris.withAppendedId(MyHoardContentProvider.CONTENT_URI,rowId);//由于我们在请求单独的一行，因此下列变量的取值都为nullString where = null;String whereArgs[] = null;String order = null;//返回指定的行Cursor resultCursor = cr.query(rowAddress,result_columns,where,whereArgs,order); 数据库查询的执行时间很长。默认，Content Resolver将在应用程序主线程上执行查询和其他一些事务。可以使用Cursor Loader异步查询内容 使用Cursor Loader异步查询内容Cursor Loader能够处理在Activity或者Fragment中使用Cursor所需的所有管理任务。 实现 Cursor Loader Callback要使用Cursor Loader，可创建一个新的LoaderManager.LoaderCallbacks实现。LoaderManager.LoaderCallbacks&lt;Cursor&gt; loaderCallback = new LoaderManager.LoaderCallbacks&lt;Cursor&gt;(){} 如果需要在Fragment或者Activity中实现一个Loader，通常通过让该组件实现LoaderCallback接口来实现 onCreateLoader 当Loader被初始化后，调用onCreateLoader，该处理程序应该创建并返回一个新的Cursor Loader对象。Cursor Loader构造函数的参数与使用Content Resolver执行查询所需的参数是相同的。 onLoadFinished 当Loader Manager已经完成了异步查询后，onLoadFinished处理程序会被调用，并把结果Cursor作为参数传入。使用这个Cursor来更新适配器和其他UI元素。 onLoaderReset 当Loader Manager重置Cursor Loader的时候，会调用onLoaderReset处理程序。 123456789101112131415161718public Loader&lt;Cursor&gt; onCreateLoader(int id,Bundle args) &#123; String[] projection = null; String where = null; String[] whereArgs = null; String sortOrder = null; Uri queryUri = MyContentProvider.CONTENT_URI; return new CursorLoader(DatabaseSkeletonActivity.this,queryUri,projection,where,whereArgs,sortOrder);&#125;public void onLoadFinished(Loader&lt;Cursor&gt; loader,Cursor cursor) &#123; &#125;public void onLoadReset(Loader&lt;Cursor&gt; loader) &#123; &#125; 初始化和重新启动Cursor Loader每个Activity和Fragment都提供了getLoaderManager方法 ，可以调用该方法来访问Loader Manager。LoaderManager loaderManager = getLoaderManager();初始化新的Loader 12Bundle args = null;loaderManager.initLoader(LOADER_ID,args,myLoaderCallbacks); 这个过程通常是在Activity的onCreate方法或者Fragment中的onActivityCreated中完成的。 添加、删除和更新内容Cursor Loader要在Content Provider上执行事务操作，需要使用Content Resolver的insert、delete和update方法。与查询一样，Content Provider的事务会在应用程序主线程上执行，除非把它们移动到一个工作线程。 本地Android Content Provider Media Store 对设备上的多媒体信息、包括音频、视频和图像提供了集中、托管的访问。 Browser 读取或者修改浏览器和浏览器搜索历史记录 Contacts Contract 检索、修改或者存储联系人的详细信息以及相关的社交流更新 Call Log 查看或者更新通话记录 Calender 创建新事件，删除或更新现有的日历项。 使用Media Store Content Provider要从Media Store访问媒体文件，可以使用MediaStore类包含的Audio，Video和Images子类，这些子类有分别包含它们的子类，用来为每个媒体提供程序提供列名和内容URI。 1234567891011121314151617181920212223242526272829//获得外部卷上每一个音频的Cursor，并提取歌曲名称和专辑名称String[] projection = new String[] &#123; MediaStore.Audio.AudioColumns.ALBUM, MediaStore.Audio.AudioColumns.TITLE&#125;Uri contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;Cursor cursor = getContentResolver().query(contentUri,projection,null,null,null);//获得所需列的索引int albumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.AudioColumns.ALBUM);int titleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.AudioColumns.TITLE);//创建一个数组来存储结果集String[] result = new String[cursor.getCount()];//迭代Cursor,提取每个专辑名称和歌曲名称while(cursor.moveToNext()) &#123; //提取歌曲的名称 String title = cursor.getString(titleIdx); //提取专辑的名称 String album = cursor.getString(albumIdx); result[cursor.getPosition()] = title + &quot; (&quot; + album + &quot;)&quot;;&#125;//关闭Cursorcursor.close(); 使用 Contacts Contract Content ProviderAndroid 向所有被赋予READ_CONTACTS权限的应用程序提供了联系人信息数据库的完全访问权限。其使用了一个三层数据模型来存储数据，将数据与联系人关联起来，并把同一个人的数据聚集起来，这是通过使用下面的ContactsContract 子类实现的 Data 在底层的表中，每个行定义了一组个人数据，并使用MIME类型分离这些数据 RawContacts 用户可以为设备指定多个联系人账户提供程序。RawContacts表中的每一行定义了一个账户，可以向这个账户关联一组Data值。 Contacts 可以将RawContacts中描述同一个人的行聚集起来。 读取联系人详情找到联系人姓名的联系信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ContentResolver cr = getContentResolver();String[] result = null;//使用部分姓名匹配找到联系人String searchName = &quot;andy&quot;;Uri lookupUri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_FILTER_URI,searchName);//创建所需列名的投影String[] projection = new String[] &#123; ContactsContract.Contacts._ID&#125;//获得一个Cursor，用于返回匹配的名称的IDCursor IdCursor = cr.query(lookupUri,projection,null,null,null);//如果有匹配的ID，则提取第一个匹配的IDString id = null;if (idCursor.moveToFirst()) &#123; int idIdx = idCursor.getColumnIndexOrThrow(ContactsContract.Contacts._ID); id = idCursor.getString(idIdx);&#125;//关闭CursoridCursor.close();//创建一个新Cursor,搜索与返回的联系人ID关联的数据if (id != null) &#123; //返回该联系人的所有PHONE数据 String where = ContactsContract.Data.CONTACT_ID + &quot; = &quot; + id + &quot; AND&quot; + ContactsContract.Data.MIMETYPE + &quot; = &apos;&quot; + ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE + &quot;&apos;&quot;; projection = new String[] &#123; ContactsContract.Data.DISPLAY_NAME, ContactsContract.CommonDataKinds.Phone.NUMBER &#125; Cursor dataCursor = getContentResolver().query(ContactsContract.Data.CONTENT_URI,projection,where,null,null); //获得所需列的索引 int nameIdx = dataCursor.getColumnIndexOrThrow(ContactsContract.Data.DISPLAY_NAME); int phoneIdx = dataCursor.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER); result = new String[dataCursor.getCount()]; while(dataCursor.moveToNext()) &#123; //提取姓名 String name = dataCursor.getString(nameIdx); //提取电话号码 String number = dataCursor.getString(phoneIdx); result[dataCursor.getPosition()] = name + &quot; (&quot; + number + &quot;)&quot;; &#125; dataCursor.close();&#125; 找到联系人联系号码的联系信息 1234567891011121314151617String incomingNumber = &quot;(650)253-0000&quot;;String result = &quot;Not Found&quot;;Uri lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI,incomingNumber);String[] projection = new String[] &#123; ContactsContract.Contacts.DISPLAY_NAME&#125;;Cursor cursor = getContentResolver().query(lookupUri,projection,null,null,null);if(cursor.moveToFirst()) &#123; int nameIdx = cursor.getColumnIndexOrThrow(ContactsContract.Contacts.DISPLAY_NAME); result = cursor.getString(nameIdx);&#125;cursor.close(); 使用Intent创建和选择纤细人选择一个联系人 12345678910111213private static int PICK_CONTACT = 0;private void pickContact() &#123; Intent intent = new Intent(Intent.ACTION_PICK,ContactsContract.Contacts.CONTENT_URI); startActivityForResult(intent,PICK_CONTACT);&#125;@Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if ((requestCode == PICK_CONTACT) &amp;&amp; (resultCode == RESULT_OK)) &#123; resultTextView.setText(data.getData().toString()); &#125;&#125; 插入一个新联系人 123456Intent intent = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT,ContactsContract.Contacts.CONTENT_URI);intent.setData(Uri.parse(&quot;tel:(650)253-0000&quot;));intent.putExtra(ContactsContract.Intents.Insert.COMPANY,&quot;Google&quot;);intent.putExtra(ContactsContract.Intents.Insert.POSTAL,&quot;1600 Amphitheatre Parkway,Mountain View,California&quot;);startActivity(intent); 使用Calendar Content Provider查询日历必须在应用程序的清单文件中包含 READ_CALENDAR 权限。 Calendars Calendar应用程序可以显示多个日历，这些日历关联多个账户。该表存储每个可显示的日历，以及日历的详情，如日历的显示名称/时区和颜色。 Events 为每个调度的日历事件包含一项，内容包括名称、描述、地点和开始/结束时间 Instances 每个事件都有一个或多个实例。 Attendees 表中每一项表示一个给定事件的单个参与者。每个参与者可以包含姓名、电子邮件地址和出席状态 Reminders 描述了事件提醒，每一行代表一个特定事件的提醒 查询Events表 12345678910111213141516171819202122232425262728//创建一个限制结果Cursor为所需列的投影String[] projection = &#123; CalendarContract.Events._ID, CalendarContract.Events.TITLE&#125;;//获取Events提供程序上的CursorCursor cursor = getContentResolver().query(CalendarContract.Events.CONTENT_URI,projection,null,null,null);//获取列的索引int nameIdx = cursor.getColumnIndexOrThrow(CalendarContract.Events.TITLE);int idIdx = cursor.getColumnIndexOrThrow(CalendarContract.Events._ID);//初始化结果集String[] result = new String[cursor.getCount()];//迭代结果Cursorwhile(cursor.moveToNext()) &#123; //提取名称 String name = cursor.getString(nameIdx); //提取唯一的ID String id = cursor.getString(idIdx); result[cursor.getPosition()] = name + &quot; (&quot; + id + &quot;)&quot;;&#125;//关闭Cursorcursor.close(); 使用Intent创建和查询日历项Calendar Content Provider包含基于Intent的机制，该机制允许你使用Calendar应用程序执行常见的操作，而不需要特殊的权限。使用Intent，可以再指定的时间打开Calendar应用程序，查看事件的而详细信息，插入一个新的事件，或编辑现有的事件。 创建新的日历事件 123456789101112131415//创建一个新的插入IntentIntent intent = new Intent(Intent.ACTION_INSERT,CalendarContract.Events.CONTENT_URI);//添加日历事件的详细信息intent.putExtra(CalendarContract.Events.TITLE,&quot;Launch!&quot;);intent.putExtra(CalendarContract.Events.DESCRIPTION,&quot;Professional Android 4 &quot; + &quot;Application Development release!&quot;);intent.putExtra(CalendarContract.Events.EVENT_LOCATION,&quot;Wrox.com&quot;);Calendar startTime = Calendar.getInstance();startTime.set(2012,2,13,0,30);intent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME,startTime.getTimeInMillis());intent.putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY,true);//使用Calendar应用程序添加新的事件startActivity(intent); 编辑日历事件 123456789101112131415//创建一个URI，通过行ID来访问指定的事件//使用它来创建一个新的编辑Intentlong rowID = 760;Uri uri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI,rowID);Intent intent = new Intent(Intent.ACTION_EDIT,uri);//修改日历事件的详细信息Calendar startTime = Calendar.getInstance();startTime.set(2012,2,13,0,30);intent.putExtra(ClendarContract.EXTRA_EVENT_BEGIN_TIME,startTime.getTimeInMillis());intent.putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY,true);//使用Calendar应用程序来编辑事件startActivity(intent); 显示日历和日历事件 123456//创建一个URI来指定要查看的特定时间的日历事件Calendar startTime = Calendar.getInstance();startTime.set(2012,2,13,0,30);Uri uri = Uri.parse(&quot;content:??com.android.calendar/time/&quot; + String.valueOf(startTime.getTimeInMillis()));//使用Calendar应用程序查看时间startActivity(intent); CursorContent Value用来向数据库的表中插入新的行。每一个ContentValues对象都将一个表行表示为列名到值得映射。数据库查询作为Cursor对象返回。Cursor是底层数据中的结果集的指针。 moveToFirst 把游标移动到查询结果中的第一行 moveToNext 把游标移动到下一行 moveToPrevious 把游标移动到前一行 getCount 返回结果集中的行数 getColumnIndexOrThrow 返回具有指定名称的列的索引(如果不存在拥有该名称的列，就会抛出异常)，索引从0开始计数。 getColumnName 返回指定列索引的名称 getColumnNames 返回当前Cursor中的所有列名的字符串数组 moveToPosition 将游标移动到指定行 getPosition 返回当前的游标位置 结束使用Cursor后，关闭它非常重要。这样可以防止内存泄漏，并降低应用程序的资源负载。cursor.close(); 消息传递发送SMS消息需添加权限&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;&gt; 12SmsManager sms = SmsManager.getDefault();sms.sendTextMessage(destinationAddress:phoneNumber,scAddress:null,text:message,sentIntent:null,delivertyIntent:null); destinationAddress: 收件人的电话号码 scAddress: 服务中心地址，null代表默认的SMSC text: SMS消息的内容 sentIntent: 发送消息后调用的挂起的意图 delivertyIntent: 消息递送后调用的挂起的意图 在onCreate() 方法中创建两个PendingIntent对象。 12sentPI = PendingIntent.getBroadcast(this,0,new Intent(SENT),0);deliveredPI = PendingIntent.getBroadcast(this,0,new Intent(DELIVERED),0); 两个PendingIntent对象被传递给sendTextMessage()方法的最后两个参数123registerReceiver(smsDeliveredReceiver,new IntentFilter(DELIVERED));registerReceiver(smsSentReceiver,new IntentFilter(SENT));sms.sendTextMessage(phoneNumber,null,message,sentPI,deliveredPI); 使用意图发送SMS消息12345Intent i = new Intent(android.content.Intent.ACTION_VIEW);i.putExtra(&quot;address&quot;,&quot;5556;5558;5560&quot;);i.putExtra(&quot;sms_body&quot;,&quot;Hello my friends!&quot;);i.setType(&quot;vnd.android-dir/mms-sms&quot;);startActivity(i); 接收SMS消息可以使用BroadcastReceiver对象接收传入的SMS消息。如果希望应用程序在接收到一条特定的SMS消息时执行一个动作，就很有用了。 在AndroidManifest.xml文件中申明 123456&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;&lt;receiver android:name=&quot;.SMSReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 创建SMSReceiver文件 123456789101112131415161718192021public class SMSReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context,Intent intent) &#123; Bundle bundle = intent.getExtras(); SmsMessage[] msgs = null; String str = "SMS from"; if (bundle != null) &#123; Object[] pdus = (Object[]) bundle.get("pdus"); msgs = new SmsMessage[puds.length]; for (int i = 0;i &lt; msgs.length;i++) &#123; msgs[i] = SmsMessage.createFromPdu((byte[])pdus[i]); if (i == 0) &#123; str += msgs[i].getOriginatingAddress(); str += ": "; &#125; str += msgs[i].getMessageBody().toString(); &#125; Toast.makeText(context,str,Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 阻止Messaging应用程序接收消息在AndroidManifest.xml中BroadcastReceiver的intent-filter中添加android:priority属性，数字越大，Android就会越早执行。并且在onReceive()方法中调用 abortBroadcast() 方法，停止广播。 发送邮件123456789101112private void sendEmail(String[] emailAddresses,String[] carbonCpies,String subject,String message) &#123; Intent emailIntent = new Intent(Intent.ACTION_SEND); emailIntent.setData(Uri.parse(&quot;mailto:&quot;)); String[] to = emailAddresses; String[] cc = carbonCopies; emailIntent.putExtra(Intent.EXTRA_EMAIL,to); emailIntent.putExtra(Intent.EXTRA_CC,cc); emailIntent.putExtra(Intent.EXTRA_SUBJECT,subject); emailIntent.putExtra(Intent.EXTRA_TEXT,message); emailIntent.setType(&quot;message/rfc822&quot;); startActivity(Intent.createChooser(emailIntent, &quot;Email&quot;));&#125; 定位使用基于位置的服务基于位置的服务(LBS)是一个很宽泛的概念，描述了用来查找设备当前位置的不同技术。主要的两个LBS元素是 位置管理器 提供基于位置的服务的挂钩 位置提供器 每一个位置提供器都表示不同的位置查找技术，这些技术用来确定设备的当前位置 使用位置管理器可以 获得当前的位置 追踪移动 设置近距离提醒，在检测到进入或者离开一个指定的区域时发出提醒 找到可用的位置提供器 监视GPS接收器的状态 LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE); 并且需要在manifest文件中申请fine权限和coarse权限 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; 选择一个位置提供器LocationManager类包含了一些静态字符串常量，这些常量将返回以下三种位置提供其的名称 LocationManager.GPS_PROVIDER LocationManager.NETWORK_PROVIDER LocationManager.PASSIVE_PROVIDER 通过指定条件查找位置提供器在大部分情况下都不太可能去显式地选择要使用的位置提供器。更常见的情况是指定你的要求。让Android去确定要使用的最优的技术。使用Criteria类来说明对提供器的要求，包括精度、能耗、花费以及返回海拔、速度和朝向的能力。 传入setAccuracy的coarse/fine 值代表一个主管的精确，其中fine代表GPS或更好的技术，而coarse则代表精度低很多的任何技术。 12345678910111213Criteria criteria = new Criteria();criteria.setAccuracy(Criteria.ACCURACY_COARSE);criteria.setPowerRequirement(Criteria.POWER_LOW);criteria.setAltitudeRequired(false);criteria.setBearingRequired(false);criteria.setSpeedRequired(false);criteria.setCostAllowed(true);criteria.setHorizontalAccuracy(Criteria.ACCURACY_HIGH);criteria.setVerticalAccuracy(Criteria.ACCURACY_MEDIA);criteria.setBearingAccuracy(Criteria.ACCURACY_LOW);criteria.setSpeedAccuracy(Criteria.ACCURACY_LOW);List&lt;String&gt; matchingProviders = locationManager.getProviders(criteria,false); 确定当前位置找出上一次确定的位置通过使用getLastKnownLocation方法并传入某个Location Provider的名称作为参数 Location location = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER); 刷新当前位置通过requestLocationUpdates方法使用LocationListener，可以请求定期更新位置变化。LocationListener还包含一些回调方法，可用于监听提供器的状态和可用性的变化。在为requestLocationUpdates方法指定参数时，可以使用特定Location Provider的名称，也可以提供一组条件来确定应该使用的提供器。为了提高效率并降低花费和电源消耗，还可以指定两次位置更新相隔的最短时间和最短距离。 123456789101112131415161718192021String provider = LocationManager.GPS_PROVIDER;int t = 5000; //毫秒int distance = 5; //米LocationListener myLocationListener = new LocationListener() &#123; public void onLocationChanaged(Location location) &#123; //基于新位置更新应用程序 &#125; public void onProviderDisabled(String provider) &#123; //如果提供器被禁用，则更新应用程序 &#125; public void onProviderEnabled(String provider) &#123; //如果提供器被启用，则更新应用程序 &#125; public void onStatusChanged(String provider,int status,Bundle extras) &#123; //如果提供器硬件状态改变，则更新应用程序 &#125;&#125;;locationManager.requestLocationUpdates(provider,t,distance,myLocationListener); 同样，你可以指定一个Pending Intent，每当位置发生变化，或者Location Provider的状态或可用性发生变化，该Pending Intent就会被广播。新位置存储在一个extra钟，其key为KEY_LOCATION_CHANGED。如果有多个Activity或Service需要使用位置更新，可以通过这种方式监听相同的广播Intent。 123456789String provider = LocationManager.GPS_PROVIDER;int t = 5000; //毫秒int distance = 5; //米final int locationUpdateRC = 0;int flags = PendingIntent.FLAG_UPDATE_CURRENT;Intent intent = new Intent(this,MyLocationUpdateReceiver.class);PendingIntent pendingIntent = PendingIntent.getBroadcast(this,locationUpdateRC,intent,flags);locationManager.requestLocationUpdates(provider,t,distance,pendingIntent); 使用Passive Location Provider可以在其他应用程序请求位置更新的时候接收更新，但是无法控制更新何时发生。 请求单独一次位置更新并不是每个应用程序都需要定期的位置更新才能保持有用。很多时候，只要确定一次位置就可以为它们提供的功能或显示的信息提供足够的上下文。 12Looper looper = null;locationManager.requestSingleUpdate(criteria,myLocationListener,looper); 当使用Location Listener时，可以指定一个Looper参数，该参数允许你在特定的线程上来定时回调————将该参数设为null将强制在当前调用线程上返回。 位置更新优化 耗电量和精度 Location Provider的精度越高，耗电量越大 启动时间 在移动环境中，得到最初位置所用的时间对用户体验有显著的影响 更新频率 更新越频繁，电源消耗越大 提供器可用性 用户可以切换提供器的可用性，所以应用程序需要检测提供器状态的变化 近距离提醒可以使用近距离设置一些Pending Intent，当设备移动到为某个固定位置指定的区域内或从该区域移出时他们就会触发。为了针对特定区域设置近距离提醒，需要选择一个中心点，绕该点的半径以及该提醒的超时时间。 123456789101112131415private static final String TREASURE_PROXIMITY_ALERT = &quot;com.paad.treasurealert&quot;;private void setProximityAlert() &#123; String locDervice = Context.LOCATION_SERVICE; LocationManager locationManager = (LocationManager)getSystemService(locService); double lat = 73.147536; double lng = 0.510638; float radius = 100f; long expiration = -1; //不会过期 Intent intent = new Intent(TREASURE_PROXIMITY_ALERT); PendingIntent proximityIntent = PendingIntent.getBroadcast(this,-1,intent,0); locationManager.addProximityAlert(lat,lng,radius,expriation,proximityIntent);&#125; Download Manager作为一个Service来优化长时间下载操作的处理。Download Manager通过处理HTTP连接、监控连接的变化和系统重新启动来确保每一次下载都能成功完成。要想访问Download Manager，可以使用getSystemService方法请求DOWNLOAD_SERVICE: 12String serviceString = Context.DOWNLOAD_SERVICE;DownloadManager downloadManager = (DownloadManager)getSystemService(serviceString); 下载文件要想请求一个下载，需要创建一个新的DownloadManager.Request，指定要下载的文件的URI并把它传给Download Manager的enqueue。 12345String serviceString = Context.DOWNLOAD_SERVICE;DownloadManager downloadManager = (DownloadManager)getSystemService(serviceString);Uri uri = Uri.parse(&quot;http://developer.android.com/shareables/icon_templates-v4.0.zip&quot;);DownloadManager.Request request = new Request(uri);long reference = downloadManager.enqueue(request); 根据返回的引用值，可以对某个下载进行进一步的操作或者查询，包括查看状态或者取消下载。在Request对象中，可以通过分别调用 addRequestHeader() 给请求添加HTTP报头 setMimeType() 重写服务器返回的MIME类型。 setAllowedNetworkTypes 可以限制下载类型为Wi-Fi或者移动网络 getReommendedMaxBytesOverMobile 它会返回一个在移动数据连接上传输时推荐的最大字节数来确定是否应该限制下载类型为Wi-Fi enqueue 一旦连接可用且Download Manager空闲，就会开始下载 要想在下载完成后收到一个通知，需要注册一个Receiver来接收ACTION_DOWNLOAD_COMPLETE广播，它将包含一个EXTRA_DOWNLOAD_ID extra，其中包含了已经完成下载的引用ID。 1234567891011IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);BroadcastReceiver receiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; long reference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1); if (myDownloadReference == reference) &#123; //对下载的文件进行一些操作 &#125; &#125;&#125;;registerReceiver(receiver,filter); 通过调用Download Manager的openDownloadFile方法，可以获得文件的Parcel File Descriptor，查询Download Manager来得到文件的位置，或者如果已经指定了文件名和位置，那么直接操作这个文件。最好为ACTION_NOTIFICATION_CLICKED操作注册一个Receiver。每当用户从Notification任务栏或者Downloads应用中选择一个下载，那么这个Intent就会被广播。 1234567891011121314IntentFilter filter = new IntentFilter(DownloadManager.ACTION_NOTIFICATION_CLICKED);BroadcastReceiver receiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; String exrtaID = DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS; long[] references = intent.getLongArrayExtra(extraID); for (long reference : references) &#123; if (myDownloadReference == reference) &#123; //对下载的文件进行一些操作 &#125; &#125; &#125;&#125;;registerReceiver(receiver,filter); 自定义Download Manager Notification默认情况下，会为Download Manager管理的每一个下载显示一个持续的Notification。每一个Notification都会显示当亲的下载进度和文件名。Download Manager可以为每个下载请求自定义Notification，包括把它完全隐藏。 request.setTitle(“”) 设置通知标题 request.setDescription(“”) 设置通知文本 通过setNotificationVisibility方法并使用下面的标识之一来控制何时以及是否应该为请求显示一个Notification: Request.VISIBILITY_VISIBLE 当一个下载正在进行时，将显示一个持续的Notification标识持续时间。下载完成后，Notification将被移除。默认。 Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED 在下载期间会显示一个持续的Notification，即使下载完成也会继续显示(直到被选择或取消) Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION 只有下载完成，Notification 才会显示 Request.VISIBILITY_HIDDEN 不为此下载显示Notification。为了设置这个标识，必须在manifest中添加DOWNLOAD_WITHOUT_NOTIFICATION权限。 指定下载位置默认，Download Manager会把下载的文件保存到共享下载缓存中，而且使用系统生成的文件名。每一个请求对象都可以指定一个下载位置，但是所有的下载都必须存储到外部存储器中的某一个地方，而且应用程序必须在其清单中WRITE_EXTERNAL_STORAGE权限。 request.setDestinationUri(Uri.fromFile(f)); 如果下载的文件用于你的应用程序，你可能希望把它放在应用程序的外部存储文件夹下。 request.setDestinationInExternalFilesDir(this,Environment.DIRECTORY_DOWNLOADS,&quot;Bugdroid.png&quot;); 对于那些都能够或者应该与其他应用程序共享的文件——特别是希望使用媒体扫描器扫描的文件，可以再外部存储器的公共目录下制定一个文件夹来存储该文件。 request.setDestinationInExternalPublicDir(Environment.DIRECTORY_MUSIC,&quot;Android_Rock.mp3&quot;); 注意: 默认情况下Download Manager下载的文件不会被媒体扫描器扫描，因此它们可能不会显示在Gallery和Music Player等应用中。为了使下载的文件可以被扫描，可以再Request对象中调用allowScaningByMediaScanner。如果使你的文件对系统的Downloads应用是可见和可管理的，那么需要调用setVisibleInDownloadsUi，并传入true 取消和删除下载使用remove方法取消一个正在等待的下载，终止一个正在进行的下载，或者删除一个完成的下载。并且允许指定一个或者多个要取消的下载。 查询Download Manager可以通过query方法查询Download Manager来得到下载请求的状态、进度和详细信息。该方法会返回下载的Curosr对象。 query方法接收DownloadManager.Query对象作为参数，使用setFilterById方法给Query对象指定一个下载引用ID的序列，或者使用setFilterStatus方法来过滤下载的状态，该方法使用某个DownloadManager.STATUS_*常量来指定下载的运行、暂停、失败或成功。 Download Manager包含了很多COLUMN_*静态字符串常量，可以用它们来查询结果Cursor，可以得到每个下载的详细信息，包括状态、文件大小、目前下载的字节数、标题、描述、URI、本地文件名、媒体类型等。 123456789101112131415161718@Overridepublic void onReceive(Context context,Intent intent) &#123; long reference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID,-1); if (myDownloadReference == reference) &#123; Query myDownloadQuery = new Query(); myDownloadQuery.setFilterById(reference); Cursor myDownload = downloadManager.query(myDownloadQuery); if (myDownload.moveToFirst()) &#123; int fileNameIdx = myDownload.getColumnIndex(DownloadManager.COLUMN_LOCAL_FILENANE); int fileUriIDX = myDownload.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI); String fileName = myDownload.getString(fileNameIdx); String fileUri = myDownload.getString(fileUriIdx); //对下载文件进行一些操作 &#125; myDownload.close(); &#125;&#125; 针对下载暂停或失败的情形，可以通过查询COLUNMN_REASON列来得到其原因，该原因是由一个整数值来表示的。 STATUSPAUSED 通过使用DownloadManager.PAUSED* 静态变量之一来解释原因。 STATUSFAILED 通过DownloadManager.ERROR* 来确定失败的原因 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//获得Download Manager ServiceString serviceString = Context.DOWNLOAD_SERVICE;DownloadManager downloadManager = (DownloadManager)getSystemService(serviceString);//为暂停的下载创建一个查询Query pausedDownloadQuery = new Query();pausedDownloadQuery.setFilterByStatus(DownloadManager.STATUS_PAUSED);//查询Download Manager中暂停的下载Cursor pausedDownloads = downloadManager.query(pasusedDownloadQuery);//获得我们需要的数据的列索引int reasonIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUNMN_REASON);int titleIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_TITLE);int fileSizeIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_TOTAL_SIZE_BYTES);int bytesDLIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_BYTES_DOWNLOADS_SO_FAR);//遍历结果Cursorwhile(pausedDownloads.moveToNext()) &#123; //从Cursor中提取需要的数据 String title = pausedDownloads.getString(titleIdx); int fileSize = pausedDownloads.getInt(fileSizeIdx); int bytesDL = pausedDownloads.getInt(bytesDLIdx); //将暂停原因转化为友好的文本 int reason = pausedDownloads.getInt(reasonIdx); String reasonString = &quot;Unknown&quot;; switch(reason) &#123; case DownloadManager.PAUSEDD_QUEUED_FOR_WIFI: reasonString = &quot;Waiting for WiFi&quot;; break; case DownloadManager.PAUSEDD_WAITING_FOR_NETWORK: reasonString = &quot;Waiting for connectivity&quot;; break; case DownloadManager.PAUSEDD_WAITING_TO_RETRY: reasonString = &quot;Waiting to retry&quot;; break; default: break; &#125; //构造一个状态概要 StringBuilder sb = new StringBuilder(); sb.append(title).append(&quot;\n&quot;); sb.append(reasonString).append(&quot;\n&quot;); sb.append(&quot;Downloaded&quot;).append(bytesDL).append(&quot; / &quot;).append(fileSize); //显示状态 Log.d(&quot;DOWNLOAD&quot;,sb.toString());&#125;//关闭结果CursorpausedDownloads.close(); 文件保存Android在应用程序的上下文中提供了一些专门的实用工具文件管理 deleteFile 使用户能够删除由当前应用程序所创建的文件 fileList 返回一个字符串数组，其中包含了由当前应用程序所创建的所有应用程序 如果应用程序崩溃或者被意外终止，那么这些方法对于清理遗留的临时文件尤为有用。 特定于应用程序的文件夹存储文件 getDir 返回一个指向内部的应用程序文件存储目录路径的File对象 getExternalFilesDir 返回一个指向外部的应用程序文件存储目录路径的File对象(Environment.getExternalStorageDirectory) 存储在应用程序文件夹中的文件应该是特定于父应用程序的而且通常不会被媒体扫描仪所侦测到，因此这些文件不会被自动添加到媒体库中。如果应用程序下载或者创建了应该添加到媒体库中的文件或者想要这些文件对其他应用程序也是可用的，可以放到公共的外部存储目录中。 创建私有的应用程序文件Android提供了openFileInput和openFileOutput方法来简化从应用程序沙箱中的文件读取数据流和向应用程序沙箱中的文件写入数据流的过程。这些方法只支持那些当前应用程序文件夹中的文件，指定路径分隔符将会导致抛出一个异常。在创建FileOoutputStream时，如果你指定的文件名不存在，Android会为你创建。对于已经存在的文件的默认行为就是覆盖它；想要在已经存在的文件末尾添加内容，可以指定其模式为Context.MODE_APPEND。默认情况下，使用openFileOutput方法创建的文件对于调用应用程序是私有的————其他应用程序会被拒绝访问。在不同应用程序间共享文件的标准方式是使用一个Content Provider。另外，当创建输出文件时，可以通过指定Context.MODE_WORLD_READABLE 或者 Context.MODE_WORLD_WRITEABLE 让它在其他应用程序中也是可用的。通过 getFilesDir 可以找到存储在你的沙箱中的文件的位置，这个方法将会返回使用openFileOutput所创建的文件的绝对路径。 使用应用程序文件缓存Android提供了一个可管理的内存缓存和一个不能管理的外部缓存。分别调用getCacheDir 和 getExternalCacheDir 方法可以从当前的上下文中访问它们。存储在任何一个该缓存位置中的文件在应用程序被卸载之后都会被删除。当系统运行在低可用存储空间的时候，存储在内部缓存中的文件可能会被系统所删除；存储在外部缓存中的文件则不会被删除，因为系统不会跟踪外部媒介的可用存储空间。 存储公共可读文件Environment.getExternalStoragePublicDirectory可以用来找到存储应用程序文件的路径。返回的位置为用户通常存放和管理他们自己的各种类型的文件的位置。 1234567File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC);File file = new File(path,FILE_NAME);try &#123; path.mkdirs();&#125; catch (IOException e) &#123; &#125; DIRECTORY_ALARMS 作为用户可选择的警示音的可用的声音文件 DIRECTORY_DCIM 设备拍到的图片和视频 DIRECTORY_DOWNLOADS 设备下载的文件 DIRECTORY_MOVIES 电影 DIRECTORY_MUSIC 代表音乐的音频文件 DIRECTORY_NOTIFICATIONS 作为用户可选择的通知音的可用的音频文件 DIRECTORY_PICTURES 图片 DIRECTORY_PODCASTS 代表播客的音频文件 DIRECTORY_RINGTONES作为用户可选择的铃声的可用的音频文件 ServiceAndroid 提供Service类来专门创建用来处理生命周期操作的应用程序组件以及包括不需要用户界面的功能。Android赋予Service比处于非活动状态的Activity更高的优先级，因此当系统请求资源时，它们被终止的可能性更小。如果用户运行过早结束了一个已经启动Service，只要有足够的资源可用，则运行时就会重新启动它。必要的时候，一个Service的优先级可以提升到和前台Activity的优先级一样高。这是为了应对一些终止Service会显著影响用户体验的极端情况，如终止正在播放的音乐。通过使用Service，即使在UI不可见的时候也可以保证应用程序的持续运行。 Service简介创建和控制Service创建Service要定义一个Service，需要创建一个扩展Service的新类，需要重写onCreate和onBind方法。 1234567891011public class MyService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Override public void onBind(Intent intent) &#123; return null; &#125;&#125; 创建一个新的Service后，必须将这个Service在应用程序的清单文件中进行注册，需要在application节点中包含一个service标记。 service android:enabled=&quot;true&quot; android:name=&quot;.MyService&quot;/&gt; 为了确保你的Service只能由自己的应用程序启动和停止，所需要在它的Service节点下添加一个permission属性 1234&lt;service android:enabled=&quot;true&quot; android:name=&quot;.MyService&quot; android:permission=&quot;com.paad.MY_SERVICE_PERMISSION&quot;/&gt; 执行一个Service并控制它的重新启动行为重写onStartCommand事件处理程序以执行一个由Service封装的任务。在这个处理程序中，也可以指定Service的重新启动行为。当一个Service通过startService启动时，就会调用onStartCommand方法，所以这个方法可能在Service生命周期内被执行很多次。 Service是在应用程序的主线程中启动的，这意味着在onStartCommand处理程序中完成的任何处理都是运行在GUI主线程中的。实现Service的标准模式是从onStartCommand中创建和运行一个新线程，用来在后台执行处理，并在该线程完成后终止这个Service。 12345@Overridepublic int onStartCommand(Intent intent,int flags,int startId) &#123; startBackgroundTask(intent,startId); return Service.START_STICKY;&#125; 通过以下的Service常量可以控制重新启动行为 START_STICKY 描述了标准的重新启动行为。如果返回了这个值，那么在运行时终止Service后，当重新启动Service时，将会调用onStartCommand。注意，当重新启动Service后，传入onStartCommand的Intent参数将是null。这种模式通常用于处理自身状态的Service，以及根据需要通过startService和stopService显式地启动和终止的Service。这些Service包括播放音乐的Service或者处理其他持续进行的后台任务的Service。 START_NOT_STICKY 这种模式用于启动以处理特殊的操作和命令的Service。通常当命令完成后，这些Service会调用stopSelf终止自己。当被运行时终止后，只有当存在未处理的启动调用时，设为这个模式的Service才回重新启动。如果在终止Service后没有进行startService调用，那么Service将停止运行，而不会调用onStartCommand。对于处理特殊请求，尤其是诸如更新或者网络轮询这样的定期处理。 START_REDELIVER_INTENT 需要确保从Service中请求的命令得以完成。这种模式是前两种模式的组合。如果Service被运行时终止，那么只有当存在未处理的启动调用或进程在调用stopSelf之前被终止时，才会重新启动Service。后一种情况中，将会调用onStartCommand，冰纯如没有正常完成处理的Intent。 由于对startService的调用不能嵌套，因此不管startService被调用了多少次，对stopService的一次调用就会终止它所匹配的运行中的Service。 自终止Service由于Service具有高优先级，它们通常不会被运行时终止，因此自终止可以显著地改善应用程序中的资源占用情况。通过在处理完成后显示地停止Service，可以避免系统仍然为使该Service继续运行而保留资源。当Service完成操作或处理后，应该调用stopSelf终止它。此时可以不传递参数，从而强制停止Service。也可以传入startId值，确保已经为目前调用的每个startService实例完成了处理。 将Service绑定到ActivityService可以和Activity绑定，后者会维持一个对前者实例的引用，此引用允许你像对待其他实例化的类那样，对正在运行的Service进行方法调用。允许Service和Activity绑定，这样能够获得更加详细的接口。要让一个Service支持绑定，需要实现onBind方法，并返回被绑定Service的当前实例。 123456789101112@Overridepublic IBinder onBind(Intent intent) &#123; return binder;&#125;public class MyBinder extends Binder &#123; MyMusicService getService() &#123; return MyMusicService.this; &#125;&#125;private final IBinder binder = new MyBinder(); Servie和其他组件之间的连接表示为一个ServiceConnection。要想将一个Service和其他组件进行绑定，需要实现一个新的ServiceConnection，建立了一个连接之后，就可以通过重写onServiceConnected和onServiceDisconnected方法来获得对Service实例的引用。 123456789101112131415//Service的引用private MyMusicService serviceRef;//处理Servie和Activity之间的连接private ServiceConnection mConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className,IBinder service) &#123; //当建立连接时调用 serviceRef = ((MyMusicService.MyBinder)service).getService(); &#125; public void onServiceDisconnected(ComponentName className) &#123; //当Service意外断开时接收 serviceRef = null; &#125;&#125; 要执行绑定，需要在Activity中调用bindService，并传递给它一个用于选择要绑定到的Service的Intent以及一个ServiceConnection实现的实例。还可以指定很多的绑定标识。 123//绑定一个ServiceIntent bindIntent = new Intent(MyActivity.this,MyMusicService.class);bindService(bindIntent,mConnection,Context.BIND_AUTO_CREATE); BIND_ADJUST_WITH_ACTIVITY 系统可以根据一个Service所绑定的Activity的相对重要重读来调整这个Service的优先级。因此，当Activity处于前台时，系统会提高Service的优先级。 BIND_IMPORTANT 和 BIND_ABOVE_CLIENT 对于正在绑定一个Service的客户端来说，这个Service非常重要。以至于客户端处于前台时，Service也应该变为前台进程。BIND_ABOVE_CLENT指定在内存很低的情况下，运行时会在终止绑定的Service之前先终止Activity。 BIND_NOT_FOREGROUND 确保绑定的Service永远不会拥有运行于前台的优先级。默认，绑定一个Service会提高它的优先级。 BIND_WAIVE_PRIORITY 表示绑定一个指定的Service不应该改变该Service的优先级。一旦Service被绑定，就可以通过从onServiceConnected处理程序获得的serviceBind对象来使用Service所有的共有方法和属性。 如果你想和运行在不同进程中的Service进行通信，可以使用广播Intent的方式或者在启动Service的Intent中添加额外的Bundle数据。如果需要耦合更加紧密的连接，可以使用Android Interface Definition Language(AIDL),使Service可以跨应用绑定。 创建前台Service在Service需要直接和用户进行交互的情况下，把Service的优先级提升到与前台一样高，可以通过调用Service的startForeground方法以设置该Service在前台运行。由于需要直接进行交互，所以必须指定一个持续工作的Notification。 1234567891011121314151617private void startPlayback(String album,String artist) &#123; int NOTIFICATION_ID = 1; //创建一个当单机通知时将打开主Activity的Intent Intent intent = new Intent(this,MyActivity.class); PendingIntent pi = PendingIntent.getActivity(this,1,intent,0); //设置Notification UI参数 Notificatin notification = new Notification(R.drawable.icon,&quot;Start Playback&quot;,System.cureentTimeMillis()); notification.setLatestEventInfo(this,album,artis,pi); //设置Notification为持续显示 notification.flags = notification.flags | Notification.FLAG_ONGOING_EVENT; //将Service移到前台 startForeground(NOTIFICATION_ID, notification);&#125; 当Service不再需要前台运行的优先级时，可以使用stopForeground方法，把它移到后台，并可以选择是否移除通知。 1234public void pausePlayback() &#123; //移到后台并移除Notification stopForeground(true);&#125; 使用后台线程Android中所有的应用程序组件包括Activity、Servie、Broadcast Receiver都在应用程序的主线程中运行，因此，任何组件中的费时处理都可能阻塞所有其他的组件，包括Service和可见Activity，我们需要避免出现未响应(Activity对一个输入事件在5秒的时间内没有响应，或者Broadcast Receiver在10秒内没有完成它的onReceive处理程序)。所以对于任何不用直接与用户界面进行交互的重要处理，使用后台线程技术是很重要的。将文件操作、网络查找、数据库事务、复杂计算调度到后台线程中完成尤其重要。 使用AsyncTask运行异步任务AsyncTask类为将耗时的操作移到后台线程并在操作完成后同步更新UI线程实现了最佳实践模式。它有助于将事件处理程序与GUI线程进行同步，允许通过更新视图和其他UI元素来报告进度，或者在任务完成后发布结果。AsyncTask处理线程创建、管理和同步等全部工作，它可以用来创建、管理和同步等全部工作，他可用来创建一个异步任务，该任务由两个部分完成:将在后台执行的处理以及在处理完成后执行的UI更新。AsyncTask对于生命周期较短且需要在UI上显示进度和结果的后台操作是很好的解决方案。然而当Activity重新启动的时候，这种操作将不会持续进行。AsyncTask在设备的方向变化而导致Activity被销毁和重新创建时会被取消。对于生命周期较长的后台操作，如从Internet下载数据，使用Service组件是更好的选择。 创建新的异步任务要创建一个新的异步任务，需要扩展AsyncTask类 12345678910111213141516171819202122232425262728293031323334353637private class MyAsyncTask extends AsyncTask&lt;String,Integer,String&gt; &#123; @Override protected String doInBackground(String... parameter) &#123; //移动到后台线程 String result = &quot;&quot;; int myProgress = 0; int inputLength = parameter[0].length(); //执行后台处理任务，更新myProgress for (int i = 1; i &lt;= inputLength;i++) &#123; myProgress = i; result = result + parameter[0].charAt(inputLength - i); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; &#125; publishProgress(myProgress); &#125; //返回一个值，它将传递给onPostExecute return result; &#125; @Override protected void onProgressUpdate(Integer... progress) &#123; //和UI线程同步 //更新进度条、Notification或者其他UI元素 asyncProgress.setProgress(progress[0]); &#125; @Override protected void onPostExecute(String result) &#123; //和UI线程同步 //通过UI更新，Dialog或者Notification报告结果 asyncTextView.setText(result); &#125;&#125; doInBackground 这个方法将会在后台线程上执行，所以应该把运行时间较长的代码放到这里，而且不能视图再次处理程序中与UI对象交互。可以在本处理程序中调用publishProgress方法以传递参数值给onProgressUpdate处理程序，当后台任务完成后，可以返回最终的结果并作为参数传递给onPostExecute处理程序。 onProgressUpdate 当中间进度更新变化时更新UI。 onPostExecute 后台任务结束，更新UI 运行异步任务调用execute来执行它，每个AsyncTask实例只能执行一次。如果试图第二次调用execute，则会抛出一个异常。 12String input = &quot;redrum ... redrum&quot;;new MyAsyncTask().execute(input); Intent Service简介Intent Service是一个非常方便的包装类，根据需求执行一组任务的后台Service实现了最佳实践模式。如Internet的循环更新或者数据处理。其他应用程序组件要想通过Intent Service完成一个任务，需要启动Service并传递给它一个包含完成该任务所需的参数的Intent。Intent Service会将收到的所有请求Intent放到队列中，并在异步后台线程中逐个地处理它们。当处理完每个收到的Intent后，Intent Service就会终止它自己。Intent Service处理所有的复杂工作，如将多个请求放入队列，后台线程的创建、UI线程的同步。 12345678910111213141516171819public class MyIntentService extends IntentService &#123; public MyIntentService(String name) &#123; super(name); //完成任何需要的构造函数任务 &#125; @Override public void onCreate() &#123; super.onCreate(); //创建Service时要执行的操作 &#125; @Override protected void onHandleIntent(Intent intent) &#123; //这个处理程序发生在一个后台线程中 //耗时任务应该在此实现 //传入这个IntentService的每个Intent将被逐个处理，当所有传入的Intent都被处理后，该Service会终止自己。 &#125;&#125; 一旦收到Intent请求，onHandleIntent处理程序就会在一个工作线程中执行。对于按需或者固定时间间隔执行一组任务，Intent Service是创建这种Service的最佳方法。 Loader简介它封装用于在UI元素中进行异步数据加载的最佳实践技术。如果想要创建一个自己的Loader实现，通常最佳实践是扩展AsyncTaskLoader而不是直接扩展Loader 异步加载数据 监控要加载的数据源并自动提供更新结果 手动创建线程和GUI线程同步Thread12345Thread thread = new Thread(null,new Runnable() &#123; public void run() &#123; &#125;&#125;,&quot;Background&quot;);thread.start(); 12345runOnUiThread(new Runnable() &#123; public void run() &#123; //更新一个View或者其他Activity UI元素 &#125;&#125;); Handler使用Handler类的post方法将更新从后台线程发布到用户界面上。 12345678910//在主线程上初始化一个handlerprivate Handler handler = new Handler();//在主UI线程上使用Handler发布doUpdateGUI Runnablehandle.post(doUpdateGUI)//执行更新UI的Runnableprivate Runnable doUpdateUI = new Runnable() &#123; public void run() &#123; updateGUI(); &#125;&#125; 使用AlarmAlarm是一种在预先确定的时间或时间间隔内激活Intent的方法。和Timer不同，Alarm是在应用程序之外操作的，所以即使应用程序关闭，它们也仍然能够用来激活应用程序事件或操作。当它们和Broadcast Receiver一起使用时会更加强大，允许设置能够激活广播Intent、启动Service、甚至启动Activity的Alarm，而不需要打开或者运行应用程序。Alarm是降低应用程序资源需求的一种极为有效的方式。可以使用Alarm实现基于网络查找的定时更新，或者把费时的或者成本受约束的操作安排在“非高峰”时期运行，又或者对失败的操作调度重试。Alarm在设备处于休眠状态时依然保持活动状态，可以有选择地设置Alarm来唤醒设备。无论何时重启设备，所有的Alarm都会被取消。 创建、设置和取消Alarm要创建一个新的只激活一次的Alarm，可以使用set方法指定一个Alarm类型、触发时间和一个要激活的Pending Intent。如果把Alarm的触发时间设置为过去的时间，那么它将会被立即触发。 RTC_WAKEUP 在指定的时间唤醒设备，并激活Pending Intent。 RTC 在指定的时间点激活Pending Intent,但是不会唤醒设备。 ELAPSED_REALTIME 根据设备启动之后经过的时间激活Pending Intent，但是不会唤醒设备。经过的时间包含设备休眠的所有时间。 ELAPSED_REALTIME_WAKEUP 在设备启动并经过指定的时间之后唤醒设备和激活Pending Intent。 12345678910111213141516//获取一个Alarm Manager的引用AlarmManager alarmManager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);//如果设备处于休眠状态，设置Alarm来唤醒设备int alarmType = AlarmManager.ELAPSED_REALTIME_WAKEUP;//10秒钟后触发设备long timeOrLengthofwait = 10000;//创建能够广播和操作的Pending IntentString ALARM_ACTION = &quot;ALARM_ACTION&quot;;Intent intentToFire = new Intent(ALARM_ACTION);PendingIntent alarmIntent = PendingIntent.getBroadcast(this,0,intentToFire,0);//设置AlarmalarmManager.set(alarmType,timeOrLengthofWait,alarmIntent); 当触发Alarm时，就会广播指定的Pending Intent。因此，使用相同的Pending Intent设置第二个Alarm会替代已经存在的Alarm。要取消一个Alarm，需要调用Alarm Manager的cancel方法，并传递给它不再想触发的Pending Intent。 设置重复Alarm重复Alarm和一次性的Alarm具有相同的工作方式，不过会在指定的时间间隔内重复触发。因为Alarm是在应用程序生命周期之外设置的，所以它们十分适合于调度定时更新或者数据查找，从而避免了在后台持续运行Service。当需要对重复Alarm的精确时间间隔进行细粒度控制时，可以使用setReating方法。传入这个方法的时间间隔可以用于指定Alarm的确切时间间隔，最多可以精确到毫秒。当按照计划定时唤醒设备来执行更新时会消耗电池的电量，setInexactRepeating方法能够帮助减少这种电量消耗。在运行时，Android会同步多个没有精确指定时间间隔的重复Alarm，并同时触发它们。 INTERVAL_FIFTEEN_MINUTES INTERVAL_HALF_HOUR INTERVAL_HOUR INTERVAL_HALF_DAY INTERVAL_DAY 12345678910111213141516//获取一个Alarm Manager的引用AlarmManager alarmManager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);//如果设备处于休眠状态，设置Alarm来唤醒设备int alarmType = AlarmManager.ELAPSED_REALTIME_WAKEUP;//调度Alarm以每半小时重复一次long timeOrLengthofWait = AlarmManager.INTERVAL_HAL_HOUR;//创建能够广播和操作的Pending IntentString ALARM_ACTION = &quot;ALARM_ACTION&quot;Intent intentToFire = new Intent(ALARM_ACTION);PendingIntent alarmIntent = PendiingIntent.getBroadcast(this,0,intentToFire,0);//每半小时唤醒设备以激活一个AlarmalarmManager.steInexactRepeating(alarmType,timeOrLengthofWait,timeOrLengthofWait,alarmIntent); 设置定期重复Alarm会对电池电量产生显著的影响。最好将Alarm频率限制为 最低可接受频率，只在必要时唤醒设备。 硬件传感器受支持的传感器 Sensor.TYPE_AMBIENT_TEMPERATURE 这是一个温度计，返回以摄氏度表示的温度。返回的温度表示的是环境的室温。 Sensor.TYPE_ACCELEROMETER 一个三轴的加速计传感器，返回三个坐标轴的当前加速度，单位为m/s2 Sensor.TYPE_GRAVITY 一个三轴的重力传感器，返回当前的方向和三个坐标轴上的重力分量，单位为m/s2。通常，重力传感器是通过对加速计传感器的结果应用一个低通过滤器，作为一个虚拟传感器实现。 Sensor.TYPE_LINEAR_ACCELERATION 一个三轴的线性加速度传感器，返回三个坐标轴上不包括重力的加速度，单位为m/s2。与重力传感器一样，线性加速度通常是加速计输出，作为一个虚拟传感器实现的。只是为了得到线性加速，对加速计输出应用了高通过滤器。 Sensor.TYPE_GYROSCOPE 一个陀螺仪传感器，以弧度/秒返回了三个坐标轴上的设备旋转速度。可以对一段时间内的旋转速率求积分，以确定设备的当前方向，但是更好的做法是结合其他传感器来使用这个传感器以得到更加平滑和校正后的结果。 Sensor.TYPE_ROTATION_VECTOR 返回设备的方向，表示为三个轴的角度的组合。通常用作传感器管理器的getRotationMatrixFormVector方向的输入，以便将返回的旋转向量转换为旋转矩阵。旋转向量传感器一般被实现为一个虚拟传感器，它可以组合并校正多个传感器得到的结果，以提供更加平滑的矩阵。 Sensor.TYPE_MAGNETIC_FIELD 一个磁力传感器，返回三个坐标轴上的当前磁场，单位为microteslas。 Sensor.TYPE_PRESSURE 一个气压传感器，返回当前的大气压力，单位为millibars。通过使用传感器管理器的getAltitude方法来比较两个位置的气压值，可以把气压传感器用于确定海拔高度。 Sensor.TYPE_RELATIVE_HUMIDITY 一个相对湿度传感器，以百分比的形式返回当前的相对湿度 Sensor.TYPE_PROXIMITY 一个近距离传感器，以厘米为单位返回设备和目标对象之间的距离。 Sensor.TYPE_LIGHT 一个环境光传感器，返回一个以lux为单位的值，用于描述环境光的亮度。 查找传感器//查找所有传感器 12SensorManager sensorManager = (SensorManager)getSystemService(service_name);List&lt;Sensor&gt; allSensor = sensorManager.getSensorList(Sensor.TYPE_ALL); 查找可用的特定类型传感器,可以传入指定所需要的传感器类型。如果指定的传感器类型有多个传感器实现，可以通过查询每个返回的Sensor对象来决定使用哪个传感器。每个Sensor对象都会报告其名称、用电量、最小延迟、最大工作范围、分辨率和供应商的类型。 如何选择一个工作范围最大并且耗电量最低的光传感器，以及校正过的陀螺仪 12345678910111213141516171819202122List&lt;Sensor&gt; lightSensors = sensorManager.getSensorList(Sensor.TYPE_LIGHT);List&lt;Sensor&gt; gyroscopes = sensorManager.getSensorList(Sensor.TYPE_GYROSCOPE);Sensor bestLightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);Sensor correctedGyro = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);if (bestLightSensor != null) &#123; for (Sensor lightSensor : lightSensors) &#123; float range = lighSensor.getMaximumRnage(); float power = lightSensor.getPower(); if (range &gt;= bestLightSensor.getMaximumRange()) &#123; if (power &lt; bestLightSensor.getPower() || range &gt; bestLightSensor.getMaximumRange()) &#123; bestLightSensor = lightSensor; &#125; &#125; &#125;&#125;if (gyroscope != null &amp;&amp; gyroscopes.size() &gt; 1) &#123; correctedGyro = gyroscopes.get(gyroscopes.size() - 1);&#125; 监视传感器为监视传感器，需要实现一个SensorEventListener，使用onSensorChanged方法监视传感器值，使用onAccuracyChanged方法响应传感器精确度的变化。 123456789final SensorEventListener mySensorEventListener = new SensorEventListener() &#123; public void onSensorChanged(SensorEvent sensorEvent) &#123; //监视传感器改变 &#125; public void onAccuracyChanged(Sensor sensor,int accuracy) &#123; //对传感器精确度的改变做出反应 &#125;&#125; onSensorChanged方法中的SensorEvent参数包含以下4中用于描述一个传感器事件的属性 sensor 触发该事件的Sensor对象 accuracy 当事件发生时传感器的精确度(low,medium,high 或 unreliable) values 包含了已检测到的新值得浮点型数组 timestamp 传感器事件发生的时间 onAccuracyChanged方法单独监视传感器精确度的变化，accuracy传感器精确度，表示的常量 SensorManager.SENSOR_STATUS_ACCURACY_LOW 表示传感器的精确度很低并且需要校准 SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM 表示传感器数据具有平均精确度，并且校准可能会改善报告的结果 SensorManager.SENSOR_STATUS_ACCURACY_HIGH 表示传感器使用的是最高精确度 SensorManager.SENSOR_STATUS_UNRELIABLE 表示传感器数据不可靠，这意味着需要校准该传感器或者当前不能读数 12Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);sensorManager.register(mySensorEventListener,sensor,SensorManager.SENSOR_DELAY_NORMAL); SENSOR_DELAY_FASTEST 指定可以实现的最快更新速率 SENSOR_DELAY_GAME 指定适合控制游戏的更新速率 SENSOR_DELAY_NORMAL 指定默认的更新速率 SENSOR_DELAY_UI 指定适合更新UI的速率 应用 使用指南针和加速计确定用户的朝向和设备方向。将它们与地图、摄像头和基于位置的服务一起使用，可以创建出增强现实UI，这种UI可以使用基于位置的数据叠加在摄像头实时播放的画面之上。 创建能够动态调整以适应用户设备的方向的UI。 通过监视快速的加速度来检测设备是否已经在掉落或者被抛掉 测量移动或者振动。 创建能够使用物理动作和移动作为输入的UI控件 找到当前的屏幕旋转方向12345678910WindowManager wm = (WindowManager)getSystemService(Context.WINDOW_SERVICE);Display display = wm.getDefaultDisplay();int rotation = display.getRotation();switch(rotation) &#123; case (Surface.ROTATION_0) : break; //Natural case (Surface.ROTATION_90) : break; //On its left side case (Surface.ROTATION_180) : break; //Upside down case (Surface.ROTATION_270) : break; //On its right side default: break;&#125; 计算方向1234567891011121314151617181920212223242526272829303132333435363738private float[] accelerometerValues;private float[] magneticFieldValues;final SensorEventListener myAccelerometerListener = new SensorEventListener() &#123; public void onSensorChanged(SensorEvent sensorEvent) &#123; if (sensorEvent.sensor.getType() == Sensor.TYPE_ACCELEROMETER) &#123; accelerometerValues = sensorEvent.values; &#125; &#125; public void onAccuracyChanged(Sensor sensor,int accuracy);&#125;;final SensorEventListener myMagneticFieldListener = new SensorEventListener() &#123; public void onSensorChanged(SensorEvent sensorEvent) &#123; if (sensorEvent.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) &#123; magneticFieldValues = sensorEvent.values; &#125; &#125; public void onAccuracyChanged(Sensor sensor,int accuracy) &#123;&#125;&#125;SensorManager sm = (SensorManager)getSystemService(Context.SENSOR_SERVICE);Sensor aSensor = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);Sensor mfSensor = sm.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);sm.registerListener(myAccelerometerListener,aSensor,SensorManager.SEENSOR_DELAY_UI);sm.registerListener(myMagneticFieldListener,mfSensor,SensorManager.SENSOR_DELAY_UI);float[] values = new float[3];float[] R = new float[9];SensorManager.getRotationMatrix(R,null,accelerometerValues,magneticFieldValues);SensorManager.getOrientation(R,values);//Convert from radians to degrees if preferredvalues[0] = (float) Math.toDegrees(values[0]);values[1] = (float) Math.toDegrees(values[1]);values[2] = (float) Math.toDegrees(values[2]); values[0] 当设备朝向磁北时，方位角为0 values[1] 俯仰角，即绕x轴的旋转 values[2] 横滚角，即绕y轴的旋转 个性化屏幕主屏幕WidgetWidget可以使我们的应用程序直接在用户主屏幕上拥有一块交互式的屏幕面板以及一个入口点。一个好的App Widget可以用最少的资源开销提供有用的、精确的和及时的信息。App Widgets作为BroadcastReceivers实现，它们使用RemoteViews来创建和更新寄存在另一个应用程序进程中的视图层次结构。为了创建一个应用程序的Widget，我们需要建立以下三个组件 一个定义了该WidgetUI的XML布局资源 一个描述了与该Widget相关联的元数据的XML文件 一个定义并控制该Widget的Intent接收器 创建Widget的XML布局资源最佳做法是使用XML将自己的Widget布局定义为一个外部布局资源，但是在Broadcast Receiver的onCreate方法中通过编程方式布局自己的UI也是同样可行的。Widget完成支持透明背景，并允许使用NinePatches和部分透明的Drawable资源。 受支持的Widget视图和布局 所有的自定义视图 由允许的视图所派生的视图 EditText FrameLayout LinearLayout RelativeLayout GridLayout AnalogClock Button ImageButton ImageView ProgressBar TextView ViewFlipper 定义Widget设置Widget定义资源作为XML存储在项目的res/xml文件夹中，appwidget-provider标签使我们能够描述Widget元数据。 initialLayout 创建Widget UI 时用到的布局资源 minWidth/minHeight 分别表示Widget的最小宽度和最小高度 resizeMode 通过使用horizontal和vertical的组合来设置resizeMode允许你指定Widget在哪个方向上进行调整。将它设置为none则会禁止调整Widget的大小。 label 在Widget选取器中用户Widget所用到的标题 updatePreiodMillis 以毫秒为单位表示的Widget更新的最小周期。Android将会以这个速率唤醒设备以便更新用户Widget，，因此应当将其指定为至少一个小时。App Widget Manger最快不能以每30分钟一次的速率进行更新。 configure 当将用户Widget添加到主屏幕中时，可以有选择地指定启动一个完全限定的Activity。 icon 默认情况下，Android在Widget选取器中呈现Widget时，会使用应用程序的图标。通过指定一个Drawable资源，可以使用一个不同的图标。 previewImage 用于显示Widget的预览，而不是显示其图标。 123456789&lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:initialLayout=&quot;@layout/my_widget_layout&quot; android:minWidth=&quot;110dp&quot; android:minHeight=&quot;110dp&quot; android:label=&quot;@string/widget_label&quot; android:updatePeriodMillis=&quot;360000&quot; android:resizeMode=&quot;horizontal|vertical&quot; android:previewImage=“@drawable/widget_preview”&gt; 创建Widget Broadcast Receiver并将其添加到应用程序的manifest文件中Widget是作为Broadcast Receiver实现的。每个Widget的Broadcast Receiver都指定Intent Filter，用于监听使用AppWidget.ACTION_APPWIDGET_UPDATE、DELETED、ENABLED以及DISABLED动作请求更新的Broadcast Intent 123456789101112131415161718192021222324public class SkeletonAppWidget extends AppWidgetProvider &#123; @Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds) &#123; //更新Widget UI &#125; @Override public void onDeleted(Context context,int[] appWidgetIds) &#123; //处理删除Widget的操作 super.onDeleted(context,appWidgetIds); &#125; @Override public void onDisabled(Context context) &#123; //Widget已被禁用 super.onDisabled(context); &#125; @Override public void onEnabled(Context context) &#123; //Widget已被启用 super.onEnabled(context); &#125;&#125; Widget必须被添加到应用程序的manifest文件中，像其他Broadcast Receiver一样使用一个receiver标签。为了将一个Broadcast Receiver指定为一个App Widget，需要下面两个标签添加到它的manifest文件节点中。 一个用于android.appwidget.action.APPWIDGET_UPDATE动作的Intent Filter 一个对appwidget-provider 元数据XML资源的引用。 12345678&lt;receiver android:name=&quot;.MyAppWidget&quot; android:label=&quot;@string/widget_label&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;/&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/widget_provider_info&quot;/&gt;&lt;/receiver&gt; AppWidgetManager 和 RemoteViewAppWidgetManager类用于更新App Widget和提供App Widget的相关信息RemoteView类用于在另一个应用程序的进程中托管的View层次的代理，从而允许修改运行在另一个应用程序中的View的属性。 RemoteView12345678910RemoteViews views = new RemoteViews(context.getPackageName(),R.layout.my_widget_layout);views.setInt(R.id.widget_image_view,&quot;setImageLevel&quot;,2); //设置ImageView的image levelviews.setBoolean(R.id.widget_text_view,&quot;setCursorVisible&quot;,true); //显示TextView的光标views.setBitmap(R.id.widget_image_button,&quot;setImageBitmap&quot;,myBitmap); //将一个位图分配给一个ImageButtonviews.setTextViewText(R.id.widget_text,&quot;Updated Text&quot;);views.setTextColor(R.id.widget_text,Color.BLUE);views.setImageViewResource(R.id.widget_image,R.drawable.icon);views.setProgressBar(R.id.widget_progressbar,100,50,false);views.setChronometer(R.id.widget_chronometer,SystemClock.elapsedRealtime,null,true);views.setViewVisibility(R.id.widget_text,View.INVISIBLE); 将RemoteView应用到运行中的App Widget要将对RemoteView所做的修改应用到处于活动状态的Widget，需要使用AppWidgetManager的updateAppWidget方法，并传入一个或更多个要更新的Widget的标识符和要应用的RemoteView作为其参数。 appWidgetManager.updateAppWidget(appWidgetIds,remoteViews); 1234567891011121314@Overridepublic void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds) &#123; //在迭代每个widget的过程中，创建一个RemoteViews对象并将修改后的RemoteViews应用到每个Widget final int N = appWidgetIds.length; for(int i = 0;i &lt; N;i++) &#123; int appWidgetId = appWidgetIds[i]; //创建一个RemoteViews对象 RemoteViews views = new RemoteViews(context.getPackageName(),R.layout.my_widget_layout); //更新UI,通知AppWidgetManager使用修改后的过程view更新widget appWidgetManager.updateAppWidget(appWidgetId,views); &#125;&#125; 也可以直接从一个Service、Activity或Broadcast Receiver更新Widget。为此，需要调用AppWidgetManager的getInstance静态方法并传入当前上下文，以获得AppWidgetManager的引用 123456789101112131415//获得AppWidgetManagerAppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);//获得所选的Widget的每个实例的标识符ComponentName thisWidget = new ComponentName(context,MyAppWidget.class);int[] appWidgetIds = appWidgetManager.getAppWidgetIds(thisWidget);//迭代每个Widget的过程中，创建一个RemoteViews对象并将修改后的RemoteViews应用到每个Widgetfor (int i = 0;i &lt; N;i++) &#123; int appWidgetId = appWidgetIds[i]; //创建一个RemoteViews对象 RemoteViews views = new RemoteViews(context.getPackageName(),R.layout.my_widget_layout); //使用views对象更新Widget的UI //通知AppWidgetManager使用修改后的远程View更新Widget appWidgetManager.updateAppWidget(appWidgetId,views);&#125; 使用RemoteViews为Widget添加交互性因为大多数主屏幕应用程序都在完整权限下运行，所以潜在的安全风险变得十分严峻。因而，Widget的交互性是被严格控制的。 添加监听一个或更多个View的Click Listener 根据所选项变化改变UI 在Collection View Widget中的View之间过滤 Android不支持直接在App Widget中输入文本。如果需要在Widget中输入文本，最佳实践是添加该Widget的一个Click Listener，让它显示一个用于接受输入的Activity。 使用Click Listener，要向Widget添加交互性，最简单、最强大的方法是添加其View的Click Listener。 123Intent intent = new Intent(context,MyActivity.class);PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0);views.setOnClickPendingIntent(R.id.widget_text,pendingIntent); Collection View Widget简介这是一种新型的Widget，用于将数据集合显示为列表、网格或层叠卡片样式 StackView 一个卡片View，以层叠方式显示其子View。这叠“卡片将从集合的头至尾自动循环。用户可以向上或向下滑动手指，进行切换” ListView 集合中的每个项目都作为垂直列表中的一行进行显示 GridView 一个二维的可滚动列表，每个项目都显示在网格的一个单元格中。 创建 RemoteViewsServiceRemoteViewsService用作一个实例化和管理RemoteViewsFactory的包装器，而RemoteViewsFactory则用来提供在Collection View Widget中显示的每个View。为创建RemoteViewsService需要扩展RemoteViewsService类，并通过重写onGetViewFactory处理程序来返回RemoteViewsFactory的一个新实例。和任何Service一样，需要使用一个service标签把RemoteViewsService添加到应用程序的manifest文件中。为防止其他应用程序访问你的Widget，必须指定android.permission.BIND_REMOTEVIEWS权限。 创建一个RemoteViewsFactoryRemoteViewsFactory是Adapter类的一个包装器，用于创建和填充将在Collection View Widget中显示的View ———— 实际上是将它们与底层的数据集合绑定到一起。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class MyRemoteViewsFactory implements RemoteViewsFactory &#123; private ArrayList&lt;String&gt; myWidgetText = new ArrayList&lt;String&gt;(); private Context context; private Intent intent; private int widgetId; public MyRemoteViewsFactory(Context context,Intent intent) &#123; this.context = context; this.intent = intent; widgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,AppWidgetManager.INVALID_APPWIDGET_ID); &#125; //设置数据源的任何连接，繁重的工作，例如下载数据，应该推迟到onDataSetChanged()或getViewAt()中执行这个调用的时间超过20秒会导致一个ANR public void onCreate() &#123; myWidgetText.add(&quot;The&quot;); myWidgetText.add(&quot;quick&quot;); myWidgetText.add(&quot;brown&quot;); myWidgetText.add(&quot;fox&quot;); myWidgetText.add(&quot;jumps&quot;); myWidgetText.add(&quot;over&quot;); myWidgetText.add(&quot;the&quot;); myWidgetText.add(&quot;lazy&quot;); myWidgetText.add(&quot;droid&quot;); &#125; //当显示的底层数据集合被修改时调用。可以使用AppWidgetManager的notifyAppWidgetViewDataChanged()方法来触发这个处理程序 public void onDataSetChanged() &#123; //底层数据改变时进行处理 &#125; //返回正在显示的集合中的项数 public int getCount() &#123; return myWidgetText.size(); &#125; //如果每个项提供的唯一ID是稳定的————即它们不会在运行时改变，就返回true public boolean hasStableIds() &#123; return false; &#125; //返回与位于指定索引位置的项目关联的唯一ID public long getItemId(int index) &#123; return index; &#125; //不同View定义的数量 public int getViewTypeCount() &#123; return 1; &#125; //可选地制定一个“加载”View进行显示 public RemoteViews getLoadingView() &#123; return null; &#125; //创建并填充将在指定索引位置显示的View public RemoteViews getViewAt(int index) &#123; //创建将在所需索引位置显示的View RemoteViews rv = new RemoteViews(context.getPackageName,R.layout.my_stack_widget_item_layout); //使用底层数据填充View rv.setTextViewText(R.id.widget_title_text,myWidgetText.get(index)); rv.setTextViewText(R.id.widget_text,&quot;View Number: &quot; + String.valueOf(index)); //创建一个特定于项的填充Intent，用于填充在App Widget Provider中创建的Pending Intent filInIntent = new Intent(); fillInIntent.putExtra(Intent.EXTRA_TEXT,myWidgetText.get(index)); rv.setOnClickFillInIntent(R.id.widget_title_text,fillInIntent); return rv; &#125; //关闭连接、游标或者onCreate中创建的其他任何持久状态 public void onDestroy() &#123; myWidgetText.clear(); &#125;&#125; 使用RemoteViewsService填充CollectionViewWidgetIntent intent = new Intent(context,MyRemoteViewsService.class); RemoteViewsService内的onGetViewFactory处理程序会收到这个Intent，从而使你能够向Service和它包含的Factory传递额外的参数。还需要指定要绑定的Widget的ID，这样可以为不同的Widget实例指定不同的Service。通过使用setEmptyView方法，可以指定一个当且仅当底层数据集合为空时显示的View。在完成绑定之后，使用App Widget Manager的updateAppWidget方法将绑定应用到指定的Widget上 123Intent intent = new Intent(context,MyRemoteViewsService.class);intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetId);views.setRemoteAdapter(appWidgetId,R.id.widget_stack_view,intent); 向Collection View Widget中的项添加交互性出于效率原因，无法向作为Collection View Widget一部分显示的每个项分配唯一的onClickPendingIntent。需要使用setPendingIntentTemplate向Widget分配一个模板Intent 1234Intent templateIntent = new Intent(Intent.ACTION_VIEW);templateIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetId);PendingIntent templatePendingIntent = PendingIntent.getActivity(context,0,templateIntent,PendingIntent.FLAG_UPDATE_CURRENT);views.setPendingIntentTemplate(R.id.widget_stack_view,templatePendingIntent); 将Collection View Widget绑定到Content ProviderCollection View Widget最强大的用途之一就是将Content Provider中的数据呈现到主屏幕上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class MyRemoteViewsFactory implements RemoteViewsFactory &#123; private Context context; private ContentResolver cr; private Cursor c; public MyRemoteViewsFactory(Context context) &#123; //获得对应程序上下文机器Content Resolver的引用 this.context = context; cr = context.getContextResolver(); &#125; public void onCreate() &#123; //执行一个查询来返回将要显示的数据的游标，任何辅助的查找或解码操作应在onDataSetChanged处理程序中完成 c = cr.query(MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,null,null,null,null); &#125; public void onDataSetChanged() &#123; // 任何辅助的查找、处理或解码可以在这里同步完成，只有这个方法完成后，Widget才回被更新 &#125; public int getCount() &#123; //返回游标中的项数 if (c != null) &#123; return c.getCount(); &#125; else &#123; return 0; &#125; &#125; public long getItemId(int index) &#123; //返回与特定项关联的唯一ID if (c != null) &#123; return c.getInt(c.getColumnIndex(MediaStore.Images.Thumbnails._ID)); &#125; else &#123; return index; &#125; &#125; public RemoteViews getViewAt(int index) &#123; //将游标移动到请求的行位置 c.moveToPosition(index); //从需要的项中提取数据 int idIdx = c.getColumnIndex(MediaStore.Images.Thumbnails._ID); String id = c.getString(idIdx); Uri uri = Uri.withAppendedPath(MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,&quot;&quot; + id); //使用合适的项布局创建一个新的RemoteViews对象 RemoteViews rv = new RemoteViews(context.getPackageName(),R.layout.my_media_widget_item_layout); //将从游标中提取的值赋给RemoteViews rv.setImageViewUri(R.id.widget_media_thumbnail,uri); //分配一个特定于项的填充Intent，用于填充在App Widget Provider中指定的Pending Intent模板。在这里，模板指定了一个ACTION_VIEW动作 Intent fillInIntent = new Intent(); fillInIntent.setData(uri); rv.setOnClickFillInIntent(R.id.widget_media_thumbnail,fillInIntent); return rv; &#125; public int getViewTypeCount() &#123; //要使用的不同View定义的数量 //对于Content Provider，这个值几乎总是1 return 1; &#125; public boolean hasStableIds() &#123; //Content Provider的ID应该是唯一并且永久的 return true; &#125; public void onDestroy() &#123; //关闭结果游标 c.close(); &#125; public RemoteViews getLoadingView() &#123; //使用默认的加载View return null; &#125;&#125; 刷新Collection View WidgetApp Widget Manager中包含的notifyAppWidgetViewDataChanged方法允许指定一个要更新的Widget ID(或ID数组)，以及该Widget中底层数据源已经发生变化的集合View的资源ID appWidgetManager.norifyAppWidgetViewDataChanged(appWidgetIds,R.id.widget_stack_view); 这将会导致相关的RemoteViewsFactory的onDataSetChanged处理程序执行，然后进行元数据调用，最后再重新创建每个View。 Media PalyerAndroid中的音频和视频的播放通常由MediaPlayer类进行处理。使用Media Player，我们能够播放存储在应用程序资源、本地文件、Content Provider或者来自网络URL的流式传输中的媒体。 准备音频播放为了使用Media Player播放音频内容，需要创建一个新的Media Player对象，并设置该音频的数据源。为此，可以使用静态create方法，并传入Activity的上下文以及下列音频源中的一种: 一个资源标识符(通常用于存储在res/raw文件夹中的音频文件) 一个本地文件的URI(使用file://模式) 一个在线音频资源的URI(URI格式) 一个本地Content Provider(它应该返回一个音频文件)的行的URI 1234567891011//从一个包资源加载音频资源MediaPlayer resourcePlayer = MediaPlayer.create(this,R.raw.my_audio);//从一个本地文件加载音频资源MediaPlayer filePlayer = MediaPlayer.create(this,Uri.parse(&quot;file:///sdcard/localfile.mp3&quot;));//从一个在线资源加载音频资源MediaPlayer urlPlayer = MediaPlayer.create(this,Uri.parse(&quot;http://site.com/audio/audio.mp3&quot;));//从一个Content Provider加载音频资源MediaPlayer contentPlayer = MediaPlayer.create(this,Settings.System.DEFAULT_RINGTONE_URI); 通过create方法返回的Media Player对象已经调用了prepare。也可以使用现有的MediaPlayer实例的setDataSource方法，必须在开始播放之前调用prepare方法。 123MediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.setDataSource(&quot;/sdcard/mydopetunes.mp3&quot;);mediaPlayer.perpare(); 准备视频播放视频内容的播放比音频播放稍微复杂一些。为了显示一个视频，首先必须为该视频指定一个Surface。 使用VideoView播放视频播放视频最简单的方法是使用VideoView类。VideoView包含了一个Surface，用于显示视频，以及封装和管理Media Player以控制视频的播放。 1234//分配本地文件以进行播放videoView.setVideoPath(&quot;/sdcard/mycatvideo.3gp&quot;);//分配一个远程视频流的URIvideoView.setVideoUri(myAwesomeStreamingSource); 当视频初始化完成后，可以使用start、stopPlayback、pause和seekTo方法控制播放，还可以使用setKeepScreenOn方法以应用一个屏幕Wake Lock。 1234567//配置VideoView并分配一个视频来源videoView.setKeepScreenOn(true);videoView.setVideoPath(&quot;/sdcard/mycatvideo.3gp&quot;);//附加一个Media ControllerMediaController mediaController = new MediaController(this);videoView.setMediaController(mediaController); 使用Media Player播放使用Media Player直接查看视频内容首先使用一个SurfaceView对象显示视频。SurfaceView类是SufaceHolder对象的包装器，后者是Surface的包装器，而Surface用于支持来自后台线程的可视化更新。SurfaceHolder是异步创建的，因此必须等到surfaceCreated处理程序被触发，然后再通过实现SurfaceHolder.Callback接口将返回的SurfaceHolder对象分配给Media Player。在创建和分配SurfaceHolder给Media Player之前，使用setDataSource方法来指定要播放的视频资源的路径、URI或Content Provider URI。在选择了媒体资源后，调用prepare来初始化Media Player，以准备进行播放。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class SurfaceViewVideoViewActivity extends Activity implements SurfaceHolder.Callback &#123; static final String TAG = &quot;SurfaceViewVideoViewActivity&quot;; private MediaPlayer mediaPlayer; public void surfaceCreated(SurfaceHolder holder) &#123; try &#123; //创建Surface后，将其作为显示表面，并分配和准备一个数据源 mediaPlayer.setDisplay(holder); mediaPlayer.setDataSource(&quot;/sdcard/test2.3gp&quot;); mediaPlayer.prepare(); &#125; catch (IllegalArgumentException e) &#123; Log.e(TAG,&quot;Illegal Argument Exception&quot;, e); &#125; catch (IllegalStateException e) &#123; Log.e(TAG,&quot;Illegal State Exception&quot;, e); &#125; catch (SecurityException e) &#123; Log.e(TAG,&quot;Security Exception&quot;, e); &#125; catch (IOException e) &#123; Log.e(TAG,&quot;IO Exception&quot;, e); &#125; &#125; public void surfaceDestroyed(SurfaceHolder holder) &#123; mediaPlayer.release(); &#125; public void surfaceChanged(SurfaceHolder holder,int format,int width,int height) &#123; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.surfaceviewvideoviewer); //创建一个新的Media Player mediaPlayer = new MediaPlayer(); //获得对SurfaceView的引用 final SurfaceView surfaceView = (SurfaceView) findViewById(R.id.surfaceView); //配置SurfaceView surfaceView.setKeepScreenOn(true); //配置SurfaceHolder并注册回调 SurfaceHolder holder = surfaceView.getHolder(); holder.addCallback(this); holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); holder.setFixedSize(400,300); //连接播放按钮 Button playButton = (Button) findViewById(R.id.buttonPlay); playButton.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; mediaPlayer.start(); &#125; &#125;); //连接暂停按钮 Button pauseButton = (Button) findViewById(R.id.buttonPause); pauseButton.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; mediaPlayer.pause(); &#125; &#125;); //添加跳过按钮按钮 Button skipButton = (Button) findViewById(R.id.buttonSkip); skipButton.setOnClickListener(new OnClickListener() &#123; public void onClick(View v) &#123; mediaPlayer.skip(); &#125; &#125;); &#125;&#125; MediaPlayer提供了getDuration方法以查找所播放媒体的长度，以及getCurrentPosition方法以查找当前的播放位置。可以使用seekTo方法跳转到媒体中的某个特定位置。为了保持一致的媒体控制体验，Android包含了一个MediaController。这是一个标准的控件，提供了常用的媒体控制按钮。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546MediaController mediaController = new MediaController(this);mediaController.setMediaPlayer(new MediaPlayerController() &#123; public boolean canPause() &#123; return true; &#125; public boolean canSeekBackward() &#123; return true; &#125; public boolean canSeekForward() &#123; return true; &#125; public int getBufferPercentage() &#123; return 0; &#125; public int getCurrentPosition() &#123; return mediaPlayer.getCurrentPosition(); &#125; public int getDuration() &#123; return mediaPlayer.getDuration(); &#125; public boolean isPlaying() &#123; return mediaPalyer.isPalying(); &#125; public void pause() &#123; mediaPlayer.pause(); &#125; public void seekTo(int pos) &#123; mediaPlayer.seekTo(pos); &#125; public void start() &#123; mediaPlayer.start(); &#125;&#125;)meidaController.setAnchorView(myView); //设置当MediaController可见时包含在哪个视图mediaController.show(); //显示mediaController.hide(); //隐藏 管理媒体播放输出MediaPlayer提供了一些方法以控制输出音量、锁定播放期间的屏幕亮度以及设置循环状态。 setVolum(0.5f,0.5f); 控制播放过程中的每个声道的音量。左右声道采用了一个0到1之间的标量浮点数值 setScreenOnWhilePlaying(true); 强制屏幕在视频播放期间不变暗 isLooping(); 确定当前的循环状态 setLooping(true); 指定所播放的媒体在播放完成时是否应当继续循环播放 响应Media播放控件。一些设备带有播放、停止、暂停、下一首和前一首媒体播放按键。用户按下这些按键时，系统会广播一个带有ACTION_MEDIA_BUTTON动作的Intent。 12345&lt;receiver android:name=&quot;.MediaControlReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MEDIA_BUTTON&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 这个BroadcastReceiver在接收到媒体按键被按下的动作时，会创建一个包含相同extra的新Intent，并把该Intent广播给播放音频的Activity 123456789101112public class MediaControlReceiver extends BroadcastReceiver &#123; public static final String ACTION_MEDIA_BUTTON = &quot;com.paad.ACTION_MEDIA_BUTTON&quot;; @Override public void onReceive(Context context,Intent intent) &#123; if (Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) &#123; Intent internalIntent = new Intent(ACTION_MEDIA_BUTTON); internalIntent.putExtra(intent.getExtras()); context.sendBroadcast(internalIntent); &#125; &#125;&#125; 被按下的媒体按键的代码存储在接收到的Intent的EXTRA_KEY_EVENT extra中 1234567891011121314151617181920212223242526272829303132public class ActivityMediaControlReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context,Intent intent) &#123; if (MediaControlReceiver.ACTION_MEDIA_BUTTON.equals(intent.getAction())) &#123; KeyEvent event = (KeyEvent) intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT); switch(event.getKeyCode()) &#123; case (KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) : if (mediaPlayer.isPlaying()) &#123; pause(); &#125; break; case (KeyEvent.KEYCODE_MEDIA_PLAY) : play(); break; case (KeyEvent.KEYCODE_MEDIA_PAUSE) : pause(); break; case (KeyEvent.KEYCODE_MEDIA_NEXT) : skip(); break; case (KeyEvent.KEYCODE_MEDIA_PREVIOUS) : previous(); break; case (KeyEvent.KEYCODE_MEDIA_STOP) : stop(); break; default: break; &#125; &#125; &#125;&#125; 如果应用程序希望在Activity不可见时仍在后台播放音频，让Media Player在Service保持运行，并使用Intent来控制媒体播放。给定的设备上可能安装了多个应用程序，每个应用程序都被配置为接收媒体按键按下动作，因此必须使用AudioManager的registerMediaButtonEventReceiver放阿飞将接收者注册为媒体按键按下动作的唯一处理程序。 12345678910//注册媒体按键事件Receiver来监听媒体按钮按下动作AudioManager am = (AudioManager)getSystemService(Context.AUDIO_SERVICE);ComponentName component = new ComponentName(this,MediaControlReceiver.class);am.registerMediaButtonEventReceiver(component);//注册一个本地Intent Receiver，用于接收在manifest文件中注册的Receiver，媒体按键按下动作。activityMediaControlReceiver = new ActivityMediaControlReceiver();IntentFilter filter = new IntentFilter(MediaControlReceiver.ACTION_MEDIA_BUTTON);registerReceiver(activityMediaControlReceiver,filter); 请求和管理音频焦点用户的设备上可能有多个媒体播放器，因此当另一个媒体应用程序获得焦点时，让你的应用程序暂停播放并交出媒体按键的控制权。 显示了一个请求音乐流永久占有音频焦点 123456AudioManager am = (AudioManager)getSystemService(Context.AUDIO_SERVICE);//请求音频焦点int result = am.requestAudioFocus(focusChangeListener,AudioManager.STREAM_MUSIC,AudioManager.AUDIOFOCUS_GAIN);if (result == AduioManager.AUDIOFOCUS_REQUEST_GRANTED) &#123; mediaPlayer.start();&#125; 音频焦点将依次分配给每个请求音频焦点的应用程序。这意味着如果另一个应用程序请求音频焦点，你的应用程序就会失去音频焦点。你在请求音频焦点时注册的Audio Focus Change Listener的onAudioFocusChange处理程序将会通知你焦点丢失的情况。 1234567891011121314151617181920212223242526private OnAudioFocusChangeListener focusChangeListener = new OnAudioFocusChangeListener() &#123; public void onAudioFocusChange(int focusChange) &#123; AudioManager am = (AudioManager) getSystemService(Context.AUDIO_SERVICE); switch(focusChange) &#123; case (AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK): //降低音量 mediaPlayer.setVolume(0.2f,0.2f); break; case (AudioManager.AUDIOFOCUS_LOSS_TRANSIENT): pause(); break; case (AudioManager.AUDIOFOCUS_LOSS): stop(); ComponentName component = new ComponentName(AudioPlayerActivity.this,MeidaControlReceiver.class); am.unregisterMediaButtonEventReceiver(component); break; case (AudioManager.AUDIOFOCUS_GAIN): //将音量恢复到正常大小，并且如果音频流已被暂停，则恢复音频流 mediaPlayer.setVolume(1f,1f); mediaPlayer.start(); break; default: break; &#125; &#125;&#125; 完成音频播放后，可以选择放弃音频焦点 am.abandonAudioFocus(focusChangeListener); 如果当前的输出流在入耳式耳机上播放，那么拔出耳机时，系统会自动将输出切换到设备的扬声器。这种情况下，暂停音频输出或者减小音量是一个很好的做法。 12345678private class NoisyAudioStreamReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context,Intent intent) &#123; if(AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction()))&#123; pause(); &#125; &#125;&#125; Remote Control Client应用程序可以向能够显示元数据、图片和媒体传输控制按键的远程控件提供数据，并响应这些远程控件。 123456789AudioManager am = (AudioManager)getSystemService(Context.AUDIO_SERVICE);//创建一个将会广播媒体按键按下动作的Pending Intent。将目标组件设为你的Broadcast ReceiverIntent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);ComponentName component = new ComponentName(this,MediaControlReceiver.class);mediaButtonIntent.setComponent(component);PendingIntent mediaPendingIntent = PendingIntent.getBroadcast(getApplicationContext(),0,meidaButtonIntent,0);//使用PendingIntent创建一个新的Remote Control Client，并把它注册到Audio Manager中myRemoteControlClient = new RemoteControlClient(mediaPendingInent);am.registerRemoteControlClient(myRemoteControlClient); 操纵原始音频使用AudioTrack和AudioRecord类可以直接从音频输入硬件录制音频，以及直接将PCM音频缓冲区中的音频流输出到音频硬件来进行播放。使用Audio Track流式传输时，可以接近实时地处理和播放传入的音频，这就允许你操纵传入或传出的音频，以及对原始音频进行信号处理。 使用AudioRecord录制声音12345678910111213141516171819202122232425262728293031323334353637int frequency = 11025;int channelConfiguration = AudioFromat.CHANNEL_CONFIGURATION_MONO;int audioEncoding = AudioFromat.ENCODING_PCM_16BIT;File file = new File(Environment.getExternalStorageDirectory(),&quot;raw.pcm&quot;);//创建新文件try &#123; file.createNewFile();&#125; catch (IOException e) &#123; Log.d(TAG,&quot;IO Exception&quot;, e);&#125;try &#123; OutputStream os = new FileOutputStream(file); BufferedOutputStream bos = new BufferedOutputStream(os); DataOutputStream dos = new DataOutputStream(bos); int bufferSize = AudioRecord.getMinBufferSize(frequency,channelConfiguration,audioEncoding); short[] buffer = new short[bufferSize]; //创建一个新的AudioRecord对象来录制音频 AudioRecord audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC,frequency,channelConfiguration,audioEncoding,bufferSize); audioRecord.startRecording(); while(isRecording) &#123; int bufferReadResult = audioRecord.read(buffer,0,bufferSize); for (int i = 0;i &lt; bufferReadResult;i++) &#123; dos.writeShort(buffer[i]); &#125; &#125; audioRecord.stop(); dos.close();&#125; catcg (Throwable t) &#123; Log.d(TAG,&quot;An error occurred during recording&quot;,t);&#125; 使用AudioTrack播放音频使用AudioTrack类可以将原始音频直接播放到硬件缓冲区中。 12345678910111213141516171819202122232425262728293031int frequency = 11025 / 2;int channelConfiguration = AudioFromat.CHANNEL_CONFIGURATION_MONO;int audioEncoding = AudioFormat.ENCODING_PCM_16BIT;File file = new File(Environment.getExternalStorageDirectory(),&quot;raw.pom&quot;);//用于存储音轨的short数组int audioLength = (int)(file.length() / 2);short[] audio = new short[audioLength];try &#123; InputStream is = new FileInputStream(file); BufferedInputStream bis = new BufferedInputStream(is); DataInputStream dis = new DataInputStream(bis); int i = 0; while(dis.available() &gt; 0) &#123; audio[i] = dis.readShort(); i++; &#125; //关闭输入流 dis.close(); //创建和播放新的AudioTrack对象 AudioTrack audioTrack = new AudioTrack(AudioManager.STREAM_MUSIC,frequency,channelConfiguration,audioEncoding,audioLength,AudioTrack.MODE_STREAM); audioTrack.play(); audioTrack.write(audio,0,audioLength);&#125; catch (Throable t) &#123; Log.d(TAG,&quot;An error occurred during playback&quot;,t);&#125; 使用Sound Pool当应用程序需要低音频延迟并且将同时播放多个音频流时，可以使用SoundPool类来管理音频。创建一个SoundPool会预加载应用程序试用的音轨，并优化它们的资源管理。创建SoundPool时，可以指定要播放的最大并发流数。当达到这个值时，SoundPool就会自动停止池内最老的、优先级最低的流，从而将音频混合的影响降到最低。 123456int maxStreams = 10;SoundPool sp = new SoundPool(maxStreams,AudioManager.STREAM_MUSIC,0);int strack1 = sp.load(R.raw.track1,0);int strack2 = sp.load(R.raw.track2,0);int strack3 = sp.load(R.raw.track3,0); 使用音效可以修改效果设置和参数，以改变在应用程序内输出的音频的效果。 Equalizer 可以修改音频输出的频率响应。使用setBandLevel方法可以为特定的频带指定一个增益值。 Virtualizer 使音频的立体声效果更强。它的实现会随输出的设备的配置而发生变化。使用setStrength方法可以将音效的强度设置为0 - 1000 BassBoost 增强音频输出的低音音频。使用setStrength方法可以将音效的强度设置为0 - 1000 PresetReverb 允许指定多个混声预设值之一。 EnvironmentalIReverb 允许通过控制音频输出来模拟不同环境的效果。 摄像头使用Intent拍摄照片startActivityForResult(new Intent(MediaStore.ACTION_IMAGE_CAPTURE), TAKE_PICTURE); 这将启动一个Camera应用程序来拍摄照片，不需要你重写原生Camera应用程序，就可以为用户提供全套的摄像头功能。用户对拍摄的照片感到满意后，该照片就会通过onActivityResult处理程序收到的Intent返回给应用程序。默认情况下，拍摄的照片将作为一个缩略图返回。 123456789101112131415161718192021222324252627282930313233343536373839404142//创建输出文件File file = new File(Environment.getExternalStorageDirectory(),&quot;test.jpg&quot;);Uri outputFileUri = Uri.fromFile(file);//生成IntentIntent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);intent.putExtra(MediaStore.EXTRA_OUTPUT,outputFileUri);//启动摄像头应用程序startActivityForResult(intent,TAKE_PICTURE);@Overrideprotected void onActivityResult(int requestCode, int resultCode,Intent data) &#123; if (requestCode == TAKE_PICTURE) &#123; //检查结果是否包含缩略图 if (data != null) &#123; if (data.hasExtra(&quot;data&quot;)) &#123; Bitmap thumbnail = data.getParcelableExtra(&quot;data&quot;); imageView.setImageBitmap(thumbnail); &#125; &#125; else &#123; //如果没有缩略图数据，则说明图像存储在目标输出URI中 int width = imgaeView.getWidth(); int height = imageView.getHeight(); BitmapFactory.Options factoryOptions = new BitmapFactory.Options(); factoryOptions.inJustDecodeBounds = true; BitmapFactory.decodeFile(outputFileUri.getPath(),factoryOptions); int imageWidth = factoryOptions.outWidth; int imageHeight = factoryOptions.outHeight; //确定将图像缩小多少 int scaleFactor = Math.min(imageWidth / width,imageHeight / height); //将图像文件解码为图像大小以填充视图 factoryOptions.inJustDecodeBounds = false; factoryOptions.inSampleSize = scaleFactor; factoryOptions.inPurgeable = true; Bitmap bitmap = BitmapFactory.decodeFile(outputFileUri.getPath(), factoryOptions); imageView.setImageBitmap(bitmap); &#125; &#125;&#125; 直接控制摄像头为了直接访问摄像头硬件，添加权限&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt; 12Camera camera = Camera.open();camera.release(); 摄像头属性使用Camera对象的getParameters方法可以得到Camera.Parameters对象，然后可以使用该对象存储摄像头设置，可以获得摄像头的许多属性和当前对焦的场景。 SceneMode 使用一个SCENEMODE* 静态常量返回或设置所拍摄的场景的类型。每个场景模式都为特定的场景类型(聚会、海滩、日落等)优化了摄像头参数的配置。 FlashMode 使用一个FLASHMODE*静态常量返回或设置当前的闪光模式(打开、关闭、红眼消减、闪光灯) WhiteBalance 使用一个WHITEBALANCE*静态常量返回或设置白平衡校正来校正场景。 AutoWhiteBalanceLock 当使用自动白平衡时，启用自动白平衡锁会暂停颜色校正算法，从而确保连续拍摄的多张照片使用相同的颜色平衡设置。当拍摄全景照片或者为高动态光照渲染图像使用包围曝光时，这种做法特别有用，使用isAutoWhiteBalanceLockSupported方法可以确认设备是否支持这种功能。 ColorEffect 使用一个EFFECT_*静态常量返回或设置应用到图像的特殊颜色效果。使用getSupportedColorEffects方法可以找出可用的颜色效果 FocusMode 使用一个FOCUS_MODE_*静态常量返回或设置摄像头尝试对焦的方式。使用getSupportedFocusModes方法可以找出可用的模式 Antibanding 使用一个ANTIBANDING_*静态常量返回或设置用来降低条带效果的屏幕刷新频率。使用getSupportedAntibanding方法可以找出可用的频率 使用CameraParameters来读取或指定图像、缩略图和摄像头预览的大小、质量和格式参数 JPEG和缩略图质量 使用setJpegQuality和setJpegThumbnailQuality方法，并传入0到100之间的整型数值 图像、预览和缩略图大小 分别使用setPictureSize、setPreviewSize和setJpegThumbnailSize参数指定图像、预览和缩略图的高度和宽度。 图像和预览像素格式 使用PixelFormat类中的一个静态常量调用setPictureFormat和setPreviewFormat可以设置图像的格式 预览帧速率 setPreviewFpsRange方法可以用来指定预览的首选帧率范围。使用getSupportedPreviewFpsRange方法可以找出所支持的最低和最高帧率 使用摄像头预览在实现自己的摄像头时，需要显示摄像头捕获的内容的一个预览，以便用户可以选择拍摄什么样的照片。显示摄像头的流式传输视频还意味着我们能够将实时视频融入到应用程序中，例如实现增强现实。摄像头预览是使用SurfaceHoder显示的，所以要在应用程序中查看实时摄像头流，必须在UI层次中包含一个Surface View，需要实现一个SurfaceHolder.Callback来监听有效表面的构建，然后该表面传递给Camera对象的setPreviewDisplay方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CameraActivity extends Activity implements SurfaceHolder.Callback &#123; private static final String TAG = &quot;CameraActivity&quot;; private Camera camera; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); SurfaceView surface = (SurfaceView)findViewById(R.id.surfaceView); SurfaceHolder holder = surface.getHolder(); holder.addCallback(this); holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); holder.setFixedSize(400,300); &#125; public void surfaceCreated(SurfaceHolder holder) &#123; try &#123; camera.setPreviewDisplay(holder); camera.startPreview(); //必要时在预览上进行绘制 &#125; catch (IOException e) &#123; Log.d (TAG,&quot;IO Exception&quot;, e); &#125; &#125; public void surfaceDestroyed(SurfaceHolder holder) &#123; camera.stopPreview(); &#125; public void surfaceChanged(SurfaceHolder holder,int format,int width,int height) &#123; &#125; @Override protected void onPause() &#123; super.onPause(); camera.release(); &#125; @Override protected void onResume() &#123; super.onResume(); camera = Camera.open(); &#125;&#125; 还可以分配一个PreviewCallback，使其在每个预览中触发，以便可以实时操纵或者分析每个预览帧。需要调用Camera对象的setPreviewCallback方法，并传入一个重写了onPreviewFrame方法的新的PreviewCallback实现。 1234567891011camera.setPreviewCallback(new PreviewCallback() &#123; public void onPreviewFrame(byte[] data,Camera camera) &#123; int quality = 60; Size previewSize = camera.getParameters().getPreviewSize(); YuvImage image = new YuvImage(data,ImageFormat.NV21,previewSize.width,previewSize.height,null); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); image.compressToJpeg (new Rect(0 ,0,previewSize.width,previewSize.height),quality,outputStream); //对预览图像执行一些操作 &#125;&#125;) 面部检测和面部特征在拍摄以人为主的照片时调整对焦区域、测光区域和确定白平衡，但是它们也可以用来制作一些创造性的效果。 为了确认设备支持面部检测功能，需要使用Camera对象的getMaxNumDetectedFaces方法int facesDetectable = camera.getParameters().getMaxNumDetectedFaces();该方法返回设备的摄像头能够检测的最大人脸数目。如果返回值为0，则说明设备不支持面部检测。 在开始使用摄像头检测人脸之前，需要分配一个新的FaceDetectionListener，使其重写onFaceDetection方法。你将得到一个Face对象的数组，每个Face对相对应在场景中检测到一个人脸。 12345678910111213141516171819202122camera.setFaceDetectionListener(new FaceDetectionListener() &#123; public void onFaceDetection(Face[] faces,Camera camera) &#123; if (faces.length &gt; 0) &#123; Log.d(&quot;FaceDetection&quot;,&quot;face detected:&quot; + faces.length + &quot; Face 1 Location X:&quot; + faces[0].rect.centerX() + “Y: ” + faces[0].rect.centerY()); &#125; &#125;&#125;)public void surfaceCreated(SurfaceHolder holder) &#123; try &#123; camera.setPreviewDisplay(holder); camera.startPreview(); camera.startFaceDetection(); &#125; catch (IOException e) &#123; Log.d(TAG, &quot;IO Exception&quot;, e); &#125;&#125;public void surfaceDestroyed(SurfaceHolder holder) &#123; camera.stopFaceDetection(); camera.stopPreview();&#125; 拍摄照片在配置好摄像头的设置并看到预览后，就可以拍摄照片了。调用Camera对象的takePicture，并传入一个ShutterCallback和两个PictureCallback实现(一个用于RAW图像，一个用于JPEG编码的图像)。每个图像回调都会收到一个以相应格式表示图像的字节数组，而快门回调则在快门关闭后立即触发。 1234567891011121314151617181920212223242526272829303132private void takePicture() &#123; camera.takePicture(shutterCallback,rawCallback,jpegCallback);&#125;ShutterCallback shutterCallback = new ShutterCallback() &#123; public void onShutter() &#123; //快门关闭时执行一些操作 &#125;&#125;PictureCallback rawCallback = new PictureCallback() &#123; public void onPictureTaken(byte[] data,Camera camera) &#123; //对图像的原始数据做一些处理 &#125;&#125;PictureCallback jpegCallback = new PictureCallback() &#123; public void onPictureTaken(byte[] data, Camera camera) &#123; //将图像的JPEG数据保存到SD卡 FileOutputStream outStream = null; try &#123; String path = Environment.getExternalStorageDirectory() + &quot;\test.jpg&quot;; outStream = new FileOutputStream(path); outStream.write(data); outStream.close(); &#125; catch (FileNotFoundException e) &#123; Log.e(TAG,&quot;File Not Found&quot;,e); &#125; catch (IOException e) &#123; Log.e(TAG, &quot;IO Exception&quot;, e); &#125; &#125;&#125; 读取并写入JPEG EXIF图像详细信息ExifInterface类为读取并修改存储在JPEG文件中的EXIF(可交换图像文件格式)数据提供了一种机制。通过将目标JPEG图像的完整文件名传入ExifInterface构造函数来创建一个新的ExifInterface实例。EXIF数据用于为照片存储各种不同的元数据，包括拍摄日期和时间、摄像头设置(如制造商和型号)、图像设置(如光圈和快门速度)以及图像描述和位置。为了读取EXIF属性，需要调用ExifInterface对象的getAttribute方法，并传入将要读取的属性名。 123456789101112File file = new File(Environment.getExternalStorageDirectory(),&quot;test.jpg&quot;);try &#123; ExifInterface exif = new ExifInterface(file.getCanonicalPath()); //读取摄像头模型和位置属性 String model = exif.getAttribute(ExifInterface.TAG_MODEL); Log.d(TAG,&quot;Model: &quot; + model); //设置摄像头的品牌 exif.setAttribute(ExifInterface.TAG_MAKE, &quot;My Phone&quot;);&#125; catch (IOException e) &#123; Log.e(TAG,&quot;IO Exception&quot;, e);&#125; 录制视频使用Intent录制视频使用此Intent启动新Activity将会启动本机视频录制器，允许用户开始、停止、浏览并重新拍摄视频。已录制视频的URI作为返回Intent的数据参数提供给Activity。 MediaStore.EXTRA_OUTPUT 默认，由视频捕获操作录制的视频将存储在默认媒体库中。 MediaStore.EXTRA_VIDEO_QUALITY 视频捕获操作允许使用一个整型值指定某个图像的质量。 MeidaStore.EXTRA_DURATION_LIMIT 所录制视频的最大长度，单位为秒。 123456789101112131415161718private static final int RECORD_VIDEO = 0;private void startRecording() &#123; //生成Intent Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE); //启动摄像头应用程序 startActivityForResult(intent,RECORD_VIDEO);&#125;@Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent intent) &#123; if (requestCode == RECORD_VIDEO) &#123; VideoView videoView = (VideoView)findViewById(R.id.videoView); videoView.setVideoURI(data.getData()); videoView.start(); &#125;&#125; 使用MediaRecorder录制视频可以使用MediaRecorder类录制音频和视频文件，然后在自己的应用程序中使用它们，或者把它们添加到媒体库中。需要添加权限 123&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.RECORD_VIDEO&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt; 配置Video Recorder首先解锁摄像头，并使用setCamera方法将其分配给Media Recorder。setAudioSource和setVideoSource方法可以指定MediaRecorder.AudioSource. 或者Media Recorder.VideoSource. 静态常量，它们分别定义了音频和视频源。 1234567891011121314151617181920212223242526272829303132//解锁摄像头以允许Meida Recorder拥有它camera.unlock();//将摄像头分配给Media RecordermediaRecorder.setCamera(camera);//配置输入源mediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);//设置录制配置文件CamcorderProfile profile = null;if (CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_1080P)) &#123; profile = CamcorderProfile.get(CamcorderProfile.QUALITY_1080P);&#125; else if (CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_720P)) &#123; profile = CamcorderProfile.get(CamcorderProfile.QUALITY_720P);&#125; else if (CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_480P)) &#123; profile = CamcorderProfile.get(CamcorderProfile.QUALITY_480P);&#125; else if (CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_HIGH)) &#123; profile = CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH);&#125;if (profile != null) &#123; mediaRecorder.setProfile(profile);&#125;//指定输出文件mediaRecorder.setOutputFile(&quot;/sdcard/myvideorecording.mp4&quot;);//准备录制mediaRecorder.prepare(); 缩短Media Recorder的启动时间来提高效率。当Activity只是用于录制音频/视频而不是静态图片，可以使用Camera.Parameters.setRecordHint方法告诉摄像头你只想录制音频/视频 123Camera.Parameters parameters = camera.getParameters();parameters.setRecordingHint(true);camera.setParameters(parameters); 预览视频流当录制视频时，实时显示传入所录制视频的预览是一种好的做法。与摄像头预览一样，可以使用MediaRecorder对象的setPreviewDisplay方法分配一个Surface来显示视频流。 123mediaRecorder.setPreviewDisplay(holder.getSurface());mediaRecorder.prepare(); 控制录制12345mediaRecorder.stop();//重置和释放Meida RecordermediaRecorder.reset();mediaRecorder.release();camera.lock(); 可以使用setVideoStabilization方法修改摄像头参数，并不是所有的摄像头硬件都支持影像稳定，所以一定要用isVideoStabilizationSupported方法进行检查 12345Camera.Parameters parameters = camera.getParameters();if (parameters.isVideoStabilizationSupported()) &#123; parameters.setVideoStabilization(true);&#125;camera.setParameters(parameters); 创建缩时视频12每隔30秒捕获一副图片mediaRecorder.setCaptureRate(0.03); 使用媒体效果使用GPU和OpenGL纹理对视频内容应用大量实时的视觉效果。可以将媒体效果应用到位图、视频或实时的摄像头预览，只要源图像绑定到一个GL_TEXTURE2D纹理图片，并且包含至少一个mipmap级别即可。一般来说，要对图片或视频帧应用一种效果，需要使用OPenGL ES2.0上下文中的EffectContext.createWithCurrentContext创建一个新的EffectContext.媒体效果是使用EffectFactory创建的，而EffectFactory可以通过调用EffectContext的getFactory方法创建。要创建特定的效果，可以调用createEffect方法，并传入一个EffectFactory.EFFECT*常量，每种效果支持不同的参数，可以调用setParameter 并传入要更改的设置的名称和要应用的值来进行配置。 向媒体库中添加新媒体使用媒体扫描仪插入媒体如果已经录制了任何一种媒体，MediaScannerConnection类提供了一个scanFile方法，作为将该媒体添加到媒体库中的一种简单方法，而不需要为媒体库Content Provider创建完整记录。在使用scanFile方法开始扫描文件之前，必须调用connect方法并等待它完成与媒体扫描仪的连接。这个调用是异步的，因此需要实现一个MediaScannerConnectionClient以便在连接建立时进行通知。 123456789101112131415161718private void mediaScan(final String filePath) &#123; MediaScannerConnectionClient mediaScannerClient = new MediaScannerConnectionClient() &#123; private MediaScannerConnection msc = null; msc = new MediaScannerConnection(VideoCameraActivity.this,this); msc.connect(); public void onMediaScannerConnected() &#123; //可以指定一个MINE类型，或者让Media Scanner根据文件名自己假定一种类型 String memeType = null; msc.scanFile(filePath,mimeType); &#125; public void onScanCompleted(String path,Uri uri) &#123; msc.disconnect(); Log.d(TAG,&quot;File Added at: &quot; + uri.toString()); &#125; &#125;;&#125; 手动插入媒体通过创建一个新的ContentValues对象并手动将其插入到适当的媒体库Content Provider中，可以将新媒体添加到媒体库中，而不需要依赖媒体扫描仪。 123456789ContentValues content = new ContentValues(3);content.put(Audio.AudioColumns.TITLE,&quot;TheSoundandtheFury&quot;);content.put(Audio.AudioColumns.DATE_ADDED,System.currentTimeMillis() / 1000);content.put(Audio.Media.MIME_TYPE,&quot;audio/amr&quot;);content.put(MediaStore.Audio.Media.DATA,&quot;/sdcard/myoutputfile.mp4&quot;);ContentResolver resolver = getContentResolver();Uri uri = resolver.insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,content);sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,uri)); 蓝牙蓝牙是一种用于短距离、低带宽点对点通信的通信协议。使用蓝牙API可以搜索并连接到一定范围之内的其他设备。 管理本地蓝牙设备适配器通过BluetoothAdapter 类来控制本地蓝牙设备，该类代表运行应用程序的Android设备。 12&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt; //读取任何一种本地Bluetooth Adapter属性、启动发现过程或者找到绑定的设备&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; //修改任何一种本地设备属性 1234567BluetoothAdater bluetooth = BluetoothAdapter.getDefaultAdapter();if (bluetooth.isEnabled()) &#123; String address = bluetooth.getAddress(); String name = bluetooth.getName();&#125;bluetooth.setName(&quot;BlackFang&quot;); 为了查找关于当前Bluetooth Adapter状态对的更详细描述，可以使用getState方法 STATE_TURNING_ON STATE_ON STATE_TURNING_OFF STATE_OFF 启用蓝牙 12345678910111213141516171819private static final int ENABLE_BLUETOOTH = 1;private void initBluetooth() &#123; if (!bluetooth.isEnabled()) &#123; //如果蓝牙未启用，提示用户打开它 Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(intent, ENABLE_BLUETOOTH); &#125; else &#123; //蓝牙已启用，初始化其UI initBluetoothUI(); &#125;&#125;protected void onActivityResult(int requestCode,int resultCode,Intent data) &#123; if (requestCode == ENABLE_BLUETOOTH) &#123; if (resultCode == RESULT_OK) &#123; initBluetoothUI(); &#125; &#125;&#125; 启用和禁用Bluetooth Adapter是比较耗时的异步操作。应用程序不应轮询Bluetooth Adapter，而是应当注册一个Broadcast Receiver用于监听ACTION_STATE_CHANGED。Broadcast Receiver包含两个extra，EXTRA_STATE和EXTRA_PREVIOUS_STATE，它们分别指示了当前和先前的Bluetooth Adapter状态。 12345678910111213141516171819202122232425262728293031BroadcastReceiver bluetoothState = new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; String prevStateExtra = BluetoothAdapter.EXTRA_PREVIOUS_STATE; String stateExtra = BluetoothAdapter.EXTRA_STATE; int state = intent.getIntExtra(stateExtra, -1); int previousState = intent.getIntExtra(prevStateExtra, -1); String tt = &quot;&quot;; switch(state) &#123; case (BluetoothAdapter.STATE_TURNING_ON) : tt = &quot;Bluetooth turning on&quot;; break; case (BluetoothAdapter.STATE_ON) : tt = &quot;Bluetooth on&quot;; break; case (BluetoothAdapter.STATE_TURNING_OFF) : tt = &quot;Bluetooth turning off&quot;; break; case (BluetoothAdapter.STATE_OFF) : tt = &quot;Bluetooth off&quot;; break; default: break; &#125; Log.d(TAG,tt); &#125;&#125;;String actionStateChanged = BluetoothAdapter.ACTION_STATE_CHANGED;registerReceiver(bluetoothState,new IntentFilter(actionStateChanged)); 可发现性和远程设备发现两个设备相互查找以进行连接的过程叫做发现。 管理设备的可发现性为了使远程Android设备能够在发现扫描中找到你的本地Bluetooth Adapter，需要确保它是可发现的。可以通过调用getScanMode来找出它的扫描模式 SCAN_MODE_CONNECTABLE_DISCOVERABLE 启用查询扫描和页面扫描，意味着该设备可被执行发现扫描的蓝牙设备发现 SCAN_MODE_CONNECTABLE 启用页面扫描但是禁用查询扫描。这意味着先前连接并绑定到本地设备的设备可以在发现过程中找到，但找不到新设备。 SCAN_MODE_NONE 可发现性被关闭。在发现过程中没有一个远程设备能够找到本地Bluetooth Adapter。 12345678910111213141516171819202122startActivityForResult (new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE),DISCOVETY_REQUEST);@Overrideprotected void onActivityResult(int requestCode,int resultCode,Intent data) &#123; if (requestCode == DISCOVETY_REQUEST) &#123; if (resultCode == RESULT_CANCELED) &#123; Log.d(TAG,&quot;Discovery canceled by user&quot;); &#125; &#125;&#125;registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; String prevScanMode = BluetoothAdapter.EXTRA_PREVIOUS_SCAN_MODE; String scanMode = BluetoothAdapter.EXTRA_SCAN_MODE; int currentScanMode = intent.getIntExtra(scanMode, -1); int prevMode = intent.getIntExtra(prevScanMode, -1); Log.d (TAG, &quot;Scan Mode: &quot; + currentScanMode + &quot;. Previous:&quot; + prevMode); &#125;&#125;,new IntentFilter(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED)); 发现远程设备通过使用isDiscovering方法可以检查本地Bluetooth Adapter是否正在执行一次发现扫描。启动发现，调用startDiscovery。取消发现，调用cancelDiscovery。Android使用Broadcast Intent来通知发现过程的启动和结束以及在扫描过程中发现的远程设备。 12345678910111213141516171819202122BroadcastReceiver discoveryMonitor = new BroadcastReceiver() &#123; String dStarted = BluetoothAdapter.ACTION_DISCOVER_STARTED; String dFinished = BluetoothAdapter.ACTION_DISCOVERY_FINISHED; @Override public void onReceive(Context context,Intent intent) &#123; if (dStarted.equals(intent.getAction())) &#123; //启动发现过程 Log.d(TAG,&quot;Discovery Started...&quot;); &#125; else if (dFinished.equals(intent.getAction())) &#123; //发现过程完成 Log.d(TAG,&quot;Discovery Complete.&quot;); &#125; String remoteDeviceName = intent.getStringExtra(BluetoothDevice.EXTRA_NAME); BluetoothDevice remoteDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); deviceList.add(remoteDevice); &#125;&#125;;registerReceiver(discoverMonitor,new IntentFilter(dStarted));registerReceiver(discoverMonitor,new IntentFilter(dFinished)); 蓝牙通信 BluetoothServerSocket 用于建立一个监听套接字以启动设备之间的链路。为建立“握手”，需要将其中一台设备充当服务器以监听和接受传入的连接请求。 BluetoothSocket 用于创建一个新的客户端来连接到正在监听的BluetoothServerSocket。一旦连接之后，就在服务器和客户端上使用Bluetooth Sockets来传输数据流。 为使Bluetooth Adapter作为服务器，需要调用其listenUsingRfcommWithServiceRecord方法来监听传入的连接请求，并传入用来标识服务器的名称和以UUID。该方法将会返回一个BluetoothServerSocket对象。为了开始监听连接，需要调用该ServerSocket的accept的方法，并可以选择传入一个超时时间。ServerSocket将会保持阻塞，直到具有匹配UUID的远程BluetoothSocket客户端尝试进行连接。 12345678910111213141516171819202122232425262728private BluetoothSocket transferSocket;private UUID startServerSocket(BlurtoothAdapter adapter) &#123; UUID uuid = UUID.fromString(&quot;ssss&quot;); String name = &quot;bluetoothserver&quot;; try &#123; final BluetoothServerSocket btserver = bluetooth.listenUsingRfcommWithServiceRecord(name,uuid); Thread acceptThread = new Thread(new Runnable() 「 public void run() &#123; try &#123; //在客户端连接建立以前保持阻塞 BluetoothSocket serverSocket = btserver.accept(); //开始监听消息 listenForMessages(serverSocket); //添加对用来发送消息的套接字的引用 transferSocket = serverSocket; &#125; catch (IOException e) &#123; Log.e(&quot;BLUETOOTH&quot;,&quot;Server connection IO Exception&quot;,e); &#125; &#125; &#125;); acceptThread.start(); &#125; catch(IOException e) &#123; Log.e(&quot;BLUETOOTH&quot;,&quot;Socket listener IO Exception&quot;,e) &#125; return uuid;&#125; 选择远程蓝牙设备进行通信可以在客户端设备上使用BluetoothSocket类，在应用程序中启动与长在监听的Server的通信信道。 蓝牙设备连接需求 远程设备必须是可发现的 远程设备必须使用一个Bluetooth Server Socket接受连接 本地和远程设备必须经过配对。如果设备没有配对，那么当启动连接请求时将提示用户进行配对。 可以使用本地BluetoothAdapter的getRemoteDevice，并指定你想要连接到的远程蓝牙设备的硬件地址。为了查找当前已配对的设备集合，可以调用本地Bluetooth Adapter的getBondedDevices方法。可以通过查询所返回的集合以发现目标蓝牙设备是否与本地BluetoothAdapter进行配对。 12345final BluetoothDevice knownDevice = bluetooth.getRemoteDevice(&quot;01:23:77:35:2F:AA&quot;);Set&lt;BluetoothDevice&gt; bondedDevices = bluetooth.getBondedDevices();if (bondedDevices.contains(knownDevice)) &#123; //目标设备已经与本地设备绑定/配对&#125; 打开一个客户端BluetoothSocket连接调用connect方法，使用所返回的Bluetooth Socket来启动连接 12345678910111213141516private void connectToServerSocket(BluetoothDevice device,UUID uuid) &#123; try &#123; BluetoothSocket clientSocket = device.createRfcommSocketToServiceRecord(uuid); //阻塞，直到服务器接受连接 clientSocket.connect(); //开始监听消息 listenForMessages(clientSocket); //添加对用于发送消息的套接字的引用 transferSocket = clientSocket; &#125; catch(IOException e) &#123; Log.e(&quot;BLUETOOTH&quot;,&quot;Bluetooth client I/O Wxception&quot;,e); &#125;&#125; 使用Bluetooth Socket传输数据一旦建立连接后，客户端和服务端设备上都会有Bluetooth Socket。两者之间没有显著区别。通过InputStram和OutputStream对象来处理。 123456789101112131415161718192021222324252627282930313233343536373839404142private void sendMessage(BluetootnSocket socket,String message) &#123; OutputStream outStream; try &#123; outStream = socket.getOutputStream(); byte[] byteArray = (message + &quot;&quot;).getBytes(); byteArray[byteArray.length - 1] = 0; outStream.write(byteArray); &#125; catch(IOException e) &#123; Log.e(TAG,&quot;Message send failed&quot;,e); &#125;&#125;private boolean listening = false;private void listenForMessages(BluetoothSocket socket,StringBuilder incoming) &#123; listening = true; int buggerSize = 1024; byte[] buffer = new byte[bufferSize]; try &#123; InputStream instream = socket.getInputStream(); int bytesRead = -1; while (listening) &#123; bytesRead = instream.read(buffer); if (bytesRead != -1) &#123; String result = &quot;&quot;; while((bytesRead == bufferSize) &amp;&amp; (buffer[bufferSize - 1] ！= 0)) &#123; result = result + new String(buffer,0,bytesRead - 1); bytesRead = instream.read(buffer); &#125; result = result + new String(buffer,0,bytesRead - 1); incoming.qppend(result); &#125; socket.close(); &#125; &#125; catch (IOException e) &#123; Log.e(TAG,&quot;Message received failed.&quot;,e); &#125; finally &#123; &#125;&#125; 管理网络Android 网络主要是通过ConnectivityManager来处理的，该服务使你可以监视连接状态、设置自己的首选网络连接以及管理连接失败转接。 Connectivity Manager用于监视网络连接状态、配置故障转移设置以及控制网络无线电。需要权限。 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot;/&gt; 查找和监视网络连接12345ConnectivityManager connectivity = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);//获得活动网络信息NetworkInfo activeNetwork = connectivity.getActiveNetworkInfo();boolean isConnected = ((activeNetwork != null) &amp;&amp; (activeNetwork.isConnectedOrConnecting()));boolean isWiFi = activeNetwork.getType() == ConnectivityManager.TYPE_WIFI; 通过查询连接状态和网络类型，可以根据可用的带宽暂时性地禁用下载和更新，修改刷新频率，或者推迟大文件的下载。 为了监视网络连接，可以创建一个Broadcast Receiver来监听ConnectivityManager.CONNECTIVITY_ACTION 12345&lt;receiver android:name=&quot;.ConnectivityChangedReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 这些Intent包含了一些extra，它们提供了关于连接状态变化的额外详细信息。可以使用ConnectivityManager类中可用的静态常量访问每个extra。 EXTRA_NO_CONNECTIVITY 布尔类型，当设备未连接到任何网络时返回true。当有连接时，使用getActiveNetworkInfo来获得新连接状态的更多详细信息并根据情况修改下载计划。 管理WiFiWifiManager代表Android Wi-Fi连接服务。它能够配置Wi-Fi网络连接，管理当前的Wi-Fi连接、扫描接入点以及监视Wi-Fi连接的变化。添加权限 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;/&gt; 123456WifiManager wifi = (WifiManager)getSystemService(Context.WIFI_SERVICE);if (!wifi.isWifiEnabled()) &#123; if (wifi.getWifiState() != WifiManager.WIFI_STATE_ENABLING) &#123; wifi.setWifiEnabled(true); &#125;&#125; 监视Wi-Fi连接大多数情况下，使用ConnectivityManager监视Wi-Fi连接的变化是一种最佳实践。不过，每当Wi-Fi 网络连接状态发生变化时，Wi-Fi Manager会广播Intent，它会使用在WifiManager类中定义的常量。 WIFI_STATE_CHANGED_ACTION 指示Wi-Fi硬件状态已经发生变化，包括enabling、enabled、disabling、disabled和unknown几种状态。 EXTRA_WIFI_STATE 新的Wi-Fi状态 EXTRA_PREVIOUS_STATE 前一次的Wi-Fi状态。 SUPPLICANT_CONNECTION_CHANGE_ACTION 每当与活动的请求方之间的连接状态发生变化时广播该Intent。当新连接建立或者现有连接丢失时就使用EXTRA_NEW_STATE触发它，并且在建立新连接时，该布尔值返回true NETWORK_STATE_CHANGED_ACTION 每当Wi-Fi连接状态发生变化时被触发。 EXTRA_NETWORK_INFO 其中包含详细描述了当前网络状态的NetworkInfo对 EXTRA_BSSID 包含所连接的接入点的BSSID RSSI_CHANGED_ACTION 通过监听RSSI_CHANGED_ACTION Intent来监视已连接Wi-Fi网络的当前信号强度。 EXTRA_NEW_RSSI 保存了当前的信号强度，可以通过使用Wi-Fi Manager的calculateSignalLevel静态方法，以便按照你指定的范围将该信号强度转换成一个整型数值。 监视活动的Wi-Fi连接的相信信息当建立了一个活动的Wi-Fi连接，就可以使用Wi-Fi Manager的getConnectionInfo方法找出连接的状态信息。所返回的WiFiInfo对象包含当前接入点的SSID、BSSID、Mac地址、IP地址，以及当前的链路速度和信号强度。 123456789WifiInfo info = wifi.getConnectionInfo();if (info.getBSSID() != null) &#123; int strength = WifiManager.calculateSingalLevel(info.getRssi(),5); int speed = info.getLinkSpeed(); String units = WifiInfo.LINK_SPEED_UNITS; String ssid = info.getSSID(); String cSummary = String.format(&quot;Connected to %s at %s%s. Strength %s/5&quot;,ssid,speed,units,strength); Log.d(TAG,cSummary);&#125; 扫描热点可以使用Wi-Fi Manager的startScan方法进行接入点扫描。一个带有SCAN_RESULTS_AVAILABLE_ACTION动作的Intent将被广播以便异步宣布扫描完成并且结果可用。 12345678910111213141516171819//注册用于监听扫描结果的BroadcastReceiverregisterReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; List&lt;ScanResult&gt; results = wifi.getScanResults(); ScanResult bestSingal = null; for (ScanResult result : results) &#123; if (bestSignal == null || WifiManager.compareSignalLevel(bestSignal.level,result.level) &lt; 0) &#123; bestSignal = result; &#125; &#125; String connSummary = String.format(&quot;%s networks found. %s is the strongest.&quot;,results.size(),bestSignal.SSID); Toast.makeText(MyActivity.this,connSummary,Toast.LENGTH_LONG).show(); &#125;&#125;,new IntentFilter(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION));//开始扫描wifi.startScan(); 管理Wi-Fi配置可以使用Wi-Fi Manager管理已配置的网络设置并控制将要连接到哪个网络。一旦连接建立，就可以通过查询可用网络连接来获得其配置和设置的更多详细信息。 getConfiguredNetworks 可以获得当前网络配置的列表。返回的WifiConfiguration对象列表包含每个配置的网络ID、SSID和其他详细信息 enableNetwork 使用某个特定的网络配置 123456789//获得可用配置的一个列表List&lt;WifiConfiguration&gt; configurations = wifi.getConfiguredNetworks();//获得第一个配置的网络IDif (configurations.size() &gt; 0) &#123; int netID = configurations.get(0).networkId; //启用网络 boolean disableAllOthers = true; wifi.enableNetwork(netID,disableAllOthers);&#125; 创建Wi-Fi网络配置为了连接到一个Wi-Fi网络，需要创建并注册一个配置。一般，用户将使用本地Wi-Fi配置设置进行该操作，但是也可以在自己的应用程序中提供相同的功能。网络配置作为WifiConfiguration对象进行存储。 BSSID 每个接入点的BSSID SSID 特定网络的SSID networkId 用于在当前设备上标识这个网络配置的唯一标识符 priority 当对要连接到的潜在接入点的列表进行排序时用到的网络配置优先级 status 该网络连接的当前状态。 addNetwork方法可以指定一个新的配置并将其添加到当前列表中。updateNetworks可以传入只包含一个网络ID和想要更改的值得WifiConfiguration对象来更新网络配置。 使用Wi-Fi Direct传输数据Wi-Fi Direct是一种通信协议，用于中等距离、高带宽的点对点通信。与蓝牙技术相比，Wi-Fi Direct更加快速可靠，而且工作距离更远。特别适合媒体共享和接收实时媒体流等操作。 初始化Wi-Fi Direct框架为使用Wi-Fi Direct，必须添加权限。 123&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; Wi-Fi Direct连接是使用Wifi2pManager系统服务建立和管理的。 1234567891011private Wifi2pManager wifiP2pManager;private Channel wifiDirectChannel;private void initializeWiFiDirect() &#123; wifiP2pManager = (Wifi2pManager)getSystemService(Context.WIFI_P2P_SERVICE); wifiDirectChannel = wifiP2pManager.initialize(this,getMainLooper(),new ChannelListener() &#123; public void onChannelDisconnected() &#123; initializeWiFiDirect(); &#125; &#125;)&#125; 将会使用这个通道与Wi-Fi Direct框架进行交互，因此WiFi P2P Manager的初始化操作通常是在Activity的onCreate处理程序内完成的。使用WiFi P2P Manager执行的大多数动作会使用一个ActionListener立即指出它们是否成功。 1234567891011121314151617181920212223private ActionListener actionListener = new ActionListener() &#123; public void onFailure(int reason) &#123; String errorMessage = &quot;WiFi Direct Failed.&quot;; switch(reason) &#123; case WifiP2pManager.BUSY: errorMessage += &quot;Framework busy.&quot;; break; case WifiP2pManager.ERROR: errorMessage += &quot;Framework error.&quot;; break; case WifiP2pManager.P2P_UNSUPPORTED: errorMessage += &quot;Unsupported.&quot;; break; default: errorMessage += &quot;Unknown error.&quot;; break; &#125; &#125; public void onSuccess() &#123; //成功，返回值通过一个Broadcast Intent返回 &#125;&#125; 启用Wi-Fi Direct并监视其状态为使一个Android是被能够发现其他Wi-Fi Direct设备或被其他Wi-Fi Direct设备发现，用户首先必须启用Wi-Fi Direct。 startActivity(new Intent(android.provider.Settings.ACTION_WIRELES_SETTINGS)); 只有建立连接并传输数据时，Wi-Fi Direct才回一直保持启用状态。如果短时间不用，它就会自动禁用。只有设备上启用了Wi-Fi Direct时，才能够执行Wi-Fi Direct操作。因此，监听Wi-Fi Direct的状态变化，并通过修改UI来禁用不可行操作非常重要。 1234567891011121314BroadcastReceiver p2pStatusReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE,WifiP2pManager.WIFI_P2P_STATE_DISABLED); switch(state) &#123; case (WifiP2pManager.WIFI_P2P_STATE_ENABLED): buttonDiscover.setEnabled(true); break; default: buttonDiscover.setEnabled(false); &#125; &#125;&#125; 在创建了连接到Wi-Fi Direct框架的通道并启用设备及其对等设备上的Wi-Fi Direct后，就可以开始搜索和连接对等设备。 发现对等设备为扫描对等设备，需要调用WiFi P2P Manager的discoverPeers方法，并传入一个处于活动状态的通道和一个Action Listener。对等设备列表的变化将作为一个Intent，通过使用WifiP2pManager，WIFI_P2P_PEERS_CHANGED_ACTION 动作广播出去。在建立一个连接或者创建一个组之前，对等设备的搜索过程会一直进行。 12345678910111213141516private void discoverPeers() &#123; wifiP2pManager.discoverPeers(wifiDirectChannel,actionListener);&#125;BroadcastReceiver peerDiscoveryReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; wifiP2pManager.requestPeers(wifiDirectChannel,new PeerListListener() &#123; public void onPeersAvailable(WifiP2pDeveiceList peers) &#123; deviceList.clear(); deviceList.addAll(peers.getDeviceList()); aa.notifyDataSetChanged(); &#125; &#125;) &#125;&#125; 连接对等设备为了与对等设备建立Wi-Fi Direct连接，需要使用WiFi P2P Manager的connect方法，并传入活动的通道，一个Action Listener以及一个指定了要连接的对等设备的地址的WifiP2pConfig对象 12345private void connectTo(WifiP2pDevice device) &#123; WifiP2pConfig config = new WifiP2pConfig(); config.deviceAddress = device.deviceAddress(); wifiP2pManager.connect(wifiDirectChannel,config,actionListener);&#125; 当尝试建立一个连接时，远程设备就会被提示接受连接请求。如果远程设备接受了建立连接的请求，成功的连接将使用WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION Intent动作在两个设备上广播。 12345678910111213141516171819202122232425262728BroadcastReceiver connectionChangedReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context,Intent intent) &#123; //提取NetworkInfo NetworkInfo networkInfo = (NetworkInfo)intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO); //检查是否已经连接 if (networkInfo.isConnected()) &#123; wifiP2pManager.requestConnectionInfo(wifiDirectChannel,new ConnectionInfoListener() &#123; public void onConnectionInfoAvailable(WifiP2pInfo info) &#123; //如果建立了连接 if (info.groupFormed) &#123; //如果这个设备是服务器 if (info.isGroupOwner) &#123; //启动Server Socket &#125; //如果这个设备是客户机 else if (info.groupFormed) &#123; //启动Client Socket &#125; &#125; &#125; &#125;); &#125; else &#123; Log.d(TAG, &quot;Wi-Fi Direct Disconnected&quot;); &#125; &#125;&#125; 当连接信息可用时，ConnectionInfoListener会触发其onConnectionInfoAvailable处理程序，并传入一个包含这些详细信息的WifiP2pInfo对象。 辅助LinkifyLinkify会自动地在TextView类中通过RegEx模式匹配来创建超链接。那些匹配一个指定的RegEx模式的文本都将会被转化为一个可以单击的超链接，这些超链接可以隐式使用匹配的文本作为目标URI来出发startActivity(new Intent(Intent.ACTION_VIEW,uri))。 原生Linkify链接类型添加 WEB_URLS、EMAIL_ADDRESSES、PHONE_NUMBERS和ALL 预设值 1234TextView textView = findViewById(R.id.myTextView);Linkify.addLinks(textView,Linkify.WEB_URLS|Linkify.EMAIL_ADDRESSES);xml 文件中autoLink属性包含(none、web、email、phone、all) 创建定制的链接字符串传入RegEx模式 12Pattern p = Pattern.compile(&quot;\\bquake[\\s]?[0-9]+\\b&quot;,Pattern.CASE_INSENSITIVE);Linkify.addLinks(myTextView,p,baseUri); 使用Match Filter和Transform Filter,通过实现Match Filter 的 acceptMatch 方法来向RegEx模式匹配添加额外的条件。Transform Filter允许修改匹配的链接文本生成的隐式URI。把链接文本和目标URI分开，你能够更自由地决定如何把数据字符串显示给用户。 12345678910111213Linkify.addLinks(myTextView,p,baseUri,new MyMatchFilter(),new MyTransformFilter());class MyMatchFilter implements MatchFilter &#123; public boolean acceptMatch(CharSequence s,int start,int end) &#123; return (start == 0 || s.charAt(start - 1) != &apos;!&apos;); &#125;&#125;class MyTransformFilter implements TransformFilter &#123; public String transformUrl(Matcher match,String url) &#123; return url.toLowerCase().replace(&quot; &quot;,&quot;&quot;); &#125;&#125; 全屏显示要想控制手机上导航栏的可见性或者平板电脑上系统栏的外观，可以对Activity层次结构中任何可见的View使用setSystemUiVisibility方法。 SYSTEM_UI_FLAG_LOW_PROFILE 和 STATUS_BAR_HIDDEN 一样会遮挡导航按钮。 SYSTEM_UI_FLAG_HIDE_NAVIGATION 在手机上移除导航栏，并遮挡平板电脑的系统栏中使用的导航按钮。 当导航的可见性变化时，最好能够和UI中其他变化同步。例如，在进入或者退出”全屏模式“时，可能需要隐藏或者显示操作栏和其他导航操作。 1234567891011myView.setOnSystemUiVisibilityChangeListener ( new OnSystemUiVisibilityChangeListener() &#123; public void onSystemUiVisibilityChange(int visibility) [ if (visibility == View.SYSTEM_UI_FLAG_VISIBLE) &#123; //显示操作栏和状态栏 &#125; else &#123; //隐藏操作栏和状态栏 &#125; &#125; &#125;) 要想隐藏状态栏，可以向Window中添加LayoutParams.FLAG_FULLSCREEN标志 12myView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN); 为每个屏幕尺寸和分辨率做设计当使用不能很好地动态缩放的Drawable资源时，应该创建和包含针对每种像素密度类别进行优化的图像资源 res/drawable-ldpi 为120dpi左右的屏幕提供低密度资源 res/drawable-mdpi 为160dpi左右的屏幕提供中密度资源 res/drawable-hdpi 为240dpi左右的屏幕提供高密度资源 res/drawable-xhdpi 为320dpi左右的屏幕提供超高密度资源 res/drawable-nodpi 用于不管宿主屏幕密度如何都不能缩放的资源 宽屏优化 long 宽屏修饰符 notlong 非宽屏修饰符 横竖屏优化 land 横屏修饰符 port 竖屏修饰符 宽度优化 w600dp 宽度修饰符 h720dp 高度修饰符 sw320dp 最小的可用屏幕宽度 设备大小 small 小 normal 普通 large 大 xlarge 超大 指定支持的屏幕尺寸对于一些应用程序，可能无法通过优化UI来使其支持所有可能的屏幕尺寸。可以通过在清单文件中使用supports-screens元素来指定应用程序可以运行在哪些屏幕上 1234&lt;supports-screens android:smallScreens=&quot;false&quot; android:normalScreens=&quot;true&quot; android:largeScreens=&quot;true&quot; android:xlargeScreens=&quot;true&quot;&gt; 复制、粘贴和剪贴板ClipboardManager clipboard = (ClipboardManager)getSystemService(CLIPBOARD_SERVICE); 剪贴板支持文本字符串、URI和Intent。要想向剪贴板复制一个对象，可以创建一个新的ClipData对象，它包括一个描述了与待复制对象相关的元数据的ClipDescription、任意数量的ClipData.Item对象。使用setPrimaryClip方法把ClipData添加到剪贴板上。clipboard.setPrimaryClip(newClip);在任意时刻，剪贴板中只能包含一个ClipData对象。复制一个新的对象会替换之前持有的剪贴板对象。 向剪贴板中复制数据ClipData类提供了大量方便的静态方法来简化一个标准的ClipData对象的创建过程。使用newPlainText方法创建一个新的ClipData对象。或使用newUri方法，指定一个Content Resolver、标签和待粘贴数据的URI。 ClipData newClip = ClipData.newPlainText(&quot;copied text&quot;,&quot;Hello, Android!&quot;);ClipData newClip = ClipData.newUri(getContentResolver(),&quot;URI&quot;,myUri); 粘贴剪贴板数据可以判断剪贴板上是否已经复制了数据，从而在UI上启用和禁用粘贴选项。 if (!(clipboard.hasPrimaryClip())){} 当然，还可以查询当前剪贴板中的Clip Data对象的数据类型。使用getPrimaryClipDescription方法获得剪贴板数据中的元数据，并使用它的hasMimeTypes方法指定应用程序粘贴所支持的MIME类型: 12345if (!(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN))) &#123; //如果剪贴板中的内容是一个不支持的类型，就禁用粘贴UI选项&#125; else &#123; //如果剪贴板中的内容是一个支持的类型，就启用粘贴UI选项&#125; 要想访问数据本身，可以使用getItemAt方法，传入你要遍历的项的索引值 ClipDate.Item item = clipboard.getPrimaryCclip().getItemAt(0); 通过分别使用getText、getUri和getIntent方法，可以获取文本、URI和Intent。使用coerceToText方法，可以将ClipData.Item对象的内容转化为一个字符串。CharSequence pasteText = item.coerceToText(this); 使用Wake Lock为了延长电池的使用寿命，Android设备会在闲置一段时间后使屏幕变暗，然后关闭屏幕显示，最后停止CPU。WakeLock是一个电源管理系统服务功能，应用程序可以使用它来控制主机设备的电源状态。可以保持CPU运行，避免屏幕变暗和关闭，以及避免键盘背光灯熄灭。但是它会显著影响电池寿命，所以在创建它之前，需要请求权限 &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt; 为创建一个WakeLock，需要调用Power Manager的newWakeLock方法，并指定下面一种WakeLock类型 FULL_WAKE_LOCK 保持屏幕最大亮度、键盘背光灯点亮以及CPU运行 SCREEN_BRIGHT_WAKE_LOCK 保持屏幕最大亮度和CPU运行 SCREEN_DIM_WAKE_LOCK 保持屏幕亮起和CPU运行(通常用于在用户观看屏幕但是很少与屏幕进行交互期间防止屏幕变暗) PARTIAL_WAKE_LOCK 保持CPU运行 创建WakeLock后，可以通过acquire来获取它。可以有选择地指定一个超时值来确保将在尽可能长时间内保持使用Wake Lock。动作完成后，需要调用release来让系统管理电源状态。 123456789101112131415161718WakeLock wakeLock;private class MyAsyncTask extends AsyncTask&lt;Void,Void,Void&gt; &#123; @Override protected Void doInBackground(Void... parameters) &#123; PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE); wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,&quot;MyWakeLock&quot;); wakeLock.acquire(); //Do things in the background return null; &#125; @Override protected void onPostExecute(Void parameters) &#123; wakeLock.release(); &#125;&#125; 参考资料《Android4 编程入门经典》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio整体学习]]></title>
      <url>%2F2018%2F04%2F10%2Fandroid-studio-study%2F</url>
      <content type="text"><![CDATA[前言开发Android也有一年多的时间了，一直使用Android Studio。虽然一直都能正常开发，但是在开发过程中，对IDE的不熟悉还是会导致各种各样的问题，也会拉低开发效率去网上搜索。所以我想整体学习了解下Android Studio的使用，记录方便日后查询。 偏好设置基础配置编码方式操作步骤: Preferences -&gt; Editor -&gt; File Encodings 个性化配置字体和大小操作步骤: Preferences -&gt; Appearance &amp; Behavior -&gt; Appearance -&gt; 勾选【Override default fonts by (not recommended)】 -&gt; 选择所要的字体和字号设置的是IDE的操作界面的字体和字号 工作台菜单栏文件（File）编辑（Edit）视图（View）Navigate（导航）代码（Code）分析（Analyze）重构（Refactor）构建（Build）运行（Run）工具（Tools）版本控制系统（VCS）窗口（Window）帮助（Help）导航条菜单栏中View -&gt; 勾选Navigation Bar可以显示导航条 工具条Android Studio的工具条分布在主界面的左右两边和底部。可以通过菜单栏-&gt;View-&gt;Tool Windows -&gt; 查看Android Studio支持的所有工具列表 工具窗口项目工具窗口（Project）提供多种视图模式来查看项目结构 收藏夹工具窗口（Favorite）可以添加经常查看或使用的文件和代码片段，以便快速查看 结构工具窗口（Structure）以树状形式展示文件中元素的层次结构。单击元素可以跳转到编辑器中对应代码的位置 待处理任务工具窗口（TODO）在Android Studio中待处理的任务可以注释使用TODO标识，该窗口显示所有待处理的任务 Android监控工具窗口（Android Profiler）CPU监控内存监控网络监控Logcat日志输出面板快照工具窗口（Captures）存放Android Monitor的dump处的heap、allocation、系统信息、布局解析等文件 构建变体工具窗口（Build Variants）用来选择当前多渠道版本的构建，执行Build APK会构建出选中的渠道版本 Gradle工具窗口（Gradle project）列出了当前项目和模块中支持的所有Gradle任务和运行配置，以便快速操作 项目 文件/目录名 说明 NewProject 项目 NewProject 自动生成的用于存放Android Studio配置文件的目录，包括版权、检查配置、jar包信息、项目名、编译、编码、gradle、模块等 NewProject/app 项目中的模块 NewProject/app/build 模块编译后的文件存放目录 NewProject/app/libs 模块依赖的jar包存放目录 NewProject/app/src/androidTest Android单元测试代码存放目录 NewProject/app/src/test 本地单元测试代码存放目录 NewProject/app/src/main 代码和资源存放目录 NewProject/app/src/main/java 代码目录 NewProject/app/src/main/res 资源目录 NewProject/app/src/main/res/drawable 存放能转化为绘制资源的位图文件或定义了绘制资源的XML文件(后缀为.png,.9.png,.jpg,.gif的图像文件) NewProject/app/src/main/res/layout 存放定义了用户界面布局的XML布局 NewProject/app/src/main/res/anim 存放定义了补间动画或逐帧动画的XML文件 NewProject/app/src/main/res/animator 存放定义了属性动画的XML文件 NewProject/app/src/main/res/transition 存放定义了场景过渡动画的XML文件 NewProject/app/src/main/res/menu 存放定义了应用程序菜单资源的XML文件 NewProject/app/src/main/res/mipmap 存放启动图标目录 NewProject/app/src/main/res/mipmap-mdpi 中密度，适用于屏幕密度为160的手机屏幕 NewProject/app/src/main/res/mipmap-hdpi 高密度，适用于屏幕密度为240的手机屏幕 NewProject/app/src/main/res/mipmap-xhdpi 超高密度，适用于屏幕密度为320的手机屏幕 NewProject/app/src/main/res/mipmap-xxhdpi 超超高密度，适用于屏幕密度为480的手机屏幕 NewProject/app/src/main/res/mipmap-xxxhdpi 超超超高密度，适用于屏幕密度为640的手机屏幕 NewProject/app/src/main/res/values 存放定义了多种类型资源的XML文件 NewProject/app/src/main/res/values/color 存放定义了颜色状态列表资源的XML文件 NewProject/app/src/main/jniLibs so文件存放目录 NewProject/app/src/main/assets 附加的资源文件存放目录 NewProject/app/src/main/res/AndroidManifest.xml 应用程序配置文件 NewProject/app/.gitignore 模块中Git忽略配置文件 NewProject/app/app.iml 模块配置文件 NewProject/app/build.gradle 模块构建配置文件 NewProject/app/proguard-rules.pro 代码混淆配置文件 NewProject/build 项目编译目录 NewProject/gradle gradle目录 NewProject/.gitignore 项目中Git的忽略配置文件 NewProject/build.gradle 项目构建配置文件 NewProject/gradle.properties gradle配置文件 NewProject/gradlew gradlew配置文件 NewProject/gradlew.bat Windows上的gradlew配置文件 NewProject/local.preperties 属性配置文件 NewProject/settings.gradle 全局配置文件 External Libraries 项目中使用到的依赖库存放目录 External Libraries/&lt; Andriod API 23 Platform &gt; Android SDK版本和存放路径 External Libraries/&lt; 1.7 &gt; JDK版本和存放路径 创建可编译的资源文件操作步骤: File -&gt; 右击module -&gt; New -&gt; Android resource file -&gt; 弹出【New Resource File】 File Name: 新建的资源文件名 Resource type: 资源类型 Root element: XML文件的根属性 Source set: 编译时引用的资源文件的来源设置，默认的是main,debug,release Directory name: 资源文件的目录名与资源类型一一对应，不可更改 Available aualifiers: 可用的资源限定符 Country Code: 移动设备国家代码，唯一识别移动用户所属国家 Network Code: 移动设备网络代码，与Country Code相结合，用来表示唯一一个移动设备的网络运营商 Local: 国际化(多语言) Layout Direction: 布局方向 Smallest Screen Width: 最小屏幕宽度。这个值是布局支持的最小宽度，而不管屏幕的当前方向 Screen Width: 最小的可用屏幕宽度。当方向在横向和纵向之间改变时，这个值会跟当前的实际宽度相匹配 Screen Height: 最小的可用屏幕高度 Size: 屏幕尺寸 Small: 小屏幕尺寸，320 * 426dp Normal: 中等屏幕尺寸，320 * 470dp Large: 大屏幕尺寸，480 * 640dp X-large: 超大屏幕尺寸，720 * 960dp Ratio: 宽高比率，指的是实际的物理尺寸宽高比率，分为Long和NotLong Orientation: 限制横竖屏切换 Portrait: 竖屏 Landscape: 横屏 Square: 正方形 UI Mode: UI模式 Car Dock: 车座 Desk Dock: 桌座 Television: 电视上 Application: 装置 Watch: 手表 Night Mode: 夜间模式 Not Night: 白天 Night: 夜间 Density: 密度,指定不同密度的手机使用不同的资源 Touch Screen: 触屏类型 No Touch: 非触屏 Stylus: 触控笔 Finger: 手指 Keyboard: 键盘类型 Exposed: 设备有可用的键盘 Hidden: 设备有可用的硬键盘 Soft: 设备有可用的软键盘 Text Input: 文本输入法 No Keys: 设备没有用于文本输入的硬键盘 Qwerty: 设备有标准的硬键盘 12Key: 设备有12个键的硬键盘 Navigation State: 导航键的状态 Exposed: 导航键可用 Hidden: 导航键不可用 Navigation Method: 导航方法 None: 除了使用触屏以外，设备没有其他导航设施 D-pad: 设备有用于导航的定向板 Trackball: 设备有用于导航的轨迹球 Wheel: 设备有用于导航的定向滚轮 Dimension: 自定义屏幕尺寸 Version: 版本,设备支持的API级别 创建不同分辨率图标操作步骤: File -&gt; 右击Module -&gt; New -&gt; Image Asset -&gt; Asset Studio对话框 Icon Type: 图标类型 Launcher Icons(Adaptive and Legacy): 自适应和传统的图标 Launcher Icons(Legacy Only): 传统图标 Action Bar and Tab Icons: 标题栏和选项卡图标 Notification Icons: 通知图标 Asset Type: 资源类型 Image: 本地图片，自动生成不同分辨率的图标 Clip Art: 剪贴画，Android Icon Text: 文字图标 Trim: 去除图标周围多余的空白 Scaling: 图标缩放 Shape: 图标形状 Effect: 设置文件折叠特效 创建矢量图操作步骤: File -&gt; 右击Module -&gt; New -&gt; Vector Asset -&gt; Configure Image Asset对话框 可以同时使用Android提供的和本地的svg图片可以设置颜色，大小和透明度 创建AIDL文件操作步骤: File -&gt; 右击Module -&gt; New -&gt; AIDL -&gt; AIDL File 创建Android文件夹 文件夹 作用 默认位置 AIDL Folder 用于存放AIDL文件 src/main/aidl/ Assets Folder 用于存放原生资源文件 src/main/assets/ JNI Folder 用于存放JNI文件 src/main/jni/ Java Folder 用于存放Java文件 src/main/java/ Java Resources Folder 用于存放Java资源文件 src/main/resources/ RenderScript Folder 用于存放RenderScript文件 src/main/rs/ Res Folder 用于存放Android资源文件 src/main/res/ 创建Resource Bundle文件ResourceBundle(资源绑定)最大好处是可以使程序国际化，在bundle文件名后加上国家、语言关键字，系统就会自动载入相应的bundle文件。properties文件一般的命名规范是: 自定义名语言代码国别代码.properties 操作步骤: File -&gt; 右击Module -&gt; New -&gt; Resource Bundle -&gt; 输入文件名”success” -&gt; 添加语言代码 -&gt; 双击打开properties -&gt; 切换到Resource Bundle -&gt; 点击+ -&gt; 输入主键 -&gt; 可以同时编辑不同语言的值 管理项目窗口Android Studio中支持好多种视图模式，要学会在适合的时候用适合的视图，提高开发效率 视图模式Project视图模式Project视图模式展示全部文件信息，文件的位置是真实的物理结构。因此在查看文件的时候建议切换到Project模式。 Packages视图模式Packages视图模式仅显示项目本身的代码和资源，其他的信息被隐藏了，代码和资源都以层级文件的形式显示。 Scratches视图模式Scratches视图模式只显示草稿文件。 Scratch Files(草稿文件)是一个非常方便的功能，可以帮助我们快速实验和建立原型，可以在不修改项目和创建任何文件的情况下快速画出草图。 Android视图模式Android视图模式会把一些我们不关心的文件和目录隐藏起来，以一种扁平化的方式显示项目结构，文件和目录通过类型进行分类，可以非常方便的查看文件。 Project Files视图模式Project Files视图模式是类似Eclipse的项目结构类型。 Problems视图模式Problems模式仅显示报错的文件结构。 Production视图模式Production模式仅显示生产文件结构。 Tests视图模式Tests模式仅显示测试文件结构。 常用设置和操作展开和收缩窗口展开窗口: shift + command + -&gt; 每操作一次窗口向右扩展一下收缩窗口: shift + command + &lt;- 每操作一次窗口向左收缩一下最大化窗口: shift + command + “‘“ 定位文件在项目中的位置Scroll from Source按钮 收起所有项目Collapse All按钮 command + “-“ 扁平化显示包名选中 Flatten Packages，所有包名都会显示在同一级目录下，不会有层次结构 隐藏空的中间包名选中 Hide Empty Middle Packages。项目窗口中的含有空文件夹的包名将会被隐藏。 缩写限定包名选中 Abbreviate Qualified Package Names。项目缩写包名 显示成员选中 Show Members。让项目窗口中的文件显示其他成员(字段、方法) 按类型排序选中 Sort By Type。让文件按类型排序，否则项目窗口中的文件按字母排序。 文件夹显示在文件之前选中 Folder Always on Top。让所有文件夹始终在文件之前，否则所有的文件和文件夹都会混在一起，按字母排序。 单击文件打开源码选中 Autoscroll to Source。项目窗口中单击文件就能够在编辑器中自动打开。 从源码定位到文件选中 Autoscroll from Source。打开源码后自动定位到该文件在项目窗口中的位置。 项目管理管理最近打开的项目为最近打开的项目进行分组方便管理多个项目 操作步骤: 菜单栏 -&gt; File -&gt; Open Recent -&gt; Manager Projects。新建分组: 右击项目名称 -&gt; New Project Group -&gt; 输入分组名 -&gt; OK。添加分组: 右击项目名称 -&gt; Move To Group —&gt; 在列出的项目分组中选择目标分组。 改变目标默认图标操作步骤: 菜单栏 -&gt; File -&gt; Open Recent -&gt; Manager Projects —&gt; 右击项目名称 -&gt; Change Icon。 从欢迎界面移除操作步骤: 菜单栏 -&gt; File -&gt; Open Recent -&gt; Manager Projects —&gt; 右击项目名称 -&gt; Remove Selected from Welcome Screen。 设置记录最近打开项目的个数Android Studio默认记录最新的50个项目。操作步骤: 偏好设置 -&gt; Editor -&gt; 单击General -&gt; 在Limits中调整Recent files limit个数。 清除缓存/重启Android Studio当我们直接修改Android Studio的配置文件时，配置没有生效或者遇到一些莫名其妙的错误时，可以尝试清除缓存再重启Android Studio来解决问题 操作步骤: 菜单栏 -&gt; File -&gt; Invalidate Caches/Restart(清除缓存/重启) -&gt; 进入确认界面。 收藏夹在Android Studio的日常编码中，如果某个文件或某段代码使我们经常需要查看或试用的，就可以把它添加到收藏夹中，以便快速查看。 添加添加文件: 右击文件 -&gt; Add to Favorites -&gt; 选中已存在的收藏夹中的收藏列表或添加到一个新建的收藏列表。添加方法: 将光标放在方法名上 -&gt; 菜单栏 -&gt; File -&gt; Add to Favorites -&gt; Add New Favorites List -&gt; 选中已存在的收藏夹中的收藏列表或添加到一个新建的收藏列表。添加断点: 打上断点，断点会自动被添加到收藏夹。 TODO在Android Studio中待处理的任务可以再注释中使用TODO来标识，以表明这个地方是需要注意的，既有可能是未完成的功能，也有可能是需要解决的BUG或者是需要优化的代码。 添加TODO任务在注释中输入TODO关键字 功能键 Expand All 展开所有 Collapse All 收起所有 Group By Modules 按模块分组 Group By Packages 按包名分组 Flatten Packages 扁平化显示包名 Autoscroll to Source 自动打开源码 Preview Source 自动预览源码 Previous TODO 向上跳转任务 Next TODO 向下跳转任务 Filter TODO items 过滤任务 可以在偏好设置 -&gt; Editor -&gt; TODO 中进行设置 自定义TODO关键字操作步骤: 偏好设置 -&gt; Editor -&gt; TODO -&gt; 添加按钮 -&gt; 输入匹配表达式 -&gt; 选择icon -&gt; 设置颜色 编辑合并两行内容通常我们要合并两行内容都是狂按删除键来删除两行之间的空格，然后对代码的格式进行调整。Android Studio给我们提供了一个自动合并两行内容的功能，可以智能地合并字符串、注释、声明和赋值，一键完成以上操作。 菜单栏: Edit -&gt; Join Lines快捷键: control + Shift + J 选择技巧扩大缩小选择范围扩大菜单栏: Edit -&gt; Extend Selection快捷键: option + 向上箭头 缩小菜单栏: Edit -&gt; Shrink Selection快捷键: option + 向下箭头 列选择模式菜单栏: Edit -&gt; Column Selection Mode快捷键: Shift + command + 8 自动补全当前的语句菜单栏: Edit -&gt; Complete Current Statement快捷键: Shift + command + 回车 一键切换大小写菜单栏: Edit -&gt; Toggle Case快捷键: Shift + command + U 查找工具栏打开查找工具栏快捷键: command + F 查找范围设置 In Comments Only: 仅在注释中搜索 In Literals Only: 仅在文本中搜索 Except Comments: 注释除外 Except Literals: 文本除外 Except Comments and Literals: 注释和文本除外 指定查找路径除了在当前文件中查找以外，还可以在其他路径中查找，另外，还可以设置很多查找条件，以方便更加精确和快速地得到查找结果。 菜单栏: Edit -&gt; Find -&gt; Find in Path…快捷键: shift + command + F 指定替换路径菜单栏: Edit -&gt; Find -&gt; Replace in Path…快捷键: shift + command + R 单击【Replace】: 一个个替换 单击【Skip】: 会跳过当前匹配结果 单击【Replace All in This File】: 替换当前文件中所有的匹配结果 单击【Skip To Next File】: 会跳跳到下一个文件 单击【All Files】: 全部替换 单击【Review】: 在工具栏显示查找结果，单击结果可以查看详情 在结构中查找和替换Android Studio提供了一个使用代码模板查找和替换的方式，可以方便地定义代码模板 操作步骤:菜单栏 -&gt; Edit -&gt; Find -&gt; Search Structurally/Replace Structurally -&gt; 打开【Structural Search】 查找用法想看方法或者变量在哪些地方进行调用 菜单栏: Edit -&gt; Find -&gt; Find Usages右键菜单: Find Usages快捷键: fn + option + F7 Skip results tab with one usage: 当搜索的数据只有一个地方使用时，不显示搜索结果标签，光标会直接跳到使用的地方。 Scope: 设置查找范围，使查找更加快速和精确 Open in new tab: 如果勾选了此项，每一次查找都会打开一个新的标签，如果不勾选此项，那么每次新的查找结果将会覆盖上一次的查找结果 显示用法显示用法功能不会另外打开一个工具窗口来显示查找结果，而是直接弹出提示框显示数据在何处被使用。 菜单栏: Edit -&gt; Find -&gt; Show Usages快捷键: fn + option + command + F7 功能 合并相同行 显示读取访问权限 显示写访问权限 显示import语句 按文件结构分组 查看在当前文件中的用法菜单栏: Edit -&gt; Find -&gt; Find Usages in File快捷键: command + F7 Macros(宏)宏是一种批处理的称谓，由一些命令组织在一起，作为一个单独的命令来完成一个特定任务。 录制回放宏 选择Eidt -&gt; Macros -&gt; Start Macros Recording -&gt; Android Studio右下角显示开始录制提示 按快捷键command + s保存文件 按快捷键control + s运行代码 选择Eidt -&gt; Macros -&gt; Stop Macros Recording -&gt; 在输入框中输入已录制宏的名字 定义快捷键。选择Android Studio -&gt; Keymap -&gt; Macros -&gt; 找到刚才录制的宏【AutoSaveAndRun】 视图工具窗口显示/隐藏工具窗口 打开/隐藏 项目工具窗口: command + 1 打开/隐藏 收藏工具窗口: command + 2 打开/隐藏 运行窗口: command + 4 打开/隐藏 调试窗口: command + 5 打开/隐藏 Android Monitor工具窗口: command + 6 打开/隐藏 项目结构窗口: command + 7 打开/隐藏 版本控制工具窗口: command + 9 打开/隐藏 终端工具窗口: fn + option + F12 快速切换工具窗口快捷键: control + Tab 查看同胞元素快速查看同胞元素是指查看跟当前类一样继承自同一个父类的所有元素操作步骤:菜单栏 -&gt; View -&gt; Show Siblings 查看文档菜单栏: View -&gt; Quick Documentation快捷键: fn + F1 设置鼠标悬停在元素上会显示文档提示操作步骤:偏好设置 -&gt; Editor -&gt; General -&gt; Other -&gt; 勾选【Show quick documentation on mouse move】 查看方法的参数信息菜单栏: View -&gt; Parameter Info快捷键: command + P 查看上下文信息菜单栏: View -&gt; Context Info快捷键: control + shift + Q 查看源码菜单栏: View -&gt; Jump to Source快捷键: command + 向下箭头鼠标: 按住command键，再用鼠标单击对应的方法或类 查看最近打开过的文件菜单栏: View -&gt; Recent Files快捷键: command + E 查看最近改动过的文件菜单栏: View -&gt; Recently Changed Files快捷键: shift + command + E 查看最近的改动菜单栏: View -&gt; Recently Changed快捷键: shift + control + C 对比任意文件菜单栏: View -&gt; Compare With快捷键: command + D 将光标放在文件上，按快捷键command + D，选择要对比的文件。 Do not ignore: 不忽略空格 Trim whitespaces: 删掉空格 Ignore whitespaces: 忽略空格 Ignore whitespaces and empty lines: 忽略空格和空行 Highlight lines: 高亮行 Highlight words: 高亮字 Highlight split changes: 高亮拆分的变动 collapse unchanged fragment: 折叠没有变动的代码片段 Show Whitespaces: 显示空格 Show Line Numbers: 显示行号 Show Indent Guides: 显示缩进向导 Use Soft Wraps: 使用自动换行 将选中的文件和正在编辑的文件进行对比菜单栏: View -&gt; Compare File with Editor 将选中的文件和剪贴板上的内容进行对比菜单栏: View -&gt; Compare with Clipboard 设置编辑器是否显示空格默认编辑器是不会显示空格的 设置当前编辑器是否显示空格只对当前打开的文件进行临时设置，可以通过菜单栏: View -&gt; Active Editor -&gt; Show Whitespaces 设置整个编辑器显示空格操作步骤:偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show whitespaces】 Leading: 开头 Inner: 中间 Trailing: 结尾 设置编辑器是否显示行号默认编辑器是不会显示空格的 设置当前编辑器是否显示行号只对当前打开的文件进行临时设置，可以通过菜单栏: View -&gt; Active Editor -&gt; Show line number快捷键: 右击编辑器窗口左边栏 -&gt; Show Line Numbers 设置整个编辑器显示行号操作步骤:偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show line numbers】 设置编辑器是否显示缩进向导默认编辑器是显示的 设置当前编辑器是否显示缩进向导只对当前打开的文件进行临时设置，可以通过菜单栏: View -&gt; Active Editor -&gt; Show Indent Guides快捷键: 右击编辑器窗口左边栏 -&gt; Show Indent Guides 设置整个编辑器显示缩进向导操作步骤:偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show vertical indent guides】 设置整个编辑器显示行号操作步骤:偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show line numbers】 设置编辑器是否使用自动换行设置当前编辑器使用自动换行只对当前打开的文件进行临时设置，可以通过菜单栏: View -&gt; Active Editor -&gt; Use Soft Wraps快捷键: 右击编辑器窗口左边栏 -&gt; Use Soft Wraps 设置整个编辑器使用自动换行操作步骤:偏好设置 -&gt; Editor -&gt; General -&gt; 查看Soft Wraps -&gt; 勾选【Use soft wraps in editor】 让换行符一直显示如果想显示所有的换行符，就不要勾选【show soft wrap indicators for current line only】，该项只会显示当前正在编辑行的换行符 设置换行后的缩进字符默认换行第二行的缩进是从第0个字符开始的，如果想自定义换行后第二行的缩进，可以勾选【Use original line`s intent for wrapped parts】,设置Additional shift。 设置编辑器是否弹出导入提示默认编辑器是显示的 设置当前编辑器弹出导入提示只对当前打开的文件进行临时设置，可以通过操作步骤:菜单栏 -&gt; View -&gt; Active Editor -&gt; Show Import Popups 设置整个编辑器弹出导入提示操作步骤:偏好设置 -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Show Import Popup 使用演示模式操作步骤:菜单栏 -&gt; View -&gt; Enter Presentation Mode 设置演示模式的字体大小使用演示模式会默认进入免打扰模式和全屏模式，如果不想进入免打扰模式和全屏模式可以单独退出操作步骤:偏好设置 -&gt; Appearance&amp;Behavior -&gt; Appearance -&gt; Presentation Mode 使用免打扰模式如果不想界面上有其他多余的东西干扰，会隐藏菜单栏、工具栏操作步骤:菜单栏 -&gt; View -&gt; Enter Distraction Free Mode 使用全屏模式操作步骤:菜单栏 -&gt; View -&gt; Enter Full Mode 导航搜索并打开类文件如果想在项目中搜索某个类文件 菜单栏: Navigate -&gt; Class快捷键: command + N 搜索并打开文件如果想在项目中搜索其他文件 菜单栏: Navigate -&gt; File快捷键: shift + command + N 搜索并打开某个文件或方法如果想在项目中搜索文件和方法 菜单栏: Navigate -&gt; Symbol快捷键: option + shift + command + N 自定义代码块选中自定义的代码片段 -&gt; 菜单栏: Code -&gt; Surround With 或 按快捷键option + command + T 可以修改代码块描述，并且可以和普通代码块一样对这段代码进行展开和折叠 在自定义代码块之间选择和跳转菜单栏: Navigate -&gt; Custom Folding快捷键: option + command + “.” 快速跳到某一行代码菜单栏: Navigate -&gt; Line快捷键: command + G 快速跳转到光标的历史位置菜单栏: Navigate -&gt; Back/Forward快捷键: command + “[“ / “]” 快速跳转到编辑过的历史位置菜单栏: Navigate -&gt; Last Edit Location / Next Edit Location快捷键: shift + command + delete 标记书签对代码进行标记，标记我们阅读的位置 Toggle Bookmark: 标记书签 Toggle Bookmark with Mnemonic: 使用助记符标记书签 Show Bookmark: 显示书签 Next Bookmark: 下一个书签 Previous Bookmark: 上一个书签 菜单栏: Navigate -&gt; Bookmarks -&gt; Toggle Bookmark快捷键: fn + F3 快速跳到声明在写代码或者阅读代码时，想快速查看一个引用首次被声明的位置菜单栏: Navigate -&gt; Declaration鼠标: 按住command + 单击类、变量或方法 快速跳到实现菜单栏: Navigate -&gt; Implementation鼠标: option + command + B 快速跳到类型声明菜单栏: Navigate -&gt; Type Declaration快捷键: shift + command + B鼠标: 按住command + shift + B 快速跳转到父类菜单栏: Navigate -&gt; Super Method快捷键: command + U鼠标: 按住command + shift + B 类和测试类之间快速跳转快速跳转到测试类前提条件: 光标定位在类文件编辑界面菜单栏: Navigate -&gt; Test快捷键: shift + command + T 查看相关联的文件菜单栏: Navigate -&gt; Related Symbol快捷键: control + command + ↑ 查看文件结构快速调出当前文件的结构，并通过模糊匹配快速跳转到指定的方法 菜单栏: Navigate -&gt; File Structure快捷键: fn + command + F12 显示匿名内部类在文件结构中显示匿名内部类，需要勾选【Show Anonymous Classes】 显示所有继承的方法在文件结构中显示匿名内部类，需要勾选【Show inherited members】 输入时缩小输入时缩小是指在输入搜索关键字时搜索结果会自动过滤，不匹配的会被过滤掉。勾选【Narrow down on tying】 查看类的层次结构图菜单栏: Navigate -&gt; Type Hierarchy快捷键: control + H 还可以切换类结构的显示方式、排序、筛选范围等 查看方法类型的层次结构菜单栏: Navigate -&gt; Type Method快捷键: shift + command + H 查看方法调用层次结构菜单栏: Navigate -&gt; Call Hierarchy快捷键: control + option + H 快速跳转到错误代码的位置跳转到下一个错误位置菜单栏: Navigate -&gt; Next Highlighted Error快捷键: fn + F12 跳转到上一个错误位置菜单栏: Navigate -&gt; Previous Highlighted Error快捷键: fn + Shift + F12 在方法间前后跳转跳转到下一个方法菜单栏: Navigate -&gt; Next Method快捷键: control + ↑ 跳转到上一个方法菜单栏: Navigate -&gt; Previous Method快捷键: control + ↓ 翻页功能向上翻页: fn + ↑向下翻页: fn + ↓ 选择当前功能在哪里显示菜单栏: Navigate -&gt; Select in快捷键: fn + option + F1 光标快速跳转到页首/页尾页首: fn + command + ←页尾: fn + command + → 编码覆写或实现方法菜单栏: Code -&gt; Override Method快捷键: control + O 实现接口方法菜单栏: Code -&gt; Implement Methods快捷键: control + L 实现代理方法菜单栏: Code -&gt; Delegate Methods右键菜单: 右击 -&gt; Generate -&gt; Delegate Methods快捷键: command + N 生成构造函数/生成Getter和Setter方法/覆写equals和hashcode方法/覆写toString方法/插入版权信息菜单栏: Code -&gt; Generate -&gt; Constructor/Getter and Setter/equals() and hashCode()/toString()/Copyright快捷键: command + N 配置版权信息菜单栏: Android Studio -&gt; Preferences -&gt; Copyright -&gt; Copyright Profiles 共享版权信息配置我们创建的copyright文件放在项目根目录/.idea/copyright下，直接把copyright这个目录复制给团队中的其他人即可实现共享。 提取或删除代码如果我们想从for、foreach、if…elseif…else、try…catch…finally、while…do、do…while中快速提取或删除代码。 菜单栏: Code -&gt; Unwrap/Remove快捷键: command + shift + delete 自动补全提示菜单栏: Code -&gt; Completion -&gt; Basic快捷键: control + 空格 智能自动补全提示该项会把不适用的条目过滤掉，只显示可用的类、变量、属性或方法 菜单栏: Code -&gt; Completion -&gt; SmartType快捷键: control + Shift + 空格 代码补全补全后不删除后面的代码操作步骤:弹出代码补全提示 -&gt; 选中补全代码 -&gt; 鼠标/Enter 补全后删除后面的代码操作步骤:弹出代码补全提示 -&gt; 选中补全代码 -&gt; Tab 布尔值取反补全操作步骤:弹出代码补全提示 -&gt; 选中补全代码 -&gt; 叹号(!) 点和分号补全操作步骤:弹出代码补全提示 -&gt; 选中补全代码 -&gt; 点(.)或分号(;) 展开或折叠代码展开或折叠当前代码此功能仅会展开或折叠当前光标所在处的一段代码 菜单栏: Code -&gt; Folding -&gt; Expand/Collapse快捷键: command + “+”/“-“ 展开或折叠当前代码块中的所有子模块菜单栏: Code -&gt; Folding -&gt; Expand Recursively/Collapse Recursively快捷键: option + command + “+”/“-“ 展开或折叠全部代码块菜单栏: Code -&gt; Folding -&gt; Expand All/Collapse All快捷键: shift + command + “+”/“-“ 展开或折叠当前文件中的所有注释菜单栏: Code -&gt; Folding -&gt; Expand doc comments/Collapse doc comments 指定展开层级指定展开代码层级: Code -&gt; Folding -&gt; Expand to level指定全部展开代码的层级: Code -&gt; Folding -&gt; Expand all to level 展开和折叠选中区域菜单栏: Code -&gt; Folding -&gt; Fold Selection/Remove regio快捷键: command + “.” 折叠代码片段此功能来折叠{}中的代码片】= + “.” 插入代码块Live Template就是把常用的代码提取成一个模板，在编写代码的时候可以通过非常少的字幕调出这个模板，达到快速输入，提高效率的目的。 菜单栏: Code -&gt; Insert Live Template快捷键: shift + command + “.” 类中常用的缩写 geti + tab //插入单例方法 psf + tab //插入public static final psfi + tab //插入public static final int psfs + tab //插入public static final String psvm + tab //插入main方法声明 St + tab //插入String 方法中常用的缩写常用代码模板 ifn + tab //null判断 if(变量 == null){} inn + tab //非空判断 if(变量 != null){} lazy + tab //延迟初始化 if(对象 == null){ 对象 == new String();} mn + tab //得到2个变量中较小的 变量 = Math.min(变量1,变量2); mx + tab //得到2个变量中较大的 变量 = Math.max(变量1,变量2); inst + tab //判断变量是否是某个对象的实例 if(变量 instanceof Object){ Object = (Object)变量;} toar + tab //把collection的对象存储到一个数组里 .toArray(new Object[.size()]) thr + tab //抛出异常 throw new 循环遍历代码模板 fori + tab //for循环 for(int i = 0; i &lt; ;i++){} itar + tab //遍历数组 for(int i = 0;i &lt; array.length;i++){=array[i];} itco + tab //迭代器循环 for(Iterator = collection.iterator();.hasNext();){Object = .next();} iten + tab //遍历枚举内容 while(enumeration.hasMoreElements()){Object = enumeration.nextElement();} iter + tab //for each循环 for(Onject :){} itit + tab //遍历迭代器 while(iterator.hasNext()){Object = iterator.next()} itli + tab //遍历list for(int i = 0;i &lt; list.size();i++){Object o = list.get(i);} ritar + tab //倒叙遍历数组 for(int i = array.length - 1;i &gt;= 0;i--){ = array[i]} 打印代码模板 serr + tab: System.err.println(&quot;&quot;); souf + tab: System.out.printf(&quot;&quot;); sout + tab: System.out.println(&quot;&quot;); soutm + tab: //打印当前类名和方法名 soutp + tab: //打印出当前方法的所有参数列表及其值 soutv + tab: //打印一个变量值 使用代码模板包裹代码菜单栏: Code -&gt; Surround with Live Template快捷键: option + command + J C.Surround with Callable: 使用Callable包围选中的代码 RL.Surround with ReadWriteLock.readLock: 使用ReadWriteLock读锁包围选中的代码 WL.Surround with ReadWriteLock.writeLock: 使用ReadWriteLock写锁包围选中的代码 I.Iterator Iterable | Array in J2SDK 5.0 syntax: 使用遍历包围选中的代码 TR.Surround with try-with-resource: 使用try-with-resource语句包围选中的代码 查看和编辑代码模板菜单栏: Preferences -&gt; Editor -&gt; Live Templates快捷键: option + command + T 使用常用代码模板包裹代码菜单栏: Code -&gt; Surround with快捷键: option + command + T 注释代码注释行菜单栏: Code -&gt; Comment with Line Comment快捷键: command + / 注释代码块菜单栏: Code -&gt; Comment with Block快捷键: option + command + / 格式化代码菜单栏: Code -&gt; Reformat Code快捷键: option + command + L 自动缩进行菜单栏: Code -&gt; Auto-Intent Lines快捷键: option + command + I 优化导入优化导入，去除代码中无效的代码菜单栏: Code -&gt; Optimize Imports快捷键: option + command + O 重新排列代码使用使用预设的代码规则重新排列代码菜单栏: Code -&gt; Rearrange Code 移动一段代码向上移动代码菜单栏: Code -&gt; Move Statement Up快捷键: shift + command + ↑ 向下移动代码菜单栏: Code -&gt; Move Statement Down快捷键: shift + command + ↓ 移动一行代码向上移动代码菜单栏: Code -&gt; Move Line Up快捷键: option + command + ↑ 向下移动代码菜单栏: Code -&gt; Move Line Down快捷键: option + command + ↓ 正则表达式操作意图提示快捷键: option + Enter 快捷键弹出选择列表 -&gt; 单击Check RegExp -&gt; 弹出对话框，输入正则表达式和匹配样本 检查代码检查工具Android Studio提供了功能强大、快速、灵活的代码检查工具，能够检测出编译器和运行时的错误，在编译之前建议修正和改进。 Android Studio代码检查不仅能检查出编译错误，还会检查出一些效率低下的代码，支持一些代码规范、编程指南、最佳实践，还有一些无法访问，未使用的代码内存泄漏都能检查出来。 目前支持的语言有Android、Java、XML、HTML 代码检查所涵盖的最常见的任务: 发现可能的错误 定位死代码 检测性能问题 改进可维护性和代码结构 与编码准则和标准一致 符合规范 全面了解LintLint是谷歌从Android 4.1版本开始提供的代码分析工具，可以再不执行应用或测试用例的情况下检查出代码结构和质量问题。 Android Lint主要用于检查以下错误 缺少转义 布局性能问题 未使用的冗余资源 在数组中定义多个配置时，数组大小不一致 可访问行问题和国际化的问题 图标问题 可用性问题 配置文件错误 报告中的Issue 和 CategoryIssueLint检查出的所有问题都是以Issue来描述的。Issue以一个文本短语来作为id，对Issue的定制等操作都是基于id的。Issue以Severity来标识危害程度。 Category Accessibility(可访问性) Correctness(正确性) Correctness &gt; Messages(正确性:信息) Internationalization(国际化) Internationalization &gt; Bidirectional Text(双向文本) Performance(性能) Security(安全) Usability(可用性) Usability:Icons(可用性:图标) Usability:Typography(可用性:字体) Lint使用场景lint检查范围 整个项目 项目中的每个模块 项目中的每个产品模块 项目中的每个测试模块 每个打开状态的文件 每个类结构 每个版本控制系统范围 配置Lint方法 在Android Studio偏好设置中配置 在lint.xml文件中配置 在build.gradle文件中配置 在Java和XML源码中配置 Lint命令行用法介绍Usage:lint [flags] &lt;project directories&gt; Flags: 1234567--help 显示帮助命令--help &lt;topic&gt; 有关特定主题的帮助--list 列出可用的问题id，然后退出--version 输出版本信息，然后退出--exitcode 如果发现错误，将退出代码设置为1--show 提供问题列表以及完整的解释--show &lt;ids&gt; 针对指定的问题id显示完整的解释 启用检查: 1234567--disable &lt;list&gt; 禁用类别列表或特定问题id,列表应该是以逗号分隔的问题id或类别--enable &lt;list&gt; 启用特定问题列表,将检查所有默认问题和指定启用的问题，列表中应该是以逗号分隔的问题id或类别--check &lt;list&gt; 只检查特定问题列表，会先禁用一切，然后重新启用给定的列表问题。列表中应该是以逗号分隔的问题id或类别。-w, --nowarn 仅检查errors-Wall 检查所有的warnings，包括那些默认关闭的-Werror 将所有警告视为错误--config &lt;filename&gt; 使用给定的配置文件来确定问题是启用还是禁用，如果项目包含一个lint.xml文件，那么这个配置文件作为备用 输出选项 12345678--quiet 不显示进展--fullpath 错误输出使用完整路径--showall 不截断长消息，显示完整的消息--nolines 输出信息中不包括错误所在源文件中的行，默认情况下是显示的，但这个参数可以关闭--html &lt;filename&gt; 创建一个HTML报告，如果文件名是个目录，lint将会为每个被扫描的项目创建一个报告--url filepath=url 添加链接到HTML报告中，使用URL前缀取代本地路径前缀。映射可以是一个逗号分隔的路径前缀对应URL前缀的列表。--simplehtml &lt;filename&gt; 创建一个简单的HTML报告--xml &lt;filename&gt; 创建一个XML文件报告 项目选项 1234--resources &lt;dir&gt; 添加一个指定的文件夹作为项目的资源目录--sources &lt;dir&gt; 添加一个指定的文件夹作为项目的资源目录，只有在一个单独项目中运行lint时才有效--classpath &lt;dir&gt; 添加文件夹作为项目的工程类目录，只有在一个单独项目中运行lint时才有效--libraries &lt;dir&gt; 添加文件夹作为项目的类库，只有在一个单独项目中运行lint时才有效 Lint命令行用法举例 如何查看哪些id和类别是可用的 ~$ lint --list 如何禁用某项检查 ~$ lint --disable MissingTranslation, UnusesdIds,Usability:Icons 项目路径 如何启用某项检查(某些检查默认是禁用的) ~$ lint --enable MissingTranslation, UnusesdIds,Usability:Icons 项目路径 如何对项目只做某项检查 ~$ lint --check MissingPrefix 项目路径 如何查看某个id的说明 ~$ lint --show id 如何以html格式输出Lint检查结果 ~$ lint 项目地址 --html test.html 检查本地项目 ~$ lint &lt;本地项目地址&gt; --html &lt;输出的html文件名.html&gt; 检查网络项目 ~$ lint --html /tmp/report.html --url 执行一次代码检查操作步骤: 菜单栏 | 右击文件夹/文件 -&gt; Analyze -&gt; Inspect Code -&gt; 指定检查范围 -&gt; OK 详解代码检查结果辅助工具重新执行代码检查(Rerun Inspection)重新执行会覆盖上一次的执行结果 全部展开或折叠结果(Expand All/Collapse All)展开折叠结果快捷键: command + ‘+’ / ‘-‘ 在检查结果中快速上下跳转(Go Pre Problem/Go Next Problem)上下跳转的时候会同时定位到源码 自动定位到问题的源码(Autoscroll to Source)单击的时候自动定位到源码 导出代码检查结果(Export)导出代码检查结果 按严重程度分组排查问题(Group by Severity)按严重程度分组会更有目的性，通常我们需要重点关注Error的问题 按目录分组排查问题(Group by Directory)可以更直观地通过路径来排查问题 过滤已解决的问题(Filter resolved items)过滤掉已经解决的问题 快速解决问题(Apply a quickfix)只有在检查出的问题有相应的解决方案时才使用，否则是不可用的。 禁用和启用某项检查在检查结果中使用了Disable inspection选项时，这个检查项将会被禁用，也就是说你再执行代码检查时，被金庸的检查项就不会被检查了。 禁用某项检查 在检查结果中单击Android -&gt; 选中【Android Resource Validation】或具体问题 右击或单击左边工具栏的操作选项 -&gt; 单击【Disable inspection】，右击Android的问题分类或具体问题 禁用【Android Resource Validation】检查的效果。单击【Disable inspection】后并没有任何显示上的效果，再一次执行代码检查后效果就出来了 重新执行一次代码检查 启用某项检查 在检查结果中单击设置 在设置中查看被禁用的检查项。被禁用的检查项会高亮显示，所以能够很容易找到哪些检查项被我们禁用了。 勾选要启用的检查项 在偏好设置中禁用和启用某项检查操作步骤: 偏好设置 -&gt; Editor -&gt; Inspections 忽略检查 忽略Android资源验证: Android Resources Validation检查 和禁用操作相同，单击【Suppress for tag】: 忽略【Android Resources Validation】对这个标签的检查,在要忽略的标签上添加&lt;!--suppress AndroidDomInspection --&gt; 和禁用操作相同，单击【Suppress for file】: 忽略【Android Resources Validation】对这个文件的检查,在要忽略的文件上添加&lt;!--suppress AndroidDomInspection --&gt; 和禁用操作相同，单击【Suppress all for file】: 忽略这个文件的所有检查项,在要忽略的标签上添加&lt;!--suppress ALL --&gt; 忽略使用了过时的API: Deprecate API usage检查 单击【Suppress for statement】: 忽略【Deprecate API usage】对这个语句的检查,在要忽略的标签上添加//noinspection deprecation 单击【Suppress for member】: 忽略【Deprecate API usage】对这个成员的检查,在要忽略的标签上添加@SuppressWarnings(&quot;deprecation&quot;) 单击【Suppress for class】: 忽略【Deprecate API usage】对这个类的检查,在要忽略的标签上添加@SuppressWarnings(&quot;ALL&quot;) 在指定范围内执行某项检查操作步骤: 在检查结果中选中一个检查项 -&gt; 右击，执行【Run Inspection on…】-&gt; 选择检查范围 -&gt; 执行检查 解决检查出的问题选中具体问题 -&gt; 查看问题详情 Name: 显示了有问题的方法名是一个公共方法 Location: 这个方法的位置，单击可打开这个类 Problem synopsis: 问题摘要，这个方法从未使用 Problem resolution: 问题解决方案，单击可快速解决 Safe delete: 安全删除 Comment out: 注释掉 Add as Entry Point: 添加为入口点 Suppress: 忽略检查 Suppress for member: 忽略成员 Suppress for class: 忽略类 Suppress all inspections for class: 忽略类的所有检查 管理代码检查配置文件操作步骤: 菜单栏 -&gt; Android Studio -&gt; Editor -&gt; Preferences -&gt; Inspections -&gt; Manage 配置代码检查规则操作步骤: 菜单栏 -&gt; Android Studio -&gt; Editor -&gt; Preferences -&gt; Inspections 快速搜索某个检查项 过滤某一类检查项(【Show Only Cleanup Inspections】过滤出所有代码清理时用到的检查项) 清空所有选中的检查项 默认禁用新的检查和恢复默认设置 设置检查项的严重级别 Typo: 拼写错误 Server Problem: 服务端问题 Info: 详情 Weak Warning: 弱警告 Warning: 警告 Error: 严重错误 Android类目的所有检查项操作步骤: 菜单栏 -&gt; Android Studio -&gt; Editor -&gt; Preferences -&gt; Inspections -&gt; 展开Android类目 Android Resources Validation: 验证Android XML中的资源引用 Android XML element is not allowed: 验证Android Resource文件和AndroidManifest.xml中不允许的标签 Constant and Resource Type Mismatches: 常量和资源类型不匹配 Missing JNI function: 报告项目中的native方法声明在项目中没有找到相应的JNI函数 Non-constant resource ID in a switch statement: 检查在Andorid Library模块中的switch语句是否使用了Resource IDs onClick handler is missing in the related activity: 检查相关的activity是否声明了XML的onClick属性中指定的方法 Unknow Android XML attribute: 检查并高亮显示Android Resource文件和AndroidManifest.xml中未知的XML属性 Android Lint类目的检查项Accessibility(可访问性)Image without contentDescription:图片没有contentDescription属性ImageView和ImageButton这样的非文本控件应该使用contentDescription属性来描述控件。这样可访问工具就可以更好的理解控件的用途，从而更加充分的分析用户界面禁用这个警告: ignore=&quot;ContentDescription&quot; Missing labelFor attribute: labelFor 属性缺失如果minSDKVersion &gt;= 17，文本字段应该标有labelFor属性 Correctness(正确性) Accidental Octal: 意外的八进制;在Groovy中，以证书0开始的数字通常会被理解为一个八进制数 Activity registered more than once: Activity注册了不止一次 AdapterViews cannot have children in XML: 在XML中AdapterViews不能有子对象 Calling new methods on older versions: 在老版本中调用新方法 Custom views in libraries should use res-auto-namespace: 库中自定义的view应该使用res-auto-namespace Cycle in resuorce definitions: 资源循环定义 Duplicate definitions of resources: 资源重复定义 Duplicate ids within a single layout: 在一个单独的layout中有重复id Fragment not instantiatable: Fragment没有实例化 Invalid ID declaration: 无效的ID声明 Manifest Resource References: Manifest资源引用 Reference to an unknown id: 引用了一个未知的id WebViews in wrap_content parents: WebView的父视图是wrap_content Correctness &gt; Messages(正确性 &gt; 信息) Extra translation: 多余的翻译(如果一个字符串出现在一个特定的语言翻译文件中，但在默认的local中没有相应的字符串，那么这个字符串是未被使用的) Incomplete translation: 翻译不完全 Invalid format string: 无效格式的字符串 Missing quantity translation: 数量的翻译缺失 String.format string doesn`t match the XML format string: String.format 字符串不匹配XML格式的字符串 Internationalization(国际化) Byte order mark inside files: 字节顺序在文件中的标记 Encoding used in resource files is not UTF-8: 资源文件不是UTF-8格式 Hardcode text: 硬编码文件 Internationalization &gt; Bidirectional Text(国际化 &gt; 双向文本)Right-to-left text compatibility issues: Right-to-left文件兼容性问题 Performance(性能) Obsolete layout params: 过时的布局参数 Using FloatMath instead of Math: 使用FloatMath替代Math Nested layout weights: 嵌套布局weights Unused resources: 未被使用的资源 Overdraw: 过度绘制 Security(安全) Hardcoded value of android: debuggable in the manifest(最好不要在manifest中设置android: debuggable属性) Pakaged private key: 打包私钥(不应该在APP中打包私钥文件) Usability(可用性) Missing menu title: 缺失菜单标题 URL not supported by app for Google App Indexing:URl 不支持Google的App索引要确保应用支持URL，以便从Google搜索中获得安装和流量 Usability &gt; Icons(可用性 &gt; 图标) Clashing PNG and 9-PNG files: PNG和9-PNG文件冲突 Duplicated icons under different names: 在不同的名字下有重复的图标 Missing application icon: 应用程序图标缺失 Missing density folder: 密度文件夹缺失 Usability &gt; Typography(可用性 &gt; 字体) Ellipsis string can be replaced with ellipsis character: 省略号字符可以用省略号代替 Fraction string can be replaced with fraction character: 分数字符串可以用分数字符代替 Hyphen can be replaced with dash: 连字符可以用破折号代替 在lint.xml文件中配置Lint检查在Android Studio的偏好设置中可以修改Lint的配置，lint.xml文件会被自动添加到Android项目中 12345678910111213141516&lt;?xml version&quot;UTF-8&quot;?&gt;&lt;!-- Ignore the ObsoleteLayoutParam issue in the specified files --&gt;&lt;lint&gt; &lt;issue id=&quot;ObsoleteLayoutParam&quot;&gt; &lt;ignore path=&quot;res/layout/activation.xml&quot; /&gt; &lt;ignore path=&quot;res/layout-xlarge/activation.xml&quot; /&gt; &lt;/issue&gt; &lt;!-- Ignore the UselessLeaf issue in the specified file --&gt; &lt;issue id=&quot;UselessLeaf&quot;&gt; &lt;ignore path=&quot;res/layout/main.xml&quot; /&gt; &lt;/issue&gt; &lt;!-- Change the severity of hardcoded strings to &quot;error&quot; --&gt; &lt;issue id&quot;error&quot; /&gt;&lt;/lint&gt; 在Gradle中配置Lint检查在build.gradle文件中添加lintOptions的配置 123456789101112131415android &#123; lintOptions &#123; //出现error时是否停止进程 abortOnError true //关闭检查项，参数是issue id disable &apos;TypographyFractions&apos;, &apos;TypographyQuotes&apos; //开启检查项，参数是issue id enable &apos;RtlHardcoded&apos;, &apos;RtlCompat&apos;, &apos;RtlEnabled&apos; //仅检查指定的检查项，参数是issue id check &apos;NewApi&apos;, &apos;InlinedApi&apos; //设置检查项的严重等级为可忽略，参数是issue id ignore &apos;NewApi&apos;, &apos;InlinedApi&apos; &#125;&#125; 使用Gradle执行Lint检查命令行执行Lint检查./gradlew lint./gradlew lintRelease./gradlew lintDebug Gradle工具窗口执行Lint检查打开Gradle工具窗口中指定模块的任务目录，在verification下面找到对应的lint任务 双击lint 双击lintDebug 双击lintRelease 在Java和XML源码中配置Lint检查在Java源码中配置Lint配置 在Java源码中使用注解@SuppressLint(“issue id”)来禁用检查 禁用多项检查的参数为一个字符串数组，如@SuppressLint({“issue id”},{“issue id”}) 禁用所有检查的参数为all,如@SuppressLint(“all”) 在XML源码中配置Lint检查在XML源码中使用属性tools:ignore = “issue id”来禁用检查 禁用多项检查: tools:ignore = “issue id, issue id” 禁用所有检查: tools:ignore = “all” 代码清理通过代码扫描检查出好多问题，Android Studio恰好提供了Code Cleanup(代码清理)这个功能。 清理代码操作步骤: 菜单栏 -&gt; Analyze -&gt; Code cleanup 配置代码清理规则操作步骤: 菜单栏 -&gt; Analyze -&gt; Code cleanup -&gt; 单击Inspection profile右边的…可以打开代码清理检查配置界面 通过名字来指定代码检查项菜单栏或右击文件 -&gt; Analyze -&gt; Run Inspection by name -&gt; 弹出规则输入框快捷键: option + command + shift + I 配置当前文件自动检查的规则Android Studio会对当前文件自动进行代码检查，检查出问题后相关的代码会被高亮显示。 菜单栏或右击文件 -&gt; Analyze -&gt; Configure Current File Analysis快捷键: option + command + shift + H 导入并查看离线检查结果Android Studio还支持代码检查结果的导入 操作步骤: 菜单栏 -&gt; Analyze -&gt; View Offline Inspection Results 自动添加是否可为空注解 @NotNull 变量或参数不能为null @Nullable 变量或参数可以为null 分析依赖菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Dependences快捷键: command + shift + A 结果分析 选中被分析的类文件 -&gt; 在右边会显示这个类文件所依赖的文件，包括项目中的文件和外部文件 单击右边依赖的文件会在下面显示这个文件在左边类文件中的用法 查看依赖文件的用法，更好地理解文件结构 分析反向依赖反向依赖就是分析出当前文件被哪些文件所依赖 操作步骤: 菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Backward Dependences -&gt; 然后弹出分析范围对话框 分析模块依赖模块依赖分析显示指定范围内存在的所有模块和它们之间的关系 操作步骤: 菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Module Dependences -&gt; 然后弹出指定分析范围对话框 分析循环依赖循环依赖就是循环引用，是两个或多个类相互持有对方 操作步骤: 菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Cyclic Dependences -&gt; 然后弹出指定分析范围对话框 分析数据流操作步骤: 菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Data Flow to here -&gt; 然后弹出分析范围选择对话框 分析堆栈信息向更加方便和专注地分析堆栈信息的时候可以使用此功能 菜单栏: Analyze -&gt; Analyze StackTrace快捷键: command + shift + A 重构重构是指在不改变外部行为的条件下，对现有的代码进行改善，以增加可读性，使设计和逻辑更加清晰。 重命名对类、方法、字段、变量、包或其他文件进行重命名 菜单栏: Refactor -&gt; Rename快捷键: fn + shift + F6 更改方法签名方法签名由方法名称和一个参数列表组成。更改方法签名可以改变方法的名称、改变函数的可访问性，对参数进行添加、删除、重命名和重新排序。 菜单栏: Refactor -&gt; Change Signature快捷键: fn + command + F6 迁移变量类型迁移类型(Type Migration) 就是改变变量的类型 菜单栏: Refactor -&gt; Type Migration快捷键: fn + shift + command + F6 转成静态方法操作步骤: 菜单栏 -&gt; Refactor -&gt; Make Static 静态方法转为实例方法操作步骤: 菜单栏 -&gt; Refactor -&gt; Convert to Instance Method 提取变量提取变量重构是将一个表达式提取为一个变量，并使用变量替换原来的表达式 菜单栏: Refactor -&gt; Extract -&gt; Variable快捷键: option + command + V 提取常量提取常量是从临时变量快速提取出静态常量 菜单栏: Refactor -&gt; Extract -&gt; Constant…快捷键: option + command + C 提取字段提取字段重构是将选中的表达式赋值给一个新声明的字段，原来的表达式使用这个新的字段来代替。 菜单栏: Refactor -&gt; Extract -&gt; Field…快捷键: option + command + F 提取参数提取参数重构是将A中的值提取为方法A的新参数，调用方法A的地方传入参数的值，这个值为之前提取的参数值 菜单栏: Refactor -&gt; Extract -&gt; Parameter…快捷键: option + command + P 提取函数式参数菜单栏: Refactor -&gt; Extract -&gt; Functional Parameter…快捷键: option + shift + command + P 提取参数对象菜单栏: Refactor -&gt; Extract -&gt; Parameter Object 提取方法在重构代码时我们经常把复杂方法中的一段代码提取出来作为一个单独的方法使用，这种重构方法叫Extra Method 菜单栏: Refactor -&gt; Extract -&gt; Method快捷键: option + command + M 提取方法对象可以把一段代码提取为方法对象使用 操作步骤: 菜单栏 -&gt; Refactor -&gt; Extrat -&gt; Method Object… 提取委托委托是有两个对象参与同一个请求，接受请求的对象将请求委托给另一个对象来处理。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Extrat -&gt; Delegate… 提取接口提取接口重构是从一个已存在的类中提取接口，可以从某个类中选择方法，把选中的方法提取到一个单独的接口中。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Extrat -&gt; Interface… 提取父类菜单栏 -&gt; Refector -&gt; Extract -&gt; Superclass… 内联方法当一个方法的本体与方法名同样清除易懂时，就没有必要使用单独的方法了，直接把方法换成方法体即可，也就是使用内联方法进行重构。 菜单栏: Refactor -&gt; Inline快捷键: option + command + N 内联临时变量当一个临时变量只被简单地引用一次，而且会影响其他重构时，就要使用内联变量进行重构。 菜单栏: Refactor -&gt; Inline快捷键: option + command + N 查找并替换重复代码查找并替换重复代码重构时查找和赵中方法或常量字段重复或类似的代码，并通过调用此方法或常量来替换他们。 操作步骤: 菜单栏 -&gt; Refactor -&gt; File and Replace Code Duplicates… 反转布尔值反转布尔值重构是把一个Boolean方法或变量改变为相反的意义，也就是原来是true的变为false，原来是false变为true 操作步骤: 菜单栏 -&gt; Refactor -&gt; Invert Boolean 把成员拉到父类把成员拉到父类重构是把当前类的方法和属性移动到它的父类中去。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Pull Members Up… 把成员推到子类把成员推到子类重构是把父类的方法和属性移动到所有子类中，弗雷德方法可以选择性地保留抽象方法。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Push Members Down… 尽可能使用接口操作步骤: 菜单栏 -&gt; Refactor -&gt; Use Interface Where Possible… 使用委托替换继承使用委托替换继承重构是移除当前子类继承的父类，但同时又能够保留并使用父类中的一些功能。 什么时候用委托替换继承当某个子类只使用了父类的一部分功能时，或者根本就不需要继承来的数据时，就要考虑用委托替换继承。 如何使用委托替换继承Android Studio 会先在子类中创建一个私有的内部类，用来继承超类或接口。然后在子类中新建一个字段来实例化这个内部类，再委托子类中的方法来调用父类的方法。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Replace Inheritance with Delegation… 移除中间人移除中间人重构是让你不使用委托方法而直接调用受委托的类 操作步骤: 菜单栏 -&gt; Refactor -&gt; Remove Middleman… 包装方法返回值包装方法返回值重构是使用一个新建的包装类来替换一个方法的返回值，这个类也可以是已存在的类。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Wrap Return Value… 将匿名类转成内部类匿名类转成内部类重构可以把一个匿名类转成内部类，这样一来这个类的其他部分就可以共享此类。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Convert Anonymous to Inner… 封装字段封装字段重构可以隐藏数据，然后创建访问器来访问。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Encapsulate Field… 使用查询替换临时变量如果一个临时变量保存了一个表达式，使用查询替换临时变量重构就是将这个表达式提炼到一个独立的方法中，并将这个临时变量的所有引用点替换为新的方法的调用。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Replace Temp with Query… 使用工厂方法替换构造方法使用工厂方法替换构造方法重构是使用一个静态方法返回一个实例化的类来替换原来的构造方法。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Replace Constructor with Factory Method … 使用构造器替换构造方法当创建一个对象需要传入多个参数的时候我们通常会根据参数的数量写多个不同的构造方法，但是这种方法不够灵活，可读性也不高。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Replace Constructor with Builder… 泛型化泛型化重构用来将那些没有使用泛型的代码转化为泛型可识别的代码 操作步骤: 菜单栏 -&gt; Refactor -&gt; Gentrify… 配置对话框 Drop obsolete casts: 删除过时的转换 Leave Object-parameterized types raw: 保留对象参数化类型 Preserve raw arrays: 保留原始队列 Perform exhaustive search: 执行穷举搜索 Generify Objects: 泛型化对象 Produce wildcard types: 产生通配符类型 国际化国际化重构就是从源代码中提取字符串，并将它们作为属性写入属性文件中，再通过生成的表达式来读取Resource Bundle中的属性来获得多语言的字符串。 操作步骤: 菜单栏 -&gt; Refactor -&gt; Internationalize… 构建Android Studio默认使用Gradle来进行项目构建，Gradle是一个自动化构建工具，采用Groovy的Domain Specific Language来描述和控制构建逻辑。 认识GradleGradle是一个自动化构建工具。特点： Gradle支持多工程构建和局部构建 Gradle支持远程或本地依赖管理：支持从远程maven仓库，nexus私服，ivy仓库以及本地仓库获取依赖 Gradle与Ant、Maven兼容 Gradle可轻松迁移：Gradle适用于任何结构的工程，可以在同一个开发平台平行构建原工程和Gradle工程 Gradle使用灵活：Gradle的整体设计是以作为一种语言为向导的，而非成为一个严格死板的框架 Gradle免费开源 Gradle跟IDE集成得非常好 Gradle可以更容易地集成到自动化构建系统 Gradle的Project、Task、和Plugin项目是指构建产物或部署的产物。每个项目包含一个或多个任务。任务是指不可分的最小工作单元，代表一个逻辑上较为独立的执行过程。 Gradle中依赖的仓库在build.gradle中添加仓库的声明，从Maven仓库中获取依赖 1234567891011121314151617181920212223242526272829repositories &#123; #1.从指定的远程Maven仓库中获取依赖 maven &#123; url &quot;http://maven.helloword.net/repo&quot; &#125; #2.从指定的本地Maven仓库中获取依赖 maven &#123; url &quot;file:///Users/bixiaopeng/mvn&quot; &#125; #3.从中央Maven仓库中获取依赖 mavenCenter() #4.从新的中央远程仓库中获取依赖 jcenter() #5.从本地仓库中获取依赖 mavenLocal() #6.需要认证的库 maven &#123; credentials &#123; username &apos;user&apos; password &apos;password&apos; &#125; url &quot;http://repo.helloword.com/maven2&quot; &#125;&#125; Maven仓库的别名 mavenCentral(): 表示从Maven中央仓库中获取依赖 jcenter(): 一个新的远程中央仓库，兼容Maven中央仓库，而且性能更优。Gradle默认使用jcenter作为仓库。 mavenLocal(): 表示从本地Maven仓库中获取依赖 从平级目录仓库中获取依赖从本地目录中获取依赖，在build.gradle中添加 123456789repositories &#123; //从当前项目的平级目录lib中获取依赖 flatDir(dir: &apos;lib&apos;,name: &apos;libs directory&apos;) //从当前项目的平级目录libA 和 libB中获取依赖 flatDir &#123; dirs &apos;libA&apos;,&apos;libB&apos; name = &apos;All dependency directories&apos; &#125;&#125; 配置Gradle环境 编辑.bash_profile vim ~/.bash_profile 配置环境变量 export GRADLE_HOME=grale路径 export PATH = $PATH: $GRADLE_HOME/bin 使配置立即生效 source ~/.bash_profile 查看配置是否生效 gradle -v Gradle Wrapper认识Gradle WrapperGradle Wrapper可以理解为Gradle的一层封装，使用它可以在没有安装Gradle的系统上使用Gradle来构建项目。 在gradle/wrapper目录下有两个文件:gradle-wrapper.jar和gradle-wrapper.properties 查看和执行Gradle任务查看当前项目支持的Gradle任务使用./gradlew task 来查看单签项目支持哪些Gradle任务 想查看所有任务和更多详情 gradlew tasks -all 想查看一个任务的更多详情 gradlew help --task &lt;task&gt; 执行Gradle任务执行命令: “gradle + 任务名称” 或者 “./gradlew + 任务名称” 常用Gradle任务 查看gradle版本 ./gradlew -v 编译并打出Debug版本的包 ./gradlew assembleDebug 编译并打开Release版本的包 ./gradlew assembleRelease 执行检查并编译打包,打出所有Release和Debug的包 ./gradlew build 删除build目录，会把app下面的build目录删掉 ./gradlew clean 编译打包并安装Debug版本的包: ./gradlew installDebug 卸载Debug版本的包: ./gradlew uninstallDebug 使用-info查看任务详情: ./gradlew uninstallDebug -info Gradle工具窗口Gradle工具窗口列出了当前项目和模块中支持的所有Gradle任务和运行配置，以便我们快速操作。 TasksTasks列表里的任务跟我们执行./gradlew task得到的任务列表是一样的。把光标放在某个任务上面会显示任务的描述信息。双击任务即可执行。 Run ConfigurationsRun Configurations列表中列出了项目中执行过的任务配置，这些配置都是执行任务时自动生成的。想再次执行的时候可以在配置列表中直接选择。 构建项目和模块编译项目当我们只想对修改过的文件进行编译时就会使用Make进行编译，可以指定对项目或者模块进行编译 菜单栏: Build -&gt; Make Project快捷键: command + F9 编译模块前提条件: 选中某个模块操作步骤: 菜单栏 -&gt; Build -&gt; Make Module’模块名’ 设置自动编译项目操作步骤: Android Studio -&gt; Preferences… -&gt; 搜索Compiler -&gt; 勾选Make project automatically 重新构建项目操作步骤: 菜单栏 -&gt; Build -&gt; Rebuild Project(重新构建项目) Make Project跟Rebuild Project的区别Make Project是对新产生变化的文件进行一次编译，已经编译过的文件就不用重新编译，Rebuild Project是对整个项目重新编译，用时更久。 清理项目清理项目会清空output目录下的文件，并重新编译项目操作步骤: 菜单栏 -&gt; Build -&gt; Clean Project Gradle ScriptGradle Scripts列表: build.gradle: 项目构建配置文件 build.gradle: 模块构建配置文件 gradle-wrapper.properties: gradle wrapper配置文件 proguard-rules.pro: 混淆规则配置文件 graddle.properties: gradle配置文件 setting.gradle: 项目全局配置文件 local.properties: SDK、NDK配置文件 Gradlew配置文件gradle-wrapper.properties这个文件一般是不动的，除非想手动指定Gradle的版本，可以修改distributionUrl。也可以在Project Structure -&gt; Project中设置Gradle version 项目全局配置文件setting.gradle主要声明一些需要加入构建的模块 本地属性配置文件local.properties在Project Structure -&gt; SDK Location 中设置SDK和NDK的路径，修改后会同步到local.properties文件中。 Gradle配置文件gradle.propertiesgradle.properties是Gradle的配置文件，build.gradle通过独缺这个文件配置的参数来进行相应的构建。 代码混淆规则配置文件proguard-rules.pro如果想在打包的时候进行代码混淆，就需要在proguard-rules.pro中配置代码混淆规则。 项目构建配置文件build.gradle1234567891011121314151617181920212223242526272829303132//项目构建文件，可以到各子项目/模块添加常用的配置选项buildscript &#123; //Android插件从这个仓库中下载 repositories &#123; jcenter() //依赖仓库源的别名，兼容maven的远程中央仓库 &#125; //依赖 dependencies &#123; //android gradle插件 classpath &apos;com.android.tools.build:gradle:2.2.0-alpha1&apos; //提示 //请不要在此处添加应用程序依赖；他们应该在单个Module build.gradle文件中添加 //这里添加的应该只是Project的依赖 &#125; //此处配置Project中默认的仓库员，包括每个module的依赖 //这样每个module就不用单独配置仓库了 allprojects &#123; repositories &#123; jecnter() &#125; &#125; //打包前执行clean任务 //任务类型是Delete //clean任务就是删除项目根目录下的build目录 task clean(type: Delete) &#123; delete rootProject.buildDir &#125;&#125; 模块构建配置文件build.gradleModule: build.gradle用来配置模块的构建任务 在项目结构中配置模块构建Project Structure用来配置项目和模块的各种构建参数和属性 配置应用程序属性 Compile Sdk Version: 指定Android的编译版本 Build Tools Version: 指定构建工具的版本 Library Repository: 指定依赖的仓库源 Ignore Assets Pattern: 指定构建打包时要忽略的文件 Incremental Dex: 增量Dex打包，开启此功能可以提升编译打包的速度 Source Compatibility: 指定资源版本 Target Compatibility: 指定目标版本 配置应用程序签名在这里配置了签名，相应地在module app的build.gradle文件中会自动添加下面的配置 123456789//签名配置signingConfigs &#123; MySigning &#123; keyAlias &apos;myandroid&apos; keyPassword &apos;123456&apos; storeFile file(&apos;钥匙库路径&apos;) storePassword &apos;123456&apos; &#125;&#125; 配置应用程序特性多渠道打包要在Flavors配置相应的属性 Name: Flavor的名字，如我们常用的渠道xiaomi,baidu Min Sdk Version: 向下兼容的最小SDK版本 Application Id: 应用程序的包名 Proguard File: 指定混淆文件路径，如果不指定会使用默认的 Signing Config: 指定签名文件。签名的文件在Signing中设置 Target Sdk Version: 目标SDK版本 Test Instrumentation Runner: 指定Test Runner Test Application Id: 测试应用的ID Version Code: 应用程序的版本号，用于升级 Version Name: 应用程序的版本名称 Version Name Suffix: 应用程序版本名称的后缀 配置应用程序的构建类型构建类型Build Types非常重要，默认两个构建版本: debug 和 release Name: 构建类型名称 Debuggable: 是否可以调试 Jni Debuggable: Jni是否可以调试 Proguard File: 指定混淆文件路径，如果不指定会使用默认的 Signing Config: 指定签名。签名的文件在Signing中设置，若为空则不签名，打出来的包也是未签过名的 Renderscript Debuggable: 是否使用渲染脚本 Renderscript Optim Level: Rendescript版本 Minify Enabled: 是否混淆 Target Sdk Version: 目标SDK版本 Pseudo Locales Enabled: 是否支持本地化整理 Application Id Suffix: 应用程序Id后缀 Version Name Suffix: 应用程序版本名称的后缀 Zip Align Enabled: 是否支持Zip Align Project Structure没有的配置，但buildTypes支持的属性如下 buildConfigField &quot;boolean&quot;,&quot;LOG_DEBUG&quot;,&quot;true&quot; 显示Log shrinkResources true 移除无用的resource文件，minifyEnabled必须为true 签名和打包Android系统要求应用程序必须经过签名才能够安装到系统中，签名就是在应用程序特定的字段中些人标识信息，Android系统通过签名判断你是否是这个应用程序的开发者。 签名相同的应用程序: 能够正常地覆盖安装旧版本 能够允许代码和数据共享 默认签名证书Android SDK工具会自动生成一个调试用的签名证书debug.keystore 当我们打debug包时，默认使用debug.keystore进行签名。debug包可以在真机和模拟器上运行和调试，但不能发布到应用市场。对外发布时要使用统一的签名。 自动打包和签名 配置签名证书。打开Project Structure窗口 选择app模块 单击Signing标签 新增一个签名证书的配置 选择证书，填入相关信息 配置构建类型 单击Build Types标签 选择release Signing Config这一项选择刚才我们配置的签名 自动打包和签名 ./gradlew assembleRelease 混淆打包为了防止反编译，增加反编译成本，使用ProGuard进行混淆，通过删除从未使用的代码和使用晦涩名字来重命名类、字段和方法，从而对代码进行压缩、优化和混淆。在build.gradle中打开混淆开关，minifyEnabled设置为true 多渠道打包国内Android应用程序有360、小米、豌豆荚、百度等非常多的下载渠道，想统计每个渠道的下载量和活跃度，就需要使用统计平台。以友盟统计为例，配置渠道信息并执行自动化打包 在AndroidMainfest.xml配置可动态替换的渠道参数123&lt;meta-data android: name = &quot;UMENG_CHANNEL&quot; android: value = &quot;$&#123;CHANNEL_ID&#125;&quot; 在build.gradle中配置渠道信息和自动替换脚本1234567891011//多渠道打包productFlavors &#123; xiaomi() //渠道名为xiaomi baidu() wandoujia() //自动替换AndroidManifest.xml中的渠道号 productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceHolders = [CHANNEL_ID: name] &#125;&#125; 打包后自动修改apk的名字12345678910111213141516171819//打包后自动修改apk的名字//release包的命名格式为: 产品名_版本号_渠道号.apk//debug包的命名格式为: 产品名_版本号_渠道号_Debug_打包时间.apkapplicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (null != outpoutFile &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123; File outputDir = new File(outputFile.parent); def baseName = PRODUCT_NAME + &quot;$&#123;defaultConfig.versionName&#125;&quot; + &quot;_&quot; + variant.productFlavors[0].name def newApkName if (variant.buildType.name.equals(&apos;release&apos;)) &#123; newApkName = baseName + &apos;.apk&apos; &#125; else if (variant.buildType.name.equals(&apos;debug&apos;)) &#123; newApkName = baseName + &quot;_Debug_$&#123;packageTime()&#125;.apk&quot; &#125; output.outputFile = new File(outputDir,newApkName) &#125; &#125;&#125; 自动化打包方法一: 命令行./gradlew assembleRelease 方法二: Gradle工具窗口方法三: 菜单栏 -&gt; Build -&gt; Generate Signed APK -&gt; 一步步下去 -&gt; 在Flavors中全选 -&gt; Finish 查看渠道号是否被正确替换单击apk后，Android Studio会自动解析apk，这样就可以在Android Studio中直接查看apk的信息了。 运行和调试运行和配置调试菜单栏: Run -&gt; Edit Configurations…快捷键: control + alt + R Android应用程序配置Name在这里输入配置的名字，会在工具栏运行应用程序配置的下拉列表中看到 General在这里配置安装、启动、部署应用程序选项 1、 Module: 列表中列出了当前项目中的所有模块，可以指定相应的模块来运行2、 Installation Options: 安装选项 Deploy: 下拉列表中列出了应用程序运行时的部署模式 Default APK: 部署默认的APK，运行时会先打包安装，再启动APK Custom Artifact: 部署自定义的APK，会根据所选择的模块来选择相应的配置 Nothing: 不做任何部署，运行时直接启动应用，如果应用已经安装了会直接启动，没有安装就会报错。 Install Flags: 给adb shell pm install 添加运行参数 Launch Options: 启动选项 Default Activity: 启动默认Activity，运行时会启动默认的MainActivity，如果没有就会报错。 Specified Activity: 指定启动的Activity Nothing: 运行时不会启动任何Activity URL: 在这里可以指定启动的scheme Launch Flags: 给sdb shell am 添加运行参数，参数添加在命令的最后面 Deployment Target Options: 部署目标选项 Target Show Device CHooser Dialog: 每次运行弹出选择设备对话框 USB Device: 使用USB连接的设备 Emulator: 使用模拟器 Use same selection for future launches: 以后每次运行都是用同样的选择。 Miscellaneous在这里配置日志和安装选项 1、Logcat Show logcat automatically: 运行时自动显示logcat日志 Clear log before launch: 启动前清空日志 2、Installation Options Skip installation if APK has not changed: 如果代码没有变更，运行时跳过安装 Force stop running application before launching activity: 启动Activity前强制关闭运行的应用程序。 Debugger在这里配置调试类型 Profiling在这里配置图形跟踪选项 Disable precompiled shaders and programs: 禁用预编译着色器和程序 Before launch在这里可以配置运行之前需要执行的任务，默认会执行Make 添加任务 任务 说明 Run External tool 运行外部工具，如果有的话可以直接选择，如果没有可以去新建 Make 编译选择的模块 Make Project 编译项目 Make,no error check 编译选择的模块，但不进行错误校验 Build Artifacts 构建构件，如果有的话可以选择对应的构件 Run Gradle task 运行Gradle任务 Gradle-aware Make 执行Gradlew任务 运行应用程序运行应用程序菜单栏: Run -&gt; Run…快捷键: control + alt + R 清理后重新运行应用程序菜单栏: Run -&gt; Clean and Return’配置名’快捷键: command + alt + R 停止应用程序运行菜单栏: Run -&gt; Stop’配置名’快捷键: command + fn + F2 调试应用程序断点行断点行断点是我们最常用到的断点，被用于对代码特定的行进行调试 菜单栏: Run -&gt; Toggle Line Breakpoint快捷键: command + F8 单击某行左边栏即可设置断点取消断点和添加行断点的方法相同 属性设置: 右击行断点，弹出属性设置对话框 Enabled: 断点启用和禁用 Suspend: 勾选All,执行到断点时所有线程都会被挂起。勾选Thread，执行到断点时只有当前断点所在的线程会被挂起。 Condition: 设置断点暂停条件 方法断点方法断点主要用来检查方法的输入和输出 操作步骤: 菜单栏 -&gt; Run -&gt; Toggle Method Breakpoint -&gt; 单击方法名所在行的左边栏 属性设置: 右击行断点，弹出属性设置对话框。和行断点相比属性多了一个Watch，Method entry 和 Method exit表示调用此方法开始的时候和结束的时候断点都会被触发。 字段观察点当我们对程序运行的过程不太关心，只关心某个变量的变化时可以使用字段观察断点 操作步骤: 菜单栏 -&gt; Run -&gt; Toggle Field Watchpoint -&gt; 单击字段所在行的左边栏 属性设置: 右击行断点，弹出属性设置对话框。和行断点相比属性多了一个Java Field Watchpoints。Field access(当字段被访问的时候触发断点)和Field modification(当字段被修改时触发断点) 条件断点条件断点用来设置断点被触发的条件，如果条件不满足断点是不会被触发的。 操作步骤: 右击左边栏的断点图标 -&gt; 勾选Condition -&gt; 设置暂停条件 临时断点当我们想某个断点只被触发一次后就自动删除的时候，可以使用临时断点 菜单栏: Run -&gt; Toggle Temporary Line Breakpoint快捷键: fn + command + option + shift + F8 如果想把临时断点变为普通断点，可以在属性中取消勾选【Remove once hit】 异常断点异常断点会在某个异常发生时触发断点，我们就可以第一时间得到异常信息，方便排查问题 菜单栏: Run -&gt; View Breakpoints快捷键: fn + command + shift + F8 在打开的断点窗口单击左上角的加号，选择Java Exception Breakpoints，然后在弹出的【Enter Exception Class】窗口中输入要调试的异常。 日志断点在调试的时候，我们想临时多加一些日志但又不想重新构建应用程序的时候，可以使用日志断点 操作步骤: 右击左边栏的断点图标 -&gt; 取消勾选【Suspend】 -&gt; 在展开的选项中勾选【Log evaluated expression】 -&gt; 输入日志信息表达式。 因为取消了Suspend，所以执行到断点出不会停下，而是会打印日志。 禁用断点当某个断点暂时不需要但又不想删除时可以先禁用 菜单栏: Run -&gt; Toggle Breakpoint Enable快捷键: option + 单击断点 断点设置打开属性配置窗口菜单栏: Run -&gt; View Breakpoints快捷键: fn + shift + command + F8调试工具窗口: 单击左边工具栏的View Breakpoints右击断点的图标: 单击More 断点管理: 断点按类型进行分组，在这里可以新建和删除断点 常用设置: 在编辑器窗口中右击断点图标就能够设置这些属性 日志断点设置: 在这里可以设置日志断点的属性 其他设置: 设置临时断点，以及选中的断点被执行后是禁用还是丢弃当前断点 过滤: 设置断点的一些限制，如作用于实例的ID，指定类以及有效次数 预览窗口: 在这里查看断点所在的代码位置 帧调试窗口帧调试窗口显示了当前断点所在的线程以及执行到该断点所调用过的方法。 堆栈帧堆栈帧是用来存储数据和不服你过程结果的数据结果，同时也用来处理动态链接、方法返回值和异常分派。每一次调用方法在队长总都会占用一部分内存，单位是帧。堆栈帧随着方法调用而创建，随着方法结束而销毁。每个堆栈帧中都包括传入的参数、返回地址、方法存储在堆栈上的局部变量以及对程序调试提供支持的信息。一个线程包括多个堆栈帧。 当前堆栈帧一个线程在执行过程中，执行到断点处暂停，如果只有当前正在执行的那个方法的堆栈帧是活动的，这个堆栈帧就是当前堆栈帧。 帧调试窗口: 显示当前断点所在的线程 显示执行过的方法，也可以说是执行到当前堆栈帧这个过程中所创建过的堆栈帧 查看工具: 查看执行过的帧和过滤当前应用的帧 内容菜单: 右击堆栈帧，显示可操作菜单 Add Stepping Filter(添加步进过滤器): 使用此命令再打开的对话框中添加一个步进过滤器 Export Threads(导出线程) Customize Threads View(自定义线程显示) 变量调试窗口我们可以再变量调试窗口中检查应用程序中对象值得存储，当选择堆栈帧的时候，变量调试窗口就会显示范围内的所有数据(方法的参数、本地变量和实例变量) Inspect检查功能用来检查字段、局部变量和表达式的引用，既可以打开一个非模式检查窗口，也可以按照需求打开多个检查窗口 操作步骤: 右击要检查的字段 -&gt; 局部变量或表达式 -&gt; Inspect -&gt;弹出一个非模式检查窗口 Mark Object标记对象功能可以给对象添加标签，看起来更加直观 操作步骤: 右击要标记的对象 -&gt; 选择Mark Object或按快捷键fn+F3 -&gt; 然后在弹出的窗口输入对象的标签 Set Value用来更改运行时字段或变量的值 Copy Value用来复制变量或结构。当选中一个变量来复制时可以复制变量的值，当选择多项时会复制整个结构 Compare Value with Clipboard跟剪切板中的值比较 Copy Name复制变量的名字 Evaluate Expression计算表达式 Add to Watches添加到见识窗口会把选择的变量或表达式添加到监视窗口，在我们调试应用程序的时候监视窗口会显示对应的表达式或变量的值。 Show Referring Objects显示选中变量引用的对象列表 Jump to Source跳转到所选变量或字段的源码 Jump to Type Source打开源代码中所选变量或字段的类型 View Text用来显示所选变量的文本 Customize Data Views自定义数据显示 监视窗口监视窗口用来计算当前堆栈帧范围内的变量或表达式，在调试的过程中通过监视窗口来监视变量或表达式的值 添加变量或表达式到监视窗口监视变量 在Variables窗口中点击变量 -&gt; Add to Watches，然后在右边的监视窗口将会出现变量 在Watches窗口中单击左下角的+按钮 -&gt; 输入变量名，会弹出智能联想，选中后添加成功。每当程序执行到包含a变量的时候，监视窗口的值会随着a变量值的变化而变化，达到监视的目的 监视表达式 按快捷键fn+option+F8，进入计算表达式窗口，输入所要监视的表达式 在Watches窗口中单击左下角的+按钮 -&gt; 输入表达式 快捷工具利用监视窗口底部的工具栏可以快速方便地进行新建、删除、移动、复制操作。 调试控制工具调试控制工具常用功能 暂停、恢复程序运行 终止进程 查看、禁用断点 获取线程堆栈 View Breakpoints(查看断点)打开断点对话框、配置断点属性 Mute Breakpoints(禁用断点)禁用断点功能可以切换断点状态。 Get thread dump(获取线程堆栈)显示线程堆栈面板 Restore Layout(恢复布局)恢复布局功能可以恢复到原始的布局，当前所有的布局变更都会被放弃 (Settings)设置 Show Values Inline: 选中后启动内联调试功能，允许在编辑器中观察执行过的变量的值 Show Method Return Values: 选中后会显示上次执行方法的返回值 Auto-Variables Mode: 选中后调试器可以自动评估某些变量 Sort Values Alphabetically: 选中后窗口中的变量值按字母的顺序排列 Unmute Breakpoints on Session Finish: 选中后当一个调试回话完成就会重新启用所有禁用的断点 步进调试工具Show Execution Point(显示执行点)当我们需要查看当前的执行点时，光标会立刻定位到当前执行到的断点快捷键: fn + option + F10 Step Over(单步跳过)执行单步跳过，就会执行下一行。如果下一行是一个方法，就不会进入方法体，而是会执行完此方法，然后跳到下一行。快捷键: fn + F8 Step Into(单步进入)执行单布进入，会执行下一行。如果下一行是一个方法，且该方法如果是自定义的方法，则会进入方法内，如果是官方类库的则不会进入。快捷键: fn + F7 Force Step Into(强制进入)执行强制进入，会进入任何方法，不管该方法是自定义的还是官方类库的快捷键: fn option + shift + F7 Force Step Out(单步跳出)执行单步跳出，会跳出当前进入的方法，返回该方法被调用处的下一行。快捷键: fn + shift + F8 Drop frame(丢弃帧)如果你已经进入了某个方法内，执行丢弃帧，当前方法会被中断，并返回当前方法被调用的地方。另外，变量的值也会回到最初。 Run to Cursor(运行到光标处)在调试时，光标可以放在任意一行。程序会运行到光标所在行暂停。 Evaluate Expression(计算表达式)会打开计算表达式窗口快捷键: fn + option + F8 计算表达式当我们想临时修改某个变量的值或查看其内部方法返回值的时候，可以使用计算表达式功能。 Expression Mode: 计算单行表达式 Code Fragment Mode: 计算代码片段，可以对声明、赋值、循环和if/else进行计算 使用表达式计算功能时需要注意一下两点 只有在调试并且断点被触发的时候，才可以使用计算表达式功能，也就是说如果不是在调试的住鞥太，计算表达式功能是不可用的 如果计算表达式调用一个方法，方法内又恰好有断点，那么该断点会被忽略，直接计算出表达式的值。 在堆栈帧中计算表达式或代码片段菜单栏: Run -&gt; Evaluate Expression快捷键: fn + option + F8 在帧调试窗口中，选择想要计算表达式的堆栈帧 调用计算表达式功能 选择计算模式 输入表达式或语句 执行计算 计算任意表达式在变量调试窗口中右击变量 -&gt; Evaluate Expression -&gt; 之前选中的变量会显示在表达式输入框中。在这里我们可以切换计算模式、查看计算过的历史、输入表达式。 快速计算表达式的值前提条件: 将光标放在表达式上或选中表达式菜单栏: Run -&gt; Quick Evaluate Expression快捷键: fn + option + command + F8 选中表达式立即显示表达式的值在调试工具栏上单击设置按钮，勾选【show value on selection change】，然后选中表达式，会在表达式的上面显示计算出来的结果。 关联调试到Android进程通常我们调试应用程序时，需要先添加断点，再运行调试。这样做会比较慢，因为需要重新部署应用程序。Android Studio提供了一种方法可以随时调试应用程序，不管当前应用程序是否以调试模式运行。 前提条件: 应用程序已经在设备上运行，已添加断点操作步骤: 菜单栏 -&gt; Run -&gt; Attach Debugger to Android Process或在工具栏中单击按钮 配置和运行单元测试配置和运行本地单元测试本地单元测试用来执行那些对Android没有依赖或Android依赖容易mock的单元测试本地单元测试运行在自己电脑上，测试用例在本地虚拟机上编译运行，执行速度快。本地单元测试写在app/src/test/java目录下本地单元测试使用JUnit或TestNG测试框架 在项目窗口中的类名上右击 -&gt; Run 测试类 保存临时配置通过上面的方法运行完测试之后，在工具栏的运行配置列表中显示了刚才运行的测试类。这个配置是自动生成的，如果需要保存，单击【Save ’测试类名‘ Configuration】 配置本地单元测试需要自定义本地单元测试配置时，可以打开Run/Debug Configurations对话框 -&gt; 单击左上角的+号 -&gt; JUnit，然后新增一个JUnit配置窗口 Name: 输入配置名 Use classpath of module: 选择测试模块，下拉列表中会列出项目所有的模块，选择我们需要测试的。 Test kind: 选择一种测试范围，本例中选择的是Class Class: 显示测试类的配置项 Method: 显示测试类和方法的配置项 测试用例配置:Class，选择测试类 Fork mode: 用来指定是为每个测试用例都创建一个进程还是所有测试用例在一个进程中执行。 none: 在一个进程中执行所有测试 method: 每个测试用例都会创建一个测试进程，这种方式会比较慢 Repeat Once: 所有用例只执行一次 N Times: 自定义用例执行次数 Until Failure: 不断重复执行，直到用例失败 Until Stopped: 不断重复执行，直到手动停止 VM options: 默认值为-ea，用来设置jvm是否启动断言机制 JER: 使用默认的设置即可 使用命令行运行单元测试./gradlew test执行Gradle测试任务所有的测试用例都会被运行，然后会产生测试报告。测试报告存放在app/build/reports/debug/index.html里 配置Android单元测试Android单元测试Android单元测试用来执行那些有Android依赖或Android依赖不好mock的单元测试Android单元测试运行在真机或模拟器上Android单元测试写在app/src/androidTest/java目录下Android单元测试使用Android Tests测试框架 配置Android单元测试需要自定义本地单元测试配置，可以打开Run/Debug Configurations对话框 -&gt; 单击左上角的+号 -&gt; Android Tests，新增一个Android Tests配置窗口 Name: 输入配置名 Module: 选择需要测试的模块 Test: 指定测试范围 指定instrumentation runner 指定目标设备 工具Android Studio中集成了很多非常好用的工具，除了IntelliJ IDEA 自带任务管理、生成Java Doc等工具，还集成了以前放在SDK目录中可以独立运行的Android开发工具，如Android Monitor、Android SDK Manager、模拟器等，现在他们已经被全部集成到了Android Studio当中，而且变得更好用。 任务Android Studio支持与很多任务跟踪管理系统进行集成，只要配置一个任务跟踪管理系统并与我们的账号进行绑定，就可以方便地创建、跟踪、处理分配给自己的任务。一个任务可以对应多个changelist，changelist就是我们修改过的文件。我们可以给每一个changelist起名字，当完成一项任务后，可以选择提交相应的changelist。 配置任务进入配置界面 偏好设置 -&gt; Tools -&gt; Tasks -&gt; Servers Tools - &gt; Tasks &amp; Contents -&gt; Configure Servers open task 右上角的setting 配置JIRAJIRA是集项目计划、任务分配、需求管理、错误跟踪于一体的商业软件。 进入服务器配置界面: 偏好设置 -&gt; Tools -&gt; Tasks -&gt; Servers 添加JIRA服务器: 单击【+】按钮，选择JIRA 输入URL和账号: 输入JIRA的URL地址，再输入用户名和密码 配置GitHub 进入服务器配置界面: 偏好设置 -&gt; Tools -&gt; Tasks -&gt; Servers 添加JIRA服务器: 单击【+】按钮，选择GitHub 输入URL和账号: 输入相关信息 配置Gitlab 进入服务器配置界面: 偏好设置 -&gt; Tools -&gt; Tasks -&gt; Servers 添加JIRA服务器: 单击【+】按钮，选择Gitlab 输入UR和Token并选择对应项目 打开任务直接打开任务菜单栏: Tools -&gt; Tasks &amp; Contents -&gt; Open Tasks快捷键: option + shift + N 搜索任务如果任务太多需要搜索，通过输入任务名会进行相关的匹配 包括已关闭的任务默认显示的任务都是未关闭状态的，如果想查看已关闭的任务，需要勾选【Include closed tasks】 查看任务的描述和注释信息使用fn + F1键可以查看任务的描述和注释信息 切换任务并合并上下文在Open Task界面，选中一个任务，按Shift + 回车键会切换到选中的任务，上下文会合并。 创建新任务在Open Task界面输入新任务的名字，按回车键就会开始创建 新建一个任务的时候会新建一个分支，分支的名字默认为任务名，可以随意修改，它会跟任务相对应。默认情况下，新建一个任务时会清空前一个任务的上下文。如果不想清空，需要取消勾选【Clear current context】 任务变更列表新建changelist输入新的changelist的名字。 提交change list菜单栏: VCS -&gt; Commit Changes快捷键: command + K 切换/关闭任务切换任务操作步骤: 工具栏 -&gt; 打开任务列表 -&gt; 双击切换切换任务以后，之前任务的上下文会被关闭 关闭任务当一个任务完成以后，可以通过菜单栏: Tools -&gt; Tasks&amp;Contexts -&gt; Close Active Task或者快捷键option + shift + W 来关闭任务 管理上下文上下文是什么上下文(Context)是指与一个任务(Task)相关的在在编辑器中被打开的文件，包括变更列表、编辑器、项目查看状态、运行配置和断点。上下文与任务是密切相关的，新建一个任务，上一个任务的上下文是要被清空的，表现就是工作去已打开的文件全部被关闭，然后新的上下文就开始被建立。 保存上下文菜单栏: Tools -&gt; Tasks&amp;Contexts -&gt; Save Context -&gt; 弹出之前保存过的context list 在这个列表里加载、合并、移除上下文。 清除上下文清除上下文功能会把所有上下文信息全部清除。菜单栏: Tools -&gt; Tasks&amp;Contexts -&gt; Clear Context JavaDocJavaDoc是Sun公司提供的一个技术，从源代码中抽取类、方法、成员等主食形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签做注释，在程序编写完成后，通过JavaDoc就可以同时形成程序的开发文档了。 配置JavaDoc操作步骤: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; JavaDoc 生成JavaDoc菜单栏: Tools -&gt; Generate JavaDoc 来指定生成JavaDoc的范围和参数。在这里可以指定生成JavaDoc的范围、输出目录、输出内容和参数。 特备注意Other command arguments的配置，如果项目中使用的是UTF8有编码格式，在这里要指定参数: -encoding utf-8 -charset utf-8，否则生成的JavaDoc中文会出现乱码。 生成JavaDoc时会先执行Gradle构建任务 如果生成JavaDoc时报错说 android.jar 找不到，就需要在 Dependencies 中添加 android.jar 将当前文件保存为模板前提条件: 光标定位在编辑界面操作步骤: 菜单栏 -&gt; Tools -&gt; Save File as Template -&gt; 弹出模板配置窗口 -&gt; 单击【OK】按钮后模板被创建 当新建一个文件时，可以看到刚才创建的模板选项。 如果想删除或重新编辑模板，就单击删除按钮或在菜单栏中单击File -&gt; New -&gt; 【Edit File Templates】 IDE Scripting Console使用 IDE Scripting Console 可以测试Groovy的代码片段操作步骤: 菜单栏 -&gt; Tools -&gt; IDE Scripting Console 管理Android SDKAndroid SDK 管理Android Studio中使用的SDK和工具，我们可以在这里查看、安装、启动、删除SDK。 菜单栏: Tools -&gt; Android -&gt; SDK Manager偏好设置: Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK 管理Android SDK平台每个Android SDK平台的安装包都默认包含了与API级别对应的Android平台和相关的源码。 管理SDK开发工具和更新站点SDK Tools选项卡中显示了Android SDK的开发工具，安装后可自动检测更新，勾选【Show Package Details】会显示所有可用的SDK版本 SDKUpdate Sites选项卡用来管理Android SDK工具更新的站点。如果站点没有被勾选，Android Studio SDK Manager就不会去检测更新。 管理Android模拟器内容简单，跳过 即时运行Instant Run会让我们的开发过程变得快速流畅,Instant Run会分析我们修改的内容，然后决定以最快的方式部署新的代码 热交换: 能够在APP运行时处理变更方法的具体实现 暖交换: 能够在APP运行时把资源文件注入应用中 冷交换: 能够在APP运行时处理一些结构性的变更。 启用即时运行操作步骤: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Instant Run -&gt; 勾选【Enable Instant Run to hot swap code/resource changes on deploy】 Restart activity on code changes: 代码变更时重启activity Show toasts in the running app when changes are applied: 每次变更应用时都显示toast提示 Show Instant Run status notifications: 显示即时运行状态通知 使用即时运行之前需要知道的事情 即时运行只支持Android 4.0 即时运行只支持Debug版本 如何判断是否已开启即时运行有闪电标识说明已经开启即时运行 即时运行是如何工作的即时运行被设计用来加快应用的构建和部署，通过执行“热交换”，“暖交换”，“冷交换”把变更的代码和资源推送到设备上 代码变更 即时运行行为 改变现有方法的实现代码 支持“热交换”: APP保持正常运行，待下次方法被调用时会使用新的实现 添加/删除或改变现有的资源 支持”暖交换”: 变更的资源会被推送到设备上，然后Activity会自动重启 结构代码变更(添加、删除或改变[-注解-实例字段-静态字段-静态方法签名-实例方法签名],改变当前类继承的父类,改变实现的接口列表,改变类的静态初始值设定,利用动态的资源ID重新布局元素) 支持“冷交换”: 结构代码变更被推送到目标设备，然后整个应用重启 改变应用的manifest,应用的manifest中改变了资源的引用 不支持。即时运行不支持改变Android manifest或manifest中资源的引用，这是因为API中包含的某些信息是从Android manifest中确定的。当APK被安装到设备上时，如果改变了manifest就必须重装APK。由于热、暖、冷交互是为了避免重新安装APK，为了加快速度，如果改变了Android manifest，Android Studio会自动部署一个新的构建 Android监视器Android Studio集成了非常丰富的工具来对APP进行监控和调试，我们可以在Android 监视器查看日志、截图、录像、解析布局、实时查看性能。 启用ADB集成菜单栏: Tools -&gt; Android -&gt; 勾选Enable ADB Integration 打开/隐藏 Android Monitor 工具窗口快捷键: command + 6 显示已连接到电脑上的设备列表，在这里选择需要使用的设备 显示手机上运行的APP进程列表 针对手机操作的工具栏，从上到下依次是截图、录像、系统信息、终止应用、布局解析、帮助工具。 Locat日志过滤工具栏，从左到右依次是日志级别、关键字、是否使用正则匹配、过滤配置 Logcat日志输出面板 Locat日志工具栏 截图 Android Studio支持对真机和模拟器截图 图片格式为PNG Android Studio支持对截图做一些修饰 截图是针对真机或模拟器的 录像 视频格式为MP4 最长可以录制三分钟 仅支持真机，模拟器不能录像 录像是针对手机的 捕获系统信息通常我们想查看系统信息都是使用adb shell dumpsys命令，如查看某个进程的内存信息:~$ adb -s 设备序列号 shell dumpsys meminfo 进程名 布局解析可以分析出当前界面的布局结构以及每个组件的属性 菜单栏: Tools -&gt; Layout Inspector Logcat监视器Logcat监视器主要用来对APP进行监控和调试，能够实时显示APP和系统输出的日志信息。当异常发生时会显示相关的堆栈信息和代码链接，我们可以单击链接跟踪到代码 Android 中支持6中日志类型 Verbose(Log.v()): 详细，用于打印所有不重要的、一般的日志信息 Debug(Log.d()): 调试，用于打印调试用的日志信息 Info(Log.i()): 信息，用于打印正常使用时需要关注的日志信息 Warn(Log.w()): 警告，用于打印可能会有问题但还没发生错误的日志信息 Error(Log.e()): 错误，用于打印运行时出现的严重错误的日志信息 Assert(Log.wrf()): 断言，用于打印运行时出现的致命错误和日志信息 1、日志没有显示: 在工具栏单击【Restart】重新启动日志2、设置日志头信息的显示: 在工具栏单击【Logcat Header】设置日志头信息的显示内容。3、过滤日志 过滤日志类型，输出级别为 Verbose &gt; Debug &gt; Info &gt; Warn &gt; Error &gt; Assert。默认显示Verbose级别的日志。 过滤输出的日志信息，支持正则匹配 过滤器 Show only selected application: 仅显示当前选中的APP的日志 Firebase: 仅显示Firebase的日志信息 No Filters: 显示设备上所有的日志信息 Edit Filter Configuration: 编辑过滤器配置 创建一个Logcat过滤器 Filter Name: 过滤器的名字 Log Tag: 设置过滤Tag参数，支持正则匹配 Log Message: 设置过滤日志信息参数，支持正则匹配 Package Name: 设置过滤包名参数，支持正则匹配 PID: 设置过滤的作用 Log Level: 设置过滤的日志类型 自定义Logcat的颜色 操作步骤: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Android Logcat 设置颜色 新建一个Scheme 选择要设置的日志类型 取消勾选【Use inherited attributes】 设置颜色 内存监视器内存监视器可以实时观察应用程序的内存使用情况。 要想查看应用程序的内存，首先要选择设备和应用程序的进程，其次要确定内存监视器是启用状态。我们可以一边操作APP一边观察内存的变化，如果发现操作APP的过程中突然出现一个意料之外内存峰值或内存GC后不断增长，那就有可能会发生OOM或内存泄漏。我们可以主动发起GC(垃圾回收),清除无用或不再被其他对象引用的那些对象所占用的内存空间。GC后内存应该稳定在一个值附近才对，如果还在不断增长，那一定是内存泄漏了。 Dump Java Heap使用HPROF查看器分析内存泄漏 单击【Dump Java Heap】按钮，得到当前内存的快照(HPROF)文件。文件被存放在Captures/Heap Snapshot目录下，并使用HPROF查看器自动打开。 使用HPROF查看器分析内存泄漏(HPROF查看器显示了APP的内存分配情况，包括APP为哪些类分配了内存空间、类的对象个数以及占用的内存大小。我们可以通过这些信息确认是否发生了内存泄漏) Captrues/Heap Snapshot: 用于存放HPROF文件 显示APP占用内存空间的类和类的属性 |属性|说明||:–|:–||Class Name|内存中的类名||Total Count|内存中该类的对象个数||Heap Count|选中的堆内存中该类的对象个数||Sizeof|该对象的大小||Shallow Size|选中的堆内存中所有对象浅堆大小总和(浅堆是指一个对象直接占用的内存大小，不包含对其他对象的引用)，Shallow Size = Sizeof * Heap Count||Retained Size|选中的堆内存中所有对象保留堆大小总和(保留堆是指一个对象自己占用的浅堆加上从该对象能直接或间接访问到对象的浅堆之和)，Retained Size等于所有Dominating Size相加| 显示选中类的所有实例和属性 |属性|说明||:–|:–||Instance|类的具体对象||Depth|从GC root到选中对象最短的跳跃数||Shallow Size|该对象的浅堆大小||Dominating Size|该对象的保留堆大小| Reference Tree: 指向所选对象的引用，以及引用的引用，其他属性同上 Analyzer Tasks: 分析任务，使用这个功能可能分析出发生内存泄漏的Activity和重复的字符串 Detect Leaked Activities: 检测内存泄漏的Activity Find Duplicate String: 找出重复的字符串 Analysis Results: 分析结果 使用MAT分析内存泄漏如果还是习惯于使用MAT分析，也可以导出标准的hprof文件 Captures/Heap Snapshot -&gt; 右击.hprof文件 -&gt; Export to standard .hprof 选择文件的存储路径 单击【OK】按钮文件保存成功 接下来就可以直接使用MAT打开这个文件进行分析了。 Allocation TrackingAllocation Tracking(内存分配追踪器)用来监视内存分配更详细的信息。我们可以监视在执行某些操作一段时间内的内存分配情况。知道这些分配，可以更加有针对性地优化相关方法。 可以查看何时、何处分配了对象，以及对象的大小、分配的线程和堆栈跟踪信息 可以通过分配/释放模式复现内存抖动的情况 可以配合HPROF查看器一起使用，追踪内存泄漏的问题。例如，当我们使用HPROF查看器发现了一个bitmap驻留在堆中的时候，可以使用Allocation Tracking 找到它的分配位置。 单击【Start Allocation Tracking】开始追踪内存分配，这时我们对APP进行一些操作，然后单击【Stop Allocation Tracking】 停止追踪后.alloc文件被保存在Capture/Allocation Tracting目录下，并且被自动打开。 显示内存分配信息。默认以方法来分类内存分配信息，还可以切换成以分配器来分类内存分配信息。 |属性|说明||:–|:–||Method|负责内存分配的方法||Count|分配对象的个数||Size|分配的内存总大小(Byte)| 单击这些属性可以进行相应的排序，我们可以通过内存分配的次数和大小来找出那些占用过多的内存、引发过多的GC且又非常耗时的方法。 内存分配的图标。通过这个漂亮的图表，我们可以看出哪些方法或类拥有最多的对象 显示图标指定的线程或方法的分配次数和内存大小 将光标放在中心点会显示图表中占比最大的线程信息，如线程名、分配次数和内存大小 这个圆圈是所有线程的占比，一些占比较小的线程双击后可展开 显示线程名/方法名、分配次数和内存大小 CPU监视器CPU监视器实时显示用户和内核模式下CPU使用率的综合，可以让我们很轻松地查看操作APP时的CPU使用率 模式在用户(User)模式下，代码必须通过系统API访问硬盘或内存，并且只能访问虚拟内存地址，崩溃通常是可回收的。在内核(Kernel)模式下，代码可以直接访问硬件，包括物理内存地址，崩溃会导致设备停止。 方法追踪Method Tacking用来追踪一段时间内系统的运行情况，可以查看APP中的调用堆栈和时间信息 单击左上角的Start Method Tracking 操作APP一段时间后再单击一次 trace文件被保存在Captures/Method Tracking目录下，并且自动打开 Inclusive Time: 包含时间(ms)，方法占用的CPU时间，包含内部调用其他方法占用的CPU时间 Exclusive Time: 独占时间(ms)，方法占用的CPU时间，但不含内部调用其他方法所占用的CPU时间 常用判断方法 方法调用次数不多，但每次调用却需要花费很长时间，可能会有问题 自身占用时间不长，但调用却非常频繁的方法也可能会有问题 网络监视器网络监视器用来查看APP的网络请求情况，可以实时监控到APP的数据传输，使用它可以帮助我们扎到一些不必要的或不规范的网络请求。流量测试是专项测试中非常重要的一个测试项，我们需要保证APP不会有不必要的数据加载、不会有过大的数据加载 GPU监视器GPU监视器用来查看UI界面渲染帧需要花多少时间，可以实时查看每一帧渲染所花费的时间。 GPU监视器能帮我们快速查看UI界面的渲染执行、确认渲染路径是否花了较长的处理时间、寻找帧渲染的时间峰值与用户或程序操作相关联。要想使用GPU监视器，首先要打开GPU呈现模式分析。 手机 -&gt; 设置 -&gt; 应用程序 -&gt; 开发者选项 -&gt; GPU呈现模式分析 -&gt; 勾选【在adb shell dumpsys gfxinfo中】 -&gt; 选中需要测试的APP进程，开启GPU监视器。 帧渲染的过程分成了四个不同的阶段 蓝色: Draw(绘制)，表示创建/刷新DisplayList(包含需要GPU绘制到屏幕上的数据信息)所花费的时间 紫色: Prepare(准备)，表示UI线程将所有资源传递给渲染线程所花费的时间 橙色: Process(过程)，表示执行DisplayList并创建OpenGL命令所花费的时间 黄色: Execute(执行)，表示CPU发送OpenGL命令给GPU，等待GPU渲染完成的时间。 GPU监视器的组成包括渲染帧的不同阶段，显示渲染帧耗时曲线图。绿色的线表示60FPS，即每一帧渲染时间大概是16ms。红色的线表示30FPS，即每一帧渲染时间大概是33ms APK分析器能反编译APK，可以帮助我们非常方便地分析APK当中的内容。我们可以用它来分析APK当中的混淆文件，一方面可以参考别人家的APK是如何配置混淆文件的，另一方面也可以排查自己家的APK是否有相关的配置问题，我们还可以用它来查看自己编译的资源文件，找出一些比较大的文件进行具体分析，确认是否需要保留、减小包大小。右上角的【Compare with…】功能可以对比两个APK文件，找出差异性，方便分析不同版本APK之间的区别。 菜单栏: Build -&gt; Analyze APK -&gt; 选择要分析的APK -&gt; OK 以微信APK为例 com.tencent.mm: 微信的包名 version 6.1.0.73_rl097298: 版本号 Raw File Size: 34.2MB: 分析出来的APK文件总大小 Download Size: 27.6MB: 下载下来的APK的总大小 File: 分析出来的文件列表 Raw File Size: 分析出来的文件对应的原始大小(未压缩过的) Download Size: 分析出来的文件对应的压缩过的大小 % of Total Download size: 分析出来的文件对应的压缩过的大小/下载下来的APK的总大小 在APK分析结果界面，按文件大小从高到低排序，可以很清楚的看出哪些是大文件，然后查看大文件内容。如果想减少包大小，需要先从大文件入手。我们可以查看合并后的AndroidManifest.xml是否正确，还可以混淆文件，看看微信是如何进行混淆配置的。 主题编辑器主题编辑器支持实时预览主题效果，支持横竖屏、UI模式、虚拟机、Android版本和多语言预览。 菜单栏: Tools -&gt; Android -&gt; Theme Editor 或者打开 res/values/styles.xml -&gt; 单击右上角Open editor colorPrimaryDark: 状态栏颜色 colorPrimary: 标题栏颜色 textColorPrimary: 标题栏字体颜色 windowBackground: 窗口背景颜色 naigationBarColor: 虚拟导航栏背景颜色 版本控制版本控制是项目开发过程中必不可少的部分，不管是个人还是团队，灵活地使用版本控制将会使项目开发变得更加轻松。 菜单栏 -&gt; VCS 可以看到版本控制系统的所有功能 右键 -&gt; 菜单 可以看到版本控制系统的选项，只包含对应的版本控制系统特有的功能 底部工具栏 -&gt; Version Control(很多功能和菜单栏VCS相同，但是这里的操作更加有针对性，还可以批量操作) 顶部工具栏 -&gt; 常用功能(更新项目、提交变更、跟远程仓库中的文件进行对比、显示历史、撤销操作) 状态栏 -&gt; 分支操作(对本地、远程分支进行各种操作，比如检出、创建新的分支、对比、合并、删除等) Git偏好设置设置步骤: 偏好设置 -&gt; Version Control -&gt; Git Path to Git executable: Git执行路径 SSH executable: 执行SSH，默认使用Android Studio内建的 commit automatically on cherry-pick: 在cherry-pick时是否自动提交 Warn if Crlf Line separators are about to be committed: 如果回车换行符被提交是否警告 Warn when committing in detached HEAD or during rebase: 提交detached HEAD 或 rebase 时是否警告 Update method: 选择代码更新方式，包括Branch defaut，merge，rebase Auto-update if push of the current branch was rejected: push当前分析被拒绝是否自动更新 Allow force push: 是否允许强制push ###配置GitHub账户信息设置步骤: 偏好设置 -&gt; Version Control -&gt; GitHub 输入账号信息 从GitHub克隆代码 进入GitHub克隆界面 欢迎界面: Check out project from Version Control -&gt; GitHub 菜单栏: File -&gt; New -&gt; Project from Version Control -&gt; GitHub 菜单栏: VCS -&gt; Check out from Version Control -&gt; GitHub 配置克隆地址 下载并打开项目。单击【Clone】按钮开始从给定的仓库地址克隆项目到本地，完成后会弹出一个【Import Project from Gradle】确认对话框。 将本地项目共享到GitHub 单价【Share Project on GitHub】。打开本地项目 -&gt; 菜单栏 -&gt; Import into Version Control -&gt; Share Project on GitHub 确定是本地项目。如果此项目已经在GitHub上，在Android Studio右上角会有相应的提示信息，单击GitHub可以跳转到项目主页。如果此项目没有在GitHub上，就会弹出一个新建仓库的对话框。 指定首次提交的文件和提交的备注。单击【OK】按钮以后在状态栏会显示进度。 确认分享成功。分享成功后在Android Studio的状态栏和右上角会显示成功提示。如果想查看GitHub上到底有没有分享成功，可以单击【SecondAPP】到项目主页查看。 查看本地变更历史查看某个文件的本地变更历史前提条件: 在文件列表中选中此文件或打开此文件，光标在文件中。操作步骤: 右击 -&gt; 在弹出的操作选项中单击Local History -&gt; Show History 显示变更历史: 如果两个文件不同就会提示不同的个数，窗口底部列出了不同颜色表示的变更操作查看某段代码的本地变更历史: 如果想查看某段代码本地的变更，需要先选中这段代码，然后再Local History列出的选项中选择【Show History for Selection】查看某个文件夹的本地变更历史: 如果想要查看某个文件夹的本地变更，只需要选中这个文件夹，然后右击选择Local History -&gt; Show History。我们还可以为每次变更贴上一个标签，只要在Local HIstory中选择Put Label，然后输入标签内容就可以了。 Git添加文件 未跟踪是指没有被纳入版本控制的文件，Git就不会跟踪文件的变更 已跟踪是指已被纳入版本控制的文件，在上一次的快照中有它们的记录，在工作一段时间后，这些文件的状态可能是未修改，已修改或已放入暂存区。 本地文件提交到远程仓库一般的流程为: 添加文件跟踪 -&gt; 暂存已修改的文件 -&gt; 提交到本地仓库 -&gt; 推送到远程仓库。 添加文件跟踪如果我们新建了一个文件，默认是没有被跟踪的，Git就不会跟踪文件的变更。未跟踪的文件显示为红色。 右击文件 -&gt; Git -&gt; Add VCS-&gt; Git -&gt; Add option + command + A 添加完成后，文件颜色变为绿色，即已跟踪提交到本地仓库/远程仓库的文件颜色显示为白色 暂存已修改的文件暂存已修改的文件方法同添加文件跟踪 Git提交变更当本地文件变更之后，我们需要提交变更 菜单栏: VCS -&gt; Git -&gt; Commit File快捷键: command + K 配置提交信息在提交变更窗口中可以选择Change list，也可以选择要提交的变更文件。在Author中选择或输入作者名字。选择Amend commit(修订提交)会在Commit Message中添加上一次的提交信息。还可以选择做一些代码优化的工作。 Reformat code(格式化代码) Rearrange code(重新排列代码) Optimize imports(优化导入) Perform code analysis(执行代码分析) Check TODO(检查待办事项) Cleanup(清理) Update copyright(更新版权声明) 提交变更 Commit and Push: 将本地变更的文件提交到本地仓库，然后推送到远程仓库 Create Patch: 将本地变更的文件作为补丁创建 Commit: 将本地变更的文件提交到本地仓库 Git文件逐行追溯如果想查看某个文件的某一行是谁修改的，就需要使用文件逐行追溯功能执行文件逐行追溯操作，会显示某个文件每一行的详细改动信息，也可以说是每一行的注释，包括修订版本号、提交者、提交日期以及提交次数。 如何进行文件逐行追溯其实就是执行git annotate命令，同git blame 菜单栏: 单击VCS -&gt; 选择Annotate 右击文件编辑区域 -&gt; 单击Git -&gt; 选择Annotate 右击文件左边栏 -&gt; 选择Annotate 显示当前修订版本修订版本号是一组SHA-1值，可以通过SHA-1 值来获取对应的那一次提交。SHA-1是散列函数加密算法，输出的散列值为40位十六进制数字串，可用于验证信息的一致性，防止被篡改。 操作步骤: 菜单栏 -&gt; VCS，右击某一个文件或文件编辑区 -&gt; Git -&gt; Show Current Revision Git文件比较Android Studio集成的Git提供了非常好用的文件比较功能，可以将本地文件与远程仓库中的、某次提交的或其他分支的文件进行比较。 操作步骤: 菜单栏 -&gt; 右击某一个文件或文件的编辑区 -&gt; VCS -&gt; Git,或者底部工具栏 -&gt; Version Control -&gt; 右击有变更的文件 -&gt; Git Compare with the Same Repository Version: 比较本地文件与远程仓库的文件 Compare with Last Repository Version: 本地文件与最近的一次提交比较 Compare with: 本地文件与某一次提交比较 Compare with Branch: 本地的文件或文件夹与某个分支上的进行比较 Git撤销操作如果我们对某个或某几个文件进行了修改，现在想撤销这些修改，可以使用Git提供的撤销操作功能。单击【Revert】按钮，被选中的文件就恢复到了改动之前的状态。 Git版本回退Git版本回退的意思就是讲本地代码会退到某一个指定的版本，此版本之前的所有内容都会被重置。 操作步骤: 菜单栏 -&gt; VCS -&gt; Git -&gt; Reset HEAD -&gt; 然后弹出Reset Head对话框 Reset Type: 回退类型 Mixed: 回退到某个版本，本地源码不会回退，会回退commit和index信息 Soft: 回退到某个版本，本地远吗和index信息不会回退，只回退了commit的信息，如果还要提交，直接commit即可。 Hard: 彻底回退到某个版本，本地的源码也会变为某个版本的内容 To Commit: 回退版本。 HEAD: 回退到最近一个提交版本 HEAD^: 会退到上一个提交版本 HEAD^^: 会退到上上一个提交版本 … HEAD~0: 会退到最近一个提交版本 HEAD~1: 会退到最近一个提交版本 HEAD~2: 会退到最近一个提交版本 Validate: 版本验证。在指定会退到某个版本之前也可以先验证一下是否是想回退的版本 Git查看提交历史Git查看提交历史记录也都有查看文件、文件夹和代码段的历史记录功能，不同点在于【查看本地变更历史】仅能查看本地的变更，远程的改动是无法看到的，【Git查看历史记录】可以查看所有commit以后的历史 查看某个文件的提交历史操作步骤: 右击 -&gt; 在弹出的操作选项中单击Git -&gt; Show History -&gt; 在Version Control中显示Hitory 查看某段代码的提交历史选中这段代码，然后在Git操作列表中选择【Show History for Selection】 Git分支管理当我们在进行软件开发时，同一个软件多个人协同开发，因此要有不同的分工。如果想让彼此的代码不受影响，就需要在不同的分支上进行开发，开发完成后再进行合并。 新建分支单击【New Branch】 -&gt; 输入分支的名字 -&gt; OK 检出分支检出分支作为新的本地分支，可以把一个远程分支checkout下来，可以起不同的名字，可以是多个本地分支，但是提交时都是向同一个远程分支进行提交。 操作步骤: 选择一个分支 -&gt; 单击【checkout as new local branch】 -&gt; 输入新的分支名 -&gt; OK -&gt; 成功检出 如果是对本地分支进行【Checkout as new local branch】操作，就会直接弹出一个【Checkout New Branch】输入框，不会有默认的分支名 检出分支/标签/修订版本如果想检出某个分支/标签/修订版本，只需要知道对应的名字就可以了。在Git Branches操作列表中选择【Checkout Tag or Revision】 -&gt; 弹出的输入框中输入分支名 -&gt; OK后会检出对应的分支。检出tag也只需要输入tag名就可以了。如果检出当前分支的某个修订版本，就需要输入对应的修订版本号 切换分支切换分支需要选择切换的分支，单击【Checkout】。如果原来的分支没有变更，checkout后会切换到新的分支:如果有变更且有冲突，就会先解决冲突再切换。 分支对比分支对比是拿当前分支与另外一个分支进行对比。 对比两个分支的提交日志对比两个分支的不同合并分支合并分支只将选中的分支与当前的分支进行合并，如果有冲突就会弹出冲突列表，解决冲突合并成功。 删除冲突 删除本地分支: 本地分支会被直接删除 删除远程分支: 删除远程分支会有确认是否删除，确认删除后状态栏会有正在删除的信息显示，删除成功后Version Control上会有删除陈宫地提示。Remote Branches列表中此分支也会消失 Git创建标签Git可以给历史中的某一个修订版本打上标签，通常我们会使用标签来标识一个版本的发布。 操作步骤: 菜单栏-&gt; VCS -&gt; Git -&gt; Tag Git Root:项目地址 Current Branch: 显示当前的分支 Tag Name: 标签名 Force: 如果相同的Tag名已经存在，是否强制创建 Commit: 通过输入的修订版本号、Tag名来打标签。如果空白，默认对HEAD打标签 Create Tag: 创建标签 Git合并分支 选择合并变更(右击项目 -&gt; 在弹出的操作列表中选择 Git -&gt; Repository -&gt; Merge Changes -&gt; 弹出合并分支对话框) 配置合并信息 Current Branch: 显示了当前的分支 Branches to merge: 显示了仓库中所有的分支，选择一个或多个要合并过来的分支 Strategy: 提供了可选择的合并策略，请按需选择 Commit Message: 添加本次合并的注释 合并分支: 配置好合并信息后单击【Merge】按钮开始合并代码。 解决Git合并中的冲突问题1: 合并分支为什么会有冲突？因为在项目开发的过程中，可能大家会同时改动某个文件，当同一个文件在远程分支和本地分支按不同的方式被修改时，在合并分支的时候就会出现冲突。 问题2: 文件冲突会导致什么样的后果？合并过程中如果文件冲突，合并就会失败，Git会在索引和工作树里设置一个特殊的状态，提示你如何解决冲突。我们必须解决完冲突并且更新索引后才能够将文件提交。 打开文件冲突列表操作步骤: Git -&gt; Resolve Conflicts合并过程中如果有冲突也会突出文件冲突列表 解决冲突的方法 如果想放弃本地的改动，而完全使用远程分支的改动，可选择【Accept Theirs】，此文件冲突解决 如果想放弃远程的改动，而完全使用本地的改动，可选择【Accept Youts】，此文件冲突解决 如果想详细解决冲突，单击【Merge】 -&gt; 会打开文件比较窗口。左边是本地变更，邮编是远程分支上的变更，中间是合并结果。如果把右边远程分支的变更用作合并结果，单击‘&lt;&lt;’远程的变更就回到合并结果中。同理，也可将本地变更合并到结果中。 如果觉得改错了要恢复，可单击【Revert】。如果确定了合并结果，就单机【Apply】。 Git使用Rebase合并分支Git Rebase是什么Rebase顾名思义是‘变基’的意思，即合并时重新定义分支的根基或节点，让提交记录按时间线排列。 Git Rebase和Merge的区别是什么Rebase跟Merge一样，都是用来合并分支的，但是Merge操作会生成一个新的节点，与之前的提交分开显示: Rebase操作不会生成新的节点，而是将两个分支融合成一个线性的提交。 什么时候使用Git Rebase使用Rebase合并分支会使提交记录看起来非常清晰，因为它是时间线线性的现实记录，所以打你想线性地查看分支的提交记录时，可以使用Git Rebase来合并分支 对每个提交定义rebase行为。默认为pick pick: 以同样的提交信息保存提交 edit: 在对下一提交进行操作之前，会让你对提交进行修正 skip: 遇到冲突暂停时，跳过这个提交 squash: 把这个提交和前一个提交合并成为一个新的提交 reword: 提交时要编辑提交信息 fixup: 和squash类似，但是要放弃提交信息 Git暂存/恢复暂存变更暂存是什么意思Git暂存就是从最近一次提交中读取相关内容，让工作区保证和上次提交的内容一致，相当于清空本地的所有改动。只不过这些改动进行了备份，我们可以选择性地进行恢复。 什么时候使用暂存将写到一半的代码暂存，然后切换到其他分支修复BUG，BUG修复完成后再切回当前分支，然后恢复之前咱村的代码继续编写 暂存和恢复暂存怎么用在Dev分支单击【Create Stash】创建暂存，IDE消除了本地的改动，恢复到上次提交的内容。切换到Master分支，改好代码返回Dev分支。此时会弹出暂存列表，选择之前暂存的代码，单击【Apply Stash】按钮进行恢复 Git获取最新内容从远程仓库获取项目中最新的内容，包括远程仓库中分支的状态，可以通过菜单栏 -&gt; VCS -&gt; Git -&gt; Fetch完成。Git会去拉取远程仓库最新的内容，并清除远程服务器上删掉的分支。 Git合并最新内容要从远程仓库获取最新的内容，然后和本地的内容自动进行合并，可以通过菜单栏 -&gt; VCS -&gt; Git -&gt; Pull。 Git会先执行Fetch去拉取远程仓库最新的内容，再执行Merge把远程仓库中的代码和本地代码合并。执行Pull以后在Version Control中会显示更新的详情。 Git更新项目 菜单栏: VCS -&gt; Update Project 快捷键: Command + T 工具栏 Update Type(更新类型): 提供了3种类型来进行同步 Merge: 更新后合并，相当于执行git fetch命令，再执行git merge或git pull——no-rebase Rebase: 更新后变基，相当于执行git fetch命令，再执行git rebase或git pull–rebase Branch Default: 更新后使用分支默认命令 Clean working tree before update(更新之前先清理工具目录): 可选择在清空工作目录之前以什么样的方式来保存你的更改，当更新完成后，可以恢复之前的更改。 Using Stash: 使用暂存 Using Shelve: 使用搁置 刷新文件状态如果我们想刷新本地文件的状态，可以使用此功能。 操作步骤: 菜单栏 -&gt; VCS -&gt; Refresh File Status,或者Version Control工具窗口 -&gt; Local Changes -&gt; Refresh Git 补丁什么是补丁Git当中的补丁是一个文本文件，包含了对源代码的修改。你可以创建一个项目中的补丁，然后把它发给需要的人，拿到补丁文件的人可以为自己的项目打上这个补丁。 创建补丁假设你修改了项目中的一个BUG，然后需要创建一个补丁 操作步骤: 菜单栏 -&gt; VCS -&gt; Create Patch… -&gt; 弹出Create Patch配置对话框 应用补丁当我们拿到补丁后，可以通过菜单栏 -&gt; VCS -&gt; Apply Patch… -&gt; 选择补丁文件 -&gt; 单击【OK】 Git搁置变更类似Git的暂存命令，等想恢复的时候再来恢复搁置。与暂存不同的是，搁置功能相当于是本地打了个补丁，把补丁文件保存在本地，等想要恢复的时候给项目打上个补丁就可以了。 搁置变更操作步骤: 菜单栏 -&gt; VCS -&gt; Shelve Changes -&gt; 在弹出的对话框中选择要暂时搁置的变更 -&gt; 单击【Shelve Changes】 恢复搁置当我们修改完BUG，回到之前的分支准备继续写代码，需要恢复之前搁置的变更 Unshelve Changes: 默认恢复搁置到新建的变更列表(操作步骤: Version Control工具窗口 -&gt; Shelf -&gt; 右击之前搁置的文件 -&gt; Unshelve Changes -&gt; 默认新建一个Changelist -&gt; 输入Name后单击【OK】按钮) Unshelve: 默认恢复搁置到默认的变更列表(操作步骤: Version Control工具窗口 -&gt; Shelf -&gt; 右击之前搁置的文件 -&gt; Unshelve -&gt; 弹出恢复搁置的对话框 -&gt; 单击【OK】按钮后搁置恢复) 查看Git项目的提交信息查看本地Git项目提交信息操作步骤: 菜单栏 -&gt; VCS -&gt; Browse VCS Repository -&gt; Show Git Repository Log -&gt; 弹出选择对话框 -&gt; 选择一个要浏览日志的项目 查看当前项目的提交信息在Version Control工具窗口的Log查看当前项目的分支信息及提交信息 过滤信息 过滤提交信息 过滤分支/用户/日期/路径 窗口最小化和最大化窗口最小化窗口菜单栏: Window -&gt; Minimize快捷键: command + M 最大化窗口菜单栏: Window -&gt; Zoom快捷键: options + command + “=” 保存和恢复窗口布局保存当前布局为默认布局操作步骤: 菜单栏 -&gt; Window -&gt; Store Current Layout as Default 恢复默认的布局菜单栏: Window -&gt; ReStore Default Layout快捷键: fn + shift + F12 工具窗口的显示和隐藏通过Tool Windows显示/隐藏工具窗口操作步骤: 菜单栏 -&gt; View -&gt; Tools Windows -&gt; 显示Android Studio支持的所有工具列表 通过工具窗口都可以通过工具条上的Tab来显示和隐藏 工具窗口的隐藏技巧隐藏活动的工具窗口当有多个窗口被打开的时候，之隐藏活动的那一个工具窗口菜单栏: Window -&gt; Active Tool Window -&gt; Hide Ative Tool Window | Close Active Tab 挨个隐藏工具窗口当有多个窗口被打开的时候，使用此功能可以按打开的顺序逆向隐藏工具窗口菜单栏: Window -&gt; Active Tool Window -&gt; Hide side tool Window 隐藏所有工具窗口当编辑器和工具窗口都打开的时候，界面会显得比较乱。如果我们只想专注地编写代码，就可以一键把所有工具窗口隐藏菜单栏: Window -&gt; Active Tool Window -&gt; Hide All Windows快捷键: fn + shift + command + F12 恢复隐藏的所有工具窗口菜单栏: Window -&gt; Active Tool Window -&gt; Restore Windows快捷键: fn + shift + command + F12 工具窗口调整技巧跳转到上一个我们经常会在工具窗口和编辑器之间跳转，可以让光标快速跳转到上一个工具窗口 菜单栏: Window -&gt; Active Tool Window -&gt; Jump to Last Tool Window快捷键: fn + F12 最大化工具窗口菜单栏: Window -&gt; Active Tool Window -&gt; Maximize tool Window快捷键: shift + command + “‘” 恢复最大化工具窗口原来的【Maximize tool Window】变为【Restore tool window size】 逐渐调整工具窗口大小最快的调整方式使用鼠标长按托拖动 激活工具窗口 -&gt; 菜单栏 -&gt; Window -&gt; Active Tool Window -&gt; Resize -&gt; Stretch to Top/Bottom/Right/Left 移动工具窗口的位置右击工具窗口 -&gt; Move To -&gt; 选择要移动到的位置 工具窗口的查看模式停驻和浮动模式停靠和脱开模式固定和非固定模式分离模式在同一个工具条上最多可以同时显示两个工具窗口 作为标签显示编辑器标签设置任一时刻打开一个文件都会以标签页的形式在编辑窗口出现 设置编辑器标签: 偏好设置 -&gt; Editor -&gt; Editor Tabs 快速切换编辑器标签上一个/下一个标签前提条件: 光标在编辑器中菜单栏: Window -&gt; Editor Tabs -&gt; Select Next Tab 或 Select Previous Tab快捷键: shift + command + ←/→ 快速切换已打开的文件快捷键control + tab 调出switcher 快速切换工具窗口使用快捷键control + tab 调出switcher，默认选中的是文件，如果想默认选中的是工具，则使用快捷键control + shift + tab。长按control + shift，通过按tab来切换工具。 关闭编辑器标签对标签右击，来选择性关闭标签页 管理编辑器标签重新打开关闭的标签操作步骤: 右击编辑器标签 -&gt; Reopen Closed Tab -&gt; 最后被关闭的标签会被打开 在最后打开新标签操作步骤: 右击编辑器标签 -&gt; 选中Open New Tabs At The End -&gt; 再打开新的文件标签时就会在已打开的标签最后打开 通过文件名排序标签操作步骤: 右击编辑器标签 -&gt; Sort Tabs By Filename 标签显示位置默认标签是显示在编辑器窗口最上面，我么也可以自定义显示的位置 操作步骤: 右击标签 -&gt; Tabs Placement -&gt; 选择显示位置 拆分编辑器窗口拆分一个标签窗口 右击标签 -&gt; Split Vertically/Horizontal(垂直拆分/水平拆分) 右击标签 -&gt; Move Right 或 Move Down。相当于水平拆分和垂直拆分，不同点是Move会把当前的标签页移到拆分的一边，而Split不会 改变拆分窗口的摆放方式操作步骤: 右击标签 -&gt; Change Splitter Orientation 改变拆分窗口的摆放方式 标签组Android Studio可以通过将标签页分组的方式支持多文件同时编辑，组的数量没有限制 操作步骤: 右击标签 -&gt; Move to Opposite Group。如果想把当前文件在另外一个标签组打开可以选择Open In Opposite Group 撤销拆分操作步骤: 右击标签 -&gt; Unsplit 或 Unsplit All 多个项目之前切换打开后面一个项目操作步骤: 菜单栏 -&gt; Window -&gt; Next Project Window 打开前面一个项目操作步骤: 菜单栏 -&gt; Window -&gt; Previous Project Window 选择某个已打开项目菜单 -&gt; Window 子菜单来完成 偏好设置外观与行为设置工具提示的延迟时间当我们把鼠标停在工具栏上的工具或编辑器中的项目会出现提示 操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; Appearance -&gt; 滑动设置【Tooltip initial delay】 设置在状态栏显示内存状态如果想实时显示内存的使用情况 操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; Appearance -&gt; 勾选【Show memory indicator】 对菜单选项和工具栏上的工具进行增删改操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; Menus and Toolbars -&gt; 选择需要操作的选项 系统设置设置启动Android Studio时是否自动打开项目当我们打开Android Stuio时默认会打开上次最后关闭的项目，如果不想自动打开上次关闭的项目 操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 不勾选【Reopen last project on startup】 设置退出Android Studio时是否弹出确认提示当我们关闭Android Studio时默认会弹出确认提示，如果不想每次都确认 操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 不勾选【Confirm application exit】 设置打开一个项目时的打开方式当我们打开一个新项目时默认会弹出一个确认提示，让我们确认是在新窗口打开还是在当前窗口打开。 操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 设置Project Opening Open project in new window: 在一个新窗口打开项目 Open project in the same window: 在同一个窗口打开项目 Confirm window to open project in: 弹出确认对话框，可选择在新窗口或原窗口打开 设置文件定期自动保存操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 勾选【Save files automatically if application is idle for [] sec】 设置编辑窗口失活时文件自动保存编辑窗口失活的意思是可理解为从编辑窗口切换到其他窗口。 操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 勾选【Save files on frame deactivation】 设置密码存储策略操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Passwords -&gt; 设置Password storage policy Do not remember passwords: 不记住密码，每次都要输入密码 Remember passwords until the application is closed: 记住密码，直到应用程序被关闭 Save on disk with master password protection: 密码保存到磁盘，使用master password来保护 设置是否让Google统计使用信息操作步骤: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Usage Statistics -&gt; Send usage statistics to Google 此功能统计Android Studio的使用情况(功能，资源的使用情况和插件的配置信息)，然后发送给Google 键盘映射在Android Studio中如何使用Eclipse的快捷键在Keymaps中选择 如何自定义一份属于自己的keymap复制一份keymap，在复制的keymap中修改 编辑器常规设置设置单击编辑器光标定位在一行的结尾或定位在单击的位置操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Virtual Space -&gt; 勾选【Allow placement of caret after end of line】 勾选，在空白位置单击，光标会定位在一行的结尾 不勾选，在空白位置单击，光标会定位在单击的地方 设置鼠标悬停在元素上会显示文档提示如果想让鼠标悬停在某个变量、类或方法上直接显示它的文档。 操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Other -&gt; 勾选【Show quick documentation on mouse move】 设置是否自动换行当一行的内容超过编辑器的宽度时，它会自动换行。 操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; 查看Soft Wraps -&gt; 勾选【Use soft wraps in editor】 让换行符一直显示如果向现实所有的换行符，就不要勾选【show soft wrap indicators for current line only】 设置换行后的缩进字符如果想自定义换行后第二行的缩进，可以勾选【Use original line`s indent for wrapped parts】 -&gt; 设置 Additional shift 设置使用command + 鼠标控制代码的缩放操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; 勾选【Change font size with Command + Mouse Wheel】 开启使用驼峰单词移动光标或选择单词时可以识别驼峰 操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Smart Keys -&gt; 勾选【Use “CamelHumps” words】 关闭单词拼写检查操作步骤: 偏好设置 -&gt; Editor -&gt; Inspections -&gt; 取消勾选【Spelling】 设置代码折叠规则自定义代码折叠的规则 操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Folding 设置自动导入设置粘贴时自动导入包从其他地方复制一段代码粘贴到Android Studio文件中时，默认Android Studio会询问你是否导入引用的包。 操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Insert imports on paste All: 全部自动导入 Ask: 询问是否自动导入 None: 不自动导入 设置自动导入需要的包操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Auto Import -&gt; 勾选【Optimize imports on the fly】 和 【Add unambiguous imports on the fly】 设置是否弹出导入提示当你输入的类的声明没有被导入时，会弹出一个导入提示 操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Show import popup 编辑器外观设置编辑器一直显示行号操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show line number】 设置编辑器显示方法分隔符如果你想让每个方法区分得更明显，可以显示方法分隔符 操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show method separators】 设置编辑器显示空格操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show whitespace】 设置编辑器显示缩进向导操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show vertical indent guides】 代码补全设置自动补全时是否区分大小写操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Completion Case sensitive completion: First letter: 区分首字母大小写 All: 区分全部大小写 None: 不区分大小写 加快自动弹出代码补全提示的速度操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Completion -&gt; 将【Autopopup decumentation in】设置为0，在Parameter Info将【Autopopup in】中设置为0 关闭自动弹出代码补全提示操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Completion -&gt; 不勾选【Autopopup decumentation in】，在Parameter Info不勾选【Autopopup in】 设置查看方法参数信息的时候显示方法签名操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Completion -&gt; Show full signatures 文件标签设置用星号标记修改过的文件标签操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Editor Tabs -&gt; 勾选【Mark modified tabs with asterisk】 设置打开的文件标签可以多行显示操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Editor Tabs -&gt; 取消勾选【Show tabs in single row】，即可让标签不隐藏，并且全部显示出来 设置文件标签的显示位置操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Editor Tabs -&gt; Placement -&gt; 选择显示位置 设置文件标签超过一定数量时的关闭规则操作步骤: 偏好设置 -&gt; Editor -&gt; General -&gt; Editor Tabs -&gt; Tab Closing Policy -&gt; 配置关闭规则 打开文件标签限制数量 当打开的文件标签超过10个时关闭使用频率较少的 当关闭标签时，激活左边相邻的标签 编辑器颜色设置是否显示条标和条标的显示颜色当编辑器中有报错的时候，在右边框上会显示一个红色的条，即条标 操作步骤: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; General -&gt; 勾选【Error stripe mark】 设置控制台的颜色操作步骤: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Console Colors 设置控制台的字体操作步骤: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Console Font 自定义代码的颜色操作步骤: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Java -&gt; 新建一个Scheme 代码风格设置Java注释按缩进显示操作步骤: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Wrapping and Braces -&gt; Keep when reformatting -&gt; 取消勾选【Comment at first column】 设置语句不要都显示在一行操作步骤: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Wrapping and Braces -&gt; Keep when reformatting -&gt; 取消勾选【Control statement in one line】 设置Java简单的类合并为一行Android Studio中的默认设置是代码格式化后不会把简单的类合并为一行 操作步骤: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Wrapping and Braces -&gt; Keep when reformatting -&gt; 勾选【Simple classes in one line】 设置Java字段和变量列对齐Android Studio中默认是没有列对齐的。 操作步骤: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Wrapping and Braces -&gt; Group declarations -&gt; 勾选【Align fields in columns】 和 【Align variables in columns】 设置自动生成字段名称时添加前缀默认自动生成字段名称是不会有任何前缀的。不过在Android Studio中提供了自动添加自定义前缀或后缀的功能，以便统一编码规范。 操作步骤: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Code Generation -&gt; 输入需要添加的前缀或后缀 文件和代码模板设置新建文件的注释模板当我们新建一个文件时会自动插入这个注释 操作步骤: 偏好设置 -&gt; Editor -&gt; File and Code Templates -&gt; Includes -&gt; File Header -&gt; 输入自定义的注释模板 模板中内置的变量 ￥{PACKAGE_NAME}: 包名 ￥{USER}: 系统的登录名 ￥{DATE}: 系统日期 ￥{TIME}: 系统时间 ￥{YEAR}: 年份 ￥{MONTH}: 月份 ￥{MONTH_NAME_SHORT}: 月份的前三个字符 ￥{MONTH_NAME_FULL}: 月份的全名 ￥{DAY}: 天 ￥{HOUR}: 时 ￥{MINUTE}: 分钟 ￥{PROJECT_NAME}: 项目名 设置新建类文件模板在类文件中可以引用头文件的注释模板如果我们想在新建类文件时自动添加某段代码加了一段代码以后我们再新建一个类文件每次新建类文件时，这段代码模板都会被应用，效率会提高很多 设置IDE和项目的编码操作步骤: 偏好设置 -&gt; Editor -&gt; File Encodings 为了防止中文乱码，一般都会勾选Transparent native-to-ascii conversion 对动态模板进行增删改查Android Studio中提供了快速插入常用代码的功能Live Templates 操作步骤: 偏好设置 -&gt; Editor -&gt; Live Templates -&gt; 对动态模板进行增删改查 查看动态模板分组 新增/删除/复制一个模板 查看具体模板 设置展开代码的按键当我们要插入动态模板的时候，输完代码片段的缩写以后默认按Tab键就可以展开diamante。当然也可以自定义展开按键。 给一个文件类型添加匹配规则操作步骤: 偏好设置 -&gt; Editor -&gt; File Types -&gt; 在Recognized File Types列表中选中一个文件类型 -&gt; 在Registered Patterns中单击+，添加一个文件类型的匹配规则 添加一个自定义的文件类型如果Android Studio可识别的文件类型不能满足需求，可以自定义一个。Android Studio中支持自定义文件类型，可以对这个文件类型设置一些特性，如关键字、注释、高亮显示，还可以设置一些模板，提高操作效率。 操作步骤: 偏好设置 -&gt; Editor -&gt; File Types -&gt; 在Recognized File Types中单击+ -&gt; 设置新的文件类型 设置忽略某类文件或文件夹如果我们不想让某个文件或某类型的文件在编辑器中显示，就可以将其忽略 操作步骤: 偏好设置 -&gt; Editor -&gt; File Types -&gt; 在Ignore files and folders中添加文件类型 插件Android Studio是基于IntelliJ IDEA开发的，自然继承了IntelliJ IDEA优秀的插件系统。我们可以通过安装插件来扩展Android Studio的功能，这会极大地方便我们日常的开发工作。 操作步骤: 偏好设置 -&gt; Plugins All plugins: 所有插件 Enabled: 所有已启用的插件 Disabled: 所有已禁用的插件 Bundled: 所有IDEA自带的插件 Custom: 所有我们自己安装的插件 安装插件Install JetBrains plugins(安装JetBrains插件)单击【Install JetBrains plugin】，然后弹出插件列表 插件排序: 插件列表默认按name排序，同时允许添加排序条件(多选) 插件分类 安装插件 选中插件 -&gt; 在插件简介中单击【Install】按钮 下载插件 下载完成后重启Android Studio，插件安装成功 设置代理 Browse Repositories(浏览插件仓库)我们想查看插件仓库中所有的插件，可以单击【Browse repositories】，然后弹出插件列表，这里的操作跟安装JetBrains插件是一样的。 Install plugin from disk(从本地磁盘安装插件) 下载插件到本地。到Android Studio插件官网(https://plugins.jetbrains.com/?androidstudio)找到自己想要的插件，下载到本地。 单击【Install plugin from disk】 -&gt; 选择下载的插件 重启Android Studio 禁用插件Android Studio中默认安装了一些根本用不到的插件，可以禁用这些插件 操作步骤: 偏好设置 -&gt; Plugins -&gt; 取消勾选想禁用的插件 -&gt; 重启 -&gt; 生效 卸载插件操作步骤: 偏好设置 -&gt; Plugins -&gt; 选中插件 -&gt; Uninstall 常用插件编辑器插件 插件名 描述 Key promoter 用于生成快捷键提示 CodeGlance 用于生成代码缩略图，方便快速定位 Eclipse Code Formatter 用于使用Eclipse的代码格式化风格 BashSupport 用于支持Bash语言 IdeaVim 用于支持VIM Grep Console 用于自定义控制台输出颜色 Maven Helper 用于查看Maven依赖树 代码工具插件 插件名 描述 String Manipulation 用于快速切换驼峰式命名和下划线命名 GsonFormat 用于快速格式化json数据，自动生成实体类参数 Android ButterKnife Zelezny 用于快速添加Butterknife注解 Android Drawable Importer 用于快速导入缩放图标到Android项目中 Android Parcelable code generator 用于快速实现Parcelable 接口 Android Postfix completion 用于根据后缀快速完成代码 AndroidAccessors 用于快速实现get和set方法的插件 Android Postfix Completion 用于快速编写Toast，Log，isEmpty,FindView等代码 JavaDoc 用于快速生成Java注释，可自定义模板 检查工具插件 插件名 描述 CheckStyle-IDEA 用于检查Java源代码是否符合编码规则 FindBugs-IDEA 用于检查Java代码中潜在的问题 MetricsReloaded 用于检查代码复杂度 其他常用插件 插件名 描述 Android WiFi Adb 用于通过WIFI连接ADB，不需要root ADB Idea 用于在Android Studio中可视化使用ADB命令 RESTClient 用于测试RESTful web services JSONOnlineViewer 用于直接在Android Studio中调试接口数据 jimu Mirror 用于在真机上快速测试布局 Codota 用于搜索Android代码实例 Genymotion 用于使用Genymotion运行和调试应用 编译和构建设置Android Studio的内存参数操作步骤: 菜单栏 -&gt; Help -&gt; Edit Custom VM Options 设置自动编译项目操作步骤: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Compiler -&gt; 勾选【Make project automatically】 设置并行编译想提升编译速度，可开启并行编译，这样会比单线程一次编译快很多。 操作步骤: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Compiler -&gt; 勾选【Compile independent modules in parallel】 调整编译内存大小操作步骤: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Compiler -&gt; 在【Command-line Options】中输入调整的内存参数 Gradle离线工作每次打开项目或者导入项目，Android Studio总会联网检查依赖的文件是否已经下载，是否有新版本，这样会导致速度很慢。如果我们清楚依赖的文件已经下载且不想更新到最新版本，可以使用Gradle离线工作模式 操作步骤: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Gradle -&gt; 勾选【Offline work】 如果使用离线工作模式可能导致项目报错，这时可以单击同步项目: Sync Project with Gradle Files 参考资料《精通Android Studio》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[新一年知识点回顾]]></title>
      <url>%2F2018%2F03%2F15%2Fnew-year-review%2F</url>
      <content type="text"><![CDATA[前言总算过完年了，距离Android的工作已经过去半年多了，总是要自己总结下得失，回顾下以往的知识点的。过去的一年，在工作上学到了很多，内存的优化管理，直播间动画的绘制，socket长连接的开发，以及其他总总第三方库的学习。让自己也提高了很多，也开始尝试使用Kotlin开发应用。尝试调用第三方电影数据库API，来进行一个自己Android项目的开发，使用了Google新推出的Android Architecture Component，规范自己的开发。虽然成长了一些，但对于以后所要学习和接触的东西变得更加渴望，感觉对于知识点的掌握，还是欠缺很多，希望记录并且回顾一下。部分笔记是以前就有记录的，现在回顾一下，并且加入一些新的内容与自己的感悟。 知识点绘图Android 的绘图是]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第三方库使用笔记]]></title>
      <url>%2F2018%2F03%2F10%2Fthird-library-note%2F</url>
      <content type="text"><![CDATA[前言项目开发中总是使用以及接入第三方库，记录一下使用过程，以及其中所遇到的问题，方便以后更加有效率的开发。 Bugly简介Bugly，属于腾讯，为移动开发者提供专业的异常上报和运营统计，帮助开发者快速发现并解决异常，同时掌握产品运营动态，及时跟进用户反馈。主要用来处理Bug反馈以及轻量运营管理。地址 集成操作SDK文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kotlin学习笔记]]></title>
      <url>%2F2018%2F01%2F27%2Fnote-kotlin-study%2F</url>
      <content type="text"><![CDATA[前言Kotlin语言从问世到现在已经有很久的时间了，2017年终于Google将Kotlin列为开发Android应用的一级语言。而且Kotlin和Java具有高度可互操作性，并且相较于Java更加简单，精炼，还添加了Java在Android中尚不支持的一些必备功能。学习Kotlin与时俱进是必须的。 Kotlin语言基础变量 var是可写的，在其生命周期中可以被多次赋值 val是只读的，仅能赋值一次 变量类型在大部分情况下无需申明 is 运算符可以对变量的类型进行判断，并且检测之后的分支中可以直接当做该类型使用，无需显式转换 三重引号内可以完整的输出原生字符串的格式 流程控制语句 分支语句（if,when） if是一个表达式，可以将代码块的最后一行作为其返回值 如果if表达式只有一个分支，或者分支的结果是Unit，它的值就是Unit when表达式类似switch-case表达式，可以用任意表达式作为判断条件，也可以检测（in）或者（!in）在一个区间中 循环语句（for,while） for循环可以对任何提供迭代器的对象进行遍历 for循环通过索引遍历一个数组或者一个list，可以for(i in array.indices) print(array[i]) for循环可以使用库函数withIndux操作for((index,value) in array.withIndex()) println(&quot;the element at $index is $value&quot;) 跳转语句（break,continue,return,throw） 标签(abc@)可以定义跳转语句，直接跳转到标签位置 修饰符 modifiers (modifier | annotations)* typeModifiers (suspendModifier | annotations)* modifier classModifier accessModifier varianceAnnotation memberModifier parameterModifier typeParameterModifier functionModifier propertyModifier classModifier 类修饰符 abstract 抽象类 final 不可被继承final类 enum 枚举类 open 可继承open类 annotation 注解类 sealed 密封类 data 数据类 memberModifier override 重写函数 open 可被重写 final 不可被重写 abstract 抽象函数 lateinit 后期初始化 accessModifier 访问权限控制，默认是public private protected public internal varianceAnnotation 泛型可变类 in out parameterModifier noinline crossinline vararg 变长参数 typeParameterModifier reified functionModifier tailrec 尾递归 operator infix inline external suspendModifier propertyModifier const suspendModifier suspend 关键字this关键字 在类的成员中，this指的是该类的对象 在扩展函数或者带接收者的函数字面值中，this表示在点左侧传递的接收者参数 在内部类中，它指的是最内层的包含它的作用域，如果我们想要引用其他作用域中的this，可以使用this@lable标签 super关键字 super关键字持有指向其父类的引用 操作符 重载操作符 重载操作符的函数需要用operator修饰符标记 中缀操作符的函数使用infix修饰符标记 相等与不相等操作符 引用相等 === !== ( 两个引用指向同一个对象 ) 如果a和b指向同一个对象，则a===b为true 结构相等 == != （ 使用equals()判断 ）a==b --&gt; a?.equals(b)?:(b===null) Elvis操作符?:（二元运算符） Elvis操作符特定是跟null比较，主要用来作null安全检查。 Kotlin没有true?1:0三元运算符，取而代之是if(true) 1 else 0 扩展函数和扩展属性 扩展函数 fun String.notEmpty():Boolean { return !this.isEmpty()} this关键字在扩展函数内部对应到接收者对象 扩展属性 扩展没有实际的将成员插入类中，它的行为只能由显式提供的getters/setters表示 空指针安全 ?.安全调用 如果变量为null，则返回null。 !!.非空断言调用 如果变量为null，则抛出kotlin.KotlinNullPointerException异常 标准库APIJava和JS共用的公共库 包名 功能说明 kotlin 核心函数和数据类型，支持所有平台 kotlin.annotation 为kotlin注解功能提供支持 kotlin.collections 集合类型，入Iterable、Collection、List、Set、Map等 kotlin.comparisons 帮助函数用于创建Comparator比较器实例 kotlin.coroutines.experimental(1.1) 支持协程，包括支持延迟序列(lazy sequence)等 kotlin.coroutines.experimental.intrinsics(1.1) 基于协程的API库的底层构建块 kotlin.experimental(1.1) 实验API，将来版本可能会改变 kotlin.io IO API用于处理文件和流 kotlin.properties 代理/委托属性的标准实现，帮助函数实现自定义代理/委托 kotlin.ranges 范围/区间，数列Progressions和相关扩展功能 kotlin.reflect Kotlin反射的运行时API kotlin.sequences 序列类型表示延迟求值的集合、实例化序列和扩展函数 kotlin.text 处理文本和正则表达式的函数 Java平台的Kotlin库 包名 功能说明 kotlin.concurrent 并发（concurrent）编程Kotlin函数库 kotlin.jvm Java平台特有的函数和注解 kotlin.reflect.full(1.1) Kotlin反射库的扩展Extensions kotlin.reflect.jvm Kotlin与Java反射的互操作运行时API kotlin.streams(1.1,JRE8) 处理Java8流的Kotlin函数库 kotlin.system 与系统相关的Kotlin函数库 JavaScript平台的Kotlin库 包名 功能说明 kotlin.browser 在浏览器环境下访问顶层属性（如document、Window等） kotlin.dom 处理浏览器DOM的Kotlin函数库 kotlin.js JavaScript平台特有的一些函数和API org.khronos.webgl WebGL API的Kotlin包装器 org.w3c.dom DOM API的Kotlin包装器 org.w3c.dom.css DOM CSS API的Kotlin包装器 org.w3c.dom.events DOM events API的Kotlin包装器 org.w3c.dom.parsing DOM parsing API的Kotlin包装器 org.w3c.dom.svg DOM SVG API的Kotlin包装器 org.w3c.dom.url DOM URL API的Kotlin包装器 org.w3c.xhr XML HttpRequest API 的Kotlin包装器 org.w3c.files W3C file API的Kotlin包装器 org.w3c.notifications Web Notification API的Kotlin包装器 org.w3c.performance Navigation Timing API的Kotlin包装器 org.w3c.workers Web Workers API的Kotlin包装器 基本数据类型与类型系统Kotlin是一门强类型、静态类型、支持隐士类型的显式类型语言。 强类型：在运行时确保不会发生未经明确转换的类型转换。（一个语言的编译器引入越多的类型检查的限制，就可以称这个语言的类型检查越强） 静态类型：静态类型检查能让很多bug在编码早期就被捕捉到，并且它也能优化运行。（类型检查可发生在编译时期（静态检查）或运行时期（动态检查）） 显式类型：定义变量时显式给出变量的类型（根据变量名是否需要显式给出类型的声明，分为显式类型语言和隐式类型语言） 根类型 AnyKotlin中所有类都有一个共同的超类Any，同Java中java.lang.Object 基本类型Kotlin中一切皆是对象，所有类型都是引用类型。 数字类型（Number） 类型 宽度(Bit) Double 64 Float 32 Long 64 Int 32 Short 16 Byte 8 这些内置的数据类型，都继承了Number和Comparable类。 Kotlin的数字类型与Java基本相同。但Kotlin对于数字没有隐式拓宽转换（如Java中int可以隐式转换为long），因为值范围较小类型并不是较大类型的子类型。 val i: Int = b.toInt() toDouble() : Double toFloat() : Float toLong() : Long toInt() : Int toChar() : Char toShort() : Short toByte() : Byte 位运算，没有特殊字符来表示，只可用中缀方式调用命名函数 位运算列表（只用于Int和Long） shl(bits)————有符号左移（Java的&lt;&lt;） shr(bits)————有符号右移（Java的&gt;&gt;） ushr(bits)————无符号右移（Java的&gt;&gt;&gt;） and(bits)————位与 or(bits)————位或 xor(bits)————位异或 inv()————位非 布尔类型 ！逻辑非：not() &amp;&amp;短路逻辑与：and() ||短路逻辑或：or() 异或（相同false，不同true）：xor 字符串类型 索引运算符s[i]： 字符串元素————字符可以使用索引运算符s[i]来访问 for循环迭代字符串 字符串类重载了+操作符，作用对象可以是任何对象，包括null 截取字符串的子串（subSequence(0,1)） trimMargin(marginPrefix:String = “|”):去除默认为边界字符为”|”的前导空格 trimIndent():把字符串行左边空白对齐切割 以美元符($)开头做字符串模板:val str = &quot;$s.length is ${s.length}&quot; 数组类型 数组在Kotlin中使用Array类表示，定义了get和set函数以及size属性。 可以使用arrayOf()来创建一个数组并传递元素值给Array Kotlin还允许不同类型元素放到一个数组中 arrayOfNulls()可以用于创建一个指定大小、元素都为空的数组。这个特殊的空数组在创建时，需要指定元素的类型。arrayOfNulls&lt;Int&gt;(10) 数组Array类还提供了一个构造函数public inline constructor(size:Int,init:(Int) -&gt; T) 例：val square = Array(10,{i -&gt; (i*i)}) []运算符代表调用成员函数get()和set() 原生数组类型 BooleanArray ———— booleanArrayOf(vararg elements: Boolean) ByteArray ———— byteArrayOf(vararg elements: Byte) CharArray ———— charArrayOf(vararg elements: Char) ShortArray ———— shortArrayOf(vararg elements: Short) IntArray ———— intArrayOf(vararg elements: Int) LongArray ———— longArrayOf(vararg elements: Long) FloatArray ———— floatArrayOf(vararg elements: Float) DoubleArray ———— doubleArrayOf(vararg elements: Double) 可空类型 null 是 Nothing? 类型的 Any?是Kotlin的类型层次结构的最顶端 Kotlin.Unit类型Kotlin中的Unit类型实现了与Java中的void一样的功能。当一个函数没有返回值时，我们用Unit来实现这个特征，而不是null kotlin.Nothing类型在Kotlin类型层次结构的最底层就是类型Nothing 类型检测与类型转换is与!is运算符 is运算符类似于Java的instanceOf，用来检查对象是否属于某数据类型 is会自动对对象的数据类型进行安全的转换 as运算符 as运算符用于执行引用类型的显式类型转换。如果兼容则转换成功，否则as?运算符返回null，as抛出异常 集合类世间本无集合；有人想要，于是就用数组创造了集合类；有人想要可以自动扩展容量的数组，于是有了List；有人想要元素不重复的数组，于是有了Set；有人想要有序的数组，于是有了TreeSet，TreeList；有人想要通过复杂对象来查找另一个对象的关联数组，于是有了Map； 几乎所有集合都是基于数组来实现的，所以数组比集合要快 集合是数组的高层次的抽象封装，集合的功能比数组要多 Kotlin集合类分为：可变集合类(Mutable)和不可变集合类(Immutable) 集合类型主要有3种：list(列表)、set(集)、map(映射) ListList接口继承与Collectio接口，元素以线性方式存储，集合中可以存放重复对象。 不可变集合类List(ReadOnly,Immutable): 使用listOf()函数来创建没有元素的空List 使用listOf(element: T)函数来创建只有一个元素的List 使用listOf(vararg elements: T)函数来创建有多个元素的List asList()是Array的扩展函数 arrayListOf()函数可以直接创建一个Java中的ArrayList对象实例 可变集合MutableList 新增了add/addAll,remove/removeAll/removeAt,set,clear,retainAll mutableListOf()函数来创建 mutableListOf()函数和直接使用arrayListOf()函数一样都是创建了一个ArrayList类 不可变的List可以通过调用转换函数toMutableList()来将其转换成可变的List 遍历List元素 使用Iterator迭代器（Kotlin中的Iterator功能比较简单，并且只能单向移动） 调用iterator()函数，容器返回一个Iterator实例 调用hasNext()函数检查序列中是否还有元素 第一次调用next()函数，返回序列的第一个元素，依次向后递推 - 使用forEach遍历List元素 list.forEach({println(it)}) List元素操作函数 add/remove 是MutableList的 添加一个元素mutableList.add(4) 在下标为0的位置添加元素0mutableList.add(0,0) 删除元素1mutableList.remove(1) 删除下标为1的元素mutableList.removeAt(1) 删除子集合mutableList.removeAll(listOf(3,4)) 添加子集合mutableList.addAll(listOf(1,2,3)) set/clear操作 更新设置下标为0的元素值为100mutableList.set(0,100) 清空集合mutableList.clear() 把可变集合转为不可变集合mutableList.toList() retainAll 取两个集合交集mList1.retainAll(mList2) contains(element:T) Boolean 判断集合中是否有指定元素list.contains(1) elementAt(index: Int): T 查找下标对应的元素list.elementAt(6) 查找下标对应元素，如果越界根据方法返回默认值list.elementAtOrElse(7,{0}) 查找下标对应元素，如果越界就返回nulllist.elementAtOrNull(7) first() 返回集合第一个元素，如果是空集，抛出异常 list.first() 对应的有针对异常处理的函数firstOrNull():T? emptyList.firstOrNull() 返回符合条件的第一个元素，没有则抛出异常 list.first(it % 2 == 0) 对应的有针对异常处理的函数firstOrNull(oerducate:(T)-&gt;Boolean):T?返回符合条件的第一个元素，没有就返回nullist.firstOrNull({it &gt; 100}) indexOf(element: T): Int 返回指定下标的元素，没有就返回-1 list.indexOf(&quot;c&quot;) indexOfFirst(predicate:(T) -&gt; Boolean):Int 返回第一个符合条件的元素下标，没有就返回-1 list.indexOfFirst({it.contains(&quot;x&quot;)}) indexOfLast(predicate:(T) -&gt; Boolean):Int 返回最后一个符合条件的元素下标，没有就返回-1 list.indexOfLast(it.contains(&quot;k&quot;)) last() 返回集合最后一个元素，空集抛出异常 list.last() last(predicate:(T) -&gt; Boolean): T 返回符合条件的最后一个元素，没有就抛出异常 list.last({it &gt; 10}) 对应的针对越界处理的lastOrNull函数，返回符合条件的最后一个元素，没有则返回null list.lastOrNull({it &gt; 10}) lastIndexOf(element: T): Int 返回符合条件的最后一个元素，没有就返回-1 list.lastIndexOf(&quot;abc&quot;) single(): T 该集合如果只剩下一个元素，则返回该元素，否则抛出异常 list.single() single(predicate: (T) -&gt; Boolean): T 返回符合条件的单个元素，否则抛出异常，或超过一个的抛异常 list.single({it == 1}) 对应的针对越界处理的singleOrNull函数，返回符合条件的单个元素，否则返回null list.singleOrNull({it == 7}) List集合的基本运算函数 any() 判断该元素至少有一个元素 list.any() any(predicate:(T) -&gt; Boolean) 判断集合中是否有满足条件的元素 list.any({list &gt; 4}) all(predicate: (T) -&gt; Boolean) 判断集合中的元素是否都满足条件，当且仅当该集合中的所有元素都满足条件时，返回true。 list.all({it &gt; 2}) none() 判断集合无元素，该集合没有任何元素，返回true list.none() none(predicate:(T) -&gt; Boolean) 判断集合中所有元素都不满足条件 list.none({it % 2 == 1}) count() 计算集合中的元素的个数 list.count() count(predicate:(T) -&gt; Boolean) 计算集合中满足条件的元素的个数 list.count({it % 2 == 0}) reduce 从第一想到最后一项进行累计运算，首先把第一个元素赋值给累加子accumulator,然后逐次向后取元素累加，新值继续赋值给累加子accumulator = operation(accumulator,iterator.next())，依次类推，最后返回累加子的值 list.reduce({total,s -&gt; total + s}) reduceRight 从最后一项到第一项进行累计运算，从右边累计运算的累加子是放在后面的 list.reduceRight({total,s -&gt; s + total}) fold(initial:R,operation:(acc:R,T)-&gt;R):R 是带初始值的reduce，fold函数给累加子赋了初始值initial list.fold(100,{total,next -&gt; next + total}) foldRight 和 reduceRight类似，有初始值 forEach(action:(T) -&gt; Unit):Unit 循环遍历元素，元素是it list.forEach{value -&gt; if (value &gt; 7) println(value)} forEachIndexed 带index(下标)的元素遍历 list.forEachIndexed(index,value -&gt; if(value &gt; 8) println(&quot;value of index $index is $value,greater than 8&quot;)) max、min 查询最大、最小的元素，空集返回null list.max() maxBy(selector:(T)-&gt;R):T?、minBy(selector:(T)-&gt;R):T? 获取函数映射结果的最大值、最小值对应的那个元素的值，如果没有则返回null。是通过selector函数的返回值来比较大小，获取最终的最大值和最小值。 list.maxBy({it * (1 - it)}) sumBy(selector:(T) -&gt; Int):Int 获取函数映射值的总和 list.sumBy({it * it}) 过滤操作函数 take(n:Int):List&lt;T&gt; 挑出该集合前n个元素的子集合，如果n=0，返回空集，如果n大于集合size，返回该集合。list.take(10) takeWhile(predicate:(T) -&gt; Boolean):List&lt;T&gt; 挑出满足条件的元素的子集合，从第一个元素开始，判断是否满足predicate为true，如果满足条件的元素就丢到返回ArrayList中，只要遇到任何一个不满足条件，就结束循环，返回list。 list.takeWhile({it % 2 == 0}) takeLast 挑出最后n个元素的子集合，从集合倒数n个元素起，取出到最后一个元素的子集合。如果传入0，返回空集。如果传入n大于集合size，返回整个集合。如果传入负数，抛出异常。list.takeLast(2) takeLastWhile(predicate:(T) -&gt; Boolean) 从最后开始挑出满足条件元素的子集合。反向取满足条件的元素，遇到不满足的元素，直接终止循环，并返回子集合。 list.takeLastWhile({it % 2 == 0}) drop(n:Int) 去除前n个元素返回剩下的元素的子集合 list.drop(5) dropWhile(predicate:(T)-&gt;Boolean) 去除满足条件的元素返回剩下的元素的子集合。去除满足条件的元素，当遇到一个不满足条件的元素时，中止操作，返回剩下的元素子集合。 list.dropWhile({it % 2 == 0}) dropLast(n:Int) 从最后去除n个元素 list.dropLast(3) dropLastWhile(predicate:(T) -&gt; Boolean) 从最后去除满足条件的元素 list.dropLastWhile({it % 2 == 0}) slice(indices:IntRange) 取开始下标至结束下标元素子集合 list.slice(1..3) slice(indices:Iterable&lt;Int&gt;) 返回指定下标的元素子集合 list.slice(listOf(2,4,6)) filterTo(destination:C,predicate:(T) -&gt; Boolean) 过滤出满足条件的元素并赋值给destination。把满足过滤条件的元素组成的子集合赋值给入参destination。 list.filterTo(dest,{it &gt; 3}) filter(predicate:(T)-&gt;Boolean) 过滤出满足条件的元素组成的子集合。相对于filterTo函数，filter函数更加简单易用。 list.filter({it &gt; 3}) filterNot(predicate:(T) -&gt; Boolean) 用来过滤所有不满足条件的元素 filterNotNull() 过滤掉null元素 映射操作函数 map(transform:(T)-&gt;R):List&lt;R&gt; 将集合中的元素通过转换函数transform映射后的结果，存到一个集合中返回。 list.map({it * it}) mapIndexed(transform:(kotlin.Int,T) -&gt; R) 转换函数transform中带有下标参数。可以同时使用下标和元素的值来进行转换。 list.mapIndexed({index,it -&gt; index * it}) mapNotNull(transform:(T) -&gt; R?) 遍历集合每个元素，得到通过函数算子transform映射之后的值，剔除掉这些值中的null，返回一个无null元素的集合。 list.mapNotNull({it}) flatmap(transform:(T)-&gt;Iterable&lt;R&gt;):List&lt;R&gt; 在原始集合的每个元素上调用transform转换函数，得到的映射结果组成的单个列表。与map相比，使用map是把list中的每一个元素都映射成一个List-n,然后以这些List-n为元素，组成一个大的嵌套的List返回。而使用flatMap则是把list中的第一个元素映射成一个List1，然后把第二个元素映射成的List2跟List1合并，最终返回一个扁平的List。 分组操作函数 groupBy(keySelector:(T) -&gt; K):Map]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-项目架构]]></title>
      <url>%2F2017%2F11%2F04%2Fnote-android-architecture%2F</url>
      <content type="text"><![CDATA[前言写完一个小项目，接着写下一个的时候，总是会发现，有些必要的工具库或者代码库，要回过头去寻找。又或者一些库的名字有所遗忘，版本有更新，再去寻找的时候，总是会浪费很多时间。所以在这篇文章中，记录一下日后项目构建所需要的代码库的地址和配置，以及一些简单必要的代码。 工具库RxLifecycleInstallation12345678910111213141516171819202122compile &apos;com.trello.rxlifecycle2:rxlifecycle:2.2.1&apos;// If you want to bind to Android-specific lifecyclescompile &apos;com.trello.rxlifecycle2:rxlifecycle-android:2.2.1&apos;// If you want pre-written Activities and Fragments you can subclass as providerscompile &apos;com.trello.rxlifecycle2:rxlifecycle-components:2.2.1&apos;// If you want pre-written support preference Fragments you can subclass as providerscompile &apos;com.trello.rxlifecycle2:rxlifecycle-components-preference:2.2.1&apos;// If you want to use Navi for providerscompile &apos;com.trello.rxlifecycle2:rxlifecycle-navi:2.2.1&apos;// If you want to use Android Lifecycle for providerscompile &apos;com.trello.rxlifecycle2:rxlifecycle-android-lifecycle:2.2.1&apos;// If you want to use Kotlin syntaxcompile &apos;com.trello.rxlifecycle2:rxlifecycle-kotlin:2.2.1&apos;// If you want to use Kotlin syntax with Android Lifecyclecompile &apos;com.trello.rxlifecycle2:rxlifecycle-android-lifecycle-kotlin:2.2.1&apos; 地址Github Gson地址Github RxPickerInstallationcompile &#39;com.caimuhao:rxpicker:1.1.5&#39; 地址Github MNCrashMonitorCrashMonitor 监听程序崩溃日志,直接页面展示崩溃日志列表 Installation 在Project的build.gradle中添加仓库地址 123456allprojects &#123; repositories &#123; ... maven &#123; url &quot;https://jitpack.io&quot; &#125; &#125; &#125; 在app目录下的build.gradle中添加依赖 123dependencies &#123; compile &apos;com.github.maning0303:MNCrashMonitor:V1.0.5&apos;&#125; 地址Github LoggerInstallationcompile &#39;com.orhanobut:logger:2.1.1&#39; 地址Github ASimpleCache地址Github Android Studio Plugins地址Github RxGpsInstallationcompile &#39;com.github.florent37:rxgps:(last version)&#39; 地址Github ObjectBoxInstallationAdd this to your root build.gradle (project level): 12345678910111213141516buildscript &#123; ext.objectboxVersion = &apos;1.3.4&apos; repositories &#123; maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125; dependencies &#123; classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot; &#125; &#125;allprojects &#123; repositories &#123; maven &#123; url &quot;http://objectbox.net/beta-repo/&quot; &#125; &#125;&#125; And this to our app’s build.gradle (module level): apply plugin: &#39;io.objectbox&#39; // after applying Android plugin 地址Github ARouterInstallation123456789101112131415161718android &#123; defaultConfig &#123; ... javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ moduleName : project.getName() ] &#125; &#125; &#125;&#125;dependencies &#123; // 替换成最新版本, 需要注意的是api // 要与compiler匹配使用，均使用最新版可以保证兼容 compile &apos;com.alibaba:arouter-api:x.x.x&apos; annotationProcessor &apos;com.alibaba:arouter-compiler:x.x.x&apos; ...&#125; 地址Github RxFileInstallationcompile &#39;com.github.pavlospt:rxfile:1.7&#39; 地址Github MatisseInstallation1234567repositories &#123; jcenter()&#125;dependencies &#123; compile &apos;com.zhihu.android:matisse:0.4.3&apos;&#125; 地址Github JKeyboardPanelSwitchInstallationcompile &#39;cn.dreamtobe.kpswitch:library:1.6.0&#39; 地址Github PhoenixInstallation12345678//图片/视频选择、预览、编辑与拍照compile &apos;com.github.guoxiaoxing:phoenix:x&apos;//选填 - 图片压缩，开启功能：Phoenix.with().enableCompress(true)，获取结果：MediaEntity.getCompressPath()compile &apos;com.github.guoxiaoxing:phoenix-compress-picture:1.0.11&apos;//选填 - 视频压缩，开启功能：Phoenix.with().enableCompress(true)，获取结果：MediaEntity.getCompressPath()compile &apos;com.github.guoxiaoxing:phoenix-compress-video:1.0.11&apos; 地址Github AndroidPerformanceMonitorInstallation12345678dependencies &#123; // most often used way, enable notification to notify block event compile &apos;com.github.markzhai:blockcanary-android:1.5.0&apos; // this way you only enable BlockCanary in debug package // debugCompile &apos;com.github.markzhai:blockcanary-android:1.5.0&apos; // releaseCompile &apos;com.github.markzhai:blockcanary-no-op:1.5.0&apos;&#125; 地址Github drawable-optimizerInstallationIn build.gradle 12345678buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;org.fabiomsr:drawable-optimizer-gradle-plugin:1.0.4&apos; &#125;&#125; And in app\build.gradle 12// Make sure this line comes *after* you apply the Android plugin (apply plugin: &apos;com.android.application&apos;)apply plugin: &apos;org.fabiomsr.drawableoptimizer&apos; Android-Debug-DatabaseInstallationdebugCompile &#39;com.amitshekhar.android:debug-db:1.0.1&#39; 地址Github RxAndroidInstallation1234compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1&apos;// Because RxAndroid releases are few and far between, it is recommended you also// explicitly depend on RxJava&apos;s latest version for bug fixes and new features.compile &apos;io.reactivex.rxjava2:rxjava:2.1.7&apos; 地址Github RxPermissionsInstallationcompile &#39;com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar&#39; 地址Github UI库android-Ultra-Pull-To-RefreshInstallationcompile &#39;in.srain.cube:ultra-ptr:1.0.11&#39; 地址Github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-小想法]]></title>
      <url>%2F2017%2F11%2F04%2Fandroid-small-idea%2F</url>
      <content type="text"><![CDATA[小想法看了那么多前辈的博客，之前的博客也有从网上搜集资料，总结的博客。但总觉得程序员的成长还是需要由自己的思想来完成博客的搭建，而且由自己边写代码边完成博客，对自身的知识总结以及对知识的学以致用还是有很大帮助的。所以打算以后多多总结项目中的错误，也可以总结自身开发项目的经验，把知识总结归纳起来，帮助自身有更大的提高。 消停了一段时间，发现果然还是写代码更能给我带来快乐哈哈哈哈哈！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-性能优化]]></title>
      <url>%2F2017%2F11%2F03%2Fandroid-performance-optimize%2F</url>
      <content type="text"><![CDATA[前言性能检测与分析，一直在 APP 开发中相当重要，但又被我们常常忽略。很多 APP 或者开发者总是急功近利，总想着快速充实 APP 的相关功能，把开发进度放在首位没有问题，可很多时候就没有然后了，这在整个开发界屡见不鲜。在这样的大背景下，加之我之前写的 RxJava 2.0 系列 收到较好的反馈，诱导我想出这么一个性能优化系列。 一些你可能需要知道的了解我的知道，我出的系列基本都是比较基础，而且侧重于常见必备。所以不一定全面，也不一定深入，所以希望理解。性能优化大概可以概括为： 性能优化说起来很简单，但做起来难。 性能优化点多并且繁杂，需要耐心和经验。也许每个优化点很小，但积累起来会从量变变成质的飞跃。 性能优化必须建立在产品设计之上，不能为了追求性能而忽略了产品设计。 提供一些资源 ( 你可能需要梯子 ) 性能优化最佳实践 性能优化工具 善用 ArrayMap程序内存的管理是否合理高效对应用的性能有着很大的影响，有时候对容器的使用不当也会导致内存管理效率低下。想必已经有很多童鞋知道了 SparseArray，但它只是用于替代 List。我们经常会在程序中用到 HashMap，它非常好用，这毋庸置疑。但它却非常耗内存。HashMap 的工作原理这里我们就不讲了，有兴趣的自行科普。 更高效的 ArrayMap 容器为了解决 HashMap 更占内存的弊端，Android 提供了内存效率更高的 ArrayMap。它内部使用两个数组进行工作，其中一个数组记录 key hash 过后的顺序列表，另外一个数组按 key 的顺序记录 Key - Value 的值。如下图所示： 当你想获取某个 Value 的时候，ArrayMap 会计算输入 key 转换过后的 hash 值，然后对 hash 数组使用二分查找法寻找到对应的 index，然后我们可以通过这个 index 在另外一个数组中直接访问到需要的键值对。如果在第二个数组键值对中的 key 和前面输入的查询 key 不一致，那么就认为是发生了碰撞冲突。为了解决这个问题，我们会以该 key 为中心点，分别上下展开，逐个去对比查找，直到找到匹配的值。如下图所示： 随着数组中的对象越来越多，查找访问单个对象的花费也会跟着增长，这是在内存占用与访问时间之间做权衡交换。既然ArrayMap中的内存占用是连续不间断的，那么它是如何处理插入与删除操作的呢？请看下图所示，演示了Array的特性： 很明显，ArrayMap 的插入与删除的效率是不够高的，但是如果数组的列表只是在一百这个数量级上，则完全不用担心这些插入与删除的效率问题。HashMap 与 ArrayMap 之间的内存占用效率对比图如下： 与 HashMap 想必，ArrayMap 在循环遍历的时候也更加简单高效，因为其采用的是 fori 循环，而 HashMap 却使用的是糟糕的 Iterator。 并不是所有情况下都用 ArrayMapArrayMap 这么优秀，但并不是所有情况下都适合使用 ArrayMap，我们应该在满足下面两个条件的时候才考虑使用 ArrayMap： 对象个数的数量级最好在 1000 以内。 数据组织形式包含 Map 结构。 所以我们需要学会在特定清醒下选择相对更加高效的实现方式。 UI 性能确实很重要UI 界面是整个 APP 性能的最前端展示，也是最容易看出性能问题的地方。可以毫不夸张地说，UI 性能的好坏直接影响这用户的体验和留存。UI 性能的目标是： 减少绘图的等待时间。 使帧率更加平稳、连贯。 UI 布局的核心原则核心原则一句话，尽可能地减少 View 的数量！我们可以通过 include、merge、viewstub 进行布局复用，通过控件属性 DrawableLeft、DrawableRight 等方式进行控件整合。 听说我们要尽可能地用 RelativeLayout ?想必一些资历较老的 Android 开发者都知道，一开始系统默认创建的布局是 LinearLayout，后面替换成了 RelativeLayout，现在又变成了 ConstraintLayout 。由于我对 ConstraintLayout 不是特别了解，所以这里我着重说说 RelativeLayout 和 LinearLayout 。我不知道在什么时候听说过，如果我们能用 RelativeLayout 的地方，尽量不要用 LinearLayout 。这种说法是不对的，实际开发中，决不能简单地说 RelativeLayout 和 LinearLayout 谁的性能更好，必须结合实际使用来进行分析。基本可以总结为：一般情况下，如果使用 LinearLayout，则一定要保证层级不能太深；如果使用 RelativeLayout，则需要尽量避免嵌套。 正文提高 APP 的启动速度对我们意义深远，很显然，APP 的启动时间越短，使用它的用户越有耐心等待打开这个 APP 进行使用。反之，启动时间太长，用户则有可能还没等到 APP 打开就已经切换到其他 APP 了。 程序启动过程中那些复杂错误的操作很有可能导致严重的性能问题。Android 系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android 系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他 APP 界面切换回来）。 那么关键的问题是，用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他 APP 了。更严重的是，如果启动时间过长，可能导致程序出现 ANR。我们应该避免出现这两种糟糕的情况。 从技术角度来说，当用户点击桌面图标开始，系统会立即为这个 APP 创建独立的专属进程，然后显示启动窗口，直到 APP 在自己的进程里面完成了程序的创建以及主线程完成了 Activity 的初始化显示操作，再然后系统进程就会把启动窗口替换成 APP 的显示窗口。 上述流程里面的绝大多数步骤都是由系统控制的，一般来说不会出现什么问题，可是对于启动速度，我们能够控制并且需要特别关注的地方主要有三处： Activity 的 onCreate 流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题。 Application 的 onCreate 流程，对于大型的 APP 来说，通常会在这里做大量的通用组件的初始化操作。 目前有部分 APP 会提供自定义的启动窗口，这里可以做成品牌宣传界面或者是给用户提供一种程序已经启动的视觉效果。 在正式着手解决问题之前，我们需要掌握一套正确测量评估启动性能的方法。所幸的是，Android 系统有提供一些工具来帮助我们定位问题。 有趣的启动时长定位display time从 Android KitKat 版本开始，Logcat 中会输出从程序启动到某个 Activity 显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。 reportFullyDrawn()我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用 activity.reportFullyDrawn() 方法来告诉系统此时的状态，以便获取整个加载的耗时。 Method Tracing前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用 Method Tracing 工具来进行详细的测量。 Systrace我们可以在 onCreate() 方法里面添加 trace.beginSection() 与 trace.endSection() 方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。 如果优化 APP 启动速度？提升 Activity 的创建速度提升 Activity 的创建速度是优化 APP 启动速度的首要关注目标。从桌面点击 APP 图标启动应用开始，程序会显示一个启动窗口等待 Activity 的创建加载完毕再进行显示。在 Activity 的创建加载过程中，会执行很多的操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写 Preference 等等。 上述操作的任何一个环节出现性能问题都可能导致画面不能及时显示，影响了程序的启动速度。上一个段落我们介绍了使用 Method Tracing 来发现那些耗时占比相对较多的方法。假设我们发现某个方法执行时间过长，接下去就可以使用 Systrace 来帮忙定位到底是什么原因导致那个方法执行时间过长。 除了使用工具进行具体定位分析性能问题之外，以下两点经验可以帮助我们对 Activity 启动做性能优化： 优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！ 异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。 别让 Application 初始化不必要的东西在 Application 初始化的地方做太多繁重的事情是可能导致严重启动性能问题的元凶之一。Application 里面的初始化操作不结束，其他任意的程序操作都无法进行。 有时候，我们会一股脑的把绝大多数全局组件的初始化操作都放在 Application 的 onCreate() 里面，但其实很多组件是需要做区队对待的，有些可以做延迟加载，有些可以放到其他的地方做初始化操作，特别需要留意包含 Disk IO 操作，网络访问等严重耗时的任务，他们会严重阻塞程序的启动。 优化这些问题的解决方案是做延迟加载，可以在 Application 里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。 恰当地使用闪屏启动闪屏不仅仅可以作为品牌宣传页，还能够减轻用户对启动耗时的感知，但是如果使用不恰当，将适得其反。前面介绍过当点击桌面图标启动 APP 的时候，程序会显示一个启动窗口，一直到页面的渲染加载完毕。如果程序的启动速度足够快，我们看的闪屏窗口停留显示的时间则会很短，但是当程序启动速度偏慢的时候，这个启动闪屏可以一定程度上减轻用户等待的焦虑感，避免用户过于轻易的关闭应用。 目前大多数开发者都会通过设置启动窗口主题的方式来替换系统默认的启动窗口，通过这种方式只是使用『障眼法』弱化了用户对启动时间的感知，但本质上并没有对启动速度做什么优化。也有些 APP 通过关闭启动窗口属性 android:windowDisablePreview 的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，这样的用户体验是十分糟糕的！ 对于启动闪屏，正确的使用方法是自定义一张图片，把这张图片通过设置主题的方式显示为启动闪屏，代码执行到主页面的 onCreate() 的时候设置为程序正常的主题。 前言内存泄漏从来都是我们老生常谈的话题，无论是 Android Studio 自带的内存泄漏分析工具还是专业的 Eclipse MAT 抑或是备受青睐的第三方插件 LeakCanary，都为我们的内存泄漏检测提供了便利。如果从根源上解决内存泄漏，内存优化必不可少。所以本章节我们参考扔物线胡凯的内存优化策略，直接拿出一章节来谈内存优化。 内存优化基本可以分为下面几个方面 减少对象的内存占用 对内存对象进行复用 避免对象的内存泄漏 内存使用策略优化 减少对象的内存占用避免在 Android 里面使用 EnumEnum 是 Java 中包含固定常量的数据类型，当需要知道预先定制的几个值，这几个值表示一些数据类，我们都可以使用 Enum。我们一般用 Enum 做一些编译时检查，以避免传入不合法的参数。 但 Enum 的每个对象都是 Object，在 Android 官网上就早已明确指出应该在 Android 开发中避免使用 Enum，因为与静态常量想必，它对内存的占用是要大很多的。 因此在实际开发中，我更加倾向于接口变量，因为接口会自动把成员变量设置为 static 和 final 的，这一点可以防止某些情况下错误地添加新的常量，这也使得代码看起来更加简单和清晰。 使用更加轻量的数据结构前面第一节已经说过，我们应该更加倾向于考虑使用 ArrayMap 和 SparseArray 而不是 HashMap 等传统数据结果，前面已经用图示演示了 HashMap 的简要工作原理，相比起 Android 系统专门为移动操作系统编写的 ArrayMap 容器，在大多数情况下，都显示效率低下，更占内存。通常的 HashMap 的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录 Mapping 操作。另外，SparseArray 更加高效在于他们避免了对 key 和 value 的 autobox 自动装箱，并且避免了装箱后的解箱。 使用更小的图片在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的 InflationException。假设有一张很大的图片被 XML 文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生 InflationException，这个问题的根本原因其实是发生了 OOM。 减少 Bitmap 对象的内存占用Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施： inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。 decode format：解码格式，选择 ARGB_8888 / RBG_565 / ARGB_4444 / ALPHA_8，存在很大差异。 尽量地采用 int 类型Android 系统中 float 类型的数据存取速度是 int 类型的一半，尽量优先采用 int 类型。而同样能作为整数的代名词，采用 int 替换 Integer 会让你的内存开销更小。 对内存对象进行复用复用系统自带的资源Android 系统本身内置了很多的资源，例如字符串 / 颜色 / 图片 / 动画 / 样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小 APK 的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意 Android 系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。 注意 ListView / GridView 的 Adapter 对 ConvertView 进行复用这个貌似没啥好说的，太基础了，而且我们可能现在更加青睐于 RecyclerView。 尽量的采用 StringBuilder这个也特别基础，我们点到为止。大概就是尽量的采用 StringBuilder / StringBuffer 来替换我们频繁的字符串拼接。 尽量使用原字符串的 subString当从已经存在的数据集中抽取出 String 的时候，尝试返回原数据的 subString 对象，而不要创建一个重复的对象。 避免在 onDraw() 里面执行对象的创建类似 onDraw() 等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的 gc，甚至是内存抖动。 避免对象的内存泄漏内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现 OOM。显然，这还使得每级 Generation 的内存区域可用空间变小，gc 就会更容易被触发，容易出现内存抖动，从而引起性能问题。 注意 Activity 的泄漏通常来说，Activity 的泄漏是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的 Activity 泄漏： 内部类引用导致 Activity 的泄漏最典型的场景是 Handler 导致的 Activity 泄漏，如果 Handler 中有延迟的任务或者是等待执行的任务队列过长，都有可能因为 Handler 继续执行而导致 Activity 发生泄漏。此时的引用关系链是 Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity。为了解决这个问题，可以在 UI 退出之前，执行 remove Handler 消息队列中的消息与 runnable 对象。或者是使用 Static + WeakReference 的方式来达到断开 Handler 与 Activity 之间存在引用关系的目的。 Activity Context 被传递到其他实例中，这可能导致自身被引用而发生泄漏。内部类引起的泄漏不仅仅会发生在 Activity 上，其他任何内部类出现的地方，都需要特别留意！我们可以考虑尽量使用 static 类型的内部类，同时使用 WeakReference 的机制来避免因为互相引用而出现的泄露。 尽量地采用 Application Context对于大部分非必须使用 Activity Context 的情况（Dialog 的 Context 就必须是Activity Context），我们都可以考虑使用 Application Context 而不是 Activity 的 Context，这样可以避免不经意的 Activity 泄露。 而且如果习惯 Glide 的童鞋可能会发现，Glide 需要传递的 Context 如果是 Activity 的 Context ，那么在 Activity 被销毁后还没加载出来的话还会引发崩溃。所以，请在使用 Glide 或者 Toast 等的时候，直接传递 Application Context 吧。 注意 Cursor 对象是否及时关闭在程序中我们经常会进行查询数据库的操作，但时常会存在不小心使用 Cursor 之后没有及时关闭的情况。这些 Cursor 的泄露，反复多次出现的话会对内存管理产生很大的负面影响，我们需要谨记对 Cursor 对象的及时关闭。 注意 WebView 的泄漏Android中 的 WebView 存在很大的兼容性问题，不仅仅是 Android 系统版本的不同对 WebView 产生很大的差异，另外不同的厂商出货的 ROM 里面 WebView 也存在着很大的差异。更严重的是标准的 WebView 存在内存泄露的问题，看这里。所以通常根治这个问题的办法是为 WebView 开启另外一个进程，通过 AIDL 与主进程进行通信，WebView 所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。 注意临时 Bitmap 对象的及时回收虽然在大多数情况下，我们会对 Bitmap 增加缓存机制，但是在某些时候，部分 Bitmap 是需要及时回收的。例如临时创建的某个相对比较大的 Bitmap 对象，在经过变换得到新的 Bitmap 对象之后，应该尽快回收原始的 Bitmap，这样能够更快释放原始 Bitmap 所占用的空间。 需要特别留意的是 Bitmap 类里面提供的 createBitmap() 方法： 这个函数返回的 Bitmap 有可能和 source bitmap 是同一个，在回收的时候，需要特别检查 source bitmap 与 return bitmap 的引用是否相同，只有在不等的情况下，才能够执行 source bitmap 的 recycle() 方法。 注意监听器的注销在 Android 程序里面存在很多需要 register 与 unregister 的监听器，我们需要确保在合适的时候及时 unregister 那些监听器。自己手动 add 的 listener，需要记得及时 remove 这个 listener。 内存使用策略优化谨慎使用 large heapAndroid 设备根据硬件与软件的设置差异而存在不同大小的内存空间，他们为应用程序设置了不同大小的 Heap 限制阈值。你可以通过调用 getMemoryClass() 来获取应用的可用 Heap 大小。在一些特殊的情景下，你可以通过在 manifest 的 application 标签下添加 largeHeap = true 的属性来为应用声明一个更大的 heap 空间。然后，你可以通过 getLargeMemoryClass() 来获取到这个更大的 heap size 阈值。然而，声明得到更大 Heap 阈值的本意是为了一小部分会消耗大量 RAM 的应用 ( 例如一个大图片的编辑应用 ) 。不要轻易的因为你需要使用更多的内存而去请求一个大的 Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用 large heap。因此请谨慎使用 large heap 属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次 gc 的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap 并不一定能够获取到更大的 heap。在某些有严格限制的机器上，large heap 的大小和通常的 heap size 是一样的。因此即使你申请了 large heap，你还是应该通过执行 getMemoryClass() 来检查实际获取到的 heap 大小。 资源文件需要选择合适的文件夹进行存放我们知道 hdpi / xhdpi / xxhdpi 等等不同 dpi 的文件夹下的图片在不同的设备上会经过 scale 的处理。例如我们只在 hdpi 的目录下放置了一张 100 x 100 的图片，那么根据换算关系，xxhdpi 的手机去引用那张图片就会被拉伸到 200 x 200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到 assets 或者 nodpi 的目录下。 Try catch某些大内存分配的操作在某些情况下，我们需要事先评估那些可能发生 OOM 的代码，对于这些可能发生 OOM 的代码，加入 catch 机制，可以考虑在 catch 里面尝试一次降级的内存分配操作。例如 decode bitmap 的时候，catch 到 OOM，可以尝试把采样比例再增加一倍之后，再次尝试 decode。 谨慎使用 static 对象因为 static 的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在 Android 中应该谨慎使用 static 对象。 特别留意单例对象中不合理的持有虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。特别是持有 Context 的引用，需要谨慎对待。 优化布局层次，减少内存消耗越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的 View 无法实现足够扁平的时候考虑使用自定义 View 来达到目的。 谨慎使用多进程使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。 一个典型的例子是创建一个可以长时间后台播放的 Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些 UI 资源也没有办法得到释放。类似这样的应用可以切分成 2 个进程：一个用来操作 UI，另外一个给后台的 Service。 写在最后内存优化并不就是说程序占用的内存越少就越好，如果因为想要保持更低的内存占用，而频繁触发执行 gc 操作，在某种程度上反而会导致应用性能整体有所下降，这里需要综合考虑做一定的权衡。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-自定义View播放Gif动画]]></title>
      <url>%2F2017%2F11%2F02%2Fandroid-view-gif%2F</url>
      <content type="text"><![CDATA[前言GIF是一种很常见的动态图片格式，在Android中它的使用场景非常多，大到启动页动画、小到一个Loading展示，都可以用GIF动画来完成，使用也很方便，直接从美工那边拿过来用就成。如果项目赶时间或者自定义原生动画太麻烦，GIF都是一个很好的选择，相比于最新的WEBP格式的动画，也有更好的兼容性（毕竟已经出现很多年了）。关于图片加载我一直用的是Google推荐的Glide，图片加载和缓存都做的很好，同样也支持GIF动画。不过Glide默认就是循环播放Gif，没有开放相关的接口来控制Gif。这就使的我们不能很好地控制Gif的播放，比如控制播放开始时间、播放次数，播放暂停、播放开始、结束事件的监听，虽然用Glide可能做到（网上说可以，但我没找到方法），但操作也会很麻烦。 分析除了第三方的库，Android自带的类android.graphics.Movie也可以用来加载播放Gif动画，而且实现起来很简单。按数据来源分别可以从Gif文件的输入流，文件路径，字节数组中得到Movie的实列。然后我们可以通过操作Movie对象来操作Gif文件。 Movie decodeStream(InputStream is) Movie decodeFile(String pathName) Movie decodeByteArray(byte[] data, int offset,int length) 下面介绍下几个movie的重要方法： int width() movie的宽，值等于gif图片的宽，单位：px。int height() movie的高，值等于gif图片的高，单位：px。int duration() movie播放一次的时长，也就是gif播放一次的时长，单位：毫秒。boolean isOpaque() Gif图片是否带透明 boolean setTime(int relativeMilliseconds) 设置movie当前处在什么时间，然后找到对应时间的图片帧，范围0 ~ duration。返回是否成功找到那一帧。draw(Canvas canvas, float , float y)draw(Canvas canvas, float x, float y, Paint paint)在Canves中画出当前帧对应的图像。x，y对应Movie左上角在Canves中的坐标。以上就是Movie平常会用到大部分方法，下面就利用这些自定义VIew实现播放Gif动画。 实现首先定义一些需要的属性，用于在布局文件中设置gif 12345678&lt;declare-styleable name=&quot;GIFVIEW&quot;&gt; &lt;!--gif文件引用--&gt; &lt;attr name=&quot;gifSrc&quot; format=&quot;reference&quot; /&gt; &lt;!--是否加载完自动播放--&gt; &lt;attr name=&quot;authPlay&quot; format=&quot;boolean&quot; /&gt; &lt;!--播放次放，默认永远播放--&gt; &lt;attr name=&quot;playCount&quot; format=&quot;integer&quot; /&gt; &lt;/declare-styleable&gt; 然后定义Gif的播放监听器,来监听各个时段的事件，命名的含义都很简单就不再介绍了： 1234567891011public interface OnPlayListener &#123; void onPlayStart(); void onPlaying(int percent); void onPlayPause(boolean pauseSuccess); void onPlayRestart(); void onPlayEnd(); &#125; 声明类，直接继承ImageView，这样我们不仅可以显示Gif动画，也可以显示普通图片：public class GifImageView extends AppCompatImageView然后加载Gif图片资源 1234567891011121314public void setGifResource(int movieResourceId, OnPlayListener onPlayListener) &#123; mOnPlayListener = onPlayListener; movie = Movie.decodeStream(getResources().openRawResource(movieResourceId)); if (movie == null) &#123; //如果movie为空，那么就不是gif文件，尝试转换为bitmap显示 Bitmap bitmap = BitmapFactory.decodeResource(getResources(), movieResourceId); if (bitmap != null) &#123; setImageBitmap(bitmap); return; &#125; &#125; movieDuration = movie.duration() == 0 ? DEFAULT_DURATION : movie.duration(); requestLayout(); &#125; 调用requestLayout重新计算View大小，并重新绘制。如果是gif格式则View宽高等于movie的宽高，不是则调用父类的测量方法。 12345678910@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (movie != null) &#123; int movieWidth = movie.width(); int movieHeight = movie.height(); setMeasuredDimension(movieWidth, movieHeight); &#125; else &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; &#125; 开始播放，其实就是调用invalidate从而调用onDraw方法就行UI绘制： 12345678public void play(int counts) &#123; this.counts = counts; reset(); if (mOnPlayListener != null) &#123; mOnPlayListener.onPlayStart(); &#125; invalidate();&#125; 不断调用onDraw方法来绘制Gif当前时间的图片帧（同样需要判断是否是gif格式，不是则调用父类的绘制方法）： 1234567891011121314151617181920@Override protected void onDraw(Canvas canvas) &#123; if (movie != null) &#123; if (!mPaused &amp;&amp; hasStart) &#123; drawMovieFrame(canvas); invalidateView(); &#125; else &#123; drawMovieFrame(canvas); &#125; &#125; else &#123; super.onDraw(canvas); &#125; &#125; /** * 画出gif帧 */ private void drawMovieFrame(Canvas canvas) &#123; movie.setTime(getCurrentFrameTime()); movie.draw(canvas, 0.0f, 0.0f); &#125; 最核心的方法就是计算当前时间需要绘制处于movie中的对应时间的图片帧。 12345678910111213141516171819private int getCurrentFrameTime() &#123; if (movieDuration == 0) return 0; //因为有暂停，所以需要减去暂停时间 long now = SystemClock.uptimeMillis() - dealyTime; int nowCount = (int) ((now - mMovieStart) / movieDuration); if (counts != -1 &amp;&amp; nowCount &gt;= counts) &#123; hasStart = false; if (mOnPlayListener != null) &#123; mOnPlayListener.onPlayEnd(); &#125; &#125; int currentTime = (int) ((now - mMovieStart) % movieDuration); int percent = currentTime * 100 / movieDuration; if (mOnPlayListener != null &amp;&amp; hasStart) &#123; mOnPlayListener.onPlaying(percent); &#125; return currentTime; &#125; 暂停Gif播放： 1234567891011121314public void pause() &#123; if (movie != null &amp;&amp; !mPaused &amp;&amp; hasStart) &#123; mPaused = true; invalidate(); mMoviePauseTime = SystemClock.uptimeMillis(); if (mOnPlayListener != null) &#123; mOnPlayListener.onPlayPause(true); &#125; &#125; else &#123; if (mOnPlayListener != null) &#123; mOnPlayListener.onPlayPause(false); &#125; &#125; &#125; 继续Gif播放： 12345678if (mPaused &amp;&amp; mMoviePauseTime &gt; 0) &#123; mPaused = false; dealyTime = dealyTime + SystemClock.uptimeMillis() - mMoviePauseTime; invalidate(); if (mOnPlayListener != null) &#123; mOnPlayListener.onPlayRestart(); &#125; &#125; 经过这些处理，我们就能更好地控制Gif的播放流程了。下面简单看下成品图： 进阶倒叙播放相信看了上面GifImageView的实现原理后，倒叙播放的实现也是很容易的。 1234567891011121314public void playReserver() &#123; if (movie != null) &#123; reset(); reverse = true; if (mOnPlayListener != null) &#123; mOnPlayListener.onPlayStart(); &#125; invalidate(); &#125;&#125; if (reverse) &#123; movie.setTime(movieDuration - getCurrentFrameTime()); &#125; else &#123; movie.setTime(getCurrentFrameTime()); &#125; 如下图，狗子的头已经从原来的左边转到右边变成了现在的右边转到左边（ಠᴗಠ）。 像播放视频一样播放Gif动画这部分是我在写完GifView后想到的一点进阶功能，既然我们已经实现了播放和暂停，即能控制在某个时间点播放指定的Gif图片帧，如果再加入进度条，快进等功能，那么不就能做到和视频播放器一样的功能了吗？限于篇幅，我只简单实现了进度条功能，更多功能实现请移步Github，地址：GifView]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-事件分发机制源码攻略]]></title>
      <url>%2F2017%2F11%2F02%2Fandroid-view-event-distribution%2F</url>
      <content type="text"><![CDATA[前言android事件分发算是自定义View不可缺失的一部分，事件分发是指那一类跟屏幕交互的操作等事件，例如滑动，点击，长按这类。这些事件都是由摁下、移动、抬起等基本事件组成的。那事件分发是指当你点击了屏幕，这个事件是如何从Activity传递到真正处理这个事件的View上的过程。例如，我们在做ListView跟ViewPager嵌套的时候，既能左右滑动，又能上下滑动，这些事件是如何避免彼此间的冲突的。下面我会分三节来介绍这一原理。首先，这次的源码分析是基于25.0.3版本进行的。 分发事件分发的事件主要是MotionEvent这个类所表示的点击、移动、抬起、取消等事件MotionEvent.ACTION_DOWNMotionEvent.ACTION_MOVEMotionEvent.ACTION_UPMotionEvent.ACTION_CANCEL… 分发的对象分发的对象是指收到上述事件的类 ActivityViewGroupView 上述三个类是主要的事件分发对象，后期的讨论也是集中在这三个类里面。这里有个点得提一下就是ViewGroup是View的子类。这些事件会在这三者的dispatchTouchEvent、onTouchEvent这两个方法里面传递，还有一个ViewGroup特有的onInterceptTouchEvent方法。下面给出以上提到的类以及方法之间的关系。 从这张图，我们可以看出，不同返回值，事件的分发方向不同，这里不做详细分析，这张图是否画得出来作为你对这次源码阅读的成绩。 DemoActivity 12345678910111213@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.i(TAG,"dispatchTouchEvent"+ev.getAction()); return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.i(TAG,"onTouchEvent"+event.getAction()); return super.onTouchEvent(event);&#125; CusViewGroup 1234567891011121314151617181920212223@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.i(TAG,"dispatchTouchEvent"+ev.getAction()); return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.i(TAG,"onInterceptTouchEvent"+ev.getAction()); return super.onInterceptTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.i(TAG,"onTouchEvent"+event.getAction()); return super.onTouchEvent(event);&#125; View 123456789101112131415@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.i(TAG,"dispatchTouchEvent"+ev.getAction()); return super.dispatchTouchEvent(ev);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Log.i(TAG,"onTouchEvent"+event.getAction()); return super.onTouchEvent(event);&#125; 布局 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.example.coffeetime.cusviewdemo.CusLineaLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.example.coffeetime.cusviewdemo.MainActivity&quot;&gt; &lt;com.example.coffeetime.cusviewdemo.CusView android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:background=&quot;@color/colorPrimary&quot;/&gt;&lt;/com.example.coffeetime.cusviewdemo.CusLineaLayout&gt; 结果 ACTION_DOWN的值为0ACTION_MOVE的值为1 从输出的结果的第一行可以看出来最先获取事件的是Activity这一层，从倒数第三行可以看出，ACTION_DOWN这个事件最终消费是在Activity的onTouchEvent这个方法被消费。这个结果跟上面的图片是一致的。再看看输出结果的倒数两行，ACTION_MOVE事件从dispatchTouchEvent直接就传给了同级的onTouchEvent方法去了，说明ACTION_DOWN事件在哪里被消费了，后续事件也在那里消费，并且跳过中间传递。这个原因会在分析源码的时候给出解释。 Activity从上述的结果，我们可以得出事件最先被拦截的地方是从Activity的dispatchTouchEvent方法开始，那我们的源码攻略也从这里开始。 12345678910111213141516171819/** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 这个方法首先判断事件类型，如果是ACTION_DOWN事件，则先执行onUserInteraction()方法； 12public void onUserInteraction() &#123;&#125; 这个方法没有实现，根据文档注释，当有任意一个按键、触屏或者轨迹球事件发生时，栈顶Activity的onUserInteraction会被触发。如果我们需要知道用户是不是正在和设备交互，可以在子类中重写这个方法，去获取通知（比如取消屏保这个场景）。跟这个方法配对的还有onUserLeaveHint方法，这个方法是在用户离开设备的时候触发的。 我们接着回到刚刚那个地方，判断完事件ACTION_DOWN事件之后，会执行getWindow().superDispatchTouchEvent(ev)这个方法，这个getWindow获取的是哪个Window呢，我们进去看看。 123public Window getWindow() &#123; return mWindow;&#125; 1234567891011/** * Abstract base class for a top-level window look and behavior policy. An * instance of this class should be used as the top-level view added to the * window manager. It provides standard UI policies such as a background, title * area, default key processing, etc. * * &lt;p&gt;The only existing implementation of this abstract class is * android.view.PhoneWindow, which you should instantiate when needing a * Window. */public abstract class Window &#123;&#125; 通过这块注释，我们可以看出，window的实现类是phoneWindow。其实在Android里面很多都是可以通过阅读注释或者是官方文档去找出具体的实现类，不是只能依靠百度；好了，那我们可以直接进到phoneWindow类去看下superDispatchTouchEvent这个方法做了些什么 1234@Override public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event); &#125; 这个方法又是调用mDecor的同名方法去实现，mDecor又是什么 phoneWindow 12// This is the top-level view of the window, containing the window decor. private DecorView mDecor; DecorView 123public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);&#125; DecorView 是window的顶级View，而DecorView是继承FrameLayout的布局，接着去FragmeLayout里面寻找dispatchTouchEvent方法，而FragmeLayout并没有实现这个方法，也即这个是直接交给ViewGroup去处理的。 小结在Activity层事件的传递过程如下图 从Activity的dispatchTouchEvent获取事件经过PhoneWindow、DecorView再到最终的ViewGroup，这一层代码比较简单，没有比较难分析的，只是经过的类比较多，其实只要把握的主线，分析起来还是比较简单的。这一篇比较少，下一篇是ViewGroup的分析，由于ViewGroup的源码比较多，所以才拆开来写，不然太长了。 ViewGroup 如果是ACTION_DOWN事件，就会去寻找子View来处理，如果找不到子View来处理，就自己处理。如果不是ACTION_DOWN事件，就会把这个事件传给处理了ACTION_DOWN事件的View来处理。 大致就这两个逻辑，虽说比较粗略，不过，这对于接下来看源码就足够了，并且源码有比较多的注释，基本上大致的方向是可以弄懂了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; ... //返回值的关键，注意留意handled的值发生改变的地方 boolean handled = false; //判断当前window是否有被遮挡，true为分发这个事件，false为丢弃这个事件 if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous // due to an app switch, ANR, or some other state change.//在新的事件开始（即是新的ACTION_DOWN事件），需要清除掉之前的状态以及设置mFirstTouchTarget=null; cancelAndClearTouchTargets(ev); resetTouchState(); &#125; // Check for interception. final boolean intercepted; //子View唯一一个可以用来控制父类事件传递 //只有ACTION_DOWN事件跟mFirstTouchTarget不为空的情况，后面的讨论大多是围绕着mFirstTouchTarget来进行的 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //是否拦截事件，disallowIntercept为true是不拦截，false是拦截 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; //一般重写onInterceptTouchEvent方法 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) &#123; ev.setTargetAccessibilityFocus(false); &#125; // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. //split是否分发给多个子View，默认为false final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //如果不被拦截即可进入或者不是ACTION_CANCEL事件 if (!canceled &amp;&amp; !intercepted) &#123; // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; //只有ACTION_DOWN等事件能够进入 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. //获取按Z轴从大到小排序的子View列表 final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList(); //是否有自定义顺序，一般为false final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; //确认这个子View的下标 final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); //根据上面获得的下标，确认这个子View final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. // 如果当前视图无法获取用户焦点，则跳过本次循环 if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //是否获得可见，并且落在child的布局范围内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //Child是否已经处理过事件了，有的话更改pointerIdBits值，并结束查找 newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); //分发给View的dispatchTouchEvent if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //给mFirstTouchTarget赋值，该事件已经被子View确认处理了 newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125; // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); &#125; if (preorderedList != null) preorderedList.clear(); &#125; if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123; // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) &#123; newTouchTarget = newTouchTarget.next; &#125; newTouchTarget.pointerIdBits |= idBitsToAssign; &#125; &#125; &#125; // Dispatch to touch targets. // 没有子View处理，则自己处理 if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. //处理除了ACTION_DOWN以外的事件 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; //如果这个事件被拦截了，intercepted为true if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; //如果事件被拦截掉， if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; resetTouchState(); &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123; final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); &#125; &#125; if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); &#125; return handled; &#125; 像这么长的代码，很多地方是可以跳过的，不过仔仔细细分析，特别是像Google出品的（个人愚见），因为这些东西考虑的方方面面比较多，而我们这个只是为了了解事件的分发，绘制那块我们不会过多涉及。（说跑题了）回到正题来，像这么长的代码，之前学习的时候，有个牛人是这么写的（个人总结）。 从结果出发，留意改变的结果的地方 上面的dispatchTouchEvent返回值是由handle决定，我们先来看第一处第8行代码 123456789101112131415boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; ... &#125; return false; 这个onFilterTouchEventForSecurity方法如果返回false的话，基本上里面的代码都不用分析了，直接返回false。那我们进去看看这个方法做了什么。 1234567891011121314151617/** * Filter the touch event to apply security policies. * * @param event The motion event to be filtered. * @return True if the event should be dispatched, false if the event should be dropped. * * @see #getFilterTouchesWhenObscured */public boolean onFilterTouchEventForSecurity(MotionEvent event) &#123; //noinspection RedundantIfStatement if ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) &#123; // Window is obscured, drop this touch. return false; &#125; return true;&#125; 这是一个安全策略方面的过滤，我们来看下这两个变量FILTER_TOUCHES_WHEN_OBSCURED、MotionEvent.FLAG_WINDOW_IS_OBSCURED是什么意思 123456/** * Indicates that the view should filter touches when its window is obscured. * Refer to the class comments for more information about this security feature. * &#123;@hide&#125; */static final int FILTER_TOUCHES_WHEN_OBSCURED = 0x00000400; 1234567891011/** * This flag indicates that the window that received this motion event is partly * or wholly obscured by another visible window above it. This flag is set to true * even if the event did not directly pass through the obscured area. * A security sensitive application can check this flag to identify situations in which * a malicious application may have covered up part of its content for the purpose * of misleading the user or hijacking touches. An appropriate response might be * to drop the suspect touches or to take additional precautions to confirm the user&apos;s * actual intent. */public static final int FLAG_WINDOW_IS_OBSCURED = 0x1; 从上面的代码注释可以看出来，这个View不能被其他的window遮挡住，这是谷歌的一个安全策略，避免被恶意程序误导用户或劫持触摸。第二处handle的改变是在172行 123456789101112131415161718if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123;...while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; ... 很明显handled的值又跟mFirstTouchTarget、alreadyDispatchedToNewTouchTarget这两个值有关，另外还跟dispatchTransformedTouchEvent（）这个方法有关，dispatchTransformedTouchEvent（）方法，我们留在后面分析，我们先来看看这两个值是在什么时候在哪里被改变的。 12345mLastTouchDownX = ev.getX();mLastTouchDownY = ev.getY();//给mFirstTouchTarget赋值，该事件已经被子View确认处理了newTouchTarget = addTouchTarget(child, idBitsToAssign);alreadyDispatchedToNewTouchTarget = true; 这个是第145行的代码，这里是找到处理事件的子View后，做的赋值，addTouchTarget这个方法里面会对mFirstTouchTarget赋值。 好了，如果是这样，我们再从上面的第13行开始分析。 123456789 // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous // due to an app switch, ANR, or some other state change.//在新的事件开始（即是新的ACTION_DOWN事件），需要清除掉之前的状态以及设置mFirstTouchTarget=null; cancelAndClearTouchTargets(ev); resetTouchState(); &#125; 这里先对该事件进行判断，如果是ACTION_DOWN事件会进到这个方法里面，做一些处理。我们来看下这两个方法都做了哪些。 12345678910111213141516171819202122232425262728/** * Cancels and clears all touch targets. */private void cancelAndClearTouchTargets(MotionEvent event) &#123; if (mFirstTouchTarget != null) &#123; boolean syntheticEvent = false; //假如event为null,重新实例一个取消（MotionEvent）的事件 if (event == null) &#123; final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; &#125; for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123; resetCancelNextUpFlag(target.child); //分发事件 dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); &#125; //重置mFirstTouchTarget clearTouchTargets(); if (syntheticEvent) &#123; event.recycle(); &#125; &#125;&#125; 从这个方法的名字可以看出来，这个方法做了两件事取消跟清除TouchTarget，首先是取消，这里的取消是指分发ACTION_CANCEL事件，在我上面注释代码的第18行，dispatchTransformedTouchEvent（）这个方法的第二个参数为true，这个值会在更改事件为ACTION_CANCEL，并分发给上次处理事件的View。这个分发事件的方法，我们留在后面分析，现在继续分析清除。 1234567891011121314/** * Clears all touch targets. */private void clearTouchTargets() &#123; TouchTarget target = mFirstTouchTarget; if (target != null) &#123; do &#123; TouchTarget next = target.next; target.recycle(); target = next; &#125; while (target != null); mFirstTouchTarget = null; &#125;&#125; 这个方法很简单了，就对TouchTarget的next是回收，最后再把mFirstTouchTarget置null。好了，这两个方法分析完，我们再回到刚刚的那个地方，看到还有一个方法resetTouchState（） 123456789/** * Resets all touch state in preparation for a new cycle. */private void resetTouchState() &#123; clearTouchTargets(); resetCancelNextUpFlag(this); mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; mNestedScrollAxes = SCROLL_AXIS_NONE;&#125; 这个方法除了clearTouchTargets（）、resetCancelNextUpFlag()这两个方法外，还对 mGroupFlags 这个标志做一个拦截方面的修改，这个标志可以让子View请求父布局不要去拦截某个事件（ACTION_DOWN除外），并且可通过getParent().requestDisallowInterceptTouchEvent()去修改这个值。 1234567891011121314151617181920// Check for interception. final boolean intercepted; //子View唯一一个可以用来控制父类事件传递 //只有ACTION_DOWN事件跟mFirstTouchTarget不为空的情况，后面的讨论大多是围绕着mFirstTouchTarget来进行的 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //是否拦截事件，disallowIntercept为true是不拦截，false是拦截 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; //一般重写onInterceptTouchEvent方法 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; 这里有个判断，只有ACTION_DOWN以及mFirstTouchTarget不为的空的情况下，才允许进入。我们来先说下，什么时候mFirstTouchTarget会不为空，我这边先简单说下，后面代码会提及；mFirstTouchTarget是在这个事件被所在的子View消费了，这个值才不会空，即使是本身ViewGroup消费了，这个值也是为空。按照这个思路的话，大家估计也不难理解我上面说的子View可以请求父布局对ACTION_DOWN以外的事件不做拦截，另外还有一点就是，一般重写只针对onInterceptTouchEvent这个方法，而dispatchTouchEvent这个方法倒是很少重写。像我们经常遇到的ViewPager跟ScrollView这个横竖滑动冲突的问题，你们去看这两个控件源码，就可以看到都是重写了onInterceptTouchEvent这个方法。 我们回到我上面提供的源码注解中，执行上述判断后，如果canceled跟intercepted都为false的话，并且这个事件为ACTION_DOWN事件，接下来将寻找满足消费条件的子View。我们来看下，是按照什么顺序来寻找View的。 按照我上面提供源码走下来，在87行处有着下面这个方法，这个方法主要是将子View按照Z轴的大小排序。 123456789101112131415161718192021222324252627282930ArrayList&lt;View&gt; buildOrderedChildList() &#123; final int childrenCount = mChildrenCount; if (childrenCount &lt;= 1 || !hasChildWithZ()) return null; if (mPreSortedChildren == null) &#123; mPreSortedChildren = new ArrayList&lt;&gt;(childrenCount); &#125; else &#123; // callers should clear, so clear shouldn&apos;t be necessary, but for safety... mPreSortedChildren.clear(); mPreSortedChildren.ensureCapacity(childrenCount); &#125; //自定义View排序 final boolean customOrder = isChildrenDrawingOrderEnabled(); for (int i = 0; i &lt; childrenCount; i++) &#123; // add next child (in child order) to end of list final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View nextChild = mChildren[childIndex]; final float currentZ = nextChild.getZ(); // insert ahead of any Views with greater Z int insertIndex = i; //有点类似于插入排序，按Z轴从小到大排序 while (insertIndex &gt; 0 &amp;&amp; mPreSortedChildren.get(insertIndex - 1).getZ() &gt; currentZ) &#123; insertIndex--; &#125; mPreSortedChildren.add(insertIndex, nextChild); &#125; return mPreSortedChildren; &#125; 其中getAndVerifyPreorderedIndex只是对View的下标进行再次确定。这里面提到一个自定义排序的问题，正常情况的布局排序是根据xml的顺序或者addView的顺序决定的。当然google也提供了setChildrenDrawingOrderEnabled（），getChildDrawingOrder（）这两个方法进行自定义排序，有需求的可以去自行了解下，我们就不深入探讨了。 1234567if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1;&#125; 现在是取到了所有的子View，那么接下来就是筛选哪些View可以处理了。首先是先获取到哪个是获取焦点的View，并且这个View是否在这些子View里面。如果找到了就走到下一步。 123456//判断这个View是否具备处理的条件if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue;&#125; 我们来看看第一个判断方法 12345678/** * Returns true if a child view can receive pointer events. * @hide */ private static boolean canViewReceivePointerEvents(@NonNull View child) &#123; return (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null; &#125; 第二个方法 123456789101112131415161718/** * Returns true if a child view contains the specified point when transformed * into its coordinate space. * Child must not be null. * @hide */protected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) &#123; final float[] point = getTempPoint(); point[0] = x; point[1] = y; transformPointToViewLocal(point, child); final boolean isInView = child.pointInView(point[0], point[1]); if (isInView &amp;&amp; outLocalPoint != null) &#123; outLocalPoint.set(point[0], point[1]); &#125; return isInView;&#125; 可见或者是正在执行动画的，并且位置是落在这个View的范围的。满足这些条件外，再判断这个View是否已经是在mFirstTouchTarget的子View里面了，如果是的话，也是结束循环了。 1234567newTouchTarget = getTouchTarget(child);if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break;&#125; 以上条件都满足的话，我们就进行分发事件的方法，我们来看下这个方法做了什么操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) &#123; return false; &#125; // If the number of pointers is the same and we don't need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) &#123; if (child == null || child.hasIdentityMatrix()) &#123; if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); &#125; return handled; &#125; transformedEvent = MotionEvent.obtain(event); &#125; else &#123; transformedEvent = event.split(newPointerIdBits); &#125; // Perform any necessary transformations and dispatch. if (child == null) &#123; handled = super.dispatchTouchEvent(transformedEvent); &#125; else &#123; final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) &#123; transformedEvent.transform(child.getInverseMatrix()); &#125; handled = child.dispatchTouchEvent(transformedEvent); &#125; // Done. transformedEvent.recycle(); return handled; &#125; 这个方法一看就有点长了，慌不慌~其实这个方法就做了两件事，第一件事，就是如果cancel为true的话，更改这个事件为ACTION_CANCEL；第二件事，就是child为null的话，调用super.dispatchTouchEvent(event);child不为空的话，就调用super.dispatchTouchEvent(event);好吧，其实这个方法，只需要看上面那部分就差不多了。 123456789101112...if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125;... 精简版的分发~~~ 如果dispatchTransformedTouchEvent方法返回true的话，就代表了这个事件已经被子View消费了，接下来关键的方法就是调用addTouchTarget（）这个方法，给mFirstTouchTarget赋值。 12345678910/** * Adds a touch target for specified child to the beginning of the list. * Assumes the target child is not already present. */ private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; &#125; 如果dispatchTransformedTouchEvent方法返回false的话，那么就代表这个事件没有View消费，那就是只能自己消费了 12345if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, ouchTarget.ALL_POINTER_IDS);&#125; 其实到这里，整个ACTION_DOWN事件的传递就结束了。我们来做了小结，当有触摸事件传递过来时 先对当前设备状态进行判断，是否没被遮挡 紧接着如果是ACTION_DOWN事件的话，就清除状态 如果onInterceptTouchEvent返回true，则事件交给自己处理 如果是ACTION_DOWN事件的话，先去寻找获得焦点的View，如果找到了，就分发给View去处理；如果找不到就交给自己处理。 接着我们再来说下除了ACTION_DOWN以外的事件传递情况，从上面的demo我们可以得知，消费了ACTION_DOWN事件，后续的事件也将给这个View消费。也即是mFirstTouchTarget != null的情况。 12345678910111213141516171819202122232425262728293031323334// Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. //处理除了ACTION_DOWN以外的事件 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; //alreadyDispatchedToNewTouchTarget为true的话，说明已经被消费了 if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123; handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; //如果这个事件被拦截了，intercepted为true if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; //如果事件被拦截掉， if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; 上面代码的第9行，这一块的的判断我们可以回溯到之前的mFirstTouchTarget赋值，也即是addTouchTarget()这个方法。可以发现，上述的判断如果为true，说明这个事件已经被消费了，所以handled就为true了。 上面代码的第12行，如果intercepted为true的话，那cancelChild也就为true了。而dispatchTransformedTouchEvent（）上面已经分析过，cancelChild为true，会向之前消费事件的View发送ACTION_CANCEL事件。后面再把mFirstTouchTarget置成next，也即是null，那么接下来的事件将被本身给消费掉。这也验证了我们上面的demo。当然，大家也可以多做几个例子好好理解理解。 下面是整个dispatchTouchEvent()里面关键方法的调用流程，可以方便理解。 好了，整个ViewGroup层dispatchTouchEvent传递到View层的dispatchTouchEvent或者传递给super.dispatchTouchEvent(event)，下一节将对View层的源码进行解析。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-自定义曲线路径动画框架]]></title>
      <url>%2F2017%2F11%2F02%2Fandroid-bight-path%2F</url>
      <content type="text"><![CDATA[前言最近在一个项目中需要一个像QQ打开个人爱好那样的动画效果如下图: 可以看出每个小球都是以顺时针旋转出来的,说明像这样的曲线动画用Android中自带的平移动画是很难实现的。 曲线动画怎么画??? 我们先来看看Android自带的绘制曲线的方式是怎样的: android自定义View中画图经常用到这几个什么什么To moveTomoveTo 不会进行绘制，只用于移动移动画笔,也就是确定绘制的起始坐标点。结合以下方法进行使用。 lineTolineTo 用于进行直线绘制。 12mPath.lineTo(300, 300);canvas.drawPath(mPath, mPaint); 默认从坐标(0,0)开始绘制。 刚才我们不是说了moveTo是用来移动画笔的吗？ 123mPath.moveTo(100, 100);mPath.lineTo(300, 300);canvas.drawPath(mPath, mPaint); 把画笔移动(100,100)处开始绘制 quadToquadTo 用于绘制圆滑曲线，即贝塞尔曲线。 cubicTocubicTo 同样是用来实现贝塞尔曲线的。mPath.cubicTo(x1, y1, x2, y2, x3, y3) (x1,y1) 为控制点，(x2,y2)为控制点，(x3,y3) 为结束点。那么，cubicTo 和 quadTo 有什么不一样呢？说白了，就是多了一个控制点而已。然后，我们想绘制和上一个一样的曲线，应该怎么写呢？ 12mPath.moveTo(100, 500);mPath.cubicTo(100, 500, 300, 100, 600, 500); 一模一样！如果我们不加 moveTo 呢？ 则以(0,0)为起点，(100,500)和(300,100)为控制点绘制贝塞尔曲线 受到上面的启发,我们也可以用同样的方法来实现一个曲线动画框架 在写框架之前我们必须要先了解一样东西: 贝塞尔曲线:维基百科中这样说到: 在数学的数值分析领域中，贝塞尔曲线（英语：Bézier curve）是计算机图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。 贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。 线性贝塞尔曲线给定点P0、P1，线性贝塞尔曲线只是一条两点之间的直线。这条线由下式给出： B(t) = P0 + (P1 - P0)t = (1 - t)P0 + tP1,t-&gt;[0,1] 二次方贝塞尔曲线二次方贝塞尔曲线的路径由给定点P0、P1、P2的函数B（t）追踪： 三次方贝塞尔曲线P0、P1、P2、P3四个点在平面或在三维空间中定义了三次方贝塞尔曲线。曲线起始于P0走向P1，并从P2的方向来到P3。一般不会经过P1或P2；这两个点只是在那里提供方向资讯。P0和P1之间的间距，决定了曲线在转而趋进P2之前，走向P1方向的“长度有多长”。 曲线的参数形式为： 以上都是维基百科给出的定义,以及不同曲线的公式和效果图; 如果不清楚可以自己百度搜索或者维基百科搜索,么么哒! 一般贝塞尔曲线方程 对于四次曲线，可由线性贝塞尔曲线描述的中介点Q0、Q1、Q2、Q3，由二次贝塞尔曲线描述的点R0、R1、R2，和由三次贝塞尔曲线描述的点S0、S1所建构： 那么在上代码之前先看看我们最后实现出来的效果图: PathPoint.java中的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * Created by zhengliang on 2016/10/15 0015. * 记录view移动动作的坐标点 */public class PathPoint &#123; /** * 起始点操作 */ public static final int MOVE=0; /** * 直线路径操作 */ public static final int LINE=1; /** * 二阶贝塞尔曲线操作 */ public static final int SECOND_CURVE =2; /** * 三阶贝塞尔曲线操作 */ public static final int THIRD_CURVE=3; /** * View移动到的最终位置 */ public float mX,mY; /** * 控制点 */ public float mContorl0X,mContorl0Y; public float mContorl1X,mContorl1Y; //操作符 public int mOperation; /** * Line/Move都通过该构造函数来创建 */ public PathPoint(int mOperation,float mX, float mY ) &#123; this.mX = mX; this.mY = mY; this.mOperation = mOperation; &#125; /** * 二阶贝塞尔曲线 * @param mX * @param mY * @param mContorl0X * @param mContorl0Y */ public PathPoint(float mContorl0X, float mContorl0Y,float mX, float mY) &#123; this.mX = mX; this.mY = mY; this.mContorl0X = mContorl0X; this.mContorl0Y = mContorl0Y; this.mOperation = SECOND_CURVE; &#125; /** * 三阶贝塞尔曲线 * @param mContorl0x * @param mContorl0Y * @param mContorl1x * @param mContorl1Y * @param mX * @param mY */ public PathPoint(float mContorl0x, float mContorl0Y, float mContorl1x, float mContorl1Y,float mX, float mY) &#123; this.mX = mX; this.mY = mY; this.mContorl0X = mContorl0x; this.mContorl0Y = mContorl0Y; this.mContorl1X = mContorl1x; this.mContorl1Y = mContorl1Y; this.mOperation = THIRD_CURVE; &#125; /** * 为了方便使用都用静态的方法来返回路径点 */ public static PathPoint moveTo(float x, float y)&#123; return new PathPoint(MOVE,x,y); &#125; public static PathPoint lineTo(float x,float y)&#123; return new PathPoint(LINE,x,y); &#125; public static PathPoint secondBesselCurveTo(float c0X, float c0Y,float x,float y)&#123; return new PathPoint(c0X,c0Y,x,y); &#125; public static PathPoint thirdBesselCurveTo(float c0X, float c0Y, float c1X, float c1Y, float x, float y)&#123; return new PathPoint(c0X,c0Y,c1X,c1Y,x,y); &#125;&#125; 这个类主要是用来记录View移动动作的坐标点,通过不同的构造函数传入不同的参数来区分不同的移动轨迹,注释写的很清楚的… 为了让不同类型的移动方式都能在使用时一次性使用我写了一个AnimatorPath类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.ArrayList;import java.util.Collection;import java.util.List;/** * Created by zhengliang on 2016/10/15 0015. * 客户端使用类,记录一系列的不同移动轨迹 */public class AnimatorPath &#123; //一系列的轨迹记录动作 private List&lt;PathPoint&gt; mPoints = new ArrayList&lt;&gt;(); /** * 移动位置到: * @param x * @param y */ public void moveTo(float x,float y)&#123; mPoints.add(PathPoint.moveTo(x,y)); &#125; /** * 直线移动 * @param x * @param y */ public void lineTo(float x,float y)&#123; mPoints.add(PathPoint.lineTo(x,y)); &#125; /** * 二阶贝塞尔曲线移动 * @param c0X * @param c0Y * @param x * @param y */ public void secondBesselCurveTo(float c0X, float c0Y,float x,float y)&#123; mPoints.add(PathPoint.secondBesselCurveTo(c0X,c0Y,x,y)); &#125; /** * 三阶贝塞尔曲线移动 * @param c0X * @param c0Y * @param c1X * @param c1Y * @param x * @param y */ public void thirdBesselCurveTo(float c0X, float c0Y, float c1X, float c1Y, float x, float y)&#123; mPoints.add(PathPoint.thirdBesselCurveTo(c0X,c0Y,c1X,c1Y,x,y)); &#125; /** * * @return 返回移动动作集合 */ public Collection&lt;PathPoint&gt; getPoints()&#123; return mPoints; &#125;&#125; 该类是最终在客户端使用的,记录一系列的不同移动轨迹,使用时调用里面的方法就可以添加不同的移动轨迹最后通过getPoints()来得到所有的移动轨迹集合 在Android自带的绘制曲线的方法中都是只是通过moveTo()方法设置起始点,在其它的方法中只是传入了终点或控制点坐标。实际上我们要画连续的曲线或连续的移动时,都需要知道起点到终点的之间所有的坐标,哪么怎么来的到这些点的坐标? Android中为我们提供了一个泛型的接口:TypeEvaluator可以很简单的实现这个难题。这里我就把它叫做”估值器”.我们只要创建一个类来实现这个接口,然后通过自己计算公式(就是我们上面的贝塞尔曲线公式) 下面来看看我项目中的估值器类:PathEvaluator 123456789101112131415161718192021222324252627282930313233343536373839import android.animation.TypeEvaluator;/** * Created by zhengliang on 2016/10/15 0015. * 估值器类,实现坐标点的计算 */public class PathEvaluator implements TypeEvaluator&lt;PathPoint&gt; &#123; /** * @param t :执行的百分比 * @param startValue : 起点 * @param endValue : 终点 * @return */ @Override public PathPoint evaluate(float t, PathPoint startValue, PathPoint endValue) &#123; float x, y; float oneMiunsT = 1 - t; //三阶贝塞尔曲线 if (endValue.mOperation == PathPoint.THIRD_CURVE) &#123; x = startValue.mX*oneMiunsT*oneMiunsT*oneMiunsT+3*endValue.mContorl0X*t*oneMiunsT*oneMiunsT+3*endValue.mContorl1X*t*t*oneMiunsT+endValue.mX*t*t*t; y = startValue.mY*oneMiunsT*oneMiunsT*oneMiunsT+3*endValue.mContorl0Y*t*oneMiunsT*oneMiunsT+3*endValue.mContorl1Y*t*t*oneMiunsT+endValue.mY*t*t*t; //二阶贝塞尔曲线 &#125;else if(endValue.mOperation == PathPoint.SECOND_CURVE)&#123; x = oneMiunsT*oneMiunsT*startValue.mX+2*t*oneMiunsT*endValue.mContorl0X+t*t*endValue.mX; y = oneMiunsT*oneMiunsT*startValue.mY+2*t*oneMiunsT*endValue.mContorl0Y+t*t*endValue.mY; //直线 &#125;else if (endValue.mOperation == PathPoint.LINE) &#123; //x起始点+t*起始点和终点的距离 x = startValue.mX + t * (endValue.mX - startValue.mX); y = startValue.mY + t * (endValue.mY - startValue.mY); &#125; else &#123; x = endValue.mX; y = endValue.mY; &#125; return PathPoint.moveTo(x,y); &#125;&#125; 泛型中传入我们自己的定义的PathPoint类;其实这些复杂的计算代码很简单,就是上面贝塞尔曲线的公式,将需要的点直接带入公式即可,我相信仔细看看会明白的! 核心代码到这里就没有了,下面看看MainActivity中的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private FloatingActionButton fab; private AnimatorPath path;//声明动画集合 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); this.fab = (FloatingActionButton) findViewById(R.id.fab); setPath(); fab.setOnClickListener(this); &#125; /*设置动画路径*/ public void setPath()&#123; path = new AnimatorPath(); path.moveTo(0,0); path.lineTo(400,400); path.secondBesselCurveTo(600, 200, 800, 400); //订单 path.thirdBesselCurveTo(100,600,900,1000,200,1200); &#125; /** * 设置动画 * @param view * @param propertyName * @param path */ private void startAnimatorPath(View view, String propertyName, AnimatorPath path) &#123; ObjectAnimator anim = ObjectAnimator.ofObject(this, propertyName, new PathEvaluator(), path.getPoints().toArray()); anim.setInterpolator(new DecelerateInterpolator());//动画插值器 anim.setDuration(3000); anim.start(); &#125; /** * 设置View的属性通过ObjectAnimator.ofObject()的反射机制来调用 * @param newLoc */ public void setFab(PathPoint newLoc) &#123; fab.setTranslationX(newLoc.mX); fab.setTranslationY(newLoc.mY); &#125; @Override public void onClick(View view) &#123; switch (view.getId())&#123; case R.id.fab: startAnimatorPath(fab, "fab", path); break; &#125; &#125;&#125; 上面代码中的:setPath()方法根据你自己项目的需要来设置不同的坐标 注意:(“这里的坐标是View以当前位置的偏移坐标,不是绝对坐标”) 上面代码中的:startAnimatorPath()参数就不介绍了注释中写的很清楚;这里直接看看ObjectAnimator.ofObject()方法的使用把: ObjectAnimator.ofObject(this, propertyName, new PathEvaluator(), path.getPoints().toArray()) 参数:this:View 参数:propertyName:属性名字 :起始这个名字是一个反射机制的调用,这样说不明白,看看这条代码: ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 0f, 1f).setDuration(500).start(); 相信这句代码都能看懂,其中”scaleX”就相当于参数:propertyName 项目代码中我们传入的参数是: startAnimatorPath(fab, &quot;fab&quot;, path); “fab”参数其实对应的就是setFab(PathPoint newLoc)方法,当我们在当前类中定义了该方法,就会自动通过反射的机制来调用该方法! ,如果还不懂,可以看看其它大神写的博客! 看看Xml中的代码: 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;zhengliang.com.customanimationframework.MainActivity&quot;&gt; &lt;zhengliang.com.customanimationframework.CustomView.PathView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:targetApi=&quot;lollipop&quot; /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; /&gt;&lt;/RelativeLayout&gt; 为了可以清晰的看见小球的移动轨迹,自定义了以个View来显示小球的运动轨迹: 1234567891011121314151617181920212223242526272829303132333435public class PathView extends View &#123; private Paint paint; public PathView(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; private void initView() &#123; paint = new Paint(); //抗锯齿 paint.setAntiAlias(true); //防抖动 paint.setDither(true); //设置画笔未实心 paint.setStyle(Paint.Style.STROKE); //设置颜色 paint.setColor(Color.GREEN); //设置画笔宽度 paint.setStrokeWidth(3); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Path path = new Path(); path.moveTo(60,60); path.lineTo(460,460); path.quadTo(660, 260, 860, 460); //订单 path.cubicTo(160,660,960,1060,260,1260); canvas.drawPath(path,paint); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-转场动画深度解析]]></title>
      <url>%2F2017%2F11%2F01%2Fandroid-catransation%2F</url>
      <content type="text"><![CDATA[Android5.0之后新增了很多好看的转场动画，相比于以前的overridePendingTransition()丰富了很多，特别新增了共享元素跳转的方式。本篇文章介绍转场动画框架的基本概念，并着手自己实现转场动画。 Scene（场景）Scene保存了一个布局文件。我们可以通过以下方式生成一个Scene： public static Scene getSceneForLayout(ViewGroup sceneRoot, int layoutId, Context context) 这个方法时静态的，传入一个根布局ViewGroup(作为显示场景的容器),一个layoutId(场景的显示内容),最后传入当前上下文。源码很短，我们一起来看一下： 12345678910111213141516public static Scene getSceneForLayout(ViewGroup sceneRoot, int layoutId, Context context) &#123; SparseArray&lt;Scene&gt; scenes = (SparseArray&lt;Scene&gt;) sceneRoot.getTag( com.android.internal.R.id.scene_layoutid_cache); if (scenes == null) &#123; scenes = new SparseArray&lt;Scene&gt;(); sceneRoot.setTagInternal(com.android.internal.R.id.scene_layoutid_cache, scenes); &#125; Scene scene = scenes.get(layoutId); if (scene != null) &#123; return scene; &#125; else &#123; scene = new Scene(sceneRoot, layoutId, context); scenes.put(layoutId, scene); return scene; &#125; &#125; 根据一个固定的Tag取得保存依附于这个ViewGroup的scene集合SparseArray scenes,如果是空就先new一个。 以要显示场景的layoutId为Key，先尝试获取这个场景，如果已经有这个layoutId对应的场景就直接返回，没有就先调用构造方法生成一个再放入进去，然后返回。 一个scene只能对应一个布局，scene只是简单保存了sceneRoot, layoutId, context的值，并没有通过layoutId来分析处理里面的View信息（也没有必要） 可以通过setEnterAction(Runnable action),setExitAction(Runnable action)，在场景被加载和移除时回调，做相应的操作。 Transition(变换）上面的介绍scene将一个或多个布局和一个加载这些布局的根布局建立起关系。真正的动画是由Transition实现的。所以大致的流程是： 123456789//为Scene创建scene root mSceneRoot = (ViewGroup) findViewById(R.id.scene_root); //创建 scenes Scene mAScene = Scene.getSceneForLayout(mSceneRoot, R.layout.a_scene, this); Scene mAnotherScene = Scene.getSceneForLayout(mSceneRoot, R.layout.another_scene, this); //代码中创建TransitionTransition mFadeTransition = new Fade(); //用TransitionManager负责场景变换TransitionManager.go(mEndingScene, mFadeTransition); 自定义TransitionTransition是个抽象类，必须要实现以下方法： public abstract void captureStartValues(TransitionValues transitionValues);捕获当前场景的视图，这里会对视图树中所有的View调用，有几个View就会调用几次。 public abstract void captureEndValues(TransitionValues transitionValues);捕获目标场景的视图，这里会对视图树中所有的View调用，有几个View就会调用几次。 public Animator createAnimator(ViewGroup sceneRoot, TransitionValues startValues,TransitionValues endValues)（不实现方法这个就没动画效果）从命名就可以看到captureStartValues和captureStartValues分别用来捕获当前场景和目标场景。 TransitionValues有三个重要属性，对理解Transition框架的机制有很大帮助。 View view:就是一个场景的一个View,在里面拿到View，我们可以从里面得到这个View我们所需要的属性。 Map&lt;String, Object&gt; values：默认为空，我们拿到属性后需要放到里面，如果这个Transition需要改变多个属性，就可以放多次进去。 ArrayList&lt;Transition&gt; targetedTransitions：默认为空，用来记录这个View执行了哪些Transition，我们可以在对这个View执行Transition的时候，把这个Transition存进去。 createAnimator方法就是Transition真正的实现方法了，返回一个属性动画。好了实战开始，我们就实现一个Transition来实现直角移动： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ChangeRect extends Transition &#123; private static final String PROPNAME_BER = "changeposition:Rect"; // 开始的状态，这里会对视图树中所有的View调用，这里我们可以记录一下View的我们感兴趣的状态，比如这里：position @Override public void captureStartValues(TransitionValues transitionValues) &#123; captureValues(transitionValues); &#125; // 结束也会对所有的View进行调用 @Override public void captureEndValues(TransitionValues transitionValues) &#123; captureValues(transitionValues); &#125; private void captureValues(TransitionValues transitionValues) &#123; float[] location = new float[2]; location[0] = transitionValues.view.getX(); location[1] = transitionValues.view.getY(); transitionValues.values.put(PROPNAME_BER, location); &#125; //新建动画 @Override public Animator createAnimator(ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues) &#123; if (null == startValues || null == endValues) &#123; return null; &#125; final View view = endValues.view; float[] startPosition = (float[]) startValues.values.get(PROPNAME_BER); float[] endPosition = (float[]) endValues.values.get(PROPNAME_BER); if (startPosition[0] != endPosition[0] || startPosition[1] != endPosition[1]) &#123; Path path=new Path(); path.moveTo(startPosition[0],startPosition[1]); path.lineTo(endPosition[0],startPosition[1]); path.lineTo(endPosition[0],endPosition[1]); ObjectAnimator animator = ObjectAnimator.ofFloat(view, View.X, View.Y, path); animator.setDuration(getDuration()); animator.start(); return animator; &#125; return null; &#125;&#125; 总结简述下Transition框架的执行机制，我们定义了两个Scene，，当我们通过 TransitionManager.go( scene , transition)，从Scene跳转到目标Scene的时候，会去取得scene对应布局，遍历布局中的每一个View（包括根布局和容器View），获取我们需要的属性。通过View的Id我们建立起两个布局中View的对应关系，所以最终只会在目标场景执行原场景有相同Id的View的动画（满足startValues != null &amp;&amp; endValues!= null）。这篇文章只是简单解析了转场动画的原理，详细的两个页面的跳转将会的下一篇展开。 Content TransitionContent Transition就是最常见的转场动画了。为了方便大家理解，我们先来上个图。 部分代码： 源Activity：123456789Slide slide=new Slide();slide.setDuration(3000);slide.setSlideEdge(Gravity.BOTTOM);getWindow().setExitTransition(slide);Explode explode = new Explode();explode.setDuration(3000);explode.setMode(Visibility.MODE_IN);getWindow().setReenterTransition(explode); 目标Activity：123456789Slide slideEnter=new Slide();slideEnter.setDuration(1500);slideEnter.setSlideEdge(Gravity.RIGHT);getWindow().setEnterTransition(slideEnter);Slide slide=new Slide();slide.setDuration(1500);slide.setSlideEdge(Gravity.RIGHT);getWindow().setReturnTransition(slide); 然后在A页面调用方法跳到B页面： 123Intent intent = new Intent(this, BActivity.class);ActivityOptionsCompat activityOptionsCompat = ActivityOptionsCompat.makeSceneTransitionAnimation(this);startActivity(intent, activityOptionsCompat.toBundle()); 可以看到一共可以设置四个Transition： (1)setExitTransition() - 当A 跳转到 B时,A中的View退出场景的效果（默认Null） (2)setEnterTransition() - 当A 跳转到 B时，B中的View进入场景的效果（默认Fade） (3)setReturnTransition() - 当B 返回 A时,B中的View退出场景的效果（默认同EnterTransition） (4)setReenterTransition() - 当B 返回 A时,A中的View进入场景的效果（默认同ExitTransition） 以上这个过程同样可以看做是Transition作用在Scene上的一系列效果，只不过这里的Scene从上一篇中的单一布局换成了Window。不过细心的同学可能发现了，明明我为四个过程都设置动画效果，可为什么ExitTransition没有生效呢？接下来我们为每个Transition加入监听，看看动画的执行流程。下面是其中一个的代码，其他三个都一样： 1234567891011121314151617181920212223242526272829303132Explode explode = new Explode();explode.setDuration(3000);explode.setMode(Visibility.MODE_IN); explode.addListener(new Transition.TransitionListener()&#123; @Override public void onTransitionStart(Transition transition) &#123; Log.d("Transitions--","ReenterTransitionStart"); &#125; @Override public void onTransitionEnd(Transition transition) &#123; Log.d("Transitions--","ReenterTransitionEnd"); &#125; @Override public void onTransitionCancel(Transition transition) &#123; &#125; @Override public void onTransitionPause(Transition transition) &#123; &#125; @Override public void onTransitionResume(Transition transition) &#123; &#125; &#125;); getWindow().setReenterTransition(explode); 再次执行程序，日志信息如下： 原来A页面的退出动画和B页面的进入动画、B页面的返回动画和A页面的重现动画是并行执行的。也就是说A页面的ExitTransition不是没有执行，而是在它执行的时候，B页面已经覆盖上来，并且EnterTransition已经同时在执行了，这时A页面已经不可见了。这也是Android默认的转场动画执行流程。那问题来了，如果想要并行执行该怎么办呢？有两种方法：在设置Transition的时候同时设置不允许Transition重叠，也就是并行执行： 12getWindow().setAllowEnterTransitionOverlap(false);getWindow().setWindowAllowReturnTransitionOverlap(false); 或者在主题文件全局设置这个属性，这样无疑更好，即减少了代码又保证了应用视觉效果的统一： 12&lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;false&lt;/item&gt;&lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;false&lt;/item&gt; 修改后效果如下：日志也显示现在是串行执行了： 生命周期分析保持上面的打印信息不变，我们增加两个Activity的生命周期日志信息，串行结果如下： 并行如下： 可以得到如下信息： 在A页面的onPause执行前，ExitTransition就已经开始执行了 Transition不会阻塞BActivity的生命周期，尽管是串行执行的，即使ExitTransition没结束，BActivity已经执行完OnResume了。 ReturnExitTransition需要等到AActivity OnStart执行完才开始执行，而且ReturnExitTransition会阻塞AActivity的生命周期，AActivity的OnResume会等到ReturnExitTransition执行完再执行。关于这点可以简要说明下：直接调用Finish不会有动画直接结束掉，需要执行onBackPressed()才会有ReturnExitTransition。看源码就很明显了： 123456789public void onBackPressed() &#123; if (mActionBar != null &amp;&amp; mActionBar.collapseActionView()) &#123; return; &#125; if (!mFragments.getFragmentManager().popBackStackImmediate()) &#123; finishAfterTransition(); &#125; &#125; 总结最后简单分析下转场动画的大致流程（以slide为例），看过上一篇文章的同学应该很好理解： 1234567891.从DecoerView开始，依次遍历获得当前Window上的视图树里的所有View2.执行captureStartValues(TransitionValues transitionValues)，捕获View开始状态的一些属性（visibility，Parent，LocationOnScree）3.设置所有的VIew为INVISIBLE。4.执行captureEndValues(TransitionValues transitionValues)，捕获View结束状态的一些属性（visibility，Parent，LocationOnScree）5.比较属性的不同,创建属性动画。下一个过程就是返回属性动画并执行了。 这是ExitTransiton的流程，其他三个也差不多。下一篇将会讲带共享元素的转场动画，也是material design中很有特色的动画了。 终于到了material design转场动画中最好玩，最有特色的一部分了。我们沿用上一篇的图，不过将跳转Activity的代码作如下更改： 12345Intent intent = new Intent(this,BBBActivity.class);ActivityOptionsCompat activityOptionsCompat =ActivityOptionsCompat.makeSceneTransitionAnimation(this , new Pair&lt;View, String&gt;(shared_image, "shared_image_") , new Pair&lt;View, String&gt;(shared_text, "shared_text_"));startActivity(intent, activityOptionsCompat.toBundle()); 然后在BBBActivity的布局文件想要设置共享元素的部分设置android:transitionName，值和上个页面中设置的值要一一对应，比如： 123456&lt;TextView android:id=&quot;@+id/tv_show&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;我是一行文字&quot; android:transitionName=&quot;shared_text_&quot;/&gt; 当然也可以在代码中设置（注意要在调用时机，不能晚于OnResume）：shared_image.setTransitionName(&quot;shared_image_&quot;);这样简单两步，咱们的带共享元素的转场动画就改造完成了： 自定义共享元素动画自带的共享元素动画很简单，可以通过如下代码定义进入和返回动画： 12345678910 getWindow().setSharedElementEnterTransition(Transition transition) getWindow().setSharedElementReturnTransition(Transition transition)``` 仔细一看这两个方法都只需要一个transition作为动画，所以意味着自定义共享元素动画就是自定义Transition了。套用第一篇自定义的那个直角移动ChangeRect，效果如下：![20171111151041183822484.gif](http://ohtrrgyyd.bkt.clouddn.com/20171111151041183822484.gif)# 其他方法上面我们只用两个方法就完成了一次完整的共享元素进入到返回动画。但其实和普通的转场动画一样，设置共享元素的转场动画有四个，除了上面介绍的还有两个就是 setSharedElementExitTransitionsetSharedElementReenterTransition1234567891011121314151617看命名方式和普通的转场动画非常相似，也就是共享元素离开和重现动画的方法。但是共享元素转场是为了表现两个页面相似内容连贯性而设计的，一组动画就足以完成了。但如果我们都加上后会怎么样呢？为了动画更明显，我们把普通动画设为串行：![2017111115104118664268.gif](http://ohtrrgyyd.bkt.clouddn.com/2017111115104118664268.gif)可以看到新增的两个并没有生效，通过日志打印也可以卡出这一点：![2017111115104118919019.png](http://ohtrrgyyd.bkt.clouddn.com/2017111115104118919019.png)SharedElementExitTransition和SharedElementReenterTransition开始后立即就结束了。关于这一点，参看stackoverflow上的回答，简单来说这两个动画的设计只是为了作一些初始化而存在的。当我们点击跳转按钮的时候，马上就已经跳到了B（参看上一篇生命周期的分析），而共享元素动画没有所谓的串行机制，会马上执行SharedElementEnterTransition，所以转场动画内部会立即结束掉ExitTransition。而ReenterTransition我们也可以从gif图看到，SharedElementReturnTransition已经完成了动画，将目标View变为目标状态，所以不再进行SharedElementReturnTransition（也因为没必要），所以只进行了普通转场动画的ReenterTransition。# 共享元素执行空间Window中有个关于共享元素的设置setSharedElementsUseOverlay(boolean sharedElementsUseOverlay)，我们将其设为false，重启App：![20171111151041191716571.gif](http://ohtrrgyyd.bkt.clouddn.com/20171111151041191716571.gif)可以看到动画执行流程没有变但是共享元素在移动过程中被遮住了，我们来看源码 protected void moveSharedElementsToOverlay() { if (mWindow == null || !mWindow.getSharedElementsUseOverlay()) { return; } setSharedElementMatrices(); int numSharedElements = mSharedElements.size(); ViewGroup decor = getDecor(); if (decor != null) { boolean moveWithParent = moveSharedElementWithParent(); Matrix tempMatrix = new Matrix(); for (int i = 0; i &lt; numSharedElements; i++) { View view = mSharedElements.get(i); tempMatrix.reset(); mSharedElementParentMatrices.get(i).invert(tempMatrix); GhostView.addGhost(view, decor, tempMatrix); ViewGroup parent = (ViewGroup) view.getParent(); if (moveWithParent &amp;&amp; !isInTransitionGroup(parent, decor)) { GhostViewListeners listener = new GhostViewListeners(view, parent, decor); parent.getViewTreeObserver().addOnPreDrawListener(listener); mGhostViewListeners.add(listener); } } } }``` 可以看到,如果getSharedElementsUseOverlay==true（也就是默认状态），系统会得到这个View，然后GhostView.addGhost(view, decor, tempMatrix)，放置在decorView的Overlay上，因为是decorView，所以也就是在整个view树结构的最上层。Overlay它是view的最上面的一个透明的层，添加到上面的和view不会被其他View遮挡住。 拓展：共享元素形变动画前面的动画效果都是操作View原有的一些属性，View的内容没有(或者内容没有改变），所以如果与Svg矢量动画配合一番，会产生怎么样的效果呢： 其实很简单，监听SharedElementEnterTransition和SharedElementReturnTransition动画，在其执行的时候执行矢量动画就行了。在更多关于这个矢量动画实现的东西可以参考这篇文章。 写在最后好了关于Android转场动画的内容完结了，代码已上传gitHub，欢迎指正！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-手势检测GestureDetector全面分析]]></title>
      <url>%2F2017%2F11%2F01%2Fandroid-gesturedetector%2F</url>
      <content type="text"><![CDATA[前言 在很多视频播放器中，都存在使用不同的手势来控制进度、亮度\音量和暂停播放等功能。Android提供了一个GestureDetector来帮助我们识别一些基本的触摸手势（还有ScaleGestureDetector可以识别缩放手势），让我们很方便地实现手势控制功能。下面我们就来学习一下GestureDetector的使用和通过源码（Android7.0）来分析一下它的实现，让我们对触摸事件处理的理解更加深入。 GestureDetector介绍 Detector的意思就是探测者，所以GestureDetector就是用来监听手势的发生。它内部有3个Listener接口，用来回调不同类型的触摸事件，用一个简略的类图来显示： 里面这些接口的方法，就是相应触摸事件的回调，实现了这些方法，就能实现传入触摸事件之后做出相应的回调。 一些回调接口： OnGestureListener，这个Listener监听一些手势，如单击、滑动、长按等操作： onDown(MotionEvent e):用户按下屏幕的时候的回调。 onShowPress(MotionEvent e)：用户按下按键后100ms（根据Android7.0源码）还没有松开或者移动就会回调，官方在源码的解释是说一般用于告诉用户已经识别按下事件的回调（我暂时想不出有什么用途，因为这个回调触发之后还会触发其他的，不像长按）。 onLongPress(MotionEvent e)：用户长按后（好像不同手机的时间不同，源码里默认是100ms+500ms）触发，触发之后不会触发其他回调，直至松开（UP事件）。 onScroll(MotionEvent e1, MotionEvent e2,float distanceX, float distanceY)：手指滑动的时候执行的回调（接收到MOVE事件，且位移大于一定距离），e1,e2分别是之前DOWN事件和当前的MOVE事件，distanceX和distanceY就是当前MOVE事件和上一个MOVE事件的位移量。 onFling(MotionEvent e1, MotionEvent e2, float velocityX,float velocityY)：用户执行抛操作之后的回调，MOVE事件之后手松开（UP事件）那一瞬间的x或者y方向速度，如果达到一定数值（源码默认是每秒50px），就是抛操作（也就是快速滑动的时候松手会有这个回调，因此基本上有onFling必然有onScroll）。 onSingleTapUp(MotionEvent e)：用户手指松开（UP事件）的时候如果没有执行onScroll()和onLongPress()这两个回调的话，就会回调这个，说明这是一个点击抬起事件，但是不能区分是否双击事件的抬起。 OnDoubleTapListener，这个Listener监听双击和单击事件。 onSingleTapConfirmed(MotionEvent e)：可以确认（通过单击DOWN后300ms没有下一个DOWN事件确认）这不是一个双击事件，而是一个单击事件的时候会回调。 onDoubleTap(MotionEvent e)：可以确认这是一个双击事件的时候回调。 onDoubleTapEvent(MotionEvent e)：onDoubleTap()回调之后的输入事件（DOWN、MOVE、UP）都会回调这个方法（这个方法可以实现一些双击后的控制，如让View双击后变得可拖动等）。 OnContextClickListener，很多人都不知道ContextClick是什么，我以前也不知道，直到我把平板接上了外接键盘——原来这就是鼠标右键。。。 onContextClick(MotionEvent e)：当鼠标/触摸板，右键点击时候的回调。 SimpleOnGestureListener，实现了上面三个接口的类，拥有上面三个的所有回调方法。 由于SimpleOnGestureListener不是抽象类，所以继承它的时候只需要选取我们所需要的回调方法来重写就可以了，非常方便，也减少了代码量，符合接口隔离原则，也是模板方法模式的实现。而实现上面的三个接口中的一个都要全部重写里面的方法，所以我们一般都是选择SimpleOnGestureListener。 ps:上面所有的回调方法的返回值都是boolean类型，和View的事件传递机制一样，返回true表示消耗了事件，flase表示没有消耗。 GestureDetector的使用GestureDetector的使用很简单，因为它的功能就是定义为识别手势，所以使用的话就是输入完整的触摸事件（完整的意思就是用户所有的触摸操作都是输入给它。为什么要强调完整，因为我上一篇博客就是分享如何拦截子View的部分触摸事件），识别然后进行相应的回调： 123456789101112131415161718192021 private void init(Context context)&#123; mOnGestureListener = new MyOnGestureListener(); mGestureDetector = new GestureDetector(context,mOnGestureListener);// mGestureDetector.setIsLongpressEnabled(false); setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; //监听触摸事件 return mGestureDetector.onTouchEvent(event); &#125; &#125;); setOnGenericMotionListener(new OnGenericMotionListener() &#123; @Override public boolean onGenericMotion(View v, MotionEvent event) &#123; Log.d(TAG, "onGenericMotion: "); //监听鼠标右键点击事件 return mGestureDetector.onGenericMotionEvent(event); &#125; &#125;); &#125; 如上面的代码，要使用OnGestureListener和OnDoubleTapListener里面的回调需要调用GestureDetector.onTouchEvent()方法，而使用OnContextClickListener的话则是需要调用onGenericMotionEvent()方法，注意一个是在onTouch()方法一个是在onGenericMotion()方法。 看完了上面一堆文字，其实你就会懂得如何使用GestureDetector了，这里有GestureDetector的实践。但是如果你想了解它的回调的时机为什么会是这样的，想具体了解它们的回调时机，可以继续看下去，下面是源码分析。 GestureDetector源码分析初始化处理 GestureDetector的源码接近800行，这在Android源码中已经算是比较短的了（毕竟注释也占一两百行了），所以说它的实现也不是很复杂的。从它的构造方法开始： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public GestureDetector(Context context, OnGestureListener listener) &#123; this(context, listener, null);&#125;public GestureDetector(Context context, OnGestureListener listener, Handler handler) &#123; //初始化Handler if (handler != null) &#123; mHandler = new GestureHandler(handler); &#125; else &#123; mHandler = new GestureHandler(); &#125; //设置Listener mListener = listener; if (listener instanceof OnDoubleTapListener) &#123; setOnDoubleTapListener((OnDoubleTapListener) listener); &#125; if (listener instanceof OnContextClickListener) &#123; setContextClickListener((OnContextClickListener) listener); &#125; init(context);&#125;private void init(Context context) &#123; if (mListener == null) &#123; throw new NullPointerException("OnGestureListener must not be null"); &#125; mIsLongpressEnabled = true; // Fallback to support pre-donuts releases int touchSlop, doubleTapSlop, doubleTapTouchSlop; if (context == null) &#123; //相当于下面的getScaledTouchSlop，表示滑动的时候，手的移动要大于这个距离才开始移动控件 touchSlop = ViewConfiguration.getTouchSlop(); //相当于下面的getScaledDoubleTapTouchSlop，表示点击的时候，手指移动大于这个距离，就被认为不可能是双击 doubleTapTouchSlop = touchSlop; //相当于下面的getScaledDoubleTapSlop，表示第二次点击的时候，和第一次的点击点位置距离如果大于这个，就被认为不是双击 doubleTapSlop = ViewConfiguration.getDoubleTapSlop(); mMinimumFlingVelocity = ViewConfiguration.getMinimumFlingVelocity(); mMaximumFlingVelocity = ViewConfiguration.getMaximumFlingVelocity(); &#125; else &#123; final ViewConfiguration configuration = ViewConfiguration.get(context); touchSlop = configuration.getScaledTouchSlop(); doubleTapTouchSlop = configuration.getScaledDoubleTapTouchSlop(); doubleTapSlop = configuration.getScaledDoubleTapSlop(); mMinimumFlingVelocity = configuration.getScaledMinimumFlingVelocity(); mMaximumFlingVelocity = configuration.getScaledMaximumFlingVelocity(); &#125; //做平方好计算距离，后面的距离对比也是用平方 mTouchSlopSquare = touchSlop * touchSlop; mDoubleTapTouchSlopSquare = doubleTapTouchSlop * doubleTapTouchSlop; mDoubleTapSlopSquare = doubleTapSlop * doubleTapSlop;&#125; 可见GestureDetector的创建就是初始化一些属性，然后就是把对应的Listener设置好，还有初始化Handler，而这里的GestureHandler，是控制onShowPress()，onLongPress()，onSingleTapConfirmed()`回调的关键： 1234567891011121314151617181920212223242526272829303132333435363738394041private class GestureHandler extends Handler &#123; //省略构造函数... @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case SHOW_PRESS: mListener.onShowPress(mCurrentDownEvent); break; case LONG_PRESS: dispatchLongPress(); break; case TAP: // If the user's finger is still down, do not count it as a tap //这里控制SingleTapConfirmed的回调， if (mDoubleTapListener != null) &#123; if (!mStillDown) &#123; //如果已经松开，就立刻调用SingleTapConfirmed mDoubleTapListener.onSingleTapConfirmed(mCurrentDownEvent); &#125; else &#123; //如果处理Message的时候还没松开，就设置mDeferConfirmSingleTap为true，在UP事件的时候调用SingleTapConfirme mDeferConfirmSingleTap = true; &#125; &#125; break; default: throw new RuntimeException("Unknown message " + msg); //never &#125; &#125; &#125; //长按处理 private void dispatchLongPress() &#123; mHandler.removeMessages(TAP); mDeferConfirmSingleTap = false; mInLongPress = true; mListener.onLongPress(mCurrentDownEvent); &#125; 输入处理 初始化完之后，就是看它的如何处理输入了，这是它的核心逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public boolean onTouchEvent(MotionEvent ev) &#123; //检查事件输入的一致性,log出来一致性的信息，如：有事件只有up没有down if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(ev, 0); &#125; final int action = ev.getAction(); //开始速度检测 if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(ev); //检测是否非主要指针抬起动作（如果是多点触摸） final boolean pointerUp = (action &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP; final int skipIndex = pointerUp ? ev.getActionIndex() : -1; // Determine focal point // 是非主要指针抬起动作的话会跳过 float sumX = 0, sumY = 0; final int count = ev.getPointerCount(); //把所有还在触摸的手指的位置x，y加起来，后面求平均数，算出中心焦点 for (int i = 0; i &lt; count; i++) &#123; if (skipIndex == i) continue; sumX += ev.getX(i); sumY += ev.getY(i); &#125; final int div = pointerUp ? count - 1 : count; final float focusX = sumX / div; final float focusY = sumY / div; boolean handled = false; switch (action &amp; MotionEvent.ACTION_MASK) &#123; case MotionEvent.ACTION_POINTER_DOWN: //... break; case MotionEvent.ACTION_POINTER_UP: //... break; case MotionEvent.ACTION_DOWN: //... break; case MotionEvent.ACTION_MOVE: //... break; case MotionEvent.ACTION_UP: //... break; case MotionEvent.ACTION_CANCEL: cancel(); break; &#125; //对未被处理的事件进行一次一致性检测 if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0); &#125; return handled;&#125; 上面的注释写得很清楚了，主要onTouchEvent()的主要思路就是先对输入事件做出统一处理，提取一些共有的信息，如多个点同时触摸时候的中心焦点和滑动速度等，然后根据事件的分类做出相应的处理。 ps：InputEventConsistencyVerifier对输入事件进行的一致性检测的结果并不影响GestureDetector的运行，如果检测到一致性不符合的事件（只有UP事件而前面没有DOWN事件），就只会输出log告诉开发者。 DOWN事件处理 下面进入DOWN事件的处理： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//... case MotionEvent.ACTION_DOWN: if (mDoubleTapListener != null) &#123; //处理双击 //取消TAP事件 boolean hadTapMessage = mHandler.hasMessages(TAP); if (hadTapMessage) mHandler.removeMessages(TAP); if ((mCurrentDownEvent != null) &amp;&amp; (mPreviousUpEvent != null) &amp;&amp; hadTapMessage &amp;&amp; isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) &#123; // This is a second tap mIsDoubleTapping = true; // Give a callback with the first tap of the double-tap //回调双击 handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent); // Give a callback with down event of the double-tap handled |= mDoubleTapListener.onDoubleTapEvent(ev); &#125; else &#123; // This is a first tap //延时发出单击事件，如果到了时间（300ms）还没有取消的话就确认是TAP事件了 mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT); &#125; &#125; mDownFocusX = mLastFocusX = focusX; mDownFocusY = mLastFocusY = focusY; //重置mCurrentDownEvent if (mCurrentDownEvent != null) &#123; mCurrentDownEvent.recycle(); &#125; mCurrentDownEvent = MotionEvent.obtain(ev); mAlwaysInTapRegion = true; mAlwaysInBiggerTapRegion = true; mStillDown = true; mInLongPress = false; mDeferConfirmSingleTap = false; //处理长按 if (mIsLongpressEnabled) &#123; mHandler.removeMessages(LONG_PRESS); //延时发送长按事件 mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT); &#125; //延时发送showPress事件 mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT); handled |= mListener.onDown(ev); break;//...//判断第二次点击是否有效双击private boolean isConsideredDoubleTap(MotionEvent firstDown, MotionEvent firstUp, MotionEvent secondDown) &#123; //第一次点击后是否有移动超出范围 if (!mAlwaysInBiggerTapRegion) &#123; return false; &#125; final long deltaTime = secondDown.getEventTime() - firstUp.getEventTime(); if (deltaTime &gt; DOUBLE_TAP_TIMEOUT || deltaTime &lt; DOUBLE_TAP_MIN_TIME) &#123; return false; &#125; int deltaX = (int) firstDown.getX() - (int) secondDown.getX(); int deltaY = (int) firstDown.getY() - (int) secondDown.getY(); //判断第二次点击是否在附近，在附近才被认为是双击 return (deltaX * deltaX + deltaY * deltaY &lt; mDoubleTapSlopSquare);&#125; 可见，对DOWN事件涉及： 处理单击判断：如果收到一次DOWN事件，而且前段时间没有DOWN事件的话，会发送一个延时的TAP信息，而一段时间（300ms）之后没有被取消的话，就执行GestureHandler里面的TAP单击确认操作。 处理双击判断：如果前面也有一次DOWN事件，而且也符合isConsideredDoubleTap()的条件（第一次点击后没有移动超出范围，第二次点击也在附近），就可以确认双击，执行onDoubleTap()和onDoubleTapEvent()的回调。 处理长按判断：先看用户是否允许检测长按，然后就是发送一个延时的LONG_PRESS信息，如果到时候还没被取消的话就是回调长按方法了。 处理showPress判断：这个和长按差不多，就是时间（100ms）短了一点而已。 PS：handled是boolean变量，|=符号是用符号右边的值跟左边的值进行或运算再赋值给左边。a |= b等价于a = a | b，这里使handled变量初始值为false，进行了多次|=操作，一旦有结果是true的话，handled最后的值就是true，所有结果都是false最后才会false，onTouchEvent()方法最后返回这个handled，就可以表示事件有没被处理，实现了对事件处理的封装。 MOVE事件处理然后再看看对MOVE事件的处理： 12345678910111213141516171819202122232425262728293031323334353637383940//... case MotionEvent.ACTION_MOVE: //如果是正在长按和点击了鼠标右键 if (mInLongPress || mInContextClick) &#123; break; &#125; final float scrollX = mLastFocusX - focusX; final float scrollY = mLastFocusY - focusY; if (mIsDoubleTapping) &#123; // Give the move events of the double-tap //如果是第二次点击的话，把移动事件也当作双击，有点奇怪 handled |= mDoubleTapListener.onDoubleTapEvent(ev); &#125; else if (mAlwaysInTapRegion) &#123; //down才会使mAlwaysInTapRegion为true final int deltaX = (int) (focusX - mDownFocusX); final int deltaY = (int) (focusY - mDownFocusY); int distance = (deltaX * deltaX) + (deltaY * deltaY); //mTouchSlopSquare是一个距离的平方，表示滑动的时候，手的移动要大于这个距离才认为是Scroll事件 if (distance &gt; mTouchSlopSquare) &#123; //进入Scroll模式 handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY); mLastFocusX = focusX; mLastFocusY = focusY; mAlwaysInTapRegion = false; mHandler.removeMessages(TAP); mHandler.removeMessages(SHOW_PRESS); mHandler.removeMessages(LONG_PRESS); &#125; if (distance &gt; mDoubleTapTouchSlopSquare) &#123; //如果移动距离超过允许范围，则不再可能认为移动事件是双击 mAlwaysInBiggerTapRegion = false; &#125; &#125; else if ((Math.abs(scrollX) &gt;= 1) || (Math.abs(scrollY) &gt;= 1)) &#123; //后续的Scroll移动，前面的是进入Scroll移动 handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY); mLastFocusX = focusX; mLastFocusY = focusY; &#125; break;//... 可见，对MOVE事件涉及： onDoubleTapEvent()回调：只要确认是双击之后，mIsDoubleTapping为true，除了长按，后面的MOVE事件都会只回调onDoubleTapEvent()。 onScroll()回调：当MOVE不是长按，不是DoubleTapEvent之后，当移动距离大于一定距离之后，就会进入Scroll模式，然后两个MOVE事件的位移距离scrollX或者scrollY大于1px，都会调用onScroll()。 UP事件的处理接下来再看UP事件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//... case MotionEvent.ACTION_UP: mStillDown = false; MotionEvent currentUpEvent = MotionEvent.obtain(ev); if (mIsDoubleTapping) &#123; // Finally, give the up event of the double-tap //双击事件 handled |= mDoubleTapListener.onDoubleTapEvent(ev); &#125; else if (mInLongPress) &#123; //长按结束 mHandler.removeMessages(TAP); mInLongPress = false; &#125; else if (mAlwaysInTapRegion &amp;&amp; !mIgnoreNextUpEvent) &#123; handled = mListener.onSingleTapUp(ev); //处理单击确认，具体逻辑看GestureHandler如何处理TAP事件 if (mDeferConfirmSingleTap &amp;&amp; mDoubleTapListener != null) &#123; mDoubleTapListener.onSingleTapConfirmed(ev); &#125; &#125; else if (!mIgnoreNextUpEvent) &#123; //处理Fling，如果速度大于定义的最小速度（50），就回调Fling // A fling must travel the minimum tap distance final VelocityTracker velocityTracker = mVelocityTracker; final int pointerId = ev.getPointerId(0); velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity); final float velocityY = velocityTracker.getYVelocity(pointerId); final float velocityX = velocityTracker.getXVelocity(pointerId); if ((Math.abs(velocityY) &gt; mMinimumFlingVelocity) || (Math.abs(velocityX) &gt; mMinimumFlingVelocity))&#123; handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY); &#125; &#125; //重置mPreviousUpEvent if (mPreviousUpEvent != null) &#123; mPreviousUpEvent.recycle(); &#125; // Hold the event we obtained above - listeners may have changed the original. mPreviousUpEvent = currentUpEvent; //回收mVelocityTracker if (mVelocityTracker != null) &#123; // This may have been cleared when we called out to the // application above. mVelocityTracker.recycle(); mVelocityTracker = null; &#125; mIsDoubleTapping = false; mDeferConfirmSingleTap = false; mIgnoreNextUpEvent = false; mHandler.removeMessages(SHOW_PRESS); mHandler.removeMessages(LONG_PRESS); break;//... 可见，对MOVE事件涉及： onDoubleTapEvent()回调：只要确认是双击之后，mIsDoubleTapping为true，除了长按，后面的MOVE事件都会只回调onDoubleTapEvent()。 onSingleTapUp()回调：DOWN事件之后没有MOVE，或者MOVE的距离没有超出范围，mAlwaysInTapRegion才不会变成false，回调onSingleTapUp()。 onSingleTapConfirmed()回调：从前面GestureHandler里面的TAP消息的实现可以看到： 12345678910111213case TAP: // If the user's finger is still down, do not count it as a tap //这里控制SingleTapConfirmed的回调， if (mDoubleTapListener != null) &#123; if (!mStillDown) &#123; //如果已经松开，就立刻调用SingleTapConfirmed mDoubleTapListener.onSingleTapConfirmed(mCurrentDownEvent); &#125; else &#123; //如果处理Message的时候还没松开，就设置mDeferConfirmSingleTap为true，在UP事件的时候调用SingleTapConfirme mDeferConfirmSingleTap = true; &#125; &#125; break; 之前看过，TAP消息是延时（300ms）发送的，然而实际逻辑中，是抬起手指才算是点击，所以这里处理TAP的时候就不一定立刻调用onSingleTapConfirmed()，而是判断手指是否松开了，是松开的话就立刻回调。如果还未松开那就把标志位mDeferConfirmSingleTap设置为true，等到收到UP事件的时候再回调。 onFling()回调：当UP事件的速度大于一定速度时，就会回调onFling()，至于mIgnoreNextUpEvent参数，是只有鼠标右键点击的时候才会为true，具体看后面。 多点触摸的处理 对于多个手指落下，前面的统一处理已经是把所有手指的坐标值加起来然后算平均值了，所以我们多根手指触摸的时候，其实滑动的实际点是这些手指的中心焦点。回看上面的MOVE事件处理，中心焦点的位置值FocusX和FocusY决定onScroll(onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY))的后两个参数值，所以处理多点触控的话就使用它们比较方便。因为MotionEvent是使用数组装着当前屏幕上所有指针的动作的，使用前两个参数的话还要循环用getX(int pointerIndex)和getY(int pointerIndex)方法取出各个指针的值再自己处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//... case MotionEvent.ACTION_POINTER_DOWN: mDownFocusX = mLastFocusX = focusX; mDownFocusY = mLastFocusY = focusY; // Cancel long press and taps //如果有多根手指按下，取消长按和点击计时 cancelTaps(); break; case MotionEvent.ACTION_POINTER_UP: mDownFocusX = mLastFocusX = focusX; mDownFocusY = mLastFocusY = focusY; // Check the dot product of current velocities. // If the pointer that left was opposing another velocity vector, clear. //计算每一秒钟的滑动像素 mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity); final int upIndex = ev.getActionIndex(); final int id1 = ev.getPointerId(upIndex); final float x1 = mVelocityTracker.getXVelocity(id1); final float y1 = mVelocityTracker.getYVelocity(id1); //如果剩下的手指速度方向是和抬起那根手指的速度相反方向的，就说明不是fling，清空速度监听 for (int i = 0; i &lt; count; i++) &#123; if (i == upIndex) continue; final int id2 = ev.getPointerId(i); final float x = x1 * mVelocityTracker.getXVelocity(id2); final float y = y1 * mVelocityTracker.getYVelocity(id2); final float dot = x + y; if (dot &lt; 0) &#123; mVelocityTracker.clear(); break; &#125; &#125; break;//...private void cancelTaps() &#123; mHandler.removeMessages(SHOW_PRESS); mHandler.removeMessages(LONG_PRESS); mHandler.removeMessages(TAP); mIsDoubleTapping = false; mAlwaysInTapRegion = false; mAlwaysInBiggerTapRegion = false; mDeferConfirmSingleTap = false; mInLongPress = false; mInContextClick = false; mIgnoreNextUpEvent = false;&#125; 这是对多个手指的UP和DOWN事件处理，其实就是做一些取消操作而让多点触摸不影响单点触摸的应用，例如在多个手指落下的时候取消点击信息等。 ContextClick的处理 ContextClick的事件是由onGenericMotionEvent()传入： 1234567891011121314151617181920212223242526272829303132public boolean onGenericMotionEvent(MotionEvent ev) &#123; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onGenericMotionEvent(ev, 0); &#125; final int actionButton = ev.getActionButton(); switch (ev.getActionMasked()) &#123; case MotionEvent.ACTION_BUTTON_PRESS: //按下触控笔首选按钮或者鼠标右键 if (mContextClickListener != null &amp;&amp; !mInContextClick &amp;&amp; !mInLongPress &amp;&amp; (actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY || actionButton == MotionEvent.BUTTON_SECONDARY)) &#123; if (mContextClickListener.onContextClick(ev)) &#123; mInContextClick = true; mHandler.removeMessages(LONG_PRESS); mHandler.removeMessages(TAP); return true; &#125; &#125; break; case MotionEvent.ACTION_BUTTON_RELEASE: if (mInContextClick &amp;&amp; (actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY || actionButton == MotionEvent.BUTTON_SECONDARY)) &#123; mInContextClick = false; //无视下一个UP事件，因为它是由鼠标右键或者触控笔键带起的 mIgnoreNextUpEvent = true; &#125; break; &#125; return false;&#125; 由此可以，当按键按下（ACTION_BUTTON_PRESS）的时候已经回调onContextClick()。 总结读完源码，总结出来的每个回调的调用时机如下表： PS：除去onContextClick()，因为它的按下鼠标右键时候是发出一系列的事件。 回调/输入事件 DOWN事件 MOVE事件 UP事件 onDown(MotionEvent e) √ × × onShowPress(MotionEvent e) √ × × onLongPress(MotionEvent e) √ × × onScroll(MotionEvent e1, MotionEvent e2,float distanceX, float distanceY) × √ × onFling(MotionEvent e1, MotionEvent e2, float velocityX,float velocityY)) × × √ onSingleTapUp(MotionEvent e) × × √ onSingleTapConfirmed(MotionEvent e) × × √ onDoubleTap(MotionEvent e) √ × × onDoubleTapEvent(MotionEvent e) √ √ √ 从上面的分析可以看出，虽然GestureDetector能识别很多手势，但是也是不能满足所有的需求的，如滑动和长按之后松开没有回调（这个可以重写onTouch()捕捉UP事件实现）、多点触控缩放手势的实现（这个可以用ScaleGestureDetector）等。 后话 有人问我看GestureDetector源码这么仔细有什么用，它又不是很常用的东西，网上随便一搜一堆资料。我的回答是因为我觉得要用一个东西的话，首先就是要搞清楚它能干什么，它的限制是什么，为什么要选择它，关于这些方面，网上的很多关于GestureDetector的资料都没有达到我想了解的程度，加上GestureDetector并不复杂，所以写下了这篇博客，这样就可以从源码层面上了解到它的回调是什么时候调用，有bug的时候也能更快的找出。 不管怎样，GestureDetector里面的SimpleOnGestureListener的设计，和对触摸事件的处理方式是很值得我学习的，记录分享至此，水平有限，如果错漏，欢迎指正和讨论。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-玩转PathMeasure]]></title>
      <url>%2F2017%2F10%2F31%2Fandroid-pathmeasure%2F</url>
      <content type="text"><![CDATA[PathMeasurePublic constructors PathMeasure 创建一个空的 pathmeasure 对象 PathMeasure(Path path,boolean forceClosed)创建一个带 path 参数的 PathMeasure,forceClosed控制 path 是否自动闭合 Public methods getLength() 返回当前 Path 的总长度。 getMatrix(float distance, Matrix matrix, int flags) getPosTan(float distance, float[] pos, float[] tan)获取distance长度的 point 值给 pos，point 点的正切值给 tan。 getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) 获取 path 的一个片段，即startD到 stopD 的线段，辅助给 dst。 isClosed() 是否自动闭合 nextContour() 移动到下一条曲线。如果 path 中含有不连续的线条，getLength、getPosTan等方法之会在第一条线上运行，需要使用这个方法跳到第二条线 setPath(Path path, boolean forceClosed) 是不是很简单，就这么几个方法，现在去画光能使者阵有思路了么~~接下来为了便于大家理解，我们再来简单回顾一下 path 的 api，因为静态的光能使者阵是需要 path 去绘制的。 Path 方法名 作用 moveTo 移动到指定点 setLastPoint 重新设置当前Path的最后一个点，如果当前Path为空，则等同上个方法 lineTo 添加当前点到一个指定点的直线 close 连接当前点到起点，形成闭合路径 addRect、addRoundRect、addOval、addCircle、addPath、addArc、arcTo 添加各种图形 isEmpty 是否为空 isRect 是否为矩形 set 用一个新的path替换 offset 对当前的路径进行偏移，不会影响后续操作 quadTo、cubicTo 贝塞尔曲线 rMoveTo、rLineTo、rQuaTo、rCubicTo 带r的是基于当前点的偏移量，不带r基于坐标原点 setFillType、getFillType 设置填充模式 transform 矩阵变换 动画拆解好了，准备工作完成，我们开始撸代码 第一步，绘制静态的光能使者阵首先绘制两个圆，然后就是中间的六角星（其实仔细看就是两个三角形）。都是很简单的方法，同学们动手去画的时候可能会遇到一个这样的问题，就是三角形的三个点不好取。其实很简单，直接在圆上取0，1/3，2/3长度的点即可，刚刚我们不是说了 PathMeasure 的方法么，用getPosTan就可以实现。 第二步，让光能使者阵动起来这里我们把这个动画效果分成三个阶段吧。 第一阶段，绘制两个圆 如上图所示，这里两个圆是慢慢绘制出来的， 圆的 path 很容易绘制出来，这里我就不讲了，然后PathMeasure的getLength可以获取 path 总的长度，getSegment可以获取某个点到某个点的 Path。因此一个 ValueAnimator 就可以解决从0到100%长度的过程，具体实现看后面的代码。 然后问题来了，path画出来的圆的起点在哪里？怎么控制两个圆开始绘制的角度不一样。有同学可能想到了旋转90°再画第二个圆，当然这种方式是可以实现的，但是由于后面的三角形也需要旋转，这里我们就不用 path 画圆了，用 path 添加一个正方形 Rect 的圆弧也是一个圆，然后我们的圆弧可以控制开始的角度，弧度。然后变成这样了 WTF？角度怎么不对了，我明明设置的开始角度的呀 12innerCircle.addArc(innerRect, 150, -360);outerCircle.addArc(outerRect, 60, -360); 最后有个大牛说你的圆变成闭环了，PathMeasure 找不到开始点，用了默认的。你把360度改成359.9让他不是一个闭环的圆就行了。 第二阶段，两个点在圆里面弹射 看起来好像还要干什么碰撞反弹之类的事，一副高科技的样子，其实不是的。 轨迹就是两个三角形，怎么让两条线跟着三角形走呢，而且走的时候还要不段变化长度。 刚刚第一步我们用 ValueAnimator 来控制一个圆从0到100%的过程， pathMeasure.getSegment(0, distance * pathMeasure.getLength(), drawPath, true); 不断截取起点到*%长度的 path 赋值给drawPath。 从里是从起点开始截取，那么我们不从起点开始截取，从当前点附近开始截取不就行了吗，哈哈哈哈~so easy 123float stopD = distance * pathMeasure.getLength();float startD = stopD - (0.5f - Math.abs(0.5f - distance)) * 200;pathMeasure.getSegment(startD, stopD, drawPath, true); 第三阶段绘制两个三角形 其实两个三角形就是第二步的运动轨迹，也是就是说直接用第阶段的 Path 即可，然后再用第一阶段一样的办法就可以实现效果。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206public class GranzortView extends View &#123; private Paint paint; private Path innerCircle;//内圆 path private Path outerCircle;//外圆 path private Path trangle1; //第一个三角形的path private Path trangle2; //第二个三角形的path private Path drawPath; //用于截取路径的path private PathMeasure pathMeasure; private float mViewWidth; private float mViewHeight; private long duration = 3000; private ValueAnimator valueAnimator; private Handler mHandler; private float distance;//当前动画执行的百分比取值为0~1 private ValueAnimator.AnimatorUpdateListener animatorUpdateListener; private Animator.AnimatorListener animatorListener; private State mCurrentState = State.CIRCLE_STATE; public GranzortView(Context context) &#123; this(context,null); &#125; public GranzortView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs,0); &#125; public GranzortView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; //三个阶段的枚举 private enum State &#123; CIRCLE_STATE, TRANGLE_STATE, FINISH_STATE &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mViewWidth = w; mViewHeight = h; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(getResources().getColor(R.color.colorPrimary)); canvas.save(); canvas.translate(mViewWidth / 2, mViewHeight / 2); switch (mCurrentState)&#123; case CIRCLE_STATE: drawPath.reset(); pathMeasure.setPath(innerCircle,false); pathMeasure.getSegment(0,distance * pathMeasure.getLength(),drawPath,true); canvas.drawPath(drawPath,paint); pathMeasure.setPath(outerCircle,false); drawPath.reset(); pathMeasure.getSegment(0,distance * pathMeasure.getLength(),drawPath,true); canvas.drawPath(drawPath,paint); break; case TRANGLE_STATE: canvas.drawPath(innerCircle,paint); canvas.drawPath(outerCircle,paint); drawPath.reset(); pathMeasure.setPath(trangle1,false); float stopD = distance * pathMeasure.getLength(); float startD = stopD - (0.5f - Math.abs(0.5f - distance)) * 200; pathMeasure.getSegment(startD,stopD,drawPath,true); canvas.drawPath(drawPath,paint); drawPath.reset(); pathMeasure.setPath(trangle2,false); pathMeasure.getSegment(startD,stopD,drawPath,true); canvas.drawPath(drawPath,paint); break; case FINISH_STATE: canvas.drawPath(innerCircle,paint); canvas.drawPath(outerCircle,paint); drawPath.reset(); pathMeasure.setPath(trangle1,false); pathMeasure.getSegment(0, distance * pathMeasure.getLength(),drawPath,true); canvas.drawPath(drawPath,paint); drawPath.reset(); pathMeasure.setPath(trangle2,false); pathMeasure.getSegment(0,distance*pathMeasure.getLength(),drawPath,true); canvas.drawPath(drawPath,paint); break; &#125; canvas.restore(); &#125; private void init()&#123; initPaint(); initPath(); initHandler(); initAnimatorListener(); initAnimator(); mCurrentState = State.CIRCLE_STATE; valueAnimator.start(); &#125; private void initHandler()&#123; mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (mCurrentState)&#123; case CIRCLE_STATE: mCurrentState = State.TRANGLE_STATE; valueAnimator.start(); break; case TRANGLE_STATE: mCurrentState = State.FINISH_STATE; valueAnimator.start(); break; &#125; &#125; &#125;; &#125; private void initAnimatorListener()&#123; animatorUpdateListener = new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; distance = animation.getAnimatedValue(); invalidate(); &#125; &#125;; animatorListener = new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; Log.e("start",mCurrentState + "_"); &#125; @Override public void onAnimationEnd(Animator animation) &#123; Log.e("end",mCurrentState+"_"); mHandler.sendEmptyMessage(0); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125; &#125; private void initAnimator()&#123; valueAnimator = ValueAnimator.ofFloat(0,1).setDuration(duration); valueAnimator.addUpdateListener(animatorUpdateListener); valueAnimator.addListener(animatorListener); &#125; private void initPath()&#123; innerCircle = new Path(); outerCircle = new Path(); trangle1 = new Path(); trangle2 = new Path(); drawPath = new Path(); pathMeasure = new PathMeasure(); RectF innerRect = new RectF(-220,-220,220,220); RectF outerRect = new RectF(-280,-280,280,280); innerCircle.addArc(innerRect,150,-359.9f);//不能取360f，否则可能造成测量到的值不准确 outerCircle.addArc(outerRect,60,-359.9f); pathMeasure.setPath(innerCircle,false); float[] pos = new float[2]; pathMeasure.getPosTan(0,pos,null);//获取开始位置的坐标 trangle1.moveTo(pos[0],pos[1]); pathMeasure.getPosTan((1f / 3f) * pathMeasure.getLength(),pos,null); trangle1.lineTo(pos[0],pos[1]); pathMeasure.getPosTan((2f / 3f)*pathMeasure.getLength(),pos,null); trangle1.lineTo(pos[0],pos[1]); trangle1.close(); pathMeasure.getPosTan((2f / 3f) * pathMeasure.getLength(),pos,null); Matrix matrix = new Matrix(); matrix.postRotate(-180); trangle1.transform(matrix,trangle2); &#125; private void initPaint()&#123; paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setColor(Color.WHITE); paint.setStyle(Paint.Style.STROKE); paint.setStrokeWidth(10); paint.setStrokeCap(Paint.Cap.ROUND); paint.setStrokeJoin(Paint.Join.BEVEL); paint.setShadowLayer(15,0,0,Color.WHITE);//白色光影效果 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-最适合使用RxJava处理的四种场景]]></title>
      <url>%2F2017%2F10%2F31%2Fandroid-four-rxjava%2F</url>
      <content type="text"><![CDATA[前言RxJava是非常热门的函数响应式编程库，在Android开发中已经非常流行了，刚开始上手会有点难，但只要理解了它，就再也回不去了；不使用RxJava写异步请求的话，就感觉各种不爽。 本文不准备讲RxJava的基础知识，如果你对RxJava不熟悉，这里有篇不错的教程可以参考《给 Android 开发者的 RxJava 详解》。 下面我们开始介绍RxJava最适合使用的四种场景，代码示例基于RxJava1 场景一： 单请求异步处理由于在Android UI线程中不能做一些耗时操作，比如网络请求，大文件保存等，所以在开发中经常会碰到异步处理的情况，我们最典型的使用场景是RxJava+Retrofit处理网络请求 12345MyService myService = retrofit.create(MyService.class);myService.getSomething() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::updateUI, this::showError); 为了使代码看起来简洁点，这边还使用了lambda表达式，updateUI和showError需要在当前类中实现，比如： 1234567public void updateUI(Data data)&#123; //TODO something&#125;public void showError(throwable t)&#123; //show error msg&#125; 场景二： 多异步请求连续调用这种场景其实也很常见，我们做用户头像编辑的使用，一般就会有三个请求需要连续调用： 请求头像上传的地址 上传头像 更新用户信息 在平时的代码里，我们需要一步步callback嵌套下来，代码冗长太难看，而且不好维护，使用RxJava链式调用处理代码逻辑就会非常清晰 1234567MyService myService = retrofit.create(MyService.class);myService.getUploadUrl() .flatMap(this::uploadImageTask) .flatMap(this::updateUserInfo) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::updateUI, this::showError); 先获取请求，再上传头像，最后更新用户信息，后面的任务依赖上一步的处理结果，依次执行。 场景三： 多异步请求合并处理有时候在项目中，我们会碰到组合多个请求的结果后，再更新UI的情况，比如我们项目中就有一个从多个请求地址获取通知数据，然后在APP上再按时间顺序组合后展示的需求，这时候我们就可以用RxJava的zip函数来处理了 123456789101112MyService myService = retrofit.create(MyService.class);Observable o1 = myService.getNotification1();Observable o2 = myService.getNotification2();Observable.zip(o1,o2, this::combiNotification) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(this::updateUI, this::showError);public List&lt;Notification&gt; combiNotification(List&lt;Notification&gt; n1, List&lt;Notification&gt; n2)&#123; //TODO 合并通知列表&#125; zip函数会等待两个请求都完成后，调用我们的合并方法combiNotification，等合并处理后再回调subscribe中的方法。 场景四： 定时轮询RxJava还特别适合对定时轮询任务的处理， 一种典型的例子就是APP提交了一个任务给后台异步处理，假设后台处理需要1-2分钟左右，我们需要定时到后台查询进度，并更新到UI上, 传统的做法是用Handler的postDelay方法，用RxJava实现的话就会非常简洁 1234567891011121314151617181920Subscription subscription = Observable.interval(2, TimeUnit.SECONDS) .map(this::getProgress) .takeUntil(progress -&gt; progress != 100) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;Long&gt;() &#123; @Override public void onCompleted() &#123; //TODO finished &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(int progress) &#123; //TODO update progress &#125; &#125;); 我们以定时2秒查询一次，直到进度progress=100为止，自动终止轮询。以上各种RxJava方法都是异步耗时调用，考虑到Activity的退出时请求还没有完成，我们需要在Activity的OnDestroy方法中取消RxJava调用subscription.unsubscribe();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-视频播放器开发]]></title>
      <url>%2F2017%2F10%2F31%2Fandroid-video-player%2F</url>
      <content type="text"><![CDATA[android中在实际的视频开发中多用即成的框架,或者自己封装相关的Manager来实现;下面介绍一个简单的android视频开发的过程: 实现网络和本地视频播放 点击控制播放,暂停 支持进度条的拖动,实时跟新进度,时间 支持横竖屏切换 在横屏状态下,音量键显示并且可调节 支持手势触摸,即:上下滑动左半屏,弹出dialog,控制屏幕亮度,并且显示进度条;上下滑动右半屏,弹出dialog,控制声音大小,并且显示进度条; First首先demo是基于videoView为基础,当然简单的开发,没有过多要求可以用原生的控制器可以可以解决,在这里控制都是自定义;首先为保证横竖屏幕的宽高不适配,需要自定义vieoView重写测量方法: 123456789101112131415161718192021public class AlpshVideo extends VideoView &#123; public AlpshVideo(Context context) &#123; super(context); &#125; public AlpshVideo(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public AlpshVideo(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //我们重新计算高度 int width = getDefaultSize(0, widthMeasureSpec); int height = getDefaultSize(0, heightMeasureSpec); setMeasuredDimension(width, height); &#125;&#125; 接着xml中嵌入自定义的vieoView: 12345&lt;com.example.video.customView.AlpshVideo android:id=&quot;@+id/videoView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;240dp&quot; /&gt; 在MainActivity中加载本地或者网络视频: 123456 //加载本地mVideoView.setVideoPath(&quot;android.resource://&quot;+getPackageName()+&quot;/&quot;+R.raw.welcome);mVideoView.start();//加载网络url//mVideoView.setVideoURI(Uri.parse(&quot;xxxx&quot;)); 我们这里以本地为例;ok这样videoView就可以开始比方视频; 自定义控制器—-&gt;布局接下来看代码,xml比较简单,仅展示代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;FrameLayout android:id=&quot;@+id/fr_video&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;240dp&quot;&gt; &lt;com.example.video.customView.AlpshVideo android:id=&quot;@+id/videoView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;240dp&quot; /&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_gravity=&quot;bottom&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot;&gt; &lt;SeekBar android:id=&quot;@+id/media_progress&quot; android:thumb=&quot;@null&quot; android:progressDrawable=&quot;@drawable/seekbar_style2&quot; android:max=&quot;100&quot; android:progress=&quot;20&quot; android:indeterminate=&quot;false&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;5dp&quot; android:layout_marginLeft=&quot;-20dp&quot; android:layout_marginRight=&quot;-20dp&quot;/&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#101010&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/media_actions&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_width=&quot;20dp&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@drawable/stop_btn&quot;/&gt; &lt;TextView android:id=&quot;@+id/media_time&quot; android:layout_marginLeft=&quot;30dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;00:00:00&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;TextView android:layout_marginLeft=&quot;5dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;/&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;TextView android:id=&quot;@+id/media_total_time&quot; android:layout_marginLeft=&quot;5dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;00:00:00&quot; android:textColor=&quot;#fff&quot; android:textSize=&quot;12sp&quot;/&gt; &lt;ImageView android:id=&quot;@+id/media_sounds&quot; android:visibility=&quot;gone&quot; android:layout_marginLeft=&quot;100dp&quot; android:layout_width=&quot;20dp&quot; android:layout_height=&quot;match_parent&quot; android:src=&quot;@drawable/icon_sounds&quot;/&gt; &lt;SeekBar android:visibility=&quot;gone&quot; android:id=&quot;@+id/media_sounds_progress&quot; android:thumb=&quot;@null&quot; android:progressDrawable=&quot;@drawable/seekbar_style&quot; android:max=&quot;100&quot; android:progress=&quot;20&quot; android:indeterminate=&quot;false&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;5dp&quot; android:layout_marginLeft=&quot;-10dp&quot; /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=&quot;@+id/media_full_screen&quot; android:layout_marginRight=&quot;15dp&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:layout_width=&quot;20dp&quot; android:layout_height=&quot;20dp&quot; android:src=&quot;@drawable/ic_full_screen&quot;/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot;&gt; &lt;include layout=&quot;@layout/dialog&quot; android:visibility=&quot;gone&quot;/&gt; &lt;/LinearLayout&gt; &lt;/FrameLayout&gt;&lt;/RelativeLayout&gt; 控制器中播放暂停按钮的实现初始化音量进度条: 1234567//获取音频管理器mAudioManager = (AudioManager) getSystemService(AUDIO_SERVICE);int streamMaxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);int streamVolume = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);mMediaSoundsProgress.setMax(streamMaxVolume);mMediaSoundsProgress.setProgress(streamVolume); 点击事件的普片切换比较简单,通过按钮的图形化切换来控制videoView的开始和暂停:在播放过程中要实时更新播放时间和进度,这里用handler来实现: 12345678910111213141516private void setPlayer() &#123; mMediaActions.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (mVideoView.isPlaying())&#123; mMediaActions.setImageResource(R.drawable.play_btn); mVideoView.pause(); mHandler.removeMessages(UpDate); &#125;else &#123; mMediaActions.setImageResource(R.drawable.stop_btn); mVideoView.start(); mHandler.sendEmptyMessage(UpDate); &#125; &#125; &#125;);&#125; 在上面代码中看到,由播放状态改变为暂停状态,实时跟新的hanler停止,切换为播放再次开启;下面看下线程中实时更新的代码: 123456789101112131415161718192021private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if (msg.what == UpDate)&#123; //当前时间 int currentPosition = mVideoView.getCurrentPosition(); //总时间 int duration = mVideoView.getDuration(); //设置时间 updateTime(mMediaTime,currentPosition); updateTime(mMediaTotalTime,duration); //设置进度 mMediaProgress.setMax(duration); mMediaProgress.setProgress(currentPosition); mHandler.sendEmptyMessageDelayed(UpDate,500); &#125; &#125;&#125;; 到这一步,视频可以播放,播放进度条实时跟新,播放时间可以实时更新; 当然在一个视频播放器中,必须实现进度条的拖动来实现进度的控制(就是快进和快退);那么需要监听播放进度条的拖动事件: private void setScrollSeek() { //播放器的进度条监听 mMediaProgress.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() { @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean b) { updateTime(mMediaTime,progress); } @Override public void onStartTrackingTouch(SeekBar seekBar) { mHandler.removeMessages(UpDate); } @Override public void onStopTrackingTouch(SeekBar seekBar) { int progress = seekBar.getProgress(); mVideoView.seekTo(progress); mHandler.sendEmptyMessage(UpDate); } }); 横竖屏切换;VideoView重新测量手机翻转然后横竖屏自由切换,当然在第一步中有提到自定义videoView重新测量,也是为了横竖屏切换时候做准备,防止半屏显示不全的出现:首先在清单文件中配置:(而且切换横屏之后音量键开始显示) 123456789&lt;activity android:configChanges=&quot;orientation|screenSize|keyboard|keyboardHidden&quot; android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 这样设置之后可以全屏,但是videoView并不可以适配,所以需要MainActivity中重写onConfigurationChanged: 12345678910111213141516171819202122232425@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); //当为横屏时候 if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE)&#123; setConfigWh(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT); isFull = true; //音量键的显示 mMediaSounds.setVisibility(View.VISIBLE); mMediaSoundsProgress.setVisibility(View.VISIBLE); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN); getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN); &#125;else&#123; //当为竖屏时候 setConfigWh(ViewGroup.LayoutParams.MATCH_PARENT, DensityUtil.dp2px(this,240)); isFull = false; mMediaSounds.setVisibility(View.GONE); mMediaSoundsProgress.setVisibility(View.GONE); getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN); getWindow().addFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN); &#125;&#125; 全屏在竖屏状态下,点击右下角的全屏按钮 也会显示横屏,所以需要设置其点击事件: 1234567891011121314151617private void setFullScreen() &#123; //设置全屏播放 mMediaFullScreen.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (isFull)&#123; //此时是全屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); &#125;else &#123; //此时是半屏 setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE); &#125; &#125; &#125;);&#125; 当这里横竖屏切换和适配就可以正常显示了 音量显示切换到横屏之后音量键显示,则需要显示器控制音量的功能: 123456789101112131415//声音调节进度条mMediaSoundsProgress.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean b) &#123; mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC,progress,0); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125;&#125;); 当这里一个简单的播放器基本完备 手势接下来来添加手势 大概策略是这样:横屏状态下(需要添加boolean判断来限定横屏之下触发):当上下滑动屏幕左半边,亮度改变,弹出一个类似dialog显示连读进度条的改变,结束触摸,则弹窗消失;当上下滑动屏幕右半边,声音改变,弹出一个类似dialog显示连读进度条的改变,结束触摸,则弹窗消失,在这个过程中控制台区域的声音进度条也会实时改变; 手势添加先来看手势的添加: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private void setScrollScreen() &#123; mVideoView.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent event) &#123; float x = event.getX(); float y = event.getY(); switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: lastX = x; lastY = y; break; case MotionEvent.ACTION_MOVE: //获取屏幕宽和高 widthPixels = getResources().getDisplayMetrics().widthPixels; heightPixels = getResources().getDisplayMetrics().heightPixels; //偏移量的记录 float dx = x - lastX; float dy = y - lastY; float absX = Math.abs(dx); float absY = Math.abs(dy); if (absX &gt; trueshold &amp;&amp; absY &gt; trueshold)&#123; if (absX &gt;= absY)&#123; isadjust = false; &#125;else if (absY &gt; absX)&#123; isadjust = true; &#125; &#125;else if (absX &gt;= trueshold &amp;&amp; absY &lt; trueshold)&#123; isadjust = false; &#125;else if(absX &lt; trueshold &amp;&amp; absY &gt;= trueshold)&#123; isadjust = true; &#125; //开始判断 音量调节 和 亮度调节 if (isadjust)&#123; //Log.i("==widthPixels",x + ""); if (x &gt; widthPixels/2)&#123; //声音 if (dy &gt; 0)&#123; //降低声音 &#125;else &#123; //增大声音 &#125; //改变声音 changeVoice(-dy); &#125;else if(x &lt; widthPixels/2)&#123; //亮度 if (dy &gt; 0)&#123; //降低亮度 //Log.i("==降低亮度",dy + ""); &#125;else &#123; //增大亮度 //Log.i("==增大亮度",dy + ""); &#125; //改变亮度 changeBrightness(-dy); &#125; &#125; lastX = x; lastY = y; break; case MotionEvent.ACTION_UP: mDialogLl.setVisibility(View.GONE); break; &#125; return true; &#125; &#125;);&#125; 就是一个onTouch的触摸事件,首先判断手势是否合法,规定一个偏移量,当,当dx dy全部超过偏移量,dy&gt;dx 手势触发 isadjust = true;当dx&lt;偏移量,dy大于偏移量手势触发 isadjust = true;触发之后判断 当x &gt; widthPixels/2,在屏幕右半边,触发音量控制当当x &lt; widthPixels/2,在屏幕左半边,触发屏幕亮度控制 ok~接下来看屏幕亮度变化的代码: 123456789101112131415161718192021222324//控制亮度public void changeBrightness(float absY)&#123; mDialogLl.setVisibility(View.VISIBLE); WindowManager.LayoutParams attributes = getWindow().getAttributes(); mScreenBrightness = attributes.screenBrightness; float index = absY / heightPixels; mScreenBrightness += index; //进行判断 if (mScreenBrightness &gt; 1.0f)&#123; mScreenBrightness = 1.0f; &#125;else if (mScreenBrightness &lt; 0.01f)&#123; mScreenBrightness = 0.01f; &#125; attributes.screenBrightness = mScreenBrightness; getWindow().setAttributes(attributes); //设置弹窗 mDialogPic.setImageResource(R.drawable.icon_media_screen); mDialogProgress.setMax(10); mDialogProgress.setProgress((int)(mScreenBrightness * 10)); Log.i("==mScreenBrightness",mScreenBrightness * 100 + "");&#125; 声音变化的代码: 123456789101112131415161718//控制声音public void changeVoice(float absY)&#123; mDialogLl.setVisibility(View.VISIBLE); int maxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC); int volume = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC); int dVoice = (int) (absY / heightPixels * maxVolume * 3); int max = Math.max(dVoice + volume, 0); //设置声音 mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC,max,0); mMediaSoundsProgress.setProgress(max); //设置弹窗 mDialogPic.setImageResource(R.drawable.icon_media_sounds); mDialogProgress.setMax(maxVolume); mDialogProgress.setProgress(max);&#125; 这样就实现声音,屏幕亮度和手势的交互;当然不要忘了结束触摸要隐藏dialog窗口: 123case MotionEvent.ACTION_UP: mDialogLl.setVisibility(View.GONE); break; 到此为止,一个横竖屏切换自如,快进快退可实现,手势和声音,屏幕亮度可以实时交互,播放信息实时更新的android播放器就完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-高级UI特效之炫酷漂浮动画—一个能让View执行漂浮的库]]></title>
      <url>%2F2017%2F10%2F30%2Fandroid-floatingview%2F</url>
      <content type="text"><![CDATA[FloatingView-android能够让View执行漂亮的漂浮动画的库 使用Step 1在 build.gradle 文件中添加库依赖 123dependencies &#123; compile &apos;com.ufreedom.uikit:FloatingViewLib:1.0.2&apos;&#125; Step 2使用 FloatingBuilder 创建一个 FloatingElement 1234567FloatingElement builder = new FloatingBuilder() .anchorView(View) .targetView(View) .offsetX(int) .offsetY(int) .floatingTransition(FloatingTransition) .build(); 使用 FloatingBuilder 可以设置的有 anchorView ：锚点，也就是你想在哪个 View 上面进行漂浮动画 target：目标，你想漂浮的 View offsetX：x 方向的偏移量，单位 px offsetY: y 方向的偏移量，单位 px floatingTransition : 漂浮效果，默认是 ScaleFloatingTransition，也可以自己实现漂浮效果 Step 3创建一个 FloatingView 作为 FloatingElement 的容器,然后让你的 View 飞起来 12Floating floating = new Floating(getActivity()); floating.startFloating(builder); 自定义坐标系 图类 漂浮动画实现漂浮动画很简单，你只需要实现 FloatingTransition 接口就可以 123public interface FloatingTransition &#123; public void applyFloating(YumFloating yumFloating); &#125; 在applyFloating方法，你可以使用 Android Animation 创建动画，然后使用 YumFloating 进行 Alpha,Scale,Translate,Rotate 等变换如果你想加入 Facebook Rebound 回弹动画效果，你可以使用 SpringHelper,例如 ScaleFloatingTransition: 12345678910111213141516171819202122232425public class ScaleFloatingTransition implements FloatingTransition &#123;...@Overridepublic void applyFloating(final YumFloating yumFloating) &#123; ValueAnimator alphaAnimator = ObjectAnimator.ofFloat(1.0f, 0.0f); alphaAnimator.setDuration(duration); alphaAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; yumFloating.setAlpha((Float) valueAnimator.getAnimatedValue()); &#125; &#125;); alphaAnimator.start(); SpringHelper.createWidthBouncinessAndSpeed(0.0f, 1.0f,bounciness, speed) .reboundListener(new SimpleReboundListener()&#123; @Override public void onReboundUpdate(double currentValue) &#123; yumFloating.setScaleX((float) currentValue); yumFloating.setScaleY((float) currentValue); &#125; &#125;).start(yumFloating);&#125;&#125; 如果 SpringHelper 无法满足你的需求，你可以直接使用 YumFloating 的createSpringByBouncinessAndSpeed(double bounciness, double speed)或者createSpringByTensionAndFriction(double tension, double friction)创建 Spring, 然后使用transition(double progress, float startValue, float endValue)进行数值转换 路径漂浮动画实现路径漂浮同样很简单，例如 CurveFloatingPathTransition ,首先你需要继承 BaseFloatingPathTransition 类.和继承 FloatingTransition 类不同的是，你需要再实现一个getFloatingPath()方法.在getFloatingPath()方法内使用Path创建你想漂浮的路径，然后调用FloatingPath.create(path, false)进行返回. 例如 CurveFloatingPathTransition 实现： 12345678910111213141516171819202122232425262728293031323334public class CurveFloatingPathTransition extends BaseFloatingPathTransition &#123; ... @Override public FloatingPath getFloatingPath() &#123; if (path == null)&#123; path = new Path(); path.moveTo(0, 0); path.quadTo(-100, -200, 0, -300); path.quadTo(200, -400, 0, -500); &#125; return FloatingPath.create(path, false); &#125; @Override public void applyFloating(final YumFloating yumFloating) &#123; ValueAnimator translateAnimator; ValueAnimator alphaAnimator; translateAnimator = ObjectAnimator.ofFloat(getStartPathPosition(), getEndPathPosition()); translateAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator valueAnimator) &#123; float value = (float) valueAnimator.getAnimatedValue(); PathPosition floatingPosition = getFloatingPosition(value); yumFloating.setTranslationX(floatingPosition.x); yumFloating.setTranslationY(floatingPosition.y); &#125; &#125;); ... &#125;&#125; 使用 Path 将你想要漂浮的路径的描绘出来，然后在 applyFloating(final YumFloating yumFloating) 方法中: 使用 getStartPathPosition() 方法获取路径的开始位置 使用 getEndPathPosition()方法获取路径的结束位置 使用 getFloatingPosition(float progress) 获取当前进度的位置 getFloatingPosition(float progress) 方法会返回一个 PathPosition 对象，其属性 x,y 分别代表当前路径动画的 x 坐标，和 y 坐标. 设计思想对于开源库来说，易用，扩展性强，非常重要， FloatingView 正在努力朝这方面发展 项目地址为:github.com/UFreedom/Fl…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-RecyclerViewItemDecoration的进阶使用]]></title>
      <url>%2F2017%2F10%2F29%2Fandroid-recyclerview-itemdecoration%2F</url>
      <content type="text"><![CDATA[ItemDecoration实现padding ItemDecoration实现下划线 ItemDecoration实现酷炫吸顶效果 ItemDecoration实现item的拖拽，平移等操作 ItemDecorationItemDecoration是RecyclerView内部的一个抽象类，要实现这个抽象类自然需要实现内部的抽象方法，除了deprecated的方法只有下面三个方法： 123456//可以实现类似padding的效果public void onDraw(Canvas c, RecyclerView parent, State state) //可以实现类似绘制背景的效果，内容在上面public void onDrawOver(Canvas c, RecyclerView parent, State state) //可以绘制在内容的上面，覆盖内容public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) 声明下：ItemDecoration的使用必须在setAdapter前，通过recyclerView.addItemDecoration()方法设置 下面讲解ItemDecoration实现的功能ItemDecoration实现padding12345678910111213141516171819 public class PaddingDecoration extends RecyclerView.ItemDecoration&#123; private int padding; public PaddingDecoration(Context context) &#123; //即你要设置的分割线的宽度 --这里设为10dp padding = context.getResources().getDimensionPixelSize(R.dimen.padding); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); //outRect就是你那个item条目的矩形 outRect.left = padding; //相当于 设置 left padding outRect.top = padding; //相当于 设置 top padding outRect.right = padding; //相当于 设置 right padding outRect.bottom = padding; //相当于 设置 bottom padding &#125;&#125; ItemDecoration实现下划线123456789101112131415161718192021222324252627282930313233343536373839 public class DeviderDecoration extends RecyclerView.ItemDecoration &#123; private int deviderHeight; private Paint dividerPaint; public DeviderDecoration(Context context) &#123; //设置画笔 dividerPaint = new Paint(); //设置分割线颜色 dividerPaint.setColor(context.getResources().getColor(R.color.colorAccent)); //设置分割线宽度 deviderHeight = context.getResources().getDimensionPixelSize(R.dimen.divider_height); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); //改变宽度 outRect.bottom = deviderHeight; &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; //得到列表所有的条目 int childCount = parent.getChildCount(); //得到条目的宽和高 int left = parent.getPaddingLeft(); int right = parent.getWidth() - parent.getPaddingRight(); for (int i = 0; i &lt; childCount - 1; i++) &#123; View view = parent.getChildAt(i); //计算每一个条目的顶点和底部 float值 float top = view.getBottom(); float bottom = view.getBottom() + deviderHeight; //重新绘制 c.drawRect(left, top, right, bottom, dividerPaint); &#125; &#125;&#125; ItemDecoration实现酷炫吸顶效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157 public class SectionDecoration extends RecyclerView.ItemDecoration &#123; private List&lt;String&gt; dataList; private DecorationCallback callback; private TextPaint textPaint; private Paint paint; private int topGap; private int alignBottom; private Paint.FontMetrics fontMetrics; public SectionDecoration(List&lt;String&gt; dataList, Context context, DecorationCallback decorationCallback) &#123; Resources res = context.getResources(); this.dataList = dataList; this.callback = decorationCallback; //设置悬浮栏的画笔---paint paint = new Paint(); paint.setColor(res.getColor(R.color.colorGray)); //设置悬浮栏中文本的画笔 textPaint = new TextPaint(); textPaint.setAntiAlias(true); textPaint.setTextSize(DensityUtil.dip2px(context, 14)); textPaint.setColor(Color.DKGRAY); textPaint.setTextAlign(Paint.Align.LEFT); fontMetrics = new Paint.FontMetrics(); //决定悬浮栏的高度等 topGap = res.getDimensionPixelSize(R.dimen.sectioned_top); //决定文本的显示位置等 alignBottom = res.getDimensionPixelSize(R.dimen.sectioned_alignBottom); &#125; //图1：代表了getItemOffsets(),可以实现类似padding的效果 @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); int pos = parent.getChildAdapterPosition(view); String groupId = callback.getGroupId(pos); if (groupId.equals("-1")) return; //只有是同一组的第一个才显示悬浮栏 if (pos == 0 || isFirstInGroup(pos)) &#123; outRect.top = topGap; if (dataList.get(pos) == "") &#123; outRect.top = 0; &#125; &#125; else &#123; outRect.top = 0; &#125; &#125; //图2：代表了onDraw(),可以实现类似绘制背景的效果，内容在上面 @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); int left = parent.getPaddingLeft(); int right = parent.getWidth() - parent.getPaddingRight(); int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View view = parent.getChildAt(i); int position = parent.getChildAdapterPosition(view); String groupId = callback.getGroupId(position); if (groupId.equals("-1")) return; String textLine = callback.getGroupFirstLine(position).toUpperCase(); if (textLine == "") &#123; float top = view.getTop(); float bottom = view.getTop(); c.drawRect(left, top, right, bottom, paint); return; &#125; else &#123; if (position == 0 || isFirstInGroup(position)) &#123; float top = view.getTop() - topGap; float bottom = view.getTop(); //绘制悬浮栏 c.drawRect(left, top, right, bottom, paint); //绘制文本 c.drawText(textLine, left, bottom, textPaint); &#125; &#125; &#125; &#125; //图3：代表了onDrawOver()，可以绘制在内容的上面，覆盖内容 @Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state); int itemCount = state.getItemCount(); int childCount = parent.getChildCount(); int left = parent.getPaddingLeft(); int right = parent.getWidth() - parent.getPaddingRight(); float lineHeight = textPaint.getTextSize() + fontMetrics.descent; String preGroupId = ""; String groupId = "-1"; for (int i = 0; i &lt; childCount; i++) &#123; View view = parent.getChildAt(i); int position = parent.getChildAdapterPosition(view); preGroupId = groupId; groupId = callback.getGroupId(position); if (groupId.equals("-1") || groupId.equals(preGroupId)) continue; String textLine = callback.getGroupFirstLine(position).toUpperCase(); if (TextUtils.isEmpty(textLine)) continue; int viewBottom = view.getBottom(); float textY = Math.max(topGap, view.getTop()); //下一个和当前不一样移动当前 if (position + 1 &lt; itemCount) &#123; String nextGroupId = callback.getGroupId(position + 1); //组内最后一个view进入了header if (nextGroupId != groupId &amp;&amp; viewBottom &lt; textY) &#123; textY = viewBottom; &#125; &#125; //textY - topGap决定了悬浮栏绘制的高度和位置 c.drawRect(left, textY - topGap, right, textY, paint); //left+2*alignBottom 决定了文本往左偏移的多少（加--&gt;向左移） //textY-alignBottom 决定了文本往右偏移的多少 (减--&gt;向上移)// c.drawText(textLine, left + 2 * alignBottom, textY - alignBottom, textPaint); c.drawText(textLine, left, textY - alignBottom, textPaint); &#125; &#125; /** * 判断是不是组中的第一个位置 * * @param pos * @return */ private boolean isFirstInGroup(int pos) &#123; if (pos == 0) &#123; return true; &#125; else &#123; // 因为是根据 字符串内容的相同与否 来判断是不是同意组的，所以此处的标记id 要是String类型 // 如果你只是做联系人列表，悬浮框里显示的只是一个字母，则标记id直接用 int 类型就行了 String prevGroupId = callback.getGroupId(pos - 1); String groupId = callback.getGroupId(pos); //判断前一个字符串 与 当前字符串 是否相同 if (prevGroupId.equals(groupId)) &#123; return false; &#125; else &#123; return true; &#125; &#125; &#125; //定义一个借口方便外界的调用 public interface DecorationCallback &#123; String getGroupId(int position); String getGroupFirstLine(int position); &#125;&#125; 使用 1234567891011121314151617textRecycler.addItemDecoration(new SectionDecoration(list, this, new SectionDecoration.DecorationCallback() &#123; @Override public String getGroupId(int position) &#123; if(NameBean.get(position)!=null) &#123; return NameBean.get(position); &#125; return "-1"; &#125; @Override public String getGroupFirstLine(int position) &#123; if(NameBean.get(position)!=null) &#123; return NameBean.get(position); &#125; return ""; &#125; &#125;)); ItemDecoration实现item的拖拽，平移等操作（穿插还通过OnItemTouchListener封装了列表的点击和长点击事件） item的点击事件和长点击事件 该功能主要通过addOnItemTouchListener() 来实现。 123456789101112131415textRecycler.addOnItemTouchListener(new OnRecyclerItemClickListener(textRecycler) &#123; @Override public void onItemClick(RecyclerView.ViewHolder viewHolder) &#123; ToastUtils.showToast(viewHolder.getAdapterPosition()+1+""); &#125; @Override public void onLongClick(RecyclerView.ViewHolder viewHolder) &#123; ToastUtils.showToast(viewHolder.getAdapterPosition()+1+""); //当 item 被长按且不是第一个时，开始拖曳这个 item if (viewHolder.getLayoutPosition() != 0) &#123; itemTouchHelper.startDrag(viewHolder); &#125; &#125; &#125;); 其中 OnRecyclerItemClickListener 是自定义的一个触摸监听器，代码如下： 12345678910111213141516171819202122232425262728293031 public abstract class OnRecyclerItemClickListener implements RecyclerView.OnItemTouchListener &#123; //手势探测器 private GestureDetectorCompat mGestureDetectorCompat; private RecyclerView mRecyclerView; public OnRecyclerItemClickListener(RecyclerView mRecyclerView) &#123; this.mRecyclerView = mRecyclerView; mGestureDetectorCompat = new GestureDetectorCompat(mRecyclerView.getContext(), new ItemTouchHelperGestureListener(mRecyclerView,this)); &#125; //第一个是拦截触摸事件的，第二个是处理触摸事件的，第三个是处理触摸冲突的。第三个这里我们用不到 @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123; mGestureDetectorCompat.onTouchEvent(e); return false; &#125; @Override public void onTouchEvent(RecyclerView rv, MotionEvent e) &#123; mGestureDetectorCompat.onTouchEvent(e); &#125; @Override public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; &#125; //提供单机 长按的方法 public abstract void onItemClick(RecyclerView.ViewHolder viewHolder); public abstract void onLongClick(RecyclerView.ViewHolder viewHolder);&#125; GestureDetectorCompat 中传入了一个 ItemTouchHelperGestureListener，代码如下： 12345678910111213141516171819202122232425262728293031public class ItemTouchHelperGestureListener extends GestureDetector.SimpleOnGestureListener &#123;private RecyclerView mRecyclerView;private OnRecyclerItemClickListener onRecyclerItemClickListener;public ItemTouchHelperGestureListener(RecyclerView mRecyclerView, OnRecyclerItemClickListener onRecyclerItemClickListener) &#123; this.mRecyclerView = mRecyclerView; this.onRecyclerItemClickListener = onRecyclerItemClickListener;&#125;//一次单独的轻触抬起手指操作，就是普通的点击事件@Overridepublic boolean onSingleTapUp(MotionEvent e) &#123; //这个ChildHelper类，它会协助获取RecyclerView中的childVIew。 可点击看源码 View childViewUnder = mRecyclerView.findChildViewUnder(e.getX(), e.getY()); if (childViewUnder != null) &#123; RecyclerView.ViewHolder childViewHolder = mRecyclerView.getChildViewHolder(childViewUnder); onRecyclerItemClickListener.onItemClick(childViewHolder); &#125; return true;&#125;//长按屏幕超过一定时长，就会触发，就是长按事件@Overridepublic void onLongPress(MotionEvent e) &#123; View childViewUnder = mRecyclerView.findChildViewUnder(e.getX(), e.getY()); if (childViewUnder != null) &#123; RecyclerView.ViewHolder childViewHolder = mRecyclerView.getChildViewHolder(childViewUnder); onRecyclerItemClickListener.onLongClick(childViewHolder); &#125;&#125; 其实通过一个手势探测器 GestureDetectorCompat 来探测屏幕事件，然后通过手势监听器 SimpleOnGestureListener 来识别手势事件的种类，然后调用我们设置的对应的回调方法。 通过findChildViewUnder()可以知道我们点击的是哪个item，可看源码 123456789101112131415 public View findChildViewUnder(float x, float y) &#123; final int count = mChildHelper.getChildCount(); for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = mChildHelper.getChildAt(i); final float translationX = ViewCompat.getTranslationX(child); final float translationY = ViewCompat.getTranslationY(child); if (x &gt;= child.getLeft() + translationX &amp;&amp; x &lt;= child.getRight() + translationX &amp;&amp; y &gt;= child.getTop() + translationY &amp;&amp; y &lt;= child.getBottom() + translationY) &#123; return child; &#125; &#125; return null;&#125; 同时我们调用 RecyclerView 的另一个方法 getChildViewHolder()，可以获得该 item 的 ViewHolder，最后再回调我们定义的虚方法 onItemClick() 就ok了，这样我们就可以在外部实现该方法来获得 item 的点击事件了。 ItemDecoration实现item的拖拽，平移等操作 ItemTouchHelper 一个帮助开发人员处理拖拽和滑动删除的实现类，它能够让你非常容易实现侧滑删除、拖拽的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 /** * Created by wen on 2017/8/8. * ItemTouchHelper 一个帮助开发人员处理拖拽和滑动删除的实现类，它能够让你非常容易实现侧滑删除、拖拽的功能。 */public class MyItemTouchHelper extends ItemTouchHelper.Callback &#123; RecyclerAdapter adapter; public MyItemTouchHelper(RecyclerAdapter adapter) &#123; this.adapter = adapter; &#125; //通过返回值来设置是否处理某次拖曳或者滑动事件 //dragFlags 是拖拽标志， //swipeFlags 是滑动标志， //swipeFlags 都设置为0，暂时不考虑滑动相关操作。 //getMovementFlags() 用于设置是否处理拖拽事件和滑动事件，以及拖拽和滑动操作的方向，有以下两种情况： //如果是列表类型的 RecyclerView，拖拽只有 UP、DOWN 两个方向 //如果是网格类型的则有 UP、DOWN、LEFT、RIGHT 四个方向 @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; if (recyclerView.getLayoutManager() instanceof GridLayoutManager) &#123; int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; int swipeFlags = 0; return makeMovementFlags(dragFlags, swipeFlags); &#125; else &#123; int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; //注意：和拖曳的区别就是在这里 int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END; return makeMovementFlags(dragFlags, swipeFlags); &#125; &#125; //当长按并进入拖曳状态时，拖曳的过程中不断的回调此方法 @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; //拖动的 item 的下标 int fromPosition = viewHolder.getAdapterPosition(); //目标 item 的下标，目标 item 就是当拖曳过程中，不断和拖动的 item 做位置交换的条目。 int toPosition = target.getAdapterPosition(); //对应某些需求，某一个item不能拖拽 if (toPosition == 0) &#123; return false; &#125; if (fromPosition &lt; toPosition) &#123; for (int i = fromPosition; i &lt; toPosition; i++) &#123; //通过你传入的adapter得到你的数据 并进行交换 Collections.swap(((RecyclerAdapter) adapter).getDataList(), i, i + 1); &#125; &#125; else &#123; for (int i = fromPosition; i &gt; toPosition; i--) &#123; Collections.swap(((RecyclerAdapter) adapter).getDataList(), i, i - 1); &#125; &#125; adapter.notifyItemMoved(fromPosition, toPosition); return true; &#125; //滑动删除的回调 @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; int adapterPosition = viewHolder.getAdapterPosition(); adapter.notifyItemRemoved(adapterPosition); ((RecyclerAdapter)adapter).getDataList().remove(adapterPosition); &#125; //当长按 item 刚开始拖曳的时候调用 @Override public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123; if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) &#123; //给被拖曳的 item 设置一个深颜色背景 viewHolder.itemView.setBackgroundColor(Color.LTGRAY); &#125; super.onSelectedChanged(viewHolder, actionState); &#125; //当完成拖曳手指松开的时候调用 @Override public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; super.clearView(recyclerView, viewHolder); //给已经完成拖曳的 item 恢复开始的背景。 // 这里我们设置的颜色尽量和你 item 在 xml 中设置的颜色保持一致 viewHolder.itemView.setBackgroundColor(Color.WHITE); &#125; //返回 false 让它控制所有的 item 都不能拖曳。 @Override public boolean isLongPressDragEnabled() &#123; return false; &#125;&#125; 使用 123456789101112131415161718itemTouchHelper = new ItemTouchHelper(new MyItemTouchHelper(adapter)); itemTouchHelper.attachToRecyclerView(textRecycler); textRecycler.addOnItemTouchListener(new OnRecyclerItemClickListener(textRecycler) &#123; @Override public void onItemClick(RecyclerView.ViewHolder viewHolder) &#123; ToastUtils.showToast(viewHolder.getAdapterPosition()+1+""); &#125; @Override public void onLongClick(RecyclerView.ViewHolder viewHolder) &#123; ToastUtils.showToast(viewHolder.getAdapterPosition()+1+""); //当 item 被长按且不是第一个时，开始拖曳这个 item（这里只是一个特殊需求） if (viewHolder.getLayoutPosition() != 0) &#123; itemTouchHelper.startDrag(viewHolder); &#125; &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-事件分发机制详解：史上最全面、最易懂]]></title>
      <url>%2F2017%2F10%2F28%2Fandroid-view-distribute%2F</url>
      <content type="text"><![CDATA[前言 Android事件分发机制是Android开发者必须了解的基础 网上有大量关于Android事件分发机制的文章，但存在一些问题：内容不全、思路不清晰、无源码分析、简单问题复杂化等等 今天，我将全面总结Android的事件分发机制，我能保证这是市面上的最全面、最清晰、最易懂的 本文秉着“结论先行、详细分析在后”的原则，即先让大家感性认识，再通过理性分析从而理解问题；所以，请各位读者先记住结论，再往下继续看分析； 目录 基础认知事件分发的对象是谁？答：事件 当用户触摸屏幕时（View或ViewGroup派生的控件），将产生点击事件（Touch事件）。 Touch事件相关细节（发生触摸的位置、时间、历史记录、手势动作等）被封装成MotionEvent对象 主要发生的Touch事件有如下四种： MotionEvent.ACTION_DOWN：按下View（所有事件的开始） MotionEvent.ACTION_MOVE：滑动View MotionEvent.ACTION_CANCEL：非人为原因结束本次事件 MotionEvent.ACTION_UP：抬起View（与DOWN对应） 事件列：从手指接触屏幕至手指离开屏幕，这个过程产生的一系列事件任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图： 即当一个MotionEvent 产生后，系统需要把这个事件传递给一个具体的 View 去处理, 事件分发的本质答：将点击事件（MotionEvent）向某个View进行传递并最终得到处理 即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。这个事件传递的过程就是分发过程。 事件在哪些对象之间进行传递？答：Activity、ViewGroup、View 一个点击事件产生后，传递顺序是：Activity（Window） -&gt; ViewGroup -&gt; View Android的UI界面是由Activity、ViewGroup、View及其派生类组合而成的 View是所有UI组件的基类 一般Button、ImageView、TextView等控件都是继承父类View ViewGroup是容纳UI组件的容器，即一组View的集合（包含很多子View和子VewGroup）， 其本身也是从View派生的，即ViewGroup是View的子类 是Android所有布局的父类或间接父类：项目用到的布局（LinearLayout、RelativeLayout等），都继承自ViewGroup，即属于ViewGroup子类。 与普通View的区别：ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。 事件分发过程由哪些方法协作完成？答：dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent() 方法 作用 调用时刻 dispatchTouchEvent() 分发（传递）点击事件 当点击事件能够传递给当前View时，该方法就会被调用 onInterceptTouchEvent() 判断是否拦截了某个事件（只存在于ViewGroup，普通的View没有这个方法） 在dispatchTouchEvent()内存调用 onTouchEvent() 处理点击事件 在dispatchTouchEvent()内部调用 下文会对这3个方法进行详细介绍 总结 Android事件分发机制的本质是要解决：点击事件由哪个对象发出，经过哪些对象，最终达到哪个对象并最终得到处理。 这里的对象是指Activity、ViewGroup、View Android中事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View 事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成 经过上述3个问题，相信大家已经对Android的事件分发有了感性的认知，接下来，我将详细介绍Android事件分发机制。 事件分发机制方法&amp;流程介绍 事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成，如下图： Android事件分发流程如下：（必须熟记） Android事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View 其中： super：调用父类方法 true：消费事件，即事件不继续往下传递 false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理 接下来，我将详细介绍这3个方法及相关流程。 dispatchTouchEvent() 属性 介绍 使用对象 Activity、ViewGroup、View 作用 分发点击事件 调用时刻 当点击事件能够传递给当前View时，该方法就会被调用 返回结果 是否消费当前事件，详细情况如下： 1. 默认情况：根据当前对象的不同而返回方法不同 对象 返回方法 备注 Activity super.dispatchTouchEvent() 即调用父类ViewGroup的dispatchTouchEvent() ViewGroup onIntercepTouchEvent() 即调用自身的onIntercepTouchEvent() View onTouchEvent（） 即调用自身的onTouchEvent（） 2. 返回true 消费事件 事件不会往下传递 后续事件（Move、Up）会继续分发到该View 流程图如下： 3. 返回false 不消费事件 事件不会往下传递 将事件回传给父控件的onTouchEvent()处理 Activity例外：返回false=消费事件 后续事件（Move、Up）会继续分发到该View(与onTouchEvent()区别） 流程图如下 onTouchEvent() 属性 介绍 使用对象 Activity、ViewGroup、View 作用 处理点击事件 调用时刻 在dispatchTouchEvent()内部调用 返回结果 是否消费（处理）当前事件，详细情况如下： 与dispatchTouchEvent()类似 1. 返回true 自己处理（消费）该事情 事件停止传递 该事件序列的后续事件（Move、Up）让其处理； 流程图如下： 2. 返回false（同默认实现：调用父类onTouchEvent()） 不处理（消费）该事件 事件往上传递给父控件的onTouchEvent()处理 当前View不再接受此事件列的其他事件（Move、Up）； 流程图如下： onInterceptTouchEvent() 属性 介绍 使用对象 ViewGroup（注：Activity、View都没该方法） 作用 拦截事件，即自己处理该事件 调用时刻 在ViewGroup的dispatchTouchEvent()内部调用 返回结果 是否拦截当前事件，详细情况如下： 流程图如下： 三者关系下面将用一段伪代码来阐述上述三个方法的关系和点击事件传递规则 1234567891011121314151617181920212223// 点击事件产生后，会直接调用dispatchTouchEvent（）方法public boolean dispatchTouchEvent(MotionEvent ev) &#123; //代表是否消耗事件 boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; //如果onInterceptTouchEvent()返回true则代表当前View拦截了点击事件 //则该点击事件则会交给当前View进行处理 //即调用onTouchEvent (）方法去处理点击事件 consume = onTouchEvent (ev) ; &#125; else &#123; //如果onInterceptTouchEvent()返回false则代表当前View不拦截点击事件 //则该点击事件则会继续传递给它的子元素 //子元素的dispatchTouchEvent（）就会被调用，重复上述过程 //直到点击事件被最终处理为止 consume = child.dispatchTouchEvent (ev) ; &#125; return consume; &#125; 总结对于事件分发的3个方法，你应该清楚了解接下来，我将开始介绍Android事件分发的常见流程 事件分发场景介绍下面我将利用例子来说明常见的点击事件传递情况 背景描述我们将要讨论的布局层次如下： 最外层：Activiy A，包含两个子View：ViewGroup B、View C 中间层：ViewGroup B，包含一个子View：View C 最内层：View C 假设用户首先触摸到屏幕上View C上的某个点（如图中黄色区域），那么Action_DOWN事件就在该点产生，然后用户移动手指并最后离开屏幕。 一般的事件传递情况一般的事件传递场景有： 默认情况 处理事件 拦截DOWN事件 拦截后续事件（MOVE、UP） 默认情况 即不对控件里的方法(dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent())进行重写或更改返回值 那么调用的是这3个方法的默认实现：调用父类的方法 事件传递情况：（如图下所示） 从Activity A—-&gt;ViewGroup B—&gt;View C，从上往下调用dispatchTouchEvent() 再由View C—&gt;ViewGroup B —&gt;Activity A，从下往上调用onTouchEvent() 注：虽然ViewGroup B的onInterceptTouchEvent方法对DOWN事件返回了false，后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent() 这一点与onTouchEvent的行为是不一样的。 处理事件假设View C希望处理这个点击事件，即C被设置成可点击的（Clickable）或者覆写了C的onTouchEvent方法返回true。 最常见的：设置Button按钮来响应点击事件 事件传递情况：（如下图） DOWN事件被传递给C的onTouchEvent方法，该方法返回true，表示处理这个事件 因为C正在处理这个事件，那么DOWN事件将不再往上传递给B和A的onTouchEvent()； 该事件列的其他事件（Move、Up）也将传递给C的onTouchEvent() 拦截DOWN事件假设ViewGroup B希望处理这个点击事件，即B覆写了onInterceptTouchEvent()返回true、onTouchEvent()返回true。事件传递情况：（如下图） DOWN事件被传递给B的onInterceptTouchEvent()方法，该方法返回true，表示拦截这个事件，即自己处理这个事件（不再往下传递） 调用onTouchEvent()处理事件（DOWN事件将不再往上传递给A的onTouchEvent()） 该事件列的其他事件（Move、Up）将直接传递给B的onTouchEvent() 该事件列的其他事件（Move、Up）将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。 拦截DOWN的后续事件假设ViewGroup B没有拦截DOWN事件（还是View C来处理DOWN事件），但它拦截了接下来的MOVE事件。 DOWN事件传递到C的onTouchEvent方法，返回了true。 在后续到来的MOVE事件，B的onInterceptTouchEvent方法返回true拦截该MOVE事件，但该事件并没有传递给B；这个MOVE事件将会被系统变成一个CANCEL事件传递给C的onTouchEvent方法 后续又来了一个MOVE事件，该MOVE事件才会直接传递给B的onTouchEvent() 后续事件将直接传递给B的onTouchEvent()处理 后续事件将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。 C再也不会收到该事件列产生的后续事件。 特别注意： 如果ViewGroup A 拦截了一个半路的事件（如MOVE），这个事件将会被系统变成一个CANCEL事件并传递给之前处理该事件的子View； 该事件不会再传递给ViewGroup A的onTouchEvent() 只有再到来的事件才会传递到ViewGroup A的onTouchEvent() 总结 对于Android的事件分发机制，你应该已经非常清楚了 如果你只是希望了解Android事件分发机制而不想深入了解，那么你可以离开这篇文章了 对于程序猿来说，知其然还需要知其所以然，接下来，我将通过源码分析来深入了解Android事件分发机制 Android事件分发机制源码分析 Android中事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View，再次贴出下图： 其中： super：调用父类方法 true：消费事件，即事件不继续往下传递 false：不消费事件，事件继续往下传递 / 交由给父控件onTouchEvent（）处理 所以，要想充分理解Android分发机制，本质上是要理解： Activity对点击事件的分发机制 ViewGroup对点击事件的分发机制 View对点击事件的分发机制 接下来，我将通过源码分析详细介绍Activity、View和ViewGroup的事件分发机制 Activity的事件分发机制源码分析 当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发 具体是由Activity的Window来完成 我们来看下Activity的dispatchTouchEvent()的源码 12345678910111213public boolean dispatchTouchEvent(MotionEvent ev) &#123; //关注点1 //一般事件列开始都是DOWN，所以这里基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //关注点2 onUserInteraction(); &#125; //关注点3 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 关注点1一般事件列开始都是DOWN（按下按钮），所以这里返回true，执行onUserInteraction() 关注点2先来看下onUserInteraction()源码 123456789101112131415161718192021 /** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and &#123;@link #onUserLeaveHint&#125; are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notfication. * * &lt;p&gt;All calls to your activity's &#123;@link #onUserLeaveHint&#125; callback will * be accompanied by calls to &#123;@link #onUserInteraction&#125;. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * &lt;p&gt;Note that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */public void onUserInteraction() &#123; &#125; 从源码可以看出： 该方法为空方法 从注释得知：当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 所以onUserInteraction()主要用于屏保 关注点3 Window类是抽象类，且PhoneWindow是Window类的唯一实现类 superDispatchTouchEvent(ev)是抽象方法，返回的是一个Window对象 通过PhoneWindow类中看一下superDispatchTouchEvent()的作用 123456@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);//mDecor是DecorView的实例//DecorView是视图的顶层view，继承自FrameLayout，是所有界面的父类&#125; 接下来我们看mDecor.superDispatchTouchEvent(event)： 1234567public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);//DecorView继承自FrameLayout//那么它的父类就是ViewGroup而super.dispatchTouchEvent(event)方法，其实就应该是ViewGroup的dispatchTouchEvent()&#125; 所以： 执行getWindow().superDispatchTouchEvent(ev)实际上是执行了ViewGroup.dispatchTouchEvent(event) 再回到最初的代码： 123456789101112public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //关注点2 onUserInteraction(); &#125; //关注点3 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 由于一般事件列开始都是DOWN，所以这里返回true，基本上都会进入getWindow().superDispatchTouchEvent(ev)的判断 所以，执行Activity.dispatchTouchEvent(ev)实际上是执行了ViewGroup.dispatchTouchEvent(event) 这样事件就从 Activity 传递到了 ViewGroup 汇总当一个点击事件发生时，调用顺序如下 事件最先传到Activity的dispatchTouchEvent()进行事件分发 调用Window类实现类PhoneWindow的superDispatchTouchEvent() 调用DecorView的superDispatchTouchEvent() 最终调用DecorView父类的dispatchTouchEvent()，即ViewGroup的dispatchTouchEvent() 结论 当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发，最终是调用了ViewGroup的dispatchTouchEvent()方法 如果ViewGroup的dispatchTouchEvent()返回true就不执行Activity的onTouchEvent()方法；如果返回false，就执行。这样事件就从 Activity 传递到了 ViewGroup 疑问那么，ViewGroup的dispatchTouchEvent()什么时候返回true，什么时候返回false？答：请继续往下看ViewGroup事件的分发机制 ViewGroup事件的分发机制在讲解ViewGroup事件的分发机制之前我们先来看个Demo Demo讲解布局如下： 结果测试：只点击Button 再点击空白处 从上面的测试结果发现： 当点击Button时，执行Button的onClick()，但ViewGroupLayout注册的onTouch（）不会执行 只有点击空白区域时才会执行ViewGroupLayout的onTouch（）; 结论：Button的onClick()将事件消费掉了，因此事件不会再继续向下传递。 接下来，我们开始进行ViewGroup事件分发的源码分析 源码分析ViewGroup的dispatchTouchEvent()源码分析 详情请看注释 Android 5.0后ViewGroup的dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同； 本文为了让读者更好理解dispatchTouchEvent()源码分析，所以采用Android 5.0前的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public boolean dispatchTouchEvent(MotionEvent ev) &#123; final int action = ev.getAction(); final float xf = ev.getX(); final float yf = ev.getY(); final float scrolledXFloat = xf + mScrollX; final float scrolledYFloat = yf + mScrollY; final Rect frame = mTempRect; boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (action == MotionEvent.ACTION_DOWN) &#123; if (mMotionTarget != null) &#123; mMotionTarget = null; &#125; //看这个If判断语句//第一个判断值disallowIntercept：是否禁用事件拦截的功能(默认是false)//可以通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改。//第二个判断值： !onInterceptTouchEvent(ev)：对onInterceptTouchEvent()返回值取反//如果我们在onInterceptTouchEvent()中返回false，就会让第二个值为true，从而进入到条件判断的内部//如果我们在onInterceptTouchEvent()中返回true，就会让第二个值为false，从而跳出了这个条件判断。//关于onInterceptTouchEvent()请看下面分析（关注点1） if (disallowIntercept || !onInterceptTouchEvent(ev)) &#123; ev.setAction(MotionEvent.ACTION_DOWN); final int scrolledXInt = (int) scrolledXFloat; final int scrolledYInt = (int) scrolledYFloat; final View[] children = mChildren; final int count = mChildrenCount; //通过for循环，遍历了当前ViewGroup下的所有子View for (int i = count - 1; i &gt;= 0; i--) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; child.getHitRect(frame); //判断当前遍历的View是不是正在点击的View //如果是，则进入条件判断内部 if (frame.contains(scrolledXInt, scrolledYInt)) &#123; final float xc = scrolledXFloat - child.mLeft; final float yc = scrolledYFloat - child.mTop; ev.setLocation(xc, yc); child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; //关注点2 //条件判断的内部调用了该View的dispatchTouchEvent()方法（具体请看下面的View事件分发机制） //实现了点击事件从ViewGroup到View的传递 if (child.dispatchTouchEvent(ev)) &#123; //调用子View的dispatchTouchEvent后是有返回值的 //如果这个控件是可点击的话，那么点击该控件时，dispatchTouchEvent的返回值必定是true //因此会导致条件判断成立 mMotionTarget = child; //于是给ViewGroup的dispatchTouchEvent方法直接返回了true，这样就导致后面的代码无法执行，直接跳出 //即把ViewGroup的touch事件拦截掉 return true; &#125; &#125; &#125; &#125; &#125; &#125; boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) || (action == MotionEvent.ACTION_CANCEL); if (isUpOrCancel) &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; final View target = mMotionTarget; //关注点3//没有任何View接收事件的情况，即点击空白处情况 if (target == null) &#123; ev.setLocation(xf, yf); if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; &#125; //调用ViewGroup的父类View的dispatchTouchEvent()//因此会执行ViewGroup的onTouch()、onTouchEvent()//实现了点击事件从ViewGroup到View的传递 return super.dispatchTouchEvent(ev); &#125; //之后的代码在一般情况下是走不到的了，我们也就不再继续往下分析。 if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) &#123; final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; ev.setAction(MotionEvent.ACTION_CANCEL); ev.setLocation(xc, yc); if (!target.dispatchTouchEvent(ev)) &#123; &#125; mMotionTarget = null; return true; &#125; if (isUpOrCancel) &#123; mMotionTarget = null; &#125; final float xc = scrolledXFloat - (float) target.mLeft; final float yc = scrolledYFloat - (float) target.mTop; ev.setLocation(xc, yc); if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) &#123; ev.setAction(MotionEvent.ACTION_CANCEL); target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT; mMotionTarget = null; &#125; return target.dispatchTouchEvent(ev); &#125; 关注点1（onInterceptTouchEvent()源码分析）ViewGroup每次在做分发时，需要调用onInterceptTouchEvent()是否拦截事件；源码分析如下： 123public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return false; &#125; 返回false =不拦截（默认），允许事件继续往下传递(向子View传递)； 因为子View也需要该事件，所以onInterceptTouchEvent拦截器return super.onInterceptTouchEvent()和return false是一样的 = 不会拦截 返回true = 拦截（手动设置），即自己处理该事件（执行自己的onTouchEvent()），事件不会继续往下传递 关注点2当点击了某个控件： 调用该控件所在布局（ViewGroup）的dispatchTouchEvent() 在布局的dispatchTouchEvent()中找到被点击的相应控件 再去调用该控件的dispatchTouchEvent() 实现了点击事件从ViewGroup到View的传递 此处是关于View.dispatchTouchEvent()的分析，详情请看下面的View事件分发机制。 结论 Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View 在ViewGroup中通过onInterceptTouchEvent()对事件传递进行拦截 onInterceptTouchEvent方法返回true代表拦截事件，即不允许事件继续向子View传递； 返回false代表不拦截事件，即允许事件继续向子View传递；（默认返回false） 子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。 View事件的分发机制View中dispatchTouchEvent()的源码分析 1234567public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event); &#125; 从上面可以看出： 只有以下三个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent(event)方法 123第一个条件：mOnTouchListener != null；第二个条件：(mViewFlags &amp; ENABLED_MASK) == ENABLED；第三个条件：mOnTouchListener.onTouch(this, event)； 下面，我们来看看下这三个判断条件： 第一个条件：mOnTouchListener!= null 123456//mOnTouchListener是在View类下setOnTouchListener方法里赋值的public void setOnTouchListener(OnTouchListener l) &#123; //即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空） mOnTouchListener = l; &#125; 第二个条件：(mViewFlags &amp; ENABLED_MASK) == ENABLED 该条件是判断当前点击的控件是否enable 由于很多View默认是enable的，因此该条件恒定为true 第三个条件：mOnTouchListener.onTouch(this, event) 回调控件注册Touch事件时的onTouch方法 123456789//手动调用设置button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; return false; &#125; &#125;); 如果在onTouch方法返回true，就会让上述三个条件全部成立，从而整个方法直接返回true。 如果在onTouch方法里返回false，就会去执行onTouchEvent(event)方法。 接下来，我们继续看：onTouchEvent(event)的源码分析 详情请看注释 Android 5.0后View的onTouchEvent()的源码发生了变化（更加复杂），但原理相同； 本文为了让读者更好理解onTouchEvent()源码分析，所以采用Android 5.0前的版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //如果该控件是可以点击的就会进入到下两行的switch判断中去； if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; //如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。 switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; // 在经过种种判断之后，会执行到关注点1的performClick()方法。 //请往下看关注点1 if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; //关注点1 //请往下看performClick()的源码分析 performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; mPrivateFlags |= PRESSED; refreshDrawableState(); postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); // Be lenient about moving outside of buttons int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; break; &#125; //如果该控件是可以点击的，就一定会返回true return true; &#125; //如果该控件是可以点击的，就一定会返回false return false; &#125; 关注点1： performClick()的源码分析 12345678910public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; &#125; return false; &#125; 只要mOnClickListener不为null，就会去调用onClick方法； 那么，mOnClickListener又是在哪里赋值的呢？请继续看： 123456public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; mOnClickListener = l; &#125; 当我们通过调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值（不为空），即会回调onClick（）。 结论 onTouch（）的执行高于onClick（） 每当控件被点击时： 如果在回调onTouch()里返回false，就会让dispatchTouchEvent方法返回false，那么就会执行onTouchEvent()；如果回调了setOnClickListener()来给控件注册点击事件的话，最后会在performClick()方法里回调onClick()。 onTouch()返回false（该事件没被onTouch()消费掉） = dispatchTouchEvent()返回false（继续向下传递） = 执行onTouchEvent() = 执行OnClick() 如果在回调onTouch()里返回true，就会让dispatchTouchEvent方法返回true，那么将不会执行onTouchEvent()，即onClick()也不会执行； onTouch()返回true（该事件被onTouch()消费掉） = dispatchTouchEvent()返回true（不会再继续向下传递） = 不会执行onTouchEvent() = 不会执行OnClick() 下面我将用Demo验证上述的结论 Demo论证1. Demo1：在回调onTouch()里返回true 123456789101112131415161718//设置OnTouchListener() button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return true; &#125; &#125;);//设置OnClickListener button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;); 点击Button，测试结果如下： 2. Demo2：在回调onTouch()里返回false 123456789101112131415161718//设置OnTouchListener() button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return false; &#125; &#125;);//设置OnClickListener button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;); 点击Button，测试结果如下： 总结：onTouch()返回true就认为该事件被onTouch()消费掉，因而不会再继续向下传递，即不会执行OnClick()。 如果你看到此处，那么恭喜你，你已经能非常熟悉掌握Android的事件分发机制了（Activity、ViewGroup、View的事件分发机制） 思考点onTouch()和onTouchEvent()的区别 这两个方法都是在View的dispatchTouchEvent中调用，但onTouch优先于onTouchEvent执行。 如果在onTouch方法中返回true将事件消费掉，onTouchEvent()将不会再执行。 特别注意：请看下面代码 123456//&amp;&amp;为短路与，即如果前面条件为false，将不再往下执行//所以，onTouch能够得到执行需要两个前提条件：//1. mOnTouchListener的值不能为空//2. 当前点击的控件必须是enable的。mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event) 因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。 Touch事件的后续事件（MOVE、UP）层级传递 如果给控件注册了Touch事件，每次点击都会触发一系列action事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP等） 当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP） 即如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE和ACTION_UP事件都不会执行 从上面对事件分发机制分析知： dispatchTouchEvent()和 onTouchEvent()消费事件、终结事件传递（返回true） 而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用 请记住：接收了ACTION_DOWN事件的函数不一定能收到后续事件（ACTION_MOVE、ACTION_UP） 这里给出ACTION_MOVE和ACTION_UP事件的传递结论： 如果在某个对象（Activity、ViewGroup、View）的dispatchTouchEvent()消费事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE和ACTION_UP事件传递方向 如果在某个对象（Activity、ViewGroup、View）的onTouchEvent()消费事件（返回true），那么ACTION_MOVE和ACTION_UP的事件从上往下传到这个View后就不再往下传递了，而直接传给自己的onTouchEvent()并结束本次事件传递过程。 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE和ACTION_UP事件传递方向]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-史上最全解析Android消息推送解决方案]]></title>
      <url>%2F2017%2F10%2F27%2Fandroid-push%2F</url>
      <content type="text"><![CDATA[前言消息推送在Android开发中应用的场景是越来越多了，比如说电商产品进行活动宣传、资讯类产品进行新闻推送等等。 本文将介绍Android中实现消息推送的7种主流解决方案。 目录 定义在用户未打开App时，App主动向用户推送服务器最新消息。如下图： 消息推送的本质是：App将服务器更新的信息推送给用户 作用 产品的角度：功能需要，比如说资讯类产品的新闻推送、工具类产品的公告推送等等 运营的角度：活动运营需要，比如说电商类产品的促销活动；召回用户 / 提高活跃度等等 作为开发者，不要有需求就接，应该多思考、多理解用户 / 功能的使用场景，有助于我们更好地去选择合适的开发方式 储备知识操作系统有自身的消息推送功能（系统级别） 系统级别：任何时候都可以推送给用户，且不会被系统杀死 Android的消息推送服务称为：C2DM（Cloudto Device Messaging） 将在下面详细描述 推送的本质与原理 消息推送的本质是：App将服务器更新的信息推送给用户，即App获取服务器信息，再推送给用户 App从服务器获取最新消息的基本方式（原理）有3种：Push、Pull 和 SMS 具体如下 解决方案经总结，Android中实现消息推送的有7种主流解决方案，接下来将一一介绍。 C2DM 定义：Cloud to Device Messaging，云端推送 Android系统级别的消息推送服务-Google出品 原理：基于Push方式，C2DM服务负责处理诸如消息排队等事务，并向运行于目标设备上的应用程序分发这些消息。如下图： 优点：C2DM提供了一个简单的、轻量级的机制，允许服务器可以通知移动应用程序直接与服务器进行通信，以便于从服务器获取应用程序更新和用户数据。 缺点： 依赖于Google官方提供的C2DM服务器，但在国内使用Google服务需要翻墙，成本较大； 需要用户手机安装Google服务。但由于Android机型、系统的碎片化 &amp; 国内环境，国内的Android系统都自动去除Google服务，假如要使用C2DM服务，这意味着用户还得去安装Google服务，成本较大。 轮询 原理：基于Pull方式，应用程序隔固定时间主动与服务器进行连接并查询是否有新的消息 缺点： 成本大，需要自己实现与服务器之间的通信，例如消息排队等； 到达率不确定，考虑轮询的频率：太低可能导致消息的延迟；太高，更费客户端的资源（CPU资源、网络流量、系统电量）和服务器资源（网络带宽） SMS 定义：短信发送 原理：基于Push方式，通过拦截SMS消息并且解析消息内容来了解服务器的意图，并获取其显示内容进行处理。 优点：可实现完全的实时操作 缺点：成本相对较高。因为目前来说，很难找到免费的短消息发送网关来实现这种方案，只能通过向运营商缴纳相应的短信费用 MQTT协议 定义：轻量级的消息发布/订阅协议 原理：基于Push方式，wmqtt.jar 是IBM提供的MQTT协议的实现，原理如下图： 更多关于MQTT协议： 项目实例源 一个采用PHP书写的服务器端 Jar包下载地址，并加入自己的Android应用程序中。 拓展：RSMB是从MQTT协议引申出来的另外一种解决方案：简单的MQTT代理，详情请点击 XMPP协议 定义：Extensible Messageing and Presence Protocol，可扩展消息与存在协议，是基于可扩展标记语言（XML）的协议，是目前主流的四种IM协议之一 其他三种： 即时信息和空间协议（IMPP） 空间和即时信息协议（PRIM） 即时通讯和空间平衡扩充的进程开始协议SIP（SIMPLE） 原理：XMPP中定义了三个角色，分别是客户端、服务器和网关 客户端 通过 TCP/IP与XMPP 服务器连接，然后在之上传输与即时通讯相关的指令（XML）； 解析组织好的 XML 信息包； 理解消息数据类型。 XMPP的核心：XML流传输协议（在网络上分片断发送XML的流协议），也是即时通讯指令的传递基础，即XMPP用TCP传的是XML流与即时通讯相关的指令，在以前要么用2进制的形式发送（比如QQ），要么用纯文本指令加空格加参数加换行符的方式发送（比如MSN）。XMPP传输的即时通讯指令的逻辑与以往相仿，只是协议的形式变成了XML格式的纯文本。 服务器 监听客户端连接，并直接与客户端应用程序通信（客户端信息记录） 与其他 XMPP 服务器通信； 网关：与异构即时通信系统进行通信 异构系统包括SMS（短信），MSN，ICQ等 通信能够在这三者的任意两个之间双向发生。 原理流程 优点： 开源：可通过修改其源代码来适应我们的应用程序。 简单：XML易于解析和阅读；将复杂性从客户端转移到了服务器端 可拓展性强：继承了在XML环境中灵活的发展性，可进一步对协议进行扩展，实现更为完善的功能。 GTalk、QQ、IM等都用这个协议 缺点：如果将消息从服务器上推送出去，则不管消息是否成功到达客户端手机上。 源码实例：有一个很棒的基于XMPP协议的java开源Android push notification：Androidpn项目地址，大家有兴趣可以去看看 更多关于XMPP协议更加详细请点击 使用第三方平台现今主流的推送平台分为 手机厂商类：小米推送、华为推送。 第三方平台类：友盟推送、极光推送、云巴（基于MQTT） BAT大厂的平台推送：阿里云移动推送、腾讯信鸽推送、百度云推送 具体各推送平台的优缺点请看我写的文章：Android推送：第三方消息推送平台详细解析 自己搭建如果你的产品对于消息推送具备较高的功能和性能要求，同时对安全性要求非常高的话，自己搭建可能是最好的方式，但这种方式无疑成本是最高的。 总结 经过上面的详细讲解，相信大家现在对Android中消息推送的解决方案已经非常了解 解决方案没有优劣，要具具体使用场景而定。但一般来说，个人建议使用第三方平台推送，成本低+抵达率高 关于Android消息推送的其他知识，具体请看：Android消息推送：手把手教你集成小米推送Android推送：第三方消息推送平台详细解析]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-RecyclerView自定义ItemDecoration从入门到实现吸顶效果]]></title>
      <url>%2F2017%2F10%2F26%2Fandroid-itemdecoration-ceiling%2F</url>
      <content type="text"><![CDATA[RecyclerView性能和自由度相比ListView强大很多,但很恼人的是它没有像ListView一样默认提供分割线. 刚接触RecyclerView,用过才发现RecyclerView没有分割线过后,遂到网上搜解决办法才发现自定义一个ItemDecoration只要一条黑线还要写代码,好麻烦,不知道有没像我一样懒得折腾上网搜现成的,粘贴到项目直接用. 拖了很久才去解决这个问题,上网大致看了一下教程,其实不难而且自定义功能很强大. 首先新建一个类覆写ItemDecoration里面有三个方法: 1234567891011121314151617181920212223public class SimpleItemDecoration extends RecyclerView.ItemDecoration &#123; public SimpleItemDecoration(Context context) &#123; &#125; public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); &#125; public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state); &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); &#125;&#125; onDraw名字很熟悉吧,和View中的onDraw一样,是用来画东西的, 在item上画分割线就靠这个方法了. onDrawOver 英文Over的意思在…的上面 ,可以理解成是图层关系,item的内容和分割线是第一层(要在第一层画东西要调用onDraw),而onDrawOver是第二层,位于onDraw的上面 getItemOffsets 看名字可以知道是设置item的偏移值,其实效果和padding一样. 以上三个方法都是在RecylerView发生滑动的时候触发. 需要注意的是三个方法的都有一个RecyclerView parent,通过这个参数我们可以获取到RecyclerView的属性,例如 parent.getChildCount();获取子View的个数,但是这个并不是获取RecyclerView所有的item个数,而是当前屏幕可见的item个数. 所以画一条分割线需要的代码是这样的: 123456789101112131415161718192021222324252627282930 private int wight; private int height; private int item_height; private int item_padding; private Paint paint;public SimpleItemDecoration(Context context) &#123; wight=context.getResources().getDisplayMetrics().widthPixels; height=context.getResources().getDisplayMetrics().heightPixels; paint=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG); paint.setColor(Color.BLACK); item_height=DensityUtil.dip2px(context, 1); item_padding=DensityUtil.dip2px(context, 10); &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); int count=parent.getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View view=parent.getChildAt(i); int top=view.getTop(); int bottom=top+item_height; c.drawRect(0,top,wight,bottom,paint); &#125; ..... &#125; 运行后得到如下图的效果. 接着把item_height=DensityUtil.dip2px(context, 1);的1改成30,你会发现item的内容和黑色的分割线重合了 因为上面说了item和内容和onDraw中画的内容在同一图层,当然会被出现重合的情况.这个时候getItemOffsets就能派上用场了.只要在原来的item的加个偏移值(效果和在Adpater中为item设置padding的效果是一样的,只是在ItemDecoration统一处理比较合适)onDraw中画的分割线有多高,我就paddingBottom多少. 所以代码是是这样的: 1234public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.bottom=item_height; &#125; 再次运行代码item被挡住的问题就解决了,RecyclerView的自定义ItemDecoration就是这么简单.有点自定义View经验的人理解起来都不会难 分割线不要占满,要有和Left,Right有间距啊? 添加如下代码: 123456789101112131415161718192021222324252627282930private int wight;private int height;private int item_height;private Paint paint;private float item_padding;public SimpleItemDecoration(Context context) &#123; wight=context.getResources().getDisplayMetrics().widthPixels; height=context.getResources().getDisplayMetrics().heightPixels; paint=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG); paint.setColor(Color.BLACK); item_height=DensityUtil.dip2px(context, 1); item_padding=DensityUtil.dip2px(context, 10);&#125;@Overridepublic void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); int count=parent.getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View view=parent.getChildAt(i); int top=view.getBottom(); int bottom=top+item_height; //这里把left和right的值分别增加item_padding,和减去item_padding. c.drawRect(item_padding,top,wight-item_padding,bottom,paint); &#125; ....&#125; 一般用到的分割线根据以上的代码再自己的按照需求稍微修改一下基本都能满足需求了. 之前在网上看到通过自定义ItemDecoration实现仿照旧版的instagram吸顶效果,感觉那种效果很好看,研究了一下发现只要理解了上面文章所说的几个方法实现起来并不难. 先来看最终效果图: 要实现吸顶的效果需要完成这些步骤: 首先需要画一条高度足够容下文字和图片的分割线. 因为是吸顶效果,所以分割线和传统的分割线一样应该是在每个item的上方而不是下方 当前屏幕可见的第一个item的Bottom&lt;=item_height(分割线的高度) 说明可见的第一个item的底部已经超出了分割线的高度,这个时候就应该让第一条分割线随着RecyclerView向上滑动直到滑出屏幕,这个时候第二个item就取代了第一个item变成了第一个item,否则分割线一直固定不动. 判断当前屏幕的第一个可见的item是哪个 把当前屏幕可见的item进行对比,如果item的内容第一个字相同,则把它们归为一组,用一条分割线显示即可. 先来实现1和2的要求,主要代码部分如下: 123456789101112131415161718192021222324252627282930313233343536373839404142private int wight; private int height; private int item_height; private Paint paint; private float item_padding; public SimpleItemDecoration(Context context) &#123; wight=context.getResources().getDisplayMetrics().widthPixels; height=context.getResources().getDisplayMetrics().heightPixels; paint=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG); //更改画笔颜色为自定义的颜色 paint.setColor(context.getResources().getColor(R.color.itemColor)); item_height=DensityUtil.dip2px(context, 30); item_padding=DensityUtil.dip2px(context, 10); &#125;@Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); //因为分割线是在item的上方,所以需要为每个item腾出一条分割线的高度 outRect.top=item_height; &#125;@Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); int count=parent.getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View view=parent.getChildAt(i); //分割线不能和item的内容重叠,所以把分割线画在getItemOffsets为item腾出来的位置上. //所以top需要上移item_height int top=view.getTop()-item_height; //bottom同理 int bottom=top+item_height; c.drawRect(0,top,wight,bottom,paint); &#125; &#125;.... 最终实现的效果如图: 注意看陈奕迅这个item的分割线是在item的上面的,并且分割线的高度已经足够容下我们稍后要绘制的内容了. 接着来实现3,怎么样才能让分割线在满足条件的时候动,不满足的时候固定? 这个时候就需要用到代码中一直没覆写的onDrawOver方法了,先来实现固定不动的分割线,代码也是非常的简单,在原来的代码上覆写onDrawOver方法(这里new了新的画笔paint2,把固定的分割线用半透明红色来作为背景,方便理解效果): 1234567paint2=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG);paint2.setColor(Color.parseColor("#52ff0000")); @Overridepublic void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state);&#125; 接着来实现实现: 当前屏幕可见的第一个item的Bottom&lt;=item_height(分割线的高度)让第一条分割线随着RecyclerView向上滑动直到滑出屏幕,代码如下: 123456789101112131415@Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state); View child0 = parent.getChildAt(0); //如果第一个item的Bottom&lt;=分割线的高度 if (child0.getBottom() &lt;= item_height) &#123; //随着RecyclerView滑动 分割线的top=固定为0不动,bottom则赋值为child0的bottom值. c.drawRect(0, 0, wight,child0.getBottom() , paint2); &#125; else &#123; //固定不动 c.drawRect(0, 0, wight, item_height, paint2); &#125; &#125; 可以看到滑动时当第二item的顶部和第一个item的底部相互接触到后继续滑动的话第一个item就会慢慢向上滑动,直到第一个item完全画出屏幕,固定分割线立马回到最开始的位置和item2分割线重叠了在一起,现在可以把paint2换回paint效果会更直观,不上效果图了,可以自己去测试. 对第一次接触ItemDecoration的人来说,难点都已经讲完了,剩下的就是在分割线范围计算出合适的位置调动drawText和drawBitmap画下文字和图片,直接贴上完整的源码: (在源码注释里面已经把没有讲到的方法大致提了一下实现的原理) 自定义ItemDecoration的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * Created by Lipt0n on 2017/8/26. */public class SimpleItemDecoration extends RecyclerView.ItemDecoration &#123; private Bitmap bitmap; private Paint.FontMetrics fontMetrics; private int wight; private int itemDecorationHeight; private Paint paint; private ObtainTextCallback callback; private float itemDecorationPadding; private TextPaint textPaint; private Rect text_rect=new Rect(); public SimpleItemDecoration(Context context, ObtainTextCallback callback) &#123; wight=context.getResources().getDisplayMetrics().widthPixels; paint=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG); paint.setColor(context.getResources().getColor(R.color.itemColor)); itemDecorationHeight=DensityUtil.dip2px(context, 30); itemDecorationPadding=DensityUtil.dip2px(context, 10); this.callback = callback; textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG); textPaint.setColor(Color.WHITE); textPaint.setTextAlign(Paint.Align.LEFT); textPaint.setTextSize(DensityUtil.dip2px(context, 25)); fontMetrics = new Paint.FontMetrics(); textPaint.getFontMetrics(fontMetrics); bitmap= BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher_round); ScaleBitmap(); &#125; //bitmap的大小和itemDecorationHeight进行比较对图片进行缩放操作(对性能有追求可以在加载到内存的时候进行压缩) private void ScaleBitmap() &#123; Matrix matrix=new Matrix(); float scale=bitmap.getWidth()&gt;itemDecorationHeight?Float.valueOf(itemDecorationHeight)/Float.valueOf(bitmap.getHeight()):Float.valueOf(bitmap.getHeight())/Float.valueOf(itemDecorationHeight); matrix.postScale(scale,scale); bitmap= Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,false); &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDraw(c, parent, state); int count=parent.getChildCount(); for (int i = 0; i &lt; count; i++) &#123; View view=parent.getChildAt(i); int top=view.getTop()-itemDecorationHeight; int bottom=top+itemDecorationHeight; int position = parent.getChildAdapterPosition(view); String content = callback.getText(position); textPaint.getTextBounds(content,0, content.length(),text_rect); if(isFirstInGroup(position)) &#123; c.drawRect(0,top,wight,bottom,paint); c.drawText(content, itemDecorationPadding+bitmap.getWidth(), bottom-fontMetrics.descent, textPaint); c.drawBitmap(bitmap,itemDecorationPadding,bottom-bitmap.getHeight(),paint); &#125; &#125; &#125; @Override public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; super.onDrawOver(c, parent, state); View child0=parent.getChildAt(0); int position = parent.getChildAdapterPosition(child0); String content = callback.getText(position); if(child0.getBottom()&lt;=itemDecorationHeight&amp;&amp;isFirstInGroup(position+1))&#123; c.drawRect(0, 0, wight, child0.getBottom(), paint); c.drawText(content, itemDecorationPadding+bitmap.getWidth(), child0.getBottom()-fontMetrics.descent, textPaint); c.drawBitmap(bitmap,itemDecorationPadding,child0.getBottom()-bitmap.getHeight(),paint); &#125; else &#123; c.drawRect(0, 0, wight, itemDecorationHeight, paint); c.drawText(content, itemDecorationPadding+bitmap.getWidth(), itemDecorationHeight-fontMetrics.descent, textPaint); c.drawBitmap(bitmap,itemDecorationPadding,itemDecorationHeight-bitmap.getHeight(),paint); &#125; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); int position= parent.getChildAdapterPosition(view); //如果不是在同一组就腾出分割线需要的高度 if(isFirstInGroup(position))&#123; outRect.top=itemDecorationHeight; &#125; &#125; //回调接口,通过该回调获取item的内容的第一个文字 public interface ObtainTextCallback &#123; String getText(int position); &#125; //判断当前item和下一个item的第一个文字是否相同,如果相同说明是同一组,不需要画分割线 private boolean isFirstInGroup(int pos) &#123; //如果是adapter的第一个position直接return,因为第一个item必须有分割线 if (pos == 0) &#123; return true; &#125; else &#123; //否者判断前一个item的字符串 与 当前item字符串 是否相同 String prevGroupId = callback.getText(pos - 1); String groupId = callback.getText(pos); if (prevGroupId.equals(groupId)) &#123; return false; &#125; else &#123; return true; &#125; &#125; &#125;&#125; Activity中调用的代码: 123456recyclerView.addItemDecoration(new SimpleItemDecoration(this, new SimpleItemDecoration.ObtainTextCallback() &#123; @Override public String getText(int position) &#123; return dataList.get(position).substring(0,1); &#125;&#125;)); 只要理解了最开始提到的ItemDecoration 的3个主要方法,再处理一下文字分组的逻辑实现起来不会太难,花点耐心还是能写出来的. 贴上github源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-拍照获取缩略图以及完整图片(适配androidN)]]></title>
      <url>%2F2017%2F10%2F24%2Fandroid-system-photo%2F</url>
      <content type="text"><![CDATA[调用系统相机拍照获取缩照片略图 调用系统相机拍照时，如果不传路径，图片默认返回缩略图，不需要权限 1234Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);&#125; takePictureIntent.resolveActivity(getPackageManager()) != null 在官方文档中有描述：startActivityForResult（）方法受到调用resolveActivity（）的条件的保护，该方法返回可处理该意图的第一个活动组件，执行此检查很重要，因为如果您使用没有应用程序可以处理的意图调用startActivityForResult（），则您的应用程序将崩溃。所以只要结果不为空，就可以安全的使用意图，大概意思是检测手机中有没有相机。 另外一种检测相机的方法是 12345&lt;manifest ... &gt; &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt; ...&lt;/manifest&gt; required=true表示要安装该应用，手机必须有摄像头该硬件。要不然不允许安装 处理回调 12345678@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get("data"); mImageView.setImageBitmap(imageBitmap); &#125;&#125; 调用系统相机拍照获取全尺寸照片 如果要保存一个全尺寸的照片，必须提供一个完整的文件名，当照片需要保存到公有目录时，那么需要一个写入的权限(写入权限已经隐含的允许读取[READ_EXTERNAL_STORAGE]，这样子就可以将app拍的照片写入到外部存储,该外部存储的链接是getExternalStoragePublicDirectory() 1234&lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; ...&lt;/manifest&gt; 当需要将得到的照片保存到私有目录时，使用该链接getExternalFilesDir(),getFilesDir()，这两个目录下的文件在应用删除的时候就自动删掉了，在android4.4以下需要权限，4.4以上应用之间不能被其他程序访问，因此该权限只要在4.4以下加入 12345&lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; android:maxSdkVersion=&quot;18&quot; /&gt; ...&lt;/manifest&gt; 提供一个不会冲突的文件名，例如按时间来起名 1234567891011121314151617String mCurrentPhotoPath;private File createImageFile() throws IOException &#123; // Create an image file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); String imageFileName = "JPEG_" + timeStamp + "_"; File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES); File image = File.createTempFile( imageFileName, /* prefix */ ".jpg", /* suffix */ storageDir /* directory */ ); // Save a file: path for use with ACTION_VIEW intents mCurrentPhotoPath = image.getAbsolutePath(); return image;&#125; 构造拍照intent，适配7.0以及4.0 1234567891011121314151617181920212223242526272829303132333435static final int REQUEST_TAKE_PHOTO = 1; private void camera2() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); // Ensure that there's a camera activity to handle the intent if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; // Create the File where the photo should go File photoFile = null; try &#123; photoFile = createImageFile(); &#125; catch (IOException ex) &#123; // Error occurred while creating the File &#125; // Continue only if the File was successfully created if (photoFile != null) &#123; Uri photoURI = FileProvider.getUriForFile(this, "lsp.com.ipctest.fileprovider", photoFile); //解决4.0 List&lt;ResolveInfo&gt; resInfoList = getPackageManager() .queryIntentActivities(takePictureIntent, PackageManager.MATCH_DEFAULT_ONLY); for (ResolveInfo resolveInfo : resInfoList) &#123; String packageName = resolveInfo.activityInfo.packageName; grantUriPermission(packageName, photoURI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); &#125; takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI); startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO); &#125; &#125; &#125; FileProvider.getUriForFile()用来返回一个content：// URI。对于最新的针对Android 7.0（API级别24）的应用程序，通过一个包边界传递一个文件：// URI会导致FileUriExposedException鸿洋的博客关于android7.0 以及 4.0 拍照封装的处理(点击跳转) 取得结果 12345if (requestCode == REQUEST_TAKE_PHOTO &amp;&amp; resultCode == RESULT_OK) &#123; Bitmap imageBitmap = BitmapFactory.decodeFile(mCurrentPhotoPath); Log.e(TAG, "文件大小" + imageBitmap.getByteCount() / 1024 + "kb"); ((ImageView) findViewById(R.id.img)).setImageBitmap(imageBitmap);&#125; 将照片保存到相册如果你保存图片的路径是getExternalFilesDir() 媒体扫描器访问不到，只有你自己的应用可以访问，因此一下方法可以将图片保存到相册 1234567private void galleryAddPic() &#123; Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); File f = new File(mCurrentPhotoPath); Uri contentUri = Uri.fromFile(f); mediaScanIntent.setData(contentUri); this.sendBroadcast(mediaScanIntent);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-关于android UI适配的一些思考]]></title>
      <url>%2F2017%2F10%2F23%2Fandroid-ui-adapt-problems%2F</url>
      <content type="text"><![CDATA[关于xml中写死dp的思考首先我们应该先把问题抛出，如果我们在xml把控件的宽度和高度写死，比如 123456&lt;TextView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;50dp&quot; android:gravity=&quot;center&quot; android:text=&quot;asdasdasd&quot; /&gt; 相信大多时候都可以这么写，因为Android dp这个单位就是为了适配屏幕而出现的控件长度单位，它会让100dp在不同的手机不同的屏幕尺寸都有相似的表现。为什么是相似的表现而不是绝对的表现呢？因为不同的设备，横向和纵向所拥有的dp很可能是不同的，一般手机横向dp在360dp左右，也就是说，如果你写了一个宽度为180dp的控件，在一些手机可能有屏幕的一般宽，有一些手机超过一般，有一些手机不到一半。 我们写这样的一段代码，然后看一下xml的预览效果： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#123333&quot; android:id=&quot;@+id/container&quot; android:layout_width=&quot;360dp&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/LinearLayout&gt; 关于java动态写控件大小的思考我们看到360dp在不同设备的所表现的占屏比是不同的。如果我们写数值比较小的dp相信直接写死的问题不大。但是如果设计稿上某个控件的宽度你换算完刚好是340dp怎么，肯定不能写340dp。其实我们可以用match_parent然后用padding margin之类的东西，在左右留一个小数值dp的距离，来实现效果。但是如果这个控件要求是高度和宽度的比例是固定的，比如展示一个广告浮层的图片，那么xml估计就无法锁定宽高比了，我们就必须借助java代码来决定这个控件高度： 123456RelativeLayout.LayoutParams mLayoutParams = new RelativeLayout.LayoutParams (mHeight,mWidth);mLayoutParams.addRule(RelativeLayout.ALIGN_TOP, R.id.supernatant);mLayoutParams.addRule(RelativeLayout.ALIGN_LEFT, R.id.supernatant);bigSupernatantImgLayoutParams.setMargins(DPIUtil.dip2px(9f), 0, 0, 0);bigImg.setLayoutParams(mLayoutParams); 类似这样宽度和高度都是活的，我们可以通过获取屏幕的实际宽高像素，来通过等比，相似等一些算法，转换出比例和UI设计图一样的UI，但是最大的弊端应该就是，这么书写会让java代码比较多，比较乱。因此会有一些百分百布局框架等，其实思路都类似，等比缩放就是很核心思路。有个轻量的方法也就是写个工具类算出设计图到手机屏幕的转换关系： 1234567public static int getHeightByValue720(int mValue) &#123;return (int) ((float) (DPITools.getHeight() * nDesignValue) / (float) 1280); &#125;public static int getWidthByValue720(int mValue) &#123;return (int) ((float) (DPITools.getWidth() * nDesignValue) / (float) 720); &#125; 这个方法就是如果是720的设计稿，我们将设计稿的值转换为在所用设备下同比例的大小。这似乎很完美。如果设计给的控件大小是 100X200 ，那么如果运行在1080p的设配上。我们动态得到控件的大小是150X300.很开心，1080的横向纵向像素是720的1.5倍，控件也大了1.5倍这，的确没毛病。但是我们可能低估了安卓阵营了。 关于动态宽高写布局的一些思考。三星Galaxy S8分辨率： 2960*1440 (570 ppi) 如果按照上述方式我们在三星Galaxy S8上运行效果会是如何呢？结果是200X462。控件已经倍拉伸了，原因就是S8的屏幕比例不是16比9所以，按照原来的方式缩放，就会造成拉伸，为此市面上也有解决方案： 123public static int getValueByValue720(int mValue) &#123;return (int) ((float) (DPITools.getWidth() * nDesignValue) / (float) 720); &#125; 就是无论宽度还是高度，都是用宽度缩放，那么刚才控件在S8上得到的数值就是200X400.控件不会被拉伸，由于现在大多界面都是可以Scroll的，那么就算高度不标准问题也不大，我们比如一个listview我们保证在16比9的手机上，能正好展示4个item，在16比10的手机上展示3个半item，在18.5比9的设备上展示4个半item，这个设计产品还是用户都是可以接受的。 关于动态宽度为基准写布局的一些思考。然而关于方法三又存在一些问题，设想下面一个场景，页面里展示的是一个cardview，cardview的背景是一张图片，所以cardview宽高必须固定，这个cardview又是不允许上下滑动的，里面又有很多控件，在16比9的设计稿上，cardview里面的控件，排列整齐，最后也没什么太大的边界。 这样面临一个问题，如果在16比10的手机上，其实每次计算出的高度都是大于手机比例的，因此cardview后面的几个控件可能无法正常显示，或被拉伸。在18.5比9的手机上，cardview下面可能有空余，或者根据不同layout方式，可能其他地方有空余。我认为这还是可以接受的，比较这种手机是少数，但是控件被挤压就难以接受了。归纳起来也就说，如果这种不能上下滑动的view，可以让它有空余，但是不能让它挤压。我们可以使用一个保守的方法，判断手机是否是大于16比9，如果大于就说明手机比较瘦高，如果小于就说明手机比较胖。我们就可以用相对充裕的方法计算控件宽高，来保证控件不被挤压。 123456public static boolean bigThan169() &#123; float h = DPIUtil.getHeight(); float w = DPIUtil.getWidth(); if ((h / w) &gt; 1.78f) return true; else return false; &#125; 123if (bigThan169())newWidth = DPIUtil.getWidthByDesignValue720(DesignWidth);（以宽度为基准）else newWidth = DPIUtil.getHeightByDesignValue720(DesignWidth);（以高度为基准 从而保证控件上下高度够用） 总之就这就是一个保守，保证控件装得下的思路，若果是控件横向被挤压也是一样的。我们为了保证显示的下，缩小了控件。 总结：UI适配愈走愈远，有时也要和设计师产品经理协调，不要设计一些容易触发适配问题的页面，减少安卓端的适配压力，但是如果场景真的无法避免，我们就只能有更优雅的方式去解决适配问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-爱奇艺APK瘦身经验]]></title>
      <url>%2F2017%2F10%2F21%2Fandroid-apk-slimming%2F</url>
      <content type="text"><![CDATA[APK瘦身的价值用户常常避免下载太大的APP，尤其是使用移动流量的情况，而且太大的APP也会占用更多的内存并消耗更多的资源，导致安装速度和加载速度变慢，在低配手机上，这些情况尤其严重。 作为中国互联网领先的手机APP，爱奇艺非常重视APP客户端的用户体验，始终关注APK的体积，并持续的跟进优化。 目前爱奇艺Android APK大小指标在视频行业甚至整个移动互联网已经处于领先地位，下面是我们在APK瘦身之路上的一些经验分享。 APK组成结构在使用一些很酷的方法，来减少应用程序的大小之前，必须先了解实际的APK文件格式。 简单地说，APK是一个包含文件/文件夹的压缩文件。作为一个开发者，我们可以很容易的通过打开压缩文件的方式查看到APK里面的内容。 7zip打开APK后的视图 各个文件或文件夹的功能 文件/文件夹 作用/功能 res 包含所有没有被编译到.arsc里面的资源文件 lib 引用库的文件夹 assets assets文件夹相比于res文件夹，还有可能放字体文件、预置数据和web页面等,通过AssetManager访问 META_INF 存放的是签名信息，用来保证apk包的完整性和系统的安全。在生成一个APK的时候，会对所有的打包文件做一个校验计算，并把结果放在该目录下面 classes.dex 包含编译后的应用程序源码转化成的dex字节码。APK里面，可能会存在多个dex文件 resources.arsc 一些资源和标识符被编译和写入这个文件 Androidmanifest.xml 编译时，应用程序的AndroidManifest.xml被转化成二进制格式 爱奇艺 APK各组成部分的占比情况 通过爱奇艺Android客户端APK组成的饼状图可以看出，APK里面占较大比重的是libs,res,dex这三块。 APK瘦身方案通过上面的分析，已经了解了APK的基本构成。下面我们就采用多种手段进行APK瘦身 针对整体优化插件化从应用功能扩张的角度看，APK包体积的增大是必然的，然而插件技术的出现很好的解决了这个问题。 通过分离应用中比较独立的模块，然后以插件的形式进行加载，比如爱奇艺Android客户端有很多的相对独立的功能，游戏，漫画，文学，电影票，应用商店等，都是通过插件的方式，从服务器下载，然后以插件的方式加载到我们的主工程。 7ZIP压缩一般情况下面，AS直接编译生成的APK里面，.arsc文件是没有进行任何压缩的，前文中APK组成部分的第一张图就可以看出。 下面，我们来解压APK，重新用7zip进行压缩，就会发现几乎所有文件都变小了，特别是.arsc文件，减小的比较多。 对比7zip压缩前和压缩后APK里面文件的变化，可以看出通过7zip压缩，.arsc文件大概减小了2M多，其它文件/文件夹体积也减小了5%左右。 签名方式Google在Android7.0系统提供了新的apksigner签名工具，相比使用java提供的jarsigner签名工具，APK体积可以减小约5%（依赖文件数量）。 我们来看一下两种不同签名方式所带来的APK体积变化 第一个APK是未签名的，第二个是使用jarsigner签名的，第三个是使用apksigner签名生成。可以看出，使用apksigner签名比使用jarsigner签名生成的APK减小了1.1M。 那么再来看一下这两种APK签名后的文件大小差异在哪里 上图中间是未签名的APK,左边是jarsigner签名的,右边是apksigner签名的。 对比未签名的APK，用jarsigner签名工具签名，APK里面所有压缩后的文件和文件夹体积都增大了；而apksigner签名工具签名，除了META_INF文件夹增大了以外，其它文件和文件夹的大小都没有改变。 产生上述变化的原因是：jarsigner是针对每个文件进行了签名，然后针对签名后的文件计算摘要，并写入到META-INF文件夹下的MANIFEST.MF文件里面；而apksigner直接计算所有文件的摘要，写入MANIFEST.MF文件。 新的apksigner工具，已经集成到Android 7.0 SDK中了，使用方法可以参考官方文档 瘦身前后APK对比在不同的版本通过不同方式进行APK瘦身的详情图，如下： 插件化是2年前所做的优化，7zip压缩和签名方式都是最近的优化方案，并且通过jenkins自动化脚本实现的。 针对资源优化移除重复的资源一套资源Android在适配图片资源的时候，如果只有一套资源，低密度手机会缩放图片，高密度手机会拉伸图片。我们利用这个特性，存放一套资源图就可以供所有密度的手机使用。 综合考虑图片清晰度，静态大小和内存占用情况，一般采用xhdpi下的资源图片。 重复资源很多时候，随着工程的增大，以及开发人员的变动，有些资源文件名字不同，但是内容却完全相同。我们可以通过扫描文件的MD5值，找出名字不同，内容相同的图片并删除，做到图片不重复。 移除无用的资源由于项目的迭代以及UI改版等各种因素，会导致工程项目里面有许多无用的资源的存在，定期扫描处理无用资源。 通过Lint工具扫描工程资源当Lint工具扫描发现无用资源的时候，会输出如下的信息，就可以删除这种资源。 12res/layout/preferences.xml: Warning: The resource R.layout.preferences appears to be unused [UnusedResources] 需要特别注意的是，需要确保不存在反射，资源拼接等访问这些资源，才可以安全的删除掉这些资源，从而减小资源个数。 通过Gradle参数配置如果工程比较大，由主工程和多个子工程组成的话，子工程里面也可能包含很多的无用资源。可以通过设置shrinkResources=true让Gradle移走无用的资源，否则默认情况下，Gradle编译只会移除无用代码，而不会关心无用资源。 123456789101112android &#123; // Other settings buildTypes &#123; release &#123; minifyEnabled true shrinkResources true proguardFilesgetDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125; 需要特别注意的是shrinkResources依赖于minifyEnabled，必须和minifyEnabled一起用，即打开shrinkResources也必须打开minifyEnabled。 通过开源扫描工具大家可能会发现Lint不是非常好用，当工程里面存在反射，过滤结果非常麻烦。 所以我们实现了一个资源扫描的工具(https://github.com/zhuzhumouse/ScanUnusedResouce )，可以过滤掉通过反射调用的资源。 原理就是把所有java和xml文件以字符串扫描到内存，然后拿到资源文件（xml,png,jpg等）名称做匹配查找，如果没有匹配到，该资源就是无用资源，可以直接删除。 该扫描工具可以解决反射调用的问题，但是不能解决资源拼接的问题，还有就是不能处理存在很多资源前缀相同的情况。 png图片压缩可以通过使用图片压缩工具对png图片进行压缩,压缩效果比较好的工具有：pngcrush,pngquant,zopflipng等，可以在保持图片质量的前提下，缩减图片的大小。 还可以通过网站对图片进行压缩，如比较有名的www.tinypng.com，该网站对上传的图片自动选择合适的压缩算法，压缩比比较高，但是只支持500张免费图片，更多图片处理是要收费的。 采用WebP格式WebP分为有损压缩，无损压缩以及包含透明度的有损压缩。 有损WebP是基于VP8视频编码中的预测编码方法来压缩图像数据；无损WebP基于使用不同的技术对图像数据进行转换；有损WebP(支持透明度)区别于有损WebP和无损WebP，这种编码允许对RGB频道的有损编码同时可对透明度频道进行无损编码。 目前4.2及以上的手机系统已经支持WebP的无损和有损压缩，但是4.0,4.1的手机系统只支持不含透明度的有损压缩。如果应用支持的最低版本(minSdkVersion)是4.0，那么就只能针对不含透明度的图片进行WebP转换了。 在Android Studio 2.3版本及以上，我们可以选中 drawable 和 mipmap 文件夹，右键后选择 convert to webp，将图片转为 WebP 格式。如果Android Stuido版本比较低的话，可以直接通过官方提供的cwebp工具，将png转换为WebP。 下面是两张png转WebP的详情对比图 png (KB) WebP 75 (KB) WebP 90 (KB) 120 2.7 5.78 10 15 27 从以上两张样图的转换结果看，不是所有的图片都有高压缩比，有些图片压缩后反而会增大，比如第二张样图。WebP对色差比较小的图片，压缩比会比较高，任何一种压缩算法只能针对具有某种特点的图片进行压缩，没用万能压缩方法。 大背景图处理对清晰度要求高的大图片，采用单纯的压缩方法就不能满足UE的要求了，需要找到一种非压缩方式来解决这个问题。 纯色图+后台下载的方式很好的解决了这个问题，客户端先使用纯色图片，然后大图从后端下载，这样只是启动的前几次使用纯色图，以后都会使用大图。 Lottie动画库的使用动画，尤其是帧动画，一直都是相当占用资源的。现在可以通过Airbnb公司开源的Lottie动画库，直接用json文件来描述动画，然后直接加载绘制出来。 具体使用参考 其它资源策略 首先考虑能否不用图片，比如使用shape代码实现。 其次如果用图片的话，能否优先使用.9图来简化图片。 采用svg矢量图和VectorDrawable类来替换传统的图片。 如果图片只是旋转角度或者颜色不同，可以用代码实现变换。 资源瘦身前后APK对比爱奇艺客户端使用到的资源优化方案详情如图所示 目前爱奇艺客户端使用了这四种资源优化方式。 原来客户端xhdpi和xxhdpi下面有一部分重叠的资源，删除后包体积缩减了1M；移除无用资源是通过自己的扫描工具，获取无用资源列表，然后确认处理；pngquart压缩是打包过程中通过gradle自动化脚本实现的；WebP格式是通过python脚本，遍历查找不含透明度的图片，然后进行WebP转化替换原图片的。 针对代码优化上面已经详细的介绍了资源文件的优化方法，通过这些优化，包体积得到明显的缩减，下面我们再来讨论一下代码的优化。 代码混淆在gradle使用minifyEnabled进行Proguard混淆的配置，可大大减小APP大小： 1234567android &#123; buildTypes &#123; release &#123; minifyEnabled true proguardFile(&apos;groguard.cfg&apos;) &#125; &#125; 下面是代码混淆前后APK的详情 尤其需要注意的是：在proguard中，是否保留符号表对APP的大小是有显著的影响的，可酌情不保留，但是建议尽量保留用于调试。 无用代码扫描同无用资源扫描方式一样，可以针对无用的代码进行扫描，这里需要关注的一点就是在插件里面通过反射的方法调用的主应用的一些类和方法是不能删除的。 也可以使用SonarQube扫描无用类，以及不同类里面的重复代码。 详情请参考 剔除R文件随着项目中资源的增加，会发现生成的dex文件里面R.class文件越来越大。我们知道真正使用资源的地方都是以R.xxx.xxx这种方式访问的，而R.xxx.xx是对应于.arsc文件里面的一个常量值。arsc里面的内容具体如下： 字符串资源在.arsc文件里面的存储方式 Layout下面的Xml资源文件在.arsc文件里面的存储方式 通过这两张截图我们可以看出，直接用ID替换资源访问代码R.XXX.XXX，这样R.class文件就没有任何作用了，可以删除它，并且代码里面的资源访问字符串也变成了常量，两个方面都减小了dex的大小。 剔除R文件可以参考开源工具 注解替代枚举谷歌官方一直强烈推荐用注解替代枚举，一方面可以缩减包体积，另一方便可以节省内存开销。我们来对比一下，在使用注解和使用枚举两种情况下，生成的class文件内容。 枚举类型源码 123456789101112131415public enum MarkViewType3&#123; SIMPLE_TEXT_MARK, DO_LIKE_MARK, BOTTOM_BANNER1, BOTTOM_BANNER2, TL_GREY_BACKGROUND_RANK, /** *服务导航mark */ SERVICENAVIRIGHTMARK, /** *搜索页热点事件，标题、评论、事件 */ BOTTOM_COMPOUND_TEXT_BANNER&#125; 编译生成dex后的class文件 12345678910111213public enum MarkViewType3&#123; static &#123; DO_LIKE_MARK = new MarkViewType3("DO_LIKE_MARK", 1); BOTTOM_BANNER1 = new MarkViewType3("BOTTOM_BANNER1", 2); BOTTOM_BANNER2 = new MarkViewType3("BOTTOM_BANNER2", 3); TL_GREY_BACKGROUND_RANK = new MarkViewType3("TL_GREY_BACKGROUND_RANK", 4); SERVICENAVIRIGHTMARK = new MarkViewType3("SERVICENAVIRIGHTMARK", 5); BOTTOM_COMPOUND_TEXT_BANNER = new MarkViewType3("BOTTOM_COMPOUND_TEXT_BANNER", 6); $VALUES = new MarkViewType3[] &#123; SIMPLE_TEXT_MARK, DO_LIKE_MARK, BOTTOM_BANNER1, BOTTOM_BANNER2, TL_GREY_BACKGROUND_RANK, SERVICENAVIRIGHTMARK, BOTTOM_COMPOUND_TEXT_BANNER &#125;; &#125;&#125; 通过对比可以看到生成的class文件里面，每个变量都是一个对象，并且还有一个value对象数组。 注解的实现源码 1234567891011121314151617181920public class MarkViewType1&#123; public static final int SIMPLE_TEXT_MARK = 0; public static final int DO_LIKE_MARK = 1; public static final int BOTTOM_BANNER1 = 2; public static final int BOTTOM_BANNER2 = 3; public static final int TL_GREY_BACKGROUND_RANK = 4; /** *服务导航mark */ public static final int SERVICENAVIRIGHTMARK = 5; /** *搜索页热点事件，标题、评论、事件 */ public static final int BOTTOM_COMPOUND_TEXT_BANNER = 6; @IntDef (&#123;SIMPLE_TEXT_MARK, DO_LIKE_MARK, BOTTOM_BANNER1, BOTTOM_BANNER2, TL_GREY_BACKGROUND_RANK , SERVICENAVIRIGHTMARK, BOTTOM_COMPOUND_TEXT_BANNER&#125;) @Retention(RetentionPolicy.SOURCE) public @interface MarkViewType1Anno&#123; &#125;&#125; 生成的class文件 123456789101112131415public class MarkViewType1&#123; public static final int BOTTOM_BANNER1 = 2; public static final int BOTTOM_BANNER2 = 3; public static final int BOTTOM_COMPOUND_TEXT_BANNER = 6; public static final int DO_LIKE_MARK = 1; public static final int SERVICENAVIRIGHTMARK = 5; public static final int SIMPLE_TEXT_MARK = 0; public static final int TL_GREY_BACKGROUND_RANK = 4; @Retention(RetentionPolicy.SOURCE) public static @interface MarkViewType1Anno &#123; &#125;&#125; 注解生成的class文件只是一些常量。 通过上面的代码对比可以看出，常量+注解的形式，一方面可以减小生成的class文件的字节数，另一方面可以减小内存开销。 代码瘦身前和瘦身后APK对比爱奇艺客户端代码优化详情如图所示 由上图可以看出，代码混淆可以很大程度的减小包体积，尤其是引入了比较多点的第三方库的情况。所以打包的时候，应该开启代码混淆，以及资源混淆。 注解替代枚举，经过尝试，发现大量修改之后，对缩减包体积帮助不大，所以爱奇艺客户端没有采用该方案。 arsc文件优化在剔除R文件小节中，大家已经看到了.arsc文件内容格式。在整体优化小节中，已经对.arsc进行了比较大的优化，接下来分析一下其它优化方式。 可以采用混淆来缩减资源文件的名称，以及移除未使用的备用资源等方式来优化.arsc文件。如何移除未使用的备用资源，gradle里面 增加如下配置： 123456android &#123; defaultConfig &#123; ... resConfigs &quot;zh&quot;, &quot;zh_CN&quot;, &quot;zh_HK&quot;, &quot;zh_MO&quot;, &quot;zh_TW&quot;, &quot;en&quot; &#125;&#125; 通过该方式，爱奇艺客户端包体积可以缩减100多KB。 lib目录优化只提供对主流架构的支持，比如arm，对于mips和x86架构可以考虑不提供支持，系统会自动提供相应的兼容。爱奇艺客户端只在armeabi下面放置了一套so库文件。 除了插件化，客户端还是用了RN的方案，从而引入了RN的so库。由于RN的so库资源比较大，有2M多，进而引入了RN的so库的插件化。通过so库的插件化，来缩减包体积。RN库的插件化，包体积就缩减了1M多。 包瘦身详情总结通过上面所有方式进行瘦身，APK变化详情，如下图所示： 由上图可以看出，经过代码优化，资源优化，lib库优化，.arsc文件优化，及整体优化，包体积由54.2M缩减到28.2M。 瘦身过程中遇到的问题WebP支持问题WebP图片的转化过程中，一定要注意资源拼接的情况。 比如如果存在vip_1,vip_2,vip_3,vip_4,vip_5等五个资源，要么都转化成WebP,要么都不转，不能处理其中的一部分。 替换一些引导图的时候，一定要打包工具和客户端同时替换。如果客户端把引导图替换成了WebP格式，而打包的时候，由于不同步，该图片又被替换成png格式，就会导致资源加载不成功，进而程序崩溃。 签名方式使用apksigner签名工具前，必须先执行zipalign操作；而使用jarsigner签名工具则是先签名，然后再用zipalign优化。 小结目前爱奇艺Android客户端主要通过插件化、RN、签名方式、7zip压缩、保留一套资源、代码资源混淆、无用资源处理、剔除R文件、图片压缩等方式来缩减包体积，包体积整体缩减了20M多。 缩减包体积是一个长期的任务，未来还有很多事情需要做，比如定期扫描无用代码和资源资源、图片持续优化、矢量图、Lottie动画的大量使用等等，随着新技术的涌现，我们会有更多的方法去缩小包体积，使得应用更轻盈运行速度更快。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-轻松自制flyme悬浮球]]></title>
      <url>%2F2017%2F10%2F21%2Fandroid-suspend-ball%2F</url>
      <content type="text"><![CDATA[前言去年用了一整年的MX4Pro，魅族留给我最大的印象就是悬浮球了（质量问题我就不说了），左右滑动切换应用、上拉返回桌面、下拉打开通知栏、轻触返回…，一切都那么丝滑。然而自从上半年换成了s7dege，我感觉怎么也习惯不了没有悬浮球的生活了。 三星自己也有一个类似于悬浮球的功能，不过太过复杂，不易用，悬浮球本来就该是一个一步操作的产品，看来三星在软件设计方面还是任重而道远。于是乎我便在各大应用市场上找悬浮球，把所有排名靠前的悬浮球应用都安装试了一下，最后终于让我找到了一款几乎和flyme悬浮球相仿的app。 这款app在我手机里呆了好几个月，是我手机里除了微信之外，唯一允许自启动的应用了。很感谢这款app的开发者，不仅没有任何广告，还非常好用，完美移植了flyme自带的悬浮球功能。 然而渐渐的，我便感觉到了一丝不舒服，那就是我每次安装了一个新app，打开后提示要赋予权限（存储、拍照）的时候，6.0的系统总会温馨的弹出一个框： 然后我就必须到设置页面，花半天找到悬浮球，关掉它的“可出现在顶部的应用程”权限，然后才能回到app，授予权限。最后，我还得再次跑到设置页面，再花半天找到悬浮球，打开它的“可出现在顶部的应用程”权限。朋友啊朋友，这种体验，一次就够了，然而硬是让我体验了N次啊！ 然而有什么能难得倒程序员的呢？刚好这个周末在家无事，我决定按照自己的习惯，打造一个心目中最易用的悬浮球。 设计UIUI很简单，直接用sketch切了三个圆，一个是作为背景的灰色半透明的圆，一个是中心的小圆，另外还有一个默认隐藏的大圆。 功能因为自己的操作习惯是固定的，所以也就不需要给悬浮球添加自定义操作的功能了，直接将操作对应的功能写死即可。 单击：返回 长按：移动悬浮球 左滑右滑：打开最近应用程序 上拉：返回桌面 下拉： 这块我最先开始定义的很简单，就是下拉通知栏，但是经过一天的使用，我又给它加了一个功能，就是保持下拉状态1.5秒，将移除悬浮球。这样你便可以很简单的移除掉悬浮球了。 实现如何添加悬浮球到桌面这里首先要感谢郭霖大神的 《 Android桌面悬浮窗效果实现，仿360手机卫士悬浮窗效果》，这部分我参考了这篇文章，成功的将悬浮球添加到了桌面。 1234567891011121314151617181920public static void addBallView(Context context) &#123; if (mBallView == null) &#123; WindowManager windowManager = getWindowManager(context); int screenWidth = windowManager.getDefaultDisplay().getWidth(); int screenHeight = windowManager.getDefaultDisplay().getHeight(); mBallView = new FloatBallView(context); LayoutParams params = new LayoutParams(); params.x = screenWidth; params.y = screenHeight / 2; params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.height = WindowManager.LayoutParams.WRAP_CONTENT; params.gravity = Gravity.LEFT | Gravity.TOP; params.type = LayoutParams.TYPE_PHONE; params.format = PixelFormat.RGBA_8888; params.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL | LayoutParams.FLAG_NOT_FOCUSABLE; mBallView.setLayoutParams(params); windowManager.addView(mBallView, params); &#125;&#125; 手势判断这是最重要的部分了，承担着悬浮球的主要功能。 手指按下时按下时，隐藏小球，展现大球，并记录按下位置和按下时间。 1234567891011121314151617case MotionEvent.ACTION_DOWN: mIsTouching = true; mImgBall.setVisibility(INVISIBLE); mImgBigBall.setVisibility(VISIBLE); mLastDownTime = System.currentTimeMillis(); mLastDownX = event.getX(); mLastDownY = event.getY(); postDelayed(new Runnable() &#123; @Override public void run() &#123; if (isLongTouch()) &#123; mIsLongTouch = true; mVibrator.vibrate(mPattern, -1); &#125; &#125; &#125;, LONG_CLICK_LIMIT); break; 代码最后的postDealy时干嘛使的呢？就是通过延迟300毫秒，判断是否是长按模式。如果目前还没有处于其他模式，则可判断为长按，并震动提醒。 手指移动时这时要判断是否是处于长按状态，如果是，那么进入MOVE模式，移动悬浮球，如果不是，则判断操作手势，即下拉还是上拉等其他手势。 123456789101112131415case MotionEvent.ACTION_MOVE: if (!mIsLongTouch &amp;&amp; isTouchSlop(event)) &#123; return true; &#125; if (mIsLongTouch &amp;&amp; (mCurrentMode == MODE_NONE || mCurrentMode == MODE_MOVE)) &#123; mLayoutParams.x = (int) (event.getRawX() - mOffsetToParent); mLayoutParams.y = (int) (event.getRawY() - mOffsetToParentY); mWindowManager.updateViewLayout(FloatBallView.this, mLayoutParams); mBigBallX = mImgBigBall.getX(); mBigBallY = mImgBigBall.getY(); mCurrentMode = MODE_MOVE; &#125; else &#123; doGesture(event); &#125; break; 进行手势操作的代码如下，主要是根据当前坐标与按下时记录的坐标进行计算，判断手势，并更新大球位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void doGesture(MotionEvent event) &#123; float offsetX = event.getX() - mLastDownX; float offsetY = event.getY() - mLastDownY; if (Math.abs(offsetX) &lt; mTouchSlop &amp;&amp; Math.abs(offsetY) &lt; mTouchSlop) &#123; return; &#125; if (Math.abs(offsetX) &gt; Math.abs(offsetY)) &#123; if (offsetX &gt; 0) &#123; if (mCurrentMode == MODE_RIGHT) &#123; return; &#125; mCurrentMode = MODE_RIGHT; mImgBigBall.setX(mBigBallX + OFFSET); mImgBigBall.setY(mBigBallY); &#125; else &#123; if (mCurrentMode == MODE_LEFT) &#123; return; &#125; mCurrentMode = MODE_LEFT; mImgBigBall.setX(mBigBallX - OFFSET); mImgBigBall.setY(mBigBallY); &#125; &#125; else &#123; if (offsetY &gt; 0) &#123; if (mCurrentMode == MODE_DOWN || mCurrentMode == MODE_GONE) &#123; return; &#125; mCurrentMode = MODE_DOWN; mImgBigBall.setX(mBigBallX); mImgBigBall.setY(mBigBallY + OFFSET); //如果长时间保持下拉状态，将会触发移除悬浮球功能 postDelayed(new Runnable() &#123; @Override public void run() &#123; if (mCurrentMode == MODE_DOWN &amp;&amp; mIsTouching) &#123; toRemove(); mCurrentMode = MODE_GONE; &#125; &#125; &#125;, TO_APP_INDEX_LIMIT); &#125; else &#123; if (mCurrentMode == MODE_UP) &#123; return; &#125; mCurrentMode = MODE_UP; mImgBigBall.setX(mBigBallX); mImgBigBall.setY(mBigBallY - OFFSET); &#125; &#125;&#125; 手指抬起时手指抬起后，先要判断是否是长按模式，不是的话再判断是否是单击，都不是的话就根据当前状态触发对应功能。 1234567891011121314case MotionEvent.ACTION_CANCEL:case MotionEvent.ACTION_UP: mIsTouching = false; if (mIsLongTouch) &#123; mIsLongTouch = false; &#125; else if (isClick(event)) &#123; AccessibilityUtil.doBack(mService); &#125; else &#123; doUp(); &#125; mImgBall.setVisibility(VISIBLE); mImgBigBall.setVisibility(INVISIBLE); mCurrentMode = MODE_NONE; break; 魅族小米请注意！试了魅族pro5，先点击start-&gt;进入辅助功能界面-&gt;点击无障碍-&gt;开启FloatBall辅助功能。接着还要干一件事，就是魅族自己给悬浮窗加了权限，必须进入设置-&gt;应用管理-&gt;已安装中找到floatball-&gt;权限管理-&gt;开启悬浮窗权限，小米应该也是。此处不想吐槽国产ROM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-OOM案例分析]]></title>
      <url>%2F2017%2F10%2F20%2Fandroid-oom%2F</url>
      <content type="text"><![CDATA[在Android（Java）开发中，基本都会遇到java.lang.OutOfMemoryError（本文简称OOM），这种错误解决起来相对于一般的Exception或者Error都要难一些，主要是由于错误产生的root cause不是很显而易见。由于没有办法能够直接拿到用户的内存dump文件，如果错误发生在线上的版本，分析起来就会更加困难。本文从一个具体的案例切入，介绍OOM分析的思路及相关工具的使用。 案例背景在美团App 7.4~7.7版本期间，美食业务的OOM数量居高不下，远高于历史水平，主要都是DECODE本地的资源出错。 图中OOM数量为各版本发版后第一个月的统计量，包含新发版本及历史版本。对比了同时期其他业务的情况，也有类似OOM。由于美食业务的访问量占美团App的比重较大，因此，OOM的数量相对其他业务也多一些。 思路方案 在问题较为严重的7.6~7.7版本期间，团队对OOM频现的原因有过各种猜测。笔者怀疑过是否是业务上某些修改引起的，例如头图尺寸变大，或者是由页面模块加载方式引起的等等。但这些与OOM问题出现的时间并不吻合。其次也怀疑过是否由某些ROM的Bug导致，但此推断缺乏有力的证据支撑。因此，要找到OOM的root cause，根本途径还是找到谁占的内存最多，然后再根据具体case具体分析，为什么占了这么多。 采集用户手机内存信息 要分析内存的占用，需要内存的dump文件，但是dump文件一般都比较大，让用户配合上传dump文件不合适。所以希望能够运行时采集一些内存的特征然后随着crash日志上报上来。当用户发生OOM时，dump出用户的内存，然后基于com.squareup.haha:haha:2.0.3分析，得到一些关键数据（内存占用最多的实例及所占比例等）。但这个方案很快就被证明是不可行的。主要基于下面几个原因： 需要引入新的库。dump和分析内存都很耗时，效率难以接受。OOM时内存已经几乎耗尽，再加载内存dump文件并分析会导致二次OOM，得不偿失。模拟复现OOM 采集用户手机内存信息的方案不可行，那么只能采取复现用户场景的方式。由于发生OOM时，用户操作路径的不确定性，无法精确复现线上的OOM，因此采取模拟复现的方式，最终发生OOM时的栈信息基本一致即可。为了能够尽量模拟用户发生OOM的场景，需要基本条件基本一致，即用户使用的手机的各种相关参数。 挖掘OOM特征 分析7.4以来的OOM，列出发生OOM的机器的特征，主要是内存和分辨率，适当考虑其它因素例如系统版本。 机型 内存 分辨率 OS stack log OPPO N1(T/W) 2G 1920 * 1080 4.2.2 java.lang.OutOfMemoryError at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)||HM 2LTE-CMCC| 1G| 1280 720| 4.4.4| java.lang.OutOfMemoryErrorat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)||Newman CM810| 2G| 1920 1080| 4.4.4| java.lang.OutOfMemoryErrorat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)||LGL22| 2G| 1830 1080| 4.2.2| java.lang.OutOfMemoryErrorat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)||OPPO X909| 2G| 1920 1080| 4.2.2| java.lang.OutOfMemoryErrorat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)||Lenovo K900| 2G| 1920 1080| 4.2.2| java.lang.OutOfMemoryErrorat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)||GiONEE E6| 2G| 1920 1080| 4.2.1| java.lang.OutOfMemoryErrorat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)| 这些特征可以总结为：内存一般，分辨率偏高，OOM的堆栈log基本一致。其中，OPPO N1(T/W)上所发生的OOM比重较高，约为65%，因此选定这款机器作为复现OOM的机器。 关键数据（内存dump文件）需要复现OOM然后获取内存dump。思路是采取内存压力测试，让问题暴露的快速且充分。具体方案为： 选取图片资源多且较为复杂的页面，比如美食的POI详情页。 加载30次该页面，为了增加OOM的几率，30个POI页面的ID是不同的。 OOM发生后，使用Android Studio自带的Android Monitor dump出HPROF文件，然后使用SDK中的hprof-conv（位于sdk_root/platform-tools）工具转换为标准的Java堆转储文件格式，这样可以使用MAT（Eclipse Memory Analyzer）继续分析。 切到histogram视图，按shadow heap降序排列。 选取byte数组，右击-&gt;list objects-&gt;with incoming references，降序排列可以看到有很多大小一致的byte[]实例。 右击其中一个数组-&gt;Path to GC Roots-&gt; exclude xxx references 如上图所示，这些byte[]都是系统的EdgeEffect的drawable所持有，drawable对应的bitmap占用的空间为1566 406 4 = 2543184，与byte数组的大小一致。 再看另外一个： 这些byte[]是被App的一个背景图所持有，如下图： 通过ImageView的ID（如图）及build目录下的R.txt反查可知该ImageView的ID名称，即可知其设置的背景图的大小为720 200（xhdpi），加载到内存并考虑density，size刚好是1080 300 * 4 = 1296000，与byte数组大小一致。 数据分析为什么会出现这些大小一致的byte数组，或者说，为什么会创建多份EdgeEffect的drawable？查看EdgeEffect的源码（4.2.2）可知，其drawable成员也是通过Resources.getDrawable系统调用获取的。 1234567891011121314/** * Construct a new EdgeEffect with a theme appropriate for the provided context. * @param context Context used to provide theming and resource information for the EdgeEffect */public EdgeEffect(Context context) &#123; final Resources res = context.getResources(); mEdge = res.getDrawable(R.drawable.overscroll_edge); mGlow = res.getDrawable(R.drawable.overscroll_glow); ****** mMinWidth = (int) (res.getDisplayMetrics().density * MIN_WIDTH + 0.5f); mInterpolator = new DecelerateInterpolator();&#125; ImageView(View)获取background对应的drawable的过程类似。 123456789for (int i = 0; i &lt; N; i++) &#123; int attr = a.getIndex(i); switch (attr) &#123; case com.android.internal.R.styleable.View_background: background = a.getDrawable(attr); // TypedArray.getDrawable break; ****** &#125;&#125; 不论是Resources.getDrawable还是TypedArray.getDrawable，最终都会调用Resources.loadDrawable。继续看Resources.loadDrawable的源码，发现的确是使用了缓存。对于同一个drawable资源，系统只会加载一次，之后都会从缓存去取。 既然drawable的加载机制并没有问题，那么drawable所在的缓存实例或者获取drawable的Resources实例是否是同一个呢？通过下面的代码，打印出每个Activity的Resources实例及Resources实例的drawable cache。 12345//noinspection uncheckedLongSparseArray&lt;WeakReference&lt;Drawable.ConstantState&gt;&gt; cache = (LongSparseArray&lt;WeakReference&lt;Drawable.ConstantState&gt;&gt;) Hack.into(Resources.class).field("mDrawableCache").get(getResources());Object appCache = Hack.into(Resources.class).field("mDrawableCache").get(getApplication().getResources());Log.e("oom", "Resources: &#123;application=" + getApplication().getResources() + ", activity=" + getResources() + "&#125;");Log.e("oom", "Resources.mDrawableCache: &#123;application=" + appCache + ", activity=" + cache + "&#125;"); 这也进一步解释了另外一个现象，即这些大小相同的数组的个数基本和启动Activity的数量成正比。 通过数据分析可知，这些drawable之所以存在多份，是因为其所在的Resources实例并不是同一个。进一步debug可知，Resources实例存在多个的原因是开启了标志位sCompatVectorFromResourcesEnabled。虽然最终造成OOM突然增多的原因只是开启一个标志位，但是这也告诫大家阅读API文档的重要性，其实很多时候API的使用说明已经明确告知了使用的限制条件甚至风险。 7.8版本关闭了此标志，发版后第一个月的OOM数量（包含历史版本）为153，如下图。 其中新版本发生的OOM数量为22。 总结对于线上出现的OOM，如何分析和解决可以大致分为三个步骤： 充分挖掘特征。在挖掘特征时，需要多方面考虑，此过程更多的是猜测怀疑，所以可能的方面都要考虑到，包括但不限于代码改动、机器特征、时间特征等，必要时还需要做一定的统计分析。 根据掌握的特征寻找稳定的复现的途径。一般需要做内存压力测试，这样比较容易达到OOM的临界值，只是简单的一些正常操作难以触发OOM。 获取可分析的数据（内存dump文件）。利用MAT分析dump文件，MAT可以方便的按照大小排序实例，可以查看某些实例到GC ROOT的路径。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-全面解析 Application类]]></title>
      <url>%2F2017%2F10%2F20%2Fandroid-application%2F</url>
      <content type="text"><![CDATA[前言Applicaiton类在 Android开发中非常常见，可是你真的了解Applicaiton类吗？本文将全面解析Applicaiton类，包括特点、方法介绍、应用场景和具体使用，希望你们会喜欢。 目录 定义 代表应用程序（即 Android App）的类，也属于Android中的一个系统组件 继承关系：继承自 ContextWarpper 类 特点实例创建方式：单例模式 每个Android App运行时，会首先自动创建Application 类并实例化 Application 对象，且只有一个 即 Application类 是单例模式（singleton）类 也可通过 继承 Application 类自定义Application 类和实例 实例形式：全局实例即不同的组件（如Activity、Service）都可获得Application对象且都是同一个对象 生命周期：等于 Android App 的生命周期Application 对象的生命周期是整个程序中最长的，即等于Android App的生命周期 方法介绍那么，该 Application 类有什么作用呢？下面，我将介绍Application 类的方法使用 onCreate（） 调用时刻： Application 实例创建时调用 Android系统的入口是Application类的 onCreate（），默认为空实现 作用 初始化 应用程序级别 的资源，如全局对象、环境配置变量、图片资源初始化、推送服务的注册等 注：请不要执行耗时操作，否则会拖慢应用程序启动速度 数据共享、数据缓存设置全局共享数据，如全局共享变量、方法等 注：这些共享数据只在应用程序的生命周期内有效，当该应用程序被杀死，这些数据也会被清空，所以只能存储一些具备 临时性的共享数据 具体使用 1234567891011// 复写方法需要在Application子类里实现private static final String VALUE = "Carson"; // 初始化全局变量 @Override public void onCreate() &#123; super.onCreate(); VALUE = 1; &#125;&#125; registerComponentCallbacks（） &amp; unregisterComponentCallbacks（） 作用：注册和注销 ComponentCallbacks2回调接口 本质上是复写 ComponentCallbacks2回调接口里的方法从而实现更多的操作，具体下面会详细介绍 具体使用 1234567891011121314151617registerComponentCallbacks(new ComponentCallbacks2() &#123;// 接口里方法下面会继续介绍 @Override public void onTrimMemory(int level) &#123; &#125; @Override public void onLowMemory() &#123; &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; &#125; &#125;); onTrimMemory（） 作用：通知 应用程序 当前内存使用情况（以内存级别进行识别） Android 4.0 后提供的一个API 应用场景：根据当前内存使用情况进行自身的内存资源的不同程度释放，以避免被系统直接杀掉 &amp; 优化应用程序的性能体验 系统在内存不足时会按照LRU Cache中从低到高杀死进程；优先杀死占用内存较高的应用 若应用占用内存较小 = 被杀死几率降低，从而快速启动（即热启动 = 启动速度快） 可回收的资源包括： 缓存，如文件缓存，图片缓存 动态生成 &amp; 添加的View 典型的应用场景有两个： 具体使用 12345678910111213141516registerComponentCallbacks(new ComponentCallbacks2() &#123;@Override public void onTrimMemory(int level) &#123; // Android系统会根据当前内存使用的情况，传入对应的级别 // 下面以清除缓存为例子介绍 super.onTrimMemory(level); . if (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) &#123; mPendingRequests.clear(); mBitmapHolderCache.evictAll(); mBitmapCache.evictAll(); &#125; &#125;); 可回调对象 &amp; 对应方法 12345Application.onTrimMemory()Activity.onTrimMemory()Fragment.OnTrimMemory()Service.onTrimMemory()ContentProvider.OnTrimMemory() 特别注意：onTrimMemory()中的TRIM_MEMORY_UI_HIDDEN与onStop（）的关系 onTrimMemory()中的TRIM_MEMORY_UI_HIDDEN的回调时刻：当应用程序中的所有UI组件全部不可见时 Activity的onStop（）回调时刻：当一个Activity完全不可见的时候 使用建议： 在 onStop（）中释放与 Activity相关的资源，如取消网络连接或者注销广播接收器等 在onTrimMemory()中的TRIM_MEMORY_UI_HIDDEN中释放与UI相关的资源，从而保证用户在使用应用程序过程中，UI相关的资源不需要重新加载，从而提升响应速度 注：onTrimMemory的TRIM_MEMORY_UI_HIDDEN等级是在onStop（）方法之前调用的 onLowMemory（） 作用：监听 Android系统整体内存较低时刻 调用时刻：Android系统整体内存较低时 12345678registerComponentCallbacks(new ComponentCallbacks2() &#123; @Override public void onLowMemory() &#123; &#125; &#125;); 应用场景：Android 4.0前 检测内存使用情况，从而避免被系统直接杀掉 &amp; 优化应用程序的性能体验 类似于 OnTrimMemory（） 特别注意：OnTrimMemory（） &amp; OnLowMemory（） 关系 OnTrimMemory（）是 OnLowMemory（） Android 4.0后的替代 API OnLowMemory（） = OnTrimMemory（）中的TRIM_MEMORY_COMPLETE级别 若想兼容Android 4.0前，请使用OnLowMemory（）；否则直接使用OnTrimMemory（）即可 onConfigurationChanged（） 作用：监听 应用程序 配置信息的改变，如屏幕旋转等 调用时刻：应用程序配置信息 改变时调用 具体使用 12345678registerComponentCallbacks(new ComponentCallbacks2() &#123; @Override public void onConfigurationChanged(Configuration newConfig) &#123; ... &#125; &#125;); 该配置信息是指 ：Manifest.xml文件下的 Activity标签属性android:configChanges的值，如下： 12345&lt;activity android:name=&quot;.MainActivity&quot;&gt; android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;// 设置该配置属性会使 Activity在配置改变时不重启，只执行onConfigurationChanged（）// 上述语句表明，设置该配置属性可使 Activity 在屏幕旋转时不重启 &lt;/activity&gt; registerActivityLifecycleCallbacks（） &amp; unregisterActivityLifecycleCallbacks（） 作用：注册 / 注销对 应用程序内 所有Activity的生命周期监听 调用时刻：当应用程序内 Activity生命周期发生变化时就会调用 实际上是调用registerActivityLifecycleCallbacks（）里 ActivityLifecycleCallbacks接口里的方法 具体使用 123456789101112131415161718192021222324252627282930313233343536373839404142// 实际上需要复写的是ActivityLifecycleCallbacks接口里的方法registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() &#123; @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) &#123; Log.d(TAG,"onActivityCreated: " + activity.getLocalClassName()); &#125; @Override public void onActivityStarted(Activity activity) &#123; Log.d(TAG,"onActivityStarted: " + activity.getLocalClassName()); &#125; @Override public void onActivityResumed(Activity activity) &#123; Log.d(TAG,"onActivityResumed: " + activity.getLocalClassName()); &#125; @Override public void onActivityPaused(Activity activity) &#123; Log.d(TAG,"onActivityPaused: " + activity.getLocalClassName()); &#125; @Override public void onActivityStopped(Activity activity) &#123; Log.d(TAG, "onActivityStopped: " + activity.getLocalClassName()); &#125; @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState) &#123; &#125; @Override public void onActivityDestroyed(Activity activity) &#123; Log.d(TAG,"onActivityDestroyed: " + activity.getLocalClassName()); &#125; &#125;);&lt;-- 测试：把应用程序从前台切到后台再打开，看Activcity的变化 --&gt; onActivityPaused: MainActivity onActivityStopped: MainActivity onActivityStarted: MainActivity onActivityResumed: MainActivity onTerminate（）调用时刻：应用程序结束时调用 但该方法只用于Android仿真机测试，在Android产品机是不会调用的 应用场景从Applicaiton类的方法可以看出，Applicaiton类的应用场景有：（已按优先级排序） 初始化 应用程序级别 的资源，如全局对象、环境配置变量等 数据共享、数据缓存，如设置全局共享变量、方法等 获取应用程序当前的内存使用情况，及时释放资源，从而避免被系统杀死 监听 应用程序 配置信息的改变，如屏幕旋转等 监听应用程序内 所有Activity的生命周期 具体使用 若需要复写实现上述方法，则需要自定义 Application类 具体过程如下 步骤1：新建Application子类 即继承 Application 类 123456789101112131415161718public class CarsonApplication extends Application &#123; ... // 根据自身需求，并结合上述介绍的方法进行方法复写实现 // 下面以onCreate()为例 private static final String VALUE = "Carson"; // 初始化全局变量 @Override public void onCreate() &#123; super.onCreate(); VALUE = 1; &#125; &#125; 步骤2：配置自定义的Application子类 在Manifest.xml文件中 标签里进行配置 Manifest.xml 123456&lt;application android:name=&quot;.CarsonApplication&quot; // 此处自定义Application子类的名字 = CarsonApplication &lt;/application&gt; 步骤3：使用自定义的Application类实例 1234567private CarsonApplicaiton app;// 只需要调用Activity.getApplication（） 或Context.getApplicationContext（）就可以获得一个Application对象app = (CarsonApplication) getApplication();// 然后再得到相应的成员变量 或方法 即可app.exitApp(); 至此，关于 Applicaiton 类已经讲解完毕。 总结我用一张图总结上述文章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-底部Tab菜单栏]]></title>
      <url>%2F2017%2F10%2F18%2Fandroid-bottom_tab%2F</url>
      <content type="text"><![CDATA[前言Android开发中使用底部菜单栏的频次非常高，主要的实现手段有以下： TabWidget 隐藏TabWidget，使用RadioGroup和RadioButton FragmentTabHost 5.0以后的TabLayout 最近推出的 Bottom navigation 今天带大家来探索下如何用Fragment+FragmentTabHost++ViewPager实现底部菜单栏 总体设计思路 Fragment：存放不同选项的页面内容 FragmentTabHost：点击切换选项卡 ViewPager：实现页面的左右滑动效果 概念介绍FragmentTabHost用于实现点击选项进行切换选项卡的自定义效果 使用FragmentTabHost，就是先用TabHost“装着”Fragment，然后放进MainActivity里面 ViewPager 定义ViewPager是android扩展包v4包中的类 android.support.v4.view.ViewPager 作用左右切换当前的view，实现滑动切换的效果。 注：1.ViewPager类直接继承了ViewGroup类，和LinearLayout等布局一样，都是一个容器，需要在里面添加我们想要显示的内容。2.ViewPager类需要PagerAdapter适配器类提供数据，与ListView类似3.Google官方建议ViewPager配合Fragment使用 Fragment 定义Fragment是activity的界面中的一部分或一种行为 1.把Fragment认为模块化的一段activity2.它具有自己的生命周期，接收它自己的事件，并可以在activity运行时被添加或删除3.Fragment不能独立存在，它必须嵌入到activity中，而且Fragment的生命周期直接受所在的activity的影响。例如：当activity暂停时，它拥有的所有的Fragment们都暂停了，当activity销毁时，它拥有的所有Fragment们都被销毁。 作用主要是为了支持更动态、更灵活的界面设计（从3.0开始引入） 实现步骤 在主xml布局里面定义一个FragmentTabHost控件 定义底部菜单栏布局 定义每个Fragment布局 定义每个Fragment的Java类 定义适配器以关联页卡和ViewPage 定义MainActivity（具体实现请看注释） 工程文件目录 具体实现实例步骤1：在主xml布局里面定义一个FragmentTabHost控件主xml布局：Main_tab_layout.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:orientation=&quot;vertical&quot; &gt; &lt;include layout=&quot;@layout/main_top&quot; /&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; /&gt;&lt;!--装4个Fragment--&gt; &lt;FrameLayout android:visibility=&quot;gone&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;!--定义FragmentTabHost控件--&gt; &lt;android.support.v4.app.FragmentTabHost android:id=&quot;@android:id/tabhost&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/black&quot; &gt;&lt;!--装4个Fragment--&gt; &lt;FrameLayout android:id=&quot;@android:id/tabcontent&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;0&quot; /&gt;&lt;!--装Tab的内容--&gt; &lt;/android.support.v4.app.FragmentTabHost&gt;&lt;/RelativeLayout&gt; 步骤2：定义底部菜单栏布局tab_content.xml 一般是图片在上，文字在下 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot; android:background=&quot;#ffffff&quot;&gt; &lt;ImageView android:id=&quot;@+id/tab_imageview&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;TextView android:id=&quot;@+id/tab_textview&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;&quot; android:textColor=&quot;@drawable/selector_text_background&quot; /&gt;&lt;/LinearLayout&gt; 步骤3：定义Fragment布局fragment_item1.xml&amp;fragment_item2.xml 这里使用两个选项，由于fragment_item1.xml与fragment_item2.xml相同，这里只贴出一个 fragment_item1.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;fragment1&quot; android:textSize=&quot;20sp&quot;/&gt;&lt;/LinearLayout&gt; 步骤4： 定义每个Fragment的Java类 1.这里使用两个选项：Fragment1.java&amp;fragmen2.java2.由于Fragment1.java&amp;fragmen2.java相同，这里只贴出一个 Fragment1.java 1234567891011121314151617181920package com.example.carson_ho.tab_menu_demo;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;/** * Created by Carson_Ho on 16/5/23. */public class Fragment1 extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_item1, null); return view; &#125;&#125; 步骤5： 定义适配器关联页卡和ViewPageMyFragmentAdapter.java 12345678910111213141516171819202122232425262728293031323334package com.example.carson_ho.tab_menu_demo;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import java.util.List;/** * Created by Carson_Ho on 16/5/23. */public class MyFragmentAdapter &#123;extends FragmentPagerAdapter &#123; List&lt;Fragment&gt; list; public MyFragmentAdapter(FragmentManager fm,List&lt;Fragment&gt; list) &#123; super(fm); this.list=list; &#125;//写构造方法，方便赋值调用 @Override public Fragment getItem(int arg0) &#123; return list.get(arg0); &#125;//根据Item的位置返回对应位置的Fragment，绑定item和Fragment @Override public int getCount() &#123; return list.size(); &#125;//设置Item的数量 &#125; 步骤6： 定义MainActivity具体实现看注释MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.example.carson_ho.tab_menu_demo;import android.os.Bundle;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentActivity;import android.support.v4.app.FragmentTabHost;import android.support.v4.view.ViewPager;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ImageView;import android.widget.TabHost;import android.widget.TabWidget;import android.widget.TextView;import java.util.ArrayList;import java.util.List;public class MainActivity extends FragmentActivity implements ViewPager.OnPageChangeListener, TabHost.OnTabChangeListener &#123; private FragmentTabHost mTabHost; private LayoutInflater layoutInflater; private Class fragmentArray[] = &#123; Fragment1.class, Fragment2.class &#125;; private int imageViewArray[] = &#123; R.drawable.tab_home_btn, R.drawable.tab_view_btn &#125;; private String textViewArray[] = &#123; &quot;首页&quot;, &quot;分类&quot;&#125;; private List&lt;Fragment&gt; list = new ArrayList&lt;Fragment&gt;(); private ViewPager vp; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView();//初始化控件 initPage();//初始化页面 &#125; // 控件初始化控件 private void initView() &#123; vp = (ViewPager) findViewById(R.id.pager); /*实现OnPageChangeListener接口,目的是监听Tab选项卡的变化，然后通知ViewPager适配器切换界面*/ /*简单来说,是为了让ViewPager滑动的时候能够带着底部菜单联动*/ vp.addOnPageChangeListener(this);//设置页面切换时的监听器 layoutInflater = LayoutInflater.from(this);//加载布局管理器 /*实例化FragmentTabHost对象并进行绑定*/ mTabHost = (FragmentTabHost) findViewById(android.R.id.tabhost);//绑定tahost mTabHost.setup(this, getSupportFragmentManager(), R.id.pager);//绑定viewpager /*实现setOnTabChangedListener接口,目的是为监听界面切换），然后实现TabHost里面图片文字的选中状态切换*/ /*简单来说,是为了当点击下面菜单时,上面的ViewPager能滑动到对应的Fragment*/ mTabHost.setOnTabChangedListener(this); int count = textViewArray.length; /*新建Tabspec选项卡并设置Tab菜单栏的内容和绑定对应的Fragment*/ for (int i = 0; i &lt; count; i++) &#123; // 给每个Tab按钮设置标签、图标和文字 TabHost.TabSpec tabSpec = mTabHost.newTabSpec(textViewArray[i]) .setIndicator(getTabItemView(i)); // 将Tab按钮添加进Tab选项卡中，并绑定Fragment mTabHost.addTab(tabSpec, fragmentArray[i], null); mTabHost.setTag(i); mTabHost.getTabWidget().getChildAt(i) .setBackgroundResource(R.drawable.selector_tab_background);//设置Tab被选中的时候颜色改变 &#125; &#125; /*初始化Fragment*/ private void initPage() &#123; Fragment1 fragment1 = new Fragment1(); Fragment2 fragment2 = new Fragment2(); list.add(fragment1); list.add(fragment2); //绑定Fragment适配器 vp.setAdapter(new MyFragmentAdapter(getSupportFragmentManager(), list)); mTabHost.getTabWidget().setDividerDrawable(null); &#125; private View getTabItemView(int i) &#123; //将xml布局转换为view对象 View view = layoutInflater.inflate(R.layout.tab_content, null); //利用view对象，找到布局中的组件,并设置内容，然后返回视图 ImageView mImageView = (ImageView) view .findViewById(R.id.tab_imageview); TextView mTextView = (TextView) view.findViewById(R.id.tab_textview); mImageView.setBackgroundResource(imageViewArray[i]); mTextView.setText(textViewArray[i]); return view; &#125; @Override public void onPageScrollStateChanged(int arg0) &#123; &#125;//arg0 ==1的时候表示正在滑动，arg0==2的时候表示滑动完毕了，arg0==0的时候表示什么都没做，就是停在那。 @Override public void onPageScrolled(int arg0, float arg1, int arg2) &#123; &#125;//表示在前一个页面滑动到后一个页面的时候，在前一个页面滑动前调用的方法 @Override public void onPageSelected(int arg0) &#123;//arg0是表示你当前选中的页面位置Postion，这事件是在你页面跳转完毕的时候调用的。 TabWidget widget = mTabHost.getTabWidget(); int oldFocusability = widget.getDescendantFocusability(); widget.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);//设置View覆盖子类控件而直接获得焦点 mTabHost.setCurrentTab(arg0);//根据位置Postion设置当前的Tab widget.setDescendantFocusability(oldFocusability);//设置取消分割线 &#125; @Override public void onTabChanged(String tabId) &#123;//Tab改变的时候调用 int position = mTabHost.getCurrentTab(); vp.setCurrentItem(position);//把选中的Tab的位置赋给适配器，让它控制页面切换 &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-过渡动画学习]]></title>
      <url>%2F2017%2F10%2F18%2Fandroid-transition-animations%2F</url>
      <content type="text"><![CDATA[概述Android 4.4.2 (API level 19)引入Transition框架，之后很多APP上都使用该框架做出很酷炫的效果，如 Google Play Newsstand app 还有github上很火的plaid 在app中适当得使用上Transition能带来较好的用户体验，视频中介绍了该框架的基本使用以及其中核心的一些类和方法，只有学会这些基本的API才能在之后的Activity/Fragment过渡定制一些自己想要的效果。 先看官网的一张关系图 图中有三个核心的类，分别是Scene、Transition和TransitionManager，下面对这个三个核心类展开分析。 Scene Scene场景，用于保存布局中所有View的属性值，创建Scene的方式可以通过getSceneForLayout方法 getSceneForLayout(ViewGroup sceneRoot, int layoutId, Context context) 比如： 12mScene0 = Scene.getSceneForLayout(mSceneRoot, R.layout.scene0, getContext());mScene1 = Scene.getSceneForLayout(mSceneRoot, R.layout.scene1, getContext()); 也可以直接new Scene(ViewGroup sceneRoot, View layout) 1234View view0 = inflater.inflate(R.layout.scene0, container, false);View view1 = inflater.inflate(R.layout.scene1, container, false);mScene0 = new Scene(mSceneRoot, view0);mScene1 = new Scene(mSceneRoot, view1); 两种方式都需要传SceneRoot，即该场景的根节点。 Transition Transition过渡动画，前面创建了两个场景，分别保存了视图的一些属性，比如Visibility、position等，Transition就是对于这些属性值的改变定义过渡的效果。从上图可以看到系统内置了一些常用的Transition，Transition的创建可以通过加载xml，如： res/transition/fade_transition.xml &lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; /&gt; 然后在代码中： 123Transition mFadeTransition = TransitionInflater.from(this). inflateTransition(R.transition.fade_transition); 或者直接在代码中： Transition mFadeTransition = new Fade(); TransitionManagerTransitionManeger用于将Scene和Transition联系起来，它提供了一系列的方法如setTransition(Scene fromScene, Scene toScene, Transition transition)指明起始场景和结束场景、他们的过渡动画是什么，go(Scene scene, Transition transition)，到指定的场景所使用的过渡动画是什么，beginDelayedTransition(ViewGroup sceneRoot, Transition transition)，在当前场景到下一帧的过渡效果是什么。比如这里使用go()方法，效果: 注意这里两个Scene中红绿两个方块除了位置和大小不一样，id是一致的，transition记录下两个Scene前后属性值，根据属性值的改变执行过渡动画，默认情况下对SceneRoot下的所有View执行动画效果，我们可以通过Transition.addTarget和removeTarget方法选择性添加或移除执行动画的View。 常用API有时候我们只想改变当前已展示的视图层级中View的状态，可以通过beginDelayedTransition实现，下面列举系统内置的Transition的使用。 AutoTransitionAutoTransition默认的动画效果，对应xml tag为autoTransition 其实是以下几个动画组合顺序执行： 123456&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:transitionOrdering=&quot;sequential&quot;&gt; &lt;fade android:fadingMode=&quot;fade_out&quot; /&gt; &lt;changeBounds /&gt; &lt;fade android:fadingMode=&quot;fade_in&quot; /&gt;&lt;/transitionSet&gt; 在代码中使用： 123456TransitionManager.beginDelayedTransition(mRoot, new AutoTransition()); if (mTextView.getVisibility() != View.VISIBLE) &#123; mTextView.setVisibility(View.VISIBLE); &#125; else &#123; mTextView.setVisibility(View.GONE); &#125; ChangeBoundsChangeBounds对应xml tag为changeBounds，根据前后布局界限的变化执行动画 12345678TransitionManager.beginDelayedTransition(mRoot, new ChangeBounds());FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mTarget.getLayoutParams();if ((lp.gravity &amp; Gravity.START) == Gravity.START) &#123; lp.gravity = Gravity.BOTTOM | Gravity.END;&#125; else &#123; lp.gravity = Gravity.TOP | Gravity.START;&#125;mTarget.setLayoutParams(lp); ChangeClipBoundsChangeClipBounds对应xml tag为changeClipBounds，作用对象：View的getClipBounds()值 1234567Rect BOUNDS = new Rect(20, 20, 100, 100);TransitionManager.beginDelayedTransition(mRoot, new ChangeClipBounds());if (BOUNDS.equals(ViewCompat.getClipBounds(mImageView))) &#123; ViewCompat.setClipBounds(mImageView, null);&#125; else &#123; ViewCompat.setClipBounds(mImageView, BOUNDS);&#125; ChangeImageTransform对应xml tag为changeImageTransform，作用对象：ImageView的matrix 12TransitionManager.beginDelayedTransition(mRoot, new ChangeImageTransform());mImageView.setScaleType(ImageView.ScaleType.XXX); ChangeScroll对应xml tag为changeScroll，作用对象：View的scroll属性值 12TransitionManager.beginDelayedTransition(mRoot, new ChangeScroll());mTarget.scrollBy(-100, -100); ChangeTransform对应xml tag 为changeTransform，作用对象：View的scale和rotation 1234567891011121314TransitionManager.beginDelayedTransition(mRoot, new ChangeTransform());if (mContainer2.getChildCount() &gt; 0) &#123; mContainer2.removeAllViews(); showRedSquare(mContainer1);&#125; else &#123; mContainer1.removeAllViews(); showRedSquare(mContainer2); mContainer2.getChildAt(0).setRotation(45);&#125;private void showRedSquare(FrameLayout container) &#123; final View view = LayoutInflater.from(getContext()) .inflate(R.layout.red_square, container, false); container.addView(view);&#125; Explode对应xml tag为explode，作用对象：View的Visibility 12345TransitionManager.beginDelayedTransition(mRoot, new Explode());int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;for (View view : mViews) &#123; view.setVisibility(vis);&#125; Fade对应xml tag为fade，作用对象：View的Visibility 可以在初始化时指定IN或者OUT分别对应淡入和淡出，也可以通过fade.setMode方法设置，若不指定默认为淡入淡出效果 12345TransitionManager.beginDelayedTransition(mRoot, new Fade());int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;for (View view : mViews) &#123; view.setVisibility(vis);&#125; Slide对应xml tag为slide，作用对象：View的Visibility 可以初始化时传入Gravity.XX，也可以通过slide.setSlideEdge方法设置，默认方向为Gravity.BOTTOM 12345TransitionManager.beginDelayedTransition(mRoot, new Slide());int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;for (View view : mViews) &#123; view.setVisibility(vis);&#125; TransitionSet对应xml tag为transitionSet 可以在代码中创建transitionSet如： 123456789101112mTransition = new TransitionSet();mTransition.addTransition(new ChangeImageTransform());mTransition.addTransition(new ChangeTransform());TransitionManager.beginDelayedTransition(mOuterFrame, mTransition); if (mInnerFrame.getChildCount() &gt; 0) &#123; mInnerFrame.removeAllViews(); addImageView(mOuterFrame, ImageView.ScaleType.CENTER_CROP, mPhotoSize); &#125; else &#123; mOuterFrame.removeViewAt(1); addImageView(mInnerFrame, ImageView.ScaleType.FIT_XY, FrameLayout.LayoutParams.MATCH_PARENT); &#125; 也可以通过加载xml布局创建transitionSet： xml布局长这样： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:transitionOrdering=&quot;together&quot;&gt; &lt;changeImageTransform/&gt; &lt;changeTransform/&gt;&lt;/transitionSet&gt; 通过transitionOrdering属性设置动画执行的顺序，together表示同时执行，sequential表示顺序执行，在代码中可以调用TransitionSet的setOrdering(int)方法，属性值传ORDERING_SEQUENTIAL或者ORDERING_TOGETHER 在代码中： 12345678910mTransition = (TransitionSet) TransitionInflater.from(getContext()).inflateTransition(R.transition.transition);TransitionManager.beginDelayedTransition(mOuterFrame, mTransition); if (mInnerFrame.getChildCount() &gt; 0) &#123; mInnerFrame.removeAllViews(); addImageView(mOuterFrame, ImageView.ScaleType.CENTER_CROP, mPhotoSize); &#125; else &#123; mOuterFrame.removeViewAt(1); addImageView(mInnerFrame, ImageView.ScaleType.FIT_XY, FrameLayout.LayoutParams.MATCH_PARENT); &#125; 这里结合changeImageTransform和changeTransform，效果如下： PathMotion Transition的辅助工具，以path的方式指定过渡效果，两个具体实现类ArcMotion和PatternPathMotion，看下ArcMotion的效果 12345678910mTransition = new AutoTransition();mTransition.setPathMotion(new ArcMotion());TransitionManager.beginDelayedTransition(mRoot, mTransition); FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mTarget.getLayoutParams(); if ((lp.gravity &amp; Gravity.START) == Gravity.START) &#123; lp.gravity = Gravity.END | Gravity.BOTTOM; &#125; else &#123; lp.gravity = Gravity.START | Gravity.TOP; &#125; mTarget.setLayoutParams(lp); 它的运动轨迹是条曲线，有兴趣的可以研究下它的实现算法，在源码中有个很萌的图如下： 自定义Transition除了系统内置的Transition，我们还可以自定义Transition效果，需要继承Transition 12345678910public class CustomTransition extends Transition &#123; @Override public void captureStartValues(TransitionValues values) &#123;&#125; @Override public void captureEndValues(TransitionValues values) &#123;&#125; @Override public Animator createAnimator(ViewGroup sceneRoot, TransitionValues startValues, TransitionValues endValues) &#123;&#125;&#125; 其工作原理是在captureStartValues和captureEndValues中分别记录View的属性值，官网建议确保属性值不冲突，属性值的命名格式参考： package_name:transition_name:property_name 在createAnimator中创建动画，对比属性值的改变执行动画效果，如自定义修改颜色动画效果： 在两个Scene中使用自定义过渡动画，效果如下： Note Android 版本在4.0(API Level 14)到4.4.2(API Level 19)使用Android Support Library’s 对于 SurfaceView可能不起效果，因为SurfaceView的实例是在非UI线程更新的，因此会造成和其他视图动画不同步。 某些特定的转换类型在应用到TextureView时可能不会产生所需的动画效果。 继承自AdapterView的如ListView，与该框架不兼容。 不要对包含文本的视图的大小进行动画 示例过渡动画在界面过渡上，Transition分为不带共享元素的Content Transition和带共享元素的ShareElement Transition。 Content Transition先看下content transition的一个例子，在Google Play Games上的应用： 在经过学习后我们也可以设计出类似的效果，首先需要了解在界面过渡中涉及到的一些重要方法，从ActivtyA调用startActivity方法唤起ActivityB，到ActivityB按返回键返回ActivityA涉及到与Transition有关的方法 ActivityA.exitTransition() ActivityB.enterTransition() ActivityB.returnTransition() ActivityA.reenterTransition() 因此，只要我们在对应的方法中设置了Transition就可以了。在默认没有设置对应Transition的情况下，Material-theme应用的exitTransition为null，enterTransition为Fade，如果reenterTransition和returnTransition未设定，则分别对应exitTransition和enterTransition。 使用在style中添加android:windowContentTransitions 属性启用窗口内容转换(Material-theme应用默认为true)，指定该Activity的Transition 12345678910&lt;!-- Base application theme. --&gt;&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- enable window content transitions --&gt; &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt; &lt;!-- specify enter and exit transitions --&gt; &lt;!-- options are: explode, slide, fade --&gt; &lt;item name=&quot;android:windowEnterTransition&quot;&gt;@transition/change_image_transform&lt;/item&gt; &lt;item name=&quot;android:windowExitTransition&quot;&gt;@transition/change_image_transform&lt;/item&gt;&lt;/style&gt; 也可以在代码中指定 123456// inside your activity (if you did not enable transitions in your theme)getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS);// set an enter transitiongetWindow().setEnterTransition(new Explode());// set an exit transitiongetWindow().setExitTransition(new Explode()); 然后启动Acticity 12startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this).toBundle()); 例子这里在代码中指定ActivityA的exitTransition: 123456private void setupTransition() &#123; Slide slide = new Slide(Gravity.LEFT); slide.setDuration(1000); slide.setInterpolator(new FastOutSlowInInterpolator()); getWindow().setExitTransition(slide); &#125; 使用xml方式指定ActivityB的enterTransition： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;slide android:duration=&quot;1000&quot; android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot; android:slideEdge=&quot;bottom&quot;&gt; &lt;targets&gt; &lt;target android:targetId=&quot;@id/content_container&quot;/&gt; &lt;/targets&gt; &lt;/slide&gt; &lt;slide android:duration=&quot;1000&quot; android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot; android:slideEdge=&quot;top&quot;&gt; &lt;targets&gt; &lt;target android:targetId=&quot;@id/image_container&quot;/&gt; &lt;/targets&gt; &lt;/slide&gt;&lt;/transitionSet&gt; 运行效果如下： 上图动画有两个问题: ActivityA的exitTransition还没完全走完ActivityB的enterTransition就执行了，ActivityB的returnTransition还没完全走完ActivityA的reenterTransition就执行了； 状态栏和导航栏的动画不太协调; 问题1是因为默认情况下enter/return transition会比exit/reenter transition完全结束前稍微快一点运行，如果想让前者完全运行完后者再进来，可以在代码中调用Window的 12setWindowAllowEnterTransitionOverlap(false)setWindowAllowReturnTransitionOverlap(false) 或者在xml中设置 12&lt;item name=&quot;android:windowAllowEnterTransitionOverlap&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:windowAllowReturnTransitionOverlap&quot;&gt;false&lt;/item&gt; 运行如下： 再看下问题2，默认情况下状态栏和标题栏也会参与动画(如果有导航栏也会，测试机默认木有导航栏)，当我们把xxxoverlap属性设为false后就看得比较明显了，如果不想让它们参与动画通过excludeTarget()将其排除，在代码中： 123456789private void setupTransition() &#123; Slide slide = new Slide(Gravity.LEFT); slide.setDuration(1000); slide.setInterpolator(new FastOutSlowInInterpolator()); slide.excludeTarget(android.R.id.statusBarBackground, true); slide.excludeTarget(android.R.id.navigationBarBackground, true); slide.excludeTarget(R.id.appbar,true); getWindow().setExitTransition(slide);&#125; 或者在xml中： 12345678910111213&lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:slideEdge=&quot;left&quot; android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot; android:duration=&quot;1000&quot;&gt; &lt;targets&gt; &lt;!-- if using a custom Toolbar container, specify the ID of the AppBarLayout --&gt; &lt;target android:excludeId=&quot;@id/appbar&quot; /&gt; &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot;/&gt; &lt;target android:excludeId=&quot;@android:id/navigationBarBackground&quot;/&gt; &lt;/targets&gt;&lt;/slide&gt; 效果如下： 具体流程ActivityA startActivity() 确定需要执行exit Transition的target View Transition的captureStartValues()获取target View Visibility的值(此时为VISIBLE) 将target View Visibility的值设为INVISIBLE Transition的captureEndValues()获取target View Visibility的值(此时为INVISIBLE) Transition的createAnimator()根据前后Visibility的属性值变化创建动画 ActivityB Activity 开始 确定需要执行enter Transition的target View Transition的captureStartValues()获取获取target View Visibility的，初始化为INVISIBLE 将target View Visibility的值设为VISIBLE Transition的captureEndValues()获取target View Visibility的值(此时为VISIBLE) Transition的createAnimator()根据前后Visibility的属性值变化创建动画 ShareElement TransitionshareElement Transition的例子 shareElement Transition指的是共享元素从activity/fragment到其他activity/fragment时的动画 有了上面的分析看名字应该也猜得出方法对应的功能了，如果没有设置exit/enter shared element transitions，默认为 @android:transition/move，上面的Content Transition是根据Visibility的变化创建动画，而shareElement Transition是根据大小，位置，和外观的变化创建动画，如chanageBounds、changeTransform、ChangeClipBounds、 ChangeImageTransform等，具体API使用和效果可以参考上篇。指定shareElement Transition可以通过代码形式： 1234getWindow().setSharedElementEnterTransition();getWindow().setSharedElementExitTransition();getWindow().setSharedElementReturnTransition();getWindow().setSharedElementReenterTransition(); 也可以通过xml形式： 12345678&lt;!-- Base application theme. --&gt;&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- specify shared element transitions --&gt; &lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt; @transition/change_image_transform&lt;/item&gt; &lt;item name=&quot;android:windowSharedElementExitTransition&quot;&gt; @transition/change_image_transform&lt;/item&gt;&lt;/style&gt; 然后启动Acticity 123456Intent intent = new Intent(this, DetailsActivity.class);// Pass data object in the bundle and populate details activity.intent.putExtra(DetailsActivity.EXTRA_CONTACT, contact);ActivityOptionsCompat options = ActivityOptionsCompat. makeSceneTransitionAnimation(this, (View)ivProfile, &quot;profile&quot;);startActivity(intent, options.toBundle()); 在布局文件中对于要共享的View添加android:transitionName且保持一致，如果要共享的View有点多，可以通过Pair，Pair 存储着共享View和View的名称，使用如下 12345678Intent intent = new Intent(context, DetailsActivity.class);intent.putExtra(DetailsActivity.EXTRA_CONTACT, contact);Pair&lt;View, String&gt; p1 = Pair.create((View)ivProfile, &quot;profile&quot;);Pair&lt;View, String&gt; p2 = Pair.create(vPalette, &quot;palette&quot;);Pair&lt;View, String&gt; p3 = Pair.create((View)tvName, &quot;text&quot;);ActivityOptionsCompat options = ActivityOptionsCompat. makeSceneTransitionAnimation(this, p1, p2, p3);startActivity(intent, options.toBundle()); 例子在ActivityB的theme中添加SharedElementEnterTransition 123&lt;item name=&quot;android:windowSharedElementEnterTransition&quot;&gt;@transition/change_image_transform&lt;/item&gt; change_image_transform.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;changeBounds android:duration=&quot;1000&quot; android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;/&gt; &lt;changeImageTransform android:duration=&quot;1000&quot; android:interpolator=&quot;@android:interpolator/fast_out_slow_in&quot;/&gt;&lt;/transitionSet&gt; 执行效果： 具体流程从图上看，好像图片是从一个ActivityA”传递”到另一个ActivityB，实际上真正负责绘制都发生在ActivityB上： ActivityA调用startActivity()后ActivityB处于透明状态 Transition收集ActivityA中共享View的初识状态，并传递给ActivityB Transition收集ActivityB中共享View的最终状态 Transition根据状态改变创建动画 Transition隐藏ActivityA，随着ActivityB的共享View运动到指定位置，ActivityB的背景在ActivityA上淡入，并随着动画完成而完全可见。 我们可以通过修改Activity背景淡入淡出时间来验证，在ActivityB中加入 getWindow().setTransitionBackgroundFadeDuration(2000); 为了更直观，把ActivityA的exitTransition先注释掉，运行效果： 可以看到，ActivityB确实像盖在ActivityA上，这里用到了 ViewOverlay，原理简单来说就是在其他View上draw，共享View利用该技术可以实现画在其他View上。我们可以通过Window的setSharedElementsUseOverlay(false)来关闭该功能，不过这样一来会使最终结果和你预想的不一致，默认该值为true。 延迟加载上面分析Transition会获取共享视图前后的状态值来创建动画，如果我们的图片是网上下载的，那么很有可能图片的准确大小需要下载下来才能确定，Activity Transitions API提供了一对方法暂时推迟过渡，直到我们确切地知道共享元素已经被适当的渲染和放置。在onCreate中调用postponeEnterTransition()(API &gt;= 21)或者supportPostponeEnterTransition()（API &lt; 21）延迟过渡；当图片的状态确定后，调用startPostponedEnterTransition()（API &gt;= 21）或supportStartPostponedEnterTransition()（API &lt; 21）恢复过渡，常见处理： 12345678910111213// ... load remote image with Glide/Picasso heresupportPostponeEnterTransition();ivBackdrop.getViewTreeObserver().addOnPreDrawListener( new ViewTreeObserver.OnPreDrawListener() &#123; @Override public boolean onPreDraw() &#123; ivBackdrop.getViewTreeObserver().removeOnPreDrawListener(this); supportStartPostponedEnterTransition(); return true; &#125; &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java-你应该知道的JDK知识]]></title>
      <url>%2F2017%2F10%2F17%2Fjava-jdk%2F</url>
      <content type="text"><![CDATA[前言无论是从事Javaee开发或者是Android开发，JDK的基础知识都尤为重要。我们在代码里经常使用ArrayList、HashMap等，但却很少思考为什么是使用它，使用的时候需要注意什么。甚至有可能去面试的时候，人家一问HashMap的实现原理，但却只知道put和get，非常尴尬。 所以为了开发更高质量的程序，写出更优秀的代码，还是需要好好研究一下JDK的一些关键源码。本文主要对JDK进行一些重要的的知识的梳理及整理，便于学习及复习。 基础知识基础数据类型变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据 类型 位 默认值 byte 8(1字节) 0 short 16(2字节) 0 int 32(4字节) 0 long 64(8字节) 0L float 32(4字节) 0.0f double 64(8字节) 0.0d boolean 1 false char 16 位 Unicode 字符 “” equal hashcode ==的区别 == 内存地址比较 equal Object默认内存地址比较，一般需要复写 hashcode 主要用于集合的散列表，Object默认为内存地址，一般不用设置，除非作用于散列集合。 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。当equals方法被重写时，通常有必要重写 hashCode 方法。但hashCode相等，不一定equals（） String、StringBuffer与StringBuilder的区别。Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBulder类表示的字符串对象可以直接进行修改。StringBuilder是JDK1.5引入的，它和StringBuffer的方法完全相同，区别在于它是单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。 Java的四种引用，强弱软虚，用到的场景。JDK1.2之前只有强引用,其他几种引用都是在JDK1.2之后引入的. 强引用（Strong Reference） 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。 软引用（Soft Reference） 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。 当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null 弱引用（Weak Reference） 发生GC时必定回收弱引用指向的内存空间。 和软引用加入队列的时机相同 虚引用（Phantom Reference) 又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。 当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了. 虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有 Java集合框架 Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。 List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。 Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。 我们看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的适配器设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。 Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。 Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。 Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。 Collection List Set Map 区别 接口 是否有序 允许元素重复 collection 否 是 List 是 是 AbstractSet 否 否 HashSet 否 否 TreeSet 是（用二叉树排序） 否 AbstractMap 否 使用 key-value 来映射和存储数据， Key 必须惟一， value 可以重复 HashMap 否 使用 key-value 来映射和存储数据， Key 必须惟一， value 可以重复 TreeMap 是（用二叉树排序） 使用 key-value 来映射和存储数据， Key 必须惟一， value 常用集合分析 集合 主要算法 源码分析 ArrayList 基于数组的List，封装了动态增长的Object[] 数组 链接 Stack 是Vector 的子类，栈 的结构（后进先出） 链接 LinkedList 实现List，Deque；实现List，可以进行队列操作，可以通过索引来随机访问集合元素；实现Deque，也可当作双端队列，也可当作栈来使用 链接 HashMap 基于哈希表的 Map 接口的实现, 使用顺序存储及链式存储的结构 链接 LinkedHashMap LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashmap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序，可以使节点的输出顺序与输入顺序相同 链接 TreeMap TreeMap的实现是红黑树算法的实现，支持排序 链接 并发Lists ArrayList——基于泛型数组 LinkedList——不推荐使用 Vector——已废弃（deprecated） CopyOnWriteArrayList——几乎不更新，常用来遍历 Queues / deques ArrayDeque——基于泛型数组 Stack——已废弃（deprecated） PriorityQueue——读取操作的内容已排序 ArrayBlockingQueue——带边界的阻塞式队列 ConcurrentLinkedDeque / ConcurrentLinkedQueue——无边界的链表队列（CAS） DelayQueue——元素带有延迟的队列 LinkedBlockingDeque / LinkedBlockingQueue——链表队列（带锁），可设定是否带边界 LinkedTransferQueue——可将元素transfer进行w/o存储 PriorityBlockingQueue——并发PriorityQueue SynchronousQueue——使用Queue接口进行Exchanger Maps HashMap——通用Map EnumMap——键使用enum Hashtable——已废弃（deprecated） IdentityHashMap——键使用==进行比较 LinkedHashMap——保持插入顺序 TreeMap——键已排序 WeakHashMap——适用于缓存（cache） ConcurrentHashMap——通用并发Map ConcurrentSkipListMap——已排序的并发Map Sets HashSet——通用set EnumSet——enum Set BitSet——比特或密集的整数Set LinkedHashSet——保持插入顺序 TreeSet——排序Set ConcurrentSkipListSet——排序并发Set CopyOnWriteArraySet——几乎不更新，通常只做遍历 总结Set的选择 HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet 对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快 EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素 HashSet、TreeSet、EnumSet都是”线程不安全”的，通常可以通过Collections工具类的synchronizedSortedSet方法来”包装”该Set集合。SortedSet s = Collections.synchronizedSortedSet(new TreeSet(…)); List 选择 java提供的List就是一个”线性表接口”，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现 Queue代表了队列，Deque代表了双端队列(既可以作为队列使用、也可以作为栈使用) 因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。 内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能 进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好 当要大量的插入，删除，应当选用LinkedList；当需要快速随机访问则选用ArrayList; Map 的选择 HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制 TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对 使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作 HahMap 是利用hashCode 进行查找，而TreeMap 是保持者某种有序状态 所以，插入，删除，定位操作时，HashMap 是最好的选择；如果要按照自然排序或者自定义排序，那么就选择TreeMap]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-粒子变幻、隧道散列、组合文字]]></title>
      <url>%2F2017%2F10%2F15%2Fandroid-study-particle%2F</url>
      <content type="text"><![CDATA[效果视频 &amp; 图片第一个视频，无散列 第二个视频，具备散列 概述跟随早前开源的 XView (github.com/af913337456…) 项目，本次在原基础上添加了 粒子变幻 自定义View。目前我在代码里面的设置它可以做到： 根据你输入文字，将被粒子组合而成。 粒子流具备多种属性，目前我拓展了缩放，圆形与矩形，墙壁碰撞，等等。 粒子每个互不影响，可以分批设置粒子特性，视频中就有 方形 和 圆形 所有的半径，坐标什么的参数都是可自定义的。 因为锚边是根据 bitmap 而来的，也就是说，你可以输入图片，然后由粒子组合 XView 项目早前已经开源了碰撞球，可以加入粒子相互碰撞 原理及其难点 根据 bitmap 找出文字或图像的边。这步骤要减少 o(n) 根据边路径，进行粒子填充 变幻算法，例如运动中的缩放 高效率的刷新，摒弃 View，采用 SurfaceView 部分代码简述调用 123456789101112131415161718192021222324252627282930313233343536373839404142// 粒子变幻particleView.setConfigAndRefreshView( new ParticleView.Config() .setCanvasWidth( // 设置画布宽度 getWindowManager().getDefaultDisplay().getWidth() ) .setCanvasHeight(800) // 设置画布高度 .setParticleRefreshTime(50) // 设置每帧刷新间隔 .set_x_Step(15) // 设置 x 轴每次取像素点的间隔 .set_y_Step(19) // 设置 轴每次取像素点的间隔 .setParticleCallBack( new ParticleView.ParticleCallBack() &#123; @Override public ParticleView.Particle setParticle(ParticleView.Particle p, int index, int x, int y) &#123; p.setX(x); // 设置获取回来的 x 为该 粒子的x坐标 p.setY(y); // 设置获取回来的 y 为该 粒子的y坐标 p.setIsZoom(true); // 设置当前颗粒子是否启动缩放 p.setRadiusMax(12); // 设置当前颗粒子最大的缩放半径 p.setRadius(12); // 设置当前颗粒子默认的半径 /** 下面的 %3 是我演示 分批次 显示不同效果而设置 **/ if(index % 3==0)&#123; p.setRectParticle(true); // 这个粒子是 正方形 的 p.setIsHash( // 设置它是否是散列的，即是随机移动 true, new Random().nextInt(30)-15, // x 速率 new Random().nextInt(30)-15 // y 速率 ); &#125; return p; // 返回这个粒子 &#125; @Override public boolean drawText(Bitmap bg,Canvas c) &#123; /** 这里就是我们要自定义显示任意文字的地方 */ MainActivity.this.drawText(bg,c,s); return true; /** 告诉它不要使用默认的 txt */ &#125; &#125; )); 源码地址 github.com/af913337456…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-LayoutInflater（布局加载器）]]></title>
      <url>%2F2017%2F10%2F14%2Fandroid-layoutinflater%2F</url>
      <content type="text"><![CDATA[前言对于LayoutInflater之前一直只会用，却不知道LayoutInflater的加载原理，每次直接 1234LayoutInflater.from(context).inflate(R.layout.activity_test, root, false);//不行就这样，反正有一种能实现我要的效果LayoutInflater.from(context).inflate(R.layout.activity_test, null); 所以，想要趁这个整理博客的机会，顺便把LayoutInflater的内容好好学习学习。 概述 LayoutInflater的常见使用场景 LayoutInflater的介绍 LayoutInflater相关介绍中的相关概念分析 LayoutInflater的常见使用场景在介绍之前，我们先回一下，我们在哪些地方都使用过LayoutInflater： 在Activity中12LayoutInflater inflater = getLayoutInflater();View view = inflater.inflate(R.layout.activity_main, null); 在Fragment中12View view = inflater.inflate(R.layout.fragment_guide_one, container, false);return view; 在Adapter中12345@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; View view = LayoutInflater.from(convertView.getContext()).inflate(R.layout.activity_main, parent, false); return view;&#125; 在某些特殊情况下，需要使用LayoutInflater，我们是这样获得它的LayoutInflater inflater =(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); 上述的使用，是我们平常常见的使用方式，而这些场景都有一个特点，因为这些场景都需要将一个XML布局文件转化成View，所以准确的说LayoutInflater的主要功能来说就是布局加载。 其实LayoutInflater还有一些扩展操作，可以通过我们自定义的方式来实现，在后面的实战篇会介绍。 LayoutInflater的介绍对于LayoutInflater的介绍性质的内容，博主认为，在网上查的任何内容，都不如查阅源码，API来的靠谱一些，因为API才是第一手的介绍资料，而且Android的源码中介绍的也比较完善。 LayoutInflater属于 android.view包下，在LayoutInflater的头部有一段关于LayoutInflater的介绍： 由于篇幅原因，这里只截取了一部分图片，总结一下： LayoutInflater的主要作用将XML文件实例化成相应的View对象 LayoutInflater在Android开发过程中，获取的方式不是直接new出来的，都是经过这两个方法得到的关联上下文的LayoutInflater： 1234//在Activity中LayoutInflater inflater = Activity#getLayoutInflater()//其他情况LayoutInflater inflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) 如果想使用新的LayoutInflater来加载View，需要使用cloneInContext()，而在新的LayoutInflater需要调用setFactory()设置视图处理器 由于性能的原因，XML文件的预处理是在Build过程中进行的。 LayoutInflater不能加载未编译的XML文件，而且LayoutInflater只能加载，通过XmlPullParser解析的R文件资源。 LayoutInflater介绍相应的解释经过上面的总结，大家对LayoutInflater有一个大致的认识，为了大家不是太懵逼，让我一一解释一波。 LayoutInflater的主要作用将XML文件实例化成相应的对象其实，大家在使用LayoutInflater时，也会注意到无非就是将布局资源通过LayoutInflater转换为相对应的View，然后在进行一些其他操作,就是LayoutInflater常见场景中的几种情况： 12View view = inflater.inflate(R.layout.fragment_guide_one, container, false);return view; LayoutInflater在Android开发过程中，不是通过new出来获取到的？在上述场景中，除了介绍的两种方式Activity#getLayoutInflater()，以及getSystemService()，大家发现常见场景中还使用了 LayoutInflater inflater =LayoutInflater.from(convertView.getContext())； 其实LayoutInflater.from()这个方法是官方帮我们封装了一层而已，底层还是调用getSystemService()方法，目的是使LayoutInflater与Context对象相绑定： 1234567public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError("LayoutInflater not found."); &#125; return LayoutInflater;&#125; 如果想使用新的LayoutInflater来加载，需要使用cloneInContext()，而在新的LayoutInflater需要调用setFactory()设置视图处理器正常来说，这种使用方式的使用场景现在也是比较多的，比如： 批量获取XML中自定义的属性 动态换肤的效果 动态改变布局中的元素 这些都是通过LayoutInflater中的Factory来实现的，而介绍这部分内容会在实战篇来介绍。 由于性能的原因，XML文件的预处理是在Build过程中进行的举个例子，在编写XML布局资源时，如果漏写了结束符号，或者一些奇怪的操作，在运行程序之前的Build（构建阶段），就会弹出报错。 这里故意将结束符，写错 12345&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" android:textSize="20sp" / 这里就会收到报错信息提示，每个XML都会有一个预编译的过程，这个过程发生在构建阶段（Build），而不是运行时。 LayoutInflater只能加载通过XmlPullParser解析的R文件资源这里的R文件资源就是指这些资源文件例如： 1234R.layout.xxxxR.drawable.xxxxR.color.xxxR.string.xxx 二级概述 Activity 的 getSystemService的实现过程 LayoutInflater 如果将布局资源转换为 View 的过程 LayoutInflater的 Factory，Factory2是什么，在解析过程中的作用是什么？ LayoutInflater 的 inflater 方法的各个参数的含义，不同的情况的含义 LayoutInflater的构造方法123protected LayoutInflater(Context context) &#123; mContext = context;&#125; 这种是LayoutInflater常规的构造方法，将Context传入，最后生成的LayoutInflater与对应的Context相绑定。 1234567protected LayoutInflater(LayoutInflater original, Context newContext) &#123; mContext = newContext; mFactory = original.mFactory; mFactory2 = original.mFactory2; mPrivateFactory = original.mPrivateFactory; setFilter(original.mFilter);&#125; 而这种构造方法来说，只是复制原LayoutInflater的内容，然后将Context对象替换，一般来说只会在cloneInContext()方法中使用。 LayoutInflater#form()方法分析根据介绍篇的内容，LayoutInflater在Android开发中一般是通过 123context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);LayoutInflater.from(context); 因为第一种方式，已经是LayoutInflater介绍中声明获取的方式之一，那么这里我们看一下LayoutInflater#form的方法。 1234567public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError("LayoutInflater not found."); &#125; return LayoutInflater;&#125; 从源码上看，LayoutInflater#form()方法内部也是通过getSystemService()方法获得，那么接下来我们看一下context#getSystemService()这个方法： public abstract Object getSystemService(@ServiceName @NonNull String name); 发现这个只是一个抽象方法，而我们知道Activity也是Context的一个实现。 Activity#getSystemService()这个方法： 12345678910111213141516@Overridepublic Object getSystemService(@ServiceName @NonNull String name) &#123; if (getBaseContext() == null) &#123; throw new IllegalStateException( "System services not available to Activities before onCreate()"); &#125; //获取WindowManager if (WINDOW_SERVICE.equals(name)) &#123; return mWindowManager; //系统的搜索框SearchManager &#125; else if (SEARCH_SERVICE.equals(name)) &#123; ensureSearchManager(); return mSearchManager; &#125; return super.getSystemService(name);&#125; 从上面看到，在Activity中只处理了两种类型的服务，分别是获取WindowManager、获取SearchManager，那我们接着看其父类的SystemService()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Overridepublic Object getSystemService(String name) &#123; //找到我们要的东西，注意这是个单例 if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123; if (mInflater == null) &#123; mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this); &#125; return mInflater; &#125; return getBaseContext().getSystemService(name);&#125;在Activity的父类即ContextThemeWrapper的getSystemService()方法中，我们发现了LayoutInflater的创建过程，从上面的代码我们可以看出：每个Activity内包含的LayoutInflater是一个单例。Activity创建LayoutInflater时，是先使用最原始的BaseContext创建，然后在将Activity的父类ContextThemeWrapper的信息通过cloneInContext()方法与其绑定。然后我们在看下LayoutInflater的cloneInContext的实现：`public abstract LayoutInflater cloneInContext(Context newContext);`先看下，这个方法的介绍：![2017110515098197795785.png](http://ohtrrgyyd.bkt.clouddn.com/2017110515098197795785.png)这个方法通过现有的LayoutInflater创建一个新的LayoutInflater副本，唯一变化的地方是指向不同的上下文对象。在ContextThemeWrapper通过这个方法创建的新的LayoutInflater还包含了主题的信息。在ContextThemeWrapper中使用cloneInContext是想将更多的信息，赋予LayoutInflater中，与其相互绑定。# Activity中LayoutInflater创建对于Activity的LayoutInflater，其实在Activity创建之时就已经创建完成，但是这一块内容属于FrameWork层的内容，博主道行太浅了，只想带大家看下from这个方法的实现过程。这里如果大家想了解可以参考下这篇文章[LayoutInflater源码解析](http://blog.csdn.net/u014486880/article/details/50707672)而Activity#getLayoutInflater方法：```java@NonNullpublic LayoutInflater getLayoutInflater() &#123; return getWindow().getLayoutInflater();&#125;这个Window对象即PhoneWindow，此时创建出来的LayoutInflater即PhoneLayoutInflater。这里给大家看下PhoneLayoutInflater的cloneInContext()方法：```javapublic LayoutInflater cloneInContext(Context newContext) &#123; return new PhoneLayoutInflater(this, newContext);&#125;protected PhoneLayoutInflater(LayoutInflater original, Context newContext) &#123; super(original, newContext);&#125; 可以发现PhoneLayoutInflater中cloneInContext()的实现，调用了第二个构造方法。 这里在Android Studio是无法查阅的，有条件的可以下载源码，如果下载源码麻烦，可以在这里查阅。 Android源码查看网址 将R.layout.xxx转换为View的过程分析其实这个过程即LayoutInflater.inflater()这个过程： 12345678910111213public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")"); &#125; final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; 在这个方法中，只是先拿到XmlResourceParser，用于后续节点的解析，我们接着往下看： 这里只看一些关键的信息，具体代码大家自行查看 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; //》》》》》》》》》》》》》》》》》第一部分》》》》》》》》》》》》》》》》》》》 try &#123; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + ": No start tag found!"); &#125; final String name = parser.getName() //》》》》》》》》》》》》》》》》》第二部分》》》》》》》》》》》》》》》》》》》 if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; //》》》》》》》》》》》》》》》》》第三部分》》》》》》》》》》》》》》》》》》》 final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; temp.setLayoutParams(params); &#125; &#125; rInflateChildren(parser, temp, attrs, true); if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; return result; &#125;&#125; 第一部分：这里第一部分的内容，主要是一个XML文件的读取过程，这里有两个判断： 遍历XML内容寻找XML标签的开始的标志或者文档结尾的标志才可以跳出循环。 如果该XML没有开始的标识，则抛出异常。 下面给大家介绍下，几种常见的解析标识： 123456789XmlPullParser.START_DOCUMENT 文档开始XmlPullParser.END_DOCUMENT 文档结束XmlPullParser.START_TAG XML标签的开始XmlPullParser.END_TAG XML标签的结束XmlPullParser.TEXT XML标签的内容 第二部分这部分的一开始先进行了Merge标签的检验，如果发现该节点是Merge，必须满足父View存在，并且与父View绑定的状态。 转换为代码: root ！= null &amp;&amp; attachToRoot ==true 这里Merge是减少布局层级存在的标签，通常和include标签一起使用，所以其必须存在父View，而且merge标签的内容必须与父View绑定。 这里调用rInflate()方法去解析Merge的标签，而rInflate()方法，在另一篇文章已经单独分析。 Android 中LayoutInflater（布局加载器）源码篇之rInflate方法 第三部分我们再看一下第三部分的代码，代码中会有一些简要的说明： 12345678910111213141516171819202122232425 //》》》》》》》》》》》》》》》》》第三部分》》》》》》》》》》》》》》》》》》》 //createViewFromTag是一个根据name来创建View的方法 final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; temp.setLayoutParams(params); &#125; &#125; //解析子标签 rInflateChildren(parser, temp, attrs, true); if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; return result;&#125; 将第三部分内容分拆一下主要分为以下几块内容： 排除标签为include，或者merge之后，就会通过createViewFromTag()方法来创建View root是inflater()方法的第二个参数，而attachToRoot是第三个参数，最后会根据这两个参数来决定返回的View 在这部分中，createViewFromTag()是根据name（名称），来创建View的一个方法。 接下来，我们要介绍的是inflater()方法中的参数，到底有什么作用？ 1234567891011121314151617181920212223 ViewGroup.LayoutParams params = null; //当Root存在 if (root != null) &#123; params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; //设置View在父布局下Params temp.setLayoutParams(params); &#125; &#125; //遍历子节点 rInflateChildren(parser, temp, attrs, true); //如果Root存在并且attachToRoot为true，即与父View绑定 //这里在解析的同时，就会将其添加至父View上 if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; //如果父Viewwe为null或者没有绑定父View都会将当前解析的View返回，否则返回父View if (root == null || !attachToRoot) &#123; result = temp; &#125;&#125; 仔细分析上述代码，可以得出如下结论： 从这段代码中，得出以下几个结论： 当root为null时，attachToRoot参数无效，而解析出的View作为一个独立的View存在（不存在LayoutParams）。 当root不为null时，attactToRoot为false，那么会给该View设置一个父View的约束（LayoutParams），然后将其返回。 当root不为null时，attactToRoot为true，那么该View会被直接addView进父View，然后会将父View返回。 当root不为null的话，attactToRoot的默认值是true。 123public View inflate(XmlPullParser parser, @Nullable ViewGroup root) &#123; return inflate(parser, root, root != null);&#125; 上面的代码中，我们还少分析了一处代码rInflateChildren()，即解析子类： 123final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,boolean finishInflate) throws XmlPullParserException, IOException &#123; rInflate(parser, parent, parent.getContext(), attrs, finishInflate);&#125; 如果你之前没看过这段代码，其实你会像博主之前一样，一直在试，而不知道这段代码正确的含义，但是有时候源码会是一个很好的老师，通过它能够得到你想要的。 流程图 CreateViewFromTag源码解析123private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123; return createViewFromTag(parent, name, context, attrs, false);&#125; createViewFromTag在LayoutInflater中存在重载，最终还是会调用5个参数的createViewFromTag方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,boolean ignoreThemeAttr) &#123; //解析view标签 if (name.equals("view")) &#123; name = attrs.getAttributeValue(null, "class"); &#125; //如果需要该标签与主题相关，需要对context进行包装，将主题信息加入context包装类ContextWrapper if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; //BlinkLayout是一种闪烁的FrameLayout，它包裹的内容会一直闪烁，类似QQ提示消息那种。 if (name.equals(TAG_1995)) &#123; return new BlinkLayout(context, attrs); &#125; //设置Factory，来对View做额外的拓展，这块属于可定制的内容 try &#123; View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; //如果此时不存在Factory，不管Factory还是Factory2，还是mPrivateFactory都不存在，那么会直接对name直接进行解析 if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; //如果name中包含.即为自定义View，否则为原生的View控件 if (-1 == name.indexOf('.')) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; 根据源码可以将createViewFromTag分为三个流程： 对一些特殊标签，做分别处理，例如：view，TAG_1995(blink) 进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View 如果没有设置Factory或Factory2，那么就会使用LayoutInflater默认的生成方式，进行View的生成 createViewFromTag分析过程：处理view标签如果标签的名称是view，注意是小写的view，这个标签一般大家不太常用，具体的使用情况如下： 1234&lt;view class=&quot;RelativeLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/view&gt; 在使用时，相当于所有控件标签的父类一样，可以设置class属性，这个属性会决定view这个节点会变成什么控件。 如果该节点与主题相关，则需要特殊处理如果该节点与主题（Theme）相关，需要将context与theme信息包装至ContextWrapper类。 处理TAG_1995标签这就有意思了，TAG_1995指的是blink这个标签，这个标签感觉使用的很少，以至于大家根本不知道。 这个标签最后会被解析成BlinkLayout，BlinkLayout其实就是一个FrameLayout，这个控件最后会将包裹内容一直闪烁(就和电脑版QQ消息提示一样)，有空大家可以自行尝试下，很简单，下面贴一下用法： 123456789&lt;blink android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;这个标签会一直闪烁&quot;/&gt;&lt;/blink&gt; 判断其是否存在Factory或者Factory2在这里先对Factory进行判空，这里不管Factory还是Factory2（mPrivateFactory 就是Factory2），本质上都是一种扩展操作，提前解析name，然后直接将解析后的View返回。 Factory123public interface Factory &#123; public View onCreateView(String name, Context context, AttributeSet attrs);&#125; Factory2123public interface Factory2 extends Factory &#123; public View onCreateView(View parent, String name, Context context, AttributeSet attrs);&#125; 从这里可以看出，Factory2和Factory都是一个接口，需要自己实现，而Factory2和Factory的区别是Factory2继承Factory，从而扩展出一个参数，就是增加了该节点的父View。 这里我自定义了一个Factory，下面自定义解析View的过程： 1234567891011121314151617181920212223242526272829@Overridepublic View onCreateView(String name, Context context, AttributeSet attrs) &#123; View view = null; try &#123; if (-1 == name.lastIndexOf(".")) &#123; if (name.equals("View") || name.equals("ViewGroup")) &#123; view = mInflater.createView(name, "android.view.", attrs); &#125; else &#123; view = mInflater.createView(name, "android.widget.", attrs); &#125; &#125; else &#123; if (name.contains(".")) &#123; String checkName = name.substring(name.lastIndexOf(".")); String prefix = name.substring(0, name.lastIndexOf(".")); view = mInflater.createView(checkName, prefix, attrs); &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; if(view != null)&#123; //在这里可以对View做一些额外的操作，并且能够获得View的属性集，可以做一些自定义操作。 view.xxxxxx &#125; return view;&#125; 从上面可以看出，Factory和Factory2其实LayoutInflater解析View时的一种扩展实现，在这里可以额外的对View处理，设置Factory和Factory2需要通过setFactory()或者setFactory2()来实现。 setFactory() 12345678910111213141516public void setFactory(Factory factory) &#123; //如果已经设置Factory，不可以继续设置Factory if (mFactorySet) &#123; throw new IllegalStateException("A factory has already been set on this LayoutInflater"); &#125; if (factory == null) &#123; throw new NullPointerException("Given factory can not be null"); &#125; //设置Factory会添加一个标记 mFactorySet = true; if (mFactory == null) &#123; mFactory = factory; &#125; else &#123; mFactory = new FactoryMerger(factory, null, mFactory, mFactory2); &#125;&#125; setFactory2() 123456789101112131415public void setFactory2(Factory2 factory) &#123; if (mFactorySet) &#123; throw new IllegalStateException("A factory has already been set on this LayoutInflater"); &#125; if (factory == null) &#123; throw new NullPointerException("Given factory can not be null"); &#125; //注意设置Factory和Factory2的标记是共用的 mFactorySet = true; if (mFactory == null) &#123; mFactory = mFactory2 = factory; &#125; else &#123; mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2); &#125;&#125; 通过上面代码可以看出，Factory和Factory2只能够设置一次，并且Factory和Factory2二者互斥，只能存在一个。 所以一般setFactory()或者setFactory2()，一般在cloneInContext()之后设置，这样生成一个新的LayoutInflater，标记默认是false，才能够设置。 LayoutInflater内置的解析过程如果Factory或者Factory2没有设置，或者返回View为null，才会使用默认解析方式。 12345if (-1 == name.indexOf(&apos;.&apos;)) &#123; view = onCreateView(parent, name, attrs);&#125; else &#123; view = createView(name, null, attrs);&#125; 这段就是对自定义View和原生的控件进行判断，这里给大家说明下原生控件和自定义View的name区别： 12原生 ： RelativeLayout自定义View ： com.demo.guidepagedemo.customview.CustomImageView 原生控件的解析方式 onCreateView ： 123protected View onCreateView(View parent, String name, AttributeSet attrs) throws ClassNotFoundException &#123; return onCreateView(name, attrs);&#125; 然后调用的还是2个参数的onCreateView()方法 123protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException &#123; return createView(name, "android.view.", attrs);&#125; 可以看到最终方法的指向还是调用createView方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; //判断构造器是否存在 Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; //如果构造器不存在，这个就相当于Class之前是否被加载过，sConstructorMap就是缓存这些Class的Map if (constructor == null) &#123; //通过前缀+name的方式去加载 clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class); //通过过滤去设置一些不需要加载的对象 if (mFilter != null &amp;&amp; clazz != null) &#123; boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); //缓存Class sConstructorMap.put(name, constructor); &#125; else &#123; //如果Class存在，并且加载Class的ClassLoader合法 //这里先判断该Class是否应该被过滤 if (mFilter != null) &#123; //过滤器也有缓存之前的Class是否被允许加载，判断这个Class的过滤状态 Boolean allowedState = mFilterMap.get(name); if (allowedState == null) &#123; //加载Class对象操作 clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class); //判断Class是否可被加载 boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz); mFilterMap.put(name, allowed); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; else if (allowedState.equals(Boolean.FALSE)) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; &#125; Object[] args = mConstructorArgs; args[1] = attrs; //如果过滤器不存在，直接实例化该View final View view = constructor.newInstance(args); //如果View属于ViewStub那么需要给ViewStub设置一个克隆过的LayoutInflater if (view instanceof ViewStub) &#123; final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; return view; &#125;&#125; 上面代码有点长，就直接在代码里面加注释了，这里额外说一下这个方法： 判断ClassLoader是否安全的verifyClassLoader ： 123456789101112131415161718private final boolean verifyClassLoader(Constructor&lt;? extends View&gt; constructor) &#123; final ClassLoader constructorLoader = constructor.getDeclaringClass().getClassLoader(); if (constructorLoader == BOOT_CLASS_LOADER) &#123; //这里注意BootClassLoader是相当于所有派生出来的ClassLoader的原始基类，所有的ClassLoader都是根据其衍生的。 return true; &#125; //这里是一个遍历操作，一直在遍历加载mContext的ClassLoader的继承树，一直在往上寻找，如果 //constructor的ClassLoader与继承树中某个ClassLoader相同就说明这个ClassLoader是安全的 ClassLoader cl = mContext.getClassLoader(); do &#123; if (constructorLoader == cl) &#123; return true; &#125; cl = cl.getParent(); &#125; while (cl != null); return false; &#125;&#125; 这里简单说明下，几种ClassLoader的作用： BootClassLoader 加载Android FrameWork层的一些字节码文件 PathClassLoader 加载已经安装到系统上的应用App（apk）上的字节码文件 DexClassLoader 加载指定目录中的Class字节码文件 BaseDexClassLoader 是PathClassloader和DexClassLoader的父类 一般的App刚启动的时候，就会有两个ClassLoader被加载，分别是PathClassLoader、DexClassLoader而这两个ClassLoader都是继承BaseDexClassLoader. 而BaseDexClassLoader继承的是ClassLoader，但是在ClassLoader中getParent()方法赋予其Parent为BootClassLoader，这个如果大家感兴趣，可以自行查阅ClassLoader。 流程图 rInflate()的源码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; //获取该标签的深度 final int depth = parser.getDepth(); int type; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); //如果该节点为requestFocus if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); //如果该节点为tag &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); //如果该节点为include标签 &#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123; throw new InflateException("&lt;include /&gt; cannot be the root element"); &#125; //解析include标签 parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; //如果该节点为Merge throw new InflateException("&lt;merge /&gt; must be the root element"); &#125; else &#123; //否则属于正常的View final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); //接下来解析子View rInflateChildren(parser, view, attrs, true); //注意这里直接进行addView操作 viewGroup.addView(view, params); &#125; &#125; //如果解析完成，需要通知父View，解析完成。 if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125; 在rInflate这里做的操作，就是识别这些节点，然后对应解析形成响应的元素，下面我们会根据代码，一段一段分析rInflate都做了什么. 如果发现requestFocus标签，则调用父View的requestFocus()方法。 requestFocus标签使用： 123456&lt;EditText android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; &gt; &lt;!-- 当前控件处于焦点状态 --&gt; &lt;requestFocus /&gt; parseRequestFocus方法： 12345private void parseRequestFocus(XmlPullParser parser, View view) throws XmlPullParserException, IOException &#123; //调用其父View的requestFocus（）方法 view.requestFocus(); consumeChildElements(parser);&#125; 如果发现tag标签，为其设置（key，value）模式的tag。 tag标签使用： 1234567891011&lt;Button android:id=&quot;@+id/tag_btn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;openClickNotification&quot; android:text=&quot;自定义带监听事件的通知&quot;&gt; &lt;tag android:id=&quot;@+id/tag_id&quot; android:value=&quot;@string/app_name&quot; /&gt;&lt;/Button&gt; parseViewTag方法 ： 1234567891011private void parseViewTag(XmlPullParser parser, View view, AttributeSet attrs) throws XmlPullParserException, IOException &#123; final Context context = view.getContext(); final TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.ViewTag); //这里设置tag的key final int key = ta.getResourceId(R.styleable.ViewTag_id, 0); //这里设置tag的value final CharSequence value = ta.getText(R.styleable.ViewTag_value); view.setTag(key, value); ta.recycle(); consumeChildElements(parser);&#125; 在parseViewTag()方法中，会把（key，value）形式的tag赋予View。 Key指的是R.id.tag_id对应的int类型数据； Value指的是R.string.app_name的String类型数据； 如果是Include标签，这里开始先获取了Include的深度 final int depth = parser.getDepth(); 所谓深度就是XML的层级关系，例如这样： 1234567&lt;!-- outside --&gt; &lt;root&gt; sometext &lt;foobar&gt; &lt;/foobar&gt; &lt;/root&gt; &lt;!-- outside --&gt; 判断该Include标签的深度是否是0，如果为0，则抛出异常，因为include不能为根元素。 如果是Merge标签，那么会直接抛出异常，因为Merge必须为根元素，也就是深度为0的节点。 最后是其他标签，例如View，一起其他的一些标签 12345final View view = createViewFromTag(parent, name, context, attrs);final ViewGroup viewGroup = (ViewGroup) parent;final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);rInflateChildren(parser, view, attrs, true);viewGroup.addView(view, params); 在加载View的过程，大致分为三个阶段： createViewFromTag() 见名知意，根据节点名称创建View rInflateChildren() 加载该节点内子类 parent.addView() 最后将该View添加进Parent布局 第一阶段 : createViewFromTag()createViewFromTag()是根据name(节点名称)来解析出View的一个方法 第二阶段 ：rInflateChildren()123final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,boolean finishInflate) throws XmlPullParserException, IOException &#123; rInflate(parser, parent, parent.getContext(), attrs, finishInflate);&#125; 这里可以看到，这里会将解析出来的View作为Root(父View)，继续进行子节点的解析，会继续调用，直到无法解析。 这里的无法解析是指： 当前解析的标识为XmlPullParser.END_TAG（节点结束的标识符），并且深度不在父节点的标签内。 或者type 为 XmlPullParser.END_DOCUMENT（文档结束的标识符）。 第三阶段 parent.addView()将View添加进父View中viewGroup.addView(view, params); 这段话，不难理解，就是将解析出的View，添加到父View中。 流程图 parseInclude()是在哪里使用的？1234567891011void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; //----------------省略部分代码--------------------//&#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123; throw new InflateException("&lt;include /&gt; cannot be the root element"); &#125; parseInclude(parser, context, parent, attrs);&#125;//----------------省略部分代码--------------------//&#125; 从上来代码中，可以发现parseInclude()是在rInflate()中出现，作用是处理当前节点是Include标签时的状况。 parseInclude()源码解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//参数说明：// parser 解析布局的解析器// context 当前加载布局的上下文对象// parent 父容器// attrs 属性集合（XML该节点的属性集合）private void parseInclude(XmlPullParser parser, Context context, View parent, AttributeSet attrs) throws XmlPullParserException, IOException &#123; int type; // 判断 Include标签是否在 ViewGroup容器之内，因为 include 标签只能存在于 ViewGroup 容器之内。 if (parent instanceof ViewGroup) &#123; //------------------&lt;第一部分&gt;-------------------// //当开发者设置 include 主题属性时，可以覆盖被 include 包裹View的主题属性。 //但是这种操作很少会使用。 //所以如果被包裹 View 设置主题属性，我们在设置就会出现覆盖效果。 //以 include 标签的主题属性为最终的主题属性 //提取出 include 的 thme 属性，如果设置了 them 属性，那么include 包裹的View 设置的 theme 将会无效 final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); final boolean hasThemeOverride = themeResId != 0; if (hasThemeOverride) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); //------------------&lt;第二部分&gt;-------------------// //如果这个属性是指向主题中的某个属性，我们必须设法得到主题中layout 的资源标识符 //先获取 layout 属性（资源 id）是否设置 int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0); if (layout == 0) &#123; //如果没直接设置布局的资源 id，那么就检索?attr/name这一类的 layout 属性 final String value = attrs.getAttributeValue(null, ATTR_LAYOUT); if (value == null || value.length() &lt;= 0) &#123; throw new InflateException("You must specify a layout in the" + " include tag: &lt;include layout=\"@layout/layoutID\" /&gt;"); &#125; //从 ?attr/name 这一类的属性中，获取布局属性 layout = context.getResources().getIdentifier(value.substring(1), null, null); &#125; //这个布局资源也许存在主题属性中，所以需要去主题属性中解析 if (mTempValue == null) &#123; mTempValue = new TypedValue(); &#125; if (layout != 0 &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, true)) &#123; layout = mTempValue.resourceId; &#125; //------------------&lt;第三部分&gt;-------------------// if (layout == 0) &#123; final String value = attrs.getAttributeValue(null, ATTR_LAYOUT); throw new InflateException("You must specify a valid layout " + "reference. The layout ID " + value + " is not valid."); &#125; else &#123; final XmlResourceParser childParser = context.getResources().getLayout(layout); try &#123; final AttributeSet childAttrs = Xml.asAttributeSet(childParser); while ((type = childParser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty. &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(childParser.getPositionDescription() + ": No start tag found!"); &#125; final String childName = childParser.getName(); if (TAG_MERGE.equals(childName)) &#123; //解析 Meger 标签 rInflate(childParser, parent, context, childAttrs, false); &#125; else &#123; //根据 name名称来创建View final View view = createViewFromTag(parent, childName, context, childAttrs, hasThemeOverride); final ViewGroup group = (ViewGroup) parent; //获取 View 的 id 和其 Visiable 属性 final TypedArray a = context.obtainStyledAttributes( attrs, R.styleable.Include); final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID); final int visibility = a.getInt(R.styleable.Include_visibility, -1); a.recycle(); //需要将 Parent中的 LayoutParams 设置为其 Params 属性。 //如果 Parent 没有通用的 Params，那么就会抛出Runtime 异常 //然后会为其设置 include 包裹内容的通用 Params， ViewGroup.LayoutParams params = null; try &#123; params = group.generateLayoutParams(attrs); &#125; catch (RuntimeException e) &#123; // Ignore, just fail over to child attrs. &#125; if (params == null) &#123; params = group.generateLayoutParams(childAttrs); &#125; view.setLayoutParams(params); // 解析子标签 rInflateChildren(childParser, view, childAttrs, true); if (id != View.NO_ID) &#123; view.setId(id); &#125; // 加载include内容时，需要直接设置其 可见性 switch (visibility) &#123; case 0: view.setVisibility(View.VISIBLE); break; case 1: view.setVisibility(View.INVISIBLE); break; case 2: view.setVisibility(View.GONE); break; &#125; //添加至父容器中 group.addView(view); &#125; &#125; finally &#123; childParser.close(); &#125; &#125; &#125; else &#123; throw new InflateException("&lt;include /&gt; can only be used inside of a ViewGroup"); &#125; LayoutInflater.consumeChildElements(parser); &#125; 先把parseInclude()这个方法全景先看下，然后我们在进行分拆，一部分一部分分析。 parseInclude()参数解读parseInclude()中分别含义四个参数： 解析器 -&gt; XmlPullParser parser用来解析XML文件的解析器，通过解析器可以得到当前节点的相对应的AttributeSet（属性集） 上下文对象 - &gt; Context context当前加载该XML的上下文对象，并且这个Context与LayoutInflater属于相互绑定关系（一一对应） 父容器 - &gt; View parent包裹该节点的父容器，一般来说都是继承ViewGroup实现的视图组 属性集 -&gt; AttributeSet attrs该节点的属性集，包括所有该节点的相关属性 Include中的theme属性这里大家先了解一个相关的问题，关于include标签设置theme属性的情况： 一般来说theme（主题）一般出现在Activtiy的AndroidManifest文件下，来给Activity设置统一的布局效果，而且可以使用如下的操作来进行主题属性的使用。 12// ?attr这样的形式，使用主题中的设置参数android:background=&quot;?attr/colorPrimary&quot; 如果Include标签下设置了新的theme，那么Include中的内容在使用主题属性时，使用的theme主题就是（include）设置的内容，而不是Activity默认下的主题，形成了一种覆盖效果。 也就是说Include标签设置的主题可以覆盖Activity设置的根主题，但是Include设置的主题只作用与Include内部。 举个栗子：style.xml 先定义好两个基础Theme，一个是作为App的基础主题，另一个是include中的主题。 1234567891011121314&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- BaseApplication theme --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;IncludeTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;!-- Include Theme --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; AndroidManifest.xml 设置Activity的基础主题为AppTheme 123&lt;activity android:name=&quot;com.demo.MainActivity&quot; android:theme=&quot;@style/AppTheme&quot;&gt;&lt;/activity&gt; activity_main.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!-- 这里是使用基础Theme的Toolbar --&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/activity_theme_tb&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;?attr/colorPrimary&quot; /&gt; &lt;!-- 这里是自带Theme Include的Toolbar --&gt; &lt;include layout=&quot;@layout/test_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:theme=&quot;@style/IncludeTheme&quot; /&gt;&lt;/RelativeLayout&gt; 接下来，我们在看一下Include包裹的布局 test_toolbar.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/include_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;?attr/colorPrimary&quot; /&gt;&lt;/LinearLayout&gt; 从上面的XML文件我们可以看出两个Toolbar调用的background都指向theme的colorPrimary属性，接下来看一下显示效果： 从效果图可以发现，Include Toolbar显示的颜色是粉色的，也就是Include额外设置的theme，这里也是从正面证明了这个概念。 第一部分：Include Theme主题的设置12345678910//------------------&lt;第一部分&gt;-------------------////提取出Theme属性final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);final int themeResId = ta.getResourceId(0, 0);final boolean hasThemeOverride = themeResId != 0;//如果存在Theme属性，那么Include包含的子标签都会使用该主题if (hasThemeOverride) &#123; context = new ContextThemeWrapper(context, themeResId);&#125;ta.recycle(); 通过上面的介绍，很明显这段代码含义，就是检测是否给Include标签设置了Theme属性，如果设置theme，就创建相应的ContextThemeWrapper，用于之后子标签的解析时theme的使用。 第二部分：Include 内容布局的设置123456789101112131415161718192021//------------------&lt;第二部分&gt;-------------------////先获取 layout 属性（资源 id）是否设置int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);if (layout == 0) &#123; //如果没直接设置布局的资源 id，那么就检索?attr/name这一类的 layout 属性 final String value = attrs.getAttributeValue(null, ATTR_LAYOUT); if (value == null || value.length() &lt;= 0) &#123; throw new InflateException("You must specify a layout in the" + " include tag: &lt;include layout=\"@layout/layoutID\" /&gt;"); &#125; //从?attr/name 这一类的属性中，获取布局属性 layout = context.getResources().getIdentifier(value.substring(1), null, null);&#125;//这个布局资源也许存在主题属性中，所以需要去主题属性中解析if (mTempValue == null) &#123; mTempValue = new TypedValue();&#125;if (layout != 0 &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, true)) &#123; layout = mTempValue.resourceId;&#125; 这部分的内容主要是提取Include的内容布局的提取，Include的内容布局的设置有两种： 第一种 ： 直接@layout 后面设置布局的XMLlayout=&quot;@layout/test_toolbar&quot; 第二种：通过引入theme的item设置的layout属性Include标签下：layout=&quot;?attr/theme_layout&quot; 包裹Include标签的布局Theme（注意：这里不是Include设置的主题）：1234567&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; //重点在这里！！！！！ &lt;item name=&quot;theme_layout&quot;&gt;@layout/test_toolbar&lt;/item&gt;&lt;/style&gt; 而上面的代码的作用是检索layout属性，如果layout已经以第一种方式引入，就不需要在去theme中检索，如果layout第一种方式检索不到资源ID，那么就会去以第二种方式进行检索。 第三部分： Include标签的View处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 //------------------&lt;第三部分&gt;-------------------// //如果此时还找不到layout，那么必然异常~，会报找不到资源ID的layout异常 if (layout == 0) &#123; final String value = attrs.getAttributeValue(null, ATTR_LAYOUT); throw new InflateException(&quot;You must specify a valid layout &quot; + &quot;reference. The layout ID &quot; + value + &quot; is not valid.&quot;); &#125; else &#123; //生成子解析器 final XmlResourceParser childParser = context.getResources().getLayout(layout); try &#123; final AttributeSet childAttrs = Xml.asAttributeSet(childParser); //----------------省略了XML一些规则的判断----------------// //获取子节点的名称 final String childName = childParser.getName(); if (TAG_MERGE.equals(childName)) &#123; //解析 Meger 标签 rInflate(childParser, parent, context, childAttrs, false); &#125; else &#123; //根据 name名称来创建View final View view = createViewFromTag(parent, childName, context, childAttrs, hasThemeOverride); final ViewGroup group = (ViewGroup) parent; //获取 View 的 id 和其 Visiable 属性 final TypedArray a = context.obtainStyledAttributes( attrs, R.styleable.Include); final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID); final int visibility = a.getInt(R.styleable.Include_visibility, -1); a.recycle(); //需要将 Parent中的 LayoutParams 设置为其 Params 属性。 //如果 Parent 没有通用的 Params，那么就会抛出Runtime 异常 //然后会为其设置 include 包裹内容的通用 Params， ViewGroup.LayoutParams params = null; try &#123; params = group.generateLayoutParams(attrs); &#125; catch (RuntimeException e) &#123; // Ignore, just fail over to child attrs. &#125; if (params == null) &#123; params = group.generateLayoutParams(childAttrs); &#125; view.setLayoutParams(params); // 解析子标签 rInflateChildren(childParser, view, childAttrs, true); if (id != View.NO_ID) &#123; view.setId(id); &#125; // 加载include内容时，需要直接设置其 可见性 switch (visibility) &#123; case 0: view.setVisibility(View.VISIBLE); break; case 1: view.setVisibility(View.INVISIBLE); break; case 2: view.setVisibility(View.GONE); break; &#125; //添加至父容器中 group.addView(view); &#125; &#125; finally &#123; childParser.close(); &#125; &#125;&#125; else &#123; throw new InflateException(&quot;&lt;include /&gt; can only be used inside of a ViewGroup&quot;);&#125; 这部分主要的作用是解析Include包裹layout的根标签： ###（1）先特别处理Merge标签 ： 如果子节点是Merge标签，那么直接进行内容的解析，调用rInflater()方法。 而rInflater()这个方法的作用是，解析某个节点，根据节点的不同类型从而进行不同的处理 ###（2）解析Include的内容： 在这之前先通过createViewFromTag()方法，根据名称来生成相对应的View 这里分成两块内容第一块是设置LayoutParams： 123456789101112ViewGroup.LayoutParams params = null;try &#123; //加载Include的父ViewGroup的LayoutParams params = group.generateLayoutParams(attrs);&#125; catch (RuntimeException e) &#123; // Ignore, just fail over to child attrs.&#125;if (params == null) &#123; //加载Include的子ViewGroup的LayoutParams params = group.generateLayoutParams(childAttrs);&#125;view.setLayoutParams(params); 这段的作用是为Include的包裹的根View设置LayoutParams，使用的LayoutParams默认是Include外层的ViewGroup。 如果此时Params加载失败，那就会使用Include包裹的ViewGroup的LayoutParams，反正怎么都得设置一个。 第二块是在这里设置子ViewGroup的显隐性： 1234567891011121314// 加载include内容时，需要直接设置其 可见性switch (visibility) &#123; case 0: view.setVisibility(View.VISIBLE); break; case 1: view.setVisibility(View.INVISIBLE); break; case 2: view.setVisibility(View.GONE); break;&#125;//添加至父容器中group.addView(view); 设置ViewGroup的显隐性，之后就将其添加至父View中，至此parseInclude的分析就到此结束。 流程图 效果 分析这个效果属于视觉差的效果，原理是根据ViewPager的滑动方向，页面内物理做同向偏移，只要偏移距离大于页面的偏移，就会产生速度差，那么就会实现该效果。 实现速度差，我们需要一个滑动的比例系数： 在页面进入时： 页面物体的移动距离 = (页面长度 - 滑动距离) * 滑动系数 在页面滑出时： 页面物体的移动距离 = （0 - 滑动距离 ） * 滑动系数 同时考虑第二张Gif上，发现物体Y轴也存在移动，所以也得需要考虑Y轴方向的滑动，整理下： 1234567//进入时：view.setTranslateX((vpWidth - positionOffsetPixels) * xIn);view.setTranslateY((vpWidth - positionOffsetPixels) * yIn);//退出时view.setTranslateX((0 - positionOffsetPixels) * xOut);view.setTranslateY((0 - positionOffsetPixels) * yOut); 这样就可以实现出： 进入该界面时，界面上的物品快速飞进来。 退出该界面时，界面上的物理快速飞出去。 实现思路对于上述的分析，这里的实现思路存在两种： 自定义View，自定义xIn、yIn、xOut、yOut四个属性的系数，所有界面上的物体继承这个自定义View。 自定义LayoutInflater.Factory在解析时，将这些自定义属性提取，以Tag方式储存起来。 优缺点分析自定义View： 优点：可以对物体做更多层面的扩展，这个自定义LayoutInflater.Factory是不具备的。 缺点：由于界面的物体数量过多，在findViewById时需要处理的View元素过多，极大的增加代码量。 自定义LayoutInflater.Factory : 优点：可以在解析过程中对View做统一操作，当出现大量的View时，能够缩减大量代码。 缺点：在解析时预处理View，但是就不能动态的改变View的属性，要对View进行扩展性操作，自定义LayoutInflater.Factory不具备这样的功能。 自定义LayoutInflater.Factory 上述的两种方案的优缺点已经分析完毕，但是本文作为实战篇，所以只会介绍自定义LayoutInflater.Factory这种方式。 在实际场景中，需要结合自身情况，以及上述的优缺点，进行合理选择。 在介绍之前，先看一段代码： 1234567891011121314View view;//如果Factory2存在，就会调用其onCreateView方法if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); //如果Factory存在，就会调用其onCreateView方法，和Factory2不同的时，这里的参数没有父View&#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs);&#125; else &#123; view = null;&#125;//如果没有Factory或者Factory2，就会寻找mPrivateFactory（本质上也是Factory2）if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs);&#125; 这段代码出自LayoutInflater中createViewFromTag()方法，作用是根据View的名称（name参数）来创建View. 在这里就简单描述下，这个方法的主要流程： 对一些特殊标签，做分别处理，例如：view，TAG_1995(blink) 进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View 如果没有设置Factory或Factory2，那么就会使用LayoutInflater默认的生成方式，进行View的生成 在实战篇中，只有第二部分和我们今天的内容是相关的，我们在看一遍第二条。 进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View 如果设置了Factory或者Factory2，那么就不会使用LayoutInflater默认的生成方式，那么生成View的过程，就由我们自主把控，这才是我们自定义LayoutInflater.Factory的主要原因。 自定义Factory还是Factory2 ？12345678910View view;//如果Factory2存在，就会调用其onCreateView方法if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); //如果Factory存在，就会调用其onCreateView方法，和Factory2不同的时，这里的参数没有父View&#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs);&#125; else &#123; view = null;&#125; 我们能够从这段代码中得出，Factory2比Factory的优先级要高，即Factory2存在Factory就不可能会被调用，同理可以得出结论： 123优先级顺序:mFactory2 &gt; mFactory &gt; mPrivateFactory &gt; LayoutInflater默认处理方式 而且我们还能够发现mFactory2的onCreateView()方法与mFactory是不相同的： 12345//mFactory2mFactory2.onCreateView(parent, name, context, attrs);//mFactoryview = mFactory.onCreateView(name, context, attrs); 根据上述的分析，我们可以得出结论： 12345(1)Factory2的调用优先级比Factory要高(2)Factory2的onCreateView()方法，会比Factory多返回一个父View的参数。(3)Factory2和Factory是互斥的，（如果不通过反射的话）只能设置一个。 第三条在CreateViewFromTag的那篇文章已经分析过了，这里不做过多的解释了。 实际选择的过程中，一般会选择自定义Factory2，因为Factory2本身也继承了Factory接口，而且Factory2的优先级比较高。 注意事项设置Factory但是发现无响应，是因为本身LayoutInflater中存在Factory2**因为一般使用方式，是直接调用cloneInContext()方法，我们知道一般的默认解析器都是PhoneLayoutInflater，我们看下其实现方式： 123protected PhoneLayoutInflater(LayoutInflater original, Context newContext) &#123; super(original, newContext);&#125; 本质就是调用LayoutInflater的两参构造方法： 1234567protected LayoutInflater(LayoutInflater original, Context newContext) &#123; mContext = newContext; mFactory = original.mFactory; mFactory2 = original.mFactory2; mPrivateFactory = original.mPrivateFactory; setFilter(original.mFilter);&#125; 在这里可以看出，cloneInContext会把原LayoutInflater的Factory2和Factory一并复制。 因为Factory比Factory2的优先级低，所以才会不出现效果。 解决方案 ： （1）自定义LayoutInflater，并且改写cloneInContext，使其不复制原LayoutInflater的Factory2以及Factory。 1234567891011public class CustomLayoutInflater extends LayoutInflater &#123; protected CustomLayoutInflater(Context context) &#123; super(context); &#125; @Override public LayoutInflater cloneInContext(Context newContext) &#123; return new CustomLayoutInflater(newContext); &#125;&#125; （2）使用时，直接通过new出实例，然后setFactory 123CustomLayoutInflater newInflater = new CustomLayoutInflater(getActivity());newInflater.setFactory2(new CustomAppFactory(newInflater, this));return newInflater.inflate(layoutId, null); 使用AppCompatActivity直接setFactory2或者setFactory为什么报错？这是因为 AppCompatActivity 在初始化的时候，已经设置了 Factory，下面来看下这部分代码 123456789@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; final AppCompatDelegate delegate = getDelegate(); //注意这个方法 delegate.installViewFactory(); delegate.onCreate(savedInstanceState); //.....省略多余的代码.......... super.onCreate(savedInstanceState);&#125; 继续查看 installViewFactory（）方法 12345678910@Overridepublic void installViewFactory() &#123; LayoutInflater layoutInflater = LayoutInflater.from(mContext); if (layoutInflater.getFactory() == null) &#123; //这句话是设置 Factory 的方法 LayoutInflaterCompat.setFactory(layoutInflater, this); &#125; else &#123; //省略部分代码。。。。。。 &#125;&#125; 可以发现，在onCreate 时 LayoutInflater 已经设置过一次 Factory 了，然后我再来看下 setFactory() 的源码： 123456789101112public void setFactory(Factory factory) &#123; if (mFactorySet) &#123; //原因就是这一句 throw new IllegalStateException("A factory has already been set on this LayoutInflater"); &#125; mFactorySet = true; if (mFactory == null) &#123; mFactory = factory; &#125; else &#123; mFactory = new FactoryMerger(factory, null, mFactory, mFactory2); &#125;&#125; 根据上面代码，就可以发现报错原因了。 解决方案 ： 在使用前，先使用 cloneInContext()克隆出一个新的 LayoutInflater，然后在进行设置操作。 123LayoutInflate newInflater = LayoutInflater.cloneInContext(inflater,context);newInflater.setFactory(new CustomFactory（）)； 这样就避开在原 LayoutInflater 设置 Factory 报错了。 自定义Factory2的实现 ——&gt; CustomAppFactory根据上面的展示效果，我们可以判断出是ViewPager + Fragment的风格，所以我们自定义Factory应该在Fragment的onCreateView中，更改LayoutInflater。 而且根据注意事项，我们一般会自定义优先级较高的Factory2，防止本身cloneInContext的LayoutInflater中已经存在Factory2，我们使用Factory会无效。 使用方式123456789public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; Bundle bundle = getArguments(); int layoutId = bundle.getInt(LAYOUT_ID); //注意需要调用cloneInContext方法生成新的LayoutInflater LayoutInflater newInflater = inflater.cloneInContext(getActivity()); //调用的是setFactory2而非setFactory newInflater.setFactory2(new CustomAppFactory(newInflater, this)); return newInflater.inflate(layoutId, null);&#125; 自定义过程那么就创建一个类CustomAppFactory来实现Factory2的接口，复写onCreateView的方法。 123456789101112131415161718192021222324252627282930313233@Overridepublic View onCreateView(String name, Context context, AttributeSet attrs) &#123; View view = null; //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;第一部分&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; try &#123; if (name.contains(".")) &#123; String checkName = name.substring(name.lastIndexOf(".")); String prefix = name.substring(0, name.lastIndexOf(".")); view = defaultInflater(checkName, prefix, attrs); &#125; if (name.equals("View") || name.equals("ViewGroup")) &#123; view = defaultInflater(name, sClassPrefix[1], attrs); &#125; else &#123; view = defaultInflater(name, sClassPrefix[0], attrs); &#125; //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;第二部分&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; //实例化完成 if (view != null) &#123; //获取自定义属性,通过标签关联到视图上 setViewTag(view, context, attrs); mInflaterView.addView(view); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return view;&#125;@Overridepublic View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; View view = onCreateView(name, context, attrs); return view;&#125; 其实如果我们采取自定义的方式，这里只会调用onCreateView()四位参数的方法，因为在比较Factory2和Factory的代码也介绍过了。 我们实现的逻辑是在onCreateView()三位逻辑里面，因为需要实现的效果不需要Parent（父View），所以这里逻辑实现全在三位参数的onCreateView()中。 在这里我们将onCreateView()中，分成2部分内容： 根据名称解析出View 扩展操作，将额外的属性，提取出来储存在Tag中 onCreateView第一部分内容12345678910if (name.contains(".")) &#123; String checkName = name.substring(name.lastIndexOf(".")); String prefix = name.substring(0, name.lastIndexOf(".")); view = defaultInflater(checkName, prefix, attrs);&#125;if (name.equals("View") || name.equals("ViewGroup")) &#123; view = defaultInflater(name, sClassPrefix[1], attrs);&#125; else &#123; view = defaultInflater(name, sClassPrefix[0], attrs);&#125; 这里判断了name中是否包含“.”，是用来判断生成的View是否是自定义View，下面来看下自定义View和Android自带的组件的区别： 1234//原生的组件RelativeLayout//自定义Viewcom.demo.guidepagedemo.customview.CustomImageView 可以发现区别为原生的View不带前缀，而自定义View是包括前缀的，所以会用name.contains(“.”)来区分。 而原生组件中View和ViewGroup是属于android.view包下，其他的例如：RelativeLayout，LinearLayout是属于android.widget包下。 1234private final String[] sClassPrefix = &#123; &quot;android.widget.&quot;, &quot;android.view.&quot;&#125;; 所以在之后会对View和ViewGroup作区分，上面把sClassPrefix贴出来了。 而这里真正的解析过程最后还是交给LayoutInflater，调用LayoutInflater的onCreateView方法： 123456789private View defaultInflater(String name, String prefix, AttributeSet attrs) &#123; View view = null; try &#123; view = mInflater.createView(name, prefix, attrs); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return view;&#125; onCreateView第二部分内容123456//实例化完成if (view != null) &#123; //获取自定义属性,通过标签关联到视图上 setViewTag(view, context, attrs); mInflaterView.addView(view);&#125; 在这里做拓展处理的，setViewTag方法是处理View的自定义属性，然后将这些属性包装成类，给View设置Tag setViewTag方法 1234567891011121314151617/** * 将View的属性信息存储在Tag中 */private void setViewTag(View view, Context context, AttributeSet attrs) &#123; //解析自定义的属性 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.CustomImageView); if (attrs != null &amp;&amp; array.length() &gt; 0) &#123; AttrTagBean bean = new AttrTagBean(); bean.xIn = array.getFloat(R.styleable.CustomImageView_in_value_x, 0f); bean.xOut = array.getFloat(R.styleable.CustomImageView_out_value_x, 0f); bean.yIn = array.getFloat(R.styleable.CustomImageView_in_value_y, 0f); bean.yOut = array.getFloat(R.styleable.CustomImageView_out_value_y, 0f); //index view.setTag(bean); &#125; array.recycle();&#125; 上面对应的是本文我们开始设置的4个系数： 1234567R.styleable.CustomImageView_in_value_x --&gt; 进入时 x方向的系数R.styleable.CustomImageView_out_value_x --&gt; 退出时 x方向的系数R.styleable.CustomImageView_in_value_y --&gt; 进入时 y方向的系数R.styleable.CustomImageView_out_value_y --&gt; 退出时 y方向的系数 而这里的mInflaterView是一个抽象接口，让Fragment来实现的，通过在Fragment中内置一个List《View》，到时候可以遍历统一操作这些View，下面是实现过程： 123456789101112131415public interface InflaterViewImpl &#123; /** * 获取View集合 * * @return */ List&lt;View&gt; getViews(); /** * 添加元素 */ void addView(View view);&#125; Fragment中的实现过程： 12345678910111213141516171819public class PageFragment extends Fragment implements InflaterViewImpl &#123; private List&lt;View&gt; views = new ArrayList&lt;&gt;(); //**************篇幅原因省略了部分方法************************// @Override public List&lt;View&gt; getViews() &#123; return views; &#125; @Override public void addView(View view) &#123; if (views.contains(view)) &#123; return; &#125; views.add(view); &#125;&#125; 处理ViewPager的滑动这是实战篇的最后一部分内容，主要介绍的是ViewPager的滑动监听相关的处理，因为所有效果是基于ViewPager的滑动监听来显示的。 因为本文主要介绍内容是自定义LayoutInflater.Factory，所以这里会简单叙述下： ```javamInflaterVp.addOnPageChangeListener(new ViewPager.OnPageChangeListener() { @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { //获取ViewPager的宽度 int vpWidth = mInflaterVp.getWidth(); //获取正在进入的界面 PageFragment inFragment = getPosition(position - 1); if (inFragment != null) { List views = inFragment.getViews(); if (views != null &amp;&amp; views.size() &gt; 0) { for (View view : views) { AttrTagBean tag = (AttrTagBean) view.getTag(); if (tag != null) { view.setTranslationX((vpWidth - positionOffsetPixels) tag.xIn); view.setTranslationY((vpWidth - positionOffsetPixels) tag.yIn); } } } } //当前正在滑动的界面 PageFragment outFragment = getPosition(position); if (outFragment != null) { List&lt;View&gt; views = outFragment.getViews(); if (views != null &amp;&amp; views.size() &gt; 0) { for (View view : views) { AttrTagBean tag = (AttrTagBean) view.getTag(); if (tag != null) { view.setTranslationX((0 - positionOffsetPixels) * tag.xOut); view.setTranslationY((0 - positionOffsetPixels) * tag.yOut); } } } } @Override public void onPageSelected(int position) { //当划到最后一页时，小人的图标消失 if (position == fragments.size() - 1) { mInflaterIv.setVisibility(View.GONE); } else { mInflaterIv.setVisibility(View.VISIBLE); } } @Override public void onPageScrollStateChanged(int state) { //这里是处理图中的小人的帧动画过程 Drawable anim = mInflaterIv.getBackground(); if (!(anim instanceof AnimationDrawable)) { return; } AnimationDrawable animation = (AnimationDrawable) anim; Log.d(&quot;滑动状态&quot;, state + &quot;&quot;); switch (state) { //空闲状态 case ViewPager.SCROLL_STATE_IDLE: animation.stop(); break; //拖动状态 case ViewPager.SCROLL_STATE_DRAGGING: animation.start(); break; //惯性滑动状态 case ViewPager.SCROLL_STATE_SETTLING: break; } } }); 小红书引导页]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Camera和Matrix实现真正的3D(WheelView)日期,地址选择滚轮控件]]></title>
      <url>%2F2017%2F10%2F12%2Fandroid-camera-matrix%2F</url>
      <content type="text"><![CDATA[前言Camera和Matrix实现真正的3D(WheelView)日期,地址选择滚轮控件 先看效果图 垂直方向的3D旋转 水平方向的3D旋转 功能分析3D旋转效果WheelView的实现方式已经有很多种方式, 而且网上也有实现好的旋转效果,不过只是2D的旋转,而且要处理滑动与单击item事件比较复杂,真正的旋转是要通过Matrix, Camera类来实现,这里的Camera不是照相机里的API,Camera可以实现x,y,z轴的旋转,不清楚的可以去也解这些API的使用, 这里不详细介绍, 配合RecyclerView.ItemDecoration,在每个item中将Canvas进行3D旋转并平移,产生3D视觉效果 这里拿垂直布局的一种状态来做示例 12345678910111213141516171819202122232425262728293031323334353637383940/** * 画垂直布局时的item * @param c * @param rect * @param position * @param parentCenterX RecyclerView的中心X点 * @param parentCenterY RecyclerView的中心Y点 */void drawVerticalItem(Canvas c, Rect rect, int position, float parentCenterX, float parentCenterY) &#123; int realPosition = position - itemCount;//数据中的实际位置 float itemCenterY = rect.exactCenterY(); float scrollOffY = itemCenterY - parentCenterY; float rotateDegreeX = scrollOffY * itemDegree / itemSize;//垂直布局时要以X轴为中心旋转 int alpha = degreeAlpha(rotateDegreeX); if (alpha &lt;= 0) return; float rotateSinX = (float) Math.sin(Math.toRadians(rotateDegreeX)); float rotateOffY = scrollOffY - wheelRadio * rotateSinX;//因旋转导致界面视角的偏移 //Log.i("you", "drawVerticalItem degree " + rotateDegreeX); //计算中心item, 优先最靠近中心区域的为中心点 boolean isCenterItem = false; if (!hasCenterItem) &#123; isCenterItem = Math.abs(scrollOffY) &lt;= halfItemHeight; if (isCenterItem) &#123; centerItemPosition = realPosition; hasCenterItem = true; &#125; &#125; //这里是旋转操作的核心,每个item在旋转成弧时，都要将item的中心在旋转后给人的视觉上的偏移计算好 c.save(); c.translate(0.0f, -rotateOffY); camera.save(); camera.rotateX(-rotateDegreeX); camera.getMatrix(matrix); camera.restore(); matrix.preTranslate(-parentCenterX, -itemCenterY); matrix.postTranslate(parentCenterX, itemCenterY); c.concat(matrix); drawItem(c, rect, realPosition, alpha, isCenterItem, true); c.restore();&#125; 到这里基本已经实现了每个item距离中心点的旋转效果,接下来就是添加WheelView显示的数量在RecyclerView头与尾部的空的item 适配器定义滑动的时候,item要能滑动距中心点以上,也可以滑动到中心点以下,所以适配器中的item数量也要对应改变,直接上代码 1234567891011121314151617181920212223class WheelViewAdapter extends RecyclerView.Adapter&lt;WheelViewHolder&gt; &#123; ...伪代码 @Override public void onBindViewHolder(WheelViewHolder holder, int position) &#123; //由于里面的文本全是画的,这里只是绑定最原始的View &#125; @Override public int getItemCount() &#123; // 这里的totalItemCount就是滑轮控件距离中心点显示的item个数 乘2 return totalItemCount + (adapter == null ? 0 : adapter.getItemCount()); &#125; @Override public WheelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; //适配器里根据垂直或水平布局显示 View view = new View(parent.getContext()); view.setLayoutParams(WheelUtils.createLayoutParams(orientation, itemSize)); return new WheelViewHolder(view); &#125;&#125; 总结：WheelView具体使用方法,示例代码中都有详细介绍,由于工作忙没有时间详细介绍里面的内容，源码里都有适当的注释，也可以一起讨论更佳的效果 后面有空再加上item点击与左右偏移时的立体效果,还有封装日期选择等…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-实现dialog的3D翻转]]></title>
      <url>%2F2017%2F10%2F11%2Fandroid-dialog-overturn%2F</url>
      <content type="text"><![CDATA[效果图本文实现了 Android 中 dialog 的 3D 翻转效果。这里通过一个简单的应用场景记录下。 分析 起初自己的思路是 Activity 进行界面跳转实现旋转效果，网上看了很多，写下来发现效果不对。之后又看到 Google 上面的 Card Flid Animation 效果是这样的。 看着确实不错，然而拿下来 demo 放慢翻转速度后发现，不是我想要的。但是跟我看到的一个 app 里面的效果一样然后想改成 dialog 试试效果，发现更是不行了。 Card Flid Animation效果如下：这个是通过Activity来切换Fragment实现的，可以看到区别是翻转时候貌似会变大，其实没用，只是翻转后的视觉问题。 听说 openGl 比较麻烦，并且没有用过。然后就搜了下Rotate3DAnimaitons。搜到了这篇文章所以这篇文章里的实现方法不是我的原创，是参考人家的。在这里感谢这位大神。不过他这个是 activity 里的，我就想要一个 dialog 效果，因为电脑上TIM 的打开红包这个 3D 效果看着不错，其实大同小异，就拿过来改成Dialog。对于 Rotate3DAnimaitons 这篇文章已经很详细了，有需要的可以参考下。 Rotate3dAnimation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * An animation that rotates the view on the Y axis between two specified angles. * This animation also adds a translation on the Z axis (depth) to improve the effect. */public class Rotate3dAnimation extends Animation &#123; private final float mFromDegrees; private final float mToDegrees; private final float mCenterX; private final float mCenterY; private final float mDepthZ; private final boolean mReverse; private Camera mCamera; /** * Creates a new 3D rotation on the Y axis. The rotation is defined by its * start angle and its end angle. Both angles are in degrees. The rotation * is performed around a center point on the 2D space, definied by a pair * of X and Y coordinates, called centerX and centerY. When the animation * starts, a translation on the Z axis (depth) is performed. The length * of the translation can be specified, as well as whether the translation * should be reversed in time. * * @param fromDegrees the start angle of the 3D rotation //起始角度 * @param toDegrees the end angle of the 3D rotation //结束角度 * @param centerX the X center of the 3D rotation //x中轴线 * @param centerY the Y center of the 3D rotation //y中轴线 * @param reverse true if the translation should be reversed, false otherwise//是否反转 */ public Rotate3dAnimation(float fromDegrees, float toDegrees, float centerX, float centerY, float depthZ, boolean reverse) &#123; mFromDegrees = fromDegrees; mToDegrees = toDegrees; mCenterX = centerX; mCenterY = centerY; mDepthZ = depthZ;//Z轴移动的距离，这个来影响视觉效果，可以解决flip animation那个给人看似放大的效果 mReverse = reverse; &#125; @Override public void initialize(int width, int height, int parentWidth, int parentHeight) &#123; super.initialize(width, height, parentWidth, parentHeight); mCamera = new Camera(); &#125; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &#123; final float fromDegrees = mFromDegrees; float degrees = fromDegrees + ((mToDegrees - fromDegrees) * interpolatedTime); final float centerX = mCenterX; final float centerY = mCenterY; final Camera camera = mCamera; final Matrix matrix = t.getMatrix(); Log.i("interpolatedTime", interpolatedTime+""); camera.save(); if (mReverse) &#123; camera.translate(0.0f, 0.0f, mDepthZ * interpolatedTime); &#125; else &#123; camera.translate(0.0f, 0.0f, mDepthZ * (1.0f - interpolatedTime)); &#125; camera.rotateY(degrees); camera.getMatrix(matrix); camera.restore(); matrix.preTranslate(-centerX, -centerY); matrix.postTranslate(centerX, centerY); &#125;&#125; dialog实现3D翻转代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206public class MyDialog extends Dialog &#123; @BindView(R.id.et_user_name) EditText etUserName; @BindView(R.id.et_password) EditText etPassword; @BindView(R.id.cb_auto_login) CheckBox cbAutoLogin; @BindView(R.id.tv_forget_pwd) TextView tvForgetPwd; @BindView(R.id.ll_content) LinearLayout llContent; @BindView(R.id.et_email) EditText etEmail; @BindView(R.id.btn_back) Button btnBack; @BindView(R.id.container) RelativeLayout container; private Context context; @BindView(R.id.ll_register) LinearLayout llRegister; //接口回调传递参数 private OnClickListenerInterface mListener; private View view;// private String strContent; private int centerX; private int centerY; private int depthZ = 700;//修改此处可以改变距离来达到你满意的效果 private int duration = 300;//动画时间 private Rotate3dAnimation openAnimation; private Rotate3dAnimation closeAnimation; private boolean isOpen = false; public interface OnClickListenerInterface &#123; /** * 确认, */ void doConfirm(); /** * 取消 */// public void doCancel(); &#125; public MyDialog(Context context) &#123; super(context); this.context = context; &#125; public MyDialog(Context context, String content) &#123; super(context); this.context = context; this.strContent = content; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //去掉系统的黑色矩形边框 getWindow().setBackgroundDrawableResource(android.R.color.transparent); requestWindowFeature(Window.FEATURE_NO_TITLE); init(); &#125; public void init() &#123; LayoutInflater inflater = LayoutInflater.from(context); view = inflater.inflate(R.layout.dialog_my, null); setContentView(view); ButterKnife.bind(this); etPassword.setTypeface(Typeface.DEFAULT); etPassword.setTransformationMethod(new PasswordTransformationMethod()); tvForgetPwd.setOnClickListener(new OnWidgetClickListener()); btnBack.setOnClickListener(new OnWidgetClickListener()); Window dialogWindow = getWindow(); WindowManager.LayoutParams lp = dialogWindow.getAttributes(); DisplayMetrics d = context.getResources().getDisplayMetrics(); // 获取屏幕宽、高用 lp.width = (int) (d.widthPixels * 0.8); // 宽度设置为屏幕的0.8 lp.height = (int) (d.heightPixels * 0.6); // 高度设置为屏幕的0.6 dialogWindow.setAttributes(lp); setCanceledOnTouchOutside(false); setCancelable(true); &#125; public void setClicklistener(OnClickListenerInterface clickListenerInterface) &#123; this.mListener = clickListenerInterface; &#125; private class OnWidgetClickListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; int id = v.getId(); switch (id) &#123; case R.id.tv_forget_pwd: startAnimation(); break; case R.id.btn_back: startAnimation(); break; &#125; &#125; &#125; private void startAnimation() &#123; //接口回调传递参数 centerX = container.getWidth() / 2; centerY = container.getHeight() / 2; if (openAnimation == null) &#123; initOpenAnim(); initCloseAnim(); &#125; //用作判断当前点击事件发生时动画是否正在执行 if (openAnimation.hasStarted() &amp;&amp; !openAnimation.hasEnded()) &#123; return; &#125; if (closeAnimation.hasStarted() &amp;&amp; !closeAnimation.hasEnded()) &#123; return; &#125; //判断动画执行 if (isOpen) &#123; container.startAnimation(openAnimation); &#125; else &#123; container.startAnimation(closeAnimation); &#125; isOpen = !isOpen; &#125; /** *注意旋转角度 */ private void initOpenAnim() &#123; //从0到90度，顺时针旋转视图，此时reverse参数为true，达到90度时动画结束时视图变得不可见， openAnimation = new Rotate3dAnimation(0, 90, centerX, centerY, depthZ, true); openAnimation.setDuration(duration); openAnimation.setFillAfter(true); openAnimation.setInterpolator(new AccelerateInterpolator()); openAnimation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; llRegister.setVisibility(View.GONE); llContent.setVisibility(View.VISIBLE); //从270到360度，顺时针旋转视图，此时reverse参数为false，达到360度动画结束时视图变得可见 Rotate3dAnimation rotateAnimation = new Rotate3dAnimation(270, 360, centerX, centerY, depthZ, false); rotateAnimation.setDuration(duration); rotateAnimation.setFillAfter(true); rotateAnimation.setInterpolator(new DecelerateInterpolator()); container.startAnimation(rotateAnimation); &#125; &#125;); &#125; private void initCloseAnim() &#123; closeAnimation = new Rotate3dAnimation(360, 270, centerX, centerY, depthZ, true); closeAnimation.setDuration(duration); closeAnimation.setFillAfter(true); closeAnimation.setInterpolator(new AccelerateInterpolator()); closeAnimation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; llRegister.setVisibility(View.VISIBLE); llContent.setVisibility(View.GONE); Rotate3dAnimation rotateAnimation = new Rotate3dAnimation(90, 0, centerX, centerY, depthZ, false); rotateAnimation.setDuration(duration); rotateAnimation.setFillAfter(true); rotateAnimation.setInterpolator(new DecelerateInterpolator()); container.startAnimation(rotateAnimation); &#125; &#125;); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-SpannableString与SpannableStringBuilder]]></title>
      <url>%2F2017%2F10%2F10%2Fandroid-spannablestring-spannablestringbuilder%2F</url>
      <content type="text"><![CDATA[概述SpannableString、SpannableStringBuilder与String的关系首先SpannableString、SpannableStringBuilder基本上与String差不多，也是用来存储字符串，但它们俩的特殊就在于有一个SetSpan（）函数，能给这些存储的String添加各种格式或者称样式（Span），将原来的String以不同的样式显示出来，比如在原来String上加下划线、加背景色、改变字体颜色、用图片把指定的文字给替换掉，等等。所以，总而言之，SpannableString、SpannableStringBuilder与String一样， 首先也是传字符串，但SpannableString、SpannableStringBuilder可以对这些字符串添加额外的样式信息，但String则不行。注意：如果这些额外信息能被所用的方式支持，比如将SpannableString传给TextView；也有对这些额外信息不支持的，比如前一章讲到的Canvas绘制文字，对于不支持的情况，SpannableString和SpannableStringBuilder就是退化为String类型，直接显示原来的String字符串，而不会再显示这些附加的额外信息。 SpannableString与SpannableStringBuilder区别它们的区别在于 SpannableString像一个String一样，构造对象的时候传入一个String，之后再无法更改String的内容，也无法拼接多个 SpannableString；而SpannableStringBuilder则更像是StringBuilder，它可以通过其append()方法来拼接多个String： 12345678//使用SpannableString，必须一次传入，构造完成 SpannableString word = new SpannableString("欢迎光临Harvic的博客"); //使用SpannableStringBuilder,可以使用append()再添加 SpannableStringBuilder multiWord = new SpannableStringBuilder(); multiWord.append("欢迎光临"); multiWord.append("Harvic的"); multiWord.append("博客"); 因为Spannable等最终都实现了CharSequence接口，所以可以直接把SpannableString和SpannableStringBuilder通过TextView.setText()设置给TextView。 SetSpan（）void setSpan (Object what, int start, int end, int flags) 函数意义：给SpannableString或SpannableStringBuilder特定范围的字符串设定Span样式，可以设置多个（比如同时加上下划线和删除线等），Falg参数标识了当在所标记范围前和标记范围后紧贴着插入新字符时的动作，即是否对新插入的字符应用同样的样式。（这个后面会具体举例说明） 参数说明： object what ：对应的各种Span，后面会提到； int start：开始应用指定Span的位置，索引从0开始 int end：结束应用指定Span的位置，特效并不包括这个位置。比如如果这里数为3（即第4个字符），第4个字符不会有任何特效。从下面的例子也可以看出来。 int flags：取值有如下四个 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE：前后都不包括，即在指定范围的前面和后面插入新字符都不会应用新样式 Spannable.SPAN_EXCLUSIVE_INCLUSIVE ：前面不包括，后面包括。即仅在范围字符的后面插入新字符时会应用新样式 Spannable.SPAN_INCLUSIVE_EXCLUSIVE ：前面包括，后面不包括。 Spannable.SPAN_INCLUSIVE_INCLUSIVE ：前后都包括。 举个例子来说明这个前后包括的问题：由于Flag的作用是用来指定范围前后输入新的字符时，会不会应用效果的，所以我们利用EditText来显示SpannableString (1)、布局XML中加入一个EditText控件： 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.try_spannable_blog.MainActivity" &gt; &lt;EditText android:id="@+id/edit" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/RelativeLayout&gt; （2）、这里用一个改变字体颜色的Span来做下演示 123456789101112131415161718192021public class MainActivity extends Activity &#123; private EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText = (EditText)findViewById(R.id.edit); //改变字体颜色 //先构造SpannableString SpannableString spanString = new SpannableString("欢迎光临Harvic的博客"); //再构造一个改变字体颜色的Span ForegroundColorSpan span = new ForegroundColorSpan(Color.BLUE); //将这个Span应用于指定范围的字体 spanString.setSpan(span, 1, 3, Spannable.SPAN_EXCLUSIVE_INCLUSIVE); //设置给EditText显示出来 editText.setText(spanString); &#125; &#125; 初始化效果是这样的： 分别在设置Span的前面和后面加入新文字，结果是这样的 在前面和后面都加入虾米两个字，可见，前面的虾米没有任何效果，后面的则不同，添加上相同的Span特效，这是由于我们设置了Spannable.SPAN_EXCLUSIVE_INCLUSIVE的原因，即（前面不应用特效，后面应用特效），其它几个Flags参数的含义想必大家也都清楚了。在此就不再赘述。 各种Span设置在前面的一个小示例，大家应该也可以看出，要应用一个Span总共分三步： 构造String 构造Span 利用SetSpan（）对指定范围的String应用这个Span 字体颜色设置（ForegroundColorSpan）1234567SpannableString spanString = new SpannableString("欢迎光临Harvic的博客"); //再构造一个改变字体颜色的Span ForegroundColorSpan span = new ForegroundColorSpan(Color.BLUE); //将这个Span应用于指定范围的字体 spanString.setSpan(span, 1, 5, Spannable.SPAN_EXCLUSIVE_INCLUSIVE); //设置给EditText显示出来 editText.setText(spanString); 效果： 字体背景颜色（BackgroundColorSpan）1234SpannableString spanString = new SpannableString("欢迎光临Harvic的博客"); BackgroundColorSpan span = new BackgroundColorSpan(Color.YELLOW); spanString.setSpan(span, 0, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); 字体大小（AbsoluteSizeSpan）1234SpannableString spanString = new SpannableString("欢迎光临Harvic的博客"); AbsoluteSizeSpan span = new AbsoluteSizeSpan(16); spanString.setSpan(span, 2, 5, Spannable.SPAN_INCLUSIVE_INCLUSIVE); editText.setText(spanString); 粗体、斜体（StyleSpan）1234SpannableString spanString = new SpannableString("欢迎光临Harvic的博客"); StyleSpan span = new StyleSpan(Typeface.BOLD_ITALIC); spanString.setSpan(span, 1, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); 删除线（StrikethroughSpan）1234SpannableString spanString = new SpannableString("欢迎光临Harvic的博客"); StrikethroughSpan span = new StrikethroughSpan(); spanString.setSpan(span, 2, 5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); 下划线（UnderlineSpan）1234SpannableString spanString = new SpannableString("欢迎光临Harvic的博客"); UnderlineSpan span = new UnderlineSpan(); spanString.setSpan(span, 1, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); 图片置换（ImageSpan）ImagSpan有很多构造函数，一般是通过传入Drawableg来构造，详细的构造说明看这里：http://developer.android.com/reference/android/text/style/ImageSpan.html 123456SpannableString spanString = new SpannableString("欢迎光临Harvic的博客"); Drawable d = getResources().getDrawable(R.drawable.ic_launcher); d.setBounds(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight()); ImageSpan span = new ImageSpan(d, ImageSpan.ALIGN_BASELINE); spanString.setSpan(span, 2, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); 这个函数的不同之处在于，前几都是在原来文字的基础上加上特效，而这里却是利用图片将文字替换。如果遇到不支持显示图片的函数，比如前一篇中的canvas绘图。就会退化成String，即以原来的String字符串来显示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 基于开源项目搭建属于自己的技术堆栈]]></title>
      <url>%2F2017%2F10%2F07%2Fandroid-technology-stack%2F</url>
      <content type="text"><![CDATA[这篇博文主要就是针对平常使用到的框架做一个整理和分析其优劣。 为了从整体上进行把握，先来看看一个完整的APP整体架构 APP的整体架构从较高的层次将，一个APP的整体架构可以分为两层，即应用层和基础框架层。 应用层专注于行业领域的实现，例如金融、支付、地图导航、社交等，它直接面向用户，是用户对产品的第一层感知。 基础框架层专注于技术领域的实现，提供APP公有的特性，避免重复制造轮子，它是用户对产品的第二层感知，例如性能、稳定性等。 一个理想的APP架构，应该拥有如下特点 支持跨平台开发 具有清晰的层次划分，同一层模块间充分解耦，模块内部符合面向对象设计六大原则 在功能、性能、稳定性等方面达到综合最优 基于以上设计原则，我们可以看出APP架构图，最上层是应用层，应用层以下都属于基础框架层，基础框架层包括：组件层、基础层和跨平台层。 我们要讨论的重点是基础层，下面开始一步一步地阐述如何基于开源函数库搭建属于自己的一个基础技术堆栈。 技术选型的考量点首先要明确的是，我们选择开源函数库或者第三方SDK、一般需要综合考虑一下几个方面 特性：提供的特性是否满足项目的需求 可用性，是否提供了简洁便利的API，方便开发者集成使用。 性能：性能不能太差，否则项目后面性能优化会过不去，可能回出现需要替换函数库的情况。 文档：文档应该比较齐全，且可读性高。 技术支持：遇到问题或者发现BUG，是否能够及时得到官方的技术支持是很重要的 大小：引入函数库会增加APK的大小，需要慎重抉择 方法数：如果函数库方法数太多，积累起来会导致你的APP遇到64K问题，应该尽量避免 日志记录能力日志记录无论在服务端开发还是移动端开发，都是一个基础且重要的能力，开发人员在代码调试以及错误定位过程中，大多说都要依赖日志信息，一个简洁灵活的日志记录模块是相当重要的。Logger 是基于系统Log类基础上进行的封装，但新增了如下超赞的特性。 在Logcat中完美的格式化输出，再也不用担心和手机其他APP或者系统的日志信息相混淆了 包含线程、类、方法信息，可以清楚地看到日志记录的调用堆栈 支持跳转到源码处 支持格式化输出JSON、XML格式信息 Logcat截图 当然Logger也不是完备的，它虽然支持格式化输出JSON、XML，但并不支持诸如List、Set、Map和数组等常见Java集合类的格式化输出。如何解决呢？可以看下LogUtils 这个开源库，它实现了Logger缺失的上述特性。 再者，Logger只支持输出日志到Logcat，但项目开发中往往还存在将日志保存到磁盘上的需求，如何将两者结合起来呢？这是就遇到了timber 。 timber是JakeWharton开源的一个日志记录库，它的特点是可扩展的框架，开发者可以方便快捷的集成不同类型的日志记录方式，例如，打印日志到Logcat、打印日志到文件、打印日志到网络等，timber通过一行代码就可以同时调用多种方式。 timber的思想很简单，就是维护一个森林对象，它由不同类型的日志树组合而成，例如，Logcat记录树、文件记录树、网络记录树等，森林对象提供对外的接口进行日志打印。每种类型的树都可以通过种植操作把自己添加到森林对象中，或者通过移除操作从森林对象中删除，从而实现该类型日志记录的开启和关闭。 最终我们的日志记录模块将由timber+Logger+LogUtils组成，当然轮子找到了，轮子的兼容合并就得靠我们自己实现了，同时我们还得增加打印到文件的日志树和打印到网络的日志树实现。 JSON解析能力移动互联网产品与服务器端通信的数据格式，如果没有特殊需求的话，一般都使用JSON格式。Android系统也原生的提供了JSON解析的API，但是它的速度非常慢，而且没有提供简洁方便的接口来提高开发者的效率和降低出错的可能。所以我们就开始找第三方开源库来实现JSON解析，比较优秀的包括如下几种。 gsongosn是Google出品的JSON解析函数库，可以将JSON字符串反序列化对应的Java对象，或者反过来将Java对象序列化为对应的JSON字符串，免去了开发者手动通过JSONObject和JSONArray将JSON字段逐个进行解析的烦恼，也减少了出错的可能性，增强了代码的质量。使用gson解析时，对应的Java实体类无需使用注解进行标记，支持任意复杂Java对象包括没有源代码的对象。 jacksonjcakson是Java语言的一个流行的JSON函数库，在Android开发中使用时，主要包含三部分。 jackson-core：JSON流处理核心库 jackson-databind：数据绑定函数库，实现Java对象和JSON字符串流的相互转换。 jackson-annotations：databind使用的注解函数库 由于jackson是针对Java语言通用的JSON函数库，并没有为Android优化定制过，因此函数保重包含很多非必要的API，相比其他的JSON函数库，用于Android平台会更显著的增大最终生成的APK的体积。 FastjsonFastjson是阿里巴巴出品的一个Java语言编写的高性能且功能完善的JSON函数库。它采用一种“假定有序快速匹配”的算法，把JSON Parse的性能提升到极致，号称是目前Java语言中最快的JSON库。Fastjson接口简单易用，已经被广泛使用在缓存序列化、协议交互、Web输出、Android客户端等多种应用场景。 由于是Java语言通用的，因此，以前在Android上使用时，Fastjson不可避免的引入了很多对于Android而言冗余的功能，从而增加了包大小，很多人使用的就是标准版的fastjson，但事实上，fastjson还存在一个专门为Android定制的版本—fastjson.android 。和标准版本相比，Android版本去掉了一些Android虚拟机dalvik不支持的功能，使得jar更小。 LoganSquareLoganSquare是近两年崛起的快速解析和序列化JSON的Android函数库，其底层基于jackson的streaming API，使用APT(Android Annotation Tool)实现编译时注解，从而提高JSON解析和序列化的性能。官网上可以看到LoganSquare和gson、jackson databind的性能对比。 从性能方面看，LoganSquare是完胜gson和jackson的。如果和fastjson相比较，两者应该是不相上下的。 再来看下jar包的大小 gson：232KB jackson：259+47+1229 = 1.5M Fastjson：417KB Fastjson.android：256KB LoganSquare：48+259 = 307KB 从性能和包大小综合考虑，最终我们会选择Fastjson.android作为基础技术堆栈中的JSON解析和序列化库。 数据库操作能力无论是iOS还是Android，底层数据库都是基于开源的SQLite实现，然后在系统层封装成用于应用层的API。虽然直接使用系统的数据库API性能很高，但是这些API接口并不是很方便开发者使用，一不小心就会引入Bug，而且代码的视觉效果也不佳。为了解决这个问题，对象关系映射（ORM）框架出现了，比较好的有ActiveAndroid，ormlite和greenDAO。 ActiveAndroidActiveAndroid是一种Active Record风格的ORM框架，Active Record（活动目录）是Yii,Rails等框架中对ORM实现的典型命名方式。它极大的简化数据库的使用，使用面向对象的方式管理数据库，告别手写SQL的历史。每一个数据库表都可以被映射为一个类，开发者只需使用类似save()或者delete()这样的函数即可。 不过ActiveAndroid已经基本上处于维护阶段了，最新的一个Release版本是在2012年发布的。 ormliteormlite是Java平台的一个ORM框架，支持JDBC连接、Spring和Android平台。在Android中使用时，它包含两部分。 ormlite-core：核心模块，无论在哪个平台使用，都必须基于这个核心库，是实现ORM映射的关键模块。 ormlite-android：基于ormlite-core封装的针对Android平台的适配器模块，Android开发中主要跟这个模块打交道。与ActiveAndroid类似，ormlite也已经不是一个活跃的开源库，最近一次Release版本是在2013年发布的。 greenDAOgreenDAO是一个轻量级且快速的ORM框架，专门为Android高度优化和定制，它能够支持每秒数千条记录的CRUD操作。官网上给出一张性能对比图 纵轴表示每秒执行的操作数。而且greenDAO处在高度活跃中，最新Release版本是在2017年3月份发布的 RealmRealm是一个全新的移动数据库引擎，它既不是基于iOS平台的Core Data，也不是基于SQLite，它拥有自己的数据库存储引擎，并实现了高效快速的数据库构建操作，相比Core Data和SQLite，Realm操作要快很多，跟ORM框架相比就更不用说了。 Realm的好处如下： 跨平台：Android和iOS已经是事实上的两大移动互联网操作系统，绝大多数应用都会支持这两个平台。使用Realm，Android和iOS开发者无需考虑内部数据的架构，调用Realm提供的API即可轻松完成数据的交换。 用法简单：相比Core Data和SQLite所需的入门知识，Realm可以极大降低开发者的学习成本，快速实现数据库存储功能。 可视化操作：Realm为开发者提供了一个轻量级的数据库可视化操作工具，开发者可以轻松查看数据库中的内容，并实现简单地插入和删除等操作。 我们看下上述四种数据库包大小。 activeandroid：40KB greendao：100KB ormlite-android：57KB realm-android：4.2M 可以看出，前三个还是正常范围，但Realm的大小一般项目可能无法接受。这是因为不同CPU架构平台的 .so 文件增加了整个包的大小，由于arm平台的so在其他平台上面能够以兼容模式运行的，虽然会损失性能，但是可以极大地减少函数库占用的空间。因此，可以选择只保留armeabi-v7a和x86两个平台的 .so 文件，直接删除无用的 .so 文件，或者通过工程的build.gradle文件中增加 ndk abi 过滤，语句如下： 123456789android &#123; ... defaultConfig &#123; ... ndk &#123; abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot; &#125; &#125;&#125; 因此，综合性能考虑，包大小以及开源库的可持续发展等因素，我们最终选择greenDAO。 网络通信能力现在的APP几乎都需要从服务器获取数据，不可避免的需要具备网络通信的能力，否则就是一个死界面。 android-async-httpAndroid最经典的网络异步通信函数库，它对Apache的HttpClient API的封装使得开发者可以简洁优雅地实现网络请求和响应，并且同时支持同步和异步请求。主要特性如下： 支持异步HTTP请求，并在匿名回调函数中处理响应 在子线程中发起HTTP请求 内部采用线程池来处理并发请求 通过RequestParams类实现GET/POST参数构造 无需第三方库支持即可实现Multipart文件上传 库的大小只有60KB 支持多种移动网络环境下自动智能的请求重试机制 HTTP响应中实现自动的gzip解码，实现快速请求响应 内置多种形式的响应解析，有原生的字节流、String、JSON对象，甚至可以将response写入到文件中。 可选的永久cookie保存，内部实现使用的是Android的SharedPreferences。 但是在6.0之后，系统对开发者隐藏了HttpClient函数库，这显著增大了使用android-async-http的代价。 如果铁了心想继续使用HttpClient，官方推荐的做法是在编译期引入org.apache.http.legacy 这个库，库目录在Android SDK目录下的platforms\android-23\optional中找到，它的作用是确保在编译时不会出现找不到HttpClient相关API的错误，在应用运行时可以不依赖这个库，因为6.0以上的Android系统还没有真正移除HttpClient的代码，只不过API设置为对开发者不可见。我们查看android-async-http源码发现，需要使用下面这个函数库来替换之前的Apache的HttpClient。 123dependencies &#123; compile &apos;cz.msebera.android:httpclient:4.3.6&apos;&#125; 这样显著的增加了APP的包的大小，如果想继续使用android-async-http，那么你的APP需要额外增加1.1MB左右的大小。 OkHttpOkHttp是一个高效的HTTP客户端，具有如下特性。 支持HTTP/2和SPDY，对同一台主机的所有请求共享同一个socket。 当SPDY不可用时，使用连接池减少请求的延迟。 透明的GZIP压缩减少下载数据大小 缓存响应避免重复的网络请求 OkHttp在网络性能很差的情况下能够很好地工作，它能够避免常见的网络连接问题。如果你的HTTP服务有多个IP地址，OkHttp在第一次连接失败是，会尝试其他可选的地址。这对于IPv4+IPv6以及托管在冗余数据中心的服务来说是必要的。OkHttp使用现代的TLS特性（SNI,ALPN）初始化HTTP连接，当握手失败时，会降低使用TSL1.0初始化连接。 OkHttp依赖于okio，okio作为java.io和java.nio的补充，是square公司开发的一个函数库。okio使得开发者可以更好地访问、存储和处理数据。一开始是作为OkHttp的一个组件存在的，当然我们也可以单独使用它。 使用Okhttp需要引入Jar包，包的大小为：326+66 = 392KB VolleyVolley是Google在2013年发布的用于Android平台的网络通信库，能使网络通信更快、更简单、更健壮。官网配出一张弓箭发射图来说明Volley特别使用于数据量小等通信频繁的场景。 具体的将，Volley是为了简化网络任务而设计的，用于帮助开发者处理请求、加载、缓存、多线程、同步等任务。Volley设计了一个灵活的网络栈适配器，在Android2.2及之前的版本中，Volley底层使用Apache HttpClient，在Android2.3及以上版本中，它使用HttpURLConnection来发起网络请求，而且开发者也很容易将网络栈切换成使用OkHttp。Volley 官方源码托管在Google Source上面，使用时只能直接以Jar包形式引入，如果想在Gradle中使用compile在线引入，可以考虑使用mcxiaoke在Github上面的Volley Mirror，然后再build.gradle中使用如下语句即可。 compile &#39;com.mcxiaoke.volley:library:1.0.19&#39; Retrofit确切的说，Retrofit并不是一个完整的网络请求函数库，而是将REST API转换成Java接口的一个开源函数库，它要求服务器API接口遵循REST规范。基于注解使得代码变得很简洁，Retrofit默认情况下使用GSON作为JSON解析器，使用OkHttp实现网络请求，三者通常配合使用，当然我们也可以将这两者换成其他的函数库。 通过以上分析，HttpURLConnection、Apache HttpClient 和OkHttp封装了底层的网络请求，而android-async-http，Volley和Retrofit是基于前面三者的基础上二次开发而成。 最后看下函数库的大小 android-async-http：106KB+1.1MB = 1.2MB OkHttp：326KB+66KB = 392KB Volley：94KB Retrofit：122KB+211KB = 333KB 图片缓存和显示能力图片缓存函数库有很多非常优秀的，开发人员可以根据需求进行选择。传统的图片缓存方案中设置有两级缓存，分别是内存缓存和磁盘缓存。在Facebook推出的Fresco中，它增加了一级缓存，也就是Native缓存，这极大地降低了使用Fresco的APP出现OOM的概率。 BitmapFunBitmapFun函数库是Android官方教程中的一个图片加载和缓存实例，对于简单的图片加载需求来说，使用BitmapFun就够了，在早期用的多，现在渐渐退出了实际项目开发的舞台。 PicassoPicasso是著名的square公司众多开源项目中的一个，它除了实现图片的下载和二级缓存功能，还解决了常见的一些问题。 在adapter中正常的处理ImageView回收和下载的取消 使用尽量小的内存实现复杂的图像变换 在Picasso中，我们使用一行代码即可实现图片下载并渲染到ImageView中。 Picasso.with(context).load(url).into(imageView); GlideGlide是Google推荐的用于Android平台上的图片加载和缓存函数库。这个库被广泛应用在Google的开源项目中，Glide和Picasso有90%的相似度，只是在细节上还是存在不少区别。Glide为包含图片的滚动列表做了尽可能流畅的优化。除了静态图片，Glide也支持GIF格式图片的显示。Glide提供了灵活的API可以让开发者方便地替换下载图片所用的网络函数库，默认情况下，它使用HttpUrlConnection作为网络请求模块，开发者也可以根据自己项目的实际需求灵活使用Google的Volley或者Square的OkHttp等函数库进行替换。 Glide的使用也可以使用一行代码来完成，语句如下 Glide.with(context).load(url).into(imageView); FrescoFresco是Facebook开源的功能强大的图片加载和缓存函数库，相比其他图片缓存库，Fresco最显著的特点是具有三级缓存：两级内存缓存和一级磁盘缓存。主要特性如下： 渐进式地加载JPEG图片 显示GIF和WebP动画 可扩展，可自定义图片加载和显示 在Android 4.X和一下的系统上，将图片放在Android内存一个特殊的区域，从而使得应用运行更流畅，同时极大减低出现OutOfMemoryError的错误。 Android-Universal-Image-LoaderAndroid-Universal-Image-Loader简称UIL，是Android平台老牌的图片下载和缓存函数库，功能强大灵活且高度可自定义，它提供一系列配置选项，并能很好地控制图片加载和缓存的过程。使用者甚多，现在项目仍在使用。UIL也支持二级缓存，特性如下： 同步或异步的多线程图片加载 高度可自定义：线程池、下载器、解码器、内存和磁盘缓存、图片显示选项等。 每张图片的显示支持多种自定义选项：默认存根图片、解码选项、Bitmap处理和显示等。 图片可缓存在内存或者磁盘（设备的文件系统或者SD卡）上。 可实时监听图片加载流程，包括下载进度。 最后看下几个库的包大小 BitmapFun：71KB Picasso：120KB Glide：475KB Fresco：47KB+93KB+93KB+10KB+3MB+62KB+8KB+111KB = 3.4MB Android-Universal-Image-Loader：162KB 图片函数库的选择需要根据APP的具体情况而定，对于严重依赖图片缓存的APP,例如壁纸类，图片社交类APP来说，可以选择最专业的Fresco。对于一般的APP，选择Fresco会显得比较重，毕竟Fresco 3.4MB的体量摆在这。 根据APP对图片显示和缓存的需求从低到高我们可以对以上函数库做一个排序 BitmapFun &lt; Picasso &lt; Android-Universal-Image-Loader &lt; Glide &lt; Fresco 值得一提的是，如果你的APP计划使用React Native进行部分模块功能的开发的话，那么在基础函数库选择方面需要考虑和React Native的依赖库的复用，这样可以减少引入React Native 所增加的APP的大小，可以复用的函数库有：OkHttp，Fresco,jackson-core.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 使用 Palette 让你的 UI 色彩与内容更贴合]]></title>
      <url>%2F2017%2F10%2F06%2Fandroid-Palette%2F</url>
      <content type="text"><![CDATA[前言今天介绍一个 Android 下比较有意思的 Support v7 库，Palette，它翻译过来就是调色板。 Palette 可以从一张 Bitmap 中提取出它突出的颜色，这样我们就可以将提取出来的颜色设置在 App 的固定 UI 中（例如：ToolBar 的背景），使得 UI 页面的整体风格更加的美观和融洽。 比如，对于一些影视类的 App，视频详情页的主题都是视频的海报，那么对于页面背景，我们可以提取视频海报的颜色，设置在背景上，使得效果更佳柔和美观。 Palette 是一个 Support v7 的包，如果使用 Gradle 引入依赖，这里使用最新的 26.+。 compile &quot;com.android.support:palette-v7:26.+&quot; Palette 的使用Palette 使用起来非常的简单，既然目的是从一个图片中提取颜色，它的步骤就有： 传递一个 Bitmap，得到一个 Palette。 通过 Palette 提取需要的颜色。 就是这么简单，如同要将大象放冰箱，需要几步一样清晰。 那么接下来我们先来了解它使用的细节。 传递 Bitmap 得到一个 PalettePalette 在旧版本上有一些 generate() 的方法，用于生成一个 Palette 对象，但是在新版本上已经被标记为 @Depercated 了，所以这里不推荐使用。 而在新版上，推荐使用 Palette.Builder 来创建我们的 Palette 对象，我们可以通过 from() 方法使用它。 一般我们使用第一个方法即可，直接传递进去一个 Bitmap 对象。得到 Builder 之后，我们还可以配置一些规则，但是一般我们不需要进行额外的（后面会讲到）。再通过 Builder.generate() 即可得到我们需要的 Palette 对象了。 通过 Palette 提取颜色Palette 从图片中提取的颜色，有很多选择。这里又涉及到另外一个类，Swatch 。 Palette 可被提取的每个颜色，都被封装成一个 Swatch 对象，用来管理多种颜色。 这些 Swatch 有： DominantSwatch VibrantSwatch DarkVibrantSwatch LightVibrantSwatch MutedSwatch DarkMutedSwatch LightMutedSwatch 其实这些 Swatch，真的不太好解释其意义，唯一特别一点的就是 DominantSwatch ，它是从图片中提取的最突出的颜色。 这些 Swatch 在 Palette 都提供了对应的 getXxx() 方法获得。不过需要注意的是，这些 getXxx() 方法可能会得到一个 null ，因为有些颜色是没有的。 如果只是需要得到一个颜色值，Palette 同时也提供了对应的 getXxxColor() 方法，方便我们使用。 得到 Swatch 对象之后，就可以通过对应的 Swatch 中对应的 Api 获取我们需要的颜色值。 getPopulation() ：Swatch 中的像素个数。 getRgb()：颜色的 RGB 值。 getHsl()：颜色的 HSL 值。 getBodyTextColor()：对应的文字颜色值。 getTitleTextColor()：对应的标题文字颜色值。 通常来说，我们只需要通过 getRgb() 获取到对应的颜色设置在背景上，如果背景之上还有文字内容，可以通过 getBodyTextColor() 提取出与背景匹配的文字颜色值，这样可以显得更加的柔和，让文字看起来更清晰和舒服。比如，如果一个深色的背景，为它设置一个默认的深色文字，基本上就看不见了，因为对比对太弱。 举个例子到这里，基本上 Palette 的基本 Api 就讲解清楚了，下面举个实际的例子来看看。 这里找了三张 Eason 的海报，用于做 Palette 的 Demo 资源，间隔去替换图片，然后分别提取出对应的颜色和字体颜色，设置在下面按钮的背景上，然后每 3s 切换一张图片。 因为有一些图片，获取的 Swatch 可能会返回 null ，所以这里用了一个比价扎眼的红色，作为错误色。 以下是获取 Swatch 的代码。 接下来通过 Swatch 提取我们需要的颜色。 这里分别获取了需要的颜色以及字体颜色，下面看看运行的效果： 可以看到，确实有一些颜色，被标记成了红色，说明当前图片有获取不到的对应颜色。 分析 Palette 的实现Palette 的主线逻辑继续深入看看 Palette 的实现原理，先从主线开始看。 从 Builder.generate() 开始。 从代码中可以看到，在 generate() 中，主线逻辑： 首先会通过 scaleBitmapDown() 方法，将图片压缩成一个小像素的，等于生成了一个新的 Bitmap 对象，这样有利于内存的管理，并且也减少了计算量。 然后再通过 mRegion 判断是否只是提取图片的某个区域，默认是完整的图片全部提取，当然也可以对 mRegion 进行配置。之后再构造一个 ColorCutQuantizer 对象，使用它的 getQuantizedColors() 方法得到 Swatch。 使用完前面压缩的 Bitmap 对象之后，再使用 recycle() 将其回收掉。 最后，通过 Palette 本身的构造函数，去生成一个 Palette 对象，返回出去。 接下来看看比较关键的 ColorCutQuantizer 中的实现逻辑。 从代码中可以看到，其中的逻辑还是很清晰的。 首先通过 quantizeFromRgb888() 方法，将每个像素的颜色进行量化，类似于将每个颜色取一个靠近的设置。举个不恰当的例子，将不同深度的红，都标记成红色。 再通过 shouldIgnoreColor() 过滤掉不需要的颜色。 最终获取到的颜色，如果小于等于我们设置的 maxColors，就可以通过 approximateToRgb888() 生成一批 Swatch。 如果大于 maxColors，就再通过 quantizePixels() 去掉一些杂色。 无论如何，最终操作的就是这里得到的 mQuantizedColors 对象。 Swatch 的 Target所有需要的 Swatch ，都是被 Target 对象所标记。不同的 Swatch 都是通过 Target 中标记的常量值，进行运算，得到行的颜色。 过滤掉不需要的颜色Palette 可以设置一些我们不需要的颜色，让它们不参与运算。这里的过滤条件，通过 Filter 来设定，并且 Palette 也提供给了一个 DEFAULT_FALTER 来标记默认的过滤颜色。 可以看到，默认的 Filter 会过滤掉一些靠近黑和白的颜色。 当然，我们也可以自己定义 Filter ，并通过 Palette 中的 addFilter()、clearFilters() 来管理它。 这里存储 Filter 的是一个 ArrayList ，所以我们是可以定义很多个 Filter 加入进去的，它们都会生效。 设置 MaxColor在 ColorCutQuantizer 中，被使用的 maxColor ，主要用于标记需要使用的颜色个数。它是可以通过 maximumColorCount() 方法，进行设置的，如果不对其进行设定，默认值为 16。 理论上来说，这里设置的maxColor 的值越大，运算花费的时间就越长。而越小，可以被选择的色值也就越少。 所以最佳的做法是根据当前 Bitmap 的用途来决定，色彩越丰富的图，设置的 maxColor 越大，即可。不过正常来说也不需要额外的设定，默认的配置就挺好用了。 小结到这里就分析完 Palette 的所有相关的内容，不要仅仅满足使用。实际上看了 Palette 的源码，对色彩的运算，也有了更加深入的了解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 自定义 LayoutInflate 实现酷炫引导页]]></title>
      <url>%2F2017%2F10%2F04%2Fandroid-LayoutInflate%2F</url>
      <content type="text"><![CDATA[今天，我们来搞点事情，自定义一个 LayoutInflate，搞点有意思的东西，实现一个酷炫的动画。首先，在自定义 LayoutInflate 之前，我们要先分析一下 LayoutInflate 的源码，了解了源码的实现方式，才能定制嘛~~~~好了，怕你们无聊跑了，先放效果图出来镇贴 好了，效果看完了， 那就先从LayoutInflate的源码开始吧。 LayoutInflate 还是提取一下关键信息吧。 LayoutInflate 可以将 xml 文件解析成 View 对象。获取方式有两种getLayoutInflater()和getSystemService(Class)。 如果要创建一个新的 LayoutInflate去解析你自己的 xml，可以使用 cloneInContext，然后调用 setFactor()。 好了，我们先来回顾一下平时我们是怎么把 xml 转换成 View 的吧。 setContentView（） 我们给 Activity 设置 布局 xml 都是调用这个方法，现在我们就来看看这个方法到底干了什么事。 1234567891011121314151617181920212223242526272829303132333435public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125;-----以上是 Activity 的方法，调用了 Window 的 steContentView----手机上的 window 都是 PhoneWindow,就不饶弯了，直接看 PhoneWindow----的setContentView方法。public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125;----在构造方法里面找到了mLayoutInflater 的赋值public PhoneWindow(Context context) &#123; super(context); mLayoutInflater = LayoutInflater.from(context);&#125; View.inflate() 同样是调用了LayoutInflate.inflate()方法 1234public static View inflate(Context context, @LayoutRes int resource, ViewGroup root) &#123; LayoutInflater factory = LayoutInflater.from(context); return factory.inflate(resource, root);&#125; LayoutInflate.from(context).inflate() 同上 我们项目中所有的 Xml 转 View 都离不开这三个方法吧，这三个方法最终调用的都还是 LayoutInflate 的 inflate 方法。 我们再来看看怎么获取到 LayoutInflate 的实例。上面三个xml 解析成 view 的方法都是用LayoutInflate.from(context)来获取 LayoutInflate 实例的。 1234567public static LayoutInflater from(Context context) &#123; LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) &#123; throw new AssertionError("LayoutInflater not found."); &#125; return LayoutInflater;&#125; 看到这个代码有木有觉得很眼熟啊，我们的 ActivityService、WindowService、NotificationService等等各种 Service 是不是都这样获取的。而我们都知道这些系统服务都是单例的，并且在应用启动的时候系统为其初始化的。好了，撤远了~~ 回过头来，我们继续看 LayoutInflate 源码。 inflate(@LayoutRes int resource, @Nullable ViewGroup root)这个方法就是将xml 文件转换成 View 的方法，我们项目中所有的 xml 解析调用的都是这个方法。第一个参数是 xml 资源 id，第二个方法是解析后的 View 是否要添加到 root view里面去。 通过 Resources 获取 xml 解析器XmlResourceParser。 1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123; final Resources res = getContext().getResources(); if (DEBUG) &#123; Log.d(TAG, "INFLATING from resource: \"" + res.getResourceName(resource) + "\" (" + Integer.toHexString(resource) + ")"); &#125; final XmlResourceParser parser = res.getLayout(resource); try &#123; return inflate(parser, root, attachToRoot); &#125; finally &#123; parser.close(); &#125;&#125; XmlResourceParser解析 xml，并且返回 view 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; //写入跟踪信息，用于 Debug 相关，先不关心这个 Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate"); final Context inflaterContext = mContext; //用于读取 xml 节点 final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. int type; //空信息直接跳过 while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; //防错判断 if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + ": No start tag found!"); &#125; //获取类名，比如说 TextView final String name = parser.getName(); if (DEBUG) &#123; System.out.println("**************************"); System.out.println("Creating root view: " + name); System.out.println("**************************"); &#125; //如果标签是merge if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; //merge作为顶级节点的时候必须添加的 rootview throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; //递归方法去掉不必要的节点，为什么 merge 可以优化布局 rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp 是根节点 final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; //如果不添加到 rootView 切 rootView 不等于空，则生成 LayoutParams if (root != null) &#123; if (DEBUG) &#123; System.out.println("Creating params from root: " + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println("-----&gt; start inflating children"); &#125; // 解析子节点 rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println("-----&gt; done inflating children"); &#125; // 如果要添加到 rootview。。 // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; &#125; catch (Exception e) &#123; InflateException ex = new InflateException(parser.getPositionDescription() + ": " + e.getMessage()); ex.initCause(e); throw ex; &#125; finally &#123; // Don't retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); //返回解析结果 return result; &#125;&#125; 在这个方法中，判断了是否使用 merge 优化布局，然后通过createViewFromTag解析的顶级 xml 节点的 view，并且处理了是否添加解析的布局到 rootView。调用rInflateChildren方法去解析子 View 并且添加到顶级节点 temp 里面。最后返回解析结果。 我们先来看看 createViewFromTag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,boolean ignoreThemeAttr) &#123; //获取命名空间 if (name.equals("view")) &#123; name = attrs.getAttributeValue(null, "class"); &#125; // 给 view 设置主题。现在知道为什么colorPrimary等 theme 属性会影响控件颜色了吧 if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; //让 view 闪烁，可以参考http://blog.csdn.net/qq_22644219/article/details/69367150 if (name.equals(TAG_1995)) &#123; // Let's party like it's 1995! return new BlinkLayout(context, attrs); &#125; try &#123; View view; //优先调用了mFactory2的 oncreateView 方法，创建了 temp View if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf('.')) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; catch (InflateException e) &#123; throw e; &#125; catch (ClassNotFoundException e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + name); ie.initCause(e); throw ie; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + name); ie.initCause(e); throw ie; &#125;&#125; 这里我们可以知道，mFactor或者 mFactor 不为 null，则调用mFactor来创建 View，如果mFactor为 null 或者mFactor创建是失败，则最终调用LayoutInflate 的createView方法 来创建 View 的，它传入了 view 的 parent、name、context、 attrs。 接下来继续去看子 View 的解析rInflateChildren 1234567891011121314151617181920212223242526272829303132333435363738394041void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;//获取布局层级 final int depth = parser.getDepth(); int type; //没看懂没事，我们不是来纠结 xml 解析的 while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); //requestFocus标签，http://blog.csdn.net/ouyang_peng/article/details/46957281 if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_TAG.equals(name)) &#123; //tag标签，只能用于 api21以上，给父view 设置一个 tag parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; //include 节点 if (parser.getDepth() == 0) &#123; throw new InflateException("&lt;include /&gt; cannot be the root element"); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; //merge 节点 throw new InflateException("&lt;merge /&gt; must be the root element"); &#125; else &#123; //走了刚刚的那个方法，创建 view 设置 LayoutParams final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); //添加到付 view viewGroup.addView(view, params); &#125; &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125;&#125; 我们来整理一下思路吧，调用步骤 LayoutInflater 的静态方法 form 获取LayoutInflater实力 inflate解析 xml 资源 inflate 调用createViewFromTag创建了顶级view inflate 调用rInflateChildren 创建所有子 view rInflateChildren递归调用rInflate创建所有子 view。 rInflate通过调用createViewFromTag真正创建一个 view。 createViewFromTag优先使用 mFactory2、mFactory、mPrivateFactory来创建 View，如果创建失败，则最终调用createView方法来创建。创建的过程中用了parent,name,context,attrs等参数，然后运用反射的方法，创建出 View， 因此，我们所有的 View 的构造方法都是被 LayoutInflate 的Factory调用创建出来的。如果要自定义 LayoutInflate 解析，只需要给调用LayoutInflate的 setFactory设置我们自定义的 Factory 即可。但是问题来了，LayoutInflate是系统服务，而且是单例，我们直接调用LayoutInflate的 setFactory 方法，会影响后期所有 view 的创建。 所以我们需要用到LayoutInflate的cloneInContext方法clone一个新的 LayoutInflate，然后再设置自己的 Factory。至于LayoutInflate是一个抽象类，cloneInContext是一个抽象方法，我们根本不用关心，因为我们直接用系统创建好的LayoutInflate即可。 好了，LayoutInflate的源码分析完了，接下来我们来分析动画了。 动画分析源码看了很久，我们再来重新看一遍动画吧 翻页 翻页的时候天上的云，地上的建筑物移动速度和翻页速度不一样 不同的背景物移动速度不一样，最后一页背景物上下扩散 翻页的过程中，人一直在走路 最后一页人要消失。 解决方案： ViewPager 给 viewPage设置PageChangeListener，在滚动的时候给各种 背景物体设置setTranslation。 不同的背景物设置不同的setTranslation系数。 人物走路用帧动画即可，在viewPage滑动处于SCROLL_STATE_DRAGGING状态的时候开启帧动画。 这个简单，监听onPageSelected，然后再设置人为 View.GONE即可。 解决方案的问题：粗略数了一下，6个页面大概有50个左右的背景物。如果要一个一个去获取 id，然后再根据不同的 id，设置不同的滑动速度滑动方向，可能你会疯掉。 因此，我们需要想一个办法，去解决这个问题。可能有的童鞋会说，我写一个自定义 View，设置滑动速度系数属性就行了呀。这个方法可以实现，but，你还是需要一个一个去 findViewbyid。 那么，我们是不是可以给 xml 添加自定义标签，然后自定义解析。比如说，天上的云，滑进来的阻尼系数是0.4，滑出去的阻尼系数是0.6，只需要在 xml 里面设置好这两个参数，然后我们再在合适的时使用这两个参数即可啊。 自定义LayoutInflater.Factory咦，怎么变成自定义LayoutInflater.Factory了，哈哈哈，还记得刚刚LayoutInflater的源码分析么，View 的创建全部在createViewFromTag里面，而createViewFromTag优先使用 Factory 来 创建。然后我们来看看Factory到底是干嘛的。 Hook you can supply that is called when inflating from a LayoutInflater.You can use this to customize the tag names available in your XML layout files. 当LayoutInflater在解析布局的时候会被调用 可以用来读取 xml 中的自定义标签。 这下迷惑都解开了吧，啊哈哈哈哈~~现在，我们就来定义这个 Factory思路很简单。 继承LayoutInflater.Factory2 实现抽象方法onCreateView 在onCreateView里面使用 LayoutInflate 的 createView方法创建View 创建成功之后，读取 view 的 attrs 属性，作为 tag 保持到 viewTag。 关键代码如下： 1234567891011121314@Overridepublic View onCreateView(String name, Context context, AttributeSet attrs) &#123; //创建一个 View View view = createViewOrFailQuietly(name, context, attrs); //实例化完成 if (view != null) &#123; //获取自定义属性，通过标签关联到视图上 setViewTag(view, context, attrs); //所有带有自定义属性的 View 保存起来，供动画切换的时候调用 mParallaxView.getParallaxViews().add(view); &#125; return view;&#125; 创建 view 的方法，这里注意一下，xml 标签里面系统的 view只有类名，自定义 view 是全路径。如：,而可以省略路径的 View 又分为 “android.widget.”和”android.view.”包下，所以对于只写缩写的 view，需要遍历这两个路径。 123456789101112131415161718192021222324private View createViewOrFailQuietly(String name, Context context, AttributeSet attrs) &#123; //1.自定义控件标签名称带点，所以创建时不需要前缀 if (name.contains(".")) &#123; createViewOrFailQuietly(name, null, context, attrs); &#125; //2.系统视图需要加上前缀 for (String prefix : sClassPrefix) &#123; View view = createViewOrFailQuietly(name, prefix, context, attrs); if (view != null) &#123; return view; &#125; &#125; return null;&#125;private View createViewOrFailQuietly(String name, String prefix, Context context, AttributeSet attrs) &#123; try &#123; //通过系统的inflater创建视图，读取系统的属性 return inflater.createView(name, prefix, attrs); &#125; catch (Exception e) &#123; return null; &#125;&#125; 读取 attrs 里面的属性，给含有特点 attrs 属性的 view设置 tag 并保存起来。 12345678910111213141516private void setViewTag(View view, Context context, AttributeSet attrs) &#123; //所有自定义的属性 TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AnimationView); if (a != null &amp;&amp; a.length() &gt; 0) &#123; //获取自定义属性的值 ParallaxViewTag tag = new ParallaxViewTag(); tag.xIn = a.getFloat(R.styleable.AnimationView_x_in, 0f); tag.xOut = a.getFloat(R.styleable.AnimationView_x_out, 0f); tag.yIn = a.getFloat(R.styleable.AnimationView_y_in, 0f); tag.yOut = a.getFloat(R.styleable.AnimationView_y_in, 0f); //index view.setTag(view.getId(), tag); a.recycle(); &#125;&#125; 好了，我们自定义LayoutInflater.Factory已经结束了，so，我们可以直接调用 LayoutInflate.cloneInContext(context)获取一个新的 LayoutInflate，然后再setFactor(customFactor)就可以了。代码如下： 123456789@Overridepublic View onCreateView(LayoutInflater original, ViewGroup container, Bundle savedInstanceState) &#123; Bundle args = getArguments(); int layoutId = args.getInt("layoutId"); LayoutInflater layoutInflater = original.cloneInContext(getActivity()); layoutInflater.setFactory(new ParallaxFactory(layoutInflater, this)); return layoutInflater.inflate(layoutId, null);&#125; 接下来的代码就不写了吧，就是监听 ViewPager 的滑动事件，获取当前滑出滑进页面的自定义了 attrs 属性的 View 列表，然后再根据滑出屏幕的比例*属性参数做 view 的 TranslationY/TranslationX 操作。这里我贴一下代码仓库地址吧，有兴趣的小伙伴可以把代码跑起来看一下 github传送门 看起来好像并没有什么卵用，就是秀了一波骚操作。写一个自定义 view，继承 ImageView，设置几个自定义 attrs 属性，再在构造方法里面把属性读出来保存到类变量，对外提供读取方法，然后同样监听 viewpager 的滑动就行了。 哈哈哈哈~~分享这篇文章的最终目的不是为了实现这个动画，就是想看一下 LayoutInflate 的源码，了解一下 xml 文件是怎么解析成 view的过程。。。。 已知 bug：v4的版本升级到19.1.0之后动画会失效引入appcompat包会报 xml 解析错误。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 用贝塞尔曲线绘制酷炫轮廓背景]]></title>
      <url>%2F2017%2F10%2F03%2Fandroid-study-bezier%2F</url>
      <content type="text"><![CDATA[Github地址：github.com/OCNYang/Con… 今天就借助这个开源控件，来为大家梳理一下自定义 View 的整个流程： 分析需求、功能，确定实现方法； 总结所需的参数属性以满足可定制性，较明确的属性归纳为自定义属性，不适合自定义属性的（比如传入数据，对象等）提供方法来设置； 有时自定义 View 会提供一种或几种默认及内置的样式，（这时可以根据内置的样式种类补充到自定义属性中），同时分析，使用内置样式或用户定制拓展时的流程； 开始根据分析，按流程依次重写： 构造函数（获取自定义属性，设置画笔等） –&gt; onMeasure()(测量大小) –&gt; onSizeChanged()(确定大小，一般我们在这里获取大小) –&gt; （onLayout()自定义View，因为没有子控件，这一步是不需要的） –&gt; onDraw()(按照需求和根据属性绘制实际内容) –&gt; 其他 如果有事件的需求，添加事件相关逻辑。那么现在我们就根据上面这个流程一步步来实现 ContourView。 分析 根据上面的分析，实现的思路大概都有了。那么我们就开始寻找具体实现方法。首先，我们选用三阶贝塞尔曲线，我们都知道三阶曲线的计算公式是： 12path.moveTo(start.x, start.y);path.cubicTo(control1.x, control1.y, control2.x,control2.y, end.x, end.y); 也就是说绘制一段曲线，我们需要知道两个锚点的坐标以及两个控制点的坐标，为了保证曲线的弯曲度能够达到理想的状态，控制点的坐标也不能是随意取的，这就要求我们必须通过一种计算方法合理的得出控制点的坐标。Google 了一下，发现先驱们已经找到了很多种方法供我们选择。 最终经过对比我们选用了这样一种方法： 这种方法大概的形式如上图，利用锚点集合，连续的4个锚点坐标Pi-1、Pi、Pi+1、Pi+2，通过具体公式来计算出中间两个锚点之间曲线的两个控制点坐标。 详细的计算方法介绍请看 ContourView 的 WiKi：Bézier-求贝塞尔曲线控制点 归纳自定义属性通过上面的分析，其实我们大概能总结出需要自定义的属性有哪些了。这里不着急，我们先总结一下自定义属性相关的内容和步骤？ 创建自定义属性文件 在 res/values/ 下新建 attrs.xml 文件（默认新建项目没有这个文件）。文件内容类似如下： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;attr name=&quot;custom_color&quot; format=&quot;color&quot;/&gt; &lt;declare-styleable name=&quot;ContourView&quot;&gt; &lt;attr name=&quot;shader_color&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;smoothness&quot; format=&quot;float&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 其中 attr 和 declare-styleable 节点分别代表的意思如下： attr： 定义了一个属性，属性名为 custom_color 这个是可以随意起的，但是要注意不要和其他控件所冲突， format 所定义的是属性的格式，其中格式又分为好多种，下面会细说，这里定义的是颜色 color。 declare-styleable：定义了一个属性组，在里面我们可以单独写 attr 属性，也可以引用直接在 resources 下定义的 attr，其中的区别就是引用的不用写 format。 需要注意的是，attr 并不依赖与 declare-styleable，declare-styleable 只是方便了 attr 的使用，使属性的使用更加明确。两者在代码中的获取方式并不相同，下面会细说。 在实际开发中，我们一般是采用 declare-styleable 方式，直接定义一组自己所编写的自定义控件需要用到的属性。 自定义属性的可以设置哪些属性 我们根据需要可以设置的自定义属性的格式一共有一下几种： format=”格式” 说明 app:myattr=”使用值” reference 参考某一资源ID “@drawable/图片ID” color 颜色值 “#FFFFFFFF” or “@color/颜色ID” boolean 布尔值 “true” or “false” dimension 尺寸值 “0dp” float 浮点型 “1.2” integer 整型值 “10” fraction 百分数值 “50%” string 字符串 “OCN.Yang” enum 枚举值（详见下） “自定义类型名称” flag 位或运算 “center bottom” 附：enum 枚举型定义：&lt;attr name=&quot;handsomeBoy&quot;&gt; &lt;enum name=&quot;OCNYang&quot; value=&quot;0x01&quot;/&gt; &lt;enum name=&quot;TFBOYS&quot; value=&quot;0x10&quot;/&gt;&lt;/attr&gt;enum 使用：app:handsomeBoy=&quot;OCNYang&quot;flag 定义：&lt;attr name=&quot;gravity&quot;&gt; &lt;flag name=&quot;top&quot; value=&quot;0&quot;/&gt; &lt;flag name=&quot;center&quot; value=&quot;1&quot;/&gt; &lt;flag name=&quot;bottom&quot; value=&quot;2&quot;/&gt;&lt;/attr&gt;flag 使用：app:gravity=&quot;center|bottom&quot;混搭使用&lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;这样，你传入资源ID或颜色值都是可以的了。 获取自定义属性 那怎么获取这些自定义的属性呢，只需要在自定义 View 的构造方法（两个参数或两个以上的参数）里通过一下方式就能获取到了： 1234567public ContourView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ContourView); //注意：获取时自定义的属性名有变动，例如：定义名：contour_style -&gt; 获取名：ContourView_contour_style（即：自定义属性组名_属性名） mStyle = typedArray.getInt(R.styleable.ContourView_contour_style, STYLE_SAND);&#125; 当然获取时，不同格式的属性需要通过 TypedArray 对应的不同的方法获取，那 TypedArray 都有哪些获取方法呢？如下图： 通过方法名称，相信你能很轻易的知道，需要哪个对应方法获取了。 如果你想更详细的了解每个方法的详细介绍，可以点击下面链接查看：developer.android.com/reference/a…另外，比较特殊的 enum 的获取方法：由于 enum 的 value 值只能设置 int 型，所以，获取enum的方式是 getInt()。 好了，关于自定义属性的介绍大概就是这么多内容了，那么回到原题，我们的 ContourView 需要哪几种 自定义属性呢？其实通过分析模块中我们就基本知道我们需要的属性有哪些了： 内置轮廓样式： enum 类型，内置多少个 enum 就有多少类型； 绘制颜色：纯色绘制时，我们需要一个颜色值，Color 属性 Shader 相关： 采用哪种 Shader，enum 类型，有RadialGradient、SweepGradient、LinearGradient； Shader 的颜色，Color 类型，需要两个一个startColor，一个endColor； Shader 填充的控制，enum 类型，我们提供几种填充的方向，比如左上角到右下角，从上到下，然后我们再通过这个方向和传入的秒点集来动态计算起点和终点的坐标 具体如下： 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;ContourView&quot;&gt; &lt;attr name=&quot;shader_mode&quot;&gt; &lt;enum name=&quot;RadialGradient&quot; value=&quot;0x01&quot;/&gt; &lt;enum name=&quot;SweepGradient&quot; value=&quot;0x02&quot;/&gt; &lt;enum name=&quot;LinearGradient&quot; value=&quot;0x03&quot;/&gt; &lt;/attr&gt; &lt;attr name=&quot;shader_startcolor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;shader_endcolor&quot; format=&quot;color&quot;/&gt; &lt;attr name=&quot;shader_style&quot;&gt; &lt;enum name=&quot;LeftToBottom&quot; value=&quot;0x00&quot;/&gt; &lt;enum name=&quot;RightToBottom&quot; value=&quot;0x11&quot;/&gt; &lt;enum name=&quot;TopToBottom&quot; value=&quot;0x12&quot;/&gt; &lt;enum name=&quot;Center&quot; value=&quot;0x13&quot;/&gt; &lt;/attr&gt; &lt;attr name=&quot;contour_style&quot;&gt; &lt;enum name=&quot;Beach&quot; value=&quot;0x23&quot;/&gt; &lt;enum name=&quot;Ripples&quot; value=&quot;0x22&quot;/&gt; &lt;enum name=&quot;Clouds&quot; value=&quot;0x21&quot;/&gt; &lt;enum name=&quot;Sand&quot; value=&quot;0x00&quot;/&gt; &lt;enum name=&quot;Shell&quot; value=&quot;0x25&quot;/&gt; &lt;/attr&gt; &lt;attr name=&quot;shader_color&quot; format=&quot;color&quot;/&gt; &lt;!--弯曲系数，在通过贝塞尔曲线绘制曲线时，来控制弯曲度--&gt; &lt;attr name=&quot;smoothness&quot; format=&quot;float&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 内置样式既然自定义 View，那我们一定会为它提供一种或几种内置好的样式呀。这样别人在偷懒不想自己定制样式时，可以也有不错的显示效果呀！通过上面知道，ContourView 的轮廓样式主要是通过给出的锚点集控制的，所有的锚点围成的闭合曲线就是轮廓的大概样式了。所以，这里我们想内置几种样式，就等于内置几个锚点集就行了，这里的我们内置的锚点坐标为了使得不同大小显示效果相同，我们先在 onSizeChanged() 获得了 View 的宽高，然后根据宽高按照百分比来设置坐标。 设置的内置轮廓有以下几种（丑爆了），只是轮廓，颜色是自己设置的： 样式（contuor_style） 效果 Sand(默认) Clouds Beach Ripples Shell 重写各方法关于自定义 View 重写各方法的介绍，网上已经有太多太多，这里就不再啰嗦了。 这里推荐一个关于自定义 View 尤其关于绘制方面讲解特别详细的系列博客：github.com/GcsSloop/An…另外厚脸皮的放上一篇自己的关于讲解“自定义组合控件”的博客地址：www.jianshu.com/p/4bbc96721… 我们知道，在自定义 View 时，必须要有构造函数的，对于4个构造函数，有时可能大家不确定到底该重写哪个，也不知道每个构造函数有什么区别，这里对常用的做法做下说明。 1234567//在代码中直接 new 一个 Custom View 实例时,会调用第一个构造函数.这个没有任何争议.public View(Context context); //在 xml 布局文件中使用自定义 View 时,会调用第二个构造函数.这个也没有争议.public View(Context context, AttributeSet attrs); //关于这个构造函数的调用，网上真是众说纷纭，我也不说哪种说法正确，下面提供详解public View(Context context, AttributeSet attrs, int defStyle);//4个参数的构造函数这里不做考虑 关于内部这4个构造函数是怎么调用的，这里直接放源码图片，自己一目了然： 大家在自定义 View 时，如果没有特别的需求，只要重写前两个构造函数就可以了，我习惯性的写成下面的形式： 12345678910111213141516public class MyView extends View &#123; public MyView(Context context) &#123; this(context, null); &#125; public MyView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public MyView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); //初始化画笔，做一些属性的默认赋值等； //获取自定义的属性等； &#125;&#125; 那，说了这么多还是没有提第3个参数到底是干什么的有什么用呀，这里我就不再为大家详细讲解了，这里找到了一片文章，讲解了第3个参数在什么时候怎么使用，大家可以看一下： www.cnblogs.com/angeldevil/… 回归到 ContourView，其实 ContourView 内部很简单，只对 onDraw() 进行了重写，毕竟 ContourView 的主要部分就是绘制。绘制的逻辑，就是遍历锚点集，然后利用上面 WiKi 里提到的公式求出各段曲线的控制点，然后用三阶贝塞尔曲线画出路径。当遍历完锚点集时，闭合曲线的轮廓基本上就得到了，然后就用Shader对路径进行绘制就行。 好了，本次的梳理内容就到这了，感兴趣的可以查看 ContourView 的源码进行分析，同时 ContourView 的这种背景效果还是不错的，需要的时候大家真的可以用到呢! ContourView GitHub:github.com/OCNYang/Con… 如果大家想看一些高级的自定义 View 的例子可以查看上次开源的 App 的天气模块，其中的天气页面以及天气折线图等等控件都是通过自定义 ViewGroup 或自定义 View 实现的。地址是:Qbox Github:github.com/OCNYang/QBo…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 带滑动效果的bottomBar]]></title>
      <url>%2F2017%2F09%2F30%2Fandroid-study-bottombar%2F</url>
      <content type="text"><![CDATA[看到一个bottomBar的设计,感觉很好看,于是把它实现了出来 可以看到这是一个常见的bottomBar把它分解一下 一共有5个item,每个item的背景颜色不一样 点击item时,item是通过滑动来移动到相应的item上的,这个移动也不是简单的线性移动,而是带有粘性的. item移动时,item颜色的切换是有item之间过渡的,类似于加了一个遮罩 移到item时,item本身是伴随item的移动是有一个动画的. 根据我们的分解,一步一步解决问题考虑到这是一个bottomBar,我选择了自定义ViewGroup来实现.因为用ViewGroup添加item会比较方便. 12345678910111213public class AnimationBottomBar extends ViewGroup &#123; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; &#125;&#125; 另外item内的小动画我也选择用缩放的形式实现,所以个效果图会有一些出入 添加item通常来说,一个item会有一个图标和简短的标题.举个例子,就像是知乎,即刻下方的bottomBar一样 所以一个item内有也要有一个图标和一个标题添加item的时候要足够方便,使用代码添加是个不错的选择,类似于这样mAnimationBottomBar.addItem(item).我创建了一个简单的BottomItem类来包装item 12345678public class BottomItem &#123; int drawableRes;//图标资源 String title;//标题 public BottomItem(@DrawableRes int drawableRes,String title)&#123; this.drawableRes=drawableRes; this.title=title; &#125;&#125; 添加item之后,我将添加的BottomItem保存到一个list里 1234public AnimationBottomBar addItem(BottomItem bottomItem) &#123; mBottomItemArrayList.add(bottomItem); return this;&#125; 添加item之后会返会对象本身,就可以继续.addItem()了,就像这样 12345mAnimationBottomBar.addItem(new BottomItem(R.drawable.h, "zero")) .addItem(new BottomItem(R.drawable.h, "one")) .addItem(new BottomItem(R.drawable.h, "two")) .addItem(new BottomItem(R.drawable.h, "four")) .addItem(new BottomItem(R.drawable.h, "five")) 好了,现在已经添加了item,嗯?球都没得.运行没有显示出来,当然啦添加了之后需要添加到ViewGroup里,在经过onMeasure和onLayout之后才会显示出来 1234567891011121314151617public void build() &#123; itemCount = mBottomItemArrayList.size(); itemWidth=getLayoutParams().width/itemCount;/*获得平均一个item的宽度,这里有个问题,因为这个时候还没有经过OnMeaSure(),width获取不到,在onMeasure里可以再次进行调整*/ for (BottomItem bottomItem : mBottomItemArrayList) &#123;/*添加图标*/ ImageView imageView = new ImageView(mContext); imageView.setImageResource(bottomItem.drawableRes); addView(imageView, itemWidth, 20); &#125; for (BottomItem bottomItem : mBottomItemArrayList) &#123;/*添加标题/ TextView textView=new TextView(mContext); textView.setTextSize(textSize); textView.setText(bottomItem.title); textView.setTextColor(textColor); textView.setGravity(Gravity.CENTER); addView(textView,itemWidth,20); &#125;&#125; onMeasure(),遍历刚刚所有添加子View,通知它们测量自己的长宽 123456789101112@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); childCount = getChildCount();/*获得所有子View的数量*/ barWidth = getSize(300,widthMeasureSpec);//bottombar的宽度 barHeight = getSize(300,heightMeasureSpec);//--的高度 for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); measureChild(childView, widthMeasureSpec, heightMeasureSpec); childView.getLayoutParams().width=itemWidth;/*调整子view的宽度*/ &#125;&#125; onLayout(),确定所有的子View应该在的位置 1234567891011@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; for (int i = 0; i &lt; itemCount; i++) &#123;/*遍历每一个item,放置item的位置*/ itemCenterX[i] = (int) (itemWidth * (i + 0.5));/*记录每个item的中心位置*/ View childImageView = getChildAt(i); childImageView.layout(itemWidth * i, 0, itemWidth * (i + 1), 100);//放置图标, View childTextView=getChildAt(itemCount+i); childTextView.layout(itemWidth * i+childTextView.getWidth()/4,100,itemWidth * (i + 1),barHeight);/*放置标题*/ &#125;&#125; 此时的样子应该是这样的 添加背景颜色你可能会想到用setBackGroundColor()来设置背景颜色,不过不要忘了,我们这个是要实现动画效果的,虽然使用setBackGroundColor()也能实现,但是要复杂一些.我决定使用OnDraw()画出来,在ViewGroup里默认是不调用OnDraw()的具体原因见这里解决方法也很简单 如果我们要重写一个ViweGroup的onDraw方法，有两种方法：1.在构造函数里面，给其设置一个颜色，如#00000000。2.在构造函数里面，调用setWillNotDraw(false)，去掉其WILL_NOT_DRAW flag。 我选择了第二个方法,因为我们要自己实现背景. 12345678910111213141516@Overrideprotected void onDraw(Canvas canvas) &#123; /*绘制item颜色*/ for (int i = 0; i &lt; 5; i++) &#123; mPaint.setColor(itemcolors[i]); canvas.drawRect(itemWidth * i, 0, itemWidth * (i + 1), barHeight, mPaint); canvas.save(); &#125; /*画出背景,两个长方形*/ mPaint.setColor(backGroundColor); canvas.drawRect(0, 0, itemMoveLeft, barHeight, mPaint); canvas.drawRect(itemMoveRight, 0, itemWidth * 5, barHeight, mPaint); canvas.save(); super.onDraw(canvas);&#125; 这里我分了两部分来画,一是每个item的背景颜色,二是整体的背景颜色,注意画的先后顺序哦,我为了实现item的移动,把item部分画在下层,把背景画在了上层,通过改变背景来实现item的移动效果.这时候的效果是这样的 实现动画注意这里的动画其实分为两个部分,两部分是同时进行的 item的移动动画 item的缩放动画 12345678910111213141516171819202122232425262728293031@Overrideprotected void onDraw(Canvas canvas) &#123; /绘制item颜色*/ for (int i = 0; i &lt; 5; i++) &#123; mPaint.setColor(itemcolors[i]); canvas.drawRect(itemWidth * i, 0, itemWidth * (i + 1), barHeight, mPaint); canvas.save(); &#125; /*画出背景,两个长方形*/ mPaint.setColor(backGroundColor); canvas.drawRect(0, 0, itemMoveLeft, barHeight, mPaint); canvas.drawRect(itemMoveRight, 0, itemWidth * 5, barHeight, mPaint); canvas.save(); /*遍历每个item位置,画出需要移动和缩放的item*/ for (int i = 0; i &lt; itemCount; i++) &#123; int deltaX=Math.abs(itemMoveCenter-itemCenterX[i]);/*获得当前item移动中心点和item固定中心点的距离*/ if (deltaX&lt;itemWidth)&#123; itemScale[i]= (float) (-0.5*deltaX/itemWidth+1);/*当距离小于一个item的宽度时调整item的缩放系数*/ &#125; else itemScale[i]=0.5f;/*非选中的item的缩放系数固定为0.5*/ /*对item的大小进行缩放*/ View childImageView = getChildAt(i); childImageView.setScaleX(itemScale[i]); childImageView.setScaleY(itemScale[i]); View childTextView = getChildAt(itemCount+i); childTextView.setScaleX(itemScale[i]); childTextView.setScaleY(itemScale[i]); &#125; super.onDraw(canvas);&#125; 我用了几个数组来记录每个item的固定中心位置,每个item的颜色,每个item的缩放系数.缩放系数这里,默认的未选中item的缩放系数是0.5,选中的item的缩放系数就是1.0,移动的时候,越靠近选中的item就这个系数就越大.既然是动画我们肯定要让她动起来,我继承了Animation类实现了自己的BottomAnimation类 12345678910111213141516171819202122private class BottomAnimation extends Animation &#123; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &#123; super.applyTransformation(interpolatedTime, t); int position = selectIndex - selectLastIndex; /*判断不同方向的移动*/ if (position &lt; 0) &#123;/*向左滑动*/ itemMoveRight = (int) (itemMoveLastRight + interpolatedTime * itemWidth * position); itemMoveLeft = (int) (itemMoveLastLeft + setFirst(interpolatedTime) * itemWidth * position); itemMoveCenter = (int) (itemMoveLastRight + interpolatedTime * itemWidth * position) -itemWidth / 2;/*记录中心点移动的位置*/ &#125; else &#123;/*向右滑动*/ itemMoveRight = (int) (itemMoveLastRight + setFirst(interpolatedTime) * itemWidth * position); itemMoveLeft = (int) (itemMoveLastLeft + interpolatedTime * itemWidth * position); itemMoveCenter = (int) (itemMoveLastLeft + interpolatedTime * itemWidth * position) + itemWidth / 2;/*记录中心点移动的位置*/ &#125; postInvalidate();/*更新画面*/ &#125; /*为了实现果冻效果,先移动的一侧要有快速效果*/ private float setFirst(float interpolatedTime) &#123; return (float) Math.sin(interpolatedTime * 0.5 * Math.PI); &#125;&#125; 在判断到有点击事件之后,启动这个动画就ok了 1234567891011121314151617@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN: touchDownX = ev.getX(); break; case MotionEvent.ACTION_UP: if (ev.getX() / itemWidth == touchDownX / itemWidth) &#123; selectIndex = (int) (ev.getX() / itemWidth); /*点击时开始动画*/ startAnimation(mBottomAnimation); &#125; break; &#125; return true;&#125; 最后的效果是这个样子的 最后完整的的代码在我的github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 快速创建Activity、Fragment模板]]></title>
      <url>%2F2017%2F09%2F29%2Fandroid-studio-template%2F</url>
      <content type="text"><![CDATA[自行复制粘贴在Settings&gt;Editor&gt;File and Code Templates新建一个 Activity可以自行将AppCompatActivity换成自己的BaseActivity，不要忘记更改import哦 123456789101112131415#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;#endimport android.os.Bundleimport android.support.v7.app.AppCompatActivity/*** description-&gt;&lt;一句话功能简介&gt;* @author SLJ* @time $&#123;DATE&#125;*/class $&#123;NAME&#125; : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) &#125;&#125; Fragment1234567891011121314151617181920#if ($&#123;PACKAGE_NAME&#125; &amp;&amp; $&#123;PACKAGE_NAME&#125; != &quot;&quot;)package $&#123;PACKAGE_NAME&#125;#endimport android.os.Bundleimport android.view.LayoutInflaterimport android.view.Viewimport android.view.ViewGroupimport android.app.Fragment/*** description-&gt;&lt;一句话功能简介&gt;* @author SLJ* @time $&#123;DATE&#125;*/class $&#123;NAME&#125; : Fragment() &#123; override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View &#123; val view = inflater?.inflate(, container, false) return view!! &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 为什么不该使用Timer]]></title>
      <url>%2F2017%2F09%2F29%2Fandroid-timer%2F</url>
      <content type="text"><![CDATA[概述在Java开发中，用过定时功能的同学一定不会对Timer感到陌生。不过，除了Timer，在Java 5之后又引入了一个定时工具ScheduledThreadPoolExecutor，那么我们应该如何在这两个定时工具之间进行选择呢？ 一般情况下我们都建议使用ScheduledThreadPoolExecutor而不是Timer，主要原因有以下3点： Timer使用的是绝对时间，系统时间的改变会对Timer产生一定的影响；而ScheduledThreadPoolExecutor使用的是相对时间，所以不会有这个问题。 Timer使用单线程来处理任务，长时间运行的任务会导致其他任务的延时处理，而ScheduledThreadPoolExecutor可以自定义线程数量。 Timer没有对运行时异常进行处理，一旦某个任务触发运行时异常，会导致整个Timer崩溃，而ScheduledThreadPoolExecutor对运行时异常做了捕获（可以在afterExecute()回调方法中进行处理），所以更加安全。 下面我们就来通过了解Timer与ScheduledThreadPoolExecutor的运行原理来理解上面几个问题出现的原因。 Timer的运行机制 TimerTask：任务类。内部持有nextExecutionTime变量，表示任务实际执行时间点，单位为毫秒，使用System.currentTimeMillis() + delay计算得出。 TimerQueue：使用小根堆实现的优先队列。按照TimerTask的实际执行时间点由小到大排序。 TimerThread：顾名思义，这是实际执行任务的线程。 TimerThread会在Timer初始化后启动，之后会进入mainLoop()方法，该方法会不断从TimerQueue中取出时间点最小的TimerTask。如果该TimerTask的执行时间点已到，则直接调用TimerTask.run()执行；否则，调用wait()方法，等待相应的时间。 而我们调用Timer.schedule()方法，实际上是通过TimerQueue.add()方法，将TimerTask加入任务等待队列。 这里还有一个需要注意的地方是：当加入任务的执行时间点是优先队列中最小的时，就调用notify()方法唤醒TimerThread，而TimerThread在被唤醒后会重新调用TimerQueue.getMin()方法，再次调用wait()，不过这次的等待时间就变成了新加入任务的时间点。 ScheduledThreadPoolExecutor的运行机制ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，对线程池的原理不了解的同学，可以看一下我的这篇文章：从零实现ImageLoader（三）—— 线程池详解。 ScheduledThreadPoolExecutor的实现比Timer要复杂一些，不过要是理解了线程池的运行原理，其实也不难。它只不过是在ThreadPoolExecutor的基础上使用自定义的阻塞队列DelayedWorkQueue来实现任务定时功能。所以ScheduledThreadPoolExecutor的运行流程其实和ThreadPoolExecutor是差不多的。 ScheduledFutureTask：任务类。内部持有time变量，单位为纳秒，通过System.nanoTime() + delay计算得出。 DelayedWorkQueue：使用小根堆实现的优先阻塞队列，将ScheduledFutureTask按照从小到大的顺序排列，同时在take()方法内实现阻塞操作。 WorkerThread：这里为了简单起见，我将线程池的核心线程和临时线程统一写成WorkerThread，但需要注意的是ScheduledThreadPoolExecutor是线程池的一个子类，所以线程池的那一套东西在ScheduledThreadPoolExecutor里也是有的。 光从这两个图上看，好像ScheduledThreadPoolExecutor和Timer的实现都大同小异，不过是换了一些名字，但实际上这两个的实现还是有很大的不同的，不止因为ScheduledThreadPoolExecutor使用的是多线程。 在Timer里定时功能的实现主要依靠TimerThread.mainLoop()的等待，而ScheduledThreadPoolExecutor使用的是多线程，在每个线程里都单独实现定时功能是不现实的，因此，ScheduledThreadPoolExecutor将定时功能放在了DelayedWorkQueue类里，而由于DelayedWorkQueue是阻塞队列，所以定时任务的实现实际上就在DelayedWorkQueue.take()方法中。下面我们就来分析一下DelayedWorkQueue.take()到底做了什么。 Leader/Follower模式在多线程网络编程中，我们一般使用一个线程监听端口，在接收到事件后再使用其他的线程去完成操作。这种情况下，在两个线程之间的上下文切换开销其实是很大的，于是我们有了Leader/Follower模式： 在Leader/Follower模式中，不存在一个专门用来监听的线程，所有的线程都是等价的，而这些线程会不断在Leader、Follower和Processor这三个状态之间来回切换。 在程序中会保证每个时刻有且只有一个Leader，这个Leader就暂时充当了之前用来监听端口线程的作用。而当有一个新的事件发生时，Leader不再是重新找一个线程去处理连接，而是自己转化为Processor处理事件，并且重新指定一个Follower作为新的Leader。当事件处理完毕后，Processor又会转化为Follower等待重新成为Leader。 take()方法的原理这里的take()方法就借助了Leader/Follower模式的思想，同一时刻只有一个Leader线程，不过这里由于任务执行的时间点是已经确定了的，所以不再是等待一个触发事件，而是等待最小任务所对应的延迟时间。其他的Follower线程则处于无限等待的状态，直到当前Leader到达指定时间后转化为Processor去处理任务，这时就会唤醒一个Follower作为下一任的Leader。而Processor在处理完任务后又会重新加入Follower进行等待。 绝对时间与相对时间了解了Timer与ScheduledThreadPoolExecutor的运行机制，下面我们就来看一下Timer的这些缺陷究竟是怎么回事。 首先是绝对时间与相对时间的问题，可能有人已经发现，不管是TimerTask还是ScheduledFutureTask都是存储的实际执行时间点，只不过一个是毫秒，一个是纳秒，难道时间单位还会对这些有影响？确实，时间单位是不会对任务的执行有影响的，不过这里的玄机就在于这个时间的计算方式：System.currentTimeMillis()与System.nanoTime()。 System.currentTimeMillis()大家已经很清楚了，就是当前时间与1970年1月1日午夜的时间差的毫秒数，而System.nanoTime()又是什么呢？官方文档里是这么说的： 此方法只能用于测量已过的时间，与系统或钟表时间的其他任何时间概念无关。返回值表示从某一固定但任意的时间算起的毫微秒数。这就是Timer与ScheduledThreadPoolExecutor一个是基于绝对时间而另一个是基于相对时间的原因。下面我们写个例子来测试一下： 1234567891011121314public static void main(String[] args) &#123; System.out.println("Start:\t" + new Date()); Executors.newSingleThreadScheduledExecutor().schedule(() -&gt; &#123; System.out.println("Executor:\t" + new Date()); &#125;, 60, TimeUnit.SECONDS); new Timer().schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println("Timer:\t" + new Date()); &#125; &#125;, 60000);&#125; 输出： 123Start: Sun Oct 08 10:51:44 CST 2017Executor: Sun Oct 08 10:51:41 CST 2017Timer: Sun Oct 08 10:52:45 CST 2017 这里，我在启动之后将系统的时钟向后调了一分钟，所以实际的启动时间应该是10:50:44，由于ScheduledThreadPoolExecutor的等待时间与系统无关，所以在一分钟后执行；而Timer是基于绝对时间的所以在10:52:45执行，实际上这时已经过去两分钟了。 单线程与多线程Timer的第二个缺陷是，由于它使用的是单线程，所以长时间执行的任务会对其他任务产生影响。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void main(String[] args) &#123; System.out.println("Start:\t\t\t" + new Date()); ScheduledExecutorService service = Executors.newScheduledThreadPool(3); service.schedule(() -&gt; &#123; System.out.println("Executor 任务1:\t" + new Date()); try &#123; Thread.sleep(30000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, 60, TimeUnit.SECONDS); service.schedule(() -&gt; &#123; System.out.println("Executor 任务2:\t" + new Date()); try &#123; Thread.sleep(30000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, 60, TimeUnit.SECONDS); Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println("Timer 任务1:\t\t" + new Date()); try &#123; Thread.sleep(30000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, 60000); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; System.out.println("Timer 任务2:\t\t" + new Date()); try &#123; Thread.sleep(30000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, 60000);&#125; 输出： 12345Start: Sun Oct 08 11:10:34 CST 2017Executor 任务1: Sun Oct 08 11:11:34 CST 2017Executor 任务2: Sun Oct 08 11:11:34 CST 2017Timer 任务1: Sun Oct 08 11:11:34 CST 2017Timer 任务2: Sun Oct 08 11:12:04 CST 2017 可以看到ScheduledThreadPoolExecutor中的两个任务在等待一分钟之后同时执行；而在Timer中的任务2却因任务1长达半分钟的执行时间，总共等了一分半钟才得以执行。 异常处理最后我们来看一下Timer与ScheduledThreadPoolExecutor对异常的处理情况： TimerTimer内部没有对异常做任何处理，如果任务执行发生运行时异常，整个TimerThread都会崩溃： 1234567891011121314151617181920212223public static void main(String[] args) &#123; System.out.println("Start:\t\t\t" + new Date()); Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; throw new RuntimeException("Timer 任务1"); &#125; &#125;, 60000); timer.schedule(new TimerTask() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Timer 任务2:\t\t" + new Date()); &#125; &#125;, 60000);&#125; 输出： 12345Start: Sun Oct 08 11:53:05 CST 2017Exception in thread &quot;Timer-0&quot; java.lang.RuntimeException: Timer 任务1 at main.Main$1.run(Main.java:32) at java.util.TimerThread.mainLoop(Timer.java:555) at java.util.TimerThread.run(Timer.java:505) 可以看到，任务1抛出的运行时异常导致整个Timer线程崩溃，任务2自然也没有执行。 ScheduledThreadPoolExecutorScheduledThreadPoolExecutor中对异常的处理实际上是ThreadPoolExecutor类完成的，ThreadPoolExecutor在任务运行时对异常做了捕获，并且将异常传入了afterExecute()方法： 123456789101112131415161718public class ThreadPoolExecutor extends AbstractExecutorService &#123; final void runWorker(Worker w) &#123; ... Throwable thrown = null; try &#123; task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; ... &#125;&#125; 我们来验证一下： 1234567891011121314151617public static void main(String[] args) &#123; System.out.println("Start:\t\t\t" + new Date()); ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor(); service.schedule(() -&gt; &#123; throw new RuntimeException("Executor 任务1"); &#125;, 60, TimeUnit.SECONDS); service.schedule(() -&gt; &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("Executor 任务2:\t" + new Date()); &#125;, 60, TimeUnit.SECONDS);&#125; 输出： 12Start: Sun Oct 08 11:33:35 CST 2017Executor 任务2: Sun Oct 08 11:34:36 CST 2017 可以看到这里虽然任务1抛出了运行时异常，但由于线程池内部完善的异常处理机制，任务2得以成功执行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 四种启动模式]]></title>
      <url>%2F2017%2F09%2F27%2Fandroid-launch-mode%2F</url>
      <content type="text"><![CDATA[此博文用来介绍一下Activity的四种启动模式和应用的场景。 主要是对于Android Activity启动模式的梳理。 返回栈首先，在介绍之前，我们需要有一个返回栈的概念。栈，是一种数据结构，遵循的是先进后出的规则，而无论是什么APP，里面的N个Activity最终都会被压入栈（或弹出栈中），而与我们进行交互的就是处于栈顶的Activity，在这里就需要介绍一个返回栈的概念。上一张图。 相信这张图片很清楚的说明，入栈的方式，所谓先进后出就是现在我们假设栈里面已经有abcd四个Activity了，并且都市默认的standard方式启动的。所谓先进后出就是，当我们不断按下back（返回键）的时候，后进去的d反而是最先谈栈的，a最后弹栈。 压栈：a-&gt;b-&gt;c-&gt;d(入栈顺序) 弹栈：b-&gt;c-&gt;b-&gt;a(弹出顺序) 先有一个返回栈的概念才能更好的进行分析。 为什么需要启动方式比如说，现在栈里面已经有四个activity abcd,这个时候的需求是需要到一个Activity a,如果我们只是使用默认的启动方式，那么就会形成abcda，当用户点击back按键的时候，弹出a，abcd。再按弹出d，abc。以此类推，然后又看到了a，是不是很烦人，而且这样的设计也的确很不人性化，所以设计了四种启动方式，来优化更好的体验，和满足特定场景下的用户需求。 四种启动的方式(1) standard: 标准的方式，也是系统默认的方式，每次启动一个activity，都会去创建一个新的activity的实例，并让该实例出于activity的栈顶位置，与用户交互，不管该实例存在不存在。 1234567button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent= new Intent(FirstActivity.this,FirstActivity.class); startActivity(intent); &#125;&#125;); 这是一个很典型的例子，就是由FirstActivity，跳转到FirstActivity，我们直观的思维会认为FirstActivity已经存在了，那么直接复用就好了啊，但是事实却不是这样子的。点击button两下，算上本身创建的FirstActivity，现在栈里面相当于有三个FirstActivity的实例，必须要点击三次返回键，才能回到桌面。这就是standard模式。 (2) singleTop :栈顶复用模式，当一个新的Activity已经处于栈顶的时候，那么再次调用新的Activity将不会创建新的实例，因为新的Activity已经在栈顶了，可以直接复用。比如说是栈的情况是abcd，d的启动方式singleTop，那么当我们再次启动d的时候，并不会创建新的实例，还是abcd，因为栈顶已经是d了，如果是adbc那么创建以后就是adbcd。如果d是默认方式启动的话，得到的就是abcdd。 (3) singleTask ：栈内复用的模式，只要activity在一个栈中，那么多次启动此activity都不会重新创建实例，比如说只要Activity以singleTask的方式启动，系统首先会去找寻是否有A需要的栈s，来存放A实例。如果没有s，就会创建栈s。然后做判断，如果s中有A，那么就直接把A置于栈顶，并且清空A上面的所有实例。如果A已经在栈顶，那么就直接复用A。如果存在S，就看S中是否有A的实例，没有A的实例就直接创建并且入栈，如果已经有A的实例并且没有处于栈顶，那就清楚A之前的所有实例，让A处于栈顶。举个例子(D都是以singleTask启动)： 比如目前S1中的情况为ABC，D以singleTask的启动方式入栈，并且请求的任务栈为S2，那么很显然，并不存在S2，所以就会创建S2，并且把D压入S2中。S1：ABC，S2：D。 另一种情况，S1：ABC ，D请求的是S1，那么直接压入S1中。S1：ABCD. S1：ADBC ，D请求的是S1，那么最终的S1：AD。因为栈内复用方式默认有一个clearTop的方法，会导致D上所有的实例出栈。让D置为栈顶。 (4) singleInstance: 单实例模式。这是一个加强版本的singleTask模式，它除了具有singleTask模式的所有特性之外，还加强的了一点，就是次方式启动的Activity只能单独的位于一个任务栈中，由于栈复用的特性，后续均不会创建新的Activity，除非这个任务栈被系统的销毁了。 特殊情况比如说现在有前台任务栈s1：AB(A底，B顶),后台任务栈S2:CD（都是以singleTask的方式启动）。当s1请求D入栈的时候，最终得到的是ABCD，但是如果只是请求C入栈的时候，得到的是ABC. 设置启动模式（两种）第一种：Xml文件中配置 1234&lt;activity android:name=&quot;.FirstActivity&quot; android:label=&quot;hello My First Activity&quot; android:launchMode=&quot;singleTop&quot;/&gt; 第二种：设置intent标志位的时候配置 123Intent intent= new Intent();intent.setClass(FirstActivity.this,FirstActivity.class);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 第二种的优先级方式是高于第一种的，当两种都存在的时候，以第二种为准。 指定栈和获取当前的activity的栈ID指定栈就是在设置activity的时候指定taskAffinity的属性，要求一个字符串，用.来分包，如果不写，栈就是默认的包名。在这里我指定为了，yanshui.site.task01配合上singleTask使用 12345&lt;activity android:name=&quot;.FirstActivity&quot; android:label=&quot;hello My First Activity&quot; android:launchMode=&quot;singleTask&quot; android:taskAffinity=&quot;yanshui.site.task01&quot;/&gt; 12//当你想要知道你当前的activity处于栈的id的时候直接在该activity中调用此方法即可。Log.d(TAG, "task id is "+getTaskId()); 使用场景 Standard 默认启动方式，每次都会创建一个新的实例，如果开发中需要就使用。但应该注意具体的情况，优化设计体验。 singleTop 栈顶复用，适合接受推送消息的展示页。某些本应只展示一个的场景，比如一下子收到一堆推送消息，不能每个都弹出来吧。但凡是这样的都行。优酷的推荐视频，电商app推送一个活动。每次只是显示第一条消息。 singleTask 栈复用模式适合程序入口，不需要启动后activity的是的，只能用在启动页了吧，首页，这种只允许有一个instance，如果有其他就移除掉它顶上的。从这个Activity进入的其他activity都抛弃掉了。用户要再操作一次。 singleInstance 栈单实例模式，需要一个activity提供给多有的应用程序访问的，比如说闹钟，响过一次以后，不再提醒，然后就不会再响了。 标志位 FLAG_ACTIVITY_NEW_TASK(xml中指定为singleTask) FLAG_ACTIVITY_SINGLE_TOP(xml中指定为singleTop) ​ 简单小结一下使用方式：standard：怎么样都要创建singleTop：顶上不是target Activity，new一个singleTask：顶上不是target Activity，移除target之上的，把自己变成top。singleInstance：开辟私有的task，完全独立于程序的其他activity的task。 使用场景：standard：普通activitysingleTop：要展示推送过来的消息singleTask：程序入口等启动页面singleInstance：完全独立的，类似闹钟的提示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 动态更换桌面图标]]></title>
      <url>%2F2017%2F09%2F26%2Fandroid-dynamic-icon%2F</url>
      <content type="text"><![CDATA[简介最近看到有可以实现动态改变桌面图标这个功能，比如天猫等app在各种剁手节的时候基本都会换个应景的图标以及整体风格，而这里只讨论图标的更换，查阅了一些资料，这里就介绍一下我认为最便捷的方式。 原理原理其实很简单就是利用标签，控制其enabled属性，用来显示与否。 实现实现之前，先简单描述一下需求： App默认图标是Android机器人图标，然后还有另外两个图标icon_1和icon_2，通过按钮点击设置变成哪个图标，也有一个还原图标的功能。 实现步骤： 增加对应个数的标签 增加布局喝对应点击事件 代码控制显示哪个图标 接下来就一步一步的来实现： 增加对应个数的标签 这里还有两个图标，所以我们再增加两个标签，这个标签是在AndroidManifest.xml的标签内的，和标签同一级，其中一个代码如下： 1234567891011&lt;activity-alias android:name=&quot;.MainActivity1&quot; android:enabled=&quot;false&quot; android:icon=&quot;@mipmap/icon_1&quot; android:label=&quot;@string/app_name&quot; android:targetActivity=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity-alias&gt; 这里需要注意一下他的这几个属性： 属性 含义 name 可任意取值，只要能保证是唯一标识即可，为了方便管理建议有规律一些 targetActivity 这个属性的值就是代表指向的是哪个Activity，而这个标签本身代表是该Activity的别名，记得指向的Activity要在该标签之前申明，否则可能运行不起来 icon 指的是该别名对应的应用图标 label 指的是该别名对应的应用名字 enabled 默认是true，true就会显示在桌面上，这里为了保证桌面只显示一个图标，则中的属性都是false，而在之后代码中动态控制这个属性，来显示和隐藏对应的图标 至于，这个和Activity的没有区别,其实完全可以把当作Activity组件来看，只是不是真身，是别名罢了。 另一个也是同理的，这里就不介绍了。 增加布局和对应点击事件 这一点其实没啥好说的，布局就是一个竖直方向的LinearLayout，里边有三个Button，通过其onClick属性，设置点击相应的方法，当然你也可以获取到这些Button再设置OnClickListener，代码比较简单，文末有Demo地址。 代码控制显示哪个图标 这一步其实也就是调用PackageManager中的一个方法即可，方法如下： 123456789private void changeLauncher(String name) &#123; PackageManager pm = getPackageManager(); //隐藏之前显示的桌面组件 pm.setComponentEnabledSetting(getComponentName(), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP); //显示新的桌面组件 pm.setComponentEnabledSetting(new ComponentName(MainActivity.this, name), PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);&#125; 都是调用PackageManager的setComponentEnabledSetting方法，第一个参数表示操作的组件是哪个，第二个参数表示显示还是隐藏，第三个组件表示是否关掉app。 TIPS 这里有个技巧，建议不要直接点了切换按钮就去执行切换图标，因为执行切换图标之后始终会关闭这次打开的app，所以我们 可以点击之后先记录下要换成哪个图标，在程序退出的时候再切换图标，这样一来就不会关闭该app了。 细心的朋友会发现，在调试阶段，我改了这个app的启动图标，再执行代码启动，发现启动不了，其实这是因为代码中默认启动那个组件和修改后的那个组件不一致了，所以就启动不了，而对于程序的更新和安装是没有影响的。 这种方式动态更换图标，更换的时候不是，切换之后就马上生效的，据我观察应该和手机性能有关，在执行该操作之后，会在几秒钟之内改变图标，但是对于普通桌面图标的改变，该缺点还是可以接受的，毕竟不是用户手动触发，也不影响体验。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio配置]]></title>
      <url>%2F2017%2F09%2F24%2Fandroid-studio-configuration%2F</url>
      <content type="text"><![CDATA[显示行号当我首次启动我的 Android Studio 的时候，我想做的第一件事就是希望能看到文件中的行号。 配置方法 File | Settings 打开设置 选择 Editor | General | Appearance 勾选 Show line numbers 驼峰选择Android 开发中，我们通常会使用驼峰命名法对变量进行命名，但是当我们通过 Ctrl + Left/ Right 键改变字符选择区域的时候 Android Studio 默认不支持‘驼峰’单词的选择。 配置方法 File | Settings 打开设置 选择 Editor | General | Smart Keys 选中 Use “CamelHumps” words 注意:如果你仍然希望当鼠标在单词上双击之后选中整个单词，需要作如下设置： File | Settings 打开设置 选择 Editor | General 取消选中 ‘Honor Camel Humps words settings when selecting on double click’ 命名前缀我们通常会遵循 Android 官方关于编码风格的指导来进行字段命名。在 Android 源码中我们可以看到通常成员变量都是以‘m’开始。其实Android Studio 可以自动在帮我们生成字段名称的时候加上自定义的前缀，如: 非共有，非静态的成员变量以’m’开始 静态成员变量以’s’开始 配置方法 File | Settings 打开设置 选择 Editor | Code Style | Java 选择 Code Generation 标签 给普通 Field 添加一个’m’前缀，给 Static filed 添加一个’s’前缀 快速导包在 Android Studio 中，我们可以通过 Alt + Enter 和 Control + Alt + O 进行导包和清除无用导包，但我们都希望这些事情应当快速自动完成。 配置方法 File | Settings 打开设置 选择 Editor | General | Auto Import 勾选 Optimize imports on the fly 勾选 Add unambiguous imports on the fly Log 颜色Darcula 主题中 Logcat 的默认配色只有红白两种颜色，不太便于我们区分 Log 的类型。 配置方法 File | Settings 打开设置 选择 Editor | Color &amp; Fonts | Android Logcat 点击 Click on Save As…按钮创建一个新的配色 Scheme 按照下面的表格修改对应的颜色(修改之前需要取消勾选 Use inherited attributes) Log级别 颜色 Assert: #AA66CC Debug: #33B5E5 Error: #FF4444 Info: #99CC00 Verbose: #FFFFFF Warning: #FFBB33 代码字体修改代码编辑区字体修改：选择菜单栏“File–settings–Editor–Colors&amp;Fonts–Font” 同样也可以修改控制台的字体(Console Font) 修改完之后发现AS的一些默认字体如侧边栏的工程目录的字体并没有发生变化，如果想改的话，那还是改一下吧（我个人一般是不改的），修改AS的默认字体(Appearance -&gt; Override default fonts by (not recommended)) 活动模板Android Studio 中默认提供了很多非常方便的活动模板(Live Templates)，例如，我们输入sout 后按 enter 键， Android Studio 会自动帮我们写入 System.out.println();其实 sout 就是 AS 自带的一个活动模板。 Editor -&gt; Live Templates 由此可以看出，活动模板就是我们常用代码的一个缩写。开发中有很多代码都会重复出现，因此自定义合适的活动模板能很大程度上避免我们很多重复的体力劳动。那么问题来了，如何自定义？ 这里我们实现一个AS不自带的方法，就是我们经常使用的switch用法作为例子。 在Custom的自定义组下，创建一个swi的自定义活动模板 提示关键字设置为 swi ，描述为 switch的选择语句 然后设置四个参数CONTAINER, FIRST,SECOND,END,分别代表着参数，第一个选择，第二个选择，最后一个光标坐落点。 然后点击右边的Edit variabldes，然后进行对四个参数的作用进行赋值，第一个参数我们选择suggestFirstVariableName(“Object”)表示系统推荐的，第二、三是为了我们方便写入我们需要的值，换行只需要回车就可以切换，避免鼠标操作，纯键盘手打，第四个参数就是我们输入的最后。 配置方法 File | Settings 打开设置 选择 Editor | Code Style | Live Templates 点击最右侧的加号并选择 Template Group 在弹出的对话框中输入一个活动模板分组的名称，如 custom 在左侧选中上一步中创建的 custom 分组，点击右边的加号 选择 Live Template ，在 Abbreviation 中对输入 psh 在 Description 中输入这个活动模板的描述 在 Template text 中输入以下代码 点击下方的 Define 按钮，选中 java 表示这个模板用于java代码 点击右侧的 Edit variables 选择 Expression 下拉框中的 className 并勾选 Skip if… 这个操作的作用是，AS会自动将我们在上一步中用’$’符包裹的 className自动替换为当前类不含包名的类名 点击 Apply 和 Ok 让设置生效。 类的头文件声明，标上自己的专注权类的头文件声明，因为我们写的代码，在开发程序的时候，我们一般都会给文件自动添加上一些关于文件的注释信息，比如开发者的名字，开发的时间，开发者的联系方式等等，效果图如下。 设置步骤 点击菜单栏的“File“-&gt;“Settings”，打开Settings窗口 点击“IDE Settings”下面的“File and Code Templates”，然后选中Templates里面的Class 然后选中Includes tab下面的File Header。 在最右边的输入框中就可以输入我们想要设置的注释模板了。比如我们输入： 1234/** * Created by OCN.Yang on $&#123;DATE&#125;. $&#123;HOUR&#125;:$&#123;MINUTE&#125; * mail:yangocn@163.com */ 然后点击ok便大功告成了。 禁止自动打开上次的工程我喜欢自己选打开哪个工程，果断禁用，设置如下：Preference -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Startup/shutdown -&gt; Reopen last project on startup 禁止代码折叠Intellij IDEA默认有很多地方的代码都会自动折叠，不过我看不惯，所以取消了，设置如下： Preference -&gt; Editor -&gt; General -&gt; Code Folding -&gt; One-line methods | “Closures”(anonymous classes implementing one method,before Java 8) | Generic constructor and method parameters 全屏代码这个功能是Android studio自带的功能，但是需要你先手动设置一下：全屏代码的快捷键（默认情况下这个功能是没有快捷键的，即是关闭的）：Toggle Presentation mode]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Lambda 表达式]]></title>
      <url>%2F2017%2F09%2F22%2Fandroid-lambda%2F</url>
      <content type="text"><![CDATA[Lambda 表达式编程中提到的 Lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。 Lambda 允许我们把行为传到函数里。之前把行为传到函数里我们采用的是匿名内部类，该方法导致行为最重要的方法夹杂在中间，不够突出，详见举例中代码。 123456789//以前点击事件，使用了匿名内部类mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(MainActivity.this, "toast", Toast.LENGTH_LONG).show(); &#125; &#125;);//新款Lambda 表达式，大家可以比较下上下的不同之处mButton.setOnClickListener(view -&gt; Toast.makeText(MainActivity.this, "toast", Toast.LENGTH_LONG).show()); 因此Lambda 表达式可以理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。 代码格式Lambda 表达式的基本格式是：() -&gt; {} 有下面三种具体表达： 1234567891011//(params) -&gt; expression//接收 x 和 y 这两个整形参数并返回它们的和； (int x, int y) -&gt; x + y//(params) -&gt; statement //不接收参数，返回整数 ‘42’； () -&gt; 42//(params) -&gt; &#123;statement&#125;//接收一个字符串并把它打印到控制台，不返回值。(String s) -&gt; &#123; System.out.println(s); &#125; 文字解释Lambda 表达式的语法由参数列表、箭头符号 -&gt; 和函数体组成。函数体既可以是一个表达式，也可以是一个语句块： 表达式：表达式会被执行然后返回执行结果。 语句块：语句块中的语句会被依次执行，就像方法中的语句一样 return 语句会把控制权交给匿名方法的调用者 break 和 continue 只能在循环中使用 如果函数体有返回值，那么函数体内部的每一条路径都必须有返回值 Lambda 表达式也会经常出现在嵌套环境中，比如说作为方法的参数。为了使 lambda 表达式在这些场景下尽可能简洁，我们去除了不必要的分隔符。不过在某些情况下我们也可以把它分为多行，然后用括号包起来，就像其它普通表达式一样。 123456FileFilter java = (File f) -&gt; f.getName().endsWith("*.java");String user = doPrivileged(() -&gt; System.getProperty("user.name"));new Thread(() -&gt; &#123; connectToService(); sendNotification();&#125;).start(); 具体案例 方法引用（关键字 ::） 简单来说，方法引用就是 Lambda 表达式的一种简写。当你创建一个 Lambda 表达式时，你创建了一个匿名方法并提供方法体，但你使用方法引用时，你只需要提供已经存在的方法的名字，它本身已经包含方法体。 做一个简单的解释，对集合进行排序，使用了Comparator的匿名内部类写法 123456789101112131415161718public static void main(String[] args) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(2); list.add(1); Collections.sort(list,new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer a, Integer b) &#123; return a - b; &#125; &#125;); &#125;//用Lambda 进行表示Collections.sort(list, (a, b) -&gt; a - b);//使用Lamabda 的方法引用，可以让匿名内部类Comparator中方法的两个参数和Integer类中compare方法的两个参数自动对应起来，是不是简洁明了呢。Collections.sort(list, Integer::compare); 方法引用的种类（Kinds of method references） 静态方法引用：ClassName::methodName 实例上的实例方法引用：instanceReference::methodName 超类上的实例方法引用：super::methodName 类型上的实例方法引用：ClassName::methodName 构造方法引用：Class::new 数组构造方法引用：TypeName[]::new 对于静态方法引用，我们需要在类名和方法名之间加入 :: 分隔符，例如 Integer::sum 使用 Lambda 的好处 Lambda 表达式不需要每次都要被实例化，对于 Java 来说，带来巨大的好处。不像实例化匿名类，对内存的影响可以降到最小。 Lambda 表达式不需要拷贝变量到它的运行环境中，从而 Lambda 表达式被当做是一个真正的方法来对待，而不是一个类的实例 。 因为是复制，变量必须声明为 final 类型，以保证在获取和使用时不会被改变。Java 使用了优雅的方式保证了变量不会被更新，所以我们不用显式地把变量加上 final 修饰。 Lambda 表达式函数体适合小型 Lambda 表达式，它消除了 return 关键字，使得语法更加简洁。 Lambda 表达式取代了匿名内部类，取消了模板，允许通过函数式风格编写代码，使代码的可读性更高，如果不想看不懂大佬的代码的话，赶紧学起来吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-超炫动画库]]></title>
      <url>%2F2017%2F09%2F20%2Fandroid-super-animation%2F</url>
      <content type="text"><![CDATA[源码地址Google Demo 概述Android 4.4.2 (API level 19)引入Transition框架，之后很多APP上都使用该框架做出很酷炫的效果，如 Google Play Newsstand app 还有github上很火的plaid 在app中适当得使用上Transition能带来较好的用户体验，视频中介绍了该框架的基本使用以及其中核心的一些类和方法，只有学会这些基本的API才能在之后的Activity/Fragment过渡定制一些自己想要的效果。先看官网的一张关系图 图中有三个核心的类，分别是Scene、Transition和TransitionManager，下面对这个三个核心类展开分析。 Scene Scene场景，用于保存布局中所有View的属性值，创建Scene的方式可以通过getSceneForLayout方法getSceneForLayout(ViewGroup sceneRoot, int layoutId, Context context)比如： 12mScene0 = Scene.getSceneForLayout(mSceneRoot,R.layout.scene0,getContext());mScene1 = Scene.getSceneForLayout(mSceneRoot,R.layout.scene1,getContext()); 也可以直接new Scene(ViewGroup sceneRoot, View layout) 1234View view0 = inflater.inflate(R.layout.scene0,container,false);View view1 = inflater.inflate(R.layout.scene1,container,false);mScene0 = new Scene(mSceneRoot,view0);mScene1 = new Scene(mSceneRoot,view1); 两种方式都需要传SceneRoot，即该场景的根节点。 Transition Transition过渡动画，前面创建了两个场景，分别保存了视图的一些属性，比如Visibility、position等，Transition就是对于这些属性值的改变定义过渡的效果。从上图可以看到系统内置了一些常用的Transition，Transition的创建可以通过加载xml，如：res/transition/fade_transition.xml &lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;/&gt; 然后在代码中： 1Transiton mFadeTransition = TransitionInflater.from(this).inflateTransition(R.transition.fade_transition); 或者直接在代码中： Transition mFadeTransition = new Fade(); TransitionManagerTransitionManeger用于将Scene和Transition联系起来，它提供了一系列的方法如setTransition(Scene fromScene, Scene toScene, Transition transition)指明起始场景和结束场景、他们的过渡动画是什么，go(Scene scene, Transition transition)，到指定的场景所使用的过渡动画是什么，beginDelayedTransition(ViewGroup sceneRoot, Transition transition)，在当前场景到下一帧的过渡效果是什么。比如这里使用go()方法，效果: 注意这里两个Scene中红绿两个方块除了位置和大小不一样，id是一致的，transition记录下两个Scene前后属性值，根据属性值的改变执行过渡动画，默认情况下对SceneRoot下的所有View执行动画效果，我们可以通过Transition.addTarget和removeTarget方法选择性添加或移除执行动画的View。 常用API有时候我们只想改变当前已展示的视图层级中View的状态，可以通过beginDelayedTransition实现，下面列举系统内置的Transition的使用。 AutoTransitionAutoTransition默认的动画效果，对应xml tag为autoTransition其实是以下几个动画组合顺序执行： 123456&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:transitionOrdering=&quot;sequential&quot;&gt; &lt;fade android:fadingMode=&quot;fade_out&quot; /&gt; &lt;changeBounds/&gt; &lt;fade android:fadingMode=&quot;fade_in&quot;/&gt;&lt;/transitionSet&gt; 在代码中使用： 123456TransitionManager.beginDelayedTransition(mRoot,new AutoTransition());if (mTextView.getVisibility() != View.VISIBLE)&#123; mTextView.setVisibility(View.VISIBLE);&#125; else &#123; mTextView.setVisibility(View.GONE);&#125; ChangeBoundsChangeBounds对应xml tag为changeBounds，根据前后布局界限的变化执行动画。 12345678TransitionManager.beginDelayedTransition(mRoot,new ChangeBounds());FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams)mTarget.getLayoutParams();if ((lp.gravity &amp; Gravity.START) == Gravity.START) &#123; lp.gravity = Gravity.BOTTOM | Gravity.END;&#125; else &#123; lp.gravity = Gravity.TOP | Gravity.START;&#125;mTarget.setLayoutParams(lp); ChangeClipBoundsChangeClipBounds对应xml tag为changeClipBounds，作用对象：View的getClipBounds()值 1234567Rect BOUNDS = new Rect(20,20,100,100);TransitionManager.beginDelayedTransition(mRoot,new ChangeClipBounds());if (BOUNDS.equals(ViewCompat.getClipBounds(mImageView))) &#123; ViewCompat.setClipBounds(mImageView,null);&#125; else &#123; ViewCompat.setClipBounds(mImageView,BOUNDS);&#125; ChangeImageTransform对应xml tag为changeImageTransform，作用对象：ImageView的matrix 12TransitionManager.beginDelayedTransition(mRoot,new ChangeImageTransform());mImageView.setScaleType(ImageView.ScaleType.xxx); ChangeScroll对应xml tag为changeScroll，作用对象：View的scroll属性值 12TransitionManager.beginDelayedTransition(mRoot,new ChangeScroll());mTarget.scrollBy(-100,-100); ChangeTransform对应xml tag 为changeTransform，作用对象：View的scale和rotation 123456789101112131415TransitionManager.beginDelayedTransition(mRoot,new ChangeTransform());if (mContainer2.getChildCount() &gt; 0)&#123; mContainer2.removeAllViews(); showRedSquare(mContainer1);&#125; else &#123; mContainer1.removeAllViews(); showRedSquare(mContainer2); mContainer2.getChildAt(0).setRotation(45);&#125;private void showRedSquare(FrameLayout container)&#123; final View view = LayoutInflater.from(getContext()) .inflate(R.layout.red_square,container,false); container.addView(view);&#125; Explode对应xml tag为explode，作用对象：View的Visibility 12345TransitionManager.beginDelayedTransition(mRoot,new Explode());int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;for (View view : mViews)&#123; view.setVisibility(vis);&#125; Fade对应xml tag为fade，作用对象：View的Visibility可以在初始化是指定IN或者OUT分别对应淡入和淡出，若不指定默认为淡入淡出效果 12345TransitionManager.beginDelayedTransition(mRoot,new Fade());int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;for (View view : mViews)&#123; view.setVisibility(vis);&#125; Slide对应xml tag为slide，作用对象：View的Visibility 12345TransitionManager.beginDelayedTransition(mRoot,new Slide());int vis = mViews.get(0).getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE;for (View view : mViews)&#123; view.setVisibility(vis);&#125; TransitionSet对应xml tag为transitionSet可以在代码中创建transitionSet如： 1234567891011mTransition = new TransitionSet();mTransition.addTransition(new ChangeImageTransform());mTransition.addTransition(new ChangeTransform());TransitionManager.beginDelayedTransition(mOUterFrame,mTransition);if (mInnerFrame.getChildCount() &gt; 0)&#123; mInnerFrame.removeAllViews(); addImageView(mOUterFrame,ImageView.ScaleType.CENTER_CROP,mPhotoSize);&#125; else &#123; mOuterFrame.removeViewAt(1); addImageView(mInnerFrame,ImageView.ScaleType.FIT_XY,FrameLayout.LayoutParams.MATCH_PARENT);&#125; 也可以通过加载xml布局创建transitionSet：xml布局长这样： 12345&lt;transitionSet xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:transitionOrdering=&quot;together&quot;&gt; &lt;changeImageTransform/&gt; &lt;changeTransform/&gt;&lt;/transitionSet&gt; 通过transitionOrdering属性设置动画执行的顺序，together表示同时执行，sequential表示顺序执行，在代码中可以调用TransitionSet的setOrdering(int)方法，属性值传ORDERING_SEQUENTIAL或者ORDERING_TOGETHER在代码中： 123456789mTransition = (TransitionSet)TransitionInflater.from(getContext()).inflateTransition(R.transition.transition);TransitionManager.beginDelayedTransition(mOuterFrame,mTransition);if (mInnerFrame.getChildCount() &gt; 0)&#123; mInnerFrame.removeAllViews(); addImageView(mOUterFrame,ImageView.ScaleType.CENTER_CROP,mPhotoSize);&#125; else &#123; mOuterFrame.removeViewAt(1); addImageView(mInnerFrame,ImageView.ScaleType.FIT_XY,FrameLayout.LayoutParams.MATCH_PARENT);&#125; 这里结合changeImageTransform和changeTransform，效果如下： PathMotion Transition的辅助工具，以path的方式指定过渡效果，两个具体实现类ArcMotion和PatternPathMotion，看下ArcMotion的效果 123456789mTransition = new AutoTransition();TransitionManager.beginDelayedTransition(mRoot,mTransition);FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mTarget.getLayoutParams();if ((lp.gravity &amp; Gravity.START) == START) &#123; lp.gravity = Gravity.END | Gravity.BOTTOM;&#125; else &#123; lp.gravity = Gravity.START | Gravity.TOP;&#125;mTarget.setLayoutParams(lp); 它的运动轨迹是条曲线，有兴趣的可以研究下它的实现算法，在源码中有个很萌的图如下： 自定义Transition除了系统内置的Transition，我们还可以自定义Transition效果，需要继承Transition 12345678public class CustomTransition extends Transition &#123; @Override public void captureStartValues(TransitionValues values)&#123;&#125; @Override public void captureEndValues(TransitionValues values)&#123;&#125; @Override public Animator createAnimator(ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues)&#123;&#125;&#125; 其工作原理是在captureStartValues和captureEndValues中分别记录View的属性值，官网建议确保属性值不冲突，属性值的命名格式参考：package_name:transition_name:property_name在createAnimator中创建动画，对比属性值的改变执行动画效果，如自定义修改颜色动画效果： 在两个Scene中使用自定义过渡动画，效果如下： Note Android 版本在4.0(API Level 14)到4.4.2(API Level 19)使用Android Support Library’s 对于 SurfaceView可能不起效果，因为SurfaceView的实例是在非UI线程更新的，因此会造成和其他视图动画不同步。 某些特定的转换类型在应用到TextureView时可能不会产生所需的动画效果。 继承自AdapterView的如ListView，与该框架不兼容。 不要对包含文本的视图的大小进行动画]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-自己封装DialogFragment]]></title>
      <url>%2F2017%2F09%2F19%2Fandroid-dialogfragment-wrap%2F</url>
      <content type="text"><![CDATA[创建通用的 CommonDialogFragment这个类是 DialogFragment 的子类，对 DialogFragment 进行封装，依赖外部传入的 AlertDialog 来构建，同时也处理了 DialogFragment 中 AlertDialog 不能设置外部取消的问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class CommonDialogFragment extends DialogFragment &#123; /** * 监听弹出窗是否被取消 */ private OnDialogCancelListener mCancelListener; /** * 回调获得需要显示的dialog */ private OnCallDialog mOnCallDialog; public interface OnDialogCancelListener &#123; void onCancel(); &#125; public interface OnCallDialog &#123; Dialog getDialog(Context context); &#125; public static CommonDialogFragment newInstance(OnCallDialog call, boolean cancelable) &#123; return newInstance(call, cancelable, null); &#125; public static CommonDialogFragment newInstance(OnCallDialog call, boolean cancelable, OnDialogCancelListener cancelListener) &#123; CommonDialogFragment instance = new CommonDialogFragment(); instance.setCancelable(cancelable); instance.mCancelListener = cancelListener; instance.mOnCallDialog = call; return instance; &#125; @Override public Dialog onCreateDialog(Bundle savedInstanceState) &#123; if (null == mOnCallDialog) &#123; super.onCreateDialog(savedInstanceState); &#125; return mOnCallDialog.getDialog(getActivity()); &#125; @Override public void onStart() &#123; super.onStart(); Dialog dialog = getDialog(); if (dialog != null) &#123; //在5.0以下的版本会出现白色背景边框，若在5.0以上设置则会造成文字部分的背景也变成透明 if(Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT) &#123; //目前只有这两个dialog会出现边框 if(dialog instanceof ProgressDialog || dialog instanceof DatePickerDialog) &#123; getDialog().getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); &#125; &#125; Window window = getDialog().getWindow(); WindowManager.LayoutParams windowParams = window.getAttributes(); windowParams.dimAmount = 0.0f; window.setAttributes(windowParams); &#125; &#125; @Override public void onCancel(DialogInterface dialog) &#123; super.onCancel(dialog); if (mCancelListener != null) &#123; mCancelListener.onCancel(); &#125; &#125;&#125; 可以看到这个类的代码量也是很少的，先定义了两个接口 OnDialogCancelListener，OnCallDialog，前者用于监听弹出窗是否被取消，后者则可以让我们回调获得想要显示的 Dialog，可以看到在 onCreateDialog() 中我们返回的 是 mOnCallDialog.getDialog(getActivity);，当我们在传入 Dialog 的时候，便会回调到此处，让 onCreateDialog() 返回我们传入的 Dialog。 接着在 onStart() 中进行了一些特殊性的处理，因为在 5.0 以下的版本，ProgressDialog 和 DatePickerDialog 会出现白色的边框，这使得用户体验非常不好，所以我们要在此处进行相应的处理 最后便是封装我们的构造函数newInstance(OnCallDialog call, boolean cancelable, OnDialogCancelListener cancelListener)，当我们要使用这个 CommonDialogFragment 的时候，先 new 一个 OnCallDialog，将我们想要显示的 Dialog 传进去，cancelable，用于设置对话框是否能被取消，可以看到在 onCancel() 有这样一段代码 123if(mCancelListener != null)&#123; mCancelListener.onCancel();&#125; 这便是我们在构造函数中传入 OnCancelListener 的原因，当我们想要做一些取消对话框后的处理时，只要在构造函数中传入 OnCancelListener，实现 onCancel() 方法就行了 实现各种类型的 DialogFragment既然前面我们创建了 CommonFragment 作为所有 DialogFragment 的基类，那么接下来我们当然要好好地来实现各种类型的 DialogFragment 了，我的思路是创建一个 DialogFragmentHelper 作为实现提示框的帮助类，帮我们把代码都封装起来，使用的时候只需要关注与 AlertDialog 的交互，Helper 会帮助我们用 DialogFragment 来进行显示，这样既能统一整个应用的 Dialog 风格，又能让我们实现各种各样的对话框变得相当的简单 在实现 DialogFragmentHelper 之前我们有两件事先要做一下 在 styles 文件中定义我们定义我们对话框的风格样式1234567891011121314151617181920212223242526&lt;style name=&quot;Base_AlertDialog&quot; parent=&quot;Base.Theme.AppCompat.Light.Dialog&quot;&gt; &lt;!--不设置在6.0以上会出现，宽度不充满屏幕的情况--&gt; &lt;item name=&quot;windowMinWidthMinor&quot;&gt;90%&lt;/item&gt; &lt;!-- 取消标题栏，如果在代码中settitle的话会无效 --&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;!-- 标题的和Message的文字颜色 --&gt; &lt;!--&lt;item name=&quot;android:textColorPrimary&quot;&gt;@color/black&lt;/item&gt;--&gt; &lt;!-- 修改顶部标题背景颜色，具体颜色自己定，可以是图片 --&gt; &lt;item name=&quot;android:topDark&quot;&gt;@color/app_main_color_deep&lt;/item&gt; &lt;!--&lt;item name=&quot;android:background&quot;&gt;@color/white&lt;/item&gt;--&gt; &lt;!-- 在某些系统上面设置背景颜色之后出现奇怪的背景，处这里设置背景为透明，为了隐藏边框 --&gt; &lt;!--&lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;--&gt; &lt;!--&lt;item name=&quot;android:windowFrame&quot;&gt;@null&lt;/item&gt;--&gt; &lt;!-- 进入和退出动画，左进右出（系统自带） --&gt; &lt;!--&lt;item name=&quot;android:windowAnimationStyle&quot;&gt;@android:style/Animation.Translucent&lt;/item&gt;--&gt; &lt;!-- 按钮字体颜色,全部一起改，单个改需要在Java代码中修改 --&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/app_main_color&lt;/item&gt; &lt;/style&gt; 我已经打上了详细的注释，相信应该很容易理解 写一个接口，用于 DialogFragmentHelper 与逻辑层之间进行数据监听123public interface IDialogResultListener&lt;T&gt; &#123; void onDataResult(T result);&#125; 准备工作做完了，就让我们开工撸 DialogFragmentHelper 吧，因为篇幅有限，我只是代表性的选了其中的一些效果来讲，具体的代码，可以参考下 DialogFragmentDemos 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class DialogFragmentHelper &#123; private static final String TAG_HEAD = DialogFragmentHelper.class.getSimpleName(); /** * 加载中的弹出窗 */ private static final int PROGRESS_THEME = R.style.Base_AlertDialog; private static final String PROGRESS_TAG = TAG_HEAD + ":progress"; public static CommonDialogFragment showProgress(FragmentManager fragmentManager, String message)&#123; return showProgress(fragmentManager, message, true, null); &#125; public static CommonDialogFragment showProgress(FragmentManager fragmentManager, String message, boolean cancelable)&#123; return showProgress(fragmentManager, message, cancelable, null); &#125; public static CommonDialogFragment showProgress(FragmentManager fragmentManager, final String message, boolean cancelable , CommonDialogFragment.OnDialogCancelListener cancelListener)&#123; CommonDialogFragment dialogFragment = CommonDialogFragment.newInstance(new CommonDialogFragment.OnCallDialog() &#123; @Override public Dialog getDialog(Context context) &#123; ProgressDialog progressDialog = new ProgressDialog(context, PROGRESS_THEME); progressDialog.setMessage(message); return progressDialog; &#125; &#125;, cancelable, cancelListener); dialogFragment.show(fragmentManager, PROGRESS_TAG); return dialogFragment; &#125; /** * 带输入框的弹出窗 */ private static final int INSERT_THEME = R.style.Base_AlertDialog; private static final String INSERT_TAG = TAG_HEAD + ":insert"; public static void showInsertDialog(FragmentManager manager, final String title, final IDialogResultListener&lt;String&gt; resultListener, final boolean cancelable)&#123; CommonDialogFragment dialogFragment = CommonDialogFragment.newInstance(new CommonDialogFragment.OnCallDialog() &#123; @Override public Dialog getDialog(Context context) &#123; // ... AlertDialog.Builder builder = new AlertDialog.Builder(context, INSERT_THEME); builder.setPositiveButton(DIALOG_POSITIVE, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; if(resultListener != null)&#123; resultListener.onDataResult(editText.getText().toString()); &#125; &#125; &#125;); builder.setNegativeButton(DIALOG_NEGATIVE, null); return builder.create(); &#125; &#125;, cancelable, null); dialogFragment.show(manager, INSERT_TAG); &#125;&#125; 可以看到因为我们实现封装了 CommonFragment，所有这些效果的实现都变得相当的简单吗，这便是封装给我们带来的便利和好处。 就以 加载中的弹出窗 为例，来看看我们是怎么实现的 123456789101112public static CommonDialogFragment showProgress(FragmentManager fragmentManager, final String message, boolean cancelable, CommonDialogFragment.OnDialogCancelListener cancelListener)&#123; CommonDialogFragment dialogFragment = CommonDialogFragment.newInstance(new CommonDialogFragment.OnCallDialog() &#123; @Override public Dialog getDialog(Context context) &#123; ProgressDialog progressDialog = new ProgressDialog(context, PROGRESS_THEME); progressDialog.setMessage(message); return progressDialog; &#125; &#125;, cancelable, cancelListener); dialogFragment.show(fragmentManager, PROGRESS_TAG); return dialogFragment;&#125; 我们先调用了 CommonDialogFragment 的构造函数，将一个 ProgressDialog 传进去，然后依次传入 cancelable 和 cancelListener，最后调用 show() 函数，将 DialogFragment 显示出来，因为我们使用了构造函数的重载，可以看到最简单的构造函数只需要传入两个参数就行了，是不是相当的简洁啊。 应该还没忘了我们上面创建了一个 IDialogResultListener 用于 DialogFragment 与逻辑层之间进行数据监听吧，为了能传入各种各样类型的数据，这里我使用了 泛型 来进行处理，就以 带输入框的弹出窗 为例来看看究竟要怎么使用吧 123456789101112131415161718192021222324public static void showInsertDialog(FragmentManager manager, final String title, final IDialogResultListener&lt;String&gt; resultListener, final boolean cancelable)&#123; CommonDialogFragment dialogFragment = CommonDialogFragment.newInstance(new CommonDialogFragment.OnCallDialog() &#123; @Override public Dialog getDialog(Context context) &#123; // ... 这里省略一部分代码 AlertDialog.Builder builder = new AlertDialog.Builder(context, INSERT_THEME); builder.setPositiveButton(DIALOG_POSITIVE, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; if(resultListener != null)&#123; resultListener.onDataResult(editText.getText().toString()); &#125; &#125; &#125;); builder.setNegativeButton(DIALOG_NEGATIVE, null); return builder.create(); &#125; &#125;, cancelable, null); dialogFragment.show(manager, INSERT_TAG);&#125; 可以看到我们在 showInsertDialog() 方法中传入了IDialogResultListener resultListener，当我们想要处理输入的内容的时候，只要在外部调用的时候，new 一个 IDialogResultListener 传进去，然后实现 onDataResult() 方法就行了 DialogFragmentDemos]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Fragment懒加载]]></title>
      <url>%2F2017%2F09%2F18%2Fandroid-fragment-lazy%2F</url>
      <content type="text"><![CDATA[生命周期附上生命周期，帮助下面的学习。 何为懒加载Fragment 的 UI 对用户可见时才加载数据 为什么需要 需求要求，我们一般是等数据加载完毕之后才会初始化UI，但是可能需求会先让UI显示，再加载数据 与ViewPager搭配使用的时候，ViewPager有缓存机制，比如三个页面，0,1,2，当我们处于1页面的时候0,2也都会加载好，如果数据量较大的话，体验会很差 实现原理核心的点是判断UI的可见，Fragment提供了一个setUserVisibleHint(boolean isVisibleToUser)方法可以用来判断； setUserVisibleHint方法 单个 Fragment，setUserVisibleHint 是不会被调用的，只有该 Fragment 在 ViewPager 里才会被调用 执行顺序：setUserVisibleHint 方法在Fragment的生命周期函数之前执行一次，此时isVisibleToUser是false，后续还会执行一次，此时isVisibleToUser是true，但是这次的时间是不确定的 。参考官方note说明 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class FriendFragment extends Fragment &#123; private boolean isVisible; // 标志位，标志已经初始化完成，防止空指针的异常 private boolean isViewCreated; public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)&#123; super.onCreateView(inflater, container, savedInstanceState); isViewCreated = true; View chatView = inflater.inflate(R.layout.activity_tab_friend, container,false); return chatView; &#125; @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); Log.e("hhp", "setUserVisibleHint: isVisibleToUser--"+isVisibleToUser+"---isViewCreated---"+isViewCreated ); if (isVisibleToUser &amp;&amp; isViewCreated) &#123; isVisible = true; lazyLoad(); &#125;else &#123; isVisible = false; &#125; &#125; private void lazyLoad() &#123; if (!isVisible || !isViewCreated) &#123; return; &#125; getData(); &#125; private void getData() &#123; //加载数据 &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if (getUserVisibleHint()) &#123; getData(); &#125; &#125;&#125; 几点说明分析两种情况： 1.进来就加载的这个Fragment，此时isVisibleToUser 和isViewCreated 两个标志位的值如下 ，无法加载数据 ，所以需要在onActivityCreated方法中调用加载数据 2.进来加载的不是这个Fragment，当该Fragment被缓存的时候，调用onActivityCreated方法getUserVisibleHint()值是false，不调用getData()方法；同理，isVisibleToUser和isViewCreated也是false，也不会调用getData()方法；滑动到该Fragment的时候，onActivityCreated方法不会再次执行，isVisibleToUser和isViewCreated都变为true，调用getData()方法加载数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[程序员开源协议]]></title>
      <url>%2F2017%2F09%2F18%2Fprogram-software-license%2F</url>
      <content type="text"><![CDATA[自由软件自由软件是一种可以不受限制地自由使用、复制、研究、修改和分发的软件。注意，自由并不代表着免费。正是这种开放、开源的精神，计算机软件才得以如此飞快地发展。 开源协议为保护自由软件原作者的相关知识产权，在作者与用户之间设立的一种虚拟合同，或者称之为授权方式。其中的条款内容，就是用来限制软件使用者的使用方式等。他人如有违反协议，作者有权利发起诉讼，维护自身权益。 开源届定义有几百种不同的开源协议，宽松程度不一，用以满足开源项目的各种使用场景。比如，是否允许商用，是否允许修改，修改后是否需要继续开源，开源是否必须继续使用相同协议授权等。 不过，作为普通用户，无论你是作为开源作者造轮子，还是作为普通用户借轮子，我们只需要知道比较流行的那几种，并能够加以区分即可。否则，上百种协议真要细分的话，绝非易事。 早期一名乌克兰程序员画有一张分析图，简单明了地描述出六种流行开源协议的使用区分。阮一峰老师翻译如下： 更简单点的话，也可以参考这张图，更加通俗易懂： 更多的开源协议，我们还可以参考这张图（目前只发现英文版）： 至于使用的话，不妨借助 GcsSloop 制作的开源协议网站： choosealicense.online 如图所示： 选择所需要的协议，一键复制即可。 说完这些，回过头来想想，估计很多人都会有疑惑：开源协议与我何干？但是，作为一名程序员，开源协议还真与你我关系紧密。 如果你是 GitHub 重度依赖者，如果你稍作留意，不难发现，基本上出名的开源项目根目录中都有一个协议文件：LICENSE.txt，而在 README.me 说明文件底部伴随着 License 内容。这就是你需要留意的地方，使用任意开源项目之前，记得阅读一下该项目的开源协议。 市场上部分 App 也会在应用中增加第三方开源项目时的使用版权说明，比如支付宝安卓版。这也是一种查看优秀 App 都使用哪些开源项目的途径之一。 如果你也是一个作者，准备开源自己的项目时，那就更得注意，想想自己需要选择哪一个开源协议更加合适。比如，大名鼎鼎的 Linux 系统采用便是 GPL 协议；作为安卓程序员，我们当然知道，我们赖以生存的 Android 开源系统，其内核采用的就是 Linux 内核。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Gradle使用总结]]></title>
      <url>%2F2017%2F09%2F11%2Fandroid-gradle%2F</url>
      <content type="text"><![CDATA[Android GradleAndroid项目使用 Gradle 作为构建框架，Gradle 又是以Groovy为脚本语言。所以学习Gradle之前需要先熟悉Groovy脚本语言。 Groovy是基于Java语言的脚本语言，所以它的语法和Java非常相似，但是具有比java更好的灵活性。下面就列举一些和Java的主要区别。 Android Gradle 的 Project 和 Tasks这个Gradle中最重要的两个概念。每次构建（build）至少由一个project构成，一个project 由一到多个task构成。项目结构中的每个build.gradle文件代表一个project，在这编译脚本文件中可以定义一系列的task；task 本质上又是由一组被顺序执行的Action`对象构成，Action其实是一段代码块，类似于Java中的方法。 Android Gradle 构建生命周期每次构建的执行本质上执行一系列的Task。某些Task可能依赖其他Task。哪些没有依赖的Task总会被最先执行，而且每个Task只会被执行一遍。每次构建的依赖关系是在构建的配置阶段确定的。每次构建分为3个阶段： Initialization: 初始化阶段 这是创建Project阶段，构建工具根据每个build.gradle文件创建出一个Project实例。初始化阶段会执行项目根目录下的settings.gradle文件，来分析哪些项目参与构建。 所以这个文件里面的内容经常是： 12include &apos;:app&apos;include &apos;:libraries:someProject&apos; 这是告诉Gradle这些项目需要编译，所以我们引入一些开源的项目的时候，需要在这里填上对应的项目名称，来告诉Gradle这些项目需要参与构建。 Configuration:配置阶段 这个阶段，通过执行构建脚本来为每个project创建并配置Task。配置阶段会去加载所有参与构建的项目的build.gradle文件，会将每个build.gradle文件实例化为一个Gradle的project对象。然后分析project之间的依赖关系，下载依赖文件，分析project下的task之间的依赖关系。 Execution:执行阶段 这是Task真正被执行的阶段，Gradle会根据依赖关系决定哪些Task需要被执行，以及执行的先后顺序。task是Gradle中的最小执行单元，我们所有的构建，编译，打包，debug，test等都是执行了某一个task，一个project可以有多个task，task之间可以互相依赖。例如我有两个task，taskA和taskB，指定taskA依赖taskB，然后执行taskA，这时会先去执行taskB，taskB执行完毕后在执行taskA。 说到这可能会有疑问，我翻遍了build.gradle也没看见一个task长啥样，有一种被欺骗的赶脚！ 其实不是，你点击AndroidStudio右侧的一个Gradle按钮，会打开一个面板，内容差不多是这样的： 里面的每一个条目都是一个task，那这些task是哪来的呢？ 一个是根目录下的 build.gradle 中的 123dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.2.2&apos;&#125; 一个是 app 目录下的 build.gradle 中的 apply plugin: &#39;com.android.application&#39; 这两段代码决定的。也就是说，Gradle提供了一个框架，这个框架有一些运行的机制可以让你完成编译，但是至于怎么编译是由插件决定的。还好Google已经给我们写好了Android对应的Gradle工具，我们使用就可以了。 根目录下的build.gradle中dependencies {classpath ‘com.android.tools.build:gradle:2.2.2’}是Android Gradle编译插件的版本。 app目录下的build.gradle中的apply plugin: ‘com.android.application’是引入了Android的应用构建项目，还有com.android.library和com.android.test用来构建library和测试。 所有Android构建需要执行的task都封装在工具里，如果你有一些特殊需求的话，也可以自己写一些task。那么对于开发一个Android应用来说，最关键的部分就是如何来用AndroidGradle的插件了。 认知Gradle WrapperAndroid Studio中默认会使用 Gradle Wrapper 而不是直接使用Gradle。命令也是使用gradlew而不是gradle。这是因为gradle针对特定的开发环境的构建脚本，新的gradle可能不能兼容旧版的构建环境。为了解决这个问题，使用Gradle Wrapper 来间接使用 gradle。相当于在外边包裹了一个中间层。对开发者来说，直接使用Gradlew 即可，不需要关心 gradle的版本变化。Gradle Wrapper 会负责下载合适的的gradle版本来构建项目。 Android 三个文件重要的 gradle 文件Gradle项目有3个重要的文件需要深入理解：项目根目录的 build.gradle , settings.gradle 和模块目录的 build.gradle 。 1.settings.gradle 文件会在构建的 initialization 阶段被执行，它用于告诉构建系统哪些模块需要包含到构建过程中。对于单模块项目， settings.gradle 文件不是必需的。对于多模块项目，如果没有该文件，构建系统就不能知道该用到哪些模块。 2.项目根目录的 build.gradle 文件用来配置针对所有模块的一些属性。它默认包含2个代码块：buildscript{…}和allprojects{…}。前者用于配置构建脚本所用到的代码库和依赖关系，后者用于定义所有模块需要用到的一些公共属性。 123456789101112131415161718buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.2&apos; &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125; buildscript：定义了 Android 编译工具的类路径。repositories中, jCenter是一个著名的 Maven 仓库。 allprojects:中定义的属性会被应用到所有 moudle 中，但是为了保证每个项目的独立性，我们一般不会在这里面操作太多共有的东西。 3.模块级配置文件 build.gradle 针对每个moudle 的配置，如果这里的定义的选项和顶层 build.gradle定义的相同。它有3个重要的代码块：plugin，android 和 dependencies。 定制项目属性（project properties)在项目根目录的build.gradle配置文件中，我们可以定制适用于所有模块的属性，通过ext 代码块来实现。如下所示： 1234ext &#123; compileSdkVersion = 22 buildToolsVersion = &quot;22.0.1&quot;&#125; 然后我们可以在模块目录的build.gradle配置文件中引用这些属性,引用语法为rootProject.ext.{属性名}。如下： 1234android &#123; compileSdkVersion rootProject.ext.compileSdkVersion buildToolsVersion rootProject.ext.buildToolsVersion&#125; Android studio gradle Task 123456789101112131415161718192021222324//构建gradlew app:clean //移除所有的编译输出文件，比如apkgradlew app:build //构建 app module ，构建任务，相当于同时执行了check任务和assemble任务//检测gradlew app:check //执行lint检测编译。//打包gradlew app:assemble //可以编译出release包和debug包，可以使用gradlew assembleRelease或者gradlew assembleDebug来单独编译一种包gradlew app:assembleRelease //app module 打 release 包gradlew app:assembleDebug //app module 打 debug 包//安装，卸载gradlew app:installDebug //安装 app 的 debug 包到手机上gradlew app:uninstallDebug //卸载手机上 app 的 debug 包gradlew app:uninstallRelease //卸载手机上 app 的 release 包gradlew app:uninstallAll //卸载手机上所有 app 的包 这些都是基本的命令，在实际项目中会根据不同的配置，会对这些task 设置不同的依赖。比如 默认的 assmeble 会依赖 assembleDebug 和assembleRelease，如果直接执行assmeble，最后会编译debug，和release 的所有版本出来。如果我们只需要编译debug 版本，我们可以运行assembleDebug。 除此之外还有一些常用的新增的其他命令，比如 install命令，会将编译后的apk 安装到连接的设备。 lint 检测 忽略编译器的 lint 检查 123456android &#123; lintOptions &#123; abortOnError false &#125;&#125; buildTypes 定义了编译类型12345678910111213android&#123; buildTypes &#123; release &#123; minifyEnabled true //打开混淆 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; debug &#123; minifyEnabled false //关闭混淆 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125; productFlavors 多渠道打包AndroidManifest.xml 里设置动态渠道变量 123456&lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;$&#123;UMENG_CHANNEL_VALUE&#125;&quot; /&gt;``` 在 build.gradle 设置 productFlavors , 这里假定我们需要打包的渠道为酷安市场、360、小米、百度、豌豆荚。 android { productFlavors { kuan { manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;kuan&quot;] } xiaomi { manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;xiaomi&quot;] } qh360 { manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;qh360&quot;] } baidu { manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;baidu&quot;] } wandoujia { manifestPlaceholders = [UMENG_CHANNEL_VALUE: &quot;wandoujia&quot;] } } }12或者批量修改 android { productFlavors { kuan {} xiaomi {} qh360 {} baidu {} wandoujia {} } productFlavors.all { flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } }123456这样在打包的时候就可以选择渠道了![20171028150920602392842.png](http://ohtrrgyyd.bkt.clouddn.com/20171028150920602392842.png)或者用命令打包 ，比如： gradlew assembleWandoujiaRelease //豌豆荚 release 包 gradlew assembleWandoujiaDebug //豌豆荚 debug 包1234# 多渠道设置包名有时候我们需要分渠道设置 applicationId 、友盟的 appkey 、友盟渠道号。 productFlavors { google { applicationId “com.wifi.cool” manifestPlaceholders = [ UMENG_APPKEY_VALUE : “456789456789”, UMENG_CHANNEL_VALUE: “google”, ] } baidu{ applicationId &apos;com.wifi.hacker&apos; manifestPlaceholders = [ UMENG_APPKEY_VALUE : &quot;123456789789&quot;, UMENG_CHANNEL_VALUE : &quot;baidu&quot;, ] } }1234# Signing 签名在 android 标签下添加 signingConfigs 标签，如下： android { signingConfigs { config { keyAlias ‘yiba’ keyPassword ‘123456’ storeFile file(‘C:/work/Key.jks’) storePassword ‘1234567’ } }}12可以在 release 和 debug 包中定义签名，如下： android { signingConfigs { config { keyAlias ‘yiba’ keyPassword ‘123456’ storeFile file(‘C:/work/Key.jks’) storePassword ‘1234567’ } } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.config } debug { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.config } } }1234567891011121314151617# 依赖管理## 依赖 jcenter 包每个库名称包含三个元素：组名:库名称:版本号`compile &apos;com.android.support:appcompat-v7:25.0.0&apos;`## 依赖本地 module`compile project(&apos;:YibaAnalytics&apos;)`## 依赖 jar 包- 把 jar 包放在 libs 目录下- 在 build.gradle 中添加依赖 dependencies { compile files(‘libs/YibaAnalytics5.jar’)}1234567![20171028150920619455522.png](http://ohtrrgyyd.bkt.clouddn.com/20171028150920619455522.png)## 依赖 aar 包- 把 aar 包放到 libs 目录下- 在 build.gradle 中添加依赖 repositories { flatDir { dirs ‘libs’ }} dependencies { compile(name:’YibaAnalytics-release’, ext:’aar’)}123456789101112如图所示：![20171028150920622394032.png](http://ohtrrgyyd.bkt.clouddn.com/20171028150920622394032.png)- 自定义依赖包目录当我们的 aar 包需要被多个 module 依赖时，我们就不能把 aar 包放在单一的 module 中，我们可以在项目的根目录创建一个目录，比如叫 aar 目录，然后把我们的 aar 包放进去，如图所示：![20171028150920623519197.png](http://ohtrrgyyd.bkt.clouddn.com/20171028150920623519197.png)在项目的根目录的 build.gradle 的 allprojects 标签下的 repositories 添加 ： flatDir { dirs ‘../aar’}123456789101112131415161718192021222324252627282930../aar 表示根目录下的 aar 文件夹。如图所示：![20171028150920625348073.png](http://ohtrrgyyd.bkt.clouddn.com/20171028150920625348073.png)然后就可以添加依赖了，如下所示：`compile(name:&apos;YibaAnalytics-release&apos;, ext:&apos;aar&apos;)`## 依赖配置有些时候，你可能需要和sdk协调工作。为了能顺利编译你的代码，你需要添加SDK到你的编译环境。你不需要将sdk包含在你的APK中，因为它早已经存在于设备中，所以配置来啦，我们会有5个不同的配置：- compile- apk- provided- testCompile- androidTestCompilecompile是默认的那个，其含义是包含所有的依赖包，即在APK里，compile的依赖会存在。apk的意思是apk中存在，但是不会加入编译中，这个貌似用的比较少。provided的意思是提供编译支持，但是不会写入apk。## 排除依赖兼容包有时候我们在引入依赖包的时候，会额外的引入 v7, v4 的包，对我们的项目造成额外的负担，我们需要把这个兼容包排除，可以使用 exclude 就能做到。 compile(‘com.google.firebase:firebase-ads:11.0.4’, { exclude group: ‘com.android.support’ //排除v7 , v4 包})123456789101112131415161718# native包（so包）用c或者c++写的library会被叫做so包，Android插件默认情况下支持native包，你需要把.so文件放在对应的文件夹中：![20171028150920630815374.png](http://ohtrrgyyd.bkt.clouddn.com/20171028150920630815374.png)**注意**jniLibs 目录应该和 Java 目录在同一级# defaultConfig 详解defaultConfig 对应的是 ProductFlavor 类。# resConfigs ： 过滤语言如果你的app中仅支持1,2种语言，但是可能引用的lib库包含多种其他语言的strings资源，这个时候我们可以通过resConfig指定我们需要的strings资源。 android { defaultConfig { applicationId &quot;com.yiba.sharewe.lite.activity&quot; minSdkVersion 14 targetSdkVersion 24 versionCode 46 versionName &quot;1.74&quot; resConfigs &apos;en&apos;, &apos;zh-rCN&apos; ,&apos;es&apos; //本次打包，只把 en(英文)、zh-rCN(中文简体)、es（西班牙语）打进保内，其他语言忽略 } }12345678# resConfigs ： 过滤 drawable文件夹的资源一般情况下，我们打完包，res 下面的资源如图所示：![20171028150920635182429.png](http://ohtrrgyyd.bkt.clouddn.com/20171028150920635182429.png)现在加上资源过滤规则： android { defaultConfig { applicationId “com.wifi.analytics” minSdkVersion 9 targetSdkVersion 25 versionCode 1 versionName “1.0” resConfigs “hdpi” //打包的时候只保留 drawable-xhdpi 文件夹里面的资源 }}1234567891011121314这次我们打包效果如下：![20171028150920637414691.png](http://ohtrrgyyd.bkt.clouddn.com/20171028150920637414691.png)# buildTypes 详解[官方文档](http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.BuildType.html)buildTypes&#123;&#125;对应的是 BuildType 类**继承关系**BuildType 继承 DefaultBuildType ； DefaultBuildType 继承 BaseConfigImpl ； BaseConfigImpl — DefaultBuildType — BuildType12**buildTypes的属性**： name：build type的名字 applicationIdSuffix：应用id后缀 versionNameSuffix：版本名称后缀 debuggable：是否生成一个debug的apk minifyEnabled：是否混淆 proguardFiles：混淆文件 signingConfig：签名配置 manifestPlaceholders：清单占位符 shrinkResources：是否去除未利用的资源，默认false，表示不去除。 zipAlignEnable：是否使用zipalign工具压缩。 multiDexEnabled：是否拆成多个Dex multiDexKeepFile：指定文本文件编译进主Dex文件中 multiDexKeepProguard：指定混淆文件编译进主Dex文件中12**buildType的方法**： 1.buildConfigField(type,name,value)：添加一个变量生成BuildConfig类。 2.consumeProguardFile(proguardFile)：添加一个混淆文件进arr包。 3.consumeProguardFile(proguardFiles)：添加混淆文件进arr包。 4.externalNativeBuild(action)：配置本地的build选项。 5.initWith：复制这个build类型的所有属性。 6.proguardFile(proguardFile)：添加一个新的混淆配置文件。 7.proguradFiles(files):添加新的混淆文件 8.resValue(type,name,value)：添加一个新的生成资源 9.setProguardFiles(proguardFileIterable):设置一个混淆配置文件。12# initWith ：复制属性 android { compileSdkVersion 25 buildToolsVersion “25.0.2” defaultConfig { applicationId “com.wifi.analytics” minSdkVersion 9 targetSdkVersion 25 versionCode 1 versionName “1.0” } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’ } debug { minifyEnabled false proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’ } myType { initWith debug //完全复制 debug 的所有属性‘ minifyEnabled true //自定义打开混淆 } } }12# applicationIdSuffix 、versionNameSuffix ：添加后缀 android { compileSdkVersion 25 buildToolsVersion “25.0.2” defaultConfig { applicationId “com.wifi.analytics” minSdkVersion 9 targetSdkVersion 25 versionCode 1 versionName “1.0” } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’ } debug { minifyEnabled false proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’ applicationIdSuffix “zhao” //applicationId 追加后缀名 zhao versionNameSuffix “debug” //versionName 追加后缀名 debug1.0 } }}12345678效果图，如下：![20171029150920649886369.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920649886369.png)# buildConfigField： 自定义属性在 build.gradle 文件中定义 buildConfigField 属性 android { buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; buildConfigField &quot;String&quot;, &quot;API_ENV&quot;, &quot;\&quot;http://yiba.com\&quot;&quot; //自定义String属性 } debug { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; buildConfigField &quot;String&quot;, &quot;API_ENV&quot;, &quot;\&quot;http://yiba.com\&quot;&quot; //自定义String属性 } } }123456789101112然后点击同步按钮，然后就可以在 build 目录看到 debug 和 release 信息。debug 环境下的 BuildConfig 如下： ![20171029150920652322417.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920652322417.png)release 环境下的 BuildConfig 如下：![20171029150920653292275.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920653292275.png)当然我们也可以在代码中获取自定义的值： //获取变量值String API = BuildConfig.API_ENV ;12上面演示了自定义 String 变量，也可以 自定义 int 、boolean android { buildTypes { debug { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; buildConfigField &quot;String&quot;, &quot;API_ENV&quot;, &quot;\&quot;http://www.baidu.com\&quot;&quot; //自定义 String 值 buildConfigField &quot;Boolean&quot;, &quot;openLog&quot;, &quot;true&quot; //自定义 boolean 值 buildConfigField &quot;int&quot;, &quot;age&quot;, &quot;10&quot; //自定义 int 值 } } }12345678910# Gradle 实现差异化构建## 情景1LeakCanary 是 square 公司出品的一个检测内存泄漏的开源库。GitHub ： [https://github.com/square/leakcanary](https://github.com/square/leakcanary)我们一般这样集成 dependencies { compile ‘com.squareup.leakcanary:leakcanary-android:1.5.2’}12然后我们在 Application 类中初始化： public class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); LeakCanary.install(this); } }12但是这样集成有一个弊端，就是 debug 和 release 包都会把 LeakCanary 的源码打进去，如果我们在 release 包中不把 LeakCanary 源码打进去，怎么办？ 还好 LeakCanary 给我们提供了一个方法，方法如下： dependencies { //打 debug 包 debugCompile ‘com.squareup.leakcanary:leakcanary-android:1.5.1’ //打 release 包 releaseCompile ‘com.squareup.leakcanary:leakcanary-android-no-op:1.5.1’ }12345678910leakcanary-android-no-op 是一个空壳，里面有2个空类，所以就可以避免把 LeakCanary 源码打进 release 包。但是这种方式有个缺陷，如果一些开源库没有提供 releaseCompile 库，那我们改怎么办了？下面的情景2 就会讲到解决方案。## 情景2Stetho 是 Faceboo k开源的Andorid调试工具。当你的应用集成Stetho时，开发者可以访问Chrome，在Chrome Developer Tools中查看应用布局，网络请求，sqlite，preference 等等。官网：[http://facebook.github.io/stetho/](http://facebook.github.io/stetho/)从官网可以看到 stetho 没有提供 releaseCompile 包 ， 情景1 的方案就不能用了。新的思路集成方案如下： dependencies { debugCompile ‘com.facebook.stetho:stetho:1.5.0’}123456在 src 目录下创建 debug 目录、release 目录 ，然后分别在 debug 目录 和 release 目录 创建 java 目录 ， 在 java 目录中创建包名，比如： com.app , 如下图所示：![20171029150920663742117.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920663742117.png)debug 目录下创建 SDKManage 类 ，如下 ： public class SDKManager { public static void init(Context context) { //初始化 Stetho Stetho.initializeWithDefaults(context); } }12release 目录下创建 SDKManage 类 ，如下 ： public class SDKManager { public static void init(Context context) { //这是一个空方法，目的是不引入 Stetho 源码 } }12在住项目中的 MyApplication 类，并且完成 Stetho 的初始化，如下： public class MyApplication extends Application { @Override public void onCreate() { super.onCreate(); SDKManager.init(this); } }1234567891011121314151617181920这样我们便完成了简单的差异化构建, 打出来的 release 包就没有 Stetho 源码。# SourceSet## SourceSet 简介SourceSet 可以定义项目结构，也可以修改项目结构。Java插件默认实现了两个SourceSet，main 和 test。每个 SourceSet 都提供了一系列的属性，通过这些属性，可以定义该 SourceSet 所包含的源文件。比如，java.srcDirs，resources.srcDirs 。Java 插件中定义的其他任务，就根据 main 和 test 的这两个 SourceSet 的定义来寻找产品代码和测试代码等。## SourceSet 定义源码目录在 Android 项目中，我们可以在 src/main/java 目录新建 Java 文件，如下图所示：![20171029150920668425492.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920668425492.png)现在我们在 src 目录下，新建 test1 目录 ，发现不能在 test1 目录中新建 Java 文件，如下图所示：![20171029150920669347940.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920669347940.png)为什么在 test1 目录不能新建 Java 文件，因为 Gradle 中 SourceSet 默认定义的源码文件路径是src/main/java , 其他的文件下下面的源码我们自然无法访问。解决这个问题也很简单，我们需要在 SourceSet 中增加一个源码路径即可。如下所示： android { sourceSets { main { java { srcDir &apos;src/test1&apos; //指定源码目录 } } } }123456然后同步一下，就可以在 test1 目录中新建 Java 文件了。如下图所示：![20171029150920675182396.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920675182396.png)当然我们也可以同时指定多个源码目录，比如同时指定 test1 , test2 , test3 为源码目录。 android { sourceSets { main { java { srcDir &apos;src/test1&apos; //指定 test1 为源码目录 srcDir &apos;src/test2&apos; //指定 test2 为源码目录 srcDir &apos;src/test3&apos; //指定 test3 为源码目录 } } } }12或者 这样写 ： android { sourceSets { main { java.srcDirs( ‘src/test1’ , ‘src/test2’ ,’src/test3’ ) } }}12345678910效果如下图所示：![20171029150920677817619.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920677817619.png)## SourceSet 定义资源目录定义 test1 目录 Java 源代码路径、res 资源目录。目录结构如下图所示：![20171029150920679824349.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920679824349.png) android { sourceSets { main { java.srcDirs(&apos;src/test1/java&apos;) //定义java 源代码 res.srcDirs(&apos;src/test1/res&apos;) //定义资源目录（layout , drawable,values） } } }12345678910111213141516171819202122## SourceSet 实现 layout 分包对于一个大项目来说，页面太多，布局文件就很多，有时在众多布局文件中找某个模块的布局文件，很是痛苦，为了解决这个问题，我们可以在创建多个 layout 目录，不同模块的布局文件放在不同的 layout 目录中，这样查找起来，就容易很多。例子：比如我们的项目中，有两个模块分别为：登录、注册。- 第一步：把项目中 layout 文件夹改名字为 layouts- 第二步：在 layouts 目录下，分别创建 login 、register 目录 。- 第三步：分别在 login 、register 目录下创建 layout 目录。注意这一步是必须的，否则会报错。- 第四步：把 登录布局文件、注册布局文件 分别放在 第三步创建的对应的 layout 目录下。效果图如下：![20171029150920685572520.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920685572520.png)SourceSet 实现如下： android { sourceSets { main { res.srcDirs &apos;src/main/res/layouts/login&apos; //定义登录布局目录 res.srcDirs &apos;src/main/res/layouts/register&apos; //定义注册布局目录 } } }12345678## SourceSet 定义 AndroidManifest 文件指定 test1 目录下的 AndroidManifest 文件。项目结构如下图所示：![20171029150920687997782.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920687997782.png)代码如下： android { sourceSets { main { manifest.srcFile &apos;src/test1/AndroidManifest.xml&apos; } } }12在组件化开发中, 我们需要针对 debug 与 release 模式下, 指定不同的 Manifest 文件, 代码如下： android { def appDebug = false; buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; appDebug = false; } debug { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; appDebug = false; } } sourceSets { main { if (appDebug) { manifest.srcFile &apos;src/test1/AndroidManifest.xml&apos; } else { manifest.srcFile &apos;src/main/AndroidManifest.xml&apos; } } } }123456789101112## SourceSet 定义 assets 目录Android Studio 项目目录中，assets 默认目录如下：![20171029150920691136995.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920691136995.png)如何重新定义 assets 目录 。在项目的根目录下创建 assets 目录，如下图所示：![20171029150920691863996.png](http://ohtrrgyyd.bkt.clouddn.com/20171029150920691863996.png)sourceSets 定义代码如下： android { sourceSets { main { assets.srcDirs = [&apos;assets&apos;] } } }12## SourceSet 定义其他资源 android { sourceSets { main { jniLibs.srcDirs //定义 jni 目录 aidl.srcDirs //定义 aidl 目录 } } }123456# applicationVariants## 定义 versionName 、VersionCode在打包的时候分 debug 、release 版本 , 需要控制 versionName android { applicationVariants.all { variant -&gt; def flavor = variant.mergedFlavor def versionName = flavor.versionName if (variant.buildType.isDebuggable()) { versionName += &quot;_debug&quot; //debug 名字 } else { versionName += &quot;_release&quot; //release 名字 } flavor.versionName = versionName } }12## 定义 APK 包的名字 apply plugin: ‘com.android.application’ android { defaultConfig { applicationId &quot;android.plugin&quot; minSdkVersion 14 targetSdkVersion 25 versionCode 1 versionName &quot;1.0&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } debug { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } //定义渠道 productFlavors { xiaomi { //小米 } wandoujia { // 豌豆荚 } } //打包命名 applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; //定义一个新的apk 名字。 // 新名字 = app 名字+ 渠道号 + 构建类型 + 版本号 + 当前构建时间 def apkName = &quot;appName_${variant.flavorName}_${buildType.name}_v${variant.versionName}_${getTime()}.apk&quot;; output.outputFile = new File(output.outputFile.parent, apkName); } } } //获取当前时间def getTime() { String today = new Date().format(‘YY年MM月dd日HH时mm分’) return today}12345678效果图如下：![2017102915092069934597.png](http://ohtrrgyyd.bkt.clouddn.com/2017102915092069934597.png)# Task## 定义 task //定义任务1task task1&lt;&lt;{ println ‘task1’} //定义任务2task task2&lt;&lt;{ println ‘task2’}12## mustRunAfter 定义 task 执行顺序 //task2 的执行顺讯在 task1 之后task2.mustRunAfter task11234- 测试1 ： gradlew task1 效果如下： :app:task1task11234- 测试2 ： gradlew task2 效果如下： :app:task2task21234- 测试3 ： gradlew task1 task2 效果如下： :app:task1task1:app:task2task21234- 测试4 ： gradlew task2 task1 效果如下： :app:task1task1:app:task2task212345678910111213## 结论如果单独执行 task1 就只会执行 task1 的任务；单独执行 task2 就只会执行 task2 的任务； 如果同时执行 task1、task2 , 一定会先执行 task1 , 等 task1 执行完后，就会执行 task2 内容。## 扩展上面 mustRunAfter 我们还有一种写法，如下图所示：`task2 &#123;&#125;.mustRunAfter task1`这个写法的效果和 mustRunAfter 是一样的，当然我们还可以在 花括号里面写一些任务，比如 ： task2 { println ‘我最先执行’}.mustRunAfter task1123456下面做个测试，测试命令如下：`gradlew task2 task1`效果如下： 我最先执行 :app:task1task1:app:task2task2123456789101112## dependsOn 定义 task 依赖task2 任务依赖于 task1 ,执行 task2 就会先执行 task1`task2.dependsOn task1`测试：`gradlew task2`效果如下： :app:task1task1:app:task2task2123456# 常用 Gradlew 命令- 1、gradlew -v : 查看版本号 Gradle 3.3Build time: 2017-01-03 15:31:04 UTCRevision: 075893a3d0798c0c1f322899b41ceca82e4e134b Groovy: 2.4.7Ant: Apache Ant(TM) version 1.9.6 compiled on June 29 2015JVM: 1.8.0_112 (Oracle Corporation 25.112-b15)OS: Windows 10 10.0 amd64``` 2、gradlew task ： 查看所有的 task 参考资料Android 利用Gradle实现差异化构建 杨海 Android目录结构]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android App性能优化全方面解析]]></title>
      <url>%2F2017%2F09%2F04%2Fandroid-performance-optimize%2F</url>
      <content type="text"><![CDATA[内存优化关于性能优化我们可以不知道其他的，但一定要知道内存优化。因为内存泄漏可以Android的常客。那么什么是内存泄漏呢？内存不在GC的掌控范围之内了。那么java的GC内存回收机制是什么？某对象不在有任何引用的时候才会进行回收。那么GC回收机制的原理是什么？又或者说可以作为GC Root引用点的是啥？或许有人听不懂我在讲啥。我们先来看张图。 当我们向上寻找，一直寻找到GC Root的时候，此对象不会进行回收，例如，一个Activity。那么如果我们向上寻找，直到找到GC Root对象的时候，就说明它是不可以回收的，例如，我定义了一个int a；但是这个数据，我整个页面或者说整个项目都没有用到，则这个对象会被GC掉。 GC的引用点 java栈中引用的对象 方法静态引用的对象 方法常量引用的对象 Native中JNI引用的对象 Thread——“活着的”线程 如何判断那么我们如何判断一个对象是一个垃圾对象，可以讲他进行回收呢？举了小例子教你们如何区分： 一般在学校吃饭，我们有两种情况，第一：吃完饭就直接走人，碗筷留给阿姨来收拾处理。第二：吃完之后把碗筷放到收盘处直接进行回收。但我们是个有素质的人，一般采用第二种情况，但根据想法，我们更倾向于第一种。那么一般在饭店或者KFC中，都是第一种情况。那么此时，问题来了，如果我已经吃完饭，然后我并没有离开饭店，做在位置上和朋友吹吹牛逼，谈谈理想，聊聊人生。那么桌上那一堆碗筷是收还是不收？讲道理是不能收的。虽然实际也是不能收的。因为顾客是上帝123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316So，我们如何判断一个对象是一个可回收的垃圾对象呢？这是我们的一个主观的判断。但是有种情况我们是必须要考虑到的，没错，就是内存过多无法释放的时候，会直接导致OOM。整个项目boom炸了。什么鬼？outofmemory。没错就是它。# 内存溢出## 分析原因我们需要分析内存溢出的原因，我们先来看一张图： ![20171031150938126840752.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938126840752.png) 内存泄漏一般导致应用卡顿，极端情况会导致项目boom。Boom的原因是因为超过内存的阈值。 原因主要有两方面：- 代码存在泄漏，内存无法及时释放导致oom（这个我们后面说）- 一些逻辑消耗了大量内存，无法及时释放或者超过导致oom所谓消耗大量的内存的，绝大多数是因为图片加载。这是我们oom出现最频繁的地方。我前面有写过图片加载的方法，一个是控制每次加载的数量，第二，保证每次滑动的时候不进行加载，滑动完进行加载。一般情况使用先进后出，而不是先进先出。不过一般我们图片加载都是使用fresco或者Glide等开源库。 我们来看下下面两张图： ![20171031150938130233770.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938130233770.png)![20171031150938131538861.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938131538861.png)对比两张图，我们可以在第一张的情况出现了oom情况，我们通过log打印发现，处理的好像没什么问题，换句话说，如果我不放那0.8M的图片。然后继续不停的操作同样会出现OOM，然而我们就蒙了。没什么图片加载怎么就这么崩掉了。## 如何查看首先，我们确定我们项目或者某几个类里面是否存在内存溢出的问题。我们可以通过如下方法：- Android–&gt;System Information–&gt;MemoryUsage查看Object里面是否有没有被释放的Views和Activity- 命令行模式：adb shell dumpsys meminfo 包名 -d就那我公司的项目举例把。首先，我们在这边可以看到memory。CPU和net的使用情况。 ![20171031150938135867093.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938135867093.png)我们找到Object。看看我们内存的消耗情况。 ![20171031150938138041717.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938138041717.png)随便这么一看，尼玛蛋，1300左右的view和一个Activity。还有3个context。可怕。。可以理解为一个Activity里面使用了将近1300个view。。。想都不敢想。。。我们可以通过看Memory Monitor工具。 检查一个一个的动作。（比如Activity的跳转）。反复多次执行某一个操作，不断的通过这个工具查看内存的大概变化情况。 前后两个内存变化增加了不少。我们可以更仔细的查找泄漏的位置，在AS里面使用 Heap SnapShot工具（堆栈快照）。如图所示： ![20171031150938142116483.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938142116483.png)我们点击后，他会进行一段时间的监控，然后会生成一个文件。我们点击我们package tree view。 ![20171031150938144979816.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938144979816.png)我们找到自己项目的包名。然后进行进一步的分析。首先看一下2个列表的列名到底指的什么。 实例化对象的详细信息： |名称|意义||:---:|:---:||Total Count|内存中该类的对象个数||Heap Count|堆内存中该类的对象个数||Sizeof|物理大小||Shallow size|该对象本身占有内存大小||Retained Size|释放该对象后，节省的内存大小||depth|深度||Dominating Size|管辖的内存大小|我们来随便的看一下内存中的数量： ![20171031150938170331677.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938170331677.png)这还是我们刚进手机，一个bean就被调用了这么多次。简直可怕。这个我们可以通过内存分析工具解决的。# 内存分析工具**性能优化工具**：- Heap SnapShot工具- Heap Viewer工具- LeakCanary工具- MAT工具- TraceView工具（Device Monitor）**第三方分析工具**：- MemoryAnalyzer- GT Home- iTest 因为我没有这些工具，无法进行演示。## 注意事项- 我们尽量不要使用Activity的上下文，而是使用application的上下文，因为application的生命周期长，进程退出时才会被销毁。所以，单例模式是最容易造成内存溢出的原本所在，因为单例模式的生命周期的应该和application的生命周期一样长，而不是和Activity的相同。- Animation也会导致内存溢出，为什么？因为我们是通过view来进行演示的，导致view被Activity持有，而Activity又持有view。最后因为Activity无法释放，导致内存泄漏。解决方法是在Activity的ondestory（）方法中调用Animation.cancle（）进行停止，当然一些简单的动画我们可以通过自定义view来解决。至少我现在已经很少使用Animation了。没有一个动画是自定义view解决不了的。如何有，那就是两个~~~。# UI优化UI优化主要包括布局优化以及view的绘制优化。不急，我们接下来一个一个慢慢看~~。先说下UI的优化到底是什么？有些时候我们打开某个软件，会出现卡顿的情况。这就是UI的问题。那么我们想一下，什么情况会导致卡顿呢？一般是如下几种情况：- 人为在UI线程中做轻微耗时操作，导致UI线程卡顿；- 布局Layout过于复杂，无法在16ms内完成渲染；- 同一时间动画执行的次数过多，导致CPU或GPU负载过重；- View过度绘制，导致某些像素在同一帧时间内被绘制多次，从而使CPU或GPU负载过重；- View频繁的触发measure、layout，导致measure、layout累计耗时过多及整个View频繁的重新渲染；- 内存频繁触发GC过多（同一帧中频繁创建内存），导致暂时阻塞渲染操作；- 冗余资源及逻辑等导致加载和执行缓慢；- 臭名昭著的ANR；可以看见，上面这些导致卡顿的原因都是我们平时开发中非常常见的。有些人可能会觉得自己的应用用着还蛮OK的，其实那是因为你没进行一些瞬时测试和压力测试，一旦在这种环境下运行你的App你就会发现很多性能问题。# 布局优化## GPU绘制我们对于UI性能的优化还可以通过开发者选项中的GPU过度绘制工具来进行分析。在设置-&gt;开发者选项-&gt;调试GPU过度绘制（不同设备可能位置或者叫法不同）中打开调试后可以看见如下图（对settings当前界面过度绘制进行分析）： ![20171031150938187814302.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938187814302.png) ![20171031150938189533910.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938189533910.png)这图看着太乱，我们来一张简洁明了的图： ![2017103115093819223109.png](http://ohtrrgyyd.bkt.clouddn.com/2017103115093819223109.png)我们的目标就是尽量减少红色Overdraw，看到更多的蓝色区域。可以发现，开启后在我们想要调试的应用界面中可以看到各种颜色的区域，具体含义如下： |颜色|含义||:---:|:---:||无色|WebView等的渲染区域||蓝色|1* 过度绘制||绿色|2* 过度绘制||淡红色|3* 过度绘制||红色|4*(+) 过度绘制|Overdraw有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。例如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色Overdraw区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。如果布局中既能采用RealtiveLayout和LinearLayout，那么直接使用LinearLayout，因为Relativelayout的布局比较复杂，绘制的时候需要花费更多的CPU时间。如果需要多个LinearLayout或者Framelayout嵌套，那么可采用Relativelayout。因为多层嵌套导致布局的绘制有大部分是重复的，这会减少程序的性能。## GPU呈现模式分析我们依旧打开设置–&gt;开发者选项–&gt;GPU呈现模式分析–&gt;在屏幕上显示为条形图，如图所示： ![20171031150938208067517.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938208067517.png) ![20171031150938209926269.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938209926269.png)当然，也可以在执行完UI滑动操作后在命令行输入如下命令查看命令行打印的GPU渲染数据（分析依据：Draw + Process + Execute = 完整的显示一帧时间 &lt; 16ms）：`adb shell dumpsys gfxinfo [应用包名]`随着界面的刷新，界面上会以实时柱状图来显示每帧的渲染时间，柱状图越高表示渲染时间越长，每个柱状图偏上都有一根代表16ms基准的绿色横线，每一条竖着的柱状线都包含三部分（蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间），只要我们每一帧的总时间低于基准线就不会发生UI卡顿问题（个别超出基准线其实也不算啥问题的）。就简单的看下我们公司项目刚启动的时候,超出基准线好多。 突然就有那么一种想吐槽的感觉…..我记得之前我做了瘦身的优化，但是要让我做性能优化，我觉得应该没那么简单……..# 代码优化Android Studio和IntellJ idead都有自带的代码检查工具。打开Analyze-&gt;Run Inspection by Name… –&gt;unused resource 点击开始检测，等待一下后会发现如下结果： ![20171031150938218179898.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938218179898.png)我们还可以这样，将鼠标放在代码区点击右键-&gt;Analyze-&gt;Inspect Code–&gt;界面选择你要检测的模块-&gt;点击确认开始检测，等待一下后会发现如下结果： ![20171031150938220134827.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938220134827.png)当然，我这只是截取了少一部分，我们看下下面那个提示：@param v tag description is missing 。意味着v的类型缺少了，要么补上介绍，要么直接删除。上面那两种方法是最容易找到代码缺陷以及无用代码的地方。所以尽情的入坑去填坑把~~# 绘制优化那么什么是绘制优化？绘制优化主要是指View的Ondraw方法需要避免执行大量的操作。我将分为了2个方面。- ondraw方法不需要创建新的局部对象，这是因为ondraw方法是实时执行的，这样会产品大量的临时对象，导致占用了更多内存，并且使系统不断的GC。降低了执行效率。- Ondraw方法不需要执行耗时操作，在ondraw方法里少使用循环，因为循环会占用CPU的时间。导致绘制不流畅，卡顿等等。Google官方指出，view的绘制帧率稳定在60dps，这要求每帧的绘制时间不超过16ms（1000/60)。虽然很难保证，但我们需要尽可能的降低。60dps是目前最合适的图像显示速度，也是绝大部分Android设备设置的调试频率，如果在16ms内顺利完成界面刷新操作可以展示出流畅的画面，而由于任何原因导致接收到VSYNC信号的时候无法完成本次刷新操作，就会产生掉帧的现象，刷新帧率自然也就跟着下降(假定刷新帧率由正常的60fps降到30fps，用户就会明显感知到卡顿)。So，前面我们说GPU的时候也谈到了这个。总的而言，感觉还是蛮重要的…..# 网络优化线程是我们项目中不可缺少的重要部分，因为我们大多数数据都是从网络获取的。So，线程这个是必备用品。 我们依旧可以通过Memory下面的Net进行网络的监听： ![20171031150938225451445.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938225451445.png)# ANR问题相信这个问题在座的各种没少遇到过，那么什么是ANR？application not responding。应用程序无响应。那么一般什么时候会出现ANR。Android官方规定：activity如果5s内无响应事件（屏幕触摸事件或者键盘输入事件）。BroadcastReceiver如果在10s内无法处理完成。Service如果20s内无法处理完成。这三种情况会导致ANR。用张简洁的图来介绍把。看起来方便~~ ![2017103115093823044615.png](http://ohtrrgyyd.bkt.clouddn.com/2017103115093823044615.png)# 线程优化上面说的三种导致ANR的情况，绝大多数就是因为线程阻塞导致的。那么我们应该如何处理呢？Android系统为我们提供了若干组工具类来解决此问题。- **Asynctask**：为UI线程与工作线程之间进行快速处理的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的场景。- **HandlerThread**：为某些回调方法或者等待某些执行任务的执行设置一个专属的线程，并提供线程任务的调度机制。- **ThreadPool**：把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。- **IntentService**：适合执行由Ui触发的后台任务。并可以把这些任务执行的情况通过一定的机制反馈给UI。网络请求耗时会给用户带来卡顿的产品体验，虽然可以使用Loading提升用户体验，但属于治标不治本。例如，当网络差的时候我们公司的项目一个loading就是10多s。甚至更多…..我就记得我当时面试之前下了一次我们公司的项目，因为网差的问题…一个loading一分多钟。。当时砸手机的冲动都有了，别说卸软件了….一般多线程的情况我们可以通过Asynctask处理。（这玩意我真没怎么用过- -）我前面有说过annotation。这是google官方推出的注解。比bufferknife强大很多。这个可以快捷方便的处理多线程而且不会导致线程阻塞，而且你也可以控制线程的顺序，例如我要执行完线程A后，根据线程A的某个参数来执行线程B。以此类推…..至于线程池么，最多的还是要说道图片加载了~~。图片加载用三方就行了~想看详细介绍，我前面有说，当然除了这个还有下载操作。这就和IntentService有关联了。一般下载我很少涉及到。。用过几次android原生的downloadmanager。。感觉略坑。# KO网络优化现在讲网络优化的重点了…重点..重点…，一般用到网最最最主要的是什么？时间！！速度！！成功率！！，时间！！速度！！成功率！！，时间！！速度！！成功率！！重要的事说三遍哈。## 图片处理这已经不是第一次在此文提到图片了。可见图片的重要性！！- 使用WebP格式；同样的照片，采用WebP格式可大幅节省流量，相对于JPG格式的图片，流量能节省将近 25% 到 35 %；相对于 PNG 格式的图片，流量可以节省将近80%。最重要的是使用WebP之后图片质量也没有改变。So，去和后台的小伙伴们商量吧~~- 使用缩略图，我在前面写图片加载有说过，就是控制他的inside和option。然后进行图片缩放。压缩？讲道理….我并不知道网络图片怎么压缩，but，我会缩放啊~~反正也不会失真。啦啦啦~咬我啊？## 网络请求处理我们可以对服务端返回数据进行缓存，设定有效时间，有效时间之内不走网络请求，减少流量消耗。对网络的缓存可以参见HttpResponseCache。在某些情况，我们尽量少使用GPS定位，如果条件允许，尽可能使用网络定位。下载、上传，我们尽可能使用断点，说个简单的，我在公司，准备下一个500M的游戏，但是下到200M的时候我下班了，此时没有了无线网，我们可以回家后用无线继续下载。So，断点续传，断点下载也是我们的必修课~，所以我前面单独提了一篇断点续传的文章。刷新数据时，尽可能使用局部刷新，而不是全局刷新，第一、界面会闪屏一下，网差的界面直接白屏一段时间也不是不可能。第二、流量的使用！！我又要拿我们公司项目搞事情了。一个闪屏的缓存60+M。。。没错，就是60+M。简直可怕，我清个3、5次缓存，在打开个3、5次。好了，2分钟时间，我一个月流量就没了。。。So，我前面提到的网络缓存很重要，至于会不会加在项目中，我还是要看了在说- - 一个不小心，整个项目炸了都有可能。。。# 启动优化众所周知，一个好的产品，除了功能强大，好的性能也必不可少。有调查显示，近50%的受访者因为apk太大而拒绝使用，近40%的受访者会因为APP性能差而卸载，性能也是造成APP用户沮丧的头号原因。安卓应用的启动方式分为三种：冷启动、暖启动、热启动，不同的启动方式决定了应用UI对用户可见所需要花费的时间长短。顾名思义，冷启动消耗的时间最长。基于冷启动方式的优化工作也是最考验产品用户体验的地方。谈及优化之前，我们先看看这三种启动方式的应用场景，以及启动过程中系统都做了些什么工作。## 冷启动为什么说冷启动是耗时最长的。冷启动是在启动应用前，系统没有获取到当前app的activity、Service等等。例如，第一次启动app。又或者说杀死进程后第一次启动。那么对比其他两种方式。冷启动自然是耗时最久的。应用发生冷启动时，系统一定会执行下面的三个任务：- 开始加载并启动应用- 应用启动后，显示一个空白的启动窗口（启动闪屏页）- 创建应用信息那么创建应用信息，系统就需要做一屁股的事：- application的初始化- 启动UI线程- 创建Activity- 导入视图（inflate view）- 计算视图大小（onmesure view）- 得到视图排版（onlayout view）- 绘制视图（ondraw view）这其中有两个 creation 工作，分别为 Application 和 Activity creation。他们均在 View 绘制展示之前。所以，在应用自定义的 Application 类和 第一个 Activity 类中，onCreate() 方法做的事情越多，冷启动消耗的时间越长。## 暖启动当应用中的 Activities 被销毁，但在内存中常驻时，应用的启动方式就会变为暖启动。相比冷启动，暖启动过程减少了对象初始化、布局加载等工作，启动时间更短。但启动时，系统依然会展示闪屏页，直到第一个 Activity 的内容呈现为止。## 热启动相比暖启动，热启动时应用做的工作更少，启动时间更短。热启动产生的场景很多，常见如：用户使用返回键退出应用，然后马上又重新启动应用。## 如何优化我们先对比下三种启动的时间对比： 冷启动： ![20171031150938245458902.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938245458902.png)暖启动 ： ![20171031150938246619966.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938246619966.png)热启动： ![20171031150938247843794.png](http://ohtrrgyyd.bkt.clouddn.com/20171031150938247843794.png)我们可以看到三者的明显的差距，一个冷启动将近一分钟，反正我是不想看，每次跑项目都好慢~那么我们应该怎么做？看到有些人介绍说改变项目的theme。把它改成launcher的theme。但我觉得，这种做测试的确没问题。但是一般项目都会有闪屏页。然后从闪屏跳转到首页。我们可以按照大多数的项目来改善。怎么说的，我们可以看到一般项目都有倒计时显示。也就是说倒计时结束就自动进入首页。或者可以直接跳过进入首页。也就是说我们可以通过此方法来进行，也就是说只要他倒计时结束，不管请求是否全部获取完我们都直接进入首页。我们可以在闪屏页进行一些必要的加载，例如用户信息，定位等等，那么至于其他的，我们可以进入主页进行预加载。就和热更新一样，在用户不知情的情况下，默默的更新bug。So，对于一些网络请求，例如广告之类的。我们可以通过此方法进行预加载。我们还可以这样，闪屏页我们把他当作一个fragment嵌套在MainActivity中，那么我们可以在进入闪屏时直接预加载主页的view。倒计时我们把闪屏页remove掉直接显示首页。通过上面的介绍，我们对启动优化有了一定的了解，其实总结的话很简单。就是减少耗时操作，总结如下：- 主线程中涉及到Shareperference能否在非UI线程执行。- Application的创建过程中尽量少的进行耗时操作。- 减少布局的层次,并且生命周期回调的方法中尽量减少耗时的操作。# 电量优化有了UI优化、内存优化、代码优化、网络优化之后我们在来说说应用开发中很重要的一个优化模块—–电量优化。## 耗电概念其实大多数开发者对电量优化的重视程度极低，其实提到性能优化想到的就是内存优化，但我们不能忽视其他的优化，电量优化其实还是必要的，例如爱奇艺、优酷等等的视频播放器以及音乐播放器。众所周知，音乐和视频其实是耗电量最大的。如果用户一旦发现我们的应用非常耗电，不好意思，他们大多会选择卸载来解决此类问题。为此，我们需要进行优化。## 如何优化其实我们把上面那四种优化解决了，就是最好的电量优化。So，对于电量优化，我在此提一些建议：- 需要进行网络请求时，我们需先判断网络当前的状态。- 在多网络请求的情况下，最好进行批量处理，尽量避免频繁的间隔网络请求。- 在同时有wifi和移动数据的情况下，我们应该直接屏幕移动数据的网络请求，只有当wifi断开时在调用，因为，wifi请求的耗电量远比移动数据的耗电量低的低。- 后台任务要尽可能少的唤醒CPU。（比方说，锁屏时，QQ的消息提示行就是唤醒了CPU。但是它的提示只有在你打开锁屏或者进行充电时才会进行提示。）# 优化总结性能优化是我们进阶的毕竟之路。So，我们必须要会，至于“会”到什么程度，就要看个人理解了。其实，上面介绍的只是性能问题的冰山一角，真正的优化，我们是在项目中总结出来的。但，我们不能一味的追求优化，就例如我，现在只是在进行优化的总结，而对于真正的实行，并没有开始，因为，优化是有风险的，一个不小心，整个项目都可能炸了。所以这就需要你的经验，以及各种总结，在改进行优化的地方先进行优化，看看效果如何，例如，UI的优化以及代码的优化。可以先拿一些网上的开源项目进行优化等等。最后，尽情的享受优化把]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Launcher启动Activity的工作过程]]></title>
      <url>%2F2017%2F09%2F04%2Fandroid-activity-launcher%2F</url>
      <content type="text"><![CDATA[Launcher手机桌面也是一个App，每一个应用的icon都罗列在Launcher上，点击icon触发onItemClick事件，下面例如我们要启动「淘宝」这个App，首先我们要在清单文件定义默认启动的Activity信息。 123456&lt;activity android:name=".MainActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 然后Launcher获取到该信息之后，启动淘宝App 12345678910//该应用的包名String pkg = info.activityInfo.packageName;//应用的主activity类String cls = info.activityInfo.name;ComponentName componet = new ComponentName(pkg, cls);Intent i = new Intent();i.setComponent(componet);startActivity(i); 启动Activity这一工作不管是相同应用的2个不同Activity的启动，或者是不同进程不同应用的Activity启动，都是由Activity大管家ActivityManagerService（简称AMS）全权管理，而他们之间的通讯就要用到Binder，通过Binder与AMS多次通讯，才能启动淘宝App。 整体流程 通过对Android操作系统的学习可以提高我们对操作系统在技术实现上的理解，这对于加强开发人员的内功是很有帮助的。但是由于Android内部实现多数都比较复杂，在研究内部实现上应该更加侧重对整体流程的把握，而不能深入到代码细节不能自拔。 Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。 AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。 Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。 淘宝app未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。 淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。 AMS通知淘宝绑定Application并启动MainActivity。 淘宝启动MainActivitiy，并且创建和关联Context,最后调用onCreate方法。 startActivityForResult我们从Activity的startActivity方法开始分析。startActivity方法有好几种重载方式，但它们最终都会调用startActivityForResult方法。 12345678910@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); &#125;&#125; 在startActivityForResult方法内，会调用Instrumentation的execStartActivity方法。 1234567public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,@Nullable Bundle options) &#123; ...... Instrumentation.ActivityResult ar =mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); ......&#125; Instrumentation Instrumentation从字面上来看是仪器盘的意思，具体到程序中是管理activity的一个工具类，包括创建和启动Activity，activity的生命周期方法都是由Instrumentation这个仪器来控制，一个进程中只用一个Instrumentation实例。 1234567891011121314151617181920212223242526272829303132/** * * * @param who The Context from which the activity is being started. * @param contextThread The main thread of the Context from which the activity * is being started. * @param token Internal token identifying to the system who is starting * the activity; may be null. * @param target Which activity is performing the start (and thus receiving * any result); * may be null if this call is no`t being made form an activity. * @param intent The actual Intent to start. * @param requestCode Identifier for this request's result; less than zero * if the caller is not expecting a result. * @param options Addition options. * */public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target,Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ...... try &#123; int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent,intent.resolveTypeIfNeeded(who.getContentResolver()),token, target != null ? target.mEmbeddedID : null,requestCode, 0, null, options); //检查启动Activity的结果（抛出异常，例如清单文件未注册Activity） checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null;&#125; 我们截取了比较关键的代码片段来分析Instrumentation的execStartActivity方法，方法参数注释中也有对该方法的几个参数进行简单描述。下面我们来分析一下比较重要的2个参数，contextThread和token。 IBinder contextThread在上一个方法中传入为mMainThread.getApplicationThread()我们可以看到这是一个IBinder对象，说明它的作用就是用于进程间通讯的Binder对象。 mMainThread实际上是ActivityThread对象。ActivityThread，就是主线程，也就是UI线程，它是在App启动时创建的，它代表了App应用程序。啥？ActivityThread代表了App应用程序，那Application类岂不是被架空了？其实，Application对我们App开发人员来说也许很重要，但是在Android系统中还真的没那么重要，他就是个上下文。Activity不是有个Context上下文吗？Application就是整个ActivityThread的上下文。 我们找到ActivityThread文件，其实这个getApplicationThread方法获取的是内部类ApplicationThread对象而且ApplicationThread继承ApplicationThreadNative 123456789101112131415public final class ActivityThread &#123;//没有继承或者实现其他类。 final ApplicationThread mAppThread = new ApplicationThread(); public ApplicationThread getApplicationThread() &#123; return mAppThread; &#125; //ActivityThread的内部类ApplicationThread private class ApplicationThread extends ApplicationThreadNative &#123; ...... &#125;&#125; 我们打开ApplicationThreadNative类(需要通过sdk的源码找到，具体路径为Sdk\sources\android-25(sdk版本)\android\app\ApplicationThreadNative)通过构造方法我们就很清晰的可以得知原来这个ApplicationThreadNative就是相当于AIDL通讯中的Stub，也就是服务端，ApplicationThreadProxy即AIDL通讯中的Proxy，也就是客户端。所以ApplicationThread是通讯的具体实现类。上面的介绍中我们也说过，Activity的启动实际上是多次进程间通讯的成果，看到这里我们就可以得出结论：ActivityThread通过内部类ApplicationThread来进行进程间通讯 123456789101112131415161718192021public abstract class ApplicationThreadNative extends Binder implements IApplicationThread &#123; static public IApplicationThread asInterface(IBinder obj) &#123;...&#125; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;...&#125; public IBinder asBinder()&#123;return this;&#125;&#125;class ApplicationThreadProxy implements IApplicationThread &#123; private final IBinder mRemote; public ApplicationThreadProxy(IBinder remote) &#123; mRemote = remote; &#125; ...&#125; public interface IApplicationThread extends IInterface {...} IBinder token追溯到参数起源，这个token对象，是在Activity的attach方法中传入的，也就是Activity的创建与关联时候(下面的内容会提到)传入的Activity信息。这也是个Binder对象，它代表了Launcher这个Activity，这里也通过Instrumentation传给AMS，AMS查询后，就知道是谁向AMS发起请求了。 1234567891011121314//Activity private IBinder mToken; final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; mToken = token;&#125; contextThread和token这两个参数是伏笔，传递给AMS，以后AMS想反过来通知Launcher，就能通过这两个参数，找到Launcher。 startActivity在Instrumentation中，启动Activity真正的实现是由ActivityManagerNative.getDefault()的startActivity方法来完成。 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); ActivityManagerService（下面简称AMS）继承自ActivityManagerNative（下面简称AMN），而AMN继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder，它是IActivityManager的具体实现，由于ActivityManagerNative.getDefault()其实是一个IActivityManager类型的Binder对象，因此它的具体实现是AMS。 我们先看代码，捋一捋上述所说的关系。 12345public final class ActivityManagerService extends ActivityManagerNative &#123;...&#125;public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123;...&#125;public interface IActivityManager extends IInterface &#123;...&#125; 首先我们来看这个命名方式，xxxNative，我们知道Stub持有Binder本地对象，Proxy持有的是Binder的代理对象。所以系统命名也是依据此因素（Native：本地的，土著的）作为命名规范。 1234567891011121314151617181920212223242526/** * Retrieve the system's default/global activity manager. */static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService("activity"); IActivityManager am = asInterface(b); return am; &#125;&#125;;/** * Cast a Binder object into an activity manager interface, generating * a proxy if needed. */static public IActivityManager asInterface(IBinder obj) &#123; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in;//同一进程，返回Stub本地对象。 &#125; return new ActivityManagerProxy(obj);//跨进程，返回代理对象。&#125; 可以发现，在AMN 中，AMS这个Binder对象采用单例模式对外提供，Singleton是一个单例的封装类，第一次调用它的get方法时它会通过create方法来初始化AMS这个Binder对象，在后续的调用中则直接返回之前创建的对象（使用同一个AMS）。 分析create方法，在IActivityManager内（相当于Client），通过应用程序中的0号引用，可以向SMgr获取服务端（Server）的Binder引用。AMN通过getDefault方法，从ServiceManager中获取AMS中Binder的引用对象，然后将它转换成ActivityManagerProxy对象（简称AMP），AMP就是AMS的代理对象。 类似AIDL中客户端的绑定代码，此时我们就可以通过ActivityManagerProxy（asInterface返回值为 IActivityManager），与AMS进行通讯。 12345678910111213141516171819202122232425262728293031//ActivityManagerProxypublic int startActivity(IApplicationThread caller, String callingPackage, Intent intent,String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain();//从Parcel池中获取Parcel对象（通讯载体），用来写入数据 Parcel reply = Parcel.obtain();//如果方法有返回值，则写入返回值 data.writeInterfaceToken(IActivityManager.descriptor);//Binder唯一标识 //caller即上面提到的contextThread，AMS就可以通过它与Launcher通讯 data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); //resultTo即上面提到的token,包含Launcher的Activity信息 data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); ...... //发送类型为START_ACTIVITY_TRANSACTION的请求给AMS，data包含Launcher和淘宝App的信息 mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); //Instrumentation通过result来检查并抛出异常（Activity未在清单文件注册等） int result = reply.readInt(); reply.recycle(); data.recycle(); return result;&#125; 从上面的分析可以知道，Activity是由AMN.getDefault()来启动的，而AMN.getDefault()实际上是AMS，因此Activity的启动过程又转移到了AMS中，为了继续分析这个过程，只需要查看AMS的startActivity方法即可。 Launcher通知AMS启动淘宝APP的MainActivity，也就是清单文件设置启动的Activity。 AMS上个图，先通俗易懂的总结一下Activity启动的整体流程，对整体框架有一个大概认识。 AMS分析再回顾一遍，通过对AMS 类的查看，我们可以知道AMS 也是一个Binder，并且它是IActivityManager的具体实现。 12345public final class ActivityManagerService extends ActivityManagerNative &#123;...&#125;public abstract class ActivityManagerNative extends Binder implements IActivityManager&#123;...&#125;public interface IActivityManager extends IInterface &#123;...&#125; 接着我们继续分析AMS的startActivity方法，这个阶段比较复杂和繁琐，一不小心就绕晕了，我们了解大致过程，不深入代码细节，对整体流程建立足够认识即可。 1234567891011121314151617//AMS@Overridepublic final int startActivity(IApplicationThread caller, String callingPackage,Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,resultWho, requestCode, startFlags, profilerInfo, bOptions,UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage,Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),userId, false, ALLOW_FULL_ONLY, "startActivity", null); //7.0Acitivty启动管理类新增ActivityStarter(原本是ActivityStackSupervisor处理该过程) return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,profilerInfo, null, null, bOptions, false, userId, null, null);&#125; ActivityStarter12345//ActivityStarterfinal int startActivityMayWait(IApplicationThread caller, int callingUid,String callingPackage, Intent intent, String resolvedType,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,IBinder resultTo, String resultWho, int requestCode, int startFlags,ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,Bundle bOptions, boolean ignoreTargetSecurity, int userId,IActivityContainer iContainer, TaskRecord inTask) &#123; ``` //根据intent在系统中找到合适的应用的activity，如果有多个activity可选择， //则会弹出ResolverActivity让用户选择合适的应用。 ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags,profileFile, profileFd, userId); 12int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,aInfo, rInfo, voiceSession, voiceInteractor,resultTo, resultWho, requestCode, callingPid,callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,options, ignoreTargetSecurity, componentSpecified, outRecord, container,inTask); return res; } //在startActivityLocked方法里，对传过来的参数做一些校验，然后创建ActivityRecord对象，再调用startActivityUnchecked(7.0前是startActivityUncheckedLocked)方法启动Activity。 final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,String callingPackage, int realCallingPid, int realCallingUid, int startFlags,ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,TaskRecord inTask) { int err = ActivityManager.START_SUCCESS; 123//创建ActivityRecord对象//ActivityRecord : 在AMS中，将用ActivityRecord来作为Activity的记录者,每次启动一个Actvity会有一个对应的ActivityRecord对象，表示Activity的一个记录ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,requestCode, componentSpecified, voiceSession != null, mSupervisor, container,options, sourceRecord); err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); //此处将通知ActivityStarter, Activity对应的Task被移动到前台 postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack); return err; } 123456789101112131415&gt; 在startActivityLocked方法里，对传过来的参数做一些校验，然后创建ActivityRecord对象，再调用startActivityUnchecked方法启动Activity。&gt; startActivityUnchecked方法负责调度ActivityRecord和Task，理解该方法是理解Actvity启动模式的关键。&gt; startActivityUnchecked方法调度task的算法非常复杂，和当前回退栈，要启动的acitivity的启动模式以及taskAffinity属性，启动activity时设置的intent的flag等诸多要素相关，intent的flag就有很多种情况，故此算法非常复杂，需要阅读源码并结合特定启动情况才能理解。接下来调用ActivityStack的startActivityLocked将ActivityRecord加入到回退栈里```java//ActivityStarter private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; ``` //ActivityStack的startActivityLocked,不要搞混了。 //同时调用WindowManager准备App切换相关的工作 mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions); if (mDoResume) { final ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) { // If the activity is not focusable, we can&apos;t resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don&apos;t want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. } else { //最终调用ActivityStackSupervisor的resumeFocusedStackTopActivityLocked mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); } }1234567891011121314151617181920212223## ActivityStackSupervisor```java//ActivityStackSupervisor boolean resumeFocusedStackTopActivityLocked() &#123; return resumeFocusedStackTopActivityLocked(null, null, null); &#125; boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; //待启动Activity对应的Task为前台Task时，调用该Task对应ActivityStack的resumeTopActivityUncheckedLocked函数 return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; //否则只是调用当前前台栈的resumeTopActivityUncheckedLocked mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; return false; &#125; ActivityStack接着跟进ActivityStack 123456//ActivityStack boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; ``` result = resumeTopActivityInnerLocked(prev, options); return result; } private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) { //mResumedActivity指向上一次启动的Activity(Launcher) if (mResumedActivity != null) { 12345 //通知Launcher进入pause状态 pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);&#125; if (pausing) &#123;//Launcher已经暂停了 if (next.app != null &amp;&amp; next.app.thread != null) { //如果app已经启动过 //调用淘宝(待启动)Activity所在进程的优先级，保证其不被kill mService.updateLruProcessLocked(next.app, true, null); } } 123456789if (next.app != null &amp;&amp; next.app.thread != null) &#123;//如果Intent不为空，调用NewIntent方法传入Intentnext.app.thread.scheduleNewIntent(next.newIntents, next.appToken, false);//假设淘宝App已经启动，点击Home键返回到Launcher,再次从Launcher启动淘宝(或者第三方启动已开启的App)next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState, mService.isNextTransitionForward(), resumeAnimOptions); } else { 1234567891011121314151617181920212223242526272829303132333435363738394041 //创建进程，冷启动Activity。或者已启动App，重新启动Activity mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true; &#125;```resumeTopActivityInnerLocked函数非常繁琐，但整体来讲应该只有两个比较关键的地方：1. 判断是否已有Activity(mResumedActivity)启动（即Launcher，通过Launcher启动淘宝的），有则暂停该Activity2. 判断是否需要重新启动目标Activity，即Activity是否已经启动过。（例如保存在后台，应用切换）&gt; 2.AMS记录要启动的Activity信息，并且通知Launcher进入pause状态。 3.Launcher进入pause状态后，通知AMS已经paused了，可以启动淘宝了。## 创建进程接下来的操作就比较重要了，创建进程，启动Activity。```java//ActivityStackSupervisor void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity&apos;s application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; //目标Activity的App已经启动（存在ActivityThread），则重启Activity realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; } } //如果进程不存在，则通过zygote创建应用进程。 mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); } 123456789101112131415161718192021从上面代码可以了解到startSpecificActivityLocked为启动Activity的两种不同情况- 例如从Launcher冷启动淘宝，则需要创建新进程，通过AMS调用Zygote(孕育天地)孵化应用进程。- 如果淘宝App已经启动，例如从MainActivity跳转到LoginActivity，则通过realStartActivityLocked启动。因为我们开头以Launcher启动淘宝为例子，所以我们硬着头皮继续分析AMS创建进程以及Activity的绑定过程。 上面分析到mService.startProcessLocked,到了这里我们直接看启动线程的方法，中间的过程实在是略复杂。&gt; 4.淘宝App未开启过，所以AMS启动新的进程，并且在新进程中创建ActivityThread对象，执行其中的main函数方法。```java//ActivityServiceManager //Process.java的start函数，将通过socket发送消息给zygote //zygote将派生出一个子进程，子进程将通过反射调用ActivityThread的main函数 Process.ProcessStartResult startResult = Process.start(&quot;android.app.ActivityThread&quot;, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); Zygote进程孵化出新的应用进程后，通过反射执行ActivityThread类的main方法。在该方法里会先准备好Looper和消息队列，然后调用attach方法将应用进程绑定到AMS，然后进入loop循环，不断地读取消息队列里的消息，并分发消息。 1234//ActivityThreadpublic static void main(String[] args) &#123; ``` //准备主线程的Looper，下篇博文分析Handler,Looper Looper.prepareMainLooper(); //创建当前进程的ActivityThread ActivityThread thread = new ActivityThread(); //将该进程绑定到AMS thread.attach(false); if (sMainThreadHandler == null) { //保存进程对应的主线程Handler sMainThreadHandler = thread.getHandler(); } 12//进入主线程的消息循环Looper.loop(); } //上面说过，ApplicationThread是ActivityThread用来与AMS通讯的中介final ApplicationThread mAppThread = new ApplicationThread(); private void attach(boolean system) { if (!system) { final IActivityManager mgr = ActivityManagerNative.getDefault(); //调用AMS的attachApplication方法，将ApplicationThread对象绑定至ActivityManagerService //这样AMS就可以通过ApplicationThread代理对象控制应用进程 mgr.attachApplication(mAppThread); } else { 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 &#125;&#125;```至此，进程创建完毕，并且也有了主线程，剩下的便是启动Activity和关联context等初始化操作了。&gt; 5.淘宝app主线程启动完毕后通知AMS，并传入applicationThread以便通讯。## AMS启动Activity小结至此通过下图总结一下在AMS启动Activity的大致流程，各个方法函数像一台机器上的不同零件，各尽其责，分工明确。 虽然错综复杂，但是耦合性低，比如说启动模式需要优化，重新完善startActivityUnchecked方法函数即可。![20171019150834779685560.png](http://ohtrrgyyd.bkt.clouddn.com/20171019150834779685560.png)## 关联Activity在这个时候，虽然有了app进程，和主线程，但是仍是一副空壳。 没有activity信息，没有关联上下文，这时候就要请出AMS来进行指挥。因为主线程main入口通过attach方法将 ApplicationThread 发送给 AMS ，所以通过applicationThread这个桥梁来通知ActivityThread创建/关联和启动Activity。```java//AMS @Override public final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; //获取applicationThread的进程id(也就是淘宝应用进程) int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125; &#125;``` 通过Binder获取proxy（ApplicationThread ）方的进程id，也就是获取目标(淘宝)进程的Pid。```java//Binder /** * Return the ID of the process that sent you the current transaction * that is being processed. This pid can be used with higher-level * system services to determine its identity and check permissions. * If the current thread is not currently executing an incoming transaction, * then its own pid is returned. */ public static final native int getCallingPid(); ```接下来重点分析attachApplicationLocked方法```java//AMS private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; // Find the application record that is being attached... either via // the pid if we are running in multiple processes, or just pull the // next app record if we are emulating process with anonymous threads. ProcessRecord app; if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid); &#125; &#125; else &#123; app = null; &#125; //因为进程由AMS启动，所以在AMS中一定会有ProcessRecord（进程记录） //如果没有ProcessRecord，则需要杀死该进程并退出 if (app == null) &#123; return false; } // If this application record is still attached to a previous // process, clean it up now. if (app.thread != null) { //如果从ProcessRecord中获取的IApplicationThread不为空，则需要处理该IApplicationThread //因为有可能此Pid为复用，旧应用进程刚释放，内部IApplicationThread尚未清空， //同时新进程又刚好使用了此Pid handleAppDiedLocked(app, true, true); } //创建死亡代理（进程kill后通知AMS） AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread); //进程注册成功，移除超时通知 mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); 12345678910111213try &#123; //******绑定Application****** thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); updateLruProcessLocked(app, false, null);&#125; catch (Exception e) &#123; //bindApplication失败后，重启进程 startProcessLocked(app, &quot;bind fail&quot;, processName); return false; } try { //******启动Activity(启动淘宝MainActivity)****** if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true;//didSomething表示是否有启动四大组件 } } catch (Exception e) { badApp = true; } 123456789101112131415161718192021222324252627282930313233343536373839404142 //绑定service和Broadcast的Application if (badApp) &#123; //如果以上组件启动出错，则需要杀死进程并移除记录 app.kill(&quot;error during init&quot;, true); handleAppDiedLocked(app, false, true); return false; &#125; //如果以上没有启动任何组件，那么didSomething为false if (!didSomething) &#123; //调整进程的oom_adj值， oom_adj相当于一种优先级 //如果应用进程没有运行任何组件，那么当内存出现不足时，该进程是最先被系统“杀死” updateOomAdjLocked(); &#125; return true; &#125;```在`attachApplicationLocked`中有两个比较重要的方法函数，分析到这里我们的文章也要进入尾声了。1. thread.bindApplication（…） : 绑定Application到ActivityThread2. mStackSupervisor.attachApplicationLocked（app） : 启动Activity（7.0前为mMainStack.realStartActivityLocked()）## bindApplication在上面我们说道，ActivityThread通过ApplicationThread与AMS进行通讯，所以上面的thread.bindApplication（...）方法，就应该是通过ApplicationThread进行传达。 在ActivityThread的内部类ApplicationThread中，我们找到bindApplication方法```java//ActivityThread //内部类ApplicationThread private class ApplicationThread extends ApplicationThreadNative &#123; public final void bindApplication(...一大堆参数...) &#123; AppBindData data = new AppBindData(); //给data设置参数... sendMessage(H.BIND_APPLICATION, data); } } private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { Message msg = Message.obtain(); //给msg设置参数 12345678910 mH.sendMessage(msg); &#125;```发送消息是通过H的`Handler`类来完成的，这个命名贼个性，很令人印象深刻。PS : 我怀疑是编写这个类的工程师词穷了…```java private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int RESUME_ACTIVITY = 107; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; `````` //绑定application case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#125; &#125; &#125;``` 可以看出，这个H类相当于ActivityThread和ApplicationThread的中介人，也就是拉皮条的。 `ActivityThread`通过`ApplicationThread`与`AMS`通讯。 `ApplicationThread`通过`H`与`ActivityThread`通讯，处理Activity事务。 那么既然`H`、`ApplicationThread`都在`ActivityThread`类里，为何`ApplicationThread`还要通过Handler来发送消息？- 便于集中管理，方便打印Log日志等，H就是这其中的大管家。- `ActivityThread`通过`ApplicationThread`和AMS进行进程间通信，AMS以进程通讯的方式来完成`ActivityThread`的请求后调用`ApplicationThread`中的`Binder`方法，然后`ApplicationThread`会向H发送消息，H收到消息后会将`ApplicationThread`中的逻辑切换到`ActivityThread`中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。 而且有一点要注意的是，这个`ActivityThread`并不是一个线程Thread，它是final类并且无继承或者实现其它类，它的作用就是在main方法内消息循环，处理主线程事务。（还需了解Looper及消息机制）言归正传，上面ApplicationThread给H发送BIND_APPLICATION标识，在H中，通过handleBindApplication处理application的绑定事务。```java//ActivityThread private void handleBindApplication(AppBindData data) &#123; //根据传递过来的ApplicationInfo创建一个对应的LoadedApk对象 data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);//获取LoadedApk /** * For apps targetting Honeycomb or later, we don&apos;t allow network usage * on the main event loop / UI thread. This is what ultimately throws * {@link NetworkOnMainThreadException}. */ //禁止在主线程使用网络操作 if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB) { StrictMode.enableDeathOnNetwork(); } /** * For apps targetting N or later, we don&apos;t allow file:// Uri exposure. * This is what ultimately throws {@link FileUriExposedException}. */ //7.0引入Fileprovide if (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.N) { StrictMode.enableDeathOnFileUriExposure(); } 12345//创建进程对应的Android运行环境ContextImplfinal ContextImpl appContext = ContextImpl.createAppContext(this, data.info);if ((InstrumentationInfo)ii != null) &#123; } else { //注意Activity的所有生命周期方法都会被Instrumentation对象所监控， //也就说执行Activity的生命周期方法前后一定会调用Instrumentation对象的相关方法 mInstrumentation = new Instrumentation(); } try { 12345678910111213141516Application app = data.info.makeApplication(data.restrictedBackupMode, null);mInitialApplication = app;//加载进程对应Package中携带的ContentProviderinstallContentProviders(app, data.providers);`````` mInstrumentation.onCreate(data.instrumentationArgs);try &#123; //这里会调用Application的onCreate方法 //故此Applcation对象的onCreate方法会比ActivityThread的main方法后调用 //但是会比这个应用的所有activity先调用 mInstrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; } } finally { StrictMode.setThreadPolicy(savedPolicy); } } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465如上文所述，handleBindApplication的目的是让一个Java进程融入到Android体系中。 因此，该函数中的代码主要进行以下工作：1. 按照Android的要求，完成对进程基本参数的设置置，包括设置进程名、时区、资源及兼容性配置； 同时也添加了一些限制，例如主线程不能访问网络等。2. 创建进程对应的ContextImpl、LoadedApk、Application等对象，同时加载Application中的ContentProvider，并初始化Application。3. 使用Instrumentation监控Activity的生命周期。（一个进程对应一个Instrumentation实例）当完成上述工作后，新建的进程终于加入到了Android体系。&gt; 6.AMS通知淘宝绑定Application并启动MainActivity。# 启动Activity## attachApplicationLocked在上述代码AMS的`attachApplicationLocked`方法中，我们说道：&gt; 在`attachApplicationLocked`中有两个比较重要的方法函数，分析到这里我们的文章也要进入尾声了。 &gt; 1. thread.bindApplication（…） : 绑定Application到ActivityThread2. mStackSupervisor.attachApplicationLocked（app） : 启动Activity绑定了Application之后，我们就可以启动Activity(淘宝MainActivity)。 ```java//ActivityStackSupervisor boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; //ActivityStackSupervisor维护着终端中所有ActivityStack //此处通过轮询，找出前台栈顶端的待启动Activity for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFocusedStack(stack)) &#123; continue; &#125; ActivityRecord hr = stack.topRunningActivityLocked(); if (hr != null) &#123; //前台待启动的Activity与当前新建的进程一致时，启动这个Activity if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; //realStartActivityLocked进行实际的启动工作 if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; &#125; &#125; return didSomething; &#125; 大概系统工程师也觉得这个启动过程贼鸡儿绕了，最终启动的方法命名为realStartActivityLocked，意味着告诉你，大伙儿不要搞晕了，这个就是最后启动Activity的方法了。最后我们直捣黄龙，在ActivityStackSupervisor方法中，我们找到如下代码 12345678//ActivityStackSupervisor app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); 看到这里想必大伙儿都明白了，AMS最后通过ApplicationThread通知ActivityThread启动Activity，感觉这一切的通讯都像发电报一样，鬼斧神工出神入化，皆出架构师之目营心匠。那么到这里我们就能推算出接下来的老套路了ApplicationThread—&gt; H—&gt; ActivityThread—&gt; 最终启动Activity的方法。 ActivityThread123456789101112131415161718//ActivityThread //内部类ApplicationThread private class ApplicationThread extends ApplicationThreadNative &#123; @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); //设置参数 ``` //从LAUNCH_ACTIVITY这个标识我们就可以知道，它就是用来启动Activity sendMessage(H.LAUNCH_ACTIVITY, r); } } private class H extends Handler { 1234567891011121314151617181920212223242526 public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; //利用ApplicationInfo等信息得到对应的LoadedApk，保存到ActivityClientRecord //ActivityClientRecord包含Activity相关的信息 r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; `````` &#125; &#125; &#125;``````java//ActivityThreadprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity a = performLaunchActivity(r, customIntent); if (a != null) { 12handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#125;````handleLaunchActivity`方法里有有两个重要的函数调用,- performLaunchActivity : 会调用Activity的onCreate,onStart,onResotreInstanceState方法- handleResumeActivity : 会调用Activity的onResume方法.&gt; 从上面的源码可以看出，performLaunchActivity方法最终完成了Activity对象的创建和启动过程，并且ActivityThread通过handleResumeActivity方法来调用被启动Activity的onResume这一生命周期方法。## performLaunchActivity`【performLaunchActivity】` 这个方法主要完成了如下几件事。【摘自Android开发艺术探索】### 从ActivityClientRecord中获取待启动的Activity的组件信息。```java//ActivityThread的performLaunchActivity方法 ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125;```### 通过Instrumentation的newActivity方法使用类加载器创建Activity对象。```java//ActivityThread的performLaunchActivity方法 Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; } 12345678### 通过LoadedApk的makeApplication方法来创建Application对象。```java//ActivityThread的performLaunchActivity方法Application app = r.packageInfo.makeApplication(false, mInstrumentation);//r.packageInfo为LoadedApk对象 其实在我们上面的bindApplication中，我们就有介绍到通过LoadedApk创建Application，并且创建完毕后，通过Instrumentation的callApplicationOnCreate来调用Application的onCreate方法 123Application app = data.info.makeApplication(data.restrictedBackupMode, null); ``` mInstrumentation.callApplicationOnCreate(app);123456789101112所以第三步是为了判断Application是否为空，而且我们从makeApplication方法中也能看出如果Application已经被创建过了，那么就不会再重复创建了。### 创建ContextImpl对象，并通过Activity的attach方法来完成一些重要数据的初始化。```java Context appContext = createBaseContextForActivity(r, activity);//创建ContextImpl对象 ``` Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) { window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; } activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); 123456789101112131415161718&gt; ContextImpl是一个很重要的数据结构，它是Context的具体实现，Context中的大部分逻辑都是由ContextImpl来完成的。ContextImpl来完成的。ContextImpl是通过Activity的attach方法来和Activity建立关联的，除此之外**，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Window接收到外部输入事件后就可以将事件传递给Activity**。### 调用Activity的onCreate方法`mInstrumentation.callActivityOnCreate(activity, r.state);`由于Activity的onCreate已经被调用，这也意味着Activity已经完成了整个启动过程。### 调用Activity的onStart,onResotreInstanceState方法```java mInstrumentation.callActivityOnCreate(activity, r.state); ``` mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); ``` 总结至此从Launcher启动Activity的工作过程整个流程已经阐述完毕了，通过这次分析，对启动Activity的来龙去脉有了大致的掌控，但是也留下了几个知识点尚未探索清晰。（越深入探索，越发现不足） Looper，Handler的工作机制（Android的消息机制） Context 到底是什么 Window的内部机制又是怎样的 如果是淘宝MainActivity启动LoginActivity呢？其实原理和上述过程大体一致，只是在ActivityStackSupervisor的startSpecificActivityLocked方法中，发现进程已经启动，直接调用realStartActivityLocked启动Activity。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android项目从立项到上线]]></title>
      <url>%2F2017%2F09%2F03%2Fandroid-project%2F</url>
      <content type="text"><![CDATA[最近在组建项目组从0开始开发项目，从立项到上线，有一些心得，包括项目规范、结构、优化、三方等，与大家分享，一起修仙！ 接下来我会以自己写的两个项目为例，结合起来分析。代码已经上传github： Material Design风格项目 点击前往 喜欢就给个star^_^ UI、Base、网络等封装库项目 点击前往 喜欢也给个star喽 先上图来看看吧： 项目采用MVP+Retrofit+RxJava+Gson+Glide+Material Design设计 同时也使用了EventBus事件总线、GreenDao数据库、SurfaceView+MediaPlayer视频播放器等主要技术。 ok！项目就简单介绍到这里，接下来开始我们的修仙之路。 项目整体分析UI风格logo主题风格： Material Design 仿ios 主界面–侧拉 主界面–仿微信 选项卡等 技术方案整体分析项目，确定整体技术方案，之后的开发中按照技术方案执行，同时编写相关文档。 项目架构 网络框架 图片处理 数据处理/接口格式 三方使用：统计、推送、更新等 可行性分析邀请项目经理、技术负责人、产品经理、后端开发、测试等共同分析技术方案的可行性，并相应调整技术方案。 工期根据项目需求和技术方案，给出开发时长； 根据工期要求，可适当调整技术方案。 测试用例测试人员开始整理、编写测试用例和项目标准文档； 个人觉得开发人员应该参与到测试工作中，这样方便自己对业务逻辑和功能分析全面，也帮助测试人员分析项目功能和技术，便于写出更加全面的测试用例。 开发规范其实Android、Ios、Server等各端开发人员，都应该有完整的、严格的开发规范，这里我只说一下Android端的开发规范： 以自己项目为例，涉及到以下几项： 文档规范 资源命名规范 代码命名规范 代码注释规范 代码风格规范 服务器数据规范 等 文档重要有以下几个文档： 需求文档 产品原型图 完整UI图 接口文档 核心技术文档 重点逻辑文档 程序框架图 ER图、数据字典、类图等 测试文档 资源文件命名规范名字全部小写，最好不用数字，全部英文，单词中间下划线隔开 drawable、anim等文件夹下名称结构为“技术点模块点空间类型_功能名”结构，技术点主要有：selector、translate、alpha、scale等，模块名主要有：login、pay、mine、setting等，控件类型主要有：button、textview、imageview、dialog等，功能名主要有：findpwd、request、back、next等。 drawable-xhdpi等图片资源名称为“技术点模块点功能名”结构，技术点主要有：activity、fragment、item、include等，模块点主要有：login、setting、mine、pay等，功能名主要有：head、title、back、sure等。 layout布局名称为“技术点模块功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。 values布局名称为“技术点模块功能名”结构，技术点主要有：activity、fragment、item、include等，模块主要有：home、lesson、mine、loginregist等，功能名主要有：login、title、setting、pay、bar等。 代码命名规范包名包名为“根包名.技术点名.模块名”结构，全部小写 类名采用 大驼峰 命名法，单词直接拼接，所有单词首字母大写 类名为“业务模块名 执行操作名 技术点名”结构，业务模块名主要有：home、lession、net、login，pay等，操作名主要有：Get、Set、Request、Login等，技术点名主要有：Activity、Fragment、View、Adapter等。 普通变量采用 小驼峰 命名法，第一个单词首字母小写，其他单词首字母大写。 普通变量为“名字简写 类型 功能名”结构，名字简写有：js等，类型主要有：Int、Double、Boolean、String、Char等，功能名有：Login、Number、Content等。 常亮所有字母全部大写，中间下划线隔开 常量为“功能名_标识”结构，功能名主要有：LOGIN、REQUEST、PERSONINFO等，标识有SUCCESS、ERROR、URL等。 方法名名字能体现出功能即可。不再累赘重述。 数据/接口定义建议 服务器返回数据采用json格式 json数据中无数据，必须返回空数组或空字符串，不可返回null Android端使用gson或fastjson或jackson等三方解析工具解析 不建议使用官方JSONObject解析，容易出错 实体类属性名与json中字段名完全一致 json中字段名全部使用英文，不可英文、拼音夹杂 用户表识建议使用Cookie 建议使用POST解析，它对参数数量没有要求，也比较安全 为了传输安全，使用https请求 等 完善接口文档，建议每一版对应一个完整接口文档 屏幕适配安卓设备分辨率、屏幕尺寸五花八门，碎片化严重，重点对市面上主流的720 1280和1080 1920手机进行适配，同时对于其他类型手机也要适配。 关于屏幕适配，之前写过一个Android屏幕完美适配方案，点击前往，这里不再重复表述。 程序架构MVP 上图介绍：Contract：契约类，一个功能模块中View接口、Model接口和请求数据回调统一在对应模块的Contract中定义，便于管理。 ViewInterface： view层接口，定义了view中的UI操作 ModelInterface： model层接口，定义了model负责的数据操作方法，如请求接口，操作数据库等 CallbackInterface： model层操作数据完成后的回调 BasePersenter： Persenter父类，主要是对相关view的获取，销毁等操作 View： view层实现类，主要就是Activity或Fragment，负责UI展示和事件响应 Model： model层实现类，就是依据业务，请求对应接口或数据库，并将结果返给回调CallBack Persenter： persenter层类，负责业务逻辑处理，view将响应传给persenter，persenter负责调用model，并将结果返回给view供其展示 MVP：MVP模式相当于在MVC模式中又加了一个Presenter用于处理模型和逻辑，将View和Model完全独立开，在android开发中的体现就是activity仅用于显示界面和交互，activity不参与模型结构和逻辑。 使用MVP模式会使得代码多出一些接口但是使得代码逻辑更加清晰，尤其是在处理复杂界面和逻辑时，我们可以对同一个activity将每一个业务都抽离成一个Presenter，这样代码既清晰逻辑明确又方便我们扩展。当然如果我们的业务逻辑本身就比较简单的话使用MVP模式就显得，没那么必要。所以我们不需要为了用它而用它，具体的还是要要业务需要 现在比较流行MVVM架构，后续我会将MVVM总结，大家期待一下。。 package划分 如上：主体按功能模块划分，同一级的还有一些技术点，如adapter、util、pay等；在功能模块下，按照mvp模式，又分为contract、model、presenter、fragment和activity；而在其他技术点包下面同样也按功能模块划分。 总之，我们划分包时：以功能模块为主，以技术点为辅。 Base、Util、UI类封装Base类 BaseApplication BaseActivity BaseFragment BasePresenter 等 BaseApplication：主要进行一些例如：三方配置、热更新加载、文件配置、数据库配置等准备工作；同时也许定义全局性变量：如Application的Context、网络状态、主线程Looper、主线程Handler等。 BaseActivity：封装为抽象类，将各任务抽取成方法，有子类实现：比如findViewById(initView)、initData、setListener等； 对友盟统计的封装：因为友盟统计或别的统计需要在所有Activity的各生命周期方法中调用api，所以应该将其封装到BaseActivity中。 项目为MVP结构，所以设置了View和Presenter的泛型，如： 其中定义了屏幕宽高度等设备信息，也定义了BasePresenter对象、并抽取抽象方法，由子类返回其对应presenter。 BaseFragment：BaseFragment的封装如BaseActivity一样，添加View和Presenter的泛型和presenter对象，创建返回Presenter的抽象方法供子类事项； 创建createView(创建跟视图view)、initChildView(子view findViewById)、initData(加载数据)抽象方法 BasePresenter： BasePresenter封装如上：内置view的软引用，在Activity或Fragment的onResume中调用presenter的attachView方法，将view实例传给presenter；在Activity或Fragment的onDestroy或onStop方法中调用detachView方法解除与view的绑定；而getView方法则是presenter在model返回数据后调用来操作对应view的展示UI方法。 Utils类只列举一些常用的工具类： SharedPreferenceUtils ToastUtils StorageUtils FileUtils NetUtils deviceUtils DateUtils LogUtils AppUtils 等 UI类只列举一些常用的View类 下拉刷新、上拉加载 圆形ImageView 自定义Dialog Banner 自定义ScrollView 自定义RecyclerView 项目相关的自定义View 等 数据库关于数据库操作，之前一直是自己写：也就是SQLiteOpenHelper结合相关SQL操作工具类来实现数据库操作。 但随着业务逻辑的增加和复杂，需要进行大量的数据库操作时，编写大量的代码，既费时间、还会避免不了地出bug； 所以我们只介绍几款流行的数据库框架： GreenDao OrmLite LitePal Realm GreenDao：特点： 存取速度快; 支持数据库加密; 轻量级; 激活实体; 支持缓存; 代码自动生成 地址：https://github.com/greenrobot/greenDAO OrmLite：优点： 轻量级； 使用简单，易上手； 封装完善； 文档全面。 缺点： 基于反射，效率较低（本人还没有觉得效率低) 缺少中文翻译文档 jar包地址：http://ormlite.com/releases/ LitePal：LitePal 框架是郭大神开源的数据库框架，他的博客也比较详细的介绍了其用法。 地址：https://github.com/LitePalFramework/LitePal Realm： 易用：Ream 不是在SQLite基础上的ORM，它有自己的数据查询引擎。并且十分容易使用。 快速：由于它是完全重新开始开发的数据库实现，所以它比任何的ORM速度都快很多，甚至比SLite速度都要快。 跨平台：Realm 支持 iOS &amp; OS X (Objective‑C &amp; Swift) &amp; Android。我们可以在这些平台上共享Realm数据库文件，并且上层逻辑可以不用任何改动的情况下实现移植。 高级：Ream支持加密，格式化查询，易于移植，支持JSON，流式api，数据变更通知等高级特性 可视化 git地址 官网 自己项目中使用了GreenDao，它代码自动生成、存取速度快、支持加密、一个轻量级别的库，用着方便，推荐大家使用GreenDao。 图片处理之前有自己封装过图片处理框架，核心是使用HttpUrlConnection实现加载，仿LruCache（近期最少使用排序）算法实现图片缓存。 但我们用的最多的还是ImageLoader、Glide、Picasso和Fresco四大主流框架，接下来主要比较一下四个框架的各自特点： ImageLoader：优点: 多线程下载，线程管理。 多级缓存架构设计和策略，内存缓存，磁盘缓存，缓存有效性处理。 图片压缩，特效处理，动画处理。 复杂网络情况下下载图片策略，例如弱网络等。 内存管理，lru 算法、对象引用、GC回收等优化。 缺点： 时间久，官方不再维护，出现bug需要自己修复。 Glide：优点： 更易用，因为Glide的with方法不光接受Context，还接受Activity 和 Fragment，Context会自动的从他们获取。同时将Activity/Fragment作为with()参数的好处是：图片加载会和Activity/Fragment的生命周期保持一致，比如Paused状态在暂停加载，在Resumed的时候又自动重新加载。所以我建议传参的时候传递Activity 和 Fragment给Glide，而不是Context。 Glide可以加载GIF动态图。 Glide缓存的是跟ImageView尺寸相同的。Glide的这种方式优点是加载显示非常快。 默认使用HttpUrlConnection下载图片，可以配置为OkHttp或者Volley下载，也可以自定义下载方式。 默认使用手机内置存储进行磁盘缓存，可以配置为外部存储，可以配置缓存大小，图片池大小。 默认使用两个线程池来分别执行读取缓存和下载任务，都可以自定义。 缺点： Glide加载的图片质量要差于Picasso，这是因为Glide默认的Bitmap格式是RGB_565，比ARGB_8888格式的内存开销要小一半。 Picasso：特点： 在adapter中需要取消已经不在视野范围的ImageView图片资源的加载，否则会导致图片错位，Picasso已经解决了这个问题。 使用复杂的图片压缩转换来尽可能的减少内存消耗 自带内存和硬盘二级缓存功能 Fresco：优点： 最大的优势便在于5.0以下(最低2.3) bitmap的加载，在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem)，而且图片不显示时，占用的内存会自动被释放，这会使APP更加流畅，减少因图片内存占用而引发的OOM。5.0以后的系统默认存储在Ashmem区了 图片的渐进式呈现，图片先呈现大致的轮廓，然后随着图片下载的继续，逐渐成仙清晰的图片，这对于慢网络对说，用户体验更好。 支持加载Git动态图和Webp格式的图片。 缺点： 框架体积比较大，3M左右，会增加APK的大小。 总结：在项目开发中，要适当的选择图片框架，ImageLoader太老已过时，且官方不再维护，所以不再考虑使用ImageLoader；Picasso能做的，Glide都能做到，就是Glide的图片质量会稍差一些；而Fresco又体积偏大，但渐进式呈现，用户体验好。综上的话，一般项目建议使用Glide即可。 网络框架上一个项目中，网络框架自己封装：核心使用HttpUrlConnection实现，先封装请求参数相关类RequestVo，其中包含请求方式、url、参数、解析类、是否缓存、缓存时长等参数；缓存是将json字符串加密后与拼接过的url成对存储到File，并且设置有效时间，超过有效时间删除缓存并去网络请求，成功后重新保存。 但现在市面上最流行的是Retrofit+RxJava+Gson，接下来我们大概介绍一下： 添加依赖12345compile &apos;io.reactivex:rxjava:x.y.z&apos;compile &apos;io.reactivex:rxandroid:1.0.1&apos;compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.2&apos; 要注意：以上添加了Retrofit、RxJava和Gson依赖，版本号必须一致 登录Service1234567interface BaseService &#123; @GET(&quot;user/login&quot; ) Observable&lt;User&gt; login( @Query(&quot;username&quot;) String username, @Query(&quot;password&quot;) String password );&#125; login方法的返回值是Observable类型，就是RxJava中的被观察者。 网络请求1234567891011121314151617181920212223242526272829303132333435363738Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create() .addCallAdapterFactory(RxJavaCallAdapterFactory.create())//新的配置 .baseUrl(BASE_URL) .build();BaseService service = retrofit.create(BaseService.class);service.login(phone, password) //获取Observable对象 .subscribeOn(Schedulers.newThread())//请求在新的线程中执行 .observeOn(Schedulers.io()) //请求完成后在io线程中执行 .doOnNext(new Action1&lt;UserInfo&gt;() &#123; @Override public void call(User user) &#123; saveUserInfo(user);//保存用户信息到本地 &#125; &#125;) .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行 .subscribe(new Subscriber&lt;User&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; //请求失败 &#125; @Override public void onNext(User user) &#123; //请求成功 &#125;&#125;);``` RxJava + Retrofit 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。可以看到，调用了service的login方法后得到Observable对象，在新的线程中执行网络请求，请求成功后切换到io线程执行保存用户信息的动作，最后再切换到主线程执行请求失败onError()、请求成功onNext()。整体的逻辑十分清晰都在一条链中，就算还有别的要求还可以往里面添加，丝毫不影响代码的简洁。 注意：Retrofit在创建的时候添了一下代码addCallAdapterFactory(RxJavaCallAdapterFactory.create())1234567891011121314151617181920212223242526272829想了解更多关于RxJava，浏览[http://gank.io/post/560e15be2dca930e00da1083#toc_1](http://gank.io/post/560e15be2dca930e00da1083#toc_1)# 其他三方在自己的开发过程中，还用到了如EventBus、Zxing、Zbar、Volley、Gson、LeakCanary等三方框架；也用到了如友盟统计、微信、支付宝支付、三方登录、极光推送、tinker热更新等三方sdk；就不再一一列举，附上一张图，大家有时间多去学习、多去了解。![20171105150981301966614.png](http://ohtrrgyyd.bkt.clouddn.com/20171105150981301966614.png)# 混淆、加固、上线## 混淆大家可以参考我的[另一篇文章](http://blog.csdn.net/jiashuai94/article/details/77991077)混淆是上线前挺重要的一个环节。Android使用的ProGuard，可以起到压缩，混淆，预检，优化的作用。### 坚持以下几项原则：- 使用三方依赖，在混淆文件中添加官方提供的混淆代码，官方没有就google；- 实体类不混淆，因为实体类涉及到与服务端的交互，各种gson的交互如此等等，是要保留的；- 与js互调的类不混淆；- 与反射有关的类不混淆 等。### 具体语法： -optimizationpasses 5 // 代码混淆的压缩比例，值在0-7之间-dontusemixedcaseclassnames // 混淆后类名都为小写-dontskipnonpubliclibraryclasses // 指定不去忽略非公共的库的类-dontskipnonpubliclibraryclassmembers // 指定不去忽略非公共的库的类的成员-dontpreverify // 不做预校验的操作 -verbose-printmapping proguardMapping.txt // 生成原类名和混淆后的类名的映射文件 -optimizations !code/simplification/cast,!field/,!class/merging/ // 指定混淆时采用的算法-keepattributes Annotation,InnerClasses // 不混淆Annotation-keepattributes Signature // 不混淆泛型-keepattributes SourceFile,LineNumberTable // 抛出异常时保留代码行号-keep class XXXX // 保留类名不变，也就是类名不混淆，而类中的成员名不保证。当然也可以是继承XXX类的所有类名不混淆，具体代码不贴了，重在理解。-keepclasseswithmembers class XXXX // 保留类名和成员名。当然也可以是类中特定方法，代码不贴了，理由同上。``` 加固： 加固一般都使用三方加固：如果apk上百度应用市场，则使用百度加固，其他情况建议使用360加固，当然，加固前一定是混淆过的、并且签过名的apk。 360加固还提供了一些其他服务，可根据项目情况操作（是需要花钱的..） 上线： 也就是我们所说的发版，当你的apk测试通过，混淆过、签名过、也加固了，可以发版了。 每个公司上线的市场要求不同，一般主要有应用宝、360、豌豆荚、百度市场、小米市场、华为市场、魅族市场等，当然还有官网了。 发版时需要：apk当然要有、logo（第一次上线）、应用简介（第一次上线）、版本号、更新功能、介绍图、官网地址（第一次上线）等。 ok，到这里，我们的一个阶段算是完成了，接下来还会有更多的业务和bug等着大家，哈哈！希望这篇文章能对大家有一点点帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android机型适配]]></title>
      <url>%2F2017%2F09%2F03%2Fandroid-ui-adapt%2F</url>
      <content type="text"><![CDATA[多机型 UI 适配在 Android 开发的工作日常中，UI 适配是一件比较重要的事情。一般开发新的功能，有新的页面，最终开发完成发布之前，都需要让设计师来审 UI 效果。 而有时候，明明我们已经在一款标准的 3 倍手机上，做到了让设计师小姐姐满意的效果，但是当换了另外一台手机的时候，效果又不那么如意。 传统的做法是，拿到效果不对的手机，单独适配看看是不是哪里布局写的不对导致效果不正确，然后改正它。但是总能碰到我们拿不到真实设备的情况。 本文就介绍一个命令，可以修改你当前设备的参数，来模拟出目标设备的显示效果，让你独立就把多机型 UI 效果确认的事情给做了。 WM 命令什么是 WM 命令说的这么厉害，实际上需要使用的就是一行 wm 命令，可以通过 adb shell 来操作它。 wm 命令主要用来帮助我们修改一些屏幕的参数，先来看看它的文档。使用 adb shell wm 命令，可以方便的查看 wm 的文档描述 可以看到，wm 命令可以帮助我们修改当前设备的 size 、 density 等参数，而这两个参数就是决定了当前设备的显示效果。 WM 的命令从上面的文档可以看出，它其实支持的命令还是挺多的，但是有一些根本用不上，是需要系统权限的，所以正常来说我们是无法使用的。那么，还是介绍几个比较实用的命令。 以下例子都是在一款标准 density 为 3 的设备上运行的，屏幕像素为 1080px * 1920px。 wm sizewm size 命令，可以用来查询和修改当前设备的尺寸，如果想要修改尺寸，可以使用 px 或者 dp 为单位（默认为 px），使用 x 进行连接，这个其实看看 wm size 的输出，你就清楚了。 在这里的例子中，做了几件事情： 使用 wm size 命令查看当前设备的尺寸。 使用 wm size 命令将当前尺寸修改成了 1000x2000。 再次使用 wm size 命令查看当前设备的尺寸。 最后使用 wm size reset 命令，将屏幕尺寸还原。 再用 wm size 命令，查看还原后的尺寸。 这几个步骤就已经涵盖了 wm size 命令的所有使用步骤，可以使用它查看当前屏幕尺寸，并且修改屏幕尺寸和还原它。 wm densitywm density 命令，可以用来查看和修改当前设备的 density 参数。 使用起来很简单，直接上命令了。 在这个例子中，我做了几件事情： 使用 wm density 查看当前设备的 density。 在使用 wm density 命令，修改当前设备的 density 为 420。 然后再使用 wm density 查看修改后的参数。 最后使用 wm density reset 将设备的 density 还原。 最后再查看一下还原后的值。 wm overscanwm overscan 命令，可以修改当前设备的屏幕内边距。其实我觉得这个命令没什么用处，但是还是演示一下如何使用。 12adb shell wm overscan 20,20,20,20adb shell wm overscan reset 在这个例子中，做了几件事情： 使用 wm overscan 修改边距为 20 。 然后使用 wm overscan reset 将其还原。 WM 命令的原理wm 命令的逻辑非常的简单，它实际上是和 WindowManagerService 进行交互，通过 WMS 来修改屏幕相关的一些参数。 这里就不介绍完整的 wm 源码了，就以一个方法举例来看看 wm 的逻辑。这里就以 wm size命令举例好了。 首先，看看 wm 命令的入口。 12345678910111213141516171819202122232425@Overridepublic void onRun() throws Exception &#123; mWm = IWindowManager.Stub.asInterface(ServiceManager.checkService(Context.WINDOW_SERVICE)); if (mWm == null)&#123; System.err.println(NO_SYSTEM_ERROR_CODE); throw new AndroidException("Can`t connect to window manager;is the system running?"); &#125; String op = nextArgRequired(); if (op.equals("size")) &#123; runDisplaySize(); &#125; else if (op.equals("overscan"))&#123; runDisplayOverscan(); &#125; else if (op.equals("scaling"))&#123; runDisplayScaling(); &#125; else if (op.equals("screen-capture"))&#123; runSetScreenCapture(); &#125; else if (op.equals("dismiss-keyguard"))&#123; runDismissKeyguard(); &#125; else &#123; showError("Error: unknown command ` " + op + "`"); return; &#125;&#125; 这里会初始化 mWm ，并且根据输入的参数，调用不同的方法，如果输入的是 size ，则会调用 runDisplaySize() 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void runDisplaySize() throws Exception &#123; String size = nextArg(); int w,h; if (size == null)&#123; Point initialSize = new Point(); Point baseSize = new Point(); try &#123; mWm.getInitialDisplaySize(Display.DEFAULT_DISPLAY, initialSize); mWm.getBaseDisplaySize(Display.DEFAULT_DISPLAY, baseSize); System.out.println("Physical size:" + initialSize.x + "x" + initialSize.y); if (!initialSize.equals(baseSize))&#123; System.out.println("Override size:" + baseSize.x + "x" + baseSize.y); &#125; &#125; catch (RemoteException e)&#123; &#125; return; &#125; else if ("reset".equals(size))&#123; w = h = -1; &#125; else &#123; int div = size.indexOf('x'); if (div &lt;= 0 || div &gt;= (size.length() - 1))&#123; System.err.println("Error: bad size" + size); return; &#125; String wstr = size.substring(0,div); String hstr = size.substring(div + 1); try &#123; w = parseDimension(wstr); h = parseDimension(hstr); &#125; catch (NumberFormatException e)&#123; System.err.println("Error: bad number" + e); return; &#125; &#125; try &#123; if (w &gt;= 0 &amp;&amp; h &gt;= 0)&#123; mWm.setForcedDisplaySize(Display.DEFAULT_DISPLAY, w, h); &#125; else &#123; mWm.clearForcedDisplaySize(Display.DEFAULT_DISPLAY); &#125; &#125; catch (RemoteException e) &#123; &#125;&#125; 在 runDisplaySize() 方法中，会先判断 size 命令后面有没有跟其它参数，如果没有，则认为是一次查询操作，会将查询到的结果输出。 而如果是 reset 方法的话，就将 w 、h 这两个代表宽高的值，设置为 -1，最终会通过 mWm.clearForcedDisplaySize() 方法，将屏幕的 size 还原。 否者就从输入的参数中，通过 x 进行分割，拿到我们输入的宽高。最终通过 mWm.setForcedDisplaySize() 方法，将当前屏幕的 size 修改成我们输入的结果。 在设置size 的时候，还会通过 parseDimens() 方法，重新计算一下输入的尺寸。 private int parseDimension(String s) throws NumberFormatException { if (s.endsWith(“px”)) { return Integer.parseInt(s.substring(0, s.length() - 2)); } if (s.endsWith(“dp”)){ int density; try { density = mWm.getBaseDisplayDensity(Display.DEFAULT_DISPLAY); } catch (RemoteException e) { density = DisplayMetrics.DENSITY_DEFAULT; } return Integer.parseInt(s.substring(0,s.length() - 2)) * density / DisplayMetrics.DENSITY_DEFAULT; } return Integer.parseInt(s);} 从这里可以看出，它支持两个尺寸，px 和 dp ，如果如果不指定尺寸，则默认认为是 px 。 到这里就完成了一次通过 wm size 命令，修改设备屏幕参数的全过程，跟多细节可以自行查阅源码。 源码的在线地址： androidxref.com/7.1.1_r6/xr… 实施修改设备参数既然已经讲清楚 wm 命令的所有细节了，那么我们只需要拿到我们需要适配的设备的 size 和 density。就可以在我们自己的设备上模拟出对应的效果。 我这里收集了一些比较常用的设备参数，可以供大家参考一下。 魅族MX3：440，1080x1800 一加5：420，1080x1920 红米NOTE，320，720x1280 华为MATE7，480，1080x1812 MOTO-G5，480，1080x1920 Moto-tx1095，432，1080x1790 Nexus5x，420，1080x1794 Nexus6p，560，1440x2392 奇酷360，460，1080x1920 VivoX5，320，720x1280 当然，最重要的是拿到公司各种 CEO、CTO、CxO 正在使用的手机参数，进行一波适配，哈哈。 下面，我们随便挑两个设备的参数进行修改，然后看看运行后的效果。 命令如下: // 修改成 一加5 adb shell wm density 420 adb shell wm size 1080x1920 // 修改成 Moto-tx1095 adb shell wm density 432 adb shell wm size 1080x1790 下面，从做到右，分别是原本的尺寸、一加5、Moto-tx1095。 其实看着差异不大，只能说桌面布局写的挺好的，所以说，如果布局写的好的话，是可以避免在不同设备上看着很明显的不同的问题 ，就像现在这样。 题外话实际上 wm 命令，也是有一些其它问题的，例如有时候通过 wm 命令修改 UI 的的时候，刷新会不及时，会卡顿，所以选择一个性能比较好的手机是一个缓解的办法。或者修改参数之后，退出 App 重新进也是一个不错的办法。 如果调整到一个太特殊的参数，例如 200x1000 这种，可能渲染起来会很奇怪。但是如果只是做一些常规设备参数的修改，只要修改值在合理的范围内，一般都是可以的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android学习路线]]></title>
      <url>%2F2017%2F09%2F02%2Fandroid-learning-path%2F</url>
      <content type="text"><![CDATA[前言Android学习路线从4个阶段来对Android的学习过程做一个全面的分析:Android初级、中级、高级以及资深工程师。只针对Android应用开发，不针对Rom开发和逆向工程等。方便起见虚拟“小D”为成长人物进行描述。 初级工程师小D之前完全没接触过Android开发，对编程基础、数据结构、C语言都有一定基础，Java语法什么的也都掌握的比较好，并不会搞Android。 首先需要购买一本Android入门的书籍（现在更推荐直接看视频教程结合网上教程动手练习），为了更快地学习Android，小D业余时间也都用来一边看书一边照着书中的例子敲代码，结果2周时间小D就把这本书学了一遍。看完这本书后对Android的历史、结构、代码规范等都有了一个大概的了解，可以写出一些简单的Activity。这个时候在小D眼里，Android开发很简单很好玩，通过在xml中摆放一些按钮文本框什么的就可以做一些界面了。 小D开始跟着他的技术导师做需求，一些简单的小需求不在话下了。突然有一天来了一个需求，该需求要求在Activity中为一个button加一个动画效果，小D慌了：“完全没接触过，书上也没有讲，怎么办呢？”小D冷静了下，搜索“Android 动画”，打开前几个链接，恍然大悟，照着网上的例子把需求给实现了。 后来导师告诉他：“学好Android，官方文档是必须看的，既全面又权威”。然后小D如获至宝，花了一年时间把上面的guide和training都看了一遍，并且他还动手抄了几个小例子。 有一天，小D又需要做一个动画相关的需求，又搜索“Android 动画”，突然他楞了一下：”总不能每次写动画都要搜索吧！“，于是他在CSDN开了一个博客，把动画相关的知识点都写上去，为的是后面再写动画相关的代码就不用去搜了，事实如何呢？后面再写动画相关的代码，的确不用再去搜了，因为通过写一篇动画博客，他把动画相关的细节都已经记住了，这样他就可以不用再去参考任何文档了，后来小D还学会了把一些琐碎的不方便放在博客上的东西写到了笔记上面，什么时候忘了10秒钟以内都可以快速找回来，而不是花10分钟去再次搜索一遍。 总结：Android入门的时候，需要有一本入门书（或者视频教程），好好学习书中的内容，同时花一年时间把Android官方文档中的training和guide看一遍，同时通过写博客和记笔记的方式来做总结，建议让自己的每篇博客都有价值些。通过一年时间的学习，相信每个人都可以达到中级工程师的水平。 技术要求： 基本知识点比如四大组件如何使用、如何创建Service、如何进行布局、简单的自定义View、动画等常见技术 书籍推荐《第一行代码 Android》、《疯狂Android》 中级工程师小D经过一年的努力学习终于成为Android中级工程师了。到了中级工程师，已经可以在公司里干很多体力活了，但是一些很重要的任务小D还不能一个人承担起来，这个时候小D需要学习的内容就很多了，如下所示： AIDL：熟悉AIDL，理解其工作原理，懂transact和onTransact的区别； Binder：从Java层大概理解Binder的工作原理，懂Parcel对象的使用； 多进程：熟练掌握多进程的运行机制，懂Messenger、Socket等； 事件分发：弹性滑动、滑动冲突等； 玩转View：View的绘制原理、各种自定义View； 动画系列：熟悉View动画和属性动画的不同点，懂属性动画的工作原理； 懂性能优化、熟悉mat等工具 懂点常见的设计模式 学习方法阅读进阶书籍，阅读Android源码，阅读官方文档并尝试自己写相关的技术文章，需要有一定技术深度和自我思考。在这个阶段的学习过程中，有2个点是比较困扰大家的，一个是阅读源码，另一个是自定义View以及滑动冲突。如何阅读源码呢？这是个头疼的问题，但是源码必须要读。阅读源码的时候不要深入代码细节不可自拔，要关注代码的流程并尽量挖掘出对应用层开发有用的结论。另外仔细阅读源码中对一个类或者方法的注释，在看不懂源码时，源码中的注释可以帮你更好地了解源码中的工作原理，这个过程虽然艰苦，但是别无他法。如何玩转自定义View呢？我们要透过现象看本质，更多地去关注自定义view所需的知识点： 搞懂view的滑动原理 搞懂如何实现弹性滑动 搞懂view的滑动冲突 搞懂view的measure、layout和draw 然后再学习几个已有的自定义view的例子 最后就可以搞定自定义view了，所谓万变不离其宗 大概再需要1-2年时间，即可达到高级工程师的技术水平。我个人认为通过《Android开发艺术探索》和《Android群英传》可以缩短这个过程为0.5-1年。注意，达到高级工程师的技术水平不代表就可以立刻成为高级工程师（受机遇、是否跳槽的影响），但是技术达到了，成为高级工程师只是很简单的事。 技术要求： 稍微深入的知识点AIDL、Messenger、Binder、多进程、动画、滑动冲突、自定义View、消息队列等 书籍推荐《Android开发艺术探索》、《Android群英传》 高级工程师小D成为了梦寐以求的高级工程师。这个时候小D的Android水平已经不错了，但是小D的目标是资深工程师，小D听说资深工程师月薪可以达到30k+。为了成为Android资深工程师，需要学习的东西就更多了，并且有些并不是那么具体了，如下所示： 继续加深理解”稍微深入的知识点“中所定义的内容 了解系统核心机制： 了解SystemServer的启动过程 了解主线程的消息循环模型 了解AMS和PMS的工作原理 能够回答问题”一个应用存在多少个Window？“ 了解四大组件的大概工作流程 … 基本知识点的细节 Activity的启动模式以及异常情况下不同Activity的表现 Service的onBind和onReBind的关联 onServiceDisconnected(ComponentName className)和binderDied()的区别 AsyncTask在不同版本上的表现细节 线程池的细节和参数配置 … 熟悉设计模式，有架构意识 学习方法这个时候已经没有太具体的学习方法了，无非就是看书、看源码和做项目，平时多种总结，尽量将知识融会贯通从而形成一种体系化的感觉。同时这个阶段对架构是有一定要求的，架构是抽象的，但是设计模式是具体的，所以一定要加强下设计模式的学习。关于设计模式的学习，推荐《Android 源码设计模式解析与实战》，既可以学习设计模式，又可能体会到Android源码中的设计思想。 技术要求： 稍微深入的知识点 系统核心机制 基本知识点的细节 设计模式和架构 书籍推荐《Android开发艺术探索》、《Android 源码设计模式解析与实战》、《Android内核剖析》 资深工程师更多了解不同业务的架构问题，内核源码设计原理，整理并开源自己的组件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android学习目录]]></title>
      <url>%2F2017%2F09%2F02%2Fandroid-catalog%2F</url>
      <content type="text"><![CDATA[基础知识 Android学习路线 Android学习资源 Java基础 Java字符串(String、StringBuilder、StringBuffer)Java线程池(newFixedThreadPool、newSingleThreadExecutor、newCacheThreadPool) newFixedThreadPool：newFixedThreadPool,创建固定大小的线程池，poolCoreSize和maxPoolSize 相等，到达coreSize,则将新的任务放到缓存队列，有线程执行完毕，直接去取。 newSingleThreadExecutor：newSingleThreadExecutor,创建一个单线程的线程池，核心池的大小和最大池大小都为1. newCacheThreadPool：newCacheThreadPool,无大小限制的线程池，提交一个任务就创建一个线程执行。 Java集合Collection: List: LinkedList ArrayList Vector Set HashSet TreeSet Map: HashMap TreeMap HashTable Java内存模型Java 内存模型这一块非常重要，因为它涉及到我们程序的性能，我们需要知道，内存是如何分配的，成员变量、静态变量、局部变量、对象等各自分配到哪一个区：栈内存、堆内存 数据结构面向对象思想OOP的的三大特性：封装、继承、多态。 设计模式程序设计6大原则 单一职责原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 开闭原则 Android StudioAndroid Studio插件 Android Studio快捷键 Android SDKActivityAndroid-启动Acivity的工作流程 ServiceBroadcastReceiverContentProviderStatusBarAndroid-StatusBar详细学习 FragmentDialogFragmentAndroid-DialogFragment详细学习 UIAndroid-XML参数详细了解 LayoutAndroid-Layout详细学习 FrameLayoutLinearLayoutTableLayoutGridLayoutRelativeLayoutDrawerLayoutSlidingPaneLayoutCoordinatorLayoutAndroid-CoordinatorLayout ViewAndroid-View的工作流程 WidgetsTextViewEditTextAndroid-EditText详细学习 Android-WindowSoftInputMode详细学习 ButtonRadioButtonCheckBoxSwitchToggleButtonImageButtonImageViewAndroid-ImageView详细学习 ProgressBarSeekBarRatingBarSpinnerWebViewContainersRadioGroupListViewGridViewExpandableListViewScrollVeiwTabHostSlidingDrawerGalleryVideoViewDialerFilterRecyclerViewAndroid-RecyclerView详细学习 CardViewPopuWindowAndroid-PopupWindow详细学习 DialogFragmentDate&amp;TimeTextClockAnalogClockChronometerDatePickerTimePickerCalendarViewExpertSpaceCheckedTextViewQuickContactBadgeExtractEditTextAutoCompleteTextViewMultiAutoCompleteTextNumberPickerZoomButtonZoomControllerGestureOverlayViewSurfaceViewTexttureViewStackViewViewStubAndroid-ViewStub详细学习 ViewAnimatorViewFlipperViewSwitcherImageSwitcherTextSwitcherAdapterViewFlipperViewPagerAndroid-Viewpager详细学习 CustomincludefragmentrequestFocusCustom Viewextend system Viewcombination Viewextend ViewAndroid-View详细学习 Android自定义控件——绘图 ViewTreeObserverAndroid-getViewTreeObserver() ColorFilterAndroid-ColorFilter详细学习 XfermodeAndroid-Xfermode详细学习 Paint Android-Paint详细学习 MatrixAndroid-Matrix详细学习 ScrollerAndroid-Scroller详细学习 ViewConfigurationAndroid-ViewConfiguration解析 MotionEventAndroid-MotionEvent解析 VelocityTrackerAndroid-VelocityTracker详细学习 SpannableStringAndroid-SpannableString设置复合文本 animationAndroid动画详细学习 Android切换动画 ViewAnimationTweenAnimationFrameAnimationPropertyAnimationValueAnimatorObjectAnimatorAnimatorSetVectorAnimationSVGVectorDrawableAnimatedVectorDrawableResourceassetsAssetManagerresanimanimatorcolordrawableinterpolatorlayoutmenurawvaluesarraysattrsboolscolorsstringstylesOpenGLBitmapBitmapFactoryAndroid-BitmapFactory详细学习 Material Design 系列Toolbar的使用Android-ToolBar详细学习 AppbarLayout+CollapsingToolbarLayoutAndroid-AppBarLayout&CollapsingToolbar&Toolbar组合使用 Android-AppBarLayout Behavior 相关： BottomSheetBehavior BottomSheetDialog SwipeDismissBehavior 自定义Behavior TextInputLayout + TextInputEditTextTabLayoutBottomNavigationViewCardView 阴影卡片Snackbar , FloatActionButton通信HttpSocketBluetoothNFCHeadsetUSB数据持久化SqliteSQLiteOpenHelperContentProviderFileAndroid存储方式以及路径API InternalStorageExternalStorageSharedPreferences多线程Android Thread 性能Android性能优化 UI优化布局层次结构Android界面性能调优 抽象布局使用HierarchyViewerLint工具内存优化OOMANR分析Heapadb shellAndroid-ADB命令 dumpsys meminfoshowmapTraceViewDalvik日志logcatMAT电量优化流量优化调试(Debug)Android-Debug LogcatadbHierarchyViewerTraceViewHeapLint适配OS Versionmin SDKUI界面适配Android界面适配 Android屏幕适配 drawable测试MonkeyMonkeyRunnerJUnitRobotiumAppiumAthrun(TMTS)UIAutomator安全服务器安全通信安全与服务器通信组件间通信反编译Android反编译 Android-获取sha1 Android-smali文件格式 数据加密数据验签代码混淆WebView/JS安全调用MD5、DES、RSA、https、证书、权限NDKAndroid-NDK JNIC语言C++Android 多媒体相机开发使用自带的相机APP拍照系统相册选择照片系统相机或相册获取的照片裁剪使用相机API 开发相机: Android 5.0 （API 21 ）以下 使用Camera API Android 5.0 以上使用 Camera2 API 自定义相册开发自定义裁剪界面视频开发视频播放 MediaPlayer VideoView 视频编解码音频开发AudioPlayer音乐播放器Android权限配置Gradle自定义Gradle插件Gradle多渠道打包手机功能电话联系人通话记录短/彩信AudioSD卡感应器加速方向重力光线陀螺仪磁场接近温度压力线性加速度旋转第三方扩展地图语音识别支付统计分析广告其他IntentAndroidManifestAIDLWifiAndroid-WiFi 国际化响应式编程Android权限机制 其他Android响应式编程 Android MVP模式 Android冷启动实现APP秒开 AndroidStudio关联Bitbucket Android-Issues Android-基类实现 Android组件化学习 LibraryAndroid-开发中常用的支持库 Android高效开发工具库 Android快速开发框架 Android-Picasso图片框架 Android-GreenDao3.2.0的使用 Android-EventBus3.0的使用 Android-常用的库 Android-Fresco详细学习 Android-RxJava详细学习 Android-Gson详细学习 Android-DataBinding详细学习 实现Android自定义锁屏页 Android自定义皮肤]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-酷炫的Activity切换动画]]></title>
      <url>%2F2017%2F08%2F31%2Fandroid-activity-handoff-animation%2F</url>
      <content type="text"><![CDATA[前言毫无疑问，动画效果能提高用户体验。我们平时使用最多的动画基本上是属性动画和补间动画了，属性动画很强，基本能定制我们想要的动画，但是你是否知道，API 21（5.0）后系统内置了Activity之间的切换动画，而且非常酷炫，今天我跟大家一起分享一下。我们知道，在两个Activity之间切换，我们一般会写出类似下面的代码： 123Intent intent=new Intent(this,SecondActivity.class);startActivity(intent);overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim); 在API 21以后，我们可以使用内置的Activity切换动画啦。但是这样也就意味着只能兼容5.0之后的系统，我们先看一个效果图来压压惊： 先看看第一个Activity，退出时用的是Explode效果，第二个Activity进入时用的是Slide效果。这些效果无需我们自己去实现，都是内置的效果，我们所编写的代码几乎为零，接下来我们一一看看内置了哪些效果。 使用内置Activity之间切换动画代码步骤Activity之间的切换期间，对于某个Activity来说，无非就是“进入”和“退出”两种情景下的动画。而“进入”分为“第一次进入Activity”和“返回当前Activity”这两种情况。另外系统还提供了一种动画，即共享元素，这是让两个Activity中的View有个过渡切换的效果。执行动画的状态如下所示： enter：用于决定第一次打开当前Activity时的动画exit : 用于决定退出当前Activity时的动画reenter: 用于决定如果当前Activity已经打开过，并且再次打开该Activity时的动画shared elements:用于决定在两个Activity之间切换时，指定两个Activity中对应的View的过渡效果 那么应该怎么去使用Activity切换动画呢？我们看看使用步骤： 首先在setContentView()之前执行，用于告诉Window页面切换需要使用动画getWindow().requestFeature(Window.FEATURE_CONTENT_TRANSITIONS); 接下来就是加载切换动画其中R.transition.explode就是要执行的动画，是在res/transition目录下的xml文件，我们使用的是系统内置的Explode效果动画，关于怎么去写explode.xml，我们接下来小节去讲解。Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode); 告诉Window，当前的Activity在什么情况下使用上面的动画上面我们创建好了切换动画，接下来就是要告诉当前窗口，在什么情况下去使用动画效果啦，你可以根据你的需求在不同的切换情景中选择不同的效果: 123456//退出时使用getWindow().setExitTransition(explode);//第一次进入时使用getWindow().setEnterTransition(explode);//再次进入时使用getWindow().setReenterTransition(explode); 当然了，你也可以不使用代码的方式，直接在你使用的主题标签里添加类似如下代码： 123&lt;item name="android:windowExitTransition"&gt;@transition/explode&lt;/item&gt;&lt;item name="android:windowEnterAnimation"&gt;@transition/explode&lt;/item&gt;&lt;item name="android:windowReenterTransition"&gt;@transition/explode&lt;/item&gt; 调用startActivity跟我们之前使用的startActivity(Intent intent);不同，这里多了一个参数Bundle，我们是先通过makeSceneTransitionAnimation函数创建一个ActivityOptions对象，再将其转为Bundle对象:startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(this).toBundle());整体使用步骤就是以上这些，是不是很简单？接下来我们去学习如何使用内置动画~ Explode效果Explode即爆炸效果，使用Explode效果很简单，在res/transition目录下新建一个xml文件(如explode.xml)，内容如下： 12&lt;explode xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" /&gt; 其中duration表示Explode动画持续时间，由于是Activity之间的切换，最好不要把动画时间设置过大，一般取200~500毫秒比较合适。我们看看效果吧~ Slide效果即滑动效果，使用Slide跟Explode类似，都是在res/transition目录下新建一个xml文件(如slide.xml)，内容如下： 123&lt;slide xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@android:interpolator/decelerate_cubic" android:slideEdge="end"/&gt; 其中，slideEdge表示起始滑动的侧边位置，end表示右侧，start表示左侧，top表示顶部，bottom表示底侧，各种效果你可以亲自试试~，一起看看滑动效果吧 GIF 效果看的比较死板，可以下载我的源码实际运行一下~ 如果你不希望顶部的状态栏以及底部的导航栏一起执行动画，可以在xml中指定： 12345678&lt;slide xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@android:interpolator/decelerate_cubic" android:slideEdge="end"&gt; &lt;targets&gt; &lt;target android:excludeId="@android:id/navigationBarBackground" /&gt; &lt;target android:excludeId="@android:id/statusBarBackground" /&gt; &lt;/targets&gt;&lt;/slide&gt; Fade效果Fade效果即淡化效果，使用淡化效果依然是很简单，在res/transition目录下新建一个xml文件(如fade.xml)，内容如下： 12&lt;fade xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" /&gt; Fade效果就是将View逐步淡化，这里不再贴效果啦，想看效果的可以下载我的源码运行看看~ Shared Element效果即共享元素效果，与前面几种效果不同的是，共享元素效果是将前面一个Activity的某个子View与后面一个Activity的某个子View之间有过渡效果，我们先看看动态图感受一下： 从动态图中看到，第一个Activity的小绿色方块到第二个Activity大绿色方块有个过渡效果~ 接下来我们看看如何实现这个效果： 1.将两个Activity中需要过渡的View加上android:transitionName属性 两个View的android:transitionName属性取值要一致，比如：第一个Activity布局： 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:id="@+id/firstSharedView" android:layout_width="100dp" android:layout_height="100dp" android:background="#00cc00" android:onClick="onClick" android:transitionName="sharedView" /&gt;&lt;/RelativeLayout&gt; 第二个Activity布局： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;View android:layout_width="match_parent" android:layout_height="300dp" android:layout_alignParentBottom="true" android:background="#00cc00" android:onClick="onClick" android:transitionName="sharedView" /&gt;&lt;/RelativeLayout&gt; 两个绿色的View都添加android:transitionName属性，并且取名一致。 2.调用startActivityActivityOptions的makeSceneTransitionAnimation函数第一个参数Activity没啥解释的，第二个参数就是第一个Activity中的View对象，第三个参数就是两个Activity的View的 android:transitionName属性的值。 startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, firstSharedView,&quot;sharedView&quot;).toBundle()); 现在就可以实现这种Shared Element效果啦，但是可能你会想实现同时让两个View有这样的效果，可是makeSceneTransitionAnimation函数却只能让我们设置一个View和一个transitionName属性。如何添加多个呢？接下来我们一起学习让多个View同时有切换效果。 除了需要将两个Activity中需要过渡的View对应取相同的名称外，还需将需要过渡的View和transitionName取值对应的String这两个对象封装到一个Pair对象中： 12Pair first = new Pair&lt;&gt;(firstSharedView, ViewCompat.getTransitionName(firstSharedView));Pair second = new Pair&lt;&gt;(secondSharedView, ViewCompat.getTransitionName(secondSharedView)); 然后调用ActivityOptionsCompat类的makeSceneTransitionAnimation的另一个重载函数makeSceneTransitionAnimation(Activity activity,Pair&lt;View, String&gt;... sharedElements)，第一个参数不解释，后面参数为不定长度的形参，即你可以传递任意多个Pair对象。 1ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, first, second); 最后调用startActivity 123456789101112131415161718 ActivityCompat.startActivity(this,intent, transitionActivityOptions.toBundle());``` 说了这么多步骤，我们来看看效果吧~![20171015150799903533027.gif](http://ohtrrgyyd.bkt.clouddn.com/20171015150799903533027.gif)## 1 自定义 Shared Element切换动画如果你对内置的 Shared Element还不够满意，你还可以定制View的过渡切换效果。步骤如下：### 创建一个View的过渡移动的轨迹路径PathMotion类我们可以创建ArcMotion对象，ArcMotion是PathMotion子类，是个曲线路径。想要了解更多ArcMotion可以查看[【ArcMotion官方文档】](https://developer.android.com/reference/android/transition/ArcMotion.html)```javaArcMotion arcMotion = new ArcMotion();arcMotion.setMinimumHorizontalAngle(50f);arcMotion.setMinimumVerticalAngle(50f); 定义ChangeBounds类我们自定义一个继承ChangeBounds的类，主要重写createAnimator函数，即创建你要执行的动画。这个函数由3个参数： 1.ViewGroup sceneRoot：屏幕根View，即DecorView，第二个Activity的DecorView。2.TransitionValues startValues：属性动画的起始属性值，TransitionValues 对象内部有各Map类型的属性values，用于保存需要执行属性动画的属性。这个里面的属性值是在函数captureStartValues里放置，因此你可以重写captureStartValues函数，并把你自定义的属性动画中的属性放进去。3.TransitionValues endValues ：与startValues类似，表示属性动画结束时的属性值。可以通过重写captureEndValues函数，并把你自定义的属性动画里面的最终属性值放进去。 我们先看一个最简单的示例： 12345678910111213141516171819202122232425package com.hc.util;import android.animation.Animator;import android.transition.ChangeBounds;import android.transition.TransitionValues;import android.view.ViewGroup;import android.view.animation.AnimationUtils;public class CustomChangeBounds extends ChangeBounds &#123; @Override public Animator createAnimator(final ViewGroup sceneRoot, TransitionValues startValues, final TransitionValues endValues) &#123; Animator changeBounds = super.createAnimator(sceneRoot, startValues, endValues); if (startValues == null || endValues == null || changeBounds == null) return null; changeBounds.setDuration(300); changeBounds.setInterpolator(AnimationUtils.loadInterpolator(sceneRoot.getContext(), android.R.interpolator.fast_out_slow_in)); return changeBounds; &#125;&#125; 看看效果吧~ 最后，再献上源码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-smali文件格式]]></title>
      <url>%2F2017%2F08%2F30%2Fandroid-smali%2F</url>
      <content type="text"><![CDATA[HelloWorld首先写一个 HelloWorld 类： 1234567package jiuyou.hello.info;public class HelloWorld &#123; public static void main(String[] args)&#123; System.out.println("hello world"); &#125;&#125; 然后生成 apk 再用 apktool 工具转成 smali 文件： 12345678910111213141516171819202122232425262728293031.class public Ljiuyou/hello/info/HelloWorld; #定义类名.super Ljava/lang/Object; #定义父类.source &quot;HelloWorld.java&quot; #源文件名# direct methods #直接方法 （# virtual methods 为虚方法）.method public constructor &lt;init&gt;()V #构造函数 .locals 0 #方法中使用到的局部变量个数 .prologue #代码起始指令 .line 8 #源代码所在行数 invoke-direct &#123;p0&#125;, Ljava/lang/Object;-&gt;&lt;init&gt;()V #调用父类构造方法 return-void #返回空.end method #方法结束.method public static main([Ljava/lang/String;)V #对应 main 方法 .locals 2 #方法包含两个局部 v0,v1 .param p0, &quot;args&quot; # [Ljava/lang/String; # main 方法的参数 agrs 标记为 p0 .prologue #代码起始指令 .line 10 sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream; #将 System.out 这个静态变量赋给 v0 const-string v1, &quot;hello world&quot; #构造字符串 #方法调用（调用 v0 的方法 println ，v1 是参数） invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V .line 11 return-void.end method 字段静态字段格式如下： 12# static fields.field &lt;访问权限&gt; static [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt; 实例字段格式如下： 12# instance fields.field &lt;访问权限&gt; [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt; 举个栗子 java ： 12345private String name;private final String sex="男";public static int age; smali : 1234567# static fields.field public static age:I# instance fields.field private name:Ljava/lang/String;.field private final sex:Ljava/lang/String; 方法方法有直接方法和虚方法两种，两者格式基本相同： 12345678# direct methods (virtual methods).method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt; &lt;.locals&gt; [.parameter] or [.param] [.prologue] [.line] &lt;代码体&gt;.end method .locals：局部变量个数.parameter or .param：指定每个参数.prologue：代码的开始处，混淆过的代码可能没有该指令.line：指定了该处指令在源代码中的行号，混淆过的代码可能没有该指令 举个栗子：java 1234public String test(int a)&#123; int b=a+10; return "test";&#125; smali 123456789101112131415# virtual methods.method public test(I)Ljava/lang/String; .locals 2 .param p1, &quot;a&quot; # I .prologue .line 11 add-int/lit8 v0, p1, 0xa .line 12 .local v0, &quot;b&quot;:I const-string v1, &quot;test&quot; return-object v1.end method 接口interface 格式如下： 12# interfaces.implements &lt;接口名&gt; 举个例子：java 12345678910public interface If &#123; int demo(String s);&#125;public class InterfaceTest implements If &#123; @Override public int demo(String s) &#123; return 0; &#125;&#125; smali ： If.smali 123# virtual methods.method public abstract demo(Ljava/lang/String;)I.end method InterfaceTest.smali 1234567891011121314# interfaces.implements Ljiuyou/hello/info/If;# virtual methods.method public demo(Ljava/lang/String;)I .locals 1 .param p1, &quot;s&quot; # Ljava/lang/String; .prologue .line 11 const/4 v0, 0x0 return v0.end method 注解格式如下： 123.annotation [注解属性] &lt;注解类名&gt; [注解字段 = 值].end annotation 如果注解的作用范围是类， .annotation 指令会直接定义在 smali 文件中，如果作用范围是方法或者字段，则会包含在方法或字段定义中。 举个栗子：java 12345@Deprecatedpublic class AnnotationTest &#123; @At(value = "tom") public String name;&#125; smali 1234567891011# annotations.annotation runtime Ljava/lang/Deprecated;.end annotation# instance fields.field public name:Ljava/lang/String; .annotation runtime Ljiuyou/hello/info/At; value = &quot;tom&quot; .end annotation.end field]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-NDK图片高斯模糊]]></title>
      <url>%2F2017%2F08%2F27%2Fandroid-ndk%2F</url>
      <content type="text"><![CDATA[CMakeCMake是一款项目构建工具，通过编写简单明了的在CmakeLists.txt来生成makefile，简单来说就是一个makefile生成器。 在Android Studio中安装CMake非常简单，打开Tools-&gt;Android-&gt;SDK Manager，选择SDK Tools标签页，勾选CMake、LLDB、NDK，OK自动安装即可。其中LLDB可以使我们在Android Studio中调试C/C++程序。NDK为原生开发工具包，必不可少。 为什么要做JNI/NDK开发众所周知，Java/Android程序是运行在JVM/Dalvik VM中，所以Java程序远没有C/C++程序性能高，尤其是在CPU密集型运算时，所以Java平台提供了JNI（Java Native Interface），可通过JNI调用C/C++等编写的so动态链接库。 注：Google在Android L以后用ART彻底代替了Dalvik VM，但ART本质上仍是一个虚拟机，并支持所有Dalvik VM指令集。 Java API中几乎所有与硬件相关的方法都是native的，比如I/O操作、网络访问、手机传感器、串口读写等。本文涉及的图片处理是一种CPU密集型任务，在Android开发中使用native方法最为合适。 如何使用CMake做JNI/NDK开发新建工程选中Include C++ Support，意为引入C++支持。 配置C++支持 在Customize C++ Support界面默认即可,意为CMake/C++11环境 认识CMakeLists.txt工程创建完毕之后Android Studio会在app目录下生成CMakeLists.txt文件。CMakeLists.txt是CMake的配置文件，用于表明版本、依赖、等信息，以下为Android Studio生成的CMakeLists（过滤注释） 1234567cmake_minimum_required(VERSION 3.4.1)add_library(native-lib SHARED src/main/cpp/native-lib.cpp)find_library(log-lib log)target_link_libraries(native-lib $&#123;log-lib&#125;) cmake_minimum_required(VERSION 3.4.1)CMake最小版本使用的是3.4.1。 add_library()配置so库信息（为当前当前脚本文件添加库） native-lib这个是声明引用so库的名称，在项目中，如果需要使用这个so文件，引用的名称就是这个。值得注意的是，实际上生成的so文件名称是libnative-lib。 SHARED这个参数表示共享so库文件，也就是在Run项目或者build项目时会在目录intermediates\transforms\mergeJniLibs\debug\folders\2000\1f\main下生成so文件。 src/main/cpp/native-lib.cpp构建so库的源文件。 find_library()查找一个库文件 log-lib这个指定的是在NDK库中每个类型的库会存放一个特定的位置，而log库存放在log-lib中 log指定使用log库 target_link_libraries()如果你本地的库（native-lib）想要调用log库的方法，那么就需要配置这个属性，意思是把NDK库关联到本地库。 native-lib要被关联的库名称 ${log-lib}要关联的库名称，要用大括号包裹，前面还要有$符号去引用。 了解JNI的C/C++规范数据类型JNI的数据类型包含两种，分别是基本类型和引用类型，它们和Java中的数据类型对应关系如下两表所示。 基本数据类型 JNI类型 Java类型 描述 jboolean boolean 无符号8位整型 jbyte byte 无符号8位整型 jchar char 无符号16位整型 jshort short 有符号16位整型 jint int 32位整型 jlong long 64位整型 jfloat float 32位浮点型 jdouble double 64位浮点型 void void 无类型 引用数据类型 JNI类型 Java类型 描述 jobject Object Object类型 jclass Class Class类型 jstring String String类型 jobjectArray Object[] 对象数组 jbooleanArray boolean[] boolean数组 jbyteArray byte[] byte数组 jcharArray char[] char数组 jshortArray short[] short数组 jintArray int[] int数组 jlongArray long[] long数组 jfloatArray float[] float数组 jdoubleArray double[] double数组 jthrowable Throwable Throwable JNI的类型签名JNI的类型签名标识了一个特定的Java类型，这个类型既可以是类也可以是方法，也可以是数据类型。 类的签名比较简单，它采用 L+包名+类型+; 的形式，只需要将其中的.替换为/即可。例如java.lang.String， 它的签名为Ljava/lang/String; ，注意末尾的;也是签名一部分。 基本数据类型的签名采用一系列大写字母来表示, 如下表所示 基本数据类型的签名 Java类型 签名 Java类型 签名 Java类型 签名 boolean Z byte B char C short S int I long J float F double D void V JNI C/C++函数编写先来看看Android Studio为我们生成的示例 1234567JNIEXPORT jstring JNICALLJava_com_glee_myapplication_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */) &#123; std::string hello = "Hello from C++"; return env-&gt;NewStringUTF(hello.c_str());&#125; JNIEXPORT &amp; JNICALLJNIEXPORT和JNICALL这两个宏（被定义在jni.h）确保这个函数在本地库外可见，并且编译器会进行正确的调用转换。 函数规范在JNI中C/C++的函数名是有规范要求的，由以下几部分串接而成 Java_前缀 完全限定的类名，并用下划线“_”作为分隔符 第一参数JNIEnv* env 第二个参数jobject或jclass 其他参数按类型映射 返回参数按类型映射 JNI层操作Bitmap对象原理Android中JNI层处理Bitmap通常有两种方法 获取到Bitmap中的byte数组并传入native方法，JNI层处理得到的byte数组后返回一个新的byte数组，Java层重建Bitmap对象。（不推荐） Java层直接向JNI层传入Bitmap的引用，JNI层得到Bitmap对象的图像数据的地址，直接修改Bitmap的byte数组。 阅读了很多篇博客，很多开发者都会采用第一种方法，本人是极不推荐的。这种方法会在内存中重建一个byte数组，会造成内存的浪费，性能低下。第二种方法是性能最优的，JNI层充分利用的C/C++指针的特性，直接获取到Bitmap中byte数组在内存中的地址，通过指针直接修改图像数据，所以用到了NDK中的android/bitmap.h。 android/bitmap.h android/bitmap.h这个头文件用于在JNI层操作Bitmap对象的，其包含于jnigraphics库中，所以要在CMakeLists.txt中的target_link_libraries加入-ljnigraphics，如下 target_link_libraries(native-lib -ljnigraphics ${log-lib}) 三个常用函数 AndroidBitmap_getInfo() 从位图句柄获得信息（宽度、高度、像素格式） AndroidBitmap_lockPixels() 对像素缓存上锁，即获得该缓存的指针。 AndroidBitmap_unlockPixels() 解锁 JNI接口函数请看注释 123456789101112JNIEXPORT void JNICALLJava_com_glee_ndkroad1006_MainActivity_gaussBlur(JNIEnv *env, jobject /* this */, jobject bmp) &#123; AndroidBitmapInfo info = &#123;0&#125;;//初始化BitmapInfo结构体 int *data=NULL;//初始化Bitmap图像数据指针 AndroidBitmap_getInfo(env, bmp, &amp;info); AndroidBitmap_lockPixels(env, bmp, (void **) &amp;data);//锁定Bitmap，并且获得指针 /**********高斯模糊算法作对int数组进行处理***********/ //调用gaussBlur函数，把图像数据指针、图片长宽和模糊半径传入 gaussBlur(data,info.width,info.height,80); /****************************************************/ AndroidBitmap_unlockPixels(env,bmp);//解锁&#125; 这里用到的gaussBlur函数代码将在文章最后列出。 Java层代码请看注释 1234567891011121314151617181920212223242526public class MainActivity extends AppCompatActivity &#123; static &#123; //通过静态代码块加载so库 System.loadLibrary("native-lib"); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化两个ImageView ImageView iv1 = (ImageView) findViewById(R.id.img1); ImageView iv2 = (ImageView) findViewById(R.id.img2); //iv1设置图片 iv1.setImageResource(R.drawable.test); //生成bitmap对象 Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test); //调用native方法，传入Bitmap对象，对Bitmap进行高斯迷糊处理 gaussBlur(bitmap); //把Bitmap对象设置给iv2 iv2.setImageBitmap(bitmap); &#125; //native方法声明 public native void gaussBlur(Bitmap bitmap);&#125; 运行效果上方的ImageView是没有进行高斯模糊处理的，下方的ImageView调用了JNI方法进行高斯模糊处理。 高斯模糊算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980void gaussBlur1(int* pix, int w, int h, int radius)&#123; float sigma = (float) (1.0 * radius / 2.57); float deno = (float) (1.0 / (sigma * sqrt(2.0 * PI))); float nume = (float) (-1.0 / (2.0 * sigma * sigma)); float* gaussMatrix = (float*)malloc(sizeof(float)* (radius + radius + 1)); float gaussSum = 0.0; for (int i = 0, x = -radius; x &lt;= radius; ++x, ++i) &#123; float g = (float) (deno * exp(1.0 * nume * x * x)); gaussMatrix[i] = g; gaussSum += g; &#125; int len = radius + radius + 1; for (int i = 0; i &lt; len; ++i) gaussMatrix[i] /= gaussSum; int* rowData = (int*)malloc(w * sizeof(int)); int* listData = (int*)malloc(h * sizeof(int)); for (int y = 0; y &lt; h; ++y) &#123; memcpy(rowData, pix + y * w, sizeof(int) * w); for (int x = 0; x &lt; w; ++x) &#123; float r = 0, g = 0, b = 0; gaussSum = 0; for (int i = -radius; i &lt;= radius; ++i) &#123; int k = x + i; if (0 &lt;= k &amp;&amp; k &lt;= w) &#123; //得到像素点的rgb值 int color = rowData[k]; int cr = (color &amp; 0x00ff0000) &gt;&gt; 16; int cg = (color &amp; 0x0000ff00) &gt;&gt; 8; int cb = (color &amp; 0x000000ff); r += cr * gaussMatrix[i + radius]; g += cg * gaussMatrix[i + radius]; b += cb * gaussMatrix[i + radius]; gaussSum += gaussMatrix[i + radius]; &#125; &#125; int cr = (int)(r / gaussSum); int cg = (int)(g / gaussSum); int cb = (int)(b / gaussSum); pix[y * w + x] = cr &lt;&lt; 16 | cg &lt;&lt; 8 | cb | 0xff000000; &#125; &#125; for (int x = 0; x &lt; w; ++x) &#123; for (int y = 0; y &lt; h; ++y) listData[y] = pix[y * w + x]; for (int y = 0; y &lt; h; ++y) &#123; float r = 0, g = 0, b = 0; gaussSum = 0; for (int j = -radius; j &lt;= radius; ++j) &#123; int k = y + j; if (0 &lt;= k &amp;&amp; k &lt;= h) &#123; int color = listData[k]; int cr = (color &amp; 0x00ff0000) &gt;&gt; 16; int cg = (color &amp; 0x0000ff00) &gt;&gt; 8; int cb = (color &amp; 0x000000ff); r += cr * gaussMatrix[j + radius]; g += cg * gaussMatrix[j + radius]; b += cb * gaussMatrix[j + radius]; gaussSum += gaussMatrix[j + radius]; &#125; &#125; int cr = (int)(r / gaussSum); int cg = (int)(g / gaussSum); int cb = (int)(b / gaussSum); pix[y * w + x] = cr &lt;&lt; 16 | cg &lt;&lt; 8 | cb | 0xff000000; &#125; &#125; free(gaussMatrix); free(rowData); free(listData);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-CoordinatorLayout详细学习]]></title>
      <url>%2F2017%2F08%2F27%2Fandroid-coordinatorLayout%2F</url>
      <content type="text"><![CDATA[曾在网上找了一些关于CoordinatorLayout的教程，大部分文章都是把CoordinatorLayout、AppbarLayout、CollapsingToolbarLayout 以及Toolbar等一起使用来介绍，这让我不知不觉在心中认为把这几个布局要一起使用，而且只是用于那种场景中。其实CoordinatorLayout的功能并不是局限于与AppBarLayout一起使用，它的功能强大着呢，本文主要对CoordinatorLayout的使用进行介绍，后面再写一篇文章将AppBarLayout和CollapsingToolBarLayout整合CoordinatorLayout一起。那么到底CoordinatorLayout有多好用，请往下感受吧~ CoordinatorLayout能做什么在学习CoordinatorLayout之前，很有必要了解CoordinatorLayout能帮我们做什么，从名字上可以看出，就是帮我们协调子View的。怎么个协调法呢?就是它根据我们的定制，帮助我们协调各个子View的布局。我们先看一组动画图~ 稍微解释一下这个动画，蓝色的矩形是我们一个普通View，黄色的Hello是一个Button。我们水平拖动蓝色矩形时，黄色Button查着与蓝色矩形相反方向移动；竖直移动蓝色矩形时，黄色也跟着竖直。简而言之：它们在竖直方向同步移动，在水平方向相反。 这个效果如果让你不用CoordinatorLayout去实现，应该没有任何问题，但是代码的耦合度应该非常大，你的代码必须要持有2个View的引用，然后在onTouchEvent里面做各种判断。如果我们想要实现的功能是，有更多的View要根据蓝色的View的移动相应作出响应，那么那就得在蓝色View的onTounchEvent里面针对其他的View处理各种逻辑。这耦合度未免太伤感了~ 而CoordinatorLayout既然号称能帮我们协调子View的布局，我们接下来看看CoordinatorLayout如何实现~ CoordinatorLayout使用CoordinatorLayout的使用核心是Behavior，Behavior就是执行你定制的动作。在讲Behavior之前必须先理解两个概念：Child和Dependency，什么意思呢？Child当然是子View的意思了，是谁的子View呢，当然是CoordinatorLayout的子View；其实Child是指要执行动作的CoordinatorLayout的子View。而Dependency是指Child依赖的View。比如上面的gif图中，蓝色的View就是Dependency，黄色的View就是Child，因为黄色的View的动作是依赖于蓝色的View。简而言之，就是如过Dependency这个View发生了变化，那么Child这个View就要相应发生变化。发生变化是具体发生什么变化呢？这里就要引入Behavior，Child发生变化的具体执行的代码都是放在Behavior这个类里面。 怎么使用Behavior呢，首先，我们定义一个类，继承CoordinatorLayout.Behavior&lt;T&gt;,其中，泛型参数T是我们要执行动作的View类，也就是Child。然后就是去实现Behavior的两个方法： 1234567891011121314151617181920/*** 判断child的布局是否依赖dependency*/ @Override public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) &#123; boolean rs; //根据逻辑判断rs的取值 //返回false表示child不依赖dependency，ture表示依赖 return rs; &#125;/*** 当dependency发生改变时（位置、宽高等），执行这个函数* 返回true表示child的位置或者是宽高要发生改变，否则就返回false*/@Overridepublic boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) &#123; //child要执行的具体动作 return true;&#125; 有了上面的概念后，我们看看具体怎么去实现吧~ 为了响应跟随手指移动的操作，我们定义一个非常简单的View，这个View只响应跟随手指移动，将这个View作为Dependency。由于过于简单，这个View源码不粘贴，我们只需知道这个View的类名叫：TempView。 我们看看Behavior的使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.hc.studyCoordinatorLayout;import android.content.Context;import android.support.design.widget.CoordinatorLayout;import android.util.AttributeSet;import android.util.DisplayMetrics;import android.view.View;import android.widget.Button;/** * Package com.hc.studyCoordinatorLayout * Created by HuaChao on 2016/6/1. */public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; &#123; private int width; public MyBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); DisplayMetrics display = context.getResources().getDisplayMetrics(); width = display.widthPixels; &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) &#123; //如果dependency是TempView的实例，说明它就是我们所需要的Dependency return dependency instanceof TempView; &#125; //每次dependency位置发生变化，都会执行onDependentViewChanged方法 @Override public boolean onDependentViewChanged(CoordinatorLayout parent, Button btn, View dependency) &#123; //根据dependency的位置，设置Button的位置 int top = dependency.getTop(); int left = dependency.getLeft(); int x = width - left - btn.getWidth(); int y = top; setPosition(btn, x, y); return true; &#125; private void setPosition(View v, int x, int y) &#123; CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) v.getLayoutParams(); layoutParams.leftMargin = x; layoutParams.topMargin = y; v.setLayoutParams(layoutParams); &#125;&#125; OK，现在我们为Button类指定了Dependency，并且定义好了跟随Dependency一直变化的动作（Behavior），接下来我们就要指定好为哪个具体的Button实例来绑定这些。方法很简单，直接在布局文件指定就好： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.hc.studyCoordinatorLayout.MainActivity"&gt; &lt;Button android:id="@+id/btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="300dp" android:layout_marginTop="300dp" android:background="#FFCC00" android:text="Hello" app:layout_behavior="com.hc.studyCoordinatorLayout.MyBehavior" /&gt; &lt;com.hc.studyCoordinatorLayout.TempView android:layout_width="100dp" android:layout_height="100dp" android:layout_marginLeft="300dp" android:layout_marginTop="300dp" android:background="#3366CC" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 是不是很简单呢？我们只需关注Behavior的编写就好了，把Child和Dependency之间的关系完全解耦了~ 附上源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-AppBarLayout]]></title>
      <url>%2F2017%2F08%2F26%2Fandroid-appbarlayout%2F</url>
      <content type="text"><![CDATA[ToolbarToobar主要是用来替换ActionBar的，换句话说，ActionBar能做的，Toolbar都能做。如果你对ActionBar的使用比较熟悉，你会发现Toolbar使用起来非常简单。ok，既然是替换，当然用Toolbar的时候就得先去把ActionBar给隐藏掉啦~ 隐藏ActionBar的方法有很多，可以通过代码的方式隐藏，也可以通过配置文件的方式，我们主要是通过配置文件的方式来隐藏。在我们的styles.xml文件中的AppTheme标签中加入如下两行： 12&lt;item name="windowActionBar"&gt;false&lt;/item&gt;&lt;item name="windowNoTitle"&gt;true&lt;/item&gt; 当然了，你也可以新建一个&lt;style&gt;标签，将上面两行代码加入，并且将这个新建的标签作为&lt;application&gt;的theme。还可以选择通过将AppTheme的parent设置为Theme.AppCompat.Light.NoActionBar的方式。方法很多，可以自己随便选。 接下来就是将Toolbar放入到布局文件（没啥好解释的）： 12345&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:background="?attr/colorPrimary" android:layout_height="?android:attr/actionBarSize" /&gt; 最后将Toobar作为“ActionBar”来用 12345Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setTitle("这里是Title"); toolbar.setSubtitle("这里是子标题"); toolbar.setLogo(R.drawable.icon); setSupportActionBar(toolbar); 可以对Toolbar设置Logo、标题、子标题等等~还有很多其他的设置，自己去慢慢玩，这里不提啦~。当然了，也可以在布局文件中设置这些，在布局文件设置就不写啦，hongyang大神有篇博客写的挺好的《 Android 5.x Theme 与 ToolBar 实战 》可以去参考一下。 如果Toolbar仅仅是用来对以往的ActionBar做一次替换，那也太没创意啦！完全没必要去替换了，因为它们表现出来的都是一样的，而且并没有让我们觉得用起来比ActionBar方便。那为啥要替换呢，总应该有他的理由吧：ActionBar是固定在顶部，并不能移动，我觉得这是最大的不好，而我们的ToolBar可以让我们随便摆放，就就可以带来很多灵活性和效果啦！ 正如你所看的这样，Toolbar根本就不够看的，一点都不复杂。接下来我们继续学习在Toolbar上面再套一层父View，让Toolbar更有互动性。 AppBarLayout AppBarLayout继承自LinearLayout，布局方向为垂直方向。所以你可以把它当成垂直布局的LinearLayout来使用。AppBarLayout是在LinearLayou上加了一些材料设计的概念，它可以让你定制当某个可滚动View的滚动手势发生变化时，其内部的子View实现何种动作。 请注意：上面提到的某个可滚动View，可以理解为某个ScrollView。怎么理解上面的话呢？就是说，当某个ScrollView发生滚动时，你可以定制你的“顶部栏”应该执行哪些动作（如跟着一起滚动、保持不动等等）。那某个可移动的View到底是哪个可移动的View呢？这是由你自己指定的！如何指定，我们后面说。 AppBarLayout子View的动作内部的子View通过在布局中加app:layout_scrollFlags设置执行的动作，那么app:layout_scrollFlags可以设置哪些动作呢？分别如下： （1） scroll:值设为scroll的View会跟随滚动事件一起发生移动。 什么意思呢？简单的说，就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。 一张gif足以说明： 对应的布局文件 1234567891011&lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?android:attr/actionBarSize" android:background="?attr/colorPrimary" app:layout_scrollFlags="scroll" /&gt;&lt;/android.support.design.widget.AppBarLayout&gt; （2） enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。 看个动画片（Y(^o^)Y）（ToolBar高度设为：?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enterAlways&quot;）： （3） exitUntilCollapsed：值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。 怎么理解呢？简单解释：在ScrollView往上滑动时，首先是View把滑动事件“夺走”，由View去执行滑动，直到滑动最小高度后，把这个滑动事件“还”回去，让ScrollView内部去上滑。看个gif感受一下（图中将高度设的比较大:200dp，并将最小高度设置为?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;）： （4） enterAlwaysCollapsed：是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。来个gif感受一下（图中将高度设的比较大:200dp，并将最小高度设置为?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enerAlways|enterAlwaysCollapsed&quot;）： 将AppBarLayout与ScrollView关联起来前面说了一直反复说“当ScrollView发生滚动时”，那么怎么将AppBarLayout与ScrollView关联起来呢？我们注意到，AppBarLayout与ScrollView之间动作“相互依赖”，这不就是我们上一篇《CoordinateLayout的使用如此简单 》所学的内容吗？把ScrollView和AppBarLayout作为CoordinateLayout的子View，然后编写一个Behavior，在这个Behavior里面判断当前的操作是应该让ScrollView时刻保持在AppBarLayout之下（即只要改变AppBarLayout的位置就可以一起滑动），还是应该让ScrollView内部滚动而不让AppBarLayout位置发生变化等等这些需求，都是可以在Behavior里面处理的。你可以去针对你的ScrollView编写Behavior。然而，我们看到我们的AppBarLayout事先的功能比较复杂，如果我们自己去定义这样的效果，代码非常复杂，还要考虑很多方面，好在Android帮我们写好啦，我们直接用就是了，这个ScrollView就是NestedScrollView，请注意，它并没有继承ScrollView，它继承的是FrameLayout，但是它实现的效果把它可以看成是ScrollView。 把NestedScrollView放入到我们的layout文件里面就可以啦~~~，很方便~ 123456789 &lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="wrap_content" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;!--将你的内容放在这里--&gt;&lt;/android.support.v4.widget.NestedScrollView&gt; 有没有注意到有个属性：app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;,它就是指定Behavior的，appbar_scrolling_view_behavior对应的类的名称是：android.support.design.widget.AppBarLayout$ScrollingViewBehavior感兴趣的可以去分析源码。 好了，我们现在会用AppBarLayout啦~是不是发现用起来so easy!接下来我们把剩下CollapsingToolbarLayout的给”消化”掉！ CollapsingToolbarLayoutCollapsingToolbarLayout是用来对Toolbar进行再次包装的ViewGroup，主要是用于实现折叠（其实就是看起来像伸缩~）的App Bar效果。它需要放在AppBarLayout布局里面，并且作为AppBarLayout的直接子View。CollapsingToolbarLayout主要包括几个功能（参照了官方网站上内容，略加自己的理解进行解释）： (1) 折叠Title（Collapsing title）：当布局内容全部显示出来时，title是最大的，但是随着View逐步移出屏幕顶部，title变得越来越小。你可以通过调用setTitle函数来设置title。 (2)内容纱布（Content scrim）：根据滚动的位置是否到达一个阀值，来决定是否对View“盖上纱布”。可以通过setContentScrim(Drawable)来设置纱布的图片. (3)状态栏纱布（Status bar scrim)：根据滚动位置是否到达一个阀值决定是否对状态栏“盖上纱布”，你可以通过setStatusBarScrim(Drawable)来设置纱布图片，但是只能在LOLLIPOP设备上面有作用。 (4)视差滚动子View(Parallax scrolling children):子View可以选择在当前的布局当时是否以“视差”的方式来跟随滚动。（PS:其实就是让这个View的滚动的速度比其他正常滚动的View速度稍微慢一点）。将布局参数app:layout_collapseMode设为parallax (5)将子View位置固定(Pinned position children)：子View可以选择是否在全局空间上固定位置，这对于Toolbar来说非常有用，因为当布局在移动时，可以将Toolbar固定位置而不受移动的影响。 将app:layout_collapseMode设为pin。 了解这些概念后，我们来看看布局吧~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width="match_parent" android:layout_height="wrap_content" app:expandedTitleMarginEnd="64dp" app:expandedTitleMarginStart="48dp" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:id="@+id/main.backdrop" android:layout_width="wrap_content" android:layout_height="300dp" android:scaleType="centerCrop" android:src="@drawable/material_img" app:layout_collapseMode="parallax" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?android:attr/actionBarSize" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingTop="50dp" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/my_txt" android:textSize="20sp" /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 上面的都看得懂吧，每个陌生的属性都是讲过的哦，忘记了的话回头看，稍微解释一下，图片被设置为有视差的滑动，Toolbar设置为固定不动，另外，CollapsingToolbarLayout会对title进行放大和缩小，我们看看效果吧~ 如果你希望拖动过程中状态栏是透明的，可以在CollapsingToolbarLayout中加 app:statusBarScrim=&quot;@android:color/transparent“，并且在onCreate中调用getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)将状态栏设置为透明就好啦~ 献上源码 AppBarLayout的ScrollFlags属性在前面两篇MD系列的文章中，通过两个案例基本上能够掌握了CoordinatorLayout与AppBarLayout的配合使用。本文我们回过头来详细聊聊AppBarLayout的ScrollFlags属性，了解一下不同值之间的区别。至此，Android Material Design系列的学习已进行到第七篇，大家可以点击以下链接查看之前的文章： Android TabLayout 分分钟打造一个滑动标签页 Android 一文告诉你到底是用Dialog，Snackbar，还是Toast Android FloatingActionButton 重要的操作不要太多，一个就好 Android 初识AppBarLayout 和 CoordinatorLayout Android CoordinatorLayout实战案例学习《一》 Android CoordinatorLayout 实战案例学习《二》 ScrollFlags共有五种常量值供AppBarLayout的Children View使用，在xml布局文件中通过app:layout_scrollFlags设置，对应的值为：scroll，enterAlways，enterAlwaysCollapsed，snap，exitUntilCollapsed；也可以在代码中通过setScrollFlags(int)方法使用，比如： 12345Toolbar toolbar = ... // your toolbar within an AppBarLayoutAppBarLayout.LayoutParams params = (AppBarLayout.LayoutParams) toolbar.getLayoutParams();params.setScrollFlags(AppBarLayout.LayoutParams.SCROLL_FLAG_SCROLL | AppBarLayout.LayoutParams.SCROLL_FLAG_ENTER_ALWAYS); 下面我们通过官网介绍、XML代码和对应的效果图分别分析这五种值的使用（备注：代码中设置也一样，不再赘述）： scroll The view will be scroll in direct relation to scroll events. This flag needs to be set for any of the other flags to take effect. If any sibling views before this one do not have this flag, then this value has no effect. Child View 伴随着滚动事件而滚出或滚进屏幕。注意两点：第一点，如果使用了其他值，必定要使用这个值才能起作用；第二点：如果在这个child View前面的任何其他Child View没有设置这个值，那么这个Child View的设置将失去作用。 示例XML代码： 12345678910111213141516171819&lt;android.support.design.widget.AppBarLayout android:id="@+id/appbar" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"&gt; &lt;android.support.v7.widget.Toolbar xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/tb_toolbar" android:layout_width="match_parent" android:layout_height="@dimen/dp_56" app:titleTextColor="@color/white" app:title="@string/app_name" app:theme="@style/OverFlowMenuTheme" app:popupTheme="@style/AppTheme" android:background="@color/blue" app:layout_scrollFlags="scroll|enterAlways"/&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 对应效果图： enterAlways When entering (scrolling on screen) the view will scroll on any downwards scroll event, regardless of whether the scrolling view is also scrolling. This is commonly referred to as the ‘quick return’ pattern. 快速返回模式。其实就是向下滚动时Scrolling View和Child View之间的滚动优先级问题。对比scroll和scroll | enterAlways设置，发生向下滚动事件时，前者优先滚动Scrolling View，后者优先滚动Child View，当优先滚动的一方已经全部滚进屏幕之后，另一方才开始滚动。 示例XML代码： 123...app:layout_scrollFlags="scroll|enterAlways"... 对应效果图： enterAlwaysCollapsed An additional flag for ‘enterAlways’ which modifies the returning view to only initially scroll back to it’s collapsed height. Once the scrolling view has reached the end of it’s scroll range, the remainder of this view will be scrolled into view. The collapsed height is defined by the view’s minimum height. enterAlways的附加值。这里涉及到Child View的高度和最小高度，向下滚动时，Child View先向下滚动最小高度值，然后Scrolling View开始滚动，到达边界时，Child View再向下滚动，直至显示完全。 示例XML代码： 123456...android:layout_height="@dimen/dp_200"android:minHeight="@dimen/dp_56"...app:layout_scrollFlags="scroll|enterAlways|enterAlwaysCollapsed"... 对应效果图： exitUntilCollapsed When exiting (scrolling off screen) the view will be scrolled until it is ‘collapsed’. The collapsed height is defined by the view’s minimum height. 这里也涉及到最小高度。发生向上滚动事件时，Child View向上滚动退出直至最小高度，然后Scrolling View开始滚动。也就是，Child View不会完全退出屏幕。 示例SML代码： 123456...android:layout_height="@dimen/dp_200"android:minHeight="@dimen/dp_56"...app:layout_scrollFlags="scroll|exitUntilCollapsed"... 对应效果图： snap Upon a scroll ending, if the view is only partially visible then it will be snapped and scrolled to it’s closest edge. For example, if the view only has it’s bottom 25% displayed, it will be scrolled off screen completely. Conversely, if it’s bottom 75% is visible then it will be scrolled fully into view. 简单理解，就是Child View滚动比例的一个吸附效果。也就是说，Child View不会存在局部显示的情况，滚动Child View的部分高度，当我们松开手指时，Child View要么向上全部滚出屏幕，要么向下全部滚进屏幕，有点类似ViewPager的左右滑动。 示例XML代码： 12345...android:layout_height="@dimen/dp_200"...app:layout_scrollFlags="scroll|snap"... 对应效果图： 示例源码我在GitHub上建立了一个Repository，用来存放整个Android Material Design系列控件的学习案例，会伴随着文章逐渐更新完善，欢迎大家补充交流，Star地址： https://github.com/Mike-bel/MDStudySamples]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Debug]]></title>
      <url>%2F2017%2F08%2F25%2Fandroid-debug%2F</url>
      <content type="text"><![CDATA[一、 进入 debug 模式的两种姿势第一种是点击运行按钮旁边的“绿色甲虫”(debug app)开始以调试模式编译运行。 这个方式的特点是，一开始就进入了调试模式。适合希望尽早进入调试模式的场景，比如你想从头开始追踪问题，或者断点在启动页或首页之类的。它的弊端是每次需要从头跑一遍，且由于调试模式下应用程序略卡顿，等你到达调试页面时会觉得老费劲。 第二种方式是在手机或模拟器已经跑起来应用程序后点击 Run -&gt; Attach debugger to Android process，选择应用程序主进程，即可进入调试模式。 这种方式的特点是，随时随地自由进入调试模式，不需要重头开始跑应用程序，该方式适合绝大多数调试场景。需要注意的是，假如跑的是 release 版本且有混淆加固之类的话，该方式就无法正常调试。 二、 常见的调试操作1 典型的调试场景一个最常见的调试场景如下： 完成包括打开 Android Studio、打开需要调试的类、连接手机等准备工作 在关键位置打上普通断点，进入调试模式后触发断点，将当前线程阻塞在断点处 单步调试，一行一行往下运行 碰到方法调用时进入方法内部 用单步调试单步执行直到该方法结束回到方法调用的下一行，或者直接退出当前方法 通过观察观察区的相关变量，推断出问题所在，结束本次调试 以上是最常规的 debug 场景，下面介绍下调试界面。 在 Android Studio 的 debug 标签（假如一开始没有，等触发断点后自然会出现）中有两个面板 debugger 和 console。debugger 又分为 Frames、Threads 和 Variables 三块，分别是堆栈内容、线程、变量区。 在 debugger 标签右边有一些操作按钮，是我们常用的调试操作，下面会一一介绍。（可以用鼠标悬停在上面看每个按钮的具体名称） 2 设置断点断点有多种类型，我们这里先只谈普通断点。在每行的最前端单击一下即可添加断点，在断点上单击一下是取消断点。普通模式下断点只是一个普通的红点，但假如是在调试模式下，则红点上会有一个“√”或“✘”表示该行是否会被运行，例如，注释行前的断点会是“✘”。 不管怎样，触发断点肯定是调试的起点。只有触发了断点，才会开始阻塞线程（注意是只会阻塞当前线程，这个后面会扩展一下详细介绍），此时当前代码行会被蓝色高亮，观察面板上的变量也会显示当前环境下的值。 3 跳到下一个断点（F9）一般情况下，在调试时我们可以根据我们的经验在几个关键的位置打上断点，这里就需要从一个断点直接跳到下一个断点。操作是继续以 debug 模式运行，快捷键是 F9（假如没改动的话应该都是这个快捷键，假如不同，可以把鼠标悬浮在该图标上看提示，下同）。 4 单步调试（F8）触发断点后，我们当然可以通过加 N 个断点来定位问题，但在较复杂的场景里可能没法判断出关键点。这时可以在比较靠前的位置添加断点作为起点，一行一行执行。操作是单步调试，快捷键是 F8。 5 进入方法内部（F7）在单步调试时方法调用语句会被看做一行，那么如何进入方法内部呢？用“进入内部”操作，快捷键是 F7. 6 退出当前方法（上档键+F8）既然有进入方法内部，就有退出当前方法的操作。当进入某个方法内部后觉得该方法后面的代码不需要看了，不需要猛按 F8 让它们跑完，可以直接退出当前方法去到该方法调用处的下一行。 有了这些操作，基本可以应付常见的 80% 的调试场景了。但仅仅了解这些，在面对复杂场景时难免效率低下。下面介绍几种非常高效的断点。 三、 几种高效断点1 条件成立时才触发的条件断点普通断点在每次运行到时都会被触发，这在多次调用、有“循环”的场景会比较麻烦，比如循环 100 次只希望停留在第 98 次。那么此刻就可以用上条件断点了。 添加条件断点：先在需要的行前左键单击添加普通断点，右键点击该断点出现对话框，在“Condition”处填入条件即可，条件语法同 Java，如 i == 98。点击 Done，完成添加。这样当条件未满足时，不会阻塞程序运行；当条件满足时断点被触发。 2 不会阻塞应用程序的日志断点有时候我们仅仅希望在关键时刻输出一些 log，那么我们需要做这些工作： 在代码里加上 log 代码 重新运行程序 重新触发断点 那么有没有什么方法可以避免这些繁杂的操作呢？这时可以试试日志断点。 在条件断点弹出的对话框里，将“suspend”设置为未选中状态，断点触发时就不会被阻塞。此时对话框会多出一些选项。 我们选中“Evaluated and log”，并在里面填写希望输出的日志，点击 Done 即可。注意，日志将输出到 Console 而非 LogCat。 3 被异常触发的异常断点我们做 debug，一般面对的都是未崩溃的异常，例如 UI 状态不对、数值不对、代码执行逻辑不对等等。碰到直接 crash 的情况，我们往往不会去 debug，而是根据报错信息定位到某某行，然后解决问题。最典型的就是空指针异常了，只要看到报错位置，基本手到擒来。 但日常开发难免碰到一些给出具体信息和抛异常的位置也没有头绪或者未给出具体位置的情况，比如某 API 抛了个状态异常，那么我们可能得去琢磨为何会状态不对。 这时还是得调试，但我们也不能眼睁睁看着抛出的异常让应用程序崩了，可以用上“异常断点”。 我们打开断点管理器，可以看到有一类是“Java Exception Breakpoints”，直接勾上是所有异常都会被触发。 假如只想被某种异常触发，我们可以点击“+”，选中“Java Exception Breakpoints”，然后输出该种异常即可。 有朋友可能注意到除了 “Java Exception Breakpoints” 外还有一个 “Exception Breakpoints”，两者区别主要是前者只支持 Java 本身的异常，后者可以支持自定义异常。 4 追踪关键点的字段断点和方法断点在诸如多线程等复杂场景下，超多的变量和超多的类再加上一些 native 方法和第三方库，调试的复杂度也直线上升。 这时可以尝试以点破面，抓住关键方法或字段来追踪应用程序的运行轨迹。于是关注某字段的字段断点和关注某方法的方法断点就派上用场了。 顾名思义，字段断点的触发条件是字段值被更改，方法断点是方法被调用。 添加方式：在字段那行、在方法声明的那行单击即可。 5 注意事项除了以上这些，还有其他断点未列出来，比如临时断点等。考虑到这类断点实用性不强，就不多加说明，有需求的朋友自然会去了解。 需要说明的是，给断点命名只是为了方便交流，各类型之间并没有特别边界。 实际上，断点只是某些操作的集合而已。比如日志断点是“不阻塞”和“输出日志”两个操作的集合，那么我们当然可以加上“设置条件”操作变成“条件日志断点”，诸如此类。我们设置断点的面板是允许我们将多种断点条件混合使用的。 所以，断点名称和类型不重要，重要的是针对现场选用合适的操作。 四 调试中的变量在设置了合适的断点后，我们就可以进行下一步操作 —— 观察变量，准确的说是观察变量的值。 1 变量观测面板众所周知，应用程序在运行期间元素都处于一种动态状态，此刻你是无法观测到具体变量的值的。只有当动态变成静态，即阻塞住应用程序，才能开始变量观测。 这个“阻塞”操作也就是上文提到的断点触发。 这里需要特别指出的是，当需要追踪某一个特定变量时，字段断点是一大利器。 如上图所示，变量观察面板会列出所有当前能访问到的成员变量和局部变量。 点击变量前的箭头，可以将该实例展开，列出所有字段。 2 Add New Watch将所有变量、所有字段列出来是比较直观，但当我们要去获取某些属性时就略蛋疼了。 比如，获取某成员变量 View 的第一个 child 的 measuredHeight。假如是靠手动去一个个“打开”属性列表，拿得多麻烦。 又比如，我们需要获取到两个属性相加后占另一个值的百分比。先去找到这两个属性的值然后额外拿计算器计算？ 这时就可以用上 “Add New Watch”了，添加一个观察表达式。通俗点就是在变量观测区执行一个表达式并得到它的值。 在面试左侧点击绿色“+”，或者点击右键在菜单中选择“New Watch”, 就会出现一个框，输入表达式即可。 举个例子： 在示例中输入toolbar.getChildAt(0).getMeasuredHeight()，可得到如图的结果。 3 设置变量的值变量的值除了能被观察外，还可以在运行时改变。 这个可以说是超酷的黑科技了。试想，碰到一个 if else 时，我们可以很轻松无成本地通过更改变量的值，让应用程序能跑到我们期望的分支上。 设置变量的值有两种方式：方式一是在变量观测区右键单击变量，在菜单中选中“set value”；方式二是鼠标悬浮在代码区中的某个可访问的变量上，在弹出的浮层里更改值。 五 犀利的小功能除了以上那些常规的操作，还有一些“还有这种操作”的小功能。 1 Force Run to Cursor该操作可以忽视已存在的断点，直接跳到光标所在的行。有种脱离断点、繁琐操作的束缚轻松自由的感觉有木有。 2 Drop frame经过不懈努力，终于快到出错的那个时刻啦，你眉飞色舞手指按得飞快，结果小手一抖，多按了几个 F8 （单步调试快捷键），错过了出错的那个时刻。如果能回退到方法执行前？ Drop frame 功能能让你回到当前方法被调用的地方，并且当前上下文所有变量也都恢复到方法调用前 —— 时光回溯有木有？ 当然别太兴奋，由于 DalvikVM 和 Android Runtime (ART) 不支持，大部分情况下你是用不到的，那个按钮长期处于不可点击状态。但如果你是在跑 JUnit 测试的话，是可以用上的。 3 Log在多线程环境下，光靠 debug 是不行的。有时 debug 本身会带来一些问题混淆了现场，比如因为 debug 时的卡顿造成环境不一致等等，这时应该学会使用打日志的形式帮忙调试。 4 布局查看器在 Android Studio 的 Android Device Monitor 里有一个 “Dump View Hierarchy for UI Automator” 功能，可以看到当前手机上应用的具体布局情况 —— 甚至布局元素的属性都会一一给出（仅可用于可调试的应用）。对 UI 调试非常有帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-组件化学习]]></title>
      <url>%2F2017%2F08%2F24%2Fandroid-modularization%2F</url>
      <content type="text"><![CDATA[网上关于组件化的文章有很多了，大部分都知道实现的思路，不过还是要自己去实践一下才会发现问题。文章的项目地址，项目用到CleanArchitecture框架，本文会介绍CleanArchitecture框架和dagger2在组件化的使用。 项目关系图 sdk: 一些公用库，各种辅助类，和第三方view basic: (依赖sdk) 网络访问初始化，本地缓存和第三方包等。 commonbusiness: (依赖basic) 这里为什么我会多出这一层，因为有很多公共的业务，好比公司的app是强登录的，我会把登录模块写在这里，里面也包含了一些baseActivity和BaseApplication和各个组件的一些公共方法还有组件各种的服务接口的定义。 module_archives和module_knowledge： 就是两个组件，可以单独运行。 application和library切换想必大家都知道了，定义一个isBuildModule=false，在组件的build.gradle中加入 12345678910111213141516171819if (isBuildModule.toBoolean()) &#123; apply plugin: 'com.android.application'&#125; else &#123; apply plugin: 'com.android.library' apply from: 'maven-release-kline-aar.gradle'&#125; sourceSets &#123; main &#123; if (isBuildModule.toBoolean()) &#123; manifest.srcFile 'src/main/debug/AndroidManifest.xml' &#125; else &#123; manifest.srcFile 'src/main/release/AndroidManifest.xml' java &#123; exclude '**/debug/**' &#125; &#125; &#125; &#125; maven-release-kline-aar.gradle是一个打包aar的文件，在切换的时候也会使用不同的AndroidManifest.xml，因为在组件是debug的时候它是单独单独运行的，还有就是代码可以在建立一个debug包，可以在单独运行的时候做些初始化app的，打包的时候回剔除这部分代码。 library依赖和资源问题我把所以的library都依赖在basic，每个组件都会依赖这个包，这样就不会存在library的版本问题，资源的问题就是 123456789101112131415defaultConfig &#123; if (isBuildModule.toBoolean()) &#123; applicationId &quot;com.wkw.archives&quot; &#125; minSdkVersion rootProject.ext.minSdkVersion targetSdkVersion rootProject.ext.targetSdkVersion versionCode rootProject.ext.versionCode versionName rootProject.ext.versionName testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; resourcePrefix &quot;archives&quot; &#125; 组件之间的通信你可以选择阿里的ARouter库，但是我的项目没有那么复杂，组件也就4个左右，所以没有使用阿里的库，我采用的是以下就是核心代码， 123456Object result = null;Class&lt;?&gt; c = Class.forName(className);if (c != null) &#123; result = c.newInstance();&#125;return result; 但是采用Class.forName会有个问题那就是在混淆的时候，className是指定的，所以要在类上加@Keep 。 CleanArchitecture框架和dagger在组件化的使用CleanArchitecture框架的github地址，这里再介绍分享一篇文章小鄧子的Easy Clean architecture on Android,我把data和domain会写在各自的业务模块中，自己的模块只要定义自己的就可以了，有个ApplicationModule会定义一些每个模块都需要的， 1234567891011121314151617181920212223242526272829303132333435363738public class ApplicationModule &#123; @Provides @Singleton Context provideContext(Application application) &#123; return application; &#125; @Provides @Singleton UserSystem provideUserSystem() &#123; return new UserSystem(); &#125; @Provides @Singleton ThreadExecutor provideThreadExecutor(JobExecutor jobExecutor) &#123; return jobExecutor; &#125; @Provides @Singleton PostExecutionThread providePostExecutionThread(UIThread uiThread) &#123; return uiThread; &#125; @Provides @Singleton MrService provideMrService() &#123; return new MrService(); &#125; @Provides @Singleton UserCache provideUserCache(UserCacheImpl userCache) &#123; return userCache; &#125;&#125; 然后在module_archives模块中会有ArchivesDataRepositoryModule和ArchivesActivityModule其中KnowledgeDataRepositoryModule用于提供如下： 123456789101112131415@Modulepublic class ArchivesDataRepositoryModule &#123; @Provides @Singleton ArchivesApi providesArchivesApi(MrService mrService) &#123; return mrService.createApi(ArchivesApi.class); &#125; @Provides @Singleton ArchivesRepository prvidesArchivesRepository(ArchivesDataRepository archivesDataRepository) &#123; return archivesDataRepository; &#125;&#125; ArchivesActivityModule的代码如下： 123456@Modulepublic abstract class ArchivesActivityModule &#123; @PerActivity @ContributesAndroidInjector() abstract ArchivesActivity contributeArchivesActivity();&#125; 这样在主app的AppComponent类中加入： 123456789101112131415@Singleton@Component(modules = &#123; AndroidInjectionModule.class, ApplicationModule.class, ArchivesDataRepositoryModule.class, ArchivesActivityModule.class, KnowledgeDataRepositoryModule.class, KnowledgeActivityModule.class&#125;)public interface AppComponent &#123; @Component.Builder interface Builder &#123; @BindsInstance Builder application(Application application); AppComponent build(); &#125; void inject(MrApplication mrApplication);&#125; 在module_archives为debug模式下也会有个AppComponent 1234567891011121314@Singleton@Component(modules = &#123; AndroidInjectionModule.class, ApplicationModule.class, ArchivesDataRepositoryModule.class, ArchivesActivityModule.class&#125;)public interface AppComponent &#123; @Component.Builder interface Builder &#123; @BindsInstance Builder application(Application application); AppComponent build(); &#125; void inject(ArchivesApplication mrApplication);&#125; 各种模块初始化api和Repository，你要是嫌弃每个模块都要引入两个.class文件，你可以使用一个然后采用include的方式好比dagger中的AndroidSupportInjectionModule类方式 123456789@Beta@Module(includes = AndroidInjectionModule.class)public abstract class AndroidSupportInjectionModule &#123; @Multibinds abstract Map&lt;Class&lt;? extends Fragment&gt;, AndroidInjector.Factory&lt;? extends Fragment&gt;&gt; supportFragmentInjectorFactories(); private AndroidSupportInjectionModule() &#123;&#125;&#125; 这样就会很清楚的知道自己模块需要初始化什么和使用什么，也不用考虑其它模块的初始化的数据，之后只需要在主app加入就行，也是比较方便的。 打包各种模块当为library是要打包成aar的，maven-release-kline-aar.gradle文件代码如下: 1234567891011121314151617181920212223242526272829303132apply plugin: 'maven'ext &#123;// ext is a gradle closure allowing the declaration of global properties PUBLISH_GROUP_ID = 'com.wkw' PUBLISH_ARTIFACT_ID = 'archives' PUBLISH_VERSION = rootProject.ext.versionName&#125;uploadArchives &#123; repositories.mavenDeployer &#123; //这里就是最后输出地址，在自己电脑上新建个文件夹，把文件夹路径粘贴在此 //注意”file://“ + 路径，有三个斜杠，别漏了 repository(url: "file:///Users/wukewei/Documents/android/ModularizationExample/repo") pom.project &#123; groupId project.PUBLISH_GROUP_ID artifactId project.PUBLISH_ARTIFACT_ID version project.PUBLISH_VERSION &#125; &#125;&#125;//以下代码会生成jar包源文件，如果是不开源码，请不要输入这段//aar包内包含注释task androidSourcesJar(type: Jar) &#123; classifier = 'sources' from android.sourceSets.main.java.sourceFiles&#125;artifacts &#123; archives androidSourcesJar&#125; 我只是打包到本地，你可以自己建立一个本地maven库。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-自定义皮肤]]></title>
      <url>%2F2017%2F08%2F23%2Fandroid-custom-skin%2F</url>
      <content type="text"><![CDATA[自定义Style和Theme Style和Theme主要用来实现白天模式和夜间模式。 一个Style是一系列属性的集合，用来指定View或者Window的外观和格式。它可以指定的属性包括高度, Padding, 文字颜色，文字尺寸，背景颜色等等。 Style是在Xml资源文件中定义的，比如： 12345&lt;style name="ListItemTitleStyle" parent="TextAppearance.AppCompat.Body1"&gt; &lt;item name="android:singleLine"&gt;true&lt;/item&gt; &lt;item name="android:ellipsize"&gt;end&lt;/item&gt; &lt;item name="android:textColor"&gt;?android:attr/textColorPrimary&lt;/item&gt;&lt;/style&gt; 在布局文件中是这样使用的： 12345&lt;TextView android:id="@+id/text_item_title" android:layout_width="match_parent" android:layout_height="wrap_content" style="@style/ListItemTitleStyle" /&gt; 这样一个Style就可以运用在多个地方，既可以统一样式，又可以减少代码量。 而Theme，其实就是一个Style，不同于我们上面提到对单一View的应用，Theme是应用于整个Activity或Application的。各位Android开发同学一定不陌生，在Manifest的Activity声明中就会经常看到。 1&lt;activity android:theme="@style/AppLightTheme.NoActionBar"/&gt; 这样，AppLightTheme.NoActionBar中的所有属性都会应用在整个Activity中。 轻听这里，实现夜间模式分三步： 自定义Style 应用Style中的属性 设置Theme 自定义Style 我们这里，就是写两个Style ，然后各自有一套对应的颜色值。 简单介绍一下几个主要的颜色值： colorPrimary: 主题色 colorAccent: 辅助色（或强调色） textColorPrimary: 主要的文字颜色，一般TextView的文字都是这个颜色 textColorSecondary: 辅助的文字颜色，一般比textColorPrimary的颜色弱一点，用于一些弱化的表示 windowBackground: Window的背景色 我们在资源文件中写对应的两套Style: 123456789101112131415&lt;style name="AppLightTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;item name="android:textColorPrimary"&gt;@color/colorPrimaryTextBlack&lt;/item&gt; &lt;item name="android:textColorSecondary"&gt;@color/colorSubTextBlack&lt;/item&gt; &lt;item name="android:windowBackground"&gt;@color/white&lt;/item&gt;&lt;/style&gt;&lt;style name="AppDarkTheme" parent="Theme.AppCompat.DayNight.DarkActionBar"&gt; &lt;item name="colorPrimary"&gt;@color/darkColorPrimary&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/darkColorAccent&lt;/item&gt; &lt;item name="android:textColorPrimary"&gt;@color/white&lt;/item&gt; &lt;item name="android:textColorSecondary"&gt;@color/colorSubTextWhite&lt;/item&gt; &lt;item name="android:windowBackground"&gt;@color/dark_bg&lt;/item&gt;&lt;/style&gt; 细心的同学会发现，Style里的属性，有的前面会以“android:”开头，如android:textColorPrimary，有的则没有，如colorPrimary。 以“android:”开头的属性，是系统的属性。而另一种属于自定义的属性，在资源文件中声明如下： 1&lt;attr name="minibar_background" format="color" /&gt; format包括boolean, color, dimension, enum, flag, float, fraction, integer, reference, string。 在此就不赘述了，这是它们的一个相当灵活的使用方式。 应用Style中的属性 比如，colorAccent是在design包中定义的，属于自定义属性，在使用的时候，直接“?attr/”+属性名就可以了。 12&lt;ImageView android:tint="?attr/colorAccent" /&gt; 系统属性要多加一个”android:”, 是”?android:attr/“+属性名。 12&lt;TextView android:textColor="?android:attr/textColorPrimary"/&gt; 这样，当指定了Theme之后，就会去相应的Style下面取对应的颜色值，从而呈现出不同的色彩。 设置Theme 在Manifest中设置是常见的方式。 &lt;activity android:theme=&quot;@style/AppLightTheme.NoActionBar&quot;/&gt; 不过为了实现模式的切换，我们是在Activity的onCreate中进行的设置 1234567protected void initTheme() &#123; if (MusicPreferences.getInstance().isNightMode()) &#123; setTheme(R.style.AppDarkTheme_NoActionBar); &#125; else &#123; setTheme(R.style.AppLightTheme_NoActionBar); &#125;&#125; 这样，通过给Activity设置不同的Theme，页面就能呈现出不同的颜色搭配。 问题 Style和Theme的方式实现简单，非常适用于模式较为固定的场景，如白天模式和夜间模式。 但是，轻听在白天的模式的时候的基础之上还有几种不同的主题色。 简单聊一下主题色。 主题色，即colorPrimary，是根据品牌形象，为App定义的一个主色调，一般应用于AppBar。 同时，有一个强调色，即colorAccent，是用在Checkbox或下划线等需要给人以提示作用的地方，起辅助的作用。 还有一个颜色是colorPrimaryDark，就是比colorPrimary稍微深一些，主要用在状态栏。 比如上图中，“蓝色”就是主题色，“红”色就是强调色。 主题色和强调色的色值可以不一样，也可以一样。在一般的设计中都是不同的。在轻听的设计中，为了突出品牌色，将强调色跟主题色统一设计成了一个颜色，所以你会看到，到处都是“绿”色。 在强调色跟主题色统一的情况下，6个主题色，6套Style，似乎还可以接受。 但是，万一以后设计同学良心发现了呢？6在6套主题色的基础之上再出6套强调色，那可就是36个Style。如果以后的调色方式再更为灵活，如： 我数学不好，谁帮我算算，别忘了加上强调色还得再平方一下…… 如果给每一个主题色都写一套Style，工作量会很大，而且不灵活。这个时候Style就玩不转了。 我们需要一种更为灵活的方案。 动态配置主题色 动态配置主题色是借鉴了github开源控件app-theme-engine。在gradle中引入方式是: 123compile(&apos;com.github.naman14:app-theme-engine:0.5.1@aar&apos;) &#123; transitive = true&#125; 由于找不到这个项目维护的地址，所以我们自己进行了扩展和优化。 主要由三个模块组成 颜色配置 颜色处理器 遍历逻辑控制器 颜色配置 颜色配置主要负责存储颜色值。 因为这里存储数据较小，而且简单，所以用SharedPreference来存储，稍加封装就可以。 颜色处理器 颜色处理器Processor主要负责对每一个View的各种颜色进行设置。 首先，定义一个接口 123public interface Processor&lt;T extends View, E&gt; &#123; void process(@NonNull Context context, @Nullable String key, @Nullable T target, @Nullable E extra);&#125; process方法就是来处理视图颜色的。 其中target就是要传入的视图，这里使用泛型，在各个派生的Processor中具体实现。 以下是几个主要的Processor。 其中DefaultProcessor是默认Processor，可以处理绝大部分的变色情况。其他几种，如他们的名字一样，会额外再处理他们特定的情况。 Processor的处理方式分三步： 给View设置tag 解析View的tag 根据具体的tag进行颜色的设置 以DefaultProcessor为例。有一个TextView，我们要使他的文字颜色为强调色。 首先，给View设置一个tag，”text_accent_color”。如果有多个tag，以逗号分隔。 123&lt;TextView android:tag="text_accent_color" /&gt; 然后在process方法中将tag解析出来 1234567891011121314151617public void process(@NonNull Context context, @Nullable String key, @Nullable View view, @Nullable Void extra) &#123; if(view != null &amp;&amp; view.getTag() != null &amp;&amp; view.getTag() instanceof String) &#123; String tag = (String)view.getTag(); if(tag.contains(",")) &#123; String[] splitTags = tag.split(","); int len = splitTags.length; for(int i = 0; i &lt; len; ++i) &#123; String part = splitTags[i]; processTagPart(context, view, part, key); &#125; &#125; else &#123; processTagPart(context, view, tag, key); &#125; &#125;&#125; 这里会根据分隔符（逗号）来对tag的数量进行解析，然后依次根据每个tag依次处理。 在处理方法processTagPart中，会找到”text_accent_color”相对应的处理逻辑 123if (view instanceof TextView) &#123; ((TextView) view).setTextColor(Config.accentColor(context, key));&#125; Config.accentColor(context, key)的作用就是从颜色配置模块中读取当前的强调色。 其他一些稍微复杂一点的情况，则可以使用相对应的Processor去进行特殊的处理。 例如，ViewPagerProcessor。ViewPager在滑动边界的时候会有一个边界反馈的效果，如下图： 这里需要特殊处理一下。ViewPager中，负责两个边缘效果的是EdgeEffectCompat。 1234567private EdgeEffectCompat mLeftEdge;private EdgeEffectCompat mRightEdge; EdgeEffectCompat是一个对系统版本做兼容性处理的类，里面有真正的边缘效果模块EdgeEffectpublic final class EdgeEffectCompat &#123; private Object mEdgeEffect;&#125; 注意到，这两处都是私有的，所以我们必须通过两次反射来获取EdgeEffect，然后更改颜色。 首先，通过反射获取ViewPager的左右EdgeEffectCompat。 1234567891011121314151617181920public static void setEdgeGlowColor(@NonNull ViewPager viewPager, @ColorInt int color) &#123; if(Build.VERSION.SDK_INT &gt;= 21) &#123; try &#123; Field edgeLeft = ViewPager.class.getDeclaredField("mLeftEdge"); edgeLeft.setAccessible(true); Field edgeRight = ViewPager.class.getDeclaredField("mRightEdge"); edgeRight.setAccessible(true); EdgeEffectCompat ee = (EdgeEffectCompat)edgeLeft.get(viewPager); if (ee != null) &#123; setEdgeGlowColor(ee, color); &#125; ee = (EdgeEffectCompat)edgeRight.get(viewPager); if (ee != null) &#123; setEdgeGlowColor(ee, color); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 然后再获取真正的EdgeEffect，并更改颜色。 12345678910private static void setEdgeGlowColor(@NonNull EdgeEffectCompat edgeEffect, @ColorInt int color) throws Exception &#123; if(Build.VERSION.SDK_INT &gt;= 21) &#123; Field field = EdgeEffectCompat.class.getDeclaredField("mEdgeEffect"); field.setAccessible(true); EdgeEffect effect = (EdgeEffect) field.get(edgeEffect); if (effect != null) &#123; effect.setColor(color); &#125; &#125;&#125; 这样边缘效果的颜色就修改好啦。 遍历逻辑 遍历逻辑控制器主要负责对整个页面的所有View进行遍历，并进行颜色处理。 以下是遍历逻辑： 初始化Processor 1234567891011private static void initProcessors() &#123; mProcessors = new HashMap(); mProcessors.put("[default]", new DefaultProcessor()); mProcessors.put(ScrollView.class.getName(), new MusicScrollViewProcessor()); mProcessors.put(ListView.class.getName(), new MusicListViewProcessor()); mProcessors.put(RecyclerView.class.getName(), new MusicRecyclerViewProcessor()); mProcessors.put(Toolbar.class.getName(), new MusicToolbarProcessor()); mProcessors.put(NavigationView.class.getName(), new MusicNavigationViewProcessor()); mProcessors.put(TabLayout.class.getName(), new MusicTabLayoutProcessor()); mProcessors.put(ViewPager.class.getName(), new MusicViewPagerProcessor());&#125; 将各Processor实例化后存入HashMap，key为类名。 开始刷新的时机是onStart，因为这个时候布局已经基本初始化完毕。我们会判断Activity之前是否start过，避免重复的进行处理。至于在此之后生成的布局，会单独对其进行一次刷新。 从流程图中可以看出，在处理ContentView之前，我们会单独处理几个特殊的布局。 StatusBar是顶部状态栏，NavigationBar是底部导航栏，有时我们会希望让这两处也兼容主题色。 如果用到ActionBar，也需要处理一下。不过MD的实现中，一般都是NoActionBar的，而用我们自己布局的ToolBar来代替。 在有侧边栏的页面中，根布局一般都是DrawerLayout，在侧边栏滑出的时候，可以设置DrawerLayout的状态栏颜色。 找我们自己的根布局：ContentViewContentView就是我们用setContentView设置的布局，它上面还有ContentParent，DecorView，Window。 直接根据资源id找？不现实，因为每个Activity的ContentView资源id基本都不一样的。 这里采取一种迂回的方式，先找到ContentView的父布局ContentParent。 我们看setContentView的代码： 12345678@Overridepublic void setContentView(int resId) &#123; ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged();&#125; 可以看到，实际上ContentParent的资源id是固定的：android.R.id.content。 系统会先把ContentParent的子视图清除，然后通过LayoutInflater的inflate方法将我们指定布局的视图解析出来并添加到ContentParent中。 那么我们就可以根据android.R.id.content先找到ContentParent，进而找到ContentView 1ViewGroup contentView = (ViewGroup) ((ViewGroup) activity.findViewById(android.R.id.content)).getChildAt(0); 获取Processor 根据View的类名获取Processor 123456789101112131415161718192021Processor processor = mProcessors.get(viewClass.getName());if(processor != null) &#123; return processor;&#125; else &#123; Class current = viewClass; do &#123; current = current.getSuperclass(); if(current == null) &#123; break; &#125; processor = mProcessors.get(current.getName()); &#125; while(processor == null); if (processor == null) &#123; mProcessors.get("[default]") &#125; return processor;&#125; 从HashMap中获取对应的Processor，如果找不到则根据父类的名字查找。找到之后就可以调用process方法进行处理。 遍历 这里会从ContentView开始进行深度优先遍历，处理所有的视图。 有一些特殊的ViewGroup不需要遍历其子布局，例如TabLayout，因为其自己的方法已经满足绝大部分的情况。 结语 以上，就是两种变色方案的具体实现。 自定义Style和Theme实现简单，整洁，适用于模式较为固定的场景。 动态配置主题色实现起来略微复杂，但是比较灵活，适用于主题色较多的场景。 将这两种方案结合，就实现了轻听的变色。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-自定义锁屏页]]></title>
      <url>%2F2017%2F08%2F22%2Fandroid-custom-lock-screen%2F</url>
      <content type="text"><![CDATA[一、为什么需要自定义锁屏页 锁屏作为一种黑白屏时代就存在的手机功能，至今仍发挥着巨大作用，特别是触屏时代的到来，锁屏的功用被发挥到了极致。多少人曾经在无聊的时候每隔几分钟划开锁屏再关上，孜孜不倦，其酸爽程度不亚于捏气泡膜。确实，一款漂亮的锁屏能为手机增色不少，但锁屏存在的核心目的主要是三个：保护自己手机的隐私，防止误操作，在不关闭系统软件的情况下节省电量。 当下，各个款式的手机自带的系统锁屏完全能够满足这些需求，而且美观程度非凡，那么开发者为什么仍然需要构建自定义锁屏呢？让我们试想一个场景，一位正在使用音乐播放器听歌的美女用户，在没有播放器自定义锁屏的情况下，切换一首歌需要几步（参考自同类文章）： 点亮手机屏幕 解开系统锁屏 打开音乐播放器 切歌再熄灭屏幕 这时的她估计已经被广场舞的歌曲骚扰了有10秒，续了10次命，这是我们程序员不愿意看到的，所以有必要依靠我们灵活的双手构建出自定义的音乐锁屏页，将切歌过程被压缩为两步：点亮屏幕和切歌，顺便可以看看歌词。如果再加个开启和关闭自定义锁屏的开关，就能完美解决用户的痛点。 二、自定义锁屏页的基本原理 然而，要实现一个自定义锁屏是一件繁琐的事情，因为系统有100种方法让这个非本地的锁屏待不下去。但是，人类的智慧是无限的，程序员需要逆流而上。 Android系统实现自定义锁屏页的思路很简单，即在App启动时开启一个service，在Service中时刻监听系统SCREEN_OFF的广播，当屏幕熄灭时，Service监听到广播，开启一个锁屏页Activity在屏幕最上层显示，该Activity创建的同时会去掉系统锁屏（当然如果有密码是禁不掉的）。示意图如下： 道理很简单，我们这里需要讨论的是细节。 广播注册 Service是普通的Service，在应用启动时直接startService，与应用同一个进程即可。此外，SCREEN_OFF广播监听必须是动态注册的，如果在AndroidManifest.xml中静态注册将无法接收到SCREEN_OFF广播，这点在Android官方文档中有明确说明，即需要通过如下代码注册： 123IntentFilter mSereenOffFilter = new IntentFilter();mScreenOffFilter.addAction(Intent.ACTION_SCREEN_OFF);registerReceiver(mScreenOffReveiver,mScreenOffFilter); 对应的BroadcastReceiver定义如下： 1234567891011private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver()&#123; @SuppressWarnings("deprecation") @Override public void onReceive(Context context,Intent intent)&#123; if(intent.getAction().equals(NOTIFY_SCREEN_OFF))&#123; Intent mLockIntent = new Intent(context, LockScreenActivity.class); mLockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); startActivity(mLockIntent); &#125; &#125;&#125; 关于启动Activity时Intent的Flag问题，如果不添加FLAG_ACTIVITY_NEW_TASK的标志位，会出现“Calling startActivity() from outside of an Activity”的运行时异常，毕竟我们是从Service启动的Activity。Activity要存在于activity的栈中，而Service在启动activity时必然不存在一个activity的栈，所以要新起一个栈，并装入启动的activity。使用该标志位时，也需要在AndroidManifest中声明taskAffinity，即新task的名称，否则锁屏Activity实质上还是在建立在原来App的task栈中。 标志位FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS，是为了避免在最近使用程序列表出现Service所启动的Activity,但这个标志位不是必须的，其使用依情况而定。 Activity设置 锁屏的activity内部也要做相应的配置，让activity在锁屏时也能够显示，同时去掉系统锁屏。当然如果设置了系统锁屏密码，系统锁屏是没有办法去掉的，这里考虑没有设置密码的情况。 典型的去掉系统锁屏页的方法是使用KeyguardManager，具体代码如下： 123KeyguardManager mKeyguardManager = (KeyguardManager)getSystemService(Context.KEYGUARD_SERVICE);KeyguardManager.KeyguardLock mKeyguardLock = mKeyguardManager.newKeyguardLock("CustomLockScreen");mKeyguardLock.disableKeyguard(); 其中，KeyguardManager是锁屏管理类，我们通过getSystemService()的方式获取实例对象mKeyguardManager，调用该对象的newKeyguardLock()方法获取KeyguardManager的内部类KeyguardLock的实例mKeyguardLock，该方法传入的字符串参数用于标识是谁隐藏了系统锁屏，最后调用mKeyguardLock的disableKeyguard()方法可以取消系统锁屏。 上述方法已经不推荐使用，可以使用更好的方法来替代。我们在自定义锁屏Activity的onCreate()方法里设定以下标志位就能完全实现相同的功能： 12getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);getWindow().addFlags(WindowManager.LayoutParams.FLAG_OW_WHEN_LOCKED); FLAG_DISMISS_KEYGUARD用于去掉系统锁屏页，FLAG_SHOW_WHEN_LOCKED使Activity在锁屏时仍然能够显示。当然，不要忘记在Manifest中加入适当的权限： 1&lt;uses-permission android:name="android.permission.DISABLE_KEYGUARD"/&gt; 屏蔽按键 当自定义锁屏页最终出现在手机上时，我们总希望它像系统锁屏页那样屹立不倒，所有的按键都不能触动它，只有通过划瓶或者指纹才能解锁，因此有必要对按键进行一定程度上的屏蔽。针对只有虚拟按键的手机，我们可以通过隐藏虚拟按键的方式部分解决这个问题，具体方法在后文会介绍。但是当用户在锁屏页底部滑动，隐藏后的虚拟按键还是会滑出，而且如果用户是物理按键的话就必须进行屏蔽了。 Back键和Menu键可以通过重写onKeyDown()方法进行屏蔽： 123456789101112public boolean onKeyDown(int keyCode, KeyEvent event)&#123; int key = event.getKeyCode(); switch(key)&#123; case KeyEvent.KEYCODE_BACK:&#123; return true; &#125; case KeyEvent.KEYCODE_MENU:&#123; return true; &#125; &#125; return super.onKeyDown(keyCode,event);&#125; Home键与Recent键（调出最近打开应用的按键）的点击事件是在framework层进行处理的，因此onKeyDown与dispatchKeyEvent都捕获不到点击事件。关于这两个按键的屏蔽方法，网上相关的资料有很多，有的用到了反射，有的通过改变Window的标志位和Type等，总的来说这些方法只对部分android版本有效，有的则完全无法编译通过。其实，这么做的目的无非是为了实现一个纯粹的锁屏页，但是这种做法有些画蛇添足，容易造成锁屏页的异常崩溃，我们要满足的是用户在锁屏页的快捷操作，Home键和Recent键无关痛痒，完全可以不管,少一些套路，多一点真诚嘛。 划屏解锁 做完以上几步，当屏幕熄灭后，再打开屏幕就能够看到我们的自定义锁屏页了，但是这时候，就算划破手指也无法解锁。所以，接下来要实现划屏解锁。 划瓶解锁的基本思路很简单，当手指在屏幕上滑动时，拦截并处理滑动事件，使锁屏页面随着手指运动，当运动到达一定的阀值时，用户手指松开手指，锁屏页自动滑动到屏幕边界消失，如果没有达到运动阀值，就会自动滑动到起始位置，重新覆盖屏幕。 为了将划屏逻辑与页面内容隔离开来，我们在锁屏页面布局中添加一个自定义的UnderView，这个UnderView填充整个屏幕，位于锁屏内容View（将其引用称之为mMoveView,并传入到UnderView中）的下方，所有划屏相关的事件都在这里拦截并处理。 mMoveView是锁屏页的显示内容，除了处理一些简单的点击事件，其他非点击事件序列都由底层的UnderView进行处理。只需要重写UnderView的onTouchEvent方法就能够实现： 123456789101112131415161718@Overridepublic boolean onTouchEvent(MotionEvent event)&#123; final int action = event.getAction(); final float nx = event.getX(); switch(action)&#123; case MotionEvent.ACTION_DOWN: mStartX = nx; onAnimationEnd(); case MotionEvent.ACTION_MOVE: handleMoveView(nx); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: doTriggerEvent(nx); break; &#125; return true;&#125; 其中，mStartX记录滑动操作起始的x坐标，handleMoveView方法控制mMoveView随手指的移动，doTriggerEvent处理手指离开后mMoveView的移动动画。两个方法的定义如下： 1234567891011private void handleMoveView(float x)&#123; float movex = x - mStartX; if(movex &lt; 0) movex = 0; mMoveView.setTranslationX(movex); float mWidthFloat = (float) mWidth; // 屏幕显示宽度 if(getBackground() != null)&#123; getBackground().setAlpha((int) ((mWidthFloat - mMoveView.getTranslationX()) / mWidthFloat * 200)); //初始透明度的值为200 &#125;&#125; 在handleMoveView()中，首先计算当前触点x坐标与初始x坐标mStartX的差值movex，然后调用mMoveView的setTranslationX方法移动。值得注意的是，目前setTranslationX方法只能在Android 3.0以上版本使用，如果采用动画兼容库nineoldandroid中ViewHelper类提供的setTranslation方法，则没有这个问题。scrollTo与scrollBy也可以实现移动，但是只是移动View的内容，并不能移动View本身。另外就是通过修改布局参数LayoutParams实现移动，虽然没有版本的限制，用起来相对复杂。这里我们采用setTranslationX，为了简洁，也是为了能够与后续使用的属性动画相统一。 此外，我们可以通过getBackground()获取UnderView的背景，并根据已划开屏幕占整个屏幕的百分比调用setAlpha方法改变背景的透明度，做出抽屉拉开时的光影变化效果。 123456789101112131415161718192021222324252627282930private void doTriggerEvent(float x)&#123; float movex = x - mStartX; if(movex &gt; (mWidth * 0.4))&#123; moveMoveView(mWidth - mMoveView.getLeft(),true);//自动移动到屏幕右边界之外，并finish掉 &#125; else &#123; moveMoveView(-mMoveView.getLeft(),false);//自动移动回初始位置，重新覆盖 &#125;&#125;private void moveMoveView(float to,boolean exit)&#123; ObjectAnimator animator = ObjectAnimator.ofFloat(mMoveView, "translationX",to); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener()&#123; @Override public void onAnimationUpdate(new ValueAnimator animation)&#123; if(getBackground() != null)&#123; getBackground().setAlpha((int)(((float)mWidth - mMoveView.getTranslationX()) / (float) mWidth * 200)); &#125; &#125; &#125;);//随意动动画背景更新背景透明度 animator.setDuration(250).start(); if(exit)&#123; animator.addListener(new AnimatorListenerAdapter()&#123; @Override public void onAnimationEnd(Animator animation)&#123; mainHandler.obtainMessage(LockScreenAcitvity.MSG_LAUNCH_HOME).sendToTarget(); super.onAnimationEnd(animation); &#125; &#125;); &#125;//监听动画结束，利用Handler通知Activity退出&#125; 当手指离开屏幕，doTraiggerEvent方法会对滑动的距离与阀值进行一个比较，此处的阀值为0.4*屏幕宽度，如果低于阀值，则通过ObjectAnimator在0.25s将mMoveView移动到初始位置，同时在ObjectAnimator的AnimatorUpdateListener的onAnimationUpdate方法中更新背景透明度；如果低于阀值，以同样的方式将mMoveView移出屏幕右边界，然后将Activity干掉，具体做法是为animator增加一个AnimatorListenerAdapter的监听器，在该监听器的onAnimationEnd方法中使用在Activity中定义的mHandler发送finish消息，完成解锁，效果如下图： 三、透明栏与沉浸模式 沉浸模式与透明栏是两个不同的概念，由于某些原因，国内一些开发或产品会把这两个概念混淆。不过没关系，在接下来的内容我们会对这两个概念进行详细的解释和区分，并应用这两种不同的模式进一步完善已经初具模样的锁屏页。 沉浸模式 什么是沉浸模式？从4.4开始，Android 为 “setSystemUiVisibility()”方法提供了新的标记 “SYSTEM_UI_FLAG_IMMERSIVE”以及”SYSTEM_UI_FLAG_IMMERSIVE_STIKY”，就是我们所谈的沉浸模式，全称为 “Immersive Full-Screen Mode”，它可以使你的app隐藏状态栏和导航栏，实现真正意义上的全屏体验。 之前 Android 也是有全屏模式的，主要通过”setSystemUiVisibility()”添加两个Flag，即”SYSTEM_UI_FLAG_FULLSCREEN”，”SYSTEM_UI_FLAG_HIDE_NAVIGATION”（仅适用于使用导航栏的设备，即虚拟按键）。 这两个标记都存在一些问题，例如使用第一个标记的时候，除非 App 提供暂时退出全屏模式的功能（例如部分电子书软件中点击一次屏幕中央位置），用户是一直都没法看见状态栏的。这样，如果用户想去看看通知中心有什么通知，那就必须点击一次屏幕，显示状态栏，然后才能调出通知中心。 而第二个标记的问题在于，Google 认为导航栏对于用户来说是十分重要的，所以只会短暂隐藏导航栏。一旦用户做其他操作，例如点击一次屏幕，导航栏就会马上被重新调出。这样的设定对于看图软件，视频软件等等没什么大问题，但是对于游戏之类用户需要经常点击屏幕的 App，那就几乎是悲剧了——这也是为什么你在 Android 4.4 之前找不到什么全屏模式会自动隐藏导航栏的应用。 Android 4.4 之后加入的Immersive Full-Screen Mode 允许用户在应用全屏的情况下，通过在原有的状态栏/导航栏区域内做向内滑动的手势来实现短暂调出状态栏和导航栏的操作，且不会影响应用的正常全屏，短暂调出的状态栏和导航栏会呈半透明状态，并且在一段时间内或者用户与应用内元素进行互动的情况下自动隐藏，沉浸模式的四种状态如下图。（参考） 状态1代表没有进入沉浸模式时页面的状态，仍然可以看到Status Bar和Navigation Bar；状态2代表用户第一次进入沉浸模式时，系统的提示弹窗，告诉用户如何在沉浸模式下呼出Status Bar和Navigation Bar；状态3代表沉浸模式，可以看到Status Bar和Navigation Bar都被隐藏；状态4代表用户在Sticky沉浸模式下呼出Status Bar和Navigation Bar，可以看到两个Bar重新出现，但是过一段时间能够自动隐藏。 一般来说，沉浸模式的标记与其他Full Screen相关的Flag搭配起来才能达到我们想要的效果，即通过沉浸模式标记规定状态栏status bar和导航栏navigation bar显示和隐藏的运转逻辑，通过其他标签设定状态栏和导航栏显示或隐藏，以及显示或隐藏的样子。这些常见的Flag及相应功能如下表： 如此多的标签，看起来非常乱，但用起来却非常简单和明确，感兴趣的开发者可以自由搭配来测试一下。下面，我们通过一个例子，将这些标签应用于锁屏页，实现对Navigation Bar的自动隐藏，同时保留Status Bar。代码非常简单，在Activity的onCreate()方法中使用： 1234567getWindow().getDecorView().getSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) 总共用到了5个Flag：SYSTEM_UI_FLAG_LAYOUT_STABLE保持整个View稳定，使View不会因为SystemUI的变化而做layout；SYSTEM_UI_FLAG_IMMERSIVE_STIKY，能够在隐藏的bar被呼出时（比如从屏幕下边缘开始向上做滑动手势），使bar在无相关操作的情况下自动再次隐藏；对于SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION，开发者容易被其中的HIDE_NAVIGATION所迷惑，其实这个Flag没有隐藏导航栏的功能，只是控制导航栏浮在屏幕上层，不占据屏幕布局空间；SYSTEM_UI_FLAG_HIDE_NAVIGATION，才是能够隐藏导航栏的Flag；SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN，由上面可知，也不能隐藏状态栏，只是使状态栏浮在屏幕上层。 需要注意的是，这段代码除了需要加在Activity的OnCreate()方法中，也要加在重写的onWindowFocusChanged()方法中，在窗口获取焦点时再将Flag设置一遍，否则可能导致无法达到预想的效果。 12345678910111213@Overridepublic void onWindowFocusChanged(boolean hasFocus)&#123; super.onWindowFocusChanged(hasFocus); if(hasFocus)&#123; getWindow().getDecorView().setSystemUiVisiblity( View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION ) &#125;&#125; 此外，有个部份要稍微留意一下，如果不希望界面的内容被上拉到状态栏(Status bar)的话，要记得在界面(Layout)XML文件中，在最外层Layout中将fitsSystemWindows属性设置为true。如下： 123456&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true"&gt;&lt;/RelativeLayout&gt; 手指在屏幕底端上划，Navigation Bar会弹出，悬浮于锁屏页底部，随后自动消失。Status Bar也按照我们预期的那样，悬浮在上方，没有隐藏。 透明栏 什么是透明栏？Google 在 Android 4.4 的 API 描述页面里提到了“Translucent system UI styling”，即半透明化的系统UI风格。这个“半透明化”包括了状态栏和通知栏，当开发者让应用支持这个新特性的时候，状态栏和导航栏可以单独/同时变为渐变的半透明样式，如下图： 在 Android 5.0 之后引入了 Material Design，状态栏和导航栏也玩出了更多花样。现在除了原有的“半透明”模式以外，还有“全透明”以及“变色”模式，一种会完全隐藏背景，另一种可以取色作为背景颜色，多种样式的透明栏如下图（上图为透明状态栏，下图为透明导航栏）： 所以，透明栏只是能够改变状态栏和导航栏的颜色，并不像沉浸模式那样隐藏状态栏和导航栏，两者是有本质区别的。 对于Android 4.4以上5.0以下的版本，设置透明状态栏的方式如下： 1234if(Build.VERSION&gt;SDK_INT &gt;= Build.VERSION_CODES.KITKAT)&#123; Window window = getWindow(); window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);&#125; 对于Android 5.0及以上版本，设置透明状态栏的方法如下： 1234567if(Build.VERSION.SDK_INT &gt;= Build.VERSION.LOLLIPOP)&#123; Window window = getWindow(); window.clearFlags(WindowManager.LayoutParams.FLAG_TrANSLUCENT_STATUS); window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE); window.addFlags(WindowManager.LayoutParams.Flag_DRAWS_SYSTEM_BAR_BACKGROUNDS); window.setStatusBarColor(0);&#125; 除了要清理掉4.4的FLAG_TRANSLUCENT_STATUS外，还要配合SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE，添加标志位FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS，并调用setStatusBarColor设置状态栏的颜色为透明。 四、指纹解锁 到这里，我们的锁屏页已经基本完工，完全能够非常优雅地解决用户的痛点，但是跟当下App自定义锁屏页的区别并不明显。接下来对新型号手机普遍具备的指纹解锁功能的考虑，则能够为锁屏页增色不少。 指纹识别无法解锁自定义锁屏页的问题 持有指纹解锁手机的用户在使用App自定义锁屏页时会出现一种困惑，当你点亮屏幕，能够看到自定义锁屏页，在使用指纹解锁成功之后（部分机型指纹解锁操作只能在系统锁屏页进行），自定义锁屏页依然存在，你还是需要划开自定义锁屏页，才能看到手机主界面。 解决这一问题的方案是一种取巧的方法，那就是在锁屏页的service中监听ACTION_USER_PRESENT广播。ACTION_USER_PRESENT广播是系统锁屏解锁广播，当系统锁屏页解锁时就会触发。如果在接收到这一广播时，将自定义锁屏页finish掉，就能避免在指纹解锁成功后自定义锁屏页仍然显示的问题。但是细心的读者会发现这种解法在逻辑上还存在问题，因为在用户没有设置锁屏密码的情况下，前文自定义锁屏页在onCreate()时设置的FLAG_DISMISS_KEYGUARD标志位能够轻易解锁系统的锁屏页，并触发ACTION_USER_PRESENT广播，此时自定义锁屏页的Service接收到这一广播后，发finish广播给自定义锁屏页，导致自定义锁屏页刚create就finish掉了，永远不可能出现。 因此，我们必须对场景进行区分，只在有锁屏密码的情况下，才对接收到的ACTION_USER_PRESENT广播进行处理，finish自定义锁屏页。即在BroadcastReceiver的onReceive()方法中加入如下代码: 123456789if(intent.getAction().equals(Intent.ACTION_USER_PRESENT))&#123; if(VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN)&#123; if(km.isKeyguardSecure())&#123; MLog.d(TAG,"KeyguardSecure!"); Intent i = new Intent(NOTIFY_USER_PRESENT); context.sendBroadcast(i); &#125; &#125;&#125; 这里KeyguardManager对象km的isKeyguardSecure()方法就是用来判断是否设置了锁屏密码。NOTIFY_USER_PRESENT是自定义广播，用来通知锁屏页Activity调用finish方法。 这种做法是合理的，因为如果没有设置锁屏密码，FLAG_DISMISS_KEYGUARD标志位解锁系统锁屏之后，到达上述代码块，isKeyguardSecure()返回为false，不会导致自定义锁屏页Activity的finish操作。而如果设置了锁屏密码，FLAG_DISMISS_KEYGUARD必然无法解锁系统锁屏，到达不了上述代码块，也不会finish。这样就避免了自定义锁屏页刚创建出来就将自己finish掉的困境。另一方面，其他非FLAG_DISMISS_KEYGUARD方式触发的解锁，比如指纹解锁，都会使Activity消失，满足了需求。 自定义锁屏页下指纹识别无法使用的问题 此外，有些手机型号，比如小米，在自定义锁屏页罩在系统锁屏页之上时（设置有锁屏密码），指纹解锁是无效的，也就是必须要划开自定义锁屏页，在系统锁屏页上才能进行指纹解锁。为了改善这种体验，我们可以在Activity中引入指纹解锁API，识别指纹并解锁，具体代码如下： 123456789101112131415161718192021222324252627private void startFingerPrintListening()&#123; if(!isFingerprintAuthAvailable())&#123; return; &#125; else &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M)&#123; if (checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED) &#123; mFingerprintManager.authenticate(null,mCancellationSignal,0,new FingerprintManager.AuthenticationCallback()&#123; @Override public void onAuthenticationError(int errorCode,CharSequence errString)&#123; super.onAuthenticationError(errorCode,errString); &#125; @Override public void onAuthenticationSucceeded(FingerprintManager.AuthenticationResult result)&#123; super.onAuthenticationSucceeded(result); finish(); &#125; @Override public void onAuthenticationFailed()&#123; super.onAuthenticationFailed(); &#125; &#125;,null); return; &#125; &#125; &#125;&#125; 123456789101112131415161718public boolean isFingerprintAuthAvailable()&#123; if(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M)&#123; mKeyguardManager = (KeyguardManager) getSystemService(Activity.KEYGUARD_SERVICE); if(!mKeyguardManager.isKeyguardSecure())&#123; return false; &#125; if(checkSelfPermission(Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED)&#123; mFingerprintManager = (FingerprintManager)getSystemService(Activity.FINGERPRINT_SERVICE); mCancellationSignal = new CancellationSignal(); return mFingerprintManager.isHardwareDetected() &amp;&amp; mFingerprintManager.hasEnrolledFingerprints(); &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125;&#125; 当然，不要忘记在Manifest中加入适当的权限： 1&lt;uses-permission android:name="android.permission.USEFINGERPRINT"/&gt; 在调用指纹识别功能之前，我们需要判断指纹识别功能是否可用，以及APP是否有相应的权限。这一过程体现在isFingerprintAuthAvailable()中，第一步是获取KeyguardManager对象，调用isKeyguardSecure()判断是否设置有锁屏密码，如果有，则需进一步判断。checkSelfPermission用来判断APP是否有指纹识别的权限(SDK 23要求)，如果有则获取FingerprintManager对象，调用该对象的isHardwareDetected()方法判断指纹识别硬件是否可用，调用hasEnrolledFingerprints()判断是否有事先录入好的指纹，只有以上条件都满足，接下来才能调用指纹识别功能。 指纹识别的调用体现在startFingerPrintListening()方法中，主要就是调用FingerprintManager的方法 1authenticate(FingerprintManager.CryptoObject crypto,CancellationSignal cancel,int flags,FingerprintManager.AuthenticationCallback callback,Handler handler) 其中，crypto参数代表Android6.0中crypto objects的wrapper class，可以通过该对象使authenticate过程更加安全，也可以不使用，这里我们将其设为null；cancel用来取消anthenticate(),我们new出一个对象传入就可以；flags是标志位，设置为0；callback为指纹识别回调，包含指纹识别的核心方法：onAuthenticationError()是指纹匹配连续失败后的回调（几十秒后才能继续匹配），onAuthenticationSucceeded()是指纹匹配成功的回调，onAuthenticationFailed()是指纹匹配失败时的回调。我们在这几个方法中做相应的处理即可，在onAuthenticationSucceeded()方法中调用finish()，就能够在指纹识别成功后关闭Activity。 五、总结 通过以上内容的分享，本鹅希望能够对大家的开发有所帮助，如果内容有问题，也希望大家指点。综上所述，在Android上实现自定义锁屏页并不是一件复杂的事情，关键是对一些技术点的把握要比较清楚。Service中启动Activity的正确方法，广播静态注册与动态注册的差别，touch事件的分发传播机制，透明栏与沉浸模式的综合运用，以及指纹识别新技术的应用，都有很多值得推敲的地方。笔者当初实现自定义锁屏页时，没有太多思考，有时照搬前人的做法，有时各种flag随便添加，有时新旧API混淆，虽然实现了需求，但是代码不够简洁，可读性也差。因此，在今后的开发过程中，除了要快速实现需求，还要在随后的维护中，多多思考和研究，使代码能够达到“少一行不行，多一行难受”的境界。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-ImageView详细学习]]></title>
      <url>%2F2017%2F08%2F17%2Fandroid-imageview%2F</url>
      <content type="text"><![CDATA[ScaleType android:scaleType=&quot;center&quot; 当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按照图片的原大小居中显示，不缩放，用ImageView的大小截取图片的居中部分。 当图片小于ImageView的宽高：直接居中显示该图片。 android:scaleType=&quot;centerCrop&quot; 当图片大于ImageView的宽高：以图片的中心点和ImageView的中心点为基准，按比例缩小图片，直到图片的宽高有一边等于ImageView的宽高，则对于另一边，图片的长度大于或等于ImageView的长度，最后用ImageView的大小居中截取该图片。 当图片小于ImageView的宽高：以图片的中心店和ImageView的中心点为基准，按比例扩大图片，直到图片的宽高大于或等于ImageView的宽高，并按ImageView的大小居中截取该图片。 android:scaleType=&quot;centerInside&quot; 当图片大于ImageView的宽高：以图片的中心和ImageView的中心点为基准，按比例缩小图片，使图片宽高等于或者小于ImagevView的宽高，直到将图片的内容完整居中显示。 当图片小于ImageView的宽高：直接居中显示该图片。 android:scaleType=&quot;fitCenter&quot; 表示把图片按比例扩大（缩小）到ImageView的宽度，居中显示。 android:scaleType=&quot;fitStart&quot; 表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的上方显示。 android:scaleType=&quot;fitEnd&quot; 表示把图片按比例扩大（缩小）到ImageView的宽度，在ImageView的下方显示。 android:scaleType=&quot;fitXY&quot; 表示把图片按指定的大小在ImageView中显示，拉伸或收缩图片，不保持原比例，填满ImageView。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Xfermode详细学习]]></title>
      <url>%2F2017%2F08%2F15%2Fandroid-xfermode%2F</url>
      <content type="text"><![CDATA[XfermodeXfermode具体怎么翻译，说实话，我也不知道，我习惯叫它图片混合模式，随便了，管它叫什么，不妨碍我们使用它。关于Xfermode的说明，可以在Google文档中找到这样的描述：Xfermode是在绘图通道中自定义“传输模式”的基类。静态函数创建可以调用或者返回任意作为模式枚举指定的预定义子类实例。当Xfermode分配给Paint，然后绘制对象与Paint就具备了所添加的xfermode。读起来比较拗口，下面直接看Xfermode的源码： 1234567891011public class Xfermode &#123; protected void finalize() throws Throwable &#123; try &#123; finalizer(native_instance); &#125; finally &#123; super.finalize(); &#125; &#125; private static native void finalizer(long native_instance); long native_instance; &#125; 看，Xfermode就这么点代码，经验告诉我们，其下必有子类，擦，变元芳了~~~ 查看一下文档发现Xfermode确实有AvoidXfermode、PixelXorXfermode、PorterDuffXfermode，下面来继续学习一下3个子类的用法。 AvoidXfermode看这个子类之前告诉大家一个不幸的消息，AvoidXfermode不支持硬件加速，在高于API16的机器上不会适用，如果想测试这个子类。 1，可以关闭手机的硬件加速模块； 2，在AndroidManifest.xml中Application节点上设置硬件加速为false。android:hardwareAccelerated=&quot;false&quot; 在Android Studio下点击查看一下AvoidXfermode的构造方法：public AvoidXfermode(int opColor, int tolerance, Mode mode) AvoidXfermode的构造方法也特别简单，一共接收3个参数：第一个参数opColor是一个16进制的带透明度通道的颜色值，如0X12345678。第二个参数tolerance表示容差值，什么是容差值呢？可以理解成一个表示“精确”和“模糊”的概念，下面会解释一下。第三个参数是AvoidXfermode的模式，AvoidXfermode的模式一共有两种：AvoidXfermode.Mode.TARGET和AvoidXfermode.Mode.AVOID。 AvoidXfermode.Mode.TARGET在该模式下Android会判断画布上的颜色是否会有跟opColor不一样的颜色，比如我opColor是红色，那么在TARGET模式下就会去判断我们的画布上是否有存在红色的地方，如果有，则把该区域“染”上一层我们画笔定义的颜色，否则不“染”色，而tolerance容差值则表示画布上的像素和我们定义的红色之间的差别该是多少的时候才去“染”的，比如当前画布有一个像素的色值是(200, 20, 13)，而我们的红色值为(255, 0, 0)，当tolerance容差值为255时，即便(200, 20, 13)并不等于红色值也会被“染”色，容差值越大“染”色范围越广反之则反，空说无凭我们来看看具体的实现和效果： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class CustomView3 extends View &#123; private Paint mPaint; private Bitmap mBitmap; private Context mContext; private int x, y, w, h; private AvoidXfermode avoidXfermode; public CustomView3(Context context) &#123; this(context, null); &#125; public CustomView3(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; initRes(); initPaint(); &#125; private void initRes() &#123; //加载bitmap mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image); //获取bitmap的展示起始布局 x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2; y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2; w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2; h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2; &#125; private void initPaint() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); avoidXfermode = new AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawBitmap(mBitmap, x, y, mPaint); mPaint.setARGB(255, 211, 53, 243); mPaint.setXfermode(avoidXfermode); canvas.drawRect(x, y, w, h, mPaint); &#125; &#125; 下面来运行看效果，首先确定一下开启的模拟器是API16以下的，或者Application节点下设置了关闭“硬件加速”： AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET)：大家可以看到，在我们的模式为TARGET容差值为0的时候此时只有当图片中像色颜色值为0XFFFFFFFF的地方才会被染色，而其他地方不会有改变 下面我们来修改一下容差值，将容差值改成255： AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.TARGET)而当容差值为255的时候只要是跟0XFFFFFFFF有点接近的地方都会被染色 AvoidXfermode.Mode.AVOID则与TARGET恰恰相反，TARGET是我们指定的颜色是否与画布的颜色一样，而AVOID是我们指定的颜色是否与画布不一样，其他的都与TARGET类似AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.AVOID)： 当模式为AVOID容差值为0时，只有当图片中像素颜色值与0XFFFFFFFF完全不一样的地方才会被染色AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.AVOID)： 当容差值为255时，只要与0XFFFFFFFF稍微有点不一样的地方就会被染色 那么这玩意究竟有什么用呢？比如说当我们只想在白色的区域画点东西或者想把白色区域的地方替换为另一张图片的时候就可以采取这种方式！ PixelXorXfermodePixelXorXfermode是Xfermode下的另外一种图像混排模式，该类特别简单，不过呢，也很不幸的，在API16中已经过时了。我们来做一个简单的了解，先看PixelXorXfermode的构造方法：public PixelXorXfermode(int opColor) 构造方法很简单，只要传递一个16进制带透明通道的颜色值即可，那么这个参数有什么用呢？我在Google文档中，找到了这样的一个算法：实际上PixelXorXfermode内部是按照“opColor ^ src ^ dst”这个异或算法运算的，得到一个不透明的(alpha = 255)的色彩值，设置到图像中，下面我们接着上面用到的图片Demo写个PixelXorXfermode的Demo： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class CustomView3 extends View &#123; private Paint mPaint; private Bitmap mBitmap; private Context mContext; private int x, y, w, h; private PixelXorXfermode pixelXorXfermode; public CustomView3(Context context) &#123; this(context, null); &#125; public CustomView3(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; initRes(); initPaint(); &#125; private void initRes() &#123; //加载bitmap mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image); //获取bitmap的展示起始布局 x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2; y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2; w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2; h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2; &#125; private void initPaint() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); pixelXorXfermode = new PixelXorXfermode(0XFFFF0000); &#125; @Override protected void onDraw(Canvas canvas) &#123; //先绘制Bitmap，src canvas.drawBitmap(mBitmap, x, y, mPaint); //随便设置一个纯色测试 mPaint.setARGB(255, 211, 53, 243); //设置Xfermode mPaint.setXfermode(pixelXorXfermode); //在bitmap上混排一个纯色的矩形（dst） canvas.drawRect(x, y, w, h, mPaint); &#125; &#125; 混排后的图像是： PixelXorXfermode在底层已经取出src，dst每个像素点与opColor进行了opColor ^ src ^ dst运算了，结果输出就是上图所示的那样！好了，我只学这么多了，因为它已经过时了，同样上面的AvoidXfermode也是，过时了，了解即可。下面是对Xfermode的第三个子类，也是唯一一个还没有过时的，非常重要的子类PorterDuffXfermode的学习。 PorterDuffXfermode同样PorterDuffXfermode也是Xfermode的子类，我们先看看它的构造方法：public PorterDuffXfermode(PorterDuff.Mode mode) PorterDuffXfermode的构造方法很简单，构造方法中需要传递一个PorterDuff.Mode参数，关于PorterDuff.Mode，我们在上篇博客中已经学习完了，其实跟ColorFilter的子类PorterDuffColorFilter的混排模式是一样的。Android系统一共提供了18种混排模式，在模拟器的ApiDemos/Graphics/XferModes，有张效果图： 这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。 PorterDuff.Mode也提供了18种混排模式已经算法，其中比上图多了ADD和OVERLAY两种模式： Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[…,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面将会对照ApiDemos/Graphics/XferModes的程序进行修改，来测试各个模块的效果，测试程序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class XfermodeView extends View &#123; //PorterDuff模式常量 可以在此更改不同的模式测试 private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR; private PorterDuffXfermode porterDuffXfermode; private int screenW, screenH; //屏幕宽高 private Bitmap srcBitmap, dstBitmap; //源图和目标图宽高 private int width = 120; private int height = 120; public XfermodeView(Context context) &#123; this(context, null); &#125; public XfermodeView(Context context, AttributeSet attrs) &#123; super(context, attrs); screenW = ScreenUtil.getScreenW((Activity) context); screenH = ScreenUtil.getScreenH((Activity) context); //创建一个PorterDuffXfermode对象 porterDuffXfermode = new PorterDuffXfermode(MODE); //创建原图和目标图 srcBitmap = makeSrc(width, height); dstBitmap = makeDst(width, height); &#125; //创建一个圆形bitmap，作为dst图 private Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); c.drawOval(new RectF(0, 0, w 3 / 4, h 3 / 4), p); return bm; &#125; // 创建一个矩形bitmap，作为src图 private Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); c.drawRect(w / 3, h / 3, w 19 / 20, h 19 / 20, p); return bm; &#125; @Override protected void onDraw(Canvas canvas) &#123; Paint paint = new Paint(); paint.setFilterBitmap(false); paint.setStyle(Paint.Style.FILL); //绘制“src”蓝色矩形原图 canvas.drawBitmap(srcBitmap, screenW / 8 - width / 4, screenH / 12 - height / 4, paint); //绘制“dst”黄色圆形原图 canvas.drawBitmap(dstBitmap, screenW / 2, screenH / 12, paint); //创建一个图层，在图层上演示图形混合后的效果 int sc = canvas.saveLayer(0, 0, screenW, screenH, null, Canvas.MATRIX_SAVE_FLAG | Canvas.CLIP_SAVE_FLAG | Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.FULL_COLOR_LAYER_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG); //先绘制“dst”黄色圆形 canvas.drawBitmap(dstBitmap, screenW / 4, screenH / 3, paint); //设置Paint的Xfermode paint.setXfermode(porterDuffXfermode); canvas.drawBitmap(srcBitmap, screenW / 4, screenH / 3, paint); paint.setXfermode(null); // 还原画布 canvas.restoreToCount(sc); &#125; &#125; 为了方便观察，需要将Activity_main.xml的背景色设置为黑色。 1.PorterDuff.Mode.CLEAR。中文描述：所绘制源图像不会提交到画布上。private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR; 2.PorterDuff.Mode.SRC。中文描述：只显示源图像。private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC; 3.PorterDuff.Mode.DST。中文描述：只显示目标图像。private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST; 4.PorterDuff.Mode.SRC_OVER。中文描述：正常绘制显示，源图像居上显示。private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OVER; 5.PorterDuff.Mode.DST_OVER。中文描述： 上下层都显示。目标图像居上显示。private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OVER; 6.PorterDuff.Mode.SRC_IN。中文描述： 取两层绘制交集中的源图像。private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_IN; 7.PorterDuff.Mode.DST_IN。中文描述：取两层绘制交集中的目标图像。private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_IN; 8.PorterDuff.Mode.SRC_OUT。中文描述：只在源图像和目标图像不相交的地方绘制源图像。private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OUT; 9.PorterDuff.Mode.DST_OUT。中文描述：只在源图像和目标图像不相交的地方绘制目标图像。private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OUT; 10.PorterDuff.Mode.SRC_ATOP。中文描述：在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_ATOP; 11.PorterDuff.Mode.DST_ATOP。中文描述：在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_ATOP; 12.PorterDuff.Mode.XOR。中文描述：异或：去除两图层交集部分private static final PorterDuff.Mode MODE = PorterDuff.Mode.XOR; 13.PorterDuff.Mode.DARKEN。中文描述：取两图层全部区域，交集部分颜色加深private static final PorterDuff.Mode MODE = PorterDuff.Mode.DARKEN; 14.PorterDuff.Mode.LIGHTEN。中文描述：取两图层全部，点亮交集部分颜色private static final PorterDuff.Mode MODE = PorterDuff.Mode.LIGHTEN; 15.PorterDuff.Mode.MULTIPLY。中文描述：取两图层交集部分叠加后颜色private static final PorterDuff.Mode MODE = PorterDuff.Mode.MULTIPLY; 16.PorterDuff.Mode.SCREEN。中文描述：滤色。private static final PorterDuff.Mode MODE = PorterDuff.Mode.SCREEN; 以下是android中新加的两种模式： 17.ADD。中文描述：饱和度相加。private static final PorterDuff.Mode MODE = PorterDuff.Mode.ADD; 18.OVERLAY。中文描述：叠加private static final PorterDuff.Mode MODE = PorterDuff.Mode.OVERLAY;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Paint详细学习]]></title>
      <url>%2F2017%2F08%2F14%2Fandroid-paints%2F</url>
      <content type="text"><![CDATA[前言的确平时开发中，用到画笔的地方还是不多的。但是一遇到自定义View，就会发现这玩意还真是不能不好好掌握，毕竟绘出我们想要的图形界面就靠它了。很多开发人员对画笔Paint的了解知之甚少，包括我自己在内，所以在今天在这里总结一下Paint的在 android图像处理中起到的作用和用法。 Paint的简单了解同样，我们学习Paint之前，首先查看一下Paint类的API，其中，我们最需要关注的地方就是Paint类给我们提供了很多的setter方法，可以通过调用setter方法来设置自己的偏好。下面是在Android Studio中查到的Paint类的部分setter： Paint(int flags)：构建Paint实例，常用的flags是ANTI_ALIAS_FLAG，消除锯齿。 set(Paint src)：将另一个Paint复制给当前Paint实例，不多说了。 setColor(int color)：设置画笔的颜色。 setColorFilter(ColorFilter filter)：设置色彩过滤器，很重要，后面还会有一些总结。 setStyle(Paint.Style style)：设置Paint的风格。 画笔样式分三种：1.Paint.Style.STROKE：描边 。2.Paint.Style.FILL_AND_STROKE：描边并填充 。3.Paint.Style.FILL：填充 。 setAlpha(int a) : 设置绘制图形的透明度。 setAntiAlias(boolean aa)：是否消除锯齿。 setARGB(int a,int r,int g,int b) : 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。 setStrokeWidth(float width)：设置Paint划线的宽度。 setDither(boolean dither) : 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰 setElegantTextHeight(boolean elegant) : //设置优雅的文字高度，这个设置可能会对FontMetrics产生影响 setFakeBoldText(boolean fakeBoldText) : //设置文本粗体 setFilterBitmap(boolean filter) : //对位图进行滤波处理，如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示 setFlags(int flags) : //设置一些标志，比如抗锯齿，下划线等等。 setFontFeatureSettings(String settings) : //设置字体样式，可以设置CSS样式 setHinting(int mode) : 设置画笔的隐藏模式。可以是 HINTING_OFF or HINTING_ON之一。 setLetterSpacing(float letterSpacing) : //设置行的间距，默认值是0，负值行间距会收缩 setLinearText(boolean linearText) : //这个是文本缓存，设置线性文本，如果设置为true就不需要缓存 setMaskFilter(MaskFilter maskfilter) : //对图像进行一定的处理，实现滤镜的效果，如滤化，立体等,有BlurMaskFilter，EmbossMaskFilter几种 setPathEffect(PathEffect effect) : //设置绘制路径的效果，有ComposePathEffect，CornerPathEffect，DashPathEffect，DiscretePathEffect，PathDashPathEffect，SumPathEffect几种 setShader(Shader shader) : //设置着色器，用来给图像着色的，绘制出各种渐变效果，有BitmapShader，ComposeShader，LinearGradient，RadialGradient，SweepGradient几种 setShadowLayer(float radius, float dx, float dy, int shadowColor) : //设置阴影效果，radius为阴影角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 ，看一下演示效果，其中第一个是没有阴影的，第二个设置了黑色的阴影 setStrikeThruText(boolean strikeThruText) : //设置文本的删除线 setStrokeCap(Cap cap) : //设置线条末端形状Paint.Cap.BUTT、Paint.Cap.ROUND、Paint.Cap.SQUARE setStrokeJoin(Join join) : //设置矩形连接时的效果Paint.Join.BEVEL、Paint.Join.MITER、Paint.Join.ROUND setStrokeMiter(float miter) : //当style为Stroke或StrokeAndFill时设置连接处的倾斜度，这个值必须大于0 setSubpixelText(boolean subpixelText) : //设置亚像素，是对文本的一种优化设置，可以让文字看起来更加清晰明显，可以参考一下PC端的控制面板-外观和个性化-调整ClearType文本 setTextAlign(Align align) : //设置文本对齐Paint.Align.CENTER、Paint.Align.LEFT、Paint.Align.RIGHT setTextLocale(Locale locale) ： //设置地理位置，比如显示中文，日文，韩文等，默认的显示Locale.getDefault()即可 setTextScaleX(float scaleX) : //设置字体的水平方向的缩放因子，默认值为1，大于1时会沿X轴水平放大，小于1时会沿X轴水平缩小 setTextSize(float textSize) : //设置字体大小 setTextSkewX(float skewX) : //设置文本在水平方向上的倾斜，默认值为0，推荐的值为-0.25 setTypeface(Typeface typeface) : //设置字体样式，可以是Typeface设置的样式，也可以通过Typeface的createFromAsset(AssetManager mgr, String path)方法加载样式 setUnderlineText(boolean underlineText) : //设置文本的下划线 setXfermode(Xfermode xfermode)：设置Paint的模式，后面有详细点的说明，很重要。 reset() : //重置Paint measureText(char[] text, int index, int count)，measureText(String text, int start, int end)，measureText(String text)，measureText(CharSequence text, int start, int end) : //测量字体的长度 breakText(char[] text, int index, int count,float maxWidth, float[] measuredWidth)，breakText(CharSequence text, int start, int end,boolean measureForwards, floatmaxWidth, float[] measuredWidth)，breakText(String text, boolean measureForwards,float maxWidth, float[] measuredWidth) : //剪切显示，就是大于maxWidth的时候只截取指定长度的显示 getTextWidths(char[] text, int index, int count,float[] widths)，getTextWidths(CharSequence text, int start, int end, float[] widths)，getTextWidths(String text, int start, int end, float[] widths)，getTextWidths(String text, float[] widths) : //提取指定范围内的字符串，保存到widths中 getTextPath(char[] text, int index, int count, float x, float y, Path path)，getTextPath(String text, int start, int end, float x, float y, Path path) : //获取文本绘制的路径，提取到Path中 getTextBounds(String text, int start, int end, Rect bounds)，getTextBounds(char[] text, int index, int count, Rect bounds) : //得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-ColorFilter详细学习]]></title>
      <url>%2F2017%2F08%2F13%2Fandroid-colorfilter%2F</url>
      <content type="text"><![CDATA[前言在Android Studio中点击进去看一下源码，可以看到ColorFilter里的代码量很少 12345678910111213141516171819public class ColorFilter &#123; /** * Holds the pointer to the native SkColorFilter instance. * * @hide */ public long native_instance; @Override protected void finalize() throws Throwable &#123; try &#123; super.finalize(); &#125; finally &#123; destroyFilter(native_instance); &#125; &#125; static native void destroyFilter(long native_instance); &#125; 由此根据我们的经验，判断ColorFilter可能是个父类，具体实现可能下面还有子类完成的，于是再看Google的文档： 一目了然了，ColorFilter下有3个子类ColorMatrixColorFilter, LightingColorFilter, PorterDuffColorFilter ，下面逐一学习一下。 ColorMatrixColorFilterColorMatrixColorFilter翻译为颜色矩阵过滤器，神马是颜色矩阵？实际上， 安卓中管理色彩矩阵是以RGBA像素点的方式加载到内存的，这些点统一使用ColorMatrix的矩阵来统一管理，矩阵定义为4*5的排列形式。那好，首先来看看ColorMatrixColorFilter的两个构造器： 123456789101112public ColorMatrixColorFilter(ColorMatrix matrix) &#123; mMatrix.set(matrix); update(); &#125; public ColorMatrixColorFilter(float[] array) &#123; if (array.length &lt; 20) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; mMatrix.set(array); update(); &#125; ColorMatrixColorFilter中一个构造器需要接收ColorMatrix对象，另一个需要接收一个4*5的float型数组，我们再打开Android Studio追踪一下mMatrix.set()方法，可以看到以上两个构造器里面调的set方法各自实现的方式 1234567public void set(ColorMatrix src) &#123; System.arraycopy(src.mArray, 0, mArray, 0, 20); &#125; public void set(float[] src) &#123; System.arraycopy(src, 0, mArray, 0, 20); &#125; 再追踪一下System.arraycopy()方法： 1public static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length) 好了，到这里，其实已经很明白了，ColorMatrixColorFilter构造器中接收的两个不同的参数，实际上底层实现方式都是一样的，都是同样调用System.arraycopy()中带float数组参数的方法。所以我们不必再考虑怎么样去写一个ColorMatrix对象传递给ColorMatrixColorFilter了，实际上我们使用第二个构造器，传递一个float数组，会显得程序更加直观易懂，那么我们就尝试写一个ColorMatrixColorFilter，并且设置给Paint吧. 123456789101112131415161718192021222324252627282930313233343536public class CustomView1 extends View &#123; private Paint mPaint; private Context mContext; public CustomView1(Context context) &#123; this(context, null); &#125; public CustomView1(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; initPaint(); &#125; private void initPaint() &#123; //初始化Paint，并且设置消除锯齿。 mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); //设置画笔样式为描边 mPaint.setStyle(Paint.Style.FILL); //设置描边的粗细，单位：像素px 注意：当setStrokeWidth(0)的时候描边宽度并不为0而是只占一个像素 mPaint.setStrokeWidth(20); //设置画笔颜色为自定义颜色 mPaint.setColor(Color.argb(255, 255, 128, 102)); ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]&#123; 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0 &#125;); mPaint.setColorFilter(colorFilter); &#125; @Override protected void onDraw(Canvas canvas) &#123; //画一个圆形，取屏幕中心点为圆心 canvas.drawCircle(ScreenUtil.getScreenW(mContext) / 2, ScreenUtil.getScreenH(mContext) / 2, 100, mPaint); &#125; &#125; 看上面的例子程序，首先创建了一个ColorMatrixColorFilter对象，并且传递进去一个float型的4*5排列的数组，然后调用Paint的setColorFilter方法将ColorMatrixColorFilter对象传入，我们在模拟器上运行一下，duang~~，我去，什么变化都没有，还是岛国的旗帜。这是怎么回事？下面有必要在学习一下了： 其实一个4*5的float数组中分别对应的是RGBA的向量值，第一行代表的是R(红色)的向量值，第二行代表G(绿色)的向量值，第三行代表B(蓝色)的向量值，第四行代表A(透明度)的向量值，这4行分别代表不同的RGBA的向量值，并且值的取值范围是[0.0F , 2.0F]，当值为1.0F的时候，表示保持原有的色彩，不发生色彩便宜。so，如果我们想要将上面的红色的圈圈颜色变掉，就不能像上面的代码一样，将所有的向量值都设置为1.0F，下面我们修改一个： 1234567ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]&#123; 0.5F, 0, 0, 0, 0, 0, 0.5F, 0, 0, 0, 0, 0, 0.5F, 0, 0, 0, 0, 0, 1, 0 &#125;); mPaint.setColorFilter(colorFilter); 将上面的ColorMatrixColorFilter中的float数组替换成这样的哎哟呵~颜色变深了，看起来神奇很多。那么，这个色彩矩阵以及这个float数组是怎样做到的呢？或者说是怎样通过计算后得到另外一个色彩值的呢？下面作图来说明一下，我们顶一个ColorMatrix的4*5的float型数组，然后定义一个我们自己MyColor，分别代表RGBA的值： 实际上，安卓系统计算色彩值是用矩阵相乘的方式得出的，如上图的样子。这里的MyColor的各项值都要转换到[0,1]之间的值，下面就是我们实际转换的计算方式和结果了。 通过上面的计算，我们得到了最终的RGBA的值是（0.5,0.25,0.2,1），说明RGB色彩值都发生了便宜，只有A未偏移，然后我们将这些值乘以255后还原一下看看，是不是跟上图的圈圈的色彩值是一致的呢，好吧，别看了，肯定必须一定是一样的。那么了解色彩矩阵有什么用呢？上面简单的更换一下色彩值而已，Paint类下也提供了setColor()方法，直接将色彩值设置上去，都TMD的方便，还搞什么玩意的矩阵，显得自己牛逼+蛋疼是不是？解释一下，上面的例子不过是个例子而已啊，真正开发的时候肯定是setColor比较简便嘛。问题来了，我们有可能处理的不是一个纯色彩的东西，而是一直图片呢？一张图片是有几十万中色彩值的，这时候setColor()就不可能让他们变色了吧，还是得用色彩矩阵来搞这玩意。下面我们从drawable目录下加载一张图片吧！ 1234567891011121314151617181920212223242526272829303132333435public class CustomView2 extends View &#123; private Context mContext; private Paint mPaint; private Bitmap mBitmap; private int x, y; public CustomView2(Context context) &#123; this(context, null); &#125; public CustomView2(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; initRes(); initPaint(); &#125; private void initRes() &#123; //获取图片 mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image); //获取图片显示起始位置 x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2; y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2; &#125; private void initPaint() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawBitmap(mBitmap, x, y, mPaint); &#125; &#125; 好了图片加载完毕，代码没有难度，上面的Paint没有做任何的处理，下面我们为Paint设置色彩过滤器吧！ 1234567ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]&#123; 0.33F, 0.59F, 0.11F, 0, 0, 0.33F, 0.59F, 0.11F, 0, 0, 0.33F, 0.59F, 0.11F, 0, 0, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(colorFilter); 好吧图片变成黑白的了，难道setColor()也可以办吗？再改一个试试： 1234567ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]&#123; 1.5F, 1.5F, 1.5F, 0, -1, 1.5F, 1.5F, 1.5F, 0, -1, 1.5F, 1.5F, 1.5F, 0, -1, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(colorFilter); 这样的效果是不是有点像负片效果啊！好了，反正我也不懂图像学，ColorMatrixColorFilter想设置什么样的就改改矩阵就行了，到底需要什么效果，效果的值要设置成多少，我也不知道，问问美工吧！我们只负责写程序！呵呵~~ LightingColorFilterLightingColorFilter顾名思义就是“光照色彩过滤器”，就是模拟一个光照照过图像所产生的效果，构造器是这样的：public LightingColorFilter(int mul, int add)查看一下Google文档，是这样介绍滴： 光照色彩滤光片，可以用来模拟简单的照明效果。一个lightingcolorfilter定义了两个参数，一个用于与源颜色相乘（称为colormultiply）和一个用于添加到源颜色（称为coloradd）。alpha通道是原封不动的彩色滤光片。给定一个源颜色的RGB，由此产生的特定颜色计算如下： 123R&apos; = R * colorMultiply.R + colorAdd.RG&apos; = G * colorMultiply.G + colorAdd.GB&apos; = B * colorMultiply.B + colorAdd.B 每个通道值的结果范围是0~255。上面的介绍写的比较明白， 算法也很简单，我们以上面的原图为例，看见蓝天了吗，我们现在去掉这个蓝色的天。根据这个短发描述呢，我们仅仅去掉蓝色，就要将蓝色的通道值改变，将B计算为其它值，这时候colorMultiply.B = 00，colorAdd.B =00，计算得到的B = 00，其它的通道R和G均不变，那么,colorAdd.R=0，colorAdd.G =0；colorMultiply.R = FF，colorMultiply.G =FF，Alpha通道A是忽略的，所以随便设置什么都不会有变化的。 12LightingColorFilter colorFilter = new LightingColorFilter(0xFFFFFF00, 0x00000000); mPaint.setColorFilter(colorFilter); 运行之后的结果，蓝天没了。 PorterDuffColorFilterColorFilter下还有最后一个子类，PorterDuff混合模式的色彩过滤器，下面是其构造器：public PorterDuffColorFilter(int color, PorterDuff.Mode mode) Google文档：PorterDuff滤光器可以用于点源像素使用一个单一的颜色和一个特定的波特达夫复合模式。 PorterDuffColorFilter的构造器也很简单，其中第一个参数表示一个16进制的色彩值，第二个参数是一个枚举值PorterDuff.Mode，表示图片混排的模式，PorterDuff.Mode在Android下一共有16种。下面我们先写一个小例子看一下，这里我们还是使用上面的图片，为原图添加图片混排模式，颜色值设置为红色0XFFFF0000，混排模式设置为PorterDuff.Mode.DARKEN。 12345678910111213141516171819202122232425262728293031323334353637public class CustomView2 extends View &#123; private Context mContext; private Paint mPaint; private Bitmap mBitmap; private int x, y; public CustomView2(Context context) &#123; this(context, null); &#125; public CustomView2(Context context, AttributeSet attrs) &#123; super(context, attrs); mContext = context; initRes(); initPaint(); &#125; private void initRes() &#123; //获取图片 mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image); //获取图片显示起始位置 x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2; y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2; &#125; private void initPaint() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(0XFFFF0000, PorterDuff.Mode.DARKEN); mPaint.setColorFilter(colorFilter); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas.drawBitmap(mBitmap, x, y, mPaint); &#125; &#125; 上面的图片就是运行之后的效果了，原图不仅变红了，而且还变暗了。其实我们这里将PorterDuffColorFilter的构造器参数拆开来分析一下，首先我们传递进去一个红色的颜色值0XFFFF0000，这里相当于创建了一张新的图层，图层的颜色就是0XFFFF0000，而我们的原图可以看作是第二张图层，我们先把这2个图片重叠放在一起，就会发现得到一个原图上很红的图片，然后我们看一下PorterDuff.Mode是DARKEN模式，表示在之前得到的“原图+很红”的图片上进一步将色调调成暗色，最终得到了如上所示的图片。 关于PorterDuff.Mode，Android系统一共提供了18种混排模式，在模拟器的ApiDemos/Graphics/XferModes，有张效果图： 这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。 PorterDuff.Mode也提供了18种混排模式算法，其中比上图多了ADD和OVERLAY两种模式： 其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[…,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面是在网上找到的汉字语言描述，感谢这位作者的总结。 注意：先绘制dst，再绘制src。 1.PorterDuff.Mode.CLEAR 所绘制源图像不会提交到画布上。 2.PorterDuff.Mode.SRC 只显示源图像。 3.PorterDuff.Mode.DST 只显示目标图像。 4.PorterDuff.Mode.SRC_OVER 正常绘制显示，源图像居上显示。 5.PorterDuff.Mode.DST_OVER 上下层都显示。目标图像居上显示。 6.PorterDuff.Mode.SRC_IN 取两层绘制交集中的源图像。 7.PorterDuff.Mode.DST_IN 取两层绘制交集中的目标图像。 8.PorterDuff.Mode.SRC_OUT 只在源图像和目标图像不相交的地方绘制源图像。 9.PorterDuff.Mode.DST_OUT 只在源图像和目标图像不相交的地方绘制目标图像。 10.PorterDuff.Mode.SRC_ATOP 在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。 11.PorterDuff.Mode.DST_ATOP 在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。 12.PorterDuff.Mode.XOR 异或：去除两图层交集部分 13.PorterDuff.Mode.DARKEN 取两图层全部区域，交集部分颜色加深 14.PorterDuff.Mode.LIGHTEN 取两图层全部，点亮交集部分颜色 15.PorterDuff.Mode.MULTIPLY 取两图层交集部分叠加后颜色 16.PorterDuff.Mode.SCREEN 滤色。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-ViewStub详细学习]]></title>
      <url>%2F2017%2F08%2F08%2Fandroid-viewstub%2F</url>
      <content type="text"><![CDATA[前言在开发应用程序的时候，经常会遇到这样的情况，会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为View.GONE，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见View.GONE但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。 ViewStub上面的问题，推荐的做法是使用 Android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了ViewStub.inflate()的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。但ViewStub也不是万能的，下面总结下ViewStub能做的事儿和什么时候该用ViewStub，什么时候该用可见性的控制。 特点 ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不能够再通过ViewStub来控制它了。 ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。 可以考虑使用ViewStub的情况 在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要在运行时不止一次的显示和隐藏某个布局，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。 想要控制显示与隐藏的是一个布局文件，而非某个View。因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。 下面来看一个实例在这个例子中，要显示二种不同的布局，一个是用TextView显示一段文字，另一个则是用ImageView显示一个图片。这二个是在onCreate()时决定是显示哪一个，这里就是应用ViewStub的最佳地点。 先来看看布局，一个是主布局，里面只定义二个ViewStub，一个用来控制TextView一个用来控制ImageView，另外就是一个是为显示文字的做的TextView布局，一个是为ImageView而做的布局： 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:gravity="center_horizontal"&gt; &lt;ViewStub android:id="@+id/viewstub_demo_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="5dip" android:layout_marginRight="5dip" android:layout_marginTop="10dip" android:layout="@layout/viewstub_demo_text_layout"/&gt; &lt;ViewStub android:id="@+id/viewstub_demo_image" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="5dip" android:layout_marginRight="5dip" android:layout="@layout/viewstub_demo_image_layout"/&gt; &lt;/LinearLayout&gt; 为TextView的布局： 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;TextView android:id="@+id/viewstub_demo_textview" android:layout_width="fill_parent" android:layout_height="wrap_content" android:background="#aa664411" android:textSize="16sp"/&gt; &lt;/LinearLayout&gt; 为ImageView的布局： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;ImageView android:id="@+id/viewstub_demo_imageview" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;/LinearLayout&gt; 下面来看代码，决定来显示哪一个，只需要找到相应的ViewStub然后调用其infalte()就可以获得相应想要的布局： 123456789101112131415161718192021222324public class ViewStubDemoActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.viewstub_demo_activity); if ((((int) (Math.random() * 100)) &amp; 0x01) == 0) &#123; // to show text // all you have to do is inflate the ViewStub for textview ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_text); stub.inflate(); TextView text = (TextView) findViewById(R.id.viewstub_demo_textview); text.setText("The tree of liberty must be refreshed from time to time" + " with the blood of patroits and tyrants! Freedom is nothing but " + "a chance to be better!"); &#125; else &#123; // to show image // all you have to do is inflate the ViewStub for imageview ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_image); stub.inflate(); ImageView image = (ImageView) findViewById(R.id.viewstub_demo_imageview); image.setImageResource(R.drawable.happy_running_dog); &#125; &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-DataBinding详细学习]]></title>
      <url>%2F2017%2F08%2F08%2Fandroid-databinding%2F</url>
      <content type="text"><![CDATA[前言谷歌开发了一个非常厉害的新框架DataBinding， 数据绑定框架给我们带来了很大的方便，以前我们可能需要在每个Activity里写很多的findViewById，不仅麻烦，还增加了代码的耦合性，如果我们使用DataBinding，就可以抛弃那么多的findViewById，省时省力。说到这里，其实网上也有很多快速的注解框架，但是注解框架与DataBinding想比还是不好用，而且官网文档说DataBinding还能提高解析XML的速度，其实DataBinding的好用，不仅仅体现在可以省去使用很多啰嗦findViewById，还有很多。往下看你就会明白的。 在介绍DataBinding之前，肯定要先学会搭建使用它的环境。在Android Studio上Databinding的使用还是很简单的。 环境搭建Android 的 Gradle 插件版本不低于 1.5.0-alpha1：classpath ‘com.android.tools.build:gradle:1.5.0’然后修改对应模块（Module）的 build.grade： 123456android &#123; .... dataBinding &#123; enabled = true &#125;&#125; 注意：Android stuido 的版本一定要大于1.3，而且Android Studio目前对binding对象没有自动代码提示，只会在编译时进行检查。就是这么简单，但是1.3及以前的版本，对于环境的搭建，可能就会麻烦一点（没事1.3的环境搭建方法，网上多得是）。 基础展示我们在具体的讲解之前，先用一个简单的小例子来学习一下基础并展现一下DataBinding的巨大魅力，估计你会被其简单的特性所吸引哦。首先我们先建立一个java bean，就是一个非常简单的用户类吧。 123456789101112131415161718192021222324package loonggg.net.databinding.bean;/** * Created by loongggdroid on 2016/3/14. */public class User &#123; private String name; private String age; public User(String name, String age) &#123; this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getName() &#123; return this.name; &#125; public String getAge() &#123; return this.age; &#125;&#125; 其次，来看看使用了DataBinding之后的布局文件是什么样子的呢？主要的变化是在layout布局文件之中。 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;variable name="user" type="loonggg.net.databinding.bean.User" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.name&#125;" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;user.age&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 看到这里，可能有的人就开始有点迷糊了，没有给控件定义id，而是用了@{ }的方法，到底是怎么回事？先不忙，一会再给你解释，我们再来看看怎么把值传进去的，在Activity中是如何使用的。 12345678910111213141516171819package loonggg.net.databinding;import android.app.Activity;import android.databinding.DataBindingUtil;import android.os.Bundle;import loonggg.net.databinding.bean.User;import loonggg.net.databinding.databinding.ActivityMainBinding;public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); User user = new User("loonggg", "23"); binding.setUser(user); &#125;&#125; 看到Activity是不是感觉很简洁，很清爽，没有了控件的初始化findViewById，然后再去setText(), 就仅仅只添加了两行代码。运行结果，不用说，显而易见，肯定会显示loonggg和23。 基础用法布局生命例子我们介绍完了，对于例子中出现的一些新东西，有必要解释一下，java bean那里就不解释了，大家肯定都懂，我们就从布局文件讲起。相比以前使用的xml，根节点由具体的某个layout（比如LinearLayout ）变成了layout，里面包括了data节点和传统的视图。这里的data节点就像是连接 View 和 Modle 的桥梁。在这个data节点中声明一个variable变量，那值就可以轻松传到布局文件中来了。 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;!--type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user--&gt; &lt;data&gt; &lt;variable name="user" type="loonggg.net.databinding.bean.User" /&gt; &lt;/data&gt; &lt;LinearLayout&gt; …… &lt;/LinearLayout&gt;&lt;/layout&gt; 变量名为user变量类型为”loonggg.net.databinding.bean.User “ type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user，TextView中的@{user.name}就是把这个user中的名字展示出来，age同样如此。 绑定Variable虽然在布局文件中对应上了，但是值是怎么传进去的呢？这就是我们要将的Activity中的那两行代码了，它把实体类和布局文件进行了绑定。修改MainActivity中的onCreate，用 DatabindingUtil.setContentView() 来替换掉 setContentView()，然后创建一个 user 对象，通过 binding.setUser(user) 与 variable 进行绑定。 1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); User user = new User("loonggg", "23"); binding.setUser(user);&#125; ActivityLayoutDetailBinding这个类是自动生成的和你的布局文件名字一样，如果你想要去改变名字的话 12345678910&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto"&gt; &lt;!--这里你也可以为Binding类进行命名，有三种形式 1、Custom:会在databinding包下 2、.Custom:会在当前的包名下创建 3、com.andly.Custom:会在指定的包名下进行创建--&gt; &lt;data class="CustomBinding"&gt;&lt;/data&gt; //在app_package/databinding下生成CustomBinding； &lt;data class=".CustomBinding"&gt;&lt;/data&gt; //在app_package下生成CustomBinding； &lt;data class="com.example.CustomBinding"&gt;&lt;/data&gt; // 明确指定包名和类名。 高级用法import用法其实data节点也是支持import用法的，比如： 1234&lt;data&gt; &lt;import type="loonggg.net.databinding.bean.User "/&gt; &lt;variablename="user"type="User" /&gt;&lt;/data&gt; 这里需要注意的是：import并不能像java 一样可以 import xx.xxx.*，必须具体到写清楚每个要导入的类名。 类名相同到这里你可能会问如果import了两个相同名称的类咋办？别怕，人家想的很周到，可以起个别名或者昵称嘛！例如： 123456789101112131415···&lt;data&gt; &lt;import type="xxx.User" alias="MyUser"&gt; &lt;import type="xxx.xx.User"&gt; &lt;variable name="user" type="User" /&gt; &lt;variable name="myUser" type="MyUser"/&gt; &lt;/data&gt; &lt;TextView xxx:@&#123;myUser.getName()&#125;&gt; &lt;TextView xxx:@&#123;user.getName()&#125;&gt;··· 变量定义的高级用法在上面，我们学会了如何去在xml中定义一些简单的变量。我们没有定义像List、Map等这样的集合变量。那这种集合变量该如何定义呢？其实定义的方式和我们上面的基本一致，区别就在于我们还需要为它定义key的变量，例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;data&gt; &lt;import type="android.graphics.Bitmap" /&gt; &lt;import type="java.util.ArrayList" /&gt; &lt;import type="java.util.HashMap" /&gt; &lt;!-- 集合的定义 --&gt; &lt;variable name="list" type="ArrayList&amp;lt;String&gt;" /&gt; // 左尖括号需要转义 &lt;variable name="map" type="HashMap&amp;lt;String, String&gt;" /&gt; &lt;variable name="array" type="String[]" /&gt; &lt;!-- 为集合定义对应的索引 --&gt; &lt;variable name="listKey" type="int" /&gt; &lt;variable name="mapKey" type="String" /&gt; &lt;variable name="arrayKey" type="int" /&gt; &lt;!-- 字符串，布尔值和int的用法--&gt; &lt;variable name="str" type="String"/&gt; &lt;variable name="error" type="boolean"/&gt; &lt;variable name="num" type="int" /&gt; &lt;/data&gt; &lt;LinearLayout android:orientation="vertical" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;list[listKey]&#125;"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;map[`name`]&#125;"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;array[0]&#125;"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;str&#125;"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;String.valueOf(num)&#125;"/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 在引用的同时也可以加上简单的逻辑运算 1234567891011121314&lt;!--数据绑定将自动检测null异常，如果你的表达式为null，它将会给它赋值为(null) 如果为int类型则默认为0--&gt; &lt;!--之前都是写三元运算符的形式，当然在数据绑定中也能够使用，但更推荐下面那种--&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@&#123;boo?note:null&#125;" /&gt; &lt;!--?? :null合并运算符，当左边为null会显示右边--&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@&#123;note??null&#125;" android:textColor="#00FF00" android:textSize="18sp" /&gt; 123456&lt;!--引用资源文件--&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:paddingLeft="@&#123;boo?@dimen/large_padding:@dimen/small_padding&#125;" android:src="@&#123;image&#125;" /&gt; 1234&lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text='@&#123;String.valueOf(map[`one`])&#125;'/&gt; Observable数据改变自动更新Observable是一个接口，它的子类有BaseObservable,ObservableField,ObservableBoolean,ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, and ObservableParcelable，ObservableArrayList,ObservableArrayMap现在我们来看看 如何在数据改变时，不手动设置，让其自动改变： 布局文件 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--布局以layout作为根布局--&gt;&lt;layout&gt; &lt;data&gt; &lt;import type="www.zhang.com.databinding.model.Person" /&gt; &lt;variable name="person" type="Person" /&gt; &lt;/data&gt; &lt;!--我们需要展示的布局--&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;`firstName:`+person.firstName&#125;" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;`lastName:`+person.lastName&#125;" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;`age:`+person.age&#125;" /&gt; &lt;Button android:id="@+id/second_btn1" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="改变数据" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Person类 1234567891011121314151617181920212223242526272829303132333435363738394041package www.zhang.com.databinding.model;import android.databinding.BaseObservable;import android.databinding.Bindable;import www.zhang.com.databinding.BR;public class Person extends BaseObservable &#123; private String firstName; private String lastName; private int age; public Person(String firstName, String lastName, int age) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; &#125; @Bindable public String getFirstName() &#123; return firstName; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; notifyPropertyChanged(BR.firstName); &#125; @Bindable public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; notifyPropertyChanged(BR.lastName); &#125; @Bindable public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; notifyPropertyChanged(BR.age); &#125;&#125; Model类继承BaseObservable,BaseObservable实现 Android.databinding.Observable接口，Observable接口可以允许附加一个监听器到model对象以便监听对象上的所有属性的变化。Observable接口有一个机制来添加和删除监听器，但通知与否由开发人员管理。为了使开发更容易，BaseObservable实现了监听器注册机制。DataBinding实现类依然负责通知当属性改变时。这是通过指定一个Bindable注解给getter以及setter内通知来完成的。notifyPropertyChanged(BR.参数名)通知更新这一个参数，需要与@Bindable注解配合使用。notifyChange()通知更新所有参数，可以不用和@Bindable注解配合使用 SecondActivity 1234567891011121314151617181920public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivitySecondBinding binding = DataBindingUtil.setContentView(SecondActivity.this, R.layout.activity_second); final Person person = new Person("zhang","san",38); binding.setPerson(person); binding.secondBtn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; person.setFirstName("li"); person.setLastName("si"); person.setAge(40); &#125; &#125;); &#125;&#125; 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--布局以layout作为根布局--&gt;&lt;layout&gt; &lt;data&gt; &lt;import type="www.zhang.com.databinding.model.Animal"/&gt; &lt;variable name="animal" type="Animal"/&gt; &lt;variable name="list" type="android.databinding.ObservableArrayList&amp;lt;String&amp;gt;"/&gt; &lt;variable name="map" type="android.databinding.ObservableArrayMap&amp;lt;String,String&amp;gt;"/&gt; &lt;/data&gt; &lt;!--我们需要展示的布局--&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;animal.field&#125;" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;String.valueOf(animal.age)&#125;" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;list[0]&#125;" /&gt; &lt;!--Map集合既可以通过map[key]的方式，也可以通过调用API--&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;list[1]&#125;" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;map[`name`]&#125;" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="56dp" android:text="@&#123;map[`age`]&#125;" /&gt; &lt;Button android:id="@+id/four_btn" android:layout_width="match_parent" android:text="改变数据" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Animal类 1234public class Animal &#123; public final ObservableField&lt;String&gt; field = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();&#125; FourActivity 12345678910111213141516171819202122232425262728293031323334353637package www.zhang.com.databinding;public class FourActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityFourBinding binding = DataBindingUtil.setContentView(FourActivity.this, R.layout.activity_four); final Animal animal = new Animal(); animal.field.set("cat"); animal.age.set(2); binding.setAnimal(animal); final ObservableArrayList&lt;String&gt; list = new ObservableArrayList&lt;&gt;(); list.add("dog"); list.add("mouse"); binding.setList(list); final ObservableArrayMap&lt;String, String&gt; map = new ObservableArrayMap&lt;&gt;(); map.put("name","Tom"); map.put("age","4"); binding.setMap(map); binding.fourBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; animal.field.set("dog"); animal.age.set(4); list.set(0,"cat"); list.set(1,"dog"); map.put("name","Sam"); map.put("age","5"); &#125; &#125;); &#125;&#125; 当Animal属性数据改变，list/map集合数据改变，会自动更新数据，我们不需要自己手动设置，省去了一个操作，让我们更专注于业务逻辑。 事件的绑定123456789&lt;!-- 绑定事件的格式有两种： 1、方法引用：直接用handle.Click或者handle::Click 推荐后者 --&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@&#123;user.name&#125;" android:onClick="@&#123;handle::Click&#125;"/&gt; 123456789101112131415161718192021222324252627282930313233&lt;!-- 2、监听绑定：使用()组，括号里面所填的是你为参数起的名字，这样你就可以在后面的括号进行引用 如果你监听的事件需要返回值，那么你的方法也要返回一个相同类型 --&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;()-&gt;handle.eventHandler(user)&#125;" android:text="传入布局文件中的数据" /&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;(thisView)-&gt;handle.eventHandlerView(thisView,user)&#125;" android:text="传入此View" /&gt; &lt;!--如果你需要为一个点击事件设置一个断言，那么使用void作为一个标志,表示什么也不做--&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;(v)-&gt;handle.isVisible(v)?handle.doSomething():void&#125;" android:text="判断是否为visible" /&gt; &lt;!--对于一些控件有自己专门的单击事件，需要创建下面的属性进行避免 SearchView android:onSearchClick ZoomControls android:onZoomIn ZoomControls android:onZoomOut--&gt; &lt;SearchView android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="@&#123;(v)-&gt;handle.searchClick(v)&#125;" android:onSearchClick="@&#123;(v)-&gt;handle.onSearchClick(v)&#125;"&gt; &lt;/SearchView&gt; 实现监听方法，保证参数个数、类型、返回值都要保证和你使用set时监听一样，不然就出报错。 12345678public void checkChanged(View view, boolean isCheck) &#123; System.out.println("checkChanged:" + view + " " + isCheck); &#125; public boolean longClick(View view) &#123; System.out.println("longClick:" + view); return true; &#125; 可以直接在 xml 导入android.view.View.OnClickListener，并制定其点击事件。 123456&lt;variable name="clickListener" type="android.view.View.OnClickListener" /&gt;... android:onClick="@&#123;clickListener&#125;"... 12345holder.binding.setClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //do something &#125;); 表达式其实在xml文件中还是支持表达式的，比如说如下： 1234&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text='@&#123;error ? "error" : "ok"&#125;'/&gt; 这是一个布尔值的使用。 下面我们就来看看表达式支持的一下语法和不支持的语法支持的表达式： Mathematical + - / * % String concatenation + Logical &amp;&amp; || Binary &amp; | ^ Unary + - ! ~ Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt; Comparison == &gt; &lt; &gt;= &lt;= instanceof Grouping () Literals - character, String, numeric, null Cast Method calls Field access Array access [] Ternary operator ?: 不支持的表达式： this super new Explicit generic invocation 在布局中使用include如果你需要用到从xml传过来的数据需要去使用bind:user属性，这里的user是你定义的实体类名 12345&lt;!--当你使用include的时候，你可以使用命名空间和属性中的变量名 来将数据传送到另一个布局中去,值得注意的是当include的父节点为merge时将不支持--&gt; &lt;include layout="@layout/detail_include" bind:user="@&#123;user&#125;" /&gt; 然后只需要在include布局里面声明之后便可以直接使用了。 示例activity_five.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--布局以layout作为根布局--&gt;&lt;layout&gt; &lt;data &gt; &lt;import type="www.zhang.com.databinding.model.Content"/&gt; &lt;variable name="con" type="Content"/&gt; &lt;/data&gt; &lt;!--我们需要展示的布局--&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;include android:id="@+id/toolbar" layout="@layout/toolbar" android:layout_height="56dp" android:layout_width="match_parent" bind:content="@&#123;con&#125;" /&gt; &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt; &lt;TextView android:text="@string/app_name" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; toolbar.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout &gt; &lt;data&gt; &lt;import type="www.zhang.com.databinding.model.Content"/&gt; &lt;variable name="content" type="Content"/&gt; &lt;/data&gt;&lt;android.support.v7.widget.Toolbar xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/toolbar" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_height="56dp" android:layout_width="match_parent" app:title="@&#123;content.title&#125;" app:subtitle="@&#123;content.subTitle&#125;" android:background="@color/colorPrimary" app:titleTextColor="@android:color/white" app:subtitleTextColor="@android:color/white" /&gt;&lt;/layout&gt; 在activity_five.xml中的include属性中定义了一个id,同时又在toolbar.xml中的Toolbar标签中又定义了一个id,其作用是通过binding.toolbar.toolbar等同于Toolbar控件，可以方便做一些操作等(不加id，同样能将变量参数传进去)FiveActivity中 1234567891011121314151617181920212223242526public class FiveActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); supportRequestWindowFeature(Window.FEATURE_NO_TITLE); ActivityFiveBinding binding =DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five); Content con = new Content("Title","SubTitle"); binding.setCon(con);// binding.toolbar.setContent(con); //这个测试没有效果，不会显示toolbar的title/subTitle// binding.toolbar.toolbar.setTitle(""); // binding.toolbar.toolbar.setSubtitle(""); //下面的代码也可以通过DataBinding绑定数据 binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher); setSupportActionBar(binding.toolbar.toolbar); binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); &#125;&#125; Content 123456789101112131415161718192021222324252627public class Content extends BaseObservable &#123; private String title; private String subTitle; public Content(String title, String subTitle) &#123; this.title = title; this.subTitle = subTitle; &#125; @Bindable public String getSubTitle() &#123; return subTitle; &#125; public void setSubTitle(String subTitle) &#123; this.subTitle = subTitle; notifyPropertyChanged(BR.subTitle); &#125; @Bindable public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; notifyPropertyChanged(BR.title); &#125;&#125; 带id的控件的赋值方式对于xml文件中控件的赋值，其实也是可以在java文件中，用java来实现的。我就以最上面那个简单的小例子来说，假如给一个TextView设置的id如下： 12345&lt;TextView android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 在Activity中这样赋值： 123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main); binding.name.setText("非著名程序员");&#125; 在布局中使用ViewStub12345678910111213141516171819/** * 为ViewStub设置监听，当显示的时候为它绑定数据，因为当不显示的ViewStub会在视图中消失 */ vs = (ViewStub) findViewById(R.id.viewstub); vs.setOnInflateListener(new ViewStub.OnInflateListener() &#123; @Override public void onInflate(ViewStub stub, View inflated) &#123; ViewstubBinding viewstubBinding = ViewstubBinding.bind(inflated); Info info = new Info(); info.setInfo("Andly Info"); viewstubBinding.setInfo(info); Drawable d = getResources().getDrawable(R.mipmap.ic_launcher); viewstubBinding.setDrawable(d); &#125; &#125;); public void toggleViewStub(View view) &#123; vs.inflate(); &#125; 在布局中使用RecycleView控件1、添加RecycleView控件12345678&lt;!-- 这里使用到了自定义属性，因为RecycleView里面有setAdapter方法，所以这里可以直接用app:adapter --&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv" android:layout_width="match_parent" android:layout_height="match_parent" app:adapter="@&#123;adapter&#125;" /&gt; 2、为RecycleView定义适配器12345678910111213141516171819202122232425@Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; ViewDataBinding viewDataBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), layoutId, parent, false); return new ViewHolder(viewDataBinding); &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.binding.setVariable(variable, list.get(position)); holder.binding.executePendingBindings(); //当然这里你也可以为其设置点击如： //holder.binding.getRoot.setOnclickListener() &#125; @Override public int getItemCount() &#123; return list.size(); &#125; class ViewHolder extends RecyclerView.ViewHolder &#123; ViewDataBinding binding; public ViewHolder(ViewDataBinding binding) &#123; super(binding.getRoot()); this.binding = binding; &#125; &#125; 3、为RecycleView设置Adapter1234//这里注意的是一定要是BR.dataInfo不能是其它的常数 MyAdapter adapter = new MyAdapter(list, R.layout.rv_item, BR.dataInfo); binding.setAdapter(adapter); binding.rv.setLayoutManager(new LinearLayoutManager(this)); 这样就大功告成，然而在很多情况我们都需要去对每个Item进行处理，如显示网络图片等等，这里我们就需要使用数据绑定自定义属性的功能，看代码 12345&lt;ImageView android:layout_width="150dp" android:layout_height="90dp" app:imageError="@&#123;@drawable/android&#125;" app:imagePath="@&#123;dataInfo.imageUrl&#125;" /&gt; 12345678910111213//当你在一个方法只需要一个参数的时候可以使用@BindingAdapter("imageUrlStr")，加上之后就可以在布局文件中直接使用imageUrlStr //运行之后就会调用loadImage方法 @BindingAdapter("imageUrlStr") public static void loadImage(ImageView iv, String url) &#123; Glide.with(iv.getContext()).load(url).into(iv);//这里使用Glide库 &#125; //上面是为loadImage传入一个参数，当传入两个或多个参数的时候应使用@BindingAdapter(&#123;"imagePath", "imageError"&#125;) //这个的ImageView自定义了两个属性一个是imagePath传入的是url,一个是imageError为Drawable @BindingAdapter(&#123;"imagePath", "imageError"&#125;) public static void downloadImage(ImageView iv, String url, Drawable error) &#123; Glide.with(iv.getContext()).load(url).error(error).into(iv); &#125; 上面的方法使用的是静态方法，如果你不想使用静态方法你需要重写一个数据绑定组件类去实现DataBindingComponent 12345678910public class MyComponent implements android.databinding.DataBindingComponent &#123; private Utils utils; @Override public Utils getUtils() &#123; if (utils == null) &#123; utils = new Utils(); &#125; return utils; &#125; &#125; 然后你需要在Activity为其进行设置 123456//第一种方式 DataBindingUtil.setDefaultComponent(new MyComponent()); //第二种方式 ActivityMyListViewBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_my_list_view,new MyComponent()); //第三种方式 DataBindingUtil.bind(root,new MyComponent()); 最后有个不起眼的小功能，就是当使用数据绑定的时候在预览界面不能看到显示的内容，这时你可以为你的控件设置默认显示内容android:text=&quot;@{placeName,default=PLACEHOLDER}&quot; 示例activity_five.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--布局以layout作为根布局--&gt;&lt;layout&gt; &lt;data &gt; &lt;import type="www.zhang.com.databinding.model.Content"/&gt; &lt;variable name="con" type="Content"/&gt; &lt;/data&gt; &lt;!--我们需要展示的布局--&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;include android:id="@+id/toolbar" layout="@layout/toolbar" android:layout_height="56dp" android:layout_width="match_parent" bind:content="@&#123;con&#125;" /&gt; &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; recycler_item.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout&gt; &lt;data&gt; &lt;variable name="str" type="String"/&gt; &lt;/data&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:orientation="vertical"&gt; &lt;TextView android:text="@&#123;str&#125;" android:gravity="center_vertical" android:textColor="@android:color/black" android:textSize="16sp" android:layout_width="match_parent" android:layout_height="48dp" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; FiveActivity 123456789101112131415161718192021222324252627282930313233343536373839404142public class FiveActivity extends AppCompatActivity &#123; private ActivityFiveBinding binding; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); supportRequestWindowFeature(Window.FEATURE_NO_TITLE); binding = DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five); initToolbar(); initRecyclerView(); &#125; private void initRecyclerView() &#123; LinearLayoutManager manager = new LinearLayoutManager(FiveActivity.this); binding.recycler.setLayoutManager(manager); binding.recycler.setHasFixedSize(true); MyAdapter adapter = new MyAdapter(getApplicationContext()); binding.recycler.setAdapter(adapter); &#125; private void initToolbar() &#123; Content con = new Content("Title","SubTitle"); binding.setCon(con);// binding.toolbar.setContent(con); //这个测试没有效果，不会显示toolbar的title/subTitle// binding.toolbar.toolbar.setTitle("");// binding.toolbar.toolbar.setSubtitle(""); //下面的代码也可以通过DataBinding绑定数据 binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher); setSupportActionBar(binding.toolbar.toolbar); binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); &#125;&#125; MyAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; &#123; private Context mContext; String[] datas; public MyAdapter(Context context) &#123; mContext = context; datas = context.getResources().getStringArray(R.array.item_list); &#125; @Override public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; RecyclerItemBinding binding = DataBindingUtil.inflate(LayoutInflater.from(mContext), R.layout.recycler_item, parent, false); return new MyViewHolder(binding); &#125; @Override public void onBindViewHolder(MyAdapter.MyViewHolder holder, int position) &#123; String name = datas[position]; holder.getBinding().setVariable(www.zhang.com.databinding.BR.str,name); //holder.getBinding().setStr(name); //两者都可以 //executePendingBindings()方法说明 // When a variable or observable changes, the binding will be scheduled to change before the next frame. // There are times, however, when binding must be executed immediately. // To force execution, use the executePendingBindings() method. holder.getBinding().executePendingBindings();//此方法必须执行在UI线程，当绑定的数据修改时更新视图（不知道翻译的准不准） &#125; @Override public int getItemCount() &#123; return datas.length; &#125; public class MyViewHolder extends RecyclerView.ViewHolder &#123; private RecyclerItemBinding binding; public MyViewHolder(ViewDataBinding binding) &#123; super(binding.getRoot()); this.binding = (RecyclerItemBinding) binding; &#125; public RecyclerItemBinding getBinding() &#123; return binding; &#125; public void setBinding(RecyclerItemBinding binding) &#123; this.binding = binding; &#125; &#125;&#125; @BindingAdapter@BindingAdapter用于修饰方法。一些属性需要定制绑定逻辑，一个用@BindingAdapter修饰的静态方法可以自定义属性的setter操作。android自身实现了大量的Adapter，你可以在项目module的android.databinding.adapters包下找到这些代码。 123456public class CardViewBindingAdapter &#123; @BindingAdapter("contentPadding") public static void setContentPadding(CardView view, int padding) &#123; view.setContentPadding(padding, padding, padding, padding); &#125;&#125; 方法内的参数可以设置多个，参数的传递在布局文件中使用自定义命名空间的属性传入。 1、默认的你的自定义的命名空间，在匹配时会被忽略。 1@BindingAdapter(&quot;contentPadding&quot;) 2、允许重写android的命名空间。 1@BindingAdapter(&quot;android:contentPadding&quot;) app:contentPadding与android:contentPadding处理行为可以不一样。app:contentPadding与custom:contentPadding处理行为是一致的。（仅android是特殊的命名空间）。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@BindingAdapter(&#123;"imageUrl", "type", "position", "debrisfly", "width", "height"&#125;)public static void setImageUrl(SimpleDraweeView view, String url, int type, int position, boolean debrisfly, int width, int height) &#123; if (url == null) &#123; url = ""; &#125; Uri uri = null; switch (type) &#123; case 1: uri = Util.parse7(url, BocaiApplication.getInstance()); break; case 2: uri = Util.parse2(url, BocaiApplication.getInstance()); break; case 3: uri = Util.parse3(url, BocaiApplication.getInstance()); break; case 8: uri = Util.parse(url, BocaiApplication.getInstance()); break; case 10: uri = Util.parseUrlBy230(url, BocaiApplication.getInstance()); break; &#125; ControllerListener controllerListener = new BaseControllerListener&lt;ImageInfo&gt;() &#123; @Override public void onFinalImageSet( String id, @Nullable ImageInfo imageInfo, @Nullable Animatable anim) &#123; if (imageInfo == null) &#123; return; &#125; if (anim != null) &#123; anim.start(); &#125; &#125; @Override public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) &#123; &#125; @Override public void onFailure(String id, Throwable throwable) &#123; &#125; &#125;; DraweeController controller = Fresco.newDraweeControllerBuilder() .setControllerListener(controllerListener) .setUri(uri) .setOldController(view.getController()) // other setters .build(); view.setController(controller); debrisflys(debrisfly, position,view,width,height);&#125; 需要注意，当你创建的适配器属性与系统默认的产生冲突时，你的自定义适配器将会覆盖掉系统原先定义的注解，这将会产生一些意外的问题。假设需要对下面接口，做适配。 1234public interface ILogAction&#123; void login(); void logout();&#125; 则需要一个方法一个接口，这么做的原因是避免login()的修改影响到logout()。所以根据业务需要，可能需要排列组合适配这两个接口。 1、适配 login2、适配 logout3、适配 login + logout @BindingBuildInfo123456789101112@BindingBuildInfo(buildId="3fefc6ba-1e95-4dcf-8ffa-278fe0f449bd",modulePackage="com.ipudong.library",sdkRoot="/Users/robert/Library/Android/sdk",layoutInfoDir="/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug",exportClassListTo="/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug/_generated.txt",isLibrary=true,minSdk=14,enableDebugLogs=false,printEncodedError=true)public class DataBindingInfo &#123;&#125; 在SOURCE阶段会自动生成DataBindingInfo.class，并标记注解如上。 @BindingConversion Annotate methods that are used to automatically convert from the expression type to the value used in the setter.有时候会遇到类型不匹配的问题，比如R.color.white是int，但是通过Data Binding赋值给android:background属性后，需要把int转换为ColorDrawable。 1234@BindingConversionpublic static Drawable convertColorToDrawable(int drawable) &#123; return new ColorDrawable(drawable);&#125; @BindingMethod &amp;&amp; @BindingMethods Used within an BindingMethods annotation to describe a renaming of an attribute to the setter used to set that attribute.Used to enumerate attribute-to-setter renaming. @BindingMethods用于修饰类。 一些属性虽然拥有setters但是并不与名字相匹配，这些方法的属性可以通过 @BindingMethod &amp;&amp; @BindingMethods 注释 setters。12345@BindingMethods(&#123; @BindingMethod(type = "android.widget.ImageView", attribute = "android:tint", method = "setImageTintList"),&#125;) 开发人员不太可能需要重命名 setters ，因为android框架属性已经实现了这一部分。事件的默认值是带有AttrChanged的属性名称。在上面的例子中，默认值是android:textAttrChanged，即使它没有提供。事件属性用于通知数据绑定系统值已更改。开发人员通常会创建一个BindingAdapter来分配事件。比如： 123456789101112131415161718192021222324@BindingAdapter(value = &#123;"android:beforeTextChanged", "android:onTextChanged", "android:afterTextChanged", "android:textAttrChanged"&#125;, requireAll = false) public static void setTextWatcher(TextView view, final BeforeTextChanged before, final OnTextChanged on, final AfterTextChanged after, final InverseBindingListener textAttrChanged) &#123; TextWatcher newValue = new TextWatcher() &#123; ... @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (on != null) &#123; on.onTextChanged(s, start, before, count); &#125; if (textAttrChanged != null) &#123; textAttrChanged.onChange(); &#125; &#125; &#125; TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher); if (oldValue != null) &#123; view.removeTextChangedListener(oldValue); &#125; view.addTextChangedListener(newValue); &#125; 如同BindingAdapters一样， InverseBindingAdapter方法 也可以将 DataBindingComponent作为第一个参数，可以是具有从DataBindingComponent检索的实例的实例方法。InverseBindingListener非常有用。 参考 InverseBindingListener @InverseBindingMethodInverseBindingMethod用于标识如何监听对View属性的更改以及要调用的getter方法。InverseBindingMethod 应该与InverseBindingMethods的部分方法相关联。 123456@InverseBindingMethods(&#123;@InverseBindingMethod( type = android.widget.TextView.class, attribute = "android:text", event = "android:textAttrChanged", method = "getText")&#125;) public class MyTextViewBindingAdapters &#123; ... &#125; @InverseBindingMethods中的属性method 是可选的。 如果其没有提供， 属性名称会查找如下几种可能性：方法名称，前缀为is或者get的方法名称。 如属性android:text, 数据绑定框架会在TextView中搜索public CharSequence getText() 方法。 @InverseBindingMethods中的属性event是可选的。 如果其没有提供，默认会使用属性名+AttrChanged后缀。如属性android:text, 默认的事件名称android:textAttrChanged。 这个事件也需要配置相关的@BindingAdapter，如下： 123456789101112131415161718192021222324@BindingAdapter(value = &#123;"android:beforeTextChanged", "android:onTextChanged", "android:afterTextChanged", "android:textAttrChanged"&#125;, requireAll = false) public static void setTextWatcher(TextView view, final BeforeTextChanged before, final OnTextChanged on, final AfterTextChanged after, final InverseBindingListener textAttrChanged) &#123; TextWatcher newValue = new TextWatcher() &#123; ... @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; if (on != null) &#123; on.onTextChanged(s, start, before, count); &#125; if (textAttrChanged != null) &#123; textAttrChanged.onChange(); &#125; &#125; &#125; TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher); if (oldValue != null) &#123; view.removeTextChangedListener(oldValue); &#125; view.addTextChangedListener(newValue); &#125; @InverseBindingMethods 用于枚举属性，getter和事件关联。 @UntaggableData Binding相关的jar包由四部分组成， baseLibrary-2.1.0-rc1.jar作为运行时类库被打进APK中； DataBinderPlugin（gradle plugin）在编译期使用，利用gradle-api（之前叫transform-api，1.5生，2.0改名）处理xml文件，生成DataBindingInfo.java； compiler-2.1.0-rc1.jar在编译器使用，入口类继承自AbstractProcessor，用于处理注解，并生成Binding类，DataBindingCompoent.java，DataBinderMapper.java类； compilerCommon-2.1.0-rc1.jar被DataBinderPlugin和compiler-2.1.0-rc1.jar所依赖 改变监听addOnPropertyChangedCallback： Model属性改变时回调发生OnRebindCallback: view发生改变重复绑定时触发 123456789101112mModel.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() &#123; @Override public void onPropertyChanged(Observable observable, int i) &#123; if (i == BR.name) &#123; Toast.makeText(TwoWayActivity.this, "name changed", Toast.LENGTH_SHORT).show(); &#125; else if (i == BR.password) &#123; Toast.makeText(TwoWayActivity.this, "password changed", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;); Component通过DataBindingUtil.setDefaultComponent来设置不同环境下不同的Component，设置之后就可以使用该Component提供的Adapter方法，默认不设置是全局使用，可以理解为作用域。 123456789101112public interface TestableAdapter &#123; @BindingAdapter("android:src") void setImageUrl(ImageView imageView, String url);&#125;public interface DataBindingComponent &#123; TestableAdapter getTestableAdapter();&#125;DataBindingUtil.setDefaultComponent(myComponent); ‐ or ‐binding = MyLayoutBinding.inflate(layoutInflater, myComponent); 相关编译流程STEP1 资源处理aapt或者gradle执行时，都会触发资源处理。在资源处理过程中，DataBinding都会扫描一遍现有的资源，生成不包含&lt;layout&gt;的data-binding-layout-out以及DataBinding所需要的data-binding-info； STEP2 DataBindingInfo.class生成在完成资源处理后，aapt或者gradle-api都会去执行DataBindingInfo.class生成操作，把相关的信息写入DataBindingInfo.class的@BindingBuildInfo注解中； STEP3 监听到注解变化生成@BindingBuildInfo注解，或者code中发现有新的注解写入，AbstractProcessor注解处理器就开始执行注解处理。DataBinding中有一个ProcessDataBinding.java类专门来处理DataBinding相关的注解； STEP4 ProcessDataBinding处理注解，生成binProcessDataBinding中处理注解永远会按顺执行3步，ProcessMethodAdapter，ProcessExpressions，ProcessBindable。每次执行都会从磁盘反序列化对应的bin文件，然后往bin中写入新的，完成后再序列化到磁盘； STEP5 生成最终产物执行ProcessMethodAdapter生成DataBindingComponents.class；执行ProcessExpressions生成ViewDataBinding.class子类（ActivityDetail2Binding.class），并触发DataBindingMapper.class更新；执行ProcessBindable生成BR.class，并触发DataBindingMapper.class更新。 注意：不允许使用混合类型 12345678910111213&lt;!--值得注意的是 android:background="@&#123;boo?@color/red:@drawable/background&#125;" 这么写将会发生错误，因为在BindingConversion默认实现为： @BindingConversion public static ColorDrawable convertColorToDrawable(int color) &#123; return new ColorDrawable(color); &#125; --&gt; &lt;ImageView android:layout_width="100dp" android:layout_height="100dp" android:layout_marginTop="20dp" android:background="@&#123;boo?@color/red:@color/green&#125;" /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-android:windowSoftInputMode属性详解]]></title>
      <url>%2F2017%2F08%2F05%2Fandroid-windowSoftInputMode%2F</url>
      <content type="text"><![CDATA[android:windowSoftInputModeactivity主窗口与软键盘的交互模式，可以用来避免输入法面板遮挡问题，Android1.5后的一个新特性。 这个属性能影响两件事情： 当有焦点产生时，软键盘是隐藏还是显示 是否减少活动主窗口大小以便腾出空间放软键盘 它的设置必须是下面列表中的一个值，或一个”state…”值加一个”adjust…”值的组合。在任一组设置多个值——多个”state…”values，例如＆mdash有未定义的结果。各个值之间用|分开。例如:&lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot;. . . &gt; 在这设置的值(除”stateUnspecified”和”adjustUnspecified”以外)将覆盖在主题中设置的值。各值的含义： stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置 stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示 stateHidden：用户选择activity时，软键盘总是被隐藏 stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的 stateVisible：软键盘通常是可见的 stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态 adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示 adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间 adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-getViewTreeObserver()]]></title>
      <url>%2F2017%2F08%2F05%2Fandroid-getViewTreeObserver%2F</url>
      <content type="text"><![CDATA[前言我们知道在oncreate中View.getWidth和View.getHeight无法获得一个view的高度和宽度，这是因为View组件布局要在onResume回调后完成。所以现在需要使用getViewTreeObserver().addOnGlobalLayoutListener()来获得宽度或者高度。这是获得一个view的宽度和高度的方法之一。 OnGlobalLayoutListenerOnGlobalLayoutListener 是ViewTreeObserver的内部类，当一个视图树的布局发生改变时，可以被ViewTreeObserver监听到，这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。ViewTreeObserver不能直接实例化，而是通过getViewTreeObserver()获得。 其他除了OnGlobalLayoutListener ，ViewTreeObserver还有如下内部类： interface ViewTreeObserver.OnGlobalFocusChangeListener当在一个视图树中的焦点状态发生改变时，所要调用的回调函数的接口类 interface ViewTreeObserver.OnGlobalLayoutListener当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类 interface ViewTreeObserver.OnPreDrawListener当一个视图树将要绘制时，所要调用的回调函数的接口类 interface ViewTreeObserver.OnScrollChangedListener当一个视图树中的一些组件发生滚动时，所要调用的回调函数的接口类 interface ViewTreeObserver.OnTouchModeChangeListener当一个视图树的触摸模式发生改变时，所要调用的回调函数的接口类 实例其中，我们可以利用OnGlobalLayoutListener来获得一个视图的真实高度。 123456789int mHeaderViewHeight; mHeaderView.getViewTreeObserver().addOnGlobalLayoutListener( new OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; m HeaderViewHeight = mHeaderView.getHeight(); getViewTreeObserver().removeGlobalOnLayoutListener(this); &#125; &#125;); 但是需要注意的是OnGlobalLayoutListener可能会被多次触发，因此在得到了高度之后，要将OnGlobalLayoutListener注销掉。另外mHeaderViewHeight和mHeaderView都需要写在当前java文件类（比如Activity）的成员变量中。不能直接在onCreate中定义否则会编译不通过： Cannot refer to a non-final variable sHeight inside an inner class defined in a different method 有时候需要在onCreate方法中知道某个View组件的宽度和高度等信息，而直接调用View组件的getWidth()、getHeight()、getMeasuredWidth()、getMeasuredHeight()、getTop()、getLeft()等方法是无法获取到真实值的，只会得到0。这是因为View组件布局要在onResume回调后完成。下面提供实现方法，onGlobalLayout回调会在view布局完成时自动调用: 123456789101112131415161718// This listener is used to get the final width of the GridView and then calculate the // number of columns and the width of each column. The width of each column is variable // as the GridView has stretchMode=columnWidth. The column width is used to set the height // of each view so we get nice square thumbnails. mGridView.getViewTreeObserver().addOnGlobalLayoutListener( //view 布局完成时调用，每次view改变时都会调用 new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; if (mAdapter.getNumColumns() == 0) &#123; final int numColumns = (int) Math.floor(mGridView.getWidth() / (mImageThumbSize + mImageThumbSpacing)); if (numColumns &gt; 0) &#123; final int columnWidth = (mGridView.getWidth() / numColumns) - mImageThumbSpacing; mAdapter.setNumColumns(numColumns); //设置 列数 mAdapter.setItemHeight(columnWidth); //设置 高度 &#125; &#125; &#125; &#125;); 在gridview布局完成后，根据girdview的宽和高设置adapter列数和每个item高度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Retrofit详细学习]]></title>
      <url>%2F2017%2F07%2F30%2Fandroid-retroift%2F</url>
      <content type="text"><![CDATA[Retrofit入门Retrofit 其实相当简单，简单到源码只有37个文件，其中22个文件是注解还都和HTTP有关，真正暴露给用户的类并不多。 创建Retrofit实例123Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") .build(); 创建Retrofit实例时需要通过Retrofit.Builder,并调用baseUrl方法设置URL。注： Retrofit2 的baseUlr 必须以 /（斜线） 结束，不然会抛出一个IllegalArgumentException。 接口定义以获取指定id的Blog为例: 1234public interface BlogService &#123; @GET("blog/&#123;id&#125;") Call&lt;ResponseBody&gt; getBlog(@Path("id") int id);&#125; 注意，这里是interface不是class，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个BlogService的代理对象。BlogService service = retrofit.create(BlogService.class);拿到代理对象之后，就可以调用该方法啦。 接口调用123456789101112131415161718Call&lt;ResponseBody&gt; call = service.getBlog(2);// 用法和OkHttp的call如出一辙,// 不同的是如果是Android系统回调方法执行在主线程call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; System.out.println(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; t.printStackTrace(); &#125;&#125;); 打印结果: {&quot;code&quot;:200,&quot;msg&quot;:&quot;OK&quot;,&quot;data&quot;:{&quot;id&quot;:2,&quot;date&quot;:&quot;2016-04-15 03:17:50&quot;,&quot;author&quot;:&quot;怪盗kidou&quot;,&quot;title&quot;:&quot;Retrofit2 测试2&quot;,&quot;content&quot;:&quot;这里是 Retrofit2 Demo 测试服务器2&quot;},&quot;count&quot;:0,&quot;page&quot;:0} Retrofit注解详解上面提到Retrofit 共22个注解，这节就专门介绍这22个注解，为帮助大家更好理解我将这22个注解分为三类，并用表格的形式展现出来,表格上说得并不完整，具体的见源码上的例子注释。 第一类：HTTP请求方法 以上表格中的除HTTP以外都对应了HTTP标准中的请求方法，而HTTP注解则可以代替以上方法中的任意一个注解,有3个属性：method、path、hasBody 1234567891011121314151617public interface BlogService &#123; /** * method 表示请求的方法，区分大小写 * path表示路径 * hasBody表示是否有请求体 */ @HTTP(method = "GET", path = "blog/&#123;id&#125;", hasBody = false) Call&lt;ResponseBody&gt; getBlog(@Path("id") int id);&#125;public static void main(String[] args)&#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") .build(); BlogService service = retrofit.create(BlogService.class); Call&lt;ResponseBody&gt; call = service.getBlog(2); ResponseBodyPrinter.printResponseBody(call);&#125; 第二类：标记类 Field、FieldMap、Part和PartMap 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap/Multipart/Part/PartMap注解]源码 */public class Example03 &#123; public interface BlogService &#123; /** * &#123;@link FormUrlEncoded&#125; 表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded） * &lt;code&gt;Field("username")&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值 */ @POST("/form") @FormUrlEncoded Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field("username") String name, @Field("age") int age); /** * Map的key作为表单的键 */ @POST("/form") @FormUrlEncoded Call&lt;ResponseBody&gt; testFormUrlEncoded2(@FieldMap Map&lt;String, Object&gt; map); /** * &#123;@link Part&#125; 后面支持三种类型，&#123;@link RequestBody&#125;、&#123;@link okhttp3.MultipartBody.Part&#125; 、任意类型 * 除 &#123;@link okhttp3.MultipartBody.Part&#125; 以外，其它类型都必须带上表单字段(&#123;@link okhttp3.MultipartBody.Part&#125; 中已经包含了表单字段的信息)， */ @POST("/form") @Multipart Call&lt;ResponseBody&gt; testFileUpload1(@Part("name") RequestBody name, @Part("age") RequestBody age, @Part MultipartBody.Part file); /** * PartMap 注解支持一个Map作为参数，支持 &#123;@link RequestBody &#125; 类型， * 如果有其它的类型，会被&#123;@link retrofit2.Converter&#125;转换，如后面会介绍的 使用&#123;@link com.google.gson.Gson&#125; 的 &#123;@link retrofit2.converter.gson.GsonRequestBodyConverter&#125; * 所以&#123;@link MultipartBody.Part&#125; 就不适用了,所以文件只能用&lt;b&gt; @Part MultipartBody.Part &lt;/b&gt; */ @POST("/form") @Multipart Call&lt;ResponseBody&gt; testFileUpload2(@PartMap Map&lt;String, RequestBody&gt; args, @Part MultipartBody.Part file); @POST("/form") @Multipart Call&lt;ResponseBody&gt; testFileUpload3(@PartMap Map&lt;String, RequestBody&gt; args); &#125; public static void main(String[] args) &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") .build(); BlogService service = retrofit.create(BlogService.class); // 演示 @FormUrlEncoded 和 @Field Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1("怪盗kidou", 24); ResponseBodyPrinter.printResponseBody(call1); //=================================================== // 演示 @FormUrlEncoded 和 @FieldMap // 实现的效果与上面想同 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("username", "怪盗kidou"); map.put("age", 24); Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map); ResponseBodyPrinter.printResponseBody(call2); //=================================================== MediaType textType = MediaType.parse("text/plain"); RequestBody name = RequestBody.create(textType, "怪盗kidou"); RequestBody age = RequestBody.create(textType, "24"); RequestBody file = RequestBody.create(MediaType.parse("application/octet-stream"), "这里是模拟文件的内容"); // 演示 @Multipart 和 @Part MultipartBody.Part filePart = MultipartBody.Part.createFormData("file", "test.txt", file); Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart); ResponseBodyPrinter.printResponseBody(call3); //=================================================== // 演示 @Multipart 和 @PartMap // 实现和上面同样的效果 Map&lt;String, RequestBody&gt; fileUpload2Args = new HashMap&lt;&gt;(); fileUpload2Args.put("name", name); fileUpload2Args.put("age", age); //这里并不会被当成文件，因为没有文件名(包含在Content-Disposition请求头中)，但上面的 filePart 有 //fileUpload2Args.put("file", file); Call&lt;ResponseBody&gt; call4 = service.testFileUpload2(fileUpload2Args, filePart); //单独处理文件 ResponseBodyPrinter.printResponseBody(call4); //=================================================== // 还有一种比较hack的方式可以实现文件上传， // 上面说过被当成文件上传的必要条件就是 Content-Disposition 请求头中必须要有 filename="xxx" 才会被当成文件 // 所有我们在写文件名的时候可以拼把 filename="XXX" 也拼接上去， // 即文件名变成 表单键名"; filename="文件名 （两端的引号会自动加，所以这里不加）也可以实现，但是不推荐方式 Map&lt;String, RequestBody&gt; fileUpload3Args = new HashMap&lt;&gt;(); fileUpload3Args.put("name",name); fileUpload3Args.put("age",age); fileUpload3Args.put("file\"; filename=\"test.txt",file); Call&lt;ResponseBody&gt; testFileUpload3 = service.testFileUpload3(fileUpload3Args); ResponseBodyPrinter.printResponseBody(testFileUpload3); &#125;&#125; 第三类：参数类 注1：{占位符}和PATH尽量只用在URL的path部分，url中的参数使用Query和QueryMap 代替，保证接口定义的简洁注2：Query、Field和Part这三者都支持数组和实现了Iterable接口的类型，如List，Set等，方便向后台传递数组。 12Call&lt;ResponseBody&gt; foo(@Query("ids[]") List&lt;Integer&gt; ids);//结果：ids[]=0&amp;ids[]=1&amp;ids[]=2 Header和Headers例子 1234567891011121314151617181920212223/** * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap注解]源码 */public class Example04 &#123; public interface BlogService &#123; @GET("/headers?showAll=true") @Headers(&#123;"CustomHeader1: customHeaderValue1", "CustomHeader2: customHeaderValue2"&#125;) Call&lt;ResponseBody&gt; testHeader(@Header("CustomHeader3") String customHeaderValue3); &#125; public static void main(String[] args) &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") .build(); BlogService service = retrofit.create(BlogService.class); //演示 @Headers 和 @Header Call&lt;ResponseBody&gt; call1 = service.testHeader("ikidou"); ResponseBodyPrinter.printResponseBody(call1); &#125;&#125; Query、QueryMap、Url 示例 1234567891011121314151617181920212223242526272829/** * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap注解]源码 */public class Example05 &#123; public interface BlogService &#123; /** * 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 &#123;@link Url&#125;提供 * 对于Query和QueryMap，如果不是String（或Map的第二个泛型参数不是String）时 * 会被默认会调用toString转换成String类型 * Url支持的类型有 okhttp3.HttpUrl, String, java.net.URI, android.net.Uri * &#123;@link retrofit2.http.QueryMap&#125; 用法和&#123;@link retrofit2.http.FieldMap&#125; 用法一样，不再说明 */ @GET //当有URL注解时，这里的URL就省略了 Call&lt;ResponseBody&gt; testUrlAndQuery(@Url String url, @Query("showAll") boolean showAll); &#125; public static void main(String[] args) &#123; Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") .build(); BlogService service = retrofit.create(BlogService.class); //演示 @Headers 和 @Header Call&lt;ResponseBody&gt; call1 = service.testUrlAndQuery("headers",false); ResponseBodyPrinter.printResponseBody(call1); &#125;&#125; Gson与Converter在默认情况下Retrofit只支持将HTTP的响应体转换换为ResponseBody,这也是什么我在前面的例子接口的返回值都是 Call&lt;ResponseBody&gt;，但如果响应体只是支持转换为ResponseBody的话何必要引用泛型呢，返回值直接用一个Call就行了嘛，既然支持泛型，那说明泛型参数可以是其它类型的，而Converter就是Retrofit为我们提供用于将ResponseBody转换为我们想要的类型，有了Converter之后我们就可以写把我们的第一个例子的接口写成这个样子了： 1234public interface BlogService &#123; @GET("blog/&#123;id&#125;") Call&lt;Result&lt;Blog&gt;&gt; getBlog(@Path("id") int id);&#125; 当然只改变泛型的类型是不行的，我们在创建Retrofit时需要明确告知用于将ResponseBody转换我们泛型中的类型时需要使用的Converter引入Gson支持:compile &#39;com.squareup.retrofit2:converter-gson:2.0.2&#39; 通过GsonConverterFactory为Retrofit添加Gson支持： 12345678910Gson gson = new GsonBuilder() //配置你的Gson .setDateFormat("yyyy-MM-dd hh:mm:ss") .create();Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") //可以接收自定义的Gson，当然也可以不传 .addConverterFactory(GsonConverterFactory.create(gson)) .build(); 这样Retrofit就会使用Gson将ResponseBody转换我们想要的类型。这是时候我们终于可以演示如使创建一个Blog了！ 12@POST("blog")Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog); 被@Body注解的的Blog将会被Gson转换成RequestBody发送到服务器。 123456BlogService service = retrofit.create(BlogService.class);Blog blog = new Blog();blog.content = "新建的Blog";blog.title = "测试";blog.author = "怪盗kidou";Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog); 结果： Result{code=200, msg=&#39;OK&#39;, data=Blog{id=20, date=&#39;2016-04-21 05:29:58&#39;, author=&#39;怪盗kidou&#39;, title=&#39;测试&#39;, content=&#39;新建的Blog&#39;}, count=0, page=0} RxJava与CallAdapter说到Retrofit就不得说到另一个火到不行的库RxJava，网上已经不少文章讲如何与Retrofit结合，但这里还是会有一个RxJava的例子，不过这里主要目的是介绍使用CallAdapter所带来的效果。 第3节介绍的Converter是对于Call&lt;T&gt;中T的转换，而CallAdapter则可以对Call转换，这样的话Call&lt;T&gt;中的Call也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个CallAdapter，这里以RxJava的为例，用Observable代替Call： 引入RxJava支持: 123compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'// 针对rxjava2.x（adapter-rxjava2的版本要 &gt;= 2.2.0）compile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0' 通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持： 1234567Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 针对rxjava2.x .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); 接口设计： 1234public interface BlogService &#123; @POST("/blog") Observable&lt;Result&lt;List&lt;Blog&gt;&gt;&gt; getBlogs();&#125; 使用： 12345678910111213141516171819BlogService service = retrofit.create(BlogService.class);service.getBlogs(1) .subscribeOn(Schedulers.io()) .subscribe(new Subscriber&lt;Result&lt;List&lt;Blog&gt;&gt;&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("onCompleted"); &#125; @Override public void onError(Throwable e) &#123; System.err.println("onError"); &#125; @Override public void onNext(Result&lt;List&lt;Blog&gt;&gt; blogsResult) &#123; System.out.println(blogsResult); &#125; &#125;); 结果： Result{code=200, msg=&#39;OK&#39;, data=[Blog{id=1, date=&#39;2016-04-15 03:17:50&#39;, author=&#39;怪盗kidou&#39;, title=&#39;Retrofit2 测试1&#39;, content=&#39;这里是 Retrofit2 Demo 测试服务器1&#39;},.....], count=20, page=1} 像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案： 用Observable&lt;Response&lt;T&gt;&gt; 代替 Observable&lt;T&gt; ,这里的Response指retrofit2.Response 用Observable&lt;Result&lt;T&gt;&gt; 代替 Observable&lt;T&gt;，这里的Result是指retrofit2.adapter.rxjava.Result,这个Result中包含了Response的实例。 自定义Converter本节的内容是教大家实现在一简易的Converter，这里以返回格式为Call&lt;String&gt;为例。在此之前先了解一下Converter接口及其作用： 1234567891011121314151617181920212223242526272829public interface Converter&lt;F, T&gt; &#123; // 实现从 F(rom) 到 T(o)的转换 T convert(F value) throws IOException; // 用于向Retrofit提供相应Converter的工厂 abstract class Factory &#123; // 这里创建从ResponseBody其它类型的Converter，如果不能处理返回null // 主要用于对响应体的处理 public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; // 在这里创建 从自定类型到ResponseBody 的Converter,不能处理就返回null， // 主要用于对Part、PartMap、Body注解的处理 public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; return null; &#125; // 这里用于对Field、FieldMap、Header、Path、Query、QueryMap注解的处理 // Retrfofit对于上面的几个注解默认使用的是调用toString方法 public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; &#125;&#125; 我们要想从Call&lt;ResponseBody&gt; 转换为 Call&lt;String&gt; 那么对应的F和T则分别对应ResponseBody和String，我们定义一个StringConverter并实现Converter接口。 123456789public static class StringConverter implements Converter&lt;ResponseBody, String&gt; &#123; public static final StringConverter INSTANCE = new StringConverter(); @Override public String convert(ResponseBody value) throws IOException &#123; return value.string(); &#125;&#125; 我们需要一个Fractory来向Retrofit注册StringConverter 123456789101112131415161718public static class StringConverterFactory extends Converter.Factory &#123; public static final StringConverterFactory INSTANCE = new StringConverterFactory(); public static StringConverterFactory create() &#123; return INSTANCE; &#125; // 我们只关实现从ResponseBody 到 String 的转换，所以其它方法可不覆盖 @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; if (type == String.class) &#123; return StringConverter.INSTANCE; &#125; //其它类型我们不处理，返回null就行 return null; &#125;&#125; 使用Retrofit.Builder.addConverterFactory向Retrofit注册我们StringConverterFactory： 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") // 如是有Gson这类的Converter 一定要放在其它前面 .addConverterFactory(StringConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); 注：addConverterFactory是有先后顺序的，如果有多个ConverterFactory都支持同一种类型，那么就是只有第一个才会被使用，而GsonConverterFactory是不判断是否支持的，所以这里交换了顺序还会有一个异常抛出，原因是类型不匹配。 只要返回值类型的泛型参数就会由我们的StringConverter处理,不管是Call&lt;String&gt;还是Observable&lt;String&gt;有没有很简单?如果你有其它的需求处理的就自己实现吧。 自定义CallAdapter本节将介绍如何自定一个CallAdapter，并验证是否所有的String都会使用我们第5节中自定义的Converter。 先看一下CallAdapter接口定义及各方法的作用： 1234567891011121314151617181920212223242526272829public interface CallAdapter&lt;T&gt; &#123; // 直正数据的类型 如Call&lt;T&gt; 中的 T // 这个 T 会作为Converter.Factory.responseBodyConverter 的第一个参数 // 可以参照上面的自定义Converter Type responseType(); &lt;R&gt; T adapt(Call&lt;R&gt; call); // 用于向Retrofit提供CallAdapter的工厂类 abstract class Factory &#123; // 在这个方法中判断是否是我们支持的类型，returnType 即Call&lt;Requestbody&gt;和`Observable&lt;Requestbody&gt;` // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型 // 不支持时返回null public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit); // 用于获取泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123; return Utils.getParameterUpperBound(index, type); &#125; // 用于获取泛型的原始类型 如 Call&lt;Requestbody&gt; 中的 Call // 上面的get方法需要使用该方法。 protected static Class&lt;?&gt; getRawType(Type type) &#123; return Utils.getRawType(type); &#125; &#125;&#125; 了解了CallAdapter的结构和其作用之后，我们就可以开始自定义我们的CallAdapter了，本节以CustomCall&lt;String&gt;为例。在此我们需要定义一个CustomCall，不过这里的CustomCall作为演示只是对Call的一个包装，并没有实际的用途。 123456789101112public static class CustomCall&lt;R&gt; &#123; public final Call&lt;R&gt; call; public CustomCall(Call&lt;R&gt; call) &#123; this.call = call; &#125; public R get() throws IOException &#123; return call.execute().body(); &#125;&#125; 有了CustomCall，我们还需要一个CustomCallAdapter来实现 Call&lt;T&gt; 到 CustomCall&lt;T&gt;的转换，这里需要注意的是最后的泛型，是我们要返回的类型。 1234567891011121314151617181920public static class CustomCallAdapter implements CallAdapter&lt;CustomCall&lt;?&gt;&gt; &#123; private final Type responseType; // 下面的 responseType 方法需要数据的类型 CustomCallAdapter(Type responseType) &#123; this.responseType = responseType; &#125; @Override public Type responseType() &#123; return responseType; &#125; @Override public &lt;R&gt; CustomCall&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; // 由 CustomCall 决定如何使用 return new CustomCall&lt;&gt;(call); &#125;&#125; 提供一个CustomCallAdapterFactory用于向Retrofit提供CustomCallAdapter： 123456789101112131415public static class CustomCallAdapterFactory extends CallAdapter.Factory &#123; public static final CustomCallAdapterFactory INSTANCE = new CustomCallAdapterFactory(); @Override public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; // 获取原始类型 Class&lt;?&gt; rawType = getRawType(returnType); // 返回值必须是CustomCall并且带有泛型 if (rawType == CustomCall.class &amp;&amp; returnType instanceof ParameterizedType) &#123; Type callReturnType = getParameterUpperBound(0, (ParameterizedType) returnType); return new CustomCallAdapter(callReturnType); &#125; return null; &#125;&#125; 使用addCallAdapterFactory向Retrofit注册CustomCallAdapterFactory。 123456Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://localhost:4567/") .addConverterFactory(Example09.StringConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(CustomCallAdapterFactory.INSTANCE) .build(); 注： addCallAdapterFactory与addConverterFactory同理，也有先后顺序。 其它说明Retrofit.Builder前面用到了 Retrofit.Builder 中的baseUrl、addCallAdapterFactory、addConverterFactory、build方法，还有callbackExecutor、callFactory、client、validateEagerly这四个方法没有用到，这里简单的介绍一下。 方法 用途 callbackExecutor(Executor) 指定Call.enqueue时使用的Executor，所以该设置只对返回值为Call的方法有效 callFactory(Factory) 设置一个自定义的okhttp3.Call.Factory，那什么是Factory呢?OkHttpClient就实现了okhttp3.Call.Factory接口，下面的client(OkHttpClient)最终也是调用了该方法，也就是说两者不能共用 client(OkHttpClient) 设置自定义的OkHttpClient,以前的Retrofit版本中不同的Retrofit对象共用同OkHttpClient,在2.0各对象各自持有不同的OkHttpClient实例，所以当你需要共用OkHttpClient或需要自定义时则可以使用该方法，如：处理Cookie、使用 stetho 调式等 validateEagerly(boolean) 是否在调用create(Class)时检测接口定义是否正确，而不是在调用方法才检测，适合在开发、测试时使用 Retrofit的Url组合规则 BaseUrl 和URL有关的注解中提供的值 最后结果 http://localhost:4567/path/to/other/ /post http://localhost:4567/post http://localhost:4567/path/to/other/ post http://localhost:4567/path/to/other/post http://localhost:4567/path/to/other/ https://github.com/ikidou https://github.com/ikidou 从上面不能难看出以下规则： 如果你在注解中提供的url是完整的url，则url将作为请求的url。 如果你在注解中提供的url是不完整的url，且不以 / 开头，则请求的url为baseUrl+注解中提供的值 如果你在注解中提供的url是不完整的url，且以 / 开头，则请求的url为baseUrl的主机部分+注解中提供的值 Retrofit提供的Converter Converter Gradle依赖 Gson com.squareup.retrofit2:converter-gson:2.0.2 Jackson com.squareup.retrofit2:converter-jackson:2.0.2 Moshi com.squareup.retrofit2:converter-moshi:2.0.2 Protobuf com.squareup.retrofit2:converter-protobuf:2.0.2 Wire com.squareup.retrofit2:converter-wire:2.0.2 Simple XML com.squareup.retrofit2:converter-simplexml:2.0.2 Scalars com.squareup.retrofit2:converter-scalars:2.0.2 Retrofit提供的CallAdapter： CallAdapter Gradle依赖 guava com.squareup.retrofit2:adapter-guava:2.0.2 Java8 com.squareup.retrofit2:adapter-java8:2.0.2 rxjava com.squareup.retrofit2:adapter-rxjava:2.0.2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Gson详细学习]]></title>
      <url>%2F2017%2F07%2F27%2Fandroid-gson%2F</url>
      <content type="text"><![CDATA[前言最近在项目中发现网络请求回来的Json数据都用Gson进行解析，以前没有对其进行一个系统的了解，所以这里做一个知识点的归纳整理。 Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。而JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。 基本概念 Serialization:序列化，使Java对象到Json字符串的过程。 Deserialization：反序列化，字符串转换成Java对象。 JSON数据中的JsonElement有下面这四种类型： JsonPrimitive —— 例如一个字符串或整型JsonObject—— 一个以 JsonElement 名字（类型为 String）作为索引的集合。也就是说可以把 JsonObject 看作值为 JsonElement 的键值对集合。JsonArray—— JsonElement 的集合。注意数组的元素可以是四种类型中的任意一种，或者混合类型都支持。JsonNull—— 值为null Gson解决的问题 提供一种像toString()和构造方法的很简单的机制，来实现Java 对象和Json之间的互相转换。 允许已经存在的无法改变的对象，转换成Json，或者Json转换成已存在的对象。 允许自定义对象的表现形式 支持任意的复杂对象 能够生成可压缩和可读的Json的字符串输出。 Gson处理对象的几个重要点 推荐把成员变量都声明称private的 没有必要用注解（@Expose 注解）指明某个字段是否会被序列化或者反序列化，所有包含在当前类（包括父类）中的字段都应该默认被序列化或者反序列化 如果某个字段被 transient 这个Java关键词修饰，就不会被序列化或者反序列化 下面的实现方式能够正确的处理null 当序列化的时候，如果对象的某个字段为null，是不会输出到Json字符串中的。 当反序列化的时候，某个字段在Json字符串中找不到对应的值，就会被赋值为null 如果一个字段是 synthetic的,他会被忽视，也即是不应该被序列化或者反序列化 内部类（或者anonymous class（匿名类），或者local class(局部类，可以理解为在方法内部声明的类)）的某个字段和外部类的某个字段一样的话，就会被忽视，不会被序列化或者反序列化 Gson的基本用法Gson提供了fromJson() 和toJson()两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。 基本数据类型的解析 12345Gson gson = new Gson();int i = gson.fromJson("100", int.class); //100double d = gson.fromJson("\"99.99\"", double.class); //99.99boolean b = gson.fromJson("true", boolean.class); // trueString str = gson.fromJson("String", String.class); // String 注：不知道你是否注意到了第2、3行有什么不一样没 基本数据类型的生成 1234Gson gson = new Gson();String jsonNumber = gson.toJson(100); // 100String jsonBoolean = gson.toJson(false); // falseString jsonString = gson.toJson("String"); //"String" POJO类的生成与解析 123456public class User &#123; //省略其它 public String name; public int age; public String emailAddress;&#125; 生成JSON： 123Gson gson = new Gson();User user = new User("怪盗kidou",24);String jsonObject = gson.toJson(user); // &#123;"name":"怪盗kidou","age":24&#125; 解析JSON： 123Gson gson = new Gson();String jsonString = "&#123;\"name\":\"怪盗kidou\",\"age\":24&#125;";User user = gson.fromJson(jsonString, User.class); Gson中使用泛型上面了解的JSON中的Number、boolean、Object和String，现在说一下Array。例：JSON字符串数组 1["Android","Java","PHP"] 当我们要通过Gson解析这个json时，一般有两种方式：使用数组，使用List。而List对于增删都是比较方便的，所以实际使用是还是List比较多。 数组比较简单 123Gson gson = new Gson();String jsonArray = "[\"Android\",\"Java\",\"PHP\"]";String[] strings = gson.fromJson(jsonArray, String[].class); 但对于List将上面的代码中的 String[].class 直接改为 List&lt;String&gt;.class 是行不通的。对于Java来说List&lt;String&gt; 和List&lt;User&gt; 这俩个的字节码文件只一个那就是List.class，这是Java泛型使用时要注意的问题 泛型擦除。为了解决的上面的问题，Gson为我们提供了TypeToken来实现对泛型的支持，所以当我们希望使用将以上的数据解析List&lt;String&gt;时需要这样写。 1234Gson gson = new Gson();String jsonArray = "[\"Android\",\"Java\",\"PHP\"]";String[] strings = gson.fromJson(jsonArray, String[].class);List&lt;String&gt; stringList = gson.fromJson(jsonArray, new TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType()); 注：TypeToken的构造方法是protected修饰的,所以上面才会写成new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType() 而不是 new TypeToken&lt;List&lt;String&gt;&gt;().getType()泛型解析对接口POJO的设计影响泛型的引入可以减少无关的代码，如我现在所在公司接口返回的数据分为两类： 1&#123;"code":"0","message":"success","data":&#123;&#125;&#125; 1&#123;"code":"0","message":"success","data":[]&#125; 我们真正需要的data所包含的数据，而code只使用一次，message则几乎不用。如果Gson不支持泛型或不知道Gson支持泛型的同学一定会这么定义POJO。 12345public class UserResponse &#123; public int code; public String message; public User data;&#125; 当其它接口的时候又重新定义一个XXResponse将data的类型改成XX，很明显code，和message被重复定义了多次，通过泛型的话我们可以将code和message字段抽取到一个Result的类中，这样我们只需要编写data字段所对应的POJO即可，更专注于我们的业务逻辑。如： 12345public class Result&lt;T&gt; &#123; public int code; public String message; public T data;&#125; 那么对于data字段是User时则可以写为 Result&lt;User&gt; ,当是个列表的时候为 Result&lt;List&lt;User&gt;&gt;，其它同理。 手动方式手动的方式就是使用stream包下的JsonReader类来手动实现反序列化，和Android中使用pull解析XML是比较类似的。 12345678910111213141516171819202122String json = "&#123;\"name\":\"怪盗kidou\",\"age\":\"24\"&#125;";User user = new User();JsonReader reader = new JsonReader(new StringReader(json));reader.beginObject(); // throws IOExceptionwhile (reader.hasNext()) &#123; String s = reader.nextName(); switch (s) &#123; case "name": user.name = reader.nextString(); break; case "age": user.age = reader.nextInt(); //自动转换 break; case "email": user.email = reader.nextString(); break; &#125;&#125;reader.endObject(); // throws IOExceptionSystem.out.println(user.name); // 怪盗kidouSystem.out.println(user.age); // 24System.out.println(user.email); // ikidou@example.com 其实自动方式最终都是通过JsonReader来实现的，如果第一个参数是String类型，那么Gson会创建一个StringReader转换成流操作。 Gson的流式序列化自动方式 所以啊，学会利用IDE的自动完成是多么重要这下知道了吧！可以看出用红框选中的部分就是我们要找的东西。提示：PrintStream(System.out) 、StringBuilder、StringBuffer和*Writer都实现了Appendable接口。 123Gson gson = new Gson();User user = new User("怪盗kidou",24,"ikidou@example.com");gson.toJson(user,System.out); // 写到控制台 手动方式12345678JsonWriter writer = new JsonWriter(new OutputStreamWriter(System.out));writer.beginObject() // throws IOException .name("name").value("怪盗kidou") .name("age").value(24) .name("email").nullValue() //演示null .endObject(); // throws IOExceptionwriter.flush(); // throws IOException//&#123;"name":"怪盗kidou","age":24,"email":null&#125; 提示：除了beginObject、endObject还有beginArray和endArray，两者可以相互嵌套，注意配对即可。beginArray后不可以调用name方法，同样beginObject后在调用value之前必须要调用name方法。 使用GsonBuilder导出null值、格式化输出、日期时间一般情况下Gson类提供的 API已经能满足大部分的使用场景，但我们需要更多更特殊、更强大的功能时，这时候就引入一个新的类 GsonBuilder。GsonBuilder从名上也能知道是用于构建Gson实例的一个类，要想改变Gson默认的设置必须使用该类配置Gson。 GsonBuilder用法123Gson gson = new GsonBuilder() //各种配置 .create(); //生成配置好的Gson Gson在默认情况下是不动导出值null的键的，如： 123456public class User &#123; //省略其它 public String name; public int age; public String email;&#125; 123Gson gson = new Gson();User user = new User("怪盗kidou",24);System.out.println(gson.toJson(user)); //&#123;"name":"怪盗kidou","age":24&#125; 可以看出，email字段是没有在json中出现的，当我们在调试是、需要导出完整的json串时或API接中要求没有值必须用Null时，就会比较有用。 使用方法： 12345Gson gson = new GsonBuilder() .serializeNulls() .create();User user = new User("怪盗kidou", 24);System.out.println(gson.toJson(user)); //&#123;"name":"怪盗kidou","age":24,"email":null&#125; 格式化输出、日期时间及其它：这些都比较简单就不一一分开写了。 123456789101112131415Gson gson = new GsonBuilder() //序列化null .serializeNulls() // 设置日期时间格式，另有2个重载方法 // 在序列化和反序化时均生效 .setDateFormat("yyyy-MM-dd") // 禁此序列化内部类 .disableInnerClassSerialization() //生成不可执行的Json（多了 )]&#125;' 这4个字符） .generateNonExecutableJson() //禁止转义html标签 .disableHtmlEscaping() //格式化输出 .setPrettyPrinting() .create(); 注意：内部类(Inner Class)和嵌套类(Nested Class)的区别 Gson中的一些注解@SerializedName注解该注解能指定该字段在JSON中对应的字段名称 12345678910111213public class Box &#123; @SerializedName("w") private int width; @SerializedName("h") private int height; @SerializedName("d") private int depth; // Methods removed for brevity&#125; 也就是说{&quot;w&quot;:10,&quot;h&quot;:20,&quot;d&quot;:30} 这个JSON 字符串能够被解析到上面的width，height和depth字段中。 @Expose注解该注解能够指定该字段是否能够序列化或者反序列化，默认的是都支持（true）。简单说来就是需要导出的字段上加上@Expose 注解，不导出的字段不加。注意是不导出的不加。 12345678910111213141516public class Account &#123; @Expose(deserialize = false) private String accountNumber; @Expose private String iban; @Expose(serialize = false) private String owner; @Expose(serialize = false, deserialize = false) private String address; private String pin;&#125; 该注解在使用new Gson() 时是不会发生作用。毕竟最常用的API要最简单，所以该注解必须和GsonBuilder配合使用。需要注意的通过 builder.excludeFieldsWithoutExposeAnnotation()方法使该注解生效。 123final GsonBuilder builder = new GsonBuilder();builder.excludeFieldsWithoutExposeAnnotation();final Gson gson = builder.create(); @Since和@Until注解Since代表“自从”，Until 代表”一直到”。它们都是针对该字段生效的版本。比如说@Since(1.2)代表从版本1.2之后才生效，@Until(0.9)代表着在0.9版本之前都是生效的。 1234567891011121314public class SoccerPlayer &#123; private String name; @Since(1.2) private int shirtNumber; @Until(0.9) private String country; private String teamName; // Methods removed for brevity&#125; 也就是说我们利用方法builder.setVersion(1.0)定义版本1.0，如下： 12345678910111213final GsonBuilder builder = new GsonBuilder(); builder.setVersion(1.0); final Gson gson = builder.create(); final SoccerPlayer account = new SoccerPlayer(); account.setName("Albert Attard"); account.setShirtNumber(10); // Since version 1.2 account.setTeamName("Zejtun Corinthians"); account.setCountry("Malta"); // Until version 0.9 final String json = gson.toJson(account); System.out.printf("Serialised (version 1.0)%n %s%n", json); 由于shirtNumber和country作用版本分别是1.2之后，和0.9之前，所以在这里都不会得到序列化，所以输出结果是： 12Serialised (version 1.0) &#123;"name":"Albert Attard","teamName":"Zejtun Corinthians"&#125; 基于访问修饰符什么是修饰符? public、static 、final、private、protected 这些就是，所以这种方式也是比较特殊的。使用方式： 12345678class ModifierSample &#123; final String finalField = "final"; static String staticField = "static"; public String publicField = "public"; protected String protectedField = "protected"; String defaultField = "default"; private String privateField = "private";&#125; 使用GsonBuilder.excludeFieldsWithModifiers构建gson,支持int形的可变参数，值由java.lang.reflect.Modifier提供，下面的程序排除了privateField 、 finalField 和staticField 三个字段。 123456ModifierSample modifierSample = new ModifierSample();Gson gson = new GsonBuilder() .excludeFieldsWithModifiers(Modifier.FINAL, Modifier.STATIC, Modifier.PRIVATE) .create();System.out.println(gson.toJson(modifierSample));// 结果：&#123;"publicField":"public","protectedField":"protected","defaultField":"default"&#125; 到此为止，Gson提供的所有注解就还有一个@JsonAdapter没有介绍了，而@JsonAdapter将和TypeAdapter将作为该系列第4篇也是最后一篇文章的主要内容。 基于策略（自定义规则）上面介绍的了3种排除字段的方法，说实话我除了@Expose以外，其它的都是只在Demo用上过，用得最多的就是马上要介绍的自定义规则，好处是功能强大、灵活，缺点是相比其它3种方法稍麻烦一点，但也仅仅只是想对其它3种稍麻烦一点而已。 基于策略是利用Gson提供的ExclusionStrategy接口，同样需要使用GsonBuilder,相关API 2个，分别是addSerializationExclusionStrategy 和addDeserializationExclusionStrategy 分别针对序列化和反序化时。这里以序列化为例。例如： 1234567891011121314151617Gson gson = new GsonBuilder() .addSerializationExclusionStrategy(new ExclusionStrategy() &#123; @Override public boolean shouldSkipField(FieldAttributes f) &#123; // 这里作判断，决定要不要排除该字段,return true为排除 if ("finalField".equals(f.getName())) return true; //按字段名排除 Expose expose = f.getAnnotation(Expose.class); if (expose != null &amp;&amp; expose.deserialize() == false) return true; //按注解排除 return false; &#125; @Override public boolean shouldSkipClass(Class&lt;?&gt; clazz) &#123; // 直接排除某个类 ，return true为排除 return (clazz == int.class || clazz == Integer.class); &#125; &#125;) .create(); POJO与JSON的字段映射规则还是之前User的例子，已经去除所有注解： 12User user = new User("怪盗kidou", 24);user.emailAddress = "ikidou@example.com"; GsonBuilder提供了FieldNamingStrategy接口和setFieldNamingPolicy和setFieldNamingStrategy 两个方法。 默认实现GsonBuilder.setFieldNamingPolicy 方法与Gson提供的另一个枚举类FieldNamingPolicy配合使用，该枚举类提供了5种实现方式分别为： FieldNamingPolicy 结果（仅输出emailAddress字段） IDENTITY {“emailAddress”:”ikidou@example.com”} LOWER_CASE_WITH_DASHES {“email-address”:”ikidou@example.com”} LOWER_CASE_WITH_UNDERSCORES {“email_address”:”ikidou@example.com”} UPPER_CAMEL_CASE {“EmailAddress”:”ikidou@example.com”} UPPER_CAMEL_CASE_WITH_SPACES {“Email Address”:”ikidou@example.com”} 自定义实现GsonBuilder.setFieldNamingStrategy 方法需要与Gson提供的FieldNamingStrategy接口配合使用，用于实现将POJO的字段与JSON的字段相对应。上面的FieldNamingPolicy实际上也实现了FieldNamingStrategy接口，也就是说FieldNamingPolicy也可以使用setFieldNamingStrategy方法。 用法： 123456789Gson gson = new GsonBuilder() .setFieldNamingStrategy(new FieldNamingStrategy() &#123; @Override public String translateName(Field f) &#123; //实现自己的规则 return null; &#125; &#125;) .create(); 注意： @SerializedName注解拥有最高优先级，在加有@SerializedName注解的字段上FieldNamingStrategy不生效！ Gson 序列化英文Serialize和format都对应序列化，这是一个Java对象到JSON字符串的过程。接着看一个例子,下面分别是java类和以及我们期望的JSON数据： 1234567public class Book &#123; private String[] authors; private String isbn10; private String isbn13; private String title; //为了代码简洁，这里移除getter和setter方法等&#125; 123456789&#123; "title": "Java Puzzlers: Traps, Pitfalls, and Corner Cases", "isbn-10": "032133678X", "isbn-13": "978-0321336781", "authors": [ "Joshua Bloch", "Neal Gafter" ]&#125; 你肯定能发现JSON数据中出现了isbn-10和isbn-13, 我们怎么把字段数据isbn10和isbn13转化为JSON数据需要的isbn-10和isbn-13,Gson当然为我们提供了对应的解决方案 序列化方案1采用上面提到的@SerializedName注解。 1234567891011public class Book &#123; private String[] authors; @SerializedName("isbn-10") private String isbn10; @SerializedName("isbn-13") private String isbn13; private String title; //为了代码简洁，这里移除getter和setter方法等&#125; 序列化方案2利用JsonSerializer类 12345678910111213141516171819public class BookSerialiser implements JsonSerializer &#123; @Override public JsonElement serialize(final Book book, final Type typeOfSrc, final JsonSerializationContext context) &#123; final JsonObject jsonObject = new JsonObject(); jsonObject.addProperty("title", book.getTitle()); jsonObject.addProperty("isbn-10", book.getIsbn10()); jsonObject.addProperty("isbn-13", book.getIsbn13()); final JsonArray jsonAuthorsArray = new JsonArray(); for (final String author : book.getAuthors()) &#123; final JsonPrimitive jsonAuthor = new JsonPrimitive(author); jsonAuthorsArray.add(jsonAuthor); &#125; jsonObject.add("authors", jsonAuthorsArray); return jsonObject; &#125;&#125; 下面对序列化过程进行大致的分析： JsonSerializer是一个接口，我们需要提供自己的实现，来满足自己的序列化要求。 12345678910public interface JsonSerializer&lt;T&gt; &#123;/** *Gson 会在解析指定类型T数据的时候触发当前回调方法进行序列化 * * @param T 需要转化为Json数据的类型，对应上面的Book * @return 返回T指定的类对应JsonElement */public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);&#125; 首先在上面的代码中，我们需要创建的是一个JsonElement对象，这里对应Book是一个对象，所以创建一个JsonObject类型。final JsonObject jsonObject = new JsonObject(); 然后我们将相应字段里面的数据填充到jsonObject里面。 12jsonObject.addProperty...jsonObject.add... 下面是jsonObject中的添加方法：jsonObj.add(String property,JsonElement value) 所以最后返回的还是一个JsonElement 类型，这里对应的是jsonObject。完成了javaBean-&gt;JSON数据的转化。 同样需要配置, 123456789101112131415// Configure GSON final GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(Book.class, new BookSerialiser()); gsonBuilder.setPrettyPrinting(); final Gson gson = gsonBuilder.create(); final Book javaPuzzlers = new Book(); javaPuzzlers.setTitle("Java Puzzlers: Traps, Pitfalls, and Corner Cases"); javaPuzzlers.setIsbn10("032133678X"); javaPuzzlers.setIsbn13("978-0321336781"); javaPuzzlers.setAuthors(new String[] &#123; "Joshua Bloch", "Neal Gafter" &#125;); // Format to JSON final String json = gson.toJson(javaPuzzlers); System.out.println(json); ，这里对应的是gsonBuilder.registerTypeAdapter(Book.class, new BookSerialiser())方法进行JsonSerializer的配置。在上面例子中，通过调用gsonBuilder.setPrettyPrinting();方法还告诉了 Gson 对生成的 JSON 对象进行格式化 Gson 反序列化英文parse和deserialise对应反序列化，这是一个字符串转换成Java对象的过程。我们同样采用上面一小节的代码片段，只不过现在我们需要做的是将： 123456789&#123; "title": "Java Puzzlers: Traps, Pitfalls, and Corner Cases", "isbn-10": "032133678X", "isbn-13": "978-0321336781", "authors": [ "Joshua Bloch", "Neal Gafter" ]&#125; 转化为对应的Book实体类。 反序列化方案1利用@SerializedName 注解也就是说我们的实体类Book.java可以这么写： 1234567891011public class Book &#123; private String[] authors; @SerializedName("isbn-10") private String isbn10; @SerializedName(value = "isbn-13", alternate = &#123;"isbn13","isbn.13"&#125;) private String isbn13; private String title; //为了代码简洁，这里移除getter和setter方法等&#125; 可以看到这里我们在@SerializedName 注解使用了一个value, alternate字段,value也就是默认的字段，对序列化和反序列化都有效，alternate只有反序列化才有效果。也就是说一般服务器返回给我们JSON数据的时候可能同样的一个图片，表示”image”,”img”,”icon”等备选属性名，我们利用@SerializedName 中的alternate字段就能解决这个问题，全部转化为我们实体类中的图片字段。 反序列化方案2我们在序列化的时候使用的是JsonSerialize ,这里对应使用JsonDeserializer我们将解析到的json数据传递给Book的setter方法即可。 12345678910111213141516171819202122232425262728public class BookDeserializer implements JsonDeserializer&lt;Book&gt; &#123; @Override public Book deserialize(final JsonElement json, final Type typeOfT, final JsonDeserializationContext context) throws JsonParseException &#123; final JsonObject jsonObject = json.getAsJsonObject(); final JsonElement jsonTitle = jsonObject.get("title"); final String title = jsonTitle.getAsString(); final String isbn10 = jsonObject.get("isbn-10").getAsString(); final String isbn13 = jsonObject.get("isbn-13").getAsString(); final JsonArray jsonAuthorsArray = jsonObject.get("authors").getAsJsonArray(); final String[] authors = new String[jsonAuthorsArray.size()]; for (int i = 0; i &lt; authors.length; i++) &#123; final JsonElement jsonAuthor = jsonAuthorsArray.get(i); authors[i] = jsonAuthor.getAsString(); &#125; final Book book = new Book(); book.setTitle(title); book.setIsbn10(isbn10); book.setIsbn13(isbn13); book.setAuthors(authors); return book; &#125;&#125; 和Gson序列化章节一样，我们这里接着分析我们是怎么将JSON数据解析（反序列化）为实体类的： 因为我们可以发现上面的JSON数据是一个{}大括号包围的，也就意味着这是一个Json对象。所以首先我们通过final JsonObject jsonObject = json.getAsJsonObject();将我们的JsonElement转化为JsonObject 通过jsonObject.get(&quot;xxx&quot;).getAsString()的形式获取相应String的值 通过jsonObject.get(&quot;xx&quot;).getAsJsonArray();获取相应的json数组，并遍历出其中的相应字段值 通过setter方法，将获取到的值设置给Book类。 最终返回的是 Book的对象实例。完成了JSON-&gt;javaBean的转化 同样需要配置 关于从本地流中读取Json数据可以使用 InputStreamReader完成 123456789101112// Configure Gson GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(Book.class, new BookDeserializer()); Gson gson = gsonBuilder.create(); // The JSON data try(Reader reader = new InputStreamReader(Main.class.getResourceAsStream("/part1/sample.json"), "UTF-8"))&#123; // Parse JSON to Java Book book = gson.fromJson(reader, Book.class); System.out.println(book); &#125; TypeAdapterTypeAdapter介绍之前在上一篇文中提到的JsonSerializer和JsonDeserializer解析的时候都利用到了一个中间件-JsonElement，比如下方的序列化过程。可以看到我们在把Java对象转化为JSON字符串的时候都会用到这个中间件JsonElement 而TypeAdapter的使用正是去掉了这个中间层，直接用流来解析数据，极大程度上提高了解析效率。 New applications should prefer TypeAdapter, whose streaming API is more efficient than this interface’s tree API.应用中应当尽量使用TypeAdapter，它流式的API相比于之前的树形解析API将会更加高效。TypeAdapter作为一个抽象类提供两个抽象方法。分别是write()和read()方法,也对应着序列化和反序列化,其它的方法都是final方法并最终调用这两个抽象方法。 如下图所示： 下面就让我们来一起使用和了解TypeAdapter吧。 TypeAdapter实例为了便于理解，这里还是统 一 一 下，采用和上面一篇文章同样的例子。Book.java实体类： 12345678910package com.javacreed.examples.gson.part1;public class Book &#123; private String[] authors; private String isbn; private String title;//为了代码简洁，这里移除getter和setter方法等&#125; 直接贴代码，具体序列化和反序列化的TypeAdapter类，这里是BookTypeAdapter.java： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.javacreed.examples.gson.part1;import java.io.IOException;import org.apache.commons.lang3.StringUtils;import com.google.gson.TypeAdapter;import com.google.gson.stream.JsonReader;import com.google.gson.stream.JsonWriter;public class BookTypeAdapter extends TypeAdapter &#123; @Override public Book read(final JsonReader in) throws IOException &#123; final Book book = new Book(); in.beginObject(); while (in.hasNext()) &#123; switch (in.nextName()) &#123; case "isbn": book.setIsbn(in.nextString()); break; case "title": book.setTitle(in.nextString()); break; case "authors": book.setAuthors(in.nextString().split(";")); break; &#125; &#125; in.endObject(); return book; &#125; @Override public void write(final JsonWriter out, final Book book) throws IOException &#123; out.beginObject(); out.name("isbn").value(book.getIsbn()); out.name("title").value(book.getTitle()); out.name("authors").value(StringUtils.join(book.getAuthors(), ";")); out.endObject(); &#125;&#125; 同样这里设置TypeAdapter之后还是需要配置（注册）,可以注意到的是gsonBuilder.registerTypeAdapter(xxx)方法进行注册在我们之前的JsonSerializer和JsonDeserializer中也有使用： 123final GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(Book.class, new BookTypeAdapter()); final Gson gson = gsonBuilder.create(); 下面对两个write方法和read方法进行分别的阐述： TypeAdapter中的write方法write()方法中会传入JsonWriter，和需要被序列化的Book对象的实例，采用和PrintStream类似的方式 写入到JsonWriter中。 12345678@Overridepublic void write(final JsonWriter out, final Book book) throws IOException &#123; out.beginObject(); out.name("isbn").value(book.getIsbn()); out.name("title").value(book.getTitle()); out.name("authors").value(StringUtils.join(book.getAuthors(), ";")); out.endObject();&#125; 下面是上面代码的步骤： out.beginObject()产生{,如果我们希望产生的是一个数组对象，对应的使用beginArray() out.name(&quot;isbn&quot;).value(book.getIsbn()); out.name(&quot;title&quot;).value(book.getTitle());分别获取book中的isbn和title字段并且设置给Json对象中的isbn和title。也就是说上面这段代码，会在json对象中产生：&quot;isbn&quot;: &quot;978-0321336781&quot;,&quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;, out.name(&quot;authors&quot;).value(StringUtils.join(book.getAuthors(), &quot;;&quot;));则会对应着：&quot;authors&quot;: &quot;Joshua Bloch;Neal Gafter&quot; 同理 out.endObject()则对应着} 那么整个上面的代码也就会产生JSON对象：{&quot;isbn&quot;: &quot;978-0321336781&quot;,&quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,&quot;authors&quot;: &quot;Joshua Bloch;Neal Gafter&quot;} 这里需要注意的是，如果没有调用 out.endObject()产生},那么你的项目会报出 1JsonSyntaxException`错误`Exception in thread "main" com.google.gson.JsonSyntaxException: java.io.EOFException: End of input at line 4 column 40 at com.google.gson.Gson.fromJson(Gson.java:813) at com.google.gson.Gson.fromJson(Gson.java:768) at com.google.gson.Gson.fromJson(Gson.java:717) at com.google.gson.Gson.fromJson(Gson.java:689) at com.javacreed.examples.gson.part1.Main.main(Main.java:41)Caused by: java.io.EOFException: End of input at line 4 column 40 at com.google.gson.stream.JsonReader.nextNonWhitespace(JsonReader.java:1377) at com.google.gson.stream.JsonReader.doPeek(JsonReader.java:471) at com.google.gson.stream.JsonReader.hasNext(JsonReader.java:403) at com.javacreed.examples.gson.part1.BookTypeAdapter.read(BookTypeAdapter.java:33) at com.javacreed.examples.gson.part1.BookTypeAdapter.read(BookTypeAdapter.java:1) at com.google.gson.Gson.fromJson(Gson.java:803) ... 4 more TypeAdapter中的read方法read()方法将会传入一个JsonReader对象实例并返回反序列化的对象。 12345678910111213141516171819202122@Overridepublic Book read(final JsonReader in) throws IOException &#123; final Book book = new Book(); in.beginObject(); while (in.hasNext()) &#123; switch (in.nextName()) &#123; case "isbn": book.setIsbn(in.nextString()); break; case "title": book.setTitle(in.nextString()); break; case "authors": book.setAuthors(in.nextString().split(";")); break; &#125; &#125; in.endObject(); return book;&#125; 下面是这段代码的步骤：同样是通过in.beginObject();和in.endObject();对应解析{,}通过while (in.hasNext()) {switch (in.nextName()) {}}来完成每个JsonElement的遍历,并且通过switch...case的方法获取Json对象中的键值对。并通过我们Book实体类的Setter方法进行设置。 12345678910111213while (in.hasNext()) &#123; switch (in.nextName()) &#123; case "isbn": book.setIsbn(in.nextString()); break; case "title": book.setTitle(in.nextString()); break; case "authors": book.setAuthors(in.nextString().split(";")); break; &#125; &#125; 同样需要注意的是,如果没有执行in.endObject()，将会出现JsonIOException的错误： 1Exception in thread "main" com.google.gson.JsonIOException: JSON document was not fully consumed. at com.google.gson.Gson.assertFullConsumption(Gson.java:776) at com.google.gson.Gson.fromJson(Gson.java:769) at com.google.gson.Gson.fromJson(Gson.java:717) at com.google.gson.Gson.fromJson(Gson.java:689) at com.javacreed.examples.gson.part1.Main.main(Main.java:41) 下面给出使用TypeAdapter的完整代码： 1234567891011121314151617181920212223242526272829package com.javacreed.examples.gson.part1;import java.io.IOException;import com.google.gson.Gson;import com.google.gson.GsonBuilder;public class Main &#123; public static void main(final String[] args) throws IOException &#123; final GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(Book.class, new BookTypeAdapter()); gsonBuilder.setPrettyPrinting(); final Gson gson = gsonBuilder.create(); final Book book = new Book(); book.setAuthors(new String[] &#123; "Joshua Bloch", "Neal Gafter" &#125;); book.setTitle("Java Puzzlers: Traps, Pitfalls, and Corner Cases"); book.setIsbn("978-0321336781"); final String json = gson.toJson(book); System.out.println("Serialised"); System.out.println(json); final Book parsedBook = gson.fromJson(json, Book.class); System.out.println("\nDeserialised"); System.out.println(parsedBook); &#125;&#125; 对应的编译结果为： 123456789101112Serialised&#123; "isbn": "978-0321336781", "title": "Java Puzzlers: Traps, Pitfalls, and Corner Cases", "authors": "Joshua Bloch;Neal Gafter"&#125;DeserialisedJava Puzzlers: Traps, Pitfalls, and Corner Cases [978-0321336781]Written by: &gt;&gt; Joshua Bloch &gt;&gt; Neal Gafter TypeAdapter处理简洁的JSON数据为了简化JSON数据，其实我们上面的JSON数据可以这么写： 1["978-0321336781","Java Puzzlers: Traps, Pitfalls, and Corner Cases","Joshua Bloch","Neal Gafter"] 可以看到的是，这样采用的直接是值的形式。当然这样操作简化了JSON数据但是可能就让整个数据的稳定性下降了许多的，你需要按照一定的顺序来解析这个数据。对应的write和read方法如下： 12345678910@Overridepublic void write(final JsonWriter out, final Book book) throws IOException &#123; out.beginArray(); out.value(book.getIsbn()); out.value(book.getTitle()); for (final String author : book.getAuthors()) &#123; out.value(author); &#125; out.endArray();&#125; 12345678910111213141516@Overridepublic Book read(final JsonReader in) throws IOException &#123; final Book book = new Book(); in.beginArray(); book.setIsbn(in.nextString()); book.setTitle(in.nextString()); final List authors = new ArrayList&lt;&gt;(); while (in.hasNext()) &#123; authors.add(in.nextString()); &#125; book.setAuthors(authors.toArray(new String[authors.size()])); in.endArray(); return book;&#125; 这里的解析原理和上面一致，不再赘述。 TypeAdapter解析内置对象（这里将nested objects翻译为内置对象，其实就是在Book类）这里对上面的Book实体类进行修改如下，添加Author作者类，每本书可以有多个作者。 1234567891011121314151617package com.javacreed.examples.gson.part3;public class Book &#123; private Author[] authors; private String isbn; private String title;class Author &#123; private int id; private String name;//为了代码简洁，这里移除getter和setter方法等&#125;//为了代码简洁，这里移除getter和setter方法等&#125; 这里提供JSON对象， 1234567891011121314&#123; "isbn": "978-0321336781", "title": "Java Puzzlers: Traps, Pitfalls, and Corner Cases", "authors": [ &#123; "id": 1, "name": "Joshua Bloch" &#125;, &#123; "id": 2, "name": "Neal Gafter" &#125; ]&#125; 下面分别展示write和read方法： 123456789101112131415@Overridepublic void write(final JsonWriter out, final Book book) throws IOException &#123; out.beginObject(); out.name("isbn").value(book.getIsbn()); out.name("title").value(book.getTitle()); out.name("authors").beginArray(); for (final Author author : book.getAuthors()) &#123; out.beginObject(); out.name("id").value(author.getId()); out.name("name").value(author.getName()); out.endObject(); &#125; out.endArray(); out.endObject();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041@Override public Book read(final JsonReader in) throws IOException &#123; final Book book = new Book(); in.beginObject(); while (in.hasNext()) &#123; switch (in.nextName()) &#123; case "isbn": book.setIsbn(in.nextString()); break; case "title": book.setTitle(in.nextString()); break; case "authors": in.beginArray(); final List authors = new ArrayList&lt;&gt;(); while (in.hasNext()) &#123; in.beginObject(); final Author author = new Author(); while (in.hasNext()) &#123; switch (in.nextName()) &#123; case "id": author.setId(in.nextInt()); break; case "name": author.setName(in.nextString()); break; &#125; &#125; authors.add(author); in.endObject(); &#125; book.setAuthors(authors.toArray(new Author[authors.size()])); in.endArray(); break; &#125; &#125; in.endObject(); return book; &#125; Gson性能分析首先来看看我们提供一个大一点的数据来论证下面一些方法的优缺点。 这里提供类LargeData.java,并分为四个部分进行内存消耗的分析： 12345678910111213141516public class LargeData &#123; private long[] numbers; public void create(final int length) &#123; numbers = new long[length]; for (int i = 0; i &lt; length; i++) &#123; numbers[i] = i; &#125; &#125; public long[] getNumbers() &#123; return numbers; &#125;&#125; 第1部分 JsonSerializer的直接使用看看下面的JsonSerializer: 12345678910111213141516171819202122232425package com.javacreed.examples.gson.part1;import java.lang.reflect.Type;import com.google.gson.JsonArray;import com.google.gson.JsonElement;import com.google.gson.JsonObject;import com.google.gson.JsonPrimitive;import com.google.gson.JsonSerializationContext;import com.google.gson.JsonSerializer;public class LargeDataSerialiser implements JsonSerializer&lt;LargeData&gt; &#123; @Override public JsonElement serialize(final LargeData data, final Type typeOfSrc, final JsonSerializationContext context) &#123; final JsonArray jsonNumbers = new JsonArray(); for (final long number : data.getNumbers()) &#123; jsonNumbers.add(new JsonPrimitive(number)); &#125; final JsonObject jsonObject = new JsonObject(); jsonObject.add("numbers", jsonNumbers); return jsonObject; &#125;&#125; 上面的代码实现了从java对象&gt;转化&gt;JSON数组的序列化过程。下面的代码实现了配置和初始化的过程，被写入文件。这里可以看到的是对LargeData初始化了10485760个元素： 123456789101112131415161718192021222324252627282930313233package com.javacreed.examples.gson.part1;import java.io.File;import java.io.IOException;import java.io.PrintStream;import com.google.gson.Gson;import com.google.gson.GsonBuilder;public class Main &#123; public static void main(final String[] args) throws IOException &#123; // Configure GSON final GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser()); gsonBuilder.setPrettyPrinting(); final Gson gson = gsonBuilder.create(); final LargeData data = new LargeData(); data.create(10485760); final String json = gson.toJson(data); final File dir = new File("target/part1"); dir.mkdirs(); try (PrintStream out = new PrintStream(new File(dir, "output.json"), "UTF-8")) &#123; out.println(json); &#125; System.out.println("Done"); &#125;&#125; 这个例子实现了创建java对象并且转化为JSON字符串并写入文件的整个过程。下面的图标展示了内存的消耗情况： 上面的的LargeData在这里会消耗89MB的内存，从java对象转化为JSON字符串的过程将会消耗大概16s的时间并且需要超过1GB的内存。也就是说，序列化1MB的数据我们需要大约11MB的工作空间。1：11的确实是一个不小的比列。下面的 图片会展示整个过程的几个阶段。 可以看到的是，这里有四个方块分别代表不同的阶段，（但是IO 缓冲区并没有在这里得到使用，所以以灰色进行标注。）整个过程从java对象（蓝色方块），然后由LargeDataSerialiser类创建的JSONElement对象（红色方块），然后这些临时的对象又被转化为JSON 字符串（绿色方块），上面的示例代码使用PrintStream将内容输出到文件中并没有使用任何缓冲区。完成了第1部分的分析，接下来下面的分析流程是一样的： 第2 部分 TypeAdapter的直接使用之前的系列文章中都对Gson基础的使用进行了很好的讲解，可以回顾一下。TypeAdapter相比 于上面的方法，并没有使用JSONElement对象，而是直接将Java对象啊转化为了JSON对象。 123456789101112131415161718192021222324252627package com.javacreed.examples.gson.part2;import java.io.IOException;import com.google.gson.TypeAdapter;import com.google.gson.stream.JsonReader;import com.google.gson.stream.JsonWriter;public class LargeDataTypeAdapter extends TypeAdapter&lt;LargeData&gt; &#123; @Override public LargeData read(final JsonReader in) throws IOException &#123; throw new UnsupportedOperationException("Coming soon"); &#125; @Override public void write(final JsonWriter out, final LargeData data) throws IOException &#123; out.beginObject(); out.name("numbers"); out.beginArray(); for (final long number : data.getNumbers()) &#123; out.value(number); &#125; out.endArray(); out.endObject(); &#125;&#125; 同样会需要配置，这里主要使用的方法是gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());： 123456789101112131415161718192021222324252627282930313233package com.javacreed.examples.gson.part2;import java.io.File;import java.io.IOException;import java.io.PrintStream;import com.google.gson.Gson;import com.google.gson.GsonBuilder;public class Main &#123; public static void main(final String[] args) throws IOException &#123; // Configure GSON final GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter()); gsonBuilder.setPrettyPrinting(); final Gson gson = gsonBuilder.create(); final LargeData data = new LargeData(); data.create(10485760); final String json = gson.toJson(data); final File dir = new File("target/part2"); dir.mkdirs(); try (PrintStream out = new PrintStream(new File(dir, "output.json"), "UTF-8")) &#123; out.println(json); &#125; System.out.println("Done"); &#125;&#125; 上面的代码完成的是从java对象 &gt;转化&gt;JSON 字符串并最终写入文件的过程。看看下面的性能分析图表： 和最初的那个方法一样，这里的LargeData对象将会需要89MB的内存，从java对象转化为JSON字符串的过程需要消耗4s的时间，大概650MB的内存。也就是说，序列化1MB的数据，大概需要7.5MB的内存空间。相比于之前的第一种JsonSerializer方法，这里减少了接近一半的内存消耗。同样的，来看看这个方法的几个过程： 这里的序列化过程主要有两个阶段，相比于之前的JSONSerializer的序列化过程，这里没有了转化为JSONElement的过程，也就完成了内存消耗的减少。 第3部分 TypeAdapter的流式处理下面的代码，我们使用上面同样的TypeAdapter，只不过我们直接在main()方法中修改Gson的用法，以流的形式进行输出。 12345678910111213141516171819202122232425262728293031323334package com.javacreed.examples.gson.part3;import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import com.google.gson.Gson;import com.google.gson.GsonBuilder;public class Main &#123; public static void main(final String[] args) throws IOException &#123; // Configure GSON final GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter()); gsonBuilder.setPrettyPrinting(); final Gson gson = gsonBuilder.create(); final LargeData data = new LargeData(); data.create(10485760); final File dir = new File("target/part3"); dir.mkdirs(); try (BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(dir, "output.json")), "UTF-8"))) &#123; gson.toJson(data, out); &#125; System.out.println("Done"); &#125;&#125; 这个例子同样是将java对象转化为JSON字符串并且输出，也来看看下面的性能分析图表： 可以看到的是同样的最初产生的数据是89MB,序列化过程将java对象转化为JSON字符串花了大概三秒钟的时间，消耗大概160MB的内存。也就是说序列化1MB的数据我们需要大概2MB的内存空间。相比于之前的两种方法，有了很大的改进。 这个方法同样的是使用了两个阶段。不过在上面一个示例中的绿色方块部分在这里没有使用，这里直接完成了java对象到IO 缓冲区的转化并写入文件。虽然这里并不是Gson的关系，但是我们使用Gson的方法极大的减少了内存消耗，所以说在使用开源库的时候，能够正确高效的使用API也显得尤为重要。 第4部分 JsonSerializer 的流式处理同样的使用第一个例子中的JsonSerializer，这里的配置需要注意的是gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser()); 12345678910111213141516171819202122232425262728293031323334package com.javacreed.examples.gson.part4;import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import com.google.gson.Gson;import com.google.gson.GsonBuilder;public class Main &#123; public static void main(final String[] args) throws IOException &#123; // Configure GSON final GsonBuilder gsonBuilder = new GsonBuilder(); gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser()); gsonBuilder.setPrettyPrinting(); final Gson gson = gsonBuilder.create(); final LargeData data = new LargeData(); data.create(10485760); final File dir = new File("target/part4"); dir.mkdirs(); try (BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(dir, "output.json")), "UTF-8"))) &#123; gson.toJson(data, out); &#125; System.out.println("Done"); &#125;&#125; 经过前面的分析，我们这里也可以这道这里主要分为三个阶段，下面提供性能分析图和JSONSerializer的阶段流程图： 这里可以看到三个阶段完成的工作消耗了11s的时间，730MB的内存空间。也就是说1：8的比例。可以相比上面的例子，知道这里使用JSONSerializer产生了JSONElement对象消耗了很多的内存。 结论在上面的分析过程中，我们采用了GSON的两种不同的方然完成了序列化一个大数据的过程，并且比较了不同的方法之间的差异。上面的第三种方法（TypeAdapter的流式处理）被论证为最合适的，消耗最少内存的一种方法。Gson主要分成两部分,一个就是数据拆解,一个是数据封装。 参考 你真的会用Gson吗?Gson使用指南（一）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-SpannableString设置复合文本]]></title>
      <url>%2F2017%2F07%2F23%2Fandroid-spannablestring%2F</url>
      <content type="text"><![CDATA[TextView通常用来显示普通文本，但是有时候需要对其中某些文本进行样式、事件方面的设置。 Android系统通过SpannableString类来对指定文本进行相关处理，具体有以下功能： BackgroundColorSpan 背景色 ClickableSpan 文本可点击，有点击事件 ForegroundColorSpan 文本颜色（前景色） MaskFilterSpan 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter) MetricAffectingSpan 父类，一般不用 RasterizerSpan 光栅效果 StrikethroughSpan 删除线（中划线） SuggestionSpan 相当于占位符 UnderlineSpan 下划线 AbsoluteSizeSpan 绝对大小（文本字体） DynamicDrawableSpan 设置图片，基于文本基线或底部对齐。 ImageSpan 图片 RelativeSizeSpan 相对大小（文本字体） ReplacementSpan 父类，一般不用 ScaleXSpan 基于x轴缩放 StyleSpan 字体样式：粗体、斜体等 SubscriptSpan 下标（数学公式会用到） SuperscriptSpan 上标（数学公式会用到） TextAppearanceSpan 文本外貌（包括字体、大小、样式和颜色） TypefaceSpan 文本字体 URLSpan 文本超链接 一、BackgroundColorSpan 背景色1234SpannableString spanText = new SpannableString("萝卜白菜的博客 -- http://orgcent.com");spanText.setSpan(new BackgroundColorSpan(Color.GREEN), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); 二、ClickableSpan 文本可点击，有点击事件三、ForegroundColorSpan 文本颜色（前景色）1234spanText = new SpannableString("萝卜白菜的博客 -- http://orgcent.com");spanText.setSpan(new ForegroundColorSpan(Color.BLUE), 6, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); 四、MaskFilterSpan 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)12345678910spanText = new SpannableString("MaskFilterSpan -- http://orgcent.com");int length = spanText.length();//模糊(BlurMaskFilter)MaskFilterSpan maskFilterSpan = new MaskFilterSpan(new BlurMaskFilter(3, Blur.OUTER));spanText.setSpan(maskFilterSpan, 0, length - 10, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);//浮雕(EmbossMaskFilter)maskFilterSpan = new MaskFilterSpan(new EmbossMaskFilter(new float[]&#123;1,1,3&#125;, 1.5f, 8, 3));spanText.setSpan(maskFilterSpan, length - 10, length, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); PS:从上图看，浮雕效果不明显。把字体设置大点后可以看得清晰些。需要其他效果可以继承MaskFilter来自定义。 六、RasterizerSpan 光栅效果1234spanText = new SpannableString("StrikethroughSpan");spanText.setSpan(new StrikethroughSpan(), 0, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); PS:暂不清楚，效果不明显。 七、StrikethroughSpan 删除线（中划线）1234spanText = new SpannableString("StrikethroughSpan");spanText.setSpan(new StrikethroughSpan(), 0, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); 八、SuggestionSpan相当于占位符，一般用在EditText输入框中。当双击此文本时，会弹出提示框选择一些建议（推荐的）文字，选中的文本将替换此占位符。在输入法上用的较多。 PS：API 14新增，暂无示例。 九、UnderlineSpan 下划线1234spanText = new SpannableString("UnderlineSpan");spanText.setSpan(new UnderlineSpan(), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); 十、AbsoluteSizeSpan 绝对大小（文本字体）1234spanText = new SpannableString("AbsoluteSizeSpan");spanText.setSpan(new AbsoluteSizeSpan(20, true), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); PS:把字体大小设置大点，效果硬朗。 十一、DynamicDrawableSpan 设置图片，基于文本基线或底部对齐。1234567891011121314151617181920DynamicDrawableSpan drawableSpan = new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BASELINE) &#123; @Override public Drawable getDrawable() &#123; Drawable d = getResources().getDrawable(R.drawable.ic_launcher); d.setBounds(0, 0, 50, 50); return d; &#125;&#125;;DynamicDrawableSpan drawableSpan2 = new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BOTTOM) &#123; @Override public Drawable getDrawable() &#123; Drawable d = getResources().getDrawable(R.drawable.ic_launcher); d.setBounds(0, 0, 50, 50); return d; &#125;&#125;;spanText.setSpan(drawableSpan, 3, 4, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);spanText.setSpan(drawableSpan2, 7, 8, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); PS:左边图片基于基线对齐，右边图片基于底部对齐 十二、ImageSpan 图片123456spanText = new SpannableString("ImageSpan");Drawable d = getResources().getDrawable(R.drawable.ic_launcher);d.setBounds(0, 0, 50, 50);spanText.setSpan(new ImageSpan(d), 3, 4, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); PS:和DynamicDrawableSpan差别不大 十三、RelativeSizeSpan 相对大小（文本字体）12345spanText = new SpannableString("RelativeSizeSpan");//参数proportion:比例大小spanText.setSpan(new RelativeSizeSpan(2.5f), 3, 4,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); PS:相对大小的比例是基于当前文本字体大小 十四、ScaleXSpan 基于x轴缩放12345spanText = new SpannableString("ScaleXSpan -- 萝卜白菜的博客");//参数proportion:比例大小spanText.setSpan(new ScaleXSpan(3.8f), 3, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); 十五、StyleSpan 字体样式：粗体、斜体等12345spanText = new SpannableString("StyleSpan -- 萝卜白菜的博客");//Typeface.BOLD_ITALIC:粗体+斜体spanText.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 3, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); 十六、SubscriptSpan 下标（数学公式会用到）1234spanText = new SpannableString("SubscriptSpan -- 萝卜白菜的博客");spanText.setSpan(new SubscriptSpan(), 6, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); 十七、SuperscriptSpan 上标（数学公式会用到）1234spanText = new SpannableString("SuperscriptSpan -- 萝卜白菜的博客");spanText.setSpan(new SuperscriptSpan(), 6, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); 十八、TextAppearanceSpan 文本外貌（包括字体、大小、样式和颜色）12345spanText = new SpannableString("TextAppearanceSpan -- 萝卜白菜的博客");//若需自定义TextAppearance，可以在系统样式上进行修改spanText.setSpan(new TextAppearanceSpan(this, android.R.style.TextAppearance_Medium),6, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText); PS:系统还提供了相关值TextAppearance_Small, TextAppearance_Large等。如有需要可在以上样式基础上修改。 十九、TypefaceSpan 文本字体1234spanText = new SpannableString("TypefaceSpan -- 萝卜白菜的博客");//若需使用自定义字体，可能要重写类TypefaceSpanspanText.setSpan(new TypefaceSpan("monospace"), 3, 10,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText);; 二十、URLSpan 文本超链接123456spanText = new SpannableString("URLSpan -- 萝卜白菜的博客");spanText.setSpan(new URLSpan("http://orgcent.com"), 10, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append("\n");mTVText.append(spanText);//让URLSpan可以点击mTVText.setMovementMethod(new LinkMovementMethod()); https://juejin.im/post/59bf91476fb9a00a583178d3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-RxJava详细学习]]></title>
      <url>%2F2017%2F07%2F17%2Fandroid-rxjava%2F</url>
      <content type="text"><![CDATA[前言Android开发已经进行了蛮久的一段时间了，基础部分都掌握的差不多了。所以需要跟进时代需要学习一直以来很火的RxJava来提升自己的开发效率以及代码的规范。 RxJava 到底是什么一个词：异步。 a library for composing asynchronous and event-based programs using observable sequences for the Java VM解释：一个对于构成使用的Java虚拟机观察序列异步和基于事件的程序库 RxJava 是一个非常著名的开源库，是ReactiveX响应式编程框架的一种Java实现，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。RxJava 是一个开源项目，地址： https://github.com/ReactiveX/RxJavaRxAndroid，用于 Android 开发，添加了 Android 用的接口。地址： https://github.com/ReactiveX/RxAndroid其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。 RxJava 好在哪换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / … ？』 一个词：简洁。 异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 AsyncTask 和Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。 假设有这样一个需求：界面上有一个自定义的视图 imageCollectorView ，它的作用是显示多张图片，并能使用 addImage(Bitmap) 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 File[] folders 中每个目录下的 png 图片都加载出来并显示在 imageCollectorView 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种： 1234567891011121314151617181920new Thread() &#123; @Override public void run() &#123; super.run(); for (File folder : folders) &#123; File[] files = folder.listFiles(); for (File file : files) &#123; if (file.getName().endsWith(".png")) &#123; final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125; &#125; &#125; &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的： 123456789101112131415161718192021222324252627Observable.from(folders) .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(".png"); &#125; &#125;) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125;&#125;); 虽然代码看起来更多了，但观察一下你会发现， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显（试想如果还要求只选取前 10 张图片，常规方式要怎么办？如果有更多这样那样的要求呢？再试想，在这一大堆需求实现完两个月之后需要改功能，当你翻回这里看到自己当初写下的那一片迷之缩进，你能保证自己将迅速看懂，而不是对着代码重新捋一遍思路？）。 另外，如果你的 IDE 是 Android Studio ，其实每次打开某个 Java 文件的时候，你会看到被自动 Lambda 化的预览，这将让你更加清晰地看到程序逻辑： 1234567Observable.from(folders) .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;) .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(".png") &#125;) .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe((Action1) (bitmap) -&gt; &#123; imageCollectorView.addImage(bitmap) &#125;); 基本概念Observable：发射源，英文释义“可观察的”，在观察者模式中称为“被观察者”或“可观察对象”；Observer：接收源，英文释义“观察者”，没错！就是观察者模式中的“观察者”，可接收Observable、Subject发射的数据；Subject：Subject是一个比较特殊的对象，既可充当发射源，也可充当接收源，为避免初学者被混淆，本章将不对Subject做过多的解释和使用，重点放在Observable和Observer上，先把最基本方法的使用学会，后面再学其他的都不是什么问题；Subscriber：“订阅者”，也是接收源，那它跟Observer有什么区别呢？Subscriber实现了Observer接口，比Observer多了一个最重要的方法unsubscribe( )，用来取消订阅，当你不再想接收数据了，可以调用unsubscribe( )方法停止接收，Observer 在 subscribe() 过程中,最终也会被转换成 Subscriber 对象，一般情况下，建议使用Subscriber作为接收源；Subscription ：Observable调用subscribe( )方法返回的对象，同样有unsubscribe( )方法，可以用来取消订阅事件；Action0：RxJava中的一个接口，它只有一个无参call（）方法，且无返回值，同样还有Action1，Action2…Action9等，Action1封装了含有 1 个参的call（）方法，即call（T t），Action2封装了含有 2 个参数的call方法，即call（T1 t1，T2 t2），以此类推；Func0：与Action0非常相似，也有call（）方法，但是它是有返回值的，同样也有Func0、Func1…Func9; API 介绍和原理简析RxJava 的观察者模式RxJava 有四个基本概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)、事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。 与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext() （相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted() 和 onError()。 onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted()方法作为标志。 onError(): 事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时队列自动终止，不允许再有事件发出。 在一个正确运行的事件序列中, onCompleted()和onError() 有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。RxJava 的观察者模式大致如下图： 基本实现基于以上的概念， RxJava 的基本实现主要有三点： 创建 ObserverObserver 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer 接口的实现方式： 12345678910111213141516Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, "Item: " + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, "Completed!"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, "Error!"); &#125;&#125;; 除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的： 12345678910111213141516Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, "Item: " + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, "Completed!"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, "Error!"); &#125;&#125;; 不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer 也总是会先被转换成一个 Subscriber 再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点： onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart()就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使doOnSubscribe()方法，具体可以在后面的文中看到。 unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription的方法，用于取消订阅。在这个方法被调用后，Subscriber将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在 subscribe() 之后， Observable 会持有 Subscriber的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause()``onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 创建 ObservableObservable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则： 123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("Hello"); subscriber.onNext("Hi"); subscriber.onNext("Aloha"); subscriber.onCompleted(); &#125;&#125;); 可以看到，这里传入了一个 OnSubscribe 对象作为参数。OnSubscribe 会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 的 call() 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用三次 onNext() 和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。 create() 方法是 RxJava 最基本的创造事件序列的方法。 just(T...): 将传入的参数依次发送出来。 123456Observable observable = Observable.just("Hello", "Hi", "Aloha");// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted(); from(T[])/ from(Iterable&lt;? extends T&gt;): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。 1234567String[] words = &#123;"Hello", "Hi", "Aloha"&#125;;Observable observable = Observable.from(words);// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted(); defer( ):有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable： 123456deferObservable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() &#123; @Override //注意此处的call方法没有Subscriber参数 public Observable&lt;String&gt; call() &#123; return Observable.just("deferObservable"); &#125;&#125;); interval( ):创建一个按固定时间间隔发射整数序列的Observable，可用作定时器： 1intervalObservable = Observable.interval(1, TimeUnit.SECONDS);//每隔一秒发送一次 range( ):创建一个发射特定整数序列的Observable，第一个参数为起始值，第二个为发送的个数，如果为0则不发送，负数则抛异常： 1rangeObservable = Observable.range(10, 5);//将发送整数10，11，12，13，14 timer( ):创建一个Observable，它在一个给定的延迟后发射一个特殊的值，等同于Android中Handler的postDelay( )方法： 1timeObservable = Observable.timer(3, TimeUnit.SECONDS); //3秒后发射一个值 repeat( ):创建一个重复发射特定数据的Observable: 1repeatObservable = Observable.just("repeatObservable").repeat(3);//重复发射3次 Subscribe (订阅)创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单： 123observable.subscribe(observer);// 或者：observable.subscribe(subscriber); subscriber() 做了3件事： 调用 Subscriber.onStart()。这个方法在前面已经介绍过，是一个可选的准备方法。 调用 Observable 中的 OnSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， Observable 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。 将传入的 Subscriber 作为 Subscription 返回。这是为了方便 unsubscribe(). 整个过程中对象间的关系如下图： 或者可以看动图： 除了 subscribe(Observer) 和subscribe(Subscriber) ，subscribe() 还支持不完整定义的回调，RxJava 会自动根据定义创建出 Subscriber 。形式如下： 12345678910111213141516171819202122232425262728Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; // onNext() @Override public void call(String s) &#123; Log.d(tag, s); &#125;&#125;;Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123; // onError() @Override public void call(Throwable throwable) &#123; // Error handling &#125;&#125;;Action0 onCompletedAction = new Action0() &#123; // onCompleted() @Override public void call() &#123; Log.d(tag, "completed"); &#125;&#125;;// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()observable.subscribe(onNextAction);// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()observable.subscribe(onNextAction, onErrorAction);// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()observable.subscribe(onNextAction, onErrorAction, onCompletedAction); 简单解释一下这段代码中出现的 Action1 和 Action0。 Action0 是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted() 方法也是无参无返回值的，因此 Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。这样其实也可以看做将 onCompleted() 方法作为参数传进了 subscribe()，相当于其他某些语言中的『闭包』。Action1 也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0 同理，由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1可以将 onNext(obj) 和 onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。事实上，虽然 Action0 和 Action1在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX 形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。 Subscriptions(订阅者)当调用Observable.subscribe()，会返回一个Subscription对象。这个对象代表了被观察者和订阅者之间的联系。 12Subscription subscription = Observable.just("Hello, World!").subscribe(s -&gt; System.out.println(s)); 你可以在后面使用这个Subscription对象来操作被观察者和订阅者之间的联系. 123subscription.unsubscribe();//接触订阅关系System.out.println("Unsubscribed=" + subscription.isUnsubscribed());// Outputs "Unsubscribed=true" RxJava的另外一个好处就是它处理unsubscribing的时候，会停止整个调用链。如果你使用了一串很复杂的操作符，调用unsubscribe将会在他当前执行的地方终止。不需要做任何额外的工作！ 场景示例打印字符串数组将字符串数组 names 中的所有字符串依次打印出来： 12345678String[] names = ...;Observable.from(names) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String name) &#123; Log.d(tag, name); &#125;&#125;); 由 id 取得图片并显示由指定的一个 drawable 文件 id drawableRes 取得图片，并显示在 ImageView 中，并在出现异常的时候打印 Toast 报错： 123456789101112131415161718192021222324int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, "Error!", Toast.LENGTH_SHORT).show(); &#125;&#125;); 正如上面两个例子这样，创建出 Observable 和 Subscriber ，再用 subscribe() 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。然而，在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。 线程控制 —— Scheduler (一)在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler （调度器）。 Scheduler 的 API (一)在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景： Schedulers.trampoline( ):当其它排队的任务完成后，在当前线程排队开始执行。 Schedulers.from(executor):使用指定的Executor作为调度器。 Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler使用的固定的线程池，默认线程数等于处理器的数量。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。 有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。文字叙述总归难理解，上代码： 123456789Observable.just(1, 2, 3, 4) .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程 .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; Log.d(tag, "number:" + number); &#125;&#125;); 上面这段代码中，由于 subscribeOn(Schedulers.io()) 的指定，被创建的事件的内容 1、2、3、4 将会在 IO 线程发出；而由于 observeOn(AndroidScheculers.mainThread()) 的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句： 123456789101112131415161718192021222324252627int drawableRes = ...;ImageView imageView = ...;Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123; @Override public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123; Drawable drawable = getTheme().getDrawable(drawableRes)); subscriber.onNext(drawable); subscriber.onCompleted(); &#125;&#125;).subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程.subscribe(new Observer&lt;Drawable&gt;() &#123; @Override public void onNext(Drawable drawable) &#123; imageView.setImageDrawable(drawable); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(activity, "Error!", Toast.LENGTH_SHORT).show(); &#125;&#125;); 那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。 Scheduler 的原理 (一)RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 subscribe() 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。 变换终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。 RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。 API首先看一个 map() 的例一： 12345678910111213Observable.just("images/logo.png") // 输入类型 String .map(new Func1&lt;String, Bitmap&gt;() &#123; @Override public Bitmap call(String filePath) &#123; // 参数类型 String return getBitmapFromPath(filePath); // 返回类型 Bitmap &#125; &#125;) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap showBitmap(bitmap); &#125; &#125;); 这里出现了一个叫做 Func1 的类。它和 Action1 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX和 ActionX的区别在 FuncX包装的是有返回值的方法。可以看到，map()方法将参数中的 String对象转换成一个 Bitmap 对象后返回，而在经过map()方法后，事件的参数类型也由 String转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换,将对象转换成另一个对象发射出去，应用范围非常广，如数据的转换，数据的预处理等。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换： 例二：对数据进行预处理，最后得到理想型数据。实际开发过程中，从后台接口获取到的数据也许不符合我们想要的，这时候可以在获取过程中对得到的数据进行预处理（结合Retrofit）。 12345678910Observable.just("12345678").map(new Func1&lt;String, String&gt;() &#123; @Override public String call(String s) &#123; return s.substring(0,4);//只要前四位 &#125;&#125;).subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i("mytag",s); &#125;&#125;); map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 map() 的示意图： flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单： 12345678910111213141516Student[] students = ...;Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onNext(String name) &#123; Log.d(tag, name); &#125; ...&#125;;Observable.from(students) .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student student) &#123; return student.getName(); &#125; &#125;) .subscribe(subscriber); 很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现： 1234567891011121314Student[] students = ...;Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() &#123; @Override public void onNext(Student student) &#123; List&lt;Course&gt; courses = student.getCourses(); for (int i = 0; i &lt; courses.size(); i++) &#123; Course course = courses.get(i); Log.d(tag, course.getName()); &#125; &#125; ...&#125;;Observable.from(students) .subscribe(subscriber); 依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？ 这个时候，就需要用 flatMap() 了： 12345678910111213141516Student[] students = ...;Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123; @Override public void onNext(Course course) &#123; Log.d(tag, course.getName()); &#125; ...&#125;;Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCourses()); &#125; &#125;) .subscribe(subscriber); 从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map()不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap()所谓的 flat。flatMap()示意图： 扩展：由于可以在嵌套的 Observable 中添加异步代码， flatMap() 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）： 123456789101112131415networkClient.token() // 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token .flatMap(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() &#123; @Override public Observable&lt;Messages&gt; call(String token) &#123; // 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表 return networkClient.messages(); &#125; &#125;) .subscribe(new Action1&lt;Messages&gt;() &#123; @Override public void call(Messages messages) &#123; // 处理显示消息列表 showMessages(messages); &#125; &#125;); 传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 flatMap() ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。 throttleFirst(): 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber);妈妈再也不怕我的用户手抖点开两个重复的界面啦。此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。 变换的原理：lift()这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）： 123456789101112// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) &#123; return Observable.create(new OnSubscribe&lt;R&gt;() &#123; @Override public void call(Subscriber subscriber) &#123; Subscriber newSubscriber = operator.call(subscriber); newSubscriber.onStart(); onSubscribe.call(newSubscriber); &#125; &#125;);&#125; 这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适） subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。 当含有 lift() 时： 1.lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了； 2.而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe； 3.当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； 4.而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call()方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call()方法将新 Subscriber和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。 这样就实现了 lift()过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。 精简掉细节的话，也可以这么说：在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。如果你更喜欢具象思维，可以看图： 或者可以看动图： 两次和多次的 lift() 同理，如下图： 举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考： 12345678910111213141516171819202122observable.lift(new Observable.Operator&lt;String, Integer&gt;() &#123; @Override public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) &#123; // 将事件序列中的 Integer 对象转换为 String 对象 return new Subscriber&lt;Integer&gt;() &#123; @Override public void onNext(Integer integer) &#123; subscriber.onNext("" + integer); &#125; @Override public void onCompleted() &#123; subscriber.onCompleted(); &#125; @Override public void onError(Throwable e) &#123; subscriber.onError(e); &#125; &#125;; &#125;&#125;); compose: 对 Observable 整体的变换除了 lift() 之外， Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable，并且他们都需要应用一组相同的 lift() 变换。你可以这么写： 123456789101112131415161718192021222324observable1 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber1);observable2 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber2);observable3 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber3);observable4 .lift1() .lift2() .lift3() .lift4() .subscribe(subscriber1); 你觉得这样太不软件工程了，于是你改成了这样： 123456789101112private Observable liftAll(Observable observable) &#123; return observable .lift1() .lift2() .lift3() .lift4();&#125;...liftAll(observable1).subscribe(subscriber1);liftAll(observable2).subscribe(subscriber2);liftAll(observable3).subscribe(subscriber3);liftAll(observable4).subscribe(subscriber4); 可读性、可维护性都提高了。可是 Observable 被一个方法包起来，这种方式对于 Observale 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 compose() 来解决了： 12345678910111213141516public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; &#123; @Override public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) &#123; return observable .lift1() .lift2() .lift3() .lift4(); &#125;&#125;...Transformer liftAll = new LiftAllTransformer();observable1.compose(liftAll).subscribe(subscriber1);observable2.compose(liftAll).subscribe(subscriber2);observable3.compose(liftAll).subscribe(subscriber3);observable4.compose(liftAll).subscribe(subscriber4); 像上面这样，使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call 方法直接对自身进行处理，也就不必被包在方法的里面了。compose() 的原理比较简单，不附图喽。 Buffer：缓存可以设置缓存大小，缓存满后，以list的方式将数据发送出去；例： 123456789Observable.just(1,2,3).buffer(2).subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() &#123; @Override public void call(List&lt;Integer&gt; list) &#123; Log.i("mytag","size:"+list.size()); &#125;&#125;); 运行打印结果如下： 111-02 20:49:58.370 23392-23392/? I/mytag: size:211-02 20:49:58.370 23392-23392/? I/mytag: size:1 在开发当中，个人经常将Buffer和Map一起使用，常发生在从后台取完数据，对一个List中的数据进行预处理后，再用Buffer缓存后一起发送，保证最后数据接收还是一个List，如下： 123456789101112List&lt;School&gt; schoolList = new ArrayList&lt;&gt;();Observable.from(schoolList).map(new Func1&lt;School, School&gt;() &#123; @Override public School call(School school) &#123; school.setName("NB大学"); //将所有学校改名 return school; &#125;&#125;).buffer(schoolList.size()) //缓存起来，最后一起发送.subscribe(new Action1&lt;List&lt;School&gt;&gt;() &#123; @Override public void call(List&lt;School&gt; schools) &#123;&#125;&#125;); Take发射前n项数据，还是用上面的例子，假设不要改所有学校的名称了，就改前四个学校的名称： 123456789Observable.from(schoolList).take(4).map(new Func1&lt;School, School&gt;() &#123; @Override public School call(School school) &#123; school.setName("NB大学"); return school; &#125;&#125;).buffer(4).subscribe(new Action1&lt;List&lt;School&gt;&gt;() &#123; @Override public void call(List&lt;School&gt; schools) &#123;&#125;&#125;); Distinct去掉重复的项，比较好理解： 123456Observable.just(1, 2, 1, 1, 2, 3).distinct().subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer item) &#123; System.out.println("Next: " + item); &#125; &#125;); 输出 1Next: 1Next: 2Next: 3 Filter：过滤通过谓词判断的项才会被发射，例如，发射小于4的数据： 1234567891011Observable.just(1, 2, 3, 4, 5).filter(new Func1&lt;Integer, Boolean&gt;() &#123; @Override public Boolean call(Integer item) &#123; return( item &lt; 4 ); &#125; &#125;).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer item) &#123; System.out.println("Next: " + item); &#125;&#125;); 输出： 1Next: 1Next: 2Next: 3 线程控制：Scheduler (二)除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。 Scheduler 的 API (二)前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map()``flatMap()等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？ 答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。上代码： 12345678Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定 .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .map(mapOperator) // 新线程，由 observeOn() 指定 .observeOn(Schedulers.io()) .map(mapOperator2) // IO 线程，由 observeOn() 指定 .observeOn(AndroidSchedulers.mainThread) .subscribe(subscriber); // Android 主线程，由 observeOn() 指定 如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。不过，不同于 observeOn() ， subscribeOn() 的位置放在哪里都可以，但它是只能调用一次的。又有好事的（其实还是当初的我）问了：如果我非要调用多次 subscribeOn() 呢？会有什么效果？这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。 Scheduler 的原理（二）其实， subscribeOn() 和 observeOn() 的内部实现，也是用的 lift()。具体看图（不同颜色的箭头表示不同的线程）：subscribeOn() 原理图： observeOn() 原理图： 从图中可以看出，subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn()的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响； 而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。 最后，我用一张图来解释当多个 subscribeOn() 和 observeOn() 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）： 图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。 延伸：doOnSubscribe()然而，虽然超过一个的 subscribeOn() 对事件处理的流程没有影响，但在流程之前却是可以利用的。 在前面讲 Subscriber 的时候，提到过 Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。 而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。 示例代码： 1234567891011Observable.create(onSubscribe) .subscribeOn(Schedulers.io()) .doOnSubscribe(new Action0() &#123; @Override public void call() &#123; progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行 &#125; &#125;) .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(subscriber); 如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。 Subject关于Subject，官方文档的解释是这样的：Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。从官方解释中，我提取出三个要点： 它可以充当Observable； 它可以充当Observer； 它是Observable和Observer之间的桥梁； 接下来对这三个要点解释一下，但在解释之前，要先介绍一下Subject的种类， Subject是一个抽象类，不能通过new来实例化Subject，所以Subject有四个实现类，分别为AsyncSubject、BehaviorSubject、PublishSubject和ReplaySubject，每个实现类都有特定的“技能”，下面结合代码来介绍一下它们各自的“技能”。注意，所有的实现类都由create()方法实例化，无需new,所有的实现类调用onCompleted()或onError(),它的Observer将不再接收数据； AsyncSubjectObserver会接收AsyncSubject的onComplete()之前的最后一个数据，如果因异常而终止，AsyncSubject将不会释放任何数据，但是会向Observer传递一个异常通知。示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344AsyncSubject&lt;String&gt; asyncSubject = AsyncSubject.create(); asyncSubject.onNext("asyncSubject1"); asyncSubject.onNext("asyncSubject2"); asyncSubject.onNext("asyncSubject3"); asyncSubject.onCompleted(); asyncSubject.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; LogUtil.log("asyncSubject onCompleted"); //输出 asyncSubject onCompleted &#125; @Override public void onError(Throwable e) &#123; LogUtil.log("asyncSubject onError"); //不输出（异常才会输出） &#125; @Override public void onNext(String s) &#123; LogUtil.log("asyncSubject:"+s); //输出asyncSubject:asyncSubject3 &#125; &#125;);``` 以上代码，Observer只会接收asyncSubject的onCompleted()被调用前的最后一个数据，即“asyncSubject3”，如果不调用onCompleted()，Subscriber将不接收任何数据。## BehaviorSubjectObserver会接收到BehaviorSubject被订阅之前的最后一个数据，再接收其他发射过来的数据，如果BehaviorSubject被订阅之前没有发送任何数据，则会发送一个默认数据。（注意跟AsyncSubject的区别，AsyncSubject要手动调用onCompleted()，且它的Observer会接收到onCompleted()前发送的最后一个数据，之后不会再接收数据，而BehaviorSubject不需手动调用onCompleted()，它的Observer接收的是BehaviorSubject被订阅前发送的最后一个数据，两个的分界点不一样，且之后还会继续接收数据。）示例代码如下：```javaBehaviorSubject&lt;String&gt; behaviorSubject = BehaviorSubject.create("default"); behaviorSubject.onNext("behaviorSubject1"); behaviorSubject.onNext("behaviorSubject2"); behaviorSubject.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; LogUtil.log("behaviorSubject:complete"); &#125; @Override public void onError(Throwable e) &#123; LogUtil.log("behaviorSubject:error"); &#125; @Override public void onNext(String s) &#123; LogUtil.log("behaviorSubject:"+s); &#125;&#125;); behaviorSubject.onNext("behaviorSubject3"); behaviorSubject.onNext("behaviorSubject4"); 以上代码，Observer会接收到behaviorSubject2、behaviorSubject3、behaviorSubject4，如果在behaviorSubject.subscribe()之前不发送behaviorSubject1、behaviorSubject2，则Observer会先接收到default,再接收behaviorSubject3、behaviorSubject4。 PublishSubjectPublishSubject比较容易理解，相对比其他Subject常用，它的Observer只会接收到PublishSubject被订阅之后发送的数据。示例代码如下： 123456789101112131415PublishSubject&lt;String&gt; publishSubject = PublishSubject.create(); publishSubject.onNext("publishSubject1"); publishSubject.onNext("publishSubject2"); publishSubject.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; LogUtil.log("publishSubject observer1:"+s); &#125; &#125;); publishSubject.onNext("publishSubject3"); publishSubject.onNext("publishSubject4"); 以上代码，Observer只会接收到”behaviorSubject3”、”behaviorSubject4”。 ReplaySubjectReplaySubject会发射所有数据给观察者，无论它们是何时订阅的。也有其它版本的ReplaySubject，在重放缓存增长到一定大小的时候或过了一段时间后会丢弃旧的数据。示例代码如下： 12345678910111213141516ReplaySubject&lt;String&gt;replaySubject = ReplaySubject.create(); //创建默认初始缓存容量大小为16的ReplaySubject，当数据条目超过16会重新分配内存空间，使用这种方式，不论ReplaySubject何时被订阅，Observer都能接收到数据//replaySubject = ReplaySubject.create(100);//创建指定初始缓存容量大小为100的ReplaySubject//replaySubject = ReplaySubject.createWithSize(2);//只缓存订阅前最后发送的2条数据 //replaySubject=ReplaySubject.createWithTime(1,TimeUnit.SECONDS,Schedulers.computation()); //replaySubject被订阅前的前1秒内发送的数据才能被接收 replaySubject.onNext("replaySubject:pre1");replaySubject.onNext("replaySubject:pre2");replaySubject.onNext("replaySubject:pre3");replaySubject.subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; LogUtil.log("replaySubject:" + s); &#125; &#125;);replaySubject.onNext("replaySubject:after1");replaySubject.onNext("replaySubject:after2"); 以上代码，由于情况比较多，注释也已解释的相当清楚，就不对输出结果一一表述了，有疑问的自行copy代码去测试一下。至此，四种Subject类型已经介绍完毕，但是需要注意，如果你把 Subject 当作一个 Subscriber 使用，不要从多个线程中调用它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。要避免此类问题，官方提出了“串行化”，你可以将 Subject 转换为一个 SerializedSubject ，类似于这样：SerializedSubject&lt;String, Integer&gt; ser = new SerializedSubject(publishSubject); Subject总结为什么说Subject既可充当Observable，又可充当Observer，是它们两个之间的桥梁呢？经过前面的例子，也许有些人已经大概理解了，不理解的且听我细细道来。首先，从理论上讲，Subject继承了Observable，又实现了Observer接口，所以说它既是Observable又是Observer，完全合理。从实际应用上讲，Subject也能实现Observable和Observer相同的功能，口说无凭，我们还是通过代码来证实比较有说服力。 创建Observable并发射数据：1Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("I'm Observable"); subscriber.onCompleted(); &#125; &#125;); 用Subject实现为： 1PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();publishSubject.onNext("as Observable");publishSubject.onCompleted(); 创建Observer订阅Observable并接收数据：123456789mObservable.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(String s) &#123;//接收数据 &#125;&#125;); 用Subject实现为： 12345678publishSubject.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(String s) &#123;&#125; &#125;); 也许有人会问，不是说Subject也可以作为Observer，不能把Subject当作Observer传入subscribe()中吗？回答是：当然可以！就象这样： 12345678PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("as Observer"); subscriber.onCompleted(); &#125;&#125;).subscribe(publishSubject); 有没有发现问题？publishSubject没有重写onNext()方法啊，在哪接收的数据？这就是前面说的“桥梁”的问题了，尽管把Subject作为Observer传入subscribe()，但接收数据还是要通过Observer来接收，借用Subject来连接Observable和Observer，整体代码如下： 123456789101112131415161718PublishSubject&lt;String&gt; publishSubject = PublishSubject.create(); Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("as Bridge"); subscriber.onCompleted(); &#125; &#125;).subscribe(publishSubject); publishSubject.subscribe(new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123;&#125; @Override public void onError(Throwable e) &#123;&#125; @Override public void onNext(String s) &#123; LogUtil.log("subject:"+s); //接收到 as Bridge &#125; &#125;); RxJava 的适用场景和使用方式与 Retrofit 的结合Retrofit 除了提供了传统的 Callback 形式的 API，还有 RxJava 版本的 Observable 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。以获取一个 User对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求： 12@GET("/user")public void getUser(@Query("userId") String userId, Callback&lt;User&gt; callback); 在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应： 123456789101112getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 而使用 RxJava 形式的 API，定义同样的请求是这样的： 12@GET("/user")public Observable&lt;User&gt; getUser(@Query("userId") String userId); 使用的时候是这样的： 123456789101112131415161718getUser(userId) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 看到区别了吗？ 当 RxJava 形式的时候，Retrofit 把请求封装进 Observable ，在请求结束后调用 onNext() 或在请求失败后调用 onError()。 对比来看， Callback 形式和 Observable 形式长得不太一样，但本质都差不多，而且在细节上 Observable 形式似乎还比 Callback形式要差点。那 Retrofit 为什么还要提供 RxJava 的支持呢？ 因为它好用啊！从这个例子看不出来是因为这只是最简单的情况。而一旦情景复杂起来， Callback 形式马上就会开始让人头疼。比如：假设这么一种情况：你的程序取到的 User 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 Callback方式大概可以这么写： 12345678910111213getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; processUser(user); // 尝试修正 User 数据 userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 有问题吗？ 很简便，但不要这样做。为什么？因为这样做会影响性能。数据库的操作很重，一次读写操作花费 10~20ms 是很常见的，这样的耗时很容易造成界面的卡顿。所以通常情况下，如果可以的话一定要避免在主线程中处理数据库。所以为了提升性能，这段代码可以优化一下： 12345678910111213141516171819202122getUser(userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; new Thread() &#123; @Override public void run() &#123; processUser(user); // 尝试修正 User 数据 runOnUiThread(new Runnable() &#123; // 切回 UI 线程 @Override public void run() &#123; userView.setUser(user); &#125; &#125;); &#125;).start(); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;; 性能问题解决，但……这代码实在是太乱了，迷之缩进啊！杂乱的代码往往不仅仅是美观问题，因为代码越乱往往就越难读懂，而如果项目中充斥着杂乱的代码，无疑会降低代码的可读性，造成团队开发效率的降低和出错率的升高。 这时候，如果用 RxJava 的形式，就好办多了。 RxJava 形式的代码是这样的： 1234567891011121314151617181920212223getUser(userId) .doOnNext(new Action1&lt;User&gt;() &#123; @Override public void call(User user) &#123; processUser(user); &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 后台代码和前台代码全都写在一条链中，明显清晰了很多。 再举一个例子：假设 /user 接口并不能直接访问，而需要填入一个在线获取的 token，代码应该怎么写？Callback 方式，可以使用嵌套的 Callback： 12345678910111213141516171819202122232425262728293031@GET("/token")public void getToken(Callback&lt;String&gt; callback);@GET("/user")public void getUser(@Query("token") String token, @Query("userId") String userId, Callback&lt;User&gt; callback);...getToken(new Callback&lt;String&gt;() &#123; @Override public void success(String token) &#123; getUser(token, userId, new Callback&lt;User&gt;() &#123; @Override public void success(User user) &#123; userView.setUser(user); &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125; &#125;; &#125; @Override public void failure(RetrofitError error) &#123; // Error handling ... &#125;&#125;); 倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。而使用 RxJava 的话，代码是这样的： 12345678910111213141516171819202122232425262728293031@GET("/token")public Observable&lt;String&gt; getToken();@GET("/user")public Observable&lt;User&gt; getUser(@Query("token") String token, @Query("userId") String userId);...getToken() .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123; @Override public Observable&lt;User&gt; onNext(String token) &#123; return getUser(token, userId); &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;User&gt;() &#123; @Override public void onNext(User user) &#123; userView.setUser(user); &#125; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable error) &#123; // Error handling ... &#125; &#125;); 用一个 flatMap() 就搞定了逻辑，依然是一条链。看着就很爽，是吧？ RxBindingRxBinding 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 OnClickListener 、设置 TextWatcher 这样的注册绑定对象的 API。 举个设置点击监听的例子。使用 RxBinding ，可以把事件监听用这样的方法来设置： 12345678Button button = ...;RxView.clickEvents(button) // 以 Observable 形式来反馈点击事件 .subscribe(new Action1&lt;ViewClickEvent&gt;() &#123; @Override public void call(ViewClickEvent event) &#123; // Click handling &#125; &#125;); 看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 setOnClickListener() 来实现的。然而，仅仅这一个形式的改变，却恰好就是 RxBinding 的目的：扩展性。通过 RxBinding 把点击监听转换成 Observable 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 throttleFirst() ，用于去抖动，也就是消除手抖导致的快速连环点击： 123RxView.clickEvents(button) .throttleFirst(500, TimeUnit.MILLISECONDS) .subscribe(clickAction); 如果想对 RxBinding 有更多了解，可以去它的 GitHub 项目 下面看看。 各种异步操作前面举的 Retrofit 和 RxBinding 的例子，是两个可以提供现成的 Observable 的库。而如果你有某些异步操作无法用这些库来自动生成 Observable，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现，有了之前几章的例子，这里应该不用再举例了。 RxBusRxBus 名字看起来像一个库，但它并不是一个库，而是一种模式，它的思想是使用 RxJava 来实现了 EventBus ，而让你不再需要使用 Otto 或者 GreenRobot 的 EventBus。至于什么是 RxBus，可以看 这篇文章 。顺便说一句，Flipboard 已经用 RxBus 替换掉了 Otto ，目前为止没有不良反应。 参考给 Android 开发者的 RxJava 详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Fresco详细学习]]></title>
      <url>%2F2017%2F07%2F10%2Fandroid-fresco%2F</url>
      <content type="text"><![CDATA[Android Fresco网络图片加载库Fresco是Facebook最新推出的一款用于Android应用中展示图片的强大图片库，可以从网络、本地存储和本地资源中加载图片。相对于ImageLoader，拥有更快的图片下载速度以及可以加载和显示gif图等诸多优势，是个很好的图片框架。 github地址： https://github.com/facebook/fresco 基本的用法： 导入 Android Studio 或者 Gradle 123dependencies &#123; compile &apos;com.facebook.fresco:fresco:0.9.0+&apos;&#125; 在xml中引入SimpleDraweeView 123456&lt;com.facebook.drawee.view.SimpleDraweeView android:id="@+id/image_view" android:layout_width="20dp" android:layout_height="20dp" fresco:placeholderImage="@drawable/my_drawable" /&gt; 注意：1、在SimpleDraweeView的父控件或者根节点中配置xmlns:fresco=”http://schemas.android.com/apk/res-auto“; 配置网络权限 在Java代码中开始加载图片123Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/fresco-logo.png&quot;);SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);draweeView.setImageURI(uri); URIs的使用 类型 Scheme 示例 远程图片 http:// 和 https:// HttpURLConnection 或者参考 使用其他网络加载方案 本地文件 file:// FileInputStream Content Provider content:// ContentResolver asset目录下的资源 asset:// AssetManager res目录下的资源 res:// Resources.openRawResource res 示例:Uri uri = Uri.parse(“res://包名(实际可以是任何字符串甚至留空)/“ + R.drawable.ic_launcher); 注意：Fresco 不支持 相对路径的URI. 所有的URI都必须是绝对路径，并且带上该URI的scheme。 在XML中使用SimpleDraweeView12345678910111213141516171819202122232425262728&lt;com.facebook.drawee.view.SimpleDraweeView android:id="@+id/my_image_view" android:layout_width="20dp" android:layout_height="20dp" fresco:fadeDuration="300" // 淡入淡出的持续时间 fresco:actualImageScaleType="focusCrop" // 实际图像的缩放类型 fresco:placeholderImage="@color/wait_color" //占位图 fresco:placeholderImageScaleType="fitCenter" //占位图的缩放类型 fresco:failureImage="@drawable/error" //下载失败显示的图片 fresco:failureImageScaleType="centerInside" //失败图的缩放类型 fresco:retryImage="@drawable/retrying" //图片加载失败时显示，提示用户点击重新加载，重复加载4次还是没有加载出来的时候才会显示failureImage的图片 fresco:retryImageScaleType="centerCrop" //重新加载的图片缩放类型 fresco:progressBarImage="@drawable/progress_bar" //进度条图片 fresco:progressBarImageScaleType="centerInside" fresco:progressBarAutoRotateInterval="1000" //进度图自动旋转间隔时间(单位：毫秒ms) fresco:backgroundImage="@color/blue" //背景图片，这里的背景图片首先被绘制 fresco:overlayImage="@drawable/watermark" // 设置叠加图，在xml中只能设置一张叠加图片，如果需要多张图片的话，需要在java代码中设置哦 fresco:pressedStateOverlayImage="@color/red" // 设置点击状态下的叠加图 fresco:roundAsCircle="false" //设置为圆形图 fresco:roundedCornerRadius="1dp" // 圆角半径 fresco:roundTopLeft="true" // 左上角是否为圆角 fresco:roundTopRight="false" fresco:roundBottomLeft="false" fresco:roundBottomRight="true" fresco:roundWithOverlayColor="@color/corner_color" fresco:roundingBorderWidth="2dp" //边框的宽度 fresco:roundingBorderColor="@color/border_color" //边框颜色 /&gt; 说明：必须声明 android:layout_width 和 android:layout_height，否则将无法正确加载图像，另外不支持 wrap_content 属性，但也有例外的时候，如果想固定控件的宽高比，则可以使用wrap_content,并通过在xml代码中设置fresco:viewAspectRatio=”小数”或者在Java代码中设置mSimpleDraweeView.setAspectRatio(1.33f);即可。 类型 描述 center 居中，无缩放 centerCrop 保持宽高比缩小或放大，是的两边都大于或等于边界，且宽和高契合显示边界，居中显示 focusCrop 同centerCrop，但居中点不是中点，而是指定的某个点 centerInside 缩放图片使两边都在显示边界内，居中显示。和fitCenter不同，不会对图片进行放大。如果尺寸大于显示边界，则保持宽高比例缩小图片。 fitCenter 保持宽高比，缩小或者放大，使得图片完全显示在显示边界内，且宽或高契合显示边界，居中显示。 fitStart 同上，但不居中，和显示边界左上对齐。 fitEnd 同fitCenter，但不居中，和显示边界右下对齐。 fitXY 不保存宽高比，填充满显示边界。 none 如果要使用tile mode显示，则需要设置为none 在Java中自定义显示图一般情况下，在XML设置显示效果即可, 如果想更多定制化，可以这样:创建一个 builder 然后设置给 SimpleDraweeView: 1234567891011List&lt;Drawable&gt; backgroundsList;List&lt;Drawable&gt; overlaysList;GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources());GenericDraweeHierarchy hierarchy = builder .setFadeDuration(300) .setPlaceholderImage(new MyCustomDrawable()) .setBackgrounds(backgroundList) .setOverlays(overlaysList) .build();mSimpleDraweeView.setHierarchy(hierarchy); 注意：请不要多次调用setHierarchy，即使这个View是可回收的。创建 DraweeHierarchy 的较为耗时的一个过程，应该多次利用。 修改 DraweeHierarchyDraweeHierarchy 的一些属性可以在运行时改变。要改变这些属性，首先获取一个引用:GenericDraweeHierarchy hierarchy = mSimpleDraweeView.getHierarchy(); 修改占位图修改占位图为资源id:hierarchy.setPlaceholderImage(R.drawable.placeholderId);或者修改为一个 Drawable:Drawable drawable;hierarchy.setPlaceholderImage(drawable); 改变图像的显示修改缩放类型:hierarchy.setActualImageScaleType(ScalingUtils.ScaleType.CENTER_INSIDE);如果你选择缩放类型为 focusCrop，需要指定一个居中点:hierarchy.setActualImageFocusPoint(point);你可以为图像添加一个 color filter:ColorFilter filter;// 创建filterhierarchy.setActualImageColorFilter(filter); 圆角除了圆角显示方式（原来为圆角的不能修改为圆圈，反之亦然），其他圆角相关的呈现参数, 具体参见这里 是可以动态修改的。如下: 获取DraweeHierarchy的圆角显示参数，修改圆角半径为10。RoundingParams roundingParams = hierarchy.getRoundingParams();roundingParams.setCornersRadius(10);hierarchy.setRoundingParams(roundingParams);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-AppBarLayout&CollapsingToolbar&Toolbar组合使用]]></title>
      <url>%2F2017%2F07%2F02%2Fandroid-appbarlayout-collapsingtoolbar-toolbar%2F</url>
      <content type="text"><![CDATA[ToolbarToobar主要是用来替换ActionBar的，换句话说，ActionBar能做的，Toolbar都能做。如果你对ActionBar的使用比较熟悉，你会发现Toolbar使用起来非常简单。ok，既然是替换，当然用Toolbar的时候就得先去把ActionBar给隐藏掉啦~ 隐藏ActionBar的方法有很多，可以通过代码的方式隐藏，也可以通过配置文件的方式，我们主要是通过配置文件的方式来隐藏。在我们的styles.xml文件中的AppTheme标签中加入如下两行： 12&lt;item name="windowActionBar"&gt;false&lt;/item&gt;&lt;item name="windowNoTitle"&gt;true&lt;/item&gt; 当然了，你也可以新建一个&lt;style&gt;标签，将上面两行代码加入，并且将这个新建的标签作为&lt;application&gt;的theme。还可以选择通过将AppTheme的parent设置为Theme.AppCompat.Light.NoActionBar的方式。方法很多，可以自己随便选。接下来就是将Toolbar放入到布局文件（没啥好解释的）： 12345&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:background="?attr/colorPrimary" android:layout_height="?android:attr/actionBarSize" /&gt; 最后将Toobar作为ActionBar来用 12345Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); toolbar.setTitle("这里是Title"); toolbar.setSubtitle("这里是子标题"); toolbar.setLogo(R.drawable.icon); setSupportActionBar(toolbar); 可以对Toolbar设置Logo、标题、子标题等等~还有很多其他的设置，自己去慢慢玩，这里不提啦~。当然了，也可以在布局文件中设置这些，在布局文件设置就不写啦。如果Toolbar仅仅是用来对以往的ActionBar做一次替换，那也太没创意啦！完全没必要去替换了，因为它们表现出来的都是一样的，而且并没有让我们觉得用起来比ActionBar方便。那为啥要替换呢，总应该有他的理由吧：ActionBar是固定在顶部，并不能移动，我觉得这是最大的不好，而我们的ToolBar可以让我们随便摆放，就就可以带来很多灵活性和效果啦！ 的确Toolbar根本就不够看的，一点都不复杂。接下来我们继续学习在Toolbar上面再套一层父View，让Toolbar更有互动性。 ToolBar中包含Nav Icon , Logo , Title , Sub Title , Menu Items 。我们可以通过代码设置上述ToolBar中的控件： 123456789101112131415161718@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.id_toolbar); // App Logo toolbar.setLogo(R.mipmap.ic_launcher); // Title toolbar.setTitle("App Title"); // Sub Title toolbar.setSubtitle("Sub title"); setSupportActionBar(toolbar); //Navigation Icon toolbar.setNavigationIcon(R.drawable.ic_toc_white_24dp);&#125; 可选方案当然如果你喜欢，也可以在布局文件中去设置部分属性： 123456789&lt;android.support.v7.widget.Toolbar android:id="@+id/id_toolbar" app:title="App Title" app:subtitle="Sub Title" app:navigationIcon="@drawable/ic_toc_white_24dp" android:layout_height="wrap_content" android:minHeight="?attr/actionBarSize" android:layout_width="match_parent" android:background="?attr/colorPrimary"/&gt; 至于Menu Item，依然支持在menu/menu_main.xml去声明，然后复写onCreateOptionsMenu和onOptionsItemSelected即可。 可选方案也可以通过toolbar.setOnMenuItemClickListener实现点击MenuItem的回调。 123456toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; return false; &#125;&#125;); 关于字体的样式，可以在布局文件设置属性app:titleTextAppearance、app:subtitleTextAppearance或者代码setTitleTextAppearance、setSubTitleTextAppearance设置。 layout_scrollFlags根据官方文档，layout_scrollFlags的取值可以为以下几种。 scroll设成这个值的效果就好比本View和scrolling view是“一体”的。具体示例我们在上面已经给出。有一点特别需要我们的注意，为了其他的滚动行为生效，必须同时指定scroll和相应的标记，比如我们想要exitUntilCollapsed所表现的滚动行为，必须将layout_scrollFlags指定为“scroll|exitUntilCollapsed”。 exitUntilCollapsed当本View离开屏幕时，会被“折叠”直到达到其最小高度。我们可以这样理解这个效果：当我们开始向上滚动scrolling view时，本View会先接管滚动事件，这样本View会先进行滚动，直到滚动到了最小高度（折叠了），scrolling view才开始实际滚动。而当本View已完全折叠后，再向下滚动scrolling view，直到scrolling view顶部的内容完全显示后，本View才会开始向下滚动以显现出来。 enterAlways当scrolling view向下滚动时，本View会一起跟着向下滚动。实际上就好比我们同时对scrolling view和本View进行向下滚动，与exitUntilCollapsed不同，当scrolling view一开始滚动，ToolBar便已开始跟着滚动，而无需scrolling view将其内容滚动到顶部。 enterAlwaysCollapsed从名字上就可以看出，这是在enterAlways的基础上，加上了“折叠”的效果。当我们开始向下滚动scrolling view时，本View会一起跟着滚动直到达到其“折叠高度”（即最小高度）。然后当scrolling view滚动至顶部内容完全显示后，再向下滚动scrolling view，本View会继续滚动到完全显示出来。需要把layout_scrollFlags指定为“scroll|enterAlways|enterAlwaysCollapsed”。 snap在一次滚动结束时，本View很可能只处于“部分显示”的状态，加上这个标记能够达到“要么完全隐藏，要么完全显示”的效果。到了这里，我们就把AppBarLayout能够实现的滚动行为介绍完毕了，很简单有木有。 AppBarLayout AppBarLayout继承自LinearLayout，布局方向为垂直方向。所以你可以把它当成垂直布局的LinearLayout来使用。AppBarLayout是在LinearLayou上加了一些材料设计的概念，它可以让你定制当某个可滚动View的滚动手势发生变化时，其内部的子View实现何种动作。 请注意：上面提到的某个可滚动View，可以理解为某个ScrollView。怎么理解上面的话呢？就是说，当某个ScrollView发生滚动时，你可以定制你的“顶部栏”应该执行哪些动作（如跟着一起滚动、保持不动等等）。那某个可移动的View到底是哪个可移动的View呢？这是由你自己指定的！如何指定，我们后面说。 AppBarLayout子View的动作内部的子View通过在布局中加app:layout_scrollFlags设置执行的动作，那么app:layout_scrollFlags可以设置哪些动作呢？分别如下： （1）scroll:值设为scroll的View会跟随滚动事件一起发生移动。什么意思呢？简单的说，就是当指定的ScrollView发生滚动时，该View也跟随一起滚动，就好像这个View也是属于这个ScrollView一样。 1234567891011&lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?android:attr/actionBarSize" android:background="?attr/colorPrimary" app:layout_scrollFlags="scroll" /&gt;&lt;/android.support.design.widget.AppBarLayout&gt; （2）enterAlways:值设为enterAlways的View,当ScrollView往下滚动时，该View会直接往下滚动。而不用考虑ScrollView是否在滚动。ToolBar高度设为：（?android:attr/actionBarSize）app:layout_scrollFlags=&quot;scroll|enterAlways&quot; （3） exitUntilCollapsed：值设为exitUntilCollapsed的View，当这个View要往上逐渐“消逝”时，会一直往上滑动，直到剩下的的高度达到它的最小高度后，再响应ScrollView的内部滑动事件。怎么理解呢？简单解释：在ScrollView往上滑动时，首先是View把滑动事件“夺走”，由View去执行滑动，直到滑动最小高度后，把这个滑动事件“还”回去，让ScrollView内部去上滑。看个gif感受一下 ,图中将高度设的比较大:200dp，并将最小高度设置为（?android:attr/actionBarSize）app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; （4） enterAlwaysCollapsed：是enterAlways的附加选项，一般跟enterAlways一起使用，它是指，View在往下“出现”的时候，首先是enterAlways效果，当View的高度达到最小高度时，View就暂时不去往下滚动，直到ScrollView滑动到顶部不再滑动时，View再继续往下滑动，直到滑到View的顶部结束。图中将高度设的比较大:200dp，并将最小高度设置为?android:attr/actionBarSize,app:layout_scrollFlags=&quot;scroll|enerAlways|enterAlwaysCollapsed&quot; 将AppBarLayout与ScrollView关联起来前面说了一直反复说“当ScrollView发生滚动时”，那么怎么将AppBarLayout与ScrollView关联起来呢？我们注意到，AppBarLayout与ScrollView之间动作“相互依赖”，把ScrollView和AppBarLayout作为CoordinateLayout的子View，然后编写一个Behavior，在这个Behavior里面判断当前的操作是应该让ScrollView时刻保持在AppBarLayout之下（即只要改变AppBarLayout的位置就可以一起滑动），还是应该让ScrollView内部滚动而不让AppBarLayout位置发生变化等等这些需求，都是可以在Behavior里面处理的。你可以去针对你的ScrollView编写Behavior。然而，我们看到我们的AppBarLayout事先的功能比较复杂，如果我们自己去定义这样的效果，代码非常复杂，还要考虑很多方面，好在Android帮我们写好啦，我们直接用就是了，这个ScrollView就是NestedScrollView，请注意，它并没有继承ScrollView，它继承的是FrameLayout，但是它实现的效果把它可以看成是ScrollView。 把NestedScrollView放入到我们的layout文件里面就可以啦~~~，很方便~ 123456789&lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;!--将你的内容放在这里--&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; 有没有注意到有个属性：app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;,它就是指定Behavior的，appbar_scrolling_view_behavior对应的类的名称是：android.support.design.widget.AppBarLayout$ScrollingViewBehavior感兴趣的可以去分析源码。好了，我们现在会用AppBarLayout啦~是不是发现用起来so easy!接下来我们把剩下CollapsingToolbarLayout的给”消化”掉！ XML 布局123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/coordinator&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/appbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?android:attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll&quot; /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;WebView android:id=&quot;@+id/web_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/WebView&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 在上面的布局文件中，NestedScrollView充当了scrolling view的角色，实际上scrolling view需要支持嵌套滚动，通常我们使用NestedScrollView、RecyclerView等已经实现了嵌套滚动的UI控件。 CoordinatorLayout在学习CoordinatorLayout之前，很有必要了解CoordinatorLayout能帮我们做什么，从名字上可以看出，就是帮我们协调子View的。怎么个协调法呢?就是它根据我们的定制，帮助我们协调各个子View的布局。 稍微解释一下这个动画，蓝色的矩形是我们一个普通View，黄色的Hello是一个Button。我们水平拖动蓝色矩形时，黄色Button查着与蓝色矩形相反方向移动；竖直移动蓝色矩形时，黄色也跟着竖直。简而言之：它们在竖直方向同步移动，在水平方向相反。这个效果如果让你不用CoordinatorLayout去实现，应该没有任何问题，但是代码的耦合度应该非常大，你的代码必须要持有2个View的引用，然后在onTouchEvent里面做各种判断。如果我们想要实现的功能是，有更多的View要根据蓝色的View的移动相应作出响应，那么那就得在蓝色View的onTounchEvent里面针对其他的View处理各种逻辑。这耦合度未免太伤感了~而CoordinatorLayout既然号称能帮我们协调子View的布局，我们接下来看看CoordinatorLayout如何实现~ CoordinatorLayout使用CoordinatorLayout的使用核心是Behavior，Behavior就是执行你定制的动作。在讲Behavior之前必须先理解两个概念：Child和Dependency，什么意思呢？Child当然是子View的意思了，是谁的子View呢，当然是CoordinatorLayout的子View；其实Child是指要执行动作的CoordinatorLayout的子View。而Dependency是指Child依赖的View。比如上面的gif图中，蓝色的View就是Dependency，黄色的View就是Child，因为黄色的View的动作是依赖于蓝色的View。简而言之，就是如过Dependency这个View发生了变化，那么Child这个View就要相应发生变化。发生变化是具体发生什么变化呢？这里就要引入Behavior，Child发生变化的具体执行的代码都是放在Behavior这个类里面。怎么使用Behavior呢，首先，我们定义一个类，继承CoordinatorLayout.Behavior&lt;T&gt;,其中，泛型参数T是我们要执行动作的View类，也就是Child。然后就是去实现Behavior的两个方法： 1234567891011121314151617181920/*** 判断child的布局是否依赖dependency*/ @Override public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) &#123; boolean rs; //根据逻辑判断rs的取值 //返回false表示child不依赖dependency，ture表示依赖 return rs; &#125;/*** 当dependency发生改变时（位置、宽高等），执行这个函数* 返回true表示child的位置或者是宽高要发生改变，否则就返回false*/@Overridepublic boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) &#123; //child要执行的具体动作 return true;&#125; 有了上面的概念后，我们看看具体怎么去实现吧~ 为了响应跟随手指移动的操作，我们定义一个非常简单的View，这个View只响应跟随手指移动，将这个View作为Dependency。由于过于简单，这个View源码不粘贴，我们只需知道这个View的类名叫：TempView。 我们看看Behavior的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.hc.studyCoordinatorLayout;import android.content.Context;import android.support.design.widget.CoordinatorLayout;import android.util.AttributeSet;import android.util.DisplayMetrics;import android.view.View;import android.widget.Button;/** * Package com.hc.studyCoordinatorLayout * Created by HuaChao on 2016/6/1. */public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; &#123; private int width; public MyBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); DisplayMetrics display = context.getResources().getDisplayMetrics(); width = display.widthPixels; &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) &#123; //如果dependency是TempView的实例，说明它就是我们所需要的Dependency return dependency instanceof TempView; &#125; //每次dependency位置发生变化，都会执行onDependentViewChanged方法 @Override public boolean onDependentViewChanged(CoordinatorLayout parent, Button btn, View dependency) &#123; //根据dependency的位置，设置Button的位置 int top = dependency.getTop(); int left = dependency.getLeft(); int x = width - left - btn.getWidth(); int y = top; setPosition(btn, x, y); return true; &#125; private void setPosition(View v, int x, int y) &#123; CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams) v.getLayoutParams(); layoutParams.leftMargin = x; layoutParams.topMargin = y; v.setLayoutParams(layoutParams); &#125;&#125; OK，现在我们为Button类指定了Dependency，并且定义好了跟随Dependency一直变化的动作（Behavior），接下来我们就要指定好为哪个具体的Button实例来绑定这些。方法很简单，直接在布局文件指定就好： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.hc.studyCoordinatorLayout.MainActivity"&gt; &lt;Button android:id="@+id/btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="300dp" android:layout_marginTop="300dp" android:background="#FFCC00" android:text="Hello" app:layout_behavior="com.hc.studyCoordinatorLayout.MyBehavior" /&gt; &lt;com.hc.studyCoordinatorLayout.TempView android:layout_width="100dp" android:layout_height="100dp" android:layout_marginLeft="300dp" android:layout_marginTop="300dp" android:background="#3366CC" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 是不是很简单呢？我们只需关注Behavior的编写就好了，把Child和Dependency之间的关系完全解耦了~ CollapsingToolbarLayoutCollapsingToolbarLayout是用来对Toolbar进行再次包装的ViewGroup，主要是用于实现折叠（其实就是看起来像伸缩~）的App Bar效果。它需要放在AppBarLayout布局里面，并且作为AppBarLayout的直接子View。CollapsingToolbarLayout主要包括几个功能（参照了官方网站上内容，略加自己的理解进行解释）： (1) Collasping title（可折叠标题）：当布局完全可见时，这个标题比较大；当折叠起来时，标题也会变小。标题的外观可以通过expandedTextAppearance和collapsedTextAppearance属性来调整。(2) Content scrim（内容纱布）：根据CollapsingToolbarLayout是否滚动到一个临界点，内容纱布会显示或隐藏。可以通过setContentScrim(Drawable)来设置内容纱布。(3) Status bar scrim（状态栏纱布）：也是根据是否滚动到临界点，来决定是否显示。可以通过setStatusBarScrim(Drawable)方法来设置。这个特性只有在Android5.0及其以上版本，我们设置fitSystemWindows为ture时才能生效。(4) Parallax scrolling children（视差滚动子View）：子View可以选择以“视差”的方式来进行滚动。（视觉效果上就是子View滚动的比其他View稍微慢些）(5) Pinned position children：子View可以选择固定在某一位置上。子View可以选择是否在全局空间上固定位置，这对于Toolbar来说非常有用，因为当布局在移动时，可以将Toolbar固定位置而不受移动的影响。 将app:layout_collapseMode设为pin。了解这些概念后，我们来看看布局吧~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width="match_parent" android:layout_height="wrap_content" app:expandedTitleMarginEnd="64dp" app:expandedTitleMarginStart="48dp" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:id="@+id/main.backdrop" android:layout_width="wrap_content" android:layout_height="300dp" android:scaleType="centerCrop" android:src="@drawable/material_img" app:layout_collapseMode="parallax" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?android:attr/actionBarSize" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="wrap_content" android:paddingTop="50dp" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/my_txt" android:textSize="20sp" /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 上面的都看得懂吧，每个陌生的属性都是讲过的哦，忘记了的话回头看，稍微解释一下，图片被设置为有视差的滑动，Toolbar设置为固定不动，另外，CollapsingToolbarLayout会对title进行放大和缩小，我们看看效果吧~ 如果你希望拖动过程中状态栏是透明的，可以在CollapsingToolbarLayout中加 app:statusBarScrim=&quot;@android:color/transparent&quot;，并且在onCreate中调用getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS)将状态栏设置为透明就好啦~ XML布局文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/coordinator" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/app_bar" android:layout_width="match_parent" android:layout_height="256dp" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" app:expandedTitleMarginEnd="50dp" app:expandedTitleMarginStart="50dp" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:src="@mipmap/ic_launcher" android:id="@+id/image" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" app:layout_collapseMode="parallax" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;WebView android:id="@+id/web_view" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;/WebView&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 我们在XML文件中为CollapsingToolbarLayout的layout_scrollFlags指定为“scroll|exitUntilCollapsed”，这样便实现了向上滚动scrolling view时的折叠效果。CollapsingToolbarLayout本质上是一个FrameLayout。我们在布局文件中为它指定了两个子View，分别是ImageView和Toolbar。ImageView的layout_collapseMode属性设为了parallax，也就是我们前面介绍的视差滚动；而Toolbar的layout_collaspeMode设为了pin，也就是Toolbar会始终固定在顶部。 contentScrim在上图中，我们看到Toolbar的背景一直都是我们指定的图片，即时图片向上滚动到消失后也是这样。那么可不可以让图片完全消失后，Toolbar显示一个另外的背景呢？答案是肯定的，只要使用我们上面提到的“内容纱布”即可。还记得我们上面关于内容纱布的介绍吗？当CollapsingToolbarLayout滚动到一个临界位置，内容纱布就会显现出来，我们通过一个例子感受下。当CollapsingToolbarLayout完全折叠后，ToolBar的背景变为了黑色，好像盖上了一层布，所以这个属性叫做“内容纱布”。这里我们发现，只有CollapsingToolbarLayout滚动到折叠后，内容纱布才显现出来，也就是说，默认的临界位置就是滚动到折叠。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-DialogFragment详细学习]]></title>
      <url>%2F2017%2F06%2F30%2Fandroid-dialogfragment%2F</url>
      <content type="text"><![CDATA[DialogFragment 设置全屏方法方法一12345@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setStyle(STYLE_NO_FRAME, android.R.style.Theme_Holo_Light);&#125; 方法二style 1234567891011121314&lt;style name="style_dialog" parent="android:style/Theme.Dialog"&gt; &lt;item name="android:windowBackground"&gt;@color/white&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowIsFloating"&gt;true&lt;/item&gt; &lt;item name="android:windowContentOverlay"&gt;@null&lt;/item&gt; &lt;item name="android:scrollHorizontally"&gt;true&lt;/item&gt; &lt;!-- Dialog进入及退出动画 --&gt; &lt;item name="android:windowAnimationStyle"&gt;@style/BottomToTopAnim&lt;/item&gt;&lt;/style&gt;&lt;style name="BottomToTopAnim" parent="android:Animation"&gt; &lt;item name="@android:windowEnterAnimation"&gt;@anim/bottom_in&lt;/item&gt; &lt;item name="@android:windowExitAnimation"&gt;@anim/bottom_out&lt;/item&gt;&lt;/style&gt; bottom_in bottom_out 进入进出动画 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;translate xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" android:fromYDelta="100%p" android:toYDelta="0"/&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;translate xmlns:android="http://schemas.android.com/apk/res/android" android:duration="300" android:fromYDelta="0" android:toYDelta="100%p"/&gt; 代码 12345678910111213141516171819202122@NonNull@Overridepublic Dialog onCreateDialog(Bundle savedInstanceState) &#123; LayoutInflater inflater = getActivity().getLayoutInflater(); View view = inflater.inflate(R.layout.view, null); final Dialog dialog = new Dialog(getActivity(), R.style.style_dialog); dialog.setContentView(view); dialog.show(); Window window = dialog.getWindow(); window.setGravity(Gravity.BOTTOM); //可设置dialog的位置 window.getDecorView().setPadding(0, 0, 0, 0); //消除边距 WindowManager.LayoutParams lp = window.getAttributes(); lp.width = WindowManager.LayoutParams.MATCH_PARENT; //设置宽度充满屏幕 lp.height = WindowManager.LayoutParams.WRAP_CONTENT; window.setAttributes(lp); return dialog;&#125; 生命周期 onAttach onCreate onCreateView onStart onStop third activity on destroy onDestroyView onDetach onAttach onCreate onCreateView onStart 设置背景为透明12View decorView = getDialog().getWindow().getDecorView();decorView.setBackground(new ColorDrawable(Color.TRANSPARENT)); (PS:Window -&gt; DecorView -&gt; FrameLayout -&gt; FrameLayout -&gt; 我们的自定义View) 这个逻辑大家应该都知道的，所以我们只需要改变底部的DecorView的背景色即可。 设置弹框位置因为View是在window下面的，我们只需要让window的Grivaty属性是Bottom，这样，里面的元素都是居于底部即可。 1234Window window = getDialog().getWindow();WindowManager.LayoutParams layoutParams = window.getAttributes();layoutParams.gravity = Gravity.BOTTOM;window.setAttributes(layoutParams); 解决DialogFragment两边的间隙因为View都是被包含在window里面，虽然我们的自己的View的宽度已经设置成了match_parent，但是我们并没有对window设置宽度为最大。所以我们先来改变window的宽度。 改变window的宽度： 12345Window window = getDialog().getWindow();WindowManager.LayoutParams layoutParams = window.getAttributes();layoutParams.gravity = Gravity.BOTTOM;layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;window.setAttributes(layoutParams); 我们在前面修改弹框位置的代码处，多添加一句： layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT; 设置之后虽然二边的间隙变小了很多。但是还是有间隙，既然我们都已经把window的宽度变为match_parent,还是没填充，说明应该是有padding值。那我们马上就想到了，难道是DecorView里面有padding值。毕竟我们的View也是被包含在DecorView里面。废话不多说，我们马上实验： decorView.setPadding(0,0,0,0); PS:这里还有另外一种方法，不写这句decorView.setPadding(0,0,0,0);而是直接设置window的背景颜色，window.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));源码中其实也给DecorView设置了padding值。所以效果相同。 设置弹框从下而上显示我们看过ios的弹框效果，是从底部从下而上升起，然后消失的时候也是从上而下消失。所以消失的时候我们不能单纯的让DialogFragment执行dismiss()，而是先让弹框执行下移的动画效果，然后再dismiss()。 既然谈到了上下的移动，大家肯定马上想到了用TranslateAnimation动画来做，我们就一步步来看如何用这个来实现： 弹框出现动画： 12345678910Animation slide = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 1.0f, Animation.RELATIVE_TO_SELF, 0.0f);slide.setDuration(400);slide.setFillAfter(true);slide.setFillEnabled(true);view.startAnimation(slide); 我们来看TranslateAnimation，这里我们传了八个参数，一般大家用到的是只传四个参数： 1TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) 也就是从坐标(fromXDelta,fromYDelta)到(toXDelta,toYDelta)。我们可以点进去这个构造函数查看： 1234567891011public TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) &#123; mFromXValue = fromXDelta; mToXValue = toXDelta; mFromYValue = fromYDelta; mToYValue = toYDelta; mFromXType = ABSOLUTE; mToXType = ABSOLUTE; mFromYType = ABSOLUTE; mToYType = ABSOLUTE;&#125; 之所以我们以前用的只传了四个参数，是因为他给我们把另外四个参数以及赋了默认值，也就是ABSOLUTE。我们继续看有哪几种可以选择： 12345678910111213141516/** * The specified dimension is an absolute number of pixels. */public static final int ABSOLUTE = 0;/** * The specified dimension holds a float and should be multiplied by the * height or width of the object being animated. */public static final int RELATIVE_TO_SELF = 1;/** * The specified dimension holds a float and should be multiplied by the * height or width of the parent of the object being animated. */public static final int RELATIVE_TO_PARENT = 2; 通过字面意思我们也能理解：ABSOLUTE是绝对坐标，RELATIVE_TO_SELF是相对于自身，RELATIVE_TO_PARENT是相对于父View。而我们只需要我们的弹框显示的位置，让的起始位置如下图所示： 刚开始超过屏幕，并且高度为弹框自身的高度，然后再回到原始位置,所以我们就用： 123456Animation slide = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 1.0f, Animation.RELATIVE_TO_SELF, 0.0f); 从原来的位置，增加了自身高度的距离为起始点，开始移动，然后再回到原来的位置。 消失动画： 只要跟上面反过来就可以了。同时这里我们要额外增加监听动画结束事件，因为我们让弹框往下移动结束后，要让这个弹框dismiss掉: 123456789101112131415161718Animation slide = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 1.0f);slide.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123;&#125; @Override public void onAnimationEnd(Animation animation) &#123; IOSDialogFragment.this.dismiss(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123;&#125;&#125;); 所以我们的动画的代码总结下就是： @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) { getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); rootView = inflater.inflate(R.layout.fragment_ios_dialog, container, false); slideToUp(rootView); return rootView; } public void slideToUp(View view){ Animation slide = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF,1.0f, Animation.RELATIVE_TO_SELF, 0.0f); slide.setDuration(400); slide.setFillEnabled(true); slide.setFillAfter(true); view.startAnimation(slide); } public void slideToDown(View view){ Animation slide = new TranslateAnimation( Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF,0.0f, Animation.RELATIVE_TO_SELF, 1.0f); slide.setDuration(400); slide.setFillEnabled(true); slide.setFillAfter(true); view.startAnimation(slide); slide.setAnimationListener(new Animation.AnimationListener() { @Override public void onAnimationStart(Animation animation) { } @Override public void onAnimationEnd(Animation animation) { IOSDialogFragment.this.dismiss();//弹框消失 } @Override public void onAnimationRepeat(Animation animation) { } }); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-RecyclerView详细学习]]></title>
      <url>%2F2017%2F06%2F25%2Fandroid-recyclerview%2F</url>
      <content type="text"><![CDATA[RecyclerViewRecyclerView是什么？RecylerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字recylerview即回收view也可以看出。看到这也许有人会问，不是已经有ListView了吗，为什么还要RecylerView呢？这就牵扯到第二个问题了。 RecyclerView的优点是什么？根据官方的介绍RecylerView是ListView的升级版，既然如此那RecylerView必然有它的优点，现就RecylerView相对于ListView的优点罗列如下： RecylerView封装了viewholder的回收复用，也就是说RecylerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的 逻辑被封装了，写起来更加简单。 提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecylerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还有StaggeredGridLayoutManager等)，也就是说RecylerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。你想控制Item的分隔线，可以通过继承RecylerView的ItemDecoration这个类，然后针对自己的业务需求去抒写代码。 可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecylerView有其自己默认的实现。 RecyclerView的用法RecyclerView的初步用法(包括RecyclerView.Adapter用法)123456789101112recyclerView = (RecyclerView) findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this ); //设置布局管理器 recyclerView.setLayoutManager(layoutManager); //设置为垂直布局，这也是默认的 layoutManager.setOrientation(OrientationHelper. VERTICAL); //设置Adapter recyclerView.setAdapter( recycleAdapter); //设置分隔线 recyclerView.addItemDecoration( new DividerGridItemDecoration(this )); //设置增加或删除条目的动画 recyclerView.setItemAnimator( new DefaultItemAnimator()); 可以看到对RecylerView的设置过程，比ListView要复杂一些，这也是RecylerView高度解耦的表现，虽然代码抒写上有点复杂，但它的扩展性是极高的。 RecyclerView的生命周期一个RecyclerView的Item加载是有顺序的，类似于Activity的生命周期（姑且这么叫把），具体可以对adapter的每个方法进行重写打下日志进行查看，具体大致为： getItemViewType(获取显示类型，返回值可在onCreateViewHolder中拿到，以决定加载哪种ViewHolder) onCreateViewHolder(加载ViewHolder的布局) onViewAttachedToWindow（当Item进入这个页面的时候调用） onBindViewHolder(将数据绑定到布局上，以及一些逻辑的控制就写这啦) onViewDetachedFromWindow（当Item离开这个页面的时候调用） onViewRecycled(当Item被回收的时候调用)tips1:如果你调用了： 1viewHolder.setIsRecyclable(false); 那么这个Item的onViewRecycled将永远不会调用。tips2:如果你的界面出现了错乱的现象，请调用如上代码可能能简单粗暴的解决，当然代价是损失少许的性能表现了。 RecyclerView.Adapter来看看它的Adapter的写法，RecyclerView的Adapter与ListView的Adapter还是有点区别的，RecyclerView.Adapter，需要实现3个方法： onCreateViewHolder()这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。直接省去了当初的convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。 onBindViewHolder()这个方法主要用于适配渲染数据到View中。方法提供给你了一个viewHolder，而不是原来的convertView。 getItemCount()这个方法就类似于BaseAdapter的getCount方法了，即总共有多少个条目。 notifyDataSetChanged()刷新所有,notifyDataSetChanged最终会使adapter的数据重新绑定，即会重新调用adapter里的onBindViewHolder方法，从而使item的position得到了更新。 notifyItemChanged(int position)position数据发生了改变，那调用这个方法，就会回调对应position的onBindViewHolder()方法了 notifyItemRangeChanged(int positionStart, int itemCount)刷新从positionStart开始itemCount数量的item了（这里的刷新指回调onBindViewHolder()方法） notifyItemInserted(int position)在第position位置被插入了一条数据的时候可以使用这个方法刷新，注意这个方法调用后会有插入的动画，这个动画可以使用默认的，也可以自己定义 notifyItemMoved(int fromPosition, int toPosition)从fromPosition移动到toPosition为止的时候可以使用这个方法刷新 notifyItemRangeInserted(int positionStart, int itemCount)批量添加 notifyItemRemoved(int position)第position个被删除的时候刷新，同样会有动画 notifyItemRangeRemoved(int positionStart, int itemCount)批量删除 onAttachedToRecyclerView (RecyclerView recyclerView)在RecyclerView.setAdapter(adapter)时进行调用 onViewAttachedToWindow(VH holder)当Item进入这个页面的时候调用 onViewDetachedFromWindow(VH holder)当Item离开这个页面的时候调用 onViewRecycled(VH holder)当Item被回收的时候调用 RecyclerView.ItemDecoration An ItemDecoration allows the application to add a special drawing and layout offset to specific item views from the adapter’s data set. This can be useful for drawing dividers between items, highlights, visual grouping boundaries and more. ItemDecoration允许应用结合adapter的数据集，对特定的item添加绘制一个周边图案。可以用于给items之间添加分割线、高亮装饰效果或者分组边界等等。 从谷歌官方的介绍可以知道，ItemDecoration是用于给列表的item添加各种装饰效果，开发中最常见的就是为item添加分割线。ItemDecoration本身是一个抽象类，抛去废弃的方法，我们需要关心的方法只有三个： 1234567891011public static abstract class ItemDecoration &#123; public void onDraw(Canvas c, RecyclerView parent, State state) &#123; onDraw(c, parent); &#125; public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123; onDrawOver(c, parent); &#125; public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewLayoutPosition(),parent); &#125;&#125; 从源码注释中，可以大概了解这三个方法的用途： onDraw：在item绘制之前时被调用，将指定的内容绘制到item view内容之下； onDrawOver：在item被绘制之后调用，将指定的内容绘制到item view内容之上 getItemOffsets：在每次测量item尺寸时被调用，将decoration的尺寸计算到item的尺寸中 ItemDecoration三个方法的测试谷歌官方在support.v7包中提供了ItemDecoration的一个实现DividerItemDecoration，这里结合这个实现，来看看其三个需要实现的方法对UI的影响。 onDraw1234567891011121314151617181920212223242526272829303132333435363738private void drawVertical(Canvas canvas, RecyclerView parent) &#123; canvas.save(); final int left; final int right; if (parent.getClipToPadding()) &#123; left = parent.getPaddingLeft(); right = parent.getWidth() - parent.getPaddingRight(); canvas.clipRect(left, parent.getPaddingTop(), right,parent.getHeight() - parent.getPaddingBottom()); &#125; else &#123; left = 0; right = parent.getWidth(); &#125; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); parent.getDecoratedBoundsWithMargins(child, mBounds); final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child)); final int top = bottom - mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); &#125; canvas.restore();&#125;``` `drawVertical`方法实现了对`Orientation == VERTICAL`的RecyclerView绘制item之间的分割线。从传入的canvas参数可以推断，分割线的绘制是通过canvas机制绘制到屏幕上：`mDivider.draw(canvas)`;其中，mDivider是一个Drawable对象，可以通过setDrawable传入自定义对象，不传入时，会自动使用系统内置的分割线样式：`android.R.attr.listDivider`。通过遍历每一个可见的child view，计算mDivider对应的left、top、right、bottom值，从而绘制到正确的位置上。对于纵向的RecyclerView而言，mDivider的left和right是固定的，和parent的左右内容边界保持一致，也就是说，把parent的左右padding都计算进去，因而是代表了RecyclerView实际的内容区域。纵向的分割线一般位于每个item的底部，因此mDivider的top值理论上应该和child view的内容下边界保持贴合。实际上，计算top和bottom的代码，谷歌官方也有所调整，在最新的实现中，先通过`parent.getDecoratedBoundsWithMargins(child, mBounds)`;拿到之前在onMeasure过程中，通过调用`getItemOffsets`获取到的mBounds，mBounds是包括了整个child view以及其decoration的总边界，之后再计算mDivider的bottom、top值。### getItemOffsets```javapublic void getItemOffsets(Rect outRect, View view, RecyclerView parent,RecyclerView.State state) &#123; if (mOrientation == VERTICAL) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125;&#125; 官方实现的getItemOffsets比较简单，只是根据列表的方向，返回了分割线在相应方向的尺寸。这里可能有一个坑，即通过setDrawable设置自定义的分割线时，容易传入一个无尺寸的drawable对象，导致分割线无法显示出来的bug，典型的代码是这样：decoration.setDrawable(new ColorDrawable(Color.RED)); DividerItemDecoration的实现中，是没有复写onDrawOver方法的，对于分割线场景而言，也确实不需要去实现它。接下来，通过几个例子，展示一下getItemOffsets对于ItemDecoration在UI上的影响。 getItemOffsets &amp; onDraw先上动图【注2】： 上图中，getItemOffsets方法里，返回outRect不同，而onDraw方法绘制的分割线高度初始值设为25，并通过外部增减来观察其UI效果。 123456789101112131415public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; outRect.set(0, 0, 0, 50);// outRect.set(50,50,50,50);&#125;public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; for (int i = 0; i &lt; childCount; i++) &#123; final View view = parent.getChildAt(i); top = view.getBottom(); left = view.getPaddingLeft() + mSize; right = view.getWidth() - view.getPaddingRight() - mSize ; bottom = top + mSize; divider.setBounds(left, top, right, bottom); divider.draw(c); &#125;&#125; 从上面两个动图对比，可以得出以下几个结论： getItemOffsets返回的矩形outRect会被计算到child view的尺寸当中； onDraw方法绘制的图形，可以超出outRect所规定的区域； onDraw方法绘制的图形，确实是处于child view的底下，当两者发生重叠时，只会显示child view的内容； getItemOffsets &amp; onDrawOver 将之前onDraw方法内代码完整拷贝到onDrawOver下，并注释掉之前onDraw中的方法，很容易验证出onDrawOver与onDraw的唯一不同之处。 onDrawOver绘制的图形，处于child view之上，当两者发生重叠时，会显示onDrawOver的内容； ItemDecoration三个方法的含义，就介绍到这里。可以感觉到，三个方法都很简单而基础，可以十分优雅的实现item的分割线效果，然而简单的如DividerItemDecoration，往往是无法满足项目开发需求的。经常会遇到某几个item不想要分割线（如头部或者最后一个item），这就需要开发者自行来实现。 添加分隔线我们可以创建一个继承RecyclerView.ItemDecoration类来绘制分隔线，通过ItemDecoration可以让我们每一个Item从视觉上面相互分开来，例如ListView的divider非常相似的效果。也可以不设置ItemDecoration，那说明ItemDecoration我们并不是强制需要使用，作为我们开发者可以设置或者不设置Decoration的。实现一个ItemDecoration，系统提供的ItemDecoration是一个抽象类，内部除去已经废弃的方法以外，我们主要实现以下三个方法: 1234567891011public static abstract class ItemDecoration &#123; public void onDraw(Canvas c,RecyclerView parent,State state) &#123; onDraw(c,parent); &#125; public void onDrawOver(Canvas c,RecyclerView parent,State state) &#123; onDrawOver(c,parent); &#125; public void getItemOffsets(RectoutRect, View view,RecyclerView parent,State state) &#123; getItemOffsets(outRect,((LayoutParams)view.getLayoutParams()).getViewLayoutPosition(),parent); &#125; &#125; onDraw方法先于drawChildren onDrawOver在drawChildren之后，一般我们选择复写其中一个即可。 getItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制Decorator。 又因为当我们RecyclerView在进行绘制的时候会进行绘制Decoration,那么会去调用onDraw和onDrawOver方法，那么这边我们其实只要去重写onDraw和getItemOffsets这两个方法就可以实现啦。然后LayoutManager会进行Item布局的时候，会去调用getItemOffset方法来计算每个Item的Decoration合适的尺寸，下面我们来具体实现一个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.example.reclerviewpractice; import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.v7.widget.LinearLayoutManager ; import android.support.v7.widget.RecyclerView; import android.view.View; public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; private static final int[] ATTRS = new int[]&#123; android.R.attr. listDivider &#125;; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS ); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); &#125; public void setOrientation( int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123; throw new IllegalArgumentException( "invalid orientation"); &#125; mOrientation = orientation; &#125; @Override public void onDraw(Canvas c, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125;else&#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125; &#125; 改变分隔线样式那么怎么更改分隔线的样式呢？在上面的DividerItemDecoration这个类中可以看到这个分隔线是跟ListView一样的，即系统的默认的样式，因此我们可以在styles的xml文件中进行更改，更改如下： 12345&lt;!-- Application theme. --&gt; &lt;style name ="AppTheme" parent="AppBaseTheme"&gt; &lt;!-- All customizations that are NOT specific to a particular API-level can go here. --&gt; &lt;item name= "android:listDivider"&gt;@drawable/divider &lt;/item &gt; &lt;/style &gt; divider的内容如下： 12345678910&lt;?xml version="1.0" encoding= "utf-8"?&gt; &lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt; &lt;!-- 填充的颜色 --&gt; &lt;solid android:color ="@color/color_red"/&gt; &lt;!-- 线条大小 --&gt; &lt;size android:height ="1dp" android:width ="1dp"/&gt; &lt;/shape&gt; 看到这肯定会有人说，这尼玛，好麻烦，还不如ListView简单呢，从上面的代码量看来确实是使用起来很复杂，但是如果此时你想将这个列表以GridView的形式展示出来，用RecylerView仅仅是换一行代码的事情. 简单的封装MKItemDecoration 支持简单颜色分割线 支持简单颜色分割线 + 文字：文字可以居左、居中 支持分割线跳过起始诺干个item，跳过最后一个item 支持分组悬停效果 支持自定义View作为Decoration 上图hoverGroup.gif的使用代码如下： 12345678910111213141516171819recyclerView.addItemDecoration(new MKItemDecoration.Builder().height(50).color(Color.parseColor("#525D97")).textSize(30).textColor(Color.WHITE).itemOffset(0).iHover(new IHover() &#123; @Override public boolean isGroup(int position) &#123; return position % 4 == 0; &#125; @Override public String groupText(int position) &#123; return adapter.data.get(4 * (position / 4)); &#125;&#125;).textAlign(MKItemDecoration.Builder.ALIGN_MIDDLE).build()); 通过封装，利用builder模式来更好的自定义需要的Decoration，其中，为了支持自定义View，需要外部传入相关的view的资源id和需要绑定的数据List，控件内部会通过view的measure,layout,draw的流程，将其绘制在屏幕上。 具体代码 RecyclerView.ViewHolder getPosition()在API22的时候已经被废弃，因为它在异步处理器更新的时候不能准确表示数据，是模棱两可的。请根据你所使用的场景参照使用getLayoutPosition() 和 getAdapterPosition() getAdapterPosition()在调用notifyDataSetChanged之后并不能马上获取Adapter中的position, 要等布局结束之后才能获取到.在调用notifyItemInserted(0)之后能通过getAdapterPosition()获取适配器位置即使新的布局还没有计算。,如果你做一些用户点击,如果getAdapterPosition()返回NO_POSITION,最好忽略点击,因为你不知道用户点击(除非你有其他机制,如稳定的id查找条目)。 getLayoutPosition()假设您正在使用LayoutManager或者想要访问ViewHolder当前点击的项目。在这种情况下,您应该使用getLayoutPosition()来获取当前布局位置。mRecyclerView.findViewHolderForLayoutPosition(myViewHolder.getLayoutPosition() - 1) RecyclerView.ItemAnimator animateAppearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)当RecyclerView中的item显示到屏幕上时调用此方法。传入的layout之后的ViewHolder对象。 animateDisappearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)当RecyclerView中的item在屏幕上由可见变为不可见时调用此方法。传入的layout之后的ViewHolder对象。 animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)当RecyclerView中的item状态发生改变时调用此方法(notifyItemChanged(position))。方法中传入了layout之前的ViewHolder和layout之后的ViewHolder对象，通过这两个ViewHolder对象获取其中的itemView进行动画效果。 runPendingAnimations()统筹RecyclerView中所有的动画，统一启动执行 setRemoveDuration(long removeDuration)/getRemoveDuration()设置删除Item动画的延迟时间 setMoveDuration(long moveDuration)/getMoveDuration()设置移动Item动画的延迟时间 setChangeDuration(long changeDuration)/getChangeDuration()设置改变Item动画的延迟时间 setAddDuration(long addDuration)/getAddDuration()设置添加Item动画的延迟时间 recordPostLayoutInformation(RecyclerView.State state, RecyclerView.ViewHolder viewHolder)布局完成后对这个方法进行调用，记录view的必要信息。 onAnimationStarted(RecyclerView.ViewHolder viewHolder)当一个新动画添加到这个ViewHolder上，调用此方法 onAnimationFinished(RecyclerView.ViewHolder viewHolder)在dispatchAnimationFinished(ViewHolder)这个方法调用后调用 obtainHolderInfo()获取ViewHolder保存的RecyclerView.ItemAnimator.ItemHolderInfo信息 isRunning()判断是否有Item动画在运行 endAnimations()停止所有动画 endAnimation(RecyclerView.ViewHolder item)停止指定动画 RecyclerView.LayoutManagerRecyclerView.LayoutManager是一个抽象类，系统为我们提供了三个实现类 LinearLayoutManager即线性布局，这个是在上面的例子中我们用到的布局 GridLayoutManager即表格布局 StaggeredGridLayoutManager即流式布局，如瀑布流效果假如将上述例子换成GridView的效果，那么相应的代码应该这样改 给RecyclerView的Item添加点击事件ListView给我们提供了onItemClickListener的监听器，但对于RecyclerView来讲，非常可惜的是，该控件没有给我们提供这样的内置监听器方法，不过我们可以进行改造实现，可以这样实现Item的点击事件的监听，在我们的adapter中增加这两个方法 12345678public interface OnItemClickListener&#123; void onClick( int position); void onLongClick( int position);&#125;public void setOnItemClickListener(OnItemClickListener onItemClickListener )&#123; this. mOnItemClickListener=onItemClickListener;&#125; 然后onBindViewHolder方法要做如下更改 12345678910111213141516171819@Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; holder. tv.setText( mDatas.get(position)); if( mOnItemClickListener!= null)&#123; holder. itemView.setOnClickListener( new OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnItemClickListener.onClick(position); &#125; &#125;); holder. itemView.setOnLongClickListener( new OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; mOnItemClickListener.onLongClick(position); return false; &#125; &#125;); &#125; RecyclerView局部刷新界面来自于RecyclerView的原理RecyclerView addView调用的时候ViewGroup addView的源码，源码如下(如无特殊说明，以下源码均为api 25) 123456789101112131415public void addView(View child, int index, LayoutParams params) &#123; if (DBG) &#123; System.out.println(this + " addView"); &#125; if (child == null) &#123; throw new IllegalArgumentException("Cannot add a null child view to a ViewGroup"); &#125; // addViewInner() will call child.requestLayout() when setting the new LayoutParams // therefore, we call requestLayout() on ourselves before, so that the child's request // will be blocked at our level requestLayout(); invalidate(true); addViewInner(child, index, params, false);&#125; 也就是会调用requestLayout，这是一个全局刷新的函数，也就是说整个界面将会被刷新，有全局刷新在View层级较多较复杂的时必然存在卡顿那么RecyclerView 如何做到滑动时addView时不卡的呢，也就是说RecyclerView addView时候为什么没有引起RecyclerView 的onMeasure触发呢，答案就是RecyclerView 以下代码 12345678@Overridepublic void requestLayout() &#123; if (mEatRequestLayout == 0 &amp;&amp; !mLayoutFrozen) &#123; super.requestLayout(); &#125; else &#123; mLayoutRequestEaten = true; &#125;&#125; 尼玛还有这种操作？？！复写requestLayout不向上报告，自己做内部处理，内部处理详见LayoutManager类的layoutChunk函数这里不细说。 好了，得到了黑科技的样本，接下来我就来实现一个黑科技的demo，改变View宽高时局部刷新界面。 黑科技的应用MainActivity布局如下 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;com.zjw.appmethodtime.MyRelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.zjw.appmethodtime.MainActivity"&gt; &lt;com.zjw.appmethodtime.MyLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.zjw.appmethodtime.MyTextView android:id="@+id/text_view" android:layout_width="match_parent" android:layout_height="50dp" android:background="@color/colorPrimary" android:text="Click Me" android:gravity="center" android:textSize="25sp" android:textStyle="bold"/&gt; &lt;/com.zjw.appmethodtime.MyLayout&gt;&lt;/com.zjw.appmethodtime.MyRelativeLayout&gt; 自定义一个RelativeLayout 用以看是否局部刷新是否生效，如果局部刷新无效则顶层onMeasure会调用（因为改变了控件大小嘛全局刷新肯定会调用到处于顶层的onMeasure） 123456789101112131415161718public class MyRelativeLayout extends RelativeLayout &#123; public MyRelativeLayout(Context context) &#123; super(context); &#125; public MyRelativeLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyRelativeLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); &#125;&#125; 自定义一个MyLayout 继承自LinearLayout ，这里只是demo你想用什么ViewGroup可以自己改。这里MyLayout 就类似于RecyclerView 了，该子View宽高改变时会调用requestLayout，MyLayout 这里做拦截，然后自行处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyLayout extends LinearLayout &#123; private int mWidthMeasureSpec; private int mheightMeasureSpec; private int mLeft; private int mTop; private int mRight; private int mBottom; public static boolean shouldLocalIinvalidate = false; public MyLayout(Context context) &#123; this(context, null); &#125; public MyLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; mLeft = l; mTop = t; mRight = r; mBottom = b; super.onLayout(changed, l, t, r, b); &#125; @Override public void requestLayout() &#123; if (shouldLocalIinvalidate) &#123; localRequestLayout(); &#125; else &#123; super.requestLayout(); &#125; &#125; @SuppressLint("WrongCall") void localRequestLayout() &#123; onMeasure(mWidthMeasureSpec, mheightMeasureSpec); onLayout(true, mLeft, mTop, mRight, mBottom); invalidate(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mWidthMeasureSpec = widthMeasureSpec; mheightMeasureSpec = widthMeasureSpec; &#125;&#125; 以下代码就是在MainActivity里使用改变子View宽高局部刷新界面 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zjw.appmethodtime;import android.content.res.Resources;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.TypedValue;import android.view.View;import android.widget.TextView;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; protected MyRecycleView mListView; protected TextView mTextView; private float value; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); super.setContentView(R.layout.activity_main); initView(); &#125; private void initView() &#123; Resources resources = this.getResources(); value = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, resources.getDisplayMetrics()); mTextView = (TextView) findViewById(R.id.text_view); mTextView.setOnClickListener(MainActivity.this); &#125; @Override public void onClick(View view) &#123; if (view.getId() == R.id.text_view) &#123; view.getLayoutParams().height += value; //shouldLocalIinvalidate 为true 表示开启局部刷新 否则为关闭（MyLayout shouldLocalIinvalidate 默认为false） ((MyLayout) view.getParent()).shouldLocalIinvalidate = true; view.requestLayout(); view.invalidate(); //局部刷新完成及时恢复成可以全局刷新的状态 ((MyLayout) view.getParent()).shouldLocalIinvalidate = false; &#125; &#125;&#125; 上面MainActivity 的onClick代码中开启了局部刷新（log代码自己加），效果图参见上文。把上面的((MyLayout) view.getParent()).shouldLocalIinvalidate = true;这句去掉，这就是相当于不启用局部刷新，然后看MyRelativeLayout 的onMeasure方法log（log代码自己加），不启用局部刷新效果图见上文。 应用场景使用于某个ViewGroup宽高已定位置已定，该子view想改变宽高等场景。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-View详细学习]]></title>
      <url>%2F2017%2F06%2F20%2Fandroid-view%2F</url>
      <content type="text"><![CDATA[View有8个直接子类：AnalogClock, ImageView, KeyboardView, ProgressBar, SurfaceView, TextView, ViewGroup, ViewStub。 View有54个间接子类：AbsListView, AbsSeekBar,AbsSpinner, AbsoluteLayout, AdapterView&lt;T extends Adapter&gt;, AppWidgetHostView, AutoCompleteTextView,Button,CheckBox, CheckedTextView, Chronometer, CompoundButton,DatePicker, DialerFilter, DigitalClock,EditText, ExpandableListView, ExtractEditText,FrameLayout, GLSurfaceView,Gallery,GestureOverlayView,GridView, HorizontalScrollView, ImageButton, ImageSwitcher, LinearLayout,ListView,MediaController, MultiAutoCompleteTextView, QuickContactBadge,RadioButton,RadioGroup, RatingBar, RelativeLayout, ScrollView, SeekBar, SlidingDrawer, Spinner, TabHost, TabWidget, TableLayout, TableRow, TextSwitcher, TimePicker, ToggleButton, TwoLineListItem,VideoView, ViewAnimator, ViewFlipper, ViewSwitcher, WebView, ZoomButton, ZoomControls View的属性基本属性 android:alpha关联方法: setAlpha(float) 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。 android:background关联方法: setBackgroundResource(int) 属性说明: 视图背景 android:clickable关联方法: setClickable(boolean) 属性说明: 视图是否可点击 android:contentDescription关联方法: setContentDescription(CharSequence) 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明 android:drawingCacheQuality关联方法: setDrawingCacheQuality(int) 属性说明: “设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存” android:duplicateParentState关联方法: 属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等） android:fadeScrollbars关联方法: setScrollbarFadingEnabled(boolean) 属性说明: 定义在ScrollBar没有使用时，是否褪色。 android:fadingEdgeLength关联方法: getVerticalFadingEdgeLength() 属性说明: 设置边框渐变的长度。 android:filterTouchesWhenObscured关联方法: setFilterTouchesWhenObscured(boolean) 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。 android:fitsSystemWindows关联方法: setFitsSystemWindows(boolean) 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏） android:focusable关联方法: setFocusable(boolean) 属性说明: 设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。在Touch模式下获取焦点需要设置focusableInTouchMode为true。 android:focusableInTouchMode关联方法: setFocusableInTouchMode(boolean) 属性说明: 设置在Touch模式下View是否能取得焦点。 android:hapticFeedbackEnabled关联方法: setHapticFeedbackEnabled(boolean) 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果 android:id关联方法: setId(int) 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用View.findViewById() 或Activity.findViewById()根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。 android:importantForAccessibility关联方法: setImportantForAccessibility(int) 属性说明: 设置可达性的重要性 android:isScrollContainer关联方法: setScrollContainer(boolean) 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条 android:keepScreenOn关联方法: setKeepScreenOn(boolean) 属性说明: 视图在可见的情况下是否保持唤醒状态。 android:layerType关联方法: setLayerType(int,Paint) 属性说明: “设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。” android:layoutDirection关联方法: setLayoutDirection(int) 属性说明: 定义布局图纸的方向 android:longClickable关联方法: setLongClickable(boolean) 属性说明: 是否响应长点击事件 android:minHeight关联方法: setMinimumHeight(int) 属性说明: 设置视图最小高度 android:minWidth关联方法: setMinimumWidth(int) 属性说明: 设置视图最小宽度 android:nextFocusDown关联方法: setNextFocusDownId(int) 属性说明: 向下移动焦点时，下一个获取焦点的view的id android:nextFocusForward关联方法: setNextFocusForwardId(int) 属性说明: 下一个获取焦点的view的id android:nextFocusLeft关联方法: setNextFocusLeftId(int) 属性说明: 向左移动焦点时，下一个获取焦点的view的id android:nextFocusRight关联方法: setNextFocusRightId(int) 属性说明: 向右移动焦点时，下一个获取焦点的view的id android:nextFocusUp关联方法: setNextFocusUpId(int) 属性说明: 向上移动焦点时，下一个获取焦点的view的id android:onClick关联方法: 属性说明: 点击时，要调用的方法的名称。 android:padding关联方法: setPaddingRelative(int,int,int,int) 属性说明: 设置上下左右的边距 android:paddingBottom关联方法: setPaddingRelative(int,int,int,int) 属性说明: 下边距 android:paddingEnd关联方法: setPaddingRelative(int,int,int,int) 属性说明: 与android:paddingRight相同 android:paddingLeft关联方法: setPadding(int,int,int,int) 属性说明: 左边距 android:paddingRight关联方法: setPadding(int,int,int,int) 属性说明: 右边距 android:paddingStart关联方法: setPaddingRelative(int,int,int,int) 属性说明: android:paddingLeft相同 android:paddingTop关联方法: setPaddingRelative(int,int,int,int) 属性说明: 上边距 android:requiresFadingEdge关联方法: setVerticalFadingEdgeEnabled(boolean) 属性说明: 定义滚动时边缘是否褪色 android:rotation关联方法: setRotation(float) 属性说明: 旋转度数 android:rotationX关联方法: setRotationX(float) 属性说明: 水平旋转度数 android:rotationY关联方法: setRotationY(float) 属性说明: 竖直旋转度数 android:saveEnabled关联方法: setSaveEnabled(boolean) 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。 android:scaleX关联方法: setScaleX(float) 属性说明: 水平方向缩放比例 android:scaleY关联方法: setScaleY(float) 属性说明: 竖直方向缩放比例 android:scrollX关联方法: 属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离 android:scrollY关联方法: 属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离 android:scrollbarAlwaysDrawHorizontalTrack关联方法: 属性说明: 是否总是绘制水平滚动条的滚动轨道 android:scrollbarAlwaysDrawVerticalTrack关联方法: 属性说明: 是否总是绘制竖直滚动条的滚动轨道 android:scrollbarDefaultDelayBeforeFade关联方法: setScrollBarDefaultDelayBeforeFade(int) 属性说明: 滚动条在n毫秒后开始淡出。 android:scrollbarFadeDuration关联方法: setScrollBarFadeDuration(int) 属性说明: 滚动条用多长时间淡出完毕。 android:scrollbarSize关联方法: setScrollBarSize(int) 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度 android:scrollbarStyle关联方法: setScrollBarStyle(int) 属性说明: “滚动条的风格。共4组值： insideOverlay——内贴图 insideInset——内插图 outsideOverlay——外贴图 outsideInset——外插图。 inside就是滚动条在绘制在padding以内；outside就是不需要绘制在padding内（即view的边界处）；Overlay是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；Inset是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。” android:scrollbarThumbHorizontal关联方法: 属性说明: 水平滚动块的drawable对象 android:scrollbarThumbVertical关联方法: 属性说明: 竖直滚动块的drawable对象 android:scrollbarTrackHorizontal关联方法: 属性说明: 水平滚动条滚动轨道的drawable对象 android:scrollbarTrackVertical关联方法: 属性说明: 竖直滚动条滚动轨道的drawable对象 android:scrollbars关联方法: 属性说明: “设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条” android:soundEffectsEnabled关联方法: setSoundEffectsEnabled(boolean) 属性说明: 点击或触摸该view时，是否需要有声音效果 android:tag关联方法: 属性说明: string标识。类似id，id是整数标识。 android:textAlignment关联方法: setTextAlignment(int) 属性说明: 设置文本的显示方式。 android:textDirection关联方法: setTextDirection(int) 属性说明: 设置文本的显示方向。 android:transformPivotX关联方法: setPivotX(float) 属性说明: 水平方向偏转量 android:transformPivotY关联方法: setPivotY(float) 属性说明: 竖直方向偏转量 android:translationX关联方法: setTranslationX(float) 属性说明: 水平方向的移动距离 android:translationY关联方法: setTranslationY(float) 属性说明: 竖直方向的移动距离 android:visibility关联方法: setVisibility(int) 属性说明: “view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见” TextView属性说明下面对TextView的属性进行说明android:autoLink关联方法: setAutoLinkMask(int)属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值(none/web/email/phone/map/all) android:autoText关联方法: setKeyListener(KeyListener)属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。 android:bufferType关联方法: setText(CharSequence,TextView.BufferType)属性说明: 指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。 android:capitalize关联方法: setKeyListener(KeyListener)属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。 android:cursorVisible关联方法: setCursorVisible(boolean)属性说明: 设定光标为显示/隐藏，默认显示。 android:digits关联方法: setKeyListener(KeyListener)属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\n()” android:drawableBottom关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。 android:drawableEnd关联方法: setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，”@[+][package:]type:name”或者”?[package:][type:]name”；也可以是颜色值，如”#rgb”, “#argb”, “#rrggbb”, or “#aarrggbb”。 android:drawableLeft关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)属性说明: 在text的左边输出一个drawable。 android:drawablePadding关联方法: setCompoundDrawablePadding(int)属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。 android:drawableRight关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)属性说明: 在text的右边输出一个drawable。 android:drawableStart关联方法: setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，”@[+][package:]type:name”或者”?[package:][type:]name”；也可以是颜色值，如”#rgb”, “#argb”, “#rrggbb”, or “#aarrggbb”。 android:drawableTop关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)属性说明: 在text的正上方输出一个drawable。 android:editable关联方法: 属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。 android:editorExtras关联方法: setInputExtras(int)属性说明: 设置文本的额外的输入数据。在EditView中才有效果。 android:ellipsize关联方法: setEllipsize(TextUtils.TruncateAt)属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动) android:ems关联方法: setEms(int)属性说明: 设置TextView的宽度为N个字符的宽度。 android:fontFamily关联方法: setTypeface(Typeface)属性说明: 文本的字形体系。 android:freezesText关联方法: setFreezesText(boolean)属性说明: 设置保存文本的内容以及光标的位置。 android:gravity关联方法: setGravity(int)属性说明: 设置文本位置，如设置成“center”，文本将居中显示。 android:height关联方法: setHeight(int)属性说明: 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米) android:hint关联方法: setHint(int)属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。 android:imeActionId关联方法: setImeActionLabel(CharSequence,int)属性说明: 设置IME动作ID。 android:imeActionLabel关联方法: setImeActionLabel(CharSequence,int)属性说明: 设置IME动作标签。在EditView再做说明。 android:imeOptions关联方法: setImeOptions(int)属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。 android:includeFontPadding关联方法: setIncludeFontPadding(boolean)属性说明: 设置文本是否包含顶部和底部额外空白，默认为true。 android:inputMethod关联方法: setKeyListener(KeyListener)属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。 android:inputType关联方法: setRawInputType(int)属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。 android:lineSpacingExtra关联方法: setLineSpacing(float,float)属性说明: 设置行间距。 android:lineSpacingMultiplier关联方法: setLineSpacing(float,float)属性说明: 设置行间距的倍数。如”1.2” android:lines关联方法: setLines(int)属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。 android:linksClickable关联方法: setLinksClickable(boolean)属性说明: 设置链接是否点击连接，即使设置了autoLink。 android:marqueeRepeatLimit关联方法: setMarqueeRepeatLimit(int)属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。 android:maxEms关联方法: setMaxEms(int)属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:maxHeight关联方法: setMaxHeight(int)属性说明: 设置文本区域的最大高度 android:maxLength关联方法: setFilters(InputFilter)属性说明: 限制显示的文本长度，超出部分不显示。 android:maxLines关联方法: setMaxLines(int)属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。 android:maxWidth关联方法: setMaxWidth(int)属性说明: 设置文本区域的最大宽度 android:minEms关联方法: setMinEms(int)属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:minHeight关联方法: setMinHeight(int)属性说明: 设置文本区域的最小高度 android:minLines关联方法: setMinLines(int)属性说明: 设置文本的最小行数，与lines类似。 android:minWidth关联方法: setMinWidth(int)属性说明: 设置文本区域的最小宽度 android:numeric关联方法: setKeyListener(KeyListener)属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。 android:password关联方法: setTransformationMethod(TransformationMethod)属性说明: 以小点”.”显示文本 android:phoneNumber关联方法: setKeyListener(KeyListener)属性说明: 设置为电话号码的输入方式。 android:privateImeOptions关联方法: setPrivateImeOptions(String)属性说明: 设置输入法选项，在EditText中才有作用。 android:scrollHorizontally关联方法: setHorizontallyScrolling(boolean)属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:selectAllOnFocus关联方法: setSelectAllOnFocus(boolean)属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。 android:shadowColor关联方法: setShadowLayer(float,float,float,int)属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。 android:shadowDx关联方法: setShadowLayer(float,float,float,int)属性说明: 设置阴影横向坐标开始位置。 android:shadowDy关联方法: setShadowLayer(float,float,float,int)属性说明: 设置阴影纵向坐标开始位置。 android:shadowRadius关联方法: setShadowLayer(float,float,float,int)属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。 android:singleLine关联方法: setTransformationMethod(TransformationMethod)属性说明: 设置单行显示。如果和layoutwidth一起使用，当文本不能全部显示时，后面用“…”来表示。如`android:text=”test singleLine”`android:singleLine=&quot;true&quot; android:layout_width=&quot;20dp&quot;将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行 android:text关联方法: setText(CharSequence,TextView.BufferType)属性说明: 设置显示文本. android:textAllCaps关联方法: setAllCaps(boolean)属性说明: 设置文本全为大写。值为”true”或”false”。 android:textAppearance关联方法: 属性说明: 设置文字外观。如“?android:attr/textAppearanceLargeInverse android:textColor关联方法: setTextColor(int)属性说明: 设置文本颜色 android:textColorHighlight关联方法: setHighlightColor(int)属性说明: 被选中文字的底色，默认为蓝色 android:textColorHint关联方法: setHintTextColor(int)属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。 android:textColorLink关联方法: setLinkTextColor(int)属性说明: 文字链接的颜色. android:textIsSelectable关联方法: isTextSelectable()属性说明: 设置非编辑文本可否被选择。值为”true”或”false”。 android:textScaleX关联方法: setTextScaleX(float)属性说明: 设置文字之间间隔，默认为1.0f。 android:textSize关联方法: setTextSize(int,float)属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp” android:textStyle关联方法: setTypeface(Typeface)属性说明: 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开 android:typeface关联方法: setTypeface(Typeface)属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3] android:width关联方法: setWidth(int)属性说明: 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。 Other由于这两天在做listView的东西，所以整理出来一些我个人认为比较特别的属性，通过设置这样的属性可以做出更加美观的列表 首先是stackFromBottom属性，这只该属性之后你做好的列表就会显示你列表的最下面，值为true和false android:stackFromBottom=&quot;true&quot; 第二是transciptMode属性，需要用ListView或者其它显示大量Items的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件transcriptMode属性可以将 android平台的控件（支持ScrollBar）自动滑动到最底部。 android:transcriptMode=&quot;alwaysScroll&quot; 第三cacheColorHint属性，很多人希望能够改变一下它的背景，使他能够符合整体的UI设计，改变背景背很简单只需要准备一张图片然后指定属性 android:background=&quot;@drawable/bg&quot;，不过不要高兴地太早，当你这么做以后，发现背景是变了，但是当你拖动，或者点击list空白位置的时候发现ListItem都变成黑色的了，破坏了整体效果。 如果你只是换背景的颜色的话，可以直接指定android:cacheColorHint为你所要的颜色，如果你是用图片做背景的话，那也只要将android:cacheColorHint指定为透明（#00000000）就可以了 第四divider属性，该属性作用是每一项之间需要设置一个图片做为间隔，或是去掉item之间的分割线 android:divider=&quot;@drawable/list_driver&quot; 其中 @drawable/list_driver 是一个图片资源，如果不想显示分割线则只要设置为android:divider=&quot;@drawable/@null&quot; 就可以了 第五fadingEdge属性，上边和下边有黑色的阴影 android:fadingEdge=&quot;none&quot; 设置后没有阴影了~ 第六scrollbars属性，作用是隐藏listView的滚动条， android:scrollbars=&quot;none&quot;与setVerticalScrollBarEnabled(true);的效果是一样的，不活动的时候隐藏，活动的时候也隐藏 第七fadeScrollbars属性，android:fadeScrollbars=&quot;true&quot; 配置ListView布局的时候，设置这个属性为true就可以实现滚动条的自动隐藏和显示。 自定义View的方法常用方法 onFinishInflate() 当View中所有的子控件均被映射成xml后触发 onMeasure(int, int) 确定所有子元素的大小 onLayout(boolean, int, int, int, int) 当View分配所有的子元素的大小和位置时触发 onSizeChanged(int, int, int, int) 当view的大小发生变化时触发 onDraw(Canvas) view渲染内容的细节 onKeyDown(int, KeyEvent) 有按键按下后触发 onKeyUp(int, KeyEvent) 有按键按下后弹起时触发 onTrackballEvent(MotionEvent) 轨迹球事件 onTouchEvent(MotionEvent) 触屏事件 onFocusChanged(boolean, int, Rect) 当View获取或失去焦点时触发 onWindowFocusChanged(boolean) 当窗口包含的view获取或失去焦点时触发 onAttachedToWindow() 当view被附着到一个窗口时触发 onDetachedFromWindow() 当view离开附着的窗口时触发，提示该方法和 onAttachedToWindow() 是相反的。 onWindowVisibilityChanged(int) 当窗口中包含的可见的view发生变化时触发 公用方法 void addChildrenForAccessibility(ArrayList&lt;View&gt; outChildren)Adds the children of this View relevant for accessibility to the given list as output. void addExtraDataToAccessibilityNodeInfo(AccessibilityNodeInfo info, String extraDataKey, Bundle arguments)Adds extra data to an AccessibilityNodeInfo based on an explicit request for the additional data. void addFocusables(ArrayList&lt;View&gt; views, int direction)Add any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views. void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode)Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views. void addKeyboardNavigationClusters(Collection&lt;View&gt; views, int direction)Adds any keyboard navigation cluster roots that are descendants of this view (possibly including this view if it is a cluster root itself) to views. void addOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)Add a listener for attach state changes. void addOnLayoutChangeListener(View.OnLayoutChangeListener listener)Add a listener that will be called when the bounds of the view change due to layout processing. void addTouchables(ArrayList&lt;View&gt; views)Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself) to views. ViewPropertyAnimator animate()This method returns a ViewPropertyAnimator object, which can be used to animate specific properties on this View. void announceForAccessibility(CharSequence text)Convenience method for sending a TYPE_ANNOUNCEMENT AccessibilityEvent to make an announcement which is related to some sort of a context change for which none of the events representing UI transitions is a good fit. void autoFill(AutoFillValue value)Automatically fills the content of this view with the value. void autoFillVirtual(int virtualId, AutoFillValue value)Automatically fills the content of a virtual view with the valueSee autoFill(AutoFillValue) and onProvideAutoFillVirtualStructure(ViewStructure, int) for more info. void bringToFront()Change the view’s z order in the tree, so it’s on top of other sibling views. void buildDrawingCache(boolean autoScale)Forces the drawing cache to be built if the drawing cache is invalid. void buildDrawingCache()Calling this method is equivalent to calling buildDrawingCache(false). void buildLayer()Forces this view’s layer to be created and this view to be rendered into its layer. boolean callOnClick()Directly call any attached OnClickListener. boolean canResolveLayoutDirection()Check if layout direction resolution can be done. boolean canResolveTextAlignment()Check if text alignment resolution can be done. boolean canResolveTextDirection()Check if text direction resolution can be done. boolean canScrollHorizontally(int direction)Check if this view can be scrolled horizontally in a certain direction. boolean canScrollVertically(int direction)Check if this view can be scrolled vertically in a certain direction. final void cancelDragAndDrop()Cancels an ongoing drag and drop operation. void cancelLongPress()Cancels a pending long press. final void cancelPendingInputEvents()Cancel any deferred high-level input events that were previously posted to the event queue. boolean checkInputConnectionProxy(View view)Called by the InputMethodManager when a view who is not the current input connection target is trying to make a call on the manager. void clearAnimation()Cancels any animations for this view. void clearFocus()Called when this view wants to give up focus.static int combineMeasuredStates(int curState, int newState)Merge two states as returned by getMeasuredState(). void computeScroll()Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary. WindowInsets computeSystemWindowInsets(WindowInsets in, Rect outLocalInsets)Compute insets that should be consumed by this view and the ones that should propagate to those under it. AccessibilityNodeInfo createAccessibilityNodeInfo()Returns an AccessibilityNodeInfo representing this view from the point of view of an AccessibilityService. void createContextMenu(ContextMenu menu)Show the context menu for this view. void destroyDrawingCache()Frees the resources used by the drawing cache. WindowInsets dispatchApplyWindowInsets(WindowInsets insets)Request to apply the given window insets to this view or another view in its subtree. boolean dispatchCapturedPointerEvent(MotionEvent event)Pass a captured pointer event down to the focused view. void dispatchConfigurationChanged(Configuration newConfig)Dispatch a notification about a resource configuration change down the view hierarchy. void dispatchDisplayHint(int hint)Dispatch a hint about whether this view is displayed. boolean dispatchDragEvent(DragEvent event)Detects if this View is enabled and has a drag event listener. void dispatchDrawableHotspotChanged(float x, float y)Dispatches drawableHotspotChanged to all of this View’s children. void dispatchFinishTemporaryDetach()Dispatch onFinishTemporaryDetach() to this View and its direct children if this is a container View. boolean dispatchGenericMotionEvent(MotionEvent event)Dispatch a generic motion event. boolean dispatchKeyEvent(KeyEvent event)Dispatch a key event to the next view on the focus path. boolean dispatchKeyEventPreIme(KeyEvent event)Dispatch a key event before it is processed by any input method associated with the view hierarchy. boolean dispatchKeyShortcutEvent(KeyEvent event)Dispatches a key shortcut event. boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed)Dispatch a fling to a nested scrolling parent. boolean dispatchNestedPreFling(float velocityX, float velocityY)Dispatch a fling to a nested scrolling parent before it is processed by this view. boolean dispatchNestedPrePerformAccessibilityAction(int action, Bundle arguments)Report an accessibility action to this view’s parents for delegated processing. boolean dispatchNestedPreScroll(int dx, int dy, int[] consumed, int[] offsetInWindow)Dispatch one step of a nested scroll in progress before this view consumes any portion of it. boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)Dispatch one step of a nested scroll in progress. void dispatchPointerCaptureChanged(boolean hasCapture) boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event)Dispatches an AccessibilityEvent to the View first and then to its children for adding their text content to the event. void dispatchProvideAutoFillStructure(ViewStructure structure, int flags)Dispatch creation of ViewStructure down the hierarchy. void dispatchProvideStructure(ViewStructure structure)Dispatch creation of ViewStructure down the hierarchy. void dispatchStartTemporaryDetach()Dispatch onStartTemporaryDetach() to this View and its direct children if this is a container View. void dispatchSystemUiVisibilityChanged(int visibility)Dispatch callbacks to setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener) down the view hierarchy. boolean dispatchTouchEvent(MotionEvent event)Pass the touch screen motion event down to the target view, or this view if it is the target. boolean dispatchTrackballEvent(MotionEvent event)Pass a trackball motion event down to the focused view.boolean dispatchUnhandledMove(View focused, int direction)This method is the last chance for the focused view and its ancestors to respond to an arrow key. void dispatchWindowFocusChanged(boolean hasFocus)Called when the window containing this view gains or loses window focus. void dispatchWindowSystemUiVisiblityChanged(int visible)Dispatch callbacks to onWindowSystemUiVisibilityChanged(int) down the view hierarchy. void dispatchWindowVisibilityChanged(int visibility)Dispatch a window visibility change down the view hierarchy. void draw(Canvas canvas)Manually render this view (and all of its children) to the given Canvas. void drawableHotspotChanged(float x, float y)This function is called whenever the view hotspot changes and needs to be propagated to drawables or child views managed by the view. View findFocus()Find the view in the hierarchy rooted at this view that currently has focus. final &lt;T extends View&gt; T findViewById(int id)Look for a child view with the given id. final &lt;T extends View&gt; T findViewWithTag(Object tag)Look for a child view with the given tag. void findViewsWithText(ArrayList&lt;View&gt; outViews, CharSequence searched, int flags)Finds the Views that contain given text. View focusSearch(int direction)Find the nearest view in the specified direction that can take focus. void forceHasOverlappingRendering(boolean hasOverlappingRendering)Sets the behavior for overlapping rendering for this view (see hasOverlappingRendering() for more details on this behavior). void forceLayout()Forces this view to be laid out during the next layout pass. static int generateViewId()Generate a value suitable for use in setId(int). CharSequence getAccessibilityClassName()Return the class name of this object to be used for accessibility purposes. int getAccessibilityLiveRegion()Gets the live region mode for this View. AccessibilityNodeProvider getAccessibilityNodeProvider()Gets the provider for managing a virtual view hierarchy rooted at this View and reported to AccessibilityServices that explore the window content. int getAccessibilityTraversalAfter()Gets the id of a view after which this one is visited in accessibility traversal. int getAccessibilityTraversalBefore()Gets the id of a view before which this one is visited in accessibility traversal. float getAlpha()The opacity of the view. Animation getAnimation()Get the animation currently associated with this view. IBinder getApplicationWindowToken()Retrieve a unique token identifying the top-level “real” window of the window that this view is attached to. int getAutoFillMode()Returns the auto-fill mode for this view. AutoFillType getAutoFillType()Describes the auto-fill type that should be used on calls to autoFill(AutoFillValue) and autoFillVirtual(int, AutoFillValue). AutoFillValue getAutoFillValue()Gets the View’s current auto-fill value. Drawable getBackground()Gets the background drawable ColorStateList getBackgroundTintList()Return the tint applied to the background drawable, if specified. PorterDuff.Mode getBackgroundTintMode()Return the blending mode used to apply the tint to the background drawable, if specified. int getBaseline()Return the offset of the widget’s text baseline from the widget’s top boundary. final int getBottom()Bottom position of this view relative to its parent. float getCameraDistance()Gets the distance along the Z axis from the camera to this view. boolean getClipBounds(Rect outRect)Populates an output rectangle with the clip bounds of the view, returning true if successful or false if the view’s clip bounds are null. Rect getClipBounds()Returns a copy of the current clipBounds. final boolean getClipToOutline()Returns whether the Outline should be used to clip the contents of the View. CharSequence getContentDescription()Returns the View’s content description. final Context getContext()Returns the context the view is running in, through which it can access the current theme, resources, etc. static int getDefaultSize(int size, int measureSpec)Utility to return a default size. Display getDisplay()Gets the logical display to which the view’s window has been attached. final int[] getDrawableState()Return an array of resource IDs of the drawable states representing the current state of the view. Bitmap getDrawingCache()Calling this method is equivalent to calling getDrawingCache(false). Bitmap getDrawingCache(boolean autoScale)Returns the bitmap in which this view drawing is cached. int getDrawingCacheBackgroundColor() int getDrawingCacheQuality()Returns the quality of the drawing cache. void getDrawingRect(Rect outRect)Return the visible drawing bounds of your view. long getDrawingTime()Return the time at which the drawing of the view hierarchy started. float getElevation()The base elevation of this view relative to its parent, in pixels. boolean getFilterTouchesWhenObscured()Gets whether the framework should discard touches when the view’s window is obscured by another visible window. boolean getFitsSystemWindows()Check for state of setFitsSystemWindows(boolean). int getFocusable()Returns the focusable setting for this view. ArrayList&lt;View&gt; getFocusables(int direction)Find and return all focusable views that are descendants of this view, possibly including this view if it is focusable itself. void getFocusedRect(Rect r)When a view has focus and the user navigates away from it, the next view is searched for starting from the rectangle filled in by this method. Drawable getForeground()Returns the drawable used as the foreground of this View. int getForegroundGravity()Describes how the foreground is positioned. ColorStateList getForegroundTintList()Return the tint applied to the foreground drawable, if specified. PorterDuff.Mode getForegroundTintMode()Return the blending mode used to apply the tint to the foreground drawable, if specified. final boolean getGlobalVisibleRect(Rect r) boolean getGlobalVisibleRect(Rect r, Point globalOffset)If some part of this view is not clipped by any of its parents, then return that area in r in global (root) coordinates. Handler getHandler() final boolean getHasOverlappingRendering()Returns the value for overlapping rendering that is used internally. final int getHeight()Return the height of your view. void getHitRect(Rect outRect)Hit rectangle in parent’s coordinates int getHorizontalFadingEdgeLength()Returns the size of the horizontal faded edges used to indicate that more content in this view is visible. int getId()Returns this view’s identifier.int getImportantForAccessibility()Gets the mode for determining whether this View is important for accessibility. boolean getKeepScreenOn()Returns whether the screen should remain on, corresponding to the current value of KEEP_SCREEN_ON. KeyEvent.DispatcherState getKeyDispatcherState()Return the global KeyEvent.DispatcherState for this view’s window. int getLabelFor()Gets the id of a view for which this view serves as a label for accessibility purposes. int getLayerType()Indicates what type of layer is currently associated with this view. int getLayoutDirection()Returns the resolved layout direction for this view. ViewGroup.LayoutParams getLayoutParams()Get the LayoutParams associated with this view. final int getLeft()Left position of this view relative to its parent. final boolean getLocalVisibleRect(Rect r) void getLocationInWindow(int[] outLocation)Computes the coordinates of this view in its window. void getLocationOnScreen(int[] outLocation)Computes the coordinates of this view on the screen. Matrix getMatrix()The transform matrix of this view, which is calculated based on the current rotation, scale, and pivot properties. final int getMeasuredHeight()Like getMeasuredHeightAndState(), but only returns the raw height component (that is the result is masked by MEASURED_SIZE_MASK). final int getMeasuredHeightAndState()Return the full height measurement information for this view as computed by the most recent call to measure(int, int). final int getMeasuredState()Return only the state bits of getMeasuredWidthAndState() and getMeasuredHeightAndState(), combined into one integer. final int getMeasuredWidth()Like getMeasuredWidthAndState(), but only returns the raw width component (that is the result is masked by MEASURED_SIZE_MASK). final int getMeasuredWidthAndState()Return the full width measurement information for this view as computed by the most recent call to measure(int, int). int getMinimumHeight()Returns the minimum height of the view. int getMinimumWidth()Returns the minimum width of the view. int getNextClusterForwardId()Gets the id of the root of the next keyboard navigation cluster. int getNextFocusDownId()Gets the id of the view to use when the next focus is FOCUS_DOWN. int getNextFocusForwardId()Gets the id of the view to use when the next focus is FOCUS_FORWARD. int getNextFocusLeftId()Gets the id of the view to use when the next focus is FOCUS_LEFT. int getNextFocusRightId()Gets the id of the view to use when the next focus is FOCUS_RIGHT. int getNextFocusUpId()Gets the id of the view to use when the next focus is FOCUS_UP.View.OnFocusChangeListener getOnFocusChangeListener()Returns the focus-change callback registered for this view. ViewOutlineProvider getOutlineProvider()Returns the current ViewOutlineProvider of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping. int getOverScrollMode()Returns the over-scroll mode for this view. ViewOverlay getOverlay()Returns the overlay for this view, creating it if it does not yet exist. int getPaddingBottom()Returns the bottom padding of this view. int getPaddingEnd()Returns the end padding of this view depending on its resolved layout direction. int getPaddingLeft()Returns the left padding of this view. int getPaddingRight()Returns the right padding of this view. int getPaddingStart()Returns the start padding of this view depending on its resolved layout direction. int getPaddingTop()Returns the top padding of this view. final ViewParent getParent()Gets the parent of this view. ViewParent getParentForAccessibility()Gets the parent for accessibility purposes. float getPivotX()The x location of the point around which the view is rotated and scaled. float getPivotY()The y location of the point around which the view is rotated and scaled. PointerIcon getPointerIcon()Gets the pointer icon for the current view. Resources getResources()Returns the resources associated with this view. final boolean getRevealOnFocusHint()Returns this view’s preference for reveal behavior when it gains focus. final int getRight()Right position of this view relative to its parent. View getRootView()Finds the topmost view in the current view hierarchy. WindowInsets getRootWindowInsets()Provide original WindowInsets that are dispatched to the view hierarchy. float getRotation()The degrees that the view is rotated around the pivot point. float getRotationX()The degrees that the view is rotated around the horizontal axis through the pivot point. float getRotationY()The degrees that the view is rotated around the vertical axis through the pivot point. float getScaleX()The amount that the view is scaled in x around the pivot point, as a proportion of the view’s unscaled width. float getScaleY()The amount that the view is scaled in y around the pivot point, as a proportion of the view’s unscaled height. int getScrollBarDefaultDelayBeforeFade()Returns the delay before scrollbars fade. int getScrollBarFadeDuration()Returns the scrollbar fade duration. int getScrollBarSize()Returns the scrollbar size. int getScrollBarStyle()Returns the current scrollbar style. int getScrollIndicators()Returns a bitmask representing the enabled scroll indicators. final int getScrollX()Return the scrolled left position of this view. final int getScrollY()Return the scrolled top position of this view. int getSolidColor()Override this if your view is known to always be drawn on top of a solid color background, and needs to draw fading edges.StateListAnimator getStateListAnimator()Returns the current StateListAnimator if exists. int getSystemUiVisibility()Returns the last setSystemUiVisibility(int) that this view has requested. Object getTag()Returns this view’s tag. Object getTag(int key)Returns the tag associated with this view and the specified key. int getTextAlignment()Return the resolved text alignment. int getTextDirection()Return the resolved text direction. CharSequence getTooltipText()Returns the view’s tooltip text. final int getTop()Top position of this view relative to its parent. TouchDelegate getTouchDelegate()Gets the TouchDelegate for this View. ArrayList&lt;View&gt; getTouchables()Find and return all touchable views that are descendants of this view, possibly including this view if it is touchable itself. String getTransitionName()Returns the name of the View to be used to identify Views in Transitions. float getTranslationX()The horizontal location of this view relative to its left position. float getTranslationY()The vertical location of this view relative to its top position. float getTranslationZ()The depth location of this view relative to its elevation. int getVerticalFadingEdgeLength()Returns the size of the vertical faded edges used to indicate that more content in this view is visible. int getVerticalScrollbarPosition() int getVerticalScrollbarWidth()Returns the width of the vertical scrollbar. ViewTreeObserver getViewTreeObserver()Returns the ViewTreeObserver for this view’s hierarchy. int getVisibility()Returns the visibility status for this view. final int getWidth()Return the width of the your view. WindowId getWindowId()Retrieve the WindowId for the window this view is currently attached to. int getWindowSystemUiVisibility()Returns the current system UI visibility that is currently set for the entire window. IBinder getWindowToken()Retrieve a unique token identifying the window this view is attached to. int getWindowVisibility()Returns the current visibility of the window this view is attached to (either GONE, INVISIBLE, or VISIBLE). void getWindowVisibleDisplayFrame(Rect outRect)Retrieve the overall visible display size in which the window this view is attached to has been positioned in. float getX()The visual x position of this view, in pixels. float getY()The visual y position of this view, in pixels. float getZ()The visual z position of this view, in pixels. boolean hasExplicitFocusable()Returns true if this view is focusable or if it contains a reachable View for which hasExplicitFocusable() returns true. boolean hasFocus()Returns true if this view has focus itself, or is the ancestor of the view that has focus. boolean hasFocusable()Returns true if this view is focusable or if it contains a reachable View for which hasFocusable() returns true. boolean hasNestedScrollingParent()Returns true if this view has a nested scrolling parent. boolean hasOnClickListeners()Return whether this view has an attached OnClickListener. boolean hasOverlappingRendering()Returns whether this View has content which overlaps. boolean hasPointerCapture()Checks pointer capture status. boolean hasTransientState()Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible. boolean hasWindowFocus()Returns true if this view is in a window that currently has window focus. static View inflate(Context context, int resource, ViewGroup root)Inflate a view from an XML resource. void invalidate()Invalidate the whole view. void invalidate(Rect dirty)Mark the area defined by dirty as needing to be drawn. void invalidate(int l, int t, int r, int b)Mark the area defined by the rect (l,t,r,b) as needing to be drawn. void invalidateDrawable(Drawable drawable)Invalidates the specified Drawable. void invalidateOutline()Called to rebuild this View’s Outline from its outline provider boolean isAccessibilityFocused()Returns whether this View is accessibility focused. boolean isActivated()Indicates the activation state of this view. boolean isAttachedToWindow()Returns true if this view is currently attached to a window. boolean isClickable()Indicates whether this view reacts to click events or not. boolean isContextClickable()Indicates whether this view reacts to context clicks or not. boolean isDirty()True if this view has changed since the last time being drawn. boolean isDrawingCacheEnabled()Indicates whether the drawing cache is enabled for this view. boolean isDuplicateParentStateEnabled()Indicates whether this duplicates its drawable state from its parent. boolean isEnabled()Returns the enabled status for this view. final boolean isFocusable()Returns whether this View is currently able to take focus. final boolean isFocusableInTouchMode()When a view is focusable, it may not want to take focus when in touch mode. boolean isFocused()Returns true if this view has focus final boolean isFocusedByDefault()Returns whether this View should receive focus when the focus is restored for the view hierarchy containing this view. boolean isHapticFeedbackEnabled() boolean isHardwareAccelerated()Indicates whether this view is attached to a hardware accelerated window or not. boolean isHorizontalFadingEdgeEnabled()Indicate whether the horizontal edges are faded when the view is scrolled horizontally. boolean isHorizontalScrollBarEnabled()Indicate whether the horizontal scrollbar should be drawn or not. boolean isHovered()Returns true if the view is currently hovered. boolean isImportantForAccessibility()Computes whether this view should be exposed for accessibility. boolean isInEditMode()Indicates whether this View is currently in edit mode. boolean isInLayout()Returns whether the view hierarchy is currently undergoing a layout pass. boolean isInTouchMode()Returns whether the device is currently in touch mode. final boolean isKeyboardNavigationCluster()Returns whether this View is a root of a keyboard navigation cluster. boolean isLaidOut()Returns true if this view has been through at least one layout since it was last attached to or detached from a window. boolean isLayoutDirectionResolved() boolean isLayoutRequested()Indicates whether or not this view’s layout will be requested during the next hierarchy layout pass. boolean isLongClickable()Indicates whether this view reacts to long click events or not. boolean isNestedScrollingEnabled()Returns true if nested scrolling is enabled for this view. boolean isOpaque()Indicates whether this View is opaque. boolean isPaddingRelative()Return if the padding has been set through relative values setPaddingRelative(int, int, int, int) or through boolean isPressed()Indicates whether the view is currently in pressed state. boolean isSaveEnabled()Indicates whether this view will save its state (that is, whether its onSaveInstanceState() method will be called). boolean isSaveFromParentEnabled()Indicates whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent. boolean isScrollContainer()Indicates whether this view is one of the set of scrollable containers in its window. boolean isScrollbarFadingEnabled()Returns true if scrollbars will fade when this view is not scrolling boolean isSelected()Indicates the selection state of this view. boolean isShown()Returns the visibility of this view and all of its ancestors boolean isSoundEffectsEnabled() final boolean isTemporarilyDetached()Tells whether the View is in the state between onStartTemporaryDetach() and onFinishTemporaryDetach(). boolean isTextAlignmentResolved() boolean isTextDirectionResolved() boolean isVerticalFadingEdgeEnabled()Indicate whether the vertical edges are faded when the view is scrolled horizontally. boolean isVerticalScrollBarEnabled()Indicate whether the vertical scrollbar should be drawn or not. void jumpDrawablesToCurrentState()Call Drawable.jumpToCurrentState() on all Drawable objects associated with this view. View keyboardNavigationClusterSearch(View currentCluster, int direction)Find the nearest keyboard navigation cluster in the specified direction. void layout(int l, int t, int r, int b)Assign a size and position to a view and all of its descendantsThis is the second phase of the layout mechanism. final void measure(int widthMeasureSpec, int heightMeasureSpec)This is called to find out how big a view should be. void offsetLeftAndRight(int offset)Offset this view’s horizontal location by the specified amount of pixels. void offsetTopAndBottom(int offset)Offset this view’s vertical location by the specified number of pixels. WindowInsets onApplyWindowInsets(WindowInsets insets)Called when the view should apply WindowInsets according to its internal policy. void onCancelPendingInputEvents()Called as the result of a call to cancelPendingInputEvents() on this view or a parent view. boolean onCapturedPointerEvent(MotionEvent event)Implement this method to handle captured pointer events boolean onCheckIsTextEditor()Check whether the called view is a text editor, in which case it would make sense to automatically display a soft input window for it. InputConnection onCreateInputConnection(EditorInfo outAttrs)Create a new InputConnection for an InputMethod to interact with the view. boolean onDragEvent(DragEvent event)Handles drag events sent by the system following a call to startDragAndDrop(). void onDrawForeground(Canvas canvas)Draw any foreground content for this view. boolean onFilterTouchEventForSecurity(MotionEvent event)Filter the touch event to apply security policies. void onFinishTemporaryDetach()Called after onStartTemporaryDetach() when the container is done changing the view. boolean onGenericMotionEvent(MotionEvent event)Implement this method to handle generic motion events. void onHoverChanged(boolean hovered)Implement this method to handle hover state changes. boolean onHoverEvent(MotionEvent event)Implement this method to handle hover events. void onInitializeAccessibilityEvent(AccessibilityEvent event)Initializes an AccessibilityEvent with information about this View which is the event source. void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info)Initializes an AccessibilityNodeInfo with information about this view. boolean onKeyDown(int keyCode, KeyEvent event)Default implementation of KeyEvent.Callback.onKeyDown(): perform press of the view when KEYCODE_DPAD_CENTER or KEYCODE_ENTER is released, if the view is enabled and clickable. boolean onKeyLongPress(int keyCode, KeyEvent event)Default implementation of KeyEvent.Callback.onKeyLongPress(): always returns false (doesn’t handle the event). boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event)Default implementation of KeyEvent.Callback.onKeyMultiple(): always returns false (doesn’t handle the event). boolean onKeyPreIme(int keyCode, KeyEvent event)Handle a key event before it is processed by any input method associated with the view hierarchy. boolean onKeyShortcut(int keyCode, KeyEvent event)Called on the focused view when a key shortcut event is not handled. boolean onKeyUp(int keyCode, KeyEvent event)Default implementation of KeyEvent.Callback.onKeyUp(): perform clicking of the view when KEYCODE_DPAD_CENTER, KEYCODE_ENTER or KEYCODE_SPACE is released. void onMovedToDisplay(int displayId)Called by the system when the hosting activity is moved from one display to another without recreation. void onPointerCaptureChange(boolean hasCapture)Called when the window has just acquired or lost pointer capture. void onPopulateAccessibilityEvent(AccessibilityEvent event)Called from dispatchPopulateAccessibilityEvent(AccessibilityEvent) giving a chance to this View to populate the accessibility event with its text content. void onProvideAutoFillStructure(ViewStructure structure, int flags)Called when assist structure is being retrieved from a view as part of an auto-fill request. void onProvideAutoFillVirtualStructure(ViewStructure structure, int flags)Called when assist structure is being retrieved from a view as part of an auto-fill request to generate additional virtual structure under this view. void onProvideStructure(ViewStructure structure)Called when assist structure is being retrieved from a view as part of Activity.onProvideAssistData. void onProvideVirtualStructure(ViewStructure structure)Called when assist structure is being retrieved from a view as part of Activity.onProvideAssistData to generate additional virtual structure under this view. PointerIcon onResolvePointerIcon(MotionEvent event, int pointerIndex)Returns the pointer icon for the motion event, or null if it doesn’t specify the icon. void onRtlPropertiesChanged(int layoutDirection)Called when any RTL property (layout direction or text direction or text alignment) has been changed. void onScreenStateChanged(int screenState)This method is called whenever the state of the screen this view is attached to changes. void onStartTemporaryDetach()This is called when a container is going to temporarily detach a child, with ViewGroup.detachViewFromParent. boolean onTouchEvent(MotionEvent event)Implement this method to handle touch screen motion events. boolean onTrackballEvent(MotionEvent event)Implement this method to handle trackball motion events. void onVisibilityAggregated(boolean isVisible)Called when the user-visibility of this View is potentially affected by a change to this view itself, an ancestor view or the window this view is attached to. void onWindowFocusChanged(boolean hasWindowFocus)Called when the window containing this view gains or loses focus. void onWindowSystemUiVisibilityChanged(int visible)Override to find out when the window’s requested system UI visibility has changed, that is the value returned by getWindowSystemUiVisibility(). boolean performAccessibilityAction(int action, Bundle arguments)Performs the specified accessibility action on the view. boolean performClick()Call this view’s OnClickListener, if it is defined. boolean performContextClick(float x, float y)Call this view’s OnContextClickListener, if it is defined. boolean performContextClick()Call this view’s OnContextClickListener, if it is defined. boolean performHapticFeedback(int feedbackConstant)Provide haptic feedback to the user for this view. boolean performHapticFeedback(int feedbackConstant, int flags)Like performHapticFeedback(int), with additional options. boolean performLongClick(float x, float y)Calls this view’s OnLongClickListener, if it is defined. boolean performLongClick()Calls this view’s OnLongClickListener, if it is defined. void playSoundEffect(int soundConstant)Play a sound effect for this view. boolean post(Runnable action)Causes the Runnable to be added to the message queue. boolean postDelayed(Runnable action, long delayMillis)Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses. void postInvalidate()Cause an invalidate to happen on a subsequent cycle through the event loop. void postInvalidate(int left, int top, int right, int bottom)Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop. void postInvalidateDelayed(long delayMilliseconds, int left, int top, int right, int bottom)Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop. void postInvalidateDelayed(long delayMilliseconds)Cause an invalidate to happen on a subsequent cycle through the event loop. void postInvalidateOnAnimation(int left, int top, int right, int bottom)Cause an invalidate of the specified area to happen on the next animation time step, typically the next display frame. void postInvalidateOnAnimation()Cause an invalidate to happen on the next animation time step, typically the next display frame. void postOnAnimation(Runnable action)Causes the Runnable to execute on the next animation time step.void postOnAnimationDelayed(Runnable action, long delayMillis)Causes the Runnable to execute on the next animation time step, after the specified amount of time elapses. void refreshDrawableState()Call this to force a view to update its drawable state. void releasePointerCapture()Releases the pointer capture. boolean removeCallbacks(Runnable action)Removes the specified Runnable from the message queue. void removeOnAttachStateChangeListener(View.OnAttachStateChangeListener listener)Remove a listener for attach state changes. void removeOnLayoutChangeListener(View.OnLayoutChangeListener listener)Remove a listener for layout changes. void requestApplyInsets()Ask that a new dispatch of onApplyWindowInsets(WindowInsets) be performed. void requestFitSystemWindows()This method was deprecated in API level 20. Use requestApplyInsets() for newer platform versions. final boolean requestFocus(int direction)Call this to try to give focus to a specific view or to one of its descendants and give it a hint about what direction focus is heading. final boolean requestFocus()Call this to try to give focus to a specific view or to one of its descendants. boolean requestFocus(int direction, Rect previouslyFocusedRect)Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from. final boolean requestFocusFromTouch()Call this to try to give focus to a specific view or to one of its descendants. void requestLayout()Call this when something has changed which has invalidated the layout of this view. void requestPointerCapture()Requests pointer capture mode. boolean requestRectangleOnScreen(Rect rectangle)Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough. boolean requestRectangleOnScreen(Rect rectangle, boolean immediate)Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough. final void requestUnbufferedDispatch(MotionEvent event)Request unbuffered dispatch of the given stream of MotionEvents to this View. static int resolveSize(int size, int measureSpec)Version of resolveSizeAndState(int, int, int) returning only the MEASURED_SIZE_MASK bits of the result. static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState)Utility to reconcile a desired size and state, with constraints imposed by a MeasureSpec. boolean restoreDefaultFocus()Gives focus to the default-focus view in the view hierarchy that has this view as a root. void restoreHierarchyState(SparseArray&lt;Parcelable&gt; container)Restore this view hierarchy’s frozen state from the given container. void saveHierarchyState(SparseArray&lt;Parcelable&gt; container)Store this view hierarchy’s frozen state into the given container. void scheduleDrawable(Drawable who, Runnable what, long when)Schedules an action on a drawable to occur at a specified time. void scrollBy(int x, int y)Move the scrolled position of your view. void scrollTo(int x, int y)Set the scrolled position of your view. void sendAccessibilityEvent(int eventType)Sends an accessibility event of the given type. void sendAccessibilityEventUnchecked(AccessibilityEvent event)This method behaves exactly as sendAccessibilityEvent(int) but takes as an argument an empty AccessibilityEvent and does not perform a check whether accessibility is enabled. void setAccessibilityDelegate(View.AccessibilityDelegate delegate)Sets a delegate for implementing accessibility support via composition (as opposed to inheritance). void setAccessibilityLiveRegion(int mode)Sets the live region mode for this view. void setAccessibilityTraversalAfter(int afterId)Sets the id of a view after which this one is visited in accessibility traversal. void setAccessibilityTraversalBefore(int beforeId)Sets the id of a view before which this one is visited in accessibility traversal. void setActivated(boolean activated)Changes the activated state of this view. void setAlpha(float alpha)Sets the opacity of the view to a value from 0 to 1, where 0 means the view is completely transparent and 1 means the view is completely opaque. void setAnimation(Animation animation)Sets the next animation to play for this view. void setAutoFillMode(int autoFillMode)Set auto-fill mode for the view. void setBackground(Drawable background)Set the background to a given Drawable, or remove the background. void setBackgroundColor(int color)Sets the background color for this view. void setBackgroundDrawable(Drawable background)This method was deprecated in API level 16. use setBackground(Drawable) instead void setBackgroundResource(int resid)Set the background to a given resource. void setBackgroundTintList(ColorStateList tint)Applies a tint to the background drawable. void setBackgroundTintMode(PorterDuff.Mode tintMode)Specifies the blending mode used to apply the tint specified by setBackgroundTintList(ColorStateList)} to the background drawable. final void setBottom(int bottom)Sets the bottom position of this view relative to its parent. void setCameraDistance(float distance)Sets the distance along the Z axis (orthogonal to the X/Y plane on which views are drawn) from the camera to this view. void setClickable(boolean clickable)Enables or disables click events for this view. void setClipBounds(Rect clipBounds)Sets a rectangular area on this view to which the view will be clipped when it is drawn. void setClipToOutline(boolean clipToOutline)Sets whether the View’s Outline should be used to clip the contents of the View. void setContentDescription(CharSequence contentDescription)Sets the View’s content description. void setContextClickable(boolean contextClickable)Enables or disables context clicking for this view. void setDrawingCacheBackgroundColor(int color)Setting a solid background color for the drawing cache’s bitmaps will improve performance and memory usage. void setDrawingCacheEnabled(boolean enabled)Enables or disables the drawing cache. void setDrawingCacheQuality(int quality)Set the drawing cache quality of this view. void setDuplicateParentStateEnabled(boolean enabled)Enables or disables the duplication of the parent’s state into this view. void setElevation(float elevation)Sets the base elevation of this view, in pixels. void setEnabled(boolean enabled)Set the enabled state of this view. void setFadingEdgeLength(int length)Set the size of the faded edge used to indicate that more content in this view is available. void setFilterTouchesWhenObscured(boolean enabled)Sets whether the framework should discard touches when the view’s window is obscured by another visible window. void setFitsSystemWindows(boolean fitSystemWindows)Sets whether or not this view should account for system screen decorations such as the status bar and inset its content; that is, controlling whether the default implementation of fitSystemWindows(Rect) will be executed. void setFocusable(boolean focusable)Set whether this view can receive the focus. void setFocusable(int focusable)Sets whether this view can receive focus. void setFocusableInTouchMode(boolean focusableInTouchMode)Set whether this view can receive focus while in touch mode. void setFocusedByDefault(boolean isFocusedByDefault)Sets whether this View should receive focus when the focus is restored for the view hierarchy containing this view. void setForeground(Drawable foreground)Supply a Drawable that is to be rendered on top of all of the content in the view. void setForegroundGravity(int gravity)Describes how the foreground is positioned. void setForegroundTintList(ColorStateList tint)Applies a tint to the foreground drawable. void setForegroundTintMode(PorterDuff.Mode tintMode)Specifies the blending mode used to apply the tint specified by setForegroundTintList(ColorStateList)} to the background drawable. void setHapticFeedbackEnabled(boolean hapticFeedbackEnabled)Set whether this view should have haptic feedback for events such as long presses. void setHasTransientState(boolean hasTransientState)Set whether this view is currently tracking transient state that the framework should attempt to preserve when possible. void setHorizontalFadingEdgeEnabled(boolean horizontalFadingEdgeEnabled)Define whether the horizontal edges should be faded when this view is scrolled horizontally. void setHorizontalScrollBarEnabled(boolean horizontalScrollBarEnabled)Define whether the horizontal scrollbar should be drawn or not. void setHovered(boolean hovered)Sets whether the view is currently hovered. void setId(int id)Sets the identifier for this view. void setImportantForAccessibility(int mode)Sets how to determine whether this view is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen. void setKeepScreenOn(boolean keepScreenOn)Controls whether the screen should remain on, modifying the value of KEEP_SCREEN_ON. void setKeyboardNavigationCluster(boolean isCluster)Set whether this view is a root of a keyboard navigation cluster. void setLabelFor(int id)Sets the id of a view for which this view serves as a label for accessibility purposes. void setLayerPaint(Paint paint)Updates the Paint object used with the current layer (used only if the current layer type is not set to LAYER_TYPE_NONE). void setLayerType(int layerType, Paint paint)Specifies the type of layer backing this view. void setLayoutDirection(int layoutDirection)Set the layout direction for this view. void setLayoutParams(ViewGroup.LayoutParams params)Set the layout parameters associated with this view. final void setLeft(int left)Sets the left position of this view relative to its parent. void setLongClickable(boolean longClickable)Enables or disables long click events for this view. void setMinimumHeight(int minHeight)Sets the minimum height of the view. void setMinimumWidth(int minWidth)Sets the minimum width of the view. void setNestedScrollingEnabled(boolean enabled)Enable or disable nested scrolling for this view. void setNextClusterForwardId(int nextClusterForwardId)Sets the id of the view to use as the root of the next keyboard navigation cluster. void setNextFocusDownId(int nextFocusDownId)Sets the id of the view to use when the next focus is FOCUS_DOWN. void setNextFocusForwardId(int nextFocusForwardId)Sets the id of the view to use when the next focus is FOCUS_FORWARD. void setNextFocusLeftId(int nextFocusLeftId)Sets the id of the view to use when the next focus is FOCUS_LEFT. void setNextFocusRightId(int nextFocusRightId)Sets the id of the view to use when the next focus is FOCUS_RIGHT. void setNextFocusUpId(int nextFocusUpId)Sets the id of the view to use when the next focus is FOCUS_UP. void setOnApplyWindowInsetsListener(View.OnApplyWindowInsetsListener listener)Set an View.OnApplyWindowInsetsListener to take over the policy for applying window insets to this view. void setOnCapturedPointerListener(View.OnCapturedPointerListener l)Set a listener to receive callbacks when the pointer capture state of a view changes. void setOnClickListener(View.OnClickListener l)Register a callback to be invoked when this view is clicked. void setOnContextClickListener(View.OnContextClickListener l)Register a callback to be invoked when this view is context clicked. void setOnCreateContextMenuListener(View.OnCreateContextMenuListener l)Register a callback to be invoked when the context menu for this view is being built. void setOnDragListener(View.OnDragListener l)Register a drag event listener callback object for this View. void setOnFocusChangeListener(View.OnFocusChangeListener l)Register a callback to be invoked when focus of this view changed. void setOnGenericMotionListener(View.OnGenericMotionListener l)Register a callback to be invoked when a generic motion event is sent to this view. void setOnHoverListener(View.OnHoverListener l)Register a callback to be invoked when a hover event is sent to this view. void setOnKeyListener(View.OnKeyListener l)Register a callback to be invoked when a hardware key is pressed in this view. void setOnLongClickListener(View.OnLongClickListener l)Register a callback to be invoked when this view is clicked and held. void setOnScrollChangeListener(View.OnScrollChangeListener l)Register a callback to be invoked when the scroll X or Y positions of this view change. void setOnSystemUiVisibilityChangeListener(View.OnSystemUiVisibilityChangeListener l)Set a listener to receive callbacks when the visibility of the system bar changes. void setOnTouchListener(View.OnTouchListener l)Register a callback to be invoked when a touch event is sent to this view. void setOutlineProvider(ViewOutlineProvider provider)Sets the ViewOutlineProvider of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping. void setOverScrollMode(int overScrollMode)Set the over-scroll mode for this view. void setPadding(int left, int top, int right, int bottom)Sets the padding. void setPaddingRelative(int start, int top, int end, int bottom)Sets the relative padding. void setPivotX(float pivotX)Sets the x location of the point around which the view is rotated and scaled. void setPivotY(float pivotY)Sets the y location of the point around which the view is rotated and scaled. void setPointerIcon(PointerIcon pointerIcon)Set the pointer icon for the current view. void setPressed(boolean pressed)Sets the pressed state for this view. final void setRevealOnFocusHint(boolean revealOnFocus)Sets this view’s preference for reveal behavior when it gains focus. final void setRight(int right)Sets the right position of this view relative to its parent. void setRotation(float rotation)Sets the degrees that the view is rotated around the pivot point. void setRotationX(float rotationX)Sets the degrees that the view is rotated around the horizontal axis through the pivot point. void setRotationY(float rotationY)Sets the degrees that the view is rotated around the vertical axis through the pivot point. void setSaveEnabled(boolean enabled)Controls whether the saving of this view’s state is enabled (that is, whether its onSaveInstanceState() method will be called). void setSaveFromParentEnabled(boolean enabled)Controls whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent. void setScaleX(float scaleX)Sets the amount that the view is scaled in x around the pivot point, as a proportion of the view’s unscaled width. void setScaleY(float scaleY)Sets the amount that the view is scaled in Y around the pivot point, as a proportion of the view’s unscaled width. void setScrollBarDefaultDelayBeforeFade(int scrollBarDefaultDelayBeforeFade)Define the delay before scrollbars fade. void setScrollBarFadeDuration(int scrollBarFadeDuration)Define the scrollbar fade duration. void setScrollBarSize(int scrollBarSize)Define the scrollbar size. void setScrollBarStyle(int style)Specify the style of the scrollbars. void setScrollContainer(boolean isScrollContainer)Change whether this view is one of the set of scrollable containers in its window. void setScrollIndicators(int indicators, int mask)Sets the state of the scroll indicators specified by the mask. void setScrollIndicators(int indicators)Sets the state of all scroll indicators. void setScrollX(int value)Set the horizontal scrolled position of your view. void setScrollY(int value)Set the vertical scrolled position of your view. void setScrollbarFadingEnabled(boolean fadeScrollbars)Define whether scrollbars will fade when the view is not scrolling. void setSelected(boolean selected)Changes the selection state of this view. void setSoundEffectsEnabled(boolean soundEffectsEnabled)Set whether this view should have sound effects enabled for events such as clicking and touching. void setStateListAnimator(StateListAnimator stateListAnimator)Attaches the provided StateListAnimator to this View. void setSystemUiVisibility(int visibility)Request that the visibility of the status bar or other screen/window decorations be changed. void setTag(int key, Object tag)Sets a tag associated with this view and a key. void setTag(Object tag)Sets the tag associated with this view. void setTextAlignment(int textAlignment)Set the text alignment. void setTextDirection(int textDirection)Set the text direction. void setTooltipText(CharSequence tooltipText)Sets the tooltip text which will be displayed in a small popup next to the view. final void setTop(int top)Sets the top position of this view relative to its parent. void setTouchDelegate(TouchDelegate delegate)Sets the TouchDelegate for this View. final void setTransitionName(String transitionName)Sets the name of the View to be used to identify Views in Transitions. void setTranslationX(float translationX)Sets the horizontal location of this view relative to its left position. void setTranslationY(float translationY)Sets the vertical location of this view relative to its top position. void setTranslationZ(float translationZ)Sets the depth location of this view relative to its elevation. void setVerticalFadingEdgeEnabled(boolean verticalFadingEdgeEnabled)Define whether the vertical edges should be faded when this view is scrolled vertically. void setVerticalScrollBarEnabled(boolean verticalScrollBarEnabled)Define whether the vertical scrollbar should be drawn or not. void setVerticalScrollbarPosition(int position)Set the position of the vertical scroll bar. void setVisibility(int visibility)Set the visibility state of this view. void setWillNotCacheDrawing(boolean willNotCacheDrawing)When a View’s drawing cache is enabled, drawing is redirected to an offscreen bitmap. void setWillNotDraw(boolean willNotDraw)If this view doesn’t do any drawing on its own, set this flag to allow further optimizations. void setX(float x)Sets the visual x position of this view, in pixels. void setY(float y)Sets the visual y position of this view, in pixels. void setZ(float z)Sets the visual z position of this view, in pixels. boolean showContextMenu()Shows the context menu for this view. boolean showContextMenu(float x, float y)Shows the context menu for this view anchored to the specified view-relative coordinate. ActionMode startActionMode(ActionMode.Callback callback, int type)Start an action mode with the given type. ActionMode startActionMode(ActionMode.Callback callback)Start an action mode with the default type TYPE_PRIMARY. void startAnimation(Animation animation)Start the specified animation now. final boolean startDrag(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)This method was deprecated in API level 24. Use startDragAndDrop() for newer platform versions. final boolean startDragAndDrop(ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)Starts a drag and drop operation. boolean startNestedScroll(int axes)Begin a nestable scroll operation along the given axes. void stopNestedScroll()Stop a nested scroll in progress. String toString()Returns a string representation of the object. void unscheduleDrawable(Drawable who, Runnable what)Cancels a scheduled action on a drawable. void unscheduleDrawable(Drawable who)Unschedule any events associated with the given Drawable. final void updateDragShadow(View.DragShadowBuilder shadowBuilder)Updates the drag shadow for the ongoing drag and drop operation. boolean willNotCacheDrawing()Returns whether or not this View can cache its drawing or not. boolean willNotDraw()Returns whether or not this View draws on its own. 获取上级View的方法汇总12345getParent() //获取上一级ViewgetRootView //获取跟布局getWindow().getDecorView() findViewById(android.R.id.content)((ViewGroup)findViewById(android.R.id.content)).getChildAt(0) 方法介绍 getRootView特例布局(R.layout.list_empty)： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#FFFFFF"&gt; &lt;TextView android:id="@+id/name" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerVertical="true" android:layout_marginLeft="15dp" android:text="暂无数据" /&gt;&lt;/RelativeLayout&gt; 代码： 1234567final View view = View.inflate(this, R.layout.list_empty, null);final TextView name = (TextView) view.findViewById(R.id.name);System.out.println("before View.inflate name getParent " + name.getParent());System.out.println("before View.inflate name getRootView " + name.getRootView());addContentView(view, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT));System.out.println("after View.inflate name getParent " + name.getParent());System.out.println("after View.inflate name getRootView " + name.getRootView()); 12345结果：before View.inflate name getParent android.widget.RelativeLayout&#123;3d679e31 V.E..... ......ID 0,0-0,0&#125;before View.inflate name getRootView android.widget.RelativeLayout&#123;3d679e31 V.E..... ......ID 0,0-0,0&#125;after View.inflate name getParent android.widget.RelativeLayout&#123;3d679e31 V.E..... ......ID 0,0-0,0&#125;after View.inflate name getRootView com.android.internal.policy.impl.MultiPhoneWindow$MultiPhoneDecorView&#123;c535bb V.E..... R.....ID 0,0-0,0&#125; 结论：如果View在代码中通过View.inflate实例化，在没有添加到显示界面前，getRootView获得的是Xml的根布局。添加后getRootView获得的是MultiPhoneDecorView。 使用场景用途：状态栏、标题栏、键盘的高度 注意：以下代码不能在onCreate里面使用，否则获取的高度为0，你可以放在onWindowFocusChanged等等 状态栏高度：getDecorView的getWindowVisibleDisplayFrame方法可以获取到程序显示的区域，包括标题栏，但不包括状态栏。 于是，我们就可以算出状态栏的高度了。 123Rect frame = new Rect(); getWindow().getDecorView().getWindowVisibleDisplayFrame(frame); int statusBarHeight = frame.top; 标题栏高度findViewById(Android.R.id.content)是不包括标题栏的，我们可以通过它获取标题栏的高度。 123int contentTop = findViewById(android.R.id.content).getTop(); //statusBarHeight是上面所求的状态栏的高度 int titleBarHeight = contentTop - statusBarHeight; 键盘高度 键盘没打开时获取android.R.id.content的可见区域高度height1， 键盘打开时再获取android.R.id.content的可见区域高度height2， 键盘的高度height1-height2 1234567891011121314151617181920212223private View globalView;private int firstHeight;private boolean isFirst = true;globalView = findViewById(android.R.id.content);globalView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; Rect rect = new Rect(); globalView.getWindowVisibleDisplayFrame(rect); if (isFirst) &#123; isFirst = false; firstHeight = rect.height(); &#125; else &#123; int height = rect.height(); if (height &lt; firstHeight) &#123; System.out.println("键盘打开 " + (firstHeight - height)); &#125; else &#123; System.out.println("键盘关闭 "); &#125; &#125; &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-基类实现及学习]]></title>
      <url>%2F2017%2F06%2F13%2Fandroid-base-class%2F</url>
      <content type="text"><![CDATA[BaseActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242public abstract class BaseActivity extends FragmentActivity &#123; /** 用来保存所有已打开的Activity */ private static Stack&lt;Activity&gt; listActivity = new Stack&lt;Activity&gt;(); /** 提示信息 **/ private Toast mToast; /** 记录上次点击按钮的时间 **/ private long lastClickTime; /** 按钮连续点击最低间隔时间 单位：毫秒 **/ public final static int CLICK_TIME = 500; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(getContentViewId()); // 设置activity为无标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE); // 将activity推入栈中 listActivity.push(this); // 初始化ui initUI(); // 初始化数据 initData(); // 事件监听 initListener(); &#125; protected void initToolbar()&#123; Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); if(toolbar != null)&#123; setSupportActionBar(toolbar); getSupportActionBar.setDisplayShowTitleEnabled(false); handleToolbar(new ToolbarHelper(this)); &#125; &#125; /** 初始化ui **/ protected abstract void initUI(); /** 初始化数据 **/ protected abstract void initData(); /** 初始化监听 **/ protected abstract void initListener(); @Override protected void onSaveInstanceState(Bundle outState) &#123; saveInstanceState(outState); super.onSaveInstanceState(outState); &#125; // 设置activity为无标题栏 protected void setBase()&#123; requestWindowFeature(Window.FEATURE_NO_TITLE); &#125; /** 保存activity状态 **/ protected void saveInstanceState(Bundle outState) &#123; &#125; protected void handleToolbar()&#123; &#125; @Override public void onBackPressed() &#123; super.onBackPressed(); &#125; public void onBack(View v) &#123; finish(); &#125; @Override protected void onResume() &#123; super.onResume(); &#125; protected abstract int getContentViewId(); protected void showLongToast(String toastText)&#123; Toast.makeText(this,toastText,Toast.LENGTH_LONG).show(); &#125; protected void showShortToast(String toastText)&#123; Toast.makeText(this,toastText,Toast.LENGTH_SHORT).show(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 从栈中移除当前activity if (listActivity.contains(this)) &#123; listActivity.remove(this); &#125; &#125; /********************** activity跳转 **********************************/ public void openActivity(Class&lt;?&gt; targetActivityClass) &#123; openActivity(targetActivityClass, null); &#125; public void openActivity(Class&lt;?&gt; targetActivityClass, Bundle bundle) &#123; Intent intent = new Intent(this, targetActivityClass); if (bundle != null) &#123; intent.putExtras(bundle); &#125; startActivity(intent); &#125; public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass) &#123; openActivity(targetActivityClass); this.finish(); &#125; public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass, Bundle bundle) &#123; openActivity(targetActivityClass, bundle); this.finish(); &#125; /***************************************************************/ /** 验证上次点击按钮时间间隔，防止重复点击 */ public boolean verifyClickTime() &#123; if (System.currentTimeMillis() - lastClickTime &lt;= CLICK_TIME) &#123; return false; &#125; lastClickTime = System.currentTimeMillis(); return true; &#125; /** 收起键盘 */ public void closeInputMethod() &#123; // 收起键盘 View view = getWindow().peekDecorView();// 用于判断虚拟软键盘是否是显示的 if (view != null) &#123; InputMethodManager inputmanger = (InputMethodManager) getSystemService(Activity.INPUT_METHOD_SERVICE); inputmanger.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); &#125; &#125; /** * 获取string * * @param mRid * @return */ public String getStringMethod(int mRid) &#123; return this.getResources().getString(mRid); &#125; /** * 获取demin * * @param mRid * @return */ protected int getDemonIntegerMethod(int mRid) &#123; return (int) this.getResources().getDimension(mRid); &#125; /** * 关闭所有(前台、后台)Activity,注意：请已BaseActivity为父类 */ protected static void finishAll() &#123; int len = listActivity.size(); for (int i = 0; i &lt; len; i++) &#123; Activity activity = listActivity.pop(); activity.finish(); &#125; &#125; /***************** 双击退出程序 ************************************************/ private long exitTime = 0; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (KeyEvent.KEYCODE_BACK == keyCode) &#123; // 判断是否在两秒之内连续点击返回键，是则退出，否则不退出 if (System.currentTimeMillis() - exitTime &gt; 2000) &#123; Toast.makeText(getApplicationContext(), "再按一次退出程序", Toast.LENGTH_SHORT).show(); // 将系统当前的时间赋值给exitTime exitTime = System.currentTimeMillis(); &#125; else &#123; finishAll(); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; /* * ************Fragement相关方法************************************************ * */ private Fragment currentFragment; /** Fragment替换(当前destrory,新的create) */ public void fragmentReplace(int target, Fragment toFragment, boolean backStack) &#123; FragmentManager manager = getSupportFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); String toClassName = toFragment.getClass().getSimpleName(); if (manager.findFragmentByTag(toClassName) == null) &#123; transaction.replace(target, toFragment, toClassName); if (backStack) &#123; transaction.addToBackStack(toClassName); &#125; transaction.commit(); &#125; &#125; /** Fragment替换(核心为隐藏当前的,显示现在的,用过的将不会destrory与create) */ public void smartFragmentReplace(int target, Fragment toFragment) &#123; FragmentManager manager = getSupportFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); // 如有当前在使用的-&gt;隐藏当前的 if (currentFragment != null) &#123; transaction.hide(currentFragment); &#125; String toClassName = toFragment.getClass().getSimpleName(); // toFragment之前添加使用过-&gt;显示出来 if (manager.findFragmentByTag(toClassName) != null) &#123; transaction.show(toFragment); &#125; else &#123;// toFragment还没添加使用过-&gt;添加上去 transaction.add(target, toFragment, toClassName); &#125; transaction.commit(); // toFragment更新为当前的 currentFragment = toFragment; &#125; /***********************************************************************/&#125; BaseFragment1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class BaseFragment extends Fragment &#123; protected Activity mActivity; /** * 获得全局的，防止使用getActivity()为空 * @param context */ @Override public void onAttach(Context context) &#123; super.onAttach(context); this.mActivity = (Activity)context; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container , Bundle savedInstanceState) &#123; View view = LayoutInflater.from(mActivity) .inflate(getLayoutId(), container, false); initView(view, savedInstanceState); return view; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); initData(); &#125; /** * 该抽象方法就是 onCreateView中需要的layoutID * @return */ protected abstract int getLayoutId(); /** * 该抽象方法就是 初始化view * @param view * @param savedInstanceState */ protected abstract void initView(View view, Bundle savedInstanceState); /** * 执行数据的加载 */ protected abstract void initData();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-VelocityTracker详细学习]]></title>
      <url>%2F2017%2F06%2F10%2Fandroid-velocitytracker%2F</url>
      <content type="text"><![CDATA[简介VelocityTracker是一个跟踪触摸事件滑动速度的帮助类，用于实现flinging以及其它类似的手势。它的原理是把触摸事件 MotionEvent 对象传递给VelocityTracker的 addMovement(MotionEvent) 方法，然后分析MotionEvent 对象在单位时间类发生的位移来计算速度。你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。 主要函数 Public Methods void addMovement(MotionEvent event) Add a users movement to the tracker. void clear() Reset the velocity tracker back to its initial state. void compute CurrentVelocity(int units,float maxVelocity)Compute the current velocity based on the points that have been collected.intunitis表示速率的基本时间单位。unitis值为1的表示是，一毫秒时间单位内运动了多少个像素， unitis值为1000表示一秒（1000毫秒）时间单位内运动了多少个像素floatVelocity表示速率的最大值 void computeCurrentVelocity(int units)Equivalent to invoking computeCurrentVelocity(int, float)with a maximum velocity of Float.MAX_VALUE. abstract T getNextPoolable() float getXVelocity()Retrieve the last computed X velocity. float getXVelocity(int id)Retrieve the last computed X velocity. float float getYVelocity(int id)Retrieve the last computed Y velocity. float getYVelocity()Retrieve the last computed Y velocity. abstract boolean isPooled() static VelocityTracker obtain()Retrieve a new VelocityTracker object to watch the velocity of a motion. void recycle()Return a VelocityTracker object back to be re-used by others. abstract void setNextPoolable(T element) abstract void setPooled(boolean isPooled) 示例12345678910111213private VelocityTracker mVelocityTracker;//生命变量 //在onTouchEvent(MotionEvent ev)中 if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain();//获得VelocityTracker类实例 &#125; mVelocityTracker.addMovement(ev);//将事件加入到VelocityTracker类实例中 //判断当ev事件是MotionEvent.ACTION_UP时：计算速率 final VelocityTracker velocityTracker = mVelocityTracker; // 1000 provides pixels per second velocityTracker.computeCurrentVelocity(1, (float)0.01);//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常 Log.i("test","velocityTraker"+velocityTracker.getXVelocity()); velocityTracker.computeCurrentVelocity(1000); //设置units的值为1000，意思为一秒时间内运动了多少个像素 Log.i("test","velocityTraker"+velocityTracker.getXVelocity()); 大体的使用是这样的：当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象使用computeCurrentVelocity (int units)函数来计算当前的速度，使用getXVelocity ()、 getYVelocity ()函数来获得当前的速度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Toolbar详细学习]]></title>
      <url>%2F2017%2F06%2F09%2Fandroid-toolbar%2F</url>
      <content type="text"><![CDATA[Toolbar是简单使用1、在应用的build.gradle中添加v7 appcompat支持库。com.android.support:appcompat-v7:24.1.1 2、让Activity继承自AppCompatActivity。 123public class MyActivity extends AppCompatActivity &#123; // ...&#125; 3、在AndroidManifest.xml文件中，设置元素使用appcompat中的某个NoActionBar主题，从而来去除使用ActionBar来提供操作栏。 1&lt;application android:theme="@style/Theme.AppCompat.Light.NoActionBar"/&gt; 4、在activity的布局中添加Toolbar。 12345678&lt;android.support.v7.widget.Toolbar android:id="@+id/my_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:elevation="4dp" android:theme="@style/ThemeOverlay.AppCompat.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; 5、在activity的onCreate()方法中，调用setSupportActionBar()方法，并传入toolbar，这样就会将toolbar设置为activity的操作栏了。 1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my); Toolbar toolbar = (Toolbar) findViewById(R.id.my_toolbar); setSupportActionBar(toolbar);&#125; Toolber复用应用中有很多界面，每个Activity一般都需要操作栏，且大多数activity的操作栏的元素是一致的，那每个布局文件里面都写这么多资源文件是累赘的。因此可以对Toolbar进行复用，使得布局文件看起来更精炼，更改Toolbar整体效果，如背景之类的可以更方便。 首先，在布局文件toolbar.xml中定义Toolbar。 123456789101112131415161718&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:contentInsetLeft="0dp" android:contentInsetStart="0dp" android:elevation="4dp" android:theme="@style/ToolbarTheme" app:navigationIcon="@drawable/icon_back" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:titleTextAppearance="@style/Toolbar.TitleText"&gt; &lt;!-- any custom view --&gt;&lt;/android.support.v7.widget.Toolbar&gt; 之后，在需要添加Toolbar的地方引入这个布局资源。 12&lt;include layout="@layout/toolbar"/&gt; 最后，在BaseActivity(一般app都会有)中的onCreate()方法设置Toolbar。注意，这个时候Activity不再继承AppCompatActivity，而是继承BaseActivity，而BaseActivity继承AppCompatActivity。BaseActivity部分代码如下： 123456789101112131415161718192021222324252627282930313233@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); if (toolbar != null) &#123; setSupportActionBar(toolbar); mToolbarHelper = new ToolbarHelper(toolbar); hanldeToolbar(mToolbarHelper); &#125;&#125;protected void hanldeToolbar(ToolbarHelper toolbarHelper) &#123;&#125;public static class ToolbarHelper &#123; private Toolbar mToolbar; public ToolbarHelper(Toolbar toolbar) &#123; this.mToolbar = toolbar; &#125; public Toolbar getToolbar() &#123; return mToolbar; &#125; public void setTitle(String title) &#123; TextView titleTV = (TextView) mToolbar.findViewById(R.id.toolbar_title); titleTV.setText(title); &#125;&#125; 代码中首先获取到Toolbar将其设置为操作栏，之后创建了一个ToolbarHelper对象，ToobarHelper主要是封装了下Toolbar，并提供操作自定义View的方法。然后调用hanldeToolbar()方法，子Activity通过重写这个方法，可以对Toolbar进行定制操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-MotionEvent解析]]></title>
      <url>%2F2017%2F06%2F08%2Fandroid-motionevent%2F</url>
      <content type="text"><![CDATA[一些常量常见的动作常量： public static final int ACTION_DOWN = 0; //单点触摸动作 public static final int ACTION_UP = 1; //单点触摸离开动作 public static final int ACTION_MOVE = 2; //触摸点移动动作 public static final int ACTION_CANCEL = 3; //触摸动作取消 public static final int ACTION_OUTSIDE = 4; //触摸动作超出边界 public static final int ACTION_POINTER_DOWN = 5;//多点触摸动作 public static final int ACTION_POINTER_UP = 6; //多点离开动作 以下是一些非touch事件 public static final int ACTION_HOVER_MOVE = 7; public static final int ACTION_SCROLL = 8; public static final int ACTION_HOVER_ENTER = 9; public static final int ACTION_HOVER_EXIT = 10; 掩码常量ACTION_MASK = 0X000000ff 动作掩码ACTION_POINTER_INDEX_MASK = 0X0000ff00 触摸点索引掩码ACTION_POINTER_INDEX_SHIFT = 8 //获取触摸点索引需要移动的位数 getRawX()和getRawY()相对于屏幕位置坐标 X,Y 相对于View的位置坐标]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-ViewConfiguration解析]]></title>
      <url>%2F2017%2F06%2F07%2Fandroid-viewconfiguration%2F</url>
      <content type="text"><![CDATA[ViewConfiguration这个类主要定义了UI中所使用到的标准常量，像超时、尺寸、距离，如果我们需要得到这些常量的数据，我们就可以通过这个类来获取，具体方法如下： 获取ViewConfiguration对象，由于ViewConfiguration的构造方法为私有的，只能通过这个静态方法来获取到该对象。 ViewConfiguration configure = ViewConfiguration.get(context); 通过该对象调用相关的函数，将返回相关的常量数据。 最后附上一些这个类文件源码，这里面所有的方法基本都是用来获取常量数据的，没有什么业务操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645import android.app.AppGlobals;import android.content.Context;import android.content.res.Configuration;import android.content.res.Resources;import android.graphics.Point;import android.os.RemoteException;import android.provider.Settings;import android.util.DisplayMetrics;import android.util.SparseArray;/** * 主要用来获取一些在UI中所使用到的标准常量，像超时、尺寸、距离 */public class ViewConfiguration &#123; /** * 定义了水平滚动条的宽度和垂直滚动条的高度，单位是dip */ private static final int SCROLL_BAR_SIZE = 10; /** * 滚动条褪去所需要经历的时间，单位：milliseconds */ private static final int SCROLL_BAR_FADE_DURATION = 250; /** * 滚动条褪去之前的默认时间延迟，单位：milliseconds */ private static final int SCROLL_BAR_DEFAULT_DELAY = 300; /** * 定义褪去边缘的长度，单位：dip */ private static final int FADING_EDGE_LENGTH = 12; /** * 按下状态在子控件上的持续时间，单位：milliseconds */ private static final int PRESSED_STATE_DURATION = 64; /** * 定义一个按下状态转变成长按状态所需要持续的时间，单位：milliseconds */ private static final int DEFAULT_LONG_PRESS_TIMEOUT = 500; /** * 定义连续重复按键间的时间延迟，单位：milliseconds */ private static final int KEY_REPEAT_DELAY = 50; /** * 如果用户需要触发全局对话框，例如：关机，锁屏等，需要按下按钮所持续的事件，单位：milliseconds */ private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500; /** * 定义一个触摸事件是点击还是滚动的事件间隔，如果在这个事件内没有移动，就认为这是一个点击，否则就是滚动，单位：milliseconds */ private static final int TAP_TIMEOUT = 180; /** * Defines the duration in milliseconds we will wait to see if a touch event * is a jump tap. If the user does not complete the jump tap within this interval, it is * considered to be a tap. */ private static final int JUMP_TAP_TIMEOUT = 500; /** * 定义双击的时间间隔，如果在这个时间内，就认为是双击 */ private static final int DOUBLE_TAP_TIMEOUT = 300; /** * 定义双击最小的时间间隔 */ private static final int DOUBLE_TAP_MIN_TIME = 40; /** * 定义一个触摸板触摸到释放可认为是一个点击事件而不是一个触摸移动手势的最大时间， * 也就是说在这个时间内进行一次触摸和释放操作就可以认为是一次点击事件，单位：milliseconds */ private static final int HOVER_TAP_TIMEOUT = 150; /** * 定义一个触摸板在触摸释放之前可以移动的最大距离， * 如果在这个距离之内就可以认为是一个点击事件，否则就是一个移动手势，单位：pixels */ private static final int HOVER_TAP_SLOP = 20; /** * 定义响应显示缩放控制的时间 */ private static final int ZOOM_CONTROLS_TIMEOUT = 3000; /** * Inset in dips to look for touchable content when the user touches the edge of the screen */ private static final int EDGE_SLOP = 12; /** * 如果我们认为用户正在滚动，这里定义一个触摸事件可以滚动的距离，单位：dips * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。 */ private static final int TOUCH_SLOP = 8; /** * 定义双击事件之间可以移动的距离，单位：dips */ private static final int DOUBLE_TAP_TOUCH_SLOP = TOUCH_SLOP; /** * 定义用户尝试翻页滚动的触摸移动距离，单位：dips * * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。 * */ private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2; /** * 定义第一次点击和第二次点击可以认为是一次双击之间的距离。单位：dips */ private static final int DOUBLE_TAP_SLOP = 100; /** * Distance in dips a touch needs to be outside of a window's bounds for it to * count as outside for purposes of dismissing the window. */ private static final int WINDOW_TOUCH_SLOP = 16; /** * 一个fling最小的速度，单位：dips/s */ private static final int MINIMUM_FLING_VELOCITY = 50; /** * 一个fling最大的速度，单位：dips/s */ private static final int MAXIMUM_FLING_VELOCITY = 8000; /** * 分发一个重复访问事件的延迟事件，单位：milliseconds */ private static final long SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS = 100; /** * The maximum size of View's drawing cache, expressed in bytes. This size * should be at least equal to the size of the screen in ARGB888 format. */ @Deprecated private static final int MAXIMUM_DRAWING_CACHE_SIZE = 480 * 800 * 4; // ARGB8888 /** * 滚动和滑动的摩擦系数 */ private static final float SCROLL_FRICTION = 0.015f; /** * Max distance in dips to overscroll for edge effects */ private static final int OVERSCROLL_DISTANCE = 0; /** * Max distance in dips to overfling for edge effects */ private static final int OVERFLING_DISTANCE = 6; private final int mEdgeSlop; private final int mFadingEdgeLength; private final int mMinimumFlingVelocity; private final int mMaximumFlingVelocity; private final int mScrollbarSize; private final int mTouchSlop; private final int mDoubleTapTouchSlop; private final int mPagingTouchSlop; private final int mDoubleTapSlop; private final int mWindowTouchSlop; private final int mMaximumDrawingCacheSize; private final int mOverscrollDistance; private final int mOverflingDistance; private final boolean mFadingMarqueeEnabled; private boolean sHasPermanentMenuKey; private boolean sHasPermanentMenuKeySet; static final SparseArray&lt;ViewConfiguration&gt; sConfigurations = new SparseArray&lt;ViewConfiguration&gt;(2); /** * 这个方法被废除了，使用ViewConfiguration.get(Context)&#125;替代 */ @Deprecated public ViewConfiguration() &#123; mEdgeSlop = EDGE_SLOP; mFadingEdgeLength = FADING_EDGE_LENGTH; mMinimumFlingVelocity = MINIMUM_FLING_VELOCITY; mMaximumFlingVelocity = MAXIMUM_FLING_VELOCITY; mScrollbarSize = SCROLL_BAR_SIZE; mTouchSlop = TOUCH_SLOP; mDoubleTapTouchSlop = DOUBLE_TAP_TOUCH_SLOP; mPagingTouchSlop = PAGING_TOUCH_SLOP; mDoubleTapSlop = DOUBLE_TAP_SLOP; mWindowTouchSlop = WINDOW_TOUCH_SLOP; //noinspection deprecation mMaximumDrawingCacheSize = MAXIMUM_DRAWING_CACHE_SIZE; mOverscrollDistance = OVERSCROLL_DISTANCE; mOverflingDistance = OVERFLING_DISTANCE; mFadingMarqueeEnabled = true; &#125; /** * 使用给定的context来创建一个新的配置。这个配置依赖于context里面不同的参数，例如显示的尺寸或者密度 * @param context 用来初始化这个view配置的应用上下文环境 * * @see #get(android.content.Context) * @see android.util.DisplayMetrics */ private ViewConfiguration(Context context) &#123; final Resources res = context.getResources(); final DisplayMetrics metrics = res.getDisplayMetrics(); final Configuration config = res.getConfiguration(); final float density = metrics.density; final float sizeAndDensity; if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE)) &#123; sizeAndDensity = density * 1.5f; &#125; else &#123; sizeAndDensity = density; &#125; mEdgeSlop = (int) (sizeAndDensity * EDGE_SLOP + 0.5f); mFadingEdgeLength = (int) (sizeAndDensity * FADING_EDGE_LENGTH + 0.5f); mMinimumFlingVelocity = (int) (density * MINIMUM_FLING_VELOCITY + 0.5f); mMaximumFlingVelocity = (int) (density * MAXIMUM_FLING_VELOCITY + 0.5f); mScrollbarSize = (int) (density * SCROLL_BAR_SIZE + 0.5f); mDoubleTapSlop = (int) (sizeAndDensity * DOUBLE_TAP_SLOP + 0.5f); mWindowTouchSlop = (int) (sizeAndDensity * WINDOW_TOUCH_SLOP + 0.5f); // Size of the screen in bytes, in ARGB_8888 format final WindowManager win = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); final Display display = win.getDefaultDisplay(); final Point size = new Point(); display.getRealSize(size); mMaximumDrawingCacheSize = 4 * size.x * size.y; mOverscrollDistance = (int) (sizeAndDensity * OVERSCROLL_DISTANCE + 0.5f); mOverflingDistance = (int) (sizeAndDensity * OVERFLING_DISTANCE + 0.5f); if (!sHasPermanentMenuKeySet) &#123; IWindowManager wm = WindowManagerGlobal.getWindowManagerService(); try &#123; sHasPermanentMenuKey = !wm.hasNavigationBar(); sHasPermanentMenuKeySet = true; &#125; catch (RemoteException ex) &#123; sHasPermanentMenuKey = false; &#125; &#125; mFadingMarqueeEnabled = res.getBoolean( com.android.internal.R.bool.config_ui_enableFadingMarquee); mTouchSlop = res.getDimensionPixelSize( com.android.internal.R.dimen.config_viewConfigurationTouchSlop); mPagingTouchSlop = mTouchSlop * 2; mDoubleTapTouchSlop = mTouchSlop; &#125; /** * 跟上面一个函数一样，只不过上面一个是创建一个ViewConfiguration对象，这里是直接通过这个静态方法返回一个对象 */ public static ViewConfiguration get(Context context) &#123; final DisplayMetrics metrics = context.getResources().getDisplayMetrics(); final int density = (int) (100.0f * metrics.density); ViewConfiguration configuration = sConfigurations.get(density); if (configuration == null) &#123; configuration = new ViewConfiguration(context); sConfigurations.put(density, configuration); &#125; return configuration; &#125; /** * @return 获取水平滚动条的宽带和垂直滚动条的高度 * * 这个函数被废除，使用getScaledScrollBarSize()来代替 */ @Deprecated public static int getScrollBarSize() &#123; return SCROLL_BAR_SIZE; &#125; /** * @return 获取水平滚动条的宽带和垂直滚动条的高度 */ public int getScaledScrollBarSize() &#123; return mScrollbarSize; &#125; /** * @return 滚动条褪去的持续时间 */ public static int getScrollBarFadeDuration() &#123; return SCROLL_BAR_FADE_DURATION; &#125; /** * @return 滚动条褪去的延迟时间 */ public static int getScrollDefaultDelay() &#123; return SCROLL_BAR_DEFAULT_DELAY; &#125; /** * @return 褪去边缘的长度 * * 这个方法已经废弃，用getScaledFadingEdgeLength()替代. */ @Deprecated public static int getFadingEdgeLength() &#123; return FADING_EDGE_LENGTH; &#125; /** * @return 褪去边缘的长度，单位：pixels */ public int getScaledFadingEdgeLength() &#123; return mFadingEdgeLength; &#125; /** * @return 在子控件上按住状态的持续时间 */ public static int getPressedStateDuration() &#123; return PRESSED_STATE_DURATION; &#125; /** * @return 按住状态转变为长按状态需要的时间 */ public static int getLongPressTimeout() &#123; return AppGlobals.getIntCoreSetting(Settings.Secure.LONG_PRESS_TIMEOUT, DEFAULT_LONG_PRESS_TIMEOUT); &#125; /** * @return 重新按键时间 */ public static int getKeyRepeatTimeout() &#123; return getLongPressTimeout(); &#125; /** * @return 重复按键延迟时间 */ public static int getKeyRepeatDelay() &#123; return KEY_REPEAT_DELAY; &#125; /** * @return 判断用户是单击还是滚动的时间，在这个时间内没有移动则是单击，否则是滚动 */ public static int getTapTimeout() &#123; return TAP_TIMEOUT; &#125; /** * @return the duration in milliseconds we will wait to see if a touch event * is a jump tap. If the user does not move within this interval, it is * considered to be a tap. */ public static int getJumpTapTimeout() &#123; return JUMP_TAP_TIMEOUT; &#125; /** * @return 得到双击间隔时间，在这个时间内，则是双击，否则就是单击 */ public static int getDoubleTapTimeout() &#123; return DOUBLE_TAP_TIMEOUT; &#125; /** * @return the minimum duration in milliseconds between the first tap's * up event and the second tap's down event for an interaction to be considered a * double-tap. * * @hide */ public static int getDoubleTapMinTime() &#123; return DOUBLE_TAP_MIN_TIME; &#125; /** * @return the maximum duration in milliseconds between a touch pad * touch and release for a given touch to be considered a tap (click) as * opposed to a hover movement gesture. * @hide */ public static int getHoverTapTimeout() &#123; return HOVER_TAP_TIMEOUT; &#125; /** * @return the maximum distance in pixels that a touch pad touch can move * before being released for it to be considered a tap (click) as opposed * to a hover movement gesture. * @hide */ public static int getHoverTapSlop() &#123; return HOVER_TAP_SLOP; &#125; /** * @return Inset in dips to look for touchable content when the user touches the edge of the * screen * * @deprecated Use &#123;@link #getScaledEdgeSlop()&#125; instead. */ @Deprecated public static int getEdgeSlop() &#123; return EDGE_SLOP; &#125; /** * @return Inset in pixels to look for touchable content when the user touches the edge of the * screen */ public int getScaledEdgeSlop() &#123; return mEdgeSlop; &#125; /** * @return Distance in dips a touch can wander before we think the user is scrolling * * @deprecated Use &#123;@link #getScaledTouchSlop()&#125; instead. */ @Deprecated public static int getTouchSlop() &#123; return TOUCH_SLOP; &#125; /** * @return Distance in pixels a touch can wander before we think the user is scrolling */ public int getScaledTouchSlop() &#123; return mTouchSlop; &#125; /** * @return Distance in pixels the first touch can wander before we do not consider this a * potential double tap event * @hide */ public int getScaledDoubleTapTouchSlop() &#123; return mDoubleTapTouchSlop; &#125; /** * @return Distance in pixels a touch can wander before we think the user is scrolling a full * page */ public int getScaledPagingTouchSlop() &#123; return mPagingTouchSlop; &#125; /** * @return Distance in dips between the first touch and second touch to still be * considered a double tap * @deprecated Use &#123;@link #getScaledDoubleTapSlop()&#125; instead. * @hide The only client of this should be GestureDetector, which needs this * for clients that still use its deprecated constructor. */ @Deprecated public static int getDoubleTapSlop() &#123; return DOUBLE_TAP_SLOP; &#125; /** * @return Distance in pixels between the first touch and second touch to still be * considered a double tap */ public int getScaledDoubleTapSlop() &#123; return mDoubleTapSlop; &#125; /** * Interval for dispatching a recurring accessibility event in milliseconds. * This interval guarantees that a recurring event will be send at most once * during the &#123;@link #getSendRecurringAccessibilityEventsInterval()&#125; time frame. * * @return The delay in milliseconds. * * @hide */ public static long getSendRecurringAccessibilityEventsInterval() &#123; return SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS; &#125; /** * @return Distance in dips a touch must be outside the bounds of a window for it * to be counted as outside the window for purposes of dismissing that * window. * * @deprecated Use &#123;@link #getScaledWindowTouchSlop()&#125; instead. */ @Deprecated public static int getWindowTouchSlop() &#123; return WINDOW_TOUCH_SLOP; &#125; /** * @return Distance in pixels a touch must be outside the bounds of a window for it * to be counted as outside the window for purposes of dismissing that window. */ public int getScaledWindowTouchSlop() &#123; return mWindowTouchSlop; &#125; /** * @return Minimum velocity to initiate a fling, as measured in dips per second. * * @deprecated Use &#123;@link #getScaledMinimumFlingVelocity()&#125; instead. */ @Deprecated public static int getMinimumFlingVelocity() &#123; return MINIMUM_FLING_VELOCITY; &#125; /** * @return 得到滑动的最小速度, 以像素/每秒来进行计算 */ public int getScaledMinimumFlingVelocity() &#123; return mMinimumFlingVelocity; &#125; /** * @return Maximum velocity to initiate a fling, as measured in dips per second. * * @deprecated Use &#123;@link #getScaledMaximumFlingVelocity()&#125; instead. */ @Deprecated public static int getMaximumFlingVelocity() &#123; return MAXIMUM_FLING_VELOCITY; &#125; /** * @return 得到滑动的最大速度, 以像素/每秒来进行计算 */ public int getScaledMaximumFlingVelocity() &#123; return mMaximumFlingVelocity; &#125; /** * The maximum drawing cache size expressed in bytes. * * @return the maximum size of View's drawing cache expressed in bytes * * @deprecated Use &#123;@link #getScaledMaximumDrawingCacheSize()&#125; instead. */ @Deprecated public static int getMaximumDrawingCacheSize() &#123; //noinspection deprecation return MAXIMUM_DRAWING_CACHE_SIZE; &#125; /** * The maximum drawing cache size expressed in bytes. * * @return the maximum size of View's drawing cache expressed in bytes */ public int getScaledMaximumDrawingCacheSize() &#123; return mMaximumDrawingCacheSize; &#125; /** * @return The maximum distance a View should overscroll by when showing edge effects (in * pixels). */ public int getScaledOverscrollDistance() &#123; return mOverscrollDistance; &#125; /** * @return The maximum distance a View should overfling by when showing edge effects (in * pixels). */ public int getScaledOverflingDistance() &#123; return mOverflingDistance; &#125; /** * The amount of time that the zoom controls should be * displayed on the screen expressed in milliseconds. * * @return the time the zoom controls should be visible expressed * in milliseconds. */ public static long getZoomControlsTimeout() &#123; return ZOOM_CONTROLS_TIMEOUT; &#125; /** * The amount of time a user needs to press the relevant key to bring up * the global actions dialog. * * @return how long a user needs to press the relevant key to bring up * the global actions dialog. */ public static long getGlobalActionKeyTimeout() &#123; return GLOBAL_ACTIONS_KEY_TIMEOUT; &#125; /** * The amount of friction applied to scrolls and flings. * * @return A scalar dimensionless value representing the coefficient of * friction. */ public static float getScrollFriction() &#123; return SCROLL_FRICTION; &#125; /** * Report if the device has a permanent menu key available to the user. * * &lt;p&gt;As of Android 3.0, devices may not have a permanent menu key available. * Apps should use the action bar to present menu options to users. * However, there are some apps where the action bar is inappropriate * or undesirable. This method may be used to detect if a menu key is present. * If not, applications should provide another on-screen affordance to access * functionality. * * @return true if a permanent menu key is present, false otherwise. */ public boolean hasPermanentMenuKey() &#123; return sHasPermanentMenuKey; &#125; /** * @hide * @return Whether or not marquee should use fading edges. */ public boolean isFadingMarqueeEnabled() &#123; return mFadingMarqueeEnabled; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Scroller详细学习]]></title>
      <url>%2F2017%2F06%2F06%2Fandroid-scroller%2F</url>
      <content type="text"><![CDATA[前言Scroller是一个专门用于处理滚动效果的工具类，可能在大多数情况下，我们直接使用Scroller的场景并不多，但是很多大家所熟知的控件在内部都是使用Scroller来实现的，如ViewPager、ListView等。先撇开Scroller类不谈，其实任何一个控件都是可以滚动的，因为在View类当中有scrollTo()和scrollBy()这两个方法。这两个方法都是用于对View进行滚动的，那么它们之间有什么区别呢？简单点讲，scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。注意，不管是scrollTo()还是scrollBy()方法，滚动的都是该View内部的内容 第一个参数x表示相对于当前位置横向移动的距离，正值向左移动，负值向右移动，单位是像素。第二个参数y表示相对于当前位置纵向移动的距离，正值向上移动，负值向下移动，单位是像素。 scrollBy()scrollBy()方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直向右下方移动。 scrollTo()scrollTo()方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。 Scroller目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤： 创建Scroller的实例 调用startScroll()方法来初始化滚动数据并刷新界面 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 startScroll(int startX,int startY,int dx,int dy) 第一个参数是滚动开始时X的坐标 第二个参数是滚动开始时Y的坐标 第三个参数是横向滚动的距离,正值表示向左滚动 第四个参数是纵向滚动的距离，正值表示向上滚动。 紧接着调用invalidate()方法来刷新界面。 startScroll (int startX, int startY, int dx, int dy, int duration)同上 第五个参数是滑动时间 computeScroll()在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。 12345678@Overridepublic void computeScroll() &#123; // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); invalidate(); &#125;&#125; getScrollX() | getScrollY()返回当前view在x或者y方向上的滚动距离]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-XML参数详细了解]]></title>
      <url>%2F2017%2F06%2F05%2Fandroid-xml%2F</url>
      <content type="text"><![CDATA[android:layout_width 设置组件的宽度 android:layout_height 设置组件的高度 android:id 给组件定义一个id值，供后期使用 android:background 设置组件的背景颜色或背景图片 android:text 设置组件的显示文字 android:textColor 设置组件的显示文字的颜色 android:layout_below 组件在参考组件的下面 android:alignTop 同指定组件的顶平行 android:maxLength=&quot;6&quot; 限制输入字数 android:digits=&#39;012356789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; 限制输入数字和大写小写字母 android:password=&#39;true&#39; 这条可以让EditText显示的内容自动为 星号，输入时内容会在1秒内变成*字样。 android:numeric=&#39;true&#39; 这条可以让输入法自动变为数字输入键盘，同时仅允许0-9的数字输入 android:capitalize=&#39;cwj1987&#39; 这样仅允许接受输入cwj1987，一般用于密码验证 android:editable=&#39;false&#39; 设置EditText不可编辑 android:singleLine=&#39;true&#39; 强制输入的内容在单行 android:ellipsize=&#39;end&#39; 自动隐藏尾部溢出数据，一般用于文字内容过长一行无法全部显示时。 android:autoLink 设置是否当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接。可选值(none/web/email/phone/map/all) android:autoText 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。 android:bufferType 指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。spannable 则可在给定的字符区域使用样式，参见这里1、这里2。 android:capitalize 设置英文字母大写类型。此处无效果，需要弹出输入法才能看得到，参见EditText此属性说明。 android:cursorVisible 设定光标为显示/隐藏，默认显示。 android:digits 设置允许输入哪些字符。如“1234567890.+-*/%\n()” android:drawableBottom 在text的下方输出一个drawable，如图片。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。 android:drawableLeft 在text的左边输出一个drawable，如图片。 android:drawablePadding 设置text与drawable(图片)的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。 android:drawableRight 在text的右边输出一个drawable，如图片。 android:drawableTop 在text的正上方输出一个drawable，如图片。 android:editable 设置是否可编辑。这里无效果，参见EditView。 android:editorExtras 设置文本的额外的输入数据。在EditView再讨论。 android:ellipsize 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动) android:freezesText 设置保存文本的内容以及光标的位置。参见：这里。 android:gravity 设置文本位置，如设置成“center”，文本将居中显示。 android:hint Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。此属性在EditView中使用，但是这里也可以用。 android:imeOptions 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。这个在EditText中再详细说明，此处无用。 android:imeActionId 设置IME动作ID。在EditText再做说明，可以先看这篇帖子：这里。 android:imeActionLabel 设置IME动作标签。在EditText再做说明。 android:includeFontPadding 设置文本是否包含顶部和底部额外空白，默认为true。 android:inputMethod 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。 android:inputType 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditText中再详细说明，这里无效果。 android:linksClickable 设置链接是否点击连接，即使设置了autoLink。 android:marqueeRepeatLimit 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。 android:ems 设置TextView的宽度为N个字符的宽度。 android:maxEms 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:minEms 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:maxLength 限制显示的文本长度，超出部分不显示。 android:lines 设置文本的行数，设置两行就显示两行，即使第二行没有数据。 android:maxLines 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。 android:minLines 设置文本的最小行数，与lines类似。 android:lineSpacingExtra 设置行间距。 android:lineSpacingMultiplier 设置行间距的倍数。如”1.2” android:numeric 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EditText将详细说明。 android:password 以小点”.”显示文本 android:phoneNumber 设置为电话号码的输入方式。 android:privateImeOptions 设置输入法选项，此处无用，在EditText将进一步讨论。 android:scrollHorizontally 设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:selectAllOnFocus 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。EditText中设置后无效果。 android:shadowColor 指定文本阴影的颜色，需要与shadowRadius一起使用。 android:shadowDx 设置阴影横向坐标开始位置。 android:shadowDy 设置阴影纵向坐标开始位置。 android:shadowRadius 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。 android:singleLine 设置单行显示。如果和layoutwidth一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=”test singleLine “ android:singleLine=”true” android:layout_width=”20dp”将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行 android:text 设置显示文本. android:textAppearance 设置文字外观。如“?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，？表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/textAppearanceMediumInverse/textAppearanceSmall/textAppearanceSmallInverse android:textColor 设置文本颜色 android:textColorHighlight 被选中文字的底色，默认为蓝色 android:textColorHint 设置提示信息文字的颜色，默认为灰色。与hint一起使用。 android:textColorLink 文字链接的颜色. android:textScaleX 设置文字之间间隔，默认为1.0f。分别设置0.5f/1.0f/1.5f/2.0f android:textSize 设置文字大小，推荐度量单位”sp”，如”15sp” android:textStyle 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开 android:typeface 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3] android:height 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米) android:maxHeight 设置文本区域的最大高度 android:minHeight 设置文本区域的最小高度 android:width 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)，与layout_width的区别看这里。 android:maxWidth 设置文本区域的最大宽度 android:minWidth 设置文本区域的最小宽度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-ViewPager详细学习]]></title>
      <url>%2F2017%2F06%2F02%2Fandroid-viewpager%2F</url>
      <content type="text"><![CDATA[简介ViewPager是android扩展包v4包中的类，这个类可以让用户左右切换当前的view ViewPager类直接继承了ViewGroup类，所有它是一个容器类，可以在其中添加其他的view类。 ViewPager类需要一个PagerAdapter适配器类给它提供数据。 ViewPager经常和Fragment一起使用，并且提供了专门的FragmentPagerAdapter和FragmentStatePagerAdapter类供Fragment中的ViewPager使用。 ViewPager的适配器简介中提到了PagerAdapter，和ListView等控件使用一样,需要ViewPager设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是一个基类适配器，我们经常用它来实现app引导图，它的子类有FragmentPagerAdapter和FragmentStatePagerAdapter,这两个子类适配器用于和Fragment一起使用，在安卓应用中它们就像listview一样出现的频繁。 实现一个最基本的PagerAdapter,必须实现四个方法，在代码里有注释12345678910111213141516171819202122232425262728public class AdapterViewpager extends PagerAdapter &#123; private List&lt;View&gt; mViewList; public AdapterViewpager(List&lt;View&gt; mViewList) &#123; this.mViewList = mViewList; &#125; @Override public int getCount() &#123;//必须实现,返回要滑动的VIew的个数 return mViewList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123;//必须实现,该函数用来判断instantiateItem(ViewGroup, int)函数所返回来的Key与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View) return view == object; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123;//必须实现，做了两件事，第一：将当前视图添加到container中，第二：返回当前View container.addView(mViewList.get(position)); return mViewList.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123;//必须实现，从当前container中删除指定位置（position）的View container.removeView(mViewList.get(position)); &#125;&#125; 实现一个最基本的FragmentPagerAdapter1234567891011121314151617181920212223public class AdapterFragment extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; mFragments; public AdapterFragment(FragmentManager fm, List&lt;Fragment&gt; mFragments) &#123; super(fm); this.mFragments = mFragments; &#125; @Override public Fragment getItem(int position) &#123;//必须实现 return mFragments.get(position); &#125; @Override public int getCount() &#123;//必须实现 return mFragments.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123;//选择性实现 return mFragments.get(position).getClass().getSimpleName(); &#125;&#125; PagerAdapter是基类适配器是一个通用的ViewPager适配器，相比PagerAdapter，FragmentPagerAdapter和FragmentStatePagerAdapter更专注于每一页是Fragment的情况，而这两个子类适配器使用情况也是有区别的。FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况。为什么？简单分析下两个适配器的源码就可以知道了。 源码略，查官网 从源码中我们可以看出FragmentStatePagerAdapter中fragment实例在destroyItem的时候被真正释放，所以FragmentStatePagerAdapter省内存。FragmentPagerAdapter中的fragment实例在destroyItem的时候并没有真正释放fragment对象只是detach，所以FragmentPagerAdapter消耗更多的内存，带来的好处就是效率更高一些。所以得出这样的结论：FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况，因此不同的场合选择合适的适配器才是正确的做法。 ViewPager的翻页动画为ViewPager设置适配器后，就可以正常使用了，接下来我们为ViewPager增加翻页动画，毕竟人的审美会疲劳，加上一些动画交互会提高不少逼格~~，ViewPager提供了PageTransformer接口用于实现翻页动画。官方提供了PageTransformer的实现例子。 例一12345678910111213141516171819202122232425262728293031323334353637 public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; Log.d("DepthPageTransformer", view.getTag() + " , " + position + ""); int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 0) &#123; // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 例二1234567891011121314151617181920212223242526272829303132333435363738394041 public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; @SuppressLint("NewApi") public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); Log.e("TAG", view + " , " + position + ""); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 实现翻页动画的关键就是重写transformPage方法，方法里有两个参数view和position,理解这两个参数非常重要。假设有三个页面view1，view2，view3从左至右在viewPager中显示 往左滑动时：view1，view2，view3的position都是不断变小的。 123view1的position: 0 → -1 → 负无穷大view2的position: 1 → 0 → -1 view3的position: 1 → 0 往右滑动时：view1，view2，view3的position都是不断变大的。 123view1的position: -1 → 0 view2的position: -1 → 0 → 1 view3的position: 0 → 1→ 正无穷大 当position是正负无穷大时view就离开屏幕视野了。因此最核心的控制逻辑是在[-1,0]和(0,1]这两个区间，通过设置透明度，平移，旋转，缩放等动画组合可以实现各式各样的页面变化效果。 简化ViewPager的使用 PagerAdapter简化 12345678910111213141516171819202122232425262728public class QuickPageAdapter&lt;T extends View&gt; extends PagerAdapter &#123; private List&lt;T&gt; mList; public QuickPageAdapter(List&lt;T&gt; mList) &#123; this.mList = mList; &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return object == view; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(mList.get(position)); return mList.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(mList.get(position)); &#125;&#125; 使用它，这样不用每次都写个适配器List views = new ArrayList&lt;&gt;();…mViewPager.setAdapter(new QuickPageAdapter(views)); FragmentPagerAdapter简化 123456789101112131415161718192021222324252627282930public class QuickFragmentPageAdapter&lt;T extends Fragment&gt; extends FragmentPagerAdapter &#123; private List&lt;T&gt; mList; private String[] mStrings; /** * @param fm * @param list * @param titles PageTitles */ public QuickFragmentPageAdapter(FragmentManager fm, List&lt;T&gt; list, String[] titles) &#123; super(fm); mList = list; mStrings = titles; &#125; @Override public Fragment getItem(int position) &#123; return mList.get(position); &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mStrings == null ? super.getPageTitle(position) : mStrings[position]; &#125;&#125; #PagerTitleStrip 将它作为子控件添加在xml布局文件中的ViewPager中 标题的获取，是重写适配器的getPageTitle(int)函数来获取的。 重写CharSequence getPageTitle(int)函数来对其进行实现 PagerTabStrip PagerTabStrip在当前页面下，会有一个下划线条来提示当前页面的Tab是哪个。 PagerTabStrip的Tab是可以点击的，当用户点击某一个Tab时，当前页面就会跳转到这个页面，而PagerTitleStrip则没这个功能。 将它作为子控件添加在xml布局文件中的ViewPager中 标题的获取，是重写适配器的getPageTitle(int)函数来获取的。 扩展：PagerTabStrip属性更改setTabIndicatorColorResource——修改Tab颜色重写适配器CharSequence getPageTitle(int)方法——添加标题 总结PagerTitleStrip和PagerTabStrip通过前面的讲解，我们应该清楚的认识到PagerTabStrip与PagerTitleStrip在添加标题栏的异同，但他们实现的标题栏效果很不好，不能指定一个页面一次显示一个，或者全部显示，而且标题还滑动。所以注定主流的App都没有用这个玩意的。所以这里也只是一个过渡，在开发中，我们也不建议使用这两个东东。 SimpleOnPageChangeListener如果不想继承实现ViewPager.OnPageChangeListener的方法，可以直接继承SimpleOnPageChangeListener对ViewPager的页面滑动事件进行简单的处理。 onPageScrolled] (int position, float positionOffset, int positionOffsetPixels)： position:当前的位置 positionoffset:当前滚动比例（左－右／0-1）（右－左／1-0） positionOffsetPixels：当前实际滚动的像素（左－右／0-页宽） （右－左／页宽－0）被调用的场景： ViewPager滚动时总被回调，这个函数在操作ViewPager时被回调很多次。 手指拖动 action_move 。n次 惯性还原 computeScroll()。n次使用场景：做view的动画效果时可以用这个回调函数。 onPageSelected(int position)被调用的场景：ViewPager确定页面是哪一页时。1次 手指拖动后抬起 action_up 。1次 或者手指滑动超出屏幕时 action_cancel。1次使用场景：页面切换后改变对应的tab的状态可以用这个回调函数。 onPageScrollStateChange (int state):被调用的场景：ViewPager状态切换时被调用。这个函数在操作ViewPager时被回调3次。 开始滚动 dragging拖动状态。1次 惯性滚动 settling还原状态。1次 滚动结束 idle空闲状态。1次使用场景：做页面状态变化后引起的view特效时可以用这个回调函数 ViewPager.OnPageChangeListener onPageScrollStateChanged(int state)//在状态改变的时候调用其中arg0这个参数有三种状态（0，1，2）。arg0 ==1表示正在滑动，arg0==2表示滑动完毕了，arg0==0表示什么都没做。当页面开始滑动的时候，三种状态的变化顺序为(1,2,0) onPageScrolled(int position, float positionOffset, int positionOffsetPixels)//当页面在滑动的时候会调用此方法，在滑动被停止之前，此方法回一直得到调用。其中三个参数的含义分别为：arg0 :当前页面，及你点击滑动的页面。arg1:当前页面偏移的百分比。arg2:当前页面偏移的像素位置 onPageSelected(int position)//页面跳转完后得到调用，arg0是你当前选中的页面的position ViewPager.OnAdapterChangeListenervoid onAdapterChanged ( ViewPagerew viewPager, PagerAdapter oldAdapter,PagerAdapter newAdapter) viewPager: ViewPager where the adapter change has happened(传入发生改变的ViewPager) oldAdapter: the previously set adapter(老的adapter) newAdapter: the newly set adapter(新的adapter) 注意点mViewPager.setOffscreenPageLimit()//这个方法是用来控制fragment不重新走生命周期的个数的，打个比方一共4个fragment页面，如果mViewPager.setOffscreenPageLimit(3)，那么所有的fragment都只走一次生命周期，如果是mViewPager.setOffscreenPageLimit(2)，那么其中有一个fragment会在切换的时候重新走一遍生命周期，FragmentStatePagerAdapter和FragmentPagerAdapter都是这样，但是FragmentPagerAdapter设置setOffscreenPageLimit()不影响fragment缓存的个数,而FragmentStatePagerAdapter缓存的fragment实例个数就是setOffscreenPageLimit()设置的值+1。另外setOffscreenPageLimit()的缺省值是1，设置0是无效的会被强制赋值成1。 提高ViewPager结合第三方库实现小圆点指示器效果https://github.com/ongakuer/CircleIndicator 使用看官方文档很简单。 看一下实现思路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void setViewPager(ViewPager viewPager) &#123; mViewpager = viewPager; if (mViewpager != null &amp;&amp; mViewpager.getAdapter() != null) &#123; mLastPosition = -1; createIndicators(); mViewpager.removeOnPageChangeListener(mInternalPageChangeListener); mViewpager.addOnPageChangeListener(mInternalPageChangeListener);//绑定上内部实现的PageChangeListener mInternalPageChangeListener.onPageSelected(mViewpager.getCurrentItem()); &#125; &#125; private final OnPageChangeListener mInternalPageChangeListener = new OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123;//这里是动画的核心 if (mViewpager.getAdapter() == null || mViewpager.getAdapter().getCount() &lt;= 0) &#123; return; &#125; if (mAnimatorIn.isRunning()) &#123; mAnimatorIn.end(); mAnimatorIn.cancel(); &#125; if (mAnimatorOut.isRunning()) &#123; mAnimatorOut.end(); mAnimatorOut.cancel(); &#125; View currentIndicator; if (mLastPosition &gt;= 0 &amp;&amp; (currentIndicator = getChildAt(mLastPosition)) != null) &#123;//页面离开屏幕时指示器动画 currentIndicator.setBackgroundResource(mIndicatorUnselectedBackgroundResId); mAnimatorIn.setTarget(currentIndicator); mAnimatorIn.start(); &#125; View selectedIndicator = getChildAt(position); if (selectedIndicator != null) &#123;//页面进入屏幕时指示器动画 selectedIndicator.setBackgroundResource(mIndicatorBackgroundResId); mAnimatorOut.setTarget(selectedIndicator); mAnimatorOut.start(); &#125; mLastPosition = position; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;; ViewPager结合design库实现tab切换在design库中有个TabLayout可以为viewPager加上Tab标题头 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.example.administrator.viewpager.MainActivity"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/mTabLayout" android:layout_width="match_parent" android:layout_height="wrap_content"&gt;&lt;/android.support.design.widget.TabLayout&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/mViewPager" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;/LinearLayout&gt;mTabLayout.setupWithViewPager(mViewPager);//一行代码完成绑定 更多高级的用法包括tab中添加icon等请转至这里传送门 基于ViewPager实现广告轮播控件https://github.com/daimajia/AndroidImageSlider 源码分析，省略了部分代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class SliderLayout extends RelativeLayout&#123; private InfiniteViewPager mViewPager;//这个ViewPager只是修改了setPageTransformer方法去掉了if (Build.VERSION.SDK_INT &gt;= 11) 的限制，结合NineOldDroid库让动画兼容低版本 /** * InfiniteViewPager adapter. */ private SliderAdapter mSliderAdapter;//这个是PagerAdapter /** * &#123;@link com.daimajia.slider.library.Tricks.ViewPagerEx&#125; indicator. */ private PagerIndicator mIndicator;//页面指示器 /** * A timer and a TimerTask using to cycle the &#123;@link com.daimajia.slider.library.Tricks.ViewPagerEx&#125;. */ private Timer mCycleTimer;//用于轮播的定时器 private TimerTask mCycleTask; /** * For resuming the cycle, after user touch or click the &#123;@link com.daimajia.slider.library.Tricks.ViewPagerEx&#125;. */ private Timer mResumingTimer; private TimerTask mResumingTask; /** * &#123;@link com.daimajia.slider.library.Tricks.ViewPagerEx&#125; 's transformer */ private BaseTransformer mViewPagerTransformer;//PageTransformer的封装用于控制页面翻页效果 public SliderLayout(Context context, AttributeSet attrs, int defStyle) &#123;//核心代码，用于初始化ViewPager super(context, attrs, defStyle); mContext = context; LayoutInflater.from(context).inflate(R.layout.slider_layout, this, true); final TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs,R.styleable.SliderLayout, defStyle,0); mTransformerSpan = attributes.getInteger(R.styleable.SliderLayout_pager_animation_span, 1100); mTransformerId = attributes.getInt(R.styleable.SliderLayout_pager_animation, Transformer.Default.ordinal()); mAutoCycle = attributes.getBoolean(R.styleable.SliderLayout_auto_cycle,true); int visibility = attributes.getInt(R.styleable.SliderLayout_indicator_visibility,0); for(PagerIndicator.IndicatorVisibility v: PagerIndicator.IndicatorVisibility.values())&#123; if(v.ordinal() == visibility)&#123; mIndicatorVisibility = v; break; &#125; &#125; mSliderAdapter = new SliderAdapter(mContext); PagerAdapter wrappedAdapter = new InfinitePagerAdapter(mSliderAdapter); mViewPager = (InfiniteViewPager)findViewById(R.id.daimajia_slider_viewpager); mViewPager.setAdapter(wrappedAdapter); mViewPager.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; int action = event.getAction(); switch (action) &#123; case MotionEvent.ACTION_UP: recoverCycle(); break; &#125; return false; &#125; &#125;); attributes.recycle(); setPresetIndicator(PresetIndicators.Center_Bottom); setPresetTransformer(mTransformerId); setSliderTransformDuration(mTransformerSpan,null); setIndicatorVisibility(mIndicatorVisibility); if(mAutoCycle)&#123; startAutoCycle(); &#125; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN://手指按下时候暂停轮播 pauseAutoCycle(); break; &#125; return false; &#125; /** * preset transformers and their names */ public enum Transformer&#123;//PageTransformer枚举 Default("Default"), Accordion("Accordion"), Background2Foreground("Background2Foreground"), CubeIn("CubeIn"), DepthPage("DepthPage"), Fade("Fade"), FlipHorizontal("FlipHorizontal"), FlipPage("FlipPage"), Foreground2Background("Foreground2Background"), RotateDown("RotateDown"), RotateUp("RotateUp"), Stack("Stack"), Tablet("Tablet"), ZoomIn("ZoomIn"), ZoomOutSlide("ZoomOutSlide"), ZoomOut("ZoomOut"); private final String name; private Transformer(String s)&#123; name = s; &#125; public String toString()&#123; return name; &#125; public boolean equals(String other)&#123; return (other == null)? false:name.equals(other); &#125; &#125;;&#125; 通过分析我们可以对SliderLayout实现思路小结一下： 内部持有一个修改过的ViewPager控件，可以兼容低版本的页面转换动画 内部有一个实现了PagerAdapter的SliderAdapter适配器 内部持有一个PagerIndicator 页面指示器可供选择 维护一个定时任务用于控制轮播 对手势事件进行处理暂停轮播，继续轮播 提供了很多缺省的PageTransformer方便调用 最后在构造函数中初始化ViewPager。 自定义 ViewPager 打造千变万化的图片切换效果ViewPager使用时间长了，他的切换效果容易觉得枯燥，形成一种审美疲劳我们需要改变，学习学习改变ViewPager切换时的效果，实现个性化的图片切换 是不是比传统的效果个性很多，嘿嘿其实很简单，学习完这篇博客，保证你可以自定义切换效果，做出各种丧心病狂的切换 制作前的分析观察下效果图，实际上改变的就是切换时的动画，那么简单了，只需要用户在切换时，拿到当前的View和下一个View，然后添加动画是不是就可以了。好，第一步，获取用户切换时的当前View和切换至的目的View。我们再来看一下，如果获取了当前View和目的View，对于动画我们需要缓慢的变化，最好是根据用户的手势滑动。比如上述效果，用户滑动时，目的图片根据用户滑动距离缓缓出现和慢慢变大。好，第二步，设计动画的梯度变化。经过分析，我们总结出两个步骤，下面我们开始一步一步来打造~~ 获取用户切换时当前View和切换至的目的View。ViewPager也需要监听用户的手势，所以肯定提供了某个方法。于是纵观ViewPager的方法，发现了一个叫做 onPageScrolled(int position, float positionOffset, int positionOffsetPixels)的方法~~没错就是这个方法：在页面滚动时调用~下面仔细研究下这几个参数：直接说测试结果：在非第一页与最后一页时，滑动到下一页，position为当前页位置；滑动到上一页：position为当前页-1positionOffset 滑动到下一页，[0,1)区间上变化；滑动到上一页：(1,0]区间上变化positionOffsetPixels这个和positionOffset很像：滑动到下一页，[0,宽度)区间上变化；滑动到上一页：(宽度,0]区间上变化第一页时：滑动到上一页position=0 ，其他基本为0 ；最后一页滑动到下一页 position为当前页位置，其他两个参数为0豁然发现，我们需要的步骤的第二步解决了，positionOffset很适合作为，渐变，缩放的控制参数；positionOffsetPixels则可以作为平移等的控制参数。 那么如何获得当前View和目的View呢：分享几个我的歧途： 【错误】我通过getChildAt(position)，getChildAt(position+1)，getChildAt(position-1)获得滑动时，左右的两个View；乍一看，还真觉得不错在代码写出来，再乍效果也出不来错误原因：我们忽略一个特别大的东西，ViewPager的机制，滑动时动态加载和删除View，ViewPager其实只会维持2到3个View，而position的范围基本属于无限~~ 【错误】我通过getCurrentItem获得当前的位置，然后+1，-1获得后一个或者前一个正在窃喜，赶快代码改过来，效果怎么也不对，乱七八糟的仔细观察日志，这个getCurrentItem当用户手指离开的屏幕，Page还在动画执行时，就改变了难怪~整个滑动过程并不是固定的唉，心都碎了~ 【错误】position在整个滑动的过程中是不变化的，而且ViewPager会保存2个或3个View;那么我考虑，如果是第一页、或者最后一页那么我取getChildAt(0)和getChildAt(1)，如果在其他页面则为getChildAt(0),getChildAt(2),然后经过一系列的变化～我想这会总该对了吧，于是我遇到第一问题，第一页的时候，不管左右position都为0，尼玛，这哪个为左View，哪个为右View~~说了这么多错误，大家可以绕过这些弯路，也能从这些弯路里面看出点什么~下面说正确的，其实ViewPager在添加一个View或者销毁一个View时，是我们自己的PageAdapter中控制的，于是我们可以在ViewPager里面维系一个HashMap，然后滑动的时候，通过get（position）取出，比如上述效果，始终是右边的View变化，要么从小到大，要么从大到小那么滑倒下一页：左边的View:map.get(position) ，右边的View : map.get(position+1) .那么滑倒上一页：左边的View : map.get(position) ， 右边的View : map.get(position+1) ， 一样的，因为滑到上一页，position为当前页-1好了，至此，我们分析了且解决了所有步骤。 代码MainActivity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.zhy_jazzyviewpager; import android.app.Activity; import android.os.Bundle; import android.support.v4.view.PagerAdapter; import android.view.Menu; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.ImageView.ScaleType; public class MainActivity extends Activity &#123; protected static final String TAG = "MainActivity"; private int[] mImgIds; private MyJazzyViewPager mViewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImgIds = new int[] &#123; R.drawable.a, R.drawable.b, R.drawable.c, R.drawable.d &#125;; mViewPager = (MyJazzyViewPager) findViewById(R.id.id_viewPager); mViewPager.setAdapter(new PagerAdapter() &#123; @Override public boolean isViewFromObject(View arg0, Object arg1) &#123; return arg0 == arg1; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView((View) object); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; ImageView imageView = new ImageView(MainActivity.this); imageView.setImageResource(mImgIds[position]); imageView.setScaleType(ScaleType.CENTER_CROP); container.addView(imageView); mViewPager.setObjectForPosition(imageView, position); return imageView; &#125; @Override public int getCount() &#123; return mImgIds.length; &#125; &#125;); &#125; &#125; 这个很常见的代码，就是初始化ViewPager就没啥可说的了有一点需要注意：在instantiateItem方法，我们多调用了一个mViewPager.setObjectForPosition(imageView, position);其实就是为了给我们的Map存值 主要看自定义的ViewPager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.example.zhy_jazzyviewpager; import java.util.HashMap; import java.util.LinkedHashMap; import android.content.Context; import android.support.v4.view.ViewPager; import android.util.AttributeSet; import android.util.Log; import android.view.View; import com.nineoldandroids.view.ViewHelper; public class MyJazzyViewPager extends ViewPager &#123; private float mTrans; private float mScale; /** * 最大的缩小比例 */ private static final float SCALE_MAX = 0.5f; private static final String TAG = "MyJazzyViewPager"; /** * 保存position与对于的View */ private HashMap&lt;Integer, View&gt; mChildrenViews = new LinkedHashMap&lt;Integer, View&gt;(); /** * 滑动时左边的元素 */ private View mLeft; /** * 滑动时右边的元素 */ private View mRight; public MyJazzyViewPager(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; // Log.e(TAG, "position=" + position+", positionOffset = "+positionOffset+" ,positionOffsetPixels = " + positionOffsetPixels+" , currentPos = " + getCurrentItem()); //滑动特别小的距离时，我们认为没有动，可有可无的判断 float effectOffset = isSmall(positionOffset) ? 0 : positionOffset; //获取左边的View mLeft = findViewFromObject(position); //获取右边的View mRight = findViewFromObject(position + 1); // 添加切换动画效果 animateStack(mLeft, mRight, effectOffset, positionOffsetPixels); super.onPageScrolled(position, positionOffset, positionOffsetPixels); &#125; public void setObjectForPosition(View view, int position) &#123; mChildrenViews.put(position, view); &#125; /** * 通过过位置获得对应的View * * @param position * @return */ public View findViewFromObject(int position) &#123; return mChildrenViews.get(position); &#125; private boolean isSmall(float positionOffset) &#123; return Math.abs(positionOffset) &lt; 0.0001; &#125; protected void animateStack(View left, View right, float effectOffset, int positionOffsetPixels) &#123; if (right != null) &#123; /** * 缩小比例 如果手指从右到左的滑动（切换到后一个）：0.0~1.0，即从一半到最大 * 如果手指从左到右的滑动（切换到前一个）：1.0~0，即从最大到一半 */ mScale = (1 - SCALE_MAX) * effectOffset + SCALE_MAX; /** * x偏移量： 如果手指从右到左的滑动（切换到后一个）：0-720 如果手指从左到右的滑动（切换到前一个）：720-0 */ mTrans = -getWidth() - getPageMargin() + positionOffsetPixels; ViewHelper.setScaleX(right, mScale); ViewHelper.setScaleY(right, mScale); ViewHelper.setTranslationX(right, mTrans); &#125; if (left != null) &#123; left.bringToFront(); &#125; &#125; &#125; 可以看到，核心代码都是onPageScrolled，我们通过findViewFromObject(position); findViewFromObject(position + 1);分别获取了左右两边的View，然后添加动画效果；当前这个例子添加了两个动画，一个是从0.5放大到1.0或者1.0缩小到0.5，没错由我们的positionOffset提供梯度的变化还有个平移的动画：下一页直接移动到当前屏幕（默认是在右边，可以注释这个效果，怎么运行看看），然后不断的通过positionOffsetPixels抵消原来默认移动时的位移，让用户感觉它就在原地放大缩小好了，这样就实现了你可以随便写自己喜欢的动画效果，比如在默认上面加个淡入淡出或者神马，随便是不是很随意~~我们的布局文件： 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.example.zhy_jazzyviewpager.MyJazzyViewPager android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/id_viewPager" /&gt; &lt;/RelativeLayout&gt; JazzyViewPager的使用其实上面的实现就是github上JazzyViewPager的源码，用法不用说了，就是我们的MainActivity，它内置了大概10来种效果，我们可以通过代码或者布局上面设置动画效果我们上面的例子效果，它叫做Stack；使用JazzViewPager的代码：其实基本一样最后也会贴上JazzyViewPager的源码的下载 MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.jfeinstein.jazzyviewpager; import com.jfeinstein.jazzyviewpager.JazzyViewPager.TransitionEffect; import android.app.Activity; import android.os.Bundle; import android.support.v4.view.PagerAdapter; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.ImageView.ScaleType; public class MainActivity extends Activity &#123; protected static final String TAG = "MainActivity"; private int[] mImgIds; private JazzyViewPager mViewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImgIds = new int[] &#123; R.drawable.a, R.drawable.b, R.drawable.c, R.drawable.d &#125;; mViewPager = (JazzyViewPager) findViewById(R.id.id_viewPager); //设置切换效果 mViewPager.setTransitionEffect(TransitionEffect.Stack); mViewPager.setAdapter(new PagerAdapter() &#123; @Override public boolean isViewFromObject(View arg0, Object arg1) &#123; return arg0 == arg1; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView((View) object); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; ImageView imageView = new ImageView(MainActivity.this); imageView.setImageResource(mImgIds[position]); imageView.setScaleType(ScaleType.CENTER_CROP); container.addView(imageView); mViewPager.setObjectForPosition(imageView, position); return imageView; &#125; @Override public int getCount() &#123; return mImgIds.length; &#125; &#125;); &#125; &#125; 与我们的代码唯一区别就是：//设置切换效果mViewPager.setTransitionEffect(TransitionEffect.Stack);它有12中可选的切换效果，其实就是写了12个切换的动画~~~好了，最后附上一个我比较喜欢的效果：Tablet 实现个性的ViewPager切换动画 实战PageTransformer（兼容Android3.0以下）概述本篇博文，将： 介绍如何使用setPageTransformer设置切换动画； 自定义PageTransformer实现个性的切换动画； 该方法在SDK11以下的版本不起作用，我们会对其做一定修改，让其向下兼容。官方示例地址：http://developer.Android.com/training/animation/screen-slide.html 有兴趣的可以去看看~~ setPageTransformer的使用首先我们迅速的实现一个传统的ViewPager效果~ 布局文件1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;android.support.v4.view.ViewPager android:id="@+id/id_viewpager" android:layout_width="fill_parent" android:layout_height="fill_parent" /&gt; &lt;/RelativeLayout&gt; MainActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.zhy.demo_zhy_08_viewpageranim; import java.util.ArrayList; import java.util.List; import android.app.Activity; import android.os.Bundle; import android.support.v4.view.PagerAdapter; import android.support.v4.view.ViewPager; import android.view.View; import android.view.ViewGroup; import android.view.Window; import android.widget.ImageView; import android.widget.ImageView.ScaleType; public class MainActivity extends Activity &#123; private ViewPager mViewPager; private int[] mImgIds = new int[] &#123; R.drawable.guide_image1, R.drawable.guide_image2, R.drawable.guide_image3 &#125;; private List&lt;ImageView&gt; mImageViews = new ArrayList&lt;ImageView&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); initData(); mViewPager = (ViewPager) findViewById(R.id.id_viewpager); mViewPager.setAdapter(new PagerAdapter() &#123; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(mImageViews.get(position)); return mImageViews.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(mImageViews.get(position)); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; @Override public int getCount() &#123; return mImgIds.length; &#125; &#125;); &#125; private void initData() &#123; for (int imgId : mImgIds) &#123; ImageView imageView = new ImageView(getApplicationContext()); imageView.setScaleType(ScaleType.CENTER_CROP); imageView.setImageResource(imgId); mImageViews.add(imageView); &#125; &#125; &#125; 好了，这样一个传统ViewPager就实现了大家对上面代码应该不会有任何陌生的感觉~运行效果也不用贴图了，大家肯定知道 PageTransformerViewPager有个方法叫做：setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer)用于设置ViewPager切换时的动画效果，并且google官方还给出了两个示例。只需要在上述代码中调用setPageTransformer即可添加切换动画效果~~下面演示google的两个PageTransformer的代码，以及运行效果。 DepthPageTransformer12345678910111213141516171819202122232425262728293031323334353637public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 0) &#123; // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125; &#125; 调用代码：mViewPager.setPageTransformer(true, new DepthPageTransformer());效果： ZoomOutPageTransformer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.zhy.view; import android.annotation.SuppressLint; import android.support.v4.view.ViewPager; import android.util.Log; import android.view.View; public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; @SuppressLint("NewApi") public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); Log.e("TAG", view + " , " + position + ""); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) //a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0 &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125; &#125; 调用代码：mViewPager.setPageTransformer(true, new ZoomOutPageTransformer()); 效果： 效果图都是google官网上的，我们的测试图会在兼容3.0以下贴出来，不然就重复了~~为ViewPager添加切换就一行代码是不是很happy，可惜是不兼容3.0以下的版本的，该方法的注释上写到：setting a PageTransformer prior to Android 3.0 (API 11) will have no effect 在3.0之前的版本设置此方法是没有效果的，那么下面我们就看如何让其兼容3.0以下版本。 版本的向下兼容不兼容的原因首先看下为什么不兼容，3.0以下呢？看上面的两个示例代码，代码中View的动画使用的是属性动画，而属性动画是3.0才推出的，那么这么写肯定是不兼容3.0以下了~那么我们首先引入nineoldandroids，让动画先能在3.0以下跑再说：修改DepthPageTransformer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.zhy.view; import com.nineoldandroids.view.ViewHelper; import android.annotation.SuppressLint; import android.support.v4.view.ViewPager; import android.view.View; public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. // view.setAlpha(0); ViewHelper.setAlpha(view, 0); &#125; else if (position &lt;= 0)// a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0 &#123; // [-1,0] // Use the default slide transition when moving to the left page // view.setAlpha(1); ViewHelper.setAlpha(view, 1); // view.setTranslationX(0); ViewHelper.setTranslationX(view, 0); // view.setScaleX(1); ViewHelper.setScaleX(view, 1); // view.setScaleY(1); ViewHelper.setScaleY(view, 1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. // view.setAlpha(1 - position); ViewHelper.setAlpha(view, 1 - position); // Counteract the default slide transition // view.setTranslationX(pageWidth * -position); ViewHelper.setTranslationX(view, pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - position); // view.setScaleX(scaleFactor); ViewHelper.setScaleX(view, scaleFactor); // view.setScaleY(1); ViewHelper.setScaleY(view, scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. // view.setAlpha(0); ViewHelper.setAlpha(view, 1); &#125; &#125; &#125; 很简单，把所有属性动画换成ViewHelper去设置就好了。现在我们去3.0以下的机子上去运行，发现还是没有效果~~为什么呢？我们再去看看setPageTransformer的源码： 1234567891011121314public void setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) &#123; if (Build.VERSION.SDK_INT &gt;= 11) &#123; final boolean hasTransformer = transformer != null; final boolean needsPopulate = hasTransformer != (mPageTransformer != null); mPageTransformer = transformer; setChildrenDrawingOrderEnabledCompat(hasTransformer); if (hasTransformer) &#123; mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD; &#125; else &#123; mDrawingOrder = DRAW_ORDER_DEFAULT; &#125; if (needsPopulate) populate(); &#125; &#125; 终于发现原因了，原来在此方法内部判断了如果是11以上的版本才让动画生效~~那么，没办法了，如果想兼容，必须修改ViewPager的源码了~~ 完美向下兼容我们将ViewPager的源码拷贝一份至我们的项目中，修改名称为ViewPagerCompat；然后注释掉SDK版本判断那一句 1234567891011121314151617public class ViewPagerCompat extends ViewGroup &#123; public void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer) &#123; // if (Build.VERSION.SDK_INT &gt;= 11) &#123; final boolean hasTransformer = transformer != null; final boolean needsPopulate = hasTransformer != (mPageTransformer != null); mPageTransformer = transformer; setChildrenDrawingOrderEnabledCompat(hasTransformer); if (hasTransformer) &#123; mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD; &#125; else &#123; mDrawingOrder = DRAW_ORDER_DEFAULT; &#125; if (needsPopulate) populate(); &#125; &#125; &#125; 注意，所有的PageTransformer使用ViewPager.PageTransformer然后我们把项目中的ViewPager改为ViewPagerCompat；记得修改布局文件，以及MainActivity中的ViewPager为ViewPagerCompat我们在2.3.3的模拟器上测试下效果： 可以看到，我们的切换动画完美的运行在2.3.3的机器上so happy ~~没有ViewPager源码的童鞋不要紧，我会在文末的源码下载中加入ViewPager源码，让你可以尽情去测试当然了，仅仅是兼容当然不能满足我们的好奇心，难道我们做到了兼容，还只能使用Google给的示例动画么我们强大的创新呢下面带领大家分析setPageTransformer方法，然后设计一个个性的动画切换效果 自定义PageTransformer实现个性切换动画123456789101112public interface PageTransformer &#123; /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ public void transformPage(View page, float position); &#125; 可以看到该接口只有一个方法，第一个是我们的view，第二个是position~~当我们滑动时：会打印出当然ViewPager中存活的每个View以及它们的position的变化注意是每一个，所以建议别只log position，不然你会觉得莫名其妙的输出position的可能性的值有，其实从官方示例的注释就能看出：[-Infinity,-1) 已经看不到了(1,+Infinity] 已经看不到了 [-1,1]重点看[-1,1]这个区间 ， 其他两个的View都已经看不到了~~ 假设现在ViewPager在A页现在滑出B页，则:A页的position变化就是( 0, -1]B页的position变化就是[ 1 , 0 ]知道了我们滑动时position的变化~~那么就开始设计我们的个性的切换效果；官方给的例子，有变化透明度、偏移量、缩放的，我们准备来个不一样的，我们变化角度，即rotation;大概的效果是这样的： 下面我们分析代码：我们设置View的旋转中心为：ViewHelper.setPivotX(view, view.getMeasuredWidth() 0.5f);ViewHelper.setPivotY(view, view.getMeasuredHeight());依然是ViewPager在A页现在滑出B页那么A页应当在滑动过程中0度到-20度的偏移，B页应当在滑动过程中+20度到0度的偏移结合A页的position变化就是( 0, -1]B页的position变化就是[ 1 , 0 ]那么旋转的角度即：mRot = (20 position); A页 mRot :0 ,~ -20 ; B页 mRot :20 ~ 0 ;瞬间觉得好简单： 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.zhy.view; import com.nineoldandroids.view.ViewHelper; import android.annotation.SuppressLint; import android.support.v4.view.ViewPager; import android.util.Log; import android.view.View; public class RotateDownPageTransformer implements ViewPager.PageTransformer &#123; private static final float ROT_MAX = 20.0f; private float mRot; public void transformPage(View view, float position) &#123; Log.e("TAG", view + " , " + position + ""); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. ViewHelper.setRotation(view, 0); &#125; else if (position &lt;= 1) // a页滑动至b页 ； a页从 0.0 ~ -1 ；b页从1 ~ 0.0 &#123; // [-1,1] // Modify the default slide transition to shrink the page as well if (position &lt; 0) &#123; mRot = (ROT_MAX * position); ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f); ViewHelper.setPivotY(view, view.getMeasuredHeight()); ViewHelper.setRotation(view, mRot); &#125; else &#123; mRot = (ROT_MAX * position); ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f); ViewHelper.setPivotY(view, view.getMeasuredHeight()); ViewHelper.setRotation(view, mRot); &#125; // Scale the page down (between MIN_SCALE and 1) // Fade the page relative to its size. &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. ViewHelper.setRotation(view, 0); &#125; &#125; &#125; 你没看错，if else 里面代码是一样的，为了好理解特意没有合并到一起~~ 到此，我们从setPageTransformer使用，到修改ViewPager做到向下兼容，直至自己定义出个性的切换效果 都已经介绍完毕～～大家可以发挥自己的创造力，做出各种神奇的动画效果，ok，就到这里！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Android Studio 快捷键]]></title>
      <url>%2F2017%2F06%2F01%2Fandroid-studio-keywords%2F</url>
      <content type="text"><![CDATA[常用快捷键自动补全 使用Enter会补全你选择的语句 使用Tab的话，会替换掉你之前在这里的内容（删除后面的语句直到遇到点号，逗号，分号） 自动缩进对齐ctr + alt + I 返回编辑器窗口 Esc: 返回编辑器 Shift + Esc: 返回编辑器并关闭当前窗口 快捷打开窗口 Mac: Cmd + 数字 windows/Linux: Alt + 数字 任意窗口切换Ctrl + Tab可以让你切换到任意窗口！在这个切换窗口打开的时候，你可以直接按数字切换到对应的工具窗口，或者输入字母搜索右边的编辑器窗口，如果你需要关闭某个窗口，在上面按BackSpace即可。 隐藏所有窗口 Mac: CMD + Shift + F12 windows/Linux: Ctrl + shift + F12如果需要恢复所有窗口，再按一次这个快捷键即可。 参数提示这个功能估计很多人知道了，但是还是提一下。在自动补全以后，如果某个方法参数超级长，你不知道参数是什么怎么办？可以试试这个。 Mac: CMD + P win/Linux: Ctrl + P 自动生成变量作为一门静态类型语言， Java 是有一定的类型推导能力的；那么你是否经常书写: 12String testStr = "testStr";List&lt;String&gt; testStrings = new ArrayList&lt;String&gt;(); 其实大可不必写那些恼火的类型声明的，一看就知道 1testStr, testStrings 就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。 Mac: Cmd + Alt + V Win/Linux: Ctrl + Alt + V 有的童鞋可能会问了：我使用ArrayList, HashMap的时候，习惯类型声明为List,Map等接口，这个自动生成的类型声明还是具体的实现啊，怎么办？这一点IDE已经帮你想到了，试试shift + tab,他会给你一个可以选择的类型列表～ 自动提取参数有时候你正在写一个方法的时候发现。哎哟，这个变量最好是当作参数传递进来啊；要做成这么一件事，你必须把这个方法内部所有使用这个局部变量的地方替换，把所有调用这个函数的地方添加参数，繁琐至极！好了有了这个你可以随便玩了： Mac: Cmd + Alt + P Win/Linux: Ctrl + Alt + P 当然，如果你想保留原来的方法，只是搞一个参数不同的方法（重载）出来，可以在弹出的那个对话框里面打勾。 自动提取方法写代码的时候是否会发现不知不觉的这个方法已经太长了，适合分解然后提取出一个个子方法；或者是重构的时候看到一个一两千的函数，你是不是头都大了？一般情况下，我们都是把要提取的代码copy出来，然后写一个方法（还要什么该死的方法签名）然后把这段代码复制进来；其实这个过程是机械的，完全可以由IDE完成： Mac: Cmd + Alt + M Win/Linux: Ctrl + Alt + M 如果想改变方法的签名，在对话框里面选择你需要的就可以了～ 上面提到了三个快捷键其实是比较类似的，如何记忆呢？ 首先组合键都是Cmd/Ctrl + Alt 然后提取变量Variable=V，参数Parameters=P，方法Method=M 内联变量/参数/方法好了学会了上面那几个快捷键，万一玩high了，比如提取了太多的方法，想“弄回去”，该怎么办呢？这个操作叫他Inline.. Mac: Cmd + Alt + N Win/Linux: Ctrl + Alt + N 上面那个图只是参考，其实不仅可以作用于变量，还可以是方法/参数，个人觉得方法inline比较有用。 万能重构键静态类型语言重构起来相对容易的，但是通常修改一个地方会牵扯到很多别的地方，我们只有一处一处找到这些编译错误然后手动修复。其实有好多工作是可以自动完成的，比如删除某个方法；先确认有没有人调用（Alt ＋ F7），没有的话把方法体删了，有的话去看看调用的地方再决定怎么办。但是重构的操作实在是太多了！我们没有办法也没有必要一个个记住，知道这个快捷键即可，我叫他万能重构键: Mac : Ctrl + T Win/Linux: Ctrl + Alt + Shift + T 在Win/ Linux 上可以考虑把这个快捷键改一下键，一下按四个键臣妾很难做到啊。。 重命名shift + F6 查找当前文件在项目中的位置快捷键: Alt + F1 拓展选择这个功能应该很多人都知道；但还是说明一下，因为跟下面两个功能跟这个结合起来才有威力。这个功能太强大了，自己去按几遍就能想到很多使用场景了；我相信有了这个功能，你使用鼠标的机会会少很多。 Mac: Alt + up/down Win/Linux: ctrl + w / ctrl + shift + w Surround With..如果你想把一段代码使用if语句包起来；又或者使用try包围一段可能有运行时异常的代码，你会怎么干？首先用光标定位到代码块开头，写上 try {然后，光标代码块末尾加} catch (XXXRuntimeException e) {// todo}？可以试试这个快捷键。 Mac: cmd + alt + t Win/Linux: ctrl + alt + t 可以使用上面的拓展选择选择你需要的代码块，然后使用这个功能Surround With；如果你什么都不选择的话，那么默认选择的是光标所在行。 Unwrap/Remove这个功能跟上面提到的是一对，有了Surround With自然就有Unsurround With;使用情况没有上面那个那么多，但是好歹一对，一起介绍吧。 高亮某东西有时候看代码的时候，看到某个变量想知道哪里使用了它；你还在用肉眼查找吗？或者你杀鸡用牛刀Find Usgae？其实你的需求就是把这个变量全部给我打个标签，我想直观的知道它在哪。 Mac: cmd + shift + F7 Win/Linux: ctrl + shift + F7这个键功能远不止这个！ 如果你高亮return或者throw，那么会把这个方法所有的返回点高亮出来！ 高亮某个类的extends或者implements会把这个类Override的方法高亮出来 高亮import会把使用的地方显示出来如果不想要高亮了，按下Esc就行。 显示方法调用树在看源码的时候，你还是使用alt + F7和ctrl + B在各个类之间来回穿梭吗？其实好多时候你就是想知道这个调用结构是怎么样的而已；谁是怎么一步一步滴调用谁的；这个快捷键会给你一个调用树。有了这个大菊观，继续探讨就很容易了。快捷键: ctrl + alt + h 万能快捷键记得之前提到过一个万能重构键, 有关重构的一切操作都可通过它完成。那么Android Studio这么快捷键，这么多功能，臣妾怎么可能都记住！要是有万能钥匙就好了！That’s it!使用这个快捷键，你想到什么功能，打开它搜索就可以了；打个比方，我想看看 Java 的for each循环和普通的for循环底层是不是同一个实现;那么我就需要看虚拟机字节码了；我记得有这个功能但是不知道快捷键是啥；OK，Cmd + shift + A，输入bytecode: 删除当前行 Mac: ctrl + Y Win/Linux: Command + Y Find usagealt+F7 格式化代码 Mac: alt+command+L Win/Linux: ctrl+alt+L 优化import Mac: alt+command+O Win/Linux: ctrl+alt+O Declaration查看定义 Mac: command+B Win/Linux: ctrl+B 快递定位并高亮错误（deprecate，unused） Mac: (shift+)F2 Win/Linux: F2 Override Methods Mac: command+O Win/Linux: ctrl+O Implement Methods Mac: command+I Win/Linux: ctrl+I Super Method（Class） Mac: command+U Win/Linux: ctrl+U Previous/Next Methodcontrol+上下方向键 引入包，添加注释…alt+enter Runshift+F10 Debugshift+F9 Make Project Mac: command+F9 Win/Linux: ctrl+F9 Make Module Mac: shift+command+F9 Win/Linux: shift+ctrl+F9 关闭当前的执行的task Mac: command+F2 Win/Linux: ctrl+F2 添加/取消断点 Mac: command+F8 Win/Linux: ctrl+F8 查看所有断点 Debug Mac: shift+command+F8 Win/Linux: shift+ctrl+F8 Step Into F7 Step OverF8 Step outshift+F8 resumeF9 Run to Cursoralt+F9 Find Mac: command+F Win/Linux: command+F Replace Mac: command+R Win/Linux: command+R Find in Pathcontrol+shift+F Replace in Pathcontrol+shiftÏ+R Back/Forward操作 Mac: alt+command+左右方向键 Win/Linux: alt+ctrl+左右方向键 Recent File Mac: command+E Win/Linux: ctrl+E Recently Change Files Mac: shift+command+E Win/Linux: shift+ctrl+E Search Method或者Class(Search Everywhere：command+N,shift+command+N,shift+alt+command+N)shift+shift Search Class Mac: command+N Win/Linux: ctrl+N Search File Mac: shift+command+N Win/Linux: shift+ctrl+N Search Symbol Mac: shift+alt+command+N Win/Linux: shift+alt+ctrl+N Move Line Up/Move Line Down Mac: shift+command+上下方向键 Win/Linux: shift+ctrl+上下方向键 常用技巧书签（Bookmarks） 描述：这是一个很有用的功能，让你可以在某处做个标记（书签），方便后面再跳转到此处。 调用：Menu → Navigate → Bookmarks 快捷键： 添加/移除书签： OS X: F3 Windows/Linux: F11 添加/移除书签(带标记)： OS X: Alt + F3 Windows/Linux: Ctrl + F11 显示全部书签显示所有的书签列表，并且是可以搜索的。 OS X: Cmd + F3 Windows/Linux: Shift + F11 上一个/下一个书签：无，可以在设置中设置快捷键。 更多：当你为某个书签指定了标记，你可以使用快捷键 Ctrl + 标记 来快速跳转到标记处，比如输入Ctrl + 1，跳到标记为1的书签处 折叠/展开代码块（Collapse Expand Code Block） 描述：该操作提供一种方法，让你隐藏你不关心的部分代码，以一种较为简洁的格式显示关键代码。一个有意思的用法是隐藏匿名内部类的代码，让其看起来像一个Lambda表达式。 快捷键： OS X: Cmd + “+”/”-“ Windows/Linux: Ctrl + Shift + “+”/”-“ 更多：可以在Settig → Editor → General → Code Folding 中设置折叠规则。 与分支比对（Compare With Branch (Git)） 描述：假如你的项目是使用git来管理的，你可以将当前文件或者文件夹与其他的分支进行比对。比较有用的是可以让你了解到你与主分支有多少差别。 调用：Menu → VCS → Git → Compare With Branch 与剪切板比对（Compare With Clipboard） 描述：将当前选中的部分与剪切板上的内容进行比对。 调用：右键选中的部分，在右键菜单中选择“Compare With Clipboard”。 上下文信息（Context Info） 描述：当前作用域定义超过滚动区域，执行该操作将显示所在的上下文信息，通常它显示的是类名或者内部类类名或者当前所在的方法名。该操作在xml文件中同样适用。 调用：Menu → View → Context Info 快捷键：Alt + Q (Windows/Linux) 更多：个人认为，这个功能更好的用法是快速查看当前类继承的父类或者实现的接口。 查找操作（Find Action） 描述：输入某个操作的名称，快速查找，对于没有快捷键的部分操作这是一个很有用的技巧。 快捷键： OS X: Cmd +Shift + A Windows/Linux: Ctrl + Shift + A 更多：当某个操作是有快捷键的，会显示在旁边。 查找补全（Find Complection） 描述：当你在一个文件中进行查找时，使用自动补全快捷键可以给出在当前文件中出现的建议单词； 快捷键：输入一些字符，然后使用自动补全 OS X: Cmd + F Windows/Linux: Ctrl + F 隐藏所有面板（Hide All Panels） 描述：切换编辑器铺满整个程序界面，隐藏其他的面板。再次执行该操作，将会回到隐藏前的状态。 调用：Menu → Window → Active Tool Window → Hide All Windows； 快捷键： OS X: Cmd +Shift + F12 Windows/Linux: Ctrl + Shift + F12 高亮一切（Hightlight All the Things） 描述：该操作将会高亮某个字符在当前文件中所有出现的地方。这不仅仅是简单的匹配，实际上它会分析当前的作用域，只高亮相关的部分。 调用：Menu → Edit → Find → Highlight Usages in File； 定位到上一处/下一处：Menu → Edit → Find → Find Next/Previous； 快捷键：相关快捷键请在菜单中查看； 更多： 如果高亮一个方法的return或throw语句，将会高亮这个方法的所有出口/结束点； 如果高亮某个类定义处的extend或implements语句，将会高亮继承的或实现的方法； 高亮一个import语句也会高亮使用到的地方； 按下Esc可以退出高亮模式； 回到上一个工具窗口（Jump to Last Tool Window） 描述：有时候你会从某个工具窗口跳到编辑器里面，然后又需要重新回到刚才操作的那个工具窗，比如你查找使用情况的时，使用该操作可以在不使用鼠标的情况下跳转到之前的工具窗口。 快捷键：F12 上一个编辑位置（Last Edit Location） 描述：该操作将使得你导航到上一处你改动过的地方，这与点击工具栏上的返回箭头回到上一个定位位置是不一样的，该操作将会返回到上一个编辑的位置。 快捷键： OS X: Cmd + Shift + Delete Windows/Linux: Ctrl + Shift + Backspace 在方法和内部类之间跳转（Move Between Methods and Inner Classes） 描述：该操作让光标在当前文件的方法或内部类的名字间跳转。 调用：Navigate → Next Method/Previous Method; 快捷键： OS X: Ctrl + Up/Down Windows/Linux: Alt + Up/Down 定位到嵌套文件（Navigate to Nested File） 描述：有时你有一堆存放在不同目录下的同名文件，例如不同模块下的AndroidManifest.xml文件，当你想定位到其中的一个文件，你会得到一堆搜索结果，你还得辨认哪个才是你需要的。通过在检索框中输入部分路径的前缀，并添加斜杠号，你就可以在第一次尝试的时候就找到正确的那个。 快捷键： OS X：Shift + Cmd + O Windows/Linux: Shift + Ctrl + N 定位到父类（Navigate to parent） 描述：如果光标是在一个继承父类重写的方法里，这个操作将定位到父类实现的地方。如果光标是在类名上，则定位到父类类名。 Menu → Navigate → Super Class/Method 快捷键： OS X: Cmd + U Windows/Linux: Ctrl + U 根据编号打开面板（Open a Panel by Its Number） 描述：你可能已经注意到某些面板的名称左边有一个数字，这里有个快捷操作可以打开它们。如果你没看到面板的名称，请点击IDE的左下角的切换按钮。 快捷键： OS X: Cmd + 数字 Windows/Linux: Alt + 数字 在外部打开文件（Open File Externally） 描述：通过这个快捷键，简单地点击 Tab，就可以打开当前文件所在的位置或者该文件的任意上层路径。 快捷键： OS X: Cmd + 单击Tab Windows/Linux: Ctrl + 点击Tab 参数信息（Parameter Info） 描述：这个操作将显示和你在方法声明处写一样的参数列表，当你想看某个存在的方法的参数，这是一个很有用的操作。光标下的参数显示为黄色，如果没有参数显示黄色，意味着你的方法调用是无效的，很可能是某个参数分配不对。（例如一个浮点数赋值给了整型参数）。如果你正在写一个方法调用，突然离开编辑的地方，再返回的时候，输入一个逗号，就可以重新触发参数信息。 快捷键： OS X: Cmd + P Windows/Linux: Ctrl + P 快速查看定义（Quick Definition Lookup） 描述：你曾经是否想查看一个方法或者类的具体实现，但是不想离开当前界面？ 该操作可以帮你搞定。 快捷键： OS X: Alt + Space / Cmd + Y Windows/Linux: Ctrl + Shift + I 最近修改的文件（Recently Changed Files） 描述：该操作类似于“最近访问（Recents）”弹窗，会显示最近本地修改过的文件列表，根据修改时间排列。可以输入字符来过滤列表结果。 快捷键： OS X: Cmd + Shift + E Windows/Linux: Ctrl + Shift + E 最近访问（Recents） 描述：该操作可以得到一个最近访问文件的可搜索的列表。 快捷键： OS X: Cmd + E Windows/Linux: Ctrl + E 相关文件（Related File） 描述：该操作有助于在布局文件和Activity/Fragment之间轻松跳转。这也是一个快捷操作，在类名/布局顶端的左侧。 快捷键： OS X: Ctrl + Cmd + Up Windows/Linux: Ctrl + Alt + Home 返回到编辑器（Return to the Editor） 描述：一大堆快捷键操作会把你从编辑器带走（type hierarchy, find usages, 等等）。如果你想返回到编辑器，你有两个选项： Esc：该操作仅仅把光标移回编辑器。 Shift + Esc：该操作会关闭当前面板，然后把光标移回到编辑器。 快捷键： 返回但保留打开的面板：Esc 关闭面板并返回：Shift + Esc Select In 描述：拿着当前文件然后问你在哪里选中该文件。恕我直言，最有用的就是在项目结构或者资源管理器中打开该文件。每一个操作都有数字或者字母作为前缀，可以通过这个前缀来快速跳转。通常，我会 Alt + F1 然后 回车(Enter) 来打开项目视图，然后 再用 Alt + F1 在OS X的Finder里找到文件。你可以在文件中或者直接在项目视图里使用该操作。 快捷键：Alt + F1 扩大/缩小选择（Extend/Shrink Selection） 描述：该操作会在上下文逐渐扩大/缩小当前选择范围。例如，它会先选中当前变量，再选中当前语句，然后选中整个方法，缩小选择则相反。 快捷键： OS X: Alt + 上/下 Windows、Linux: Ctrl+W / Ctrl + Shift + W Sublime Text式的多处选择（Sublime Text Multi Selection） 描述：这个功能超级赞！该操作会识别当前选中字符串，选择下一个同样的字符串，并且添加一个光标。这意味着你可以在同一个文件里拥有多个光标，你可以同时在所有光标处输入任何东西。 快捷键： OS X: Ctrl + G Windows、Linux: Alt + Ｊ 文件结构弹窗（The File Structure Popup） 描述：该操作可以展示当前类的大纲，并且可以快速跳转。你还可以通过键盘输入来过滤结果。这是一种很高效的方法来跳转到指定方法。 更多： 你在输入字符的时候可以用驼峰风格来过滤选项。比如输入”oCr”会找到”onCreate” 你可以通过勾选多选框来决定是否显示匿名类。这在某些情况下很有用，比如你想直接跳转到一个OnClickListener的onClick方法。 快捷键： OS X: Cmd + F12 Windows/Linux: Ctrl + F12 调用：Menu → Navigate → File Structure 切换器（The Switcher） 描述：该快捷键基本上就是IDE的alt+tab/cmd+tab命令。你可以用它在导航tab或者面板切换。一旦打开这个窗口，只要一直按着ctrl键，你可以通过对应的数字或者字母快捷键快速选择。你也可以通过backspace键来关闭一个已选中的tab或者面板。 快捷键：Ctrl + Tab 版本控制操作弹窗（VCS Operations Popup） 描述：该操作会给你显示最常用的版本控制操作。如果你的项目没有用git等版本控制软件进行管理，它至少会给你提供一个由IDE维护的本地历史记录。 快捷键： OS X: Ctrl + V Windows/Linux: Alt + 引号 编码技巧列选择/块选择（Column Selection） 描述：正常选择时，当你向下选择时，会直接将当前行到行尾都选中，而块选择模式下，则是根据鼠标选中的矩形区域来选择。 调用：按住Alt，然后拖动鼠标选择。 开启/关闭块选择：Menu → Edit → Column Selection Mode 快捷键：切换块选择模式： OS X：Cmd + Shift + 8 Windows/Linux: Shift + Alt + Insert 语句补全（Complete Statement） 描述：这个方法将会生成缺失的代码来补全语句，常用的使用场景如下： 在行末添加一个分号，即使光标不在行末； 为if、while、for 语句生成圆括号和大括号； 方法声明后，添加大括号； 调用：Menu → Edit → Compelete Current Statement 快捷键： OS X: Cmd + Shift + Enter Windows/Linux: Ctrl + Shift + Enter 更多：如果一个语句已经补全，当你执行该操作时，则会直接跳到下一行，即使光标不在当前行的行末。 删除行（Delete Line） 描述：如果没选中，则删除光标所在行，如果选中，则会删除选中所在的所有行。 快捷键： OS X: Cmd + Delete Windows/Linux: Ctrl + Y 行复制（Duplicate Line） 描述：复制当前行，并粘贴到下一行，这个操作不会影响剪贴板的内容。这个命令配合移动行快捷键非常有用。 快捷键： OS X: Cmd + D Windows/Linux: Ctrl + D 编写正则表达式（Edit Regex） 描述：使用Java编写正则表达式是一件很困难的事，主要原因是： 你必须得避开反斜杠； 说实话，正则很难； 看第二条。 IDE能帮我们干点啥呢？当然是一个舒服的界面来编写和测试正则啦~ 快捷键：Alt + Enter → check regexp 使用Enter和Tab进行代码补全的差别（Enter vs Tab for Code Completion） 描述：代码补全时，可以使用Enter或Tab来进行补全操作，但是两者是有差别的。 使用Enter时：从光标处插入补全的代码，对原来的代码不做任何操作。 使用Tab时：从光标处插入补全的代码，并删除后面的代码，直到遇到点号、圆括号、分号或空格为止。 提取方法（Extract Method） 描述：提取一段代码块，生成一个新的方法。当你发现某个方法里面过于复杂，需要将某一段代码提取成单独的方法时，该技巧是很有用的。 调用：Menu → Refactor → Extract → Method 快捷键： OS X: Cmd + Alt + M Windows/Linux: Ctrl + Alt + M 更多：在提取代码的对话框，你可以更改方法的修饰符和参数的变量名。 提取参数（Extract Parameter） 描述：这是一个提取参数的快捷操作。当你觉得可以通过提取参数来优化某个方法的时候，这个技巧将很有用。该操作会将当前值作为一个方法的参数，将旧的值放到方法调用的地方，作为传进来的参数。 调用：Menu → Refactor → Extract → Parameter 快捷键： OS X: Cmd + Alt + P Windows/Linux: Ctrl + Alt + P 更多：通过勾选“delegate”，可以保持旧的方法，重载生成一个新方法。 提取变量（Extract Variable） 描述：这是一个提取变量的快捷操作。当你在没有写变量声明的直接写下值的时候，这是一个很方便生成变量声明的操作，同时还会给出一个建议的变量命名。 调用：Menu → Refactor → Extract → Variable 快捷键： OS X: Cmd + Alt + V Windows/Linux: Ctrl + Alt + V 更多：当你需要改变变量声明的类型，例如使用 List 替代 ArrayList，可以按下Shift + Tab，就会显示所有可用的变量类型。 内置（Inline） 描述：当你开始对提取操作有点兴奋的时候，突然觉得东西太多了，怎么办呢？这是一个和提取相反的操作。该操作对方法、字段、参数和变量均有效。 调用：Menu → Refactor → Inline 快捷键： OS X: Cmd + Alt + N Windows/Linux: Ctrl + Alt + N 合并行和文本（Join Lines and Literals） 描述：这个操作比起在行末使劲按删除键爽多了！该操作遵守格式化规则，同时： 合并两行注释，同时移除多余的//； 合并多行字符串，移除+和双引号； 合并字段的声明和初始化赋值； 快捷键：Ctrl + Shift + J 动态模板（Live Templates） 描述：动态模板是一种快速插入代码片段的方法，使用动态模板比较有意思的是你可以使用合适的默认值将模板参数化，当你插入代码片段时，这可以指导你完成参数。 更多：如果你知道模板的缩写，就可以不必使用快捷键，只需要键入缩写并使用Tab键补全即可。 快捷键： OS X: Cmd + J Windows/Linux: Ctrl + J 上下移动行（Move Lines Up Down） 描述：不需要复制粘贴就可以上下移动行了。 快捷键：Alt + Shift + Up/Down 移动方法（Move Methods） 描述：这个操作和移动行操作很类似，不过该操作是应用于整个方法的，在不需要复制、粘贴的情况下，就可以将整个方法块移动到另一个方法的前面或后面。该操作的实际叫做“移动语句”，这意味着你可以移动任何类型的语句，你可以方便地调整字段或内部类的顺序。 快捷键： OS X: Cmd + Alt + Up/Down Windows/Linux: Ctrl + Shift + Up/Down 取反补全（Negation Completion） 描述：有时你自动补全一个布尔值，然后回到该值的前面添加一个感叹号来完成取反操作，现在通过使用输入!代替enter完成补全操作，就可以跳过这些繁琐的操作了。 快捷键：代码补全的时候，按下!即可（有时需要上下键选中候选项）； 后缀补全（Postfix Completion） 描述：你可以认为该操作是一种代码补全，它会在点号之前生成代码，而不是在点号之后。实际上你调用这个操作和正常的代码补全操作一样：在一个表达式之后输入点号。 例如对一个列表进行遍历，你可以输入myList.for，然后按下Tab键，就会自动生成for循环代码。 调用： 你可以在某个表达式后面输入点号，出现一个候选列表，在常规的代码补全提示就可以看到一系列后缀补全关键字，同样的，你也可以在Editor → Postfix Completion中看到一系列后缀补全关键字。 常用的有后缀补全关键字有： .for (补全foreach语句) .format (使用String.format()包裹一个字符串) .cast (使用类型转化包裹一个表达式) 重构（Refactor This） 描述：该操作可以显示所有对当前选中项可行的重构方法。这个列表可以用数字序号快速选择。 快捷键：Ctrl + T(OS X)、Ctrl + Alt + Shift + T(Windows/Linux) 重命名（Rename） 描述：你可以通过该操作重命名变量、字段、方法、类、包。当然了，该操作会确保重命名对上下文有意义，不会无脑替换掉所有文件中的名字； 快捷键：Shift + F6 更多：如果你忘记了这个快捷键，你可以使用快速修复（Quick Fix）的快捷键，它通常包含重命名选项。 分号/点 补全（Semicolon Dot Completion） 描述：代码补全这个功能太棒啦！我们大概都对以下这种情况很熟悉：开始输入点什么东西，接着从IDE得到一些建议的选项，然后通过Enter或者Tab来选择我们想要的补全代码。其实还有另外一种方法来选择补全的代码：我们可以输入一个点(.)或者一个分号(;)。这样就会完成补全，添加所选字符。这在结束一条语句补全或者快速链式调用方法的时候特别有用。 注意点：如果你要代码补全的方法需要参数，这些参数会被略过。 快捷键：Autocomplete + “.” 或者 “;” 包裹代码（Surround With） 描述： 该操作可以用特定代码结构包裹住选中的代码块，通常是if语句，循环，try/catch语句或者runnable语句。 如果你没有选中任何东西，该操作会包裹当前一整行。 快捷键： OS X: Cmd + Alt + T Windows/Linux: Ctrl + Alt + T 移除包裹代码（Unwrap Remove） 描述：该操作会移除周围的代码，它可能是一条if语句，一个while循环，一个try/catch语句甚至是一个runnable语句。该操作恰恰和包裹代码（Surround With）相反。 快捷键： OS X: Cmd + Shift + Delete Windows/Linux: Ctrl + Shift + Delete 手动唤出自动补全（Class Name Completion） 描述：一般使用 Android Studio 的时候，自动提示会在你想要提示的时候自动出现，比如输入 Log. ，就出现 Log.d()、Log.e、Log.i() 等提示。不过如果在自动提示的时候手一抖选错的话，比如想选 Log.d() 结果选了 Log.e() ，你可能会把 .e() 都删掉，然后再输入一个 . ， 然后弹出自动补全提示。其实这时候只需要删除 e() 然后手动唤出自动补全即可。 快捷键： OS X/Windows/Linux: Ctrl + Alt + Space (可能存在快捷键冲突无法唤出，修改下快捷键即可) 调试技巧分析传入数据流（Analyze data flow to here） 描述：这个操作将会根据当前选中的变量、参数或者字段，分析出其传递到此处的路径。 当你进入某段陌生的代码，试图明白某个参数是怎么传递到此处的时候，这是一个非常有用的操作。 调用：Menu → Analyze → Analyze Data Flow to Here 快捷键：无，可以在设置中指定。 相反的操作：分析传出数据流（Analyze data flow from here），这个将会分析当前选中的变量往下传递的路径，直到结束。 堆栈追踪分析（Analyze Stacktrace） 描述： 这个操作读取一份堆栈追踪信息，并且使它像logcat中那样可以点击。当你从bug报告中或者终端复制了一份堆栈追踪，使用该操作可以很方便地调试。 调用：Menu → Analyze → Analyze Stacktrace 快捷键：无，可以在设置中指定。 更多：通过使用“ProGuard Unscramble Plugin”插件，也可以分析混淆过的堆栈追踪。 关联调试程序（Attach Debugger） 描述：随时启动调试程序，即使你没有以调试模式启动你的应用。这是一个很方便的操作，因为你不必为了调试程序而以调试模式重新部署你的应用。当别人正在测试应用，突然遇到一个bug而将设备交给你时，你也可以很快地进入调试模式。 调用：点击工具栏图标或者Menu → Build → Attach to Android Process 快捷键：无，可以在设置中指定，或者点击工具栏对应的图标。 条件断点（Conditional Breakpoints） 描述：简单说，就是当设定的条件满足时，才会触发断点。你可以基于当前范围输入一个java布尔表达式，并且条件输入框内是支持代码补全的。 调用：右键需要填写表达式的断点，然后输入布尔表达式。 禁用断点（Disable Breakpoints） 这个操作将使得断点。当你有一个设置过复杂条件的断点或者是日志断点，当前不需要，但是下次又不用重新创建，该操作是很方便的。 调用：按住Alt，然后单击断点即可。 计算表达式（Evaluate Expression） 描述：这个操作可以用来查看变量的内容并且计算几乎任何有效的java表达式。需要注意的是，如果你修改了变量的状态，这个状态在你恢复代码执行后依然会保留。 快捷键：处在断点状态时，光标放在变量处，按Alt + F8，即可显示计算表达式对话框。 审查变量（Inspect Variable） 描述：该操作可以在不打开计算表达式对话框就能审查表达式的值。 快捷键：调试状态下，按住Alt键，然后单击表达式即可。 日志断点（Logging Breakpoints） 描述：这是一种打印日志而不是暂停的断点，当你想打印一些日志信息但是不想添加log代码后重新部署项目，这是一个非常有用的操作。 调用：在断点上右键，取消Suspend的勾选，然后勾选上Log evaluated Expression，并在输入框中输入你要打印的日志信息。 标记对象（Mark Object） 描述：当你在调试的时候，这个操作可以让你给某个特殊的对象添加一个标签，方便你后面很快地辨认。在调试时，当你从一堆相似的对象中查看某个对象是否和之前是一样的，这就是一个非常有用的操作。 调用：右键你需要标记的对象，选中Mark Object，输入标签； 快捷键：选中对象时 OS X: F3 Windows/Linux: F11 显示当前运行点（Show Execution Point） 描述：该操作会立刻把你的光标移回到当前debug处。 通常的情况是： 你在某处触发了断点 然后在文件中随意浏览 直接调用这个快捷键，快速返回之前逐步调试的地方。 快捷键：（Debug时) Alt + F10； 终止进程（Stop Process） 描述：该操作会终止当前正在运行的任务。如果任务数量大于一，则显示一个列表供你选择。在终止调试或者中止编译的时候特别有用！ 快捷键： OS X: Cmd + F2 Windows、Linux: Ctrl + F2 临时断点（Temporary Breakpoints） 描述：通过该操作可以添加一个断点，这个断点会在第一次被命中的时候自动移除。 快捷键： 鼠标: Alt + 鼠标左键 点击代码左侧 OS X: Cmd + Alt + Shift + F8 Windows/Linux: Ctrl + Alt + Shift + F8 调用层级树弹窗（The Call Hierarchy Popup） 描述：该操作会给你展示 在一个方法的声明和调用之间所有可能的路径。 快捷键：Ctrl + Alt + H]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-线程管理]]></title>
      <url>%2F2017%2F05%2F30%2Fandroid-thread%2F</url>
      <content type="text"><![CDATA[Thread 继承Thread方式 实现Runnable接口 Thread主要函数： run()//包含线程运行时所执行的代码 start()//用于启动线程 sleep()/sleep(long millis)//线程休眠，交出CPU，让CPU去执行其他的任务，然后线程进入阻塞状态，sleep方法不会释放锁 yield()//使当前线程交出CPU，让CPU去执行其他的任务，但不会是线程进入阻塞状态，而是重置为就绪状态，yield方法不会释放锁 join()/join(long millis)/join(long millis,int nanoseconds)//等待线程终止，直白的说 就是发起该子线程的线程 只有等待该子线程运行结束才能继续往下运行 wait()//交出cpu，让CPU去执行其他的任务，让线程进入阻塞状态，同时也会释放锁 interrupt()//中断线程，自stop函数过时之后，我们通过interrupt方法和isInterrupted()方法来停止正在运行的线程，注意只能中断已经处于阻塞的线程 getId()//获取当前线程的ID getName()/setName()//获取和设置线程的名字 getPriority()/setPriority()//获取和这是线程的优先级 一般property用1-10的整数表示，默认优先级是5，优先级最高是10，优先级高的线程被执行的机率高 setDaemon()/isDaemo()//设置和判断是否是守护线程 currentThread()//静态函数获取当前线程 Thread线程主要状态 New 一旦被实例化之后就处于new状态 Runnable 调用了start函数之后就处于Runnable状态 Running 线程被cpu执行 调用run函数之后 就处于Running状态 Blocked 调用join()、sleep()、wait()使线程处于Blocked状态 Dead 线程的run()方法运行完毕或被中断或被异常退出，线程将会到达Dead状态 如何停止一个线程通过interrupt方法和isInterrupted()方法来停止正在运行的线程，首先必须先让线程处于阻塞状态 Thread线程同步问题 同步函数 同步代码块 使用特殊域变量(volatile)实现线程同步 ExecutorService线程池new Thread()的缺点 每次new Thread()耗费性能 调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。 不利于扩展，比如如定时执行、定期执行、线程中断采用线程池的优点 重用存在的线程，减少对象创建、消亡的开销，性能佳 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞 提供定时执行、定期执行、单线程、并发数控制等功能 ExecutorService 12345678910111213141516171819202122232425262728293031323334public interface ExecutorService extends Executor&#123; void shutdown();//顺次地关闭ExecutorService,停止接收新的任务，等待所有已经提交的任务执行完毕之后，关闭ExecutorService List&lt;Runnable&gt; shutdownNow();//阻止等待任务启动并试图停止当前正在执行的任务，停止接收新的任务，返回处于等待的任务列表 boolean isShutdown();//判断线程池是否已经关闭 boolean isTerminated();//如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。 boolean awaitTermination(long timeout, TimeUnit unit)//等待（阻塞）直到关闭或最长等待时间或发生中断,timeout - 最长等待时间 ,unit - timeout 参数的时间单位 如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);//提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。 Future&lt;?&gt; submit(Runnable task);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。 throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。 throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。 throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; &#125; Executor接口 1234public interface Executor &#123; void execute(Runnable command);//执行已提交的 Runnable 任务对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法&#125; Executors工厂类 newFixedThreadPool()创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。(运行结果：总共只会创建5个线程， 开始执行五个线程，当五个线程都处于活动状态，再次提交的任务都会加入队列等到其他线程运行结束，当线程处于空闲状态时会被下一个任务复用) newCachedThreadPool()创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程(运行结果：可以看出缓存线程池大小是不定值，可以需要创建不同数量的线程，在使用缓存型池时，先查看池中有没有以前创建的线程，如果有，就复用.如果没有，就新建新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务) newScheduledThreadPool()创建一个定长线程池，支持定时及周期性任务执行schedule(Runnable command,long delay, TimeUnit unit)创建并执行在给定延迟后启用的一次性操作(运行结果和newFixedThreadPool类似，不同的是newScheduledThreadPool是延时一定时间之后才执行scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnitunit) 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay后开始执行，然后在initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推)scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟 newSingleThreadExecutor()创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行(运行结果：只会创建一个线程，当上一个执行完之后才会执行第二个)通过ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();实现延时的单线程线程池。 ThreadPoolExecutorThreadPoolExecutor线程池用于管理线程任务队列、若干个线程。 1.ThreadPoolExecutor构造函数1234ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue);ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit,BlockingQueue workQueue,RejectedExecutionHandler handler);ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler) ;ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory, RejectedExecutionHandler handler); corePoolSize： 线程池维护线程的最少数量 maximumPoolSize：线程池维护线程的最大数量 keepAliveTime： 线程池维护线程所允许的空闲时间 unit： 线程池维护线程所允许的空闲时间的单位 workQueue： 线程池所使用的缓冲队列 threadFactory：线程池用于创建线程 handler： 线程池对拒绝任务的处理策略 AsyncTaskAndroid的AsyncTask比Handler更轻量级一些，适用于简单的异步处理。同时在处理单个后台任务时，AsyncTask的代码量更少并且更加轻量级。AsyncTask定义了三种泛型类型 Params，Progress和Result。 Params 启动任务执行的输入参数，比如HTTP请求的URL。 Progress 后台任务执行的百分比。 Result 后台执行任务最终返回的结果，比如String。使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法： doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。 onPostExecute(Result) 相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回有必要的话你还得重写以下这三个方法，但不是必须的： onProgressUpdate(Progress…) 可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。 onPreExecute() 这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。 onCancelled() 用户调用取消时，要做的操作使用AsyncTask类，以下是几条必须遵守的准则： Task的实例必须在UI thread中创建； execute方法必须在UI thread中调用； 不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法； 该task只能被执行一次，否则多次调用时将会出现异常； 参考Android线程管理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Issues]]></title>
      <url>%2F2017%2F05%2F28%2Fandroid-issues%2F</url>
      <content type="text"><![CDATA[前言这篇文章主要记录一些在实际开发中遇到的问题，以及对其的解决措施。方便日后解决同样类型的问题。 Activity的使用1、onSaveInstance 和 onRestoreInstanceStateonSaveInstance方法在系统回收Activity之前会调用；Back键不会调用。onPause（）—&gt;onSaveInstanceState( )–&gt;onStop( );onRestoreInstanceState()会在onStart()和onResume()之间执行。 1、当用户按下HOME键时。这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 2、长按HOME键，选择运行其他的程序时。 3、按下电源按键（关闭屏幕显示）时。 4、从activity A中启动一个新的activity时。 5、屏幕方向切换时，例如从竖屏切换到横屏时。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行 至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和 onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提 是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。activity中保存数据有两种方式onPause()，onSaveInstance(bundle), 恢复数据也有两种途径onCreate(Bundle), onRestoreInstanceState(budle)，默认情况下onSaveInstanceSate()和onRestoreInstanceState()会对UI状态进行保存和恢复，如果需要保存其他数据可以在onSaveInstanceState()，onPause()保存，但是如果是持久化的数据得通过onPause()保存(google推荐)。 二、Fragment使用1、java.lang.IllegalStateException: Fragment does not have a view先说明下出现这个异常的原因，这是在fragment onCreateView()中调用getChildFragmentManager()的时候出现的。解决办法就是不要再onCreateView()中调用getChildFragmentManager()。那么如果你要调用getChildFragmentManager()，那么必须onCreateView之后，view被创建了。 三、UI控件1、Button控件（1）解决Android5.0版本以上Button自带阴影问题设置Button的样式为style=&quot;?android:attr/borderlessButtonStyle&quot; 2、TextView控件（1）Text View中修改文字段落中部分字体颜色使用ForegroundColorSpan来修改 3、CheckBox控件（1）如何修改复选框的样式 首先在drawable文件夹中添加drawable文件checkbox_style.xml。 123456&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/checkbox_pressed" android:state_checked="true"/&gt; &lt;item android:drawable="@drawable/checkbox_normal" android:state_checked="false"/&gt; &lt;item android:drawable="@drawable/checkbox_normal"/&gt; &lt;/selector&gt; 在values文件夹下的styles.xml文件中添加CustomCheckboxTheme样式。 123&lt;style name="CustomCheckboxTheme" parent="@android:style/Widget.CompoundButton.CheckBox"&gt; &lt;item name="android:button"&gt;@drawable/checkbox_style&lt;/item&gt; &lt;/style&gt; 在布局文件中使用CustomCheckboxTheme样式。12345&lt;CheckBox android:id="@+id/select_all" android:layout_width="wrap_content" android:layout_height="wrap_content" style="@style/CustomCheckboxTheme" /&gt; 4、RecyclerView控件（1）RecyclerView删除Item导致位置错乱RecyclerView的刷新分为内容变化和结构变化，结构变化比如remove和insert等并不会导致viewholder的更新，所以有时候我们使用notifyItemRemoved(position);或者使用notifyItemInserted(position);item的位置并没有发生改变，或者位置发生错乱，很是奇怪诡异，需要重新调用notifyDataSetChanged();才能刷新整个List每个Item的位置，但这样做会使得RecyclerView增加和删除的动画效果没有了。那么要既想没有Bug的插入删除，又想有动画怎么搞呢，只需要刷新删除位置以下的List的Item位置即可，那么幸亏RecyclerView有一个局部刷新的方法：notifyItemRangeChanged(int positionStart, int itemCount)怎么使用呢？ 我们只需要在删除或插入时同时,刷新改变位置item下方的所有Item的位置： 插入动作： 1234notifyItemInserted(position);if (position != mData.size()) &#123; otifyItemRangeChanged(position, mData.size() - position); &#125; 删除动作： 1234 notifyItemRemoved(position);if (position != mData.size()) &#123; otifyItemRangeChanged(position, mData.size() - position); &#125; （2）RecyclerView只显示第一个数据在onCreateViewHolder中获取View的时候不指定ViewGroup 123456@Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext()); View convertView = layoutInflater.inflate(R.layout.item, null, false); // if use parent, only first line will show up return new ViewHolder(convertView); &#125; 5、EditText控件（1）如何自动打开软键盘四、自定义View的实现1、自定义TextView时，自定义参数的设置自定义属性一般在onMeasure()方法后才能将XML文件中的自定义设置的属性数值传递进来，无法在setBackground()方法和setText()方法直接调用。如果是想要在代码中设置变量属性，还是直接在自定义控件扩展类中添加新方法进行使用。自定义控件的三个构造类 123public GuideTextView(Context context) //在代码中直接使用public GuideTextView(Context context, AttributeSet attrs) //在xml文件中直接使用时调用public GuideTextView(Context context, AttributeSet attrs, int defStyleAttr) //xml文件中使用默认主题时调用 2、扩展自定义View的实现在onDraw()方法中，将绘制代码写在super.onDraw(canvas);方法之前，绘制效果将显示在控件底层；将绘制代码写在super.onDraw(canvas);方法之后，绘制效果将显示在控件底层。 3、getDimension()、getDimensionPixelOffset()和getDimensionPixelSize()的区别 getDimension()是基于当前DisplayMetrics进行转换，获取指定资源id对应的尺寸。文档里并没说这里返回的就是像素，要注意这个函数的返回值是float，像素肯定是int。 getDimensionPixelSize()与getDimension()功能类似，不同的是将结果转换为int，并且小数部分四舍五入。 getDimensionPixelOffset()与getDimension()功能类似，不同的是将结果转换为int，并且偏移转换（offset conversion，函数命名中的offset是这个意思）是直接截断小数位，即取整（其实就是把float强制转化为int，注意不是四舍五入哦）。由此可见，这三个函数返回的都是绝对尺寸，而不是相对尺寸（dp/sp等）。如果getDimension()返回结果是20.5f，那么getDimensionPixelSize()返回结果就是21，getDimensionPixelOffset()返回结果就是20。 4、DisplayMetrics显示的数值 density: 显示的逻辑分辨率 width及height: 屏幕分辨率(绝对宽高) scaleDensity: 字体显示的缩放因子 xdpi及ydpi: 水平方向DPI和竖直方向DPI 5、屏幕尺寸单位 屏幕尺寸: 屏幕尺寸指屏幕的对角线的长度，单位是英寸(in)，1英寸=2.54厘米 px: 是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素，一般以纵向像素*横向像素。 dpi: dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。 density: 屏幕密度，density和dpi的关系为 density = dpi/160 dp和dip: 设备独立像素，device independent pixels的缩写， Android 特有的单位，在屏幕密度dpi = 160屏幕上，1dp = 1px。dp和density的关系为 1dp = density px，dip值 =（dpi值/160）* pixel值 sp: 和dp很类似，一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。 6、EditText启动软键盘怎么和EditText布局一起上移，并且背景不动在根布局中添加ScrollView来存放背景显示内容，中间必须添加一个RelativeLayout或者LinearLayout(如果添加RelativeLayout则ScrollView必须设置属性android:fillViewport=&quot;true&quot;)，在ScrollView控件底下添加EditText所在布局，设置AndroidManifest.xml中android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot;，在代码中设置RelativeLayout中的显示布局的布局属性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.jrm.adolph.test1.MainActivity"&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent" android:fillViewport="true"&gt; &lt;RelativeLayout android:id="@+id/layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="64dp" android:background="@color/colorAccent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="软键盘" android:textSize="20sp"/&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:id="@+id/content_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:layout_centerInParent="true" android:textSize="20sp"/&gt; &lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt; &lt;/ScrollView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="48dp" android:layout_alignParentBottom="true"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="送礼"/&gt; &lt;EditText android:id="@+id/et" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_weight="1"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="发送"/&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 12345Rect outRect = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect);RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) layout.getLayoutParams();params.height = outRect.bottom - outRect.top;layout.setLayoutParams(params); 7、设置Button的selector控制按钮的点击形态设置好press、enable属性的对应图片，点击按钮图片形态不响应。必须把默认的按钮图片样式放在最底下，才能实现。12345&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/lucky_turntable_pressed_btn" android:state_pressed="true"/&gt; &lt;item android:drawable="@drawable/lucky_turntable_unable_btn" android:state_enabled="false"/&gt; &lt;item android:drawable="@drawable/lucky_turntable_focusable_btn"/&gt;&lt;/selector&gt; 8、DispatchTouchEvent重写dispatchTouchEvent的时候，无论你是return true，亦或是return false都会导致child接受不到事件。return true ： 告诉parent，这个事件我消费了。如果这个是down事件，那么我就会作为一个target或者说handle(事件持有者)，后续的move事件或者up事件等，都会直接分发到我这里，不继续往下分发。return false：告诉parent，这个事件我不需要，那么会交回给parent的onTouchEvnet处理。只有return super.dispatchTouchEvent的时候才会将事件继续往下传递。 五、Android类库使用问题1、Android DataBinding（1）include布局使用，如何传变量进去include布局中同样用layout标签包裹，将父布局中的变量以1app:XXX=&quot;@&#123;XXX&#125;&quot; 自定义属性的形式传进去,并在include布局中同样申明XXX相同的变量名以及变量类型，即可进行使用。注意使用在表达式中使用View.VISIBLE设置可视化的时候导入View类，否则会报错。 （2）如何调用include中的控件普通调用include中的控件，直接使用findViewById可以直接获取控件。使用dataBinding时，有时会出现获取控件无法调用的情况，这种情况给include标签赋一个id，在类中通过bind.&lt;include-id&gt;.&lt;widget-id&gt;进行调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-常用的Android库]]></title>
      <url>%2F2017%2F05%2F18%2Fandroid-common-android-library%2F</url>
      <content type="text"><![CDATA[前言Android开发中常用的以及想要尝试的库，在这里还是记录下。 Lottie这是一个能解析Adobe After Effects动画导出的JSON文件并把它们渲染成本地动画的库。在Google Play Store上有一个示例app。 Toasty一个创建自定义Toast的库。 StyleableToast这是另外一个创建自定义Toast的库。 StoreStore是一个异步加载和缓存库。文档描述： Store是一个简化数据的请求，解析，保存，以及数据重试的类。一个Store类似于 仓库模式 ，不过用RxJava封装成了响应式的API，以支持单向数据流 。 文档非常易懂，这个库值得尝试。你可以尝试各种flows，比如数据请求，缓存，解析等。 PreviewSeekBar如果你使用Google Play Movies，你可能注意到了这个动画效果很棒，可以预览电影的SeekBar。 Rúben Sousa 实现了这种效果并开源。 Chuck如果你使用 OkHttp的话，这个库可以帮助你拦截并记录所有的HTTP请求与响应。它还提供了一个来显示内容。 CoordinatorTabLayoutCoordinatorTabLayout是一个自定义的组合控件，帮助你快速实现TabLayout与CoordinatorLayout相结合的样式。 BoxingBoxing是一个基于MVP模式的Android多媒体选择器，你可以： 图片选择（单／多选）， 预览或者剪裁图片。 它还支持gif，视图选择，图片压缩以及自定义UI： excelPanelRecyclerView实现的二维表格，不仅可以加载历史数据，还能加载新数据。 Horizontal Calendar又一个用RecyclerView实现的Material横向日历视图。 CameraFragment一个集成了拍照功能的Fragment ，根据README： CameraFragment直接预览camera视图，并提供简单的API来捕获或者管理设备。你可以使用CameraFragment设置自己的布局以及控制camera。 ShimmerRecyclerView一个可以在加载数据的时候显示闪烁（Shimmer）的RecyclerView。这个RecyclerView内置一个adapter，控制shimmer的外观。 CounterFab这是一个在浮动操作按钮的右上角显示数字标识的库。可以从Google Play上下载demo app。 FadingTextView一个可以让TextView以淡如淡出的形式不断改变自己内容的库。 Bridge Bridge是一个简单但是强大的HTTP网络操作库。提供链式调用的API，为了最大的兼容性和最快的速度，用 Java/Android的URLConnection类实现。 这个库文档非常齐全，绝对值得一试。 Ason这是Aidan Follestad的第二个library。其主要目的是简化和JSON的交互。 also makes (de)serialization painless. ObjectBox大家都应该知道greenrobot，不知道的话也应该知道他们开发的 GreenDAO 和 EventBus。这次要介绍的是一个面向对象的数据库。greenrobot宣称： 性能是我们创建ObjectBox的首要因素。之前我们创建了安卓和SQLite上最快的对象关系映射 (ORM) greenDAO。自从2011年第一个版本发布以来，我们对对象持久化－以及SQLite的缺陷有了许多认识。我们意识到， 要显著提高移动端的性能，需要从内核开始，创建一个基于对象的数据库。 FlowLayout一个让子view在空间不够的情况下自动跳到下一行的布局。子view之间的间隔由FlowLayout计算出来，以便让view是均匀分布的。 Shortbread这是一个这样的库 为使用了@Shortcut注解的Activity和方法生成app shortcuts。无需动用manifest, XML以及shortcut manager。只需为想要shortcut调用的代码添加注释。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github pages和Hexo搭建]]></title>
      <url>%2F2017%2F04%2F11%2Fbuild-the-githubpages-with-hexo%2F</url>
      <content type="text"><![CDATA[前言由于之前Jekyll的博客搭建起来，插件支持太少，以及其他的目录和语法高亮支持不太好，过于麻烦。最近看了其他人用Hexo搭建的Blog，被其简洁和方便，美观的界面所深深吸引。所以，查询其相关资料，发现的确很棒，而且文档相对Jekyll来说也齐全很多。顿时萌生了转战Hexo的想法。搭建完成后，发现的确好棒，很多在Jekyll上无法实现的功能，在这里能轻松实现，而且搭配Next主题，秒杀全场啊。 一、基础博客搭建流程安装Node和Git1、安装node.js。brew install node 2、安装git。brew intall git 3、选装cnpm。淘宝cnpm官网。由于npm国内下载速度经常抽风，所以建议安装淘宝的这个镜像；使用方法就是在命令中把npm换成cnpm即可。安装方法：在cmd工具中输入如下命令npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Hexo及其相关插件1、全局安装Hexocnpm install hexo-cli -g #安装hexohexo -v #出现版本信息则表示安装成功 2、在项目中安装Hexo创建文件夹，进入文件夹目录cnpm install hexo --save #在当前项目中安装hexohexo init #初始化hexocnpm install #安装依赖包 3、安装Hexo的插件cnpm install hexo-server --save #搭建本地服务器所需插件cnpm install hexo-deployer-git --save #使用git方式进行部署博客所需插件 在本地生成博客静态页面并预览1、在本地生成静态页面hexo generate，会生成一个存放静态文件的文件夹public，其简写形式为hexo g 2、启动本地服务器hexo server,其简写形式为hexo s这条指令运行完成后可在本地启动服务器并预览博客，默认网址为http://localhost:4000/。 创建GitHub Pages并配置ssh1、创建博客仓库。注册并登陆到GitHub官网，假如你注册的用户名是Magic，那么新建一个名为Magic.github.io的仓库，注意仓库的用户名一定要是用户名+github.io的形式！ 2、本地生成ssh密钥。终端下输入ssh-keygen -t rsa -C ‘你的邮箱地址’ 3、上传本地的公钥串，使当前电脑与GitHub账户建立联系。/Users/你的计算机用户名/.ssh 目录下打开刚刚生成的id_rsa.pub，复制里面的内容。然后点击你GitHub账户右上角的头像，选择settings，找到SSH and GPG keys，点击进入之后再点击New SSH key，title随便写，把公钥串粘贴到文本框，保存即可。cat id_rsa.pub 本地博客同步到GitHub上这一步其实就是把本地生成的博客内容（静态页面）放到GitHub新建成的仓库Magic.github.io中。 1、编辑博客配置文件: _config.yml在hexo根目录下找到_config.yml文件，把其中的deploy参数（没有的话就按如下格式新建，注意冒号后面一定要有一个空格），修改为： 1234deploy: type: git repo: git@github.com:LiLei/LiLei.github.io.git branch: master 2、重新部署打开终端，进入博客根目录，依次执行如下Hexo命令：hexo clean #会清除缓存文件db.json及之前生成的静态文件夹publichexo g #会重新生成静态文件夹publichexo deploy #因为之前已经安装了插件并且在博客配置文件中也配置好了，所以这个命令会在博客根目录下生成一个.deploy_git的文件夹，并 把本地生成的静态文件部署到Magic.github.io这个仓库中的master分支上；简写形式为hexo d； hexo g 和 hexo d可以合并在一起写：hexo g -d 3、在浏览器中访问博客在浏览器中输入Magic.github.io（可能你已经发现了，这个就是之前新建仓库的名字，同时也是你博客的域名），没毛病的话，你应该可以再次看到那个熟悉又亲切的博客页面了。 二、更换主题Blog的主题还是很重要的，直接影响写博客和看博客人的心情。在浏览了官网的全部主题以及和Next的对比下，最终还是选用了Next。毕竟有官方文档支持，而且符合内心界面简洁的风格，功能自定义强大，全面。 更换主题主要是两步，先下载主题然后放到博客中的themes文件夹（专门用来存放主题）下，再修改主题的配置文件_config.yml中相关参数，启用themes文件夹下新增的主题。这里用Next主题做示例。 下载Next主题。进入 根目录/themes 文件夹中，打开终端，输入：git clone https://github.com/iissnan/hexo-theme-next themes/next把主题包克隆到themes文件夹中即可。 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开根目录下的站点配置文件_config.yml， 找到 theme 字段，并将其值更改为 next（注意冒号后面要留一个 空格）。 验证主题清除并重新生成hexo静态文件，启动本地服务器，然后通过http://localhost:4000/预览博客：hexo clean #清除静态文件hexo g #重新生成静态文件hexo s #启动服务器 Next中文官网官网有更加全面的介绍 三、自定义域名自定义域名对于我们这些不喜欢加github.io后缀的人来说还是很有必要的。而且githubpages的浏览速度过慢，导致体验很差。所以我们需要加速，如果不使用GithubPages的话，可以直接搭在自己的服务器上，这样速度够快。另一种方法就是对域名使用CDN加速了，阿里云的CDN加速太贵了，查了一下发现百度有免费的CDN加速(发现百度还是有点良心的)。百度云加速 百度云加速域名解析设置1、进入域名服务商的后台解析DNS域名解析为ns1.bddns.cn和ns2.bddns.cn 2、进入百度云加速域名的解析后台，添加如下两条解析记录： 3、在博客目录的source文件夹下（根目录/source）创建一个名为CNAME的文件，内容为你注册域名。 CNAME是不带任何后缀的。 上面操作完毕后，大概过几分钟就可以通过自定义的新域名访问博客了。如果不行，就依次执行hexo clean、hexo g 、hexo d再试下。 四、博客操作1、新建文章hexo new post 背影在Git Bash中执行上面命令会新建一篇名为‘背影’的文章，源文件会自动生成到hexoBlog/source/_post 路径下，后缀为.md，直接打开编辑就可以了。编辑完保存，然后再依次执行hexo clean、hexo g、hexo d在博客就可以看到你的文章了（有时候网络问题生成会比较慢，需要等几分钟才可以看到）。如果习惯了之前Jekyll的博客命名风格，修改站点配置文件_config.yml的内容new_post_name: :year-:month-:day-:title.md # File name of new posts，之后就可以使用时间-名字的文件命名风格了。 2、新建页面新建标签、分类、关于我等各种页面，并在博客的菜单栏中显示。这里以新建‘标签’页面来做示范。 1、创建页面。在终端中执行hexo new page &#39;tags&#39;，会在根目录/source路径下自动生成一个名为tags的文件夹，里面包含一个index.md的文件，在这个文件中添加对应的页面类型type: tags：12345---title: Tagclouddate: 2017-01-01 15:24:23type: &apos;tags&apos; #声明页面类型--- 把页面路径添加到菜单中。编辑主题配置文件（themes/_config.yml）,找到menu字段，添加tag: /tags（格式为item_name: link），如下：123menu: home: / tag: /tags #‘标签’’页面的路径 设置博客中‘标签’这个菜单项的显示图标。同样是在主题配置文件中，找到nenu_icons字段，添加tags tags（格式为item_name: icon_name），如下：1234menu_icons: enable: true #显示图标 home: home tag: tags #tag标签的icons是‘tags’ 设置博客中‘标签’这个菜单项的显示文本。上面的item_name并不会直接用于博客界面的显示，只是用来匹配图标和显示在页面上的文字，可以理解为一个桥梁。那么到底在哪里设置呢？首先，在站点配置文件中（hexoBlog下的_config.yml文件）找到language字段，设置为zh-Hans；然后， 在themes/next/languages路径下找到zh-Hans.yml文件，在menu字段下添加tag: 标签云（格式为item_name: show_name），如下：123menu: home: 首页 tag: 标签云 #博客页面就会显示‘标签云’ 五、多终端同步管理技巧如果你使用过云盘或者有Git操作的基础，下面的内容会非常好理解。 1、思路：需要发布到GitHub仓库的静态内容（也就是执行hexo g -d之后生成的public和.deploy_git文件夹）放在master上，而博客所有其他源文件（除了public和.deploy_git）存放到另外一个新建的hexo分支（这个分支的名字可以随意取），并且在GitHub上将其设为默认分支。以后所有的操作都会在hexo这个分支上进行，操作完之后依次执行git add .、git commit -m &#39;commets&#39;、git push把所有源文件推到远程仓库的hexo分支上（这里远程仓库其实扮演了一个云盘的角色）；即使换了电脑，你可以直接clone远程仓库的hexo分支到本地或者执行git pull下拉更新到本地覆盖现有源文件，就在本地还原了最新的博客内容了。 2、操作流程假设你最早是在家里的A电脑上搭建了博客，那么A电脑的准备工作：把源文件push到GitHub。 1、初始化仓库博客根目录下依次执行：git initgit remote add origin &lt;server&gt; 2、新建并切换到hexo分支git checkout -b hexo 3、找到.gitignore文件（没有的话就在根目录下新建一个）,在最后增加两行内容：/.deploy_git 和 /public 目的是让git不跟踪这两个文件的更新，也就是push到hexo分支的内容里不会有这两个文件。 4、把本地新建的分支push到远程分支：git add .git commit -m &#39;commets&#39;git push -u origin hexo:hexo 然后再去GitHub上把新建的hexo分支设置为默认分支。 画面一转，我们到了公司。此时公司B电脑上空空如也，那么执行如下操作： 在桌面（或任意地址）执行git clone &lt;server&gt; -b &lt;branch&gt;这里的是你远程仓库的clone地址，就是之前新创建的hexo分支，这句话的作用是把远程仓库中的分支克隆到本地当前目录。有了源文件就可以任性修改博客了。修改完之后先生成静态文件发布到博客中：hexo cleanhexo g -d再把最终保存的源文件push到GitHub，保证多终端可以同步：git add .git commit -m &#39;comment&#39;git push最后画面再切换会家中的A电脑，因为此时远程仓库中的博客源文件已经做了更新，而我们A电脑上也有之前的源文件，那么只需要下来更新覆盖到本地就可以啦，进入到博客根目录，执行：git pull 六、优化博客设置文字居中（写博客时）在你博客文章中需要居中处加上下面这段代码即可，中间的文字改成你所需要的文字。 123456789101112131415161718192021&lt;blockquote class=&quot;blockquote-center&quot;&gt;不忘初心，这里可以写多行文字&lt;/blockquote&gt; ``` &lt;blockquote class=&quot;blockquote-center&quot;&gt;不忘初心，这里可以写多行文字&lt;/blockquote&gt;## 为博客加上GitHub丝带如果是Next主题（其他主题也差不多），添加GitHub丝带：在**themes\next\layout\_layout.swig**中加入相关代码，记得修改自己的链接。相关代码你可以在GitHub官方网站 [GitHub Ribbons](https://github.com/blog/273-github-ribbons) 上进行选择。## 加入作者版权信息我们可以为博客文章加入作者版权信息。 例如本文地址：http://www......./ 转载请注明出处，谢谢！等等。 对Next主题而言，先找到**/themes/next/layout/_macro/post.swig**，再找到其中的微信订阅部分，如下所示： ![20170331149093965647853.png](http://ohtrrgyyd.bkt.clouddn.com/20170331149093965647853.png)然后直接在其上面添加如下代码段： 本文地址：{ { page.permalink } }转载请注明出处，谢谢！ 12345678910111213当然，在上面这段代码，你可以进行一些个性化编写，可以展示你自己个性化的版权信息。## 为博客加入动态背景首先找到**\themes\next\layout\_layout.swig**，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。- 默认灰色线条`&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;`- 浅蓝色线条`&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot; count=&quot;50&quot; zindex=&quot;-2&quot; opacity=&quot;1&quot; color=&quot;0,104,183&quot;&gt;&lt;/script&gt;`- 然后在**themes\source\js\src**`下新建文件particle.js`写上以下代码: !function(){function n(n,e,t){return n.getAttribute(e)||t}function e(n){return document.getElementsByTagName(n)}function t(){var t=e(“script”),o=t.length,i=t[o-1];return{l:o,z:n(i,”zIndex”,-1),o:n(i,”opacity”,.5),c:n(i,”color”,”0,0,0”),n:n(i,”count”,99)} }function o(){c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function i(){l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i){for(i.x+=i.xa,i.y+=i.ya,i.xa=i.x&gt;c||i.x&lt;0?-1:1,i.ya=i.y&gt;a||i.y]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git学习笔记]]></title>
      <url>%2F2017%2F04%2F05%2Fgit%2F</url>
      <content type="text"><![CDATA[前言Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。相对于SVN来说，可能Git更符合个人开发者的习惯。而且由于GitHub开源代码平台的出色，导致很多优秀的代码都通过Git保存在其中，所以学会使用Git也是重中之重，对于一个程序员来说基本是必备的技能。所以，全面了解Git还是很有必要的。 Git常用操作命令远程仓库相关命令检出仓库：$ git clone git://github.com/jquery/jquery.git查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url]删除远程仓库：$ git remote rm [name]修改远程仓库：$ git remote set-url --push [name] [newUrl]拉取远程仓库：$ git pull [remoteName] [localBranchName]推送远程仓库：$ git push [remoteName] [localBranchName] 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：$git push origin test:master // 提交本地test分支作为远程的master分支$git push origin test:test // 提交本地test分支作为远程的test分支 分支(branch)操作相关命令查看本地分支：$ git branch查看远程分支：$ git branch -r创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支切换分支：$ git checkout [name]创建新分支并立即切换到新分支：$ git checkout -b [name]删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并创建远程分支(本地分支push到远程)：$ git push origin [name]删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] 创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)$git symbolic-ref HEAD refs/heads/[name]$rm .git/index$git clean -fdx 版本(tag)操作相关命令查看版本：$ git tag创建版本：$ git tag [name]删除版本：$ git tag -d [name]查看远程版本：$ git tag -r创建远程版本(本地版本push到远程)：$ git push origin [name]删除远程版本：$ git push origin :refs/tags/[name]合并远程仓库的tag到本地：$ git pull origin --tags上传本地tag到远程仓库：$ git push origin --tags创建带注释的tag：$ git tag -a [name] -m &#39;yourMessage&#39; 子模块(submodule)相关操作命令添加子模块：$ git submodule add [url] [path]如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs初始化子模块：$ git submodule init ----只在首次检出仓库时运行一次就行更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下删除子模块：（分4步走哦） $ git rm --cached [path] 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 编辑“ .git/config”文件，将子模块的相关配置节点删除掉 手动删除子模块残留的目录 忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如123targetbin*.db Git 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263git branch 查看本地所有分支git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支git branch -r 查看本地所有分支git commit -am &quot;init&quot; 提交并且加注释 git remote add origin git@192.168.1.119:ndshowgit push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout --track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支devgit merge origin/dev 将分支dev与当前分支进行合并git checkout dev 切换到本地dev分支git remote show 查看远程库git add .git rm 文件名(包括路径) 从git中删除指定文件git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来git config --list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m &quot;This is the message describing the commit&quot; 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm --cached a.a 移除文件(只从暂存区中删除)git commit -m &quot;remove&quot; 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff --cached 或 $ git diff --staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来---------------------------------------------------------git remote add origin git@github.com:username/Hello-World.gitgit push origin master 将本地项目给提交到服务器中-----------------------------------------------------------git pull 本地与服务器端同步-----------------------------------------------------------------git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin serverfix:awesomebranch------------------------------------------------------------------git fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m &quot;log_message&quot; (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支du -hs-----------------------------------------------------------mkdir WebAppcd WebAppgit inittouch READMEgit add READMEgit commit -m &apos;first commit&apos;git remote add origin git@github.com:daixu/WebApp.gitgit push -u origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EventBus 3.0的使用]]></title>
      <url>%2F2017%2F04%2F02%2Fandroid-eventbus%2F</url>
      <content type="text"><![CDATA[前言一直用Handler来处理应用内的通信，但是发现局限性还是太大了。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。 使用EventBus添加依赖库compile &#39;org.greenrobot:eventbus:3.0.0&#39; 注册举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this);&#125; 订阅者类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了:1234@Subscribe(threadMode = ThreadMode.MainThread)public void helloEventBus(String message)&#123; mText.setText(message);&#125; 该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？ 发布者既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：12String json="";EventBus.getDefault().post(json); 这样就OK了，你可以试下能否正常运行了！ 原理初探你订阅了内容，所以你需要在该类注册EventBus，而你订阅的方法需要传入String,即你的接收信息为String类型，那么在post的时候，你post出去的也应该是String类型，其才会接收到消息。 如果你post的是对象首先你需要定义一个类似pojo类：12345678public class MessageEvent &#123; public final String name; public final String password; public MessageEvent(String name,String password) &#123; this.name = name; this.password=password; &#125;&#125; 然后你post的时候：EventBus.getDefault().post(new MessageEvent(&quot;hello&quot;,&quot;world&quot;)); 当然，你接收的方法也需要改为：1234@Subscribe(threadMode = ThreadMode.MainThread)public void helloEventBus(MessageEvent message)&#123; mText.setText(message.name);&#125; ThreadMode提供了四个常量： MainThread 主线程 BackgroundThread 后台线程 Async 后台线程 PostThread 发送线程（默认） BackgroundThread:当事件是在UI线程发出，那么事件处理实际上是需要新建单独线程，如果是在后台线程发出，那么事件处理就在该线程。该事件处理方法应该是快速的，避免阻塞后台线程。Async：发送事件方不需要等待事件处理完毕。这种方式适用于该事件处理方法需要较长时间，例如网络请求。 EventBus黏性事件EventBus除了普通事件也支持粘性事件，这个有点类似广播分类中的粘性广播。本身粘性广播用的就比较少，为了方便理解成订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅函数有所不同，需要注解中添加sticky = true1234@Subscribe(threadMode = ThreadMode.MAIN,sticky = true) //在ui线程执行 public void onDataSynEvent(DataSynEvent event) &#123; Log.e(TAG, "event----&gt;" + event.getCount());&#125; 发送粘性事件EventBus.getDefault().postSticky(new DataSynEvent()); 对于粘性广播我们都比较清楚属于常驻广播，对于EventBus粘性事件也类似，我们如果不再需要该粘性事件我们可以移除EventBus.getDefault().removeStickyEvent(new DataSynEvent()); 或者调用移除所有粘性事件EventBus.getDefault().removeAllStickyEvents(); 默认情况下，其为false。什么情况下使用sticky呢？当你希望你的事件不被马上处理的时候，举个栗子，比如说，在一个详情页点赞之后，产生一个VoteEvent，VoteEvent并不立即被消费，而是等用户退出详情页回到商品列表之后，接收到该事件，然后刷新Adapter等。其实这就是之前我们用startActivityForResult和onActivityResult做的事情。 订阅事件的优先级事件的优先级类似广播的优先级，优先级越高优先获得消息1234@Subscribe(threadMode = ThreadMode.MAIN,priority = 100) //在ui线程执行 优先级100 public void onDataSynEvent(DataSynEvent event) &#123; Log.e(TAG, "event----&gt;" + event.getCount());&#125; 终止事件往下传递发送有序广播可以终止广播的继续往下传递，EventBus也实现了此功能EventBus.getDefault().cancelEventDelivery(event) ;//优先级高的订阅者可以终止事件往下传递 建议推荐大家在使用EventBus的时候，创建一个事件类，把你的每一个参数（或者可能发生冲突的参数），封装成一个类：12345678public class Event &#123; public static class UserListEvent &#123; public List&lt;User&gt; users ; &#125; public static class ItemListEvent &#123; public List&lt;Item&gt; items; &#125; &#125; processor使用按照Markus Junginger的说法（EventBus创作者），在3.0中，如果你想进一步提升你的app的性能.EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析,处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.其在编译的时候为注册类构建了一个索引，而不是在运行时，这样的结果是其让EventBus 3.0的性能提升了一倍，相比2.4来说，其会是它的3到6倍。大家可以感受下： 具体使用：在build.gradle中添加如下配置12345678910111213141516buildscript &#123; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; &#125;&#125;apply plugin: &apos;com.neenbedankt.android-apt&apos;dependencies &#123; compile &apos;org.greenrobot:eventbus:3.0.0&apos; apt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;&#125;apt &#123; arguments &#123; eventBusIndex &quot;com.whoislcj.eventbus.MyEventBusIndex&quot; &#125;&#125; 使用索引此时编译一次，自动生成生成索引类。在\build\generated\source\apt\PakageName\下看到通过注解分析生成的索引类，这样我们便可以在初始化EventBus时应用我们生成的索引了。自动生成的代码。123456789101112131415161718192021222324252627282930/** This class is generated by EventBus, do not edit. */public class MyEventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); putIndex(new SimpleSubscriberInfo(com.whoislcj.testhttp.MainActivity.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo("onDataSynEvent", com.whoislcj.testhttp.eventBus.DataSynEvent.class, ThreadMode.MAIN, 100, false), new SubscriberMethodInfo("onDataSynEvent1", com.whoislcj.testhttp.eventBus.TestEvent.class, ThreadMode.MAIN, 0, true), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; 添加索引到EventBus默认的单例中EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus(); 对比添加前后注册效率对比分别EventBus.getDefault().register(this); 添加之前：前后用了9毫秒 添加之后：前后用了2毫秒]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GreenDao3.2.0的使用]]></title>
      <url>%2F2017%2F03%2F31%2Fandroid-greendao%2F</url>
      <content type="text"><![CDATA[前言我相信，在平时的开发过程中，大家一定会或多或少地接触到SQLite。然而在使用它时，我们往往需要做许多额外的工作，像编写 SQL语句与解析查询结果等。所以，适用于Android ORM框架也就孕育而生了，现在市面上主流的框架有OrmLite、SugarORM、Active Android、Realm与greenDAO。但是使用数量最多的还是Realm与greenDAO，所以为了目前的项目需要写个文档记录一下greenDAO的使用。简单的讲，greenDAO是一个将对象映射到SQLite 数据库中的轻量且快速的ORM解决方案。（greenDAO is a light &amp; fast ORM solution that maps objects to SQLite databases.）。这个图对于理解greenDAO是必不可少的。 greenDAO特点 性能最大化，可能是Android平台上最快的ORM框架 易于使用的API 最小的内存开销 依赖体积小 支持数据库加密 强大的社区支持 配置greenDAO在app的Gradle中配置：apply plugin: &#39;org.greenrobot.greendao&#39;123dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.0&apos;&#125; 在project的Gradle中配置：123456789buildscript &#123; repositories &#123; jcenter() mavenCentral() &#125; dependencies &#123; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.1&apos; &#125;&#125; 在app的Gradle配置数据库版本等信息12345greendao &#123; schemaVersion 1 //对应当前数据库版本c daoPackage &apos;com.koma.greendao.gen&apos; //由GreenDao自动生成代码所在的包名，默认的是在项目包下面新建一个gen。 targetGenDir &apos;src/main/java&apos; //设置自动生成代码的目录&#125; 使用greenDAO使用流程在项目中新建一个表字段的实体类，不需要自己写get和set方法，在生成表的时候会自动生成。不要忘了在类名上标记@Entity注解如图： 选择build ——Make Project 一切顺利的话则会在包名下生成数据库的操作类，如下图： Ps:新建一个实体类，对项目进行Make Project，成功之后会在daoPackage目录下自动生成代码 在项目中定义实体类12345678@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; @Property(nameInDb = "USERNAME") private String name; private int age;&#125; 注解： @Entity——————————标识实体类，greenDAO会映射成sqlite的一个表，表名为实体类名的大写形式 schema：告知GreenDao当前实体属于哪个schema active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法 nameInDb：在数据库中使用的别名，默认使用的是实体的类名 indexes：定义索引，可以跨越多个列 createInDb：标记创建数据库表 基础属性注解 @Id——————————标识主键，该字段的类型为long或Long类型，autoincrement设置是否自动增长 @Property——————————标识该属性在表中对应的列名称, nameInDb设置名称 @Transient——————————标识该属性将不会映射到表中，也就是没有这列 @NotNull——————————设置表中当前列的值不可为空 索引注解 @Unique——————————向数据库列添加了一个唯一的约束 @Index——————————使用@Index作为一个属性来创建一个索引；定义多列索引(@link Entity#indexes()) 关系注解 @ToMany——————————定义与多个实体对象的关系 @ToOne——————————定义与另一个实体（一个实体对象）的关系 @Convert——————————指定自定义类型(@linkPropertyConverter) @Generated——————————greenDAO运行所产生的构造函数或者方法，被此标注的代码可以变更或者下次运行时清除 @JoinEntity——————————定义表连接关系 @JoinProperty——————————定义名称和引用名称属性关系 @Keep——————————注解的代码段在GreenDao下次运行时保持不变 注解实体类：默认禁止修改此类 注解其他代码段，默认禁止修改注解的代码段 @OrderBy——————————指定排序 初始化GreenDao一般建议在Application中初始化数据库12345678910private void setupDataBase(Context context)&#123; DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(context,DATA_BASE_NAME); Database db = openHelper.getWritableDb(); DaoMaster daoMaster = new DaoMaster(db); mDaoSession = daoMaster.new Session();&#125;public static DaoSession getDaoSession()&#123; return mDaoSession;&#125; DevOpenHelper有两个重载方法： DevOpenHelper(Context context,String name) DevOpenHelper(Context context,String name,CursorFactory factory)context上下文这个不用多说，name数据库的名字，cursorFactory游标工厂，一般不用，传入null或者使用两个参数的方法即可。我们对外提供一个getDaoSession()的方法供外部使用。 对数据库的增、删、改、查操作首先获得UserDao的对象UserDao userDao = GreenDaoManager.getInstance().getNewSession().getUserDao(); 增：12345User user = new User(null, name, age, studentId);userDao.insert(user);insert(T entity) 当指定主键在表中存在时会发生异常insertOrReplace(T entity) 当指定主键在表中存在时会覆盖数据insertInTx(Iterable&lt;T&gt; entities) 批量插入数据 删：12345678User user = new User(null, name, age, studentId); userDao.delete(user) delete(T entity) 删除数据deleteByKey(K key) 指定主键删除数据deleteInTx(Iterable&lt;T&gt; entities) 批量删除数据deleteByKeyInTx(Iterable&lt;K&gt; keys) 批量按数据删除数据 deleteAll() 删除所有数据 改：12345User user = new User(id, name, age, studentId);userDao.update(user); update(T entity) 修改数据，主键需相同updateInTx(Iterable&lt;T&gt; entities) 批量更新数据 查：12345userDao.load(id) load(K key) 根据id查找数据loadByRowId(long rowId) 根据行号查找数据loadAll() 查找全部数据 查询功能GreeDAO提供了各种各种的查询API，参见http://greenrobot.org/greendao/documentation/queries/ 如果需要在控制台查看GreenDao是怎么拼装SQL语句的，在OnCreate()方法中打开下面的开关： 条件查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//查询所有数据 public void queryAll() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().list(); &#125; //eq: equal 精确查询 名字等于jackie public void queryEq() &#123; Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.eq("jackie")).unique(); &#125; //notEq: not equal 精确查询 名字不等于jackie public void queryNotEq() &#123; Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.notEq("jackie")).unique(); &#125; //like 模糊查询 名字以jackie开头 public void queryLike() &#123; Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like("jackie")).unique(); //通配符 List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like("jackie%")).list(); &#125; //between 区间查询 年龄在20到30之间 public void queryBetween() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.between(20, 30)).list(); &#125; //gt: greater than 半开区间查询，年龄大于18 public void queryGt() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.gt(18)).list(); &#125; //ge: greater equal 半封闭区间查询，年龄大于或者等于18 public void queryGe() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.ge(18)).list(); &#125; //lt: less than 半开区间查询，年龄小于18 public void queryLt() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.lt(18)).list(); &#125; //le: less equal 半封闭区间查询，年龄小于或者等于18 public void queryLe() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.le(18)).list(); &#125; //名字以jackie开头，年龄升序排序 public void queryLikeAsc() &#123; //通配符 List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like("jackie%")).orderAsc(PersonDao.Properties.Age).list(); &#125; //名字以jackie开头，年龄降序排序 public void queryLikeDesc() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like("jackie%")).orderDesc(PersonDao.Properties.Age).list(); &#125; 当上述查询满足不了业务逻辑时，可以自定义查询语句： 多线程查询首先来看错误的方法： 错误截图： 从上面可以看出，只能在创建Query对象的线程中调用查询方法！解决方法： 一对一查询 一对一、一对多关系greenDAO目前只支持一对一和一对多关系，并不支持多对多关系 一对一：123private Long studentId;@ToOne(joinProperty = "studentId")private Studentstudent; 1234567891011121314151617@Generated(hash = 313494093)public Student getStudent() &#123; Long __key = this.studentId; if (student__resolvedKey == null || !student__resolvedKey.equals(__key)) &#123; final DaoSession daoSession = this.daoSession; if (daoSession == null) &#123; throw new DaoException("Entity is detached from DAO context"); &#125; StudentDao targetDao = daoSession.getStudentDao(); Student studentNew = targetDao.load(__key); synchronized (this) &#123; student = studentNew; student__resolvedKey = __key; &#125; &#125; return student;&#125; 使用@ToOne标记，joinProperty指定一个字段，如果没有定义，会自动生成一个字段，get方法时自动生成的，使用@Generated标记，代表自动生成的，无需动代码。 一对多（有三种映射形式）12@ToMany(referencedJoinProperty = "teacherId")private List&lt;Teacher&gt; teacherList; referencedJoinProperty：指定目标实体中与源实体相对应的外键。 1234@ToMany(joinProperties = &#123; @JoinProperty(name="studentTag",referencedName = "teacherTag")&#125;)private List&lt;Teacher&gt; teacherList; JoinProperty: 对于复杂一点的关系可以定义一组@JoinProperty注解。每个@JoinProperty注解都需要有源实体中的源属性和对应实体中的引用属性。1234567@ToMany@JoinEntity( entity = Teacher.class, sourceProperty = "teacherId", targetProperty = "id")private List&lt;Teacher&gt; teacherList; @JoinEntity：在做NM多对多映射的时候使用 数据库的升级数据库升级最麻烦的就是数据保存的问题，下面是数据库升级时执行的代码。 1234567891011121314151617/** WARNING: Drops all table on Upgrade! Use only during development. */public static class DevOpenHelper extends OpenHelper &#123; public DevOpenHelper(Context context, String name) &#123; super(context, name); &#125; public DevOpenHelper(Context context, String name, CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables"); dropAllTables(db, true); onCreate(db); &#125;&#125; 第一句注释的话已经告诉我们数据库升级时会删除所有的表，重新创建。所以我们可以自定义一个类继承OpenHelper，在升级时先生成临时表，删除旧表创建新表后，再把临时表的数据导入进去。有牛人已经做出这个项目来了，我就厚颜无耻选择直接用了。 在project的gradle添加123456allprojects &#123; repositories &#123; jcenter() maven &#123; url "https://jitpack.io" &#125; &#125;&#125; 在app的gradle添加：compile &#39;com.github.yuweiguocn:GreenDaoUpgradeHelper:v1.3.0&#39; 新建一个类12345678910111213public class MySQLiteOpenHelper extends DaoMaster.OpenHelper&#123; public MySQLiteOpenHelper(Contextcontext,Stringname)&#123; super(context,name); &#125; public MySQLiteOpenHelper(Contextcontext,String name,SQLiteDatabase.CursorFactoryfactory) &#123; super(context,name,factory); &#125; @Override public void onUpgrade(SQLiteDatabasedb,int oldVersion,intnewVersion) &#123; Log.d("SQLite","数据库从"+oldVersion+"升级到"+newVersion); MigrationHelper.migrate(db,UserDao.class,StudentDao.class); &#125;&#125; 使用时直接用MySQLiteOpenHelper代替DaoMaster.OpenHelper。 实战下面就以购物车的实战来使用GreenDao，这里的购物车展示图如下我们所知道的数据库操作需要：数据库名、表名、字段名，缺一不可，下面就是这三项的创建 一、创建Bean对象（表名和字段名）GreenDao需要创建Bean对象之后，该Bean对象就是表名，而它的属性值就是字段名，其 实现是通过注释的方式来实现的，下面是购物车的Bean对象（每个Bean对象对应一张表）1234567891011121314151617181920212223242526@Entitypublic class Shop&#123; //表示为购物车列表 public static final int TYPE_CART = 0x01; //表示为收藏列表 public static final int TYPE_LOVE = 0x02; //不能用int @Id(autoincrement = true) private Long id; //商品名称 @Unique private String name; //商品价格 @Property(nameInDb = "price") private String price; //已售数量 private int sell_num; //图标url private String image_url; //商家地址 private String address; //商品列表类型 private int type;&#125; 之后进行Make Project生成Bean实体的构造方法和get、set方法和DaoMaster、DaoSession、DAOS类 二、创建数据库1234567891011121314151617181920212223242526272829public class BaseApplication extends Application &#123; private static DaoSession daoSession; @Override public void onCreate() &#123; super.onCreate(); //配置数据库 setupDatabase(); &#125; /** * 配置数据库 */ private void setupDatabase() &#123; //创建数据库shop.db" DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, "shop.db", null); //获取可写数据库 SQLiteDatabase db = helper.getWritableDatabase(); //获取数据库对象 DaoMaster daoMaster = new DaoMaster(db); //获取Dao对象管理者 daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoInstant() &#123; return daoSession; &#125;&#125; GreenDao已经将我们的数据库创建缩成几句话，代码会自动将Bean对象创建成表，不再是传统的手写SQL语句。这里的数据库创建只需要在Application中执行一次即可，这里对几个类进行解释 DevOpenHelper：创建SQLite数据库的SQLiteOpenHelper的具体实现 DaoMaster：GreenDao的顶级对象，作为数据库对象、用于创建表和删除表 DaoSession：管理所有的Dao对象，Dao对象中存在着增删改查等API 由于我们已经创建好了DaoSession和Shop的Bean对象，编译后会自动生成我们的ShopDao对象，可通过DaoSession获得ShopDao dao = daoSession.getShopDao();这里的Dao（Data Access Object）是指数据访问接口，即提供了数据库操作一些API接口，可通过dao进行增删改查操作。 三、数据库的增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LoveDao &#123; /** * 添加数据，如果有重复则覆盖 * * @param shop */ public static void insertLove(Shop shop) &#123; BaseApplication.getDaoInstant().getShopDao().insertOrReplace(shop); &#125; /** * 删除数据 * * @param id */ public static void deleteLove(long id) &#123; BaseApplication.getDaoInstant().getShopDao().deleteByKey(id); &#125; /** * 更新数据 * * @param shop */ public static void updateLove(Shop shop) &#123; BaseApplication.getDaoInstant().getShopDao().update(shop); &#125; /** * 查询条件为Type=TYPE_LOVE的数据 * * @return */ public static List&lt;Shop&gt; queryLove() &#123; return BaseApplication.getDaoInstant().getShopDao().queryBuilder().where(ShopDao.Properties.Type.eq(Shop.TYPE_LOVE)).list(); &#125; /** * 查询全部数据 */ public static List&lt;Shop&gt; queryAll() &#123; return BaseApplication.getDaoInstant().getShopDao().loadAll(); &#125;&#125; GreenDao的封装更加短小精悍，语义明朗，下面对GreenDao中Dao对象其他API的介绍 增加单个数据 getShopDao().insert(shop); getShopDao().insertOrReplace(shop); 增加多个数据 getShopDao().insertInTx(shopList); getShopDao().insertOrReplaceInTx(shopList); 查询全部 List&lt; Shop&gt; list = getShopDao().loadAll(); List&lt; Shop&gt; list = getShopDao().queryBuilder().list(); 查询附加单个条件 .where() .whereOr() 查询附加多个条件 .where(, , ,) .whereOr(, , ,) 查询附加排序 .orderDesc() .orderAsc() 查询限制当页个数 .limit() 查询总个数 .count() 修改单个数据 getShopDao().update(shop); 修改多个数据 getShopDao().updateInTx(shopList); 删除单个数据 getTABUserDao().delete(user); 删除多个数据 getUserDao().deleteInTx(userList); 删除数据ByKey getTABUserDao().deleteByKey();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习笔记]]></title>
      <url>%2F2017%2F03%2F27%2Fpython-study-note%2F</url>
      <content type="text"><![CDATA[前言由于写毕设要搭建后端爬虫的需求，所以开始学习Python语言。由于没有系统的学习，所以笔记可能会记得比较散乱，有时间会一一整理，把一些重要的学习知识点记下来。当然有时间也会整理基础知识。 安装 Python升级pippip3 install --upgrade pip 安装 Python 虚拟环境(sudo) pip3 install virtualenv virtualenvwrapper 修改~/.bash_profile,添加以下语句123export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/workspacesource /usr/local/bin/virtualenvwrapper.sh 修改后使之立即生效(也可以重启终端使之生效)：source ~/.bash_profile 基本用法1、创建一个虚拟开发环境mkvirtualenv zqxt：创建运行环境zqxtworkon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境deactivate: 退出终端环境其它的：rmvirtualenv ENV：删除运行环境ENVmkproject mic：创建mic项目和运行环境micmktmpenv：创建临时运行环境lsvirtualenv: 列出可用的运行环境lssitepackages: 列出当前环境安装了的包创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。 完成后在当前目录会创建一个test_env的文件夹，进入文件夹会发现生成了以下的目录，神奇吧12345678910111213├── bin├── include│ └── python2.7├── lib│ └── python2.7 //所有的新包会被存在这│ ├── distutils│ ├── encodings│ ├── lib-dynload│ └── site-packages├── local│ ├── bin│ ├── include│ └── lib 安装Djangopip3 install Django或者pip install Django==1.10.6在终端上输入Python,点击Enter,进入Python环境123456&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION(1, 8, 16, &apos;final&apos;, 0)&gt;&gt;&gt; &gt;&gt;&gt; django.get_version()&apos;1.8.16&apos; 这样就可以看见安装的django的版本号 安装django-Celery，设置调度计划任务pip3 install django-celery 安装PIL（Python Imaging Library）图片处理的扩展包:brew install jpeg #安装 安装Django-Dynamic-Scraper(DDS)pip3 install django-dynamic-scraperpip3 install scrapy-splashpip3 install scrapy-djangoitem 安装scrapypip3 install Scrapy 安装Scrapy或者pip3 install scrapy==1.3.3 安装chardet-检测网页编码pip3 install chardet #安装chardet1234567def GetHtml( url): page = urllib.request.urlopen(url) contex = page.read() return contex print(sys.getfilesystemencoding()) #本地系统编码print('Html is encoding by : %',chardet.detect(GetHtml(url))) #网页编码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac命令行整理]]></title>
      <url>%2F2017%2F03%2F25%2Fmac-command%2F</url>
      <content type="text"><![CDATA[前言命令行是操作Mac和Linux最基础和重要的内容，简单的命令行自然会随时记得。但是碰到配置环境以及安装软件这种活，还是得时不时的上网查询，而且在不同的电脑配置还得重新上网查询，所以在此记录一下，以节省以后使用命令行的时间。 查看端口占用情况及杀死进程sudo lsof -i :9000 #查看端口进程sudo kill -9 716 #根据PID杀死进程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apache简单搭建文件共享服务器]]></title>
      <url>%2F2017%2F03%2F17%2Fapache-build-file-server%2F</url>
      <content type="text"><![CDATA[前言因为公司需求，增加打包测试发布的效率以及方便查看log信息。所以需要搭建一个简单的文件服务器。Mac内置Apache，所以我们可以很方便的搭建起来。 启动Apache启动：sudo apachectl start停止：sudo apachectl stop重启：sudo apachectl restart查看 Apache 版本 httpd -v浏览器打开 http://127.0.0.1 可以看到 It works! 的页面 文件根目录系统级的根目录http://localhosts/ 对应的是 /Library/WebServer/Documents/ 系统级根目录默认没有开启目录列表，开启方法：编辑 /etc/apache2/httpd.conf文件搜索找到 &lt;Directory &quot;/Library/WebServer/Documents&quot;&gt;将 Options FollowSymLinks Multiviews 修改为Options Indexes FollowSymLinks Multiviews 用户级根目录另一个 Web 根目录默认是 ~/Sites ，10.9 中你需要手动创建这个Sites目录。检查/etc/apache2/users/这个目录下是否有 username.conf 文件如果没有，则需要新建一个，username 需要是你的账户名字，建议使用终端创建这个文件：cd /etc/apache2/userssudo vi username.conf贴入以下内容，注意修改 username 为你的账户名字1234567&lt;Directory &quot;/Users/username/Sites/&quot;&gt;Options Indexes MultiViews FollowSymLinksAllowOverride AllOrder allow,denyAllow from allRequire all granted&lt;/Directory&gt; 这个文件的权限应该是: -rw-r--r-- 1 root wheel 298 Jun 28 16:47 username.conf 如果不是，请修改: sudo chmod 644 username.conf 编辑 /etc/apache2/httpd.conf 文件，删除下列这些代码前的注释符号： #1234Include /private/etc/apache2/extra/httpd-userdir.confLoadModule authz_core_module libexec/apache2/mod_authz_core.soLoadModule authz_host_module libexec/apache2/mod_authz_host.soLoadModule userdir_module libexec/apache2/mod_userdir.so 编辑 /etc/apache2/extra/httpd-userdir.conf文件，删除下列这些代码前的注释符号： #Include /private/etc/apache2/users/*.conf 重启 Apachesudo apachectl restart这时，这个网址应该已经可以用了：http://localhost/~username/ 想去除/~username/~username看着的确比较累赘，所以我们重定向把他给去掉进入/Library/WebServer/Documents文件夹中，找到index.html.en文件，在里面添加一行&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;0; URL=/~rainbird&quot;&gt;。最后变成这个样子。12&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;0; URL=/~rainbird&quot;&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python-Crawler]]></title>
      <url>%2F2017%2F03%2F15%2Fpython-crawler%2F</url>
      <content type="text"><![CDATA[总文件1234567891011121314151617181920212223242526import scrapyfrom scrapy.selector import Selectorfrom scrapy.http import HtmlResponseclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://www.xujc.com.cn/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self,response): sel = Selector(response) sties = sel.xpath('//table') # for site in sties: # title = site.xpath('tr/td').extract() # print(site) # print(title) #filename = 'school-%s.html' % 1 #with open(filename, 'wb') as f: #f.write(contents) #self.log('Saved file %s' % filename) 重点关注链接and标题123456789101112131415161718192021import scrapyfrom scrapy.selector import Selectorfrom scrapy.http import HtmlResponseclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://www.xujc.com.cn/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self,response): sel = Selector(response) sties = sel.xpath('//table') title = sties[16].xpath('tr/td/a/text() | tr/td/a/@href | tr/td/text()').extract() print(sties[10]) print(title) 日期时间123title = sties[25].xpath('tr/td/table/tr/td[@id="zb"]/table/tr/td/span/text()').extract() print(sties[10]) print(title) 通知公告123456789101112131415161718192021import scrapyfrom scrapy.selector import Selectorfrom scrapy.http import HtmlResponseclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://www.xujc.com.cn/index.php?c=Article&amp;a=idxnews&amp;lx=notice', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self,response): sel = Selector(response) sties = sel.xpath('/html/body/table/tr') for site in sties: title = site.xpath('td/a/@href | td/a/text()').extract() print(site) print(title) 新闻中心123456789101112131415161718192021import scrapyfrom scrapy.selector import Selectorfrom scrapy.http import HtmlResponseclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://www.xujc.com.cn/index.php?c=Article&amp;a=idxnews&amp;lx=news', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self,response): sel = Selector(response) sties = sel.xpath('/html/body/ul/li') for site in sties: title = site.xpath('a/@href | a/text()').extract() print(site) print(title)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android ADB 命令]]></title>
      <url>%2F2017%2F03%2F05%2Fandroid-adb%2F</url>
      <content type="text"><![CDATA[查看设备adb devices 这个命令是查看当前连接的设备, 连接到计算机的android设备或者模拟器将会列出显示 安装软件adb install &lt;apk文件路径&gt; 这个命令将指定的apk文件安装到设备上 卸载软件adb uninstall &lt;软件名&gt; adb uninstall -k &lt;软件名&gt; 如果加 -k 参数,为卸载软件但是保留配置和缓存文件. 进入设备或模拟器的shelladb shell 通过上面的命令，就可以进入设备或模拟器的shell环境中，在这个Linux Shell中，你可以执行各种Linux的命令，另外如果只想执行一条shell命令，可以采用以下的方式： adb shell [command] 如：adb shell dmesg会打印出内核的调试信息。 发布端口adb forward tcp:5555 tcp:8000 可以设置任意的端口号，做为主机向模拟器或设备的请求端口。如： 从电脑上发送文件到设备adb push &lt;本地路径&gt; &lt;远程路径&gt; 用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机) 从设备上下载文件到电脑adb pull &lt;远程路径&gt; &lt;本地路径&gt; 用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑 查看bug报告adb bugreport 记录无线通讯日志adb shell logcat -b radio 一般来说，无线通讯的日志非常多，在运行时没必要去记录，但我们还是可以通过命令，设置记录 获取设备的ID和序列号adb get-product adb get-serialno adb shell sqlite3 adb shell后面跟的命令主要来自源码\system\core\toolbox目录和源码\frameworks\base\cmds目录 删除系统应用adb remount （重新挂载系统分区，使系统分区重新可写）。 adb shell cd system/app rm *.apk 获取管理员权限adb root 启动Activityadb shell am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）。 复制文件你可向一个设备或从一个设备中复制文件,复制一个文件或目录到设备或模拟器上： adb push &lt;source&gt; &lt;destination&gt;&lt;/destination&gt;&lt;/source&gt; 如：adb push test.txt /tmp/test.txt 从设备或模拟器上复制一个文件或目录： adb pull &lt;source&gt; &lt;destination&gt;&lt;/destination&gt;&lt;/source&gt; 如：adb pull /addroid/lib/libwebcore.so . 搜索模拟器/设备的实例取得当前运行的模拟器/设备的实例的列表及每个实例的状态： adb devices]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac安装配置appium]]></title>
      <url>%2F2017%2F03%2F01%2Fappium-setup-and-usage%2F</url>
      <content type="text"><![CDATA[#前言因为公司需求，需要安装Appium来实现对手机APP的自动化测试，提升工作效率。所以来学习并记录一下Appium的安装以及使用的步骤，方便自己以后对App测试环境搭建的操作。 安装Appium安装Homebrew $ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; #下载 $ brew update #更新 $ brew -v #查看是否安装好，以及其版本号 安装Node.js使用homebrew来安装Node.js $ brew install node #安装 $ node -v #查看是否安装好，以及其版本号 安装npm $ brew install npm 安装appium服务端推荐使用cnpm来安装：淘宝 NPM 镜像 10分钟同步npmjs.org镜像，使用方式和npm完全一致 $ npm install cnpm -g --registry=https://registry.npm.taobao.org $ npm view appium versions #查看appium所有的版本号 $ cnpm install -g appium --no-cache $ cnpm install -g appium $ cnpm install -g appium-doctor 检查appium环境检测在环境监测中打叉的就是没安装成功或者环境没有配置完全的 appium-doctor appium环境常见问题解决 Xcode Command Line Tools are NOT installed! xcode-select --install #按照提示安装即可 Carthage was NOT found $ brew install carthage #carthage：类似cocoapods管理第三方代码，自动将工程编译为动态库，所以仅支持iOS8以上 ANDROID_HOME is NOT set! 使用最新版本Java 修改Mac的开发环境 vi .bash_profile export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk(版本记得改)/Contents/Home export ANDROID_HOME=/Users/YourMacName/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:${JAVA_HOME}/bin 修改完配置文件记得保存退出，然后source .bash_profile 如果有问题记得修改在终端的Shall打开方式，调整为命令 安装appium客户端（Python为例） brew search python #查看可安装的python版本 brew install python3 #安装python3 pip install Appium-Python-Client #安装python客户端 安装支持iOS测试的插件 $ brew install libimobiledevice --HEAD # install from HEAD to get important updates $ brew install ideviceinstaller # 只是对iOS9有用 $ npm install -g ios-deploy # iOS10 以后的版本安装ios-deploy $ sudo gem install xcpretty # 真机需要安装 xcpretty Appium测试iOS模拟器测试 xcodebuild -sdk iphonesimulator #在xcodeproj项目工程目录下执行，编译生成build文件夹，并在其中生成app文件 npm install -g authorize-ios #安装iOS模拟器启动器 sudo authorize-ios #启动iOS模拟器 appium &amp; #启动appium服务器 python ***.py #另开一个终端执行python脚本 iOS模拟器自动开启，安装应用并开始执行测试脚本 Android模拟器测试 appium -a 127.0.0.1 -p 4723 -U db3489d --no-reset Appium命令服务端启动命令服务器标志所有的标志都是可选的，但是有一些标志需要组合在一起才能生效。 标志 默认值 描述 例子 –shell null 进入 REPL 模式 –localizable-strings-dir en.lproj IOS only: 定位 .strings所在目录的相对路径 –localizable-strings-dir en.lproj –app null iOS: 基于模拟器编译的 app 的绝对路径或者设备目标的 bundle_id； Android: apk 文件的绝对路径–app /abs/path/to/my.app –ipa null (IOS-only) .ipa 文件的绝对路径 –ipa /abs/path/to/my.ipa -U, –udid null 连接物理设备的唯一设备标识符 –udid 1adsf-sdfas-asdf-123sdf -a, –address 0.0.0.0 监听的 ip 地址 –address 0.0.0.0 -p, –port 4723 监听的端口 –port 4723 -ca, –callback-address null 回调IP地址 (默认: 相同的IP地址) –callback-address 127.0.0.1 -cp, –callback-port null 回调端口号 (默认: 相同的端口号) –callback-port 4723 -bp, –bootstrap-port 4724 (Android-only) 连接设备的端口号 –bootstrap-port 4724 -k, –keep-artifacts false 弃用，无效。trace信息现在保留tmp目录下，每次运行前会清除该目录中的信息。 也可以参考 –trace-dir 。 -r, –backend-retries 3 (iOS-only) 遇到 crash 或者 超时，Instrument 重新启动的次数。 –backend-retries 3 –session-override false 允许 session 被覆盖 (冲突的话) –full-reset false (iOS) 删除整个模拟器目录。 (Android) 通过卸载应用（而不是清除数据）重置应用状态。在 Android 上，session 完成后也会删除应用。 –no-reset false session 之间不重置应用状态 (iOS: 不删除应用的 plist 文件； Android: 在创建一个新的 session 前不删除应用。) -l, –pre-launch false 在第一个 session 前，预启动应用 (iOS 需要 –app 参数，Android 需要 –app-pkg 和 –app-activity) -lt, –launch-timeout 90000 (iOS-only) 等待 Instruments 启动的时间 -g, –log null 将日志输出到指定文件 –log /path/to/appium.log –log-level debug 日志级别; 默认 (console[:file]): debug[:debug] –log-level debug –log-timestamp false 在终端输出里显示时间戳 –local-timezone false 使用本地时间戳 –log-no-colors false 不在终端输出中显示颜色 -G, –webhook null 同时发送日志到 HTTP 监听器 –webhook localhost:9876 –native-instruments-lib false (IOS-only) iOS 内建了一个怪异的不可能避免的延迟。我们在 Appium 里修复了它。如果你想用原来的，你可以使用这个参数。 –app-pkg null (Android-only) 你要运行的apk的java包。 (例如， com.example.android.myApp) –app-pkg com.example.android.myApp –app-activity null (Android-only) 打开应用时，启动的 Activity 的名字(比如， MainActivity) –app-activity MainActivity –app-wait-package false (Android-only) 你想等待的 Activity 的包名。(比如， com.example.android.myApp) –app-wait-package com.example.android.myApp –app-wait-activity false (Android-only) 你想等待的 Activity 名字(比如， SplashActivity) –app-wait-activity SplashActivity –android-coverage false (Android-only) 完全符合条件的 instrumentation 类。 作为命令 adb shell am instrument -e coverage true -w 的 -w 的参数 –android-coverage com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation –avd null (Android-only) 要启动的 avd 的名字 –avd-args null (Android-only) 添加额外的参数给要启动avd –avd-args -no-snapshot-load –device-ready-timeout 5 (Android-only) 等待设备准备好的时间，以秒为单位 –device-ready-timeout 5 –safari false (IOS-Only) 使用 Safari 应用 –device-name null 待使用的移动设备名字 –device-name iPhone Retina (4-inch), Android Emulator –platform-name null 移动平台的名称: iOS, Android, or FirefoxOS –platform-name iOS –platform-version null 移动平台的版本 –platform-version 7.1 –automation-name null 自动化工具的名称: Appium or Selendroid –automation-name Appium –browser-name null 移动浏览器的名称: Safari or Chrome –browser-name Safari –default-device, -dd false (IOS-Simulator-only) 使用instruments自己启动的默认模拟器 –force-iphone false (IOS-only) 无论应用要用什么模拟器，强制使用 iPhone 模拟器 –force-ipad false (IOS-only) 无论应用要用什么模拟器，强制使用 iPad 模拟器 –language null iOS / Android 模拟器的语言 –language en –locale null Locale for the iOS simulator / Android Emulator –locale en_US –calendar-format null (IOS-only) iOS 模拟器的日历格式 –calendar-format gregorian –orientation null (IOS-only) 初始化请求时，使用 LANDSCAPE (横屏) 或者 PORTRAIT (竖屏) –orientation LANDSCAPE –tracetemplate null (IOS-only) 指定 Instruments 使用的 tracetemplate 文件 –tracetemplate /Users/me/Automation.tracetemplate –show-sim-log false (IOS-only) 如果设置了， iOS 模拟器的日志会写到终端上来 –show-ios-log false (IOS-only) 如果设置了， iOS 系统的日志会写到终端上来 –nodeconfig null 指定 JSON 格式的配置文件 ，用来在 selenium grid 里注册 appiumd –nodeconfig /abs/path/to/nodeconfig.json -ra, –robot-address 0.0.0.0 robot 的 ip 地址 –robot-address 0.0.0.0 -rp, –robot-port -1 robot 的端口地址 –robot-port 4242 –selendroid-port 8080 用来和 Selendroid 交互的本地端口 –selendroid-port 8080 –chromedriver-port 9515 ChromeDriver运行的端口 –chromedriver-port 9515 –chromedriver-executable null ChromeDriver 可执行文件的完整路径 –use-keystore false (Android-only) 设置签名 apk 的 keystore –keystore-path (Android-only) keystore 的路径 –keystore-password android (Android-only) keystore 的密码 –key-alias androiddebugkey (Android-only) Key 的别名 –key-password android (Android-only) Key 的密码 –show-config false 打印 Appium 服务器的配置信息，然后退出 –no-perms-check false 跳过Appium对是否可以读/写必要文件的检查 –command-timeout 60 默认所有会话的接收命令超时时间 (在超时时间内没有接收到新命令，自动关闭会话)。 会被新的超时时间覆盖 –keep-keychains false (iOS) 当 Appium 启动或者关闭的时候，是否保留 keychains (Library/Keychains) –strict-caps false 如果所选设备是appium不承认的有效设备，会导致会话失败 –isolate-sim-device false Xcode 6存在一个bug，那就是一些平台上如果其他模拟器设备先被删除时某个特定的模拟器只能在没有任何错误的情况下被建立。这个选项导致了Appium不得不删除除了正在使用设备以外其他所有的设备。请注意这是永久性删除，你可以使用simctl或xcode管理被Appium使用的设备类别。 –tmp null 可以被Appium用来管理临时文件的目录（绝对路径），比如存放需要移动的内置iOS应用程序。 默认的变量为 APPIUM_TMP_DIR ，在 *nix/Mac 为 /tmp 在windows上使用环境便令 TEMP 设定的目录。 –trace-dir null 用于保存iOS instruments trace的 appium 目录，是绝对路径， 默认为 /appium-instruments –intent-action android.intent.action.MAIN (Android-only) 用于启动 activity 的intent action –intent-action android.intent.action.MAIN –intent-category android.intent.category.LAUNCHER (Android-only) 用于启动 activity 的intent category –intent-category android.intent.category.APP_CONTACTS –intent-flags 0x10200000 (Android-only) 启动 activity 的标志 –intent-flags 0x10200000 –intent-args null (Android-only) 启动 activity 时附带额外的 intent 参数 –intent-args 0x10200000 –suppress-adb-kill-server false (Android-only) 如果被设定，阻止Appium杀掉adb实例。 Android测试用例编写例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445import osimport unittestfrom appium import webdriverfrom time import sleepPATH = lambda p: os.path.abspath( os.path.join(os.path.dirname(__file__),p))class XingQiuAndroidTests(unittest.TestCase): def setUp(self): desired_caps = &#123;&#125; desired_caps['deviceName'] = 'emulator-5554' #adb devices查到的设备名 desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '4.4' desired_caps['app'] = PATH( '../../../Users/jiangruoming/Desktop/***.apk' ) desired_caps['appPackage'] = 'com.***.***' #被测App的包名 desired_caps['appActivity'] = '.****' #启动时的Activity self.driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) #earDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出 def tearDown(self): self.driver.quit() #放置的就是我们的测试脚本了，这部分我们并不陌生；因为我们执行的脚本就在这里。 def test_add_contacts(self): el = self.driver.find_element_by_id("com.***.***:id/sign_phone") el.click() phone_number = self.driver.find_element_by_id("com.***.***:id/et_user_phone") code = self.driver.find_element_by_id("com.***.***:id/et_smscode") phone_number.send_keys("*********") code.send_keys("****") btn = self.driver.find_element_by_id("com.***.***:id/btn_finish") btn.click()if __name__ == '__main__': suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuAndroidTests) unittest.TextTestRunner(verbosity=2).run(suite) 测试流程1、启动Appiumappium -a 127.0.0.1 -p 4723 --log /path/to/appium.log 2、启动Android模拟器由于测试apk不支持X86平台，所以Genymotion无法支持运行，原生arm模拟器运行过慢(胃都等疼了)。试过多个模拟器后，最终选定了夜神模拟器，效果还是不错的。但是由于其主要用于PC平台运行Android游戏，所以用于开发平台还是需要进行配置。 1、adb配置在Mac环境中加入adb的环境变量vi .bash_profileexport PATH=/Users/Path/To/Android/sdk/platform-tools/:$PATHsource .bash_profile 2、adb连接之后进入夜神的包内容中在adb所在文件夹运行adb连接命令adb connect 127.0.0.1:62001这样adb devices就能显示夜神模拟器的Device ID 3、运行脚本iOS测试用例编写例子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import unittestimport osfrom appium import webdriverfrom time import sleepPATH = lambda p: os.path.abspath( os.path.join(os.path.dirname(__file__),p))class XingQiuiOSTests(unittest.TestCase): def setUp(self): desired_caps = &#123;&#125; desired_caps['platformName'] = 'iOS' desired_caps['platformVersion'] = '10.2' desired_caps['deviceName'] = 'iPhone Simulator' desired_caps['app'] = PATH('../../../Users/jiangruoming/Desktop/***.app') self.driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) #def tearDown(self): #self.driver.quit() def test_add_contacts(self): el2 = self.driver.find_elements_by_accessibility_id('Allow') if el2: el2[0].click() el3 = self.driver.find_elements_by_class_name('XCUIElementTypeButton')[0] el3.click() el4 = self.driver.find_elements_by_class_name('XCUIElementTypeTextField')[0] el4.send_keys("15088678313") el5 = self.driver.find_elements_by_class_name('XCUIElementTypeTextField')[1] el5.send_keys("1234") el6 = self.driver.find_elements_by_class_name('XCUIElementTypeButton')[0] el6.click()if __name__ == '__main__': suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuiOSTests) unittest.TextTestRunner(verbosity=2).run(suite) XCUIElementType12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879XCUIElementTypeAny, XCUIElementTypeUnknown, XCUIElementTypeApplication, XCUIElementTypeGroup, XCUIElementTypeWindow, XCUIElementTypeSheet, XCUIElementTypeDrawer, XCUIElementTypeAlert, XCUIElementTypeDialog, XCUIElementTypeButton, XCUIElementTypeRadioButton, XCUIElementTypeRadioGroup, XCUIElementTypeCheckBox, XCUIElementTypeDisclosureTriangle, XCUIElementTypePopUpButton, XCUIElementTypeComboBox, XCUIElementTypeMenuButton, XCUIElementTypeToolbarButton, XCUIElementTypePopover, XCUIElementTypeKeyboard, XCUIElementTypeKey, XCUIElementTypeNavigationBar, XCUIElementTypeTabBar, XCUIElementTypeTabGroup, XCUIElementTypeToolbar, XCUIElementTypeStatusBar, XCUIElementTypeTable, XCUIElementTypeTableRow, XCUIElementTypeTableColumn, XCUIElementTypeOutline, XCUIElementTypeOutlineRow, XCUIElementTypeBrowser, XCUIElementTypeCollectionView, XCUIElementTypeSlider, XCUIElementTypePageIndicator, XCUIElementTypeProgressIndicator, XCUIElementTypeActivityIndicator, XCUIElementTypeSegmentedControl, XCUIElementTypePicker, XCUIElementTypePickerWheel, XCUIElementTypeSwitch, XCUIElementTypeToggle, XCUIElementTypeLink, XCUIElementTypeImage, XCUIElementTypeIcon, XCUIElementTypeSearchField, XCUIElementTypeScrollView, XCUIElementTypeScrollBar, XCUIElementTypeStaticText, XCUIElementTypeTextField, XCUIElementTypeDateField, XCUIElementTypeTimeField, XCUIElementTypeTextView, XCUIElementTypeMenu, XCUIElementTypeMenuItem, XCUIElementTypeMenuBar, XCUIElementTypeMenuBarItem, XCUIElementTypeMap, XCUIElementTypeWebView, XCUIElementTypeIncrementArrow, XCUIElementTypeDecrementArrow, XCUIElementTypeTimeline, XCUIElementTypeRatingIndicator, XCUIElementTypeValueIndicator, XCUIElementTypeSplitGroup, XCUIElementTypeSplitter, XCUIElementTypeRelevanceIndicator, XCUIElementTypeColorWell, XCUIElementTypeHelpTag, XCUIElementTypeMatte, XCUIElementTypeDockItem, XCUIElementTypeRuler, XCUIElementTypeRulerMarker, XCUIElementTypeGrid, XCUIElementTypeLevelIndicator, XCUIElementTypeCell, XCUIElementTypeLayoutArea, XCUIElementTypeLayoutItem, XCUIElementTypeHandle, Appium Python API contextscontexts(self):Returns the contexts within the current session.返回当前会话中的上下文，使用后可以识别H5页面的控件Usage: driver.contexts用法: driver.contexts current_contextcurrent_context(self):Returns the current context of the current session.返回当前会话的当前上下文Usage: driver.current_context用法: driver. current_context contextcontext(self):Returns the current context of the current session.返回当前会话的当前上下文。Usage: driver.context用法: driver. Context find_element_by_ios_uiautomationfind_element_by_ios_uiautomation(self, uia_string):Finds an element by uiautomation in iOS.通过iOS uiautomation查找元素Args: uia_string - The element name in the iOS UIAutomation libraryUsage: driver.find_element_by_ios_uiautomation(&#39;.elements()[1].cells()[2]&#39;)用法: dr. find_element_by_ios_uiautomation(‘elements’) find_element_by_accessibility_idfind_element_by_accessibility_id(self, id):Finds an element by accessibility id.通过accessibility id查找元素Args: id - a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilizeUsage:driver.find_element_by_accessibility_id()用法:driver.find_element_by_accessibility_id(‘id’) scrollscroll(self, origin_el, destination_el):Scrolls from one element to another从元素origin_el滚动至元素destination_elArgs: originalEl - the element from which to being scrolling destinationEl - the element to scroll toUsage: driver.scroll(el1, el2)用法: driver.scroll(el1,el2) drag_and_dropdrag_and_drop(self, origin_el, destination_el):Drag the origin element to the destination element将元素origin_el拖到目标元素destination_elArgs: originEl - the element to drag destinationEl - the element to drag to用法: driver.drag_and_drop(el1,el2) taptap(self, positions, duration=None):Taps on an particular place with up to five fingers, holding for a certain time模拟手指点击（最多五个手指），可设置按住时间长度（毫秒）Args: positions - an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five. duration - (optional) length of time to tap, in msUsage: driver.tap([(100, 20), (100, 60), (100, 100)], 500)用法: driver.tap([(x,y),(x1,y1)],500) swipeswipe(self, start_x, start_y, end_x, end_y, duration=None):Swipe from one point to another point, for an optional duration.从A点滑动至B点，滑动时间为毫秒Args: start_x - x-coordinate at which to start start_y - y-coordinate at which to start end_x - x-coordinate at which to stop end_y - y-coordinate at which to stop duration - (optional) time to take the swipe, in ms. Usage: driver.swipe(100, 100, 100, 400)用法: driver.swipe(x1,y1,x2,y2,500) flickflick(self, start_x, start_y, end_x, end_y):Flick from one point to another point.按住A点后快速滑动至B点Args: start_x - x-coordinate at which to start start_y - y-coordinate at which to start end_x - x-coordinate at which to stop end_y - y-coordinate at which to stopUsage:driver.flick(100, 100, 100, 400)用法:driver.flick(x1,y1,x2,y2) pinchpinch(self, element=None, percent=200, steps=50):Pinch on an element a certain amount在元素上执行模拟双指捏（缩小操作）Args: element - the element to pinch percent - (optional) amount to pinch. Defaults to 200% steps - (optional) number of steps in the pinch action Usage: driver.pinch(element)用法: driver.pinch(element) zoomzoom(self, element=None, percent=200, steps=50):Zooms in on an element a certain amount在元素上执行放大操作Args: element - the element to zoom percent - (optional) amount to zoom. Defaults to 200% steps - (optional) number of steps in the zoom action Usage: driver.zoom(element)用法: driver.zoom(element) resetreset(self):Resets the current application on the device.重置应用(类似删除应用数据)用法:driver.reset() hide_keyboardhide_keyboard(self, key_name=None, key=None, strategy=None):Hides the software keyboard on the device. In iOS, use key_name to press a particular key, or strategy. In Android, no parameters are used.隐藏键盘,iOS使用key_name隐藏，安卓不使用参数Args: key_name - key to press strategy - strategy for closing the keyboard (e.g., tapOutside) driver.hide_keyboard() keyeventkeyevent(self, keycode, metastate=None):Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html.发送按键码（安卓仅有），按键码可以上网址中找到Args: keycode - the keycode to be sent to the device metastate - meta information about the keycode being sent 用法:dr.keyevent(‘4’) press_keycodepress_keycode(self, keycode, metastate=None):Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html.发送按键码（安卓仅有），按键码可以上网址中找到Args: keycode - the keycode to be sent to the device metastate - meta information about the keycode being sent 用法:driver.press_ keycode(‘4’) dr.keyevent(‘4’)与driver.press_ keycode(‘4’) 功能实现上一样的，都是按了返回键 long_press_keycodelong_press_keycode(self, keycode, metastate=None):Sends a long press of keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html.发送一个长按的按键码（长按某键）Args: keycode - the keycode to be sent to the device metastate - meta information about the keycode being sent用法:driver.long_press_keycode(‘4’) current_activitycurrent_activity(self):Retrieves the current activity on the device.获取当前的activity用法:print(driver.current_activity()) wait_activitywait_activity(self, activity, timeout, interval=1):Wait for an activity: block until target activity presents or time out.This is an Android-only method.等待指定的activity出现直到超时，interval为扫描间隔1秒即每隔几秒获取一次当前的activity返回的True 或 FalseAgrs: activity - target activity timeout - max wait time, in seconds interval - sleep interval between retries, in seconds 用法: driver.wait_activity(‘.activity.xxx’,5,2) background_appbackground_app(self, seconds):Puts the application in the background on the device for a certain duration.后台运行app多少秒Args: seconds - the duration for the application to remain in the background用法:driver.background_app(5)置后台5秒后再运行 is_app_installedis_app_installed(self, bundle_id):Checks whether the application specified by bundle_id is installed on the device.检查app是否有安装返回 True or FalseArgs: bundle_id - the id of the application to query 用法:driver.is_app_installed(“com.xxxx”) install_appinstall_app(self, app_path):Install the application found at app_path on the device.安装app,app_path为安装包路径Args: app_path - the local or remote path to the application to install 用法:driver.install_app(app_path) remove_appremove_app(self, app_id):Remove the specified application from the device.删除appArgs: app_id - the application id to be removed 用法:driver.remove_app(“com.xxx.”) launch_applaunch_app(self):Start on the device the application specified in the desired capabilities.启动app用法:driver.launch_app() close_appclose_app(self):Stop the running application, specified in the desired capabilities, on the device.关闭app用法:driver.close_app()启动和关闭app运行好像会出错 start_activitystart_activity(self, app_package, app_activity, **opts):Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened.This is an Android-only method.在测试过程中打开任意活动。如果活动属于另一个应用程序，该应用程序的启动和活动被打开。这是一个安卓的方法Args: app_package - The package containing the activity to start. app_activity - The activity to start. app_wait_package - Begin automation after this package starts (optional). app_wait_activity - Begin automation after this activity starts (optional). intent_action - Intent to start (optional). intent_category - Intent category to start (optional). intent_flags - Flags to send to the intent (optional). optional_intent_arguments - Optional arguments to the intent (optional). stop_app_on_reset - Should the app be stopped on reset (optional)? 用法:driver.start_activity(app_package, app_activity) locklock(self, seconds):Lock the device for a certain period of time. iOS only.锁屏一段时间 iOS专有Args: the duration to lock the device, in seconds 用法:driver.lock() shakeshake(self):Shake the device.摇一摇手机用法:driver.shake() open_notificationsopen_notifications(self):Open notification shade in Android (API Level 18 and above)打系统通知栏（仅支持API 18 以上的安卓系统）用法:driver.open_notifications() network_connectionnetwork_connection(self):Returns an integer bitmask specifying the network connection type.Android only.返回网络类型 数值Possible values are available through the enumeration appium.webdriver.ConnectionType用法:driver.network_connection set_network_connectionset_network_connection(self, connectionType):Sets the network connection type. Android only.Possible values: Value (Alias) Data Wifi Airplane Mode 0 (None) 0 0 0 1 (Airplane Mode) 0 0 1 2 (Wifi only) 0 1 0 4 (Data only) 1 0 0 6 (All network on) 1 1 0 These are available through the enumeration appium.webdriver.ConnectionType` 设置网络类型Args: connectionType - a member of the enum appium.webdriver.ConnectionType 用法:先加载from appium.webdriver.connectiontype import ConnectionTypedr.set_network_connection(ConnectionType.WIFI_ONLY)ConnectionType的类型有NO_CONNECTION = 0AIRPLANE_MODE = 1WIFI_ONLY = 2DATA_ONLY = 4ALL_NETWORK_ON = 6 available_ime_enginesavailable_ime_engines(self):Get the available input methods for an Android device. Package and activity are returned (e.g., [‘com.android.inputmethod.latin/.LatinIME’])Android only.返回安卓设备可用的输入法用法:print(driver.available_ime_engines) is_ime_activeis_ime_active(self):Checks whether the device has IME service active. Returns True/False.Android only.检查设备是否有输入法服务活动。返回真/假。安卓用法:print(driver.is_ime_active()) activate_ime_engineactivate_ime_engine(self, engine):Activates the given IME engine on the device.Android only.激活安卓设备中的指定输入法，设备可用输入法可以从“available_ime_engines”获取Args: engine - the package and activity of the IME engine to activate (e.g.,’com.android.inputmethod.latin/.LatinIME’) 用法: driver.activate_ime_engine(“com.android.inputmethod.latin/.LatinIME”) deactivate_ime_enginedeactivate_ime_engine(self):Deactivates the currently active IME engine on the device.Android only.关闭安卓设备当前的输入法用法:driver.deactivate_ime_engine() active_ime_engineactive_ime_engine(self):Returns the activity and package of the currently active IME engine (e.g.,’com.android.inputmethod.latin/.LatinIME’).Android only.返回当前输入法的包名用法:driver.active_ime_engine toggle_location_servicestoggle_location_services(self):Toggle the location services on the device. Android only.打开安卓设备上的位置定位设置用法:driver.toggle_location_services() set_locationset_location(self, latitude, longitude, altitude):Set the location of the device设置设备的经纬度Args: latitude纬度 - String or numeric value between -90.0 and 90.00 longitude经度 - String or numeric value between -180.0 and 180.0 altitude海拔高度- String or numeric value 用法:driver.set_location(纬度，经度，高度) tag_nametag_name(self):This element’s tagName property.返回元素的tagName属性经实践返回的是class name用法:element.tag_name() texttext(self):The text of the element.返回元素的文本值用法:element.text() clickclick(self):Clicks the element.点击元素用法:element.click() submitsubmit(self):Submits a form.提交表单用法:暂无 clearclear(self):Clears the text if it’s a text entry element.清除输入的内容用法:element.clear() get_attributeget_attribute(self, name):详见@chenhengjie123 的超级链接Gets the given attribute or property of the element. 获取 content-desc 的方法为 get_attribute(“name”) ，而且还不能保证返回的一定是 content-desc （content-desc 为空时会返回 text 属性值） get_attribute 方法不是我们在 uiautomatorviewer 看到的所有属性都能获取的（此处的名称均为使用 get_attribute 时使用的属性名称)可获取的：字符串类型： name(返回 content-desc 或 text) text(返回 text) className(返回 class，只有 API=&gt;18 才能支持) resourceId(返回 resource-id，只有 API=&gt;18 才能支持)This method will first try to return the value of a property with the given name. If a property with that name doesn’t exist, it returns the value of the attribute with the same name. If there’s no attribute with that name, None is returned.Values which are considered truthy, that is equals “true” or “false”,are returned as booleans. All other non-None values are returned as strings. For attributes or properties which do not exist, None is returned. Args: name - Name of the attribute/property to retrieve. Example: # Check if the &quot;active&quot; CSS class is applied to an element. is_active = &quot;active&quot; in target_element.get_attribute(&quot;class&quot;) 用法:暂无 is_selectedis_selected(self):Returns whether the element is selected.Can be used to check if a checkbox or radio button is selected.返回元素是否选择。可以用来检查一个复选框或单选按钮被选中。用法:element.is_slected() is_enabledis_enabled(self):Returns whether the element is enabled.返回元素是否可用True of False用法:element.is_enabled() find_element_by_idfind_element_by_id(self, id_):Finds element within this element’s children by ID.通过元素的ID定位元素Args: id_ - ID of child element to locate. 用法:driver. find_element_by_id(“id”) find_elements_by_idfind_elements_by_id(self, id_):Finds a list of elements within this element’s children by ID.通过元素ID定位,含有该属性的所有元素Args: id_ - Id of child element to find. 用法:driver. find_elements_by_id(“id”) find_element_by_namefind_element_by_name(self, name):Finds element within this element’s children by name.通过元素Name定位（元素的名称属性text）.Args: name - name property of the element to find. 用法:driver.find_element_by_name(“name”) find_elements_by_namefind_elements_by_name(self, name):Finds a list of elements within this element’s children by name.通过元素Name定位（元素的名称属性text），含有该属性的所有元素.Args: name - name property to search for. 用法:driver.find_element_by_name(“name”) find_element_by_link_textfind_element_by_link_text(self, link_text):Finds element within this element’s children by visible link text.通过元素可见链接文本定位.Args: link_text - Link text string to search for. 用法:driver.find_element_by_link_text(“text”) find_elements_by_link_textfind_element_by_link_text(self, link_text):Finds a list of elements within this element’s children by visible link text.通过元素可见链接文本定位,含有该属性的所有元素.Args: link_text - Link text string to search for. 用法:driver.find_elements_by_link_text(“text”) find_element_by_partial_link_textfind_element_by_partial_link_text(self, link_text):Finds element within this element’s children by partially visible link text.通过元素部分可见链接文本定位.Args: link_text - Link text string to search for. driver. find_element_by_partial_link_text(“text”) find_elements_by_partial_link_textfind_elements_by_partial_link_text(self, link_text):Finds a list of elements within this element’s children by link text.通过元素部分可见链接文本定位,含有该属性的所有元素.Args: link_text - Link text string to search for. driver. find_elements_by_partial_link_text(“text”) find_element_by_tag_namefind_element_by_tag_name(self, name):Finds element within this element’s children by tag name.通过查找html的标签名称定位元素Args: name - name of html tag (eg: h1, a, span) 用法: driver.find_element_by_tag_name(“name”) find_elements_by_tag_namefind_elements_by_tag_name(self, name):Finds a list of elements within this element’s children by tag name.通过查找html的标签名称定位所有元素Args: name - name of html tag (eg: h1, a, span). 用法: driver.find_elements_by_tag_name(“name”) find_element_by_xpathfind_element_by_xpath(self, xpath):Finds element by xpath.通过Xpath定位元素，详细方法可参阅http://www.w3school.com.cn/xpath/Args:xpath - xpath of element to locate. “//input[@class=’myelement’]”Note: The base path will be relative to this element’s location.This will select the first link under this element.myelement.find_elements_by_xpath(&quot;.//a&quot;)However, this will select the first link on the page.myelement.find_elements_by_xpath(&quot;//a&quot;) 用法 find_element_by_xpath(“//*”) find_elements_by_xpathfind_elements_by_xpath(self, xpath):Finds elements within the element by xpath.Args: xpath - xpath locator string. Note: The base path will be relative to this element’s location.This will select all links under this element.myelement.find_elements_by_xpath(&quot;.//a&quot;).However, this will select all links in the page itself.myelement.find_elements_by_xpath(&quot;//a&quot;). 用法:find_elements_by_xpath(“//*”) find_element_by_class_namefind_element_by_class_name(self, name):Finds element within this element’s children by class name.通过元素class name属性定位元素.Args: name - class name to search for. 用法:driver. find_element_by_class_name(“android.widget.LinearLayout”) find_elements_by_class_namefind_elements_by_class_name(self, name):Finds a list of elements within this element’s children by class name.通过元素class name属性定位所有含有该属性的元素.Args: name - class name to search for. 用法:driver. find_elements_by_class_name(“android.widget.LinearLayout”). find_element_by_css_selectorfind_element_by_css_selector(self, css_selector):Finds element within this element’s children by CSS selector.通过CSS选择器定位元素.Args: css_selector - CSS selctor string, ex: ‘a.nav#home’ send_keyssend_keys(self, *value):Simulates typing into the element.在元素中模拟输入（开启appium自带的输入法并配置了appium输入法后，可以输入中英文）.Args: value - A string for typing, or setting form fields. For setting file inputs, this could be a local file path.Use this to send simple key events or to fill out form fields:form_textfield = driver.find_element_by_name(&#39;username&#39;)form_textfield.send_keys(&quot;admin&quot;)This can also be used to set file inputs.file_input = driver.find_element_by_name(&#39;profilePic&#39;)file_input.send_keys(&quot;path/to/profilepic.gif&quot;)# Generally it&#39;s better to wrap the file path in one of the methods# in os.path to return the actual path to support cross OS testing.# file_input.send_keys(os.path.abspath(&quot;path/to/profilepic.gif&quot;))driver.element.send_keys(“中英”) is_displayedis_displayed(self):Whether the element is visible to a user.此元素用户是否可见。简单地说就是隐藏元素和被控件挡住无法操作的元素（仅限 Selenium，appium是否实现了类似功能不是太确定）这一项都会返回 False.用法:driver.element.is_displayed() location_once_scrolled_into_viewlocation_once_scrolled_into_view(self):“””THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover. where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view.Returns the top lefthand corner location on the screen, or None if the element is not visible. 暂不知道用法 sizesize(self):The size of the element.获取元素的大小（高和宽）.new_size[&quot;height&quot;] = size[&quot;height&quot;]new_size[&quot;width&quot;] = size[&quot;width&quot;] 用法:driver.element.size value_of_css_propertyvalue_of_css_property(self, property_name):The value of a CSS property.CSS属性用法 暂不知 locationlocation(self):The location of the element in the renderable canvas.获取元素左上角的坐标用法:driver.element.location返回element的x坐标, int类型driver.element.location.get(&#39;x&#39;)返回element的y坐标, int类型driver.element.location.get(&#39;y&#39;) rectrect(self):A dictionary with the size and location of the element.元素的大小和位置的字典 screenshot_as_base64screenshot_as_base64(self):Gets the screenshot of the current element as a base64 encoded string.获取当前元素的截图为Base64编码的字符串Usage:img_b64 = element.screenshot_as_base64 execute_scriptexecute_script(self, script, *args):Synchronously Executes JavaScript in the current window/frame.在当前窗口/框架（特指 Html 的 iframe ）同步执行 javascript 代码。你可以理解为如果这段代码是睡眠5秒，这五秒内主线程的 javascript 不会执行Args: script: The JavaScript to execute. *args: Any applicable arguments for your JavaScript.Usage:driver.execute_script(&#39;document.title&#39;) execute_async_scriptexecute_async_script(self, script, *args):Asynchronously Executes JavaScript in the current window/frame.插入 javascript 代码，只是这个是异步的，也就是如果你的代码是睡眠5秒，那么你只是自己在睡，页面的其他 javascript 代码还是照常执行Args: script: The JavaScript to execute. *args: Any applicable arguments for your JavaScript. Usage:driver.execute_async_script(&#39;document.title&#39;) current_urlcurrent_url(self):Gets the URL of the current page.获取当前页面的网址。Usage:driver.current_url用法driver.current_url page_sourcepage_source(self):Gets the source of the current page.获取当前页面的源Usage:driver.page_source closeclose(self):Closes the current window.关闭当前窗口Usage:driver.close() quitquit(self):Quits the driver and closes every associated window.退出脚本运行并关闭每个相关的窗口连接Usage:driver.quit() 参考资料:打造心目中理想的自动化测试框(AppiumBooster) 从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用 Python-Client的github文档地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[命令行工具使用]]></title>
      <url>%2F2017%2F02%2F18%2Fcommand-line-tools%2F</url>
      <content type="text"><![CDATA[替换Ruby的源 $gem source -r https://rubygems.org/ $ gem source -a https://ruby.taobao.org $ gem sources -l要想验证是否替换成功了，可以执行 CURRENT SOURCES http://ruby.taobao.org/正常的输出结果 Mac OS X安装Ruby运行环境 先安装 Xcode 开发工具，它将帮你安装好 Unix 环境需要的开发包。 安装 RVM $ curl -L https://get.rvm.io | bash -s stable期间可能会问你sudo管理员密码，以及自动通过homebrew安装依赖包，等待一段时间后就可以成功安装好 RVM。 $ source ~/.rvm/scripts/rvm载入 RVM 环境 rvm -v检查一下是否安装正确 用 RVM 安装 Ruby 环境 $ rvm list known列出已知的ruby版本 $ rvm install 2.4.0可以选择现有的rvm版本来进行安装 $ rvm list查询已经安装的ruby $ rvm remove 1.9.2卸载一个已安装版本 设置 Ruby 版本 $ rvm 2.0.0 --defaultRVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本 Mac OS X安装cocoapods sudo gem install cocoapods 如果速度不行，更换源。 Mac OS X安装命令行切图工具 由一张1024*1024的图片批量生成applogo brew install imagemagick 配置icon_convert.sh文件 cd 到icon_convert.sh所在文件夹 执行./icon_convert.sh &#39;1024.png&#39; 生成对应的appicon]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LaTeX表示方法]]></title>
      <url>%2F2017%2F02%2F18%2Flatex%2F</url>
      <content type="text"><![CDATA[一、指数和下标可以用^和_后加相应字符来实现。 二、平方根（square root）的输入命令为：\sqrt，n 次方根相应地为: \sqrt[n]。方根符号的大小由LATEX自动加以调整。也可用\surd 仅给出符号。 三、命令\overline 和\underline 在表达式的上、下方画出水平线。 四、命令\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号。 五、向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量时非常有用。 六、分数（fraction）使用\frac{…}{…} 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。 七、积分运算符（integral operator）用\int 来生成。求和运算符（sum operator）由\sum 生成。乘积运算符（product operator）由\prod 生成。上限和下限用^ 和_来生成，类似于上标和下标。 以下提供一些常用符号的表示方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Matrix]]></title>
      <url>%2F2017%2F02%2F10%2Fandroid-matrix%2F</url>
      <content type="text"><![CDATA[Matrix的数学原理在Android中，如果你用Matrix进行过图像处理，那么一定知道Matrix这个类。Android中的Matrix是一个3 x 3的矩阵，其内容如下： Matrix的对图像的处理可分为四类基本变换： Translate ———— 平移变换 Rotate ———— 旋转变换 Scale ———— 缩放变换 Skew ———— 错切变换 从字面上理解，矩阵中的MSCALE用于处理缩放变换，MSKEW用于处理错切变换，MTRANS用于处理平移变换，MPERSP用于处理透视变换。实际中当然不能完全按照字面上的说法去理解Matrix。同时，在Android的文档中，未见到用Matrix进行透视变换的相关说明，所以本文也不讨论这方面的问题。这里需要把矩阵根据他们的作用划分为4块： 如上图所示，这四块区域各有作用。后面会详细讲解各个作用，先来看看这个矩阵是如何影响图像的。先看看屏幕的坐标系： 看上图，这里表示了屏幕的坐标系，其中的x，y轴是大家所熟知的，但是其实，一个物体他是存在于一个三维空间的，所以必然会有z轴。我们的屏幕，就像是一个窗口，透过它，我们看到了屏幕后面的世界，那里面有各种物体，我们看到的是映射在x，y平面上的一个投射图像。屏幕就像是一个镜头一样，将里面的物体映射到x，y平面上，成为一个二维的图像。那么如果，我们把屏幕这个镜头沿着z轴，拉远或者拉进，那么图像会有什么变化呢，肯定会变小或者变大。就好比坐在飞机上透过窗口看地面的汽车，和在地面上看到的大小是不同的。 x，y分别代表x，y轴上的坐标，而1代表屏幕在z轴上的坐标为默认的。如果将1变大，那么屏幕会拉远， 图形会变小。 针对每种变换，Android提供了pre、set和post三种操作方式。其中 set用于设置Matrix中的值。 pre是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。 post是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。 除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。 下面我们来看看四种变换的具体情形。由于所有的图形都是有点组成，因此我们只需要考察一个点相关变换即可。 平移变换假定有一个点的坐标是 P($x{0}$,$y{0}$) ，将其移动到 P(x,y) ，再假定在x轴和y轴方向移动的大小分别为: $\Delta$x = x - $x{0}$ and $\Delta$y = y - $y{0}$ 如下图所示： 不难知道：x = $x{0}$ + $\Delta$xy = $y{0}$ + $\Delta$y 如果用矩阵来表示的话，就可以写成： 旋转变换围绕坐标原点旋转：假定有一个点 P($x{0}$,$y{0}$) ，相对坐标原点 $\theta$ 顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图： 那么， 如果用矩阵，就可以表示为： 围绕某个点旋转如果是围绕某个点 P($x{p}$,$y{p}$) 顺时针旋转 $\theta$ ，那么可以用矩阵表示为：可以化为：很显然1、是将坐标原点移动到点 P($x{p}$,$y{p}$) 后， P($x{0}$,$y{0}$) 的新坐标。 2、是将上一步变换后的 P($x{0}$,$y{0}$) ，围绕新的坐标原点顺时针旋转 $\theta$ 。3、经过上一步旋转变换后，再将坐标原点移回到原来的坐标原点。所以，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。 同时，可以看到，上面的矩阵四块区域的切分也是因为矩阵乘法的操作决定的，由于这里的乘法运算中，左上角的四个值，可以和x，y值做乘法运算，所以可以影响到旋转等操作，而右上角的模块，只能做加法，所以只能影响到平移。右下角的模块主要管z轴，自然就可以进行等比的缩放了，左下角的模块一般不去动他，否则会把x，y值加入到z轴中来，会不可控。 缩放变换理论上而言，一个点是不存在什么缩放变换的，但考虑到所有图像都是由点组成，因此，如果图像在x轴和y轴方向分别放大k1和k2倍的话，那么图像中的所有点的x坐标和y坐标均会分别放大k1和k2倍，即x = $k{1}$$x{0}$y = $k{2}$$y{0}$用矩阵表示就是：缩放变换比较好理解，就不多说了。 错切变换错切变换(skew)在数学上又称为Shear mapping(可译为“剪切变换”)或者Transvection(缩并)，它是一种比较特殊的线性变换。错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对应的y坐标(或者x坐标)则按比例发生平移，且平移的大小和该点到x轴(或y轴)的垂直距离成正比。错切变换，属于等面积变换，即一个形状在错切变换的前后，其面积是相等的。比如下图，各点的y坐标保持不变，但其x坐标则按比例发生了平移。这种情况将水平错切。 下图各点的x坐标保持不变，但其y坐标则按比例发生了平移。这种情况叫垂直错切。 假定一个点 P($x{0}$,$y{0}$) 经过错切变换后得到 P(x,y) ，对于水平错切而言，应该有如下关系：x = $x{0}$ + k$y{0}$y = $y_{0}$用矩阵表示就是：扩展到3 x 3的矩阵就是下面这样的形式：同理，对于垂直错切，可以有：在数学上严格的错切变换就是上面这样的。在Android中除了有上面说到的情况外，还可以同时进行水平、垂直错切，那么形式上就是： 对称变换除了上面讲到的4中基本变换外，事实上，我们还可以利用Matrix，进行对称变换。所谓对称变换，就是经过变化后的图像和原图像是关于某个对称轴是对称的。比如，某点 P($x{0}$,$y{0}$) 经过对称变换后得到 P(x,y) ， 如果对称轴是x轴，那么，x = $x{0}$y = -$y{0}$用矩阵表示就是：如果对称轴是y轴，那么，x = -$x{0}$y = $y{0}$用矩阵表示就是：如果对称轴是y = x，如图：那么，很容易可以解得：x = $y{0}$y = $x{0}$用矩阵表示就是：同样的道理，如果对称轴是y = -x，那么用矩阵表示就是：特殊地，如果对称轴是y = kx，如下图：那么，很容易可解得：用矩阵表示就是： 当k = 0时，即y = 0，也就是对称轴为x轴的情况；当k趋于无穷大时，即x = 0，也就是对称轴为y轴的情况；当k =1时，即y = x，也就是对称轴为y = x的情况；当k = -1时，即y = -x，也就是对称轴为y = -x的情况。不难验证，这和我们前面说到的4中具体情况是相吻合的。如果对称轴是y = kx + b这样的情况，只需要在上面的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：需要特别注意：在实际编程中，我们知道屏幕的y坐标的正向和数学中y坐标的正向刚好是相反的，所以在数学上y = x和屏幕上的y = -x才是真正的同一个东西，反之亦然。也就是说，如果要使图片在屏幕上看起来像按照数学意义上y = x对称，那么需使用这种转换：要使图片在屏幕上看起来像按照数学意义上y = -x对称，那么需使用这种转换：关于对称轴为y = kx 或y = kx + b的情况，同样需要考虑这方面的问题。 三角函数12public void setSinCos(float sinValue, float cosValue, float px, float py)public void setSinCos(float sinValue, float cosValue) 这个方法乍一看可能有点蒙，其实在前面的原理中，我们讲解了一个旋转的例子，他最终的矩阵效果是这样的： 其实旋转，就是使用了这样的matrix，显而易见，这里的参数就清晰了。sinValue：对应图中的sin值cosValue：对应cos值px:中心的x坐标py：中心的y坐标看一个示例,我们把图像旋转90度，那么90度对应的sin和cos分别是1和0。 看代码如下： 123Matrixmatrix = new Matrix();matrix.setSinCos(1, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);canvas.drawBitmap(bitmap, matrix, paint);123123 数值操作数值操作这一组方法可以帮助我们直接控制Matrix里面的数值。 setvoid set (Matrix src)没有返回值，有一个参数，作用是将参数Matrix的数值复制到当前Matrix中。如果参数为空，则重置当前Matrix，相当于reset() resetvoid reset ()重置当前Matrix(将当前Matrix重置为单位矩阵)。 setValuesvoid setValues (float[] values)setValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。 getValuesvoid getValues (float[] values)很显然，getValues和setValues是一对方法，参数也是浮点型的一维数组，长度需要大于9，将Matrix中的数值拷贝进参数的前9位中。 基本方法解析讲解完了matrix作用于像素点的原理之后，我们逐个讲解它的方法。 12public Matrix()public Matrix(Matrix src) 构造函数有两个，第一个是直接创建一个单位矩阵，第二个是根据提供的矩阵创建一个新的矩阵（采用deep copy）单位矩阵如下： 12public boolean isIdentity()//判断是否是单位矩阵public boolean isAffine()//判断是否是仿射矩阵 是否是单位矩阵很简单，就不做讲解了，这里是否是仿射矩阵可能大家不好理解。首先来看看什么是仿射变换。仿射变换其实就是二维坐标到二维坐标的线性变换，保持二维图形的“平直性”（即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（指保持二维图形间的相对位置关系不变，平行线还是平行线，而直线上点的位置顺序不变），可以通过一系列的原子变换的复合来实现，原子变换就包括：平移、缩放、翻转、旋转和错切。这里除了透视可以改变z轴以外，其他的变换基本都是上述的原子变换，所以，只要最后一行是0,0,1则是仿射矩阵。public boolean rectStaysRect()判断该矩阵是否可以将一个矩形依然变换为一个矩形。当矩阵是单位矩阵，或者只进行平移，缩放，以及旋转90度的倍数的时候，返回true。public void reset()重置矩阵为单位矩阵。public void setTranslate(float dx, float dy)设置平移效果，参数分别是x，y上的平移量。效果图如下： 代码如下： 12345Matrix matrix = new Matrix();canvas.drawBitmap(bitmap, matrix, paint);matrix.setTranslate(100, 1000);canvas.drawBitmap(bitmap, matrix, paint);1234512345 代码验证在第一部分中讲到的各种图像变换的验证代码如下，一共列出了10种情况。如果要验证其中的某一种情况，只需将相应的代码反注释即可。试验中用到的图片：其尺寸为162 x 251。 每种变换的结果，请见代码之后的说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372import android.app.Activity; import android.content.Context; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Canvas; import android.graphics.Matrix; import android.os.Bundle; import android.util.Log; import android.view.MotionEvent; import android.view.View; import android.view.Window; import android.view.WindowManager; import android.view.View.OnTouchListener; import android.widget.ImageView; public class TestTransformMatrixActivity extends Activity implements OnTouchListener &#123; private TransformMatrixView view; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); view = new TransformMatrixView(this); view.setScaleType(ImageView.ScaleType.MATRIX); view.setOnTouchListener(this); setContentView(view); &#125; class TransformMatrixView extends ImageView &#123; private Bitmap bitmap; private Matrix matrix; public TransformMatrixView(Context context) &#123; super(context); bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie); matrix = new Matrix(); &#125; @Override protected void onDraw(Canvas canvas) &#123; // 画出原图像 canvas.drawBitmap(bitmap, 0, 0, null); // 画出变换后的图像 canvas.drawBitmap(bitmap, matrix, null); super.onDraw(canvas); &#125; @Override public void setImageMatrix(Matrix matrix) &#123; this.matrix.set(matrix); super.setImageMatrix(matrix); &#125; public Bitmap getImageBitmap() &#123; return bitmap; &#125; &#125; public boolean onTouch(View v, MotionEvent e) &#123; if(e.getAction() == MotionEvent.ACTION_UP) &#123; Matrix matrix = new Matrix(); // 输出图像的宽度和高度(162 x 251) Log.e("TestTransformMatrixActivity", "image size: width x height = " + view.getImageBitmap().getWidth() + " x " + view.getImageBitmap().getHeight()); // 1. 平移 matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight()); // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight() view.setImageMatrix(matrix); // 下面的代码是为了查看matrix中的元素 float[] matrixValues = new float[9]; matrix.getValues(matrixValues); for(int i = 0; i &lt; 3; ++i) &#123; String temp = new String(); for(int j = 0; j &lt; 3; ++j) &#123; temp += matrixValues[3 * i + j ] + "\t"; &#125; Log.e("TestTransformMatrixActivity", temp); &#125; // // 2. 旋转(围绕图像的中心点) // matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 3. 旋转(围绕坐标原点) + 平移(效果同2) // matrix.setRotate(45f); // matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f); // matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f); // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 4. 缩放 // matrix.setScale(2f, 2f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 5. 错切 - 水平 // matrix.setSkew(0.5f, 0f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth(), 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 6. 错切 - 垂直 // matrix.setSkew(0f, 0.5f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // 7. 错切 - 水平 + 垂直 // matrix.setSkew(0.5f, 0.5f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 8. 对称 (水平对称) // float matrix_values[] = &#123;1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 9. 对称 - 垂直 // float matrix_values[] = &#123;-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 10. 对称(对称轴为直线y = x) // float matrix_values[] = &#123;0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(), // view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; view.invalidate(); &#125; return true; &#125; &#125; 下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵 平移输出的结果：请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。 旋转(围绕图像的中心点)输出的结果： 它实际上是matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式,matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);所产生的转换矩阵就是：而matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);的意思就是在上述矩阵的左边再乘以下面的矩阵：关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。所以它实际上就是：出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。 旋转(围绕坐标原点旋转，在加上两次平移，效果同2)根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道：matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);等价于matrix.setRotate(45f);matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);其中matrix.setRotate(45f)对应的矩阵是： matrix.preTranslate(-1f view.getImageBitmap().getWidth() / 2f, -1f view.getImageBitmap().getHeight()/ 2f)对应的矩阵是： 由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。 matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f)对应的矩阵是：这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。 所以综合起来， matrix.setRotate(45f);matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);对应的矩阵就是：这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的：因此，此处变换后的图像和2中变换后的图像时一样的。 缩放变换程序所输出的两个矩阵分别是：其中第二个矩阵，其实是下面两个矩阵相乘的结果：大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。 错切变换(水平错切)代码所输出的两个矩阵分别是：其中，第二个矩阵其实是下面两个矩阵相乘的结果：大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 错切变换(垂直错切) 代码所输出的两个矩阵分别是：其中，第二个矩阵其实是下面两个矩阵相乘的结果：大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 错切变换(水平+垂直错切)代码所输出的两个矩阵分别是：其中，后者是下面两个矩阵相乘的结果：大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 对称变换(水平对称) 代码所输出的两个各矩阵分别是：其中，后者是下面两个矩阵相乘的结果：大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 对称变换(垂直对称) 代码所输出的两个矩阵分别是：其中，后者是下面两个矩阵相乘的结果：大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 对称变换(对称轴为直线y = x)代码所输出的两个矩阵分别是：其中，后者是下面两个矩阵相乘的结果：大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 关于先乘和后乘的问题由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例：越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。 当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate($\theta$)，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。 进阶方法解析上面的基本方法中，有关于变换的set方法都可以带来不同的效果，但是每个set都会把上个效果清除掉，例如依次调用了setSkew,setTranslate，那么最终只有setTranslate会起作用，那么如何才和将两种效果复合呢。Matrix给我们提供了很多方法。但是主要都是2类：preXXXX:以pre开头，例如preTranslatepostXXXX:以post开头，例如postScale他们分别代表了前乘，和后乘。看一段代码： 123Matrix matrix = new Matrix();matrix.setTranslate(100, 1000);matrix.preScale(0.5f, 0.5f); 这里matrix前乘了一个scale矩阵，换算成数学式如下： 从上面可以看出，最终得出的matrix既包含了缩放信息也有平移信息。后乘自然就是matrix在后面，而缩放矩阵在前面，由于矩阵前后乘并不等价，也就导致了他们的效果不同。我们来看看后乘的结果： 可以看到，结果跟上面不同，并且这也不是我们想要的结果，这里缩放没有更改，但是平移被减半了，换句话说，平移的距离也被缩放了。所以需要注意前后乘法的关系。来看看他们对应的效果图：前乘： 后乘： 可以明显看到，后乘的平移距离受了影响。了解清除了前后乘的意义，在使用的过程中，多个效果的叠加时，一样要注意，否则效果达不到预期。 其他方法解析matrix除了上面的方法外，还有一些其他的方法，这里依次解析 setRectToRectpublic boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf)将rect变换成rect，上面的rectStaysRect已经说过，要保持rect只能做缩放平移和选择90度的倍数，那么这里其实也是一样，只是这几种变化，这里通过stf参数来控制。ScaleToFit 有如下四个值：FILL: 可能会变换矩形的长宽比，保证变换和目标矩阵长宽一致。START:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。左上对齐。CENTER: 保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。END:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。右下对齐。这里使用谷歌的api demo的图片作为例子： setPolyToPolypublic boolean setPolyToPoly(float[] src, int srcIndex,float[] dst, int dstIndex,int pointCount)通过指定的0-4个点，原始坐标以及变化后的坐标，来得到一个变换矩阵。如果指定0个点则没有效果。下面通过例子分别说明1到4个点的可以达到的效果： 1个点，平移只指定一个点，可以达到平移效果： 代码如下：12345float[] src = &#123;0, 0&#125;;int DX = 300;float[] dst = &#123;0 + DX, 0 + DX&#125;;matrix.setPolyToPoly(src, 0, dst, 0, 1);canvas.drawBitmap(bitmap, matrix, paint);1234512345 2个点，旋转或者缩放两个点，可以达到旋转效果或者缩放效果，缩放比较简单，这里我们来看旋转效果，一个点指定中心，一点指出旋转的效果 代码如下123456int bw = bitmap.getWidth();int bh = bitmap.getHeight();float[] src = &#123;bw / 2, bh / 2, bw, 0&#125;;float[] dst = &#123;bw / 2, bh / 2, bw / 2 + bh / 2, bh / 2 + bw / 2&#125;;matrix.setPolyToPoly(src, 0, dst, 0, 2);canvas.drawBitmap(bitmap, matrix, paint);123456123456 图片的中心点作为旋转的中心，前后不变，右上角变化到了下方，所以导致图片旋转了90度。 3个点，错切使用3个点，可以产生错切效果，指定3个顶点，一个固定，另外两个移动。看图： 代码如下： 1234567Matrix matrix = new Matrix();int bw = bitmap.getWidth();int bh = bitmap.getHeight();float[] src = &#123;0,0, 0, bh,bw,bh&#125;;float[] dst = &#123;0, 0, 200, bh, bw + 200, bh&#125;;matrix.setPolyToPoly(src, 0, dst, 0, 3);canvas.drawBitmap(bitmap, matrix, paint);12345671234567 4个点，透视透视就是观察的角度变化了。导致投射到平面上的二维图像变化了。我们看下面的例子，更容易理解： 图片看起来好像倾斜了，实现特别简单： 12345678Matrix matrix = new Matrix();int bw = bitmap.getWidth();int bh = bitmap.getHeight();float[] src = &#123;0, 0, 0, bh, bw, bh, bw, 0&#125;;int DX = 100;float[] dst = &#123;0 + DX, 0, 0, bh, bw, bh, bw - DX, 0&#125;;matrix.setPolyToPoly(src, 0, dst, 0, 4);canvas.drawBitmap(bitmap, matrix, paint);1234567812345678 可以看到，只是把左右两个顶点往里面收拢了，这样就得出了一个有3d效果的透视图。 invertpublic boolean invert(Matrix inverse)反转当前矩阵，如果能反转就返回true并将反转后的值写入inverse，否则返回false。当前矩阵*inverse=单位矩阵。反转前后有什么效果，我们来看看示例： 可以看到，反转之后，其实是对效果的一种反转。 mapPoints123public void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex,int pointCount)public void mapPoints(float[] dst, float[] src)public void mapPoints(float[] pts) 映射点的值到指定的数组中，这个方法可以在矩阵变换以后，给出指定点的值。 dst：指定写入的数组 dstIndex：写入的起始索引，x，y两个坐标算作一对，索引的单位是对，也就是经过两个值才加1 src：指定要计算的点 srcIndex：要计算的点的索引 pointCount：需要计算的点的个数，每个点有两个值，x和y。 mapVectors123public void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex,int vectorCount)public void mapVectors(float[] dst, float[] src)public void mapVectors(float[] vecs) 与上面的mapPoionts基本类似，这里是将一个矩阵作用于一个向量，由于向量的平移前后是相等的，所以这个方法不会对translate相关的方法产生反应，如果只是调用了translate相关的方法，那么得到的值和原本的一致。 mapRect12public boolean mapRect(RectF dst, RectF src)public boolean mapRect(RectF rect) 返回值即是调用的rectStaysRect()，这个方法前面有讲过，这里把src中指定的矩形的左上角和右下角的两个点的坐标，写入dst中。 mapRadiuspublic float mapRadius(float radius)返回一个圆圈半径的平均值，将matrix作用于一个指定radius半径的圆，随后返回的平均半径。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 关联 Bitbucket]]></title>
      <url>%2F2017%2F02%2F09%2Fandroid-studio-bitbucket%2F</url>
      <content type="text"><![CDATA[前言Github的确是一个开源代码浏览以及存放的好去处。但是当你想要创立一个私人仓库，存放自己的个人项目时，公开的仓库肯定是不行的，而私人账号必须要收费。对于那些手头紧，并且不想维护服务器的人来说，Bitbucket是个不错的选择。每个Bitbucket账号可以创立5个免费的私人仓库，够用了。最近在做毕业设计，需要将项目git到一个私人仓库，所以学习一下Android Studio和Bitbucket关联，毕竟能IDE中git，就觉得用SourceTree有点麻烦。 Bitbucket简介BitBucket 是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。常用的代码托管平台Github、SVN、Bitbucket中，Bitbucket具有以下优势： 支持Hg，最易学易用（但不是最强大的）的分布式版本管理工具。同时也支持Git。他的网页端的git仓库不如github好用，但是作为远端仓库足够了。 完全免费的闭源项目，还支持5人以内的合作开发。 支持中文。 官方的git工具SourceTree比GitHub for windows好用。 使用步骤一、安装Git安装步骤都是一路默认下一步，这里就不做说明了，安装好了后，需要将AndroidStudio与Git进行关联： Android Studio–&gt; Preferences –&gt; Version Control –&gt; Git，在Path to Git executable栏找到Git安装目录中bin文件下的git文件。点击右侧的Test，如果出现如图中的成功提示框，表示AndroidStudio与Git已经关联成功。 二、在Bitbucket网站创建远程仓库在Bitbucket网站上创建仓库 记录下远程仓库的URL，后面会用到 三、在AndroidStudio中创建新项目首先新建一个项目,然后进入项目后首先选择VCS–&gt;Enable Version Control Integration,然后选择Git，此时代码文件会变成红色 接下来设置项目需要忽略上传的文件File–&gt;Settings –&gt; Version Control –&gt;Ignore Files 接下来将项目添加到Git本地仓库中，在Project视图下，右键工程Git–&gt;Add,添加成功后，代码文件会变成绿色的。 至此创建项目就完成了 四、AndroidStudio中将项目提交并推送到远程仓库进入AS项目中，选择VCS–&gt;Git-&gt;Commit File 填写提交信息后，选择commit and Push 之后点击Define remote 填入第二步中的远程仓库URL，点击OK校验URL后就可以Push了。 到此项目构建者的工作就算完成了，其他小伙伴可以直接参照第六步，从远程仓库剪切项目代码。 六、别忘了给Bitbucket添加SSH密钥ssh-keygen -t rsa -C &quot;your_email@example.com&quot;使用你的邮件创建一个新的 SSH 密匙标签，将会生成 ~/.ssh/id_rsa 文件， 用于存储你的密匙。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 冷启动实现APP秒开]]></title>
      <url>%2F2017%2F02%2F09%2Fandroid-cold-launch%2F</url>
      <content type="text"><![CDATA[前言在阅读这篇文章之前，首先需要理解几个东西： 1、什么是Android的冷启动时间？冷启动时间是指用户从手机桌面点击APP的那一刻起到启动页面的Activity调用onCreate()方法之间的这个时间段。 2、在冷启动的时间段内发生了什么？首先我们要知道当打开一个Activity的时候发生了什么，在一个Activity打开时，如果该Activity所属的Application还没有启动，那么系统会为这个Activity创建一个进程（每创建一个进程都会调用一次Application，所以Application的onCreate()方法可能会被调用多次），在进程的创建和初始化中，势必会消耗一些时间，在这个时间里，WindowManager会先加载APP里的主题样式里的窗口背景（windowBackground）作为预览元素，然后才去真正的加载布局，如果这个时间过长，而默认的背景又是黑色或者白色，这样会给用户造成一种错觉，这个APP很卡，很不流畅，自然也影响了用户体验。 来看下效果图：未优化： 优化方案一： 优化方案二： 历史原因当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态的，这就很尴尬了，因为用户会以为没有点到APP而再次点击，这极大的降低用户体验，Android需要及时做出反馈去避免这段迷之尴尬。于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是Preview Window,即预览窗口。 好了，现在我们明白了，Preview Window其实是为了提高用户体验而有意设定的。因此，其实如果不是强迫症，它可能并不是一个问题。 但是我猜大部分小伙伴应该是和我一样的强迫症患者：这么丑的黑屏怎么能出现在我的APP上呢？？？！！！ 所以，下面我们就来聊聊这个问题的解决方案。 解决方案既然决定解决这个问题，那么从哪里入手呢，Android在选择展示黑屏或者白屏的时候，是根据你设定的主题而不同的，也就是说，虽然你的代码没有被执行，你的配置文件却被提前读取了，用来作为展示Preview Window界面的依据。在用户点击手机桌面APP的时候，看到的黑屏或者白屏其实是界面渲染前的第一帧，如果你看懂了文章头的那2个问题，那么解决这个问题就非常轻松了，无非就是将Theme里的windowBackground设置成我们想要让用户看到的画面就可以了 所以，我们的解决方案的切入口就是整个APP的manifest文件，更确切的说应该是主题配置文件。 方案一 ：开历史倒车这个方案就是禁止加载Preview Window，具体做法如下： style.xml true将APPTheme设定为启动的Activity的主题，即可禁止Preview Window，当然，也有人通过把preview window设置为全透明，也达成了类似的效果。 结果就是，当你点击APP时，界面会无响应一段时间，然后进入APP。 我个人强烈不推荐这么做，因为Android想方设法提升的用户体验一下子被你打回解放前。 方案二：自定义Preview Window1、透明启动将背景颜色设置为透明色，这样当用户点击桌面APP图片的时候，并不会”立即”进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦，哈哈），其实现在微信也是这样做的，不信你可以试试。&lt;style name=&quot;Appwelcome&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot;/&gt;透明化这种做法需要注意的一点，如果直接把Theme引入Activity，在运行的时候可能会出现如下异常： java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity. 这个是因为使用了不兼容的Theme，例如我这里的Activity继承了AppCompatActivity，解决方案很简单： 1、让其Activity集成Activity而不要集成兼容性的AppCompatActivity 2、在onCreate()方法里的super.onCreate(savedInstanceState)之前设置我们原来APP的Theme 1234567public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; setTheme(R.style.AppTheme); super.onCreate(savedInstanceState); &#125;&#125; 2、Logo图片启动将背景图设置成我们APP的Logo图，作为APP启动的引导，现在市面上大部分的APP也是这么做的。具体方法如下： style.xlm123&lt;style name="APPTheme" parent="@android:style/Theme.Holo.NoActionBar"&gt; &lt;item name="android:windowBackground"&gt;@drawable/splash_icon&lt;/item&gt;&lt;/style&gt; 同样将主题设置到启动的Activity的主题中，windowBackground就是即将展示的preview window。其中splash_icon可以是一整张图片，网上很多小伙伴也都是这么做的。其实它也可以是一个能解析出图片资源的XML文件，好像只有layer-list这种能做得到,因为它能够将多个drawable叠加起来展示。 splash_icon.xml12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" android:opacity="opaque"&gt; &lt;item android:drawable="@color/white"/&gt; &lt;item&gt; &lt;bitmap android:gravity="center" android:src="@drawable/qq"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 这样设置之后，当你点击APP，会立马进入你配置的界面，然后启动欢迎页，效果如下 上面的2种做法，我们都需要将Theme引入对应的Activity123456789&lt;activity android:name=".app.main.MainActivity" android:theme="@style/AppWelcome" android:screenOrientation="portrait"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 那么，将preview window直接设置为图片和设置为xml文件有什么区别或者优劣呢？我先卖个关子。先谈谈这种方案的优劣，首先这种方案已经解决了原生preview window的单调难看的问题，在原来的基础上进一步提升了用户体验。可是我们的APP都是有欢（guang）迎（gao）页的，从preview window跳转到欢（guang）迎（gao）页是不可避免的，这样的话，两个界面的切换就会显得很突兀的， 所以强迫症的我们，尝试让这两个界面的切换变成一个界面的变化，从而进一步提升显示效果，怎么样才能让两个界面切换看起来像是在同一个界面里的变化呢？答案就是： 动画。 在这种需求下，图片和xml文件的区别就出来了，因为后者可以帮助我们更准确的实现动画。 方案三：自定义Preview Window增强版废话少说，我们先来看效果 有了动画之后，界面切换顺畅了许多。上面的动画实现其实非常简单，无非就是放缩，移动，渐变的组合使用（我仅仅用作范例给大家参考），具体的动画代码细节就不谈了，有兴趣可以去github上看本次项目的demo，我们重点来聊一聊思路。 在这里我们需要明确一点的是，preview window 只能是静态图，它本身是不展示动画的，我们这里的动画，其实是在进入欢迎页之后的展示的。明确了这一点之后，整个动画效果的实现思路其实就已经摆在我们眼前了，那就是当界面从 Preview Window 跳转到 欢迎页 的时候，欢迎页必须首先展示一个和 Preview Window 一模一样的界面，让人看起来好像界面还没切换一样，然后再慢慢切换到欢迎页。 然后，我们再来谈谈为什么设置xml的方式可以帮助我们更准确的实现动画，就是因为要保证 Preview Window 和欢迎页最开始展示的界面保持绝对一致，只有通过xml的布局才是达到这种效果。 好了，启动页做到这个份儿上，应该就可以交货了，不过还有一个小问题需要大家注意的，那就是我们给Preview Window设置的背景图如果不做处理，图片就会一直存在于内存中，所以，当我们进入到欢迎页的时候，不要忘了把背景图设置为空： SplashActivity.java123456@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; //将window的背景图设置为空 getWindow().setBackgroundDrawable(null); super.onCreate(savedInstanceState);&#125; 关于启动优化上面的做法其实可以达到”秒开”APP的效果，不过确不是真实的速度，在Activity创建过程中其实是会经过一系列framework层的操作，在日常开发中，我们都会去重写Application类，然后在Application里进行一些初始化操作，比如存放用户标识的静态化TOKEN，第三方SDK的初始化等。这里给出几点建议： 1、不要让Application参与业务的操作 2、不要在APPlication进行耗时操作，比如有些开发者会在自己的APP里一系列文件夹或文件（比如我自己），这些I/O操作应该放到”确实该使用的时候再去创建”亦或者是数据库的一些操作。 3、不要以静态变量的方式在Application中保存数据等。 当然这是绝对的理想主义，把上面的”不要”2字之前添上”尽量”2字吧，毕竟在实际开发中，这样做确实会让我们方便许多。 对了，补充一点，布局也是很重要的，尽量的去减少布局的复杂性，布局深度，因为在View绘制的过程中，测量也是很耗费性能的。 总结到这里，关于Android启动页的相关问题就都讲完了。最终的高清的效果图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Thread]]></title>
      <url>%2F2017%2F02%2F05%2Fandroid-thread%2F</url>
      <content type="text"><![CDATA[线程简介现在操作系统在运行一个程序时，会自动为其创建一个进程，不论是 PC 还是 Android。 一个进程内可以有多个线程，这些线程作为操作系统调度的最小单元，负责执行各种各样的任务，这些线程都拥有各自的计数器、堆栈、局部变量等属性，并且可以访问共享内存。 想象一下，如果你的电脑里只有一条线程在执行任务，一旦遇到 I/O 密集的任务，CPU 只能长时等待，效率很低。 如果把一个进程比作一个外卖公司，CPU 就是外卖公司拥有的主要资源（可以当做电动车），那线程（Thread）就是外卖公司中的一位送餐员，Runnable 就是送餐员要执行的任务（一般情况下都是送饭）。 线程创建的三种方式送餐员最重要的任务就是送餐，我们以代码来演示创建一个送餐员的三种方式： 1.实现 Runnable 接口123456789101112131415161718192021222324252627public class ThreadTest0 &#123; /** * 1.实现 Runnable 接口，在 run() 方法中写要执行的任务 */ static class Task implements Runnable&#123; @Override public void run() &#123; try &#123; Thread.sleep(new Random().nextInt(300 )); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": 您的外卖已送达"); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 4; i++) &#123; //2.创建一个送餐员线程，然后将任务传递给他，同时起个名 Thread shixinzhang = new Thread(new Task(), "外卖任务 " + i); //3.命令送餐员出发！ shixinzhang.start(); &#125; &#125;&#125; 注意，上述代码中调用的是送餐员线程的 start() 方法，然后线程会调用 Task 对象的 run() 方法执行任务。运行结果如下： 外卖任务 3: 您的外卖已送达外卖任务 1: 您的外卖已送达外卖任务 0: 您的外卖已送达外卖任务 2: 您的外卖已送达 可以看到执行任务的是各个线程。如果在 main() 方法中直接调用 run 方法，就相当于主线程直接执行任务，没有在子线程中进行。 直接在 main 中调用 run()：123456789public static void main(String[] args) &#123; for (int i = 0; i &lt; 4; i++) &#123; //2.创建一个送餐员线程，然后将任务传递给他，同时起个名 Task task = new Task(); Thread shixinzhang = new Thread(task, "外卖任务 " + i); //3.直接执行任务 task.run(); &#125;&#125; 运行结果： main: 您的外卖已送达main: 您的外卖已送达main: 您的外卖已送达main: 您的外卖已送达 2.继承 Thread，重写其 run 方法123456789101112131415161718192021222324252627282930public class ThreadTest1 &#123; /** * 继承 Thread，重写 run 方法，在 run 方法中写要执行的任务 */ static class DeliverThread extends Thread&#123; public DeliverThread(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; Thread.sleep(new Random().nextInt(300 )); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": 您的外卖已送达"); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 4; i++) &#123; //2.创建一个送餐员线程，同时起个名 DeliverThread shixinzhang = new DeliverThread("外卖任务" + i); shixinzhang.start(); &#125; &#125;&#125; 运行结果： 外卖任务1: 您的外卖已送达外卖任务3: 您的外卖已送达外卖任务0: 您的外卖已送达外卖任务2: 您的外卖已送达 为什么直接继承 Thread 也可以在子线程中执行任务呢？ 从 Thread 源码中我们可以看到， Thread 其实也实现了 Runnable ：public class Thread implements Runnable 它内部也有一个 Runnable 的引用，我们调用 start() 方法后送餐员小张就蓄势以待准备出发了，之所以没说“立即出发送餐”，是因为此时可能电动车（CPU）正在被别人使用。 线程 start() 后操作系统会给他分配相关的资源，包括单独的程序计数器（可以理解为送餐员的任务本，上面记录了当前送餐任务的地址和下一个任务的地址）和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行。 等线程被 CPU 调度后就会执行线程中的 run() 方法，因此我们通过重写 Thread 的 run() 方法就可以达到在子线程执行任务的目的。 3.实现 Callable 接口，重写 call() 方法，用 FutureTask 获得结果123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CallableTest &#123; /** * 实现 Callable 接口 */ static class DeliverCallable implements Callable&lt;String&gt; &#123; /** * 执行方法，相当于 Runnable 的 run, 不过可以有返回值和抛出异常 * @return * @throws Exception */ @Override public String call() throws Exception &#123; Thread.sleep(new Random().nextInt(10000)); System.out.println(Thread.currentThread().getName() + "：您的外卖已送达"); return Thread.currentThread().getName() + " 送达时间：" + System.currentTimeMillis() + "\n"; &#125; &#125; /** * Callable 作为参数传递给 FutureTask，FutureTask 再作为参数传递给 Thread（类似 Runnable），然后就可以在子线程执行 * @param args */ public static void main(String[] args) &#123; List&lt;FutureTask&lt;String&gt;&gt; futureTasks = new ArrayList&lt;&gt;(4); for (int i = 0; i &lt; 4; i++) &#123; DeliverCallable callable = new DeliverCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable); futureTasks.add(futureTask); Thread thread = new Thread(futureTask, "送餐员 " + i); thread.start(); &#125; StringBuilder results = new StringBuilder(); futureTasks.forEach(futureTask -&gt; &#123; try &#123; //获取线程返回结果，没返回就会阻塞 results.append(futureTask.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(System.currentTimeMillis() + " 得到结果：\n" + results); &#125;&#125; 第三种创建线程的方式与前两种的不同之处在于，以 Callable 作为任务，而不是 Runnable，这种方式的好处是可以获得结果和响应中断。 运行结果：123456789送餐员 3：您的外卖已送达 送餐员 1：您的外卖已送达 送餐员 0：您的外卖已送达 送餐员 2：您的外卖已送达 1487998155430 得到结果： 送餐员 0 送达时间：1487998155076 送餐员 1 送达时间：1487998150453 送餐员 2 送达时间：1487998155430 送餐员 3 送达时间：1487998149779 线程的基本属性1.优先级Thread 有个优先级字段：private int priority 操作系统采用时间片（CPU 单次执行某线程的时间）的形式来调度线程的运行，线程被 CPU 调用的时间超过它的时间片后，就会发生线程调度。 线程的优先级可以在一定程度上影响它得到时间片的多少，也就是被处理的机会。 Java 中 Thread 的优先级为从 1 到 10 逐渐提高，默认为 5。 有长耗时操作的线程，一般建议设置低优先级，确保处理器不会被独占太久；频繁阻塞（休眠或者 I/O）的线程建议设置高优先级。123456public final static int MIN_PRIORITY = 1;//线程的默认优先级public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程优先级只是对操作系统分配时间片的建议。虽然 Java 提供了 10 个优先级别，但不同的操作系统的优先级并不相同，不能很好的和 Java 的 10 个优先级别对应。&gt;所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。 2.守护线程Java 中，线程也分三六九等。守护线程相当于小弟，做一些后台调度、支持性工作,比如 JVM 的垃圾回收、内存管理等线程都是守护线程。 Thread 中有个布尔值标识当前线程是否为守护线程： private boolean daemon = false; 同时也提供了设置和查看当前线程是否为守护线程的方法： 1234567891011public final void setDaemon(boolean on) &#123; checkAccess(); if (isAlive()) &#123; throw new IllegalThreadStateException(); &#125; daemon = on;&#125;public final boolean isDaemon() &#123; return daemon;&#125; Daemon 属性需要在调用线程的 start() 方法之前调用。 一个进程中，如果所有线程都退出了，Java 虚拟机就会退出。注意了，这里的“所有”就不包括守护线程，也就是说，当除守护线程外的其他线程都结束后，Java 虚拟机就会退出，然后将守护进程终止。 这里需要注意的是，由于上述特性，Java 虚拟机退出后，在守护线程中的 finally 块中的代码不一定执行。 举个例子：1234567891011121314151617181920public class DaemonTreadTest0 &#123; static class DaemonThread extends Thread&#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(Thread.currentThread().getName() + " finally is called!"); &#125; &#125; &#125; public static void main(String[] args) &#123; DaemonThread thread = new DaemonThread(); thread.setDaemon(true); thread.start(); &#125;&#125; 上述代码中将线程设置为守护线程，由于 main 线程启动 DaemonThread 后就结束，此时虚拟机中没有非守护线程，虚拟机也会退出，守护进程被终止，但是它的 finally 块中的内容却没有被调用。 如果将setDaemon方法注释掉，就会发现有运行结果: Thread-0 finally is called! 因此，守护线程中不能依靠 finally 块进行资源关闭和清理。 线程的生命周期线程具有如下几个状态： 线程状态 介绍 备注 NEW 新创建 还未调用 start() 方法；还不是活着的 (alive) RUNNABLE 就绪的 调用了 start() ，此时线程已经准备好被执行，处于就绪队列；是活着的(alive) RUNNING 运行中 线程获得 CPU 资源，正在执行任务；活着的 BLOCKED 阻塞的 线程阻塞于锁或者调用了 sleep；活着的 WAITING 等待中 线程由于某种原因等待其他线程；或者的 TIME_WAITING 超时等待 与 WAITING 的区别是可以在特定时间后自动返回；活着的 TERMINATED 终止 执行完毕或者被其他线程杀死；不是活着的 有几点注意： Java 中的 Thread 运行状态没有 RUNNING 这一步，运行中的线程状态是 RUNNABLE 三个让线程进入 WAITING 状态的方法 Object.wait() Thread.join() LockSupport.park() Lock.lock() Java 中关于“线程是否活着”的定义 Thread 中有个判断是否为活着的方法：public final native boolean isAlive() Java 中线程除了 NEW 和 TERMINITED 状态，其他状态下调用 isAlive() 方法均返回 true，也就是活着的。 线程的关键方法1.Thread.sleep()Thread.sleep() 是一个静态方法： public static native void sleep(long millis) throws InterruptedException; sleep() 方法： 使当前所在线程进入阻塞 只是让出 CPU ，并没有释放对象锁 由于休眠时间结束后不一定会立即被 CPU 调度，因此线程休眠的时间可能大于传入参数 如果被中断会抛出 InterruptedException 注意上面的第一条！由于 sleep 是静态方法，它的作用时使当前所在线程祖舍。因此最好在线程内部直接调用 Thread.sleep()，如果你在主线程调用某个线程的 sleep() 方法，其实阻塞的是主线程！ 2.Object.wait()与 Thread.sleep() 容易混淆的是 Object.wait() 方法。 Object.wait() 方法： 让出 CPU，释放对象锁 在调用前需要先拥有某对象的锁，所以一般在 synchronized 同步块中使用 使该线程进入该对象监视器的等待队列 3.Thread.yield()Thread. yield() 也是一个静态方法： public static native void yield(); “Thread.yield() 表示暂停当前线程，让出 CPU 给优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程。 和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。 yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中。 yield() 一般使用较少。 4.Thread.join()Thread.join() 表示线程合并，调用线程会进入阻塞状态，需要等待被调用线程结束后才可以执行。 线程的合并的含义就是将几个并发执行线程的线程合并为一个单线程执行。 比如下述代码：1234567891011121314Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("thread is running!"); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);thread.start();thread.join();System.out.println("main thread "); 我们在主线程调用了 thread.join() 方法，该线程会在输出一句话后休眠 5 秒，等该线程结束后主线程才可以继续执行，输出最后一句结果： thread is running!main thread Thread.join 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//无参方法public final void join() throws InterruptedException &#123; join(0);&#125;//有参方法，表示等待 millis 毫秒后自动返回public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125;//有参方法，表示等待 millis + (nanos - 50000) 毫秒后结束public final synchronized void join(long millis, int nanos)throws InterruptedException &#123; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123; millis++; &#125; join(millis);&#125; 通过源码可以发现，Thread.join 是通过 synchronized + Object.wait() 实现的。 Thread.join 的应用场景是：当一个线程必须等待其他线程执行完毕才能继续执行，比如合并计算。 线程的中断有时候我们需要中断一个正在运行的线程，一种很容易想到的方法是在线程的 run() 方法中加一个循环条件： 1234567891011121314151617181920212223242526272829303132public class ThreadInterruptTest1 &#123; static class InterruptThread extends Thread&#123; private boolean running; public InterruptThread(boolean running) &#123; this.running = running; &#125; public boolean isRunning() &#123; return running; &#125; public void setRunning(boolean running) &#123; this.running = running; &#125; @Override public void run() &#123; while (running)&#123; System.out.println(Thread.currentThread().getName() + " is running"); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; InterruptThread thread = new InterruptThread(true); thread.start(); Thread.sleep(5000); thread.setRunning(false); &#125;&#125; 上面的代码中线程 InterruptThread 有一个标志位 running，当这个标志位为 true 时才可以运行。因此我们可以通过修改这个标志位为 false 来中断该线程。 其实 Thread 内部也为我们提供了同样的机制 ： 方法名 方法介绍 public void interrupt() 试图中断调用线程，设置中断标志位为 false public boolean isInterrupted() 返回调用线程是否被中断 public static boolean interrupted() 返回当前线程是否被中断的状态值，同时将中断标志位复位（设为 false） 1.public void interrupt()它的作用是设置标志位为 false，能否达到中断调用线程的效果，还取决于该线程是否可以响应中断（说直白些就是吃不吃这套），比如 Runnable 的 run() 方法就无法响应中断。 因此我们对执行 Runnable 任务的线程调用 interrupt() 方法后，该线程也不会中断，举个例子：123456789101112131415161718192021222324252627282930313233343536373839public class ThreadInterruptTest2 &#123; static class UnInterruptThread extends Thread&#123; public UnInterruptThread(String s) &#123; setName(s); &#125; @Override public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + " is running!"); &#125; &#125; &#125; static class UnInterruptRunnable implements Runnable&#123; @Override public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + " is running!"); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; UnInterruptThread thread = new UnInterruptThread("无法中断的线程");// Thread thread = new Thread(new UnInterruptRunnable(), "无法中断"); thread.start(); //先让它执行一秒 Thread.sleep(1000); thread.interrupt(); //不立即退出 Thread.sleep(3000); &#125;&#125; 这两种方式创建的线程，在调用 thread.interrupt() 方法后仍然会继续执行！ 这时就需要用到上面 Thread 提供的第二个关于中断的方法 isInterrupted() 了。 2.public boolean isInterrupted()我们可以通过 isInterrupted() 知道调用线程是否被中断，以此来作为线程是否运行的判断标志。 isInterrupted() 在刚创建时默认为 false 不用多说；线程有许多方法可以响应中断（比如 Thread.sleep()，Thread.wait()），这些方法在收到中断请求、抛出 InterruptedException 之前，JVM 会先把该线程的中断标志位复位，这时调用 isInterrupted 将会返回 false；线程结束后，线程的中断标志位也会复位为 false。 举个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 线程中断练习 * Created by zhangshixin on 17/2/25. * http://blog.csdn.net/u011240877 */public class ThreadInterruptTest &#123; /** * 调用 Thread.sleep() 方法的线程，线程如果在 sleep 时被中断，会抛出 InterruptedException * 我们在代码中进行捕获，并且查看 JVM 是否将中断标志位重置 */ static class SleepThread extends Thread&#123; public SleepThread(String s) &#123; setName(s); &#125; @Override public void run() &#123; while (!isInterrupted())&#123; try &#123; Thread.sleep(500); System.out.println(Thread.currentThread().getName() + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println("SleepRunner 在 sleep 时被中断了，此时中断标志位为：" + isInterrupted()); &#125; &#125; &#125; &#125; /** * 希望通过这个线程了解：线程运行结束后，中断标志位会重置 */ static class BusyThread extends Thread&#123; public BusyThread(String s) &#123; setName(s); &#125; @Override public void run() &#123; while (!isInterrupted())&#123; System.out.println(Thread.currentThread().getName() + System.currentTimeMillis()); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; SleepThread sleepThread = new SleepThread("SleepRunner："); BusyThread busyThread = new BusyThread("BusyRunner："); //新创建的线程 中断标志为 false System.out.println("SleepThread 新创建时的中断标志位：" + sleepThread.isInterrupted()); Thread.sleep(2000); //启动两个线程 sleepThread.start(); busyThread.start(); //让它们运行一秒 Thread.sleep(1000); //分别中断两个线程 sleepThread.interrupt(); busyThread.interrupt(); //查看线程的中断标志位 Thread.sleep(2000); System.out.println("由于中断标志位变为 true 导致运行结束的线程，中断标志位为: " + busyThread.isInterrupted()); Thread.sleep(1000); &#125;&#125; 上述代码中 两个线程都使用 isInterrupted 作为循环执行任务的条件，其中 SleepThread 方法调用了 Thread.sleep，这个方法的会响应中断，抛出异常。 运行结果如下： 可以看到： 线程中，在抛出 InterruptedException 前 JVM 的确会重置中断标志位为 false 这将导致以 isInterrupted 方法作为循环执行任务的线程无法正确中断 3.public static boolean interrupted()Thread.interrupted() 方法是一个静态方法，它会返回调用线程（而不是被调用线程）的中断标志位，返回后重置中断标志位。 因此 Thread.interrupted() 第二次调用永远返回 false。 源码：123public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125; 总结这篇文章总结了 线程的基本概念和关键方法，还有一些不建议使用的方法没有介绍，是因为它们有很多副作用，比如 suspend() 方法在调用后虽然线程会进入休眠状态，却不会释放资源，很容易引发死锁问题；同样，stop() 方法终结一个线程时无法保证这个线程有机会释放资源，也会导致一些不确定问题。 我们可以通过下面的图片整体分析线程的生命周期和主要方法：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android MVP模式]]></title>
      <url>%2F2017%2F02%2F04%2Fandroid-mvp%2F</url>
      <content type="text"><![CDATA[MVP 这种模式出现已经很久了，在网上有些关于 MVP 开源代码2014年就有了。近期由于面试都有问这方面的问题，所以来了解一下。网上关于 MVP 的资料其实也不少，通常都要把 MVP 和 MVC 做一下比较，MVC通常一般都会应用，这篇文章就来学习下MVP模式。 一、什么是MVP？随着UI创建技术的功能日益增强，UI层也履行着越来越多的职责。为了更好地细分视图(View)与模型(Model)的功能，让View专注于处理数据的可视化以及与用户的交互，同时让Model只关系数据的处理，基于MVC概念的MVP(Model-View-Presenter)模式应运而生。MVP 是 Model、Presenter、View 的缩写，三个部分的关系如下图所示。 在 Android 项目中，负责界面展示的模块（所有的 Activitiy 、Fragment以及 View 的子类）都可以划分到 View 这个层次，所有的业务逻辑处理（请求网络数据、数据库读取等）可以划分到 Model 这个层次，为了使得 View 和 Model 之间松耦合，用 Presenter 帮助解耦。所以可以猜测，在具体实现中 Presenter 类肯定要持有 View 和 Model 的引用。现在来说一下，上图中三个箭头的意思。流程是这样子的，从左到右看，比如我们刚进入一个 Activity，那么这个 Activity 做为 View 层，肯定需要通知 Presenter 加载数据，而Presenter会继续调用Model层加载数据，等Model加载完毕后，回调给 Presenter，Presenter 持有View引用，再通知View更新界面。 MVP模式的三个角色的作用： Presenter-中介主演沟通View和Model的桥梁，他从Model获取数据后返回给View层，是的View层和Model层之间没有耦合，从而奖业务逻辑从View层抽离。 Model-房主Model主要提供数据的存取、检索、操纵功能，Presenter需要通过Model层存储、获取数据，Model层就想是一个仓库。 View-用户负责绘制UI元素、与用户进行交互(在Android中体现为Activity)。View通常是指Activity、Fragment或者某个View控件。它含有一个Presenter成员变量，同时它需要实现一个逻辑接口，奖View上的操作转交割Presenter进行实现，最后Presenter调用View逻辑接口将结果返回给View元素。 View interface需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试; 为什么使用MVP模式在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由Presenter处理）.另外，回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明了什么？说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。 MVP与MVC的异同MVC模式与MVP模式都作为用来分离UI层与业务层的一种开发模式被应用了很多年。在我们选择一种开发模式时，首先需要了解一下这种模式的利弊：无论MVC或是MVP模式都不可避免地存在一个弊端： 额外的代码复杂度及学习成本。这就导致了这两种开发模式也许并不是很小型应用。但比起他们的优点，这点弊端基本可以忽略了： (1)降低耦合度 (2)模块职责划分明显 (3)利于测试驱动开发 (4)代码复用 (5)隐藏数据 (6)代码灵活性 MVP模式： View不直接与Model交互，而是通过与Presenter交互来与Model间接交互 Presenter与View的交互是通过接口来进行的，更有利于添加单元测试 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑 MVC模式： View可以与Model直接交互 Controller是基于行为的，并且可以被多个View共享 可以负责决定显示哪个View 二、MVP的效果现在我们来实现这样一个Android上的Demo(如图)：可以从EditText读取用户信息并存取，也可以根据ID来从后台读出用户信息并显示。 页面布局很简单，就不介绍了。下面根据MVP原则来进行编码：先来看看java文件的目录结构： 可以发现，Presenter与Model、View都是通过接口来进行交互的，既降低耦合也方便进行单元测试。 (1)首先我们需要一个UserBean，用来保存用户信息 1234567891011121314public class UserBean &#123; private String mFirstName ; private String mLastName ; public UserBean (String firstName, String lastName) &#123; this.mFirstName = firstName; this.mLastName = lastName; &#125; public String getFirstName() &#123; return mFirstName ; &#125; public String getLastName() &#123; return mLastName ; &#125;&#125; (2)再来看看View接口：根据需求可知，View可以对ID、FirstName、LastName这三个EditText进行读操作，对FirstName和LastName进行写操作，由此定义IUserView接口： 1234567public interface IUserView &#123; int getID(); String getFristName(); String getLastName(); void setFirstName (String firstName); void setLastName (String lastName); &#125; (3)Model接口：同样，Model也需要对这三个字段进行读写操作，并存储在某个载体内(这不是我们所关心的，可以存在内存、文件、数据库或者远程服务器，但对于Presenter及View无影响),定义IUserModel接口： 1234567public interface IUserModel &#123; void setID (int id); void setFirstName (String firstName); void setLastName (String lastName); int getID(); UserBean load (int id);//通过id读取user信息,返回一个UserBean &#125; (4)Presenter:至此，Presenter就能通过接口与View及Model进行交互了： 123456789101112131415161718192021public class UserPresenter &#123; private IUserView mUserView ; private IUserModel mUserModel ; public UserPresenter (IUserView view) &#123; mUserView = view; mUserModel = new UserModel (); &#125; public void saveUser( int id , String firstName , String lastName) &#123; mUserModel .setID (id ); mUserModel .setFirstName (firstName ); mUserModel .setLastName (lastName ); &#125; public void loadUser( int id ) &#123; UserBean user = mUserModel .load (id ); mUserrView .setFirstName (user .getFirstName ());//通过调用IUserView的方法来更新显示 mUserView .setLastName (user .getLastName ()); &#125; &#125; (5)UserActivity:UserActivity实现了IUserView及View.OnClickListener接口，同时有一个UserPresenter成员变量： 123456public class UserActivity extends Activity implements OnClickListener, IUserView &#123; private EditText mFirstNameEditText , mLastNameEditText , mIdEditText ; private Button mSaveButton , mLoadButton ; private UserPresenter mUserPresenter ; 重写了OnClick方法：123456789101112131415@Override public void onClick(View v) &#123; // TODO Auto-generated method stub switch ( v. getId()) &#123; case R .id .saveButton : mUserPresenter .saveUser (getID (), getFristName (), getLastName ()); break ; case R .id .loadButton : mUserPresenter .loadUser (getID ()); break ; default : break ; &#125; &#125; 可以看到，View只负责处理与用户进行交互，并把数据相关的逻辑操作都扔给了Presenter去做。而Presenter调用Model处理完数据之后，再通过IUserView更新View显示的信息。 三、MVP的Android伪代码实现 首先需要一个Presenter，作为View和Model的中间人 然后你还需要一个View以及ViewImpl接口 最后你还需要Model一个ModelImpl接口 四、不必纠结是MVC还是MVP MVC和MVP的最终目的就是要数据和UI分离，互相不影响。那么如何能不必纠结而做到呢？？你听说过面向对象吗？听过再听听我的理解~ 面向对象封装、多态，继承。老师好像也都是这么教的，那么到底说明是多态封装继承呢？ 封装封装就是将用户不想看到的东西封装起来，可以用到面向对象中的 Private属性，将用户不想看到的内容写在这里面。比如收音机上的播放功能，用户不用知道收益及如何播放，它只需要知道摁下这个键能播放即可。 多态多态就是一个对象的多种表现形态，主要表现为：行为多态和状态多态。行为多态就好比一个父亲有多个孩子，每个孩子都不一样，但是都是同一个父亲；状态多态就好比每个孩子在一天中有好多个状态变现，有吃饭，学习，睡觉。 继承？不！我想说的是对象！我的一个朋友告诉我继承其实是对面向对象的最大误解。继承我们可以理解成一个对象他有多个小对象组成；比如人这个对象是由手脚，脑袋…等其它小对象组成。因此继承我们可以不去记住，我们只要对每个对象有深刻的认识即可把对象描述清楚！ 那么MVC、MVP与面向对象有什么关系呢？？ 首先MVC和MVP都是要求数据和UI之间互不影响，那么面向对象不就是吗！？ 面向对象View?对象也就是我们说的用户也就是MC或者MVP中View，用户需要什么我们就展示给其什么，不需要的我们将其封装起来提供一个方法给你调用即可，这是不是和MVC或者MVP中很像！ 面向对象Model?同时面向对象也是需要将对象的行为细分，比如人可以跑，可以游泳…这是不是和MVC中的Model一样，需要处理用户不同的操作。 面向对象Controller?最后面向对象也是需要一个状态去控制的，比如人的大脑。通过大脑去协调手和脚的平衡。 五、内存泄露问题由上可见，Presenter中持有View接口对象，这个接口对象实际为MainActivity.this，Modle中也同时拥有Presenter对象实例，当MainActivity要销毁时，Presenter中有Modle在获取数据，那么问题来了，这个Activity还能正常销毁吗？ 答案是不能！ 当Modle在获取数据时，不做处理，它就一直持有Presenter对象，而Presenter对象又持有Activity对象，这条GC链不剪断，Activity就无法被完整回收。换句话说：Presenter不销毁，Activity就无法正常被回收。 解决MVP的内存泄露 Presenter在Activity的onDestroy方法回调时执行资源释放操作，或者在Presenter引用View对象时使用更加容易回收的软引用，弱应用。比如示例代码：Activity123456@Override public void onDestroy() &#123; super.onDestroy(); mPresenter.destroy(); mPresenter = null; &#125; Presenter1234567public void destroy() &#123; view = null; if(modle != null) &#123; modle.cancleTasks(); modle = null; &#125;&#125; Modle123public void cancleTasks() &#123; // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api&#125; 个人总结 因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！ 六、总结最后重新梳理一下 MVP 的编写方式。 1、 根据项目需求，写一个 XXView 接口。然后让对应的 Activity/Fragment 实现这个接口。View 层基本搞定！ 2、编写 Model 层，主要就是网络数据请求了或者其他什么耗时操作，实现方式尽情发挥你的想象，但是最后一定需要用 Presenter 层定义的接口，回调给 Presenter 通知 View 层 更新数据。 3、编写 Presenter 层，Presenter 层需要持有 View 层和 Model层的引用，并且实现 Presenter 层定义的回调接口。在回调接口中调用 View 层的代码 进行界面更新，最重要的是，有一个调用通过Model层的方法，在此方法中，调用 Model 层请求数据。 4、回到View 层的Activity ，调用 Presenter 层获取数据。到此完成。 因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！备注：为了遵守面向接口编程的原则，做了一下接口的抽取。如Presenter 中 实现了 JokePresenter 接口，Model 层中实现了 JokeModel 接口。好了，如果在阅读中，发现了有错误的地方，还望指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Wi-Fi 直连]]></title>
      <url>%2F2017%2F02%2F02%2Fandroid-wifi%2F</url>
      <content type="text"><![CDATA[Android Wi-Fi 直连Wi-Fi直连是Android 4.0(API level 14)或更高的版本的才加入的新功能，使用Wi-Fi直连相关的API可以发现并连接支持Wi-Fi直连的设备，连接之后设备之间可以通信，传输的距离比蓝牙的传输距离要远很多 API 概述 Wi-Fi直连的方法类WifiP2pManager提供了一些方法来使用Wi-Fi直连的相关的接口来发现连接设备 方法 描述 initialize() 在Wi-Fi框架中注册，必须在其他方法之前调用 connect() 和另外的直连设备连接 cancelConnect() 取消正在连接的动作 requestConnectInfo() 请求已经连接的信息 createGroup() 创建直连的设备组 removeGroup() 删除当前的设置组 requestGroupInfo() 请求当前组的信息 discoverPeers() 初始化搜索 requestPeers() 请求已经发现的设备的列表 Wi-Fi直连的监听类WifiP2pManager中也提供了很多的监听接口，计时的通知当前的 activity相关的搜索和连接的结果 接口 相关的操作 WifiP2pManager.ActionListener 相关的操作：connect(), cancelConnect(), createGroup(), removeGroup(), and discoverPeers() WifiP2pManager.ChannelListener 相关的操作：initialize() WifiP2pManager.ConnectionInfoListener 相关的操作：requestConnectInfo() WifiP2pManager.GroupInfoListener 相关的操作：requestGroupInfo() WifiP2pManager.PeerListListener 相关的操作：requestPeers() Wi-Fi直连的Intent Intent 描述 WIFI_P2P_CONNECTION_CHANGED_ACTION 当设备的Wi-Fi的连接状态发生变化时触发 WIFI_P2P_PEERS_CHANGED_ACTION 在调用discoverPeers()时触发，可以调用requestPeers()方法更新设备列表 WIFI_P2P_STATE_CHANGED_ACTION Wi-Fi直连的状态发生变化时触发 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION Wi-Fi直连的设备的详细信息发生变化时触发 创建Wi-Fi直连的应用 初始化设置首先要保证设置支持Wi-Fi直连相关的协议，如果支持，我们就可以获得WifiP2pManager的实例，创建并注册相关的广播，使用相关的api在AndroidManifest中必须声明相关的权限,Wi-Fi直连是在api level 14及更高的版本才能使用，还要声明android:minSdkVersion=&quot;14&quot; 123456&lt;uses-sdk android:minSdkVersion=&quot;14&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 初始化WifiP2pManager的实例，并注册相关的广播，监听Wi-Fi直连的状态 1234567891011121314151617181920212223242526272829303132333435private WifiP2pManager mManager;private Channel mChannel;private IntentFilter directFilter;private WiFiDirectReceiver directReceiver ;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mManager = (WifiP2pManager)this.getSystemService(Context.WIFI_P2P_SERVICE); mChannel = mManager.initialize(this, this.getMainLooper(), null); directReceiver = new WiFiDirectReceiver(mManager, mChannel, this); directFilter = new IntentFilter(); directFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION); directFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION); directFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION); directFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);&#125;//注册广播监听@Overrideprotected void onResume() &#123; super.onResume(); this.registerReceiver(directReceiver, directFilter);&#125;//取消注册@Overrideprotected void onPause() &#123; super.onPause(); this.unregisterReceiver(directReceiver);&#125; 广播接受 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class WiFiDirectReceiver extends BroadcastReceiver&#123; private WifiP2pManager mManager; private Channel mChannel; private MainActivity mActivity; private PeerListListener mListener; private WifiP2pConfig mConfig = new WifiP2pConfig(); public WiFiDirectReceiver()&#123;&#125; public WiFiDirectReceiver(WifiP2pManager manager,Channel channel,MainActivity activity)&#123; this.mManager = manager; this.mChannel = channel; this.mActivity = activity; &#125; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); Log.e("tag", "===============wifi direct action: "+action); if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION))&#123; int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1); if(state == WifiP2pManager.WIFI_P2P_STATE_ENABLED)&#123; //打开 &#125;else if(state == WifiP2pManager.WIFI_P2P_STATE_DISABLED)&#123; //关闭 &#125; &#125;else if(action.equals(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION))&#123; &#125;else if(action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION))&#123; &#125;else if(action.equals(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION))&#123; &#125; &#125;&#125;``` - 发现设备在调用之后initialize()方法之后，会触发`WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION`的广播，在BroadcastReceiver中，如果WifiP2pManager.WIFI_P2P_STATE_ENABLED的状态已经打开，在BroadcastReceiver调用discoverPeers方法,如果发现设备.会回调onSuccess方法 ``` javamManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() &#123;@Override public void onSuccess() &#123; Log.e("tag", "===================discovery success"); &#125; @Override public void onFailure(int reason) &#123; Log.e("tag", "===================discovery failed"); &#125;&#125;); 如果发现设备，系统会触发WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION这个广播，在这个广播中可以调用requestPeers方法可以列出所有的设备 1234567891011if(null != mManager)&#123; mManager.requestPeers(mChannel, new WifiP2pManager.PeerListListener() &#123; @Override public void onPeersAvailable(WifiP2pDeviceList peers) &#123; Log.e("tag", "==================peers list size: "+peers.getDeviceList().size()); for(WifiP2pDevice device: peers.getDeviceList())&#123; Log.e("tag", "==================device addr: "+device.deviceName+" name: "+device.deviceName); &#125; &#125; &#125;);&#125; 连接设备对于已经发现的设备我们可以调用connect()方法连接，需要初始化WifiP2pConfig,并设置config的deviceAddress 123456789101112private WifiP2pConfig mConfig = new WifiP2pConfig(); mConfig.deviceAddress = device.deviceAddress;mManager.connect(mChannel, mConfig, new WifiP2pManager.ActionListener() &#123; @Override public void onSuccess() &#123; Log.e("tag", "==============connnect success"); &#125; @Override public void onFailure(int reason) &#123; Log.e("tag", "=================connect failed"); &#125;&#125;); 连接成功会回调onSuccess方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 权限机制]]></title>
      <url>%2F2017%2F01%2F31%2Fandroid-permissions%2F</url>
      <content type="text"><![CDATA[一、概要Android M已经发布一段时间了，市面上很多应用都已经适配Android M。权限机制，作为Android M的一大特性，受到了很多开发者的关注。本文主要分享了以下几个知识点的内容，1、Android权限机制关键知识点；2、QQ音乐对于权限的适配经验；3、近段时间以来遇到的一些Android权限方面的问题。OK，下面进入主题。 二、Android权限机制已经了解过基本知识的，建议直接跳到第三点（QQ音乐的权限适配经验）。 Android6.0以前，Android的权限机制比较简单，开发者在AndroidManifest文件中声明需要的权限，APP安装时，系统提示用户APP将获取的权限，需要用户同意授权才能继续安装，从此APP便永久的获得了授权。然而，同期的iOS对于权限的处理会更加灵活，权限的授予并不是在安装时，而是在APP运行时，用户可以根据自身的需要，决定是否授予APP某一权限，同时，用户也可以很方便回收授予的权限。显然，动态权限管理的机制，对于用户的隐私保护是更加适用的，Android过于简单的权限机制也受到了不少人的吐槽。终于，Android6.0也发布了动态权限的机制。 开始适配和如何兼容APP要适配Android6.0非常简单，只需要将targetSdkVersion和compileSdkVersion都升级到23及以上，同时加入权限检查申请等代码逻辑即可。这里很多人会有一些疑惑，如果针对旧版本的APP在Android6.0机型上运行或者针对Android6.0适配了的APP在Android6.0以下机型上运行，会有什么表现呢？是如何兼容的呢？ 1、首先，旧版本APP（targetSdkVersion低于23），因为没有适配权限的申请相关逻辑，在Android6.0以上机型运行的时候，仍然采用安装时授权的方案。 2、适配了Android6.0的APP，在低版本Android系统上运行的时候，仍然采用安装时授权的方案，但是开发者需要注意的是，权限申请的代码逻辑只应该在Android6.0及以上的机型被执行。 危险权限与普通权限一开始，听到要加入权限判断和申请代码逻辑的程序员内心可能是崩溃的：正常的一个有一定规模的APP，很容易就七七八八的声明了很多权限，如果每个权限都申请岂不是非常麻烦？ 好歹，Google还算比较明智，并不是所有的权限都需要运行时申请才能使用。Google对每个权限的隐私危害性进行了评估。将权限分为了两大类：普通权限和危险权限。举个例子，控制手机震动的权限对于用户并没有什么危害，只要开发者声明了这个权限，安装后就可以一直被授权，也不能被回收，但是，像读取sd卡数据这类权限，很显然就是危险权限了，APP必须向用户申请这个权限。 Google还是很体贴我们开发者的，为了进一步减少开发的工作量和申请权限对用户的骚扰，对危险权限根据各自的属性进行了分组。举个例子，读sd卡和写sd卡，这两个权限通常都是成对声明和使用的，因此，它们被分为一组，而且，只要我们获取了这个权限组里面的任意一个权限，就可以获取整个权限组的权限。Google对于危险权限的定义和分组见下图。 权限相关API说明首先，在动态权限申请的流程中，开发者主要关注流程和API如下： 1、检查权限是否授予。Activity.javapublic int checkSelfPermission(permission) 2、申请权限。Activity.javapublic final void requestPermissions( new String[permission1,permission2,...], requestCode) 这个时候，会弹出系统授权弹窗（授权弹窗是不支持自定义的，原因理所当然）。 3、权限回调。用户在系统弹窗里面选择后，结果会通过Activity的onRequestPermissionsResult方法回调APP。123public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; //继续执行逻辑或者提示权限获取失败&#125; 4、权限说明。用户如果选择了拒绝，下一次在需要声明该权限的时候，Google建议APP开发者给予用户更多的说明，因此提供了下面这个API,这个方法返回值在使用过程中会发现有点纠结（具体解析见下面代码块说明）。1234567public boolean shouldShowRequestPermissionRationale(permission)&#123; 1、APP没有申请这个权限的话，返回false 2、用户拒绝时，勾选了不再提示的话，返回false 3、用户拒绝，但是没有勾选不再提示的话，返回true 因此如果想在第一次就给用户提示，需要记录权限是否申请过，没有申请过的话，强制弹窗提示，而不能根据这个方法的返回值来。&#125; 三、QQ音乐的权限适配经验1、不同权限，申请的时机不同QQ音乐作为一个比较复杂的流媒体应用，也需要不少权限，但是究竟在什么时候来申请这些权限就成了适配6.0时首当其冲问题。针对这个问题，我们也对需要的权限进行了思考，大致认为申请权限需要分为两个时机。 用户触发：这个很好理解，有些和特性相关的权限，比如说听歌识曲的录音权限、自建歌单封面拍照权限等，这类权限平时APP运行时并不需要，那么我们选择在用户触发或者进入该功能的时候，进行授权受阻逻辑。 应用启动时：我们在梳理的时候发现，有些权限（读取设备信息，读写sd卡等）并不是由用户或者特性触发的，而是网络免流，登录安全，日志系统这些底层逻辑无时不刻触发的。对于这些权限，就比较纠结了。不过回过头来看，这些权限通常是开发者或者APP不能妥协的权限，因为如果用户不授权的话，将会影响整个APP的功能和数据。所以，我们选择比较暴力的方式，在应用启动的时候，就受阻。这也是Google建议的一种方式。 但是需要注意的是，一开始就申请授权也不要冷冰冰地直接拉起系统弹窗授权，建议先用APP自己的弹窗向用户礼貌地说明为什么需要这几个权限，比如，读取不到设备信息无法联通免流，无法保证登录安全，读取不到SD卡无法播放歌曲等，避免太生硬引起用户的反感。特别是，因为本地化翻译的原因，Google对于权限的弹窗说明很不local，例如我们申请读取设备信息的权限时，系统的弹窗是“电话权限”，这里很容易引起用户的误解，所以，合理的引导和解释是必不可少的。 2、应用启动授权，需要一个壳刚刚已经说到了，很多隐形的权限和特性无关。那么，如果我们直接启动APP，用户又还没有授权的情况下，很多初始化逻辑很容易就因为没有权限crash了，即使没有crash，后面也可能会有或多或少其他的问题。因此，我们需要在这些权限完全授予前，禁止这些逻辑的执行。 做过启动相关的同学都知道，拦截一个APP正常的启动后面再恢复，是很复杂的一件事情，往往我们需要一个外壳来把业务逻辑的内壳隔绝开。就QQ音乐而言，我们很容易的就想到了dex加载的壳，需求也很类似，dex加载也需要优先于业务来做。顺着这个思路，很自然地，我们就选择了在dex的壳里面做权限的受阻逻辑，而且也很快很好的达到了预期的效果。相信现在大部分APP都是分dex的了，因此建议按照这个方式来做，可以节省很多的工作量。 四、Android权限机制“乱象”这里要说的乱象，其实是和Android严重的碎片化有一定的关系。随着国产ROM越来越个性，很多ROM在尝试建立自己的权限机制，有些甚至基于Android5.x就开放了原生的或者开发了自己的权限机制。而面对这些情况，我们往往能做的非常有限，举几个例子。 1、读取运动数据权限开发QQ音乐跑步电台的过程中发现，在某国产ROM的一些机型上会提示“应用读取运动数据权限”的系统弹窗。可是，反复查阅相关API发现，我们使用的计步相关的Sensor并不需要申请什么权限。可如果用户选择了拒绝，即使APP注册了Sensor，也收不到系统的回调。后来联系该厂商的相关人员后，给出的答复是，第三方APP无法检查和申请这个权限，这个权限本身也属于该厂商ROM自己的权限机制。 类似的案例还有一个，就是在某厂商的手机管家，会一直提示QQ音乐尝试读取应用程序列表。其实，我们并没有读取应用程序列表，只是调用了PackageManager相关的一些API，就是触发这个告警。 对于这类问题，我们怀疑，第三方ROM是在运行时检测到了APP调用了相关的API后，进行权限阻断。这里开发同学需要注意的是，被阻断的API不一定会导致crash，但是可能导致我们获取不到正确的返回值或者收不到系统的一些消息回调。 2、无法添加快捷方式本来&lt;uses-permission android:name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot;/&gt;声明后，我们就可以在桌面上创建快捷方式了，而且这个权限也不是危险权限。可是某些国产ROM，对于APP添加快捷方式限制的比较严，必须要用户在设置里面手动允许添加快捷方式后，APP才能最终成功的添加。这种情况，APP也不能知道是否能添加快捷方式，只能默默的添加失败了。不过好在这里受影响并不是主快捷方式，而且某些功能的快捷方式入口。 3、消失的桌面歌词，悬浮窗权限QQ音乐桌面歌词采用了向WindowManager里面添加View的方式实现。可是很多国产ROM很早就具备了悬浮窗权限。一开始，我们将type改为LayoutParams.TYPE_TOAST同时声明&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;这个普通权限，躲避了大多数系统的问题。可是，2016年底，随着某ROM系统的升级，这一招也没用了，大批用户反馈爆发。 我们继续尝试检测悬浮窗权限，发现checkPermission（&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;）返回的结果永远是true，因此这条路也走不通。 最终，经过各种查阅，发现这个悬浮窗权限并不在Android6.0标准的权限机制内，而是AppOpsManager里面已经被隐藏了的一个开关位，对应于第24个开关。需要注意的是，AppOpsManager这个类很早就有了，但是很多ROM隐藏了checkOp的方法，好在最后发现通过反射仍旧可以调用这个方法检测权限是否打开。 AppOpsManager manager = (AppOpsManager) context.getSystemService("appops"); try { Object object = invokeMethod(manager, "checkOp", op, Binder.getCallingUid(), getPackageName(context)); return AppOpsManager.MODE_ALLOWED == (Integer) object; } catch (Exception e) { MLog.e(TAG, "CheckPermission " + e.toString()); } 不过，要打开悬浮窗权限，不同ROM的路径还不一样，有的是在设置里面，有的是在系统自带的管家里面，最后我们只能根据不同的ROM，给予用户不同的引导，终于将反馈量降了下去。 转载自Android权限机制与适配经验]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 存储方式以及路径API]]></title>
      <url>%2F2017%2F01%2F31%2Fandroid-save-method%2F</url>
      <content type="text"><![CDATA[首先说一句,平时说的存储分成了内部存储和外部存储。注意内部存储又叫做机身内存，而且内存又包含了两个部分RAM(运行时内存,这个和运行速度有关系，是手机运行时存储数据和指令的地方)、ROM(这个才算是真正存储东西的内部存储范围，是应用配置和其他数据的地方);而外部存储就很明确了,用户的外部挂载存储设备,如SD卡,手机的内部存储卡。 来介绍几个概念: 一、内存全称内部存储,英文名(InternalStorage)。当我们在打开DDMS下的File Explorer面板的时候，/data目录就是所谓的内部存储 (ROM )。但是注意，当手机没有root的时候不能打开此文件夹。当打开data文件夹的时候，目录结构如下: 这里一般都是关注两个最重要的文件夹: app文件夹里存放着我们所有安装的app的apk文件，并且当我们调试一个app的时候，可以看到控制台输出的内容，有一项是uploading …..就是上传我们的apk到这个文件夹，上传成功之后才开始安装。这里写图片描述 第二个文件夹是data,也就是我们常说的/data/data目录(存储包私有数据)。此目录下将每一个APP的存储内容按照包名分类存放好。比如: data/data/包名/shared_prefs 存放该APP内的SP信息 data/data/包名/databases 存放该APP的数据库信息 data/data/包名/files 将APP的文件信息存放在files文件夹 data/data/包名/cache 存放的是APP的缓存信息 多扯一句,下面的代码就会在files文件夹先创建一个hello_file文件并写入了数据:12345String FILENAME = "hello_file";String string = "hello world!";FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_APPEND|Context.MODE_WORLD_READABLE);fos.write(string.getBytes());fos.close(); 二、外存/storage/sdcard/Android/data目录或者说/storage/emulated/0/Android/data包目录属于外部存储。比如我们的内部存储卡。注意,Google官方建议开发者将App的数据存储在私有目录即/storage/emulated/0/Android/data包下，这样卸载App时数据会随之被系统清除，不会造成数据残留。 除了/data之外的存储目录 /mnt:这个目录专门用来当作挂载点(MountPoint)。通俗点说,/mnt就是来挂载外部存储设备的(如sdcard),我们的sdcard将会被手机系统视作一个文件夹,这个文件夹将会被系统嵌入到收集系统的mnt目录 /dev包:Linux系统的常规文件夹。 /system包:系统配置的文件夹，比如Android系统框架（framework）、底层类库（lib）、字体（font）等。 1、下面说一下路径API和对以上的文件的操作:context.getFilesDir().getAbsolutePath()context.getFilesDir().getPath() 上面的两个API都是得到应用程序私有目录下的文件路径:/data/data/包名/files 2、context.getCacheDir().getPath()取得应用程序的缓存文件在内部存储上的存储路径/data/data/包名/cache 3、context.getExternalCacheDir().getAbsolutePath()和context.getExternalCacheDir().getCanonicalPath()取得应用程序的缓存文件在外部存储上的存储路径/storage/sdcard/Android/data/包名/cache 4、context.getObbDir().getAbsolutePath()取得外部存储obb目录的根路径/storage/sdcard/Android/obb/包名 5、Environment.getExternalStorageState()得到外部存储卡(sdcard)的存储状态mounted 6、Environment.getExternalStorageDirectory().getAbsolutePath()得到外部存储的整个根路径/storage/sdcard 7、Environment.getDownloadCacheDirectory().getAbsolutePath()得到外部存储的下载文件的缓存路径/cache 8、Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getAbsolutePath()得到外部存储的图片的根路径/storage/sdcard/Pictures 9、Environment.getRootDirectory().getAbsolutePath()/system 10、Environment.getDataDirectory().getAbsolutePath() /data 最后总结一下: 内部数据：/data/data/包名/XXX 外部私有数据：/storage/emulated/0/Android/data/包名/XXX 外部公有数据：/storage/emulated/0/包名/XXX 当用应用管理来清除数据的时候: 清除缓存：将外部私有数据下的cache包（/storage/emulated/0/Android/data/包名/cache）清除，将内部数据下的cache包下的内容（/data/data/包名/cache/XXX）清除 。 清楚数据：将外部私有数据包（/storage/emulated/0/Android/data/包名）清除，将内部数据下的所有内容（/data/data/包名/XXX）清除；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 响应式编程的应用]]></title>
      <url>%2F2017%2F01%2F30%2Fandroid-responsive-code%2F</url>
      <content type="text"><![CDATA[响应式编程简介 响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。 响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们更改电子表（变化的传播）中的一些数值时，我们需要更新整个表格或者我们的机器人碰到墙时会转弯（响应事件）。 今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。 响应式编程的具体实现-RxJava基本概念RxJava的四种角色 Observable Observer Subscriber Subject Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。 热Observable和冷Observable从发射物的角度来看，有两种不同的Observable:热的和冷的。一个”热”的Observable典型的只要一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。 Observable创建符 Observable.create() 12345Observable.create(new Observable.OnSubscribe&lt;Object&gt;()&#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber&#123; &#125;&#125;); Observable.from()from() 创建符可以从一个列表/数组来创建Observable,并一个接一个的从列表/数组中发射出来每一个对象，或者也可以从Java Future 类来创建Observable，并发射Future对象的 .get() 方法返回的结果值。传入 Future 作为参数时，我们可以指定一个超时的值。Observable将等待来自 Future 的结果；如果在超时之前仍然没有结果返回，Observable将会触发 onError() 方法通知观察者有错误发生了。 123456789101112131415161718192021List&lt;Integer&gt; items = new ArrayList&lt;Integer&gt;();items.add(1);items.add(10);items.add(100);items.add(200);Observable&lt;Integer&gt; observableString = Observable.from(items);Subscription subscriptionPrint = observableString.subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("Observable completed"); &#125; @Override public void onError(Throwable e) &#123; System.out.println("Oh,no! Something wrong happened！"); &#125; @Override public void onNext(Integer item) &#123; System.out.println("Item is " + item); &#125;&#125;); Observable.just()just() 方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们。 just() 方法也可以接受列表或数组，就像 from() 方法，但是它不会迭代列表发射每个值,它将会发射整个列表。通常，当我们想发射一组已经定义好的值时会用到它。但是如果我们的函数不是时变性的，我们可以用just来创建一个更有组织性和可测性的代码库。 1234567891011121314151617Observable&lt;String&gt; observableString = Observable.just(helloWorld());Subscription subscriptionPrint = observableString.subscribe(newObserver&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("Observable completed"); &#125; @Override public void onError(Throwable e) &#123; System.out.println("Oh,no! Something wrong happened!"); &#125; @Override public void onNext(String message) &#123; System.out.println(message); &#125;&#125;); helloWorld() 方法比较简单，像这样： 123private String helloWorld()&#123; return "Hello World";&#125; SubjectSubject 既可以是 Observable，也可以是 Observer。RxJava 提供四种不同的 Subject : PublishSubject BehaviorSubjectBehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。 BehaviorSubject&lt;Integer&gt; behaviorSubject = BehaviorSubject.create(1); 在这个短例子中，我们创建了一个能发射整形(Integer)的BehaviorSubject。由于每当Observes订阅它时就会发射最新的数据，所以它需要一个初始值。 ReplaySubjectReplaySubject 会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发: ReplaySubject&lt;Integer&gt; replaySubject = ReplaySubject.create(); AsyncSubject当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。 AsyncSubject&lt;Integer&gt; asyncSubject = AsyncSubject.create(); 直接创建 Observable在我们的第一个列子里，我们将检索安装的应用列表并填充RecycleView的item来展示它们。我们也设想一个下拉刷新的功能和一个进度条来告知用户当前任务正在执行。 首先，我们创建Observable。我们需要一个函数来检索安装的应用程序列表并把它提供给我们的观察者。我们一个接一个的发射这些应用程序数据，将它们分组到一个单独的列表中，以此来展示响应式方法的灵活性。 123456789101112131415161718192021222324private Observable&lt;AppInfo&gt; getApps()&#123; return Observable.create(subscriber -&gt; &#123; List&lt;AppInfoRich&gt; apps = new ArrayList&lt;AppInfoRich&gt;(); final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null); mainIntent.addCategory(Intent.CATEGORY_LAUNCHER); List&lt;ResolveInfo&gt; infos = getActivity().queryIntentActivities(mainIntent, 0); for(ResolveInfo info : infos)&#123; apps.add(new AppInfoRich(getActivity(),info)); &#125; for (AppInfoRich appInfo:apps) &#123; Bitmap icon = Utils.drawableToBitmap(appInfo.getIcon()); String name = appInfo.getName(); String iconPath = mFilesDir + "/" + name; Utils.storeBitmap(App.instance, icon,name); if (subscriber.isUnsubscribed())&#123; return; &#125; subscriber.onNext(new AppInfo(name, iconPath, appInfo.getLastUpdateTime())); &#125; if (!subscriber.isUnsubscribed())&#123; subscriber.onCompleted(); &#125; &#125;);&#125; AppInfo为App信息的实体类，包括上次更新时间、图标、名字三个属性，此处省略。 需要重点注意的是在发射新的数据或者完成序列之前要检测观察者的订阅情况。这样的话代码会更高效，因为如果没有观察者等待时我们就不生成没有必要的数据项。 接下来，我们来定义下拉刷新的方法：1234567891011121314151617181920private void refreshTheList() &#123; getApps().toSortedList() .subscribe(new Observer&lt;List&lt;AppInfo&gt;&gt;() &#123; @Override public void onCompleted() &#123; Toast.makeText(getActivity(), "Here is the list!", Toast.LENGTH_LONG).show(); &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(getActivity(), "Something went wrong!", Toast.LENGTH_SHORT).show(); mSwipeRefreshLayout.setRefreshing(false); &#125; @Override public void onNext(List&lt;AppInfo&gt; appInfos) &#123; mRecyclerView.setVisibility(View.VISIBLE); mAdapter.addApplications(appInfos); mSwipeRefreshLayout.setRefreshing(false); &#125; &#125;);&#125; 从列表创建 Observable在这个例子中，我们将引入 from() 函数。使用这个特殊的“创建”函数，我们可以从一个列表中创建一个Observable。Observable将发射出列表中的每一个元素，我们可以通过订阅它们来对这些发出的元素做出响应。1234567891011121314151617181920private void loadList(List&lt;AppInfo&gt; apps) &#123; mRecyclerView.setVisibility(View.VISIBLE); Observable.from(apps).subscribe(new Observer&lt;AppInfo&gt;() &#123; @Override public void onCompleted() &#123; mSwipeRefreshLayout.setRefreshing(false); Toast.makeText(getActivity(), "Here is the list!", Toast.LENGTH_LONG).show(); &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(getActivity(), "Something went wrong!", Toast.LENGTH_SHORT).show(); mSwipeRefreshLayout.setRefreshing(false); &#125; @Override public void onNext(AppInfo appInfo) &#123; mAddedApps.add(appInfo); mAdapter.addApplication(mAddedApps.size() - 1, appInfo); &#125; &#125;);&#125; 和第一个例子一个主要的不同是我们在 onCompleted() 函数中停掉进度条是因为我们一个一个的发射元素；第一个例子中的Observable发射的是整个list,因此在 onNext() 函数中停掉进度条的做法是安全的。 具有特殊功能的创建符 just()你可以将一个函数作为参数传给 just() 方法，你将会得到一个已存在代码的原始Observable版本。在一个新的响应式架构的基础上迁移已存在的代码，这个方法可能是一个有用的开始点。 repeat()假如你想对一个Observable重复发射三次数据 :123Observable.just(appOne,appTwo,appThree) .repeat(3) .subscribe(); 我们在 just() 创建Observable后追加了 repeat(3) ，它将会创建9个元素的序列，每一个都单独发射。 defer()有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。看下面的 getInt() 函数：12345678910private Observable&lt;Integer&gt; getInt()&#123; return Observable.create(subscriber -&gt; &#123; if(subscriber.isUnsubscribed())&#123; return; &#125; App.L.debug("GETINT"); subscriber.onNext(42); subscriber.onCompleted(); &#125;);&#125; 这比较简单，并且它没有做太多事情，但是它正好为我们服务。现在，我们可以创建一个新的Observable并且应用 defer() : Observable&lt;Integer&gt; deferred = Observable.defer(this::getInt); 这次， deferred 存在，但是 getInt() create() 方法还没有调用 : logcat日志也没有“GETINT”打印出来 :123deferred.subscribe(number -&gt; &#123; App.L.debug(String.valueOf(number));&#125;); 但是一旦我们订阅了， create() 方法就会被调用并且我们也可以在logcat日志中打印出两个值：GETINT 和 42。 range()从一个指定的数字X开始发射N个数字。range() 函数用两个数字作为参数：第一个是起始点，第二个是我们想发射数字的个数。 interval()interval() 函数在你需要创建一个轮询程序时非常好用。interval() 函数的两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。 timer()如果你需要一个一段时间之后才发射的Observable，你可以使用 timer()。 过滤Observables过滤序列RxJava让我们使用 filter() 方法来过滤我们观测序列中不想要的值。 我们从发出的每个元素中过滤掉开头字母不是C的 : 123456.filter(new Func1&lt;AppInfo,Boolean&gt;()&#123; @Override public Boolean call(AppInfo appInfo)&#123; return appInfo.getName().startsWith("C"); &#125;&#125;) 我们传一个新的 Func1 对象给 filter() 函数，即只有一个参数的函数。 Func1 有一个 AppInfo 对象来作为它的参数类型并且返回 Boolean 对象。只要条件符合 filter() 函数就会返回 true 。此时，值会发射出去并且所有的观察者都会接收到。 filter() 函数最常用的用法之一时过滤 null 对象： 123456.filter(new Func1&lt;AppInfo,Boolean&gt;()&#123; @Override public Boolean call(AppInfo appInfo)&#123; return appInfo != null; &#125;&#125;) 它帮我们免去了在 onNext() 函数调用中再去检测 null 值，让我们把注意力集中在应用业务逻辑上。 获取我们需要的数据当我们不需要整个序列时，而是只想取开头或结尾的几个元素，我们可以用 take() 或 takeLast() 。 take()take() 函数用整数N来作为一个参数，从原始的序列中发射前N个元素，然后完成： 123Observable.from(apps) .take(3) .subscribe(...); takeLast()如果我们想要最后N个元素，我们只需使用 takeLast() 函数： 123Observable.from(apps) .takeLast(3) .subscribe(...); 有且仅有一次 distinct()就像 takeLast() 一样， distinct() 作用于一个完整的序列，然后得到重复的过滤项，它需要记录每一个发射的值。如果你在处理一大堆序列或者大的数据记得关注内存使用情况。 12345Observable&lt;AppInfo&gt; fullOfDuplicates = Observable.from(apps) .take(3) .repeat(3);fullOfDuplicates.distinct() .subscribe(...); ditinctUntilChanged()如果在一个可观测序列发射一个不同于之前的一个新值时让我们得到通知这时候该怎么做？ditinctUntilChanged() 过滤函数能做到这一点。它能轻易的忽略掉所有的重复并且只发射出新的值。 First and lastfirst() 方法和 last() 方法很容易弄明白。它们从Observable中只发射第一个元素或者最后一个元素。这两个都可以传 Func1 作为参数。与 first() 和 last() 相似的变量有： firstOrDefault() 和 lastOrDefault() 。这两个函数当可观测序列完成时不再发射任何值时用得上。在这种场景下，如果Observable不再发射任何值时我们可以指定发射一个默认的值。 Skip and SkipLastskip() 和 skipLast() 函数与 take() 和 takeLast() 相对应。它们用整数N作参数，从本质上来说，它们不让Observable发射前N个或者后N个值。 ElementAt如果我们只想要可观测序列发射的第五个元素该怎么办？ elementAt() 函数仅从一个序列中发射第n个元素然后就完成了。如果我们想查找第五个元素但是可观测序列只有三个元素可供发射时该怎么办？我们可以使用 elementAtOrDefault() 。 Sampling在Observable后面加一个 sample() ，我们将创建一个新的可观测序列，它将在一个指定的时间间隔里由Observable发射最近一次的数值：123Observable&lt;Integer&gt; sensor = [...]sensor.sample(30,TimeUnit.SECONDS) .subscribe(...); 如果我们想让它定时发射第一个元素而不是最近的一个元素，我们可以使用 throttleFirst() 。 Timeout我们可以使用 timeout() 函数来监听源可观测序列,就是在我们设定的时间间隔内如果没有得到一个值则发射一个错误。我们可以认为 timeout() 为一个Observable的限时的副本。如果在指定的时间间隔内Observable不发射值的话，它监听的原始的Observable时就会触发 onError() 函数。123Subscription subscription = getCurrentTemperature() .timeout(2,TimeUnit.SECONDS) .subscribe(...); Debouncedebounce() 函数过滤掉由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。 下图展示了多久从Observable发射一次新的数据， debounce() 函数开启一个内部定时器，如果在这个时间间隔内没有新的据发射，则新的Observable发射出最后一个数据： 变换Observables*map家族RxJava提供了几个mapping函数： map() , flatMap() , concatMap() , flatMapIterable() 以及 switchMap() .所有这些函数都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。 MapRxJava的 map 函数接收一个指定的 Func 对象然后将它应用到每一个由Observable发射的值上。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Observable.from(apps) .map(new Func1&lt;AppInfo,AppInfo&gt;()&#123; @Override public Appinfo call(AppInfo appInfo)&#123; String currentName = appInfo.getName(); String lowerCaseName = currentName.toLowerCase(); appInfo.setName(lowerCaseName); return appInfo; &#125; &#125;) .subscribe(...);``` 正如你看到的，像往常一样创建我们发射的Observable之后，我们追加一个 map 调用，我们创建一个简单的函数来更新 AppInfo对象并提供一个名字小写的新版本给观察者。- FlatMap 在复杂的场景中，我们有一个这样的Observable：它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的 flatMap() 函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。 ![20170227148818631525343.png](http://ohtrrgyyd.bkt.clouddn.com/20170227148818631525343.png) 当我们在处理可能有大量的Observables时，重要是记住任何一个Observables发生错误的情况， flatMap() 将会触发它自己的 onError() 函数并放弃整个链。重要的一点提示是关于合并部分：它允许交叉。正如上图所示，这意味着 flatMap() 不能够保证在最终生成的Observable中源Observables确切的发射顺序。- ConcatMap RxJava的 concatMap() 函数解决了 flatMap() 的交叉问题，提供了一种能够把发射的值连续在一起的铺平函数，而不是合并它们，如下图所示： ![2017022714881863516790.png](http://ohtrrgyyd.bkt.clouddn.com/2017022714881863516790.png)- FlatMapIterable 作为*map家族的一员， flatMapInterable() 和 flatMap() 很像。仅有的本质不同是它将源数据两两结成对并生成Iterable，而不是原始数据项和生成的Observables。- SwitchMap switchMap() 和 flatMap() 很像，除了一点：每当源Observable发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的Observable，并开始监视当前发射的这一个。- Scan RxJava的 scan() 函数可以看做是一个累积函数。 scan() 函数对原始Observable发射的每一项数据都应用一个函数，计算出函数的结果值，并将该值填充回可观测序列，等待和下一次发射的数据一起使用。作为一个通用的例子，给出一个累加器：``` javaObservable.just(1,2,3,4,5) .scan((sum,item) -&gt; sum + item) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; Log.d("RXJAVA", "Sequence completed."); &#125; @Override public void onError(Throwable e) &#123; Log.e("RXJAVA", "Something went south!"); &#125; @Override public void onNext(Integer item) &#123; Log.d("RXJAVA", "item is: " + item); &#125; &#125;); 我们得到的结果是： RXJAVA: item is: 1RXJAVA: item is: 3RXJAVA: item is: 6RXJAVA: item is: 10RXJAVA: item is: 15RXJAVA: Sequence completed. GroupByRxJava提供了一个有用的函数从列表中按照指定的规则： groupBy() 来分组元素。下图中的例子展示了 groupBy() 如何将发射的值根据他们的形状来进行分组。 这个函数将源Observable变换成一个发射Observables的新的Observable。它们中的每一个新的Observable都发射一组指定的数据。 为了创建一个分组了的已安装应用列表，我们在 loadList() 函数中引入了一个新的元素：12345678Observable&lt;GroupedObservable&lt;String,AppInfo&gt;&gt; groupedItems = Observable.from(apps) .groupBy(new Func1&lt;AppInfo,String&gt;()&#123; @Override public String call(AppInfo appInfo)&#123; SimpleDateFormat formatter = new SimpleDateFormat("MM/yyyy"); return formatter.format(new Date(appInfo.getLastUpdateTime())); &#125; &#125;); 现在我们创建了一个新的Observable， groupedItems ，它将会发射一个带有 GroupedObservable 的序列。 GroupedObservable 是一个特殊的Observable，它源自一个分组的key。在这个例子中，key就是 String ，代表的意思是 Month/Year 格式化的最近更新日期。 BufferRxJava中的 buffer() 函数将源Observable变换一个新的Observable，这个新的Observable每次发射一组列表值而不是一个一个发射。 buffer() 函数有几种变体。其中有一个是允许你指定一个 skip 值：此后每 skip 项数据，用count项数据填充缓冲区。另一个是buffer() 带一个 timespan 的参数，会创建一个每隔timespan时间段就会发射一个列表的Observable。 WindowRxJava的 window() 函数和 buffer() 很像，但是它发射的是Observable而不是列表。 正如 buffer() 一样, window() 也有一个 skip 变体。 Castcast() 函数是 map() 操作符的特殊版本。它将源Observable中的每一项数据都转换为新的类型，把它变成了不同的 Class 。 组合ObservablesMerge在”异步的世界“中经常会创建这样的场景，我们有多个来源但是又只想有一个结果：多输入，单输出。RxJava的 merge() 方法将帮助你把两个甚至更多的Observables合并到他们发射的数据项里。下图给出了把两个序列合并在一个最终发射的Observable。 正如你看到的那样，发射的数据被交叉合并到一个Observable里面。注意如果你同步的合并Observable，它们将连接在一起并且不会交叉。12Observable&lt;AppInfo&gt; mergedObserbable = Observable.merge(observableApps,observableReversedApps);mergedObserbable.subscribe(...); 注意错误时的toast消息，你可以认为每个Observable抛出的错误都将会打断合并。如果你需要避免这种情况，RxJava提供了 mergeDelayError() ，它能从一个Observable中继续发射数据即便是其中有一个抛出了错误。当所有的Observables都完成时， mergeDelayError() 将会发射 onError()。 ZIP在一种新的可能场景中处理多个数据来源时会带来：多从个Observables接收数据，处理它们，然后将它们合并成一个新的可观测序列来使用。RxJava有一个特殊的方法可以完成： zip() 合并两个或者多个Observables发射出的数据项，根据指定的函数Func* 变换它们，并发射一个新值。下图展示了 zip() 方法如何处理发射的“numbers”和“letters”然后将它们合并一个新的数据项： 123Observable.zip(observableApp, tictoc, (AppInfo appInfo, Long time) -&gt; updateTitle(appInfo, time)) .observeOn(AndroidSchedulers.mainThread()) .subscribe(...); zip() 函数有三个参数：两个Observables和一个 Func2 。 Join前面两个方法， zip() 和 merge() 方法作用在发射数据的范畴内，在决定如何操作值之前有些场景我们需要考虑时间的。RxJava的 join() 函数基于时间窗口将两个Observables发射的数据结合在一起。 为了正确的理解上一张图，我们解释下 join() 需要的参数： 第二个Observable和源Observable结合。 Func1 参数：在指定的由时间窗口定义时间间隔内，源Observable发射的数据和从第二个Observable发射的数据相互配合返回的Observable。 Func1 参数：在指定的由时间窗口定义时间间隔内，第二个Observable发射的数据和从源Observable发射的数据相互配合返回的Observable。 Func2 参数：定义已发射的数据如何与新发射的数据项相结合。 combineLatestRxJava的 combineLatest() 函数有点像 zip() 函数的特殊形式。正如我们已经学习的， zip() 作用于最近未打包的两个Observables。相反， combineLatest() 作用于最近发射的数据项：如果 Observable1 发射了A并且 Observable2 发射了B和C， combineLatest() 将会分组处理AB和AC，如下图所示： And,Then和When在将来还有一些 zip() 满足不了的场景。如复杂的架构，或者是仅仅为了个人爱好，你可以使用And/Then/When解决方案。它们在RxJava的joins包下，使用Pattern和Plan作为中介，将发射的数据集合并到一起。 Switch给出一个发射多个Observables序列的源Observable， switch() 订阅到源Observable然后开始发射由第一个发射的Observable发射的一样的数据。当源Observable发射一个新的Observable时， switch() 立即取消订阅前一个发射数据的Observable（因此打断了从它那里发射的数据流）然后订阅一个新的Observable，并开始发射它的数据。 StartWithRxJava的 startWith() 是 concat() 的对应部分。正如 concat() 向发射数据的Observable追加数据那样，在Observable开始发射他们的数据之前，startWith() 通过传递一个参数来先发射一个数据序列。 Schedulers-解决Android主线程问题Schedulers调度器以一种最简单的方式将多线程用在你的Apps的中。它们时RxJava重要的一部分并能很好地与Observables协同工作。它们无需处理实现、同步、线程、平台限制、平台变化而可以提供一种灵活的方式来创建并发程序。 RxJava提供了5种调度器： .io() .computation() .immediate() .newThread() .trampoline() Schedulers.io()这个调度器时用于I/O操作。它基于根据需要，增长或缩减来自适应的线程池。我们将使用它来修复我们之前看到的 StrictMode 违规做法。由于它专用于I/O操作，所以并不是RxJava的默认方法；正确的使用它是由开发者决定的。 重点需要注意的是线程池是无限制的，大量的I/O调度操作将创建许多个线程并占用内存。一如既往的是，我们需要在性能和简捷两者之间找到一个有效的平衡点。 Schedulers.computation()这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器： buffer() , debounce() , delay() , interval() , sample() , skip()。 Schedulers.immediate()这个调度器允许你立即在当前线程执行你指定的工作。它是 timeout() , timeInterval() ,以及 timestamp() 方法默认的调度器。 Schedulers.newThread()这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。 Schedulers.trampoline()当我们想在当前线程执行一个任务时，并不是立即，我们可以用 .trampoline() 将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是 repeat() 和 retry() 方法默认的调度器。 非阻塞I/O操作使用 Schedulers.io() 创建非阻塞的版本：12345public static void storeBitmap(Context context, Bitmap bitmap, String filename) &#123; Schedulers.io().createWorker().schedule(() -&gt; &#123; blockingStoreBitmap(context, bitmap, filename); &#125;);&#125; SubscribeOn and ObserveOn我们学到了如何在一个调度器上运行一个任务。但是我们如何利用它来和Observables一起工作呢？RxJava提供了 subscribeOn() 方法来用于每个Observable对象。 subscribeOn() 方法用 Scheduler 来作为参数并在这个Scheduler上执行Observable调用。 首先，我们需要一个新的 getApps() 方法来检索已安装的应用列表：123456789101112131415private Observable&lt;AppInfo&gt; getApps() &#123; return Observable.create(subscriber -&gt; &#123; List&lt;AppInfo&gt; apps = new ArrayList&lt;&gt;(); SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE); Type appInfoType = new TypeToken&lt;List&lt;AppInfo&gt;&gt;()&#123;&#125;.getType(); String serializedApps = sharedPref.getString("APPS", ""); if (!"".equals(serializedApps)) &#123; apps = new Gson().fromJson(serializedApps,appInfoType); &#125; for (AppInfo app : apps) &#123; subscriber.onNext(app); &#125; subscriber.onCompleted(); &#125;);&#125; 然后，我们所需要做的是指定 getApps() 需要在调度器上执行：12getApps().subscribeOn(Schedulers.io()) .subscribe(new Observer&lt;AppInfo&gt;() &#123; [...] 最后，我们只需在 loadList() 函数添加几行代码，那么每一项就都准备好了：12345getApps() .onBackpressureBuffer() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;AppInfo&gt;() &#123; [...] observeOn() 方法将会在指定的调度器上返回结果：如例子中的UI线程。 onBackpressureBuffer() 方法将告诉Observable发射的数据如果比观察者消费的数据要更快的话，它必须把它们存储在缓存中并提供一个合适的时间给它们。 处理耗时的任务一个与I/O无关的耗时的任务：12345getObservableApps(apps) .onBackpressureBuffer() .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;AppInfo&gt;() &#123; [...] 总结RxJava提供了一种以面向时序的方式考虑数据的机会：所有事情都是持续变化的，数据在更新，事件在触发，然后你就可以创建事件响应式的、灵活的、运行流畅的App。 转载自响应式编程在Android中的应用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 图片加载框架－Picasso的使用指南]]></title>
      <url>%2F2017%2F01%2F30%2Fandroid-picasso%2F</url>
      <content type="text"><![CDATA[前言Android 中有几个比较有名的图片加载框架，Universal ImageLoader、Picasso、Glide和Fresco。它们各有优点，以前一直用的是ImageLoader 做项目中的图片加载，由于作者宣布ImageLoader 不会在更新了，因此新的项目打算换一个图片加载框架－Picasso, Picasso 是Square 公司开源的Android 端的图片加载和缓存框架。Square 真是一家良心公司啊，为我们Android开发者贡献了很多优秀的开源项目有木有！像什么Rerefoit 、OkHttp、LeakCanary、Picasso等等都是非常火的开源项目。扯远了，回到正题，除了使用简单方便，Picasso还能自动帮我们做以下事情： 处理Adapter 中ImageView的回收和取消下载。 使用最小的内存 来做复杂的图片变换。比如高斯模糊，圆角、圆形等处理。 自动帮我们缓存图片。内存和磁盘缓存。以上只是列出了Picasso 比较核心的几点，其实它的优点远远不止这些，接下来就看一下如何使用Picasso。 使用一、添加依赖要使用Picasso,首先我们要添加版本依赖，去官网或者Github 看一下当前的最新版本(截止本文最新版本为2.5.2)，然后在build.gradle中添加依赖： compile &apos;com.squareup.picasso:picasso:2.5.2&apos; 二、加载显示图片将Picasso添加到项目之后，我们就可以用它来加载图片了，使用方法非常简单：123Picasso.with(this) .load("http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg") .into(mImageView); 只需要一行代码就完成了加载图片到显示的整个过程，链式调用，非常简洁，其实有三步，一次调用了三个方法： with(Context) 获取一个Picasso单例，参数是一个Context上下文 load(String) 调用load 方法加载图片 into (ImageView) 将图片显示在对应的View上，可以是ImageView，也可以是实现了Target j接口的自定义View。上面演示了加载一张网络图片，它还支持其它形式的图片加载，加载文件图片，加载本地资源图片，加载一个Uri 路径给的图片，提供了几个重载的方法： 1.load(Uri uri) 加载一个以Uri路径给的图片12Uri uri = Uri.parse(ANDROID_RESOURCE + context.getPackageName() + FOREWARD_SLASH + resourceId)Picasso.with(this).load(uri).into(mImageView); 2.load(File file) 加载File中的图片Picasso.with(this).load(file).into(mImageView); 3.load(int resourceId) 加载本地资源图片Picasso.with(this).load(R.mipmap.ic_launcher).into(mImageView); 提醒：上面介绍了load的几个重载方法，加载不同资源的图片，另外提醒注意一下load(String path)接受String 参数的这个方法，参数String 可以是一个网络图片url,也可以是file 路径、content资源 和Android Resource。看一下源码的注释。1234567891011121314151617181920212223242526&gt;/** * Start an image request using the specified path. This is a convenience method for calling * &#123;@link #load(Uri)&#125;. * &lt;p&gt; * This path may be a remote URL, file resource (prefixed with &#123;@code file:&#125;), content resource * (prefixed with &#123;@code content:&#125;), or android resource (prefixed with &#123;@code * android.resource:&#125;. * &lt;p&gt; * Passing &#123;@code null&#125; as a &#123;@code path&#125; will not trigger any request but will set a * placeholder, if one is specified. * * @see #load(Uri) * @see #load(File) * @see #load(int) * @throws IllegalArgumentException if &#123;@code path&#125; is empty or blank string. */ public RequestCreator load(String path) &#123; if (path == null) &#123; return new RequestCreator(this, null, 0); &#125; if (path.trim().length() == 0) &#123; throw new IllegalArgumentException("Path must not be empty."); &#125; return load(Uri.parse(path)); &#125;&gt; 要使用string 参数加载上面的几种资源，除了网络url,其它几种需要加上对应前缀，file文件路径前缀：file: , content 添加前缀：content: ,Android Resource 添加：android.resource: 三、placeholder&amp; error &amp; noPlaceholder &amp; noFade通过上面的第一步我们就可以通过Picasso 加载图片了，我们的项目中通常最常用的就是加载网络图片，但是由于网络环境的差异，有时侯加载网络图片的过程有点慢，这样界面上就会显示空ImageView什么也看不见，用户体验非常不好。其实以前用过ImageLoader的同学都知道，ImageLoader 是可以设置加载中显示默认图片的，Picasso当然也给我们提供了这个功能，这就是我们要说的placeholder(占位图)。 1.placeholderplaceholder提供一张在网络请求还没有完成时显示的图片，它必须是本地图片，代码如下：12345678910111213 Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .into(mImageView);``` 设置placeholder之后，在加载图片的时候，就可以显示设置的默认图了，提升用户体验。### 2.error和placeholder 的用法一样，error 提供一张在加载图片出错的情况下显示的默认图``` javaPicasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .into(mImageView); 3.noPlaceholder这个方法的意思就是：在调用into的时候明确告诉你没有占位图设置。根据这个方法签名的解释是阻止View被回收的时候Picasso清空target或者设置一个应用的占位图。需要注意的是placeholder和noPlaceholder 不能同时应用在同一个请求上，会抛异常。1234Picasso.with(this).load(URL) .noPlaceholder() .error(R.drawable.error_iamge) .into(mImageView); 4.noFade无论你是否设置了占位图，Picasso 从磁盘或者网络加载图片时，into 显示到ImageView 都会有一个简单的渐入过度效果，让你的UI视觉效果更柔顺丝滑一点，如果你不要这个渐入的效果（没有这么坑爹的需求吧！！！），就调用noFade方法。12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .noFade() .into(mImageView); 四、设置图片尺寸(Resize)、缩放(Scale)和裁剪(Crop)1.Resize(int w,int h)在项目中，为了带宽、内存使用和下载速度等考虑，服务端给我们的图片的size 应该和我们View 实际的size一样的，但是实际情况并非如此，服务端可能给我们一些奇怪的尺寸的图片，我们可以使用resize(int w,int hei) 来重新设置尺寸。12345678910Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resize(400,200) .into(mImageView);``` resize()方法接受的参数的单位是pixels,还有一个可以设置dp单位的方法，将你的尺寸写在dimens.xml文件中，然后用`resizeDimen(int targetWidthResId, int targetHeightResId)`方法 ``` xml&lt;dimen name="image_width"&gt;300dp&lt;/dimen&gt;&lt;dimen name="image_height"&gt;200dp&lt;/dimen&gt; 12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resizeDimen(R.dimen.image_width,R.dimen.image_height) .into(mImageView); 2.onlyScaleDown当调用了resize 方法重新设置图片尺寸的时候，调用onlyScaleDown 方法，只有当原始图片的尺寸大于我们指定的尺寸时，resize才起作用,如：12345678910111213141516171819Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resize(4000,2000) .onlyScaleDown() .into(mImageView);``` 只有当原来的图片尺寸大于4000 x 2000的时候，resize 才起作用。### 3.图片裁剪 centerCrop()这个属性应该不陌生吧！ImageView 的ScaleType 就有这个属性。当我们使用resize 来重新设置图片的尺寸的时候，你会发现有些图片拉伸或者扭曲了（使用ImageView的时候碰到过吧），我要避免这种情况，Picasso 同样给我们提供了一个方法，centerCrop，**充满ImageView 的边界，居中裁剪**。``` javaPicasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resize(400,200) .centerCrop() .into(mImageView); 4.centerInside上面的centerCrop是可能看不到全部图片的，如果你想让View将图片展示完全，可以用centerInside，但是如果图片尺寸小于View尺寸的话，是不能充满View边界的。123456Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resize(400,200) .centerInside() .into(mImageView); 5.fitfit 是干什的呢？上面我们需要用resize()来指定我们需要的图片的尺寸，那就是说在程序中需要我们计算我们需要的尺寸（固定大小的除外），这样很麻烦，fit 方法就帮我们解决了这个问题。fit 它会自动测量我们的View的大小，然后内部调用reszie方法把图片裁剪到View的大小，这就帮我们做了计算size和调用resize 这2步。非常方便。代码如下：12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .fit() .into(mImageView); 使用fit 还是会出现拉伸扭曲的情况，因此最好配合前面的centerCrop使用，代码如下：123456Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .fit() .centerCrop() .into(mImageView); 看一下对比图:fit(会拉伸): fit &amp; centerCrop (不会拉伸): 注意：特别注意， fit 只对ImageView 有效 使用fit时，ImageView 宽和高不能为wrap_content,很好理解，因为它要测量宽高。 五、图片旋转Rotation()在图片显示到ImageView 之前，还可以对图片做一些旋转操作，调用rotate(int degree)方法12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .rotate(180) .into(mImageView); 这个方法它是以（0，0）点旋转，但是有些时候我们并不想以（0,0）点旋转，还提供了另外一个方法可以指定原点： rotate(float degrees, float pivotX, float pivotY) 以(pivotX, pivotY)为原点旋转 12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .rotate(180,200,100) .into(mImageView); 六、转换器TransformationTransformation 这就是Picasso的一个非常强大的功能了，它允许你在load图片 -&gt; into ImageView 中间这个过成对图片做一系列的变换。比如你要做图片高斯模糊、添加圆角、做度灰处理、圆形图片等等都可以通过Transformation来完成。 来看一个高斯模糊的例子： 1.首先定义一个转换器继承 Transformation1234567891011121314151617181920212223242526272829303132333435363738394041public static class BlurTransformation implements Transformation&#123; RenderScript rs; public BlurTransformation(Context context) &#123; super(); rs = RenderScript.create(context); &#125; @Override public Bitmap transform(Bitmap bitmap) &#123; // Create another bitmap that will hold the results of the filter. Bitmap blurredBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true); // Allocate memory for Renderscript to work with Allocation input = Allocation.createFromBitmap(rs, blurredBitmap, Allocation.MipmapControl.MIPMAP_FULL, Allocation.USAGE_SHARED); Allocation output = Allocation.createTyped(rs, input.getType()); // Load up an instance of the specific script that we want to use. ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); script.setInput(input); // Set the blur radius script.setRadius(25); // Start the ScriptIntrinisicBlur script.forEach(output); // Copy the output to the blurred bitmap output.copyTo(blurredBitmap); bitmap.recycle(); return blurredBitmap; &#125; @Override public String key() &#123; return "blur"; &#125; &#125; 2.加载图片的时候，在into 方法前面调用 transform方法 应用Transformation12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .transform(new BlurTransformation(this)) .into(mBlurImage); 看一下效果图： 上面为原图，下面为高斯模糊图是不是很强大，任何复杂的变换都可以通过Transformation 来做。还不止于此，还有更强大的功能。可以在一个请求上应用多个Transformation比如：我想先做个灰度处理然后在做一个高斯模糊图： 1.灰度的Transformation12345678910111213141516171819202122232425262728public static class GrayTransformation implements Transformation&#123; @Override public Bitmap transform(Bitmap source) &#123; int width, height; height = source.getHeight(); width = source.getWidth(); Bitmap bmpGrayscale = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565); Canvas c = new Canvas(bmpGrayscale); Paint paint = new Paint(); ColorMatrix cm = new ColorMatrix(); cm.setSaturation(0); ColorMatrixColorFilter f = new ColorMatrixColorFilter(cm); paint.setColorFilter(f); c.drawBitmap(source, 0, 0, paint); if(source!=null &amp;&amp; source!=bmpGrayscale)&#123; source.recycle(); &#125; return bmpGrayscale; &#125; @Override public String key() &#123; return "gray"; &#125; &#125; 2.如果是多个Transformation操作，有2种方式应用方式一：直接调用多次transform 方法，不会覆盖的。它只是保存到了一个List 里面12345678Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .fit() .centerCrop() .transform(new GrayTransformation())//度灰处理 .transform(new BlurTransformation(this))//高斯模糊 .into(mBlurImage); 需要注意调用的顺序方式二：接受一个List，将Transformation 放大list 里12345678910List&lt;Transformation&gt; transformations = new ArrayList&lt;&gt;();transformations.add(new GrayTransformation());transformations.add(new BlurTransformation(this));Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .fit() .centerCrop() .transform(transformations) .into(mBlurImage); 效果图： 如上图，第一张为灰度操作，第二张为 灰度＋高斯模糊另外发现了一个开源库，专门写了很多好玩的Transformation，有兴趣的可以看一下：picasso-transformations 七、请求优先级Picasso 为请求设置有优先级，有三种优先级，LOW、NORMAL、HIGH。默认情况下都是NORMAL，除了调用fetch 方法，fetch 方法的优先级是LOW。12345public enum Priority &#123; LOW, NORMAL, HIGH&#125; 可以通过priority方法设置请求的优先级，这会影响请求的执行顺序，但是这是不能保证的，它只会往高的优先级靠拢。代码如下：123456Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .priority(Picasso.Priority.HIGH) // .priority(Picasso.Priority.LOW) .into(mImageView); 八、Tag管理请求Picasso 允许我们为一个请求设置tag来管理请求，看一下对应的几个方法：下面3个方法是Picasso这个类的： cancelTag(Object tag) 取消设置了给定tag的所有请求 pauseTag(Object tag) 暂停设置了给定tag 的所有请求 resumeTag(Object tag) resume 被暂停的给定tag的所有请求 还有一个方法是RequestCreator的: tag(Object tag) 为请求设置tag 几个方法的意思也很明确，就是我们可以暂停、resume、和取消请求，可以用在哪些场景呢？ 场景一： 比如一个照片流列表，当我们快速滑动列表浏览照片的时候，后台会一直发起请求加载照片的，这可能会导致卡顿，那么我们就可以为每个请求设置一个相同的Tag，在快速滑动的时候，调用pauseTag暂停请求，当滑动停止的时候，调用resumeTag恢复请求，这样的体验是不是就会更好一些呢。 Adapter中添加如下代码：12345Picasso.with(this).load(mData.get(position)) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .tag("PhotoTag") .into(holder.mImageView); Activity中为RecyclerView添加滑动监听：123456789101112mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; final Picasso picasso = Picasso.with(MainActivity.this); if (newState == SCROLL_STATE_IDLE) &#123; picasso.resumeTag("PhotoTag"); &#125; else &#123; picasso.pauseTag("PhotoTag"); &#125; &#125; &#125;); 场景二： 比如一个照片流列表界面，在弱网环境下，加载很慢，退出这个界面时可能会有很多请求没有完成，这个时候我们就可 以通过tag 来取消请求了。 九、同步／异步加载图片Picasso 加载图片也有同步／异步两种方式 1.get() 同步很简单，同步加载使用get() 方法，返回一个Bitmap 对象，代码如下：12345try &#123; Bitmap bitmap = Picasso.with(this).load(URL).get(); &#125; catch (IOException e) &#123; e.printStackTrace();&#125; 注意：使用同步方式加载，不能放在主线程来做。 2.异步的方式加载图片，fetch()一般直接加载图片通过into显示到ImageView 是异步的方式，除此之外，还提供了2个异步的方法： fetch() 异步方式加载图片 fetch(Callback callback) 异步方式加载图片并给一个回调接口。 1234567891011Picasso.with(this).load(URL).fetch(new Callback() &#123; @Override public void onSuccess() &#123; //加载成功 &#125; @Override public void onError() &#123; //加载失败 &#125;&#125;); 这里就要吐槽一下接口设计了，回调并没有返回Bitmap, 不知道作者是怎么考虑的，只是一个通知效果，知道请求失败还是成功。fetch 方法异步加载图片并没有返回Bitmap，这个方法在请求成功之后，将结果存到了缓存，包括磁盘和内存缓存。所以使用这种方式加载图片适用于这种场景：知道稍后会加载图片，使用fetch 先加载缓存，起到一个预加载的效果。 十、缓存（Disk 和 Memory）Picasso 有内存缓存(Memory)和磁盘缓存（ Disk）, 首先来看一下源码中对于缓存的介绍： LRU memory cache of 15% the available application RAM Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is onlyavailable on API 14+ or if you are using a standalone library that provides a disk cache on all API levels like OkHttp) Three download threads for disk and network access. 可以看出，内存缓存是使用的LRU 策略的缓存实现，它的大小是内存大小的15%,可以自定义它的大小，最后在扩展那一章节再讲，磁盘缓存是磁盘容量的2%但是不超过50M,不少于5M。处理一个请求的时候，按照这个顺讯检查：memory-&gt;disk-&gt;network 。先检查有木有内存缓存，如果命中，直接返回结果，否则检查磁盘缓存，命中则返回结果，没有命中则从网上获取。 默认情况下，Picasso 内存缓存和磁盘缓存都开启了的，也就是加载图片的时候，内存和磁盘都缓存了，但是有些时候，我们并不需要缓存，比如说：加载一张大图片的时候，如果再内存中保存一份，很容易造成OOM,这时候我们只希望有磁盘缓存，而不希望缓存到内存，因此就需要我们设置缓存策略了。Picasso 提供了这样的方法。 1.memoryPolicy 设置内存缓存策略就像上面所说的，有时候我们不希望有内存缓存，我们可以通过 memoryPolicy 来设置。MemoryPolicy是一个枚举，有两个值 NO_CACHE：表示处理请求的时候跳过检查内存缓存NO_STORE: 表示请求成功之后，不将最终的结果存到内存。 示例代码如下：12345with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE) //静止内存缓存 .into(mBlurImage); 2.networkPolicy 设置磁盘缓存策略和内存缓存一样，加载一张图片的时候，你也可以跳过磁盘缓存，和内存缓存策略的控制方式一样，磁盘缓存调用方法networkPolicy(NetworkPolicy policy, NetworkPolicy… additional) , NetworkPolicy是一个枚举类型，有三个值： NO_CACHE: 表示处理请求的时候跳过处理磁盘缓存 NO_STORE: 表示请求成功后，不将结果缓存到Disk,但是这个只对OkHttp有效。 OFFLINE: 这个就跟 上面两个不一样了，如果networkPolicy方法用的是这个参数，那么Picasso会强制这次请求从缓存中获取结果，不会发起网络请求，不管缓存中能否获取到结果。 使用示例：123456with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE)//跳过内存缓存 .networkPolicy(NetworkPolicy.NO_CACHE)//跳过磁盘缓存 .into(mBlurImage); 强制从缓存获取：12345with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .networkPolicy(NetworkPolicy.OFFLINE)//强制从缓存获取结果 .into(mBlurImage); 十一、Debug 和日志1.缓存指示器上一节说了，Picasso 有内存缓存和磁盘缓存，先从内存获取，没有再去磁盘缓存获取，都有就从网络加载，网络加载是比较昂贵和耗时的。因此，作为一个开发者，我们往往需要加载的图片是从哪儿来的（内存、Disk还是网络），Picasso让我们很容易就实现了。只需要调用一个方法setIndicatorsEnabled(boolean)就可以了,它会在图片的左上角出现一个带色块的三角形标示，有3种颜色，绿色表示从内存加载、蓝色表示从磁盘加载、红色表示从网络加载。Picasso.with(this).setIndicatorsEnabled(true);//显示指示器效果图： 如上图所示，第一张图从网络获取，第二张从磁盘获取，第三张图从内存获取。看一下源码中定义指示器的颜色：123456789101112/** Describes where the image was loaded from. */public enum LoadedFrom &#123; MEMORY(Color.GREEN), DISK(Color.BLUE), NETWORK(Color.RED); final int debugColor; private LoadedFrom(int debugColor) &#123; this.debugColor = debugColor; &#125;&#125; 可以很清楚看出，对应三种颜色代表着图片的来源。 2.日志上面的指示器能够很好的帮助我们看出图片的来源，但是有时候我们需要更详细的信息，Picasso,可以打印一些日志，比如一些关键方法的执行时间等等，我们只需要调用setLoggingEnabled(true)方法，然后App在加载图片的过程中，我们就可以从logcat 看到一些关键的日志信息。Picasso.with(this).setLoggingEnabled(true);//开启日志打印 十二、Picasso 扩展到目前为止，Picasso的基本使用已经讲得差不多了，但是在实际项目中我们这可能还满足不了我们的需求，我们需要对它做一些自己的扩展，比如我们需要换缓存的位置、我们需要扩大缓存、自定义线程池、自定义下载器等等。这些都是可以的，接下来我们来看一下可以做哪些方面的扩展。 1.用Builder 自己构造一个Picasso Instance我们来回顾一下前面是怎么用Picasso加载图片的：123Picasso.with(this) .load("http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg") .into(mImageView); 总共3步： 用with方法获取一个Picasso 示例 用load方法加载图片 用into 放法显示图片 首先Picasso是一个单例模式，我们每一次获取的示例都是默认提供给我们的实例。但是也可以不用它给的Instance,我们直接用builder来构造一个Picasso:123456Picasso.Builder builder = new Picasso.Builder(this);//构造一个PicassoPicasso picasso = builder.build();//加载图片picasso.load(URL).into(mImageView); 这样我们就构造了一个局部的Picasso实例，当然了，我们直接用new 了一个builder，然后build()生成了一个Picasso。这跟默认的通过with方法获取的实例是一样的。那么现在我们就可以配置一些自定义的功能了。 2, 配置自定义下载器 downLoader如果我们不想用默认提供的Downloader,那么我们可以自定义一个下载器然后配置进去。举个例子： (1) 先自定义一个Downloader(只是举个例子，并没有实现):12345678910111213141516/** * Created by zhouwei on 17/2/26. */public class CustomDownloader implements Downloader &#123; @Override public Response load(Uri uri, int networkPolicy) throws IOException &#123; return null; &#125; @Override public void shutdown() &#123; &#125;&#125; (2) 然后通过builder配置：12345678910111213 //配置下载器builder.downloader(new CustomDownloader());//构造一个PicassoPicasso picasso = builder.build();``` 这样配置后，我们用build()生成的Picasso 实例来加载图片就会使用自定义的下载器来下载图片了。### 3.配置缓存前面说过，内存缓存是用的LRU Cahce ,大小是手机内存的15% ，如果你想缓存大小更大一点或者更小一点，可以自定义，然后配置。``` java//配置缓存LruCache cache = new LruCache(5 * 1024 * 1024);// 设置缓存大小builder.memoryCache(cache); 上面只是一个简单的举例，当然了你可以自定义，也可以使用LRUCache,改变大小，改变存储路径等等。 提示： 很遗憾，好像没有提供改变磁盘缓存的接口，那就只能用默认的了。 4.配置线程池Picasso 默认的线程池的核心线程数为3，如果你觉得不够用的话，可以配置自己需要的线程池，举个列子：123//配置线程池ExecutorService executorService = Executors.newFixedThreadPool(8);builder.executor(executorService); 5.配置全局的 Picasso Instance上面说的这些自定义配置项目都是应用在一个局部的Picasso instance 上的，我们不可能每一次使用都要重新配置一下，这样就太麻烦了。我们希望我们的这些自定义配置能在整个项目都应用上，并且只配置一次。其实Picasso 给我们提供了这样的方法。可以调用setSingletonInstance(Picasso picasso)就可以了，看一下这个方法的源码：12345678910111213/** * Set the global instance returned from &#123;@link #with&#125;. * &lt;p&gt; * This method must be called before any calls to &#123;@link #with&#125; and may only be called once. */public static void setSingletonInstance(Picasso picasso) &#123; synchronized (Picasso.class) &#123; if (singleton != null) &#123; throw new IllegalStateException("Singleton instance already exists."); &#125; singleton = picasso; &#125;&#125; 设置一个通过with方法返回的全局instance。我们只希望配置一次，所以，我们应该在Application 的onCreate方法中做全局配置就可以了。app一启动就配置好，然后直接和前面的使用方法一样，调用with方法获取Picasso instance 加载图片就OK了。 因此在Application 中添加如下代码：123456789101112131415161718192021@Overridepublic void onCreate() &#123; super.onCreate(); // 配置全局的Picasso instance Picasso.Builder builder = new Picasso.Builder(this); //配置下载器 builder.downloader(new CustomDownloader()); //配置缓存 LruCache cache = new LruCache(5*1024*1024);// 设置缓存大小 builder.memoryCache(cache); //配置线程池 ExecutorService executorService = Executors.newFixedThreadPool(8); builder.executor(executorService); //构造一个Picasso Picasso picasso = builder.build(); // 设置全局单列instance Picasso.setSingletonInstance(picasso);&#125; 然后应用这些自定义配置加载图片 Picasso.with(this).load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;).into(mImageView);用法和以前的一样，但是我们已经将我们的自定义配置应用上了。 结尾以上就是对Picasso 用法的全部总结，如有什么问题，欢迎留言指正。Picasso真的是一个强大的图片加载缓存库，API 简单好用，而且是链式调用的（这点我特别喜欢）。官方文档写的比较简单，很多用法都要看源码和注释才知道。希望本文能给才开始使用Picasso 的同学一点帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 界面性能调优]]></title>
      <url>%2F2017%2F01%2F27%2Fandroid-view-performance-optimizing%2F</url>
      <content type="text"><![CDATA[前言界面是 Android 应用中直接影响用户体验最关键的部分。如果代码实现得不好，界面容易发生卡顿且导致应用占用大量内存。又卡又慢的应用体验，会影响客户或用户对产品的信心和评价，所以不可忽视。 一、 Android渲染知识1 绘制原理Android系统要求每一帧都要在 16ms 内绘制完成，平滑的完成一帧意味着任何特殊的帧需要执行所有的渲染代码（包括 framework 发送给 GPU 和 CPU 绘制到缓冲区的命令）都要在 16ms 内完成，保持流畅的体验。这个速度允许系统在动画和输入事件的过程中以约 60 帧每秒(1秒 / 0.016帧每秒 = 62.5帧/秒)的平滑帧率来渲染。 如果你的应用没有在 16ms 内完成这一帧的绘制，假设你花了 24ms 来绘制这一帧，那么就会出现掉帧的情况。 系统准备将新的一帧绘制到屏幕上，但是这一帧并没有准备好，所有就不会有绘制操作，画面也就不会刷新。反馈到用户身上，就是用户盯着同一张图看了 32ms 而不是 16ms ，也就是说掉帧发生了。 2 掉帧掉帧是用户体验中一个非常核心的问题。丢弃了当前帧，并且之后不能够延续之前的帧率，这种不连续的间隔会容易会引起用户的注意，也就是我们常说的卡顿、不流畅。 引起掉帧的原因非常多，比如： 花了非常多时间重新绘制界面中的大部分东西，这样非常浪费CPU周期. 过度绘制严重，在绘制用户看不到的对象上花费了太多的时间. 有一大堆动画重复了一遍又一遍，消耗 CPU 、 GPU 资源 频繁的触发垃圾回收 3 为什么是60Fps？Android系统要求每一帧都要在 16ms 内绘制完成，那么1秒的帧率就是约 60 帧每秒（ 1秒 / 0.016帧每秒 = 62.5帧/秒 ），那为什么要以 60 Fps来作为 App 性能的衡量标准呢？这是因为人眼和大脑之间的协作无法感知到超过 60 Fps的画面更新。市面上绝大多数Android设备的屏幕刷新频率是 60 HZ。当然，超过 60 Fps 是没有意义的，人眼感知不到区别。24 Fps 是人眼能感知的连续线性的运动，所以是电影胶圈的常用帧率，因为这个帧率已经足够支撑大部分电影画面所要表达的内容，同时能最大限度地减少费用支出。但是，低于 30 Fps 是无法顺畅表现绚丽的画面内容的，此时就需要用到 60 Fps 来达到想要表达的效果。了解更多Fps知识详见「Wiki」。应用的界面性能目标就是保持 60 Fps，这意味着每一帧你只有 16 ms（1秒 / 60帧率）的时间来处理所有的任务。 4 垃圾回收垃圾回收器是一个在应用运行期间自动释放那些不再引用的内存的机制，常称 GC 。频繁的 GC 也是导致严重性能问题的罪魁祸首之一。前面提到，平滑的完成一帧意味着所有渲染代码都必须在 16ms 内完成。频繁的 GC 会严重限制一帧时间内的剩余时间，如果 GC 所做的工作超过了那些必须的工作，那么留给应用平滑的帧率的时间就越少。越接近 16ms ，在垃圾回收事件触发的时候，就越容易导致卡顿。注意，Android4.4 引进了新的 ART 虚拟机来取代 Dalvik 虚拟机。它们的机制大有不同，简单而言： Dalvik 虚拟机的 GC 是非常耗资源的，并且在正常的情况下一个硬件性能不错的Android设备也会很容易耗费掉 10 - 20 ms 的时间； ART 虚拟机的GC会动态提升垃圾回收的效率，在 ART 中的中断，通常在 2 - 3 ms 间。 比 Dalvik 虚拟机有很大的性能提升；ART 虚拟机相对于 Dalvik 虚拟机来说的垃圾回收来说有一个很大的性能提升，但 2 - 3 ms 的回收时间对于超过16ms帧率的界限也是足够的。因此，尽管垃圾回收在 Android 5.0 之后不再是耗资源的行为，但也是始终需要尽可能避免的，特别是在执行动画的情况下，可能会导致一些让用户明显感觉的丢帧。 想了解更多详细的 ART 和 Dalvik 虚拟机垃圾回收机制，可「戳我」和「我」进行深入了解。 5 UI 线程UI 线程是应用的主线程，很多的性能和卡顿问题是由于我们在主线程中做了大量的工作。所以，所有耗资源的操作，比如 IO 操作、网络操作、SQL 操作、列表刷新等，都应该用后台进程去实现，不能占用主线程，主线程是 UI 线程，是保持程序流畅的关键；在 Android 5.0 版本里，Android 框架层引入了 “ Render Thread ” ，用于向 GPU 发送实际渲染的操作。这个线程减轻了一些 UI 线程减少的操作。但是输入、滚动和动画仍然在 UI thread，因为 Thread 必须能够响应操作。 6 垂直同步垂直同步是 Android4.1 通过 Project Butter 在 UI 架构中引入的新技术，同期引入的还有 Triple Buffer 和 HWComposer 等技术，都是为提高 UI 的流畅性而生。举个例子，你拍了一张照片，然后旋转5度再拍另外一张照片，将两照片的中间剪开并拼接在一起，得到下图： 中间这部分有明显区别的部分，等价于设备刷新率和帧速率不一致的结果。一般而言， GPU 的帧速率应高于刷新率，才不会卡顿或掉帧。如果屏幕刷新率比帧速率还快，屏幕会在两帧中显示同一个画面，这种断断续续情况持续发生时，用户将会很明显地感觉到动画的卡顿或者掉帧，然后又恢复正常，我们常称之为闪屏、跳帧、延迟。应用应避免这些帧率下降的情况，以确保 GPU 能在屏幕刷新之前完成数据的获取及写入，保证动画流畅。 7 UI 绘制机制与栅格化绝大多数渲染操作都依赖两个硬件： CPU 、 GPU 。 CPU 负责 Measure 、 layout 、 Record 、 Execute 的计算操作， GPU 负责栅格化（ Rasterization ）操作。 非必需的视图组件会带来多余的 CPU 计算操作，还会占用多余的 GPU 资源。 栅格化（ Rasterization ）能将 Button 、 Shape 、 Path 、 Bitmap 等资源组件拆分到不同的像素上进行显示。这个操作很费时，所以引入了 GPU 来加快栅格化的操作。 CPU 负责把 UI 组件计算成多边形（ Polygons ），纹理（ Texture ），然后交给 GPU 进行栅格化渲染，再将处理结果传到屏幕上显示。 在 Android 里的那些资源组件的显示（比如 Bitmaps 、 Drawable ），都是一起打包到统一的纹理（ Texture ）当中，然后再传递到 GPU 里面。图片的显示，则是先经过 CPU 的计算加载到内存中，再传给 GPU 进行渲染。文字的显示，则是先经过 CPU 换算成纹理（ Texture ），再传给 GPU 进行渲染，返回到 CPU 绘制单个字符的时候，再重新引用经过 GPU 渲染的内容。动画的显示更加复杂，我们需要在 16 ms 内处理完所有 CPU 和 GPU 的计算、绘制、渲染等操作，才能获得应用的流畅体验。 二、To检测和解决1 检测维度根据业务的不同与所需要的测试粒度的不同，就会有不同的检测维度。目前我所在业务所需的界面性能检测维度如下： 界面过度绘制；（检测过度绘制） 渲染性能；（检测严格模式下的UI渲染性能呈现） 布局边界合理性；（检测元素显示的合理性） 还有专项测试中某些用户场景可能还包含着另外一些隐形的检测维度，比如： OpenGL 跟踪分析； GPU 视图更新合理性； Flash 硬件层更新合理性； 动画加 / 减速状态问题点检测； …… 2 调试工具检测和解决界面性能问题很大程度上依赖于你的应用程序架构，幸运的是，Andorid 提供了很多调试工具，知道并学会使用这些工具很重要，它们可以帮助我们调试和分析界面性能问题，以让应用拥有更好的性能体验。下面列举Android常见的界面性能调试工具： (1)Hierarchy View Hierarchy View 在Android SDK里自带，常用来查看界面的视图结构是否过于复杂，用于了解哪些视图过度绘制，又该如何进行改进。详见官方使用教程（需要翻墙）:「戳我」，官方介绍「戳我」。 (2)LintLint 是 ADT 自带的静态代码扫描工具，可以给 XML 布局文件和 项目代码中不合理的或存在风险的模块提出改善性建议。官方关于 Lint 的实际使用的提示，列举几点如下： 包含无用的分支，建议去除； 包含无用的父控件，建议去除； 警告该布局深度过深； 建议使用 compound drawables ； 建议使用 merge 标签； ……更多 Lint 的官方介绍「戳我」。 (3)Systrace Systrace 在Android DDMS 里自带，可以用来跟踪 graphics 、view 和 window 的信息，发现一些深层次的问题。很麻烦，限制大，实际调试中我基本用不到。官方介绍 「戳我」和 「我」。 (4)Track Track 在 Android DDMS里自带，是个很棒的用来跟踪构造视图的时候哪些方法费时，精确到每一个函数，无论是应用函数还是系统函数，我们可以很容易地看到掉帧的地方以及那一帧所有函数的调用情况，找出问题点进行优化。官方介绍 「戳我」。 (5)OverDraw 通过在 Android 设备的设置 APP 的开发者选项里打开 “ 调试 GPU 过度绘制 ” ，来查看应用所有界面及分支界面下的过度绘制情况，方便进行优化。官方介绍 「戳我」。 (6)GPU 呈现模式分析 通过在 Android 设备的设置 APP 的开发者选项里启动 “ GPU 呈现模式分析 ” ，可以得到最近 128 帧 每一帧渲染的时间，分析性能渲染的性能及性能瓶颈。官方介绍 「戳我」。 (7)StrictMode通过在 Android 设备的设置 APP 的开发者选项里启动 “ 严格模式 ” ，来查看应用哪些操作在主线程上执行时间过长。当一些操作违背了严格模式时屏幕的四周边界会闪烁红色，同时输出 StrictMode 的相关信息到 LOGCAT 日志中。 (8)Animator duration scale通过在 Android 设备的设置 APP 的开发者选项里打开 “ 窗口动画缩放 ” / “ 过渡动画缩放 ” / “ 动画程序时长缩放 ”，来加速或减慢动画的时间，以查看加速或减慢状态下的动画是否会有问题。 (9)Show hardware layer updates通过在 Android 设备的设置 APP 的开发者选项里启动 “ 显示硬件层更新 ”，当 Flash 硬件层在进行更新时会显示为绿色。使用这个工具可以让你查看在动画期间哪些不期望更新的布局有更新，方便你进行优化，以获得应用更好的性能。实例《 Optimizing Android Hardware Layers 》（需要翻墙）:「戳我」。 3 如何解决前面提到过我司的目前所需的测试维度如下： 界面过度绘制；（检测过度绘制） 渲染性能；（检测严格模式下的UI渲染性能呈现） 布局边界合理性；（检测元素显示的合理性） 故接下来将围绕这三两点，分别从概念、追踪、挖掘根源以及排查的工具来具体讲述如何解决，以及给开发的优化建议。 三、界面过度绘制（OverDraw）1 过度绘制概念过度绘制是一个术语，表示某些组件在屏幕上的一个像素点的绘制次数超过 1 次。 通俗来讲，绘制界面可以类比成一个涂鸦客涂鸦墙壁，涂鸦是一件工作量很大的事情，墙面的每个点在涂鸦过程中可能被涂了各种各样的颜色，但最终呈现的颜色却只可能是 1 种。这意味着我们花大力气涂鸦过程中那些非最终呈现的颜色对路人是不可见的，是一种对时间、精力和资源的浪费，存在很大的改善空间。绘制界面同理，花了太多的时间去绘制那些堆叠在下面的、用户看不到的东西，这样是在浪费CPU周期和渲染时间！ 官方例子，被用户激活的卡片在最上面,而那些没有激活的卡片在下面，在绘制用户看不到的对象上花费了太多的时间。 2 追踪过度绘制通过在 Android 设备的设置 APP 的开发者选项里打开 “ 调试 GPU 过度绘制 ” ，来查看应用所有界面及分支界面下的过度绘制情况，方便进行优化。 Android 会在屏幕上显示不同深浅的颜色来表示过度绘制： 没颜色：没有过度绘制，即一个像素点绘制了 1 次，显示应用本来的颜色； 蓝色：1倍过度绘制，即一个像素点绘制了 2 次； 绿色：2倍过度绘制，即一个像素点绘制了 3 次； 浅红色：3倍过度绘制，即一个像素点绘制了 4 次； 深红色：4倍过度绘制及以上，即一个像素点绘制了 5 次及以上。 设备的硬件性能是有限的，当过度绘制导致应用需要消耗更多资源（超过了可用资源）的时候性能就会降低，表现为卡顿、不流畅、ANR 等。为了最大限度地提高应用的性能和体验，就需要尽可能地减少过度绘制，即更多的蓝色色块而不是红色色块。 实际测试，常用以下两点来作为过度绘制的测试指标，将过度绘制控制在一个约定好的合理范围内： 应用所有界面以及分支界面均不存在超过4X过度绘制（深红色区域）； 应用所有界面以及分支界面下，3X过度绘制总面积（浅红色区域）不超过屏幕可视区域的1/4； 3 过度绘制的根源过度绘制很大程度上来自于视图相互重叠的问题，其次还有不必要的背景重叠。 官方例子，比如一个应用所有的View都有背景的话，就会看起来像第一张图中那样，而在去除这些不必要的背景之后（指的是Window的默认背景、Layout的背景、文字以及图片的可能存在的背景），效果就像第二张图那样，基本没有过度绘制的情况。 4 不合理的xml布局对绘制的影响当布局文件的节点树的深度越深，XML 中的标签和属性设置越多，对界面的显示有灾难性影响。 一个界面要显示出来，第一步会进行解析布局，在 requestLayout 之后还要进行一系列的 measure 、 layout 、 draw 操作，若布局文件嵌套过深、拥有的标签属性过于臃肿，每一步的执行时间都会受到影响，而界面的显示是进行完这些操作后才会显示的，所以每一步操作的时间增长，最终显示的时间就会越长。 5 源码相关有能力且有兴趣看源码的童鞋，过度绘制的源码位置在: /frameworks/base/libs/hwui/OpenGLRenderer.cpp ，有兴趣的可以去研究查看。123456789101112131415161718192021222324252627if (Properties::debugOverdraw &amp;&amp; getTargetFbo() == 0) &#123; const Rect* clip = &amp;mTilingClip; mRenderState.scissor().setEnabled(true); mRenderState.scissor().set(clip-&gt;left, mState.firstSnapshot()-&gt;getViewportHeight() - clip-&gt;bottom, clip-&gt;right - clip-&gt;left, clip-&gt;bottom - clip-&gt;top); // 1x overdraw mRenderState.stencil().enableDebugTest(2); drawColor(mCaches.getOverdrawColor(1), SkXfermode::kdata-urlOver_Mode); // 2x overdraw mRenderState.stencil().enableDebugTest(3); drawColor(mCaches.getOverdrawColor(2), SkXfermode::kdata-urlOver_Mode); // 3x overdraw mRenderState.stencil().enableDebugTest(4); drawColor(mCaches.getOverdrawColor(3), SkXfermode::kdata-urlOver_Mode); // 4x overdraw and higher mRenderState.stencil().enableDebugTest(4, true); drawColor(mCaches.getOverdrawColor(4), SkXfermode::kdata-urlOver_Mode); mRenderState.stencil().disable(); &#125;&#125; 四、 渲染性能（Rendering）1 渲染性能概念渲染性能往往是掉帧的罪魁祸首，这种问题很常见，让人头疼。好在 Android 给我们提供了一个强大的工具，帮助我们非常容易追踪性能渲染问题，看到究竟是什么导致你的应用出现卡顿、掉帧。 2 追踪渲染性能通过在 Android 设备的设置 APP 的开发者选项里打开 “ GPU 呈现模式分析 ” 选项，选择 ” 在屏幕上显示为条形图 “。 这个工具会在Android 设备的屏幕上实时显示当前界面的最近 128 帧 的 GPU 绘制图形数据，包括 StatusBar 、 NavBar 、 当前界面的 GPU 绘制图形柱状图数据。我们一般只需关心当前界面的 GPU 绘制图形数据即可。 界面上一共有 128 个小柱状图，代表的是当前界面最近的 128 帧 GPU 绘制图形数据。一个小柱状图代表的这一帧画面渲染的耗时，柱状图越高代表耗时越长。随着界面的刷新，柱状图信息也会实时滚动刷新。中间有一条绿线，代表 16 ms ，保持动画流畅的关键就在于让这些垂直的柱状条尽可能地保持在绿线下面,任何时候超过绿线,你就有可能丢失一帧的内容。 每一个柱状图都是由三种颜色构成：蓝、红、黄。 蓝色代表的是这一帧绘制 Display List 的时间。通俗来说，就是记录了需要花费多长时间在屏幕上更新视图。用代码语言来说，就是执行视图的 onDraw 方法，创建或更新每一个视图的 Display List 的时间。 红色代表的是这一帧 OpenGL 渲染 Display List 所需要的时间。通俗来说，就是记录了执行视图绘制的耗时。用代码语言来说，就是 Android 用 OpenGL ES 的 API 接口进行 2D 渲染 Display List 的时间。 黄色代表的是这一帧 CPU 等待 GPU 处理的时间。通俗来说，就是 CPU 等待 GPU 发出接到命令的回复的等待时间。用代码语言来说，就是这是一个阻塞调用。 实际测试，常用以下两点来作为渲染性能的测试指标，将渲染性能控制在一个约定好的合理范围内： 执行应用的所有功能及分支功能，操作过程中涉及的柱状条区域应至少 90 % 保持到绿线下面； 从用户体检的角度主观判断应用在 512 M 内存的 Android 设备下所有操作过程中的卡顿感是否能接受，不会感觉突兀怪异； 3 渲染性能差的根源当你看到蓝色的线较高的时候，可能是由于你的视图突然无效了需要重新绘制，或者是自定义的视图过于复杂耗时过长。 当你看到红色的线较高的时候，可能是由于你的视图重新提交了需要重新绘制导致的（比如屏幕从竖屏旋转成横屏后当前界面重新创建），或者是自定义的视图很复杂，绘制起来很麻烦，导致耗时过长。比如下面这种视图： 当你看到黄色的线较高的时候，那就意味着你给 GPU 太多的工作，太多的负责视图需要 OpenGL 命令去绘制和处理，导致 CPU 迟迟没等到 GPU 发出接到命令的回复。 4 检测说明这个工具能够很好地帮助你找到渲染相关的问题，帮助你找到卡顿的性能瓶颈，追踪究竟是什么导致被测应用出现卡顿、变慢的情况，以便在代码层面进行优化。甚至让负责产品设计的人去改善他的设计，以获得良好的用户体验。 检测渲染性能时，常伴随着开启“ 严格模式 ” 查看应用哪些情景在 UI 线程（主线程）上执行时间过长。 另外有些强大但可能少用的工具在测试性能渲染时辅助分析，比如： HierarchyViewer：这个工具常用来查看界面的视图结构是否过于复杂，用于了解哪些视图过度绘制，又该如何进行改进； Tracer for OpenGL：这个工具收集了所有UI界面发给GPU的绘制命令。常用于辅助开发人员 DEBUG 、定位一些 HierarchyViewer 工具定位不了的疑难渲染细节问题。 5 UI绘制机制的补充说明如上面所说，布局和 UI 组件等都会先经过 CPU 计算成 GPU 能够识别并绘制的多边形（ Polygons ），纹理（ Texture ），然后交给 GPU 进行栅格化渲染，再将处理结果传到屏幕上显示。 “ CPU 计算成 GPU 能够识别并绘制的对象 ” 这个操作是在 DisplayList 的帮助下完成的。DisplayList 拥有要交给 GPU 栅格化渲染到屏幕上的数据信息。 DisplayList 会在某个视图第一次需要渲染时创建。当该视图有类似位置被移动等变化而需要重新渲染这个视图的时候，则只需 GPU 额外执行一次渲染指令冰更新到屏幕上就够了。但如果视图中的绘制内容发生变化时（比如不可见了），那之间的 DisplayList 就无法继续使用了，这时系统就会重新执行一次重新创建 DisplayList 、渲染DisplayList 并更新到屏幕上。这个流程的表现性能取决于该视图的复杂程度。 五、给开发的界面优化 Advice1 优化布局的结构布局结构太复杂，会减慢渲染的速度，造成性能瓶颈。我们可以通过以下这些惯用、有效的布局原则来优化： 避免复杂的View层级。布局越复杂就越臃肿，就越容易出现性能问题，寻找最节省资源的方式去展示嵌套的内容； 尽量避免在视图层级的顶层使用相对布局 RelativeLayout 。相对布局 RelativeLayout 比较耗资源，因为一个相对布局 RelativeLayout 需要两次度量来确保自己处理了所有的布局关系，而且这个问题会伴随着视图层级中的相对布局 RelativeLayout 的增多，而变得更严重； 布局层级一样的情况建议使用线性布局 LinearLayout 代替相对布局 RelativeLayout，因为线性布局 LinearLayout 性能要更高一些；确实需要对分支进行相对布局 RelativeLayout 的时候，可以考虑更优化的网格布局 GridLayout ，它已经预处理了分支视图的关系，可以避免两次度量的问题； 相对复杂的布局建议采用相对布局 RelativeLayout ，相对布局 RelativeLayout 可以简单实现线性布局 LinearLayout 嵌套才能实现的布局； 不要使用绝对布局 AbsoluteLayout ； 将可重复使用的组件抽取出来并用 标签进行重用。如果应用多个地方的 UI 用到某个布局，就将其写成一个布局部件，便于各个 UI 重用。官方详解 「 戳我 」 使用 merge 标签减少布局的嵌套层次，官方详解 「 戳我 」；去掉多余的不可见背景。有多层背景颜色的布局，只留最上层的对用户可见的颜色即可，其他用户不可见的底层颜色可以去掉，减少无效的绘制操作； 尽量避免使用 layoutweight 属性。使用包含 layoutweight 属性的线性布局 LinearLayout 每一个子组件都需要被测量两次，会消耗过多的系统资源。在使用 ListView 标签与 GridView 标签的时候，这个问题显的尤其重要，因为子组件会重复被创建。平分布局可以使用相对布局 RelativeLayout 里一个 0dp 的 view 做分割线来搞定，如果不行，那就……； 合理的界面的布局结构应是宽而浅，而不是窄而深； 2 优化处理逻辑 按需载入视图。某些不怎么重用的耗资源视图，可以等到需要的时候再加载，提高UI渲染速度； 使用 ViewStub 标签来加载一些不常用的布局； 动态地 inflation view 性能要比用 ViewStub 标签的 setVisiblity 性能要好，当然某些功能的实现采用 ViewStub 标签更合适； 尽量避免不必要的耗资源操作，节省宝贵的运算时间； 避免在 UI 线程进行繁重的操作。耗资源的操作（比如 IO 操作、网络操作、SQL 操作、列表刷新等）耗资源的操作应用后台进程去实现，不能占用 UI 线程，UI 线程是主线程，主线程是保持程序流畅的关键，应该只操作那些核心的 UI 操作，比如处理视图的属性和绘制； 最小化唤醒机制。我们常用广播来接收那些期望响应的消息和事件，但过多的响应超过本身需求的话，会消耗多余的 Android 设备性能和资源。所以应该最小化唤醒机制，当应用不关心这些消失和事件时，就关闭广播，并慎重选择那些要响应的 Intent 。 为低端设备考虑，比如 512M 内存、双核 CPU 、低分辨率，确保你的应用可以满足不同水平的设备。 优化应用的启动速度。当应用启动一个应用时，界面的尽快反馈显示可以给用户一个良好的体验。为了启动更快，可以延迟加载一些 UI 以及避免在应用 Application 层级初始化代码。 3 善用 DEBUG 工具 多使用Android提供的一些调试工具去追踪应用主要功能的性能情况； 多使用Android提供的一些调试工具去追踪应用主要功能的内存分配情况； 转载自Android界面性能调优手册]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 快速开发框架]]></title>
      <url>%2F2017%2F01%2F15%2Fandroid-quick-develop-frame%2F</url>
      <content type="text"><![CDATA[一、Afinal 官方介绍： Afinal是一个Android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对Android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。详情请通过以下网址查看。 Afinal 是一个android的sqlite orm 和 ioc 框架。同时封装了android中的http框架，使其更加简单易用； 使用finalBitmap，无需考虑bitmap在android中加载的时候oom的问题和快速滑动的时候图片加载位置错位等问题。 Afinal的宗旨是简洁，快速。约定大于配置的方式。尽量一行代码完成所有事情。 项目地址：https://github.com/yangfuhai/afinal 功能： 一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。 优点：功能比较全面，文档完善，代码效率比较高。 缺点：没有项目demo，框架的时间比较久，代码冗余比较多（这也是无可避免的），文档比较老跟不上代码更新进度。 （这个评价是其他高人评的，他自己也有写了框架。我个人觉得以前Afinal算是经典了 用的人多）。 二、xUtils Git地址：https://github.com/wyouflf/xUtils xUtils：可以说是Afinal的升级版。 xUtils 包含了很多实用的android工具。 xUtils 支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响… xUitls 最低兼容android 2.2 (api level 8) 三、ThinkAndroid 项目地址：https://github.com/white-cat/ThinkAndroid 官方介绍： ThinkAndroid是一个免费的开源的、简易的、遵循Apache2开源协议发布的Android开发框架，其开发宗旨是简单、快速的进行Android应用程序的开发，包含Android mvc、简易sqlite orm、ioc模块、封装Android httpclitent的http模块,具有快速构建文件缓存功能，无需考虑缓存文件的格式，都可以非常轻松的实现缓存，它还基于文件缓存模块实现了图片缓存功能，在android中加载的图片的时候，对oom的问题，和对加载图片错位的问题都轻易解决。他还包括了一个手机开发中经常应用的实用工具类，如日志管理，配置文件管理，android下载器模块，网络切换检测等等工具 优点：功能看起来比较完善。个人觉得名字起的好。 缺点：从2013年就停止维护了，没有项目文档。 四、LoonAndroid 官方介绍： 如果你想看ui方面的东西，这里没有，想要看牛逼的效果这里也没有。这只是纯实现功能的框架，它的目标是节省代码量，降低耦合，让代码层次看起来更清晰。整个框架一部分是网上的，一部分是我改的，为了适应我的编码习惯，还有一部分像orm完全是网上的组件。在此感谢那些朋友们。 整个框架式的初衷是为了偷懒，之前都是一个功能一个jar，做项目的时候拉进去，这样对于我来说依然还是比较麻烦。最后就导致我把所有的jar做成了一个工具集合包。 有很多框架都含有这个工具集合里的功能，这些不一定都好用，因为这是根据我个人使用喜欢来实现的，如果你们有自己的想法，可以自己把架包解压了以后，源码拉出来改动下。 目前很多框架都用到了注解，除了androidannotations没有入侵我们应用的代码以外，其他的基本上都有，要么是必须继承框架里面的activity,要么是必须在activity的oncreat里面调用某个方法。 整个框架式不同于androidannotations，Roboguice等ioc框架，这是一个类似spring的实现方式。在整应用的生命周期中找到切入点，然后对activity的生命周期进行拦截，然后插入自己的功能。 开源地址：https://github.com/gdpancheng/LoonAndroid 功能： 自动注入框架（只需要继承框架内的application既可） 图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性） 网络请求模块（继承了基本上现在所有的http请求） eventbus（集成一个开源的框架） 验证框架（集成开源框架） json解析（支持解析成集合或者对象） 数据库（不知道是哪位写的 忘记了） 多线程断点下载（自动判断是否支持多线程，判断是否是重定向） 自动更新模块 一系列工具类 优点：功能多 缺点：文档方面 五、KJFrameForAndroid 项目地址：https://github.com/kymjs/KJFrameForAndroid 官方介绍： KJFrameForAndroid 又叫KJLibrary，是一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用；KJFrameForAndroid的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。我们提倡用最少的代码，完成最多的操作，用最高的效率，完成最复杂的功能。 功能： 一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用； KJFrameForAndroid开发框架的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。总共分为五大模块：UILibrary，UtilsLibrary，HttpLibrary，BitmapLibrary，DBLibrary。 优点：功能比较全面，代码效率很高，文档完善，有项目demo，出来的比较晚借鉴了很多大型框架经验。 缺点：项目文档是html页面，查看起来很不方便，项目交流平台没多少人说话（难道大神都是不说话的？） （这两个评价是KJFrameForAndroid的作者对自己的评价，个人觉得作者是个天才。他的评价可能刚写完网上发布后写的。我在给他更新评价。因为现在已经过去了几个月一直在时不时更新。功能很全，项目文档也很全面，而且代码里注释最多 这方面这个很难得。交流平台人很多挺热闹，作者希望更热闹这样框架越来越完善。对于初学者希望看到Demo更完善） 六、dhroid 官方介绍： dhroid 是基于android 平台, 极速开发框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展.使你更快,更好的开发商业级别应用 开源地址: http://git.oschina.net/tengzhinei/dhroid 功能： Ioc容器: (用过spring的都知道)视图注入,对象注入,接口注入,解决类依赖关系 Eventbus: android平台事件总线框架,独创延时事件,事件管理轻松 Dhnet: 网络http请求的解决方案,使用简单,减少代码,自带多种网络访问缓存策略 adapter模块: 数据绑定轻松,不用写多余的adapter,天生网络支持(一行代码搞定加载,刷新问题) DhDb: android中sqlite的最轻量orm框架(增删改查轻松搞定) Perference: android自带Perference 升级版,让你的Perference更强大,更方便 工具集合 JSONUtil(安全处理json),ViewUtil(数据绑定更快) ThreadWorker(异步任务工具)… 优点：功能全面，有demo，作者也是为公司开发的框架。 缺点：文档方面现在不是很好，就eoe上的那些。 七、SmartAndroid 项目地址：http://www.aplesson.com/smartAndroid/demos 官方介绍： SmartAndroid是一套给 Android开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库以及简单的接口和逻辑结构，其目的是使开发人员更快速地进行项目开发。使用 SmartAndroid可以减少代码的编写量，并将你的精力投入到项目的创造性开发上。 功能： SmartAndroid 拥有全范围的类库，可以完成大多数通常需要的APP开发任务，包括： 异步网络操作相关所有功能、强大的图片处理操作、轻量级ORM数据库Sqlite库、zip操作 、动画特效、Html等解析采集、事件总线EventBus/Otto、Gson(Json)、AQuery、主流所有UI控件（例如：ActionbarSherlock，SlidingMenu，BottomView，Actionbar，DragListView等10多种UI库）等。 优点：功能非常全，超出你索要、文档完善（作者很全面，官方网站是web响应式网站，框架里功能有UI各种特效应该最全了，一直更新中） 缺点：jar包大点？（功能多不可避免，不是问题），在线文档（随响应式的手机访问也方便，但是网速慢就不好了，页面打开不是很流畅） 八、andBase 官方介绍： andbase是为Android开发者量身打造的一款开源类库产品 开源地址：https://code.jd.com/zhaoqp2010_m/andbase 功能： andbase中包含了大量的开发常用手段。如网络下载，多线程与线程池的管理，数据库ORM，图片缓存管理，图片文件下载上传，Http请求工具，常用工具类（字符串，日期，文件处理，图片处理工具类等），能够使您的应用在团队开发中减少冗余代码，很大的提高了代码的维护性与开发高效性，能很好的规避由于开发疏忽而导致常犯的错误。 andbase封装了大量的常用控件。如list分页，下拉刷新，图片轮播，表格，多线程下载器，侧边栏，图片上传，轮子选择，图表，Tab滑动，日历选择器等。 强大的AbActivity，您没有理由不继承它。继承它你能够获得一个简单强大可设置的操作栏，以及一系列的简单调用，如弹出框，提示框，进度框，副操作栏等。 提供效率较高图片缓存管理策略，使内存大幅度节省，利用率提高，效率提高。程序中要管理大量的图片资源，andbase提供简单的方法，几步完成下载与显示，并支持缩放，裁剪，缓存功能。 封装了大量常见工具类。包括日期，字符，文件，图片等各种处理函数，多而全。 用andbase大量减少handler的使用，而采用回调函数，代码更整洁。handler会产生大量代码，并且不好维护，andbase对handler进行了封装。 简单轻量支持注解自动建表的ORM框架（支持一/多对多的关联操作）。写sql，建表，工作量大，andbase提供更傻瓜异步增删改查工具类。 异步请求http框架，网络请求标准化，支持文件上传下载，get，post，进度显示。包含了异步与http请求的工具类，实用。 热情的支持群体。 优点：功能很全，demo做的好 、API文档完善、接近完美 缺点：希望文档更详细些。 九、AndroidAnnotations 项目地址：https://github.com/excilys/androidannotations 功能： 完全注解框架，一切皆为注解：声明控件，绑定控件，设置监听，setcontentview，长按事件，异步线程，全部通过注解实现。 优点：完全的注解，使开发起来更加便利，程序员写的代码也更少。 缺点：文档是全英文的加上功能比较少没有具体研究，由于一切都是注解，感觉效率不高，不过根据官方介绍说并不是使用的反射加载，所以效率比一般注解高很多。 十、volley 项目地址： https://github.com/smanikandan14/Volley-demo 功能：Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮异步加载网络图片、网络数据 优点：Google官方推荐，请看去年的开发者大会介绍。 缺点：功能比较少，只有网络数据加载和网络图片加载 总结以上的开发框架网上都可以下载源码，也有demo实例的。当然我没分析和对比框架的效率性能，但是都非常实用，其作者大部分是个人，都是些牛人或天才。你可以直接使用，也可以把有用跳出来用，至少有很多使用工具。如果有发现Bug，作者希望把bug交给他。 Afinal 和 xUtils简单实用但是demo和更新的问题。 KJFrameForAndroid 算是新出的，功能也多，效率也应该好，代码也注释多 用起来也很方便。 Dhroid 作者自己公司的框架，也可以直接请教。 SmartAndroid 强劲的框架功能俱全。 andBase 出来早各个方面算是完整的吧。 转自：http://blog.csdn.net/buddyuu/article/details/40503471]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android View的工作流程]]></title>
      <url>%2F2017%2F01%2F08%2Fandroid-view-workflow%2F</url>
      <content type="text"><![CDATA[前言写了那么多自定义View，但是对于其中的原理以及工作流程还不是很了解，所以这篇博文来总结和回顾一下Android开发中的View的工作流程，view的工作流程主要包含measure、layout和draw三大流程，在进入主题之前，先要理解一下几个概念，以便更好的理解view的三大流程。转载自《安卓复习之旅——View的工作流程》 了解ViewRoot和DecorViewViewRoot对应ViewRootImpl类，实现了ViewParent接口，它是连接WindowManager和DecorView的桥梁，WindowManager的实现类是WindowManagerImpl类:123456public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow; private IBinder mDefaultToken; 其中WindowManagerGlobal相当与一个代理类，WindowManagerImpl 中的实现的方法都是通过WindowManagerGlobal来具体实现的，我们来看看WindowManagerImpl 中的addView()方法：12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; 可以看出确实是通过WindowManagerGlobal的addView()方法来具体实现的，进入WindowManagerGlobal的addView()方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException("View " + view + " has already been added to the window manager."); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; //实例化ViewRootImpl root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; //连接WindowManager和DecorView root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; &#125; 由上面注释的代码可以看出ViewRootImpl是连接WindowManager和DecorView的桥梁。 DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况和Android版本及主体有关），上面的是标题栏，下面的是内容栏。在Activity中通过setContentView所设置的布局文件其实就是被加到内容栏之中的，而内容栏的id是content，在代码中可以通过ViewGroup content = （ViewGroup)findViewById(R.android.id.content)来得到content对应的layout。DecorView的结构图： View的绘制流程View的绘制流程是从ViewRootImpl的performTraversals()方法开始的，它经过measure、layout和draw三个流程才能最终将view绘制出来，其中measure测量view的宽高，layout确定view在父容器中的位置，draw负责将view绘制在屏幕上。view的绘制流程图： performTraversals()方法源码比较长，就不贴出来了，有兴趣可以去查看一下，从上面的流程图可以看出performTraversals会依次调用 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); - performLayout(lp, mWidth, mHeight); - performDraw();三个方法，这三个方法顶级view的三个流程，在 performMeasure()中会调用mView.measure()方法，mView.measure()又会调用onMeasure()方法对所有子元素进行测量，这个时候measure流程就从父容器传递到了子元素中，这样就完成了依次measure过程，performLayout()和performDraw()与performMeasure()过程是类似的，唯一的不同是performDraw()过程在draw方法中是通过dispatchDraw(canvas)方法来完成绘制的; 理解MeasureSpecMeasureSpec是一个32位的int值，高2位代表SpecMode,低30位代表SpecSize，SpecMode是指测量模式，SpecSize是指某种测量模式下的规格大小；MeasureSpec内部的一些常量：123456789101112131415161718192021 private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size,int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125;public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; measureSpec 将SpecMode和SpecSize打包成一个int值，一组SpecMode和SpecSize也可以打包成一个measureSpec 通过getMode和getSize可以得到对应的值；SpecMode有三种类型： UNSPECIFIED父容器没有对view有任何限制，要多大给多大； EXACTLY父容器已经检测出view所需要的精确大小，view的大小就是SpecSize所指定的值，它对应于LayoutParams中的match_parent和具体的数值两种模式； AT_MOST父容器指定一个可用的大小即SpecSize，view的大小不能超过这个大小，对应于layoutParams中的wrap——content； measureSpec 与LayoutParams有什么关系呢？当我们给view设置了LayoutParams后，系统会将LayoutParams在父容器的约束下转换成对应的measureSpec ；对于DecorView来说，在ViewRootImpl中的measureHierarchy方法中进行了measureSpec 的创建过程，desiredWindowWidth为屏幕宽度，desiredWindowHeight为屏幕高度；123childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); 进入getRootMeasureSpec方法：12345678910111213141516171819private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec; &#125; 这个方法是根据DecorView自身的LayoutParams来计算出对应的measureSpec ；对于普通view的measure过程是有viewgroup传递下来的，先看看viewgroup的measureChildWithMargins方法：1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; measureChildWithMargins方法会通过getChildMeasureSpec方法计算出子元素的MeasureSpec然后子元素进行measure，从代码可以看出子元素的MeasureSpec与父容器的MeasureSpec与自身的LayoutParams有关，此外，还与view的margin和padding有关，下面进入getChildMeasureSpec方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 这个方法主要作用是根据父容器的MeasureSpec与view自身的LayoutParams来确定子元素的MeasureSpec，参数中的padding指父容器已占用的大小。 View的三大流程measure过程measure过程要分两种情况，一种是普通view，一种是viewgroup： 1.view的measureview的measure方法是一个final类型的方法，意味着不能重写这个方法，在这个方法中调用了onMeasure方法，我们可以重写onMeasure方法。123456789101112131415public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ... &#125; 看看onMeasure方法的实现： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 调用setMeasuredDimension方法设置view的测量值，其中getSuggestedMinimumWidth()是系统默认提供的值，这里就不深究了，下面看看getDefaultSize方法： 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; 在UNSPECIFIED模式下，返回系统默认值，EXACTLY和AT_MOST模式下，返回measureSpec中的值；这里也可以得到一个结论：当我们直接继承一个view的自定义控件需要重写onMeasure方法去设置wrap_content时的自身大小，否则在布局中使用wrap_content的效果与match_parent一样，原因是当view设置为wrap_content时，模式是AT_MOST，通过前一篇文章中的getChildMeasureSpec方法可以知道，view的specSize就是parentSize；重写onMeasure的代码思路如下：1234567891011121314151617int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(viewWidth, viewHeight); &#125; else if(widthMode == MeasureSpec.AT_MOST )&#123; setMeasuredDimension(viewWidth, heightSize); &#125; else if(heightMode == MeasureSpec.AT_MOST )&#123; setMeasuredDimension(widthSize, viewHeight); &#125; 2.viewgroup的measure对于viewgroup来说，出了完成自己的measure过程，还要遍历子view的measure方法，各个子view完成对自身的measure过程，与view不同的是，viewgroup是一个抽象类，它是通过measureChildren（）方法开始measure，先看看measureChildren方法的代码：12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; 从以上代码可以看出，确实是会通过measureChild方法对每一个子view进行measure，1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; measureChild方法先得到子view的MeasureSpec，然后再调用子view的measure方法； view的measure过程是三大流程中最复杂的一个，measure完成以后，通过getMeasuredHeight()和getMeasuredWeight()可以得到view的测量高宽，但是在某些极端情况下，系统可能会多次measure才能得到最终的值，在这种情况下，在onMeasure中可能得到的值不是准确的。我们最好在onLayout中获取；还有一个需要注意的是，我们在onCreate、onStart和onResume中均得不到view的宽高，因为measure过程与activity的生命周期不是同步的； layout过程layout过程的作用是viewgroup来确定子元素的位置，当viewgroup的位置确定后，会遍历所有子元素并调用其layout方法，在layout方法中又会调用onLayout方法。先看viewgroup的layout方法：123456789101112@Override public final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125; &#125; 可以看出是调用父类的layout方法：12345678910111213141516171819202122232425262728293031323334353637383940public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; 首先通过setFrame确定view的四个顶点位置，此时父容器的位置也就确定了，接下来就会调用onLayout方法确定子元素的位置； protected void onLayout(boolean changed, int left, int top, int right, int bottom) {} onLayout方法并没有给出具体的实现，当继承特定的组件时，不需要我们重写onLayout方法，继承viewgroup时则需要重写onLayout方法。 draw过程draw的作用是将view绘制到屏幕上，view的绘制流程遵循以下几步： 绘制背景drawBackground(canvas); 绘制自己onDraw(canvas); 绘制子元素dispatchDraw(canvas); 绘制装饰onDrawForeground(canvas); 看看draw源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; ... &#125; view绘制过程的传递是通过 dispatchDraw(canvas)来实现的， dispatchDraw(canvas);会遍历所有的子元素的draw方法，view有一个特殊的方法：setWillNotDraw，先看一下源码;12345678910111213/** * If this view doesn't do any drawing on its own, set this flag to * allow further optimizations. By default, this flag is not set on * View, but could be set on some View subclasses such as ViewGroup. * * Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125; * you should clear this flag. * * @param willNotDraw whether or not this View draw on its own */ public void setWillNotDraw(boolean willNotDraw) &#123; setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK); &#125; 意思是如果一个view不需要绘制任何内容，那么设置这个标记位为TRUE后，系统会进行优化，默认情况下标记位为FALSE。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 高效开发工具库]]></title>
      <url>%2F2017%2F01%2F04%2Fandroid-efficient-tools%2F</url>
      <content type="text"><![CDATA[前言这篇文章介绍开发者如何学习提高以构建更好的app，我将分享一些自己受益过的教程和资料。 一. 使用Android studio的快捷键1. tips这里是一个使用Android studio的小建议集合，大家可以在里边找到不少提高效率的点子。 2. template使用Live templates可以节省coding时间：使用缩写快速输入方法或者循环eg: 输入 fbc 则快速速入了findViewById template入门：Android Studio Live Templates 值得试用的live template 集合：keyboardsurfer/idea-live-templates 自定义template，这里是Reto Meier写的一篇非常好的教程Writing More Code by Writing Less Code with Android Studio Live Templates，当然也可以从IntelliJ IDEA documentation获取更多细节。 二. Debugging App时用到的工具 Library methods count Android 的 library非常有用，但是太多的库也会是的app中方法数目快速增加，这个工具可以显示各个依赖库的方法数。 Stetho 使用Stetho，可以非常方便地监控app，尤其是网络流量。还可以监测并编辑SQLite，和Shared Preferences。 LeakCanary Android和java工程中可以的内存泄露监测工具。 Gradle, Please Chris broadFoot做的一个非常酷的一个library，只需要输入一个Library 的名字，就可以得到这个Library 的gradle依赖code，并且是该Library的最新版本，不要错过这个网站： Android Arsenal 这是一个分类查看Android Library、工具、工程的网站，很赞！ Android Tool Mac上的Android工具，可以进行录屏、截屏、安装apk，记录bug。 Butterknife Zelezny，可以根据选择的xml文件自动生成butterknife的注入代码。 ADB Idea Android和Intellij IDEA中可用的插件，卸载App、killApp、启动App、重启App、清除App数据、清除App数据并重启。 Another Adb tool 另一个可用adb工具。 Google Developers India , Android Developers 获取最新的Android信息 Android Dev weekly 订阅最新的Android资讯。 三. 向其它开发者学习从开源代码中，我们可以学习到不少技巧。 Google I/O Google I/O是谷歌每年举行的为期两天的开发者大会，会上会展示数百个程序示例。这个工程是会议上的应用程序。应用支持Android 4.0以及更高版本的设备，并针对各种形状和尺寸手机和平板进行优化。 Android App MVP Architecture 这个工程提供了一个比较详细的MVP框架的demo，并且使用了Dagger2、GreenDao、Rxjava、FastAndroidNetworking、PlaceHolderView、AndroidDebugDatabase。 Google Android Architecture Blueprints 在构建应用程序时，我们可能会碰到各种各样的问题，使得我们在测试、维护、扩展应用程序时比较困难。Google Android Architecture Blueprints提供了避免这些常见问题的演示程序，这个项目使用不同的架构和和工具实现了相同的app。 Plaid 提供了设计资讯和灵感，非常好的实践了material design。 Kickstarter kickstarter是一个全球性的社区，把创造力融入生活中，探索艺术、设计、电影、游戏、音乐等等相关的项目，并且可以把这些项目加入到收藏夹。 四. 其它 开源协议介绍：Developer’s Guide to Open Source Licenses 测试入门：Testing Guide Android 优化实践：Best Practices for Performance | Android Developers 依赖注入：Dagger 2 Dependency Injection for Android Developers Introduction to Dagger 2, Using Dependency Injection in Android: Part 1 Fragmented Podcast:Donn Felker 和 Kaushik Gopal在这里介绍Android开发者如何进阶，构建更好的软件。 Playbook for Developers：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 屏幕适配]]></title>
      <url>%2F2016%2F08%2F05%2Fandroid-screen-adapt%2F</url>
      <content type="text"><![CDATA[前言Android手机由于厂家未统一，以及某些厂家的标新立异，导致目前Android手机的分辨率和尺寸千奇百怪，无所不有。所以对Android手机的屏幕适配一直开发是一个大问题。要学习这方面的知识，并且掌握是Android开发的一个重头。 关于屏幕适配的dp、dpi、px一、分辨率,屏幕大小,密度1、分辨率。分辨率就是手机屏幕的像素点数，一般描述成屏幕的“宽×高”，安卓手机屏幕常见的分辨率有480×800、720×1280、1080×1920、1440x2560的2K屏等。720×1280表示此屏幕在宽度方向有720个像素，在高度方向有1280个像素。 2、屏幕大小。屏幕大小是手机对角线的物理尺寸，以英寸（inch）为单位。比如某某手机为“5寸大屏手机”，就是指对角线的尺寸，5寸×2.54厘米/寸=12.7厘米。 3、密度（dpi，dots per inch；或PPI，pixels per inch）。从英文顾名思义，就是每英寸的像素点数，数值越高当然显示越细腻。假如我们知道一部手机的分辨率是1080×1920，屏幕大小是5英寸，你能否算出此屏幕的密度呢？中学的勾股定理派上用场啦！通过宽1080和高1920，根据勾股定理，我们得出对角线的像素数大约是2203，那么用2203除以5就是此屏幕的密度了，计算结果是440。440dpi的屏幕已经相当细腻了。 二、实际密度与系统密度“实际密度”就是我们自己算出来的密度，这个密度代表了屏幕真实的细腻程度，如上述例子中的440dpi就是实际密度，说明这块屏幕每寸有440个像素。5英寸1080×1920的屏幕密度是440，而相同分辨率的4.5英寸屏幕密度是490。如此看来，屏幕密度将会出现很多数值，呈现严重的碎片化。而密度又是安卓屏幕将界面进行缩放显示的依据，那么安卓是如何适配这么多屏幕的呢？其实，每部安卓手机屏幕都有一个初始的固定密度，这些数值是120、160、240、320、480，我们权且称为“系统密度”也称为“广义密度”。大家发现规律没有？相隔数值之间是2倍的关系。一般情况下，240×320的屏幕是低密度120dpi，即ldpi；320×480的屏幕是中密度160dpi，即mdpi；480×800的屏幕是高密度240dpi，即hdpi；720×1280的屏幕是超高密度320dpi，即xhdpi；1080×1920的屏幕是超超高密度480dpi，即xxhdpi。安卓对界面元素进行缩放的比例依据正是系统密度，而不是实际密度。将一定范围的屏幕密度的设备视为一个特定的密度，比如屏幕密度在240左右的设备视为高密度（hdpi），在320左右的视为超高密度（xhdpi）等。 三、dp、sp、px的区别px：即像素，1px代表屏幕上一个物理的像素点；px单位不被建议使用，因为同样100px的图片，在不同手机上显示的实际大小可能不同，偶尔用到px的情况，是需要画1像素表格线或阴影线的时候，用其他单位如dp会显得模糊。dp也可写为dip，即density-independent pixel。你可以想象dp更类似一个物理尺寸，比如一张宽和高均为100dp的图片在320×480和480×800的手机上“看起来”一样大。而实际上，它们的像素值并不一样。dp正是这样一个尺寸，不管这个屏幕的密度是多少，屏幕上相同dp大小的元素看起来始终差不多大。sp：sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），所以目前主流应用字体大小已经改用dp，不用sp，省去用户手动调整字体适配的麻烦。 四、常规的安卓手机分辨率及其dpi和density的计算查看一下现在Android Studio自带的模拟器设备： 手机屏幕的dpi和density的计算：以Nexus5X为例： 手机大小5.2英寸，分辨率为1080×1920，那么该手机屏幕的：物理宽度：(1080/√￣(1080×1080+1920×1920))*5.2=2.55像素密度dpi：1080/2.55=420px/英寸密度density：420/160=2.625 五、转换公式dp和px之间的换算：dp=px * densitydp与px的换算要以系统密度为准在安卓中，系统密度为160dpi的中密度手机屏幕为基准屏幕，即320×480的手机屏幕。在这个屏幕中，1dp=1px。100dp在320×480（mdpi，160dpi）中是100px。那么100dp在480×800（hdpi，240dpi）的手机上是多少px呢？我们知道100dp在两个手机上看起来差不多大，根据160与240的比例关系，我们可以知道，在480×800中，100dp实际覆盖了150px。中密度和高密度的缩放比例，720×1280的系统密度为320，320×480的系统密度为160，320/160=2，那么在720×1280中，1dp=2px。同理，在1080×1920中，1dp=3px。ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12，我们发现，相隔数字之间还是2倍的关系。计算的时候，以mdpi为基准。比如在720×1280（xhdpi）中，1dp等于多少px呢？mdpi是4，xhdpi是8，2倍的关系，即1dp=2px。反着计算更重要，比如你用PhotoShop在720×1280的画布中制作了界面效果图，两个元素的间距是20px，那开发是多少dp呢？2倍的关系，那就是10dp！实际程序中根据不同机型，可以用代码计算相应的转换。当安卓系统字号设为“普通”时，sp与px的尺寸换算和dp与px是一样的。比如某个文字大小在720×1280的PS画布中是24px，那么告诉工程师，这个文字大小是12sp。实际开发过程中，常规用到的转换公式是： 12345678910111213141516171819202122232425/** * * @param context 上下文 * @param values dp值 * @return */ public static int dp2px(Context context, int values) &#123; float scale = context.getResources().getDisplayMetrics().density; return (int) (values * scale + 0.5f); &#125; public static int px2dip(Context context, float pxValue) &#123; float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; public static int px2sp(Context context, float pxValue) &#123; float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (pxValue / fontScale + 0.5f); &#125; public static int sp2px(Context context, float spValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (spValue * fontScale + 0.5f); &#125; 以dp2px为例，这里有一个小细节，根据上面的推导，return的结果应该是 (int) (values * density)，而结果会+0.5f再强转，原因是浮点型强转整型过程直接回去除小数部分，+0.5f相当于四舍五入的过程（小数部分大与0.5的+0.5f后会进一位）,结果显得更加精确。 二、资源文件夹之间的关系Android开发中，UI一般会制作多种图片素材，根据素材的分辨率大小，放在如下几个文件夹中：ldpi（120dpi）mdpi（160dpi）hdpi（240dpi）xdpi（320dpi）xxdpi（480dpi）xxxdpi（640dpi）以mdpi（160dpi）为基准可以看出系数比例关系：0.75：1：1.5：2：3：4 一、资源文件的加载很明显420dpi不属于上述文件分类中的任何一个，安卓手机分辨率千奇百怪，因此，上述文件夹不是指定具体的分辨率，而是一个范围，如ldpi（value&lt;120dpi），mdpi（120dpi&lt;value&lt;160dpi），以此类推，420dpi会加载xxdpi中的资源文件验证一下：这里有两张图片 将171×171放入xxdpi中，64×64放入xdpi中，用Nexus5X进行测试，应该加载哪个文件夹中的资源呢？123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:src="@mipmap/icon_life" /&gt;&lt;/RelativeLayout&gt; 结果如图： 这个到底是加载的哪个文件夹的图片呢，加载的是171还是64？我也不知道。那么我调换一下，将171×171放入xdpi中，64×64放入xxdpi中，如果图片变小了，那么证明，必然加载的是xxdpi文件夹的图片了。结果如图： 二、建议在xdhpi中作图安卓手机有这么多屏幕，我到底依据哪种屏幕作图呢？没有必要为不同密度的手机都提供一套素材，大部分情况下，一套就够了。现在手机比较高的分辨率是1080×1920，你可以选择这个尺寸作图，但是图片素材将会增大应用安装包的大小。并且尺寸越大的图片占用的内存也就越高。如果你不是设计ROM，而是做一款应用，我建议大家用PS在720×1280的画布中作图。这个尺寸兼顾了美观性、经济性和计算的简单。美观性是指，以这个尺寸做出来的应用，在720×1280中显示完美，在1080×1920中看起来也比较清晰；经济性是指，这个分辨率下导出的图片尺寸适中，内存消耗不会过高，并且图片文件大小适中，安装包也不会过大；计算的简单，就是1dp=2px啊，多好计算啊！做出来的图片，记着让界面工程师放进drawable-xhdpi的资源文件夹中。xhdpi (320dpi, 2x) 同iOS @2x 750x1334xxdpi (480dpi, 3x) 同iOS @3x 1242x2208（除以1.15，则等比缩放到android的1080*1920)淘宝选择2x标注，3x切图，具体讲解如下：http://blog.csdn.net/zx_android/article/details/51150156 三、屏幕的宽高差异在720×1280中作图，要考虑向下兼容不同的屏幕。通过计算我们可以知道，320×480和480×800的屏幕宽度都是320dp，而720×1280和1080×1920的屏幕宽度都是360dp。它们之间有40dp的差距，这40dp在设计中影响还是很大的。如下图蝴蝶图片距离屏幕的左右边距在320dp宽的屏幕和360dp宽的屏幕中就不一样。如果想消除这些比例差异，可以通过添加布局文件来实现。一般情况下，布局文件放在layout文件夹中，如果要单独对360dp的屏幕进行调整，你可以单做做一个布局文件放在layout-w360dp中；不过，最好是默认针对360dp的屏幕布局（较为主流），然后对320dp的屏幕单独布局，将布局文件放到layout-w320dp中；如果你想对某个特殊的分辨率进行调整，那么你可以将布局文件放在标有分辨率的文件夹中，如layout-854×480。 四、几个资源的文件夹在720×1280中做了图片，要让开发人员放到drawable-xhdpi的资源文件夹中，这样才可以显示正确。个人认为仅提供一套素材就可以了，可以测试一下应用在低端手机上运行是否流畅，如果比较卡顿，可以根据需要提供部分mdpi的图片素材，因为xhdpi中的图片运行在mdpi的手机上会比较占内存。以应用图标为例，xhdpi中的图标大小是96px，如果要单独给mdpi提供图标，那么这个图标大小是48px，放到drawable-mdpi的资源文件夹中。各个资源文件夹中的图片尺寸同样符合ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12的规律。 如果你把一个高2px的分割线素材做成了9.png图片，你想让细线在不同密度中都是2px，而不被安卓根据密度进行缩放，怎么办？你可以把这个分割线素材放到drawable-nodpi中，这个资源文件夹中的图片，将按照实际像素大小进行显示，而不会被安卓根据密度进行缩放。即在mdpi中细线是2px（2dp），在xhdpi中细线是2px（1dp）。 五、资源加载优先级Google官方文档显示如下：如果有最匹配的资源（e.g. 设备是HDPI，存在hdpi的资源），则删除其他的资源。如果没有最佳匹配资源，优先匹配更高dpi的资源，缩小合适的比例以后使用（e.g. 设备是HDPI，未能找到hdpi的资源，但是有xhdpi的资源，则把XHDPI的资源缩小的3/4以后使用），并排除其他的资源（Google解释说，因为执行缩小操作比执行放大操作更加方便，所以高dpi资源优先与低dpi资源，不过，个人认为对于大部分图片来说，大图缩小造成的失真应该是小于小图放大造成的失真）。如果没最佳匹配的资源，也不存在更高dpi的资源，则使用dpi更低的资源，并放大合适的比例以后使用（e.g. 设备为HDPI，未能找到hdpi以及更高的资源，单存在mdpi的资源，则把mdpi的资源放大到3/2以后使用），并删排除其他资源。原则上来说，dalvik优先使用符合设备dpi的资源，其次是dpi较低的高dpi资源，再次是dpi较高的高dpi资源，最后采用nodpi的资源，由此，根据设备自身的dpi的不同，不同dpi资源的优先级是有差异的（忽略mdpi&amp;hdpi）: 设备dpi优先级顺序（由高到低）tvdpi tvdpi&gt;hdpi&gt;xhdpi&gt;xxhdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpihdpi hdpi&gt;xhdpi&gt;xxhdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpixhdpi xhdpi&gt;xxhdpi&gt;hdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpixxhdpi xxhdpi&gt;xhdpi&gt;hdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpi另外，除了nodpi以外，使用其他dpi资源前，还需要根据缩放比进行缩小/放大操作。 六、项目实战 类似上图是美工标注后的高保真图，分辨率为640*1136，对应到安卓为720p（会有细微偏差），ios为2@，安卓开发同学拿到图，下面的工作就比较简单了。 单位换算：只需要将上面的px/2，则得到代码中距离需要的dp，字体大小需要的sp。 切图处理：美工的切图一律放入xhdpi文件即可 这里我举两个适配的例子帮助大家更好的理解。 【代码适配】上图大家觉得怎么布局比较好？解答：【我加入的圈子】左边空出固定距离，右边【&gt;】空出固定距离，中间铺满屏幕，这样可以让360dp甚至更大的手机，不至于让页面内容缩在中间一小块。再看下下面的布局： 【动态布局适配】上图又怎么布局呢？做到各种机型适配。我在项目中的做法是，用（屏幕的宽度（像素）-两边的间距-中间间距）/3，这样得到每个图片的宽度，然后图片的高度设置成高图片的宽度相等（当然也可以重写view，自动设置宽等于高）代码如下： 1234LinearLayout.LayoutParams linearParams = (LinearLayout.LayoutParams)pic.getLayoutParams(); linearParams.width =(context.getResources().getDisplayMetrics().widthPixels-DisplayUtil.dip2px(context, 44)) / 3; linearParams.height = linearParams.width; pic.setLayoutParams(linearParams); //使设置好的布局参数应用到控件 【比重适配】weight也可以搞定了！的确，可以用比重去做，三个图片各占比为1，再调整下边距，但是高度怎么办，前面说过上，可以重写view,让这个view的高跟宽度相等，这种方式也可以。 【另类适配】 应该大家有看到有人提到过纯代码适配，就在在Java代码中动态设置每个view的宽跟高，宽跟高是通过计算得出的。比如设计图是640 1136，这个view的宽在640的设计图上是20px。所以有同学会通过DisplayMetrics metrics = res.getDisplayMetrics();screenWidth = metrics.widthPixels screenHeight = metrics.heightPixels;拿到当前屏幕的宽跟高，如果当前手机屏幕是720 1280，及screenWidth =720，screenHeight =1280，那么当前的view的宽度等于screenWidth /640 * view的宽度，这样的确非常完美，每部手机都可以等比的缩放。但是代码维护跟开发难度就是成倍的增加，不建议使用。 【不同的layout适配】 在res目录下创建不同的layout文件夹，比如：layout-640x360、layout-800x480……所有的layout文件在编译之后都会写入R.java里，而系统会根据屏幕的大小自己选择合适的layout进行使用。这种现在基本不会有人这么适配，不展开讨论。 【dimen尺寸资源文件的使用】dimen.xml在values文件夹下面12345&lt;resources&gt; &lt;!-- Default screen margins, per the Android Design guidelines. --&gt; &lt;dimen name="btn_width"&gt;16dp&lt;/dimen&gt; &lt;dimen name="btn_height"&gt;16dp&lt;/dimen&gt;&lt;/resources&gt; 布局中的使用： &lt;Button android:text="@string/test_dimen1" android:id="@+id/Button01" android:layout_width="@dimen/btn_width" android:layout_height="@dimen/btn_height"/&gt; 文件夹含义：values-v11 ——-API 11+代表android 3.0 +，意思是在API11设备上，该目录下的dimens.xml代替res/values/dimens.xmlvalues-480x320、values-800x480等 ————意思是在不同分辨率下，该目录下的dimens.xml代替res/values/dimens.xml]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 开发中常用的支持库]]></title>
      <url>%2F2016%2F06%2F11%2Fandroid-library%2F</url>
      <content type="text"><![CDATA[转载自《Android开发中那些常见到让人忽视的基础知识》 前言许多情况下，某项功能可能对应用开发者很有用，但是添加到 Android 框架却并不合适。例如，某个应用可能仅需要用于特定用例的某项功能，如在不同版本的 Android 系统之间顺畅切换。为了解决这一问题，Android SDK 添加了多个库，这些库统称为 Android 支持库。如果应用开发者想要在应用中集成库功能，他们可以添加其中任意一个库。 Android支持库（Android Support Library） 向后兼容版本的框架组件 什么是向后兼容？-让在旧版本 Android 平台上运行的应用支持为新版本平台推出的功能。例如，应用在依赖于框架类的 5.0（API 级别 21）版本以下的 Android 系统上运行时，将无法显示 Material Design 元素，因为该版本的 Android 框架不支持 Material Design。但是，如果此应用添加了支持库的 appcompat 库，则可以访问 API 级别 21 中具有的许多功能，其中包括对 Material Design 的支持。 用于实现建议的 Android 布局模式的UI元素 如DrawerLayout，RecyclerView等 支持不同的设备类型 如Android TV，Android Auto等 其他实用功能 如运行时权限等 支持库种类： support-v4用在 Android 2.3（API 级别 9） 或更高版本上。 support-v7用在 Android 2.3（API 级别 9）或更高版本上，依赖v4 support-v8 support-v13 support-v14 support-v17 注解支持库 设计支持库 各种支持库功能描述v4 支持库这些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。注：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果在 Gradle 脚本中列出了 support-v4，APK 将包含所有的 v4 模块。不过，要减少 APK 大小，建议仅列出应用需要的特定模块。 v4 compat 库为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-compat:24.2.0 v4 core-utils 库提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-core-utils:24.2.0 v4 core-ui 库实现各种 UI 相关组件，例如 ViewPager、NestedScrollView 和 ExploreByTouchHelper。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-core-ui:24.2.0 v4 media-compat 库向后移植部分媒体框架，包括 MediaBrowser 和 MediaSession。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-media-compat:24.2.0 v4 fragment 库添加对使用片段封装用户界面和功能的支持，从而使应用能够提供可以在大屏幕设备与小屏幕设备之间进行调节的布局。此模块依赖于 compat、core-utils、core-ui 和 media-compat。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-fragment:24.2.0 Dalvik 可执行文件分包支持库此库可以为使用多个 Dalvik Executable (DEX) 文件开发应用提供支持。引用超过 65536 个方法的应用须使用 Dalvik 可执行文件分包配置。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:multidex:1.0.0 v7 支持库一些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。这些库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。 v7 appcompat 库此库添加了对操作栏用户界面设计模式的支持。此库包含对 Material Design 用户界面实现的支持。注：此库依赖于 v4 支持库。下面是 v7 appcompat 库中包含的一些关键类： ActionBar - 提供操作栏用户界面模式的实现。 AppCompatActivity - 添加一个应用 Activity 类，此类可作为使用支持库操作栏实现的 Activity 的基础类。 AppCompatDialog - 添加一个对话框类，此类可作为 AppCompat 主题对话框的基础类。 ShareActionProvider - 包含对可以添加到操作栏中的标准化分享操作（例如电子邮件或发帖至社交应用）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:appcompat-v7:24.2.0 v7 cardview 库此库添加了对 CardView 小部件的支持，让您能够在卡片内显示信息，从而使应用具备一致的外观。这些卡片对 Material Design 实现非常有用，并在电视应用布局中广为使用。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:cardview-v7:24.2.0 v7 gridlayout 库此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:gridlayout-v7:24.2.0 v7 mediarouter 库此库可以提供 MediaRouter、MediaRouteProvider 和支持 Google Cast 的相关媒体类。一般而言，利用 v7 mediarouter 库中的 API，您可以控制当前设备到外部屏幕、扬声器和其他目标设备的媒体渠道和流的路由。此库包含的 API 可以用于发布应用特定的媒体路由提供程序、发现和选择目标设备，以及检查媒体状态，等等。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:mediarouter-v7:24.2.0支持库 r18 中引入的 v7 mediarouter 库 API 在后续版本的支持库中可能会发生更改。目前，建议仅使用与 Google Cast 有关的库。 v7 palette 库v7 palette 支持库包含 Palette 类，此类让您可以从图像中抽取突出颜色。例如，音乐应用可以使用 Palette 对象从专辑封面抽取主要颜色，然后使用这些颜色创建一个色彩协调的歌曲标题卡。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:palette-v7:24.2.0 v7 recyclerview 库recyclerview 库添加了 RecyclerView 类。此类能够为 RecyclerView 小部件提供支持，RecyclerView 是一种通过提供有限的数据项窗口有效显示大数据集的视图。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:recyclerview-v7:24.2.0 v7 Preference 支持库首选项软件包提供的 API 支持添加 preference 对象（例如 CheckBoxPreference 和 ListPreference），方便用户修改 UI 设置。v7 Preference 库添加了对接口（例如 Preference.OnPreferenceChangeListener 和 Preference.OnPreferenceClickListener）以及类（例如 CheckBoxPreference 和 ListPreference）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:preference-v7:24.2.0 v8 支持库此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。此库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。v8 renderscript 库此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。它添加了对 RenderScript 计算框架的支持。 android.support.v8.renderscript 软件包中包含这些 API。请注意，在应用中添加这些 API 的步骤与添加其他支持库 API 迥然不同。注：Android Studio 和 Gradle 构建支持使用带支持库的 RenderScript。renderscript 库位于 build-tools/$VERSION/renderscript/ 文件夹中。以下示例显示了此库的 Gradle 构建脚本属性：1234defaultConfig &#123; renderscriptTargetApi 18 renderscriptSupportModeEnabled true&#125; v13 支持库此库旨在用于 Android 3.2（API 级别 13）及更高版本。它添加了对带有 (FragmentCompat) 类和其他片段支持类的 Fragment 用户界面模式的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-v13:24.2.0 v14 Preference 支持库android.support.v14.preference 软件包提供的 API 添加了对首选项接口（例如 PreferenceFragment.OnPreferenceStartFragmentCallback 和 PreferenceFragment.OnPreferenceStartScreenCallback）以及类（例如 MultiSelectListPreference 和 PreferenceFragment）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:preference-v14:24.2.0 适用于电视的 v17 Preference 支持库android.support.v17.preference 软件包提供的 API 可以在电视设备上提供首选项接口，包括对 LeanbackListPreferenceDialogFragment.ViewHolder.OnItemClickListener 接口和类的支持，例如 BaseLeanbackPreferenceFragment 和 LeanbackPreferenceFragment。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:preference-leanback-v17:24.2.0 v17 Leanback 库android.support.v17.leanback 软件包提供的 API 支持在电视设备上构建用户界面。它为电视应用提供了一些重要的小部件。一些值得注意的类包括：BrowseFragment - 一种用于创建主要布局的片段，主要布局用于浏览类别和媒体项目。 DetailsFragment - 用于 Leanback 细节屏幕的包装器片段。 PlaybackOverlayFragment - 用于显示播放控件及相关内容的 DetailsFragment 子类。 SearchFragment - 用于处理搜索的片段。片段可以接收用户的搜索请求并将其传递给应用提供的 SearchResultProvider。SearchResultProvider 可以将搜索结果返回给 SearchFragment，后者会将结果渲染到 RowsFragment 中。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:leanback-v17:24.2.0 注解支持库注解软件包提供的 API 支持向应用中添加注解元数据。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-annotations:24.2.0 设计支持库设计软件包提供的 API 支持向应用中添加 Material Design 组件和模式。设计支持库添加了对应用开发者依赖的各种 Material Design 组件和模式的支持，例如抽屉式导航栏、浮动操作按钮 (FAB)、快捷信息栏和标签页。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:design:24.2.0 自定义标签页支持库自定义标签页软件包提供的 API 支持向应用中添加自定义标签页并对其进行管理。自定义标签页支持库添加了对自定义标签页服务和自定义标签页回调等各种类的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:customtabs:24.2.0 百分比支持库百分比软件包提供的 API 支持向应用中添加基于百分比的尺寸并对其进行管理。百分比支持库添加了对 PercentLayoutHelper.PercentLayoutParams 接口和各种类的支持，例如 PercentFrameLayout 和 PercentRelativeLayout。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:percent:24.2.0 适用于电视的应用建议支持库应用建议软件包提供的 API 支持向电视设备上运行的应用中添加内容建议。应用库添加了对注解（例如 ContentRecommendation.ContentMaturity 和各种类（例如 ContentRecommendation 和 RecommendationExtender）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:recommendation:24.2.0 参考文章：https://developer.android.com/topic/libraries/support-library/features.html#v4 建议：在对Android有一定了解的情况下，可以适当看一下Android官方文档，并做好记录，避免每次忘了都得去Google。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android StatusBar学习]]></title>
      <url>%2F2016%2F05%2F19%2Fandroid-statusbar%2F</url>
      <content type="text"><![CDATA[前言一直以来，iOS 设备上状态栏背景色和图标文字颜色的灵活可变性始终受到设计人员的青睐，有意地恰当地融入到 App 的各种界面设计当中，更好地提升用户体验。 由于系统的限制，在老版本的安卓系统中，Android App 无法做到这些，产生一些设计上的遗憾。幸运的是，自4.4 版本（API 19)以后，Android 系统开始支持状态栏的定制，并被纳入 Android 设计规范当中，Android App 在设计上迈出了重要的一步。 “沉浸式状态栏” VS “透明状态栏”一般来说，Android 默认的状态栏样式表现为黑底白字，如果我们应用的标题栏背景色也为黑色，那就能与状态栏很好地衔接在一起，体验极佳。反之，如果为其他的颜色，整个界面的呈现效果就会大打折扣。 幸运的是，Android 4.4 版本开始，系统提供了相应的 API，支持状态栏全透明化，界面 Content View 可以延伸到状态栏上，填充状态栏背景色。而在 Android 5.0 版本开始，系统在此基础上做了进一步优化和规范，能够实现动态改变状态栏背景色，在透明度上默认呈现为半透明化，可定制化程度更高。 在此基础上，最终要做到我们的应用呈现在 Android 各个系统版本上的效果如图所示： 关于 Android 4.4 版本开始的状态栏变化，许多人喜欢称之为“沉浸式状态栏”，但从系统提供的 API 命名上可以看出，核心词汇为 “Translucent”，故准确来讲，这种效果又应该称之为“透明状态栏”。知乎上对于这两种叫法也颇有争议，具体内容可参考话题：为什么在国内会有很多用户把「透明栏」（Translucent Bars）称作 「沉浸式顶栏」？。可能对于设计师而言，沉浸式还是透明式的称呼有所区别，但对于广大开发者而言，无足轻重，我们所关注的应该是如何实现这种效果，并能够很好的兼容到各个版本中。 相关 API 介绍一般来说，目前在 Android 项目中我们都会使用 Toolbar 替代 ActionBar 来实现导航栏，除此之外，要实现透明状态栏效果，还需要了解两个相关 API，下面逐一介绍一下： 一：&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;也可以在代码中实现（据说，在代码中实现兼容性更好，style 资源中设置的方式在某些国产手机厂商定制的系统中存在一些问题）:1234if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); local LayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);&#125; 顾名思义，该属性能够实现透明状态栏效果，是在 Android 4.4 版本引入的，也就是兼容至 API 19 及以上版本。使用该属性设置主题后，内容布局向上延伸至状态栏，并且在不同版本的系统中呈现效果也有所区别，如图所示： 显然，在 API 19 及更高版本上，Toolbar 内容延伸至状态栏上去了，出现重叠问题，此时，就需要使用到另一个属性了。 二：android:fitsSystemWindows=&quot;true&quot; Boolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity. 用在 layout 布局文件中。官方文档给出了很明确的介绍，大致是说能够将使用该属性的视图与系统窗口（如状态栏）保持一定的 padding 间距。所以如果我们在 toolbar 中设置了该属性，就能够解决 true 配置带来的视图延伸问题，使呈现效果达到文章开始所示图中的效果。 使用案例分析res/values/styles 文件中定义基础主题样式：123&lt;style name="BaseTheme" parent="Theme.AppCompat.Light.NoActionBar"/&gt; &lt;style name="AppTheme" parent="BaseTheme"&gt; &lt;/style&gt; res/values-v19/styles 文件中定义兼容主题样式：123&lt;style name="AppTheme" parent="BaseTheme"&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;/style&gt; 然后在 AndroidManifest.xml 文件中使用全局主题样式：1234567&lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="Samples" android:supportsRtl="true" android:name=".MyApplication" android:theme="@style/AppTheme"&gt; 新建一个 layout 布局文件，单独定义 toolbar 内容，在应用中的其他 Activity 界面布局中使用 include 标签潜入引用：123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v7.widget.Toolbar xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/tb_toolbar" android:layout_width="match_parent" android:layout_height="wrap_content" android:minHeight="?actionBarSize" android:background="@color/colorPrimary" android:fitsSystemWindows="true" app:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:title="@string/app_name" app:titleTextColor="@android:color/white"&gt;&lt;/android.support.v7.widget.Toolbar&gt; 这里使用android:fitsSystemWindows=&quot;true&quot;属性解决内容试图向上延伸的问题。实际上，也可以使用 android:paddingTop=&quot;@dimen/toolbar_padding_top&quot; 的方式解决，toolbar_padding_top 间距为状态栏高度，在大多数机器上状态栏高度为 25dp，当然也可以通过代码动态获取状态栏高度并设置到 Toolbar 的 paddingTop 属性上。需要注意的是，这里要做兼容判断，比如在 res/values/dimens.xml 中定义toolbar_padding_top 高度为 0dp，在 res/values-v19/dimens.xml 中为 25dp，确保兼容 Android 4.4 以下版本。 基本上，做到这些就能够实现文章开头处图中的效果。值得注意的是，有时候如果想在 Android 5.0 及以上版本的系统中也做到全透明效果，或者说状态栏与导航栏的颜色一致，还可以做进一步兼容处理，毕竟自 5.0 版本开始，系统对于状态栏背景色的定制提供了更好的 API。如 res/values-v21/styles.xml 中定义： 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;style name="AppTheme" parent="BaseTheme"&gt; &lt;item name="android:colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="android:colorPrimaryDark"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="android:colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 说明一点，使用这种处理方式后，5.0 系统中应用的状态栏背景色可随意定制，同时与使用 &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 样式有所不同的是，该处理方式不会引起内容视图的向上延伸，所以不需要在 layout 布局文件中额外添加 android:fitsSystemWindows=”true” 属性。当然，添加了也无所谓，毕竟还要兼容 4.4 到 5.0 之间的版本。 状态栏白底黑字前面我们说过，虽然说 4.4 版本开始，可以实现透明状态栏效果，也就是可以通过各种手段实现修改状态栏背景色，但是状态栏图标和文字的颜色默认为白色，这个是无法像 iOS 系统那样，根据应用的整体色调动态修改。如果恰好 Toolbar 的背景色为白色，为了保持一致，将状态栏背景色调为白色的话，就会与状态栏的白色内容发生冲突，导致其内容无法凸显，这个体验肯定无法被用户接受。 所以，遇见这种 Toolbar 或者说导航栏背景色为白色的情况，一般有两种处理方式：第一种，不修改状态栏背景色，通常默认为黑色背景白色内容；第二种，修改状态栏背景色为淡黑色，这样既能显示状态栏内容，又能与白色导航栏弱显衔接，比如支付宝 App 就是这么做的： 像上图这种处理方式较黑色状态栏来说，相对缓和一些，那能不能做到修改状态栏内容的颜色呢，比如白底黑字？大家知道，Android 系统是开源的，国内的各家手机厂商都做了一些自己的定制，像部分厂商定制的系统就提供了相应的 API 供开发人员做适配工作。比如，部分厂商就提供了相应的 API 来修改状态栏内容颜色，实现状态栏白底黑字效果，如图： 具体做法就是，在代码中判断系统类型，与提供修改状态内容颜色的系统匹配，使用其特定的 API 操作即可。目前开放这种定制 API 的系统已知有 MIUI 和 Flyme 系统，具体实现代码可参考： 小米 MIUI 6 系统 魅族 Flyme 系统 其实，在 Android 6.0（API 23）及更高的版本上，系统也开始提供了对应的 API 来实现浅色调背景的状态栏效果，可将状态栏图标和文字内容改为黑色样式，实现方式为：12345if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; getWindow().getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); getWindow().setStatusBarColor(Color.TRANSPARENT);&#125; 但是不知国内厂商在定制系统时是否对此有做处理，能否兼容这个 API ？不过，貌似微博 App 是这么做的，大家感兴趣地不妨一试。 注意事项除了上述 Toolbar 与 状态栏在背景色上的衔接，App 中常见还有这样一种设计，以微博个人主页为例，如图所示： 页面顶部的图片内容延伸至状态栏中，这种做法其实就是单独使用 &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 样式，不在 layout 布局文件中添加 android:fitsSystemWindows=&quot;true&quot;属性即可。 还有一点，通常我们会在资源文件中定义不同版本的主题样式，再在 标签中统一设置，然后所有的 Activity 都能使用这个主题样式。但存在这样一种情况，Activity 由不同的 Fragment 组成，然后不同 Fragment 在状态栏的呈现上有所不同，比如有的 Fragment 顶部使用 Toolbar 与状态栏衔接，有的顶部直接使用图片延伸至状态栏上甚至不会用到 Toolbar，如图所示： 由于 Fragment 是无法像 Activity 那样在 AndroidManifest.xml 中单独设置主题样式的，所以这里可以这样做：宿主 Activity 还是使用透明样式，以满足图片延伸的 Fragment 页面效果，其他使用 Toolbar 的 Fragment，在其 Layout 布局文件顶部单独定义一个 View，让其延伸至状态栏，然后在代码中根据不同版本系统设置其高度，4.4 版本以下设置该 View 高度为0，4.4 及以上版本设置为设备状态栏高度，通过代码获取状态高度的方式如下：12345678910/** * 获取状态栏高度 * @param activity * @return */public static int getStatusBarHeight(Activity activity)&#123; Rect rect = new Rect(); activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(rect); return rect.top==0 ? 60 : rect.top;&#125; 最后再补充一点，大家知道，长按 Toolbar 中 Menu Item 时会显示一个 Toast 提示，内容来自 Item 定义时对应的 title 属性，通常显示如图所示： 但是，如果你误将 fitsSystemWindows 属性设置在了 style 样式文件中，比如：123&lt;style name="BaseTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="android:fitsSystemWindows"&gt;true&lt;/item&gt;&lt;/style&gt; 将会导致下图效果：可见，Menu Options Item 长按时弹出的 Toast 样式没了内容间距，显然很丑。所以，记得将该属性设置在正确的布局文件中，不要设置成全局的。 相关拓展以上便是有关 Android 4.4 开始的状态栏背景色相关知识，可以看出 4.4 、5.0 、6.0 版本作为三个分水岭，根据需要做好相关适配工作即可。还有一种通过 setSystemUiVisibility() 方法设置状态栏的方式，还能实现状态栏的显示与隐藏交互效果，具体可参考这篇文章： http://blog.csdn.net/guolin_blog/article/details/51763825 GitHub 上对于 Android 4.4 版本开始的状态栏背景色的处理有一个开源库，感兴趣地朋友也可借鉴参考一番，地址如下： https://github.com/jgilfelt/SystemBarTint 有关 Toolbar 替换 ActionBar 的使用，可以我之前总结的一篇文章，地址为： http://yifeng.studio/2016/10/12/android-toolbar/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio必备插件整理]]></title>
      <url>%2F2016%2F03%2F15%2Fandroid-studio-plugin%2F</url>
      <content type="text"><![CDATA[前言Android studio常用插件，可极大简化开发，增强开发效率。 1 Android ButterKnife ZeleznyButterKnife 注解生成器，使用起来非常简单方便，使用ButterKnife的有福了！配合ButterKnife实现注解，从此不用写findViewById，想着就爽啊。在Activity，Fragment，Adapter中选中布局xml的资源id自动生成butterknife注解。 2 SelectorChapek for Android设计师给我们提供好了各种资源，每个按钮都要写一个selector是不是很麻烦？这么这个插件就为解决这个问题而生，你只需要做的是告诉设计师们按照规范命名就好了，其他一键搞定。按照不同状态(normal、pressed)的标准命名后，右键文件树Generate Android Selectors见inmite/android-selector-chapek · GitHub。 通过资源文件命名自动生成Selector文件。 3 GsonFormat快速将json字符串转换成一个Java Bean，免去我们根据json字符串手写对应Java Bean的过程。现在大多数服务端api都以json数据格式返回，而客户端需要根据api接口生成相应的实体类，这个插件把这个过程自动化了，赶紧使用起来吧。 4 Android Parcelable Code GeneratorAndroid中的序列化有两种方式，分别是实现Serializable接口和Parcelable接口，但在Android中是推荐使用Parcelable，只不过我们这种方式要比Serializable方式要繁琐，那么有了这个插件一切就ok了。JavaBean序列化，快速实现Parcelable接口。 5 Genymotion这个不解释,速度较快的android模拟器!!! 6 Android Code Generator根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。 7 CodeGlance在右边可以预览代码，实现快速定位 8 findBugs-IDEA查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…） 9 ADB WIFI使用wifi无线调试你的app，无需root权限也可参考以下文章：Android wifi无线调试App新玩法ADB WIFI 10 AndroidPixelDimenGeneratorAndroid Studio自动生成dimen.xml文件插件 11 Android Styler根据xml自动生成style代码的插件Usage: copy lines with future style from your layout.xml file paste it to styles.xml file with Ctrl+Shift+D (or context menu) enter name of new style in the modal window your style is prepared! 12 Android Drawable Importer这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片） 13 LeakCanary帮助你在开发阶段方便的检测出内存泄露的问题，使用起来更简单方便。可以参考以下文章：LeakCanary 中文使用说明 14 RemoveButterKnifeButterKnife这个第三方库每次更新之后，绑定view的注解都会改变，从bind,到inject，再到bindview，搞得很多人都不敢升级，一旦升级，就会有巨量的代码需要手动修改，非常痛苦当我们有一些非常棒的代码需要拿到其他项目使用，但是我们发现，那个项目对第三方库的使用是有限制的，我们不能使用butterknife，这时候，我们又得从注解改回findviewbyid针对上面的两种情况，如果view比较少还好说，如果有几十个view，那么我们一个个的手动删除注解，写findviewbyid语句，简直是一场噩梦（别问我为什么知道这是噩梦）所以，这种有规律又重复简单的工作为什么不能用一个插件来实现呢？于是RemoveButterKnife的想法就出现了。具体介绍 15 AndroidProguardPlugin一键生成项目混淆代码插件，值得你安装~(不过目前可能有些第三方项目的混淆还未添加完全) 16 Sexy Editor设置AS代码编辑区的背景图 17 folding-plugin布局文件分组的插件 18 Android-DPI-CalculatorDPI计算插件使用：或者： 19 Android Studio Prettify可以将代码中的字符串写在string.xml文件中选中字符串鼠标右键选择图中所示这个插件还可以自动书写findViewById 20 Material Theme UI添加Material主题到你的AS 21 CheckStyle-IDEACheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。 22 ECTranslationAndroid Studio Plugin,Translate English to Chinese. Android Studio 翻译插件,可以将英文翻译为中文。 23 WakaTime记录你在IDE上的工作时间 24 AndroidWiFiADB无线调试应用 25 AndroidLocalizationer可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件 26 TranslationPlugin又一翻译插件,可中英互译。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android自定义控件——绘图]]></title>
      <url>%2F2016%2F01%2F11%2Fandroid-draw%2F</url>
      <content type="text"><![CDATA[前言之前学习了Android自定义控件的动画，得到了很大的提升。所以赶紧学习学习自定义控件的绘图，把以前的知识整理整理，研究研究Android的各种特效，android的特效真是其它平台无法比拟的，而且一个漂亮的UI交互，会给APP增色不少。 一、概述及基本几何图形绘制一、Paint和Canvas像我们平时画图一样，需要两个工具，纸和笔。Paint就是相当于笔，而Canvas就是纸，这里叫画布。 所以，凡有跟要要画的东西的设置相关的，比如大小，粗细，画笔颜色，透明度，字体的样式等等，都是在Paint里设置；同样，凡是要画出成品的东西，比如圆形，矩形，文字等相关的都是在Canvas里生成。 1、Paint的基本设置函数 paint.setAntiAlias(true);//抗锯齿功能 paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 Paint.Style.FILL :填充内部 Paint.Style.FILL_AND_STROKE ：填充内部和描边 Paint.Style.STROKE ：仅描边 paint.setStrokeWidth(30);//设置画笔宽度 paint.setShadowLayer(float radius, float dx, float dy, int color);//设置阴影，radius:阴影的倾斜度，dx:水平位移，dy:垂直位移 2、示例1、首先新建一个工程，把默认的XML改成FrameLayout布局，布局代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/root" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.try_paint_blog.MainActivity" &gt; &lt;/FrameLayout&gt; ``` **这里有个特别要注意的地方，给根结点FrameLayout加一个ID号，后面用来在它的内部添加视图用的**#### 2、然后新建一个视图类，派生自View，想要自由实现的东西，都在onDraw()函数中绘制返回``` javapublic class MyView extends View &#123; Context m_context; public MyView(Context context) &#123; super(context); // TODO Auto-generated constructor stub m_context=context; &#125; //重写OnDraw（）函数，在每次重绘时自主实现绘图 @Override protected void onDraw(Canvas canvas) &#123; // TODO Auto-generated method stub super.onDraw(canvas); //设置画笔基本属性 Paint paint=new Paint(); paint.setAntiAlias(true);//抗锯齿功能 paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 Style.FILL/Style.FILL_AND_STROKE/Style.STROKE paint.setStrokeWidth(5);//设置画笔宽度 paint.setShadowLayer(10, 15, 15, Color.GREEN);//设置阴影 //设置画布背景颜色 canvas.drawRGB(255, 255,255); //画圆 canvas.drawCircle(190, 200, 150, paint); &#125; &#125; 3、视图类写好了，下面就要将其加入到Activity中，让它显示出来，在MainActiviy中添加如下代码：123456789101112public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FrameLayout root=(FrameLayout)findViewById(R.id.root); root.addView(new MyView(MainActivity.this)); &#125; &#125; 三、基本几何图形绘制1、画直线void drawLine (float startX, float startY, float stopX, float stopY, Paint paint) startX:开始点X坐标 startY:开始点Y坐标 stopX:结束点X坐标 stopY:结束点Y坐标 123456Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(5);//设置画笔宽度 canvas.drawLine(100, 100, 200, 200, paint); 2、多条直线void drawLines (float[] pts, Paint paint) void drawLines (float[] pts, int offset, int count, Paint paint) pts:是点的集合，大家下面可以看到，这里不是形成连接线，而是每两个点形成一条直线，pts的组织方式为｛x1,y1,x2,y2,x3,y3,……｝ 1234567Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(5);//设置画笔宽度 float []pts=&#123;10,10,100,100,200,200,400,400&#125;; canvas.drawLines(pts, paint); 3、点void drawPoint (float x, float y, Paint paint); float X：点的X坐标 float Y：点的Y坐标 123456Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 canvas.drawPoint(100, 100, paint); 4、多个点void drawPoints (float[] pts, Paint paint) void drawPoints (float[] pts, int offset, int count, Paint paint) float[] pts:点的合集，与上面直线一直，样式为｛x1,y1,x2,y2,x3,y3,……｝ int offset:集合中跳过的数值个数，注意不是点的个数！一个点是两个数值； count:参与绘制的数值的个数，指pts[]里的数值个数，而不是点的个数，因为一个点是两个数值 1234567Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 float []pts=&#123;10,10,100,100,200,200,400,400&#125;; canvas.drawPoints(pts, 2, 4, paint); 同样是上面的四个点：（10，10）、（100，100），（200，200），（400，400），drawPoints里路过前两个数值，即第一个点跳过，画出后面四个数值代表的点，即第二，第三个点。最后第四个点没画。 5、矩形工具类RectF与Rect这两个都是矩形辅助类，区别不大，用哪个都行，根据四个点构建一个矩形结构；在画图时，利用这个矩形结构可以画出对应的矩形或者与其它图形Region相交、相加等等； RectF构造函数有下面四个，但最常用的还是第二个，根据四个点构造出一个矩形； RectF() RectF(float left, float top, float right, float bottom) RectF(RectF r) RectF(Rect r) Rect构造函数如下，最常用的也是根据四个点来构造矩形 Rect() Rect(int left, int top, int right, int bottom) Rect(Rect r) 6、矩形void drawRect (float left, float top, float right, float bottom, Paint paint) void drawRect (RectF rect, Paint paint) void drawRect (Rect r, Paint paint) 第一个的写法是直接传入矩形的四个点，画出矩形 第二、三个构造函数是根据传入RectF或者Rect矩形变量来指定所画的矩形的 123456789101112Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 canvas.drawRect(10, 10, 100, 100, paint);//直接构造 RectF rect = new RectF(120, 10, 210, 100); canvas.drawRect(rect, paint);//使用RectF构造 Rect rect2 = new Rect(230, 10, 320, 100); canvas.drawRect(rect2, paint);//使用Rect构造 7、圆角矩形void drawRoundRect (RectF rect, float rx, float ry, Paint paint) RectF rect:要画的矩形 float rx:生成圆角的椭圆的X轴半径 float ry:生成圆角的椭圆的Y轴半径 1234567Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 RectF rect = new RectF(100, 10, 300, 100); canvas.drawRoundRect(rect, 20, 10, paint); 8、圆形void drawCircle (float cx, float cy, float radius, Paint paint) float cx：圆心点X轴坐标 float cy：圆心点Y轴坐标 float radius：圆的半径 123456Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 canvas.drawCircle(150, 150, 100, paint); 9、椭圆椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，矩形的宽为椭圆的Y轴，建立的椭圆图形 void drawOval (RectF oval, Paint paint) RectF oval：用来生成椭圆的矩形 12345678910Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.STROKE);//填充样式改为描边 paint.setStrokeWidth(5);//设置画笔宽度 RectF rect = new RectF(100, 10, 300, 100); canvas.drawRect(rect, paint);//画矩形 paint.setColor(Color.GREEN);//更改画笔颜色 canvas.drawOval(rect, paint);//同一个矩形画椭圆 10、弧弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以弧当然也是根据矩形来生成的； void drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) RectF oval:生成椭圆的矩形 float startAngle：弧开始的角度，以X轴正方向为0度 float sweepAngle：弧持续的角度 boolean useCenter:是否有弧的两边，True，还两边，False，只有一条弧 12345678910Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.STROKE);//填充样式改为描边 paint.setStrokeWidth(5);//设置画笔宽度 RectF rect1 = new RectF(100, 10, 300, 100); canvas.drawArc(rect1, 0, 90, true, paint); RectF rect2 = new RectF(400, 10, 600, 100); canvas.drawArc(rect2, 0, 90, false, paint); 四、路径及文字1、路径canvas中绘制路径利用： void drawPath (Path path, Paint paint); 1、直线路径void moveTo (float x1, float y1):直线的开始点；即将直线路径的绘制点定在（x1,y1）的位置； void lineTo (float x2, float y2)：直线的结束点，又是下一次绘制直线路径的开始点；lineTo（）可以一直用； void close ():如果连续画了几条直线，但没有形成闭环，调用Close()会将路径首尾点连接起来，形成闭环； 1234567891011121314Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.STROKE);//填充样式改为描边 paint.setStrokeWidth(5);//设置画笔宽度 Path path = new Path(); path.moveTo(10, 10); //设定起始点 path.lineTo(10, 100);//第一条直线的终点，也是第二条直线的起点 path.lineTo(300, 100);//画第二条直线 path.lineTo(500, 100);//第三条直线 path.close();//闭环 canvas.drawPath(path, paint); 2、矩形路径void addRect (float left, float top, float right, float bottom, Path.Direction dir) void addRect (RectF rect, Path.Direction dir) Path.Direction有两个值： Path.Direction.CCW：是counter-clockwise缩写，指创建逆时针方向的矩形路径； Path.Direction.CW：是clockwise的缩写，指创建顺时针方向的矩形路径； 123456789101112131415161718192021//先创建两个大小一样的路径 //第一个逆向生成 Path CCWRectpath = new Path(); RectF rect1 = new RectF(50, 50, 240, 200); CCWRectpath.addRect(rect1, Direction.CCW); //第二个顺向生成 Path CWRectpath = new Path(); RectF rect2 = new RectF(290, 50, 480, 200); CWRectpath.addRect(rect2, Direction.CW); //先画出这两个路径 canvas.drawPath(CCWRectpath, paint); canvas.drawPath(CWRectpath, paint); //依据路径写出文字 String text="风萧萧兮易水寒，壮士一去兮不复返"; paint.setColor(Color.GRAY); paint.setTextSize(35); canvas.drawTextOnPath(text, CCWRectpath, 0, 18, paint);//逆时针生成 canvas.drawTextOnPath(text, CWRectpath, 0, 18, paint);//顺时针生成 路径的顺序对文字的显示方向有影响 3、圆角矩形路径void addRoundRect (RectF rect, float[] radii, Path.Direction dir) void addRoundRect (RectF rect, float rx, float ry, Path.Direction dir) 第一个构造函数：可以定制每个角的圆角大小： 第二个构造函数：只能构建统一圆角大小 123456789Path path = new Path(); RectF rect1 = new RectF(50, 50, 240, 200); path.addRoundRect(rect1, 10, 15 , Direction.CCW); RectF rect2 = new RectF(290, 50, 480, 200); float radii[] =&#123;10,15,20,25,30,35,40,45&#125;; path.addRoundRect(rect2, radii, Direction.CCW); canvas.drawPath(path, paint); 4、圆形路径void addCircle (float x, float y, float radius, Path.Direction dir) float x：圆心X轴坐标 float y：圆心Y轴坐标 float radius：圆半径 123Path path = new Path(); path.addCircle(200, 200, 100, Direction.CCW); canvas.drawPath(path, paint); 5、椭圆路径void addOval (RectF oval, Path.Direction dir) RectF oval：生成椭圆所对应的矩形 Path.Direction :生成方式，与矩形一样，分为顺时针与逆时针，意义完全相同，不再重复 1234Path path = new Path(); RectF rect = new RectF(50, 50, 240, 200); path.addOval(rect, Direction.CCW); canvas.drawPath(path, paint); 6、弧形路径void addArc (RectF oval, float startAngle, float sweepAngle) RectF oval：弧是椭圆的一部分，这个参数就是生成椭圆所对应的矩形； float startAngle：开始的角度，X轴正方向为0度 float sweepAngel：持续的度数； 12345678910Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.STROKE);//填充样式改为描边 paint.setStrokeWidth(5);//设置画笔宽度 Path path = new Path(); RectF rect = new RectF(50, 50, 240, 200); path.addArc(rect, 0, 100); canvas.drawPath(path, paint);//画出路径 7、线段轨迹void quadTo (float x1, float y1, float x2, float y2) 2、文字1、Paint的相关设置123456789101112131415//普通设置 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setStyle(Paint.Style.FILL);//绘图样式，对于设文字和几何图形都有效 paint.setTextAlign(Align.CENTER);//设置文字对齐方式，取值：align.CENTER、align.LEFT或align.RIGHT paint.setTextSize(12);//设置文字大小 //样式设置 paint.setFakeBoldText(true);//设置是否为粗体文字 paint.setUnderlineText(true);//设置下划线 paint.setTextSkewX((float) -0.25);//设置字体水平倾斜度，普通斜体字是-0.25 paint.setStrikeThruText(true);//设置带有删除线效果 //其它设置 paint.setTextScaleX(2);//只会将水平方向拉伸，高度不会变 2、canvas绘图方式1、普通水平绘制void drawText (String text, float x, float y, Paint paint)void drawText (CharSequence text, int start, int end, float x, float y, Paint paint)void drawText (String text, int start, int end, float x, float y, Paint paint)void drawText (char[] text, int index, int count, float x, float y, Paint paint) 第一个构造函数：最普通简单的构造函数； 第三、四个构造函数：实现截取一部分字体给图； 第二个构造函数：最强大，因为传入的可以是charSequence类型字体，但是并不可以实现绘制带图片的扩展文字 2、指定个个文字位置void drawPosText (char[] text, int index, int count, float[] pos, Paint paint) void drawPosText (String text, float[] pos, Paint paint) char[] text：要绘制的文字数组 int index:：第一个要绘制的文字的索引 int count：要绘制的文字的个数，用来算最后一个文字的位置，从第一个绘制的文字开始算起 float[] pos：每个字体的位置，同样两两一组，如｛x1,y1,x2,y2,x3,y3……｝ 12345678910111213Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setTextSize(80);//设置文字大小 paint.setStyle(Paint.Style.FILL);//绘图样式，设置为填充 float []pos=new float[]&#123;80,100, 80,200, 80,300, 80,400&#125;; canvas.drawPosText("画图示例", pos, paint);//两个构造函数 3、沿路径绘制void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint) void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint) float hOffset : 与路径起始点的水平偏移距离 float vOffset : 与路径中心的垂直偏移量 123456789101112131415161718192021222324Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setTextSize(45);//设置文字大小 paint.setStyle(Paint.Style.STROKE);//绘图样式，设置为填充 String string="风萧萧兮易水寒，壮士一去兮不复返"; //先创建两个相同的圆形路径，并先画出两个路径原图 Path circlePath=new Path(); circlePath.addCircle(220,200, 180, Path.Direction.CCW);//逆向绘制,还记得吗,上篇讲过的 canvas.drawPath(circlePath, paint);//绘制出路径原形 Path circlePath2=new Path(); circlePath2.addCircle(750,200, 180, Path.Direction.CCW); canvas.drawPath(circlePath2, paint);//绘制出路径原形 paint.setColor(Color.GREEN); //hoffset、voffset参数值全部设为0，看原始状态是怎样的 canvas.drawTextOnPath(string, circlePath, 0, 0, paint); //第二个路径，改变hoffset、voffset参数值 canvas.drawTextOnPath(string, circlePath2, 80, 30, paint); 3、字体样式设置（Typeface）paint.setTypeface(typeface); Typeface是专门用来设置字体样式的，通过paint.setTypeface()来指定。可以指定系统中的字体样式，也可以指定自定义的样式文件中获取。要构建Typeface时，可以指定所用样式的正常体、斜体、粗体等，如果指定样式中，没有相关文字的样式就会用系统默认的样式来显示，一般默认是宋体。 创建Typeface： Typeface create(String familyName, int style) //直接通过指定字体名来加载系统中自带的文字样式 Typeface create(Typeface family, int style) //通过其它Typeface变量来构建文字样式 Typeface createFromAsset(AssetManager mgr, String path) //通过从Asset中获取外部字体来显示字体样式 Typeface createFromFile(String path)//直接从路径创建 Typeface createFromFile(File path)//从外部路径来创建字体样式 Typeface defaultFromStyle(int style)//创建默认字体 Typeface.NORMAL //正常体 Typeface.BOLD //粗体 Typeface.ITALIC //斜体 Typeface.BOLD_ITALIC //粗斜体 1、使用系统中的字体Typeface defaultFromStyle(int style)//创建默认字体 Typeface create(String familyName, int style) //直接通过指定字体名来加载系统中自带的文字样式 12345678910111213//使用系统自带字体绘制 Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setTextSize(60);//设置文字大小 paint.setStyle(Paint.Style.STROKE);//绘图样式，设置为填充 String familyName = "宋体"; Typeface font = Typeface.create(familyName,Typeface.NORMAL); paint.setTypeface(font); canvas.drawText("欢迎光临Harvic的博客",10,100, paint); 2、自字义字体自定义字体的话，我们就需要从外部字体文件加载我们所需要的字形的，从外部文件加载字形所使用的Typeface构造函数如下面三个： Typeface createFromAsset(AssetManager mgr, String path) //通过从Asset中获取外部字体来显示字体样式 Typeface createFromFile(String path)//直接从路径创建 Typeface createFromFile(File path)//从外部路径来创建字体样式 1234567891011121314//自定义字体，，，迷你简罗卜 Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setTextSize(60);//设置文字大小 paint.setStyle(Paint.Style.FILL);//绘图样式，设置为填充 AssetManager mgr=m_context.getAssets();//得到AssetManager Typeface typeface=Typeface.createFromAsset(mgr, "fonts/jian_luobo.ttf");//根据路径得到Typeface paint.setTypeface(typeface); Log.v("msg",typeface.toString()); canvas.drawText("欢迎光临Harvic的博客",10,100, paint);//两个构造函数 五、区域(Range)一、构造RegionRegion，中文意思即区域的意思，它表示的是canvas图层上的某一块封闭的区域。 1、基本构造函数public Region() //创建一个空的区域 public Region(Region region) //拷贝一个region的范围 public Region(Rect r) //创建一个矩形的区域 public Region(int left, int top, int right, int bottom) //创建一个矩形的区域 第一个还要配合其它函数使用，暂时不提。 第二个构造函数是通过其它的Region来复制一个同样的Region变量 第三个，第四个才是正规常的，根据一个矩形或矩形的左上角和右下角点构造出一个矩形区域 2、间接构造函数 public void setEmpty() //从某种意义上讲置空也是一个构造函数，即将原来的一个区域变量变成了一个空变量，要再利用其它的Set方法重新构造区域。 public boolean set(Region region) //利用新的区域值来替换原来的区域 public boolean set(Rect r) //利用矩形所代表的区域替换原来的区域 public boolean set(int left, int top, int right, int bottom) //根据矩形的两个点构造出矩形区域来替换原来的区域值 public boolean setPath(Path path, Region clip) //根据路径的区域与某区域的交集，构造出新区域，这个后面具体讲解 注意：无论调用Set系列函数的Region是不是有区域值，当调用Set系列函数后，原来的区域值就会被替换成Set函数里的区域。 3、使用SetPath（）构造不规则区域boolean setPath (Path path, Region clip) Path path：用来构造的区域的路径 Region clip：与前面的path所构成的路径取交集，并将两交集设置为最终的区域 指定另一个区域来取共同的交集，当然如果想显示路径构造的区域，Region clip参数可以传一个比Path范围大的多的区域，取完交集之后，当然是Path参数所对应的区域喽。 二、矩形集枚举区域——RegionIterator类RegionIterator类，实现了获取组成区域的矩形集的功能。 RegionIterator(Region region) //根据区域构建对应的矩形集 boolean next(Rect r) //获取下一个矩形，结果保存在参数Rect r中 三、区域的合并、交叉等操作无论是区域还是矩形，都会涉及到与另一个区域的一些操作，比如取交集、取并集等，涉及到的函数有： public final boolean union(Rect r) public boolean op(Rect r, Op op) public boolean op(int left, int top, int right, int bottom, Op op) public boolean op(Region region, Op op) public boolean op(Rect rect, Region region, Op op) 123456789假设用region1 去组合region2 public enum Op &#123; DIFFERENCE(0), //最终区域为region1 与 region2不同的区域 INTERSECT(1), // 最终区域为region1 与 region2相交的区域 UNION(2), //最终区域为region1 与 region2组合一起的区域 XOR(3), //最终区域为region1 与 region2相交之外的区域 REVERSE_DIFFERENCE(4), //最终区域为region2 与 region1不同的区域 REPLACE(5); //最终区域为为region2的区域 &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.Rect; import android.graphics.Region; import android.graphics.Paint.Style; import android.graphics.Region.Op; import android.graphics.RegionIterator; import android.view.View; public class MyRegionView extends View &#123; public MyRegionView(Context context) &#123; super(context); // TODO Auto-generated constructor stub &#125; @Override protected void onDraw(Canvas canvas) &#123; // TODO Auto-generated method stub super.onDraw(canvas); //构造两个矩形 Rect rect1 = new Rect(100,100,400,200); Rect rect2 = new Rect(200,0,300,300); //构造一个画笔，画出矩形轮廓 Paint paint = new Paint(); paint.setColor(Color.RED); paint.setStyle(Style.STROKE); paint.setStrokeWidth(2); canvas.drawRect(rect1, paint); canvas.drawRect(rect2, paint); //构造两个Region Region region = new Region(rect1); Region region2= new Region(rect2); //取两个区域的交集 region.op(region2, Op.INTERSECT); //再构造一个画笔,填充Region操作结果 Paint paint_fill = new Paint(); paint_fill.setColor(Color.GREEN); paint_fill.setStyle(Style.FILL); drawRegion(canvas, region, paint_fill); &#125; private void drawRegion(Canvas canvas,Region rgn,Paint paint) &#123; RegionIterator iter = new RegionIterator(rgn); Rect r = new Rect(); while (iter.next(r)) &#123; canvas.drawRect(r, paint); &#125; &#125; &#125; 四、其它一些方法123456789101112131415161718192021222324252627/**几个判断方法*/ public native boolean isEmpty();//判断该区域是否为空 public native boolean isRect(); //是否是一个矩阵 public native boolean isComplex();//是否是多个矩阵组合 /**一系列的getBound方法，返回一个Region的边界*/ public Rect getBounds() public boolean getBounds(Rect r) public Path getBoundaryPath() public boolean getBoundaryPath(Path path) /**一系列的判断是否包含某点 和是否相交*/ public native boolean contains(int x, int y);//是否包含某点 public boolean quickContains(Rect r) //是否包含某矩形 public native boolean quickContains(int left, int top, int right, int bottom) //是否没有包含某矩阵形 public boolean quickReject(Rect r) //是否没和该矩形相交 public native boolean quickReject(int left, int top, int right, int bottom); //是否没和该矩形相交 public native boolean quickReject(Region rgn); //是否没和该矩形相交 /**几个平移变换的方法*/ public void translate(int dx, int dy) public native void translate(int dx, int dy, Region dst); public void scale(float scale) //hide public native void scale(float scale, Region dst);//hide 五、裁剪1、概述裁剪Clip，即裁剪Canvas图层，我们绘制的东西，只能在裁剪区域的范围能才能显示出来。裁剪画布是利用Clip系列函数，通过与Rect、Path、Region取交、并、差等集合运算来获得最新的画布形状。除了调用Save、Restore函数以外，这个操作是不可逆的，一但Canvas画布被裁剪，就不能再被恢复！ Clip系列函数如下： boolean clipPath(Path path) boolean clipPath(Path path, Region.Op op) boolean clipRect(Rect rect, Region.Op op) boolean clipRect(RectF rect, Region.Op op) boolean clipRect(int left, int top, int right, int bottom) boolean clipRect(float left, float top, float right, float bottom) boolean clipRect(RectF rect) boolean clipRect(float left, float top, float right, float bottom, Region.Op op) boolean clipRect(Rect rect) boolean clipRegion(Region region) boolean clipRegion(Region region, Region.Op op) 12345678910@Override protected void onDraw(Canvas canvas) &#123; Paint paint=new Paint(); canvas.save(); canvas.clipRect(new Rect(100,100,300,300)); canvas.drawColor(Color.BLUE);//裁剪区域的rect变为蓝色 canvas.drawRect(new Rect(0,0,100,100), paint);//在裁剪的区域之外，不能显示 canvas.drawCircle(150,150, 50, paint);//在裁剪区域之内，能显示 canvas.restore(); &#125; 裁剪并不像Matrix变换，它相对于mutable bitmap的坐标是不会改变的。所以超出裁剪区域的绘制不会被显示 裁剪的保存和回滚：canvas.save()和canvas.restore()不仅对matrix有效，同样对clip有类似的效果。 2、裁剪的方式 最基本的clipRect，裁剪一个矩形 clipPath，裁剪Path包括的范围，Path所包括的范围不是空的才有效。 clipRegion。 clipRegion与clipRect和clipPath要使用当前的matrix进行变换不同。clipRegion不会进行转换。也就是说canvas的matrix对clipRegion没有影响。 3、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ClippingRegion extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new SampleView(this)); &#125; private class SampleView extends View &#123; private Bitmap mBitmap; private int limitLength = 0; private int width; private int heigth; private static final int CLIP_HEIGHT = 30; private boolean status = HIDE;//显示还是隐藏的状态，最开始为HIDE private static final boolean SHOW = true;//显示图片 private static final boolean HIDE = false;//隐藏图片 public SampleView(Context context) &#123; super(context); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image1); limitLength = width = mBitmap.getWidth(); heigth = mBitmap.getHeight(); &#125; @Override protected void onDraw(Canvas canvas) &#123; Region region = new Region(); int i = 0; while (i * CLIP_HEIGHT &lt;= heigth) &#123;//计算clip的区域 if (i % 2 == 0) &#123; region.union(new Rect(0, i * CLIP_HEIGHT, limitLength, (i + 1) * CLIP_HEIGHT)); &#125; else &#123; region.union(new Rect(width - limitLength, i * CLIP_HEIGHT, width, (i + 1) * CLIP_HEIGHT)); &#125; i++; &#125; canvas.clipRegion(region); canvas.drawBitmap(mBitmap, 0, 0, new Paint()); if (status == HIDE) &#123;//如果此时是隐藏 limitLength -= 5; if(limitLength&lt;=0) status=SHOW; &#125; else &#123;//如果此时是显示 limitLength += 5; if(limitLength&gt;=width) status=HIDE; &#125; invalidate(); &#125; &#125; &#125; 六、canvas变换与操作一、平移(translate)canvas中有一个函数translate（）是用来实现画布平移的，画布的原状是以左上角为原点，向左是X轴正方向，向下是Y轴正方向. 注意：canvas移动之前设置的(0,0)的图形位置和移动之后设置的(0,0)的图形位置显示结果不一样。 二、屏幕显示与Canvas的关系 调用canvas.drawRect(rect1, paint_green);时，产生一个Canvas透明图层，由于当时还没有对坐标系平移，所以坐标原点是（0，0）；再在系统在Canvas上画好之后，覆盖到屏幕上显示出来，过程如下图： 然后再第二次调用canvas.drawRect(rect1, paint_red);时，又会重新产生一个全新的Canvas画布，但此时画布坐标已经改变了，即向右和向下分别移动了100像素，所以此时的绘图方式为：（合成视图，从上往下看的合成方式） 上图展示了，上层的Canvas图层与底部的屏幕的合成过程，由于Canvas画布已经平移了100像素，所以在画图时是以新原点来产生视图的，然后合成到屏幕上，这就是我们上面最终看到的结果了。我们看到屏幕移动之后，有一部分超出了屏幕的范围，那超出范围的图像显不显示呢，当然不显示了！也就是说，Canvas上虽然能画上，但超出了屏幕的范围，是不会显示的。 总结： 每次调用canvas.drawXXXX系列函数来绘图进，都会产生一个全新的Canvas画布。 如果在DrawXXX前，调用平移、旋转等函数来对Canvas进行了操作，那么这个操作是不可逆的！每次产生的画布的最新位置都是这些操作后的位置。（关于Save()、Restore()的画布可逆问题的后面再讲） 在Canvas与屏幕合成时，超出屏幕范围的图像是不会显示出来的。 三、旋转(Rotate)画布的旋转是默认是围绕坐标原点来旋转的，这里容易产生错觉，看起来觉得是图片旋转了，其实我们旋转的是画布，以后在此画布上画的东西显示出来的时候全部看起来都是旋转的。其实Roate函数有两个构造函数： void rotate(float degrees) void rotate (float degrees, float px, float py) 第一个构造函数直接输入旋转的度数，正数是顺时针旋转，负数指逆时针旋转，它的旋转中心点是原点（0，0） 第二个构造函数除了度数以外，还可以指定旋转的中心点坐标（px,py） 四、缩放(scale)public void scale (float sx, float sy); public final void scale (float sx, float sy, float px, float py); 五、扭曲(skew)void skew (float sx, float sy) float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值 float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值 六、画布的保存与恢复（save()、restore()）我们为了实现一些效果不得不对画布进行操作，但操作完了，画布状态也改变了，这会严重影响到后面的画图操作。如果我们能对画布的大小和状态（旋转角度、扭曲等）进行实时保存和恢复就最好了。 int save() //每次调用Save()函数，都会把当前的画布的状态进行保存，然后放入特定的栈中； void restore() //每当调用Restore()函数，就会把栈中最顶层的画布状态取出来，并按照这个状态恢复当前的画布，并在这个画布上做画。 七、drawText()详解1、概述在canvas在利用drawText绘制文字时，是有规则的，这个规则就是基线！我们先来看一下什么是基线： 也就是说，只要基线的位置定了，那文字的位置必然是定了的！ 2、canvas.drawText()1234567/** * text:要绘制的文字 * x：绘制原点x坐标 * y：绘制原点y坐标 * paint:用来做画的画笔 */ public void drawText(String text, float x, float y, Paint paint) 上面这个构造函数是最常用的drawText方法，传进去一个String对象就能画出对应的文字。但这里有两个参数需要非常注意，表示原点坐标的x和y.很多同学可能会认为，这里传进去的原点参数(x,y)是所在绘制文字所在矩形的左上角的点。但实际上并不是！在(x,y)中最让人捉急的是y坐标，一般而言，(x，y)所代表的位置是所画图形对应的矩形的左上角点。但在drawText中是非常例外的，y所代表的是基线的位置！ 3、paint.setTextAlign(Paint.Align.XXX)paint.setTextAlign()来设置文字在矩形中的相对位置 1234/** * 其中Align的取值为：Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT */ Paint::setTextAlign(Align align); Panit.Align.LEFT:原点在所绘制文字的左边 Paint.Align.CENTER:原点在所绘制文字的中间 Paint.Align.RIGHT:原点在所绘制文字的右边 4、drawText的四线格与FontMetrics1、Text的绘图四线格前面我们讲了基线，其实除了基线，系统在绘制Text时，还是有其它线的，我们来看个图：除了基线以外，如上图所示，另外还有四条线，分别是ascent,descent,top,bottom，他们的意义分别是： ascent: 系统建议的，绘制单个字符时，字符应当的最高高度所在线 descent:系统建议的，绘制单个字符时，字符应当的最低高度所在线 top: 可绘制的最高高度所在线 bottom: 可绘制的最低高度所在线 我们在绘制文字时，ascent是推荐的绘制文字的最高高度，就表示在绘制文字时，尽力要在这个最高高度以下绘制文字。descent是推荐的绘制文字的最底高度线，同样表示是在绘制文字时尽量在这个descent线以上来绘制文字。而top线则指该文字可以绘制的最高高度线，bottom则是表示该文字可以绘制的最低高度线。ascent,descent是系统建议上的绘制高度，而top,bottom则是物理上屏幕最高，最低可以画的高度值。他们的差别与我们上面说的视频处理的安全框和屏幕的道理是一样的。 2、FontMetrics（1）、fontMetrics概述面我们讲了，系统在画文字时的五条线，baseline、ascent、descent、top、bottom我们知道baseline的位置是我们在构造drawText()时的参数y来决定的，那ascent,descent,top,bottom这些线的位置要怎么计算出来呢？Android给我们提供了一个类：FontMetrics，它里面有四个成员变量： FontMetrics::ascent; FontMetrics::descent; FontMetrics::top; FontMetrics::bottom; ascent = ascent线的y坐标 - baseline线的y坐标； descent = descent线的y坐标 - baseline线的y坐标； top = top线的y坐标 - baseline线的y坐标； bottom = bottom线的y坐标 - baseline线的y坐标； ascent = ascent线的y坐标 - baseline线的y坐标；FontMetrics的这几个变量的值都是以baseline为基准的，对于ascent来说，baseline线在ascent线之下，所以必然baseline的y值要大于ascent线的y值，所以ascent变量的值是负的。 descent = descent线的y坐标 - baseline线的y坐标；descent线在baseline线之下，所以必然descent线的y坐标要大于baseline线的y坐标，所以descent变量的值必然是正数。 （2）、得到Text四线格的各线位置 ascent线Y坐标 = baseline线Y坐标 + fontMetric.ascent; descent线Y坐标 = baseline线的y坐标 + fontMetric.descent； top线Y坐标 = baseline线的y坐标 + fontMetric.top； bottom线Y坐标 = baseline线的y坐标 + fontMetric.bottom； （3）、获取FontMetrics对象获取FontMetrics对象是根据paint对象来获取的： 123Paint paint = new Paint(); Paint.FontMetrics fm = paint.getFontMetrics(); Paint.FontMetricsInt fmInt = paint.getFontMetricsInt(); （4）、实例：计算Text四线格位置123456789101112131415161718192021222324252627282930313233343536373839protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int baseLineY = 200; int baseLineX = 0 ; Paint paint = new Paint(); //写文字 paint.setColor(Color.GREEN); paint.setTextSize(120); //以px为单位 paint.setTextAlign(Paint.Align.LEFT); canvas.drawText("harvic\'s blog", baseLineX, baseLineY, paint); //计算各线在位置 Paint.FontMetrics fm = paint.getFontMetrics(); float ascent = baseLineY + fm.ascent; float descent = baseLineY + fm.descent; float top = baseLineY + fm.top; float bottom = baseLineY + fm.bottom; //画基线 paint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint); //画top paint.setColor(Color.BLUE); canvas.drawLine(baseLineX, top, 3000, top, paint); //画ascent paint.setColor(Color.GREEN); canvas.drawLine(baseLineX, ascent, 3000, ascent, paint); //画descent paint.setColor(Color.YELLOW); canvas.drawLine(baseLineX, descent, 3000, descent, paint); //画bottom paint.setColor(Color.RED); canvas.drawLine(baseLineX, bottom, 3000, bottom, paint); &#125; 3、所绘文字宽度、高度和最小矩形获取这部分，我们将讲解如何获取所绘制字符串所占区域的高度、宽度和仅包裹字符串的最小矩形。 1、字符串所占高度和宽度字符串所占高度很容易得到，直接用bottom线所在位置的Y坐标减去top线所在位置的Y坐标就是字符串所占的高度。12345Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int top = baseLineY + fm.top; int bottom = baseLineY + fm.bottom; //所占高度 int height = bottom - top; （2）、宽度宽度是非常容易得到的，直接利用下面的函数就可以得到 int width = paint.measureText(String text); （3）、最小矩形 概述要获取最小矩形，也是通过系统函数来获取的 12345678/** * 获取指定字符串所对应的最小矩形，以（0，0）点所在位置为基线 * @param text 要测量最小矩形的字符串 * @param start 要测量起始字符在字符串中的索引 * @param end 所要测量的字符的长度 * @param bounds 接收测量结果 */ public void getTextBounds(String text, int start, int end, Rect bounds); 得到最小矩形的实际位置 在上面这个图中，我们将黑色矩形平行下移距离Y（黄色线依照的是基线的位置），那么平移后的左上角点的y坐标就是 y2 = y1 + Y;同样的道理，由于paint.getTextBounds（）得到最小矩形的基线是y = 0;那我们直接将这个矩形移动baseline的距离就可以得到这个矩形实际应当在的位置了。所以矩形应当所在实际位置的坐标是： 123456Rect minRect = new Rect(); paint.getTextBounds(text,0,text.length(),minRect); //最小矩形，实际top位置 int minTop = bounds.top + baselineY; //最小矩形，实际bottom位置 int minBottom = bounds.bottom + baselineY; 4、定点写字讲完上面的三部分，这篇文章所要讲的知识点基本就结束了，这部分其实就是应用的范畴了，在这部分中，我们将讲述，当我们设定一个点，如何到得基线位置，进而画出字符串。 1、给定左上顶点绘图这部分，我们假定给出所要绘制矩形的左上角顶点坐标，然后画出这个文字。 在这个图中，我们给定左上角的位置，即(left,top)；我们知道要画文字，drawText（）中传进去的Y坐标是基线的位置，所以我们就必须根据top的位置计算出baseline的位置。我们来看一个公式：FontMetrics.top = top - baseline;所以baseline = top - FontMetrics.top;因为FontMetrics.top是可以得到的，又因为我们的top坐标是给定的，所以通过这个公式就能得到baseline的位置了。下面举个例子来说明一下根据矩形左上项点绘制文字的过程：先看下效果图：在这个效果图中，因为我们会给定矩形左上角顶点(left,top)，所以们先画出top线的位置，然后计算出baseline的位置，并画出来。最后根据baseline把文字写出来。代码如下： 12345678910111213141516171819202122232425262728protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); String text = "harvic\'s blog"; int top = 200; int baseLineX = 0 ; //设置paint Paint paint = new Paint(); paint.setTextSize(120); //以px为单位 paint.setTextAlign(Paint.Align.LEFT); //画top线 paint.setColor(Color.YELLOW); canvas.drawLine(baseLineX, top, 3000, top, paint); //计算出baseLine位置 Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int baseLineY = top - fm.top; //画基线 paint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint); //写文字 paint.setColor(Color.GREEN); canvas.drawText(text, baseLineX, baseLineY, paint); &#125; 这段代码，比较简单，首先是我们给定top给的位置int top = 200;然后根据top线位置计算出baseline所在位置,并画出来。 2、给定中间线位置绘图 在这个图中，总共有四条线：top线，bottom线，baseline和center线；图中center线正是在top线和bottom线的正中间。为了方便推导公式，我另外标了三个距离A,B,C;很显然，距离A和距离C是相等的，都等于文字所在矩形高度以的一半，即：A = C = (bottom - top)/2;又因为bottom = baseline + FontMetrics.bottom;top = baseline+FontMetrics.top;所以，将它们两个代入上面的公式，就可得到：A = C = (FontMetrics.bottom - FontMetrics.top)/2;而距离B,则表示Center线到baseline的距离。很显然距离B = C - (bottom - baseline);又因为FontMetrics.bottom = bottom-baseline;C = A;所以，B = A - FontMetrics.bottom;所以baseline = center + B = center + A - FontMetrics.bottom = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom; 根据上面的推导过程，我们最终可知，当给定中间线center位置以后，baseline的位置为： baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom; 12345678910111213141516171819202122232425262728protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); String text = "harvic\'s blog"; int center = 200; int baseLineX = 0 ; //设置paint Paint paint = new Paint(); paint.setTextSize(120); //以px为单位 paint.setTextAlign(Paint.Align.LEFT); //画center线 paint.setColor(Color.YELLOW); canvas.drawLine(baseLineX, center, 3000, center, paint); //计算出baseLine位置 Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int baseLineY = center + (fm.bottom - fm.top)/2 - fm.bottom; //画基线 paint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint); //写文字 paint.setColor(Color.GREEN); canvas.drawText(text, baseLineX, baseLineY, paint); &#125; 二、Path之贝赛尔曲线和手势轨迹、水波纹效果1、手势轨迹利用贝塞尔曲线，我们能实现平滑的手势轨迹效果 2、水波纹效果电池充电时，有些手机会显示水波纹效果，就是这样做出来的。 3、概述在Path中有四个函数与贝赛尔曲线有关：123456//二阶贝赛尔 public void quadTo(float x1, float y1, float x2, float y2) public void rQuadTo(float dx1, float dy1, float dx2, float dy2) //三阶贝赛尔 public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3) public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3) 1、贝赛尔曲线来源在数学的数值分析领域中，贝赛尔曲线（Bézier曲线）是电脑图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。 2、贝赛尔曲线公式1、一阶贝赛尔曲线其公式可概括为： 对应动画演示为： P0为起点、P1为终点，t表示当前时间，B(t)表示公式的结果值。注意，曲线的意义就是公式结果B(t)随时间的变化，其取值所形成的轨迹。在动画中，黑色点表示在当前时间t下公式B(t)的取值。而红色的那条线就不在各个时间点下不同取值的B(t)所形成的轨迹。总而言之：对于一阶贝赛尔曲线，大家可以理解为在起始点和终点形成的这条直线上，匀速移动的点。 2、二阶贝赛尔曲线对应的动画：首先，P0点和P1点形成了一条贝赛尔曲线，还记得我们上面对一阶贝赛尔曲线的总结么：就是一个点在这条直线上做匀速运动；所以P0-P1这条直线上的移动的点就是Q0；同样，P1,P2形成了一条一阶贝赛尔曲线，在这条一阶贝赛尔曲线上，它们的随时间移动的点是Q1最后，动态点Q0和Q1又形成了一条一阶贝赛尔曲线，在它们这条一阶贝赛尔曲线动态移动的点是B而B的移动轨迹就是这个二阶贝赛尔曲线的最终形态。从上面的讲解大家也可以知道，之所以叫它二阶贝赛尔曲线是因为，B的移动轨迹是建立在两个一阶贝赛尔曲线的中间点Q0,Q1的基础上的。在理解了二阶贝赛尔曲线的形成原理以后，我们就不难理解三阶贝赛尔曲线了 3、三阶贝赛尔曲线对应的动画：首先，这里有三条一阶贝赛尔曲线，分别是P0-P1,P1-P2,P2-P3;他们随时间变化的点分别为Q0，Q1，Q2然后是由Q0，Q1，Q2这三个点，再次连接，形成了两条一阶贝赛尔曲线，分别是Q0—Q1,Q1—Q2;他们随时间变化的点为R0,R1同样，R0和R1同样可以连接形成一条一阶贝赛尔曲线，在R0—R1这条贝赛尔曲线上随时间移动的点是B而B的移动轨迹就是这个三阶贝赛尔曲线的最终形状。从上面的解析大家可以看出，所谓几阶贝赛尔曲线，全部是由一条条一阶贝赛尔曲线搭起来的；在上图中，形成一阶贝赛尔曲线的直线是灰色的，形成二阶贝赛尔曲线线是绿色的，形成三阶贝赛尔曲线的线是蓝色的。 4、四阶贝赛尔曲线 5、五阶贝赛尔曲线 3、贝赛尔曲线与PhotoShop钢笔工具这么屌的贝赛尔曲线，在专业绘图工具PhotoShop中当然会有它的踪影，它就是钢笔工具，钢笔工具所使用的路径弯曲效果就是二阶贝赛尔曲线。我来给大家演示一下钢笔工具的用法：我们拿最终成形的图形来看一下为什么钢笔工具是二阶贝赛尔曲线：右图演示的假设某一点t=0.25时，动态点B的位置图同样，这里P0是起始点，P2是终点，P1是控制点；P0-P1、P1-P2形成了第一层的一阶贝赛尔曲线。它们随时间的动态点分别是Q0,Q1动态点Q0,Q1又形成了第二层的一阶贝赛尔曲线，它们的动态点是B.而B的轨迹跟钢笔工具的形状是完全一样的。所以钢笔工具的拉伸效果是使用的二阶贝赛尔曲线！这个图与上面二阶贝赛尔曲线t=0.25时的曲线差不多，大家理解起来难度也不大。这里需要注意的是，我们在使用钢笔工具时，拖动的是P5点。其实二阶贝赛尔曲线的控制点是其对面的P1点，钢笔工具这样设计是当然是因为操作起来比较方便。 4、Android中贝赛尔曲线之quadTopublic void quadTo(float x1, float y1, float x2, float y2) public void rQuadTo(float dx1, float dy1, float dx2, float dy2) public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3) public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3) 在这四个函数中quadTo、rQuadTo是二阶贝赛尔曲线，cubicTo、rCubicTo是三阶贝赛尔曲线。 1、quadTo使用原理public void quadTo(float x1, float y1, float x2, float y2) 参数中(x1,y1)是控制点坐标，(x2,y2)是终点坐标大家可能会有一个疑问：有控制点和终点坐标，那起始点是多少呢整条线的起始点是通过Path.moveTo(x,y)来指定的，而如果我们连续调用quadTo()，前一个quadTo()的终点，就是下一个quadTo()函数的起点；如果初始没有调用Path.moveTo(x,y)来指定起始点，则默认以控件左上角(0,0)为起始点； 1、示例最关键的是如何来确定控制点的位置！前面讲过，PhotoShop中的钢笔工具是二阶贝赛尔曲线，所以我们可以利用钢笔工具来模拟画出这条波浪线来辅助确定控制点的位置。下面我们来看看这个路径轨迹中，控制点分别在哪个位置我们先看P0-P2这条轨迹，P0是起点，假设位置坐标是(100,300)，P2是终点，假充位置坐标是(300,300)；在以P0为起始点，P2为终点这条二阶贝赛尔曲线上，P1是控制点，很明显P1大概在P0,P2中间的位置，所以它的X坐标应该是200，关于Y坐标，我们无法确定，但很明显的是P1在P0,P2点的上方，也就是它的Y值比它们的小，所以根据钢笔工具上面的位置，我们让P1的比P0,P2的小100;所以P1的坐标是（200，200）同理，不难求出在P2,P4这条二阶贝赛尔曲线上，它们的控制点P3的坐标位置应该是(400,400)；P3的X坐标是400是，因为P3点是P2,P4的中间点；与P3与P1距离P0-P2-P4这条直线的距离应该是相等的。P1距离P0-P2的值为100；P3距离P2-P4的距离也应该是100，这样不难算出P3的坐标应该是(400,400)。 自定义View我们知道在动画绘图时，会调用onDraw(Canvas canvas)函数，我们如果重写了onDraw(Canvas canvas)函数，那么我们利用canvas在上面画了什么，就会显示什么。所以我们自定义一个View12345678910111213141516171819202122232425public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setStyle(Paint.Style.STROKE); paint.setColor(Color.GREEN); Path path = new Path(); path.moveTo(100,300); path.quadTo(200,200,300,300); path.quadTo(400,400,500,300); canvas.drawPath(path,paint); &#125; &#125; 这里最重要的就是在onDraw(Canvas canvas)中创建Path的过程，我们在上面已经提到，第一个起始点是需要调用path.moveTo(100,300)来指定的，之后后一个path.quadTo的起始点是以前一个path.quadTo的终点为起始点的。有关控制点的位置如何查找，我们上面已经利用钢笔工具给大家讲解了，这里就不再细讲。所以，大家在自定义控件的时候，要多跟UED沟通，看他们是如何来实现这个效果的，如果是用的钢笔工具，那我们也可以效仿使用二阶贝赛尔曲线来实现。 总结整条线的起始点是通过Path.moveTo(x,y)来指定的，如果初始没有调用Path.moveTo(x,y)来指定起始点，则默认以控件左上角(0,0)为起始点；而如果我们连续调用quadTo()，前一个quadTo()的终点，就是下一个quadTo()函数的起点； 5、手指轨迹要实现手指轨迹其实是非常简单的，我们只需要在自定义中拦截OnTouchEvent，然后根据手指的移动轨迹来绘制Path即可。要实现把手指的移动轨迹连接起来，最简单的方法就是直接使用Path.lineTo()就能实现把各个点连接起来。 1、实现方式一：Path.lineTo(x,y)自定义View——MyView 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyView extends View &#123; private Path mPath = new Path(); public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: &#123; mPath.moveTo(event.getX(), event.getY()); return true; &#125; case MotionEvent.ACTION_MOVE: mPath.lineTo(event.getX(), event.getY()); postInvalidate(); break; default: break; &#125; return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); canvas.drawPath(mPath,paint); &#125; public void reset()&#123; mPath.reset(); invalidate(); &#125; &#125; 当用户点击屏幕的时候，我们调用mPath.moveTo(event.getX(), event.getY());然后在用户移动手指时使用mPath.lineTo(event.getX(), event.getY());将各个点串起来。然后调用postInvalidate()重绘；Path.moveTo()和Path.lineTo()的用法，大家如果看了《android Graphics（二）：路径及文字》之后，理解起来应该没什么难度，但这里有两个地方需要注意第一：有关在case MotionEvent.ACTION_DOWN时return true的问题：return true表示当前控件已经消费了下按动作，之后的ACTION_MOVE、ACTION_UP动作也会继续传递到当前控件中；如果我们在case MotionEvent.ACTION_DOWN时return false，那么后序的ACTION_MOVE、ACTION_UP动作就不会再传到这个控件来了。有关动作拦截的知识，后续会在这个系列中单独来讲，大家先期待下吧。第二：这里重绘控件使用的是postInvalidate();而我们以前也有用Invalidate()函数的。这两个函数的作用都是用来重绘控件的，但区别是Invalidate()一定要在UI线程执行，如果不是在UI线程就会报错。而postInvalidate()则没有那么多讲究，它可以在任何线程中执行，而不必一定要是主线程。其实在postInvalidate()就是利用handler给主线程发送刷新界面的消息来实现的，所以它是可以在任何线程中执行，而不会出错。而正是因为它是通过发消息来实现的，所以它的界面刷新可能没有直接调Invalidate()刷的那么快。所以在我们确定当前线程是主线程的情况下，还是以invalide()函数为主。当我们不确定当前要刷新页面的位置所处的线程是不是主线程的时候，还是用postInvalidate为好。这里我是故意用的postInvalidate()，因为onTouchEvent()本来就是在主线程中的，使用Invalidate()是更合适的。 使用Path.lineTo()所存在问题：在画出来的两个点连接处有明显的转折，而且位置横纵坐标变化比较快的位置，看起来跟图片这大后的马赛克一样；利用Path绘图，是不可能出现马赛克的，因为除了Bitmap以外的任何canvas绘图全部都是矢量图，也就是利用数学公式来作出来的图，无论放在多大屏幕上，都不可能会出现马赛克！这里利用Path绘图，之所以看起来像是马赛克是因为这是由各个不同点之间连线写出来的，而之间并没有平滑过渡，所以当坐标变化比较剧烈时，线与线之间的转折就显得特别明显了。所以要想优化这种效果，就得实现线与线之间的平滑过渡，很显然，二阶贝赛尔曲线就是干这个事的。下面我们就利用我们新学的Path.quadTo函数来重新实现下移动轨迹效果。 2、实现方式二（优化）：使用Path.quadTo()函数实现过渡(1)、原理概述我们上面讲了，使用Path.lineTo()的最大问题就是线段转折处不够平滑。Path.quadTo()可以实现平滑过渡，但使用Path.quadTo()的最大问题是，如何找到起始点和结束点。下图中，有用绿点表示的三个点，连成的两条直线，很明显他们转折处是有明显折痕的下面我们在PhotoShop中利用钢笔工具，看如何才能实现这两条线之间的转折从这两个线段中可以看出，我们使用Path.lineTo（）的时候，是直接把手指触点A,B,C给连起来。而钢笔工具要实现这三个点间的流畅过渡，就只能将这两个线段的中间点做为起始点和结束点，而将手指的倒数第二个触点B做为控制点。大家可能会觉得，那这样，在结束的时候，A到P0和P1到C1的这段距离岂不是没画进去？是的，如果Path最终没有close的话，这两段距离是被抛弃掉的。因为手指间滑动时，每两个点间的距离很小，所以P1到C之间的距离可以忽略不计。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyView extends View &#123; private Path mPath = new Path(); private float mPreX,mPreY; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN:&#123; mPath.moveTo(event.getX(),event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; &#125; case MotionEvent.ACTION_MOVE:&#123; float endX = (mPreX+event.getX())/2; float endY = (mPreY+event.getY())/2; mPath.quadTo(mPreX,mPreY,endX,endY); mPreX = event.getX(); mPreY =event.getY(); invalidate(); &#125; break; default: break; &#125; return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setStyle(Paint.Style.STROKE); paint.setColor(Color.GREEN); paint.setStrokeWidth(2); canvas.drawPath(mPath,paint); &#125; public void reset()&#123; mPath.reset(); postInvalidate(); &#125; &#125; 6、Path.rQuadTo()1、概述public void rQuadTo(float dx1, float dy1, float dx2, float dy2) dx1:控制点X坐标，表示相对上一个终点X坐标的位移坐标，可为负值，正值表示相加，负值表示相减； dy1:控制点Y坐标，相对上一个终点Y坐标的位移坐标。同样可为负值，正值表示相加，负值表示相减； dx2:终点X坐标，同样是一个相对坐标，相对上一个终点X坐标的位移值，可为负值，正值表示相加，负值表示相减； dy2:终点Y坐标，同样是一个相对，相对上一个终点Y坐标的位移值。可为负值，正值表示相加，负值表示相减； 这四个参数都是传递的都是相对值，相对上一个终点的位移值。比如，我们上一个终点坐标是(300,400)那么利用rQuadTo(100,-100,200,100)；得到的控制点坐标是（300+100,400-100）即(500,300)同样，得到的终点坐标是(300+200,400+100)即(500,500)所以下面这两段代码是等价的：利用quadTo定义绝对坐标 path.moveTo(300,400); path.quadTo(500,300,500,500); 与利用rQuadTo定义相对坐标 path.moveTo(300,400); path.rQuadTo(100,-100,200,100) 2、使用rQuadTo实现波浪线1234567891011121314protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setStyle(Paint.Style.STROKE); paint.setColor(Color.GREEN); Path path = new Path(); path.moveTo(100,300); path.rQuadTo(100,-100,200,0); path.rQuadTo(100,100,200,0); canvas.drawPath(path,paint); &#125; 第一句：path.rQuadTo(100,-100,200,0);是建立在（100,300）这个点基础上来计算相对坐标的。所以控制点X坐标=上一个终点X坐标+控制点X位移 = 100+100=200；控制点Y坐标=上一个终点Y坐标+控制点Y位移 = 300-100=200；终点X坐标 = 上一个终点X坐标+终点X位移 = 100+200=300；终点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+0=300;所以这句与path.quadTo(200,200,300,300);对等的第二句：path.rQuadTo(100,100,200,0);是建立在它的前一个终点即(300,300)的基础上来计算相对坐标的！所以控制点X坐标=上一个终点X坐标+控制点X位移 = 300+100=200；控制点Y坐标=上一个终点Y坐标+控制点Y位移 = 300+100=200；终点X坐标 = 上一个终点X坐标+终点X位移 = 300+200=500；终点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+0=300;所以这句与path.quadTo(400,400,500,300);对等的最终效果也是一样的。通过这个例子，只想让大家明白一点：rQuadTo(float dx1, float dy1, float dx2, float dy2)中的位移坐标，都是以上一个终点位置为基准来做偏移的！ 3、实现波浪效果 完整的MyView代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyView extends View &#123; private Paint mPaint; private Path mPath; private int mItemWaveLength = 400; private int dx; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPath.reset(); int originY = 300; int halfWaveLen = mItemWaveLength/2; mPath.moveTo(-mItemWaveLength+dx,originY); for (int i = -mItemWaveLength;i&lt;=getWidth()+mItemWaveLength;i+=mItemWaveLength)&#123; mPath.rQuadTo(halfWaveLen/2,-100,halfWaveLen,0); mPath.rQuadTo(halfWaveLen/2,100,halfWaveLen,0); &#125; mPath.lineTo(getWidth(),getHeight()); mPath.lineTo(0,getHeight()); mPath.close(); canvas.drawPath(mPath,mPaint); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(2000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125; &#125; 然后在MyActivity中开始动画： 123456789101112public class MyActivity extends Activity &#123; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); final MyView myView = (MyView)findViewById(R.id.myview); myView.startAnim(); &#125; &#125; 三、Paint之函数大汇总一、基本用法1、概述paint中基本设置的函数 reset() //重置画笔 setColor(int color) //给画笔设置颜色值 setARGB(int a, int r, int g, int b) //同样是设置颜色，但是利用ARGB分开设置 setAlpha(int a) //设置画笔透明度 setStyle(Paint.Style style) //设置画笔样式，取值有 Paint.Style.FILL :填充内部 Paint.Style.FILL_AND_STROKE ：填充内部和描边 Paint.Style.STROKE ：仅描边 setStrokeWidth(float width) //设置画笔宽度 setAntiAlias(boolean aa) //设置画笔是否抗锯齿 上面这些函数，我们在前面几篇已经详细讲过了，难度也都不大，不再细讲。下面几个函数我们是没有讲到过的，下面做下补充 setStrokeCap(Paint.Cap cap) //设置线冒样式，取值有Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) setStrokeJoin(Paint.Join join) //设置线段连接处样式，取值有：Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线) setStrokeMiter(float miter) //设置笔画的倾斜度，90度拿画笔与30拿画笔，画出来的线条样式肯定是不一样的吧。（事实证明，根本看不出来什么区别好吗……囧……） setPathEffect(PathEffect effect) //设置路径样式;取值类型是所有派生自PathEffect的子类：ComposePathEffect, CornerPathEffect, DashPathEffect, DiscretePathEffect, PathDashPathEffect, SumPathEffect （1）、CornerPathEffect——圆形拐角效果它的作用就是将原来Path生硬的直线拐角，变成圆形拐角： public CornerPathEffect(float radius) 它只有一个参数radius：即当前连接两条直线所使用的圆的半径。上面这个图，很清晰的展示了利用半径R=50的圆来代替原来两条直线间的夹角。12345678910111213141516171819Paint paint = new Paint(); paint.setStrokeWidth(4); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); Path path = new Path(); path.moveTo(100,600); path.lineTo(400,100); path.lineTo(700,900); canvas.drawPath(path,paint); paint.setColor(Color.RED); paint.setPathEffect(new CornerPathEffect(100)); canvas.drawPath(path,paint); paint.setColor(Color.YELLOW); paint.setPathEffect(new CornerPathEffect(200)); canvas.drawPath(path,paint); 在这里，我利用Path构造了一个夹角，在同一个位置画了三遍，第一遍是没有添加任何PathEffect的;第二遍，CornerPathEffect的圆半径为100；第三遍CornerPathEffect的圆半径为200；很明显能看出在半径不同情况下，连接位置也是不一样的。 （2）、DashPathEffect——虚线效果 public DashPathEffect(float intervals[], float phase) intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[]中这些基本线段循环组成的。比如，我们定义new float[] {20,10}；那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10； 对于intervals[]数组的有两个限定： 长度必须大于等于2；因为必须有一个实线段和一个空线段来组成虚线。 个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。 （3）、DiscretePathEffect——离散路径效果同样，图中第一条线是原生的，第二条线加上离散路径效果后的样式。DiscretePathEffect就是将原来路径分隔成定长的线段，然后将每条线段随机偏移一段位置，我们可以用它来模拟一种类似生锈铁丝的效果. public DiscretePathEffect(float segmentLength, float deviation) 第一个参数segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为2的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。 第二参数deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。 12345678910111213141516Paint paint = getPaint(); Path path = getPath(); //第一条原生Path canvas.drawPath(path,paint); //第二条Path canvas.translate(0,200); paint.setPathEffect(new DiscretePathEffect(2,5)); canvas.drawPath(path,paint); //第三条Path canvas.translate(0,200); paint.setPathEffect(new DiscretePathEffect(6,5)); canvas.drawPath(path,paint); //第四条Path canvas.translate(0,200); paint.setPathEffect(new DiscretePathEffect(6,15)); canvas.drawPath(path,paint); 我们这里涉及到一个函数getPath函数就是随机生成一条路径；我们先来看效果，然后再回来看getPath（）的实现 从第二条和第三条相比，可以明显看出，在仅增大segmentLength的情况下，很明显第三条线段所切的子线段要大一些，所以就没有第二条曲线的那么多线段相交所产生的折点，所以相比第二条更顺滑一些，当然铁锈效果就没有第二条那么明显了。第三条和第四条相比，在segmentLength都是6的情况下，在第四条仅增大了deviation参数（偏移距离），从效果图中也明显可以看出每个子线段向外偏移的距离也增大了。 （4）、PathDashPathEffect——印章路径效果它的作用就是用另一个路径图案做为印章，沿着指定路径一个个盖上去。 public PathDashPathEffect(Path shape, float advance, float phase,Style style) Path shape:表示印章路径，比如我们下面示例中的三角形加右上角一个点； float advance：表示两个印章路径间的距离,很容易理解，印章间距离越大，间距就越大。 float phase：路径绘制偏移距离，与上面DashPathEffect中的float phase参数意义相同 Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE;Style.ROTATE表示通过旋转印章来过渡转角；Style.MORPH表示通过变形印章来过渡转角；Style.TRANSLATE表示通过位移来过渡转角。这三个效果的具体意义，上面会通过具体示例来分别讲解。 123456789101112131415161718192021Paint paint = getPaint(); //画出原始路径 Path path = new Path(); path.moveTo(100,600); path.lineTo(400,100); path.lineTo(700,900); canvas.drawPath(path,paint); //构建印章路径 Path stampPath = new Path(); stampPath.moveTo(0,20); stampPath.lineTo(10,0); stampPath.lineTo(20,20); stampPath.close(); stampPath.addCircle(0,0,3, Path.Direction.CCW); //使用印章路径效果 canvas.translate(0,200); paint.setPathEffect(new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.TRANSLATE)); canvas.drawPath(path,paint); 在Style不同的情况下，在转角处都如何处理的 12345678910111213141516171819202122232425262728private void drawPathDashPathEffect(Canvas canvas)&#123; Paint paint = getPaint(); Path path = getPath(); canvas.drawPath(path,paint); canvas.translate(0,200); paint.setPathEffect(new PathDashPathEffect(getStampPath(),35,0, PathDashPathEffect.Style.MORPH)); canvas.drawPath(path,paint); canvas.translate(0,200); paint.setPathEffect(new PathDashPathEffect(getStampPath(),35,0, PathDashPathEffect.Style.ROTATE)); canvas.drawPath(path,paint); canvas.translate(0,200); paint.setPathEffect(new PathDashPathEffect(getStampPath(),35,0, PathDashPathEffect.Style.TRANSLATE)); canvas.drawPath(path,paint); &#125; private Path getStampPath()&#123; Path path = new Path(); path.moveTo(0,20); path.lineTo(10,0); path.lineTo(20,20); path.close(); path.addCircle(0,0,3, Path.Direction.CCW); return path; &#125; 这段代码通过getPath()函数随机生成一条路径，并将原始路径和各个Style的路径画出来。第一条是原始路径，第二条的Style是Style.MORPH，第三条是Style.ROTATE，第四条是Style.TRANSLATE； 当Style.MORPH时，就是通过对印章进行变形来过渡转角的 当Style为Style.ROTATE时就是靠旋转印章角度来过渡转角的 当Style为Style.TRANSLATE时，即不会对印章变形也不会对旋转印章角度，而只是通过变改印章的位置来过渡 （5）、ComposePathEffect与SumPathEffect这两个都是用来合并两个特效的。但它们之间是有区别的： public ComposePathEffect(PathEffect outerpe, PathEffect innerpe) ComposePathEffect合并两个特效是有先后顺序的，它会先将第二个参数的PathEffect innerpe的特效作用于路径上，然后再在此加了特效的路径上作用第二个特效。 public SumPathEffect(PathEffect first, PathEffect second) 而SumPathEffect是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。 1234567891011121314151617181920212223242526272829//画原始路径 Paint paint = getPaint(); Path path = getPath(); canvas.drawPath(path,paint); //仅应用圆角特效的路径 canvas.translate(0,200); CornerPathEffect cornerPathEffect = new CornerPathEffect(100); paint.setPathEffect(cornerPathEffect); canvas.drawPath(path,paint); //仅应用虚线特效的路径 canvas.translate(0,200); DashPathEffect dashPathEffect = new DashPathEffect(new float[]&#123;2,5,10,10&#125;,0); paint.setPathEffect(dashPathEffect); canvas.drawPath(path,paint); //利用ComposePathEffect先应用圆角特效,再应用虚线特效 canvas.translate(0,200); ComposePathEffect composePathEffect = new ComposePathEffect(dashPathEffect,cornerPathEffect); paint.setPathEffect(composePathEffect); canvas.drawPath(path,paint); //利用SumPathEffect,分别将圆角特效应用于原始路径,然后将生成的两条特效路径合并 canvas.translate(0,200); paint.setStyle(Paint.Style.STROKE); SumPathEffect sumPathEffect = new SumPathEffect(cornerPathEffect,dashPathEffect); paint.setPathEffect(sumPathEffect); canvas.drawPath(path,paint); 二、字体相关setTextSize(float textSize) //设置文字大小 setFakeBoldText(boolean fakeBoldText) //设置是否为粗体文字 setStrikeThruText(boolean strikeThruText) //设置带有删除线效果 setUnderlineText(boolean underlineText) //设置下划线 setTextAlign(Paint.Align align) //设置开始绘图点位置 setTextScaleX(float scaleX) //水平拉伸设置 setTextSkewX(float skewX) //设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 setTypeface(Typeface typeface) //字体样式 1、setLinearText(boolean linearText)设置是否打开线性文本标识；由于文本想要快速绘制出来，必然是需要提前缓存在显存中的，一般而言每个文字需要一个字节的大小来存储它（当然具体需要多少字节与编码方式有关），那如果是长篇文章，可见所需的大小可想而知。我们可以通过setLinearText (true)告诉Android我们不需要这样的文本缓存。但如果我们不用文本缓存，虽然能够省去一些内存空间，但这是以显示速度为代价的。由于这个是API 1的函数，由于当时的android手机的内存大小还是很小的，所以尽量减少内存使用是每个应用的头等大事，在当时的的环境下这个函数还是很有用的。但在今天，内存动不动就是4G以上了，文本缓存的所占的那点内存就微不足道了，没有哪个APP会牺牲性能来减少这点这内存占用了，所以这个函数基本没用了。2、setSubpixelText(boolean subpixelText)表示是否打开亚像素设置来绘制文本。亚像素的概念比较难理解，首先，我们都知道像素，比如一个android手机的分辨率是1280 720，那就是指它的屏幕在垂直方向有1280个像素点，水平方向上有720个像素点。我们知道每个像素点都是一个独立显示一个颜色的个体。所以如果一副图片，在一个屏幕上用了300 100个相素点，而在另一个屏幕上却用了450 150个像素来显示。那么，请问在哪个屏幕上这张图片显示的更清晰？当然是第二个屏幕，因为它使用的像素点更多，所显示的细节更精细。那么问题来了，android设置在出厂时，设定的像素显示都是固定的几个范围：320 480，480 800，720 1280，1080 * 1920等等；那么如何在同样的分辨率的显示器中增强显示清晰度呢？亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。注意：亚像素是通过程序计算出来模拟插入的，在没有改变硬件构造的情况下，来改善屏幕分辨率大小。亚像素显示，是仅在液晶显示器上使用的一种增强字体清晰度的技术。但这种技术有时会出现问题，用投影仪投射到白色墙壁上，会出出字体显示不正常的情况，而且对于老式的CRT显示器是根本不支持的。在android还没有出现时，windows已经能够支持亚像素显示了，在windows机器中，这个功能叫做ClearType，在以前讲述windows的GDI绘图时，也曾经讲过ClearType的应用效果。 三、其它接下来还剩几个跟图片和测量相关的函数，我们接下来分篇慢慢讲解。1、图像处理： setShader(Shader shader) setShadowLayer(float radius, float dx, float dy, int shadowColor) setDither(boolean dither) setColorFilter(ColorFilter filter) setXfermode(Xfermode xfermode) setFilterBitmap(boolean filter) clearShadowLayer() 2、measure测量相关 breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth) measureText(String text) 三、Paint之ColorMatrix与滤镜效果一、矩阵概述学过线代的应该都清楚，就不记录了。 二、色彩矩阵对于色彩的存储，Bitmap类使用一个32位的数值来保存。红、绿、蓝及透明度各占8位，每一个色彩分量的取值范围是0-255。透明度为0表示完全透明，为255时，色彩完全可见。 1、色彩信息的矩阵表示四阶表示由于一个色彩信息包含R、G、B、Alpha信息，所以，我们必然要使用一个4阶色彩变换矩阵来修改色彩的每一个分量值：注意：对于色彩变换矩阵，这里的色彩顺序是R、G、B、A而不是A、R、G、B！！！如果想将色彩（0，255，0，255）更改为半透明时，可以使用下面的的矩阵运算来表示： 为什么使用五阶矩阵上面使用四阶矩阵完全可以改变图片的RGBA值了，但考虑一种情况，如果我们只想在原有的R色上增加一些分量呢？这时，我们就得再多加一阶来表示平移变换。所以，一个既包含线性变换，又包含平移变换的组合变换，称为仿射变换。使用四阶的色彩变换矩阵来修改色彩，只能够对色彩的每一个分量值进行乘（除）运算，如果要对这些分量值进行加减法的运算（平移变换），只能通过五阶矩阵来完成。考虑下面这个变换：1、红色分量值更改为原来的2倍；2、绿色分量增加100；则使用4阶矩阵的乘法无法实现，所以，应该在四阶色彩变换矩阵上增加一个“哑元坐标”，来实现所列的矩阵运算: 三、Android中的色彩矩阵1、概述在上面的所有讲解之后，大家也应该看出来了，色彩变换矩阵的表示形式，肯定是五阶的那种，所以大家看一下，在默认情况下，色彩变换矩阵的形式：Android中的色彩矩阵是用ColorMatrics类来表示的。使用ColorMatrix的方法如下1234567ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.5, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); 2、示例1（单个颜色的蓝色通道输出）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class MyView extends View &#123; private Paint mPaint = new Paint(); private Bitmap bitmap;// 位图 public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); mPaint.setARGB(255,200,100,100); // 绘制原始位图 canvas.drawRect(0,0,500,600,mPaint); canvas.translate(550,0); // 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawRect(0,0,500,600,mPaint); &#125; &#125;``` 在上面中，我们先将图笔颜色值设为(255,200,100,100)，然后对其进行ColorMatrix颜色值运算，把红色和绿色都去掉，仅显示蓝色值；只显示蓝色值的效果在Photoshop中叫做蓝色通道。效果图如下： 左侧是原图，右侧是该图对应的蓝色通道![201702142952620160419090342953.png](http://ohtrrgyyd.bkt.clouddn.com/201702142952620160419090342953.png)这里只是对一个颜色值，而ColorMatrics的最厉害的地方在于，能够很批量地改变图像中的所有颜色值。下面我们就对图像应用ColorMatrics的例子来看看，如果只显示图像中的蓝色通道会怎样#### 3、示例2（图片多颜色的蓝色通道输出）下面我们就举个给Bitmap应用ColorMatrix的例子：``` javapublic class MyView extends View &#123; private Paint mPaint = new Paint(); private Bitmap bitmap;// 位图 public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint.setAntiAlias(true); // 获取位图 bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制原始位图 canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); canvas.translate(510, 0); // 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); &#125; &#125;``` 这里分两次绘制了一个bitmap，第一次绘制了一个原始图像，然后利用ColorMatrix生成了一个仅包含蓝色的图像，用过PhotoShop的同学应该很清楚这个跟Photoshop中的蓝色通道的效果是一致的。效果图如下：![201702142204420160419090516432.png](http://ohtrrgyyd.bkt.clouddn.com/201702142204420160419090516432.png)**大家注意哦，不要在onDraw里new Paint对象，上节中我为了省事就直接在onDraw（）函数中直接new 了Paint对象，由于onDraw函数在刷新时会连续调用多次，所以如果在其中不断的new对象，会造成程序不断的GC(内存回收)，是会严重影响性能的！在程序中，我有时会了为了方便理解，就直接在onDraw（）中创建对象了，大家在实际应用中一定要杜绝这种应用哦。**#### 四、色彩的几种运算方式##### 1、色彩的平移运算色彩的平移运算，实际上就是色彩的加法运算。其实就是在色彩变换矩阵的最后一行加上某个值；这样可以增加特定色彩的饱和度![201702143469220160419090748183.png](http://ohtrrgyyd.bkt.clouddn.com/201702143469220160419090748183.png)比如，同样是上面的图片，我们给它应用下面的色彩值：``` javaColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 1, 0, 0, 50, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); 在绿色值上添加增量50，即增大绿色的饱和度。效果图如下： 同样，左侧是原图，右侧是增大绿色饱和度后的效果；大家要特别注意的是，由于图片是由一个个像素组成的，所以用每个像素所对应的色彩数组，来乘转换矩阵，结果就是转换后的当前点的颜色值；所以，在应用ColorMatrics后，图片中每个像素的绿色值都增加了50，从小狗脸上也可以看出来，狗脸也变绿了（它可能看到他女朋友跟人家跑了，哈哈）！色彩平移除了增加指定颜色饱和度以外，另一个应用就是色彩反转(PhotoShop中的反相功能) 色彩反转/反相功能色彩反转就是求出每个色彩的补值来做为目标图像的对应颜色值：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; -1,0,0,0,255, 0,-1,0,0,255, 0,0,-1,0,255, 0,0,0 ,1,0 &#125;); 2、色彩的缩放运算色彩的缩放运算其实就是色彩的乘法运算。在色彩矩阵对角线上的分别代表R、G、B、A的几个值，将其分别乘以指定的值。这就是所谓的缩放变换。我们可以针对某一个颜色值进行放大缩小运算，但当对R、G、B、A同时进行放大缩小时，就是对亮度进行调节！看下面的将亮度增大1.2倍的代码：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1.2f, 0, 0, 0, 0, 0, 1.2f, 0, 0, 50, 0, 0, 1.2f, 0, 0, 0, 0, 0, 1.2f, 0, &#125;); 3、缩放变换的特殊应用（通道输出）由于在色彩变换矩阵中，对角线上的数的取值范围是从0-1的，所以当取0时，这个色彩就完全不显示，所以当我们R、G都取0，而独有B取1时，就只显示了蓝色，所形成的图像也就是我们通常说的蓝色通道；看下几个通道输出的效果图：红色通道矩阵123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, &#125;); 绿色通道矩阵123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, &#125;); 蓝色通道矩阵123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); 4、色彩的旋转运算RGB色是如何旋转的呢，首先用R、G、B三色建立立体坐标系：所以，我们可以把一个色彩值看成三维空间里的一个点，色彩值的三个分量可以看成该点的坐标（三维坐标）。我们先不考虑，在三个维度综合情况下是怎么旋转的，我们先看看，在某个轴做为Z轴，在另两个轴形成的平面上旋转的情况，下图分析了，在将蓝色轴做为Z轴，仅在红—绿平面上旋转a度的情况：在图中，我们可以看到，在旋转后，原R在R轴的分量变为:原R cosa，但原G分量在旋转后，在R轴上也有了分量，但分量落在了负轴上，所以我们要减去这部分分量，所以最终的结果是最终的R=原R cosa-原G * sina;下面就看下关于几种旋转计算及结果矩阵，（注意：这几个图只标记了原X轴色彩分量的旋转，没有把Y轴色彩分量的旋转标记出来） 绕蓝色轴旋转a度 对应的色彩变换矩阵是 绕红色轴旋转a度 对应的色彩变换矩阵是 绕绿色轴旋转a度 对应的色彩变换矩阵是 当围绕红色轴进行色彩旋转时，由于当前红色轴的色彩是不变的，而仅利用三角函数来动态的变更绿色和蓝色的颜色值。这种改变就叫做色相调节！当围绕红色轴旋转时，是对图片就行红色色相的调节；同理，当围绕蓝色颜色轴旋转时，就是对图片就行蓝色色相调节；当然，当围绕绿色轴旋转时，就是对图片进行绿色色相的调节. 下面我们做一个动态的调节，针对红色色相。 这个效果图表示的是，在滚轮正中间位置时表示旋转角度为0度，最右侧位置表示向正方向旋转180，左侧到底表示负方向旋转180.同理可以得到围绕绿色轴旋转的效果图：最后是，围绕蓝色轴旋转的效果图： 5、色彩的投射运算色彩矩阵运算的公式：其中我把红色运算给单独拉了出来，红色标记的那几个元素a12,a13,a14,在运算中，是利用G、B、A的颜色值的分量来增加红色值的。来看具体的运算：注意：最终结果的220=0.2 100+1 200,可见绿色分量在原有绿色分量的基础上，增加了红色分量值的0.2倍；利用其它色彩分量的倍数来更改自己色彩分量的值，这种运算就叫投射运算。下图阴影部分；对这些值进行修改时，修改所使用的增加值来自于其它色彩分量的信息。色彩投射的一个最简单应用就是变为黑白图片：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0.213f, 0.715f, 0.072f, 0, 0, 0.213f, 0.715f, 0.072f, 0, 0, 0.213f, 0.715f, 0.072f, 0, 0, 0, 0, 0, 1, 0, &#125;); 首先了解一下去色原理：只要把RGB三通道的色彩信息设置成一样；即：R＝G＝B，那么图像就变成了灰色，并且，为了保证图像亮度不变，同一个通道中的R+G+B=1:如：0.213+0.715+0.072＝1；三个数字的由来：0.213, 0.715, 0.072；按理说应该把RGB平分，都是0.3333333。三个数字应该是根据色彩光波频率及色彩心理学计算出来的（本人是这么认为，当然也查询了一些资料，目前尚未找到准确答案）。在作用于人眼的光线中，彩色光要明显强于无色光。对一个图像按RGB平分理论给图像去色的话，人眼就会明显感觉到图像变暗了（当然可能有心理上的原因，也有光波的科学依据）另外，在彩色图像中能识别的一下细节也可能会丢失。所以google最终给我们的颜色值就是上面的比例：0.213, 0.715, 0.072；所以，在给图像去色时我们保留了大量的G通道信息，使得图像不至于变暗或者绿色信息不至于丢失（我猜想）。投射运算的另一个应用是：色彩反色当我们利用色彩矩阵将两个颜色反转，这种操作就叫做色彩反色比如，下面的的将红色和绿色反色（红绿反色） 123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0,1,0,0,0, 1,0,0,0,0, 0,0,1,0,0, 0,0,0,1,0 &#125;); 左侧的图为原图，右边为红绿反色以后的效果图;从矩阵中可以看出红绿反色的关键在于，第一行用绿色来代替了红色，第二行用红色代替了绿色。类似可以有红蓝反色，绿蓝反色等，对应矩阵难度不大，就不再细讲了。 变旧照片投射运算的另一个应用是照片变旧，对应矩阵如下：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1/2f,1/2f,1/2f,0,0, 1/3f,1/3f,1/3f,0,0, 1/4f,1/4f,1/4f,0,0, 0,0,0,1,0 &#125;); 五、ColorMatrix函数上面讲了利用色彩矩阵的来做一些运算，但这些都是需要特定的色彩设计基础的，Android中ColorMatrix自带了一些函数来帮我们完成一些调整饱和度、色彩旋转等操作的函数，我们就一一来看看 1、构造函数ColorMatrix共有三个构造函数： ColorMatrix() ColorMatrix(float[] src) ColorMatrix(ColorMatrix src) 2、设置、重置函数第一个构造函数ColorMatrix()，需要与其它函数共用才行： public void set(ColorMatrix src) public void set(float[] src) public void reset() 3、setSaturation——设置饱和度上面我们讲过，我们可以通过色彩的平移运算单独增强R,G,B其中一个的饱和度，但当我们需要整体增强图像的饱和度时需要如何来做呢？ColorMatrics给我们提供了一个方法来整体增强图像的饱和度，函数如下： public void setSaturation(float sat) //整体增强颜色饱和度，即同时增强R,G,B的色彩饱和度 参数float sat：表示把当前色彩饱和度放大的倍数。取值为0表示完全无色彩，即灰度图像（黑白图像）；取值为1时，表示色彩不变动；当取值大于1时，显示色彩过度饱和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MyActivity extends Activity &#123; private SeekBar mSeekBar; private ImageView mImageView; private Bitmap mOriginBmp,mTempBmp; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mImageView = (ImageView) findViewById(R.id.img); mSeekBar = (SeekBar)findViewById(R.id.seekbar); mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.dog); mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(), Bitmap.Config.ARGB_8888); mSeekBar.setMax(20); mSeekBar.setProgress(1); mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; Bitmap bitmap = handleColorMatrixBmp(progress); mImageView.setImageBitmap(bitmap); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); &#125; private Bitmap handleColorMatrixBmp(int progress)&#123; // 创建一个相同尺寸的可变的位图区,用于绘制调色后的图片 Canvas canvas = new Canvas(mTempBmp); // 得到画笔对象 Paint paint = new Paint(); // 新建paint paint.setAntiAlias(true); // 设置抗锯齿,也即是边缘做平滑处理 ColorMatrix mSaturationMatrix = new ColorMatrix(); mSaturationMatrix.setSaturation(progress); paint.setColorFilter(new ColorMatrixColorFilter(mSaturationMatrix));// 设置颜色变换效果 canvas.drawBitmap(mOriginBmp, 0, 0, paint); // 将颜色变化后的图片输出到新创建的位图区 // 返回新的位图，也即调色处理后的图片 return mTempBmp; &#125; &#125; 滑块默认在一倍的位置，向左到底是0，向右到底是20（即饱和度放大20倍） 4、setScale——色彩缩放同样，对于色彩的缩放运算ColorMatrics也已经为我们封装了一个函数： public void setScale(float rScale, float gScale, float bScale,float aScale) 总共有四个参数，分别对应R,G,B,A颜色值的缩放倍数。比如，在小狗图片中，绿色占大部分，所以我们仅将绿色放大1.3倍：12345678910canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); canvas.save(); canvas.translate(510, 0); // 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(); colorMatrix.setScale(1,1.3f,1,1); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); 在仅将绿色放大1.3倍后，整个图片看起来更鲜艳了有没有。 5、setRotate——色彩旋转上面在讲解色彩旋转运算时，给大家列出了在色彩旋转时的效果和原理，由于涉及到正余弦函数的计算，而且这些公式推导起来相当具有难度，所以Android的大大们，已经给我们封装好了色彩旋转的函数：1234567/** * 将旋转围绕某一个颜色轴旋转 * axis=0 围绕红色轴旋转 * axis=1 围绕绿色轴旋转 * axis=2 围绕蓝色轴旋转 */ public void setRotate(int axis, float degrees)； int axis：表示围绕哪个轴旋转，取值为0，1，2；取0时表示围绕红色轴旋转；取值1时，表示围绕绿色轴旋转；取值2时，表示围绕蓝色轴旋转； float degrees：表示旋转的度数 6、ColorMatrics相乘矩阵相乘涉及到三个函数： public void setConcat(ColorMatrix matA, ColorMatrix matB) //这个函数接收两个ColorMatrix矩阵matA和matB，乘法规则为matA*matB，然后将结果做为当前ColorMatrix的值。 public void preConcat(ColorMatrix prematrix) //假如当前矩阵的A，而preConcat的意思就是将当前的矩阵A乘以prematrix public void postConcat(ColorMatrix postmatrix) //上面prematrix是当前矩阵A*prematrix；而postConcat函数的意义就是postmatrix*当前矩阵A;这就是一个前乘，一个是后乘的区别 7、getArray()获取当前矩阵数组getArray函数的意义就是返回当前ColorMatrics对象中的所保存的矩阵 public float[] getArray() 好啦，本篇到这里就结束了，有关矩阵的知识是比较有难度的，但是这篇对于图像处理是至关重要的，因为在有些相机软件中会有各种滤镜效果，这些滤镜效果大部分就是通过更改ColorMatrics矩阵来完成的！当然要完全会构造ColorMatrics矩阵是需要色彩设计相关的知识的；相信通过本篇知识，你也能写出些滤镜效果了，做出来一个简单的图片处理APP也不是问题了哦。 四、Paint之setColorFilter上篇给大家讲了在setColorFilter中使用ColorMatrix的过程，其实setColorFilter除了使用ColorMatrix还有其它的用法，这节我们就具体来看看setColorFilter的用法。 一、setColorFilterpublic ColorFilter setColorFilter(ColorFilter filter) 参数是传入ColorFilter的对象，其实ColorFilter是一个空对象，其中什么也没有：123456789101112131415161718public class ColorFilter &#123; int native_instance; /** * @hide */ public int nativeColorFilter; protected void finalize() throws Throwable &#123; try &#123; super.finalize(); &#125; finally &#123; finalizer(native_instance, nativeColorFilter); &#125; &#125; private static native void finalizer(int native_instance, int nativeColorFilter); &#125; 但是ColorFilter派生了几个子类，分别是： 1、ColorMatrixColorFilter这个是色彩矩阵颜色过滤器，该类只有两个函数，也都是构造函数： ColorMatrixColorFilter(ColorMatrix matrix) ColorMatrixColorFilter(float[] array) 示例12345678910111213canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); canvas.translate(510, 0); // 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1/2f,1/2f,1/2f,0,0, 1/3f,1/3f,1/3f,0,0, 1/4f,1/4f,1/4f,0,0, 0,0,0,1,0 &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); 2、LightingColorFilter前一篇，我们利用一篇的篇幅来讲解ColorMatrix的作用，所有需要完成色彩操作的都是可以利用ColorMatrix来完成的，只是有一点ColorMatrix纵然很强大，但太！过！难！用，所以Android为我们提供了一个简单过滤颜色和增强色彩的函数，就是LightingColorFilter这个叫做光照颜色过滤器，可以简单的完成色彩过滤和色彩增强功能。整个类就只有一个函数，还是构造函数： public LightingColorFilter(int mul, int add) 这里有两个参数,mul是乘法multiply的缩写，add是加法的意思。mul和add取值都是0xRRGGBB,分别对应R、G、B颜色，注意哦，这里是没有透明度A的，透明度在这里是不起作用的，LightingColorFilter只针对RGB色值起作用比如，当前有一个颜色值为（r,g,b），对它应用LightingColorFilter(mul, add)效果后的颜色值为： 结果R值 = (r*mul.R+add.R)%255; 结果G值 = (g*mul.G+add.G)%255; 结果B值 = (b*mul.B+add.B)%255; 作用LightingColorFilter(mul, add)效果后的R值等于，原来的r值乘以mul.R,然后再加上add.R做为最终结果。因为颜色值要的取值范围在0-255，所以要把结果对255取余，得到最终结果。所以从公式中可以看出mul.R是对当前红色值进行放大的倍数；而add.R则表示对当前红色增加的数值；它们对应ColorMatrix的位置如下： 利用mul进行颜色值放大并不好控制，所以更多的是用来过滤颜色，即当对应的颜色值取0时，就不会将对应的颜色显示出来，而把要显示出来的颜色对应的mul值设置为ff,即255;从公式中可以知道设置为255不会对原始的这个颜色分量产生任何影响。所以这样就可以把想要的颜色给显示出来，把不想要的颜色给过滤掉比如，下面这个蓝色按钮：我们可以在点击时让它变成绿色，这要怎么做呢？直接使用LightingColorFilter把其它颜色都过滤掉，只显示绿色就可以了： 12345678910111213141516171819202122232425public class MyView extends View &#123; private Paint mPaint; private Bitmap mBmp; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.btn); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(0,550); mPaint.setColorFilter(new LightingColorFilter(0x00ff00,0x000000)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; &#125; 这里把mul参数设置为0x00ff00，即把绿色显示出来，把R和B过滤掉。而add参数全部设置为0，即没有对原始图像色彩做任何改变好像这样会有点问题，因为普通我们在点击按钮的时候，不可能会直接把它改变成另一个颜色，而只是增加它的颜色深浅值。比如下面我们增强颜色的蓝色值，将整个图片变得更蓝123456789101112protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new LightingColorFilter(0xffffff,0x0000f0)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; mul参数设置为0xffffff，即没有对颜色做任何改变；add参数设置为0x0000f0，即在每个像素的蓝色值在原来基础上增加0xf0，让原来的图像变得更蓝；这样会显得整个图片的颜色更深。更像按压后的效果。 3、PorterDuffColorFilter这个叫PorterDuff颜色滤镜，也叫图形混合滤镜；其名称是Tomas Proter和Tom Duff两个人名的缩写，他们提出的图形混合的概念极大地推动了图形图像学的发展。 public PorterDuffColorFilter(int srcColor, PorterDuff.Mode mode) int srcColor：0xAARRGGBB类型的颜色值。 PorterDuff.Mode mode：表示混合模式，枚举值有18个，表示各种图形混合模式,有： Mode.CLEAR Mode.SRC Mode.DST Mode.SRC_OVER Mode.DST_OVER Mode.SRC_IN Mode.DST_IN Mode.SRC_OUT Mode.DST_OUT Mode.SRC_ATOP Mode.DST_ATOP Mode.XOR Mode.DARKEN (变暗) Mode.LIGHTEN (变亮) Mode.MULTIPLY (正片叠底) Mode.SCREEN (滤色) Mode.OVERLAY (叠加) Mode.ADD (饱和度相加) 我们拿正片叠底来试下效果：1234567891011121314151617181920212223242526272829public class MyView extends View &#123; private Paint mPaint; private Bitmap mBmp; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); drawPorterDuffFilter(canvas); &#125; private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.MULTIPLY));//变暗 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; &#125; 在录相中给大家演示了通过Photoshop来改变混合模式的过程，录相中分别更改了Mode.DARKEN（变暗），Mode.LIGHTEN（变亮），Mode.MULTIPLY（正片叠底），Mode.OVERLAY（叠加），Mode.SCREEN（滤色）这五种效果，大家可以尝试，我们通过代码得到的效果是与PhotoShop中的模式相同的。但PhotoShop中要比我们中强大的多，除了这些模式以外，还有其它的一些模式是我们所没有的；当然，PhotoShop中的所有这些效果都是可以通过ColorMetrix完成的，但前提是数学和色彩设计知识都要很棒才行哦。但Mode.ADD(饱和度)相加在Photoshop中是没有的。下面我通过代码把这几个效果给大家分别画出来：效果图如下： 对应代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyView extends View &#123; private Paint mPaint; private Bitmap mBmp; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); drawPorterDuffFilter(canvas); &#125; private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.ADD));//饱和度相加 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DARKEN));//变暗 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.LIGHTEN));//变亮 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.MULTIPLY));//正片叠底 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.OVERLAY));//叠加 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SCREEN));//滤色 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; &#125; 在这里大家不必理解PorterDuff.Mode的具体算法，只需要知道应用哪个模式，对应效果是怎样的就可以了。除了上面的六个Mode，还有其它的三组Mode，由于每组Mode的效果都是相同的，所以我们分组来讲 第一组：清空模式 Mode.CLEAR和Mode.XOR他们在这里的效果是完成一致的，就是把图像清空，所以一旦应用他们两个中的任何一个，所得到的结果图像就是一个空图1234567891011121314private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.CLEAR)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.XOR)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; 第二组：目标图像模式在Mode模式中，有一组DST相关的模式，DST所代表的意义就是被应用模式的图像，即我们这里的小狗图片。这些模式有：Mode.DST、Mode.DST_IN、Mode.DST_OUT、Mode.DST_OVER、Mode.DST_ATOP下面我们来看看他们的效果： 1234567891011121314151617181920212223242526private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_IN)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_OUT)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_OVER)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_ATOP)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; 从效果图中可以看到，除了Mode.DST_OUT显示完全透明图片以外，其它全部显示目标图像；所以这几个模式在PorterDuffColorFilter的实际应用中，并没什么用。 第三组：源图模式 在Mode模式中，有一组SRC相关的模式,SRC表示的颜色值所代表的图像，这些模式有：Mode.SRC、Mode.SRC_IN、Mode.SRC_OUT、Mode.SRC_OVER、Mode.SRC_ATOP下面我们来看看他们的效果： 1234567891011121314151617181920212223242526private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_OUT)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_OVER)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_ATOP)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; 从效果图中可以看出，除了Mode.SRC_OUT显示完全透明图片以外，其它全部显示源图像；利用这个特性，我们可以在不同情况下，改变一个纯色图标的颜色。这个也是V4包中DrawableCompat类添加的一个setLint()函数所使用实现方法 setTint(Drawable drawable, int tint) 即最左边是一原图，后面都是指定的各个颜色，利用setTint就可以把一个图片渲染为不同的颜色，这样就可以支持多主题，在不同的风格和不同的情境下使用不同的颜色的图片。由于仅使用一个图片就可以实现多个主题，就不必再引入多个颜色的切图，就可以在一定程度上缩小包的大小。我们不必引入V4包，仅仅通过PorterDuffColorFilter就可以实现setTint的功能: 123456789101112131415161718192021222324252627private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 100; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xffff00ff, PorterDuff.Mode.SRC)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xff00f0ff, PorterDuff.Mode.SRC_ATOP)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xfff0f0ff, PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xffffff00, PorterDuff.Mode.SRC_OVER)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xff000000, PorterDuff.Mode.SRC_ATOP)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; 从效果图中可以看到，SRC相关的模式，只有Mode.SRC_ATOP和SRC_IN能够实现SetTint的功能，其它的是不行的。这里先记着就可以了，后面地讲原理时会具体讲原因。所以这里的一个应用就是通过PorterDuffColorFilter的Mode.SRC_ATOP或SRC_IN模式实现SetTint()的功能；有些同学可能会讲，这个功能是不是可以通过ColorMatrix来实现？当然是可以的，比如我们要将原图标改成第三个效果，即颜色为0xff00f0ff，所对应的矩阵为123456ColorMatrix matrix = new ColorMatrix(new float[]&#123; 0,0,0,0,0, 0,0,0,0,240, 0,0,0,0,255, 0,0,0,1,0 &#125;); 1、PorterDuffColorFilter只能实现与一个特定颜色值的合成。 2、通过Mode.ADD(饱和度相加)，Mode.DARKEN（变暗），Mode.LIGHTEN（变亮），Mode.MULTIPLY（正片叠底），Mode.OVERLAY（叠加），Mode.SCREEN（滤色）可以实现与指定颜色的复合。 3、通过Mode.SRC、Mode.SRC_IN、Mode.SRC_ATOP能够实现setTint()的功能，可以改变纯色图标的颜色。 五、Paint之setXfermode(一)一、GPU硬件加速1、概述GPU英文全称Graphic Processing Unit，中文翻译为“图形处理器”。与CPU不同，GPU是专门为处理图形任务而产生的芯片。在GPU出现之前，CPU一直负责着所有的运算工作，CPU的架构是有利于X86指令集的串行架构，CPU从设计思路上适合尽可能快的完成一个任务。但当面对类似多媒体、图形图像处理类型的任务时，就显得力不从心。因为在多媒体计算中通常要求更高的运算密度、多并发线程和频繁地存储器访问；显然当你打游戏时，屏幕上的动画是需要实时刷新的，这些都需要频繁的计算、存取动作；如果CPU不能及时响应，那么屏幕就会显得很卡……你的队友可能会发一句……我等的花都谢了，你咋还不动呢……为了专门处理多媒体的计算、存储任务，GPU就应运而生了，GPU中自带处理器和存储器，以用来专门计算和存储多媒体任务。对于Andorid来讲，在API 11之前是没有GPU的概念的，在API 11之后，在程序集中加入了对GPU加速的支持，在API 14之后，硬件加速是默认开启的！我们可以显式地强制图像计算时使用GPU而不使用CPU.在CPU绘制和GPU绘制时，在流程上是有区别的：在基于软件的绘制模型下，CPU主导绘图，视图按照两个步骤绘制： 让View层次结构失效 绘制View层次结构在基于硬件加速的绘制模式下，GPU主导绘图，绘制按照三个步骤绘制： 让View层次结构失效 记录、更新显示列表 绘制显示列表可以看到在GPU加速时，流程中多了一项“记录、更新显示列表”，它表示在第一步View层次结构失效后，并不是直接开始逐层绘制，而是首先把这些View的绘制函数作为绘制指令记录一个显示列表中，然后再读取显示列表中的绘制指令调用OpenGL相关函数完成实际绘制。所以在GPU加速时，实际是使用OpenGL的函数来完成绘制的。所以使用GPU加速的优点显而易见：硬件加速提高了Android系统显示和刷新的速度；它有缺点也显而易见： 兼容性问题:由于是将绘制函数转换成OpenGL命令来绘制，定然会存在OpenGL并不能完全支持原始绘制函数的问题，所以这就会造成在打开GPU加速时，效果会失效的问题。 内存消耗问题:由于需要OpenGL的指令，所以需要把系统中的OpenGL相关的包加载到内存中来，所以单纯OpenGL API调用就会占用8MB，而实际上会占用更多内存； 电量消耗问题:多使用了一个部件，当然会更耗电…… 下图显示了一些特殊函数硬件加速开始支持的平台等级：（红叉表示任何平台都不支持，不在列表中的默认在API 11就开始支持）上面我们涉及了两个API等级，在API 11以后，在程序集中加入了对GPU加速的支持，在API 14之后，硬件加速是默认开启的！也就是说在API 11——API 13虽然是支持硬件加速的，但是默认是关闭的。 2、禁用GPU硬件加速方法那么问题就来了，如果你的APP跑在API 14版本以后，而你洽好要用那些不支持硬件加速的函数要怎么办？那就只好禁用硬件加速喽，针对不同类型的东东，Android给我们提供了不同的禁用方法：硬件加速分全局（Application）、Activity、Window、View 四个层级 1.在AndroidManifest.xml文件为application标签添加如下的属性即可为整个应用程序开启/关闭硬件加速：&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; 2.在Activity 标签下使用 hardwareAccelerated 属性开启或关闭硬件加速：&lt;activity android:hardwareAccelerated=&quot;false&quot; /&gt; 3. 在Window 层级使用如下代码开启硬件加速：(Window层级不支持关闭硬件加速)123getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 4.View 级别如下关闭硬件加速：（view 层级上不支持开启硬件加速）setLayerType(View.LAYER_TYPE_SOFTWARE, null); 或者使用android:layerType=”software”来关闭硬件加速：比如 1234567&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" android:paddingLeft="2dp" android:layerType="software" android:paddingRight="2dp" &gt; 二、setXfermode(Xfermode xfermode)之AvoidXfermode这个函数是图像混合里最难的一个了，它的功能也是相当强大的，这个模式叫做图形混合模式。与setColorFilter一样，派生自Xfermode的有三个类： 1、概述——基本流程从上面可以看出，派生自Xfermode的有AvoidXfermode，PixelXorXfermode，PorterDuffXfermode;从硬件加速不支持的函数列表中，我们可以看到AvoidXfermode，PixelXorXfermode是完全不支持的，而PorterDuffXfermode是部分不支持的。 所以在使用Xfermode时，为了保险起见，我们需要做两件事： 禁用硬件加速： setLayerType(View.LAYER_TYPE_SOFTWARE, null); 使用离屏绘制 12345//新建图层 int layerID = canvas.saveLayer(0,0,width,height,mPaint,Canvas.ALL_SAVE_FLAG); //TODO 核心绘制代码//还原图层 canvas.restoreToCount(layerID); 我们需要把绘制的核心代码放在saveLayer()和restoreToCount()之间即可。下面我们先简单讲解AvoidXfermode的用法，然后写个例子，看下SetXfermode()的使用方法和效果AvoidXfermode的声明如下： public AvoidXfermode(int opColor, int tolerance, Mode mode) 当Mode取Mode.TARGET时，它的意义表示将opColor参数所指定的颜色替换成画笔的颜色。 第一个参数opColor：一个16进制的AARRGGBB的颜色值； 第二个参数tolerance：表示容差，这个概念我们后面再细讲 第三个参数mode：取值有两个Mode.TARGET和Mode.AVOID；这里我们先知道Mode.TARGET的意义就可以了，Mode.TARGET表示将指定的颜色替换掉 12345678910111213141516171819202122232425262728public class MyView extends View &#123; private Paint mPaint; private Bitmap mBmp; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); setLayerType(View.LAYER_TYPE_SOFTWARE, null); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); mPaint.setColor(Color.RED); int layerID = canvas.saveLayer(0,0,width,height,mPaint,Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); mPaint.setXfermode(new AvoidXfermode(Color.WHITE,100, AvoidXfermode.Mode.TARGET)); canvas.drawRect(0,0,width,height,mPaint); canvas.restoreToCount(layerID); &#125; &#125; mPaint.setXfermode(new AvoidXfermode(Color.WHITE,100, AvoidXfermode.Mode.TARGET)); 这一点与Photoshop是类似的，就是以白色为目标色，容差为100找到对应的选区；容差是以颜色差异为基础的，任何两个颜色之间的颜色差异是从0-255的范围内的。具体两个颜色之间的差异的的数值为多少是需要靠公式来计算的，而容差的概念就是指与目标色所能容忍的最大颜色差异，所以容差越大，所覆盖的颜色区域就越大；所以当容差为0时，就表示只选择与目标色一模一样的颜色区域；当容差为100时，就表示与目标色值的颜色差异在100范围内的都是可以的；而由于最大的颜色差异是255，所以当我们的容差是255时，所有的颜色都将被选中。 2、canvas脏区域更新原理Android在绘图时会先检查该画笔Paint对象有没有设置Xfermode，如果没有设置Xfermode，那么直接将绘制的图形覆盖Canvas对应位置原有的像素；如果设置了Xfermode，那么会按照Xfermode具体的规则来更新Canvas中对应位置的像素颜色。所以对于AvoidXfermode而言，这个规则就是先把把目标区域（选区）中的颜色值先清空，然后再把目标颜色给替换上；如果没有设置Xfermode，那么直接将绘制的图形覆盖Canvas对应位置原有的像素；如果设置了Xfermode，那么会按照Xfermode具体的规则来更新Canvas中对应位置的像素颜色。 3、AvoidXfermode在讲解了AvoidXfermode的绘图流程和脏区域更新原理后，这里就开始具体的来看看AvoidXfermode这个函数了；AvoidXfermode类已经在API 16弃用了，但目前还没有能替代它的方法，所以API 16以上的平台还是支持的。如果大家想在API 16以上使用这个类，唯一需要注意的是它不支持硬件加速，所以记得禁用硬件加速就可以了；AvoidXfermode的声明如下： public AvoidXfermode(int opColor, int tolerance, Mode mode) 第一个参数opColor：一个16进制的AARRGGBB的颜色值； 第二个参数tolerance：表示容差，这个概念我们后面再细讲 第三个参数mode：取值有两个Mode.TARGET和Mode.AVOID；Mode.TARGET表示将指定的颜色替换掉，这个我们已经前面演示过了，而Mode.AVOID的意思就是Mode.TARGET所选区域的取反。 123456789101112131415protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); mPaint.setColor(Color.RED); int layerID = canvas.saveLayer(0,0,width,height,mPaint,Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); mPaint.setXfermode(new AvoidXfermode(Color.WHITE,100, AvoidXfermode.Mode.AVOID)); canvas.drawRect(0,0,width,height,mPaint); canvas.restoreToCount(layerID); &#125; 因为Android里计算容差与Photoshop的不同，在Photoshop中容差为255时表示全图选区，而在Android中的选区却不是全图！就是因为在计算颜色差值计算时的差异导致的。 三、setXfermode(Xfermode xfermode)之PixelXorXfermode与AvoidXfermode一样也在API 16过时了,它是一个简单的异或运算(op ^ src ^ dst)，返回的alpha值始终等于255，所以对操作颜色混合不是特别的有效；这个类的用法难度不大，而且基本上用不到，这里就不再细讲了，大家有兴趣的话，可以尝试一下。 四、setXfermode(Xfermode xfermode)之PorterDuffXfermode1、概述PorterDuffXfermode的构造函数如下： public PorterDuffXfermode(PorterDuff.Mode mode) 它只有一个参数PorterDuff.Mode，对于PorterDuff.Mode大家应该比较熟悉，我们在讲解setColorFilter时已经用过它： mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.OVERLAY)); 前面我们讲过PorterDuff.Mode表示混合模式，枚举值有18个，表示各种图形混合模式,有： 比如LIGHTEN的计算方式为[Sa + Da - Sa Da, Sc (1 - Da) + Dc (1 - Sa) + max(Sc, Dc)]，其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，在每个公式中，都会被分为两部分[……，……]，其中“,”前的部分为“Sa + Da - Sa Da”这一部分的值代表计算后的Alpha通道而“,”后的部分为“Sc (1 - Da) + Dc (1 - Sa) + max(Sc, Dc)”这一部分的值代表计算后的颜色值，图形混合后的图片就是依据这个公式来对DST和SRC两张图像中每一个像素进行计算，得到最终的结果的。Google给我们了一张图，显示的是两个图形一圆一方通过一定的计算产生不同的组合效果，其中圆形是底部的目标图像，方形是上方的源图像。 在上面的公式中涉及到一个概念，目标图DST，源图SRC。那什么是源图，什么是目标图呢？我们简单举例子来说明一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyView extends View &#123; private int width = 400; private int height = 400; private Bitmap dstBmp; private Bitmap srcBmp; private Paint mPaint; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); dstBmp = makeDst(width,height); srcBmp = makeSrc(width,height); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerID = canvas.saveLayer(0,0,width*2,height*2,mPaint,Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(srcBmp, width/2, height/2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; static Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); c.drawOval(new RectF(0, 0, w, h), p); return bm; &#125; static Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); c.drawRect(0, 0,w,h, p); return bm; &#125; &#125; 它会在源图像所在区域与目标图像运算，在得到结果以后，将结果覆盖到目标图像上。整个过程如下：首先在两个矩形的所在位置： 然后是源图像计算结果的覆盖过程： 其中蓝色小块是源图像所在区域与目标图像经过运算的结果（有关这个结果为什么是一小块蓝色，下篇会具体讲），在得到结果以后，把结果对应区域的图像先清空，然后把结果覆盖上去。（还记得我们在讲解canvas脏数据更新的时候提到，如果没有xfermode就直接覆盖上去，如果有xfermode则先清空对应的区域，然后再覆盖上去）；这里还需要强调一点，源图像在运算时，只是在源图像所在区域与对应区域的目标图像做运算。所以目标图像与源图像不相交的地方是不会参与运算的！这一点非常重要！不相交的地方不会参与运算，所以不相交的地方的图像也不会是脏数据，也不会被更新，所以不相交地方的图像也永远显示的是目标图像。 六、Paint之setXfermode(二)这篇文章将逐个讲解每个模式的意义。这里所讲的各种模式，在大家理解了之后可以回过头来看看setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.XXXX));中的混合过程，其实在PorterDuffColorFilter中的混合过程与这里的setXfermode()设置混合模式的计算方式和效果是完全相同的，只是在PorterDuffColorFilter中只能使用纯色彩，而且是完全覆盖在图片上方；而setXfermode()则不同，它只会在目标图像和源图像交合的位置起作用，而且源图像不一定是纯色的。在开始讲解之前，我们随便拿一个效果图来看一下，我们在这个效果图中需要关注哪两点 123canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN)); canvas.drawBitmap(srcBmp,width/2,height/2, mPaint); 前面在讲canvas的脏区域更新时，已经提到，在最后一句计算效果图像时，是以源图像所在区域为计算目标的，把计算后的源图像更新到对应区域内。所以如上图所示，我们在计算源图像所在区域效果图时，需要着重关注两个区域：1、如图标示区域一：区域一是源图像和目标图像的相交区域，由于在这个区域源图像和目标图像像素都不是空白像素，所以可以明显看出颜色的计算效果。2、如图标示区域二：在区域二中，源图像所在区域的目标图像是空白像素，所以这块区域所表示的意义就是，当某一方区域是空白像素时，此时的计算结果。总而言之：我们在下面的各个模式计算时，只需要关注图示中的区域一和区域二；其中区域一表示当源图像和目标图像像素都不是空白像素时的计算结果，而区域二则表示当某一方区域是空白像素时，此时的计算结果。 一、颜色叠加相关模式这部分涉及到的几个模式有Mode.ADD（饱和度相加）、Mode.DARKEN（变暗），Mode.LIGHTEN（变亮）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加），Mode.SCREEN（滤色） 1、Mode.ADD（饱和度相加）它的公式是Saturate(S + D)；ADD模式简单来说就是对SRC与DST两张图片相交区域的饱和度进行相加同样使用上篇中的示例，一个矩形，一个圆形来做相加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MyView extends View &#123; private int width = 400; private int height = 400; private Bitmap dstBmp; private Bitmap srcBmp; private Paint mPaint; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); srcBmp = makeSrc(width, height); dstBmp = makeDst(width, height); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerID = canvas.saveLayer(0,0,width*2,height*2,mPaint,Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD)); canvas.drawBitmap(srcBmp,width/2,height/2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; // create a bitmap with a circle, used for the "dst" image static Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); c.drawOval(new RectF(0, 0, w, h), p); return bm; &#125; // create a bitmap with a rect, used for the "src" image static Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); c.drawRect(0, 0, w, h, p); return bm; &#125; &#125; 从效果图中可以看出，只有源图与目标图像相交的部分的图像的饱和度产生了变化，没相交的部分是没有变的，因为对方的饱和度是0，当然不相交的位置饱和度是不会变的。这个模式的应用范围比较少，暂时想不到哪里会用到； 2、Mode.LIGHTEN（变亮）它的算法是： [Sa + Da - Sa Da,Sc (1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)]圆形和矩形的效果图为： 这个效果比较容易理解，两个图像重合的区域才会有颜色值变化，所以只有重合区域才有变亮的效果，源图像非重合的区域，由于对应区域的目标图像是空白像素，所以直接显示源图像。 我们在实际应用中，会有下面的这个情况，当选中一本书时，给这本书加上灯光效果 其实它是两张图合成的：DST:目标图像 SRC:源图像 可以看到，在这张图片的最上方中间的位置有些白色半透明的填充，其它位置都是透明的。 12345678910111213141516171819202122232425262728public class LightBookView extends View &#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC; public LightBookView(Context context, AttributeSet attrs) &#123; super(context, attrs); mBitPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.book_bg,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.book_light,null); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); //先画书架，做为目标图像 canvas.drawBitmap(BmpDST,0,0,mBitPaint); mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN)); //再图光点 canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; &#125; 意思就是先把书架做为目标图像画在底层，然后给mBitPaint设置上PorterDuffXfermode，然后将处理过的源图盖在目标图像上。代码难度不大，就不再细讲。 3、Mode.DARKEN（变暗）对应公式是： [Sa + Da - Sa Da,Sc (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)]同样是对应photoshop中的混合模式中的变暗模式 4、Mode.MULTIPLY(正片叠底)公式是：[Sa Da, Sc Dc] 有些同学会奇怪了，Photoshop中也有正片叠底啊，相交区域正片叠底后的颜色确实是绿色的，但源图像的非相交区域怎么没了？我们来看下他的计算公式：[Sa Da, Sc Dc]，在计算alpha值时的公式是Sa * Da，是用源图像的alpha值乘以目标图像的alpha值；由于源图像的非相交区域所对应的目标图像像素的alpha是0，所以结果像素的alpha值仍是0，所以源图像的非相交区域在计算后是透明的。在两个图像的相交区域的混合方式是与photoshop中的正片叠底效果是一致的。 5、Mode.OVERLAY（叠加）这个没有给出公式…… 虽然没有给出公式，但从效果图中可以看到，源图像交合部分有效果，非交合部分依然是存在的，这就可以肯定一点，当目标图像透明时，在这个模式下源图像的色值不会受到影响； 6、Mode.SCREEN（滤色）对应公式是：[Sa + Da - Sa Da, Sc + Dc - Sc Dc] 同样，只是源图像与目标图像交合部分有效果，源图像非交合部分保持原样。 总结 这几种模式都是PhotoShop中存在的模式，是通过计算改变交合区域的颜色值的 除了Mode.MULTIPLY(正片叠底)会在目标图像透明时将结果对应区域置为透明，其它图像都不受目标图像透明像素影响，即源图像非交合部分保持原样。 7、示例——twitter标识的描边效果由于这些模式在photoshop中都存在，直接拿目标图像和源图像在photoshop中就可以演示出来，就没有多举例子，其实，在实现时实现两图像混合时，也经常会用到这些模式的，比如这里twitter的暗光效果。图一：图二：然后完成的效果如下： 我们先想想这个要实现的效果有哪些特性：首先，在图一中，小鸟整个都是蓝色的在图二中，只有小鸟的边缘部分是白色的，中间部分是透明的。在最终的合成图中：图一和图二中小鸟与边缘的是显示的，而且还有某种效果，但小鸟中间的区域变透明了！显示的是底部Activity的背景色。想到我们前面学到的几种样式中，只有Mode.MULTIPLY(正片叠底)会在两个图像的一方透明时，结果像素就是透明的。所以这里使用的模式就是Mode.MULTIPLY 123456789101112131415161718192021222324public class TwitterView extends View &#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC; public TwitterView(Context context, AttributeSet attrs) &#123; super(context, attrs); mBitPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_bg,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_light,null); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,0,0,mBitPaint); mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY)); canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; &#125; 二、SRC相关模式在讲完了photoshop中存在的几个模式以后，还有几个是在处理结果时以源图像显示为主的几个模式，所以大家在遇到当图像相交时，需要显示源图像时，就需要从这几个模式中考虑了这部分所涉及的模式有：Mode.SRC、Mode.SRC_IN、Mode.SRC_OUT、Mode.SRC_OVER、Mode.SRC_ATOP 1、Mode.SRC计算公式为：[Sa, Sc]从公式中也可以看出，在处理源图像所在区域的相交问题时，全部以源图像显示 2、Mode.SRC_IN计算公式为：[Sa Da, Sc Da]在这个公式中结果值的透明度和颜色值都是由Sa,Sc分别乘以目标图像的Da来计算的。所以当目标图像为空白像素时，计算结果也将会为空白像素。 大家注意SRC_IN模式与SRC模式的区别，一般而言，是在相交区域时无论SRC_IN还是SRC模式都是显示源图像，而唯一不同的是，当目标图像是空白像素时，在SRC_IN所对应的区域也将会变成空白像素；其实更严格的来讲，SRC_IN模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。当目标图像透明度为0时，源图像就完全不显示。 示例1：图形圆角 图像一：（我们熟悉的小狗 ） 图像二：（去角遮罩） 效果为： 可以看到这个遮罩的四个角都是圆形切角，都是透明的。现在我们需要利用SRC_IN的特性，显示SRC图像，但会把目标图像中空白像素的部分去掉的特性来做了。由于我们需要最终显示小狗图像，所以这里需要将小狗 图像做为SRC，将遮罩做为目标图像 12345678910111213141516171819202122232425262728public class RoundImageView_SRCIN extends View &#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC; public RoundImageView_SRCIN(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_shade,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,0,0,mBitPaint); mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; &#125; 示例2：图片倒影前面我们讲过，SRC_IN模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。所以当目标图像的透明度在0-255之间时，就会把源图像的透明度和颜色值都会变小。利用这个特性，我们可以做出倒影效果 用到的遮罩为： 这个遮罩好像还不太清，它是一个从上到下的白色填充渐变；白色的透明度从49%到0； 123456789101112131415161718192021222324252627282930313233343536public class InvertedImageView_SRCIN extends View&#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC,BmpRevert; public InvertedImageView_SRCIN(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_invert_shade,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); Matrix matrix = new Matrix(); matrix.setScale(1F, -1F); // 生成倒影图 BmpRevert = Bitmap.createBitmap(BmpSRC, 0, 0, BmpSRC.getWidth(), BmpSRC.getHeight(), matrix, true); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //先画出小狗图片 canvas.drawBitmap(BmpSRC,0,0,mBitPaint); //再画出倒影 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.translate(0,BmpSRC.getHeight()); canvas.drawBitmap(BmpDST,0,0,mBitPaint); mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(BmpRevert,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; &#125; 3、Mode.SRC_OUT计算公式为：[Sa (1 - Da), Sc (1 - Da)]从公式中可以看出，计算结果的透明度=Sa * (1 - Da)；也就是说当目标图像图像完全透明时，计算结果将是透明的； 从示例图中也可以看出，源图像与目标图像的相交部分由于目标图像的透明度为100%，所以相交部分的计算结果为空白像素。在目标图像为空白像素时，完全以源图像显示。所以这个模式的特性可以概括为：以目标图像的透明度的补值来调节源图像的透明度和色彩饱和度。即当目标图像为空白像素时，就完全显示源图像，当目标图像的透明度为100%时，交合区域为空像素。Mode.SRC_OUT简单来说，当目标图像有图像时结果显示空白像素，当目标图像没有图像时，结果显示源图像。 1、橡皮擦效果利用这个特性，我们可以实现橡皮擦效果 原理：我们说了简单来讲Mode.SRC_OUT模式，当目标图像有图像时计算结果为空白像素，当目标图像没有图像时，显示源图像；所以我们把手指轨迹做为目标图像，在与源图像计算时，有手指轨迹的地方就变为空白像素了，看起来的效果就是被擦除了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class DogView_SRCOUT extends View &#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC; private Path mPath; private float mPreX,mPreY; public DogView_SRCOUT(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); mBitPaint.setColor(Color.RED); mBitPaint.setStyle(Paint.Style.STROKE); mBitPaint.setStrokeWidth(45); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888); mPath = new Path(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); //先把手指轨迹画到目标Bitmap上 Canvas c = new Canvas(BmpDST); c.drawPath(mPath,mBitPaint); //然后把目标图像画到画布上 canvas.drawBitmap(BmpDST,0,0,mBitPaint); //计算源图像区域 mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT)); canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(event.getX(),event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float endX = (mPreX+event.getX())/2; float endY = (mPreY+event.getY())/2; mPath.quadTo(mPreX,mPreY,endX,endY); mPreX = event.getX(); mPreY =event.getY(); break; case MotionEvent.ACTION_UP: break; &#125; postInvalidate(); return super.onTouchEvent(event); &#125; &#125; 2、刮刮卡效果首先，搞一个刮刮卡图片：然后再搞个中奖结果：结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class GuaGuaCardView_SRCOUT extends View&#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC,BmpText; private Path mPath; private float mPreX,mPreY; public GuaGuaCardView_SRCOUT(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); mBitPaint.setColor(Color.RED); mBitPaint.setStyle(Paint.Style.STROKE); mBitPaint.setStrokeWidth(45); BmpText = BitmapFactory.decodeResource(getResources(),R.drawable.guaguaka_text,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.guaguaka_pic,null); BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888); mPath = new Path(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(BmpText,0,0,mBitPaint); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); //先把手指轨迹画到目标Bitmap上 Canvas c = new Canvas(BmpDST); c.drawPath(mPath,mBitPaint); //然后把目标图像画到画布上 canvas.drawBitmap(BmpDST,0,0,mBitPaint); //计算源图像区域 mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT)); canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(event.getX(),event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float endX = (mPreX+event.getX())/2; float endY = (mPreY+event.getY())/2; mPath.quadTo(mPreX,mPreY,endX,endY); mPreX = event.getX(); mPreY =event.getY(); break; case MotionEvent.ACTION_UP: break; &#125; postInvalidate(); return super.onTouchEvent(event); &#125; &#125; 与上面橡皮擦效果不同的是，在绘图时，在特效前先把刮刮卡的中奖文字绘在底部，这时候当橡皮擦把刮刮卡的图片给擦除掉时，就露出底部的刮刮卡的中奖文字了。 4、Mode.SRC_OVER计算公式为：[Sa + (1 - Sa) Da, Rc = Sc + (1 - Sa) Dc]我们可以看到，在计算结果中，源图像没有变。它的意思就是在目标图像的顶部绘制源图像。从公式中也可以看出目标图像的透明度为Sa + (1 - Sa)*Da；即在源图像的透明度基础上增加一部分目标图像的透明度。增加的透明度是源图像透明度的补量；目标图像的色彩值的计算方式同理，所以当源图像透明度为100%时，就原样显示源图像； 5、Mode.SRC_ATOP计算公式为：[Da, Sc Da + (1 - Sa) Dc]很奇怪，它的效果图竟然与SRC_IN模式是相同的，我们来对比一下它们的公式：SRC_IN: [Sa Da, Sc Da]SRC_ATOP:[Da, Sc Da + (1 - Sa) Dc]先看透明度：在SRC_IN中是Sa Da,在SRC_ATOP是DaSRC_IN是源图像透明度乘以目标图像的透明度做为结果透明度，而SRC_ATOP是直接使用目标图像的透明度做为结果透明度再看颜色值：SRC_IN的颜色值为 Sc Da，SRC_ATOP的颜色值为Sc Da + (1 - Sa) Dc；SRC_ATOP在SRC_IN的基础上还增加了(1 - Sa) * Dc； 总结 当透明度只有100%和0%时，SRC_ATOP是SRC_IN是通用的 当透明度不只有100%和0%时，SRC_ATOP相比SRC_IN源图像的饱和度会增加，即会显得更亮！ 所以，前面利用SRC_IN实现的圆角效果是完全可以使用SRC_ATOP模式来实现的。 1、圆角效果（当透明度只有100%和0%时，SRC_ATOP是SRC_IN是通用的） 代码中仅将SRC_IN模式改为SRC_ATOP模式即可 示例2：图片倒影(颜色饱和度增加)前面我们讲过，当目标图像的透明度不是100%和0%时，源图像的颜色值就会比SRC_IN模式的颜色值饱和度增加。我们来对比下效果：同样只需要在将原图片倒影代码的SRC_IN模式改成SRC_ATOP即可 效果图如下：然后再来看看原来SRC_IN的效果图，对比一下： 明显亮度是有增加的。所以对于SRC_ATOP的结论就出来了，一般而言SRC_ATOP是可以和SRC_IN通用的，但SRC_ATOP所产生的效果图在目标图不是透明度不是0或100%的时候，会比SRC_IN模式产生的图像更亮些； 七、Paint之setXfermode(三)一、DST相关模式在讲完了SRC相关的模式以后，我们知道SRC相关的模式，都是在相交区域优先显示源图像为主。与之相对应的有DST相关的模式，在DST相关的模式中，在处理相交区域时，优先以目标图像显示为主。这部分所涉及的模式有：Mode.DST、Mode.DST_IN、Mode.DST_OUT、Mode.DST_OVER、Mode.DST_ATOP 1、Mode.DST计算公式为：[Da, Dc]从公式中也可以看出，在处理源图像所在区域的相交问题时，正好与Mode.SRC相反，全部以目标图像显示 2、Mode.DST_IN计算公式为：[Da Sa,Dc Sa]我们与Mode.SRC_IN的公式对比一下：SRC_IN:[Sa Da, Sc Da]正好与SRC_IN相反，Mode.DST_IN是在相交时利用源图像的透明度来改变目标图像的透明度和饱和度。当源图像透明度为0时，目标图像就完全不显示。由于Mode.DST_IN的模式与SRC_IN正好是相反，所以我们利用Mode.SRC_IN实现的示例，只需要将源图像与目标图像对调就可以使用Mode.DST_IN来实现了。 示例1、区域波纹之前讲解了水波纹效果，但这个水波纹效果却只能是一固定在一个矩形区域，本例我们就利用xfermode来实现在不规则区域中显示水波纹效果，效果图如下： 这里使用到一张图片 在这张图片中，只有文字部分是纯白色的，其它区域都是透明像素。所以再加上我们需要自己绘制的水波纹效果的图片，这里就有两张图片了，一张是水波纹效果图，另一张是text_shade.png那么问题来了，如果我们使用Mode.DST_IN模式的话，谁当目标图像，谁当源图像呢？这就需要分析Mode.DST_IN模式的成像原理了，在Mode.DST_IN中，源图像所占区域计算结果图像时，相交区域显示的是DST目标图像；所以我们要最终显示的被裁剪后的波纹图，所以DST目标图像就应该是波纹图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class CircleWave_DSTIN extends View &#123; private Paint mPaint; private Path mPath; private int mItemWaveLength = 1000; private int dx; private Bitmap BmpSRC,BmpDST; public CircleWave_DSTIN(Context context, AttributeSet attrs) &#123; super(context, attrs); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.text_shade,null); BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888); startAnim(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); generageWavePath(); //先清空bitmap上的图像,然后再画上Path Canvas c = new Canvas(BmpDST); c.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR); c.drawPath(mPath,mPaint); canvas.drawBitmap(BmpSRC,0,0,mPaint); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,0,0,mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); canvas.drawBitmap(BmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; /** * 生成此时的Path */ private void generageWavePath()&#123; mPath.reset(); int originY = BmpSRC.getHeight()/2; int halfWaveLen = mItemWaveLength/2; mPath.moveTo(-mItemWaveLength+dx,originY); for (int i = -mItemWaveLength;i&lt;=getWidth()+mItemWaveLength;i+=mItemWaveLength)&#123; mPath.rQuadTo(halfWaveLen/2,-50,halfWaveLen,0); mPath.rQuadTo(halfWaveLen/2,50,halfWaveLen,0); &#125; mPath.lineTo(BmpSRC.getWidth(),BmpSRC.getHeight()); mPath.lineTo(0,BmpSRC.getHeight()); mPath.close(); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(2000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125; &#125; 2、心电图 很明显，正规的心电图应该是利用Path把当前的实时的点连接起来，我这里只是一张图片(hearmap.png)通过使用动画来实现的 中间是一条心电图线，其余位置都是透明像素；大家先想想我们要怎么利用这张图片实现上面的动画呢？利用Mode.DST_IN模式，由于在这个模式中，相交区域优先显示目标图像，所以我们这里需要显示心电图，所以心电图就是目标图像。那么问题来了，源图像是啥？由于我们需要从右向左逐渐显示心电图图像，所以我们源图像就是自建的空白图像，在这个图像中，绘制一个矩形，逐渐增大矩形的区域，即相交区域也会跟着增大，由于相交区域会显示出目标图像，显示出来的结果就是心电图的动画 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HeartMap extends View &#123; private Paint mPaint; private int mItemWaveLength = 0; private int dx=0; private Bitmap BmpSRC,BmpDST; public HeartMap(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.heartmap,null); BmpSRC = Bitmap.createBitmap(BmpDST.getWidth(), BmpDST.getHeight(), Bitmap.Config.ARGB_8888); mItemWaveLength = BmpDST.getWidth(); startAnim(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Canvas c = new Canvas(BmpSRC); //清空bitmap c.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR); //画上矩形 c.drawRect(BmpDST.getWidth() - dx,0,BmpDST.getWidth(),BmpDST.getHeight(),mPaint); //模式合成 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,0,0,mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); canvas.drawBitmap(BmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(6000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125; &#125; 3、不规则波纹 上面我们实现的波纹效果都是规则的，如果我们想实现如下图这样的不规则波纹要怎么办呢？ 在这里我们需要用到两张图： 一张不规则的波浪图 想必到这里，可能很多同学都知道要怎么做了就是在圆形遮罩上绘制不断移动的不规则的波浪图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class IrregularWaveView extends View &#123; private Paint mPaint; private int mItemWaveLength = 0; private int dx=0; private Bitmap BmpSRC,BmpDST; public IrregularWaveView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.wave_bg,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.circle_shape,null); mItemWaveLength = BmpDST.getWidth(); startAnim(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //先画上圆形 canvas.drawBitmap(BmpSRC,0,0,mPaint); //再画上结果 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,new Rect(dx,0,dx+BmpSRC.getWidth(),BmpSRC.getHeight()),new Rect(0,0,BmpSRC.getWidth(),BmpSRC.getHeight()),mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); canvas.drawBitmap(BmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(4000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125; &#125; 3、Mode.DST_OUT计算公式为：[Da (1 - Sa), Dc (1 - Sa)] 同样，我们拿这个公式与Mode.SRC_OUT对比一下，Mode.SRC_OUT：[Sa (1 - Da), Sc (1 - Da)]可以看出Mode.SRC_OUT是利用目标图像的透明度的补值来改变源图像的透明度和饱和度。而Mode.DST_OUT反过来，是通过源图像的透明度补值来改变目标图像的透明度和饱和度。简单来说，在Mode.DST_OUT模式下，就是相交区域显示的是目标图像，目标图像的透明度和饱和度与源图像的透明度相反，当源图像透明底是100%时，则相交区域为空值。当源图像透明度为0时，则完全显示目标图像。非相交区域完全显示目标图像。 示例图像为： 有些同学对这个结果可能感觉很奇怪，我们来分析一下，上篇中我们提到在xfermode的示例图像中，我们主要需要关注两点： 图中编号1的相交区域：在DST_OUT模式下，由于源图像的透明度是100%，所以计算后的结果图像在这个区域是空像素。图中编号2的非相交区域：在DST_OUT模式下，这个区域的源图像透明度仍为100%，所以计算后的结果图像在这个区域仍是空像素。所以我们做下简单的总结，当源图像区域透明度为100%时，所在区域计算结果为透明像素，当源图像的区域透明时，计算结果就是目标图像；这与SRC_OUT模式的结果正好相反，在SRC_OUT模式下，当目标图像区域透明度为100%时，所在区域计算结果为透明像素，当目标图像的区域透明时，计算结果就是源图像；所以，在上篇中，使用SRC_OUT模式实现的橡皮擦效果和刮刮卡效果都是可以使用DST_OUT模式实现的，只需要将SRC和DST所对应的图像翻转一下就可以了；这里就不再实现了，大家自己来试试吧。 4、Mode.DST_OVER计算公式为：[Sa + (1 - Sa) Da, Rc = Dc + (1 - Da) Sc]同样先写Mode.SRC_OVER对比一下，SRC_OVER：[Sa + (1 - Sa) Da, Rc = Sc + (1 - Sa) Dc]所以它们的效果就是在SRC模式中以显示SRC图像为主变成了以显示DST图像为主。从SRC模式中的使用目标图像控制结果图像的透明度和饱和度变成了由源图像控件结果图像的透明度和饱和度。示例图像为： 5、Mode.DST_ATOP计算公式为：[Sa, Sa Dc + Sc (1 - Da)]示例图像为： 由于在SRC中，我们知道了Mode.SRC_ATOP与MODE.SRC_IN的区别：一般而言SRC_ATOP是可以和SRC_IN通用的，但SRC_ATOP所产生的效果图在目标图的透明度不是0或100%的时候，会比SRC_IN模式产生的图像更亮些；我们再来对比下DST中的两个模式与SRC中的这两个模式中公式中区别：SRC_IN: [Sa Da, Sc Da]SRC_ATOP:[Da, Sc Da + (1 - Sa) Dc]DST_IN:[Da Sa , Dc Sa ]DST_ATOP:[Sa, Sa Dc + Sc (1 - Da)]从公式中可以看到，在SRC模式中，以显示源图像为主，透明度和饱和度利用Da来调节而在DST模式中，以显示目标图像为主，透明度和饱和度利用Sa来调节 所以Mode.DST_ATOP与Mode.DST_IN的关系也是：一般而言DST_ATOP是可以和DST_IN通用的，但DST_ATOP所产生的效果图在源图像的透明度不是0或100%的时候，会比DST_IN模式产生的图像更亮些；同样，大家也可以使用Mode.DST_ATOP实现上篇文章中Mode.SRC_ATOP的两个示例：圆角效果和图片倒影，这里就不再讲了 总结 DST相关模式是完全可以使用SRC对应的模式来实现的，只不过需要将目标图像和源图像对调一下即可。 在SRC模式中，是以显示源图像为主，通过目标图像的透明度来调节计算结果的透明度和饱和度，而在DST模式中，是以显示目标图像为主，通过源图像的透明度来调节计算结果的透明度和饱和度。 二、其它模式除了颜色叠加系列模式，SRC系列模式和DST系列模式以外，另外还有两个模式Mode.CLEAR和Mode.XOR,下面我们就来看看它们的用法 1、Mode.CLEAR计算公式：[0, 0] 前面我们做清空图像的时候用过这个方法，从公式中可以看到，计算结果直接就是[0,0]即空像素。也就是说，源图像所在区域都会变成空像素！这样就起到了清空源图像所在区域图像的功能了。上面示例中已经存在这个Mode的用法，这里就不再举例了。 2、Mode.XOR计算公式为：[Sa + Da - Sa Da,Sc (1 - Da) + Dc * (1 - Sa) + min(Sc, Dc)] 单从示例图像中，好像是异或的功能，即将源图像中除了相交区域以外的部分做为结果。但仔细看看公式，其实并没有这么简单。首先看公式中透明度部分：Sa + Da - Sa Da，就是将目标图像和源图像的透明度相加，然后减去它们的乘积，所以计算结果的透明度会增大（即比目标图像和源图像都大，当其中一个图像的透明度为1时，那结果图像的透明度肯定是1）然后再看颜色值部分：Sc (1 - Da) + Dc * (1 - Sa) + min(Sc, Dc)；表示源图像和目标图像分别以自己的透明度的补值乘以对方的颜色值，然后相加得到结果。最后再加上Sc, Dc中的最小值。 在实际应用中，我们可以从下面三个方面来决定使用哪一个模式： 首先，目标图像和源图像混合，需不需要生成颜色的叠加特效，如果需要叠加特效则从颜色叠加相关模式中选择，有Mode.ADD（饱和度相加）、Mode.DARKEN（变暗），Mode.LIGHTEN（变亮）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加），Mode.SCREEN（滤色） 当不需要特效，而需要根据某一张图像的透明像素来裁剪时，就需要使用SRC相关模式或DST相关模式了。由于SRC相关模式与DST相关模式是相通的，唯一不同的是决定当前哪个是目标图像和源图像； 当需要清空图像时，使用Mode.CLEAR 四、Canvas八、Canvas与图层(一)一、如何获得一个Canvas对象方法一：自定义view时， 重写onDraw、dispatchDraw方法（1）、定义我们先来看一下onDraw、dispatchDraw方法的定义1234567protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125; protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); &#125; 可以看到onDraw、dispatchDraw在传入的参数中都有一个canvas对象。这个canvas对象是View中的Canvas对象，利用这个canvas对象绘图，效果会直接反应在View中； （2）、onDraw、dispatchDraw区别 onDraw()的意思是绘制视图自身 dispatchDraw()是绘制子视图 无论是View还是ViewGroup对它们俩的调用顺序都是onDraw()-&gt;dispatchDraw()但在ViewGroup中，当它有背景的时候就会调用onDraw()方法，否则就会跳过onDraw()直接调用dispatchDraw()；所以如果要在ViewGroup中绘图时，往往是重写dispatchDraw()方法在View中，onDraw()和dispatchDraw()都会被调用的，所以我们无论把绘图代码放在onDraw()或者dispatchDraw()中都是可以得到效果的，但是由于dispatchDraw()的含义是绘制子控件，所以原则来上讲，在绘制View控件时，我们是重新onDraw()函数。 总结在绘制View控件时，需要重写onDraw()函数，在绘制ViewGroup时，需要重写dispatchDraw()函数。 方法二：使用Bitmap创建1、构建方法Canvas c = new Canvas(bitmap); 或 Canvas c = new Canvas(); c.setBitmap(bitmap); 其中bitmap可以从图片加载，也可以创建，有下面几种方法 //方法一：新建一个空白bitmap Bitmap bmp = Bitmap.createBitmap(width ,height Bitmap.Config.ARGB_8888); //方法二：从图片中加载 Bitmap bmp = BitmapFactory.decodeResource(getResources(),R.drawable.wave_bg,null); 2、在OnDraw（）中使用我们一定要注意的是，如果我们用bitmap构造了一个canvas，那这个canvas上绘制的图像也都会保存在这个bitmap上，而不是画在View上，如果想画在View上就必须使用OnDraw（Canvas canvas）函数中传进来的canvas画一遍bitmap才能画到view上。 123456789101112131415161718192021222324public class BitmapCanvasView extends View &#123; private Bitmap mBmp; private Paint mPaint; private Canvas mBmpCanvas; public BitmapCanvasView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mBmp = Bitmap.createBitmap(500 ,500 , Bitmap.Config.ARGB_8888); mBmpCanvas = new Canvas(mBmp); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setTextSize(100); mBmpCanvas.drawText("启舰大SB",0,100,mPaint); canvas.drawBitmap(mBmp,0,0,mPaint); &#125; &#125; 方法三：SurfaceHolder.lockCanvas()Canvas除了save()和restore()以外，还有其它一些函数来保存和恢复画布状态，这部分我们就来看看。 1、saveLayer()saveLayer()有两个函数： /** * 保存指定矩形区域的canvas内容 */ public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) RectF bounds：要保存的区域的矩形。 int saveFlags：取值有：ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG、HAS_ALPHA_LAYER_SAVE_FLAG、FULL_COLOR_LAYER_SAVE_FLAG、CLIP_TO_LAYER_SAVE_FLAG总共有这六个，其中ALL_SAVE_FLAG表示保存全部内容 第二个构造函数实际与第一个是一样的，只不过是根据四个点来构造一个矩形。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class XfermodeView extends View &#123; private int width = 400; private int height = 400; private Bitmap dstBmp; private Bitmap srcBmp; private Paint mPaint; public XfermodeView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); srcBmp = makeSrc(width, height); dstBmp = makeDst(width, height); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.GREEN); int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; // create a bitmap with a circle, used for the "dst" image static Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); c.drawOval(new RectF(0, 0, w, h), p); return bm; &#125; // create a bitmap with a rect, used for the "src" image static Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); c.drawRect(0, 0, w, h, p); return bm; &#125; &#125; 那么问题来了，如果我们把saveLayer给去掉，看看会怎样： 我们先回顾下Mode.SRC_IN的效果：在处理源图像时，以显示源图像为主，在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。当目标图像透明度为0时，源图像就完全不显示。再回过来看结果，第一个结果是对的，因为不与圆相交以外的区域透明度都是0，而第二个图像怎么就变成了这屌样，源图像全部都显示出来了。 （1）、saveLayer的绘图流程这是因为在调用saveLayer时，会生成了一个全新的bitmap，这个bitmap的大小就是我们指定的保存区域的大小，新生成的bitmap是全透明的，在调用saveLayer后所有的绘图操作都是在这个bitmap上进行的。 1234int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); 我们讲过，在画源图像时，会把之前画布上所有的内容都做为目标图像，而在saveLayer新生成的bitmap上，只有dstBmp对应的圆形，所以除了与圆形相交之外的位置都是空像素。在画图完成之后，会把saveLayer所生成的bitmap盖在原来的canvas上面。所以此时的xfermode的合成过程如下图所示： savelayer新建的画布上的图像做为目标图像，矩形所在的透明图层与之相交，计算结果画在新建的透明画布上。最终将计算结果直接盖在原始画布上，形成最终的显示效果。 （2）、没有saveLayer的绘图流程然后我们再来看第二个示例，在第二个示例中，唯一的不同就是把saveLayer去掉了；在saveLayer去掉后，所有的绘图操作都放在了原始View的Canvas所对应的Bitmap上了12345678protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.GREEN); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); mPaint.setXfermode(null); &#125; 由于我们先把整个画布给染成了绿色，然后再画上了一个圆形，所以在应用xfermode来画源图像的时候，目标图像当前Bitmap上的所有图像了，也就是整个绿色的屏幕和一个圆形了。所以这时候源图像的相交区域是没有透明像素的，透明度全是100%，这也就不难解释结果是这样的原因了。此时的xfermode合成过程如下： 由于没有调用saveLayer，所以圆形是直接画在原始画布上的，而当矩形与其相交时，就是直接与原始画布上的所有图像做计算的。总结saveLayer会创建一个全新透明的bitmap，大小与指定保存的区域一致，其后的绘图操作都放在这个bitmap上进行。在绘制结束后，会直接盖在上一层的Bitmap上显示。 2、画布与图层上面我们讲到了画布(Bitmap)、图层(Layer)和Canvas的概念，估计大家都会被绕晕了。下面我们下面来具体讲解下它们之间的关系。图层(Layer)：每一次调用canvas.drawXXX系列函数时，都会生成一个透明图层来专门来画这个图形，比如我们上面在画矩形时的透明图层就是这个概念。画布(bitmap)：每一个画布都是一个bitmap，所有的图像都是画在bitmap上的！我们知道每一次调用canvas.drawxxx函数时，都会生成一个专用的透明图层来画这个图形，画完以后，就盖在了画布上。所以如果我们连续调用五个draw函数，那么就会生成五个透明图层，画完之后依次盖在画布上显示。画布有两种，第一种是view的原始画布，是通过onDraw（Canvas canvas）函数传进来的，其中参数中的canvas就对应的是view的原始画布，控件的背景就是画在这个画布上的！另一种是人造画布，通过saveLayer()、new Canvas(bitmap)这些方法来人为新建一个画布。尤其是saveLayer()，一旦调用saveLayer()新建一个画布以后，以后的所有draw函数所画的图像都是画在这个画布上的，只有当调用restore()、resoreToCount()函数以后，才会返回到原始画布上绘制。Canvas:这个概念比较难理解，我们可以把Canvas理解成画板，Bitmap理解成透明画纸，而Layer则理解成图层；每一个draw函数都对应一个图层，在一个图形画完以后，就放在画纸上显示。而一张张透明的画纸则一层层地叠加在画板上显示出来。我们知道画板和画纸都是用夹子夹在一起的，所以当我们旋转画板时，所有画纸都会跟着旋转！当我们把整个画板裁小时，所以的画纸也都会变小了！这一点非常重要，当我们利用saveLayer来生成多个画纸时，然后最上层的画纸调用canvas.rotate(30)是把画板给旋转了，所有的画纸也都被旋转30度！这一点非常注意。另外，如果最上层的画纸调用canvas.clipRect()将画板裁剪了，那么所有的画纸也都会被裁剪。唯一能够恢复的操作是调用canvas.revert()把上一次的动作给取消掉！但在利用canvas绘图与画板不一样的是，画布的影响只体现在以后的操作上，以前画上去的图像已经显示在屏幕上是不会受到影响的。 三、save()、saveLayer()、saveLayerAlpha()中的用法1、saveLayer的用法public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) 我们前面提到了saveLayer会新建一个画布(bitmap)，后续的所有操作都是在这个画布上进行的。下面我们来分别看下saveLayer使用中的注意事项。 （1）、saveLayer后的所有动作都只对新建画布有效123456789101112131415161718192021public class SaveLayerUseExample_3_1 extends View&#123; private Paint mPaint; private Bitmap mBitmap; public SaveLayerUseExample_3_1(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.dog);; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mBitmap,0,0,mPaint); int layerID = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); canvas.skew(1.732f,0); canvas.drawRect(0,0,150,160,mPaint); canvas.restoreToCount(layerID); &#125; &#125; 在onDraw中，我们先在view的原始画布上画上了小狗的图像，然后利用saveLayer新建了一个图层，然后利用canvas.skew将新建的图层水平斜切45度。所以之后画的矩形(0,0,150,160)就是斜切的。而正是由于在新建画布后的各种操作都是针对新建画布来操作的，不会对以前的画布产生影响，从效果图中也明显可以看出，将画布水平斜切45度也只影响了saveLayer的新建画布，并没有对之前的原始画布产生影响。 （2）、通过Rect指定矩形大小就是新建的画布大小在saveLayer的参数中，我们可以通过指定Rect对象或者指定四个点来来指定一个矩形，这个矩形的大小就是新建画布的大小，我们举例来看一下：12345678910111213141516171819202122public class SaveLayerUseExample_3_1 extends View &#123; private Paint mPaint; private Bitmap mBitmap; public SaveLayerUseExample_3_1(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog); ; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mBitmap, 0, 0, mPaint); int layerID = canvas.saveLayer(0, 0, 100, 100, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawRect(0, 0, 500, 600, mPaint); canvas.restoreToCount(layerID); &#125; &#125; 在绘图时，我们先把小狗图片绘制在原始画布上的，然后新建一个大小为(0,0,100,100)大小的透明画布，然后再在这个画布上画一个(0, 0, 500, 600)的矩形。由于画布大小只有(0,0,100,100)，所以(0, 0, 500, 600)这个矩形并不能完全显示出来，也只能显示出来(0,0,100,100)画布大小的部分。那有些同学会说了，nnd，为了避免画布太小而出现问题，我每次都新建一个屏幕大小的画布多好，这样虽然是不会出现问题，但你想过没有，屏幕大小的画布需要多少空间吗，按一个像素需要8bit存储空间算，1024 768的机器，所使用的bit数就是1024 768 8=6.2M！所以我们在使用saveLayer新建画布时，一定要选择适当的大小，不然你的APP很可能OOM哦。*注意，注意：在我的例子中都是直接新建全屏画布的，因为写例子比较方便！！！！但是我这只是示例，在现实使用中，一定要适量的创建画布的大小哦！ 2、saveLayerAlpha的用法public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags) public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags) 相比saveLayer，多一个alpha参数，用以指定新建画布透明度,取值范围为0-255，可以用16进制的oxAA表示；这个函数的意义也是在调用的时候会新建一个bitmap画布，以后的各种绘图操作都作用在这个画布上，但这个画布是有透明度的，透明度就是通过alpha值指定的。 123456789101112131415161718192021public class SaveLayerAlphaView extends View &#123; private Paint mPaint; public SaveLayerAlphaView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(100,100,300,300,mPaint); int layerID = canvas.saveLayerAlpha(0,0,600,600,0x88,Canvas.ALL_SAVE_FLAG); mPaint.setColor(Color.GREEN); canvas.drawRect(200,200,400,400,mPaint); canvas.restoreToCount(layerID); &#125; &#125; 在saveLayerAlpha以后，我们画了一个绿色的矩形，由于把saveLayerAlpha新建的矩形的透明度是0x88（136）大概是50%透明度，从效果图中也可以看出在新建图像与上一画布合成后，是具有透明度的。 九、Canvas与图层（二）一、FLAG的具体意义1、FLAG概述有关save系列函数，在canvas中总共有如下几个： public int save() public int save(int saveFlags) public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags) public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags) 这段我们先关注前四个，save的两个函数和saveLayer的两个函数；我们知道他们两个不同之处在于saveLayer会新建一个画布，而save函数则不会新建画布；它们都具有Flag标识，这些Flag标识的意义和使用范围如下： FLAG 意义 适用范围 ALL_SAVE_FLAG 保存所有的标识 save()、saveLayer() MATRIX_SAVE_FLAG 仅保存canvas的matrix数组 save()、saveLayer() CLIP_SAVE_FLAG 仅保存canvas的当前大小 save()、saveLayer() HAS_ALPHA_LAYER_SAVE_FLAG 标识新建的bmp具有透明度，在与上层画布结合时，透明位置显示上图图像,与FULL_COLOR_LAYER_SAVE_FLAG冲突，若同时指定，则以HAS_ALPHA_LAYER_SAVE_FLAG为主 saveLayer() FULL_COLOR_LAYER_SAVE_FLAG 标识新建的bmp颜色完全独立，在与上层画布结合时，先清空上层画布再覆盖上去 saveLayer() CLIP_TO_LAYER_SAVE_FLAG 在保存图层前先把当前画布根据bounds裁剪，与CLIP_SAVE_FLAG冲突，若同时指定，则以CLIP_SAVE_FLAG为主 saveLayer() 从上面的表格中可以看到，ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG是save()、saveLayer()共用的。而另外三个是saveLayer()专用的；我们一个个来解析下它们的不同之处在讲解之前，我们先考虑一下，如果让我们保存一个画布的状态，以便恢复，我们需要保存哪些内容呢？第一个是位置信息，第二个是大小信息；好像除此之外也没什么了。所以，位置信息对应的是MATRIX_SAVE_FLAG，大小信息对应的是：CLIP_SAVE_FLAG，这也就是save\saveLayer所共用的，而另外的三个函数，则是指定saveLayer新建的bitmap具有哪种特性。已经不再是保存画布的范畴了。 2、FLAG之MATRIX_SAVE_FLAG(1)、save(int flag)与MATRIX_SAVE_FLAG我们知道canvas.translate(平移)、canvas.rotate（旋转）、canvas.scale（缩放）、canvas.skew（扭曲）其实都是利用位置矩阵matrix实现的，而MATRIX_SAVE_FLAG标识就是指定只保存这个位置矩阵，除此之外的其它任何内容都不会被保存。1234567891011121314151617181920212223public class MATRIX_SAVE_FLAG_View extends View &#123; private Paint mPaint; public MATRIX_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(Canvas.MATRIX_SAVE_FLAG); canvas.rotate(40); canvas.drawRect(100,0,200,100,mPaint); canvas.restore(); mPaint.setColor(Color.YELLOW); canvas.drawRect(100,0,200,100,mPaint); &#125; &#125; 我们直接看OnDraw函数，先调用 canvas.save(Canvas.MATRIX_SAVE_FLAG)将canvas的位置矩阵保存起来，然后将画布旋转40度之后，画一个绿色矩形；然后调用canvas.restore()之后将画布恢复，然后再在同一个位置画一个黄色的矩形。 很明显，在canvas.restore()后，画布的旋转给恢复到了原来了状态。然后我们再来看看，如果我们给画布裁剪，看还能不能被恢复 12345678910111213141516171819202122public class MATRIX_SAVE_FLAG_View extends View &#123; private Paint mPaint; public MATRIX_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(Canvas.MATRIX_SAVE_FLAG); canvas.clipRect(100,0,200,100); canvas.drawColor(Color.GREEN); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 从效果图来看，我们恢复画布后，把画布全部染成了黄色，但并没有染全屏幕的画布，而只是clip后的一部分，这说明，被裁剪的画布没有被还原！前面我们说了调用 canvas.save(Canvas.MATRIX_SAVE_FLAG)只会保存了位置矩阵！恢复时，也只会恢复画布的位置信息，有关画布的大小，是不会被恢复的！ （2）、saveLayer()与MATRIX_SAVE_FLAG同样先来看旋转的例子：12345678910111213141516171819202122232425public class MATRIX_SAVE_FLAG_View extends View &#123; private Paint mPaint; public MATRIX_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.rotate(40); canvas.drawRect(100,0,200,100,mPaint); canvas.restore(); mPaint.setColor(Color.YELLOW); canvas.drawRect(100,0,200,100,mPaint); &#125; &#125; 这里在保存Flag时，多了一个Canvas.HAS_ALPHA_LAYER_SAVE_FLAG，表示在新建的画布在合成到上一个画布上时，直接覆盖，不清空所在区域原图像，这个标识这里先忽略，我们后面会具体讲。效果与原因都是与save()相同，指定保存Canvas.MATRIX_SAVE_FLAG，即canvas的位置信息，当调用canvas.revert()后，原始画布的旋转被恢复。所以再次画图到原始画布上时，是没有旋转的。我们还是直接来看例子吧，裁剪： 1234567891011121314151617181920212223public class MATRIX_SAVE_FLAG_View extends View &#123; private Paint mPaint; public MATRIX_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.GREEN); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.clipRect(100,0,200,100); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 与上面的例子一样，在saveLayer中也只是保存Canvas.MATRIX_SAVE_FLAG，即canvas的位置信息，之后调用canvas.clipRect(100,0,200,100);将画板裁剪，注意我们在讲解canvas时提到了，无论哪个图层调用canvas的位置变换和裁剪操作，所有的画布都会受到连累，这些连累也只表现在画布以后的绘图上，之前画过的图像不会受到影响。所以在clipRect之前画出来的全屏绿色是不受影响的，当restore()以后，canvas只恢复了原始画布的位置信息而原始画布的大小却无法被恢复，所以当再调用 canvas.drawColor(Color.YELLOW)，也只能画出来一小块了。注意：在上面的例子中用到了canvas.clipRect()，这个函数是不支持硬件加速的，所以需要添加setLayerType函数来禁用硬件加速。总结 当save\saveLayer调用Canvas.MATRIX_SAVE_FLAG标识时只会保存画布的位置矩阵信息，在canvas.restore()时也只会恢复位置信息，而改变过的画布大小是不会被恢复的。 当使用canvas.saveLayer(Canvas.MATRIX_SAVE_FLAG)时，需要与Canvas.HAS_ALPHA_LAYER_SAVE_FLAG一起使用，不然新建画布所在区域原来的图像将被清空。 3、FLAG之CLIP_SAVE_FLAG这个标识的意思是仅保存Canvas的裁剪信息，而对于位置信息则不管不问，所以在canvas.restore()时，会只恢复Canvas的大小，而对于Canvas的旋转、平移等位置改变的信息是不会恢复的。 (1)、save(int flag)与CLIP_SAVE_FLAG我们先来看个裁剪的例子：123456789101112131415161718192021public class CLIP_SAVE_FLAG_View extends View &#123; private Paint mPaint; public CLIP_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.save(Canvas.CLIP_SAVE_FLAG); canvas.clipRect(100,0,200,100); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 从效果图中可以看出在canvas.restore()后，canvas被恢复到初始化的全屏大小。然后我们再看一个旋转的例子1234567891011121314151617181920212223public class CLIP_SAVE_FLAG_View extends View &#123; private Paint mPaint; public CLIP_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(Color.GREEN); canvas.drawRect(100,0,200,100,mPaint); canvas.save(Canvas.CLIP_SAVE_FLAG); canvas.rotate(40); canvas.restore(); mPaint.setColor(Color.YELLOW); canvas.drawRect(100,0,200,100,mPaint); &#125; &#125; 我们先画了一个绿色的矩形，之后旋转画布，然后在调用 canvas.restore()恢复画布之后，再画上一个同样的黄色矩形。从效果图中可以看出，canvas在恢复时，并没有恢复旋转的画布，这也就是Canvas.CLIP_SAVE_FLAG的意义所在，只保存裁剪信息，不保存位置信息，所以恢复时，位置信息是不会被恢复的！ (2)、saveLayer(int flag)与CLIP_SAVE_FLAG在添加上Canvas.HAS_ALPHA_LAYER_SAVE_FLAG标识以后，效果与canvas.save相同，这里就简单讲解一下。先看裁剪的例子： 123456789101112131415161718public class CLIP_SAVE_FLAG_View extends View &#123; private Paint mPaint; public CLIP_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.clipRect(100,0,200,100); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 效果与canvas.save一样，原因也很简单，因为Canvas.CLIP_SAVE_FLAG标识是可以恢复裁剪信息的。然后再来看看旋转。 1234567891011121314151617181920212223public class CLIP_SAVE_FLAG_View extends View &#123; private Paint mPaint; public CLIP_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(Color.GREEN); canvas.drawRect(100,0,200,100,mPaint); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.rotate(40); canvas.restore(); mPaint.setColor(Color.YELLOW); canvas.drawRect(100,0,200,100,mPaint); &#125; &#125; 因为Canvas.CLIP_SAVE_FLAG不能保存位置信息，所以在canvas.restore()后，旋转并没有被恢复。 总结 当save/saveLayer调用 Canvas.CLIP_SAVE_FLAG时只会保存画布的裁剪信息，在canvas.restore()时也只会恢复裁剪信息，而改变过的画布位置信息是不会被恢复的。 当使用canvas.saveLayer(Canvas.CLIP_SAVE_FLAG)时，需要与Canvas.HAS_ALPHA_LAYER_SAVE_FLAG一起使用，不然新建画布所在区域原来的图像将被清空。 4、FLAG之HAS_ALPHA_LAYER_SAVE_FLAG和FULL_COLOR_LAYER_SAVE_FLAG这两个标识都是saveLayer()专用的HAS_ALPHA_LAYER_SAVE_FLAG表示新建的bitmap画布在与上一个画布合成时，不会将上一层画布内容清空，直接盖在上一个画布内容上面。FULL_COLOR_LAYER_SAVE_FLAG则表示新建的bimap画布在与上一个画布合成时，先将上一层画布对应区域清空，然后再盖在上面。下面我们分别举例子来看注意一定要在view中禁用掉硬件加速，因为在api 21之后，才支持saveLayer (1)、FULL_COLOR_LAYER_SAVE_FLAG12345678910111213141516171819public class ALPHA_COLOR_FALG_VIEW extends View &#123; private Paint mPaint; public ALPHA_COLOR_FALG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,500,500,mPaint,Canvas.FULL_COLOR_LAYER_SAVE_FLAG); canvas.drawRect(100,100,300,300,mPaint); canvas.restore(); &#125; &#125; 我们在saveLayer时，新建bitmap画布的大小为(0,0,500,500)，然后在新建画布中画了一个矩形(100,100,300,300)，由于我们使用的标识是Canvas.FULL_COLOR_LAYER_SAVE_FLAG，所以新建画布在与上一层画布合成时，会先把上一层画布对应区域的图像清空掉，然后再盖上新建画布。由于新建画布中除了绿色矩形，其它位置都是透明像素，所以就显示出Activity的底色（黑色）。如果你把activity的背景色在xml中设置为白色，做出来的效果图中，露出来的就是白色了： main.xml1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:background="#ffffff" &gt; (2)、HAS_ALPHA_LAYER_SAVE_FLAG我把简单把上面的示例代码改一下，把Canvas.FULL_COLOR_LAYER_SAVE_FLAG改成Canvas.HAS_ALPHA_LAYER_SAVE_FLAG：12345678910111213141516171819public class ALPHA_COLOR_FALG_VIEW extends View &#123; private Paint mPaint; public ALPHA_COLOR_FALG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,500,500,mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.drawRect(100,100,300,300,mPaint); canvas.restore(); &#125; &#125; （3）、共用时，以HAS_ALPHA_LAYER_SAVE_FLAG为主很明显这两个标识是相互冲突的，因为Canvas.HAS_ALPHA_LAYER_SAVE_FLAG表示直接盖上去而不清空上一画布的图像，而Canvas.FULL_COLOR_LAYER_SAVE_FLAG则表示先将上一画布对应区域图像清空，然后再盖上去。当他们共用时，以哪个标识位为主呢？ 123456789101112131415161718public class ALPHA_COLOR_FALG_VIEW extends View &#123; private Paint mPaint; public ALPHA_COLOR_FALG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,500,500,mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.FULL_COLOR_LAYER_SAVE_FLAG); canvas.drawRect(100,100,300,300,mPaint); canvas.restore(); &#125; &#125; 所以从效果图中也可以看出，当这两个标识同时使用时，以Canvas.HAS_ALPHA_LAYER_SAVE_FLAG为主。 （4）、当saveLayer只指定MATRIX_SAVE_FLAG/CLIP_SAVE_FLAG的合成方式前面我们在讲解saveLayer的MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG标识时，都强制加上了Canvas.HAS_ALPHA_LAYER_SAVE_FLAG标识，意思是让其在合成时不清空上一画布图像。那么问题来了，当我们只指定MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG标识时，Android默认的合成方式哪一个呢？ 123456789101112131415161718192021public class ALPHA_COLOR_FALG_VIEW extends View &#123; private Paint mPaint; public ALPHA_COLOR_FALG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,500,500,mPaint,Canvas.MATRIX_SAVE_FLAG); canvas.rotate(40); canvas.drawRect(100, 100, 300, 300, mPaint); canvas.restore(); &#125; &#125; 从效果图中可以看出，在默认情况下使用的是Canvas.FULL_COLOR_LAYER_SAVE_FLAG标识，即先清空上一层画布对应区域的图像，然后再合成，所以这也是我们在上面的例子中强制添加HAS_ALPHA_LAYER_SAVE_FLAG标识的原因 总结 HAS_ALPHA_LAYER_SAVE_FLAG表示新建的bitmap画布在与上一个画布合成时，不会将上一层画布内容清空，直接盖在上一个画布内容上面。 FULL_COLOR_LAYER_SAVE_FLAG则表示新建的bimap画布在与上一个画布合成时，先将上一层画布对应区域清空，然后再盖在上面。 当HAS_ALPHA_LAYER_SAVE_FLAG与FULL_COLOR_LAYER_SAVE_FLAG两个标识同时指定时，以HAS_ALPHA_LAYER_SAVE_FLAG为主 当即没有指定HAS_ALPHA_LAYER_SAVE_FLAG也没有指定FULL_COLOR_LAYER_SAVE_FLAG时，系统默认使用FULL_COLOR_LAYER_SAVE_FLAG； 5、FLAG之CLIP_TO_LAYER_SAVE_FLAG（1）、概述这个标识比较犯贱，它的意义是，在新建bitmap前，先把canvas给裁剪，前面我们讲过canvas代表的是画板的意思，一旦画板被裁剪，那么其中的各个画布都会被受到影响。而且由于它是在新建bitmap前做的裁剪，所以是无法恢复的！12345678910111213141516171819public class CLIP_TO_LAYER_SAVE_FLAG_VIEW extends View &#123; private Paint mPaint; public CLIP_TO_LAYER_SAVE_FLAG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0, 0, 500, 500, mPaint, Canvas.CLIP_TO_LAYER_SAVE_FLAG); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 从效果图中可以看出，当我们调用canvas.saveLayer(0, 0, 500, 500, mPaint, Canvas.CLIP_TO_LAYER_SAVE_FLAG)时，canvas画板就被裁剪了，不仅影响了自己，而且还把view的原始画布给影响了，虽然在调用了canvas.restore()，但最后一句在将原始画布填充为黄色，也可以看出，原始画布没有被恢复！ （2）、与CLIP_SAVE_FLAG共用时，Canvas将被恢复我们知道，前面有一个保存裁剪信息的标识：CLIP_SAVE_FLAG，假如我们让它裁剪时，先保存裁剪区域，是不是可以恢复过来呢？12345678910111213141516171819public class CLIP_TO_LAYER_SAVE_FLAG_VIEW extends View &#123; private Paint mPaint; public CLIP_TO_LAYER_SAVE_FLAG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0, 0, 500, 500, mPaint, Canvas.CLIP_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 从效果图中可以看出canvas被恢复了，不过canvas被恢复也，也就失去了Canvas.CLIP_TO_LAYER_SAVE_FLAG标识的意义了。总结 CLIP_TO_LAYER_SAVE_FLAG意义是在新建bitmap前，先把canvas给裁剪，一旦画板被裁剪，那么其中的各个画布都会被受到影响。而且由于它是在新建bitmap前做的裁剪，所以是无法恢复的； 当CLIP_TO_LAYER_SAVE_FLAG与CLIP_SAVE_FLAG标识共用时，在调用restore()后，画布将被恢复 6、FLAG之ALL_SAVE_FLAG这个标识是我们最常用的，它是所有标识的公共集合。对于save(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG；即保存位置信息和裁剪信息对于save(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG很容易理解，因为save(int flag)函数只能使用MATRIX_SAVE_FLAG 、CLIP_SAVE_FLAG这两个标识。对于saveLayer(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG；即保存保存位置信息和裁剪信息，新建画布在与上一层画布合成时，不清空原画布内容。原本来讲saveLayer的ALL_SAVE_FLAG标识应当是它所能使用的所有标识的集合，即应当是ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG|FULL_COLOR_LAYER_SAVE_FLAG|CLIP_TO_LAYER_SAVE_FLAG,但由于HAS_ALPHA_LAYER_SAVE_FLAG与FULL_COLOR_LAYER_SAVE_FLAG共用时以HAS_ALPHA_LAYER_SAVE_FLAG为主，CLIP_TO_LAYER_SAVE_FLAG与CLIP_SAVE_FLAG共用时，CLIP_TO_LAYER_SAVE_FLAG将无效，所以最终ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG；在理解了上面各个TAG的样式以后，这个TAG的难度几乎没有，这里就不再举例了。 四、restore()与restoreToCount()1、restore()restore()的作用就是把回退栈中的最上层画布状态出栈，恢复画布状态. 2、restoreToCount(int count)public int save() public int save(int saveFlags) public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags) public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags) 在save()、saveLayer()、saveLayerAlpha()保存画布后，都会返回一个ID值，这个ID值表示当前保存的画布信息的栈层索引（从0开始），比如保存在第三层，则返回2； public void restoreToCount(int saveCount); 它表示一直退栈，一直退到指定count的层数为栈顶为止；注意这个saveCount起始值是从1开始的，也就是说它比对应栈的索引要多1；比如，我们开始的栈已经有两层，然后我们调用如下代码： int id = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); canvas.restoreToCount(id); 调用canvas.saveLayer后，新保存的画布放在了第三层，返回的id的值是对应的索引即2而canvas.restoreToCount(id);则表示一直退栈，把栈一直退到第二层在栈顶的位置，刚好把新建的第三层给退出掉。所以利用这个特性，我们可以调用save函数的时候，把对应的id保存住，然后canvas.restoreToCount(id)就可以把栈的状态回退到生成这个id前的状态。下面我们举个例子来看下： 1234567891011121314151617181920212223242526272829303132333435public class RestoreToCountView extends View &#123; private Paint mPaint; private String TAG = "qijian"; public RestoreToCountView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int id1 = canvas.save(); canvas.clipRect(0,0,800,800); canvas.drawColor(Color.RED); Log.d(TAG,"count:"+canvas.getSaveCount()+" id1:"+id1); int id2 = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); canvas.clipRect(100,100,700,700); canvas.drawColor(Color.GREEN); Log.d(TAG,"count:"+canvas.getSaveCount()+" id2:"+id2); int id3 = canvas.saveLayerAlpha(0,0,getWidth(),getHeight(),0xf0,Canvas.ALL_SAVE_FLAG); canvas.clipRect(200,200,600,600); canvas.drawColor(Color.YELLOW); Log.d(TAG,"count:"+canvas.getSaveCount()+" id3:"+id3); int id4 = canvas.save(Canvas.ALL_SAVE_FLAG); canvas.clipRect(300,300,500,500); canvas.drawColor(Color.BLUE); Log.d(TAG,"count:"+canvas.getSaveCount()+" id4:"+id4); &#125; &#125; 在onDraw函数中，我们连续对canvas做裁剪，并且在裁剪后，把当前画布画上一层不同的颜色，然后把当前的栈的层数和最高层的索引打出来效果图如下： Log日志如下： 然后我们更改一下上面的代码：123456789101112131415161718192021222324252627protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int id1 = canvas.save(); canvas.clipRect(0,0,800,800); canvas.drawColor(Color.RED); Log.d(TAG,"count:"+canvas.getSaveCount()+" id1:"+id1); int id2 = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); canvas.clipRect(100,100,700,700); canvas.drawColor(Color.GREEN); Log.d(TAG,"count:"+canvas.getSaveCount()+" id2:"+id2); int id3 = canvas.saveLayerAlpha(0,0,getWidth(),getHeight(),0xf0,Canvas.ALL_SAVE_FLAG); canvas.clipRect(200,200,600,600); canvas.drawColor(Color.YELLOW); Log.d(TAG,"count:"+canvas.getSaveCount()+" id3:"+id3); int id4 = canvas.save(Canvas.ALL_SAVE_FLAG); canvas.clipRect(300,300,500,500); canvas.drawColor(Color.BLUE); Log.d(TAG,"count:"+canvas.getSaveCount()+" id4:"+id4); canvas.restoreToCount(id3); canvas.drawColor(Color.GRAY); Log.d(TAG,"count:"+canvas.getSaveCount()); &#125; 我们在最后添加上canvas.restoreToCount(id3);，然后把画布整个绘成灰色。效果图如下： Log日志如下： 从代码中可以看出调用canvas.restoreToCount(id3)后，将恢复到生成id3之前的画布状态，id3之前的画布状态就是(100,100,700,700) 3、restore()与restoreToCount(int count)关系它们两个针对的都是同一个栈，所以是完全可以通用的，不同的是restore()是默认将栈顶内容退出还原画布，而restoreToCount(int count)则是一直退栈，直到指定层count做为栈顶，将此之前的所有动作都恢复。大家可能还有个疑问，前面我们讲了各种FLAG，在应用不同FLAG时，都是保存在同一个栈中吗，我们下面试一下 12345678910111213141516171819202122232425262728public class RestoreToCountView extends View &#123; private Paint mPaint; private String TAG = "qijian"; public RestoreToCountView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.save(Canvas.ALL_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); &#125; &#125; 在这个例子中，我们多次调用不同的save函数和不同的FLAG，然后将栈中层数打出来，日志如下： 从效果图中可以明显看出，每save一次，栈的层数都在加一，所以无论哪种save方法，哪个FLAG标识，保存画布时都使用的是同一个栈所以restore()与restoreToCount(int count)的结论来了： restore的意义是把回退栈中的最上层画布状态出栈，恢复画布状态。restoreToCount(int count)的意义是一直退栈，直到指定层count做为栈顶，将此之前的所有动作都恢复。 所以无论哪种save方法，哪个FLAG标识，保存画布时都使用的是同一个栈 restore()与restoreToCount(int count)针对的都是同一个栈，所以是完全可以通用和混用的。 好了，有关保存图层的知识到这里就结束了，这两篇内容理解起来可能会比较困难，多看两遍喽，有关FLAG标识的知识，如果看不懂就算了，会用ALL_SAVE_FLAG就行，其它标识用到的机会比较少。 五、实例操作一、QQ红点拖动删除效果实现（基本原理篇）前几篇给大家讲了有关绘图的知识，这篇我们稍微停一下，来看下手机QQ中拖动删除的效果是如何实现的；这篇涉及到的知识有： saveLayer图层相关知识 Path的贝赛尔曲线 手势监听 animationlist逐帧动画 这里有三个效果点： 拉长效果的实现 拉的不够长时返回初始状态 拉的够长后显示爆炸消除效果 一、拉伸效果实现1、实现原理一上来先给大家讲本篇最难的部分，这点理解了，后面就轻松了本节先实现一个圆圈的拉伸效果，效果图如下： 看起来是不是挺好玩的，跟拉弹弓一样，这里主要有两个效果组成： 新加一个跟圆圈跟手指位置移动的圆 两个圆之间的连线填充用贝赛尔曲线 拼接过程如下图： 从上面的拼接图中可以看出，整个拉伸效果是由两个圆和中间的贝赛尔曲线连线所组成的矩形所组成的。在贝赛尔曲线部分我们已经讲了，贝赛尔曲线关键地在于控件点的坐标如何动态的确定，我们已经说过贝赛尔曲线的控制点我们可以借助PhtotoShop的钢笔工具来找；那我们就来借助钢笔工具来找一下，如下图：我们单独拿出来最终的结果图来看一下：P0,P1是两个圆的切线的交点（切点），Q0是二阶贝赛尔曲线的控制点。从图中大概可以看出Q0的位置应该在两个圆心连线的中点。在知道两个圆心点位置以后，Q0点的坐标很容易求得，但是P0,P1的坐标要怎么来求得现在的当务之急了。先给大家画个图来看求下图中P0点的坐标这里演示的是圆形向右下拉的过程(为什么选择向右下拉为例来计算坐标我们后面会讲)，左上角的圆形是初始圆形（圆心坐标是x0,yo），右下角的圆形是拖动后的圆形（圆心坐标是x1,y1);首先，在这个图中有四个切点P0,P1,P2,P3；这四个切点的坐标就是我们所要求的。我们这里以求P0为例来演示下求坐标的过程。先看P0所在位置所形成的三角形，所在初始圆形的坐标是（x0,y0）我们单独把这个三角形拿出来，这里可以很明显的可以看出P0的坐标是： x = x0 + r * sina; y = y0 - r * cosa; 由于屏幕坐标系是X轴向右为正，Y轴向下为正。所以P0的X坐标是比圆形x0坐标大的，所以要加上r sina；而P0的Y坐标是在圆形y0坐标的上方，比y0小，所以要减去r cosa;用同样的方法可以求出P1,P2,P3的坐标公式: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//P1x = x1 + r * sina;y = y1 - r * cosa;//P2x = x1 - r * sina;y = y1 + r * cosa;//P3x = x0 - r * sina;y = y0 + r * cosa;``` 那么问题来了，角度a的值是多少呢？ 我们再回过头来看一下我们的高清无码大图: ![20170218148742763582964.png](http://ohtrrgyyd.bkt.clouddn.com/20170218148742763582964.png)tan(a) = dy/dx; 所以a = arctan(dy/dx); 这样角度a的值就求到了，自然sina和cosa也就得到了。 ##### 2、代码实现下面我们就来看一下如何用代码来实现这个手拖动的过程；&gt; 注意：这篇博客并不是要制造出来一个通用组件，而是主要为了讲解拖动消除的原理，后面我们会逐渐对这篇文章进行扩充，最终将产出一个通用控件！慢慢来吧###### （1）、新建类及初始化 由于我们这篇是讲解基本原理，所以我们新建一个类派生自FramLayout，然后在这个类中做绘图等等操作。``` javapublic class RedPointView extends FrameLayout &#123; private PointF mStartPoint, mCurPoint; private int mRadius = 20; private Paint mPaint; private Path mPath; public RedPointView(Context context) &#123; super(context); initView(); &#125; public RedPointView(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public RedPointView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initView(); &#125; private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); mPath = new Path(); &#125;&#125; 我们新建了一个RedPointView类派生自FramLayout，然后添加了一个初始化函数：1234567891011private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); mPath = new Path();&#125; 首先是两个点坐标，分别表示两个圆的圆心位置。mStartPoint表示起始圆心位置，mCurPoint是当前手指的位置，也就是移动的圆心位置。然后是初始化Paint和Path。 （2）、圆随着手指移动这部分的效果图如下：当手指移动时新画一个圆在随着手指移动所以我们要先定义一个变量表示当前用户的手指是不是下按状态，如果是下按状态就根据当前手指的位置多画一个圆.完整代码如下： 123456789101112131415161718192021222324252627@Overrideprotected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); if (mTouch) &#123; canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mTouch = true; &#125; break; case MotionEvent.ACTION_UP: &#123; mTouch = false; &#125; &#125; mCurPoint.set(event.getX(), event.getY()); postInvalidate(); return true;&#125; 我们先来看看对onTouchEvent的拦截过程，在onTouchEvent中，在手指下按时将mTouch赋值为true，在手机抬起时赋值为false;然后将当前手指的位置传给mCurPoint保存，然后调用postInvalidate()强制重绘；最后return true表示当前消息到此为止，就不再往父控件传了。以前我们讲过postInvalidate()和invadite()的区别，这里再简单说一下：invadite()必须在主线程中调用，而postInvalidate()内部是由Handler的消息机制实现的，所以在任何线程都可以调用，但实时性没有invadite()强。所以一般为了保险起见，一般是使用postInvalidate()来刷新界面。 由于我们这里是继承自FrameLayout所以是重写dispatchDraw()函数来进行重绘我们来看看dispatchDraw中实现代码，这里可谓是有难度：1234567891011protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); if (mTouch) &#123; canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; super.dispatchDraw(canvas)操作的位置问题。首先是super.dispatchDraw(canvas)放的位置很重要，我们有时把它写在绘图操作的最上方，有时把它写在所有绘图操作的最下方，关于这两个位置是有很大差别的，有关位置的问题，下面我们会再讲，这里放在哪里都不会有影响。 canvas.saveLayer()与canvas.restore()是Canvas的绘图操作 最后是画初始圆和移动圆的位置 1234canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);if (mTouch) &#123; canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);&#125; 这里主要是根据当前手指是不是在移动来判断是不是画出随手指移动的圆。代码难度不大就不再细讲了。到这里，我们就实现了两个圆的显示了，最关键的部分来了——下面就是要看如何利用贝赛尔曲线把这两个圆连接起来。 (3)、贝赛尔曲线连接两个圆首先，我们先看如何把路径给计算出来的： 12345678910111213141516171819202122232425262728293031323334353637383940//圆半径private int mRadius = 20;private void calculatePath() &#123; //这里就是根据两个圆心坐标来计算出dx,dy，然后利用double a = Math.atan(dy / dx)得到夹角a的值，然后求得mRadius * Math.sin(a) 和 mRadius * Math.cos(a)的值； float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; // 根据角度算出四边形的四个点 float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); // 根据角度算出四边形的四个点 float x1 = startX + offsetX; float y1 = startY - offsetY; float x2 = x + offsetX; float y2 = y - offsetY; float x3 = x - offsetX; float y3 = y + offsetY; float x4 = startX - offsetX; float y4 = startY + offsetY; float anchorX = (startX + x) / 2; float anchorY = (startY + y) / 2; //最后把这四个点连起来： mPath.reset(); mPath.moveTo(x1, y1); mPath.quadTo(anchorX, anchorY, x2, y2); mPath.lineTo(x3, y3); mPath.quadTo(anchorX, anchorY, x4, y4); mPath.lineTo(x1, y1);&#125; 根据我们画的图中也可以知道，P0-P1，P2-P3是用贝赛尔曲线连起来的，P1-P2,P3-P0是用直线连起来的；在我们得到当前的路径以后，下面就是画图的问题了： 12345678910111213protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; 其实就是添加在手指下按时，先用calculatePath()计算路径然后再利用canvas.drawPath(mPath, mPaint)把路径画出来的过程，难度不大就不再讲了。到这里，我们这节开始时的效果就实现了，效果图如刚开始时所示。 贴出来完整代码给大家参考下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class RedPointView extends FrameLayout &#123; private PointF mStartPoint, mCurPoint; private int mRadius = 20; private Paint mPaint; private Path mPath; private boolean mTouch = false; public RedPointView(Context context) &#123; super(context); initView(); &#125; public RedPointView(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public RedPointView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initView(); &#125; private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); mPath = new Path(); &#125; private void calculatePath() &#123; float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); // 根据角度算出四边形的四个点 float x1 = startX - offsetX; float y1 = startY + offsetY; float x2 = x - offsetX; float y2 = y + offsetY; float x3 = x + offsetX; float y3 = y - offsetY; float x4 = startX + offsetX; float y4 = startY - offsetY; float anchorX = (startX + x) / 2; float anchorY = (startY + y) / 2; mPath.reset(); mPath.moveTo(x1, y1); mPath.quadTo(anchorX, anchorY, x2, y2); mPath.lineTo(x3, y3); mPath.quadTo(anchorX, anchorY, x4, y4); mPath.lineTo(x1, y1); &#125; @Override protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint); &#125; canvas.restore(); super.dispatchDraw(canvas); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mTouch = true; &#125; break; case MotionEvent.ACTION_UP: &#123; mTouch = false; &#125; &#125; mCurPoint.set(event.getX(), event.getY()); postInvalidate(); return true; &#125;&#125; 3、疑问：当手指拖动位置不同时，也能统一处理求得各个点坐标？细心的同学可能会发现，同样是P0,P1,P2,P3四个切点，当移动圆的位置变化时，四个点的计算公式是会变化的，我们同样以P0点为例来看下当手指移动点在右下方时的公式为 x = x0 + r * sina; y = y0 - r * cosa; 那么当手指移动点在左上方时，它的公式又为：在变为左上方时，P0点的X坐标就跑到了原点(x0,y0)的左侧，从图像中不难看出P0点的坐标为： x = x0 - r * sina; y = y0 - r * cosa; 但是我们在计算时全部都是使用x = x0 + r * sina;这个公式来计算的，明明在这种情况下使用同一个公式是有问题的，但出来的效果为什么却是正确的呢？这是因为Math的三角函数取值是有正有负的，当Math.atan(double value)的入参value是负值是，它对应的输出的角度值也是负值，同样，Math.sin(double a) 的输出值也是负值所在因为在手指移动点在左上角时，dx正值，dy却是负值，所以利用a =Math.atan(dy/dx)求得的角度a是负值，进而sina和cos都是负值这里其实是用到了正弦函数和余弦函数的几个性质： sin(-a) = - sina; cos(-a) = cosa; sin(π/2-α) = cosα cos(π/2-α) = sinα 所以当a值为负值时： x = x0 + r * sin（-a）; y = y0 - r * cosa; 也就变成了下面的公式了： x = x0 - r * sina; y = y0 - r * cosa; 这也是我们为什么用同一个公式能解决所有情况的原因所在！但我们在得到这个公式时，必须在保证dx,dy都为正值的情况下，因为此时夹角a必然是正值，不存在数学换算的问题；不然如果dx,dy中任意一个为负数时，夹角a也将是负值，此时你将算得头大…… 二、自定义文字与爆炸效果上面把最难的拉伸效果实现以后，下面就要完整的来实现开篇的功能了，再来看下最终的效果图：除了拉伸效果以后，还有一个TextView用来设置文字，另外在超出定长以后消失时会有爆炸效果我们先来实现添加TextView，然后再添加爆炸效果. 1、添加TextView我们添加TextVIew后所实现的功能的效果图为：添加TextView后需要添加三个功能： 初始只显示TextView，而不显示原来的圆圈 点击TextView所在区域才能移动TextVIew 移动时，TextView跟随手指移动，同时显示原TextVIew所在的圆圈和贝赛尔连接线 本着上面几个功能点，我们一步步来实现 （1）、添加并初始化TextView首先，我们要在初始化的时候原布局中添加一个TextView控件：1234567891011121314151617181920private TextView mTipTextView;private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); mTipTextView = new TextView(getContext()); mTipTextView.setLayoutParams(params); mTipTextView.setPadding(10, 10, 10, 10); mTipTextView.setBackgroundResource(R.drawable.tv_bg); mTipTextView.setTextColor(Color.GREEN); mTipTextView.setText("99+"); addView(mTipTextView);&#125; 这段代码难度不大，就是在原来初始化的基础上向ViewGroup中添加一个TextVIew控件，并做一些基本的设置。我们这里把TextView的一些设置都写死在类内部了，这样是为了讲解方便，但如果要集成为公用控件，当然要把这些设置文字内容和颜色暴露给外部，最简单的方法就向外部暴露一个getTextView()的方法，把当前TextView的对象直接返回给外部，让它直接可以设置TextView；上面的代码中有一个设置TextView背景的代码： mTipTextView.setBackgroundResource(R.drawable.tv_bg)，对应的xml文件为：123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;corners android:radius="10dp"/&gt; &lt;solid android:color="#ff0000"/&gt; &lt;stroke android:color="#0f000000" android:width="1dp"/&gt;&lt;/shape&gt; 就是给TextView添加带有圆角的红色背景，另外还加了个不怎么黑的描边。 （2）、点击TextView时才允许拖动我们需要在用户点击区域在TextView内部时才允许拖动TextView：12345678910111213141516171819202122232425262728public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; // 判断触摸点是否在tipImageView中 //拿到当前TextView所在屏幕的位置矩形 Rect rect = new Rect(); int[] location = new int[2]; mTipTextView.getLocationOnScreen(location); rect.left = location[0]; rect.top = location[1]; rect.right = mTipTextView.getWidth() + location[0]; rect.bottom = mTipTextView.getHeight() + location[1]; //然后就是判断当前手指所在位置是不是在这个矩形内了： if (rect.contains((int) event.getRawX(), (int) event.getRawY())) &#123; mTouch = true; &#125; &#125; break; case MotionEvent.ACTION_UP: &#123; //抬起手指时还原位置 mTouch = false; &#125; break; &#125; mCurPoint.set(event.getX(), event.getY()); postInvalidate(); return true;&#125; 这里主要是在MotionEvent.ACTION_DOWN的时候，判断当前当前手指区域是否在TextView内部，如果是就将mTouch赋值为true；这里涉及的一个函数还没的一直没有提及这里给大家讲一下： public void getLocationOnScreen(int[] location) 该函数的功能是获取当前控件所在屏幕的位置，传进去一个location的数组，在执行以后会把left,top值赋给location[0]和location[1].这里最主要注意的是，我们前面讲了getLocationOnScreen()函数得到的位置是屏幕坐标，所以我们也必须拿到手指的屏幕坐标，所以event.getRawX()得到的就是相对屏幕的坐标以前在博客中也讲到过getX与getRawX的区别：getX()得到是相对当前控件左上角的坐标，而getRawX是得到在屏幕中的坐标，在第三部曲中会单独开一篇来讲解有关坐标的知识，大家这里先知道这两个函数的用法就好了，第三部曲中会深入地讲解。 （3）、绘图在绘图部分，我们需要完成两个功能：当用户没点击时将TextView设置为原来的位置，当用户点击时一方面TextView要跟着手指移动，另一方面要画出初始圆形12345678910111213141516171819@Overrideprotected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint);//将textview的中心放在当前手指位置 //先看用户没有点击时，把TextView设置在初始的位置点 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; 画出初始的圆形，手指处的圆形，和两个圆之间的贝赛尔曲线连接矩形；最后把TextView盖在手指处的圆形上即可。代码难度不大就不再细讲了。 (4)、拉伸时把圆半径缩小正常情况下，随着拉伸长度的增大，两个圆的半径是应该逐步就小的；这样才更符合力学原理是吧，效果图如下： 这个功能非常简单，只需要在拉伸时，跟根据用户的拉伸长度，动态的设置当前所画圆的半径即可：1234567891011121314151617181920212223private float DEFAULT_RADIUS = 20;private float mRadius = DEFAULT_RADIUS;private void calculatePath() &#123; float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); float distance = (float) Math.sqrt(Math.pow(y-startY, 2) + Math.pow(x-startX, 2)); mRadius = DEFAULT_RADIUS - distance/15; if(mRadius&lt;9)&#123; mRadius = 9; &#125; // 根据角度算出四边形的四个点 …………&#125; 这里代码很简单，就是根据勾股定理（a^2+b^2=c^2）求出两个圆心之间当前距离，然后按照一定的规则计算出当前的圆半径，我这里定的规则就是DEFAULT_RADIUS-distance/15；但不要一直小到0，因为我们中间的连接线是两个相同半径的圆的切线来计算出来的，所以当圆心半径变小时，两个圆之间的连接矩形也在变小，所以小到一定程度后，就不能再小了，我这里这个临界值定为9. (5)、答疑：super.dispatchDraw(canvas)的位置问题这里大家可能会有个疑问，为什么super.dispatchDraw(canvas)的位置有时候会直接写在dispatchDraw的下面呢？比如这样： 1234void dispatchDraw(Canvas canvas)&#123; super.dispatchDraw(canvas); …………//其它绘图操作&#125; 有时候又这么写：先做绘图操作再写super.dispatchDraw(canvas) 1234void dispatchDraw(Canvas canvas)&#123; …………//其它绘图操作 super.dispatchDraw(canvas);&#125; 这两个到底有什么差别呢？至于到底有什么差别，我们得先来看一下super.dispatchDraw(canvas);的作用是什么；super.dispatchDraw(canvas);的作用是绘出该控件的所有子控件，所以这样结论就很明显了，如果是像第一个那样先做super.dispatchDraw(canvas);再做其它绘图操作的结果是，先把子控件绘制出来，然后再画自己，这样可能会造成自己把子控件给覆盖上；相反，先做其它绘图操作然后再调用super.dispatchDraw(canvas)的结果是：先把自己给画出来，然后再画子控件，子控件会把自己的绘图结果给覆盖上；所以，我们回过头来看看我们在上面的例子中的代码：123456789101112131415161718protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint);//将textview的中心放在当前手指位置 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; 在这段代码中，我们是先绘制自己，然后再绘制它的子控件（TextView）,这样的结果就是TextView会把当前的绘图内容覆盖上，如果我把绘图画笔改成绿色，就会很明显，我们来看下效果： 然后我们再反过来看一下，如果我们先做super.dispatchDraw(canvas);然后再做自己的绘图操作，看下效果是怎么样的：12345678910111213141516protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint);//将textview的中心放在当前手指位置 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore();&#125; 很明显，后来的绘图操作把子控件给盖住了，这就是 super.dispatchDraw(canvas)在不同位置的区别！ 2、爆炸效果这里我们就差最后一个效果了：当用户手指拉到一定长度松手后，将出来爆炸效果，效果图如下： （1）、定义逐帧动画首先，我们定义一个爆炸效果的动画（这些图片资源都是从手机QQ的apk里解压出来的，嘿嘿）图片资源如下：先添加个逐帧动画，对应的代码如下：1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true"&gt; &lt;item android:drawable="@drawable/idp" android:duration="300"/&gt; &lt;item android:drawable="@drawable/idq" android:duration="300"/&gt; &lt;item android:drawable="@drawable/idr" android:duration="300"/&gt; &lt;item android:drawable="@drawable/ids" android:duration="300"/&gt; &lt;item android:drawable="@drawable/idt" android:duration="300"/&gt; &lt;item android:drawable="@android:color/transparent" android:duration="300"/&gt;&lt;/animation-list&gt; （2）、添加ImageView我们需要添加一个ImageView控件来单独来播放这个逐帧动画：1234567891011121314151617181920212223242526272829private ImageView exploredImageView;private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); mTipTextView = new TextView(getContext()); mTipTextView.setLayoutParams(params); mTipTextView.setPadding(10, 10, 10, 10); mTipTextView.setBackgroundResource(R.drawable.tv_bg); mTipTextView.setTextColor(Color.WHITE); mTipTextView.setText("99+"); exploredImageView = new ImageView(getContext()); exploredImageView.setLayoutParams(params); exploredImageView.setImageResource(R.drawable.tip_anim); exploredImageView.setVisibility(View.INVISIBLE); addView(mTipTextView); addView(exploredImageView);&#125; （3）、定值爆炸在绘图的时候，我们就要开启爆炸效果了，上面我们在半径小于9的时候，一直给它赋值9，现在我们当它小于9时，让它爆炸：1234567891011121314151617181920212223242526private void calculatePath() &#123; float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); float distance = (float) Math.sqrt(Math.pow(y-startY, 2) + Math.pow(x-startX, 2)); mRadius = -distance/15+DEFAULT_RADIUS; if(mRadius &lt; 9)&#123; isAnimStart = true; exploredImageView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); exploredImageView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); exploredImageView.setVisibility(View.VISIBLE); ((AnimationDrawable) exploredImageView.getDrawable()).start(); mTipTextView.setVisibility(View.GONE); &#125; //根据角度算出四边形的四个点 …………&#125; 当半径小于9时，开始爆炸效果，然后声明一个变量isAnimStart来标识当前爆炸效果开始了；因为当爆炸效果开始以后，后面的绘图操作就不能再画圆和贝赛尔曲线了，应该清空当前画布，只显示ImageVIew的动画效果然后利用setX和setY函数将当前ImageVIew的位置移动到手指的位置，最后是显示ImageView并开始动画；最后是绘图操作：123456789101112131415161718192021protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); if (!mTouch || isAnimStart) &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; calculatePath(); canvas.drawPath(mPath, mPaint); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); //将textview的中心放在当前手指位置 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; 这里的绘图操作加上了isAnimStart变量的判断，当动画开始或者手指没在按的时候只显示TextView，之外的其它操作肯定是用户在点按TextView，此时需要画出拉伸效果。最后，把整体控件的源码贴给大家，可以自己对照下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159public class RedPointControlVIew extends FrameLayout &#123; private PointF mStartPoint, mCurPoint; private float DEFAULT_RADIUS = 20; private float mRadius = DEFAULT_RADIUS; private Paint mPaint; private Path mPath; private boolean mTouch = false; private boolean isAnimStart = false; private TextView mTipTextView; private ImageView exploredImageView; public RedPointControlVIew(Context context) &#123; super(context); initView(); &#125; public RedPointControlVIew(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public RedPointControlVIew(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initView(); &#125; private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); mTipTextView = new TextView(getContext()); mTipTextView.setLayoutParams(params); mTipTextView.setPadding(10, 10, 10, 10); mTipTextView.setBackgroundResource(R.drawable.tv_bg); mTipTextView.setTextColor(Color.WHITE); mTipTextView.setText("99+"); exploredImageView = new ImageView(getContext()); exploredImageView.setLayoutParams(params); exploredImageView.setImageResource(R.drawable.tip_anim); exploredImageView.setVisibility(View.INVISIBLE); addView(mTipTextView); addView(exploredImageView); &#125; private void calculatePath() &#123; float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); float distance = (float) Math.sqrt(Math.pow(y-startY, 2) + Math.pow(x-startX, 2)); mRadius = -distance/15+DEFAULT_RADIUS; if(mRadius &lt; 9)&#123; isAnimStart = true; exploredImageView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); exploredImageView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); exploredImageView.setVisibility(View.VISIBLE); ((AnimationDrawable) exploredImageView.getDrawable()).start(); mTipTextView.setVisibility(View.GONE); &#125; // 根据角度算出四边形的四个点 float x1 = startX + offsetX; float y1 = startY - offsetY; float x2 = x + offsetX; float y2 = y - offsetY; float x3 = x - offsetX; float y3 = y + offsetY; float x4 = startX - offsetX; float y4 = startY + offsetY; float anchorX = (startX + x) / 2; float anchorY = (startY + y) / 2; mPath.reset(); mPath.moveTo(x1, y1); mPath.quadTo(anchorX, anchorY, x2, y2); mPath.lineTo(x3, y3); mPath.quadTo(anchorX, anchorY, x4, y4); mPath.lineTo(x1, y1); &#125; /** * onDraw:为什么要行绘制自己的,然后再调用super.onDraw * @param canvas */ @Override protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); if (!mTouch || isAnimStart) &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; calculatePath(); canvas.drawPath(mPath, mPaint); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); //将textview的中心放在当前手指位置 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore(); super.dispatchDraw(canvas); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; // 判断触摸点是否在tipImageView中 Rect rect = new Rect(); int[] location = new int[2]; mTipTextView.getLocationOnScreen(location); rect.left = location[0]; rect.top = location[1]; rect.right = mTipTextView.getWidth() + location[0]; rect.bottom = mTipTextView.getHeight() + location[1]; if (rect.contains((int) event.getRawX(), (int) event.getRawY())) &#123; mTouch = true; &#125; &#125; break; case MotionEvent.ACTION_UP: &#123; //抬起手指时还原位置 mTouch = false; &#125; break; &#125; postInvalidate(); mCurPoint.set(event.getX(), event.getY()); return true; &#125;&#125; 好了，这篇文章就到这了，通过这篇文章，简单复习了下前面学到的动画和绘图的知识，后面我们会这个控件进行扩充，逐步把它封装成共用的控件。 二、给控件添加阴影效果与发光效果这节我们将学到如下内容： 传统地给按钮添加阴影的方法 如何给已有控件添加阴影 如何给图片添加阴影 一、layerlist给按钮添加阴影效果给控件添加阴影有很多方法，但平常我们给按钮添加阴影最常用的就是使用layerlist多层绘图来添加阴影效果，我们先来看一下给按钮添加的阴影效果图： 从效果图中可以明显看出，按钮的外围多了一圈灰色的阴影效果。在开始做阴影效果之前，我们先讲解一下有关layerlist的知识。在xml中，我们有常用的几个标签：shape、selector、layerlist; shape标签：以前我们讲过,就是利用代码绘制出背景效果，可以定义填充色、描边、圆角、渐变等。不了解的同学可以参考下：《详解shape标签》 selector标签：用于定义在用户不同的动作状态下，使用不同的背景值。有关selector的知识，博主没有讲过，也不打算再讲了，难度不大，自己搜几个帖子就能学会了。 layerlist标签：这个标签的主要作用就是将多个图层按照顺序叠起来，做为一个背景图来显示。 1、layerlist示例：layerlist标签就是模拟Photoshop中图层的概念，把每一张图层按照顺序叠加起来，做为背景图来显示；我们先来看一下简单的例子，我们要显示一下两只蜗牛的图片：它由三张图片组成：一张纯蓝色的背景：(blog1_1.png)一只黄蜗牛：(blog1_2.png)一只土色蜗牛：(blog1_3.png)我们先定义一个layerlist的文件（shade.xml）123456&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/blog1_1"/&gt; &lt;item android:drawable="@drawable/blog1_2"/&gt; &lt;item android:drawable="@drawable/blog1_3"/&gt; &lt;/layer-list&gt; 这里分别将上面的三张图片做为item添加给layer-list；效果图就是一开始演示的那样。layer-list使用起来很简单，只需要把每一层设置为其中的item即可。有一点需要注意，layer-list标签的Item中不仅可以设置drawable，也可以设置shape、selector，我们下面一一做下尝试。 2、layer-list与shape标签编写控件阴影drawable代码上面我们使用使用的是layer-list中item的drawable属性来直接引入图片，其实除了drawable属性，item还有另外几个属性： android:top 顶部的偏移量 android:bottom 底部的偏移量 android:left 左边的偏移量 android:right 右边的偏移量这四个偏移量和控件的margin设置差不多，都是外间距的效果。如果不设置偏移量，前面的图层就完全挡住了后面的图层，从而也看不到后面的图层效果了。言归正转，先来看看如何在layer-list中使用shape标签：12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; 上面的代码实现的效果是这样的：大家看到类似阴影的效果了吧，不错，这段代码就是实现按钮阴影的代码，我们来仔细看一下首先，它使用layer-list将两层shape叠加在一起，底部的shape代码为：123456&lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; 底部是一个灰色的矩形，它的四个角被圆角化，并且填充为灰色。上层绘制的shape对应的代码为：1234567&lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; 它同样绘制的是一个四个角都被圆角化的矩形，但填充颜色是纯白色。为了露出底层的灰色阴影，我们需要给上层的shape加上边距，这也就是item的 android:left=”2dp” android:top=”2dp” android:bottom=”2dp” android:right=”2dp”这四个属性的作用，相当于margin的作用。 使用阴影drawable在写好layer-list以后，我们需要在按钮控件中使用它：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="10dp" android:layout_margin="10dp" android:background="@drawable/layer_shape_list" android:text="带阴影的按钮" android:textColor="#ff0000"/&gt;``` 我们来看下效果：![201702182509320160704092043807.gif](http://ohtrrgyyd.bkt.clouddn.com/201702182509320160704092043807.gif) 从效果图中可以看到，我们虽然实现了带阴影的按钮效果，但是在点击时却没有任何状态变化，这对于按钮是完全不能接受的，所以我们需要给按钮添加上状态变化，这就需要用到selector标签了##### 3、layer-list与selector标签**改造方法一：使用layer-list做根结点** 下面我们对上面shape的代码进行改造，当用户手指按下的时候，将前景色改为黄色，代码为：``` xml&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;selector&gt; &lt;item android:state_pressed="true"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/selector&gt; &lt;/item&gt; &lt;/layer-list&gt; 我们先来看一下效果，然后再来看代码这里明显实现了当用户点击时前景变化的功能。下面我们再来讲解下代码首先，这里同样是绘制两层layer，第一层，依然是阴影层，代码没动：123456&lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; 在第一层绘制完成以后，当绘制第二层时就出现问题了：1234567891011121314151617&lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;selector&gt; &lt;item android:state_pressed="true"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/selector&gt; &lt;/item&gt; 第二层中，会对当前用户状态做判断，如果用户当前是按下状态，则绘制：123456&lt;item android:state_pressed="true"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; 如果是其它状态，则绘制默认图像：123456&lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; 所以对于layer-list标签，从这里也可以看出来：它的绘制是逐层绘制的，层与层之间是没有任何影响的，每一层可以单独设置selector标签来响应不同的用户操作状态。改造方法二：使用selector做根结点上面我们使用layer-list来做根结点来绘制出按钮的不同状态响应的效果，对selector、layer-list使用熟悉的同学，应该还可以想到另一种实现方式，使用selector做为根结点来实现响应不同用户操作。我们先直接上代码吧：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;/selector&gt; 同样我们先来看一下使用代码与效果，然后再来讲解实现原理：使用方法，同样是做为background引入： 12345678&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="10dp" android:layout_margin="10dp" android:background="@drawable/selector_layer_list" android:text="Selector为根的按钮" android:textColor="#ff0000"/&gt; 效果图如下：很明显，实现了与上面layer-list标签为根同样的效果，我们现在来看一下代码原理：代码看起来很长，很唬人，其实原理很简单，它就是根据当前不同的状态，绘制不同的图形，当用户是按压状态时，通过layer-list绘制出一下最上层是黄色，底层是灰色的按钮背景图像：1234567891011121314151617&lt;item android:state_pressed="true"&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; 然后在其它状态时，绘制一个前景色是白色，背景色是灰色的按钮背景图：1234567891011121314151617&lt;item&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; 4、存在问题由于使用layer-list标签实现的阴影只能做为background引入，所以如果对你是文字时，它的阴影效果就变成了这样：1234567&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="文字的阴影效果" android:layout_margin="10dp" android:padding="10dp" android:background="@drawable/layer_shape_list"/&gt; 对应效果图为：看起来跟按钮一个样 - _ -!!! 很囧有没有，文字的阴影应该是这样的才对：所以我们下面就要开始讲解如何实现文字的阴影效果啦，嘿嘿 二、Paint.setShadowLayer实现阴影效果上面我们讲了利用layer-list只能实现按钮的阴影效果，对于文字和图片都无法实现阴影效果，除了layer-list，我们只能用自定义控件来实现阴影效果了，Paint中有一个专门用来实现阴影效果的函数setShadowLayer，我们先来看看这个函数实现的阴影效果图：从效果图中可以看出setShadowLayer函数能够实现： 定制阴影模糊程度 定制阴影偏移距离 清除阴影和显示阴影 1、setShadowLayer构造函数看起来setShadowLayer好像能够完成阴影定制的方方面面，我们先来看看它的构造函数： public void setShadowLayer(float radius, float dx, float dy, int color) float radius：意思是模糊半径，radius越大越模糊，越小越清晰，但是如果radius设置为0，则阴影消失不见；有关清除阴影的问题，下面我们会专门讲。 float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移 float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移 int color：绘制阴影的画笔颜色，即阴影的颜色（对图片阴影无效） 我们这里需要着重讲两个点：一个是模糊半径，另一个是绘制阴影的画笔颜色为什么对图片无效： 模糊半径的具体意义：setShadowLayer使用的是高斯模糊算法，高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的RGB值并且平均，然后这个平均值就是模糊处理过的像素，如果对图片中的所有像素都这么处理的话，处理完成的图片就会变得模糊。取周围像素的半径就是模糊半径.很容易知道,模糊半径越大,所得平均像素与原始像素相差就越大,也就越模糊. 绘制阴影的画笔颜色为什么对图片无效从上面的效果图中可以看出，使用setShadowLayer所产生的阴影，对于文字和绘制的图形的阴影都是使用自定义的阴影画笔颜色来画的，而图片的阴影则是直接产生一张相同的图片，仅对阴影图片的边缘进行模糊。大家可能会疑问，会什么对图片的处理是生成一张相同的背景图片呢？这是因为为了给图片添加阴影，如果统一使用某一种颜色来做阴影可能会与图片的颜色相差很大，而且不协调，比如某张图片的色彩非常丰富，而阴影如果使用灰色来做，可能就会显得很突兀，所以为了解决这个问题，针对图片的阴影就不再是统一颜色了，而是复制出这张图片，把复制出的图片的边缘进行模糊，做为阴影；但这样又会引起一个问题，就是如果我们想把图片的阴影做成灰色怎么办？使用setShadowLayer自动生成阴影是没办法了，在下篇我们会具体来讲，如何给图片添加指定颜色的阴影。 注意：这里有一点需要非常注意的是setShadowLayer只有文字绘制阴影支持硬件加速，其它都不支持硬件加速，所以为了方便起见，我们需要在自定义控件中禁用硬件加速。 2、示例一：初步使用setShadowLayer 这里实现了对文本，图形，Image的阴影效果；具体的代码如下：1234567891011121314151617181920212223242526272829303132333435363738public class ShadowLayerView extends View &#123; private Paint mPaint = new Paint(); private Bitmap mDogBmp; public ShadowLayerView(Context context) &#123; super(context); init(); &#125; public ShadowLayerView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ShadowLayerView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; //首先是初始化，在初始化时设置画笔的颜色 private void init()&#123; setLayerType( LAYER_TYPE_SOFTWARE , null); //禁用硬件加速 //设置paint的属性，由于我们需要画图片，所以先把要画的图片加载进来。 mPaint.setColor(Color.GREEN); //设置画笔的颜色是绿色，从效果图中也可以看出来画出来的字体和圆形都是绿色的 mPaint.setTextSize(25); mPaint.setShadowLayer(1, 10, 10, Color.GRAY); //指的是阴影的颜色，从效果图中也明显可以看出，字体和阴影的颜色都是灰色的。 mDogBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawText("启舰大SB",100,100,mPaint); canvas.drawCircle(200,200,50,mPaint); canvas.drawBitmap(mDogBmp,null,new Rect(200,300,200+mDogBmp.getWidth(),300+mDogBmp.getHeight()),mPaint); &#125; &#125; 3、示例二：setShadowLayer各参数意义下面我们就来实现一下这部分开篇时的效果，动态添加setShadowLayer中的各个参数，就可以明显看出来它们的作用：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ShadowLayerView extends View &#123; private Paint mPaint = new Paint(); private Bitmap mDogBmp; private int mRadius = 1,mDx = 10,mDy = 10; public ShadowLayerView(Context context) &#123; super(context); init(); &#125; public ShadowLayerView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ShadowLayerView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType( LAYER_TYPE_SOFTWARE , null); mPaint.setColor(Color.GREEN); mPaint.setTextSize(25); mDogBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); &#125; public void changeRadius() &#123; mRadius++; postInvalidate(); &#125; public void changeDx() &#123; mDx+=5; postInvalidate(); &#125; public void changeDy() &#123; mDy+=5; postInvalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY); canvas.drawText("启舰大SB",100,100,mPaint); canvas.drawCircle(200,200,50,mPaint); canvas.drawBitmap(mDogBmp,null,new Rect(200,300,200+mDogBmp.getWidth(),300+mDogBmp.getHeight()),mPaint); &#125; &#125; 这段代码难度并不大，只是将 mPaint.setShadowLayer中的各参数写成了变量，并向外暴露了几个接口changeRadius()、changeDx()、changeDy()；当外部调用这些接口时，增加对应的变量，并且重绘控件；由于每次重绘控件都肯定会调用onDraw方法，所以，我们将mPaint.setShadowLayer的设置放到onDraw方法里来，以确保每次重绘时mPaint.setShadowLayer的设置都会被更新。 使用时123456789101112131415161718192021222324252627public class MyActivity extends Activity implements View.OnClickListener&#123; private ShadowLayerView mShadowLayerView; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mShadowLayerView = (ShadowLayerView)findViewById(R.id.shadowlayerview); findViewById(R.id.radius_btn).setOnClickListener(this); findViewById(R.id.dx_btn).setOnClickListener(this); findViewById(R.id.dy_btn).setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.radius_btn: mShadowLayerView.changeRadius(); break; case R.id.dx_btn: mShadowLayerView.changeDx();; break; case R.id.dy_btn: mShadowLayerView.changeDy(); break; &#125; &#125; &#125; 从效果图中可以明显看到各个参数的区别，但正是通过效果图，我们可以明显得看出两个结论： 图片的阴影是不受阴影画笔颜色影响的，它是一张图片的副本； 无论是图片还是图形，模糊时，仅模糊边界部分，随着模糊半径的增大，向内、向外延伸；其实很好理解这个问题：由于模糊半径的增大，高斯模糊向周边取值的范围在增大，所以向内、向外延伸的距离就会更大 4、Paint.clearShadowLayer()清除阴影上面我们讲解了使用setShadowLayer添加阴影的问题，下面我们再来看看如何清除阴影的。清除阴影其实有两个方法，可以将setShadowLayer的radius的值设为0，也可以使用专门的清除阴影的函数： //Paint系函数：清除ShadowLayer阴影 public void clearShadowLayer() 将setShadowLayer的radius的值设为0来清除阴影的用法，我这里就不再演示了，大家可以自己试试，我们这里尝试下使用clearShadowLayer() 来清除阴影的用法。在上面函数的基础上，我们另外添加一个变量来控制当前是否显示阴影： 12345678910111213141516171819202122232425262728293031public class ShadowLayerView extends View &#123; ………… private boolean mSetShadow = true; ………… public void clearShadow()&#123; mSetShadow = false; postInvalidate(); &#125; public void showShadow()&#123; mSetShadow = true; postInvalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mSetShadow) &#123; mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY); &#125;else &#123; mPaint.clearShadowLayer(); &#125; canvas.drawText("启舰大SB",100,100,mPaint); canvas.drawCircle(200,200,50,mPaint); canvas.drawBitmap(mDogBmp,null,new Rect(200,300,200+mDogBmp.getWidth(),300+mDogBmp.getHeight()),mPaint); &#125; &#125; 修改的代码很简单，增加一个变量mSetShadow来控制当前是否显示阴影，如果需要显示阴影就调用mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY);设置阴影，如果不需要显示阴影就调用mPaint.clearShadowLayer();来清除阴影；对于使用btn调用clearShadow()、showShadow()这两个接口的用法，就不再帖代码了，没啥难度，源码里也有；效果图如下： 在目前的所有例子中，我们的定义控件在xml中使用时，layout_widht、layout_height都统一设置成match_parent或者fill_parent来强制全屏；是时间教大家如何使用wrap_content属性，如何让控件自已计算高度了，下篇我们就来看看这个问题。 三、TextView及其派生类使用ShadowLayer添加阴影效果上面我们通过自定义控件来实现了自定义阴影效果，那么问题来了，如果我需要给已有的控件添加阴影效果，实现下面这样的效果： 1、XML实现从上面可以看到，TextView,Button,EditView中的文字都具有阴影效果。那是怎么实现的呢？难道我们需要在原生控件的甚而上派生一个类在onDraw里使用setShadowLayer来绘制阴影吗？答案当然不是，setShadowLayer是API 1 就已经引入的方法，同样，对于TextView和从TextView派生的类都自然具体XML属性来设置阴影。这几个设置阴影的XML属性如下：123456&lt;TextView ………… android:shadowRadius="3" android:shadowDx="5" android:shadowDy="5" android:shadowColor="@android:color/darker_gray"/&gt; 这几个属性的意义非常容易理解，直接对应setShadowLayer的几个参数setShadowLayer(float radius, float dx, float dy, int color)，但这几个属性只有TextVIew及其派生类才会有，其它类是没有的，TextVIew的派生类如下：所以一般我们使用的Button和EditText是可以使用Xml来实现阴影的。 2、代码实现既然能通过XML实现，当然也能会代码版了，TextView及其派生类，都有一个Paint.setShadowLayer的同名方法： //TextView中的设置阴影函数 public void setShadowLayer(float radius, float dx, float dy, int color) 通过该方法就很容易来实现TextView及其派生类的阴影了。使用示例如下： TextView tv = (TextView)findViewById(R.id.tv); tv.setShadowLayer(2,5,5, Color.GREEN); 四、SetMaskFilter之BlurMaskFilter实现发光效果前面我们讲了如何给控件添加阴影效果，其它跟阴影效果类似的还有一个发光效果： 上面就是我们这节要讲的发光效果，在这个效果图中，总共涉及了三个内容的发光效果：文字、图形和Bitmap图像。从最后一个小狗的Bitmap所形成的发光效果中可以看到，与setShadowLayer一样，发光效果也只会影响边缘部分图像，内部图像是不受影响的。从第三个图形（红绿各一半的Bitmap）中可以看到：发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。所以初步我们对发光效果有如下结论： 与setShadowLayer一样，发光效果也是使用的高斯模糊，并且只会影响边缘部分图像，内部图像是不受影响的 发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。 1、SetMaskFilter之BlurMaskFilter概述Paint函数的的setMaskFilter声明如下： public MaskFilter setMaskFilter(MaskFilter maskfilter) 前面我们讲到setColorFilter来设置颜色滤镜,与setColorFilter一样，setMaskFilter中的MaskFilter也是没有具体实现的，也是通过派生子类来实现具体的不同功能的，MaskFilter有两个派生类BlurMaskFilter和EmbossMaskFilter，其中BlurMaskFilter就是我们这段要讲的实现发光效果的子类，而EmbossMaskFilter是用来实现浮雕效果的，用处很少，这里就不再讲了。另一点需要注意的是，setMaskFilter是不支持硬件加速的，必须关闭硬件加速才可以。BlurMaskFilter的构造函数如下： public BlurMaskFilter(float radius, Blur style) 其中： float radius：用来定义模糊半径，同样是高斯模糊算法。 Blur style：发光样式，有内发光、外发光、和内外发光，分别对应：Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)，这几个模式，后面我们会逐个来展示用法。下面我们简单举一个例子来看看用法先，这个例子的代码如下： 12345678910111213141516171819202122232425262728293031public class BlurMaskFilterView extends View &#123; private Paint mPaint; public BlurMaskFilterView(Context context) &#123; super(context); init(); &#125; public BlurMaskFilterView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public BlurMaskFilterView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setMaskFilter(new BlurMaskFilter(50, Blur.INNER)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(200,200,100,mPaint); &#125; &#125; 这里使用起来非常容易，只需要在paint的时候调用setMaskFilter将BlurMaskFilter的实例设置进行就可以了。这里使用的内发光模式。我们来看下效果图： 很明显的内发光效果。下面我们分别来看看各种模式下的发光效果。 2、BlurStyle发光效果(1)、Blur.INNER——内发光 (2)、Blur.SOLID——外发光 (3)、Blur.NORMAL——内外发光 (4)、Blur.OUTER——仅显示发光效果 Blur.OUTER比较特殊，这种模式下仅会显示发光效果，会把原图像中除了发光部分，全部变为透明！大家是否可以看出来发光效果与setShadowLayer所生成的阴影之间有什么联系？setShadowLayer所生成的阴影，其实就是将新建的阴影图形副本进行发光效果并且位移一定的距离而已。下篇我们就会利用这个原理来生成图片指定颜色的阴影效果。到这里，这篇文章就结束了，下篇将继续给大家讲解如何给图片添加指定颜色的阴影效果，并且初步教大家如何将其封装成一个控件。 三、为Bitmap添加阴影并封装控件上篇给大家讲解了如何控件添加阴影效果，但是在为Bitmap图片添加阴影时，却没办法添加具有指定颜色的阴影，这篇我们就来使用自定义的控件及自定义属性来初步封装下控件。前方高能预警——本篇内容涉及内容较多，难度较大，需要多加思考。 一、使用BlurMaskFilter为图片构造定色阴影效果上面我们讲了通过setShadowLayer为图片添加阴影效果，但是图片的的阴影是用原图形的副本加上边缘发光效果组成的。我们怎么能给图片添加一个灰色的阴影呢？我们来分析一下setShadowLayer的阴影形成过程（假定阴影画笔是灰色），对于文字和图形，它首先产生一个跟原型一样的灰色副本。然后对这个灰色副本应用BlurMaskFilter，使其内外发光；这样就形成了所谓的阴影！当然最后再偏移一段距离。所以，我们要给图片添加灰色阴影效果，所以我们能不能仿一下这个过程：先绘制一个跟图片一样大小的灰色图形，然后给这个灰色图形应用BlurMaskFilter使其内外发光，然后偏移原图形绘制出来，不就可以了么所以，这里涉及到三个点： 绘制出一个一样大小的灰色图形 对灰色图形应用BlurMaskFilter使其内外发光 偏移原图形一段距离绘制出来下面我们就通过例子来一步步看是怎么实现出来的吧 1、绘制出一个一样大小的灰色图像首先，我们来看怎么能绘出一个指定Bitmap所对应的灰色图像。我们知道canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)中的paint的画笔颜色对画出来的bitmap是没有任何影响的，因为原来Bitmap长什么样，无论你画笔是什么颜色，画出来的图片还是跟原图片长的一样。所以如果我们需要画一张对应的灰色图像，我们需要新建一个一样大小的空白图，但是新图片的透明度要与原图片保持一致。所以如何从原图片中抽出Alpha值成为了关键。即我们只需要创建一个与原图片一样大小且Alpha相同的图片即可。其实Bitmap中已经存在抽取出只具有Alpha值图片的函数： public Bitmap extractAlpha(); extraAlpha()函数的功能是：新建一张空白图片，图片具有与原图片一样的Alpha值，这个新建的Bitmap做为结果返回。这个空白图片中每个像素都具有与原图片一样的Alpha值，而且具体的颜色时，只有在使用canvas.drawBitmap绘制时，由传入的paint的颜色指定。总结 extractAlpha()新建一张仅具有Alpha值的空白图像 这张图像的颜色，是由canvas.drawBitmap时的画笔指定的。 （1）、extractAlpha()使用示例下面，我们就用个例子先来看下extractAlpha()函数的用法我们拿一张图片来做试验，下面这张PNG图片中，一只小猫和一只小狗，其余地方都是透明色。下面我们分别利用extractAlpha()画出它对应的红色和绿色的阴影图对应的代码为：123456789101112131415161718192021222324252627282930313233343536373839public class ExtractAlphaView extends View &#123; private Paint mPaint; private Bitmap mBitmap,mAlphaBmp; public ExtractAlphaView(Context context) &#123; super(context); init(); &#125; public ExtractAlphaView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ExtractAlphaView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; //禁用硬件加速 setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.blog12); mAlphaBmp = mBitmap.extractAlpha(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //分别将画笔的颜色设置为红色和绿色，然后两次把mAlphaBmp画出来。 int width = 200; int height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth(); mPaint.setColor(Color.RED); canvas.drawBitmap(mAlphaBmp,null,new Rect(0,0,width,height),mPaint); mPaint.setColor(Color.GREEN); canvas.drawBitmap(mAlphaBmp,null,new Rect(0,height,width,2*height),mPaint); &#125;&#125; 首先是禁用硬件加速，这基本上是我们做自定义控件的标配！为了防止功能不好用，记得每次都加上这个函数！然后是利用extratAlpha()来生成仅具有透明度的空白图像。 2、对灰色图形应用BlurMaskFilter使其内外发光在第一步完成了之后，我们进行第二步，将阴影添加内外发光效果。就形成了阴影的模样。代码很简单，只需要使用Paint.setMaskFilter函数添加发光效果即可，代码如下：123456789101112protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 200; int height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth(); mPaint.setColor(Color.RED); mPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mAlphaBmp,null,new Rect(0,0,width,height),mPaint); mPaint.setColor(Color.GREEN); canvas.drawBitmap(mAlphaBmp,null,new Rect(0,height,width,2*height),mPaint);&#125; 明显可以看出这里只添加了一行代码：mPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL));就是添加内外发光效果，难度不大，不再细讲。 3、偏移原图形一段距离绘制出来这段比较简单了，只需要先把阴影画出来，然后再把原图像盖上去，但需要注意的是，阴影需要相对原图像偏移一段距离。完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ExtractAlphaView extends View &#123; private Paint mPaint; private Bitmap mBitmap,mAlphaBmp; public ExtractAlphaView(Context context) &#123; super(context); init(); &#125; public ExtractAlphaView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ExtractAlphaView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.blog12); mAlphaBmp = mBitmap.extractAlpha(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 200; int height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth(); //绘制阴影 mPaint.setColor(Color.RED); mPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mAlphaBmp,null,new Rect(10,10,width,height),mPaint); mPaint.setColor(Color.GREEN); canvas.drawBitmap(mAlphaBmp,null,new Rect(10,height+10,width,2*height),mPaint); //绘制原图像 mPaint.setMaskFilter(null); canvas.drawBitmap(mBitmap,null,new Rect(0,0,width,height),mPaint); canvas.drawBitmap(mBitmap,null,new Rect(0,height,width,2*height),mPaint); &#125;&#125; 关键部分在onDraw函数中，先画出来阴影，然后再画出来原图像，需要注意的是在画原图像时，需要利用mPaint.setMaskFilter(null);将发光效果去掉。只有阴影需要发光效果，原图像是不需要发光效果的。另一点注意的是，阴影要偏移一点位置，这里是偏移了10个像素。 二、封装控件上面我们初步实现了图片的阴影效果，但这只是本篇内容的一小部分，最最重要的，如何将它封装成一个控件，具有如下功能： 让用户定义图片内容 让用户定义偏移距离 让用户定义阴影颜色和阴影模糊程度 可以使用wrap_content属性自适应大小 1、自定义控件属性有关自定义控件属性，大家首先需要看下这篇文章《PullScrollView详解（一）——自定义控件属性》，在这篇文章中讲解了自定义控件属性的方法与提取方法。下面将会直接用到自定义属性的内容，下面涉及到的时候就自认为大家已经学会了自定义控件属性的方法了。在这里，我们需要自定义四个属性，分别对应： 自定义图片内容、自定义偏移距离、自定义阴影颜色、自定义阴影模糊程度 这四个需求，所以我们先利用declare-styleable标签来定义这些属性attr.xml12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="BitmapShadowView"&gt; &lt;attr name="src" format="reference" /&gt; &lt;attr name="shadowDx" format="integer" /&gt; &lt;attr name="shadowDy" format="integer" /&gt; &lt;attr name="shadowColor" format="color"/&gt; &lt;attr name="shadowRadius" format="float"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这里定义了五个xml属性，src来引用图片资源，仿照setShadowLayer另外定义shadowDx、shadowDy、shadowColor、shadowRadius来定义阴影的边距、颜色和模糊半径。然后在布局中使用：(main.xml)12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;com.harvic.BlogBitmapShadow.BitmapShadowView android:layout_width="200dp" android:layout_height="200dp" android:layout_gravity="center_horizontal" app:src="@drawable/blog12" app:shadowDx="10" app:shadowDy="10" app:shadowRadius="10.0" app:shadowColor="@android:color/holo_red_dark"/&gt;&lt;/LinearLayout&gt; 在布局中使用很简单，直接定义控件所使用的图片资源、阴影相关参数就可以了，难度不大就不再讲了，下面我们来看如何在代码中中提取用户传入的这些属性。BitmapShadowView中提取属性值并绘阴影先列出完整代码，然后再细讲：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class BitmapShadowView extends View &#123; private Paint mPaint; private Bitmap mBmp,mShadowBmp; private int mDx = 10,mDy = 10; private float mRadius = 0; private int mShadowColor; public BitmapShadowView(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(context,attrs); &#125; public BitmapShadowView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(context,attrs); &#125; private void init(Context context,AttributeSet attrs) throws Exception &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); /** * 提取属性定义 */ TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView); int BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-1); if (BitmapID == -1)&#123; throw new Exception("BitmapShadowView 需要定义Src属性,而且必须是图像"); &#125; mBmp = BitmapFactory.decodeResource(getResources(),BitmapID); mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,0); mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,0); mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,0); mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK); typedArray.recycle(); /** * 其它定义 */ mPaint = new Paint(); mShadowBmp = mBmp.extractAlpha(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth()-mDx; int height = width * mBmp.getHeight()/mBmp.getWidth(); //绘制阴影 mPaint.setColor(mShadowColor); mPaint.setMaskFilter(new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mShadowBmp,null,new Rect(mDx,mDy,width,height),mPaint); //绘制原图像 mPaint.setMaskFilter(null); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125;&#125; 在这段代码中分两部分，首先根据属性来初始化各变量，然后再利用这些变量画出bitmap与阴影。首先看初始化部分：1234567891011121314151617181920212223private void init(Context context,AttributeSet attrs) throws Exception &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); /** * 提取属性定义 */ TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView); int BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-1); if (BitmapID == -1)&#123; throw new Exception("BitmapShadowView 需要定义Src属性,而且必须是图像"); &#125; mBmp = BitmapFactory.decodeResource(getResources(),BitmapID); mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,0); mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,0); mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,0); mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK); typedArray.recycle(); /** * 其它定义 */ mPaint = new Paint(); mShadowBmp = mBmp.extractAlpha();&#125; 初始化的时候，首先是利用TypedArray来初始化各项参数，由于我们是做图片的阴影，所以图片资源必须赋值，所以我们在提取图片资源时，对其添加容错：1234int BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-1);if (BitmapID == -1)&#123; throw new Exception("BitmapShadowView 需要定义Src属性,而且必须是图像");&#125; 当提取失败时，抛出异常，终止程序，这样用户在写代码时就可以及时发现问题，而不必等上线以后才发现没有bitmap；有关其它属性值的提取，这里就不再细讲了。在提取完属性以后，就是定义画笔paint和根据源图像利用extractAlpha()来生成阴影图像；在初始化以后就是利用这些属性来进行绘图了：123456789101112131415protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth()-mDx; int height = width * mBmp.getHeight()/mBmp.getWidth(); //绘制阴影 mPaint.setColor(mShadowColor); mPaint.setMaskFilter(new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mShadowBmp,null,new Rect(mDx,mDy,width,height),mPaint); //绘制原图像 mPaint.setMaskFilter(null); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint);&#125; 首先，图片宽度与控件宽度操持一致（但需要把阴影的位置空出来），所以宽度为：int width = getWidth()-mDx根据图片的宽高比换算出图片的高度：int height = width * mBmp.getHeight()/mBmp.getWidth()我们依控件左上角（0，0）显示原图像，阴影在(mDx,mDy)处显示；到这里自定义属性的定义与提取就结束了，最终效果图为：从效果图中可以明显看出，明显给原图片添加了红色的阴影效果。目前，我们初步实现了可以让用户自定义控件属性的功能，但我们在使用这个控件时，必须强制设置指定的宽高或者fill_parent来强制平屏，这样明显是不可取的，我们需要它能够让用户使用wrap_conetent时，自己计算宽高。 2、wrap_content自适应宽高在自适应宽高时，需要了解onMeasure()、onLayout()与onDraw()的知识；在第三篇中我还会重新讲解一遍onMeasure()、onLayout()与onDraw()，这里涉及内容不多，看完上一篇然后再理解以下内容应该不会有问题在看完上面的文章，大家就应该知道，对于View控件的自适应宽高，只需要在上面的代码中重写onMeasure()方法就可以了:12345678910111213protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width = mBmp.getWidth(); int height = mBmp.getHeight(); setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height);&#125; 在onMeasure方法中，当用户指定属性是wrap_content时，就使用图片的宽高做为控件的宽高。此时整个自定义控件的完整代码为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class BitmapShadowView extends View &#123; private Paint mPaint; private Bitmap mBmp,mShadowBmp; private int mDx = 10,mDy = 10; private float mRadius = 0; private int mShadowColor; public BitmapShadowView(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(context,attrs); &#125; public BitmapShadowView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(context,attrs); &#125; private void init(Context context,AttributeSet attrs) throws Exception &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); /** * 提取属性定义 */ TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView); int BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-1); if (BitmapID == -1)&#123; throw new Exception("BitmapShadowView 需要定义Src属性,而且必须是图像"); &#125; mBmp = BitmapFactory.decodeResource(getResources(),BitmapID); mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,0); mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,0); mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,0); mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK); typedArray.recycle(); /** * 其它定义 */ mPaint = new Paint(); mShadowBmp = mBmp.extractAlpha(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width = mBmp.getWidth(); int height = mBmp.getHeight(); setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth()-mDx; int height = width * mBmp.getHeight()/mBmp.getWidth(); //绘制阴影 mPaint.setColor(mShadowColor); mPaint.setMaskFilter(new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mShadowBmp,null,new Rect(mDx,mDy,width,height),mPaint); //绘制原图像 mPaint.setMaskFilter(null); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125;&#125; 所以当我们对这个自定义的控件使用如下布局（使用wrap_content）：123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;com.harvic.BlogBitmapShadow.BitmapShadowView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" app:src="@drawable/blog12" app:shadowDx="10" app:shadowDy="10" app:shadowRadius="10.0" app:shadowColor="@android:color/holo_red_dark"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="test BTN"/&gt;&lt;/LinearLayout&gt; 所以，这时候如果我们需要产生灰色阴影，只需要把xml中的app:shadowColor的值改一下即可：(为了方便看阴影，我把Activiy背景改成了白色)1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:background="@android:color/white"&gt; &lt;com.harvic.BlogBitmapShadow.BitmapShadowView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" app:src="@drawable/blog12" app:shadowDx="10" app:shadowDy="10" app:shadowRadius="10.0" app:shadowColor="@android:color/darker_gray"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="test BTN"/&gt;&lt;/LinearLayout&gt; 到这里，整个控件的封装就结束了，但细心的同学可以发现，BitmapShadowView的构造函数默认有三个，而我这里只写了两个具有AttributeSet attrs参数的，而下面这个构造函数却是没有实现的：123public BitmapShadowView(Context context)&#123; super(context);&#125; 因为当从XML中生成控件时，都会调用具有AttributeSet attrs参数的方法，而从代码中生成控件则会调用上面仅具有context函数的方法，所以如果需要从代码中生成需要添加上这个方法，并且需要在代码中提供接口供外部设置各种属性才好，我这里就略去了这部分内容了，大家可以自己来填充这个控件，使其更完整。 四、BitmapShader与望远镜效果上篇初步给大家展示了封装控件的方法，这篇我们继续Paint来看相关方法的用法，这篇我们将会讲一个很起来没啥用，但效果却很屌的方法setShader，这篇文章最后，我们将实现的效果是望远镜效果:（看起来有没有屌屌的）我们先来看看setShader函数的声明： //Paint类中的方法 public Shader setShader(Shader shader) Shader在三维软件中称之为着色器，就是用来给空白图形上色用的。在PhotoShop中有一个工具叫印章工具，我们能够指定印章的样式来填充图形。印章的样式可以是图像、颜色、渐变色等。这里的Shader实现的效果与印章类似。我们也是通过给Shader指定对应的图像、渐变色等来填充图形的。Shader类只是一个基类，它其中只有两个方法setLocalMatrix(Matrix localM)、getLocalMatrix(Matrix localM)用来设置坐标变换矩阵的，有关设置矩阵的内容，我们后面会单独讲解坐标矩阵用法的时候，会再次提，这里就先略过。Shader类与ColorFiler一样，其实是一个空类，它的功能的实现，主要是靠它的派生类来实现的。继承关系如下：下面我们就来逐个来看每个派生类的用法与效果。 一、BitmapShader基本用法1、概述我们这篇文章只看一个派生类：BitmapShader，它的构造函数如下： public BitmapShader(Bitmap bitmap, TileMode tileX, TileMode tileY) 这个就相当于PhotoShop中的图案印章工具，bitmap用来指定图案，tileX用来指定当X轴超出单个图片大小时时所使用的重复策略，同样tileY用于指定当Y轴超出单个图片大小时时所使用的重复策略其中TileMode的取值有： TileMode.CLAMP:用边缘色彩填充多余空间 TileMode.REPEAT:重复原图像来填充多余空间 TileMode.MIRROR:重复使用镜像模式的图像来填充多余空间只看这些还是啥都不懂，我们先来举个例子来看下用法 2、BitmapShader使用示例这里使用的印章图像是：(dog_edge.png)中间是我们熟悉的小狗，四周被四种不同的颜色给包围，这些颜色是我特地画上去的，后面自然有它的用处。我们还是先直接来看完整代码吧：12345678910111213141516171819202122232425262728293031public class BitmapShaderView extends View &#123; private Paint mPaint; private Bitmap mBmp; public BitmapShaderView(Context context) &#123; super(context); init(); &#125; public BitmapShaderView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public BitmapShaderView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge); mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //getWidth()用于获取控件宽度，getHeight()用于获取控件高度 canvas.drawRect(0,0,getWidth(),getHeight(),mPaint); &#125;&#125; 代码其实很简单，在初始化的时候设置印章图片：12345private void init()&#123; mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge); mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));&#125; 然后在绘图的时候，利用paint绘制一个矩形，这个矩形的大小与控件的大小一模一样：12345protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //getWidth()用于获取控件宽度，getHeight()用于获取控件高度 canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 然后在布局中使用时：123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="test BTN"/&gt; &lt;com.harvic.Blog_BitmapShader.BitmapShaderView android:layout_width="200dp" android:layout_height="400dp" android:layout_gravity="center_horizontal"/&gt;&lt;/LinearLayout&gt; 给我们自定义的控件添加上宽高限制，为了方便看效果，我在它上面也另外加了一个按钮从效果图中可以看出： 使用X轴和Y轴都使用REPEAT模式下，在超出单个图像的区域后，就会重复绘制这个图像 绘制是从控件的左上角开始的，而不是从屏幕原点开始的！这点很好理解，因为我们绘图也只会在自定义控件上绘图，不会在全屏幕上绘图。 3、TileMode模式解析上面初步看到了REPEAT模式的用法，现在我们分别来看在各个模式下的不同表现 （1）、TileMode.REPEAT模式：重复原图像来填充多余空间在更改模式时，只需要更新setShader里的代码：mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));在这里，X轴、Y轴全部设置成REPEAT模式，所以当控件的显示范围超出了单个图的显示范围时，在X轴上将使用REPEAT模式,同样，在Y轴上也将使用REPEAT模式 （2）、TileMode.MIRROR模式：重复使用镜像模式的图像来填充多余空间同样，将X轴、Y轴全部改为MIRROR模式：mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.MIRROR));先看效果图的X轴：在X轴上每两张图片的显示都像镜子一样翻转一下。同样，在Y轴上每两张图片的显示也都像镜子一样翻转一下。所以这就是镜相效果的作用，镜相效果其实就是在显示下一图片的时候，就相当于两张图片中间放了一个镜子一样。 （3）、TileMode.CLAMP:用边缘色彩填充多余空间同样，我们还是将X轴、Y轴全部改为CLAMP模式：mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.CLAMP));CLAMP模式的意思就是当控件区域超过当前单个图片的大小时，空白位置的颜色填充就用图片的边缘颜色来填充。 （4）、TileMode.CLAMP与填充顺序我们还是先来看一下原图像：按照我们上面讲的，当X轴、Y轴全部都是CLAMP模式时，X轴的空白区域会用图像的右侧边缘颜色来填充；Y轴的空白区域会用图像的底部的边缘颜色来填充，那效果应该是这样的：明显右下角的空白位置根本与图像是不沾边的，那它要用什么颜色来填充呢？是填充上方的蓝色还是填充左侧的绿色呢？从最终的效果图来看，这部分填充的颜色是绿色的，可为什么呢？其实这是跟填充顺序有关的，因为我们同时要填充横向和竖向；那到底是先填充横向还是先填充竖向呢？答案是先填充竖向！在填充竖向后的结果如下：在填充竖向后，整个竖向都是有颜色的了，此时再根据竖向的边缘色彩来填充横向：红色方框的区域就是根据竖向的边缘色彩来填充的，这样，当X轴Y轴全是CLAMP时，就理解为什么右下角是填充的绿色而不是蓝色的原因了。 （5）、当MIRROR与REPEAT混用时TileMode.MIRROR, TileMode.REPEAT上面我们在填充X轴 和Y轴的空白位置时，都是用的同一种模式，下面我们就来看一下当X轴与Y轴的填充模式不一样时，效果又是怎样的呢？这里我们假设X轴填充空白区域时，使用MIRROR样式、在填充Y轴空白区域时，使用REPEAT样式：mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.REPEAT));无论哪两种模式混合，我们在理解时只需要记着填充顺序是先填充Y轴，然后再填充X轴！这样效果图就很好理解了首先，是先填充Y轴，在填充Y轴时使用的是REPEAT模式，此时的效果图是：在填充Y轴以后再利用X轴的镜相模式来填充X轴，这样整个控件就被填充完毕了。TileMode.REPEAT，TileMode.MIRROR下面我们再反过来看一下当X轴使用REPEAT模式，Y轴使用MIRROR模式效果会怎样：mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.MIRROR));同样是先使用镜相模式来填充Y轴，然后再使用REPEAT模式来填充X轴；所以从效果图中可以明显看出第一列的Y轴全部是镜相效果。然后再根据第一列的镜相效果来填充X轴，由于X轴使用的是REPEAT模式，所以X轴的图像全部都与左侧第一列的图像相同。 （6）、CLAMP模式与其它模式混用上面我们理解了填充顺序的意义以后，下面再来看一下最难的两种混用方式，就是当CLAMP模式与其它模式混用时的效果。比如，当X轴使用CLAMP效果填充，而Y轴使用MIRROR效果填充时：mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.MIRROR));从效果图中很好理解，先填充Y轴，填充以后的Y轴各个图像是镜相分布的。而此时再使用CLAMP模式来填充X轴，会拿Y轴图像最边缘的颜色来进行填充。理解难度不大，就不再细讲了。下面再将这两种模式反过来，X轴使用MIRROR模式而Y轴使用CLAMP模式：mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP));想必大家看到效果图以后，也理解为什么会出现这种效果了，这里就不再讲了，如果还不懂，把上面讲的再看一遍。 4、绘图位置与模式的关系在上面的例子中，我们利用drawRect把整个控件大小都给覆盖了，那假如我们只画一个小矩形而不完全覆盖整个控件，那我们SetShader的图片是从哪里开始画的呢？是从开始drawRect所绘矩形的左上角开始画，还是在控件的左上角开始的呢？我们举个例子来看下：123456789101112131415161718192021222324252627282930public class BitmapShaderView extends View &#123; private Paint mPaint; private Bitmap mBmp; public BitmapShaderView(Context context) &#123; super(context); init(); &#125; public BitmapShaderView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public BitmapShaderView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge); mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(100,20,200,200,mPaint); &#125;&#125; 上面的代码并没有改变什么，我们需要注意的只有两点：第一：设置的重复模式：mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP));第二：绘图时，仅绘制一小块矩形：canvas.drawRect(100,20,200,200,mPaint);这是个什么鬼……根本看不懂啊有木有……我们再回来看一下当所绘矩形覆盖整个控件时的效果图：而我们这里的效果图根本就是这个完整的图片上扣出来的一小块有没有…… 其实这正说明了一个问题：无论你利用绘图函数绘多大一块，在哪绘制，与Shader无关。因为Shader总是在控件的左上角开始，而你绘制的部分只是显示出来的部分而已。没有绘制的部分虽然已经生成，但只是不会显示出来罢了。 利用这个特性，我们就可绘制我们的最上面的望远镜效果了 5、望远镜效果我们只需要按照控件大小平铺当前所要绘制的图形的Shader，然后再画出来一个圆圈来当做望远镜就可以了。我们先用一张做为Shader的背景图：在看完所使用的背景以后，我们再来看下效果图这里有两个功能：首先，将图片拉伸来覆盖整个控件；然后，首先给控件设置进BitmapShader，然后在手指的位置画一个半径为150的圆就可以了。正是由于在Paint设置了Shader以后，无论我们绘图位置在哪，Shader中的图片都是从控件的左上角开始填充的，而我们所使用的绘图函数只是用来指定哪部分显示出来，所以当我们在手指按下位置画上一个圆形时，就会把圆形部分的图像显示出来了，看起来就是个望远镜效果。然后完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class TelescopeView extends View &#123; private Paint mPaint; private Bitmap mBitmap,mBitmapBG; private int mDx = -1, mDy = -1; public TelescopeView(Context context) &#123; super(context); init(); &#125; public TelescopeView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TelescopeView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.scenery); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDx = (int) event.getX(); mDy = (int) event.getY(); postInvalidate(); return true; case MotionEvent.ACTION_MOVE: mDx = (int) event.getX(); mDy = (int) event.getY(); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mDx = -1; mDy = -1; break; &#125; postInvalidate(); return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mBitmapBG == null)&#123; mBitmapBG = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888); Canvas canvasbg = new Canvas(mBitmapBG); canvasbg.drawBitmap(mBitmap,null,new Rect(0,0,getWidth(),getHeight()),mPaint); &#125; if (mDx != -1 &amp;&amp; mDy != -1) &#123; mPaint.setShader(new BitmapShader(mBitmapBG, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); canvas.drawCircle(mDx, mDy, 150, mPaint); &#125; &#125;&#125; 我们主要来看下OnDraw函数：在onDraw函数中，第一部分，就是新建一个空白的bitmap，这个bitmap的大小与控件一样，然后把我们的背景图进行拉伸，画到这个空白的bitmap上。12345if (mBitmapBG == null)&#123; mBitmapBG = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888); Canvas canvasbg = new Canvas(mBitmapBG); canvasbg.drawBitmap(mBitmap,null,new Rect(0,0,getWidth(),getHeight()),mPaint);&#125; 由于这里的canvasbg是用mBitmapBG创建的，所以所画的任何图像都会直接显示在mBitmapBG上，而我们创建的mBitmapBG是与控件一样大的，所以当把mBitmapBG做为Shader来设置给paint时，mBitmapBG会正好覆盖整个控件，而不会有多余的空白像素。这里需要注意的就是我们在将原图像画到mBitmapBG时，进行了拉压缩，把它拉伸到根当前控件一样大小。然后利用Shader的知识，利用OnMotionEvent来捕捉用户的手指位置，当用户手指下按时，在手指位置画一个半径为150的圆形，把对应的位置的图像显示出来就可以了：1234if (mDx != -1 &amp;&amp; mDy != -1) &#123; mPaint.setShader(new BitmapShader(mBitmapBG, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); canvas.drawCircle(mDx, mDy, 150, mPaint);&#125; 这个控件的难度并不大，问题就在于理解Shader中图像的起始布局位置和显示图像的关系。 二、利用BitmapShader生成不规则头像这部分，我们还得利用Shader的从控件左上角开始布局的原理和显示图像的关系，来讲解一个我们平时经常用到的控件：不规则头像，效果图如下： 前面我们已经教大家了一种生成不规则头像的方法，大家还记得不，使用xfermode。这篇我们就来讲解另一种生成不规则头像的方法，大家赶紧喜大普奔吧 这里我们依然教大家如何将它封装成一个控件，这里所实现的效果有：圆形图像，方形带圆角的头像。 1、初步实现圆形头像控件这部分，我们先讲原理，初步实现下面的控件效果原始的头像是这样的：很明显我们给头像加了个圆框效果；我们直接来看代码吧：1234567891011121314151617181920212223242526272829303132333435public class AvatorViewDemo extends View &#123; private Paint mPaint; private Bitmap mBitmap; private BitmapShader mBitmapShader; public AvatorViewDemo(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(); &#125; public AvatorViewDemo(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(); &#125; private void init() throws Exception&#123; mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.avator); mPaint = new Paint(); mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Matrix matrix = new Matrix(); float scale = (float) getWidth()/mBitmap.getWidth(); matrix.setScale(scale,scale); mBitmapShader.setLocalMatrix(matrix); mPaint.setShader(mBitmapShader); float half = getWidth()/2; canvas.drawCircle(half,half,getWidth()/2,mPaint); &#125;&#125; 首先是初始化：123456private void init() throws Exception&#123; mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.avator); mPaint = new Paint(); mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);&#125; 在初始化时创建一个BitmapShader，填充模式分别是TileMode.CLAMP、TileMode.CLAMP，其实这里填充模式没什么用，因为我们只需要显示当前图片；所以不存在多余空白区域，所以使用哪种填充模式都无所谓。最关键的部分在于绘图：1234567891011protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Matrix matrix = new Matrix(); float scale = (float) getWidth()/mBitmap.getWidth(); matrix.setScale(scale,scale); mBitmapShader.setLocalMatrix(matrix); mPaint.setShader(mBitmapShader); float half = getWidth()/2; canvas.drawCircle(half,half,getWidth()/2,mPaint);&#125; 绘图时，首先是将BitmapShader缩放到与控件宽高一致；由于我们要画的是一个圆形图像，所以我们必须将图像缩放成一个正方形，而边长就与控件的宽度一致即可：12345Matrix matrix = new Matrix();float scale = (float) getWidth()/mBitmap.getWidth();matrix.setScale(scale,scale);mBitmapShader.setLocalMatrix(matrix);mPaint.setShader(mBitmapShader); 这块就使用了位置矩阵的知识，同时也用上了我们开篇时所讲的mBitmapShader.setLocalMatrix(matrix)函数，有关位置矩阵我们会在后面的章节中涉及，这里只需要知道这块是用来缩放BitmapShader的即可。然后利用BitmapShader是从控件左上角开始平铺的，利用canvas.drawXXX系列函数只是用来定义显示哪一块的原理，我们在图片的正中心画一个圆，半径是图片正方形半径的一半：float half = getWidth()/2;canvas.drawCircle(half,half,getWidth()/2,mPaint);在理解了上面的原理之后，再理解这个就难度不大了。我们这里只画了个圆形，如果我们画一个矩形，那显示的控件就是个矩形了，如果我们画一个五角形，那头像也就是个五角形效果了；原理到这里就讲完了，下面我们先来看几个开源例子，然后再继续讲解如何将其封装成控件的知识。下面我们来看一下几个开源的例子：地址：https://github.com/hdodenhof/CircleImageView这个效果大家现在会做了没，它不仅实现了圆形头像效果，还而还在外边加了一个带颜色的边。想必在头像外围加个描边不是什么给事吧……悄悄提醒一下，只需要在画圆时，将paint设置为mPaint.setStyle(Paint.Style.STROKE);即可画出来描边。大家自己试试怎么来实现这个控件吧。第二个开源例子：地址：https://github.com/MostafaGazar/CustomShapeImageView具体这些效果在这个控件中是怎么实现的，我也没有看。但敢肯定的是，通过BitmapShape是肯定可以实现的，只要我们利用Path可以做出各种图形（比如这里的五角形，这里的心形），然后利用canvas在Shape上显示出来这块区域就可以了。但明显难度是比较大的，所以对于这类复杂的图像显示，还是建议使用以前我们讲过的Xfermode来做图像混合即可。好了，原理就讲到这了，下面我们把上面的圆形控件加以封装，做出来一个通用控件 2、封装成控件上篇文章已经教大家如何封装成控件了，这部分我们再来看这个例子是如何封装成控件的。我们再重新来看一下效果图，看我们这部分要做哪些效果出来从效果图来看，我们要做两个效果： 圆形图像 矩形图像，但带自定义大小的圆角 （1）、自定义属性封装控件最难免的就是自定义属性了，这块是必会的。根据我们需要做的两个效果，所以我们自定义属性时，首先要有一个属性来标识当前是做圆形头像还是做矩形图像然后如果是矩形图像，还要有一个值来表示矩形图像的圆角有多大最后，还需要一个src的属性来让用户引入Bitmap图像所以，此时的定义属性应该是：（values/attrs.xml）1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="AvatorView"&gt; &lt;attr name="src" format="reference" /&gt; &lt;attr name="format" format="enum"&gt; &lt;enum name="circle" value="0"/&gt; &lt;enum name="rectTangle" value="1"/&gt; &lt;/attr&gt; &lt;attr name="radius" format="integer" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这里定义了三个属性： src：对应BitmapShader所需要使用的图片 format：是一个枚举值，用于指定当前是做圆形图像还是做矩形图像 radius：是矩形图像时的边角圆形半径 （2）、控件解析在自定义的属性之后，我们就开始我们自定义控件的Java代码征程了，首先是解析自定义属性：1234567891011121314151617181920212223242526272829303132333435363738public class AvatorView extends View &#123; private Paint mPaint; private Bitmap mBitmap; private BitmapShader mBitmapShader; private int mEnumFormat =0,mRadius = 5; public AvatorView(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(context,attrs); &#125; public AvatorView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(context,attrs); &#125; private void init(Context context,AttributeSet attrs) throws Exception&#123; /** * 提取属性定义 */ TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.AvatorView); int BitmapID = typedArray.getResourceId(R.styleable.AvatorView_src,-1); if (BitmapID == -1)&#123; throw new Exception("AvatorView 需要定义Src属性,而且必须是图像"); &#125; mBitmap = BitmapFactory.decodeResource(getResources(),BitmapID); mEnumFormat = typedArray.getInt(R.styleable.AvatorView_format,0); if (mEnumFormat == 1)&#123; mRadius = typedArray.getInt(R.styleable.AvatorView_radius,5); &#125; typedArray.recycle(); mPaint = new Paint(); mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); &#125; …………&#125; 这部分与上篇相同，就不再讲了，无外乎就是在初始化的时候解析控件自定义属性，没什么难度。 （3）、自测量然后我们需要在用户定义layout_width、layout_height的值为wrap_content时，自测量控件大小即重写onMeasuer()12345678910111213protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width = mBitmap.getWidth(); int height = mBitmap.getHeight(); setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height);&#125; 主要就是当用户将控件的layout_with或者layout_heigt设置成wrap_content时，将宽高设置成图片的宽高。这块我们在上篇也已经讲过了，这里也就不再细讲了。不理解的同学自行翻看上一篇。 （4）、绘图最后一部分，到了正式绘图了：12345678910111213141516protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Matrix matrix = new Matrix(); float scale = (float) getWidth()/mBitmap.getWidth(); matrix.setScale(scale,scale); mBitmapShader.setLocalMatrix(matrix); mPaint.setShader(mBitmapShader); float half = getWidth()/2; if (mEnumFormat == 0)&#123; canvas.drawCircle(half,half,getWidth()/2,mPaint); &#125;else if(mEnumFormat == 1)&#123; canvas.drawRoundRect(new RectF(0,0,getWidth(),getHeight()),mRadius,mRadius,mPaint); &#125;&#125; 也没啥难度，就是先放大BitmapShader到与控件相同大小，然后根据用户要画的是圆形还是圆角矩形，调用不同的绘图函数即可。 （5）、XML中使用然后我们来看如何在布局中使用这个控件(main.xml)：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res/com.harvic.Blog_BitmapShader" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="50dp" android:layout_height="50dp" app:src="@drawable/avator" app:format="circle"/&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="100dp" android:layout_height="100dp" app:src="@drawable/avator" app:format="circle"/&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="100dp" android:layout_height="100dp" android:layout_marginTop="10dp" app:src="@drawable/avator" app:format="rectTangle" app:radius="10"/&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="130dp" android:layout_height="130dp" android:layout_marginTop="10dp" app:src="@drawable/avator" app:format="rectTangle" app:radius="30"/&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="150dp" android:layout_height="150dp" android:layout_marginTop="10dp" app:src="@drawable/avator" app:format="rectTangle" app:radius="70"/&gt;&lt;/LinearLayout&gt; 效果图就是如开篇所示，从布局代码中可以看到，我们已经实现了这个自定义控件，我们不仅可以指定大小，而且还可以使用wrap_content来自适应大小。我这里没有使用wrap_content的主要原因在于图片太大，使用wrap_content的话就画不了几张图了，大家底下自已试试吧 （6）、存在问题有些同学每次都是拿博主控件直接用到项目中，这可是不行的哦，因为博主在这里讲的自定义控件都是抛砖引玉的，主要核心在原理讲解，并没有做太多的容错的……这个控件也不例外，我们这里强制使用的正方的图像，当图像是矩形时，就会出现问题，大家需要自己做容错处理，判断图像的宽高，缩放图像以至在不改变图片比例的情况下，填充控件。这篇文章就到这了，下篇继续来看Shader的其它派生类的用法和实例。 五、LinearGradient与闪动文字效果这篇就给大家讲setShader的另一个参数，LinearGradient，使用过shape标签的同学，对这个方法估计都不莫生，就是线性渐变。跟PhotoShop中的线性渐变的原理和作用是一样的。这篇文章的最终会实现一个闪动文字效果控件： 一、引言标签的用法：12345678910&lt;gradient android:type=["linear" | "radial" | "sweep"] //共有3中渐变类型，线性渐变（默认）/放射渐变/扫描式渐变 android:angle="integer" //渐变角度，必须为45的倍数，0为从左到右，90为从上到下 android:centerX="float" //渐变中心X的相当位置，范围为0～1 android:centerY="float" //渐变中心Y的相当位置，范围为0～1 android:startColor="color" //渐变开始点的颜色 android:centerColor="color" //渐变中间点的颜色，在开始与结束点之间 android:endColor="color" //渐变结束点的颜色 android:gradientRadius="float" //渐变的半径，只有当渐变类型为radial时才能使用 android:useLevel=["true" | "false"] /&gt; //使用LevelListDrawable时就要设置为true。设为false时才有渐变效果 其中的渐变类型有”linear” | “radial” | “sweep”,在代码中对应的类分别是LinearGradient、RaialGradient、SweepGradient；有关各个渐变效果的用法，不知道的同学强烈建议你先看看这篇文章。这篇我们要讲就是线性渐变的LinearGradient； 二、LinearGradient基本使用1、构造函数我们先来看下LinearGradient的构造函数：第一个构造函数：public LinearGradient(float x0, float y0, float x1, float y1,int color0, int color1, TileMode tile)用过PhotoShop的线性激变工具的同学，应该都知道，线性渐变其实是在指定的两个点之间填充渐变颜色。 参数中的(x0,y0)就是起始渐变点坐标，参数中(x1,y1)就是结束渐变点坐标； color0就是起始颜色，color1就是终止颜色；颜色值必须使用0xAARRGGBB形式的16进制表示！表示透明度的AA一定不能少。 TileMode tile：与BitmapShader一样，用于指定控件区域大于指定的渐变区域时，空白区域的颜色填充方法。 很显然！这个方法，只能指定两种颜色之间的渐变。如果需要多种颜色之间的渐变，就需要使用下面的这个构造函数了。 第二个构造函数：public LinearGradient(float x0, float y0, float x1, float y1,int colors[], float positions[], TileMode tile)同样，(x0,y0)就是起始渐变点坐标，参数中(x1,y1)就是结束渐变点坐标colors[]用于指定渐变的颜色值数组，同样，颜色值必须使用0xAARRGGBB形式的16进制表示！表示透明度的AA一定不能少。positions[]与渐变的颜色相对应，取值是0-1的float类型，表示在每一个颜色在整条渐变线中的百分比位置 2、两色渐变使用示例我们先来看看两色渐变的构造函数是如何来使用的：1234567891011121314151617181920212223242526272829public class LinearGradientView extends View &#123; private Paint mPaint; public LinearGradientView(Context context) &#123; super(context); init(); &#125; public LinearGradientView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public LinearGradientView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setShader(new LinearGradient(0,getHeight()/2,getWidth(),getHeight()/2,0xffff0000,0xff00ff00, Shader.TileMode.CLAMP)); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint); &#125;&#125; 很简单，只需要在绘图的时候构造LinearGradient实例，通过Paint.setShader设置进去即可。大家注意一下，我这里设置的渐变范围是从控件的左边中点到右边中点：mPaint.setShader(new LinearGradient(0,getHeight()/2,getWidth(),getHeight()/2,0xffff0000,0xff00ff00, Shader.TileMode.CLAMP));最后通过canvas.drawRect把整个控件区域画出来：canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);这里大家注意一下，上面我们也已经提到了，颜色值必须使用0xAARRGGBB的完整16进制的颜色样式表示，我们这里的颜色值就是0xffff0000和0xff00ff00；大家自己可以进行尝试，如果把红色的透明度值去掉，改写成0xff00000，是不会有任何显示的。 3、多色渐变使用示例下面我们来看第二个构造函数，多色渐变的使用方法：12345678protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,getHeight()/2,getWidth(),getHeight()/2,colors,pos, Shader.TileMode.CLAMP); mPaint.setShader(multiGradient); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 从这里可以看出，渐变的开始点同样是控件左边中点，渐变的结束点也同样是控件右边中点；这里我们指定了五种渐变颜色，而且指定了每个颜色的位置，前四种颜色是按20%均匀分布的，最后两种颜色相距40%；最后通过canvas.drawRect把整个控件区域画出来 注意:colors和pos的个数一定要相等，也就是说必须指定每一个颜色值的位置！如果多或少都会直接报错：（Signal 11是SO内部错误） 4、渐变起始坐标与填充的关系——矩形填充我们上面的示例中都是从控件左边中间到控件右边中点；如果我们改成从左上角到右上角的填充方式，结果会怎样呢？12345678910111213141516171819202122232425262728293031323334353637383940protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,0,getWidth(),getHeight(),colors,pos, Shader.TileMode.CLAMP); mPaint.setShader(multiGradient); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125;``` 渐变线是从控件的左上角到控件的右下角位置：`LinearGradient multiGradient = new LinearGradient(0,0,getWidth(),getHeight(),colors,pos, Shader.TileMode.CLAMP);` 效果图： ![2017021914874880007490.png](http://ohtrrgyyd.bkt.clouddn.com/2017021914874880007490.png) 原理图： ![20170219148748802635587.png](http://ohtrrgyyd.bkt.clouddn.com/20170219148748802635587.png) 就是说，首先是两个渐变点之间连线，然后以连线为对角线形成一个矩形，各种颜色都是以这条对角线为矩形的填充的。##### 5、TileMode重复方式在讲到BitmapShader的时候，我们已经详细讲过TileMode的意义：当控件区域大小渐变区域时，用于填充空白位置的。 下面我们就逐个看一下TileMode不同时，对于线性渐变的有什么作用。 ###### （1）、X、Y轴共用填充参数 首先，我们再回来看一下LinearGradient的构造函数：`public LinearGradient(float x0, float y0, float x1, float y1,int colors[], float positions[], TileMode tile)` `public LinearGradient(float x0, float y0, float x1, float y1,int color0, int color1, TileMode tile)` 从构造函数中可以看出，LiearGradient只有一个TileMode参数，这说明X轴与Y轴共用这一个TileMode填充参数，而不能像BitmapShader那样分别指定X轴与Y轴的填充参数。 ###### （2）、TileMode.CLAMP``` javaprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas);//// 多色渐变 int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,0,getWidth()/2,getHeight()/2,colors,pos, Shader.TileMode.CLAMP); mPaint.setShader(multiGradient); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 这里做了一个多色渐变，渐变点是从(0,0)到屏幕的中间点(width/2,height.2)；效果图如下：从效果图中可以看到，效果很好理解，就是以(0,0)到(width/2,height.2)为矩形对角线，来填充各种颜色渐变，对于之外的区域，用边缘色彩来填充。 （3）、TileMode.REPEAT同样是上面的代码，渐变点是从(0,0)到屏幕的中间点(width/2,height.2)，当空白区域填充模式改为TileMode.REPEAT时，效果图如下：大家初次看到这个效果，可能一脸懵逼 —_—!!!, 其实也不难理解，我们需要先找到哪块是我们的渐变，哪块是空白像素的填充：在这个图中，蓝色块是我们原始的渐变图形，从从(0,0)到屏幕的中间点(width/2,height.2)，另外的没有遮起来的部分是空白位置填充的。在填充时，结束点做为填充点的起点，即填充的线性渐变的位置为从(width/2,height/2)到(width,height)，即从中间点到右下角点位置的填充。 （4）、TileMode.MIRROR同样，如果我们把填充模式改为镜像模式，效果图如下： 6、填充方式：从控件左上角开始填充与BitmapShader一样，同样是从控件左上角开始填充整个控件，利用canvas.drawXXX系列函数只是用来指定显示哪一块比如：123456789protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //多色渐变 int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,0,getWidth()/2,getHeight()/2,colors,pos, Shader.TileMode.MIRROR); mPaint.setShader(multiGradient); canvas.drawRect(100,100,200,200,mPaint); &#125; 同样是使用镜像模式，但我们不再全屏绘制，而只是绘出其中一小部分：我们再来看看全屏绘制的镜像模式的效果图：很明显，这里所绘制的一小块，跟从全屏绘制的效果图上摘下来的一块一样。 这就说明了：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块 我们说了如果利用drawXXX系列函数只是用来指定显示哪一块，那如果我们利用DrawText来显示，那是不是就会显示出彩色文字了？12345678910protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //多色渐变 int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,0,getWidth()/2,getHeight()/2,colors,pos, Shader.TileMode.MIRROR); mPaint.setShader(multiGradient); mPaint.setTextSize(50); canvas.drawText("欢迎关注启舰的blog",0,200,mPaint);&#125; 有没有感觉很酷炫……看似牛逼的效果其实就是这么简单……如果我们把渐变效果移动起来，就直接实现了我们开篇时说的文字渐变的动画效果了。下面我们加入动画，让颜色动起来吧 三、闪光字符串实现这部分我们要实现的效果图如下： 闪光效果有木有……看起来很碉堡吧，我们就来具体看下原理吧，这个控件只给大家讲基本原理，就不再封装成控件了。我们先来看下原理图： 1、原理（1）、初始状态首先，我们要有一个渐变的LinearGradient,颜色是从文字颜色的黑色到中间的绿色，然后再到黑色，填充模式为 Shader.TileMode.CLAMP，初始的位置在文字的左侧；对应图像为： 我这里为了表述文字效果，特地做了几个处理； 首先我把渐变图像用红边框了起来。由于填充模式是Shader.TileMode.CLAMP，所以右侧文字的位置会被填充为边缘颜色黑色 为了表述当前文字的位置，我特地把文字写成了红色。而文字真正的颜色应该是其底部LinearGradient的填充色才对的，大家这点注意。对应代码为：12345678910mLinearGradient = new LinearGradient(- getMeasuredWidth(),0,0,0,new int[]&#123; getCurrentTextColor(),0xff00ff00,getCurrentTextColor()&#125;, new float[]&#123; 0, 0.5f, 1 &#125;, Shader.TileMode.CLAMP );&#125; （2）、运动中下图显示的是当渐变的LinearGradient移动到文字部分的时的状态由于使用的是Shader.TileMode.CLAMP填充模式，所以两次空白区域都会被填充为LinearGradient的边缘颜色，即文字的黑色。上面我们讲了，文字会显示其下方LinearGradient的填充颜色，所以现在文字的文字就会有一部分变绿了。 （3）、终止状态在终止状态时，LinearGradient移动到文字的右侧同样是由于Shader.TileMode.CLAMP填充模式，文字会被填充为文字原本的颜色。 从上面的原理中，我们需要理出来几个点：第一：创建的LinearGradient渐变的构造方法，前面已经列出来代码了，初始位置是在文字左侧的，而且大小与文字所占位置相同，填充模式使用边缘填充第二：从起始位置和终止位置可以看出，LinearGradient渐变的运动长度是两个文字的长度。 2、代码实现其实看了原理之后，实现起来就没有什么难度了，我们还是列出完整代码，然后针对性的讲一点就可以了，如果大家还没看懂，可以把示例源码下下来，自己再研究研究123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ShimmerTextView extends TextView &#123; private Paint mPaint; private int mDx; private LinearGradient mLinearGradient; public ShimmerTextView(Context context) &#123; super(context); init(); &#125; public ShimmerTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ShimmerTextView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; mPaint =getPaint(); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); ValueAnimator animator = ValueAnimator.ofInt(0,2*getMeasuredWidth()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mDx = (Integer) animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.setRepeatMode(ValueAnimator.RESTART); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setDuration(2000); animator.start(); mLinearGradient = new LinearGradient(- getMeasuredWidth(),0,0,0,new int[]&#123; getCurrentTextColor(),0xff00ff00,getCurrentTextColor() &#125;, new float[]&#123; 0, 0.5f, 1 &#125;, Shader.TileMode.CLAMP ); &#125; @Override protected void onDraw(Canvas canvas) &#123; Matrix matrix = new Matrix(); matrix.setTranslate(mDx,0); mLinearGradient.setLocalMatrix(matrix); mPaint.setShader(mLinearGradient); super.onDraw(canvas); &#125;&#125; 1、派生自TextView首先需要注意的是，控件派生自TextView，所以可以使用TextView的自带方法getCurrentTextColor()来获取文字颜色。 2、如何移动LinearGradient然后，上面我们讲了如何给文字加上渐变效果，其实让它动起来办法很简单，还记得我们说过Shader有一个setLocalMatrix(Matrix localM) 方法可以设置位置矩阵么，我们只需要给LinearGradient设置上逐渐平移的矩阵就可以了。比如：1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; Matrix matrix = new Matrix(); matrix.setTranslate(mDx,0); mLinearGradient.setLocalMatrix(matrix); mPaint.setShader(mLinearGradient); super.onDraw(canvas);&#125; 其中向右偏移的距离mDx，是由ValueAnimator生成的； 3、ValueAnimator的创建前面我们讲了LinearGradient移动距离是从0到两倍的text距离，我们通过getMeasuredWidth()可以得到TextView的宽度，乘以2就可以了，创建代码如下：123456789101112ValueAnimator animator = ValueAnimator.ofInt(0,2*getMeasuredWidth());animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mDx = (Integer) animation.getAnimatedValue(); postInvalidate(); &#125;&#125;);animator.setRepeatMode(ValueAnimator.RESTART);animator.setRepeatCount(ValueAnimator.INFINITE);animator.setDuration(2000);animator.start(); 六、RadialGradient与水波纹按钮效果这篇将是Shader的最后一篇，下部分，我们将讲述Canvas变换的知识。在讲完Canvas变换以后，就正式进入第三部曲啦，是不是有点小激动呢…… 今天给大家讲的效果是使用RadialGradient来实现水波纹按钮效果，水波纹效果是Android L平台上自带的效果，这里我们就看看它是如何实现的，本篇的最终效果图如下 一、RadialGradient详解RadialGradient的意思是放射渐变，即它会向一个放射源一样，从一个点开始向外从一个颜色渐变成另一种颜色； 1、构造函数RadialGradient有两个构造函数1234//两色渐变RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode)//多色渐变RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode) （1）、两色渐变构造函数使用实例下面我们来看一下两色渐变构造函数的使用方法。RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode)这个两色渐变的构造函数的各项参数意义如下： centerX：渐变中心点X坐标 centerY：渐变中心点Y坐标 radius：渐变半径 centerColor：渐变的起始颜色，即渐变中心点的颜色,取值类型必须是八位的0xAARRGGBB色值！透明底Alpha值不能省略，不然不会显示出颜色。 edgeColor：渐变结束时的颜色，即渐变圆边缘的颜色，同样，取值类型必须是八位的0xAARRGGBB色值！ TileMode：与我们前面讲的各个Shader一样，用于指定当控件区域大于指定的渐变区域时，空白区域的颜色填充方式。 下面我们举个例子来看下用法： 123456789101112131415161718192021222324252627282930313233343536373839public class DoubleColorRadialGradientView extends View &#123; private Paint mPaint; private RadialGradient mRadialGradient; private int mRadius = 100; public DoubleColorRadialGradientView(Context context) &#123; super(context); init(); &#125; public DoubleColorRadialGradientView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public DoubleColorRadialGradientView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.REPEAT); mPaint.setShader(mRadialGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(getWidth()/2,getHeight()/2,mRadius,mPaint); &#125;&#125; 代码量不大，这里首先在onSizeChange中，创建RadialGradient实例。onSizeChange会在布局发生改变时调用，onSizeChanged(int w, int h, int oldw, int oldh)传过来四个参数，前两个参数就代表当前控件所应显示的宽和高。有关onSizeChange的具体意义，我们会在第三部曲讲解回调函数流程中具体讲到，这里大家就先理解到这吧。在onSizeChange中，我们创建了一个RadialGradient，以控件的中心点为圆点，创建一个半径为mRadius的，从0xffff0000到0xff00ff00的放射渐变。我们这里指定的空白填充方式为Shader.TileMode.REPEAT。然后在绘图的时候： 1234protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(getWidth()/2,getHeight()/2,mRadius,mPaint);&#125; 在绘图时，依然是以控件中心点为圆心，画一个半径为mRadius的圆；注意我们画的圆的大小与所构造的放射渐变的大小是一样的，所以不存在空白区域的填充问题。 效果图如下： （2）、多色渐变构造函数使用实例多色渐变的构造函数如下：RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode) 这里与两色渐变不同的是两个函数： int[] colors：表示所需要的渐变颜色数组 float[] stops：表示每个渐变颜色所在的位置百分点，取值0-1，数量必须与colors数组保持一致，不然直接crash,一般第一个数值取0，最后一个数值取1；如果第一个数值和最后一个数值并没有取0和1，比如我们这里取一个位置数组：{0.2,0.5,0.8}，起始点是0.2百分比位置，结束点是0.8百分比位置，而0-0.2百分比位置和0.8-1.0百分比的位置都是没有指定颜色的。而这些位置的颜色就是根据我们指定的TileMode空白区域填充模式来自行填充！！！有时效果我们是不可控的。所以为了方便起见，建议大家stop数组的起始和终止数值设为0和1. 下面我们举个例子来看下用法：1234567891011121314151617181920212223242526272829303132333435363738394041public class MultiColorRadialGradientView extends View &#123; private Paint mPaint; private RadialGradient mRadialGradient; private int mRadius = 100; public MultiColorRadialGradientView(Context context) &#123; super(context); init(); &#125; public MultiColorRadialGradientView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public MultiColorRadialGradientView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); int[] colors = new int[]&#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00&#125;; float[] stops = new float[]&#123;0f,0.2f,0.5f,1f&#125;; mRadialGradient = new RadialGradient(w/2,h/2,mRadius,colors,stops, Shader.TileMode.REPEAT); mPaint.setShader(mRadialGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(getWidth()/2,getHeight()/2,mRadius,mPaint); &#125;&#125; 这里主要看下多色渐变的构造方法：123int[] colors = new int[]&#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00&#125;;float[] stops = new float[]&#123;0f,0.2f,0.5f,1f&#125;;mRadialGradient = new RadialGradient(w/2,h/2,mRadius,colors,stops, Shader.TileMode.REPEAT); 这里构造了一个四色颜色数组，渐变位置对应{0f,0.2f,0.5f,1f}，然后创建RadialGradient实例。没什么难度。然后在绘画的时候，同样以控件中心为半径，以放射渐变的半径为半径画圆。由于画的圆半径与放射渐变的大小相同，所以不存在空白位置填充的问题，所以TileMode.REPEAT并没有用到。 1、TileMode重复方式TileMode的问题，已经重复讲了几篇文章了，其实虽然每种Shader所表现出来的效果不一样，但是形成原理都是相同的。下面我们再来看一下RadialGradient在不同的TileMode下的具体表现。 （1）、X、Y轴共用填充参数与LinearGradient一样，从构造函数中，可以明显看出RadialGradient只有一个填充模式： 1234//两色渐变RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode)//多色渐变RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode) 这就说明了，当填充空白区域时，X轴和Y轴使用同一种填充模式。而不能像BitmapShader那样分别指定X轴与Y轴的填充参数。 （2）、TileMode.CLAMP——边缘填充我们依然使用双色渐变的示例来看下效果，为了显示填充效果，我们这次画一个屏幕大小的矩形：1234567891011121314@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 从效果图中可以明显看出，除了放渐渐变以外的空白区域都被边缘填充成为了绿色； （3）、TileMode.REPEAT——重复填充我们仍使用上面的代码，只是将填充模式改为重复填充：123456789101112protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.REPEAT); mPaint.setShader(mRadialGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 这个图像乍看去有点辣眼睛，花花绿绿的……从效果图中可以看出，最内部的圆形是红到绿的原始放射渐变。其外面的圆就是空白区域填充模式了，在它的外围，从红到绿渐变。 （4）、TileMode.MIRROR—镜像填充同样是使用上面的代码，只是将填充模式改为镜像填充：12345678910111213protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.MIRROR); mPaint.setShader(mRadialGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 有些同学第一下看到这个图可能有点懵，所谓镜像，就是把原来的颜色的倒过来填充。即原始是红到绿渐变，第二圈就变成了绿到红渐变，第三圈就又是红到绿渐变，如此往复。如果我把每一圈渐变的界限标出来，大家可能就容易看懂了： 图中白色线就是每一圈渐变的边界线，一次完整的填充就是两个白色圈中的部分。 （5）、填充方式：从控件左上角开始填充在讲BitmapShader和LinearShader时，我们就一再强调一个点：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块；我们在RadialGradient中也做下测试： 1234567891011121314@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.REPEAT); mPaint.setShader(mRadialGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0,0,200,200,mPaint);&#125; 我们这里使用TileMode.REPEAT来填充空白区域，在绘图时，我们只画出左上角的一部分；效果图如下： 从效果图中明显可以看出结论了：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块 二、水波纹按钮效果这部分就要利用RadialGradient来实现水波纹效果了，我们这里直接继承自Button类，做一个按钮的水波纹效果，其实这里继承自任何一个类都是可以在这个类原本的显示内容上显示水波纹效果的，比如，大家可以试验下在源码的基础上，将其改为派生自ImageView，当然要记得给它添加上src属性，是一样会有水波纹效果的。 1、概述根据上面的的对RadialGradient的讲解，大家第一反应应该是，水波纹很好实现啊：不就是，画一个带有渐变效果的逐渐放大的圆不就得了。不错，思想确实就是这么简单。 （1）、不过，第一个问题来了，从哪个颜色，渐变到哪个颜色呢？最理想的状态是，从按钮的背景色渐变到天蓝色（开篇效果图中颜色）。但是，怎么拿到按钮的背景色呢？因为按钮的android:background属性填充不一定是颜色，有可能是一个drawable，而这个drawable可以是图片，也可能是selector文件等，所以这条路根本走不通。而我们讲过，RadialGradient中填充的渐变色彩必须是AARRGGBB形式的，所以我们只需要讲初始颜色的透明度设为0，不就露出了按钮的背景色了么。即类似下面的代码：mRadialGradient = new RadialGradient(x, y,20 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); 在这里我们将初始的渐变色改为0x00FFFFFF，由于透明度部分全部设置为0，所以整个颜色就是透明的。所以整个渐变过程就变为从零透明度逐渐变为纯天蓝色（0xFF58FAAC）。 （2）、第二个问题，我们应该怎么安排RadialGradient的填充模式从效果图中是可以明显看出我们会逐渐放大绘制RadialGradient的圆的，那么，我们是让RadialGradient的渐变变径随着绘制的圆增大而增大，还是不改变RadialGradient的初始半径，空余部分使用Shader.TileMode.CLAMP填充来实现水波纹呢。 答案是让RadialGradient的渐变变径随着绘制的圆增大而增大；下面我们分别举个例子来看下效果就知道区别了： 我们将RadialGradient的初始半径设置为20，而假设当前绘制圆的半径是150，分别用模拟代码来展示在不同代码处理下的效果，以最终决定选用哪种方式来绘制RadialGradient渐变。 如果使用空余部分使用Shader.TileMode.CLAMP填充 123456789101112@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mRadialGradient == null) &#123; int x = getWidth()/2; int y = getHeight()/2; mRadialGradient = new RadialGradient(x, y,20 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); canvas.drawCircle(x, y, 150, mPaint); &#125;&#125; 这里以控件中心为圆心，构造一个RadialGradient，这个RadialGradient的半径是20，从透明色，渐变到天蓝色mRadialGradient = new RadialGradient(x, y,20 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP);而在canvas画圆时，仍然以控件中心为圆心，但圆的半径却是150，明显要超出RadialGradient的半径，空白部分使用Shader.TileMode.CLAMP边缘模式填充canvas.drawCircle(x, y, 150, mPaint);从效果图中可以看出，在0-20的部分是从透明色到天蓝色的渐变，但是超出半径20的部分，都以边缘模式填充为完全不透明的天蓝色，感觉跟按钮完全没有融合在一起有没有如果让RadialGradient的渐变变径随着绘制的圆增大而增大1234567891011protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mRadialGradient == null) &#123; int x = getWidth()/2; int y = getHeight()/2; mRadialGradient = new RadialGradient(x, y,150 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); canvas.drawCircle(x, y, 150, mPaint); &#125;&#125; 这里的代码跟上面的一样，唯一不同的是，构造的RadialGradient的渐变半径与canvas.drawCircle所画的圆的半径是一样的，都是150；这就演示了让RadialGradient的渐变变径随着绘制的圆增大而增大的效果很明显，这是我们想要的结果，渐变色与按钮的背景完全融合。 2、代码实现上面在讲解了解决了核心问题，以后，下面我们就开始正式实战了从效果图中，可以看到我们所需要完成的功能： 在手指按下时，绘制一个默认大小的圆 在手指移动时，所绘制的默认圆的位置需要跟随手指移动 在手指放开时，圆逐渐变大 在动画结束时，波纹效果消失 按下和移动首先，我们来完成前两个功能：当首先按下时，绘制一个默认大小的圆，而且当手指移动时，可以跟随移动：123456789101112131415private int mX, mY;private int DEFAULT_RADIUS = 50;public boolean onTouchEvent(MotionEvent event) &#123; if (mX != event.getX() || mY != mY) &#123; mX = (int) event.getX(); mY = (int) event.getY(); setRadius(DEFAULT_RADIUS); &#125; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; return true; &#125; return super.onTouchEvent(event);&#125; 首先，我们这里并没区分MotionEvent.ACTION_DOWN和MotionEvent.ACTION_UP的绘图操作，只是统一在当前手指位置与上次的不一样时，就调用setRadius(DEFAULT_RADIUS);重绘RadialGradient；很明显，mX、mY变量表示当前手指的位置，而DEFAULT_RADIUS变量表示默认的RadialGradient的渐变尺寸。但是必须在 MotionEvent.ACTION_DOWN时return true，因为如果不return true，就表示当前控件并不需要下按之后的消息，所以ACTION_MOVE、ACTION_UP消息都不会再传到这个控件里来了，有关这个问题，在前面的文章中已经不只一次提到，这里就不再缀述了。 其中，setRadius(DEFAULT_RADIUS)函数的定义如下：1234567891011121314151617//表示当前渐变半径private int mCurRadius = 0;public void setRadius(final int radius) &#123; mCurRadius = radius; if (mCurRadius &gt; 0) &#123; mRadialGradient = new RadialGradient(mX, mY, mCurRadius, 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); &#125; postInvalidate();&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mX, mY, mCurRadius, mPaint);&#125; 在setRadius中主要负责在手指位置和渐变半径改变时，重新创建RadialGradient，然后重绘。很明显mCurRadius变量表示当前的渐变半径。最后在OnDraw函数中重绘时，画一个跟渐变半径同样大小的圆即可。 手指放开在手指放开时，主要是开始逐渐放大放射半径的动画，然后在动画结束的时候，清除RadialGradient。代码如下：1234567891011121314151617181920212223242526272829303132333435363738private ObjectAnimator mAnimator;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; ………… f (event.getAction() == MotionEvent.ACTION_UP) &#123; if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel(); &#125; if (mAnimator == null) &#123; mAnimator = ObjectAnimator.ofInt(this,"radius",DEFAULT_RADIUS, getWidth()); &#125; mAnimator.setInterpolator(new AccelerateInterpolator()); mAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; setRadius(0); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mAnimator.start(); &#125; return super.onTouchEvent(event);&#125; 在这段代码中，首先是在开始下一个动画前，先判断当前mAnimator是不是还在动画中，如果是正在动画就先取消: 123if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel();&#125; 这是为了避免当用户连续点击多次的时候，下一次开始动画时，上一次动画还没结束，这样两次动画就会造成冲突，应该先把上次的动画取消掉，然后再重新开始这次的动画：123mAnimator = ObjectAnimator.ofInt(this,"radius",DEFAULT_RADIUS, getWidth());&#125;mAnimator.setInterpolator(new AccelerateInterpolator()); 然后创建一个ObjectAnimator对象，这里动画操作的函数是setRadius(final int radius)函数，动画的区间是从默认半径到整个控件的宽度，之所以用当前控件的宽度来做为最大动画值，是因为，我们必须指定一个足够大的值，足以让波纹能够覆盖整个控件以后再结束。从效果图中可以看出，在这里控件的宽度是整个控件长度的最大值，所以，我们就以用户点击控件最边缘来算，当用户点击最左或最右边缘时，整个RadialGradient的半径是最大的，此时的最大值是控件宽度，所以我们就用控件宽度来做为动画的最大值即可。 其实这里还是不够严谨，因为在实际应用中，控件的宽度并不是整个控件的最大值，也有可能是控件的高度是最大的，所以最严谨的做法就是先判断控件的高度和宽度哪个最大，然后将最大值做为动画的半径。这里为了简化代码可读性，就不再对比了。 然后给mAnimator设置AccelerateInterpolator()插值器，因为我们需要让波纹的速度逐渐加快，如果不设置插值器的话，默认是使用LinearInterpolator插值器的，这样出来的效果是波纹的变大速度将是匀速的。mAnimator.setInterpolator(new AccelerateInterpolator());最后我们需要监听mAnimator结束的动作，当动画结束时，我们需要让RadialGradient消失，最简单的消失办法就是将所画圆的半径设置为0。12345678mAnimator.addListener(new Animator.AnimatorListener() &#123; ………… @Override public void onAnimationEnd(Animator animation) &#123; setRadius(0); &#125; …………&#125;); 到这里所有的代码就讲完了，完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class RippleView extends Button &#123; private int mX, mY; private ObjectAnimator mAnimator; private int DEFAULT_RADIUS = 50; private int mCurRadius = 0; private RadialGradient mRadialGradient; private Paint mPaint; public RippleView(Context context) &#123; super(context); init(); &#125; public RippleView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public RippleView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (mX != event.getX() || mY != mY) &#123; mX = (int) event.getX(); mY = (int) event.getY(); setRadius(DEFAULT_RADIUS); &#125; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; return true; &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123; if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel(); &#125; if (mAnimator == null) &#123; mAnimator = ObjectAnimator.ofInt(this,"radius",DEFAULT_RADIUS, getWidth()); &#125; mAnimator.setInterpolator(new AccelerateInterpolator()); mAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; setRadius(0); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mAnimator.start(); &#125; return super.onTouchEvent(event); &#125; public void setRadius(final int radius) &#123; mCurRadius = radius; if (mCurRadius &gt; 0) &#123; mRadialGradient = new RadialGradient(mX, mY, mCurRadius, 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); &#125; postInvalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mX, mY, mCurRadius, mPaint); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义控件——动画]]></title>
      <url>%2F2015%2F11%2F10%2Fandroid-animation%2F</url>
      <content type="text"><![CDATA[前言学习Android最重要的就是自定义控件了，好看的人性化的控件总是能抓住客户以及使用者的心，所以从网上学习了部分知识，以及通过自己的实践，总结了自定义控件的学习。在Android动画中，总共有两种类型的动画View Animation(视图动画)和Property Animator(属性动画)。其中： View Animation包括Tween Animation（补间动画）和Frame Animation(逐帧动画); Property Animator包括ValueAnimator和ObjectAnimation； alpha、scale、translate、rotate属于Tween Animation。 不同之处： 引入时间不同：View Animation是API Level 1就引入的。Property Animation是API Level 11引入的，即Android 3.0才开始有Property Animation相关的API。 所在包名不同：View Animation在包android.view.animation中。而Property Animation API在包 android.animation中。 动画类的命名不同：View Animation中动画类取名都叫XXXXAnimation,而在Property Animator中动画类的取名则叫XXXXAnimator 一、alpha、scale、translate、rotate、set(Tween Animation)的xml属性及用法一、概述alpha：渐变透明度动画效果scale：渐变尺寸伸缩动画效果translate：画面转换位置移动动画效果rotate：画面转移旋转动画效果 动作定义的动画文件应当放在res/anim文件夹下，采用R.anim.XXX.xml方式进行访问。 二、scale标签——调节尺寸scale是缩放动画 1、自身属性 android:fromXScale //起始的X方向上相对自身的缩放比例，浮点值，比如1.0代表自身无变化，0.5代表起始时缩小一倍，2.0代表放大一倍; android:toXScale //结尾的X方向上相对自身的缩放比例，浮点值; android:fromYScale //起始的Y方向上相对自身的缩放比例，浮点值; android:toYScale //结尾的Y方向上相对自身的缩放比例，浮点值; android:pivotX //缩放起点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p，当为数值时，表示在当前View的左上角，即原点处加上50px，做为起始缩放点；如果是50%，表示在当前控件的左上角加上自己宽度的50%做为起始点；如果是50%p，那么就是表示在当前的左上角加上父控件宽度的50%做为起始点x轴坐标。 android:pivotY //缩放起点Y轴坐标，取值及意义跟android:pivotX一样。 2、从Animation类继承的属性 android:duration //动画持续时间，以毫秒为单位 android:fillAfte //如果设置为true，控件动画结束时，将保持动画最后时的状态 android:fillBefore //如果设置为true,控件动画结束时，还原到开始动画前的状态 android:fillEnabled //与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态 android:repeatCount //重复次数 android:repeatMode //重复类型，有reverse和restart两个值，reverse表示倒序回放，restart表示重新放一遍，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作. android:interpolator //设定插值器，其实就是指定的动作效果，比如弹跳效果等，不在这小节中讲解，后面会单独列出一单讲解。 三、alpha标签——调节透明度1、自身属性 android:fromAlpha //动画开始的透明度，从0.0 –1.0 ，0.0表示全透明，1.0表示完全不透明 android:toAlpha //动画结束时的透明度，也是从0.0 –1.0 ，0.0表示全透明，1.0表示完全不透明 四、rotate标签——旋转1、自身属性 android:fromDegrees //开始旋转的角度位置，正值代表顺时针方向度数，负值代码逆时针方向度数 android:toDegrees //结束时旋转到的角度位置，正值代表顺时针方向度数，负值代码逆时针方向度数 android:pivotX //放起点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p. android:pivotY //缩放起点Y轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p 五、translate标签 —— 平移1、自身属性 android:fromXDelta //起始点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p android:fromYDelta //起始点Y轴坐标，可以是数值、百分数、百分数p 三种样式 android:toXDelta //结束点X轴坐标 android:toYDelta //结束点Y轴坐标 六、set标签——定义动作合集set标签自已是没有属性的，他的属性都是从Animation继承而来，但当它们用于Set标签时，就会对Set标签下的所有子控件都产生作用。 七、示例123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="3000" android:fillAfter="true"&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0"/&gt; &lt;scale android:fromXScale="0.0" android:toXScale="1.4" android:fromYScale="0.0" android:toYScale="1.4" android:pivotX="50%" android:pivotY="50%"/&gt; &lt;rotate android:fromDegrees="0" android:toDegrees="720" android:pivotX="50%" android:pivotY="50%"/&gt; &lt;/set&gt; 八、使用Animation 通过scaleAnimation = AnimationUtils.loadAnimation(this, R.anim.scaleanim);从XML文件中获取动画 利用startAnimation(animation);将动画传递给指定控件显示。 二、Interpolator插值器一、概述Interpolator属性是Animation类的一个XML属性，所以alpha、scale、rotate、translate、set都会继承得到这个属性。Interpolator被译为插值器，指定动画如何变化，跟PS里的动作有点类似：随便拿来一张图片，应用一个动作，图片就会指定变化。 Interpolator的系统值有下面几个： AccelerateDecelerateInterpolator //在动画开始与介绍的地方速率改变比较慢，在中间的时候加速 AccelerateInterpolator //在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator //开始的时候向后然后向前甩 AnticipateOvershootInterpolator //开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator //动画结束的时候弹起 CycleInterpolator //动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator //在动画开始的地方快然后慢 LinearInterpolator //以常量速率改变 OvershootInterpolator //向前甩一定值后再回到原来位置 三、用代码实现Animation1.Animation类是所有动画的基类，它所具有的标签对应的函数： android:duration —— setDuration(long) //动画持续时间，以毫秒为单位 android:fillAfter —— setFillAfter(boolean) //如果设置为true，控件动画结束时，将保持动画最后时的状态 android:fillBefore —— setFillBefore(boolean) //如果设置为true,控件动画结束时，还原到开始动画前的状态 android:fillEnabled —— setFillEnabled(boolean) //与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态 android:repeatCount —— setRepeatCount(int) //重复次数 android:repeatMode —— setRepeatMode(int) //重复类型，有reverse和restart两个值，取值为RESTART或 REVERSE，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。 android:interpolator —— setInterpolator(Interpolator) //设定插值器，其实就是指定的动作效果，比如弹跳效果等 2.ScaleAnimation这是scale标签对应的类 构造函数： ScaleAnimation(Context context, AttributeSet attrs) //从XML文件加载动画，基本用不到 ScaleAnimation(float fromX, float toX, float fromY, float toY) ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY) ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 第一个构造函数是从本地XML文件加载动画，基本用不到的，我们主要看下面三个构造函数.在标签属性android:pivotX中有三种取值，数，百分数，百分数p；体现在构造函数中，就是最后一个构造函数的pivotXType,它的取值有三个，Animation.ABSOLUTE、Animation.RELATIVE_TO_SELF和Animation.RELATIVE_TO_PARENT； 示例：构造的XML代码： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:fromXScale="0.0" android:toXScale="1.4" android:fromYScale="0.0" android:toYScale="1.4" android:pivotX="50" android:pivotY="50" android:duration="700" /&gt; 对应的代码为： 12scaleAnim = new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f); scaleAnim.setDuration(700); 3. AlphaAnimation这是alpha标签对应的类 构造函数： AlphaAnimation(Context context, AttributeSet attrs) //同样，从本地XML加载动画，基本不用 AlphaAnimation(float fromAlpha, float toAlpha) 示例：构造的XML代码： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;alpha xmlns:android="http://schemas.android.com/apk/res/android" android:fromAlpha="1.0" android:toAlpha="0.1" android:duration="3000" android:fillBefore="true"&gt; &lt;/alpha&gt; 对应的代码为： 123alphaAnim = new AlphaAnimation(1.0f,0.1f); alphaAnim.setDuration(3000); alphaAnim.setFillBefore(true); 4. RotateAnimationRotateAnimation类对应Rotate标签 构造函数： RotateAnimation(Context context, AttributeSet attrs) //从本地XML文档加载动画，同样，基本不用 RotateAnimation(float fromDegrees, float toDegrees) RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY) RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 示例：构造的XML代码： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" android:fromDegrees="0" android:toDegrees="-650" android:pivotX="50%" android:pivotY="50%" android:duration="3000" android:fillAfter="true"&gt; &lt;/rotate&gt; 对应的代码为： 123rotateAnim = new RotateAnimation(0, -650, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); rotateAnim.setDuration(3000); rotateAnim.setFillAfter(true); 5. TranslateAnimationTranslateAnimation类对应translate标签 构造函数： TranslateAnimation(Context context, AttributeSet attrs) //同样，基本不用 TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) //使用是绝对数值 TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue) //最理想的状态就是这个构造函数，能够指定每个值的类型。只有这个构造函数可以指定百分数和相对父控件的百分数。 示例：构造的XML代码： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;translate xmlns:android="http://schemas.android.com/apk/res/android" android:fromXDelta="0" android:toXDelta="-80" android:fromYDelta="0" android:toYDelta="-80" android:duration="2000" android:fillBefore="true"&gt; &lt;/translate&gt; 对应的代码为： 1234translateAnim = new TranslateAnimation(Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80, Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80); translateAnim.setDuration(2000); translateAnim.setFillBefore(true); 6. AnimationSetAnimationSet类对应set标签，定义动作类的集合 构造函数： AnimationSet(Context context, AttributeSet attrs) //同样，基本不用 AnimationSet(boolean shareInterpolator) //shareInterpolator取值true或false，取true时，指在AnimationSet中定义一个插值器（interpolater），它下面的所有动画共同。如果设为false，则表示它下面的动画自己定义各自的插值器。 增加动画函数public void addAnimation (Animation a) 示例：构造的XML代码： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="3000" android:fillAfter="true"&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0"/&gt; &lt;scale android:fromXScale="0.0" android:toXScale="1.4" android:fromYScale="0.0" android:toYScale="1.4" android:pivotX="50%" android:pivotY="50%"/&gt; &lt;rotate android:fromDegrees="0" android:toDegrees="720" android:pivotX="50%" android:pivotY="50%"/&gt; &lt;/set&gt; 对应的代码为： 1234567891011alphaAnim = new AlphaAnimation(1.0f,0.1f); scaleAnim = new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f); rotateAnim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); setAnim=new AnimationSet(true); setAnim.addAnimation(alphaAnim); setAnim.addAnimation(scaleAnim); setAnim.addAnimation(rotateAnim); setAnim.setDuration(3000); setAnim.setFillAfter(true); 7. Interpolater插值器代码使用方法： 123ScaleAnimation interpolateScaleAnim=new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f); interpolateScaleAnim.setInterpolator(new BounceInterpolator()); interpolateScaleAnim.setDuration(3000); 四、ValueAnimator基本使用一、概述1、为什么要引入Property Animator(属性动画)1、Property Animator能实现补间动画无法实现的功能 补间动画和逐帧动画统称为View Animation，也就是说这两个动画只能对派生自View的控件 实例起作用；而Property Animator则不同，从名字中可以看出属性动画，应该是作用于控件 属性的！正因为属性动画能够只针对控件的某一个属性来做动画，所以也就造就了他能单独改变 控件的某一个属性的值！比如颜色！这就是Property Animator能实现补间动画无法实现的功 能的最重要原因。 2、View Animation仅能对指定的控件做动画，而Property Animator是通过改变控件某一 属性值来做动画的。 假设我们将一个按钮从左上角利用补间动画将其移动到右下角，在移动过程中和移动后，这个按钮 都是不会响应点击事件的。这是为什么呢？因为补间动画仅仅转变的是控件的显示位置而已，并没 有改变控件本身的值。View Animation的动画实现是通过其Parent View实现的，在View被 drawn时Parents View改变它的绘制参数，这样虽然View的大小或旋转角度等改变了，但View 的实际属性没变，所以有效区域还是应用动画之前的区域；我们看到的效果仅仅是系统作用在按钮 上的显示效果，利用动画把按钮从原来的位置移到了右下角，但按钮内部的任何值是没有变化的， 所以按钮所捕捉的点击区域仍是原来的点击区域。 3、补间动画虽能对控件做动画，但并没有改变控件内部的属性值。而Property Animator则是 恰恰相反，Property Animator是通过改变控件内部的属性值来达到动画效果的 二、ValueAnimator简单使用1、初步使用ValueAnimator创建ValueAnimator实例 123ValueAnimator animator = ValueAnimator.ofInt(0,400); animator.setDuration(1000); animator.start(); 利用ValueAnimator.ofInt创建了一个值从0到400的动画，动画时长是1s，然后让动画开始。从这段代码中可以看出，ValueAnimator没有跟任何的控件相关联，那也正好说明ValueAnimator只是对值做动画运算，而不是针对控件的，我们需要监听ValueAnimator的动画过程来自己对控件做操作。 添加监听 123456789101112ValueAnimator animator = ValueAnimator.ofInt(0,400); animator.setDuration(1000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int curValue = (int)animation.getAnimatedValue(); Log.d("qijian","curValue:"+curValue); tv.layout(curValue,curValue,curValue+tv.getWidth(),curValue+tv.getHeight()); &#125; &#125;); animator.start(); 这就是ValueAnimator的功能：ValueAnimator对指定值区间做动画运算，我们通过对运算过程做监听来自己操作控件。 总结 ValueAnimator只负责对指定的数字区间进行动画运算 我们需要对运算过程进行监听，然后自己对控件做动画操作 2、常用函数 ValueAnimator setDuration(long duration) //设置一次动画的时长，单位是毫秒 void start() //开始动画 Object getAnimatedValue(); //获取动画在当前运动点的值，所以这个对象只能用于在动画运动中。返回的值是Object,上面我们说过，通过getAnimatedValue()得到的值的实际类型与初始设置的值相同，如果我们利用ofInt（）设置的动画，那通过getAnimatedValue()得到的值为类型就是Int类型。如果我们利用ofFloat（）设置的动画，通过getAnimatedValue()得到的值类型就是Float类型。 void setRepeatCount(int value) //设置循环次数,设置为INFINITE表示无限循环 setRepeatMode(int value) //设置循环模式,value取值有RESTART，REVERSE cancel() //取消动画 3、监听器 AnimatorUpdateListener就是监听动画的实时变化状态，在onAnimationUpdate(ValueAnimator animation)中的animation表示当前状态动画的实例。添加AnimatorUpdateListener的方法是addUpdateListener(AnimatorListener listener)。 在AnimatorListener中，主要是监听Animation的四个状态，start、end、cancel、repeat；当动画开始时，会调用onAnimationStart(Animator animation)方法，当动画结束时调用onAnimationEnd(Animator animation)，当动画取消时，调用onAnimationCancel(Animator animation)函数，当动画重复时，会调用onAnimationRepeat(Animator animation)函数。添加AnimatorListener的方法是addListener(AnimatorListener listener)。 void removeUpdateListener(AnimatorUpdateListener listener); //移除AnimatorUpdateListener void removeAllUpdateListeners(); //移除AnimatorUpdateListener void removeListener(AnimatorListener listener); //用于在animator中移除指定的监听器 void removeAllListeners(); //用于移除animator中所有的AnimatorListener监听器 4、其他函数 public void setStartDelay(long startDelay); //延时多久时间开始，单位是毫秒 public ValueAnimator clone(); //完全克隆一个ValueAnimator实例，包括它所有的设置以及所有对监听器代码的处理 5、插值器控制动画的加速变化animator.setInterpolator(new BounceInterpolator()); //简单使用 6、自定义插值器123456789101112131415public class LinearInterpolator implements TimeInterpolator &#123; public LinearInterpolator() &#123; &#125; public LinearInterpolator(Context context, AttributeSet attrs) &#123; &#125; /** *主要重写该方法，对动画的进度从0到1进行调节 **/ public float getInterpolation(float input) &#123; return input; &#125;&#125; 7、Evaluator 这幅图讲述了从定义动画的数字区间到通过AnimatorUpdateListener中得到当前动画所对应数值的整个过程。下面我们对这四个步骤具体讲解一下：(1)、ofInt(0,400)表示指定动画的数字区间，是从0运动到400；(2)、加速器：上面我们讲了，在动画开始后，通过加速器会返回当前动画进度所对应的数字进度，但这个数字进度是百分制的，以小数表示，如0.2(3)、Evaluator:我们知道我们通过监听器拿到的是当前动画所对应的具体数值，而不是百分制的进度。那么就必须有一个地方会根据当前的数字进度，将其转化为对应的数值，这个地方就是Evaluator；Evaluator就是将从加速器返回的数字进度转成对应的数字值。所以上部分中，我们讲到的公式： 当前的值 = 100 + （400 - 100）* 显示进度这个公式就是在Evaluator计算的；在拿到当前数字进度所对应的值以后，将其返回（4）、监听器：我们通过在AnimatorUpdateListener监听器使用animation.getAnimatedValue()函数拿到Evaluator中返回的数字值。 ofInt和ofFloat都是系统直接提供的函数，所以在使用时都会有默认的加速器和Evaluator来使用的，不指定则使用默认的；对于Evaluator而言，ofInt()的默认Evaluator当然是IntEvaluator;而FloatEvalutar默认的则是FloatEvalutor; Evalutor一般来讲不能通用，会报强转错误，也就是说，只有在数值类型相同的情况下，Evalutor才能共用。Evaluator其实就是一个转换器，他能把小数进度转换成对应的数值位置 8、自定义Evaluator1234567public class MyEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; @Override public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(200+startInt + fraction * (endValue - startInt)); &#125;&#125; 我们可以通过重写加速器改变数值进度来改变数值位置，也可以通过改变Evaluator中进度所对应的数值来改变数值位置。 9、ArgbEvalutorArgbEvalutor是用来做颜色值过渡转换的。 123ValueAnimator animator = ValueAnimator.ofInt(0xffffff00,0xff0000ff);animator.setEvaluator(new ArgbEvaluator());animator.setDuration(3000); 10、ofInt(),ofFloat(),ofObject()ofInt()只能传入Integer类型的值,而ofFloat（）则只能传入Float类型的值,ofObject(),可以传进去任何类型的变量. ofObject()示例1、简单示例 123456789101112ValueAnimator animator = ValueAnimator.ofObject(new CharEvaluator(),new Character('A'),new Character('Z')); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; char text = (char)animation.getAnimatedValue(); tv.setText(String.valueOf(text)); &#125; &#125;); animator.setDuration(10000); animator.setInterpolator(new AccelerateInterpolator()); animator.start(); 2、自定义示例 在这里，我们自定义了一个View，在这个view上画一个圆，但这个圆是有动画效果的。从效果中可以看出使用的插值器应该是回弹插值器(BounceInterpolator)。下面就来看看这个动画是怎么做出来的。 首先，我们自定义一个类Point 123456789101112131415public class Point &#123; private int radius; public Point(int radius)&#123; this.radius = radius; &#125; public int getRadius() &#123; return radius; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; &#125; 然后我们自定义一个View:MyPointView 1234567891011121314151617181920212223242526272829303132public class MyPointView extends View &#123; private Point mCurPoint; public MyPointView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mCurPoint != null)&#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setColor(Color.RED); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(300,300,mCurPoint.getRadius(),paint); &#125; &#125; public void doPointAnim()&#123; ValueAnimator animator = ValueAnimator.ofObject(new PointEvaluator(),new Point(20),new Point(200)); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCurPoint = (Point)animation.getAnimatedValue(); invalidate(); &#125; &#125;); animator.setDuration(1000); animator.setInterpolator(new BounceInterpolator()); animator.start(); &#125; &#125; 在布局中添加入自定义View，然后在主界面中调用 1234567891011121314151617181920public class MyActivity extends Activity &#123; private Button btnStart; private MyPointView mPointView; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); btnStart = (Button) findViewById(R.id.btn); mPointView = (MyPointView)findViewById(R.id.pointview); btnStart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mPointView.doPointAnim(); &#125; &#125;); &#125; &#125; 三、ObjectAnimator基础使用为了能让动画直接与对应控件相关联，以使我们从监听动画过程中解放出来，谷歌的开发人员在ValueAnimator的基础上，又派生了一个类ObjectAnimator; 由于ObjectAnimator是派生自ValueAnimator的，所以ValueAnimator中所能使用的方法，在ObjectAnimator中都可以正常使用。但ObjectAnimator也重写了几个方法，比如ofInt(),ofFloat()等。 改变透明度示例123ObjectAnimator animator = ObjectAnimator.ofFloat(tv,"alpha",1,0,1); animator.setDuration(2000);animator.start(); 构造函数public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) 第一个参数用于指定这个动画要操作的是哪个控件 第二个参数用于指定这个动画要操作这个控件的哪个属性(rotationX-围绕X轴，rotationY-围绕Y轴，rotation围绕Z轴，translationX-在X轴上水平移动，translationY-在Y轴上水平移动，scaleX-在X轴上缩放倍数，scaleY-在Y轴上缩放倍数) 第三个参数是可变长参数，这个就跟ValueAnimator中的可变长参数的意义一样了，就是指这个属性值是从哪变到哪 自定义ObjectAnimator属性1、保存圆形信息类——Point123456789101112131415public class Point &#123; private int mRadius; public Point(int radius)&#123; mRadius = radius; &#125; public int getRadius() &#123; return mRadius; &#125; public void setRadius(int radius) &#123; mRadius = radius; &#125; &#125; 2、自定义控件——MyPointView123456789101112131415161718192021222324public class MyPointView extends View &#123; private Point mPoint = new Point(100); public MyPointView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mPoint != null)&#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setColor(Color.RED); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(300,300,mPoint.getRadius(),paint); &#125; super.onDraw(canvas); &#125; void setPointRadius(int radius)&#123; mPoint.setRadius(radius); invalidate(); &#125; &#125; 3、MyActivity1234567891011121314151617181920212223242526public class MyActivity extends Activity &#123; private Button btnStart; private MyPointView mPointView; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); btnStart = (Button) findViewById(R.id.btn); mPointView = (MyPointView)findViewById(R.id.pointview); btnStart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doPointViewAnimation(); &#125; &#125;); &#125; private void doPointViewAnimation()&#123; ObjectAnimator animator = ObjectAnimator.ofInt(mPointView, "pointRadius", 0, 300, 100); animator.setDuration(2000); animator.start(); &#125;&#125; 五、PropertyValuesHolder与KeyframeValueAnimator和ObjectAnimator除了通过ofInt(),ofFloat(),ofObject()创建实例外，还都有一个ofPropertyValuesHolder()方法来创建实例。通常ValueAnimator使用ofPropertyValuesHolder()的机会不多，所以只讲ObjectAnimator中ofPropertyValuesHolder()的用法。对于ValueAnimator的ofPropertyValuesHolder()使用是差不多的。 1、PropertyValuesHolder1、概述PropertyValuesHolder这个类的意义就是，它其中保存了动画过程中所需要操作的属性和对应的值。我们通过ofFloat(Object target, String propertyName, float… values)构造的动画，ofFloat()的内部实现其实就是将传进来的参数封装成PropertyValuesHolder实例来保存动画状态。在封装成PropertyValuesHolder实例以后，后期的各种操作也是以PropertyValuesHolder为主的。 创建实例的函数1234public static PropertyValuesHolder ofFloat(String propertyName, float... values) public static PropertyValuesHolder ofInt(String propertyName, int... values) public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,Object... values) public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values) 这里总共有四个创建实例的方法，这一段我们着重讲ofFloat、ofInt和ofObject的用法，ofKeyframe我们单独讲。 2、PropertyValuesHolder之ofFloat()、ofInt()（1）ofFloat()、ofInt()构造函数 public static PropertyValuesHolder ofFloat(String propertyName, float... values) public static PropertyValuesHolder ofInt(String propertyName, int... values) propertyName：表示ObjectAnimator需要操作的属性名。即ObjectAnimator需要通过反射查找对应属性的setProperty()函数的那个property. values：属性所对应的参数，同样是可变长参数，可以指定多个，还记得我们在ObjectAnimator中讲过，如果只指定了一个，那么ObjectAnimator会通过查找getProperty()方法来获得初始值。 （2）、ObjectAnimator.ofPropertyValuesHolder()ObjectAnimator提供了一个设置PropertyValuesHolder实例的入口： public static ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values); target：指需要执行动画的控件 values：是一个可变长参数，可以传进去多个PropertyValuesHolder实例，由于每个PropertyValuesHolder实例都会针对一个属性做动画，所以如果传进去多个PropertyValuesHolder实例，将会对控件的多个属性同时做动画操作。 示例 123456PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat("Rotation", 60f, -60f, 40f, -40f, -20f, 20f, 10f, -10f, 0f); PropertyValuesHolder colorHolder = PropertyValuesHolder.ofInt("BackgroundColor", 0xffffffff, 0xffff00ff, 0xffffff00, 0xffffffff); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotationHolder, colorHolder); animator.setDuration(3000); animator.setInterpolator(new AccelerateInterpolator()); animator.start(); 3、PropertyValuesHolder之ofObject()ofObject的构造函数public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,Object... values); propertyName:ObjectAnimator动画操作的属性名; evaluator:Evaluator实例，Evaluator是将当前动画进度计算出当前值的类，可以使用系统自带的IntEvaluator、FloatEvaluator也可以自定义。 values：可变长参数，表示操作动画属性的值。 示例 通过自字义的CharEvaluator来自动实现字母的改变与计算。 首先是自定义一个CharEvaluator,通过进度值来自动计算出当前的字母: 12345678910public class CharEvaluator implements TypeEvaluator&lt;Character&gt; &#123; @Override public Character evaluate(float fraction, Character startValue, Character endValue) &#123; int startInt = (int)startValue; int endInt = (int)endValue; int curInt = (int)(startInt + fraction *(endInt - startInt)); char result = (char)curInt; return result; &#125; &#125; 从CharEvaluator中可以看出，从CharEvaluator中产出的动画中间值类型为Character类型。TextView中虽然有setText(CharSequence text) 函数，但这个函数的参数类型是CharSequence，而不是Character类型。所以我们要自定义一个类派生自TextView来改变TextView的字符 12345678public class MyTextView extends TextView &#123; public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public void setCharText(Character character)&#123; setText(String.valueOf(character)); &#125; &#125; 最后MyActivity,在点击按钮的时候开始动画，核心代码为: 123456789101112131415161718192021222324252627public class MyActivity extends Activity &#123; private Button btn; private TextView mTextView; private MyTextView mMyTv; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mMyTv = (MyTextView)findViewById(R.id.mytv); btn = (Button) findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doOfObjectAnim(); &#125; &#125;); &#125; private void doOfObjectAnim()&#123; PropertyValuesHolder charHolder = PropertyValuesHolder.ofObject("CharText",new CharEvaluator(),new Character('A'),new Character('Z')); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mMyTv, charHolder); animator.setDuration(3000); animator.setInterpolator(new AccelerateInterpolator()); animator.start(); &#125; &#125; 3、Keyframe1、概述—-我们知道如果要控制动画速率的变化，我们可以通过自定义插值器，也可以通过自定义Evaluator来实现。但如果真的让我们为了速率变化效果而自定义插值器或者Evaluator的话，恐怕大部分同学会有一万头草泥马在眼前奔过，因为大部分的同学的数学知识已经还给老师了。—-为了解决方便的控制动画速率的问题，谷歌为了我等屁民定义了一个KeyFrame的类，KeyFrame直译过来就是关键帧。—-关键帧这个概念是从动画里学来的，我们知道视频里，一秒要播放24帧图片，对于制作flash动画的同学来讲，是不是每一帧都要画出来呢？当然不是了，如果每一帧都画出来，那估计做出来一个动画片都得要一年时间；比如我们要让一个球在30秒时间内，从（0,0）点运动到（300，200）点，那flash是怎么来做的呢，在flash中，我们只需要定义两个关键帧，在动画开始时定义一个，把球的位置放在(0,0)点；在30秒后，再定义一个关键帧，把球的位置放在（300，200）点。在动画 开始时，球初始在是（0，0）点，30秒时间内就adobe flash就会自动填充，把球平滑移动到第二个关键帧的位置（300，200）点；—-通过上面分析flash动画的制作原理，我们知道，一个关键帧必须包含两个原素，第一时间点，第二位置。即这个关键帧是表示的是某个物体在哪个时间点应该在哪个位置上。—-所以谷歌的KeyFrame也不例外，KeyFrame的生成方式为： public static Keyframe ofFloat(float fraction, float value); fraction：表示当前的显示进度，即从加速器中getInterpolation()函数的返回值； value：表示当前应该在的位置 比如Keyframe.ofFloat(0, 0)表示动画进度为0时，动画所在的数值位置为0；Keyframe.ofFloat(0.25f, -20f)表示动画进度为25%时，动画所在的数值位置为-20；Keyframe.ofFloat(1f,0)表示动画结束时，动画所在的数值位置为0；在理解了KeyFrame.ofFloat()的参数以后，我们来看看PropertyValuesHolder是如何使用KeyFrame对象的： public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values); propertyName：动画所要操作的属性名 values：Keyframe的列表，PropertyValuesHolder会根据每个Keyframe的设定，定时将指定的值输出给动画。 完整的KeyFrame使用代码： 1234567Keyframe frame0 = Keyframe.ofFloat(0f, 0); Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f); Keyframe frame2 = Keyframe.ofFloat(1, 0); PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe("rotation",frame0,frame1,frame2); Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage,frameHolder); animator.setDuration(1000); animator.start(); 第一步：生成Keyframe对象；第二步：利用PropertyValuesHolder.ofKeyframe()生成PropertyValuesHolder对象第三步：ObjectAnimator.ofPropertyValuesHolder()生成对应的Animator 2、示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyActivity extends Activity &#123; private ImageView mImage; private Button mBtn; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mImage = (ImageView)findViewById(R.id.img); mBtn = (Button)findViewById(R.id.btn); mBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doOfFloatAnim(); &#125; &#125;); &#125; private void doOfFloatAnim()&#123; /** * 左右震动效果 */ Keyframe frame0 = Keyframe.ofFloat(0f, 0); Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f); Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f); Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f); Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f); Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f); Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f); Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f); Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f); Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f); Keyframe frame10 = Keyframe.ofFloat(1, 0); PropertyValuesHolder frameHolder1 = PropertyValuesHolder.ofKeyframe("rotation", frame0, frame1, frame2, frame3, frame4,frame5, frame6, frame7, frame8, frame9, frame10); /** * scaleX放大1.1倍 */ Keyframe scaleXframe0 = Keyframe.ofFloat(0f, 1); Keyframe scaleXframe1 = Keyframe.ofFloat(0.1f, 1.1f); Keyframe scaleXframe2 = Keyframe.ofFloat(0.2f, 1.1f); Keyframe scaleXframe3 = Keyframe.ofFloat(0.3f, 1.1f); Keyframe scaleXframe4 = Keyframe.ofFloat(0.4f, 1.1f); Keyframe scaleXframe5 = Keyframe.ofFloat(0.5f, 1.1f); Keyframe scaleXframe6 = Keyframe.ofFloat(0.6f, 1.1f); Keyframe scaleXframe7 = Keyframe.ofFloat(0.7f, 1.1f); Keyframe scaleXframe8 = Keyframe.ofFloat(0.8f, 1.1f); Keyframe scaleXframe9 = Keyframe.ofFloat(0.9f, 1.1f); Keyframe scaleXframe10 = Keyframe.ofFloat(1, 1); PropertyValuesHolder frameHolder2 = PropertyValuesHolder.ofKeyframe("ScaleX",scaleXframe0,scaleXframe1,scaleXframe2,scaleXframe3,scaleXframe4,scaleXframe5,scaleXframe6,scaleXframe7,scaleXframe8,scaleXframe9,scaleXframe10); /** * scaleY放大1.1倍 */ Keyframe scaleYframe0 = Keyframe.ofFloat(0f, 1); Keyframe scaleYframe1 = Keyframe.ofFloat(0.1f, 1.1f); Keyframe scaleYframe2 = Keyframe.ofFloat(0.2f, 1.1f); Keyframe scaleYframe3 = Keyframe.ofFloat(0.3f, 1.1f); Keyframe scaleYframe4 = Keyframe.ofFloat(0.4f, 1.1f); Keyframe scaleYframe5 = Keyframe.ofFloat(0.5f, 1.1f); Keyframe scaleYframe6 = Keyframe.ofFloat(0.6f, 1.1f); Keyframe scaleYframe7 = Keyframe.ofFloat(0.7f, 1.1f); Keyframe scaleYframe8 = Keyframe.ofFloat(0.8f, 1.1f); Keyframe scaleYframe9 = Keyframe.ofFloat(0.9f, 1.1f); Keyframe scaleYframe10 = Keyframe.ofFloat(1, 1); PropertyValuesHolder frameHolder3 = PropertyValuesHolder.ofKeyframe("ScaleY",scaleYframe0,scaleYframe1,scaleYframe2,scaleYframe3,scaleYframe4,scaleYframe5,scaleYframe6,scaleYframe7,scaleYframe8,scaleYframe9,scaleYframe10); /** * 构建动画 */ Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage, frameHolder1,frameHolder2,frameHolder3); animator.setDuration(1000); animator.start(); &#125; &#125; 3、常用函数123456789101112131415161718192021222324252627/** * ofFloat */ public static Keyframe ofFloat(float fraction) public static Keyframe ofFloat(float fraction, float value) /** * ofInt */ public static Keyframe ofInt(float fraction) public static Keyframe ofInt(float fraction, int value) /** * ofObject */ public static Keyframe ofObject(float fraction) public static Keyframe ofObject(float fraction, Object value) /** * 设置fraction参数，即Keyframe所对应的进度 */ public void setFraction(float fraction) /** * 设置当前Keyframe所对应的值 */ public void setValue(Object value) /** * 设置Keyframe动作期间所对应的插值器 */ public void setInterpolator(TimeInterpolator interpolator) PropertyValuesHolder之其它函数PropertyValuesHolder除了上面的讲到的ofInt,ofFloat,ofObject,ofKeyframe以外，api 11的还有几个函数：123456789101112131415161718192021222324/** * 设置动画的Evaluator */ public void setEvaluator(TypeEvaluator evaluator) /** * 用于设置ofFloat所对应的动画值列表 */ public void setFloatValues(float... values) /** * 用于设置ofInt所对应的动画值列表 */ public void setIntValues(int... values) /** * 用于设置ofKeyframe所对应的动画值列表 */ public void setKeyframes(Keyframe... values) /** * 用于设置ofObject所对应的动画值列表 */ public void setObjectValues(Object... values) /** * 设置动画属性名 */ public void setPropertyName(String propertyName) 六、联合动画的代码实现上几篇给大家分别讲了ValueAnimator和ObjectAnimator,相比而言ObjectAnimator更为方便而且由于set函数是在控件类内部实现，所以封装性更好。而且在现实使用中一般而言都是使用ObjectAnimator的机率比较大。但ValueAnimator和ObjectAnimator都只能单单实现一个动画，那如果我们想要使用一个组合动画，比如边放大，边移动，边改变alpha值，要怎么办。对于这种组合型的动画，谷歌给我们提供了一个类AnimatorSet;这篇我们就着重来看看组合动画的实现方法吧。 1、AnimatorSet——playSequentially,playTogether首先，AnimatorSet针对ValueAnimator和ObjectAnimator都是适用的，但一般而言，我们不会用到ValueAnimator的组合动画，所以我们这篇仅讲解ObjectAnimator下的组合动画实现。在AnimatorSet中直接给为我们提供了两个方法playSequentially和playTogether，playSequentially表示所有动画依次播放，playTogether表示所有动画一起开始。 1、playSequentiallypublic void playSequentially(Animator... items); public void playSequentially(List&lt;Animator&gt; items); 这里有两种声明，第一个是我们最常用的，它的参数是可变长参数，也就是说我们可以传进去任意多个Animator对象。这些对象的动画会逐个播放。第二个构造函数，是传进去一个List&lt; Animator&gt;的列表。原理一样，也是逐个去取List中的动画对象，然后逐个播放。但使用起来稍微麻烦一些。 示例12345678910111213141516171819202122232425262728293031public class MyActivity extends Activity &#123; private Button mButton; private TextView mTv1, mTv2; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mButton = (Button) findViewById(R.id.btn); mTv1 = (TextView) findViewById(R.id.tv_1); mTv2 = (TextView) findViewById(R.id.tv_2); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doPlaySequentiallyAnimator(); &#125; &#125;); &#125; private void doPlaySequentiallyAnimator()&#123; ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, "BackgroundColor", 0xffff00ff, 0xffffff00, 0xffff00ff); ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, "translationY", 0, 300, 0); ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, "translationY", 0, 400, 0); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playSequentially(tv1BgAnimator,tv1TranslateY,tv2TranslateY); animatorSet.setDuration(1000); animatorSet.start(); &#125;&#125; 2、playTogetherpublic void playTogether(Animator... items); public void playTogether(Collection&lt;Animator&gt; items); 同样这里也是有两个构造函数，他们两个的意义是一样的，只是传入的参数不一样，第一个依然是传可变长参数列表，第二个则是需要传一个组装好的Collection对象。 示例12345678ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, "BackgroundColor", 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, "translationY", 0, 400, 0);ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, "translationY", 0, 400, 0);AnimatorSet animatorSet = new AnimatorSet();animatorSet.playTogether(tv1BgAnimator,tv1TranslateY,tv2TranslateY);animatorSet.setDuration(1000);animatorSet.start(); 自由设置动画顺序——AnimatorSet.Builder上面我们讲了playTogether和playSequentially，分别能实现一起开始动画和逐个开始动画。但并不是非常自由的组合动画，比如我们有三个动画A,B,C我们想先播放C然后同时播放A和B。利用playTogether和playSequentially是没办法实现的，所以为了更方便的组合动画，谷歌的开发人员另外给我们提供一个类AnimatorSet.Builder。 1、示例1234567ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, "BackgroundColor", 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, "translationY", 0, 400, 0);AnimatorSet animatorSet = new AnimatorSet();AnimatorSet.Builder builder = animatorSet.play(tv1BgAnimator);builder.with(tv1TranslateY);animatorSet.start(); 2、AnimatorSet.Builder函数1234567891011//调用AnimatorSet中的play方法是获取AnimatorSet.Builder对象的唯一途径//表示要播放哪个动画public Builder play(Animator anim)//和前面动画一起执行public Builder with(Animator anim)//执行前面的动画后才执行该动画public Builder before(Animator anim)//执行先执行这个动画再执行前面动画public Builder after(Animator anim)//延迟n毫秒之后执行动画public Builder after(long delay) 3、使用示例12345678ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, "BackgroundColor", 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, "translationY", 0, 400, 0);ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, "translationY", 0, 400, 0);AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(tv1TranslateY).with(tv2TranslateY).after(tv1BgAnimator);animatorSet.setDuration(2000);animatorSet.start(); AnimatorSet监听器 1、AnimatorSet的监听函数也只是用来监听AnimatorSet的状态的，与其中的动画无关； 2、AnimatorSet中没有设置循环的函数，所以AnimatorSet监听器中永远无法运行到onAnimationRepeat()中！ 通用函数逐个设置与AnimatorSet设置的区别123456//设置单次动画时长public AnimatorSet setDuration(long duration);//设置加速器public void setInterpolator(TimeInterpolator interpolator)//设置ObjectAnimator动画目标控件public void setTarget(Object target) 区别就是：在AnimatorSet中设置以后，会覆盖单个ObjectAnimator中的设置；即如果AnimatorSet中没有设置，那么就以ObjectAnimator中的设置为准。如果AnimatorSet中设置以后，ObjectAnimator中的设置就会无效。 七、联合动画的XML实现与使用示例1、联合动画的XML实现在xml中对应animator总共有三个标签，分别是 &lt;animator /&gt;:对应ValueAnimator &lt;objectAnimator /&gt;:对应ObjectAnimator &lt;set /&gt;:对应AnimatorSet 1、animator(1)下面是完整的animator所有的字段及取值范围：123456789&lt;animator android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"] android:interpolator=["@android:interpolator/XXX"]/&gt; android:duration:每次动画播放的时长 android:valueFrom:初始动化值；取值范围为float,int和color，如果取值为float对应的值样式应该为89.0，取值为Int时，对应的值样式为：89;当取值为clolor时，对应的值样式为 #333333; android:valueTo：动画结束值；取值范围同样是float,int和color这三种类型的值； android:startOffset：动画激活延时；对应代码中的startDelay(long delay)函数； android:repeatCount：动画重复次数 android:repeatMode：动画重复模式，取值为repeat和reverse；repeat表示正序重播，reverse表示倒序重播 android:valueType：表示参数值类型，取值为intType和floatType；与android:valueFrom、android:valueTo相对应。如果这里的取值为intType，那么android:valueFrom、android:valueTo的值也就要对应的是int类型的数值。如果这里的数值是floatType，那么android:valueFrom、android:valueTo的值也要对应的设置为float类型的值。非常注意的是，如果android:valueFrom、android:valueTo的值设置为color类型的值，那么不需要设置这个参数； android:interpolator:设置加速器；有关系统加速器所对应的xml值对照表如下： (2)将xml加载到程序中在定义了一个xml后，我们需要将其加载到程序中，使用的方法如下： ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(MyActivity.this,R.animator.animator); valueAnimator.start(); 2、objectAnimator(1)字段意义及使用方法12345678910&lt;objectAnimator android:propertyName="string" android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"] android:interpolator=["@android:interpolator/XXX"]/&gt; android:propertyName：对应属性名，即ObjectAnimator所需要操作的属性名。其它字段的意义与animator的意义与取值是一样的，下面再重新列举一下。 android:duration:每次动画播放的时长 android:valueFrom:初始动化值；取值范围为float,int和color； android:valueTo：动画结束值；取值范围同样是float,int和color这三种类型的值； android:startOffset：动画激活延时；对应代码中的startDelay(long delay)函数； android:repeatCount：动画重复次数 android:repeatMode：动画重复模式，取值为repeat和reverse；repeat表示正序重播，reverse表示倒序重播 android:valueType：表示参数值类型，取值为intType和floatType；与android:valueFrom、android:valueTo相对应。如果这里的取值为intType，那么android:valueFrom、android:valueTo的值也就要对应的是int类型的数值。如果这里的数值是floatType，那么android:valueFrom、android:valueTo的值也要对应的设置为float类型的值。非常注意的是，如果android:valueFrom、android:valueTo的值设置为color类型的值，那么不需要设置这个参数； android:interpolator:设置加速器。 (2)将xml加载到程序中ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator(MyActivity.this, R.animator.object_animator); animator.setTarget(mTv1); animator.start(); 3、set(1)字段意义及使用方法12&lt;set android:ordering=["together" | "sequentially"]&gt; android:ordering：表示动画开始顺序。together表示同时开始动画，sequentially表示逐个开始动画； (2)将xml加载到程序中AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(MyActivity.this, R.animator.set_animator); set.setTarget(mTv1); set.start(); 2、AnimatorSet应用应用AnimatorSet例子效果： 我们先来分析下这个效果，在用户点击按钮时，把菜单弹出来；弹出来的时候，动画一点从小变到大，一边透明度从0变到1.关键问题是，怎么样实现各个菜单以当前点击按钮为圆心排列在圆形上； 布局代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginBottom="10dp" android:layout_marginRight="10dp"&gt; &lt;Button android:id="@+id/menu" style="@style/MenuStyle" android:background="@drawable/menu"/&gt; &lt;Button android:id="@+id/item1" style="@style/MenuItemStyle" android:background="@drawable/circle1" android:visibility="gone"/&gt; &lt;Button android:id="@+id/item2" style="@style/MenuItemStyle" android:background="@drawable/circle2" android:visibility="gone"/&gt; &lt;Button android:id="@+id/item3" style="@style/MenuItemStyle" android:background="@drawable/circle3" android:visibility="gone"/&gt; &lt;Button android:id="@+id/item4" style="@style/MenuItemStyle" android:background="@drawable/circle4" android:visibility="gone"/&gt; &lt;Button android:id="@+id/item5" style="@style/MenuItemStyle" android:background="@drawable/circle5" android:visibility="gone"/&gt;&lt;/FrameLayout&gt; 其中的style代码为： 12345678910111213&lt;resources&gt; &lt;style name="MenuStyle"&gt; &lt;item name="android:layout_width"&gt;50dp&lt;/item&gt; &lt;item name="android:layout_height"&gt;50dp&lt;/item&gt; &lt;item name="android:layout_gravity"&gt;right|bottom&lt;/item&gt; &lt;/style&gt; &lt;style name="MenuItemStyle"&gt; &lt;item name="android:layout_width"&gt;45dp&lt;/item&gt; &lt;item name="android:layout_height"&gt;45dp&lt;/item&gt; &lt;item name="android:layout_gravity"&gt;right|bottom&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; MyActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class MyActivity extends Activity implements View.OnClickListener&#123; private static final String TAG = "MainActivity"; private Button mMenuButton; private Button mItemButton1; private Button mItemButton2; private Button mItemButton3; private Button mItemButton4; private Button mItemButton5; private boolean mIsMenuOpen = false; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); initView(); &#125; private void initView() &#123; mMenuButton = (Button) findViewById(R.id.menu); mMenuButton.setOnClickListener(this); mItemButton1 = (Button) findViewById(R.id.item1); mItemButton1.setOnClickListener(this); mItemButton2 = (Button) findViewById(R.id.item2); mItemButton2.setOnClickListener(this); mItemButton3 = (Button) findViewById(R.id.item3); mItemButton3.setOnClickListener(this); mItemButton4 = (Button) findViewById(R.id.item4); mItemButton4.setOnClickListener(this); mItemButton5 = (Button) findViewById(R.id.item5); mItemButton5.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (v == mMenuButton) &#123; if (!mIsMenuOpen) &#123; mIsMenuOpen = true; doAnimateOpen(mItemButton1, 0, 5, 300); doAnimateOpen(mItemButton2, 1, 5, 300); doAnimateOpen(mItemButton3, 2, 5, 300); doAnimateOpen(mItemButton4, 3, 5, 300); doAnimateOpen(mItemButton5, 4, 5, 300); &#125; else &#123; mIsMenuOpen = false; doAnimateClose(mItemButton1, 0, 5, 300); doAnimateClose(mItemButton2, 1, 5, 300); doAnimateClose(mItemButton3, 2, 5, 300); doAnimateClose(mItemButton4, 3, 5, 300); doAnimateClose(mItemButton5, 4, 5, 300); &#125; &#125; else &#123; Toast.makeText(this, "你点击了" + v, Toast.LENGTH_SHORT).show(); &#125; &#125; private void doAnimateOpen(View view, int index, int total, int radius) &#123; if (view.getVisibility() != View.VISIBLE) &#123; view.setVisibility(View.VISIBLE); &#125; double degree = Math.toRadians(90)/(total - 1) * index; int translationX = -(int) (radius * Math.sin(degree)); int translationY = -(int) (radius * Math.cos(degree)); AnimatorSet set = new AnimatorSet(); //包含平移、缩放和透明度动画 set.playTogether( ObjectAnimator.ofFloat(view, "translationX", 0, translationX), ObjectAnimator.ofFloat(view, "translationY", 0, translationY), ObjectAnimator.ofFloat(view, "scaleX", 0f, 1f), ObjectAnimator.ofFloat(view, "scaleY", 0f, 1f), ObjectAnimator.ofFloat(view, "alpha", 0f, 1)); //动画周期为500ms set.setDuration(1 * 500).start(); &#125; private void doAnimateClose(final View view, int index, int total,int radius) &#123; if (view.getVisibility() != View.VISIBLE) &#123; view.setVisibility(View.VISIBLE); &#125; double degree = Math.PI * index / ((total - 1) * 2); int translationX = -(int) (radius * Math.sin(degree)); int translationY = -(int) (radius * Math.cos(degree)); AnimatorSet set = new AnimatorSet(); //包含平移、缩放和透明度动画 set.playTogether( ObjectAnimator.ofFloat(view, "translationX", translationX, 0), ObjectAnimator.ofFloat(view, "translationY", translationY, 0), ObjectAnimator.ofFloat(view, "scaleX", 1f, 0.1f), ObjectAnimator.ofFloat(view, "scaleY", 1f, 0.1f), ObjectAnimator.ofFloat(view, "alpha", 1f, 0f)); set.setDuration(1 * 500).start(); &#125;&#125; 一、LayoutAnimation的xml实现——layoutAnimation标签1、概述这部分，我们就来看看layoutAnimation标签的用法，要使用layoutAnimation只需要两步：第一：定义一个layoutAnimation的animation文件，如：(anim/layout_animation.xml) 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="1" android:animationOrder="normal" android:animation="@anim/slide_in_left"/&gt; 第二步：在viewGroup类型的控件中，添加Android:layoutAnimation=”@anim/layout_animation”，如：123456&lt;ListView android:id="@+id/listview" android:layout_width="match_parent" android:layout_height="match_parent" android:layoutAnimation="@anim/layout_animation" /&gt; 注意我们可以知道最重要的一点：android:layoutAnimation只在viewGroup创建的时候，才会对其中的item添加动画。在创建成功以后，再向其中添加item将不会再有动画。 2、layoutAnimation各字段意义12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="1" android:animationOrder="normal" android:animation="@anim/slide_in_left"/&gt; delay:指每个Item的动画开始延时，取值是android:animation所指定动画时长的倍数，取值类型可以是float类型，也可以是百分数，默认是0.5;比如我们这里指定的动画是@anim/slide_in_left，而在slide_in_left.xml中指定android:duration=”1000”，即单次动画的时长是1000毫秒，而我们在这里的指定android:delay=”1”，即一个Item的动画会在上一个item动画完成后延时单次动画时长的一倍时间开始，即延时1000毫秒后开始。 animationOrder:指viewGroup中的控件动画开始顺序，取值有normal(正序)、reverse(倒序)、random(随机) animation：指定每个item入场所要应用的动画。仅能指定res/aim文件夹下的animation定义的动画，不可使用animator动画。 二、LayoutAnimation的代码实现——LayoutAnimationController1、构造函数public LayoutAnimationController(Animation animation) public LayoutAnimationController(Animation animation, float delay) 2、基本函数123456789101112/** * 设置animation动画 */public void setAnimation(Animation animation)/** * 设置单个item开始动画延时 */public void setDelay(float delay)/** * 设置viewGroup中控件开始动画顺序，取值为ORDER_NORMAL、ORDER_REVERSE、ORDER_RANDOM */public void setOrder(int order) 3、示例同样以上面的例子为例，把xml实现改成代码实现。由于我们要代码实现layoutAnimation，所以我们不再需要写layoutAnimation的xml了，只需要一个动画的animation:(slide_in_left.xml) 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000"&gt; &lt;translate android:fromXDelta="-50%p" android:toXDelta="0"/&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0"/&gt;&lt;/set&gt; 然后是主布局（main.xml） 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/addlist" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="添加list数据"/&gt; &lt;ListView android:id="@+id/listview" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 最后我们来看看代码(MyActivity.Java) 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyActivity extends Activity &#123; private ListView mListView; private ArrayAdapter mAdapter; private Button mAddListBtn; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mListView = (ListView) findViewById(R.id.listview); mAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1, getData()); mListView.setAdapter(mAdapter); mAddListBtn = (Button)findViewById(R.id.addlist); mAddListBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mAdapter.addAll(getData()); &#125; &#125;); //代码设置通过加载XML动画设置文件来创建一个Animation对象； Animation animation= AnimationUtils.loadAnimation(this,R.anim.slide_in_left); //得到一个LayoutAnimationController对象； LayoutAnimationController controller = new LayoutAnimationController(animation); //设置控件显示的顺序； controller.setOrder(LayoutAnimationController.ORDER_REVERSE); //设置控件显示间隔时间； controller.setDelay(0.3f); //为ListView设置LayoutAnimationController属性； mListView.setLayoutAnimation(controller); mListView.startLayoutAnimation(); &#125; private List&lt;String&gt; getData() &#123; List&lt;String&gt; data = new ArrayList&lt;String&gt;(); data.add("测试数据1"); data.add("测试数据2"); data.add("测试数据3"); data.add("测试数据4"); return data; &#125;&#125; 三、GridLayoutAnimation的XML实现——gridLayoutAnimation这部分将给大家讲解有关gridview给内部子控件添加创建动画的内容。 1、标签属性1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;gridLayoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:rowDelay="75%" android:columnDelay="60%" android:directionPriority="none" android:direction="bottom_to_top|right_to_left" android:animation="@android:anim/slide_in_left"/&gt; rowDelay:每一行动画开始的延迟。与LayoutAnimation一样，可以取百分数，也可以取浮点数。取值意义为，当前android:animation所指动画时长的倍数。 columnDelay：每一列动画开始的延迟。取值类型及意义与rowDelay相同。 directionPriority：方向优先级。取值为row,collumn,none，意义分别为：行优先，列优先，和无优先级（同时进行）;具体意义，后面会细讲 direction：gridview动画方向。取值有四个：left_to_right：列，从左向右开始动画right_to_left ：列，从右向左开始动画top_to_bottom：行，从上向下开始动画bottom_to_top：行，从下向上开始动画这四个值之间可以通过“|”连接，从而可以取多个值。很显然left_to_right和right_to_left是互斥的，top_to_bottom和bottom_to_top是互斥的。如果不指定 direction字段，默认值为left_to_right | top_to_bottom；即从上往下，从左往右。 animation: gridview内部元素所使用的动画。 2、示例(1)、首先是gride_animation.xml123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;gridLayoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:rowDelay="75%" android:columnDelay="60%" android:directionPriority="none" android:animation="@anim/slide_in_left"/&gt; 这里没有设置android:direction属性，采用默认值：left_to_right|top_to_bottom；然后是对应的animation动画slide_in_left.xml: 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000"&gt; &lt;translate android:fromXDelta="-50%p" android:toXDelta="0"/&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0" /&gt;&lt;/set&gt; (2)、程序布局main.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/add_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="添加grid数据"/&gt; &lt;GridView android:id="@+id/grid" android:layout_width="match_parent" android:layout_height="match_parent" android:columnWidth="60dp" android:gravity="center" android:horizontalSpacing="10dp" android:layoutAnimation="@anim/gride_animation" android:numColumns="auto_fit" android:stretchMode="columnWidth" android:verticalSpacing="10dp"/&gt;&lt;/LinearLayout&gt; (3)、代码处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MyActivity extends Activity &#123; private GridAdapter mGrideAdapter; private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;(); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); /** * 填充gridview */ GridView grid = (GridView) findViewById(R.id.grid); mDatas.addAll(getData()); mGrideAdapter = new GridAdapter(); grid.setAdapter(mGrideAdapter); /** * 按钮点击响应 */ Button addData = (Button)findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; addData(); &#125; &#125;); &#125; private List&lt;String&gt; getData() &#123; List&lt;String&gt; data = new ArrayList&lt;String&gt;(); for (int i = 1;i&lt;35;i++)&#123; data.add("DATA "+i); &#125; return data; &#125; public void addData()&#123; mDatas.addAll(mDatas); mGrideAdapter.notifyDataSetChanged(); &#125; public class GridAdapter extends BaseAdapter &#123; public View getView(int position, View convertView, ViewGroup parent) &#123; TextView i = new TextView(MyActivity.this); i.setText(mDatas.get(position)); i.setLayoutParams(new GridView.LayoutParams(GridView.LayoutParams.WRAP_CONTENT, GridView.LayoutParams.WRAP_CONTENT)); return i; &#125; public final int getCount() &#123; return mDatas.size(); &#125; public final Object getItem(int position) &#123; return null; &#125; public final long getItemId(int position) &#123; return position; &#125; &#125;&#125; 四、GridLayoutAnimation的代码实现——GridLayoutAnimationController1、构造函数public GridLayoutAnimationController(Animation animation) public GridLayoutAnimationController(Animation animation, float columnDelay, float rowDelay) 2、其他方法12345678910111213141516/** * 设置列动画开始延迟 */public void setColumnDelay(float columnDelay)/** * 设置行动画开始延迟 */ public void setRowDelay(float rowDelay) /** * 设置gridview动画的入场方向。取值有：DIRECTION_BOTTOM_TO_TOP、DIRECTION_TOP_TO_BOTTOM、DIRECTION_LEFT_TO_RIGHT、DIRECTION_RIGHT_TO_LEFT */ public void setDirection(int direction) /** * 动画开始优先级，取值有PRIORITY_COLUMN、PRIORITY_NONE、PRIORITY_ROW */ public void setDirectionPriority(int directionPriority) 3、示例创建一个slide_in_left.xml文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000"&gt; &lt;translate android:fromXDelta="-50%p" android:toXDelta="0"/&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0" /&gt;&lt;/set&gt;``` 然后是布局文件main.xml:``` xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;GridView android:id="@+id/grid" android:layout_width="match_parent" android:layout_height="match_parent" android:columnWidth="60dp" android:gravity="center" android:horizontalSpacing="10dp" android:numColumns="auto_fit" android:stretchMode="columnWidth" android:verticalSpacing="10dp"/&gt;&lt;/LinearLayout&gt; 最后是MyActivity中的填充部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MyActivity extends Activity &#123; private GridAdapter mGrideAdapter; private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;(); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); /** * 填充gridview */ GridView grid = (GridView) findViewById(R.id.grid); mDatas.addAll(getData()); mGrideAdapter = new GridAdapter(); grid.setAdapter(mGrideAdapter); Animation animation = AnimationUtils.loadAnimation(MyActivity.this,R.anim.slide_in_left); GridLayoutAnimationController controller = new GridLayoutAnimationController(animation); controller.setColumnDelay(0.75f); controller.setRowDelay(0.5f); controller.setDirection(GridLayoutAnimationController.DIRECTION_BOTTOM_TO_TOP|GridLayoutAnimationController.DIRECTION_LEFT_TO_RIGHT); controller.setDirectionPriority(GridLayoutAnimationController.PRIORITY_NONE); grid.setLayoutAnimation(controller); grid.startLayoutAnimation(); &#125; private List&lt;String&gt; getData() &#123; List&lt;String&gt; data = new ArrayList&lt;String&gt;(); for (int i = 1;i&lt;35;i++)&#123; data.add("DATA "+i); &#125; return data; &#125; public void addData()&#123; mDatas.addAll(mDatas); mGrideAdapter.notifyDataSetChanged(); &#125; public class GridAdapter extends BaseAdapter &#123; public View getView(int position, View convertView, ViewGroup parent) &#123; TextView i = new TextView(MyActivity.this); i.setText(mDatas.get(position)); i.setLayoutParams(new GridView.LayoutParams(GridView.LayoutParams.WRAP_CONTENT, GridView.LayoutParams.WRAP_CONTENT)); return i; &#125; public final int getCount() &#123; return mDatas.size(); &#125; public final Object getItem(int position) &#123; return null; &#125; public final long getItemId(int position) &#123; return position; &#125; &#125;&#125; 八、animateLayoutChanges与LayoutTransition之前说的LayoutAnimation虽能实现ViewGroup的进入动画，但只能在创建时有效。在创建后，再往里添加控件就不会再有动画。在API 11后，又添加了两个能实现在创建后添加控件仍能应用动画的方法，分别是Android:animateLayoutChanges属性和LayoutTransition类。 一、android:animateLayoutChanges属性所有派生自ViewGroup的控件都具有此属性，只要在XML中添加上这个属性，就能实现添加/删除其中控件时，带有默认动画了。 1、简单示例1、main.xml布局代码123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/add_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="添加控件"/&gt; &lt;Button android:id="@+id/remove_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="移除控件"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/layoutTransitionGroup" android:layout_width="match_parent" android:layout_height="wrap_content" android:animateLayoutChanges="true" android:orientation="vertical"/&gt; &lt;/LinearLayout&gt; 2、MyActivity代码123456789101112131415161718192021222324252627282930313233343536373839404142public class MyActivity extends Activity implements View.OnClickListener &#123; private LinearLayout layoutTransitionGroup; private int i = 0; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup); findViewById(R.id.add_btn).setOnClickListener(this); findViewById(R.id.remove_btn).setOnClickListener(this); &#125; private void addButtonView() &#123; i++; Button button = new Button(this); button.setText("button" + i); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); button.setLayoutParams(params); layoutTransitionGroup.addView(button, 0); &#125; private void removeButtonView() &#123; if (i &gt; 0) &#123; layoutTransitionGroup.removeViewAt(0); &#125; i--; &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.add_btn) &#123; addButtonView(); &#125; if (v.getId() == R.id.remove_btn) &#123; removeButtonView(); &#125; &#125; &#125; 二、LayoutTransaction1、概述上面虽然在ViewGroup类控件XML中仅添加一行android:animateLayoutChanges=[true]即可实现内部控件添加删除时都加上动画效果。但却只能使用默认动画效果，而无法自定义动画。为了能让我们自定义动画，谷歌在API 11时，同时为我们引入了一个类LayoutTransaction。要使用LayoutTransaction是非常容易的，只需要三步： 第一步：创建实例LayoutTransaction transitioner = new LayoutTransition(); 第二步：创建动画并设置ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f); transitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut); 第三步：将LayoutTransaction设置进ViewGrouplinearLayout.setLayoutTransition(mTransitioner); 在第二步中，transitioner.setAnimator设置动画的函数声明为： public void setAnimator(int transitionType, Animator animator) 第一个参数int transitionType：表示当前应用动画的对象范围，取值有： APPEARING —— 元素在容器中出现时所定义的动画。 DISAPPEARING —— 元素在容器中消失时所定义的动画。 CHANGE_APPEARING —— 由于容器中要显现一个新的元素，其它需要变化的元素所应用的动画 CHANGE_DISAPPEARING —— 当容器中某个元素消失，其它需要变化的元素所应用的动画 2、LayoutTransition.CHANGE_APPEARING与LayoutTransition.CHANGE_DISAPPEARING在添加控件时，除了被添加控件本身的入场动画以外，其它需要移动位置的控件，在移动位置时，也被添加上了动画（left点位移动画），这些除了被添加控件以外的其它需要移动位置的控件组合，所对应的动画就是LayoutTransition.CHANGE_APPEARING同样，在移除一个控件时，因为移除了一个控件，而其它所有需要改变位置的控件组合所对应的动画就是LayoutTransition.CHANGE_DISAPPEARING LayoutTransition.CHANGE_APPEARING实现12345678910111213141516171819202122232425public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup); findViewById(R.id.add_btn).setOnClickListener(this); findViewById(R.id.remove_btn).setOnClickListener(this); mTransitioner = new LayoutTransition(); //入场动画:view在这个容器中消失时触发的动画 ObjectAnimator animIn = ObjectAnimator.ofFloat(null, "rotationY", 0f, 360f,0f); mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn); //出场动画:view显示时的动画 ObjectAnimator animOut = ObjectAnimator.ofFloat(null, "rotation", 0f, 90f, 0f); mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut); PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt("left",0,100,0); PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt("top",1,1); Animator changeAppearAnimator = ObjectAnimator.ofPropertyValuesHolder(layoutTransitionGroup, pvhLeft,pvhBottom,pvhTop,pvhRight); mTransitioner.setAnimator(LayoutTransition.CHANGE_APPEARING,changeAppearAnimator); layoutTransitionGroup.setLayoutTransition(mTransitioner); &#125; 注意 LayoutTransition.CHANGE_APPEARING和LayoutTransition.CHANGE_DISAPPEARING必须使用PropertyValuesHolder所构造的动画才会有效果，不然无效！也就是说使用ObjectAnimator构造的动画，在这里是不会有效果的！ 在构造PropertyValuesHolder动画时，”left”、”top”属性的变动是必写的。如果不需要变动，则直接写为： 在构造PropertyValuesHolder时，所使用的ofInt,ofFloat中的参数值，第一个值和最后一个值必须相同，不然此属性所对应的的动画将被放弃，在此属性值上将不会有效果； 在构造PropertyValuesHolder时，所使用的ofInt,ofFloat中，如果所有参数值都相同，也将不会有动画效果。 九、实现ListView Item进入动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class ListAdapter extends BaseAdapter &#123; private List&lt;Drawable&gt; mDrawableList = new ArrayList&lt;&gt;(); private int mLength = 0; private LayoutInflater mInflater; private Context mContext; private ListView mListView; private Animation animation; AbsListView.OnScrollListener mOnScrollListener = new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; View firstChild = view.getChildAt(0); if (firstChild == null) return; int top = firstChild.getTop(); /** * firstVisibleItem &gt; mFirstPosition表示向下滑动一整个Item * mFirstTop &gt; top表示在当前这个item中滑动 */ isScrollDown = firstVisibleItem &gt; mFirstPosition || mFirstTop &gt; top; mFirstTop = top; mFirstPosition = firstVisibleItem; &#125; &#125;; public ListAdapter(Context context, ListView listView, List&lt;Drawable&gt; drawables, int length) &#123; mDrawableList.addAll(drawables); mLength = length; mInflater = LayoutInflater.from(context); mContext = context; mListView = listView; animation = AnimationUtils.loadAnimation(mContext,R.anim.bottom_in_anim); &#125; @Override public int getCount() &#123; return mLength; &#125; @Override public Object getItem(int position) &#123; return mDrawableList.get(position % mDrawableList.size()); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.item_layout, null); holder.mImageView = (ImageView) convertView.findViewById(R.id.img); holder.mTextView = (TextView) convertView.findViewById(R.id.text); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; //清除当前显示区域中所有item的动画 for (int i=0;i&lt;mListView.getChildCount();i++)&#123; View view = mListView.getChildAt(i); view.clearAnimation(); &#125; if (isScrollDown) &#123; convertView.startAnimation(animation); &#125; convertView.setTag(holder); holder.mImageView.setImageDrawable(mDrawableList.get(position % mDrawableList.size())); holder.mTextView.setText(position+""); return convertView; &#125; public class ViewHolder &#123; public ImageView mImageView; public TextView mTextView; &#125; &#125; 摘记自Android自定义控件三部曲文章索引]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PopUpWindow使用详解]]></title>
      <url>%2F2015%2F11%2F10%2Fandroid-popupwindow%2F</url>
      <content type="text"><![CDATA[前言学习PopUpWindow，学习弹出窗口的使用，并且了解以及自定义PopUpWindow，以开发更好的应用。 1.PopupWindow与AlertDialog的区别最关键的区别是AlertDialog不能指定显示位置，只能默认显示在屏幕最中间（当然也可以通过设置WindowManager参数来改变位置）。而PopupWindow是可以指定显示位置的，随便哪个位置都可以，更加灵活。 2.PopupWindow的相关函数(1)构造函数public PopupWindow (Context context)//方法一public PopupWindow(View contentView)//方法二public PopupWindow(View contentView, int width, int height)//方法三public PopupWindow(View contentView, int width, int height, boolean focusable)//方法四生成PopupWindow的最基本的三个条件一定要设置View contentView,int width,int height，缺一不可。如果使用方法一构造依旧需要用setContentView(),setWidth(),setHeight()来对其进行设置。 (2)显示函数showAsDropDown(View anchor)：//相对某个控件的位置（正左下方），无偏移showAsDropDown(View anchor, int xoff, int yoff)：//相对某个控件的位置，有偏移;xoff表示x轴的偏移，正值表示向左，负值表示向右；yoff表示相对y轴的偏移，正值是向下，负值是向上showAtLocation(View parent, int gravity, int x, int y)：//相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移 (3)其他函数public void dismiss()public void setFocusable(boolean focusable)public void setTouchable(boolean touchable)public void setOutsideTouchable(boolean touchable)public void setBackgroundDrawable(Drawable background) (4)PopupWindow设置动画mPopWindow.setAnimationStyle(R.style.contextMenuAnim);//设置动画所对应的style 3.解决问题(1)如何在弹出窗口时，使界面变暗。在PopupWindow的界面外包裹一层RelativeLayout，将RelativeLayout的界面铺满整个界面，使其颜色为半透明背景，将PopupWindow的视图设置其位置即可。 (2)如何点击空白处的时候让PopupWindow消失设置setBackgroundDrawable(new ColorDrawable(0x00000000));背景不为空但是完全透明。如此设置还能让PopupWindow在点击back的时候消失。 4.注意问题(1)注意最终显示效果为代码中设置的PopupWindow的宽高，而不是xml中视图的宽高。5.示例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity extends Activity &#123; private PopupWindow mPopupWindow; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); View popupView = getLayoutInflater().inflate(R.layout.layout_popupwindow, null); mPopupWindow = new PopupWindow(popupView, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT, true); mPopupWindow.setTouchable(true); mPopupWindow.setOutsideTouchable(true); mPopupWindow.setBackgroundDrawable(new BitmapDrawable(getResources(), (Bitmap) null)); mPopupWindow.getContentView().setFocusableInTouchMode(true); mPopupWindow.getContentView().setFocusable(true); mPopupWindow.getContentView().setOnKeyListener(new OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.getRepeatCount() == 0 &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123; if (mPopupWindow != null &amp;&amp; mPopupWindow.isShowing()) &#123; mPopupWindow.dismiss(); &#125; return true; &#125; return false; &#125; &#125;); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.getRepeatCount() == 0) &#123; if (mPopupWindow != null &amp;&amp; !mPopupWindow.isShowing()) &#123; mPopupWindow.showAtLocation(findViewById(R.id.layout_main), Gravity.BOTTOM, 0, 0); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android学习资料大全]]></title>
      <url>%2F2015%2F10%2F17%2Fandroid-study%2F</url>
      <content type="text"><![CDATA[前言学习Android光看书和看视频是不够的，需要实践和一些网络资料的收集，慢慢积累，才能提高自身水平。本文记录一些常常需要查看的Android学习网站和博客，不时翻阅一下，以提高自身水平。 教程 很好的中文教程 Google Android官方培训课程中文版 Google Android官方培训课程英文版 Android 开发列表 awesome-android github上的一个项目，收集了好多的Android开源项目 android-open-project 一个分类特别好的网站 Android Arsenal MaterialDesign资料整理 Awesome-MaterialDesign coursera-android 一个android教程类项目，8周完成结业。基本上囊括了android所有知识点，如果你想把android方面的知识系统地整理一遍，可以果断也把它fork下来，一个一个开始练习，总共有100多个例子。 50个Android开发技巧 Vector_Yi整理的Android开发技巧 android-best-practices android编程最佳实践 android-UniversalMusicPlayer google官方跨设备的例子，一款播放器，UI和交互都超级棒，而且同时支持手机、平板和Android Wear。 Android-Material-Example 另一个Android L学习的例子。 Material-Animations Material动画例子 工具 Android Button Maker Android Button Maker是一个可以在线生成按钮代码的工具。Android API提供了XML文件定义的几何形状的Drawable资源，包括颜色、边界和梯度。这些按钮的生成是基于drawable形态的XML代码，这样可以比普通的png按钮加载得更快。你可以在设置面板上自定义按钮的属性，然后获取其源码。 AndroidAssetStudio Asset Studio可以让你快速简单地从已经存在的图片、剪贴画或者文本资源中生成图标。这些图标可以应用在Launcher icons Action bar and tab iconsNotification icons Navigation drawer indicator** Generic icons ActionbarStyleGenerator 这个ActionBar风格生成器可以让你轻松地创建一个简洁、有吸引力且无漏洞的自定义actionbar。它会生成所有9种必须的patch assets以及相关XML的drawables和styles文件，这些文件可以直接复制到你的项目中。 AndroidHolo 这个Android Holo颜色生成器可以让你简单地为你的应用创建Android组件，如editext或者spinner，并且可以使用自己的颜色。它会生成所有9种必须的patch assets以及相关XML的drawables和styles文件，可以直接复制这些文件到你的项目中。 AndroidLayoutBinder Android Layout Binder会将你安卓的XML布局文件转换成一系列的声明，绑定保存所有的人工输入。键入一个前缀，选择XML文件上要粘贴的范围，然后点击生成。选择“verbose”来找出所有被跳过的区域的原因。 APKAnalyser 这是一个静态、虚拟分析工具，你可以全面地概览应用的架构。可以用它来检查API参考文档，查看应用依赖还有反编译字节码。APKAnalyser是一个完整的开源工具链，它支持修改应用的二进制代码，你可以重新打包、安装、运行以及验证logcat的结果。 maven-android-sdk-deployer 一个使用Maven Android Plugin插件安装Android SDK组件的工具 Material Palette调色板 Material Design出来一段时间了，身为Android开发人员想要自己适配一套Material Design，但是又苦于缺少设计方面的知识与理解，怎么办呢？这个网站就可以自动帮你生成调色板。 Android-Iconics 这是一个可以让你在你的项目中使用几乎任何字体图标的库。默认包含 FontAwesome 和 Material Design Icons 还包含 Meteocons 插件。你甚至可以添加任何你自定义的字体图标（typeface）。 android-actionbarstylegenerator action bar风格在线制作。UI组件 Google提供的750个Material Ddesign图标 Material Design资源 一大波优质的Material Design资源免费下载 Material UI Material UI 是一个 CSS 框架和一组实现谷歌 Material Design 设计规范的 React 组件。可以用在html5方式的APP中 android-ui Android UI库， Android L风格。 Android-LollipopShowcase Euclid 一个非常精美的用户信息页面的实现，动效很细腻。 android-typeface-helper typeface效果 android-flip 可以实现类似Flipboard一样的翻页效果。 android-viewbadger 为视图增加badger。可以做的更好看点。 AndroidViewAnimations 漂亮的视图动画。 JazzyViewPager 为ViewPager增加一条切换动画 labelview 贴纸效果。 AndroidTagGroup 一个漂亮的标签组控件。 AutoCompleteBubbleText 自动选择，可用于tag选择 BlurEffectForAndroidDesign 模糊效果的演示。 MaterialDesignLibrary 为Adnroid 2.2等低版本应用增加Android L 5.0风格的组件。 RippleEffect 涟漪效果 material-ripple 为view增加的Android L涟漪效果的包装类 HoloColorPicker Holo风格的颜色选择器。 Android-Action-Bar-Icons 图标资源 FancyCoverFlow MaterialViewPager ViewPager， Material Design风格 FlippableStackView 堆栈效果 HorizontalStackView 另一个横向堆栈效果 GiftCard-Android 礼品卡效果 cheesesquare Android 设计库的演示 Button android-floating-action-button Android L风格的浮动按钮， 红色小鲜肉。 Android-Bootstrap bootstrap风格的按钮。 使用Font Awesome图标字体。 android-bootstrap 不同于上面的Android-Bootstrap。 此项目是一个Android应用程序的模版， 相当于一个脚手架的功能。 android-process-button 很酷的一个组件，可以在按钮下部显示漂亮的进度条，就像GMAIL一样。 fab 一个支持很多自定义属性的Floating Action Button控件。 FloatingActionButton 模仿Android L的Floating Action Button (FAB)， 可以用在Jellybean 和 KitKat中 AndroidFloatLabel 浮动标签， 按需显示。 Android-UndoBar fab-toolbar Material Design风格的FAB工具栏效果 Menu ActionBarSherlock 一个功能强大的ActionBar组件(不仅仅是ActionBar)。 Android 4.0+上使用native action bar， 低版本的Android模拟实现。强大到无语了，必须关注的一个开源组件。 SlidingMenu一款优秀的侧滑菜单组件。 Google+, YouTube和Facebook在它们的应用中采用的侧滑菜单流行开来， 国内也有很多的应用如网易新闻等也采用了这种菜单方式。 侧滑菜单组件很好几种， 尤以此款最为好用。 看看官方网站上的知名用户就知道了。 android-menudrawer 又一个滑动菜单的组件。 android-undergarment 抽屉组件。集成这个组件非常简单 ,只要在activity的oncreate中加入mDrawerGarment = new DrawerGarment(this, R.layout.dashboard); DragLayout 使用support.v4包下的ViewDragHelper实现QQ5.0侧滑 android-satellite-menu 类似Path一样的菜单。 L-Navigation-Drawer 替换Android L的导航抽屉类。 也就是左边拖动菜单。 material-menu 模仿Android L的drawer, back, dismiss and check icons动画 ArcMenu 又一个类似Path的环形菜单。 Application richeditor-android 超酷的富文本编辑器 superCleanMaster 一键清理 开源版，包括内存加速，缓存清理，自启管理，软件管理等。 facebook-android-sdk Facebook提供的SDK， 可以在应用中集成Facebook. MaterialSettings 可以让你轻松创建Material Design风格的Settings Activity的库。 ZhihuPaper 个人开发的知乎日报客户端。 更纯净的知乎日报 chromeview Android webview组件的实现， 但是基于最新的Chromium 代码。 android-pdfview transparent-over-animtabsview 模仿网易云音乐 LetterImageView 类似Android的邮件应用， 用首字母作为图片。 chromium-webview-samples1 chromium-webview-samples2 chromium-webview-samples3 chromium-webview-samples4 chromium-webview-samples5 Pull-Down PullDownListView 仿微信首页的下拉效果，非常细腻。 Taurus 下拉刷新的动画好赞。 Android-PullToRefresh 你不陌生， 在列表或者视图的顶部或者底部拖动可以刷新数据和页面。可以和ListView、ExpandableListView、GridView、WebView、ScrollView、HorizontalScrollView、ViewPager配合使用。 android-PullRefreshLayout 下拉刷新布局， 比SwipeRefreshLayout更漂亮。 android-pulltorefresh 又一个拖动刷新的组件。到此为止说了好多又了。 因为有些功能确实有多个不错的实现。 Image SimpleTagImageView 一个可以在图片四个角显示一个小标签的ImageView，并且可以控制标签的宽度和背景颜色。 Android-Universal-Image-Loader 强大灵活的加载、缓存、显示图片的库。 picasso 强大的图像下载和缓存库。 PhotoView ImageView扩展， 支持放缩和手势。 ion 又一个图像异步加载库。至少推荐三个了， 轮子不少。关注度很高 Android-Ultra-Photo-Selector 一个图片选择器控件，支持选择多张图片、浏览设备上所有包含图片的文件夹、预览选择的图片并且支持缩放。 MultiImageSelector 国人开发的一个多图像选择组件 cropper 图像剪切和旋转。 android-gif-drawable android-crop 图像裁剪 EditText GridPasswordView 仿微信/支付宝的密码输入框效果。 Shimmer-android 闪烁发光的文本框。 android-edittext-validator 文本框校验 Desktop DevelopQuickSetting 一个快速开启关闭开发者设置的工具，提供了app界面和桌面widget，能快速打开关闭overdraw，layout border，gpu rendering，adb wifi，不保存activity实例等功能。需要root权限 Indicator Android-ViewPagerIndicator滑动页面几乎成了现在国内的应用的标配了，尤其在你第一次安装/启动应用时， 总会有几张介绍页面让你滑动显示。 用它吧，不会辜负你的。 SpringIndicator 模仿Morning Routine的引导页效果. Layout AndroidStaggeredGrid 想做瀑布流式的应用吗？用它吧。 cardslib 一种卡片式的布局控件。 记得以前的有道词典的默认页就是这种布局 LDrawer 使用material design动画的drawer图标 AndroidViewHover 一种优雅的显示上下文和菜单的库 FreeFlow comcast出品的一个布局引擎。 FreeFlow让你很容易的定制布局和漂亮的转换动画。 android-viewflow 可以水平滚动的视图。 StaggeredGridView 瀑布流。类似Pinterest。 KugouLayout 一个模仿酷狗播放器滑动返回的layout，可以让你的app有更丰富便捷的手势操作，支持activity滑动返回和普通layout的滑动显示/隐藏两种模式。 StickyGridHeaders 可以固定header和分区的Grid。 ArcLayout 超酷的弧形布局 AndroidSwipeLayout 功能强大的swipe布局。 android-sliding-layer-lib 滑动层框架， 支持左右滑动，全屏。 PinterestLikeAdapterView 瀑布流。 Chart WilliamChart 图表组件。 hellocharts-android 一个图表库， 带少量动画。 GraphView 可以产生放缩的线图和直方图。 MPAndroidChart 非常不错的图表工具。 AndroidCharts 图表控件 Android-Charts 国人实现的图表控件 desCharts 图表控件 XCL-Charts 国人出品， 图表控件，种类很多。 Listview ListViewAnimations为ListView增加动画， 还提供滑动删除选定项的功能。 类似Android的邮件的删除操作。 StickyListHeaders header可以固定的组件。 看下图。 drag-sort-listview 在ListItem拖动重排序。 FadingActionBar 折叠风格的ActionBar. Android-SlideExpandableListView 有一个可以滑动的ExpandableListView组件。 pinned-section-listview GroupName滑动到顶端时会固定不动直到另外一个GroupName到达顶端的ExpandListView PullZoomView 最近国内用的比较多的一个风格。 拖动时头部缩放。 Android-SwipeToDismiss 演示ListView滑动删除。 MultiChoiceAdapter ListView 支持多选。 PinnedHeaderExpandableListView 国人实现的一个ExpandableListView,头部可以固定， 并且可以伸缩。 PullToZoomInListView 滑动ListView时使其HeaderView跟随滑动缩放. FlyRefresh 创意Replace的Android实现，很cool. AnimateCheckBox 酷炫CheckBox Calendar Android-Week-View 日历组件。 android-times-square square出品的日期选择组件。 android-betterpickers 更好的时间、日期库。 material-calendarview DatePicker 中国人开发的日期选择器 Toast Crouton Toast之外的另以选择。 SuperToasts 扩展的Toast. Progress circular-progress-button 环形进度条按钮。 ProgressWheel 环形进度条。 dashed-circular-progress 圆形轨迹进度条控件。 NumberProgressBar 漂亮的带数字的进度条。 CircleProgress 圆圈进度条 ElasticDownload 酷炫进度条 Font Calligraphy 在Android中更容易的使用字体。 [android-iconify][UI-font 2] 集成FontAwesome 。 ActionBar GlassActionBar 毛玻璃效果的action bar. NotBoringActionBar 拖动时顶部可以收缩。 Dialog L-Dialogs 代替Android L的对话框 StandOut 很容易的创建弹出窗口。 类库 roboguice google guice框架在Android平台上的实现。 android-async-http 基于Apache http client实现的支持异步、回调的android http client组件。 androidannotations 将注解引入到Android开发中，极大的减少代码里，可以更好的维护代码。 retrofit 类型安全的Restful client库。 dagger 一个快速的依赖注入库。这个square公司出了不少的组件库。 square公司就是那个移动支付的创业公司。 okhttp 还是square出品， HTTP+SPDY 客户端。 EventBus 一个专为Android优化的发布订阅框架, event bus模式。 可以在Activity, Fragment 和后台线程之间交流数据。 butterknife 专为视图注入库。 robospice 一个模块化的Android类库， 可以更容易的编写异步的长时间运行的任务。 AndroidAsync 又是异步处理库， 支持socket,http (client+server),websocket 和socket.io ，基于nio。 ActiveAndroid active record风格的操作Android SQLite 数据库。 androidquery JQuery很熟悉吧。 这是Android版的JQuery。 greenDAO 一个轻量级的快速的ORM方案。 操作SQLite 数据库。 Bolts-Android 一套底层库。 scaloid 极大的减少Android得代码，更易维护。 conceal Facebook的快速加密类。 android-common 国人实现的一个工具包。 xUtils 国人实现的一个工具包。 android-priority-jobqueue Path出品的job queue。 android-sqlite-asset-helper 数据库辅助类。 包括数据库的创建与升级。 tape 一组queue类。 square出品。 spring-android joda-time-android 为Android做了优化 spydroid-ipcamera 将你的收集作为监控设备。 ACRA ACRA是一个可以让安卓应用自动发出GoogleDoc格式崩溃报告的函数库。安卓开发者可以通过ACRA获取应用崩溃或者错误行为的数据。如果有一个崩溃发生，你的应用不会越过已有的系统崩溃提醒或者报告功能来添加用户提醒。如果使用Toast、状态提醒条或者直接对话框模式，这个“强制关闭”的对话框不会再显示，就算设备上原生系统的提醒功能开启也不能发送一个另外的报告。 jpinyin JPinyin是一个汉字转拼音的Java开源类库，在PinYin4j的功能基础上做了一些改进。 Game Engine libgdx libGDX是基于OpenGL的跨平台的游戏开发框架。 AndEngine 知名的Android 2D OpenGL 游戏引擎。 ogengine 国人开发的国际著名开源引擎AndEngine的一个分支 （往上看）。遵循LGPL开源协议使用OpenGL ES进行图形绘制。同时集成了Box2D物理引擎，因此可以实现复杂的物理效果。 citrus 快速且轻量级的2D &amp; 3D游戏引擎。 Cocos2d-Android 知名的游戏引擎 gameclosure JavaScript 游戏引擎 游戏引擎列表 维基百科上的各种游戏引擎， 各种平台的引擎列表， 全。 Android HTML5应用 PhoneCap 早在2011年10月，Adobe收购了Nitobi Software和它的PhoneGap产品，然后宣布这个移动开发框架将会继续开源，并把它提交到Apache Incubator，以便完全接受ASF的管治。 Cordova Cordova是贡献给Apache后的开源项目，是从PhoneGap中抽出的核心代码，是驱动PhoneGap的核心引擎。你可以把他想象成类似于Webkit和Google Chrome的关系。Adobe将会继续以Cordova加上PhoneGap Build和Adobe Shadow的组合提供PhoneGap。 Cordova-SQLitePlugin awesome-cordova Cordova插件列表 ionic 基于Cordova的快速创建平台。 mui 国内厂商dcloud开源的一个高性能的html5框架。 lungo awesome-html5 Pixi.js MelonJS Crafty cutjs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Minecraft源码获取]]></title>
      <url>%2F2015%2F10%2F11%2Fget-minecraft-code%2F</url>
      <content type="text"><![CDATA[前言自从大三开始就喜欢上了Minecraft这个自由度极高的游戏，一直想了解他的实现，但苦于这方面资料一直不多。查了许多网站和贴吧，终于有结果了。发出来记录一下。 下载mcp9.31.zip MCP Mod Coder Pack官网 mcp9.31对应 Minecraft 1.10 解压缩，得到mcp930文件夹，打开docs文件夹，可以查看说明文档 打开README-MCP.TXT，可以找到安装步骤 下载Minecraft服务端程序,复制到mcp931/jars Minecraft_server.1.10.jar 开启正版Minecraft启动程序，下载Minecraft.1.10版本。将.minecraft 文件夹下的 “assets”, “libraries” and “versions”三个文件夹复制到mcp931/jars.(游戏必须启动过一次) 运行mcp931/decompile.sh，反编译游戏文件得到源代码（注意要有Python和Scala的运行环境） 使用Eclipse打开mcp931下的eclipse工作空间，就可以查看Minecraft的源代码了 recompile.sh–重新编译修改后的游戏 startclient.sh–执行客户端 startserver.sh–执行服务端 cleanup.sh–清理编译过的文件，方便重新编译]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法]]></title>
      <url>%2F2015%2F07%2F22%2Falgorithm-sort%2F</url>
      <content type="text"><![CDATA[前言 现在排序算法经过长时间的演变，发展处各种不同的排序算法。不得不说在日常开发以及日后的研究生活中还是比较常见以及使用的。再此对各种排序算法做一个记录，方便日后比较和查阅。 排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； 直接插入排序(插入排序) 介绍它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 步骤 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2 最优复杂度：当输入数组就是排好序的时候，复杂度为O(n)，而快速排序在这种情况下会产生O(n^2)的复杂度。 最差复杂度：当输入数组为倒序时，复杂度为O(n^2) 比较适合用于“少量元素的数组”。 代码 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;class Untitled &#123; public static void main(String[] args) &#123; Random ran = new Random(); int[] sort = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; sort[i] = ran.nextInt(50); &#125; System.out.println("排序前的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; System.out.println(); directInsertSort(sort); System.out.println("排序后的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; &#125; /** * 直接插入排序 * * @param sort */ private static void directInsertSort(int[] sort) &#123; for (int i = 1; i &lt; sort.length; i++) &#123; int index = i - 1; int temp = sort[i]; while (index &gt;= 0 &amp;&amp; sort[index] &gt; temp) &#123; sort[index + 1] = sort[index]; index--; &#125; sort[index + 1] = temp; &#125; &#125;&#125; 示例 希尔排序 介绍希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 步骤 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 示例 排序效果 冒泡排序 介绍冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码 1234567891011121314151617181920212223242526272829303132import java.util.*;class test1 &#123; public static void main(String[] args) &#123; Random ran = new Random(); int[] sort = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; sort[i] = ran.nextInt(50); &#125; System.out.println("排序前的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; System.out.println(); buddleSort(sort); System.out.println("排序后的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; &#125; public static void buddleSort(int[] sort)&#123; for (int i = 1;i &lt; sort.length;i++) &#123; for (int j = 0;j &lt; sort.length - i;j++) &#123; if (sort[j] &gt; sort[j+1]) &#123; int temp = sort[j]; sort[j] = sort[j + 1]; sort[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 示例 排序效果 选择排序 介绍选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。 步骤 从n个记录中找出关键码最小的记录与第一个记录交换； 从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换； 以此类推….. 第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换； 直到整个序列按关键码有序。 代码 123456789101112131415161718192021222324252627282930313233import java.util.*;class Untitled &#123; public static void main(String[] args) &#123; Random ran = new Random(); int[] sort = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; sort[i] = ran.nextInt(50); &#125; System.out.println("排序前的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; System.out.println(); selectSort(sort); System.out.println("排序后的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; &#125; public static void selectSort(int[] sort)&#123; for (int i = 0; i &lt; sort.length - 1;i++) &#123; for (int j = i + 1;j &lt; sort.length;j++) &#123; if (sort[j] &lt; sort[i]) &#123; int temp = sort[j]; sort[j] = sort[i]; sort[i] = temp; &#125; &#125; &#125; &#125;&#125; 示例 排序效果 快速排序 介绍快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。 步骤 从数列中挑出一个元素，称为 “基准”(pivot) 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.*;class Untitled &#123; public static void main(String[] args) &#123; Random ran = new Random(); int[] sort = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; sort[i] = ran.nextInt(50); &#125; System.out.println("排序前的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; System.out.println(); quickSort(sort, 0, sort.length - 1); System.out.println("排序后的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; &#125; public static void quickSort(int[] sort, int start, int end) &#123; // 设置关键数据key为要排序数组的第一个元素， // 即第一趟排序后，key右边的数全部比key大，key左边的数全部比key小 int key = sort[start]; // 设置数组左边的索引，往右移动判断比key大的数 int i = start; // 设置数组右边的索引，往左移动判断比key小的数 int j = end; // 如果左边索引比右边索引小，则还有数据没有排序 while (i &lt; j) &#123; while (sort[j] &gt; key &amp;&amp; j &gt; start) &#123; j--; &#125; while (sort[i] &lt; key &amp;&amp; i &lt; end) &#123; i++; &#125; if (i &lt; j) &#123; int temp = sort[i]; sort[i] = sort[j]; sort[j] = temp; &#125; &#125; // 如果左边索引比右边索引要大，说明第一次排序完成，将sort[j]与key对换 // 即保持了key左边的数比key小，key右边的数比key大 if (i &gt; j) &#123; int temp = sort[j]; sort[j] = sort[start]; sort[start] = temp; &#125; //递归调用 if (j &gt; start &amp;&amp; j &lt; end) &#123; quickSort(sort, start, j - 1); quickSort(sort, j + 1, end); &#125; &#125;&#125; 示例 一趟排序的过程 排序的全过程 排序效果 归并排序 介绍归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用 步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 示例 排序效果 堆排序 介绍堆积排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。 大顶堆序列：（96, 83,27,38,11,09) 小顶堆序列：（12，36，24，85，47，30，53，91）初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。 步骤 调整小顶堆的方法 设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶(最后一个元素与堆顶进行交换)，堆被破坏，其原因仅是根结点不满足堆的性质。 将根结点与左、右子树中较小元素的进行交换。 若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法(2). 若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法(2). 继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。 n个元素初始建堆的过程(建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。) n 个结点的完全二叉树，则最后一个结点是第个结点的子树。 筛选从第个结点为根的子树开始，该子树成为堆。 之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。 如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49） 排序效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取Sha1值]]></title>
      <url>%2F2015%2F07%2F10%2Fandroid-get-sha1%2F</url>
      <content type="text"><![CDATA[前言自从用了高德地图和百度地图的API，就一直被获取Sha1的值搞得烦不胜烦，总是忘记，花时间去到网上找方式。不过，经历了这么多次的摧残也熟了。记录一下，避免下次再忘记。 使用 keytool（jdk自带工具） 运行进入控制台。 在弹出的控制台窗口中定位到 .android 文件夹。 继续在控制台输入命令。 开发模式使用 debug.keystore，命令为：keytool -list -v -keystore debug.keystore 发布模式使用 apk 对应的 keystore，命令为：keytool -list -v -keystore apk的keystore 提示输入密钥库密码，开发模式默认密码是 android，发布模式的密码是为 apk 的 keystore 设置的密码。输入密钥后回车（如果没设置密码，可直接回车），此时可在控制台显示的信息中获取 Sha1 值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[布局的xml属性]]></title>
      <url>%2F2015%2F06%2F25%2Fandroid-layout%2F</url>
      <content type="text"><![CDATA[前言虽然布局已经用了蛮熟练的了，但还是记录一下自己的学习经历。并且避免日后遗忘，做个记录总是好的。 RelativeLayout 相对于给定ID控件android:layout_above 将该控件的底部置于给定ID的控件之上;android:layout_below 将该控件的底部置于给定ID的控件之下;android:layout_toLeftOf 将该控件的右边缘与给定ID的控件左边缘对 齐;android:layout_toRightOf 将该控件的左边缘与给定ID的控件右边缘对 齐;android:layout_alignBaseline 将该控件的baseline与给定ID的baseline对 齐;android:layout_alignTop 将该控件的顶部边缘与给定ID的顶部边缘对 齐;android:layout_alignBottom 将该控件的底部边缘与给定ID的底部边缘对 齐;android:layout_alignLeft 将该控件的左边缘与给定ID的左边缘对齐;android:layout_alignRight 将该控件的右边缘与给定ID的右边缘对齐; 相对于父组件android:layout_alignParentTop 如果为true,将该控件的顶部与其父控件的 顶部对齐;android:layout_alignParentBottom 如果为true,将该控件的底部与其父控件 的底部对齐;android:layout_alignParentLeft 如果为true,将该控件的左部与其父控件的 左部对齐;android:layout_alignParentRight 如果为true,将该控件的右部与其父控件 的右部对齐; 居中android:layout_centerHorizontal 如果为true,将该控件的置于水平居中;android:layout_centerVertical 如果为true,将该控件的置于垂直居中;android:layout_centerInParent 如果为true,将该控件的置于父控件的中央; 指定移动像素，值为pxandroid:layout_marginTop 上偏移的值;android:layout_marginBottom 下偏移的值;android:layout_marginLeft 左偏移的值;android:layout_marginRight 右偏移的值;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EditText]]></title>
      <url>%2F2015%2F06%2F21%2Fandroid-edittext%2F</url>
      <content type="text"><![CDATA[EditText控件的常用属性如下：android:hint=”请输入数字！”//设置显示在输入位置上的提示信息 android:numeric=”integer”//设置只能输入整数，如果是小数则是：decimal android:singleLine=”true”//设置单行输入，一旦设置为true，则文字不会自动换行。 android:password=”true”//设置只能输入密码 android:textColor = “#ff8c00”//设置字体颜色 android:textStyle=”bold”//设置字体类型，如加粗、斜体等 android:textSize=”20dip”//设置字体大小 android:textColorHighlight=”#cccccc”//设置被选中文字的底色，默认为蓝色 android:textColorHint=”#ffff00”//设置提示信息文字的颜色，默认为灰色 android:textScaleX=”1.5”//设置字与字之间的间距 android:typeface=”monospace”//设置字型，如normal, sans, serif, monospace android:background=”@null”//设置控件的背景，默认为灰色带边框的背景，@null指透明，且没有边框 android:layout_weight=”1”//设置控件所占的权重，控制控件之间的地位 android:textAppearance=”?android:attr/textAppearanceLargeInverse”//设置文字外观 android:layout_gravity=”center_vertical”//设置控件显示的位置：默认top，这里居中显示，还有bottom android:gravity=”top” //多行中指针在第一行位置，即顶部 android:capitalize //首字母大写 android：phoneNumber //输入电话号码 android：editable //是否可编辑 android:autoLink=”all” //设置文本超链接样式当点击网址时，跳向该网址，可选值(none/web/email/phone/map/all) android:autoText //如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。 android:bufferType //指定getText()方式取得的文本类别 android:cursorVisible //设定光标为显示/隐藏，默认显示。 android:digits //设置允许输入哪些字符。如“1234567890.+-*/% ()” android:editorExtras //设置文本的额外的输入数据 android:ellipsize //设置当文字过长时,该控件该如何显示。有如下值设置：”start”—?省略号显示在开头;”end”——省略号显示在结尾;”middle”—-省略号显示在中间;”marquee” ——以跑马灯的方式显示(动画横向移动) android:freezesText //设置保存文本的内容以及光标的位置 android:gravity //设置文本位置，如设置成“center”，文本将居中显示。 android:hintText //为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色 android:includeFontPadding //设置文本是否包含顶部和底部额外空白，默认为true。 android:linksClickable //设置链接是否点击连接，即使设置了autoLink。 android:marqueeRepeatLimit //在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。 android:ems //设置TextView的宽度为N个字符的宽度。 android:maxEms //设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:minEms //设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:maxLength //限制显示的文本长度，超出部分不显示。 android:lines //设置文本的行数，设置两行就显示两行，即使第二行没有数据。 android:maxLines //设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。 android:minLines //设置文本的最小行数，与lines类似。 android:lineSpacingExtra 设置行间距。 android:lineSpacingMultiplier //设置行间距的倍数。如”1.2” android:password //以小点”.”显示文本 android:scrollHorizontally //设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:selectAllOnFocus //如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。 android:shadowColor //指定文本阴影的颜色，需要与shadowRadius一起使用。 android:shadowDx //设置阴影横向坐标开始位置。 android:shadowDy //设置阴影纵向坐标开始位置。 android:shadowRadius //设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好 android:height //设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米) android:maxHeight //设置文本区域的最大高度 android:minHeight //设置文本区域的最小高度 android:width //设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)，与layout_width的区别看这里。 android:maxWidth //设置文本区域的最大宽度 android:minWidth //设置文本区域的最小宽度 自动弹出软键盘为了改善用户体验，在进入一个Android页面时，自动弹出输入软键盘，实现方法如下。 方法一：首先要对指定的输入框请求焦点。然后调用输入管理器弹出软键盘。 绑定软键盘到EditText：12345editText.setFocusable(true); editText.setFocusableInTouchMode(true); editText.requestFocus(); InputMethodManager inputManager = (InputMethodManager)editText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); inputManager.showSoftInput(editText, 0); 去除软键盘显示：1234edit.setText(""); edit.clearFocus(); InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(edit.getWindowToken(), 0); 由于调转到一个新的页面，就需要弹出软键盘，往往页面还未加载完，造成软键盘无法弹出，这个时候可采用延时弹出的方法进行解决，延时大概300毫秒来保证页面加载完成： 方法A:12345678910111213141516private Handler hander=new Handler()&#123; public void handleMessage(android.os.Message msg) &#123; edit.setFocusable(true); edit.setFocusableInTouchMode(true); edit.requestFocus(); InputMethodManager inputManager = (InputMethodManager)edit.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); inputManager.showSoftInput(edit, 0); &#125;; &#125;; @Override public void onWindowFocusChanged(boolean hasWindowFocus) &#123; if(visible)&#123; hander.sendEmptyMessageDelayed(0, 1000); &#125; &#125; 方法B：1234567Timer timer = new Timer(); timer.schedule(new TimerTask() &#123; public void run()&#123; InputMethodManager inputManager = (InputMethodManager)editText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); inputManager.showSoftInput(editText, 0); &#125; &#125;, 500); 方法二：布局中自动弹出软键盘： 1234editText.requestFocus(); editText.setFocusable(true); InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInputFromInputMethod(editText.getWindowToken(),0); 布局中自动关闭软键盘：12InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(talking_edit.getWindowToken() , 0); 对话框中软键盘自动弹出和关闭：1getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE|WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE); 通过各种百度，又搜集并整理了好多关于软键盘的一些方法： 1.软键盘的显示原理软键盘其实是一个Dialog。InputMethodService为我们的输入法创建了一个Dialog，并且对某些参数进行了设置，使之能够在底部或者全屏显示。当我们点击输入框时，系统会对当前的主窗口进行调整，以便留出相应的空间来显示该Dialog在底部，或者全屏。 2.活动主窗口调整android定义了一个属性windowSoftInputMode, 用它可以让程序控制活动主窗口调整的方式。我们可以在配置文件AndroidManifet.xml中对Activity进行设置。这个属性的设置将会影响两件事情: 软键盘的状态——隐藏或显示。 活动的主窗口调整——是否减少活动主窗口大小以便腾出空间放软键盘或是否当活动窗口的部分被软键盘覆盖时它的内容的当前焦点是可见的。 故该属性的设置必须是下面列表中的一个值，或一个“state…”值加一个“adjust…”值的组合。在任一组设置多个值，各个值之间用|分开。 “stateUnspecified”： 软键盘的状态(隐藏或可见)没有被指定。系统将选择一个合适的状态或依赖于主题的设置。这个是软件盘行为的默认设置。 “stateUnchanged”：软键盘被保持上次的状态。 “stateHidden”：当用户选择该Activity时，软键盘被隐藏。 “stateAlwaysHidden”： 软键盘总是被隐藏的。 “stateVisible”： 软键盘是可见的。 “stateAlwaysVisible”： 当用户选择这个Activity时，软键盘是可见的。 “adjustUnspecified”： 它不被指定是否该Activity主窗口调整大小以便留出软键盘的空间，或是否窗口上的内容得到屏幕上当前的焦点是可见的。系统将自动选择这些模式中一种主要依赖于是否窗口的内容有任何布局视图能够滚动他们的内容。如果有这样的一个视图，这个窗口将调整大小，这样的假设可以使滚动窗口的内容在一个较小的区域中可见的。这个是主窗口默认的行为设置。也就是说，系统自动决定是采用平移模式还是压缩模式，决定因素在于内容是否可以滚动。 “adjustResize”：（压缩模式） 当软键盘弹出时，要对主窗口调整屏幕的大小以便留出软键盘的空间。 “adjustPan”：（平移模式：当输入框不会被遮挡时，该模式没有对布局进行调整，然而当输入框将要被遮挡时，窗口就会进行平移。也就是说，该模式始终是保持输入框为可见。）该Activity主窗口并不调整屏幕的大小以便留出软键盘的空间。相反，当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分。这个通常是不期望比调整大小，因为用户可能关闭软键盘以便获得与被覆盖内容的交互操作。 3.侦听软键盘的显示隐藏有时候，借助系统本身的机制来实现主窗口的调整并非我们想要的结果，我们可能希望在软键盘显示隐藏的时候，手动的对布局进行修改，以便使软键盘弹出时更加美观。这时就需要对软键盘的显示隐藏进行侦听。 我们可以借助软键盘显示和隐藏时，对主窗口进行了重新布局这个特性来进行侦听。如果我们设置的模式为压缩模式，那么我们可以对布局的onSizeChanged函数进行跟踪，如果为平移模式，那么该函数可能不会被调用。 设置EditText控件默认不弹出软键盘的几种方法： 1.在AndroidMainfest.xml中选择哪个activity，设置windowSoftInputMode属性为adjustUnspecified|stateHidden例如： 123456789&lt;activity android:name=".Main" android:label="@string/app_name" android:windowSoftInputMode="adjustUnspecified|stateHidden" android:configChanges="orientation|keyboardHidden"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 2.让EditText失去焦点，使用EditText的clearFocus方法例如： 12EditText edit=(EditText)findViewById(R.id.edit); edit.clearFocus(); 3.强制隐藏Android输入法窗口例如： 123EditText edit=(EditText)findViewById(R.id.edit); InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE); imm.hideSoftInputFromWindow(edit.getWindowToken(),0); 4.例：EditText edit=(EditText)findViewById(R.id.edit); edit.setInputType(InputType.TYPE_NULL); 显示和隐藏软键盘： 123456789101112tv.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE); //隐藏软键盘 // imm.hideSoftInputFromWindow(tv.getWindowToken(), 0); //显示软键盘 // imm.showSoftInputFromInputMethod(tv.getWindowToken(), 0); //切换软键盘的显示与隐藏 imm.toggleSoftInputFromWindow(tv.getWindowToken(), 0, InputMethodManager.HIDE_NOT_ALWAYS); //或者 // imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); &#125; &#125;); 备注： 1，Eidtext这个控件默认是你点击了它获得焦点之后就会自动地弹出软键盘，前提是你在竖屏的时候。但横盘的时候，不会自动弹出弹出软键盘了。模拟器横屏时默认是打开了键盘的所以就算你用代码来显示软键盘也是显示不出来的，而像真实的手机（有物理键盘（硬件盘）比如G1）就不一样了。可以通过sensor来把画面横屏而并没正在的将键盘打开时就可以通过代码来显示软键盘了。 2,问题在通过代码来使得软键盘显示与隐藏时可以写在某控件的onClick事件里来或者用timer来控制，若你直接在onCreate或onResume里面是不行的，从网上找来的理由说是：软件盘是要在所有view画完才能显示的。 情况一： 12345678@Override protected void onResume() &#123; // TODO Auto-generated method stub super.onResume(); InputMethodManager im = ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)); im.showSoftInput(tv, 0); &#125; &#125; 情况二： 12345678910tv.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; InputMethodManager im = ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE)); if (im.showSoftInput(tv, InputMethodManager.SHOW_FORCED)) &#123; System.out.println(" return is true fullscreenmode" + im.isFullscreenMode()); &#125; else &#123; System.out.println("return is not true"); &#125;&#125;&#125;); *自定义软键盘的Enter键* SDK升级到1.5以后，当文本输入框（EditText及其子类）获得焦点后，会弹出系统自带的软键盘为了实现一些自定义的功能，就稍微研究了下 当layout中有多个EditText，把每个控件的android:singleLine的属性都被设置成true的情况下，软键盘的Enter键上 的文字会变成“Next”，按下后下个EditText会自动获得焦点（实现了“Next”的功能）；当最后一个控件获得焦点的时候，Enter键上的文 字会变成“Done”，按下后软键盘会自动隐藏起来 把EditText的Ime Options属性设置成不同的值，Enter键上可以显示不同的文字或图案actionNone : 回车键，按下后光标到下一行actionGo ： Go，actionSearch ： 一个放大镜actionSend ： SendactionNext ： NextactionDone ： Done，隐藏软键盘，即使不是最后一个文本输入框; 示例：—————————–&gt; 123456789101112131415161718&lt;EditText android:text="" android:layout_width="fill_parent" android:layout_height="wrap_content" android:inputType="text" android:id="@+id/edit1"/&gt; &lt;EditText android:layout_width="fill_parent" android:layout_height="wrap_content" android:id="@+id/edit2" android:imeOptions="actionSend" //发送 android:inputType="text|textEmailAddress"/&gt; &lt;EditText android:layout_width="fill_parent" android:layout_height="wrap_content" android:id="@+id/edit3" android:imeOptions="actionDone" //确定 android:inputType="number|numberSigned|numberDecimal"/&gt; And java 代码如下： 123456789101112131415161718192021edit1.setOnEditorActionListener(onEditorActionListener); edit2.setOnEditorActionListener(onEditorActionListener); edit3.setOnEditorActionListener(onEditorActionListener); rivate OnEditorActionListener onEditorActionListener = new OnEditorActionListener() &#123; @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; switch(actionId)&#123; case EditorInfo.IME_NULL: System.out.println("null for default_content: " + v.getText() ); break; case EditorInfo.IME_ACTION_SEND: System.out.println("action send for email_content: " + v.getText()); break; case EditorInfo.IME_ACTION_DONE: System.out.println("action done for number_content: " + v.getText()); break; &#125; return true; &#125; &#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BitmapFactory]]></title>
      <url>%2F2015%2F06%2F20%2Fandroid-bitmapfactory%2F</url>
      <content type="text"><![CDATA[BitmapFactory.decodeResource(Resources res,int Id);//资源文件生成位图 Bitmap bmp = Bitmapfactory.decodeResource(this.getResources(),。drawable.icon); draBitmap(Bitmap bitmap,float left,float top,Paint paint); canvas.drawBitmap(bmp,0,0,paint); canvas.rotate(float degrees,float px,float py); canvas.save(); canvas.restore(); canvas.translate(float dx,float dy); canvas.scale(float sx,float sy,float px,float py); canvas.clipRect(int left,int top,int right,int bottom);//剪切区域 Region region = new Region(); region.op(new Rect(20,20,100,100),Region.Op.UNION); canvas.clipRegion(region);//设置可视区域 Region.Op.UNION:区域全部显示 Region.Op.INTERSECT:区域的交集显示 Region.Op.XOR:不显示交集区域]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中的绘画]]></title>
      <url>%2F2015%2F06%2F20%2F2015-6-20-android-paint%2F</url>
      <content type="text"><![CDATA[CanvasdrawColor(int color); drawText(String text,float x,float y,Paint paint); drawPoint(float x,float y,Paint paint); drawPoints(float[] pts,Paint paint); drawLine(float startX,float startY,float stopX,float stopY,Paint paint); drawLines(float[] pts,Paint paint); drawRect(float left,float top,float right,float bottom,Paint paint); drawRect(Rect rect,Paint paint); drawRoundRect(RectF rect,float rx,float ry,Paint paint);//圆角矩形 drawCircle(float cx,float cy,float radius,Paint paint); drawArc(RectF oval,float startAngle,float sweepAngle,boolean useCenter,Paint paint);//绘制扇形(弧形) drawOval(RectF oval, Paint paint);//绘制椭圆 drawPath(Path path,Paint paint);//绘制指定路径图形 drawTextOnPath(String text,Path path,float hOffset,float vOffset,Paint paint);//将文本沿指定路径绘制 Rect(float left,float top,float right,float bottom);矩形类，左上角和右下角坐标； RectF同上; #PathmoveTo(float x,float y); lineTo(float x,float y); close();//起点和中点只有一个，lineTo可以有好多个； android.graphics.Path.quadTo(float x1,float y1,float x2,float y2);//绘制贝塞尔曲线 addArc(RectF oval,float startAngle,float sweepAngle); addOval(RectF oval, Direction dir); addCircle(float x,float y,float radius,Direction dir); addRect(RectF rect,Direction dir); addRoundRect(RectF rect,float[] radii,Direction dir); Canvas.setDrawFilter(DrawFilter filter);//设置绘图抗锯齿 #PaintsetAntiAlias(boolean aa);//设置画笔是否有锯齿，默认为false；true（无） setAlpha(int a);//设置画笔透明度 setTextAlign(Paint.Align align);//设置绘制文本的锚点 measureText(String text);//获取文本宽度 setStyle(Style style);//设置画笔样式 setColor(int Color);//设置画笔颜色 setStrokeWidth(float width);//设置画笔粗细程度 setTextSize(float textSize);//设置文本字体尺寸 setARGB(int a,int r,int g,int b);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android数据存储]]></title>
      <url>%2F2015%2F06%2F05%2Fdata-save%2F</url>
      <content type="text"><![CDATA[前言Android需要存储本地数据的地方有好多，但是采用什么方式进行存储比较好，就是我们需要考虑的了。Android给我们提供了四种数据存储的方式，来好好学习下。 SharedPreference适用于简单数据的保存，属于配置性质的保存，不适合数据比较大的情况； FileInputStream/FileOutputStream适用于游戏的保存和使用，可以保存较大的数据，不仅能保存在内存中，还能保存在SDcard SQLite也适合游戏的保存和使用，不仅可以保存较大的数据，而且可以将自己的数据存储在文件系统或者数据库当中； ContentProvider应用间数据进行交换 SharedPreferenceContext.getSharePreferences(String name,int mode)–获取SharedPreference 实例； 操作模式Context.MODE_PRIVATE;//新内容覆盖原内容Context.MODE_APPEND;//新内容追加到原内容后Context.MODE_WORLD_READABLE;//允许其他应用程序读取Context.MODE_WORLD_WRITEABLE;//允许其他应用程序写入，会覆盖原数据 常用函数getFloat(String key,float defValue);getIn(String key,int defValue);getLong(String key,long defValue);getString(String key,String defValue);getBoolean(String key,boolean defValue); 获取编辑对象SharePreferences.Editor edit();//实例化编辑对象SharePreferences.Editor.putFloat (arg0,arg1);SharePreferences.Editor.putInt (arg0,arg1);SharePreferences.Editor.putLong (arg0,arg1);SharePreferences.Editor.putString (arg0,arg1);SharePreferences.Editor.putBoolean (arg0,arg1);SharePreferences.Editor.commit();//存入数据SharePreferences.Editor.clear();//清除数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL数据类型]]></title>
      <url>%2F2015%2F05%2F27%2Fsql-data-type%2F</url>
      <content type="text"><![CDATA[前言最近学习SQL，掌握其中的数据类型还是很重要的。上课上过SQL Server，Oracle。自己学了MySQL和SQLite，语法和数据类型基本想通，只不过查询方式和操作有很大的区别。大的功能不说，以MySQL为例记录一下数据类型。 整数数据类型TINYINT、BIT、BOOL————1SMALLINT—————————2MEDIUMINT—————————3INT—————————————4BIGINT———————————8 浮点型数据类型FLOATDOUBLEDECIMAL 常规字符串类型[national]char(M)[binary|ASCII|unicode]char[national]varchar(M)[binary] TEXT和BLOB类型TINYBLOB、TINYTEXTBLOB、TEXTMEDIUMBLOB、MEDIUMTEXTLONGBLOB、LONGTEXT ENUM和SET类型Enum(“value1”,”value2”,………)Set(“value1”,”value2”,………) 日期和时间数据类型DATE 日期，格式YYYY-MM-DDTIME 时间，格式HH：MM：SSDATETIME 日期和时间，格式YYYY-MM-DD HH：MM：SSTIMESTAMP 时间标签，在处理报告时使用显示格式取决于M的值YEAR 年份可指定两位数字和四位数字的格式 在创建表时，使用哪种数字类型应遵循以下原则：（1）选择最小的可用类型，如果数值永远不超过127，则使用TINYINT比使用INT强。（2）对于完全都是数字的，可以选择整数类型。（3）浮点型用于可能具有小数部分的数，例如货物单价、网上购物交付金额等。 在创建表和使用字符串类型时应遵循以下原则：（1）从速度方面考虑，要选择固定的列，可以使用CHAR类型。（2）要节省空间，使用动态的列，可以使用VARCHAR类型。（3）要将列中的内容限制在一种选择，可以使用ENUM类型。（4）允许在一个列中又多于一个的条目，可以使用SET类型。（5）如果要搜索的内容不区分大小写，可以使用TEXT类型。（6）如果要搜索的内容需要区分大小写，可以使用BLOB类型。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用color]]></title>
      <url>%2F2015%2F05%2F19%2Fcolor%2F</url>
      <content type="text"><![CDATA[前言因为有许多颜色是常用的，避免以后查找，记录在这里进行比对 &lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt;&lt;!--白色 --&gt; 白色 &lt;color name=&quot;ivory&quot;&gt;#FFFFF0&lt;/color&gt;&lt;!--象牙色 --&gt; 象牙色 &lt;color name=&quot;lightyellow&quot;&gt;#FFFFE0&lt;/color&gt;&lt;!--亮黄色--&gt; 亮黄色 &lt;color name=&quot;yellow&quot;&gt;#FFFF00&lt;/color&gt;&lt;!--黄色 --&gt; 黄色 &lt;color name=&quot;snow&quot;&gt;#FFFAFA&lt;/color&gt;&lt;!--雪白色 --&gt; 雪白色 &lt;color name=&quot;floralwhite&quot;&gt;#FFFAF0&lt;/color&gt;&lt;!--花白色 --&gt; 花白色 &lt;color name=&quot;lemonchiffon&quot;&gt;#FFFACD&lt;/color&gt;&lt;!--柠檬绸色 --&gt;柠檬绸色&lt;color name=&quot;cornsilk&quot;&gt;#FFF8DC&lt;/color&gt;&lt;!--米绸色 --&gt; 米绸色 &lt;color name=&quot;seashell&quot;&gt;#FFF5EE&lt;/color&gt;&lt;!--海贝色 --&gt; 海贝色 &lt;color name=&quot;lavenderblush&quot;&gt;#FFF0F5&lt;/color&gt;&lt;!--淡紫红 --&gt; 淡紫红 &lt;color name=&quot;papayawhip&quot;&gt;#FFEFD5&lt;/color&gt;&lt;!--番木色 --&gt; 番木色 &lt;color name=&quot;blanchedalmond&quot;&gt;#FFEBCD&lt;/color&gt;&lt;!--白杏色 --&gt; 白杏色 &lt;color name=&quot;mistyrose&quot;&gt;#FFE4E1&lt;/color&gt;&lt;!--浅玫瑰色 --&gt; 浅玫瑰色 &lt;color name=&quot;bisque&quot;&gt;#FFE4C4&lt;/color&gt;&lt;!--桔黄色 --&gt; 桔黄色 &lt;color name=&quot;moccasin&quot;&gt;#FFE4B5&lt;/color&gt;&lt;!--鹿皮色 --&gt; 鹿皮色 &lt;color name=&quot;navajowhite&quot;&gt;#FFDEAD&lt;/color&gt;&lt;!--纳瓦白 --&gt; 纳瓦白 &lt;color name=&quot;peachpuff&quot;&gt;#FFDAB9&lt;/color&gt;&lt;!--桃色 --&gt; 桃色 &lt;color name=&quot;gold&quot;&gt;#FFD700&lt;/color&gt;&lt;!--金色 --&gt; 金色 &lt;color name=&quot;pink&quot;&gt;#FFC0CB&lt;/color&gt;&lt;!--粉红色 --&gt; 粉红色 &lt;color name=&quot;lightpink&quot;&gt;#FFB6C1&lt;/color&gt;&lt;!--亮粉红色--&gt; 亮粉红色 &lt;color name=&quot;orange&quot;&gt;#FFA500&lt;/color&gt;&lt;!--橙色 --&gt; 橙色 &lt;color name=&quot;lightsalmon&quot;&gt;#FFA07A&lt;/color&gt;&lt;!--亮肉色 --&gt; 亮肉色 &lt;color name=&quot;darkorange&quot;&gt;#FF8C00&lt;/color&gt;&lt;!--暗桔黄色 --&gt; 暗桔黄色 &lt;color name=&quot;coral&quot;&gt;#FF7F50&lt;/color&gt;&lt;!--珊瑚色 --&gt; 珊瑚色 &lt;color name=&quot;hotpink&quot;&gt;#FF69B4&lt;/color&gt;&lt;!--热粉红色 --&gt; 热粉红色 &lt;color name=&quot;tomato&quot;&gt;#FF6347&lt;/color&gt;&lt;!--西红柿色 --&gt; 西红柿色 &lt;color name=&quot;orangered&quot;&gt;#FF4500&lt;/color&gt;&lt;!--红橙色 --&gt; 红橙色 &lt;color name=&quot;deeppink&quot;&gt;#FF1493&lt;/color&gt;&lt;!--深粉红色 --&gt; 深粉红色 &lt;color name=&quot;fuchsia&quot;&gt;#FF00FF&lt;/color&gt;&lt;!--紫红色 --&gt; 紫红色 &lt;color name=&quot;magenta&quot;&gt;#FF00FF&lt;/color&gt;&lt;!--红紫色 --&gt; 红紫色 &lt;color name=&quot;red&quot;&gt;#FF0000&lt;/color&gt;&lt;!--红色 --&gt; 红色 &lt;color name=&quot;oldlace&quot;&gt;#FDF5E6&lt;/color&gt;&lt;!--老花色 --&gt; 老花色 &lt;color name=&quot;lightgoldenrodyellow&quot;&gt;#FAFAD2&lt;/color&gt;&lt;!--亮金黄色 --&gt; 亮金黄 &lt;color name=&quot;linen&quot;&gt;#FAF0E6&lt;/color&gt;&lt;!--亚麻色 --&gt; 亚麻色 &lt;color name=&quot;antiquewhite&quot;&gt;#FAEBD7&lt;/color&gt;&lt;!--古董白 --&gt; 古董白 &lt;color name=&quot;salmon&quot;&gt;#FA8072&lt;/color&gt;&lt;!--鲜肉色 --&gt; 鲜肉色 &lt;color name=&quot;ghostwhite&quot;&gt;#F8F8FF&lt;/color&gt;&lt;!--幽灵白 --&gt; 幽灵白 &lt;color name=&quot;mintcream&quot;&gt;#F5FFFA&lt;/color&gt;&lt;!--薄荷色 --&gt; 薄荷色 &lt;color name=&quot;whitesmoke&quot;&gt;#F5F5F5&lt;/color&gt;&lt;!--烟白色 --&gt; 烟白色 &lt;color name=&quot;beige&quot;&gt;#F5F5DC&lt;/color&gt;&lt;!--米色 --&gt; 米色 &lt;color name=&quot;wheat&quot;&gt;#F5DEB3&lt;/color&gt;&lt;!--浅黄色 --&gt; 浅黄色 &lt;color name=&quot;sandybrown&quot;&gt;#F4A460&lt;/color&gt;&lt;!--沙褐色--&gt; 沙褐色 &lt;color name=&quot;azure&quot;&gt;#F0FFFF&lt;/color&gt;&lt;!--天蓝色 --&gt; 天蓝色 &lt;color name=&quot;honeydew&quot;&gt;#F0FFF0&lt;/color&gt;&lt;!--蜜色 --&gt; 蜜色 &lt;color name=&quot;aliceblue&quot;&gt;#F0F8FF&lt;/color&gt;&lt;!--艾利斯兰 --&gt; 艾利斯兰 &lt;color name=&quot;khaki&quot;&gt;#F0E68C&lt;/color&gt;&lt;!--黄褐色 --&gt; 黄褐色 &lt;color name=&quot;lightcoral&quot;&gt;#F08080&lt;/color&gt;&lt;!--亮珊瑚色 --&gt; 亮珊瑚色 &lt;color name=&quot;palegoldenrod&quot;&gt;#EEE8AA&lt;/color&gt;&lt;!--苍麒麟色 --&gt; 苍麒麟色 &lt;color name=&quot;violet&quot;&gt;#EE82EE&lt;/color&gt;&lt;!--紫罗兰色 --&gt; 紫罗兰色 &lt;color name=&quot;darksalmon&quot;&gt;#E9967A&lt;/color&gt;&lt;!--暗肉色 --&gt; 暗肉色 &lt;color name=&quot;lavender&quot;&gt;#E6E6FA&lt;/color&gt;&lt;!--淡紫色 --&gt; 淡紫色 &lt;color name=&quot;lightcyan&quot;&gt;#E0FFFF&lt;/color&gt;&lt;!--亮青色 --&gt; 亮青色 &lt;color name=&quot;burlywood&quot;&gt;#DEB887&lt;/color&gt;&lt;!--实木色 --&gt; 实木色 &lt;color name=&quot;plum&quot;&gt;#DDA0DD&lt;/color&gt;&lt;!--洋李色 --&gt; 洋李色 &lt;color name=&quot;gainsboro&quot;&gt;#DCDCDC&lt;/color&gt;&lt;!--淡灰色 --&gt; 淡灰色 &lt;color name=&quot;crimson&quot;&gt;#DC143C&lt;/color&gt;&lt;!--暗深红色 --&gt; 暗深红色 &lt;color name=&quot;palevioletred&quot;&gt;#DB7093&lt;/color&gt;&lt;!--苍紫罗兰色 --&gt; 苍紫罗兰色 &lt;color name=&quot;goldenrod&quot;&gt;#DAA520&lt;/color&gt;&lt;!--金麒麟色 --&gt; 金麒麟色 &lt;color name=&quot;orchid&quot;&gt;#DA70D6&lt;/color&gt;&lt;!--淡紫色 --&gt; 淡紫色 &lt;color name=&quot;thistle&quot;&gt;#D8BFD8&lt;/color&gt;&lt;!--蓟色 --&gt; 蓟色 &lt;color name=&quot;lightgray&quot;&gt;#D3D3D3&lt;/color&gt;&lt;!--亮灰色 --&gt; 亮灰色 &lt;color name=&quot;tan&quot;&gt;#D2B48C&lt;/color&gt;&lt;!--茶色 --&gt; 茶色 &lt;color name=&quot;chocolate&quot;&gt;#D2691E&lt;/color&gt;&lt;!--巧可力色 --&gt; 巧可力色 &lt;color name=&quot;peru&quot;&gt;#CD853F&lt;/color&gt;&lt;!--秘鲁色 --&gt; 秘鲁色 &lt;color name=&quot;indianred&quot;&gt;#CD5C5C&lt;/color&gt;&lt;!--印第安红 --&gt; 印第安红 &lt;color name=&quot;mediumvioletred&quot;&gt;#C71585&lt;/color&gt;&lt;!--中紫罗兰色 --&gt; 中紫罗兰色 &lt;color name=&quot;silver&quot;&gt;#C0C0C0&lt;/color&gt;&lt;!--银色 --&gt; 银色 &lt;color name=&quot;darkkhaki&quot;&gt;#BDB76B&lt;/color&gt;&lt;!--暗黄褐色 --&gt; 暗黄褐色 &lt;color name=&quot;rosybrown&quot;&gt;#BC8F8F&lt;/color&gt; &lt;!--褐玫瑰红 --&gt; 褐玫瑰红 &lt;color name=&quot;mediumorchid&quot;&gt;#BA55D3&lt;/color&gt;&lt;!--中粉紫色 --&gt; 中粉紫色 &lt;color name=&quot;darkgoldenrod&quot;&gt;#B8860B&lt;/color&gt;&lt;!--暗金黄色 --&gt; 暗金黄色 &lt;color name=&quot;firebrick&quot;&gt;#B22222&lt;/color&gt;&lt;!--火砖色 --&gt; 火砖色 &lt;color name=&quot;powderblue&quot;&gt;#B0E0E6&lt;/color&gt;&lt;!--粉蓝色 --&gt; 粉蓝色 &lt;color name=&quot;lightsteelblue&quot;&gt;#B0C4DE&lt;/color&gt;&lt;!--亮钢兰色 --&gt; 亮钢兰色 &lt;color name=&quot;paleturquoise&quot;&gt;#AFEEEE&lt;/color&gt;&lt;!--苍宝石绿 --&gt; 苍宝石绿 &lt;color name=&quot;greenyellow&quot;&gt;#ADFF2F&lt;/color&gt;&lt;!--黄绿色 --&gt; 黄绿色 &lt;color name=&quot;lightblue&quot;&gt;#ADD8E6&lt;/color&gt;&lt;!--亮蓝色 --&gt; 亮蓝色 &lt;color name=&quot;darkgray&quot;&gt;#A9A9A9&lt;/color&gt;&lt;!--暗灰色 --&gt; 暗灰色 &lt;color name=&quot;brown&quot;&gt;#A52A2A&lt;/color&gt;&lt;!--褐色 --&gt; 褐色 &lt;color name=&quot;sienna&quot;&gt;#A0522D&lt;/color&gt;&lt;!--赭色 --&gt; 赭色 &lt;color name=&quot;darkorchid&quot;&gt;#9932CC&lt;/color&gt;&lt;!--暗紫色--&gt; 暗紫色 &lt;color name=&quot;palegreen&quot;&gt;#98FB98&lt;/color&gt;&lt;!--苍绿色 --&gt; 苍绿色 &lt;color name=&quot;darkviolet&quot;&gt;#9400D3&lt;/color&gt;&lt;!--暗紫罗兰色 --&gt; 暗紫罗兰色 &lt;color name=&quot;mediumpurple&quot;&gt;#9370DB&lt;/color&gt;&lt;!--中紫色 --&gt; 中紫色 &lt;color name=&quot;lightgreen&quot;&gt;#90EE90&lt;/color&gt;&lt;!--亮绿色 --&gt; 亮绿色 &lt;color name=&quot;darkseagreen&quot;&gt;#8FBC8F&lt;/color&gt;&lt;!--暗海兰色 --&gt; 暗海兰色 &lt;color name=&quot;saddlebrown&quot;&gt;#8B4513&lt;/color&gt;&lt;!--重褐色 --&gt; 重褐色 &lt;color name=&quot;darkmagenta&quot;&gt;#8B008B&lt;/color&gt;&lt;!--暗洋红 --&gt; 暗洋红 &lt;color name=&quot;darkred&quot;&gt;#8B0000&lt;/color&gt;&lt;!--暗红色 --&gt; 暗红色 &lt;color name=&quot;blueviolet&quot;&gt;#8A2BE2&lt;/color&gt;&lt;!--紫罗兰蓝色 --&gt; 紫罗兰蓝色 &lt;color name=&quot;lightskyblue&quot;&gt;#87CEFA&lt;/color&gt;&lt;!--亮天蓝色 --&gt; 亮天蓝色 &lt;color name=&quot;skyblue&quot;&gt;#87CEEB&lt;/color&gt;&lt;!--天蓝色 --&gt; 天蓝色 &lt;color name=&quot;gray&quot;&gt;#808080&lt;/color&gt;&lt;!--灰色 --&gt; 灰色 &lt;color name=&quot;olive&quot;&gt;#808000&lt;/color&gt;&lt;!--橄榄色 --&gt;橄榄色&lt;color name=&quot;purple&quot;&gt;#800080&lt;/color&gt;&lt;!--紫色 --&gt; 紫色 &lt;color name=&quot;maroon&quot;&gt;#800000&lt;/color&gt;&lt;!--粟色 --&gt; 粟色 &lt;color name=&quot;aquamarine&quot;&gt;#7FFFD4&lt;/color&gt;&lt;!--碧绿色--&gt; 碧绿色 &lt;color name=&quot;chartreuse&quot;&gt;#7FFF00&lt;/color&gt;&lt;!--黄绿色 --&gt; 黄绿色 &lt;color name=&quot;lawngreen&quot;&gt;#7CFC00&lt;/color&gt;&lt;!--草绿色 --&gt; 草绿色 &lt;color name=&quot;mediumslateblue&quot;&gt;#7B68EE&lt;/color&gt;&lt;!--中暗蓝色 --&gt; 中暗蓝色 &lt;color name=&quot;lightslategray&quot;&gt;#778899&lt;/color&gt;&lt;!--亮蓝灰 --&gt; 亮蓝灰 &lt;color name=&quot;slategrey&quot;&gt;#708090&lt;/color&gt;&lt;!--灰石色 --&gt; 灰石色 &lt;color name=&quot;olivedrab&quot;&gt;#6B8E23&lt;/color&gt;&lt;!--深绿褐色 --&gt; 深绿褐色 &lt;color name=&quot;slateblue&quot;&gt;#6A5ACD&lt;/color&gt;&lt;!--石蓝色 --&gt; 石蓝色 &lt;color name=&quot;dimgray&quot;&gt;#696969&lt;/color&gt;&lt;!--暗灰色 --&gt; 暗灰色 &lt;color name=&quot;mediumaquamarine&quot;&gt;#66CDAA&lt;/color&gt;&lt;!--中绿色 --&gt; 中绿色 &lt;color name=&quot;cornflowerblue&quot;&gt;#6495ED&lt;/color&gt;&lt;!--菊兰色 --&gt; 菊兰色 &lt;color name=&quot;cadetblue&quot;&gt;#5F9EA0&lt;/color&gt;&lt;!--军兰色 --&gt; 军兰色 &lt;color name=&quot;darkolivegreen&quot;&gt;#556B2F&lt;/color&gt;&lt;!--暗橄榄绿 --&gt; 暗橄榄绿 &lt;color name=&quot;indigo&quot;&gt;#4B0082&lt;/color&gt;&lt;!--靛青色 --&gt; 靛青色 &lt;color name=&quot;mediumturquoise&quot;&gt;#48D1CC&lt;/color&gt;&lt;!--中绿宝石 --&gt; 中绿宝石 &lt;color name=&quot;darkslateblue&quot;&gt;#483D8B&lt;/color&gt;&lt;!--暗灰蓝色 --&gt; 暗灰蓝色 &lt;color name=&quot;steelblue&quot;&gt;#4682B4&lt;/color&gt;&lt;!--钢兰色 --&gt; 钢兰色 &lt;color name=&quot;royalblue&quot;&gt;#4169E1&lt;/color&gt;&lt;!--皇家蓝 --&gt; 皇家蓝 &lt;color name=&quot;turquoise&quot;&gt;#40E0D0&lt;/color&gt;&lt;!--青绿色 --&gt; 青绿色 &lt;color name=&quot;mediumseagreen&quot;&gt;#3CB371&lt;/color&gt;&lt;!--中海蓝 --&gt; 中海蓝 &lt;color name=&quot;limegreen&quot;&gt;#32CD32&lt;/color&gt;&lt;!--橙绿色 --&gt; 橙绿色 &lt;color name=&quot;darkslategray&quot;&gt;#2F4F4F&lt;/color&gt;&lt;!--暗瓦灰色 --&gt; 暗瓦灰色 &lt;color name=&quot;seagreen&quot;&gt;#2E8B57&lt;/color&gt;&lt;!--海绿色 --&gt; 海绿色 &lt;color name=&quot;forestgreen&quot;&gt;#228B22&lt;/color&gt;&lt;!--森林绿 --&gt; 森林绿 &lt;color name=&quot;lightseagreen&quot;&gt;#20B2AA&lt;/color&gt;&lt;!--亮海蓝色 --&gt; 亮海蓝色 &lt;color name=&quot;dodgerblue&quot;&gt;#1E90FF&lt;/color&gt;&lt;!--闪兰色 --&gt; 闪兰色 &lt;color name=&quot;midnightblue&quot;&gt;#191970&lt;/color&gt;&lt;!--中灰兰色 --&gt; 中灰兰色 &lt;color name=&quot;aqua&quot;&gt;#00FFFF&lt;/color&gt;&lt;!--浅绿色 --&gt; 浅绿色 &lt;color name=&quot;cyan&quot;&gt;#00FFFF&lt;/color&gt;&lt;!--青色 --&gt; 青色 &lt;color name=&quot;springgreen&quot;&gt;#00FF7F&lt;/color&gt;&lt;!--春绿色--&gt; 春绿色 &lt;color name=&quot;lime&quot;&gt;#00FF00&lt;/color&gt;&lt;!--酸橙色 --&gt; 酸橙色 &lt;color name=&quot;mediumspringgreen&quot;&gt;#00FA9A&lt;/color&gt;&lt;!--中春绿色 --&gt; 中春绿色 &lt;color name=&quot;darkturquoise&quot;&gt;#00CED1&lt;/color&gt;&lt;!--暗宝石绿 --&gt; 暗宝石绿 &lt;color name=&quot;deepskyblue&quot;&gt;#00BFFF&lt;/color&gt;&lt;!--深天蓝色 --&gt; 深天蓝色 &lt;color name=&quot;darkcyan&quot;&gt;#008B8B&lt;/color&gt;&lt;!--暗青色 --&gt; 暗青色 &lt;color name=&quot;teal&quot;&gt;#008080&lt;/color&gt;&lt;!--水鸭色 --&gt; 水鸭色 &lt;color name=&quot;green&quot;&gt;#008000&lt;/color&gt;&lt;!--绿色 --&gt; 绿色 &lt;color name=&quot;darkgreen&quot;&gt;#006400&lt;/color&gt;&lt;!--暗绿色 --&gt; 暗绿色 &lt;color name=&quot;blue&quot;&gt;#0000FF&lt;/color&gt;&lt;!--蓝色 --&gt; 蓝色 &lt;color name=&quot;mediumblue&quot;&gt;#0000CD&lt;/color&gt;&lt;!--中兰色 --&gt; 中兰色 &lt;color name=&quot;darkblue&quot;&gt;#00008B&lt;/color&gt;&lt;!--暗蓝色 --&gt; 暗蓝色 &lt;color name=&quot;navy&quot;&gt;#000080&lt;/color&gt;&lt;!--海军色 --&gt; 海军色 &lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt;&lt;!--黑色 --&gt; 黑色]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android反编译]]></title>
      <url>%2F2015%2F05%2F10%2Fandroid-decompile%2F</url>
      <content type="text"><![CDATA[前言自学Android有段时间了，发现反编译别人的apk读别人的代码，是个提高的好方式，还能获取一些好的图片资源。网上找了些方式，发现过程和方式有一些出路，还是自己写个blog来记录一下。 反编译工具反编译的工具，就选用大家通用的Apktool，dex2jar和JD-GUI。（超链接进入其官网）这三个软件Apktool的安装稍微麻烦点，其他都还好，基本上下载下来解压了就能用。 Apktool(按照官网安装方式，我的是Mac系统，其他系统同样按照官网方式安装) Download Mac wrapper script (Right click, Save Link As apktool) Download apktool-2 (find newest here) Rename downloaded jar to apktool.jar Move both files (apktool.jar &amp; apktool) to /usr/local/bin (root needed) Make sure both files are executable (chmod +x) Try running apktool via cli 基本上按照上面的6个步骤就ok了。虽然很简单，还是解释下吧。 是下载一个shell脚本，保存的名字就是”apktool”,不要带.sh后缀。可以复制到sublimetext，然后保存下。 下载最新的apktool-2 将所下载的jar文件改名为”apktool.jar” 将shell脚本”apktool”和”apktool.jar”放到 “/usr/local/bin”目录下 增加这两个文件可执行权限，chmod a+x file 执行shell apktool就ok了。 安装完毕后可以运行apktool -v查看版本信息 dex2jar和JD-GUI 这两个直接下载，然后解压缩就ok 反编译为了检测下是否能破解，我们先用Apktool反编译，免得我们最后一场空。（只有Apktool能反编译／回编译，我们的破解才有意义）。 新建个apk文件夹，将待破译的apk放进去，之后进到这个目录运行命令: apktool d test.apk apktool b hongbao (hongbao 就是反编译出来的文件夹) 回编译apk过程中会生成build和dist文件夹，编译出来的apk在dist目录下，打开build/apk文件夹会发现少了original文件夹下的META-INF文件夹，也就意味着dist里的apk文件是没有签名的。 我们要用dex2jar将apk转成jar文件，实质是将apk里的classes.dex转成jar。将dex2jar里的d2j_invoke.sh／d2j-dex2jar.sh增加可执行权限。然后进到dex2jar这个文件夹下运行: ./d2j-dex2jar.sh /Users/yanzi/apk/hongbao.apk 得到hongbao-dex2jar.jar文件。 打开JD-GUI，将hongbao-dex2jar.jar拖进去就看到源码了。通过看Java源码对比smali文件，修改后回编译就ok了！ 添加签名 回编译后的apk是安装不成功的，总是提示Failure [INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION]实质是没签名。 生成签名 keytool -genkey -keystore hongbao.keystore -keyalg RSA -validity 10000 -alias hongbao 为apk增加签名 jarsigner -digestalg SHA1 -sigalg MD5withRSA -tsa -verbose -keystore hongbao.keystore -signedjar hongbao-signed.apk hongbao.apk hongbao 注意 最后的”hongbao”就是－alias后面带的，必须保持一致。 如果不带-digestalg SHA1 -sigalg MD5withRSA签名后的apk安装也是不成功的，说INSTALL_PARSE_FAILED_NO_CERTIFICATES的错误，如果不带-tsa会报一个时间方面的警告。 使用apktool是为了能将修改后的代码或者资源重新回编译，改进效果。如果只是单纯想要apk里面的代码，还有一种方式更加简单。 修改apk后缀名为.zip 解压apk.zip 拷贝解压文件夹中的classes.dex文件至dex2jar工具存放目录下 终端进入dex2jar目录，执行./d2j-dex2jar.sh classes.dex 生成classes.dex.dex2jar.jar文件 可以通过JD-GUI工具直接打开查看jar文件中的代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS7搭建Git]]></title>
      <url>%2F2015%2F04%2F29%2Fgit-server%2F</url>
      <content type="text"><![CDATA[前言Git是一个好东西，分布式管理的方式的确使管理代码变得方便很多。而且git致富和linux之父是同一个人，在linux上搭建git十分简单。感觉除了用GitHub公有仓库外，自己搭建一个私有的仓库来储存自己的代码还是蛮有必要的。 git作为一个 分布式代码仓库，其实没有server和client的概念，每个机器上保存的都是一份完整的代码库，不过貌似是大团队的话，为了管理方便，会在服务器装一个管理的东东，俺是小团队，有需要再去研究，小团队手动就口以了 服务端安装Git 安装Git # yum -y install git 创建一个裸仓库 12345cd /srvmkdir GitServercd GitServercd MyBloggit init --bare MyBlog.git //初始化空的Git版本库 创建一个git用户 12useradd gitUserpasswd gitUser 然后把GitServer文件夹赋予git用户 chown -R gitUser: gitUser GitServer 至此，服务端的git搭建就完毕了。 客户端操作Git 在本机创建一个文件夹，进入文件夹 直接clone git clone gitUser@***.**.**.**:/srv/GitServer/project.git //**.**.**.**为你服务器的外网ip 输入git的密码 进入project.git 创建一个测试文件 vim test.txt 输入 Hello Git World! 查看状态 git status 看到待添加的文件test.txt 添加test.txt让git追踪 git add test.txt 提交到版本库，并写上备注信息 git commit test.txt -m &#39;jest a test&#39; 把他推送到服务器的版本库中去，要输入密码 git push origin master 服务端查看 由于在服务器端创建版本库时用的是git init --bare project.git加了个–-bare就是创建一个裸仓库，没有工作区，所以这里只记录了文件的改动，要看是不是同步过来了，需要在git clone一次，看是不是这一次有test.txt啦 git clone gitUser@127.0.0.1:/srv/GitServer/MyBlog.git 输入密码后，下载代码，然后进入仓库查看果然master分支已经有test.txt，打开文件，发现内容一致。 git log查看提交记录,作者时间以及备注信息一致 啦啦啦，私有git搭建完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[改善C++代码的建议]]></title>
      <url>%2F2015%2F04%2F28%2FC%2B%2B-advice%2F</url>
      <content type="text"><![CDATA[学习C++代码的一些建议，记录一下 不要让main函数返回void() —-int main()和int main（int argc，char *argv[]）这两个都是可行的; FALSE/TRUE是int型，false/true是bool型 表达式****==****，最好写成number==nValue，例0==nValue 运算符优先级问题要考虑清楚 使用宏定义时，要用括号完备地保护每一个参数 指针变量一定要初始化 将逗号分隔表达式一定要规范，在条件和循环语句中，表达式的值采用的是最右边的结果; 时刻提防内存溢出。当信息来源不可靠时，要用到内存缓冲区时，必须提高警惕，必须知道内存缓冲区的总长度，并检验内存缓冲区； 拒绝晦涩难懂的函数指针定义，拒绝函数定义中成堆的括号,使用typedef让函数指针更加直观，易维护； 避免包含相同的头文件在不同文件中 { #ifndef _PROJECT_PATH_FILE_H_ #define _PROJECT_PATH_FILE_H_ ……//声明 #endif }; 优化结构体中元素的布局 { a.结构体变量的首地址能够被其最宽基本类型成员的大小所整除； b.结构体每个成员相对于结构体首地址的偏移量（offset）都是成员自身大小的整数倍，如有需要编译器会在成员之间加上填充字节; c.结构体的总大小为结构体最宽基本类型大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。 *把结构体中得变量按照类型大小从小到大依次声明，尽量减少中间的填充字节。 } #pragma pack(1) struct A { int a; char b; short c; } 将强制转型减到最少 不同类型的指针之间不能相互转换（避免在内存访问时存在隐患） const_cast(a)：目的简单明确，使用情形比较单一，易于掌握; dynamic_cast(a):实现慢，代价大； reinterpret_cast(a):不安全； static_cast(a):不安全 优先使用前缀操作符 前缀操作符的效率要优于后缀操作符（整形，长整形可忽略；用户自定义类型，优先使用前缀操作符。） 掌握变量定义的位置与时机 控制变量的作用域，适当位置可减少操作时间； 小心typedef使用中的陷阱 容易与宏定义混淆，typedef声明多个指针对象，形式直观，方便省事。请注意区分typedef与#define之间的不同,不要用理解宏的思维方式对待typedef，typedef声明的新名字具有一定的封装性，更易定义变量。同时还要注意它是一个无“现实意义”的存储类关键字; 尽量不要使用可变参数 缺乏类型检查，类型安全性无从谈起；必须通过其他方式告诉函数所传递的类型，以及参数个数；不支持自定义数据类型; 慎用goto 没有带来太大的正面作用，相反却容易破坏程序的结构性，影响了程序的可读性; 提防隐式转换带来的麻烦 影响数据的精确性，编译器无法正常接受；（为防止精度损失，类型总是被提升为较宽的类型；所有含有小于整形的算术表达式在计算之前其类型都会被转换成整形） 使用非C/C++关键字的具名函数，用operator as_T()替换operato T(); 为单参数的构造函数加上explicit关键字; 正确区分void与void 如果函数没有返回值，那么应将其声明为void类型（不加返回值类型限定的函数，就会被编译器作为返回整型值处理）；如果函数无参数，那么声明函数参数为void；任何类型的指针都可以赋值给void*；void指针进行算法操作是不合法的; 明白在C++中如何使用C 要想在C++中使用大量现成的C程序库，实现C++与C的混编，必须了解extern“C”是怎么回事，明白“C”的使用方式; 使用memcpy（）系列 包含memcpy（），memset（），memcmp（），要注意对象是不是POD。 尽量用new/delete代替malloc/free malloc/free是语言的标准函数库，而new/delete是C++的运算符。malloc/free无法满足创建动态对象的要求；new不仅能够完成动态内存分配，还能完成初始化工作，稳妥的构造对象；delete不仅能完成内存的释放，还能对对象进行清理。 灵活地使用不同风格的注释 版权和版本声明，使用C风格的/ \/;内嵌注释用//；宏尾端的注释用/ / 尽量使用C++标准的iostream C++ iostream程序库中的类与C stream函数虽然各有优点，但是一般推荐使用前者，为类型安全与可扩充性对于我们更有吸引力，所以建议使用iostream; 尽量采用C++风格的强制类型转换 尽量用const、enum、inline替换#define 宏定义并不在编译范围内，使得程序难于分析，难于调试；使用常量可以避免目标码的多分复制；用const修饰指针建议使用更加高级的const string形式。对于简单的常量，应该尽量使用const对象或枚举类型的数据，避免使用#define。对于形似函数的宏，尽量使用内联函数，避免使用#define。尽量将工作交给编译器而不是预处理器; 用引用代替指针 从编码实践角度来看，指针与引用并无太大不同。在大多数情况下，指针可用索引类型完美代替，并且其实现代码更简洁清晰，更加易于理解 区分内存分配的方式 栈效率高一点，而堆较灵活 new/delete与new[]/delete[]必须配对使用 区分new的三种形态 new内存失败后的正确处理 当使用new申请一块内存失败时，抛出异常std::bad_alloc是C++标准中规定的标准行为，所以推荐使用try{p=new int[SIZE];}catch(std::bad_alloc){…}的处理方式 明晰class与struct之间的区别 关于使用大括号初始化：class与struct定义了构造函数就不能用大括号初始化，如果没有定义struct可以用大括号初始化，而class只有在所有成员变量全是public情况下才能用大括号初始化; class默认成员访问权限是private，struct中则是public class继承是private，struct继承是public]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何搭建LAMP环境]]></title>
      <url>%2F2015%2F04%2F23%2Fbuild-lamp%2F</url>
      <content type="text"><![CDATA[前言由于买了阿里云学生机，就想着自己在服务器上搭建网站。首先给服务器搭建LAMP环境，以后搭建网站就有着落了。 安装Apache服务 安装 yum -y install httpd 开启apache服务 systemctl start httpd.service 设置apache服务开机启动 systemctl enable httpd.service 验证Apache服务是否安装成功 在本机浏览器中输入阿里云服务器的外网ip，出现Testing 123… Apache页面说明安装成功。 安装PHP 安装 yum -y install php 重启Apache服务 systemctl restart httpd.service或者systemctl restart httpd 写一个php文件在浏览器中运行一次 vi /var/www/html/info.php——–输入&lt;?php phpinfo(); ?&gt;——-在本机浏览器中输入ip/info.php,出现php version说明php安装成功。 安装MySqlCentOS 7.0 安装MariaDB，这是MySql的一个分支，是由MySql的创始人Michael Widenius带领开发的，团队依旧，所以两者使用基本没有太大的区别。 安装 yum install mariadb-server -y 开启MySQL服务 systemctl start mariadb.service 设置开机启动MySQL服务 systemctl enable mariadb.service 设置root帐户的密码 mysql_secure_installation 之后会让你输入当前mysql的密码，直接Enter。之后输入新密码，以及确认密码，后面的内容看你的情况进行选择是或者否。 想要确认密码是否已经改变，可以输入mysql -uroot -p进行测试。 将PHP和MySQL关联起来输入yum -y install php-mysql 安装常用的PHP模块 安装：yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel 重启Apache服务 systemctl restart httpd.service 结束然后，再次在浏览器中运行info.php，你会看到安装的模块的信息。至此，LAMP环境就搭建好了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github pages和Jekyll搭建]]></title>
      <url>%2F2015%2F04%2F11%2Fbuild-the-githubpages%2F</url>
      <content type="text"><![CDATA[前言最近才发现Github原来也可以支持博客的搭建，利用Jekyll这个静态网站生成器，可以很快搭建一个博客来记录自己开发学习生活的一些知识点和经验。之前的WordPress用的不怎么顺手，一台服务器既要搭建博客，又要玩些其他小应用还是不怎么方便，所以既然有了这个免费的技术分享区还是可以好好利用的。 Step 1.Github选址GitHub是拿来干什么的就不多说了,GitHub Pages(Website for you and your project.),这就是我们所需要搭建的博客了，通过Git方式对博客进行管理，这种方式免费，安全，快捷。 新建repository名为username.github.io，username为你github的用户名。那么他的master分支上的文件就能在username.github.io的根目录访问到。 创建仓库后，进入Setting，拉动滚动条至GitHub Pages那一栏，点击Automatic page generator. 进入创建用户页面，可以自己编辑，也可以从readme加载。 点击continue to layout，继续选择主题。选好后点击PUBLISH，发布，整个技术博客站点的CSS，HTML和IMG都会导入到你的仓库中。 最后在浏览器中输入username.github.io就可以进入到你的博客主页中了。ps.觉得域名丑的，或者不想用这个域名的，可以花钱买个域名或者把自己已经买的域名映射过去。在仓库根路径下创建一个名为”CNAME”的文件，注意没有后缀。文件中填入你所要指向的域名。这样访问 http://username.github.io 时浏览器就接收到重定向指令,跳转到CNAME里面指定的域名去了。接着还需要到你域名的服务商那里修改域名的记录，通过在终端输入ping username.github.io可以获得博客的ip，添加”www”和”@”两条记录，这样就完成修改域名了。 Git教程-廖雪峰 Git使用教程图文详解 Step 2.本地环境搭建这一步不是必须的，但是强烈建议完成。这样，在博客发布之前方便调试检验一下。 首先更新本机上的ruby。 安装RVM $ curl -L get.rvm.io | bash -s stable $ source ~/.bashrc $ source ~/.bash_profile 测试安装是否正常rvm -v 用RVM升级Ruby 查看当前ruby版本$ ruby -v 列出已知的ruby版本$ rvm list known 安装最新版本ruby$ rvm install x.x.x 查看当前ruby版本$ ruby -v 安装Bundle $ gem install bundle 在根目录下创建一个叫Gemfile的文件，注意没有后缀 在Gemfile文件中输入source &#39;https://gems.ruby-china.org//&#39;gem &#39;github-pages&#39; 保存后，在命令行中执行$ bundle install $ bundle update 启动转化和本地服务 $ bundle exec jekyll serve 安装Jekyll gem install jekyll 在你希望存放博客的目录下输入jekyll new your-site-name 进入cd your-site-name 启动转化和本地服务 $ bundle exec jekyll serve --watch 打开浏览器http://localhost:4000就可以本地进行查看和调试你的网站了。 Step 3.Jekyll Jekyll目录 _config.yml 是配置文件，你可以在里面配置你博客会用到的常量，比如博客名，邮件 _includes：就是你文章各个部分的html文件，可以在布局中包含这些文件 _layouts：存放模板。就是你网页的布局，主页布局，文章布局。当然不是指CSS那样的布局，是指，你包含哪些基本的内容到页面上。包含的内容就是includes里面的文件。 _posts: 存放博客文章 index：博客主页 CNAME文件：域名地址 CSS：存放博客所用CSS JS: 存放博客所用JavaScript 如何发表文章 文章的写法，在Markdown开头加上一段： --- layout: posttitle: &quot;Welcome to Jekyll!&quot; date: 2014-01-27 21:57:11 categories: Blog --- 文件命名格式: 时间加标题 比如：2015-08-15-HowTOBuildBlog.mdok，你可以写文章了，放入_post文件夹即可。 修改主题 学习学习前端，并且研究下Jekyll官网，自己修改。或者fork别人在github写好的模板进行修改 Step 4.同步本地和GitHub博客文件使用git命令或者用图形化客户端直接进行文件同步，方法简单不详述。 Step 5.Markdown使用这种语法写文件简单的多了，附上markdown语法和心得 参考网址：http://www.jianshu.com/p/9a6bc31d329dhttps://zhuanlan.zhihu.com/p/21333968 Step 6.代码高亮代码： 在文中使用效果：12345public void hello()&#123; int a = 0; int b = 1; int c = a + b;&#125; Step 7.MarkDown解析器现在github推荐kramdown作为markdown解析器。其解析速度很快比PHP markdown和Maruku都要快几倍。kramdown有很多一般markdown所没有的语法特点，包括和GFM也有差异。另外也可以很方便地作为文件转换使用。kramdown和markdown较大的差异比较 Step 8.生成目录没有目录还是一件很苦恼的事情。特别是长篇博客，所以去查了markdown如何生成目录，在此更新一下。kramdown默认是支持TOC。在_config.yml中的配置方式为：123markdown: kramdownkramdown: input: GFM 在编写文章时，插入下面代码，渲染之后就可以生成TOC了： Step 9.插入数学公式在/source/_includes/head.html中将下面的代码插入&lt;head&gt;和&lt;/head&gt;标签之间。12345678910111213141516171819202122232425262728293031&lt;!-- mathjax config similar to math.stackexchange --&gt;&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true &#125; &#125;);&lt;/script&gt;&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;);&lt;/script&gt;&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for(i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += ' has-jax'; &#125; &#125;);&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt; 接着使用LaTeX表达式进行编辑。]]></content>
    </entry>

    
  
  
</search>
