<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android-RecyclerView详细学习]]></title>
      <url>%2F2017%2F06%2F25%2Fandroid-recyclerview%2F</url>
      <content type="text"><![CDATA[RecyclerViewRecyclerView是什么？RecylerView是support-v7包中的新组件，是一个强大的滑动组件，与经典的ListView相比，同样拥有item回收复用的功能，这一点从它的名字recylerview即回收view也可以看出。看到这也许有人会问，不是已经有ListView了吗，为什么还要RecylerView呢？这就牵扯到第二个问题了。 RecyclerView的优点是什么？根据官方的介绍RecylerView是ListView的升级版，既然如此那RecylerView必然有它的优点，现就RecylerView相对于ListView的优点罗列如下： RecylerView封装了viewholder的回收复用，也就是说RecylerView标准化了ViewHolder，编写Adapter面向的是ViewHolder而不再是View了，复用的 逻辑被封装了，写起来更加简单。 提供了一种插拔式的体验，高度的解耦，异常的灵活，针对一个Item的显示RecylerView专门抽取出了相应的类，来控制Item的显示，使其的扩展性非常强。例如：你想控制横向或者纵向滑动列表效果可以通过LinearLayoutManager这个类来进行控制(与GridView效果对应的是GridLayoutManager,与瀑布流对应的还有StaggeredGridLayoutManager等)，也就是说RecylerView不再拘泥于ListView的线性展示方式，它也可以实现GridView的效果等多种效果。你想控制Item的分隔线，可以通过继承RecylerView的ItemDecoration这个类，然后针对自己的业务需求去抒写代码。 可以控制Item增删的动画，可以通过ItemAnimator这个类进行控制，当然针对增删的动画，RecylerView有其自己默认的实现。 RecyclerView的用法RecyclerView的初步用法(包括RecyclerView.Adapter用法)123456789101112recyclerView = (RecyclerView) findViewById(R.id.recyclerView); LinearLayoutManager layoutManager = new LinearLayoutManager(this ); //设置布局管理器 recyclerView.setLayoutManager(layoutManager); //设置为垂直布局，这也是默认的 layoutManager.setOrientation(OrientationHelper. VERTICAL); //设置Adapter recyclerView.setAdapter( recycleAdapter); //设置分隔线 recyclerView.addItemDecoration( new DividerGridItemDecoration(this )); //设置增加或删除条目的动画 recyclerView.setItemAnimator( new DefaultItemAnimator()); 可以看到对RecylerView的设置过程，比ListView要复杂一些，这也是RecylerView高度解耦的表现，虽然代码抒写上有点复杂，但它的扩展性是极高的。 RecyclerView的生命周期一个RecyclerView的Item加载是有顺序的，类似于Activity的生命周期（姑且这么叫把），具体可以对adapter的每个方法进行重写打下日志进行查看，具体大致为： getItemViewType(获取显示类型，返回值可在onCreateViewHolder中拿到，以决定加载哪种ViewHolder) onCreateViewHolder(加载ViewHolder的布局) onViewAttachedToWindow（当Item进入这个页面的时候调用） onBindViewHolder(将数据绑定到布局上，以及一些逻辑的控制就写这啦) onViewDetachedFromWindow（当Item离开这个页面的时候调用） onViewRecycled(当Item被回收的时候调用)tips1:如果你调用了： 1viewHolder.setIsRecyclable(false); 那么这个Item的onViewRecycled将永远不会调用。tips2:如果你的界面出现了错乱的现象，请调用如上代码可能能简单粗暴的解决，当然代价是损失少许的性能表现了。 RecyclerView.Adapter来看看它的Adapter的写法，RecyclerView的Adapter与ListView的Adapter还是有点区别的，RecyclerView.Adapter，需要实现3个方法： onCreateViewHolder()这个方法主要生成为每个Item inflater出一个View，但是该方法返回的是一个ViewHolder。该方法把View直接封装在ViewHolder中，然后我们面向的是ViewHolder这个实例，当然这个ViewHolder需要我们自己去编写。直接省去了当初的convertView.setTag(holder)和convertView.getTag()这些繁琐的步骤。 onBindViewHolder()这个方法主要用于适配渲染数据到View中。方法提供给你了一个viewHolder，而不是原来的convertView。 getItemCount()这个方法就类似于BaseAdapter的getCount方法了，即总共有多少个条目。 notifyDataSetChanged()刷新所有,notifyDataSetChanged最终会使adapter的数据重新绑定，即会重新调用adapter里的onBindViewHolder方法，从而使item的position得到了更新。 notifyItemChanged(int position)position数据发生了改变，那调用这个方法，就会回调对应position的onBindViewHolder()方法了 notifyItemRangeChanged(int positionStart, int itemCount)刷新从positionStart开始itemCount数量的item了（这里的刷新指回调onBindViewHolder()方法） notifyItemInserted(int position)在第position位置被插入了一条数据的时候可以使用这个方法刷新，注意这个方法调用后会有插入的动画，这个动画可以使用默认的，也可以自己定义 notifyItemMoved(int fromPosition, int toPosition)从fromPosition移动到toPosition为止的时候可以使用这个方法刷新 notifyItemRangeInserted(int positionStart, int itemCount)批量添加 notifyItemRemoved(int position)第position个被删除的时候刷新，同样会有动画 notifyItemRangeRemoved(int positionStart, int itemCount)批量删除 onAttachedToRecyclerView (RecyclerView recyclerView)在RecyclerView.setAdapter(adapter)时进行调用 onViewAttachedToWindow(VH holder)当Item进入这个页面的时候调用 onViewDetachedFromWindow(VH holder)当Item离开这个页面的时候调用 onViewRecycled(VH holder)当Item被回收的时候调用 RecyclerView.ItemDecoration添加分隔线我们可以创建一个继承RecyclerView.ItemDecoration类来绘制分隔线，通过ItemDecoration可以让我们每一个Item从视觉上面相互分开来，例如ListView的divider非常相似的效果。也可以不设置ItemDecoration，那说明ItemDecoration我们并不是强制需要使用，作为我们开发者可以设置或者不设置Decoration的。实现一个ItemDecoration，系统提供的ItemDecoration是一个抽象类，内部除去已经废弃的方法以外，我们主要实现以下三个方法: 1234567891011public static abstract class ItemDecoration &#123; public void onDraw(Canvas c,RecyclerView parent,State state) &#123; onDraw(c,parent); &#125; public void onDrawOver(Canvas c,RecyclerView parent,State state) &#123; onDrawOver(c,parent); &#125; public void getItemOffsets(RectoutRect, View view,RecyclerView parent,State state) &#123; getItemOffsets(outRect,((LayoutParams)view.getLayoutParams()).getViewLayoutPosition(),parent); &#125; &#125; onDraw方法先于drawChildren onDrawOver在drawChildren之后，一般我们选择复写其中一个即可。 getItemOffsets 可以通过outRect.set()为每个Item设置一定的偏移量，主要用于绘制Decorator。 又因为当我们RecyclerView在进行绘制的时候会进行绘制Decoration,那么会去调用onDraw和onDrawOver方法，那么这边我们其实只要去重写onDraw和getItemOffsets这两个方法就可以实现啦。然后LayoutManager会进行Item布局的时候，会去调用getItemOffset方法来计算每个Item的Decoration合适的尺寸，下面我们来具体实现一个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.example.reclerviewpractice; import android.content.Context; import android.content.res.TypedArray; import android.graphics.Canvas; import android.graphics.Rect; import android.graphics.drawable.Drawable; import android.support.v7.widget.LinearLayoutManager ; import android.support.v7.widget.RecyclerView; import android.view.View; public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; private static final int[] ATTRS = new int[]&#123; android.R.attr. listDivider &#125;; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS ); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); &#125; public void setOrientation( int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123; throw new IllegalArgumentException( "invalid orientation"); &#125; mOrientation = orientation; &#125; @Override public void onDraw(Canvas c, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125;else&#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125; &#125; 改变分隔线样式那么怎么更改分隔线的样式呢？在上面的DividerItemDecoration这个类中可以看到这个分隔线是跟ListView一样的，即系统的默认的样式，因此我们可以在styles的xml文件中进行更改，更改如下： 12345&lt;!-- Application theme. --&gt; &lt;style name ="AppTheme" parent="AppBaseTheme"&gt; &lt;!-- All customizations that are NOT specific to a particular API-level can go here. --&gt; &lt;item name= "android:listDivider"&gt;@drawable/divider &lt;/item &gt; &lt;/style &gt; divider的内容如下： 12345678910&lt;?xml version="1.0" encoding= "utf-8"?&gt; &lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle" &gt; &lt;!-- 填充的颜色 --&gt; &lt;solid android:color ="@color/color_red"/&gt; &lt;!-- 线条大小 --&gt; &lt;size android:height ="1dp" android:width ="1dp"/&gt; &lt;/shape&gt; 看到这肯定会有人说，这尼玛，好麻烦，还不如ListView简单呢，从上面的代码量看来确实是使用起来很复杂，但是如果此时你想将这个列表以GridView的形式展示出来，用RecylerView仅仅是换一行代码的事情. RecyclerView.ViewHolder getPosition()在API22的时候已经被废弃，因为它在异步处理器更新的时候不能准确表示数据，是模棱两可的。请根据你所使用的场景参照使用getLayoutPosition() 和 getAdapterPosition() getAdapterPosition()在调用notifyDataSetChanged之后并不能马上获取Adapter中的position, 要等布局结束之后才能获取到.在调用notifyItemInserted(0)之后能通过getAdapterPosition()获取适配器位置即使新的布局还没有计算。,如果你做一些用户点击,如果getAdapterPosition()返回NO_POSITION,最好忽略点击,因为你不知道用户点击(除非你有其他机制,如稳定的id查找条目)。 getLayoutPosition()假设您正在使用LayoutManager或者想要访问ViewHolder当前点击的项目。在这种情况下,您应该使用getLayoutPosition()来获取当前布局位置。mRecyclerView.findViewHolderForLayoutPosition(myViewHolder.getLayoutPosition() - 1) RecyclerView.ItemAnimator animateAppearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)当RecyclerView中的item显示到屏幕上时调用此方法。传入的layout之后的ViewHolder对象。 animateDisappearance(RecyclerView.ViewHolder viewHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)当RecyclerView中的item在屏幕上由可见变为不可见时调用此方法。传入的layout之后的ViewHolder对象。 animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, RecyclerView.ItemAnimator.ItemHolderInfo preLayoutInfo, RecyclerView.ItemAnimator.ItemHolderInfo postLayoutInfo)当RecyclerView中的item状态发生改变时调用此方法(notifyItemChanged(position))。方法中传入了layout之前的ViewHolder和layout之后的ViewHolder对象，通过这两个ViewHolder对象获取其中的itemView进行动画效果。 runPendingAnimations()统筹RecyclerView中所有的动画，统一启动执行 setRemoveDuration(long removeDuration)/getRemoveDuration()设置删除Item动画的延迟时间 setMoveDuration(long moveDuration)/getMoveDuration()设置移动Item动画的延迟时间 setChangeDuration(long changeDuration)/getChangeDuration()设置改变Item动画的延迟时间 setAddDuration(long addDuration)/getAddDuration()设置添加Item动画的延迟时间 recordPostLayoutInformation(RecyclerView.State state, RecyclerView.ViewHolder viewHolder)布局完成后对这个方法进行调用，记录view的必要信息。 onAnimationStarted(RecyclerView.ViewHolder viewHolder)当一个新动画添加到这个ViewHolder上，调用此方法 onAnimationFinished(RecyclerView.ViewHolder viewHolder)在dispatchAnimationFinished(ViewHolder)这个方法调用后调用 obtainHolderInfo()获取ViewHolder保存的RecyclerView.ItemAnimator.ItemHolderInfo信息 isRunning()判断是否有Item动画在运行 endAnimations()停止所有动画 endAnimation(RecyclerView.ViewHolder item)停止指定动画 RecyclerView.LayoutManagerRecyclerView.LayoutManager是一个抽象类，系统为我们提供了三个实现类 LinearLayoutManager即线性布局，这个是在上面的例子中我们用到的布局 GridLayoutManager即表格布局 StaggeredGridLayoutManager即流式布局，如瀑布流效果假如将上述例子换成GridView的效果，那么相应的代码应该这样改 给RecyclerView的Item添加点击事件ListView给我们提供了onItemClickListener的监听器，但对于RecyclerView来讲，非常可惜的是，该控件没有给我们提供这样的内置监听器方法，不过我们可以进行改造实现，可以这样实现Item的点击事件的监听，在我们的adapter中增加这两个方法 12345678public interface OnItemClickListener&#123; void onClick( int position); void onLongClick( int position);&#125;public void setOnItemClickListener(OnItemClickListener onItemClickListener )&#123; this. mOnItemClickListener=onItemClickListener;&#125; 然后onBindViewHolder方法要做如下更改 12345678910111213141516171819@Override public void onBindViewHolder(MyViewHolder holder, final int position) &#123; holder. tv.setText( mDatas.get(position)); if( mOnItemClickListener!= null)&#123; holder. itemView.setOnClickListener( new OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnItemClickListener.onClick(position); &#125; &#125;); holder. itemView.setOnLongClickListener( new OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; mOnItemClickListener.onLongClick(position); return false; &#125; &#125;); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-View详细学习]]></title>
      <url>%2F2017%2F06%2F20%2Fandroid-view%2F</url>
      <content type="text"><![CDATA[View的属性 android:alpha关联方法: setAlpha(float) 属性说明: 视图透明度，值在0-1之间。0为完全透明，1为完全不透明。 android:background关联方法: setBackgroundResource(int) 属性说明: 视图背景 android:clickable关联方法: setClickable(boolean) 属性说明: 视图是否可点击 android:contentDescription关联方法: setContentDescription(CharSequence) 属性说明: 设置View的备注说明，作为一种辅助功能提供,为一些没有文字描述的View提供说明 android:drawingCacheQuality关联方法: setDrawingCacheQuality(int) 属性说明: “设置绘图时半透明质量。有可以取以下3个值 auto——默认，由框架决定 high——高质量，使用较高的颜色深度，消耗更多的内存 low——低质量，使用较低的颜色深度，但是用更少的内存” android:duplicateParentState关联方法: 属性说明: 如果设置此属性，将直接从父容器中获取绘图状态（光标，按下等） android:fadeScrollbars关联方法: setScrollbarFadingEnabled(boolean) 属性说明: 定义在ScrollBar没有使用时，是否褪色。 android:fadingEdgeLength关联方法: getVerticalFadingEdgeLength() 属性说明: 设置边框渐变的长度。 android:filterTouchesWhenObscured关联方法: setFilterTouchesWhenObscured(boolean) 属性说明: view所在窗口被其它可见窗口遮住时，是否过滤触摸事件。 android:fitsSystemWindows关联方法: setFitsSystemWindows(boolean) 属性说明: 设置布局调整时是否考虑系统窗口（如状态栏） android:focusable关联方法: setFocusable(boolean) 属性说明: 设置是否获得焦点。若有requestFocus()被调用时，后者优先处理。注意在表单中想设置某一个如EditText获取焦点，光设置这个是不行的，需要将这个EditText前面的focusable都设置为false才行。在Touch模式下获取焦点需要设置focusableInTouchMode为true。 android:focusableInTouchMode关联方法: setFocusableInTouchMode(boolean) 属性说明: 设置在Touch模式下View是否能取得焦点。 android:hapticFeedbackEnabled关联方法: setHapticFeedbackEnabled(boolean) 属性说明: 是否启用触摸反馈，启用后就是在点击等操作时会有震动等反馈效果 android:id关联方法: setId(int) 属性说明: 给当前View设置一个在当前layout.xml中的唯一编号，可以通过调用View.findViewById() 或Activity.findViewById()根据这个编号查找到对应的View。不同的layout.xml之间定义相同的id不会冲突。 android:importantForAccessibility关联方法: setImportantForAccessibility(int) 属性说明: 设置可达性的重要性 android:isScrollContainer关联方法: setScrollContainer(boolean) 属性说明: 设置当前View为滚动容器。这里没有测试出效果来，ListView/ GridView/ ScrollView根本就不用设置这个属性，而EdidText设置android:scrollbars也能出滚动条 android:keepScreenOn关联方法: setKeepScreenOn(boolean) 属性说明: 视图在可见的情况下是否保持唤醒状态。 android:layerType关联方法: setLayerType(int,Paint) 属性说明: “设置指定层的类型，可以取以下3个值： none——不指定 software——软件层。 hardware——硬件层。使用硬件加速。” android:layoutDirection关联方法: setLayoutDirection(int) 属性说明: 定义布局图纸的方向 android:longClickable关联方法: setLongClickable(boolean) 属性说明: 是否响应长点击事件 android:minHeight关联方法: setMinimumHeight(int) 属性说明: 设置视图最小高度 android:minWidth关联方法: setMinimumWidth(int) 属性说明: 设置视图最小宽度 android:nextFocusDown关联方法: setNextFocusDownId(int) 属性说明: 向下移动焦点时，下一个获取焦点的view的id android:nextFocusForward关联方法: setNextFocusForwardId(int) 属性说明: 下一个获取焦点的view的id android:nextFocusLeft关联方法: setNextFocusLeftId(int) 属性说明: 向左移动焦点时，下一个获取焦点的view的id android:nextFocusRight关联方法: setNextFocusRightId(int) 属性说明: 向右移动焦点时，下一个获取焦点的view的id android:nextFocusUp关联方法: setNextFocusUpId(int) 属性说明: 向上移动焦点时，下一个获取焦点的view的id android:onClick关联方法: 属性说明: 点击时，要调用的方法的名称。 android:padding关联方法: setPaddingRelative(int,int,int,int) 属性说明: 设置上下左右的边距 android:paddingBottom关联方法: setPaddingRelative(int,int,int,int) 属性说明: 下边距 android:paddingEnd关联方法: setPaddingRelative(int,int,int,int) 属性说明: 与android:paddingRight相同 android:paddingLeft关联方法: setPadding(int,int,int,int) 属性说明: 左边距 android:paddingRight关联方法: setPadding(int,int,int,int) 属性说明: 右边距 android:paddingStart关联方法: setPaddingRelative(int,int,int,int) 属性说明: android:paddingLeft相同 android:paddingTop关联方法: setPaddingRelative(int,int,int,int) 属性说明: 上边距 android:requiresFadingEdge关联方法: setVerticalFadingEdgeEnabled(boolean) 属性说明: 定义滚动时边缘是否褪色 android:rotation关联方法: setRotation(float) 属性说明: 旋转度数 android:rotationX关联方法: setRotationX(float) 属性说明: 水平旋转度数 android:rotationY关联方法: setRotationY(float) 属性说明: 竖直旋转度数 android:saveEnabled关联方法: setSaveEnabled(boolean) 属性说明: 在配置改变等情况出现时是否保存view的状态数据。如果你的view有id，那默认系统就会帮你保存。 android:scaleX关联方法: setScaleX(float) 属性说明: 水平方向缩放比例 android:scaleY关联方法: setScaleY(float) 属性说明: 竖直方向缩放比例 android:scrollX关联方法: 属性说明: x方向的滚动偏移。即在水平方向滚动了多少距离 android:scrollY关联方法: 属性说明: y方向的滚动偏移。即在竖直方向滚动了多少距离 android:scrollbarAlwaysDrawHorizontalTrack关联方法: 属性说明: 是否总是绘制水平滚动条的滚动轨道 android:scrollbarAlwaysDrawVerticalTrack关联方法: 属性说明: 是否总是绘制竖直滚动条的滚动轨道 android:scrollbarDefaultDelayBeforeFade关联方法: setScrollBarDefaultDelayBeforeFade(int) 属性说明: 滚动条在n毫秒后开始淡出。 android:scrollbarFadeDuration关联方法: setScrollBarFadeDuration(int) 属性说明: 滚动条用多长时间淡出完毕。 android:scrollbarSize关联方法: setScrollBarSize(int) 属性说明: 设置滚动条的尺寸。垂直滚动条的宽度、水平滚动条的高度 android:scrollbarStyle关联方法: setScrollBarStyle(int) 属性说明: “滚动条的风格。共4组值： insideOverlay——内贴图 insideInset——内插图 outsideOverlay——外贴图 outsideInset——外插图。 inside就是滚动条在绘制在padding以内；outside就是不需要绘制在padding内（即view的边界处）；Overlay是贴图，就是直接覆盖在内容的上方，这样内容可能会显示到滚动条下方去；Inset是插图，就是会在对应padding上加上滚动条的宽度，以不让内容显示到滚动条下面去。” android:scrollbarThumbHorizontal关联方法: 属性说明: 水平滚动块的drawable对象 android:scrollbarThumbVertical关联方法: 属性说明: 竖直滚动块的drawable对象 android:scrollbarTrackHorizontal关联方法: 属性说明: 水平滚动条滚动轨道的drawable对象 android:scrollbarTrackVertical关联方法: 属性说明: 竖直滚动条滚动轨道的drawable对象 android:scrollbars关联方法: 属性说明: “设置可显示的滚动条。有3个取值: none——不显示滚动条 horizontal——显示水平滚动条 vertical——显示竖直滚动条” android:soundEffectsEnabled关联方法: setSoundEffectsEnabled(boolean) 属性说明: 点击或触摸该view时，是否需要有声音效果 android:tag关联方法: 属性说明: string标识。类似id，id是整数标识。 android:textAlignment关联方法: setTextAlignment(int) 属性说明: 设置文本的显示方式。 android:textDirection关联方法: setTextDirection(int) 属性说明: 设置文本的显示方向。 android:transformPivotX关联方法: setPivotX(float) 属性说明: 水平方向偏转量 android:transformPivotY关联方法: setPivotY(float) 属性说明: 竖直方向偏转量 android:translationX关联方法: setTranslationX(float) 属性说明: 水平方向的移动距离 android:translationY关联方法: setTranslationY(float) 属性说明: 竖直方向的移动距离 android:visibility关联方法: setVisibility(int) 属性说明: “view的可见性。有3个取值： gone——不可见，同时不占用view的空间； invisible——不可见，但占用view的空间； visible——可见” TextView属性说明 下面对TextView的属性进行说明android:autoLink关联方法: setAutoLinkMask(int)属性说明: 设置是否“当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接”。可选值(none/web/email/phone/map/all) android:autoText关联方法: setKeyListener(KeyListener)属性说明: 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。 android:bufferType关联方法: setText(CharSequence,TextView.BufferType)属性说明: 指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。 android:capitalize关联方法: setKeyListener(KeyListener)属性说明: 设置自动大写属性。比如设置为2，自动大写单词首字符；设置为1，自动大写每句话的首字母等等。 android:cursorVisible关联方法: setCursorVisible(boolean)属性说明: 设定光标为显示/隐藏，默认显示。 android:digits关联方法: setKeyListener(KeyListener)属性说明: 设置允许输入哪些字符。如“1234567890.+-*/%\n()” android:drawableBottom关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)属性说明: 在text的下方输出一个drawable。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。 android:drawableEnd关联方法: setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)属性说明: 在文本结尾处显示drawable对象。它的值可以是其它资源的引用，比如，”@[+][package:]type:name”或者”?[package:][type:]name”；也可以是颜色值，如”#rgb”, “#argb”, “#rrggbb”, or “#aarrggbb”。 android:drawableLeft关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)属性说明: 在text的左边输出一个drawable。 android:drawablePadding关联方法: setCompoundDrawablePadding(int)属性说明: 设置text与drawable的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。 android:drawableRight关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)属性说明: 在text的右边输出一个drawable。 android:drawableStart关联方法: setCompoundDrawablesRelativeWithIntrinsicBounds(int,int,int,int)属性说明: 在文本开始处显示drawable对象。它的值可以是其它资源的引用，比如，”@[+][package:]type:name”或者”?[package:][type:]name”；也可以是颜色值，如”#rgb”, “#argb”, “#rrggbb”, or “#aarrggbb”。 android:drawableTop关联方法: setCompoundDrawablesWithIntrinsicBounds(int,int,int,int)属性说明: 在text的正上方输出一个drawable。 android:editable关联方法: 属性说明: 设置是否可编辑。这里无效果，在EditView中才有效果。 android:editorExtras关联方法: setInputExtras(int)属性说明: 设置文本的额外的输入数据。在EditView中才有效果。 android:ellipsize关联方法: setEllipsize(TextUtils.TruncateAt)属性说明: 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动) android:ems关联方法: setEms(int)属性说明: 设置TextView的宽度为N个字符的宽度。 android:fontFamily关联方法: setTypeface(Typeface)属性说明: 文本的字形体系。 android:freezesText关联方法: setFreezesText(boolean)属性说明: 设置保存文本的内容以及光标的位置。 android:gravity关联方法: setGravity(int)属性说明: 设置文本位置，如设置成“center”，文本将居中显示。 android:height关联方法: setHeight(int)属性说明: 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米) android:hint关联方法: setHint(int)属性说明: Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。 android:imeActionId关联方法: setImeActionLabel(CharSequence,int)属性说明: 设置IME动作ID。 android:imeActionLabel关联方法: setImeActionLabel(CharSequence,int)属性说明: 设置IME动作标签。在EditView再做说明。 android:imeOptions关联方法: setImeOptions(int)属性说明: 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。 android:includeFontPadding关联方法: setIncludeFontPadding(boolean)属性说明: 设置文本是否包含顶部和底部额外空白，默认为true。 android:inputMethod关联方法: setKeyListener(KeyListener)属性说明: 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。 android:inputType关联方法: setRawInputType(int)属性说明: 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。 android:lineSpacingExtra关联方法: setLineSpacing(float,float)属性说明: 设置行间距。 android:lineSpacingMultiplier关联方法: setLineSpacing(float,float)属性说明: 设置行间距的倍数。如”1.2” android:lines关联方法: setLines(int)属性说明: 设置文本的行数，设置两行就显示两行，即使第二行没有数据。 android:linksClickable关联方法: setLinksClickable(boolean)属性说明: 设置链接是否点击连接，即使设置了autoLink。 android:marqueeRepeatLimit关联方法: setMarqueeRepeatLimit(int)属性说明: 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。 android:maxEms关联方法: setMaxEms(int)属性说明: 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:maxHeight关联方法: setMaxHeight(int)属性说明: 设置文本区域的最大高度 android:maxLength关联方法: setFilters(InputFilter)属性说明: 限制显示的文本长度，超出部分不显示。 android:maxLines关联方法: setMaxLines(int)属性说明: 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。 android:maxWidth关联方法: setMaxWidth(int)属性说明: 设置文本区域的最大宽度 android:minEms关联方法: setMinEms(int)属性说明: 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:minHeight关联方法: setMinHeight(int)属性说明: 设置文本区域的最小高度 android:minLines关联方法: setMinLines(int)属性说明: 设置文本的最小行数，与lines类似。 android:minWidth关联方法: setMinWidth(int)属性说明: 设置文本区域的最小宽度 android:numeric关联方法: setKeyListener(KeyListener)属性说明: 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。 android:password关联方法: setTransformationMethod(TransformationMethod)属性说明: 以小点”.”显示文本 android:phoneNumber关联方法: setKeyListener(KeyListener)属性说明: 设置为电话号码的输入方式。 android:privateImeOptions关联方法: setPrivateImeOptions(String)属性说明: 设置输入法选项，在EditText中才有作用。 android:scrollHorizontally关联方法: setHorizontallyScrolling(boolean)属性说明: 设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:selectAllOnFocus关联方法: setSelectAllOnFocus(boolean)属性说明: 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。 android:shadowColor关联方法: setShadowLayer(float,float,float,int)属性说明: 指定文本阴影的颜色，需要与shadowRadius一起使用。 android:shadowDx关联方法: setShadowLayer(float,float,float,int)属性说明: 设置阴影横向坐标开始位置。 android:shadowDy关联方法: setShadowLayer(float,float,float,int)属性说明: 设置阴影纵向坐标开始位置。 android:shadowRadius关联方法: setShadowLayer(float,float,float,int)属性说明: 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。 android:singleLine关联方法: setTransformationMethod(TransformationMethod)属性说明: 设置单行显示。如果和layoutwidth一起使用，当文本不能全部显示时，后面用“…”来表示。如`android:text=”test singleLine”`android:singleLine=&quot;true&quot; android:layout_width=&quot;20dp&quot;将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行 android:text关联方法: setText(CharSequence,TextView.BufferType)属性说明: 设置显示文本. android:textAllCaps关联方法: setAllCaps(boolean)属性说明: 设置文本全为大写。值为”true”或”false”。 android:textAppearance关联方法: 属性说明: 设置文字外观。如“?android:attr/textAppearanceLargeInverse android:textColor关联方法: setTextColor(int)属性说明: 设置文本颜色 android:textColorHighlight关联方法: setHighlightColor(int)属性说明: 被选中文字的底色，默认为蓝色 android:textColorHint关联方法: setHintTextColor(int)属性说明: 设置提示信息文字的颜色，默认为灰色。与hint一起使用。 android:textColorLink关联方法: setLinkTextColor(int)属性说明: 文字链接的颜色. android:textIsSelectable关联方法: isTextSelectable()属性说明: 设置非编辑文本可否被选择。值为”true”或”false”。 android:textScaleX关联方法: setTextScaleX(float)属性说明: 设置文字之间间隔，默认为1.0f。 android:textSize关联方法: setTextSize(int,float)属性说明: 设置文字大小，推荐度量单位”sp”，如”15sp” android:textStyle关联方法: setTypeface(Typeface)属性说明: 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开 android:typeface关联方法: setTypeface(Typeface)属性说明: 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3] android:width关联方法: setWidth(int)属性说明: 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)。 由于这两天在做listView的东西，所以整理出来一些我个人认为比较特别的属性，通过设置这样的属性可以做出更加美观的列表 首先是stackFromBottom属性，这只该属性之后你做好的列表就会显示你列表的最下面，值为true和false android:stackFromBottom=&quot;true&quot; 第二是transciptMode属性，需要用ListView或者其它显示大量Items的控件实时跟踪或者查看信息，并且希望最新的条目可以自动滚动到可视范围内。通过设置的控件transcriptMode属性可以将 android平台的控件（支持ScrollBar）自动滑动到最底部。 android:transcriptMode=&quot;alwaysScroll&quot; 第三cacheColorHint属性，很多人希望能够改变一下它的背景，使他能够符合整体的UI设计，改变背景背很简单只需要准备一张图片然后指定属性 android:background=&quot;@drawable/bg&quot;，不过不要高兴地太早，当你这么做以后，发现背景是变了，但是当你拖动，或者点击list空白位置的时候发现ListItem都变成黑色的了，破坏了整体效果。 如果你只是换背景的颜色的话，可以直接指定android:cacheColorHint为你所要的颜色，如果你是用图片做背景的话，那也只要将android:cacheColorHint指定为透明（#00000000）就可以了 第四divider属性，该属性作用是每一项之间需要设置一个图片做为间隔，或是去掉item之间的分割线 android:divider=&quot;@drawable/list_driver&quot; 其中 @drawable/list_driver 是一个图片资源，如果不想显示分割线则只要设置为android:divider=&quot;@drawable/@null&quot; 就可以了 第五fadingEdge属性，上边和下边有黑色的阴影 android:fadingEdge=&quot;none&quot; 设置后没有阴影了~ 第五scrollbars属性，作用是隐藏listView的滚动条， android:scrollbars=&quot;none&quot;与setVerticalScrollBarEnabled(true);的效果是一样的，不活动的时候隐藏，活动的时候也隐藏 第六fadeScrollbars属性，android:fadeScrollbars=&quot;true&quot; 配置ListView布局的时候，设置这个属性为true就可以实现滚动条的自动隐藏和显示。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-基类实现及学习]]></title>
      <url>%2F2017%2F06%2F13%2Fandroid-base-class%2F</url>
      <content type="text"><![CDATA[BaseActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242public abstract class BaseActivity extends FragmentActivity &#123; /** 用来保存所有已打开的Activity */ private static Stack&lt;Activity&gt; listActivity = new Stack&lt;Activity&gt;(); /** 提示信息 **/ private Toast mToast; /** 记录上次点击按钮的时间 **/ private long lastClickTime; /** 按钮连续点击最低间隔时间 单位：毫秒 **/ public final static int CLICK_TIME = 500; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(getContentViewId()); // 设置activity为无标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE); // 将activity推入栈中 listActivity.push(this); // 初始化ui initUI(); // 初始化数据 initData(); // 事件监听 initListener(); &#125; protected void initToolbar()&#123; Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); if(toolbar != null)&#123; setSupportActionBar(toolbar); getSupportActionBar.setDisplayShowTitleEnabled(false); handleToolbar(new ToolbarHelper(this)); &#125; &#125; /** 初始化ui **/ protected abstract void initUI(); /** 初始化数据 **/ protected abstract void initData(); /** 初始化监听 **/ protected abstract void initListener(); @Override protected void onSaveInstanceState(Bundle outState) &#123; saveInstanceState(outState); super.onSaveInstanceState(outState); &#125; // 设置activity为无标题栏 protected void setBase()&#123; requestWindowFeature(Window.FEATURE_NO_TITLE); &#125; /** 保存activity状态 **/ protected void saveInstanceState(Bundle outState) &#123; &#125; protected void handleToolbar()&#123; &#125; @Override public void onBackPressed() &#123; super.onBackPressed(); &#125; public void onBack(View v) &#123; finish(); &#125; @Override protected void onResume() &#123; super.onResume(); &#125; protected abstract int getContentViewId(); protected void showLongToast(String toastText)&#123; Toast.makeText(this,toastText,Toast.LENGTH_LONG).show(); &#125; protected void showShortToast(String toastText)&#123; Toast.makeText(this,toastText,Toast.LENGTH_SHORT).show(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 从栈中移除当前activity if (listActivity.contains(this)) &#123; listActivity.remove(this); &#125; &#125; /********************** activity跳转 **********************************/ public void openActivity(Class&lt;?&gt; targetActivityClass) &#123; openActivity(targetActivityClass, null); &#125; public void openActivity(Class&lt;?&gt; targetActivityClass, Bundle bundle) &#123; Intent intent = new Intent(this, targetActivityClass); if (bundle != null) &#123; intent.putExtras(bundle); &#125; startActivity(intent); &#125; public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass) &#123; openActivity(targetActivityClass); this.finish(); &#125; public void openActivityAndCloseThis(Class&lt;?&gt; targetActivityClass, Bundle bundle) &#123; openActivity(targetActivityClass, bundle); this.finish(); &#125; /***************************************************************/ /** 验证上次点击按钮时间间隔，防止重复点击 */ public boolean verifyClickTime() &#123; if (System.currentTimeMillis() - lastClickTime &lt;= CLICK_TIME) &#123; return false; &#125; lastClickTime = System.currentTimeMillis(); return true; &#125; /** 收起键盘 */ public void closeInputMethod() &#123; // 收起键盘 View view = getWindow().peekDecorView();// 用于判断虚拟软键盘是否是显示的 if (view != null) &#123; InputMethodManager inputmanger = (InputMethodManager) getSystemService(Activity.INPUT_METHOD_SERVICE); inputmanger.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); &#125; &#125; /** * 获取string * * @param mRid * @return */ public String getStringMethod(int mRid) &#123; return this.getResources().getString(mRid); &#125; /** * 获取demin * * @param mRid * @return */ protected int getDemonIntegerMethod(int mRid) &#123; return (int) this.getResources().getDimension(mRid); &#125; /** * 关闭所有(前台、后台)Activity,注意：请已BaseActivity为父类 */ protected static void finishAll() &#123; int len = listActivity.size(); for (int i = 0; i &lt; len; i++) &#123; Activity activity = listActivity.pop(); activity.finish(); &#125; &#125; /***************** 双击退出程序 ************************************************/ private long exitTime = 0; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (KeyEvent.KEYCODE_BACK == keyCode) &#123; // 判断是否在两秒之内连续点击返回键，是则退出，否则不退出 if (System.currentTimeMillis() - exitTime &gt; 2000) &#123; Toast.makeText(getApplicationContext(), "再按一次退出程序", Toast.LENGTH_SHORT).show(); // 将系统当前的时间赋值给exitTime exitTime = System.currentTimeMillis(); &#125; else &#123; finishAll(); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125; /* * ************Fragement相关方法************************************************ * */ private Fragment currentFragment; /** Fragment替换(当前destrory,新的create) */ public void fragmentReplace(int target, Fragment toFragment, boolean backStack) &#123; FragmentManager manager = getSupportFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); String toClassName = toFragment.getClass().getSimpleName(); if (manager.findFragmentByTag(toClassName) == null) &#123; transaction.replace(target, toFragment, toClassName); if (backStack) &#123; transaction.addToBackStack(toClassName); &#125; transaction.commit(); &#125; &#125; /** Fragment替换(核心为隐藏当前的,显示现在的,用过的将不会destrory与create) */ public void smartFragmentReplace(int target, Fragment toFragment) &#123; FragmentManager manager = getSupportFragmentManager(); FragmentTransaction transaction = manager.beginTransaction(); // 如有当前在使用的-&gt;隐藏当前的 if (currentFragment != null) &#123; transaction.hide(currentFragment); &#125; String toClassName = toFragment.getClass().getSimpleName(); // toFragment之前添加使用过-&gt;显示出来 if (manager.findFragmentByTag(toClassName) != null) &#123; transaction.show(toFragment); &#125; else &#123;// toFragment还没添加使用过-&gt;添加上去 transaction.add(target, toFragment, toClassName); &#125; transaction.commit(); // toFragment更新为当前的 currentFragment = toFragment; &#125; /***********************************************************************/&#125; BaseFragment1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class BaseFragment extends Fragment &#123; protected Activity mActivity; /** * 获得全局的，防止使用getActivity()为空 * @param context */ @Override public void onAttach(Context context) &#123; super.onAttach(context); this.mActivity = (Activity)context; &#125; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container , Bundle savedInstanceState) &#123; View view = LayoutInflater.from(mActivity) .inflate(getLayoutId(), container, false); initView(view, savedInstanceState); return view; &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); initData(); &#125; /** * 该抽象方法就是 onCreateView中需要的layoutID * @return */ protected abstract int getLayoutId(); /** * 该抽象方法就是 初始化view * @param view * @param savedInstanceState */ protected abstract void initView(View view, Bundle savedInstanceState); /** * 执行数据的加载 */ protected abstract void initData();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-VelocityTracker详细学习]]></title>
      <url>%2F2017%2F06%2F10%2Fandroid-velocitytracker%2F</url>
      <content type="text"><![CDATA[简介VelocityTracker是一个跟踪触摸事件滑动速度的帮助类，用于实现flinging以及其它类似的手势。它的原理是把触摸事件 MotionEvent 对象传递给VelocityTracker的 addMovement(MotionEvent) 方法，然后分析MotionEvent 对象在单位时间类发生的位移来计算速度。你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。 主要函数 Public Methods void addMovement(MotionEvent event) Add a users movement to the tracker. void clear() Reset the velocity tracker back to its initial state. void compute CurrentVelocity(int units,float maxVelocity)Compute the current velocity based on the points that have been collected.intunitis表示速率的基本时间单位。unitis值为1的表示是，一毫秒时间单位内运动了多少个像素， unitis值为1000表示一秒（1000毫秒）时间单位内运动了多少个像素floatVelocity表示速率的最大值 void computeCurrentVelocity(int units)Equivalent to invoking computeCurrentVelocity(int, float)with a maximum velocity of Float.MAX_VALUE. abstract T getNextPoolable() float getXVelocity()Retrieve the last computed X velocity. float getXVelocity(int id)Retrieve the last computed X velocity. float float getYVelocity(int id)Retrieve the last computed Y velocity. float getYVelocity()Retrieve the last computed Y velocity. abstract boolean isPooled() static VelocityTracker obtain()Retrieve a new VelocityTracker object to watch the velocity of a motion. void recycle()Return a VelocityTracker object back to be re-used by others. abstract void setNextPoolable(T element) abstract void setPooled(boolean isPooled) 示例12345678910111213private VelocityTracker mVelocityTracker;//生命变量 //在onTouchEvent(MotionEvent ev)中 if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain();//获得VelocityTracker类实例 &#125; mVelocityTracker.addMovement(ev);//将事件加入到VelocityTracker类实例中 //判断当ev事件是MotionEvent.ACTION_UP时：计算速率 final VelocityTracker velocityTracker = mVelocityTracker; // 1000 provides pixels per second velocityTracker.computeCurrentVelocity(1, (float)0.01);//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常 Log.i("test","velocityTraker"+velocityTracker.getXVelocity()); velocityTracker.computeCurrentVelocity(1000); //设置units的值为1000，意思为一秒时间内运动了多少个像素 Log.i("test","velocityTraker"+velocityTracker.getXVelocity()); 大体的使用是这样的：当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象使用computeCurrentVelocity (int units)函数来计算当前的速度，使用getXVelocity ()、 getYVelocity ()函数来获得当前的速度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Toolbar详细学习]]></title>
      <url>%2F2017%2F06%2F09%2Fandroid-toolbar%2F</url>
      <content type="text"><![CDATA[Toolbar是简单使用1、在应用的build.gradle中添加v7 appcompat支持库。com.android.support:appcompat-v7:24.1.1 2、让Activity继承自AppCompatActivity。 123public class MyActivity extends AppCompatActivity &#123; // ...&#125; 3、在AndroidManifest.xml文件中，设置元素使用appcompat中的某个NoActionBar主题，从而来去除使用ActionBar来提供操作栏。 1&lt;application android:theme="@style/Theme.AppCompat.Light.NoActionBar"/&gt; 4、在activity的布局中添加Toolbar。 12345678&lt;android.support.v7.widget.Toolbar android:id="@+id/my_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:elevation="4dp" android:theme="@style/ThemeOverlay.AppCompat.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; 5、在activity的onCreate()方法中，调用setSupportActionBar()方法，并传入toolbar，这样就会将toolbar设置为activity的操作栏了。 1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_my); Toolbar toolbar = (Toolbar) findViewById(R.id.my_toolbar); setSupportActionBar(toolbar);&#125; Toolber复用应用中有很多界面，每个Activity一般都需要操作栏，且大多数activity的操作栏的元素是一致的，那每个布局文件里面都写这么多资源文件是累赘的。因此可以对Toolbar进行复用，使得布局文件看起来更精炼，更改Toolbar整体效果，如背景之类的可以更方便。 首先，在布局文件toolbar.xml中定义Toolbar。 123456789101112131415161718&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:contentInsetLeft="0dp" android:contentInsetStart="0dp" android:elevation="4dp" android:theme="@style/ToolbarTheme" app:navigationIcon="@drawable/icon_back" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:titleTextAppearance="@style/Toolbar.TitleText"&gt; &lt;!-- any custom view --&gt;&lt;/android.support.v7.widget.Toolbar&gt; 之后，在需要添加Toolbar的地方引入这个布局资源。 12&lt;include layout="@layout/toolbar"/&gt; 最后，在BaseActivity(一般app都会有)中的onCreate()方法设置Toolbar。注意，这个时候Activity不再继承AppCompatActivity，而是继承BaseActivity，而BaseActivity继承AppCompatActivity。BaseActivity部分代码如下： 123456789101112131415161718192021222324252627282930313233@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); if (toolbar != null) &#123; setSupportActionBar(toolbar); mToolbarHelper = new ToolbarHelper(toolbar); hanldeToolbar(mToolbarHelper); &#125;&#125;protected void hanldeToolbar(ToolbarHelper toolbarHelper) &#123;&#125;public static class ToolbarHelper &#123; private Toolbar mToolbar; public ToolbarHelper(Toolbar toolbar) &#123; this.mToolbar = toolbar; &#125; public Toolbar getToolbar() &#123; return mToolbar; &#125; public void setTitle(String title) &#123; TextView titleTV = (TextView) mToolbar.findViewById(R.id.toolbar_title); titleTV.setText(title); &#125;&#125; 代码中首先获取到Toolbar将其设置为操作栏，之后创建了一个ToolbarHelper对象，ToobarHelper主要是封装了下Toolbar，并提供操作自定义View的方法。然后调用hanldeToolbar()方法，子Activity通过重写这个方法，可以对Toolbar进行定制操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-MotionEvent解析]]></title>
      <url>%2F2017%2F06%2F08%2Fandroid-motionevent%2F</url>
      <content type="text"><![CDATA[一些常量常见的动作常量： public static final int ACTION_DOWN = 0; //单点触摸动作 public static final int ACTION_UP = 1; //单点触摸离开动作 public static final int ACTION_MOVE = 2; //触摸点移动动作 public static final int ACTION_CANCEL = 3; //触摸动作取消 public static final int ACTION_OUTSIDE = 4; //触摸动作超出边界 public static final int ACTION_POINTER_DOWN = 5;//多点触摸动作 public static final int ACTION_POINTER_UP = 6; //多点离开动作 以下是一些非touch事件 public static final int ACTION_HOVER_MOVE = 7; public static final int ACTION_SCROLL = 8; public static final int ACTION_HOVER_ENTER = 9; public static final int ACTION_HOVER_EXIT = 10; 掩码常量ACTION_MASK = 0X000000ff 动作掩码ACTION_POINTER_INDEX_MASK = 0X0000ff00 触摸点索引掩码ACTION_POINTER_INDEX_SHIFT = 8 //获取触摸点索引需要移动的位数 getRawX()和getRawY()相对于屏幕位置坐标 X,Y 相对于View的位置坐标]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-ViewConfiguration解析]]></title>
      <url>%2F2017%2F06%2F07%2Fandroid-viewconfiguration%2F</url>
      <content type="text"><![CDATA[ViewConfiguration这个类主要定义了UI中所使用到的标准常量，像超时、尺寸、距离，如果我们需要得到这些常量的数据，我们就可以通过这个类来获取，具体方法如下： 获取ViewConfiguration对象，由于ViewConfiguration的构造方法为私有的，只能通过这个静态方法来获取到该对象。 ViewConfiguration configure = ViewConfiguration.get(context); 通过该对象调用相关的函数，将返回相关的常量数据。 最后附上一些这个类文件源码，这里面所有的方法基本都是用来获取常量数据的，没有什么业务操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645import android.app.AppGlobals;import android.content.Context;import android.content.res.Configuration;import android.content.res.Resources;import android.graphics.Point;import android.os.RemoteException;import android.provider.Settings;import android.util.DisplayMetrics;import android.util.SparseArray;/** * 主要用来获取一些在UI中所使用到的标准常量，像超时、尺寸、距离 */public class ViewConfiguration &#123; /** * 定义了水平滚动条的宽度和垂直滚动条的高度，单位是dip */ private static final int SCROLL_BAR_SIZE = 10; /** * 滚动条褪去所需要经历的时间，单位：milliseconds */ private static final int SCROLL_BAR_FADE_DURATION = 250; /** * 滚动条褪去之前的默认时间延迟，单位：milliseconds */ private static final int SCROLL_BAR_DEFAULT_DELAY = 300; /** * 定义褪去边缘的长度，单位：dip */ private static final int FADING_EDGE_LENGTH = 12; /** * 按下状态在子控件上的持续时间，单位：milliseconds */ private static final int PRESSED_STATE_DURATION = 64; /** * 定义一个按下状态转变成长按状态所需要持续的时间，单位：milliseconds */ private static final int DEFAULT_LONG_PRESS_TIMEOUT = 500; /** * 定义连续重复按键间的时间延迟，单位：milliseconds */ private static final int KEY_REPEAT_DELAY = 50; /** * 如果用户需要触发全局对话框，例如：关机，锁屏等，需要按下按钮所持续的事件，单位：milliseconds */ private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500; /** * 定义一个触摸事件是点击还是滚动的事件间隔，如果在这个事件内没有移动，就认为这是一个点击，否则就是滚动，单位：milliseconds */ private static final int TAP_TIMEOUT = 180; /** * Defines the duration in milliseconds we will wait to see if a touch event * is a jump tap. If the user does not complete the jump tap within this interval, it is * considered to be a tap. */ private static final int JUMP_TAP_TIMEOUT = 500; /** * 定义双击的时间间隔，如果在这个时间内，就认为是双击 */ private static final int DOUBLE_TAP_TIMEOUT = 300; /** * 定义双击最小的时间间隔 */ private static final int DOUBLE_TAP_MIN_TIME = 40; /** * 定义一个触摸板触摸到释放可认为是一个点击事件而不是一个触摸移动手势的最大时间， * 也就是说在这个时间内进行一次触摸和释放操作就可以认为是一次点击事件，单位：milliseconds */ private static final int HOVER_TAP_TIMEOUT = 150; /** * 定义一个触摸板在触摸释放之前可以移动的最大距离， * 如果在这个距离之内就可以认为是一个点击事件，否则就是一个移动手势，单位：pixels */ private static final int HOVER_TAP_SLOP = 20; /** * 定义响应显示缩放控制的时间 */ private static final int ZOOM_CONTROLS_TIMEOUT = 3000; /** * Inset in dips to look for touchable content when the user touches the edge of the screen */ private static final int EDGE_SLOP = 12; /** * 如果我们认为用户正在滚动，这里定义一个触摸事件可以滚动的距离，单位：dips * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。 */ private static final int TOUCH_SLOP = 8; /** * 定义双击事件之间可以移动的距离，单位：dips */ private static final int DOUBLE_TAP_TOUCH_SLOP = TOUCH_SLOP; /** * 定义用户尝试翻页滚动的触摸移动距离，单位：dips * * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。 * */ private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2; /** * 定义第一次点击和第二次点击可以认为是一次双击之间的距离。单位：dips */ private static final int DOUBLE_TAP_SLOP = 100; /** * Distance in dips a touch needs to be outside of a window's bounds for it to * count as outside for purposes of dismissing the window. */ private static final int WINDOW_TOUCH_SLOP = 16; /** * 一个fling最小的速度，单位：dips/s */ private static final int MINIMUM_FLING_VELOCITY = 50; /** * 一个fling最大的速度，单位：dips/s */ private static final int MAXIMUM_FLING_VELOCITY = 8000; /** * 分发一个重复访问事件的延迟事件，单位：milliseconds */ private static final long SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS = 100; /** * The maximum size of View's drawing cache, expressed in bytes. This size * should be at least equal to the size of the screen in ARGB888 format. */ @Deprecated private static final int MAXIMUM_DRAWING_CACHE_SIZE = 480 * 800 * 4; // ARGB8888 /** * 滚动和滑动的摩擦系数 */ private static final float SCROLL_FRICTION = 0.015f; /** * Max distance in dips to overscroll for edge effects */ private static final int OVERSCROLL_DISTANCE = 0; /** * Max distance in dips to overfling for edge effects */ private static final int OVERFLING_DISTANCE = 6; private final int mEdgeSlop; private final int mFadingEdgeLength; private final int mMinimumFlingVelocity; private final int mMaximumFlingVelocity; private final int mScrollbarSize; private final int mTouchSlop; private final int mDoubleTapTouchSlop; private final int mPagingTouchSlop; private final int mDoubleTapSlop; private final int mWindowTouchSlop; private final int mMaximumDrawingCacheSize; private final int mOverscrollDistance; private final int mOverflingDistance; private final boolean mFadingMarqueeEnabled; private boolean sHasPermanentMenuKey; private boolean sHasPermanentMenuKeySet; static final SparseArray&lt;ViewConfiguration&gt; sConfigurations = new SparseArray&lt;ViewConfiguration&gt;(2); /** * 这个方法被废除了，使用ViewConfiguration.get(Context)&#125;替代 */ @Deprecated public ViewConfiguration() &#123; mEdgeSlop = EDGE_SLOP; mFadingEdgeLength = FADING_EDGE_LENGTH; mMinimumFlingVelocity = MINIMUM_FLING_VELOCITY; mMaximumFlingVelocity = MAXIMUM_FLING_VELOCITY; mScrollbarSize = SCROLL_BAR_SIZE; mTouchSlop = TOUCH_SLOP; mDoubleTapTouchSlop = DOUBLE_TAP_TOUCH_SLOP; mPagingTouchSlop = PAGING_TOUCH_SLOP; mDoubleTapSlop = DOUBLE_TAP_SLOP; mWindowTouchSlop = WINDOW_TOUCH_SLOP; //noinspection deprecation mMaximumDrawingCacheSize = MAXIMUM_DRAWING_CACHE_SIZE; mOverscrollDistance = OVERSCROLL_DISTANCE; mOverflingDistance = OVERFLING_DISTANCE; mFadingMarqueeEnabled = true; &#125; /** * 使用给定的context来创建一个新的配置。这个配置依赖于context里面不同的参数，例如显示的尺寸或者密度 * @param context 用来初始化这个view配置的应用上下文环境 * * @see #get(android.content.Context) * @see android.util.DisplayMetrics */ private ViewConfiguration(Context context) &#123; final Resources res = context.getResources(); final DisplayMetrics metrics = res.getDisplayMetrics(); final Configuration config = res.getConfiguration(); final float density = metrics.density; final float sizeAndDensity; if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE)) &#123; sizeAndDensity = density * 1.5f; &#125; else &#123; sizeAndDensity = density; &#125; mEdgeSlop = (int) (sizeAndDensity * EDGE_SLOP + 0.5f); mFadingEdgeLength = (int) (sizeAndDensity * FADING_EDGE_LENGTH + 0.5f); mMinimumFlingVelocity = (int) (density * MINIMUM_FLING_VELOCITY + 0.5f); mMaximumFlingVelocity = (int) (density * MAXIMUM_FLING_VELOCITY + 0.5f); mScrollbarSize = (int) (density * SCROLL_BAR_SIZE + 0.5f); mDoubleTapSlop = (int) (sizeAndDensity * DOUBLE_TAP_SLOP + 0.5f); mWindowTouchSlop = (int) (sizeAndDensity * WINDOW_TOUCH_SLOP + 0.5f); // Size of the screen in bytes, in ARGB_8888 format final WindowManager win = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); final Display display = win.getDefaultDisplay(); final Point size = new Point(); display.getRealSize(size); mMaximumDrawingCacheSize = 4 * size.x * size.y; mOverscrollDistance = (int) (sizeAndDensity * OVERSCROLL_DISTANCE + 0.5f); mOverflingDistance = (int) (sizeAndDensity * OVERFLING_DISTANCE + 0.5f); if (!sHasPermanentMenuKeySet) &#123; IWindowManager wm = WindowManagerGlobal.getWindowManagerService(); try &#123; sHasPermanentMenuKey = !wm.hasNavigationBar(); sHasPermanentMenuKeySet = true; &#125; catch (RemoteException ex) &#123; sHasPermanentMenuKey = false; &#125; &#125; mFadingMarqueeEnabled = res.getBoolean( com.android.internal.R.bool.config_ui_enableFadingMarquee); mTouchSlop = res.getDimensionPixelSize( com.android.internal.R.dimen.config_viewConfigurationTouchSlop); mPagingTouchSlop = mTouchSlop * 2; mDoubleTapTouchSlop = mTouchSlop; &#125; /** * 跟上面一个函数一样，只不过上面一个是创建一个ViewConfiguration对象，这里是直接通过这个静态方法返回一个对象 */ public static ViewConfiguration get(Context context) &#123; final DisplayMetrics metrics = context.getResources().getDisplayMetrics(); final int density = (int) (100.0f * metrics.density); ViewConfiguration configuration = sConfigurations.get(density); if (configuration == null) &#123; configuration = new ViewConfiguration(context); sConfigurations.put(density, configuration); &#125; return configuration; &#125; /** * @return 获取水平滚动条的宽带和垂直滚动条的高度 * * 这个函数被废除，使用getScaledScrollBarSize()来代替 */ @Deprecated public static int getScrollBarSize() &#123; return SCROLL_BAR_SIZE; &#125; /** * @return 获取水平滚动条的宽带和垂直滚动条的高度 */ public int getScaledScrollBarSize() &#123; return mScrollbarSize; &#125; /** * @return 滚动条褪去的持续时间 */ public static int getScrollBarFadeDuration() &#123; return SCROLL_BAR_FADE_DURATION; &#125; /** * @return 滚动条褪去的延迟时间 */ public static int getScrollDefaultDelay() &#123; return SCROLL_BAR_DEFAULT_DELAY; &#125; /** * @return 褪去边缘的长度 * * 这个方法已经废弃，用getScaledFadingEdgeLength()替代. */ @Deprecated public static int getFadingEdgeLength() &#123; return FADING_EDGE_LENGTH; &#125; /** * @return 褪去边缘的长度，单位：pixels */ public int getScaledFadingEdgeLength() &#123; return mFadingEdgeLength; &#125; /** * @return 在子控件上按住状态的持续时间 */ public static int getPressedStateDuration() &#123; return PRESSED_STATE_DURATION; &#125; /** * @return 按住状态转变为长按状态需要的时间 */ public static int getLongPressTimeout() &#123; return AppGlobals.getIntCoreSetting(Settings.Secure.LONG_PRESS_TIMEOUT, DEFAULT_LONG_PRESS_TIMEOUT); &#125; /** * @return 重新按键时间 */ public static int getKeyRepeatTimeout() &#123; return getLongPressTimeout(); &#125; /** * @return 重复按键延迟时间 */ public static int getKeyRepeatDelay() &#123; return KEY_REPEAT_DELAY; &#125; /** * @return 判断用户是单击还是滚动的时间，在这个时间内没有移动则是单击，否则是滚动 */ public static int getTapTimeout() &#123; return TAP_TIMEOUT; &#125; /** * @return the duration in milliseconds we will wait to see if a touch event * is a jump tap. If the user does not move within this interval, it is * considered to be a tap. */ public static int getJumpTapTimeout() &#123; return JUMP_TAP_TIMEOUT; &#125; /** * @return 得到双击间隔时间，在这个时间内，则是双击，否则就是单击 */ public static int getDoubleTapTimeout() &#123; return DOUBLE_TAP_TIMEOUT; &#125; /** * @return the minimum duration in milliseconds between the first tap's * up event and the second tap's down event for an interaction to be considered a * double-tap. * * @hide */ public static int getDoubleTapMinTime() &#123; return DOUBLE_TAP_MIN_TIME; &#125; /** * @return the maximum duration in milliseconds between a touch pad * touch and release for a given touch to be considered a tap (click) as * opposed to a hover movement gesture. * @hide */ public static int getHoverTapTimeout() &#123; return HOVER_TAP_TIMEOUT; &#125; /** * @return the maximum distance in pixels that a touch pad touch can move * before being released for it to be considered a tap (click) as opposed * to a hover movement gesture. * @hide */ public static int getHoverTapSlop() &#123; return HOVER_TAP_SLOP; &#125; /** * @return Inset in dips to look for touchable content when the user touches the edge of the * screen * * @deprecated Use &#123;@link #getScaledEdgeSlop()&#125; instead. */ @Deprecated public static int getEdgeSlop() &#123; return EDGE_SLOP; &#125; /** * @return Inset in pixels to look for touchable content when the user touches the edge of the * screen */ public int getScaledEdgeSlop() &#123; return mEdgeSlop; &#125; /** * @return Distance in dips a touch can wander before we think the user is scrolling * * @deprecated Use &#123;@link #getScaledTouchSlop()&#125; instead. */ @Deprecated public static int getTouchSlop() &#123; return TOUCH_SLOP; &#125; /** * @return Distance in pixels a touch can wander before we think the user is scrolling */ public int getScaledTouchSlop() &#123; return mTouchSlop; &#125; /** * @return Distance in pixels the first touch can wander before we do not consider this a * potential double tap event * @hide */ public int getScaledDoubleTapTouchSlop() &#123; return mDoubleTapTouchSlop; &#125; /** * @return Distance in pixels a touch can wander before we think the user is scrolling a full * page */ public int getScaledPagingTouchSlop() &#123; return mPagingTouchSlop; &#125; /** * @return Distance in dips between the first touch and second touch to still be * considered a double tap * @deprecated Use &#123;@link #getScaledDoubleTapSlop()&#125; instead. * @hide The only client of this should be GestureDetector, which needs this * for clients that still use its deprecated constructor. */ @Deprecated public static int getDoubleTapSlop() &#123; return DOUBLE_TAP_SLOP; &#125; /** * @return Distance in pixels between the first touch and second touch to still be * considered a double tap */ public int getScaledDoubleTapSlop() &#123; return mDoubleTapSlop; &#125; /** * Interval for dispatching a recurring accessibility event in milliseconds. * This interval guarantees that a recurring event will be send at most once * during the &#123;@link #getSendRecurringAccessibilityEventsInterval()&#125; time frame. * * @return The delay in milliseconds. * * @hide */ public static long getSendRecurringAccessibilityEventsInterval() &#123; return SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS; &#125; /** * @return Distance in dips a touch must be outside the bounds of a window for it * to be counted as outside the window for purposes of dismissing that * window. * * @deprecated Use &#123;@link #getScaledWindowTouchSlop()&#125; instead. */ @Deprecated public static int getWindowTouchSlop() &#123; return WINDOW_TOUCH_SLOP; &#125; /** * @return Distance in pixels a touch must be outside the bounds of a window for it * to be counted as outside the window for purposes of dismissing that window. */ public int getScaledWindowTouchSlop() &#123; return mWindowTouchSlop; &#125; /** * @return Minimum velocity to initiate a fling, as measured in dips per second. * * @deprecated Use &#123;@link #getScaledMinimumFlingVelocity()&#125; instead. */ @Deprecated public static int getMinimumFlingVelocity() &#123; return MINIMUM_FLING_VELOCITY; &#125; /** * @return 得到滑动的最小速度, 以像素/每秒来进行计算 */ public int getScaledMinimumFlingVelocity() &#123; return mMinimumFlingVelocity; &#125; /** * @return Maximum velocity to initiate a fling, as measured in dips per second. * * @deprecated Use &#123;@link #getScaledMaximumFlingVelocity()&#125; instead. */ @Deprecated public static int getMaximumFlingVelocity() &#123; return MAXIMUM_FLING_VELOCITY; &#125; /** * @return 得到滑动的最大速度, 以像素/每秒来进行计算 */ public int getScaledMaximumFlingVelocity() &#123; return mMaximumFlingVelocity; &#125; /** * The maximum drawing cache size expressed in bytes. * * @return the maximum size of View's drawing cache expressed in bytes * * @deprecated Use &#123;@link #getScaledMaximumDrawingCacheSize()&#125; instead. */ @Deprecated public static int getMaximumDrawingCacheSize() &#123; //noinspection deprecation return MAXIMUM_DRAWING_CACHE_SIZE; &#125; /** * The maximum drawing cache size expressed in bytes. * * @return the maximum size of View's drawing cache expressed in bytes */ public int getScaledMaximumDrawingCacheSize() &#123; return mMaximumDrawingCacheSize; &#125; /** * @return The maximum distance a View should overscroll by when showing edge effects (in * pixels). */ public int getScaledOverscrollDistance() &#123; return mOverscrollDistance; &#125; /** * @return The maximum distance a View should overfling by when showing edge effects (in * pixels). */ public int getScaledOverflingDistance() &#123; return mOverflingDistance; &#125; /** * The amount of time that the zoom controls should be * displayed on the screen expressed in milliseconds. * * @return the time the zoom controls should be visible expressed * in milliseconds. */ public static long getZoomControlsTimeout() &#123; return ZOOM_CONTROLS_TIMEOUT; &#125; /** * The amount of time a user needs to press the relevant key to bring up * the global actions dialog. * * @return how long a user needs to press the relevant key to bring up * the global actions dialog. */ public static long getGlobalActionKeyTimeout() &#123; return GLOBAL_ACTIONS_KEY_TIMEOUT; &#125; /** * The amount of friction applied to scrolls and flings. * * @return A scalar dimensionless value representing the coefficient of * friction. */ public static float getScrollFriction() &#123; return SCROLL_FRICTION; &#125; /** * Report if the device has a permanent menu key available to the user. * * &lt;p&gt;As of Android 3.0, devices may not have a permanent menu key available. * Apps should use the action bar to present menu options to users. * However, there are some apps where the action bar is inappropriate * or undesirable. This method may be used to detect if a menu key is present. * If not, applications should provide another on-screen affordance to access * functionality. * * @return true if a permanent menu key is present, false otherwise. */ public boolean hasPermanentMenuKey() &#123; return sHasPermanentMenuKey; &#125; /** * @hide * @return Whether or not marquee should use fading edges. */ public boolean isFadingMarqueeEnabled() &#123; return mFadingMarqueeEnabled; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Scroller详细学习]]></title>
      <url>%2F2017%2F06%2F06%2Fandroid-scroller%2F</url>
      <content type="text"><![CDATA[前言Scroller是一个专门用于处理滚动效果的工具类，可能在大多数情况下，我们直接使用Scroller的场景并不多，但是很多大家所熟知的控件在内部都是使用Scroller来实现的，如ViewPager、ListView等。先撇开Scroller类不谈，其实任何一个控件都是可以滚动的，因为在View类当中有scrollTo()和scrollBy()这两个方法。这两个方法都是用于对View进行滚动的，那么它们之间有什么区别呢？简单点讲，scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。注意，不管是scrollTo()还是scrollBy()方法，滚动的都是该View内部的内容 第一个参数x表示相对于当前位置横向移动的距离，正值向左移动，负值向右移动，单位是像素。第二个参数y表示相对于当前位置纵向移动的距离，正值向上移动，负值向下移动，单位是像素。 scrollBy()scrollBy()方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直向右下方移动。 scrollTo()scrollTo()方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。 Scroller目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤： 创建Scroller的实例 调用startScroll()方法来初始化滚动数据并刷新界面 重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 startScroll(int startX,int startY,int dx,int dy) 第一个参数是滚动开始时X的坐标 第二个参数是滚动开始时Y的坐标 第三个参数是横向滚动的距离,正值表示向左滚动 第四个参数是纵向滚动的距离，正值表示向上滚动。 紧接着调用invalidate()方法来刷新界面。 startScroll (int startX, int startY, int dx, int dy, int duration)同上 第五个参数是滑动时间 computeScroll()在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。 12345678@Overridepublic void computeScroll() &#123; // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); invalidate(); &#125;&#125; getScrollX() | getScrollY()返回当前view在x或者y方向上的滚动距离]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-XML参数详细了解]]></title>
      <url>%2F2017%2F06%2F05%2Fandroid-xml%2F</url>
      <content type="text"><![CDATA[android:layout_width 设置组件的宽度 android:layout_height 设置组件的高度 android:id 给组件定义一个id值，供后期使用 android:background 设置组件的背景颜色或背景图片 android:text 设置组件的显示文字 android:textColor 设置组件的显示文字的颜色 android:layout_below 组件在参考组件的下面 android:alignTop 同指定组件的顶平行 android:maxLength=&quot;6&quot; 限制输入字数 android:digits=&#39;012356789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; 限制输入数字和大写小写字母 android:password=&#39;true&#39; 这条可以让EditText显示的内容自动为 星号，输入时内容会在1秒内变成*字样。 android:numeric=&#39;true&#39; 这条可以让输入法自动变为数字输入键盘，同时仅允许0-9的数字输入 android:capitalize=&#39;cwj1987&#39; 这样仅允许接受输入cwj1987，一般用于密码验证 android:editable=&#39;false&#39; 设置EditText不可编辑 android:singleLine=&#39;true&#39; 强制输入的内容在单行 android:ellipsize=&#39;end&#39; 自动隐藏尾部溢出数据，一般用于文字内容过长一行无法全部显示时。 android:autoLink 设置是否当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接。可选值(none/web/email/phone/map/all) android:autoText 如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。 android:bufferType 指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。spannable 则可在给定的字符区域使用样式，参见这里1、这里2。 android:capitalize 设置英文字母大写类型。此处无效果，需要弹出输入法才能看得到，参见EditText此属性说明。 android:cursorVisible 设定光标为显示/隐藏，默认显示。 android:digits 设置允许输入哪些字符。如“1234567890.+-*/%\n()” android:drawableBottom 在text的下方输出一个drawable，如图片。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。 android:drawableLeft 在text的左边输出一个drawable，如图片。 android:drawablePadding 设置text与drawable(图片)的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。 android:drawableRight 在text的右边输出一个drawable，如图片。 android:drawableTop 在text的正上方输出一个drawable，如图片。 android:editable 设置是否可编辑。这里无效果，参见EditView。 android:editorExtras 设置文本的额外的输入数据。在EditView再讨论。 android:ellipsize 设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动) android:freezesText 设置保存文本的内容以及光标的位置。参见：这里。 android:gravity 设置文本位置，如设置成“center”，文本将居中显示。 android:hint Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。此属性在EditView中使用，但是这里也可以用。 android:imeOptions 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。这个在EditText中再详细说明，此处无用。 android:imeActionId 设置IME动作ID。在EditText再做说明，可以先看这篇帖子：这里。 android:imeActionLabel 设置IME动作标签。在EditText再做说明。 android:includeFontPadding 设置文本是否包含顶部和底部额外空白，默认为true。 android:inputMethod 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。 android:inputType 设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditText中再详细说明，这里无效果。 android:linksClickable 设置链接是否点击连接，即使设置了autoLink。 android:marqueeRepeatLimit 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。 android:ems 设置TextView的宽度为N个字符的宽度。 android:maxEms 设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:minEms 设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:maxLength 限制显示的文本长度，超出部分不显示。 android:lines 设置文本的行数，设置两行就显示两行，即使第二行没有数据。 android:maxLines 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。 android:minLines 设置文本的最小行数，与lines类似。 android:lineSpacingExtra 设置行间距。 android:lineSpacingMultiplier 设置行间距的倍数。如”1.2” android:numeric 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EditText将详细说明。 android:password 以小点”.”显示文本 android:phoneNumber 设置为电话号码的输入方式。 android:privateImeOptions 设置输入法选项，此处无用，在EditText将进一步讨论。 android:scrollHorizontally 设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:selectAllOnFocus 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。EditText中设置后无效果。 android:shadowColor 指定文本阴影的颜色，需要与shadowRadius一起使用。 android:shadowDx 设置阴影横向坐标开始位置。 android:shadowDy 设置阴影纵向坐标开始位置。 android:shadowRadius 设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。 android:singleLine 设置单行显示。如果和layoutwidth一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=”test singleLine “ android:singleLine=”true” android:layout_width=”20dp”将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行 android:text 设置显示文本. android:textAppearance 设置文字外观。如“?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，？表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/textAppearanceMediumInverse/textAppearanceSmall/textAppearanceSmallInverse android:textColor 设置文本颜色 android:textColorHighlight 被选中文字的底色，默认为蓝色 android:textColorHint 设置提示信息文字的颜色，默认为灰色。与hint一起使用。 android:textColorLink 文字链接的颜色. android:textScaleX 设置文字之间间隔，默认为1.0f。分别设置0.5f/1.0f/1.5f/2.0f android:textSize 设置文字大小，推荐度量单位”sp”，如”15sp” android:textStyle 设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开 android:typeface 设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3] android:height 设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米) android:maxHeight 设置文本区域的最大高度 android:minHeight 设置文本区域的最小高度 android:width 设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)，与layout_width的区别看这里。 android:maxWidth 设置文本区域的最大宽度 android:minWidth 设置文本区域的最小宽度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Matrix方法详细了解]]></title>
      <url>%2F2017%2F06%2F04%2Fandroid-matrix%2F</url>
      <content type="text"><![CDATA[一、概述这里我们会详细讲解matrix的各个方法，以及它的用法。matrix叫做矩阵，在前面讲解 ColorFilter 的文章中，我们讲解了ColorMatrix，他是一个4 * 5的矩阵。而这里，我们讲解的Matrix不是用于处理颜色的，而是处理图形的。他是一个3 * 3的矩阵。 二、原理先看看matrix的矩阵是什么样子的： 这里可以查看Matrix的代码得到。那么这个矩阵分别代表了什么呢，这里通过他们的名字可以看出，scale是缩放，skew是错切（canvas变换中有讲过），trans是平移，persp代表透视（官方文档中，也没有详细讲解，透视在这里只做简单介绍）。这里需要把矩阵根据他们的作用划分为4块： 如上图所示，这四块区域各有作用。后面会详细讲解各个作用，先来看看这个矩阵是如何影响图像的。先看看屏幕的坐标系： 看上图，这里表示了屏幕的坐标系，其中的x，y轴是大家所熟知的，但是其实，一个物体他是存在于一个三维空间的，所以必然会有z轴。我们的屏幕，就像是一个窗口，透过它，我们看到了屏幕后面的世界，那里面有各种物体，我们看到的是映射在x，y平面上的一个投射图像。屏幕就像是一个镜头一样，将里面的物体映射到x，y平面上，成为一个二维的图像。那么如果，我们把屏幕这个镜头沿着z轴，拉远或者拉进，那么图像会有什么变化呢，肯定会变小或者变大。就好比坐在飞机上透过窗口看地面的汽车，和在地面上看到的大小是不同的。 结论就是，在屏幕上显示的像素，不仅仅有x，y坐标，其实还有z轴的影响。所以这里对应的像素描述由一个3行一列的矩阵来表示： x，y分别代表x，y轴上的坐标，而1代表屏幕在z轴上的坐标为默认的。如果将1变大，那么屏幕会拉远， 图形会变小。 现在我们来看看matrix怎么作用于每个像素的值。这里需要用到矩阵的乘法，首先需要明确的是，矩阵的前乘和后乘是不相同的，也就是说不满足乘法交换律。 这里我们通过一个旋转变换来看看原理,其实一张图片围绕一个点旋转，也就是所有的点都围绕一个点旋转，所以只需要关注一个点的情况即可： 假定有一个点 ，相对坐标原点顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图： 那么就有： 换做矩阵运算就如下图： 从这里就可以看出，矩阵中的值，是如何作用于像素点的x，y坐标以及z轴远近。 同时，可以看到，上面的矩阵四块区域的切分也是因为矩阵乘法的操作决定的，由于这里的乘法运算中，左上角的四个值，可以和x，y值做乘法运算，所以可以影响到旋转等操作，而右上角的模块，只能做加法，所以只能影响到平移。右下角的模块主要管z轴，自然就可以进行等比的缩放了，左下角的模块一般不去动他，否则会把x，y值加入到z轴中来，会不可控。 三、基本方法解析讲解完了matrix作用于像素点的原理之后，我们逐个讲解它的方法。 12public Matrix()public Matrix(Matrix src) 构造函数有两个，第一个是直接创建一个单位矩阵，第二个是根据提供的矩阵创建一个新的矩阵（采用deep copy）单位矩阵如下： 12public boolean isIdentity()//判断是否是单位矩阵public boolean isAffine()//判断是否是仿射矩阵 是否是单位矩阵很简单，就不做讲解了，这里是否是仿射矩阵可能大家不好理解。首先来看看什么是仿射变换。仿射变换其实就是二维坐标到二维坐标的线性变换，保持二维图形的“平直性”（即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（指保持二维图形间的相对位置关系不变，平行线还是平行线，而直线上点的位置顺序不变），可以通过一系列的原子变换的复合来实现，原子变换就包括：平移、缩放、翻转、旋转和错切。这里除了透视可以改变z轴以外，其他的变换基本都是上述的原子变换，所以，只要最后一行是0,0,1则是仿射矩阵。public boolean rectStaysRect()判断该矩阵是否可以将一个矩形依然变换为一个矩形。当矩阵是单位矩阵，或者只进行平移，缩放，以及旋转90度的倍数的时候，返回true。public void reset()重置矩阵为单位矩阵。public void setTranslate(float dx, float dy)设置平移效果，参数分别是x，y上的平移量。效果图如下： 代码如下： 12345Matrix matrix = new Matrix();canvas.drawBitmap(bitmap, matrix, paint);matrix.setTranslate(100, 1000);canvas.drawBitmap(bitmap, matrix, paint);1234512345 缩放12public void setScale(float sx, float sy, float px, float py)public void setScale(float sx, float sy) 两个方法都是设置缩放到matrix中，sx，sy代表了缩放的倍数，px,py代表缩放的中心。这里跟上面比较类似不做讲解了。 旋转12public void setRotate(float degrees, float px, float py)public void setRotate(float degrees) 和上面类似，不再讲解。 三角函数12public void setSinCos(float sinValue, float cosValue, float px, float py)public void setSinCos(float sinValue, float cosValue) 这个方法乍一看可能有点蒙，其实在前面的原理中，我们讲解了一个旋转的例子，他最终的矩阵效果是这样的： 其实旋转，就是使用了这样的matrix，显而易见，这里的参数就清晰了。sinValue：对应图中的sin值cosValue：对应cos值px:中心的x坐标py：中心的y坐标看一个示例,我们把图像旋转90度，那么90度对应的sin和cos分别是1和0。 看代码如下： 123Matrixmatrix = new Matrix();matrix.setSinCos(1, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);canvas.drawBitmap(bitmap, matrix, paint);123123 错切12public void setSkew(float kx, float ky, float px, float py)public void setSkew(float kx, float ky) 错切，这里kx，ky分别代表了x，y上的错切因子，px，py代表了错切的中心。不了解错切了在前面canvas变换中去查看，这里不再讲解。 public boolean setConcat(Matrix a,Matrix b)将当前matrix的值变为a和b的乘积,它的意义在下面的 进阶方法中来探讨。 1.equals比较两个Matrix的数值是否相同。 2.hashCode获取Matrix的哈希值。 3.toString将Matrix转换为字符串: Matrix{[1.0, 0.0, 0.0][0.0, 1.0, 0.0][0.0, 0.0, 1.0]} 4.toShortString将Matrix转换为短字符串: [1.0, 0.0, 0.0][0.0, 1.0, 0.0][0.0, 0.0, 1.0] 数值操作数值操作这一组方法可以帮助我们直接控制Matrix里面的数值。 1.setvoid set (Matrix src)没有返回值，有一个参数，作用是将参数Matrix的数值复制到当前Matrix中。如果参数为空，则重置当前Matrix，相当于reset() 2.resetvoid reset ()重置当前Matrix(将当前Matrix重置为单位矩阵)。 3.setValuesvoid setValues (float[] values)setValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。 4.getValuesvoid getValues (float[] values)很显然，getValues和setValues是一对方法，参数也是浮点型的一维数组，长度需要大于9，将Matrix中的数值拷贝进参数的前9位中。 四、进阶方法解析上面的基本方法中，有关于变换的set方法都可以带来不同的效果，但是每个set都会把上个效果清除掉，例如依次调用了setSkew,setTranslate，那么最终只有setTranslate会起作用，那么如何才和将两种效果复合呢。Matrix给我们提供了很多方法。但是主要都是2类：preXXXX:以pre开头，例如preTranslatepostXXXX:以post开头，例如postScale他们分别代表了前乘，和后乘。看一段代码： 123Matrix matrix = new Matrix();matrix.setTranslate(100, 1000);matrix.preScale(0.5f, 0.5f); 这里matrix前乘了一个scale矩阵，换算成数学式如下： 从上面可以看出，最终得出的matrix既包含了缩放信息也有平移信息。后乘自然就是matrix在后面，而缩放矩阵在前面，由于矩阵前后乘并不等价，也就导致了他们的效果不同。我们来看看后乘的结果： 可以看到，结果跟上面不同，并且这也不是我们想要的结果，这里缩放没有更改，但是平移被减半了，换句话说，平移的距离也被缩放了。所以需要注意前后乘法的关系。来看看他们对应的效果图：前乘： 后乘： 可以明显看到，后乘的平移距离受了影响。了解清除了前后乘的意义，在使用的过程中，多个效果的叠加时，一样要注意，否则效果达不到预期。 五、其他方法解析matrix除了上面的方法外，还有一些其他的方法，这里依次解析 1、setRectToRectpublic boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf)将rect变换成rect，上面的rectStaysRect已经说过，要保持rect只能做缩放平移和选择90度的倍数，那么这里其实也是一样，只是这几种变化，这里通过stf参数来控制。ScaleToFit 有如下四个值：FILL: 可能会变换矩形的长宽比，保证变换和目标矩阵长宽一致。START:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。左上对齐。CENTER: 保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。END:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。右下对齐。这里使用谷歌的api demo的图片作为例子： 2、setPolyToPolypublic boolean setPolyToPoly(float[] src, int srcIndex,float[] dst, int dstIndex,int pointCount)通过指定的0-4个点，原始坐标以及变化后的坐标，来得到一个变换矩阵。如果指定0个点则没有效果。下面通过例子分别说明1到4个点的可以达到的效果： 1个点，平移只指定一个点，可以达到平移效果： 代码如下：12345float[] src = &#123;0, 0&#125;;int DX = 300;float[] dst = &#123;0 + DX, 0 + DX&#125;;matrix.setPolyToPoly(src, 0, dst, 0, 1);canvas.drawBitmap(bitmap, matrix, paint);1234512345 2个点，旋转或者缩放两个点，可以达到旋转效果或者缩放效果，缩放比较简单，这里我们来看旋转效果，一个点指定中心，一点指出旋转的效果 代码如下123456int bw = bitmap.getWidth();int bh = bitmap.getHeight();float[] src = &#123;bw / 2, bh / 2, bw, 0&#125;;float[] dst = &#123;bw / 2, bh / 2, bw / 2 + bh / 2, bh / 2 + bw / 2&#125;;matrix.setPolyToPoly(src, 0, dst, 0, 2);canvas.drawBitmap(bitmap, matrix, paint);123456123456 图片的中心点作为旋转的中心，前后不变，右上角变化到了下方，所以导致图片旋转了90度。 3个点，错切使用3个点，可以产生错切效果，指定3个顶点，一个固定，另外两个移动。看图： 代码如下： 1234567Matrix matrix = new Matrix();int bw = bitmap.getWidth();int bh = bitmap.getHeight();float[] src = &#123;0,0, 0, bh,bw,bh&#125;;float[] dst = &#123;0, 0, 200, bh, bw + 200, bh&#125;;matrix.setPolyToPoly(src, 0, dst, 0, 3);canvas.drawBitmap(bitmap, matrix, paint);12345671234567 4个点，透视透视就是观察的角度变化了。导致投射到平面上的二维图像变化了。我们看下面的例子，更容易理解： 图片看起来好像倾斜了，实现特别简单： 12345678Matrix matrix = new Matrix();int bw = bitmap.getWidth();int bh = bitmap.getHeight();float[] src = &#123;0, 0, 0, bh, bw, bh, bw, 0&#125;;int DX = 100;float[] dst = &#123;0 + DX, 0, 0, bh, bw, bh, bw - DX, 0&#125;;matrix.setPolyToPoly(src, 0, dst, 0, 4);canvas.drawBitmap(bitmap, matrix, paint);1234567812345678 可以看到，只是把左右两个顶点往里面收拢了，这样就得出了一个有3d效果的透视图。 3、invertpublic boolean invert(Matrix inverse)反转当前矩阵，如果能反转就返回true并将反转后的值写入inverse，否则返回false。当前矩阵*inverse=单位矩阵。反转前后有什么效果，我们来看看示例： 可以看到，反转之后，其实是对效果的一种反转。 4、mapPoints123public void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex,int pointCount)public void mapPoints(float[] dst, float[] src)public void mapPoints(float[] pts) 映射点的值到指定的数组中，这个方法可以在矩阵变换以后，给出指定点的值。 dst：指定写入的数组 dstIndex：写入的起始索引，x，y两个坐标算作一对，索引的单位是对，也就是经过两个值才加1 src：指定要计算的点 srcIndex：要计算的点的索引 pointCount：需要计算的点的个数，每个点有两个值，x和y。 5、mapVectors123public void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex,int vectorCount)public void mapVectors(float[] dst, float[] src)public void mapVectors(float[] vecs) 与上面的mapPoionts基本类似，这里是将一个矩阵作用于一个向量，由于向量的平移前后是相等的，所以这个方法不会对translate相关的方法产生反应，如果只是调用了translate相关的方法，那么得到的值和原本的一致。 6、mapRect12public boolean mapRect(RectF dst, RectF src)public boolean mapRect(RectF rect) 返回值即是调用的rectStaysRect()，这个方法前面有讲过，这里把src中指定的矩形的左上角和右下角的两个点的坐标，写入dst中。 7、mapRadiuspublic float mapRadius(float radius)返回一个圆圈半径的平均值，将matrix作用于一个指定radius半径的圆，随后返回的平均半径。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Fragment方法详细了解]]></title>
      <url>%2F2017%2F06%2F03%2Fandroid-fragment%2F</url>
      <content type="text"><![CDATA[boolean shouldShowRequestPermissionRationale (String permission)告诉你的app在实际显示权限对话框之前是否显示一个对正在请求权限的解释 void setUserVisibleHint (boolean isVisibleToUser)设置fragment’s UI现在对用户可见 void setTargetFragment (Fragment fragment, int requestCode)一般就是用于当前fragment由别的fragment启动，在完成操作后返回数据的onActivityResult]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-ViewPager详细学习]]></title>
      <url>%2F2017%2F06%2F02%2Fandroid-viewpager%2F</url>
      <content type="text"><![CDATA[简介ViewPager是android扩展包v4包中的类，这个类可以让用户左右切换当前的view ViewPager类直接继承了ViewGroup类，所有它是一个容器类，可以在其中添加其他的view类。 ViewPager类需要一个PagerAdapter适配器类给它提供数据。 ViewPager经常和Fragment一起使用，并且提供了专门的FragmentPagerAdapter和FragmentStatePagerAdapter类供Fragment中的ViewPager使用。 ViewPager的适配器简介中提到了PagerAdapter，和ListView等控件使用一样,需要ViewPager设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是一个基类适配器，我们经常用它来实现app引导图，它的子类有FragmentPagerAdapter和FragmentStatePagerAdapter,这两个子类适配器用于和Fragment一起使用，在安卓应用中它们就像listview一样出现的频繁。 实现一个最基本的PagerAdapter,必须实现四个方法，在代码里有注释12345678910111213141516171819202122232425262728public class AdapterViewpager extends PagerAdapter &#123; private List&lt;View&gt; mViewList; public AdapterViewpager(List&lt;View&gt; mViewList) &#123; this.mViewList = mViewList; &#125; @Override public int getCount() &#123;//必须实现,返回要滑动的VIew的个数 return mViewList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123;//必须实现,该函数用来判断instantiateItem(ViewGroup, int)函数所返回来的Key与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View) return view == object; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123;//必须实现，做了两件事，第一：将当前视图添加到container中，第二：返回当前View container.addView(mViewList.get(position)); return mViewList.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123;//必须实现，从当前container中删除指定位置（position）的View container.removeView(mViewList.get(position)); &#125;&#125; 实现一个最基本的FragmentPagerAdapter1234567891011121314151617181920212223public class AdapterFragment extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; mFragments; public AdapterFragment(FragmentManager fm, List&lt;Fragment&gt; mFragments) &#123; super(fm); this.mFragments = mFragments; &#125; @Override public Fragment getItem(int position) &#123;//必须实现 return mFragments.get(position); &#125; @Override public int getCount() &#123;//必须实现 return mFragments.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123;//选择性实现 return mFragments.get(position).getClass().getSimpleName(); &#125;&#125; PagerAdapter是基类适配器是一个通用的ViewPager适配器，相比PagerAdapter，FragmentPagerAdapter和FragmentStatePagerAdapter更专注于每一页是Fragment的情况，而这两个子类适配器使用情况也是有区别的。FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况。为什么？简单分析下两个适配器的源码就可以知道了。 源码略，查官网 从源码中我们可以看出FragmentStatePagerAdapter中fragment实例在destroyItem的时候被真正释放，所以FragmentStatePagerAdapter省内存。FragmentPagerAdapter中的fragment实例在destroyItem的时候并没有真正释放fragment对象只是detach，所以FragmentPagerAdapter消耗更多的内存，带来的好处就是效率更高一些。所以得出这样的结论：FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况，因此不同的场合选择合适的适配器才是正确的做法。 ViewPager的翻页动画为ViewPager设置适配器后，就可以正常使用了，接下来我们为ViewPager增加翻页动画，毕竟人的审美会疲劳，加上一些动画交互会提高不少逼格~~，ViewPager提供了PageTransformer接口用于实现翻页动画。官方提供了PageTransformer的实现例子。 例一12345678910111213141516171819202122232425262728293031323334353637 public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; Log.d("DepthPageTransformer", view.getTag() + " , " + position + ""); int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 0) &#123; // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 例二1234567891011121314151617181920212223242526272829303132333435363738394041 public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; @SuppressLint("NewApi") public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); Log.e("TAG", view + " , " + position + ""); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 实现翻页动画的关键就是重写transformPage方法，方法里有两个参数view和position,理解这两个参数非常重要。假设有三个页面view1，view2，view3从左至右在viewPager中显示 往左滑动时：view1，view2，view3的position都是不断变小的。 123view1的position: 0 → -1 → 负无穷大view2的position: 1 → 0 → -1 view3的position: 1 → 0 往右滑动时：view1，view2，view3的position都是不断变大的。 123view1的position: -1 → 0 view2的position: -1 → 0 → 1 view3的position: 0 → 1→ 正无穷大 当position是正负无穷大时view就离开屏幕视野了。因此最核心的控制逻辑是在[-1,0]和(0,1]这两个区间，通过设置透明度，平移，旋转，缩放等动画组合可以实现各式各样的页面变化效果。 简化ViewPager的使用 PagerAdapter简化 12345678910111213141516171819202122232425262728public class QuickPageAdapter&lt;T extends View&gt; extends PagerAdapter &#123; private List&lt;T&gt; mList; public QuickPageAdapter(List&lt;T&gt; mList) &#123; this.mList = mList; &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return object == view; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(mList.get(position)); return mList.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(mList.get(position)); &#125;&#125; 使用它，这样不用每次都写个适配器List views = new ArrayList&lt;&gt;();…mViewPager.setAdapter(new QuickPageAdapter(views)); FragmentPagerAdapter简化 123456789101112131415161718192021222324252627282930public class QuickFragmentPageAdapter&lt;T extends Fragment&gt; extends FragmentPagerAdapter &#123; private List&lt;T&gt; mList; private String[] mStrings; /** * @param fm * @param list * @param titles PageTitles */ public QuickFragmentPageAdapter(FragmentManager fm, List&lt;T&gt; list, String[] titles) &#123; super(fm); mList = list; mStrings = titles; &#125; @Override public Fragment getItem(int position) &#123; return mList.get(position); &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mStrings == null ? super.getPageTitle(position) : mStrings[position]; &#125;&#125; #PagerTitleStrip 将它作为子控件添加在xml布局文件中的ViewPager中 标题的获取，是重写适配器的getPageTitle(int)函数来获取的。 重写CharSequence getPageTitle(int)函数来对其进行实现 PagerTabStrip PagerTabStrip在当前页面下，会有一个下划线条来提示当前页面的Tab是哪个。 PagerTabStrip的Tab是可以点击的，当用户点击某一个Tab时，当前页面就会跳转到这个页面，而PagerTitleStrip则没这个功能。 将它作为子控件添加在xml布局文件中的ViewPager中 标题的获取，是重写适配器的getPageTitle(int)函数来获取的。 扩展：PagerTabStrip属性更改setTabIndicatorColorResource——修改Tab颜色重写适配器CharSequence getPageTitle(int)方法——添加标题 总结PagerTitleStrip和PagerTabStrip通过前面的讲解，我们应该清楚的认识到PagerTabStrip与PagerTitleStrip在添加标题栏的异同，但他们实现的标题栏效果很不好，不能指定一个页面一次显示一个，或者全部显示，而且标题还滑动。所以注定主流的App都没有用这个玩意的。所以这里也只是一个过渡，在开发中，我们也不建议使用这两个东东。 SimpleOnPageChangeListener如果不想继承实现ViewPager.OnPageChangeListener的方法，可以直接继承SimpleOnPageChangeListener对ViewPager的页面滑动事件进行简单的处理。 onPageScrolled] (int position, float positionOffset, int positionOffsetPixels)： position:当前的位置 positionoffset:当前滚动比例（左－右／0-1）（右－左／1-0） positionOffsetPixels：当前实际滚动的像素（左－右／0-页宽） （右－左／页宽－0）被调用的场景： ViewPager滚动时总被回调，这个函数在操作ViewPager时被回调很多次。 手指拖动 action_move 。n次 惯性还原 computeScroll()。n次使用场景：做view的动画效果时可以用这个回调函数。 onPageSelected(int position)被调用的场景：ViewPager确定页面是哪一页时。1次 手指拖动后抬起 action_up 。1次 或者手指滑动超出屏幕时 action_cancel。1次使用场景：页面切换后改变对应的tab的状态可以用这个回调函数。 onPageScrollStateChange (int state):被调用的场景：ViewPager状态切换时被调用。这个函数在操作ViewPager时被回调3次。 开始滚动 dragging拖动状态。1次 惯性滚动 settling还原状态。1次 滚动结束 idle空闲状态。1次使用场景：做页面状态变化后引起的view特效时可以用这个回调函数 ViewPager.OnPageChangeListener onPageScrollStateChanged(int state)//在状态改变的时候调用其中arg0这个参数有三种状态（0，1，2）。arg0 ==1表示正在滑动，arg0==2表示滑动完毕了，arg0==0表示什么都没做。当页面开始滑动的时候，三种状态的变化顺序为(1,2,0) onPageScrolled(int position, float positionOffset, int positionOffsetPixels)//当页面在滑动的时候会调用此方法，在滑动被停止之前，此方法回一直得到调用。其中三个参数的含义分别为：arg0 :当前页面，及你点击滑动的页面。arg1:当前页面偏移的百分比。arg2:当前页面偏移的像素位置 onPageSelected(int position)//页面跳转完后得到调用，arg0是你当前选中的页面的position ViewPager.OnAdapterChangeListenervoid onAdapterChanged ( ViewPagerew viewPager, PagerAdapter oldAdapter,PagerAdapter newAdapter) viewPager: ViewPager where the adapter change has happened(传入发生改变的ViewPager) oldAdapter: the previously set adapter(老的adapter) newAdapter: the newly set adapter(新的adapter) 注意点mViewPager.setOffscreenPageLimit()//这个方法是用来控制fragment不重新走生命周期的个数的，打个比方一共4个fragment页面，如果mViewPager.setOffscreenPageLimit(3)，那么所有的fragment都只走一次生命周期，如果是mViewPager.setOffscreenPageLimit(2)，那么其中有一个fragment会在切换的时候重新走一遍生命周期，FragmentStatePagerAdapter和FragmentPagerAdapter都是这样，但是FragmentPagerAdapter设置setOffscreenPageLimit()不影响fragment缓存的个数,而FragmentStatePagerAdapter缓存的fragment实例个数就是setOffscreenPageLimit()设置的值+1。另外setOffscreenPageLimit()的缺省值是1，设置0是无效的会被强制赋值成1。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Android Studio 快捷键]]></title>
      <url>%2F2017%2F06%2F01%2Fandroid-studio-keywords%2F</url>
      <content type="text"><![CDATA[自动补全 使用Enter会补全你选择的语句 使用Tab的话，会替换掉你之前在这里的内容（删除后面的语句直到遇到点号，逗号，分号） 自动缩进对齐ctr + alt + I 返回编辑器窗口 Esc: 返回编辑器 Shift + Esc: 返回编辑器并关闭当前窗口 快捷打开窗口 Mac: Cmd + 数字 windows/Linux: Alt + 数字 任意窗口切换Ctrl + Tab可以让你切换到任意窗口！在这个切换窗口打开的时候，你可以直接按数字切换到对应的工具窗口，或者输入字母搜索右边的编辑器窗口，如果你需要关闭某个窗口，在上面按BackSpace即可。 隐藏所有窗口 Mac: CMD + Shift + F12 windows/Linux: Ctrl + shift + F12如果需要恢复所有窗口，再按一次这个快捷键即可。 参数提示这个功能估计很多人知道了，但是还是提一下。在自动补全以后，如果某个方法参数超级长，你不知道参数是什么怎么办？可以试试这个。 Mac: CMD + P win/Linux: Ctrl + P 自动生成变量作为一门静态类型语言， Java 是有一定的类型推导能力的；那么你是否经常书写: 12String testStr = "testStr";List&lt;String&gt; testStrings = new ArrayList&lt;String&gt;(); 其实大可不必写那些恼火的类型声明的，一看就知道 1testStr, testStrings 就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。 Mac: Cmd + Alt + V Win/Linux: Ctrl + Alt + V 有的童鞋可能会问了：我使用ArrayList, HashMap的时候，习惯类型声明为List,Map等接口，这个自动生成的类型声明还是具体的实现啊，怎么办？这一点IDE已经帮你想到了，试试shift + tab,他会给你一个可以选择的类型列表～ 自动提取参数有时候你正在写一个方法的时候发现。哎哟，这个变量最好是当作参数传递进来啊；要做成这么一件事，你必须把这个方法内部所有使用这个局部变量的地方替换，把所有调用这个函数的地方添加参数，繁琐至极！好了有了这个你可以随便玩了： Mac: Cmd + Alt + P Win/Linux: Ctrl + Alt + P 当然，如果你想保留原来的方法，只是搞一个参数不同的方法（重载）出来，可以在弹出的那个对话框里面打勾。 自动提取方法写代码的时候是否会发现不知不觉的这个方法已经太长了，适合分解然后提取出一个个子方法；或者是重构的时候看到一个一两千的函数，你是不是头都大了？一般情况下，我们都是把要提取的代码copy出来，然后写一个方法（还要什么该死的方法签名）然后把这段代码复制进来；其实这个过程是机械的，完全可以由IDE完成： Mac: Cmd + Alt + M Win/Linux: Ctrl + Alt + M 如果想改变方法的签名，在对话框里面选择你需要的就可以了～ 上面提到了三个快捷键其实是比较类似的，如何记忆呢？ 首先组合键都是Cmd/Ctrl + Alt 然后提取变量Variable=V，参数Parameters=P，方法Method=M 内联变量/参数/方法好了学会了上面那几个快捷键，万一玩high了，比如提取了太多的方法，想“弄回去”，该怎么办呢？这个操作叫他Inline.. Mac: + Alt + N```1* Win/Linux: ```Ctrl + Alt + N 上面那个图只是参考，其实不仅可以作用于变量，还可以是方法/参数，个人觉得方法inline比较有用。 万能重构键静态类型语言重构起来相对容易的，但是通常修改一个地方会牵扯到很多别的地方，我们只有一处一处找到这些编译错误然后手动修复。其实有好多工作是可以自动完成的，比如删除某个方法；先确认有没有人调用（Alt ＋ F7），没有的话把方法体删了，有的话去看看调用的地方再决定怎么办。但是重构的操作实在是太多了！我们没有办法也没有必要一个个记住，知道这个快捷键即可，我叫他万能重构键: Mac : Ctrl + T Win/Linux: Ctrl + Alt + Shift + T 在Win/ Linux 上可以考虑把这个快捷键改一下键，一下按四个键臣妾很难做到啊。。 重命名shift + F6 查找当前文件在项目中的位置快捷键: Alt + F1 拓展选择这个功能应该很多人都知道；但还是说明一下，因为跟下面两个功能跟这个结合起来才有威力。这个功能太强大了，自己去按几遍就能想到很多使用场景了；我相信有了这个功能，你使用鼠标的机会会少很多。 Mac: Alt + up/down Win/Linux: ctrl + w / ctrl + shift + w Surround With..如果你想把一段代码使用if语句包起来；又或者使用try包围一段可能有运行时异常的代码，你会怎么干？首先用光标定位到代码块开头，写上 try {然后，光标代码块末尾加} catch (XXXRuntimeException e) {// todo}？可以试试这个快捷键。 Mac: cmd + alt + t Win/Linux: ctrl + alt + t 可以使用上面的拓展选择选择你需要的代码块，然后使用这个功能Surround With；如果你什么都不选择的话，那么默认选择的是光标所在行。 Unwrap/Remove这个功能跟上面提到的是一对，有了Surround With自然就有Unsurround With;使用情况没有上面那个那么多，但是好歹一对，一起介绍吧。 高亮某东西有时候看代码的时候，看到某个变量想知道哪里使用了它；你还在用肉眼查找吗？或者你杀鸡用牛刀Find Usgae？其实你的需求就是把这个变量全部给我打个标签，我想直观的知道它在哪。 Mac: cmd + shift + F7 Win/Linux: ctrl + shift + F7这个键功能远不止这个！ 如果你高亮return或者throw，那么会把这个方法所有的返回点高亮出来！ 高亮某个类的extends或者implements会把这个类Override的方法高亮出来 高亮import会把使用的地方显示出来如果不想要高亮了，按下Esc就行。 显示方法调用树在看源码的时候，你还是使用alt + F7和ctrl + B在各个类之间来回穿梭吗？其实好多时候你就是想知道这个调用结构是怎么样的而已；谁是怎么一步一步滴调用谁的；这个快捷键会给你一个调用树。有了这个大菊观，继续探讨就很容易了。快捷键: ctrl + alt + h 万能快捷键记得之前提到过一个万能重构键, 有关重构的一切操作都可通过它完成。那么Android Studio这么快捷键，这么多功能，臣妾怎么可能都记住！要是有万能钥匙就好了！That’s it!使用这个快捷键，你想到什么功能，打开它搜索就可以了；打个比方，我想看看 Java 的for each循环和普通的for循环底层是不是同一个实现;那么我就需要看虚拟机字节码了；我记得有这个功能但是不知道快捷键是啥；OK，Cmd + shift + A，输入bytecode: 删除当前行 Mac: ctrl + Y Win/Linux: Command + Y Find usagealt+F7 格式化代码 Mac: alt+command+L Win/Linux: ctrl+alt+L 优化import Mac: alt+command+O Win/Linux: ctrl+alt+O Declaration查看定义 Mac: command+B Win/Linux: ctrl+B 快递定位并高亮错误（deprecate，unused） Mac: (shift+)F2 Win/Linux: F2 Override Methods Mac: command+O Win/Linux: ctrl+O Implement Methods Mac: command+I Win/Linux: ctrl+I Super Method（Class） Mac: command+U Win/Linux: ctrl+U Previous/Next Methodcontrol+上下方向键 引入包，添加注释…alt+enter 添加/取消bookmark Mac: command+F11 Win/Linux: ctrl+F11 显示bookmark列表shift+F11 展开收缩代码 Mac: command + +/- Win/Linux: ctrl + +/- Move Line Up/Move Line Down Mac: shift+command+上下方向键 Win/Linux: shift+ctrl+上下方向键 Runshift+F10 Debugshift+F9 Make Project Mac: command+F9 Win/Linux: ctrl+F9 Make Module Mac: shift+command+F9 Win/Linux: shift+ctrl+F9 关闭当前的执行的task Mac: command+F2 Win/Linux: ctrl+F2 添加/取消断点 Mac: command+F8 Win/Linux: ctrl+F8 查看所有断点 Debug Mac: shift+command+F8 Win/Linux: shift+ctrl+F8 Step Into F7 Step OverF8 Step outshift+F8 resumeF9 Run to Cursoralt+F9 Find Mac: command+F Win/Linux: command+F Replace Mac: command+R Win/Linux: command+R Find in Pathcontrol+shift+F Replace in Pathcontrol+shiftÏ+R Back/Forward操作 Mac: alt+command+左右方向键 Win/Linux: alt+ctrl+左右方向键 Recent File Mac: command+E Win/Linux: ctrl+E Recently Change Files Mac: shift+command+E Win/Linux: shift+ctrl+E Search Method或者Class(Search Everywhere：command+N,shift+command+N,shift+alt+command+N)shift+shift Search Class Mac: command+N Win/Linux: ctrl+N Search File Mac: shift+command+N Win/Linux: shift+ctrl+N Search Symbol Mac: shift+alt+command+N Win/Linux: shift+alt+ctrl+N]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-线程管理]]></title>
      <url>%2F2017%2F05%2F30%2Fandroid-thread%2F</url>
      <content type="text"><![CDATA[Thread 继承Thread方式 实现Runnable接口 Thread主要函数： run()//包含线程运行时所执行的代码 start()//用于启动线程 sleep()/sleep(long millis)//线程休眠，交出CPU，让CPU去执行其他的任务，然后线程进入阻塞状态，sleep方法不会释放锁 yield()//使当前线程交出CPU，让CPU去执行其他的任务，但不会是线程进入阻塞状态，而是重置为就绪状态，yield方法不会释放锁 join()/join(long millis)/join(long millis,int nanoseconds)//等待线程终止，直白的说 就是发起该子线程的线程 只有等待该子线程运行结束才能继续往下运行 wait()//交出cpu，让CPU去执行其他的任务，让线程进入阻塞状态，同时也会释放锁 interrupt()//中断线程，自stop函数过时之后，我们通过interrupt方法和isInterrupted()方法来停止正在运行的线程，注意只能中断已经处于阻塞的线程 getId()//获取当前线程的ID getName()/setName()//获取和设置线程的名字 getPriority()/setPriority()//获取和这是线程的优先级 一般property用1-10的整数表示，默认优先级是5，优先级最高是10，优先级高的线程被执行的机率高 setDaemon()/isDaemo()//设置和判断是否是守护线程 currentThread()//静态函数获取当前线程 Thread线程主要状态 New 一旦被实例化之后就处于new状态 Runnable 调用了start函数之后就处于Runnable状态 Running 线程被cpu执行 调用run函数之后 就处于Running状态 Blocked 调用join()、sleep()、wait()使线程处于Blocked状态 Dead 线程的run()方法运行完毕或被中断或被异常退出，线程将会到达Dead状态 如何停止一个线程通过interrupt方法和isInterrupted()方法来停止正在运行的线程，首先必须先让线程处于阻塞状态 Thread线程同步问题 同步函数 同步代码块 使用特殊域变量(volatile)实现线程同步 ExecutorService线程池new Thread()的缺点 每次new Thread()耗费性能 调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。 不利于扩展，比如如定时执行、定期执行、线程中断采用线程池的优点 重用存在的线程，减少对象创建、消亡的开销，性能佳 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞 提供定时执行、定期执行、单线程、并发数控制等功能 ExecutorService 12345678910111213141516171819202122232425262728293031323334public interface ExecutorService extends Executor&#123; void shutdown();//顺次地关闭ExecutorService,停止接收新的任务，等待所有已经提交的任务执行完毕之后，关闭ExecutorService List&lt;Runnable&gt; shutdownNow();//阻止等待任务启动并试图停止当前正在执行的任务，停止接收新的任务，返回处于等待的任务列表 boolean isShutdown();//判断线程池是否已经关闭 boolean isTerminated();//如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。 boolean awaitTermination(long timeout, TimeUnit unit)//等待（阻塞）直到关闭或最长等待时间或发生中断,timeout - 最长等待时间 ,unit - timeout 参数的时间单位 如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);//提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。 Future&lt;?&gt; submit(Runnable task);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。 throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。 throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。 throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; &#125; Executor接口 1234public interface Executor &#123; void execute(Runnable command);//执行已提交的 Runnable 任务对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法&#125; Executors工厂类 newFixedThreadPool()创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。(运行结果：总共只会创建5个线程， 开始执行五个线程，当五个线程都处于活动状态，再次提交的任务都会加入队列等到其他线程运行结束，当线程处于空闲状态时会被下一个任务复用) newCachedThreadPool()创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程(运行结果：可以看出缓存线程池大小是不定值，可以需要创建不同数量的线程，在使用缓存型池时，先查看池中有没有以前创建的线程，如果有，就复用.如果没有，就新建新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务) newScheduledThreadPool()创建一个定长线程池，支持定时及周期性任务执行schedule(Runnable command,long delay, TimeUnit unit)创建并执行在给定延迟后启用的一次性操作(运行结果和newFixedThreadPool类似，不同的是newScheduledThreadPool是延时一定时间之后才执行scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnitunit) 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 initialDelay后开始执行，然后在initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推)scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟 newSingleThreadExecutor()创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行(运行结果：只会创建一个线程，当上一个执行完之后才会执行第二个)通过ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();实现延时的单线程线程池。 ThreadPoolExecutorThreadPoolExecutor线程池用于管理线程任务队列、若干个线程。 1.ThreadPoolExecutor构造函数1234ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue);ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit,BlockingQueue workQueue,RejectedExecutionHandler handler);ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler) ;ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory, RejectedExecutionHandler handler); corePoolSize： 线程池维护线程的最少数量 maximumPoolSize：线程池维护线程的最大数量 keepAliveTime： 线程池维护线程所允许的空闲时间 unit： 线程池维护线程所允许的空闲时间的单位 workQueue： 线程池所使用的缓冲队列 threadFactory：线程池用于创建线程 handler： 线程池对拒绝任务的处理策略 AsyncTaskAndroid的AsyncTask比Handler更轻量级一些，适用于简单的异步处理。同时在处理单个后台任务时，AsyncTask的代码量更少并且更加轻量级。AsyncTask定义了三种泛型类型 Params，Progress和Result。 Params 启动任务执行的输入参数，比如HTTP请求的URL。 Progress 后台任务执行的百分比。 Result 后台执行任务最终返回的结果，比如String。使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法： doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。 onPostExecute(Result) 相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回有必要的话你还得重写以下这三个方法，但不是必须的： onProgressUpdate(Progress…) 可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。 onPreExecute() 这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。 onCancelled() 用户调用取消时，要做的操作使用AsyncTask类，以下是几条必须遵守的准则： Task的实例必须在UI thread中创建； execute方法必须在UI thread中调用； 不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法； 该task只能被执行一次，否则多次调用时将会出现异常； 参考Android线程管理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-Issues]]></title>
      <url>%2F2017%2F05%2F28%2Fandroid-issues%2F</url>
      <content type="text"><![CDATA[前言这篇文章主要记录一些在实际开发中遇到的问题，以及对其的解决措施。方便日后解决同样类型的问题。 Activity的使用1、onSaveInstance 和 onRestoreInstanceStateonSaveInstance方法在系统回收Activity之前会调用；Back键不会调用。onPause（）—&gt;onSaveInstanceState( )–&gt;onStop( );onRestoreInstanceState()会在onStart()和onResume()之间执行。 1、当用户按下HOME键时。这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则 2、长按HOME键，选择运行其他的程序时。 3、按下电源按键（关闭屏幕显示）时。 4、从activity A中启动一个新的activity时。 5、屏幕方向切换时，例如从竖屏切换到横屏时。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行 至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和 onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提 是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。activity中保存数据有两种方式onPause()，onSaveInstance(bundle), 恢复数据也有两种途径onCreate(Bundle), onRestoreInstanceState(budle)，默认情况下onSaveInstanceSate()和onRestoreInstanceState()会对UI状态进行保存和恢复，如果需要保存其他数据可以在onSaveInstanceState()，onPause()保存，但是如果是持久化的数据得通过onPause()保存(google推荐)。 二、Fragment使用1、java.lang.IllegalStateException: Fragment does not have a view先说明下出现这个异常的原因，这是在fragment onCreateView()中调用getChildFragmentManager()的时候出现的。解决办法就是不要再onCreateView()中调用getChildFragmentManager()。那么如果你要调用getChildFragmentManager()，那么必须onCreateView之后，view被创建了。 三、UI控件1、Button控件（1）解决Android5.0版本以上Button自带阴影问题设置Button的样式为style=&quot;?android:attr/borderlessButtonStyle&quot; 2、TextView控件（1）Text View中修改文字段落中部分字体颜色使用ForegroundColorSpan来修改 3、CheckBox控件（1）如何修改复选框的样式 首先在drawable文件夹中添加drawable文件checkbox_style.xml。 123456&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/checkbox_pressed" android:state_checked="true"/&gt; &lt;item android:drawable="@drawable/checkbox_normal" android:state_checked="false"/&gt; &lt;item android:drawable="@drawable/checkbox_normal"/&gt; &lt;/selector&gt; 在values文件夹下的styles.xml文件中添加CustomCheckboxTheme样式。 123&lt;style name="CustomCheckboxTheme" parent="@android:style/Widget.CompoundButton.CheckBox"&gt; &lt;item name="android:button"&gt;@drawable/checkbox_style&lt;/item&gt; &lt;/style&gt; 在布局文件中使用CustomCheckboxTheme样式。12345&lt;CheckBox android:id="@+id/select_all" android:layout_width="wrap_content" android:layout_height="wrap_content" style="@style/CustomCheckboxTheme" /&gt; 4、RecyclerView控件（1）RecyclerView删除Item导致位置错乱RecyclerView的刷新分为内容变化和结构变化，结构变化比如remove和insert等并不会导致viewholder的更新，所以有时候我们使用notifyItemRemoved(position);或者使用notifyItemInserted(position);item的位置并没有发生改变，或者位置发生错乱，很是奇怪诡异，需要重新调用notifyDataSetChanged();才能刷新整个List每个Item的位置，但这样做会使得RecyclerView增加和删除的动画效果没有了。那么要既想没有Bug的插入删除，又想有动画怎么搞呢，只需要刷新删除位置以下的List的Item位置即可，那么幸亏RecyclerView有一个局部刷新的方法：notifyItemRangeChanged(int positionStart, int itemCount)怎么使用呢？ 我们只需要在删除或插入时同时,刷新改变位置item下方的所有Item的位置： 插入动作： 1234notifyItemInserted(position);if (position != mData.size()) &#123; otifyItemRangeChanged(position, mData.size() - position); &#125; 删除动作： 1234 notifyItemRemoved(position);if (position != mData.size()) &#123; otifyItemRangeChanged(position, mData.size() - position); &#125; （2）RecyclerView只显示第一个数据在onCreateViewHolder中获取View的时候不指定ViewGroup 123456@Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext()); View convertView = layoutInflater.inflate(R.layout.item, null, false); // if use parent, only first line will show up return new ViewHolder(convertView); &#125; 5、EditText控件（1）如何自动打开软键盘四、自定义View的实现1、自定义TextView时，自定义参数的设置自定义属性一般在onMeasure()方法后才能将XML文件中的自定义设置的属性数值传递进来，无法在setBackground()方法和setText()方法直接调用。如果是想要在代码中设置变量属性，还是直接在自定义控件扩展类中添加新方法进行使用。自定义控件的三个构造类 123public GuideTextView(Context context) //在代码中直接使用public GuideTextView(Context context, AttributeSet attrs) //在xml文件中直接使用时调用public GuideTextView(Context context, AttributeSet attrs, int defStyleAttr) //xml文件中使用默认主题时调用 2、扩展自定义View的实现在onDraw()方法中，将绘制代码写在super.onDraw(canvas);方法之前，绘制效果将显示在控件底层；将绘制代码写在super.onDraw(canvas);方法之后，绘制效果将显示在控件底层。 3、getDimension()、getDimensionPixelOffset()和getDimensionPixelSize()的区别 getDimension()是基于当前DisplayMetrics进行转换，获取指定资源id对应的尺寸。文档里并没说这里返回的就是像素，要注意这个函数的返回值是float，像素肯定是int。 getDimensionPixelSize()与getDimension()功能类似，不同的是将结果转换为int，并且小数部分四舍五入。 getDimensionPixelOffset()与getDimension()功能类似，不同的是将结果转换为int，并且偏移转换（offset conversion，函数命名中的offset是这个意思）是直接截断小数位，即取整（其实就是把float强制转化为int，注意不是四舍五入哦）。由此可见，这三个函数返回的都是绝对尺寸，而不是相对尺寸（dp/sp等）。如果getDimension()返回结果是20.5f，那么getDimensionPixelSize()返回结果就是21，getDimensionPixelOffset()返回结果就是20。 4、DisplayMetrics显示的数值 density: 显示的逻辑分辨率 width及height: 屏幕分辨率(绝对宽高) scaleDensity: 字体显示的缩放因子 xdpi及ydpi: 水平方向DPI和竖直方向DPI 5、屏幕尺寸单位 屏幕尺寸: 屏幕尺寸指屏幕的对角线的长度，单位是英寸(in)，1英寸=2.54厘米 px: 是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素，一般以纵向像素*横向像素。 dpi: dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。 density: 屏幕密度，density和dpi的关系为 density = dpi/160 dp和dip: 设备独立像素，device independent pixels的缩写， Android 特有的单位，在屏幕密度dpi = 160屏幕上，1dp = 1px。dp和density的关系为 1dp = density px，dip值 =（dpi值/160）* pixel值 sp: 和dp很类似，一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。 6、EditText启动软键盘怎么和EditText布局一起上移，并且背景不动在根布局中添加ScrollView来存放背景显示内容，中间必须添加一个RelativeLayout或者LinearLayout(如果添加RelativeLayout则ScrollView必须设置属性android:fillViewport=&quot;true&quot;)，在ScrollView控件底下添加EditText所在布局，设置AndroidManifest.xml中android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot;，在代码中设置RelativeLayout中的显示布局的布局属性。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.jrm.adolph.test1.MainActivity"&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent" android:fillViewport="true"&gt; &lt;RelativeLayout android:id="@+id/layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="64dp" android:background="@color/colorAccent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:text="软键盘" android:textSize="20sp"/&gt; &lt;/RelativeLayout&gt; &lt;RelativeLayout android:id="@+id/content_layout" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:layout_centerInParent="true" android:textSize="20sp"/&gt; &lt;/RelativeLayout&gt; &lt;/RelativeLayout&gt; &lt;/ScrollView&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="48dp" android:layout_alignParentBottom="true"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="送礼"/&gt; &lt;EditText android:id="@+id/et" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_weight="1"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="发送"/&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 12345Rect outRect = new Rect();getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect);RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) layout.getLayoutParams();params.height = outRect.bottom - outRect.top;layout.setLayoutParams(params); 7、设置Button的selector控制按钮的点击形态设置好press、enable属性的对应图片，点击按钮图片形态不响应。必须把默认的按钮图片样式放在最底下，才能实现。12345&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/lucky_turntable_pressed_btn" android:state_pressed="true"/&gt; &lt;item android:drawable="@drawable/lucky_turntable_unable_btn" android:state_enabled="false"/&gt; &lt;item android:drawable="@drawable/lucky_turntable_focusable_btn"/&gt;&lt;/selector&gt; 8、DispatchTouchEvent重写dispatchTouchEvent的时候，无论你是return true，亦或是return false都会导致child接受不到事件。return true ： 告诉parent，这个事件我消费了。如果这个是down事件，那么我就会作为一个target或者说handle(事件持有者)，后续的move事件或者up事件等，都会直接分发到我这里，不继续往下分发。return false：告诉parent，这个事件我不需要，那么会交回给parent的onTouchEvnet处理。只有return super.dispatchTouchEvent的时候才会将事件继续往下传递。 五、Android类库使用问题1、Android DataBinding（1）include布局使用，如何传变量进去include布局中同样用layout标签包裹，将父布局中的变量以1app:XXX=&quot;@&#123;XXX&#125;&quot; 自定义属性的形式传进去,并在include布局中同样申明XXX相同的变量名以及变量类型，即可进行使用。注意使用在表达式中使用View.VISIBLE设置可视化的时候导入View类，否则会报错。 （2）如何调用include中的控件普通调用include中的控件，直接使用findViewById可以直接获取控件。使用dataBinding时，有时会出现获取控件无法调用的情况，这种情况给include标签赋一个id，在类中通过bind.&lt;include-id&gt;.&lt;widget-id&gt;进行调用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-常用的Android库]]></title>
      <url>%2F2017%2F05%2F18%2Fandroid-common-android-library%2F</url>
      <content type="text"><![CDATA[前言Android开发中常用的以及想要尝试的库，在这里还是记录下。 Lottie这是一个能解析Adobe After Effects动画导出的JSON文件并把它们渲染成本地动画的库。在Google Play Store上有一个示例app。 Toasty一个创建自定义Toast的库。 StyleableToast这是另外一个创建自定义Toast的库。 StoreStore是一个异步加载和缓存库。文档描述： Store是一个简化数据的请求，解析，保存，以及数据重试的类。一个Store类似于 仓库模式 ，不过用RxJava封装成了响应式的API，以支持单向数据流 。 文档非常易懂，这个库值得尝试。你可以尝试各种flows，比如数据请求，缓存，解析等。 PreviewSeekBar如果你使用Google Play Movies，你可能注意到了这个动画效果很棒，可以预览电影的SeekBar。 Rúben Sousa 实现了这种效果并开源。 Chuck如果你使用 OkHttp的话，这个库可以帮助你拦截并记录所有的HTTP请求与响应。它还提供了一个来显示内容。 CoordinatorTabLayoutCoordinatorTabLayout是一个自定义的组合控件，帮助你快速实现TabLayout与CoordinatorLayout相结合的样式。 BoxingBoxing是一个基于MVP模式的Android多媒体选择器，你可以： 图片选择（单／多选）， 预览或者剪裁图片。 它还支持gif，视图选择，图片压缩以及自定义UI： excelPanelRecyclerView实现的二维表格，不仅可以加载历史数据，还能加载新数据。 Horizontal Calendar又一个用RecyclerView实现的Material横向日历视图。 CameraFragment一个集成了拍照功能的Fragment ，根据README： CameraFragment直接预览camera视图，并提供简单的API来捕获或者管理设备。你可以使用CameraFragment设置自己的布局以及控制camera。 ShimmerRecyclerView一个可以在加载数据的时候显示闪烁（Shimmer）的RecyclerView。这个RecyclerView内置一个adapter，控制shimmer的外观。 CounterFab这是一个在浮动操作按钮的右上角显示数字标识的库。可以从Google Play上下载demo app。 FadingTextView一个可以让TextView以淡如淡出的形式不断改变自己内容的库。 Bridge Bridge是一个简单但是强大的HTTP网络操作库。提供链式调用的API，为了最大的兼容性和最快的速度，用 Java/Android的URLConnection类实现。 这个库文档非常齐全，绝对值得一试。 Ason这是Aidan Follestad的第二个library。其主要目的是简化和JSON的交互。 also makes (de)serialization painless. ObjectBox大家都应该知道greenrobot，不知道的话也应该知道他们开发的 GreenDAO 和 EventBus。这次要介绍的是一个面向对象的数据库。greenrobot宣称： 性能是我们创建ObjectBox的首要因素。之前我们创建了安卓和SQLite上最快的对象关系映射 (ORM) greenDAO。自从2011年第一个版本发布以来，我们对对象持久化－以及SQLite的缺陷有了许多认识。我们意识到， 要显著提高移动端的性能，需要从内核开始，创建一个基于对象的数据库。 FlowLayout一个让子view在空间不够的情况下自动跳到下一行的布局。子view之间的间隔由FlowLayout计算出来，以便让view是均匀分布的。 Shortbread这是一个这样的库 为使用了@Shortcut注解的Activity和方法生成app shortcuts。无需动用manifest, XML以及shortcut manager。只需为想要shortcut调用的代码添加注释。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android-多线程任务]]></title>
      <url>%2F2017%2F05%2F16%2Fandroid-multithreading%2F</url>
      <content type="text"><![CDATA[前言由于这么长时间以来对Android的多线程任务的处理的概念一直很模糊，所以花了一段时间来了解Android多线程的实现方式，以及在何种场景使用何种多线程处理方式。 AsyncTask]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github pages和Hexo搭建]]></title>
      <url>%2F2017%2F04%2F11%2Fbuild-the-githubpages-with-hexo%2F</url>
      <content type="text"><![CDATA[前言由于之前Jekyll的博客搭建起来，插件支持太少，以及其他的目录和语法高亮支持不太好，过于麻烦。最近看了其他人用Hexo搭建的Blog，被其简洁和方便，美观的界面所深深吸引。所以，查询其相关资料，发现的确很棒，而且文档相对Jekyll来说也齐全很多。顿时萌生了转战Hexo的想法。搭建完成后，发现的确好棒，很多在Jekyll上无法实现的功能，在这里能轻松实现，而且搭配Next主题，秒杀全场啊。 一、基础博客搭建流程安装Node和Git1、安装node.js。brew install node 2、安装git。brew intall git 3、选装cnpm。淘宝cnpm官网。由于npm国内下载速度经常抽风，所以建议安装淘宝的这个镜像；使用方法就是在命令中把npm换成cnpm即可。安装方法：在cmd工具中输入如下命令npm install -g cnpm --registry=https://registry.npm.taobao.org 安装Hexo及其相关插件1、全局安装Hexocnpm install hexo-cli -g #安装hexohexo -v #出现版本信息则表示安装成功 2、在项目中安装Hexo创建文件夹，进入文件夹目录cnpm install hexo --save #在当前项目中安装hexohexo init #初始化hexocnpm install #安装依赖包 3、安装Hexo的插件cnpm install hexo-server --save #搭建本地服务器所需插件cnpm install hexo-deployer-git --save #使用git方式进行部署博客所需插件 在本地生成博客静态页面并预览1、在本地生成静态页面hexo generate，会生成一个存放静态文件的文件夹public，其简写形式为hexo g 2、启动本地服务器hexo server,其简写形式为hexo s这条指令运行完成后可在本地启动服务器并预览博客，默认网址为http://localhost:4000/。 创建GitHub Pages并配置ssh1、创建博客仓库。注册并登陆到GitHub官网，假如你注册的用户名是Magic，那么新建一个名为Magic.github.io的仓库，注意仓库的用户名一定要是用户名+github.io的形式！ 2、本地生成ssh密钥。终端下输入ssh-keygen -t rsa -C ‘你的邮箱地址’ 3、上传本地的公钥串，使当前电脑与GitHub账户建立联系。/Users/你的计算机用户名/.ssh 目录下打开刚刚生成的id_rsa.pub，复制里面的内容。然后点击你GitHub账户右上角的头像，选择settings，找到SSH and GPG keys，点击进入之后再点击New SSH key，title随便写，把公钥串粘贴到文本框，保存即可。cat id_rsa.pub 本地博客同步到GitHub上这一步其实就是把本地生成的博客内容（静态页面）放到GitHub新建成的仓库Magic.github.io中。 1、编辑博客配置文件: _config.yml在hexo根目录下找到_config.yml文件，把其中的deploy参数（没有的话就按如下格式新建，注意冒号后面一定要有一个空格），修改为： 1234deploy: type: git repo: git@github.com:LiLei/LiLei.github.io.git branch: master 2、重新部署打开终端，进入博客根目录，依次执行如下Hexo命令：hexo clean #会清除缓存文件db.json及之前生成的静态文件夹publichexo g #会重新生成静态文件夹publichexo deploy #因为之前已经安装了插件并且在博客配置文件中也配置好了，所以这个命令会在博客根目录下生成一个.deploy_git的文件夹，并 把本地生成的静态文件部署到Magic.github.io这个仓库中的master分支上；简写形式为hexo d； hexo g 和 hexo d可以合并在一起写：hexo g -d 3、在浏览器中访问博客在浏览器中输入Magic.github.io（可能你已经发现了，这个就是之前新建仓库的名字，同时也是你博客的域名），没毛病的话，你应该可以再次看到那个熟悉又亲切的博客页面了。 二、更换主题Blog的主题还是很重要的，直接影响写博客和看博客人的心情。在浏览了官网的全部主题以及和Next的对比下，最终还是选用了Next。毕竟有官方文档支持，而且符合内心界面简洁的风格，功能自定义强大，全面。 更换主题主要是两步，先下载主题然后放到博客中的themes文件夹（专门用来存放主题）下，再修改主题的配置文件_config.yml中相关参数，启用themes文件夹下新增的主题。这里用Next主题做示例。 下载Next主题。进入 根目录/themes 文件夹中，打开终端，输入：git clone https://github.com/iissnan/hexo-theme-next themes/next把主题包克隆到themes文件夹中即可。 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开根目录下的站点配置文件_config.yml， 找到 theme 字段，并将其值更改为 next（注意冒号后面要留一个 空格）。 验证主题清除并重新生成hexo静态文件，启动本地服务器，然后通过http://localhost:4000/预览博客：hexo clean #清除静态文件hexo g #重新生成静态文件hexo s #启动服务器 Next中文官网官网有更加全面的介绍 三、自定义域名自定义域名对于我们这些不喜欢加github.io后缀的人来说还是很有必要的。而且githubpages的浏览速度过慢，导致体验很差。所以我们需要加速，如果不使用GithubPages的话，可以直接搭在自己的服务器上，这样速度够快。另一种方法就是对域名使用CDN加速了，阿里云的CDN加速太贵了，查了一下发现百度有免费的CDN加速(发现百度还是有点良心的)。百度云加速 百度云加速域名解析设置1、进入域名服务商的后台解析DNS域名解析为ns1.bddns.cn和ns2.bddns.cn 2、进入百度云加速域名的解析后台，添加如下两条解析记录： 3、在博客目录的source文件夹下（根目录/source）创建一个名为CNAME的文件，内容为你注册域名。 CNAME是不带任何后缀的。 上面操作完毕后，大概过几分钟就可以通过自定义的新域名访问博客了。如果不行，就依次执行hexo clean、hexo g 、hexo d再试下。 四、博客操作1、新建文章hexo new post 背影在Git Bash中执行上面命令会新建一篇名为‘背影’的文章，源文件会自动生成到hexoBlog/source/_post 路径下，后缀为.md，直接打开编辑就可以了。编辑完保存，然后再依次执行hexo clean、hexo g、hexo d在博客就可以看到你的文章了（有时候网络问题生成会比较慢，需要等几分钟才可以看到）。如果习惯了之前Jekyll的博客命名风格，修改站点配置文件_config.yml的内容new_post_name: :year-:month-:day-:title.md # File name of new posts，之后就可以使用时间-名字的文件命名风格了。 2、新建页面新建标签、分类、关于我等各种页面，并在博客的菜单栏中显示。这里以新建‘标签’页面来做示范。 1、创建页面。在终端中执行hexo new page &#39;tags&#39;，会在根目录/source路径下自动生成一个名为tags的文件夹，里面包含一个index.md的文件，在这个文件中添加对应的页面类型type: tags：12345---title: Tagclouddate: 2017-01-01 15:24:23type: &apos;tags&apos; #声明页面类型--- 把页面路径添加到菜单中。编辑主题配置文件（themes/_config.yml）,找到menu字段，添加tag: /tags（格式为item_name: link），如下：123menu: home: / tag: /tags #‘标签’’页面的路径 设置博客中‘标签’这个菜单项的显示图标。同样是在主题配置文件中，找到nenu_icons字段，添加tags tags（格式为item_name: icon_name），如下：1234menu_icons: enable: true #显示图标 home: home tag: tags #tag标签的icons是‘tags’ 设置博客中‘标签’这个菜单项的显示文本。上面的item_name并不会直接用于博客界面的显示，只是用来匹配图标和显示在页面上的文字，可以理解为一个桥梁。那么到底在哪里设置呢？首先，在站点配置文件中（hexoBlog下的_config.yml文件）找到language字段，设置为zh-Hans；然后， 在themes/next/languages路径下找到zh-Hans.yml文件，在menu字段下添加tag: 标签云（格式为item_name: show_name），如下：123menu: home: 首页 tag: 标签云 #博客页面就会显示‘标签云’ 五、多终端同步管理技巧如果你使用过云盘或者有Git操作的基础，下面的内容会非常好理解。 1、思路：需要发布到GitHub仓库的静态内容（也就是执行hexo g -d之后生成的public和.deploy_git文件夹）放在master上，而博客所有其他源文件（除了public和.deploy_git）存放到另外一个新建的hexo分支（这个分支的名字可以随意取），并且在GitHub上将其设为默认分支。以后所有的操作都会在hexo这个分支上进行，操作完之后依次执行git add .、git commit -m &#39;commets&#39;、git push把所有源文件推到远程仓库的hexo分支上（这里远程仓库其实扮演了一个云盘的角色）；即使换了电脑，你可以直接clone远程仓库的hexo分支到本地或者执行git pull下拉更新到本地覆盖现有源文件，就在本地还原了最新的博客内容了。 2、操作流程假设你最早是在家里的A电脑上搭建了博客，那么A电脑的准备工作：把源文件push到GitHub。 1、初始化仓库博客根目录下依次执行：git initgit remote add origin &lt;server&gt; 2、新建并切换到hexo分支git checkout -b hexo 3、找到.gitignore文件（没有的话就在根目录下新建一个）,在最后增加两行内容：/.deploy_git 和 /public 目的是让git不跟踪这两个文件的更新，也就是push到hexo分支的内容里不会有这两个文件。 4、把本地新建的分支push到远程分支：git add .git commit -m &#39;commets&#39;git push -u origin hexo:hexo 然后再去GitHub上把新建的hexo分支设置为默认分支。 画面一转，我们到了公司。此时公司B电脑上空空如也，那么执行如下操作： 在桌面（或任意地址）执行git clone &lt;server&gt; -b &lt;branch&gt;这里的是你远程仓库的clone地址，就是之前新创建的hexo分支，这句话的作用是把远程仓库中的分支克隆到本地当前目录。有了源文件就可以任性修改博客了。修改完之后先生成静态文件发布到博客中：hexo cleanhexo g -d再把最终保存的源文件push到GitHub，保证多终端可以同步：git add .git commit -m &#39;comment&#39;git push最后画面再切换会家中的A电脑，因为此时远程仓库中的博客源文件已经做了更新，而我们A电脑上也有之前的源文件，那么只需要下来更新覆盖到本地就可以啦，进入到博客根目录，执行：git pull 六、优化博客设置文字居中（写博客时）在你博客文章中需要居中处加上下面这段代码即可，中间的文字改成你所需要的文字。 123456789101112131415161718192021&lt;blockquote class=&quot;blockquote-center&quot;&gt;不忘初心，这里可以写多行文字&lt;/blockquote&gt; ``` &lt;blockquote class=&quot;blockquote-center&quot;&gt;不忘初心，这里可以写多行文字&lt;/blockquote&gt;## 为博客加上GitHub丝带如果是Next主题（其他主题也差不多），添加GitHub丝带：在**themes\next\layout\_layout.swig**中加入相关代码，记得修改自己的链接。相关代码你可以在GitHub官方网站 [GitHub Ribbons](https://github.com/blog/273-github-ribbons) 上进行选择。## 加入作者版权信息我们可以为博客文章加入作者版权信息。 例如本文地址：http://www......./ 转载请注明出处，谢谢！等等。 对Next主题而言，先找到**/themes/next/layout/_macro/post.swig**，再找到其中的微信订阅部分，如下所示： ![20170331149093965647853.png](http://ohtrrgyyd.bkt.clouddn.com/20170331149093965647853.png)然后直接在其上面添加如下代码段： 本文地址：{ { page.permalink } }转载请注明出处，谢谢！ 12345678910111213当然，在上面这段代码，你可以进行一些个性化编写，可以展示你自己个性化的版权信息。## 为博客加入动态背景首先找到**\themes\next\layout\_layout.swig**，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。- 默认灰色线条`&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;`- 浅蓝色线条`&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot; count=&quot;50&quot; zindex=&quot;-2&quot; opacity=&quot;1&quot; color=&quot;0,104,183&quot;&gt;&lt;/script&gt;`- 然后在**themes\source\js\src**`下新建文件particle.js`写上以下代码: !function(){function n(n,e,t){return n.getAttribute(e)||t}function e(n){return document.getElementsByTagName(n)}function t(){var t=e(“script”),o=t.length,i=t[o-1];return{l:o,z:n(i,”zIndex”,-1),o:n(i,”opacity”,.5),c:n(i,”color”,”0,0,0”),n:n(i,”count”,99)} }function o(){c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function i(){l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i){for(i.x+=i.xa,i.y+=i.ya,i.xa=i.x&gt;c||i.x&lt;0?-1:1,i.ya=i.y&gt;a||i.y]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git学习笔记]]></title>
      <url>%2F2017%2F04%2F05%2Fgit%2F</url>
      <content type="text"><![CDATA[前言Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。相对于SVN来说，可能Git更符合个人开发者的习惯。而且由于GitHub开源代码平台的出色，导致很多优秀的代码都通过Git保存在其中，所以学会使用Git也是重中之重，对于一个程序员来说基本是必备的技能。所以，全面了解Git还是很有必要的。 Git常用操作命令远程仓库相关命令检出仓库：$ git clone git://github.com/jquery/jquery.git查看远程仓库：$ git remote -v添加远程仓库：$ git remote add [name] [url]删除远程仓库：$ git remote rm [name]修改远程仓库：$ git remote set-url --push [name] [newUrl]拉取远程仓库：$ git pull [remoteName] [localBranchName]推送远程仓库：$ git push [remoteName] [localBranchName] 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：$git push origin test:master // 提交本地test分支作为远程的master分支$git push origin test:test // 提交本地test分支作为远程的test分支 分支(branch)操作相关命令查看本地分支：$ git branch查看远程分支：$ git branch -r创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支切换分支：$ git checkout [name]创建新分支并立即切换到新分支：$ git checkout -b [name]删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并创建远程分支(本地分支push到远程)：$ git push origin [name]删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] 创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)$git symbolic-ref HEAD refs/heads/[name]$rm .git/index$git clean -fdx 版本(tag)操作相关命令查看版本：$ git tag创建版本：$ git tag [name]删除版本：$ git tag -d [name]查看远程版本：$ git tag -r创建远程版本(本地版本push到远程)：$ git push origin [name]删除远程版本：$ git push origin :refs/tags/[name]合并远程仓库的tag到本地：$ git pull origin --tags上传本地tag到远程仓库：$ git push origin --tags创建带注释的tag：$ git tag -a [name] -m &#39;yourMessage&#39; 子模块(submodule)相关操作命令添加子模块：$ git submodule add [url] [path]如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs初始化子模块：$ git submodule init ----只在首次检出仓库时运行一次就行更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下删除子模块：（分4步走哦） $ git rm --cached [path] 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 编辑“ .git/config”文件，将子模块的相关配置节点删除掉 手动删除子模块残留的目录 忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如123targetbin*.db Git 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263git branch 查看本地所有分支git status 查看当前状态 git commit 提交 git branch -a 查看所有的分支git branch -r 查看本地所有分支git commit -am &quot;init&quot; 提交并且加注释 git remote add origin git@192.168.1.119:ndshowgit push origin master 将文件给推到服务器上 git remote show origin 显示远程库origin里的资源 git push origin master:developgit push origin master:hb-dev 将本地库与服务器上的库进行关联 git checkout --track origin/dev 切换到远程dev分支git branch -D master develop 删除本地库developgit checkout -b dev 建立一个新的本地分支devgit merge origin/dev 将分支dev与当前分支进行合并git checkout dev 切换到本地dev分支git remote show 查看远程库git add .git rm 文件名(包括路径) 从git中删除指定文件git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来git config --list 看所有用户git ls-files 看已经被提交的git rm [file name] 删除一个文件git commit -a 提交当前repos的所有的改变git add [file name] 添加一个文件到git indexgit commit -v 当你用－v参数的时候可以看commit的差异git commit -m &quot;This is the message describing the commit&quot; 添加commit信息git commit -a -a是代表add，把所有的change加到git index里然后再commitgit commit -a -v 一般提交命令git log 看你commit的日志git diff 查看尚未暂存的更新git rm a.a 移除文件(从暂存区和工作区中删除)git rm --cached a.a 移除文件(只从暂存区中删除)git commit -m &quot;remove&quot; 移除文件(从Git中删除)git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)git diff --cached 或 $ git diff --staged 查看尚未提交的更新git stash push 将文件给push到一个临时空间中git stash pop 将文件从临时空间pop下来---------------------------------------------------------git remote add origin git@github.com:username/Hello-World.gitgit push origin master 将本地项目给提交到服务器中-----------------------------------------------------------git pull 本地与服务器端同步-----------------------------------------------------------------git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。git push origin serverfix:awesomebranch------------------------------------------------------------------git fetch 相当于是从远程获取最新版本到本地，不会自动mergegit commit -a -m &quot;log_message&quot; (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：git branch branch_0.1 master 从主分支master创建branch_0.1分支git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0git checkout branch_1.0/master 切换到branch_1.0/master分支du -hs-----------------------------------------------------------mkdir WebAppcd WebAppgit inittouch READMEgit add READMEgit commit -m &apos;first commit&apos;git remote add origin git@github.com:daixu/WebApp.gitgit push -u origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EventBus 3.0的使用]]></title>
      <url>%2F2017%2F04%2F02%2Fandroid-eventbus%2F</url>
      <content type="text"><![CDATA[前言一直用Handler来处理应用内的通信，但是发现局限性还是太大了。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。 使用EventBus添加依赖库compile &#39;org.greenrobot:eventbus:3.0.0&#39; 注册举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。12345678910111213@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); EventBus.getDefault().register(this);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this);&#125; 订阅者类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了:1234@Subscribe(threadMode = ThreadMode.MainThread)public void helloEventBus(String message)&#123; mText.setText(message);&#125; 该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？ 发布者既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：12String json="";EventBus.getDefault().post(json); 这样就OK了，你可以试下能否正常运行了！ 原理初探你订阅了内容，所以你需要在该类注册EventBus，而你订阅的方法需要传入String,即你的接收信息为String类型，那么在post的时候，你post出去的也应该是String类型，其才会接收到消息。 如果你post的是对象首先你需要定义一个类似pojo类：12345678public class MessageEvent &#123; public final String name; public final String password; public MessageEvent(String name,String password) &#123; this.name = name; this.password=password; &#125;&#125; 然后你post的时候：EventBus.getDefault().post(new MessageEvent(&quot;hello&quot;,&quot;world&quot;)); 当然，你接收的方法也需要改为：1234@Subscribe(threadMode = ThreadMode.MainThread)public void helloEventBus(MessageEvent message)&#123; mText.setText(message.name);&#125; ThreadMode提供了四个常量： MainThread 主线程 BackgroundThread 后台线程 Async 后台线程 PostThread 发送线程（默认） BackgroundThread:当事件是在UI线程发出，那么事件处理实际上是需要新建单独线程，如果是在后台线程发出，那么事件处理就在该线程。该事件处理方法应该是快速的，避免阻塞后台线程。Async：发送事件方不需要等待事件处理完毕。这种方式适用于该事件处理方法需要较长时间，例如网络请求。 EventBus黏性事件EventBus除了普通事件也支持粘性事件，这个有点类似广播分类中的粘性广播。本身粘性广播用的就比较少，为了方便理解成订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅函数有所不同，需要注解中添加sticky = true1234@Subscribe(threadMode = ThreadMode.MAIN,sticky = true) //在ui线程执行 public void onDataSynEvent(DataSynEvent event) &#123; Log.e(TAG, "event----&gt;" + event.getCount());&#125; 发送粘性事件EventBus.getDefault().postSticky(new DataSynEvent()); 对于粘性广播我们都比较清楚属于常驻广播，对于EventBus粘性事件也类似，我们如果不再需要该粘性事件我们可以移除EventBus.getDefault().removeStickyEvent(new DataSynEvent()); 或者调用移除所有粘性事件EventBus.getDefault().removeAllStickyEvents(); 默认情况下，其为false。什么情况下使用sticky呢？当你希望你的事件不被马上处理的时候，举个栗子，比如说，在一个详情页点赞之后，产生一个VoteEvent，VoteEvent并不立即被消费，而是等用户退出详情页回到商品列表之后，接收到该事件，然后刷新Adapter等。其实这就是之前我们用startActivityForResult和onActivityResult做的事情。 订阅事件的优先级事件的优先级类似广播的优先级，优先级越高优先获得消息1234@Subscribe(threadMode = ThreadMode.MAIN,priority = 100) //在ui线程执行 优先级100 public void onDataSynEvent(DataSynEvent event) &#123; Log.e(TAG, "event----&gt;" + event.getCount());&#125; 终止事件往下传递发送有序广播可以终止广播的继续往下传递，EventBus也实现了此功能EventBus.getDefault().cancelEventDelivery(event) ;//优先级高的订阅者可以终止事件往下传递 建议推荐大家在使用EventBus的时候，创建一个事件类，把你的每一个参数（或者可能发生冲突的参数），封装成一个类：12345678public class Event &#123; public static class UserListEvent &#123; public List&lt;User&gt; users ; &#125; public static class ItemListEvent &#123; public List&lt;Item&gt; items; &#125; &#125; processor使用按照Markus Junginger的说法（EventBus创作者），在3.0中，如果你想进一步提升你的app的性能.EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析,处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.其在编译的时候为注册类构建了一个索引，而不是在运行时，这样的结果是其让EventBus 3.0的性能提升了一倍，相比2.4来说，其会是它的3到6倍。大家可以感受下： 具体使用：在build.gradle中添加如下配置12345678910111213141516buildscript &#123; dependencies &#123; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; &#125;&#125;apply plugin: &apos;com.neenbedankt.android-apt&apos;dependencies &#123; compile &apos;org.greenrobot:eventbus:3.0.0&apos; apt &apos;org.greenrobot:eventbus-annotation-processor:3.0.1&apos;&#125;apt &#123; arguments &#123; eventBusIndex &quot;com.whoislcj.eventbus.MyEventBusIndex&quot; &#125;&#125; 使用索引此时编译一次，自动生成生成索引类。在\build\generated\source\apt\PakageName\下看到通过注解分析生成的索引类，这样我们便可以在初始化EventBus时应用我们生成的索引了。自动生成的代码。123456789101112131415161718192021222324252627282930/** This class is generated by EventBus, do not edit. */public class MyEventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); putIndex(new SimpleSubscriberInfo(com.whoislcj.testhttp.MainActivity.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo("onDataSynEvent", com.whoislcj.testhttp.eventBus.DataSynEvent.class, ThreadMode.MAIN, 100, false), new SubscriberMethodInfo("onDataSynEvent1", com.whoislcj.testhttp.eventBus.TestEvent.class, ThreadMode.MAIN, 0, true), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; 添加索引到EventBus默认的单例中EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus(); 对比添加前后注册效率对比分别EventBus.getDefault().register(this); 添加之前：前后用了9毫秒 添加之后：前后用了2毫秒]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GreenDao3.2.0的使用]]></title>
      <url>%2F2017%2F03%2F31%2Fandroid-greendao%2F</url>
      <content type="text"><![CDATA[前言我相信，在平时的开发过程中，大家一定会或多或少地接触到SQLite。然而在使用它时，我们往往需要做许多额外的工作，像编写 SQL语句与解析查询结果等。所以，适用于Android ORM框架也就孕育而生了，现在市面上主流的框架有OrmLite、SugarORM、Active Android、Realm与greenDAO。但是使用数量最多的还是Realm与greenDAO，所以为了目前的项目需要写个文档记录一下greenDAO的使用。简单的讲，greenDAO是一个将对象映射到SQLite 数据库中的轻量且快速的ORM解决方案。（greenDAO is a light &amp; fast ORM solution that maps objects to SQLite databases.）。这个图对于理解greenDAO是必不可少的。 greenDAO特点 性能最大化，可能是Android平台上最快的ORM框架 易于使用的API 最小的内存开销 依赖体积小 支持数据库加密 强大的社区支持 配置greenDAO在app的Gradle中配置：apply plugin: &#39;org.greenrobot.greendao&#39;123dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.0&apos;&#125; 在project的Gradle中配置：123456789buildscript &#123; repositories &#123; jcenter() mavenCentral() &#125; dependencies &#123; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.1&apos; &#125;&#125; 在app的Gradle配置数据库版本等信息12345greendao &#123; schemaVersion 1 //对应当前数据库版本c daoPackage &apos;com.koma.greendao.gen&apos; //由GreenDao自动生成代码所在的包名，默认的是在项目包下面新建一个gen。 targetGenDir &apos;src/main/java&apos; //设置自动生成代码的目录&#125; 使用greenDAO使用流程在项目中新建一个表字段的实体类，不需要自己写get和set方法，在生成表的时候会自动生成。不要忘了在类名上标记@Entity注解如图： 选择build ——Make Project 一切顺利的话则会在包名下生成数据库的操作类，如下图： Ps:新建一个实体类，对项目进行Make Project，成功之后会在daoPackage目录下自动生成代码 在项目中定义实体类12345678@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; @Property(nameInDb = "USERNAME") private String name; private int age;&#125; 注解： @Entity——————————标识实体类，greenDAO会映射成sqlite的一个表，表名为实体类名的大写形式 schema：告知GreenDao当前实体属于哪个schema active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法 nameInDb：在数据库中使用的别名，默认使用的是实体的类名 indexes：定义索引，可以跨越多个列 createInDb：标记创建数据库表 基础属性注解 @Id——————————标识主键，该字段的类型为long或Long类型，autoincrement设置是否自动增长 @Property——————————标识该属性在表中对应的列名称, nameInDb设置名称 @Transient——————————标识该属性将不会映射到表中，也就是没有这列 @NotNull——————————设置表中当前列的值不可为空 索引注解 @Unique——————————向数据库列添加了一个唯一的约束 @Index——————————使用@Index作为一个属性来创建一个索引；定义多列索引(@link Entity#indexes()) 关系注解 @ToMany——————————定义与多个实体对象的关系 @ToOne——————————定义与另一个实体（一个实体对象）的关系 @Convert——————————指定自定义类型(@linkPropertyConverter) @Generated——————————greenDAO运行所产生的构造函数或者方法，被此标注的代码可以变更或者下次运行时清除 @JoinEntity——————————定义表连接关系 @JoinProperty——————————定义名称和引用名称属性关系 @Keep——————————注解的代码段在GreenDao下次运行时保持不变 注解实体类：默认禁止修改此类 注解其他代码段，默认禁止修改注解的代码段 @OrderBy——————————指定排序 初始化GreenDao一般建议在Application中初始化数据库12345678910private void setupDataBase(Context context)&#123; DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(context,DATA_BASE_NAME); Database db = openHelper.getWritableDb(); DaoMaster daoMaster = new DaoMaster(db); mDaoSession = daoMaster.new Session();&#125;public static DaoSession getDaoSession()&#123; return mDaoSession;&#125; DevOpenHelper有两个重载方法： DevOpenHelper(Context context,String name) DevOpenHelper(Context context,String name,CursorFactory factory)context上下文这个不用多说，name数据库的名字，cursorFactory游标工厂，一般不用，传入null或者使用两个参数的方法即可。我们对外提供一个getDaoSession()的方法供外部使用。 对数据库的增、删、改、查操作首先获得UserDao的对象UserDao userDao = GreenDaoManager.getInstance().getNewSession().getUserDao(); 增：12345User user = new User(null, name, age, studentId);userDao.insert(user);insert(T entity) 当指定主键在表中存在时会发生异常insertOrReplace(T entity) 当指定主键在表中存在时会覆盖数据insertInTx(Iterable&lt;T&gt; entities) 批量插入数据 删：12345678User user = new User(null, name, age, studentId); userDao.delete(user) delete(T entity) 删除数据deleteByKey(K key) 指定主键删除数据deleteInTx(Iterable&lt;T&gt; entities) 批量删除数据deleteByKeyInTx(Iterable&lt;K&gt; keys) 批量按数据删除数据 deleteAll() 删除所有数据 改：12345User user = new User(id, name, age, studentId);userDao.update(user); update(T entity) 修改数据，主键需相同updateInTx(Iterable&lt;T&gt; entities) 批量更新数据 查：12345userDao.load(id) load(K key) 根据id查找数据loadByRowId(long rowId) 根据行号查找数据loadAll() 查找全部数据 查询功能GreeDAO提供了各种各种的查询API，参见http://greenrobot.org/greendao/documentation/queries/ 如果需要在控制台查看GreenDao是怎么拼装SQL语句的，在OnCreate()方法中打开下面的开关： 条件查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//查询所有数据 public void queryAll() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().list(); &#125; //eq: equal 精确查询 名字等于jackie public void queryEq() &#123; Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.eq("jackie")).unique(); &#125; //notEq: not equal 精确查询 名字不等于jackie public void queryNotEq() &#123; Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.notEq("jackie")).unique(); &#125; //like 模糊查询 名字以jackie开头 public void queryLike() &#123; Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like("jackie")).unique(); //通配符 List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like("jackie%")).list(); &#125; //between 区间查询 年龄在20到30之间 public void queryBetween() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.between(20, 30)).list(); &#125; //gt: greater than 半开区间查询，年龄大于18 public void queryGt() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.gt(18)).list(); &#125; //ge: greater equal 半封闭区间查询，年龄大于或者等于18 public void queryGe() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.ge(18)).list(); &#125; //lt: less than 半开区间查询，年龄小于18 public void queryLt() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.lt(18)).list(); &#125; //le: less equal 半封闭区间查询，年龄小于或者等于18 public void queryLe() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.le(18)).list(); &#125; //名字以jackie开头，年龄升序排序 public void queryLikeAsc() &#123; //通配符 List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like("jackie%")).orderAsc(PersonDao.Properties.Age).list(); &#125; //名字以jackie开头，年龄降序排序 public void queryLikeDesc() &#123; List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like("jackie%")).orderDesc(PersonDao.Properties.Age).list(); &#125; 当上述查询满足不了业务逻辑时，可以自定义查询语句： 多线程查询首先来看错误的方法： 错误截图： 从上面可以看出，只能在创建Query对象的线程中调用查询方法！解决方法： 一对一查询 一对一、一对多关系greenDAO目前只支持一对一和一对多关系，并不支持多对多关系 一对一：123private Long studentId;@ToOne(joinProperty = "studentId")private Studentstudent; 1234567891011121314151617@Generated(hash = 313494093)public Student getStudent() &#123; Long __key = this.studentId; if (student__resolvedKey == null || !student__resolvedKey.equals(__key)) &#123; final DaoSession daoSession = this.daoSession; if (daoSession == null) &#123; throw new DaoException("Entity is detached from DAO context"); &#125; StudentDao targetDao = daoSession.getStudentDao(); Student studentNew = targetDao.load(__key); synchronized (this) &#123; student = studentNew; student__resolvedKey = __key; &#125; &#125; return student;&#125; 使用@ToOne标记，joinProperty指定一个字段，如果没有定义，会自动生成一个字段，get方法时自动生成的，使用@Generated标记，代表自动生成的，无需动代码。 一对多（有三种映射形式）12@ToMany(referencedJoinProperty = "teacherId")private List&lt;Teacher&gt; teacherList; referencedJoinProperty：指定目标实体中与源实体相对应的外键。 1234@ToMany(joinProperties = &#123; @JoinProperty(name="studentTag",referencedName = "teacherTag")&#125;)private List&lt;Teacher&gt; teacherList; JoinProperty: 对于复杂一点的关系可以定义一组@JoinProperty注解。每个@JoinProperty注解都需要有源实体中的源属性和对应实体中的引用属性。1234567@ToMany@JoinEntity( entity = Teacher.class, sourceProperty = "teacherId", targetProperty = "id")private List&lt;Teacher&gt; teacherList; @JoinEntity：在做NM多对多映射的时候使用 数据库的升级数据库升级最麻烦的就是数据保存的问题，下面是数据库升级时执行的代码。 1234567891011121314151617/** WARNING: Drops all table on Upgrade! Use only during development. */public static class DevOpenHelper extends OpenHelper &#123; public DevOpenHelper(Context context, String name) &#123; super(context, name); &#125; public DevOpenHelper(Context context, String name, CursorFactory factory) &#123; super(context, name, factory); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; Log.i("greenDAO", "Upgrading schema from version " + oldVersion + " to " + newVersion + " by dropping all tables"); dropAllTables(db, true); onCreate(db); &#125;&#125; 第一句注释的话已经告诉我们数据库升级时会删除所有的表，重新创建。所以我们可以自定义一个类继承OpenHelper，在升级时先生成临时表，删除旧表创建新表后，再把临时表的数据导入进去。有牛人已经做出这个项目来了，我就厚颜无耻选择直接用了。 在project的gradle添加123456allprojects &#123; repositories &#123; jcenter() maven &#123; url "https://jitpack.io" &#125; &#125;&#125; 在app的gradle添加：compile &#39;com.github.yuweiguocn:GreenDaoUpgradeHelper:v1.3.0&#39; 新建一个类12345678910111213public class MySQLiteOpenHelper extends DaoMaster.OpenHelper&#123; public MySQLiteOpenHelper(Contextcontext,Stringname)&#123; super(context,name); &#125; public MySQLiteOpenHelper(Contextcontext,String name,SQLiteDatabase.CursorFactoryfactory) &#123; super(context,name,factory); &#125; @Override public void onUpgrade(SQLiteDatabasedb,int oldVersion,intnewVersion) &#123; Log.d("SQLite","数据库从"+oldVersion+"升级到"+newVersion); MigrationHelper.migrate(db,UserDao.class,StudentDao.class); &#125;&#125; 使用时直接用MySQLiteOpenHelper代替DaoMaster.OpenHelper。 实战下面就以购物车的实战来使用GreenDao，这里的购物车展示图如下我们所知道的数据库操作需要：数据库名、表名、字段名，缺一不可，下面就是这三项的创建 一、创建Bean对象（表名和字段名）GreenDao需要创建Bean对象之后，该Bean对象就是表名，而它的属性值就是字段名，其 实现是通过注释的方式来实现的，下面是购物车的Bean对象（每个Bean对象对应一张表）1234567891011121314151617181920212223242526@Entitypublic class Shop&#123; //表示为购物车列表 public static final int TYPE_CART = 0x01; //表示为收藏列表 public static final int TYPE_LOVE = 0x02; //不能用int @Id(autoincrement = true) private Long id; //商品名称 @Unique private String name; //商品价格 @Property(nameInDb = "price") private String price; //已售数量 private int sell_num; //图标url private String image_url; //商家地址 private String address; //商品列表类型 private int type;&#125; 之后进行Make Project生成Bean实体的构造方法和get、set方法和DaoMaster、DaoSession、DAOS类 二、创建数据库1234567891011121314151617181920212223242526272829public class BaseApplication extends Application &#123; private static DaoSession daoSession; @Override public void onCreate() &#123; super.onCreate(); //配置数据库 setupDatabase(); &#125; /** * 配置数据库 */ private void setupDatabase() &#123; //创建数据库shop.db" DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, "shop.db", null); //获取可写数据库 SQLiteDatabase db = helper.getWritableDatabase(); //获取数据库对象 DaoMaster daoMaster = new DaoMaster(db); //获取Dao对象管理者 daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoInstant() &#123; return daoSession; &#125;&#125; GreenDao已经将我们的数据库创建缩成几句话，代码会自动将Bean对象创建成表，不再是传统的手写SQL语句。这里的数据库创建只需要在Application中执行一次即可，这里对几个类进行解释 DevOpenHelper：创建SQLite数据库的SQLiteOpenHelper的具体实现 DaoMaster：GreenDao的顶级对象，作为数据库对象、用于创建表和删除表 DaoSession：管理所有的Dao对象，Dao对象中存在着增删改查等API 由于我们已经创建好了DaoSession和Shop的Bean对象，编译后会自动生成我们的ShopDao对象，可通过DaoSession获得ShopDao dao = daoSession.getShopDao();这里的Dao（Data Access Object）是指数据访问接口，即提供了数据库操作一些API接口，可通过dao进行增删改查操作。 三、数据库的增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445public class LoveDao &#123; /** * 添加数据，如果有重复则覆盖 * * @param shop */ public static void insertLove(Shop shop) &#123; BaseApplication.getDaoInstant().getShopDao().insertOrReplace(shop); &#125; /** * 删除数据 * * @param id */ public static void deleteLove(long id) &#123; BaseApplication.getDaoInstant().getShopDao().deleteByKey(id); &#125; /** * 更新数据 * * @param shop */ public static void updateLove(Shop shop) &#123; BaseApplication.getDaoInstant().getShopDao().update(shop); &#125; /** * 查询条件为Type=TYPE_LOVE的数据 * * @return */ public static List&lt;Shop&gt; queryLove() &#123; return BaseApplication.getDaoInstant().getShopDao().queryBuilder().where(ShopDao.Properties.Type.eq(Shop.TYPE_LOVE)).list(); &#125; /** * 查询全部数据 */ public static List&lt;Shop&gt; queryAll() &#123; return BaseApplication.getDaoInstant().getShopDao().loadAll(); &#125;&#125; GreenDao的封装更加短小精悍，语义明朗，下面对GreenDao中Dao对象其他API的介绍 增加单个数据 getShopDao().insert(shop); getShopDao().insertOrReplace(shop); 增加多个数据 getShopDao().insertInTx(shopList); getShopDao().insertOrReplaceInTx(shopList); 查询全部 List&lt; Shop&gt; list = getShopDao().loadAll(); List&lt; Shop&gt; list = getShopDao().queryBuilder().list(); 查询附加单个条件 .where() .whereOr() 查询附加多个条件 .where(, , ,) .whereOr(, , ,) 查询附加排序 .orderDesc() .orderAsc() 查询限制当页个数 .limit() 查询总个数 .count() 修改单个数据 getShopDao().update(shop); 修改多个数据 getShopDao().updateInTx(shopList); 删除单个数据 getTABUserDao().delete(user); 删除多个数据 getUserDao().deleteInTx(userList); 删除数据ByKey getTABUserDao().deleteByKey();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python学习笔记]]></title>
      <url>%2F2017%2F03%2F27%2Fpython-study-note%2F</url>
      <content type="text"><![CDATA[前言由于写毕设要搭建后端爬虫的需求，所以开始学习Python语言。由于没有系统的学习，所以笔记可能会记得比较散乱，有时间会一一整理，把一些重要的学习知识点记下来。当然有时间也会整理基础知识。 安装 Python升级pippip3 install --upgrade pip 安装 Python 虚拟环境(sudo) pip3 install virtualenv virtualenvwrapper 修改~/.bash_profile,添加以下语句123export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/workspacesource /usr/local/bin/virtualenvwrapper.sh 修改后使之立即生效(也可以重启终端使之生效)：source ~/.bash_profile 基本用法1、创建一个虚拟开发环境mkvirtualenv zqxt：创建运行环境zqxtworkon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境deactivate: 退出终端环境其它的：rmvirtualenv ENV：删除运行环境ENVmkproject mic：创建mic项目和运行环境micmktmpenv：创建临时运行环境lsvirtualenv: 列出可用的运行环境lssitepackages: 列出当前环境安装了的包创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。 完成后在当前目录会创建一个test_env的文件夹，进入文件夹会发现生成了以下的目录，神奇吧12345678910111213├── bin├── include│ └── python2.7├── lib│ └── python2.7 //所有的新包会被存在这│ ├── distutils│ ├── encodings│ ├── lib-dynload│ └── site-packages├── local│ ├── bin│ ├── include│ └── lib 安装Djangopip3 install Django或者pip install Django==1.10.6在终端上输入Python,点击Enter,进入Python环境123456&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION(1, 8, 16, &apos;final&apos;, 0)&gt;&gt;&gt; &gt;&gt;&gt; django.get_version()&apos;1.8.16&apos; 这样就可以看见安装的django的版本号 安装django-Celery，设置调度计划任务pip3 install django-celery 安装PIL（Python Imaging Library）图片处理的扩展包:brew install jpeg #安装 安装Django-Dynamic-Scraper(DDS)pip3 install django-dynamic-scraperpip3 install scrapy-splashpip3 install scrapy-djangoitem 安装scrapypip3 install Scrapy 安装Scrapy或者pip3 install scrapy==1.3.3 安装chardet-检测网页编码pip3 install chardet #安装chardet1234567def GetHtml( url): page = urllib.request.urlopen(url) contex = page.read() return contex print(sys.getfilesystemencoding()) #本地系统编码print('Html is encoding by : %',chardet.detect(GetHtml(url))) #网页编码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac命令行整理]]></title>
      <url>%2F2017%2F03%2F25%2Fmac-command%2F</url>
      <content type="text"><![CDATA[前言命令行是操作Mac和Linux最基础和重要的内容，简单的命令行自然会随时记得。但是碰到配置环境以及安装软件这种活，还是得时不时的上网查询，而且在不同的电脑配置还得重新上网查询，所以在此记录一下，以节省以后使用命令行的时间。 查看端口占用情况及杀死进程sudo lsof -i :9000 #查看端口进程sudo kill -9 716 #根据PID杀死进程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apache简单搭建文件共享服务器]]></title>
      <url>%2F2017%2F03%2F17%2Fapache-build-file-server%2F</url>
      <content type="text"><![CDATA[前言因为公司需求，增加打包测试发布的效率以及方便查看log信息。所以需要搭建一个简单的文件服务器。Mac内置Apache，所以我们可以很方便的搭建起来。 启动Apache启动：sudo apachectl start停止：sudo apachectl stop重启：sudo apachectl restart查看 Apache 版本 httpd -v浏览器打开 http://127.0.0.1 可以看到 It works! 的页面 文件根目录系统级的根目录http://localhosts/ 对应的是 /Library/WebServer/Documents/ 系统级根目录默认没有开启目录列表，开启方法：编辑 /etc/apache2/httpd.conf文件搜索找到 &lt;Directory &quot;/Library/WebServer/Documents&quot;&gt;将 Options FollowSymLinks Multiviews 修改为Options Indexes FollowSymLinks Multiviews 用户级根目录另一个 Web 根目录默认是 ~/Sites ，10.9 中你需要手动创建这个Sites目录。检查/etc/apache2/users/这个目录下是否有 username.conf 文件如果没有，则需要新建一个，username 需要是你的账户名字，建议使用终端创建这个文件：cd /etc/apache2/userssudo vi username.conf贴入以下内容，注意修改 username 为你的账户名字1234567&lt;Directory &quot;/Users/username/Sites/&quot;&gt;Options Indexes MultiViews FollowSymLinksAllowOverride AllOrder allow,denyAllow from allRequire all granted&lt;/Directory&gt; 这个文件的权限应该是: -rw-r--r-- 1 root wheel 298 Jun 28 16:47 username.conf 如果不是，请修改: sudo chmod 644 username.conf 编辑 /etc/apache2/httpd.conf 文件，删除下列这些代码前的注释符号： #1234Include /private/etc/apache2/extra/httpd-userdir.confLoadModule authz_core_module libexec/apache2/mod_authz_core.soLoadModule authz_host_module libexec/apache2/mod_authz_host.soLoadModule userdir_module libexec/apache2/mod_userdir.so 编辑 /etc/apache2/extra/httpd-userdir.conf文件，删除下列这些代码前的注释符号： #Include /private/etc/apache2/users/*.conf 重启 Apachesudo apachectl restart这时，这个网址应该已经可以用了：http://localhost/~username/ 想去除/~username/~username看着的确比较累赘，所以我们重定向把他给去掉进入/Library/WebServer/Documents文件夹中，找到index.html.en文件，在里面添加一行&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;0; URL=/~rainbird&quot;&gt;。最后变成这个样子。12&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;0; URL=/~rainbird&quot;&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python-Crawler]]></title>
      <url>%2F2017%2F03%2F15%2Fpython-crawler%2F</url>
      <content type="text"><![CDATA[总文件1234567891011121314151617181920212223242526import scrapyfrom scrapy.selector import Selectorfrom scrapy.http import HtmlResponseclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://www.xujc.com.cn/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self,response): sel = Selector(response) sties = sel.xpath('//table') # for site in sties: # title = site.xpath('tr/td').extract() # print(site) # print(title) #filename = 'school-%s.html' % 1 #with open(filename, 'wb') as f: #f.write(contents) #self.log('Saved file %s' % filename) 重点关注链接and标题123456789101112131415161718192021import scrapyfrom scrapy.selector import Selectorfrom scrapy.http import HtmlResponseclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://www.xujc.com.cn/', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self,response): sel = Selector(response) sties = sel.xpath('//table') title = sties[16].xpath('tr/td/a/text() | tr/td/a/@href | tr/td/text()').extract() print(sties[10]) print(title) 日期时间123title = sties[25].xpath('tr/td/table/tr/td[@id="zb"]/table/tr/td/span/text()').extract() print(sties[10]) print(title) 通知公告123456789101112131415161718192021import scrapyfrom scrapy.selector import Selectorfrom scrapy.http import HtmlResponseclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://www.xujc.com.cn/index.php?c=Article&amp;a=idxnews&amp;lx=notice', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self,response): sel = Selector(response) sties = sel.xpath('/html/body/table/tr') for site in sties: title = site.xpath('td/a/@href | td/a/text()').extract() print(site) print(title) 新闻中心123456789101112131415161718192021import scrapyfrom scrapy.selector import Selectorfrom scrapy.http import HtmlResponseclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): urls = [ 'http://www.xujc.com.cn/index.php?c=Article&amp;a=idxnews&amp;lx=news', ] for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self,response): sel = Selector(response) sties = sel.xpath('/html/body/ul/li') for site in sties: title = site.xpath('a/@href | a/text()').extract() print(site) print(title)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android ADB 命令]]></title>
      <url>%2F2017%2F03%2F05%2Fandroid-adb%2F</url>
      <content type="text"><![CDATA[查看设备adb devices 这个命令是查看当前连接的设备, 连接到计算机的android设备或者模拟器将会列出显示 安装软件adb install &lt;apk文件路径&gt; 这个命令将指定的apk文件安装到设备上 卸载软件adb uninstall &lt;软件名&gt; adb uninstall -k &lt;软件名&gt; 如果加 -k 参数,为卸载软件但是保留配置和缓存文件. 进入设备或模拟器的shelladb shell 通过上面的命令，就可以进入设备或模拟器的shell环境中，在这个Linux Shell中，你可以执行各种Linux的命令，另外如果只想执行一条shell命令，可以采用以下的方式： adb shell [command] 如：adb shell dmesg会打印出内核的调试信息。 发布端口adb forward tcp:5555 tcp:8000 可以设置任意的端口号，做为主机向模拟器或设备的请求端口。如： 从电脑上发送文件到设备adb push &lt;本地路径&gt; &lt;远程路径&gt; 用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机) 从设备上下载文件到电脑adb pull &lt;远程路径&gt; &lt;本地路径&gt; 用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑 查看bug报告adb bugreport 记录无线通讯日志adb shell logcat -b radio 一般来说，无线通讯的日志非常多，在运行时没必要去记录，但我们还是可以通过命令，设置记录 获取设备的ID和序列号adb get-product adb get-serialno adb shell sqlite3 adb shell后面跟的命令主要来自源码\system\core\toolbox目录和源码\frameworks\base\cmds目录 删除系统应用adb remount （重新挂载系统分区，使系统分区重新可写）。 adb shell cd system/app rm *.apk 获取管理员权限adb root 启动Activityadb shell am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）。 复制文件你可向一个设备或从一个设备中复制文件,复制一个文件或目录到设备或模拟器上： adb push &lt;source&gt; &lt;destination&gt;&lt;/destination&gt;&lt;/source&gt; 如：adb push test.txt /tmp/test.txt 从设备或模拟器上复制一个文件或目录： adb pull &lt;source&gt; &lt;destination&gt;&lt;/destination&gt;&lt;/source&gt; 如：adb pull /addroid/lib/libwebcore.so . 搜索模拟器/设备的实例取得当前运行的模拟器/设备的实例的列表及每个实例的状态： adb devices]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac安装配置appium]]></title>
      <url>%2F2017%2F03%2F01%2Fappium-setup-and-usage%2F</url>
      <content type="text"><![CDATA[#前言因为公司需求，需要安装Appium来实现对手机APP的自动化测试，提升工作效率。所以来学习并记录一下Appium的安装以及使用的步骤，方便自己以后对App测试环境搭建的操作。 安装Appium安装Homebrew $ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; #下载 $ brew update #更新 $ brew -v #查看是否安装好，以及其版本号 安装Node.js使用homebrew来安装Node.js $ brew install node #安装 $ node -v #查看是否安装好，以及其版本号 安装npm $ brew install npm 安装appium服务端推荐使用cnpm来安装：淘宝 NPM 镜像 10分钟同步npmjs.org镜像，使用方式和npm完全一致 $ npm install cnpm -g --registry=https://registry.npm.taobao.org $ npm view appium versions #查看appium所有的版本号 $ cnpm install -g appium --no-cache $ cnpm install -g appium $ cnpm install -g appium-doctor 检查appium环境检测在环境监测中打叉的就是没安装成功或者环境没有配置完全的 appium-doctor appium环境常见问题解决 Xcode Command Line Tools are NOT installed! xcode-select --install #按照提示安装即可 Carthage was NOT found $ brew install carthage #carthage：类似cocoapods管理第三方代码，自动将工程编译为动态库，所以仅支持iOS8以上 ANDROID_HOME is NOT set! 使用最新版本Java 修改Mac的开发环境 vi .bash_profile export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk(版本记得改)/Contents/Home export ANDROID_HOME=/Users/YourMacName/Library/Android/sdk export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:${JAVA_HOME}/bin 修改完配置文件记得保存退出，然后source .bash_profile 如果有问题记得修改在终端的Shall打开方式，调整为命令 安装appium客户端（Python为例） brew search python #查看可安装的python版本 brew install python3 #安装python3 pip install Appium-Python-Client #安装python客户端 安装支持iOS测试的插件 $ brew install libimobiledevice --HEAD # install from HEAD to get important updates $ brew install ideviceinstaller # 只是对iOS9有用 $ npm install -g ios-deploy # iOS10 以后的版本安装ios-deploy $ sudo gem install xcpretty # 真机需要安装 xcpretty Appium测试iOS模拟器测试 xcodebuild -sdk iphonesimulator #在xcodeproj项目工程目录下执行，编译生成build文件夹，并在其中生成app文件 npm install -g authorize-ios #安装iOS模拟器启动器 sudo authorize-ios #启动iOS模拟器 appium &amp; #启动appium服务器 python ***.py #另开一个终端执行python脚本 iOS模拟器自动开启，安装应用并开始执行测试脚本 Android模拟器测试 appium -a 127.0.0.1 -p 4723 -U db3489d --no-reset Appium命令服务端启动命令服务器标志所有的标志都是可选的，但是有一些标志需要组合在一起才能生效。 标志 默认值 描述 例子 –shell null 进入 REPL 模式 –localizable-strings-dir en.lproj IOS only: 定位 .strings所在目录的相对路径 –localizable-strings-dir en.lproj –app null iOS: 基于模拟器编译的 app 的绝对路径或者设备目标的 bundle_id； Android: apk 文件的绝对路径–app /abs/path/to/my.app –ipa null (IOS-only) .ipa 文件的绝对路径 –ipa /abs/path/to/my.ipa -U, –udid null 连接物理设备的唯一设备标识符 –udid 1adsf-sdfas-asdf-123sdf -a, –address 0.0.0.0 监听的 ip 地址 –address 0.0.0.0 -p, –port 4723 监听的端口 –port 4723 -ca, –callback-address null 回调IP地址 (默认: 相同的IP地址) –callback-address 127.0.0.1 -cp, –callback-port null 回调端口号 (默认: 相同的端口号) –callback-port 4723 -bp, –bootstrap-port 4724 (Android-only) 连接设备的端口号 –bootstrap-port 4724 -k, –keep-artifacts false 弃用，无效。trace信息现在保留tmp目录下，每次运行前会清除该目录中的信息。 也可以参考 –trace-dir 。 -r, –backend-retries 3 (iOS-only) 遇到 crash 或者 超时，Instrument 重新启动的次数。 –backend-retries 3 –session-override false 允许 session 被覆盖 (冲突的话) –full-reset false (iOS) 删除整个模拟器目录。 (Android) 通过卸载应用（而不是清除数据）重置应用状态。在 Android 上，session 完成后也会删除应用。 –no-reset false session 之间不重置应用状态 (iOS: 不删除应用的 plist 文件； Android: 在创建一个新的 session 前不删除应用。) -l, –pre-launch false 在第一个 session 前，预启动应用 (iOS 需要 –app 参数，Android 需要 –app-pkg 和 –app-activity) -lt, –launch-timeout 90000 (iOS-only) 等待 Instruments 启动的时间 -g, –log null 将日志输出到指定文件 –log /path/to/appium.log –log-level debug 日志级别; 默认 (console[:file]): debug[:debug] –log-level debug –log-timestamp false 在终端输出里显示时间戳 –local-timezone false 使用本地时间戳 –log-no-colors false 不在终端输出中显示颜色 -G, –webhook null 同时发送日志到 HTTP 监听器 –webhook localhost:9876 –native-instruments-lib false (IOS-only) iOS 内建了一个怪异的不可能避免的延迟。我们在 Appium 里修复了它。如果你想用原来的，你可以使用这个参数。 –app-pkg null (Android-only) 你要运行的apk的java包。 (例如， com.example.android.myApp) –app-pkg com.example.android.myApp –app-activity null (Android-only) 打开应用时，启动的 Activity 的名字(比如， MainActivity) –app-activity MainActivity –app-wait-package false (Android-only) 你想等待的 Activity 的包名。(比如， com.example.android.myApp) –app-wait-package com.example.android.myApp –app-wait-activity false (Android-only) 你想等待的 Activity 名字(比如， SplashActivity) –app-wait-activity SplashActivity –android-coverage false (Android-only) 完全符合条件的 instrumentation 类。 作为命令 adb shell am instrument -e coverage true -w 的 -w 的参数 –android-coverage com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation –avd null (Android-only) 要启动的 avd 的名字 –avd-args null (Android-only) 添加额外的参数给要启动avd –avd-args -no-snapshot-load –device-ready-timeout 5 (Android-only) 等待设备准备好的时间，以秒为单位 –device-ready-timeout 5 –safari false (IOS-Only) 使用 Safari 应用 –device-name null 待使用的移动设备名字 –device-name iPhone Retina (4-inch), Android Emulator –platform-name null 移动平台的名称: iOS, Android, or FirefoxOS –platform-name iOS –platform-version null 移动平台的版本 –platform-version 7.1 –automation-name null 自动化工具的名称: Appium or Selendroid –automation-name Appium –browser-name null 移动浏览器的名称: Safari or Chrome –browser-name Safari –default-device, -dd false (IOS-Simulator-only) 使用instruments自己启动的默认模拟器 –force-iphone false (IOS-only) 无论应用要用什么模拟器，强制使用 iPhone 模拟器 –force-ipad false (IOS-only) 无论应用要用什么模拟器，强制使用 iPad 模拟器 –language null iOS / Android 模拟器的语言 –language en –locale null Locale for the iOS simulator / Android Emulator –locale en_US –calendar-format null (IOS-only) iOS 模拟器的日历格式 –calendar-format gregorian –orientation null (IOS-only) 初始化请求时，使用 LANDSCAPE (横屏) 或者 PORTRAIT (竖屏) –orientation LANDSCAPE –tracetemplate null (IOS-only) 指定 Instruments 使用的 tracetemplate 文件 –tracetemplate /Users/me/Automation.tracetemplate –show-sim-log false (IOS-only) 如果设置了， iOS 模拟器的日志会写到终端上来 –show-ios-log false (IOS-only) 如果设置了， iOS 系统的日志会写到终端上来 –nodeconfig null 指定 JSON 格式的配置文件 ，用来在 selenium grid 里注册 appiumd –nodeconfig /abs/path/to/nodeconfig.json -ra, –robot-address 0.0.0.0 robot 的 ip 地址 –robot-address 0.0.0.0 -rp, –robot-port -1 robot 的端口地址 –robot-port 4242 –selendroid-port 8080 用来和 Selendroid 交互的本地端口 –selendroid-port 8080 –chromedriver-port 9515 ChromeDriver运行的端口 –chromedriver-port 9515 –chromedriver-executable null ChromeDriver 可执行文件的完整路径 –use-keystore false (Android-only) 设置签名 apk 的 keystore –keystore-path (Android-only) keystore 的路径 –keystore-password android (Android-only) keystore 的密码 –key-alias androiddebugkey (Android-only) Key 的别名 –key-password android (Android-only) Key 的密码 –show-config false 打印 Appium 服务器的配置信息，然后退出 –no-perms-check false 跳过Appium对是否可以读/写必要文件的检查 –command-timeout 60 默认所有会话的接收命令超时时间 (在超时时间内没有接收到新命令，自动关闭会话)。 会被新的超时时间覆盖 –keep-keychains false (iOS) 当 Appium 启动或者关闭的时候，是否保留 keychains (Library/Keychains) –strict-caps false 如果所选设备是appium不承认的有效设备，会导致会话失败 –isolate-sim-device false Xcode 6存在一个bug，那就是一些平台上如果其他模拟器设备先被删除时某个特定的模拟器只能在没有任何错误的情况下被建立。这个选项导致了Appium不得不删除除了正在使用设备以外其他所有的设备。请注意这是永久性删除，你可以使用simctl或xcode管理被Appium使用的设备类别。 –tmp null 可以被Appium用来管理临时文件的目录（绝对路径），比如存放需要移动的内置iOS应用程序。 默认的变量为 APPIUM_TMP_DIR ，在 *nix/Mac 为 /tmp 在windows上使用环境便令 TEMP 设定的目录。 –trace-dir null 用于保存iOS instruments trace的 appium 目录，是绝对路径， 默认为 /appium-instruments –intent-action android.intent.action.MAIN (Android-only) 用于启动 activity 的intent action –intent-action android.intent.action.MAIN –intent-category android.intent.category.LAUNCHER (Android-only) 用于启动 activity 的intent category –intent-category android.intent.category.APP_CONTACTS –intent-flags 0x10200000 (Android-only) 启动 activity 的标志 –intent-flags 0x10200000 –intent-args null (Android-only) 启动 activity 时附带额外的 intent 参数 –intent-args 0x10200000 –suppress-adb-kill-server false (Android-only) 如果被设定，阻止Appium杀掉adb实例。 Android测试用例编写例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445import osimport unittestfrom appium import webdriverfrom time import sleepPATH = lambda p: os.path.abspath( os.path.join(os.path.dirname(__file__),p))class XingQiuAndroidTests(unittest.TestCase): def setUp(self): desired_caps = &#123;&#125; desired_caps['deviceName'] = 'emulator-5554' #adb devices查到的设备名 desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '4.4' desired_caps['app'] = PATH( '../../../Users/jiangruoming/Desktop/***.apk' ) desired_caps['appPackage'] = 'com.***.***' #被测App的包名 desired_caps['appActivity'] = '.****' #启动时的Activity self.driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) #earDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出 def tearDown(self): self.driver.quit() #放置的就是我们的测试脚本了，这部分我们并不陌生；因为我们执行的脚本就在这里。 def test_add_contacts(self): el = self.driver.find_element_by_id("com.***.***:id/sign_phone") el.click() phone_number = self.driver.find_element_by_id("com.***.***:id/et_user_phone") code = self.driver.find_element_by_id("com.***.***:id/et_smscode") phone_number.send_keys("*********") code.send_keys("****") btn = self.driver.find_element_by_id("com.***.***:id/btn_finish") btn.click()if __name__ == '__main__': suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuAndroidTests) unittest.TextTestRunner(verbosity=2).run(suite) 测试流程1、启动Appiumappium -a 127.0.0.1 -p 4723 --log /path/to/appium.log 2、启动Android模拟器由于测试apk不支持X86平台，所以Genymotion无法支持运行，原生arm模拟器运行过慢(胃都等疼了)。试过多个模拟器后，最终选定了夜神模拟器，效果还是不错的。但是由于其主要用于PC平台运行Android游戏，所以用于开发平台还是需要进行配置。 1、adb配置在Mac环境中加入adb的环境变量vi .bash_profileexport PATH=/Users/Path/To/Android/sdk/platform-tools/:$PATHsource .bash_profile 2、adb连接之后进入夜神的包内容中在adb所在文件夹运行adb连接命令adb connect 127.0.0.1:62001这样adb devices就能显示夜神模拟器的Device ID 3、运行脚本iOS测试用例编写例子:12345678910111213141516171819202122232425262728293031323334353637383940414243444546import unittestimport osfrom appium import webdriverfrom time import sleepPATH = lambda p: os.path.abspath( os.path.join(os.path.dirname(__file__),p))class XingQiuiOSTests(unittest.TestCase): def setUp(self): desired_caps = &#123;&#125; desired_caps['platformName'] = 'iOS' desired_caps['platformVersion'] = '10.2' desired_caps['deviceName'] = 'iPhone Simulator' desired_caps['app'] = PATH('../../../Users/jiangruoming/Desktop/***.app') self.driver = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) #def tearDown(self): #self.driver.quit() def test_add_contacts(self): el2 = self.driver.find_elements_by_accessibility_id('Allow') if el2: el2[0].click() el3 = self.driver.find_elements_by_class_name('XCUIElementTypeButton')[0] el3.click() el4 = self.driver.find_elements_by_class_name('XCUIElementTypeTextField')[0] el4.send_keys("15088678313") el5 = self.driver.find_elements_by_class_name('XCUIElementTypeTextField')[1] el5.send_keys("1234") el6 = self.driver.find_elements_by_class_name('XCUIElementTypeButton')[0] el6.click()if __name__ == '__main__': suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuiOSTests) unittest.TextTestRunner(verbosity=2).run(suite) XCUIElementType12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879XCUIElementTypeAny, XCUIElementTypeUnknown, XCUIElementTypeApplication, XCUIElementTypeGroup, XCUIElementTypeWindow, XCUIElementTypeSheet, XCUIElementTypeDrawer, XCUIElementTypeAlert, XCUIElementTypeDialog, XCUIElementTypeButton, XCUIElementTypeRadioButton, XCUIElementTypeRadioGroup, XCUIElementTypeCheckBox, XCUIElementTypeDisclosureTriangle, XCUIElementTypePopUpButton, XCUIElementTypeComboBox, XCUIElementTypeMenuButton, XCUIElementTypeToolbarButton, XCUIElementTypePopover, XCUIElementTypeKeyboard, XCUIElementTypeKey, XCUIElementTypeNavigationBar, XCUIElementTypeTabBar, XCUIElementTypeTabGroup, XCUIElementTypeToolbar, XCUIElementTypeStatusBar, XCUIElementTypeTable, XCUIElementTypeTableRow, XCUIElementTypeTableColumn, XCUIElementTypeOutline, XCUIElementTypeOutlineRow, XCUIElementTypeBrowser, XCUIElementTypeCollectionView, XCUIElementTypeSlider, XCUIElementTypePageIndicator, XCUIElementTypeProgressIndicator, XCUIElementTypeActivityIndicator, XCUIElementTypeSegmentedControl, XCUIElementTypePicker, XCUIElementTypePickerWheel, XCUIElementTypeSwitch, XCUIElementTypeToggle, XCUIElementTypeLink, XCUIElementTypeImage, XCUIElementTypeIcon, XCUIElementTypeSearchField, XCUIElementTypeScrollView, XCUIElementTypeScrollBar, XCUIElementTypeStaticText, XCUIElementTypeTextField, XCUIElementTypeDateField, XCUIElementTypeTimeField, XCUIElementTypeTextView, XCUIElementTypeMenu, XCUIElementTypeMenuItem, XCUIElementTypeMenuBar, XCUIElementTypeMenuBarItem, XCUIElementTypeMap, XCUIElementTypeWebView, XCUIElementTypeIncrementArrow, XCUIElementTypeDecrementArrow, XCUIElementTypeTimeline, XCUIElementTypeRatingIndicator, XCUIElementTypeValueIndicator, XCUIElementTypeSplitGroup, XCUIElementTypeSplitter, XCUIElementTypeRelevanceIndicator, XCUIElementTypeColorWell, XCUIElementTypeHelpTag, XCUIElementTypeMatte, XCUIElementTypeDockItem, XCUIElementTypeRuler, XCUIElementTypeRulerMarker, XCUIElementTypeGrid, XCUIElementTypeLevelIndicator, XCUIElementTypeCell, XCUIElementTypeLayoutArea, XCUIElementTypeLayoutItem, XCUIElementTypeHandle, Appium Python API contextscontexts(self):Returns the contexts within the current session.返回当前会话中的上下文，使用后可以识别H5页面的控件Usage: driver.contexts用法: driver.contexts current_contextcurrent_context(self):Returns the current context of the current session.返回当前会话的当前上下文Usage: driver.current_context用法: driver. current_context contextcontext(self):Returns the current context of the current session.返回当前会话的当前上下文。Usage: driver.context用法: driver. Context find_element_by_ios_uiautomationfind_element_by_ios_uiautomation(self, uia_string):Finds an element by uiautomation in iOS.通过iOS uiautomation查找元素Args: uia_string - The element name in the iOS UIAutomation libraryUsage: driver.find_element_by_ios_uiautomation(&#39;.elements()[1].cells()[2]&#39;)用法: dr. find_element_by_ios_uiautomation(‘elements’) find_element_by_accessibility_idfind_element_by_accessibility_id(self, id):Finds an element by accessibility id.通过accessibility id查找元素Args: id - a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilizeUsage:driver.find_element_by_accessibility_id()用法:driver.find_element_by_accessibility_id(‘id’) scrollscroll(self, origin_el, destination_el):Scrolls from one element to another从元素origin_el滚动至元素destination_elArgs: originalEl - the element from which to being scrolling destinationEl - the element to scroll toUsage: driver.scroll(el1, el2)用法: driver.scroll(el1,el2) drag_and_dropdrag_and_drop(self, origin_el, destination_el):Drag the origin element to the destination element将元素origin_el拖到目标元素destination_elArgs: originEl - the element to drag destinationEl - the element to drag to用法: driver.drag_and_drop(el1,el2) taptap(self, positions, duration=None):Taps on an particular place with up to five fingers, holding for a certain time模拟手指点击（最多五个手指），可设置按住时间长度（毫秒）Args: positions - an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five. duration - (optional) length of time to tap, in msUsage: driver.tap([(100, 20), (100, 60), (100, 100)], 500)用法: driver.tap([(x,y),(x1,y1)],500) swipeswipe(self, start_x, start_y, end_x, end_y, duration=None):Swipe from one point to another point, for an optional duration.从A点滑动至B点，滑动时间为毫秒Args: start_x - x-coordinate at which to start start_y - y-coordinate at which to start end_x - x-coordinate at which to stop end_y - y-coordinate at which to stop duration - (optional) time to take the swipe, in ms. Usage: driver.swipe(100, 100, 100, 400)用法: driver.swipe(x1,y1,x2,y2,500) flickflick(self, start_x, start_y, end_x, end_y):Flick from one point to another point.按住A点后快速滑动至B点Args: start_x - x-coordinate at which to start start_y - y-coordinate at which to start end_x - x-coordinate at which to stop end_y - y-coordinate at which to stopUsage:driver.flick(100, 100, 100, 400)用法:driver.flick(x1,y1,x2,y2) pinchpinch(self, element=None, percent=200, steps=50):Pinch on an element a certain amount在元素上执行模拟双指捏（缩小操作）Args: element - the element to pinch percent - (optional) amount to pinch. Defaults to 200% steps - (optional) number of steps in the pinch action Usage: driver.pinch(element)用法: driver.pinch(element) zoomzoom(self, element=None, percent=200, steps=50):Zooms in on an element a certain amount在元素上执行放大操作Args: element - the element to zoom percent - (optional) amount to zoom. Defaults to 200% steps - (optional) number of steps in the zoom action Usage: driver.zoom(element)用法: driver.zoom(element) resetreset(self):Resets the current application on the device.重置应用(类似删除应用数据)用法:driver.reset() hide_keyboardhide_keyboard(self, key_name=None, key=None, strategy=None):Hides the software keyboard on the device. In iOS, use key_name to press a particular key, or strategy. In Android, no parameters are used.隐藏键盘,iOS使用key_name隐藏，安卓不使用参数Args: key_name - key to press strategy - strategy for closing the keyboard (e.g., tapOutside) driver.hide_keyboard() keyeventkeyevent(self, keycode, metastate=None):Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html.发送按键码（安卓仅有），按键码可以上网址中找到Args: keycode - the keycode to be sent to the device metastate - meta information about the keycode being sent 用法:dr.keyevent(‘4’) press_keycodepress_keycode(self, keycode, metastate=None):Sends a keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html.发送按键码（安卓仅有），按键码可以上网址中找到Args: keycode - the keycode to be sent to the device metastate - meta information about the keycode being sent 用法:driver.press_ keycode(‘4’) dr.keyevent(‘4’)与driver.press_ keycode(‘4’) 功能实现上一样的，都是按了返回键 long_press_keycodelong_press_keycode(self, keycode, metastate=None):Sends a long press of keycode to the device. Android only. Possible keycodes can be found in http://developer.android.com/reference/android/view/KeyEvent.html.发送一个长按的按键码（长按某键）Args: keycode - the keycode to be sent to the device metastate - meta information about the keycode being sent用法:driver.long_press_keycode(‘4’) current_activitycurrent_activity(self):Retrieves the current activity on the device.获取当前的activity用法:print(driver.current_activity()) wait_activitywait_activity(self, activity, timeout, interval=1):Wait for an activity: block until target activity presents or time out.This is an Android-only method.等待指定的activity出现直到超时，interval为扫描间隔1秒即每隔几秒获取一次当前的activity返回的True 或 FalseAgrs: activity - target activity timeout - max wait time, in seconds interval - sleep interval between retries, in seconds 用法: driver.wait_activity(‘.activity.xxx’,5,2) background_appbackground_app(self, seconds):Puts the application in the background on the device for a certain duration.后台运行app多少秒Args: seconds - the duration for the application to remain in the background用法:driver.background_app(5)置后台5秒后再运行 is_app_installedis_app_installed(self, bundle_id):Checks whether the application specified by bundle_id is installed on the device.检查app是否有安装返回 True or FalseArgs: bundle_id - the id of the application to query 用法:driver.is_app_installed(“com.xxxx”) install_appinstall_app(self, app_path):Install the application found at app_path on the device.安装app,app_path为安装包路径Args: app_path - the local or remote path to the application to install 用法:driver.install_app(app_path) remove_appremove_app(self, app_id):Remove the specified application from the device.删除appArgs: app_id - the application id to be removed 用法:driver.remove_app(“com.xxx.”) launch_applaunch_app(self):Start on the device the application specified in the desired capabilities.启动app用法:driver.launch_app() close_appclose_app(self):Stop the running application, specified in the desired capabilities, on the device.关闭app用法:driver.close_app()启动和关闭app运行好像会出错 start_activitystart_activity(self, app_package, app_activity, **opts):Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened.This is an Android-only method.在测试过程中打开任意活动。如果活动属于另一个应用程序，该应用程序的启动和活动被打开。这是一个安卓的方法Args: app_package - The package containing the activity to start. app_activity - The activity to start. app_wait_package - Begin automation after this package starts (optional). app_wait_activity - Begin automation after this activity starts (optional). intent_action - Intent to start (optional). intent_category - Intent category to start (optional). intent_flags - Flags to send to the intent (optional). optional_intent_arguments - Optional arguments to the intent (optional). stop_app_on_reset - Should the app be stopped on reset (optional)? 用法:driver.start_activity(app_package, app_activity) locklock(self, seconds):Lock the device for a certain period of time. iOS only.锁屏一段时间 iOS专有Args: the duration to lock the device, in seconds 用法:driver.lock() shakeshake(self):Shake the device.摇一摇手机用法:driver.shake() open_notificationsopen_notifications(self):Open notification shade in Android (API Level 18 and above)打系统通知栏（仅支持API 18 以上的安卓系统）用法:driver.open_notifications() network_connectionnetwork_connection(self):Returns an integer bitmask specifying the network connection type.Android only.返回网络类型 数值Possible values are available through the enumeration appium.webdriver.ConnectionType用法:driver.network_connection set_network_connectionset_network_connection(self, connectionType):Sets the network connection type. Android only.Possible values: Value (Alias) Data Wifi Airplane Mode 0 (None) 0 0 0 1 (Airplane Mode) 0 0 1 2 (Wifi only) 0 1 0 4 (Data only) 1 0 0 6 (All network on) 1 1 0 These are available through the enumeration appium.webdriver.ConnectionType` 设置网络类型Args: connectionType - a member of the enum appium.webdriver.ConnectionType 用法:先加载from appium.webdriver.connectiontype import ConnectionTypedr.set_network_connection(ConnectionType.WIFI_ONLY)ConnectionType的类型有NO_CONNECTION = 0AIRPLANE_MODE = 1WIFI_ONLY = 2DATA_ONLY = 4ALL_NETWORK_ON = 6 available_ime_enginesavailable_ime_engines(self):Get the available input methods for an Android device. Package and activity are returned (e.g., [‘com.android.inputmethod.latin/.LatinIME’])Android only.返回安卓设备可用的输入法用法:print(driver.available_ime_engines) is_ime_activeis_ime_active(self):Checks whether the device has IME service active. Returns True/False.Android only.检查设备是否有输入法服务活动。返回真/假。安卓用法:print(driver.is_ime_active()) activate_ime_engineactivate_ime_engine(self, engine):Activates the given IME engine on the device.Android only.激活安卓设备中的指定输入法，设备可用输入法可以从“available_ime_engines”获取Args: engine - the package and activity of the IME engine to activate (e.g.,’com.android.inputmethod.latin/.LatinIME’) 用法: driver.activate_ime_engine(“com.android.inputmethod.latin/.LatinIME”) deactivate_ime_enginedeactivate_ime_engine(self):Deactivates the currently active IME engine on the device.Android only.关闭安卓设备当前的输入法用法:driver.deactivate_ime_engine() active_ime_engineactive_ime_engine(self):Returns the activity and package of the currently active IME engine (e.g.,’com.android.inputmethod.latin/.LatinIME’).Android only.返回当前输入法的包名用法:driver.active_ime_engine toggle_location_servicestoggle_location_services(self):Toggle the location services on the device. Android only.打开安卓设备上的位置定位设置用法:driver.toggle_location_services() set_locationset_location(self, latitude, longitude, altitude):Set the location of the device设置设备的经纬度Args: latitude纬度 - String or numeric value between -90.0 and 90.00 longitude经度 - String or numeric value between -180.0 and 180.0 altitude海拔高度- String or numeric value 用法:driver.set_location(纬度，经度，高度) tag_nametag_name(self):This element’s tagName property.返回元素的tagName属性经实践返回的是class name用法:element.tag_name() texttext(self):The text of the element.返回元素的文本值用法:element.text() clickclick(self):Clicks the element.点击元素用法:element.click() submitsubmit(self):Submits a form.提交表单用法:暂无 clearclear(self):Clears the text if it’s a text entry element.清除输入的内容用法:element.clear() get_attributeget_attribute(self, name):详见@chenhengjie123 的超级链接Gets the given attribute or property of the element. 获取 content-desc 的方法为 get_attribute(“name”) ，而且还不能保证返回的一定是 content-desc （content-desc 为空时会返回 text 属性值） get_attribute 方法不是我们在 uiautomatorviewer 看到的所有属性都能获取的（此处的名称均为使用 get_attribute 时使用的属性名称)可获取的：字符串类型： name(返回 content-desc 或 text) text(返回 text) className(返回 class，只有 API=&gt;18 才能支持) resourceId(返回 resource-id，只有 API=&gt;18 才能支持)This method will first try to return the value of a property with the given name. If a property with that name doesn’t exist, it returns the value of the attribute with the same name. If there’s no attribute with that name, None is returned.Values which are considered truthy, that is equals “true” or “false”,are returned as booleans. All other non-None values are returned as strings. For attributes or properties which do not exist, None is returned. Args: name - Name of the attribute/property to retrieve. Example: # Check if the &quot;active&quot; CSS class is applied to an element. is_active = &quot;active&quot; in target_element.get_attribute(&quot;class&quot;) 用法:暂无 is_selectedis_selected(self):Returns whether the element is selected.Can be used to check if a checkbox or radio button is selected.返回元素是否选择。可以用来检查一个复选框或单选按钮被选中。用法:element.is_slected() is_enabledis_enabled(self):Returns whether the element is enabled.返回元素是否可用True of False用法:element.is_enabled() find_element_by_idfind_element_by_id(self, id_):Finds element within this element’s children by ID.通过元素的ID定位元素Args: id_ - ID of child element to locate. 用法:driver. find_element_by_id(“id”) find_elements_by_idfind_elements_by_id(self, id_):Finds a list of elements within this element’s children by ID.通过元素ID定位,含有该属性的所有元素Args: id_ - Id of child element to find. 用法:driver. find_elements_by_id(“id”) find_element_by_namefind_element_by_name(self, name):Finds element within this element’s children by name.通过元素Name定位（元素的名称属性text）.Args: name - name property of the element to find. 用法:driver.find_element_by_name(“name”) find_elements_by_namefind_elements_by_name(self, name):Finds a list of elements within this element’s children by name.通过元素Name定位（元素的名称属性text），含有该属性的所有元素.Args: name - name property to search for. 用法:driver.find_element_by_name(“name”) find_element_by_link_textfind_element_by_link_text(self, link_text):Finds element within this element’s children by visible link text.通过元素可见链接文本定位.Args: link_text - Link text string to search for. 用法:driver.find_element_by_link_text(“text”) find_elements_by_link_textfind_element_by_link_text(self, link_text):Finds a list of elements within this element’s children by visible link text.通过元素可见链接文本定位,含有该属性的所有元素.Args: link_text - Link text string to search for. 用法:driver.find_elements_by_link_text(“text”) find_element_by_partial_link_textfind_element_by_partial_link_text(self, link_text):Finds element within this element’s children by partially visible link text.通过元素部分可见链接文本定位.Args: link_text - Link text string to search for. driver. find_element_by_partial_link_text(“text”) find_elements_by_partial_link_textfind_elements_by_partial_link_text(self, link_text):Finds a list of elements within this element’s children by link text.通过元素部分可见链接文本定位,含有该属性的所有元素.Args: link_text - Link text string to search for. driver. find_elements_by_partial_link_text(“text”) find_element_by_tag_namefind_element_by_tag_name(self, name):Finds element within this element’s children by tag name.通过查找html的标签名称定位元素Args: name - name of html tag (eg: h1, a, span) 用法: driver.find_element_by_tag_name(“name”) find_elements_by_tag_namefind_elements_by_tag_name(self, name):Finds a list of elements within this element’s children by tag name.通过查找html的标签名称定位所有元素Args: name - name of html tag (eg: h1, a, span). 用法: driver.find_elements_by_tag_name(“name”) find_element_by_xpathfind_element_by_xpath(self, xpath):Finds element by xpath.通过Xpath定位元素，详细方法可参阅http://www.w3school.com.cn/xpath/Args:xpath - xpath of element to locate. “//input[@class=’myelement’]”Note: The base path will be relative to this element’s location.This will select the first link under this element.myelement.find_elements_by_xpath(&quot;.//a&quot;)However, this will select the first link on the page.myelement.find_elements_by_xpath(&quot;//a&quot;) 用法 find_element_by_xpath(“//*”) find_elements_by_xpathfind_elements_by_xpath(self, xpath):Finds elements within the element by xpath.Args: xpath - xpath locator string. Note: The base path will be relative to this element’s location.This will select all links under this element.myelement.find_elements_by_xpath(&quot;.//a&quot;).However, this will select all links in the page itself.myelement.find_elements_by_xpath(&quot;//a&quot;). 用法:find_elements_by_xpath(“//*”) find_element_by_class_namefind_element_by_class_name(self, name):Finds element within this element’s children by class name.通过元素class name属性定位元素.Args: name - class name to search for. 用法:driver. find_element_by_class_name(“android.widget.LinearLayout”) find_elements_by_class_namefind_elements_by_class_name(self, name):Finds a list of elements within this element’s children by class name.通过元素class name属性定位所有含有该属性的元素.Args: name - class name to search for. 用法:driver. find_elements_by_class_name(“android.widget.LinearLayout”). find_element_by_css_selectorfind_element_by_css_selector(self, css_selector):Finds element within this element’s children by CSS selector.通过CSS选择器定位元素.Args: css_selector - CSS selctor string, ex: ‘a.nav#home’ send_keyssend_keys(self, *value):Simulates typing into the element.在元素中模拟输入（开启appium自带的输入法并配置了appium输入法后，可以输入中英文）.Args: value - A string for typing, or setting form fields. For setting file inputs, this could be a local file path.Use this to send simple key events or to fill out form fields:form_textfield = driver.find_element_by_name(&#39;username&#39;)form_textfield.send_keys(&quot;admin&quot;)This can also be used to set file inputs.file_input = driver.find_element_by_name(&#39;profilePic&#39;)file_input.send_keys(&quot;path/to/profilepic.gif&quot;)# Generally it&#39;s better to wrap the file path in one of the methods# in os.path to return the actual path to support cross OS testing.# file_input.send_keys(os.path.abspath(&quot;path/to/profilepic.gif&quot;))driver.element.send_keys(“中英”) is_displayedis_displayed(self):Whether the element is visible to a user.此元素用户是否可见。简单地说就是隐藏元素和被控件挡住无法操作的元素（仅限 Selenium，appium是否实现了类似功能不是太确定）这一项都会返回 False.用法:driver.element.is_displayed() location_once_scrolled_into_viewlocation_once_scrolled_into_view(self):“””THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover. where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view.Returns the top lefthand corner location on the screen, or None if the element is not visible. 暂不知道用法 sizesize(self):The size of the element.获取元素的大小（高和宽）.new_size[&quot;height&quot;] = size[&quot;height&quot;]new_size[&quot;width&quot;] = size[&quot;width&quot;] 用法:driver.element.size value_of_css_propertyvalue_of_css_property(self, property_name):The value of a CSS property.CSS属性用法 暂不知 locationlocation(self):The location of the element in the renderable canvas.获取元素左上角的坐标用法:driver.element.location返回element的x坐标, int类型driver.element.location.get(&#39;x&#39;)返回element的y坐标, int类型driver.element.location.get(&#39;y&#39;) rectrect(self):A dictionary with the size and location of the element.元素的大小和位置的字典 screenshot_as_base64screenshot_as_base64(self):Gets the screenshot of the current element as a base64 encoded string.获取当前元素的截图为Base64编码的字符串Usage:img_b64 = element.screenshot_as_base64 execute_scriptexecute_script(self, script, *args):Synchronously Executes JavaScript in the current window/frame.在当前窗口/框架（特指 Html 的 iframe ）同步执行 javascript 代码。你可以理解为如果这段代码是睡眠5秒，这五秒内主线程的 javascript 不会执行Args: script: The JavaScript to execute. *args: Any applicable arguments for your JavaScript.Usage:driver.execute_script(&#39;document.title&#39;) execute_async_scriptexecute_async_script(self, script, *args):Asynchronously Executes JavaScript in the current window/frame.插入 javascript 代码，只是这个是异步的，也就是如果你的代码是睡眠5秒，那么你只是自己在睡，页面的其他 javascript 代码还是照常执行Args: script: The JavaScript to execute. *args: Any applicable arguments for your JavaScript. Usage:driver.execute_async_script(&#39;document.title&#39;) current_urlcurrent_url(self):Gets the URL of the current page.获取当前页面的网址。Usage:driver.current_url用法driver.current_url page_sourcepage_source(self):Gets the source of the current page.获取当前页面的源Usage:driver.page_source closeclose(self):Closes the current window.关闭当前窗口Usage:driver.close() quitquit(self):Quits the driver and closes every associated window.退出脚本运行并关闭每个相关的窗口连接Usage:driver.quit() 参考资料:打造心目中理想的自动化测试框(AppiumBooster) 从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用 Python-Client的github文档地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LaTeX表示方法]]></title>
      <url>%2F2017%2F02%2F18%2Flatex%2F</url>
      <content type="text"><![CDATA[一、指数和下标可以用^和_后加相应字符来实现。 二、平方根（square root）的输入命令为：\sqrt，n 次方根相应地为: \sqrt[n]。方根符号的大小由LATEX自动加以调整。也可用\surd 仅给出符号。 三、命令\overline 和\underline 在表达式的上、下方画出水平线。 四、命令\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号。 五、向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量时非常有用。 六、分数（fraction）使用\frac{…}{…} 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。 七、积分运算符（integral operator）用\int 来生成。求和运算符（sum operator）由\sum 生成。乘积运算符（product operator）由\prod 生成。上限和下限用^ 和_来生成，类似于上标和下标。 以下提供一些常用符号的表示方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[命令行工具使用]]></title>
      <url>%2F2017%2F02%2F18%2Fcommand-line-tools%2F</url>
      <content type="text"><![CDATA[替换Ruby的源 $gem source -r https://rubygems.org/ $ gem source -a https://ruby.taobao.org $ gem sources -l要想验证是否替换成功了，可以执行 CURRENT SOURCES http://ruby.taobao.org/正常的输出结果 Mac OS X安装Ruby运行环境 先安装 Xcode 开发工具，它将帮你安装好 Unix 环境需要的开发包。 安装 RVM $ curl -L https://get.rvm.io | bash -s stable期间可能会问你sudo管理员密码，以及自动通过homebrew安装依赖包，等待一段时间后就可以成功安装好 RVM。 $ source ~/.rvm/scripts/rvm载入 RVM 环境 rvm -v检查一下是否安装正确 用 RVM 安装 Ruby 环境 $ rvm list known列出已知的ruby版本 $ rvm install 2.4.0可以选择现有的rvm版本来进行安装 $ rvm list查询已经安装的ruby $ rvm remove 1.9.2卸载一个已安装版本 设置 Ruby 版本 $ rvm 2.0.0 --defaultRVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本 Mac OS X安装cocoapods sudo gem install cocoapods 如果速度不行，更换源。 Mac OS X安装命令行切图工具 由一张1024*1024的图片批量生成applogo brew install imagemagick 配置icon_convert.sh文件 cd 到icon_convert.sh所在文件夹 执行./icon_convert.sh &#39;1024.png&#39; 生成对应的appicon]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Matrix]]></title>
      <url>%2F2017%2F02%2F10%2Fandroid-matrix%2F</url>
      <content type="text"><![CDATA[Matrix的数学原理在Android中，如果你用Matrix进行过图像处理，那么一定知道Matrix这个类。Android中的Matrix是一个3 x 3的矩阵，其内容如下： Matrix的对图像的处理可分为四类基本变换： Translate ———— 平移变换 Rotate ———— 旋转变换 Scale ———— 缩放变换 Skew ———— 错切变换 从字面上理解，矩阵中的MSCALE用于处理缩放变换，MSKEW用于处理错切变换，MTRANS用于处理平移变换，MPERSP用于处理透视变换。实际中当然不能完全按照字面上的说法去理解Matrix。同时，在Android的文档中，未见到用Matrix进行透视变换的相关说明，所以本文也不讨论这方面的问题。 针对每种变换，Android提供了pre、set和post三种操作方式。其中 set用于设置Matrix中的值。 pre是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。 post是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。 除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。 下面我们来看看四种变换的具体情形。由于所有的图形都是有点组成，因此我们只需要考察一个点相关变换即可。 一、 平移变换假定有一个点的坐标是 P($x{0}$,$y{0}$) ，将其移动到 P(x,y) ，再假定在x轴和y轴方向移动的大小分别为: $\Delta$x = x - $x{0}$ and $\Delta$y = y - $y{0}$ 如下图所示： 不难知道：x = $x{0}$ + $\Delta$xy = $y{0}$ + $\Delta$y 如果用矩阵来表示的话，就可以写成： 二、 旋转变换2.1 围绕坐标原点旋转：假定有一个点 P($x{0}$,$y{0}$) ，相对坐标原点 $\theta$ 顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图： 那么， 如果用矩阵，就可以表示为： 2.2 围绕某个点旋转如果是围绕某个点 P($x{p}$,$y{p}$) 顺时针旋转 $\theta$ ，那么可以用矩阵表示为：可以化为：很显然1、是将坐标原点移动到点 P($x{p}$,$y{p}$) 后， P($x{0}$,$y{0}$) 的新坐标。 2、是将上一步变换后的 P($x{0}$,$y{0}$) ，围绕新的坐标原点顺时针旋转 $\theta$ 。3、经过上一步旋转变换后，再将坐标原点移回到原来的坐标原点。所以，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。 三、 缩放变换理论上而言，一个点是不存在什么缩放变换的，但考虑到所有图像都是由点组成，因此，如果图像在x轴和y轴方向分别放大k1和k2倍的话，那么图像中的所有点的x坐标和y坐标均会分别放大k1和k2倍，即x = $k{1}$$x{0}$y = $k{2}$$y{0}$用矩阵表示就是：缩放变换比较好理解，就不多说了。 四、 错切变换错切变换(skew)在数学上又称为Shear mapping(可译为“剪切变换”)或者Transvection(缩并)，它是一种比较特殊的线性变换。错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对应的y坐标(或者x坐标)则按比例发生平移，且平移的大小和该点到x轴(或y轴)的垂直距离成正比。错切变换，属于等面积变换，即一个形状在错切变换的前后，其面积是相等的。比如下图，各点的y坐标保持不变，但其x坐标则按比例发生了平移。这种情况将水平错切。 下图各点的x坐标保持不变，但其y坐标则按比例发生了平移。这种情况叫垂直错切。 假定一个点 P($x{0}$,$y{0}$) 经过错切变换后得到 P(x,y) ，对于水平错切而言，应该有如下关系：x = $x{0}$ + k$y{0}$y = $y_{0}$用矩阵表示就是：扩展到3 x 3的矩阵就是下面这样的形式：同理，对于垂直错切，可以有：在数学上严格的错切变换就是上面这样的。在Android中除了有上面说到的情况外，还可以同时进行水平、垂直错切，那么形式上就是： 五、 对称变换除了上面讲到的4中基本变换外，事实上，我们还可以利用Matrix，进行对称变换。所谓对称变换，就是经过变化后的图像和原图像是关于某个对称轴是对称的。比如，某点 P($x{0}$,$y{0}$) 经过对称变换后得到 P(x,y) ， 如果对称轴是x轴，那么，x = $x{0}$y = -$y{0}$用矩阵表示就是：如果对称轴是y轴，那么，x = -$x{0}$y = $y{0}$用矩阵表示就是：如果对称轴是y = x，如图：那么，很容易可以解得：x = $y{0}$y = $x{0}$用矩阵表示就是：同样的道理，如果对称轴是y = -x，那么用矩阵表示就是：特殊地，如果对称轴是y = kx，如下图：那么，很容易可解得：用矩阵表示就是： 当k = 0时，即y = 0，也就是对称轴为x轴的情况；当k趋于无穷大时，即x = 0，也就是对称轴为y轴的情况；当k =1时，即y = x，也就是对称轴为y = x的情况；当k = -1时，即y = -x，也就是对称轴为y = -x的情况。不难验证，这和我们前面说到的4中具体情况是相吻合的。如果对称轴是y = kx + b这样的情况，只需要在上面的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：需要特别注意：在实际编程中，我们知道屏幕的y坐标的正向和数学中y坐标的正向刚好是相反的，所以在数学上y = x和屏幕上的y = -x才是真正的同一个东西，反之亦然。也就是说，如果要使图片在屏幕上看起来像按照数学意义上y = x对称，那么需使用这种转换：要使图片在屏幕上看起来像按照数学意义上y = -x对称，那么需使用这种转换：关于对称轴为y = kx 或y = kx + b的情况，同样需要考虑这方面的问题。 第二部分 代码验证在第一部分中讲到的各种图像变换的验证代码如下，一共列出了10种情况。如果要验证其中的某一种情况，只需将相应的代码反注释即可。试验中用到的图片：其尺寸为162 x 251。 每种变换的结果，请见代码之后的说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372import android.app.Activity; import android.content.Context; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.graphics.Canvas; import android.graphics.Matrix; import android.os.Bundle; import android.util.Log; import android.view.MotionEvent; import android.view.View; import android.view.Window; import android.view.WindowManager; import android.view.View.OnTouchListener; import android.widget.ImageView; public class TestTransformMatrixActivity extends Activity implements OnTouchListener &#123; private TransformMatrixView view; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); view = new TransformMatrixView(this); view.setScaleType(ImageView.ScaleType.MATRIX); view.setOnTouchListener(this); setContentView(view); &#125; class TransformMatrixView extends ImageView &#123; private Bitmap bitmap; private Matrix matrix; public TransformMatrixView(Context context) &#123; super(context); bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie); matrix = new Matrix(); &#125; @Override protected void onDraw(Canvas canvas) &#123; // 画出原图像 canvas.drawBitmap(bitmap, 0, 0, null); // 画出变换后的图像 canvas.drawBitmap(bitmap, matrix, null); super.onDraw(canvas); &#125; @Override public void setImageMatrix(Matrix matrix) &#123; this.matrix.set(matrix); super.setImageMatrix(matrix); &#125; public Bitmap getImageBitmap() &#123; return bitmap; &#125; &#125; public boolean onTouch(View v, MotionEvent e) &#123; if(e.getAction() == MotionEvent.ACTION_UP) &#123; Matrix matrix = new Matrix(); // 输出图像的宽度和高度(162 x 251) Log.e("TestTransformMatrixActivity", "image size: width x height = " + view.getImageBitmap().getWidth() + " x " + view.getImageBitmap().getHeight()); // 1. 平移 matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight()); // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight() view.setImageMatrix(matrix); // 下面的代码是为了查看matrix中的元素 float[] matrixValues = new float[9]; matrix.getValues(matrixValues); for(int i = 0; i &lt; 3; ++i) &#123; String temp = new String(); for(int j = 0; j &lt; 3; ++j) &#123; temp += matrixValues[3 * i + j ] + "\t"; &#125; Log.e("TestTransformMatrixActivity", temp); &#125; // // 2. 旋转(围绕图像的中心点) // matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f); // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 3. 旋转(围绕坐标原点) + 平移(效果同2) // matrix.setRotate(45f); // matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f); // matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f); // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 4. 缩放 // matrix.setScale(2f, 2f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 5. 错切 - 水平 // matrix.setSkew(0.5f, 0f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth(), 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 6. 错切 - 垂直 // matrix.setSkew(0f, 0.5f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // 7. 错切 - 水平 + 垂直 // matrix.setSkew(0.5f, 0.5f); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 8. 对称 (水平对称) // float matrix_values[] = &#123;1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 9. 对称 - 垂直 // float matrix_values[] = &#123;-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // 10. 对称(对称轴为直线y = x) // float matrix_values[] = &#123;0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f&#125;; // matrix.setValues(matrix_values); // // 下面的代码是为了查看matrix中的元素 // float[] matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; // // // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠 // matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(), // view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth()); // view.setImageMatrix(matrix); // // // 下面的代码是为了查看matrix中的元素 // matrixValues = new float[9]; // matrix.getValues(matrixValues); // for(int i = 0; i &lt; 3; ++i) // &#123; // String temp = new String(); // for(int j = 0; j &lt; 3; ++j) // &#123; // temp += matrixValues[3 * i + j ] + "\t"; // &#125; // Log.e("TestTransformMatrixActivity", temp); // &#125; view.invalidate(); &#125; return true; &#125; &#125; 下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵 1、平移输出的结果：请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。 2、旋转(围绕图像的中心点)输出的结果： 它实际上是matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式,matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);所产生的转换矩阵就是：而matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);的意思就是在上述矩阵的左边再乘以下面的矩阵：关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。所以它实际上就是：出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。 3、旋转(围绕坐标原点旋转，在加上两次平移，效果同2)根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道：matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);等价于matrix.setRotate(45f);matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);其中matrix.setRotate(45f)对应的矩阵是： matrix.preTranslate(-1f view.getImageBitmap().getWidth() / 2f, -1f view.getImageBitmap().getHeight()/ 2f)对应的矩阵是： 由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。 matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f)对应的矩阵是：这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。 所以综合起来， matrix.setRotate(45f);matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);对应的矩阵就是：这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的：因此，此处变换后的图像和2中变换后的图像时一样的。 4、缩放变换程序所输出的两个矩阵分别是：其中第二个矩阵，其实是下面两个矩阵相乘的结果：大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。 5、错切变换(水平错切)代码所输出的两个矩阵分别是：其中，第二个矩阵其实是下面两个矩阵相乘的结果：大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 6、错切变换(垂直错切) 代码所输出的两个矩阵分别是：其中，第二个矩阵其实是下面两个矩阵相乘的结果：大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 7、错切变换(水平+垂直错切)代码所输出的两个矩阵分别是：其中，后者是下面两个矩阵相乘的结果：大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。 8、对称变换(水平对称) 代码所输出的两个各矩阵分别是：其中，后者是下面两个矩阵相乘的结果：大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 9、对称变换(垂直对称) 代码所输出的两个矩阵分别是：其中，后者是下面两个矩阵相乘的结果：大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 10、对称变换(对称轴为直线y = x)代码所输出的两个矩阵分别是：其中，后者是下面两个矩阵相乘的结果：大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。 11、关于先乘和后乘的问题由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例：越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。 当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate($\theta$)，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 冷启动实现APP秒开]]></title>
      <url>%2F2017%2F02%2F09%2Fandroid-cold-launch%2F</url>
      <content type="text"><![CDATA[前言在阅读这篇文章之前，首先需要理解几个东西： 1、什么是Android的冷启动时间？冷启动时间是指用户从手机桌面点击APP的那一刻起到启动页面的Activity调用onCreate()方法之间的这个时间段。 2、在冷启动的时间段内发生了什么？首先我们要知道当打开一个Activity的时候发生了什么，在一个Activity打开时，如果该Activity所属的Application还没有启动，那么系统会为这个Activity创建一个进程（每创建一个进程都会调用一次Application，所以Application的onCreate()方法可能会被调用多次），在进程的创建和初始化中，势必会消耗一些时间，在这个时间里，WindowManager会先加载APP里的主题样式里的窗口背景（windowBackground）作为预览元素，然后才去真正的加载布局，如果这个时间过长，而默认的背景又是黑色或者白色，这样会给用户造成一种错觉，这个APP很卡，很不流畅，自然也影响了用户体验。 来看下效果图：未优化： 优化方案一： 优化方案二： 历史原因当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态的，这就很尴尬了，因为用户会以为没有点到APP而再次点击，这极大的降低用户体验，Android需要及时做出反馈去避免这段迷之尴尬。于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是Preview Window,即预览窗口。 好了，现在我们明白了，Preview Window其实是为了提高用户体验而有意设定的。因此，其实如果不是强迫症，它可能并不是一个问题。 但是我猜大部分小伙伴应该是和我一样的强迫症患者：这么丑的黑屏怎么能出现在我的APP上呢？？？！！！ 所以，下面我们就来聊聊这个问题的解决方案。 解决方案既然决定解决这个问题，那么从哪里入手呢，Android在选择展示黑屏或者白屏的时候，是根据你设定的主题而不同的，也就是说，虽然你的代码没有被执行，你的配置文件却被提前读取了，用来作为展示Preview Window界面的依据。在用户点击手机桌面APP的时候，看到的黑屏或者白屏其实是界面渲染前的第一帧，如果你看懂了文章头的那2个问题，那么解决这个问题就非常轻松了，无非就是将Theme里的windowBackground设置成我们想要让用户看到的画面就可以了 所以，我们的解决方案的切入口就是整个APP的manifest文件，更确切的说应该是主题配置文件。 方案一 ：开历史倒车这个方案就是禁止加载Preview Window，具体做法如下： style.xml true将APPTheme设定为启动的Activity的主题，即可禁止Preview Window，当然，也有人通过把preview window设置为全透明，也达成了类似的效果。 结果就是，当你点击APP时，界面会无响应一段时间，然后进入APP。 我个人强烈不推荐这么做，因为Android想方设法提升的用户体验一下子被你打回解放前。 方案二：自定义Preview Window1、透明启动将背景颜色设置为透明色，这样当用户点击桌面APP图片的时候，并不会”立即”进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦，哈哈），其实现在微信也是这样做的，不信你可以试试。&lt;style name=&quot;Appwelcome&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot;/&gt;透明化这种做法需要注意的一点，如果直接把Theme引入Activity，在运行的时候可能会出现如下异常： java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity. 这个是因为使用了不兼容的Theme，例如我这里的Activity继承了AppCompatActivity，解决方案很简单： 1、让其Activity集成Activity而不要集成兼容性的AppCompatActivity 2、在onCreate()方法里的super.onCreate(savedInstanceState)之前设置我们原来APP的Theme 1234567public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; setTheme(R.style.AppTheme); super.onCreate(savedInstanceState); &#125;&#125; 2、Logo图片启动将背景图设置成我们APP的Logo图，作为APP启动的引导，现在市面上大部分的APP也是这么做的。具体方法如下： style.xlm123&lt;style name="APPTheme" parent="@android:style/Theme.Holo.NoActionBar"&gt; &lt;item name="android:windowBackground"&gt;@drawable/splash_icon&lt;/item&gt;&lt;/style&gt; 同样将主题设置到启动的Activity的主题中，windowBackground就是即将展示的preview window。其中splash_icon可以是一整张图片，网上很多小伙伴也都是这么做的。其实它也可以是一个能解析出图片资源的XML文件，好像只有layer-list这种能做得到,因为它能够将多个drawable叠加起来展示。 splash_icon.xml12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" android:opacity="opaque"&gt; &lt;item android:drawable="@color/white"/&gt; &lt;item&gt; &lt;bitmap android:gravity="center" android:src="@drawable/qq"/&gt; &lt;/item&gt;&lt;/layer-list&gt; 这样设置之后，当你点击APP，会立马进入你配置的界面，然后启动欢迎页，效果如下 上面的2种做法，我们都需要将Theme引入对应的Activity123456789&lt;activity android:name=".app.main.MainActivity" android:theme="@style/AppWelcome" android:screenOrientation="portrait"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 那么，将preview window直接设置为图片和设置为xml文件有什么区别或者优劣呢？我先卖个关子。先谈谈这种方案的优劣，首先这种方案已经解决了原生preview window的单调难看的问题，在原来的基础上进一步提升了用户体验。可是我们的APP都是有欢（guang）迎（gao）页的，从preview window跳转到欢（guang）迎（gao）页是不可避免的，这样的话，两个界面的切换就会显得很突兀的， 所以强迫症的我们，尝试让这两个界面的切换变成一个界面的变化，从而进一步提升显示效果，怎么样才能让两个界面切换看起来像是在同一个界面里的变化呢？答案就是： 动画。 在这种需求下，图片和xml文件的区别就出来了，因为后者可以帮助我们更准确的实现动画。 方案三：自定义Preview Window增强版废话少说，我们先来看效果 有了动画之后，界面切换顺畅了许多。上面的动画实现其实非常简单，无非就是放缩，移动，渐变的组合使用（我仅仅用作范例给大家参考），具体的动画代码细节就不谈了，有兴趣可以去github上看本次项目的demo，我们重点来聊一聊思路。 在这里我们需要明确一点的是，preview window 只能是静态图，它本身是不展示动画的，我们这里的动画，其实是在进入欢迎页之后的展示的。明确了这一点之后，整个动画效果的实现思路其实就已经摆在我们眼前了，那就是当界面从 Preview Window 跳转到 欢迎页 的时候，欢迎页必须首先展示一个和 Preview Window 一模一样的界面，让人看起来好像界面还没切换一样，然后再慢慢切换到欢迎页。 然后，我们再来谈谈为什么设置xml的方式可以帮助我们更准确的实现动画，就是因为要保证 Preview Window 和欢迎页最开始展示的界面保持绝对一致，只有通过xml的布局才是达到这种效果。 好了，启动页做到这个份儿上，应该就可以交货了，不过还有一个小问题需要大家注意的，那就是我们给Preview Window设置的背景图如果不做处理，图片就会一直存在于内存中，所以，当我们进入到欢迎页的时候，不要忘了把背景图设置为空： SplashActivity.java123456@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; //将window的背景图设置为空 getWindow().setBackgroundDrawable(null); super.onCreate(savedInstanceState);&#125; 关于启动优化上面的做法其实可以达到”秒开”APP的效果，不过确不是真实的速度，在Activity创建过程中其实是会经过一系列framework层的操作，在日常开发中，我们都会去重写Application类，然后在Application里进行一些初始化操作，比如存放用户标识的静态化TOKEN，第三方SDK的初始化等。这里给出几点建议： 1、不要让Application参与业务的操作 2、不要在APPlication进行耗时操作，比如有些开发者会在自己的APP里一系列文件夹或文件（比如我自己），这些I/O操作应该放到”确实该使用的时候再去创建”亦或者是数据库的一些操作。 3、不要以静态变量的方式在Application中保存数据等。 当然这是绝对的理想主义，把上面的”不要”2字之前添上”尽量”2字吧，毕竟在实际开发中，这样做确实会让我们方便许多。 对了，补充一点，布局也是很重要的，尽量的去减少布局的复杂性，布局深度，因为在View绘制的过程中，测量也是很耗费性能的。 总结到这里，关于Android启动页的相关问题就都讲完了。最终的高清的效果图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 关联 Bitbucket]]></title>
      <url>%2F2017%2F02%2F09%2Fandroidstudio-bitbucket%2F</url>
      <content type="text"><![CDATA[前言Github的确是一个开源代码浏览以及存放的好去处。但是当你想要创立一个私人仓库，存放自己的个人项目时，公开的仓库肯定是不行的，而私人账号必须要收费。对于那些手头紧，并且不想维护服务器的人来说，Bitbucket是个不错的选择。每个Bitbucket账号可以创立5个免费的私人仓库，够用了。最近在做毕业设计，需要将项目git到一个私人仓库，所以学习一下Android Studio和Bitbucket关联，毕竟能IDE中git，就觉得用SourceTree有点麻烦。 Bitbucket简介BitBucket 是一家源代码托管网站，采用Mercurial和Git作为分布式版本控制系统，同时提供商业计划和免费账户。常用的代码托管平台Github、SVN、Bitbucket中，Bitbucket具有以下优势： 支持Hg，最易学易用（但不是最强大的）的分布式版本管理工具。同时也支持Git。他的网页端的git仓库不如github好用，但是作为远端仓库足够了。 完全免费的闭源项目，还支持5人以内的合作开发。 支持中文。 官方的git工具SourceTree比GitHub for windows好用。 使用步骤一、安装Git安装步骤都是一路默认下一步，这里就不做说明了，安装好了后，需要将AndroidStudio与Git进行关联： Android Studio–&gt; Preferences –&gt; Version Control –&gt; Git，在Path to Git executable栏找到Git安装目录中bin文件下的git文件。点击右侧的Test，如果出现如图中的成功提示框，表示AndroidStudio与Git已经关联成功。 二、在Bitbucket网站创建远程仓库在Bitbucket网站上创建仓库 记录下远程仓库的URL，后面会用到 三、在AndroidStudio中创建新项目首先新建一个项目,然后进入项目后首先选择VCS–&gt;Enable Version Control Integration,然后选择Git，此时代码文件会变成红色 接下来设置项目需要忽略上传的文件File–&gt;Settings –&gt; Version Control –&gt;Ignore Files 接下来将项目添加到Git本地仓库中，在Project视图下，右键工程Git–&gt;Add,添加成功后，代码文件会变成绿色的。 至此创建项目就完成了 四、AndroidStudio中将项目提交并推送到远程仓库进入AS项目中，选择VCS–&gt;Git-&gt;Commit File 填写提交信息后，选择commit and Push 之后点击Define remote 填入第二步中的远程仓库URL，点击OK校验URL后就可以Push了。 到此项目构建者的工作就算完成了，其他小伙伴可以直接参照第六步，从远程仓库剪切项目代码。 六、别忘了给Bitbucket添加SSH密钥ssh-keygen -t rsa -C &quot;your_email@example.com&quot;使用你的邮件创建一个新的 SSH 密匙标签，将会生成 ~/.ssh/id_rsa 文件， 用于存储你的密匙。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Thread]]></title>
      <url>%2F2017%2F02%2F05%2Fandroid-thread%2F</url>
      <content type="text"><![CDATA[线程简介现在操作系统在运行一个程序时，会自动为其创建一个进程，不论是 PC 还是 Android。 一个进程内可以有多个线程，这些线程作为操作系统调度的最小单元，负责执行各种各样的任务，这些线程都拥有各自的计数器、堆栈、局部变量等属性，并且可以访问共享内存。 想象一下，如果你的电脑里只有一条线程在执行任务，一旦遇到 I/O 密集的任务，CPU 只能长时等待，效率很低。 如果把一个进程比作一个外卖公司，CPU 就是外卖公司拥有的主要资源（可以当做电动车），那线程（Thread）就是外卖公司中的一位送餐员，Runnable 就是送餐员要执行的任务（一般情况下都是送饭）。 线程创建的三种方式送餐员最重要的任务就是送餐，我们以代码来演示创建一个送餐员的三种方式： 1.实现 Runnable 接口123456789101112131415161718192021222324252627public class ThreadTest0 &#123; /** * 1.实现 Runnable 接口，在 run() 方法中写要执行的任务 */ static class Task implements Runnable&#123; @Override public void run() &#123; try &#123; Thread.sleep(new Random().nextInt(300 )); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": 您的外卖已送达"); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 4; i++) &#123; //2.创建一个送餐员线程，然后将任务传递给他，同时起个名 Thread shixinzhang = new Thread(new Task(), "外卖任务 " + i); //3.命令送餐员出发！ shixinzhang.start(); &#125; &#125;&#125; 注意，上述代码中调用的是送餐员线程的 start() 方法，然后线程会调用 Task 对象的 run() 方法执行任务。运行结果如下： 外卖任务 3: 您的外卖已送达外卖任务 1: 您的外卖已送达外卖任务 0: 您的外卖已送达外卖任务 2: 您的外卖已送达 可以看到执行任务的是各个线程。如果在 main() 方法中直接调用 run 方法，就相当于主线程直接执行任务，没有在子线程中进行。 直接在 main 中调用 run()：123456789public static void main(String[] args) &#123; for (int i = 0; i &lt; 4; i++) &#123; //2.创建一个送餐员线程，然后将任务传递给他，同时起个名 Task task = new Task(); Thread shixinzhang = new Thread(task, "外卖任务 " + i); //3.直接执行任务 task.run(); &#125;&#125; 运行结果： main: 您的外卖已送达main: 您的外卖已送达main: 您的外卖已送达main: 您的外卖已送达 2.继承 Thread，重写其 run 方法123456789101112131415161718192021222324252627282930public class ThreadTest1 &#123; /** * 继承 Thread，重写 run 方法，在 run 方法中写要执行的任务 */ static class DeliverThread extends Thread&#123; public DeliverThread(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; Thread.sleep(new Random().nextInt(300 )); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ": 您的外卖已送达"); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 4; i++) &#123; //2.创建一个送餐员线程，同时起个名 DeliverThread shixinzhang = new DeliverThread("外卖任务" + i); shixinzhang.start(); &#125; &#125;&#125; 运行结果： 外卖任务1: 您的外卖已送达外卖任务3: 您的外卖已送达外卖任务0: 您的外卖已送达外卖任务2: 您的外卖已送达 为什么直接继承 Thread 也可以在子线程中执行任务呢？ 从 Thread 源码中我们可以看到， Thread 其实也实现了 Runnable ：public class Thread implements Runnable 它内部也有一个 Runnable 的引用，我们调用 start() 方法后送餐员小张就蓄势以待准备出发了，之所以没说“立即出发送餐”，是因为此时可能电动车（CPU）正在被别人使用。 线程 start() 后操作系统会给他分配相关的资源，包括单独的程序计数器（可以理解为送餐员的任务本，上面记录了当前送餐任务的地址和下一个任务的地址）和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行。 等线程被 CPU 调度后就会执行线程中的 run() 方法，因此我们通过重写 Thread 的 run() 方法就可以达到在子线程执行任务的目的。 3.实现 Callable 接口，重写 call() 方法，用 FutureTask 获得结果123456789101112131415161718192021222324252627282930313233343536373839404142434445public class CallableTest &#123; /** * 实现 Callable 接口 */ static class DeliverCallable implements Callable&lt;String&gt; &#123; /** * 执行方法，相当于 Runnable 的 run, 不过可以有返回值和抛出异常 * @return * @throws Exception */ @Override public String call() throws Exception &#123; Thread.sleep(new Random().nextInt(10000)); System.out.println(Thread.currentThread().getName() + "：您的外卖已送达"); return Thread.currentThread().getName() + " 送达时间：" + System.currentTimeMillis() + "\n"; &#125; &#125; /** * Callable 作为参数传递给 FutureTask，FutureTask 再作为参数传递给 Thread（类似 Runnable），然后就可以在子线程执行 * @param args */ public static void main(String[] args) &#123; List&lt;FutureTask&lt;String&gt;&gt; futureTasks = new ArrayList&lt;&gt;(4); for (int i = 0; i &lt; 4; i++) &#123; DeliverCallable callable = new DeliverCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable); futureTasks.add(futureTask); Thread thread = new Thread(futureTask, "送餐员 " + i); thread.start(); &#125; StringBuilder results = new StringBuilder(); futureTasks.forEach(futureTask -&gt; &#123; try &#123; //获取线程返回结果，没返回就会阻塞 results.append(futureTask.get()); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;); System.out.println(System.currentTimeMillis() + " 得到结果：\n" + results); &#125;&#125; 第三种创建线程的方式与前两种的不同之处在于，以 Callable 作为任务，而不是 Runnable，这种方式的好处是可以获得结果和响应中断。 运行结果：123456789送餐员 3：您的外卖已送达 送餐员 1：您的外卖已送达 送餐员 0：您的外卖已送达 送餐员 2：您的外卖已送达 1487998155430 得到结果： 送餐员 0 送达时间：1487998155076 送餐员 1 送达时间：1487998150453 送餐员 2 送达时间：1487998155430 送餐员 3 送达时间：1487998149779 线程的基本属性1.优先级Thread 有个优先级字段：private int priority 操作系统采用时间片（CPU 单次执行某线程的时间）的形式来调度线程的运行，线程被 CPU 调用的时间超过它的时间片后，就会发生线程调度。 线程的优先级可以在一定程度上影响它得到时间片的多少，也就是被处理的机会。 Java 中 Thread 的优先级为从 1 到 10 逐渐提高，默认为 5。 有长耗时操作的线程，一般建议设置低优先级，确保处理器不会被独占太久；频繁阻塞（休眠或者 I/O）的线程建议设置高优先级。123456public final static int MIN_PRIORITY = 1;//线程的默认优先级public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10; 线程优先级只是对操作系统分配时间片的建议。虽然 Java 提供了 10 个优先级别，但不同的操作系统的优先级并不相同，不能很好的和 Java 的 10 个优先级别对应。&gt;所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。 2.守护线程Java 中，线程也分三六九等。守护线程相当于小弟，做一些后台调度、支持性工作,比如 JVM 的垃圾回收、内存管理等线程都是守护线程。 Thread 中有个布尔值标识当前线程是否为守护线程： private boolean daemon = false; 同时也提供了设置和查看当前线程是否为守护线程的方法： 1234567891011public final void setDaemon(boolean on) &#123; checkAccess(); if (isAlive()) &#123; throw new IllegalThreadStateException(); &#125; daemon = on;&#125;public final boolean isDaemon() &#123; return daemon;&#125; Daemon 属性需要在调用线程的 start() 方法之前调用。 一个进程中，如果所有线程都退出了，Java 虚拟机就会退出。注意了，这里的“所有”就不包括守护线程，也就是说，当除守护线程外的其他线程都结束后，Java 虚拟机就会退出，然后将守护进程终止。 这里需要注意的是，由于上述特性，Java 虚拟机退出后，在守护线程中的 finally 块中的代码不一定执行。 举个例子：1234567891011121314151617181920public class DaemonTreadTest0 &#123; static class DaemonThread extends Thread&#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; System.out.println(Thread.currentThread().getName() + " finally is called!"); &#125; &#125; &#125; public static void main(String[] args) &#123; DaemonThread thread = new DaemonThread(); thread.setDaemon(true); thread.start(); &#125;&#125; 上述代码中将线程设置为守护线程，由于 main 线程启动 DaemonThread 后就结束，此时虚拟机中没有非守护线程，虚拟机也会退出，守护进程被终止，但是它的 finally 块中的内容却没有被调用。 如果将setDaemon方法注释掉，就会发现有运行结果: Thread-0 finally is called! 因此，守护线程中不能依靠 finally 块进行资源关闭和清理。 线程的生命周期线程具有如下几个状态： 线程状态 介绍 备注 NEW 新创建 还未调用 start() 方法；还不是活着的 (alive) RUNNABLE 就绪的 调用了 start() ，此时线程已经准备好被执行，处于就绪队列；是活着的(alive) RUNNING 运行中 线程获得 CPU 资源，正在执行任务；活着的 BLOCKED 阻塞的 线程阻塞于锁或者调用了 sleep；活着的 WAITING 等待中 线程由于某种原因等待其他线程；或者的 TIME_WAITING 超时等待 与 WAITING 的区别是可以在特定时间后自动返回；活着的 TERMINATED 终止 执行完毕或者被其他线程杀死；不是活着的 有几点注意： Java 中的 Thread 运行状态没有 RUNNING 这一步，运行中的线程状态是 RUNNABLE 三个让线程进入 WAITING 状态的方法 Object.wait() Thread.join() LockSupport.park() Lock.lock() Java 中关于“线程是否活着”的定义 Thread 中有个判断是否为活着的方法：public final native boolean isAlive() Java 中线程除了 NEW 和 TERMINITED 状态，其他状态下调用 isAlive() 方法均返回 true，也就是活着的。 线程的关键方法1.Thread.sleep()Thread.sleep() 是一个静态方法： public static native void sleep(long millis) throws InterruptedException; sleep() 方法： 使当前所在线程进入阻塞 只是让出 CPU ，并没有释放对象锁 由于休眠时间结束后不一定会立即被 CPU 调度，因此线程休眠的时间可能大于传入参数 如果被中断会抛出 InterruptedException 注意上面的第一条！由于 sleep 是静态方法，它的作用时使当前所在线程祖舍。因此最好在线程内部直接调用 Thread.sleep()，如果你在主线程调用某个线程的 sleep() 方法，其实阻塞的是主线程！ 2.Object.wait()与 Thread.sleep() 容易混淆的是 Object.wait() 方法。 Object.wait() 方法： 让出 CPU，释放对象锁 在调用前需要先拥有某对象的锁，所以一般在 synchronized 同步块中使用 使该线程进入该对象监视器的等待队列 3.Thread.yield()Thread. yield() 也是一个静态方法： public static native void yield(); “Thread.yield() 表示暂停当前线程，让出 CPU 给优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程。 和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。 yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中。 yield() 一般使用较少。 4.Thread.join()Thread.join() 表示线程合并，调用线程会进入阻塞状态，需要等待被调用线程结束后才可以执行。 线程的合并的含义就是将几个并发执行线程的线程合并为一个单线程执行。 比如下述代码：1234567891011121314Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("thread is running!"); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;);thread.start();thread.join();System.out.println("main thread "); 我们在主线程调用了 thread.join() 方法，该线程会在输出一句话后休眠 5 秒，等该线程结束后主线程才可以继续执行，输出最后一句结果： thread is running!main thread Thread.join 源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//无参方法public final void join() throws InterruptedException &#123; join(0);&#125;//有参方法，表示等待 millis 毫秒后自动返回public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125;//有参方法，表示等待 millis + (nanos - 50000) 毫秒后结束public final synchronized void join(long millis, int nanos)throws InterruptedException &#123; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) &#123; millis++; &#125; join(millis);&#125; 通过源码可以发现，Thread.join 是通过 synchronized + Object.wait() 实现的。 Thread.join 的应用场景是：当一个线程必须等待其他线程执行完毕才能继续执行，比如合并计算。 线程的中断有时候我们需要中断一个正在运行的线程，一种很容易想到的方法是在线程的 run() 方法中加一个循环条件： 1234567891011121314151617181920212223242526272829303132public class ThreadInterruptTest1 &#123; static class InterruptThread extends Thread&#123; private boolean running; public InterruptThread(boolean running) &#123; this.running = running; &#125; public boolean isRunning() &#123; return running; &#125; public void setRunning(boolean running) &#123; this.running = running; &#125; @Override public void run() &#123; while (running)&#123; System.out.println(Thread.currentThread().getName() + " is running"); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; InterruptThread thread = new InterruptThread(true); thread.start(); Thread.sleep(5000); thread.setRunning(false); &#125;&#125; 上面的代码中线程 InterruptThread 有一个标志位 running，当这个标志位为 true 时才可以运行。因此我们可以通过修改这个标志位为 false 来中断该线程。 其实 Thread 内部也为我们提供了同样的机制 ： 方法名 方法介绍 public void interrupt() 试图中断调用线程，设置中断标志位为 false public boolean isInterrupted() 返回调用线程是否被中断 public static boolean interrupted() 返回当前线程是否被中断的状态值，同时将中断标志位复位（设为 false） 1.public void interrupt()它的作用是设置标志位为 false，能否达到中断调用线程的效果，还取决于该线程是否可以响应中断（说直白些就是吃不吃这套），比如 Runnable 的 run() 方法就无法响应中断。 因此我们对执行 Runnable 任务的线程调用 interrupt() 方法后，该线程也不会中断，举个例子：123456789101112131415161718192021222324252627282930313233343536373839public class ThreadInterruptTest2 &#123; static class UnInterruptThread extends Thread&#123; public UnInterruptThread(String s) &#123; setName(s); &#125; @Override public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + " is running!"); &#125; &#125; &#125; static class UnInterruptRunnable implements Runnable&#123; @Override public void run() &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + " is running!"); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; UnInterruptThread thread = new UnInterruptThread("无法中断的线程");// Thread thread = new Thread(new UnInterruptRunnable(), "无法中断"); thread.start(); //先让它执行一秒 Thread.sleep(1000); thread.interrupt(); //不立即退出 Thread.sleep(3000); &#125;&#125; 这两种方式创建的线程，在调用 thread.interrupt() 方法后仍然会继续执行！ 这时就需要用到上面 Thread 提供的第二个关于中断的方法 isInterrupted() 了。 2.public boolean isInterrupted()我们可以通过 isInterrupted() 知道调用线程是否被中断，以此来作为线程是否运行的判断标志。 isInterrupted() 在刚创建时默认为 false 不用多说；线程有许多方法可以响应中断（比如 Thread.sleep()，Thread.wait()），这些方法在收到中断请求、抛出 InterruptedException 之前，JVM 会先把该线程的中断标志位复位，这时调用 isInterrupted 将会返回 false；线程结束后，线程的中断标志位也会复位为 false。 举个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 线程中断练习 * Created by zhangshixin on 17/2/25. * http://blog.csdn.net/u011240877 */public class ThreadInterruptTest &#123; /** * 调用 Thread.sleep() 方法的线程，线程如果在 sleep 时被中断，会抛出 InterruptedException * 我们在代码中进行捕获，并且查看 JVM 是否将中断标志位重置 */ static class SleepThread extends Thread&#123; public SleepThread(String s) &#123; setName(s); &#125; @Override public void run() &#123; while (!isInterrupted())&#123; try &#123; Thread.sleep(500); System.out.println(Thread.currentThread().getName() + System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println("SleepRunner 在 sleep 时被中断了，此时中断标志位为：" + isInterrupted()); &#125; &#125; &#125; &#125; /** * 希望通过这个线程了解：线程运行结束后，中断标志位会重置 */ static class BusyThread extends Thread&#123; public BusyThread(String s) &#123; setName(s); &#125; @Override public void run() &#123; while (!isInterrupted())&#123; System.out.println(Thread.currentThread().getName() + System.currentTimeMillis()); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; SleepThread sleepThread = new SleepThread("SleepRunner："); BusyThread busyThread = new BusyThread("BusyRunner："); //新创建的线程 中断标志为 false System.out.println("SleepThread 新创建时的中断标志位：" + sleepThread.isInterrupted()); Thread.sleep(2000); //启动两个线程 sleepThread.start(); busyThread.start(); //让它们运行一秒 Thread.sleep(1000); //分别中断两个线程 sleepThread.interrupt(); busyThread.interrupt(); //查看线程的中断标志位 Thread.sleep(2000); System.out.println("由于中断标志位变为 true 导致运行结束的线程，中断标志位为: " + busyThread.isInterrupted()); Thread.sleep(1000); &#125;&#125; 上述代码中 两个线程都使用 isInterrupted 作为循环执行任务的条件，其中 SleepThread 方法调用了 Thread.sleep，这个方法的会响应中断，抛出异常。 运行结果如下： 可以看到： 线程中，在抛出 InterruptedException 前 JVM 的确会重置中断标志位为 false 这将导致以 isInterrupted 方法作为循环执行任务的线程无法正确中断 3.public static boolean interrupted()Thread.interrupted() 方法是一个静态方法，它会返回调用线程（而不是被调用线程）的中断标志位，返回后重置中断标志位。 因此 Thread.interrupted() 第二次调用永远返回 false。 源码：123public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125; 总结这篇文章总结了 线程的基本概念和关键方法，还有一些不建议使用的方法没有介绍，是因为它们有很多副作用，比如 suspend() 方法在调用后虽然线程会进入休眠状态，却不会释放资源，很容易引发死锁问题；同样，stop() 方法终结一个线程时无法保证这个线程有机会释放资源，也会导致一些不确定问题。 我们可以通过下面的图片整体分析线程的生命周期和主要方法：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android MVP模式]]></title>
      <url>%2F2017%2F02%2F04%2Fandroid-mvp%2F</url>
      <content type="text"><![CDATA[MVP 这种模式出现已经很久了，在网上有些关于 MVP 开源代码2014年就有了。近期由于面试都有问这方面的问题，所以来了解一下。网上关于 MVP 的资料其实也不少，通常都要把 MVP 和 MVC 做一下比较，MVC通常一般都会应用，这篇文章就来学习下MVP模式。 一、什么是MVP？随着UI创建技术的功能日益增强，UI层也履行着越来越多的职责。为了更好地细分视图(View)与模型(Model)的功能，让View专注于处理数据的可视化以及与用户的交互，同时让Model只关系数据的处理，基于MVC概念的MVP(Model-View-Presenter)模式应运而生。MVP 是 Model、Presenter、View 的缩写，三个部分的关系如下图所示。 在 Android 项目中，负责界面展示的模块（所有的 Activitiy 、Fragment以及 View 的子类）都可以划分到 View 这个层次，所有的业务逻辑处理（请求网络数据、数据库读取等）可以划分到 Model 这个层次，为了使得 View 和 Model 之间松耦合，用 Presenter 帮助解耦。所以可以猜测，在具体实现中 Presenter 类肯定要持有 View 和 Model 的引用。现在来说一下，上图中三个箭头的意思。流程是这样子的，从左到右看，比如我们刚进入一个 Activity，那么这个 Activity 做为 View 层，肯定需要通知 Presenter 加载数据，而Presenter会继续调用Model层加载数据，等Model加载完毕后，回调给 Presenter，Presenter 持有View引用，再通知View更新界面。 MVP模式的三个角色的作用： Presenter-中介主演沟通View和Model的桥梁，他从Model获取数据后返回给View层，是的View层和Model层之间没有耦合，从而奖业务逻辑从View层抽离。 Model-房主Model主要提供数据的存取、检索、操纵功能，Presenter需要通过Model层存储、获取数据，Model层就想是一个仓库。 View-用户负责绘制UI元素、与用户进行交互(在Android中体现为Activity)。View通常是指Activity、Fragment或者某个View控件。它含有一个Presenter成员变量，同时它需要实现一个逻辑接口，奖View上的操作转交割Presenter进行实现，最后Presenter调用View逻辑接口将结果返回给View元素。 View interface需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试; 为什么使用MVP模式在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由Presenter处理）.另外，回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明了什么？说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。 MVP与MVC的异同MVC模式与MVP模式都作为用来分离UI层与业务层的一种开发模式被应用了很多年。在我们选择一种开发模式时，首先需要了解一下这种模式的利弊：无论MVC或是MVP模式都不可避免地存在一个弊端： 额外的代码复杂度及学习成本。这就导致了这两种开发模式也许并不是很小型应用。但比起他们的优点，这点弊端基本可以忽略了： (1)降低耦合度 (2)模块职责划分明显 (3)利于测试驱动开发 (4)代码复用 (5)隐藏数据 (6)代码灵活性 MVP模式： View不直接与Model交互，而是通过与Presenter交互来与Model间接交互 Presenter与View的交互是通过接口来进行的，更有利于添加单元测试 通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑 MVC模式： View可以与Model直接交互 Controller是基于行为的，并且可以被多个View共享 可以负责决定显示哪个View 二、MVP的效果现在我们来实现这样一个Android上的Demo(如图)：可以从EditText读取用户信息并存取，也可以根据ID来从后台读出用户信息并显示。 页面布局很简单，就不介绍了。下面根据MVP原则来进行编码：先来看看java文件的目录结构： 可以发现，Presenter与Model、View都是通过接口来进行交互的，既降低耦合也方便进行单元测试。 (1)首先我们需要一个UserBean，用来保存用户信息 1234567891011121314public class UserBean &#123; private String mFirstName ; private String mLastName ; public UserBean (String firstName, String lastName) &#123; this.mFirstName = firstName; this.mLastName = lastName; &#125; public String getFirstName() &#123; return mFirstName ; &#125; public String getLastName() &#123; return mLastName ; &#125;&#125; (2)再来看看View接口：根据需求可知，View可以对ID、FirstName、LastName这三个EditText进行读操作，对FirstName和LastName进行写操作，由此定义IUserView接口： 1234567public interface IUserView &#123; int getID(); String getFristName(); String getLastName(); void setFirstName (String firstName); void setLastName (String lastName); &#125; (3)Model接口：同样，Model也需要对这三个字段进行读写操作，并存储在某个载体内(这不是我们所关心的，可以存在内存、文件、数据库或者远程服务器，但对于Presenter及View无影响),定义IUserModel接口： 1234567public interface IUserModel &#123; void setID (int id); void setFirstName (String firstName); void setLastName (String lastName); int getID(); UserBean load (int id);//通过id读取user信息,返回一个UserBean &#125; (4)Presenter:至此，Presenter就能通过接口与View及Model进行交互了： 123456789101112131415161718192021public class UserPresenter &#123; private IUserView mUserView ; private IUserModel mUserModel ; public UserPresenter (IUserView view) &#123; mUserView = view; mUserModel = new UserModel (); &#125; public void saveUser( int id , String firstName , String lastName) &#123; mUserModel .setID (id ); mUserModel .setFirstName (firstName ); mUserModel .setLastName (lastName ); &#125; public void loadUser( int id ) &#123; UserBean user = mUserModel .load (id ); mUserrView .setFirstName (user .getFirstName ());//通过调用IUserView的方法来更新显示 mUserView .setLastName (user .getLastName ()); &#125; &#125; (5)UserActivity:UserActivity实现了IUserView及View.OnClickListener接口，同时有一个UserPresenter成员变量： 123456public class UserActivity extends Activity implements OnClickListener, IUserView &#123; private EditText mFirstNameEditText , mLastNameEditText , mIdEditText ; private Button mSaveButton , mLoadButton ; private UserPresenter mUserPresenter ; 重写了OnClick方法：123456789101112131415@Override public void onClick(View v) &#123; // TODO Auto-generated method stub switch ( v. getId()) &#123; case R .id .saveButton : mUserPresenter .saveUser (getID (), getFristName (), getLastName ()); break ; case R .id .loadButton : mUserPresenter .loadUser (getID ()); break ; default : break ; &#125; &#125; 可以看到，View只负责处理与用户进行交互，并把数据相关的逻辑操作都扔给了Presenter去做。而Presenter调用Model处理完数据之后，再通过IUserView更新View显示的信息。 三、MVP的Android伪代码实现 首先需要一个Presenter，作为View和Model的中间人 然后你还需要一个View以及ViewImpl接口 最后你还需要Model一个ModelImpl接口 四、不必纠结是MVC还是MVP MVC和MVP的最终目的就是要数据和UI分离，互相不影响。那么如何能不必纠结而做到呢？？你听说过面向对象吗？听过再听听我的理解~ 面向对象封装、多态，继承。老师好像也都是这么教的，那么到底说明是多态封装继承呢？ 封装封装就是将用户不想看到的东西封装起来，可以用到面向对象中的 Private属性，将用户不想看到的内容写在这里面。比如收音机上的播放功能，用户不用知道收益及如何播放，它只需要知道摁下这个键能播放即可。 多态多态就是一个对象的多种表现形态，主要表现为：行为多态和状态多态。行为多态就好比一个父亲有多个孩子，每个孩子都不一样，但是都是同一个父亲；状态多态就好比每个孩子在一天中有好多个状态变现，有吃饭，学习，睡觉。 继承？不！我想说的是对象！我的一个朋友告诉我继承其实是对面向对象的最大误解。继承我们可以理解成一个对象他有多个小对象组成；比如人这个对象是由手脚，脑袋…等其它小对象组成。因此继承我们可以不去记住，我们只要对每个对象有深刻的认识即可把对象描述清楚！ 那么MVC、MVP与面向对象有什么关系呢？？ 首先MVC和MVP都是要求数据和UI之间互不影响，那么面向对象不就是吗！？ 面向对象View?对象也就是我们说的用户也就是MC或者MVP中View，用户需要什么我们就展示给其什么，不需要的我们将其封装起来提供一个方法给你调用即可，这是不是和MVC或者MVP中很像！ 面向对象Model?同时面向对象也是需要将对象的行为细分，比如人可以跑，可以游泳…这是不是和MVC中的Model一样，需要处理用户不同的操作。 面向对象Controller?最后面向对象也是需要一个状态去控制的，比如人的大脑。通过大脑去协调手和脚的平衡。 五、内存泄露问题由上可见，Presenter中持有View接口对象，这个接口对象实际为MainActivity.this，Modle中也同时拥有Presenter对象实例，当MainActivity要销毁时，Presenter中有Modle在获取数据，那么问题来了，这个Activity还能正常销毁吗？ 答案是不能！ 当Modle在获取数据时，不做处理，它就一直持有Presenter对象，而Presenter对象又持有Activity对象，这条GC链不剪断，Activity就无法被完整回收。换句话说：Presenter不销毁，Activity就无法正常被回收。 解决MVP的内存泄露 Presenter在Activity的onDestroy方法回调时执行资源释放操作，或者在Presenter引用View对象时使用更加容易回收的软引用，弱应用。比如示例代码：Activity123456@Override public void onDestroy() &#123; super.onDestroy(); mPresenter.destroy(); mPresenter = null; &#125; Presenter1234567public void destroy() &#123; view = null; if(modle != null) &#123; modle.cancleTasks(); modle = null; &#125;&#125; Modle123public void cancleTasks() &#123; // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api&#125; 个人总结 因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！ 六、总结最后重新梳理一下 MVP 的编写方式。 1、 根据项目需求，写一个 XXView 接口。然后让对应的 Activity/Fragment 实现这个接口。View 层基本搞定！ 2、编写 Model 层，主要就是网络数据请求了或者其他什么耗时操作，实现方式尽情发挥你的想象，但是最后一定需要用 Presenter 层定义的接口，回调给 Presenter 通知 View 层 更新数据。 3、编写 Presenter 层，Presenter 层需要持有 View 层和 Model层的引用，并且实现 Presenter 层定义的回调接口。在回调接口中调用 View 层的代码 进行界面更新，最重要的是，有一个调用通过Model层的方法，在此方法中，调用 Model 层请求数据。 4、回到View 层的Activity ，调用 Presenter 层获取数据。到此完成。 因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！备注：为了遵守面向接口编程的原则，做了一下接口的抽取。如Presenter 中 实现了 JokePresenter 接口，Model 层中实现了 JokeModel 接口。好了，如果在阅读中，发现了有错误的地方，还望指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Wi-Fi 直连]]></title>
      <url>%2F2017%2F02%2F02%2Fandroid-wifi%2F</url>
      <content type="text"><![CDATA[Android Wi-Fi 直连Wi-Fi直连是Android 4.0(API level 14)或更高的版本的才加入的新功能，使用Wi-Fi直连相关的API可以发现并连接支持Wi-Fi直连的设备，连接之后设备之间可以通信，传输的距离比蓝牙的传输距离要远很多 API 概述 Wi-Fi直连的方法类WifiP2pManager提供了一些方法来使用Wi-Fi直连的相关的接口来发现连接设备 方法 描述 initialize() 在Wi-Fi框架中注册，必须在其他方法之前调用 connect() 和另外的直连设备连接 cancelConnect() 取消正在连接的动作 requestConnectInfo() 请求已经连接的信息 createGroup() 创建直连的设备组 removeGroup() 删除当前的设置组 requestGroupInfo() 请求当前组的信息 discoverPeers() 初始化搜索 requestPeers() 请求已经发现的设备的列表 Wi-Fi直连的监听类WifiP2pManager中也提供了很多的监听接口，计时的通知当前的 activity相关的搜索和连接的结果 接口 相关的操作 WifiP2pManager.ActionListener 相关的操作：connect(), cancelConnect(), createGroup(), removeGroup(), and discoverPeers() WifiP2pManager.ChannelListener 相关的操作：initialize() WifiP2pManager.ConnectionInfoListener 相关的操作：requestConnectInfo() WifiP2pManager.GroupInfoListener 相关的操作：requestGroupInfo() WifiP2pManager.PeerListListener 相关的操作：requestPeers() Wi-Fi直连的Intent Intent 描述 WIFI_P2P_CONNECTION_CHANGED_ACTION 当设备的Wi-Fi的连接状态发生变化时触发 WIFI_P2P_PEERS_CHANGED_ACTION 在调用discoverPeers()时触发，可以调用requestPeers()方法更新设备列表 WIFI_P2P_STATE_CHANGED_ACTION Wi-Fi直连的状态发生变化时触发 WIFI_P2P_THIS_DEVICE_CHANGED_ACTION Wi-Fi直连的设备的详细信息发生变化时触发 创建Wi-Fi直连的应用 初始化设置首先要保证设置支持Wi-Fi直连相关的协议，如果支持，我们就可以获得WifiP2pManager的实例，创建并注册相关的广播，使用相关的api在AndroidManifest中必须声明相关的权限,Wi-Fi直连是在api level 14及更高的版本才能使用，还要声明android:minSdkVersion=&quot;14&quot; 123456&lt;uses-sdk android:minSdkVersion=&quot;14&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 初始化WifiP2pManager的实例，并注册相关的广播，监听Wi-Fi直连的状态 1234567891011121314151617181920212223242526272829303132333435private WifiP2pManager mManager;private Channel mChannel;private IntentFilter directFilter;private WiFiDirectReceiver directReceiver ;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mManager = (WifiP2pManager)this.getSystemService(Context.WIFI_P2P_SERVICE); mChannel = mManager.initialize(this, this.getMainLooper(), null); directReceiver = new WiFiDirectReceiver(mManager, mChannel, this); directFilter = new IntentFilter(); directFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION); directFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION); directFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION); directFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);&#125;//注册广播监听@Overrideprotected void onResume() &#123; super.onResume(); this.registerReceiver(directReceiver, directFilter);&#125;//取消注册@Overrideprotected void onPause() &#123; super.onPause(); this.unregisterReceiver(directReceiver);&#125; 广播接受 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class WiFiDirectReceiver extends BroadcastReceiver&#123; private WifiP2pManager mManager; private Channel mChannel; private MainActivity mActivity; private PeerListListener mListener; private WifiP2pConfig mConfig = new WifiP2pConfig(); public WiFiDirectReceiver()&#123;&#125; public WiFiDirectReceiver(WifiP2pManager manager,Channel channel,MainActivity activity)&#123; this.mManager = manager; this.mChannel = channel; this.mActivity = activity; &#125; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); Log.e("tag", "===============wifi direct action: "+action); if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION))&#123; int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1); if(state == WifiP2pManager.WIFI_P2P_STATE_ENABLED)&#123; //打开 &#125;else if(state == WifiP2pManager.WIFI_P2P_STATE_DISABLED)&#123; //关闭 &#125; &#125;else if(action.equals(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION))&#123; &#125;else if(action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION))&#123; &#125;else if(action.equals(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION))&#123; &#125; &#125;&#125;``` - 发现设备在调用之后initialize()方法之后，会触发`WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION`的广播，在BroadcastReceiver中，如果WifiP2pManager.WIFI_P2P_STATE_ENABLED的状态已经打开，在BroadcastReceiver调用discoverPeers方法,如果发现设备.会回调onSuccess方法 ``` javamManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() &#123;@Override public void onSuccess() &#123; Log.e("tag", "===================discovery success"); &#125; @Override public void onFailure(int reason) &#123; Log.e("tag", "===================discovery failed"); &#125;&#125;); 如果发现设备，系统会触发WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION这个广播，在这个广播中可以调用requestPeers方法可以列出所有的设备 1234567891011if(null != mManager)&#123; mManager.requestPeers(mChannel, new WifiP2pManager.PeerListListener() &#123; @Override public void onPeersAvailable(WifiP2pDeviceList peers) &#123; Log.e("tag", "==================peers list size: "+peers.getDeviceList().size()); for(WifiP2pDevice device: peers.getDeviceList())&#123; Log.e("tag", "==================device addr: "+device.deviceName+" name: "+device.deviceName); &#125; &#125; &#125;);&#125; 连接设备对于已经发现的设备我们可以调用connect()方法连接，需要初始化WifiP2pConfig,并设置config的deviceAddress 123456789101112private WifiP2pConfig mConfig = new WifiP2pConfig(); mConfig.deviceAddress = device.deviceAddress;mManager.connect(mChannel, mConfig, new WifiP2pManager.ActionListener() &#123; @Override public void onSuccess() &#123; Log.e("tag", "==============connnect success"); &#125; @Override public void onFailure(int reason) &#123; Log.e("tag", "=================connect failed"); &#125;&#125;); 连接成功会回调onSuccess方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 存储方式以及路径API]]></title>
      <url>%2F2017%2F01%2F31%2Fandroid-save-method%2F</url>
      <content type="text"><![CDATA[首先说一句,平时说的存储分成了内部存储和外部存储。注意内部存储又叫做机身内存，而且内存又包含了两个部分RAM(运行时内存,这个和运行速度有关系，是手机运行时存储数据和指令的地方)、ROM(这个才算是真正存储东西的内部存储范围，是应用配置和其他数据的地方);而外部存储就很明确了,用户的外部挂载存储设备,如SD卡,手机的内部存储卡。 来介绍几个概念: 一、内存全称内部存储,英文名(InternalStorage)。当我们在打开DDMS下的File Explorer面板的时候，/data目录就是所谓的内部存储 (ROM )。但是注意，当手机没有root的时候不能打开此文件夹。当打开data文件夹的时候，目录结构如下: 这里一般都是关注两个最重要的文件夹: app文件夹里存放着我们所有安装的app的apk文件，并且当我们调试一个app的时候，可以看到控制台输出的内容，有一项是uploading …..就是上传我们的apk到这个文件夹，上传成功之后才开始安装。这里写图片描述 第二个文件夹是data,也就是我们常说的/data/data目录(存储包私有数据)。此目录下将每一个APP的存储内容按照包名分类存放好。比如: data/data/包名/shared_prefs 存放该APP内的SP信息 data/data/包名/databases 存放该APP的数据库信息 data/data/包名/files 将APP的文件信息存放在files文件夹 data/data/包名/cache 存放的是APP的缓存信息 多扯一句,下面的代码就会在files文件夹先创建一个hello_file文件并写入了数据:12345String FILENAME = "hello_file";String string = "hello world!";FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_APPEND|Context.MODE_WORLD_READABLE);fos.write(string.getBytes());fos.close(); 二、外存/storage/sdcard/Android/data目录或者说/storage/emulated/0/Android/data包目录属于外部存储。比如我们的内部存储卡。注意,Google官方建议开发者将App的数据存储在私有目录即/storage/emulated/0/Android/data包下，这样卸载App时数据会随之被系统清除，不会造成数据残留。 除了/data之外的存储目录 /mnt:这个目录专门用来当作挂载点(MountPoint)。通俗点说,/mnt就是来挂载外部存储设备的(如sdcard),我们的sdcard将会被手机系统视作一个文件夹,这个文件夹将会被系统嵌入到收集系统的mnt目录 /dev包:Linux系统的常规文件夹。 /system包:系统配置的文件夹，比如Android系统框架（framework）、底层类库（lib）、字体（font）等。 1、下面说一下路径API和对以上的文件的操作:context.getFilesDir().getAbsolutePath()context.getFilesDir().getPath() 上面的两个API都是得到应用程序私有目录下的文件路径:/data/data/包名/files 2、context.getCacheDir().getPath()取得应用程序的缓存文件在内部存储上的存储路径/data/data/包名/cache 3、context.getExternalCacheDir().getAbsolutePath()和context.getExternalCacheDir().getCanonicalPath()取得应用程序的缓存文件在外部存储上的存储路径/storage/sdcard/Android/data/包名/cache 4、context.getObbDir().getAbsolutePath()取得外部存储obb目录的根路径/storage/sdcard/Android/obb/包名 5、Environment.getExternalStorageState()得到外部存储卡(sdcard)的存储状态mounted 6、Environment.getExternalStorageDirectory().getAbsolutePath()得到外部存储的整个根路径/storage/sdcard 7、Environment.getDownloadCacheDirectory().getAbsolutePath()得到外部存储的下载文件的缓存路径/cache 8、Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getAbsolutePath()得到外部存储的图片的根路径/storage/sdcard/Pictures 9、Environment.getRootDirectory().getAbsolutePath()/system 10、Environment.getDataDirectory().getAbsolutePath() /data 最后总结一下: 内部数据：/data/data/包名/XXX 外部私有数据：/storage/emulated/0/Android/data/包名/XXX 外部公有数据：/storage/emulated/0/包名/XXX 当用应用管理来清除数据的时候: 清除缓存：将外部私有数据下的cache包（/storage/emulated/0/Android/data/包名/cache）清除，将内部数据下的cache包下的内容（/data/data/包名/cache/XXX）清除 。 清楚数据：将外部私有数据包（/storage/emulated/0/Android/data/包名）清除，将内部数据下的所有内容（/data/data/包名/XXX）清除；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 权限机制]]></title>
      <url>%2F2017%2F01%2F31%2Fandroid-permissions%2F</url>
      <content type="text"><![CDATA[一、概要Android M已经发布一段时间了，市面上很多应用都已经适配Android M。权限机制，作为Android M的一大特性，受到了很多开发者的关注。本文主要分享了以下几个知识点的内容，1、Android权限机制关键知识点；2、QQ音乐对于权限的适配经验；3、近段时间以来遇到的一些Android权限方面的问题。OK，下面进入主题。 二、Android权限机制已经了解过基本知识的，建议直接跳到第三点（QQ音乐的权限适配经验）。 Android6.0以前，Android的权限机制比较简单，开发者在AndroidManifest文件中声明需要的权限，APP安装时，系统提示用户APP将获取的权限，需要用户同意授权才能继续安装，从此APP便永久的获得了授权。然而，同期的iOS对于权限的处理会更加灵活，权限的授予并不是在安装时，而是在APP运行时，用户可以根据自身的需要，决定是否授予APP某一权限，同时，用户也可以很方便回收授予的权限。显然，动态权限管理的机制，对于用户的隐私保护是更加适用的，Android过于简单的权限机制也受到了不少人的吐槽。终于，Android6.0也发布了动态权限的机制。 开始适配和如何兼容APP要适配Android6.0非常简单，只需要将targetSdkVersion和compileSdkVersion都升级到23及以上，同时加入权限检查申请等代码逻辑即可。这里很多人会有一些疑惑，如果针对旧版本的APP在Android6.0机型上运行或者针对Android6.0适配了的APP在Android6.0以下机型上运行，会有什么表现呢？是如何兼容的呢？ 1、首先，旧版本APP（targetSdkVersion低于23），因为没有适配权限的申请相关逻辑，在Android6.0以上机型运行的时候，仍然采用安装时授权的方案。 2、适配了Android6.0的APP，在低版本Android系统上运行的时候，仍然采用安装时授权的方案，但是开发者需要注意的是，权限申请的代码逻辑只应该在Android6.0及以上的机型被执行。 危险权限与普通权限一开始，听到要加入权限判断和申请代码逻辑的程序员内心可能是崩溃的：正常的一个有一定规模的APP，很容易就七七八八的声明了很多权限，如果每个权限都申请岂不是非常麻烦？ 好歹，Google还算比较明智，并不是所有的权限都需要运行时申请才能使用。Google对每个权限的隐私危害性进行了评估。将权限分为了两大类：普通权限和危险权限。举个例子，控制手机震动的权限对于用户并没有什么危害，只要开发者声明了这个权限，安装后就可以一直被授权，也不能被回收，但是，像读取sd卡数据这类权限，很显然就是危险权限了，APP必须向用户申请这个权限。 Google还是很体贴我们开发者的，为了进一步减少开发的工作量和申请权限对用户的骚扰，对危险权限根据各自的属性进行了分组。举个例子，读sd卡和写sd卡，这两个权限通常都是成对声明和使用的，因此，它们被分为一组，而且，只要我们获取了这个权限组里面的任意一个权限，就可以获取整个权限组的权限。Google对于危险权限的定义和分组见下图。 权限相关API说明首先，在动态权限申请的流程中，开发者主要关注流程和API如下： 1、检查权限是否授予。Activity.javapublic int checkSelfPermission(permission) 2、申请权限。Activity.javapublic final void requestPermissions( new String[permission1,permission2,...], requestCode) 这个时候，会弹出系统授权弹窗（授权弹窗是不支持自定义的，原因理所当然）。 3、权限回调。用户在系统弹窗里面选择后，结果会通过Activity的onRequestPermissionsResult方法回调APP。123public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; //继续执行逻辑或者提示权限获取失败&#125; 4、权限说明。用户如果选择了拒绝，下一次在需要声明该权限的时候，Google建议APP开发者给予用户更多的说明，因此提供了下面这个API,这个方法返回值在使用过程中会发现有点纠结（具体解析见下面代码块说明）。1234567public boolean shouldShowRequestPermissionRationale(permission)&#123; 1、APP没有申请这个权限的话，返回false 2、用户拒绝时，勾选了不再提示的话，返回false 3、用户拒绝，但是没有勾选不再提示的话，返回true 因此如果想在第一次就给用户提示，需要记录权限是否申请过，没有申请过的话，强制弹窗提示，而不能根据这个方法的返回值来。&#125; 三、QQ音乐的权限适配经验1、不同权限，申请的时机不同QQ音乐作为一个比较复杂的流媒体应用，也需要不少权限，但是究竟在什么时候来申请这些权限就成了适配6.0时首当其冲问题。针对这个问题，我们也对需要的权限进行了思考，大致认为申请权限需要分为两个时机。 用户触发：这个很好理解，有些和特性相关的权限，比如说听歌识曲的录音权限、自建歌单封面拍照权限等，这类权限平时APP运行时并不需要，那么我们选择在用户触发或者进入该功能的时候，进行授权受阻逻辑。 应用启动时：我们在梳理的时候发现，有些权限（读取设备信息，读写sd卡等）并不是由用户或者特性触发的，而是网络免流，登录安全，日志系统这些底层逻辑无时不刻触发的。对于这些权限，就比较纠结了。不过回过头来看，这些权限通常是开发者或者APP不能妥协的权限，因为如果用户不授权的话，将会影响整个APP的功能和数据。所以，我们选择比较暴力的方式，在应用启动的时候，就受阻。这也是Google建议的一种方式。 但是需要注意的是，一开始就申请授权也不要冷冰冰地直接拉起系统弹窗授权，建议先用APP自己的弹窗向用户礼貌地说明为什么需要这几个权限，比如，读取不到设备信息无法联通免流，无法保证登录安全，读取不到SD卡无法播放歌曲等，避免太生硬引起用户的反感。特别是，因为本地化翻译的原因，Google对于权限的弹窗说明很不local，例如我们申请读取设备信息的权限时，系统的弹窗是“电话权限”，这里很容易引起用户的误解，所以，合理的引导和解释是必不可少的。 2、应用启动授权，需要一个壳刚刚已经说到了，很多隐形的权限和特性无关。那么，如果我们直接启动APP，用户又还没有授权的情况下，很多初始化逻辑很容易就因为没有权限crash了，即使没有crash，后面也可能会有或多或少其他的问题。因此，我们需要在这些权限完全授予前，禁止这些逻辑的执行。 做过启动相关的同学都知道，拦截一个APP正常的启动后面再恢复，是很复杂的一件事情，往往我们需要一个外壳来把业务逻辑的内壳隔绝开。就QQ音乐而言，我们很容易的就想到了dex加载的壳，需求也很类似，dex加载也需要优先于业务来做。顺着这个思路，很自然地，我们就选择了在dex的壳里面做权限的受阻逻辑，而且也很快很好的达到了预期的效果。相信现在大部分APP都是分dex的了，因此建议按照这个方式来做，可以节省很多的工作量。 四、Android权限机制“乱象”这里要说的乱象，其实是和Android严重的碎片化有一定的关系。随着国产ROM越来越个性，很多ROM在尝试建立自己的权限机制，有些甚至基于Android5.x就开放了原生的或者开发了自己的权限机制。而面对这些情况，我们往往能做的非常有限，举几个例子。 1、读取运动数据权限开发QQ音乐跑步电台的过程中发现，在某国产ROM的一些机型上会提示“应用读取运动数据权限”的系统弹窗。可是，反复查阅相关API发现，我们使用的计步相关的Sensor并不需要申请什么权限。可如果用户选择了拒绝，即使APP注册了Sensor，也收不到系统的回调。后来联系该厂商的相关人员后，给出的答复是，第三方APP无法检查和申请这个权限，这个权限本身也属于该厂商ROM自己的权限机制。 类似的案例还有一个，就是在某厂商的手机管家，会一直提示QQ音乐尝试读取应用程序列表。其实，我们并没有读取应用程序列表，只是调用了PackageManager相关的一些API，就是触发这个告警。 对于这类问题，我们怀疑，第三方ROM是在运行时检测到了APP调用了相关的API后，进行权限阻断。这里开发同学需要注意的是，被阻断的API不一定会导致crash，但是可能导致我们获取不到正确的返回值或者收不到系统的一些消息回调。 2、无法添加快捷方式本来&lt;uses-permission android:name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot;/&gt;声明后，我们就可以在桌面上创建快捷方式了，而且这个权限也不是危险权限。可是某些国产ROM，对于APP添加快捷方式限制的比较严，必须要用户在设置里面手动允许添加快捷方式后，APP才能最终成功的添加。这种情况，APP也不能知道是否能添加快捷方式，只能默默的添加失败了。不过好在这里受影响并不是主快捷方式，而且某些功能的快捷方式入口。 3、消失的桌面歌词，悬浮窗权限QQ音乐桌面歌词采用了向WindowManager里面添加View的方式实现。可是很多国产ROM很早就具备了悬浮窗权限。一开始，我们将type改为LayoutParams.TYPE_TOAST同时声明&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;这个普通权限，躲避了大多数系统的问题。可是，2016年底，随着某ROM系统的升级，这一招也没用了，大批用户反馈爆发。 我们继续尝试检测悬浮窗权限，发现checkPermission（&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;）返回的结果永远是true，因此这条路也走不通。 最终，经过各种查阅，发现这个悬浮窗权限并不在Android6.0标准的权限机制内，而是AppOpsManager里面已经被隐藏了的一个开关位，对应于第24个开关。需要注意的是，AppOpsManager这个类很早就有了，但是很多ROM隐藏了checkOp的方法，好在最后发现通过反射仍旧可以调用这个方法检测权限是否打开。 AppOpsManager manager = (AppOpsManager) context.getSystemService("appops"); try { Object object = invokeMethod(manager, "checkOp", op, Binder.getCallingUid(), getPackageName(context)); return AppOpsManager.MODE_ALLOWED == (Integer) object; } catch (Exception e) { MLog.e(TAG, "CheckPermission " + e.toString()); } 不过，要打开悬浮窗权限，不同ROM的路径还不一样，有的是在设置里面，有的是在系统自带的管家里面，最后我们只能根据不同的ROM，给予用户不同的引导，终于将反馈量降了下去。 转载自Android权限机制与适配经验]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 响应式编程的应用]]></title>
      <url>%2F2017%2F01%2F30%2Fandroid-responsive-code%2F</url>
      <content type="text"><![CDATA[响应式编程简介 响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。 响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们更改电子表（变化的传播）中的一些数值时，我们需要更新整个表格或者我们的机器人碰到墙时会转弯（响应事件）。 今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。 响应式编程的具体实现-RxJava基本概念RxJava的四种角色 Observable Observer Subscriber Subject Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。 热Observable和冷Observable从发射物的角度来看，有两种不同的Observable:热的和冷的。一个”热”的Observable典型的只要一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。 Observable创建符 Observable.create() 12345Observable.create(new Observable.OnSubscribe&lt;Object&gt;()&#123; @Override public void call(Subscriber&lt;? super Object&gt; subscriber&#123; &#125;&#125;); Observable.from()from() 创建符可以从一个列表/数组来创建Observable,并一个接一个的从列表/数组中发射出来每一个对象，或者也可以从Java Future 类来创建Observable，并发射Future对象的 .get() 方法返回的结果值。传入 Future 作为参数时，我们可以指定一个超时的值。Observable将等待来自 Future 的结果；如果在超时之前仍然没有结果返回，Observable将会触发 onError() 方法通知观察者有错误发生了。 123456789101112131415161718192021List&lt;Integer&gt; items = new ArrayList&lt;Integer&gt;();items.add(1);items.add(10);items.add(100);items.add(200);Observable&lt;Integer&gt; observableString = Observable.from(items);Subscription subscriptionPrint = observableString.subscribe(new Observer&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("Observable completed"); &#125; @Override public void onError(Throwable e) &#123; System.out.println("Oh,no! Something wrong happened！"); &#125; @Override public void onNext(Integer item) &#123; System.out.println("Item is " + item); &#125;&#125;); Observable.just()just() 方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们。 just() 方法也可以接受列表或数组，就像 from() 方法，但是它不会迭代列表发射每个值,它将会发射整个列表。通常，当我们想发射一组已经定义好的值时会用到它。但是如果我们的函数不是时变性的，我们可以用just来创建一个更有组织性和可测性的代码库。 1234567891011121314151617Observable&lt;String&gt; observableString = Observable.just(helloWorld());Subscription subscriptionPrint = observableString.subscribe(newObserver&lt;String&gt;() &#123; @Override public void onCompleted() &#123; System.out.println("Observable completed"); &#125; @Override public void onError(Throwable e) &#123; System.out.println("Oh,no! Something wrong happened!"); &#125; @Override public void onNext(String message) &#123; System.out.println(message); &#125;&#125;); helloWorld() 方法比较简单，像这样： 123private String helloWorld()&#123; return "Hello World";&#125; SubjectSubject 既可以是 Observable，也可以是 Observer。RxJava 提供四种不同的 Subject : PublishSubject BehaviorSubjectBehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。 BehaviorSubject&lt;Integer&gt; behaviorSubject = BehaviorSubject.create(1); 在这个短例子中，我们创建了一个能发射整形(Integer)的BehaviorSubject。由于每当Observes订阅它时就会发射最新的数据，所以它需要一个初始值。 ReplaySubjectReplaySubject 会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发: ReplaySubject&lt;Integer&gt; replaySubject = ReplaySubject.create(); AsyncSubject当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。 AsyncSubject&lt;Integer&gt; asyncSubject = AsyncSubject.create(); 直接创建 Observable在我们的第一个列子里，我们将检索安装的应用列表并填充RecycleView的item来展示它们。我们也设想一个下拉刷新的功能和一个进度条来告知用户当前任务正在执行。 首先，我们创建Observable。我们需要一个函数来检索安装的应用程序列表并把它提供给我们的观察者。我们一个接一个的发射这些应用程序数据，将它们分组到一个单独的列表中，以此来展示响应式方法的灵活性。 123456789101112131415161718192021222324private Observable&lt;AppInfo&gt; getApps()&#123; return Observable.create(subscriber -&gt; &#123; List&lt;AppInfoRich&gt; apps = new ArrayList&lt;AppInfoRich&gt;(); final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null); mainIntent.addCategory(Intent.CATEGORY_LAUNCHER); List&lt;ResolveInfo&gt; infos = getActivity().queryIntentActivities(mainIntent, 0); for(ResolveInfo info : infos)&#123; apps.add(new AppInfoRich(getActivity(),info)); &#125; for (AppInfoRich appInfo:apps) &#123; Bitmap icon = Utils.drawableToBitmap(appInfo.getIcon()); String name = appInfo.getName(); String iconPath = mFilesDir + "/" + name; Utils.storeBitmap(App.instance, icon,name); if (subscriber.isUnsubscribed())&#123; return; &#125; subscriber.onNext(new AppInfo(name, iconPath, appInfo.getLastUpdateTime())); &#125; if (!subscriber.isUnsubscribed())&#123; subscriber.onCompleted(); &#125; &#125;);&#125; AppInfo为App信息的实体类，包括上次更新时间、图标、名字三个属性，此处省略。 需要重点注意的是在发射新的数据或者完成序列之前要检测观察者的订阅情况。这样的话代码会更高效，因为如果没有观察者等待时我们就不生成没有必要的数据项。 接下来，我们来定义下拉刷新的方法：1234567891011121314151617181920private void refreshTheList() &#123; getApps().toSortedList() .subscribe(new Observer&lt;List&lt;AppInfo&gt;&gt;() &#123; @Override public void onCompleted() &#123; Toast.makeText(getActivity(), "Here is the list!", Toast.LENGTH_LONG).show(); &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(getActivity(), "Something went wrong!", Toast.LENGTH_SHORT).show(); mSwipeRefreshLayout.setRefreshing(false); &#125; @Override public void onNext(List&lt;AppInfo&gt; appInfos) &#123; mRecyclerView.setVisibility(View.VISIBLE); mAdapter.addApplications(appInfos); mSwipeRefreshLayout.setRefreshing(false); &#125; &#125;);&#125; 从列表创建 Observable在这个例子中，我们将引入 from() 函数。使用这个特殊的“创建”函数，我们可以从一个列表中创建一个Observable。Observable将发射出列表中的每一个元素，我们可以通过订阅它们来对这些发出的元素做出响应。1234567891011121314151617181920private void loadList(List&lt;AppInfo&gt; apps) &#123; mRecyclerView.setVisibility(View.VISIBLE); Observable.from(apps).subscribe(new Observer&lt;AppInfo&gt;() &#123; @Override public void onCompleted() &#123; mSwipeRefreshLayout.setRefreshing(false); Toast.makeText(getActivity(), "Here is the list!", Toast.LENGTH_LONG).show(); &#125; @Override public void onError(Throwable e) &#123; Toast.makeText(getActivity(), "Something went wrong!", Toast.LENGTH_SHORT).show(); mSwipeRefreshLayout.setRefreshing(false); &#125; @Override public void onNext(AppInfo appInfo) &#123; mAddedApps.add(appInfo); mAdapter.addApplication(mAddedApps.size() - 1, appInfo); &#125; &#125;);&#125; 和第一个例子一个主要的不同是我们在 onCompleted() 函数中停掉进度条是因为我们一个一个的发射元素；第一个例子中的Observable发射的是整个list,因此在 onNext() 函数中停掉进度条的做法是安全的。 具有特殊功能的创建符 just()你可以将一个函数作为参数传给 just() 方法，你将会得到一个已存在代码的原始Observable版本。在一个新的响应式架构的基础上迁移已存在的代码，这个方法可能是一个有用的开始点。 repeat()假如你想对一个Observable重复发射三次数据 :123Observable.just(appOne,appTwo,appThree) .repeat(3) .subscribe(); 我们在 just() 创建Observable后追加了 repeat(3) ，它将会创建9个元素的序列，每一个都单独发射。 defer()有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。看下面的 getInt() 函数：12345678910private Observable&lt;Integer&gt; getInt()&#123; return Observable.create(subscriber -&gt; &#123; if(subscriber.isUnsubscribed())&#123; return; &#125; App.L.debug("GETINT"); subscriber.onNext(42); subscriber.onCompleted(); &#125;);&#125; 这比较简单，并且它没有做太多事情，但是它正好为我们服务。现在，我们可以创建一个新的Observable并且应用 defer() : Observable&lt;Integer&gt; deferred = Observable.defer(this::getInt); 这次， deferred 存在，但是 getInt() create() 方法还没有调用 : logcat日志也没有“GETINT”打印出来 :123deferred.subscribe(number -&gt; &#123; App.L.debug(String.valueOf(number));&#125;); 但是一旦我们订阅了， create() 方法就会被调用并且我们也可以在logcat日志中打印出两个值：GETINT 和 42。 range()从一个指定的数字X开始发射N个数字。range() 函数用两个数字作为参数：第一个是起始点，第二个是我们想发射数字的个数。 interval()interval() 函数在你需要创建一个轮询程序时非常好用。interval() 函数的两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。 timer()如果你需要一个一段时间之后才发射的Observable，你可以使用 timer()。 过滤Observables过滤序列RxJava让我们使用 filter() 方法来过滤我们观测序列中不想要的值。 我们从发出的每个元素中过滤掉开头字母不是C的 : 123456.filter(new Func1&lt;AppInfo,Boolean&gt;()&#123; @Override public Boolean call(AppInfo appInfo)&#123; return appInfo.getName().startsWith("C"); &#125;&#125;) 我们传一个新的 Func1 对象给 filter() 函数，即只有一个参数的函数。 Func1 有一个 AppInfo 对象来作为它的参数类型并且返回 Boolean 对象。只要条件符合 filter() 函数就会返回 true 。此时，值会发射出去并且所有的观察者都会接收到。 filter() 函数最常用的用法之一时过滤 null 对象： 123456.filter(new Func1&lt;AppInfo,Boolean&gt;()&#123; @Override public Boolean call(AppInfo appInfo)&#123; return appInfo != null; &#125;&#125;) 它帮我们免去了在 onNext() 函数调用中再去检测 null 值，让我们把注意力集中在应用业务逻辑上。 获取我们需要的数据当我们不需要整个序列时，而是只想取开头或结尾的几个元素，我们可以用 take() 或 takeLast() 。 take()take() 函数用整数N来作为一个参数，从原始的序列中发射前N个元素，然后完成： 123Observable.from(apps) .take(3) .subscribe(...); takeLast()如果我们想要最后N个元素，我们只需使用 takeLast() 函数： 123Observable.from(apps) .takeLast(3) .subscribe(...); 有且仅有一次 distinct()就像 takeLast() 一样， distinct() 作用于一个完整的序列，然后得到重复的过滤项，它需要记录每一个发射的值。如果你在处理一大堆序列或者大的数据记得关注内存使用情况。 12345Observable&lt;AppInfo&gt; fullOfDuplicates = Observable.from(apps) .take(3) .repeat(3);fullOfDuplicates.distinct() .subscribe(...); ditinctUntilChanged()如果在一个可观测序列发射一个不同于之前的一个新值时让我们得到通知这时候该怎么做？ditinctUntilChanged() 过滤函数能做到这一点。它能轻易的忽略掉所有的重复并且只发射出新的值。 First and lastfirst() 方法和 last() 方法很容易弄明白。它们从Observable中只发射第一个元素或者最后一个元素。这两个都可以传 Func1 作为参数。与 first() 和 last() 相似的变量有： firstOrDefault() 和 lastOrDefault() 。这两个函数当可观测序列完成时不再发射任何值时用得上。在这种场景下，如果Observable不再发射任何值时我们可以指定发射一个默认的值。 Skip and SkipLastskip() 和 skipLast() 函数与 take() 和 takeLast() 相对应。它们用整数N作参数，从本质上来说，它们不让Observable发射前N个或者后N个值。 ElementAt如果我们只想要可观测序列发射的第五个元素该怎么办？ elementAt() 函数仅从一个序列中发射第n个元素然后就完成了。如果我们想查找第五个元素但是可观测序列只有三个元素可供发射时该怎么办？我们可以使用 elementAtOrDefault() 。 Sampling在Observable后面加一个 sample() ，我们将创建一个新的可观测序列，它将在一个指定的时间间隔里由Observable发射最近一次的数值：123Observable&lt;Integer&gt; sensor = [...]sensor.sample(30,TimeUnit.SECONDS) .subscribe(...); 如果我们想让它定时发射第一个元素而不是最近的一个元素，我们可以使用 throttleFirst() 。 Timeout我们可以使用 timeout() 函数来监听源可观测序列,就是在我们设定的时间间隔内如果没有得到一个值则发射一个错误。我们可以认为 timeout() 为一个Observable的限时的副本。如果在指定的时间间隔内Observable不发射值的话，它监听的原始的Observable时就会触发 onError() 函数。123Subscription subscription = getCurrentTemperature() .timeout(2,TimeUnit.SECONDS) .subscribe(...); Debouncedebounce() 函数过滤掉由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。 下图展示了多久从Observable发射一次新的数据， debounce() 函数开启一个内部定时器，如果在这个时间间隔内没有新的据发射，则新的Observable发射出最后一个数据： 变换Observables*map家族RxJava提供了几个mapping函数： map() , flatMap() , concatMap() , flatMapIterable() 以及 switchMap() .所有这些函数都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。 MapRxJava的 map 函数接收一个指定的 Func 对象然后将它应用到每一个由Observable发射的值上。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Observable.from(apps) .map(new Func1&lt;AppInfo,AppInfo&gt;()&#123; @Override public Appinfo call(AppInfo appInfo)&#123; String currentName = appInfo.getName(); String lowerCaseName = currentName.toLowerCase(); appInfo.setName(lowerCaseName); return appInfo; &#125; &#125;) .subscribe(...);``` 正如你看到的，像往常一样创建我们发射的Observable之后，我们追加一个 map 调用，我们创建一个简单的函数来更新 AppInfo对象并提供一个名字小写的新版本给观察者。- FlatMap 在复杂的场景中，我们有一个这样的Observable：它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的 flatMap() 函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。 ![20170227148818631525343.png](http://ohtrrgyyd.bkt.clouddn.com/20170227148818631525343.png) 当我们在处理可能有大量的Observables时，重要是记住任何一个Observables发生错误的情况， flatMap() 将会触发它自己的 onError() 函数并放弃整个链。重要的一点提示是关于合并部分：它允许交叉。正如上图所示，这意味着 flatMap() 不能够保证在最终生成的Observable中源Observables确切的发射顺序。- ConcatMap RxJava的 concatMap() 函数解决了 flatMap() 的交叉问题，提供了一种能够把发射的值连续在一起的铺平函数，而不是合并它们，如下图所示： ![2017022714881863516790.png](http://ohtrrgyyd.bkt.clouddn.com/2017022714881863516790.png)- FlatMapIterable 作为*map家族的一员， flatMapInterable() 和 flatMap() 很像。仅有的本质不同是它将源数据两两结成对并生成Iterable，而不是原始数据项和生成的Observables。- SwitchMap switchMap() 和 flatMap() 很像，除了一点：每当源Observable发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的Observable，并开始监视当前发射的这一个。- Scan RxJava的 scan() 函数可以看做是一个累积函数。 scan() 函数对原始Observable发射的每一项数据都应用一个函数，计算出函数的结果值，并将该值填充回可观测序列，等待和下一次发射的数据一起使用。作为一个通用的例子，给出一个累加器：``` javaObservable.just(1,2,3,4,5) .scan((sum,item) -&gt; sum + item) .subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onCompleted() &#123; Log.d("RXJAVA", "Sequence completed."); &#125; @Override public void onError(Throwable e) &#123; Log.e("RXJAVA", "Something went south!"); &#125; @Override public void onNext(Integer item) &#123; Log.d("RXJAVA", "item is: " + item); &#125; &#125;); 我们得到的结果是： RXJAVA: item is: 1RXJAVA: item is: 3RXJAVA: item is: 6RXJAVA: item is: 10RXJAVA: item is: 15RXJAVA: Sequence completed. GroupByRxJava提供了一个有用的函数从列表中按照指定的规则： groupBy() 来分组元素。下图中的例子展示了 groupBy() 如何将发射的值根据他们的形状来进行分组。 这个函数将源Observable变换成一个发射Observables的新的Observable。它们中的每一个新的Observable都发射一组指定的数据。 为了创建一个分组了的已安装应用列表，我们在 loadList() 函数中引入了一个新的元素：12345678Observable&lt;GroupedObservable&lt;String,AppInfo&gt;&gt; groupedItems = Observable.from(apps) .groupBy(new Func1&lt;AppInfo,String&gt;()&#123; @Override public String call(AppInfo appInfo)&#123; SimpleDateFormat formatter = new SimpleDateFormat("MM/yyyy"); return formatter.format(new Date(appInfo.getLastUpdateTime())); &#125; &#125;); 现在我们创建了一个新的Observable， groupedItems ，它将会发射一个带有 GroupedObservable 的序列。 GroupedObservable 是一个特殊的Observable，它源自一个分组的key。在这个例子中，key就是 String ，代表的意思是 Month/Year 格式化的最近更新日期。 BufferRxJava中的 buffer() 函数将源Observable变换一个新的Observable，这个新的Observable每次发射一组列表值而不是一个一个发射。 buffer() 函数有几种变体。其中有一个是允许你指定一个 skip 值：此后每 skip 项数据，用count项数据填充缓冲区。另一个是buffer() 带一个 timespan 的参数，会创建一个每隔timespan时间段就会发射一个列表的Observable。 WindowRxJava的 window() 函数和 buffer() 很像，但是它发射的是Observable而不是列表。 正如 buffer() 一样, window() 也有一个 skip 变体。 Castcast() 函数是 map() 操作符的特殊版本。它将源Observable中的每一项数据都转换为新的类型，把它变成了不同的 Class 。 组合ObservablesMerge在”异步的世界“中经常会创建这样的场景，我们有多个来源但是又只想有一个结果：多输入，单输出。RxJava的 merge() 方法将帮助你把两个甚至更多的Observables合并到他们发射的数据项里。下图给出了把两个序列合并在一个最终发射的Observable。 正如你看到的那样，发射的数据被交叉合并到一个Observable里面。注意如果你同步的合并Observable，它们将连接在一起并且不会交叉。12Observable&lt;AppInfo&gt; mergedObserbable = Observable.merge(observableApps,observableReversedApps);mergedObserbable.subscribe(...); 注意错误时的toast消息，你可以认为每个Observable抛出的错误都将会打断合并。如果你需要避免这种情况，RxJava提供了 mergeDelayError() ，它能从一个Observable中继续发射数据即便是其中有一个抛出了错误。当所有的Observables都完成时， mergeDelayError() 将会发射 onError()。 ZIP在一种新的可能场景中处理多个数据来源时会带来：多从个Observables接收数据，处理它们，然后将它们合并成一个新的可观测序列来使用。RxJava有一个特殊的方法可以完成： zip() 合并两个或者多个Observables发射出的数据项，根据指定的函数Func* 变换它们，并发射一个新值。下图展示了 zip() 方法如何处理发射的“numbers”和“letters”然后将它们合并一个新的数据项： 123Observable.zip(observableApp, tictoc, (AppInfo appInfo, Long time) -&gt; updateTitle(appInfo, time)) .observeOn(AndroidSchedulers.mainThread()) .subscribe(...); zip() 函数有三个参数：两个Observables和一个 Func2 。 Join前面两个方法， zip() 和 merge() 方法作用在发射数据的范畴内，在决定如何操作值之前有些场景我们需要考虑时间的。RxJava的 join() 函数基于时间窗口将两个Observables发射的数据结合在一起。 为了正确的理解上一张图，我们解释下 join() 需要的参数： 第二个Observable和源Observable结合。 Func1 参数：在指定的由时间窗口定义时间间隔内，源Observable发射的数据和从第二个Observable发射的数据相互配合返回的Observable。 Func1 参数：在指定的由时间窗口定义时间间隔内，第二个Observable发射的数据和从源Observable发射的数据相互配合返回的Observable。 Func2 参数：定义已发射的数据如何与新发射的数据项相结合。 combineLatestRxJava的 combineLatest() 函数有点像 zip() 函数的特殊形式。正如我们已经学习的， zip() 作用于最近未打包的两个Observables。相反， combineLatest() 作用于最近发射的数据项：如果 Observable1 发射了A并且 Observable2 发射了B和C， combineLatest() 将会分组处理AB和AC，如下图所示： And,Then和When在将来还有一些 zip() 满足不了的场景。如复杂的架构，或者是仅仅为了个人爱好，你可以使用And/Then/When解决方案。它们在RxJava的joins包下，使用Pattern和Plan作为中介，将发射的数据集合并到一起。 Switch给出一个发射多个Observables序列的源Observable， switch() 订阅到源Observable然后开始发射由第一个发射的Observable发射的一样的数据。当源Observable发射一个新的Observable时， switch() 立即取消订阅前一个发射数据的Observable（因此打断了从它那里发射的数据流）然后订阅一个新的Observable，并开始发射它的数据。 StartWithRxJava的 startWith() 是 concat() 的对应部分。正如 concat() 向发射数据的Observable追加数据那样，在Observable开始发射他们的数据之前，startWith() 通过传递一个参数来先发射一个数据序列。 Schedulers-解决Android主线程问题Schedulers调度器以一种最简单的方式将多线程用在你的Apps的中。它们时RxJava重要的一部分并能很好地与Observables协同工作。它们无需处理实现、同步、线程、平台限制、平台变化而可以提供一种灵活的方式来创建并发程序。 RxJava提供了5种调度器： .io() .computation() .immediate() .newThread() .trampoline() Schedulers.io()这个调度器时用于I/O操作。它基于根据需要，增长或缩减来自适应的线程池。我们将使用它来修复我们之前看到的 StrictMode 违规做法。由于它专用于I/O操作，所以并不是RxJava的默认方法；正确的使用它是由开发者决定的。 重点需要注意的是线程池是无限制的，大量的I/O调度操作将创建许多个线程并占用内存。一如既往的是，我们需要在性能和简捷两者之间找到一个有效的平衡点。 Schedulers.computation()这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器： buffer() , debounce() , delay() , interval() , sample() , skip()。 Schedulers.immediate()这个调度器允许你立即在当前线程执行你指定的工作。它是 timeout() , timeInterval() ,以及 timestamp() 方法默认的调度器。 Schedulers.newThread()这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。 Schedulers.trampoline()当我们想在当前线程执行一个任务时，并不是立即，我们可以用 .trampoline() 将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是 repeat() 和 retry() 方法默认的调度器。 非阻塞I/O操作使用 Schedulers.io() 创建非阻塞的版本：12345public static void storeBitmap(Context context, Bitmap bitmap, String filename) &#123; Schedulers.io().createWorker().schedule(() -&gt; &#123; blockingStoreBitmap(context, bitmap, filename); &#125;);&#125; SubscribeOn and ObserveOn我们学到了如何在一个调度器上运行一个任务。但是我们如何利用它来和Observables一起工作呢？RxJava提供了 subscribeOn() 方法来用于每个Observable对象。 subscribeOn() 方法用 Scheduler 来作为参数并在这个Scheduler上执行Observable调用。 首先，我们需要一个新的 getApps() 方法来检索已安装的应用列表：123456789101112131415private Observable&lt;AppInfo&gt; getApps() &#123; return Observable.create(subscriber -&gt; &#123; List&lt;AppInfo&gt; apps = new ArrayList&lt;&gt;(); SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE); Type appInfoType = new TypeToken&lt;List&lt;AppInfo&gt;&gt;()&#123;&#125;.getType(); String serializedApps = sharedPref.getString("APPS", ""); if (!"".equals(serializedApps)) &#123; apps = new Gson().fromJson(serializedApps,appInfoType); &#125; for (AppInfo app : apps) &#123; subscriber.onNext(app); &#125; subscriber.onCompleted(); &#125;);&#125; 然后，我们所需要做的是指定 getApps() 需要在调度器上执行：12getApps().subscribeOn(Schedulers.io()) .subscribe(new Observer&lt;AppInfo&gt;() &#123; [...] 最后，我们只需在 loadList() 函数添加几行代码，那么每一项就都准备好了：12345getApps() .onBackpressureBuffer() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;AppInfo&gt;() &#123; [...] observeOn() 方法将会在指定的调度器上返回结果：如例子中的UI线程。 onBackpressureBuffer() 方法将告诉Observable发射的数据如果比观察者消费的数据要更快的话，它必须把它们存储在缓存中并提供一个合适的时间给它们。 处理耗时的任务一个与I/O无关的耗时的任务：12345getObservableApps(apps) .onBackpressureBuffer() .subscribeOn(Schedulers.computation()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;AppInfo&gt;() &#123; [...] 总结RxJava提供了一种以面向时序的方式考虑数据的机会：所有事情都是持续变化的，数据在更新，事件在触发，然后你就可以创建事件响应式的、灵活的、运行流畅的App。 转载自响应式编程在Android中的应用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 图片加载框架－Picasso的使用指南]]></title>
      <url>%2F2017%2F01%2F30%2Fandroid-picasso%2F</url>
      <content type="text"><![CDATA[前言Android 中有几个比较有名的图片加载框架，Universal ImageLoader、Picasso、Glide和Fresco。它们各有优点，以前一直用的是ImageLoader 做项目中的图片加载，由于作者宣布ImageLoader 不会在更新了，因此新的项目打算换一个图片加载框架－Picasso, Picasso 是Square 公司开源的Android 端的图片加载和缓存框架。Square 真是一家良心公司啊，为我们Android开发者贡献了很多优秀的开源项目有木有！像什么Rerefoit 、OkHttp、LeakCanary、Picasso等等都是非常火的开源项目。扯远了，回到正题，除了使用简单方便，Picasso还能自动帮我们做以下事情： 处理Adapter 中ImageView的回收和取消下载。 使用最小的内存 来做复杂的图片变换。比如高斯模糊，圆角、圆形等处理。 自动帮我们缓存图片。内存和磁盘缓存。以上只是列出了Picasso 比较核心的几点，其实它的优点远远不止这些，接下来就看一下如何使用Picasso。 使用一、添加依赖要使用Picasso,首先我们要添加版本依赖，去官网或者Github 看一下当前的最新版本(截止本文最新版本为2.5.2)，然后在build.gradle中添加依赖： compile &apos;com.squareup.picasso:picasso:2.5.2&apos; 二、加载显示图片将Picasso添加到项目之后，我们就可以用它来加载图片了，使用方法非常简单：123Picasso.with(this) .load("http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg") .into(mImageView); 只需要一行代码就完成了加载图片到显示的整个过程，链式调用，非常简洁，其实有三步，一次调用了三个方法： with(Context) 获取一个Picasso单例，参数是一个Context上下文 load(String) 调用load 方法加载图片 into (ImageView) 将图片显示在对应的View上，可以是ImageView，也可以是实现了Target j接口的自定义View。上面演示了加载一张网络图片，它还支持其它形式的图片加载，加载文件图片，加载本地资源图片，加载一个Uri 路径给的图片，提供了几个重载的方法： 1.load(Uri uri) 加载一个以Uri路径给的图片12Uri uri = Uri.parse(ANDROID_RESOURCE + context.getPackageName() + FOREWARD_SLASH + resourceId)Picasso.with(this).load(uri).into(mImageView); 2.load(File file) 加载File中的图片Picasso.with(this).load(file).into(mImageView); 3.load(int resourceId) 加载本地资源图片Picasso.with(this).load(R.mipmap.ic_launcher).into(mImageView); 提醒：上面介绍了load的几个重载方法，加载不同资源的图片，另外提醒注意一下load(String path)接受String 参数的这个方法，参数String 可以是一个网络图片url,也可以是file 路径、content资源 和Android Resource。看一下源码的注释。1234567891011121314151617181920212223242526&gt;/** * Start an image request using the specified path. This is a convenience method for calling * &#123;@link #load(Uri)&#125;. * &lt;p&gt; * This path may be a remote URL, file resource (prefixed with &#123;@code file:&#125;), content resource * (prefixed with &#123;@code content:&#125;), or android resource (prefixed with &#123;@code * android.resource:&#125;. * &lt;p&gt; * Passing &#123;@code null&#125; as a &#123;@code path&#125; will not trigger any request but will set a * placeholder, if one is specified. * * @see #load(Uri) * @see #load(File) * @see #load(int) * @throws IllegalArgumentException if &#123;@code path&#125; is empty or blank string. */ public RequestCreator load(String path) &#123; if (path == null) &#123; return new RequestCreator(this, null, 0); &#125; if (path.trim().length() == 0) &#123; throw new IllegalArgumentException("Path must not be empty."); &#125; return load(Uri.parse(path)); &#125;&gt; 要使用string 参数加载上面的几种资源，除了网络url,其它几种需要加上对应前缀，file文件路径前缀：file: , content 添加前缀：content: ,Android Resource 添加：android.resource: 三、placeholder&amp; error &amp; noPlaceholder &amp; noFade通过上面的第一步我们就可以通过Picasso 加载图片了，我们的项目中通常最常用的就是加载网络图片，但是由于网络环境的差异，有时侯加载网络图片的过程有点慢，这样界面上就会显示空ImageView什么也看不见，用户体验非常不好。其实以前用过ImageLoader的同学都知道，ImageLoader 是可以设置加载中显示默认图片的，Picasso当然也给我们提供了这个功能，这就是我们要说的placeholder(占位图)。 1.placeholderplaceholder提供一张在网络请求还没有完成时显示的图片，它必须是本地图片，代码如下：12345678910111213 Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .into(mImageView);``` 设置placeholder之后，在加载图片的时候，就可以显示设置的默认图了，提升用户体验。### 2.error和placeholder 的用法一样，error 提供一张在加载图片出错的情况下显示的默认图``` javaPicasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .into(mImageView); 3.noPlaceholder这个方法的意思就是：在调用into的时候明确告诉你没有占位图设置。根据这个方法签名的解释是阻止View被回收的时候Picasso清空target或者设置一个应用的占位图。需要注意的是placeholder和noPlaceholder 不能同时应用在同一个请求上，会抛异常。1234Picasso.with(this).load(URL) .noPlaceholder() .error(R.drawable.error_iamge) .into(mImageView); 4.noFade无论你是否设置了占位图，Picasso 从磁盘或者网络加载图片时，into 显示到ImageView 都会有一个简单的渐入过度效果，让你的UI视觉效果更柔顺丝滑一点，如果你不要这个渐入的效果（没有这么坑爹的需求吧！！！），就调用noFade方法。12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .noFade() .into(mImageView); 四、设置图片尺寸(Resize)、缩放(Scale)和裁剪(Crop)1.Resize(int w,int h)在项目中，为了带宽、内存使用和下载速度等考虑，服务端给我们的图片的size 应该和我们View 实际的size一样的，但是实际情况并非如此，服务端可能给我们一些奇怪的尺寸的图片，我们可以使用resize(int w,int hei) 来重新设置尺寸。12345678910Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resize(400,200) .into(mImageView);``` resize()方法接受的参数的单位是pixels,还有一个可以设置dp单位的方法，将你的尺寸写在dimens.xml文件中，然后用`resizeDimen(int targetWidthResId, int targetHeightResId)`方法 ``` xml&lt;dimen name="image_width"&gt;300dp&lt;/dimen&gt;&lt;dimen name="image_height"&gt;200dp&lt;/dimen&gt; 12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resizeDimen(R.dimen.image_width,R.dimen.image_height) .into(mImageView); 2.onlyScaleDown当调用了resize 方法重新设置图片尺寸的时候，调用onlyScaleDown 方法，只有当原始图片的尺寸大于我们指定的尺寸时，resize才起作用,如：12345678910111213141516171819Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resize(4000,2000) .onlyScaleDown() .into(mImageView);``` 只有当原来的图片尺寸大于4000 x 2000的时候，resize 才起作用。### 3.图片裁剪 centerCrop()这个属性应该不陌生吧！ImageView 的ScaleType 就有这个属性。当我们使用resize 来重新设置图片的尺寸的时候，你会发现有些图片拉伸或者扭曲了（使用ImageView的时候碰到过吧），我要避免这种情况，Picasso 同样给我们提供了一个方法，centerCrop，**充满ImageView 的边界，居中裁剪**。``` javaPicasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resize(400,200) .centerCrop() .into(mImageView); 4.centerInside上面的centerCrop是可能看不到全部图片的，如果你想让View将图片展示完全，可以用centerInside，但是如果图片尺寸小于View尺寸的话，是不能充满View边界的。123456Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .resize(400,200) .centerInside() .into(mImageView); 5.fitfit 是干什的呢？上面我们需要用resize()来指定我们需要的图片的尺寸，那就是说在程序中需要我们计算我们需要的尺寸（固定大小的除外），这样很麻烦，fit 方法就帮我们解决了这个问题。fit 它会自动测量我们的View的大小，然后内部调用reszie方法把图片裁剪到View的大小，这就帮我们做了计算size和调用resize 这2步。非常方便。代码如下：12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .fit() .into(mImageView); 使用fit 还是会出现拉伸扭曲的情况，因此最好配合前面的centerCrop使用，代码如下：123456Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .fit() .centerCrop() .into(mImageView); 看一下对比图:fit(会拉伸): fit &amp; centerCrop (不会拉伸): 注意：特别注意， fit 只对ImageView 有效 使用fit时，ImageView 宽和高不能为wrap_content,很好理解，因为它要测量宽高。 五、图片旋转Rotation()在图片显示到ImageView 之前，还可以对图片做一些旋转操作，调用rotate(int degree)方法12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .rotate(180) .into(mImageView); 这个方法它是以（0，0）点旋转，但是有些时候我们并不想以（0,0）点旋转，还提供了另外一个方法可以指定原点： rotate(float degrees, float pivotX, float pivotY) 以(pivotX, pivotY)为原点旋转 12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .rotate(180,200,100) .into(mImageView); 六、转换器TransformationTransformation 这就是Picasso的一个非常强大的功能了，它允许你在load图片 -&gt; into ImageView 中间这个过成对图片做一系列的变换。比如你要做图片高斯模糊、添加圆角、做度灰处理、圆形图片等等都可以通过Transformation来完成。 来看一个高斯模糊的例子： 1.首先定义一个转换器继承 Transformation1234567891011121314151617181920212223242526272829303132333435363738394041public static class BlurTransformation implements Transformation&#123; RenderScript rs; public BlurTransformation(Context context) &#123; super(); rs = RenderScript.create(context); &#125; @Override public Bitmap transform(Bitmap bitmap) &#123; // Create another bitmap that will hold the results of the filter. Bitmap blurredBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true); // Allocate memory for Renderscript to work with Allocation input = Allocation.createFromBitmap(rs, blurredBitmap, Allocation.MipmapControl.MIPMAP_FULL, Allocation.USAGE_SHARED); Allocation output = Allocation.createTyped(rs, input.getType()); // Load up an instance of the specific script that we want to use. ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); script.setInput(input); // Set the blur radius script.setRadius(25); // Start the ScriptIntrinisicBlur script.forEach(output); // Copy the output to the blurred bitmap output.copyTo(blurredBitmap); bitmap.recycle(); return blurredBitmap; &#125; @Override public String key() &#123; return "blur"; &#125; &#125; 2.加载图片的时候，在into 方法前面调用 transform方法 应用Transformation12345Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .transform(new BlurTransformation(this)) .into(mBlurImage); 看一下效果图： 上面为原图，下面为高斯模糊图是不是很强大，任何复杂的变换都可以通过Transformation 来做。还不止于此，还有更强大的功能。可以在一个请求上应用多个Transformation比如：我想先做个灰度处理然后在做一个高斯模糊图： 1.灰度的Transformation12345678910111213141516171819202122232425262728public static class GrayTransformation implements Transformation&#123; @Override public Bitmap transform(Bitmap source) &#123; int width, height; height = source.getHeight(); width = source.getWidth(); Bitmap bmpGrayscale = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565); Canvas c = new Canvas(bmpGrayscale); Paint paint = new Paint(); ColorMatrix cm = new ColorMatrix(); cm.setSaturation(0); ColorMatrixColorFilter f = new ColorMatrixColorFilter(cm); paint.setColorFilter(f); c.drawBitmap(source, 0, 0, paint); if(source!=null &amp;&amp; source!=bmpGrayscale)&#123; source.recycle(); &#125; return bmpGrayscale; &#125; @Override public String key() &#123; return "gray"; &#125; &#125; 2.如果是多个Transformation操作，有2种方式应用方式一：直接调用多次transform 方法，不会覆盖的。它只是保存到了一个List 里面12345678Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .fit() .centerCrop() .transform(new GrayTransformation())//度灰处理 .transform(new BlurTransformation(this))//高斯模糊 .into(mBlurImage); 需要注意调用的顺序方式二：接受一个List，将Transformation 放大list 里12345678910List&lt;Transformation&gt; transformations = new ArrayList&lt;&gt;();transformations.add(new GrayTransformation());transformations.add(new BlurTransformation(this));Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .fit() .centerCrop() .transform(transformations) .into(mBlurImage); 效果图： 如上图，第一张为灰度操作，第二张为 灰度＋高斯模糊另外发现了一个开源库，专门写了很多好玩的Transformation，有兴趣的可以看一下：picasso-transformations 七、请求优先级Picasso 为请求设置有优先级，有三种优先级，LOW、NORMAL、HIGH。默认情况下都是NORMAL，除了调用fetch 方法，fetch 方法的优先级是LOW。12345public enum Priority &#123; LOW, NORMAL, HIGH&#125; 可以通过priority方法设置请求的优先级，这会影响请求的执行顺序，但是这是不能保证的，它只会往高的优先级靠拢。代码如下：123456Picasso.with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .priority(Picasso.Priority.HIGH) // .priority(Picasso.Priority.LOW) .into(mImageView); 八、Tag管理请求Picasso 允许我们为一个请求设置tag来管理请求，看一下对应的几个方法：下面3个方法是Picasso这个类的： cancelTag(Object tag) 取消设置了给定tag的所有请求 pauseTag(Object tag) 暂停设置了给定tag 的所有请求 resumeTag(Object tag) resume 被暂停的给定tag的所有请求 还有一个方法是RequestCreator的: tag(Object tag) 为请求设置tag 几个方法的意思也很明确，就是我们可以暂停、resume、和取消请求，可以用在哪些场景呢？ 场景一： 比如一个照片流列表，当我们快速滑动列表浏览照片的时候，后台会一直发起请求加载照片的，这可能会导致卡顿，那么我们就可以为每个请求设置一个相同的Tag，在快速滑动的时候，调用pauseTag暂停请求，当滑动停止的时候，调用resumeTag恢复请求，这样的体验是不是就会更好一些呢。 Adapter中添加如下代码：12345Picasso.with(this).load(mData.get(position)) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .tag("PhotoTag") .into(holder.mImageView); Activity中为RecyclerView添加滑动监听：123456789101112mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; final Picasso picasso = Picasso.with(MainActivity.this); if (newState == SCROLL_STATE_IDLE) &#123; picasso.resumeTag("PhotoTag"); &#125; else &#123; picasso.pauseTag("PhotoTag"); &#125; &#125; &#125;); 场景二： 比如一个照片流列表界面，在弱网环境下，加载很慢，退出这个界面时可能会有很多请求没有完成，这个时候我们就可 以通过tag 来取消请求了。 九、同步／异步加载图片Picasso 加载图片也有同步／异步两种方式 1.get() 同步很简单，同步加载使用get() 方法，返回一个Bitmap 对象，代码如下：12345try &#123; Bitmap bitmap = Picasso.with(this).load(URL).get(); &#125; catch (IOException e) &#123; e.printStackTrace();&#125; 注意：使用同步方式加载，不能放在主线程来做。 2.异步的方式加载图片，fetch()一般直接加载图片通过into显示到ImageView 是异步的方式，除此之外，还提供了2个异步的方法： fetch() 异步方式加载图片 fetch(Callback callback) 异步方式加载图片并给一个回调接口。 1234567891011Picasso.with(this).load(URL).fetch(new Callback() &#123; @Override public void onSuccess() &#123; //加载成功 &#125; @Override public void onError() &#123; //加载失败 &#125;&#125;); 这里就要吐槽一下接口设计了，回调并没有返回Bitmap, 不知道作者是怎么考虑的，只是一个通知效果，知道请求失败还是成功。fetch 方法异步加载图片并没有返回Bitmap，这个方法在请求成功之后，将结果存到了缓存，包括磁盘和内存缓存。所以使用这种方式加载图片适用于这种场景：知道稍后会加载图片，使用fetch 先加载缓存，起到一个预加载的效果。 十、缓存（Disk 和 Memory）Picasso 有内存缓存(Memory)和磁盘缓存（ Disk）, 首先来看一下源码中对于缓存的介绍： LRU memory cache of 15% the available application RAM Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is onlyavailable on API 14+ or if you are using a standalone library that provides a disk cache on all API levels like OkHttp) Three download threads for disk and network access. 可以看出，内存缓存是使用的LRU 策略的缓存实现，它的大小是内存大小的15%,可以自定义它的大小，最后在扩展那一章节再讲，磁盘缓存是磁盘容量的2%但是不超过50M,不少于5M。处理一个请求的时候，按照这个顺讯检查：memory-&gt;disk-&gt;network 。先检查有木有内存缓存，如果命中，直接返回结果，否则检查磁盘缓存，命中则返回结果，没有命中则从网上获取。 默认情况下，Picasso 内存缓存和磁盘缓存都开启了的，也就是加载图片的时候，内存和磁盘都缓存了，但是有些时候，我们并不需要缓存，比如说：加载一张大图片的时候，如果再内存中保存一份，很容易造成OOM,这时候我们只希望有磁盘缓存，而不希望缓存到内存，因此就需要我们设置缓存策略了。Picasso 提供了这样的方法。 1.memoryPolicy 设置内存缓存策略就像上面所说的，有时候我们不希望有内存缓存，我们可以通过 memoryPolicy 来设置。MemoryPolicy是一个枚举，有两个值 NO_CACHE：表示处理请求的时候跳过检查内存缓存NO_STORE: 表示请求成功之后，不将最终的结果存到内存。 示例代码如下：12345with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE) //静止内存缓存 .into(mBlurImage); 2.networkPolicy 设置磁盘缓存策略和内存缓存一样，加载一张图片的时候，你也可以跳过磁盘缓存，和内存缓存策略的控制方式一样，磁盘缓存调用方法networkPolicy(NetworkPolicy policy, NetworkPolicy… additional) , NetworkPolicy是一个枚举类型，有三个值： NO_CACHE: 表示处理请求的时候跳过处理磁盘缓存 NO_STORE: 表示请求成功后，不将结果缓存到Disk,但是这个只对OkHttp有效。 OFFLINE: 这个就跟 上面两个不一样了，如果networkPolicy方法用的是这个参数，那么Picasso会强制这次请求从缓存中获取结果，不会发起网络请求，不管缓存中能否获取到结果。 使用示例：123456with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE)//跳过内存缓存 .networkPolicy(NetworkPolicy.NO_CACHE)//跳过磁盘缓存 .into(mBlurImage); 强制从缓存获取：12345with(this).load(URL) .placeholder(R.drawable.default_bg) .error(R.drawable.error_iamge) .networkPolicy(NetworkPolicy.OFFLINE)//强制从缓存获取结果 .into(mBlurImage); 十一、Debug 和日志1.缓存指示器上一节说了，Picasso 有内存缓存和磁盘缓存，先从内存获取，没有再去磁盘缓存获取，都有就从网络加载，网络加载是比较昂贵和耗时的。因此，作为一个开发者，我们往往需要加载的图片是从哪儿来的（内存、Disk还是网络），Picasso让我们很容易就实现了。只需要调用一个方法setIndicatorsEnabled(boolean)就可以了,它会在图片的左上角出现一个带色块的三角形标示，有3种颜色，绿色表示从内存加载、蓝色表示从磁盘加载、红色表示从网络加载。Picasso.with(this).setIndicatorsEnabled(true);//显示指示器效果图： 如上图所示，第一张图从网络获取，第二张从磁盘获取，第三张图从内存获取。看一下源码中定义指示器的颜色：123456789101112/** Describes where the image was loaded from. */public enum LoadedFrom &#123; MEMORY(Color.GREEN), DISK(Color.BLUE), NETWORK(Color.RED); final int debugColor; private LoadedFrom(int debugColor) &#123; this.debugColor = debugColor; &#125;&#125; 可以很清楚看出，对应三种颜色代表着图片的来源。 2.日志上面的指示器能够很好的帮助我们看出图片的来源，但是有时候我们需要更详细的信息，Picasso,可以打印一些日志，比如一些关键方法的执行时间等等，我们只需要调用setLoggingEnabled(true)方法，然后App在加载图片的过程中，我们就可以从logcat 看到一些关键的日志信息。Picasso.with(this).setLoggingEnabled(true);//开启日志打印 十二、Picasso 扩展到目前为止，Picasso的基本使用已经讲得差不多了，但是在实际项目中我们这可能还满足不了我们的需求，我们需要对它做一些自己的扩展，比如我们需要换缓存的位置、我们需要扩大缓存、自定义线程池、自定义下载器等等。这些都是可以的，接下来我们来看一下可以做哪些方面的扩展。 1.用Builder 自己构造一个Picasso Instance我们来回顾一下前面是怎么用Picasso加载图片的：123Picasso.with(this) .load("http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg") .into(mImageView); 总共3步： 用with方法获取一个Picasso 示例 用load方法加载图片 用into 放法显示图片 首先Picasso是一个单例模式，我们每一次获取的示例都是默认提供给我们的实例。但是也可以不用它给的Instance,我们直接用builder来构造一个Picasso:123456Picasso.Builder builder = new Picasso.Builder(this);//构造一个PicassoPicasso picasso = builder.build();//加载图片picasso.load(URL).into(mImageView); 这样我们就构造了一个局部的Picasso实例，当然了，我们直接用new 了一个builder，然后build()生成了一个Picasso。这跟默认的通过with方法获取的实例是一样的。那么现在我们就可以配置一些自定义的功能了。 2, 配置自定义下载器 downLoader如果我们不想用默认提供的Downloader,那么我们可以自定义一个下载器然后配置进去。举个例子： (1) 先自定义一个Downloader(只是举个例子，并没有实现):12345678910111213141516/** * Created by zhouwei on 17/2/26. */public class CustomDownloader implements Downloader &#123; @Override public Response load(Uri uri, int networkPolicy) throws IOException &#123; return null; &#125; @Override public void shutdown() &#123; &#125;&#125; (2) 然后通过builder配置：12345678910111213 //配置下载器builder.downloader(new CustomDownloader());//构造一个PicassoPicasso picasso = builder.build();``` 这样配置后，我们用build()生成的Picasso 实例来加载图片就会使用自定义的下载器来下载图片了。### 3.配置缓存前面说过，内存缓存是用的LRU Cahce ,大小是手机内存的15% ，如果你想缓存大小更大一点或者更小一点，可以自定义，然后配置。``` java//配置缓存LruCache cache = new LruCache(5 * 1024 * 1024);// 设置缓存大小builder.memoryCache(cache); 上面只是一个简单的举例，当然了你可以自定义，也可以使用LRUCache,改变大小，改变存储路径等等。 提示： 很遗憾，好像没有提供改变磁盘缓存的接口，那就只能用默认的了。 4.配置线程池Picasso 默认的线程池的核心线程数为3，如果你觉得不够用的话，可以配置自己需要的线程池，举个列子：123//配置线程池ExecutorService executorService = Executors.newFixedThreadPool(8);builder.executor(executorService); 5.配置全局的 Picasso Instance上面说的这些自定义配置项目都是应用在一个局部的Picasso instance 上的，我们不可能每一次使用都要重新配置一下，这样就太麻烦了。我们希望我们的这些自定义配置能在整个项目都应用上，并且只配置一次。其实Picasso 给我们提供了这样的方法。可以调用setSingletonInstance(Picasso picasso)就可以了，看一下这个方法的源码：12345678910111213/** * Set the global instance returned from &#123;@link #with&#125;. * &lt;p&gt; * This method must be called before any calls to &#123;@link #with&#125; and may only be called once. */public static void setSingletonInstance(Picasso picasso) &#123; synchronized (Picasso.class) &#123; if (singleton != null) &#123; throw new IllegalStateException("Singleton instance already exists."); &#125; singleton = picasso; &#125;&#125; 设置一个通过with方法返回的全局instance。我们只希望配置一次，所以，我们应该在Application 的onCreate方法中做全局配置就可以了。app一启动就配置好，然后直接和前面的使用方法一样，调用with方法获取Picasso instance 加载图片就OK了。 因此在Application 中添加如下代码：123456789101112131415161718192021@Overridepublic void onCreate() &#123; super.onCreate(); // 配置全局的Picasso instance Picasso.Builder builder = new Picasso.Builder(this); //配置下载器 builder.downloader(new CustomDownloader()); //配置缓存 LruCache cache = new LruCache(5*1024*1024);// 设置缓存大小 builder.memoryCache(cache); //配置线程池 ExecutorService executorService = Executors.newFixedThreadPool(8); builder.executor(executorService); //构造一个Picasso Picasso picasso = builder.build(); // 设置全局单列instance Picasso.setSingletonInstance(picasso);&#125; 然后应用这些自定义配置加载图片 Picasso.with(this).load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;).into(mImageView);用法和以前的一样，但是我们已经将我们的自定义配置应用上了。 结尾以上就是对Picasso 用法的全部总结，如有什么问题，欢迎留言指正。Picasso真的是一个强大的图片加载缓存库，API 简单好用，而且是链式调用的（这点我特别喜欢）。官方文档写的比较简单，很多用法都要看源码和注释才知道。希望本文能给才开始使用Picasso 的同学一点帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 界面性能调优]]></title>
      <url>%2F2017%2F01%2F27%2Fandroid-view-performance-optimizing%2F</url>
      <content type="text"><![CDATA[前言界面是 Android 应用中直接影响用户体验最关键的部分。如果代码实现得不好，界面容易发生卡顿且导致应用占用大量内存。又卡又慢的应用体验，会影响客户或用户对产品的信心和评价，所以不可忽视。 一、 Android渲染知识1 绘制原理Android系统要求每一帧都要在 16ms 内绘制完成，平滑的完成一帧意味着任何特殊的帧需要执行所有的渲染代码（包括 framework 发送给 GPU 和 CPU 绘制到缓冲区的命令）都要在 16ms 内完成，保持流畅的体验。这个速度允许系统在动画和输入事件的过程中以约 60 帧每秒(1秒 / 0.016帧每秒 = 62.5帧/秒)的平滑帧率来渲染。 如果你的应用没有在 16ms 内完成这一帧的绘制，假设你花了 24ms 来绘制这一帧，那么就会出现掉帧的情况。 系统准备将新的一帧绘制到屏幕上，但是这一帧并没有准备好，所有就不会有绘制操作，画面也就不会刷新。反馈到用户身上，就是用户盯着同一张图看了 32ms 而不是 16ms ，也就是说掉帧发生了。 2 掉帧掉帧是用户体验中一个非常核心的问题。丢弃了当前帧，并且之后不能够延续之前的帧率，这种不连续的间隔会容易会引起用户的注意，也就是我们常说的卡顿、不流畅。 引起掉帧的原因非常多，比如： 花了非常多时间重新绘制界面中的大部分东西，这样非常浪费CPU周期. 过度绘制严重，在绘制用户看不到的对象上花费了太多的时间. 有一大堆动画重复了一遍又一遍，消耗 CPU 、 GPU 资源 频繁的触发垃圾回收 3 为什么是60Fps？Android系统要求每一帧都要在 16ms 内绘制完成，那么1秒的帧率就是约 60 帧每秒（ 1秒 / 0.016帧每秒 = 62.5帧/秒 ），那为什么要以 60 Fps来作为 App 性能的衡量标准呢？这是因为人眼和大脑之间的协作无法感知到超过 60 Fps的画面更新。市面上绝大多数Android设备的屏幕刷新频率是 60 HZ。当然，超过 60 Fps 是没有意义的，人眼感知不到区别。24 Fps 是人眼能感知的连续线性的运动，所以是电影胶圈的常用帧率，因为这个帧率已经足够支撑大部分电影画面所要表达的内容，同时能最大限度地减少费用支出。但是，低于 30 Fps 是无法顺畅表现绚丽的画面内容的，此时就需要用到 60 Fps 来达到想要表达的效果。了解更多Fps知识详见「Wiki」。应用的界面性能目标就是保持 60 Fps，这意味着每一帧你只有 16 ms（1秒 / 60帧率）的时间来处理所有的任务。 4 垃圾回收垃圾回收器是一个在应用运行期间自动释放那些不再引用的内存的机制，常称 GC 。频繁的 GC 也是导致严重性能问题的罪魁祸首之一。前面提到，平滑的完成一帧意味着所有渲染代码都必须在 16ms 内完成。频繁的 GC 会严重限制一帧时间内的剩余时间，如果 GC 所做的工作超过了那些必须的工作，那么留给应用平滑的帧率的时间就越少。越接近 16ms ，在垃圾回收事件触发的时候，就越容易导致卡顿。注意，Android4.4 引进了新的 ART 虚拟机来取代 Dalvik 虚拟机。它们的机制大有不同，简单而言： Dalvik 虚拟机的 GC 是非常耗资源的，并且在正常的情况下一个硬件性能不错的Android设备也会很容易耗费掉 10 - 20 ms 的时间； ART 虚拟机的GC会动态提升垃圾回收的效率，在 ART 中的中断，通常在 2 - 3 ms 间。 比 Dalvik 虚拟机有很大的性能提升；ART 虚拟机相对于 Dalvik 虚拟机来说的垃圾回收来说有一个很大的性能提升，但 2 - 3 ms 的回收时间对于超过16ms帧率的界限也是足够的。因此，尽管垃圾回收在 Android 5.0 之后不再是耗资源的行为，但也是始终需要尽可能避免的，特别是在执行动画的情况下，可能会导致一些让用户明显感觉的丢帧。 想了解更多详细的 ART 和 Dalvik 虚拟机垃圾回收机制，可「戳我」和「我」进行深入了解。 5 UI 线程UI 线程是应用的主线程，很多的性能和卡顿问题是由于我们在主线程中做了大量的工作。所以，所有耗资源的操作，比如 IO 操作、网络操作、SQL 操作、列表刷新等，都应该用后台进程去实现，不能占用主线程，主线程是 UI 线程，是保持程序流畅的关键；在 Android 5.0 版本里，Android 框架层引入了 “ Render Thread ” ，用于向 GPU 发送实际渲染的操作。这个线程减轻了一些 UI 线程减少的操作。但是输入、滚动和动画仍然在 UI thread，因为 Thread 必须能够响应操作。 6 垂直同步垂直同步是 Android4.1 通过 Project Butter 在 UI 架构中引入的新技术，同期引入的还有 Triple Buffer 和 HWComposer 等技术，都是为提高 UI 的流畅性而生。举个例子，你拍了一张照片，然后旋转5度再拍另外一张照片，将两照片的中间剪开并拼接在一起，得到下图： 中间这部分有明显区别的部分，等价于设备刷新率和帧速率不一致的结果。一般而言， GPU 的帧速率应高于刷新率，才不会卡顿或掉帧。如果屏幕刷新率比帧速率还快，屏幕会在两帧中显示同一个画面，这种断断续续情况持续发生时，用户将会很明显地感觉到动画的卡顿或者掉帧，然后又恢复正常，我们常称之为闪屏、跳帧、延迟。应用应避免这些帧率下降的情况，以确保 GPU 能在屏幕刷新之前完成数据的获取及写入，保证动画流畅。 7 UI 绘制机制与栅格化绝大多数渲染操作都依赖两个硬件： CPU 、 GPU 。 CPU 负责 Measure 、 layout 、 Record 、 Execute 的计算操作， GPU 负责栅格化（ Rasterization ）操作。 非必需的视图组件会带来多余的 CPU 计算操作，还会占用多余的 GPU 资源。 栅格化（ Rasterization ）能将 Button 、 Shape 、 Path 、 Bitmap 等资源组件拆分到不同的像素上进行显示。这个操作很费时，所以引入了 GPU 来加快栅格化的操作。 CPU 负责把 UI 组件计算成多边形（ Polygons ），纹理（ Texture ），然后交给 GPU 进行栅格化渲染，再将处理结果传到屏幕上显示。 在 Android 里的那些资源组件的显示（比如 Bitmaps 、 Drawable ），都是一起打包到统一的纹理（ Texture ）当中，然后再传递到 GPU 里面。图片的显示，则是先经过 CPU 的计算加载到内存中，再传给 GPU 进行渲染。文字的显示，则是先经过 CPU 换算成纹理（ Texture ），再传给 GPU 进行渲染，返回到 CPU 绘制单个字符的时候，再重新引用经过 GPU 渲染的内容。动画的显示更加复杂，我们需要在 16 ms 内处理完所有 CPU 和 GPU 的计算、绘制、渲染等操作，才能获得应用的流畅体验。 二、To检测和解决1 检测维度根据业务的不同与所需要的测试粒度的不同，就会有不同的检测维度。目前我所在业务所需的界面性能检测维度如下： 界面过度绘制；（检测过度绘制） 渲染性能；（检测严格模式下的UI渲染性能呈现） 布局边界合理性；（检测元素显示的合理性） 还有专项测试中某些用户场景可能还包含着另外一些隐形的检测维度，比如： OpenGL 跟踪分析； GPU 视图更新合理性； Flash 硬件层更新合理性； 动画加 / 减速状态问题点检测； …… 2 调试工具检测和解决界面性能问题很大程度上依赖于你的应用程序架构，幸运的是，Andorid 提供了很多调试工具，知道并学会使用这些工具很重要，它们可以帮助我们调试和分析界面性能问题，以让应用拥有更好的性能体验。下面列举Android常见的界面性能调试工具： (1)Hierarchy View Hierarchy View 在Android SDK里自带，常用来查看界面的视图结构是否过于复杂，用于了解哪些视图过度绘制，又该如何进行改进。详见官方使用教程（需要翻墙）:「戳我」，官方介绍「戳我」。 (2)LintLint 是 ADT 自带的静态代码扫描工具，可以给 XML 布局文件和 项目代码中不合理的或存在风险的模块提出改善性建议。官方关于 Lint 的实际使用的提示，列举几点如下： 包含无用的分支，建议去除； 包含无用的父控件，建议去除； 警告该布局深度过深； 建议使用 compound drawables ； 建议使用 merge 标签； ……更多 Lint 的官方介绍「戳我」。 (3)Systrace Systrace 在Android DDMS 里自带，可以用来跟踪 graphics 、view 和 window 的信息，发现一些深层次的问题。很麻烦，限制大，实际调试中我基本用不到。官方介绍 「戳我」和 「我」。 (4)Track Track 在 Android DDMS里自带，是个很棒的用来跟踪构造视图的时候哪些方法费时，精确到每一个函数，无论是应用函数还是系统函数，我们可以很容易地看到掉帧的地方以及那一帧所有函数的调用情况，找出问题点进行优化。官方介绍 「戳我」。 (5)OverDraw 通过在 Android 设备的设置 APP 的开发者选项里打开 “ 调试 GPU 过度绘制 ” ，来查看应用所有界面及分支界面下的过度绘制情况，方便进行优化。官方介绍 「戳我」。 (6)GPU 呈现模式分析 通过在 Android 设备的设置 APP 的开发者选项里启动 “ GPU 呈现模式分析 ” ，可以得到最近 128 帧 每一帧渲染的时间，分析性能渲染的性能及性能瓶颈。官方介绍 「戳我」。 (7)StrictMode通过在 Android 设备的设置 APP 的开发者选项里启动 “ 严格模式 ” ，来查看应用哪些操作在主线程上执行时间过长。当一些操作违背了严格模式时屏幕的四周边界会闪烁红色，同时输出 StrictMode 的相关信息到 LOGCAT 日志中。 (8)Animator duration scale通过在 Android 设备的设置 APP 的开发者选项里打开 “ 窗口动画缩放 ” / “ 过渡动画缩放 ” / “ 动画程序时长缩放 ”，来加速或减慢动画的时间，以查看加速或减慢状态下的动画是否会有问题。 (9)Show hardware layer updates通过在 Android 设备的设置 APP 的开发者选项里启动 “ 显示硬件层更新 ”，当 Flash 硬件层在进行更新时会显示为绿色。使用这个工具可以让你查看在动画期间哪些不期望更新的布局有更新，方便你进行优化，以获得应用更好的性能。实例《 Optimizing Android Hardware Layers 》（需要翻墙）:「戳我」。 3 如何解决前面提到过我司的目前所需的测试维度如下： 界面过度绘制；（检测过度绘制） 渲染性能；（检测严格模式下的UI渲染性能呈现） 布局边界合理性；（检测元素显示的合理性） 故接下来将围绕这三两点，分别从概念、追踪、挖掘根源以及排查的工具来具体讲述如何解决，以及给开发的优化建议。 三、界面过度绘制（OverDraw）1 过度绘制概念过度绘制是一个术语，表示某些组件在屏幕上的一个像素点的绘制次数超过 1 次。 通俗来讲，绘制界面可以类比成一个涂鸦客涂鸦墙壁，涂鸦是一件工作量很大的事情，墙面的每个点在涂鸦过程中可能被涂了各种各样的颜色，但最终呈现的颜色却只可能是 1 种。这意味着我们花大力气涂鸦过程中那些非最终呈现的颜色对路人是不可见的，是一种对时间、精力和资源的浪费，存在很大的改善空间。绘制界面同理，花了太多的时间去绘制那些堆叠在下面的、用户看不到的东西，这样是在浪费CPU周期和渲染时间！ 官方例子，被用户激活的卡片在最上面,而那些没有激活的卡片在下面，在绘制用户看不到的对象上花费了太多的时间。 2 追踪过度绘制通过在 Android 设备的设置 APP 的开发者选项里打开 “ 调试 GPU 过度绘制 ” ，来查看应用所有界面及分支界面下的过度绘制情况，方便进行优化。 Android 会在屏幕上显示不同深浅的颜色来表示过度绘制： 没颜色：没有过度绘制，即一个像素点绘制了 1 次，显示应用本来的颜色； 蓝色：1倍过度绘制，即一个像素点绘制了 2 次； 绿色：2倍过度绘制，即一个像素点绘制了 3 次； 浅红色：3倍过度绘制，即一个像素点绘制了 4 次； 深红色：4倍过度绘制及以上，即一个像素点绘制了 5 次及以上。 设备的硬件性能是有限的，当过度绘制导致应用需要消耗更多资源（超过了可用资源）的时候性能就会降低，表现为卡顿、不流畅、ANR 等。为了最大限度地提高应用的性能和体验，就需要尽可能地减少过度绘制，即更多的蓝色色块而不是红色色块。 实际测试，常用以下两点来作为过度绘制的测试指标，将过度绘制控制在一个约定好的合理范围内： 应用所有界面以及分支界面均不存在超过4X过度绘制（深红色区域）； 应用所有界面以及分支界面下，3X过度绘制总面积（浅红色区域）不超过屏幕可视区域的1/4； 3 过度绘制的根源过度绘制很大程度上来自于视图相互重叠的问题，其次还有不必要的背景重叠。 官方例子，比如一个应用所有的View都有背景的话，就会看起来像第一张图中那样，而在去除这些不必要的背景之后（指的是Window的默认背景、Layout的背景、文字以及图片的可能存在的背景），效果就像第二张图那样，基本没有过度绘制的情况。 4 不合理的xml布局对绘制的影响当布局文件的节点树的深度越深，XML 中的标签和属性设置越多，对界面的显示有灾难性影响。 一个界面要显示出来，第一步会进行解析布局，在 requestLayout 之后还要进行一系列的 measure 、 layout 、 draw 操作，若布局文件嵌套过深、拥有的标签属性过于臃肿，每一步的执行时间都会受到影响，而界面的显示是进行完这些操作后才会显示的，所以每一步操作的时间增长，最终显示的时间就会越长。 5 源码相关有能力且有兴趣看源码的童鞋，过度绘制的源码位置在: /frameworks/base/libs/hwui/OpenGLRenderer.cpp ，有兴趣的可以去研究查看。123456789101112131415161718192021222324252627if (Properties::debugOverdraw &amp;&amp; getTargetFbo() == 0) &#123; const Rect* clip = &amp;mTilingClip; mRenderState.scissor().setEnabled(true); mRenderState.scissor().set(clip-&gt;left, mState.firstSnapshot()-&gt;getViewportHeight() - clip-&gt;bottom, clip-&gt;right - clip-&gt;left, clip-&gt;bottom - clip-&gt;top); // 1x overdraw mRenderState.stencil().enableDebugTest(2); drawColor(mCaches.getOverdrawColor(1), SkXfermode::kdata-urlOver_Mode); // 2x overdraw mRenderState.stencil().enableDebugTest(3); drawColor(mCaches.getOverdrawColor(2), SkXfermode::kdata-urlOver_Mode); // 3x overdraw mRenderState.stencil().enableDebugTest(4); drawColor(mCaches.getOverdrawColor(3), SkXfermode::kdata-urlOver_Mode); // 4x overdraw and higher mRenderState.stencil().enableDebugTest(4, true); drawColor(mCaches.getOverdrawColor(4), SkXfermode::kdata-urlOver_Mode); mRenderState.stencil().disable(); &#125;&#125; 四、 渲染性能（Rendering）1 渲染性能概念渲染性能往往是掉帧的罪魁祸首，这种问题很常见，让人头疼。好在 Android 给我们提供了一个强大的工具，帮助我们非常容易追踪性能渲染问题，看到究竟是什么导致你的应用出现卡顿、掉帧。 2 追踪渲染性能通过在 Android 设备的设置 APP 的开发者选项里打开 “ GPU 呈现模式分析 ” 选项，选择 ” 在屏幕上显示为条形图 “。 这个工具会在Android 设备的屏幕上实时显示当前界面的最近 128 帧 的 GPU 绘制图形数据，包括 StatusBar 、 NavBar 、 当前界面的 GPU 绘制图形柱状图数据。我们一般只需关心当前界面的 GPU 绘制图形数据即可。 界面上一共有 128 个小柱状图，代表的是当前界面最近的 128 帧 GPU 绘制图形数据。一个小柱状图代表的这一帧画面渲染的耗时，柱状图越高代表耗时越长。随着界面的刷新，柱状图信息也会实时滚动刷新。中间有一条绿线，代表 16 ms ，保持动画流畅的关键就在于让这些垂直的柱状条尽可能地保持在绿线下面,任何时候超过绿线,你就有可能丢失一帧的内容。 每一个柱状图都是由三种颜色构成：蓝、红、黄。 蓝色代表的是这一帧绘制 Display List 的时间。通俗来说，就是记录了需要花费多长时间在屏幕上更新视图。用代码语言来说，就是执行视图的 onDraw 方法，创建或更新每一个视图的 Display List 的时间。 红色代表的是这一帧 OpenGL 渲染 Display List 所需要的时间。通俗来说，就是记录了执行视图绘制的耗时。用代码语言来说，就是 Android 用 OpenGL ES 的 API 接口进行 2D 渲染 Display List 的时间。 黄色代表的是这一帧 CPU 等待 GPU 处理的时间。通俗来说，就是 CPU 等待 GPU 发出接到命令的回复的等待时间。用代码语言来说，就是这是一个阻塞调用。 实际测试，常用以下两点来作为渲染性能的测试指标，将渲染性能控制在一个约定好的合理范围内： 执行应用的所有功能及分支功能，操作过程中涉及的柱状条区域应至少 90 % 保持到绿线下面； 从用户体检的角度主观判断应用在 512 M 内存的 Android 设备下所有操作过程中的卡顿感是否能接受，不会感觉突兀怪异； 3 渲染性能差的根源当你看到蓝色的线较高的时候，可能是由于你的视图突然无效了需要重新绘制，或者是自定义的视图过于复杂耗时过长。 当你看到红色的线较高的时候，可能是由于你的视图重新提交了需要重新绘制导致的（比如屏幕从竖屏旋转成横屏后当前界面重新创建），或者是自定义的视图很复杂，绘制起来很麻烦，导致耗时过长。比如下面这种视图： 当你看到黄色的线较高的时候，那就意味着你给 GPU 太多的工作，太多的负责视图需要 OpenGL 命令去绘制和处理，导致 CPU 迟迟没等到 GPU 发出接到命令的回复。 4 检测说明这个工具能够很好地帮助你找到渲染相关的问题，帮助你找到卡顿的性能瓶颈，追踪究竟是什么导致被测应用出现卡顿、变慢的情况，以便在代码层面进行优化。甚至让负责产品设计的人去改善他的设计，以获得良好的用户体验。 检测渲染性能时，常伴随着开启“ 严格模式 ” 查看应用哪些情景在 UI 线程（主线程）上执行时间过长。 另外有些强大但可能少用的工具在测试性能渲染时辅助分析，比如： HierarchyViewer：这个工具常用来查看界面的视图结构是否过于复杂，用于了解哪些视图过度绘制，又该如何进行改进； Tracer for OpenGL：这个工具收集了所有UI界面发给GPU的绘制命令。常用于辅助开发人员 DEBUG 、定位一些 HierarchyViewer 工具定位不了的疑难渲染细节问题。 5 UI绘制机制的补充说明如上面所说，布局和 UI 组件等都会先经过 CPU 计算成 GPU 能够识别并绘制的多边形（ Polygons ），纹理（ Texture ），然后交给 GPU 进行栅格化渲染，再将处理结果传到屏幕上显示。 “ CPU 计算成 GPU 能够识别并绘制的对象 ” 这个操作是在 DisplayList 的帮助下完成的。DisplayList 拥有要交给 GPU 栅格化渲染到屏幕上的数据信息。 DisplayList 会在某个视图第一次需要渲染时创建。当该视图有类似位置被移动等变化而需要重新渲染这个视图的时候，则只需 GPU 额外执行一次渲染指令冰更新到屏幕上就够了。但如果视图中的绘制内容发生变化时（比如不可见了），那之间的 DisplayList 就无法继续使用了，这时系统就会重新执行一次重新创建 DisplayList 、渲染DisplayList 并更新到屏幕上。这个流程的表现性能取决于该视图的复杂程度。 五、给开发的界面优化 Advice1 优化布局的结构布局结构太复杂，会减慢渲染的速度，造成性能瓶颈。我们可以通过以下这些惯用、有效的布局原则来优化： 避免复杂的View层级。布局越复杂就越臃肿，就越容易出现性能问题，寻找最节省资源的方式去展示嵌套的内容； 尽量避免在视图层级的顶层使用相对布局 RelativeLayout 。相对布局 RelativeLayout 比较耗资源，因为一个相对布局 RelativeLayout 需要两次度量来确保自己处理了所有的布局关系，而且这个问题会伴随着视图层级中的相对布局 RelativeLayout 的增多，而变得更严重； 布局层级一样的情况建议使用线性布局 LinearLayout 代替相对布局 RelativeLayout，因为线性布局 LinearLayout 性能要更高一些；确实需要对分支进行相对布局 RelativeLayout 的时候，可以考虑更优化的网格布局 GridLayout ，它已经预处理了分支视图的关系，可以避免两次度量的问题； 相对复杂的布局建议采用相对布局 RelativeLayout ，相对布局 RelativeLayout 可以简单实现线性布局 LinearLayout 嵌套才能实现的布局； 不要使用绝对布局 AbsoluteLayout ； 将可重复使用的组件抽取出来并用 标签进行重用。如果应用多个地方的 UI 用到某个布局，就将其写成一个布局部件，便于各个 UI 重用。官方详解 「 戳我 」 使用 merge 标签减少布局的嵌套层次，官方详解 「 戳我 」；去掉多余的不可见背景。有多层背景颜色的布局，只留最上层的对用户可见的颜色即可，其他用户不可见的底层颜色可以去掉，减少无效的绘制操作； 尽量避免使用 layoutweight 属性。使用包含 layoutweight 属性的线性布局 LinearLayout 每一个子组件都需要被测量两次，会消耗过多的系统资源。在使用 ListView 标签与 GridView 标签的时候，这个问题显的尤其重要，因为子组件会重复被创建。平分布局可以使用相对布局 RelativeLayout 里一个 0dp 的 view 做分割线来搞定，如果不行，那就……； 合理的界面的布局结构应是宽而浅，而不是窄而深； 2 优化处理逻辑 按需载入视图。某些不怎么重用的耗资源视图，可以等到需要的时候再加载，提高UI渲染速度； 使用 ViewStub 标签来加载一些不常用的布局； 动态地 inflation view 性能要比用 ViewStub 标签的 setVisiblity 性能要好，当然某些功能的实现采用 ViewStub 标签更合适； 尽量避免不必要的耗资源操作，节省宝贵的运算时间； 避免在 UI 线程进行繁重的操作。耗资源的操作（比如 IO 操作、网络操作、SQL 操作、列表刷新等）耗资源的操作应用后台进程去实现，不能占用 UI 线程，UI 线程是主线程，主线程是保持程序流畅的关键，应该只操作那些核心的 UI 操作，比如处理视图的属性和绘制； 最小化唤醒机制。我们常用广播来接收那些期望响应的消息和事件，但过多的响应超过本身需求的话，会消耗多余的 Android 设备性能和资源。所以应该最小化唤醒机制，当应用不关心这些消失和事件时，就关闭广播，并慎重选择那些要响应的 Intent 。 为低端设备考虑，比如 512M 内存、双核 CPU 、低分辨率，确保你的应用可以满足不同水平的设备。 优化应用的启动速度。当应用启动一个应用时，界面的尽快反馈显示可以给用户一个良好的体验。为了启动更快，可以延迟加载一些 UI 以及避免在应用 Application 层级初始化代码。 3 善用 DEBUG 工具 多使用Android提供的一些调试工具去追踪应用主要功能的性能情况； 多使用Android提供的一些调试工具去追踪应用主要功能的内存分配情况； 转载自Android界面性能调优手册]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 快速开发框架]]></title>
      <url>%2F2017%2F01%2F15%2Fandroid-quick-develop-frame%2F</url>
      <content type="text"><![CDATA[一、Afinal 官方介绍： Afinal是一个Android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对Android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。详情请通过以下网址查看。 Afinal 是一个android的sqlite orm 和 ioc 框架。同时封装了android中的http框架，使其更加简单易用； 使用finalBitmap，无需考虑bitmap在android中加载的时候oom的问题和快速滑动的时候图片加载位置错位等问题。 Afinal的宗旨是简洁，快速。约定大于配置的方式。尽量一行代码完成所有事情。 项目地址：https://github.com/yangfuhai/afinal 功能： 一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。 优点：功能比较全面，文档完善，代码效率比较高。 缺点：没有项目demo，框架的时间比较久，代码冗余比较多（这也是无可避免的），文档比较老跟不上代码更新进度。 （这个评价是其他高人评的，他自己也有写了框架。我个人觉得以前Afinal算是经典了 用的人多）。 二、xUtils Git地址：https://github.com/wyouflf/xUtils xUtils：可以说是Afinal的升级版。 xUtils 包含了很多实用的android工具。 xUtils 支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响… xUitls 最低兼容android 2.2 (api level 8) 三、ThinkAndroid 项目地址：https://github.com/white-cat/ThinkAndroid 官方介绍： ThinkAndroid是一个免费的开源的、简易的、遵循Apache2开源协议发布的Android开发框架，其开发宗旨是简单、快速的进行Android应用程序的开发，包含Android mvc、简易sqlite orm、ioc模块、封装Android httpclitent的http模块,具有快速构建文件缓存功能，无需考虑缓存文件的格式，都可以非常轻松的实现缓存，它还基于文件缓存模块实现了图片缓存功能，在android中加载的图片的时候，对oom的问题，和对加载图片错位的问题都轻易解决。他还包括了一个手机开发中经常应用的实用工具类，如日志管理，配置文件管理，android下载器模块，网络切换检测等等工具 优点：功能看起来比较完善。个人觉得名字起的好。 缺点：从2013年就停止维护了，没有项目文档。 四、LoonAndroid 官方介绍： 如果你想看ui方面的东西，这里没有，想要看牛逼的效果这里也没有。这只是纯实现功能的框架，它的目标是节省代码量，降低耦合，让代码层次看起来更清晰。整个框架一部分是网上的，一部分是我改的，为了适应我的编码习惯，还有一部分像orm完全是网上的组件。在此感谢那些朋友们。 整个框架式的初衷是为了偷懒，之前都是一个功能一个jar，做项目的时候拉进去，这样对于我来说依然还是比较麻烦。最后就导致我把所有的jar做成了一个工具集合包。 有很多框架都含有这个工具集合里的功能，这些不一定都好用，因为这是根据我个人使用喜欢来实现的，如果你们有自己的想法，可以自己把架包解压了以后，源码拉出来改动下。 目前很多框架都用到了注解，除了androidannotations没有入侵我们应用的代码以外，其他的基本上都有，要么是必须继承框架里面的activity,要么是必须在activity的oncreat里面调用某个方法。 整个框架式不同于androidannotations，Roboguice等ioc框架，这是一个类似spring的实现方式。在整应用的生命周期中找到切入点，然后对activity的生命周期进行拦截，然后插入自己的功能。 开源地址：https://github.com/gdpancheng/LoonAndroid 功能： 自动注入框架（只需要继承框架内的application既可） 图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性） 网络请求模块（继承了基本上现在所有的http请求） eventbus（集成一个开源的框架） 验证框架（集成开源框架） json解析（支持解析成集合或者对象） 数据库（不知道是哪位写的 忘记了） 多线程断点下载（自动判断是否支持多线程，判断是否是重定向） 自动更新模块 一系列工具类 优点：功能多 缺点：文档方面 五、KJFrameForAndroid 项目地址：https://github.com/kymjs/KJFrameForAndroid 官方介绍： KJFrameForAndroid 又叫KJLibrary，是一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用；KJFrameForAndroid的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。我们提倡用最少的代码，完成最多的操作，用最高的效率，完成最复杂的功能。 功能： 一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用； KJFrameForAndroid开发框架的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。总共分为五大模块：UILibrary，UtilsLibrary，HttpLibrary，BitmapLibrary，DBLibrary。 优点：功能比较全面，代码效率很高，文档完善，有项目demo，出来的比较晚借鉴了很多大型框架经验。 缺点：项目文档是html页面，查看起来很不方便，项目交流平台没多少人说话（难道大神都是不说话的？） （这两个评价是KJFrameForAndroid的作者对自己的评价，个人觉得作者是个天才。他的评价可能刚写完网上发布后写的。我在给他更新评价。因为现在已经过去了几个月一直在时不时更新。功能很全，项目文档也很全面，而且代码里注释最多 这方面这个很难得。交流平台人很多挺热闹，作者希望更热闹这样框架越来越完善。对于初学者希望看到Demo更完善） 六、dhroid 官方介绍： dhroid 是基于android 平台, 极速开发框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展.使你更快,更好的开发商业级别应用 开源地址: http://git.oschina.net/tengzhinei/dhroid 功能： Ioc容器: (用过spring的都知道)视图注入,对象注入,接口注入,解决类依赖关系 Eventbus: android平台事件总线框架,独创延时事件,事件管理轻松 Dhnet: 网络http请求的解决方案,使用简单,减少代码,自带多种网络访问缓存策略 adapter模块: 数据绑定轻松,不用写多余的adapter,天生网络支持(一行代码搞定加载,刷新问题) DhDb: android中sqlite的最轻量orm框架(增删改查轻松搞定) Perference: android自带Perference 升级版,让你的Perference更强大,更方便 工具集合 JSONUtil(安全处理json),ViewUtil(数据绑定更快) ThreadWorker(异步任务工具)… 优点：功能全面，有demo，作者也是为公司开发的框架。 缺点：文档方面现在不是很好，就eoe上的那些。 七、SmartAndroid 项目地址：http://www.aplesson.com/smartAndroid/demos 官方介绍： SmartAndroid是一套给 Android开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库以及简单的接口和逻辑结构，其目的是使开发人员更快速地进行项目开发。使用 SmartAndroid可以减少代码的编写量，并将你的精力投入到项目的创造性开发上。 功能： SmartAndroid 拥有全范围的类库，可以完成大多数通常需要的APP开发任务，包括： 异步网络操作相关所有功能、强大的图片处理操作、轻量级ORM数据库Sqlite库、zip操作 、动画特效、Html等解析采集、事件总线EventBus/Otto、Gson(Json)、AQuery、主流所有UI控件（例如：ActionbarSherlock，SlidingMenu，BottomView，Actionbar，DragListView等10多种UI库）等。 优点：功能非常全，超出你索要、文档完善（作者很全面，官方网站是web响应式网站，框架里功能有UI各种特效应该最全了，一直更新中） 缺点：jar包大点？（功能多不可避免，不是问题），在线文档（随响应式的手机访问也方便，但是网速慢就不好了，页面打开不是很流畅） 八、andBase 官方介绍： andbase是为Android开发者量身打造的一款开源类库产品 开源地址：https://code.jd.com/zhaoqp2010_m/andbase 功能： andbase中包含了大量的开发常用手段。如网络下载，多线程与线程池的管理，数据库ORM，图片缓存管理，图片文件下载上传，Http请求工具，常用工具类（字符串，日期，文件处理，图片处理工具类等），能够使您的应用在团队开发中减少冗余代码，很大的提高了代码的维护性与开发高效性，能很好的规避由于开发疏忽而导致常犯的错误。 andbase封装了大量的常用控件。如list分页，下拉刷新，图片轮播，表格，多线程下载器，侧边栏，图片上传，轮子选择，图表，Tab滑动，日历选择器等。 强大的AbActivity，您没有理由不继承它。继承它你能够获得一个简单强大可设置的操作栏，以及一系列的简单调用，如弹出框，提示框，进度框，副操作栏等。 提供效率较高图片缓存管理策略，使内存大幅度节省，利用率提高，效率提高。程序中要管理大量的图片资源，andbase提供简单的方法，几步完成下载与显示，并支持缩放，裁剪，缓存功能。 封装了大量常见工具类。包括日期，字符，文件，图片等各种处理函数，多而全。 用andbase大量减少handler的使用，而采用回调函数，代码更整洁。handler会产生大量代码，并且不好维护，andbase对handler进行了封装。 简单轻量支持注解自动建表的ORM框架（支持一/多对多的关联操作）。写sql，建表，工作量大，andbase提供更傻瓜异步增删改查工具类。 异步请求http框架，网络请求标准化，支持文件上传下载，get，post，进度显示。包含了异步与http请求的工具类，实用。 热情的支持群体。 优点：功能很全，demo做的好 、API文档完善、接近完美 缺点：希望文档更详细些。 九、AndroidAnnotations 项目地址：https://github.com/excilys/androidannotations 功能： 完全注解框架，一切皆为注解：声明控件，绑定控件，设置监听，setcontentview，长按事件，异步线程，全部通过注解实现。 优点：完全的注解，使开发起来更加便利，程序员写的代码也更少。 缺点：文档是全英文的加上功能比较少没有具体研究，由于一切都是注解，感觉效率不高，不过根据官方介绍说并不是使用的反射加载，所以效率比一般注解高很多。 十、volley 项目地址： https://github.com/smanikandan14/Volley-demo 功能：Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮异步加载网络图片、网络数据 优点：Google官方推荐，请看去年的开发者大会介绍。 缺点：功能比较少，只有网络数据加载和网络图片加载 总结以上的开发框架网上都可以下载源码，也有demo实例的。当然我没分析和对比框架的效率性能，但是都非常实用，其作者大部分是个人，都是些牛人或天才。你可以直接使用，也可以把有用跳出来用，至少有很多使用工具。如果有发现Bug，作者希望把bug交给他。 Afinal 和 xUtils简单实用但是demo和更新的问题。 KJFrameForAndroid 算是新出的，功能也多，效率也应该好，代码也注释多 用起来也很方便。 Dhroid 作者自己公司的框架，也可以直接请教。 SmartAndroid 强劲的框架功能俱全。 andBase 出来早各个方面算是完整的吧。 转自：http://blog.csdn.net/buddyuu/article/details/40503471]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android View的工作流程]]></title>
      <url>%2F2017%2F01%2F08%2Fandroid-view-workflow%2F</url>
      <content type="text"><![CDATA[前言写了那么多自定义View，但是对于其中的原理以及工作流程还不是很了解，所以这篇博文来总结和回顾一下Android开发中的View的工作流程，view的工作流程主要包含measure、layout和draw三大流程，在进入主题之前，先要理解一下几个概念，以便更好的理解view的三大流程。转载自《安卓复习之旅——View的工作流程》 了解ViewRoot和DecorViewViewRoot对应ViewRootImpl类，实现了ViewParent接口，它是连接WindowManager和DecorView的桥梁，WindowManager的实现类是WindowManagerImpl类:123456public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow; private IBinder mDefaultToken; 其中WindowManagerGlobal相当与一个代理类，WindowManagerImpl 中的实现的方法都是通过WindowManagerGlobal来具体实现的，我们来看看WindowManagerImpl 中的addView()方法：12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; 可以看出确实是通过WindowManagerGlobal的addView()方法来具体实现的，进入WindowManagerGlobal的addView()方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException("View " + view + " has already been added to the window manager."); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; //实例化ViewRootImpl root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; //连接WindowManager和DecorView root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; &#125; 由上面注释的代码可以看出ViewRootImpl是连接WindowManager和DecorView的桥梁。 DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况和Android版本及主体有关），上面的是标题栏，下面的是内容栏。在Activity中通过setContentView所设置的布局文件其实就是被加到内容栏之中的，而内容栏的id是content，在代码中可以通过ViewGroup content = （ViewGroup)findViewById(R.android.id.content)来得到content对应的layout。DecorView的结构图： View的绘制流程View的绘制流程是从ViewRootImpl的performTraversals()方法开始的，它经过measure、layout和draw三个流程才能最终将view绘制出来，其中measure测量view的宽高，layout确定view在父容器中的位置，draw负责将view绘制在屏幕上。view的绘制流程图： performTraversals()方法源码比较长，就不贴出来了，有兴趣可以去查看一下，从上面的流程图可以看出performTraversals会依次调用 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); - performLayout(lp, mWidth, mHeight); - performDraw();三个方法，这三个方法顶级view的三个流程，在 performMeasure()中会调用mView.measure()方法，mView.measure()又会调用onMeasure()方法对所有子元素进行测量，这个时候measure流程就从父容器传递到了子元素中，这样就完成了依次measure过程，performLayout()和performDraw()与performMeasure()过程是类似的，唯一的不同是performDraw()过程在draw方法中是通过dispatchDraw(canvas)方法来完成绘制的; 理解MeasureSpecMeasureSpec是一个32位的int值，高2位代表SpecMode,低30位代表SpecSize，SpecMode是指测量模式，SpecSize是指某种测量模式下的规格大小；MeasureSpec内部的一些常量：123456789101112131415161718192021 private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size,int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125;public static int getMode(int measureSpec) &#123; //noinspection ResourceType return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; measureSpec 将SpecMode和SpecSize打包成一个int值，一组SpecMode和SpecSize也可以打包成一个measureSpec 通过getMode和getSize可以得到对应的值；SpecMode有三种类型： UNSPECIFIED父容器没有对view有任何限制，要多大给多大； EXACTLY父容器已经检测出view所需要的精确大小，view的大小就是SpecSize所指定的值，它对应于LayoutParams中的match_parent和具体的数值两种模式； AT_MOST父容器指定一个可用的大小即SpecSize，view的大小不能超过这个大小，对应于layoutParams中的wrap——content； measureSpec 与LayoutParams有什么关系呢？当我们给view设置了LayoutParams后，系统会将LayoutParams在父容器的约束下转换成对应的measureSpec ；对于DecorView来说，在ViewRootImpl中的measureHierarchy方法中进行了measureSpec 的创建过程，desiredWindowWidth为屏幕宽度，desiredWindowHeight为屏幕高度；123childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); 进入getRootMeasureSpec方法：12345678910111213141516171819private static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT: // Window can't resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec; &#125; 这个方法是根据DecorView自身的LayoutParams来计算出对应的measureSpec ；对于普通view的measure过程是有viewgroup传递下来的，先看看viewgroup的measureChildWithMargins方法：1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; measureChildWithMargins方法会通过getChildMeasureSpec方法计算出子元素的MeasureSpec然后子元素进行measure，从代码可以看出子元素的MeasureSpec与父容器的MeasureSpec与自身的LayoutParams有关，此外，还与view的margin和padding有关，下面进入getChildMeasureSpec方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can't be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) &#123; // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; 这个方法主要作用是根据父容器的MeasureSpec与view自身的LayoutParams来确定子元素的MeasureSpec，参数中的padding指父容器已占用的大小。 View的三大流程measure过程measure过程要分两种情况，一种是普通view，一种是viewgroup： 1.view的measureview的measure方法是一个final类型的方法，意味着不能重写这个方法，在这个方法中调用了onMeasure方法，我们可以重写onMeasure方法。123456789101112131415public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; ... if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; ... &#125; 看看onMeasure方法的实现： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 调用setMeasuredDimension方法设置view的测量值，其中getSuggestedMinimumWidth()是系统默认提供的值，这里就不深究了，下面看看getDefaultSize方法： 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; 在UNSPECIFIED模式下，返回系统默认值，EXACTLY和AT_MOST模式下，返回measureSpec中的值；这里也可以得到一个结论：当我们直接继承一个view的自定义控件需要重写onMeasure方法去设置wrap_content时的自身大小，否则在布局中使用wrap_content的效果与match_parent一样，原因是当view设置为wrap_content时，模式是AT_MOST，通过前一篇文章中的getChildMeasureSpec方法可以知道，view的specSize就是parentSize；重写onMeasure的代码思路如下：1234567891011121314151617int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(viewWidth, viewHeight); &#125; else if(widthMode == MeasureSpec.AT_MOST )&#123; setMeasuredDimension(viewWidth, heightSize); &#125; else if(heightMode == MeasureSpec.AT_MOST )&#123; setMeasuredDimension(widthSize, viewHeight); &#125; 2.viewgroup的measure对于viewgroup来说，出了完成自己的measure过程，还要遍历子view的measure方法，各个子view完成对自身的measure过程，与view不同的是，viewgroup是一个抽象类，它是通过measureChildren（）方法开始measure，先看看measureChildren方法的代码：12345678910protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) &#123; final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; size; ++i) &#123; final View child = children[i]; if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; &#125; &#125; 从以上代码可以看出，确实是会通过measureChild方法对每一个子view进行measure，1234567891011protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) &#123; final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; measureChild方法先得到子view的MeasureSpec，然后再调用子view的measure方法； view的measure过程是三大流程中最复杂的一个，measure完成以后，通过getMeasuredHeight()和getMeasuredWeight()可以得到view的测量高宽，但是在某些极端情况下，系统可能会多次measure才能得到最终的值，在这种情况下，在onMeasure中可能得到的值不是准确的。我们最好在onLayout中获取；还有一个需要注意的是，我们在onCreate、onStart和onResume中均得不到view的宽高，因为measure过程与activity的生命周期不是同步的； layout过程layout过程的作用是viewgroup来确定子元素的位置，当viewgroup的位置确定后，会遍历所有子元素并调用其layout方法，在layout方法中又会调用onLayout方法。先看viewgroup的layout方法：123456789101112@Override public final void layout(int l, int t, int r, int b) &#123; if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) &#123; if (mTransition != null) &#123; mTransition.layoutChange(this); &#125; super.layout(l, t, r, b); &#125; else &#123; // record the fact that we noop'd it; request layout when transition finishes mLayoutCalledWhileSuppressed = true; &#125; &#125; 可以看出是调用父类的layout方法：12345678910111213141516171819202122232425262728293031323334353637383940public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) &#123; if(mRoundScrollbarRenderer == null) &#123; mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); &#125; &#125; else &#123; mRoundScrollbarRenderer = null; &#125; mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; 首先通过setFrame确定view的四个顶点位置，此时父容器的位置也就确定了，接下来就会调用onLayout方法确定子元素的位置； protected void onLayout(boolean changed, int left, int top, int right, int bottom) {} onLayout方法并没有给出具体的实现，当继承特定的组件时，不需要我们重写onLayout方法，继承viewgroup时则需要重写onLayout方法。 draw过程draw的作用是将view绘制到屏幕上，view的绘制流程遵循以下几步： 绘制背景drawBackground(canvas); 绘制自己onDraw(canvas); 绘制子元素dispatchDraw(canvas); 绘制装饰onDrawForeground(canvas); 看看draw源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; &#125; ... &#125; view绘制过程的传递是通过 dispatchDraw(canvas)来实现的， dispatchDraw(canvas);会遍历所有的子元素的draw方法，view有一个特殊的方法：setWillNotDraw，先看一下源码;12345678910111213/** * If this view doesn't do any drawing on its own, set this flag to * allow further optimizations. By default, this flag is not set on * View, but could be set on some View subclasses such as ViewGroup. * * Typically, if you override &#123;@link #onDraw(android.graphics.Canvas)&#125; * you should clear this flag. * * @param willNotDraw whether or not this View draw on its own */ public void setWillNotDraw(boolean willNotDraw) &#123; setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK); &#125; 意思是如果一个view不需要绘制任何内容，那么设置这个标记位为TRUE后，系统会进行优化，默认情况下标记位为FALSE。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 高效开发工具库]]></title>
      <url>%2F2017%2F01%2F04%2Fandroid-efficient-tools%2F</url>
      <content type="text"><![CDATA[前言这篇文章介绍开发者如何学习提高以构建更好的app，我将分享一些自己受益过的教程和资料。 一. 使用Android studio的快捷键1. tips这里是一个使用Android studio的小建议集合，大家可以在里边找到不少提高效率的点子。 2. template使用Live templates可以节省coding时间：使用缩写快速输入方法或者循环eg: 输入 fbc 则快速速入了findViewById template入门：Android Studio Live Templates 值得试用的live template 集合：keyboardsurfer/idea-live-templates 自定义template，这里是Reto Meier写的一篇非常好的教程Writing More Code by Writing Less Code with Android Studio Live Templates，当然也可以从IntelliJ IDEA documentation获取更多细节。 二. Debugging App时用到的工具 Library methods count Android 的 library非常有用，但是太多的库也会是的app中方法数目快速增加，这个工具可以显示各个依赖库的方法数。 Stetho 使用Stetho，可以非常方便地监控app，尤其是网络流量。还可以监测并编辑SQLite，和Shared Preferences。 LeakCanary Android和java工程中可以的内存泄露监测工具。 Gradle, Please Chris broadFoot做的一个非常酷的一个library，只需要输入一个Library 的名字，就可以得到这个Library 的gradle依赖code，并且是该Library的最新版本，不要错过这个网站： Android Arsenal 这是一个分类查看Android Library、工具、工程的网站，很赞！ Android Tool Mac上的Android工具，可以进行录屏、截屏、安装apk，记录bug。 Butterknife Zelezny，可以根据选择的xml文件自动生成butterknife的注入代码。 ADB Idea Android和Intellij IDEA中可用的插件，卸载App、killApp、启动App、重启App、清除App数据、清除App数据并重启。 Another Adb tool 另一个可用adb工具。 Google Developers India , Android Developers 获取最新的Android信息 Android Dev weekly 订阅最新的Android资讯。 三. 向其它开发者学习从开源代码中，我们可以学习到不少技巧。 Google I/O Google I/O是谷歌每年举行的为期两天的开发者大会，会上会展示数百个程序示例。这个工程是会议上的应用程序。应用支持Android 4.0以及更高版本的设备，并针对各种形状和尺寸手机和平板进行优化。 Android App MVP Architecture 这个工程提供了一个比较详细的MVP框架的demo，并且使用了Dagger2、GreenDao、Rxjava、FastAndroidNetworking、PlaceHolderView、AndroidDebugDatabase。 Google Android Architecture Blueprints 在构建应用程序时，我们可能会碰到各种各样的问题，使得我们在测试、维护、扩展应用程序时比较困难。Google Android Architecture Blueprints提供了避免这些常见问题的演示程序，这个项目使用不同的架构和和工具实现了相同的app。 Plaid 提供了设计资讯和灵感，非常好的实践了material design。 Kickstarter kickstarter是一个全球性的社区，把创造力融入生活中，探索艺术、设计、电影、游戏、音乐等等相关的项目，并且可以把这些项目加入到收藏夹。 四. 其它 开源协议介绍：Developer’s Guide to Open Source Licenses 测试入门：Testing Guide Android 优化实践：Best Practices for Performance | Android Developers 依赖注入：Dagger 2 Dependency Injection for Android Developers Introduction to Dagger 2, Using Dependency Injection in Android: Part 1 Fragmented Podcast:Donn Felker 和 Kaushik Gopal在这里介绍Android开发者如何进阶，构建更好的软件。 Playbook for Developers：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 屏幕适配]]></title>
      <url>%2F2016%2F08%2F05%2Fandroid-screen-adapt%2F</url>
      <content type="text"><![CDATA[前言Android手机由于厂家未统一，以及某些厂家的标新立异，导致目前Android手机的分辨率和尺寸千奇百怪，无所不有。所以对Android手机的屏幕适配一直开发是一个大问题。要学习这方面的知识，并且掌握是Android开发的一个重头。 关于屏幕适配的dp、dpi、px一、分辨率,屏幕大小,密度1、分辨率。分辨率就是手机屏幕的像素点数，一般描述成屏幕的“宽×高”，安卓手机屏幕常见的分辨率有480×800、720×1280、1080×1920、1440x2560的2K屏等。720×1280表示此屏幕在宽度方向有720个像素，在高度方向有1280个像素。 2、屏幕大小。屏幕大小是手机对角线的物理尺寸，以英寸（inch）为单位。比如某某手机为“5寸大屏手机”，就是指对角线的尺寸，5寸×2.54厘米/寸=12.7厘米。 3、密度（dpi，dots per inch；或PPI，pixels per inch）。从英文顾名思义，就是每英寸的像素点数，数值越高当然显示越细腻。假如我们知道一部手机的分辨率是1080×1920，屏幕大小是5英寸，你能否算出此屏幕的密度呢？中学的勾股定理派上用场啦！通过宽1080和高1920，根据勾股定理，我们得出对角线的像素数大约是2203，那么用2203除以5就是此屏幕的密度了，计算结果是440。440dpi的屏幕已经相当细腻了。 二、实际密度与系统密度“实际密度”就是我们自己算出来的密度，这个密度代表了屏幕真实的细腻程度，如上述例子中的440dpi就是实际密度，说明这块屏幕每寸有440个像素。5英寸1080×1920的屏幕密度是440，而相同分辨率的4.5英寸屏幕密度是490。如此看来，屏幕密度将会出现很多数值，呈现严重的碎片化。而密度又是安卓屏幕将界面进行缩放显示的依据，那么安卓是如何适配这么多屏幕的呢？其实，每部安卓手机屏幕都有一个初始的固定密度，这些数值是120、160、240、320、480，我们权且称为“系统密度”也称为“广义密度”。大家发现规律没有？相隔数值之间是2倍的关系。一般情况下，240×320的屏幕是低密度120dpi，即ldpi；320×480的屏幕是中密度160dpi，即mdpi；480×800的屏幕是高密度240dpi，即hdpi；720×1280的屏幕是超高密度320dpi，即xhdpi；1080×1920的屏幕是超超高密度480dpi，即xxhdpi。安卓对界面元素进行缩放的比例依据正是系统密度，而不是实际密度。将一定范围的屏幕密度的设备视为一个特定的密度，比如屏幕密度在240左右的设备视为高密度（hdpi），在320左右的视为超高密度（xhdpi）等。 三、dp、sp、px的区别px：即像素，1px代表屏幕上一个物理的像素点；px单位不被建议使用，因为同样100px的图片，在不同手机上显示的实际大小可能不同，偶尔用到px的情况，是需要画1像素表格线或阴影线的时候，用其他单位如dp会显得模糊。dp也可写为dip，即density-independent pixel。你可以想象dp更类似一个物理尺寸，比如一张宽和高均为100dp的图片在320×480和480×800的手机上“看起来”一样大。而实际上，它们的像素值并不一样。dp正是这样一个尺寸，不管这个屏幕的密度是多少，屏幕上相同dp大小的元素看起来始终差不多大。sp：sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），所以目前主流应用字体大小已经改用dp，不用sp，省去用户手动调整字体适配的麻烦。 四、常规的安卓手机分辨率及其dpi和density的计算查看一下现在Android Studio自带的模拟器设备： 手机屏幕的dpi和density的计算：以Nexus5X为例： 手机大小5.2英寸，分辨率为1080×1920，那么该手机屏幕的：物理宽度：(1080/√￣(1080×1080+1920×1920))*5.2=2.55像素密度dpi：1080/2.55=420px/英寸密度density：420/160=2.625 五、转换公式dp和px之间的换算：dp=px * densitydp与px的换算要以系统密度为准在安卓中，系统密度为160dpi的中密度手机屏幕为基准屏幕，即320×480的手机屏幕。在这个屏幕中，1dp=1px。100dp在320×480（mdpi，160dpi）中是100px。那么100dp在480×800（hdpi，240dpi）的手机上是多少px呢？我们知道100dp在两个手机上看起来差不多大，根据160与240的比例关系，我们可以知道，在480×800中，100dp实际覆盖了150px。中密度和高密度的缩放比例，720×1280的系统密度为320，320×480的系统密度为160，320/160=2，那么在720×1280中，1dp=2px。同理，在1080×1920中，1dp=3px。ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12，我们发现，相隔数字之间还是2倍的关系。计算的时候，以mdpi为基准。比如在720×1280（xhdpi）中，1dp等于多少px呢？mdpi是4，xhdpi是8，2倍的关系，即1dp=2px。反着计算更重要，比如你用PhotoShop在720×1280的画布中制作了界面效果图，两个元素的间距是20px，那开发是多少dp呢？2倍的关系，那就是10dp！实际程序中根据不同机型，可以用代码计算相应的转换。当安卓系统字号设为“普通”时，sp与px的尺寸换算和dp与px是一样的。比如某个文字大小在720×1280的PS画布中是24px，那么告诉工程师，这个文字大小是12sp。实际开发过程中，常规用到的转换公式是： 12345678910111213141516171819202122232425/** * * @param context 上下文 * @param values dp值 * @return */ public static int dp2px(Context context, int values) &#123; float scale = context.getResources().getDisplayMetrics().density; return (int) (values * scale + 0.5f); &#125; public static int px2dip(Context context, float pxValue) &#123; float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); &#125; public static int px2sp(Context context, float pxValue) &#123; float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (pxValue / fontScale + 0.5f); &#125; public static int sp2px(Context context, float spValue) &#123; final float fontScale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (spValue * fontScale + 0.5f); &#125; 以dp2px为例，这里有一个小细节，根据上面的推导，return的结果应该是 (int) (values * density)，而结果会+0.5f再强转，原因是浮点型强转整型过程直接回去除小数部分，+0.5f相当于四舍五入的过程（小数部分大与0.5的+0.5f后会进一位）,结果显得更加精确。 二、资源文件夹之间的关系Android开发中，UI一般会制作多种图片素材，根据素材的分辨率大小，放在如下几个文件夹中：ldpi（120dpi）mdpi（160dpi）hdpi（240dpi）xdpi（320dpi）xxdpi（480dpi）xxxdpi（640dpi）以mdpi（160dpi）为基准可以看出系数比例关系：0.75：1：1.5：2：3：4 一、资源文件的加载很明显420dpi不属于上述文件分类中的任何一个，安卓手机分辨率千奇百怪，因此，上述文件夹不是指定具体的分辨率，而是一个范围，如ldpi（value&lt;120dpi），mdpi（120dpi&lt;value&lt;160dpi），以此类推，420dpi会加载xxdpi中的资源文件验证一下：这里有两张图片 将171×171放入xxdpi中，64×64放入xdpi中，用Nexus5X进行测试，应该加载哪个文件夹中的资源呢？123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:src="@mipmap/icon_life" /&gt;&lt;/RelativeLayout&gt; 结果如图： 这个到底是加载的哪个文件夹的图片呢，加载的是171还是64？我也不知道。那么我调换一下，将171×171放入xdpi中，64×64放入xxdpi中，如果图片变小了，那么证明，必然加载的是xxdpi文件夹的图片了。结果如图： 二、建议在xdhpi中作图安卓手机有这么多屏幕，我到底依据哪种屏幕作图呢？没有必要为不同密度的手机都提供一套素材，大部分情况下，一套就够了。现在手机比较高的分辨率是1080×1920，你可以选择这个尺寸作图，但是图片素材将会增大应用安装包的大小。并且尺寸越大的图片占用的内存也就越高。如果你不是设计ROM，而是做一款应用，我建议大家用PS在720×1280的画布中作图。这个尺寸兼顾了美观性、经济性和计算的简单。美观性是指，以这个尺寸做出来的应用，在720×1280中显示完美，在1080×1920中看起来也比较清晰；经济性是指，这个分辨率下导出的图片尺寸适中，内存消耗不会过高，并且图片文件大小适中，安装包也不会过大；计算的简单，就是1dp=2px啊，多好计算啊！做出来的图片，记着让界面工程师放进drawable-xhdpi的资源文件夹中。xhdpi (320dpi, 2x) 同iOS @2x 750x1334xxdpi (480dpi, 3x) 同iOS @3x 1242x2208（除以1.15，则等比缩放到android的1080*1920)淘宝选择2x标注，3x切图，具体讲解如下：http://blog.csdn.net/zx_android/article/details/51150156 三、屏幕的宽高差异在720×1280中作图，要考虑向下兼容不同的屏幕。通过计算我们可以知道，320×480和480×800的屏幕宽度都是320dp，而720×1280和1080×1920的屏幕宽度都是360dp。它们之间有40dp的差距，这40dp在设计中影响还是很大的。如下图蝴蝶图片距离屏幕的左右边距在320dp宽的屏幕和360dp宽的屏幕中就不一样。如果想消除这些比例差异，可以通过添加布局文件来实现。一般情况下，布局文件放在layout文件夹中，如果要单独对360dp的屏幕进行调整，你可以单做做一个布局文件放在layout-w360dp中；不过，最好是默认针对360dp的屏幕布局（较为主流），然后对320dp的屏幕单独布局，将布局文件放到layout-w320dp中；如果你想对某个特殊的分辨率进行调整，那么你可以将布局文件放在标有分辨率的文件夹中，如layout-854×480。 四、几个资源的文件夹在720×1280中做了图片，要让开发人员放到drawable-xhdpi的资源文件夹中，这样才可以显示正确。个人认为仅提供一套素材就可以了，可以测试一下应用在低端手机上运行是否流畅，如果比较卡顿，可以根据需要提供部分mdpi的图片素材，因为xhdpi中的图片运行在mdpi的手机上会比较占内存。以应用图标为例，xhdpi中的图标大小是96px，如果要单独给mdpi提供图标，那么这个图标大小是48px，放到drawable-mdpi的资源文件夹中。各个资源文件夹中的图片尺寸同样符合ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12的规律。 如果你把一个高2px的分割线素材做成了9.png图片，你想让细线在不同密度中都是2px，而不被安卓根据密度进行缩放，怎么办？你可以把这个分割线素材放到drawable-nodpi中，这个资源文件夹中的图片，将按照实际像素大小进行显示，而不会被安卓根据密度进行缩放。即在mdpi中细线是2px（2dp），在xhdpi中细线是2px（1dp）。 五、资源加载优先级Google官方文档显示如下：如果有最匹配的资源（e.g. 设备是HDPI，存在hdpi的资源），则删除其他的资源。如果没有最佳匹配资源，优先匹配更高dpi的资源，缩小合适的比例以后使用（e.g. 设备是HDPI，未能找到hdpi的资源，但是有xhdpi的资源，则把XHDPI的资源缩小的3/4以后使用），并排除其他的资源（Google解释说，因为执行缩小操作比执行放大操作更加方便，所以高dpi资源优先与低dpi资源，不过，个人认为对于大部分图片来说，大图缩小造成的失真应该是小于小图放大造成的失真）。如果没最佳匹配的资源，也不存在更高dpi的资源，则使用dpi更低的资源，并放大合适的比例以后使用（e.g. 设备为HDPI，未能找到hdpi以及更高的资源，单存在mdpi的资源，则把mdpi的资源放大到3/2以后使用），并删排除其他资源。原则上来说，dalvik优先使用符合设备dpi的资源，其次是dpi较低的高dpi资源，再次是dpi较高的高dpi资源，最后采用nodpi的资源，由此，根据设备自身的dpi的不同，不同dpi资源的优先级是有差异的（忽略mdpi&amp;hdpi）: 设备dpi优先级顺序（由高到低）tvdpi tvdpi&gt;hdpi&gt;xhdpi&gt;xxhdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpihdpi hdpi&gt;xhdpi&gt;xxhdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpixhdpi xhdpi&gt;xxhdpi&gt;hdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpixxhdpi xxhdpi&gt;xhdpi&gt;hdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpi另外，除了nodpi以外，使用其他dpi资源前，还需要根据缩放比进行缩小/放大操作。 六、项目实战 类似上图是美工标注后的高保真图，分辨率为640*1136，对应到安卓为720p（会有细微偏差），ios为2@，安卓开发同学拿到图，下面的工作就比较简单了。 单位换算：只需要将上面的px/2，则得到代码中距离需要的dp，字体大小需要的sp。 切图处理：美工的切图一律放入xhdpi文件即可 这里我举两个适配的例子帮助大家更好的理解。 【代码适配】上图大家觉得怎么布局比较好？解答：【我加入的圈子】左边空出固定距离，右边【&gt;】空出固定距离，中间铺满屏幕，这样可以让360dp甚至更大的手机，不至于让页面内容缩在中间一小块。再看下下面的布局： 【动态布局适配】上图又怎么布局呢？做到各种机型适配。我在项目中的做法是，用（屏幕的宽度（像素）-两边的间距-中间间距）/3，这样得到每个图片的宽度，然后图片的高度设置成高图片的宽度相等（当然也可以重写view，自动设置宽等于高）代码如下： 1234LinearLayout.LayoutParams linearParams = (LinearLayout.LayoutParams)pic.getLayoutParams(); linearParams.width =(context.getResources().getDisplayMetrics().widthPixels-DisplayUtil.dip2px(context, 44)) / 3; linearParams.height = linearParams.width; pic.setLayoutParams(linearParams); //使设置好的布局参数应用到控件 【比重适配】weight也可以搞定了！的确，可以用比重去做，三个图片各占比为1，再调整下边距，但是高度怎么办，前面说过上，可以重写view,让这个view的高跟宽度相等，这种方式也可以。 【另类适配】 应该大家有看到有人提到过纯代码适配，就在在Java代码中动态设置每个view的宽跟高，宽跟高是通过计算得出的。比如设计图是640 1136，这个view的宽在640的设计图上是20px。所以有同学会通过DisplayMetrics metrics = res.getDisplayMetrics();screenWidth = metrics.widthPixels screenHeight = metrics.heightPixels;拿到当前屏幕的宽跟高，如果当前手机屏幕是720 1280，及screenWidth =720，screenHeight =1280，那么当前的view的宽度等于screenWidth /640 * view的宽度，这样的确非常完美，每部手机都可以等比的缩放。但是代码维护跟开发难度就是成倍的增加，不建议使用。 【不同的layout适配】 在res目录下创建不同的layout文件夹，比如：layout-640x360、layout-800x480……所有的layout文件在编译之后都会写入R.java里，而系统会根据屏幕的大小自己选择合适的layout进行使用。这种现在基本不会有人这么适配，不展开讨论。 【dimen尺寸资源文件的使用】dimen.xml在values文件夹下面12345&lt;resources&gt; &lt;!-- Default screen margins, per the Android Design guidelines. --&gt; &lt;dimen name="btn_width"&gt;16dp&lt;/dimen&gt; &lt;dimen name="btn_height"&gt;16dp&lt;/dimen&gt;&lt;/resources&gt; 布局中的使用： &lt;Button android:text="@string/test_dimen1" android:id="@+id/Button01" android:layout_width="@dimen/btn_width" android:layout_height="@dimen/btn_height"/&gt; 文件夹含义：values-v11 ——-API 11+代表android 3.0 +，意思是在API11设备上，该目录下的dimens.xml代替res/values/dimens.xmlvalues-480x320、values-800x480等 ————意思是在不同分辨率下，该目录下的dimens.xml代替res/values/dimens.xml]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 开发中常用的支持库]]></title>
      <url>%2F2016%2F06%2F11%2Fandroid-library%2F</url>
      <content type="text"><![CDATA[转载自《Android开发中那些常见到让人忽视的基础知识》 前言许多情况下，某项功能可能对应用开发者很有用，但是添加到 Android 框架却并不合适。例如，某个应用可能仅需要用于特定用例的某项功能，如在不同版本的 Android 系统之间顺畅切换。为了解决这一问题，Android SDK 添加了多个库，这些库统称为 Android 支持库。如果应用开发者想要在应用中集成库功能，他们可以添加其中任意一个库。 Android支持库（Android Support Library） 向后兼容版本的框架组件 什么是向后兼容？-让在旧版本 Android 平台上运行的应用支持为新版本平台推出的功能。例如，应用在依赖于框架类的 5.0（API 级别 21）版本以下的 Android 系统上运行时，将无法显示 Material Design 元素，因为该版本的 Android 框架不支持 Material Design。但是，如果此应用添加了支持库的 appcompat 库，则可以访问 API 级别 21 中具有的许多功能，其中包括对 Material Design 的支持。 用于实现建议的 Android 布局模式的UI元素 如DrawerLayout，RecyclerView等 支持不同的设备类型 如Android TV，Android Auto等 其他实用功能 如运行时权限等 支持库种类： support-v4用在 Android 2.3（API 级别 9） 或更高版本上。 support-v7用在 Android 2.3（API 级别 9）或更高版本上，依赖v4 support-v8 support-v13 support-v14 support-v17 注解支持库 设计支持库 各种支持库功能描述v4 支持库这些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。注：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果在 Gradle 脚本中列出了 support-v4，APK 将包含所有的 v4 模块。不过，要减少 APK 大小，建议仅列出应用需要的特定模块。 v4 compat 库为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-compat:24.2.0 v4 core-utils 库提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-core-utils:24.2.0 v4 core-ui 库实现各种 UI 相关组件，例如 ViewPager、NestedScrollView 和 ExploreByTouchHelper。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-core-ui:24.2.0 v4 media-compat 库向后移植部分媒体框架，包括 MediaBrowser 和 MediaSession。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-media-compat:24.2.0 v4 fragment 库添加对使用片段封装用户界面和功能的支持，从而使应用能够提供可以在大屏幕设备与小屏幕设备之间进行调节的布局。此模块依赖于 compat、core-utils、core-ui 和 media-compat。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-fragment:24.2.0 Dalvik 可执行文件分包支持库此库可以为使用多个 Dalvik Executable (DEX) 文件开发应用提供支持。引用超过 65536 个方法的应用须使用 Dalvik 可执行文件分包配置。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:multidex:1.0.0 v7 支持库一些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。这些库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。 v7 appcompat 库此库添加了对操作栏用户界面设计模式的支持。此库包含对 Material Design 用户界面实现的支持。注：此库依赖于 v4 支持库。下面是 v7 appcompat 库中包含的一些关键类： ActionBar - 提供操作栏用户界面模式的实现。 AppCompatActivity - 添加一个应用 Activity 类，此类可作为使用支持库操作栏实现的 Activity 的基础类。 AppCompatDialog - 添加一个对话框类，此类可作为 AppCompat 主题对话框的基础类。 ShareActionProvider - 包含对可以添加到操作栏中的标准化分享操作（例如电子邮件或发帖至社交应用）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:appcompat-v7:24.2.0 v7 cardview 库此库添加了对 CardView 小部件的支持，让您能够在卡片内显示信息，从而使应用具备一致的外观。这些卡片对 Material Design 实现非常有用，并在电视应用布局中广为使用。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:cardview-v7:24.2.0 v7 gridlayout 库此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:gridlayout-v7:24.2.0 v7 mediarouter 库此库可以提供 MediaRouter、MediaRouteProvider 和支持 Google Cast 的相关媒体类。一般而言，利用 v7 mediarouter 库中的 API，您可以控制当前设备到外部屏幕、扬声器和其他目标设备的媒体渠道和流的路由。此库包含的 API 可以用于发布应用特定的媒体路由提供程序、发现和选择目标设备，以及检查媒体状态，等等。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:mediarouter-v7:24.2.0支持库 r18 中引入的 v7 mediarouter 库 API 在后续版本的支持库中可能会发生更改。目前，建议仅使用与 Google Cast 有关的库。 v7 palette 库v7 palette 支持库包含 Palette 类，此类让您可以从图像中抽取突出颜色。例如，音乐应用可以使用 Palette 对象从专辑封面抽取主要颜色，然后使用这些颜色创建一个色彩协调的歌曲标题卡。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:palette-v7:24.2.0 v7 recyclerview 库recyclerview 库添加了 RecyclerView 类。此类能够为 RecyclerView 小部件提供支持，RecyclerView 是一种通过提供有限的数据项窗口有效显示大数据集的视图。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:recyclerview-v7:24.2.0 v7 Preference 支持库首选项软件包提供的 API 支持添加 preference 对象（例如 CheckBoxPreference 和 ListPreference），方便用户修改 UI 设置。v7 Preference 库添加了对接口（例如 Preference.OnPreferenceChangeListener 和 Preference.OnPreferenceClickListener）以及类（例如 CheckBoxPreference 和 ListPreference）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:preference-v7:24.2.0 v8 支持库此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。此库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。v8 renderscript 库此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。它添加了对 RenderScript 计算框架的支持。 android.support.v8.renderscript 软件包中包含这些 API。请注意，在应用中添加这些 API 的步骤与添加其他支持库 API 迥然不同。注：Android Studio 和 Gradle 构建支持使用带支持库的 RenderScript。renderscript 库位于 build-tools/$VERSION/renderscript/ 文件夹中。以下示例显示了此库的 Gradle 构建脚本属性：1234defaultConfig &#123; renderscriptTargetApi 18 renderscriptSupportModeEnabled true&#125; v13 支持库此库旨在用于 Android 3.2（API 级别 13）及更高版本。它添加了对带有 (FragmentCompat) 类和其他片段支持类的 Fragment 用户界面模式的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-v13:24.2.0 v14 Preference 支持库android.support.v14.preference 软件包提供的 API 添加了对首选项接口（例如 PreferenceFragment.OnPreferenceStartFragmentCallback 和 PreferenceFragment.OnPreferenceStartScreenCallback）以及类（例如 MultiSelectListPreference 和 PreferenceFragment）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:preference-v14:24.2.0 适用于电视的 v17 Preference 支持库android.support.v17.preference 软件包提供的 API 可以在电视设备上提供首选项接口，包括对 LeanbackListPreferenceDialogFragment.ViewHolder.OnItemClickListener 接口和类的支持，例如 BaseLeanbackPreferenceFragment 和 LeanbackPreferenceFragment。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:preference-leanback-v17:24.2.0 v17 Leanback 库android.support.v17.leanback 软件包提供的 API 支持在电视设备上构建用户界面。它为电视应用提供了一些重要的小部件。一些值得注意的类包括：BrowseFragment - 一种用于创建主要布局的片段，主要布局用于浏览类别和媒体项目。 DetailsFragment - 用于 Leanback 细节屏幕的包装器片段。 PlaybackOverlayFragment - 用于显示播放控件及相关内容的 DetailsFragment 子类。 SearchFragment - 用于处理搜索的片段。片段可以接收用户的搜索请求并将其传递给应用提供的 SearchResultProvider。SearchResultProvider 可以将搜索结果返回给 SearchFragment，后者会将结果渲染到 RowsFragment 中。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:leanback-v17:24.2.0 注解支持库注解软件包提供的 API 支持向应用中添加注解元数据。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:support-annotations:24.2.0 设计支持库设计软件包提供的 API 支持向应用中添加 Material Design 组件和模式。设计支持库添加了对应用开发者依赖的各种 Material Design 组件和模式的支持，例如抽屉式导航栏、浮动操作按钮 (FAB)、快捷信息栏和标签页。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:design:24.2.0 自定义标签页支持库自定义标签页软件包提供的 API 支持向应用中添加自定义标签页并对其进行管理。自定义标签页支持库添加了对自定义标签页服务和自定义标签页回调等各种类的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:customtabs:24.2.0 百分比支持库百分比软件包提供的 API 支持向应用中添加基于百分比的尺寸并对其进行管理。百分比支持库添加了对 PercentLayoutHelper.PercentLayoutParams 接口和各种类的支持，例如 PercentFrameLayout 和 PercentRelativeLayout。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:percent:24.2.0 适用于电视的应用建议支持库应用建议软件包提供的 API 支持向电视设备上运行的应用中添加内容建议。应用库添加了对注解（例如 ContentRecommendation.ContentMaturity 和各种类（例如 ContentRecommendation 和 RecommendationExtender）的支持。此库的 Gradle 构建脚本依赖关系标识符如下所示：com.android.support:recommendation:24.2.0 参考文章：https://developer.android.com/topic/libraries/support-library/features.html#v4 建议：在对Android有一定了解的情况下，可以适当看一下Android官方文档，并做好记录，避免每次忘了都得去Google。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android StatusBar学习]]></title>
      <url>%2F2016%2F05%2F19%2Fandroid-statusbar%2F</url>
      <content type="text"><![CDATA[前言一直以来，iOS 设备上状态栏背景色和图标文字颜色的灵活可变性始终受到设计人员的青睐，有意地恰当地融入到 App 的各种界面设计当中，更好地提升用户体验。 由于系统的限制，在老版本的安卓系统中，Android App 无法做到这些，产生一些设计上的遗憾。幸运的是，自4.4 版本（API 19)以后，Android 系统开始支持状态栏的定制，并被纳入 Android 设计规范当中，Android App 在设计上迈出了重要的一步。 “沉浸式状态栏” VS “透明状态栏”一般来说，Android 默认的状态栏样式表现为黑底白字，如果我们应用的标题栏背景色也为黑色，那就能与状态栏很好地衔接在一起，体验极佳。反之，如果为其他的颜色，整个界面的呈现效果就会大打折扣。 幸运的是，Android 4.4 版本开始，系统提供了相应的 API，支持状态栏全透明化，界面 Content View 可以延伸到状态栏上，填充状态栏背景色。而在 Android 5.0 版本开始，系统在此基础上做了进一步优化和规范，能够实现动态改变状态栏背景色，在透明度上默认呈现为半透明化，可定制化程度更高。 在此基础上，最终要做到我们的应用呈现在 Android 各个系统版本上的效果如图所示： 关于 Android 4.4 版本开始的状态栏变化，许多人喜欢称之为“沉浸式状态栏”，但从系统提供的 API 命名上可以看出，核心词汇为 “Translucent”，故准确来讲，这种效果又应该称之为“透明状态栏”。知乎上对于这两种叫法也颇有争议，具体内容可参考话题：为什么在国内会有很多用户把「透明栏」（Translucent Bars）称作 「沉浸式顶栏」？。可能对于设计师而言，沉浸式还是透明式的称呼有所区别，但对于广大开发者而言，无足轻重，我们所关注的应该是如何实现这种效果，并能够很好的兼容到各个版本中。 相关 API 介绍一般来说，目前在 Android 项目中我们都会使用 Toolbar 替代 ActionBar 来实现导航栏，除此之外，要实现透明状态栏效果，还需要了解两个相关 API，下面逐一介绍一下： 一：&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;也可以在代码中实现（据说，在代码中实现兼容性更好，style 资源中设置的方式在某些国产手机厂商定制的系统中存在一些问题）:1234if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); local LayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);&#125; 顾名思义，该属性能够实现透明状态栏效果，是在 Android 4.4 版本引入的，也就是兼容至 API 19 及以上版本。使用该属性设置主题后，内容布局向上延伸至状态栏，并且在不同版本的系统中呈现效果也有所区别，如图所示： 显然，在 API 19 及更高版本上，Toolbar 内容延伸至状态栏上去了，出现重叠问题，此时，就需要使用到另一个属性了。 二：android:fitsSystemWindows=&quot;true&quot; Boolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity. 用在 layout 布局文件中。官方文档给出了很明确的介绍，大致是说能够将使用该属性的视图与系统窗口（如状态栏）保持一定的 padding 间距。所以如果我们在 toolbar 中设置了该属性，就能够解决 true 配置带来的视图延伸问题，使呈现效果达到文章开始所示图中的效果。 使用案例分析res/values/styles 文件中定义基础主题样式：123&lt;style name="BaseTheme" parent="Theme.AppCompat.Light.NoActionBar"/&gt; &lt;style name="AppTheme" parent="BaseTheme"&gt; &lt;/style&gt; res/values-v19/styles 文件中定义兼容主题样式：123&lt;style name="AppTheme" parent="BaseTheme"&gt; &lt;item name="android:windowTranslucentStatus"&gt;true&lt;/item&gt; &lt;/style&gt; 然后在 AndroidManifest.xml 文件中使用全局主题样式：1234567&lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="Samples" android:supportsRtl="true" android:name=".MyApplication" android:theme="@style/AppTheme"&gt; 新建一个 layout 布局文件，单独定义 toolbar 内容，在应用中的其他 Activity 界面布局中使用 include 标签潜入引用：123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v7.widget.Toolbar xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/tb_toolbar" android:layout_width="match_parent" android:layout_height="wrap_content" android:minHeight="?actionBarSize" android:background="@color/colorPrimary" android:fitsSystemWindows="true" app:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:title="@string/app_name" app:titleTextColor="@android:color/white"&gt;&lt;/android.support.v7.widget.Toolbar&gt; 这里使用android:fitsSystemWindows=&quot;true&quot;属性解决内容试图向上延伸的问题。实际上，也可以使用 android:paddingTop=&quot;@dimen/toolbar_padding_top&quot; 的方式解决，toolbar_padding_top 间距为状态栏高度，在大多数机器上状态栏高度为 25dp，当然也可以通过代码动态获取状态栏高度并设置到 Toolbar 的 paddingTop 属性上。需要注意的是，这里要做兼容判断，比如在 res/values/dimens.xml 中定义toolbar_padding_top 高度为 0dp，在 res/values-v19/dimens.xml 中为 25dp，确保兼容 Android 4.4 以下版本。 基本上，做到这些就能够实现文章开头处图中的效果。值得注意的是，有时候如果想在 Android 5.0 及以上版本的系统中也做到全透明效果，或者说状态栏与导航栏的颜色一致，还可以做进一步兼容处理，毕竟自 5.0 版本开始，系统对于状态栏背景色的定制提供了更好的 API。如 res/values-v21/styles.xml 中定义： 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;style name="AppTheme" parent="BaseTheme"&gt; &lt;item name="android:colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="android:colorPrimaryDark"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="android:colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 说明一点，使用这种处理方式后，5.0 系统中应用的状态栏背景色可随意定制，同时与使用 &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 样式有所不同的是，该处理方式不会引起内容视图的向上延伸，所以不需要在 layout 布局文件中额外添加 android:fitsSystemWindows=”true” 属性。当然，添加了也无所谓，毕竟还要兼容 4.4 到 5.0 之间的版本。 状态栏白底黑字前面我们说过，虽然说 4.4 版本开始，可以实现透明状态栏效果，也就是可以通过各种手段实现修改状态栏背景色，但是状态栏图标和文字的颜色默认为白色，这个是无法像 iOS 系统那样，根据应用的整体色调动态修改。如果恰好 Toolbar 的背景色为白色，为了保持一致，将状态栏背景色调为白色的话，就会与状态栏的白色内容发生冲突，导致其内容无法凸显，这个体验肯定无法被用户接受。 所以，遇见这种 Toolbar 或者说导航栏背景色为白色的情况，一般有两种处理方式：第一种，不修改状态栏背景色，通常默认为黑色背景白色内容；第二种，修改状态栏背景色为淡黑色，这样既能显示状态栏内容，又能与白色导航栏弱显衔接，比如支付宝 App 就是这么做的： 像上图这种处理方式较黑色状态栏来说，相对缓和一些，那能不能做到修改状态栏内容的颜色呢，比如白底黑字？大家知道，Android 系统是开源的，国内的各家手机厂商都做了一些自己的定制，像部分厂商定制的系统就提供了相应的 API 供开发人员做适配工作。比如，部分厂商就提供了相应的 API 来修改状态栏内容颜色，实现状态栏白底黑字效果，如图： 具体做法就是，在代码中判断系统类型，与提供修改状态内容颜色的系统匹配，使用其特定的 API 操作即可。目前开放这种定制 API 的系统已知有 MIUI 和 Flyme 系统，具体实现代码可参考： 小米 MIUI 6 系统 魅族 Flyme 系统 其实，在 Android 6.0（API 23）及更高的版本上，系统也开始提供了对应的 API 来实现浅色调背景的状态栏效果，可将状态栏图标和文字内容改为黑色样式，实现方式为：12345if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; getWindow().getDecorView().setSystemUiVisibility( View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR); getWindow().setStatusBarColor(Color.TRANSPARENT);&#125; 但是不知国内厂商在定制系统时是否对此有做处理，能否兼容这个 API ？不过，貌似微博 App 是这么做的，大家感兴趣地不妨一试。 注意事项除了上述 Toolbar 与 状态栏在背景色上的衔接，App 中常见还有这样一种设计，以微博个人主页为例，如图所示： 页面顶部的图片内容延伸至状态栏中，这种做法其实就是单独使用 &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt; 样式，不在 layout 布局文件中添加 android:fitsSystemWindows=&quot;true&quot;属性即可。 还有一点，通常我们会在资源文件中定义不同版本的主题样式，再在 标签中统一设置，然后所有的 Activity 都能使用这个主题样式。但存在这样一种情况，Activity 由不同的 Fragment 组成，然后不同 Fragment 在状态栏的呈现上有所不同，比如有的 Fragment 顶部使用 Toolbar 与状态栏衔接，有的顶部直接使用图片延伸至状态栏上甚至不会用到 Toolbar，如图所示： 由于 Fragment 是无法像 Activity 那样在 AndroidManifest.xml 中单独设置主题样式的，所以这里可以这样做：宿主 Activity 还是使用透明样式，以满足图片延伸的 Fragment 页面效果，其他使用 Toolbar 的 Fragment，在其 Layout 布局文件顶部单独定义一个 View，让其延伸至状态栏，然后在代码中根据不同版本系统设置其高度，4.4 版本以下设置该 View 高度为0，4.4 及以上版本设置为设备状态栏高度，通过代码获取状态高度的方式如下：12345678910/** * 获取状态栏高度 * @param activity * @return */public static int getStatusBarHeight(Activity activity)&#123; Rect rect = new Rect(); activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(rect); return rect.top==0 ? 60 : rect.top;&#125; 最后再补充一点，大家知道，长按 Toolbar 中 Menu Item 时会显示一个 Toast 提示，内容来自 Item 定义时对应的 title 属性，通常显示如图所示： 但是，如果你误将 fitsSystemWindows 属性设置在了 style 样式文件中，比如：123&lt;style name="BaseTheme" parent="Theme.AppCompat.Light.NoActionBar"&gt; &lt;item name="android:fitsSystemWindows"&gt;true&lt;/item&gt;&lt;/style&gt; 将会导致下图效果：可见，Menu Options Item 长按时弹出的 Toast 样式没了内容间距，显然很丑。所以，记得将该属性设置在正确的布局文件中，不要设置成全局的。 相关拓展以上便是有关 Android 4.4 开始的状态栏背景色相关知识，可以看出 4.4 、5.0 、6.0 版本作为三个分水岭，根据需要做好相关适配工作即可。还有一种通过 setSystemUiVisibility() 方法设置状态栏的方式，还能实现状态栏的显示与隐藏交互效果，具体可参考这篇文章： http://blog.csdn.net/guolin_blog/article/details/51763825 GitHub 上对于 Android 4.4 版本开始的状态栏背景色的处理有一个开源库，感兴趣地朋友也可借鉴参考一番，地址如下： https://github.com/jgilfelt/SystemBarTint 有关 Toolbar 替换 ActionBar 的使用，可以我之前总结的一篇文章，地址为： http://yifeng.studio/2016/10/12/android-toolbar/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android ViewPager全面剖析及使用详解]]></title>
      <url>%2F2016%2F05%2F02%2Fandroid-viewpager%2F</url>
      <content type="text"><![CDATA[前言ViewPager在开发中的使用频率非常的高，所以在此做个总结。主要包括以下几方面： ViewPager的简介和作用 ViewPager的适配器 ViewPager的翻页动画 简化ViewPager的使用 ViewPager结合第三方库实现小圆点指示器效果 ViewPager结合design库实现tab切换 基于ViewPager实现广告轮播控件 按照惯例，先上个效果图 基础篇1.ViewPager的简介和作用ViewPager是android扩展包v4包中的类，这个类可以让用户左右切换当前的view ViewPager类直接继承了ViewGroup类，所以它是一个容器类，可以在其中添加其他的view类。 ViewPager类需要一个PagerAdapter适配器类给它提供数据。 ViewPager经常和Fragment一起使用，并且提供了专门的FragmentPagerAdapter和FragmentStatePagerAdapter类供Fragment中的ViewPager使用。 关于ViewPager，我们先来看看api中的继承关系 从图里可以看出，ViewPager继承自ViewGroup，也就是ViewPager是一个容器类，可以包含其他的View类。然后我们在看看api中的定义： ViewPager是一个允许使用者左右滑动数据页面的布局管理器。你可以通过一个适配器（PagerAdapter）来管理要显示的页面。不过要注意的是，这个类目前还处于初期的设计和开发。随着今后兼容库的更新，API文档也会进行更改，同时应用程序在编译时也需要对代码进行一定的修改。ViewPager更多的时候会与Fragment一起使用，这是一种很好的方法来管理各个页面的生命周期。Android提供了一些专门的适配器来让ViewPager与Fragment一起工作，也就是FragmentPagerAdapter与FragmentStatePagerAdapter。他们基本上可以满足大部分常见的永续需求，并且他们都有简单的代码样例来展示如何用他们来建立一个完整的用户页面。 通过这一段描述，大家应该对ViewPager有了一个大致的了解，把常用的信息再总结一下： ViewPager主要用来左右滑动。（类似图片轮播） ViewPager要用适配器来连接“视图”和“数据”。（大家可以联想下listview的使用方法，原理是类似的） 官方推荐ViewPager与Fragment一起使用，并且有专门的适配器。 2.ViewPager的适配器简介中提到了PagerAdapter，和ListView等控件使用一样,需要ViewPager设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是一个基类适配器，我们经常用它来实现app引导图，它的子类有FragmentPagerAdapter和FragmentStatePagerAdapter,这两个子类适配器用于和Fragment一起使用，在安卓应用中它们就像listview一样出现的频繁。 我们先来看看API中对PagerAdapter的描述： Base class providing the adapter to populate pages inside of a ViewPager. You will most likely want to use a more specific implementation of this, such as FragmentPagerAdapter or FragmentStatePagerAdapter.When you implement a PagerAdapter, you must override the following methods at minimum:instantiateItem(ViewGroup, int)destroyItem(ViewGroup, int, Object)getCount()isViewFromObject(View, Object)PagerAdapter is more general than the adapters used for AdapterViews. Instead of providing a View recycling mechanism directly ViewPager uses callbacks to indicate the steps taken during an update. A PagerAdapter may implement a form of View recycling if desired or use a more sophisticated method of managing page Views such as Fragment transactions where each page is represented by its own Fragment.ViewPager associates each page with a key Object instead of working with Views directly. This key is used to track and uniquely identify a given page independent of its position in the adapter. A call to the PagerAdapter method startUpdate(ViewGroup) indicates that the contents of the ViewPager are about to change. One or more calls to instantiateItem(ViewGroup, int) and/or destroyItem(ViewGroup, int, Object) will follow, and the end of an update will be signaled by a call to finishUpdate(ViewGroup). By the time finishUpdate returns the views associated with the key objects returned by instantiateItem should be added to the parent ViewGroup passed to these methods and the views associated with the keys passed to destroyItem should be removed. The method isViewFromObject(View, Object) identifies whether a page View is associated with a given key object.A very simple PagerAdapter may choose to use the page Views themselves as key objects, returning them from instantiateItem(ViewGroup, int) after creation and adding them to the parent ViewGroup. A matching destroyItem(ViewGroup, int, Object) implementation would remove the View from the parent ViewGroup and isViewFromObject(View, Object) could be implemented as return view == object;.PagerAdapter supports data set changes. Data set changes must occur on the main thread and must end with a call to notifyDataSetChanged() similar to AdapterView adapters derived from BaseAdapter. A data set change may involve pages being added, removed, or changing position. The ViewPager will keep the current page active provided the adapter implements the method getItemPosition(Object). 大致的翻译： PagerAdapter是用于“将多个页面填充到ViewPager”的适配器的一个基类，大多数情况下，你们可能更倾向于使用一个实现了PagerAdapter并且更加具体的适配器，例如FragmentPagerAdapter或者FragmentStatePagerAdapter。当你实现一个PagerAdapter时，你至少需要重写下面的几个方法：instantiateItem(ViewGroup, int)destroyItem(ViewGroup, int, Object)getCount()isViewFromObject(View, Object)PagerAdapter比很多AdapterView的适配器更加通用。ViewPager使用回调机制来显示一个更新步骤，而不是直接使用视图回收机制。如果需要时，PagerAdapter也可以实现视图回收方法，或者直接使用一种更加巧妙的方法来管理页面，比如直接使用能够管理自身事务的Fragment。ViewPager并不直接管理页面，而是通过一个key将每个页面联系起来。这个key用来跟踪和唯一标识一个给定的页面，且该key独立于adapter之外。PagerAdapter中的startUpdate(ViewGroup)方法一旦被执行，就说明ViewPager的内容即将开始改变。紧接着，instantiateItem(ViewGroup, int)和/或destroyItem(ViewGroup, int, Object)方法将会被执行，然后finishUpdate(ViewGroup)的执行就意味着这一次刷新的完成。当finishUpdate(ViewGroup)方法执行完时，与instantiateItem(ViewGroup, int)方法返回的key相对应的视图将会被加入到父ViewGroup中，而与传递给destroyItem(ViewGroup, int, Object)方法的key相对应的视图将会被移除。isViewFromObject(View, Object)方法则判断一个视图是否与一个给定的key相对应。一个简单的PagerAdapter会选择将视图本身作为key，在将视图创建并加入父ViewGroup之后通过instantiateItem(ViewGroup, int)返回。这种情况下，destroyItem(ViewGroup, int, Object) 的实现方法只需要将View从ViewGroup中移除即可，而isViewFromObject(View, Object)的实现方法可以直接写成return view == object;。PagerAdapter支持数据集的改变。数据集的改变必须放在主线程中，并且在结束时调用notifyDataSetChanged()方法，这与通过BaseAdapter适配的AdapterView类似。一个数据集的改变包含了页面的添加、移除或者位移。ViewPager可以通过在适配器中实现getItemPosition(Object)方法来保持当前页面处于运行状态。 1234instantiateItem(ViewGroup, int) //负责初始化指定位置的页面，并且需要返回当前页面本身（其实不一定要View本身，只要是能唯一标识该页面的key都可以，不过初学者一般就先用View本身作为key就可以啦）；destroyItem(ViewGroup, int, Object) //负责移除指定位置的页面；isViewFromObject(View, Object) //里直接写“return view == object;”即可（当然，如果你在instantiateItem(ViewGroup, int) //里返回的不是View本身，那就不能这么写哦）；在描述中并未提及到getCount()方法，不过这个比较简单，也很常见，就是返回要展示的页面数量。 实现一个最基本的PagerAdapter,必须实现四个方法，在代码里有注释 12345678910111213141516171819202122232425262728public class AdapterViewpager extends PagerAdapter &#123; private List&lt;View&gt; mViewList; public AdapterViewpager(List&lt;View&gt; mViewList) &#123; this.mViewList = mViewList; &#125; @Override public int getCount() &#123;//必须实现 return mViewList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123;//必须实现 return view == object; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123;//必须实现，实例化 container.addView(mViewList.get(position)); return mViewList.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123;//必须实现，销毁 container.removeView(mViewList.get(position)); &#125;&#125; 实现一个最基本的FragmentPagerAdapter 1234567891011121314151617181920212223public class AdapterFragment extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; mFragments; public AdapterFragment(FragmentManager fm, List&lt;Fragment&gt; mFragments) &#123; super(fm); this.mFragments = mFragments; &#125; @Override public Fragment getItem(int position) &#123;//必须实现 return mFragments.get(position); &#125; @Override public int getCount() &#123;//必须实现 return mFragments.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123;//选择性实现 return mFragments.get(position).getClass().getSimpleName(); &#125;&#125; FragmentStatePagerAdapter的实现和FragmentPagerAdapter的实现一样就不在写了 3个适配器的基本实现讲完了是不是很简单，那他们的区别是什么呢？PagerAdapter是基类适配器是一个通用的ViewPager适配器，相比PagerAdapter，FragmentPagerAdapter和FragmentStatePagerAdapter更专注于每一页是Fragment的情况，而这两个子类适配器使用情况也是有区别的。FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况。为什么？简单分析下两个适配器的源码就可以知道了。 FragmentStatePagerAdapter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 @Override public Object instantiateItem(ViewGroup container, int position) &#123; // If we already have this item instantiated, there is nothing // to do. This can happen when we are restoring the entire pager // from its saved state, where the fragment manager has already // taken care of restoring the fragments we previously had instantiated. if (mFragments.size() &gt; position) &#123; Fragment f = mFragments.get(position);//fragment被释放后这里得到的null值 if (f != null) &#123; return f; &#125; &#125; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; Fragment fragment = getItem(position);//fragment被释放后或者是初次进入页面拿到新的Fragment实例 if (DEBUG) Log.v(TAG, "Adding item #" + position + ": f=" + fragment); if (mSavedState.size() &gt; position) &#123; Fragment.SavedState fss = mSavedState.get(position); if (fss != null) &#123; fragment.setInitialSavedState(fss); &#125; &#125; while (mFragments.size() &lt;= position) &#123; mFragments.add(null); &#125; fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); mFragments.set(position, fragment); mCurTransaction.add(container.getId(), fragment);//新的Fragment实例 是add上去的 return fragment; &#125;@Override public void destroyItem(ViewGroup container, int position, Object object) &#123; Fragment fragment = (Fragment) object; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Removing item #" + position + ": f=" + object + " v=" + ((Fragment)object).getView()); while (mSavedState.size() &lt;= position) &#123; mSavedState.add(null); &#125; mSavedState.set(position, fragment.isAdded() ? mFragmentManager.saveFragmentInstanceState(fragment) : null); mFragments.set(position, null);//真正释放了fragment实例 mCurTransaction.remove(fragment); &#125; FragmentPagerAdapter 12345678910111213141516171819202122232425262728293031323334353637@Overridepublic Object instantiateItem(ViewGroup container, int position) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; final long itemId = getItemId(position); // Do we already have this fragment? String name = makeFragmentName(container.getId(), itemId); Fragment fragment = mFragmentManager.findFragmentByTag(name); if (fragment != null) &#123; if (DEBUG) Log.v(TAG, "Attaching item #" + itemId + ": f=" + fragment); mCurTransaction.attach(fragment);//因为fragment实例没有被真正释放，所以可以直接attach效率高 &#125; else &#123; fragment = getItem(position);//初始化页面的时候拿到fragment的实例 if (DEBUG) Log.v(TAG, "Adding item #" + itemId + ": f=" + fragment); mCurTransaction.add(container.getId(), fragment, makeFragmentName(container.getId(), itemId));//add上去 &#125; if (fragment != mCurrentPrimaryItem) &#123; fragment.setMenuVisibility(false); fragment.setUserVisibleHint(false); &#125; return fragment;&#125;@Overridepublic void destroyItem(ViewGroup container, int position, Object object) &#123; if (mCurTransaction == null) &#123; mCurTransaction = mFragmentManager.beginTransaction(); &#125; if (DEBUG) Log.v(TAG, "Detaching item #" + getItemId(position) + ": f=" + object + " v=" + ((Fragment)object).getView()); mCurTransaction.detach((Fragment)object);//并没有真正释放fragment对象只是detach&#125; 从源码中我们可以看出FragmentStatePagerAdapter中fragment实例在destroyItem的时候被真正释放，所以FragmentStatePagerAdapter省内存。FragmentPagerAdapter中的fragment实例在destroyItem的时候并没有真正释放fragment对象只是detach，所以FragmentPagerAdapter消耗更多的内存，带来的好处就是效率更高一些。所以得出这样的结论：FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况，因此不同的场合选择合适的适配器才是正确的做法 3.ViewPager的翻页动画为ViewPager设置适配器后，就可以正常使用了，接下来我们为ViewPager增加翻页动画，毕竟人的审美会疲劳，加上一些动画交互会提高不少逼格~~，ViewPager提供了PageTransformer接口用于实现翻页动画。官方提供了PageTransformer的实现例子。 12345678910111213141516171819202122232425262728293031323334353637public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; Log.d("DepthPageTransformer", view.getTag() + " , " + position + ""); int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 0) &#123; // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; @SuppressLint("NewApi") public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); Log.e("TAG", view + " , " + position + ""); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 实现翻页动画的关键就是重写transformPage方法，方法里有两个参数view和position,理解这两个参数非常重要。假设有三个页面view1，view2，view3从左至右在viewPager中显示 往左滑动时：view1，view2，view3的position都是不断变小的。 123456 view1的position: 0 → -1 → 负无穷大 view2的position: 1 → 0 → -1 view3的position: 1 → 0``` - **往右滑动时：view1，view2，view3的position都是不断变大的。** view1的position: -1 → 0 view2的position: -1 → 0 → 1 view3的position: 0 → 1→ 正无穷大 12345678910111213141516171819202122232425262728293031323334353637当position是正负无穷大时view就离开屏幕视野了。因此最核心的控制逻辑是在[-1,0]和(0,1]这两个区间，通过设置透明度，平移，旋转，缩放等动画组合可以实现各式各样的页面变化效果。## 4.简化ViewPager的使用这里只是做了最简单的封装，可以根据需要调整- PagerAdapter简化``` javapublic class QuickPageAdapter&lt;T extends View&gt; extends PagerAdapter &#123; private List&lt;T&gt; mList; public QuickPageAdapter(List&lt;T&gt; mList) &#123; this.mList = mList; &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return object == view; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(mList.get(position)); return mList.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(mList.get(position)); &#125;&#125; 使用它，这样不用每次都写个适配器List views = new ArrayList&lt;&gt;();…mViewPager.setAdapter(new QuickPageAdapter(views)); FragmentPagerAdapter简化 123456789101112131415161718192021222324252627282930public class QuickFragmentPageAdapter&lt;T extends Fragment&gt; extends FragmentPagerAdapter &#123; private List&lt;T&gt; mList; private String[] mStrings; /** * @param fm * @param list * @param titles PageTitles */ public QuickFragmentPageAdapter(FragmentManager fm, List&lt;T&gt; list, String[] titles) &#123; super(fm); mList = list; mStrings = titles; &#125; @Override public Fragment getItem(int position) &#123; return mList.get(position); &#125; @Override public int getCount() &#123; return mList.size(); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mStrings == null ? super.getPageTitle(position) : mStrings[position]; &#125;&#125; FragmentStatePagerAdapter封装类似FragmentPagerAdapter就不写了，基本使用讲完了。 5.补充一个知识点mViewPager.setOffscreenPageLimit()//这个方法是用来控制fragment不重新走生命周期的个数的，打个比方一共4个fragment页面，如果mViewPager.setOffscreenPageLimit(3)，那么所有的fragment都只走一次生命周期，如果是mViewPager.setOffscreenPageLimit(2)，那么其中有一个fragment会在切换的时候重新走一遍生命周期，FragmentStatePagerAdapter和FragmentPagerAdapter都是这样，但是FragmentPagerAdapter设置setOffscreenPageLimit不影响fragment缓存的个数,而FragmentStatePagerAdapter缓存的fragment实例个数就是setOffscreenPageLimit设置的值+1。另外setOffscreenPageLimit的缺省值是1，设置0是无效的会被强制赋值成1。 123456789101112private static final int DEFAULT_OFFSCREEN_PAGES = 1; public void setOffscreenPageLimit(int limit) &#123; if (limit &lt; DEFAULT_OFFSCREEN_PAGES) &#123; Log.w(TAG, "Requested offscreen page limit " + limit + " too small; defaulting to " + DEFAULT_OFFSCREEN_PAGES); limit = DEFAULT_OFFSCREEN_PAGES;//强制赋值为1 &#125; if (limit != mOffscreenPageLimit) &#123; mOffscreenPageLimit = limit; populate(); &#125; &#125; 提高1.ViewPager结合第三方库实现小圆点指示器效果https://github.com/ongakuer/CircleIndicator 使用看官方文档很简单。 看一下实现思路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void setViewPager(ViewPager viewPager) &#123; mViewpager = viewPager; if (mViewpager != null &amp;&amp; mViewpager.getAdapter() != null) &#123; mLastPosition = -1; createIndicators(); mViewpager.removeOnPageChangeListener(mInternalPageChangeListener); mViewpager.addOnPageChangeListener(mInternalPageChangeListener);//绑定上内部实现的PageChangeListener mInternalPageChangeListener.onPageSelected(mViewpager.getCurrentItem()); &#125; &#125; private final OnPageChangeListener mInternalPageChangeListener = new OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; &#125; @Override public void onPageSelected(int position) &#123;//这里是动画的核心 if (mViewpager.getAdapter() == null || mViewpager.getAdapter().getCount() &lt;= 0) &#123; return; &#125; if (mAnimatorIn.isRunning()) &#123; mAnimatorIn.end(); mAnimatorIn.cancel(); &#125; if (mAnimatorOut.isRunning()) &#123; mAnimatorOut.end(); mAnimatorOut.cancel(); &#125; View currentIndicator; if (mLastPosition &gt;= 0 &amp;&amp; (currentIndicator = getChildAt(mLastPosition)) != null) &#123;//页面离开屏幕时指示器动画 currentIndicator.setBackgroundResource(mIndicatorUnselectedBackgroundResId); mAnimatorIn.setTarget(currentIndicator); mAnimatorIn.start(); &#125; View selectedIndicator = getChildAt(position); if (selectedIndicator != null) &#123;//页面进入屏幕时指示器动画 selectedIndicator.setBackgroundResource(mIndicatorBackgroundResId); mAnimatorOut.setTarget(selectedIndicator); mAnimatorOut.start(); &#125; mLastPosition = position; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;; 2.ViewPager结合design库实现tab切换在design库中有个TabLayout可以为viewPager加上Tab标题头 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.example.administrator.viewpager.MainActivity"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/mTabLayout" android:layout_width="match_parent" android:layout_height="wrap_content"&gt;&lt;/android.support.design.widget.TabLayout&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/mViewPager" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;/LinearLayout&gt;mTabLayout.setupWithViewPager(mViewPager);//一行代码完成绑定 更多高级的用法包括tab中添加icon等请转至这里传送门 3.基于ViewPager实现广告轮播控件https://github.com/daimajia/AndroidImageSlider 源码分析，省略了部分代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public class SliderLayout extends RelativeLayout&#123; private InfiniteViewPager mViewPager;//这个ViewPager只是修改了setPageTransformer方法去掉了if (Build.VERSION.SDK_INT &gt;= 11) 的限制，结合NineOldDroid库让动画兼容低版本 /** * InfiniteViewPager adapter. */ private SliderAdapter mSliderAdapter;//这个是PagerAdapter /** * &#123;@link com.daimajia.slider.library.Tricks.ViewPagerEx&#125; indicator. */ private PagerIndicator mIndicator;//页面指示器 /** * A timer and a TimerTask using to cycle the &#123;@link com.daimajia.slider.library.Tricks.ViewPagerEx&#125;. */ private Timer mCycleTimer;//用于轮播的定时器 private TimerTask mCycleTask; /** * For resuming the cycle, after user touch or click the &#123;@link com.daimajia.slider.library.Tricks.ViewPagerEx&#125;. */ private Timer mResumingTimer; private TimerTask mResumingTask; /** * &#123;@link com.daimajia.slider.library.Tricks.ViewPagerEx&#125; 's transformer */ private BaseTransformer mViewPagerTransformer;//PageTransformer的封装用于控制页面翻页效果 public SliderLayout(Context context, AttributeSet attrs, int defStyle) &#123;//核心代码，用于初始化ViewPager super(context, attrs, defStyle); mContext = context; LayoutInflater.from(context).inflate(R.layout.slider_layout, this, true); final TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs,R.styleable.SliderLayout, defStyle,0); mTransformerSpan = attributes.getInteger(R.styleable.SliderLayout_pager_animation_span, 1100); mTransformerId = attributes.getInt(R.styleable.SliderLayout_pager_animation, Transformer.Default.ordinal()); mAutoCycle = attributes.getBoolean(R.styleable.SliderLayout_auto_cycle,true); int visibility = attributes.getInt(R.styleable.SliderLayout_indicator_visibility,0); for(PagerIndicator.IndicatorVisibility v: PagerIndicator.IndicatorVisibility.values())&#123; if(v.ordinal() == visibility)&#123; mIndicatorVisibility = v; break; &#125; &#125; mSliderAdapter = new SliderAdapter(mContext); PagerAdapter wrappedAdapter = new InfinitePagerAdapter(mSliderAdapter); mViewPager = (InfiniteViewPager)findViewById(R.id.daimajia_slider_viewpager); mViewPager.setAdapter(wrappedAdapter); mViewPager.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; int action = event.getAction(); switch (action) &#123; case MotionEvent.ACTION_UP: recoverCycle(); break; &#125; return false; &#125; &#125;); attributes.recycle(); setPresetIndicator(PresetIndicators.Center_Bottom); setPresetTransformer(mTransformerId); setSliderTransformDuration(mTransformerSpan,null); setIndicatorVisibility(mIndicatorVisibility); if(mAutoCycle)&#123; startAutoCycle(); &#125; &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; int action = ev.getAction(); switch (action) &#123; case MotionEvent.ACTION_DOWN://手指按下时候暂停轮播 pauseAutoCycle(); break; &#125; return false; &#125; /** * preset transformers and their names */ public enum Transformer&#123;//PageTransformer枚举 Default("Default"), Accordion("Accordion"), Background2Foreground("Background2Foreground"), CubeIn("CubeIn"), DepthPage("DepthPage"), Fade("Fade"), FlipHorizontal("FlipHorizontal"), FlipPage("FlipPage"), Foreground2Background("Foreground2Background"), RotateDown("RotateDown"), RotateUp("RotateUp"), Stack("Stack"), Tablet("Tablet"), ZoomIn("ZoomIn"), ZoomOutSlide("ZoomOutSlide"), ZoomOut("ZoomOut"); private final String name; private Transformer(String s)&#123; name = s; &#125; public String toString()&#123; return name; &#125; public boolean equals(String other)&#123; return (other == null)? false:name.equals(other); &#125; &#125;;&#125; 通过分析我们可以对SliderLayout实现思路小结一下：1.内部持有一个修改过的ViewPager控件，可以兼容低版本的页面转换动画2.内部有一个实现了PagerAdapter的SliderAdapter适配器3.内部持有一个PagerIndicator 页面指示器可供选择4.维护一个定时任务用于控制轮播5.对手势事件进行处理暂停轮播，继续轮播6.提供了很多缺省的PageTransformer方便调用最后在构造函数中初始化ViewPager。 自定义 ViewPager 打造千变万化的图片切换效果ViewPager使用时间长了，他的切换效果容易觉得枯燥，形成一种审美疲劳我们需要改变，学习学习改变ViewPager切换时的效果，实现个性化的图片切换 是不是比传统的效果个性很多，嘿嘿其实很简单，学习完这篇博客，保证你可以自定义切换效果，做出各种丧心病狂的切换 1、制作前的分析观察下效果图，实际上改变的就是切换时的动画，那么简单了，只需要用户在切换时，拿到当前的View和下一个View，然后添加动画是不是就可以了。好，第一步，获取用户切换时的当前View和切换至的目的View。我们再来看一下，如果获取了当前View和目的View，对于动画我们需要缓慢的变化，最好是根据用户的手势滑动。比如上述效果，用户滑动时，目的图片根据用户滑动距离缓缓出现和慢慢变大。好，第二步，设计动画的梯度变化。经过分析，我们总结出两个步骤，下面我们开始一步一步来打造~~ 2、获取用户切换时当前View和切换至的目的View。ViewPager也需要监听用户的手势，所以肯定提供了某个方法。于是纵观ViewPager的方法，发现了一个叫做 onPageScrolled(int position, float positionOffset, int positionOffsetPixels)的方法~~没错就是这个方法：在页面滚动时调用~下面仔细研究下这几个参数：直接说测试结果：在非第一页与最后一页时，滑动到下一页，position为当前页位置；滑动到上一页：position为当前页-1positionOffset 滑动到下一页，[0,1)区间上变化；滑动到上一页：(1,0]区间上变化positionOffsetPixels这个和positionOffset很像：滑动到下一页，[0,宽度)区间上变化；滑动到上一页：(宽度,0]区间上变化第一页时：滑动到上一页position=0 ，其他基本为0 ；最后一页滑动到下一页 position为当前页位置，其他两个参数为0豁然发现，我们需要的步骤的第二步解决了，positionOffset很适合作为，渐变，缩放的控制参数；positionOffsetPixels则可以作为平移等的控制参数。 那么如何获得当前View和目的View呢：分享几个我的歧途： 【错误】我通过getChildAt(position)，getChildAt(position+1)，getChildAt(position-1)获得滑动时，左右的两个View；乍一看，还真觉得不错在代码写出来，再乍效果也出不来错误原因：我们忽略一个特别大的东西，ViewPager的机制，滑动时动态加载和删除View，ViewPager其实只会维持2到3个View，而position的范围基本属于无限~~ 【错误】我通过getCurrentItem获得当前的位置，然后+1，-1获得后一个或者前一个正在窃喜，赶快代码改过来，效果怎么也不对，乱七八糟的仔细观察日志，这个getCurrentItem当用户手指离开的屏幕，Page还在动画执行时，就改变了难怪~整个滑动过程并不是固定的唉，心都碎了~ 【错误】position在整个滑动的过程中是不变化的，而且ViewPager会保存2个或3个View;那么我考虑，如果是第一页、或者最后一页那么我取getChildAt(0)和getChildAt(1)，如果在其他页面则为getChildAt(0),getChildAt(2),然后经过一系列的变化～我想这会总该对了吧，于是我遇到第一问题，第一页的时候，不管左右position都为0，尼玛，这哪个为左View，哪个为右View~~说了这么多错误，大家可以绕过这些弯路，也能从这些弯路里面看出点什么~下面说正确的，其实ViewPager在添加一个View或者销毁一个View时，是我们自己的PageAdapter中控制的，于是我们可以在ViewPager里面维系一个HashMap，然后滑动的时候，通过get（position）取出，比如上述效果，始终是右边的View变化，要么从小到大，要么从大到小那么滑倒下一页：左边的View:map.get(position) ，右边的View : map.get(position+1) .那么滑倒上一页：左边的View : map.get(position) ， 右边的View : map.get(position+1) ， 一样的，因为滑到上一页，position为当前页-1好了，至此，我们分析了且解决了所有步骤。 3、代码MainActivity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.zhy_jazzyviewpager; import android.app.Activity; import android.os.Bundle; import android.support.v4.view.PagerAdapter; import android.view.Menu; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.ImageView.ScaleType; public class MainActivity extends Activity &#123; protected static final String TAG = "MainActivity"; private int[] mImgIds; private MyJazzyViewPager mViewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImgIds = new int[] &#123; R.drawable.a, R.drawable.b, R.drawable.c, R.drawable.d &#125;; mViewPager = (MyJazzyViewPager) findViewById(R.id.id_viewPager); mViewPager.setAdapter(new PagerAdapter() &#123; @Override public boolean isViewFromObject(View arg0, Object arg1) &#123; return arg0 == arg1; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView((View) object); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; ImageView imageView = new ImageView(MainActivity.this); imageView.setImageResource(mImgIds[position]); imageView.setScaleType(ScaleType.CENTER_CROP); container.addView(imageView); mViewPager.setObjectForPosition(imageView, position); return imageView; &#125; @Override public int getCount() &#123; return mImgIds.length; &#125; &#125;); &#125; &#125; 这个很常见的代码，就是初始化ViewPager就没啥可说的了有一点需要注意：在instantiateItem方法，我们多调用了一个mViewPager.setObjectForPosition(imageView, position);其实就是为了给我们的Map存值 主要看自定义的ViewPager 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.example.zhy_jazzyviewpager; import java.util.HashMap; import java.util.LinkedHashMap; import android.content.Context; import android.support.v4.view.ViewPager; import android.util.AttributeSet; import android.util.Log; import android.view.View; import com.nineoldandroids.view.ViewHelper; public class MyJazzyViewPager extends ViewPager &#123; private float mTrans; private float mScale; /** * 最大的缩小比例 */ private static final float SCALE_MAX = 0.5f; private static final String TAG = "MyJazzyViewPager"; /** * 保存position与对于的View */ private HashMap&lt;Integer, View&gt; mChildrenViews = new LinkedHashMap&lt;Integer, View&gt;(); /** * 滑动时左边的元素 */ private View mLeft; /** * 滑动时右边的元素 */ private View mRight; public MyJazzyViewPager(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; // Log.e(TAG, "position=" + position+", positionOffset = "+positionOffset+" ,positionOffsetPixels = " + positionOffsetPixels+" , currentPos = " + getCurrentItem()); //滑动特别小的距离时，我们认为没有动，可有可无的判断 float effectOffset = isSmall(positionOffset) ? 0 : positionOffset; //获取左边的View mLeft = findViewFromObject(position); //获取右边的View mRight = findViewFromObject(position + 1); // 添加切换动画效果 animateStack(mLeft, mRight, effectOffset, positionOffsetPixels); super.onPageScrolled(position, positionOffset, positionOffsetPixels); &#125; public void setObjectForPosition(View view, int position) &#123; mChildrenViews.put(position, view); &#125; /** * 通过过位置获得对应的View * * @param position * @return */ public View findViewFromObject(int position) &#123; return mChildrenViews.get(position); &#125; private boolean isSmall(float positionOffset) &#123; return Math.abs(positionOffset) &lt; 0.0001; &#125; protected void animateStack(View left, View right, float effectOffset, int positionOffsetPixels) &#123; if (right != null) &#123; /** * 缩小比例 如果手指从右到左的滑动（切换到后一个）：0.0~1.0，即从一半到最大 * 如果手指从左到右的滑动（切换到前一个）：1.0~0，即从最大到一半 */ mScale = (1 - SCALE_MAX) * effectOffset + SCALE_MAX; /** * x偏移量： 如果手指从右到左的滑动（切换到后一个）：0-720 如果手指从左到右的滑动（切换到前一个）：720-0 */ mTrans = -getWidth() - getPageMargin() + positionOffsetPixels; ViewHelper.setScaleX(right, mScale); ViewHelper.setScaleY(right, mScale); ViewHelper.setTranslationX(right, mTrans); &#125; if (left != null) &#123; left.bringToFront(); &#125; &#125; &#125; 可以看到，核心代码都是onPageScrolled，我们通过findViewFromObject(position); findViewFromObject(position + 1);分别获取了左右两边的View，然后添加动画效果；当前这个例子添加了两个动画，一个是从0.5放大到1.0或者1.0缩小到0.5，没错由我们的positionOffset提供梯度的变化还有个平移的动画：下一页直接移动到当前屏幕（默认是在右边，可以注释这个效果，怎么运行看看），然后不断的通过positionOffsetPixels抵消原来默认移动时的位移，让用户感觉它就在原地放大缩小好了，这样就实现了你可以随便写自己喜欢的动画效果，比如在默认上面加个淡入淡出或者神马，随便是不是很随意~~我们的布局文件： 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.example.zhy_jazzyviewpager.MyJazzyViewPager android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/id_viewPager" /&gt; &lt;/RelativeLayout&gt; 4、JazzyViewPager的使用其实上面的实现就是github上JazzyViewPager的源码，用法不用说了，就是我们的MainActivity，它内置了大概10来种效果，我们可以通过代码或者布局上面设置动画效果我们上面的例子效果，它叫做Stack；使用JazzViewPager的代码：其实基本一样最后也会贴上JazzyViewPager的源码的下载 MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.jfeinstein.jazzyviewpager; import com.jfeinstein.jazzyviewpager.JazzyViewPager.TransitionEffect; import android.app.Activity; import android.os.Bundle; import android.support.v4.view.PagerAdapter; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.ImageView.ScaleType; public class MainActivity extends Activity &#123; protected static final String TAG = "MainActivity"; private int[] mImgIds; private JazzyViewPager mViewPager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImgIds = new int[] &#123; R.drawable.a, R.drawable.b, R.drawable.c, R.drawable.d &#125;; mViewPager = (JazzyViewPager) findViewById(R.id.id_viewPager); //设置切换效果 mViewPager.setTransitionEffect(TransitionEffect.Stack); mViewPager.setAdapter(new PagerAdapter() &#123; @Override public boolean isViewFromObject(View arg0, Object arg1) &#123; return arg0 == arg1; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView((View) object); &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; ImageView imageView = new ImageView(MainActivity.this); imageView.setImageResource(mImgIds[position]); imageView.setScaleType(ScaleType.CENTER_CROP); container.addView(imageView); mViewPager.setObjectForPosition(imageView, position); return imageView; &#125; @Override public int getCount() &#123; return mImgIds.length; &#125; &#125;); &#125; &#125; 与我们的代码唯一区别就是：//设置切换效果mViewPager.setTransitionEffect(TransitionEffect.Stack);它有12中可选的切换效果，其实就是写了12个切换的动画~~~好了，最后附上一个我比较喜欢的效果：Tablet 实现个性的ViewPager切换动画 实战PageTransformer（兼容Android3.0以下）1、概述本篇博文，将： 介绍如何使用setPageTransformer设置切换动画； 自定义PageTransformer实现个性的切换动画； 该方法在SDK11以下的版本不起作用，我们会对其做一定修改，让其向下兼容。官方示例地址：http://developer.Android.com/training/animation/screen-slide.html 有兴趣的可以去看看~~ 2、setPageTransformer的使用首先我们迅速的实现一个传统的ViewPager效果~ 1、布局文件1234567891011&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;android.support.v4.view.ViewPager android:id="@+id/id_viewpager" android:layout_width="fill_parent" android:layout_height="fill_parent" /&gt; &lt;/RelativeLayout&gt; 2、MainActivity12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.zhy.demo_zhy_08_viewpageranim; import java.util.ArrayList; import java.util.List; import android.app.Activity; import android.os.Bundle; import android.support.v4.view.PagerAdapter; import android.support.v4.view.ViewPager; import android.view.View; import android.view.ViewGroup; import android.view.Window; import android.widget.ImageView; import android.widget.ImageView.ScaleType; public class MainActivity extends Activity &#123; private ViewPager mViewPager; private int[] mImgIds = new int[] &#123; R.drawable.guide_image1, R.drawable.guide_image2, R.drawable.guide_image3 &#125;; private List&lt;ImageView&gt; mImageViews = new ArrayList&lt;ImageView&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); initData(); mViewPager = (ViewPager) findViewById(R.id.id_viewpager); mViewPager.setAdapter(new PagerAdapter() &#123; @Override public Object instantiateItem(ViewGroup container, int position) &#123; container.addView(mImageViews.get(position)); return mImageViews.get(position); &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView(mImageViews.get(position)); &#125; @Override public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; @Override public int getCount() &#123; return mImgIds.length; &#125; &#125;); &#125; private void initData() &#123; for (int imgId : mImgIds) &#123; ImageView imageView = new ImageView(getApplicationContext()); imageView.setScaleType(ScaleType.CENTER_CROP); imageView.setImageResource(imgId); mImageViews.add(imageView); &#125; &#125; &#125; 好了，这样一个传统ViewPager就实现了大家对上面代码应该不会有任何陌生的感觉~运行效果也不用贴图了，大家肯定知道 3、PageTransformerViewPager有个方法叫做：setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer)用于设置ViewPager切换时的动画效果，并且google官方还给出了两个示例。只需要在上述代码中调用setPageTransformer即可添加切换动画效果~~下面演示google的两个PageTransformer的代码，以及运行效果。 1、DepthPageTransformer12345678910111213141516171819202122232425262728293031323334353637public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 0) &#123; // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125; &#125; 调用代码：mViewPager.setPageTransformer(true, new DepthPageTransformer());效果： 2、ZoomOutPageTransformer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.zhy.view; import android.annotation.SuppressLint; import android.support.v4.view.ViewPager; import android.util.Log; import android.view.View; public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; @SuppressLint("NewApi") public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); Log.e("TAG", view + " , " + position + ""); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) //a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0 &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125; &#125; 调用代码：mViewPager.setPageTransformer(true, new ZoomOutPageTransformer()); 效果： 效果图都是google官网上的，我们的测试图会在兼容3.0以下贴出来，不然就重复了~~为ViewPager添加切换就一行代码是不是很happy，可惜是不兼容3.0以下的版本的，该方法的注释上写到：setting a PageTransformer prior to Android 3.0 (API 11) will have no effect 在3.0之前的版本设置此方法是没有效果的，那么下面我们就看如何让其兼容3.0以下版本。 3、版本的向下兼容1、不兼容的原因首先看下为什么不兼容，3.0以下呢？看上面的两个示例代码，代码中View的动画使用的是属性动画，而属性动画是3.0才推出的，那么这么写肯定是不兼容3.0以下了~那么我们首先引入nineoldandroids，让动画先能在3.0以下跑再说：修改DepthPageTransformer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.zhy.view; import com.nineoldandroids.view.ViewHelper; import android.annotation.SuppressLint; import android.support.v4.view.ViewPager; import android.view.View; public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. // view.setAlpha(0); ViewHelper.setAlpha(view, 0); &#125; else if (position &lt;= 0)// a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0 &#123; // [-1,0] // Use the default slide transition when moving to the left page // view.setAlpha(1); ViewHelper.setAlpha(view, 1); // view.setTranslationX(0); ViewHelper.setTranslationX(view, 0); // view.setScaleX(1); ViewHelper.setScaleX(view, 1); // view.setScaleY(1); ViewHelper.setScaleY(view, 1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. // view.setAlpha(1 - position); ViewHelper.setAlpha(view, 1 - position); // Counteract the default slide transition // view.setTranslationX(pageWidth * -position); ViewHelper.setTranslationX(view, pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - position); // view.setScaleX(scaleFactor); ViewHelper.setScaleX(view, scaleFactor); // view.setScaleY(1); ViewHelper.setScaleY(view, scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. // view.setAlpha(0); ViewHelper.setAlpha(view, 1); &#125; &#125; &#125; 很简单，把所有属性动画换成ViewHelper去设置就好了。现在我们去3.0以下的机子上去运行，发现还是没有效果~~为什么呢？我们再去看看setPageTransformer的源码： 1234567891011121314public void setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) &#123; if (Build.VERSION.SDK_INT &gt;= 11) &#123; final boolean hasTransformer = transformer != null; final boolean needsPopulate = hasTransformer != (mPageTransformer != null); mPageTransformer = transformer; setChildrenDrawingOrderEnabledCompat(hasTransformer); if (hasTransformer) &#123; mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD; &#125; else &#123; mDrawingOrder = DRAW_ORDER_DEFAULT; &#125; if (needsPopulate) populate(); &#125; &#125; 终于发现原因了，原来在此方法内部判断了如果是11以上的版本才让动画生效~~那么，没办法了，如果想兼容，必须修改ViewPager的源码了~~ 2、完美向下兼容我们将ViewPager的源码拷贝一份至我们的项目中，修改名称为ViewPagerCompat；然后注释掉SDK版本判断那一句 1234567891011121314151617public class ViewPagerCompat extends ViewGroup &#123; public void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer) &#123; // if (Build.VERSION.SDK_INT &gt;= 11) &#123; final boolean hasTransformer = transformer != null; final boolean needsPopulate = hasTransformer != (mPageTransformer != null); mPageTransformer = transformer; setChildrenDrawingOrderEnabledCompat(hasTransformer); if (hasTransformer) &#123; mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD; &#125; else &#123; mDrawingOrder = DRAW_ORDER_DEFAULT; &#125; if (needsPopulate) populate(); &#125; &#125; &#125; 注意，所有的PageTransformer使用ViewPager.PageTransformer然后我们把项目中的ViewPager改为ViewPagerCompat；记得修改布局文件，以及MainActivity中的ViewPager为ViewPagerCompat我们在2.3.3的模拟器上测试下效果： 可以看到，我们的切换动画完美的运行在2.3.3的机器上so happy ~~没有ViewPager源码的童鞋不要紧，我会在文末的源码下载中加入ViewPager源码，让你可以尽情去测试当然了，仅仅是兼容当然不能满足我们的好奇心，难道我们做到了兼容，还只能使用Google给的示例动画么我们强大的创新呢下面带领大家分析setPageTransformer方法，然后设计一个个性的动画切换效果 4、自定义PageTransformer实现个性切换动画123456789101112public interface PageTransformer &#123; /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ public void transformPage(View page, float position); &#125; 可以看到该接口只有一个方法，第一个是我们的view，第二个是position~~当我们滑动时：会打印出当然ViewPager中存活的每个View以及它们的position的变化注意是每一个，所以建议别只log position，不然你会觉得莫名其妙的输出position的可能性的值有，其实从官方示例的注释就能看出：[-Infinity,-1) 已经看不到了(1,+Infinity] 已经看不到了 [-1,1]重点看[-1,1]这个区间 ， 其他两个的View都已经看不到了~~ 假设现在ViewPager在A页现在滑出B页，则:A页的position变化就是( 0, -1]B页的position变化就是[ 1 , 0 ]知道了我们滑动时position的变化~~那么就开始设计我们的个性的切换效果；官方给的例子，有变化透明度、偏移量、缩放的，我们准备来个不一样的，我们变化角度，即rotation;大概的效果是这样的： 下面我们分析代码：我们设置View的旋转中心为：ViewHelper.setPivotX(view, view.getMeasuredWidth() 0.5f);ViewHelper.setPivotY(view, view.getMeasuredHeight());依然是ViewPager在A页现在滑出B页那么A页应当在滑动过程中0度到-20度的偏移，B页应当在滑动过程中+20度到0度的偏移结合A页的position变化就是( 0, -1]B页的position变化就是[ 1 , 0 ]那么旋转的角度即：mRot = (20 position); A页 mRot :0 ,~ -20 ; B页 mRot :20 ~ 0 ;瞬间觉得好简单：完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.zhy.view; import com.nineoldandroids.view.ViewHelper; import android.annotation.SuppressLint; import android.support.v4.view.ViewPager; import android.util.Log; import android.view.View; public class RotateDownPageTransformer implements ViewPager.PageTransformer &#123; private static final float ROT_MAX = 20.0f; private float mRot; public void transformPage(View view, float position) &#123; Log.e("TAG", view + " , " + position + ""); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. ViewHelper.setRotation(view, 0); &#125; else if (position &lt;= 1) // a页滑动至b页 ； a页从 0.0 ~ -1 ；b页从1 ~ 0.0 &#123; // [-1,1] // Modify the default slide transition to shrink the page as well if (position &lt; 0) &#123; mRot = (ROT_MAX * position); ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f); ViewHelper.setPivotY(view, view.getMeasuredHeight()); ViewHelper.setRotation(view, mRot); &#125; else &#123; mRot = (ROT_MAX * position); ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f); ViewHelper.setPivotY(view, view.getMeasuredHeight()); ViewHelper.setRotation(view, mRot); &#125; // Scale the page down (between MIN_SCALE and 1) // Fade the page relative to its size. &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. ViewHelper.setRotation(view, 0); &#125; &#125; &#125; 你没看错，if else 里面代码是一样的，为了好理解特意没有合并到一起~~ 到此，我们从setPageTransformer使用，到修改ViewPager做到向下兼容，直至自己定义出个性的切换效果 都已经介绍完毕～～大家可以发挥自己的创造力，做出各种神奇的动画效果，ok，就到这里！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio必备插件整理]]></title>
      <url>%2F2016%2F03%2F15%2Fandroid-studio-plugin%2F</url>
      <content type="text"><![CDATA[前言Android studio常用插件，可极大简化开发，增强开发效率。 1 Android ButterKnife ZeleznyButterKnife 注解生成器，使用起来非常简单方便，使用ButterKnife的有福了！配合ButterKnife实现注解，从此不用写findViewById，想着就爽啊。在Activity，Fragment，Adapter中选中布局xml的资源id自动生成butterknife注解。 2 SelectorChapek for Android设计师给我们提供好了各种资源，每个按钮都要写一个selector是不是很麻烦？这么这个插件就为解决这个问题而生，你只需要做的是告诉设计师们按照规范命名就好了，其他一键搞定。按照不同状态(normal、pressed)的标准命名后，右键文件树Generate Android Selectors见inmite/android-selector-chapek · GitHub。 通过资源文件命名自动生成Selector文件。 3 GsonFormat快速将json字符串转换成一个Java Bean，免去我们根据json字符串手写对应Java Bean的过程。现在大多数服务端api都以json数据格式返回，而客户端需要根据api接口生成相应的实体类，这个插件把这个过程自动化了，赶紧使用起来吧。 4 Android Parcelable Code GeneratorAndroid中的序列化有两种方式，分别是实现Serializable接口和Parcelable接口，但在Android中是推荐使用Parcelable，只不过我们这种方式要比Serializable方式要繁琐，那么有了这个插件一切就ok了。JavaBean序列化，快速实现Parcelable接口。 5 Genymotion这个不解释,速度较快的android模拟器!!! 6 Android Code Generator根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。 7 CodeGlance在右边可以预览代码，实现快速定位 8 findBugs-IDEA查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…） 9 ADB WIFI使用wifi无线调试你的app，无需root权限也可参考以下文章：Android wifi无线调试App新玩法ADB WIFI 10 AndroidPixelDimenGeneratorAndroid Studio自动生成dimen.xml文件插件 11 Android Styler根据xml自动生成style代码的插件Usage: copy lines with future style from your layout.xml file paste it to styles.xml file with Ctrl+Shift+D (or context menu) enter name of new style in the modal window your style is prepared! 12 Android Drawable Importer这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片） 13 LeakCanary帮助你在开发阶段方便的检测出内存泄露的问题，使用起来更简单方便。可以参考以下文章：LeakCanary 中文使用说明 14 RemoveButterKnifeButterKnife这个第三方库每次更新之后，绑定view的注解都会改变，从bind,到inject，再到bindview，搞得很多人都不敢升级，一旦升级，就会有巨量的代码需要手动修改，非常痛苦当我们有一些非常棒的代码需要拿到其他项目使用，但是我们发现，那个项目对第三方库的使用是有限制的，我们不能使用butterknife，这时候，我们又得从注解改回findviewbyid针对上面的两种情况，如果view比较少还好说，如果有几十个view，那么我们一个个的手动删除注解，写findviewbyid语句，简直是一场噩梦（别问我为什么知道这是噩梦）所以，这种有规律又重复简单的工作为什么不能用一个插件来实现呢？于是RemoveButterKnife的想法就出现了。具体介绍 15 AndroidProguardPlugin一键生成项目混淆代码插件，值得你安装~(不过目前可能有些第三方项目的混淆还未添加完全) 16 Sexy Editor设置AS代码编辑区的背景图 17 folding-plugin布局文件分组的插件 18 Android-DPI-CalculatorDPI计算插件使用：或者： 19 Android Studio Prettify可以将代码中的字符串写在string.xml文件中选中字符串鼠标右键选择图中所示这个插件还可以自动书写findViewById 20 Material Theme UI添加Material主题到你的AS 21 CheckStyle-IDEACheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。 22 ECTranslationAndroid Studio Plugin,Translate English to Chinese. Android Studio 翻译插件,可以将英文翻译为中文。 23 WakaTime记录你在IDE上的工作时间 24 AndroidWiFiADB无线调试应用 25 AndroidLocalizationer可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件 26 TranslationPlugin又一翻译插件,可中英互译。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义控件——绘图]]></title>
      <url>%2F2016%2F01%2F11%2Fandroid-draw%2F</url>
      <content type="text"><![CDATA[前言之前学习了Android自定义控件的动画，得到了很大的提升。所以赶紧学习学习自定义控件的绘图，把以前的知识整理整理，研究研究Android的各种特效，android的特效真是其它平台无法比拟的，而且一个漂亮的UI交互，会给APP增色不少。 一、概述及基本几何图形绘制一、Paint和Canvas像我们平时画图一样，需要两个工具，纸和笔。Paint就是相当于笔，而Canvas就是纸，这里叫画布。 所以，凡有跟要要画的东西的设置相关的，比如大小，粗细，画笔颜色，透明度，字体的样式等等，都是在Paint里设置；同样，凡是要画出成品的东西，比如圆形，矩形，文字等相关的都是在Canvas里生成。 1、Paint的基本设置函数 paint.setAntiAlias(true);//抗锯齿功能 paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 Paint.Style.FILL :填充内部 Paint.Style.FILL_AND_STROKE ：填充内部和描边 Paint.Style.STROKE ：仅描边 paint.setStrokeWidth(30);//设置画笔宽度 paint.setShadowLayer(float radius, float dx, float dy, int color);//设置阴影，radius:阴影的倾斜度，dx:水平位移，dy:垂直位移 2、示例1、首先新建一个工程，把默认的XML改成FrameLayout布局，布局代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/root" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.example.try_paint_blog.MainActivity" &gt; &lt;/FrameLayout&gt; ``` **这里有个特别要注意的地方，给根结点FrameLayout加一个ID号，后面用来在它的内部添加视图用的**#### 2、然后新建一个视图类，派生自View，想要自由实现的东西，都在onDraw()函数中绘制返回``` javapublic class MyView extends View &#123; Context m_context; public MyView(Context context) &#123; super(context); // TODO Auto-generated constructor stub m_context=context; &#125; //重写OnDraw（）函数，在每次重绘时自主实现绘图 @Override protected void onDraw(Canvas canvas) &#123; // TODO Auto-generated method stub super.onDraw(canvas); //设置画笔基本属性 Paint paint=new Paint(); paint.setAntiAlias(true);//抗锯齿功能 paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 Style.FILL/Style.FILL_AND_STROKE/Style.STROKE paint.setStrokeWidth(5);//设置画笔宽度 paint.setShadowLayer(10, 15, 15, Color.GREEN);//设置阴影 //设置画布背景颜色 canvas.drawRGB(255, 255,255); //画圆 canvas.drawCircle(190, 200, 150, paint); &#125; &#125; 3、视图类写好了，下面就要将其加入到Activity中，让它显示出来，在MainActiviy中添加如下代码：123456789101112public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); FrameLayout root=(FrameLayout)findViewById(R.id.root); root.addView(new MyView(MainActivity.this)); &#125; &#125; 三、基本几何图形绘制1、画直线void drawLine (float startX, float startY, float stopX, float stopY, Paint paint) startX:开始点X坐标 startY:开始点Y坐标 stopX:结束点X坐标 stopY:结束点Y坐标 123456Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(5);//设置画笔宽度 canvas.drawLine(100, 100, 200, 200, paint); 2、多条直线void drawLines (float[] pts, Paint paint) void drawLines (float[] pts, int offset, int count, Paint paint) pts:是点的集合，大家下面可以看到，这里不是形成连接线，而是每两个点形成一条直线，pts的组织方式为｛x1,y1,x2,y2,x3,y3,……｝ 1234567Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(5);//设置画笔宽度 float []pts=&#123;10,10,100,100,200,200,400,400&#125;; canvas.drawLines(pts, paint); 3、点void drawPoint (float x, float y, Paint paint); float X：点的X坐标 float Y：点的Y坐标 123456Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 canvas.drawPoint(100, 100, paint); 4、多个点void drawPoints (float[] pts, Paint paint) void drawPoints (float[] pts, int offset, int count, Paint paint) float[] pts:点的合集，与上面直线一直，样式为｛x1,y1,x2,y2,x3,y3,……｝ int offset:集合中跳过的数值个数，注意不是点的个数！一个点是两个数值； count:参与绘制的数值的个数，指pts[]里的数值个数，而不是点的个数，因为一个点是两个数值 1234567Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 float []pts=&#123;10,10,100,100,200,200,400,400&#125;; canvas.drawPoints(pts, 2, 4, paint); 同样是上面的四个点：（10，10）、（100，100），（200，200），（400，400），drawPoints里路过前两个数值，即第一个点跳过，画出后面四个数值代表的点，即第二，第三个点。最后第四个点没画。 5、矩形工具类RectF与Rect这两个都是矩形辅助类，区别不大，用哪个都行，根据四个点构建一个矩形结构；在画图时，利用这个矩形结构可以画出对应的矩形或者与其它图形Region相交、相加等等； RectF构造函数有下面四个，但最常用的还是第二个，根据四个点构造出一个矩形； RectF() RectF(float left, float top, float right, float bottom) RectF(RectF r) RectF(Rect r) Rect构造函数如下，最常用的也是根据四个点来构造矩形 Rect() Rect(int left, int top, int right, int bottom) Rect(Rect r) 6、矩形void drawRect (float left, float top, float right, float bottom, Paint paint) void drawRect (RectF rect, Paint paint) void drawRect (Rect r, Paint paint) 第一个的写法是直接传入矩形的四个点，画出矩形 第二、三个构造函数是根据传入RectF或者Rect矩形变量来指定所画的矩形的 123456789101112Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 canvas.drawRect(10, 10, 100, 100, paint);//直接构造 RectF rect = new RectF(120, 10, 210, 100); canvas.drawRect(rect, paint);//使用RectF构造 Rect rect2 = new Rect(230, 10, 320, 100); canvas.drawRect(rect2, paint);//使用Rect构造 7、圆角矩形void drawRoundRect (RectF rect, float rx, float ry, Paint paint) RectF rect:要画的矩形 float rx:生成圆角的椭圆的X轴半径 float ry:生成圆角的椭圆的Y轴半径 1234567Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 RectF rect = new RectF(100, 10, 300, 100); canvas.drawRoundRect(rect, 20, 10, paint); 8、圆形void drawCircle (float cx, float cy, float radius, Paint paint) float cx：圆心点X轴坐标 float cy：圆心点Y轴坐标 float radius：圆的半径 123456Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.FILL);//设置填充样式 paint.setStrokeWidth(15);//设置画笔宽度 canvas.drawCircle(150, 150, 100, paint); 9、椭圆椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，矩形的宽为椭圆的Y轴，建立的椭圆图形 void drawOval (RectF oval, Paint paint) RectF oval：用来生成椭圆的矩形 12345678910Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.STROKE);//填充样式改为描边 paint.setStrokeWidth(5);//设置画笔宽度 RectF rect = new RectF(100, 10, 300, 100); canvas.drawRect(rect, paint);//画矩形 paint.setColor(Color.GREEN);//更改画笔颜色 canvas.drawOval(rect, paint);//同一个矩形画椭圆 10、弧弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以弧当然也是根据矩形来生成的； void drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) RectF oval:生成椭圆的矩形 float startAngle：弧开始的角度，以X轴正方向为0度 float sweepAngle：弧持续的角度 boolean useCenter:是否有弧的两边，True，还两边，False，只有一条弧 12345678910Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.STROKE);//填充样式改为描边 paint.setStrokeWidth(5);//设置画笔宽度 RectF rect1 = new RectF(100, 10, 300, 100); canvas.drawArc(rect1, 0, 90, true, paint); RectF rect2 = new RectF(400, 10, 600, 100); canvas.drawArc(rect2, 0, 90, false, paint); 四、路径及文字1、路径canvas中绘制路径利用： void drawPath (Path path, Paint paint); 1、直线路径void moveTo (float x1, float y1):直线的开始点；即将直线路径的绘制点定在（x1,y1）的位置； void lineTo (float x2, float y2)：直线的结束点，又是下一次绘制直线路径的开始点；lineTo（）可以一直用； void close ():如果连续画了几条直线，但没有形成闭环，调用Close()会将路径首尾点连接起来，形成闭环； 1234567891011121314Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.STROKE);//填充样式改为描边 paint.setStrokeWidth(5);//设置画笔宽度 Path path = new Path(); path.moveTo(10, 10); //设定起始点 path.lineTo(10, 100);//第一条直线的终点，也是第二条直线的起点 path.lineTo(300, 100);//画第二条直线 path.lineTo(500, 100);//第三条直线 path.close();//闭环 canvas.drawPath(path, paint); 2、矩形路径void addRect (float left, float top, float right, float bottom, Path.Direction dir) void addRect (RectF rect, Path.Direction dir) Path.Direction有两个值： Path.Direction.CCW：是counter-clockwise缩写，指创建逆时针方向的矩形路径； Path.Direction.CW：是clockwise的缩写，指创建顺时针方向的矩形路径； 123456789101112131415161718192021//先创建两个大小一样的路径 //第一个逆向生成 Path CCWRectpath = new Path(); RectF rect1 = new RectF(50, 50, 240, 200); CCWRectpath.addRect(rect1, Direction.CCW); //第二个顺向生成 Path CWRectpath = new Path(); RectF rect2 = new RectF(290, 50, 480, 200); CWRectpath.addRect(rect2, Direction.CW); //先画出这两个路径 canvas.drawPath(CCWRectpath, paint); canvas.drawPath(CWRectpath, paint); //依据路径写出文字 String text="风萧萧兮易水寒，壮士一去兮不复返"; paint.setColor(Color.GRAY); paint.setTextSize(35); canvas.drawTextOnPath(text, CCWRectpath, 0, 18, paint);//逆时针生成 canvas.drawTextOnPath(text, CWRectpath, 0, 18, paint);//顺时针生成 路径的顺序对文字的显示方向有影响 3、圆角矩形路径void addRoundRect (RectF rect, float[] radii, Path.Direction dir) void addRoundRect (RectF rect, float rx, float ry, Path.Direction dir) 第一个构造函数：可以定制每个角的圆角大小： 第二个构造函数：只能构建统一圆角大小 123456789Path path = new Path(); RectF rect1 = new RectF(50, 50, 240, 200); path.addRoundRect(rect1, 10, 15 , Direction.CCW); RectF rect2 = new RectF(290, 50, 480, 200); float radii[] =&#123;10,15,20,25,30,35,40,45&#125;; path.addRoundRect(rect2, radii, Direction.CCW); canvas.drawPath(path, paint); 4、圆形路径void addCircle (float x, float y, float radius, Path.Direction dir) float x：圆心X轴坐标 float y：圆心Y轴坐标 float radius：圆半径 123Path path = new Path(); path.addCircle(200, 200, 100, Direction.CCW); canvas.drawPath(path, paint); 5、椭圆路径void addOval (RectF oval, Path.Direction dir) RectF oval：生成椭圆所对应的矩形 Path.Direction :生成方式，与矩形一样，分为顺时针与逆时针，意义完全相同，不再重复 1234Path path = new Path(); RectF rect = new RectF(50, 50, 240, 200); path.addOval(rect, Direction.CCW); canvas.drawPath(path, paint); 6、弧形路径void addArc (RectF oval, float startAngle, float sweepAngle) RectF oval：弧是椭圆的一部分，这个参数就是生成椭圆所对应的矩形； float startAngle：开始的角度，X轴正方向为0度 float sweepAngel：持续的度数； 12345678910Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStyle(Style.STROKE);//填充样式改为描边 paint.setStrokeWidth(5);//设置画笔宽度 Path path = new Path(); RectF rect = new RectF(50, 50, 240, 200); path.addArc(rect, 0, 100); canvas.drawPath(path, paint);//画出路径 7、线段轨迹void quadTo (float x1, float y1, float x2, float y2) 2、文字1、Paint的相关设置123456789101112131415//普通设置 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setStyle(Paint.Style.FILL);//绘图样式，对于设文字和几何图形都有效 paint.setTextAlign(Align.CENTER);//设置文字对齐方式，取值：align.CENTER、align.LEFT或align.RIGHT paint.setTextSize(12);//设置文字大小 //样式设置 paint.setFakeBoldText(true);//设置是否为粗体文字 paint.setUnderlineText(true);//设置下划线 paint.setTextSkewX((float) -0.25);//设置字体水平倾斜度，普通斜体字是-0.25 paint.setStrikeThruText(true);//设置带有删除线效果 //其它设置 paint.setTextScaleX(2);//只会将水平方向拉伸，高度不会变 2、canvas绘图方式1、普通水平绘制void drawText (String text, float x, float y, Paint paint)void drawText (CharSequence text, int start, int end, float x, float y, Paint paint)void drawText (String text, int start, int end, float x, float y, Paint paint)void drawText (char[] text, int index, int count, float x, float y, Paint paint) 第一个构造函数：最普通简单的构造函数； 第三、四个构造函数：实现截取一部分字体给图； 第二个构造函数：最强大，因为传入的可以是charSequence类型字体，但是并不可以实现绘制带图片的扩展文字 2、指定个个文字位置void drawPosText (char[] text, int index, int count, float[] pos, Paint paint) void drawPosText (String text, float[] pos, Paint paint) char[] text：要绘制的文字数组 int index:：第一个要绘制的文字的索引 int count：要绘制的文字的个数，用来算最后一个文字的位置，从第一个绘制的文字开始算起 float[] pos：每个字体的位置，同样两两一组，如｛x1,y1,x2,y2,x3,y3……｝ 12345678910111213Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setTextSize(80);//设置文字大小 paint.setStyle(Paint.Style.FILL);//绘图样式，设置为填充 float []pos=new float[]&#123;80,100, 80,200, 80,300, 80,400&#125;; canvas.drawPosText("画图示例", pos, paint);//两个构造函数 3、沿路径绘制void drawTextOnPath (String text, Path path, float hOffset, float vOffset, Paint paint) void drawTextOnPath (char[] text, int index, int count, Path path, float hOffset, float vOffset, Paint paint) float hOffset : 与路径起始点的水平偏移距离 float vOffset : 与路径中心的垂直偏移量 123456789101112131415161718192021222324Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setTextSize(45);//设置文字大小 paint.setStyle(Paint.Style.STROKE);//绘图样式，设置为填充 String string="风萧萧兮易水寒，壮士一去兮不复返"; //先创建两个相同的圆形路径，并先画出两个路径原图 Path circlePath=new Path(); circlePath.addCircle(220,200, 180, Path.Direction.CCW);//逆向绘制,还记得吗,上篇讲过的 canvas.drawPath(circlePath, paint);//绘制出路径原形 Path circlePath2=new Path(); circlePath2.addCircle(750,200, 180, Path.Direction.CCW); canvas.drawPath(circlePath2, paint);//绘制出路径原形 paint.setColor(Color.GREEN); //hoffset、voffset参数值全部设为0，看原始状态是怎样的 canvas.drawTextOnPath(string, circlePath, 0, 0, paint); //第二个路径，改变hoffset、voffset参数值 canvas.drawTextOnPath(string, circlePath2, 80, 30, paint); 3、字体样式设置（Typeface）paint.setTypeface(typeface); Typeface是专门用来设置字体样式的，通过paint.setTypeface()来指定。可以指定系统中的字体样式，也可以指定自定义的样式文件中获取。要构建Typeface时，可以指定所用样式的正常体、斜体、粗体等，如果指定样式中，没有相关文字的样式就会用系统默认的样式来显示，一般默认是宋体。 创建Typeface： Typeface create(String familyName, int style) //直接通过指定字体名来加载系统中自带的文字样式 Typeface create(Typeface family, int style) //通过其它Typeface变量来构建文字样式 Typeface createFromAsset(AssetManager mgr, String path) //通过从Asset中获取外部字体来显示字体样式 Typeface createFromFile(String path)//直接从路径创建 Typeface createFromFile(File path)//从外部路径来创建字体样式 Typeface defaultFromStyle(int style)//创建默认字体 Typeface.NORMAL //正常体 Typeface.BOLD //粗体 Typeface.ITALIC //斜体 Typeface.BOLD_ITALIC //粗斜体 1、使用系统中的字体Typeface defaultFromStyle(int style)//创建默认字体 Typeface create(String familyName, int style) //直接通过指定字体名来加载系统中自带的文字样式 12345678910111213//使用系统自带字体绘制 Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setTextSize(60);//设置文字大小 paint.setStyle(Paint.Style.STROKE);//绘图样式，设置为填充 String familyName = "宋体"; Typeface font = Typeface.create(familyName,Typeface.NORMAL); paint.setTypeface(font); canvas.drawText("欢迎光临Harvic的博客",10,100, paint); 2、自字义字体自定义字体的话，我们就需要从外部字体文件加载我们所需要的字形的，从外部文件加载字形所使用的Typeface构造函数如下面三个： Typeface createFromAsset(AssetManager mgr, String path) //通过从Asset中获取外部字体来显示字体样式 Typeface createFromFile(String path)//直接从路径创建 Typeface createFromFile(File path)//从外部路径来创建字体样式 1234567891011121314//自定义字体，，，迷你简罗卜 Paint paint=new Paint(); paint.setColor(Color.RED); //设置画笔颜色 paint.setStrokeWidth (5);//设置画笔宽度 paint.setAntiAlias(true); //指定是否使用抗锯齿功能，如果使用，会使绘图速度变慢 paint.setTextSize(60);//设置文字大小 paint.setStyle(Paint.Style.FILL);//绘图样式，设置为填充 AssetManager mgr=m_context.getAssets();//得到AssetManager Typeface typeface=Typeface.createFromAsset(mgr, "fonts/jian_luobo.ttf");//根据路径得到Typeface paint.setTypeface(typeface); Log.v("msg",typeface.toString()); canvas.drawText("欢迎光临Harvic的博客",10,100, paint);//两个构造函数 五、区域(Range)一、构造RegionRegion，中文意思即区域的意思，它表示的是canvas图层上的某一块封闭的区域。 1、基本构造函数public Region() //创建一个空的区域 public Region(Region region) //拷贝一个region的范围 public Region(Rect r) //创建一个矩形的区域 public Region(int left, int top, int right, int bottom) //创建一个矩形的区域 第一个还要配合其它函数使用，暂时不提。 第二个构造函数是通过其它的Region来复制一个同样的Region变量 第三个，第四个才是正规常的，根据一个矩形或矩形的左上角和右下角点构造出一个矩形区域 2、间接构造函数 public void setEmpty() //从某种意义上讲置空也是一个构造函数，即将原来的一个区域变量变成了一个空变量，要再利用其它的Set方法重新构造区域。 public boolean set(Region region) //利用新的区域值来替换原来的区域 public boolean set(Rect r) //利用矩形所代表的区域替换原来的区域 public boolean set(int left, int top, int right, int bottom) //根据矩形的两个点构造出矩形区域来替换原来的区域值 public boolean setPath(Path path, Region clip) //根据路径的区域与某区域的交集，构造出新区域，这个后面具体讲解 注意：无论调用Set系列函数的Region是不是有区域值，当调用Set系列函数后，原来的区域值就会被替换成Set函数里的区域。 3、使用SetPath（）构造不规则区域boolean setPath (Path path, Region clip) Path path：用来构造的区域的路径 Region clip：与前面的path所构成的路径取交集，并将两交集设置为最终的区域 指定另一个区域来取共同的交集，当然如果想显示路径构造的区域，Region clip参数可以传一个比Path范围大的多的区域，取完交集之后，当然是Path参数所对应的区域喽。 二、矩形集枚举区域——RegionIterator类RegionIterator类，实现了获取组成区域的矩形集的功能。 RegionIterator(Region region) //根据区域构建对应的矩形集 boolean next(Rect r) //获取下一个矩形，结果保存在参数Rect r中 三、区域的合并、交叉等操作无论是区域还是矩形，都会涉及到与另一个区域的一些操作，比如取交集、取并集等，涉及到的函数有： public final boolean union(Rect r) public boolean op(Rect r, Op op) public boolean op(int left, int top, int right, int bottom, Op op) public boolean op(Region region, Op op) public boolean op(Rect rect, Region region, Op op) 123456789假设用region1 去组合region2 public enum Op &#123; DIFFERENCE(0), //最终区域为region1 与 region2不同的区域 INTERSECT(1), // 最终区域为region1 与 region2相交的区域 UNION(2), //最终区域为region1 与 region2组合一起的区域 XOR(3), //最终区域为region1 与 region2相交之外的区域 REVERSE_DIFFERENCE(4), //最终区域为region2 与 region1不同的区域 REPLACE(5); //最终区域为为region2的区域 &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.graphics.Rect; import android.graphics.Region; import android.graphics.Paint.Style; import android.graphics.Region.Op; import android.graphics.RegionIterator; import android.view.View; public class MyRegionView extends View &#123; public MyRegionView(Context context) &#123; super(context); // TODO Auto-generated constructor stub &#125; @Override protected void onDraw(Canvas canvas) &#123; // TODO Auto-generated method stub super.onDraw(canvas); //构造两个矩形 Rect rect1 = new Rect(100,100,400,200); Rect rect2 = new Rect(200,0,300,300); //构造一个画笔，画出矩形轮廓 Paint paint = new Paint(); paint.setColor(Color.RED); paint.setStyle(Style.STROKE); paint.setStrokeWidth(2); canvas.drawRect(rect1, paint); canvas.drawRect(rect2, paint); //构造两个Region Region region = new Region(rect1); Region region2= new Region(rect2); //取两个区域的交集 region.op(region2, Op.INTERSECT); //再构造一个画笔,填充Region操作结果 Paint paint_fill = new Paint(); paint_fill.setColor(Color.GREEN); paint_fill.setStyle(Style.FILL); drawRegion(canvas, region, paint_fill); &#125; private void drawRegion(Canvas canvas,Region rgn,Paint paint) &#123; RegionIterator iter = new RegionIterator(rgn); Rect r = new Rect(); while (iter.next(r)) &#123; canvas.drawRect(r, paint); &#125; &#125; &#125; 四、其它一些方法123456789101112131415161718192021222324252627/**几个判断方法*/ public native boolean isEmpty();//判断该区域是否为空 public native boolean isRect(); //是否是一个矩阵 public native boolean isComplex();//是否是多个矩阵组合 /**一系列的getBound方法，返回一个Region的边界*/ public Rect getBounds() public boolean getBounds(Rect r) public Path getBoundaryPath() public boolean getBoundaryPath(Path path) /**一系列的判断是否包含某点 和是否相交*/ public native boolean contains(int x, int y);//是否包含某点 public boolean quickContains(Rect r) //是否包含某矩形 public native boolean quickContains(int left, int top, int right, int bottom) //是否没有包含某矩阵形 public boolean quickReject(Rect r) //是否没和该矩形相交 public native boolean quickReject(int left, int top, int right, int bottom); //是否没和该矩形相交 public native boolean quickReject(Region rgn); //是否没和该矩形相交 /**几个平移变换的方法*/ public void translate(int dx, int dy) public native void translate(int dx, int dy, Region dst); public void scale(float scale) //hide public native void scale(float scale, Region dst);//hide 五、裁剪1、概述裁剪Clip，即裁剪Canvas图层，我们绘制的东西，只能在裁剪区域的范围能才能显示出来。裁剪画布是利用Clip系列函数，通过与Rect、Path、Region取交、并、差等集合运算来获得最新的画布形状。除了调用Save、Restore函数以外，这个操作是不可逆的，一但Canvas画布被裁剪，就不能再被恢复！ Clip系列函数如下： boolean clipPath(Path path) boolean clipPath(Path path, Region.Op op) boolean clipRect(Rect rect, Region.Op op) boolean clipRect(RectF rect, Region.Op op) boolean clipRect(int left, int top, int right, int bottom) boolean clipRect(float left, float top, float right, float bottom) boolean clipRect(RectF rect) boolean clipRect(float left, float top, float right, float bottom, Region.Op op) boolean clipRect(Rect rect) boolean clipRegion(Region region) boolean clipRegion(Region region, Region.Op op) 12345678910@Override protected void onDraw(Canvas canvas) &#123; Paint paint=new Paint(); canvas.save(); canvas.clipRect(new Rect(100,100,300,300)); canvas.drawColor(Color.BLUE);//裁剪区域的rect变为蓝色 canvas.drawRect(new Rect(0,0,100,100), paint);//在裁剪的区域之外，不能显示 canvas.drawCircle(150,150, 50, paint);//在裁剪区域之内，能显示 canvas.restore(); &#125; 裁剪并不像Matrix变换，它相对于mutable bitmap的坐标是不会改变的。所以超出裁剪区域的绘制不会被显示 裁剪的保存和回滚：canvas.save()和canvas.restore()不仅对matrix有效，同样对clip有类似的效果。 2、裁剪的方式 最基本的clipRect，裁剪一个矩形 clipPath，裁剪Path包括的范围，Path所包括的范围不是空的才有效。 clipRegion。 clipRegion与clipRect和clipPath要使用当前的matrix进行变换不同。clipRegion不会进行转换。也就是说canvas的matrix对clipRegion没有影响。 3、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ClippingRegion extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(new SampleView(this)); &#125; private class SampleView extends View &#123; private Bitmap mBitmap; private int limitLength = 0; private int width; private int heigth; private static final int CLIP_HEIGHT = 30; private boolean status = HIDE;//显示还是隐藏的状态，最开始为HIDE private static final boolean SHOW = true;//显示图片 private static final boolean HIDE = false;//隐藏图片 public SampleView(Context context) &#123; super(context); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.image1); limitLength = width = mBitmap.getWidth(); heigth = mBitmap.getHeight(); &#125; @Override protected void onDraw(Canvas canvas) &#123; Region region = new Region(); int i = 0; while (i * CLIP_HEIGHT &lt;= heigth) &#123;//计算clip的区域 if (i % 2 == 0) &#123; region.union(new Rect(0, i * CLIP_HEIGHT, limitLength, (i + 1) * CLIP_HEIGHT)); &#125; else &#123; region.union(new Rect(width - limitLength, i * CLIP_HEIGHT, width, (i + 1) * CLIP_HEIGHT)); &#125; i++; &#125; canvas.clipRegion(region); canvas.drawBitmap(mBitmap, 0, 0, new Paint()); if (status == HIDE) &#123;//如果此时是隐藏 limitLength -= 5; if(limitLength&lt;=0) status=SHOW; &#125; else &#123;//如果此时是显示 limitLength += 5; if(limitLength&gt;=width) status=HIDE; &#125; invalidate(); &#125; &#125; &#125; 六、canvas变换与操作一、平移(translate)canvas中有一个函数translate（）是用来实现画布平移的，画布的原状是以左上角为原点，向左是X轴正方向，向下是Y轴正方向. 注意：canvas移动之前设置的(0,0)的图形位置和移动之后设置的(0,0)的图形位置显示结果不一样。 二、屏幕显示与Canvas的关系 调用canvas.drawRect(rect1, paint_green);时，产生一个Canvas透明图层，由于当时还没有对坐标系平移，所以坐标原点是（0，0）；再在系统在Canvas上画好之后，覆盖到屏幕上显示出来，过程如下图： 然后再第二次调用canvas.drawRect(rect1, paint_red);时，又会重新产生一个全新的Canvas画布，但此时画布坐标已经改变了，即向右和向下分别移动了100像素，所以此时的绘图方式为：（合成视图，从上往下看的合成方式） 上图展示了，上层的Canvas图层与底部的屏幕的合成过程，由于Canvas画布已经平移了100像素，所以在画图时是以新原点来产生视图的，然后合成到屏幕上，这就是我们上面最终看到的结果了。我们看到屏幕移动之后，有一部分超出了屏幕的范围，那超出范围的图像显不显示呢，当然不显示了！也就是说，Canvas上虽然能画上，但超出了屏幕的范围，是不会显示的。 总结： 每次调用canvas.drawXXXX系列函数来绘图进，都会产生一个全新的Canvas画布。 如果在DrawXXX前，调用平移、旋转等函数来对Canvas进行了操作，那么这个操作是不可逆的！每次产生的画布的最新位置都是这些操作后的位置。（关于Save()、Restore()的画布可逆问题的后面再讲） 在Canvas与屏幕合成时，超出屏幕范围的图像是不会显示出来的。 三、旋转(Rotate)画布的旋转是默认是围绕坐标原点来旋转的，这里容易产生错觉，看起来觉得是图片旋转了，其实我们旋转的是画布，以后在此画布上画的东西显示出来的时候全部看起来都是旋转的。其实Roate函数有两个构造函数： void rotate(float degrees) void rotate (float degrees, float px, float py) 第一个构造函数直接输入旋转的度数，正数是顺时针旋转，负数指逆时针旋转，它的旋转中心点是原点（0，0） 第二个构造函数除了度数以外，还可以指定旋转的中心点坐标（px,py） 四、缩放(scale)public void scale (float sx, float sy); public final void scale (float sx, float sy, float px, float py); 五、扭曲(skew)void skew (float sx, float sy) float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值 float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值 六、画布的保存与恢复（save()、restore()）我们为了实现一些效果不得不对画布进行操作，但操作完了，画布状态也改变了，这会严重影响到后面的画图操作。如果我们能对画布的大小和状态（旋转角度、扭曲等）进行实时保存和恢复就最好了。 int save() //每次调用Save()函数，都会把当前的画布的状态进行保存，然后放入特定的栈中； void restore() //每当调用Restore()函数，就会把栈中最顶层的画布状态取出来，并按照这个状态恢复当前的画布，并在这个画布上做画。 七、drawText()详解1、概述在canvas在利用drawText绘制文字时，是有规则的，这个规则就是基线！我们先来看一下什么是基线： 也就是说，只要基线的位置定了，那文字的位置必然是定了的！ 2、canvas.drawText()1234567/** * text:要绘制的文字 * x：绘制原点x坐标 * y：绘制原点y坐标 * paint:用来做画的画笔 */ public void drawText(String text, float x, float y, Paint paint) 上面这个构造函数是最常用的drawText方法，传进去一个String对象就能画出对应的文字。但这里有两个参数需要非常注意，表示原点坐标的x和y.很多同学可能会认为，这里传进去的原点参数(x,y)是所在绘制文字所在矩形的左上角的点。但实际上并不是！在(x,y)中最让人捉急的是y坐标，一般而言，(x，y)所代表的位置是所画图形对应的矩形的左上角点。但在drawText中是非常例外的，y所代表的是基线的位置！ 3、paint.setTextAlign(Paint.Align.XXX)paint.setTextAlign()来设置文字在矩形中的相对位置 1234/** * 其中Align的取值为：Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT */ Paint::setTextAlign(Align align); Panit.Align.LEFT:原点在所绘制文字的左边 Paint.Align.CENTER:原点在所绘制文字的中间 Paint.Align.RIGHT:原点在所绘制文字的右边 4、drawText的四线格与FontMetrics1、Text的绘图四线格前面我们讲了基线，其实除了基线，系统在绘制Text时，还是有其它线的，我们来看个图：除了基线以外，如上图所示，另外还有四条线，分别是ascent,descent,top,bottom，他们的意义分别是： ascent: 系统建议的，绘制单个字符时，字符应当的最高高度所在线 descent:系统建议的，绘制单个字符时，字符应当的最低高度所在线 top: 可绘制的最高高度所在线 bottom: 可绘制的最低高度所在线 我们在绘制文字时，ascent是推荐的绘制文字的最高高度，就表示在绘制文字时，尽力要在这个最高高度以下绘制文字。descent是推荐的绘制文字的最底高度线，同样表示是在绘制文字时尽量在这个descent线以上来绘制文字。而top线则指该文字可以绘制的最高高度线，bottom则是表示该文字可以绘制的最低高度线。ascent,descent是系统建议上的绘制高度，而top,bottom则是物理上屏幕最高，最低可以画的高度值。他们的差别与我们上面说的视频处理的安全框和屏幕的道理是一样的。 2、FontMetrics（1）、fontMetrics概述面我们讲了，系统在画文字时的五条线，baseline、ascent、descent、top、bottom我们知道baseline的位置是我们在构造drawText()时的参数y来决定的，那ascent,descent,top,bottom这些线的位置要怎么计算出来呢？Android给我们提供了一个类：FontMetrics，它里面有四个成员变量： FontMetrics::ascent; FontMetrics::descent; FontMetrics::top; FontMetrics::bottom; ascent = ascent线的y坐标 - baseline线的y坐标； descent = descent线的y坐标 - baseline线的y坐标； top = top线的y坐标 - baseline线的y坐标； bottom = bottom线的y坐标 - baseline线的y坐标； ascent = ascent线的y坐标 - baseline线的y坐标；FontMetrics的这几个变量的值都是以baseline为基准的，对于ascent来说，baseline线在ascent线之下，所以必然baseline的y值要大于ascent线的y值，所以ascent变量的值是负的。 descent = descent线的y坐标 - baseline线的y坐标；descent线在baseline线之下，所以必然descent线的y坐标要大于baseline线的y坐标，所以descent变量的值必然是正数。 （2）、得到Text四线格的各线位置 ascent线Y坐标 = baseline线Y坐标 + fontMetric.ascent; descent线Y坐标 = baseline线的y坐标 + fontMetric.descent； top线Y坐标 = baseline线的y坐标 + fontMetric.top； bottom线Y坐标 = baseline线的y坐标 + fontMetric.bottom； （3）、获取FontMetrics对象获取FontMetrics对象是根据paint对象来获取的： 123Paint paint = new Paint(); Paint.FontMetrics fm = paint.getFontMetrics(); Paint.FontMetricsInt fmInt = paint.getFontMetricsInt(); （4）、实例：计算Text四线格位置123456789101112131415161718192021222324252627282930313233343536373839protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int baseLineY = 200; int baseLineX = 0 ; Paint paint = new Paint(); //写文字 paint.setColor(Color.GREEN); paint.setTextSize(120); //以px为单位 paint.setTextAlign(Paint.Align.LEFT); canvas.drawText("harvic\'s blog", baseLineX, baseLineY, paint); //计算各线在位置 Paint.FontMetrics fm = paint.getFontMetrics(); float ascent = baseLineY + fm.ascent; float descent = baseLineY + fm.descent; float top = baseLineY + fm.top; float bottom = baseLineY + fm.bottom; //画基线 paint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint); //画top paint.setColor(Color.BLUE); canvas.drawLine(baseLineX, top, 3000, top, paint); //画ascent paint.setColor(Color.GREEN); canvas.drawLine(baseLineX, ascent, 3000, ascent, paint); //画descent paint.setColor(Color.YELLOW); canvas.drawLine(baseLineX, descent, 3000, descent, paint); //画bottom paint.setColor(Color.RED); canvas.drawLine(baseLineX, bottom, 3000, bottom, paint); &#125; 3、所绘文字宽度、高度和最小矩形获取这部分，我们将讲解如何获取所绘制字符串所占区域的高度、宽度和仅包裹字符串的最小矩形。 1、字符串所占高度和宽度字符串所占高度很容易得到，直接用bottom线所在位置的Y坐标减去top线所在位置的Y坐标就是字符串所占的高度。12345Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int top = baseLineY + fm.top; int bottom = baseLineY + fm.bottom; //所占高度 int height = bottom - top; （2）、宽度宽度是非常容易得到的，直接利用下面的函数就可以得到 int width = paint.measureText(String text); （3）、最小矩形 概述要获取最小矩形，也是通过系统函数来获取的 12345678/** * 获取指定字符串所对应的最小矩形，以（0，0）点所在位置为基线 * @param text 要测量最小矩形的字符串 * @param start 要测量起始字符在字符串中的索引 * @param end 所要测量的字符的长度 * @param bounds 接收测量结果 */ public void getTextBounds(String text, int start, int end, Rect bounds); 得到最小矩形的实际位置 在上面这个图中，我们将黑色矩形平行下移距离Y（黄色线依照的是基线的位置），那么平移后的左上角点的y坐标就是 y2 = y1 + Y;同样的道理，由于paint.getTextBounds（）得到最小矩形的基线是y = 0;那我们直接将这个矩形移动baseline的距离就可以得到这个矩形实际应当在的位置了。所以矩形应当所在实际位置的坐标是： 123456Rect minRect = new Rect(); paint.getTextBounds(text,0,text.length(),minRect); //最小矩形，实际top位置 int minTop = bounds.top + baselineY; //最小矩形，实际bottom位置 int minBottom = bounds.bottom + baselineY; 4、定点写字讲完上面的三部分，这篇文章所要讲的知识点基本就结束了，这部分其实就是应用的范畴了，在这部分中，我们将讲述，当我们设定一个点，如何到得基线位置，进而画出字符串。 1、给定左上顶点绘图这部分，我们假定给出所要绘制矩形的左上角顶点坐标，然后画出这个文字。 在这个图中，我们给定左上角的位置，即(left,top)；我们知道要画文字，drawText（）中传进去的Y坐标是基线的位置，所以我们就必须根据top的位置计算出baseline的位置。我们来看一个公式：FontMetrics.top = top - baseline;所以baseline = top - FontMetrics.top;因为FontMetrics.top是可以得到的，又因为我们的top坐标是给定的，所以通过这个公式就能得到baseline的位置了。下面举个例子来说明一下根据矩形左上项点绘制文字的过程：先看下效果图：在这个效果图中，因为我们会给定矩形左上角顶点(left,top)，所以们先画出top线的位置，然后计算出baseline的位置，并画出来。最后根据baseline把文字写出来。代码如下： 12345678910111213141516171819202122232425262728protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); String text = "harvic\'s blog"; int top = 200; int baseLineX = 0 ; //设置paint Paint paint = new Paint(); paint.setTextSize(120); //以px为单位 paint.setTextAlign(Paint.Align.LEFT); //画top线 paint.setColor(Color.YELLOW); canvas.drawLine(baseLineX, top, 3000, top, paint); //计算出baseLine位置 Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int baseLineY = top - fm.top; //画基线 paint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint); //写文字 paint.setColor(Color.GREEN); canvas.drawText(text, baseLineX, baseLineY, paint); &#125; 这段代码，比较简单，首先是我们给定top给的位置int top = 200;然后根据top线位置计算出baseline所在位置,并画出来。 2、给定中间线位置绘图 在这个图中，总共有四条线：top线，bottom线，baseline和center线；图中center线正是在top线和bottom线的正中间。为了方便推导公式，我另外标了三个距离A,B,C;很显然，距离A和距离C是相等的，都等于文字所在矩形高度以的一半，即：A = C = (bottom - top)/2;又因为bottom = baseline + FontMetrics.bottom;top = baseline+FontMetrics.top;所以，将它们两个代入上面的公式，就可得到：A = C = (FontMetrics.bottom - FontMetrics.top)/2;而距离B,则表示Center线到baseline的距离。很显然距离B = C - (bottom - baseline);又因为FontMetrics.bottom = bottom-baseline;C = A;所以，B = A - FontMetrics.bottom;所以baseline = center + B = center + A - FontMetrics.bottom = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom; 根据上面的推导过程，我们最终可知，当给定中间线center位置以后，baseline的位置为： baseline = center + (FontMetrics.bottom - FontMetrics.top)/2 - FontMetrics.bottom; 12345678910111213141516171819202122232425262728protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); String text = "harvic\'s blog"; int center = 200; int baseLineX = 0 ; //设置paint Paint paint = new Paint(); paint.setTextSize(120); //以px为单位 paint.setTextAlign(Paint.Align.LEFT); //画center线 paint.setColor(Color.YELLOW); canvas.drawLine(baseLineX, center, 3000, center, paint); //计算出baseLine位置 Paint.FontMetricsInt fm = paint.getFontMetricsInt(); int baseLineY = center + (fm.bottom - fm.top)/2 - fm.bottom; //画基线 paint.setColor(Color.RED); canvas.drawLine(baseLineX, baseLineY, 3000, baseLineY, paint); //写文字 paint.setColor(Color.GREEN); canvas.drawText(text, baseLineX, baseLineY, paint); &#125; 二、Path之贝赛尔曲线和手势轨迹、水波纹效果1、手势轨迹利用贝塞尔曲线，我们能实现平滑的手势轨迹效果 2、水波纹效果电池充电时，有些手机会显示水波纹效果，就是这样做出来的。 3、概述在Path中有四个函数与贝赛尔曲线有关：123456//二阶贝赛尔 public void quadTo(float x1, float y1, float x2, float y2) public void rQuadTo(float dx1, float dy1, float dx2, float dy2) //三阶贝赛尔 public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3) public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3) 1、贝赛尔曲线来源在数学的数值分析领域中，贝赛尔曲线（Bézier曲线）是电脑图形学中相当重要的参数曲线。更高维度的广泛化贝塞尔曲线就称作贝塞尔曲面，其中贝塞尔三角是一种特殊的实例。贝塞尔曲线于1962年，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau于1959年运用de Casteljau算法开发，以稳定数值的方法求出贝塞尔曲线。 2、贝赛尔曲线公式1、一阶贝赛尔曲线其公式可概括为： 对应动画演示为： P0为起点、P1为终点，t表示当前时间，B(t)表示公式的结果值。注意，曲线的意义就是公式结果B(t)随时间的变化，其取值所形成的轨迹。在动画中，黑色点表示在当前时间t下公式B(t)的取值。而红色的那条线就不在各个时间点下不同取值的B(t)所形成的轨迹。总而言之：对于一阶贝赛尔曲线，大家可以理解为在起始点和终点形成的这条直线上，匀速移动的点。 2、二阶贝赛尔曲线对应的动画：首先，P0点和P1点形成了一条贝赛尔曲线，还记得我们上面对一阶贝赛尔曲线的总结么：就是一个点在这条直线上做匀速运动；所以P0-P1这条直线上的移动的点就是Q0；同样，P1,P2形成了一条一阶贝赛尔曲线，在这条一阶贝赛尔曲线上，它们的随时间移动的点是Q1最后，动态点Q0和Q1又形成了一条一阶贝赛尔曲线，在它们这条一阶贝赛尔曲线动态移动的点是B而B的移动轨迹就是这个二阶贝赛尔曲线的最终形态。从上面的讲解大家也可以知道，之所以叫它二阶贝赛尔曲线是因为，B的移动轨迹是建立在两个一阶贝赛尔曲线的中间点Q0,Q1的基础上的。在理解了二阶贝赛尔曲线的形成原理以后，我们就不难理解三阶贝赛尔曲线了 3、三阶贝赛尔曲线对应的动画：首先，这里有三条一阶贝赛尔曲线，分别是P0-P1,P1-P2,P2-P3;他们随时间变化的点分别为Q0，Q1，Q2然后是由Q0，Q1，Q2这三个点，再次连接，形成了两条一阶贝赛尔曲线，分别是Q0—Q1,Q1—Q2;他们随时间变化的点为R0,R1同样，R0和R1同样可以连接形成一条一阶贝赛尔曲线，在R0—R1这条贝赛尔曲线上随时间移动的点是B而B的移动轨迹就是这个三阶贝赛尔曲线的最终形状。从上面的解析大家可以看出，所谓几阶贝赛尔曲线，全部是由一条条一阶贝赛尔曲线搭起来的；在上图中，形成一阶贝赛尔曲线的直线是灰色的，形成二阶贝赛尔曲线线是绿色的，形成三阶贝赛尔曲线的线是蓝色的。 4、四阶贝赛尔曲线 5、五阶贝赛尔曲线 3、贝赛尔曲线与PhotoShop钢笔工具这么屌的贝赛尔曲线，在专业绘图工具PhotoShop中当然会有它的踪影，它就是钢笔工具，钢笔工具所使用的路径弯曲效果就是二阶贝赛尔曲线。我来给大家演示一下钢笔工具的用法：我们拿最终成形的图形来看一下为什么钢笔工具是二阶贝赛尔曲线：右图演示的假设某一点t=0.25时，动态点B的位置图同样，这里P0是起始点，P2是终点，P1是控制点；P0-P1、P1-P2形成了第一层的一阶贝赛尔曲线。它们随时间的动态点分别是Q0,Q1动态点Q0,Q1又形成了第二层的一阶贝赛尔曲线，它们的动态点是B.而B的轨迹跟钢笔工具的形状是完全一样的。所以钢笔工具的拉伸效果是使用的二阶贝赛尔曲线！这个图与上面二阶贝赛尔曲线t=0.25时的曲线差不多，大家理解起来难度也不大。这里需要注意的是，我们在使用钢笔工具时，拖动的是P5点。其实二阶贝赛尔曲线的控制点是其对面的P1点，钢笔工具这样设计是当然是因为操作起来比较方便。 4、Android中贝赛尔曲线之quadTopublic void quadTo(float x1, float y1, float x2, float y2) public void rQuadTo(float dx1, float dy1, float dx2, float dy2) public void cubicTo(float x1, float y1, float x2, float y2,float x3, float y3) public void rCubicTo(float x1, float y1, float x2, float y2,float x3, float y3) 在这四个函数中quadTo、rQuadTo是二阶贝赛尔曲线，cubicTo、rCubicTo是三阶贝赛尔曲线。 1、quadTo使用原理public void quadTo(float x1, float y1, float x2, float y2) 参数中(x1,y1)是控制点坐标，(x2,y2)是终点坐标大家可能会有一个疑问：有控制点和终点坐标，那起始点是多少呢整条线的起始点是通过Path.moveTo(x,y)来指定的，而如果我们连续调用quadTo()，前一个quadTo()的终点，就是下一个quadTo()函数的起点；如果初始没有调用Path.moveTo(x,y)来指定起始点，则默认以控件左上角(0,0)为起始点； 1、示例最关键的是如何来确定控制点的位置！前面讲过，PhotoShop中的钢笔工具是二阶贝赛尔曲线，所以我们可以利用钢笔工具来模拟画出这条波浪线来辅助确定控制点的位置。下面我们来看看这个路径轨迹中，控制点分别在哪个位置我们先看P0-P2这条轨迹，P0是起点，假设位置坐标是(100,300)，P2是终点，假充位置坐标是(300,300)；在以P0为起始点，P2为终点这条二阶贝赛尔曲线上，P1是控制点，很明显P1大概在P0,P2中间的位置，所以它的X坐标应该是200，关于Y坐标，我们无法确定，但很明显的是P1在P0,P2点的上方，也就是它的Y值比它们的小，所以根据钢笔工具上面的位置，我们让P1的比P0,P2的小100;所以P1的坐标是（200，200）同理，不难求出在P2,P4这条二阶贝赛尔曲线上，它们的控制点P3的坐标位置应该是(400,400)；P3的X坐标是400是，因为P3点是P2,P4的中间点；与P3与P1距离P0-P2-P4这条直线的距离应该是相等的。P1距离P0-P2的值为100；P3距离P2-P4的距离也应该是100，这样不难算出P3的坐标应该是(400,400)。 自定义View我们知道在动画绘图时，会调用onDraw(Canvas canvas)函数，我们如果重写了onDraw(Canvas canvas)函数，那么我们利用canvas在上面画了什么，就会显示什么。所以我们自定义一个View12345678910111213141516171819202122232425public class MyView extends View &#123; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setStyle(Paint.Style.STROKE); paint.setColor(Color.GREEN); Path path = new Path(); path.moveTo(100,300); path.quadTo(200,200,300,300); path.quadTo(400,400,500,300); canvas.drawPath(path,paint); &#125; &#125; 这里最重要的就是在onDraw(Canvas canvas)中创建Path的过程，我们在上面已经提到，第一个起始点是需要调用path.moveTo(100,300)来指定的，之后后一个path.quadTo的起始点是以前一个path.quadTo的终点为起始点的。有关控制点的位置如何查找，我们上面已经利用钢笔工具给大家讲解了，这里就不再细讲。所以，大家在自定义控件的时候，要多跟UED沟通，看他们是如何来实现这个效果的，如果是用的钢笔工具，那我们也可以效仿使用二阶贝赛尔曲线来实现。 总结整条线的起始点是通过Path.moveTo(x,y)来指定的，如果初始没有调用Path.moveTo(x,y)来指定起始点，则默认以控件左上角(0,0)为起始点；而如果我们连续调用quadTo()，前一个quadTo()的终点，就是下一个quadTo()函数的起点； 5、手指轨迹要实现手指轨迹其实是非常简单的，我们只需要在自定义中拦截OnTouchEvent，然后根据手指的移动轨迹来绘制Path即可。要实现把手指的移动轨迹连接起来，最简单的方法就是直接使用Path.lineTo()就能实现把各个点连接起来。 1、实现方式一：Path.lineTo(x,y)自定义View——MyView 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyView extends View &#123; private Path mPath = new Path(); public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: &#123; mPath.moveTo(event.getX(), event.getY()); return true; &#125; case MotionEvent.ACTION_MOVE: mPath.lineTo(event.getX(), event.getY()); postInvalidate(); break; default: break; &#125; return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); canvas.drawPath(mPath,paint); &#125; public void reset()&#123; mPath.reset(); invalidate(); &#125; &#125; 当用户点击屏幕的时候，我们调用mPath.moveTo(event.getX(), event.getY());然后在用户移动手指时使用mPath.lineTo(event.getX(), event.getY());将各个点串起来。然后调用postInvalidate()重绘；Path.moveTo()和Path.lineTo()的用法，大家如果看了《android Graphics（二）：路径及文字》之后，理解起来应该没什么难度，但这里有两个地方需要注意第一：有关在case MotionEvent.ACTION_DOWN时return true的问题：return true表示当前控件已经消费了下按动作，之后的ACTION_MOVE、ACTION_UP动作也会继续传递到当前控件中；如果我们在case MotionEvent.ACTION_DOWN时return false，那么后序的ACTION_MOVE、ACTION_UP动作就不会再传到这个控件来了。有关动作拦截的知识，后续会在这个系列中单独来讲，大家先期待下吧。第二：这里重绘控件使用的是postInvalidate();而我们以前也有用Invalidate()函数的。这两个函数的作用都是用来重绘控件的，但区别是Invalidate()一定要在UI线程执行，如果不是在UI线程就会报错。而postInvalidate()则没有那么多讲究，它可以在任何线程中执行，而不必一定要是主线程。其实在postInvalidate()就是利用handler给主线程发送刷新界面的消息来实现的，所以它是可以在任何线程中执行，而不会出错。而正是因为它是通过发消息来实现的，所以它的界面刷新可能没有直接调Invalidate()刷的那么快。所以在我们确定当前线程是主线程的情况下，还是以invalide()函数为主。当我们不确定当前要刷新页面的位置所处的线程是不是主线程的时候，还是用postInvalidate为好。这里我是故意用的postInvalidate()，因为onTouchEvent()本来就是在主线程中的，使用Invalidate()是更合适的。 使用Path.lineTo()所存在问题：在画出来的两个点连接处有明显的转折，而且位置横纵坐标变化比较快的位置，看起来跟图片这大后的马赛克一样；利用Path绘图，是不可能出现马赛克的，因为除了Bitmap以外的任何canvas绘图全部都是矢量图，也就是利用数学公式来作出来的图，无论放在多大屏幕上，都不可能会出现马赛克！这里利用Path绘图，之所以看起来像是马赛克是因为这是由各个不同点之间连线写出来的，而之间并没有平滑过渡，所以当坐标变化比较剧烈时，线与线之间的转折就显得特别明显了。所以要想优化这种效果，就得实现线与线之间的平滑过渡，很显然，二阶贝赛尔曲线就是干这个事的。下面我们就利用我们新学的Path.quadTo函数来重新实现下移动轨迹效果。 2、实现方式二（优化）：使用Path.quadTo()函数实现过渡(1)、原理概述我们上面讲了，使用Path.lineTo()的最大问题就是线段转折处不够平滑。Path.quadTo()可以实现平滑过渡，但使用Path.quadTo()的最大问题是，如何找到起始点和结束点。下图中，有用绿点表示的三个点，连成的两条直线，很明显他们转折处是有明显折痕的下面我们在PhotoShop中利用钢笔工具，看如何才能实现这两条线之间的转折从这两个线段中可以看出，我们使用Path.lineTo（）的时候，是直接把手指触点A,B,C给连起来。而钢笔工具要实现这三个点间的流畅过渡，就只能将这两个线段的中间点做为起始点和结束点，而将手指的倒数第二个触点B做为控制点。大家可能会觉得，那这样，在结束的时候，A到P0和P1到C1的这段距离岂不是没画进去？是的，如果Path最终没有close的话，这两段距离是被抛弃掉的。因为手指间滑动时，每两个点间的距离很小，所以P1到C之间的距离可以忽略不计。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MyView extends View &#123; private Path mPath = new Path(); private float mPreX,mPreY; public MyView(Context context) &#123; super(context); &#125; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN:&#123; mPath.moveTo(event.getX(),event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; &#125; case MotionEvent.ACTION_MOVE:&#123; float endX = (mPreX+event.getX())/2; float endY = (mPreY+event.getY())/2; mPath.quadTo(mPreX,mPreY,endX,endY); mPreX = event.getX(); mPreY =event.getY(); invalidate(); &#125; break; default: break; &#125; return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setStyle(Paint.Style.STROKE); paint.setColor(Color.GREEN); paint.setStrokeWidth(2); canvas.drawPath(mPath,paint); &#125; public void reset()&#123; mPath.reset(); postInvalidate(); &#125; &#125; 6、Path.rQuadTo()1、概述public void rQuadTo(float dx1, float dy1, float dx2, float dy2) dx1:控制点X坐标，表示相对上一个终点X坐标的位移坐标，可为负值，正值表示相加，负值表示相减； dy1:控制点Y坐标，相对上一个终点Y坐标的位移坐标。同样可为负值，正值表示相加，负值表示相减； dx2:终点X坐标，同样是一个相对坐标，相对上一个终点X坐标的位移值，可为负值，正值表示相加，负值表示相减； dy2:终点Y坐标，同样是一个相对，相对上一个终点Y坐标的位移值。可为负值，正值表示相加，负值表示相减； 这四个参数都是传递的都是相对值，相对上一个终点的位移值。比如，我们上一个终点坐标是(300,400)那么利用rQuadTo(100,-100,200,100)；得到的控制点坐标是（300+100,400-100）即(500,300)同样，得到的终点坐标是(300+200,400+100)即(500,500)所以下面这两段代码是等价的：利用quadTo定义绝对坐标 path.moveTo(300,400); path.quadTo(500,300,500,500); 与利用rQuadTo定义相对坐标 path.moveTo(300,400); path.rQuadTo(100,-100,200,100) 2、使用rQuadTo实现波浪线1234567891011121314protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Paint paint = new Paint(); paint.setStyle(Paint.Style.STROKE); paint.setColor(Color.GREEN); Path path = new Path(); path.moveTo(100,300); path.rQuadTo(100,-100,200,0); path.rQuadTo(100,100,200,0); canvas.drawPath(path,paint); &#125; 第一句：path.rQuadTo(100,-100,200,0);是建立在（100,300）这个点基础上来计算相对坐标的。所以控制点X坐标=上一个终点X坐标+控制点X位移 = 100+100=200；控制点Y坐标=上一个终点Y坐标+控制点Y位移 = 300-100=200；终点X坐标 = 上一个终点X坐标+终点X位移 = 100+200=300；终点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+0=300;所以这句与path.quadTo(200,200,300,300);对等的第二句：path.rQuadTo(100,100,200,0);是建立在它的前一个终点即(300,300)的基础上来计算相对坐标的！所以控制点X坐标=上一个终点X坐标+控制点X位移 = 300+100=200；控制点Y坐标=上一个终点Y坐标+控制点Y位移 = 300+100=200；终点X坐标 = 上一个终点X坐标+终点X位移 = 300+200=500；终点Y坐标 = 上一个终点Y坐标+控制点Y位移 = 300+0=300;所以这句与path.quadTo(400,400,500,300);对等的最终效果也是一样的。通过这个例子，只想让大家明白一点：rQuadTo(float dx1, float dy1, float dx2, float dy2)中的位移坐标，都是以上一个终点位置为基准来做偏移的！ 3、实现波浪效果 完整的MyView代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyView extends View &#123; private Paint mPaint; private Path mPath; private int mItemWaveLength = 400; private int dx; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPath.reset(); int originY = 300; int halfWaveLen = mItemWaveLength/2; mPath.moveTo(-mItemWaveLength+dx,originY); for (int i = -mItemWaveLength;i&lt;=getWidth()+mItemWaveLength;i+=mItemWaveLength)&#123; mPath.rQuadTo(halfWaveLen/2,-100,halfWaveLen,0); mPath.rQuadTo(halfWaveLen/2,100,halfWaveLen,0); &#125; mPath.lineTo(getWidth(),getHeight()); mPath.lineTo(0,getHeight()); mPath.close(); canvas.drawPath(mPath,mPaint); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(2000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125; &#125; 然后在MyActivity中开始动画： 123456789101112public class MyActivity extends Activity &#123; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); final MyView myView = (MyView)findViewById(R.id.myview); myView.startAnim(); &#125; &#125; 三、Paint之函数大汇总一、基本用法1、概述paint中基本设置的函数 reset() //重置画笔 setColor(int color) //给画笔设置颜色值 setARGB(int a, int r, int g, int b) //同样是设置颜色，但是利用ARGB分开设置 setAlpha(int a) //设置画笔透明度 setStyle(Paint.Style style) //设置画笔样式，取值有 Paint.Style.FILL :填充内部 Paint.Style.FILL_AND_STROKE ：填充内部和描边 Paint.Style.STROKE ：仅描边 setStrokeWidth(float width) //设置画笔宽度 setAntiAlias(boolean aa) //设置画笔是否抗锯齿 上面这些函数，我们在前面几篇已经详细讲过了，难度也都不大，不再细讲。下面几个函数我们是没有讲到过的，下面做下补充 setStrokeCap(Paint.Cap cap) //设置线冒样式，取值有Cap.ROUND(圆形线冒)、Cap.SQUARE(方形线冒)、Paint.Cap.BUTT(无线冒) setStrokeJoin(Paint.Join join) //设置线段连接处样式，取值有：Join.MITER（结合处为锐角）、Join.Round(结合处为圆弧)、Join.BEVEL(结合处为直线) setStrokeMiter(float miter) //设置笔画的倾斜度，90度拿画笔与30拿画笔，画出来的线条样式肯定是不一样的吧。（事实证明，根本看不出来什么区别好吗……囧……） setPathEffect(PathEffect effect) //设置路径样式;取值类型是所有派生自PathEffect的子类：ComposePathEffect, CornerPathEffect, DashPathEffect, DiscretePathEffect, PathDashPathEffect, SumPathEffect （1）、CornerPathEffect——圆形拐角效果它的作用就是将原来Path生硬的直线拐角，变成圆形拐角： public CornerPathEffect(float radius) 它只有一个参数radius：即当前连接两条直线所使用的圆的半径。上面这个图，很清晰的展示了利用半径R=50的圆来代替原来两条直线间的夹角。12345678910111213141516171819Paint paint = new Paint(); paint.setStrokeWidth(4); paint.setColor(Color.GREEN); paint.setStyle(Paint.Style.STROKE); Path path = new Path(); path.moveTo(100,600); path.lineTo(400,100); path.lineTo(700,900); canvas.drawPath(path,paint); paint.setColor(Color.RED); paint.setPathEffect(new CornerPathEffect(100)); canvas.drawPath(path,paint); paint.setColor(Color.YELLOW); paint.setPathEffect(new CornerPathEffect(200)); canvas.drawPath(path,paint); 在这里，我利用Path构造了一个夹角，在同一个位置画了三遍，第一遍是没有添加任何PathEffect的;第二遍，CornerPathEffect的圆半径为100；第三遍CornerPathEffect的圆半径为200；很明显能看出在半径不同情况下，连接位置也是不一样的。 （2）、DashPathEffect——虚线效果 public DashPathEffect(float intervals[], float phase) intervals[]：表示组成虚线的各个线段的长度；整条虚线就是由intervals[]中这些基本线段循环组成的。比如，我们定义new float[] {20,10}；那这个虚线段就是由两段线段组成的，第一个可见的线段长为20，每二个线段不可见，长度为10； 对于intervals[]数组的有两个限定： 长度必须大于等于2；因为必须有一个实线段和一个空线段来组成虚线。 个数必须为偶数，如果是基数，最后一个数字将被忽略；这个很好理解，因为一组虚线的组成必然是一个实线和一个空线成对组成的。 （3）、DiscretePathEffect——离散路径效果同样，图中第一条线是原生的，第二条线加上离散路径效果后的样式。DiscretePathEffect就是将原来路径分隔成定长的线段，然后将每条线段随机偏移一段位置，我们可以用它来模拟一种类似生锈铁丝的效果. public DiscretePathEffect(float segmentLength, float deviation) 第一个参数segmentLength：表示将原来的路径切成多长的线段。如果值为2，那么这个路径就会被切成一段段由长度为2的小线段。所以这个值越小，所切成的小线段越多；这个值越大，所切成的小线段越少。 第二参数deviation：表示被切成的每个小线段的可偏移距离。值越大，就表示每个线段的可偏移距离就越大，就显得越凌乱，值越小，每个线段的可偏移原位置的距离就越小。 12345678910111213141516Paint paint = getPaint(); Path path = getPath(); //第一条原生Path canvas.drawPath(path,paint); //第二条Path canvas.translate(0,200); paint.setPathEffect(new DiscretePathEffect(2,5)); canvas.drawPath(path,paint); //第三条Path canvas.translate(0,200); paint.setPathEffect(new DiscretePathEffect(6,5)); canvas.drawPath(path,paint); //第四条Path canvas.translate(0,200); paint.setPathEffect(new DiscretePathEffect(6,15)); canvas.drawPath(path,paint); 我们这里涉及到一个函数getPath函数就是随机生成一条路径；我们先来看效果，然后再回来看getPath（）的实现 从第二条和第三条相比，可以明显看出，在仅增大segmentLength的情况下，很明显第三条线段所切的子线段要大一些，所以就没有第二条曲线的那么多线段相交所产生的折点，所以相比第二条更顺滑一些，当然铁锈效果就没有第二条那么明显了。第三条和第四条相比，在segmentLength都是6的情况下，在第四条仅增大了deviation参数（偏移距离），从效果图中也明显可以看出每个子线段向外偏移的距离也增大了。 （4）、PathDashPathEffect——印章路径效果它的作用就是用另一个路径图案做为印章，沿着指定路径一个个盖上去。 public PathDashPathEffect(Path shape, float advance, float phase,Style style) Path shape:表示印章路径，比如我们下面示例中的三角形加右上角一个点； float advance：表示两个印章路径间的距离,很容易理解，印章间距离越大，间距就越大。 float phase：路径绘制偏移距离，与上面DashPathEffect中的float phase参数意义相同 Style style：表示在遇到转角时，如何操作印章以使转角平滑过渡，取值有：Style.ROTATE，Style.MORPH，Style.TRANSLATE;Style.ROTATE表示通过旋转印章来过渡转角；Style.MORPH表示通过变形印章来过渡转角；Style.TRANSLATE表示通过位移来过渡转角。这三个效果的具体意义，上面会通过具体示例来分别讲解。 123456789101112131415161718192021Paint paint = getPaint(); //画出原始路径 Path path = new Path(); path.moveTo(100,600); path.lineTo(400,100); path.lineTo(700,900); canvas.drawPath(path,paint); //构建印章路径 Path stampPath = new Path(); stampPath.moveTo(0,20); stampPath.lineTo(10,0); stampPath.lineTo(20,20); stampPath.close(); stampPath.addCircle(0,0,3, Path.Direction.CCW); //使用印章路径效果 canvas.translate(0,200); paint.setPathEffect(new PathDashPathEffect(stampPath,35,0, PathDashPathEffect.Style.TRANSLATE)); canvas.drawPath(path,paint); 在Style不同的情况下，在转角处都如何处理的 12345678910111213141516171819202122232425262728private void drawPathDashPathEffect(Canvas canvas)&#123; Paint paint = getPaint(); Path path = getPath(); canvas.drawPath(path,paint); canvas.translate(0,200); paint.setPathEffect(new PathDashPathEffect(getStampPath(),35,0, PathDashPathEffect.Style.MORPH)); canvas.drawPath(path,paint); canvas.translate(0,200); paint.setPathEffect(new PathDashPathEffect(getStampPath(),35,0, PathDashPathEffect.Style.ROTATE)); canvas.drawPath(path,paint); canvas.translate(0,200); paint.setPathEffect(new PathDashPathEffect(getStampPath(),35,0, PathDashPathEffect.Style.TRANSLATE)); canvas.drawPath(path,paint); &#125; private Path getStampPath()&#123; Path path = new Path(); path.moveTo(0,20); path.lineTo(10,0); path.lineTo(20,20); path.close(); path.addCircle(0,0,3, Path.Direction.CCW); return path; &#125; 这段代码通过getPath()函数随机生成一条路径，并将原始路径和各个Style的路径画出来。第一条是原始路径，第二条的Style是Style.MORPH，第三条是Style.ROTATE，第四条是Style.TRANSLATE； 当Style.MORPH时，就是通过对印章进行变形来过渡转角的 当Style为Style.ROTATE时就是靠旋转印章角度来过渡转角的 当Style为Style.TRANSLATE时，即不会对印章变形也不会对旋转印章角度，而只是通过变改印章的位置来过渡 （5）、ComposePathEffect与SumPathEffect这两个都是用来合并两个特效的。但它们之间是有区别的： public ComposePathEffect(PathEffect outerpe, PathEffect innerpe) ComposePathEffect合并两个特效是有先后顺序的，它会先将第二个参数的PathEffect innerpe的特效作用于路径上，然后再在此加了特效的路径上作用第二个特效。 public SumPathEffect(PathEffect first, PathEffect second) 而SumPathEffect是分别对原始路径分别作用第一个特效和第二个特效。然后再将这两条路径合并，做为最终结果。 1234567891011121314151617181920212223242526272829//画原始路径 Paint paint = getPaint(); Path path = getPath(); canvas.drawPath(path,paint); //仅应用圆角特效的路径 canvas.translate(0,200); CornerPathEffect cornerPathEffect = new CornerPathEffect(100); paint.setPathEffect(cornerPathEffect); canvas.drawPath(path,paint); //仅应用虚线特效的路径 canvas.translate(0,200); DashPathEffect dashPathEffect = new DashPathEffect(new float[]&#123;2,5,10,10&#125;,0); paint.setPathEffect(dashPathEffect); canvas.drawPath(path,paint); //利用ComposePathEffect先应用圆角特效,再应用虚线特效 canvas.translate(0,200); ComposePathEffect composePathEffect = new ComposePathEffect(dashPathEffect,cornerPathEffect); paint.setPathEffect(composePathEffect); canvas.drawPath(path,paint); //利用SumPathEffect,分别将圆角特效应用于原始路径,然后将生成的两条特效路径合并 canvas.translate(0,200); paint.setStyle(Paint.Style.STROKE); SumPathEffect sumPathEffect = new SumPathEffect(cornerPathEffect,dashPathEffect); paint.setPathEffect(sumPathEffect); canvas.drawPath(path,paint); 二、字体相关setTextSize(float textSize) //设置文字大小 setFakeBoldText(boolean fakeBoldText) //设置是否为粗体文字 setStrikeThruText(boolean strikeThruText) //设置带有删除线效果 setUnderlineText(boolean underlineText) //设置下划线 setTextAlign(Paint.Align align) //设置开始绘图点位置 setTextScaleX(float scaleX) //水平拉伸设置 setTextSkewX(float skewX) //设置字体水平倾斜度，普通斜体字是-0.25，可见往右斜 setTypeface(Typeface typeface) //字体样式 1、setLinearText(boolean linearText)设置是否打开线性文本标识；由于文本想要快速绘制出来，必然是需要提前缓存在显存中的，一般而言每个文字需要一个字节的大小来存储它（当然具体需要多少字节与编码方式有关），那如果是长篇文章，可见所需的大小可想而知。我们可以通过setLinearText (true)告诉Android我们不需要这样的文本缓存。但如果我们不用文本缓存，虽然能够省去一些内存空间，但这是以显示速度为代价的。由于这个是API 1的函数，由于当时的android手机的内存大小还是很小的，所以尽量减少内存使用是每个应用的头等大事，在当时的的环境下这个函数还是很有用的。但在今天，内存动不动就是4G以上了，文本缓存的所占的那点内存就微不足道了，没有哪个APP会牺牲性能来减少这点这内存占用了，所以这个函数基本没用了。2、setSubpixelText(boolean subpixelText)表示是否打开亚像素设置来绘制文本。亚像素的概念比较难理解，首先，我们都知道像素，比如一个android手机的分辨率是1280 720，那就是指它的屏幕在垂直方向有1280个像素点，水平方向上有720个像素点。我们知道每个像素点都是一个独立显示一个颜色的个体。所以如果一副图片，在一个屏幕上用了300 100个相素点，而在另一个屏幕上却用了450 150个像素来显示。那么，请问在哪个屏幕上这张图片显示的更清晰？当然是第二个屏幕，因为它使用的像素点更多，所显示的细节更精细。那么问题来了，android设置在出厂时，设定的像素显示都是固定的几个范围：320 480，480 800，720 1280，1080 * 1920等等；那么如何在同样的分辨率的显示器中增强显示清晰度呢？亚像素的概念就油然而生了，亚像素就是把两个相邻的两个像素之间的距离再细分，再插入一些像素，这些通过程序加入的像素就是亚像素。在两个像素间插入的像素个数是通过程序计算出来的，一般是插入两个、三个或四个。所以打开亚像素显示，是可以在增强文本显示清晰度的，但由于插入亚像素是通过程序计算而来的，所以会耗费一定的计算机性能。注意：亚像素是通过程序计算出来模拟插入的，在没有改变硬件构造的情况下，来改善屏幕分辨率大小。亚像素显示，是仅在液晶显示器上使用的一种增强字体清晰度的技术。但这种技术有时会出现问题，用投影仪投射到白色墙壁上，会出出字体显示不正常的情况，而且对于老式的CRT显示器是根本不支持的。在android还没有出现时，windows已经能够支持亚像素显示了，在windows机器中，这个功能叫做ClearType，在以前讲述windows的GDI绘图时，也曾经讲过ClearType的应用效果。 三、其它接下来还剩几个跟图片和测量相关的函数，我们接下来分篇慢慢讲解。1、图像处理： setShader(Shader shader) setShadowLayer(float radius, float dx, float dy, int shadowColor) setDither(boolean dither) setColorFilter(ColorFilter filter) setXfermode(Xfermode xfermode) setFilterBitmap(boolean filter) clearShadowLayer() 2、measure测量相关 breakText(char[] text, int index, int count, float maxWidth, float[] measuredWidth) measureText(String text) 三、Paint之ColorMatrix与滤镜效果一、矩阵概述学过线代的应该都清楚，就不记录了。 二、色彩矩阵对于色彩的存储，Bitmap类使用一个32位的数值来保存。红、绿、蓝及透明度各占8位，每一个色彩分量的取值范围是0-255。透明度为0表示完全透明，为255时，色彩完全可见。 1、色彩信息的矩阵表示四阶表示由于一个色彩信息包含R、G、B、Alpha信息，所以，我们必然要使用一个4阶色彩变换矩阵来修改色彩的每一个分量值：注意：对于色彩变换矩阵，这里的色彩顺序是R、G、B、A而不是A、R、G、B！！！如果想将色彩（0，255，0，255）更改为半透明时，可以使用下面的的矩阵运算来表示： 为什么使用五阶矩阵上面使用四阶矩阵完全可以改变图片的RGBA值了，但考虑一种情况，如果我们只想在原有的R色上增加一些分量呢？这时，我们就得再多加一阶来表示平移变换。所以，一个既包含线性变换，又包含平移变换的组合变换，称为仿射变换。使用四阶的色彩变换矩阵来修改色彩，只能够对色彩的每一个分量值进行乘（除）运算，如果要对这些分量值进行加减法的运算（平移变换），只能通过五阶矩阵来完成。考虑下面这个变换：1、红色分量值更改为原来的2倍；2、绿色分量增加100；则使用4阶矩阵的乘法无法实现，所以，应该在四阶色彩变换矩阵上增加一个“哑元坐标”，来实现所列的矩阵运算: 三、Android中的色彩矩阵1、概述在上面的所有讲解之后，大家也应该看出来了，色彩变换矩阵的表示形式，肯定是五阶的那种，所以大家看一下，在默认情况下，色彩变换矩阵的形式：Android中的色彩矩阵是用ColorMatrics类来表示的。使用ColorMatrix的方法如下1234567ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0.5, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); 2、示例1（单个颜色的蓝色通道输出）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class MyView extends View &#123; private Paint mPaint = new Paint(); private Bitmap bitmap;// 位图 public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); mPaint.setARGB(255,200,100,100); // 绘制原始位图 canvas.drawRect(0,0,500,600,mPaint); canvas.translate(550,0); // 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawRect(0,0,500,600,mPaint); &#125; &#125;``` 在上面中，我们先将图笔颜色值设为(255,200,100,100)，然后对其进行ColorMatrix颜色值运算，把红色和绿色都去掉，仅显示蓝色值；只显示蓝色值的效果在Photoshop中叫做蓝色通道。效果图如下： 左侧是原图，右侧是该图对应的蓝色通道![201702142952620160419090342953.png](http://ohtrrgyyd.bkt.clouddn.com/201702142952620160419090342953.png)这里只是对一个颜色值，而ColorMatrics的最厉害的地方在于，能够很批量地改变图像中的所有颜色值。下面我们就对图像应用ColorMatrics的例子来看看，如果只显示图像中的蓝色通道会怎样#### 3、示例2（图片多颜色的蓝色通道输出）下面我们就举个给Bitmap应用ColorMatrix的例子：``` javapublic class MyView extends View &#123; private Paint mPaint = new Paint(); private Bitmap bitmap;// 位图 public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint.setAntiAlias(true); // 获取位图 bitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 绘制原始位图 canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); canvas.translate(510, 0); // 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); &#125; &#125;``` 这里分两次绘制了一个bitmap，第一次绘制了一个原始图像，然后利用ColorMatrix生成了一个仅包含蓝色的图像，用过PhotoShop的同学应该很清楚这个跟Photoshop中的蓝色通道的效果是一致的。效果图如下：![201702142204420160419090516432.png](http://ohtrrgyyd.bkt.clouddn.com/201702142204420160419090516432.png)**大家注意哦，不要在onDraw里new Paint对象，上节中我为了省事就直接在onDraw（）函数中直接new 了Paint对象，由于onDraw函数在刷新时会连续调用多次，所以如果在其中不断的new对象，会造成程序不断的GC(内存回收)，是会严重影响性能的！在程序中，我有时会了为了方便理解，就直接在onDraw（）中创建对象了，大家在实际应用中一定要杜绝这种应用哦。**#### 四、色彩的几种运算方式##### 1、色彩的平移运算色彩的平移运算，实际上就是色彩的加法运算。其实就是在色彩变换矩阵的最后一行加上某个值；这样可以增加特定色彩的饱和度![201702143469220160419090748183.png](http://ohtrrgyyd.bkt.clouddn.com/201702143469220160419090748183.png)比如，同样是上面的图片，我们给它应用下面的色彩值：``` javaColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 1, 0, 0, 50, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); 在绿色值上添加增量50，即增大绿色的饱和度。效果图如下： 同样，左侧是原图，右侧是增大绿色饱和度后的效果；大家要特别注意的是，由于图片是由一个个像素组成的，所以用每个像素所对应的色彩数组，来乘转换矩阵，结果就是转换后的当前点的颜色值；所以，在应用ColorMatrics后，图片中每个像素的绿色值都增加了50，从小狗脸上也可以看出来，狗脸也变绿了（它可能看到他女朋友跟人家跑了，哈哈）！色彩平移除了增加指定颜色饱和度以外，另一个应用就是色彩反转(PhotoShop中的反相功能) 色彩反转/反相功能色彩反转就是求出每个色彩的补值来做为目标图像的对应颜色值：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; -1,0,0,0,255, 0,-1,0,0,255, 0,0,-1,0,255, 0,0,0 ,1,0 &#125;); 2、色彩的缩放运算色彩的缩放运算其实就是色彩的乘法运算。在色彩矩阵对角线上的分别代表R、G、B、A的几个值，将其分别乘以指定的值。这就是所谓的缩放变换。我们可以针对某一个颜色值进行放大缩小运算，但当对R、G、B、A同时进行放大缩小时，就是对亮度进行调节！看下面的将亮度增大1.2倍的代码：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1.2f, 0, 0, 0, 0, 0, 1.2f, 0, 0, 50, 0, 0, 1.2f, 0, 0, 0, 0, 0, 1.2f, 0, &#125;); 3、缩放变换的特殊应用（通道输出）由于在色彩变换矩阵中，对角线上的数的取值范围是从0-1的，所以当取0时，这个色彩就完全不显示，所以当我们R、G都取0，而独有B取1时，就只显示了蓝色，所形成的图像也就是我们通常说的蓝色通道；看下几个通道输出的效果图：红色通道矩阵123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, &#125;); 绿色通道矩阵123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, &#125;); 蓝色通道矩阵123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, &#125;); 4、色彩的旋转运算RGB色是如何旋转的呢，首先用R、G、B三色建立立体坐标系：所以，我们可以把一个色彩值看成三维空间里的一个点，色彩值的三个分量可以看成该点的坐标（三维坐标）。我们先不考虑，在三个维度综合情况下是怎么旋转的，我们先看看，在某个轴做为Z轴，在另两个轴形成的平面上旋转的情况，下图分析了，在将蓝色轴做为Z轴，仅在红—绿平面上旋转a度的情况：在图中，我们可以看到，在旋转后，原R在R轴的分量变为:原R cosa，但原G分量在旋转后，在R轴上也有了分量，但分量落在了负轴上，所以我们要减去这部分分量，所以最终的结果是最终的R=原R cosa-原G * sina;下面就看下关于几种旋转计算及结果矩阵，（注意：这几个图只标记了原X轴色彩分量的旋转，没有把Y轴色彩分量的旋转标记出来） 绕蓝色轴旋转a度 对应的色彩变换矩阵是 绕红色轴旋转a度 对应的色彩变换矩阵是 绕绿色轴旋转a度 对应的色彩变换矩阵是 当围绕红色轴进行色彩旋转时，由于当前红色轴的色彩是不变的，而仅利用三角函数来动态的变更绿色和蓝色的颜色值。这种改变就叫做色相调节！当围绕红色轴旋转时，是对图片就行红色色相的调节；同理，当围绕蓝色颜色轴旋转时，就是对图片就行蓝色色相调节；当然，当围绕绿色轴旋转时，就是对图片进行绿色色相的调节. 下面我们做一个动态的调节，针对红色色相。 这个效果图表示的是，在滚轮正中间位置时表示旋转角度为0度，最右侧位置表示向正方向旋转180，左侧到底表示负方向旋转180.同理可以得到围绕绿色轴旋转的效果图：最后是，围绕蓝色轴旋转的效果图： 5、色彩的投射运算色彩矩阵运算的公式：其中我把红色运算给单独拉了出来，红色标记的那几个元素a12,a13,a14,在运算中，是利用G、B、A的颜色值的分量来增加红色值的。来看具体的运算：注意：最终结果的220=0.2 100+1 200,可见绿色分量在原有绿色分量的基础上，增加了红色分量值的0.2倍；利用其它色彩分量的倍数来更改自己色彩分量的值，这种运算就叫投射运算。下图阴影部分；对这些值进行修改时，修改所使用的增加值来自于其它色彩分量的信息。色彩投射的一个最简单应用就是变为黑白图片：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0.213f, 0.715f, 0.072f, 0, 0, 0.213f, 0.715f, 0.072f, 0, 0, 0.213f, 0.715f, 0.072f, 0, 0, 0, 0, 0, 1, 0, &#125;); 首先了解一下去色原理：只要把RGB三通道的色彩信息设置成一样；即：R＝G＝B，那么图像就变成了灰色，并且，为了保证图像亮度不变，同一个通道中的R+G+B=1:如：0.213+0.715+0.072＝1；三个数字的由来：0.213, 0.715, 0.072；按理说应该把RGB平分，都是0.3333333。三个数字应该是根据色彩光波频率及色彩心理学计算出来的（本人是这么认为，当然也查询了一些资料，目前尚未找到准确答案）。在作用于人眼的光线中，彩色光要明显强于无色光。对一个图像按RGB平分理论给图像去色的话，人眼就会明显感觉到图像变暗了（当然可能有心理上的原因，也有光波的科学依据）另外，在彩色图像中能识别的一下细节也可能会丢失。所以google最终给我们的颜色值就是上面的比例：0.213, 0.715, 0.072；所以，在给图像去色时我们保留了大量的G通道信息，使得图像不至于变暗或者绿色信息不至于丢失（我猜想）。投射运算的另一个应用是：色彩反色当我们利用色彩矩阵将两个颜色反转，这种操作就叫做色彩反色比如，下面的的将红色和绿色反色（红绿反色） 123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 0,1,0,0,0, 1,0,0,0,0, 0,0,1,0,0, 0,0,0,1,0 &#125;); 左侧的图为原图，右边为红绿反色以后的效果图;从矩阵中可以看出红绿反色的关键在于，第一行用绿色来代替了红色，第二行用红色代替了绿色。类似可以有红蓝反色，绿蓝反色等，对应矩阵难度不大，就不再细讲了。 变旧照片投射运算的另一个应用是照片变旧，对应矩阵如下：123456ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1/2f,1/2f,1/2f,0,0, 1/3f,1/3f,1/3f,0,0, 1/4f,1/4f,1/4f,0,0, 0,0,0,1,0 &#125;); 五、ColorMatrix函数上面讲了利用色彩矩阵的来做一些运算，但这些都是需要特定的色彩设计基础的，Android中ColorMatrix自带了一些函数来帮我们完成一些调整饱和度、色彩旋转等操作的函数，我们就一一来看看 1、构造函数ColorMatrix共有三个构造函数： ColorMatrix() ColorMatrix(float[] src) ColorMatrix(ColorMatrix src) 2、设置、重置函数第一个构造函数ColorMatrix()，需要与其它函数共用才行： public void set(ColorMatrix src) public void set(float[] src) public void reset() 3、setSaturation——设置饱和度上面我们讲过，我们可以通过色彩的平移运算单独增强R,G,B其中一个的饱和度，但当我们需要整体增强图像的饱和度时需要如何来做呢？ColorMatrics给我们提供了一个方法来整体增强图像的饱和度，函数如下： public void setSaturation(float sat) //整体增强颜色饱和度，即同时增强R,G,B的色彩饱和度 参数float sat：表示把当前色彩饱和度放大的倍数。取值为0表示完全无色彩，即灰度图像（黑白图像）；取值为1时，表示色彩不变动；当取值大于1时，显示色彩过度饱和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MyActivity extends Activity &#123; private SeekBar mSeekBar; private ImageView mImageView; private Bitmap mOriginBmp,mTempBmp; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mImageView = (ImageView) findViewById(R.id.img); mSeekBar = (SeekBar)findViewById(R.id.seekbar); mOriginBmp = BitmapFactory.decodeResource(getResources(), R.drawable.dog); mTempBmp = Bitmap.createBitmap(mOriginBmp.getWidth(), mOriginBmp.getHeight(), Bitmap.Config.ARGB_8888); mSeekBar.setMax(20); mSeekBar.setProgress(1); mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; @Override public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; Bitmap bitmap = handleColorMatrixBmp(progress); mImageView.setImageBitmap(bitmap); &#125; @Override public void onStartTrackingTouch(SeekBar seekBar) &#123; &#125; @Override public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); &#125; private Bitmap handleColorMatrixBmp(int progress)&#123; // 创建一个相同尺寸的可变的位图区,用于绘制调色后的图片 Canvas canvas = new Canvas(mTempBmp); // 得到画笔对象 Paint paint = new Paint(); // 新建paint paint.setAntiAlias(true); // 设置抗锯齿,也即是边缘做平滑处理 ColorMatrix mSaturationMatrix = new ColorMatrix(); mSaturationMatrix.setSaturation(progress); paint.setColorFilter(new ColorMatrixColorFilter(mSaturationMatrix));// 设置颜色变换效果 canvas.drawBitmap(mOriginBmp, 0, 0, paint); // 将颜色变化后的图片输出到新创建的位图区 // 返回新的位图，也即调色处理后的图片 return mTempBmp; &#125; &#125; 滑块默认在一倍的位置，向左到底是0，向右到底是20（即饱和度放大20倍） 4、setScale——色彩缩放同样，对于色彩的缩放运算ColorMatrics也已经为我们封装了一个函数： public void setScale(float rScale, float gScale, float bScale,float aScale) 总共有四个参数，分别对应R,G,B,A颜色值的缩放倍数。比如，在小狗图片中，绿色占大部分，所以我们仅将绿色放大1.3倍：12345678910canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); canvas.save(); canvas.translate(510, 0); // 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(); colorMatrix.setScale(1,1.3f,1,1); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); 在仅将绿色放大1.3倍后，整个图片看起来更鲜艳了有没有。 5、setRotate——色彩旋转上面在讲解色彩旋转运算时，给大家列出了在色彩旋转时的效果和原理，由于涉及到正余弦函数的计算，而且这些公式推导起来相当具有难度，所以Android的大大们，已经给我们封装好了色彩旋转的函数：1234567/** * 将旋转围绕某一个颜色轴旋转 * axis=0 围绕红色轴旋转 * axis=1 围绕绿色轴旋转 * axis=2 围绕蓝色轴旋转 */ public void setRotate(int axis, float degrees)； int axis：表示围绕哪个轴旋转，取值为0，1，2；取0时表示围绕红色轴旋转；取值1时，表示围绕绿色轴旋转；取值2时，表示围绕蓝色轴旋转； float degrees：表示旋转的度数 6、ColorMatrics相乘矩阵相乘涉及到三个函数： public void setConcat(ColorMatrix matA, ColorMatrix matB) //这个函数接收两个ColorMatrix矩阵matA和matB，乘法规则为matA*matB，然后将结果做为当前ColorMatrix的值。 public void preConcat(ColorMatrix prematrix) //假如当前矩阵的A，而preConcat的意思就是将当前的矩阵A乘以prematrix public void postConcat(ColorMatrix postmatrix) //上面prematrix是当前矩阵A*prematrix；而postConcat函数的意义就是postmatrix*当前矩阵A;这就是一个前乘，一个是后乘的区别 7、getArray()获取当前矩阵数组getArray函数的意义就是返回当前ColorMatrics对象中的所保存的矩阵 public float[] getArray() 好啦，本篇到这里就结束了，有关矩阵的知识是比较有难度的，但是这篇对于图像处理是至关重要的，因为在有些相机软件中会有各种滤镜效果，这些滤镜效果大部分就是通过更改ColorMatrics矩阵来完成的！当然要完全会构造ColorMatrics矩阵是需要色彩设计相关的知识的；相信通过本篇知识，你也能写出些滤镜效果了，做出来一个简单的图片处理APP也不是问题了哦。 四、Paint之setColorFilter上篇给大家讲了在setColorFilter中使用ColorMatrix的过程，其实setColorFilter除了使用ColorMatrix还有其它的用法，这节我们就具体来看看setColorFilter的用法。 一、setColorFilterpublic ColorFilter setColorFilter(ColorFilter filter) 参数是传入ColorFilter的对象，其实ColorFilter是一个空对象，其中什么也没有：123456789101112131415161718public class ColorFilter &#123; int native_instance; /** * @hide */ public int nativeColorFilter; protected void finalize() throws Throwable &#123; try &#123; super.finalize(); &#125; finally &#123; finalizer(native_instance, nativeColorFilter); &#125; &#125; private static native void finalizer(int native_instance, int nativeColorFilter); &#125; 但是ColorFilter派生了几个子类，分别是： 1、ColorMatrixColorFilter这个是色彩矩阵颜色过滤器，该类只有两个函数，也都是构造函数： ColorMatrixColorFilter(ColorMatrix matrix) ColorMatrixColorFilter(float[] array) 示例12345678910111213canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); canvas.translate(510, 0); // 生成色彩矩阵 ColorMatrix colorMatrix = new ColorMatrix(new float[]&#123; 1/2f,1/2f,1/2f,0,0, 1/3f,1/3f,1/3f,0,0, 1/4f,1/4f,1/4f,0,0, 0,0,0,1,0 &#125;); mPaint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); canvas.drawBitmap(bitmap, null, new Rect(0, 0, 500, 500 * bitmap.getHeight() / bitmap.getWidth()), mPaint); 2、LightingColorFilter前一篇，我们利用一篇的篇幅来讲解ColorMatrix的作用，所有需要完成色彩操作的都是可以利用ColorMatrix来完成的，只是有一点ColorMatrix纵然很强大，但太！过！难！用，所以Android为我们提供了一个简单过滤颜色和增强色彩的函数，就是LightingColorFilter这个叫做光照颜色过滤器，可以简单的完成色彩过滤和色彩增强功能。整个类就只有一个函数，还是构造函数： public LightingColorFilter(int mul, int add) 这里有两个参数,mul是乘法multiply的缩写，add是加法的意思。mul和add取值都是0xRRGGBB,分别对应R、G、B颜色，注意哦，这里是没有透明度A的，透明度在这里是不起作用的，LightingColorFilter只针对RGB色值起作用比如，当前有一个颜色值为（r,g,b），对它应用LightingColorFilter(mul, add)效果后的颜色值为： 结果R值 = (r*mul.R+add.R)%255; 结果G值 = (g*mul.G+add.G)%255; 结果B值 = (b*mul.B+add.B)%255; 作用LightingColorFilter(mul, add)效果后的R值等于，原来的r值乘以mul.R,然后再加上add.R做为最终结果。因为颜色值要的取值范围在0-255，所以要把结果对255取余，得到最终结果。所以从公式中可以看出mul.R是对当前红色值进行放大的倍数；而add.R则表示对当前红色增加的数值；它们对应ColorMatrix的位置如下： 利用mul进行颜色值放大并不好控制，所以更多的是用来过滤颜色，即当对应的颜色值取0时，就不会将对应的颜色显示出来，而把要显示出来的颜色对应的mul值设置为ff,即255;从公式中可以知道设置为255不会对原始的这个颜色分量产生任何影响。所以这样就可以把想要的颜色给显示出来，把不想要的颜色给过滤掉比如，下面这个蓝色按钮：我们可以在点击时让它变成绿色，这要怎么做呢？直接使用LightingColorFilter把其它颜色都过滤掉，只显示绿色就可以了： 12345678910111213141516171819202122232425public class MyView extends View &#123; private Paint mPaint; private Bitmap mBmp; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.btn); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(0,550); mPaint.setColorFilter(new LightingColorFilter(0x00ff00,0x000000)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; &#125; 这里把mul参数设置为0x00ff00，即把绿色显示出来，把R和B过滤掉。而add参数全部设置为0，即没有对原始图像色彩做任何改变好像这样会有点问题，因为普通我们在点击按钮的时候，不可能会直接把它改变成另一个颜色，而只是增加它的颜色深浅值。比如下面我们增强颜色的蓝色值，将整个图片变得更蓝123456789101112protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new LightingColorFilter(0xffffff,0x0000f0)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; mul参数设置为0xffffff，即没有对颜色做任何改变；add参数设置为0x0000f0，即在每个像素的蓝色值在原来基础上增加0xf0，让原来的图像变得更蓝；这样会显得整个图片的颜色更深。更像按压后的效果。 3、PorterDuffColorFilter这个叫PorterDuff颜色滤镜，也叫图形混合滤镜；其名称是Tomas Proter和Tom Duff两个人名的缩写，他们提出的图形混合的概念极大地推动了图形图像学的发展。 public PorterDuffColorFilter(int srcColor, PorterDuff.Mode mode) int srcColor：0xAARRGGBB类型的颜色值。 PorterDuff.Mode mode：表示混合模式，枚举值有18个，表示各种图形混合模式,有： Mode.CLEAR Mode.SRC Mode.DST Mode.SRC_OVER Mode.DST_OVER Mode.SRC_IN Mode.DST_IN Mode.SRC_OUT Mode.DST_OUT Mode.SRC_ATOP Mode.DST_ATOP Mode.XOR Mode.DARKEN (变暗) Mode.LIGHTEN (变亮) Mode.MULTIPLY (正片叠底) Mode.SCREEN (滤色) Mode.OVERLAY (叠加) Mode.ADD (饱和度相加) 我们拿正片叠底来试下效果：1234567891011121314151617181920212223242526272829public class MyView extends View &#123; private Paint mPaint; private Bitmap mBmp; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); drawPorterDuffFilter(canvas); &#125; private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.MULTIPLY));//变暗 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; &#125; 在录相中给大家演示了通过Photoshop来改变混合模式的过程，录相中分别更改了Mode.DARKEN（变暗），Mode.LIGHTEN（变亮），Mode.MULTIPLY（正片叠底），Mode.OVERLAY（叠加），Mode.SCREEN（滤色）这五种效果，大家可以尝试，我们通过代码得到的效果是与PhotoShop中的模式相同的。但PhotoShop中要比我们中强大的多，除了这些模式以外，还有其它的一些模式是我们所没有的；当然，PhotoShop中的所有这些效果都是可以通过ColorMetrix完成的，但前提是数学和色彩设计知识都要很棒才行哦。但Mode.ADD(饱和度)相加在Photoshop中是没有的。下面我通过代码把这几个效果给大家分别画出来：效果图如下： 对应代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MyView extends View &#123; private Paint mPaint; private Bitmap mBmp; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setAntiAlias(true); drawPorterDuffFilter(canvas); &#125; private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.ADD));//饱和度相加 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DARKEN));//变暗 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.LIGHTEN));//变亮 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.MULTIPLY));//正片叠底 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.OVERLAY));//叠加 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SCREEN));//滤色 canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; &#125; 在这里大家不必理解PorterDuff.Mode的具体算法，只需要知道应用哪个模式，对应效果是怎样的就可以了。除了上面的六个Mode，还有其它的三组Mode，由于每组Mode的效果都是相同的，所以我们分组来讲 第一组：清空模式 Mode.CLEAR和Mode.XOR他们在这里的效果是完成一致的，就是把图像清空，所以一旦应用他们两个中的任何一个，所得到的结果图像就是一个空图1234567891011121314private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.CLEAR)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.XOR)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; 第二组：目标图像模式在Mode模式中，有一组DST相关的模式，DST所代表的意义就是被应用模式的图像，即我们这里的小狗图片。这些模式有：Mode.DST、Mode.DST_IN、Mode.DST_OUT、Mode.DST_OVER、Mode.DST_ATOP下面我们来看看他们的效果： 1234567891011121314151617181920212223242526private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_IN)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_OUT)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_OVER)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.DST_ATOP)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; 从效果图中可以看到，除了Mode.DST_OUT显示完全透明图片以外，其它全部显示目标图像；所以这几个模式在PorterDuffColorFilter的实际应用中，并没什么用。 第三组：源图模式 在Mode模式中，有一组SRC相关的模式,SRC表示的颜色值所代表的图像，这些模式有：Mode.SRC、Mode.SRC_IN、Mode.SRC_OUT、Mode.SRC_OVER、Mode.SRC_ATOP下面我们来看看他们的效果： 1234567891011121314151617181920212223242526private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_OUT)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(-550,550); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_OVER)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(550,0); mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.SRC_ATOP)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; 从效果图中可以看出，除了Mode.SRC_OUT显示完全透明图片以外，其它全部显示源图像；利用这个特性，我们可以在不同情况下，改变一个纯色图标的颜色。这个也是V4包中DrawableCompat类添加的一个setLint()函数所使用实现方法 setTint(Drawable drawable, int tint) 即最左边是一原图，后面都是指定的各个颜色，利用setTint就可以把一个图片渲染为不同的颜色，这样就可以支持多主题，在不同的风格和不同的情境下使用不同的颜色的图片。由于仅使用一个图片就可以实现多个主题，就不必再引入多个颜色的切图，就可以在一定程度上缩小包的大小。我们不必引入V4包，仅仅通过PorterDuffColorFilter就可以实现setTint的功能: 123456789101112131415161718192021222324252627private void drawPorterDuffFilter(Canvas canvas)&#123; int width = 100; int height = width * mBmp.getHeight()/mBmp.getWidth(); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xffff00ff, PorterDuff.Mode.SRC)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xff00f0ff, PorterDuff.Mode.SRC_ATOP)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xfff0f0ff, PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xffffff00, PorterDuff.Mode.SRC_OVER)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); canvas.translate(150,0); mPaint.setColorFilter(new PorterDuffColorFilter(0xff000000, PorterDuff.Mode.SRC_ATOP)); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125; 从效果图中可以看到，SRC相关的模式，只有Mode.SRC_ATOP和SRC_IN能够实现SetTint的功能，其它的是不行的。这里先记着就可以了，后面地讲原理时会具体讲原因。所以这里的一个应用就是通过PorterDuffColorFilter的Mode.SRC_ATOP或SRC_IN模式实现SetTint()的功能；有些同学可能会讲，这个功能是不是可以通过ColorMatrix来实现？当然是可以的，比如我们要将原图标改成第三个效果，即颜色为0xff00f0ff，所对应的矩阵为123456ColorMatrix matrix = new ColorMatrix(new float[]&#123; 0,0,0,0,0, 0,0,0,0,240, 0,0,0,0,255, 0,0,0,1,0 &#125;); 1、PorterDuffColorFilter只能实现与一个特定颜色值的合成。 2、通过Mode.ADD(饱和度相加)，Mode.DARKEN（变暗），Mode.LIGHTEN（变亮），Mode.MULTIPLY（正片叠底），Mode.OVERLAY（叠加），Mode.SCREEN（滤色）可以实现与指定颜色的复合。 3、通过Mode.SRC、Mode.SRC_IN、Mode.SRC_ATOP能够实现setTint()的功能，可以改变纯色图标的颜色。 五、Paint之setXfermode(一)一、GPU硬件加速1、概述GPU英文全称Graphic Processing Unit，中文翻译为“图形处理器”。与CPU不同，GPU是专门为处理图形任务而产生的芯片。在GPU出现之前，CPU一直负责着所有的运算工作，CPU的架构是有利于X86指令集的串行架构，CPU从设计思路上适合尽可能快的完成一个任务。但当面对类似多媒体、图形图像处理类型的任务时，就显得力不从心。因为在多媒体计算中通常要求更高的运算密度、多并发线程和频繁地存储器访问；显然当你打游戏时，屏幕上的动画是需要实时刷新的，这些都需要频繁的计算、存取动作；如果CPU不能及时响应，那么屏幕就会显得很卡……你的队友可能会发一句……我等的花都谢了，你咋还不动呢……为了专门处理多媒体的计算、存储任务，GPU就应运而生了，GPU中自带处理器和存储器，以用来专门计算和存储多媒体任务。对于Andorid来讲，在API 11之前是没有GPU的概念的，在API 11之后，在程序集中加入了对GPU加速的支持，在API 14之后，硬件加速是默认开启的！我们可以显式地强制图像计算时使用GPU而不使用CPU.在CPU绘制和GPU绘制时，在流程上是有区别的：在基于软件的绘制模型下，CPU主导绘图，视图按照两个步骤绘制： 让View层次结构失效 绘制View层次结构在基于硬件加速的绘制模式下，GPU主导绘图，绘制按照三个步骤绘制： 让View层次结构失效 记录、更新显示列表 绘制显示列表可以看到在GPU加速时，流程中多了一项“记录、更新显示列表”，它表示在第一步View层次结构失效后，并不是直接开始逐层绘制，而是首先把这些View的绘制函数作为绘制指令记录一个显示列表中，然后再读取显示列表中的绘制指令调用OpenGL相关函数完成实际绘制。所以在GPU加速时，实际是使用OpenGL的函数来完成绘制的。所以使用GPU加速的优点显而易见：硬件加速提高了Android系统显示和刷新的速度；它有缺点也显而易见： 兼容性问题:由于是将绘制函数转换成OpenGL命令来绘制，定然会存在OpenGL并不能完全支持原始绘制函数的问题，所以这就会造成在打开GPU加速时，效果会失效的问题。 内存消耗问题:由于需要OpenGL的指令，所以需要把系统中的OpenGL相关的包加载到内存中来，所以单纯OpenGL API调用就会占用8MB，而实际上会占用更多内存； 电量消耗问题:多使用了一个部件，当然会更耗电…… 下图显示了一些特殊函数硬件加速开始支持的平台等级：（红叉表示任何平台都不支持，不在列表中的默认在API 11就开始支持）上面我们涉及了两个API等级，在API 11以后，在程序集中加入了对GPU加速的支持，在API 14之后，硬件加速是默认开启的！也就是说在API 11——API 13虽然是支持硬件加速的，但是默认是关闭的。 2、禁用GPU硬件加速方法那么问题就来了，如果你的APP跑在API 14版本以后，而你洽好要用那些不支持硬件加速的函数要怎么办？那就只好禁用硬件加速喽，针对不同类型的东东，Android给我们提供了不同的禁用方法：硬件加速分全局（Application）、Activity、Window、View 四个层级 1.在AndroidManifest.xml文件为application标签添加如下的属性即可为整个应用程序开启/关闭硬件加速：&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; 2.在Activity 标签下使用 hardwareAccelerated 属性开启或关闭硬件加速：&lt;activity android:hardwareAccelerated=&quot;false&quot; /&gt; 3. 在Window 层级使用如下代码开启硬件加速：(Window层级不支持关闭硬件加速)123getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); 4.View 级别如下关闭硬件加速：（view 层级上不支持开启硬件加速）setLayerType(View.LAYER_TYPE_SOFTWARE, null); 或者使用android:layerType=”software”来关闭硬件加速：比如 1234567&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical" android:paddingLeft="2dp" android:layerType="software" android:paddingRight="2dp" &gt; 二、setXfermode(Xfermode xfermode)之AvoidXfermode这个函数是图像混合里最难的一个了，它的功能也是相当强大的，这个模式叫做图形混合模式。与setColorFilter一样，派生自Xfermode的有三个类： 1、概述——基本流程从上面可以看出，派生自Xfermode的有AvoidXfermode，PixelXorXfermode，PorterDuffXfermode;从硬件加速不支持的函数列表中，我们可以看到AvoidXfermode，PixelXorXfermode是完全不支持的，而PorterDuffXfermode是部分不支持的。 所以在使用Xfermode时，为了保险起见，我们需要做两件事： 禁用硬件加速： setLayerType(View.LAYER_TYPE_SOFTWARE, null); 使用离屏绘制 12345//新建图层 int layerID = canvas.saveLayer(0,0,width,height,mPaint,Canvas.ALL_SAVE_FLAG); //TODO 核心绘制代码//还原图层 canvas.restoreToCount(layerID); 我们需要把绘制的核心代码放在saveLayer()和restoreToCount()之间即可。下面我们先简单讲解AvoidXfermode的用法，然后写个例子，看下SetXfermode()的使用方法和效果AvoidXfermode的声明如下： public AvoidXfermode(int opColor, int tolerance, Mode mode) 当Mode取Mode.TARGET时，它的意义表示将opColor参数所指定的颜色替换成画笔的颜色。 第一个参数opColor：一个16进制的AARRGGBB的颜色值； 第二个参数tolerance：表示容差，这个概念我们后面再细讲 第三个参数mode：取值有两个Mode.TARGET和Mode.AVOID；这里我们先知道Mode.TARGET的意义就可以了，Mode.TARGET表示将指定的颜色替换掉 12345678910111213141516171819202122232425262728public class MyView extends View &#123; private Paint mPaint; private Bitmap mBmp; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); setLayerType(View.LAYER_TYPE_SOFTWARE, null); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); mPaint.setColor(Color.RED); int layerID = canvas.saveLayer(0,0,width,height,mPaint,Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); mPaint.setXfermode(new AvoidXfermode(Color.WHITE,100, AvoidXfermode.Mode.TARGET)); canvas.drawRect(0,0,width,height,mPaint); canvas.restoreToCount(layerID); &#125; &#125; mPaint.setXfermode(new AvoidXfermode(Color.WHITE,100, AvoidXfermode.Mode.TARGET)); 这一点与Photoshop是类似的，就是以白色为目标色，容差为100找到对应的选区；容差是以颜色差异为基础的，任何两个颜色之间的颜色差异是从0-255的范围内的。具体两个颜色之间的差异的的数值为多少是需要靠公式来计算的，而容差的概念就是指与目标色所能容忍的最大颜色差异，所以容差越大，所覆盖的颜色区域就越大；所以当容差为0时，就表示只选择与目标色一模一样的颜色区域；当容差为100时，就表示与目标色值的颜色差异在100范围内的都是可以的；而由于最大的颜色差异是255，所以当我们的容差是255时，所有的颜色都将被选中。 2、canvas脏区域更新原理Android在绘图时会先检查该画笔Paint对象有没有设置Xfermode，如果没有设置Xfermode，那么直接将绘制的图形覆盖Canvas对应位置原有的像素；如果设置了Xfermode，那么会按照Xfermode具体的规则来更新Canvas中对应位置的像素颜色。所以对于AvoidXfermode而言，这个规则就是先把把目标区域（选区）中的颜色值先清空，然后再把目标颜色给替换上；如果没有设置Xfermode，那么直接将绘制的图形覆盖Canvas对应位置原有的像素；如果设置了Xfermode，那么会按照Xfermode具体的规则来更新Canvas中对应位置的像素颜色。 3、AvoidXfermode在讲解了AvoidXfermode的绘图流程和脏区域更新原理后，这里就开始具体的来看看AvoidXfermode这个函数了；AvoidXfermode类已经在API 16弃用了，但目前还没有能替代它的方法，所以API 16以上的平台还是支持的。如果大家想在API 16以上使用这个类，唯一需要注意的是它不支持硬件加速，所以记得禁用硬件加速就可以了；AvoidXfermode的声明如下： public AvoidXfermode(int opColor, int tolerance, Mode mode) 第一个参数opColor：一个16进制的AARRGGBB的颜色值； 第二个参数tolerance：表示容差，这个概念我们后面再细讲 第三个参数mode：取值有两个Mode.TARGET和Mode.AVOID；Mode.TARGET表示将指定的颜色替换掉，这个我们已经前面演示过了，而Mode.AVOID的意思就是Mode.TARGET所选区域的取反。 123456789101112131415protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 500; int height = width * mBmp.getHeight()/mBmp.getWidth(); mPaint.setColor(Color.RED); int layerID = canvas.saveLayer(0,0,width,height,mPaint,Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); mPaint.setXfermode(new AvoidXfermode(Color.WHITE,100, AvoidXfermode.Mode.AVOID)); canvas.drawRect(0,0,width,height,mPaint); canvas.restoreToCount(layerID); &#125; 因为Android里计算容差与Photoshop的不同，在Photoshop中容差为255时表示全图选区，而在Android中的选区却不是全图！就是因为在计算颜色差值计算时的差异导致的。 三、setXfermode(Xfermode xfermode)之PixelXorXfermode与AvoidXfermode一样也在API 16过时了,它是一个简单的异或运算(op ^ src ^ dst)，返回的alpha值始终等于255，所以对操作颜色混合不是特别的有效；这个类的用法难度不大，而且基本上用不到，这里就不再细讲了，大家有兴趣的话，可以尝试一下。 四、setXfermode(Xfermode xfermode)之PorterDuffXfermode1、概述PorterDuffXfermode的构造函数如下： public PorterDuffXfermode(PorterDuff.Mode mode) 它只有一个参数PorterDuff.Mode，对于PorterDuff.Mode大家应该比较熟悉，我们在讲解setColorFilter时已经用过它： mPaint.setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.OVERLAY)); 前面我们讲过PorterDuff.Mode表示混合模式，枚举值有18个，表示各种图形混合模式,有： 比如LIGHTEN的计算方式为[Sa + Da - Sa Da, Sc (1 - Da) + Dc (1 - Sa) + max(Sc, Dc)]，其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，在每个公式中，都会被分为两部分[……，……]，其中“,”前的部分为“Sa + Da - Sa Da”这一部分的值代表计算后的Alpha通道而“,”后的部分为“Sc (1 - Da) + Dc (1 - Sa) + max(Sc, Dc)”这一部分的值代表计算后的颜色值，图形混合后的图片就是依据这个公式来对DST和SRC两张图像中每一个像素进行计算，得到最终的结果的。Google给我们了一张图，显示的是两个图形一圆一方通过一定的计算产生不同的组合效果，其中圆形是底部的目标图像，方形是上方的源图像。 在上面的公式中涉及到一个概念，目标图DST，源图SRC。那什么是源图，什么是目标图呢？我们简单举例子来说明一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyView extends View &#123; private int width = 400; private int height = 400; private Bitmap dstBmp; private Bitmap srcBmp; private Paint mPaint; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); dstBmp = makeDst(width,height); srcBmp = makeSrc(width,height); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerID = canvas.saveLayer(0,0,width*2,height*2,mPaint,Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(srcBmp, width/2, height/2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; static Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); c.drawOval(new RectF(0, 0, w, h), p); return bm; &#125; static Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); c.drawRect(0, 0,w,h, p); return bm; &#125; &#125; 它会在源图像所在区域与目标图像运算，在得到结果以后，将结果覆盖到目标图像上。整个过程如下：首先在两个矩形的所在位置： 然后是源图像计算结果的覆盖过程： 其中蓝色小块是源图像所在区域与目标图像经过运算的结果（有关这个结果为什么是一小块蓝色，下篇会具体讲），在得到结果以后，把结果对应区域的图像先清空，然后把结果覆盖上去。（还记得我们在讲解canvas脏数据更新的时候提到，如果没有xfermode就直接覆盖上去，如果有xfermode则先清空对应的区域，然后再覆盖上去）；这里还需要强调一点，源图像在运算时，只是在源图像所在区域与对应区域的目标图像做运算。所以目标图像与源图像不相交的地方是不会参与运算的！这一点非常重要！不相交的地方不会参与运算，所以不相交的地方的图像也不会是脏数据，也不会被更新，所以不相交地方的图像也永远显示的是目标图像。 六、Paint之setXfermode(二)这篇文章将逐个讲解每个模式的意义。这里所讲的各种模式，在大家理解了之后可以回过头来看看setColorFilter(new PorterDuffColorFilter(Color.RED, PorterDuff.Mode.XXXX));中的混合过程，其实在PorterDuffColorFilter中的混合过程与这里的setXfermode()设置混合模式的计算方式和效果是完全相同的，只是在PorterDuffColorFilter中只能使用纯色彩，而且是完全覆盖在图片上方；而setXfermode()则不同，它只会在目标图像和源图像交合的位置起作用，而且源图像不一定是纯色的。在开始讲解之前，我们随便拿一个效果图来看一下，我们在这个效果图中需要关注哪两点 123canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN)); canvas.drawBitmap(srcBmp,width/2,height/2, mPaint); 前面在讲canvas的脏区域更新时，已经提到，在最后一句计算效果图像时，是以源图像所在区域为计算目标的，把计算后的源图像更新到对应区域内。所以如上图所示，我们在计算源图像所在区域效果图时，需要着重关注两个区域：1、如图标示区域一：区域一是源图像和目标图像的相交区域，由于在这个区域源图像和目标图像像素都不是空白像素，所以可以明显看出颜色的计算效果。2、如图标示区域二：在区域二中，源图像所在区域的目标图像是空白像素，所以这块区域所表示的意义就是，当某一方区域是空白像素时，此时的计算结果。总而言之：我们在下面的各个模式计算时，只需要关注图示中的区域一和区域二；其中区域一表示当源图像和目标图像像素都不是空白像素时的计算结果，而区域二则表示当某一方区域是空白像素时，此时的计算结果。 一、颜色叠加相关模式这部分涉及到的几个模式有Mode.ADD（饱和度相加）、Mode.DARKEN（变暗），Mode.LIGHTEN（变亮）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加），Mode.SCREEN（滤色） 1、Mode.ADD（饱和度相加）它的公式是Saturate(S + D)；ADD模式简单来说就是对SRC与DST两张图片相交区域的饱和度进行相加同样使用上篇中的示例，一个矩形，一个圆形来做相加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MyView extends View &#123; private int width = 400; private int height = 400; private Bitmap dstBmp; private Bitmap srcBmp; private Paint mPaint; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); srcBmp = makeSrc(width, height); dstBmp = makeDst(width, height); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerID = canvas.saveLayer(0,0,width*2,height*2,mPaint,Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.ADD)); canvas.drawBitmap(srcBmp,width/2,height/2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; // create a bitmap with a circle, used for the "dst" image static Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); c.drawOval(new RectF(0, 0, w, h), p); return bm; &#125; // create a bitmap with a rect, used for the "src" image static Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); c.drawRect(0, 0, w, h, p); return bm; &#125; &#125; 从效果图中可以看出，只有源图与目标图像相交的部分的图像的饱和度产生了变化，没相交的部分是没有变的，因为对方的饱和度是0，当然不相交的位置饱和度是不会变的。这个模式的应用范围比较少，暂时想不到哪里会用到； 2、Mode.LIGHTEN（变亮）它的算法是： [Sa + Da - Sa Da,Sc (1 - Da) + Dc*(1 - Sa) + max(Sc, Dc)]圆形和矩形的效果图为： 这个效果比较容易理解，两个图像重合的区域才会有颜色值变化，所以只有重合区域才有变亮的效果，源图像非重合的区域，由于对应区域的目标图像是空白像素，所以直接显示源图像。 我们在实际应用中，会有下面的这个情况，当选中一本书时，给这本书加上灯光效果 其实它是两张图合成的：DST:目标图像 SRC:源图像 可以看到，在这张图片的最上方中间的位置有些白色半透明的填充，其它位置都是透明的。 12345678910111213141516171819202122232425262728public class LightBookView extends View &#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC; public LightBookView(Context context, AttributeSet attrs) &#123; super(context, attrs); mBitPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.book_bg,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.book_light,null); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); //先画书架，做为目标图像 canvas.drawBitmap(BmpDST,0,0,mBitPaint); mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN)); //再图光点 canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; &#125; 意思就是先把书架做为目标图像画在底层，然后给mBitPaint设置上PorterDuffXfermode，然后将处理过的源图盖在目标图像上。代码难度不大，就不再细讲。 3、Mode.DARKEN（变暗）对应公式是： [Sa + Da - Sa Da,Sc (1 - Da) + Dc * (1 - Sa) + max(Sc, Dc)]同样是对应photoshop中的混合模式中的变暗模式 4、Mode.MULTIPLY(正片叠底)公式是：[Sa Da, Sc Dc] 有些同学会奇怪了，Photoshop中也有正片叠底啊，相交区域正片叠底后的颜色确实是绿色的，但源图像的非相交区域怎么没了？我们来看下他的计算公式：[Sa Da, Sc Dc]，在计算alpha值时的公式是Sa * Da，是用源图像的alpha值乘以目标图像的alpha值；由于源图像的非相交区域所对应的目标图像像素的alpha是0，所以结果像素的alpha值仍是0，所以源图像的非相交区域在计算后是透明的。在两个图像的相交区域的混合方式是与photoshop中的正片叠底效果是一致的。 5、Mode.OVERLAY（叠加）这个没有给出公式…… 虽然没有给出公式，但从效果图中可以看到，源图像交合部分有效果，非交合部分依然是存在的，这就可以肯定一点，当目标图像透明时，在这个模式下源图像的色值不会受到影响； 6、Mode.SCREEN（滤色）对应公式是：[Sa + Da - Sa Da, Sc + Dc - Sc Dc] 同样，只是源图像与目标图像交合部分有效果，源图像非交合部分保持原样。 总结 这几种模式都是PhotoShop中存在的模式，是通过计算改变交合区域的颜色值的 除了Mode.MULTIPLY(正片叠底)会在目标图像透明时将结果对应区域置为透明，其它图像都不受目标图像透明像素影响，即源图像非交合部分保持原样。 7、示例——twitter标识的描边效果由于这些模式在photoshop中都存在，直接拿目标图像和源图像在photoshop中就可以演示出来，就没有多举例子，其实，在实现时实现两图像混合时，也经常会用到这些模式的，比如这里twitter的暗光效果。图一：图二：然后完成的效果如下： 我们先想想这个要实现的效果有哪些特性：首先，在图一中，小鸟整个都是蓝色的在图二中，只有小鸟的边缘部分是白色的，中间部分是透明的。在最终的合成图中：图一和图二中小鸟与边缘的是显示的，而且还有某种效果，但小鸟中间的区域变透明了！显示的是底部Activity的背景色。想到我们前面学到的几种样式中，只有Mode.MULTIPLY(正片叠底)会在两个图像的一方透明时，结果像素就是透明的。所以这里使用的模式就是Mode.MULTIPLY 123456789101112131415161718192021222324public class TwitterView extends View &#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC; public TwitterView(Context context, AttributeSet attrs) &#123; super(context, attrs); mBitPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_bg,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.twiter_light,null); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,0,0,mBitPaint); mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY)); canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; &#125; 二、SRC相关模式在讲完了photoshop中存在的几个模式以后，还有几个是在处理结果时以源图像显示为主的几个模式，所以大家在遇到当图像相交时，需要显示源图像时，就需要从这几个模式中考虑了这部分所涉及的模式有：Mode.SRC、Mode.SRC_IN、Mode.SRC_OUT、Mode.SRC_OVER、Mode.SRC_ATOP 1、Mode.SRC计算公式为：[Sa, Sc]从公式中也可以看出，在处理源图像所在区域的相交问题时，全部以源图像显示 2、Mode.SRC_IN计算公式为：[Sa Da, Sc Da]在这个公式中结果值的透明度和颜色值都是由Sa,Sc分别乘以目标图像的Da来计算的。所以当目标图像为空白像素时，计算结果也将会为空白像素。 大家注意SRC_IN模式与SRC模式的区别，一般而言，是在相交区域时无论SRC_IN还是SRC模式都是显示源图像，而唯一不同的是，当目标图像是空白像素时，在SRC_IN所对应的区域也将会变成空白像素；其实更严格的来讲，SRC_IN模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。当目标图像透明度为0时，源图像就完全不显示。 示例1：图形圆角 图像一：（我们熟悉的小狗 ） 图像二：（去角遮罩） 效果为： 可以看到这个遮罩的四个角都是圆形切角，都是透明的。现在我们需要利用SRC_IN的特性，显示SRC图像，但会把目标图像中空白像素的部分去掉的特性来做了。由于我们需要最终显示小狗图像，所以这里需要将小狗 图像做为SRC，将遮罩做为目标图像 12345678910111213141516171819202122232425262728public class RoundImageView_SRCIN extends View &#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC; public RoundImageView_SRCIN(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_shade,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,0,0,mBitPaint); mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; &#125; 示例2：图片倒影前面我们讲过，SRC_IN模式是在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。所以当目标图像的透明度在0-255之间时，就会把源图像的透明度和颜色值都会变小。利用这个特性，我们可以做出倒影效果 用到的遮罩为： 这个遮罩好像还不太清，它是一个从上到下的白色填充渐变；白色的透明度从49%到0； 123456789101112131415161718192021222324252627282930313233343536public class InvertedImageView_SRCIN extends View&#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC,BmpRevert; public InvertedImageView_SRCIN(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.dog_invert_shade,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); Matrix matrix = new Matrix(); matrix.setScale(1F, -1F); // 生成倒影图 BmpRevert = Bitmap.createBitmap(BmpSRC, 0, 0, BmpSRC.getWidth(), BmpSRC.getHeight(), matrix, true); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //先画出小狗图片 canvas.drawBitmap(BmpSRC,0,0,mBitPaint); //再画出倒影 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.translate(0,BmpSRC.getHeight()); canvas.drawBitmap(BmpDST,0,0,mBitPaint); mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(BmpRevert,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; &#125; 3、Mode.SRC_OUT计算公式为：[Sa (1 - Da), Sc (1 - Da)]从公式中可以看出，计算结果的透明度=Sa * (1 - Da)；也就是说当目标图像图像完全透明时，计算结果将是透明的； 从示例图中也可以看出，源图像与目标图像的相交部分由于目标图像的透明度为100%，所以相交部分的计算结果为空白像素。在目标图像为空白像素时，完全以源图像显示。所以这个模式的特性可以概括为：以目标图像的透明度的补值来调节源图像的透明度和色彩饱和度。即当目标图像为空白像素时，就完全显示源图像，当目标图像的透明度为100%时，交合区域为空像素。Mode.SRC_OUT简单来说，当目标图像有图像时结果显示空白像素，当目标图像没有图像时，结果显示源图像。 1、橡皮擦效果利用这个特性，我们可以实现橡皮擦效果 原理：我们说了简单来讲Mode.SRC_OUT模式，当目标图像有图像时计算结果为空白像素，当目标图像没有图像时，显示源图像；所以我们把手指轨迹做为目标图像，在与源图像计算时，有手指轨迹的地方就变为空白像素了，看起来的效果就是被擦除了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class DogView_SRCOUT extends View &#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC; private Path mPath; private float mPreX,mPreY; public DogView_SRCOUT(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); mBitPaint.setColor(Color.RED); mBitPaint.setStyle(Paint.Style.STROKE); mBitPaint.setStrokeWidth(45); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.dog,null); BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888); mPath = new Path(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); //先把手指轨迹画到目标Bitmap上 Canvas c = new Canvas(BmpDST); c.drawPath(mPath,mBitPaint); //然后把目标图像画到画布上 canvas.drawBitmap(BmpDST,0,0,mBitPaint); //计算源图像区域 mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT)); canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(event.getX(),event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float endX = (mPreX+event.getX())/2; float endY = (mPreY+event.getY())/2; mPath.quadTo(mPreX,mPreY,endX,endY); mPreX = event.getX(); mPreY =event.getY(); break; case MotionEvent.ACTION_UP: break; &#125; postInvalidate(); return super.onTouchEvent(event); &#125; &#125; 2、刮刮卡效果首先，搞一个刮刮卡图片：然后再搞个中奖结果：结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class GuaGuaCardView_SRCOUT extends View&#123; private Paint mBitPaint; private Bitmap BmpDST,BmpSRC,BmpText; private Path mPath; private float mPreX,mPreY; public GuaGuaCardView_SRCOUT(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mBitPaint = new Paint(); mBitPaint.setColor(Color.RED); mBitPaint.setStyle(Paint.Style.STROKE); mBitPaint.setStrokeWidth(45); BmpText = BitmapFactory.decodeResource(getResources(),R.drawable.guaguaka_text,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.guaguaka_pic,null); BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888); mPath = new Path(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(BmpText,0,0,mBitPaint); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); //先把手指轨迹画到目标Bitmap上 Canvas c = new Canvas(BmpDST); c.drawPath(mPath,mBitPaint); //然后把目标图像画到画布上 canvas.drawBitmap(BmpDST,0,0,mBitPaint); //计算源图像区域 mBitPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT)); canvas.drawBitmap(BmpSRC,0,0,mBitPaint); mBitPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_DOWN: mPath.moveTo(event.getX(),event.getY()); mPreX = event.getX(); mPreY = event.getY(); return true; case MotionEvent.ACTION_MOVE: float endX = (mPreX+event.getX())/2; float endY = (mPreY+event.getY())/2; mPath.quadTo(mPreX,mPreY,endX,endY); mPreX = event.getX(); mPreY =event.getY(); break; case MotionEvent.ACTION_UP: break; &#125; postInvalidate(); return super.onTouchEvent(event); &#125; &#125; 与上面橡皮擦效果不同的是，在绘图时，在特效前先把刮刮卡的中奖文字绘在底部，这时候当橡皮擦把刮刮卡的图片给擦除掉时，就露出底部的刮刮卡的中奖文字了。 4、Mode.SRC_OVER计算公式为：[Sa + (1 - Sa) Da, Rc = Sc + (1 - Sa) Dc]我们可以看到，在计算结果中，源图像没有变。它的意思就是在目标图像的顶部绘制源图像。从公式中也可以看出目标图像的透明度为Sa + (1 - Sa)*Da；即在源图像的透明度基础上增加一部分目标图像的透明度。增加的透明度是源图像透明度的补量；目标图像的色彩值的计算方式同理，所以当源图像透明度为100%时，就原样显示源图像； 5、Mode.SRC_ATOP计算公式为：[Da, Sc Da + (1 - Sa) Dc]很奇怪，它的效果图竟然与SRC_IN模式是相同的，我们来对比一下它们的公式：SRC_IN: [Sa Da, Sc Da]SRC_ATOP:[Da, Sc Da + (1 - Sa) Dc]先看透明度：在SRC_IN中是Sa Da,在SRC_ATOP是DaSRC_IN是源图像透明度乘以目标图像的透明度做为结果透明度，而SRC_ATOP是直接使用目标图像的透明度做为结果透明度再看颜色值：SRC_IN的颜色值为 Sc Da，SRC_ATOP的颜色值为Sc Da + (1 - Sa) Dc；SRC_ATOP在SRC_IN的基础上还增加了(1 - Sa) * Dc； 总结 当透明度只有100%和0%时，SRC_ATOP是SRC_IN是通用的 当透明度不只有100%和0%时，SRC_ATOP相比SRC_IN源图像的饱和度会增加，即会显得更亮！ 所以，前面利用SRC_IN实现的圆角效果是完全可以使用SRC_ATOP模式来实现的。 1、圆角效果（当透明度只有100%和0%时，SRC_ATOP是SRC_IN是通用的） 代码中仅将SRC_IN模式改为SRC_ATOP模式即可 示例2：图片倒影(颜色饱和度增加)前面我们讲过，当目标图像的透明度不是100%和0%时，源图像的颜色值就会比SRC_IN模式的颜色值饱和度增加。我们来对比下效果：同样只需要在将原图片倒影代码的SRC_IN模式改成SRC_ATOP即可 效果图如下：然后再来看看原来SRC_IN的效果图，对比一下： 明显亮度是有增加的。所以对于SRC_ATOP的结论就出来了，一般而言SRC_ATOP是可以和SRC_IN通用的，但SRC_ATOP所产生的效果图在目标图不是透明度不是0或100%的时候，会比SRC_IN模式产生的图像更亮些； 七、Paint之setXfermode(三)一、DST相关模式在讲完了SRC相关的模式以后，我们知道SRC相关的模式，都是在相交区域优先显示源图像为主。与之相对应的有DST相关的模式，在DST相关的模式中，在处理相交区域时，优先以目标图像显示为主。这部分所涉及的模式有：Mode.DST、Mode.DST_IN、Mode.DST_OUT、Mode.DST_OVER、Mode.DST_ATOP 1、Mode.DST计算公式为：[Da, Dc]从公式中也可以看出，在处理源图像所在区域的相交问题时，正好与Mode.SRC相反，全部以目标图像显示 2、Mode.DST_IN计算公式为：[Da Sa,Dc Sa]我们与Mode.SRC_IN的公式对比一下：SRC_IN:[Sa Da, Sc Da]正好与SRC_IN相反，Mode.DST_IN是在相交时利用源图像的透明度来改变目标图像的透明度和饱和度。当源图像透明度为0时，目标图像就完全不显示。由于Mode.DST_IN的模式与SRC_IN正好是相反，所以我们利用Mode.SRC_IN实现的示例，只需要将源图像与目标图像对调就可以使用Mode.DST_IN来实现了。 示例1、区域波纹之前讲解了水波纹效果，但这个水波纹效果却只能是一固定在一个矩形区域，本例我们就利用xfermode来实现在不规则区域中显示水波纹效果，效果图如下： 这里使用到一张图片 在这张图片中，只有文字部分是纯白色的，其它区域都是透明像素。所以再加上我们需要自己绘制的水波纹效果的图片，这里就有两张图片了，一张是水波纹效果图，另一张是text_shade.png那么问题来了，如果我们使用Mode.DST_IN模式的话，谁当目标图像，谁当源图像呢？这就需要分析Mode.DST_IN模式的成像原理了，在Mode.DST_IN中，源图像所占区域计算结果图像时，相交区域显示的是DST目标图像；所以我们要最终显示的被裁剪后的波纹图，所以DST目标图像就应该是波纹图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class CircleWave_DSTIN extends View &#123; private Paint mPaint; private Path mPath; private int mItemWaveLength = 1000; private int dx; private Bitmap BmpSRC,BmpDST; public CircleWave_DSTIN(Context context, AttributeSet attrs) &#123; super(context, attrs); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.GREEN); mPaint.setStyle(Paint.Style.FILL_AND_STROKE); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.text_shade,null); BmpDST = Bitmap.createBitmap(BmpSRC.getWidth(), BmpSRC.getHeight(), Bitmap.Config.ARGB_8888); startAnim(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); generageWavePath(); //先清空bitmap上的图像,然后再画上Path Canvas c = new Canvas(BmpDST); c.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR); c.drawPath(mPath,mPaint); canvas.drawBitmap(BmpSRC,0,0,mPaint); int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,0,0,mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); canvas.drawBitmap(BmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; /** * 生成此时的Path */ private void generageWavePath()&#123; mPath.reset(); int originY = BmpSRC.getHeight()/2; int halfWaveLen = mItemWaveLength/2; mPath.moveTo(-mItemWaveLength+dx,originY); for (int i = -mItemWaveLength;i&lt;=getWidth()+mItemWaveLength;i+=mItemWaveLength)&#123; mPath.rQuadTo(halfWaveLen/2,-50,halfWaveLen,0); mPath.rQuadTo(halfWaveLen/2,50,halfWaveLen,0); &#125; mPath.lineTo(BmpSRC.getWidth(),BmpSRC.getHeight()); mPath.lineTo(0,BmpSRC.getHeight()); mPath.close(); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(2000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125; &#125; 2、心电图 很明显，正规的心电图应该是利用Path把当前的实时的点连接起来，我这里只是一张图片(hearmap.png)通过使用动画来实现的 中间是一条心电图线，其余位置都是透明像素；大家先想想我们要怎么利用这张图片实现上面的动画呢？利用Mode.DST_IN模式，由于在这个模式中，相交区域优先显示目标图像，所以我们这里需要显示心电图，所以心电图就是目标图像。那么问题来了，源图像是啥？由于我们需要从右向左逐渐显示心电图图像，所以我们源图像就是自建的空白图像，在这个图像中，绘制一个矩形，逐渐增大矩形的区域，即相交区域也会跟着增大，由于相交区域会显示出目标图像，显示出来的结果就是心电图的动画 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HeartMap extends View &#123; private Paint mPaint; private int mItemWaveLength = 0; private int dx=0; private Bitmap BmpSRC,BmpDST; public HeartMap(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.heartmap,null); BmpSRC = Bitmap.createBitmap(BmpDST.getWidth(), BmpDST.getHeight(), Bitmap.Config.ARGB_8888); mItemWaveLength = BmpDST.getWidth(); startAnim(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Canvas c = new Canvas(BmpSRC); //清空bitmap c.drawColor(Color.BLACK, PorterDuff.Mode.CLEAR); //画上矩形 c.drawRect(BmpDST.getWidth() - dx,0,BmpDST.getWidth(),BmpDST.getHeight(),mPaint); //模式合成 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,0,0,mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); canvas.drawBitmap(BmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(6000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125; &#125; 3、不规则波纹 上面我们实现的波纹效果都是规则的，如果我们想实现如下图这样的不规则波纹要怎么办呢？ 在这里我们需要用到两张图： 一张不规则的波浪图 想必到这里，可能很多同学都知道要怎么做了就是在圆形遮罩上绘制不断移动的不规则的波浪图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class IrregularWaveView extends View &#123; private Paint mPaint; private int mItemWaveLength = 0; private int dx=0; private Bitmap BmpSRC,BmpDST; public IrregularWaveView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); BmpDST = BitmapFactory.decodeResource(getResources(),R.drawable.wave_bg,null); BmpSRC = BitmapFactory.decodeResource(getResources(),R.drawable.circle_shape,null); mItemWaveLength = BmpDST.getWidth(); startAnim(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //先画上圆形 canvas.drawBitmap(BmpSRC,0,0,mPaint); //再画上结果 int layerId = canvas.saveLayer(0, 0, getWidth(), getHeight(), null, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(BmpDST,new Rect(dx,0,dx+BmpSRC.getWidth(),BmpSRC.getHeight()),new Rect(0,0,BmpSRC.getWidth(),BmpSRC.getHeight()),mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN)); canvas.drawBitmap(BmpSRC,0,0,mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerId); &#125; public void startAnim()&#123; ValueAnimator animator = ValueAnimator.ofInt(0,mItemWaveLength); animator.setDuration(4000); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setInterpolator(new LinearInterpolator()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; dx = (int)animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.start(); &#125; &#125; 3、Mode.DST_OUT计算公式为：[Da (1 - Sa), Dc (1 - Sa)] 同样，我们拿这个公式与Mode.SRC_OUT对比一下，Mode.SRC_OUT：[Sa (1 - Da), Sc (1 - Da)]可以看出Mode.SRC_OUT是利用目标图像的透明度的补值来改变源图像的透明度和饱和度。而Mode.DST_OUT反过来，是通过源图像的透明度补值来改变目标图像的透明度和饱和度。简单来说，在Mode.DST_OUT模式下，就是相交区域显示的是目标图像，目标图像的透明度和饱和度与源图像的透明度相反，当源图像透明底是100%时，则相交区域为空值。当源图像透明度为0时，则完全显示目标图像。非相交区域完全显示目标图像。 示例图像为： 有些同学对这个结果可能感觉很奇怪，我们来分析一下，上篇中我们提到在xfermode的示例图像中，我们主要需要关注两点： 图中编号1的相交区域：在DST_OUT模式下，由于源图像的透明度是100%，所以计算后的结果图像在这个区域是空像素。图中编号2的非相交区域：在DST_OUT模式下，这个区域的源图像透明度仍为100%，所以计算后的结果图像在这个区域仍是空像素。所以我们做下简单的总结，当源图像区域透明度为100%时，所在区域计算结果为透明像素，当源图像的区域透明时，计算结果就是目标图像；这与SRC_OUT模式的结果正好相反，在SRC_OUT模式下，当目标图像区域透明度为100%时，所在区域计算结果为透明像素，当目标图像的区域透明时，计算结果就是源图像；所以，在上篇中，使用SRC_OUT模式实现的橡皮擦效果和刮刮卡效果都是可以使用DST_OUT模式实现的，只需要将SRC和DST所对应的图像翻转一下就可以了；这里就不再实现了，大家自己来试试吧。 4、Mode.DST_OVER计算公式为：[Sa + (1 - Sa) Da, Rc = Dc + (1 - Da) Sc]同样先写Mode.SRC_OVER对比一下，SRC_OVER：[Sa + (1 - Sa) Da, Rc = Sc + (1 - Sa) Dc]所以它们的效果就是在SRC模式中以显示SRC图像为主变成了以显示DST图像为主。从SRC模式中的使用目标图像控制结果图像的透明度和饱和度变成了由源图像控件结果图像的透明度和饱和度。示例图像为： 5、Mode.DST_ATOP计算公式为：[Sa, Sa Dc + Sc (1 - Da)]示例图像为： 由于在SRC中，我们知道了Mode.SRC_ATOP与MODE.SRC_IN的区别：一般而言SRC_ATOP是可以和SRC_IN通用的，但SRC_ATOP所产生的效果图在目标图的透明度不是0或100%的时候，会比SRC_IN模式产生的图像更亮些；我们再来对比下DST中的两个模式与SRC中的这两个模式中公式中区别：SRC_IN: [Sa Da, Sc Da]SRC_ATOP:[Da, Sc Da + (1 - Sa) Dc]DST_IN:[Da Sa , Dc Sa ]DST_ATOP:[Sa, Sa Dc + Sc (1 - Da)]从公式中可以看到，在SRC模式中，以显示源图像为主，透明度和饱和度利用Da来调节而在DST模式中，以显示目标图像为主，透明度和饱和度利用Sa来调节 所以Mode.DST_ATOP与Mode.DST_IN的关系也是：一般而言DST_ATOP是可以和DST_IN通用的，但DST_ATOP所产生的效果图在源图像的透明度不是0或100%的时候，会比DST_IN模式产生的图像更亮些；同样，大家也可以使用Mode.DST_ATOP实现上篇文章中Mode.SRC_ATOP的两个示例：圆角效果和图片倒影，这里就不再讲了 总结 DST相关模式是完全可以使用SRC对应的模式来实现的，只不过需要将目标图像和源图像对调一下即可。 在SRC模式中，是以显示源图像为主，通过目标图像的透明度来调节计算结果的透明度和饱和度，而在DST模式中，是以显示目标图像为主，通过源图像的透明度来调节计算结果的透明度和饱和度。 二、其它模式除了颜色叠加系列模式，SRC系列模式和DST系列模式以外，另外还有两个模式Mode.CLEAR和Mode.XOR,下面我们就来看看它们的用法 1、Mode.CLEAR计算公式：[0, 0] 前面我们做清空图像的时候用过这个方法，从公式中可以看到，计算结果直接就是[0,0]即空像素。也就是说，源图像所在区域都会变成空像素！这样就起到了清空源图像所在区域图像的功能了。上面示例中已经存在这个Mode的用法，这里就不再举例了。 2、Mode.XOR计算公式为：[Sa + Da - Sa Da,Sc (1 - Da) + Dc * (1 - Sa) + min(Sc, Dc)] 单从示例图像中，好像是异或的功能，即将源图像中除了相交区域以外的部分做为结果。但仔细看看公式，其实并没有这么简单。首先看公式中透明度部分：Sa + Da - Sa Da，就是将目标图像和源图像的透明度相加，然后减去它们的乘积，所以计算结果的透明度会增大（即比目标图像和源图像都大，当其中一个图像的透明度为1时，那结果图像的透明度肯定是1）然后再看颜色值部分：Sc (1 - Da) + Dc * (1 - Sa) + min(Sc, Dc)；表示源图像和目标图像分别以自己的透明度的补值乘以对方的颜色值，然后相加得到结果。最后再加上Sc, Dc中的最小值。 在实际应用中，我们可以从下面三个方面来决定使用哪一个模式： 首先，目标图像和源图像混合，需不需要生成颜色的叠加特效，如果需要叠加特效则从颜色叠加相关模式中选择，有Mode.ADD（饱和度相加）、Mode.DARKEN（变暗），Mode.LIGHTEN（变亮）、Mode.MULTIPLY（正片叠底）、Mode.OVERLAY（叠加），Mode.SCREEN（滤色） 当不需要特效，而需要根据某一张图像的透明像素来裁剪时，就需要使用SRC相关模式或DST相关模式了。由于SRC相关模式与DST相关模式是相通的，唯一不同的是决定当前哪个是目标图像和源图像； 当需要清空图像时，使用Mode.CLEAR 四、Canvas八、Canvas与图层(一)一、如何获得一个Canvas对象方法一：自定义view时， 重写onDraw、dispatchDraw方法（1）、定义我们先来看一下onDraw、dispatchDraw方法的定义1234567protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); &#125; protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); &#125; 可以看到onDraw、dispatchDraw在传入的参数中都有一个canvas对象。这个canvas对象是View中的Canvas对象，利用这个canvas对象绘图，效果会直接反应在View中； （2）、onDraw、dispatchDraw区别 onDraw()的意思是绘制视图自身 dispatchDraw()是绘制子视图 无论是View还是ViewGroup对它们俩的调用顺序都是onDraw()-&gt;dispatchDraw()但在ViewGroup中，当它有背景的时候就会调用onDraw()方法，否则就会跳过onDraw()直接调用dispatchDraw()；所以如果要在ViewGroup中绘图时，往往是重写dispatchDraw()方法在View中，onDraw()和dispatchDraw()都会被调用的，所以我们无论把绘图代码放在onDraw()或者dispatchDraw()中都是可以得到效果的，但是由于dispatchDraw()的含义是绘制子控件，所以原则来上讲，在绘制View控件时，我们是重新onDraw()函数。 总结在绘制View控件时，需要重写onDraw()函数，在绘制ViewGroup时，需要重写dispatchDraw()函数。 方法二：使用Bitmap创建1、构建方法Canvas c = new Canvas(bitmap); 或 Canvas c = new Canvas(); c.setBitmap(bitmap); 其中bitmap可以从图片加载，也可以创建，有下面几种方法 //方法一：新建一个空白bitmap Bitmap bmp = Bitmap.createBitmap(width ,height Bitmap.Config.ARGB_8888); //方法二：从图片中加载 Bitmap bmp = BitmapFactory.decodeResource(getResources(),R.drawable.wave_bg,null); 2、在OnDraw（）中使用我们一定要注意的是，如果我们用bitmap构造了一个canvas，那这个canvas上绘制的图像也都会保存在这个bitmap上，而不是画在View上，如果想画在View上就必须使用OnDraw（Canvas canvas）函数中传进来的canvas画一遍bitmap才能画到view上。 123456789101112131415161718192021222324public class BitmapCanvasView extends View &#123; private Bitmap mBmp; private Paint mPaint; private Canvas mBmpCanvas; public BitmapCanvasView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mBmp = Bitmap.createBitmap(500 ,500 , Bitmap.Config.ARGB_8888); mBmpCanvas = new Canvas(mBmp); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setTextSize(100); mBmpCanvas.drawText("启舰大SB",0,100,mPaint); canvas.drawBitmap(mBmp,0,0,mPaint); &#125; &#125; 方法三：SurfaceHolder.lockCanvas()Canvas除了save()和restore()以外，还有其它一些函数来保存和恢复画布状态，这部分我们就来看看。 1、saveLayer()saveLayer()有两个函数： /** * 保存指定矩形区域的canvas内容 */ public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) RectF bounds：要保存的区域的矩形。 int saveFlags：取值有：ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG、HAS_ALPHA_LAYER_SAVE_FLAG、FULL_COLOR_LAYER_SAVE_FLAG、CLIP_TO_LAYER_SAVE_FLAG总共有这六个，其中ALL_SAVE_FLAG表示保存全部内容 第二个构造函数实际与第一个是一样的，只不过是根据四个点来构造一个矩形。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class XfermodeView extends View &#123; private int width = 400; private int height = 400; private Bitmap dstBmp; private Bitmap srcBmp; private Paint mPaint; public XfermodeView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); srcBmp = makeSrc(width, height); dstBmp = makeDst(width, height); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.GREEN); int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); mPaint.setXfermode(null); canvas.restoreToCount(layerID); &#125; // create a bitmap with a circle, used for the "dst" image static Bitmap makeDst(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFFFFCC44); c.drawOval(new RectF(0, 0, w, h), p); return bm; &#125; // create a bitmap with a rect, used for the "src" image static Bitmap makeSrc(int w, int h) &#123; Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bm); Paint p = new Paint(Paint.ANTI_ALIAS_FLAG); p.setColor(0xFF66AAFF); c.drawRect(0, 0, w, h, p); return bm; &#125; &#125; 那么问题来了，如果我们把saveLayer给去掉，看看会怎样： 我们先回顾下Mode.SRC_IN的效果：在处理源图像时，以显示源图像为主，在相交时利用目标图像的透明度来改变源图像的透明度和饱和度。当目标图像透明度为0时，源图像就完全不显示。再回过来看结果，第一个结果是对的，因为不与圆相交以外的区域透明度都是0，而第二个图像怎么就变成了这屌样，源图像全部都显示出来了。 （1）、saveLayer的绘图流程这是因为在调用saveLayer时，会生成了一个全新的bitmap，这个bitmap的大小就是我们指定的保存区域的大小，新生成的bitmap是全透明的，在调用saveLayer后所有的绘图操作都是在这个bitmap上进行的。 1234int layerID = canvas.saveLayer(0, 0, width * 2, height * 2, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); 我们讲过，在画源图像时，会把之前画布上所有的内容都做为目标图像，而在saveLayer新生成的bitmap上，只有dstBmp对应的圆形，所以除了与圆形相交之外的位置都是空像素。在画图完成之后，会把saveLayer所生成的bitmap盖在原来的canvas上面。所以此时的xfermode的合成过程如下图所示： savelayer新建的画布上的图像做为目标图像，矩形所在的透明图层与之相交，计算结果画在新建的透明画布上。最终将计算结果直接盖在原始画布上，形成最终的显示效果。 （2）、没有saveLayer的绘图流程然后我们再来看第二个示例，在第二个示例中，唯一的不同就是把saveLayer去掉了；在saveLayer去掉后，所有的绘图操作都放在了原始View的Canvas所对应的Bitmap上了12345678protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.GREEN); canvas.drawBitmap(dstBmp, 0, 0, mPaint); mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(srcBmp, width / 2, height / 2, mPaint); mPaint.setXfermode(null); &#125; 由于我们先把整个画布给染成了绿色，然后再画上了一个圆形，所以在应用xfermode来画源图像的时候，目标图像当前Bitmap上的所有图像了，也就是整个绿色的屏幕和一个圆形了。所以这时候源图像的相交区域是没有透明像素的，透明度全是100%，这也就不难解释结果是这样的原因了。此时的xfermode合成过程如下： 由于没有调用saveLayer，所以圆形是直接画在原始画布上的，而当矩形与其相交时，就是直接与原始画布上的所有图像做计算的。总结saveLayer会创建一个全新透明的bitmap，大小与指定保存的区域一致，其后的绘图操作都放在这个bitmap上进行。在绘制结束后，会直接盖在上一层的Bitmap上显示。 2、画布与图层上面我们讲到了画布(Bitmap)、图层(Layer)和Canvas的概念，估计大家都会被绕晕了。下面我们下面来具体讲解下它们之间的关系。图层(Layer)：每一次调用canvas.drawXXX系列函数时，都会生成一个透明图层来专门来画这个图形，比如我们上面在画矩形时的透明图层就是这个概念。画布(bitmap)：每一个画布都是一个bitmap，所有的图像都是画在bitmap上的！我们知道每一次调用canvas.drawxxx函数时，都会生成一个专用的透明图层来画这个图形，画完以后，就盖在了画布上。所以如果我们连续调用五个draw函数，那么就会生成五个透明图层，画完之后依次盖在画布上显示。画布有两种，第一种是view的原始画布，是通过onDraw（Canvas canvas）函数传进来的，其中参数中的canvas就对应的是view的原始画布，控件的背景就是画在这个画布上的！另一种是人造画布，通过saveLayer()、new Canvas(bitmap)这些方法来人为新建一个画布。尤其是saveLayer()，一旦调用saveLayer()新建一个画布以后，以后的所有draw函数所画的图像都是画在这个画布上的，只有当调用restore()、resoreToCount()函数以后，才会返回到原始画布上绘制。Canvas:这个概念比较难理解，我们可以把Canvas理解成画板，Bitmap理解成透明画纸，而Layer则理解成图层；每一个draw函数都对应一个图层，在一个图形画完以后，就放在画纸上显示。而一张张透明的画纸则一层层地叠加在画板上显示出来。我们知道画板和画纸都是用夹子夹在一起的，所以当我们旋转画板时，所有画纸都会跟着旋转！当我们把整个画板裁小时，所以的画纸也都会变小了！这一点非常重要，当我们利用saveLayer来生成多个画纸时，然后最上层的画纸调用canvas.rotate(30)是把画板给旋转了，所有的画纸也都被旋转30度！这一点非常注意。另外，如果最上层的画纸调用canvas.clipRect()将画板裁剪了，那么所有的画纸也都会被裁剪。唯一能够恢复的操作是调用canvas.revert()把上一次的动作给取消掉！但在利用canvas绘图与画板不一样的是，画布的影响只体现在以后的操作上，以前画上去的图像已经显示在屏幕上是不会受到影响的。 三、save()、saveLayer()、saveLayerAlpha()中的用法1、saveLayer的用法public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) 我们前面提到了saveLayer会新建一个画布(bitmap)，后续的所有操作都是在这个画布上进行的。下面我们来分别看下saveLayer使用中的注意事项。 （1）、saveLayer后的所有动作都只对新建画布有效123456789101112131415161718192021public class SaveLayerUseExample_3_1 extends View&#123; private Paint mPaint; private Bitmap mBitmap; public SaveLayerUseExample_3_1(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.dog);; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mBitmap,0,0,mPaint); int layerID = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); canvas.skew(1.732f,0); canvas.drawRect(0,0,150,160,mPaint); canvas.restoreToCount(layerID); &#125; &#125; 在onDraw中，我们先在view的原始画布上画上了小狗的图像，然后利用saveLayer新建了一个图层，然后利用canvas.skew将新建的图层水平斜切45度。所以之后画的矩形(0,0,150,160)就是斜切的。而正是由于在新建画布后的各种操作都是针对新建画布来操作的，不会对以前的画布产生影响，从效果图中也明显可以看出，将画布水平斜切45度也只影响了saveLayer的新建画布，并没有对之前的原始画布产生影响。 （2）、通过Rect指定矩形大小就是新建的画布大小在saveLayer的参数中，我们可以通过指定Rect对象或者指定四个点来来指定一个矩形，这个矩形的大小就是新建画布的大小，我们举例来看一下：12345678910111213141516171819202122public class SaveLayerUseExample_3_1 extends View &#123; private Paint mPaint; private Bitmap mBitmap; public SaveLayerUseExample_3_1(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.dog); ; &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawBitmap(mBitmap, 0, 0, mPaint); int layerID = canvas.saveLayer(0, 0, 100, 100, mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawRect(0, 0, 500, 600, mPaint); canvas.restoreToCount(layerID); &#125; &#125; 在绘图时，我们先把小狗图片绘制在原始画布上的，然后新建一个大小为(0,0,100,100)大小的透明画布，然后再在这个画布上画一个(0, 0, 500, 600)的矩形。由于画布大小只有(0,0,100,100)，所以(0, 0, 500, 600)这个矩形并不能完全显示出来，也只能显示出来(0,0,100,100)画布大小的部分。那有些同学会说了，nnd，为了避免画布太小而出现问题，我每次都新建一个屏幕大小的画布多好，这样虽然是不会出现问题，但你想过没有，屏幕大小的画布需要多少空间吗，按一个像素需要8bit存储空间算，1024 768的机器，所使用的bit数就是1024 768 8=6.2M！所以我们在使用saveLayer新建画布时，一定要选择适当的大小，不然你的APP很可能OOM哦。*注意，注意：在我的例子中都是直接新建全屏画布的，因为写例子比较方便！！！！但是我这只是示例，在现实使用中，一定要适量的创建画布的大小哦！ 2、saveLayerAlpha的用法public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags) public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags) 相比saveLayer，多一个alpha参数，用以指定新建画布透明度,取值范围为0-255，可以用16进制的oxAA表示；这个函数的意义也是在调用的时候会新建一个bitmap画布，以后的各种绘图操作都作用在这个画布上，但这个画布是有透明度的，透明度就是通过alpha值指定的。 123456789101112131415161718192021public class SaveLayerAlphaView extends View &#123; private Paint mPaint; public SaveLayerAlphaView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(100,100,300,300,mPaint); int layerID = canvas.saveLayerAlpha(0,0,600,600,0x88,Canvas.ALL_SAVE_FLAG); mPaint.setColor(Color.GREEN); canvas.drawRect(200,200,400,400,mPaint); canvas.restoreToCount(layerID); &#125; &#125; 在saveLayerAlpha以后，我们画了一个绿色的矩形，由于把saveLayerAlpha新建的矩形的透明度是0x88（136）大概是50%透明度，从效果图中也可以看出在新建图像与上一画布合成后，是具有透明度的。 九、Canvas与图层（二）一、FLAG的具体意义1、FLAG概述有关save系列函数，在canvas中总共有如下几个： public int save() public int save(int saveFlags) public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags) public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags) 这段我们先关注前四个，save的两个函数和saveLayer的两个函数；我们知道他们两个不同之处在于saveLayer会新建一个画布，而save函数则不会新建画布；它们都具有Flag标识，这些Flag标识的意义和使用范围如下： FLAG 意义 适用范围 ALL_SAVE_FLAG 保存所有的标识 save()、saveLayer() MATRIX_SAVE_FLAG 仅保存canvas的matrix数组 save()、saveLayer() CLIP_SAVE_FLAG 仅保存canvas的当前大小 save()、saveLayer() HAS_ALPHA_LAYER_SAVE_FLAG 标识新建的bmp具有透明度，在与上层画布结合时，透明位置显示上图图像,与FULL_COLOR_LAYER_SAVE_FLAG冲突，若同时指定，则以HAS_ALPHA_LAYER_SAVE_FLAG为主 saveLayer() FULL_COLOR_LAYER_SAVE_FLAG 标识新建的bmp颜色完全独立，在与上层画布结合时，先清空上层画布再覆盖上去 saveLayer() CLIP_TO_LAYER_SAVE_FLAG 在保存图层前先把当前画布根据bounds裁剪，与CLIP_SAVE_FLAG冲突，若同时指定，则以CLIP_SAVE_FLAG为主 saveLayer() 从上面的表格中可以看到，ALL_SAVE_FLAG、MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG是save()、saveLayer()共用的。而另外三个是saveLayer()专用的；我们一个个来解析下它们的不同之处在讲解之前，我们先考虑一下，如果让我们保存一个画布的状态，以便恢复，我们需要保存哪些内容呢？第一个是位置信息，第二个是大小信息；好像除此之外也没什么了。所以，位置信息对应的是MATRIX_SAVE_FLAG，大小信息对应的是：CLIP_SAVE_FLAG，这也就是save\saveLayer所共用的，而另外的三个函数，则是指定saveLayer新建的bitmap具有哪种特性。已经不再是保存画布的范畴了。 2、FLAG之MATRIX_SAVE_FLAG(1)、save(int flag)与MATRIX_SAVE_FLAG我们知道canvas.translate(平移)、canvas.rotate（旋转）、canvas.scale（缩放）、canvas.skew（扭曲）其实都是利用位置矩阵matrix实现的，而MATRIX_SAVE_FLAG标识就是指定只保存这个位置矩阵，除此之外的其它任何内容都不会被保存。1234567891011121314151617181920212223public class MATRIX_SAVE_FLAG_View extends View &#123; private Paint mPaint; public MATRIX_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(Canvas.MATRIX_SAVE_FLAG); canvas.rotate(40); canvas.drawRect(100,0,200,100,mPaint); canvas.restore(); mPaint.setColor(Color.YELLOW); canvas.drawRect(100,0,200,100,mPaint); &#125; &#125; 我们直接看OnDraw函数，先调用 canvas.save(Canvas.MATRIX_SAVE_FLAG)将canvas的位置矩阵保存起来，然后将画布旋转40度之后，画一个绿色矩形；然后调用canvas.restore()之后将画布恢复，然后再在同一个位置画一个黄色的矩形。 很明显，在canvas.restore()后，画布的旋转给恢复到了原来了状态。然后我们再来看看，如果我们给画布裁剪，看还能不能被恢复 12345678910111213141516171819202122public class MATRIX_SAVE_FLAG_View extends View &#123; private Paint mPaint; public MATRIX_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(Canvas.MATRIX_SAVE_FLAG); canvas.clipRect(100,0,200,100); canvas.drawColor(Color.GREEN); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 从效果图来看，我们恢复画布后，把画布全部染成了黄色，但并没有染全屏幕的画布，而只是clip后的一部分，这说明，被裁剪的画布没有被还原！前面我们说了调用 canvas.save(Canvas.MATRIX_SAVE_FLAG)只会保存了位置矩阵！恢复时，也只会恢复画布的位置信息，有关画布的大小，是不会被恢复的！ （2）、saveLayer()与MATRIX_SAVE_FLAG同样先来看旋转的例子：12345678910111213141516171819202122232425public class MATRIX_SAVE_FLAG_View extends View &#123; private Paint mPaint; public MATRIX_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.rotate(40); canvas.drawRect(100,0,200,100,mPaint); canvas.restore(); mPaint.setColor(Color.YELLOW); canvas.drawRect(100,0,200,100,mPaint); &#125; &#125; 这里在保存Flag时，多了一个Canvas.HAS_ALPHA_LAYER_SAVE_FLAG，表示在新建的画布在合成到上一个画布上时，直接覆盖，不清空所在区域原图像，这个标识这里先忽略，我们后面会具体讲。效果与原因都是与save()相同，指定保存Canvas.MATRIX_SAVE_FLAG，即canvas的位置信息，当调用canvas.revert()后，原始画布的旋转被恢复。所以再次画图到原始画布上时，是没有旋转的。我们还是直接来看例子吧，裁剪： 1234567891011121314151617181920212223public class MATRIX_SAVE_FLAG_View extends View &#123; private Paint mPaint; public MATRIX_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.GREEN); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.clipRect(100,0,200,100); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 与上面的例子一样，在saveLayer中也只是保存Canvas.MATRIX_SAVE_FLAG，即canvas的位置信息，之后调用canvas.clipRect(100,0,200,100);将画板裁剪，注意我们在讲解canvas时提到了，无论哪个图层调用canvas的位置变换和裁剪操作，所有的画布都会受到连累，这些连累也只表现在画布以后的绘图上，之前画过的图像不会受到影响。所以在clipRect之前画出来的全屏绿色是不受影响的，当restore()以后，canvas只恢复了原始画布的位置信息而原始画布的大小却无法被恢复，所以当再调用 canvas.drawColor(Color.YELLOW)，也只能画出来一小块了。注意：在上面的例子中用到了canvas.clipRect()，这个函数是不支持硬件加速的，所以需要添加setLayerType函数来禁用硬件加速。总结 当save\saveLayer调用Canvas.MATRIX_SAVE_FLAG标识时只会保存画布的位置矩阵信息，在canvas.restore()时也只会恢复位置信息，而改变过的画布大小是不会被恢复的。 当使用canvas.saveLayer(Canvas.MATRIX_SAVE_FLAG)时，需要与Canvas.HAS_ALPHA_LAYER_SAVE_FLAG一起使用，不然新建画布所在区域原来的图像将被清空。 3、FLAG之CLIP_SAVE_FLAG这个标识的意思是仅保存Canvas的裁剪信息，而对于位置信息则不管不问，所以在canvas.restore()时，会只恢复Canvas的大小，而对于Canvas的旋转、平移等位置改变的信息是不会恢复的。 (1)、save(int flag)与CLIP_SAVE_FLAG我们先来看个裁剪的例子：123456789101112131415161718192021public class CLIP_SAVE_FLAG_View extends View &#123; private Paint mPaint; public CLIP_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.save(Canvas.CLIP_SAVE_FLAG); canvas.clipRect(100,0,200,100); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 从效果图中可以看出在canvas.restore()后，canvas被恢复到初始化的全屏大小。然后我们再看一个旋转的例子1234567891011121314151617181920212223public class CLIP_SAVE_FLAG_View extends View &#123; private Paint mPaint; public CLIP_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(Color.GREEN); canvas.drawRect(100,0,200,100,mPaint); canvas.save(Canvas.CLIP_SAVE_FLAG); canvas.rotate(40); canvas.restore(); mPaint.setColor(Color.YELLOW); canvas.drawRect(100,0,200,100,mPaint); &#125; &#125; 我们先画了一个绿色的矩形，之后旋转画布，然后在调用 canvas.restore()恢复画布之后，再画上一个同样的黄色矩形。从效果图中可以看出，canvas在恢复时，并没有恢复旋转的画布，这也就是Canvas.CLIP_SAVE_FLAG的意义所在，只保存裁剪信息，不保存位置信息，所以恢复时，位置信息是不会被恢复的！ (2)、saveLayer(int flag)与CLIP_SAVE_FLAG在添加上Canvas.HAS_ALPHA_LAYER_SAVE_FLAG标识以后，效果与canvas.save相同，这里就简单讲解一下。先看裁剪的例子： 123456789101112131415161718public class CLIP_SAVE_FLAG_View extends View &#123; private Paint mPaint; public CLIP_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.clipRect(100,0,200,100); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 效果与canvas.save一样，原因也很简单，因为Canvas.CLIP_SAVE_FLAG标识是可以恢复裁剪信息的。然后再来看看旋转。 1234567891011121314151617181920212223public class CLIP_SAVE_FLAG_View extends View &#123; private Paint mPaint; public CLIP_SAVE_FLAG_View(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setColor(Color.GREEN); canvas.drawRect(100,0,200,100,mPaint); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG|Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.rotate(40); canvas.restore(); mPaint.setColor(Color.YELLOW); canvas.drawRect(100,0,200,100,mPaint); &#125; &#125; 因为Canvas.CLIP_SAVE_FLAG不能保存位置信息，所以在canvas.restore()后，旋转并没有被恢复。 总结 当save/saveLayer调用 Canvas.CLIP_SAVE_FLAG时只会保存画布的裁剪信息，在canvas.restore()时也只会恢复裁剪信息，而改变过的画布位置信息是不会被恢复的。 当使用canvas.saveLayer(Canvas.CLIP_SAVE_FLAG)时，需要与Canvas.HAS_ALPHA_LAYER_SAVE_FLAG一起使用，不然新建画布所在区域原来的图像将被清空。 4、FLAG之HAS_ALPHA_LAYER_SAVE_FLAG和FULL_COLOR_LAYER_SAVE_FLAG这两个标识都是saveLayer()专用的HAS_ALPHA_LAYER_SAVE_FLAG表示新建的bitmap画布在与上一个画布合成时，不会将上一层画布内容清空，直接盖在上一个画布内容上面。FULL_COLOR_LAYER_SAVE_FLAG则表示新建的bimap画布在与上一个画布合成时，先将上一层画布对应区域清空，然后再盖在上面。下面我们分别举例子来看注意一定要在view中禁用掉硬件加速，因为在api 21之后，才支持saveLayer (1)、FULL_COLOR_LAYER_SAVE_FLAG12345678910111213141516171819public class ALPHA_COLOR_FALG_VIEW extends View &#123; private Paint mPaint; public ALPHA_COLOR_FALG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,500,500,mPaint,Canvas.FULL_COLOR_LAYER_SAVE_FLAG); canvas.drawRect(100,100,300,300,mPaint); canvas.restore(); &#125; &#125; 我们在saveLayer时，新建bitmap画布的大小为(0,0,500,500)，然后在新建画布中画了一个矩形(100,100,300,300)，由于我们使用的标识是Canvas.FULL_COLOR_LAYER_SAVE_FLAG，所以新建画布在与上一层画布合成时，会先把上一层画布对应区域的图像清空掉，然后再盖上新建画布。由于新建画布中除了绿色矩形，其它位置都是透明像素，所以就显示出Activity的底色（黑色）。如果你把activity的背景色在xml中设置为白色，做出来的效果图中，露出来的就是白色了： main.xml1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:background="#ffffff" &gt; (2)、HAS_ALPHA_LAYER_SAVE_FLAG我把简单把上面的示例代码改一下，把Canvas.FULL_COLOR_LAYER_SAVE_FLAG改成Canvas.HAS_ALPHA_LAYER_SAVE_FLAG：12345678910111213141516171819public class ALPHA_COLOR_FALG_VIEW extends View &#123; private Paint mPaint; public ALPHA_COLOR_FALG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,500,500,mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); canvas.drawRect(100,100,300,300,mPaint); canvas.restore(); &#125; &#125; （3）、共用时，以HAS_ALPHA_LAYER_SAVE_FLAG为主很明显这两个标识是相互冲突的，因为Canvas.HAS_ALPHA_LAYER_SAVE_FLAG表示直接盖上去而不清空上一画布的图像，而Canvas.FULL_COLOR_LAYER_SAVE_FLAG则表示先将上一画布对应区域图像清空，然后再盖上去。当他们共用时，以哪个标识位为主呢？ 123456789101112131415161718public class ALPHA_COLOR_FALG_VIEW extends View &#123; private Paint mPaint; public ALPHA_COLOR_FALG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,500,500,mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG | Canvas.FULL_COLOR_LAYER_SAVE_FLAG); canvas.drawRect(100,100,300,300,mPaint); canvas.restore(); &#125; &#125; 所以从效果图中也可以看出，当这两个标识同时使用时，以Canvas.HAS_ALPHA_LAYER_SAVE_FLAG为主。 （4）、当saveLayer只指定MATRIX_SAVE_FLAG/CLIP_SAVE_FLAG的合成方式前面我们在讲解saveLayer的MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG标识时，都强制加上了Canvas.HAS_ALPHA_LAYER_SAVE_FLAG标识，意思是让其在合成时不清空上一画布图像。那么问题来了，当我们只指定MATRIX_SAVE_FLAG、CLIP_SAVE_FLAG标识时，Android默认的合成方式哪一个呢？ 123456789101112131415161718192021public class ALPHA_COLOR_FALG_VIEW extends View &#123; private Paint mPaint; public ALPHA_COLOR_FALG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0,0,500,500,mPaint,Canvas.MATRIX_SAVE_FLAG); canvas.rotate(40); canvas.drawRect(100, 100, 300, 300, mPaint); canvas.restore(); &#125; &#125; 从效果图中可以看出，在默认情况下使用的是Canvas.FULL_COLOR_LAYER_SAVE_FLAG标识，即先清空上一层画布对应区域的图像，然后再合成，所以这也是我们在上面的例子中强制添加HAS_ALPHA_LAYER_SAVE_FLAG标识的原因 总结 HAS_ALPHA_LAYER_SAVE_FLAG表示新建的bitmap画布在与上一个画布合成时，不会将上一层画布内容清空，直接盖在上一个画布内容上面。 FULL_COLOR_LAYER_SAVE_FLAG则表示新建的bimap画布在与上一个画布合成时，先将上一层画布对应区域清空，然后再盖在上面。 当HAS_ALPHA_LAYER_SAVE_FLAG与FULL_COLOR_LAYER_SAVE_FLAG两个标识同时指定时，以HAS_ALPHA_LAYER_SAVE_FLAG为主 当即没有指定HAS_ALPHA_LAYER_SAVE_FLAG也没有指定FULL_COLOR_LAYER_SAVE_FLAG时，系统默认使用FULL_COLOR_LAYER_SAVE_FLAG； 5、FLAG之CLIP_TO_LAYER_SAVE_FLAG（1）、概述这个标识比较犯贱，它的意义是，在新建bitmap前，先把canvas给裁剪，前面我们讲过canvas代表的是画板的意思，一旦画板被裁剪，那么其中的各个画布都会被受到影响。而且由于它是在新建bitmap前做的裁剪，所以是无法恢复的！12345678910111213141516171819public class CLIP_TO_LAYER_SAVE_FLAG_VIEW extends View &#123; private Paint mPaint; public CLIP_TO_LAYER_SAVE_FLAG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0, 0, 500, 500, mPaint, Canvas.CLIP_TO_LAYER_SAVE_FLAG); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 从效果图中可以看出，当我们调用canvas.saveLayer(0, 0, 500, 500, mPaint, Canvas.CLIP_TO_LAYER_SAVE_FLAG)时，canvas画板就被裁剪了，不仅影响了自己，而且还把view的原始画布给影响了，虽然在调用了canvas.restore()，但最后一句在将原始画布填充为黄色，也可以看出，原始画布没有被恢复！ （2）、与CLIP_SAVE_FLAG共用时，Canvas将被恢复我们知道，前面有一个保存裁剪信息的标识：CLIP_SAVE_FLAG，假如我们让它裁剪时，先保存裁剪区域，是不是可以恢复过来呢？12345678910111213141516171819public class CLIP_TO_LAYER_SAVE_FLAG_VIEW extends View &#123; private Paint mPaint; public CLIP_TO_LAYER_SAVE_FLAG_VIEW(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.GREEN); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.RED); canvas.saveLayer(0, 0, 500, 500, mPaint, Canvas.CLIP_SAVE_FLAG | Canvas.CLIP_TO_LAYER_SAVE_FLAG); canvas.restore(); canvas.drawColor(Color.YELLOW); &#125; &#125; 从效果图中可以看出canvas被恢复了，不过canvas被恢复也，也就失去了Canvas.CLIP_TO_LAYER_SAVE_FLAG标识的意义了。总结 CLIP_TO_LAYER_SAVE_FLAG意义是在新建bitmap前，先把canvas给裁剪，一旦画板被裁剪，那么其中的各个画布都会被受到影响。而且由于它是在新建bitmap前做的裁剪，所以是无法恢复的； 当CLIP_TO_LAYER_SAVE_FLAG与CLIP_SAVE_FLAG标识共用时，在调用restore()后，画布将被恢复 6、FLAG之ALL_SAVE_FLAG这个标识是我们最常用的，它是所有标识的公共集合。对于save(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG；即保存位置信息和裁剪信息对于save(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG很容易理解，因为save(int flag)函数只能使用MATRIX_SAVE_FLAG 、CLIP_SAVE_FLAG这两个标识。对于saveLayer(int flag)来讲，ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG；即保存保存位置信息和裁剪信息，新建画布在与上一层画布合成时，不清空原画布内容。原本来讲saveLayer的ALL_SAVE_FLAG标识应当是它所能使用的所有标识的集合，即应当是ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG|FULL_COLOR_LAYER_SAVE_FLAG|CLIP_TO_LAYER_SAVE_FLAG,但由于HAS_ALPHA_LAYER_SAVE_FLAG与FULL_COLOR_LAYER_SAVE_FLAG共用时以HAS_ALPHA_LAYER_SAVE_FLAG为主，CLIP_TO_LAYER_SAVE_FLAG与CLIP_SAVE_FLAG共用时，CLIP_TO_LAYER_SAVE_FLAG将无效，所以最终ALL_SAVE_FLAG = MATRIX_SAVE_FLAG | CLIP_SAVE_FLAG|HAS_ALPHA_LAYER_SAVE_FLAG；在理解了上面各个TAG的样式以后，这个TAG的难度几乎没有，这里就不再举例了。 四、restore()与restoreToCount()1、restore()restore()的作用就是把回退栈中的最上层画布状态出栈，恢复画布状态. 2、restoreToCount(int count)public int save() public int save(int saveFlags) public int saveLayer(RectF bounds, Paint paint, int saveFlags) public int saveLayer(float left, float top, float right, float bottom,Paint paint, int saveFlags) public int saveLayerAlpha(RectF bounds, int alpha, int saveFlags) public int saveLayerAlpha(float left, float top, float right, float bottom,int alpha, int saveFlags) 在save()、saveLayer()、saveLayerAlpha()保存画布后，都会返回一个ID值，这个ID值表示当前保存的画布信息的栈层索引（从0开始），比如保存在第三层，则返回2； public void restoreToCount(int saveCount); 它表示一直退栈，一直退到指定count的层数为栈顶为止；注意这个saveCount起始值是从1开始的，也就是说它比对应栈的索引要多1；比如，我们开始的栈已经有两层，然后我们调用如下代码： int id = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); canvas.restoreToCount(id); 调用canvas.saveLayer后，新保存的画布放在了第三层，返回的id的值是对应的索引即2而canvas.restoreToCount(id);则表示一直退栈，把栈一直退到第二层在栈顶的位置，刚好把新建的第三层给退出掉。所以利用这个特性，我们可以调用save函数的时候，把对应的id保存住，然后canvas.restoreToCount(id)就可以把栈的状态回退到生成这个id前的状态。下面我们举个例子来看下： 1234567891011121314151617181920212223242526272829303132333435public class RestoreToCountView extends View &#123; private Paint mPaint; private String TAG = "qijian"; public RestoreToCountView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(); mPaint.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int id1 = canvas.save(); canvas.clipRect(0,0,800,800); canvas.drawColor(Color.RED); Log.d(TAG,"count:"+canvas.getSaveCount()+" id1:"+id1); int id2 = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); canvas.clipRect(100,100,700,700); canvas.drawColor(Color.GREEN); Log.d(TAG,"count:"+canvas.getSaveCount()+" id2:"+id2); int id3 = canvas.saveLayerAlpha(0,0,getWidth(),getHeight(),0xf0,Canvas.ALL_SAVE_FLAG); canvas.clipRect(200,200,600,600); canvas.drawColor(Color.YELLOW); Log.d(TAG,"count:"+canvas.getSaveCount()+" id3:"+id3); int id4 = canvas.save(Canvas.ALL_SAVE_FLAG); canvas.clipRect(300,300,500,500); canvas.drawColor(Color.BLUE); Log.d(TAG,"count:"+canvas.getSaveCount()+" id4:"+id4); &#125; &#125; 在onDraw函数中，我们连续对canvas做裁剪，并且在裁剪后，把当前画布画上一层不同的颜色，然后把当前的栈的层数和最高层的索引打出来效果图如下： Log日志如下： 然后我们更改一下上面的代码：123456789101112131415161718192021222324252627protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int id1 = canvas.save(); canvas.clipRect(0,0,800,800); canvas.drawColor(Color.RED); Log.d(TAG,"count:"+canvas.getSaveCount()+" id1:"+id1); int id2 = canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); canvas.clipRect(100,100,700,700); canvas.drawColor(Color.GREEN); Log.d(TAG,"count:"+canvas.getSaveCount()+" id2:"+id2); int id3 = canvas.saveLayerAlpha(0,0,getWidth(),getHeight(),0xf0,Canvas.ALL_SAVE_FLAG); canvas.clipRect(200,200,600,600); canvas.drawColor(Color.YELLOW); Log.d(TAG,"count:"+canvas.getSaveCount()+" id3:"+id3); int id4 = canvas.save(Canvas.ALL_SAVE_FLAG); canvas.clipRect(300,300,500,500); canvas.drawColor(Color.BLUE); Log.d(TAG,"count:"+canvas.getSaveCount()+" id4:"+id4); canvas.restoreToCount(id3); canvas.drawColor(Color.GRAY); Log.d(TAG,"count:"+canvas.getSaveCount()); &#125; 我们在最后添加上canvas.restoreToCount(id3);，然后把画布整个绘成灰色。效果图如下： Log日志如下： 从代码中可以看出调用canvas.restoreToCount(id3)后，将恢复到生成id3之前的画布状态，id3之前的画布状态就是(100,100,700,700) 3、restore()与restoreToCount(int count)关系它们两个针对的都是同一个栈，所以是完全可以通用的，不同的是restore()是默认将栈顶内容退出还原画布，而restoreToCount(int count)则是一直退栈，直到指定层count做为栈顶，将此之前的所有动作都恢复。大家可能还有个疑问，前面我们讲了各种FLAG，在应用不同FLAG时，都是保存在同一个栈中吗，我们下面试一下 12345678910111213141516171819202122232425262728public class RestoreToCountView extends View &#123; private Paint mPaint; private String TAG = "qijian"; public RestoreToCountView(Context context, AttributeSet attrs) &#123; super(context, attrs); setLayerType(View.LAYER_TYPE_SOFTWARE, null); mPaint = new Paint(); mPaint.setColor(Color.RED); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.save(); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.save(Canvas.ALL_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.CLIP_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.MATRIX_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.HAS_ALPHA_LAYER_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); Log.d(TAG,"count:"+canvas.getSaveCount()); &#125; &#125; 在这个例子中，我们多次调用不同的save函数和不同的FLAG，然后将栈中层数打出来，日志如下： 从效果图中可以明显看出，每save一次，栈的层数都在加一，所以无论哪种save方法，哪个FLAG标识，保存画布时都使用的是同一个栈所以restore()与restoreToCount(int count)的结论来了： restore的意义是把回退栈中的最上层画布状态出栈，恢复画布状态。restoreToCount(int count)的意义是一直退栈，直到指定层count做为栈顶，将此之前的所有动作都恢复。 所以无论哪种save方法，哪个FLAG标识，保存画布时都使用的是同一个栈 restore()与restoreToCount(int count)针对的都是同一个栈，所以是完全可以通用和混用的。 好了，有关保存图层的知识到这里就结束了，这两篇内容理解起来可能会比较困难，多看两遍喽，有关FLAG标识的知识，如果看不懂就算了，会用ALL_SAVE_FLAG就行，其它标识用到的机会比较少。 五、实例操作一、QQ红点拖动删除效果实现（基本原理篇）前几篇给大家讲了有关绘图的知识，这篇我们稍微停一下，来看下手机QQ中拖动删除的效果是如何实现的；这篇涉及到的知识有： saveLayer图层相关知识 Path的贝赛尔曲线 手势监听 animationlist逐帧动画 这里有三个效果点： 拉长效果的实现 拉的不够长时返回初始状态 拉的够长后显示爆炸消除效果 一、拉伸效果实现1、实现原理一上来先给大家讲本篇最难的部分，这点理解了，后面就轻松了本节先实现一个圆圈的拉伸效果，效果图如下： 看起来是不是挺好玩的，跟拉弹弓一样，这里主要有两个效果组成： 新加一个跟圆圈跟手指位置移动的圆 两个圆之间的连线填充用贝赛尔曲线 拼接过程如下图： 从上面的拼接图中可以看出，整个拉伸效果是由两个圆和中间的贝赛尔曲线连线所组成的矩形所组成的。在贝赛尔曲线部分我们已经讲了，贝赛尔曲线关键地在于控件点的坐标如何动态的确定，我们已经说过贝赛尔曲线的控制点我们可以借助PhtotoShop的钢笔工具来找；那我们就来借助钢笔工具来找一下，如下图：我们单独拿出来最终的结果图来看一下：P0,P1是两个圆的切线的交点（切点），Q0是二阶贝赛尔曲线的控制点。从图中大概可以看出Q0的位置应该在两个圆心连线的中点。在知道两个圆心点位置以后，Q0点的坐标很容易求得，但是P0,P1的坐标要怎么来求得现在的当务之急了。先给大家画个图来看求下图中P0点的坐标这里演示的是圆形向右下拉的过程(为什么选择向右下拉为例来计算坐标我们后面会讲)，左上角的圆形是初始圆形（圆心坐标是x0,yo），右下角的圆形是拖动后的圆形（圆心坐标是x1,y1);首先，在这个图中有四个切点P0,P1,P2,P3；这四个切点的坐标就是我们所要求的。我们这里以求P0为例来演示下求坐标的过程。先看P0所在位置所形成的三角形，所在初始圆形的坐标是（x0,y0）我们单独把这个三角形拿出来，这里可以很明显的可以看出P0的坐标是： x = x0 + r * sina; y = y0 - r * cosa; 由于屏幕坐标系是X轴向右为正，Y轴向下为正。所以P0的X坐标是比圆形x0坐标大的，所以要加上r sina；而P0的Y坐标是在圆形y0坐标的上方，比y0小，所以要减去r cosa;用同样的方法可以求出P1,P2,P3的坐标公式: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//P1x = x1 + r * sina;y = y1 - r * cosa;//P2x = x1 - r * sina;y = y1 + r * cosa;//P3x = x0 - r * sina;y = y0 + r * cosa;``` 那么问题来了，角度a的值是多少呢？ 我们再回过头来看一下我们的高清无码大图: ![20170218148742763582964.png](http://ohtrrgyyd.bkt.clouddn.com/20170218148742763582964.png)tan(a) = dy/dx; 所以a = arctan(dy/dx); 这样角度a的值就求到了，自然sina和cosa也就得到了。 ##### 2、代码实现下面我们就来看一下如何用代码来实现这个手拖动的过程；&gt; 注意：这篇博客并不是要制造出来一个通用组件，而是主要为了讲解拖动消除的原理，后面我们会逐渐对这篇文章进行扩充，最终将产出一个通用控件！慢慢来吧###### （1）、新建类及初始化 由于我们这篇是讲解基本原理，所以我们新建一个类派生自FramLayout，然后在这个类中做绘图等等操作。``` javapublic class RedPointView extends FrameLayout &#123; private PointF mStartPoint, mCurPoint; private int mRadius = 20; private Paint mPaint; private Path mPath; public RedPointView(Context context) &#123; super(context); initView(); &#125; public RedPointView(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public RedPointView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initView(); &#125; private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); mPath = new Path(); &#125;&#125; 我们新建了一个RedPointView类派生自FramLayout，然后添加了一个初始化函数：1234567891011private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); mPath = new Path();&#125; 首先是两个点坐标，分别表示两个圆的圆心位置。mStartPoint表示起始圆心位置，mCurPoint是当前手指的位置，也就是移动的圆心位置。然后是初始化Paint和Path。 （2）、圆随着手指移动这部分的效果图如下：当手指移动时新画一个圆在随着手指移动所以我们要先定义一个变量表示当前用户的手指是不是下按状态，如果是下按状态就根据当前手指的位置多画一个圆.完整代码如下： 123456789101112131415161718192021222324252627@Overrideprotected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); if (mTouch) &#123; canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mTouch = true; &#125; break; case MotionEvent.ACTION_UP: &#123; mTouch = false; &#125; &#125; mCurPoint.set(event.getX(), event.getY()); postInvalidate(); return true;&#125; 我们先来看看对onTouchEvent的拦截过程，在onTouchEvent中，在手指下按时将mTouch赋值为true，在手机抬起时赋值为false;然后将当前手指的位置传给mCurPoint保存，然后调用postInvalidate()强制重绘；最后return true表示当前消息到此为止，就不再往父控件传了。以前我们讲过postInvalidate()和invadite()的区别，这里再简单说一下：invadite()必须在主线程中调用，而postInvalidate()内部是由Handler的消息机制实现的，所以在任何线程都可以调用，但实时性没有invadite()强。所以一般为了保险起见，一般是使用postInvalidate()来刷新界面。 由于我们这里是继承自FrameLayout所以是重写dispatchDraw()函数来进行重绘我们来看看dispatchDraw中实现代码，这里可谓是有难度：1234567891011protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); if (mTouch) &#123; canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; super.dispatchDraw(canvas)操作的位置问题。首先是super.dispatchDraw(canvas)放的位置很重要，我们有时把它写在绘图操作的最上方，有时把它写在所有绘图操作的最下方，关于这两个位置是有很大差别的，有关位置的问题，下面我们会再讲，这里放在哪里都不会有影响。 canvas.saveLayer()与canvas.restore()是Canvas的绘图操作 最后是画初始圆和移动圆的位置 1234canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint);if (mTouch) &#123; canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint);&#125; 这里主要是根据当前手指是不是在移动来判断是不是画出随手指移动的圆。代码难度不大就不再细讲了。到这里，我们就实现了两个圆的显示了，最关键的部分来了——下面就是要看如何利用贝赛尔曲线把这两个圆连接起来。 (3)、贝赛尔曲线连接两个圆首先，我们先看如何把路径给计算出来的： 12345678910111213141516171819202122232425262728293031323334353637383940//圆半径private int mRadius = 20;private void calculatePath() &#123; //这里就是根据两个圆心坐标来计算出dx,dy，然后利用double a = Math.atan(dy / dx)得到夹角a的值，然后求得mRadius * Math.sin(a) 和 mRadius * Math.cos(a)的值； float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; // 根据角度算出四边形的四个点 float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); // 根据角度算出四边形的四个点 float x1 = startX + offsetX; float y1 = startY - offsetY; float x2 = x + offsetX; float y2 = y - offsetY; float x3 = x - offsetX; float y3 = y + offsetY; float x4 = startX - offsetX; float y4 = startY + offsetY; float anchorX = (startX + x) / 2; float anchorY = (startY + y) / 2; //最后把这四个点连起来： mPath.reset(); mPath.moveTo(x1, y1); mPath.quadTo(anchorX, anchorY, x2, y2); mPath.lineTo(x3, y3); mPath.quadTo(anchorX, anchorY, x4, y4); mPath.lineTo(x1, y1);&#125; 根据我们画的图中也可以知道，P0-P1，P2-P3是用贝赛尔曲线连起来的，P1-P2,P3-P0是用直线连起来的；在我们得到当前的路径以后，下面就是画图的问题了： 12345678910111213protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; 其实就是添加在手指下按时，先用calculatePath()计算路径然后再利用canvas.drawPath(mPath, mPaint)把路径画出来的过程，难度不大就不再讲了。到这里，我们这节开始时的效果就实现了，效果图如刚开始时所示。 贴出来完整代码给大家参考下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class RedPointView extends FrameLayout &#123; private PointF mStartPoint, mCurPoint; private int mRadius = 20; private Paint mPaint; private Path mPath; private boolean mTouch = false; public RedPointView(Context context) &#123; super(context); initView(); &#125; public RedPointView(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public RedPointView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initView(); &#125; private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); mPath = new Path(); &#125; private void calculatePath() &#123; float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); // 根据角度算出四边形的四个点 float x1 = startX - offsetX; float y1 = startY + offsetY; float x2 = x - offsetX; float y2 = y + offsetY; float x3 = x + offsetX; float y3 = y - offsetY; float x4 = startX + offsetX; float y4 = startY - offsetY; float anchorX = (startX + x) / 2; float anchorY = (startY + y) / 2; mPath.reset(); mPath.moveTo(x1, y1); mPath.quadTo(anchorX, anchorY, x2, y2); mPath.lineTo(x3, y3); mPath.quadTo(anchorX, anchorY, x4, y4); mPath.lineTo(x1, y1); &#125; @Override protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint); &#125; canvas.restore(); super.dispatchDraw(canvas); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mTouch = true; &#125; break; case MotionEvent.ACTION_UP: &#123; mTouch = false; &#125; &#125; mCurPoint.set(event.getX(), event.getY()); postInvalidate(); return true; &#125;&#125; 3、疑问：当手指拖动位置不同时，也能统一处理求得各个点坐标？细心的同学可能会发现，同样是P0,P1,P2,P3四个切点，当移动圆的位置变化时，四个点的计算公式是会变化的，我们同样以P0点为例来看下当手指移动点在右下方时的公式为 x = x0 + r * sina; y = y0 - r * cosa; 那么当手指移动点在左上方时，它的公式又为：在变为左上方时，P0点的X坐标就跑到了原点(x0,y0)的左侧，从图像中不难看出P0点的坐标为： x = x0 - r * sina; y = y0 - r * cosa; 但是我们在计算时全部都是使用x = x0 + r * sina;这个公式来计算的，明明在这种情况下使用同一个公式是有问题的，但出来的效果为什么却是正确的呢？这是因为Math的三角函数取值是有正有负的，当Math.atan(double value)的入参value是负值是，它对应的输出的角度值也是负值，同样，Math.sin(double a) 的输出值也是负值所在因为在手指移动点在左上角时，dx正值，dy却是负值，所以利用a =Math.atan(dy/dx)求得的角度a是负值，进而sina和cos都是负值这里其实是用到了正弦函数和余弦函数的几个性质： sin(-a) = - sina; cos(-a) = cosa; sin(π/2-α) = cosα cos(π/2-α) = sinα 所以当a值为负值时： x = x0 + r * sin（-a）; y = y0 - r * cosa; 也就变成了下面的公式了： x = x0 - r * sina; y = y0 - r * cosa; 这也是我们为什么用同一个公式能解决所有情况的原因所在！但我们在得到这个公式时，必须在保证dx,dy都为正值的情况下，因为此时夹角a必然是正值，不存在数学换算的问题；不然如果dx,dy中任意一个为负数时，夹角a也将是负值，此时你将算得头大…… 二、自定义文字与爆炸效果上面把最难的拉伸效果实现以后，下面就要完整的来实现开篇的功能了，再来看下最终的效果图：除了拉伸效果以后，还有一个TextView用来设置文字，另外在超出定长以后消失时会有爆炸效果我们先来实现添加TextView，然后再添加爆炸效果. 1、添加TextView我们添加TextVIew后所实现的功能的效果图为：添加TextView后需要添加三个功能： 初始只显示TextView，而不显示原来的圆圈 点击TextView所在区域才能移动TextVIew 移动时，TextView跟随手指移动，同时显示原TextVIew所在的圆圈和贝赛尔连接线 本着上面几个功能点，我们一步步来实现 （1）、添加并初始化TextView首先，我们要在初始化的时候原布局中添加一个TextView控件：1234567891011121314151617181920private TextView mTipTextView;private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); mTipTextView = new TextView(getContext()); mTipTextView.setLayoutParams(params); mTipTextView.setPadding(10, 10, 10, 10); mTipTextView.setBackgroundResource(R.drawable.tv_bg); mTipTextView.setTextColor(Color.GREEN); mTipTextView.setText("99+"); addView(mTipTextView);&#125; 这段代码难度不大，就是在原来初始化的基础上向ViewGroup中添加一个TextVIew控件，并做一些基本的设置。我们这里把TextView的一些设置都写死在类内部了，这样是为了讲解方便，但如果要集成为公用控件，当然要把这些设置文字内容和颜色暴露给外部，最简单的方法就向外部暴露一个getTextView()的方法，把当前TextView的对象直接返回给外部，让它直接可以设置TextView；上面的代码中有一个设置TextView背景的代码： mTipTextView.setBackgroundResource(R.drawable.tv_bg)，对应的xml文件为：123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;corners android:radius="10dp"/&gt; &lt;solid android:color="#ff0000"/&gt; &lt;stroke android:color="#0f000000" android:width="1dp"/&gt;&lt;/shape&gt; 就是给TextView添加带有圆角的红色背景，另外还加了个不怎么黑的描边。 （2）、点击TextView时才允许拖动我们需要在用户点击区域在TextView内部时才允许拖动TextView：12345678910111213141516171819202122232425262728public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; // 判断触摸点是否在tipImageView中 //拿到当前TextView所在屏幕的位置矩形 Rect rect = new Rect(); int[] location = new int[2]; mTipTextView.getLocationOnScreen(location); rect.left = location[0]; rect.top = location[1]; rect.right = mTipTextView.getWidth() + location[0]; rect.bottom = mTipTextView.getHeight() + location[1]; //然后就是判断当前手指所在位置是不是在这个矩形内了： if (rect.contains((int) event.getRawX(), (int) event.getRawY())) &#123; mTouch = true; &#125; &#125; break; case MotionEvent.ACTION_UP: &#123; //抬起手指时还原位置 mTouch = false; &#125; break; &#125; mCurPoint.set(event.getX(), event.getY()); postInvalidate(); return true;&#125; 这里主要是在MotionEvent.ACTION_DOWN的时候，判断当前当前手指区域是否在TextView内部，如果是就将mTouch赋值为true；这里涉及的一个函数还没的一直没有提及这里给大家讲一下： public void getLocationOnScreen(int[] location) 该函数的功能是获取当前控件所在屏幕的位置，传进去一个location的数组，在执行以后会把left,top值赋给location[0]和location[1].这里最主要注意的是，我们前面讲了getLocationOnScreen()函数得到的位置是屏幕坐标，所以我们也必须拿到手指的屏幕坐标，所以event.getRawX()得到的就是相对屏幕的坐标以前在博客中也讲到过getX与getRawX的区别：getX()得到是相对当前控件左上角的坐标，而getRawX是得到在屏幕中的坐标，在第三部曲中会单独开一篇来讲解有关坐标的知识，大家这里先知道这两个函数的用法就好了，第三部曲中会深入地讲解。 （3）、绘图在绘图部分，我们需要完成两个功能：当用户没点击时将TextView设置为原来的位置，当用户点击时一方面TextView要跟着手指移动，另一方面要画出初始圆形12345678910111213141516171819@Overrideprotected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint);//将textview的中心放在当前手指位置 //先看用户没有点击时，把TextView设置在初始的位置点 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; 画出初始的圆形，手指处的圆形，和两个圆之间的贝赛尔曲线连接矩形；最后把TextView盖在手指处的圆形上即可。代码难度不大就不再细讲了。 (4)、拉伸时把圆半径缩小正常情况下，随着拉伸长度的增大，两个圆的半径是应该逐步就小的；这样才更符合力学原理是吧，效果图如下： 这个功能非常简单，只需要在拉伸时，跟根据用户的拉伸长度，动态的设置当前所画圆的半径即可：1234567891011121314151617181920212223private float DEFAULT_RADIUS = 20;private float mRadius = DEFAULT_RADIUS;private void calculatePath() &#123; float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); float distance = (float) Math.sqrt(Math.pow(y-startY, 2) + Math.pow(x-startX, 2)); mRadius = DEFAULT_RADIUS - distance/15; if(mRadius&lt;9)&#123; mRadius = 9; &#125; // 根据角度算出四边形的四个点 …………&#125; 这里代码很简单，就是根据勾股定理（a^2+b^2=c^2）求出两个圆心之间当前距离，然后按照一定的规则计算出当前的圆半径，我这里定的规则就是DEFAULT_RADIUS-distance/15；但不要一直小到0，因为我们中间的连接线是两个相同半径的圆的切线来计算出来的，所以当圆心半径变小时，两个圆之间的连接矩形也在变小，所以小到一定程度后，就不能再小了，我这里这个临界值定为9. (5)、答疑：super.dispatchDraw(canvas)的位置问题这里大家可能会有个疑问，为什么super.dispatchDraw(canvas)的位置有时候会直接写在dispatchDraw的下面呢？比如这样： 1234void dispatchDraw(Canvas canvas)&#123; super.dispatchDraw(canvas); …………//其它绘图操作&#125; 有时候又这么写：先做绘图操作再写super.dispatchDraw(canvas) 1234void dispatchDraw(Canvas canvas)&#123; …………//其它绘图操作 super.dispatchDraw(canvas);&#125; 这两个到底有什么差别呢？至于到底有什么差别，我们得先来看一下super.dispatchDraw(canvas);的作用是什么；super.dispatchDraw(canvas);的作用是绘出该控件的所有子控件，所以这样结论就很明显了，如果是像第一个那样先做super.dispatchDraw(canvas);再做其它绘图操作的结果是，先把子控件绘制出来，然后再画自己，这样可能会造成自己把子控件给覆盖上；相反，先做其它绘图操作然后再调用super.dispatchDraw(canvas)的结果是：先把自己给画出来，然后再画子控件，子控件会把自己的绘图结果给覆盖上；所以，我们回过头来看看我们在上面的例子中的代码：123456789101112131415161718protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint);//将textview的中心放在当前手指位置 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; 在这段代码中，我们是先绘制自己，然后再绘制它的子控件（TextView）,这样的结果就是TextView会把当前的绘图内容覆盖上，如果我把绘图画笔改成绿色，就会很明显，我们来看下效果： 然后我们再反过来看一下，如果我们先做super.dispatchDraw(canvas);然后再做自己的绘图操作，看下效果是怎么样的：12345678910111213141516protected void dispatchDraw(Canvas canvas) &#123; super.dispatchDraw(canvas); canvas.saveLayer(new RectF(0, 0, getWidth(), getHeight()), mPaint, Canvas.ALL_SAVE_FLAG); if (mTouch) &#123; calculatePath(); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); canvas.drawPath(mPath, mPaint);//将textview的中心放在当前手指位置 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore();&#125; 很明显，后来的绘图操作把子控件给盖住了，这就是 super.dispatchDraw(canvas)在不同位置的区别！ 2、爆炸效果这里我们就差最后一个效果了：当用户手指拉到一定长度松手后，将出来爆炸效果，效果图如下： （1）、定义逐帧动画首先，我们定义一个爆炸效果的动画（这些图片资源都是从手机QQ的apk里解压出来的，嘿嘿）图片资源如下：先添加个逐帧动画，对应的代码如下：1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true"&gt; &lt;item android:drawable="@drawable/idp" android:duration="300"/&gt; &lt;item android:drawable="@drawable/idq" android:duration="300"/&gt; &lt;item android:drawable="@drawable/idr" android:duration="300"/&gt; &lt;item android:drawable="@drawable/ids" android:duration="300"/&gt; &lt;item android:drawable="@drawable/idt" android:duration="300"/&gt; &lt;item android:drawable="@android:color/transparent" android:duration="300"/&gt;&lt;/animation-list&gt; （2）、添加ImageView我们需要添加一个ImageView控件来单独来播放这个逐帧动画：1234567891011121314151617181920212223242526272829private ImageView exploredImageView;private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); mTipTextView = new TextView(getContext()); mTipTextView.setLayoutParams(params); mTipTextView.setPadding(10, 10, 10, 10); mTipTextView.setBackgroundResource(R.drawable.tv_bg); mTipTextView.setTextColor(Color.WHITE); mTipTextView.setText("99+"); exploredImageView = new ImageView(getContext()); exploredImageView.setLayoutParams(params); exploredImageView.setImageResource(R.drawable.tip_anim); exploredImageView.setVisibility(View.INVISIBLE); addView(mTipTextView); addView(exploredImageView);&#125; （3）、定值爆炸在绘图的时候，我们就要开启爆炸效果了，上面我们在半径小于9的时候，一直给它赋值9，现在我们当它小于9时，让它爆炸：1234567891011121314151617181920212223242526private void calculatePath() &#123; float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); float distance = (float) Math.sqrt(Math.pow(y-startY, 2) + Math.pow(x-startX, 2)); mRadius = -distance/15+DEFAULT_RADIUS; if(mRadius &lt; 9)&#123; isAnimStart = true; exploredImageView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); exploredImageView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); exploredImageView.setVisibility(View.VISIBLE); ((AnimationDrawable) exploredImageView.getDrawable()).start(); mTipTextView.setVisibility(View.GONE); &#125; //根据角度算出四边形的四个点 …………&#125; 当半径小于9时，开始爆炸效果，然后声明一个变量isAnimStart来标识当前爆炸效果开始了；因为当爆炸效果开始以后，后面的绘图操作就不能再画圆和贝赛尔曲线了，应该清空当前画布，只显示ImageVIew的动画效果然后利用setX和setY函数将当前ImageVIew的位置移动到手指的位置，最后是显示ImageView并开始动画；最后是绘图操作：123456789101112131415161718192021protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); if (!mTouch || isAnimStart) &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; calculatePath(); canvas.drawPath(mPath, mPaint); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); //将textview的中心放在当前手指位置 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore(); super.dispatchDraw(canvas);&#125; 这里的绘图操作加上了isAnimStart变量的判断，当动画开始或者手指没在按的时候只显示TextView，之外的其它操作肯定是用户在点按TextView，此时需要画出拉伸效果。最后，把整体控件的源码贴给大家，可以自己对照下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159public class RedPointControlVIew extends FrameLayout &#123; private PointF mStartPoint, mCurPoint; private float DEFAULT_RADIUS = 20; private float mRadius = DEFAULT_RADIUS; private Paint mPaint; private Path mPath; private boolean mTouch = false; private boolean isAnimStart = false; private TextView mTipTextView; private ImageView exploredImageView; public RedPointControlVIew(Context context) &#123; super(context); initView(); &#125; public RedPointControlVIew(Context context, AttributeSet attrs) &#123; super(context, attrs); initView(); &#125; public RedPointControlVIew(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); initView(); &#125; private void initView() &#123; mStartPoint = new PointF(100, 100); mCurPoint = new PointF(); mPath = new Path(); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setStyle(Paint.Style.FILL); LayoutParams params = new LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); mTipTextView = new TextView(getContext()); mTipTextView.setLayoutParams(params); mTipTextView.setPadding(10, 10, 10, 10); mTipTextView.setBackgroundResource(R.drawable.tv_bg); mTipTextView.setTextColor(Color.WHITE); mTipTextView.setText("99+"); exploredImageView = new ImageView(getContext()); exploredImageView.setLayoutParams(params); exploredImageView.setImageResource(R.drawable.tip_anim); exploredImageView.setVisibility(View.INVISIBLE); addView(mTipTextView); addView(exploredImageView); &#125; private void calculatePath() &#123; float x = mCurPoint.x; float y = mCurPoint.y; float startX = mStartPoint.x; float startY = mStartPoint.y; float dx = x - startX; float dy = y - startY; double a = Math.atan(dy / dx); float offsetX = (float) (mRadius * Math.sin(a)); float offsetY = (float) (mRadius * Math.cos(a)); float distance = (float) Math.sqrt(Math.pow(y-startY, 2) + Math.pow(x-startX, 2)); mRadius = -distance/15+DEFAULT_RADIUS; if(mRadius &lt; 9)&#123; isAnimStart = true; exploredImageView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); exploredImageView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); exploredImageView.setVisibility(View.VISIBLE); ((AnimationDrawable) exploredImageView.getDrawable()).start(); mTipTextView.setVisibility(View.GONE); &#125; // 根据角度算出四边形的四个点 float x1 = startX + offsetX; float y1 = startY - offsetY; float x2 = x + offsetX; float y2 = y - offsetY; float x3 = x - offsetX; float y3 = y + offsetY; float x4 = startX - offsetX; float y4 = startY + offsetY; float anchorX = (startX + x) / 2; float anchorY = (startY + y) / 2; mPath.reset(); mPath.moveTo(x1, y1); mPath.quadTo(anchorX, anchorY, x2, y2); mPath.lineTo(x3, y3); mPath.quadTo(anchorX, anchorY, x4, y4); mPath.lineTo(x1, y1); &#125; /** * onDraw:为什么要行绘制自己的,然后再调用super.onDraw * @param canvas */ @Override protected void dispatchDraw(Canvas canvas) &#123; canvas.saveLayer(0,0,getWidth(),getHeight(),mPaint,Canvas.ALL_SAVE_FLAG); if (!mTouch || isAnimStart) &#123; mTipTextView.setX(mStartPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mStartPoint.y - mTipTextView.getHeight() / 2); &#125;else &#123; calculatePath(); canvas.drawPath(mPath, mPaint); canvas.drawCircle(mStartPoint.x, mStartPoint.y, mRadius, mPaint); canvas.drawCircle(mCurPoint.x, mCurPoint.y, mRadius, mPaint); //将textview的中心放在当前手指位置 mTipTextView.setX(mCurPoint.x - mTipTextView.getWidth() / 2); mTipTextView.setY(mCurPoint.y - mTipTextView.getHeight() / 2); &#125; canvas.restore(); super.dispatchDraw(canvas); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; // 判断触摸点是否在tipImageView中 Rect rect = new Rect(); int[] location = new int[2]; mTipTextView.getLocationOnScreen(location); rect.left = location[0]; rect.top = location[1]; rect.right = mTipTextView.getWidth() + location[0]; rect.bottom = mTipTextView.getHeight() + location[1]; if (rect.contains((int) event.getRawX(), (int) event.getRawY())) &#123; mTouch = true; &#125; &#125; break; case MotionEvent.ACTION_UP: &#123; //抬起手指时还原位置 mTouch = false; &#125; break; &#125; postInvalidate(); mCurPoint.set(event.getX(), event.getY()); return true; &#125;&#125; 好了，这篇文章就到这了，通过这篇文章，简单复习了下前面学到的动画和绘图的知识，后面我们会这个控件进行扩充，逐步把它封装成共用的控件。 二、给控件添加阴影效果与发光效果这节我们将学到如下内容： 传统地给按钮添加阴影的方法 如何给已有控件添加阴影 如何给图片添加阴影 一、layerlist给按钮添加阴影效果给控件添加阴影有很多方法，但平常我们给按钮添加阴影最常用的就是使用layerlist多层绘图来添加阴影效果，我们先来看一下给按钮添加的阴影效果图： 从效果图中可以明显看出，按钮的外围多了一圈灰色的阴影效果。在开始做阴影效果之前，我们先讲解一下有关layerlist的知识。在xml中，我们有常用的几个标签：shape、selector、layerlist; shape标签：以前我们讲过,就是利用代码绘制出背景效果，可以定义填充色、描边、圆角、渐变等。不了解的同学可以参考下：《详解shape标签》 selector标签：用于定义在用户不同的动作状态下，使用不同的背景值。有关selector的知识，博主没有讲过，也不打算再讲了，难度不大，自己搜几个帖子就能学会了。 layerlist标签：这个标签的主要作用就是将多个图层按照顺序叠起来，做为一个背景图来显示。 1、layerlist示例：layerlist标签就是模拟Photoshop中图层的概念，把每一张图层按照顺序叠加起来，做为背景图来显示；我们先来看一下简单的例子，我们要显示一下两只蜗牛的图片：它由三张图片组成：一张纯蓝色的背景：(blog1_1.png)一只黄蜗牛：(blog1_2.png)一只土色蜗牛：(blog1_3.png)我们先定义一个layerlist的文件（shade.xml）123456&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/blog1_1"/&gt; &lt;item android:drawable="@drawable/blog1_2"/&gt; &lt;item android:drawable="@drawable/blog1_3"/&gt; &lt;/layer-list&gt; 这里分别将上面的三张图片做为item添加给layer-list；效果图就是一开始演示的那样。layer-list使用起来很简单，只需要把每一层设置为其中的item即可。有一点需要注意，layer-list标签的Item中不仅可以设置drawable，也可以设置shape、selector，我们下面一一做下尝试。 2、layer-list与shape标签编写控件阴影drawable代码上面我们使用使用的是layer-list中item的drawable属性来直接引入图片，其实除了drawable属性，item还有另外几个属性： android:top 顶部的偏移量 android:bottom 底部的偏移量 android:left 左边的偏移量 android:right 右边的偏移量这四个偏移量和控件的margin设置差不多，都是外间距的效果。如果不设置偏移量，前面的图层就完全挡住了后面的图层，从而也看不到后面的图层效果了。言归正转，先来看看如何在layer-list中使用shape标签：12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; 上面的代码实现的效果是这样的：大家看到类似阴影的效果了吧，不错，这段代码就是实现按钮阴影的代码，我们来仔细看一下首先，它使用layer-list将两层shape叠加在一起，底部的shape代码为：123456&lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; 底部是一个灰色的矩形，它的四个角被圆角化，并且填充为灰色。上层绘制的shape对应的代码为：1234567&lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; 它同样绘制的是一个四个角都被圆角化的矩形，但填充颜色是纯白色。为了露出底层的灰色阴影，我们需要给上层的shape加上边距，这也就是item的 android:left=”2dp” android:top=”2dp” android:bottom=”2dp” android:right=”2dp”这四个属性的作用，相当于margin的作用。 使用阴影drawable在写好layer-list以后，我们需要在按钮控件中使用它：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="10dp" android:layout_margin="10dp" android:background="@drawable/layer_shape_list" android:text="带阴影的按钮" android:textColor="#ff0000"/&gt;``` 我们来看下效果：![201702182509320160704092043807.gif](http://ohtrrgyyd.bkt.clouddn.com/201702182509320160704092043807.gif) 从效果图中可以看到，我们虽然实现了带阴影的按钮效果，但是在点击时却没有任何状态变化，这对于按钮是完全不能接受的，所以我们需要给按钮添加上状态变化，这就需要用到selector标签了##### 3、layer-list与selector标签**改造方法一：使用layer-list做根结点** 下面我们对上面shape的代码进行改造，当用户手指按下的时候，将前景色改为黄色，代码为：``` xml&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;selector&gt; &lt;item android:state_pressed="true"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/selector&gt; &lt;/item&gt; &lt;/layer-list&gt; 我们先来看一下效果，然后再来看代码这里明显实现了当用户点击时前景变化的功能。下面我们再来讲解下代码首先，这里同样是绘制两层layer，第一层，依然是阴影层，代码没动：123456&lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; 在第一层绘制完成以后，当绘制第二层时就出现问题了：1234567891011121314151617&lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;selector&gt; &lt;item android:state_pressed="true"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/selector&gt; &lt;/item&gt; 第二层中，会对当前用户状态做判断，如果用户当前是按下状态，则绘制：123456&lt;item android:state_pressed="true"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; 如果是其它状态，则绘制默认图像：123456&lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; 所以对于layer-list标签，从这里也可以看出来：它的绘制是逐层绘制的，层与层之间是没有任何影响的，每一层可以单独设置selector标签来响应不同的用户操作状态。改造方法二：使用selector做根结点上面我们使用layer-list来做根结点来绘制出按钮的不同状态响应的效果，对selector、layer-list使用熟悉的同学，应该还可以想到另一种实现方式，使用selector做为根结点来实现响应不同用户操作。我们先直接上代码吧：123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;item&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; &lt;/selector&gt; 同样我们先来看一下使用代码与效果，然后再来讲解实现原理：使用方法，同样是做为background引入： 12345678&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="10dp" android:layout_margin="10dp" android:background="@drawable/selector_layer_list" android:text="Selector为根的按钮" android:textColor="#ff0000"/&gt; 效果图如下：很明显，实现了与上面layer-list标签为根同样的效果，我们现在来看一下代码原理：代码看起来很长，很唬人，其实原理很简单，它就是根据当前不同的状态，绘制不同的图形，当用户是按压状态时，通过layer-list绘制出一下最上层是黄色，底层是灰色的按钮背景图像：1234567891011121314151617&lt;item android:state_pressed="true"&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFF00"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; 然后在其它状态时，绘制一个前景色是白色，背景色是灰色的按钮背景图：1234567891011121314151617&lt;item&gt; &lt;layer-list&gt; &lt;item&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#E4E4E4"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:left="2dp" android:top="2dp" android:bottom="2dp" android:right="2dp"&gt; &lt;shape&gt; &lt;corners android:radius="25dp"/&gt; &lt;solid android:color="#FFFFFF"/&gt; &lt;/shape&gt; &lt;/item&gt; &lt;/layer-list&gt; &lt;/item&gt; 4、存在问题由于使用layer-list标签实现的阴影只能做为background引入，所以如果对你是文字时，它的阴影效果就变成了这样：1234567&lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="文字的阴影效果" android:layout_margin="10dp" android:padding="10dp" android:background="@drawable/layer_shape_list"/&gt; 对应效果图为：看起来跟按钮一个样 - _ -!!! 很囧有没有，文字的阴影应该是这样的才对：所以我们下面就要开始讲解如何实现文字的阴影效果啦，嘿嘿 二、Paint.setShadowLayer实现阴影效果上面我们讲了利用layer-list只能实现按钮的阴影效果，对于文字和图片都无法实现阴影效果，除了layer-list，我们只能用自定义控件来实现阴影效果了，Paint中有一个专门用来实现阴影效果的函数setShadowLayer，我们先来看看这个函数实现的阴影效果图：从效果图中可以看出setShadowLayer函数能够实现： 定制阴影模糊程度 定制阴影偏移距离 清除阴影和显示阴影 1、setShadowLayer构造函数看起来setShadowLayer好像能够完成阴影定制的方方面面，我们先来看看它的构造函数： public void setShadowLayer(float radius, float dx, float dy, int color) float radius：意思是模糊半径，radius越大越模糊，越小越清晰，但是如果radius设置为0，则阴影消失不见；有关清除阴影的问题，下面我们会专门讲。 float dx：阴影的横向偏移距离，正值向右偏移，负值向左偏移 float dy：阴影的纵向偏移距离，正值向下偏移，负值向上偏移 int color：绘制阴影的画笔颜色，即阴影的颜色（对图片阴影无效） 我们这里需要着重讲两个点：一个是模糊半径，另一个是绘制阴影的画笔颜色为什么对图片无效： 模糊半径的具体意义：setShadowLayer使用的是高斯模糊算法，高斯模糊的具体算法是：对于正在处理的每一个像素，取周围若干个像素的RGB值并且平均，然后这个平均值就是模糊处理过的像素，如果对图片中的所有像素都这么处理的话，处理完成的图片就会变得模糊。取周围像素的半径就是模糊半径.很容易知道,模糊半径越大,所得平均像素与原始像素相差就越大,也就越模糊. 绘制阴影的画笔颜色为什么对图片无效从上面的效果图中可以看出，使用setShadowLayer所产生的阴影，对于文字和绘制的图形的阴影都是使用自定义的阴影画笔颜色来画的，而图片的阴影则是直接产生一张相同的图片，仅对阴影图片的边缘进行模糊。大家可能会疑问，会什么对图片的处理是生成一张相同的背景图片呢？这是因为为了给图片添加阴影，如果统一使用某一种颜色来做阴影可能会与图片的颜色相差很大，而且不协调，比如某张图片的色彩非常丰富，而阴影如果使用灰色来做，可能就会显得很突兀，所以为了解决这个问题，针对图片的阴影就不再是统一颜色了，而是复制出这张图片，把复制出的图片的边缘进行模糊，做为阴影；但这样又会引起一个问题，就是如果我们想把图片的阴影做成灰色怎么办？使用setShadowLayer自动生成阴影是没办法了，在下篇我们会具体来讲，如何给图片添加指定颜色的阴影。 注意：这里有一点需要非常注意的是setShadowLayer只有文字绘制阴影支持硬件加速，其它都不支持硬件加速，所以为了方便起见，我们需要在自定义控件中禁用硬件加速。 2、示例一：初步使用setShadowLayer 这里实现了对文本，图形，Image的阴影效果；具体的代码如下：1234567891011121314151617181920212223242526272829303132333435363738public class ShadowLayerView extends View &#123; private Paint mPaint = new Paint(); private Bitmap mDogBmp; public ShadowLayerView(Context context) &#123; super(context); init(); &#125; public ShadowLayerView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ShadowLayerView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; //首先是初始化，在初始化时设置画笔的颜色 private void init()&#123; setLayerType( LAYER_TYPE_SOFTWARE , null); //禁用硬件加速 //设置paint的属性，由于我们需要画图片，所以先把要画的图片加载进来。 mPaint.setColor(Color.GREEN); //设置画笔的颜色是绿色，从效果图中也可以看出来画出来的字体和圆形都是绿色的 mPaint.setTextSize(25); mPaint.setShadowLayer(1, 10, 10, Color.GRAY); //指的是阴影的颜色，从效果图中也明显可以看出，字体和阴影的颜色都是灰色的。 mDogBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawText("启舰大SB",100,100,mPaint); canvas.drawCircle(200,200,50,mPaint); canvas.drawBitmap(mDogBmp,null,new Rect(200,300,200+mDogBmp.getWidth(),300+mDogBmp.getHeight()),mPaint); &#125; &#125; 3、示例二：setShadowLayer各参数意义下面我们就来实现一下这部分开篇时的效果，动态添加setShadowLayer中的各个参数，就可以明显看出来它们的作用：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ShadowLayerView extends View &#123; private Paint mPaint = new Paint(); private Bitmap mDogBmp; private int mRadius = 1,mDx = 10,mDy = 10; public ShadowLayerView(Context context) &#123; super(context); init(); &#125; public ShadowLayerView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ShadowLayerView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType( LAYER_TYPE_SOFTWARE , null); mPaint.setColor(Color.GREEN); mPaint.setTextSize(25); mDogBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog); &#125; public void changeRadius() &#123; mRadius++; postInvalidate(); &#125; public void changeDx() &#123; mDx+=5; postInvalidate(); &#125; public void changeDy() &#123; mDy+=5; postInvalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY); canvas.drawText("启舰大SB",100,100,mPaint); canvas.drawCircle(200,200,50,mPaint); canvas.drawBitmap(mDogBmp,null,new Rect(200,300,200+mDogBmp.getWidth(),300+mDogBmp.getHeight()),mPaint); &#125; &#125; 这段代码难度并不大，只是将 mPaint.setShadowLayer中的各参数写成了变量，并向外暴露了几个接口changeRadius()、changeDx()、changeDy()；当外部调用这些接口时，增加对应的变量，并且重绘控件；由于每次重绘控件都肯定会调用onDraw方法，所以，我们将mPaint.setShadowLayer的设置放到onDraw方法里来，以确保每次重绘时mPaint.setShadowLayer的设置都会被更新。 使用时123456789101112131415161718192021222324252627public class MyActivity extends Activity implements View.OnClickListener&#123; private ShadowLayerView mShadowLayerView; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mShadowLayerView = (ShadowLayerView)findViewById(R.id.shadowlayerview); findViewById(R.id.radius_btn).setOnClickListener(this); findViewById(R.id.dx_btn).setOnClickListener(this); findViewById(R.id.dy_btn).setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.radius_btn: mShadowLayerView.changeRadius(); break; case R.id.dx_btn: mShadowLayerView.changeDx();; break; case R.id.dy_btn: mShadowLayerView.changeDy(); break; &#125; &#125; &#125; 从效果图中可以明显看到各个参数的区别，但正是通过效果图，我们可以明显得看出两个结论： 图片的阴影是不受阴影画笔颜色影响的，它是一张图片的副本； 无论是图片还是图形，模糊时，仅模糊边界部分，随着模糊半径的增大，向内、向外延伸；其实很好理解这个问题：由于模糊半径的增大，高斯模糊向周边取值的范围在增大，所以向内、向外延伸的距离就会更大 4、Paint.clearShadowLayer()清除阴影上面我们讲解了使用setShadowLayer添加阴影的问题，下面我们再来看看如何清除阴影的。清除阴影其实有两个方法，可以将setShadowLayer的radius的值设为0，也可以使用专门的清除阴影的函数： //Paint系函数：清除ShadowLayer阴影 public void clearShadowLayer() 将setShadowLayer的radius的值设为0来清除阴影的用法，我这里就不再演示了，大家可以自己试试，我们这里尝试下使用clearShadowLayer() 来清除阴影的用法。在上面函数的基础上，我们另外添加一个变量来控制当前是否显示阴影： 12345678910111213141516171819202122232425262728293031public class ShadowLayerView extends View &#123; ………… private boolean mSetShadow = true; ………… public void clearShadow()&#123; mSetShadow = false; postInvalidate(); &#125; public void showShadow()&#123; mSetShadow = true; postInvalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mSetShadow) &#123; mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY); &#125;else &#123; mPaint.clearShadowLayer(); &#125; canvas.drawText("启舰大SB",100,100,mPaint); canvas.drawCircle(200,200,50,mPaint); canvas.drawBitmap(mDogBmp,null,new Rect(200,300,200+mDogBmp.getWidth(),300+mDogBmp.getHeight()),mPaint); &#125; &#125; 修改的代码很简单，增加一个变量mSetShadow来控制当前是否显示阴影，如果需要显示阴影就调用mPaint.setShadowLayer(mRadius, mDx, mDy, Color.GRAY);设置阴影，如果不需要显示阴影就调用mPaint.clearShadowLayer();来清除阴影；对于使用btn调用clearShadow()、showShadow()这两个接口的用法，就不再帖代码了，没啥难度，源码里也有；效果图如下： 在目前的所有例子中，我们的定义控件在xml中使用时，layout_widht、layout_height都统一设置成match_parent或者fill_parent来强制全屏；是时间教大家如何使用wrap_content属性，如何让控件自已计算高度了，下篇我们就来看看这个问题。 三、TextView及其派生类使用ShadowLayer添加阴影效果上面我们通过自定义控件来实现了自定义阴影效果，那么问题来了，如果我需要给已有的控件添加阴影效果，实现下面这样的效果： 1、XML实现从上面可以看到，TextView,Button,EditView中的文字都具有阴影效果。那是怎么实现的呢？难道我们需要在原生控件的甚而上派生一个类在onDraw里使用setShadowLayer来绘制阴影吗？答案当然不是，setShadowLayer是API 1 就已经引入的方法，同样，对于TextView和从TextView派生的类都自然具体XML属性来设置阴影。这几个设置阴影的XML属性如下：123456&lt;TextView ………… android:shadowRadius="3" android:shadowDx="5" android:shadowDy="5" android:shadowColor="@android:color/darker_gray"/&gt; 这几个属性的意义非常容易理解，直接对应setShadowLayer的几个参数setShadowLayer(float radius, float dx, float dy, int color)，但这几个属性只有TextVIew及其派生类才会有，其它类是没有的，TextVIew的派生类如下：所以一般我们使用的Button和EditText是可以使用Xml来实现阴影的。 2、代码实现既然能通过XML实现，当然也能会代码版了，TextView及其派生类，都有一个Paint.setShadowLayer的同名方法： //TextView中的设置阴影函数 public void setShadowLayer(float radius, float dx, float dy, int color) 通过该方法就很容易来实现TextView及其派生类的阴影了。使用示例如下： TextView tv = (TextView)findViewById(R.id.tv); tv.setShadowLayer(2,5,5, Color.GREEN); 四、SetMaskFilter之BlurMaskFilter实现发光效果前面我们讲了如何给控件添加阴影效果，其它跟阴影效果类似的还有一个发光效果： 上面就是我们这节要讲的发光效果，在这个效果图中，总共涉及了三个内容的发光效果：文字、图形和Bitmap图像。从最后一个小狗的Bitmap所形成的发光效果中可以看到，与setShadowLayer一样，发光效果也只会影响边缘部分图像，内部图像是不受影响的。从第三个图形（红绿各一半的Bitmap）中可以看到：发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。所以初步我们对发光效果有如下结论： 与setShadowLayer一样，发光效果也是使用的高斯模糊，并且只会影响边缘部分图像，内部图像是不受影响的 发光效果是无法指定发光颜色的，采用边缘部分的颜色取样来进行模糊发光。所以边缘是什么颜色，发出的光也就是什么颜色的。 1、SetMaskFilter之BlurMaskFilter概述Paint函数的的setMaskFilter声明如下： public MaskFilter setMaskFilter(MaskFilter maskfilter) 前面我们讲到setColorFilter来设置颜色滤镜,与setColorFilter一样，setMaskFilter中的MaskFilter也是没有具体实现的，也是通过派生子类来实现具体的不同功能的，MaskFilter有两个派生类BlurMaskFilter和EmbossMaskFilter，其中BlurMaskFilter就是我们这段要讲的实现发光效果的子类，而EmbossMaskFilter是用来实现浮雕效果的，用处很少，这里就不再讲了。另一点需要注意的是，setMaskFilter是不支持硬件加速的，必须关闭硬件加速才可以。BlurMaskFilter的构造函数如下： public BlurMaskFilter(float radius, Blur style) 其中： float radius：用来定义模糊半径，同样是高斯模糊算法。 Blur style：发光样式，有内发光、外发光、和内外发光，分别对应：Blur.INNER(内发光)、Blur.SOLID(外发光)、Blur.NORMAL(内外发光)、Blur.OUTER(仅发光部分可见)，这几个模式，后面我们会逐个来展示用法。下面我们简单举一个例子来看看用法先，这个例子的代码如下： 12345678910111213141516171819202122232425262728293031public class BlurMaskFilterView extends View &#123; private Paint mPaint; public BlurMaskFilterView(Context context) &#123; super(context); init(); &#125; public BlurMaskFilterView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public BlurMaskFilterView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mPaint.setColor(Color.RED); mPaint.setMaskFilter(new BlurMaskFilter(50, Blur.INNER)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(200,200,100,mPaint); &#125; &#125; 这里使用起来非常容易，只需要在paint的时候调用setMaskFilter将BlurMaskFilter的实例设置进行就可以了。这里使用的内发光模式。我们来看下效果图： 很明显的内发光效果。下面我们分别来看看各种模式下的发光效果。 2、BlurStyle发光效果(1)、Blur.INNER——内发光 (2)、Blur.SOLID——外发光 (3)、Blur.NORMAL——内外发光 (4)、Blur.OUTER——仅显示发光效果 Blur.OUTER比较特殊，这种模式下仅会显示发光效果，会把原图像中除了发光部分，全部变为透明！大家是否可以看出来发光效果与setShadowLayer所生成的阴影之间有什么联系？setShadowLayer所生成的阴影，其实就是将新建的阴影图形副本进行发光效果并且位移一定的距离而已。下篇我们就会利用这个原理来生成图片指定颜色的阴影效果。到这里，这篇文章就结束了，下篇将继续给大家讲解如何给图片添加指定颜色的阴影效果，并且初步教大家如何将其封装成一个控件。 三、为Bitmap添加阴影并封装控件上篇给大家讲解了如何控件添加阴影效果，但是在为Bitmap图片添加阴影时，却没办法添加具有指定颜色的阴影，这篇我们就来使用自定义的控件及自定义属性来初步封装下控件。前方高能预警——本篇内容涉及内容较多，难度较大，需要多加思考。 一、使用BlurMaskFilter为图片构造定色阴影效果上面我们讲了通过setShadowLayer为图片添加阴影效果，但是图片的的阴影是用原图形的副本加上边缘发光效果组成的。我们怎么能给图片添加一个灰色的阴影呢？我们来分析一下setShadowLayer的阴影形成过程（假定阴影画笔是灰色），对于文字和图形，它首先产生一个跟原型一样的灰色副本。然后对这个灰色副本应用BlurMaskFilter，使其内外发光；这样就形成了所谓的阴影！当然最后再偏移一段距离。所以，我们要给图片添加灰色阴影效果，所以我们能不能仿一下这个过程：先绘制一个跟图片一样大小的灰色图形，然后给这个灰色图形应用BlurMaskFilter使其内外发光，然后偏移原图形绘制出来，不就可以了么所以，这里涉及到三个点： 绘制出一个一样大小的灰色图形 对灰色图形应用BlurMaskFilter使其内外发光 偏移原图形一段距离绘制出来下面我们就通过例子来一步步看是怎么实现出来的吧 1、绘制出一个一样大小的灰色图像首先，我们来看怎么能绘出一个指定Bitmap所对应的灰色图像。我们知道canvas.drawBitmap(Bitmap bitmap, Rect src, Rect dst, Paint paint)中的paint的画笔颜色对画出来的bitmap是没有任何影响的，因为原来Bitmap长什么样，无论你画笔是什么颜色，画出来的图片还是跟原图片长的一样。所以如果我们需要画一张对应的灰色图像，我们需要新建一个一样大小的空白图，但是新图片的透明度要与原图片保持一致。所以如何从原图片中抽出Alpha值成为了关键。即我们只需要创建一个与原图片一样大小且Alpha相同的图片即可。其实Bitmap中已经存在抽取出只具有Alpha值图片的函数： public Bitmap extractAlpha(); extraAlpha()函数的功能是：新建一张空白图片，图片具有与原图片一样的Alpha值，这个新建的Bitmap做为结果返回。这个空白图片中每个像素都具有与原图片一样的Alpha值，而且具体的颜色时，只有在使用canvas.drawBitmap绘制时，由传入的paint的颜色指定。总结 extractAlpha()新建一张仅具有Alpha值的空白图像 这张图像的颜色，是由canvas.drawBitmap时的画笔指定的。 （1）、extractAlpha()使用示例下面，我们就用个例子先来看下extractAlpha()函数的用法我们拿一张图片来做试验，下面这张PNG图片中，一只小猫和一只小狗，其余地方都是透明色。下面我们分别利用extractAlpha()画出它对应的红色和绿色的阴影图对应的代码为：123456789101112131415161718192021222324252627282930313233343536373839public class ExtractAlphaView extends View &#123; private Paint mPaint; private Bitmap mBitmap,mAlphaBmp; public ExtractAlphaView(Context context) &#123; super(context); init(); &#125; public ExtractAlphaView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ExtractAlphaView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; //禁用硬件加速 setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.blog12); mAlphaBmp = mBitmap.extractAlpha(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //分别将画笔的颜色设置为红色和绿色，然后两次把mAlphaBmp画出来。 int width = 200; int height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth(); mPaint.setColor(Color.RED); canvas.drawBitmap(mAlphaBmp,null,new Rect(0,0,width,height),mPaint); mPaint.setColor(Color.GREEN); canvas.drawBitmap(mAlphaBmp,null,new Rect(0,height,width,2*height),mPaint); &#125;&#125; 首先是禁用硬件加速，这基本上是我们做自定义控件的标配！为了防止功能不好用，记得每次都加上这个函数！然后是利用extratAlpha()来生成仅具有透明度的空白图像。 2、对灰色图形应用BlurMaskFilter使其内外发光在第一步完成了之后，我们进行第二步，将阴影添加内外发光效果。就形成了阴影的模样。代码很简单，只需要使用Paint.setMaskFilter函数添加发光效果即可，代码如下：123456789101112protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 200; int height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth(); mPaint.setColor(Color.RED); mPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mAlphaBmp,null,new Rect(0,0,width,height),mPaint); mPaint.setColor(Color.GREEN); canvas.drawBitmap(mAlphaBmp,null,new Rect(0,height,width,2*height),mPaint);&#125; 明显可以看出这里只添加了一行代码：mPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL));就是添加内外发光效果，难度不大，不再细讲。 3、偏移原图形一段距离绘制出来这段比较简单了，只需要先把阴影画出来，然后再把原图像盖上去，但需要注意的是，阴影需要相对原图像偏移一段距离。完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ExtractAlphaView extends View &#123; private Paint mPaint; private Bitmap mBitmap,mAlphaBmp; public ExtractAlphaView(Context context) &#123; super(context); init(); &#125; public ExtractAlphaView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ExtractAlphaView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.blog12); mAlphaBmp = mBitmap.extractAlpha(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = 200; int height = width * mAlphaBmp.getHeight()/mAlphaBmp.getWidth(); //绘制阴影 mPaint.setColor(Color.RED); mPaint.setMaskFilter(new BlurMaskFilter(10, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mAlphaBmp,null,new Rect(10,10,width,height),mPaint); mPaint.setColor(Color.GREEN); canvas.drawBitmap(mAlphaBmp,null,new Rect(10,height+10,width,2*height),mPaint); //绘制原图像 mPaint.setMaskFilter(null); canvas.drawBitmap(mBitmap,null,new Rect(0,0,width,height),mPaint); canvas.drawBitmap(mBitmap,null,new Rect(0,height,width,2*height),mPaint); &#125;&#125; 关键部分在onDraw函数中，先画出来阴影，然后再画出来原图像，需要注意的是在画原图像时，需要利用mPaint.setMaskFilter(null);将发光效果去掉。只有阴影需要发光效果，原图像是不需要发光效果的。另一点注意的是，阴影要偏移一点位置，这里是偏移了10个像素。 二、封装控件上面我们初步实现了图片的阴影效果，但这只是本篇内容的一小部分，最最重要的，如何将它封装成一个控件，具有如下功能： 让用户定义图片内容 让用户定义偏移距离 让用户定义阴影颜色和阴影模糊程度 可以使用wrap_content属性自适应大小 1、自定义控件属性有关自定义控件属性，大家首先需要看下这篇文章《PullScrollView详解（一）——自定义控件属性》，在这篇文章中讲解了自定义控件属性的方法与提取方法。下面将会直接用到自定义属性的内容，下面涉及到的时候就自认为大家已经学会了自定义控件属性的方法了。在这里，我们需要自定义四个属性，分别对应： 自定义图片内容、自定义偏移距离、自定义阴影颜色、自定义阴影模糊程度 这四个需求，所以我们先利用declare-styleable标签来定义这些属性attr.xml12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="BitmapShadowView"&gt; &lt;attr name="src" format="reference" /&gt; &lt;attr name="shadowDx" format="integer" /&gt; &lt;attr name="shadowDy" format="integer" /&gt; &lt;attr name="shadowColor" format="color"/&gt; &lt;attr name="shadowRadius" format="float"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这里定义了五个xml属性，src来引用图片资源，仿照setShadowLayer另外定义shadowDx、shadowDy、shadowColor、shadowRadius来定义阴影的边距、颜色和模糊半径。然后在布局中使用：(main.xml)12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;com.harvic.BlogBitmapShadow.BitmapShadowView android:layout_width="200dp" android:layout_height="200dp" android:layout_gravity="center_horizontal" app:src="@drawable/blog12" app:shadowDx="10" app:shadowDy="10" app:shadowRadius="10.0" app:shadowColor="@android:color/holo_red_dark"/&gt;&lt;/LinearLayout&gt; 在布局中使用很简单，直接定义控件所使用的图片资源、阴影相关参数就可以了，难度不大就不再讲了，下面我们来看如何在代码中中提取用户传入的这些属性。BitmapShadowView中提取属性值并绘阴影先列出完整代码，然后再细讲：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class BitmapShadowView extends View &#123; private Paint mPaint; private Bitmap mBmp,mShadowBmp; private int mDx = 10,mDy = 10; private float mRadius = 0; private int mShadowColor; public BitmapShadowView(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(context,attrs); &#125; public BitmapShadowView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(context,attrs); &#125; private void init(Context context,AttributeSet attrs) throws Exception &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); /** * 提取属性定义 */ TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView); int BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-1); if (BitmapID == -1)&#123; throw new Exception("BitmapShadowView 需要定义Src属性,而且必须是图像"); &#125; mBmp = BitmapFactory.decodeResource(getResources(),BitmapID); mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,0); mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,0); mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,0); mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK); typedArray.recycle(); /** * 其它定义 */ mPaint = new Paint(); mShadowBmp = mBmp.extractAlpha(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth()-mDx; int height = width * mBmp.getHeight()/mBmp.getWidth(); //绘制阴影 mPaint.setColor(mShadowColor); mPaint.setMaskFilter(new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mShadowBmp,null,new Rect(mDx,mDy,width,height),mPaint); //绘制原图像 mPaint.setMaskFilter(null); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125;&#125; 在这段代码中分两部分，首先根据属性来初始化各变量，然后再利用这些变量画出bitmap与阴影。首先看初始化部分：1234567891011121314151617181920212223private void init(Context context,AttributeSet attrs) throws Exception &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); /** * 提取属性定义 */ TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView); int BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-1); if (BitmapID == -1)&#123; throw new Exception("BitmapShadowView 需要定义Src属性,而且必须是图像"); &#125; mBmp = BitmapFactory.decodeResource(getResources(),BitmapID); mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,0); mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,0); mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,0); mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK); typedArray.recycle(); /** * 其它定义 */ mPaint = new Paint(); mShadowBmp = mBmp.extractAlpha();&#125; 初始化的时候，首先是利用TypedArray来初始化各项参数，由于我们是做图片的阴影，所以图片资源必须赋值，所以我们在提取图片资源时，对其添加容错：1234int BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-1);if (BitmapID == -1)&#123; throw new Exception("BitmapShadowView 需要定义Src属性,而且必须是图像");&#125; 当提取失败时，抛出异常，终止程序，这样用户在写代码时就可以及时发现问题，而不必等上线以后才发现没有bitmap；有关其它属性值的提取，这里就不再细讲了。在提取完属性以后，就是定义画笔paint和根据源图像利用extractAlpha()来生成阴影图像；在初始化以后就是利用这些属性来进行绘图了：123456789101112131415protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth()-mDx; int height = width * mBmp.getHeight()/mBmp.getWidth(); //绘制阴影 mPaint.setColor(mShadowColor); mPaint.setMaskFilter(new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mShadowBmp,null,new Rect(mDx,mDy,width,height),mPaint); //绘制原图像 mPaint.setMaskFilter(null); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint);&#125; 首先，图片宽度与控件宽度操持一致（但需要把阴影的位置空出来），所以宽度为：int width = getWidth()-mDx根据图片的宽高比换算出图片的高度：int height = width * mBmp.getHeight()/mBmp.getWidth()我们依控件左上角（0，0）显示原图像，阴影在(mDx,mDy)处显示；到这里自定义属性的定义与提取就结束了，最终效果图为：从效果图中可以明显看出，明显给原图片添加了红色的阴影效果。目前，我们初步实现了可以让用户自定义控件属性的功能，但我们在使用这个控件时，必须强制设置指定的宽高或者fill_parent来强制平屏，这样明显是不可取的，我们需要它能够让用户使用wrap_conetent时，自己计算宽高。 2、wrap_content自适应宽高在自适应宽高时，需要了解onMeasure()、onLayout()与onDraw()的知识；在第三篇中我还会重新讲解一遍onMeasure()、onLayout()与onDraw()，这里涉及内容不多，看完上一篇然后再理解以下内容应该不会有问题在看完上面的文章，大家就应该知道，对于View控件的自适应宽高，只需要在上面的代码中重写onMeasure()方法就可以了:12345678910111213protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width = mBmp.getWidth(); int height = mBmp.getHeight(); setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height);&#125; 在onMeasure方法中，当用户指定属性是wrap_content时，就使用图片的宽高做为控件的宽高。此时整个自定义控件的完整代码为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class BitmapShadowView extends View &#123; private Paint mPaint; private Bitmap mBmp,mShadowBmp; private int mDx = 10,mDy = 10; private float mRadius = 0; private int mShadowColor; public BitmapShadowView(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(context,attrs); &#125; public BitmapShadowView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(context,attrs); &#125; private void init(Context context,AttributeSet attrs) throws Exception &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); /** * 提取属性定义 */ TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.BitmapShadowView); int BitmapID = typedArray.getResourceId(R.styleable.BitmapShadowView_src,-1); if (BitmapID == -1)&#123; throw new Exception("BitmapShadowView 需要定义Src属性,而且必须是图像"); &#125; mBmp = BitmapFactory.decodeResource(getResources(),BitmapID); mDx = typedArray.getInt(R.styleable.BitmapShadowView_shadowDx,0); mDy = typedArray.getInt(R.styleable.BitmapShadowView_shadowDy,0); mRadius = typedArray.getFloat(R.styleable.BitmapShadowView_shadowRadius,0); mShadowColor = typedArray.getColor(R.styleable.BitmapShadowView_shadowColor,Color.BLACK); typedArray.recycle(); /** * 其它定义 */ mPaint = new Paint(); mShadowBmp = mBmp.extractAlpha(); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width = mBmp.getWidth(); int height = mBmp.getHeight(); setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int width = getWidth()-mDx; int height = width * mBmp.getHeight()/mBmp.getWidth(); //绘制阴影 mPaint.setColor(mShadowColor); mPaint.setMaskFilter(new BlurMaskFilter(mRadius, BlurMaskFilter.Blur.NORMAL)); canvas.drawBitmap(mShadowBmp,null,new Rect(mDx,mDy,width,height),mPaint); //绘制原图像 mPaint.setMaskFilter(null); canvas.drawBitmap(mBmp,null,new Rect(0,0,width,height),mPaint); &#125;&#125; 所以当我们对这个自定义的控件使用如下布局（使用wrap_content）：123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;com.harvic.BlogBitmapShadow.BitmapShadowView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" app:src="@drawable/blog12" app:shadowDx="10" app:shadowDy="10" app:shadowRadius="10.0" app:shadowColor="@android:color/holo_red_dark"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="test BTN"/&gt;&lt;/LinearLayout&gt; 所以，这时候如果我们需要产生灰色阴影，只需要把xml中的app:shadowColor的值改一下即可：(为了方便看阴影，我把Activiy背景改成了白色)1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res/com.harvic.BlogBitmapShadow" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:background="@android:color/white"&gt; &lt;com.harvic.BlogBitmapShadow.BitmapShadowView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center_horizontal" app:src="@drawable/blog12" app:shadowDx="10" app:shadowDy="10" app:shadowRadius="10.0" app:shadowColor="@android:color/darker_gray"/&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="test BTN"/&gt;&lt;/LinearLayout&gt; 到这里，整个控件的封装就结束了，但细心的同学可以发现，BitmapShadowView的构造函数默认有三个，而我这里只写了两个具有AttributeSet attrs参数的，而下面这个构造函数却是没有实现的：123public BitmapShadowView(Context context)&#123; super(context);&#125; 因为当从XML中生成控件时，都会调用具有AttributeSet attrs参数的方法，而从代码中生成控件则会调用上面仅具有context函数的方法，所以如果需要从代码中生成需要添加上这个方法，并且需要在代码中提供接口供外部设置各种属性才好，我这里就略去了这部分内容了，大家可以自己来填充这个控件，使其更完整。 四、BitmapShader与望远镜效果上篇初步给大家展示了封装控件的方法，这篇我们继续Paint来看相关方法的用法，这篇我们将会讲一个很起来没啥用，但效果却很屌的方法setShader，这篇文章最后，我们将实现的效果是望远镜效果:（看起来有没有屌屌的）我们先来看看setShader函数的声明： //Paint类中的方法 public Shader setShader(Shader shader) Shader在三维软件中称之为着色器，就是用来给空白图形上色用的。在PhotoShop中有一个工具叫印章工具，我们能够指定印章的样式来填充图形。印章的样式可以是图像、颜色、渐变色等。这里的Shader实现的效果与印章类似。我们也是通过给Shader指定对应的图像、渐变色等来填充图形的。Shader类只是一个基类，它其中只有两个方法setLocalMatrix(Matrix localM)、getLocalMatrix(Matrix localM)用来设置坐标变换矩阵的，有关设置矩阵的内容，我们后面会单独讲解坐标矩阵用法的时候，会再次提，这里就先略过。Shader类与ColorFiler一样，其实是一个空类，它的功能的实现，主要是靠它的派生类来实现的。继承关系如下：下面我们就来逐个来看每个派生类的用法与效果。 一、BitmapShader基本用法1、概述我们这篇文章只看一个派生类：BitmapShader，它的构造函数如下： public BitmapShader(Bitmap bitmap, TileMode tileX, TileMode tileY) 这个就相当于PhotoShop中的图案印章工具，bitmap用来指定图案，tileX用来指定当X轴超出单个图片大小时时所使用的重复策略，同样tileY用于指定当Y轴超出单个图片大小时时所使用的重复策略其中TileMode的取值有： TileMode.CLAMP:用边缘色彩填充多余空间 TileMode.REPEAT:重复原图像来填充多余空间 TileMode.MIRROR:重复使用镜像模式的图像来填充多余空间只看这些还是啥都不懂，我们先来举个例子来看下用法 2、BitmapShader使用示例这里使用的印章图像是：(dog_edge.png)中间是我们熟悉的小狗，四周被四种不同的颜色给包围，这些颜色是我特地画上去的，后面自然有它的用处。我们还是先直接来看完整代码吧：12345678910111213141516171819202122232425262728293031public class BitmapShaderView extends View &#123; private Paint mPaint; private Bitmap mBmp; public BitmapShaderView(Context context) &#123; super(context); init(); &#125; public BitmapShaderView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public BitmapShaderView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge); mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //getWidth()用于获取控件宽度，getHeight()用于获取控件高度 canvas.drawRect(0,0,getWidth(),getHeight(),mPaint); &#125;&#125; 代码其实很简单，在初始化的时候设置印章图片：12345private void init()&#123; mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge); mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));&#125; 然后在绘图的时候，利用paint绘制一个矩形，这个矩形的大小与控件的大小一模一样：12345protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //getWidth()用于获取控件宽度，getHeight()用于获取控件高度 canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 然后在布局中使用时：123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;Button android:layout_width="match_parent" android:layout_height="wrap_content" android:text="test BTN"/&gt; &lt;com.harvic.Blog_BitmapShader.BitmapShaderView android:layout_width="200dp" android:layout_height="400dp" android:layout_gravity="center_horizontal"/&gt;&lt;/LinearLayout&gt; 给我们自定义的控件添加上宽高限制，为了方便看效果，我在它上面也另外加了一个按钮从效果图中可以看出： 使用X轴和Y轴都使用REPEAT模式下，在超出单个图像的区域后，就会重复绘制这个图像 绘制是从控件的左上角开始的，而不是从屏幕原点开始的！这点很好理解，因为我们绘图也只会在自定义控件上绘图，不会在全屏幕上绘图。 3、TileMode模式解析上面初步看到了REPEAT模式的用法，现在我们分别来看在各个模式下的不同表现 （1）、TileMode.REPEAT模式：重复原图像来填充多余空间在更改模式时，只需要更新setShader里的代码：mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.REPEAT));在这里，X轴、Y轴全部设置成REPEAT模式，所以当控件的显示范围超出了单个图的显示范围时，在X轴上将使用REPEAT模式,同样，在Y轴上也将使用REPEAT模式 （2）、TileMode.MIRROR模式：重复使用镜像模式的图像来填充多余空间同样，将X轴、Y轴全部改为MIRROR模式：mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.MIRROR));先看效果图的X轴：在X轴上每两张图片的显示都像镜子一样翻转一下。同样，在Y轴上每两张图片的显示也都像镜子一样翻转一下。所以这就是镜相效果的作用，镜相效果其实就是在显示下一图片的时候，就相当于两张图片中间放了一个镜子一样。 （3）、TileMode.CLAMP:用边缘色彩填充多余空间同样，我们还是将X轴、Y轴全部改为CLAMP模式：mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.CLAMP));CLAMP模式的意思就是当控件区域超过当前单个图片的大小时，空白位置的颜色填充就用图片的边缘颜色来填充。 （4）、TileMode.CLAMP与填充顺序我们还是先来看一下原图像：按照我们上面讲的，当X轴、Y轴全部都是CLAMP模式时，X轴的空白区域会用图像的右侧边缘颜色来填充；Y轴的空白区域会用图像的底部的边缘颜色来填充，那效果应该是这样的：明显右下角的空白位置根本与图像是不沾边的，那它要用什么颜色来填充呢？是填充上方的蓝色还是填充左侧的绿色呢？从最终的效果图来看，这部分填充的颜色是绿色的，可为什么呢？其实这是跟填充顺序有关的，因为我们同时要填充横向和竖向；那到底是先填充横向还是先填充竖向呢？答案是先填充竖向！在填充竖向后的结果如下：在填充竖向后，整个竖向都是有颜色的了，此时再根据竖向的边缘色彩来填充横向：红色方框的区域就是根据竖向的边缘色彩来填充的，这样，当X轴Y轴全是CLAMP时，就理解为什么右下角是填充的绿色而不是蓝色的原因了。 （5）、当MIRROR与REPEAT混用时TileMode.MIRROR, TileMode.REPEAT上面我们在填充X轴 和Y轴的空白位置时，都是用的同一种模式，下面我们就来看一下当X轴与Y轴的填充模式不一样时，效果又是怎样的呢？这里我们假设X轴填充空白区域时，使用MIRROR样式、在填充Y轴空白区域时，使用REPEAT样式：mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.REPEAT));无论哪两种模式混合，我们在理解时只需要记着填充顺序是先填充Y轴，然后再填充X轴！这样效果图就很好理解了首先，是先填充Y轴，在填充Y轴时使用的是REPEAT模式，此时的效果图是：在填充Y轴以后再利用X轴的镜相模式来填充X轴，这样整个控件就被填充完毕了。TileMode.REPEAT，TileMode.MIRROR下面我们再反过来看一下当X轴使用REPEAT模式，Y轴使用MIRROR模式效果会怎样：mPaint.setShader(new BitmapShader(mBmp, TileMode.REPEAT, TileMode.MIRROR));同样是先使用镜相模式来填充Y轴，然后再使用REPEAT模式来填充X轴；所以从效果图中可以明显看出第一列的Y轴全部是镜相效果。然后再根据第一列的镜相效果来填充X轴，由于X轴使用的是REPEAT模式，所以X轴的图像全部都与左侧第一列的图像相同。 （6）、CLAMP模式与其它模式混用上面我们理解了填充顺序的意义以后，下面再来看一下最难的两种混用方式，就是当CLAMP模式与其它模式混用时的效果。比如，当X轴使用CLAMP效果填充，而Y轴使用MIRROR效果填充时：mPaint.setShader(new BitmapShader(mBmp, TileMode.CLAMP, TileMode.MIRROR));从效果图中很好理解，先填充Y轴，填充以后的Y轴各个图像是镜相分布的。而此时再使用CLAMP模式来填充X轴，会拿Y轴图像最边缘的颜色来进行填充。理解难度不大，就不再细讲了。下面再将这两种模式反过来，X轴使用MIRROR模式而Y轴使用CLAMP模式：mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP));想必大家看到效果图以后，也理解为什么会出现这种效果了，这里就不再讲了，如果还不懂，把上面讲的再看一遍。 4、绘图位置与模式的关系在上面的例子中，我们利用drawRect把整个控件大小都给覆盖了，那假如我们只画一个小矩形而不完全覆盖整个控件，那我们SetShader的图片是从哪里开始画的呢？是从开始drawRect所绘矩形的左上角开始画，还是在控件的左上角开始的呢？我们举个例子来看下：123456789101112131415161718192021222324252627282930public class BitmapShaderView extends View &#123; private Paint mPaint; private Bitmap mBmp; public BitmapShaderView(Context context) &#123; super(context); init(); &#125; public BitmapShaderView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public BitmapShaderView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; mPaint = new Paint(); mBmp = BitmapFactory.decodeResource(getResources(),R.drawable.dog_edge); mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP)); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(100,20,200,200,mPaint); &#125;&#125; 上面的代码并没有改变什么，我们需要注意的只有两点：第一：设置的重复模式：mPaint.setShader(new BitmapShader(mBmp, TileMode.MIRROR, TileMode.CLAMP));第二：绘图时，仅绘制一小块矩形：canvas.drawRect(100,20,200,200,mPaint);这是个什么鬼……根本看不懂啊有木有……我们再回来看一下当所绘矩形覆盖整个控件时的效果图：而我们这里的效果图根本就是这个完整的图片上扣出来的一小块有没有…… 其实这正说明了一个问题：无论你利用绘图函数绘多大一块，在哪绘制，与Shader无关。因为Shader总是在控件的左上角开始，而你绘制的部分只是显示出来的部分而已。没有绘制的部分虽然已经生成，但只是不会显示出来罢了。 利用这个特性，我们就可绘制我们的最上面的望远镜效果了 5、望远镜效果我们只需要按照控件大小平铺当前所要绘制的图形的Shader，然后再画出来一个圆圈来当做望远镜就可以了。我们先用一张做为Shader的背景图：在看完所使用的背景以后，我们再来看下效果图这里有两个功能：首先，将图片拉伸来覆盖整个控件；然后，首先给控件设置进BitmapShader，然后在手指的位置画一个半径为150的圆就可以了。正是由于在Paint设置了Shader以后，无论我们绘图位置在哪，Shader中的图片都是从控件的左上角开始填充的，而我们所使用的绘图函数只是用来指定哪部分显示出来，所以当我们在手指按下位置画上一个圆形时，就会把圆形部分的图像显示出来了，看起来就是个望远镜效果。然后完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class TelescopeView extends View &#123; private Paint mPaint; private Bitmap mBitmap,mBitmapBG; private int mDx = -1, mDy = -1; public TelescopeView(Context context) &#123; super(context); init(); &#125; public TelescopeView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public TelescopeView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; mPaint = new Paint(); mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.scenery); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDx = (int) event.getX(); mDy = (int) event.getY(); postInvalidate(); return true; case MotionEvent.ACTION_MOVE: mDx = (int) event.getX(); mDy = (int) event.getY(); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: mDx = -1; mDy = -1; break; &#125; postInvalidate(); return super.onTouchEvent(event); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mBitmapBG == null)&#123; mBitmapBG = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888); Canvas canvasbg = new Canvas(mBitmapBG); canvasbg.drawBitmap(mBitmap,null,new Rect(0,0,getWidth(),getHeight()),mPaint); &#125; if (mDx != -1 &amp;&amp; mDy != -1) &#123; mPaint.setShader(new BitmapShader(mBitmapBG, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); canvas.drawCircle(mDx, mDy, 150, mPaint); &#125; &#125;&#125; 我们主要来看下OnDraw函数：在onDraw函数中，第一部分，就是新建一个空白的bitmap，这个bitmap的大小与控件一样，然后把我们的背景图进行拉伸，画到这个空白的bitmap上。12345if (mBitmapBG == null)&#123; mBitmapBG = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888); Canvas canvasbg = new Canvas(mBitmapBG); canvasbg.drawBitmap(mBitmap,null,new Rect(0,0,getWidth(),getHeight()),mPaint);&#125; 由于这里的canvasbg是用mBitmapBG创建的，所以所画的任何图像都会直接显示在mBitmapBG上，而我们创建的mBitmapBG是与控件一样大的，所以当把mBitmapBG做为Shader来设置给paint时，mBitmapBG会正好覆盖整个控件，而不会有多余的空白像素。这里需要注意的就是我们在将原图像画到mBitmapBG时，进行了拉压缩，把它拉伸到根当前控件一样大小。然后利用Shader的知识，利用OnMotionEvent来捕捉用户的手指位置，当用户手指下按时，在手指位置画一个半径为150的圆形，把对应的位置的图像显示出来就可以了：1234if (mDx != -1 &amp;&amp; mDy != -1) &#123; mPaint.setShader(new BitmapShader(mBitmapBG, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT)); canvas.drawCircle(mDx, mDy, 150, mPaint);&#125; 这个控件的难度并不大，问题就在于理解Shader中图像的起始布局位置和显示图像的关系。 二、利用BitmapShader生成不规则头像这部分，我们还得利用Shader的从控件左上角开始布局的原理和显示图像的关系，来讲解一个我们平时经常用到的控件：不规则头像，效果图如下： 前面我们已经教大家了一种生成不规则头像的方法，大家还记得不，使用xfermode。这篇我们就来讲解另一种生成不规则头像的方法，大家赶紧喜大普奔吧 这里我们依然教大家如何将它封装成一个控件，这里所实现的效果有：圆形图像，方形带圆角的头像。 1、初步实现圆形头像控件这部分，我们先讲原理，初步实现下面的控件效果原始的头像是这样的：很明显我们给头像加了个圆框效果；我们直接来看代码吧：1234567891011121314151617181920212223242526272829303132333435public class AvatorViewDemo extends View &#123; private Paint mPaint; private Bitmap mBitmap; private BitmapShader mBitmapShader; public AvatorViewDemo(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(); &#125; public AvatorViewDemo(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(); &#125; private void init() throws Exception&#123; mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.avator); mPaint = new Paint(); mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Matrix matrix = new Matrix(); float scale = (float) getWidth()/mBitmap.getWidth(); matrix.setScale(scale,scale); mBitmapShader.setLocalMatrix(matrix); mPaint.setShader(mBitmapShader); float half = getWidth()/2; canvas.drawCircle(half,half,getWidth()/2,mPaint); &#125;&#125; 首先是初始化：123456private void init() throws Exception&#123; mBitmap = BitmapFactory.decodeResource(getResources(),R.drawable.avator); mPaint = new Paint(); mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);&#125; 在初始化时创建一个BitmapShader，填充模式分别是TileMode.CLAMP、TileMode.CLAMP，其实这里填充模式没什么用，因为我们只需要显示当前图片；所以不存在多余空白区域，所以使用哪种填充模式都无所谓。最关键的部分在于绘图：1234567891011protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Matrix matrix = new Matrix(); float scale = (float) getWidth()/mBitmap.getWidth(); matrix.setScale(scale,scale); mBitmapShader.setLocalMatrix(matrix); mPaint.setShader(mBitmapShader); float half = getWidth()/2; canvas.drawCircle(half,half,getWidth()/2,mPaint);&#125; 绘图时，首先是将BitmapShader缩放到与控件宽高一致；由于我们要画的是一个圆形图像，所以我们必须将图像缩放成一个正方形，而边长就与控件的宽度一致即可：12345Matrix matrix = new Matrix();float scale = (float) getWidth()/mBitmap.getWidth();matrix.setScale(scale,scale);mBitmapShader.setLocalMatrix(matrix);mPaint.setShader(mBitmapShader); 这块就使用了位置矩阵的知识，同时也用上了我们开篇时所讲的mBitmapShader.setLocalMatrix(matrix)函数，有关位置矩阵我们会在后面的章节中涉及，这里只需要知道这块是用来缩放BitmapShader的即可。然后利用BitmapShader是从控件左上角开始平铺的，利用canvas.drawXXX系列函数只是用来定义显示哪一块的原理，我们在图片的正中心画一个圆，半径是图片正方形半径的一半：float half = getWidth()/2;canvas.drawCircle(half,half,getWidth()/2,mPaint);在理解了上面的原理之后，再理解这个就难度不大了。我们这里只画了个圆形，如果我们画一个矩形，那显示的控件就是个矩形了，如果我们画一个五角形，那头像也就是个五角形效果了；原理到这里就讲完了，下面我们先来看几个开源例子，然后再继续讲解如何将其封装成控件的知识。下面我们来看一下几个开源的例子：地址：https://github.com/hdodenhof/CircleImageView这个效果大家现在会做了没，它不仅实现了圆形头像效果，还而还在外边加了一个带颜色的边。想必在头像外围加个描边不是什么给事吧……悄悄提醒一下，只需要在画圆时，将paint设置为mPaint.setStyle(Paint.Style.STROKE);即可画出来描边。大家自己试试怎么来实现这个控件吧。第二个开源例子：地址：https://github.com/MostafaGazar/CustomShapeImageView具体这些效果在这个控件中是怎么实现的，我也没有看。但敢肯定的是，通过BitmapShape是肯定可以实现的，只要我们利用Path可以做出各种图形（比如这里的五角形，这里的心形），然后利用canvas在Shape上显示出来这块区域就可以了。但明显难度是比较大的，所以对于这类复杂的图像显示，还是建议使用以前我们讲过的Xfermode来做图像混合即可。好了，原理就讲到这了，下面我们把上面的圆形控件加以封装，做出来一个通用控件 2、封装成控件上篇文章已经教大家如何封装成控件了，这部分我们再来看这个例子是如何封装成控件的。我们再重新来看一下效果图，看我们这部分要做哪些效果出来从效果图来看，我们要做两个效果： 圆形图像 矩形图像，但带自定义大小的圆角 （1）、自定义属性封装控件最难免的就是自定义属性了，这块是必会的。根据我们需要做的两个效果，所以我们自定义属性时，首先要有一个属性来标识当前是做圆形头像还是做矩形图像然后如果是矩形图像，还要有一个值来表示矩形图像的圆角有多大最后，还需要一个src的属性来让用户引入Bitmap图像所以，此时的定义属性应该是：（values/attrs.xml）1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="AvatorView"&gt; &lt;attr name="src" format="reference" /&gt; &lt;attr name="format" format="enum"&gt; &lt;enum name="circle" value="0"/&gt; &lt;enum name="rectTangle" value="1"/&gt; &lt;/attr&gt; &lt;attr name="radius" format="integer" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这里定义了三个属性： src：对应BitmapShader所需要使用的图片 format：是一个枚举值，用于指定当前是做圆形图像还是做矩形图像 radius：是矩形图像时的边角圆形半径 （2）、控件解析在自定义的属性之后，我们就开始我们自定义控件的Java代码征程了，首先是解析自定义属性：1234567891011121314151617181920212223242526272829303132333435363738public class AvatorView extends View &#123; private Paint mPaint; private Bitmap mBitmap; private BitmapShader mBitmapShader; private int mEnumFormat =0,mRadius = 5; public AvatorView(Context context, AttributeSet attrs) throws Exception&#123; super(context, attrs); init(context,attrs); &#125; public AvatorView(Context context, AttributeSet attrs, int defStyle) throws Exception&#123; super(context, attrs, defStyle); init(context,attrs); &#125; private void init(Context context,AttributeSet attrs) throws Exception&#123; /** * 提取属性定义 */ TypedArray typedArray = context.obtainStyledAttributes(attrs,R.styleable.AvatorView); int BitmapID = typedArray.getResourceId(R.styleable.AvatorView_src,-1); if (BitmapID == -1)&#123; throw new Exception("AvatorView 需要定义Src属性,而且必须是图像"); &#125; mBitmap = BitmapFactory.decodeResource(getResources(),BitmapID); mEnumFormat = typedArray.getInt(R.styleable.AvatorView_format,0); if (mEnumFormat == 1)&#123; mRadius = typedArray.getInt(R.styleable.AvatorView_radius,5); &#125; typedArray.recycle(); mPaint = new Paint(); mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); &#125; …………&#125; 这部分与上篇相同，就不再讲了，无外乎就是在初始化的时候解析控件自定义属性，没什么难度。 （3）、自测量然后我们需要在用户定义layout_width、layout_height的值为wrap_content时，自测量控件大小即重写onMeasuer()12345678910111213protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width = mBitmap.getWidth(); int height = mBitmap.getHeight(); setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth: width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight: height);&#125; 主要就是当用户将控件的layout_with或者layout_heigt设置成wrap_content时，将宽高设置成图片的宽高。这块我们在上篇也已经讲过了，这里也就不再细讲了。不理解的同学自行翻看上一篇。 （4）、绘图最后一部分，到了正式绘图了：12345678910111213141516protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); Matrix matrix = new Matrix(); float scale = (float) getWidth()/mBitmap.getWidth(); matrix.setScale(scale,scale); mBitmapShader.setLocalMatrix(matrix); mPaint.setShader(mBitmapShader); float half = getWidth()/2; if (mEnumFormat == 0)&#123; canvas.drawCircle(half,half,getWidth()/2,mPaint); &#125;else if(mEnumFormat == 1)&#123; canvas.drawRoundRect(new RectF(0,0,getWidth(),getHeight()),mRadius,mRadius,mPaint); &#125;&#125; 也没啥难度，就是先放大BitmapShader到与控件相同大小，然后根据用户要画的是圆形还是圆角矩形，调用不同的绘图函数即可。 （5）、XML中使用然后我们来看如何在布局中使用这个控件(main.xml)：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res/com.harvic.Blog_BitmapShader" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent"&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="50dp" android:layout_height="50dp" app:src="@drawable/avator" app:format="circle"/&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="100dp" android:layout_height="100dp" app:src="@drawable/avator" app:format="circle"/&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="100dp" android:layout_height="100dp" android:layout_marginTop="10dp" app:src="@drawable/avator" app:format="rectTangle" app:radius="10"/&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="130dp" android:layout_height="130dp" android:layout_marginTop="10dp" app:src="@drawable/avator" app:format="rectTangle" app:radius="30"/&gt; &lt;com.harvic.Blog_BitmapShader.AvatorView android:layout_width="150dp" android:layout_height="150dp" android:layout_marginTop="10dp" app:src="@drawable/avator" app:format="rectTangle" app:radius="70"/&gt;&lt;/LinearLayout&gt; 效果图就是如开篇所示，从布局代码中可以看到，我们已经实现了这个自定义控件，我们不仅可以指定大小，而且还可以使用wrap_content来自适应大小。我这里没有使用wrap_content的主要原因在于图片太大，使用wrap_content的话就画不了几张图了，大家底下自已试试吧 （6）、存在问题有些同学每次都是拿博主控件直接用到项目中，这可是不行的哦，因为博主在这里讲的自定义控件都是抛砖引玉的，主要核心在原理讲解，并没有做太多的容错的……这个控件也不例外，我们这里强制使用的正方的图像，当图像是矩形时，就会出现问题，大家需要自己做容错处理，判断图像的宽高，缩放图像以至在不改变图片比例的情况下，填充控件。这篇文章就到这了，下篇继续来看Shader的其它派生类的用法和实例。 五、LinearGradient与闪动文字效果这篇就给大家讲setShader的另一个参数，LinearGradient，使用过shape标签的同学，对这个方法估计都不莫生，就是线性渐变。跟PhotoShop中的线性渐变的原理和作用是一样的。这篇文章的最终会实现一个闪动文字效果控件： 一、引言标签的用法：12345678910&lt;gradient android:type=["linear" | "radial" | "sweep"] //共有3中渐变类型，线性渐变（默认）/放射渐变/扫描式渐变 android:angle="integer" //渐变角度，必须为45的倍数，0为从左到右，90为从上到下 android:centerX="float" //渐变中心X的相当位置，范围为0～1 android:centerY="float" //渐变中心Y的相当位置，范围为0～1 android:startColor="color" //渐变开始点的颜色 android:centerColor="color" //渐变中间点的颜色，在开始与结束点之间 android:endColor="color" //渐变结束点的颜色 android:gradientRadius="float" //渐变的半径，只有当渐变类型为radial时才能使用 android:useLevel=["true" | "false"] /&gt; //使用LevelListDrawable时就要设置为true。设为false时才有渐变效果 其中的渐变类型有”linear” | “radial” | “sweep”,在代码中对应的类分别是LinearGradient、RaialGradient、SweepGradient；有关各个渐变效果的用法，不知道的同学强烈建议你先看看这篇文章。这篇我们要讲就是线性渐变的LinearGradient； 二、LinearGradient基本使用1、构造函数我们先来看下LinearGradient的构造函数：第一个构造函数：public LinearGradient(float x0, float y0, float x1, float y1,int color0, int color1, TileMode tile)用过PhotoShop的线性激变工具的同学，应该都知道，线性渐变其实是在指定的两个点之间填充渐变颜色。 参数中的(x0,y0)就是起始渐变点坐标，参数中(x1,y1)就是结束渐变点坐标； color0就是起始颜色，color1就是终止颜色；颜色值必须使用0xAARRGGBB形式的16进制表示！表示透明度的AA一定不能少。 TileMode tile：与BitmapShader一样，用于指定控件区域大于指定的渐变区域时，空白区域的颜色填充方法。 很显然！这个方法，只能指定两种颜色之间的渐变。如果需要多种颜色之间的渐变，就需要使用下面的这个构造函数了。 第二个构造函数：public LinearGradient(float x0, float y0, float x1, float y1,int colors[], float positions[], TileMode tile)同样，(x0,y0)就是起始渐变点坐标，参数中(x1,y1)就是结束渐变点坐标colors[]用于指定渐变的颜色值数组，同样，颜色值必须使用0xAARRGGBB形式的16进制表示！表示透明度的AA一定不能少。positions[]与渐变的颜色相对应，取值是0-1的float类型，表示在每一个颜色在整条渐变线中的百分比位置 2、两色渐变使用示例我们先来看看两色渐变的构造函数是如何来使用的：1234567891011121314151617181920212223242526272829public class LinearGradientView extends View &#123; private Paint mPaint; public LinearGradientView(Context context) &#123; super(context); init(); &#125; public LinearGradientView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public LinearGradientView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); mPaint.setShader(new LinearGradient(0,getHeight()/2,getWidth(),getHeight()/2,0xffff0000,0xff00ff00, Shader.TileMode.CLAMP)); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint); &#125;&#125; 很简单，只需要在绘图的时候构造LinearGradient实例，通过Paint.setShader设置进去即可。大家注意一下，我这里设置的渐变范围是从控件的左边中点到右边中点：mPaint.setShader(new LinearGradient(0,getHeight()/2,getWidth(),getHeight()/2,0xffff0000,0xff00ff00, Shader.TileMode.CLAMP));最后通过canvas.drawRect把整个控件区域画出来：canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);这里大家注意一下，上面我们也已经提到了，颜色值必须使用0xAARRGGBB的完整16进制的颜色样式表示，我们这里的颜色值就是0xffff0000和0xff00ff00；大家自己可以进行尝试，如果把红色的透明度值去掉，改写成0xff00000，是不会有任何显示的。 3、多色渐变使用示例下面我们来看第二个构造函数，多色渐变的使用方法：12345678protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,getHeight()/2,getWidth(),getHeight()/2,colors,pos, Shader.TileMode.CLAMP); mPaint.setShader(multiGradient); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 从这里可以看出，渐变的开始点同样是控件左边中点，渐变的结束点也同样是控件右边中点；这里我们指定了五种渐变颜色，而且指定了每个颜色的位置，前四种颜色是按20%均匀分布的，最后两种颜色相距40%；最后通过canvas.drawRect把整个控件区域画出来 注意:colors和pos的个数一定要相等，也就是说必须指定每一个颜色值的位置！如果多或少都会直接报错：（Signal 11是SO内部错误） 4、渐变起始坐标与填充的关系——矩形填充我们上面的示例中都是从控件左边中间到控件右边中点；如果我们改成从左上角到右上角的填充方式，结果会怎样呢？12345678910111213141516171819202122232425262728293031323334353637383940protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,0,getWidth(),getHeight(),colors,pos, Shader.TileMode.CLAMP); mPaint.setShader(multiGradient); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125;``` 渐变线是从控件的左上角到控件的右下角位置：`LinearGradient multiGradient = new LinearGradient(0,0,getWidth(),getHeight(),colors,pos, Shader.TileMode.CLAMP);` 效果图： ![2017021914874880007490.png](http://ohtrrgyyd.bkt.clouddn.com/2017021914874880007490.png) 原理图： ![20170219148748802635587.png](http://ohtrrgyyd.bkt.clouddn.com/20170219148748802635587.png) 就是说，首先是两个渐变点之间连线，然后以连线为对角线形成一个矩形，各种颜色都是以这条对角线为矩形的填充的。##### 5、TileMode重复方式在讲到BitmapShader的时候，我们已经详细讲过TileMode的意义：当控件区域大小渐变区域时，用于填充空白位置的。 下面我们就逐个看一下TileMode不同时，对于线性渐变的有什么作用。 ###### （1）、X、Y轴共用填充参数 首先，我们再回来看一下LinearGradient的构造函数：`public LinearGradient(float x0, float y0, float x1, float y1,int colors[], float positions[], TileMode tile)` `public LinearGradient(float x0, float y0, float x1, float y1,int color0, int color1, TileMode tile)` 从构造函数中可以看出，LiearGradient只有一个TileMode参数，这说明X轴与Y轴共用这一个TileMode填充参数，而不能像BitmapShader那样分别指定X轴与Y轴的填充参数。 ###### （2）、TileMode.CLAMP``` javaprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas);//// 多色渐变 int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,0,getWidth()/2,getHeight()/2,colors,pos, Shader.TileMode.CLAMP); mPaint.setShader(multiGradient); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 这里做了一个多色渐变，渐变点是从(0,0)到屏幕的中间点(width/2,height.2)；效果图如下：从效果图中可以看到，效果很好理解，就是以(0,0)到(width/2,height.2)为矩形对角线，来填充各种颜色渐变，对于之外的区域，用边缘色彩来填充。 （3）、TileMode.REPEAT同样是上面的代码，渐变点是从(0,0)到屏幕的中间点(width/2,height.2)，当空白区域填充模式改为TileMode.REPEAT时，效果图如下：大家初次看到这个效果，可能一脸懵逼 —_—!!!, 其实也不难理解，我们需要先找到哪块是我们的渐变，哪块是空白像素的填充：在这个图中，蓝色块是我们原始的渐变图形，从从(0,0)到屏幕的中间点(width/2,height.2)，另外的没有遮起来的部分是空白位置填充的。在填充时，结束点做为填充点的起点，即填充的线性渐变的位置为从(width/2,height/2)到(width,height)，即从中间点到右下角点位置的填充。 （4）、TileMode.MIRROR同样，如果我们把填充模式改为镜像模式，效果图如下： 6、填充方式：从控件左上角开始填充与BitmapShader一样，同样是从控件左上角开始填充整个控件，利用canvas.drawXXX系列函数只是用来指定显示哪一块比如：123456789protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //多色渐变 int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,0,getWidth()/2,getHeight()/2,colors,pos, Shader.TileMode.MIRROR); mPaint.setShader(multiGradient); canvas.drawRect(100,100,200,200,mPaint); &#125; 同样是使用镜像模式，但我们不再全屏绘制，而只是绘出其中一小部分：我们再来看看全屏绘制的镜像模式的效果图：很明显，这里所绘制的一小块，跟从全屏绘制的效果图上摘下来的一块一样。 这就说明了：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块 我们说了如果利用drawXXX系列函数只是用来指定显示哪一块，那如果我们利用DrawText来显示，那是不是就会显示出彩色文字了？12345678910protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //多色渐变 int[] colors = &#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00,0xff00ffff&#125;; float[] pos = &#123;0f,0.2f,0.4f,0.6f,1.0f&#125;; LinearGradient multiGradient = new LinearGradient(0,0,getWidth()/2,getHeight()/2,colors,pos, Shader.TileMode.MIRROR); mPaint.setShader(multiGradient); mPaint.setTextSize(50); canvas.drawText("欢迎关注启舰的blog",0,200,mPaint);&#125; 有没有感觉很酷炫……看似牛逼的效果其实就是这么简单……如果我们把渐变效果移动起来，就直接实现了我们开篇时说的文字渐变的动画效果了。下面我们加入动画，让颜色动起来吧 三、闪光字符串实现这部分我们要实现的效果图如下： 闪光效果有木有……看起来很碉堡吧，我们就来具体看下原理吧，这个控件只给大家讲基本原理，就不再封装成控件了。我们先来看下原理图： 1、原理（1）、初始状态首先，我们要有一个渐变的LinearGradient,颜色是从文字颜色的黑色到中间的绿色，然后再到黑色，填充模式为 Shader.TileMode.CLAMP，初始的位置在文字的左侧；对应图像为： 我这里为了表述文字效果，特地做了几个处理； 首先我把渐变图像用红边框了起来。由于填充模式是Shader.TileMode.CLAMP，所以右侧文字的位置会被填充为边缘颜色黑色 为了表述当前文字的位置，我特地把文字写成了红色。而文字真正的颜色应该是其底部LinearGradient的填充色才对的，大家这点注意。对应代码为：12345678910mLinearGradient = new LinearGradient(- getMeasuredWidth(),0,0,0,new int[]&#123; getCurrentTextColor(),0xff00ff00,getCurrentTextColor()&#125;, new float[]&#123; 0, 0.5f, 1 &#125;, Shader.TileMode.CLAMP );&#125; （2）、运动中下图显示的是当渐变的LinearGradient移动到文字部分的时的状态由于使用的是Shader.TileMode.CLAMP填充模式，所以两次空白区域都会被填充为LinearGradient的边缘颜色，即文字的黑色。上面我们讲了，文字会显示其下方LinearGradient的填充颜色，所以现在文字的文字就会有一部分变绿了。 （3）、终止状态在终止状态时，LinearGradient移动到文字的右侧同样是由于Shader.TileMode.CLAMP填充模式，文字会被填充为文字原本的颜色。 从上面的原理中，我们需要理出来几个点：第一：创建的LinearGradient渐变的构造方法，前面已经列出来代码了，初始位置是在文字左侧的，而且大小与文字所占位置相同，填充模式使用边缘填充第二：从起始位置和终止位置可以看出，LinearGradient渐变的运动长度是两个文字的长度。 2、代码实现其实看了原理之后，实现起来就没有什么难度了，我们还是列出完整代码，然后针对性的讲一点就可以了，如果大家还没看懂，可以把示例源码下下来，自己再研究研究123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ShimmerTextView extends TextView &#123; private Paint mPaint; private int mDx; private LinearGradient mLinearGradient; public ShimmerTextView(Context context) &#123; super(context); init(); &#125; public ShimmerTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public ShimmerTextView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; mPaint =getPaint(); &#125; @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); ValueAnimator animator = ValueAnimator.ofInt(0,2*getMeasuredWidth()); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mDx = (Integer) animation.getAnimatedValue(); postInvalidate(); &#125; &#125;); animator.setRepeatMode(ValueAnimator.RESTART); animator.setRepeatCount(ValueAnimator.INFINITE); animator.setDuration(2000); animator.start(); mLinearGradient = new LinearGradient(- getMeasuredWidth(),0,0,0,new int[]&#123; getCurrentTextColor(),0xff00ff00,getCurrentTextColor() &#125;, new float[]&#123; 0, 0.5f, 1 &#125;, Shader.TileMode.CLAMP ); &#125; @Override protected void onDraw(Canvas canvas) &#123; Matrix matrix = new Matrix(); matrix.setTranslate(mDx,0); mLinearGradient.setLocalMatrix(matrix); mPaint.setShader(mLinearGradient); super.onDraw(canvas); &#125;&#125; 1、派生自TextView首先需要注意的是，控件派生自TextView，所以可以使用TextView的自带方法getCurrentTextColor()来获取文字颜色。 2、如何移动LinearGradient然后，上面我们讲了如何给文字加上渐变效果，其实让它动起来办法很简单，还记得我们说过Shader有一个setLocalMatrix(Matrix localM) 方法可以设置位置矩阵么，我们只需要给LinearGradient设置上逐渐平移的矩阵就可以了。比如：1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; Matrix matrix = new Matrix(); matrix.setTranslate(mDx,0); mLinearGradient.setLocalMatrix(matrix); mPaint.setShader(mLinearGradient); super.onDraw(canvas);&#125; 其中向右偏移的距离mDx，是由ValueAnimator生成的； 3、ValueAnimator的创建前面我们讲了LinearGradient移动距离是从0到两倍的text距离，我们通过getMeasuredWidth()可以得到TextView的宽度，乘以2就可以了，创建代码如下：123456789101112ValueAnimator animator = ValueAnimator.ofInt(0,2*getMeasuredWidth());animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mDx = (Integer) animation.getAnimatedValue(); postInvalidate(); &#125;&#125;);animator.setRepeatMode(ValueAnimator.RESTART);animator.setRepeatCount(ValueAnimator.INFINITE);animator.setDuration(2000);animator.start(); 六、RadialGradient与水波纹按钮效果这篇将是Shader的最后一篇，下部分，我们将讲述Canvas变换的知识。在讲完Canvas变换以后，就正式进入第三部曲啦，是不是有点小激动呢…… 今天给大家讲的效果是使用RadialGradient来实现水波纹按钮效果，水波纹效果是Android L平台上自带的效果，这里我们就看看它是如何实现的，本篇的最终效果图如下 一、RadialGradient详解RadialGradient的意思是放射渐变，即它会向一个放射源一样，从一个点开始向外从一个颜色渐变成另一种颜色； 1、构造函数RadialGradient有两个构造函数1234//两色渐变RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode)//多色渐变RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode) （1）、两色渐变构造函数使用实例下面我们来看一下两色渐变构造函数的使用方法。RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode)这个两色渐变的构造函数的各项参数意义如下： centerX：渐变中心点X坐标 centerY：渐变中心点Y坐标 radius：渐变半径 centerColor：渐变的起始颜色，即渐变中心点的颜色,取值类型必须是八位的0xAARRGGBB色值！透明底Alpha值不能省略，不然不会显示出颜色。 edgeColor：渐变结束时的颜色，即渐变圆边缘的颜色，同样，取值类型必须是八位的0xAARRGGBB色值！ TileMode：与我们前面讲的各个Shader一样，用于指定当控件区域大于指定的渐变区域时，空白区域的颜色填充方式。 下面我们举个例子来看下用法： 123456789101112131415161718192021222324252627282930313233343536373839public class DoubleColorRadialGradientView extends View &#123; private Paint mPaint; private RadialGradient mRadialGradient; private int mRadius = 100; public DoubleColorRadialGradientView(Context context) &#123; super(context); init(); &#125; public DoubleColorRadialGradientView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public DoubleColorRadialGradientView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.REPEAT); mPaint.setShader(mRadialGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(getWidth()/2,getHeight()/2,mRadius,mPaint); &#125;&#125; 代码量不大，这里首先在onSizeChange中，创建RadialGradient实例。onSizeChange会在布局发生改变时调用，onSizeChanged(int w, int h, int oldw, int oldh)传过来四个参数，前两个参数就代表当前控件所应显示的宽和高。有关onSizeChange的具体意义，我们会在第三部曲讲解回调函数流程中具体讲到，这里大家就先理解到这吧。在onSizeChange中，我们创建了一个RadialGradient，以控件的中心点为圆点，创建一个半径为mRadius的，从0xffff0000到0xff00ff00的放射渐变。我们这里指定的空白填充方式为Shader.TileMode.REPEAT。然后在绘图的时候： 1234protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(getWidth()/2,getHeight()/2,mRadius,mPaint);&#125; 在绘图时，依然是以控件中心点为圆心，画一个半径为mRadius的圆；注意我们画的圆的大小与所构造的放射渐变的大小是一样的，所以不存在空白区域的填充问题。 效果图如下： （2）、多色渐变构造函数使用实例多色渐变的构造函数如下：RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode) 这里与两色渐变不同的是两个函数： int[] colors：表示所需要的渐变颜色数组 float[] stops：表示每个渐变颜色所在的位置百分点，取值0-1，数量必须与colors数组保持一致，不然直接crash,一般第一个数值取0，最后一个数值取1；如果第一个数值和最后一个数值并没有取0和1，比如我们这里取一个位置数组：{0.2,0.5,0.8}，起始点是0.2百分比位置，结束点是0.8百分比位置，而0-0.2百分比位置和0.8-1.0百分比的位置都是没有指定颜色的。而这些位置的颜色就是根据我们指定的TileMode空白区域填充模式来自行填充！！！有时效果我们是不可控的。所以为了方便起见，建议大家stop数组的起始和终止数值设为0和1. 下面我们举个例子来看下用法：1234567891011121314151617181920212223242526272829303132333435363738394041public class MultiColorRadialGradientView extends View &#123; private Paint mPaint; private RadialGradient mRadialGradient; private int mRadius = 100; public MultiColorRadialGradientView(Context context) &#123; super(context); init(); &#125; public MultiColorRadialGradientView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public MultiColorRadialGradientView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init()&#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); int[] colors = new int[]&#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00&#125;; float[] stops = new float[]&#123;0f,0.2f,0.5f,1f&#125;; mRadialGradient = new RadialGradient(w/2,h/2,mRadius,colors,stops, Shader.TileMode.REPEAT); mPaint.setShader(mRadialGradient); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(getWidth()/2,getHeight()/2,mRadius,mPaint); &#125;&#125; 这里主要看下多色渐变的构造方法：123int[] colors = new int[]&#123;0xffff0000,0xff00ff00,0xff0000ff,0xffffff00&#125;;float[] stops = new float[]&#123;0f,0.2f,0.5f,1f&#125;;mRadialGradient = new RadialGradient(w/2,h/2,mRadius,colors,stops, Shader.TileMode.REPEAT); 这里构造了一个四色颜色数组，渐变位置对应{0f,0.2f,0.5f,1f}，然后创建RadialGradient实例。没什么难度。然后在绘画的时候，同样以控件中心为半径，以放射渐变的半径为半径画圆。由于画的圆半径与放射渐变的大小相同，所以不存在空白位置填充的问题，所以TileMode.REPEAT并没有用到。 1、TileMode重复方式TileMode的问题，已经重复讲了几篇文章了，其实虽然每种Shader所表现出来的效果不一样，但是形成原理都是相同的。下面我们再来看一下RadialGradient在不同的TileMode下的具体表现。 （1）、X、Y轴共用填充参数与LinearGradient一样，从构造函数中，可以明显看出RadialGradient只有一个填充模式： 1234//两色渐变RadialGradient(float centerX, float centerY, float radius, int centerColor, int edgeColor, Shader.TileMode tileMode)//多色渐变RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode) 这就说明了，当填充空白区域时，X轴和Y轴使用同一种填充模式。而不能像BitmapShader那样分别指定X轴与Y轴的填充参数。 （2）、TileMode.CLAMP——边缘填充我们依然使用双色渐变的示例来看下效果，为了显示填充效果，我们这次画一个屏幕大小的矩形：1234567891011121314@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 从效果图中可以明显看出，除了放渐渐变以外的空白区域都被边缘填充成为了绿色； （3）、TileMode.REPEAT——重复填充我们仍使用上面的代码，只是将填充模式改为重复填充：123456789101112protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.REPEAT); mPaint.setShader(mRadialGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 这个图像乍看去有点辣眼睛，花花绿绿的……从效果图中可以看出，最内部的圆形是红到绿的原始放射渐变。其外面的圆就是空白区域填充模式了，在它的外围，从红到绿渐变。 （4）、TileMode.MIRROR—镜像填充同样是使用上面的代码，只是将填充模式改为镜像填充：12345678910111213protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.MIRROR); mPaint.setShader(mRadialGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);&#125; 有些同学第一下看到这个图可能有点懵，所谓镜像，就是把原来的颜色的倒过来填充。即原始是红到绿渐变，第二圈就变成了绿到红渐变，第三圈就又是红到绿渐变，如此往复。如果我把每一圈渐变的界限标出来，大家可能就容易看懂了： 图中白色线就是每一圈渐变的边界线，一次完整的填充就是两个白色圈中的部分。 （5）、填充方式：从控件左上角开始填充在讲BitmapShader和LinearShader时，我们就一再强调一个点：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块；我们在RadialGradient中也做下测试： 1234567891011121314@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mRadialGradient = new RadialGradient(w/2,h/2,mRadius,0xffff0000,0xff00ff00, Shader.TileMode.REPEAT); mPaint.setShader(mRadialGradient);&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawRect(0,0,200,200,mPaint);&#125; 我们这里使用TileMode.REPEAT来填充空白区域，在绘图时，我们只画出左上角的一部分；效果图如下： 从效果图中明显可以看出结论了：无论哪种Shader，都是从控件的左上角开始填充的，利用canvas.drawXXX系列函数只是用来指定显示哪一块 二、水波纹按钮效果这部分就要利用RadialGradient来实现水波纹效果了，我们这里直接继承自Button类，做一个按钮的水波纹效果，其实这里继承自任何一个类都是可以在这个类原本的显示内容上显示水波纹效果的，比如，大家可以试验下在源码的基础上，将其改为派生自ImageView，当然要记得给它添加上src属性，是一样会有水波纹效果的。 1、概述根据上面的的对RadialGradient的讲解，大家第一反应应该是，水波纹很好实现啊：不就是，画一个带有渐变效果的逐渐放大的圆不就得了。不错，思想确实就是这么简单。 （1）、不过，第一个问题来了，从哪个颜色，渐变到哪个颜色呢？最理想的状态是，从按钮的背景色渐变到天蓝色（开篇效果图中颜色）。但是，怎么拿到按钮的背景色呢？因为按钮的android:background属性填充不一定是颜色，有可能是一个drawable，而这个drawable可以是图片，也可能是selector文件等，所以这条路根本走不通。而我们讲过，RadialGradient中填充的渐变色彩必须是AARRGGBB形式的，所以我们只需要讲初始颜色的透明度设为0，不就露出了按钮的背景色了么。即类似下面的代码：mRadialGradient = new RadialGradient(x, y,20 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); 在这里我们将初始的渐变色改为0x00FFFFFF，由于透明度部分全部设置为0，所以整个颜色就是透明的。所以整个渐变过程就变为从零透明度逐渐变为纯天蓝色（0xFF58FAAC）。 （2）、第二个问题，我们应该怎么安排RadialGradient的填充模式从效果图中是可以明显看出我们会逐渐放大绘制RadialGradient的圆的，那么，我们是让RadialGradient的渐变变径随着绘制的圆增大而增大，还是不改变RadialGradient的初始半径，空余部分使用Shader.TileMode.CLAMP填充来实现水波纹呢。 答案是让RadialGradient的渐变变径随着绘制的圆增大而增大；下面我们分别举个例子来看下效果就知道区别了： 我们将RadialGradient的初始半径设置为20，而假设当前绘制圆的半径是150，分别用模拟代码来展示在不同代码处理下的效果，以最终决定选用哪种方式来绘制RadialGradient渐变。 如果使用空余部分使用Shader.TileMode.CLAMP填充 123456789101112@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mRadialGradient == null) &#123; int x = getWidth()/2; int y = getHeight()/2; mRadialGradient = new RadialGradient(x, y,20 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); canvas.drawCircle(x, y, 150, mPaint); &#125;&#125; 这里以控件中心为圆心，构造一个RadialGradient，这个RadialGradient的半径是20，从透明色，渐变到天蓝色mRadialGradient = new RadialGradient(x, y,20 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP);而在canvas画圆时，仍然以控件中心为圆心，但圆的半径却是150，明显要超出RadialGradient的半径，空白部分使用Shader.TileMode.CLAMP边缘模式填充canvas.drawCircle(x, y, 150, mPaint);从效果图中可以看出，在0-20的部分是从透明色到天蓝色的渐变，但是超出半径20的部分，都以边缘模式填充为完全不透明的天蓝色，感觉跟按钮完全没有融合在一起有没有如果让RadialGradient的渐变变径随着绘制的圆增大而增大1234567891011protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mRadialGradient == null) &#123; int x = getWidth()/2; int y = getHeight()/2; mRadialGradient = new RadialGradient(x, y,150 , 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); canvas.drawCircle(x, y, 150, mPaint); &#125;&#125; 这里的代码跟上面的一样，唯一不同的是，构造的RadialGradient的渐变半径与canvas.drawCircle所画的圆的半径是一样的，都是150；这就演示了让RadialGradient的渐变变径随着绘制的圆增大而增大的效果很明显，这是我们想要的结果，渐变色与按钮的背景完全融合。 2、代码实现上面在讲解了解决了核心问题，以后，下面我们就开始正式实战了从效果图中，可以看到我们所需要完成的功能： 在手指按下时，绘制一个默认大小的圆 在手指移动时，所绘制的默认圆的位置需要跟随手指移动 在手指放开时，圆逐渐变大 在动画结束时，波纹效果消失 按下和移动首先，我们来完成前两个功能：当首先按下时，绘制一个默认大小的圆，而且当手指移动时，可以跟随移动：123456789101112131415private int mX, mY;private int DEFAULT_RADIUS = 50;public boolean onTouchEvent(MotionEvent event) &#123; if (mX != event.getX() || mY != mY) &#123; mX = (int) event.getX(); mY = (int) event.getY(); setRadius(DEFAULT_RADIUS); &#125; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; return true; &#125; return super.onTouchEvent(event);&#125; 首先，我们这里并没区分MotionEvent.ACTION_DOWN和MotionEvent.ACTION_UP的绘图操作，只是统一在当前手指位置与上次的不一样时，就调用setRadius(DEFAULT_RADIUS);重绘RadialGradient；很明显，mX、mY变量表示当前手指的位置，而DEFAULT_RADIUS变量表示默认的RadialGradient的渐变尺寸。但是必须在 MotionEvent.ACTION_DOWN时return true，因为如果不return true，就表示当前控件并不需要下按之后的消息，所以ACTION_MOVE、ACTION_UP消息都不会再传到这个控件里来了，有关这个问题，在前面的文章中已经不只一次提到，这里就不再缀述了。 其中，setRadius(DEFAULT_RADIUS)函数的定义如下：1234567891011121314151617//表示当前渐变半径private int mCurRadius = 0;public void setRadius(final int radius) &#123; mCurRadius = radius; if (mCurRadius &gt; 0) &#123; mRadialGradient = new RadialGradient(mX, mY, mCurRadius, 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); &#125; postInvalidate();&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mX, mY, mCurRadius, mPaint);&#125; 在setRadius中主要负责在手指位置和渐变半径改变时，重新创建RadialGradient，然后重绘。很明显mCurRadius变量表示当前的渐变半径。最后在OnDraw函数中重绘时，画一个跟渐变半径同样大小的圆即可。 手指放开在手指放开时，主要是开始逐渐放大放射半径的动画，然后在动画结束的时候，清除RadialGradient。代码如下：1234567891011121314151617181920212223242526272829303132333435363738private ObjectAnimator mAnimator;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; ………… f (event.getAction() == MotionEvent.ACTION_UP) &#123; if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel(); &#125; if (mAnimator == null) &#123; mAnimator = ObjectAnimator.ofInt(this,"radius",DEFAULT_RADIUS, getWidth()); &#125; mAnimator.setInterpolator(new AccelerateInterpolator()); mAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; setRadius(0); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mAnimator.start(); &#125; return super.onTouchEvent(event);&#125; 在这段代码中，首先是在开始下一个动画前，先判断当前mAnimator是不是还在动画中，如果是正在动画就先取消: 123if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel();&#125; 这是为了避免当用户连续点击多次的时候，下一次开始动画时，上一次动画还没结束，这样两次动画就会造成冲突，应该先把上次的动画取消掉，然后再重新开始这次的动画：123mAnimator = ObjectAnimator.ofInt(this,"radius",DEFAULT_RADIUS, getWidth());&#125;mAnimator.setInterpolator(new AccelerateInterpolator()); 然后创建一个ObjectAnimator对象，这里动画操作的函数是setRadius(final int radius)函数，动画的区间是从默认半径到整个控件的宽度，之所以用当前控件的宽度来做为最大动画值，是因为，我们必须指定一个足够大的值，足以让波纹能够覆盖整个控件以后再结束。从效果图中可以看出，在这里控件的宽度是整个控件长度的最大值，所以，我们就以用户点击控件最边缘来算，当用户点击最左或最右边缘时，整个RadialGradient的半径是最大的，此时的最大值是控件宽度，所以我们就用控件宽度来做为动画的最大值即可。 其实这里还是不够严谨，因为在实际应用中，控件的宽度并不是整个控件的最大值，也有可能是控件的高度是最大的，所以最严谨的做法就是先判断控件的高度和宽度哪个最大，然后将最大值做为动画的半径。这里为了简化代码可读性，就不再对比了。 然后给mAnimator设置AccelerateInterpolator()插值器，因为我们需要让波纹的速度逐渐加快，如果不设置插值器的话，默认是使用LinearInterpolator插值器的，这样出来的效果是波纹的变大速度将是匀速的。mAnimator.setInterpolator(new AccelerateInterpolator());最后我们需要监听mAnimator结束的动作，当动画结束时，我们需要让RadialGradient消失，最简单的消失办法就是将所画圆的半径设置为0。12345678mAnimator.addListener(new Animator.AnimatorListener() &#123; ………… @Override public void onAnimationEnd(Animator animation) &#123; setRadius(0); &#125; …………&#125;); 到这里所有的代码就讲完了，完整的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class RippleView extends Button &#123; private int mX, mY; private ObjectAnimator mAnimator; private int DEFAULT_RADIUS = 50; private int mCurRadius = 0; private RadialGradient mRadialGradient; private Paint mPaint; public RippleView(Context context) &#123; super(context); init(); &#125; public RippleView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public RippleView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); init(); &#125; private void init() &#123; setLayerType(LAYER_TYPE_SOFTWARE,null); mPaint = new Paint(); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; if (mX != event.getX() || mY != mY) &#123; mX = (int) event.getX(); mY = (int) event.getY(); setRadius(DEFAULT_RADIUS); &#125; if (event.getAction() == MotionEvent.ACTION_DOWN) &#123; return true; &#125; else if (event.getAction() == MotionEvent.ACTION_UP) &#123; if (mAnimator != null &amp;&amp; mAnimator.isRunning()) &#123; mAnimator.cancel(); &#125; if (mAnimator == null) &#123; mAnimator = ObjectAnimator.ofInt(this,"radius",DEFAULT_RADIUS, getWidth()); &#125; mAnimator.setInterpolator(new AccelerateInterpolator()); mAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; setRadius(0); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); mAnimator.start(); &#125; return super.onTouchEvent(event); &#125; public void setRadius(final int radius) &#123; mCurRadius = radius; if (mCurRadius &gt; 0) &#123; mRadialGradient = new RadialGradient(mX, mY, mCurRadius, 0x00FFFFFF, 0xFF58FAAC, Shader.TileMode.CLAMP); mPaint.setShader(mRadialGradient); &#125; postInvalidate(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawCircle(mX, mY, mCurRadius, mPaint); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义控件——动画]]></title>
      <url>%2F2015%2F11%2F10%2Fandroid-animation%2F</url>
      <content type="text"><![CDATA[前言学习Android最重要的就是自定义控件了，好看的人性化的控件总是能抓住客户以及使用者的心，所以从网上学习了部分知识，以及通过自己的实践，总结了自定义控件的学习。在Android动画中，总共有两种类型的动画View Animation(视图动画)和Property Animator(属性动画)。其中： View Animation包括Tween Animation（补间动画）和Frame Animation(逐帧动画); Property Animator包括ValueAnimator和ObjectAnimation； alpha、scale、translate、rotate属于Tween Animation。 不同之处： 引入时间不同：View Animation是API Level 1就引入的。Property Animation是API Level 11引入的，即Android 3.0才开始有Property Animation相关的API。 所在包名不同：View Animation在包android.view.animation中。而Property Animation API在包 android.animation中。 动画类的命名不同：View Animation中动画类取名都叫XXXXAnimation,而在Property Animator中动画类的取名则叫XXXXAnimator 一、alpha、scale、translate、rotate、set(Tween Animation)的xml属性及用法一、概述alpha：渐变透明度动画效果scale：渐变尺寸伸缩动画效果translate：画面转换位置移动动画效果rotate：画面转移旋转动画效果 动作定义的动画文件应当放在res/anim文件夹下，采用R.anim.XXX.xml方式进行访问。 二、scale标签——调节尺寸scale是缩放动画 1、自身属性 android:fromXScale //起始的X方向上相对自身的缩放比例，浮点值，比如1.0代表自身无变化，0.5代表起始时缩小一倍，2.0代表放大一倍; android:toXScale //结尾的X方向上相对自身的缩放比例，浮点值; android:fromYScale //起始的Y方向上相对自身的缩放比例，浮点值; android:toYScale //结尾的Y方向上相对自身的缩放比例，浮点值; android:pivotX //缩放起点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p，当为数值时，表示在当前View的左上角，即原点处加上50px，做为起始缩放点；如果是50%，表示在当前控件的左上角加上自己宽度的50%做为起始点；如果是50%p，那么就是表示在当前的左上角加上父控件宽度的50%做为起始点x轴坐标。 android:pivotY //缩放起点Y轴坐标，取值及意义跟android:pivotX一样。 2、从Animation类继承的属性 android:duration //动画持续时间，以毫秒为单位 android:fillAfte //如果设置为true，控件动画结束时，将保持动画最后时的状态 android:fillBefore //如果设置为true,控件动画结束时，还原到开始动画前的状态 android:fillEnabled //与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态 android:repeatCount //重复次数 android:repeatMode //重复类型，有reverse和restart两个值，reverse表示倒序回放，restart表示重新放一遍，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作. android:interpolator //设定插值器，其实就是指定的动作效果，比如弹跳效果等，不在这小节中讲解，后面会单独列出一单讲解。 三、alpha标签——调节透明度1、自身属性 android:fromAlpha //动画开始的透明度，从0.0 –1.0 ，0.0表示全透明，1.0表示完全不透明 android:toAlpha //动画结束时的透明度，也是从0.0 –1.0 ，0.0表示全透明，1.0表示完全不透明 四、rotate标签——旋转1、自身属性 android:fromDegrees //开始旋转的角度位置，正值代表顺时针方向度数，负值代码逆时针方向度数 android:toDegrees //结束时旋转到的角度位置，正值代表顺时针方向度数，负值代码逆时针方向度数 android:pivotX //放起点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p. android:pivotY //缩放起点Y轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p 五、translate标签 —— 平移1、自身属性 android:fromXDelta //起始点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p android:fromYDelta //起始点Y轴坐标，可以是数值、百分数、百分数p 三种样式 android:toXDelta //结束点X轴坐标 android:toYDelta //结束点Y轴坐标 六、set标签——定义动作合集set标签自已是没有属性的，他的属性都是从Animation继承而来，但当它们用于Set标签时，就会对Set标签下的所有子控件都产生作用。 七、示例123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="3000" android:fillAfter="true"&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0"/&gt; &lt;scale android:fromXScale="0.0" android:toXScale="1.4" android:fromYScale="0.0" android:toYScale="1.4" android:pivotX="50%" android:pivotY="50%"/&gt; &lt;rotate android:fromDegrees="0" android:toDegrees="720" android:pivotX="50%" android:pivotY="50%"/&gt; &lt;/set&gt; 八、使用Animation 通过scaleAnimation = AnimationUtils.loadAnimation(this, R.anim.scaleanim);从XML文件中获取动画 利用startAnimation(animation);将动画传递给指定控件显示。 二、Interpolator插值器一、概述Interpolator属性是Animation类的一个XML属性，所以alpha、scale、rotate、translate、set都会继承得到这个属性。Interpolator被译为插值器，指定动画如何变化，跟PS里的动作有点类似：随便拿来一张图片，应用一个动作，图片就会指定变化。 Interpolator的系统值有下面几个： AccelerateDecelerateInterpolator //在动画开始与介绍的地方速率改变比较慢，在中间的时候加速 AccelerateInterpolator //在动画开始的地方速率改变比较慢，然后开始加速 AnticipateInterpolator //开始的时候向后然后向前甩 AnticipateOvershootInterpolator //开始的时候向后然后向前甩一定值后返回最后的值 BounceInterpolator //动画结束的时候弹起 CycleInterpolator //动画循环播放特定的次数，速率改变沿着正弦曲线 DecelerateInterpolator //在动画开始的地方快然后慢 LinearInterpolator //以常量速率改变 OvershootInterpolator //向前甩一定值后再回到原来位置 三、用代码实现Animation1.Animation类是所有动画的基类，它所具有的标签对应的函数： android:duration —— setDuration(long) //动画持续时间，以毫秒为单位 android:fillAfter —— setFillAfter(boolean) //如果设置为true，控件动画结束时，将保持动画最后时的状态 android:fillBefore —— setFillBefore(boolean) //如果设置为true,控件动画结束时，还原到开始动画前的状态 android:fillEnabled —— setFillEnabled(boolean) //与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态 android:repeatCount —— setRepeatCount(int) //重复次数 android:repeatMode —— setRepeatMode(int) //重复类型，有reverse和restart两个值，取值为RESTART或 REVERSE，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。 android:interpolator —— setInterpolator(Interpolator) //设定插值器，其实就是指定的动作效果，比如弹跳效果等 2.ScaleAnimation这是scale标签对应的类 构造函数： ScaleAnimation(Context context, AttributeSet attrs) //从XML文件加载动画，基本用不到 ScaleAnimation(float fromX, float toX, float fromY, float toY) ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY) ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 第一个构造函数是从本地XML文件加载动画，基本用不到的，我们主要看下面三个构造函数.在标签属性android:pivotX中有三种取值，数，百分数，百分数p；体现在构造函数中，就是最后一个构造函数的pivotXType,它的取值有三个，Animation.ABSOLUTE、Animation.RELATIVE_TO_SELF和Animation.RELATIVE_TO_PARENT； 示例：构造的XML代码： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:fromXScale="0.0" android:toXScale="1.4" android:fromYScale="0.0" android:toYScale="1.4" android:pivotX="50" android:pivotY="50" android:duration="700" /&gt; 对应的代码为： 12scaleAnim = new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f); scaleAnim.setDuration(700); 3. AlphaAnimation这是alpha标签对应的类 构造函数： AlphaAnimation(Context context, AttributeSet attrs) //同样，从本地XML加载动画，基本不用 AlphaAnimation(float fromAlpha, float toAlpha) 示例：构造的XML代码： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;alpha xmlns:android="http://schemas.android.com/apk/res/android" android:fromAlpha="1.0" android:toAlpha="0.1" android:duration="3000" android:fillBefore="true"&gt; &lt;/alpha&gt; 对应的代码为： 123alphaAnim = new AlphaAnimation(1.0f,0.1f); alphaAnim.setDuration(3000); alphaAnim.setFillBefore(true); 4. RotateAnimationRotateAnimation类对应Rotate标签 构造函数： RotateAnimation(Context context, AttributeSet attrs) //从本地XML文档加载动画，同样，基本不用 RotateAnimation(float fromDegrees, float toDegrees) RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY) RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) 示例：构造的XML代码： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;rotate xmlns:android="http://schemas.android.com/apk/res/android" android:fromDegrees="0" android:toDegrees="-650" android:pivotX="50%" android:pivotY="50%" android:duration="3000" android:fillAfter="true"&gt; &lt;/rotate&gt; 对应的代码为： 123rotateAnim = new RotateAnimation(0, -650, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); rotateAnim.setDuration(3000); rotateAnim.setFillAfter(true); 5. TranslateAnimationTranslateAnimation类对应translate标签 构造函数： TranslateAnimation(Context context, AttributeSet attrs) //同样，基本不用 TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) //使用是绝对数值 TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue) //最理想的状态就是这个构造函数，能够指定每个值的类型。只有这个构造函数可以指定百分数和相对父控件的百分数。 示例：构造的XML代码： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;translate xmlns:android="http://schemas.android.com/apk/res/android" android:fromXDelta="0" android:toXDelta="-80" android:fromYDelta="0" android:toYDelta="-80" android:duration="2000" android:fillBefore="true"&gt; &lt;/translate&gt; 对应的代码为： 1234translateAnim = new TranslateAnimation(Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80, Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80); translateAnim.setDuration(2000); translateAnim.setFillBefore(true); 6. AnimationSetAnimationSet类对应set标签，定义动作类的集合 构造函数： AnimationSet(Context context, AttributeSet attrs) //同样，基本不用 AnimationSet(boolean shareInterpolator) //shareInterpolator取值true或false，取true时，指在AnimationSet中定义一个插值器（interpolater），它下面的所有动画共同。如果设为false，则表示它下面的动画自己定义各自的插值器。 增加动画函数public void addAnimation (Animation a) 示例：构造的XML代码： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="3000" android:fillAfter="true"&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0"/&gt; &lt;scale android:fromXScale="0.0" android:toXScale="1.4" android:fromYScale="0.0" android:toYScale="1.4" android:pivotX="50%" android:pivotY="50%"/&gt; &lt;rotate android:fromDegrees="0" android:toDegrees="720" android:pivotX="50%" android:pivotY="50%"/&gt; &lt;/set&gt; 对应的代码为： 1234567891011alphaAnim = new AlphaAnimation(1.0f,0.1f); scaleAnim = new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f); rotateAnim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); setAnim=new AnimationSet(true); setAnim.addAnimation(alphaAnim); setAnim.addAnimation(scaleAnim); setAnim.addAnimation(rotateAnim); setAnim.setDuration(3000); setAnim.setFillAfter(true); 7. Interpolater插值器代码使用方法： 123ScaleAnimation interpolateScaleAnim=new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f); interpolateScaleAnim.setInterpolator(new BounceInterpolator()); interpolateScaleAnim.setDuration(3000); 四、ValueAnimator基本使用一、概述1、为什么要引入Property Animator(属性动画)1、Property Animator能实现补间动画无法实现的功能 补间动画和逐帧动画统称为View Animation，也就是说这两个动画只能对派生自View的控件 实例起作用；而Property Animator则不同，从名字中可以看出属性动画，应该是作用于控件 属性的！正因为属性动画能够只针对控件的某一个属性来做动画，所以也就造就了他能单独改变 控件的某一个属性的值！比如颜色！这就是Property Animator能实现补间动画无法实现的功 能的最重要原因。 2、View Animation仅能对指定的控件做动画，而Property Animator是通过改变控件某一 属性值来做动画的。 假设我们将一个按钮从左上角利用补间动画将其移动到右下角，在移动过程中和移动后，这个按钮 都是不会响应点击事件的。这是为什么呢？因为补间动画仅仅转变的是控件的显示位置而已，并没 有改变控件本身的值。View Animation的动画实现是通过其Parent View实现的，在View被 drawn时Parents View改变它的绘制参数，这样虽然View的大小或旋转角度等改变了，但View 的实际属性没变，所以有效区域还是应用动画之前的区域；我们看到的效果仅仅是系统作用在按钮 上的显示效果，利用动画把按钮从原来的位置移到了右下角，但按钮内部的任何值是没有变化的， 所以按钮所捕捉的点击区域仍是原来的点击区域。 3、补间动画虽能对控件做动画，但并没有改变控件内部的属性值。而Property Animator则是 恰恰相反，Property Animator是通过改变控件内部的属性值来达到动画效果的 二、ValueAnimator简单使用1、初步使用ValueAnimator创建ValueAnimator实例 123ValueAnimator animator = ValueAnimator.ofInt(0,400); animator.setDuration(1000); animator.start(); 利用ValueAnimator.ofInt创建了一个值从0到400的动画，动画时长是1s，然后让动画开始。从这段代码中可以看出，ValueAnimator没有跟任何的控件相关联，那也正好说明ValueAnimator只是对值做动画运算，而不是针对控件的，我们需要监听ValueAnimator的动画过程来自己对控件做操作。 添加监听 123456789101112ValueAnimator animator = ValueAnimator.ofInt(0,400); animator.setDuration(1000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int curValue = (int)animation.getAnimatedValue(); Log.d("qijian","curValue:"+curValue); tv.layout(curValue,curValue,curValue+tv.getWidth(),curValue+tv.getHeight()); &#125; &#125;); animator.start(); 这就是ValueAnimator的功能：ValueAnimator对指定值区间做动画运算，我们通过对运算过程做监听来自己操作控件。 总结 ValueAnimator只负责对指定的数字区间进行动画运算 我们需要对运算过程进行监听，然后自己对控件做动画操作 2、常用函数 ValueAnimator setDuration(long duration) //设置一次动画的时长，单位是毫秒 void start() //开始动画 Object getAnimatedValue(); //获取动画在当前运动点的值，所以这个对象只能用于在动画运动中。返回的值是Object,上面我们说过，通过getAnimatedValue()得到的值的实际类型与初始设置的值相同，如果我们利用ofInt（）设置的动画，那通过getAnimatedValue()得到的值为类型就是Int类型。如果我们利用ofFloat（）设置的动画，通过getAnimatedValue()得到的值类型就是Float类型。 void setRepeatCount(int value) //设置循环次数,设置为INFINITE表示无限循环 setRepeatMode(int value) //设置循环模式,value取值有RESTART，REVERSE cancel() //取消动画 3、监听器 AnimatorUpdateListener就是监听动画的实时变化状态，在onAnimationUpdate(ValueAnimator animation)中的animation表示当前状态动画的实例。添加AnimatorUpdateListener的方法是addUpdateListener(AnimatorListener listener)。 在AnimatorListener中，主要是监听Animation的四个状态，start、end、cancel、repeat；当动画开始时，会调用onAnimationStart(Animator animation)方法，当动画结束时调用onAnimationEnd(Animator animation)，当动画取消时，调用onAnimationCancel(Animator animation)函数，当动画重复时，会调用onAnimationRepeat(Animator animation)函数。添加AnimatorListener的方法是addListener(AnimatorListener listener)。 void removeUpdateListener(AnimatorUpdateListener listener); //移除AnimatorUpdateListener void removeAllUpdateListeners(); //移除AnimatorUpdateListener void removeListener(AnimatorListener listener); //用于在animator中移除指定的监听器 void removeAllListeners(); //用于移除animator中所有的AnimatorListener监听器 4、其他函数 public void setStartDelay(long startDelay); //延时多久时间开始，单位是毫秒 public ValueAnimator clone(); //完全克隆一个ValueAnimator实例，包括它所有的设置以及所有对监听器代码的处理 5、插值器控制动画的加速变化animator.setInterpolator(new BounceInterpolator()); //简单使用 6、自定义插值器123456789101112131415public class LinearInterpolator implements TimeInterpolator &#123; public LinearInterpolator() &#123; &#125; public LinearInterpolator(Context context, AttributeSet attrs) &#123; &#125; /** *主要重写该方法，对动画的进度从0到1进行调节 **/ public float getInterpolation(float input) &#123; return input; &#125;&#125; 7、Evaluator 这幅图讲述了从定义动画的数字区间到通过AnimatorUpdateListener中得到当前动画所对应数值的整个过程。下面我们对这四个步骤具体讲解一下：(1)、ofInt(0,400)表示指定动画的数字区间，是从0运动到400；(2)、加速器：上面我们讲了，在动画开始后，通过加速器会返回当前动画进度所对应的数字进度，但这个数字进度是百分制的，以小数表示，如0.2(3)、Evaluator:我们知道我们通过监听器拿到的是当前动画所对应的具体数值，而不是百分制的进度。那么就必须有一个地方会根据当前的数字进度，将其转化为对应的数值，这个地方就是Evaluator；Evaluator就是将从加速器返回的数字进度转成对应的数字值。所以上部分中，我们讲到的公式： 当前的值 = 100 + （400 - 100）* 显示进度这个公式就是在Evaluator计算的；在拿到当前数字进度所对应的值以后，将其返回（4）、监听器：我们通过在AnimatorUpdateListener监听器使用animation.getAnimatedValue()函数拿到Evaluator中返回的数字值。 ofInt和ofFloat都是系统直接提供的函数，所以在使用时都会有默认的加速器和Evaluator来使用的，不指定则使用默认的；对于Evaluator而言，ofInt()的默认Evaluator当然是IntEvaluator;而FloatEvalutar默认的则是FloatEvalutor; Evalutor一般来讲不能通用，会报强转错误，也就是说，只有在数值类型相同的情况下，Evalutor才能共用。Evaluator其实就是一个转换器，他能把小数进度转换成对应的数值位置 8、自定义Evaluator1234567public class MyEvaluator implements TypeEvaluator&lt;Integer&gt; &#123; @Override public Integer evaluate(float fraction, Integer startValue, Integer endValue) &#123; int startInt = startValue; return (int)(200+startInt + fraction * (endValue - startInt)); &#125;&#125; 我们可以通过重写加速器改变数值进度来改变数值位置，也可以通过改变Evaluator中进度所对应的数值来改变数值位置。 9、ArgbEvalutorArgbEvalutor是用来做颜色值过渡转换的。 123ValueAnimator animator = ValueAnimator.ofInt(0xffffff00,0xff0000ff);animator.setEvaluator(new ArgbEvaluator());animator.setDuration(3000); 10、ofInt(),ofFloat(),ofObject()ofInt()只能传入Integer类型的值,而ofFloat（）则只能传入Float类型的值,ofObject(),可以传进去任何类型的变量. ofObject()示例1、简单示例 123456789101112ValueAnimator animator = ValueAnimator.ofObject(new CharEvaluator(),new Character('A'),new Character('Z')); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; char text = (char)animation.getAnimatedValue(); tv.setText(String.valueOf(text)); &#125; &#125;); animator.setDuration(10000); animator.setInterpolator(new AccelerateInterpolator()); animator.start(); 2、自定义示例 在这里，我们自定义了一个View，在这个view上画一个圆，但这个圆是有动画效果的。从效果中可以看出使用的插值器应该是回弹插值器(BounceInterpolator)。下面就来看看这个动画是怎么做出来的。 首先，我们自定义一个类Point 123456789101112131415public class Point &#123; private int radius; public Point(int radius)&#123; this.radius = radius; &#125; public int getRadius() &#123; return radius; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; &#125; 然后我们自定义一个View:MyPointView 1234567891011121314151617181920212223242526272829303132public class MyPointView extends View &#123; private Point mCurPoint; public MyPointView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if (mCurPoint != null)&#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setColor(Color.RED); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(300,300,mCurPoint.getRadius(),paint); &#125; &#125; public void doPointAnim()&#123; ValueAnimator animator = ValueAnimator.ofObject(new PointEvaluator(),new Point(20),new Point(200)); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mCurPoint = (Point)animation.getAnimatedValue(); invalidate(); &#125; &#125;); animator.setDuration(1000); animator.setInterpolator(new BounceInterpolator()); animator.start(); &#125; &#125; 在布局中添加入自定义View，然后在主界面中调用 1234567891011121314151617181920public class MyActivity extends Activity &#123; private Button btnStart; private MyPointView mPointView; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); btnStart = (Button) findViewById(R.id.btn); mPointView = (MyPointView)findViewById(R.id.pointview); btnStart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mPointView.doPointAnim(); &#125; &#125;); &#125; &#125; 三、ObjectAnimator基础使用为了能让动画直接与对应控件相关联，以使我们从监听动画过程中解放出来，谷歌的开发人员在ValueAnimator的基础上，又派生了一个类ObjectAnimator; 由于ObjectAnimator是派生自ValueAnimator的，所以ValueAnimator中所能使用的方法，在ObjectAnimator中都可以正常使用。但ObjectAnimator也重写了几个方法，比如ofInt(),ofFloat()等。 改变透明度示例123ObjectAnimator animator = ObjectAnimator.ofFloat(tv,"alpha",1,0,1); animator.setDuration(2000);animator.start(); 构造函数public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) 第一个参数用于指定这个动画要操作的是哪个控件 第二个参数用于指定这个动画要操作这个控件的哪个属性(rotationX-围绕X轴，rotationY-围绕Y轴，rotation围绕Z轴，translationX-在X轴上水平移动，translationY-在Y轴上水平移动，scaleX-在X轴上缩放倍数，scaleY-在Y轴上缩放倍数) 第三个参数是可变长参数，这个就跟ValueAnimator中的可变长参数的意义一样了，就是指这个属性值是从哪变到哪 自定义ObjectAnimator属性1、保存圆形信息类——Point123456789101112131415public class Point &#123; private int mRadius; public Point(int radius)&#123; mRadius = radius; &#125; public int getRadius() &#123; return mRadius; &#125; public void setRadius(int radius) &#123; mRadius = radius; &#125; &#125; 2、自定义控件——MyPointView123456789101112131415161718192021222324public class MyPointView extends View &#123; private Point mPoint = new Point(100); public MyPointView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; if (mPoint != null)&#123; Paint paint = new Paint(); paint.setAntiAlias(true); paint.setColor(Color.RED); paint.setStyle(Paint.Style.FILL); canvas.drawCircle(300,300,mPoint.getRadius(),paint); &#125; super.onDraw(canvas); &#125; void setPointRadius(int radius)&#123; mPoint.setRadius(radius); invalidate(); &#125; &#125; 3、MyActivity1234567891011121314151617181920212223242526public class MyActivity extends Activity &#123; private Button btnStart; private MyPointView mPointView; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); btnStart = (Button) findViewById(R.id.btn); mPointView = (MyPointView)findViewById(R.id.pointview); btnStart.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doPointViewAnimation(); &#125; &#125;); &#125; private void doPointViewAnimation()&#123; ObjectAnimator animator = ObjectAnimator.ofInt(mPointView, "pointRadius", 0, 300, 100); animator.setDuration(2000); animator.start(); &#125;&#125; 五、PropertyValuesHolder与KeyframeValueAnimator和ObjectAnimator除了通过ofInt(),ofFloat(),ofObject()创建实例外，还都有一个ofPropertyValuesHolder()方法来创建实例。通常ValueAnimator使用ofPropertyValuesHolder()的机会不多，所以只讲ObjectAnimator中ofPropertyValuesHolder()的用法。对于ValueAnimator的ofPropertyValuesHolder()使用是差不多的。 1、PropertyValuesHolder1、概述PropertyValuesHolder这个类的意义就是，它其中保存了动画过程中所需要操作的属性和对应的值。我们通过ofFloat(Object target, String propertyName, float… values)构造的动画，ofFloat()的内部实现其实就是将传进来的参数封装成PropertyValuesHolder实例来保存动画状态。在封装成PropertyValuesHolder实例以后，后期的各种操作也是以PropertyValuesHolder为主的。 创建实例的函数1234public static PropertyValuesHolder ofFloat(String propertyName, float... values) public static PropertyValuesHolder ofInt(String propertyName, int... values) public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,Object... values) public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values) 这里总共有四个创建实例的方法，这一段我们着重讲ofFloat、ofInt和ofObject的用法，ofKeyframe我们单独讲。 2、PropertyValuesHolder之ofFloat()、ofInt()（1）ofFloat()、ofInt()构造函数 public static PropertyValuesHolder ofFloat(String propertyName, float... values) public static PropertyValuesHolder ofInt(String propertyName, int... values) propertyName：表示ObjectAnimator需要操作的属性名。即ObjectAnimator需要通过反射查找对应属性的setProperty()函数的那个property. values：属性所对应的参数，同样是可变长参数，可以指定多个，还记得我们在ObjectAnimator中讲过，如果只指定了一个，那么ObjectAnimator会通过查找getProperty()方法来获得初始值。 （2）、ObjectAnimator.ofPropertyValuesHolder()ObjectAnimator提供了一个设置PropertyValuesHolder实例的入口： public static ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values); target：指需要执行动画的控件 values：是一个可变长参数，可以传进去多个PropertyValuesHolder实例，由于每个PropertyValuesHolder实例都会针对一个属性做动画，所以如果传进去多个PropertyValuesHolder实例，将会对控件的多个属性同时做动画操作。 示例 123456PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat("Rotation", 60f, -60f, 40f, -40f, -20f, 20f, 10f, -10f, 0f); PropertyValuesHolder colorHolder = PropertyValuesHolder.ofInt("BackgroundColor", 0xffffffff, 0xffff00ff, 0xffffff00, 0xffffffff); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotationHolder, colorHolder); animator.setDuration(3000); animator.setInterpolator(new AccelerateInterpolator()); animator.start(); 3、PropertyValuesHolder之ofObject()ofObject的构造函数public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,Object... values); propertyName:ObjectAnimator动画操作的属性名; evaluator:Evaluator实例，Evaluator是将当前动画进度计算出当前值的类，可以使用系统自带的IntEvaluator、FloatEvaluator也可以自定义。 values：可变长参数，表示操作动画属性的值。 示例 通过自字义的CharEvaluator来自动实现字母的改变与计算。 首先是自定义一个CharEvaluator,通过进度值来自动计算出当前的字母: 12345678910public class CharEvaluator implements TypeEvaluator&lt;Character&gt; &#123; @Override public Character evaluate(float fraction, Character startValue, Character endValue) &#123; int startInt = (int)startValue; int endInt = (int)endValue; int curInt = (int)(startInt + fraction *(endInt - startInt)); char result = (char)curInt; return result; &#125; &#125; 从CharEvaluator中可以看出，从CharEvaluator中产出的动画中间值类型为Character类型。TextView中虽然有setText(CharSequence text) 函数，但这个函数的参数类型是CharSequence，而不是Character类型。所以我们要自定义一个类派生自TextView来改变TextView的字符 12345678public class MyTextView extends TextView &#123; public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public void setCharText(Character character)&#123; setText(String.valueOf(character)); &#125; &#125; 最后MyActivity,在点击按钮的时候开始动画，核心代码为: 123456789101112131415161718192021222324252627public class MyActivity extends Activity &#123; private Button btn; private TextView mTextView; private MyTextView mMyTv; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mMyTv = (MyTextView)findViewById(R.id.mytv); btn = (Button) findViewById(R.id.btn); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doOfObjectAnim(); &#125; &#125;); &#125; private void doOfObjectAnim()&#123; PropertyValuesHolder charHolder = PropertyValuesHolder.ofObject("CharText",new CharEvaluator(),new Character('A'),new Character('Z')); ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mMyTv, charHolder); animator.setDuration(3000); animator.setInterpolator(new AccelerateInterpolator()); animator.start(); &#125; &#125; 3、Keyframe1、概述—-我们知道如果要控制动画速率的变化，我们可以通过自定义插值器，也可以通过自定义Evaluator来实现。但如果真的让我们为了速率变化效果而自定义插值器或者Evaluator的话，恐怕大部分同学会有一万头草泥马在眼前奔过，因为大部分的同学的数学知识已经还给老师了。—-为了解决方便的控制动画速率的问题，谷歌为了我等屁民定义了一个KeyFrame的类，KeyFrame直译过来就是关键帧。—-关键帧这个概念是从动画里学来的，我们知道视频里，一秒要播放24帧图片，对于制作flash动画的同学来讲，是不是每一帧都要画出来呢？当然不是了，如果每一帧都画出来，那估计做出来一个动画片都得要一年时间；比如我们要让一个球在30秒时间内，从（0,0）点运动到（300，200）点，那flash是怎么来做的呢，在flash中，我们只需要定义两个关键帧，在动画开始时定义一个，把球的位置放在(0,0)点；在30秒后，再定义一个关键帧，把球的位置放在（300，200）点。在动画 开始时，球初始在是（0，0）点，30秒时间内就adobe flash就会自动填充，把球平滑移动到第二个关键帧的位置（300，200）点；—-通过上面分析flash动画的制作原理，我们知道，一个关键帧必须包含两个原素，第一时间点，第二位置。即这个关键帧是表示的是某个物体在哪个时间点应该在哪个位置上。—-所以谷歌的KeyFrame也不例外，KeyFrame的生成方式为： public static Keyframe ofFloat(float fraction, float value); fraction：表示当前的显示进度，即从加速器中getInterpolation()函数的返回值； value：表示当前应该在的位置 比如Keyframe.ofFloat(0, 0)表示动画进度为0时，动画所在的数值位置为0；Keyframe.ofFloat(0.25f, -20f)表示动画进度为25%时，动画所在的数值位置为-20；Keyframe.ofFloat(1f,0)表示动画结束时，动画所在的数值位置为0；在理解了KeyFrame.ofFloat()的参数以后，我们来看看PropertyValuesHolder是如何使用KeyFrame对象的： public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values); propertyName：动画所要操作的属性名 values：Keyframe的列表，PropertyValuesHolder会根据每个Keyframe的设定，定时将指定的值输出给动画。 完整的KeyFrame使用代码： 1234567Keyframe frame0 = Keyframe.ofFloat(0f, 0); Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f); Keyframe frame2 = Keyframe.ofFloat(1, 0); PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe("rotation",frame0,frame1,frame2); Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage,frameHolder); animator.setDuration(1000); animator.start(); 第一步：生成Keyframe对象；第二步：利用PropertyValuesHolder.ofKeyframe()生成PropertyValuesHolder对象第三步：ObjectAnimator.ofPropertyValuesHolder()生成对应的Animator 2、示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class MyActivity extends Activity &#123; private ImageView mImage; private Button mBtn; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mImage = (ImageView)findViewById(R.id.img); mBtn = (Button)findViewById(R.id.btn); mBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doOfFloatAnim(); &#125; &#125;); &#125; private void doOfFloatAnim()&#123; /** * 左右震动效果 */ Keyframe frame0 = Keyframe.ofFloat(0f, 0); Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f); Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f); Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f); Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f); Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f); Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f); Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f); Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f); Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f); Keyframe frame10 = Keyframe.ofFloat(1, 0); PropertyValuesHolder frameHolder1 = PropertyValuesHolder.ofKeyframe("rotation", frame0, frame1, frame2, frame3, frame4,frame5, frame6, frame7, frame8, frame9, frame10); /** * scaleX放大1.1倍 */ Keyframe scaleXframe0 = Keyframe.ofFloat(0f, 1); Keyframe scaleXframe1 = Keyframe.ofFloat(0.1f, 1.1f); Keyframe scaleXframe2 = Keyframe.ofFloat(0.2f, 1.1f); Keyframe scaleXframe3 = Keyframe.ofFloat(0.3f, 1.1f); Keyframe scaleXframe4 = Keyframe.ofFloat(0.4f, 1.1f); Keyframe scaleXframe5 = Keyframe.ofFloat(0.5f, 1.1f); Keyframe scaleXframe6 = Keyframe.ofFloat(0.6f, 1.1f); Keyframe scaleXframe7 = Keyframe.ofFloat(0.7f, 1.1f); Keyframe scaleXframe8 = Keyframe.ofFloat(0.8f, 1.1f); Keyframe scaleXframe9 = Keyframe.ofFloat(0.9f, 1.1f); Keyframe scaleXframe10 = Keyframe.ofFloat(1, 1); PropertyValuesHolder frameHolder2 = PropertyValuesHolder.ofKeyframe("ScaleX",scaleXframe0,scaleXframe1,scaleXframe2,scaleXframe3,scaleXframe4,scaleXframe5,scaleXframe6,scaleXframe7,scaleXframe8,scaleXframe9,scaleXframe10); /** * scaleY放大1.1倍 */ Keyframe scaleYframe0 = Keyframe.ofFloat(0f, 1); Keyframe scaleYframe1 = Keyframe.ofFloat(0.1f, 1.1f); Keyframe scaleYframe2 = Keyframe.ofFloat(0.2f, 1.1f); Keyframe scaleYframe3 = Keyframe.ofFloat(0.3f, 1.1f); Keyframe scaleYframe4 = Keyframe.ofFloat(0.4f, 1.1f); Keyframe scaleYframe5 = Keyframe.ofFloat(0.5f, 1.1f); Keyframe scaleYframe6 = Keyframe.ofFloat(0.6f, 1.1f); Keyframe scaleYframe7 = Keyframe.ofFloat(0.7f, 1.1f); Keyframe scaleYframe8 = Keyframe.ofFloat(0.8f, 1.1f); Keyframe scaleYframe9 = Keyframe.ofFloat(0.9f, 1.1f); Keyframe scaleYframe10 = Keyframe.ofFloat(1, 1); PropertyValuesHolder frameHolder3 = PropertyValuesHolder.ofKeyframe("ScaleY",scaleYframe0,scaleYframe1,scaleYframe2,scaleYframe3,scaleYframe4,scaleYframe5,scaleYframe6,scaleYframe7,scaleYframe8,scaleYframe9,scaleYframe10); /** * 构建动画 */ Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage, frameHolder1,frameHolder2,frameHolder3); animator.setDuration(1000); animator.start(); &#125; &#125; 3、常用函数123456789101112131415161718192021222324252627/** * ofFloat */ public static Keyframe ofFloat(float fraction) public static Keyframe ofFloat(float fraction, float value) /** * ofInt */ public static Keyframe ofInt(float fraction) public static Keyframe ofInt(float fraction, int value) /** * ofObject */ public static Keyframe ofObject(float fraction) public static Keyframe ofObject(float fraction, Object value) /** * 设置fraction参数，即Keyframe所对应的进度 */ public void setFraction(float fraction) /** * 设置当前Keyframe所对应的值 */ public void setValue(Object value) /** * 设置Keyframe动作期间所对应的插值器 */ public void setInterpolator(TimeInterpolator interpolator) PropertyValuesHolder之其它函数PropertyValuesHolder除了上面的讲到的ofInt,ofFloat,ofObject,ofKeyframe以外，api 11的还有几个函数：123456789101112131415161718192021222324/** * 设置动画的Evaluator */ public void setEvaluator(TypeEvaluator evaluator) /** * 用于设置ofFloat所对应的动画值列表 */ public void setFloatValues(float... values) /** * 用于设置ofInt所对应的动画值列表 */ public void setIntValues(int... values) /** * 用于设置ofKeyframe所对应的动画值列表 */ public void setKeyframes(Keyframe... values) /** * 用于设置ofObject所对应的动画值列表 */ public void setObjectValues(Object... values) /** * 设置动画属性名 */ public void setPropertyName(String propertyName) 六、联合动画的代码实现上几篇给大家分别讲了ValueAnimator和ObjectAnimator,相比而言ObjectAnimator更为方便而且由于set函数是在控件类内部实现，所以封装性更好。而且在现实使用中一般而言都是使用ObjectAnimator的机率比较大。但ValueAnimator和ObjectAnimator都只能单单实现一个动画，那如果我们想要使用一个组合动画，比如边放大，边移动，边改变alpha值，要怎么办。对于这种组合型的动画，谷歌给我们提供了一个类AnimatorSet;这篇我们就着重来看看组合动画的实现方法吧。 1、AnimatorSet——playSequentially,playTogether首先，AnimatorSet针对ValueAnimator和ObjectAnimator都是适用的，但一般而言，我们不会用到ValueAnimator的组合动画，所以我们这篇仅讲解ObjectAnimator下的组合动画实现。在AnimatorSet中直接给为我们提供了两个方法playSequentially和playTogether，playSequentially表示所有动画依次播放，playTogether表示所有动画一起开始。 1、playSequentiallypublic void playSequentially(Animator... items); public void playSequentially(List&lt;Animator&gt; items); 这里有两种声明，第一个是我们最常用的，它的参数是可变长参数，也就是说我们可以传进去任意多个Animator对象。这些对象的动画会逐个播放。第二个构造函数，是传进去一个List&lt; Animator&gt;的列表。原理一样，也是逐个去取List中的动画对象，然后逐个播放。但使用起来稍微麻烦一些。 示例12345678910111213141516171819202122232425262728293031public class MyActivity extends Activity &#123; private Button mButton; private TextView mTv1, mTv2; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mButton = (Button) findViewById(R.id.btn); mTv1 = (TextView) findViewById(R.id.tv_1); mTv2 = (TextView) findViewById(R.id.tv_2); mButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; doPlaySequentiallyAnimator(); &#125; &#125;); &#125; private void doPlaySequentiallyAnimator()&#123; ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, "BackgroundColor", 0xffff00ff, 0xffffff00, 0xffff00ff); ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, "translationY", 0, 300, 0); ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, "translationY", 0, 400, 0); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playSequentially(tv1BgAnimator,tv1TranslateY,tv2TranslateY); animatorSet.setDuration(1000); animatorSet.start(); &#125;&#125; 2、playTogetherpublic void playTogether(Animator... items); public void playTogether(Collection&lt;Animator&gt; items); 同样这里也是有两个构造函数，他们两个的意义是一样的，只是传入的参数不一样，第一个依然是传可变长参数列表，第二个则是需要传一个组装好的Collection对象。 示例12345678ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, "BackgroundColor", 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, "translationY", 0, 400, 0);ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, "translationY", 0, 400, 0);AnimatorSet animatorSet = new AnimatorSet();animatorSet.playTogether(tv1BgAnimator,tv1TranslateY,tv2TranslateY);animatorSet.setDuration(1000);animatorSet.start(); 自由设置动画顺序——AnimatorSet.Builder上面我们讲了playTogether和playSequentially，分别能实现一起开始动画和逐个开始动画。但并不是非常自由的组合动画，比如我们有三个动画A,B,C我们想先播放C然后同时播放A和B。利用playTogether和playSequentially是没办法实现的，所以为了更方便的组合动画，谷歌的开发人员另外给我们提供一个类AnimatorSet.Builder。 1、示例1234567ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, "BackgroundColor", 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, "translationY", 0, 400, 0);AnimatorSet animatorSet = new AnimatorSet();AnimatorSet.Builder builder = animatorSet.play(tv1BgAnimator);builder.with(tv1TranslateY);animatorSet.start(); 2、AnimatorSet.Builder函数1234567891011//调用AnimatorSet中的play方法是获取AnimatorSet.Builder对象的唯一途径//表示要播放哪个动画public Builder play(Animator anim)//和前面动画一起执行public Builder with(Animator anim)//执行前面的动画后才执行该动画public Builder before(Animator anim)//执行先执行这个动画再执行前面动画public Builder after(Animator anim)//延迟n毫秒之后执行动画public Builder after(long delay) 3、使用示例12345678ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, "BackgroundColor", 0xffff00ff, 0xffffff00, 0xffff00ff);ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, "translationY", 0, 400, 0);ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, "translationY", 0, 400, 0);AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(tv1TranslateY).with(tv2TranslateY).after(tv1BgAnimator);animatorSet.setDuration(2000);animatorSet.start(); AnimatorSet监听器 1、AnimatorSet的监听函数也只是用来监听AnimatorSet的状态的，与其中的动画无关； 2、AnimatorSet中没有设置循环的函数，所以AnimatorSet监听器中永远无法运行到onAnimationRepeat()中！ 通用函数逐个设置与AnimatorSet设置的区别123456//设置单次动画时长public AnimatorSet setDuration(long duration);//设置加速器public void setInterpolator(TimeInterpolator interpolator)//设置ObjectAnimator动画目标控件public void setTarget(Object target) 区别就是：在AnimatorSet中设置以后，会覆盖单个ObjectAnimator中的设置；即如果AnimatorSet中没有设置，那么就以ObjectAnimator中的设置为准。如果AnimatorSet中设置以后，ObjectAnimator中的设置就会无效。 七、联合动画的XML实现与使用示例1、联合动画的XML实现在xml中对应animator总共有三个标签，分别是 &lt;animator /&gt;:对应ValueAnimator &lt;objectAnimator /&gt;:对应ObjectAnimator &lt;set /&gt;:对应AnimatorSet 1、animator(1)下面是完整的animator所有的字段及取值范围：123456789&lt;animator android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"] android:interpolator=["@android:interpolator/XXX"]/&gt; android:duration:每次动画播放的时长 android:valueFrom:初始动化值；取值范围为float,int和color，如果取值为float对应的值样式应该为89.0，取值为Int时，对应的值样式为：89;当取值为clolor时，对应的值样式为 #333333; android:valueTo：动画结束值；取值范围同样是float,int和color这三种类型的值； android:startOffset：动画激活延时；对应代码中的startDelay(long delay)函数； android:repeatCount：动画重复次数 android:repeatMode：动画重复模式，取值为repeat和reverse；repeat表示正序重播，reverse表示倒序重播 android:valueType：表示参数值类型，取值为intType和floatType；与android:valueFrom、android:valueTo相对应。如果这里的取值为intType，那么android:valueFrom、android:valueTo的值也就要对应的是int类型的数值。如果这里的数值是floatType，那么android:valueFrom、android:valueTo的值也要对应的设置为float类型的值。非常注意的是，如果android:valueFrom、android:valueTo的值设置为color类型的值，那么不需要设置这个参数； android:interpolator:设置加速器；有关系统加速器所对应的xml值对照表如下： (2)将xml加载到程序中在定义了一个xml后，我们需要将其加载到程序中，使用的方法如下： ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(MyActivity.this,R.animator.animator); valueAnimator.start(); 2、objectAnimator(1)字段意义及使用方法12345678910&lt;objectAnimator android:propertyName="string" android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"] android:interpolator=["@android:interpolator/XXX"]/&gt; android:propertyName：对应属性名，即ObjectAnimator所需要操作的属性名。其它字段的意义与animator的意义与取值是一样的，下面再重新列举一下。 android:duration:每次动画播放的时长 android:valueFrom:初始动化值；取值范围为float,int和color； android:valueTo：动画结束值；取值范围同样是float,int和color这三种类型的值； android:startOffset：动画激活延时；对应代码中的startDelay(long delay)函数； android:repeatCount：动画重复次数 android:repeatMode：动画重复模式，取值为repeat和reverse；repeat表示正序重播，reverse表示倒序重播 android:valueType：表示参数值类型，取值为intType和floatType；与android:valueFrom、android:valueTo相对应。如果这里的取值为intType，那么android:valueFrom、android:valueTo的值也就要对应的是int类型的数值。如果这里的数值是floatType，那么android:valueFrom、android:valueTo的值也要对应的设置为float类型的值。非常注意的是，如果android:valueFrom、android:valueTo的值设置为color类型的值，那么不需要设置这个参数； android:interpolator:设置加速器。 (2)将xml加载到程序中ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator(MyActivity.this, R.animator.object_animator); animator.setTarget(mTv1); animator.start(); 3、set(1)字段意义及使用方法12&lt;set android:ordering=["together" | "sequentially"]&gt; android:ordering：表示动画开始顺序。together表示同时开始动画，sequentially表示逐个开始动画； (2)将xml加载到程序中AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(MyActivity.this, R.animator.set_animator); set.setTarget(mTv1); set.start(); 2、AnimatorSet应用应用AnimatorSet例子效果： 我们先来分析下这个效果，在用户点击按钮时，把菜单弹出来；弹出来的时候，动画一点从小变到大，一边透明度从0变到1.关键问题是，怎么样实现各个菜单以当前点击按钮为圆心排列在圆形上； 布局代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginBottom="10dp" android:layout_marginRight="10dp"&gt; &lt;Button android:id="@+id/menu" style="@style/MenuStyle" android:background="@drawable/menu"/&gt; &lt;Button android:id="@+id/item1" style="@style/MenuItemStyle" android:background="@drawable/circle1" android:visibility="gone"/&gt; &lt;Button android:id="@+id/item2" style="@style/MenuItemStyle" android:background="@drawable/circle2" android:visibility="gone"/&gt; &lt;Button android:id="@+id/item3" style="@style/MenuItemStyle" android:background="@drawable/circle3" android:visibility="gone"/&gt; &lt;Button android:id="@+id/item4" style="@style/MenuItemStyle" android:background="@drawable/circle4" android:visibility="gone"/&gt; &lt;Button android:id="@+id/item5" style="@style/MenuItemStyle" android:background="@drawable/circle5" android:visibility="gone"/&gt;&lt;/FrameLayout&gt; 其中的style代码为： 12345678910111213&lt;resources&gt; &lt;style name="MenuStyle"&gt; &lt;item name="android:layout_width"&gt;50dp&lt;/item&gt; &lt;item name="android:layout_height"&gt;50dp&lt;/item&gt; &lt;item name="android:layout_gravity"&gt;right|bottom&lt;/item&gt; &lt;/style&gt; &lt;style name="MenuItemStyle"&gt; &lt;item name="android:layout_width"&gt;45dp&lt;/item&gt; &lt;item name="android:layout_height"&gt;45dp&lt;/item&gt; &lt;item name="android:layout_gravity"&gt;right|bottom&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; MyActivity.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class MyActivity extends Activity implements View.OnClickListener&#123; private static final String TAG = "MainActivity"; private Button mMenuButton; private Button mItemButton1; private Button mItemButton2; private Button mItemButton3; private Button mItemButton4; private Button mItemButton5; private boolean mIsMenuOpen = false; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); initView(); &#125; private void initView() &#123; mMenuButton = (Button) findViewById(R.id.menu); mMenuButton.setOnClickListener(this); mItemButton1 = (Button) findViewById(R.id.item1); mItemButton1.setOnClickListener(this); mItemButton2 = (Button) findViewById(R.id.item2); mItemButton2.setOnClickListener(this); mItemButton3 = (Button) findViewById(R.id.item3); mItemButton3.setOnClickListener(this); mItemButton4 = (Button) findViewById(R.id.item4); mItemButton4.setOnClickListener(this); mItemButton5 = (Button) findViewById(R.id.item5); mItemButton5.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; if (v == mMenuButton) &#123; if (!mIsMenuOpen) &#123; mIsMenuOpen = true; doAnimateOpen(mItemButton1, 0, 5, 300); doAnimateOpen(mItemButton2, 1, 5, 300); doAnimateOpen(mItemButton3, 2, 5, 300); doAnimateOpen(mItemButton4, 3, 5, 300); doAnimateOpen(mItemButton5, 4, 5, 300); &#125; else &#123; mIsMenuOpen = false; doAnimateClose(mItemButton1, 0, 5, 300); doAnimateClose(mItemButton2, 1, 5, 300); doAnimateClose(mItemButton3, 2, 5, 300); doAnimateClose(mItemButton4, 3, 5, 300); doAnimateClose(mItemButton5, 4, 5, 300); &#125; &#125; else &#123; Toast.makeText(this, "你点击了" + v, Toast.LENGTH_SHORT).show(); &#125; &#125; private void doAnimateOpen(View view, int index, int total, int radius) &#123; if (view.getVisibility() != View.VISIBLE) &#123; view.setVisibility(View.VISIBLE); &#125; double degree = Math.toRadians(90)/(total - 1) * index; int translationX = -(int) (radius * Math.sin(degree)); int translationY = -(int) (radius * Math.cos(degree)); AnimatorSet set = new AnimatorSet(); //包含平移、缩放和透明度动画 set.playTogether( ObjectAnimator.ofFloat(view, "translationX", 0, translationX), ObjectAnimator.ofFloat(view, "translationY", 0, translationY), ObjectAnimator.ofFloat(view, "scaleX", 0f, 1f), ObjectAnimator.ofFloat(view, "scaleY", 0f, 1f), ObjectAnimator.ofFloat(view, "alpha", 0f, 1)); //动画周期为500ms set.setDuration(1 * 500).start(); &#125; private void doAnimateClose(final View view, int index, int total,int radius) &#123; if (view.getVisibility() != View.VISIBLE) &#123; view.setVisibility(View.VISIBLE); &#125; double degree = Math.PI * index / ((total - 1) * 2); int translationX = -(int) (radius * Math.sin(degree)); int translationY = -(int) (radius * Math.cos(degree)); AnimatorSet set = new AnimatorSet(); //包含平移、缩放和透明度动画 set.playTogether( ObjectAnimator.ofFloat(view, "translationX", translationX, 0), ObjectAnimator.ofFloat(view, "translationY", translationY, 0), ObjectAnimator.ofFloat(view, "scaleX", 1f, 0.1f), ObjectAnimator.ofFloat(view, "scaleY", 1f, 0.1f), ObjectAnimator.ofFloat(view, "alpha", 1f, 0f)); set.setDuration(1 * 500).start(); &#125;&#125; 一、LayoutAnimation的xml实现——layoutAnimation标签1、概述这部分，我们就来看看layoutAnimation标签的用法，要使用layoutAnimation只需要两步：第一：定义一个layoutAnimation的animation文件，如：(anim/layout_animation.xml) 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="1" android:animationOrder="normal" android:animation="@anim/slide_in_left"/&gt; 第二步：在viewGroup类型的控件中，添加Android:layoutAnimation=”@anim/layout_animation”，如：123456&lt;ListView android:id="@+id/listview" android:layout_width="match_parent" android:layout_height="match_parent" android:layoutAnimation="@anim/layout_animation" /&gt; 注意我们可以知道最重要的一点：android:layoutAnimation只在viewGroup创建的时候，才会对其中的item添加动画。在创建成功以后，再向其中添加item将不会再有动画。 2、layoutAnimation各字段意义12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="1" android:animationOrder="normal" android:animation="@anim/slide_in_left"/&gt; delay:指每个Item的动画开始延时，取值是android:animation所指定动画时长的倍数，取值类型可以是float类型，也可以是百分数，默认是0.5;比如我们这里指定的动画是@anim/slide_in_left，而在slide_in_left.xml中指定android:duration=”1000”，即单次动画的时长是1000毫秒，而我们在这里的指定android:delay=”1”，即一个Item的动画会在上一个item动画完成后延时单次动画时长的一倍时间开始，即延时1000毫秒后开始。 animationOrder:指viewGroup中的控件动画开始顺序，取值有normal(正序)、reverse(倒序)、random(随机) animation：指定每个item入场所要应用的动画。仅能指定res/aim文件夹下的animation定义的动画，不可使用animator动画。 二、LayoutAnimation的代码实现——LayoutAnimationController1、构造函数public LayoutAnimationController(Animation animation) public LayoutAnimationController(Animation animation, float delay) 2、基本函数123456789101112/** * 设置animation动画 */public void setAnimation(Animation animation)/** * 设置单个item开始动画延时 */public void setDelay(float delay)/** * 设置viewGroup中控件开始动画顺序，取值为ORDER_NORMAL、ORDER_REVERSE、ORDER_RANDOM */public void setOrder(int order) 3、示例同样以上面的例子为例，把xml实现改成代码实现。由于我们要代码实现layoutAnimation，所以我们不再需要写layoutAnimation的xml了，只需要一个动画的animation:(slide_in_left.xml) 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000"&gt; &lt;translate android:fromXDelta="-50%p" android:toXDelta="0"/&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0"/&gt;&lt;/set&gt; 然后是主布局（main.xml） 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/addlist" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="添加list数据"/&gt; &lt;ListView android:id="@+id/listview" android:layout_width="match_parent" android:layout_height="match_parent"/&gt;&lt;/LinearLayout&gt; 最后我们来看看代码(MyActivity.Java) 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyActivity extends Activity &#123; private ListView mListView; private ArrayAdapter mAdapter; private Button mAddListBtn; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mListView = (ListView) findViewById(R.id.listview); mAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1, getData()); mListView.setAdapter(mAdapter); mAddListBtn = (Button)findViewById(R.id.addlist); mAddListBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mAdapter.addAll(getData()); &#125; &#125;); //代码设置通过加载XML动画设置文件来创建一个Animation对象； Animation animation= AnimationUtils.loadAnimation(this,R.anim.slide_in_left); //得到一个LayoutAnimationController对象； LayoutAnimationController controller = new LayoutAnimationController(animation); //设置控件显示的顺序； controller.setOrder(LayoutAnimationController.ORDER_REVERSE); //设置控件显示间隔时间； controller.setDelay(0.3f); //为ListView设置LayoutAnimationController属性； mListView.setLayoutAnimation(controller); mListView.startLayoutAnimation(); &#125; private List&lt;String&gt; getData() &#123; List&lt;String&gt; data = new ArrayList&lt;String&gt;(); data.add("测试数据1"); data.add("测试数据2"); data.add("测试数据3"); data.add("测试数据4"); return data; &#125;&#125; 三、GridLayoutAnimation的XML实现——gridLayoutAnimation这部分将给大家讲解有关gridview给内部子控件添加创建动画的内容。 1、标签属性1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;gridLayoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:rowDelay="75%" android:columnDelay="60%" android:directionPriority="none" android:direction="bottom_to_top|right_to_left" android:animation="@android:anim/slide_in_left"/&gt; rowDelay:每一行动画开始的延迟。与LayoutAnimation一样，可以取百分数，也可以取浮点数。取值意义为，当前android:animation所指动画时长的倍数。 columnDelay：每一列动画开始的延迟。取值类型及意义与rowDelay相同。 directionPriority：方向优先级。取值为row,collumn,none，意义分别为：行优先，列优先，和无优先级（同时进行）;具体意义，后面会细讲 direction：gridview动画方向。取值有四个：left_to_right：列，从左向右开始动画right_to_left ：列，从右向左开始动画top_to_bottom：行，从上向下开始动画bottom_to_top：行，从下向上开始动画这四个值之间可以通过“|”连接，从而可以取多个值。很显然left_to_right和right_to_left是互斥的，top_to_bottom和bottom_to_top是互斥的。如果不指定 direction字段，默认值为left_to_right | top_to_bottom；即从上往下，从左往右。 animation: gridview内部元素所使用的动画。 2、示例(1)、首先是gride_animation.xml123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;gridLayoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:rowDelay="75%" android:columnDelay="60%" android:directionPriority="none" android:animation="@anim/slide_in_left"/&gt; 这里没有设置android:direction属性，采用默认值：left_to_right|top_to_bottom；然后是对应的animation动画slide_in_left.xml: 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000"&gt; &lt;translate android:fromXDelta="-50%p" android:toXDelta="0"/&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0" /&gt;&lt;/set&gt; (2)、程序布局main.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;Button android:id="@+id/add_data" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="添加grid数据"/&gt; &lt;GridView android:id="@+id/grid" android:layout_width="match_parent" android:layout_height="match_parent" android:columnWidth="60dp" android:gravity="center" android:horizontalSpacing="10dp" android:layoutAnimation="@anim/gride_animation" android:numColumns="auto_fit" android:stretchMode="columnWidth" android:verticalSpacing="10dp"/&gt;&lt;/LinearLayout&gt; (3)、代码处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class MyActivity extends Activity &#123; private GridAdapter mGrideAdapter; private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;(); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); /** * 填充gridview */ GridView grid = (GridView) findViewById(R.id.grid); mDatas.addAll(getData()); mGrideAdapter = new GridAdapter(); grid.setAdapter(mGrideAdapter); /** * 按钮点击响应 */ Button addData = (Button)findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; addData(); &#125; &#125;); &#125; private List&lt;String&gt; getData() &#123; List&lt;String&gt; data = new ArrayList&lt;String&gt;(); for (int i = 1;i&lt;35;i++)&#123; data.add("DATA "+i); &#125; return data; &#125; public void addData()&#123; mDatas.addAll(mDatas); mGrideAdapter.notifyDataSetChanged(); &#125; public class GridAdapter extends BaseAdapter &#123; public View getView(int position, View convertView, ViewGroup parent) &#123; TextView i = new TextView(MyActivity.this); i.setText(mDatas.get(position)); i.setLayoutParams(new GridView.LayoutParams(GridView.LayoutParams.WRAP_CONTENT, GridView.LayoutParams.WRAP_CONTENT)); return i; &#125; public final int getCount() &#123; return mDatas.size(); &#125; public final Object getItem(int position) &#123; return null; &#125; public final long getItemId(int position) &#123; return position; &#125; &#125;&#125; 四、GridLayoutAnimation的代码实现——GridLayoutAnimationController1、构造函数public GridLayoutAnimationController(Animation animation) public GridLayoutAnimationController(Animation animation, float columnDelay, float rowDelay) 2、其他方法12345678910111213141516/** * 设置列动画开始延迟 */public void setColumnDelay(float columnDelay)/** * 设置行动画开始延迟 */ public void setRowDelay(float rowDelay) /** * 设置gridview动画的入场方向。取值有：DIRECTION_BOTTOM_TO_TOP、DIRECTION_TOP_TO_BOTTOM、DIRECTION_LEFT_TO_RIGHT、DIRECTION_RIGHT_TO_LEFT */ public void setDirection(int direction) /** * 动画开始优先级，取值有PRIORITY_COLUMN、PRIORITY_NONE、PRIORITY_ROW */ public void setDirectionPriority(int directionPriority) 3、示例创建一个slide_in_left.xml文件 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000"&gt; &lt;translate android:fromXDelta="-50%p" android:toXDelta="0"/&gt; &lt;alpha android:fromAlpha="0.0" android:toAlpha="1.0" /&gt;&lt;/set&gt;``` 然后是布局文件main.xml:``` xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;GridView android:id="@+id/grid" android:layout_width="match_parent" android:layout_height="match_parent" android:columnWidth="60dp" android:gravity="center" android:horizontalSpacing="10dp" android:numColumns="auto_fit" android:stretchMode="columnWidth" android:verticalSpacing="10dp"/&gt;&lt;/LinearLayout&gt; 最后是MyActivity中的填充部分： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MyActivity extends Activity &#123; private GridAdapter mGrideAdapter; private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;(); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); /** * 填充gridview */ GridView grid = (GridView) findViewById(R.id.grid); mDatas.addAll(getData()); mGrideAdapter = new GridAdapter(); grid.setAdapter(mGrideAdapter); Animation animation = AnimationUtils.loadAnimation(MyActivity.this,R.anim.slide_in_left); GridLayoutAnimationController controller = new GridLayoutAnimationController(animation); controller.setColumnDelay(0.75f); controller.setRowDelay(0.5f); controller.setDirection(GridLayoutAnimationController.DIRECTION_BOTTOM_TO_TOP|GridLayoutAnimationController.DIRECTION_LEFT_TO_RIGHT); controller.setDirectionPriority(GridLayoutAnimationController.PRIORITY_NONE); grid.setLayoutAnimation(controller); grid.startLayoutAnimation(); &#125; private List&lt;String&gt; getData() &#123; List&lt;String&gt; data = new ArrayList&lt;String&gt;(); for (int i = 1;i&lt;35;i++)&#123; data.add("DATA "+i); &#125; return data; &#125; public void addData()&#123; mDatas.addAll(mDatas); mGrideAdapter.notifyDataSetChanged(); &#125; public class GridAdapter extends BaseAdapter &#123; public View getView(int position, View convertView, ViewGroup parent) &#123; TextView i = new TextView(MyActivity.this); i.setText(mDatas.get(position)); i.setLayoutParams(new GridView.LayoutParams(GridView.LayoutParams.WRAP_CONTENT, GridView.LayoutParams.WRAP_CONTENT)); return i; &#125; public final int getCount() &#123; return mDatas.size(); &#125; public final Object getItem(int position) &#123; return null; &#125; public final long getItemId(int position) &#123; return position; &#125; &#125;&#125; 八、animateLayoutChanges与LayoutTransition之前说的LayoutAnimation虽能实现ViewGroup的进入动画，但只能在创建时有效。在创建后，再往里添加控件就不会再有动画。在API 11后，又添加了两个能实现在创建后添加控件仍能应用动画的方法，分别是Android:animateLayoutChanges属性和LayoutTransition类。 一、android:animateLayoutChanges属性所有派生自ViewGroup的控件都具有此属性，只要在XML中添加上这个属性，就能实现添加/删除其中控件时，带有默认动画了。 1、简单示例1、main.xml布局代码123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:id="@+id/add_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="添加控件"/&gt; &lt;Button android:id="@+id/remove_btn" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="移除控件"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:id="@+id/layoutTransitionGroup" android:layout_width="match_parent" android:layout_height="wrap_content" android:animateLayoutChanges="true" android:orientation="vertical"/&gt; &lt;/LinearLayout&gt; 2、MyActivity代码123456789101112131415161718192021222324252627282930313233343536373839404142public class MyActivity extends Activity implements View.OnClickListener &#123; private LinearLayout layoutTransitionGroup; private int i = 0; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup); findViewById(R.id.add_btn).setOnClickListener(this); findViewById(R.id.remove_btn).setOnClickListener(this); &#125; private void addButtonView() &#123; i++; Button button = new Button(this); button.setText("button" + i); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); button.setLayoutParams(params); layoutTransitionGroup.addView(button, 0); &#125; private void removeButtonView() &#123; if (i &gt; 0) &#123; layoutTransitionGroup.removeViewAt(0); &#125; i--; &#125; @Override public void onClick(View v) &#123; if (v.getId() == R.id.add_btn) &#123; addButtonView(); &#125; if (v.getId() == R.id.remove_btn) &#123; removeButtonView(); &#125; &#125; &#125; 二、LayoutTransaction1、概述上面虽然在ViewGroup类控件XML中仅添加一行android:animateLayoutChanges=[true]即可实现内部控件添加删除时都加上动画效果。但却只能使用默认动画效果，而无法自定义动画。为了能让我们自定义动画，谷歌在API 11时，同时为我们引入了一个类LayoutTransaction。要使用LayoutTransaction是非常容易的，只需要三步： 第一步：创建实例LayoutTransaction transitioner = new LayoutTransition(); 第二步：创建动画并设置ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f); transitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut); 第三步：将LayoutTransaction设置进ViewGrouplinearLayout.setLayoutTransition(mTransitioner); 在第二步中，transitioner.setAnimator设置动画的函数声明为： public void setAnimator(int transitionType, Animator animator) 第一个参数int transitionType：表示当前应用动画的对象范围，取值有： APPEARING —— 元素在容器中出现时所定义的动画。 DISAPPEARING —— 元素在容器中消失时所定义的动画。 CHANGE_APPEARING —— 由于容器中要显现一个新的元素，其它需要变化的元素所应用的动画 CHANGE_DISAPPEARING —— 当容器中某个元素消失，其它需要变化的元素所应用的动画 2、LayoutTransition.CHANGE_APPEARING与LayoutTransition.CHANGE_DISAPPEARING在添加控件时，除了被添加控件本身的入场动画以外，其它需要移动位置的控件，在移动位置时，也被添加上了动画（left点位移动画），这些除了被添加控件以外的其它需要移动位置的控件组合，所对应的动画就是LayoutTransition.CHANGE_APPEARING同样，在移除一个控件时，因为移除了一个控件，而其它所有需要改变位置的控件组合所对应的动画就是LayoutTransition.CHANGE_DISAPPEARING LayoutTransition.CHANGE_APPEARING实现12345678910111213141516171819202122232425public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup); findViewById(R.id.add_btn).setOnClickListener(this); findViewById(R.id.remove_btn).setOnClickListener(this); mTransitioner = new LayoutTransition(); //入场动画:view在这个容器中消失时触发的动画 ObjectAnimator animIn = ObjectAnimator.ofFloat(null, "rotationY", 0f, 360f,0f); mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn); //出场动画:view显示时的动画 ObjectAnimator animOut = ObjectAnimator.ofFloat(null, "rotation", 0f, 90f, 0f); mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut); PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt("left",0,100,0); PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt("top",1,1); Animator changeAppearAnimator = ObjectAnimator.ofPropertyValuesHolder(layoutTransitionGroup, pvhLeft,pvhBottom,pvhTop,pvhRight); mTransitioner.setAnimator(LayoutTransition.CHANGE_APPEARING,changeAppearAnimator); layoutTransitionGroup.setLayoutTransition(mTransitioner); &#125; 注意 LayoutTransition.CHANGE_APPEARING和LayoutTransition.CHANGE_DISAPPEARING必须使用PropertyValuesHolder所构造的动画才会有效果，不然无效！也就是说使用ObjectAnimator构造的动画，在这里是不会有效果的！ 在构造PropertyValuesHolder动画时，”left”、”top”属性的变动是必写的。如果不需要变动，则直接写为： 在构造PropertyValuesHolder时，所使用的ofInt,ofFloat中的参数值，第一个值和最后一个值必须相同，不然此属性所对应的的动画将被放弃，在此属性值上将不会有效果； 在构造PropertyValuesHolder时，所使用的ofInt,ofFloat中，如果所有参数值都相同，也将不会有动画效果。 九、实现ListView Item进入动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class ListAdapter extends BaseAdapter &#123; private List&lt;Drawable&gt; mDrawableList = new ArrayList&lt;&gt;(); private int mLength = 0; private LayoutInflater mInflater; private Context mContext; private ListView mListView; private Animation animation; AbsListView.OnScrollListener mOnScrollListener = new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; View firstChild = view.getChildAt(0); if (firstChild == null) return; int top = firstChild.getTop(); /** * firstVisibleItem &gt; mFirstPosition表示向下滑动一整个Item * mFirstTop &gt; top表示在当前这个item中滑动 */ isScrollDown = firstVisibleItem &gt; mFirstPosition || mFirstTop &gt; top; mFirstTop = top; mFirstPosition = firstVisibleItem; &#125; &#125;; public ListAdapter(Context context, ListView listView, List&lt;Drawable&gt; drawables, int length) &#123; mDrawableList.addAll(drawables); mLength = length; mInflater = LayoutInflater.from(context); mContext = context; mListView = listView; animation = AnimationUtils.loadAnimation(mContext,R.anim.bottom_in_anim); &#125; @Override public int getCount() &#123; return mLength; &#125; @Override public Object getItem(int position) &#123; return mDrawableList.get(position % mDrawableList.size()); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null) &#123; holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.item_layout, null); holder.mImageView = (ImageView) convertView.findViewById(R.id.img); holder.mTextView = (TextView) convertView.findViewById(R.id.text); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; //清除当前显示区域中所有item的动画 for (int i=0;i&lt;mListView.getChildCount();i++)&#123; View view = mListView.getChildAt(i); view.clearAnimation(); &#125; if (isScrollDown) &#123; convertView.startAnimation(animation); &#125; convertView.setTag(holder); holder.mImageView.setImageDrawable(mDrawableList.get(position % mDrawableList.size())); holder.mTextView.setText(position+""); return convertView; &#125; public class ViewHolder &#123; public ImageView mImageView; public TextView mTextView; &#125; &#125; 摘记自Android自定义控件三部曲文章索引]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PopUpWindow使用详解]]></title>
      <url>%2F2015%2F11%2F10%2Fandroid-popupwindow%2F</url>
      <content type="text"><![CDATA[前言学习PopUpWindow，学习弹出窗口的使用，并且了解以及自定义PopUpWindow，以开发更好的应用。 1.PopupWindow与AlertDialog的区别最关键的区别是AlertDialog不能指定显示位置，只能默认显示在屏幕最中间（当然也可以通过设置WindowManager参数来改变位置）。而PopupWindow是可以指定显示位置的，随便哪个位置都可以，更加灵活。 2.PopupWindow的相关函数(1)构造函数public PopupWindow (Context context)//方法一public PopupWindow(View contentView)//方法二public PopupWindow(View contentView, int width, int height)//方法三public PopupWindow(View contentView, int width, int height, boolean focusable)//方法四生成PopupWindow的最基本的三个条件一定要设置View contentView,int width,int height，缺一不可。如果使用方法一构造依旧需要用setContentView(),setWidth(),setHeight()来对其进行设置。 (2)显示函数showAsDropDown(View anchor)：//相对某个控件的位置（正左下方），无偏移showAsDropDown(View anchor, int xoff, int yoff)：//相对某个控件的位置，有偏移;xoff表示x轴的偏移，正值表示向左，负值表示向右；yoff表示相对y轴的偏移，正值是向下，负值是向上showAtLocation(View parent, int gravity, int x, int y)：//相对于父控件的位置（例如正中央Gravity.CENTER，下方Gravity.BOTTOM等），可以设置偏移或无偏移 (3)其他函数public void dismiss()public void setFocusable(boolean focusable)public void setTouchable(boolean touchable)public void setOutsideTouchable(boolean touchable)public void setBackgroundDrawable(Drawable background) (4)PopupWindow设置动画mPopWindow.setAnimationStyle(R.style.contextMenuAnim);//设置动画所对应的style 3.解决问题(1)如何在弹出窗口时，使界面变暗。在PopupWindow的界面外包裹一层RelativeLayout，将RelativeLayout的界面铺满整个界面，使其颜色为半透明背景，将PopupWindow的视图设置其位置即可。 (2)如何点击空白处的时候让PopupWindow消失设置setBackgroundDrawable(new ColorDrawable(0x00000000));背景不为空但是完全透明。如此设置还能让PopupWindow在点击back的时候消失。 4.注意问题(1)注意最终显示效果为代码中设置的PopupWindow的宽高，而不是xml中视图的宽高。5.示例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity extends Activity &#123; private PopupWindow mPopupWindow; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); View popupView = getLayoutInflater().inflate(R.layout.layout_popupwindow, null); mPopupWindow = new PopupWindow(popupView, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT, true); mPopupWindow.setTouchable(true); mPopupWindow.setOutsideTouchable(true); mPopupWindow.setBackgroundDrawable(new BitmapDrawable(getResources(), (Bitmap) null)); mPopupWindow.getContentView().setFocusableInTouchMode(true); mPopupWindow.getContentView().setFocusable(true); mPopupWindow.getContentView().setOnKeyListener(new OnKeyListener() &#123; @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.getRepeatCount() == 0 &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123; if (mPopupWindow != null &amp;&amp; mPopupWindow.isShowing()) &#123; mPopupWindow.dismiss(); &#125; return true; &#125; return false; &#125; &#125;); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; event.getRepeatCount() == 0) &#123; if (mPopupWindow != null &amp;&amp; !mPopupWindow.isShowing()) &#123; mPopupWindow.showAtLocation(findViewById(R.id.layout_main), Gravity.BOTTOM, 0, 0); &#125; return true; &#125; return super.onKeyDown(keyCode, event); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android学习资料大全]]></title>
      <url>%2F2015%2F10%2F17%2Fandroid-study%2F</url>
      <content type="text"><![CDATA[前言学习Android光看书和看视频是不够的，需要实践和一些网络资料的收集，慢慢积累，才能提高自身水平。本文记录一些常常需要查看的Android学习网站和博客，不时翻阅一下，以提高自身水平。 教程 很好的中文教程 Google Android官方培训课程中文版 Google Android官方培训课程英文版 Android 开发列表 awesome-android github上的一个项目，收集了好多的Android开源项目 android-open-project 一个分类特别好的网站 Android Arsenal MaterialDesign资料整理 Awesome-MaterialDesign coursera-android 一个android教程类项目，8周完成结业。基本上囊括了android所有知识点，如果你想把android方面的知识系统地整理一遍，可以果断也把它fork下来，一个一个开始练习，总共有100多个例子。 50个Android开发技巧 Vector_Yi整理的Android开发技巧 android-best-practices android编程最佳实践 android-UniversalMusicPlayer google官方跨设备的例子，一款播放器，UI和交互都超级棒，而且同时支持手机、平板和Android Wear。 Android-Material-Example 另一个Android L学习的例子。 Material-Animations Material动画例子 工具 Android Button Maker Android Button Maker是一个可以在线生成按钮代码的工具。Android API提供了XML文件定义的几何形状的Drawable资源，包括颜色、边界和梯度。这些按钮的生成是基于drawable形态的XML代码，这样可以比普通的png按钮加载得更快。你可以在设置面板上自定义按钮的属性，然后获取其源码。 AndroidAssetStudio Asset Studio可以让你快速简单地从已经存在的图片、剪贴画或者文本资源中生成图标。这些图标可以应用在Launcher icons Action bar and tab iconsNotification icons Navigation drawer indicator** Generic icons ActionbarStyleGenerator 这个ActionBar风格生成器可以让你轻松地创建一个简洁、有吸引力且无漏洞的自定义actionbar。它会生成所有9种必须的patch assets以及相关XML的drawables和styles文件，这些文件可以直接复制到你的项目中。 AndroidHolo 这个Android Holo颜色生成器可以让你简单地为你的应用创建Android组件，如editext或者spinner，并且可以使用自己的颜色。它会生成所有9种必须的patch assets以及相关XML的drawables和styles文件，可以直接复制这些文件到你的项目中。 AndroidLayoutBinder Android Layout Binder会将你安卓的XML布局文件转换成一系列的声明，绑定保存所有的人工输入。键入一个前缀，选择XML文件上要粘贴的范围，然后点击生成。选择“verbose”来找出所有被跳过的区域的原因。 APKAnalyser 这是一个静态、虚拟分析工具，你可以全面地概览应用的架构。可以用它来检查API参考文档，查看应用依赖还有反编译字节码。APKAnalyser是一个完整的开源工具链，它支持修改应用的二进制代码，你可以重新打包、安装、运行以及验证logcat的结果。 maven-android-sdk-deployer 一个使用Maven Android Plugin插件安装Android SDK组件的工具 Material Palette调色板 Material Design出来一段时间了，身为Android开发人员想要自己适配一套Material Design，但是又苦于缺少设计方面的知识与理解，怎么办呢？这个网站就可以自动帮你生成调色板。 Android-Iconics 这是一个可以让你在你的项目中使用几乎任何字体图标的库。默认包含 FontAwesome 和 Material Design Icons 还包含 Meteocons 插件。你甚至可以添加任何你自定义的字体图标（typeface）。 android-actionbarstylegenerator action bar风格在线制作。UI组件 Google提供的750个Material Ddesign图标 Material Design资源 一大波优质的Material Design资源免费下载 Material UI Material UI 是一个 CSS 框架和一组实现谷歌 Material Design 设计规范的 React 组件。可以用在html5方式的APP中 android-ui Android UI库， Android L风格。 Android-LollipopShowcase Euclid 一个非常精美的用户信息页面的实现，动效很细腻。 android-typeface-helper typeface效果 android-flip 可以实现类似Flipboard一样的翻页效果。 android-viewbadger 为视图增加badger。可以做的更好看点。 AndroidViewAnimations 漂亮的视图动画。 JazzyViewPager 为ViewPager增加一条切换动画 labelview 贴纸效果。 AndroidTagGroup 一个漂亮的标签组控件。 AutoCompleteBubbleText 自动选择，可用于tag选择 BlurEffectForAndroidDesign 模糊效果的演示。 MaterialDesignLibrary 为Adnroid 2.2等低版本应用增加Android L 5.0风格的组件。 RippleEffect 涟漪效果 material-ripple 为view增加的Android L涟漪效果的包装类 HoloColorPicker Holo风格的颜色选择器。 Android-Action-Bar-Icons 图标资源 FancyCoverFlow MaterialViewPager ViewPager， Material Design风格 FlippableStackView 堆栈效果 HorizontalStackView 另一个横向堆栈效果 GiftCard-Android 礼品卡效果 cheesesquare Android 设计库的演示 Button android-floating-action-button Android L风格的浮动按钮， 红色小鲜肉。 Android-Bootstrap bootstrap风格的按钮。 使用Font Awesome图标字体。 android-bootstrap 不同于上面的Android-Bootstrap。 此项目是一个Android应用程序的模版， 相当于一个脚手架的功能。 android-process-button 很酷的一个组件，可以在按钮下部显示漂亮的进度条，就像GMAIL一样。 fab 一个支持很多自定义属性的Floating Action Button控件。 FloatingActionButton 模仿Android L的Floating Action Button (FAB)， 可以用在Jellybean 和 KitKat中 AndroidFloatLabel 浮动标签， 按需显示。 Android-UndoBar fab-toolbar Material Design风格的FAB工具栏效果 Menu ActionBarSherlock 一个功能强大的ActionBar组件(不仅仅是ActionBar)。 Android 4.0+上使用native action bar， 低版本的Android模拟实现。强大到无语了，必须关注的一个开源组件。 SlidingMenu一款优秀的侧滑菜单组件。 Google+, YouTube和Facebook在它们的应用中采用的侧滑菜单流行开来， 国内也有很多的应用如网易新闻等也采用了这种菜单方式。 侧滑菜单组件很好几种， 尤以此款最为好用。 看看官方网站上的知名用户就知道了。 android-menudrawer 又一个滑动菜单的组件。 android-undergarment 抽屉组件。集成这个组件非常简单 ,只要在activity的oncreate中加入mDrawerGarment = new DrawerGarment(this, R.layout.dashboard); DragLayout 使用support.v4包下的ViewDragHelper实现QQ5.0侧滑 android-satellite-menu 类似Path一样的菜单。 L-Navigation-Drawer 替换Android L的导航抽屉类。 也就是左边拖动菜单。 material-menu 模仿Android L的drawer, back, dismiss and check icons动画 ArcMenu 又一个类似Path的环形菜单。 Application richeditor-android 超酷的富文本编辑器 superCleanMaster 一键清理 开源版，包括内存加速，缓存清理，自启管理，软件管理等。 facebook-android-sdk Facebook提供的SDK， 可以在应用中集成Facebook. MaterialSettings 可以让你轻松创建Material Design风格的Settings Activity的库。 ZhihuPaper 个人开发的知乎日报客户端。 更纯净的知乎日报 chromeview Android webview组件的实现， 但是基于最新的Chromium 代码。 android-pdfview transparent-over-animtabsview 模仿网易云音乐 LetterImageView 类似Android的邮件应用， 用首字母作为图片。 chromium-webview-samples1 chromium-webview-samples2 chromium-webview-samples3 chromium-webview-samples4 chromium-webview-samples5 Pull-Down PullDownListView 仿微信首页的下拉效果，非常细腻。 Taurus 下拉刷新的动画好赞。 Android-PullToRefresh 你不陌生， 在列表或者视图的顶部或者底部拖动可以刷新数据和页面。可以和ListView、ExpandableListView、GridView、WebView、ScrollView、HorizontalScrollView、ViewPager配合使用。 android-PullRefreshLayout 下拉刷新布局， 比SwipeRefreshLayout更漂亮。 android-pulltorefresh 又一个拖动刷新的组件。到此为止说了好多又了。 因为有些功能确实有多个不错的实现。 Image SimpleTagImageView 一个可以在图片四个角显示一个小标签的ImageView，并且可以控制标签的宽度和背景颜色。 Android-Universal-Image-Loader 强大灵活的加载、缓存、显示图片的库。 picasso 强大的图像下载和缓存库。 PhotoView ImageView扩展， 支持放缩和手势。 ion 又一个图像异步加载库。至少推荐三个了， 轮子不少。关注度很高 Android-Ultra-Photo-Selector 一个图片选择器控件，支持选择多张图片、浏览设备上所有包含图片的文件夹、预览选择的图片并且支持缩放。 MultiImageSelector 国人开发的一个多图像选择组件 cropper 图像剪切和旋转。 android-gif-drawable android-crop 图像裁剪 EditText GridPasswordView 仿微信/支付宝的密码输入框效果。 Shimmer-android 闪烁发光的文本框。 android-edittext-validator 文本框校验 Desktop DevelopQuickSetting 一个快速开启关闭开发者设置的工具，提供了app界面和桌面widget，能快速打开关闭overdraw，layout border，gpu rendering，adb wifi，不保存activity实例等功能。需要root权限 Indicator Android-ViewPagerIndicator滑动页面几乎成了现在国内的应用的标配了，尤其在你第一次安装/启动应用时， 总会有几张介绍页面让你滑动显示。 用它吧，不会辜负你的。 SpringIndicator 模仿Morning Routine的引导页效果. Layout AndroidStaggeredGrid 想做瀑布流式的应用吗？用它吧。 cardslib 一种卡片式的布局控件。 记得以前的有道词典的默认页就是这种布局 LDrawer 使用material design动画的drawer图标 AndroidViewHover 一种优雅的显示上下文和菜单的库 FreeFlow comcast出品的一个布局引擎。 FreeFlow让你很容易的定制布局和漂亮的转换动画。 android-viewflow 可以水平滚动的视图。 StaggeredGridView 瀑布流。类似Pinterest。 KugouLayout 一个模仿酷狗播放器滑动返回的layout，可以让你的app有更丰富便捷的手势操作，支持activity滑动返回和普通layout的滑动显示/隐藏两种模式。 StickyGridHeaders 可以固定header和分区的Grid。 ArcLayout 超酷的弧形布局 AndroidSwipeLayout 功能强大的swipe布局。 android-sliding-layer-lib 滑动层框架， 支持左右滑动，全屏。 PinterestLikeAdapterView 瀑布流。 Chart WilliamChart 图表组件。 hellocharts-android 一个图表库， 带少量动画。 GraphView 可以产生放缩的线图和直方图。 MPAndroidChart 非常不错的图表工具。 AndroidCharts 图表控件 Android-Charts 国人实现的图表控件 desCharts 图表控件 XCL-Charts 国人出品， 图表控件，种类很多。 Listview ListViewAnimations为ListView增加动画， 还提供滑动删除选定项的功能。 类似Android的邮件的删除操作。 StickyListHeaders header可以固定的组件。 看下图。 drag-sort-listview 在ListItem拖动重排序。 FadingActionBar 折叠风格的ActionBar. Android-SlideExpandableListView 有一个可以滑动的ExpandableListView组件。 pinned-section-listview GroupName滑动到顶端时会固定不动直到另外一个GroupName到达顶端的ExpandListView PullZoomView 最近国内用的比较多的一个风格。 拖动时头部缩放。 Android-SwipeToDismiss 演示ListView滑动删除。 MultiChoiceAdapter ListView 支持多选。 PinnedHeaderExpandableListView 国人实现的一个ExpandableListView,头部可以固定， 并且可以伸缩。 PullToZoomInListView 滑动ListView时使其HeaderView跟随滑动缩放. FlyRefresh 创意Replace的Android实现，很cool. AnimateCheckBox 酷炫CheckBox Calendar Android-Week-View 日历组件。 android-times-square square出品的日期选择组件。 android-betterpickers 更好的时间、日期库。 material-calendarview DatePicker 中国人开发的日期选择器 Toast Crouton Toast之外的另以选择。 SuperToasts 扩展的Toast. Progress circular-progress-button 环形进度条按钮。 ProgressWheel 环形进度条。 dashed-circular-progress 圆形轨迹进度条控件。 NumberProgressBar 漂亮的带数字的进度条。 CircleProgress 圆圈进度条 ElasticDownload 酷炫进度条 Font Calligraphy 在Android中更容易的使用字体。 [android-iconify][UI-font 2] 集成FontAwesome 。 ActionBar GlassActionBar 毛玻璃效果的action bar. NotBoringActionBar 拖动时顶部可以收缩。 Dialog L-Dialogs 代替Android L的对话框 StandOut 很容易的创建弹出窗口。 类库 roboguice google guice框架在Android平台上的实现。 android-async-http 基于Apache http client实现的支持异步、回调的android http client组件。 androidannotations 将注解引入到Android开发中，极大的减少代码里，可以更好的维护代码。 retrofit 类型安全的Restful client库。 dagger 一个快速的依赖注入库。这个square公司出了不少的组件库。 square公司就是那个移动支付的创业公司。 okhttp 还是square出品， HTTP+SPDY 客户端。 EventBus 一个专为Android优化的发布订阅框架, event bus模式。 可以在Activity, Fragment 和后台线程之间交流数据。 butterknife 专为视图注入库。 robospice 一个模块化的Android类库， 可以更容易的编写异步的长时间运行的任务。 AndroidAsync 又是异步处理库， 支持socket,http (client+server),websocket 和socket.io ，基于nio。 ActiveAndroid active record风格的操作Android SQLite 数据库。 androidquery JQuery很熟悉吧。 这是Android版的JQuery。 greenDAO 一个轻量级的快速的ORM方案。 操作SQLite 数据库。 Bolts-Android 一套底层库。 scaloid 极大的减少Android得代码，更易维护。 conceal Facebook的快速加密类。 android-common 国人实现的一个工具包。 xUtils 国人实现的一个工具包。 android-priority-jobqueue Path出品的job queue。 android-sqlite-asset-helper 数据库辅助类。 包括数据库的创建与升级。 tape 一组queue类。 square出品。 spring-android joda-time-android 为Android做了优化 spydroid-ipcamera 将你的收集作为监控设备。 ACRA ACRA是一个可以让安卓应用自动发出GoogleDoc格式崩溃报告的函数库。安卓开发者可以通过ACRA获取应用崩溃或者错误行为的数据。如果有一个崩溃发生，你的应用不会越过已有的系统崩溃提醒或者报告功能来添加用户提醒。如果使用Toast、状态提醒条或者直接对话框模式，这个“强制关闭”的对话框不会再显示，就算设备上原生系统的提醒功能开启也不能发送一个另外的报告。 jpinyin JPinyin是一个汉字转拼音的Java开源类库，在PinYin4j的功能基础上做了一些改进。 Game Engine libgdx libGDX是基于OpenGL的跨平台的游戏开发框架。 AndEngine 知名的Android 2D OpenGL 游戏引擎。 ogengine 国人开发的国际著名开源引擎AndEngine的一个分支 （往上看）。遵循LGPL开源协议使用OpenGL ES进行图形绘制。同时集成了Box2D物理引擎，因此可以实现复杂的物理效果。 citrus 快速且轻量级的2D &amp; 3D游戏引擎。 Cocos2d-Android 知名的游戏引擎 gameclosure JavaScript 游戏引擎 游戏引擎列表 维基百科上的各种游戏引擎， 各种平台的引擎列表， 全。 Android HTML5应用 PhoneCap 早在2011年10月，Adobe收购了Nitobi Software和它的PhoneGap产品，然后宣布这个移动开发框架将会继续开源，并把它提交到Apache Incubator，以便完全接受ASF的管治。 Cordova Cordova是贡献给Apache后的开源项目，是从PhoneGap中抽出的核心代码，是驱动PhoneGap的核心引擎。你可以把他想象成类似于Webkit和Google Chrome的关系。Adobe将会继续以Cordova加上PhoneGap Build和Adobe Shadow的组合提供PhoneGap。 Cordova-SQLitePlugin awesome-cordova Cordova插件列表 ionic 基于Cordova的快速创建平台。 mui 国内厂商dcloud开源的一个高性能的html5框架。 lungo awesome-html5 Pixi.js MelonJS Crafty cutjs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Minecraft源码获取]]></title>
      <url>%2F2015%2F10%2F11%2Fget-minecraft-code%2F</url>
      <content type="text"><![CDATA[前言自从大三开始就喜欢上了Minecraft这个自由度极高的游戏，一直想了解他的实现，但苦于这方面资料一直不多。查了许多网站和贴吧，终于有结果了。发出来记录一下。 下载mcp9.31.zip MCP Mod Coder Pack官网 mcp9.31对应 Minecraft 1.10 解压缩，得到mcp930文件夹，打开docs文件夹，可以查看说明文档 打开README-MCP.TXT，可以找到安装步骤 下载Minecraft服务端程序,复制到mcp931/jars Minecraft_server.1.10.jar 开启正版Minecraft启动程序，下载Minecraft.1.10版本。将.minecraft 文件夹下的 “assets”, “libraries” and “versions”三个文件夹复制到mcp931/jars.(游戏必须启动过一次) 运行mcp931/decompile.sh，反编译游戏文件得到源代码（注意要有Python和Scala的运行环境） 使用Eclipse打开mcp931下的eclipse工作空间，就可以查看Minecraft的源代码了 recompile.sh–重新编译修改后的游戏 startclient.sh–执行客户端 startserver.sh–执行服务端 cleanup.sh–清理编译过的文件，方便重新编译]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[排序算法]]></title>
      <url>%2F2015%2F07%2F22%2Falgorithm-sort%2F</url>
      <content type="text"><![CDATA[前言 现在排序算法经过长时间的演变，发展处各种不同的排序算法。不得不说在日常开发以及日后的研究生活中还是比较常见以及使用的。再此对各种排序算法做一个记录，方便日后比较和查阅。 排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。 快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； 直接插入排序(插入排序) 介绍它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 步骤 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2 最优复杂度：当输入数组就是排好序的时候，复杂度为O(n)，而快速排序在这种情况下会产生O(n^2)的复杂度。 最差复杂度：当输入数组为倒序时，复杂度为O(n^2) 比较适合用于“少量元素的数组”。 代码 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;class Untitled &#123; public static void main(String[] args) &#123; Random ran = new Random(); int[] sort = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; sort[i] = ran.nextInt(50); &#125; System.out.println("排序前的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; System.out.println(); directInsertSort(sort); System.out.println("排序后的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; &#125; /** * 直接插入排序 * * @param sort */ private static void directInsertSort(int[] sort) &#123; for (int i = 1; i &lt; sort.length; i++) &#123; int index = i - 1; int temp = sort[i]; while (index &gt;= 0 &amp;&amp; sort[index] &gt; temp) &#123; sort[index + 1] = sort[index]; index--; &#125; sort[index + 1] = temp; &#125; &#125;&#125; 示例 希尔排序 介绍希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 步骤 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 示例 排序效果 冒泡排序 介绍冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码 1234567891011121314151617181920212223242526272829303132import java.util.*;class test1 &#123; public static void main(String[] args) &#123; Random ran = new Random(); int[] sort = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; sort[i] = ran.nextInt(50); &#125; System.out.println("排序前的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; System.out.println(); buddleSort(sort); System.out.println("排序后的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; &#125; public static void buddleSort(int[] sort)&#123; for (int i = 1;i &lt; sort.length;i++) &#123; for (int j = 0;j &lt; sort.length - i;j++) &#123; if (sort[j] &gt; sort[j+1]) &#123; int temp = sort[j]; sort[j] = sort[j + 1]; sort[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 示例 排序效果 选择排序 介绍选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。 步骤 从n个记录中找出关键码最小的记录与第一个记录交换； 从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换； 以此类推….. 第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换； 直到整个序列按关键码有序。 代码 123456789101112131415161718192021222324252627282930313233import java.util.*;class Untitled &#123; public static void main(String[] args) &#123; Random ran = new Random(); int[] sort = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; sort[i] = ran.nextInt(50); &#125; System.out.println("排序前的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; System.out.println(); selectSort(sort); System.out.println("排序后的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; &#125; public static void selectSort(int[] sort)&#123; for (int i = 0; i &lt; sort.length - 1;i++) &#123; for (int j = i + 1;j &lt; sort.length;j++) &#123; if (sort[j] &lt; sort[i]) &#123; int temp = sort[j]; sort[j] = sort[i]; sort[i] = temp; &#125; &#125; &#125; &#125;&#125; 示例 排序效果 快速排序 介绍快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。 步骤 从数列中挑出一个元素，称为 “基准”(pivot) 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.*;class Untitled &#123; public static void main(String[] args) &#123; Random ran = new Random(); int[] sort = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; sort[i] = ran.nextInt(50); &#125; System.out.println("排序前的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; System.out.println(); quickSort(sort, 0, sort.length - 1); System.out.println("排序后的数组为"); for (int i : sort) &#123; System.out.print(i + " "); &#125; &#125; public static void quickSort(int[] sort, int start, int end) &#123; // 设置关键数据key为要排序数组的第一个元素， // 即第一趟排序后，key右边的数全部比key大，key左边的数全部比key小 int key = sort[start]; // 设置数组左边的索引，往右移动判断比key大的数 int i = start; // 设置数组右边的索引，往左移动判断比key小的数 int j = end; // 如果左边索引比右边索引小，则还有数据没有排序 while (i &lt; j) &#123; while (sort[j] &gt; key &amp;&amp; j &gt; start) &#123; j--; &#125; while (sort[i] &lt; key &amp;&amp; i &lt; end) &#123; i++; &#125; if (i &lt; j) &#123; int temp = sort[i]; sort[i] = sort[j]; sort[j] = temp; &#125; &#125; // 如果左边索引比右边索引要大，说明第一次排序完成，将sort[j]与key对换 // 即保持了key左边的数比key小，key右边的数比key大 if (i &gt; j) &#123; int temp = sort[j]; sort[j] = sort[start]; sort[start] = temp; &#125; //递归调用 if (j &gt; start &amp;&amp; j &lt; end) &#123; quickSort(sort, start, j - 1); quickSort(sort, j + 1, end); &#125; &#125;&#125; 示例 一趟排序的过程 排序的全过程 排序效果 归并排序 介绍归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用 步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 示例 排序效果 堆排序 介绍堆积排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。 大顶堆序列：（96, 83,27,38,11,09) 小顶堆序列：（12，36，24，85，47，30，53，91）初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。 步骤 调整小顶堆的方法 设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶(最后一个元素与堆顶进行交换)，堆被破坏，其原因仅是根结点不满足堆的性质。 将根结点与左、右子树中较小元素的进行交换。 若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法(2). 若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法(2). 继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。 n个元素初始建堆的过程(建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。) n 个结点的完全二叉树，则最后一个结点是第个结点的子树。 筛选从第个结点为根的子树开始，该子树成为堆。 之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。 如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49） 排序效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取Sha1值]]></title>
      <url>%2F2015%2F07%2F10%2Fandroid-get-sha1%2F</url>
      <content type="text"><![CDATA[前言自从用了高德地图和百度地图的API，就一直被获取Sha1的值搞得烦不胜烦，总是忘记，花时间去到网上找方式。不过，经历了这么多次的摧残也熟了。记录一下，避免下次再忘记。 使用 keytool（jdk自带工具） 运行进入控制台。 在弹出的控制台窗口中定位到 .android 文件夹。 继续在控制台输入命令。 开发模式使用 debug.keystore，命令为：keytool -list -v -keystore debug.keystore 发布模式使用 apk 对应的 keystore，命令为：keytool -list -v -keystore apk的keystore 提示输入密钥库密码，开发模式默认密码是 android，发布模式的密码是为 apk 的 keystore 设置的密码。输入密钥后回车（如果没设置密码，可直接回车），此时可在控制台显示的信息中获取 Sha1 值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[布局的xml属性]]></title>
      <url>%2F2015%2F06%2F25%2Fandroid-layout%2F</url>
      <content type="text"><![CDATA[前言虽然布局已经用了蛮熟练的了，但还是记录一下自己的学习经历。并且避免日后遗忘，做个记录总是好的。 RelativeLayout 相对于给定ID控件android:layout_above 将该控件的底部置于给定ID的控件之上;android:layout_below 将该控件的底部置于给定ID的控件之下;android:layout_toLeftOf 将该控件的右边缘与给定ID的控件左边缘对 齐;android:layout_toRightOf 将该控件的左边缘与给定ID的控件右边缘对 齐;android:layout_alignBaseline 将该控件的baseline与给定ID的baseline对 齐;android:layout_alignTop 将该控件的顶部边缘与给定ID的顶部边缘对 齐;android:layout_alignBottom 将该控件的底部边缘与给定ID的底部边缘对 齐;android:layout_alignLeft 将该控件的左边缘与给定ID的左边缘对齐;android:layout_alignRight 将该控件的右边缘与给定ID的右边缘对齐; 相对于父组件android:layout_alignParentTop 如果为true,将该控件的顶部与其父控件的 顶部对齐;android:layout_alignParentBottom 如果为true,将该控件的底部与其父控件 的底部对齐;android:layout_alignParentLeft 如果为true,将该控件的左部与其父控件的 左部对齐;android:layout_alignParentRight 如果为true,将该控件的右部与其父控件 的右部对齐; 居中android:layout_centerHorizontal 如果为true,将该控件的置于水平居中;android:layout_centerVertical 如果为true,将该控件的置于垂直居中;android:layout_centerInParent 如果为true,将该控件的置于父控件的中央; 指定移动像素，值为pxandroid:layout_marginTop 上偏移的值;android:layout_marginBottom 下偏移的值;android:layout_marginLeft 左偏移的值;android:layout_marginRight 右偏移的值;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EditText]]></title>
      <url>%2F2015%2F06%2F21%2Fandroid-edittext%2F</url>
      <content type="text"><![CDATA[EditText控件的常用属性如下：android:hint=”请输入数字！”//设置显示在输入位置上的提示信息 android:numeric=”integer”//设置只能输入整数，如果是小数则是：decimal android:singleLine=”true”//设置单行输入，一旦设置为true，则文字不会自动换行。 android:password=”true”//设置只能输入密码 android:textColor = “#ff8c00”//设置字体颜色 android:textStyle=”bold”//设置字体类型，如加粗、斜体等 android:textSize=”20dip”//设置字体大小 android:textColorHighlight=”#cccccc”//设置被选中文字的底色，默认为蓝色 android:textColorHint=”#ffff00”//设置提示信息文字的颜色，默认为灰色 android:textScaleX=”1.5”//设置字与字之间的间距 android:typeface=”monospace”//设置字型，如normal, sans, serif, monospace android:background=”@null”//设置控件的背景，默认为灰色带边框的背景，@null指透明，且没有边框 android:layout_weight=”1”//设置控件所占的权重，控制控件之间的地位 android:textAppearance=”?android:attr/textAppearanceLargeInverse”//设置文字外观 android:layout_gravity=”center_vertical”//设置控件显示的位置：默认top，这里居中显示，还有bottom android:gravity=”top” //多行中指针在第一行位置，即顶部 android:capitalize //首字母大写 android：phoneNumber //输入电话号码 android：editable //是否可编辑 android:autoLink=”all” //设置文本超链接样式当点击网址时，跳向该网址，可选值(none/web/email/phone/map/all) android:autoText //如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。 android:bufferType //指定getText()方式取得的文本类别 android:cursorVisible //设定光标为显示/隐藏，默认显示。 android:digits //设置允许输入哪些字符。如“1234567890.+-*/% ()” android:editorExtras //设置文本的额外的输入数据 android:ellipsize //设置当文字过长时,该控件该如何显示。有如下值设置：”start”—?省略号显示在开头;”end”——省略号显示在结尾;”middle”—-省略号显示在中间;”marquee” ——以跑马灯的方式显示(动画横向移动) android:freezesText //设置保存文本的内容以及光标的位置 android:gravity //设置文本位置，如设置成“center”，文本将居中显示。 android:hintText //为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色 android:includeFontPadding //设置文本是否包含顶部和底部额外空白，默认为true。 android:linksClickable //设置链接是否点击连接，即使设置了autoLink。 android:marqueeRepeatLimit //在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。 android:ems //设置TextView的宽度为N个字符的宽度。 android:maxEms //设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:minEms //设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。 android:maxLength //限制显示的文本长度，超出部分不显示。 android:lines //设置文本的行数，设置两行就显示两行，即使第二行没有数据。 android:maxLines //设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。 android:minLines //设置文本的最小行数，与lines类似。 android:lineSpacingExtra 设置行间距。 android:lineSpacingMultiplier //设置行间距的倍数。如”1.2” android:password //以小点”.”显示文本 android:scrollHorizontally //设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:selectAllOnFocus //如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。 android:shadowColor //指定文本阴影的颜色，需要与shadowRadius一起使用。 android:shadowDx //设置阴影横向坐标开始位置。 android:shadowDy //设置阴影纵向坐标开始位置。 android:shadowRadius //设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好 android:height //设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米) android:maxHeight //设置文本区域的最大高度 android:minHeight //设置文本区域的最小高度 android:width //设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)，与layout_width的区别看这里。 android:maxWidth //设置文本区域的最大宽度 android:minWidth //设置文本区域的最小宽度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BitmapFactory]]></title>
      <url>%2F2015%2F06%2F20%2Fandroid-bitmapfactory%2F</url>
      <content type="text"><![CDATA[BitmapFactory.decodeResource(Resources res,int Id);//资源文件生成位图 Bitmap bmp = Bitmapfactory.decodeResource(this.getResources(),。drawable.icon); draBitmap(Bitmap bitmap,float left,float top,Paint paint); canvas.drawBitmap(bmp,0,0,paint); canvas.rotate(float degrees,float px,float py); canvas.save(); canvas.restore(); canvas.translate(float dx,float dy); canvas.scale(float sx,float sy,float px,float py); canvas.clipRect(int left,int top,int right,int bottom);//剪切区域 Region region = new Region(); region.op(new Rect(20,20,100,100),Region.Op.UNION); canvas.clipRegion(region);//设置可视区域 Region.Op.UNION:区域全部显示 Region.Op.INTERSECT:区域的交集显示 Region.Op.XOR:不显示交集区域]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android中的绘画]]></title>
      <url>%2F2015%2F06%2F20%2F2015-6-20-android-paint%2F</url>
      <content type="text"><![CDATA[CanvasdrawColor(int color); drawText(String text,float x,float y,Paint paint); drawPoint(float x,float y,Paint paint); drawPoints(float[] pts,Paint paint); drawLine(float startX,float startY,float stopX,float stopY,Paint paint); drawLines(float[] pts,Paint paint); drawRect(float left,float top,float right,float bottom,Paint paint); drawRect(Rect rect,Paint paint); drawRoundRect(RectF rect,float rx,float ry,Paint paint);//圆角矩形 drawCircle(float cx,float cy,float radius,Paint paint); drawArc(RectF oval,float startAngle,float sweepAngle,boolean useCenter,Paint paint);//绘制扇形(弧形) drawOval(RectF oval, Paint paint);//绘制椭圆 drawPath(Path path,Paint paint);//绘制指定路径图形 drawTextOnPath(String text,Path path,float hOffset,float vOffset,Paint paint);//将文本沿指定路径绘制 Rect(float left,float top,float right,float bottom);矩形类，左上角和右下角坐标； RectF同上; #PathmoveTo(float x,float y); lineTo(float x,float y); close();//起点和中点只有一个，lineTo可以有好多个； android.graphics.Path.quadTo(float x1,float y1,float x2,float y2);//绘制贝塞尔曲线 addArc(RectF oval,float startAngle,float sweepAngle); addOval(RectF oval, Direction dir); addCircle(float x,float y,float radius,Direction dir); addRect(RectF rect,Direction dir); addRoundRect(RectF rect,float[] radii,Direction dir); Canvas.setDrawFilter(DrawFilter filter);//设置绘图抗锯齿 #PaintsetAntiAlias(boolean aa);//设置画笔是否有锯齿，默认为false；true（无） setAlpha(int a);//设置画笔透明度 setTextAlign(Paint.Align align);//设置绘制文本的锚点 measureText(String text);//获取文本宽度 setStyle(Style style);//设置画笔样式 setColor(int Color);//设置画笔颜色 setStrokeWidth(float width);//设置画笔粗细程度 setTextSize(float textSize);//设置文本字体尺寸 setARGB(int a,int r,int g,int b);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android常用小记]]></title>
      <url>%2F2015%2F06%2F11%2Fandroid-note%2F</url>
      <content type="text"><![CDATA[前言Android中部分内容总是会忘记，但又是时常用到。老是百度、Google太浪费时间，所以记录下来方便日后查看。 隐去标题栏(应用名称)this.requestWindowFeature(Window.FEATURE_NO_TITLE);或者在AndroidManifest.xml修改android:theme =&quot;@android:style/Theme.NoTitleBar&quot; 隐去状态栏部分（电池图标和一切修饰部分）this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);或者在AndroidManifest.xml中修改android:theme =&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot; android:largeHeap=&quot;true&quot;增大应用申请的内存 android:persistent=&quot;true&quot;将应用定义为永久性应用 android:supportsRtl=&quot;true&quot;应用布局支持从右向左 FLAG_ACTIVITY_BROUGHT_TO_FRONTFLAG_ACTIVITY_BROUGHT_TO_FRONT通过Intent调用会把当前activity放在栈顶。比如说我现在有A，在A中启动B，此时在Ａ中Intent中加上这个标记。此时B就是以FLAG_ACTIVITY_BROUGHT_TO_FRONT方式启动，此时在B中再启动C，D（正常启动C,D），如果这个时候在D中再启动B，这个时候最后的栈的情况是 A,C,D,B。如果在A,B,C,D正常启动的话，不管B有没有用FLAG_ACTIVITY_BROUGHT_TO_FRONT启动，此时在D中启动B的话，还是会变成A,C,D,B的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android数据存储]]></title>
      <url>%2F2015%2F06%2F05%2Fdata-save%2F</url>
      <content type="text"><![CDATA[前言Android需要存储本地数据的地方有好多，但是采用什么方式进行存储比较好，就是我们需要考虑的了。Android给我们提供了四种数据存储的方式，来好好学习下。 SharedPreference适用于简单数据的保存，属于配置性质的保存，不适合数据比较大的情况； FileInputStream/FileOutputStream适用于游戏的保存和使用，可以保存较大的数据，不仅能保存在内存中，还能保存在SDcard SQLite也适合游戏的保存和使用，不仅可以保存较大的数据，而且可以将自己的数据存储在文件系统或者数据库当中； ContentProvider应用间数据进行交换 SharedPreferenceContext.getSharePreferences(String name,int mode)–获取SharedPreference 实例； 操作模式Context.MODE_PRIVATE;//新内容覆盖原内容Context.MODE_APPEND;//新内容追加到原内容后Context.MODE_WORLD_READABLE;//允许其他应用程序读取Context.MODE_WORLD_WRITEABLE;//允许其他应用程序写入，会覆盖原数据 常用函数getFloat(String key,float defValue);getIn(String key,int defValue);getLong(String key,long defValue);getString(String key,String defValue);getBoolean(String key,boolean defValue); 获取编辑对象SharePreferences.Editor edit();//实例化编辑对象SharePreferences.Editor.putFloat (arg0,arg1);SharePreferences.Editor.putInt (arg0,arg1);SharePreferences.Editor.putLong (arg0,arg1);SharePreferences.Editor.putString (arg0,arg1);SharePreferences.Editor.putBoolean (arg0,arg1);SharePreferences.Editor.commit();//存入数据SharePreferences.Editor.clear();//清除数据]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL数据类型]]></title>
      <url>%2F2015%2F05%2F27%2Fsql-data-type%2F</url>
      <content type="text"><![CDATA[前言最近学习SQL，掌握其中的数据类型还是很重要的。上课上过SQL Server，Oracle。自己学了MySQL和SQLite，语法和数据类型基本想通，只不过查询方式和操作有很大的区别。大的功能不说，以MySQL为例记录一下数据类型。 整数数据类型TINYINT、BIT、BOOL————1SMALLINT—————————2MEDIUMINT—————————3INT—————————————4BIGINT———————————8 浮点型数据类型FLOATDOUBLEDECIMAL 常规字符串类型[national]char(M)[binary|ASCII|unicode]char[national]varchar(M)[binary] TEXT和BLOB类型TINYBLOB、TINYTEXTBLOB、TEXTMEDIUMBLOB、MEDIUMTEXTLONGBLOB、LONGTEXT ENUM和SET类型Enum(“value1”,”value2”,………)Set(“value1”,”value2”,………) 日期和时间数据类型DATE 日期，格式YYYY-MM-DDTIME 时间，格式HH：MM：SSDATETIME 日期和时间，格式YYYY-MM-DD HH：MM：SSTIMESTAMP 时间标签，在处理报告时使用显示格式取决于M的值YEAR 年份可指定两位数字和四位数字的格式 在创建表时，使用哪种数字类型应遵循以下原则：（1）选择最小的可用类型，如果数值永远不超过127，则使用TINYINT比使用INT强。（2）对于完全都是数字的，可以选择整数类型。（3）浮点型用于可能具有小数部分的数，例如货物单价、网上购物交付金额等。 在创建表和使用字符串类型时应遵循以下原则：（1）从速度方面考虑，要选择固定的列，可以使用CHAR类型。（2）要节省空间，使用动态的列，可以使用VARCHAR类型。（3）要将列中的内容限制在一种选择，可以使用ENUM类型。（4）允许在一个列中又多于一个的条目，可以使用SET类型。（5）如果要搜索的内容不区分大小写，可以使用TEXT类型。（6）如果要搜索的内容需要区分大小写，可以使用BLOB类型。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用color]]></title>
      <url>%2F2015%2F05%2F19%2Fcolor%2F</url>
      <content type="text"><![CDATA[前言因为有许多颜色是常用的，避免以后查找，记录在这里进行比对 &lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt;&lt;!--白色 --&gt; 白色 &lt;color name=&quot;ivory&quot;&gt;#FFFFF0&lt;/color&gt;&lt;!--象牙色 --&gt; 象牙色 &lt;color name=&quot;lightyellow&quot;&gt;#FFFFE0&lt;/color&gt;&lt;!--亮黄色--&gt; 亮黄色 &lt;color name=&quot;yellow&quot;&gt;#FFFF00&lt;/color&gt;&lt;!--黄色 --&gt; 黄色 &lt;color name=&quot;snow&quot;&gt;#FFFAFA&lt;/color&gt;&lt;!--雪白色 --&gt; 雪白色 &lt;color name=&quot;floralwhite&quot;&gt;#FFFAF0&lt;/color&gt;&lt;!--花白色 --&gt; 花白色 &lt;color name=&quot;lemonchiffon&quot;&gt;#FFFACD&lt;/color&gt;&lt;!--柠檬绸色 --&gt;柠檬绸色&lt;color name=&quot;cornsilk&quot;&gt;#FFF8DC&lt;/color&gt;&lt;!--米绸色 --&gt; 米绸色 &lt;color name=&quot;seashell&quot;&gt;#FFF5EE&lt;/color&gt;&lt;!--海贝色 --&gt; 海贝色 &lt;color name=&quot;lavenderblush&quot;&gt;#FFF0F5&lt;/color&gt;&lt;!--淡紫红 --&gt; 淡紫红 &lt;color name=&quot;papayawhip&quot;&gt;#FFEFD5&lt;/color&gt;&lt;!--番木色 --&gt; 番木色 &lt;color name=&quot;blanchedalmond&quot;&gt;#FFEBCD&lt;/color&gt;&lt;!--白杏色 --&gt; 白杏色 &lt;color name=&quot;mistyrose&quot;&gt;#FFE4E1&lt;/color&gt;&lt;!--浅玫瑰色 --&gt; 浅玫瑰色 &lt;color name=&quot;bisque&quot;&gt;#FFE4C4&lt;/color&gt;&lt;!--桔黄色 --&gt; 桔黄色 &lt;color name=&quot;moccasin&quot;&gt;#FFE4B5&lt;/color&gt;&lt;!--鹿皮色 --&gt; 鹿皮色 &lt;color name=&quot;navajowhite&quot;&gt;#FFDEAD&lt;/color&gt;&lt;!--纳瓦白 --&gt; 纳瓦白 &lt;color name=&quot;peachpuff&quot;&gt;#FFDAB9&lt;/color&gt;&lt;!--桃色 --&gt; 桃色 &lt;color name=&quot;gold&quot;&gt;#FFD700&lt;/color&gt;&lt;!--金色 --&gt; 金色 &lt;color name=&quot;pink&quot;&gt;#FFC0CB&lt;/color&gt;&lt;!--粉红色 --&gt; 粉红色 &lt;color name=&quot;lightpink&quot;&gt;#FFB6C1&lt;/color&gt;&lt;!--亮粉红色--&gt; 亮粉红色 &lt;color name=&quot;orange&quot;&gt;#FFA500&lt;/color&gt;&lt;!--橙色 --&gt; 橙色 &lt;color name=&quot;lightsalmon&quot;&gt;#FFA07A&lt;/color&gt;&lt;!--亮肉色 --&gt; 亮肉色 &lt;color name=&quot;darkorange&quot;&gt;#FF8C00&lt;/color&gt;&lt;!--暗桔黄色 --&gt; 暗桔黄色 &lt;color name=&quot;coral&quot;&gt;#FF7F50&lt;/color&gt;&lt;!--珊瑚色 --&gt; 珊瑚色 &lt;color name=&quot;hotpink&quot;&gt;#FF69B4&lt;/color&gt;&lt;!--热粉红色 --&gt; 热粉红色 &lt;color name=&quot;tomato&quot;&gt;#FF6347&lt;/color&gt;&lt;!--西红柿色 --&gt; 西红柿色 &lt;color name=&quot;orangered&quot;&gt;#FF4500&lt;/color&gt;&lt;!--红橙色 --&gt; 红橙色 &lt;color name=&quot;deeppink&quot;&gt;#FF1493&lt;/color&gt;&lt;!--深粉红色 --&gt; 深粉红色 &lt;color name=&quot;fuchsia&quot;&gt;#FF00FF&lt;/color&gt;&lt;!--紫红色 --&gt; 紫红色 &lt;color name=&quot;magenta&quot;&gt;#FF00FF&lt;/color&gt;&lt;!--红紫色 --&gt; 红紫色 &lt;color name=&quot;red&quot;&gt;#FF0000&lt;/color&gt;&lt;!--红色 --&gt; 红色 &lt;color name=&quot;oldlace&quot;&gt;#FDF5E6&lt;/color&gt;&lt;!--老花色 --&gt; 老花色 &lt;color name=&quot;lightgoldenrodyellow&quot;&gt;#FAFAD2&lt;/color&gt;&lt;!--亮金黄色 --&gt; 亮金黄 &lt;color name=&quot;linen&quot;&gt;#FAF0E6&lt;/color&gt;&lt;!--亚麻色 --&gt; 亚麻色 &lt;color name=&quot;antiquewhite&quot;&gt;#FAEBD7&lt;/color&gt;&lt;!--古董白 --&gt; 古董白 &lt;color name=&quot;salmon&quot;&gt;#FA8072&lt;/color&gt;&lt;!--鲜肉色 --&gt; 鲜肉色 &lt;color name=&quot;ghostwhite&quot;&gt;#F8F8FF&lt;/color&gt;&lt;!--幽灵白 --&gt; 幽灵白 &lt;color name=&quot;mintcream&quot;&gt;#F5FFFA&lt;/color&gt;&lt;!--薄荷色 --&gt; 薄荷色 &lt;color name=&quot;whitesmoke&quot;&gt;#F5F5F5&lt;/color&gt;&lt;!--烟白色 --&gt; 烟白色 &lt;color name=&quot;beige&quot;&gt;#F5F5DC&lt;/color&gt;&lt;!--米色 --&gt; 米色 &lt;color name=&quot;wheat&quot;&gt;#F5DEB3&lt;/color&gt;&lt;!--浅黄色 --&gt; 浅黄色 &lt;color name=&quot;sandybrown&quot;&gt;#F4A460&lt;/color&gt;&lt;!--沙褐色--&gt; 沙褐色 &lt;color name=&quot;azure&quot;&gt;#F0FFFF&lt;/color&gt;&lt;!--天蓝色 --&gt; 天蓝色 &lt;color name=&quot;honeydew&quot;&gt;#F0FFF0&lt;/color&gt;&lt;!--蜜色 --&gt; 蜜色 &lt;color name=&quot;aliceblue&quot;&gt;#F0F8FF&lt;/color&gt;&lt;!--艾利斯兰 --&gt; 艾利斯兰 &lt;color name=&quot;khaki&quot;&gt;#F0E68C&lt;/color&gt;&lt;!--黄褐色 --&gt; 黄褐色 &lt;color name=&quot;lightcoral&quot;&gt;#F08080&lt;/color&gt;&lt;!--亮珊瑚色 --&gt; 亮珊瑚色 &lt;color name=&quot;palegoldenrod&quot;&gt;#EEE8AA&lt;/color&gt;&lt;!--苍麒麟色 --&gt; 苍麒麟色 &lt;color name=&quot;violet&quot;&gt;#EE82EE&lt;/color&gt;&lt;!--紫罗兰色 --&gt; 紫罗兰色 &lt;color name=&quot;darksalmon&quot;&gt;#E9967A&lt;/color&gt;&lt;!--暗肉色 --&gt; 暗肉色 &lt;color name=&quot;lavender&quot;&gt;#E6E6FA&lt;/color&gt;&lt;!--淡紫色 --&gt; 淡紫色 &lt;color name=&quot;lightcyan&quot;&gt;#E0FFFF&lt;/color&gt;&lt;!--亮青色 --&gt; 亮青色 &lt;color name=&quot;burlywood&quot;&gt;#DEB887&lt;/color&gt;&lt;!--实木色 --&gt; 实木色 &lt;color name=&quot;plum&quot;&gt;#DDA0DD&lt;/color&gt;&lt;!--洋李色 --&gt; 洋李色 &lt;color name=&quot;gainsboro&quot;&gt;#DCDCDC&lt;/color&gt;&lt;!--淡灰色 --&gt; 淡灰色 &lt;color name=&quot;crimson&quot;&gt;#DC143C&lt;/color&gt;&lt;!--暗深红色 --&gt; 暗深红色 &lt;color name=&quot;palevioletred&quot;&gt;#DB7093&lt;/color&gt;&lt;!--苍紫罗兰色 --&gt; 苍紫罗兰色 &lt;color name=&quot;goldenrod&quot;&gt;#DAA520&lt;/color&gt;&lt;!--金麒麟色 --&gt; 金麒麟色 &lt;color name=&quot;orchid&quot;&gt;#DA70D6&lt;/color&gt;&lt;!--淡紫色 --&gt; 淡紫色 &lt;color name=&quot;thistle&quot;&gt;#D8BFD8&lt;/color&gt;&lt;!--蓟色 --&gt; 蓟色 &lt;color name=&quot;lightgray&quot;&gt;#D3D3D3&lt;/color&gt;&lt;!--亮灰色 --&gt; 亮灰色 &lt;color name=&quot;tan&quot;&gt;#D2B48C&lt;/color&gt;&lt;!--茶色 --&gt; 茶色 &lt;color name=&quot;chocolate&quot;&gt;#D2691E&lt;/color&gt;&lt;!--巧可力色 --&gt; 巧可力色 &lt;color name=&quot;peru&quot;&gt;#CD853F&lt;/color&gt;&lt;!--秘鲁色 --&gt; 秘鲁色 &lt;color name=&quot;indianred&quot;&gt;#CD5C5C&lt;/color&gt;&lt;!--印第安红 --&gt; 印第安红 &lt;color name=&quot;mediumvioletred&quot;&gt;#C71585&lt;/color&gt;&lt;!--中紫罗兰色 --&gt; 中紫罗兰色 &lt;color name=&quot;silver&quot;&gt;#C0C0C0&lt;/color&gt;&lt;!--银色 --&gt; 银色 &lt;color name=&quot;darkkhaki&quot;&gt;#BDB76B&lt;/color&gt;&lt;!--暗黄褐色 --&gt; 暗黄褐色 &lt;color name=&quot;rosybrown&quot;&gt;#BC8F8F&lt;/color&gt; &lt;!--褐玫瑰红 --&gt; 褐玫瑰红 &lt;color name=&quot;mediumorchid&quot;&gt;#BA55D3&lt;/color&gt;&lt;!--中粉紫色 --&gt; 中粉紫色 &lt;color name=&quot;darkgoldenrod&quot;&gt;#B8860B&lt;/color&gt;&lt;!--暗金黄色 --&gt; 暗金黄色 &lt;color name=&quot;firebrick&quot;&gt;#B22222&lt;/color&gt;&lt;!--火砖色 --&gt; 火砖色 &lt;color name=&quot;powderblue&quot;&gt;#B0E0E6&lt;/color&gt;&lt;!--粉蓝色 --&gt; 粉蓝色 &lt;color name=&quot;lightsteelblue&quot;&gt;#B0C4DE&lt;/color&gt;&lt;!--亮钢兰色 --&gt; 亮钢兰色 &lt;color name=&quot;paleturquoise&quot;&gt;#AFEEEE&lt;/color&gt;&lt;!--苍宝石绿 --&gt; 苍宝石绿 &lt;color name=&quot;greenyellow&quot;&gt;#ADFF2F&lt;/color&gt;&lt;!--黄绿色 --&gt; 黄绿色 &lt;color name=&quot;lightblue&quot;&gt;#ADD8E6&lt;/color&gt;&lt;!--亮蓝色 --&gt; 亮蓝色 &lt;color name=&quot;darkgray&quot;&gt;#A9A9A9&lt;/color&gt;&lt;!--暗灰色 --&gt; 暗灰色 &lt;color name=&quot;brown&quot;&gt;#A52A2A&lt;/color&gt;&lt;!--褐色 --&gt; 褐色 &lt;color name=&quot;sienna&quot;&gt;#A0522D&lt;/color&gt;&lt;!--赭色 --&gt; 赭色 &lt;color name=&quot;darkorchid&quot;&gt;#9932CC&lt;/color&gt;&lt;!--暗紫色--&gt; 暗紫色 &lt;color name=&quot;palegreen&quot;&gt;#98FB98&lt;/color&gt;&lt;!--苍绿色 --&gt; 苍绿色 &lt;color name=&quot;darkviolet&quot;&gt;#9400D3&lt;/color&gt;&lt;!--暗紫罗兰色 --&gt; 暗紫罗兰色 &lt;color name=&quot;mediumpurple&quot;&gt;#9370DB&lt;/color&gt;&lt;!--中紫色 --&gt; 中紫色 &lt;color name=&quot;lightgreen&quot;&gt;#90EE90&lt;/color&gt;&lt;!--亮绿色 --&gt; 亮绿色 &lt;color name=&quot;darkseagreen&quot;&gt;#8FBC8F&lt;/color&gt;&lt;!--暗海兰色 --&gt; 暗海兰色 &lt;color name=&quot;saddlebrown&quot;&gt;#8B4513&lt;/color&gt;&lt;!--重褐色 --&gt; 重褐色 &lt;color name=&quot;darkmagenta&quot;&gt;#8B008B&lt;/color&gt;&lt;!--暗洋红 --&gt; 暗洋红 &lt;color name=&quot;darkred&quot;&gt;#8B0000&lt;/color&gt;&lt;!--暗红色 --&gt; 暗红色 &lt;color name=&quot;blueviolet&quot;&gt;#8A2BE2&lt;/color&gt;&lt;!--紫罗兰蓝色 --&gt; 紫罗兰蓝色 &lt;color name=&quot;lightskyblue&quot;&gt;#87CEFA&lt;/color&gt;&lt;!--亮天蓝色 --&gt; 亮天蓝色 &lt;color name=&quot;skyblue&quot;&gt;#87CEEB&lt;/color&gt;&lt;!--天蓝色 --&gt; 天蓝色 &lt;color name=&quot;gray&quot;&gt;#808080&lt;/color&gt;&lt;!--灰色 --&gt; 灰色 &lt;color name=&quot;olive&quot;&gt;#808000&lt;/color&gt;&lt;!--橄榄色 --&gt;橄榄色&lt;color name=&quot;purple&quot;&gt;#800080&lt;/color&gt;&lt;!--紫色 --&gt; 紫色 &lt;color name=&quot;maroon&quot;&gt;#800000&lt;/color&gt;&lt;!--粟色 --&gt; 粟色 &lt;color name=&quot;aquamarine&quot;&gt;#7FFFD4&lt;/color&gt;&lt;!--碧绿色--&gt; 碧绿色 &lt;color name=&quot;chartreuse&quot;&gt;#7FFF00&lt;/color&gt;&lt;!--黄绿色 --&gt; 黄绿色 &lt;color name=&quot;lawngreen&quot;&gt;#7CFC00&lt;/color&gt;&lt;!--草绿色 --&gt; 草绿色 &lt;color name=&quot;mediumslateblue&quot;&gt;#7B68EE&lt;/color&gt;&lt;!--中暗蓝色 --&gt; 中暗蓝色 &lt;color name=&quot;lightslategray&quot;&gt;#778899&lt;/color&gt;&lt;!--亮蓝灰 --&gt; 亮蓝灰 &lt;color name=&quot;slategrey&quot;&gt;#708090&lt;/color&gt;&lt;!--灰石色 --&gt; 灰石色 &lt;color name=&quot;olivedrab&quot;&gt;#6B8E23&lt;/color&gt;&lt;!--深绿褐色 --&gt; 深绿褐色 &lt;color name=&quot;slateblue&quot;&gt;#6A5ACD&lt;/color&gt;&lt;!--石蓝色 --&gt; 石蓝色 &lt;color name=&quot;dimgray&quot;&gt;#696969&lt;/color&gt;&lt;!--暗灰色 --&gt; 暗灰色 &lt;color name=&quot;mediumaquamarine&quot;&gt;#66CDAA&lt;/color&gt;&lt;!--中绿色 --&gt; 中绿色 &lt;color name=&quot;cornflowerblue&quot;&gt;#6495ED&lt;/color&gt;&lt;!--菊兰色 --&gt; 菊兰色 &lt;color name=&quot;cadetblue&quot;&gt;#5F9EA0&lt;/color&gt;&lt;!--军兰色 --&gt; 军兰色 &lt;color name=&quot;darkolivegreen&quot;&gt;#556B2F&lt;/color&gt;&lt;!--暗橄榄绿 --&gt; 暗橄榄绿 &lt;color name=&quot;indigo&quot;&gt;#4B0082&lt;/color&gt;&lt;!--靛青色 --&gt; 靛青色 &lt;color name=&quot;mediumturquoise&quot;&gt;#48D1CC&lt;/color&gt;&lt;!--中绿宝石 --&gt; 中绿宝石 &lt;color name=&quot;darkslateblue&quot;&gt;#483D8B&lt;/color&gt;&lt;!--暗灰蓝色 --&gt; 暗灰蓝色 &lt;color name=&quot;steelblue&quot;&gt;#4682B4&lt;/color&gt;&lt;!--钢兰色 --&gt; 钢兰色 &lt;color name=&quot;royalblue&quot;&gt;#4169E1&lt;/color&gt;&lt;!--皇家蓝 --&gt; 皇家蓝 &lt;color name=&quot;turquoise&quot;&gt;#40E0D0&lt;/color&gt;&lt;!--青绿色 --&gt; 青绿色 &lt;color name=&quot;mediumseagreen&quot;&gt;#3CB371&lt;/color&gt;&lt;!--中海蓝 --&gt; 中海蓝 &lt;color name=&quot;limegreen&quot;&gt;#32CD32&lt;/color&gt;&lt;!--橙绿色 --&gt; 橙绿色 &lt;color name=&quot;darkslategray&quot;&gt;#2F4F4F&lt;/color&gt;&lt;!--暗瓦灰色 --&gt; 暗瓦灰色 &lt;color name=&quot;seagreen&quot;&gt;#2E8B57&lt;/color&gt;&lt;!--海绿色 --&gt; 海绿色 &lt;color name=&quot;forestgreen&quot;&gt;#228B22&lt;/color&gt;&lt;!--森林绿 --&gt; 森林绿 &lt;color name=&quot;lightseagreen&quot;&gt;#20B2AA&lt;/color&gt;&lt;!--亮海蓝色 --&gt; 亮海蓝色 &lt;color name=&quot;dodgerblue&quot;&gt;#1E90FF&lt;/color&gt;&lt;!--闪兰色 --&gt; 闪兰色 &lt;color name=&quot;midnightblue&quot;&gt;#191970&lt;/color&gt;&lt;!--中灰兰色 --&gt; 中灰兰色 &lt;color name=&quot;aqua&quot;&gt;#00FFFF&lt;/color&gt;&lt;!--浅绿色 --&gt; 浅绿色 &lt;color name=&quot;cyan&quot;&gt;#00FFFF&lt;/color&gt;&lt;!--青色 --&gt; 青色 &lt;color name=&quot;springgreen&quot;&gt;#00FF7F&lt;/color&gt;&lt;!--春绿色--&gt; 春绿色 &lt;color name=&quot;lime&quot;&gt;#00FF00&lt;/color&gt;&lt;!--酸橙色 --&gt; 酸橙色 &lt;color name=&quot;mediumspringgreen&quot;&gt;#00FA9A&lt;/color&gt;&lt;!--中春绿色 --&gt; 中春绿色 &lt;color name=&quot;darkturquoise&quot;&gt;#00CED1&lt;/color&gt;&lt;!--暗宝石绿 --&gt; 暗宝石绿 &lt;color name=&quot;deepskyblue&quot;&gt;#00BFFF&lt;/color&gt;&lt;!--深天蓝色 --&gt; 深天蓝色 &lt;color name=&quot;darkcyan&quot;&gt;#008B8B&lt;/color&gt;&lt;!--暗青色 --&gt; 暗青色 &lt;color name=&quot;teal&quot;&gt;#008080&lt;/color&gt;&lt;!--水鸭色 --&gt; 水鸭色 &lt;color name=&quot;green&quot;&gt;#008000&lt;/color&gt;&lt;!--绿色 --&gt; 绿色 &lt;color name=&quot;darkgreen&quot;&gt;#006400&lt;/color&gt;&lt;!--暗绿色 --&gt; 暗绿色 &lt;color name=&quot;blue&quot;&gt;#0000FF&lt;/color&gt;&lt;!--蓝色 --&gt; 蓝色 &lt;color name=&quot;mediumblue&quot;&gt;#0000CD&lt;/color&gt;&lt;!--中兰色 --&gt; 中兰色 &lt;color name=&quot;darkblue&quot;&gt;#00008B&lt;/color&gt;&lt;!--暗蓝色 --&gt; 暗蓝色 &lt;color name=&quot;navy&quot;&gt;#000080&lt;/color&gt;&lt;!--海军色 --&gt; 海军色 &lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt;&lt;!--黑色 --&gt; 黑色]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android反编译]]></title>
      <url>%2F2015%2F05%2F10%2Fandroid-decompile%2F</url>
      <content type="text"><![CDATA[前言自学Android有段时间了，发现反编译别人的apk读别人的代码，是个提高的好方式，还能获取一些好的图片资源。网上找了些方式，发现过程和方式有一些出路，还是自己写个blog来记录一下。 反编译工具反编译的工具，就选用大家通用的Apktool，dex2jar和JD-GUI。（超链接进入其官网）这三个软件Apktool的安装稍微麻烦点，其他都还好，基本上下载下来解压了就能用。 Apktool(按照官网安装方式，我的是Mac系统，其他系统同样按照官网方式安装) Download Mac wrapper script (Right click, Save Link As apktool) Download apktool-2 (find newest here) Rename downloaded jar to apktool.jar Move both files (apktool.jar &amp; apktool) to /usr/local/bin (root needed) Make sure both files are executable (chmod +x) Try running apktool via cli 基本上按照上面的6个步骤就ok了。虽然很简单，还是解释下吧。 是下载一个shell脚本，保存的名字就是”apktool”,不要带.sh后缀。可以复制到sublimetext，然后保存下。 下载最新的apktool-2 将所下载的jar文件改名为”apktool.jar” 将shell脚本”apktool”和”apktool.jar”放到 “/usr/local/bin”目录下 增加这两个文件可执行权限，chmod a+x file 执行shell apktool就ok了。 安装完毕后可以运行apktool -v查看版本信息 dex2jar和JD-GUI 这两个直接下载，然后解压缩就ok 反编译为了检测下是否能破解，我们先用Apktool反编译，免得我们最后一场空。（只有Apktool能反编译／回编译，我们的破解才有意义）。 新建个apk文件夹，将待破译的apk放进去，之后进到这个目录运行命令: apktool d test.apk apktool b hongbao (hongbao 就是反编译出来的文件夹) 回编译apk过程中会生成build和dist文件夹，编译出来的apk在dist目录下，打开build/apk文件夹会发现少了original文件夹下的META-INF文件夹，也就意味着dist里的apk文件是没有签名的。 我们要用dex2jar将apk转成jar文件，实质是将apk里的classes.dex转成jar。将dex2jar里的d2j_invoke.sh／d2j-dex2jar.sh增加可执行权限。然后进到dex2jar这个文件夹下运行: ./d2j-dex2jar.sh /Users/yanzi/apk/hongbao.apk 得到hongbao-dex2jar.jar文件。 打开JD-GUI，将hongbao-dex2jar.jar拖进去就看到源码了。通过看Java源码对比smali文件，修改后回编译就ok了！ 添加签名 回编译后的apk是安装不成功的，总是提示Failure [INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION]实质是没签名。 生成签名 keytool -genkey -keystore hongbao.keystore -keyalg RSA -validity 10000 -alias hongbao 为apk增加签名 jarsigner -digestalg SHA1 -sigalg MD5withRSA -tsa -verbose -keystore hongbao.keystore -signedjar hongbao-signed.apk hongbao.apk hongbao 注意 最后的”hongbao”就是－alias后面带的，必须保持一致。 如果不带-digestalg SHA1 -sigalg MD5withRSA签名后的apk安装也是不成功的，说INSTALL_PARSE_FAILED_NO_CERTIFICATES的错误，如果不带-tsa会报一个时间方面的警告。 使用apktool是为了能将修改后的代码或者资源重新回编译，改进效果。如果只是单纯想要apk里面的代码，还有一种方式更加简单。 修改apk后缀名为.zip 解压apk.zip 拷贝解压文件夹中的classes.dex文件至dex2jar工具存放目录下 终端进入dex2jar目录，执行./d2j-dex2jar.sh classes.dex 生成classes.dex.dex2jar.jar文件 可以通过JD-GUI工具直接打开查看jar文件中的代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS7搭建Git]]></title>
      <url>%2F2015%2F04%2F29%2Fgit-server%2F</url>
      <content type="text"><![CDATA[前言Git是一个好东西，分布式管理的方式的确使管理代码变得方便很多。而且git致富和linux之父是同一个人，在linux上搭建git十分简单。感觉除了用GitHub公有仓库外，自己搭建一个私有的仓库来储存自己的代码还是蛮有必要的。 git作为一个 分布式代码仓库，其实没有server和client的概念，每个机器上保存的都是一份完整的代码库，不过貌似是大团队的话，为了管理方便，会在服务器装一个管理的东东，俺是小团队，有需要再去研究，小团队手动就口以了 服务端安装Git 安装Git # yum -y install git 创建一个裸仓库 12345cd /srvmkdir GitServercd GitServercd MyBloggit init --bare MyBlog.git //初始化空的Git版本库 创建一个git用户 12useradd gitUserpasswd gitUser 然后把GitServer文件夹赋予git用户 chown -R gitUser: gitUser GitServer 至此，服务端的git搭建就完毕了。 客户端操作Git 在本机创建一个文件夹，进入文件夹 直接clone git clone gitUser@***.**.**.**:/srv/GitServer/project.git //**.**.**.**为你服务器的外网ip 输入git的密码 进入project.git 创建一个测试文件 vim test.txt 输入 Hello Git World! 查看状态 git status 看到待添加的文件test.txt 添加test.txt让git追踪 git add test.txt 提交到版本库，并写上备注信息 git commit test.txt -m &#39;jest a test&#39; 把他推送到服务器的版本库中去，要输入密码 git push origin master 服务端查看 由于在服务器端创建版本库时用的是git init --bare project.git加了个–-bare就是创建一个裸仓库，没有工作区，所以这里只记录了文件的改动，要看是不是同步过来了，需要在git clone一次，看是不是这一次有test.txt啦 git clone gitUser@127.0.0.1:/srv/GitServer/MyBlog.git 输入密码后，下载代码，然后进入仓库查看果然master分支已经有test.txt，打开文件，发现内容一致。 git log查看提交记录,作者时间以及备注信息一致 啦啦啦，私有git搭建完成]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[改善C++代码的建议]]></title>
      <url>%2F2015%2F04%2F28%2FC%2B%2B-advice%2F</url>
      <content type="text"><![CDATA[学习C++代码的一些建议，记录一下 不要让main函数返回void() —-int main()和int main（int argc，char *argv[]）这两个都是可行的; FALSE/TRUE是int型，false/true是bool型 表达式****==****，最好写成number==nValue，例0==nValue 运算符优先级问题要考虑清楚 使用宏定义时，要用括号完备地保护每一个参数 指针变量一定要初始化 将逗号分隔表达式一定要规范，在条件和循环语句中，表达式的值采用的是最右边的结果; 时刻提防内存溢出。当信息来源不可靠时，要用到内存缓冲区时，必须提高警惕，必须知道内存缓冲区的总长度，并检验内存缓冲区； 拒绝晦涩难懂的函数指针定义，拒绝函数定义中成堆的括号,使用typedef让函数指针更加直观，易维护； 避免包含相同的头文件在不同文件中 { #ifndef _PROJECT_PATH_FILE_H_ #define _PROJECT_PATH_FILE_H_ ……//声明 #endif }; 优化结构体中元素的布局 { a.结构体变量的首地址能够被其最宽基本类型成员的大小所整除； b.结构体每个成员相对于结构体首地址的偏移量（offset）都是成员自身大小的整数倍，如有需要编译器会在成员之间加上填充字节; c.结构体的总大小为结构体最宽基本类型大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。 *把结构体中得变量按照类型大小从小到大依次声明，尽量减少中间的填充字节。 } #pragma pack(1) struct A { int a; char b; short c; } 将强制转型减到最少 不同类型的指针之间不能相互转换（避免在内存访问时存在隐患） const_cast(a)：目的简单明确，使用情形比较单一，易于掌握; dynamic_cast(a):实现慢，代价大； reinterpret_cast(a):不安全； static_cast(a):不安全 优先使用前缀操作符 前缀操作符的效率要优于后缀操作符（整形，长整形可忽略；用户自定义类型，优先使用前缀操作符。） 掌握变量定义的位置与时机 控制变量的作用域，适当位置可减少操作时间； 小心typedef使用中的陷阱 容易与宏定义混淆，typedef声明多个指针对象，形式直观，方便省事。请注意区分typedef与#define之间的不同,不要用理解宏的思维方式对待typedef，typedef声明的新名字具有一定的封装性，更易定义变量。同时还要注意它是一个无“现实意义”的存储类关键字; 尽量不要使用可变参数 缺乏类型检查，类型安全性无从谈起；必须通过其他方式告诉函数所传递的类型，以及参数个数；不支持自定义数据类型; 慎用goto 没有带来太大的正面作用，相反却容易破坏程序的结构性，影响了程序的可读性; 提防隐式转换带来的麻烦 影响数据的精确性，编译器无法正常接受；（为防止精度损失，类型总是被提升为较宽的类型；所有含有小于整形的算术表达式在计算之前其类型都会被转换成整形） 使用非C/C++关键字的具名函数，用operator as_T()替换operato T(); 为单参数的构造函数加上explicit关键字; 正确区分void与void 如果函数没有返回值，那么应将其声明为void类型（不加返回值类型限定的函数，就会被编译器作为返回整型值处理）；如果函数无参数，那么声明函数参数为void；任何类型的指针都可以赋值给void*；void指针进行算法操作是不合法的; 明白在C++中如何使用C 要想在C++中使用大量现成的C程序库，实现C++与C的混编，必须了解extern“C”是怎么回事，明白“C”的使用方式; 使用memcpy（）系列 包含memcpy（），memset（），memcmp（），要注意对象是不是POD。 尽量用new/delete代替malloc/free malloc/free是语言的标准函数库，而new/delete是C++的运算符。malloc/free无法满足创建动态对象的要求；new不仅能够完成动态内存分配，还能完成初始化工作，稳妥的构造对象；delete不仅能完成内存的释放，还能对对象进行清理。 灵活地使用不同风格的注释 版权和版本声明，使用C风格的/ \/;内嵌注释用//；宏尾端的注释用/ / 尽量使用C++标准的iostream C++ iostream程序库中的类与C stream函数虽然各有优点，但是一般推荐使用前者，为类型安全与可扩充性对于我们更有吸引力，所以建议使用iostream; 尽量采用C++风格的强制类型转换 尽量用const、enum、inline替换#define 宏定义并不在编译范围内，使得程序难于分析，难于调试；使用常量可以避免目标码的多分复制；用const修饰指针建议使用更加高级的const string形式。对于简单的常量，应该尽量使用const对象或枚举类型的数据，避免使用#define。对于形似函数的宏，尽量使用内联函数，避免使用#define。尽量将工作交给编译器而不是预处理器; 用引用代替指针 从编码实践角度来看，指针与引用并无太大不同。在大多数情况下，指针可用索引类型完美代替，并且其实现代码更简洁清晰，更加易于理解 区分内存分配的方式 栈效率高一点，而堆较灵活 new/delete与new[]/delete[]必须配对使用 区分new的三种形态 new内存失败后的正确处理 当使用new申请一块内存失败时，抛出异常std::bad_alloc是C++标准中规定的标准行为，所以推荐使用try{p=new int[SIZE];}catch(std::bad_alloc){…}的处理方式 明晰class与struct之间的区别 关于使用大括号初始化：class与struct定义了构造函数就不能用大括号初始化，如果没有定义struct可以用大括号初始化，而class只有在所有成员变量全是public情况下才能用大括号初始化; class默认成员访问权限是private，struct中则是public class继承是private，struct继承是public]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何搭建LAMP环境]]></title>
      <url>%2F2015%2F04%2F23%2Fbuild-lamp%2F</url>
      <content type="text"><![CDATA[前言由于买了阿里云学生机，就想着自己在服务器上搭建网站。首先给服务器搭建LAMP环境，以后搭建网站就有着落了。 安装Apache服务 安装 yum -y install httpd 开启apache服务 systemctl start httpd.service 设置apache服务开机启动 systemctl enable httpd.service 验证Apache服务是否安装成功 在本机浏览器中输入阿里云服务器的外网ip，出现Testing 123… Apache页面说明安装成功。 安装PHP 安装 yum -y install php 重启Apache服务 systemctl restart httpd.service或者systemctl restart httpd 写一个php文件在浏览器中运行一次 vi /var/www/html/info.php——–输入&lt;?php phpinfo(); ?&gt;——-在本机浏览器中输入ip/info.php,出现php version说明php安装成功。 安装MySqlCentOS 7.0 安装MariaDB，这是MySql的一个分支，是由MySql的创始人Michael Widenius带领开发的，团队依旧，所以两者使用基本没有太大的区别。 安装 yum install mariadb-server -y 开启MySQL服务 systemctl start mariadb.service 设置开机启动MySQL服务 systemctl enable mariadb.service 设置root帐户的密码 mysql_secure_installation 之后会让你输入当前mysql的密码，直接Enter。之后输入新密码，以及确认密码，后面的内容看你的情况进行选择是或者否。 想要确认密码是否已经改变，可以输入mysql -uroot -p进行测试。 将PHP和MySQL关联起来输入yum -y install php-mysql 安装常用的PHP模块 安装：yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel 重启Apache服务 systemctl restart httpd.service 结束然后，再次在浏览器中运行info.php，你会看到安装的模块的信息。至此，LAMP环境就搭建好了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github pages和Jekyll搭建]]></title>
      <url>%2F2015%2F04%2F11%2Fbuild-the-githubpages%2F</url>
      <content type="text"><![CDATA[前言最近才发现Github原来也可以支持博客的搭建，利用Jekyll这个静态网站生成器，可以很快搭建一个博客来记录自己开发学习生活的一些知识点和经验。之前的WordPress用的不怎么顺手，一台服务器既要搭建博客，又要玩些其他小应用还是不怎么方便，所以既然有了这个免费的技术分享区还是可以好好利用的。 Step 1.Github选址GitHub是拿来干什么的就不多说了,GitHub Pages(Website for you and your project.),这就是我们所需要搭建的博客了，通过Git方式对博客进行管理，这种方式免费，安全，快捷。 新建repository名为username.github.io，username为你github的用户名。那么他的master分支上的文件就能在username.github.io的根目录访问到。 创建仓库后，进入Setting，拉动滚动条至GitHub Pages那一栏，点击Automatic page generator. 进入创建用户页面，可以自己编辑，也可以从readme加载。 点击continue to layout，继续选择主题。选好后点击PUBLISH，发布，整个技术博客站点的CSS，HTML和IMG都会导入到你的仓库中。 最后在浏览器中输入username.github.io就可以进入到你的博客主页中了。ps.觉得域名丑的，或者不想用这个域名的，可以花钱买个域名或者把自己已经买的域名映射过去。在仓库根路径下创建一个名为”CNAME”的文件，注意没有后缀。文件中填入你所要指向的域名。这样访问 http://username.github.io 时浏览器就接收到重定向指令,跳转到CNAME里面指定的域名去了。接着还需要到你域名的服务商那里修改域名的记录，通过在终端输入ping username.github.io可以获得博客的ip，添加”www”和”@”两条记录，这样就完成修改域名了。 Git教程-廖雪峰 Git使用教程图文详解 Step 2.本地环境搭建这一步不是必须的，但是强烈建议完成。这样，在博客发布之前方便调试检验一下。 首先更新本机上的ruby。 安装RVM $ curl -L get.rvm.io | bash -s stable $ source ~/.bashrc $ source ~/.bash_profile 测试安装是否正常rvm -v 用RVM升级Ruby 查看当前ruby版本$ ruby -v 列出已知的ruby版本$ rvm list known 安装最新版本ruby$ rvm install x.x.x 查看当前ruby版本$ ruby -v 安装Bundle $ gem install bundle 在根目录下创建一个叫Gemfile的文件，注意没有后缀 在Gemfile文件中输入source &#39;https://gems.ruby-china.org//&#39;gem &#39;github-pages&#39; 保存后，在命令行中执行$ bundle install $ bundle update 启动转化和本地服务 $ bundle exec jekyll serve 安装Jekyll gem install jekyll 在你希望存放博客的目录下输入jekyll new your-site-name 进入cd your-site-name 启动转化和本地服务 $ bundle exec jekyll serve --watch 打开浏览器http://localhost:4000就可以本地进行查看和调试你的网站了。 Step 3.Jekyll Jekyll目录 _config.yml 是配置文件，你可以在里面配置你博客会用到的常量，比如博客名，邮件 _includes：就是你文章各个部分的html文件，可以在布局中包含这些文件 _layouts：存放模板。就是你网页的布局，主页布局，文章布局。当然不是指CSS那样的布局，是指，你包含哪些基本的内容到页面上。包含的内容就是includes里面的文件。 _posts: 存放博客文章 index：博客主页 CNAME文件：域名地址 CSS：存放博客所用CSS JS: 存放博客所用JavaScript 如何发表文章 文章的写法，在Markdown开头加上一段： --- layout: posttitle: &quot;Welcome to Jekyll!&quot; date: 2014-01-27 21:57:11 categories: Blog --- 文件命名格式: 时间加标题 比如：2015-08-15-HowTOBuildBlog.mdok，你可以写文章了，放入_post文件夹即可。 修改主题 学习学习前端，并且研究下Jekyll官网，自己修改。或者fork别人在github写好的模板进行修改 Step 4.同步本地和GitHub博客文件使用git命令或者用图形化客户端直接进行文件同步，方法简单不详述。 Step 5.Markdown使用这种语法写文件简单的多了，附上markdown语法和心得 参考网址：http://www.jianshu.com/p/9a6bc31d329dhttps://zhuanlan.zhihu.com/p/21333968 Step 6.代码高亮代码： 在文中使用效果：12345public void hello()&#123; int a = 0; int b = 1; int c = a + b;&#125; Step 7.MarkDown解析器现在github推荐kramdown作为markdown解析器。其解析速度很快比PHP markdown和Maruku都要快几倍。kramdown有很多一般markdown所没有的语法特点，包括和GFM也有差异。另外也可以很方便地作为文件转换使用。kramdown和markdown较大的差异比较 Step 8.生成目录没有目录还是一件很苦恼的事情。特别是长篇博客，所以去查了markdown如何生成目录，在此更新一下。kramdown默认是支持TOC。在_config.yml中的配置方式为：123markdown: kramdownkramdown: input: GFM 在编写文章时，插入下面代码，渲染之后就可以生成TOC了： Step 9.插入数学公式在/source/_includes/head.html中将下面的代码插入&lt;head&gt;和&lt;/head&gt;标签之间。12345678910111213141516171819202122232425262728293031&lt;!-- mathjax config similar to math.stackexchange --&gt;&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true &#125; &#125;);&lt;/script&gt;&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;);&lt;/script&gt;&lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Queue(function() &#123; var all = MathJax.Hub.getAllJax(), i; for(i=0; i &lt; all.length; i += 1) &#123; all[i].SourceElement().parentNode.className += ' has-jax'; &#125; &#125;);&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt; 接着使用LaTeX表达式进行编辑。]]></content>
    </entry>

    
  
  
</search>
