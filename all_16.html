<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207868031.html">
                
                  <h1>排序算法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<ul>
<li><p>现在排序算法经过长时间的演变，发展处各种不同的排序算法。不得不说在日常开发以及日后的研究生活中还是比较常见以及使用的。再此对各种排序算法做一个记录，方便日后比较和查阅。<br/>
<figure><img src="media/15561207868031/15713341125110.jpg" alt=""/></figure></p></li>
<li><p>排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。<br/>
<figure><img src="media/15561207868031/15713341219800.jpg" alt=""/></figure></p></li>
<li><p>当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。  </p></li>
<li><p>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p></li>
</ul>

<h2 id="toc_1">直接插入排序(插入排序)</h2>

<ul>
<li><strong>介绍</strong><br/>
它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</li>
<li><strong>步骤</strong><br/>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置中</li>
<li>重复步骤2</li>
</ol></li>
<li>最优复杂度：当输入数组就是排好序的时候，复杂度为O(n)，而快速排序在这种情况下会产生O(n<sup>2)的复杂度。</sup></li>
<li>最差复杂度：当输入数组为倒序时，复杂度为O(n<sup>2)</sup></li>
<li><p>比较适合用于“少量元素的数组”。</p></li>
<li><p><strong>代码</strong></p></li>
</ul>

<pre class="line-numbers"><code class="language-java">import java.util.*;

class Untitled {
    public static void main(String[] args) {
        Random ran = new Random();
        int[] sort = new int[10];
        for (int i = 0;i &lt; 10;i++) {
            sort[i] = ran.nextInt(50);
        }
        System.out.println(&quot;排序前的数组为&quot;);
        for (int i : sort) {
            System.out.print(i + &quot; &quot;);
        }
        System.out.println();
        directInsertSort(sort);
        System.out.println(&quot;排序后的数组为&quot;);
        for (int i : sort) {
            System.out.print(i + &quot; &quot;);
        }
    }
    /** 
     * 直接插入排序 
     *  
     * @param sort 
     */
    private static void directInsertSort(int[] sort) {  
        for (int i = 1; i &lt; sort.length; i++) {  
            int index = i - 1;  
            int temp = sort[i];  
            while (index &gt;= 0 &amp;&amp; sort[index] &gt; temp) {  
                sort[index + 1] = sort[index];  
                index--;  
            }  
            sort[index + 1] = temp;  
        }  
    }
}
</code></pre>

<ul>
<li><strong>示例</strong><br/></li>
</ul>

<p><figure><img src="media/15561207868031/15713341524184.jpg" alt=""/></figure></p>

<h2 id="toc_2">希尔排序</h2>

<ul>
<li><p><strong>介绍</strong><br/><br/>
希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。<br/><br/>
希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li>
</ol></li>
<li><p><strong>步骤</strong>  </p>
<ol>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol></li>
<li><p><strong>示例</strong>  </p></li>
</ul>

<p><figure><img src="media/15561207868031/15713341708914.jpg" alt=""/></figure></p>

<ul>
<li><strong>排序效果</strong></li>
</ul>

<p><figure><img src="media/15561207868031/2016120965074shell.gif" alt=""/></figure></p>

<h2 id="toc_3">冒泡排序</h2>

<ul>
<li><p><strong>介绍</strong><br/><br/>
冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p></li>
<li><p><strong>步骤</strong>  </p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol></li>
<li><p><strong>代码</strong></p></li>
</ul>

<pre class="line-numbers"><code class="language-java">import java.util.*;
class test1 {
    public static void main(String[] args) {
        Random ran = new Random();
        int[] sort = new int[10];
        for (int i = 0;i &lt; 10;i++) {
            sort[i] = ran.nextInt(50);
        }
        System.out.println(&quot;排序前的数组为&quot;);
        for (int i : sort) {
            System.out.print(i + &quot; &quot;);
        }
        System.out.println();
        buddleSort(sort);
        System.out.println(&quot;排序后的数组为&quot;);
        for (int i : sort) {
            System.out.print(i + &quot; &quot;);
        }
    }
    
    public static void buddleSort(int[] sort){
        for (int i = 1;i &lt; sort.length;i++) {
            for (int j = 0;j &lt; sort.length - i;j++) {
                if (sort[j] &gt; sort[j+1]) {
                    int temp = sort[j];
                    sort[j] = sort[j + 1];
                    sort[j + 1] = temp;
                }
            }
        }
    }
}
</code></pre>

<ul>
<li><strong>示例</strong><br/></li>
</ul>

<p><figure><img src="media/15561207868031/15713342077053.jpg" alt=""/></figure></p>

<ul>
<li><strong>排序效果</strong><br/>
<figure><img src="media/15561207868031/2016120956722maopao2.gif" alt=""/></figure></li>
</ul>

<p><figure><img src="media/15561207868031/2016120989640maopao.gif" alt=""/></figure></p>

<h2 id="toc_4">选择排序</h2>

<ul>
<li><p><strong>介绍</strong><br/><br/>
选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。</p></li>
<li><p><strong>步骤</strong>  </p>
<ol>
<li>从n个记录中找出关键码最小的记录与第一个记录交换；</li>
<li>从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；</li>
<li>以此类推.....</li>
<li>第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换；</li>
<li>直到整个序列按关键码有序。</li>
</ol></li>
<li><p><strong>代码</strong></p></li>
</ul>

<pre class="line-numbers"><code class="language-java">import java.util.*;

class Untitled {
    public static void main(String[] args) {
        Random ran = new Random();
        int[] sort = new int[10];
        for (int i = 0;i &lt; 10;i++) {
            sort[i] = ran.nextInt(50);
        }
        System.out.println(&quot;排序前的数组为&quot;);
        for (int i : sort) {
            System.out.print(i + &quot; &quot;);
        }
        System.out.println();
        selectSort(sort);
        System.out.println(&quot;排序后的数组为&quot;);
        for (int i : sort) {
            System.out.print(i + &quot; &quot;);
        }
    }
    
    public static void selectSort(int[] sort){
        for (int i = 0; i &lt; sort.length - 1;i++) {
            for (int j = i + 1;j &lt; sort.length;j++) {
                if (sort[j] &lt; sort[i]) {
                    int temp = sort[j];  
                    sort[j] = sort[i];  
                    sort[i] = temp;
                }
            }
        }
    }
}
</code></pre>

<ul>
<li><p><strong>示例</strong>  </p>
<p><figure><img src="media/15561207868031/15713343029261.jpg" alt=""/></figure></p></li>
<li><p><strong>排序效果</strong>  </p></li>
</ul>

<p><figure><img src="media/15561207868031/2016120919414selection.gif" alt=""/></figure></p>

<h2 id="toc_5">快速排序</h2>

<ul>
<li><p><strong>介绍</strong><br/><br/>
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。</p></li>
<li><p><strong>步骤</strong>  </p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”(pivot)</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol></li>
<li><p><strong>代码</strong></p></li>
</ul>

<pre class="line-numbers"><code class="language-java">import java.util.*;

class Untitled {
    public static void main(String[] args) {
        Random ran = new Random();
        int[] sort = new int[10];
        for (int i = 0;i &lt; 10;i++) {
            sort[i] = ran.nextInt(50);
        }
        System.out.println(&quot;排序前的数组为&quot;);
        for (int i : sort) {
            System.out.print(i + &quot; &quot;);
        }
        System.out.println();
        quickSort(sort, 0, sort.length - 1);
        System.out.println(&quot;排序后的数组为&quot;);
        for (int i : sort) {
            System.out.print(i + &quot; &quot;);
        }
    }
    
    public static void quickSort(int[] sort, int start, int end) {  
            // 设置关键数据key为要排序数组的第一个元素，  
            // 即第一趟排序后，key右边的数全部比key大，key左边的数全部比key小  
            int key = sort[start];  
            // 设置数组左边的索引，往右移动判断比key大的数  
            int i = start;  
            // 设置数组右边的索引，往左移动判断比key小的数  
            int j = end;  
            // 如果左边索引比右边索引小，则还有数据没有排序  
            while (i &lt; j) {  
                while (sort[j] &gt; key &amp;&amp; j &gt; start) {
                    j--;
                }
                while (sort[i] &lt; key &amp;&amp; i &lt; end) {
                    i++;
                }
                if (i &lt; j) {
                    int temp = sort[i];
                    sort[i] = sort[j];
                    sort[j] = temp;
                }
            }
            // 如果左边索引比右边索引要大，说明第一次排序完成，将sort[j]与key对换
            // 即保持了key左边的数比key小，key右边的数比key大
            if (i &gt; j) {
                int temp = sort[j];
                sort[j] = sort[start];
                sort[start] = temp;
            }
            //递归调用
            if (j &gt; start &amp;&amp; j &lt; end) {
                quickSort(sort, start, j - 1);
                quickSort(sort, j + 1, end);
            }
        }
}
</code></pre>

<ul>
<li><p><strong>示例</strong>  </p>
<ul>
<li>一趟排序的过程
<figure><img src="media/15561207868031/15713343508151.jpg" alt=""/></figure></li>
<li>排序的全过程
<figure><img src="media/15561207868031/15713343604337.jpg" alt=""/></figure></li>
</ul></li>
<li><p><strong>排序效果</strong><br/><br/>
<figure><img src="media/15561207868031/2016120919907quick.gif" alt=""/></figure></p></li>
</ul>

<h2 id="toc_6">归并排序</h2>

<ul>
<li><p><strong>介绍</strong><br/><br/>
归并排序（Merge sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用</p></li>
<li><p><strong>步骤</strong>  </p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针达到序列尾</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ol></li>
<li><p><strong>示例</strong>  </p></li>
</ul>

<p><figure><img src="media/15561207868031/15713343859472.jpg" alt=""/></figure></p>

<ul>
<li><strong>排序效果</strong><br/>
<figure><img src="media/15561207868031/2016120958071guibing.gif" alt=""/></figure></li>
</ul>

<h2 id="toc_7">堆排序</h2>

<ul>
<li><p><strong>介绍</strong><br/><br/>
堆积排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。  </p>
<ol>
<li>大顶堆序列：（96, 83,27,38,11,09)</li>
<li>小顶堆序列：（12，36，24，85，47，30，53，91）<br/>
<figure><img src="media/15561207868031/15713344155617.jpg" alt=""/></figure>
初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</li>
</ol></li>
<li><p><strong>步骤</strong>  </p>
<ul>
<li>调整小顶堆的方法
<ol>
<li>设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶(最后一个元素与堆顶进行交换)，堆被破坏，其原因仅是根结点不满足堆的性质。</li>
<li>将根结点与左、右子树中较小元素的进行交换。</li>
<li>若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法(2).</li>
<li>若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法(2).</li>
<li>继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。
<figure><img src="media/15561207868031/15713344320945.jpg" alt=""/></figure></li>
</ol></li>
<li>n个元素初始建堆的过程(建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。)
<ol>
<li>n 个结点的完全二叉树，则最后一个结点是第<figure><img src="media/15561207868031/15713344446409.jpg" alt=""/></figure><br/>
个结点的子树。</li>
<li>筛选从第<figure><img src="media/15561207868031/15713344446409.jpg" alt=""/></figure>个结点为根的子树开始，该子树成为堆。</li>
<li>之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</li>
<li>如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）
<figure><img src="media/15561207868031/15713345432692.jpg" alt=""/></figure></li>
</ol></li>
</ul></li>
<li><p><strong>排序效果</strong>  </p></li>
</ul>

<p><figure><img src="media/15561207868031/2016120979146heapsort.gif" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/7/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AE%97%E6%B3%95.html'>算法</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867998.html">
                
                  <h1>获取Sha1值</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>自从用了高德地图和百度地图的API，就一直被获取Sha1的值搞得烦不胜烦，总是忘记，花时间去到网上找方式。不过，经历了这么多次的摧残也熟了。记录一下，避免下次再忘记。</p>

<h2 id="toc_1">使用 keytool（jdk自带工具）</h2>

<ol>
<li>运行进入控制台。</li>
<li>在弹出的控制台窗口中定位到 .android 文件夹。</li>
<li>继续在控制台输入命令。 开发模式使用 debug.keystore，命令为：<code>keytool -list -v -keystore debug.keystore</code> 发布模式使用 apk 对应的 keystore，命令为：<code>keytool -list -v -keystore apk的keystore</code></li>
<li>提示输入密钥库密码，开发模式默认密码是 android，发布模式的密码是为 apk 的 keystore 设置的密码。输入密钥后回车（如果没设置密码，可直接回车），此时可在控制台显示的信息中获取 Sha1 值</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/7/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867938.html">
                
                  <h1>Android-EditText</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">EditText控件的常用属性如下：</h2>

<p><strong>android:hint=&quot;请输入数字！&quot;</strong>//设置显示在输入位置上的提示信息  </p>

<p><strong>android:numeric=&quot;integer&quot;</strong>//设置只能输入整数，如果是小数则是：decimal  </p>

<p><strong>android:singleLine=&quot;true&quot;</strong>//设置单行输入，一旦设置为true，则文字不会自动换行。  </p>

<p><strong>android:password=&quot;true&quot;</strong>//设置只能输入密码  </p>

<p><strong>android:textColor = &quot;#ff8c00&quot;</strong>//设置字体颜色  </p>

<p><strong>android:textStyle=&quot;bold&quot;</strong>//设置字体类型，如加粗、斜体等  </p>

<p><strong>android:textSize=&quot;20dip&quot;</strong>//设置字体大小  </p>

<p><strong>android:textColorHighlight=&quot;#cccccc&quot;</strong>//设置被选中文字的底色，默认为蓝色  </p>

<p><strong>android:textColorHint=&quot;#ffff00&quot;</strong>//设置提示信息文字的颜色，默认为灰色  </p>

<p><strong>android:textScaleX=&quot;1.5&quot;</strong>//设置字与字之间的间距  </p>

<p><strong>android:typeface=&quot;monospace&quot;</strong>//设置字型，如normal, sans, serif, monospace  </p>

<p><strong>android:background=&quot;@null&quot;</strong>//设置控件的背景，默认为灰色带边框的背景，@null指透明，且没有边框  </p>

<p><strong>android:layout_weight=&quot;1&quot;</strong>//设置控件所占的权重，控制控件之间的地位  </p>

<p><strong>android:textAppearance=&quot;?android:attr/textAppearanceLargeInverse&quot;</strong>//设置文字外观  </p>

<p><strong>android:layout_gravity=&quot;center_vertical&quot;</strong>//设置控件显示的位置：默认top，这里居中显示，还有bottom  </p>

<p><strong>android:gravity=&quot;top&quot;</strong> //多行中指针在第一行位置，即顶部  </p>

<p><strong>android:capitalize</strong> //首字母大写  </p>

<p><strong>android：phoneNumber</strong> //输入电话号码  </p>

<p><strong>android：editable</strong> //是否可编辑  </p>

<p><strong>android:autoLink=”all”</strong> //设置文本超链接样式当点击网址时，跳向该网址，可选值(none/web/email/phone/map/all)  </p>

<p><strong>android:autoText</strong> //如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。  </p>

<p><strong>android:bufferType</strong> //指定getText()方式取得的文本类别  </p>

<p><strong>android:cursorVisible</strong> //设定光标为显示/隐藏，默认显示。  </p>

<p><strong>android:digits</strong>  //设置允许输入哪些字符。如“1234567890.+-*/% ()”  </p>

<p><strong>android:editorExtras</strong>  //设置文本的额外的输入数据  </p>

<p><strong>android:ellipsize</strong>  //设置当文字过长时,该控件该如何显示。有如下值设置：”start”—?省略号显示在开头;”end”——省略号显示在结尾;”middle”—-省略号显示在中间;”marquee” ——以跑马灯的方式显示(动画横向移动)  </p>

<p><strong>android:freezesText</strong>  //设置保存文本的内容以及光标的位置  </p>

<p><strong>android:gravity</strong>  //设置文本位置，如设置成“center”，文本将居中显示。  </p>

<p><strong>android:hintText</strong>  //为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色  </p>

<p><strong>android:includeFontPadding</strong> //设置文本是否包含顶部和底部额外空白，默认为true。  </p>

<p><strong>android:linksClickable</strong>   //设置链接是否点击连接，即使设置了autoLink。  </p>

<p><strong>android:marqueeRepeatLimit</strong>  //在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。  </p>

<p><strong>android:ems</strong>  //设置TextView的宽度为N个字符的宽度。  </p>

<p><strong>android:maxEms</strong>  //设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。  </p>

<p><strong>android:minEms</strong>  //设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。  </p>

<p><strong>android:maxLength</strong>  //限制显示的文本长度，超出部分不显示。  </p>

<p><strong>android:lines</strong>  //设置文本的行数，设置两行就显示两行，即使第二行没有数据。  </p>

<p><strong>android:maxLines</strong>  //设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。  </p>

<p><strong>android:minLines</strong>  //设置文本的最小行数，与lines类似。  </p>

<p><strong>android:lineSpacingExtra</strong>  设置行间距。  </p>

<p><strong>android:lineSpacingMultiplier</strong>  //设置行间距的倍数。如”1.2”  </p>

<p><strong>android:password</strong>  //以小点”.”显示文本  </p>

<p><strong>android:scrollHorizontally</strong>  //设置文本超出TextView的宽度的情况下，是否出现横拉条。  </p>

<p><strong>android:selectAllOnFocus</strong>  //如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。  </p>

<p><strong>android:shadowColor</strong>  //指定文本阴影的颜色，需要与shadowRadius一起使用。  </p>

<p><strong>android:shadowDx</strong>  //设置阴影横向坐标开始位置。  </p>

<p><strong>android:shadowDy</strong>  //设置阴影纵向坐标开始位置。  </p>

<p><strong>android:shadowRadius</strong>  //设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好  </p>

<p><strong>android:height</strong>  //设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)  </p>

<p><strong>android:maxHeight</strong>  //设置文本区域的最大高度  </p>

<p><strong>android:minHeight</strong>  //设置文本区域的最小高度  </p>

<p><strong>android:width</strong>  //设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)，与layout_width的区别看这里。  </p>

<p><strong>android:maxWidth</strong>  //设置文本区域的最大宽度  </p>

<p><strong>android:minWidth</strong>  //设置文本区域的最小宽度  </p>

<h2 id="toc_1">自动弹出软键盘</h2>

<p>为了改善用户体验，在进入一个Android页面时，自动弹出输入软键盘，实现方法如下。</p>

<h3 id="toc_2">方法一：</h3>

<p>首先要对指定的输入框请求焦点。然后调用输入管理器弹出软键盘。</p>

<h4 id="toc_3">绑定软键盘到EditText：</h4>

<pre class="line-numbers"><code class="language-java">editText.setFocusable(true);  
editText.setFocusableInTouchMode(true);  
editText.requestFocus();  
InputMethodManager inputManager = (InputMethodManager)editText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);  
inputManager.showSoftInput(editText, 0);

</code></pre>

<h4 id="toc_4">去除软键盘显示：</h4>

<pre class="line-numbers"><code class="language-java">edit.setText(&quot;&quot;);    
edit.clearFocus();    
InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);     
imm.hideSoftInputFromWindow(edit.getWindowToken(), 0);
</code></pre>

<p>由于调转到一个新的页面，就需要弹出软键盘，往往页面还未加载完，造成软键盘无法弹出，这个时候可采用延时弹出的方法进行解决，延时大概300毫秒来保证页面加载完成：</p>

<h4 id="toc_5">方法A:</h4>

<pre class="line-numbers"><code class="language-java">private Handler hander=new Handler(){    
    public void handleMessage(android.os.Message msg) {    
        edit.setFocusable(true);    
        edit.setFocusableInTouchMode(true);    
        edit.requestFocus();    
        InputMethodManager inputManager = (InputMethodManager)edit.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);    
        inputManager.showSoftInput(edit, 0);    
    };    
};   
  
@Override    
public void onWindowFocusChanged(boolean hasWindowFocus) {    
    if(visible){        
        hander.sendEmptyMessageDelayed(0, 1000);    
    }    
}
</code></pre>

<h4 id="toc_6">方法B：</h4>

<pre class="line-numbers"><code class="language-java">Timer timer = new Timer();  
timer.schedule(new TimerTask()  {  
    public void run(){  
       InputMethodManager inputManager = (InputMethodManager)editText.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);  
    inputManager.showSoftInput(editText, 0);  
    }  
}, 500);
</code></pre>

<h3 id="toc_7">方法二：</h3>

<p>布局中自动弹出软键盘：</p>

<pre class="line-numbers"><code class="language-java">editText.requestFocus();  
editText.setFocusable(true);  
InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);  
imm.showSoftInputFromInputMethod(editText.getWindowToken(),0);
</code></pre>

<h4 id="toc_8">布局中自动关闭软键盘：</h4>

<pre class="line-numbers"><code class="language-java">InputMethodManager imm = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);    
imm.hideSoftInputFromWindow(talking_edit.getWindowToken() , 0);
</code></pre>

<h3 id="toc_9">对话框中软键盘自动弹出和关闭：</h3>

<pre class="line-numbers"><code class="language-java">getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE|WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
</code></pre>

<p><strong>通过各种百度，又搜集并整理了好多关于软键盘的一些方法</strong>：</p>

<h4 id="toc_10">1.软键盘的显示原理      </h4>

<p>软键盘其实是一个Dialog。InputMethodService为我们的输入法创建了一个Dialog，并且对某些参数进行了设置，使之能够在底部或者全屏显示。当我们点击输入框时，系统会对当前的主窗口进行调整，以便留出相应的空间来显示该Dialog在底部，或者全屏。</p>

<h4 id="toc_11">2.活动主窗口调整       </h4>

<p>android定义了一个属性windowSoftInputMode, 用它可以让程序控制活动主窗口调整的方式。我们可以在配置文件AndroidManifet.xml中对Activity进行设置。这个属性的设置将会影响两件事情:       </p>

<ul>
<li>软键盘的状态——隐藏或显示。      </li>
<li><p>活动的主窗口调整——是否减少活动主窗口大小以便腾出空间放软键盘或是否当活动窗口的部分被软键盘覆盖时它的内容的当前焦点是可见的。       故该属性的设置必须是下面列表中的一个值，或一个“state…”值加一个“adjust…”值的组合。在任一组设置多个值，各个值之间用|分开。</p></li>
<li><p>&quot;stateUnspecified&quot;： 软键盘的状态(隐藏或可见)没有被指定。系统将选择一个合适的状态或依赖于主题的设置。这个是软件盘行为的默认设置。</p></li>
<li><p>&quot;stateUnchanged&quot;：软键盘被保持上次的状态。</p></li>
<li><p>&quot;stateHidden&quot;：当用户选择该Activity时，软键盘被隐藏。</p></li>
<li><p>&quot;stateAlwaysHidden&quot;： 软键盘总是被隐藏的。</p></li>
<li><p>&quot;stateVisible&quot;： 软键盘是可见的。</p></li>
<li><p>&quot;stateAlwaysVisible&quot;： 当用户选择这个Activity时，软键盘是可见的。</p></li>
<li><p>&quot;adjustUnspecified&quot;： 它不被指定是否该Activity主窗口调整大小以便留出软键盘的空间，或是否窗口上的内容得到屏幕上当前的焦点是可见的。系统将自动选择这些模式中一种主要依赖于是否窗口的内容有任何布局视图能够滚动他们的内容。如果有这样的一个视图，这个窗口将调整大小，这样的假设可以使滚动窗口的内容在一个较小的区域中可见的。这个是主窗口默认的行为设置。也就是说，系统自动决定是采用平移模式还是压缩模式，决定因素在于内容是否可以滚动。</p></li>
<li><p>&quot;adjustResize&quot;：（压缩模式） 当软键盘弹出时，要对主窗口调整屏幕的大小以便留出软键盘的空间。</p></li>
<li><p>&quot;adjustPan&quot;：（平移模式：当输入框不会被遮挡时，该模式没有对布局进行调整，然而当输入框将要被遮挡时，窗口就会进行平移。也就是说，该模式始终是保持输入框为可见。）该Activity主窗口并不调整屏幕的大小以便留出软键盘的空间。相反，当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分。这个通常是不期望比调整大小，因为用户可能关闭软键盘以便获得与被覆盖内容的交互操作。</p></li>
</ul>

<h4 id="toc_12">3.侦听软键盘的显示隐藏      </h4>

<p>有时候，借助系统本身的机制来实现主窗口的调整并非我们想要的结果，我们可能希望在软键盘显示隐藏的时候，手动的对布局进行修改，以便使软键盘弹出时更加美观。这时就需要对软键盘的显示隐藏进行侦听。       我们可以借助软键盘显示和隐藏时，对主窗口进行了重新布局这个特性来进行侦听。如果我们设置的模式为压缩模式，那么我们可以对布局的onSizeChanged函数进行跟踪，如果为平移模式，那么该函数可能不会被调用。</p>

<p><strong>设置EditText控件默认不弹出软键盘的几种方法</strong>：</p>

<p>1.在AndroidMainfest.xml中选择哪个activity，设置windowSoftInputMode属性为adjustUnspecified|stateHidden例如：</p>

<pre class="line-numbers"><code class="language-java">&lt;activity android:name=&quot;.Main&quot;                  
    android:label=&quot;@string/app_name&quot;                  
    android:windowSoftInputMode=&quot;adjustUnspecified|stateHidden&quot;                  
    android:configChanges=&quot;orientation|keyboardHidden&quot;&gt;            
    &lt;intent-filter&gt;                
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            
    &lt;/intent-filter&gt;        
&lt;/activity&gt;
</code></pre>

<p>2.让EditText失去焦点，使用EditText的clearFocus方法例如：</p>

<pre class="line-numbers"><code class="language-java">EditText edit=(EditText)findViewById(R.id.edit);           
edit.clearFocus();
</code></pre>

<p>3.强制隐藏Android输入法窗口例如：</p>

<pre class="line-numbers"><code class="language-java">EditText edit=(EditText)findViewById(R.id.edit);             
InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);            
imm.hideSoftInputFromWindow(edit.getWindowToken(),0);
</code></pre>

<p>4.例：EditText edit=(EditText)findViewById(R.id.edit);       edit.setInputType(InputType.TYPE_NULL);</p>

<p><strong>显示和隐藏软键盘</strong>：</p>

<pre class="line-numbers"><code class="language-java">tv.setOnClickListener(new OnClickListener() {   
    @Override public void onClick(View v) {  
        InputMethodManager imm = (InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE);  
        //隐藏软键盘 //  
        imm.hideSoftInputFromWindow(tv.getWindowToken(), 0);   
        //显示软键盘 //   
        imm.showSoftInputFromInputMethod(tv.getWindowToken(), 0);   
        //切换软键盘的显示与隐藏   
       imm.toggleSoftInputFromWindow(tv.getWindowToken(), 0, InputMethodManager.HIDE_NOT_ALWAYS);   
        //或者 // imm.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); 
    } 
});
</code></pre>

<p><strong>备注</strong>：</p>

<ul>
<li>1，Eidtext这个控件默认是你点击了它获得焦点之后就会自动地弹出软键盘，前提是你在竖屏的时候。但横盘的时候，不会自动弹出弹出软键盘了。模拟器横屏时默认是打开了键盘的所以就算你用代码来显示软键盘也是显示不出来的，而像真实的手机（有物理键盘（硬件盘）比如G1）就不一样了。可以通过sensor来把画面横屏而并没正在的将键盘打开时就可以通过代码来显示软键盘了。</li>
<li>2,问题在通过代码来使得软键盘显示与隐藏时可以写在某控件的onClick事件里来或者用timer来控制，若你直接在onCreate或onResume里面是不行的，从网上找来的理由说是：软件盘是要在所有view画完才能显示的。</li>
</ul>

<p><strong>情况一</strong>：</p>

<pre class="line-numbers"><code class="language-java">@Override  
protected void onResume() {  
    // TODO Auto-generated method stub  
    super.onResume();  
    InputMethodManager im = ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE));  
    im.showSoftInput(tv, 0);  
    }  
}
</code></pre>

<p><strong>情况二</strong>：</p>

<pre class="line-numbers"><code class="language-java">tv.setOnClickListener(new OnClickListener() {  
@Override  
public void onClick(View arg0) {  
    InputMethodManager im = ((InputMethodManager) getSystemService(INPUT_METHOD_SERVICE));  
    if (im.showSoftInput(tv, InputMethodManager.SHOW_FORCED)) {  
        System.out.println(&quot; return is true fullscreenmode&quot; + im.isFullscreenMode());  
    } else {  
        System.out.println(&quot;return is not true&quot;);  
    }
}});
</code></pre>

<p>********************************************************<strong><em>自定义软键盘的Enter键</em></strong>********************************************************</p>

<p>SDK升级到1.5以后，当文本输入框（EditText及其子类）获得焦点后，会弹出系统自带的软键盘为了实现一些自定义的功能，就稍微研究了下* 当layout中有多个EditText，把每个控件的android:singleLine的属性都被设置成true的情况下，软键盘的Enter键上 的文字会变成“Next”，按下后下个EditText会自动获得焦点（实现了“Next”的功能）；当最后一个控件获得焦点的时候，Enter键上的文 字会变成“Done”，按下后软键盘会自动隐藏起来* 把EditText的Ime Options属性设置成不同的值，Enter键上可以显示不同的文字或图案actionNone : 回车键，按下后光标到下一行actionGo ：  Go，actionSearch ： 一个放大镜actionSend ： SendactionNext ： NextactionDone ： Done，隐藏软键盘，即使不是最后一个文本输入框;</p>

<p><strong>示例：-----------------------------&gt;</strong></p>

<pre class="line-numbers"><code class="language-java">&lt;EditText 
    android:text=&quot;&quot;   
    android:layout_width=&quot;fill_parent&quot;   
    android:layout_height=&quot;wrap_content&quot;  
    android:inputType=&quot;text&quot;  
    android:id=&quot;@+id/edit1&quot;/&gt;  
&lt;EditText 
    android:layout_width=&quot;fill_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:id=&quot;@+id/edit2&quot;  
    android:imeOptions=&quot;actionSend&quot; //发送  
    android:inputType=&quot;text|textEmailAddress&quot;/&gt;  
&lt;EditText 
    android:layout_width=&quot;fill_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:id=&quot;@+id/edit3&quot;  
    android:imeOptions=&quot;actionDone&quot;  //确定  
    android:inputType=&quot;number|numberSigned|numberDecimal&quot;/&gt;
</code></pre>

<p>And <strong>java</strong> 代码如下：</p>

<pre class="line-numbers"><code class="language-java">edit1.setOnEditorActionListener(onEditorActionListener);  
edit2.setOnEditorActionListener(onEditorActionListener);  
edit3.setOnEditorActionListener(onEditorActionListener);  
rivate OnEditorActionListener onEditorActionListener = new OnEditorActionListener() {  
     
    @Override  
    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {  
        switch(actionId){    
        case EditorInfo.IME_NULL:    
            System.out.println(&quot;null for default_content: &quot; + v.getText() );    
            break;    
        case EditorInfo.IME_ACTION_SEND:    
            System.out.println(&quot;action send for email_content: &quot;  + v.getText());    
            break;    
        case EditorInfo.IME_ACTION_DONE:    
            System.out.println(&quot;action done for number_content: &quot;  + v.getText());    
            break;    
        }    
        return true;  
    }  
};
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/6/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867810.html">
                
                  <h1>MySQL数据类型</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>最近学习SQL，掌握其中的数据类型还是很重要的。上课上过SQL Server，Oracle。自己学了MySQL和SQLite，语法和数据类型基本想通，只不过查询方式和操作有很大的区别。大的功能不说，以MySQL为例记录一下数据类型。</p>

<ul>
<li>整数数据类型<br/>
TINYINT、BIT、BOOL————1<br/>
SMALLINT—————————2<br/>
MEDIUMINT—————————3<br/>
INT—————————————4<br/>
BIGINT———————————8<br/></li>
<li>浮点型数据类型<br/>
FLOAT<br/>
DOUBLE<br/>
DECIMAL<br/></li>
<li>常规字符串类型<br/>
[national]char(M)[binary|ASCII|unicode]<br/>
char<br/>
[national]varchar(M)[binary]<br/></li>
<li>TEXT和BLOB类型<br/>
TINYBLOB、TINYTEXT<br/>
BLOB、TEXT<br/>
MEDIUMBLOB、MEDIUMTEXT<br/>
LONGBLOB、LONGTEXT<br/></li>
<li>ENUM和SET类型<br/>
Enum(“value1”,”value2”,………)<br/>
Set(“value1”,”value2”,………)<br/></li>
<li><p>日期和时间数据类型<br/><br/>
DATE            日期，格式YYYY-MM-DD<br/><br/>
TIME            时间，格式HH：MM：SS<br/><br/>
DATETIME        日期和时间，格式YYYY-MM-DD HH：MM：SS<br/><br/>
TIMESTAMP       时间标签，在处理报告时使用显示格式取决于M的值<br/><br/>
YEAR            年份可指定两位数字和四位数字的格式  </p></li>
<li><p>在创建表时，使用哪种数字类型应遵循以下原则：<br/><br/>
（1）选择最小的可用类型，如果数值永远不超过127，则使用TINYINT比使用INT强。<br/><br/>
（2）对于完全都是数字的，可以选择整数类型。<br/><br/>
（3）浮点型用于可能具有小数部分的数，例如货物单价、网上购物交付金额等。</p></li>
<li><p>在创建表和使用字符串类型时应遵循以下原则：<br/><br/>
（1）从速度方面考虑，要选择固定的列，可以使用CHAR类型。<br/><br/>
（2）要节省空间，使用动态的列，可以使用VARCHAR类型。<br/><br/>
（3）要将列中的内容限制在一种选择，可以使用ENUM类型。<br/><br/>
（4）允许在一个列中又多于一个的条目，可以使用SET类型。<br/><br/>
（5）如果要搜索的内容不区分大小写，可以使用TEXT类型。<br/><br/>
（6）如果要搜索的内容需要区分大小写，可以使用BLOB类型。</p></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/5/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='MySQL.html'>MySQL</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867776.html">
                
                  <h1>常用color</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>因为有许多颜色是常用的，避免以后查找，记录在这里进行比对</p>

<p><code>&lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt;&lt;!--白色 --&gt;</code><font color="#FFFFFF"> 白色 </font><br/><br/>
<code>&lt;color name=&quot;ivory&quot;&gt;#FFFFF0&lt;/color&gt;&lt;!--象牙色 --&gt;</code><font color="#FFFFF0"> 象牙色 </font><br/><br/>
<code>&lt;color name=&quot;lightyellow&quot;&gt;#FFFFE0&lt;/color&gt;&lt;!--亮黄色--&gt;</code><font color="#FFFFE0"> 亮黄色 </font><br/><br/>
<code>&lt;color name=&quot;yellow&quot;&gt;#FFFF00&lt;/color&gt;&lt;!--黄色 --&gt;</code><font color="#FFFF00"> 黄色 </font><br/><br/>
<code>&lt;color name=&quot;snow&quot;&gt;#FFFAFA&lt;/color&gt;&lt;!--雪白色 --&gt;</code><font color="#FFFAFA"> 雪白色 </font><br/><br/>
<code>&lt;color name=&quot;floralwhite&quot;&gt;#FFFAF0&lt;/color&gt;&lt;!--花白色 --&gt;</code><font color="#FFFAF0"> 花白色 </font><br/><br/>
<code>&lt;color name=&quot;lemonchiffon&quot;&gt;#FFFACD&lt;/color&gt;&lt;!--柠檬绸色 --&gt;</code><font color="#FFFACD">柠檬绸色</font><br/><br/>
<code>&lt;color name=&quot;cornsilk&quot;&gt;#FFF8DC&lt;/color&gt;&lt;!--米绸色 --&gt;</code><font color="#FFF8DC"> 米绸色 </font><br/><br/>
<code>&lt;color name=&quot;seashell&quot;&gt;#FFF5EE&lt;/color&gt;&lt;!--海贝色 --&gt;</code><font color="#FFF5EE"> 海贝色 </font><br/><br/>
<code>&lt;color name=&quot;lavenderblush&quot;&gt;#FFF0F5&lt;/color&gt;&lt;!--淡紫红 --&gt;</code><font color="#FFF0F5"> 淡紫红 </font><br/><br/>
<code>&lt;color name=&quot;papayawhip&quot;&gt;#FFEFD5&lt;/color&gt;&lt;!--番木色 --&gt;</code><font color="#FFEFD5"> 番木色 </font><br/><br/>
<code>&lt;color name=&quot;blanchedalmond&quot;&gt;#FFEBCD&lt;/color&gt;&lt;!--白杏色 --&gt;</code><font color="#FFEBCD"> 白杏色 </font><br/><br/>
<code>&lt;color name=&quot;mistyrose&quot;&gt;#FFE4E1&lt;/color&gt;&lt;!--浅玫瑰色 --&gt;</code><font color="#FFE4E1"> 浅玫瑰色 </font><br/><br/>
<code>&lt;color name=&quot;bisque&quot;&gt;#FFE4C4&lt;/color&gt;&lt;!--桔黄色 --&gt;</code><font color="#FFE4C4"> 桔黄色 </font><br/><br/>
<code>&lt;color name=&quot;moccasin&quot;&gt;#FFE4B5&lt;/color&gt;&lt;!--鹿皮色 --&gt;</code><font color="#FFE4B5"> 鹿皮色 </font><br/><br/>
<code>&lt;color name=&quot;navajowhite&quot;&gt;#FFDEAD&lt;/color&gt;&lt;!--纳瓦白 --&gt;</code><font color="#FFDEAD"> 纳瓦白 </font><br/><br/>
<code>&lt;color name=&quot;peachpuff&quot;&gt;#FFDAB9&lt;/color&gt;&lt;!--桃色 --&gt;</code><font color="#FFDAB9"> 桃色 </font><br/><br/>
<code>&lt;color name=&quot;gold&quot;&gt;#FFD700&lt;/color&gt;&lt;!--金色 --&gt;</code><font color="#FFD700"> 金色 </font><br/><br/>
<code>&lt;color name=&quot;pink&quot;&gt;#FFC0CB&lt;/color&gt;&lt;!--粉红色 --&gt;</code><font color="#FFC0CB"> 粉红色 </font><br/><br/>
<code>&lt;color name=&quot;lightpink&quot;&gt;#FFB6C1&lt;/color&gt;&lt;!--亮粉红色--&gt;</code><font color="#FFB6C1"> 亮粉红色 </font><br/><br/>
<code>&lt;color name=&quot;orange&quot;&gt;#FFA500&lt;/color&gt;&lt;!--橙色 --&gt;</code><font color="#FFA500"> 橙色 </font><br/><br/>
<code>&lt;color name=&quot;lightsalmon&quot;&gt;#FFA07A&lt;/color&gt;&lt;!--亮肉色 --&gt;</code><font color="#FFA07A"> 亮肉色 </font><br/><br/>
<code>&lt;color name=&quot;darkorange&quot;&gt;#FF8C00&lt;/color&gt;&lt;!--暗桔黄色 --&gt;</code><font color="#FF8C00"> 暗桔黄色 </font><br/><br/>
<code>&lt;color name=&quot;coral&quot;&gt;#FF7F50&lt;/color&gt;&lt;!--珊瑚色 --&gt;</code><font color="#FF7F50"> 珊瑚色 </font><br/><br/>
<code>&lt;color name=&quot;hotpink&quot;&gt;#FF69B4&lt;/color&gt;&lt;!--热粉红色 --&gt;</code><font color="#FF69B4"> 热粉红色 </font><br/><br/>
<code>&lt;color name=&quot;tomato&quot;&gt;#FF6347&lt;/color&gt;&lt;!--西红柿色 --&gt;</code><font color="#FF6347"> 西红柿色 </font><br/><br/>
<code>&lt;color name=&quot;orangered&quot;&gt;#FF4500&lt;/color&gt;&lt;!--红橙色 --&gt;</code><font color="#FF4500"> 红橙色 </font><br/><br/>
<code>&lt;color name=&quot;deeppink&quot;&gt;#FF1493&lt;/color&gt;&lt;!--深粉红色 --&gt;</code><font color="#FF1493"> 深粉红色 </font><br/><br/>
<code>&lt;color name=&quot;fuchsia&quot;&gt;#FF00FF&lt;/color&gt;&lt;!--紫红色 --&gt;</code><font color="#FF00FF"> 紫红色 </font><br/><br/>
<code>&lt;color name=&quot;magenta&quot;&gt;#FF00FF&lt;/color&gt;&lt;!--红紫色 --&gt;</code><font color="#FF00FF"> 红紫色 </font><br/><br/>
<code>&lt;color name=&quot;red&quot;&gt;#FF0000&lt;/color&gt;&lt;!--红色 --&gt;</code><font color="#FF0000"> 红色 </font><br/><br/>
<code>&lt;color name=&quot;oldlace&quot;&gt;#FDF5E6&lt;/color&gt;&lt;!--老花色 --&gt;</code><font color="#FDF5E6"> 老花色 </font><br/><br/>
<code>&lt;color name=&quot;lightgoldenrodyellow&quot;&gt;#FAFAD2&lt;/color&gt;&lt;!--亮金黄色 --&gt;</code><font color="#FAFAD2"> 亮金黄 </font><br/><br/>
<code>&lt;color name=&quot;linen&quot;&gt;#FAF0E6&lt;/color&gt;&lt;!--亚麻色 --&gt;</code><font color="#FAF0E6"> 亚麻色 </font><br/><br/>
<code>&lt;color name=&quot;antiquewhite&quot;&gt;#FAEBD7&lt;/color&gt;&lt;!--古董白 --&gt;</code><font color="#FAEBD7"> 古董白 </font><br/><br/>
<code>&lt;color name=&quot;salmon&quot;&gt;#FA8072&lt;/color&gt;&lt;!--鲜肉色 --&gt;</code><font color="#FA8072"> 鲜肉色 </font><br/><br/>
<code>&lt;color name=&quot;ghostwhite&quot;&gt;#F8F8FF&lt;/color&gt;&lt;!--幽灵白 --&gt;</code><font color="#F8F8FF"> 幽灵白 </font><br/><br/>
<code>&lt;color name=&quot;mintcream&quot;&gt;#F5FFFA&lt;/color&gt;&lt;!--薄荷色 --&gt;</code><font color="#F5FFFA"> 薄荷色 </font><br/><br/>
<code>&lt;color name=&quot;whitesmoke&quot;&gt;#F5F5F5&lt;/color&gt;&lt;!--烟白色 --&gt;</code><font color="#F5F5F5"> 烟白色 </font><br/><br/>
<code>&lt;color name=&quot;beige&quot;&gt;#F5F5DC&lt;/color&gt;&lt;!--米色 --&gt;</code><font color="#F5F5DC"> 米色 </font><br/><br/>
<code>&lt;color name=&quot;wheat&quot;&gt;#F5DEB3&lt;/color&gt;&lt;!--浅黄色 --&gt;</code><font color="#F5DEB3"> 浅黄色 </font><br/><br/>
<code>&lt;color name=&quot;sandybrown&quot;&gt;#F4A460&lt;/color&gt;&lt;!--沙褐色--&gt;</code><font color="#F4A460"> 沙褐色 </font><br/><br/>
<code>&lt;color name=&quot;azure&quot;&gt;#F0FFFF&lt;/color&gt;&lt;!--天蓝色 --&gt;</code><font color="#F0FFFF"> 天蓝色 </font><br/><br/>
<code>&lt;color name=&quot;honeydew&quot;&gt;#F0FFF0&lt;/color&gt;&lt;!--蜜色 --&gt;</code><font color="#F0FFF0"> 蜜色 </font><br/><br/>
<code>&lt;color name=&quot;aliceblue&quot;&gt;#F0F8FF&lt;/color&gt;&lt;!--艾利斯兰 --&gt;</code><font color="#F0F8FF"> 艾利斯兰 </font><br/><br/>
<code>&lt;color name=&quot;khaki&quot;&gt;#F0E68C&lt;/color&gt;&lt;!--黄褐色 --&gt;</code><font color="#F0E68C"> 黄褐色 </font><br/><br/>
<code>&lt;color name=&quot;lightcoral&quot;&gt;#F08080&lt;/color&gt;&lt;!--亮珊瑚色 --&gt;</code><font color="#F08080"> 亮珊瑚色 </font><br/><br/>
<code>&lt;color name=&quot;palegoldenrod&quot;&gt;#EEE8AA&lt;/color&gt;&lt;!--苍麒麟色 --&gt;</code><font color="#EEE8AA"> 苍麒麟色 </font><br/><br/>
<code>&lt;color name=&quot;violet&quot;&gt;#EE82EE&lt;/color&gt;&lt;!--紫罗兰色 --&gt;</code><font color="#EE82EE"> 紫罗兰色 </font><br/><br/>
<code>&lt;color name=&quot;darksalmon&quot;&gt;#E9967A&lt;/color&gt;&lt;!--暗肉色 --&gt;</code><font color="#E9967A"> 暗肉色 </font><br/><br/>
<code>&lt;color name=&quot;lavender&quot;&gt;#E6E6FA&lt;/color&gt;&lt;!--淡紫色 --&gt;</code><font color="#E6E6FA"> 淡紫色 </font><br/><br/>
<code>&lt;color name=&quot;lightcyan&quot;&gt;#E0FFFF&lt;/color&gt;&lt;!--亮青色 --&gt;</code><font color="#E0FFFF"> 亮青色 </font><br/><br/>
<code>&lt;color name=&quot;burlywood&quot;&gt;#DEB887&lt;/color&gt;&lt;!--实木色 --&gt;</code><font color="#DEB887"> 实木色 </font><br/><br/>
<code>&lt;color name=&quot;plum&quot;&gt;#DDA0DD&lt;/color&gt;&lt;!--洋李色 --&gt;</code><font color="#DDA0DD"> 洋李色 </font><br/><br/>
<code>&lt;color name=&quot;gainsboro&quot;&gt;#DCDCDC&lt;/color&gt;&lt;!--淡灰色 --&gt;</code><font color="#DCDCDC"> 淡灰色 </font><br/><br/>
<code>&lt;color name=&quot;crimson&quot;&gt;#DC143C&lt;/color&gt;&lt;!--暗深红色 --&gt;</code><font color="#DC143C"> 暗深红色 </font><br/><br/>
<code>&lt;color name=&quot;palevioletred&quot;&gt;#DB7093&lt;/color&gt;&lt;!--苍紫罗兰色 --&gt;</code><font color="#DB7093"> 苍紫罗兰色 </font><br/><br/>
<code>&lt;color name=&quot;goldenrod&quot;&gt;#DAA520&lt;/color&gt;&lt;!--金麒麟色 --&gt;</code><font color="#DAA520"> 金麒麟色 </font><br/><br/>
<code>&lt;color name=&quot;orchid&quot;&gt;#DA70D6&lt;/color&gt;&lt;!--淡紫色 --&gt;</code><font color="#DA70D6"> 淡紫色 </font><br/><br/>
<code>&lt;color name=&quot;thistle&quot;&gt;#D8BFD8&lt;/color&gt;&lt;!--蓟色 --&gt;</code><font color="#D8BFD8"> 蓟色 </font><br/><br/>
<code>&lt;color name=&quot;lightgray&quot;&gt;#D3D3D3&lt;/color&gt;&lt;!--亮灰色 --&gt;</code><font color="#D3D3D3"> 亮灰色 </font><br/><br/>
<code>&lt;color name=&quot;tan&quot;&gt;#D2B48C&lt;/color&gt;&lt;!--茶色 --&gt;</code><font color="#D2B48C"> 茶色 </font><br/><br/>
<code>&lt;color name=&quot;chocolate&quot;&gt;#D2691E&lt;/color&gt;&lt;!--巧可力色 --&gt;</code><font color="#D2691E"> 巧可力色 </font><br/><br/>
<code>&lt;color name=&quot;peru&quot;&gt;#CD853F&lt;/color&gt;&lt;!--秘鲁色 --&gt;</code><font color="#CD853F"> 秘鲁色 </font><br/><br/>
<code>&lt;color name=&quot;indianred&quot;&gt;#CD5C5C&lt;/color&gt;&lt;!--印第安红 --&gt;</code><font color="#CD5C5C"> 印第安红 </font><br/><br/>
<code>&lt;color name=&quot;mediumvioletred&quot;&gt;#C71585&lt;/color&gt;&lt;!--中紫罗兰色 --&gt;</code><font color="#C71585"> 中紫罗兰色 </font><br/><br/>
<code>&lt;color name=&quot;silver&quot;&gt;#C0C0C0&lt;/color&gt;&lt;!--银色 --&gt;</code><font color="#C0C0C0"> 银色 </font><br/><br/>
<code>&lt;color name=&quot;darkkhaki&quot;&gt;#BDB76B&lt;/color&gt;&lt;!--暗黄褐色 --&gt;</code><font color="#BDB76B"> 暗黄褐色 </font><br/><br/>
<code>&lt;color name=&quot;rosybrown&quot;&gt;#BC8F8F&lt;/color&gt; &lt;!--褐玫瑰红 --&gt;</code><font color="#BC8F8F"> 褐玫瑰红 </font><br/><br/>
<code>&lt;color name=&quot;mediumorchid&quot;&gt;#BA55D3&lt;/color&gt;&lt;!--中粉紫色 --&gt;</code><font color="#BA55D3"> 中粉紫色 </font><br/><br/>
<code>&lt;color name=&quot;darkgoldenrod&quot;&gt;#B8860B&lt;/color&gt;&lt;!--暗金黄色 --&gt;</code><font color="#B8860B"> 暗金黄色 </font><br/><br/>
<code>&lt;color name=&quot;firebrick&quot;&gt;#B22222&lt;/color&gt;&lt;!--火砖色 --&gt;</code><font color="#B22222"> 火砖色 </font><br/><br/>
<code>&lt;color name=&quot;powderblue&quot;&gt;#B0E0E6&lt;/color&gt;&lt;!--粉蓝色 --&gt;</code><font color="#B0E0E6"> 粉蓝色 </font><br/><br/>
<code>&lt;color name=&quot;lightsteelblue&quot;&gt;#B0C4DE&lt;/color&gt;&lt;!--亮钢兰色 --&gt;</code><font color="#B0C4DE"> 亮钢兰色 </font><br/><br/>
<code>&lt;color name=&quot;paleturquoise&quot;&gt;#AFEEEE&lt;/color&gt;&lt;!--苍宝石绿 --&gt;</code><font color="#AFEEEE"> 苍宝石绿 </font><br/><br/>
<code>&lt;color name=&quot;greenyellow&quot;&gt;#ADFF2F&lt;/color&gt;&lt;!--黄绿色 --&gt;</code><font color="#ADFF2F"> 黄绿色 </font><br/><br/>
<code>&lt;color name=&quot;lightblue&quot;&gt;#ADD8E6&lt;/color&gt;&lt;!--亮蓝色 --&gt;</code><font color="#ADD8E6"> 亮蓝色 </font><br/><br/>
<code>&lt;color name=&quot;darkgray&quot;&gt;#A9A9A9&lt;/color&gt;&lt;!--暗灰色 --&gt;</code><font color="#A9A9A9"> 暗灰色 </font><br/><br/>
<code>&lt;color name=&quot;brown&quot;&gt;#A52A2A&lt;/color&gt;&lt;!--褐色 --&gt;</code><font color="#A52A2A"> 褐色 </font><br/><br/>
<code>&lt;color name=&quot;sienna&quot;&gt;#A0522D&lt;/color&gt;&lt;!--赭色 --&gt;</code><font color="#A0522D"> 赭色 </font><br/><br/>
<code>&lt;color name=&quot;darkorchid&quot;&gt;#9932CC&lt;/color&gt;&lt;!--暗紫色--&gt;</code><font color="#9932CC"> 暗紫色 </font><br/><br/>
<code>&lt;color name=&quot;palegreen&quot;&gt;#98FB98&lt;/color&gt;&lt;!--苍绿色 --&gt;</code><font color="#98FB98"> 苍绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkviolet&quot;&gt;#9400D3&lt;/color&gt;&lt;!--暗紫罗兰色 --&gt;</code><font color="#9400D3"> 暗紫罗兰色 </font><br/><br/>
<code>&lt;color name=&quot;mediumpurple&quot;&gt;#9370DB&lt;/color&gt;&lt;!--中紫色 --&gt;</code><font color="#9370DB"> 中紫色 </font><br/><br/>
<code>&lt;color name=&quot;lightgreen&quot;&gt;#90EE90&lt;/color&gt;&lt;!--亮绿色 --&gt;</code><font color="#90EE90"> 亮绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkseagreen&quot;&gt;#8FBC8F&lt;/color&gt;&lt;!--暗海兰色 --&gt;</code><font color="#8FBC8F"> 暗海兰色 </font><br/><br/>
<code>&lt;color name=&quot;saddlebrown&quot;&gt;#8B4513&lt;/color&gt;&lt;!--重褐色 --&gt;</code><font color="#8B4513"> 重褐色 </font><br/><br/>
<code>&lt;color name=&quot;darkmagenta&quot;&gt;#8B008B&lt;/color&gt;&lt;!--暗洋红 --&gt;</code><font color="#8B008B"> 暗洋红 </font><br/><br/>
<code>&lt;color name=&quot;darkred&quot;&gt;#8B0000&lt;/color&gt;&lt;!--暗红色 --&gt;</code><font color="#8B0000"> 暗红色 </font><br/><br/>
<code>&lt;color name=&quot;blueviolet&quot;&gt;#8A2BE2&lt;/color&gt;&lt;!--紫罗兰蓝色 --&gt;</code><font color="#8A2BE2"> 紫罗兰蓝色 </font><br/><br/>
<code>&lt;color name=&quot;lightskyblue&quot;&gt;#87CEFA&lt;/color&gt;&lt;!--亮天蓝色 --&gt;</code><font color="#87CEFA"> 亮天蓝色 </font><br/><br/>
<code>&lt;color name=&quot;skyblue&quot;&gt;#87CEEB&lt;/color&gt;&lt;!--天蓝色 --&gt;</code><font color="#87CEEB"> 天蓝色 </font><br/><br/>
<code>&lt;color name=&quot;gray&quot;&gt;#808080&lt;/color&gt;&lt;!--灰色 --&gt;</code><font color="#808080"> 灰色 </font><br/><br/>
<code>&lt;color name=&quot;olive&quot;&gt;#808000&lt;/color&gt;&lt;!--橄榄色 --&gt;</code><font color="#808000">橄榄色</font><br/><br/>
<code>&lt;color name=&quot;purple&quot;&gt;#800080&lt;/color&gt;&lt;!--紫色 --&gt;</code><font color="#800080"> 紫色 </font><br/><br/>
<code>&lt;color name=&quot;maroon&quot;&gt;#800000&lt;/color&gt;&lt;!--粟色 --&gt;</code><font color="#800000"> 粟色 </font><br/><br/>
<code>&lt;color name=&quot;aquamarine&quot;&gt;#7FFFD4&lt;/color&gt;&lt;!--碧绿色--&gt;</code><font color="#7FFFD4"> 碧绿色 </font><br/><br/>
<code>&lt;color name=&quot;chartreuse&quot;&gt;#7FFF00&lt;/color&gt;&lt;!--黄绿色 --&gt;</code><font color="#7FFF00"> 黄绿色 </font><br/><br/>
<code>&lt;color name=&quot;lawngreen&quot;&gt;#7CFC00&lt;/color&gt;&lt;!--草绿色 --&gt;</code><font color="#7CFC00"> 草绿色 </font><br/><br/>
<code>&lt;color name=&quot;mediumslateblue&quot;&gt;#7B68EE&lt;/color&gt;&lt;!--中暗蓝色 --&gt;</code><font color="#7B68EE"> 中暗蓝色 </font><br/><br/>
<code>&lt;color name=&quot;lightslategray&quot;&gt;#778899&lt;/color&gt;&lt;!--亮蓝灰 --&gt;</code><font color="#778899"> 亮蓝灰 </font><br/><br/>
<code>&lt;color name=&quot;slategrey&quot;&gt;#708090&lt;/color&gt;&lt;!--灰石色 --&gt;</code><font color="#708090"> 灰石色 </font><br/><br/>
<code>&lt;color name=&quot;olivedrab&quot;&gt;#6B8E23&lt;/color&gt;&lt;!--深绿褐色 --&gt;</code><font color="#6B8E23"> 深绿褐色 </font><br/><br/>
<code>&lt;color name=&quot;slateblue&quot;&gt;#6A5ACD&lt;/color&gt;&lt;!--石蓝色 --&gt;</code><font color="#6A5ACD"> 石蓝色 </font><br/><br/>
<code>&lt;color name=&quot;dimgray&quot;&gt;#696969&lt;/color&gt;&lt;!--暗灰色 --&gt;</code><font color="#696969"> 暗灰色 </font><br/><br/>
<code>&lt;color name=&quot;mediumaquamarine&quot;&gt;#66CDAA&lt;/color&gt;&lt;!--中绿色 --&gt;</code><font color="#66CDAA"> 中绿色 </font><br/><br/>
<code>&lt;color name=&quot;cornflowerblue&quot;&gt;#6495ED&lt;/color&gt;&lt;!--菊兰色 --&gt;</code><font color="#6495ED"> 菊兰色 </font><br/><br/>
<code>&lt;color name=&quot;cadetblue&quot;&gt;#5F9EA0&lt;/color&gt;&lt;!--军兰色 --&gt;</code><font color="#5F9EA0"> 军兰色 </font><br/><br/>
<code>&lt;color name=&quot;darkolivegreen&quot;&gt;#556B2F&lt;/color&gt;&lt;!--暗橄榄绿  --&gt;</code><font color="#556B2F"> 暗橄榄绿 </font><br/><br/>
<code>&lt;color name=&quot;indigo&quot;&gt;#4B0082&lt;/color&gt;&lt;!--靛青色 --&gt;</code><font color="#4B0082"> 靛青色 </font><br/><br/>
<code>&lt;color name=&quot;mediumturquoise&quot;&gt;#48D1CC&lt;/color&gt;&lt;!--中绿宝石 --&gt;</code><font color="#48D1CC"> 中绿宝石 </font><br/><br/>
<code>&lt;color name=&quot;darkslateblue&quot;&gt;#483D8B&lt;/color&gt;&lt;!--暗灰蓝色 --&gt;</code><font color="#483D8B"> 暗灰蓝色 </font><br/><br/>
<code>&lt;color name=&quot;steelblue&quot;&gt;#4682B4&lt;/color&gt;&lt;!--钢兰色 --&gt;</code><font color="#4682B4"> 钢兰色 </font><br/><br/>
<code>&lt;color name=&quot;royalblue&quot;&gt;#4169E1&lt;/color&gt;&lt;!--皇家蓝 --&gt;</code><font color="#4169E1"> 皇家蓝 </font><br/><br/>
<code>&lt;color name=&quot;turquoise&quot;&gt;#40E0D0&lt;/color&gt;&lt;!--青绿色 --&gt;</code><font color="#40E0D0"> 青绿色 </font><br/><br/>
<code>&lt;color name=&quot;mediumseagreen&quot;&gt;#3CB371&lt;/color&gt;&lt;!--中海蓝 --&gt;</code><font color="#3CB371"> 中海蓝 </font><br/><br/>
<code>&lt;color name=&quot;limegreen&quot;&gt;#32CD32&lt;/color&gt;&lt;!--橙绿色 --&gt;</code><font color="#32CD32"> 橙绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkslategray&quot;&gt;#2F4F4F&lt;/color&gt;&lt;!--暗瓦灰色 --&gt;</code><font color="#2F4F4F"> 暗瓦灰色 </font><br/><br/>
<code>&lt;color name=&quot;seagreen&quot;&gt;#2E8B57&lt;/color&gt;&lt;!--海绿色 --&gt;</code><font color="#2E8B57"> 海绿色 </font><br/><br/>
<code>&lt;color name=&quot;forestgreen&quot;&gt;#228B22&lt;/color&gt;&lt;!--森林绿 --&gt;</code><font color="#228B22"> 森林绿 </font><br/><br/>
<code>&lt;color name=&quot;lightseagreen&quot;&gt;#20B2AA&lt;/color&gt;&lt;!--亮海蓝色 --&gt;</code><font color="#20B2AA"> 亮海蓝色 </font><br/><br/>
<code>&lt;color name=&quot;dodgerblue&quot;&gt;#1E90FF&lt;/color&gt;&lt;!--闪兰色 --&gt;</code><font color="#1E90FF"> 闪兰色 </font><br/><br/>
<code>&lt;color name=&quot;midnightblue&quot;&gt;#191970&lt;/color&gt;&lt;!--中灰兰色 --&gt;</code><font color="#191970"> 中灰兰色 </font><br/><br/>
<code>&lt;color name=&quot;aqua&quot;&gt;#00FFFF&lt;/color&gt;&lt;!--浅绿色 --&gt;</code><font color="#00FFFF"> 浅绿色 </font><br/><br/>
<code>&lt;color name=&quot;cyan&quot;&gt;#00FFFF&lt;/color&gt;&lt;!--青色 --&gt;</code><font color="#00FFFF"> 青色 </font><br/><br/>
<code>&lt;color name=&quot;springgreen&quot;&gt;#00FF7F&lt;/color&gt;&lt;!--春绿色--&gt;</code><font color="#00FF7F"> 春绿色 </font><br/><br/>
<code>&lt;color name=&quot;lime&quot;&gt;#00FF00&lt;/color&gt;&lt;!--酸橙色 --&gt;</code><font color="#00FF00"> 酸橙色 </font><br/><br/>
<code>&lt;color name=&quot;mediumspringgreen&quot;&gt;#00FA9A&lt;/color&gt;&lt;!--中春绿色 --&gt;</code><font color="#00FA9A"> 中春绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkturquoise&quot;&gt;#00CED1&lt;/color&gt;&lt;!--暗宝石绿 --&gt;</code><font color="#00CED1"> 暗宝石绿 </font><br/><br/>
<code>&lt;color name=&quot;deepskyblue&quot;&gt;#00BFFF&lt;/color&gt;&lt;!--深天蓝色 --&gt;</code><font color="#00BFFF"> 深天蓝色 </font><br/><br/>
<code>&lt;color name=&quot;darkcyan&quot;&gt;#008B8B&lt;/color&gt;&lt;!--暗青色 --&gt;</code><font color="#008B8B"> 暗青色 </font><br/><br/>
<code>&lt;color name=&quot;teal&quot;&gt;#008080&lt;/color&gt;&lt;!--水鸭色 --&gt;</code><font color="#008080"> 水鸭色 </font><br/><br/>
<code>&lt;color name=&quot;green&quot;&gt;#008000&lt;/color&gt;&lt;!--绿色 --&gt;</code><font color="#008000"> 绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkgreen&quot;&gt;#006400&lt;/color&gt;&lt;!--暗绿色 --&gt;</code><font color="#006400"> 暗绿色 </font><br/><br/>
<code>&lt;color name=&quot;blue&quot;&gt;#0000FF&lt;/color&gt;&lt;!--蓝色 --&gt;</code><font color="#0000FF"> 蓝色 </font><br/><br/>
<code>&lt;color name=&quot;mediumblue&quot;&gt;#0000CD&lt;/color&gt;&lt;!--中兰色 --&gt;</code><font color="#0000CD"> 中兰色 </font><br/><br/>
<code>&lt;color name=&quot;darkblue&quot;&gt;#00008B&lt;/color&gt;&lt;!--暗蓝色 --&gt;</code><font color="#00008B"> 暗蓝色 </font><br/><br/>
<code>&lt;color name=&quot;navy&quot;&gt;#000080&lt;/color&gt;&lt;!--海军色 --&gt;</code><font color="#000080"> 海军色 </font><br/><br/>
<code>&lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt;&lt;!--黑色 --&gt;</code><font color="#000000"> 黑色 </font>  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/5/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='UI.html'>UI</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867740.html">
                
                  <h1>Android反编译</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>自学Android有段时间了，发现反编译别人的apk读别人的代码，是个提高的好方式，还能获取一些好的图片资源。网上找了些方式，发现过程和方式有一些出路，还是自己写个blog来记录一下。</p>

<h2 id="toc_1">反编译工具</h2>

<p>反编译的工具，就选用大家通用的<a href="https://ibotpeaches.github.io/Apktool/install/" title="ApkTool">Apktool</a>，<a href="https://github.com/pxb1988/dex2jar" title="dex2jar">dex2jar</a>和<a href="http://jd.benow.ca" title="JD-GUI">JD-GUI</a>。（超链接进入其官网）<br/><br/>
这三个软件Apktool的安装稍微麻烦点，其他都还好，基本上下载下来解压了就能用。</p>

<ul>
<li><p>Apktool(按照官网安装方式，我的是Mac系统，其他系统同样按照官网方式安装)</p>
<ul>
<li>Download Mac <a href="https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/osx/apktool">wrapper script</a> (Right click, Save Link As apktool)</li>
<li>Download apktool-2 (<a href="https://bitbucket.org/iBotPeaches/apktool/downloads">find newest here</a>)</li>
<li>Rename downloaded jar to apktool.jar</li>
<li>Move both files (apktool.jar &amp; apktool) to /usr/local/bin (root needed)</li>
<li>Make sure both files are executable (chmod +x)</li>
<li>Try running apktool via cli</li>
</ul></li>
<li><p>基本上按照上面的6个步骤就ok了。虽然很简单，还是解释下吧。</p>
<ol>
<li>是下载一个shell脚本，保存的名字就是”apktool”,不要带.sh后缀。可以复制到sublimetext，然后保存下。 </li>
<li>下载最新的apktool-2</li>
<li>将所下载的jar文件改名为”apktool.jar” </li>
<li>将shell脚本”apktool”和”apktool.jar”放到 “/usr/local/bin”目录下</li>
<li>增加这两个文件可执行权限，chmod a+x file</li>
<li>执行shell apktool就ok了。</li>
</ol></li>
</ul>

<p>安装完毕后可以运行apktool -v查看版本信息</p>

<ul>
<li>dex2jar和JD-GUI
<ul>
<li>这两个直接下载，然后解压缩就ok</li>
</ul></li>
</ul>

<h2 id="toc_2">反编译</h2>

<p>为了检测下是否能破解，我们先用Apktool反编译，免得我们最后一场空。（只有Apktool能反编译／回编译，我们的破解才有意义）。 </p>

<ul>
<li>新建个apk文件夹，将待破译的apk放进去，之后进到这个目录运行命令: <code>apktool d test.apk</code></li>
<li><code>apktool b hongbao</code> (hongbao 就是反编译出来的文件夹)</li>
<li>回编译apk过程中会生成build和dist文件夹，编译出来的apk在dist目录下，打开build/apk文件夹会发现少了original文件夹下的META-INF文件夹，也就意味着dist里的apk文件是没有签名的。</li>
<li>我们要用dex2jar将apk转成jar文件，实质是将apk里的classes.dex转成jar。将dex2jar里的d2j_invoke.sh／d2j-dex2jar.sh增加可执行权限。然后进到dex2jar这个文件夹下运行: <code>./d2j-dex2jar.sh /Users/yanzi/apk/hongbao.apk</code> 得到hongbao-dex2jar.jar文件。</li>
<li>打开JD-GUI，将hongbao-dex2jar.jar拖进去就看到源码了。 <br/>
通过看Java源码对比smali文件，修改后回编译就ok了！</li>
</ul>

<h2 id="toc_3">添加签名</h2>

<ul>
<li>回编译后的apk是安装不成功的，总是提示 <br/>
Failure [INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION] <br/>
实质是没签名。
<ol>
<li>生成签名 <code>keytool -genkey -keystore hongbao.keystore -keyalg RSA -validity 10000 -alias hongbao</code></li>
<li>为apk增加签名 <code>jarsigner -digestalg SHA1 -sigalg MD5withRSA -tsa -verbose -keystore hongbao.keystore -signedjar hongbao-signed.apk hongbao.apk hongbao</code></li>
<li>注意 
<ol>
<li>最后的”hongbao”就是－alias后面带的，必须保持一致。</li>
<li>如果不带-digestalg SHA1 -sigalg MD5withRSA签名后的apk安装也是不成功的，说INSTALL_PARSE_FAILED_NO_CERTIFICATES的错误，如果不带-tsa会报一个时间方面的警告。</li>
</ol></li>
</ol></li>
</ul>

<p><strong>使用apktool是为了能将修改后的代码或者资源重新回编译，改进效果。如果只是单纯想要apk里面的代码，还有一种方式更加简单。</strong></p>

<ul>
<li>修改apk后缀名为.zip</li>
<li>解压apk.zip</li>
<li>拷贝解压文件夹中的classes.dex文件至dex2jar工具存放目录下</li>
<li>终端进入dex2jar目录，执行<code>./d2j-dex2jar.sh classes.dex</code></li>
<li>生成classes.dex.dex2jar.jar文件</li>
<li>可以通过JD-GUI工具直接打开查看jar文件中的代码</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/5/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867705.html">
                
                  <h1>CentOS7搭建Git</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Git是一个好东西，分布式管理的方式的确使管理代码变得方便很多。而且git致富和linux之父是同一个人，在linux上搭建git十分简单。感觉除了用GitHub公有仓库外，自己搭建一个私有的仓库来储存自己的代码还是蛮有必要的。</p>

<blockquote>
<p>git作为一个 分布式代码仓库，其实没有server和client的概念，每个机器上保存的都是一份完整的代码库，不过貌似是大团队的话，为了管理方便，会在服务器装一个管理的东东，俺是小团队，有需要再去研究，小团队手动就口以了</p>
</blockquote>

<h2 id="toc_1">服务端安装Git</h2>

<ul>
<li>安装Git <code># yum -y install git</code></li>
<li>创建一个裸仓库 
<code>
cd /srv<br/>
mkdir GitServer<br/>
cd GitServer<br/>
cd MyBlog<br/>
git init --bare MyBlog.git //初始化空的Git版本库
</code></li>
<li>创建一个git用户
<code>
useradd gitUser<br/>
passwd gitUser
</code></li>
<li>然后把GitServer文件夹赋予git用户  <code>chown -R gitUser: gitUser GitServer</code></li>
</ul>

<p><strong>至此，服务端的git搭建就完毕了。</strong></p>

<h2 id="toc_2">客户端操作Git</h2>

<ul>
<li>在本机创建一个文件夹，进入文件夹</li>
<li>直接clone <code>git clone gitUser@***.**.**.**:/srv/GitServer/project.git //**.**.**.**为你服务器的外网ip</code> </li>
<li>输入git的密码</li>
<li>进入project.git</li>
<li>创建一个测试文件 <code>vim test.txt</code></li>
<li>输入 Hello Git World!</li>
<li>查看状态 <code>git status</code> 看到待添加的文件test.txt</li>
<li>添加test.txt让git追踪 <code>git add test.txt</code></li>
<li>提交到版本库，并写上备注信息 <code>git commit test.txt -m &#39;jest a test&#39;</code></li>
<li>把他推送到服务器的版本库中去，要输入密码 <code>git push origin master</code></li>
</ul>

<h2 id="toc_3">服务端查看</h2>

<ul>
<li>由于在服务器端创建版本库时用的是<code>git init --bare project.git</code>加了个–-bare就是创建一个裸仓库，没有工作区，所以这里只记录了文件的改动，要看是不是同步过来了，需要在git clone一次，看是不是这一次有test.txt啦</li>
<li><code>git clone gitUser@127.0.0.1:/srv/GitServer/MyBlog.git</code></li>
<li>输入密码后，下载代码，然后进入仓库查看果然master分支已经有test.txt，打开文件，发现内容一致。</li>
<li>git log查看提交记录,作者时间以及备注信息一致</li>
<li>啦啦啦，私有git搭建完成</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/4/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867665.html">
                
                  <h1>改善C++代码的建议</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">学习C++代码的一些建议，记录一下</h2>

<ul>
<li><strong>不要让main函数返回void()</strong> ----<code>int main()</code>和<code>int main（int argc，char *argv[]）</code>这两个都是可行的;</li>
<li><strong>FALSE/TRUE是int型，false/true是bool型</strong></li>
<li><strong>表达式****<mark>****，最好写成number</mark>nValue，例0==nValue</strong></li>
<li><strong>运算符优先级问题要考虑清楚</strong></li>
<li><strong>使用宏定义时，要用括号完备地保护每一个参数</strong></li>
<li><strong>指针变量一定要初始化</strong></li>
<li><strong>将逗号分隔表达式一定要规范</strong>，在条件和循环语句中，表达式的值采用的是最右边的结果;</li>
<li><strong>时刻提防内存溢出。</strong>当信息来源不可靠时，要用到内存缓冲区时，必须提高警惕，必须知道内存缓冲区的总长度，并检验内存缓冲区；</li>
<li><strong>拒绝晦涩难懂的函数指针定义，拒绝函数定义中成堆的括号</strong>,使用typedef让函数指针更加直观，易维护；</li>
<li><strong>避免包含相同的头文件在不同文件中</strong></li>
</ul>

<pre>
{
   #ifndef _PROJECT_PATH_FILE_H_

   #define _PROJECT_PATH_FILE_H_
   ……//声明
   #endif 
};
</pre>

<ul>
<li><strong>优化结构体中元素的布局</strong></li>
</ul>

<pre>
{
    a.结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
    b.结构体每个成员相对于结构体首地址的偏移量（offset）都是成员自身大小的整数倍，如有需要编译器会在成员之间加上填充字节;
    c.结构体的总大小为结构体最宽基本类型大小的整数倍，如有需要，编译器会在最末一个成员之后加上填充字节。
*把结构体中得变量按照类型大小从小到大依次声明，尽量减少中间的填充字节。
}
#pragma pack(1)
struct A
{
   int a;
   char b;
   short c;
}
</pre>

<ul>
<li><strong>将强制转型减到最少</strong>  不同类型的指针之间不能相互转换（避免在内存访问时存在隐患）<br/>
<ul>
<li>const_cast<T*>(a)：目的简单明确，使用情形比较单一，易于掌握;</li>
<li>dynamic_cast<T*>(a):实现慢，代价大；</li>
<li>reinterpret_cast<T*>(a):不安全；</li>
<li>static_cast<T*>(a):不安全</li>
</ul></li>
<li><strong>优先使用前缀操作符</strong> 前缀操作符的效率要优于后缀操作符（整形，长整形可忽略；用户自定义类型，优先使用前缀操作符。）</li>
<li><strong>掌握变量定义的位置与时机</strong> 控制变量的作用域，适当位置可减少操作时间；</li>
<li><strong>小心typedef使用中的陷阱</strong> 容易与宏定义混淆，typedef声明多个指针对象，形式直观，方便省事。请注意区分typedef与#define之间的不同,不要用理解宏的思维方式对待typedef，typedef声明的新名字具有一定的封装性，更易定义变量。同时还要注意它是一个无“现实意义”的存储类关键字;</li>
<li><strong>尽量不要使用可变参数</strong> 缺乏类型检查，类型安全性无从谈起；必须通过其他方式告诉函数所传递的类型，以及参数个数；不支持自定义数据类型;</li>
<li><strong>慎用goto</strong> 没有带来太大的正面作用，相反却容易破坏程序的结构性，影响了程序的可读性;</li>
<li><strong>提防隐式转换带来的麻烦</strong> 影响数据的精确性，编译器无法正常接受；（为防止精度损失，类型总是被提升为较宽的类型；所有含有小于整形的算术表达式在计算之前其类型都会被转换成整形）
<ul>
<li>使用非C/C++关键字的具名函数，用operator as_T()替换operato  T();</li>
<li>为单参数的构造函数加上explicit关键字;</li>
</ul></li>
<li><strong>正确区分void与void</strong> 如果函数没有返回值，那么应将其声明为void类型（不加返回值类型限定的函数，就会被编译器作为返回整型值处理）；如果函数无参数，那么声明函数参数为void；任何类型的指针都可以赋值给void*；void指针进行算法操作是不合法的;</li>
<li><strong>明白在C++中如何使用C</strong> 要想在C++中使用大量现成的C程序库，实现C++与C的混编，必须了解extern“C”是怎么回事，明白“C”的使用方式;</li>
<li><strong>使用memcpy（）系列</strong> 包含memcpy（），memset（），memcmp（），要注意对象是不是POD。</li>
<li><strong>尽量用new/delete代替malloc/free</strong> malloc/free是语言的标准函数库，而new/delete是C++的运算符。malloc/free无法满足创建动态对象的要求；new不仅能够完成动态内存分配，还能完成初始化工作，稳妥的构造对象；delete不仅能完成内存的释放，还能对对象进行清理。</li>
<li><strong>灵活地使用不同风格的注释</strong> 版权和版本声明，使用C风格的/* */;内嵌注释用//；宏尾端的注释用/* */</li>
<li><strong>尽量使用C++标准的iostream</strong> C++ iostream程序库中的类与C stream函数虽然各有优点，但是一般推荐使用前者，为类型安全与可扩充性对于我们更有吸引力，所以建议使用iostream;</li>
<li><strong>尽量采用C++风格的强制类型转换</strong></li>
<li><strong>尽量用const、enum、inline替换#define</strong> 宏定义并不在编译范围内，使得程序难于分析，难于调试；使用常量可以避免目标码的多分复制；用const修饰指针建议使用更加高级的const string形式。对于简单的常量，应该尽量使用const对象或枚举类型的数据，避免使用#define。对于形似函数的宏，尽量使用内联函数，避免使用#define。尽量将工作交给编译器而不是预处理器;</li>
<li><strong>用引用代替指针</strong> 从编码实践角度来看，指针与引用并无太大不同。在大多数情况下，指针可用索引类型完美代替，并且其实现代码更简洁清晰，更加易于理解</li>
<li><strong>区分内存分配的方式</strong> 栈效率高一点，而堆较灵活</li>
<li><strong>new/delete与new[]/delete[]必须配对使用</strong></li>
<li><strong>区分new的三种形态</strong></li>
<li><strong>new内存失败后的正确处理</strong> 当使用new申请一块内存失败时，抛出异常std::bad_alloc是C++标准中规定的标准行为，所以推荐使用try{p=new int[SIZE];}catch(std::bad_alloc){…}的处理方式</li>
<li><strong>明晰class与struct之间的区别</strong> 
<ul>
<li>关于使用大括号初始化：class与struct定义了构造函数就不能用大括号初始化，如果没有定义struct可以用大括号初始化，而class只有在所有成员变量全是public情况下才能用大括号初始化;</li>
<li>class默认成员访问权限是private，struct中则是public</li>
<li>class继承是private，struct继承是public</li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/4/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='C++.html'>C++</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867630.html">
                
                  <h1>如何搭建LAMP环境</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>由于买了阿里云学生机，就想着自己在服务器上搭建网站。首先给服务器搭建LAMP环境，以后搭建网站就有着落了。</p>

<h2 id="toc_1">安装Apache服务</h2>

<ul>
<li>安装 <code>yum -y install httpd</code></li>
<li>开启apache服务 <code>systemctl start httpd.service</code></li>
<li>设置apache服务开机启动 <code>systemctl enable httpd.service</code></li>
<li>验证Apache服务是否安装成功 在本机浏览器中输入阿里云服务器的外网ip，出现Testing 123... Apache页面说明安装成功。</li>
</ul>

<h2 id="toc_2">安装PHP</h2>

<ul>
<li>安装 <code>yum -y install php</code></li>
<li>重启Apache服务 <code>systemctl restart httpd.service</code>或者<code>systemctl restart httpd</code></li>
<li>写一个php文件在浏览器中运行一次 <code>vi /var/www/html/info.php</code>--------输入<code>&lt;?php phpinfo(); ?&gt;</code>-------在本机浏览器中输入ip/info.php,出现php version说明php安装成功。</li>
</ul>

<h2 id="toc_3">安装MySql</h2>

<p>CentOS 7.0 安装MariaDB，这是MySql的一个分支，是由MySql的创始人Michael Widenius带领开发的，团队依旧，所以两者使用基本没有太大的区别。</p>

<ul>
<li>安装 <code>yum install mariadb-server -y</code></li>
<li>开启MySQL服务 <code>systemctl start mariadb.service</code></li>
<li>设置开机启动MySQL服务 <code>systemctl enable mariadb.service</code></li>
<li>设置root帐户的密码 <code>mysql_secure_installation</code></li>
<li>之后会让你输入当前mysql的密码，直接Enter。之后输入新密码，以及确认密码，后面的内容看你的情况进行选择是或者否。</li>
<li>想要确认密码是否已经改变，可以输入<code>mysql -uroot -p</code>进行测试。</li>
</ul>

<h2 id="toc_4">将PHP和MySQL关联起来</h2>

<p>输入<code>yum -y install php-mysql</code></p>

<h2 id="toc_5">安装常用的PHP模块</h2>

<ul>
<li>安装：<code>yum -y install php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel</code></li>
<li>重启Apache服务 <code>systemctl restart httpd.service</code></li>
</ul>

<h2 id="toc_6">结束</h2>

<p>然后，再次在浏览器中运行info.php，你会看到安装的模块的信息。<br/>
至此，LAMP环境就搭建好了。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/4/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207867585.html">
                
                  <h1>Github pages和Jekyll搭建</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>最近才发现Github原来也可以支持博客的搭建，利用Jekyll这个静态网站生成器，可以很快搭建一个博客来记录自己开发学习生活的一些知识点和经验。之前的WordPress用的不怎么顺手，一台服务器既要搭建博客，又要玩些其他小应用还是不怎么方便，所以既然有了这个免费的技术分享区还是可以好好利用的。  </p>

<h2 id="toc_1">Step 1.Github选址</h2>

<p><a href="https://github.com" title="GitHub">GitHub</a>是拿来干什么的就不多说了,<a href="https://help.github.com/articles/using-jekyll-as-a-static-site-generator-with-github-pages/" title="Github Pages">GitHub Pages</a>(Website for you and your project.),这就是我们所需要搭建的博客了，通过Git方式对博客进行管理，这种方式免费，安全，快捷。</p>

<ul>
<li>新建repository名为username.github.io，username为你github的用户名。那么他的master分支上的文件就能在username.github.io的根目录访问到。</li>
<li>创建仓库后，进入Setting，拉动滚动条至GitHub Pages那一栏，点击Automatic page generator.</li>
<li>进入创建用户页面，可以自己编辑，也可以从readme加载。</li>
<li>点击continue to layout，继续选择主题。选好后点击PUBLISH，发布，整个技术博客站点的CSS，HTML和IMG都会导入到你的仓库中。</li>
<li><p>最后在浏览器中输入username.github.io就可以进入到你的博客主页中了。<br/><br/>
ps.觉得域名丑的，或者不想用这个域名的，可以花钱买个域名或者把自己已经买的域名映射过去。在仓库根路径下创建一个名为&quot;CNAME&quot;的文件，注意没有后缀。文件中填入你所要指向的域名。这样访问 <a href="http://username.github.io">http://username.github.io</a> 时浏览器就接收到重定向指令,跳转到CNAME里面指定的域名去了。接着还需要到你域名的服务商那里修改域名的记录，通过在终端输入<code>ping username.github.io</code>可以获得博客的ip，添加&quot;www&quot;和&quot;@&quot;两条记录，这样就完成修改域名了。</p>
<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" title="Git">Git教程-廖雪峰</a><br/><br/>
<a href="http://www.linuxidc.com/Linux/2014-09/106230p2.htm" title="Git">Git使用教程图文详解</a></p></li>
</ul>

<h2 id="toc_2">Step 2.本地环境搭建</h2>

<p>这一步不是必须的，但是强烈建议完成。这样，在博客发布之前方便调试检验一下。  </p>

<ul>
<li>首先更新本机上的ruby。
<ul>
<li>安装RVM
<ul>
<li><code>$ curl -L get.rvm.io | bash -s stable</code></li>
<li><code>$ source ~/.bashrc</code></li>
<li><code>$ source ~/.bash_profile</code></li>
<li>测试安装是否正常<code>rvm -v</code></li>
</ul></li>
<li>用RVM升级Ruby
<ul>
<li>查看当前ruby版本<code>$ ruby -v</code></li>
<li>列出已知的ruby版本<code>$ rvm list known</code></li>
<li>安装最新版本ruby<code>$ rvm install x.x.x</code></li>
<li>查看当前ruby版本<code>$ ruby -v</code></li>
</ul></li>
</ul></li>
<li>安装Bundle
<ul>
<li><code>$ gem install bundle</code></li>
<li>在根目录下创建一个叫Gemfile的文件，注意没有后缀</li>
<li>在Gemfile文件中输入
<code>source &#39;https://gems.ruby-china.org//&#39;</code>
<code>gem &#39;github-pages&#39;</code></li>
<li>保存后，在命令行中执行<code>$ bundle install</code></li>
<li><code>$ bundle update</code></li>
<li>启动转化和本地服务 <code>$ bundle exec jekyll serve</code></li>
</ul></li>
<li>安装Jekyll
<ul>
<li><code>gem install jekyll</code></li>
<li>在你希望存放博客的目录下输入<code>jekyll new your-site-name</code></li>
<li>进入<code>cd your-site-name</code></li>
<li>启动转化和本地服务 <code>$ bundle exec jekyll serve --watch</code></li>
<li>打开浏览器<a href="http://localhost:4000%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%9C%AC%E5%9C%B0%E8%BF%9B%E8%A1%8C%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%B0%83%E8%AF%95%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E4%BA%86%E3%80%82">http://localhost:4000就可以本地进行查看和调试你的网站了。</a></li>
</ul></li>
</ul>

<h2 id="toc_3">Step 3.Jekyll</h2>

<ul>
<li>Jekyll目录
<ul>
<li>_config.yml 是配置文件，你可以在里面配置你博客会用到的常量，比如博客名，邮件</li>
<li>_includes：就是你文章各个部分的html文件，可以在布局中包含这些文件</li>
<li>_layouts：存放模板。就是你网页的布局，主页布局，文章布局。当然不是指CSS那样的布局，是指，你包含哪些基本的内容到页面上。包含的内容就是includes里面的文件。</li>
<li>_posts: 存放博客文章</li>
<li>index：博客主页</li>
<li>CNAME文件：域名地址</li>
<li>CSS：存放博客所用CSS</li>
<li>JS: 存放博客所用JavaScript </li>
</ul></li>
<li>如何发表文章
<ul>
<li>文章的写法，在Markdown开头加上一段：</li>
</ul></li>
</ul>

<blockquote>
<pre class="line-numbers"><code class="language-text">---
layout: posttitle: &quot;Welcome to Jekyll!&quot;
date: 2014-01-27 21:57:11
categories: Blog
---
</code></pre>
</blockquote>

<p>文件命名格式: 时间加标题 比如：2015-08-15-HowTOBuildBlog.md<br/>
ok，你可以写文章了，放入_post文件夹即可。</p>

<ul>
<li>修改主题
<ul>
<li>学习学习前端，并且研究下<a href="http://jekyll.com.cn" title="Jekyll">Jekyll官网</a>，自己修改。或者fork别人在github写好的模板进行修改</li>
</ul></li>
</ul>

<h2 id="toc_4">Step 4.同步本地和GitHub博客文件</h2>

<pre class="line-numbers"><code class="language-text">使用git命令或者用图形化客户端直接进行文件同步，方法简单不详述。
</code></pre>

<h2 id="toc_5">Step 5.Markdown</h2>

<p>使用这种语法写文件简单的多了，附上<a href="https://segmentfault.com/a/1190000004543870" title="markdown">markdown语法和心得</a></p>

<p>参考网址：<br/><br/>
<a href="http://www.jianshu.com/p/9a6bc31d329d">http://www.jianshu.com/p/9a6bc31d329d</a><br/><br/>
<a href="https://zhuanlan.zhihu.com/p/21333968">https://zhuanlan.zhihu.com/p/21333968</a></p>

<h2 id="toc_6">Step 6.代码高亮</h2>

<p>代码：<br/><br/>
<figure><img src="media/15561207867585/15713340859116.png" alt=""/></figure></p>

<p>在文中使用效果：  </p>

<pre class="line-numbers"><code class="language-java"> public void hello(){
    int a = 0;
    int b = 1;
    int c = a + b;
 }
</code></pre>

<h2 id="toc_7">Step 7.MarkDown解析器</h2>

<p>现在github推荐kramdown作为markdown解析器。其解析速度很快比PHP markdown和Maruku都要快几倍。kramdown有很多一般markdown所没有的语法特点，包括和GFM也有差异。另外也可以很方便地作为文件转换使用。<br/><br/>
<a href="7">kramdown和markdown较大的差异比较</a></p>

<h2 id="toc_8">Step 8.生成目录</h2>

<p>没有目录还是一件很苦恼的事情。特别是长篇博客，所以去查了markdown如何生成目录，在此更新一下。<br/><br/>
kramdown默认是支持TOC。在_config.yml中的配置方式为：</p>

<pre class="line-numbers"><code class="language-text">markdown: kramdown
kramdown:
  input:  GFM
</code></pre>

<p>在编写文章时，插入下面代码，渲染之后就可以生成TOC了：</p>

<p><figure><img src="media/15561207867585/15713340992995.png" alt=""/></figure></p>

<h2 id="toc_9">Step 9.插入数学公式</h2>

<p>在<code>/source/_includes/head.html</code>中将下面的代码插入<code>&lt;head&gt;</code>和<code>&lt;/head&gt;</code>标签之间。  </p>

<pre class="line-numbers"><code class="language-markup">&lt;!-- mathjax config similar to math.stackexchange --&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ [&#39;$&#39;,&#39;$&#39;], [&quot;\\(&quot;,&quot;\\)&quot;] ],
      processEscapes: true
    }
  });
&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: [&#39;script&#39;, &#39;noscript&#39;, &#39;style&#39;, &#39;textarea&#39;, &#39;pre&#39;, &#39;code&#39;]
      }
    });
&lt;/script&gt;

&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i &lt; all.length; i += 1) {
            all[i].SourceElement().parentNode.className += &#39; has-jax&#39;;
        }
    });
&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;
   src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;
&lt;/script&gt;
</code></pre>

<p>接着使用LaTeX表达式进行编辑。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2015/4/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_15.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15712984956484.html">代理模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15712937841703.html">备忘录模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711947460528.html">观察者模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711314242192.html">策略模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711233221322.html">适配器模式</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
