<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207869765.html">
                
                  <h1>Android-MotionEvent解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一些常量</h2>

<h3 id="toc_1">常见的动作常量：</h3>

<ul>
<li><code>public static final int ACTION_DOWN = 0;       //单点触摸动作</code></li>
<li><code>public static final int ACTION_UP  = 1;        //单点触摸离开动作</code></li>
<li><code>public static final int ACTION_MOVE = 2;       //触摸点移动动作</code></li>
<li><code>public static final int ACTION_CANCEL = 3;     //触摸动作取消</code></li>
<li><code>public static final int ACTION_OUTSIDE = 4;    //触摸动作超出边界</code></li>
<li><code>public static final int ACTION_POINTER_DOWN = 5;//多点触摸动作</code>    </li>
<li><code>public static final int ACTION_POINTER_UP = 6;  //多点离开动作</code>  
### 以下是一些非touch事件    </li>
<li><code>public static final int ACTION_HOVER_MOVE       = 7;</code></li>
<li><code>public static final int ACTION_SCROLL           = 8;</code>    </li>
<li><code>public static final int ACTION_HOVER_ENTER      = 9;</code>    </li>
<li><code>public static final int ACTION_HOVER_EXIT       = 10;</code></li>
</ul>

<h3 id="toc_2">掩码常量</h3>

<p><code>ACTION_MASK = 0X000000ff</code></p>

<h3 id="toc_3">动作掩码</h3>

<p><code>ACTION_POINTER_INDEX_MASK = 0X0000ff00</code></p>

<h3 id="toc_4">触摸点索引掩码</h3>

<p><code>ACTION_POINTER_INDEX_SHIFT = 8  //获取触摸点索引需要移动的位数</code></p>

<h3 id="toc_5">getRawX()和getRawY()</h3>

<p><code>相对于屏幕位置坐标</code></p>

<h3 id="toc_6">X,Y 相对于View的位置坐标</h3>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869720.html">
                
                  <h1>Android-ViewConfiguration解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>ViewConfiguration这个类主要定义了UI中所使用到的标准常量，像超时、尺寸、距离，如果我们需要得到这些常量的数据，我们就可以通过这个类来获取，具体方法如下： </p>

<ul>
<li>获取ViewConfiguration对象，由于ViewConfiguration的构造方法为私有的，只能通过这个静态方法来获取到该对象。 ViewConfiguration configure = ViewConfiguration.get(context); </li>
<li>通过该对象调用相关的函数，将返回相关的常量数据。</li>
</ul>

<p>最后附上一些这个类文件源码，这里面所有的方法基本都是用来获取常量数据的，没有什么业务操作。</p>

<pre class="line-numbers"><code class="language-java">import android.app.AppGlobals;
import android.content.Context;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Point;
import android.os.RemoteException;
import android.provider.Settings;
import android.util.DisplayMetrics;
import android.util.SparseArray;

/**
 * 主要用来获取一些在UI中所使用到的标准常量，像超时、尺寸、距离
 */
public class ViewConfiguration {
    /**
     * 定义了水平滚动条的宽度和垂直滚动条的高度，单位是dip
     */
    private static final int SCROLL_BAR_SIZE = 10;

    /**
     * 滚动条褪去所需要经历的时间，单位：milliseconds
     */
    private static final int SCROLL_BAR_FADE_DURATION = 250;

    /**
     * 滚动条褪去之前的默认时间延迟，单位：milliseconds
     */
    private static final int SCROLL_BAR_DEFAULT_DELAY = 300;

    /**
     * 定义褪去边缘的长度，单位：dip
     */
    private static final int FADING_EDGE_LENGTH = 12;

    /**
     * 按下状态在子控件上的持续时间，单位：milliseconds
     */
    private static final int PRESSED_STATE_DURATION = 64;

    /**
     * 定义一个按下状态转变成长按状态所需要持续的时间，单位：milliseconds
     */
    private static final int DEFAULT_LONG_PRESS_TIMEOUT = 500;

    /**
     * 定义连续重复按键间的时间延迟，单位：milliseconds
     */
    private static final int KEY_REPEAT_DELAY = 50;

    /**
     * 如果用户需要触发全局对话框，例如：关机，锁屏等，需要按下按钮所持续的事件，单位：milliseconds
     */
    private static final int GLOBAL_ACTIONS_KEY_TIMEOUT = 500;

    /**
     * 定义一个触摸事件是点击还是滚动的事件间隔，如果在这个事件内没有移动，就认为这是一个点击，否则就是滚动，单位：milliseconds
     */
    private static final int TAP_TIMEOUT = 180;

    /**
     * Defines the duration in milliseconds we will wait to see if a touch event
     * is a jump tap. If the user does not complete the jump tap within this interval, it is
     * considered to be a tap.
     */
    private static final int JUMP_TAP_TIMEOUT = 500;

    /**
     * 定义双击的时间间隔，如果在这个时间内，就认为是双击
     */
    private static final int DOUBLE_TAP_TIMEOUT = 300;

    /**
     * 定义双击最小的时间间隔
     */
    private static final int DOUBLE_TAP_MIN_TIME = 40;

    /**
     * 定义一个触摸板触摸到释放可认为是一个点击事件而不是一个触摸移动手势的最大时间，
     * 也就是说在这个时间内进行一次触摸和释放操作就可以认为是一次点击事件，单位：milliseconds
     */
    private static final int HOVER_TAP_TIMEOUT = 150;

    /**
     * 定义一个触摸板在触摸释放之前可以移动的最大距离，
     * 如果在这个距离之内就可以认为是一个点击事件，否则就是一个移动手势，单位：pixels
     */
    private static final int HOVER_TAP_SLOP = 20;

    /**
     * 定义响应显示缩放控制的时间
     */
    private static final int ZOOM_CONTROLS_TIMEOUT = 3000;

    /**
     * Inset in dips to look for touchable content when the user touches the edge of the screen
     */
    private static final int EDGE_SLOP = 12;

    /**
     * 如果我们认为用户正在滚动，这里定义一个触摸事件可以滚动的距离，单位：dips
     * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。
     */
    private static final int TOUCH_SLOP = 8;

    /**
     * 定义双击事件之间可以移动的距离，单位：dips
     */
    private static final int DOUBLE_TAP_TOUCH_SLOP = TOUCH_SLOP;

    /**
     * 定义用户尝试翻页滚动的触摸移动距离，单位：dips
     *
     * 注意：这个值在这里定义只是作为那些没有提供上下文Context来决定密度和配置相关值的应用程序的一个备用值。
     *
     */
    private static final int PAGING_TOUCH_SLOP = TOUCH_SLOP * 2;

    /**
     * 定义第一次点击和第二次点击可以认为是一次双击之间的距离。单位：dips
     */
    private static final int DOUBLE_TAP_SLOP = 100;

    /**
     * Distance in dips a touch needs to be outside of a window&#39;s bounds for it to
     * count as outside for purposes of dismissing the window.
     */
    private static final int WINDOW_TOUCH_SLOP = 16;

    /**
     * 一个fling最小的速度，单位：dips/s
     */
    private static final int MINIMUM_FLING_VELOCITY = 50;

    /**
     * 一个fling最大的速度，单位：dips/s
     */
    private static final int MAXIMUM_FLING_VELOCITY = 8000;

    /**
     * 分发一个重复访问事件的延迟事件，单位：milliseconds
     */
    private static final long SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS = 100;

    /**
     * The maximum size of View&#39;s drawing cache, expressed in bytes. This size
     * should be at least equal to the size of the screen in ARGB888 format.
     */
    @Deprecated
    private static final int MAXIMUM_DRAWING_CACHE_SIZE = 480 * 800 * 4; // ARGB8888

    /**
     * 滚动和滑动的摩擦系数
     */
    private static final float SCROLL_FRICTION = 0.015f;

    /**
     * Max distance in dips to overscroll for edge effects
     */
    private static final int OVERSCROLL_DISTANCE = 0;

    /**
     * Max distance in dips to overfling for edge effects
     */
    private static final int OVERFLING_DISTANCE = 6;

    private final int mEdgeSlop;
    private final int mFadingEdgeLength;
    private final int mMinimumFlingVelocity;
    private final int mMaximumFlingVelocity;
    private final int mScrollbarSize;
    private final int mTouchSlop;
    private final int mDoubleTapTouchSlop;
    private final int mPagingTouchSlop;
    private final int mDoubleTapSlop;
    private final int mWindowTouchSlop;
    private final int mMaximumDrawingCacheSize;
    private final int mOverscrollDistance;
    private final int mOverflingDistance;
    private final boolean mFadingMarqueeEnabled;

    private boolean sHasPermanentMenuKey;
    private boolean sHasPermanentMenuKeySet;

    static final SparseArray&lt;ViewConfiguration&gt; sConfigurations =
            new SparseArray&lt;ViewConfiguration&gt;(2);

    /**
     * 这个方法被废除了，使用ViewConfiguration.get(Context)}替代
     */
    @Deprecated
    public ViewConfiguration() {
        mEdgeSlop = EDGE_SLOP;
        mFadingEdgeLength = FADING_EDGE_LENGTH;
        mMinimumFlingVelocity = MINIMUM_FLING_VELOCITY;
        mMaximumFlingVelocity = MAXIMUM_FLING_VELOCITY;
        mScrollbarSize = SCROLL_BAR_SIZE;
        mTouchSlop = TOUCH_SLOP;
        mDoubleTapTouchSlop = DOUBLE_TAP_TOUCH_SLOP;
        mPagingTouchSlop = PAGING_TOUCH_SLOP;
        mDoubleTapSlop = DOUBLE_TAP_SLOP;
        mWindowTouchSlop = WINDOW_TOUCH_SLOP;
        //noinspection deprecation
        mMaximumDrawingCacheSize = MAXIMUM_DRAWING_CACHE_SIZE;
        mOverscrollDistance = OVERSCROLL_DISTANCE;
        mOverflingDistance = OVERFLING_DISTANCE;
        mFadingMarqueeEnabled = true;
    }

    /**
     * 使用给定的context来创建一个新的配置。这个配置依赖于context里面不同的参数，例如显示的尺寸或者密度
     * @param context 用来初始化这个view配置的应用上下文环境
     *
     * @see #get(android.content.Context)
     * @see android.util.DisplayMetrics
     */
    private ViewConfiguration(Context context) {
        final Resources res = context.getResources();
        final DisplayMetrics metrics = res.getDisplayMetrics();
        final Configuration config = res.getConfiguration();
        final float density = metrics.density;
        final float sizeAndDensity;
        if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE)) {
            sizeAndDensity = density * 1.5f;
        } else {
            sizeAndDensity = density;
        }

        mEdgeSlop = (int) (sizeAndDensity * EDGE_SLOP + 0.5f);
        mFadingEdgeLength = (int) (sizeAndDensity * FADING_EDGE_LENGTH + 0.5f);
        mMinimumFlingVelocity = (int) (density * MINIMUM_FLING_VELOCITY + 0.5f);
        mMaximumFlingVelocity = (int) (density * MAXIMUM_FLING_VELOCITY + 0.5f);
        mScrollbarSize = (int) (density * SCROLL_BAR_SIZE + 0.5f);
        mDoubleTapSlop = (int) (sizeAndDensity * DOUBLE_TAP_SLOP + 0.5f);
        mWindowTouchSlop = (int) (sizeAndDensity * WINDOW_TOUCH_SLOP + 0.5f);

        // Size of the screen in bytes, in ARGB_8888 format
        final WindowManager win = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);
        final Display display = win.getDefaultDisplay();
        final Point size = new Point();
        display.getRealSize(size);
        mMaximumDrawingCacheSize = 4 * size.x * size.y;

        mOverscrollDistance = (int) (sizeAndDensity * OVERSCROLL_DISTANCE + 0.5f);
        mOverflingDistance = (int) (sizeAndDensity * OVERFLING_DISTANCE + 0.5f);

        if (!sHasPermanentMenuKeySet) {
            IWindowManager wm = WindowManagerGlobal.getWindowManagerService();
            try {
                sHasPermanentMenuKey = !wm.hasNavigationBar();
                sHasPermanentMenuKeySet = true;
            } catch (RemoteException ex) {
                sHasPermanentMenuKey = false;
            }
        }

        mFadingMarqueeEnabled = res.getBoolean(
                com.android.internal.R.bool.config_ui_enableFadingMarquee);
        mTouchSlop = res.getDimensionPixelSize(
                com.android.internal.R.dimen.config_viewConfigurationTouchSlop);
        mPagingTouchSlop = mTouchSlop * 2;

        mDoubleTapTouchSlop = mTouchSlop;
    }

    /**
     * 跟上面一个函数一样，只不过上面一个是创建一个ViewConfiguration对象，这里是直接通过这个静态方法返回一个对象
     */
    public static ViewConfiguration get(Context context) {
        final DisplayMetrics metrics = context.getResources().getDisplayMetrics();
        final int density = (int) (100.0f * metrics.density);

        ViewConfiguration configuration = sConfigurations.get(density);
        if (configuration == null) {
            configuration = new ViewConfiguration(context);
            sConfigurations.put(density, configuration);
        }

        return configuration;
    }

    /**
     * @return 获取水平滚动条的宽带和垂直滚动条的高度
     *
     * 这个函数被废除，使用getScaledScrollBarSize()来代替
     */
    @Deprecated
    public static int getScrollBarSize() {
        return SCROLL_BAR_SIZE;
    }

    /**
     * @return 获取水平滚动条的宽带和垂直滚动条的高度
     */
    public int getScaledScrollBarSize() {
        return mScrollbarSize;
    }

    /**
     * @return 滚动条褪去的持续时间
     */
    public static int getScrollBarFadeDuration() {
        return SCROLL_BAR_FADE_DURATION;
    }

    /**
     * @return 滚动条褪去的延迟时间
     */
    public static int getScrollDefaultDelay() {
        return SCROLL_BAR_DEFAULT_DELAY;
    }

    /**
     * @return 褪去边缘的长度
     *
     * 这个方法已经废弃，用getScaledFadingEdgeLength()替代.
     */
    @Deprecated
    public static int getFadingEdgeLength() {
        return FADING_EDGE_LENGTH;
    }

    /**
     * @return 褪去边缘的长度，单位：pixels
     */
    public int getScaledFadingEdgeLength() {
        return mFadingEdgeLength;
    }

    /**
     * @return 在子控件上按住状态的持续时间
     */
    public static int getPressedStateDuration() {
        return PRESSED_STATE_DURATION;
    }

    /**
     * @return 按住状态转变为长按状态需要的时间
     */
    public static int getLongPressTimeout() {
        return AppGlobals.getIntCoreSetting(Settings.Secure.LONG_PRESS_TIMEOUT,
                DEFAULT_LONG_PRESS_TIMEOUT);
    }

    /**
     * @return 重新按键时间
     */
    public static int getKeyRepeatTimeout() {
        return getLongPressTimeout();
    }

    /**
     * @return 重复按键延迟时间
     */
    public static int getKeyRepeatDelay() {
        return KEY_REPEAT_DELAY;
    }

    /**
     * @return 判断用户是单击还是滚动的时间，在这个时间内没有移动则是单击，否则是滚动
     */
    public static int getTapTimeout() {
        return TAP_TIMEOUT;
    }

    /**
     * @return the duration in milliseconds we will wait to see if a touch event
     * is a jump tap. If the user does not move within this interval, it is
     * considered to be a tap.
     */
    public static int getJumpTapTimeout() {
        return JUMP_TAP_TIMEOUT;
    }

    /**
     * @return 得到双击间隔时间，在这个时间内，则是双击，否则就是单击
     */
    public static int getDoubleTapTimeout() {
        return DOUBLE_TAP_TIMEOUT;
    }

    /**
     * @return the minimum duration in milliseconds between the first tap&#39;s
     * up event and the second tap&#39;s down event for an interaction to be considered a
     * double-tap.
     *
     * @hide
     */
    public static int getDoubleTapMinTime() {
        return DOUBLE_TAP_MIN_TIME;
    }

    /**
     * @return the maximum duration in milliseconds between a touch pad
     * touch and release for a given touch to be considered a tap (click) as
     * opposed to a hover movement gesture.
     * @hide
     */
    public static int getHoverTapTimeout() {
        return HOVER_TAP_TIMEOUT;
    }

    /**
     * @return the maximum distance in pixels that a touch pad touch can move
     * before being released for it to be considered a tap (click) as opposed
     * to a hover movement gesture.
     * @hide
     */
    public static int getHoverTapSlop() {
        return HOVER_TAP_SLOP;
    }

    /**
     * @return Inset in dips to look for touchable content when the user touches the edge of the
     *         screen
     *
     * @deprecated Use {@link #getScaledEdgeSlop()} instead.
     */
    @Deprecated
    public static int getEdgeSlop() {
        return EDGE_SLOP;
    }

    /**
     * @return Inset in pixels to look for touchable content when the user touches the edge of the
     *         screen
     */
    public int getScaledEdgeSlop() {
        return mEdgeSlop;
    }

    /**
     * @return Distance in dips a touch can wander before we think the user is scrolling
     *
     * @deprecated Use {@link #getScaledTouchSlop()} instead.
     */
    @Deprecated
    public static int getTouchSlop() {
        return TOUCH_SLOP;
    }

    /**
     * @return Distance in pixels a touch can wander before we think the user is scrolling
     */
    public int getScaledTouchSlop() {
        return mTouchSlop;
    }

    /**
     * @return Distance in pixels the first touch can wander before we do not consider this a
     * potential double tap event
     * @hide
     */
    public int getScaledDoubleTapTouchSlop() {
        return mDoubleTapTouchSlop;
    }

    /**
     * @return Distance in pixels a touch can wander before we think the user is scrolling a full
     * page
     */
    public int getScaledPagingTouchSlop() {
        return mPagingTouchSlop;
    }

    /**
     * @return Distance in dips between the first touch and second touch to still be
     *         considered a double tap
     * @deprecated Use {@link #getScaledDoubleTapSlop()} instead.
     * @hide The only client of this should be GestureDetector, which needs this
     *       for clients that still use its deprecated constructor.
     */
    @Deprecated
    public static int getDoubleTapSlop() {
        return DOUBLE_TAP_SLOP;
    }

    /**
     * @return Distance in pixels between the first touch and second touch to still be
     *         considered a double tap
     */
    public int getScaledDoubleTapSlop() {
        return mDoubleTapSlop;
    }

    /**
     * Interval for dispatching a recurring accessibility event in milliseconds.
     * This interval guarantees that a recurring event will be send at most once
     * during the {@link #getSendRecurringAccessibilityEventsInterval()} time frame.
     *
     * @return The delay in milliseconds.
     *
     * @hide
     */
    public static long getSendRecurringAccessibilityEventsInterval() {
        return SEND_RECURRING_ACCESSIBILITY_EVENTS_INTERVAL_MILLIS;
    }

    /**
     * @return Distance in dips a touch must be outside the bounds of a window for it
     * to be counted as outside the window for purposes of dismissing that
     * window.
     *
     * @deprecated Use {@link #getScaledWindowTouchSlop()} instead.
     */
    @Deprecated
    public static int getWindowTouchSlop() {
        return WINDOW_TOUCH_SLOP;
    }

    /**
     * @return Distance in pixels a touch must be outside the bounds of a window for it
     * to be counted as outside the window for purposes of dismissing that window.
     */
    public int getScaledWindowTouchSlop() {
        return mWindowTouchSlop;
    }

    /**
     * @return Minimum velocity to initiate a fling, as measured in dips per second.
     *
     * @deprecated Use {@link #getScaledMinimumFlingVelocity()} instead.
     */
    @Deprecated
    public static int getMinimumFlingVelocity() {
        return MINIMUM_FLING_VELOCITY;
    }

    /**
     * @return 得到滑动的最小速度, 以像素/每秒来进行计算
     */
    public int getScaledMinimumFlingVelocity() {
        return mMinimumFlingVelocity;
    }

    /**
     * @return Maximum velocity to initiate a fling, as measured in dips per second.
     *
     * @deprecated Use {@link #getScaledMaximumFlingVelocity()} instead.
     */
    @Deprecated
    public static int getMaximumFlingVelocity() {
        return MAXIMUM_FLING_VELOCITY;
    }

    /**
     * @return 得到滑动的最大速度, 以像素/每秒来进行计算
     */
    public int getScaledMaximumFlingVelocity() {
        return mMaximumFlingVelocity;
    }

    /**
     * The maximum drawing cache size expressed in bytes.
     *
     * @return the maximum size of View&#39;s drawing cache expressed in bytes
     *
     * @deprecated Use {@link #getScaledMaximumDrawingCacheSize()} instead.
     */
    @Deprecated
    public static int getMaximumDrawingCacheSize() {
        //noinspection deprecation
        return MAXIMUM_DRAWING_CACHE_SIZE;
    }

    /**
     * The maximum drawing cache size expressed in bytes.
     *
     * @return the maximum size of View&#39;s drawing cache expressed in bytes
     */
    public int getScaledMaximumDrawingCacheSize() {
        return mMaximumDrawingCacheSize;
    }

    /**
     * @return The maximum distance a View should overscroll by when showing edge effects (in
     * pixels).
     */
    public int getScaledOverscrollDistance() {
        return mOverscrollDistance;
    }

    /**
     * @return The maximum distance a View should overfling by when showing edge effects (in
     * pixels).
     */
    public int getScaledOverflingDistance() {
        return mOverflingDistance;
    }

    /**
     * The amount of time that the zoom controls should be
     * displayed on the screen expressed in milliseconds.
     *
     * @return the time the zoom controls should be visible expressed
     * in milliseconds.
     */
    public static long getZoomControlsTimeout() {
        return ZOOM_CONTROLS_TIMEOUT;
    }

    /**
     * The amount of time a user needs to press the relevant key to bring up
     * the global actions dialog.
     *
     * @return how long a user needs to press the relevant key to bring up
     *   the global actions dialog.
     */
    public static long getGlobalActionKeyTimeout() {
        return GLOBAL_ACTIONS_KEY_TIMEOUT;
    }

    /**
     * The amount of friction applied to scrolls and flings.
     *
     * @return A scalar dimensionless value representing the coefficient of
     *         friction.
     */
    public static float getScrollFriction() {
        return SCROLL_FRICTION;
    }

    /**
     * Report if the device has a permanent menu key available to the user.
     *
     * &lt;p&gt;As of Android 3.0, devices may not have a permanent menu key available.
     * Apps should use the action bar to present menu options to users.
     * However, there are some apps where the action bar is inappropriate
     * or undesirable. This method may be used to detect if a menu key is present.
     * If not, applications should provide another on-screen affordance to access
     * functionality.
     *
     * @return true if a permanent menu key is present, false otherwise.
     */
    public boolean hasPermanentMenuKey() {
        return sHasPermanentMenuKey;
    }

    /**
     * @hide
     * @return Whether or not marquee should use fading edges.
     */
    public boolean isFadingMarqueeEnabled() {
        return mFadingMarqueeEnabled;
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/07</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869583.html">
                
                  <h1>Android-ViewPager详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">简介</h2>

<p>ViewPager是android扩展包v4包中的类，这个类可以让用户左右切换当前的view</p>

<ul>
<li>ViewPager类直接继承了ViewGroup类，所有它是一个容器类，可以在其中添加其他的view类。</li>
<li>ViewPager类需要一个PagerAdapter适配器类给它提供数据。</li>
<li>ViewPager经常和Fragment一起使用，并且提供了专门的FragmentPagerAdapter和FragmentStatePagerAdapter类供Fragment中的ViewPager使用。</li>
</ul>

<h2 id="toc_1">ViewPager的适配器</h2>

<p>简介中提到了PagerAdapter，和ListView等控件使用一样,需要ViewPager设置PagerAdapter来完成页面和数据的绑定，这个PagerAdapter是一个基类适配器，我们经常用它来实现app引导图，它的子类有FragmentPagerAdapter和FragmentStatePagerAdapter,这两个子类适配器用于和Fragment一起使用，在安卓应用中它们就像listview一样出现的频繁。</p>

<h3 id="toc_2">实现一个最基本的PagerAdapter,必须实现四个方法，在代码里有注释</h3>

<pre class="line-numbers"><code class="language-java">public class AdapterViewpager extends PagerAdapter {
    private List&lt;View&gt; mViewList;

    public AdapterViewpager(List&lt;View&gt; mViewList) {
        this.mViewList = mViewList;
    }

    @Override
    public int getCount() {//必须实现,返回要滑动的VIew的个数
        return mViewList.size();
    }

    @Override
    public boolean isViewFromObject(View view, Object object) {//必须实现,该函数用来判断instantiateItem(ViewGroup, int)函数所返回来的Key与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View)
        return view == object;
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {//必须实现，做了两件事，第一：将当前视图添加到container中，第二：返回当前View
        container.addView(mViewList.get(position));
        return mViewList.get(position);
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {//必须实现，从当前container中删除指定位置（position）的View
        container.removeView(mViewList.get(position));
    }
}
</code></pre>

<h3 id="toc_3">实现一个最基本的FragmentPagerAdapter</h3>

<pre class="line-numbers"><code class="language-java">public class AdapterFragment extends FragmentPagerAdapter {
    private List&lt;Fragment&gt; mFragments;

    public AdapterFragment(FragmentManager fm, List&lt;Fragment&gt; mFragments) {
        super(fm);
        this.mFragments = mFragments;
    }

    @Override
    public Fragment getItem(int position) {//必须实现
        return mFragments.get(position);
    }

    @Override
    public int getCount() {//必须实现
        return mFragments.size();
    }

    @Override
    public CharSequence getPageTitle(int position) {//选择性实现
        return mFragments.get(position).getClass().getSimpleName();
    }
}
</code></pre>

<p>PagerAdapter是基类适配器是一个通用的ViewPager适配器，相比PagerAdapter，FragmentPagerAdapter和FragmentStatePagerAdapter更专注于每一页是Fragment的情况，而这两个子类适配器使用情况也是有区别的。FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况。为什么？简单分析下两个适配器的源码就可以知道了。</p>

<p><strong>源码略，查官网</strong></p>

<p>从源码中我们可以看出FragmentStatePagerAdapter中fragment实例在destroyItem的时候被真正释放，所以FragmentStatePagerAdapter省内存。FragmentPagerAdapter中的fragment实例在destroyItem的时候并没有真正释放fragment对象只是detach，所以FragmentPagerAdapter消耗更多的内存，带来的好处就是效率更高一些。所以得出这样的结论：FragmentPagerAdapter适用于页面比较少的情况，FragmentStatePagerAdapter适用于页面比较多的情况，因此不同的场合选择合适的适配器才是正确的做法。</p>

<h2 id="toc_4">ViewPager的翻页动画</h2>

<p>为ViewPager设置适配器后，就可以正常使用了，接下来我们为ViewPager增加翻页动画，毕竟人的审美会疲劳，加上一些动画交互会提高不少逼格~~，ViewPager提供了PageTransformer接口用于实现翻页动画。官方提供了PageTransformer的实现例子。</p>

<h3 id="toc_5">例一</h3>

<pre class="line-numbers"><code class="language-java"> public class DepthPageTransformer implements ViewPager.PageTransformer {
    private static final float MIN_SCALE = 0.75f;

    public void transformPage(View view, float position) {
        Log.d(&quot;DepthPageTransformer&quot;, view.getTag() + &quot; , &quot; + position + &quot;&quot;);
        int pageWidth = view.getWidth();

        if (position &lt; -1) { // [-Infinity,-1)
            // This page is way off-screen to the left.
            view.setAlpha(0);

        } else if (position &lt;= 0) { // [-1,0]
            // Use the default slide transition when moving to the left page
            view.setAlpha(1);
            view.setTranslationX(0);
            view.setScaleX(1);
            view.setScaleY(1);

        } else if (position &lt;= 1) { // (0,1]
            // Fade the page out.
            view.setAlpha(1 - position);

            // Counteract the default slide transition
            view.setTranslationX(pageWidth * -position);

            // Scale the page down (between MIN_SCALE and 1)
            float scaleFactor = MIN_SCALE
                    + (1 - MIN_SCALE) * (1 - Math.abs(position));
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);

        } else { // (1,+Infinity]
            // This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}
</code></pre>

<h3 id="toc_6">例二</h3>

<pre class="line-numbers"><code class="language-java"> public class ZoomOutPageTransformer implements ViewPager.PageTransformer {
    private static final float MIN_SCALE = 0.85f;
    private static final float MIN_ALPHA = 0.5f;

    @SuppressLint(&quot;NewApi&quot;)
    public void transformPage(View view, float position) {
        int pageWidth = view.getWidth();
        int pageHeight = view.getHeight();

        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);

        if (position &lt; -1) { // [-Infinity,-1)
            // This page is way off-screen to the left.
            view.setAlpha(0);

        } else if (position &lt;= 1) 
        { // [-1,1]
            // Modify the default slide transition to shrink the page as well
            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));
            float vertMargin = pageHeight * (1 - scaleFactor) / 2;
            float horzMargin = pageWidth * (1 - scaleFactor) / 2;
            if (position &lt; 0) {
                view.setTranslationX(horzMargin - vertMargin / 2);
            } else {
                view.setTranslationX(-horzMargin + vertMargin / 2);
            }

            // Scale the page down (between MIN_SCALE and 1)
            view.setScaleX(scaleFactor);
            view.setScaleY(scaleFactor);

            // Fade the page relative to its size.
            view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE)
                    / (1 - MIN_SCALE) * (1 - MIN_ALPHA));

        } else { // (1,+Infinity]
            // This page is way off-screen to the right.
            view.setAlpha(0);
        }
    }
}
</code></pre>

<p>实现翻页动画的关键就是重写transformPage方法，方法里有两个参数view和position,理解这两个参数非常重要。假设有三个页面view1，view2，view3从左至右在viewPager中显示</p>

<ul>
<li>往左滑动时：view1，view2，view3的position都是不断变小的。
<code>
           view1的position: 0 → -1 → 负无穷大<br/>
           view2的position: 1 → 0 → -1 <br/>
           view3的position: 1 → 0
</code></li>
<li>往右滑动时：view1，view2，view3的position都是不断变大的。
<code>
           view1的position: -1 → 0 <br/>
           view2的position: -1 → 0 → 1 <br/>
           view3的position: 0 → 1→ 正无穷大
</code>
当position是正负无穷大时view就离开屏幕视野了。因此最核心的控制逻辑是在[-1,0]和(0,1]这两个区间，通过设置透明度，平移，旋转，缩放等动画组合可以实现各式各样的页面变化效果。</li>
</ul>

<h3 id="toc_7">简化ViewPager的使用</h3>

<ul>
<li>PagerAdapter简化</li>
</ul>

<pre class="line-numbers"><code class="language-java">public class QuickPageAdapter&lt;T extends View&gt; extends PagerAdapter {
  private List&lt;T&gt; mList;

  public QuickPageAdapter(List&lt;T&gt; mList) {
      this.mList = mList;
  }

  @Override
  public int getCount() {
      return mList.size();
  }

  @Override
  public boolean isViewFromObject(View view, Object object) {
      return object == view;
  }

  @Override
  public Object instantiateItem(ViewGroup container, int position) {
      container.addView(mList.get(position));
      return mList.get(position);
  }

  @Override
  public void destroyItem(ViewGroup container, int position, Object object) {
      container.removeView(mList.get(position));
  }
}
</code></pre>

<p>使用它，这样不用每次都写个适配器List<View> views = new ArrayList&lt;&gt;();...mViewPager.setAdapter(new QuickPageAdapter<View>(views));</p>

<ul>
<li>FragmentPagerAdapter简化</li>
</ul>

<pre class="line-numbers"><code class="language-java">public class QuickFragmentPageAdapter&lt;T extends Fragment&gt; extends FragmentPagerAdapter {
  private List&lt;T&gt; mList;
  private String[] mStrings;

  /**
   * @param fm
   * @param list
   * @param titles PageTitles
   */
  public QuickFragmentPageAdapter(FragmentManager fm, List&lt;T&gt; list, String[] titles) {
      super(fm);
      mList = list;
      mStrings = titles;
  }

  @Override
  public Fragment getItem(int position) {
      return mList.get(position);
  }

  @Override
  public int getCount() {
      return mList.size();
  }

  @Override
  public CharSequence getPageTitle(int position) {
      return mStrings == null ? super.getPageTitle(position) : mStrings[position];
  }
}
</code></pre>

<h2 id="toc_8">PagerTitleStrip</h2>

<ul>
<li>将它作为子控件添加在xml布局文件中的ViewPager中</li>
<li>标题的获取，是重写适配器的getPageTitle(int)函数来获取的。</li>
</ul>

<p>重写CharSequence <code>getPageTitle(int)</code>函数来对其进行实现</p>

<h2 id="toc_9">PagerTabStrip</h2>

<ul>
<li>PagerTabStrip在当前页面下，会有一个下划线条来提示当前页面的Tab是哪个。</li>
<li>PagerTabStrip的Tab是可以点击的，当用户点击某一个Tab时，当前页面就会跳转到这个页面，而PagerTitleStrip则没这个功能。</li>
<li>将它作为子控件添加在xml布局文件中的ViewPager中</li>
<li>标题的获取，是重写适配器的getPageTitle(int)函数来获取的。</li>
</ul>

<h3 id="toc_10">扩展：PagerTabStrip属性更改</h3>

<p><code>setTabIndicatorColorResource</code>——修改Tab颜色<br/><br/>
重写适配器CharSequence getPageTitle(int)方法——添加标题</p>

<h3 id="toc_11">总结PagerTitleStrip和PagerTabStrip</h3>

<p>通过前面的讲解，我们应该清楚的认识到PagerTabStrip与PagerTitleStrip在添加标题栏的异同，但他们实现的标题栏效果很不好，不能指定一个页面一次显示一个，或者全部显示，而且标题还滑动。所以注定主流的App都没有用这个玩意的。所以这里也只是一个过渡，在开发中，我们也不建议使用这两个东东。</p>

<h2 id="toc_12">SimpleOnPageChangeListener</h2>

<p>如果不想继承实现<code>ViewPager.OnPageChangeListener</code>的方法，可以直接继承SimpleOnPageChangeListener对ViewPager的页面滑动事件进行简单的处理。</p>

<ul>
<li> <strong>onPageScrolled] (int position, float positionOffset, int positionOffsetPixels)：</strong>
<ul>
<li>position:当前的位置</li>
<li>positionoffset:当前滚动比例（左－右／0-1）（右－左／1-0）</li>
<li>positionOffsetPixels：当前实际滚动的像素（左－右／0-页宽） （右－左／页宽－0）<br/>
被调用的场景： ViewPager滚动时总被回调，这个函数在操作ViewPager时被回调很多次。</li>
</ul></li>
<li>手指拖动 action_move 。n次</li>
<li><p>惯性还原 computeScroll()。n次<br/>
使用场景：做view的动画效果时可以用这个回调函数。</p></li>
<li><p><strong>onPageSelected(int position)</strong><br/>
被调用的场景：ViewPager确定页面是哪一页时。1次</p></li>
<li><p>手指拖动后抬起 action_up 。1次</p></li>
<li><p>或者手指滑动超出屏幕时 action_cancel。1次<br/>
使用场景：页面切换后改变对应的tab的状态可以用这个回调函数。</p></li>
<li><p><strong>onPageScrollStateChange (int state):</strong><br/>
被调用的场景：ViewPager状态切换时被调用。这个函数在操作ViewPager时被回调3次。</p>
<ul>
<li>开始滚动 dragging拖动状态。1次</li>
<li>惯性滚动 settling还原状态。1次</li>
<li>滚动结束 idle空闲状态。1次<br/>
使用场景：做页面状态变化后引起的view特效时可以用这个回调函数</li>
</ul></li>
</ul>

<h2 id="toc_13">ViewPager.OnPageChangeListener</h2>

<ul>
<li><code>onPageScrollStateChanged(int state)</code>//在状态改变的时候调用其中arg0这个参数有三种状态（0，1，2）。arg0 <mark>1表示正在滑动，arg0</mark>2表示滑动完毕了，arg0==0表示什么都没做。当页面开始滑动的时候，三种状态的变化顺序为(1,2,0)</li>
<li><code>onPageScrolled(int position, float positionOffset, int positionOffsetPixels)</code>//当页面在滑动的时候会调用此方法，在滑动被停止之前，此方法回一直得到调用。其中三个参数的含义分别为：arg0 :当前页面，及你点击滑动的页面。arg1:当前页面偏移的百分比。arg2:当前页面偏移的像素位置</li>
<li><code>onPageSelected(int position)</code>//页面跳转完后得到调用，arg0是你当前选中的页面的position</li>
</ul>

<h2 id="toc_14">ViewPager.OnAdapterChangeListener</h2>

<p><code>void onAdapterChanged ( ViewPagerew viewPager, PagerAdapter oldAdapter,PagerAdapter newAdapter)</code></p>

<ul>
<li>viewPager:  ViewPager where the adapter change has happened(传入发生改变的ViewPager)</li>
<li>oldAdapter: the previously set adapter(老的adapter)</li>
<li>newAdapter: the newly set adapter(新的adapter)</li>
</ul>

<h2 id="toc_15">注意点</h2>

<p><code>mViewPager.setOffscreenPageLimit()</code>//这个方法是用来控制fragment不重新走生命周期的个数的，打个比方一共4个fragment页面，如果<code>mViewPager.setOffscreenPageLimit(3)</code>，那么所有的fragment都只走一次生命周期，如果是<code>mViewPager.setOffscreenPageLimit(2)</code>，那么其中有一个fragment会在切换的时候重新走一遍生命周期，<code>FragmentStatePagerAdapter</code>和<code>FragmentPagerAdapter</code>都是这样，但是<code>FragmentPagerAdapter</code>设置<code>setOffscreenPageLimit()</code>不影响fragment缓存的个数,而<code>FragmentStatePagerAdapter</code>缓存的fragment实例个数就是<code>setOffscreenPageLimit()</code>设置的值+1。另外<code>setOffscreenPageLimit()</code>的缺省值是1，设置0是无效的会被强制赋值成1。</p>

<h2 id="toc_16">提高</h2>

<h3 id="toc_17">ViewPager结合第三方库实现小圆点指示器效果</h3>

<p><a href="https://github.com/ongakuer/CircleIndicator">https://github.com/ongakuer/CircleIndicator</a></p>

<p><figure><img src="media/15561207869583/20170221497391480849-687604baae5b6559.gif" alt=""/></figure></p>

<p>使用看官方文档很简单。</p>

<p><strong>看一下实现思路</strong></p>

<pre class="line-numbers"><code class="language-java">public void setViewPager(ViewPager viewPager) {
        mViewpager = viewPager;
        if (mViewpager != null &amp;&amp; mViewpager.getAdapter() != null) {
            mLastPosition = -1;
            createIndicators();
            mViewpager.removeOnPageChangeListener(mInternalPageChangeListener);
            mViewpager.addOnPageChangeListener(mInternalPageChangeListener);//绑定上内部实现的PageChangeListener
            mInternalPageChangeListener.onPageSelected(mViewpager.getCurrentItem());
        }
    }

    private final OnPageChangeListener mInternalPageChangeListener = new OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        }

        @Override public void onPageSelected(int position) {//这里是动画的核心

            if (mViewpager.getAdapter() == null || mViewpager.getAdapter().getCount() &lt;= 0) {
                return;
            }

            if (mAnimatorIn.isRunning()) {
                mAnimatorIn.end();
                mAnimatorIn.cancel();
            }

            if (mAnimatorOut.isRunning()) {
                mAnimatorOut.end();
                mAnimatorOut.cancel();
            }

            View currentIndicator;
            if (mLastPosition &gt;= 0 &amp;&amp; (currentIndicator = getChildAt(mLastPosition)) != null) {//页面离开屏幕时指示器动画
                currentIndicator.setBackgroundResource(mIndicatorUnselectedBackgroundResId);
                mAnimatorIn.setTarget(currentIndicator);
                mAnimatorIn.start();
            }

            View selectedIndicator = getChildAt(position);
            if (selectedIndicator != null) {//页面进入屏幕时指示器动画
                selectedIndicator.setBackgroundResource(mIndicatorBackgroundResId);
                mAnimatorOut.setTarget(selectedIndicator);
                mAnimatorOut.start();
            }
            mLastPosition = position;
        }

        @Override public void onPageScrollStateChanged(int state) {
        }
    };
</code></pre>

<h3 id="toc_18">ViewPager结合design库实现tab切换</h3>

<p>在design库中有个TabLayout可以为viewPager加上Tab标题头</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    tools:context=&quot;com.example.administrator.viewpager.MainActivity&quot;&gt;

    &lt;android.support.design.widget.TabLayout
        android:id=&quot;@+id/mTabLayout&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;&lt;/android.support.design.widget.TabLayout&gt;

    &lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/mViewPager&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;&lt;/android.support.v4.view.ViewPager&gt;

&lt;/LinearLayout&gt;

mTabLayout.setupWithViewPager(mViewPager);//一行代码完成绑定
</code></pre>

<p>更多高级的用法包括tab中添加icon等请转至这里<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0731/3247.html">传送门</a></p>

<h3 id="toc_19">基于ViewPager实现广告轮播控件</h3>

<p><a href="https://github.com/daimajia/AndroidImageSlider">https://github.com/daimajia/AndroidImageSlider</a></p>

<p><figure><img src="media/15561207869583/20170221497391480849-687604baae5b6559.gif" alt=""/></figure></p>

<p><strong>源码分析，省略了部分代码</strong>：</p>

<pre class="line-numbers"><code class="language-java">public class SliderLayout extends RelativeLayout{

    private InfiniteViewPager mViewPager;//这个ViewPager只是修改了setPageTransformer方法去掉了if (Build.VERSION.SDK_INT &gt;= 11) 的限制，结合NineOldDroid库让动画兼容低版本

    /**
     * InfiniteViewPager adapter.
     */
    private SliderAdapter mSliderAdapter;//这个是PagerAdapter

    /**
     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} indicator.
     */
    private PagerIndicator mIndicator;//页面指示器


    /**
     * A timer and a TimerTask using to cycle the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}.
     */
    private Timer mCycleTimer;//用于轮播的定时器
    private TimerTask mCycleTask;

    /**
     * For resuming the cycle, after user touch or click the {@link com.daimajia.slider.library.Tricks.ViewPagerEx}.
     */
    private Timer mResumingTimer;
    private TimerTask mResumingTask;

    /**
     * {@link com.daimajia.slider.library.Tricks.ViewPagerEx} &#39;s transformer
     */
    private BaseTransformer mViewPagerTransformer;//PageTransformer的封装用于控制页面翻页效果

    public SliderLayout(Context context, AttributeSet attrs, int defStyle) {//核心代码，用于初始化ViewPager
        super(context, attrs, defStyle);
        mContext = context;
        LayoutInflater.from(context).inflate(R.layout.slider_layout, this, true);

        final TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs,R.styleable.SliderLayout,
                defStyle,0);

        mTransformerSpan = attributes.getInteger(R.styleable.SliderLayout_pager_animation_span, 1100);
        mTransformerId = attributes.getInt(R.styleable.SliderLayout_pager_animation, Transformer.Default.ordinal());
        mAutoCycle = attributes.getBoolean(R.styleable.SliderLayout_auto_cycle,true);
        int visibility = attributes.getInt(R.styleable.SliderLayout_indicator_visibility,0);
        for(PagerIndicator.IndicatorVisibility v: PagerIndicator.IndicatorVisibility.values()){
            if(v.ordinal() == visibility){
                mIndicatorVisibility = v;
                break;
            }
        }
        mSliderAdapter = new SliderAdapter(mContext);
        PagerAdapter wrappedAdapter = new InfinitePagerAdapter(mSliderAdapter);

        mViewPager = (InfiniteViewPager)findViewById(R.id.daimajia_slider_viewpager);
        mViewPager.setAdapter(wrappedAdapter);

        mViewPager.setOnTouchListener(new OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                int action = event.getAction();
                switch (action) {
                     case MotionEvent.ACTION_UP:
                        recoverCycle();
                        break;
                }
                return false;
            }
        });

        attributes.recycle();
        setPresetIndicator(PresetIndicators.Center_Bottom);
        setPresetTransformer(mTransformerId);
        setSliderTransformDuration(mTransformerSpan,null);
        setIndicatorVisibility(mIndicatorVisibility);
        if(mAutoCycle){
            startAutoCycle();
        }
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        int action = ev.getAction();
        switch (action) {
            case MotionEvent.ACTION_DOWN://手指按下时候暂停轮播
                pauseAutoCycle();
                break;
        }
        return false;
    }

    /**
     * preset transformers and their names
     */
    public enum Transformer{//PageTransformer枚举
        Default(&quot;Default&quot;),
        Accordion(&quot;Accordion&quot;),
        Background2Foreground(&quot;Background2Foreground&quot;),
        CubeIn(&quot;CubeIn&quot;),
        DepthPage(&quot;DepthPage&quot;),
        Fade(&quot;Fade&quot;),
        FlipHorizontal(&quot;FlipHorizontal&quot;),
        FlipPage(&quot;FlipPage&quot;),
        Foreground2Background(&quot;Foreground2Background&quot;),
        RotateDown(&quot;RotateDown&quot;),
        RotateUp(&quot;RotateUp&quot;),
        Stack(&quot;Stack&quot;),
        Tablet(&quot;Tablet&quot;),
        ZoomIn(&quot;ZoomIn&quot;),
        ZoomOutSlide(&quot;ZoomOutSlide&quot;),
        ZoomOut(&quot;ZoomOut&quot;);

        private final String name;

        private Transformer(String s){
            name = s;
        }
        public String toString(){
            return name;
        }

        public boolean equals(String other){
            return (other == null)? false:name.equals(other);
        }
    };
}
</code></pre>

<p><strong>通过分析我们可以对SliderLayout实现思路小结一下：</strong></p>

<ol>
<li>内部持有一个修改过的ViewPager控件，可以兼容低版本的页面转换动画</li>
<li>内部有一个实现了PagerAdapter的SliderAdapter适配器</li>
<li>内部持有一个PagerIndicator 页面指示器可供选择</li>
<li>维护一个定时任务用于控制轮播</li>
<li>对手势事件进行处理暂停轮播，继续轮播</li>
<li>提供了很多缺省的PageTransformer方便调用</li>
</ol>

<p>最后在构造函数中初始化ViewPager。</p>

<h2 id="toc_20">自定义 ViewPager 打造千变万化的图片切换效果</h2>

<p>ViewPager使用时间长了，他的切换效果容易觉得枯燥，形成一种审美疲劳<del>我们需要改变，学习学习改变ViewPager切换时的效果，实现个性化的图片切换</del></p>

<p><figure><img src="media/15561207869583/20170222778011406001554_7159.gif" alt=""/></figure></p>

<p>是不是比传统的效果个性很多，嘿嘿<del>其实很简单，学习完这篇博客，保证你可以自定义切换效果，做出各种丧心病狂的切换</del></p>

<h3 id="toc_21">制作前的分析</h3>

<p>观察下效果图，实际上改变的就是切换时的动画，那么简单了，只需要用户在切换时，拿到当前的View和下一个View，然后添加动画是不是就可以了。好，第一步，获取用户切换时的当前View和切换至的目的View。我们再来看一下，如果获取了当前View和目的View，对于动画我们需要缓慢的变化，最好是根据用户的手势滑动。比如上述效果，用户滑动时，目的图片根据用户滑动距离缓缓出现和慢慢变大。好，第二步，设计动画的梯度变化。<br/><br/>
经过分析，我们总结出两个步骤，下面我们开始一步一步来打造~~</p>

<h3 id="toc_22">获取用户切换时当前View和切换至的目的View。</h3>

<p>ViewPager也需要监听用户的手势，所以肯定提供了某个方法。于是纵观ViewPager的方法，发现了一个叫做 onPageScrolled(int position, float positionOffset, int positionOffsetPixels)的方法~~<br/><br/>
没错就是这个方法：在页面滚动时调用~<br/><br/>
下面仔细研究下这几个参数：<br/><br/>
直接说测试结果：<br/><br/>
在非第一页与最后一页时，滑动到下一页，position为当前页位置；滑动到上一页：position为当前页-1<br/><br/>
positionOffset 滑动到下一页，[0,1)区间上变化；滑动到上一页：(1,0]区间上变化<br/><br/>
positionOffsetPixels这个和positionOffset很像：滑动到下一页，[0,宽度)区间上变化；滑动到上一页：(宽度,0]区间上变化<br/>
第一页时：滑动到上一页position=0 ，其他基本为0 ；最后一页滑动到下一页 position为当前页位置，其他两个参数为0<br/><br/>
豁然发现，我们需要的步骤的第二步解决了，positionOffset很适合作为，渐变，缩放的控制参数；positionOffsetPixels则可以作为平移等的控制参数。  </p>

<p><strong><em>那么如何获得当前View和目的View呢：</em></strong><br/><br/>
分享几个我的歧途：</p>

<ul>
<li>【错误】我通过getChildAt(position)，getChildAt(position+1)，getChildAt(position-1)获得滑动时，左右的两个View；乍一看，还真觉得不错<del>在代码写出来，再乍效果也出不来</del>错误原因：我们忽略一个特别大的东西，ViewPager的机制，滑动时动态加载和删除View，ViewPager其实只会维持2到3个View，而position的范围基本属于无限~~</li>
<li>【错误】我通过getCurrentItem获得当前的位置，然后+1，-1获得后一个或者前一个<del>正在窃喜，赶快代码改过来，效果怎么也不对，乱七八糟的</del>仔细观察日志，这个getCurrentItem当用户手指离开的屏幕，Page还在动画执行时，就改变了<del>难怪~整个滑动过程并不是固定的</del>唉，心都碎了~</li>
<li>【错误】position在整个滑动的过程中是不变化的，而且ViewPager会保存2个或3个View;那么我考虑，如果是第一页、或者最后一页那么我取getChildAt(0)和getChildAt(1)，如果在其他页面则为getChildAt(0),getChildAt(2),然后经过一系列的变化～我想这会总该对了吧，于是我遇到第一问题，第一页的时候，不管左右position都为0，尼玛，这哪个为左View，哪个为右View~~<br/>
说了这么多错误，大家可以绕过这些弯路，也能从这些弯路里面看出点什么~<br/>
下面说正确的，其实ViewPager在添加一个View或者销毁一个View时，是我们自己的PageAdapter中控制的，于是我们可以在ViewPager里面维系一个HashMap<Position，View>，然后滑动的时候，通过get（position）取出，比如上述效果，始终是右边的View变化，要么从小到大，要么从大到小<br/>
那么滑倒下一页：左边的View:map.get(position) ，右边的View : map.get(position+1) .<br/>
那么滑倒上一页：左边的View : map.get(position) ， 右边的View : map.get(position+1) ， 一样的，因为滑到上一页，position为当前页-1<br/>
好了，至此，我们分析了且解决了所有步骤。<br/></li>
</ul>

<h3 id="toc_23">代码</h3>

<p><strong>MainActivity</strong>  </p>

<pre class="line-numbers"><code class="language-java">package com.example.zhy_jazzyviewpager;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.view.Menu;  
import android.view.View;  
import android.view.ViewGroup;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    protected static final String TAG = &quot;MainActivity&quot;;  
    private int[] mImgIds;  
    private MyJazzyViewPager mViewPager;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        mImgIds = new int[] { R.drawable.a, R.drawable.b, R.drawable.c,  
                R.drawable.d };  
        mViewPager = (MyJazzyViewPager) findViewById(R.id.id_viewPager);  
        mViewPager.setAdapter(new PagerAdapter()  
        {  
  
            @Override  
            public boolean isViewFromObject(View arg0, Object arg1)  
            {  
                return arg0 == arg1;  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
                container.removeView((View) object);  
            }  
  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
                ImageView imageView = new ImageView(MainActivity.this);  
                imageView.setImageResource(mImgIds[position]);  
                imageView.setScaleType(ScaleType.CENTER_CROP);  
                container.addView(imageView);  
                mViewPager.setObjectForPosition(imageView, position);  
                return imageView;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
  
}
</code></pre>

<p>这个很常见的代码，就是初始化ViewPager<del>就没啥可说的了</del>有一点需要注意：在instantiateItem方法，我们多调用了一个mViewPager.setObjectForPosition(imageView, position);其实就是为了给我们的Map存值</p>

<p><strong>主要看自定义的ViewPager</strong>  </p>

<pre class="line-numbers"><code class="language-java">package com.example.zhy_jazzyviewpager;  
  
import java.util.HashMap;  
import java.util.LinkedHashMap;  
  
import android.content.Context;  
import android.support.v4.view.ViewPager;  
import android.util.AttributeSet;  
import android.util.Log;  
import android.view.View;  
  
import com.nineoldandroids.view.ViewHelper;  
  
public class MyJazzyViewPager extends ViewPager  
{  
    private float mTrans;  
    private float mScale;  
    /** 
     * 最大的缩小比例 
     */  
    private static final float SCALE_MAX = 0.5f;  
    private static final String TAG = &quot;MyJazzyViewPager&quot;;  
    /** 
     * 保存position与对于的View 
     */  
    private HashMap&lt;Integer, View&gt; mChildrenViews = new LinkedHashMap&lt;Integer, View&gt;();  
    /** 
     * 滑动时左边的元素 
     */  
    private View mLeft;  
    /** 
     * 滑动时右边的元素 
     */  
    private View mRight;  
  
    public MyJazzyViewPager(Context context, AttributeSet attrs)  
    {  
        super(context, attrs);  
    }  
  
    @Override  
    public void onPageScrolled(int position, float positionOffset,  
            int positionOffsetPixels)  
    {  
  
//      Log.e(TAG, &quot;position=&quot; + position+&quot;, positionOffset = &quot;+positionOffset+&quot; ,positionOffsetPixels =  &quot; + positionOffsetPixels+&quot; , currentPos = &quot; + getCurrentItem());  
          
        //滑动特别小的距离时，我们认为没有动，可有可无的判断  
        float effectOffset = isSmall(positionOffset) ? 0 : positionOffset;  
          
        //获取左边的View  
        mLeft = findViewFromObject(position);  
        //获取右边的View  
        mRight = findViewFromObject(position + 1);  
          
        // 添加切换动画效果  
        animateStack(mLeft, mRight, effectOffset, positionOffsetPixels);  
        super.onPageScrolled(position, positionOffset, positionOffsetPixels);  
    }  
  
    public void setObjectForPosition(View view, int position)  
    {  
        mChildrenViews.put(position, view);  
    }  
  
    /** 
     * 通过过位置获得对应的View 
     *  
     * @param position 
     * @return 
     */  
    public View findViewFromObject(int position)  
    {  
        return mChildrenViews.get(position);  
    }  
  
    private boolean isSmall(float positionOffset)  
    {  
        return Math.abs(positionOffset) &lt; 0.0001;  
    }  
  
    protected void animateStack(View left, View right, float effectOffset,  
            int positionOffsetPixels)  
    {  
        if (right != null)  
        {  
            /** 
             * 缩小比例 如果手指从右到左的滑动（切换到后一个）：0.0~1.0，即从一半到最大 
             * 如果手指从左到右的滑动（切换到前一个）：1.0~0，即从最大到一半 
             */  
            mScale = (1 - SCALE_MAX) * effectOffset + SCALE_MAX;  
            /** 
             * x偏移量： 如果手指从右到左的滑动（切换到后一个）：0-720 如果手指从左到右的滑动（切换到前一个）：720-0 
             */  
            mTrans = -getWidth() - getPageMargin() + positionOffsetPixels;  
            ViewHelper.setScaleX(right, mScale);  
            ViewHelper.setScaleY(right, mScale);  
            ViewHelper.setTranslationX(right, mTrans);  
        }  
        if (left != null)  
        {  
            left.bringToFront();  
        }  
    }  
}
</code></pre>

<p>可以看到，核心代码都是onPageScrolled，我们通过findViewFromObject(position); findViewFromObject(position + 1);分别获取了左右两边的View，然后添加动画效果；当前这个例子添加了两个动画，一个是从0.5放大到1.0或者1.0缩小到0.5，没错由我们的positionOffset提供梯度的变化<del>还有个平移的动画：下一页直接移动到当前屏幕（默认是在右边，可以注释这个效果，怎么运行看看），然后不断的通过positionOffsetPixels抵消原来默认移动时的位移，让用户感觉它就在原地放大缩小</del><br/><br/>
好了，这样就实现了<del>你可以随便写自己喜欢的动画效果，比如在默认上面加个淡入淡出或者神马，随便</del>是不是很随意~~<br/><br/>
我们的布局文件：  </p>

<pre class="line-numbers"><code class="language-markup">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
  &gt;  
  
    &lt;com.example.zhy_jazzyviewpager.MyJazzyViewPager  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:id=&quot;@+id/id_viewPager&quot; /&gt;  
  
&lt;/RelativeLayout&gt; 
</code></pre>

<h3 id="toc_24">JazzyViewPager的使用</h3>

<p>其实上面的实现就是github上JazzyViewPager的源码，用法不用说了，就是我们的MainActivity，它内置了大概10来种效果，我们可以通过代码或者布局上面设置动画效果<del>我们上面的例子效果，它叫做Stack；<br/><br/>
使用JazzViewPager的代码：其实基本一样</del>最后也会贴上JazzyViewPager的源码的下载  </p>

<p><strong>MainActivity</strong>  </p>

<pre class="line-numbers"><code class="language-java">package com.jfeinstein.jazzyviewpager;  
  
import com.jfeinstein.jazzyviewpager.JazzyViewPager.TransitionEffect;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.view.View;  
import android.view.ViewGroup;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    protected static final String TAG = &quot;MainActivity&quot;;  
    private int[] mImgIds;  
    private JazzyViewPager mViewPager;  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        mImgIds = new int[] { R.drawable.a, R.drawable.b, R.drawable.c,  
                R.drawable.d };  
        mViewPager = (JazzyViewPager) findViewById(R.id.id_viewPager);  
        //设置切换效果  
        mViewPager.setTransitionEffect(TransitionEffect.Stack);  
          
          
        mViewPager.setAdapter(new PagerAdapter()  
        {  
  
            @Override  
            public boolean isViewFromObject(View arg0, Object arg1)  
            {  
                return arg0 == arg1;  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
                container.removeView((View) object);  
            }  
  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
                ImageView imageView = new ImageView(MainActivity.this);  
                imageView.setImageResource(mImgIds[position]);  
                imageView.setScaleType(ScaleType.CENTER_CROP);  
                container.addView(imageView);  
                mViewPager.setObjectForPosition(imageView, position);  
                return imageView;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
}
</code></pre>

<p>与我们的代码唯一区别就是：<br/><br/>
//设置切换效果<br/><br/>
mViewPager.setTransitionEffect(TransitionEffect.Stack);<br/><br/>
它有12中可选的切换效果，其实就是写了12个切换的动画~~~<br/><br/>
好了，最后附上一个我比较喜欢的效果：Tablet  </p>

<p><figure><img src="media/15561207869583/201702229727320140722145522928.gif" alt=""/></figure></p>

<h2 id="toc_25">实现个性的ViewPager切换动画 实战PageTransformer（兼容Android3.0以下）</h2>

<h3 id="toc_26">概述</h3>

<p>本篇博文，将：</p>

<ol>
<li>介绍如何使用setPageTransformer设置切换动画；</li>
<li>自定义PageTransformer实现个性的切换动画；</li>
<li>该方法在SDK11以下的版本不起作用，我们会对其做一定修改，让其向下兼容。<br/>
官方示例地址：<a href="http://developer.Android.com/training/animation/screen-slide.html">http://developer.Android.com/training/animation/screen-slide.html</a> 有兴趣的可以去看看~~</li>
</ol>

<h3 id="toc_27">setPageTransformer的使用</h3>

<p>首先我们迅速的实现一个传统的ViewPager效果~</p>

<h4 id="toc_28">布局文件</h4>

<pre class="line-numbers"><code class="language-markup">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot; &gt;  
  
    &lt;android.support.v4.view.ViewPager  
        android:id=&quot;@+id/id_viewpager&quot;  
        android:layout_width=&quot;fill_parent&quot;  
        android:layout_height=&quot;fill_parent&quot; /&gt;  
  
&lt;/RelativeLayout&gt;
</code></pre>

<h4 id="toc_29">MainActivity</h4>

<pre class="line-numbers"><code class="language-java">package com.zhy.demo_zhy_08_viewpageranim;  
  
import java.util.ArrayList;  
import java.util.List;  
  
import android.app.Activity;  
import android.os.Bundle;  
import android.support.v4.view.PagerAdapter;  
import android.support.v4.view.ViewPager;  
import android.view.View;  
import android.view.ViewGroup;  
import android.view.Window;  
import android.widget.ImageView;  
import android.widget.ImageView.ScaleType;  
  
public class MainActivity extends Activity  
{  
    private ViewPager mViewPager;  
    private int[] mImgIds = new int[] { R.drawable.guide_image1,  
            R.drawable.guide_image2, R.drawable.guide_image3 };  
    private List&lt;ImageView&gt; mImageViews = new ArrayList&lt;ImageView&gt;();  
  
    @Override  
    protected void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        setContentView(R.layout.activity_main);  
  
        initData();  
  
        mViewPager = (ViewPager) findViewById(R.id.id_viewpager);  
  
        mViewPager.setAdapter(new PagerAdapter()  
        {  
            @Override  
            public Object instantiateItem(ViewGroup container, int position)  
            {  
  
                container.addView(mImageViews.get(position));  
                return mImageViews.get(position);  
            }  
  
            @Override  
            public void destroyItem(ViewGroup container, int position,  
                    Object object)  
            {  
  
                container.removeView(mImageViews.get(position));  
            }  
  
            @Override  
            public boolean isViewFromObject(View view, Object object)  
            {  
                return view == object;  
            }  
  
            @Override  
            public int getCount()  
            {  
                return mImgIds.length;  
            }  
        });  
  
    }  
  
    private void initData()  
    {  
        for (int imgId : mImgIds)  
        {  
            ImageView imageView = new ImageView(getApplicationContext());  
            imageView.setScaleType(ScaleType.CENTER_CROP);  
            imageView.setImageResource(imgId);  
            mImageViews.add(imageView);  
        }  
    }  
  
}
</code></pre>

<p>好了，这样一个传统ViewPager就实现了<del>大家对上面代码应该不会有任何陌生的感觉~运行效果也不用贴图了，大家肯定知道</del></p>

<h4 id="toc_30">PageTransformer</h4>

<p>ViewPager有个方法叫做：<br/><br/>
<code>setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer)</code><br/><br/>
用于设置ViewPager切换时的动画效果，并且google官方还给出了两个示例。<br/><br/>
只需要在上述代码中调用setPageTransformer即可添加切换动画效果~~下面演示google的两个PageTransformer的代码，以及运行效果。  </p>

<h5 id="toc_31">DepthPageTransformer</h5>

<pre class="line-numbers"><code class="language-java">
public class DepthPageTransformer implements ViewPager.PageTransformer {  
    private static final float MIN_SCALE = 0.75f;  
  
    public void transformPage(View view, float position) {  
        int pageWidth = view.getWidth();  
  
        if (position &lt; -1) { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            view.setAlpha(0);  
  
        } else if (position &lt;= 0) { // [-1,0]  
            // Use the default slide transition when moving to the left page  
            view.setAlpha(1);  
            view.setTranslationX(0);  
            view.setScaleX(1);  
            view.setScaleY(1);  
  
        } else if (position &lt;= 1) { // (0,1]  
            // Fade the page out.  
            view.setAlpha(1 - position);  
  
            // Counteract the default slide transition  
            view.setTranslationX(pageWidth * -position);  
  
            // Scale the page down (between MIN_SCALE and 1)  
            float scaleFactor = MIN_SCALE  
                    + (1 - MIN_SCALE) * (1 - Math.abs(position));  
            view.setScaleX(scaleFactor);  
            view.setScaleY(scaleFactor);  
  
        } else { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            view.setAlpha(0);  
        }  
    }  
}
</code></pre>

<p>调用代码：<br/><br/>
<code>mViewPager.setPageTransformer(true, new DepthPageTransformer());</code><br/><br/>
效果：  </p>

<p><figure><img src="media/15561207869583/201702227053520141028231742399.gif" alt=""/></figure></p>

<h5 id="toc_32">ZoomOutPageTransformer</h5>

<pre class="line-numbers"><code class="language-java">package com.zhy.view;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.util.Log;  
import android.view.View;  
  
public class ZoomOutPageTransformer implements ViewPager.PageTransformer  
{  
    private static final float MIN_SCALE = 0.85f;  
    private static final float MIN_ALPHA = 0.5f;  
  
    @SuppressLint(&quot;NewApi&quot;)  
    public void transformPage(View view, float position)  
    {  
        int pageWidth = view.getWidth();  
        int pageHeight = view.getHeight();  
  
        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            view.setAlpha(0);  
  
        } else if (position &lt;= 1) //a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0  
        { // [-1,1]  
            // Modify the default slide transition to shrink the page as well  
            float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position));  
            float vertMargin = pageHeight * (1 - scaleFactor) / 2;  
            float horzMargin = pageWidth * (1 - scaleFactor) / 2;  
            if (position &lt; 0)  
            {  
                view.setTranslationX(horzMargin - vertMargin / 2);  
            } else  
            {  
                view.setTranslationX(-horzMargin + vertMargin / 2);  
            }  
  
            // Scale the page down (between MIN_SCALE and 1)  
            view.setScaleX(scaleFactor);  
            view.setScaleY(scaleFactor);  
  
            // Fade the page relative to its size.  
            view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE)  
                    / (1 - MIN_SCALE) * (1 - MIN_ALPHA));  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            view.setAlpha(0);  
        }  
    }  
}
</code></pre>

<p>调用代码：<br/><br/>
<code>mViewPager.setPageTransformer(true, new ZoomOutPageTransformer());</code>  </p>

<p>效果：  </p>

<p><figure><img src="media/15561207869583/201702224016820141028231715785.gif" alt=""/></figure></p>

<p>效果图都是google官网上的，我们的测试图会在兼容3.0以下贴出来，不然就重复了~~<br/><br/>
为ViewPager添加切换就一行代码是不是很happy，可惜是不兼容3.0以下的版本的，该方法的注释上写到：<br/><br/>
setting a PageTransformer prior to Android 3.0 (API 11) will have no effect 在3.0之前的版本设置此方法是没有效果的，那么下面我们就看如何让其兼容3.0以下版本。  </p>

<h3 id="toc_33">版本的向下兼容</h3>

<h4 id="toc_34">不兼容的原因</h4>

<p>首先看下为什么不兼容，3.0以下呢？<br/><br/>
看上面的两个示例代码，代码中View的动画使用的是属性动画，而属性动画是3.0才推出的，那么这么写肯定是不兼容3.0以下了~<br/><br/>
那么我们首先引入nineoldandroids，让动画先能在3.0以下跑再说：<br/><br/>
修改DepthPageTransformer  </p>

<pre class="line-numbers"><code class="language-java">package com.zhy.view;  
  
import com.nineoldandroids.view.ViewHelper;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.view.View;  
  
public class DepthPageTransformer implements ViewPager.PageTransformer  
{  
    private static final float MIN_SCALE = 0.75f;  
  
    public void transformPage(View view, float position)  
    {  
        int pageWidth = view.getWidth();  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            // view.setAlpha(0);  
            ViewHelper.setAlpha(view, 0);  
        } else if (position &lt;= 0)// a页滑动至b页 ； a页从 0.0 -1 ；b页从1 ~ 0.0  
        { // [-1,0]  
            // Use the default slide transition when moving to the left page  
            // view.setAlpha(1);  
            ViewHelper.setAlpha(view, 1);  
            // view.setTranslationX(0);  
            ViewHelper.setTranslationX(view, 0);  
            // view.setScaleX(1);  
            ViewHelper.setScaleX(view, 1);  
            // view.setScaleY(1);  
            ViewHelper.setScaleY(view, 1);  
  
        } else if (position &lt;= 1)  
        { // (0,1]  
            // Fade the page out.  
            // view.setAlpha(1 - position);  
            ViewHelper.setAlpha(view, 1 - position);  
  
            // Counteract the default slide transition  
            // view.setTranslationX(pageWidth * -position);  
            ViewHelper.setTranslationX(view, pageWidth * -position);  
  
            // Scale the page down (between MIN_SCALE and 1)  
            float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - position);  
            // view.setScaleX(scaleFactor);  
            ViewHelper.setScaleX(view, scaleFactor);  
            // view.setScaleY(1);  
            ViewHelper.setScaleY(view, scaleFactor);  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            // view.setAlpha(0);  
            ViewHelper.setAlpha(view, 1);  
        }  
    }  
}
</code></pre>

<p>很简单，把所有属性动画换成ViewHelper去设置就好了。现在我们去3.0以下的机子上去运行，发现还是没有效果~~<br/><br/>
为什么呢？<br/><br/>
我们再去看看setPageTransformer的源码：  </p>

<pre class="line-numbers"><code class="language-java">public void setPageTransformer(boolean reverseDrawingOrder, PageTransformer transformer) {  
       if (Build.VERSION.SDK_INT &gt;= 11) {  
           final boolean hasTransformer = transformer != null;  
           final boolean needsPopulate = hasTransformer != (mPageTransformer != null);  
           mPageTransformer = transformer;  
           setChildrenDrawingOrderEnabledCompat(hasTransformer);  
           if (hasTransformer) {  
               mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;  
           } else {  
               mDrawingOrder = DRAW_ORDER_DEFAULT;  
           }  
           if (needsPopulate) populate();  
       }  
   }
</code></pre>

<p>终于发现原因了，原来在此方法内部判断了如果是11以上的版本才让动画生效~~<br/><br/>
那么，没办法了，如果想兼容，必须修改ViewPager的源码了~~  </p>

<h4 id="toc_35">完美向下兼容</h4>

<p>我们将ViewPager的源码拷贝一份至我们的项目中，修改名称为ViewPagerCompat；然后注释掉SDK版本判断那一句  </p>

<pre class="line-numbers"><code class="language-java">public class ViewPagerCompat extends ViewGroup {  
    public void setPageTransformer(boolean reverseDrawingOrder, ViewPager.PageTransformer transformer) {  
//        if (Build.VERSION.SDK_INT &gt;= 11)   
        {  
            final boolean hasTransformer = transformer != null;  
            final boolean needsPopulate = hasTransformer != (mPageTransformer != null);  
            mPageTransformer = transformer;  
            setChildrenDrawingOrderEnabledCompat(hasTransformer);  
            if (hasTransformer) {  
                mDrawingOrder = reverseDrawingOrder ? DRAW_ORDER_REVERSE : DRAW_ORDER_FORWARD;  
            } else {  
                mDrawingOrder = DRAW_ORDER_DEFAULT;  
            }  
            if (needsPopulate) populate();  
        }  
    }
 }
 ```
 
注意，所有的PageTransformer使用ViewPager.PageTransformer  
然后我们把项目中的ViewPager改为ViewPagerCompat；记得修改布局文件，以及MainActivity中的ViewPager为ViewPagerCompat
我们在2.3.3的模拟器上测试下效果：  

![](media/15561207869583/201702225837420141028231840899.gif)

可以看到，我们的切换动画完美的运行在2.3.3的机器上~~so happy ~~没有ViewPager源码的童鞋不要紧，我会在文末的源码下载中加入ViewPager源码，让你可以尽情去测试~~  
当然了，仅仅是兼容当然不能满足我们的好奇心，难道我们做到了兼容，还只能使用Google给的示例动画么~~我们强大的创新呢~~下面带领大家分析setPageTransformer方法，然后设计一个个性的动画切换效果  

#### 自定义PageTransformer实现个性切换动画

``` java

public interface PageTransformer {  
       /** 
        * Apply a property transformation to the given page. 
        * 
        * @param page Apply the transformation to this page 
        * @param position Position of page relative to the current front-and-center 
        *                 position of the pager. 0 is front and center. 1 is one full 
        *                 page position to the right, and -1 is one page position to the left. 
        */  
       public void transformPage(View page, float position);  
   }
</code></pre>

<p>可以看到该接口只有一个方法，第一个是我们的view，第二个是position~~<br/><br/>
当我们滑动时：会打印出当然ViewPager中存活的每个View以及它们的position的变化<del>注意是每一个，所以建议别只log position，不然你会觉得莫名其妙的输出</del><br/><br/>
position的可能性的值有，其实从官方示例的注释就能看出：<br/><br/>
[-Infinity,-1)  已经看不到了<br/><br/>
(1,+Infinity] 已经看不到了<br/><br/>
 [-1,1] <br/>
重点看[-1,1]这个区间 ， 其他两个的View都已经看不到了~~  </p>

<p>假设现在ViewPager在A页现在滑出B页，则:<br/><br/>
A页的position变化就是( 0, -1]<br/><br/>
B页的position变化就是[ 1 , 0 ]<br/><br/>
知道了我们滑动时position的变化~~那么就开始设计我们的个性的切换效果；<br/><br/>
官方给的例子，有变化透明度、偏移量、缩放的，我们准备来个不一样的，我们变化角度，即rotation;<br/><br/>
大概的效果是这样的：  </p>

<p><figure><img src="media/15561207869583/20170222949151414293422_1593.gif" alt=""/></figure></p>

<p>下面我们分析代码：<br/><br/>
我们设置View的旋转中心为：<br/><br/>
ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);<br/><br/>
ViewHelper.setPivotY(view, view.getMeasuredHeight());<br/><br/>
依然是ViewPager在A页现在滑出B页<br/><br/>
那么A页应当在滑动过程中0度到-20度的偏移，B页应当在滑动过程中+20度到0度的偏移<br/><br/>
结合<br/><br/>
A页的position变化就是( 0, -1]<br/><br/>
B页的position变化就是[ 1 , 0 ]<br/><br/>
那么旋转的角度即：mRot = (20 * position); A页 mRot :0 ,~ -20 ; B页 mRot :20 ~ 0  ;<br/><br/>
瞬间觉得好简单： </p>

<p><strong>完整代码</strong>：  </p>

<pre class="line-numbers"><code class="language-java">package com.zhy.view;  
  
import com.nineoldandroids.view.ViewHelper;  
  
import android.annotation.SuppressLint;  
import android.support.v4.view.ViewPager;  
import android.util.Log;  
import android.view.View;  
  
public class RotateDownPageTransformer implements ViewPager.PageTransformer  
{  
      
    private static final float ROT_MAX = 20.0f;  
    private float mRot;  
      
  
      
    public void transformPage(View view, float position)  
    {  
  
        Log.e(&quot;TAG&quot;, view + &quot; , &quot; + position + &quot;&quot;);  
  
        if (position &lt; -1)  
        { // [-Infinity,-1)  
            // This page is way off-screen to the left.  
            ViewHelper.setRotation(view, 0);  
  
        } else if (position &lt;= 1) // a页滑动至b页 ； a页从 0.0 ~ -1 ；b页从1 ~ 0.0  
        { // [-1,1]  
            // Modify the default slide transition to shrink the page as well  
            if (position &lt; 0)  
            {  
  
                mRot = (ROT_MAX * position);  
                ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);  
                ViewHelper.setPivotY(view, view.getMeasuredHeight());  
                ViewHelper.setRotation(view, mRot);  
            } else  
            {  
  
                mRot = (ROT_MAX * position);  
                ViewHelper.setPivotX(view, view.getMeasuredWidth() * 0.5f);  
                ViewHelper.setPivotY(view, view.getMeasuredHeight());  
                ViewHelper.setRotation(view, mRot);  
            }  
  
            // Scale the page down (between MIN_SCALE and 1)  
  
            // Fade the page relative to its size.  
  
        } else  
        { // (1,+Infinity]  
            // This page is way off-screen to the right.  
            ViewHelper.setRotation(view, 0);  
        }  
    }  
}
</code></pre>

<p>你没看错，if else 里面代码是一样的，为了好理解特意没有合并到一起~~  </p>

<p>到此，我们从setPageTransformer使用，到修改ViewPager做到向下兼容，直至自己定义出个性的切换效果 都已经介绍完毕～～<br/><br/>
大家可以发挥自己的创造力，做出各种神奇的动画效果，ok，就到这里！  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869535.html">
                
                  <h1>Android-Android Studio 快捷键</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">常用快捷键</h2>

<h3 id="toc_1">自动补全</h3>

<ul>
<li>使用<code>Enter</code>会补全你选择的语句</li>
<li>使用<code>Tab</code>的话，会替换掉你之前在这里的内容（删除后面的语句直到遇到点号，逗号，分号）</li>
</ul>

<h3 id="toc_2">自动缩进对齐</h3>

<p><code>ctr + alt + I</code></p>

<h3 id="toc_3">返回编辑器窗口</h3>

<ul>
<li><code>Esc</code>: 返回编辑器</li>
<li><code>Shift + Esc</code>: 返回编辑器并关闭当前窗口</li>
</ul>

<h3 id="toc_4">快捷打开窗口</h3>

<ul>
<li>Mac: <code>Cmd + 数字</code></li>
<li>windows/Linux: <code>Alt + 数字</code></li>
</ul>

<h3 id="toc_5">任意窗口切换</h3>

<p><code>Ctrl + Tab</code>可以让你切换到任意窗口！<br/>
在这个切换窗口打开的时候，你可以直接按数字切换到对应的工具窗口，或者输入字母搜索右边的编辑器窗口，如果你需要关闭某个窗口，在上面按<code>BackSpace</code>即可。</p>

<h3 id="toc_6">隐藏所有窗口</h3>

<ul>
<li>Mac: <code>CMD + Shift + F12</code></li>
<li>windows/Linux: <code>Ctrl + shift + F12</code><br/>
如果需要恢复所有窗口，再按一次这个快捷键即可。</li>
</ul>

<h3 id="toc_7">参数提示</h3>

<p>这个功能估计很多人知道了，但是还是提一下。在自动补全以后，如果某个方法参数超级长，你不知道参数是什么怎么办？可以试试这个。</p>

<ul>
<li>Mac: <code>CMD + P</code></li>
<li>win/Linux: <code>Ctrl + P</code></li>
</ul>

<h3 id="toc_8">自动生成变量</h3>

<p>作为一门静态类型语言， <a href="http://lib.csdn.net/base/java">Java</a> 是有一定的类型推导能力的；那么你是否经常书写:</p>

<pre class="line-numbers"><code class="language-java">String testStr = &quot;testStr&quot;;
List&lt;String&gt; testStrings = new ArrayList&lt;String&gt;();
</code></pre>

<p>其实大可不必写那些恼火的类型声明的，一看就知道</p>

<pre class="line-numbers"><code class="language-text">testStr, testStrings
</code></pre>

<p>就知道是什么类型，再这么干不就是废话么！好在IDEA给了我们这个能力。尝试一下这个快捷键吧，会给你惊喜。</p>

<ul>
<li>Mac: <code>Cmd + Alt + V</code></li>
<li>Win/Linux: <code>Ctrl + Alt + V</code></li>
</ul>

<p>有的童鞋可能会问了：我使用<code>ArrayList, HashMap</code>的时候，习惯类型声明为<code>List,Map</code>等接口，这个自动生成的类型声明还是具体的实现啊，怎么办？这一点IDE已经帮你想到了，试试<code>shift + tab</code>,他会给你一个可以选择的类型列表～</p>

<h3 id="toc_9">自动提取参数</h3>

<p>有时候你正在写一个方法的时候发现。哎哟，这个变量最好是当作参数传递进来啊；要做成这么一件事，你必须把这个方法内部所有使用这个局部变量的地方替换，把所有调用这个函数的地方添加参数，繁琐至极！好了有了这个你可以随便玩了：</p>

<ul>
<li>Mac: <code>Cmd + Alt + P</code></li>
<li>Win/Linux: <code>Ctrl + Alt + P</code></li>
</ul>

<p>当然，如果你想保留原来的方法，只是搞一个参数不同的方法（重载）出来，可以在弹出的那个对话框里面打勾。</p>

<h3 id="toc_10">自动提取方法</h3>

<p>写代码的时候是否会发现不知不觉的这个方法已经太长了，适合分解然后提取出一个个子方法；或者是重构的时候看到一个一两千的函数，你是不是头都大了？一般情况下，我们都是把要提取的代码copy出来，然后写一个方法（还要什么该死的方法签名）然后把这段代码复制进来；其实这个过程是机械的，完全可以由IDE完成：</p>

<ul>
<li>Mac: <code>Cmd + Alt + M</code></li>
<li>Win/Linux: <code>Ctrl + Alt + M</code></li>
</ul>

<p>如果想改变方法的签名，在对话框里面选择你需要的就可以了～</p>

<blockquote>
<p>上面提到了三个快捷键其实是比较类似的，如何记忆呢？</p>

<ul>
<li>首先组合键都是<code>Cmd/Ctrl + Alt</code></li>
<li>然后提取变量Variable=V，参数Parameters=P，方法Method=M</li>
</ul>
</blockquote>

<h3 id="toc_11">内联变量/参数/方法</h3>

<p>好了学会了上面那几个快捷键，万一玩high了，比如提取了太多的方法，想“弄回去”，该怎么办呢？这个操作叫他<code>Inline..</code></p>

<ul>
<li>Mac: <code>Cmd + Alt + N</code></li>
<li>Win/Linux: <code>Ctrl + Alt + N</code></li>
</ul>

<p>上面那个图只是参考，其实不仅可以作用于变量，还可以是方法/参数，个人觉得方法inline比较有用。</p>

<h3 id="toc_12">万能重构键</h3>

<p>静态类型语言重构起来相对容易的，但是通常修改一个地方会牵扯到很多别的地方，我们只有一处一处找到这些编译错误然后手动修复。其实有好多工作是可以自动完成的，比如删除某个方法；先确认有没有人调用（Alt ＋ F7），没有的话把方法体删了，有的话去看看调用的地方再决定怎么办。<br/>
但是重构的操作实在是太多了！我们没有办法也没有必要一个个记住，知道这个快捷键即可，我叫他万能重构键:</p>

<ul>
<li>Mac : <code>Ctrl + T</code></li>
<li>Win/Linux: <code>Ctrl + Alt + Shift + T</code></li>
</ul>

<p>在Win/ <a href="http://lib.csdn.net/base/linux">Linux</a> 上可以考虑把这个快捷键改一下键，一下按四个键臣妾很难做到啊。。</p>

<h3 id="toc_13">重命名</h3>

<p><code>shift + F6</code></p>

<h3 id="toc_14">查找当前文件在项目中的位置</h3>

<p>快捷键: <code>Alt + F1</code></p>

<h3 id="toc_15">拓展选择</h3>

<p>这个功能应该很多人都知道；但还是说明一下，因为跟下面两个功能跟这个结合起来才有威力。这个功能太强大了，自己去按几遍就能想到很多使用场景了；我相信有了这个功能，你使用鼠标的机会会少很多。</p>

<ul>
<li>Mac: <code>Alt + up/down</code></li>
<li>Win/Linux: <code>ctrl + w / ctrl + shift + w</code></li>
</ul>

<h3 id="toc_16">Surround With..</h3>

<p>如果你想把一段代码使用<code>if</code>语句包起来；又或者使用<code>try</code>包围一段可能有运行时异常的代码，你会怎么干？<br/>
首先用光标定位到代码块开头，写上 <code>try {</code>然后，光标代码块末尾加<code>} catch (XXXRuntimeException e) {// todo}</code>？可以试试这个快捷键。</p>

<ul>
<li>Mac: <code>cmd + alt + t</code></li>
<li>Win/Linux: <code>ctrl + alt + t</code></li>
</ul>

<p>可以使用上面的拓展选择选择你需要的代码块，然后使用这个功能Surround With；如果你什么都不选择的话，那么默认选择的是光标所在行。</p>

<h3 id="toc_17">Unwrap/Remove</h3>

<p>这个功能跟上面提到的是一对，有了Surround With自然就有Unsurround With;使用情况没有上面那个那么多，但是好歹一对，一起介绍吧。</p>

<h3 id="toc_18">高亮某东西</h3>

<p>有时候看代码的时候，看到某个变量想知道哪里使用了它；你还在用肉眼查找吗？或者你杀鸡用牛刀<br/>
<code>Find Usgae</code>？其实你的需求就是把这个变量全部给我打个标签，我想直观的知道它在哪。</p>

<ul>
<li>Mac: <code>cmd + shift + F7</code></li>
<li>Win/Linux: <code>ctrl + shift + F7</code><br/>
这个键功能远不止这个！</li>
<li>如果你高亮<code>return</code>或者<code>throw</code>，那么会把这个方法所有的返回点高亮出来！</li>
<li>高亮某个类的<code>extends</code>或者<code>implements</code>会把这个类Override的方法高亮出来</li>
<li>高亮<code>import</code>会把使用的地方显示出来<br/>
如果不想要高亮了，按下Esc就行。 </li>
</ul>

<h3 id="toc_19">显示方法调用树</h3>

<p>在看源码的时候，你还是使用<code>alt + F7</code>和<code>ctrl + B</code>在各个类之间来回穿梭吗？其实好多时候你就是想知道这个调用结构是怎么样的而已；谁是怎么一步一步滴调用谁的；这个快捷键会给你一个调用树。有了这个大菊观，继续探讨就很容易了。<br/>
快捷键: <code>ctrl + alt + h</code></p>

<h3 id="toc_20">万能快捷键</h3>

<p>记得之前提到过一个万能重构键, 有关重构的一切操作都可通过它完成。那么Android Studio这么快捷键，这么多功能，臣妾怎么可能都记住！要是有万能钥匙就好了！That’s it!<br/>
使用这个快捷键，你想到什么功能，打开它搜索就可以了；打个比方，我想看看 <a href="http://lib.csdn.net/base/java">Java</a> 的<code>for each</code>循环和普通的<code>for</code>循环底层是不是同一个实现;那么我就需要看虚拟机字节码了；我记得有这个功能但是不知道快捷键是啥；OK，<code>Cmd + shift + A</code>，输入<code>bytecode</code>:</p>

<h3 id="toc_21">删除当前行</h3>

<ul>
<li>Mac: <code>ctrl + Y</code></li>
<li>Win/Linux: <code>Command + Y</code></li>
</ul>

<h3 id="toc_22">Find usage</h3>

<p><code>alt+F7</code></p>

<h3 id="toc_23">格式化代码</h3>

<ul>
<li>Mac: <code>alt+command+L</code></li>
<li>Win/Linux: <code>ctrl+alt+L</code></li>
</ul>

<h3 id="toc_24">优化import</h3>

<ul>
<li>Mac: <code>alt+command+O</code></li>
<li>Win/Linux: <code>ctrl+alt+O</code></li>
</ul>

<h3 id="toc_25">Declaration查看定义</h3>

<ul>
<li>Mac: <code>command+B</code></li>
<li>Win/Linux: <code>ctrl+B</code></li>
</ul>

<h3 id="toc_26">快递定位并高亮错误（deprecate，unused）</h3>

<ul>
<li>Mac: <code>(shift+)F2</code></li>
<li>Win/Linux: <code>F2</code></li>
</ul>

<h3 id="toc_27">Override Methods</h3>

<ul>
<li>Mac: <code>command+O</code></li>
<li>Win/Linux: <code>ctrl+O</code></li>
</ul>

<h3 id="toc_28">Implement Methods</h3>

<ul>
<li>Mac: <code>command+I</code></li>
<li>Win/Linux: <code>ctrl+I</code></li>
</ul>

<h3 id="toc_29">Super Method（Class）</h3>

<ul>
<li>Mac: <code>command+U</code></li>
<li>Win/Linux: <code>ctrl+U</code></li>
</ul>

<h3 id="toc_30">Previous/Next Method</h3>

<p><code>control+上下方向键</code></p>

<h3 id="toc_31">引入包，添加注释…</h3>

<p><code>alt+enter</code></p>

<h3 id="toc_32">Run</h3>

<p>shift+F10 </p>

<h3 id="toc_33">Debug </h3>

<p>shift+F9</p>

<h3 id="toc_34">Make Project</h3>

<ul>
<li>Mac: <code>command+F9</code></li>
<li>Win/Linux: <code>ctrl+F9</code></li>
</ul>

<h3 id="toc_35">Make Module</h3>

<ul>
<li>Mac: <code>shift+command+F9</code></li>
<li>Win/Linux: <code>shift+ctrl+F9</code></li>
</ul>

<h3 id="toc_36">关闭当前的执行的task</h3>

<ul>
<li>Mac: <code>command+F2</code></li>
<li>Win/Linux: <code>ctrl+F2</code></li>
</ul>

<h3 id="toc_37">添加/取消断点</h3>

<ul>
<li>Mac: <code>command+F8</code></li>
<li>Win/Linux: <code>ctrl+F8</code></li>
</ul>

<h3 id="toc_38">查看所有断点 Debug</h3>

<ul>
<li>Mac: <code>shift+command+F8</code></li>
<li>Win/Linux: <code>shift+ctrl+F8</code></li>
</ul>

<h3 id="toc_39">Step Into</h3>

<p> <code>F7</code></p>

<h3 id="toc_40">Step Over</h3>

<p><code>F8</code></p>

<h3 id="toc_41">Step out</h3>

<p><code>shift+F8</code> </p>

<h3 id="toc_42">resume </h3>

<p><code>F9</code></p>

<h3 id="toc_43">Run to Cursor</h3>

<p><code>alt+F9</code></p>

<h3 id="toc_44">Find</h3>

<ul>
<li>Mac: <code>command+F</code></li>
<li>Win/Linux: <code>command+F</code></li>
</ul>

<h3 id="toc_45">Replace</h3>

<ul>
<li>Mac: <code>command+R</code></li>
<li>Win/Linux: <code>command+R</code></li>
</ul>

<h3 id="toc_46">Find in Path</h3>

<p><code>control+shift+F</code></p>

<h3 id="toc_47">Replace in Path</h3>

<p><code>control+shiftÏ+R</code></p>

<h3 id="toc_48">Back/Forward操作</h3>

<ul>
<li>Mac: <code>alt+command+左右方向键</code></li>
<li>Win/Linux: <code>alt+ctrl+左右方向键</code></li>
</ul>

<h3 id="toc_49">Recent File</h3>

<ul>
<li>Mac: <code>command+E</code></li>
<li>Win/Linux: <code>ctrl+E</code></li>
</ul>

<h3 id="toc_50">Recently Change Files</h3>

<ul>
<li>Mac: <code>shift+command+E</code></li>
<li>Win/Linux: <code>shift+ctrl+E</code></li>
</ul>

<h3 id="toc_51">Search Method或者Class</h3>

<p>(Search Everywhere：<code>command+N</code>,<code>shift+command+N</code>,<code>shift+alt+command+N</code>)<br/>
<code>shift+shift</code></p>

<h3 id="toc_52">Search Class</h3>

<ul>
<li>Mac: <code>command+N</code></li>
<li>Win/Linux: <code>ctrl+N</code></li>
</ul>

<h3 id="toc_53">Search File</h3>

<ul>
<li>Mac: <code>shift+command+N</code></li>
<li>Win/Linux: <code>shift+ctrl+N</code></li>
</ul>

<h3 id="toc_54">Search Symbol</h3>

<ul>
<li>Mac: <code>shift+alt+command+N</code></li>
<li>Win/Linux: <code>shift+alt+ctrl+N</code></li>
</ul>

<h3 id="toc_55">Move Line Up/Move Line Down</h3>

<ul>
<li>Mac: <code>shift+command+上下方向键</code></li>
<li>Win/Linux: <code>shift+ctrl+上下方向键</code></li>
</ul>

<h2 id="toc_56">常用技巧</h2>

<h3 id="toc_57">书签（Bookmarks）</h3>

<ul>
<li><strong>描述</strong>：这是一个很有用的功能，让你可以在某处做个标记（书签），方便后面再跳转到此处。</li>
<li><strong>调用</strong>：Menu → Navigate → Bookmarks</li>
<li><strong>快捷键</strong>：
<ul>
<li>添加/移除书签：
<ul>
<li>OS X: <code>F3</code></li>
<li>Windows/Linux: <code>F11</code></li>
</ul></li>
<li>添加/移除书签(带标记)：
<ul>
<li>OS X: <code>Alt + F3</code></li>
<li>Windows/Linux: <code>Ctrl + F11</code></li>
</ul></li>
<li>显示全部书签显示所有的书签列表，并且是可以搜索的。
<ul>
<li>OS X: <code>Cmd + F3</code></li>
<li>Windows/Linux: <code>Shift + F11</code></li>
</ul></li>
<li>上一个/下一个书签：无，可以在设置中设置快捷键。</li>
</ul></li>
<li><strong>更多</strong>：当你为某个书签指定了标记，你可以使用快捷键 <code>Ctrl + 标记</code> 来快速跳转到标记处，比如输入<code>Ctrl + 1</code>，跳到标记为1的书签处</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980563110691.gif" alt=""/></figure></p>

<h3 id="toc_58">折叠/展开代码块（Collapse Expand Code Block） </h3>

<ul>
<li><strong>描述</strong>：该操作提供一种方法，让你隐藏你不关心的部分代码，以一种较为简洁的格式显示关键代码。一个有意思的用法是隐藏匿名内部类的代码，让其看起来像一个Lambda表达式。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + “+”/”-“</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + “+”/”-“</code></li>
</ul></li>
<li><strong>更多</strong>：可以在Settig → Editor → General → Code Folding 中设置折叠规则。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980566925324.gif" alt=""/></figure></p>

<h3 id="toc_59">与分支比对（Compare With Branch (Git)）</h3>

<ul>
<li><strong>描述</strong>：假如你的项目是使用git来管理的，你可以将当前文件或者文件夹与其他的分支进行比对。比较有用的是可以让你了解到你与主分支有多少差别。</li>
<li><strong>调用</strong>：Menu → VCS → Git → Compare With Branch</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980569269725.gif" alt=""/></figure></p>

<h3 id="toc_60">与剪切板比对（Compare With Clipboard）</h3>

<ul>
<li><strong>描述</strong>：将当前选中的部分与剪切板上的内容进行比对。</li>
<li><strong>调用</strong>：右键选中的部分，在右键菜单中选择“Compare With Clipboard”。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980574818952.gif" alt=""/></figure></p>

<h3 id="toc_61">上下文信息（Context Info）</h3>

<ul>
<li><strong>描述</strong>：当前作用域定义超过滚动区域，执行该操作将显示所在的上下文信息，通常它显示的是类名或者内部类类名或者当前所在的方法名。该操作在xml文件中同样适用。</li>
<li><strong>调用</strong>：Menu → View → Context Info</li>
<li><strong>快捷键</strong>：Alt + Q (Windows/Linux)</li>
<li><strong>更多</strong>：个人认为，这个功能更好的用法是快速查看当前类继承的父类或者实现的接口。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980576930267.gif" alt=""/></figure></p>

<h3 id="toc_62">查找操作（Find Action）</h3>

<ul>
<li><strong>描述</strong>：输入某个操作的名称，快速查找，对于没有快捷键的部分操作这是一个很有用的技巧。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd +Shift + A</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + A</code></li>
</ul></li>
<li><strong>更多</strong>：当某个操作是有快捷键的，会显示在旁边。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980579558685.gif" alt=""/></figure></p>

<h3 id="toc_63">查找补全（Find Complection）</h3>

<ul>
<li><strong>描述</strong>：当你在一个文件中进行查找时，使用自动补全快捷键可以给出在当前文件中出现的建议单词；</li>
<li><strong>快捷键</strong>：输入一些字符，然后使用自动补全
<ul>
<li>OS X: <code>Cmd + F</code></li>
<li>Windows/Linux: <code>Ctrl + F</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980582766335.gif" alt=""/></figure></p>

<h3 id="toc_64">隐藏所有面板（Hide All Panels）</h3>

<ul>
<li><strong>描述</strong>：切换编辑器铺满整个程序界面，隐藏其他的面板。再次执行该操作，将会回到隐藏前的状态。</li>
<li><strong>调用</strong>：Menu → Window → Active Tool Window → Hide All Windows；</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd +Shift + F12</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + F12</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980590796229.gif" alt=""/></figure></p>

<h3 id="toc_65">高亮一切（Hightlight All the Things）</h3>

<ul>
<li><strong>描述</strong>：该操作将会高亮某个字符在当前文件中所有出现的地方。这不仅仅是简单的匹配，实际上它会分析当前的作用域，只高亮相关的部分。</li>
<li><strong>调用</strong>：Menu → Edit → Find → Highlight Usages in File；</li>
<li><strong>定位到上一处/下一处</strong>：Menu → Edit → Find → Find Next/Previous；</li>
<li><strong>快捷键</strong>：相关快捷键请在菜单中查看；</li>
<li><strong>更多</strong>：
<ul>
<li>如果高亮一个方法的return或throw语句，将会高亮这个方法的所有出口/结束点；</li>
<li>如果高亮某个类定义处的extend或implements语句，将会高亮继承的或实现的方法；</li>
<li>高亮一个import语句也会高亮使用到的地方；</li>
<li>按下Esc可以退出高亮模式；</li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980592566371.gif" alt=""/></figure></p>

<h3 id="toc_66">回到上一个工具窗口（Jump to Last Tool Window）</h3>

<ul>
<li><strong>描述</strong>：有时候你会从某个工具窗口跳到编辑器里面，然后又需要重新回到刚才操作的那个工具窗，比如你查找使用情况的时，使用该操作可以在不使用鼠标的情况下跳转到之前的工具窗口。</li>
<li><strong>快捷键</strong>：F12</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980594942504.gif" alt=""/></figure></p>

<h3 id="toc_67">上一个编辑位置（Last Edit Location）</h3>

<ul>
<li><strong>描述</strong>：该操作将使得你导航到上一处你改动过的地方，这与点击工具栏上的返回箭头回到上一个定位位置是不一样的，该操作将会返回到上一个编辑的位置。</li>
<li><strong>快捷键</strong>： 
<ul>
<li>OS X: <code>Cmd + Shift + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Backspace﻿</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980596825126.gif" alt=""/></figure></p>

<h3 id="toc_68">在方法和内部类之间跳转（Move Between Methods and Inner Classes）</h3>

<ul>
<li><strong>描述</strong>：该操作让光标在当前文件的方法或内部类的名字间跳转。</li>
<li><strong>调用</strong>：Navigate → Next Method/Previous Method;</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + Up/Down﻿</code></li>
<li>Windows/Linux: <code>Alt + Up/Down</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980599666524.gif" alt=""/></figure></p>

<h3 id="toc_69">定位到嵌套文件（Navigate to Nested File）</h3>

<ul>
<li><strong>描述</strong>：有时你有一堆存放在不同目录下的同名文件，例如不同模块下的AndroidManifest.xml文件，当你想定位到其中的一个文件，你会得到一堆搜索结果，你还得辨认哪个才是你需要的。通过在检索框中输入部分路径的前缀，并添加斜杠号，你就可以在第一次尝试的时候就找到正确的那个。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X：<code>Shift + Cmd + O</code></li>
<li>Windows/Linux: <code>Shift + Ctrl + N﻿</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980603928163.gif" alt=""/></figure></p>

<h3 id="toc_70">定位到父类（Navigate to parent）</h3>

<ul>
<li><strong>描述</strong>：如果光标是在一个继承父类重写的方法里，这个操作将定位到父类实现的地方。如果光标是在类名上，则定位到父类类名。</li>
<li>Menu → Navigate → Super Class/Method</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + U</code></li>
<li>Windows/Linux: <code>Ctrl + U</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/2017110415098060573045.gif" alt=""/></figure></p>

<h3 id="toc_71">根据编号打开面板（Open a Panel by Its Number）</h3>

<ul>
<li><strong>描述</strong>：你可能已经注意到某些面板的名称左边有一个数字，这里有个快捷操作可以打开它们。如果你没看到面板的名称，请点击IDE的左下角的切换按钮。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + 数字</code></li>
<li>Windows/Linux: <code>Alt + 数字</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980607694073.gif" alt=""/></figure></p>

<h3 id="toc_72">在外部打开文件（Open File Externally）</h3>

<ul>
<li><strong>描述</strong>：通过这个快捷键，简单地点击 Tab，就可以打开当前文件所在的位置或者该文件的任意上层路径。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + 单击Tab</code></li>
<li>Windows/Linux: <code>Ctrl + 点击Tab</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980611657644.gif" alt=""/></figure></p>

<h3 id="toc_73">参数信息（Parameter Info）</h3>

<ul>
<li><strong>描述</strong>：这个操作将显示和你在方法声明处写一样的参数列表，当你想看某个存在的方法的参数，这是一个很有用的操作。光标下的参数显示为黄色，如果没有参数显示黄色，意味着你的方法调用是无效的，很可能是某个参数分配不对。（例如一个浮点数赋值给了整型参数）。如果你正在写一个方法调用，突然离开编辑的地方，再返回的时候，输入一个逗号，就可以重新触发参数信息。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + P</code></li>
<li>Windows/Linux: <code>Ctrl + P</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980616259965.gif" alt=""/></figure></p>

<h3 id="toc_74">快速查看定义（Quick Definition Lookup）</h3>

<ul>
<li><strong>描述</strong>：你曾经是否想查看一个方法或者类的具体实现，但是不想离开当前界面？ 该操作可以帮你搞定。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Alt + Space / Cmd + Y</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + I</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980618467849.gif" alt=""/></figure></p>

<h3 id="toc_75">最近修改的文件（Recently Changed Files）</h3>

<ul>
<li><strong>描述</strong>：该操作类似于“最近访问（Recents）”弹窗，会显示最近本地修改过的文件列表，根据修改时间排列。可以输入字符来过滤列表结果。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + E</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + E</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980621570214.gif" alt=""/></figure></p>

<h3 id="toc_76">最近访问（Recents）</h3>

<ul>
<li><strong>描述</strong>：该操作可以得到一个最近访问文件的可搜索的列表。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + E</code></li>
<li>Windows/Linux: <code>Ctrl + E</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980623538307.gif" alt=""/></figure></p>

<h3 id="toc_77">相关文件（Related File）</h3>

<ul>
<li><strong>描述</strong>：该操作有助于在布局文件和Activity/Fragment之间轻松跳转。这也是一个快捷操作，在类名/布局顶端的左侧。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + Cmd + Up</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + Home</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980626239846.gif" alt=""/></figure></p>

<h3 id="toc_78">返回到编辑器（Return to the Editor）</h3>

<ul>
<li><strong>描述</strong>：一大堆快捷键操作会把你从编辑器带走（type hierarchy, find usages, 等等）。如果你想返回到编辑器，你有两个选项：
<ul>
<li><code>Esc</code>：该操作仅仅把光标移回编辑器。</li>
<li><code>Shift + Esc</code>：该操作会关闭当前面板，然后把光标移回到编辑器。</li>
</ul></li>
<li><strong>快捷键</strong>：
<ul>
<li>返回但保留打开的面板：<code>Esc</code></li>
<li>关闭面板并返回：<code>Shift + Esc</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980627917706.gif" alt=""/></figure></p>

<h3 id="toc_79">Select In</h3>

<ul>
<li><strong>描述</strong>：拿着当前文件然后问你在哪里选中该文件。恕我直言，最有用的就是在项目结构或者资源管理器中打开该文件。每一个操作都有数字或者字母作为前缀，可以通过这个前缀来快速跳转。通常，我会 Alt + F1 然后 回车(Enter) 来打开项目视图，然后 再用 Alt + F1 在OS X的Finder里找到文件。你可以在文件中或者直接在项目视图里使用该操作。</li>
<li><strong>快捷键</strong>：<code>Alt + F1</code></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980629875328.gif" alt=""/></figure></p>

<h3 id="toc_80">扩大/缩小选择（Extend/Shrink Selection）</h3>

<ul>
<li><strong>描述</strong>：该操作会在上下文逐渐扩大/缩小当前选择范围。例如，它会先选中当前变量，再选中当前语句，然后选中整个方法，缩小选择则相反。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Alt + 上/下</code></li>
<li>Windows、Linux: <code>Ctrl+W / Ctrl + Shift + W﻿</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980631814449.gif" alt=""/></figure></p>

<h3 id="toc_81">Sublime Text式的多处选择（Sublime Text Multi Selection）</h3>

<ul>
<li><strong>描述</strong>：这个功能超级赞！该操作会识别当前选中字符串，选择下一个同样的字符串，并且添加一个光标。这意味着你可以在同一个文件里拥有多个光标，你可以同时在所有光标处输入任何东西。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + G</code></li>
<li>Windows、Linux: <code>Alt + Ｊ</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980633994665.gif" alt=""/></figure></p>

<h3 id="toc_82">文件结构弹窗（The File Structure Popup）</h3>

<ul>
<li><strong>描述</strong>：该操作可以展示当前类的大纲，并且可以快速跳转。你还可以通过键盘输入来过滤结果。这是一种很高效的方法来跳转到指定方法。</li>
<li><strong>更多</strong>：
<ul>
<li>你在输入字符的时候可以用驼峰风格来过滤选项。比如输入”oCr”会找到”onCreate”</li>
<li>你可以通过勾选多选框来决定是否显示匿名类。这在某些情况下很有用，比如你想直接跳转到一个OnClickListener的onClick方法。</li>
</ul></li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + F12</code></li>
<li>Windows/Linux: <code>Ctrl + F12</code></li>
</ul></li>
<li><strong>调用</strong>：Menu → Navigate → File Structure</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980637886260.gif" alt=""/></figure></p>

<h3 id="toc_83">切换器（The Switcher）</h3>

<ul>
<li><strong>描述</strong>：该快捷键基本上就是IDE的alt+tab/cmd+tab命令。你可以用它在导航tab或者面板切换。一旦打开这个窗口，只要一直按着ctrl键，你可以通过对应的数字或者字母快捷键快速选择。你也可以通过backspace键来关闭一个已选中的tab或者面板。</li>
<li><strong>快捷键</strong>：<code>Ctrl + Tab</code></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980639938168.gif" alt=""/></figure></p>

<h3 id="toc_84">版本控制操作弹窗（VCS Operations Popup）</h3>

<ul>
<li><strong>描述</strong>：该操作会给你显示最常用的版本控制操作。如果你的项目没有用git等版本控制软件进行管理，它至少会给你提供一个由IDE维护的本地历史记录。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Ctrl + V</code></li>
<li>Windows/Linux: <code>Alt + 引号</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980642462619.gif" alt=""/></figure></p>

<h2 id="toc_85">编码技巧</h2>

<h3 id="toc_86">列选择/块选择（Column Selection）</h3>

<ul>
<li><strong>描述</strong>：正常选择时，当你向下选择时，会直接将当前行到行尾都选中，而块选择模式下，则是根据鼠标选中的矩形区域来选择。</li>
<li><strong>调用</strong>：按住Alt，然后拖动鼠标选择。</li>
<li><strong>开启/关闭块选择</strong>：Menu → Edit → Column Selection Mode</li>
<li><strong>快捷键</strong>：切换块选择模式：
<ul>
<li>OS X：<code>Cmd + Shift + 8</code></li>
<li>Windows/Linux: <code>Shift + Alt + Insert﻿</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/2017110415098064433401.gif" alt=""/></figure></p>

<h3 id="toc_87">语句补全（Complete Statement）</h3>

<ul>
<li><strong>描述</strong>：这个方法将会生成缺失的代码来补全语句，常用的使用场景如下：
<ul>
<li>在行末添加一个分号，即使光标不在行末；</li>
<li>为if、while、for 语句生成圆括号和大括号；</li>
<li>方法声明后，添加大括号；</li>
</ul></li>
<li><strong>调用</strong>：Menu → Edit → Compelete Current Statement</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + Enter</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Enter</code></li>
</ul></li>
<li><strong>更多</strong>：如果一个语句已经补全，当你执行该操作时，则会直接跳到下一行，即使光标不在当前行的行末。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980646813298.gif" alt=""/></figure></p>

<h3 id="toc_88">删除行（Delete Line）</h3>

<ul>
<li><strong>描述</strong>：如果没选中，则删除光标所在行，如果选中，则会删除选中所在的所有行。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Y</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980648262822.gif" alt=""/></figure></p>

<h3 id="toc_89">行复制（Duplicate Line）</h3>

<ul>
<li><strong>描述</strong>：复制当前行，并粘贴到下一行，这个操作不会影响剪贴板的内容。这个命令配合移动行快捷键非常有用。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + D</code></li>
<li>Windows/Linux: <code>Ctrl + D</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980649696731.gif" alt=""/></figure></p>

<h3 id="toc_90">编写正则表达式（Edit Regex）</h3>

<ul>
<li><strong>描述</strong>：使用Java编写正则表达式是一件很困难的事，主要原因是：
<ul>
<li>你必须得避开反斜杠；</li>
<li>说实话，正则很难；</li>
<li>看第二条。</li>
</ul></li>
</ul>

<p>IDE能帮我们干点啥呢？当然是一个舒服的界面来编写和测试正则啦~</p>

<ul>
<li><strong>快捷键</strong>：Alt + Enter → check regexp</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980651186804.gif" alt=""/></figure></p>

<h3 id="toc_91">使用Enter和Tab进行代码补全的差别（Enter vs Tab for Code Completion）</h3>

<ul>
<li><strong>描述</strong>：代码补全时，可以使用Enter或Tab来进行补全操作，但是两者是有差别的。</li>
<li><strong>使用Enter时</strong>：从光标处插入补全的代码，对原来的代码不做任何操作。</li>
<li><strong>使用Tab时</strong>：从光标处插入补全的代码，并删除后面的代码，直到遇到点号、圆括号、分号或空格为止。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980653180946.gif" alt=""/></figure></p>

<h3 id="toc_92">提取方法（Extract Method）</h3>

<ul>
<li><strong>描述</strong>：提取一段代码块，生成一个新的方法。当你发现某个方法里面过于复杂，需要将某一段代码提取成单独的方法时，该技巧是很有用的。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Method</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + M</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + M</code></li>
</ul></li>
<li><strong>更多</strong>：在提取代码的对话框，你可以更改方法的修饰符和参数的变量名。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980654825229.gif" alt=""/></figure></p>

<h3 id="toc_93">提取参数（Extract Parameter）</h3>

<ul>
<li><strong>描述</strong>：这是一个提取参数的快捷操作。当你觉得可以通过提取参数来优化某个方法的时候，这个技巧将很有用。该操作会将当前值作为一个方法的参数，将旧的值放到方法调用的地方，作为传进来的参数。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Parameter</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + P</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + P</code></li>
</ul></li>
<li><strong>更多</strong>：通过勾选“delegate”，可以保持旧的方法，重载生成一个新方法。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980656810471.gif" alt=""/></figure></p>

<h3 id="toc_94">提取变量（Extract Variable）</h3>

<ul>
<li><strong>描述</strong>：这是一个提取变量的快捷操作。当你在没有写变量声明的直接写下值的时候，这是一个很方便生成变量声明的操作，同时还会给出一个建议的变量命名。</li>
<li><strong>调用</strong>：Menu → Refactor → Extract → Variable</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + V</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + V</code></li>
</ul></li>
<li><strong>更多</strong>：当你需要改变变量声明的类型，例如使用 List 替代 ArrayList，可以按下Shift + Tab，就会显示所有可用的变量类型。</li>
</ul>

<p><figure><img src="media/15561207869535/2017110415098065961111.gif" alt=""/></figure></p>

<h3 id="toc_95">内置（Inline）</h3>

<ul>
<li><strong>描述</strong>：当你开始对提取操作有点兴奋的时候，突然觉得东西太多了，怎么办呢？这是一个和提取相反的操作。该操作对方法、字段、参数和变量均有效。</li>
<li><strong>调用</strong>：Menu → Refactor → Inline</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + N</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + N</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980663164666.gif" alt=""/></figure></p>

<h3 id="toc_96">合并行和文本（Join Lines and Literals）</h3>

<ul>
<li><strong>描述</strong>：这个操作比起在行末使劲按删除键爽多了！该操作遵守格式化规则，同时：
<ul>
<li>合并两行注释，同时移除多余的//；</li>
<li>合并多行字符串，移除+和双引号；</li>
<li>合并字段的声明和初始化赋值；</li>
</ul></li>
<li><strong>快捷键</strong>：<code>Ctrl + Shift + J</code></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980665059689.gif" alt=""/></figure></p>

<h3 id="toc_97">动态模板（Live Templates）</h3>

<ul>
<li><strong>描述</strong>：动态模板是一种快速插入代码片段的方法，使用动态模板比较有意思的是你可以使用合适的默认值将模板参数化，当你插入代码片段时，这可以指导你完成参数。</li>
<li><strong>更多</strong>：如果你知道模板的缩写，就可以不必使用快捷键，只需要键入缩写并使用Tab键补全即可。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + J</code></li>
<li>Windows/Linux: <code>Ctrl + J</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980666912326.gif" alt=""/></figure></p>

<h3 id="toc_98">上下移动行（Move Lines Up Down）</h3>

<ul>
<li><strong>描述</strong>：不需要复制粘贴就可以上下移动行了。</li>
<li><strong>快捷键</strong>：<code>Alt + Shift + Up/Down﻿</code></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980669255942.gif" alt=""/></figure></p>

<h3 id="toc_99">移动方法（Move Methods）</h3>

<ul>
<li><strong>描述</strong>：这个操作和移动行操作很类似，不过该操作是应用于整个方法的，在不需要复制、粘贴的情况下，就可以将整个方法块移动到另一个方法的前面或后面。该操作的实际叫做“移动语句”，这意味着你可以移动任何类型的语句，你可以方便地调整字段或内部类的顺序。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Alt + Up/Down</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Up/Down</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980671139565.gif" alt=""/></figure></p>

<h3 id="toc_100">取反补全（Negation Completion）</h3>

<ul>
<li><strong>描述</strong>：有时你自动补全一个布尔值，然后回到该值的前面添加一个感叹号来完成取反操作，现在通过使用输入!代替enter完成补全操作，就可以跳过这些繁琐的操作了。</li>
<li><strong>快捷键</strong>：代码补全的时候，按下!即可（有时需要上下键选中候选项）；</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980672883680.gif" alt=""/></figure></p>

<h3 id="toc_101">后缀补全（Postfix Completion）</h3>

<ul>
<li><strong>描述</strong>：你可以认为该操作是一种代码补全，它会在点号之前生成代码，而不是在点号之后。实际上你调用这个操作和正常的代码补全操作一样：在一个表达式之后输入点号。</li>
</ul>

<p>例如对一个列表进行遍历，你可以输入myList.for，然后按下Tab键，就会自动生成for循环代码。</p>

<ul>
<li><p><strong>调用</strong>： 你可以在某个表达式后面输入点号，出现一个候选列表，在常规的代码补全提示就可以看到一系列后缀补全关键字，同样的，你也可以在Editor → Postfix Completion中看到一系列后缀补全关键字。</p></li>
<li><p>常用的有后缀补全关键字有：</p>
<ul>
<li>.for (补全foreach语句)</li>
<li>.format (使用String.format()包裹一个字符串)</li>
<li>.cast (使用类型转化包裹一个表达式)</li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980676555014.gif" alt=""/></figure></p>

<h3 id="toc_102">重构（Refactor This）</h3>

<ul>
<li><strong>描述</strong>：该操作可以显示所有对当前选中项可行的重构方法。这个列表可以用数字序号快速选择。</li>
<li><strong>快捷键</strong>：Ctrl + T(OS X)、Ctrl + Alt + Shift + T(Windows/Linux)</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980678781403.gif" alt=""/></figure></p>

<h3 id="toc_103">重命名（Rename）</h3>

<ul>
<li><strong>描述</strong>：你可以通过该操作重命名变量、字段、方法、类、包。当然了，该操作会确保重命名对上下文有意义，不会无脑替换掉所有文件中的名字；</li>
<li><strong>快捷键</strong>：<code>Shift + F6</code></li>
<li><strong>更多</strong>：如果你忘记了这个快捷键，你可以使用快速修复（Quick Fix）的快捷键，它通常包含重命名选项。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980681031115.gif" alt=""/></figure></p>

<h3 id="toc_104">分号/点 补全（Semicolon Dot Completion）</h3>

<ul>
<li><strong>描述</strong>：代码补全这个功能太棒啦！我们大概都对以下这种情况很熟悉：开始输入点什么东西，接着从IDE得到一些建议的选项，然后通过Enter或者Tab来选择我们想要的补全代码。其实还有另外一种方法来选择补全的代码：我们可以输入一个点(.)或者一个分号(;)。这样就会完成补全，添加所选字符。这在结束一条语句补全或者快速链式调用方法的时候特别有用。</li>
<li><strong>注意点</strong>：如果你要代码补全的方法需要参数，这些参数会被略过。</li>
<li><strong>快捷键</strong>：<code>Autocomplete + “.” 或者 “;”</code></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980682566602.gif" alt=""/></figure></p>

<h3 id="toc_105">包裹代码（Surround With）</h3>

<ul>
<li><p><strong>描述</strong>： 该操作可以用特定代码结构包裹住选中的代码块，通常是if语句，循环，try/catch语句或者runnable语句。 如果你没有选中任何东西，该操作会包裹当前一整行。</p></li>
<li><p><strong>快捷键</strong>：</p>
<ul>
<li>OS X: <code>Cmd + Alt + T</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + T</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980684453567.gif" alt=""/></figure></p>

<h3 id="toc_106">移除包裹代码（Unwrap Remove）</h3>

<ul>
<li><strong>描述</strong>：该操作会移除周围的代码，它可能是一条if语句，一个while循环，一个try/catch语句甚至是一个runnable语句。该操作恰恰和包裹代码（Surround With）相反。</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + Shift + Delete</code></li>
<li>Windows/Linux: <code>Ctrl + Shift + Delete</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980686388604.gif" alt=""/></figure></p>

<h3 id="toc_107">手动唤出自动补全（Class Name Completion）</h3>

<ul>
<li><strong>描述</strong>：一般使用 Android Studio 的时候，自动提示会在你想要提示的时候自动出现，比如输入 Log. ，就出现 Log.d()、Log.e、Log.i() 等提示。不过如果在自动提示的时候手一抖选错的话，比如想选 Log.d() 结果选了 Log.e() ，你可能会把 .e() 都删掉，然后再输入一个 . ， 然后弹出自动补全提示。其实这时候只需要删除 e() 然后手动唤出自动补全即可。</li>
<li><strong>快捷键</strong>： 
<ul>
<li>OS X/Windows/Linux: <code>Ctrl + Alt + Space</code> (可能存在快捷键冲突无法唤出，修改下快捷键即可)</li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980688325290.gif" alt=""/></figure></p>

<h2 id="toc_108">调试技巧</h2>

<h3 id="toc_109">分析传入数据流（Analyze data flow to here）</h3>

<ul>
<li><strong>描述</strong>：这个操作将会根据当前选中的变量、参数或者字段，分析出其传递到此处的路径。 当你进入某段陌生的代码，试图明白某个参数是怎么传递到此处的时候，这是一个非常有用的操作。</li>
<li><strong>调用</strong>：Menu → Analyze → Analyze Data Flow to Here</li>
<li><strong>快捷键</strong>：无，可以在设置中指定。</li>
<li><strong>相反的操作</strong>：分析传出数据流（Analyze data flow from here），这个将会分析当前选中的变量往下传递的路径，直到结束。</li>
</ul>

<p><figure><img src="media/15561207869535/2017110415098069615710.gif" alt=""/></figure></p>

<h3 id="toc_110">堆栈追踪分析（Analyze Stacktrace）</h3>

<ul>
<li><strong>描述</strong>： 这个操作读取一份堆栈追踪信息，并且使它像logcat中那样可以点击。当你从bug报告中或者终端复制了一份堆栈追踪，使用该操作可以很方便地调试。</li>
<li><strong>调用</strong>：Menu → Analyze → Analyze Stacktrace</li>
<li><strong>快捷键</strong>：无，可以在设置中指定。</li>
<li><strong>更多</strong>：通过使用“ProGuard Unscramble Plugin”插件，也可以分析混淆过的堆栈追踪。</li>
</ul>

<p><figure><img src="media/15561207869535/2017110415098070105942.gif" alt=""/></figure></p>

<h3 id="toc_111">关联调试程序（Attach Debugger）</h3>

<ul>
<li><strong>描述</strong>：随时启动调试程序，即使你没有以调试模式启动你的应用。这是一个很方便的操作，因为你不必为了调试程序而以调试模式重新部署你的应用。当别人正在测试应用，突然遇到一个bug而将设备交给你时，你也可以很快地进入调试模式。</li>
<li><strong>调用</strong>：点击工具栏图标或者Menu → Build → Attach to Android Process</li>
<li><strong>快捷键</strong>：无，可以在设置中指定，或者点击工具栏对应的图标。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980702475158.gif" alt=""/></figure></p>

<h3 id="toc_112">条件断点（Conditional Breakpoints）</h3>

<ul>
<li><strong>描述</strong>：简单说，就是当设定的条件满足时，才会触发断点。你可以基于当前范围输入一个java布尔表达式，并且条件输入框内是支持代码补全的。</li>
<li><strong>调用</strong>：右键需要填写表达式的断点，然后输入布尔表达式。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980704751679.gif" alt=""/></figure></p>

<h3 id="toc_113">禁用断点（Disable Breakpoints）</h3>

<ul>
<li>这个操作将使得断点。当你有一个设置过复杂条件的断点或者是日志断点，当前不需要，但是下次又不用重新创建，该操作是很方便的。</li>
<li><strong>调用</strong>：按住Alt，然后单击断点即可。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980707081458.gif" alt=""/></figure></p>

<h3 id="toc_114">计算表达式（Evaluate Expression）</h3>

<ul>
<li><strong>描述</strong>：这个操作可以用来查看变量的内容并且计算几乎任何有效的java表达式。需要注意的是，如果你修改了变量的状态，这个状态在你恢复代码执行后依然会保留。</li>
<li><strong>快捷键</strong>：处在断点状态时，光标放在变量处，按Alt + F8，即可显示计算表达式对话框。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980709720976.gif" alt=""/></figure></p>

<h3 id="toc_115">审查变量（Inspect Variable）</h3>

<ul>
<li><strong>描述</strong>：该操作可以在不打开计算表达式对话框就能审查表达式的值。</li>
<li><strong>快捷键</strong>：调试状态下，按住Alt键，然后单击表达式即可。</li>
</ul>

<p><figure><img src="media/15561207869535/2017110415098071175665.gif" alt=""/></figure></p>

<h3 id="toc_116">日志断点（Logging Breakpoints）</h3>

<ul>
<li><strong>描述</strong>：这是一种打印日志而不是暂停的断点，当你想打印一些日志信息但是不想添加log代码后重新部署项目，这是一个非常有用的操作。</li>
<li><strong>调用</strong>：在断点上右键，取消Suspend的勾选，然后勾选上Log evaluated Expression，并在输入框中输入你要打印的日志信息。</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980717148789.gif" alt=""/></figure></p>

<h3 id="toc_117">标记对象（Mark Object）</h3>

<ul>
<li><strong>描述</strong>：当你在调试的时候，这个操作可以让你给某个特殊的对象添加一个标签，方便你后面很快地辨认。在调试时，当你从一堆相似的对象中查看某个对象是否和之前是一样的，这就是一个非常有用的操作。</li>
<li><strong>调用</strong>：右键你需要标记的对象，选中Mark Object，输入标签；</li>
<li><strong>快捷键</strong>：选中对象时
<ul>
<li>OS X: <code>F3</code></li>
<li>Windows/Linux: <code>F11</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980728765306.gif" alt=""/></figure></p>

<h3 id="toc_118">显示当前运行点（Show Execution Point）</h3>

<ul>
<li><strong>描述</strong>：该操作会立刻把你的光标移回到当前debug处。</li>
</ul>

<p>通常的情况是：</p>

<ol>
<li>你在某处触发了断点</li>
<li>然后在文件中随意浏览</li>
<li><p>直接调用这个快捷键，快速返回之前逐步调试的地方。</p></li>
</ol>

<ul>
<li>快捷键：（Debug时) <code>Alt + F10</code>；</li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980726232579.gif" alt=""/></figure></p>

<h3 id="toc_119">终止进程（Stop Process）</h3>

<ul>
<li><strong>描述</strong>：该操作会终止当前正在运行的任务。如果任务数量大于一，则显示一个列表供你选择。在终止调试或者中止编译的时候特别有用！</li>
<li><strong>快捷键</strong>：
<ul>
<li>OS X: <code>Cmd + F2</code></li>
<li>Windows、Linux: <code>Ctrl + F2</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980743452167.gif" alt=""/></figure></p>

<h3 id="toc_120">临时断点（Temporary Breakpoints）</h3>

<ul>
<li><strong>描述</strong>：通过该操作可以添加一个断点，这个断点会在第一次被命中的时候自动移除。</li>
<li><strong>快捷键</strong>：
<ul>
<li>鼠标: <code>Alt + 鼠标左键 点击代码左侧</code></li>
<li>OS X: <code>Cmd + Alt + Shift + F8</code></li>
<li>Windows/Linux: <code>Ctrl + Alt + Shift + F8</code></li>
</ul></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980746471135.gif" alt=""/></figure></p>

<h3 id="toc_121">调用层级树弹窗（The Call Hierarchy Popup）</h3>

<ul>
<li><strong>描述</strong>：该操作会给你展示 在一个方法的声明和调用之间所有可能的路径。</li>
<li><strong>快捷键</strong>：<code>Ctrl + Alt + H</code></li>
</ul>

<p><figure><img src="media/15561207869535/20171104150980748531704.gif" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/06/01</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869436.html">
                
                  <h1>Android-Issues</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>这篇文章主要记录一些在实际开发中遇到的问题，以及对其的解决措施。方便日后解决同样类型的问题。</p>

<h2 id="toc_1">Activity的使用</h2>

<h3 id="toc_2">1、onSaveInstance 和 onRestoreInstanceState</h3>

<p>onSaveInstance方法在系统回收Activity之前会调用；Back键不会调用。onPause（）—&gt;<code>onSaveInstanceState( )</code>–&gt;onStop( );<code>onRestoreInstanceState()</code>会在onStart()和onResume()之间执行。</p>

<ul>
<li>1、当用户按下HOME键时。这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，故系统会调用onSaveInstanceState，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</li>
<li>2、长按HOME键，选择运行其他的程序时。</li>
<li>3、按下电源按键（关闭屏幕显示）时。</li>
<li>4、从activity A中启动一个新的activity时。</li>
<li>5、屏幕方向切换时，例如从竖屏切换到横屏时。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行</li>
</ul>

<p>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和 onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提 是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。<br/>
activity中保存数据有两种方式onPause()，onSaveInstance(bundle),  恢复数据也有两种途径onCreate(Bundle), onRestoreInstanceState(budle)，默认情况下onSaveInstanceSate()和onRestoreInstanceState()会对UI状态进行保存和恢复，如果需要保存其他数据可以在onSaveInstanceState()，onPause()保存，但是如果是持久化的数据得通过onPause()保存(google推荐)。</p>

<h2 id="toc_3">二、Fragment使用</h2>

<h3 id="toc_4">1、<code>java.lang.IllegalStateException: Fragment does not have a view</code></h3>

<p>先说明下出现这个异常的原因，这是在<code>fragment onCreateView()</code>中调用<code>getChildFragmentManager()</code>的时候出现的。解决办法就是不要再onCreateView()中调用<code>getChildFragmentManager()</code>。那么如果你要调用<code>getChildFragmentManager()</code>，那么必须onCreateView之后，view被创建了。</p>

<h2 id="toc_5">三、UI控件</h2>

<h3 id="toc_6">1、Button控件</h3>

<h4 id="toc_7">（1）解决Android5.0版本以上Button自带阴影问题</h4>

<p>设置Button的样式为<code>style=&quot;?android:attr/borderlessButtonStyle&quot;</code></p>

<h3 id="toc_8">2、TextView控件</h3>

<h4 id="toc_9">（1）Text View中修改文字段落中部分字体颜色</h4>

<p>使用ForegroundColorSpan来修改</p>

<h3 id="toc_10">3、CheckBox控件</h3>

<h4 id="toc_11">（1）如何修改复选框的样式</h4>

<ul>
<li><p>首先在drawable文件夹中添加drawable文件checkbox_style.xml。</p>
<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;  <br/>
&lt;item android:drawable=&quot;@drawable/checkbox_pressed&quot; android:state_checked=&quot;true&quot;/&gt;  <br/>
&lt;item android:drawable=&quot;@drawable/checkbox_normal&quot; android:state_checked=&quot;false&quot;/&gt;  <br/>
&lt;item android:drawable=&quot;@drawable/checkbox_normal&quot;/&gt;  <br/>
&lt;/selector&gt;
</code></pre></li>
<li><p>在values文件夹下的styles.xml文件中添加CustomCheckboxTheme样式。</p></li>
</ul>

<pre class="line-numbers"><code class="language-markup">&lt;style name=&quot;CustomCheckboxTheme&quot; parent=&quot;@android:style/Widget.CompoundButton.CheckBox&quot;&gt;  
    &lt;item name=&quot;android:button&quot;&gt;@drawable/checkbox_style&lt;/item&gt;  
&lt;/style&gt;
</code></pre>

<ul>
<li>在布局文件中使用CustomCheckboxTheme样式。
<code>xml
&lt;CheckBox  <br/>
android:id=&quot;@+id/select_all&quot;  <br/>
android:layout_width=&quot;wrap_content&quot;  <br/>
android:layout_height=&quot;wrap_content&quot;  <br/>
style=&quot;@style/CustomCheckboxTheme&quot; /&gt;
</code></li>
</ul>

<h3 id="toc_12">4、RecyclerView控件</h3>

<h4 id="toc_13">（1）RecyclerView删除Item导致位置错乱</h4>

<p>RecyclerView的刷新分为内容变化和结构变化，结构变化比如remove和insert等并不会导致viewholder的更新，所以有时候我们使用<code>notifyItemRemoved(position);</code>或者使用<code>notifyItemInserted(position);</code>item的位置并没有发生改变，或者位置发生错乱，很是奇怪诡异，需要重新调用<code>notifyDataSetChanged();</code>才能刷新整个List每个Item的位置，但这样做会使得RecyclerView增加和删除的动画效果没有了。那么要既想没有Bug的插入删除，又想有动画怎么搞呢，只需要刷新删除位置以下的List的Item位置即可，那么幸亏RecyclerView有一个局部刷新的方法：<code>notifyItemRangeChanged(int positionStart, int itemCount)</code>怎么使用呢？ 我们只需要在删除或插入时同时,刷新改变位置item下方的所有Item的位置： 插入动作：</p>

<pre class="line-numbers"><code class="language-java">notifyItemInserted(position);
if (position != mData.size()) {
   otifyItemRangeChanged(position, mData.size() - position);
 }
</code></pre>

<p>删除动作：</p>

<pre class="line-numbers"><code class="language-java"> notifyItemRemoved(position);
if (position != mData.size()) {
   otifyItemRangeChanged(position, mData.size() - position);
 }
</code></pre>

<h4 id="toc_14">（2）RecyclerView只显示第一个数据</h4>

<p>在<code>onCreateViewHolder</code>中获取View的时候不指定<code>ViewGroup</code></p>

<pre class="line-numbers"><code class="language-java">@Override  
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  
    LayoutInflater layoutInflater = LayoutInflater.from(parent.getContext());  
    View convertView = layoutInflater.inflate(R.layout.item, null, false); // if use parent, only first line will show up  
    return new ViewHolder(convertView);  
}
</code></pre>

<h3 id="toc_15">5、EditText控件</h3>

<h4 id="toc_16">（1）如何自动打开软键盘</h4>

<h2 id="toc_17">四、自定义View的实现</h2>

<h3 id="toc_18">1、自定义TextView时，自定义参数的设置</h3>

<p>自定义属性一般在<code>onMeasure()</code>方法后才能将XML文件中的自定义设置的属性数值传递进来，无法在<code>setBackground()</code>方法和<code>setText()</code>方法直接调用。如果是想要在代码中设置变量属性，还是直接在自定义控件扩展类中添加新方法进行使用。自定义控件的三个构造类</p>

<pre class="line-numbers"><code class="language-java">public GuideTextView(Context context) //在代码中直接使用
public GuideTextView(Context context, AttributeSet attrs) //在xml文件中直接使用时调用
public GuideTextView(Context context, AttributeSet attrs, int defStyleAttr) //xml文件中使用默认主题时调用
</code></pre>

<h3 id="toc_19">2、扩展自定义View的实现</h3>

<p>在<code>onDraw()</code>方法中，将绘制代码写在<code>super.onDraw(canvas);</code>方法之前，绘制效果将显示在控件底层；将绘制代码写在<code>super.onDraw(canvas);</code>方法之后，绘制效果将显示在控件底层。</p>

<h3 id="toc_20">3、getDimension()、getDimensionPixelOffset()和getDimensionPixelSize()的区别</h3>

<ul>
<li><code>getDimension()</code>是基于当前DisplayMetrics进行转换，获取指定资源id对应的尺寸。文档里并没说这里返回的就是像素，要注意这个函数的返回值是float，像素肯定是int。</li>
<li><code>getDimensionPixelSize()</code>与<code>getDimension()</code>功能类似，不同的是将结果转换为int，并且小数部分四舍五入。</li>
<li><code>getDimensionPixelOffset()</code>与<code>getDimension()</code>功能类似，不同的是将结果转换为int，并且偏移转换（offset conversion，函数命名中的offset是这个意思）是直接截断小数位，即取整（其实就是把float强制转化为int，注意不是四舍五入哦）。
由此可见，这三个函数返回的都是绝对尺寸，而不是相对尺寸（dp/sp等）。如果getDimension()返回结果是20.5f，那么<code>getDimensionPixelSize()</code>返回结果就是21，<code>getDimensionPixelOffset()</code>返回结果就是20。</li>
</ul>

<h3 id="toc_21">4、DisplayMetrics显示的数值</h3>

<ul>
<li><em>density</em>: 显示的逻辑分辨率</li>
<li><em>width</em>及<em>height</em>: 屏幕分辨率(绝对宽高)</li>
<li><em>scaleDensity</em>: 字体显示的缩放因子</li>
<li><em>xdpi</em>及<em>ydpi</em>: 水平方向DPI和竖直方向DPI</li>
</ul>

<h3 id="toc_22">5、屏幕尺寸单位</h3>

<ul>
<li>屏幕尺寸: 屏幕尺寸指屏幕的对角线的长度，单位是英寸(in)，1英寸=2.54厘米</li>
<li>px: 是英文单词pixel的缩写，意为像素，屏幕上的点。我们通常所说的分辨率如480X800就是指的像素，一般以纵向像素*横向像素。</li>
<li>dpi: dpi是Dots Per Inch的缩写, 每英寸点数，即每英寸包含像素个数。</li>
<li>density: 屏幕密度，density和dpi的关系为 density = dpi/160</li>
<li>dp和dip: 设备独立像素，device independent pixels的缩写， <a href="http://lib.csdn.net/base/android">Android</a> 特有的单位，在屏幕密度dpi = 160屏幕上，1dp = 1px。dp和density的关系为 1dp = density px，dip值 =（dpi值/160）* pixel值</li>
<li>sp: 和dp很类似，一般用来设置字体大小，和dp的区别是它可以根据用户的字体大小偏好来缩放。</li>
</ul>

<h3 id="toc_23">6、EditText启动软键盘怎么和EditText布局一起上移，并且背景不动</h3>

<p>在根布局中添加ScrollView来存放背景显示内容，中间必须添加一个RelativeLayout或者LinearLayout(如果添加RelativeLayout则ScrollView必须设置属性<code>android:fillViewport=&quot;true&quot;</code>)，在ScrollView控件底下添加EditText所在布局，设置AndroidManifest.xml中<code>android:windowSoftInputMode=&quot;adjustResize|stateHidden&quot;</code>，在代码中设置RelativeLayout中的显示布局的布局属性。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.jrm.adolph.test1.MainActivity&quot;&gt;
    &lt;ScrollView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:fillViewport=&quot;true&quot;&gt;
        &lt;RelativeLayout
            android:id=&quot;@+id/layout&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;&gt;

            &lt;RelativeLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;64dp&quot;
                android:background=&quot;@color/colorAccent&quot;&gt;
                &lt;TextView
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:layout_centerInParent=&quot;true&quot;
                    android:text=&quot;软键盘&quot;
                    android:textSize=&quot;20sp&quot;/&gt;
            &lt;/RelativeLayout&gt;
            &lt;RelativeLayout
                android:id=&quot;@+id/content_layout&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;match_parent&quot;&gt;
                &lt;TextView
                    android:layout_width=&quot;wrap_content&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    android:text=&quot;Hello World!&quot;
                    android:layout_centerInParent=&quot;true&quot;
                    android:textSize=&quot;20sp&quot;/&gt;
            &lt;/RelativeLayout&gt;
        &lt;/RelativeLayout&gt;
    &lt;/ScrollView&gt;
    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;48dp&quot;
        android:layout_alignParentBottom=&quot;true&quot;&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;送礼&quot;/&gt;
        &lt;EditText
            android:id=&quot;@+id/et&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_weight=&quot;1&quot;/&gt;
        &lt;Button
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;发送&quot;/&gt;
    &lt;/LinearLayout&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<pre class="line-numbers"><code class="language-java">Rect outRect = new Rect();
getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect);
RelativeLayout.LayoutParams params = (RelativeLayout.LayoutParams) layout.getLayoutParams();
params.height = outRect.bottom - outRect.top;
layout.setLayoutParams(params);
</code></pre>

<h3 id="toc_24">7、设置Button的selector控制按钮的点击形态</h3>

<p>设置好press、enable属性的对应图片，点击按钮图片形态不响应。必须把默认的按钮图片样式放在最底下，才能实现。</p>

<pre class="line-numbers"><code class="language-markup">&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_pressed_btn&quot; android:state_pressed=&quot;true&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_unable_btn&quot; android:state_enabled=&quot;false&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/lucky_turntable_focusable_btn&quot;/&gt;
&lt;/selector&gt;
</code></pre>

<h3 id="toc_25">8、DispatchTouchEvent</h3>

<p>重写dispatchTouchEvent的时候，无论你是return true，亦或是return false都会导致child接受不到事件。<br/>
<code>return true</code> ： 告诉parent，这个事件我消费了。如果这个是down事件，那么我就会作为一个target或者说handle(事件持有者)，后续的move事件或者up事件等，都会直接分发到我这里，不继续往下分发。 <br/>
<code>return false</code>：告诉parent，这个事件我不需要，那么会交回给parent的onTouchEvnet处理。只有return <code>super.dispatchTouchEvent</code>的时候才会将事件继续往下传递。<br/>
<figure><img src="media/15561207869436/15713067993235.jpg" alt=""/></figure></p>

<h2 id="toc_26">五、Android类库使用问题</h2>

<h3 id="toc_27">1、Android DataBinding</h3>

<h4 id="toc_28">（1）include布局使用，如何传变量进去</h4>

<p>include布局中同样用layout标签包裹，将父布局中的变量以</p>

<pre class="line-numbers"><code class="language-text">app:XXX=&quot;@{XXX}&quot;
</code></pre>

<p>自定义属性的形式传进去,并在include布局中同样申明XXX相同的变量名以及变量类型，即可进行使用。注意使用在表达式中使用View.VISIBLE设置可视化的时候导入View类，否则会报错。</p>

<h4 id="toc_29">（2）如何调用include中的控件</h4>

<p>普通调用include中的控件，直接使用<code>findViewById</code>可以直接获取控件。使用dataBinding时，有时会出现获取控件无法调用的情况，这种情况给include标签赋一个id，在类中通过<code>bind.&lt;include-id&gt;.&lt;widget-id&gt;</code>进行调用。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/05/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869150.html">
                
                  <h1>Github pages和Hexo搭建</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>由于之前Jekyll的博客搭建起来，插件支持太少，以及其他的目录和语法高亮支持不太好，过于麻烦。最近看了其他人用Hexo搭建的Blog，被其简洁和方便，美观的界面所深深吸引。所以，查询其相关资料，发现的确很棒，而且文档相对Jekyll来说也齐全很多。顿时萌生了转战Hexo的想法。搭建完成后，发现的确好棒，很多在Jekyll上无法实现的功能，在这里能轻松实现，而且搭配Next主题，秒杀全场啊。</p>

<h2 id="toc_1">一、基础博客搭建流程</h2>

<h3 id="toc_2">安装Node和Git</h3>

<h4 id="toc_3">1、安装node.js。</h4>

<p><code>brew install node</code></p>

<h4 id="toc_4">2、安装git。</h4>

<p><code>brew intall git</code></p>

<h4 id="toc_5">3、选装cnpm。</h4>

<p>淘宝cnpm官网。由于npm国内下载速度经常抽风，所以建议安装淘宝的这个镜像；使用方法就是在命令中把npm换成cnpm即可。<br/><br/>
安装方法：在cmd工具中输入如下命令<br/><br/>
<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>

<h3 id="toc_6">安装Hexo及其相关插件</h3>

<h4 id="toc_7">1、全局安装Hexo</h4>

<p><code>cnpm install hexo-cli -g    #安装hexo</code><br/>
<code>hexo -v   #出现版本信息则表示安装成功</code></p>

<h4 id="toc_8">2、在项目中安装Hexo</h4>

<p>创建文件夹，进入文件夹目录<br/><br/>
<code>cnpm install hexo --save     #在当前项目中安装hexo</code><br/><br/>
<code>hexo init         #初始化hexo</code><br/><br/>
<code>cnpm install         #安装依赖包</code>  </p>

<h4 id="toc_9">3、安装Hexo的插件</h4>

<p><code>cnpm install hexo-server --save     #搭建本地服务器所需插件</code><br/>
<code>cnpm install hexo-deployer-git --save     #使用git方式进行部署博客所需插件</code></p>

<h3 id="toc_10">在本地生成博客静态页面并预览</h3>

<h4 id="toc_11">1、在本地生成静态页面</h4>

<p><code>hexo generate</code>，会生成一个存放静态文件的文件夹public，其简写形式为<code>hexo g</code>  </p>

<h4 id="toc_12">2、启动本地服务器</h4>

<p><code>hexo server</code>,其简写形式为<code>hexo s</code><br/><br/>
这条指令运行完成后可在本地启动服务器并预览博客，默认网址为<a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p>

<h3 id="toc_13">创建GitHub Pages并配置ssh</h3>

<h4 id="toc_14">1、创建博客仓库。</h4>

<p>注册并登陆到GitHub官网，假如你注册的用户名是Magic，那么新建一个名为Magic.github.io的仓库，注意仓库的用户名一定要是用户名+github.io的形式！</p>

<h4 id="toc_15">2、本地生成ssh密钥。</h4>

<p>终端下输入<code>ssh-keygen -t rsa -C ‘你的邮箱地址’</code></p>

<h4 id="toc_16">3、上传本地的公钥串，使当前电脑与GitHub账户建立联系。</h4>

<p>/Users/你的计算机用户名/.ssh 目录下打开刚刚生成的id_rsa.pub，复制里面的内容。然后点击你GitHub账户右上角的头像，选择settings，找到SSH and GPG keys，点击进入之后再点击New SSH key，title随便写，把公钥串粘贴到文本框，保存即可。<br/>
<code>cat id_rsa.pub</code></p>

<h3 id="toc_17">本地博客同步到GitHub上</h3>

<p>这一步其实就是把本地生成的博客内容（静态页面）放到GitHub新建成的仓库Magic.github.io中。</p>

<h4 id="toc_18">1、编辑博客配置文件: _config.yml</h4>

<p>在hexo根目录下找到_config.yml文件，把其中的deploy参数（没有的话就按如下格式新建，注意冒号后面一定要有一个空格），修改为：  </p>

<pre class="line-numbers"><code class="language-text">deploy: 
     type: git 
     repo: git@github.com:LiLei/LiLei.github.io.git             
     branch: master
</code></pre>

<h4 id="toc_19">2、重新部署</h4>

<p>打开终端，进入博客根目录，依次执行如下Hexo命令：<br/>
<code>hexo clean    #会清除缓存文件db.json及之前生成的静态文件夹public</code><br/><br/>
<code>hexo g     #会重新生成静态文件夹public</code><br/><br/>
<code>hexo deploy    #因为之前已经安装了插件并且在博客配置文件中也配置好了，所以这个命令会在博客根目录下生成一个.deploy_git的文件夹，并 把本地生成的静态文件部署到Magic.github.io这个仓库中的master分支上；简写形式为hexo d；</code>    </p>

<p><code>hexo g</code> 和 <code>hexo d</code>可以合并在一起写：<code>hexo g -d</code></p>

<h4 id="toc_20">3、在浏览器中访问博客</h4>

<p>在浏览器中输入Magic.github.io（可能你已经发现了，这个就是之前新建仓库的名字，同时也是你博客的域名），没毛病的话，你应该可以再次看到那个熟悉又亲切的博客页面了。</p>

<h2 id="toc_21">二、更换主题</h2>

<p>Blog的主题还是很重要的，直接影响写博客和看博客人的心情。在浏览了官网的全部主题以及和Next的对比下，最终还是选用了Next。毕竟有官方文档支持，而且符合内心界面简洁的风格，功能自定义强大，全面。  </p>

<p>更换主题主要是两步，先下载主题然后放到博客中的themes文件夹（专门用来存放主题）下，再修改主题的配置文件_config.yml中相关参数，启用themes文件夹下新增的主题。这里用Next主题做示例。  </p>

<h3 id="toc_22">下载Next主题。</h3>

<p>进入 <strong>根目录/themes</strong> 文件夹中，打开终端，输入：<br/>
<code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br/>
把主题包克隆到<strong>themes</strong>文件夹中即可。  </p>

<h3 id="toc_23">启用主题</h3>

<p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开根目录下的站点配置文件<strong>_config.yml</strong>， 找到 <strong>theme</strong> 字段，并将其值更改为 next（注意冒号后面要留一个 空格）。</p>

<h3 id="toc_24">验证主题</h3>

<p>清除并重新生成hexo静态文件，启动本地服务器，然后通过<a href="http://localhost:4000/%E9%A2%84%E8%A7%88%E5%8D%9A%E5%AE%A2%EF%BC%9A">http://localhost:4000/预览博客：</a><br/><br/>
<code>hexo clean         #清除静态文件</code><br/>
<code>hexo g          #重新生成静态文件</code><br/>
<code>hexo s         #启动服务器</code></p>

<blockquote>
<p><a href="http://theme-next.iissnan.com/getting-started.html#download-next-theme">Next中文官网</a>官网有更加全面的介绍</p>
</blockquote>

<h2 id="toc_25">三、自定义域名</h2>

<p>自定义域名对于我们这些不喜欢加github.io后缀的人来说还是很有必要的。而且githubpages的浏览速度过慢，导致体验很差。所以我们需要加速，如果不使用GithubPages的话，可以直接搭在自己的服务器上，这样速度够快。另一种方法就是对域名使用CDN加速了，阿里云的CDN加速太贵了，查了一下发现百度有免费的CDN加速(发现百度还是有点良心的)。<a href="https://su.baidu.com/product/cdn.html">百度云加速</a></p>

<h3 id="toc_26">百度云加速域名解析设置</h3>

<h4 id="toc_27">1、进入域名服务商的后台解析DNS域名</h4>

<p>解析为<code>ns1.bddns.cn</code>和<code>ns2.bddns.cn</code>  </p>

<h4 id="toc_28">2、进入百度云加速域名的解析后台，添加如下两条解析记录：</h4>

<p><figure><img src="media/15561207869150/15713208476970.jpg" alt=""/></figure></p>

<h4 id="toc_29">3、在博客目录的source文件夹下（根目录/source）创建一个名为<strong>CNAME</strong>的文件，内容为你注册域名。</h4>

<blockquote>
<p>CNAME是不带任何后缀的。</p>
</blockquote>

<p>上面操作完毕后，大概过几分钟就可以通过自定义的新域名访问博客了。如果不行，就依次执行<code>hexo clean</code>、<code>hexo g</code> 、<code>hexo d</code>再试下。</p>

<h2 id="toc_30">四、博客操作</h2>

<h3 id="toc_31">1、新建文章</h3>

<p><code>hexo new post 背影</code><br/>
在Git Bash中执行上面命令会新建一篇名为‘背影’的文章，源文件会自动生成到hexoBlog/source/_post 路径下，后缀为.md，直接打开编辑就可以了。编辑完保存，然后再依次执行<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code>在博客就可以看到你的文章了（有时候网络问题生成会比较慢，需要等几分钟才可以看到）。<br/>
如果习惯了之前Jekyll的博客命名风格，修改站点配置文件_config.yml的内容<code>new_post_name: :year-:month-:day-:title.md # File name of new posts</code>，之后就可以使用时间-名字的文件命名风格了。</p>

<h3 id="toc_32">2、新建页面</h3>

<p>新建标签、分类、关于我等各种页面，并在博客的菜单栏中显示。这里以新建‘标签’页面来做示范。</p>

<h4 id="toc_33">1、创建页面。</h4>

<p>在终端中执行<code>hexo new page &#39;tags&#39;</code>，会在根目录/source路径下自动生成一个名为tags的文件夹，里面包含一个index.md的文件，在这个文件中添加对应的页面类型<code>type: tags</code>：</p>

<pre class="line-numbers"><code class="language-text">      ---
      title: Tagcloud
      date: 2017-01-01 15:24:23
      type: &#39;tags&#39;   #声明页面类型
      ---
</code></pre>

<p>把页面路径添加到菜单中。<br/>
编辑主题配置文件（themes/_config.yml）,找到menu字段，添加<code>tag: /tags</code>（格式为<code>item_name: link</code>），如下：</p>

<pre class="line-numbers"><code class="language-text">menu:
    home: /
    tag: /tags    #‘标签’’页面的路径
</code></pre>

<p>设置博客中‘标签’这个菜单项的显示图标。<br/>
同样是在主题配置文件中，找到nenu_icons字段，添加<code>tags tags</code>（格式为<code>item_name: icon_name</code>），如下：</p>

<pre class="line-numbers"><code class="language-text">menu_icons:
    enable: true     #显示图标
    home: home
    tag: tags     #tag标签的icons是‘tags’
</code></pre>

<p>设置博客中‘标签’这个菜单项的显示文本。<br/>
上面的<code>item_name</code>并不会直接用于博客界面的显示，只是用来匹配图标和显示在页面上的文字，可以理解为一个桥梁。那么到底在哪里设置呢？<br/>
首先，在站点配置文件中（hexoBlog下的_config.yml文件）找到<code>language</code>字段，设置为<code>zh-Hans</code>；<br/><br/>
然后， 在<code>themes/next/languages</code>路径下找到<code>zh-Hans.yml</code>文件，在<code>menu</code>字段下添加<code>tag</code>: 标签云（格式为<code>item_name: show_name</code>），如下：</p>

<pre class="line-numbers"><code class="language-text">   menu:
       home: 首页
       tag: 标签云    #博客页面就会显示‘标签云’
</code></pre>

<h2 id="toc_34">五、多终端同步管理技巧</h2>

<p>如果你使用过云盘或者有Git操作的基础，下面的内容会非常好理解。  </p>

<h3 id="toc_35">1、思路：</h3>

<p>需要发布到GitHub仓库的静态内容（也就是执行<code>hexo g -d</code>之后生成的<strong>public</strong>和<strong>.deploy_git</strong>文件夹）放在master上，而博客所有其他源文件（除了<strong>public</strong>和<strong>.deploy_git</strong>）存放到另外一个新建的<strong>hexo</strong>分支（这个分支的名字可以随意取），并且在GitHub上将其设为默认分支。<br/><br/>
以后所有的操作都会在<strong>hexo</strong>这个分支上进行，操作完之后依次执行<code>git add .</code>、<code>git commit -m &#39;commets&#39;</code>、<code>git push</code>把所有源文件推到远程仓库的<strong>hexo</strong>分支上（这里远程仓库其实扮演了一个云盘的角色）；即使换了电脑，你可以直接clone远程仓库的<strong>hexo</strong>分支到本地或者执行<strong>git pull</strong>下拉更新到本地覆盖现有源文件，就在本地还原了最新的博客内容了。  </p>

<h3 id="toc_36">2、操作流程</h3>

<p>假设你最早是在家里的A电脑上搭建了博客，那么A电脑的准备工作：把源文件push到GitHub。</p>

<h4 id="toc_37">1、初始化仓库</h4>

<p>博客根目录下依次执行：<br/><br/>
<code>git init</code><br/><br/>
<code>git remote add origin &lt;server&gt;</code></p>

<h4 id="toc_38">2、新建并切换到hexo分支</h4>

<p><code>git checkout -b hexo</code>  </p>

<h4 id="toc_39">3、找到.gitignore文件（没有的话就在根目录下新建一个）,在最后增加两行内容：</h4>

<p><strong>/.deploy_git</strong> 和 <strong>/public</strong></p>

<blockquote>
<p>目的是让git不跟踪这两个文件的更新，也就是push到hexo分支的内容里不会有这两个文件。</p>
</blockquote>

<h4 id="toc_40">4、把本地新建的分支push到远程分支：</h4>

<p><code>git add .</code><br/><br/>
<code>git commit -m &#39;commets&#39;</code><br/><br/>
<code>git push -u origin hexo:hexo</code>  </p>

<p>然后再去GitHub上把新建的hexo分支设置为默认分支。  </p>

<p>画面一转，我们到了公司。此时公司B电脑上空空如也，那么执行如下操作：  </p>

<p>在桌面（或任意地址）执行<br/><br/>
<code>git clone &lt;server&gt; -b &lt;branch&gt;</code><br/>
这里的<server>是你远程仓库的clone地址，<server>就是之前新创建的hexo分支，这句话的作用是把远程<server>仓库中的<branch>分支克隆到本地当前目录。<br/><br/>
有了源文件就可以任性修改博客了。修改完之后先生成静态文件发布到博客中：<br/><br/>
<code>hexo clean</code><br/><br/>
<code>hexo g -d</code><br/><br/>
再把最终保存的源文件push到GitHub，保证多终端可以同步：<br/><br/>
<code>git add .</code><br/><br/>
<code>git commit -m &#39;comment&#39;</code><br/><br/>
<code>git push</code><br/><br/>
最后画面再切换会家中的A电脑，因为此时远程仓库中的博客源文件已经做了更新，而我们A电脑上也有之前的源文件，那么只需要下来更新覆盖到本地就可以啦，进入到博客根目录，执行：<br/><br/>
<code>git pull</code>  </p>

<h2 id="toc_41">六、优化博客设置</h2>

<h3 id="toc_42">文字居中（写博客时）</h3>

<p>在你博客文章中需要居中处加上下面这段代码即可，中间的文字改成你所需要的文字。  </p>

<pre class="line-numbers"><code class="language-text">&lt;blockquote class=&quot;blockquote-center&quot;&gt;
不忘初心，这里可以写多行文字
&lt;/blockquote&gt; 
</code></pre>

<blockquote class="blockquote-center">
不忘初心，这里可以写多行文字
</blockquote>

<h3 id="toc_43">为博客加上GitHub丝带</h3>

<p>如果是Next主题（其他主题也差不多），添加GitHub丝带：在<strong>themes\next\layout_layout.swig</strong>中加入相关代码，记得修改自己的链接。</p>

<p>相关代码你可以在GitHub官方网站 <a href="https://github.com/blog/273-github-ribbons">GitHub Ribbons</a> 上进行选择。</p>

<h3 id="toc_44">加入作者版权信息</h3>

<p>我们可以为博客文章加入作者版权信息。<br/><br/>
例如本文地址：<a href="http://www......./">http://www......./</a> 转载请注明出处，谢谢！等等。<br/><br/>
对Next主题而言，先找到<strong>/themes/next/layout/_macro/post.swig</strong>，再找到其中的微信订阅部分，如下所示：<br/><br/>
<figure><img src="media/15561207869150/15713230284517.jpg" alt=""/></figure></p>

<p>然后直接在其上面添加如下代码段：   </p>

<pre class="line-numbers"><code class="language-text">&lt;div align=&quot;center&quot;&gt;
  {% if not is_index %}
    &lt;div class=&quot;copyright&quot;&gt;
    &lt;p&gt;&lt;span&gt;
    &lt;b&gt;本文地址：&lt;/b&gt;&lt;a href=&quot;{ { url_for(page.path) } }&quot; title=&quot;{ { page.title } }&quot;&gt;{ { page.permalink } }&lt;/a&gt;&lt;br /&gt;&lt;b&gt;转载请注明出处，谢谢！&lt;/b&gt;
    &lt;/span&gt;&lt;/p&gt;
    &lt;/div&gt;
  {% endif %}
&lt;/div&gt;
</code></pre>

<p>当然，在上面这段代码，你可以进行一些个性化编写，可以展示你自己个性化的版权信息。</p>

<h3 id="toc_45">为博客加入动态背景</h3>

<p>首先找到<strong>\themes\next\layout_layout.swig</strong>，在末尾前加上下面一句:（这里提供两种样式，当然你也可以自由更改）。</p>

<ul>
<li><p>默认灰色线条<br/>
<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot;&gt;&lt;/script&gt;</code></p></li>
<li><p>浅蓝色线条<br/>
<code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/particle.js&quot; count=&quot;50&quot; zindex=&quot;-2&quot; opacity=&quot;1&quot; color=&quot;0,104,183&quot;&gt;&lt;/script&gt;</code></p></li>
<li><p>然后在<strong>themes\source\js\src</strong><code>下新建文件particle.js</code>写上以下代码:  </p></li>
</ul>

<pre class="line-numbers"><code class="language-text">!function(){function n(n,e,t){return n.getAttribute(e)||t}function e(n){return document.getElementsByTagName(n)}function t(){var t=e(&quot;script&quot;),o=t.length,i=t[o-1];return{l:o,z:n(i,&quot;zIndex&quot;,-1),o:n(i,&quot;opacity&quot;,.5),c:n(i,&quot;color&quot;,&quot;0,0,0&quot;),n:n(i,&quot;count&quot;,99)} }function o(){c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight}function i(){l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i){for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle=&quot;rgba(&quot;+m.c+&quot;,&quot;+(t+.2)+&quot;)&quot;,l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)}),r(i)}var c,a,u=document.createElement(&quot;canvas&quot;),m=t(),d=&quot;c_n&quot;+m.l,l=u.getContext(&quot;2d&quot;),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n){window.setTimeout(n,1e3/45)},x=Math.random,w={x:null,y:null,max:2e4};u.id=d,u.style.cssText=&quot;position:fixed;top:0;left:0;z-index:&quot;+m.z+&quot;;opacity:&quot;+m.o,e(&quot;body&quot;)[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n){n=n||window.event,w.x=n.clientX,w.y=n.clientY},window.onmouseout=function(){w.x=null,w.y=null};for(var y=[],s=0;m.n&gt;s;s++){var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push({x:f,y:h,xa:g,ya:p,max:6e3})}setTimeout(function(){i()},100)}();
</code></pre>

<h3 id="toc_46">为博客加入鼠标点击显示红心</h3>

<p>鼠标点击小红心在<strong>\themes\next\source\js\src</strong>文件目录下添加love.js文件。内容为：</p>

<pre class="line-numbers"><code class="language-text">!function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)} }function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)} }(),n()}(window,document);
</code></pre>

<p>找到<strong>\themes\next\layout_layout.swing</strong>文件，在文件的后面，</body>之前 添加以下代码：</p>

<pre class="line-numbers"><code class="language-text">&lt;!-- 小红心 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;
</code></pre>

<h3 id="toc_47">给博客添加LICENSE</h3>

<p>在主题配置文件中添加下面这段代码（添加之前好好看看你的主题配置文件是否已经包含这段代码，已经包含就不用再加一遍了，因为重复会报错），这个<strong>LICENSE</strong>显示在侧边栏。  </p>

<pre class="line-numbers"><code class="language-text"># Creative Commons 4.0 International License.
# http://creativecommons.org/
# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero
creative_commons: by-nc-sa
#creative_commons:
</code></pre>

<h3 id="toc_48">添加Local Search功能</h3>

<p>安装 <strong>hexo</strong>插件<br/><br/>
在你的站点文件夹中，用shell等运行下面这行代码：<br/><br/>
<code>$ npm install hexo-generator-searchdb --save</code>  </p>

<h3 id="toc_49">编辑站点配置文件</h3>

<p>添加以下字段：  </p>

<pre class="line-numbers"><code class="language-text">search:
  path: search.xml
  field: post
  format: html
  limit: 10000
</code></pre>

<h3 id="toc_50">启用本地搜索</h3>

<p>编辑主题配置文件启用本地搜索  </p>

<pre class="line-numbers"><code class="language-text"># Local search
local_search:
  enable: true
</code></pre>

<h3 id="toc_51">修改字体大小</h3>

<p>打开<strong>\themes\next\source\css\ _variables\base.styl</strong>文件，将<strong>$font-size-base</strong>改成16px，如下所示：</p>

<p><code>$font-size-base = 16px</code></p>

<h3 id="toc_52">修改网页配色</h3>

<p>取色可以用QQ，打开QQ按Ctrl+Alt+A开始截图，将鼠标移到文字上，按住Ctrl键即可看到该颜色的16进制代码。也可以用chrome浏览器的develop tool取色，选取喜欢的颜色。<br/><br/>
修改<strong>\themes\next\source\css\ _variables\base.styl</strong>文件，找到文件开头的colors for use across theme，加入自定义颜色，在<strong>orange = #fc6423</strong>下加入下面这段代码：  </p>

<pre class="line-numbers"><code class="language-text">// 下面是我自定义的颜色
$my-link-blue = #0593d3  //链接颜色
$my-link-hover-blue = #0477ab  //鼠标悬停后颜色
</code></pre>

<h3 id="toc_53">修改超链接颜色</h3>

<p>打开<strong>\themes\next\source\css\ _variables\base.styl</strong>文件，像下面这样改掉这几行：  </p>

<pre class="line-numbers"><code class="language-text">/ Global link color.
$link-color                   = $my-link-blue
$link-hover-color             = $my-link-hover-blue
$link-decoration-color        = $gray-lighter
$link-decoration-hover-color  = $my-link-hover-blue
</code></pre>

<h3 id="toc_54">修改小型代码块颜色</h3>

<p>我修改<code>&lt;code&gt;</code>样式是因为我开启了<code>highlight</code>，<code>highlight</code>在渲染<code>&lt;pre&gt;&lt;code&gt;</code>标签的同时也渲染了<code>&lt;code&gt;</code>标签，而且优先级高，所以才会出现方法一中这种不开启<code>!important</code>，样式就不起作用的问题。在方法一使用了<code>!important</code>使得此处对<code>&lt;code&gt;</code>的样式优先级最高，所以设置成功。</p>

<ul>
<li>方法一<br/>
打开\themes\next\source\css\ _variables\base.styl文件，修改如下：<br/>
在下面这段代码：<br/>
<code>
// Code &amp; Code Blocks<br/>
// --------------------------------------------------<br/>
$code-font-family               = $font-family-monospace<br/>
$code-font-size                 = 14px<br/>
$code-font-size                 = unit(hexo-config(&#39;font.codes.size&#39;), px) if hexo-config(&#39;font.codes.size&#39;) is a &#39;unit&#39;<br/>
$code-border-radius             = 4px
</code></li>
</ul>

<p>下方加入下面这段代码:  </p>

<pre class="line-numbers"><code class="language-text">code {
  color:#dd0055 !important;
  background:#eee !important;
}
</code></pre>

<ul>
<li>方法二<br/>
你也可以不用方法一（建议使用方法一，因为第二种可能会失效，被其他的样式定义覆盖），而是在<code>source/css/_variables/custom.styl</code>文件中设定<code>$code-foreground</code>和<code>$code-background</code>的值，也是用的优先级。<br/>
<code>
$code-foreground = #fc6423<br/>
$code-background = #fc6423<br/>
# 此处颜色只是例子，你自己设置。
</code></li>
</ul>

<p><figure><img src="media/15561207869150/15713230870860.jpg" alt=""/></figure></p>

<h3 id="toc_55">修改其他颜色</h3>

<p>修改：<code>themes\next\source\css\_variables\.base.styl</code>文件：  </p>

<pre class="line-numbers"><code class="language-text">grey-dim     = #666         &gt;&gt;&gt;      $grey-dim     = #353535
$black-light  = #555         &gt;&gt;&gt;      $black-light  = #353535
$blue-bright  = #87daff      &gt;&gt;&gt;      $blue-bright  = #45c5ff
</code></pre>

<h3 id="toc_56">加入统计和提高索引量</h3>

<p>添加<code>sitemap</code>插件<br/><br/>
谷歌与百度的站点地图，前者适用于其他搜索引擎，用来手动提交以增加收录。<br/><br/>
<code>sitemap</code> 安装<br/><br/>
在你的站点文件夹中，用shell等分次运行下面这两行代码：  </p>

<pre class="line-numbers"><code class="language-text">npm install hexo-generator-sitemap@1 --save
npm install hexo-generator-baidu-sitemap@0.1.1 --save
</code></pre>

<p>设置站点配置文件<br/><br/>
在站点配置文件中添加代码：  </p>

<pre class="line-numbers"><code class="language-text"># hexo sitemap网站地图
sitemap:
  path: sitemap.xml
baidusitemap:
  path: baidusitemap.xml
</code></pre>

<ul>
<li><p>配置成功后，<code>hexo</code>编译时会在<code>hexo</code>站点根目录生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>。其中<code>sitemap.xml</code>适合提交给谷歌搜素引擎，<code>baidusitemap.xml</code>适合提交百度搜索引擎。</p></li>
<li><p>其次，在站点根目录下新建一个<code>robots.txt</code>文件，其中添加下面的一段代码（具体网站改为你自己的网址）：</p></li>
</ul>

<pre class="line-numbers"><code class="language-text"># hexo robots.txt
User-agent: *
Allow: /
Allow: /archives/
Disallow: /vendors/
Disallow: /js/
Disallow: /css/
Disallow: /fonts/
Disallow: /vendors/
Disallow: /fancybox/
Sitemap: http://dingxuewen.github.io/sitemap.xml
Sitemap: https://dingxuewen.github.io/sitemap.xml
</code></pre>

<h3 id="toc_57">给非友情链添加标签</h3>

<p>经过<code>chinaz</code>站长工具友情链接检测，发现有不必要的PR值输出，对于非友情链接的PR值输出，我们可以加上<code>nofollow</code>便签避免不必要的PR输出。方法是给链接加上<code>rel=&quot;external nofollow&quot;</code>属性。例如：</p>

<p>找到<code>\themes\next\layout\_partials\footer.swig</code>文件，将下面代码：<br/><br/>
<code>{ { __(&#39;footer.powered&#39;, &#39;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#39;) } }</code><br/><br/>
改成：<br/><br/>
<code>{ { __(&#39;footer.powered&#39;, &#39;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot; rel=&quot;external nofollow&quot;&gt;Hexo&lt;/a&gt;&#39;) } }</code><br/><br/>
将下面代码：<br/><br/>
<code>&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;</code><br/><br/>
改成：<br/><br/>
<code>&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt;</code>  </p>

<h3 id="toc_58">加入Baidu站长统计</h3>

<p>先准备一些代码。站长统计，注册并获取统计代码：  </p>

<pre class="line-numbers"><code class="language-text">  |  
&lt;script type=&quot;text/javascript&quot;&gt;
  var cnzz_protocol = ((&quot;https:&quot; == document.location.protocol) ? &quot; https://&quot; : &quot; http://&quot;);
  document.write(xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#39; type=&#39;text/javascript&#39;%3E%3C/script%3E&quot;));
&lt;/script&gt;
</code></pre>

<p>修改底栏:找到<code>\themes\next\layout\_partials\footer.swig</code>文件,加入上面这段代码，出于保护隐私的考虑，我编辑掉了部分关键代码，直接复制上面的无法使用。注意把上面的<code>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code>换成你自己的站长统计代码。</p>

<h3 id="toc_59">在页脚加入地图</h3>

<p>在页脚加入百度地图和谷歌地图链接：</p>

<p>找到<code>\themes\next\layout\_partials\footer.swig</code>文件，百度和Google网站地图，上面已经安装了，这是插入到底栏的代码：  </p>

<pre class="line-numbers"><code class="language-text">|  &lt;span&gt;&lt;a href=&quot;/sitemap.xml&quot;&gt;Google网站地图&lt;/a&gt;&lt;/span&gt;  
|  &lt;span&gt;&lt;a href=&quot;/baidusitemap.xml&quot;&gt;百度网站地图
</code></pre>

<h3 id="toc_60">添加Baidu自动推送</h3>

<p>百度自动推送代码，在页面被访问时，页面URL将立即被推送给百度，可以增加百度收录：找到<code>\themes\next\layout\_partials\footer.swig</code>或<code>\themes\next\layout\_macro\post.swig</code>文件，（Next主题已经有了<code>\themes\next\layout\_scripts\baidu-push.swig</code>）添加下面的代码。  </p>

<pre class="line-numbers"><code class="language-text">&lt;script&gt;
(function(){
    var bp = document.createElement(&#39;script&#39;);
    var curProtocol = window.location.protocol.split(&#39;:&#39;)[0];
    if (curProtocol === &#39;https&#39;){
   bp.src = &#39;https://zz.bdstatic.com/linksubmit/push.js&#39;;
  }
  else{
  bp.src = &#39;http://push.zhanzhang.baidu.com/push.js&#39;;
  }
    var s = document.getElementsByTagName(&quot;script&quot;)[0];
    s.parentNode.insertBefore(bp, s);
})();
&lt;/script&gt;
</code></pre>

<h3 id="toc_61">不蒜子统计</h3>

<p>找到<code>\themes\next\layout\_partials\footer.swig</code>文件，加入下面不蒜子统计代码：  </p>

<pre class="line-numbers"><code class="language-text">  |  本页点击 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次
  |  本站总点击 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次
  |  您是第 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 位访客
&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;
&lt;/script&gt;
</code></pre>

<h3 id="toc_62">在标题下添加【阅读量】等</h3>

<p>现在要添加的阅读量统计也依赖下面这段代码。  </p>

<pre class="line-numbers"><code class="language-text">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;
&lt;/script&gt;
</code></pre>

<p>打开<code>/themes/next/layout/_macro/post.swig</code>，找到标签<code>&lt;div class=&quot;post-meta&quot;&gt;&lt;/div&gt;</code>，在该标签内部合适的位置（如<code>time</code>和<code>categories</code>之间或<code>categories</code>后面）添加：</p>

<pre class="line-numbers"><code class="language-text">{% if not is_index %}
  &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;  |  阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次&lt;/span&gt;
{% endif %}
</code></pre>

<h3 id="toc_63">将阅读量改为热度（更个性）</h3>

<p>还可以继续修改，看到好多人的博客不是阅读次数（阅读量），而是热度 188 ℃，那么可以继续这样修改，首先在Next主题的<code>/themes/next/languages/zh-Hans</code>文件中查找”阅读次数“这几个字，可以看到，在<code>post</code>中的<code>visitors</code>被定义为“阅读次数”，把这里的“阅读次数”改为“热度”。</p>

<p>那么怎么在页面中显示呢。打开Next主题文件夹中<code>layout/_macro/post.swig</code>，在这个文件里加上摄氏度的标志，在<code>&lt;span class=&quot;leancloud-visitors-count&quot;&gt;&lt;/span&gt;</code>下面增加一行<code>&lt;span&gt;℃&lt;/span&gt;</code>即可。<br/><br/>
<figure><img src="media/15561207869150/15713230980370.jpg" alt=""/></figure></p>

<h3 id="toc_64">修改标题下分类等的样式</h3>

<p>在Next主题中，我用的是<code>LeanCloud</code>数据统计，默认样式是在统计数据前有个小眼睛，我感觉不好看，想把它去掉，那么打开<code>/themes/next/layout/_macro/post.swig</code>，找到标签<code>&lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;</code>，去掉下面这段代码即可：  </p>

<pre class="line-numbers"><code class="language-text">&lt;span class=&quot;post-meta-item-icon&quot;&gt;
  &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt;
&lt;/span&gt;
</code></pre>

<h3 id="toc_65">多说个性化设置</h3>

<p>设置多说动感头像<br/>
打开多说后台，进入后台管理，点击设置，在设置里有“自定义CSS”，将下面的这段代码粘贴进去：  </p>

<pre class="line-numbers"><code class="language-text">#ds-reset .ds-avatar img,
#ds-recent-visitors .ds-avatar img {
width: 54px;
height: 54px;     /*设置图像的长和宽，这里要根据自己的评论框情况更改*/
border-radius: 27px;     /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/
-webkit-border-radius: 27px;     /*圆角效果：兼容webkit浏览器*/
-moz-border-radius: 27px;
box-shadow: inset 0 -1px 0 #3333sf;     /*设置图像阴影效果*/
-webkit-box-shadow: inset 0 -1px 0 #3333sf;
-webkit-transition: 0.4s;
-webkit-transition: -webkit-transform 0.4s ease-out;
transition: transform 0.4s ease-out;     /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/
-moz-transition: -moz-transform 0.4s ease-out;
}
#ds-reset .ds-avatar img:hover,
#ds-recent-visitors .ds-avatar img:hover {
/*设置鼠标悬浮在头像时的CSS样式*/    box-shadow: 0 0 10px #fff;
rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);
-webkit-box-shadow: 0 0 10px #fff;
rgba(255, 255, 255, .6), inset 0 0 20px rgba(255, 255, 255, 1);
transform: rotateZ(360deg);     /*图像旋转360度*/
-webkit-transform: rotateZ(360deg);
-moz-transform: rotateZ(360deg);
}
#ds-thread #ds-reset .ds-textarea-wrapper textarea {
background: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;
}
#ds-recent-visitors .ds-avatar {
float: left
}
/*隐藏多说底部版权*/
#ds-thread #ds-reset .ds-powered-by {
display: none;
}
</code></pre>

<h3 id="toc_66">最近访客设置</h3>

<ul>
<li>第一步 为页面添加代码<br/>
往你想添加的页面增加下面的一小段代码即可。<br/>
<code>&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;28&quot; data-avatar-size=&quot;42&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt;</code><br/></li>
</ul>

<p>解释一下上一段代码，其中：  </p>

<pre class="line-numbers"><code class="language-text">class=“ds-recent-visitors”    //指定显示最近访客容器
data-num-items=“28”    //显示最近访客的数量
data-avatar-size=“42”    //显示最近访客头像尺寸大小
id=“ds-recent-visitors”    //为了调节最近访客样式加的
</code></pre>

<p>可以通过生成了一个guestbook页面，然后直接在\guestbook\index.md中添加了上面那段代码实现的。</p>

<ul>
<li>第二步 修改其样式<br/>
通过多说后台管理&gt;设置&gt;基本设置&gt;自定义CSS修改最近访客css样式。<br/>
我的整个多说自定义css，其中访客样式和评论样式统一。代码已经包括在上一节设置多说动感头像的那段代码中了。你还可以不直接用那段代码，而是对其进行编辑，修改成你喜欢的样式。</li>
</ul>

<h3 id="toc_67">增加留言页</h3>

<p>那么有人会问，guestbook是如何创建的，那么现在我就把方法写出来。<br/><br/>
新建一个 <code>guestbook</code> 页面：<br/><br/>
在你的站点文件夹，用shell等运行下面这行代码：<br/><br/>
<code>hexo new page &quot;guestbook&quot;</code>  </p>

<p>找到你NexT主题<code>_config.yml</code>（主意是Next主题的<code>_config.yml</code>，不是hexo站点目录下的<code>_config.yml</code>），文件路径<code>\themes\next\_config.yml</code>，添加<code>guestbook</code>到<code>menu</code>中，如下:  </p>

<pre class="line-numbers"><code class="language-text">menu:
  home: /
  #categories: /categories
  about: /about
  archives: /archives
  # tags: /tags
  #commonweal: /404.html
  guestbook: /guestbook
</code></pre>

<p>找到你Next主题<code>zh-Hans.yml</code>文件（我的网站是简体语言的），文件路径<code>\themes\next\languages\zh-Hans.yml</code>，添加<code>guestbook</code>: 留言板到<code>menu</code>中，如下:  </p>

<pre class="line-numbers"><code class="language-text">menu:
  home: 首页
  archives: 归档
  categories: 分类
  tags: 标签
  about: 关于
  commonweal: 公益404
  guestbook: 留言
</code></pre>

<h3 id="toc_68">SEO优化</h3>

<p>更改首页标题格式为「关键词-网站名称-网站描述」。打开<code>\themes\next\layout\index.swig</code>文件，找到这行代码：<br/><br/>
<code>{% block title %} { { config.title } } {% endblock %}</code><br/><br/>
把它改成：  </p>

<pre class="line-numbers"><code class="language-text">{% block title %}
  { { theme.keywords } } - { { config.title } } - { { theme.description } }
{% endblock %}
</code></pre>

<p><figure><img src="media/15561207869150/15713231331218.jpg" alt=""/></figure></p>

<h3 id="toc_69">博客部署的message设置</h3>

<p>在<code>\hexo\node_modules\hexo-deployer-git\lib\deployer.js</code>文件末尾找到这一句：<br/><br/>
<code>Site updated: { { now(&#39;YYYY-MM-DD HH:mm:ss&#39;) } }.</code><br/><br/>
改得个性化一点：<br/><br/>
<code>勤奋的博主又更新啦: { { now(\&#39;YYYY-MM-DD HH:mm:ss\&#39;) } }.</code>  </p>

<h3 id="toc_70">为项目主页添加README</h3>

<p>在 <code>Github</code> 上的博客仓库主页空荡荡的，没有<code>README</code>。如果把<code>README.md</code>放入<code>source</code>文件夹，<code>hexo g</code>生成时会被解析成<code>html</code>文件，放到<code>public</code>文件夹，生成时又会自动删除。<br/>
  解决方法很简单，在站点配置文件中，搜索<code>skip_render:</code>，在其冒号后加一个空格然后加上<code>README.md</code>即可。<br/>
  </p>

<h3 id="toc_71">优化主题 sidebar 头像</h3>

<p>就是为主题 <code>sidebar</code> 头像添加圆形化旋转的效果。修改 <code>/themes/next/source/css/_common/components/sidebar/sidebar-author.styl</code> 文件，我的整个 <code>sidebar-author.styl</code>文件的代码如下，你可以直接复制这段代码去替换你这个文件中的所有代码。<br/>
有一个注意事项，就是你要保证你的头像，也就是 <code>avatar.jpg</code> 这个图片是正方形，不是的话你要将其修改成正方形，这样才能通过样式将其展现为很好看的正圆，否则会是一个椭圆形。</p>

<pre class="line-numbers"><code class="language-text">.site-author-image {
  display: block;
  margin: 0 auto;
  padding: $site-author-image-padding;
  max-width: $site-author-image-width;
  height: $site-author-image-height;
  border: $site-author-image-border-width solid $site-author-image-border-color;

  /* 头像圆形 */
  border-radius: 80px;
  -webkit-border-radius: 80px;
  -moz-border-radius: 80px;
  box-shadow: inset 0 -1px 0 #333sf;

  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/
  -webkit-animation: play 2s ease-out 1s 1;
  -moz-animation: play 2s ease-out 1s 1;
  animation: play 2s ease-out 1s 1;

  /* 鼠标经过头像旋转360度 */
  -webkit-transition: -webkit-transform 1.5s ease-out;
  -moz-transition: -moz-transform 1.5s ease-out;
  transition: transform 1.5s ease-out;
}
img:hover {
  /* 鼠标经过停止头像旋转 
  -webkit-animation-play-state:paused;
  animation-play-state:paused;*/

  /* 鼠标经过头像旋转360度 */
  -webkit-transform: rotateZ(360deg);
  -moz-transform: rotateZ(360deg);
  transform: rotateZ(360deg);
}
/* Z 轴旋转动画 */
@-webkit-keyframes play {
  0% {
    -webkit-transform: rotateZ(0deg);
  }
  100% {
    -webkit-transform: rotateZ(-360deg);
  }
}
@-moz-keyframes play {
  0% {
    -moz-transform: rotateZ(0deg);
  }
  100% {
    -moz-transform: rotateZ(-360deg);
  }
}
@keyframes play {
  0% {
    transform: rotateZ(0deg);
  }
  100% {
    transform: rotateZ(-360deg);
  }
}
.site-author-name {
  margin: $site-author-name-margin;
  text-align: $site-author-name-align;
  color: $site-author-name-color;
  font-weight: $site-author-name-weight;
}
.site-description {
  margin-top: $site-description-margin-top;
  text-align: $site-description-align;
  font-size: $site-description-font-size;
  color: $site-description-color;
}
</code></pre>

<p><figure><img src="media/15561207869150/15713231449946.jpg" alt=""/></figure></p>

<h3 id="toc_72">小红心优化</h3>

<p>为博客加入鼠标点击显示小红心，但是如果我们只想在博客的某个页面添加这个功能呢？<br/>
那么就可以在 <code>\themes\next\source\js\src 文件目录下添加 love.js</code> 文件。内容为：</p>

<pre class="line-numbers"><code class="language-text">!function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)} }function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)} }(),n()}(window,document);
</code></pre>

<p>之后呢，不在<code>\themes\next\layout\_layout.swing</code> 文件中添加代码，而是在你想要显示红心的页面的 <code>Markdown</code>文件中加入下面这段代码,例如我就在我的留言板页面的 <code>Markdown</code> 文件中加入了下面这段代码。</p>

<pre class="line-numbers"><code class="language-text">&lt;!-- 小红心 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;
</code></pre>

<h3 id="toc_73">文章内文本样式</h3>

<p><code>Markdown</code> 毕竟是为了方便写作，在样式上过于单调。我们可以自己来给文章加一些样式。NexT 作者提供了一个供用户自己定义样式的文件：<code>\themes\next\source\css\_custom\custom.stly</code>。可以按照自己的需要写。</p>

<h3 id="toc_74">设置动态title</h3>

<p>在 <code>\themes\next\source\js\src</code> 目录下新建 <code>dytitle.js</code> 。添加以下内容：</p>

<pre class="line-numbers"><code class="language-text">&lt;!--崩溃欺骗--&gt;
var OriginTitile = document.title;
 var titleTime;
 document.addEventListener(&#39;visibilitychange&#39;, function () {
     if (document.hidden) {
         $(&#39;[rel=&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;/img/TEP.ico&quot;);
         document.title = &#39; 页面崩溃啦 ~ | cwyaml！&#39;;
         clearTimeout(titleTime);
     }
     else {
         $(&#39;[rel=&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;/favicon.ico&quot;);
         document.title = &#39; 噫又好了~ &#39; + OriginTitile;
         titleTime = setTimeout(function () {
             document.title = OriginTitile;
         }, 2000);
     }
 });
</code></pre>

<p>更改 <code>\themes\next\layout\_layout.swig</code> 。在<code>&lt;/body&gt;</code> 之前添加：</p>

<pre class="line-numbers"><code class="language-text">&lt;!--卖萌--&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/dytitle.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p><figure><img src="media/15561207869150/2017033114909378973004.gif" alt=""/></figure></p>

<h3 id="toc_75">添加听音乐</h3>

<p>代码设置<br/>
在 <code>\themes\next\layout\_macro</code>目录下新建 <code>high.swig</code> 文件，添加以下内容：</p>

<pre class="line-numbers"><code class="language-text">&lt;a title=&quot;收藏到书签，偶尔High一下^_^&quot; rel=&quot;alternate&quot; class=&quot;mw-harlem_shake_slow wobble shake&quot; href=&#39;javascript:(
    /*
     * Copyright (C) 2015 Rocko (rocko.xyz) &lt;rocko.zxp@gmail.com&gt;
     *
     * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
     * you may not use this file except in compliance with the License.

     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function go() {

      var songs = [
          &quot;http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3&quot;, 
          &quot;http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3&quot;,
          &quot;http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3&quot;,    
          &quot;......&quot;
      ];

      function S() {
          var e = document.getElementById(&quot;audio_element_id&quot;);
          if(e != null){
              var index = parseInt(e.getAttribute(&quot;curSongIndex&quot;));
              if(index &gt; songs.length - 2) {
                  index = 0;
              } else {
                  index++;
              }
              e.setAttribute(&quot;curSongIndex&quot;, index);
          }
          e.src = i;
          e.play()
      }
      function initAudioEle() {
          var e = document.getElementById(&quot;audio_element_id&quot;);
          if(e === null){
            e = document.createElement(&quot;audio&quot;);
            e.setAttribute(&quot;curSongIndex&quot;, 0);
            e.id = &quot;audio_element_id&quot;;
            e.loop = false;
            e.bgcolor = 0;
            e.innerHTML = &quot; &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;&quot;;
            document.body.appendChild(e);
            e.addEventListener(&quot;ended&quot;, function() {
              go();
            }, true);
          }        
      }

      initAudioEle();
      var curSongIndex = parseInt(document.getElementById(&quot;audio_element_id&quot;).getAttribute(&quot;curSongIndex&quot;));
      var i = songs[curSongIndex];
      S();
    })()&#39;&gt;
    &lt;i class=&quot;fa fa-music&quot;&gt;&lt;/i&gt; 听音乐&lt;/a&gt;
</code></pre>

<p>在侧边栏引用该文件：修改 <code>\themes\next\layout\_macro\sidebar.swig</code> ，添加以下代码：<br/>
<figure><img src="media/15561207869150/15713232089390.jpg" alt=""/></figure></p>

<p><figure><img src="media/15561207869150/15713232213230.png" alt=""/></figure></p>

<p>样式修改：使 听音乐 和 RSS 并排展示。<br/>
修改 <code>\themes\next\source\css\_schemes\Pisces\_sidebar.styl</code>文件：<br/><br/>
<code>display: inline-block;</code>  </p>

<p><figure><img src="media/15561207869150/15713232712578.png" alt=""/></figure></p>

<p>添加自己喜欢的音乐：修改其中的歌曲链接即可.</p>

<pre class="line-numbers"><code class="language-text">var songs = [
      &quot;http://m2.music.126.net/3uHnH7uQAeFwUfuvEB9lrg==/3265549619475054.mp3&quot;, 
      &quot;http://m2.music.126.net/NnHwR2HV-1OoKZ6R5LVy4Q==/18502581673300023.mp3&quot;,
      &quot;http://m2.music.126.net/qv3RI4K7ABKJ0TyAdb3taw==/3250156397064860.mp3&quot;,    
      &quot;......&quot;
  ];
</code></pre>

<p>首页听音乐摇晃：需要加载 <code>css</code> 样式。在 <code>themes\next\layout\_layout.swig</code>文件的 <code>&lt;/body&gt;</code>标签前 添加以下代码：</p>

<pre class="line-numbers"><code class="language-text">&lt;!-- 听音乐摇晃 --&gt;
&lt;link href=&quot;http://s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;
</code></pre>

<p>注意：有时候使用 <code>Firefox</code> 、<code>Chrome</code>时会提示非法插件并禁止使用，遇到这种情况我们把样式代码引入到 <code>\themes\next\source\css\_custom\custom.stly</code>文件即可解决。</p>

<h3 id="toc_76">音乐链接获取</h3>

<ul>
<li>先获取歌曲id，直接打开 网易云音乐网页版 <a href="http://music.163.com">http://music.163.com</a> 搜索自己喜欢的音乐，点击外链生成器获取歌曲的 ID 。举个例子：（id显而易见吧）<br/>
<code>http://music.163.com/#/song?id=443205403</code><br/></li>
<li>将下面网址中的两处id替换成的歌曲 id ，你将会获得一大串代码：外链就隐藏其中（如下图，自己找）。</li>
<li><a href="http://music.163.com/api/song/detail/?id=425137664&amp;ids=%5B425137664%5D&amp;csrf_token=">http://music.163.com/api/song/detail/?id=425137664&amp;ids=[425137664]&amp;csrf_token=</a></li>
</ul>

<p><figure><img src="media/15561207869150/15713233009274.png" alt=""/></figure></p>

<ul>
<li>将上一步中获取到的网址放到地址栏中，若能正常播放音乐说明获取到的网址是正确的。然后你就可以把这些歌曲添加到自己的网页中了！用这种方法有些歌曲并不能获得，不过时效很长（只要网易云能听）。</li>
</ul>

<h3 id="toc_77">博文压缩</h3>

<p>目前知道的有两个插件可以压缩博文，<code>hexo-all-minifier</code> 插件和 <code>gulp</code> 插件。<code>hexo-all-minifier</code> 虽然使用比较简单，而且也可以压缩图片，但是对文章缩进（输入法全拼模式下按 Tab）不支持，所以暂时使用 gulp 压缩手段。</p>

<h4 id="toc_78"><code>hexo-all-minifier</code> 使用方法</h4>

<p>安装 <code>hexo-all-minifier</code>，在站点的根目录下执行以下命令：<br/><br/>
<code>$ npm install hexo-all-minifier --save</code><br/><br/>
hexo g 编译的时候就会自动压缩 HTML、JS、图片。详情参考插件介绍 <a href="https://github.com/chenzhutian/hexo-all-minifier">hexo-all-minifier</a></p>

<h4 id="toc_79"><code>glup</code> 使用方法</h4>

<p>hexo 依赖 gulp 插件安装，在站点的根目录下执行以下命令：  </p>

<pre class="line-numbers"><code class="language-text">$ npm install gulp -g
$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save
</code></pre>

<p>在 <code>package.json</code> 同级目录下，新建 <code>gulpfile.js</code> 并填入以下内容：  </p>

<pre class="line-numbers"><code class="language-text">var gulp = require(&#39;gulp&#39;);
var minifycss = require(&#39;gulp-minify-css&#39;);
var uglify = require(&#39;gulp-uglify&#39;);
var htmlmin = require(&#39;gulp-htmlmin&#39;);
var htmlclean = require(&#39;gulp-htmlclean&#39;);
// 压缩 public 目录 css
gulp.task(&#39;minify-css&#39;, function() {
    return gulp.src(&#39;./public/**/*.css&#39;)
        .pipe(minifycss())
        .pipe(gulp.dest(&#39;./public&#39;));
});
// 压缩 public 目录 html
gulp.task(&#39;minify-html&#39;, function() {
  return gulp.src(&#39;./public/**/*.html&#39;)
    .pipe(htmlclean())
    .pipe(htmlmin({
         removeComments: true,
         minifyJS: true,
         minifyCSS: true,
         minifyURLs: true,
    }))
    .pipe(gulp.dest(&#39;./public&#39;))
});
// 压缩 public/js 目录 js
gulp.task(&#39;minify-js&#39;, function() {
    return gulp.src(&#39;./public/**/*.js&#39;)
        .pipe(uglify())
        .pipe(gulp.dest(&#39;./public&#39;));
});
// 执行 gulp 命令时执行的任务
gulp.task(&#39;default&#39;, [
    &#39;minify-html&#39;,&#39;minify-css&#39;,&#39;minify-js&#39;
]);
</code></pre>

<p>生成博文是执行 <code>hexo g &amp;&amp;amp</code>; <code>gulp</code> 就会根据 <code>gulpfile.js</code> 中的配置，对 public目录中的静态资源文件进行压缩。</p>

<h3 id="toc_80">博文置顶</h3>

<p>修改 <code>hero-generator-index</code> 插件<br/><br/>
替换文件：<code>node_modules/hexo-generator-index/lib/generator.js</code> 内的代码为：  </p>

<pre class="line-numbers"><code class="language-text">&#39;use strict&#39;;
var pagination = require(&#39;hexo-pagination&#39;);
module.exports = function(locals){
  var config = this.config;
  var posts = locals.posts;
    posts.data = posts.data.sort(function(a, b) {
        if(a.top &amp;&amp; b.top) { // 两篇文章top都有定义
            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排
            else return b.top - a.top; // 否则按照top值降序排
        }
        else if(a.top &amp;&amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）
            return -1;
        }
        else if(!a.top &amp;&amp; b.top) {
            return 1;
        }
        else return b.date - a.date; // 都没定义按照文章日期降序排
    });
  var paginationDir = config.pagination_dir || &#39;page&#39;;
  return pagination(&#39;&#39;, posts, {
    perPage: config.index_generator.per_page,
    layout: [&#39;index&#39;, &#39;archive&#39;],
    format: paginationDir + &#39;/%d/&#39;,
    data: {
      __index: true
    }
  });
};
</code></pre>

<h3 id="toc_81">设置文章置顶</h3>

<p>在文章 <code>Front-matter</code> 中添加 <code>top</code> 值，数值越大文章越靠前，如：  </p>

<pre class="line-numbers"><code class="language-text">---
title: 图集
categories: [图片]
tags: [picture]
date: 2015-04-02 14:36:04
top: 10
---
</code></pre>

<h3 id="toc_82">embed.js本地化</h3>

<p><code>embed.js</code> 是多说使用的远程脚本，你可以访问 <code>http://static.duoshuo.com/embed.js</code> 这个网址。右键另存为 <code>\theme\next\source\js\src\</code>这个文件夹。</p>

<p>然后打开 <code>\themes\next\layout\_scripts\third-party\comments\duoshuo.swig</code> 这个文件，在文件里搜索 <code>//static.duoshuo.com/embed.js</code> ，把它改成 <code>/js/src/embed.js</code>。搞定啦！</p>

<h3 id="toc_83">Hexo更改默认Google字体库</h3>

<p>因为一些国内的客观原因，google字体库 的访问速度一直很慢，所以生成页面后，访问系统总是会耗费一大部分的时间在加载google字体库上，而且经常加载不成功。<br/><br/>
解决的办法是可以用国内的CDN库来替代主题中的google字体库，更改方法如下：<br/>
shell中运行如下命令：<br/><br/>
<code>grep -ir fonts.google themes/</code><br/>
找到对应的google字体库地方，用国内的CDN字体库替换，如360字体库：<a href="http://libs.useso.com/">360前端公共库CDN</a>。</p>

<h3 id="toc_84">首页分割线</h3>

<p>在 <code>\themes\next\source\css\_custom\custom.styl</code> 文件中添加以下代码，可以修改博客首页中每篇文章的分割线长度，我设置为了100%长度。  </p>

<pre class="line-numbers"><code class="language-text">//index页面中每篇文章相隔的那条线
.posts-expand {
  .post-eof {
    display: block;
    margin: $post-eof-margin-top auto $post-eof-margin-bottom;
    width: 100%;
    height: 3px;
    background: $grey-light;
    text-align: center;
  }
}
</code></pre>

<h3 id="toc_85">字体、颜色等设置</h3>

<p>在<code>\themes\next\source\css\_variables\custom.styl</code> 文件中添加以下代码。具体功能我已经做了注释。</p>

<pre class="line-numbers"><code class="language-text">// 标题，修改成你期望的字体族
$font-family-headings = Georgia, sans
// 修改成你期望的字体族
$font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif
// 代码字体
$code-font-family = &quot;Input Mono&quot;, &quot;PT Mono&quot;, Consolas, Monaco, Menlo, monospace
// 正文字体的大小
$font-size-base = 16px
// 代码字体的大小
$code-font-size = 14px
// 代码块颜色
$code-foreground = #dd0055
// Background color for &lt;body&gt;
$body-bg-color = #e7e5dc  //theme mist use #fdfdfd
// text-color
$text-color = #353535
</code></pre>

<h3 id="toc_86">语言配置</h3>

<p><code>_config.yml</code>中的<code>language</code>要配置为选定的主题<code>cilia</code>文件夹下的<code>language</code>目录下的文件，如：  </p>

<pre class="line-numbers"><code class="language-text">language: zh-Hans
language: en
language: zh-hk
language: zh-tw
</code></pre>

<p>这里修改 zh-Hans为标准的zh-cn,并添加一些汉化内容<br/><br/>
语言配置用法:  </p>

<pre class="line-numbers"><code class="language-text"># 不带参数的
__(&#39;xxxx&#39;)
# 带参数的
_p(&#39;xxx&#39;,xx)
</code></pre>

<h3 id="toc_87">不蒜子统计显示</h3>

<p>添加站点统计配置为不蒜子统计，并且可开关<br/><br/>
<code>busuanzi: true</code>  </p>

<h3 id="toc_88">配置自己的分享</h3>

<p>国内的<code>jiathis</code><br/>
将<code>themes/yilia/_partial/share_jia.ejs</code>中的内容替换为：</p>

<pre class="line-numbers"><code class="language-text">&lt;div class=&quot;jiathis_style&quot;&gt;
    &lt;span class=&quot;jiathis_txt&quot;&gt;&lt;%= __(&#39;post.share&#39;) %&gt;:   &lt;/span&gt;
    &lt;a class=&quot;jiathis_button_weixin&quot;&gt;微信&lt;/a&gt;
    &lt;a class=&quot;jiathis_button_cqq&quot;&gt;QQ好友&lt;/a&gt;
    &lt;a class=&quot;jiathis_button_qzone&quot;&gt;QQ空间&lt;/a&gt;
    &lt;a class=&quot;jiathis_button_tsina&quot;&gt;新浪微博&lt;/a&gt;
    &lt;a href=&quot;http://www.jiathis.com/share?uid=2080230&quot; class=&quot;jiathis jiathis_txt jiathis_separator jtico jtico_jiathis&quot; target=&quot;_blank&quot;&gt;更多&lt;/a&gt;
    &lt;a class=&quot;jiathis_counter_style&quot;&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://v3.jiathis.com/code/jia.js?uid=2080230&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
</code></pre>

<p>其中uid为自己在<code>jiathis</code>注册的<code>uid</code><br/>
国外的<code>add this</code><br/>
将<code>themes/yilia/_partial/share_jia.ejs</code>中的内容替换为：  </p>

<pre class="line-numbers"><code class="language-text">&lt;!-- Go to www.addthis.com/dashboard to customize your tools --&gt;
&lt;div class=&quot;addthis_sharing_toolbox&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-568f54bcfd6a7b04&quot; async=&quot;async&quot;&gt;&lt;/script&gt;
</code></pre>

<h3 id="toc_89">Rss</h3>

<p>添加Rss，需要先安装rss生成模块：<br/><br/>
<code>npm install hexo-generator-feed --save</code><br/><br/>
然后在themes/yilia/_config.yml开启rss<br/><br/>
<code>rss: /atom.xml</code><br/><br/>
添加站点地图插件<br/><br/>
<code>npm install hexo-generator-sitmap --save</code><br/><br/>
会在每次<code>hexo generator</code>后自动生成到网站根目录  </p>

<h3 id="toc_90">设置网站logo</h3>

<p>通过网站<a href="http://tool.lu/favicon/">favicon</a>在线制作 制作favicon图片，logo最好设置32*32。<br/>
next主题：将图片放在next主题<code>source/images</code>目录下</p>

<pre class="line-numbers"><code class="language-text"># 在next主题配置文件中添加：
favicon: /uploads/images/favicon.png
</code></pre>

<p><figure><img src="media/15561207869150/15713233218770.png" alt=""/></figure></p>

<h3 id="toc_91">Hexo文章简单加密访问</h3>

<p>找到<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件。<br/>
按道理是添加在任何地方都行，但是推荐加在所有的<code>&lt;meta&gt;</code>标签之后。</p>

<pre class="line-numbers"><code class="language-text">&lt;script&gt;
    (function() {
        if(&#39;{ { page.password } }&#39;) {
            if (prompt(&#39;请输入文章密码&#39;) !== &#39;{ { page.password } }&#39;) {
                alert(&#39;密码错误！&#39;);
                history.back();
            }
        }
    } )();
&lt;/script&gt;
</code></pre>

<pre class="line-numbers"><code class="language-text">---
title: Hexo文章简单加密访问
date: 2016-12-02 
tags: hexo
categories: 博客
keywords:
    - Hexo
    - 加密
description: 文章访问密码：password
password: password
---
</code></pre>

<p><figure><img src="media/15561207869150/15713233356229.png" alt=""/></figure></p>

<h3 id="toc_92">Hexo high一下</h3>

<p>是直接把这段代码当成一个菜单项加在博客主题配置的<code>_config.yml</code>文件中  </p>

<pre class="line-numbers"><code class="language-text">&lt;li&gt; &lt;a title=&quot;把这个链接拖到你的Chrome收藏夹工具栏中&quot; href=&#39;javascript:(function() {
    function c() {
        var e = document.createElement(&quot;link&quot;);
        e.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
        e.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);
        e.setAttribute(&quot;href&quot;, f);
        e.setAttribute(&quot;class&quot;, l);
        document.body.appendChild(e)
    }

    function h() {
        var e = document.getElementsByClassName(l);
        for (var t = 0; t &lt; e.length; t++) {
            document.body.removeChild(e[t])
        }
    }

    function p() {
        var e = document.createElement(&quot;div&quot;);
        e.setAttribute(&quot;class&quot;, a);
        document.body.appendChild(e);
        setTimeout(function() {
            document.body.removeChild(e)
        }, 100)
    }

    function d(e) {
        return {
            height : e.offsetHeight,
            width : e.offsetWidth
        }
    }

    function v(i) {
        var s = d(i);
        return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r
    }

    function m(e) {
        var t = e;
        var n = 0;
        while (!!t) {
            n += t.offsetTop;
            t = t.offsetParent
        }
        return n
    }

    function g() {
        var e = document.documentElement;
        if (!!window.innerWidth) {
            return window.innerHeight
        } else if (e &amp;&amp; !isNaN(e.clientHeight)) {
            return e.clientHeight
        }
        return 0
    }

    function y() {
        if (window.pageYOffset) {
            return window.pageYOffset
        }
        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
    }

    function E(e) {
        var t = m(e);
        return t &gt;= w &amp;&amp; t &lt;= b + w
    }

    function S() {
        var e = document.createElement(&quot;audio&quot;);
        e.setAttribute(&quot;class&quot;, l);
        e.src = i;
        e.loop = false;
        e.addEventListener(&quot;canplay&quot;, function() {
            setTimeout(function() {
                x(k)
            }, 500);
            setTimeout(function() {
                N();
                p();
                for (var e = 0; e &lt; O.length; e++) {
                    T(O[e])
                }
            }, 15500)
        }, true);
        e.addEventListener(&quot;ended&quot;, function() {
            N();
            h()
        }, true);
        e.innerHTML = &quot; &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;&quot;;
        document.body.appendChild(e);
        e.play()
    }

    function x(e) {
        e.className += &quot; &quot; + s + &quot; &quot; + o
    }

    function T(e) {
        e.className += &quot; &quot; + s + &quot; &quot; + u[Math.floor(Math.random() * u.length)]
    }

    function N() {
        var e = document.getElementsByClassName(s);
        var t = new RegExp(&quot;\\b&quot; + s + &quot;\\b&quot;);
        for (var n = 0; n &lt; e.length; ) {
            e[n].className = e[n].className.replace(t, &quot;&quot;)
        }
    }

    var e = 30;
    var t = 30;
    var n = 350;
    var r = 350;
    var i = &quot;//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3&quot;;
    var s = &quot;mw-harlem_shake_me&quot;;
    var o = &quot;im_first&quot;;
    var u = [&quot;im_drunk&quot;, &quot;im_baked&quot;, &quot;im_trippin&quot;, &quot;im_blown&quot;];
    var a = &quot;mw-strobe_light&quot;;
    var f = &quot;//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css&quot;;
    var l = &quot;mw_added_css&quot;;
    var b = g();
    var w = y();
    var C = document.getElementsByTagName(&quot;*&quot;);
    var k = null;
    for (var L = 0; L &lt; C.length; L++) {
        var A = C[L];
        if (v(A)) {
            if (E(A)) {
                k = A;
                break
            }
        }
    }
    if (A === null) {
        console.warn(&quot;Could not find a node of the right size. Please try a different page.&quot;);
        return
    }
    c();
    S();
    var O = [];
    for (var L = 0; L &lt; C.length; L++) {
        var A = C[L];
        if (v(A)) {
            O.push(A)
        }
    }
})()    &#39;&gt;High一下&lt;/a&gt; &lt;/li&gt;
</code></pre>

<pre class="line-numbers"><code class="language-text">menu:
  high: javascript:void(0)
menu_icons:
  high: play

// 第一个 high 的javascript:void(0)是指a标签的跳转链接，其实这里的功能就是为了让它不跳转的，另外还有一个功能，可以把空链接的a标签悬浮变成手型的鼠标。

第二个 high对应的play是展示的图标，NexT主题使用的是fontawesome图标，这里的play就是其对应的图标，想自己 diy 一下就去fontawesome上找个自己喜欢的。

这样的方法简单粗暴有效，并且还有一个好处，可以直接把这个链接保存成浏览器的书签，这样就能在任何网页都能够调用这个 High一下 的方法。
</code></pre>

<h3 id="toc_93">high 一下自定义页面歌曲</h3>

<p>首先是在需要自定义曲子的文章中加上：<br/><br/>
<code>&lt;div id=&quot;musicUrl&quot; url=&quot;***&quot;&gt;&lt;div&gt;</code><br/><br/>
然后最终版high.js代码是这样：  </p>

<pre class="line-numbers"><code class="language-text">document.getElementsByClassName(&#39;menu-item-high&#39;)[0].addEventListener(&#39;click&#39;, (function(){
    var play = false;
    var musicUrl = document.getElementById(&#39;musicUrl&#39;);
    if(musicUrl){
        musicUrl = musicUrl.getAttribute(&#39;url&#39;);
    }else{
        musicUrl = null;
    }
    return function(){
        if(play){
            console.log(&#39;Enjoying&#39;);
            return;
        }
        play = true;
        function c() {
            var e = document.createElement(&quot;link&quot;);
            e.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
            e.setAttribute(&quot;rel&quot;, &quot;stylesheet&quot;);
            e.setAttribute(&quot;href&quot;, f);
            e.setAttribute(&quot;class&quot;, l);
            document.body.appendChild(e)
        }

        function h() {
            var e = document.getElementsByClassName(l);
            for (var t = 0; t &lt; e.length; t++) {
                document.body.removeChild(e[t])
            }
        }

        function p() {
            var e = document.createElement(&quot;div&quot;);
            e.setAttribute(&quot;class&quot;, a);
            document.body.appendChild(e);
            setTimeout(function() {
                document.body.removeChild(e)
            }, 100)
        }

        function d(e) {
            return {
                height: e.offsetHeight,
                width: e.offsetWidth
            }
        }

        function v(i) {
            var s = d(i);
            return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r
        }

        function m(e) {
            var t = e;
            var n = 0;
            while (!!t) {
                n += t.offsetTop;
                t = t.offsetParent
            }
            return n
        }

        function g() {
            var e = document.documentElement;
            if (!!window.innerWidth) {
                return window.innerHeight
            } else if (e &amp;&amp; !isNaN(e.clientHeight)) {
                return e.clientHeight
            }
            return 0
        }

        function y() {
            if (window.pageYOffset) {
                return window.pageYOffset
            }
            return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
        }

        function E(e) {
            var t = m(e);
            return t &gt;= w &amp;&amp; t &lt;= b + w
        }

        function S() {
            var e = document.createElement(&quot;audio&quot;);
            e.setAttribute(&quot;class&quot;, l);
            e.src = i;
            e.loop = false;
            e.addEventListener(&quot;canplay&quot;, function() {
                setTimeout(function() {
                    x(k)
                }, 500);
                setTimeout(function() {
                    N();
                    p();
                    for (var e = 0; e &lt; O.length; e++) {
                        T(O[e])
                    }
                }, 15500)
            }, true);
            e.addEventListener(&quot;ended&quot;, function() {
                N();
                h();
                paly = false;
            }, true);
            e.innerHTML = &quot; &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;&quot;;
            document.body.appendChild(e);
            e.play()
        }

        function x(e) {
            e.className += &quot; &quot; + s + &quot; &quot; + o
        }

        function T(e) {
            e.className += &quot; &quot; + s + &quot; &quot; + u[Math.floor(Math.random() * u.length)]
        }

        function N() {
            var e = document.getElementsByClassName(s);
            var t = new RegExp(&quot;\\b&quot; + s + &quot;\\b&quot;);
            for (var n = 0; n &lt; e.length; ) {
                e[n].className = e[n].className.replace(t, &quot;&quot;)
            }
        }

        var e = 30;
        var t = 30;
        var n = 350;
        var r = 350;
        var i = musicUrl || &quot;//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3&quot;;
        var s = &quot;mw-harlem_shake_me&quot;;
        var o = &quot;im_first&quot;;
        var u = [&quot;im_drunk&quot;, &quot;im_baked&quot;, &quot;im_trippin&quot;, &quot;im_blown&quot;];
        var a = &quot;mw-strobe_light&quot;;
        var f = &quot;/vendors/high/high.css&quot;;
        var l = &quot;mw_added_css&quot;;
        var b = g();
        var w = y();
        var C = document.getElementsByTagName(&quot;*&quot;);
        var k = null;
        for (var L = 0; L &lt; C.length; L++) {
            var A = C[L];
            if (v(A)) {
                if (E(A)) {
                    k = A;
                    break
                }
            }
        }
        if (A === null) {
            console.warn(&quot;Could not find a node of the right size. Please try a different page.&quot;);
            return
        }
        c();
        S();
        var O = [];
        for (var L = 0; L &lt; C.length; L++) {
            var A = C[L];
            if (v(A)) {
                O.push(A)
            }
        }
    };
})(), false);
</code></pre>

<h3 id="toc_94">修改文章链接</h3>

<p>HEXO 默认的文章链接形式为<code>domain/year/month/day/postname</code>，默认就是一个四级url，并且可能造成url过长，对搜索引擎是十分不友好的，我们可以改成<code>domain/postname</code>的形式。编辑站点<code>_config.yml</code>文件，修改其中的<code>permalink</code>字段改为<code>permalink: :title.html</code>即可。</p>

<h2 id="toc_95">七、总结</h2>

<p>每次写完博客发布都需要用到的命令<br/><br/>
<code>hexo clean</code><br/><br/>
<code>hexo g -d</code><br/><br/>
发布之前，在本地预览博客用到的命令：<br/><br/>
<code>hexo s</code><br/><br/>
同步博客需要用到的命令：<br/><br/>
<code>git add .</code><br/><br/>
<code>git commit -m &#39;comment&#39;</code><br/><br/>
<code>git push</code><br/><br/>
<code>git clone &lt;server&gt; -b &lt;branch&gt;</code><br/><br/>
<code>git pull</code>  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/04/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869331.html">
                
                  <h1>Git学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。相对于SVN来说，可能Git更符合个人开发者的习惯。而且由于GitHub开源代码平台的出色，导致很多优秀的代码都通过Git保存在其中，所以学会使用Git也是重中之重，对于一个程序员来说基本是必备的技能。所以，全面了解Git还是很有必要的。</p>

<h2 id="toc_1">Git常用操作命令</h2>

<h3 id="toc_2">远程仓库相关命令</h3>

<p>检出仓库：<code>$ git clone git://github.com/jquery/jquery.git</code><br/><br/>
查看远程仓库：<code>$ git remote -v</code><br/><br/>
添加远程仓库：<code>$ git remote add [name] [url]</code><br/><br/>
删除远程仓库：<code>$ git remote rm [name]</code><br/><br/>
修改远程仓库：<code>$ git remote set-url --push [name] [newUrl]</code><br/><br/>
拉取远程仓库：<code>$ git pull [remoteName] [localBranchName]</code><br/><br/>
推送远程仓库：<code>$ git push [remoteName] [localBranchName]</code>  </p>

<p>如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：<br/><br/>
<code>$git push origin test:master         // 提交本地test分支作为远程的master分支</code><br/><br/>
<code>$git push origin test:test              // 提交本地test分支作为远程的test分支</code>  </p>

<h3 id="toc_3">分支(branch)操作相关命令</h3>

<p>查看本地分支：<code>$ git branch</code><br/><br/>
查看远程分支：<code>$ git branch -r</code><br/><br/>
创建本地分支：<code>$ git branch [name] ----注意新分支创建后不会自动切换为当前分支</code><br/><br/>
切换分支：<code>$ git checkout [name]</code><br/><br/>
创建新分支并立即切换到新分支：<code>$ git checkout -b [name]</code><br/><br/>
删除分支：<code>$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</code><br/><br/>
合并分支：<code>$ git merge [name] ----将名称为[name]的分支与当前分支合并</code><br/><br/>
创建远程分支(本地分支push到远程)：<code>$ git push origin [name]</code><br/><br/>
删除远程分支：<code>$ git push origin :heads/[name]</code> 或 <code>$ gitpush origin :[name]</code>  </p>

<p>创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)<br/><br/>
<code>$git symbolic-ref HEAD refs/heads/[name]</code><br/><br/>
<code>$rm .git/index</code><br/><br/>
<code>$git clean -fdx</code>  </p>

<h3 id="toc_4">版本(tag)操作相关命令</h3>

<p>Tag的概念类似于branch，区别是branch是可以不断改变、Merge的而Tag不行。Tag可以认为是一个快照，一个记录点，用于记录某个commit点或分支的历史快照。Tag通常打在Master分支上，以保证代码的准确性。目前的项目开发中，当发布版本时 tag 就派上用场了。例如 v1.0.1，v1.0.2… <br/>
另外，git 提供了 tag 的增删改查一系列操作，在 tag 的使用上，可谓非常之方便。</p>

<p>查看版本：<code>$ git tag</code><br/><br/>
创建版本：<code>$ git tag [name] [commitId]</code> <br/>
创建带注释的版本：<code>$ git tag -a [name] -m [注释] [commitId]</code><br/><br/>
删除版本：<code>$ git tag -d [name]</code><br/><br/>
查看远程版本：<code>$ git tag -r</code><br/><br/>
创建远程版本(本地版本push到远程)：<code>$ git push origin [name]</code><br/><br/>
删除远程版本：<code>$ git push origin :refs/tags/[name]</code><br/><br/>
合并远程仓库的tag到本地：<code>$ git pull origin --tags</code><br/><br/>
上传本地tag到远程仓库：<code>$ git push origin --tags</code><br/><br/>
创建带注释的tag：<code>$ git tag -a [name] -m &#39;yourMessage&#39;</code>  </p>

<h3 id="toc_5">子模块(submodule)相关操作命令</h3>

<p>添加子模块：<code>$ git submodule add [url] [path]</code><br/><br/>
如：<code>$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs</code><br/><br/>
初始化子模块：<code>$ git submodule init  ----只在首次检出仓库时运行一次就行</code><br/><br/>
更新子模块：<code>$ git submodule update ----每次更新或切换分支后都需要运行一下</code><br/><br/>
删除子模块：（分4步走哦）</p>

<ul>
<li><code>$ git rm --cached [path]</code></li>
<li>编辑“.gitmodules”文件，将子模块的相关配置节点删除掉</li>
<li>编辑“ .git/config”文件，将子模块的相关配置节点删除掉</li>
<li>手动删除子模块残留的目录</li>
</ul>

<h3 id="toc_6">回退操作</h3>

<p>git checkout 还原一个代码仓库中的文件。 <code>git checkout &lt;file&gt;</code>。可以初始化到上一个add指令执行成功后的状态。</p>

<p><code>git reset &lt;last commit SHA&gt; &lt;file&gt;</code>。reset提交记录，但不修改本地工作区，从而进行新的提交。</p>

<p><code>git reset --hard HEAD^</code>。 回退到上个版本。HEAD表示当前版本，上一个版本HEAD<sup>，上上个版本HEAD<sup><sup>，上100个版本HEAD~100。</sup></sup></sup></p>

<p><code>git reset --hard &lt;commit id&gt;</code>。 回退到指定版本。</p>

<h3 id="toc_7">文件暂存</h3>

<p>当前开发者正在dev分支上进行一个新功能的开发，但是开发到一半，测试人员提了一个bug需要解决，这时候开发者通常需要创建一个bug分支来修改这个bug，但是当前dev分支并不是干净的，新功能开发到一半直接从dev上拉分支，代码是不完善的。在这种情况下，可以使用git stash指令将当前修改暂存起来，把修改前的分支作为新的bug分支，而不会带有新修改的代码。等重新切换回dev分支的时候，再把代码pop出来，继续开发。</p>

<p><code>git stash</code> 暂存代码<br/>
<code>git stash list</code> 查看当前暂存的内容<br/>
<code>git stash apply</code> 进行内容恢复,不会删除记录<br/>
<code>git stash pop</code> 进行内容恢复，会删除记录<br/>
<code>git stash drop</code> 删除记录</p>

<h3 id="toc_8">忽略一些文件、文件夹不提交</h3>

<p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如  </p>

<pre class="line-numbers"><code class="language-text">target
bin
*.db
</code></pre>

<h2 id="toc_9">Git 常用命令</h2>

<pre class="line-numbers"><code class="language-shell">git branch # 查看本地所有分支
git status # 查看当前状态 
git commit # 提交 
git branch -a # 查看所有的分支
git branch -r # 查看本地所有分支
git commit -am &quot;init&quot; # 提交并且加注释 
git remote add origin git@192.168.1.119:ndshow
git push origin master # 将文件给推到服务器上
git push -u origin master # 不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来。
git remote show origin # 显示远程库origin里的资源 
git push origin master:develop
git push origin master:hb-dev # 将本地库与服务器上的库进行关联 
git checkout --track origin/dev # 切换到远程dev分支
git branch -D master develop # 删除本地库develop
git checkout -b dev # 建立一个新的本地分支dev，并切换过去
git merge origin/dev # 将分支dev与当前分支进行合并
git checkout dev # 切换到本地dev分支
git remote show # 查看远程库
git add .
git rm 文件名(包括路径) # 从git中删除指定文件
git clone git://github.com/schacon/grit.git # 从服务器上将代码给拉下来
git config --list # 查看所有用户
git ls-files # 查看已经被提交的文件
git commit -a # 提交当前repos的所有的改变
git add [file name] # 添加一个文件到git index
git commit -v # 当你用－v参数的时候可以看commit的差异
git commit -m &quot;This is the message describing the commit&quot; # 添加commit信息
git commit -a # -a是代表add，把所有的change加到git index里然后再commit
git log # 查看日志
git reflog # 增强查看日志
git diff # 查看尚未暂存的更新
git rm a.a # 移除文件(从暂存区和工作区中删除)
git rm --cached # a.a 移除文件(只从暂存区中删除)
git commit -m &quot;remove&quot; # 移除文件(从Git中删除)
git rm -f a.a # 强行移除修改后文件(从暂存区和工作区中删除)
git diff --cached 或 $ git diff --staged # 查看尚未提交的更新
git stash push # 将文件给push到一个临时空间中
git stash pop # 将文件从临时空间pop下来
---------------------------------------------------------
git remote add origin git@github.com:username/Hello-World.git
git push origin master # 将本地项目给提交到服务器中
-----------------------------------------------------------
git pull # 本地与服务器端同步
-----------------------------------------------------------------
git push (远程仓库名) (分支名) # 将本地分支推送到服务器上去。
git push origin serverfix:awesomebranch
------------------------------------------------------------------
git fetch # 相当于是从远程获取最新版本到本地，不会自动merge
git commit -a -m &quot;log_message&quot; # (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：
git branch branch_0.1 master # 从主分支master创建branch_0.1分支
git branch -m branch_0.1 branch_1.0 # 将branch_0.1重命名为branch_1.0
git checkout branch_1.0/master # 切换到branch_1.0/master分支

-----------------------------------------------------------
mkdir WebApp
cd WebApp
git init
touch README
git add README
git commit -m &#39;first commit&#39;
git remote add origin git@github.com:daixu/WebApp.git
git push -u origin master
</code></pre>

<p><figure><img src="media/15561207869331/15713049632464.jpg" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/04/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869292.html">
                
                  <h1>EventBus 3.0的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>一直用Handler来处理应用内的通信，但是发现局限性还是太大了。EventBus是一个Android端优化的publish/subscribe消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。比如请求网络，等网络返回时通过Handler或Broadcast通知UI，两个Fragment之间需要通过Listener通信，这些需求都可以通过EventBus实现。</p>

<h2 id="toc_1">使用EventBus</h2>

<h3 id="toc_2">添加依赖库</h3>

<p><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;</code></p>

<h3 id="toc_3">注册</h3>

<p>举个例子，你需要在一个activity中注册eventbus事件，然后定义接收方法，这和Android的广播机制很像，你需要首先注册广播，然后需要编写内部类，实现接收广播，然后操作UI,在EventBus中，你同样需要这么做。</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    EventBus.getDefault().register(this);

}
@Override
protected void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
}
</code></pre>

<h3 id="toc_4">订阅者</h3>

<p>类似广播，但是有别于2.4版本，你不必再去约定OnEvent方法开头了:</p>

<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(String message){
    mText.setText(message);
}
</code></pre>

<p>该操作很简单，定义了一个hello方法，需要传入String参数，在其中操作UI操作，注意：<br/>
我们添加了注解@Subscribe，其含义为订阅者，在其内传入了threadMode，我们定义为ThreadMode.MainThread，其含义为该方法在UI线程完成，这样你就不要担心抛出异常啦。是不是很简单？</p>

<h3 id="toc_5">发布者</h3>

<p>既然你在某个地方订阅了内容，当然就会在某个地方发布消息。举个例子，你的这个activity需要http请求，而http请求你肯定是在异步线程中操作，其返回结果后，你可以这么写：</p>

<pre class="line-numbers"><code class="language-java">String json=&quot;&quot;;
EventBus.getDefault().post(json);
</code></pre>

<p>这样就OK了，你可以试下能否正常运行了！</p>

<h2 id="toc_6">原理初探</h2>

<p>你订阅了内容，所以你需要在该类注册EventBus，而你订阅的方法需要传入String,即你的接收信息为String类型，那么在post的时候，你post出去的也应该是String类型，其才会接收到消息。</p>

<h3 id="toc_7">如果你post的是对象</h3>

<p>首先你需要定义一个类似pojo类：</p>

<pre class="line-numbers"><code class="language-java">public class MessageEvent {
  public final String name;
  public final String password;
  public MessageEvent(String name,String password) {
    this.name = name;
    this.password=password;
  }
}
</code></pre>

<h3 id="toc_8">然后你post的时候：</h3>

<p><code>EventBus.getDefault().post(new MessageEvent(&quot;hello&quot;,&quot;world&quot;));</code></p>

<h3 id="toc_9">当然，你接收的方法也需要改为：</h3>

<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MainThread)
public void helloEventBus(MessageEvent message){
    mText.setText(message.name);
}
</code></pre>

<h2 id="toc_10">ThreadMode提供了四个常量：</h2>

<ul>
<li>MainThread 主线程</li>
<li>BackgroundThread 后台线程</li>
<li>Async 后台线程</li>
<li>PostThread 发送线程（默认）</li>
</ul>

<p>BackgroundThread:当事件是在UI线程发出，那么事件处理实际上是需要新建单独线程，如果是在后台线程发出，那么事件处理就在该线程。该事件处理方法应该是快速的，避免阻塞后台线程。<br/><br/>
Async：发送事件方不需要等待事件处理完毕。这种方式适用于该事件处理方法需要较长时间，例如网络请求。</p>

<h2 id="toc_11">EventBus黏性事件</h2>

<p>EventBus除了普通事件也支持粘性事件，这个有点类似广播分类中的粘性广播。本身粘性广播用的就比较少，为了方便理解成订阅在发布事件之后，但同样可以收到事件。订阅/解除订阅和普通事件一样，但是处理订阅函数有所不同，需要注解中添加<code>sticky = true</code></p>

<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MAIN,sticky = true) //在ui线程执行
    public void onDataSynEvent(DataSynEvent event) {
        Log.e(TAG, &quot;event----&gt;&quot; + event.getCount());
}
</code></pre>

<h3 id="toc_12">发送粘性事件</h3>

<p><code>EventBus.getDefault().postSticky(new DataSynEvent());</code>  </p>

<h3 id="toc_13">对于粘性广播我们都比较清楚属于常驻广播，对于EventBus粘性事件也类似，我们如果不再需要该粘性事件我们可以移除</h3>

<p><code>EventBus.getDefault().removeStickyEvent(new DataSynEvent());</code>  </p>

<h3 id="toc_14">或者调用移除所有粘性事件</h3>

<p><code>EventBus.getDefault().removeAllStickyEvents();</code>  </p>

<p>默认情况下，其为false。什么情况下使用sticky呢？<br/><br/>
当你希望你的事件不被马上处理的时候，举个栗子，比如说，在一个详情页点赞之后，产生一个VoteEvent，VoteEvent并不立即被消费，而是等用户退出详情页回到商品列表之后，接收到该事件，然后刷新Adapter等。其实这就是之前我们用startActivityForResult和onActivityResult做的事情。  </p>

<h2 id="toc_15">订阅事件的优先级</h2>

<p>事件的优先级类似广播的优先级，优先级越高优先获得消息</p>

<pre class="line-numbers"><code class="language-java">@Subscribe(threadMode = ThreadMode.MAIN,priority = 100) //在ui线程执行 优先级100
    public void onDataSynEvent(DataSynEvent event) {
        Log.e(TAG, &quot;event----&gt;&quot; + event.getCount());
}
</code></pre>

<h2 id="toc_16">终止事件往下传递</h2>

<p>发送有序广播可以终止广播的继续往下传递，EventBus也实现了此功能<br/>
<code>EventBus.getDefault().cancelEventDelivery(event) ;//优先级高的订阅者可以终止事件往下传递</code></p>

<h2 id="toc_17">建议</h2>

<p>推荐大家在使用EventBus的时候，创建一个事件类，把你的每一个参数（或者可能发生冲突的参数），封装成一个类：</p>

<pre class="line-numbers"><code class="language-java">public class Event  {  
    public static class UserListEvent {  
        public List&lt;User&gt; users ;  
    }
    public static class ItemListEvent {  
        public List&lt;Item&gt; items;  
    }    
}
</code></pre>

<h2 id="toc_18">processor使用</h2>

<p>按照Markus Junginger的说法（EventBus创作者），在3.0中，如果你想进一步提升你的app的性能.<br/>
EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe()注解并解析,处理其中所包含的信息,然后生成java类来保存所有订阅者关于订阅的信息,这样就比在运行时使用反射来获得这些订阅者的信息速度要快.<br/><br/>
其在编译的时候为注册类构建了一个索引，而不是在运行时，这样的结果是其让EventBus 3.0的性能提升了一倍，相比2.4来说，其会是它的3到6倍。大家可以感受下：<br/><br/>
<figure><img src="media/15561207869292/15713067794323.jpg" alt=""/></figure></p>

<h3 id="toc_19">具体使用：在build.gradle中添加如下配置</h3>

<pre class="line-numbers"><code class="language-text">buildscript {
    dependencies {
        classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.8&#39;
    }
}
apply plugin: &#39;com.neenbedankt.android-apt&#39;

dependencies {
    compile &#39;org.greenrobot:eventbus:3.0.0&#39;
    apt &#39;org.greenrobot:eventbus-annotation-processor:3.0.1&#39;
}
apt {
    arguments {
        eventBusIndex &quot;com.whoislcj.eventbus.MyEventBusIndex&quot;
    }
}
</code></pre>

<h3 id="toc_20">使用索引</h3>

<p>此时编译一次，自动生成生成索引类。在\build\generated\source\apt\PakageName\下看到通过注解分析生成的索引类，这样我们便可以在初始化EventBus时应用我们生成的索引了。自动生成的代码。</p>

<pre class="line-numbers"><code class="language-java">/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();

        putIndex(new SimpleSubscriberInfo(com.whoislcj.testhttp.MainActivity.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo(&quot;onDataSynEvent&quot;, com.whoislcj.testhttp.eventBus.DataSynEvent.class,
                    ThreadMode.MAIN, 100, false),
            new SubscriberMethodInfo(&quot;onDataSynEvent1&quot;, com.whoislcj.testhttp.eventBus.TestEvent.class, ThreadMode.MAIN,
                    0, true),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    @Override
    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
</code></pre>

<p>添加索引到EventBus默认的单例中<br/><br/>
<code>EventBus.builder().addIndex(new MyEventBusIndex()).installDefaultEventBus();</code>  </p>

<h3 id="toc_21">对比添加前后注册效率对比</h3>

<p>分别EventBus.getDefault().register(this);</p>

<ul>
<li>添加之前：前后用了9毫秒</li>
<li>添加之后：前后用了2毫秒</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/04/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869255.html">
                
                  <h1>GreenDao3.2.0的使用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>我相信，在平时的开发过程中，大家一定会或多或少地接触到SQLite。然而在使用它时，我们往往需要做许多额外的工作，像编写 SQL语句与解析查询结果等。所以，适用于Android ORM框架也就孕育而生了，现在市面上主流的框架有OrmLite、SugarORM、Active Android、Realm与greenDAO。但是使用数量最多的还是Realm与greenDAO，所以为了目前的项目需要写个文档记录一下greenDAO的使用。简单的讲，greenDAO是一个将对象映射到SQLite 数据库中的轻量且快速的ORM解决方案。（greenDAO is a light &amp; fast ORM solution that maps objects to SQLite databases.）。</p>

<p><figure><img src="media/15561207869255/15713066502027.jpg" alt=""/></figure></p>

<p>这个图对于理解greenDAO是必不可少的。</p>

<h2 id="toc_1">greenDAO特点</h2>

<ul>
<li>性能最大化，可能是Android平台上最快的ORM框架</li>
<li>易于使用的API</li>
<li>最小的内存开销</li>
<li>依赖体积小</li>
<li>支持数据库加密</li>
<li>强大的社区支持</li>
</ul>

<h2 id="toc_2">配置greenDAO</h2>

<h3 id="toc_3">在<code>app</code>的Gradle中配置：</h3>

<p><code>apply plugin: &#39;org.greenrobot.greendao&#39;</code>  </p>

<pre class="line-numbers"><code class="language-text">dependencies {
        compile &#39;org.greenrobot:greendao:3.2.0&#39;
}
</code></pre>

<h3 id="toc_4">在<code>project</code>的Gradle中配置：</h3>

<pre class="line-numbers"><code class="language-text">buildscript {
    repositories {
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath &#39;org.greenrobot:greendao-gradle-plugin:3.2.1&#39; 
    }
}
</code></pre>

<h3 id="toc_5">在app的Gradle配置数据库版本等信息</h3>

<pre class="line-numbers"><code class="language-text">greendao {
    schemaVersion 1                         //对应当前数据库版本c
    daoPackage &#39;com.koma.greendao.gen&#39;  //由GreenDao自动生成代码所在的包名，默认的是在项目包下面新建一个gen。
    targetGenDir &#39;src/main/java&#39;        //设置自动生成代码的目录
}
</code></pre>

<h2 id="toc_6">使用greenDAO</h2>

<h3 id="toc_7">使用流程</h3>

<p>在项目中新建一个表字段的实体类，不需要自己写get和set方法，在生成表的时候会自动生成。不要忘了在类名上标记@Entity注解如图：   </p>

<p><figure><img src="media/15561207869255/15713066625628.jpg" alt=""/></figure></p>

<p>选择build ——Make Project 一切顺利的话则会在包名下生成数据库的操作类，如下图：  </p>

<p><figure><img src="media/15561207869255/15713066721049.jpg" alt=""/></figure></p>

<p>Ps:新建一个实体类，对项目进行<code>Make Project</code>，成功之后会在daoPackage目录下自动生成代码</p>

<h3 id="toc_8">在项目中定义实体类</h3>

<pre class="line-numbers"><code class="language-java">@Entity
public class User  {
    @Id(autoincrement = true)
    private Long id;
    @Property(nameInDb = &quot;USERNAME&quot;)
    private String name;
    private int age;
}
</code></pre>

<h3 id="toc_9">注解：</h3>

<ul>
<li>@Entity——————————标识实体类，greenDAO会映射成sqlite的一个表，表名为实体类名的大写形式
<ul>
<li>schema：告知GreenDao当前实体属于哪个schema</li>
<li>active：标记一个实体处于活跃状态，活动实体有更新、删除和刷新方法</li>
<li>nameInDb：在数据库中使用的别名，默认使用的是实体的类名</li>
<li>indexes：定义索引，可以跨越多个列</li>
<li>createInDb：标记创建数据库表</li>
</ul></li>
<li>基础属性注解
<ul>
<li>@Id——————————标识主键，该字段的类型为long或Long类型，autoincrement设置是否自动增长</li>
<li>@Property——————————标识该属性在表中对应的列名称, nameInDb设置名称</li>
<li>@Transient——————————标识该属性将不会映射到表中，也就是没有这列</li>
<li>@NotNull——————————设置表中当前列的值不可为空</li>
</ul></li>
<li>索引注解
<ul>
<li>@Unique——————————向数据库列添加了一个唯一的约束</li>
<li>@Index——————————使用@Index作为一个属性来创建一个索引；定义多列索引(@link Entity#indexes())</li>
</ul></li>
<li>关系注解
<ul>
<li>@ToMany——————————定义与多个实体对象的关系</li>
<li>@ToOne——————————定义与另一个实体（一个实体对象）的关系</li>
</ul></li>
<li>@Convert——————————指定自定义类型(@linkPropertyConverter)</li>
<li>@Generated——————————greenDAO运行所产生的构造函数或者方法，被此标注的代码可以变更或者下次运行时清除</li>
<li>@JoinEntity——————————定义表连接关系</li>
<li>@JoinProperty——————————定义名称和引用名称属性关系</li>
<li>@Keep——————————注解的代码段在GreenDao下次运行时保持不变
<ul>
<li>注解实体类：默认禁止修改此类</li>
<li>注解其他代码段，默认禁止修改注解的代码段</li>
</ul></li>
<li>@OrderBy——————————指定排序</li>
</ul>

<h3 id="toc_10">初始化GreenDao</h3>

<p>一般建议在Application中初始化数据库  </p>

<pre class="line-numbers"><code class="language-java">private void setupDataBase(Context context){
    DaoMaster.DevOpenHelper openHelper = new DaoMaster.DevOpenHelper(context,DATA_BASE_NAME);
    Database db = openHelper.getWritableDb();
    DaoMaster daoMaster = new DaoMaster(db);
    mDaoSession = daoMaster.new Session();
}

public static DaoSession getDaoSession(){
    return mDaoSession;
}
</code></pre>

<p><code>DevOpenHelper</code>有两个重载方法：  </p>

<ul>
<li><code>DevOpenHelper(Context context,String name)</code></li>
<li><code>DevOpenHelper(Context context,String name,CursorFactory factory)</code>
<code>context</code>上下文这个不用多说，<code>name</code>数据库的名字，<code>cursorFactory</code>游标工厂，一般不用，传入null或者使用两个参数的方法即可。我们对外提供一个getDaoSession()的方法供外部使用。</li>
</ul>

<h3 id="toc_11">对数据库的增、删、改、查操作</h3>

<h4 id="toc_12">首先获得UserDao的对象</h4>

<p><code>UserDao userDao = GreenDaoManager.getInstance().getNewSession().getUserDao();</code></p>

<h4 id="toc_13">增：</h4>

<pre class="line-numbers"><code class="language-java">User user = new User(null, name, age, studentId);
userDao.insert(user);
insert(T entity)       当指定主键在表中存在时会发生异常
insertOrReplace(T entity)      当指定主键在表中存在时会覆盖数据
insertInTx(Iterable&lt;T&gt; entities)      批量插入数据
</code></pre>

<h4 id="toc_14">删：</h4>

<pre class="line-numbers"><code class="language-java">User user = new User(null, name, age, studentId);    
userDao.delete(user)
 
delete(T entity)       删除数据
deleteByKey(K key)     指定主键删除数据
deleteInTx(Iterable&lt;T&gt; entities)      批量删除数据
deleteByKeyInTx(Iterable&lt;K&gt; keys)      批量按数据删除数据        
deleteAll()    删除所有数据
</code></pre>

<h4 id="toc_15">改：</h4>

<pre class="line-numbers"><code class="language-java">User user = new User(id, name, age, studentId);
userDao.update(user);
 
update(T entity)       修改数据，主键需相同
updateInTx(Iterable&lt;T&gt; entities)      批量更新数据
</code></pre>

<h4 id="toc_16">查：</h4>

<pre class="line-numbers"><code class="language-java">userDao.load(id)
 
load(K key)    根据id查找数据
loadByRowId(long rowId)        根据行号查找数据
loadAll()      查找全部数据
</code></pre>

<h5 id="toc_17">查询功能</h5>

<p>GreeDAO提供了各种各种的查询API，参见<a href="http://greenrobot.org/greendao/documentation/queries/">http://greenrobot.org/greendao/documentation/queries/</a>  </p>

<p><figure><img src="media/15561207869255/15713066831882.jpg" alt=""/></figure></p>

<p>如果需要在控制台查看GreenDao是怎么拼装SQL语句的，在OnCreate()方法中打开下面的开关：<br/><br/>
<figure><img src="media/15561207869255/15713066943832.jpg" alt=""/></figure></p>

<h5 id="toc_18">条件查询</h5>

<pre class="line-numbers"><code class="language-java">//查询所有数据  
public void queryAll() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().list();  
}  
  
//eq: equal 精确查询  名字等于jackie  
public void queryEq() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.eq(&quot;jackie&quot;)).unique();  
}  
  
//notEq: not equal 精确查询  名字不等于jackie  
public void queryNotEq() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.notEq(&quot;jackie&quot;)).unique();  
}  
  
//like  模糊查询  名字以jackie开头  
public void queryLike() {  
    Person person = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie&quot;)).unique();  
    //通配符  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).list();  
}  
  
//between 区间查询 年龄在20到30之间  
public void queryBetween() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.between(20, 30)).list();  
}  
  
//gt: greater than 半开区间查询，年龄大于18  
public void queryGt() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.gt(18)).list();  
}  
  
//ge: greater equal 半封闭区间查询，年龄大于或者等于18  
public void queryGe() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.ge(18)).list();  
}  
  
//lt: less than 半开区间查询，年龄小于18  
public void queryLt() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.lt(18)).list();  
}  
  
//le: less equal 半封闭区间查询，年龄小于或者等于18  
public void queryLe() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Age.le(18)).list();  
}  
  
//名字以jackie开头，年龄升序排序  
public void queryLikeAsc() {  
    //通配符  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).orderAsc(PersonDao.Properties.Age).list();  
}  
  
//名字以jackie开头，年龄降序排序  
public void queryLikeDesc() {  
    List&lt;Person&gt; persons = mPersonDao.queryBuilder().where(PersonDao.Properties.Name.like(&quot;jackie%&quot;)).orderDesc(PersonDao.Properties.Age).list();  
}  
</code></pre>

<p>当上述查询满足不了业务逻辑时，可以自定义查询语句：   </p>

<p><figure><img src="media/15561207869255/15713067068458.jpg" alt=""/></figure></p>

<h5 id="toc_19">多线程查询</h5>

<p>首先来看错误的方法：<br/><br/>
<figure><img src="media/15561207869255/15713067155848.jpg" alt=""/></figure></p>

<p>错误截图：<br/><br/>
<figure><img src="media/15561207869255/15713067289369.jpg" alt=""/></figure> </p>

<p>从上面可以看出，只能在创建Query对象的线程中调用查询方法！<br/><br/>
解决方法：<br/><br/>
<figure><img src="media/15561207869255/15713067386987.jpg" alt=""/></figure></p>

<h5 id="toc_20">一对一查询</h5>

<p><figure><img src="media/15561207869255/15713067480106.jpg" alt=""/></figure></p>

<h4 id="toc_21">一对一、一对多关系</h4>

<p>greenDAO目前只支持一对一和一对多关系，并不支持多对多关系  </p>

<h5 id="toc_22">一对一：</h5>

<pre class="line-numbers"><code class="language-java">private Long studentId;
@ToOne(joinProperty = &quot;studentId&quot;)
private Studentstudent;
</code></pre>

<pre class="line-numbers"><code class="language-java">@Generated(hash = 313494093)
public Student getStudent() {
    Long __key = this.studentId;
    if (student__resolvedKey == null || !student__resolvedKey.equals(__key)) {
        final DaoSession daoSession = this.daoSession;
        if (daoSession == null) {
            throw new DaoException(&quot;Entity is detached from DAO context&quot;);
        }
        StudentDao targetDao = daoSession.getStudentDao();
        Student studentNew = targetDao.load(__key);
        synchronized (this) {
            student = studentNew;
            student__resolvedKey = __key;
        }
    }
    return student;
}
</code></pre>

<p>使用<code>@ToOne</code>标记，<code>joinProperty</code>指定一个字段，如果没有定义，会自动生成一个字段，<code>get</code>方法时自动生成的，使用<code>@Generated</code>标记，代表自动生成的，无需动代码。</p>

<h5 id="toc_23">一对多（有三种映射形式）</h5>

<pre class="line-numbers"><code class="language-java">@ToMany(referencedJoinProperty = &quot;teacherId&quot;)
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p><code>referencedJoinProperty</code>：指定目标实体中与源实体相对应的外键。</p>

<pre class="line-numbers"><code class="language-java">@ToMany(joinProperties = {
        @JoinProperty(name=&quot;studentTag&quot;,referencedName = &quot;teacherTag&quot;)
})
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p><code>JoinProperty</code>: 对于复杂一点的关系可以定义一组<code>@JoinProperty</code>注解。每个<code>@JoinProperty</code>注解都需要有源实体中的源属性和对应实体中的引用属性。</p>

<pre class="line-numbers"><code class="language-java">@ToMany
@JoinEntity(
        entity = Teacher.class,
        sourceProperty = &quot;teacherId&quot;,
        targetProperty = &quot;id&quot;
)
private List&lt;Teacher&gt; teacherList;
</code></pre>

<p>@JoinEntity：在做NM多对多映射的时候使用</p>

<h4 id="toc_24">数据库的升级</h4>

<p>数据库升级最麻烦的就是数据保存的问题，下面是数据库升级时执行的代码。</p>

<pre class="line-numbers"><code class="language-java">/** WARNING: Drops all table on Upgrade! Use only during development. */
public static class DevOpenHelper extends OpenHelper {
    public DevOpenHelper(Context context, String name) {
        super(context, name);
    }

    public DevOpenHelper(Context context, String name, CursorFactory factory) {
        super(context, name, factory);
    }

    @Override
    public void onUpgrade(Database db, int oldVersion, int newVersion) {
        Log.i(&quot;greenDAO&quot;, &quot;Upgrading schema from version &quot; + oldVersion + &quot; to &quot; + newVersion + &quot; by dropping all tables&quot;);
        dropAllTables(db, true);
        onCreate(db);
    }
}
</code></pre>

<p>第一句注释的话已经告诉我们数据库升级时会删除所有的表，重新创建。所以我们可以自定义一个类继承<code>OpenHelper</code>，在升级时先生成临时表，删除旧表创建新表后，再把临时表的数据导入进去。有牛人已经做出这个项目来了，我就厚颜无耻选择直接用了。</p>

<h5 id="toc_25">在project的gradle添加</h5>

<pre class="line-numbers"><code class="language-java">allprojects {
    repositories {
        jcenter()
        maven { url &quot;https://jitpack.io&quot; }
    }
}
</code></pre>

<h5 id="toc_26">在app的gradle添加：</h5>

<p><code>compile &#39;com.github.yuweiguocn:GreenDaoUpgradeHelper:v1.3.0&#39;</code></p>

<h5 id="toc_27">新建一个类</h5>

<pre class="line-numbers"><code class="language-java">public class MySQLiteOpenHelper extends DaoMaster.OpenHelper{
    public MySQLiteOpenHelper(Contextcontext,Stringname){
        super(context,name);
    }
    public MySQLiteOpenHelper(Contextcontext,String name,SQLiteDatabase.CursorFactoryfactory) {
        super(context,name,factory);
    }
    @Override
    public void onUpgrade(SQLiteDatabasedb,int oldVersion,intnewVersion) {
        Log.d(&quot;SQLite&quot;,&quot;数据库从&quot;+oldVersion+&quot;升级到&quot;+newVersion);
        MigrationHelper.migrate(db,UserDao.class,StudentDao.class);
    }
}
</code></pre>

<p>使用时直接用MySQLiteOpenHelper代替DaoMaster.OpenHelper。</p>

<h2 id="toc_28">实战</h2>

<p>下面就以购物车的实战来使用GreenDao，这里的购物车展示图如下<br/><br/>
<figure><img src="media/15561207869255/15713067603164.jpg" alt=""/></figure></p>

<p>我们所知道的数据库操作需要：数据库名、表名、字段名，缺一不可，下面就是这三项的创建  </p>

<h3 id="toc_29">一、创建Bean对象（表名和字段名）</h3>

<p>GreenDao需要创建Bean对象之后，该Bean对象就是表名，而它的属性值就是字段名，其 实现是通过注释的方式来实现的，下面是购物车的Bean对象（每个Bean对象对应一张表）  </p>

<pre class="line-numbers"><code class="language-java">@Entity
public class Shop{

    //表示为购物车列表
    public static final int TYPE_CART = 0x01;
    //表示为收藏列表
    public static final int TYPE_LOVE = 0x02;

    //不能用int
    @Id(autoincrement = true)
    private Long id;
    //商品名称
    @Unique
    private String name;
    //商品价格
    @Property(nameInDb = &quot;price&quot;)
    private String price;
    //已售数量
    private int sell_num;
    //图标url
    private String image_url;
    //商家地址
    private String address;
    //商品列表类型
    private int type;
}
</code></pre>

<p>之后进行<code>Make Project</code> <br/>
生成<code>Bean</code>实体的构造方法和<code>get</code>、<code>set</code>方法和<code>DaoMaster</code>、<code>DaoSession</code>、<code>DAOS</code>类</p>

<h3 id="toc_30">二、创建数据库</h3>

<pre class="line-numbers"><code class="language-java">public class BaseApplication extends Application {

    private static DaoSession daoSession;

    @Override
    public void onCreate() {
        super.onCreate();
        //配置数据库
        setupDatabase();
    }

    /**
     * 配置数据库
     */
    private void setupDatabase() {
        //创建数据库shop.db&quot;
        DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;shop.db&quot;, null);
        //获取可写数据库
        SQLiteDatabase db = helper.getWritableDatabase();
        //获取数据库对象
        DaoMaster daoMaster = new DaoMaster(db);
        //获取Dao对象管理者
        daoSession = daoMaster.newSession();
    }

    public static DaoSession getDaoInstant() {
        return daoSession;
    }
}
</code></pre>

<p>GreenDao已经将我们的数据库创建缩成几句话，代码会自动将Bean对象创建成表，不再是传统的手写SQL语句。这里的数据库创建只需要在Application中执行一次即可，这里对几个类进行解释  </p>

<ul>
<li><code>DevOpenHelper</code>：创建SQLite数据库的SQLiteOpenHelper的具体实现</li>
<li><code>DaoMaster</code>：GreenDao的顶级对象，作为数据库对象、用于创建表和删除表</li>
<li><code>DaoSession</code>：管理所有的Dao对象，Dao对象中存在着增删改查等API</li>
</ul>

<p>由于我们已经创建好了DaoSession和Shop的Bean对象，编译后会自动生成我们的ShopDao对象，可通过DaoSession获得<br/><br/>
<code>ShopDao dao = daoSession.getShopDao();</code><br/><br/>
这里的Dao（Data Access Object）是指数据访问接口，即提供了数据库操作一些API接口，可通过dao进行增删改查操作。</p>

<h3 id="toc_31">三、数据库的增删改查</h3>

<pre class="line-numbers"><code class="language-java">public class LoveDao {

    /**
     * 添加数据，如果有重复则覆盖
     *
     * @param shop
     */
    public static void insertLove(Shop shop) {
        BaseApplication.getDaoInstant().getShopDao().insertOrReplace(shop);
    }

    /**
     * 删除数据
     *
     * @param id
     */
    public static void deleteLove(long id) {
        BaseApplication.getDaoInstant().getShopDao().deleteByKey(id);
    }

    /**
     * 更新数据
     *
     * @param shop
     */
    public static void updateLove(Shop shop) {
        BaseApplication.getDaoInstant().getShopDao().update(shop);
    }

    /**
     * 查询条件为Type=TYPE_LOVE的数据
     *
     * @return
     */
    public static List&lt;Shop&gt; queryLove() {
        return BaseApplication.getDaoInstant().getShopDao().queryBuilder().where(ShopDao.Properties.Type.eq(Shop.TYPE_LOVE)).list();
    }

    /**
     * 查询全部数据
     */
    public static List&lt;Shop&gt; queryAll() {
        return BaseApplication.getDaoInstant().getShopDao().loadAll();
    }
}
</code></pre>

<p>GreenDao的封装更加短小精悍，语义明朗，下面对GreenDao中Dao对象其他API的介绍  </p>

<ul>
<li>增加单个数据
<ul>
<li><code>getShopDao().insert(shop);</code></li>
<li><code>getShopDao().insertOrReplace(shop);</code></li>
</ul></li>
<li>增加多个数据
<ul>
<li><code>getShopDao().insertInTx(shopList);</code></li>
<li><code>getShopDao().insertOrReplaceInTx(shopList);</code></li>
</ul></li>
<li>查询全部
<ul>
<li><code>List&lt; Shop&gt; list = getShopDao().loadAll();</code></li>
<li><code>List&lt; Shop&gt; list = getShopDao().queryBuilder().list();</code></li>
</ul></li>
<li>查询附加单个条件
<ul>
<li><code>.where()</code></li>
<li><code>.whereOr()</code></li>
</ul></li>
<li>查询附加多个条件
<ul>
<li><code>.where(, , ,)</code></li>
<li><code>.whereOr(, , ,)</code></li>
</ul></li>
<li>查询附加排序
<ul>
<li><code>.orderDesc()</code></li>
<li><code>.orderAsc()</code></li>
</ul></li>
<li>查询限制当页个数
<ul>
<li><code>.limit()</code></li>
</ul></li>
<li>查询总个数
<ul>
<li><code>.count()</code></li>
</ul></li>
<li>修改单个数据
<ul>
<li><code>getShopDao().update(shop);</code></li>
</ul></li>
<li>修改多个数据
<ul>
<li><code>getShopDao().updateInTx(shopList);</code></li>
</ul></li>
<li>删除单个数据
<ul>
<li><code>getTABUserDao().delete(user);</code></li>
</ul></li>
<li>删除多个数据
<ul>
<li><code>getUserDao().deleteInTx(userList);</code></li>
</ul></li>
<li>删除数据ByKey
<ul>
<li><code>getTABUserDao().deleteByKey();</code></li>
</ul></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/03/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207869218.html">
                
                  <h1>Python学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>由于写毕设要搭建后端爬虫的需求，所以开始学习Python语言。由于没有系统的学习，所以笔记可能会记得比较散乱，有时间会一一整理，把一些重要的学习知识点记下来。当然有时间也会整理基础知识。</p>

<h2 id="toc_1">安装 Python</h2>

<h3 id="toc_2">升级pip</h3>

<p><code>pip3 install --upgrade pip</code></p>

<h2 id="toc_3">安装 Python 虚拟环境</h2>

<p><code>(sudo) pip3 install virtualenv virtualenvwrapper</code>  </p>

<p>修改<code>~/.bash_profile</code>,添加以下语句  </p>

<pre class="line-numbers"><code class="language-text">export WORKON_HOME=$HOME/.virtualenvs
export PROJECT_HOME=$HOME/workspace
source /usr/local/bin/virtualenvwrapper.sh
</code></pre>

<p>修改后使之立即生效(也可以重启终端使之生效)：<br/><br/>
<code>source ~/.bash_profile</code>  </p>

<h3 id="toc_4">基本用法</h3>

<h4 id="toc_5">1、创建一个虚拟开发环境</h4>

<p><code>mkvirtualenv zqxt：创建运行环境zqxt</code><br/><br/>
<code>workon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境</code><br/><br/>
<code>deactivate: 退出终端环境</code><br/><br/>
其它的： <br/>
<code>rmvirtualenv ENV：删除运行环境ENV</code><br/><br/>
<code>mkproject mic：创建mic项目和运行环境mic</code><br/><br/>
<code>mktmpenv：创建临时运行环境</code><br/><br/>
<code>lsvirtualenv: 列出可用的运行环境</code><br/><br/>
<code>lssitepackages: 列出当前环境安装了的包</code><br/><br/>
创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。  </p>

<p>完成后在当前目录会创建一个test_env的文件夹，进入文件夹会发现生成了以下的目录，神奇吧  </p>

<pre class="line-numbers"><code class="language-text">├── bin
├── include
│   └── python2.7
├── lib
│   └── python2.7       //所有的新包会被存在这
│       ├── distutils
│       ├── encodings
│       ├── lib-dynload
│       └── site-packages
├── local
│   ├── bin
│   ├── include
│   └── lib
</code></pre>

<h2 id="toc_6">安装Django</h2>

<p><code>pip3 install Django</code>或者<code>pip install Django==1.10.6</code><br/><br/>
在终端上输入Python,点击Enter,进入Python环境</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; import django
&gt;&gt;&gt; django.VERSION
(1, 8, 16, &#39;final&#39;, 0)
&gt;&gt;&gt; 
&gt;&gt;&gt; django.get_version()
&#39;1.8.16&#39;
</code></pre>

<p>这样就可以看见安装的django的版本号</p>

<h3 id="toc_7">安装django-Celery，设置调度计划任务</h3>

<p><code>pip3 install django-celery</code></p>

<h3 id="toc_8">安装PIL（Python Imaging Library）</h3>

<p>图片处理的扩展包:<br/>
<code>brew install jpeg    #安装</code></p>

<h3 id="toc_9">安装Django-Dynamic-Scraper(DDS)</h3>

<p><code>pip3 install django-dynamic-scraper</code><br/><br/>
<code>pip3 install scrapy-splash</code><br/>
<code>pip3 install scrapy-djangoitem</code></p>

<h2 id="toc_10">安装scrapy</h2>

<p><code>pip3 install Scrapy 安装Scrapy</code>或者<code>pip3 install scrapy==1.3.3</code>  </p>

<h2 id="toc_11">安装chardet-检测网页编码</h2>

<p><code>pip3 install chardet  #安装chardet</code>  </p>

<pre class="line-numbers"><code class="language-python">def GetHtml( url):  
    page = urllib.request.urlopen(url)  
    contex = page.read()  
    return contex  

print(sys.getfilesystemencoding())    #本地系统编码
print(&#39;Html is encoding by : %&#39;,chardet.detect(GetHtml(url))) #网页编码
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/03/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python.html'>Python</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_15.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_17.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16145671673295.html">多态</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
