<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Mac安装配置appium - MagicalRice的Blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">MagicalRice的Blog</a></h1>
					<p class="subtitle">技术博客</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">Mac安装配置appium</h1>
		<div class="entry-content" itemprop="articleBody">
			<h2 id="toc_0">前言</h2>

<p>因为公司需求，需要安装Appium来实现对手机APP的自动化测试，提升工作效率。所以来学习并记录一下Appium的安装以及使用的步骤，方便自己以后对App测试环境搭建的操作。</p>

<h2 id="toc_1">一、安装Appium</h2>

<h3 id="toc_2">(二) 安装Homebrew</h3>

<ul>
<li><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;  #下载</code></li>
<li><code>$ brew update #更新</code></li>
<li><code>$ brew -v #查看是否安装好，以及其版本号</code></li>
</ul>

<h3 id="toc_3">(三) 安装Node.js</h3>

<p>使用homebrew来安装Node.js </p>

<ul>
<li><code>$ brew install node #安装</code></li>
<li><code>$ node -v #查看是否安装好，以及其版本号</code></li>
</ul>

<h3 id="toc_4">(四) 安装npm</h3>

<ul>
<li><code>$ brew install npm</code></li>
</ul>

<h3 id="toc_5">(五) 安装appium服务端</h3>

<p>推荐使用cnpm来安装：<a href="https://npm.taobao.org/">淘宝 NPM 镜像</a> 10分钟同步npmjs.org镜像，使用方式和npm完全一致</p>

<ul>
<li><code>$ npm install cnpm -g --registry=https://registry.npm.taobao.org</code></li>
<li><code>$ npm view appium versions #查看appium所有的版本号</code></li>
<li><code>$ cnpm install -g appium --no-cache $ cnpm install -g appium $ cnpm install -g appium-doctor</code></li>
</ul>

<h3 id="toc_6">(六) 检查appium环境检测</h3>

<p>在环境监测中打叉的就是没安装成功或者环境没有配置完全的</p>

<ul>
<li><code>appium-doctor</code></li>
</ul>

<h4 id="toc_7">1、appium环境常见问题解决</h4>

<h5 id="toc_8">(1) Xcode Command Line Tools are NOT installed!</h5>

<pre class="line-numbers"><code class="language-text">- `xcode-select --install   #按照提示安装即可`
</code></pre>

<h5 id="toc_9">(2) Carthage was NOT found</h5>

<pre class="line-numbers"><code class="language-text">- `$ brew install carthage       #carthage：类似cocoapods管理第三方代码，自动将工程编译为动态库，所以仅支持iOS8以上`
</code></pre>

<h5 id="toc_10">(3) ANDROID_HOME is NOT set!</h5>

<pre class="line-numbers"><code class="language-text">- 使用最新版本Java
- 修改Mac的开发环境
- `vi .bash_profile`
- `export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk(版本记得改)/Contents/Home`
- `export ANDROID_HOME=/Users/YourMacName/Library/Android/sdk`
- `export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:${JAVA_HOME}/bin`
- 修改完配置文件记得保存退出，然后`source .bash_profile`
- 如果有问题记得修改在终端的Shall打开方式，调整为命令
</code></pre>

<h3 id="toc_11">(七) 安装appium客户端（Python为例）</h3>

<ul>
<li><code>brew search python   #查看可安装的python版本</code></li>
<li><code>brew install python3     #安装python3</code></li>
<li><code>pip install Appium-Python-Client   #安装python客户端</code>  </li>
</ul>

<h3 id="toc_12">(八) 安装支持iOS测试的插件</h3>

<ul>
<li><code>$ brew install libimobiledevice --HEAD  # install from HEAD to get important updates</code></li>
<li><code>$ brew install ideviceinstaller         # 只是对iOS9有用</code></li>
<li><code>$ npm install -g ios-deploy                # iOS10 以后的版本安装ios-deploy</code></li>
<li><code>$ sudo gem install xcpretty            # 真机需要安装 xcpretty</code></li>
</ul>

<h2 id="toc_13">二、Appium测试</h2>

<h3 id="toc_14">(一) iOS模拟器测试</h3>

<ul>
<li><code>xcodebuild -sdk iphonesimulator   #在xcodeproj项目工程目录下执行，编译生成build文件夹，并在其中生成app文件</code></li>
<li><code>npm install -g authorize-ios   #安装iOS模拟器启动器</code> </li>
<li><code>sudo authorize-ios   #启动iOS模拟器</code> </li>
<li><code>appium &amp;    #启动appium服务器</code> </li>
<li><code>python ***.py     #另开一个终端执行python脚本</code> </li>
<li>iOS模拟器自动开启，安装应用并开始执行测试脚本</li>
</ul>

<h3 id="toc_15">(二) Android模拟器测试</h3>

<ul>
<li><code>appium -a 127.0.0.1 -p 4723 -U db3489d --no-reset</code></li>
</ul>

<h2 id="toc_16">三、Appium命令</h2>

<h3 id="toc_17">(一) 服务端启动命令</h3>

<p><strong>服务器标志</strong><br/>
所有的标志都是可选的，但是有一些标志需要组合在一起才能生效。</p>

<table>
<thead>
<tr>
<th>标志</th>
<th>默认值</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>

<tbody>
<tr>
<td>--shell</td>
<td>null</td>
<td>进入 REPL 模式</td>
<td></td>
</tr>
<tr>
<td>--localizable-strings-dir</td>
<td>en.lproj</td>
<td>IOS only: 定位 .strings所在目录的相对路径</td>
<td>--localizable-strings-dir en.lproj</td>
</tr>
<tr>
<td>--app</td>
<td>null</td>
<td>iOS: 基于模拟器编译的 app 的绝对路径或者设备目标的 bundle_id； Android: apk 文件的绝对路径--app /abs/path/to/my.app</td>
<td></td>
</tr>
<tr>
<td>--ipa</td>
<td>null</td>
<td>(IOS-only) .ipa 文件的绝对路径</td>
<td>--ipa /abs/path/to/my.ipa</td>
</tr>
<tr>
<td>-U, --udid</td>
<td>null</td>
<td>连接物理设备的唯一设备标识符</td>
<td>--udid 1adsf-sdfas-asdf-123sdf</td>
</tr>
<tr>
<td>-a, --address</td>
<td>0.0.0.0</td>
<td>监听的 ip 地址</td>
<td>--address 0.0.0.0</td>
</tr>
<tr>
<td>-p, --port</td>
<td>4723</td>
<td>监听的端口</td>
<td>--port 4723</td>
</tr>
<tr>
<td>-ca, --callback-address</td>
<td>null</td>
<td>回调IP地址 (默认: 相同的IP地址)</td>
<td>--callback-address 127.0.0.1</td>
</tr>
<tr>
<td>-cp, --callback-port</td>
<td>null</td>
<td>回调端口号 (默认: 相同的端口号)</td>
<td>--callback-port 4723</td>
</tr>
<tr>
<td>-bp, --bootstrap-port</td>
<td>4724</td>
<td>(Android-only) 连接设备的端口号</td>
<td>--bootstrap-port 4724</td>
</tr>
<tr>
<td>-k, --keep-artifacts</td>
<td>false</td>
<td>弃用，无效。trace信息现在保留tmp目录下，每次运行前会清除该目录中的信息。 也可以参考 –trace-dir 。</td>
<td></td>
</tr>
<tr>
<td>-r, --backend-retries</td>
<td>3</td>
<td>(iOS-only) 遇到 crash 或者 超时，Instrument 重新启动的次数。</td>
<td>--backend-retries 3</td>
</tr>
<tr>
<td>--session-override</td>
<td>false</td>
<td>允许 session 被覆盖 (冲突的话)</td>
<td></td>
</tr>
<tr>
<td>--full-reset</td>
<td>false</td>
<td>(iOS) 删除整个模拟器目录。 (Android) 通过卸载应用（而不是清除数据）重置应用状态。在 Android 上，session 完成后也会删除应用。</td>
<td></td>
</tr>
<tr>
<td>--no-reset</td>
<td>false</td>
<td>session 之间不重置应用状态 (iOS: 不删除应用的 plist 文件； Android: 在创建一个新的 session 前不删除应用。)</td>
<td></td>
</tr>
<tr>
<td>-l, --pre-launch</td>
<td>false</td>
<td>在第一个 session 前，预启动应用 (iOS 需要 –app 参数，Android 需要 –app-pkg 和 –app-activity)</td>
<td></td>
</tr>
<tr>
<td>-lt, --launch-timeout  90000   (iOS-only) 等待 Instruments 启动的时间</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g, --log</td>
<td>null</td>
<td>将日志输出到指定文件</td>
<td>--log /path/to/appium.log</td>
</tr>
<tr>
<td>--log-level</td>
<td>debug</td>
<td>日志级别; 默认 (console[:file]): debug[:debug]</td>
<td>--log-level debug</td>
</tr>
<tr>
<td>--log-timestamp</td>
<td>false</td>
<td>在终端输出里显示时间戳</td>
<td></td>
</tr>
<tr>
<td>--local-timezone</td>
<td>false</td>
<td>使用本地时间戳</td>
<td></td>
</tr>
<tr>
<td>--log-no-colors</td>
<td>false</td>
<td>不在终端输出中显示颜色</td>
<td></td>
</tr>
<tr>
<td>-G, --webhook</td>
<td>null</td>
<td>同时发送日志到 HTTP 监听器</td>
<td>--webhook localhost:9876</td>
</tr>
<tr>
<td>--native-instruments-lib</td>
<td>false</td>
<td>(IOS-only) iOS 内建了一个怪异的不可能避免的延迟。我们在 Appium 里修复了它。如果你想用原来的，你可以使用这个参数。</td>
<td></td>
</tr>
<tr>
<td>--app-pkg</td>
<td>null</td>
<td>(Android-only) 你要运行的apk的java包。 (例如， com.example.android.myApp)</td>
<td>--app-pkg com.example.android.myApp</td>
</tr>
<tr>
<td>--app-activity</td>
<td>null</td>
<td>(Android-only) 打开应用时，启动的 Activity 的名字(比如， MainActivity)</td>
<td>--app-activity MainActivity</td>
</tr>
<tr>
<td>--app-wait-package</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 的包名。(比如， com.example.android.myApp)</td>
<td>--app-wait-package com.example.android.myApp</td>
</tr>
<tr>
<td>--app-wait-activity</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 名字(比如， SplashActivity)</td>
<td>--app-wait-activity SplashActivity</td>
</tr>
<tr>
<td>--android-coverage</td>
<td>false</td>
<td>(Android-only) 完全符合条件的 instrumentation 类。 作为命令 adb shell am instrument -e coverage true -w 的 -w 的参数</td>
<td>--android-coverage com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td>
</tr>
<tr>
<td>--avd</td>
<td>null</td>
<td>(Android-only) 要启动的 avd 的名字</td>
<td></td>
</tr>
<tr>
<td>--avd-args</td>
<td>null</td>
<td>(Android-only) 添加额外的参数给要启动avd</td>
<td>--avd-args -no-snapshot-load</td>
</tr>
<tr>
<td>--device-ready-timeout</td>
<td>5</td>
<td>(Android-only) 等待设备准备好的时间，以秒为单位</td>
<td>--device-ready-timeout 5</td>
</tr>
<tr>
<td>--safari</td>
<td>false</td>
<td>(IOS-Only) 使用 Safari 应用</td>
<td></td>
</tr>
<tr>
<td>--device-name</td>
<td>null</td>
<td>待使用的移动设备名字</td>
<td>--device-name iPhone Retina (4-inch), Android Emulator</td>
</tr>
<tr>
<td>--platform-name</td>
<td>null</td>
<td>移动平台的名称: iOS, Android, or FirefoxOS</td>
<td>--platform-name iOS</td>
</tr>
<tr>
<td>--platform-version</td>
<td>null</td>
<td>移动平台的版本</td>
<td>--platform-version 7.1</td>
</tr>
<tr>
<td>--automation-name</td>
<td>null</td>
<td>自动化工具的名称: Appium or Selendroid</td>
<td>--automation-name Appium</td>
</tr>
<tr>
<td>--browser-name</td>
<td>null</td>
<td>移动浏览器的名称: Safari or Chrome</td>
<td>--browser-name Safari</td>
</tr>
<tr>
<td>--default-device, -dd</td>
<td>false</td>
<td>(IOS-Simulator-only) 使用instruments自己启动的默认模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-iphone</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPhone 模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-ipad</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPad 模拟器</td>
<td></td>
</tr>
<tr>
<td>--language</td>
<td>null</td>
<td>iOS / Android 模拟器的语言</td>
<td>--language en</td>
</tr>
<tr>
<td>--locale</td>
<td>null</td>
<td>Locale for the iOS simulator / Android Emulator</td>
<td>--locale en_US</td>
</tr>
<tr>
<td>--calendar-format</td>
<td>null</td>
<td>(IOS-only) iOS 模拟器的日历格式</td>
<td>--calendar-format gregorian</td>
</tr>
<tr>
<td>--orientation</td>
<td>null</td>
<td>(IOS-only) 初始化请求时，使用 LANDSCAPE (横屏) 或者 PORTRAIT (竖屏)</td>
<td>--orientation LANDSCAPE</td>
</tr>
<tr>
<td>--tracetemplate</td>
<td>null</td>
<td>(IOS-only) 指定 Instruments 使用的 tracetemplate 文件</td>
<td>--tracetemplate /Users/me/Automation.tracetemplate</td>
</tr>
<tr>
<td>--show-sim-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 模拟器的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--show-ios-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 系统的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--nodeconfig</td>
<td>null</td>
<td>指定 JSON 格式的配置文件 ，用来在 selenium grid 里注册 appiumd</td>
<td>--nodeconfig /abs/path/to/nodeconfig.json</td>
</tr>
<tr>
<td>-ra, --robot-address</td>
<td>0.0.0.0</td>
<td>robot 的 ip 地址</td>
<td>--robot-address 0.0.0.0</td>
</tr>
<tr>
<td>-rp, --robot-port</td>
<td>-1</td>
<td>robot 的端口地址</td>
<td>--robot-port 4242</td>
</tr>
<tr>
<td>--selendroid-port</td>
<td>8080</td>
<td>用来和 Selendroid 交互的本地端口</td>
<td>--selendroid-port 8080</td>
</tr>
<tr>
<td>--chromedriver-port</td>
<td>9515</td>
<td>ChromeDriver运行的端口</td>
<td>--chromedriver-port 9515</td>
</tr>
<tr>
<td>--chromedriver-executable</td>
<td>null</td>
<td>ChromeDriver 可执行文件的完整路径</td>
<td></td>
</tr>
<tr>
<td>--use-keystore</td>
<td>false</td>
<td>(Android-only) 设置签名 apk 的 keystore</td>
<td></td>
</tr>
<tr>
<td>--keystore-path</td>
<td>(Android-only) keystore 的路径</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--keystore-password</td>
<td>android</td>
<td>(Android-only) keystore 的密码</td>
<td></td>
</tr>
<tr>
<td>--key-alias</td>
<td>androiddebugkey</td>
<td>(Android-only) Key 的别名</td>
<td></td>
</tr>
<tr>
<td>--key-password</td>
<td>android</td>
<td>(Android-only) Key 的密码</td>
<td></td>
</tr>
<tr>
<td>--show-config</td>
<td>false</td>
<td>打印 Appium 服务器的配置信息，然后退出</td>
<td></td>
</tr>
<tr>
<td>--no-perms-check</td>
<td>false</td>
<td>跳过Appium对是否可以读/写必要文件的检查</td>
<td></td>
</tr>
<tr>
<td>--command-timeout</td>
<td>60</td>
<td>默认所有会话的接收命令超时时间 (在超时时间内没有接收到新命令，自动关闭会话)。 会被新的超时时间覆盖</td>
<td></td>
</tr>
<tr>
<td>--keep-keychains</td>
<td>false</td>
<td>(iOS) 当 Appium 启动或者关闭的时候，是否保留 keychains (Library/Keychains)</td>
<td></td>
</tr>
<tr>
<td>--strict-caps</td>
<td>false</td>
<td>如果所选设备是appium不承认的有效设备，会导致会话失败</td>
<td></td>
</tr>
<tr>
<td>--isolate-sim-device</td>
<td>false  Xcode 6存在一个bug，那就是一些平台上如果其他模拟器设备先被删除时某个特定的模拟器只能在没有任何错误的情况下被建立。这个选项导致了Appium不得不删除除了正在使用设备以外其他所有的设备。请注意这是永久性删除，你可以使用simctl或xcode管理被Appium使用的设备类别。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--tmp</td>
<td>null</td>
<td>可以被Appium用来管理临时文件的目录（绝对路径），比如存放需要移动的内置iOS应用程序。 默认的变量为 APPIUM_TMP_DIR ，在 *nix/Mac 为 /tmp 在windows上使用环境便令 TEMP 设定的目录。</td>
<td></td>
</tr>
<tr>
<td>--trace-dir</td>
<td>null</td>
<td>用于保存iOS instruments trace的 appium 目录，是绝对路径， 默认为 /appium-instruments</td>
<td></td>
</tr>
<tr>
<td>--intent-action</td>
<td>android.intent.action.MAIN</td>
<td>(Android-only) 用于启动 activity 的intent action</td>
<td>--intent-action android.intent.action.MAIN</td>
</tr>
<tr>
<td>--intent-category</td>
<td>android.intent.category.LAUNCHER</td>
<td>(Android-only) 用于启动 activity 的intent category</td>
<td>--intent-category android.intent.category.APP_CONTACTS</td>
</tr>
<tr>
<td>--intent-flags</td>
<td>0x10200000</td>
<td>(Android-only) 启动 activity 的标志</td>
<td>--intent-flags 0x10200000</td>
</tr>
<tr>
<td>--intent-args</td>
<td>null</td>
<td>(Android-only) 启动 activity 时附带额外的 intent 参数</td>
<td>--intent-args 0x10200000</td>
</tr>
<tr>
<td>--suppress-adb-kill-server</td>
<td>false</td>
<td>(Android-only) 如果被设定，阻止Appium杀掉adb实例。</td>
<td></td>
</tr>
</tbody>
</table>

<h3 id="toc_18">(二) Android测试用例编写</h3>

<h4 id="toc_19">1、例子:</h4>

<pre class="line-numbers"><code class="language-python">import os

import unittest
from appium import webdriver
from time import sleep

PATH = lambda p: os.path.abspath(
    os.path.join(os.path.dirname(__file__),p)
)

class XingQiuAndroidTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps[&#39;deviceName&#39;] = &#39;emulator-5554&#39;  #adb devices查到的设备名
        desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
        desired_caps[&#39;platformVersion&#39;] = &#39;4.4&#39;
        desired_caps[&#39;app&#39;] = PATH(
            &#39;../../../Users/jiangruoming/Desktop/***.apk&#39;
        )
        desired_caps[&#39;appPackage&#39;] = &#39;com.***.***&#39;  #被测App的包名
        desired_caps[&#39;appActivity&#39;] = &#39;.****&#39; #启动时的Activity

        self.driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

    #earDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出
    def tearDown(self):
        self.driver.quit()

    #放置的就是我们的测试脚本了，这部分我们并不陌生；因为我们执行的脚本就在这里。
    def test_add_contacts(self):
        el = self.driver.find_element_by_id(&quot;com.***.***:id/sign_phone&quot;)
        el.click()

        phone_number = self.driver.find_element_by_id(&quot;com.***.***:id/et_user_phone&quot;)
        code = self.driver.find_element_by_id(&quot;com.***.***:id/et_smscode&quot;)
        phone_number.send_keys(&quot;*********&quot;)
        code.send_keys(&quot;****&quot;)

        btn = self.driver.find_element_by_id(&quot;com.***.***:id/btn_finish&quot;)
        btn.click()

if __name__ == &#39;__main__&#39;:
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuAndroidTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>

<h4 id="toc_20">2、测试流程</h4>

<h5 id="toc_21">(1) 启动Appium</h5>

<p><code>appium -a 127.0.0.1 -p 4723 --log /path/to/appium.log</code></p>

<h5 id="toc_22">(2) 启动Android模拟器</h5>

<p>由于测试apk不支持X86平台，所以Genymotion无法支持运行，原生arm模拟器运行过慢(胃都等疼了)。试过多个模拟器后，最终选定了夜神模拟器，效果还是不错的。但是由于其主要用于PC平台运行Android游戏，所以用于开发平台还是需要进行配置。</p>

<h6 id="toc_23">a、adb配置</h6>

<p>在Mac环境中加入adb的环境变量<br/><br/>
<code>vi .bash_profile</code><br/><br/>
<code>export PATH=/Users/Path/To/Android/sdk/platform-tools/:$PATH</code><br/><br/>
<code>source .bash_profile</code>  </p>

<h6 id="toc_24">b、adb连接</h6>

<p>之后进入夜神的包内容中在adb所在文件夹运行adb连接命令<br/><br/>
<code>adb connect 127.0.0.1:62001</code><br/>
这样<code>adb devices</code>就能显示夜神模拟器的Device ID</p>

<h5 id="toc_25">(3) 运行脚本</h5>

<h3 id="toc_26">(三) iOS测试用例编写</h3>

<h4 id="toc_27">1、例子:</h4>

<pre class="line-numbers"><code class="language-python">import unittest
import os
from appium import webdriver
from time import sleep


PATH = lambda p: os.path.abspath(
    os.path.join(os.path.dirname(__file__),p)
)

class XingQiuiOSTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps[&#39;platformName&#39;] = &#39;iOS&#39;
        desired_caps[&#39;platformVersion&#39;] = &#39;10.2&#39;
        desired_caps[&#39;deviceName&#39;] = &#39;iPhone Simulator&#39;
        desired_caps[&#39;app&#39;] = PATH(&#39;../../../Users/jiangruoming/Desktop/***.app&#39;)

        self.driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

    #def tearDown(self):
        #self.driver.quit()

    def test_add_contacts(self):

        el2 = self.driver.find_elements_by_accessibility_id(&#39;Allow&#39;)

        if el2:
            el2[0].click()

        el3 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeButton&#39;)[0]
        el3.click()

        el4 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeTextField&#39;)[0]
        el4.send_keys(&quot;15088678313&quot;)

        el5 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeTextField&#39;)[1]
        el5.send_keys(&quot;1234&quot;)

        el6 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeButton&#39;)[0]
        el6.click()

if __name__ == &#39;__main__&#39;:
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuiOSTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>

<h4 id="toc_28">2、XCUIElementType</h4>

<pre class="line-numbers"><code class="language-python">XCUIElementTypeAny,
    XCUIElementTypeUnknown,
    XCUIElementTypeApplication,
    XCUIElementTypeGroup,
    XCUIElementTypeWindow,
    XCUIElementTypeSheet,
    XCUIElementTypeDrawer,
    XCUIElementTypeAlert,
    XCUIElementTypeDialog,
    XCUIElementTypeButton,
    XCUIElementTypeRadioButton,
    XCUIElementTypeRadioGroup,
    XCUIElementTypeCheckBox,
    XCUIElementTypeDisclosureTriangle,
    XCUIElementTypePopUpButton,
    XCUIElementTypeComboBox,
    XCUIElementTypeMenuButton,
    XCUIElementTypeToolbarButton,
    XCUIElementTypePopover,
    XCUIElementTypeKeyboard,
    XCUIElementTypeKey,
    XCUIElementTypeNavigationBar,
    XCUIElementTypeTabBar,
    XCUIElementTypeTabGroup,
    XCUIElementTypeToolbar,
    XCUIElementTypeStatusBar,
    XCUIElementTypeTable,
    XCUIElementTypeTableRow,
    XCUIElementTypeTableColumn,
    XCUIElementTypeOutline,
    XCUIElementTypeOutlineRow,
    XCUIElementTypeBrowser,
    XCUIElementTypeCollectionView,
    XCUIElementTypeSlider,
    XCUIElementTypePageIndicator,
    XCUIElementTypeProgressIndicator,
    XCUIElementTypeActivityIndicator,
    XCUIElementTypeSegmentedControl,
    XCUIElementTypePicker,
    XCUIElementTypePickerWheel,
    XCUIElementTypeSwitch,
    XCUIElementTypeToggle,
    XCUIElementTypeLink,
    XCUIElementTypeImage,
    XCUIElementTypeIcon,
    XCUIElementTypeSearchField,
    XCUIElementTypeScrollView,
    XCUIElementTypeScrollBar,
    XCUIElementTypeStaticText,
    XCUIElementTypeTextField,
    XCUIElementTypeDateField,
    XCUIElementTypeTimeField,
    XCUIElementTypeTextView,
    XCUIElementTypeMenu,
    XCUIElementTypeMenuItem,
    XCUIElementTypeMenuBar,
    XCUIElementTypeMenuBarItem,
    XCUIElementTypeMap,
    XCUIElementTypeWebView,
    XCUIElementTypeIncrementArrow,
    XCUIElementTypeDecrementArrow,
    XCUIElementTypeTimeline,
    XCUIElementTypeRatingIndicator,
    XCUIElementTypeValueIndicator,
    XCUIElementTypeSplitGroup,
    XCUIElementTypeSplitter,
    XCUIElementTypeRelevanceIndicator,
    XCUIElementTypeColorWell,
    XCUIElementTypeHelpTag,
    XCUIElementTypeMatte,
    XCUIElementTypeDockItem,
    XCUIElementTypeRuler,
    XCUIElementTypeRulerMarker,
    XCUIElementTypeGrid,
    XCUIElementTypeLevelIndicator,
    XCUIElementTypeCell,
    XCUIElementTypeLayoutArea,
    XCUIElementTypeLayoutItem,
    XCUIElementTypeHandle,
</code></pre>

<h4 id="toc_29">3、Appium Python API</h4>

<h5 id="toc_30">(1) contexts</h5>

<p><code>contexts(self)</code>:<br/><br/>
Returns the contexts within the current session.<br/>
返回当前会话中的上下文，使用后可以识别H5页面的控件<br/>
Usage:<br/><br/>
    <code>driver.contexts</code><br/><br/>
用法:<br/><br/>
    <code>driver.contexts</code></p>

<h5 id="toc_31">(2) current_context</h5>

<p><code>current_context(self)</code>:<br/><br/>
Returns the current context of the current session.<br/><br/>
返回当前会话的当前上下文<br/><br/>
Usage:<br/><br/>
    <code>driver.current_context</code><br/><br/>
用法:<br/><br/>
    <code>driver. current_context</code></p>

<h5 id="toc_32">(3) context</h5>

<p><code>context(self)</code>:<br/><br/>
Returns the current context of the current session.<br/><br/>
返回当前会话的当前上下文。<br/><br/>
Usage:<br/><br/>
    <code>driver.context</code><br/><br/>
用法:<br/><br/>
    <code>driver. Context</code></p>

<h5 id="toc_33">(4) find_element_by_ios_uiautomation</h5>

<p><code>find_element_by_ios_uiautomation(self, uia_string)</code>:<br/><br/>
Finds an element by uiautomation in iOS.<br/><br/>
通过iOS uiautomation查找元素<br/><br/>
Args:  </p>

<ul>
<li>uia_string - The element name in the iOS UIAutomation library<br/>
Usage:<br/>
<code>driver.find_element_by_ios_uiautomation(&#39;.elements()[1].cells()[2]&#39;)</code>
用法:<br/>
<code>dr. find_element_by_ios_uiautomation(‘elements’)</code></li>
</ul>

<h5 id="toc_34">(5) find_element_by_accessibility_id</h5>

<p><code>find_element_by_accessibility_id(self, id)</code>:<br/><br/>
Finds an element by accessibility id.<br/><br/>
通过accessibility id查找元素<br/><br/>
Args:<br/><br/>
    - id - a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize<br/><br/>
Usage:<br/><br/>
    <code>driver.find_element_by_accessibility_id()</code><br/><br/>
用法:<br/><br/>
    <code>driver.find_element_by_accessibility_id(‘id’)</code></p>

<h5 id="toc_35">(6) scroll</h5>

<p><code>scroll(self, origin_el, destination_el)</code>:<br/>
Scrolls from one element to another<br/><br/>
从元素origin_el滚动至元素destination_el<br/><br/>
Args:  </p>

<ul>
<li>originalEl - the element from which to being scrolling</li>
<li>destinationEl - the element to scroll to<br/>
Usage:<br/>
<code>driver.scroll(el1, el2)</code>
用法:<br/>
<code>driver.scroll(el1,el2)</code></li>
</ul>

<h5 id="toc_36">(7) drag_and_drop</h5>

<p><code>drag_and_drop(self, origin_el, destination_el)</code>:<br/><br/>
Drag the origin element to the destination element<br/><br/>
将元素origin_el拖到目标元素destination_el<br/><br/>
Args:  </p>

<ul>
<li>originEl - the element to drag</li>
<li>destinationEl - the element to drag to<br/>
用法:<br/>
<code>driver.drag_and_drop(el1,el2)</code></li>
</ul>

<h5 id="toc_37">(8) tap</h5>

<p><code>tap(self, positions, duration=None)</code>:<br/><br/>
Taps on an particular place with up to five fingers, holding for a certain time<br/><br/>
模拟手指点击（最多五个手指），可设置按住时间长度（毫秒）<br/><br/>
Args:</p>

<ul>
<li>positions - an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five.</li>
<li>duration - (optional) length of time to tap, in ms<br/>
Usage:<br/>
<code>driver.tap([(100, 20), (100, 60), (100, 100)], 500)</code>
用法:<br/>
<code>driver.tap([(x,y),(x1,y1)],500)</code></li>
</ul>

<h5 id="toc_38">(9) swipe</h5>

<p><code>swipe(self, start_x, start_y, end_x, end_y, duration=None)</code>:<br/><br/>
Swipe from one point to another point, for an optional duration.<br/><br/>
从A点滑动至B点，滑动时间为毫秒<br/><br/>
Args:<br/><br/>
    - start_x - x-coordinate at which to start<br/>
    - start_y - y-coordinate at which to start<br/>
    - end_x - x-coordinate at which to stop<br/>
    - end_y - y-coordinate at which to stop<br/>
    - duration - (optional) time to take the swipe, in ms.  </p>

<p>Usage:<br/><br/>
    <code>driver.swipe(100, 100, 100, 400)</code><br/>
用法:<br/><br/>
    <code>driver.swipe(x1,y1,x2,y2,500)</code></p>

<h5 id="toc_39">(10) flick</h5>

<p><code>flick(self, start_x, start_y, end_x, end_y)</code>:<br/><br/>
Flick from one point to another point.<br/><br/>
按住A点后快速滑动至B点<br/><br/>
Args:<br/><br/>
    - start_x - x-coordinate at which to start<br/>
    - start_y - y-coordinate at which to start<br/>
    - end_x - x-coordinate at which to stop<br/>
    - end_y - y-coordinate at which to stop<br/><br/>
Usage:<br/><br/>
    <code>driver.flick(100, 100, 100, 400)</code><br/>
用法:<br/><br/>
    <code>driver.flick(x1,y1,x2,y2)</code></p>

<h5 id="toc_40">(11) pinch</h5>

<p><code>pinch(self, element=None, percent=200, steps=50)</code>:<br/><br/>
Pinch on an element a certain amount<br/><br/>
在元素上执行模拟双指捏（缩小操作）<br/><br/>
Args:  </p>

<ul>
<li>element - the element to pinch</li>
<li>percent - (optional) amount to pinch. Defaults to 200%</li>
<li>steps - (optional) number of steps in the pinch action</li>
</ul>

<p>Usage:<br/><br/>
    <code>driver.pinch(element)</code><br/>
用法:<br/>
    <code>driver.pinch(element)</code></p>

<h5 id="toc_41">(12) zoom</h5>

<p><code>zoom(self, element=None, percent=200, steps=50)</code>:<br/>
Zooms in on an element a certain amount<br/><br/>
在元素上执行放大操作<br/><br/>
Args:  </p>

<ul>
<li>element - the element to zoom</li>
<li>percent - (optional) amount to zoom. Defaults to 200%</li>
<li>steps - (optional) number of steps in the zoom action</li>
</ul>

<p>Usage:<br/>
    <code>driver.zoom(element)</code><br/>
用法: <br/>
    <code>driver.zoom(element)</code></p>

<h5 id="toc_42">(13) reset</h5>

<p><code>reset(self)</code>:<br/><br/>
Resets the current application on the device.<br/><br/>
重置应用(类似删除应用数据)<br/><br/>
用法:<br/>
<code>driver.reset()</code></p>

<h5 id="toc_43">(14) hide_keyboard</h5>

<p><code>hide_keyboard(self, key_name=None, key=None, strategy=None)</code>:<br/>
Hides the software keyboard on the device. In iOS, use <code>key_name</code> to press a particular key, or <code>strategy</code>. In Android, no parameters are used.<br/>
隐藏键盘,iOS使用key_name隐藏，安卓不使用参数<br/>
Args:  </p>

<ul>
<li>key_name - key to press</li>
<li>strategy - strategy for closing the keyboard (e.g., <code>tapOutside</code>)</li>
</ul>

<p><code>driver.hide_keyboard()</code></p>

<h5 id="toc_44">(15) keyevent</h5>

<p><code>keyevent(self, keycode, metastate=None)</code>:<br/><br/>
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送按键码（安卓仅有），按键码可以上网址中找到<br/><br/>
Args:  </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>

<p>用法:<br/>
<code>dr.keyevent(‘4’)</code></p>

<h5 id="toc_45">(16) press_keycode</h5>

<p><code>press_keycode(self, keycode, metastate=None)</code>:<br/><br/>
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送按键码（安卓仅有），按键码可以上网址中找到<br/>
Args:   </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>

<p>用法: <br/>
<code>driver.press_ keycode(‘4’)</code>  </p>

<p>dr.keyevent(‘4’)与driver.press_ keycode(‘4’) 功能实现上一样的，都是按了返回键</p>

<h5 id="toc_46">(17) long_press_keycode</h5>

<p><code>long_press_keycode(self, keycode, metastate=None)</code>:<br/><br/>
Sends a long press of keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送一个长按的按键码（长按某键）<br/><br/>
Args:   </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent<br/>
用法:<br/>
<code>driver.long_press_keycode(‘4’)</code></li>
</ul>

<h5 id="toc_47">(18) current_activity</h5>

<p><code>current_activity(self)</code>:<br/><br/>
Retrieves the current activity on the device.<br/><br/>
获取当前的activity<br/><br/>
用法:<br/>
<code>print(driver.current_activity())</code></p>

<h5 id="toc_48">(19) wait_activity</h5>

<p><code>wait_activity(self, activity, timeout, interval=1)</code>:<br/><br/>
Wait for an activity: block until target activity presents or time out.<br/><br/>
This is an Android-only method.<br/><br/>
等待指定的activity出现直到超时，interval为扫描间隔1秒<br/><br/>
即每隔几秒获取一次当前的activity<br/><br/>
返回的True 或 False<br/><br/>
Agrs:</p>

<ul>
<li>activity - target activity</li>
<li>timeout - max wait time, in seconds</li>
<li>interval - sleep interval between retries, in seconds</li>
</ul>

<p>用法:<br/>
    <code>driver.wait_activity(‘.activity.xxx’,5,2)</code></p>

<h5 id="toc_49">(20) background_app</h5>

<p><code>background_app(self, seconds)</code>:<br/>
Puts the application in the background on the device for a certain duration.<br/><br/>
后台运行app多少秒<br/><br/>
Args:  </p>

<ul>
<li>seconds - the duration for the application to remain in the background<br/>
用法:
<code>driver.background_app(5)</code><br/>
置后台5秒后再运行</li>
</ul>

<h5 id="toc_50">(21) is_app_installed</h5>

<p><code>is_app_installed(self, bundle_id)</code>:<br/><br/>
Checks whether the application specified by <code>bundle_id</code> is installed on the device.<br/><br/>
检查app是否有安装<br/><br/>
返回 True or False<br/><br/>
Args:  </p>

<ul>
<li>bundle_id - the id of the application to query<br/></li>
</ul>

<p>用法: <br/>
<code>driver.is_app_installed(“com.xxxx”)</code></p>

<h5 id="toc_51">(22) install_app</h5>

<p><code>install_app(self, app_path)</code>:<br/><br/>
Install the application found at <code>app_path</code> on the device.<br/><br/>
安装app,app_path为安装包路径<br/><br/>
Args:  </p>

<ul>
<li>app_path - the local or remote path to the application to install</li>
</ul>

<p>用法:<br/><br/>
<code>driver.install_app(app_path)</code></p>

<h5 id="toc_52">(23) remove_app</h5>

<p><code>remove_app(self, app_id)</code>:<br/><br/>
Remove the specified application from the device.<br/><br/>
删除app<br/><br/>
Args:  </p>

<ul>
<li>app_id - the application id to be removed<br/></li>
</ul>

<p>用法: <br/>
<code>driver.remove_app(“com.xxx.”)</code></p>

<h5 id="toc_53">(24) launch_app</h5>

<p><code>launch_app(self)</code>:<br/><br/>
Start on the device the application specified in the desired capabilities.<br/><br/>
启动app<br/><br/>
用法:<br/><br/>
<code>driver.launch_app()</code></p>

<h5 id="toc_54">(25) close_app</h5>

<p><code>close_app(self)</code>:<br/><br/>
Stop the running application, specified in the desired capabilities, on the device.<br/><br/>
关闭app<br/><br/>
用法:<br/><br/>
<code>driver.close_app()</code><br/><br/>
启动和关闭app运行好像会出错</p>

<h5 id="toc_55">(26) start_activity</h5>

<p><code>start_activity(self, app_package, app_activity, **opts)</code>:<br/><br/>
Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened.<br/><br/>
This is an Android-only method.<br/><br/>
在测试过程中打开任意活动。如果活动属于另一个应用程序，该应用程序的启动和活动被打开。<br/><br/>
这是一个安卓的方法<br/><br/>
Args:</p>

<ul>
<li>app_package - The package containing the activity to start.</li>
<li>app_activity - The activity to start.</li>
<li>app_wait_package - Begin automation after this package starts (optional).</li>
<li>app_wait_activity - Begin automation after this activity starts (optional).</li>
<li>intent_action - Intent to start (optional).</li>
<li>intent_category - Intent category to start (optional).</li>
<li>intent_flags - Flags to send to the intent (optional).</li>
<li>optional_intent_arguments - Optional arguments to the intent (optional).</li>
<li>stop_app_on_reset - Should the app be stopped on reset (optional)?</li>
</ul>

<p>用法:<br/><br/>
<code>driver.start_activity(app_package, app_activity)</code></p>

<h5 id="toc_56">(27) lock</h5>

<p><code>lock(self, seconds)</code>:<br/><br/>
Lock the device for a certain period of time. iOS only.<br/><br/>
锁屏一段时间  iOS专有<br/><br/>
Args:  </p>

<ul>
<li>the duration to lock the device, in seconds</li>
</ul>

<p>用法:<br/><br/>
<code>driver.lock()</code></p>

<h5 id="toc_57">(28) shake</h5>

<p><code>shake(self)</code>:<br/><br/>
Shake the device.<br/><br/>
摇一摇手机<br/><br/>
用法:<br/><br/>
<code>driver.shake()</code></p>

<h5 id="toc_58">(29) open_notifications</h5>

<p><code>open_notifications(self)</code>:<br/><br/>
Open notification shade in Android (API Level 18 and above)<br/><br/>
打系统通知栏（仅支持API 18 以上的安卓系统）<br/><br/>
用法:<br/><br/>
<code>driver.open_notifications()</code></p>

<h5 id="toc_59">(30) network_connection</h5>

<p><code>network_connection(self)</code>:<br/><br/>
Returns an integer bitmask specifying the network connection type.<br/><br/>
Android only.<br/><br/>
返回网络类型  数值<br/><br/>
Possible values are available through the enumeration <code>appium.webdriver.ConnectionType</code><br/><br/>
用法:<br/><br/>
<code>driver.network_connection</code>  </p>

<h5 id="toc_60">(31) set_network_connection</h5>

<p><code>set_network_connection(self, connectionType)</code>:<br/><br/>
Sets the network connection type. Android only.<br/><br/>
Possible values:  </p>

<table>
<thead>
<tr>
<th>Value (Alias)</th>
<th>Data</th>
<th>Wifi</th>
<th>Airplane Mode</th>
</tr>
</thead>

<tbody>
<tr>
<td>0 (None)</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1 (Airplane Mode)</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2 (Wifi only)</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4 (Data only)</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6 (All network on)</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

<p>These are available through the enumeration appium.webdriver.ConnectionType`</p>

<p>设置网络类型<br/><br/>
Args:  </p>

<ul>
<li>connectionType - a member of the enum appium.webdriver.ConnectionType</li>
</ul>

<p>用法:<br/><br/>
先加载from appium.webdriver.connectiontype import ConnectionType<br/><br/>
<code>dr.set_network_connection(ConnectionType.WIFI_ONLY)</code><br/><br/>
ConnectionType的类型有<br/><br/>
NO_CONNECTION = 0<br/><br/>
AIRPLANE_MODE = 1<br/><br/>
WIFI_ONLY = 2<br/><br/>
DATA_ONLY = 4<br/><br/>
ALL_NETWORK_ON = 6  </p>

<h5 id="toc_61">(32) available_ime_engines</h5>

<p><code>available_ime_engines(self)</code>:<br/><br/>
Get the available input methods for an Android device. Package and activity are returned (e.g., [&#39;com.android.inputmethod.latin/.LatinIME&#39;])<br/><br/>
Android only.<br/><br/>
返回安卓设备可用的输入法<br/><br/>
用法:<br/><br/>
<code>print(driver.available_ime_engines)</code></p>

<h5 id="toc_62">(33) is_ime_active</h5>

<p><code>is_ime_active(self)</code>:<br/><br/>
Checks whether the device has IME service active. Returns True/False.<br/><br/>
Android only.<br/><br/>
检查设备是否有输入法服务活动。返回真/假。<br/><br/>
安卓<br/><br/>
用法: <br/>
    <code>print(driver.is_ime_active())</code></p>

<h5 id="toc_63">(34) activate_ime_engine</h5>

<p><code>activate_ime_engine(self, engine)</code>:<br/><br/>
Activates the given IME engine on the device.<br/><br/>
Android only.<br/><br/>
激活安卓设备中的指定输入法，设备可用输入法可以从“available_ime_engines”获取<br/><br/>
Args:  </p>

<ul>
<li>engine - the package and activity of the IME engine to activate (e.g.,&#39;com.android.inputmethod.latin/.LatinIME&#39;)<br/></li>
</ul>

<p>用法:<br/><br/>
    <code>driver.activate_ime_engine(“com.android.inputmethod.latin/.LatinIME”)</code></p>

<h5 id="toc_64">(35) deactivate_ime_engine</h5>

<p><code>deactivate_ime_engine(self)</code>:<br/><br/>
Deactivates the currently active IME engine on the device.<br/><br/>
Android only.<br/><br/>
关闭安卓设备当前的输入法<br/><br/>
用法:<br/>
    <code>driver.deactivate_ime_engine()</code></p>

<h5 id="toc_65">(36) active_ime_engine</h5>

<p><code>active_ime_engine(self)</code>:<br/><br/>
Returns the activity and package of the currently active IME engine (e.g.,&#39;com.android.inputmethod.latin/.LatinIME&#39;).<br/><br/>
Android only.<br/><br/>
返回当前输入法的包名<br/><br/>
用法:<br/><br/>
<code>driver.active_ime_engine</code>  </p>

<h5 id="toc_66">(37) toggle_location_services</h5>

<p><code>toggle_location_services(self)</code>:<br/><br/>
Toggle the location services on the device. Android only.<br/><br/>
打开安卓设备上的位置定位设置<br/><br/>
用法:<br/>
<code>driver.toggle_location_services()</code></p>

<h5 id="toc_67">(38) set_location</h5>

<p><code>set_location(self, latitude, longitude, altitude)</code>:<br/><br/>
Set the location of the device<br/><br/>
设置设备的经纬度<br/><br/>
Args:  </p>

<ul>
<li>latitude纬度 - String or numeric value between -90.0 and 90.00</li>
<li>longitude经度 - String or numeric value between -180.0 and 180.0</li>
<li>altitude海拔高度- String or numeric value</li>
</ul>

<p>用法:<br/><br/>
<code>driver.set_location(纬度，经度，高度)</code></p>

<h5 id="toc_68">(39) tag_name</h5>

<p><code>tag_name(self)</code>:<br/><br/>
This element&#39;s <code>tagName</code> property.<br/><br/>
返回元素的tagName属性<br/><br/>
经实践返回的是class name<br/><br/>
用法:<br/><br/>
<code>element.tag_name()</code></p>

<h5 id="toc_69">(40) text</h5>

<p><code>text(self)</code>:<br/><br/>
The text of the element.<br/><br/>
返回元素的文本值<br/><br/>
用法:<br/><br/>
<code>element.text()</code></p>

<h5 id="toc_70">(41) click</h5>

<p><code>click(self)</code>:<br/><br/>
Clicks the element.<br/><br/>
点击元素<br/><br/>
用法:<br/><br/>
<code>element.click()</code></p>

<h5 id="toc_71">(42) submit</h5>

<p><code>submit(self)</code>:<br/><br/>
Submits a form.<br/><br/>
提交表单<br/><br/>
用法:<br/><br/>
暂无</p>

<h5 id="toc_72">(43) clear</h5>

<p><code>clear(self)</code>:<br/><br/>
Clears the text if it&#39;s a text entry element.<br/><br/>
清除输入的内容<br/><br/>
用法:<br/><br/>
<code>element.clear()</code></p>

<h5 id="toc_73">(44) get_attribute</h5>

<p><code>get_attribute(self, name)</code>:<br/><br/>
详见@chenhengjie123 的超级链接<br/><br/>
Gets the given attribute or property of the element.  </p>

<pre class="line-numbers"><code class="language-text">1. 获取 content-desc 的方法为 get_attribute(&quot;name&quot;) ，而且还不能保证返回的一定是 content-desc （content-desc 为空时会返回 text 属性值）  
2. get_attribute 方法不是我们在 uiautomatorviewer 看到的所有属性都能获取的（此处的名称均为使用 get_attribute 时使用的属性名称)
可获取的：
字符串类型：
    `name(返回 content-desc 或 text)`
    `text(返回 text)`
    `className(返回 class，只有 API=&gt;18 才能支持)`
    `resourceId(返回 resource-id，只有 API=&gt;18 才能支持)`
</code></pre>

<p>This method will first try to return the value of a property with the given name. If a property with that name doesn&#39;t exist, it returns the value of the attribute with the same name. If there&#39;s no attribute with that name, <code>None</code> is returned.Values which are considered truthy, that is equals &quot;true&quot; or &quot;false&quot;,are returned as booleans.  All other non-<code>None</code> values are returned as strings.  For attributes or properties which do not exist, <code>None</code> is returned.</p>

<p>Args:</p>

<ul>
<li>name - Name of the attribute/property to retrieve.</li>
</ul>

<p>Example:<br/>
    # Check if the &quot;active&quot; CSS class is applied to an element.</p>

<p><code>is_active = &quot;active&quot; in target_element.get_attribute(&quot;class&quot;)</code></p>

<p>用法:<br/><br/>
暂无</p>

<h5 id="toc_74">(45) is_selected</h5>

<p><code>is_selected(self)</code>:<br/><br/>
Returns whether the element is selected.<br/><br/>
Can be used to check if a checkbox or radio button is selected.<br/><br/>
返回元素是否选择。<br/><br/>
可以用来检查一个复选框或单选按钮被选中。<br/><br/>
用法:<br/><br/>
<code>element.is_slected()</code></p>

<h5 id="toc_75">(46) is_enabled</h5>

<p><code>is_enabled(self)</code>:<br/><br/>
Returns whether the element is enabled.<br/><br/>
返回元素是否可用True of False<br/><br/>
用法:<br/><br/>
<code>element.is_enabled()</code></p>

<h5 id="toc_76">(47) find_element_by_id</h5>

<p><code>find_element_by_id(self, id_)</code>:<br/><br/>
Finds element within this element&#39;s children by ID.<br/><br/>
通过元素的ID定位元素<br/><br/>
Args:  </p>

<ul>
<li>id_ - ID of child element to locate.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_element_by_id(“id”)</code></p>

<h5 id="toc_77">(48) find_elements_by_id</h5>

<p><code>find_elements_by_id(self, id_)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by ID.<br/><br/>
通过元素ID定位,含有该属性的所有元素<br/><br/>
Args:   </p>

<ul>
<li>id_ - Id of child element to find.</li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_elements_by_id(“id”)</code></p>

<h5 id="toc_78">(49) find_element_by_name</h5>

<p><code>find_element_by_name(self, name)</code>:<br/><br/>
Finds element within this element&#39;s children by name.<br/><br/>
通过元素Name定位（元素的名称属性text）. <br/>
Args:  </p>

<ul>
<li>name - name property of the element to find.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_name(“name”)</code></p>

<h5 id="toc_79">(50) find_elements_by_name</h5>

<p><code>find_elements_by_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by name.<br/><br/>
通过元素Name定位（元素的名称属性text），含有该属性的所有元素. <br/>
Args:  </p>

<ul>
<li>name - name property to search for.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_name(“name”)</code></p>

<h5 id="toc_80">(51) find_element_by_link_text</h5>

<p><code>find_element_by_link_text(self, link_text)</code>:<br/><br/>
Finds element within this element&#39;s children by visible link text.<br/><br/>
通过元素可见链接文本定位. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_link_text(“text”)</code></p>

<h5 id="toc_81">(52) find_elements_by_link_text</h5>

<p><code>find_element_by_link_text(self, link_text)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by visible link text. <br/>
通过元素可见链接文本定位,含有该属性的所有元素. <br/>
Args:    </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p>用法: <br/>
<code>driver.find_elements_by_link_text(“text”)</code></p>

<h5 id="toc_82">(53) find_element_by_partial_link_text</h5>

<p><code>find_element_by_partial_link_text(self, link_text)</code>:<br/><br/>
Finds element within this element&#39;s children by partially visible link text.<br/><br/>
通过元素部分可见链接文本定位. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p><code>driver. find_element_by_partial_link_text(“text”)</code></p>

<h5 id="toc_83">(54) find_elements_by_partial_link_text</h5>

<p><code>find_elements_by_partial_link_text(self, link_text)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by link text.<br/><br/>
通过元素部分可见链接文本定位,含有该属性的所有元素. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p><code>driver. find_elements_by_partial_link_text(“text”)</code></p>

<h5 id="toc_84">(55) find_element_by_tag_name</h5>

<p><code>find_element_by_tag_name(self, name)</code>:<br/>
Finds element within this element&#39;s children by tag name.<br/><br/>
通过查找html的标签名称定位元素<br/><br/>
Args:</p>

<ul>
<li>name - name of html tag (eg: h1, a, span)</li>
</ul>

<p>用法:<br/><br/>
    <code>driver.find_element_by_tag_name(“name”)</code></p>

<h5 id="toc_85">(56) find_elements_by_tag_name</h5>

<p><code>find_elements_by_tag_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by tag name.<br/>
通过查找html的标签名称定位所有元素<br/><br/>
Args:  </p>

<ul>
<li>name - name of html tag (eg: h1, a, span). </li>
</ul>

<p>用法:<br/>
    <code>driver.find_elements_by_tag_name(“name”)</code></p>

<h5 id="toc_86">(57) find_element_by_xpath</h5>

<p><code>find_element_by_xpath(self, xpath)</code>:<br/><br/>
Finds element by xpath.<br/><br/>
通过Xpath定位元素，详细方法可参阅<a href="http://www.w3school.com.cn/xpath/">http://www.w3school.com.cn/xpath/</a><br/>
Args:<br/>
    xpath - xpath of element to locate.  &quot;//input[@class=&#39;myelement&#39;]&quot;<br/>
    Note: The base path will be relative to this element&#39;s location.<br/>
    This will select the first link under this element.<br/>
    <code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code><br/>
    However, this will select the first link on the page.<br/>
    <code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>  </p>

<p>用法 <code>find_element_by_xpath(“//*”)</code></p>

<h5 id="toc_87">(58) find_elements_by_xpath</h5>

<p><code>find_elements_by_xpath(self, xpath)</code>:<br/>
Finds elements within the element by xpath.<br/><br/>
Args:</p>

<ul>
<li>xpath - xpath locator string.</li>
</ul>

<p>Note: The base path will be relative to this element&#39;s location.<br/><br/>
This will select all links under this element.<br/><br/>
<code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code>. <br/>
However, this will select all links in the page itself.<br/><br/>
<code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>. </p>

<p>用法:<br/><br/>
<code>find_elements_by_xpath(“//*”)</code></p>

<h5 id="toc_88">(59) find_element_by_class_name</h5>

<p><code>find_element_by_class_name(self, name)</code>:<br/><br/>
Finds element within this element&#39;s children by class name.<br/><br/>
通过元素class name属性定位元素.<br/><br/>
Args:  </p>

<ul>
<li>name - class name to search for.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_element_by_class_name(“android.widget.LinearLayout”)</code></p>

<h5 id="toc_89">(60) find_elements_by_class_name</h5>

<p><code>find_elements_by_class_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by class name.<br/><br/>
通过元素class name属性定位所有含有该属性的元素. <br/>
Args:  </p>

<ul>
<li>name - class name to search for.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_elements_by_class_name(“android.widget.LinearLayout”)</code>. </p>

<h5 id="toc_90">(61) find_element_by_css_selector</h5>

<p><code>find_element_by_css_selector(self, css_selector)</code>:<br/><br/>
Finds element within this element&#39;s children by CSS selector.<br/><br/>
通过CSS选择器定位元素. <br/>
Args:  </p>

<ul>
<li>css_selector - CSS selctor string, ex: &#39;a.nav#home&#39;</li>
</ul>

<h5 id="toc_91">(62) send_keys</h5>

<p><code>send_keys(self, *value)</code>:<br/><br/>
Simulates typing into the element.<br/><br/>
在元素中模拟输入（开启appium自带的输入法并配置了appium输入法后，可以输入中英文）. <br/>
Args:</p>

<ul>
<li>value - A string for typing, or setting form fields.  For setting file inputs, this could be a local file path.Use this to send simple key events or to fill out form fields:<br/>
<code>form_textfield = driver.find_element_by_name(&#39;username&#39;)</code><br/>
<code>form_textfield.send_keys(&quot;admin&quot;)</code><br/>
This can also be used to set file inputs.<br/>
<code>file_input = driver.find_element_by_name(&#39;profilePic&#39;)</code><br/>
<code>file_input.send_keys(&quot;path/to/profilepic.gif&quot;)</code><br/>
<code># Generally it&#39;s better to wrap the file path in one of the methods</code><br/>
<code># in os.path to return the actual path to support cross OS testing.</code><br/>
<code># file_input.send_keys(os.path.abspath(&quot;path/to/profilepic.gif&quot;))</code><br/>
<code>driver.element.send_keys(“中英”)</code></li>
</ul>

<h5 id="toc_92">(63) is_displayed</h5>

<p><code>is_displayed(self)</code>:<br/><br/>
Whether the element is visible to a user.<br/><br/>
此元素用户是否可见。简单地说就是隐藏元素和被控件挡住无法操作的元素（仅限 Selenium，appium是否实现了类似功能不是太确定）这一项都会返回 False. <br/>
用法:<br/><br/>
<code>driver.element.is_displayed()</code></p>

<h5 id="toc_93">(64) location_once_scrolled_into_view</h5>

<p><code>location_once_scrolled_into_view(self)</code>:<br/><br/>
 &quot;&quot;&quot;THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover. where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view.Returns the top lefthand corner location on the screen, or <code>None</code> if the element is not visible.</p>

<p>暂不知道用法</p>

<h5 id="toc_94">(65) size</h5>

<p><code>size(self)</code>:<br/><br/>
The size of the element.<br/><br/>
获取元素的大小（高和宽）.<br/><br/>
<code>new_size[&quot;height&quot;] = size[&quot;height&quot;]</code><br/><br/>
<code>new_size[&quot;width&quot;] = size[&quot;width&quot;]</code>   </p>

<p>用法:<br/><br/>
<code>driver.element.size</code></p>

<h5 id="toc_95">(66) value_of_css_property</h5>

<p><code>value_of_css_property(self, property_name)</code>:<br/><br/>
The value of a CSS property.<br/><br/>
CSS属性<br/><br/>
用法 暂不知  </p>

<h5 id="toc_96">(67) location</h5>

<p><code>location(self)</code>:<br/><br/>
The location of the element in the renderable canvas.<br/><br/>
获取元素左上角的坐标<br/><br/>
用法:<br/><br/>
<code>driver.element.location</code><br/><br/>
返回element的x坐标, int类型<br/><br/>
<code>driver.element.location.get(&#39;x&#39;)</code><br/><br/>
返回element的y坐标, int类型<br/><br/>
<code>driver.element.location.get(&#39;y&#39;)</code></p>

<h5 id="toc_97">(68) rect</h5>

<p><code>rect(self)</code>:<br/><br/>
A dictionary with the size and location of the element.<br/><br/>
元素的大小和位置的字典  </p>

<h5 id="toc_98">(69) screenshot_as_base64</h5>

<p><code>screenshot_as_base64(self)</code>:<br/><br/>
Gets the screenshot of the current element as a base64 encoded string.<br/><br/>
获取当前元素的截图为Base64编码的字符串<br/><br/>
Usage:<br/><br/>
<code>img_b64 = element.screenshot_as_base64</code></p>

<h5 id="toc_99">(70) execute_script</h5>

<p><code>execute_script(self, script, *args)</code>:<br/><br/>
Synchronously Executes JavaScript in the current window/frame.<br/><br/>
在当前窗口/框架（特指 Html 的 iframe ）同步执行 javascript 代码。你可以理解为如果这段代码是睡眠5秒，这五秒内主线程的 javascript 不会执行<br/><br/>
Args:  </p>

<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.<br/>
Usage:<br/>
<code>driver.execute_script(&#39;document.title&#39;)</code></li>
</ul>

<h5 id="toc_100">(71) execute_async_script</h5>

<p><code>execute_async_script(self, script, *args)</code>:<br/><br/>
Asynchronously Executes JavaScript in the current window/frame.<br/><br/>
插入 javascript 代码，只是这个是异步的，也就是如果你的代码是睡眠5秒，那么你只是自己在睡，页面的其他 javascript 代码还是照常执行<br/><br/>
Args:  </p>

<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.</li>
</ul>

<p>Usage:<br/><br/>
<code>driver.execute_async_script(&#39;document.title&#39;)</code></p>

<h5 id="toc_101">(72) current_url</h5>

<p><code>current_url(self)</code>:<br/><br/>
Gets the URL of the current page.<br/><br/>
获取当前页面的网址。<br/><br/>
Usage:<br/><br/>
<code>driver.current_url</code><br/>
用法<br/><br/>
<code>driver.current_url</code></p>

<h5 id="toc_102">(73) page_source</h5>

<p><code>page_source(self)</code>:<br/><br/>
Gets the source of the current page.<br/><br/>
获取当前页面的源<br/><br/>
Usage:<br/><br/>
<code>driver.page_source</code></p>

<h5 id="toc_103">(74) close</h5>

<p><code>close(self)</code>:<br/>
Closes the current window.<br/><br/>
关闭当前窗口<br/><br/>
Usage:<br/><br/>
<code>driver.close()</code></p>

<h5 id="toc_104">(75) quit</h5>

<p><code>quit(self)</code>:<br/><br/>
Quits the driver and closes every associated window.<br/><br/>
退出脚本运行并关闭每个相关的窗口连接<br/><br/>
Usage:<br/><br/>
<code>driver.quit()</code></p>

<p>参考资料:<br/><br/>
<a href="http://debugtalk.com/post/build-ideal-app-automation-test-framework/">打造心目中理想的自动化测试框(AppiumBooster)</a>   </p>

<p><a href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/">从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用</a>  </p>

<p><a href="https://github.com/appium/python-client">Python-Client的github文档地址</a></p>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>