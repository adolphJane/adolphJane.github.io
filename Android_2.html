<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15626502770827.html">
                
                  <h1>Android-Scroller详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Scroller是一个专门用于处理滚动效果的工具类，可能在大多数情况下，我们直接使用Scroller的场景并不多，但是很多大家所熟知的控件在内部都是使用Scroller来实现的，如ViewPager、ListView等。先撇开Scroller类不谈，其实任何一个控件都是可以滚动的，因为在View类当中有scrollTo()和scrollBy()这两个方法。这两个方法都是用于对View进行滚动的，那么它们之间有什么区别呢？简单点讲，scrollBy()方法是让View相对于当前的位置滚动某段距离，而scrollTo()方法则是让View相对于初始的位置滚动某段距离。<strong>注意，不管是scrollTo()还是scrollBy()方法，滚动的都是该View内部的内容</strong></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017092315061662718986.jpg" alt="2017092315061662718986.jpg"/></p>

<p>第一个参数x表示相对于当前位置横向移动的距离，正值向左移动，负值向右移动，单位是像素。第二个参数y表示相对于当前位置纵向移动的距离，正值向上移动，负值向下移动，单位是像素。</p>

<h2 id="toc_1">scrollBy()</h2>

<p><code>scrollBy()</code>方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直向右下方移动。</p>

<h2 id="toc_2">scrollTo()</h2>

<p><code>scrollTo()</code>方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。</p>

<h2 id="toc_3">Scroller</h2>

<p>目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。<br/>
Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p>

<ul>
<li>创建Scroller的实例</li>
<li>调用startScroll()方法来初始化滚动数据并刷新界面 </li>
<li>重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</li>
</ul>

<h2 id="toc_4">startScroll(int startX,int startY,int dx,int dy)</h2>

<ul>
<li>第一个参数是滚动开始时X的坐标</li>
<li>第二个参数是滚动开始时Y的坐标</li>
<li>第三个参数是横向滚动的距离,正值表示向左滚动</li>
<li>第四个参数是纵向滚动的距离，正值表示向上滚动。</li>
<li>紧接着调用invalidate()方法来刷新界面。</li>
</ul>

<h2 id="toc_5">startScroll (int startX,  int startY, int dx, int dy, int duration)</h2>

<p>同上</p>

<ul>
<li>第五个参数是滑动时间</li>
</ul>

<h2 id="toc_6">computeScroll()</h2>

<p>在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。</p>

<pre><code class="language-java">@Override
public void computeScroll() {
    // 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        invalidate();
    }
}
</code></pre>

<h2 id="toc_7">getScrollX() | getScrollY()</h2>

<p>返回当前view在x或者y方向上的滚动距离</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502771006.html">
                
                  <h1>Android-线程管理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Thread</h2>

<ul>
<li>继承Thread方式</li>
<li>实现Runnable接口</li>
</ul>

<h2 id="toc_1">Thread主要函数：</h2>

<ul>
<li><code>run()</code>//包含线程运行时所执行的代码</li>
<li><code>start()</code>//用于启动线程</li>
<li><code>sleep()/sleep(long millis)</code>//线程休眠，交出CPU，让CPU去执行其他的任务，然后线程进入阻塞状态，sleep方法不会释放锁</li>
<li><code>yield()</code>//使当前线程交出CPU，让CPU去执行其他的任务，但不会是线程进入阻塞状态，而是重置为就绪状态，yield方法不会释放锁</li>
<li><code>join()/join(long millis)/join(long millis,int nanoseconds)</code>//等待线程终止，直白的说 就是发起该子线程的线程 只有等待该子线程运行结束才能继续往下运行</li>
<li><code>wait()</code>//交出cpu，让CPU去执行其他的任务，让线程进入阻塞状态，同时也会释放锁</li>
<li><code>interrupt()</code>//中断线程，自stop函数过时之后，我们通过interrupt方法和isInterrupted()方法来停止正在运行的线程，注意只能中断已经处于阻塞的线程</li>
<li><code>getId()</code>//获取当前线程的ID</li>
<li><code>getName()/setName()</code>//获取和设置线程的名字</li>
<li><code>getPriority()/setPriority()</code>//获取和这是线程的优先级 一般property用1-10的整数表示，默认优先级是5，优先级最高是10，优先级高的线程被执行的机率高</li>
<li><code>setDaemon()/isDaemo()</code>//设置和判断是否是守护线程</li>
<li><code>currentThread()</code>//静态函数获取当前线程</li>
</ul>

<h2 id="toc_2">Thread线程主要状态</h2>

<ol>
<li>New  一旦被实例化之后就处于new状态</li>
<li>Runnable 调用了start函数之后就处于Runnable状态</li>
<li>Running 线程被cpu执行 调用run函数之后 就处于Running状态</li>
<li>Blocked 调用join()、sleep()、wait()使线程处于Blocked状态</li>
<li>Dead    线程的run()方法运行完毕或被中断或被异常退出，线程将会到达Dead状态</li>
</ol>

<h2 id="toc_3">如何停止一个线程</h2>

<p>通过interrupt方法和isInterrupted()方法来停止正在运行的线程，首先必须先让线程处于阻塞状态</p>

<h2 id="toc_4">Thread线程同步问题</h2>

<ul>
<li>同步函数</li>
<li>同步代码块</li>
<li>使用特殊域变量(volatile)实现线程同步</li>
</ul>

<h2 id="toc_5">ExecutorService线程池</h2>

<h3 id="toc_6">new Thread()的缺点</h3>

<ul>
<li>每次new Thread()耗费性能</li>
<li>调用new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。</li>
<li>不利于扩展，比如如定时执行、定期执行、线程中断<br/>
#### 采用线程池的优点</li>
<li>重用存在的线程，减少对象创建、消亡的开销，性能佳</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能</li>
</ul>

<p><strong>ExecutorService</strong></p>

<pre><code class="language-java">public interface ExecutorService extends Executor{
    void shutdown();//顺次地关闭ExecutorService,停止接收新的任务，等待所有已经提交的任务执行完毕之后，关闭ExecutorService

    List&lt;Runnable&gt; shutdownNow();//阻止等待任务启动并试图停止当前正在执行的任务，停止接收新的任务，返回处于等待的任务列表

    boolean isShutdown();//判断线程池是否已经关闭

    boolean isTerminated();//如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。

    
    boolean awaitTermination(long timeout, TimeUnit unit)//等待（阻塞）直到关闭或最长等待时间或发生中断,timeout - 最长等待时间 ,unit - timeout 参数的时间单位  如果此执行程序终止，则返回 true；如果终止前超时期满，则返回 false 

 
    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);//提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。

    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。

 
    Future&lt;?&gt; submit(Runnable task);//提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。
        throws InterruptedException;

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                                  long timeout, TimeUnit unit)//执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。
        throws InterruptedException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)//执行给定的任务，如果在给定的超时期满前某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。
        throws InterruptedException, ExecutionException;

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;   
}
</code></pre>

<p><strong>Executor接口</strong></p>

<pre><code class="language-java">public interface Executor {

    void execute(Runnable command);//执行已提交的 Runnable 任务对象。此接口提供一种将任务提交与每个任务将如何运行的机制（包括线程使用的细节、调度等）分离开来的方法
}
</code></pre>

<p><strong>Executors工厂类</strong></p>

<ul>
<li><code>newFixedThreadPool()</code>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。(运行结果：总共只会创建5个线程， 开始执行五个线程，当五个线程都处于活动状态，再次提交的任务都会加入队列等到其他线程运行结束，当线程处于空闲状态时会被下一个任务复用)</li>
<li><code>newCachedThreadPool()</code>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程(运行结果：可以看出缓存线程池大小是不定值，可以需要创建不同数量的线程，在使用缓存型池时，先查看池中有没有以前创建的线程，如果有，就复用.如果没有，就新建新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务)</li>
<li><code>newScheduledThreadPool()</code>创建一个定长线程池，支持定时及周期性任务执行<code>schedule(Runnable command,long delay, TimeUnit unit)</code>创建并执行在给定延迟后启用的一次性操作(运行结果和newFixedThreadPool类似，不同的是newScheduledThreadPool是延时一定时间之后才执行<code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnitunit)</code>  创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期；也就是将在 <code>initialDelay</code>后开始执行，然后在<code>initialDelay+period</code> 后执行，接着在 <code>initialDelay + 2 * period</code> 后执行，依此类推)<code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code>创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟</li>
<li><code>newSingleThreadExecutor()</code>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行(运行结果：只会创建一个线程，当上一个执行完之后才会执行第二个)通过<code>ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();</code>实现延时的单线程线程池。</li>
</ul>

<h2 id="toc_7">ThreadPoolExecutor</h2>

<p>ThreadPoolExecutor线程池用于管理线程任务队列、若干个线程。</p>

<h3 id="toc_8">1.ThreadPoolExecutor构造函数</h3>

<pre><code class="language-java">ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue);
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime, TimeUnit unit,BlockingQueue workQueue,RejectedExecutionHandler handler);
ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler) ;
ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory, RejectedExecutionHandler handler);
</code></pre>

<ul>
<li><em>corePoolSize</em>： 线程池维护线程的最少数量　　</li>
<li><em>maximumPoolSize</em>：线程池维护线程的最大数量　　</li>
<li><em>keepAliveTime</em>： 线程池维护线程所允许的空闲时间　　</li>
<li><em>unit</em>： 线程池维护线程所允许的空闲时间的单位　　</li>
<li><em>workQueue</em>： 线程池所使用的缓冲队列　　</li>
<li><em>threadFactory</em>：线程池用于创建线程　　</li>
<li><em>handler</em>： 线程池对拒绝任务的处理策略</li>
</ul>

<h3 id="toc_9">AsyncTask</h3>

<p>Android的AsyncTask比Handler更轻量级一些，适用于简单的异步处理。同时在处理单个后台任务时，AsyncTask的代码量更少并且更加轻量级。<br/>
AsyncTask定义了三种泛型类型 Params，Progress和Result。</p>

<ul>
<li>Params 启动任务执行的输入参数，比如HTTP请求的URL。</li>
<li>Progress 后台任务执行的百分比。</li>
<li>Result 后台执行任务最终返回的结果，比如String。<br/>
使用过AsyncTask 的同学都知道一个异步加载数据最少要重写以下这两个方法：</li>
<li>doInBackground(Params…) 后台执行，比较耗时的操作都可以放在这里。注意这里不能直接操作UI。此方法在后台线程执行，完成任务的主要工作，通常需要较长的时间。在执行过程中可以调用publicProgress(Progress…)来更新任务的进度。</li>
<li>onPostExecute(Result)  相当于Handler 处理UI的方式，在这里面可以使用在doInBackground 得到的结果处理操作UI。 此方法在主线程执行，任务执行的结果作为此方法的参数返回<br/>
有必要的话你还得重写以下这三个方法，但不是必须的：</li>
<li>onProgressUpdate(Progress…)   可以使用进度条增加用户体验度。 此方法在主线程执行，用于显示任务执行的进度。</li>
<li>onPreExecute()        这里是最终用户调用Excute时的接口，当任务执行之前开始调用此方法，可以在这里显示进度对话框。</li>
<li>onCancelled()             用户调用取消时，要做的操作<br/>
使用AsyncTask类，以下是几条必须遵守的准则：</li>
<li>Task的实例必须在UI thread中创建；</li>
<li>execute方法必须在UI thread中调用；</li>
<li>不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params...), onProgressUpdate(Progress...)这几个方法；</li>
<li>该task只能被执行一次，否则多次调用时将会出现异常；</li>
</ul>

<h3 id="toc_10">参考</h3>

<p><a href="http://www.cnblogs.com/whoislcj/p/5603277.html">Android线程管理</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502771669.html">
                
                  <h1>Android Matrix</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">Matrix的数学原理</h2>

<p>在Android中，如果你用Matrix进行过图像处理，那么一定知道Matrix这个类。Android中的Matrix是一个3 x 3的矩阵，其内容如下：  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833750324849.png" alt="1.png"/></p>

<p>Matrix的对图像的处理可分为四类基本变换：</p>

<ul>
<li>Translate ————    平移变换</li>
<li>Rotate        ————    旋转变换</li>
<li>Scale     ————    缩放变换</li>
<li>Skew          ————    错切变换</li>
</ul>

<p>从字面上理解，矩阵中的MSCALE用于处理缩放变换，MSKEW用于处理错切变换，MTRANS用于处理平移变换，MPERSP用于处理透视变换。实际中当然不能完全按照字面上的说法去理解Matrix。同时，在Android的文档中，未见到用Matrix进行透视变换的相关说明，所以本文也不讨论这方面的问题。这里需要把矩阵根据他们的作用划分为4块：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616374765871.png" alt="20170923150616374765871.png"/></p>

<p>如上图所示，这四块区域各有作用。后面会详细讲解各个作用，先来看看这个矩阵是如何影响图像的。先看看屏幕的坐标系：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616379323870.png" alt="20170923150616379323870.png"/></p>

<p>看上图，这里表示了屏幕的坐标系，其中的x，y轴是大家所熟知的，但是其实，一个物体他是存在于一个三维空间的，所以必然会有z轴。我们的屏幕，就像是一个窗口，透过它，我们看到了屏幕后面的世界，那里面有各种物体，我们看到的是映射在x，y平面上的一个投射图像。屏幕就像是一个镜头一样，将里面的物体映射到x，y平面上，成为一个二维的图像。那么如果，我们把屏幕这个镜头沿着z轴，拉远或者拉进，那么图像会有什么变化呢，肯定会变小或者变大。就好比坐在飞机上透过窗口看地面的汽车，和在地面上看到的大小是不同的。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616386136695.png" alt="20170923150616386136695.png"/></p>

<p>x，y分别代表x，y轴上的坐标，而1代表屏幕在z轴上的坐标为默认的。如果将1变大，那么屏幕会拉远， 图形会变小。</p>

<p>针对每种变换，Android提供了pre、set和post三种操作方式。其中</p>

<ul>
<li>set用于设置Matrix中的值。</li>
<li>pre是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。</li>
<li>post是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。</li>
</ul>

<p>除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。</p>

<p>下面我们来看看四种变换的具体情形。由于所有的图形都是有点组成，因此我们只需要考察一个点相关变换即可。</p>

<h3 id="toc_1">平移变换</h3>

<p>假定有一个点的坐标是 P(\(x_{0}\),\(y_{0}\)) ，将其移动到 P(x,y) ，再假定在x轴和y轴方向移动的大小分别为: \(\Delta\)x = x - \(x_{0}\) and \(\Delta\)y = y - \(y_{0}\)   </p>

<p>如下图所示：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833900863943.png" alt="20170301148833900863943.png"/>  </p>

<p>不难知道：<br/><br/>
x = \(x_{0}\) + \(\Delta\)x<br/><br/>
y = \(y_{0}\) + \(\Delta\)y    </p>

<p>如果用矩阵来表示的话，就可以写成：  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833910576102.png" alt="20170301148833910576102.png"/></p>

<h3 id="toc_2">旋转变换</h3>

<h4 id="toc_3">围绕坐标原点旋转：</h4>

<p>假定有一个点 P(\(x_{0}\),\(y_{0}\)) ，相对坐标原点 \(\theta\) 顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833915872714.png" alt="20170301148833915872714.png"/></p>

<p>那么，<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833921797142.png" alt="20170301148833921797142.png"/></p>

<p>如果用矩阵，就可以表示为：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833923074578.png" alt="20170301148833923074578.png"/></p>

<h4 id="toc_4">围绕某个点旋转</h4>

<p>如果是围绕某个点 P(\(x_{p}\),\(y_{p}\)) 顺时针旋转 \(\theta\) ，那么可以用矩阵表示为：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883392576953.png" alt="2017030114883392576953.png"/><br/><br/>
可以化为：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833927146486.png" alt="20170301148833927146486.png"/><br/><br/>
很显然<br/><br/>
1、<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833928967061.png" alt="20170301148833928967061.png"/>是将坐标原点移动到点 P(\(x_{p}\),\(y_{p}\)) 后， P(\(x_{0}\),\(y_{0}\)) 的新坐标。  </p>

<p>2、<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833934213059.png" alt="20170301148833934213059.png"/>是将上一步变换后的 P(\(x_{0}\),\(y_{0}\)) ，围绕新的坐标原点顺时针旋转 \(\theta\) 。<br/><br/>
3、<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833940633954.png" alt="20170301148833940633954.png"/><br/><br/>
经过上一步旋转变换后，再将坐标原点移回到原来的坐标原点。<br/><br/>
所以，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。  </p>

<p>同时，可以看到，上面的矩阵四块区域的切分也是因为矩阵乘法的操作决定的，由于这里的乘法运算中，左上角的四个值，可以和x，y值做乘法运算，所以可以影响到旋转等操作，而右上角的模块，只能做加法，所以只能影响到平移。右下角的模块主要管z轴，自然就可以进行等比的缩放了，左下角的模块一般不去动他，否则会把x，y值加入到z轴中来，会不可控。</p>

<h3 id="toc_5">缩放变换</h3>

<p>理论上而言，一个点是不存在什么缩放变换的，但考虑到所有图像都是由点组成，因此，如果图像在x轴和y轴方向分别放大k1和k2倍的话，那么图像中的所有点的x坐标和y坐标均会分别放大k1和k2倍，即<br/><br/>
x = \(k_{1}\)\(x_{0}\)<br/><br/>
y = \(k_{2}\)\(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833944726575.png" alt="20170301148833944726575.png"/><br/><br/>
缩放变换比较好理解，就不多说了。 </p>

<h3 id="toc_6">错切变换</h3>

<p>错切变换(skew)在数学上又称为Shear mapping(可译为“剪切变换”)或者Transvection(缩并)，它是一种比较特殊的线性变换。错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对应的y坐标(或者x坐标)则按比例发生平移，且平移的大小和该点到x轴(或y轴)的垂直距离成正比。错切变换，属于等面积变换，即一个形状在错切变换的前后，其面积是相等的。<br/><br/>
比如下图，各点的y坐标保持不变，但其x坐标则按比例发生了平移。这种情况将水平错切。  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833947362086.png" alt="20170301148833947362086.png"/><br/><br/>
下图各点的x坐标保持不变，但其y坐标则按比例发生了平移。这种情况叫垂直错切。  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833948852458.png" alt="20170301148833948852458.png"/>  </p>

<p>假定一个点 P(\(x_{0}\),\(y_{0}\)) 经过错切变换后得到 P(x,y) ，对于水平错切而言，应该有如下关系：<br/><br/>
x = \(x_{0}\) + k\(y_{0}\)<br/><br/>
y = \(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833957987910.png" alt="20170301148833957987910.png"/><br/><br/>
扩展到3 x 3的矩阵就是下面这样的形式：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833959011272.png" alt="20170301148833959011272.png"/><br/><br/>
同理，对于垂直错切，可以有：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833960187699.png" alt="20170301148833960187699.png"/><br/><br/>
在数学上严格的错切变换就是上面这样的。在Android中除了有上面说到的情况外，还可以同时进行水平、垂直错切，那么形式上就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833961263046.png" alt="20170301148833961263046.png"/></p>

<h3 id="toc_7">对称变换</h3>

<p>除了上面讲到的4中基本变换外，事实上，我们还可以利用Matrix，进行对称变换。所谓对称变换，就是经过变化后的图像和原图像是关于某个对称轴是对称的。比如，某点 P(\(x_{0}\),\(y_{0}\)) 经过对称变换后得到 P(x,y) ，</p>

<p>如果对称轴是x轴，那么，<br/><br/>
x = \(x_{0}\)<br/><br/>
y = -\(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834373561338.png" alt="20170301148834373561338.png"/><br/><br/>
如果对称轴是y轴，那么，<br/><br/>
x = -\(x_{0}\)<br/><br/>
y = \(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834375645689.png" alt="20170301148834375645689.png"/><br/><br/>
如果对称轴是y = x，如图：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834376584200.png" alt="20170301148834376584200.png"/><br/><br/>
那么，<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834377595408.png" alt="20170301148834377595408.png"/><br/><br/>
很容易可以解得：<br/><br/>
x = \(y_{0}\)<br/><br/>
y = \(x_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883437925984.png" alt="2017030114883437925984.png"/><br/><br/>
同样的道理，如果对称轴是y = -x，那么用矩阵表示就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834380928745.png" alt="20170301148834380928745.png"/><br/><br/>
特殊地，如果对称轴是y = kx，如下图：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834381851581.png" alt="20170301148834381851581.png"/><br/><br/>
那么，<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834382842810.png" alt="20170301148834382842810.png"/><br/><br/>
很容易可解得：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834383638888.png" alt="20170301148834383638888.png"/><br/><br/>
用矩阵表示就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/201703011488343844739.png" alt="201703011488343844739.png"/>  </p>

<p>当k = 0时，即y = 0，也就是对称轴为x轴的情况；当k趋于无穷大时，即x = 0，也就是对称轴为y轴的情况；当k =1时，即y = x，也就是对称轴为y = x的情况；当k = -1时，即y = -x，也就是对称轴为y = -x的情况。不难验证，这和我们前面说到的4中具体情况是相吻合的。<br/><br/>
如果对称轴是y = kx + b这样的情况，只需要在上面的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834385747500.png" alt="20170301148834385747500.png"/><br/><br/>
需要特别注意：在实际编程中，我们知道屏幕的y坐标的正向和数学中y坐标的正向刚好是相反的，所以在数学上y = x和屏幕上的y = -x才是真正的同一个东西，反之亦然。也就是说，如果要使图片在屏幕上看起来像按照数学意义上y = x对称，那么需使用这种转换：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834387269783.png" alt="20170301148834387269783.png"/><br/><br/>
要使图片在屏幕上看起来像按照数学意义上y = -x对称，那么需使用这种转换：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883438827302.png" alt="2017030114883438827302.png"/><br/><br/>
关于对称轴为y = kx 或y = kx + b的情况，同样需要考虑这方面的问题。</p>

<h3 id="toc_8">三角函数</h3>

<pre><code class="language-text">public void setSinCos(float sinValue, float cosValue, float px, float py)
public void setSinCos(float sinValue, float cosValue)
</code></pre>

<p>这个方法乍一看可能有点蒙，其实在前面的原理中，我们讲解了一个旋转的例子，他最终的矩阵效果是这样的：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616425357007.jpg" alt="20170923150616425357007.jpg"/></p>

<p>其实旋转，就是使用了这样的matrix，显而易见，这里的参数就清晰了。<br/><br/>
sinValue：对应图中的sin值<br/><br/>
cosValue：对应cos值<br/><br/>
px:中心的x坐标<br/><br/>
py：中心的y坐标<br/><br/>
看一个示例,我们把图像旋转90度，那么90度对应的sin和cos分别是1和0。  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616431122661.png" alt="20170923150616431122661.png"/></p>

<p>看代码如下：</p>

<pre><code class="language-java">Matrixmatrix = new Matrix();
matrix.setSinCos(1, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);
canvas.drawBitmap(bitmap, matrix, paint);123123
</code></pre>

<h3 id="toc_9">数值操作</h3>

<p>数值操作这一组方法可以帮助我们直接控制Matrix里面的数值。</p>

<h4 id="toc_10">set</h4>

<p><code>void set (Matrix src)</code>没有返回值，有一个参数，作用是将参数Matrix的数值复制到当前Matrix中。如果参数为空，则重置当前Matrix，相当于<code>reset()</code></p>

<h4 id="toc_11">reset</h4>

<p><code>void reset ()</code>重置当前Matrix(将当前Matrix重置为单位矩阵)。</p>

<h4 id="toc_12">setValues</h4>

<p><code>void setValues (float[] values)</code>setValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</p>

<h4 id="toc_13">getValues</h4>

<p><code>void getValues (float[] values)</code>很显然，getValues和setValues是一对方法，参数也是浮点型的一维数组，长度需要大于9，将Matrix中的数值拷贝进参数的前9位中。</p>

<h2 id="toc_14">基本方法解析</h2>

<p>讲解完了matrix作用于像素点的原理之后，我们逐个讲解它的方法。</p>

<pre><code class="language-java">public Matrix()
public Matrix(Matrix src)
</code></pre>

<p>构造函数有两个，第一个是直接创建一个单位矩阵，第二个是根据提供的矩阵创建一个新的矩阵（采用deep copy）<br/>
单位矩阵如下：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616404162667.png" alt="20170923150616404162667.png"/></p>

<pre><code class="language-java">public boolean isIdentity()//判断是否是单位矩阵
public boolean isAffine()//判断是否是仿射矩阵
</code></pre>

<p>是否是单位矩阵很简单，就不做讲解了，这里是否是仿射矩阵可能大家不好理解。<br/>
首先来看看什么是仿射变换。仿射变换其实就是二维坐标到二维坐标的线性变换，保持二维图形的“平直性”（即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（指保持二维图形间的相对位置关系不变，平行线还是平行线，而直线上点的位置顺序不变），可以通过一系列的原子变换的复合来实现，原子变换就包括：平移、缩放、翻转、旋转和错切。这里除了透视可以改变z轴以外，其他的变换基本都是上述的原子变换，所以，只要最后一行是0,0,1则是仿射矩阵。<code>public boolean rectStaysRect()</code>判断该矩阵是否可以将一个矩形依然变换为一个矩形。当矩阵是单位矩阵，或者只进行平移，缩放，以及旋转90度的倍数的时候，返回true。<code>public void reset()</code>重置矩阵为单位矩阵。<br/>
<code>public void setTranslate(float dx, float dy)</code>设置平移效果，参数分别是x，y上的平移量。<br/>
效果图如下：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616415154198.png" alt="20170923150616415154198.png"/></p>

<p>代码如下：</p>

<pre><code class="language-java">Matrix matrix = new Matrix();
canvas.drawBitmap(bitmap, matrix, paint);

matrix.setTranslate(100, 1000);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>

<h2 id="toc_15">代码验证</h2>

<p>在第一部分中讲到的各种图像变换的验证代码如下，一共列出了10种情况。如果要验证其中的某一种情况，只需将相应的代码反注释即可。试验中用到的图片：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883438981398.png" alt="2017030114883438981398.png"/><br/><br/>
其尺寸为162 x 251。  </p>

<p>每种变换的结果，请见代码之后的说明。</p>

<pre><code class="language-java">import android.app.Activity;  
import android.content.Context;  
import android.graphics.Bitmap;  
import android.graphics.BitmapFactory;  
import android.graphics.Canvas;  
import android.graphics.Matrix;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.MotionEvent;  
import android.view.View;  
import android.view.Window;  
import android.view.WindowManager;  
import android.view.View.OnTouchListener;  
import android.widget.ImageView;  
  
public class TestTransformMatrixActivity extends Activity  
implements  
OnTouchListener  
{  
    private TransformMatrixView view;  
    @Override  
    public void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);  
  
        view = new TransformMatrixView(this);  
        view.setScaleType(ImageView.ScaleType.MATRIX);  
        view.setOnTouchListener(this);  
          
        setContentView(view);  
    }  
      
    class TransformMatrixView extends ImageView  
    {  
        private Bitmap bitmap;  
        private Matrix matrix;  
        public TransformMatrixView(Context context)  
        {  
            super(context);  
            bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie);  
            matrix = new Matrix();  
        }  
  
        @Override  
        protected void onDraw(Canvas canvas)  
        {  
            // 画出原图像  
            canvas.drawBitmap(bitmap, 0, 0, null);  
            // 画出变换后的图像  
            canvas.drawBitmap(bitmap, matrix, null);  
            super.onDraw(canvas);  
        }  
  
        @Override  
        public void setImageMatrix(Matrix matrix)  
        {  
            this.matrix.set(matrix);  
            super.setImageMatrix(matrix);  
        }  
          
        public Bitmap getImageBitmap()  
        {  
            return bitmap;  
        }  
    }  
  
    public boolean onTouch(View v, MotionEvent e)  
    {  
        if(e.getAction() == MotionEvent.ACTION_UP)  
        {  
            Matrix matrix = new Matrix();  
            // 输出图像的宽度和高度(162 x 251)  
            Log.e(&quot;TestTransformMatrixActivity&quot;, &quot;image size: width x height = &quot; +  view.getImageBitmap().getWidth() + &quot; x &quot; + view.getImageBitmap().getHeight());  
            // 1. 平移  
            matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
            // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight()  
            view.setImageMatrix(matrix);  
              
            // 下面的代码是为了查看matrix中的元素  
            float[] matrixValues = new float[9];  
            matrix.getValues(matrixValues);  
            for(int i = 0; i &lt; 3; ++i)  
            {  
                String temp = new String();  
                for(int j = 0; j &lt; 3; ++j)  
                {  
                    temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
                }  
                Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
            }  
              
  
//          // 2. 旋转(围绕图像的中心点)  
//          matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
              
//          // 3. 旋转(围绕坐标原点) + 平移(效果同2)  
//          matrix.setRotate(45f);  
//          matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f);  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 4. 缩放  
//          matrix.setScale(2f, 2f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 5. 错切 - 水平  
//          matrix.setSkew(0.5f, 0f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠           
//          matrix.postTranslate(view.getImageBitmap().getWidth(), 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 6. 错切 - 垂直  
//          matrix.setSkew(0f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          7. 错切 - 水平 + 垂直  
//          matrix.setSkew(0.5f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 8. 对称 (水平对称)  
//          float matrix_values[] = {1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 9. 对称 - 垂直  
//          float matrix_values[] = {-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }     
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 10. 对称(对称轴为直线y = x)  
//          float matrix_values[] = {0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(),   
//                  view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
            view.invalidate();  
        }  
        return true;  
    }  
}
</code></pre>

<p>下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵</p>

<h3 id="toc_16">平移</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834397841218.png" alt="20170301148834397841218.png"/><br/><br/>
输出的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834399578654.png" alt="20170301148834399578654.png"/><br/><br/>
请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。</p>

<h3 id="toc_17">旋转(围绕图像的中心点)</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834401523528.png" alt="20170301148834401523528.png"/><br/>
输出的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834402755650.png" alt="20170301148834402755650.png"/>  </p>

<p><strong>它实际上是</strong> <br/>
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code><br/><br/>
这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式,<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
所产生的转换矩阵就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834407336074.png" alt="20170301148834407336074.png"/><br/><br/>
而<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code>的意思就是在上述矩阵的左边再乘以下面的矩阵：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883440946965.png" alt="2017030114883440946965.png"/><br/><br/>
关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。<br/><br/>
所以它实际上就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834415832436.png" alt="20170301148834415832436.png"/><br/><br/>
出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。</p>

<h3 id="toc_18">旋转(围绕坐标原点旋转，在加上两次平移，效果同2)</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834419441235.png" alt="20170301148834419441235.png"/><br/><br/>
根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道：<br/><br/>
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
等价于<br/><br/>
<code>matrix.setRotate(45f);</code><br/><br/>
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
其中matrix.setRotate(45f)对应的矩阵是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834424050901.png" alt="20170301148834424050901.png"/>  </p>

<p>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight()/ 2f)对应的矩阵是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834425298280.png" alt="20170301148834425298280.png"/>  </p>

<p>由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。  </p>

<p><code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f)</code>对应的矩阵是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834426293354.png" alt="20170301148834426293354.png"/><br/><br/>
这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。  </p>

<p>所以综合起来，  </p>

<p><code>matrix.setRotate(45f);</code><br/><br/>
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
对应的矩阵就是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834427273695.png" alt="20170301148834427273695.png"/><br/><br/>
这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834428250094.png" alt="20170301148834428250094.png"/><br/><br/>
因此，此处变换后的图像和2中变换后的图像时一样的。  </p>

<h3 id="toc_19">缩放变换</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834429635851.png" alt="20170301148834429635851.png"/><br/><br/>
程序所输出的两个矩阵分别是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443077762.png" alt="2017030114883443077762.png"/><br/><br/>
其中第二个矩阵，其实是下面两个矩阵相乘的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834431597151.png" alt="20170301148834431597151.png"/><br/><br/>
大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。  </p>

<h3 id="toc_20">错切变换(水平错切)</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443394822.png" alt="2017030114883443394822.png"/><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834434942666.png" alt="20170301148834434942666.png"/><br/><br/>
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443583409.png" alt="2017030114883443583409.png"/><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_21">错切变换(垂直错切)</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834436740060.png" alt="20170301148834436740060.png"/>  </p>

<p>代码所输出的两个矩阵分别是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834438464295.png" alt="20170301148834438464295.png"/><br/><br/>
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834439581151.png" alt="20170301148834439581151.png"/><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_22">错切变换(水平+垂直错切)</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834440579717.png" alt="20170301148834440579717.png"/><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834441593278.png" alt="20170301148834441593278.png"/><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883444261979.png" alt="2017030114883444261979.png"/><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。    </p>

<h3 id="toc_23">对称变换(水平对称)</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834443981714.png" alt="20170301148834443981714.png"/>  </p>

<p>代码所输出的两个各矩阵分别是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883444616294.png" alt="2017030114883444616294.png"/><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834447285645.png" alt="20170301148834447285645.png"/><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_24">对称变换(垂直对称)</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834448061705.png" alt="20170301148834448061705.png"/>  </p>

<p>代码所输出的两个矩阵分别是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834449886306.png" alt="20170301148834449886306.png"/><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834450718549.png" alt="20170301148834450718549.png"/><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_25">对称变换(对称轴为直线y = x)</h3>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834451545673.png" alt="20170301148834451545673.png"/><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834452594988.png" alt="20170301148834452594988.png"/><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834453180954.png" alt="20170301148834453180954.png"/><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_26">关于先乘和后乘的问题</h3>

<p>由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834454434026.png" alt="20170301148834454434026.png"/><br/><br/>
越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。  </p>

<p>当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate(\(\theta\))，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。  </p>

<h2 id="toc_27">进阶方法解析</h2>

<p>上面的基本方法中，有关于变换的set方法都可以带来不同的效果，但是每个set都会把上个效果清除掉，例如依次调用了setSkew,setTranslate，那么最终只有setTranslate会起作用，那么如何才和将两种效果复合呢。Matrix给我们提供了很多方法。但是主要都是2类：<br/>
preXXXX:以pre开头，例如preTranslate<br/>
postXXXX:以post开头，例如postScale<br/>
他们分别代表了前乘，和后乘。看一段代码：</p>

<pre><code class="language-java">Matrix matrix = new Matrix();
matrix.setTranslate(100, 1000);
matrix.preScale(0.5f, 0.5f);
</code></pre>

<p>这里matrix前乘了一个scale矩阵，换算成数学式如下：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/2017092315061645158599.png" alt="2017092315061645158599.png"/></p>

<p>从上面可以看出，最终得出的matrix既包含了缩放信息也有平移信息。<br/>
后乘自然就是matrix在后面，而缩放矩阵在前面，由于矩阵前后乘并不等价，也就导致了他们的效果不同。我们来看看后乘的结果：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616454160642.png" alt="20170923150616454160642.png"/></p>

<p>可以看到，结果跟上面不同，并且这也不是我们想要的结果，这里缩放没有更改，但是平移被减半了，换句话说，平移的距离也被缩放了。所以需要注意前后乘法的关系。<br/>
来看看他们对应的效果图：<br/><br/>
<strong>前乘：</strong></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616460519787.png" alt="20170923150616460519787.png"/></p>

<p><strong>后乘：</strong></p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616463626763.png" alt="20170923150616463626763.png"/></p>

<p>可以明显看到，后乘的平移距离受了影响。<br/>
了解清除了前后乘的意义，在使用的过程中，多个效果的叠加时，一样要注意，否则效果达不到预期。</p>

<h2 id="toc_28">其他方法解析</h2>

<p>matrix除了上面的方法外，还有一些其他的方法，这里依次解析</p>

<h3 id="toc_29">setRectToRect</h3>

<p><code>public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf)</code>将rect变换成rect，上面的rectStaysRect已经说过，要保持rect只能做缩放平移和选择90度的倍数，那么这里其实也是一样，只是这几种变化，这里通过stf参数来控制。<br/><br/>
<code>ScaleToFit</code> 有如下四个值：<br/><br/>
<code>FILL</code>: 可能会变换矩形的长宽比，保证变换和目标矩阵长宽一致。<br/><br/>
<code>START</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。左上对齐。<br/><br/>
<code>CENTER</code>: 保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。<br/><br/>
<code>END</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。右下对齐。<br/><br/>
这里使用谷歌的api demo的图片作为例子：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616472114007.png" alt="20170923150616472114007.png"/></p>

<h3 id="toc_30">setPolyToPoly</h3>

<p><code>public boolean setPolyToPoly(float[] src, int srcIndex,float[] dst, int dstIndex,int pointCount)</code>通过指定的0-4个点，原始坐标以及变化后的坐标，来得到一个变换矩阵。如果指定0个点则没有效果。<br/><br/>
下面通过例子分别说明1到4个点的可以达到的效果：</p>

<h4 id="toc_31">1个点，平移</h4>

<p>只指定一个点，可以达到平移效果：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616478770235.png" alt="20170923150616478770235.png"/></p>

<p>代码如下：</p>

<pre><code class="language-java">float[] src = {0, 0};
int DX = 300;
float[] dst = {0 + DX, 0 + DX};
matrix.setPolyToPoly(src, 0, dst, 0, 1);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>

<h4 id="toc_32">2个点，旋转或者缩放</h4>

<p>两个点，可以达到旋转效果或者缩放效果，缩放比较简单，这里我们来看旋转效果，一个点指定中心，一点指出旋转的效果</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616485313647.png" alt="20170923150616485313647.png"/></p>

<p>代码如下</p>

<pre><code class="language-java">int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {bw / 2, bh / 2, bw, 0};
float[] dst = {bw / 2, bh / 2, bw / 2 + bh / 2, bh / 2 + bw / 2};
matrix.setPolyToPoly(src, 0, dst, 0, 2);
canvas.drawBitmap(bitmap, matrix, paint);123456123456
</code></pre>

<p>图片的中心点作为旋转的中心，前后不变，右上角变化到了下方，所以导致图片旋转了90度。</p>

<h4 id="toc_33">3个点，错切</h4>

<p>使用3个点，可以产生错切效果，指定3个顶点，一个固定，另外两个移动。<br/><br/>
看图：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616492474600.png" alt="20170923150616492474600.png"/></p>

<p>代码如下：</p>

<pre><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0,0, 0, bh,bw,bh};
float[] dst = {0, 0, 200, bh, bw + 200, bh};
matrix.setPolyToPoly(src, 0, dst, 0, 3);
canvas.drawBitmap(bitmap, matrix, paint);12345671234567
</code></pre>

<h4 id="toc_34">4个点，透视</h4>

<p>透视就是观察的角度变化了。导致投射到平面上的二维图像变化了。<br/>
我们看下面的例子，更容易理解：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616497319034.png" alt="20170923150616497319034.png"/></p>

<p>图片看起来好像倾斜了，实现特别简单：</p>

<pre><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0, 0, 0, bh, bw, bh, bw, 0};
int DX = 100;
float[] dst = {0 + DX, 0, 0, bh, bw, bh, bw - DX, 0};
matrix.setPolyToPoly(src, 0, dst, 0, 4);
canvas.drawBitmap(bitmap, matrix, paint);1234567812345678
</code></pre>

<p>可以看到，只是把左右两个顶点往里面收拢了，这样就得出了一个有3d效果的透视图。</p>

<h3 id="toc_35">invert</h3>

<p><code>public boolean invert(Matrix inverse)</code>反转当前矩阵，如果能反转就返回true并将反转后的值写入inverse，否则返回false。当前矩阵*inverse=单位矩阵。<br/><br/>
反转前后有什么效果，我们来看看示例：</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616503373152.png" alt="20170923150616503373152.png"/></p>

<p>可以看到，反转之后，其实是对效果的一种反转。</p>

<h3 id="toc_36">mapPoints</h3>

<pre><code class="language-java">public void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex,int pointCount)
public void mapPoints(float[] dst, float[] src)
public void mapPoints(float[] pts)
</code></pre>

<p>映射点的值到指定的数组中，这个方法可以在矩阵变换以后，给出指定点的值。</p>

<ul>
<li>dst：指定写入的数组<br/></li>
<li>dstIndex：写入的起始索引，x，y两个坐标算作一对，索引的单位是对，也就是经过两个值才加1</li>
<li>src：指定要计算的点</li>
<li>srcIndex：要计算的点的索引</li>
<li>pointCount：需要计算的点的个数，每个点有两个值，x和y。</li>
</ul>

<h3 id="toc_37">mapVectors</h3>

<pre><code class="language-java">public void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex,int vectorCount)
public void mapVectors(float[] dst, float[] src)
public void mapVectors(float[] vecs)

</code></pre>

<p>与上面的mapPoionts基本类似，这里是将一个矩阵作用于一个向量，由于向量的平移前后是相等的，所以这个方法不会对translate相关的方法产生反应，如果只是调用了translate相关的方法，那么得到的值和原本的一致。</p>

<h3 id="toc_38">mapRect</h3>

<pre><code class="language-java">public boolean mapRect(RectF dst, RectF src)
public boolean mapRect(RectF rect)
</code></pre>

<p>返回值即是调用的rectStaysRect()，这个方法前面有讲过，这里把src中指定的矩形的左上角和右下角的两个点的坐标，写入dst中。</p>

<h3 id="toc_39">mapRadius</h3>

<p><code>public float mapRadius(float radius)</code>返回一个圆圈半径的平均值，将matrix作用于一个指定radius半径的圆，随后返回的平均半径。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502771839.html">
                
                  <h1>Android MVP模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>MVP 这种模式出现已经很久了，在网上有些关于 MVP 开源代码2014年就有了。近期由于面试都有问这方面的问题，所以来了解一下。网上关于 MVP 的资料其实也不少，通常都要把 MVP 和 MVC 做一下比较，MVC通常一般都会应用，这篇文章就来学习下MVP模式。</p>

<h2 id="toc_0">一、什么是MVP？</h2>

<p>随着UI创建技术的功能日益增强，UI层也履行着越来越多的职责。为了更好地细分视图(View)与模型(Model)的功能，让View专注于处理数据的可视化以及与用户的交互，同时让Model只关系数据的处理，基于MVC概念的MVP(Model-View-Presenter)模式应运而生。<br/><br/>
MVP 是 Model、Presenter、View 的缩写，三个部分的关系如下图所示。<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819849456583.png" alt="20170227148819849456583.png"/> </p>

<p>在 Android 项目中，负责界面展示的模块（所有的 Activitiy 、Fragment以及 View 的子类）都可以划分到 View 这个层次，所有的业务逻辑处理（请求网络数据、数据库读取等）可以划分到 Model 这个层次，为了使得 View 和 Model 之间松耦合，用 Presenter 帮助解耦。所以可以猜测，在具体实现中 Presenter 类肯定要持有 View 和 Model 的引用。现在来说一下，上图中三个箭头的意思。流程是这样子的，从左到右看，比如我们刚进入一个 Activity，那么这个 Activity 做为 View 层，肯定需要通知 Presenter 加载数据，而Presenter会继续调用Model层加载数据，等Model加载完毕后，回调给 Presenter，Presenter 持有View引用，再通知View更新界面。</p>

<h3 id="toc_1">MVP模式的三个角色的作用：</h3>

<ul>
<li>Presenter-中介<br/>
主演沟通View和Model的桥梁，他从Model获取数据后返回给View层，是的View层和Model层之间没有耦合，从而奖业务逻辑从View层抽离。</li>
<li>Model-房主<br/>
Model主要提供数据的存取、检索、操纵功能，Presenter需要通过Model层存储、获取数据，Model层就想是一个仓库。</li>
<li>View-用户<br/>
负责绘制UI元素、与用户进行交互(在Android中体现为Activity)。View通常是指Activity、Fragment或者某个View控件。它含有一个Presenter成员变量，同时它需要实现一个逻辑接口，奖View上的操作转交割Presenter进行实现，最后Presenter调用View逻辑接口将结果返回给View元素。</li>
<li>View interface<br/>
需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;</li>
</ul>

<h3 id="toc_2">为什么使用MVP模式</h3>

<p>在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中View，它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由Presenter处理）.<br/><br/>
另外，回想一下你在开发Android应用时是如何对代码逻辑进行单元测试的？是否每次都要将应用部署到Android模拟器或真机上，然后通过模拟用户操作进行测试？然而由于Android平台的特性，每次部署都耗费了大量的时间，这直接导致开发效率的降低。而在MVP模式中，处理复杂逻辑的Presenter是通过interface与View(Activity)进行交互的，这说明了什么？说明我们可以通过自定义类实现这个interface来模拟Activity的行为对Presenter进行单元测试，省去了大量的部署及测试的时间。</p>

<h3 id="toc_3">MVP与MVC的异同</h3>

<p>MVC模式与MVP模式都作为用来分离UI层与业务层的一种开发模式被应用了很多年。在我们选择一种开发模式时，首先需要了解一下这种模式的利弊：<br/><br/>
无论MVC或是MVP模式都不可避免地存在一个弊端：<br/><br/>
          <strong>额外的代码复杂度及学习成本。</strong><br/>
这就导致了这两种开发模式也许并不是很小型应用。<br/>
但比起他们的优点，这点弊端基本可以忽略了：</p>

<ul>
<li>(1)降低耦合度</li>
<li>(2)模块职责划分明显</li>
<li>(3)利于测试驱动开发</li>
<li>(4)代码复用</li>
<li>(5)隐藏数据</li>
<li>(6)代码灵活性</li>
</ul>

<h4 id="toc_4">MVP模式：</h4>

<ul>
<li>View不直接与Model交互，而是通过与Presenter交互来与Model间接交互</li>
<li>Presenter与View的交互是通过接口来进行的，更有利于添加单元测试</li>
<li>通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑<br/></li>
</ul>

<h4 id="toc_5">MVC模式：</h4>

<ul>
<li>View可以与Model直接交互</li>
<li>Controller是基于行为的，并且可以被多个View共享</li>
<li>可以负责决定显示哪个View</li>
</ul>

<h2 id="toc_6">二、MVP的效果</h2>

<p>现在我们来实现这样一个Android上的Demo(如图)：可以从EditText读取用户信息并存取，也可以根据ID来从后台读出用户信息并显示。<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819875942251.png" alt="20170227148819875942251.png"/>  </p>

<p>页面布局很简单，就不介绍了。下面根据MVP原则来进行编码：<br/><br/>
先来看看java文件的目录结构：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819877439872.png" alt="20170227148819877439872.png"/>  </p>

<p>可以发现，Presenter与Model、View都是通过接口来进行交互的，既降低耦合也方便进行单元测试。</p>

<ul>
<li><p>(1)首先我们需要一个UserBean，用来保存用户信息</p>
<pre><code class="language-java">public class UserBean {  
private String mFirstName ;  <br/>
private String mLastName ;  <br/>
public UserBean (String firstName, String lastName) {  <br/>
    this.mFirstName = firstName;  <br/>
    this.mLastName = lastName;  <br/>
}  <br/>
public String getFirstName() {  <br/>
    return mFirstName ;  <br/>
}  <br/>
public String getLastName() {  <br/>
    return mLastName ;  <br/>
}<br/>
}
</code></pre></li>
<li><p>(2)再来看看View接口：<br/><br/>
根据需求可知，View可以对ID、FirstName、LastName这三个EditText进行读操作，对FirstName和LastName进行写操作，由此定义IUserView接口：</p>
<pre><code class="language-java">public interface IUserView {  
   int getID();  <br/>
   String getFristName();  <br/>
   String getLastName();  <br/>
   void setFirstName (String firstName);  <br/>
   void setLastName (String lastName);  <br/>
}
</code></pre></li>
<li><p>(3)Model接口：<br/><br/>
同样，Model也需要对这三个字段进行读写操作，并存储在某个载体内(这不是我们所关心的，可以存在内存、文件、数据库或者远程服务器，但对于Presenter及View无影响),定义IUserModel接口：</p></li>
</ul>

<pre><code class="language-java">public interface IUserModel {  
       void setID (int id);  
       void setFirstName (String firstName);  
       void setLastName (String lastName);  
       int getID();  
       UserBean load (int id);//通过id读取user信息,返回一个UserBean  
}
</code></pre>

<ul>
<li><p>(4)Presenter:<br/><br/>
至此，Presenter就能通过接口与View及Model进行交互了：</p>
<pre><code class="language-java">public class UserPresenter {  
   private IUserView mUserView ;  <br/>
   private IUserModel mUserModel ;  <br/>
   public UserPresenter (IUserView view) {  <br/>
         mUserView = view;  <br/>
         mUserModel = new UserModel ();  <br/>
   }  <br/>
   public void saveUser( int id , String firstName , String lastName) {  <br/>
         mUserModel .setID (id );  <br/>
         mUserModel .setFirstName (firstName );  <br/>
         mUserModel .setLastName (lastName );  <br/>
   }  <br/>
   public void loadUser( int id ) {  <br/>
         UserBean user = mUserModel .load (id );  <br/>
         mUserrView .setFirstName (user .getFirstName ());//通过调用IUserView的方法来更新显示  <br/>
         mUserView .setLastName (user .getLastName ());  <br/>
   }  <br/>
}
</code></pre></li>
<li><p>(5)UserActivity:<br/>
UserActivity实现了IUserView及View.OnClickListener接口，同时有一个UserPresenter成员变量：</p>
<pre><code class="language-java">public class UserActivity extends Activity implements OnClickListener,  
         IUserView {  <br/>
   private EditText mFirstNameEditText , mLastNameEditText , mIdEditText ;  <br/>
   private Button mSaveButton , mLoadButton ;  <br/>
   private UserPresenter mUserPresenter ; 
</code></pre></li>
</ul>

<p>重写了OnClick方法：  </p>

<pre><code class="language-java">@Override  
       public void onClick(View v) {  
             // TODO Auto-generated method stub  
             switch ( v. getId()) {  
             case R .id .saveButton :  
                   mUserPresenter .saveUser (getID (), getFristName (),  
                               getLastName ());  
                   break ;  
             case R .id .loadButton :  
                   mUserPresenter .loadUser (getID ());  
                   break ;  
             default :  
                   break ;  
             }  
       }
</code></pre>

<p>可以看到，View只负责处理与用户进行交互，并把数据相关的逻辑操作都扔给了Presenter去做。而Presenter调用Model处理完数据之后，再通过IUserView更新View显示的信息。</p>

<h2 id="toc_7">三、MVP的Android伪代码实现</h2>

<ul>
<li>首先需要一个Presenter，作为View和Model的中间人
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819813736752.png" alt="20170227148819813736752.png"/></li>
<li>然后你还需要一个View以及ViewImpl接口
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022714881981564410.png" alt="2017022714881981564410.png"/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819816221120.png" alt="20170227148819816221120.png"/></li>
<li>最后你还需要Model一个ModelImpl接口
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170227148819817269813.png" alt="20170227148819817269813.png"/></li>
</ul>

<h2 id="toc_8">四、不必纠结是MVC还是MVP</h2>

<blockquote>
<p>MVC和MVP的最终目的就是要数据和UI分离，互相不影响。那么如何能不必纠结而做到呢？？你听说过面向对象吗？听过再听听我的理解~</p>
</blockquote>

<ul>
<li>面向对象<br/>
封装、多态，继承。老师好像也都是这么教的，那么到底说明是多态封装继承呢？</li>
<li>封装<br/>
封装就是将用户不想看到的东西封装起来，可以用到面向对象中的 Private<br/>
属性，将用户不想看到的内容写在这里面。比如收音机上的播放功能，用户不用知道收益及如何播放，它只需要知道摁下这个键能播放即可。</li>
<li>多态<br/>
多态就是一个对象的多种表现形态，主要表现为：行为多态和状态多态。<br/>
行为多态就好比一个父亲有多个孩子，每个孩子都不一样，但是都是同一个父亲；状态多态就好比每个孩子在一天中有好多个状态变现，有吃饭，学习，睡觉。</li>
<li>继承？不！我想说的是对象！<br/>
我的一个朋友告诉我继承其实是对面向对象的最大误解。继承我们可以理解成一个对象他有多个小对象组成；比如人这个对象是由手脚，脑袋...等其它小对象组成。因此继承我们可以不去记住，我们只要对每个对象有深刻的认识即可把对象描述清楚！</li>
</ul>

<blockquote>
<p>那么MVC、MVP与面向对象有什么关系呢？？  </p>
</blockquote>

<p>首先MVC和MVP都是要求数据和UI之间互不影响，那么面向对象不就是吗！？</p>

<ul>
<li><p>面向对象View?<br/><br/>
对象也就是我们说的用户也就是MC或者MVP中View，用户需要什么我们就展示给其什么，不需要的我们将其封装起来提供一个方法给你调用即可，这是不是和MVC或者MVP中很像！</p></li>
<li><p>面向对象Model?<br/><br/>
同时面向对象也是需要将对象的行为细分，比如人可以跑，可以游泳...这是不是和MVC中的Model一样，需要处理用户不同的操作。</p></li>
<li><p>面向对象Controller?<br/><br/>
最后面向对象也是需要一个状态去控制的，比如人的大脑。通过大脑去协调手和脚的平衡。</p></li>
</ul>

<h2 id="toc_9">五、内存泄露问题</h2>

<p>由上可见，Presenter中持有View接口对象，这个接口对象实际为MainActivity.this，Modle中也同时拥有Presenter对象实例，当MainActivity要销毁时，Presenter中有Modle在获取数据，那么问题来了，这个Activity还能正常销毁吗？   </p>

<p><strong>答案是不能！</strong> </p>

<p>当Modle在获取数据时，不做处理，它就一直持有Presenter对象，而Presenter对象又持有Activity对象，这条GC链不剪断，Activity就无法被完整回收。<br/><br/>
换句话说：Presenter不销毁，Activity就无法正常被回收。  </p>

<p>解决MVP的内存泄露</p>

<p>Presenter在Activity的onDestroy方法回调时执行资源释放操作，或者在Presenter引用View对象时使用更加容易回收的软引用，弱应用。 <br/>
比如示例代码：<br/><br/>
<strong>Activity</strong>  </p>

<pre><code class="language-java">@Override
    public void onDestroy() {
        super.onDestroy();
        mPresenter.destroy();
        mPresenter = null;
    }
</code></pre>

<p><strong>Presenter</strong>  </p>

<pre><code class="language-java">public void destroy() {
    view = null;
    if(modle != null) {
        modle.cancleTasks();
        modle = null;
    }
}
</code></pre>

<p><strong>Modle</strong></p>

<pre><code class="language-java">public void cancleTasks() {
    // TODO 终止线程池ThreadPool.shutDown()，AsyncTask.cancle()，或者调用框架的取消任务api
}
</code></pre>

<p>个人总结</p>

<p>因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！</p>

<h2 id="toc_10">六、总结</h2>

<p>最后重新梳理一下 MVP 的编写方式。</p>

<ul>
<li>1、 根据项目需求，写一个 XXView 接口。然后让对应的 Activity/Fragment 实现这个接口。View 层基本搞定！</li>
<li>2、编写 Model 层，主要就是网络数据请求了或者其他什么耗时操作，实现方式尽情发挥你的想象，但是最后一定需要用 Presenter 层定义的接口，回调给 Presenter 通知 View 层 更新数据。</li>
<li>3、编写 Presenter 层，Presenter 层需要持有 View 层和 Model层的引用，并且实现 Presenter 层定义的回调接口。在回调接口中调用 View 层的代码 进行界面更新，最重要的是，有一个调用通过Model层的方法，在此方法中，调用 Model 层请求数据。</li>
<li>4、回到View 层的Activity ，调用 Presenter 层获取数据。到此完成。</li>
</ul>

<p><strong>因为面向MVP接口编程，可适应需求变更，所以MVP适用于比较大的项目；因为其简化了Activity和Fragmnt的职责，可大大减少View层的代码量，比起MVC中Activity，Fragment动不动上千行的代码量，简直优雅！</strong><br/><br/>
<strong>备注：</strong>为了遵守面向接口编程的原则，做了一下接口的抽取。如Presenter 中 实现了 JokePresenter 接口，Model 层中实现了 JokeModel 接口。好了，如果在阅读中，发现了有错误的地方，还望指正。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502772268.html">
                
                  <h1>Android 快速开发框架</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、Afinal</h2>

<ul>
<li><strong>官方介绍</strong>：</li>
</ul>

<p>Afinal是一个Android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对Android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。详情请通过以下网址查看。</p>

<p>Afinal 是一个android的sqlite orm 和 ioc 框架。同时封装了android中的http框架，使其更加简单易用；</p>

<p>使用finalBitmap，无需考虑bitmap在android中加载的时候oom的问题和快速滑动的时候图片加载位置错位等问题。</p>

<p>Afinal的宗旨是简洁，快速。约定大于配置的方式。尽量一行代码完成所有事情。</p>

<ul>
<li><p><strong>项目地址</strong>：<a href="https://github.com/yangfuhai/afinal">https://github.com/yangfuhai/afinal</a></p></li>
<li><p><strong>功能</strong>：</p></li>
</ul>

<p>一个android的ioc，orm框架，内置了四大模块功能：FinalAcitivity,FinalBitmap,FinalDb,FinalHttp。通过finalActivity，我们可以通过注解的方式进行绑定ui和事件。通过finalBitmap，我们可以方便的加载bitmap图片，而无需考虑oom等问题。通过finalDB模块，我们一行代码就可以对android的sqlite数据库进行增删改查。通过FinalHttp模块，我们可以以ajax形式请求http数据。</p>

<p>优点：功能比较全面，文档完善，代码效率比较高。</p>

<p>缺点：没有项目demo，框架的时间比较久，代码冗余比较多（这也是无可避免的），文档比较老跟不上代码更新进度。</p>

<p>（这个评价是其他高人评的，他自己也有写了框架。我个人觉得以前Afinal算是经典了 用的人多）。</p>

<h2 id="toc_1">二、xUtils</h2>

<ul>
<li><strong>Git地址</strong>：<a href="https://github.com/wyouflf/xUtils">https://github.com/wyouflf/xUtils</a></li>
</ul>

<p>xUtils：可以说是Afinal的升级版。</p>

<p>xUtils 包含了很多实用的android工具。</p>

<p>xUtils 支持大文件上传，更全面的http请求协议支持(10种谓词)，拥有更加灵活的ORM，更多的事件注解支持且不受混淆影响...</p>

<p>xUitls 最低兼容android 2.2 (api level 8)</p>

<h2 id="toc_2">三、ThinkAndroid</h2>

<ul>
<li><p><strong>项目地址</strong>：<a href="https://github.com/white-cat/ThinkAndroid">https://github.com/white-cat/ThinkAndroid</a></p></li>
<li><p><strong>官方介绍</strong>：</p></li>
</ul>

<p>ThinkAndroid是一个免费的开源的、简易的、遵循Apache2开源协议发布的Android开发框架，其开发宗旨是简单、快速的进行Android应用程序的开发，包含Android mvc、简易sqlite orm、ioc模块、封装Android httpclitent的http模块,具有快速构建文件缓存功能，无需考虑缓存文件的格式，都可以非常轻松的实现缓存，它还基于文件缓存模块实现了图片缓存功能，在android中加载的图片的时候，对oom的问题，和对加载图片错位的问题都轻易解决。他还包括了一个手机开发中经常应用的实用工具类，如日志管理，配置文件管理，android下载器模块，网络切换检测等等工具</p>

<ul>
<li><p><strong>优点</strong>：功能看起来比较完善。个人觉得名字起的好。</p></li>
<li><p><strong>缺点</strong>：从2013年就停止维护了，没有项目文档。</p></li>
</ul>

<h2 id="toc_3">四、LoonAndroid</h2>

<ul>
<li><strong>官方介绍</strong>：</li>
</ul>

<p>如果你想看ui方面的东西，这里没有，想要看牛逼的效果这里也没有。这只是纯实现功能的框架，它的目标是节省代码量，降低耦合，让代码层次看起来更清晰。整个框架一部分是网上的，一部分是我改的，为了适应我的编码习惯，还有一部分像orm完全是网上的组件。在此感谢那些朋友们。 整个框架式的初衷是为了偷懒，之前都是一个功能一个jar，做项目的时候拉进去，这样对于我来说依然还是比较麻烦。最后就导致我把所有的jar做成了一个工具集合包。 有很多框架都含有这个工具集合里的功能，这些不一定都好用，因为这是根据我个人使用喜欢来实现的，如果你们有自己的想法，可以自己把架包解压了以后，源码拉出来改动下。 目前很多框架都用到了注解，除了androidannotations没有入侵我们应用的代码以外，其他的基本上都有，要么是必须继承框架里面的activity,要么是必须在activity的oncreat里面调用某个方法。 整个框架式不同于androidannotations，Roboguice等ioc框架，这是一个类似spring的实现方式。在整应用的生命周期中找到切入点，然后对activity的生命周期进行拦截，然后插入自己的功能。</p>

<ul>
<li><p><strong>开源地址</strong>：<a href="https://github.com/gdpancheng/LoonAndroid">https://github.com/gdpancheng/LoonAndroid</a></p></li>
<li><p><strong>功能</strong>：</p>
<ol>
<li>自动注入框架（只需要继承框架内的application既可）</li>
<li>图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）</li>
<li>网络请求模块（继承了基本上现在所有的http请求）</li>
<li>eventbus（集成一个开源的框架）</li>
<li>验证框架（集成开源框架）</li>
<li>json解析（支持解析成集合或者对象）</li>
<li>数据库（不知道是哪位写的 忘记了）</li>
<li>多线程断点下载（自动判断是否支持多线程，判断是否是重定向）</li>
<li>自动更新模块</li>
<li>一系列工具类</li>
</ol></li>
<li><p><strong>优点</strong>：功能多</p></li>
<li><p><strong>缺点</strong>：文档方面</p></li>
</ul>

<h2 id="toc_4">五、KJFrameForAndroid</h2>

<ul>
<li><p><strong>项目地址</strong>：<a href="https://github.com/kymjs/KJFrameForAndroid">https://github.com/kymjs/KJFrameForAndroid</a></p></li>
<li><p><strong>官方介绍</strong>：</p></li>
</ul>

<p>KJFrameForAndroid 又叫KJLibrary，是一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用；<br/>
KJFrameForAndroid的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。我们提倡用最少的代码，完成最多的操作，用最高的效率，完成最复杂的功能。</p>

<ul>
<li><strong>功能</strong>：</li>
</ul>

<p>一个android的orm 和 ioc 框架。同时封装了android中的Bitmap与Http操作的框架，使其更加简单易用； KJFrameForAndroid开发框架的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。总共分为五大模块：UILibrary，UtilsLibrary，HttpLibrary，BitmapLibrary，DBLibrary。</p>

<ul>
<li><p><strong>优点</strong>：功能比较全面，代码效率很高，文档完善，有项目demo，出来的比较晚借鉴了很多大型框架经验。</p></li>
<li><p><strong>缺点</strong>：项目文档是html页面，查看起来很不方便，项目交流平台没多少人说话（难道大神都是不说话的？）</p></li>
</ul>

<p>（这两个评价是KJFrameForAndroid的作者对自己的评价，个人觉得作者是个天才。他的评价可能刚写完网上发布后写的。我在给他更新评价。因为现在已经过去了几个月一直在时不时更新。功能很全，项目文档也很全面，而且代码里注释最多 这方面这个很难得。交流平台人很多挺热闹，作者希望更热闹这样框架越来越完善。对于初学者希望看到Demo更完善）</p>

<h2 id="toc_5">六、dhroid</h2>

<ul>
<li><strong>官方介绍</strong>：</li>
</ul>

<p>dhroid 是基于android 平台, 极速开发框架，其核心设计目标是开发迅速、代码量少、学习简单、功能强大、轻量级、易扩展.使你更快,更好的开发商业级别应用</p>

<ul>
<li><p><strong>开源地址</strong>: <a href="http://git.oschina.net/tengzhinei/dhroid">http://git.oschina.net/tengzhinei/dhroid</a></p></li>
<li><p><strong>功能</strong>：</p>
<ol>
<li>Ioc容器: (用过spring的都知道)视图注入,对象注入,接口注入,解决类依赖关系</li>
<li>Eventbus: android平台事件总线框架,独创延时事件,事件管理轻松</li>
<li>Dhnet: 网络http请求的解决方案,使用简单,减少代码,自带多种网络访问缓存策略</li>
<li>adapter模块: 数据绑定轻松,不用写多余的adapter,天生网络支持(一行代码搞定加载,刷新问题)</li>
<li>DhDb: android中sqlite的最轻量orm框架(增删改查轻松搞定)</li>
<li>Perference: android自带Perference 升级版,让你的Perference更强大,更方便</li>
</ol></li>
</ul>

<p>工具集合 JSONUtil(安全处理json),ViewUtil(数据绑定更快) ThreadWorker(异步任务工具)...</p>

<ul>
<li><strong>优点</strong>：功能全面，有demo，作者也是为公司开发的框架。</li>
<li><strong>缺点</strong>：文档方面现在不是很好，就eoe上的那些。</li>
</ul>

<h2 id="toc_6">七、SmartAndroid</h2>

<ul>
<li><p><strong>项目地址</strong>：<a href="http://www.aplesson.com/smartAndroid/demos">http://www.aplesson.com/smartAndroid/demos</a></p></li>
<li><p><strong>官方介绍</strong>：</p></li>
</ul>

<p>SmartAndroid是一套给 Android开发者使用的应用程序开发框架和工具包。它提供一套丰富的标准库以及简单的接口和逻辑结构，其目的是使开发人员更快速地进行项目开发。使用 SmartAndroid可以减少代码的编写量，并将你的精力投入到项目的创造性开发上。</p>

<ul>
<li><strong>功能</strong>：</li>
</ul>

<p>SmartAndroid 拥有全范围的类库，可以完成大多数通常需要的APP开发任务，包括： 异步网络操作相关所有功能、强大的图片处理操作、轻量级ORM数据库Sqlite库、zip操作 、动画特效、Html等解析采集、事件总线EventBus/Otto、Gson(Json)、AQuery、主流所有UI控件（例如：ActionbarSherlock，SlidingMenu，BottomView，Actionbar，DragListView等10多种UI库）等。</p>

<ul>
<li><p><strong>优点</strong>：功能非常全，超出你索要、文档完善（作者很全面，官方网站是web响应式网站，框架里功能有UI各种特效应该最全了，一直更新中）</p></li>
<li><p><strong>缺点</strong>：jar包大点？（功能多不可避免，不是问题），在线文档（随响应式的手机访问也方便，但是网速慢就不好了，页面打开不是很流畅）</p></li>
</ul>

<h2 id="toc_7">八、andBase</h2>

<ul>
<li><strong>官方介绍</strong>：</li>
</ul>

<p>andbase是为Android开发者量身打造的一款开源类库产品</p>

<ul>
<li><p><strong>开源地址</strong>：<a href="https://code.jd.com/zhaoqp2010_m/andbase">https://code.jd.com/zhaoqp2010_m/andbase</a></p></li>
<li><p><strong>功能</strong>：</p>
<ol>
<li>andbase中包含了大量的开发常用手段。如网络下载，多线程与线程池的管理，数据库ORM，图片缓存管理，图片文件下载上传，Http请求工具，常用工具类（字符串，日期，文件处理，图片处理工具类等），能够使您的应用在团队开发中减少冗余代码，很大的提高了代码的维护性与开发高效性，能很好的规避由于开发疏忽而导致常犯的错误。</li>
<li>andbase封装了大量的常用控件。如list分页，下拉刷新，图片轮播，表格，多线程下载器，侧边栏，图片上传，轮子选择，图表，Tab滑动，日历选择器等。</li>
<li>强大的AbActivity，您没有理由不继承它。继承它你能够获得一个简单强大可设置的操作栏，以及一系列的简单调用，如弹出框，提示框，进度框，副操作栏等。</li>
<li>提供效率较高图片缓存管理策略，使内存大幅度节省，利用率提高，效率提高。程序中要管理大量的图片资源，andbase提供简单的方法，几步完成下载与显示，并支持缩放，裁剪，缓存功能。</li>
<li>封装了大量常见工具类。包括日期，字符，文件，图片等各种处理函数，多而全。</li>
<li>用andbase大量减少handler的使用，而采用回调函数，代码更整洁。handler会产生大量代码，并且不好维护，andbase对handler进行了封装。</li>
<li>简单轻量支持注解自动建表的ORM框架（支持一/多对多的关联操作）。写sql，建表，工作量大，andbase提供更傻瓜异步增删改查工具类。</li>
<li>异步请求http框架，网络请求标准化，支持文件上传下载，get，post，进度显示。包含了异步与http请求的工具类，实用。</li>
<li>热情的支持群体。</li>
</ol></li>
<li><p><strong>优点</strong>：功能很全，demo做的好 、API文档完善、接近完美</p></li>
<li><p><strong>缺点</strong>：希望文档更详细些。</p></li>
</ul>

<h2 id="toc_8">九、AndroidAnnotations</h2>

<ul>
<li><p><strong>项目地址</strong>：<a href="https://github.com/excilys/androidannotations">https://github.com/excilys/androidannotations</a></p></li>
<li><p><strong>功能</strong>：</p></li>
</ul>

<p>完全注解框架，一切皆为注解：声明控件，绑定控件，设置监听，setcontentview，长按事件，异步线程，全部通过注解实现。</p>

<ul>
<li><p><strong>优点</strong>：完全的注解，使开发起来更加便利，程序员写的代码也更少。</p></li>
<li><p><strong>缺点</strong>：文档是全英文的加上功能比较少没有具体研究，由于一切都是注解，感觉效率不高，不过根据官方介绍说并不是使用的反射加载，所以效率比一般注解高很多。</p></li>
</ul>

<h2 id="toc_9">十、volley</h2>

<ul>
<li><p><strong>项目地址</strong>： <a href="https://github.com/smanikandan14/Volley-demo">https://github.com/smanikandan14/Volley-demo</a></p></li>
<li><p><strong>功能</strong>：Volley是Android平台上的网络通信库，能使网络通信更快，更简单，更健壮异步加载网络图片、网络数据</p></li>
<li><p><strong>优点</strong>：Google官方推荐，请看去年的开发者大会介绍。</p></li>
<li><p><strong>缺点</strong>：功能比较少，只有网络数据加载和网络图片加载</p></li>
</ul>

<h2 id="toc_10">总结</h2>

<p>以上的开发框架网上都可以下载源码，也有demo实例的。当然我没分析和对比框架的效率性能，但是都非常实用，其作者大部分是个人，都是些牛人或天才。你可以直接使用，也可以把有用跳出来用，至少有很多使用工具。如果有发现Bug，作者希望把bug交给他。</p>

<p>Afinal 和 xUtils简单实用但是demo和更新的问题。</p>

<p>KJFrameForAndroid 算是新出的，功能也多，效率也应该好，代码也注释多 用起来也很方便。</p>

<p>Dhroid 作者自己公司的框架，也可以直接请教。</p>

<p>SmartAndroid 强劲的框架功能俱全。</p>

<p>andBase 出来早各个方面算是完整的吧。</p>

<p>转自：<a href="http://blog.csdn.net/buddyuu/article/details/40503471">http://blog.csdn.net/buddyuu/article/details/40503471</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502772407.html">
                
                  <h1>Android StatusBar学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>一直以来，iOS 设备上状态栏背景色和图标文字颜色的灵活可变性始终受到设计人员的青睐，有意地恰当地融入到 App 的各种界面设计当中，更好地提升用户体验。  </p>

<p>由于系统的限制，在老版本的安卓系统中，Android App 无法做到这些，产生一些设计上的遗憾。幸运的是，自<strong>4.4 版本（API 19)</strong>以后，Android 系统开始支持状态栏的定制，并被纳入 Android 设计规范当中，Android App 在设计上迈出了重要的一步。</p>

<h2 id="toc_1">“沉浸式状态栏” VS “透明状态栏”</h2>

<p>一般来说，Android 默认的状态栏样式表现为黑底白字，如果我们应用的标题栏背景色也为黑色，那就能与状态栏很好地衔接在一起，体验极佳。反之，如果为其他的颜色，整个界面的呈现效果就会大打折扣。</p>

<p>幸运的是，Android 4.4 版本开始，系统提供了相应的 API，支持状态栏全透明化，界面 Content View 可以延伸到状态栏上，填充状态栏背景色。而在 Android 5.0 版本开始，系统在此基础上做了进一步优化和规范，能够实现动态改变状态栏背景色，在透明度上默认呈现为半透明化，可定制化程度更高。</p>

<p>在此基础上，最终要做到我们的应用呈现在 Android 各个系统版本上的效果如图所示：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170223148785204419031.png" alt="20170223148785204419031.png"/></p>

<p>关于 Android 4.4 版本开始的状态栏变化，许多人喜欢称之为“沉浸式状态栏”，但从系统提供的 API 命名上可以看出，核心词汇为 “Translucent”，故准确来讲，这种效果又应该称之为“透明状态栏”。知乎上对于这两种叫法也颇有争议，具体内容可参考话题：为什么在国内会有很多用户把「透明栏」（Translucent Bars）称作 「沉浸式顶栏」？。可能对于设计师而言，沉浸式还是透明式的称呼有所区别，但对于广大开发者而言，无足轻重，我们所关注的应该是如何实现这种效果，并能够很好的兼容到各个版本中。</p>

<h2 id="toc_2">相关 API 介绍</h2>

<p>一般来说，目前在 Android 项目中我们都会使用 Toolbar 替代 ActionBar 来实现导航栏，除此之外，要实现透明状态栏效果，还需要了解两个相关 API，下面逐一介绍一下：</p>

<h3 id="toc_3">一：</h3>

<p><code>&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</code><br/>
也可以在代码中实现（据说，在代码中实现兼容性更好，style 资源中设置的方式在某些国产手机厂商定制的系统中存在一些问题）:</p>

<pre><code class="language-java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
    WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes();
    local LayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);
}
</code></pre>

<p>顾名思义，该属性能够实现透明状态栏效果，是在 Android 4.4 版本引入的，也就是兼容至 API 19 及以上版本。使用该属性设置主题后，内容布局向上延伸至状态栏，并且在不同版本的系统中呈现效果也有所区别，如图所示：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170223148785226694094.png" alt="20170223148785226694094.png"/></p>

<p>显然，在 API 19 及更高版本上，Toolbar 内容延伸至状态栏上去了，出现重叠问题，此时，就需要使用到另一个属性了。</p>

<h3 id="toc_4">二：</h3>

<p><code>android:fitsSystemWindows=&quot;true&quot;</code>  </p>

<blockquote>
<p>Boolean internal attribute to adjust view layout based on system windows such as the status bar. If true, adjusts the padding of this view to leave space for the system windows. Will only take effect if this view is in a non-embedded activity.</p>
</blockquote>

<p>用在 layout 布局文件中。官方文档给出了很明确的介绍，大致是说能够将使用该属性的视图与系统窗口（如状态栏）保持一定的 padding 间距。所以如果我们在 toolbar 中设置了该属性，就能够解决 <item name="android:windowTranslucentStatus">true</item> 配置带来的视图延伸问题，使呈现效果达到文章开始所示图中的效果。</p>

<h2 id="toc_5">使用案例分析</h2>

<p><strong>res/values/styles 文件中定义基础主题样式：</strong></p>

<pre><code class="language-markup">    &lt;style name=&quot;BaseTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;/&gt;
   &lt;style name=&quot;AppTheme&quot; parent=&quot;BaseTheme&quot;&gt;
   &lt;/style&gt;
</code></pre>

<p><strong>res/values-v19/styles 文件中定义兼容主题样式：</strong></p>

<pre><code class="language-markup">    &lt;style name=&quot;AppTheme&quot; parent=&quot;BaseTheme&quot;&gt;
   &lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;
   &lt;/style&gt;
</code></pre>

<p><strong>然后在 AndroidManifest.xml 文件中使用全局主题样式：</strong></p>

<pre><code class="language-markup">&lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;Samples&quot;
        android:supportsRtl=&quot;true&quot;
        android:name=&quot;.MyApplication&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;
</code></pre>

<p>新建一个 layout 布局文件，单独定义 toolbar 内容，在应用中的其他 Activity 界面布局中使用 include 标签潜入引用：</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;android.support.v7.widget.Toolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:id=&quot;@+id/tb_toolbar&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:minHeight=&quot;?actionBarSize&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:fitsSystemWindows=&quot;true&quot;
    app:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;
    app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;
    app:title=&quot;@string/app_name&quot;
    app:titleTextColor=&quot;@android:color/white&quot;&gt;

&lt;/android.support.v7.widget.Toolbar&gt;
</code></pre>

<p>这里使用<code>android:fitsSystemWindows=&quot;true&quot;</code>属性解决内容试图向上延伸的问题。实际上，也可以使用 <code>android:paddingTop=&quot;@dimen/toolbar_padding_top&quot;</code> 的方式解决，toolbar_padding_top 间距为状态栏高度，在大多数机器上状态栏高度为 25dp，当然也可以通过代码动态获取状态栏高度并设置到 Toolbar 的 paddingTop 属性上。需要注意的是，这里要做兼容判断，比如在 res/values/dimens.xml 中定义toolbar_padding_top 高度为 0dp，在 res/values-v19/dimens.xml 中为 25dp，确保兼容 Android 4.4 以下版本。</p>

<p>基本上，做到这些就能够实现文章开头处图中的效果。值得注意的是，有时候如果想在 Android 5.0 及以上版本的系统中也做到全透明效果，或者说状态栏与导航栏的颜色一致，还可以做进一步兼容处理，毕竟自 5.0 版本开始，系统对于状态栏背景色的定制提供了更好的 API。如 res/values-v21/styles.xml 中定义：</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;

    &lt;style name=&quot;AppTheme&quot; parent=&quot;BaseTheme&quot;&gt;
        &lt;item name=&quot;android:colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
        &lt;item name=&quot;android:colorPrimaryDark&quot;&gt;@color/colorPrimary&lt;/item&gt;
        &lt;item name=&quot;android:colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;/style&gt;

&lt;/resources&gt;
</code></pre>

<p>说明一点，使用这种处理方式后，5.0 系统中应用的状态栏背景色可随意定制，同时与使用 <code>&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</code> 样式有所不同的是，该处理方式不会引起内容视图的向上延伸，所以不需要在 layout 布局文件中额外添加 android:fitsSystemWindows=&quot;true&quot; 属性。当然，添加了也无所谓，毕竟还要兼容 4.4 到 5.0 之间的版本。</p>

<h2 id="toc_6">状态栏白底黑字</h2>

<p>前面我们说过，虽然说 4.4 版本开始，可以实现透明状态栏效果，也就是可以通过各种手段实现修改状态栏背景色，但是状态栏图标和文字的颜色默认为白色，这个是无法像 iOS 系统那样，根据应用的整体色调动态修改。如果恰好 Toolbar 的背景色为白色，为了保持一致，将状态栏背景色调为白色的话，就会与状态栏的白色内容发生冲突，导致其内容无法凸显，这个体验肯定无法被用户接受。  </p>

<p>所以，遇见这种 Toolbar 或者说导航栏背景色为白色的情况，一般有两种处理方式：第一种，不修改状态栏背景色，通常默认为黑色背景白色内容；第二种，修改状态栏背景色为淡黑色，这样既能显示状态栏内容，又能与白色导航栏弱显衔接，比如支付宝 App 就是这么做的：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170223148785322655441.png" alt="20170223148785322655441.png"/></p>

<p>像上图这种处理方式较黑色状态栏来说，相对缓和一些，那能不能做到修改状态栏内容的颜色呢，比如白底黑字？大家知道，Android 系统是开源的，国内的各家手机厂商都做了一些自己的定制，像部分厂商定制的系统就提供了相应的 API 供开发人员做适配工作。比如，部分厂商就提供了相应的 API 来修改状态栏内容颜色，实现状态栏白底黑字效果，如图：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170223148785324052944.png" alt="20170223148785324052944.png"/></p>

<p>具体做法就是，在代码中判断系统类型，与提供修改状态内容颜色的系统匹配，使用其特定的 API 操作即可。目前开放这种定制 API 的系统已知有 MIUI 和 Flyme 系统，具体实现代码可参考：</p>

<ul>
<li><a href="http://dev.xiaomi.com/doc/p=4769/index.html">小米 MIUI 6 系统</a></li>
<li><a href="http://open-wiki.flyme.cn/index.php?title=%E7%8A%B6%E6%80%81%E6%A0%8F%E5%8F%98%E8%89%B2">魅族 Flyme 系统</a></li>
</ul>

<p>其实，在 Android 6.0（API 23）及更高的版本上，系统也开始提供了对应的 API 来实现浅色调背景的状态栏效果，可将状态栏图标和文字内容改为黑色样式，实现方式为：</p>

<pre><code class="language-java">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
    getWindow().getDecorView().setSystemUiVisibility(
        View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);
        getWindow().setStatusBarColor(Color.TRANSPARENT);
}
</code></pre>

<p>但是不知国内厂商在定制系统时是否对此有做处理，能否兼容这个 API ？不过，貌似微博 App 是这么做的，大家感兴趣地不妨一试。</p>

<h2 id="toc_7">注意事项</h2>

<p>除了上述 Toolbar 与 状态栏在背景色上的衔接，App 中常见还有这样一种设计，以微博个人主页为例，如图所示：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170223148785341741351.png" alt="20170223148785341741351.png"/></p>

<p>页面顶部的图片内容延伸至状态栏中，这种做法其实就是单独使用 <code>&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;</code> 样式，不在 layout 布局文件中添加 <code>android:fitsSystemWindows=&quot;true&quot;</code>属性即可。</p>

<p>还有一点，通常我们会在资源文件中定义不同版本的主题样式，再在 <application> 标签中统一设置，然后所有的 Activity 都能使用这个主题样式。但存在这样一种情况，Activity 由不同的 Fragment 组成，然后不同 Fragment 在状态栏的呈现上有所不同，比如有的 Fragment 顶部使用 Toolbar 与状态栏衔接，有的顶部直接使用图片延伸至状态栏上甚至不会用到 Toolbar，如图所示：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170223148785345291771.png" alt="20170223148785345291771.png"/></p>

<p>由于 Fragment 是无法像 Activity 那样在 AndroidManifest.xml 中单独设置主题样式的，所以这里可以这样做：宿主 Activity 还是使用透明样式，以满足图片延伸的 Fragment 页面效果，其他使用 Toolbar 的 Fragment，在其 Layout 布局文件顶部单独定义一个 View，让其延伸至状态栏，然后在代码中根据不同版本系统设置其高度，4.4 版本以下设置该 View 高度为0，4.4 及以上版本设置为设备状态栏高度，通过代码获取状态高度的方式如下：</p>

<pre><code class="language-java">/**
 * 获取状态栏高度
 * @param activity
 * @return
 */
public static int getStatusBarHeight(Activity activity){
    Rect rect = new Rect();
    activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);
    return rect.top==0 ? 60 : rect.top;
}
</code></pre>

<p>最后再补充一点，大家知道，长按 Toolbar 中 Menu Item 时会显示一个 Toast 提示，内容来自 Item 定义时对应的 title 属性，通常显示如图所示：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170223148785352797212.png" alt="20170223148785352797212.png"/></p>

<p>但是，如果你误将 fitsSystemWindows 属性设置在了 style 样式文件中，比如：</p>

<pre><code class="language-java">&lt;style name=&quot;BaseTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;item name=&quot;android:fitsSystemWindows&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>将会导致下图效果：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170223148785356810318.png" alt="20170223148785356810318.png"/><br/>
可见，Menu Options Item 长按时弹出的 Toast 样式没了内容间距，显然很丑。所以，记得将该属性设置在正确的布局文件中，不要设置成全局的。</p>

<h2 id="toc_8">相关拓展</h2>

<p>以上便是有关 Android 4.4 开始的状态栏背景色相关知识，可以看出 4.4 、5.0 、6.0 版本作为三个分水岭，根据需要做好相关适配工作即可。还有一种通过 <code>setSystemUiVisibility()</code> 方法设置状态栏的方式，还能实现状态栏的显示与隐藏交互效果，具体可参考这篇文章：</p>

<ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/51763825">http://blog.csdn.net/guolin_blog/article/details/51763825</a></li>
</ul>

<p>GitHub 上对于 Android 4.4 版本开始的状态栏背景色的处理有一个开源库，感兴趣地朋友也可借鉴参考一番，地址如下：</p>

<ul>
<li><a href="https://github.com/jgilfelt/SystemBarTint">https://github.com/jgilfelt/SystemBarTint</a></li>
</ul>

<p>有关 Toolbar 替换 ActionBar 的使用，可以我之前总结的一篇文章，地址为：</p>

<ul>
<li><a href="http://yifeng.studio/2016/10/12/android-toolbar/">http://yifeng.studio/2016/10/12/android-toolbar/</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502772451.html">
                
                  <h1>Android Studio必备插件整理</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android studio常用插件，可极大简化开发，增强开发效率。</p>

<h2 id="toc_1">一、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7369-android-butterknife-zelezny">Android ButterKnife Zelezny</a></h2>

<p>ButterKnife 注解生成器，使用起来非常简单方便，使用ButterKnife的有福了！配合ButterKnife实现注解，从此不用写findViewById，想着就爽啊。在Activity，Fragment，Adapter中选中布局xml的资源id自动生成butterknife注解。<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/201702202121zelezny_animated.gif" alt="201702202121zelezny_animated.gif"/></p>

<h2 id="toc_2">二、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7298-selectorchapek-for-android">SelectorChapek for Android</a></h2>

<p>设计师给我们提供好了各种资源，每个按钮都要写一个selector是不是很麻烦？这么这个插件就为解决这个问题而生，你只需要做的是告诉设计师们按照规范命名就好了，其他一键搞定。按照不同状态(normal、pressed)的标准命名后，右键文件树Generate Android Selectors见<a href="https://github.com/inmite/android-selector-chapek">inmite/android-selector-chapek · GitHub</a>。 通过资源文件命名自动生成Selector文件。<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752603531749.png" alt="20170220148752603531749.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752532933779.png" alt="20170220148752532933779.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752606656680.png" alt="20170220148752606656680.png"/></p>

<h2 id="toc_3">三、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7654-gsonformat">GsonFormat</a></h2>

<p>快速将json字符串转换成一个Java Bean，免去我们根据json字符串手写对应Java Bean的过程。现在大多数服务端api都以json数据格式返回，而客户端需要根据api接口生成相应的实体类，这个插件把这个过程自动化了，赶紧使用起来吧。<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022076961screenshot_15729.png" alt="2017022076961screenshot_15729.png"/></p>

<h2 id="toc_4">四、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7332-android-parcelable-code-generator">Android Parcelable Code Generator</a></h2>

<p>Android中的序列化有两种方式，分别是实现Serializable接口和Parcelable接口，但在Android中是推荐使用Parcelable，只不过我们这种方式要比Serializable方式要繁琐，那么有了这个插件一切就ok了。JavaBean序列化，快速实现Parcelable接口。<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752548073022.png" alt="20170220148752548073022.png"/></p>

<h2 id="toc_5">五、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7269-genymotion">Genymotion</a></h2>

<p>这个不解释,速度较快的android模拟器!!!</p>

<h2 id="toc_6">六、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7595-android-code-generator">Android Code Generator</a></h2>

<p>根据布局文件快速生成对应的Activity，Fragment，Adapter，Menu。<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022047055screenshot_14834.png" alt="2017022047055screenshot_14834.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022040056screenshot_14833.png" alt="2017022040056screenshot_14833.png"/></p>

<h2 id="toc_7">七、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7275-codeglance">CodeGlance</a></h2>

<p>在右边可以预览代码，实现快速定位<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752573288050.png" alt="20170220148752573288050.png"/></p>

<h2 id="toc_8">八、<a href="https://plugins.jetbrains.com/androidstudio/plugin/3847-findbugs-idea">findBugs-IDEA</a></h2>

<p>查找bug的插件，Android Studio也提供了代码审查的功能（Analyze-Inspect Code…）<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752579143883.png" alt="20170220148752579143883.png"/></p>

<h2 id="toc_9">九、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7856-adb-wifi">ADB WIFI</a></h2>

<p>使用wifi无线调试你的app，无需root权限<br/><br/>
也可参考以下文章：<br/><br/>
<a href="http://www.jianshu.com/p/21d1b65d92a4">Android wifi无线调试App新玩法ADB WIFI</a><br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752583764864.png" alt="20170220148752583764864.png"/></p>

<h2 id="toc_10">十、<a href="https://github.com/succlz123/AndroidPixelDimenGenerator">AndroidPixelDimenGenerator</a></h2>

<p>Android Studio自动生成dimen.xml文件插件</p>

<h2 id="toc_11">十一、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7972-android-styler">Android Styler</a></h2>

<p>根据xml自动生成style代码的插件<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752589625883.png" alt="20170220148752589625883.png"/><br/>
Usage:</p>

<ul>
<li>copy lines with future style from your layout.xml file</li>
<li>paste it to styles.xml file with Ctrl+Shift+D (or context menu)</li>
<li>enter name of new style in the modal window</li>
<li>your style is prepared!</li>
</ul>

<h2 id="toc_12">十二、<a href="https://plugins.jetbrains.com/androidstudio/plugin/7658-android-drawable-importer">Android Drawable Importer</a></h2>

<p>这是一个非常强大的图片导入插件。它导入Android图标与Material图标的Drawable ，批量导入Drawable ，多源导入Drawable（即导入某张图片各种dpi对应的图片）<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752595242357.png" alt="20170220148752595242357.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752596473216.png" alt="20170220148752596473216.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752597669112.png" alt="20170220148752597669112.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752598441950.png" alt="20170220148752598441950.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752598985838.png" alt="20170220148752598985838.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752599470122.png" alt="20170220148752599470122.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752600211562.png" alt="20170220148752600211562.png"/></p>

<h2 id="toc_13">十三、<a href="https://github.com/square/leakcanary">LeakCanary</a></h2>

<p>帮助你在开发阶段方便的检测出内存泄露的问题，使用起来更简单方便。<br/><br/>
可以参考以下文章：<br/><br/>
<a href="http://www.liaohuqiu.net/cn/posts/leak-canary-read-me/">LeakCanary 中文使用说明</a><br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752612729962.png" alt="20170220148752612729962.png"/></p>

<h2 id="toc_14">十四、<a href="https://github.com/u3shadow/RemoveButterKnife">RemoveButterKnife</a></h2>

<p>ButterKnife这个第三方库每次更新之后，绑定view的注解都会改变，从bind,到inject，再到bindview，搞得很多人都不敢升级，一旦升级，就会有巨量的代码需要手动修改，非常痛苦<br/><br/>
当我们有一些非常棒的代码需要拿到其他项目使用，但是我们发现，那个项目对第三方库的使用是有限制的，我们不能使用butterknife，这时候，我们又得从注解改回findviewbyid<br/><br/>
针对上面的两种情况，如果view比较少还好说，如果有几十个view，那么我们一个个的手动删除注解，写findviewbyid语句，简直是一场噩梦（别问我为什么知道这是噩梦）<br/><br/>
所以，这种有规律又重复简单的工作为什么不能用一个插件来实现呢？于是RemoveButterKnife的想法就出现了。<br/><br/>
<a href="http://www.u3coding.com/2016/06/24/androidstudio-plugin-removebutterknife-di/">具体介绍</a><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022015484687474703a2f2f7777772e7533636f64696e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30362f312e676966.gif" alt="2017022015484687474703a2f2f7777772e7533636f64696e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30362f312e676966.gif"/></p>

<h2 id="toc_15">十五、<a href="https://github.com/zhonghanwen/AndroidProguardPlugin">AndroidProguardPlugin</a></h2>

<p>一键生成项目混淆代码插件，值得你安装~(不过目前可能有些第三方项目的混淆还未添加完全)<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022038041androidproguard1.gif" alt="2017022038041androidproguard1.gif"/></p>

<h2 id="toc_16">十六、<a href="https://plugins.jetbrains.com/androidstudio/plugin/1833-sexy-editor">Sexy Editor</a></h2>

<p>设置AS代码编辑区的背景图</p>

<h2 id="toc_17">十七、<a href="https://github.com/dmytrodanylyk/folding-plugin">folding-plugin</a></h2>

<p>布局文件分组的插件<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752640181897.png" alt="20170220148752640181897.png"/></p>

<h2 id="toc_18">十八、<a href="https://github.com/JerzyPuchalski/Android-DPI-Calculator">Android-DPI-Calculator</a></h2>

<p>DPI计算插件<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752641920734.png" alt="20170220148752641920734.png"/><br/>
使用：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752643315168.png" alt="20170220148752643315168.png"/><br/>
或者：<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022014875264458133.png" alt="2017022014875264458133.png"/></p>

<h2 id="toc_19">十九、<a href="https://plugins.jetbrains.com/idea/plugin/7405-android-studio-prettify">Android Studio Prettify</a></h2>

<p>可以将代码中的字符串写在string.xml文件中<br/><br/>
选中字符串鼠标右键选择图中所示<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022014875265102378.png" alt="2017022014875265102378.png"/><br/><br/>
这个插件还可以自动书写findViewById<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220946screenshot_14418.png" alt="20170220946screenshot_14418.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/2017022014875265419694.png" alt="2017022014875265419694.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752655222061.png" alt="20170220148752655222061.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752656067022.png" alt="20170220148752656067022.png"/></p>

<h2 id="toc_20">二十、<a href="https://plugins.jetbrains.com/idea/plugin/8006-material-theme-ui">Material Theme UI</a></h2>

<p>添加Material主题到你的AS<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752659388840.png" alt="20170220148752659388840.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752660126901.png" alt="20170220148752660126901.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752660955431.png" alt="20170220148752660955431.png"/></p>

<h2 id="toc_21">二十一、<a href="https://plugins.jetbrains.com/idea/plugin/1065-checkstyle-idea">CheckStyle-IDEA</a></h2>

<p>CheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。</p>

<h2 id="toc_22">二十二、<a href="https://github.com/Skykai521/ECTranslation">ECTranslation</a></h2>

<p>Android Studio Plugin,Translate English to Chinese. Android Studio 翻译插件,可以将英文翻译为中文。<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752673862872.png" alt="20170220148752673862872.png"/></p>

<h2 id="toc_23">二十三、<a href="https://plugins.jetbrains.com/plugin/7425?pr=">WakaTime</a></h2>

<p>记录你在IDE上的工作时间<br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752676883809.png" alt="20170220148752676883809.png"/></p>

<h2 id="toc_24">二十四、<a href="https://github.com/pedrovgs/AndroidWiFiADB">AndroidWiFiADB</a></h2>

<p>无线调试应用<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/201702205064android_devices_window.png" alt="201702205064android_devices_window.png"/></p>

<h2 id="toc_25">二十五、<a href="https://github.com/westlinkin/AndroidLocalizationer">AndroidLocalizationer</a></h2>

<p>可用于将项目中的 string 资源自动翻译为其他语言的 Android Studio/IntelliJ IDEA 插件<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752685834411.png" alt="20170220148752685834411.png"/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/20170220148752686437878.png" alt="20170220148752686437878.png"/></p>

<h2 id="toc_26">二十六、<a href="https://github.com/YiiGuxing/TranslationPlugin">TranslationPlugin</a></h2>

<p>又一翻译插件,可中英互译。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502772690.html">
                
                  <h1>Android-自定义控件——动画</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>学习Android最重要的就是自定义控件了，好看的人性化的控件总是能抓住客户以及使用者的心，所以从网上学习了部分知识，以及通过自己的实践，总结了自定义控件的学习。在Android动画中，总共有两种类型的动画View Animation(视图动画)和Property Animator(属性动画)。其中：</p>

<ul>
<li>View Animation包括Tween Animation（补间动画）和Frame Animation(逐帧动画);</li>
<li>Property Animator包括ValueAnimator和ObjectAnimation；</li>
<li>alpha、scale、translate、rotate属于Tween Animation。</li>
</ul>

<p>不同之处：</p>

<ul>
<li>引入时间不同：View Animation是API Level 1就引入的。Property Animation是API Level 11引入的，即Android 3.0才开始有Property Animation相关的API。 </li>
<li>所在包名不同：View Animation在包android.view.animation中。而Property Animation API在包 android.animation中。 </li>
<li>动画类的命名不同：View Animation中动画类取名都叫XXXXAnimation,而在Property Animator中动画类的取名则叫XXXXAnimator</li>
</ul>

<h2 id="toc_1">一、alpha、scale、translate、rotate、set(Tween Animation)的xml属性及用法</h2>

<h3 id="toc_2">(一)概述</h3>

<p>alpha：渐变透明度动画效果<br/>
scale：渐变尺寸伸缩动画效果<br/>
translate：画面转换位置移动动画效果<br/>
rotate：画面转移旋转动画效果</p>

<p>动作定义的动画文件应当放在res/anim文件夹下，采用R.anim.XXX.xml方式进行访问。</p>

<h3 id="toc_3">(二)scale标签——调节尺寸</h3>

<p>scale是缩放动画</p>

<h4 id="toc_4">1、自身属性</h4>

<ul>
<li><strong>android:fromXScale</strong> //起始的X方向上相对自身的缩放比例，浮点值，比如1.0代表自身无变化，0.5代表起始时缩小一倍，2.0代表放大一倍;</li>
<li><strong>android:toXScale</strong> //结尾的X方向上相对自身的缩放比例，浮点值;</li>
<li><strong>android:fromYScale</strong> //起始的Y方向上相对自身的缩放比例，浮点值;</li>
<li><strong>android:toYScale</strong> //结尾的Y方向上相对自身的缩放比例，浮点值;</li>
<li><strong>android:pivotX</strong> //缩放起点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p，当为数值时，表示在当前View的左上角，即原点处加上50px，做为起始缩放点；如果是50%，表示在当前控件的左上角加上自己宽度的50%做为起始点；如果是50%p，那么就是表示在当前的左上角加上父控件宽度的50%做为起始点x轴坐标。</li>
<li><strong>android:pivotY</strong> //缩放起点Y轴坐标，取值及意义跟android:pivotX一样。</li>
</ul>

<h4 id="toc_5">2、从Animation类继承的属性</h4>

<ul>
<li><strong>android:duration</strong> //动画持续时间，以毫秒为单位 </li>
<li><strong>android:fillAfte</strong> //如果设置为true，控件动画结束时，将保持动画最后时的状态</li>
<li><strong>android:fillBefore</strong> //如果设置为true,控件动画结束时，还原到开始动画前的状态</li>
<li><strong>android:fillEnabled</strong> //与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态</li>
<li><strong>android:repeatCount</strong> //重复次数</li>
<li><strong>android:repeatMode</strong> //重复类型，有reverse和restart两个值，reverse表示倒序回放，restart表示重新放一遍，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作.</li>
<li><strong>android:interpolator</strong> //设定插值器，其实就是指定的动作效果，比如弹跳效果等，不在这小节中讲解，后面会单独列出一单讲解。</li>
</ul>

<h3 id="toc_6">(三)alpha标签——调节透明度</h3>

<h4 id="toc_7">1、自身属性</h4>

<ul>
<li><strong>android:fromAlpha</strong> //动画开始的透明度，从0.0 --1.0 ，0.0表示全透明，1.0表示完全不透明</li>
<li><strong>android:toAlpha</strong> //动画结束时的透明度，也是从0.0 --1.0 ，0.0表示全透明，1.0表示完全不透明</li>
</ul>

<h3 id="toc_8">(四)rotate标签——旋转</h3>

<h4 id="toc_9">1、自身属性</h4>

<ul>
<li><strong>android:fromDegrees</strong> //开始旋转的角度位置，正值代表顺时针方向度数，负值代码逆时针方向度数</li>
<li><strong>android:toDegrees</strong> //结束时旋转到的角度位置，正值代表顺时针方向度数，负值代码逆时针方向度数</li>
<li><strong>android:pivotX</strong> //放起点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p.</li>
<li><strong>android:pivotY</strong> //缩放起点Y轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p</li>
</ul>

<h3 id="toc_10">(五)translate标签 —— 平移</h3>

<h4 id="toc_11">1、自身属性</h4>

<ul>
<li><strong>android:fromXDelta</strong> //起始点X轴坐标，可以是数值、百分数、百分数p 三种样式，比如 50、50%、50%p</li>
<li><strong>android:fromYDelta</strong> //起始点Y轴坐标，可以是数值、百分数、百分数p 三种样式</li>
<li><strong>android:toXDelta</strong> //结束点X轴坐标</li>
<li><strong>android:toYDelta</strong> //结束点Y轴坐标</li>
</ul>

<h3 id="toc_12">(六)set标签——定义动作合集</h3>

<p>set标签自已是没有属性的，他的属性都是从Animation继承而来，但当它们用于Set标签时，就会对Set标签下的所有子控件都产生作用。</p>

<h3 id="toc_13">(七)示例</h3>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:duration=&quot;3000&quot;  
    android:fillAfter=&quot;true&quot;&gt;  
      
  &lt;alpha   
    android:fromAlpha=&quot;0.0&quot;  
    android:toAlpha=&quot;1.0&quot;/&gt;  
    
  &lt;scale  
    android:fromXScale=&quot;0.0&quot;  
    android:toXScale=&quot;1.4&quot;  
    android:fromYScale=&quot;0.0&quot;  
    android:toYScale=&quot;1.4&quot;  
    android:pivotX=&quot;50%&quot;  
    android:pivotY=&quot;50%&quot;/&gt;  
    
  &lt;rotate  
    android:fromDegrees=&quot;0&quot;  
    android:toDegrees=&quot;720&quot;  
    android:pivotX=&quot;50%&quot;  
    android:pivotY=&quot;50%&quot;/&gt;  
         
&lt;/set&gt; 
</code></pre>

<h3 id="toc_14">(八)使用Animation</h3>

<ol>
<li>通过<code>scaleAnimation = AnimationUtils.loadAnimation(this, R.anim.scaleanim);</code>从XML文件中获取动画</li>
<li>利用<code>startAnimation(animation);</code>将动画传递给指定控件显示。</li>
</ol>

<h2 id="toc_15">二、Interpolator插值器</h2>

<h3 id="toc_16">(一)概述</h3>

<p>Interpolator属性是Animation类的一个XML属性，所以alpha、scale、rotate、translate、set都会继承得到这个属性。Interpolator被译为插值器，指定动画如何变化，跟PS里的动作有点类似：随便拿来一张图片，应用一个动作，图片就会指定变化。</p>

<p>Interpolator的系统值有下面几个：  </p>

<ul>
<li>AccelerateDecelerateInterpolator   //在动画开始与介绍的地方速率改变比较慢，在中间的时候加速<br/></li>
<li>AccelerateInterpolator   //在动画开始的地方速率改变比较慢，然后开始加速<br/></li>
<li>AnticipateInterpolator   //开始的时候向后然后向前甩<br/></li>
<li>AnticipateOvershootInterpolator   //开始的时候向后然后向前甩一定值后返回最后的值<br/></li>
<li>BounceInterpolator   //动画结束的时候弹起<br/></li>
<li>CycleInterpolator   //动画循环播放特定的次数，速率改变沿着正弦曲线</li>
<li>DecelerateInterpolator   //在动画开始的地方快然后慢</li>
<li>LinearInterpolator   //以常量速率改变</li>
<li>OvershootInterpolator   //向前甩一定值后再回到原来位置</li>
</ul>

<h2 id="toc_17">三、用代码实现Animation</h2>

<h3 id="toc_18">(一)Animation类是所有动画的基类，它所具有的标签对应的函数：</h3>

<ul>
<li>android:duration —— setDuration(long)   //动画持续时间，以毫秒为单位</li>
<li>android:fillAfter —— setFillAfter(boolean)   //如果设置为true，控件动画结束时，将保持动画最后时的状态</li>
<li>android:fillBefore —— setFillBefore(boolean)   //如果设置为true,控件动画结束时，还原到开始动画前的状态</li>
<li>android:fillEnabled —— setFillEnabled(boolean)   //与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态</li>
<li>android:repeatCount —— setRepeatCount(int)   //重复次数</li>
<li>android:repeatMode —— setRepeatMode(int)   //重复类型，有reverse和restart两个值，取值为RESTART或 REVERSE，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。</li>
<li>android:interpolator —— setInterpolator(Interpolator)   //设定插值器，其实就是指定的动作效果，比如弹跳效果等</li>
</ul>

<h3 id="toc_19">(二)ScaleAnimation</h3>

<p>这是scale标签对应的类</p>

<h4 id="toc_20">构造函数：</h4>

<ul>
<li><strong>ScaleAnimation(Context context, AttributeSet attrs)</strong>  //从XML文件加载动画，基本用不到</li>
<li><strong>ScaleAnimation(float fromX, float toX, float fromY, float toY)</strong></li>
<li><strong>ScaleAnimation(float fromX, float toX, float fromY, float toY, float pivotX, float pivotY)</strong></li>
<li><strong>ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)</strong></li>
</ul>

<p>第一个构造函数是从本地XML文件加载动画，基本用不到的，我们主要看下面三个构造函数.在标签属性<strong>android:pivotX</strong>中有三种取值，数，百分数，百分数p；体现在构造函数中，就是最后一个构造函数的<strong>pivotXType</strong>,它的取值有三个，<strong>Animation.ABSOLUTE</strong>、<strong>Animation.RELATIVE_TO_SELF</strong>和<strong>Animation.RELATIVE_TO_PARENT</strong>；</p>

<h4 id="toc_21">示例：</h4>

<p>构造的XML代码：</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;scale xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:fromXScale=&quot;0.0&quot;  
    android:toXScale=&quot;1.4&quot;  
    android:fromYScale=&quot;0.0&quot;  
    android:toYScale=&quot;1.4&quot;  
    android:pivotX=&quot;50&quot;  
    android:pivotY=&quot;50&quot;  
    android:duration=&quot;700&quot; /&gt;  
</code></pre>

<p>对应的代码为：</p>

<pre><code class="language-java">scaleAnim = new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);  
scaleAnim.setDuration(700);
</code></pre>

<h3 id="toc_22">(三)AlphaAnimation</h3>

<p>这是alpha标签对应的类</p>

<h4 id="toc_23">构造函数：</h4>

<ul>
<li><strong>AlphaAnimation(Context context, AttributeSet attrs)</strong>   //同样，从本地XML加载动画，基本不用</li>
<li><strong>AlphaAnimation(float fromAlpha, float toAlpha)</strong></li>
</ul>

<h4 id="toc_24">示例：</h4>

<p>构造的XML代码：  </p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;alpha xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:fromAlpha=&quot;1.0&quot;  
    android:toAlpha=&quot;0.1&quot;  
    android:duration=&quot;3000&quot;  
    android:fillBefore=&quot;true&quot;&gt;  
&lt;/alpha&gt; 
</code></pre>

<p>对应的代码为：</p>

<pre><code class="language-java">alphaAnim = new AlphaAnimation(1.0f,0.1f);  
alphaAnim.setDuration(3000);  
alphaAnim.setFillBefore(true); 
</code></pre>

<h3 id="toc_25">(四) RotateAnimation</h3>

<p>RotateAnimation类对应Rotate标签</p>

<h4 id="toc_26">构造函数：</h4>

<ul>
<li><strong>RotateAnimation(Context context, AttributeSet attrs)</strong>   //从本地XML文档加载动画，同样，基本不用</li>
<li><strong>RotateAnimation(float fromDegrees, float toDegrees)</strong></li>
<li><strong>RotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY)</strong></li>
<li><strong>RotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)</strong></li>
</ul>

<h4 id="toc_27">示例：</h4>

<p>构造的XML代码：  </p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:fromDegrees=&quot;0&quot;  
    android:toDegrees=&quot;-650&quot;  
    android:pivotX=&quot;50%&quot;  
    android:pivotY=&quot;50%&quot;  
    android:duration=&quot;3000&quot;  
    android:fillAfter=&quot;true&quot;&gt;  
&lt;/rotate&gt;  
</code></pre>

<p>对应的代码为：</p>

<pre><code class="language-java">rotateAnim = new RotateAnimation(0, -650, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);  
rotateAnim.setDuration(3000);  
rotateAnim.setFillAfter(true);  
</code></pre>

<h3 id="toc_28">(五)TranslateAnimation</h3>

<p>TranslateAnimation类对应translate标签</p>

<h4 id="toc_29">构造函数：</h4>

<ul>
<li><strong>TranslateAnimation(Context context, AttributeSet attrs)</strong>  //同样，基本不用</li>
<li><strong>TranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta)</strong>   //使用是绝对数值</li>
<li><strong>TranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue, int fromYType, float fromYValue, int toYType, float toYValue)</strong>   //最理想的状态就是这个构造函数，能够指定每个值的类型。只有这个构造函数可以指定百分数和相对父控件的百分数。</li>
</ul>

<h4 id="toc_30">示例：</h4>

<p>构造的XML代码：  </p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;translate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:fromXDelta=&quot;0&quot;   
    android:toXDelta=&quot;-80&quot;  
    android:fromYDelta=&quot;0&quot;  
    android:toYDelta=&quot;-80&quot;  
    android:duration=&quot;2000&quot;  
    android:fillBefore=&quot;true&quot;&gt;  
&lt;/translate&gt;  
</code></pre>

<p>对应的代码为：</p>

<pre><code class="language-java">translateAnim = new TranslateAnimation(Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80,   
        Animation.ABSOLUTE, 0, Animation.ABSOLUTE, -80);  
translateAnim.setDuration(2000);  
translateAnim.setFillBefore(true);  
</code></pre>

<h3 id="toc_31">(六)AnimationSet</h3>

<p>AnimationSet类对应set标签，定义动作类的集合</p>

<h4 id="toc_32">构造函数：</h4>

<ul>
<li><strong>AnimationSet(Context context, AttributeSet attrs)</strong>   //同样，基本不用</li>
<li><strong>AnimationSet(boolean shareInterpolator)</strong>   //shareInterpolator取值true或false，取true时，指在AnimationSet中定义一个插值器（interpolater），它下面的所有动画共同。如果设为false，则表示它下面的动画自己定义各自的插值器。</li>
</ul>

<h4 id="toc_33">增加动画函数</h4>

<pre><code class="language-text">public void addAnimation (Animation a)
</code></pre>

<h4 id="toc_34">示例：</h4>

<p>构造的XML代码：  </p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:duration=&quot;3000&quot;  
    android:fillAfter=&quot;true&quot;&gt;  
      
  &lt;alpha   
    android:fromAlpha=&quot;0.0&quot;  
    android:toAlpha=&quot;1.0&quot;/&gt;  
    
  &lt;scale  
    android:fromXScale=&quot;0.0&quot;  
    android:toXScale=&quot;1.4&quot;  
    android:fromYScale=&quot;0.0&quot;  
    android:toYScale=&quot;1.4&quot;  
    android:pivotX=&quot;50%&quot;  
    android:pivotY=&quot;50%&quot;/&gt;  
    
  &lt;rotate  
    android:fromDegrees=&quot;0&quot;  
    android:toDegrees=&quot;720&quot;  
    android:pivotX=&quot;50%&quot;  
    android:pivotY=&quot;50%&quot;/&gt;  
         
&lt;/set&gt; 
</code></pre>

<p>对应的代码为：</p>

<pre><code class="language-java">alphaAnim = new AlphaAnimation(1.0f,0.1f);  
scaleAnim = new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);  
rotateAnim = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);  
  
setAnim=new AnimationSet(true);  
setAnim.addAnimation(alphaAnim);  
setAnim.addAnimation(scaleAnim);  
setAnim.addAnimation(rotateAnim);  
  
setAnim.setDuration(3000);  
setAnim.setFillAfter(true); 
</code></pre>

<h3 id="toc_35">(七) Interpolater插值器</h3>

<p>代码使用方法：  </p>

<pre><code class="language-java">ScaleAnimation interpolateScaleAnim=new ScaleAnimation(0.0f,1.4f,0.0f,1.4f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f);  
interpolateScaleAnim.setInterpolator(new BounceInterpolator());  
interpolateScaleAnim.setDuration(3000);  
</code></pre>

<h2 id="toc_36">四、ValueAnimator基本使用</h2>

<h3 id="toc_37">(一)概述</h3>

<h4 id="toc_38">1、为什么要引入Property Animator(属性动画)</h4>

<pre><code class="language-text">1、Property Animator能实现补间动画无法实现的功能
补间动画和逐帧动画统称为View Animation，也就是说这两个动画只能对派生自View的控件
实例起作用；而Property Animator则不同，从名字中可以看出属性动画，应该是作用于控件
属性的！正因为属性动画能够只针对控件的某一个属性来做动画，所以也就造就了他能单独改变
控件的某一个属性的值！比如颜色！这就是Property Animator能实现补间动画无法实现的功
能的最重要原因。
2、View Animation仅能对指定的控件做动画，而Property Animator是通过改变控件某一
属性值来做动画的。 
假设我们将一个按钮从左上角利用补间动画将其移动到右下角，在移动过程中和移动后，这个按钮
都是不会响应点击事件的。这是为什么呢？因为补间动画仅仅转变的是控件的显示位置而已，并没
有改变控件本身的值。View Animation的动画实现是通过其Parent View实现的，在View被
drawn时Parents View改变它的绘制参数，这样虽然View的大小或旋转角度等改变了，但View
的实际属性没变，所以有效区域还是应用动画之前的区域；我们看到的效果仅仅是系统作用在按钮
上的显示效果，利用动画把按钮从原来的位置移到了右下角，但按钮内部的任何值是没有变化的，
所以按钮所捕捉的点击区域仍是原来的点击区域。
3、补间动画虽能对控件做动画，但并没有改变控件内部的属性值。而Property Animator则是
恰恰相反，Property Animator是通过改变控件内部的属性值来达到动画效果的
</code></pre>

<h3 id="toc_39">(二)ValueAnimator简单使用</h3>

<h4 id="toc_40">1、初步使用ValueAnimator</h4>

<p><strong>创建ValueAnimator实例</strong></p>

<pre><code class="language-java">ValueAnimator animator = ValueAnimator.ofInt(0,400);  
animator.setDuration(1000);  
animator.start();
</code></pre>

<p>利用ValueAnimator.ofInt创建了一个值从0到400的动画，动画时长是1s，然后让动画开始。从这段代码中可以看出，ValueAnimator没有跟任何的控件相关联，那也正好说明ValueAnimator只是对值做动画运算，而不是针对控件的，我们需要监听ValueAnimator的动画过程来自己对控件做操作。 </p>

<p><strong>添加监听</strong></p>

<pre><code class="language-java">ValueAnimator animator = ValueAnimator.ofInt(0,400);  
animator.setDuration(1000);  
  
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {  
    @Override  
    public void onAnimationUpdate(ValueAnimator animation) {  
        int curValue = (int)animation.getAnimatedValue();  
        Log.d(&quot;qijian&quot;,&quot;curValue:&quot;+curValue);
        tv.layout(curValue,curValue,curValue+tv.getWidth(),curValue+tv.getHeight());
    }  
});  
animator.start(); 
</code></pre>

<p>这就是ValueAnimator的功能：ValueAnimator对指定值区间做动画运算，我们通过对运算过程做监听来自己操作控件。  </p>

<p><strong>总结</strong></p>

<ul>
<li>ValueAnimator只负责对指定的数字区间进行动画运算</li>
<li>我们需要对运算过程进行监听，然后自己对控件做动画操作</li>
</ul>

<h4 id="toc_41">2、常用函数</h4>

<ul>
<li><strong>ValueAnimator setDuration(long duration)</strong>   //设置一次动画的时长，单位是毫秒</li>
<li><strong>void start()</strong>   //开始动画</li>
<li><strong>Object getAnimatedValue();</strong>   //获取动画在当前运动点的值，所以这个对象只能用于在动画运动中。返回的值是Object,上面我们说过，通过getAnimatedValue()得到的值的实际类型与初始设置的值相同，如果我们利用ofInt（）设置的动画，那通过getAnimatedValue()得到的值为类型就是Int类型。如果我们利用ofFloat（）设置的动画，通过getAnimatedValue()得到的值类型就是Float类型。</li>
<li><strong>void setRepeatCount(int value)</strong>   //设置循环次数,设置为INFINITE表示无限循环</li>
<li><strong>setRepeatMode(int value)</strong>   //设置循环模式,value取值有RESTART，REVERSE</li>
<li><strong>cancel()</strong>   //取消动画</li>
</ul>

<h4 id="toc_42">3、监听器</h4>

<ul>
<li>AnimatorUpdateListener就是监听动画的实时变化状态，在onAnimationUpdate(ValueAnimator animation)中的animation表示当前状态动画的实例。添加AnimatorUpdateListener的方法是addUpdateListener(AnimatorListener listener)。</li>
<li>在AnimatorListener中，主要是监听Animation的四个状态，start、end、cancel、repeat；当动画开始时，会调用onAnimationStart(Animator animation)方法，当动画结束时调用onAnimationEnd(Animator animation)，当动画取消时，调用onAnimationCancel(Animator animation)函数，当动画重复时，会调用onAnimationRepeat(Animator animation)函数。添加AnimatorListener的方法是addListener(AnimatorListener listener)。</li>
<li><strong>void removeUpdateListener(AnimatorUpdateListener listener);</strong>   //移除AnimatorUpdateListener</li>
<li><strong>void removeAllUpdateListeners();</strong>   //移除AnimatorUpdateListener </li>
<li><strong>void removeListener(AnimatorListener listener);</strong>   //用于在animator中移除指定的监听器</li>
<li><strong>void removeAllListeners();</strong>   //用于移除animator中所有的AnimatorListener监听器</li>
</ul>

<h4 id="toc_43">4、其他函数</h4>

<ul>
<li><strong>public void setStartDelay(long startDelay);</strong>   //延时多久时间开始，单位是毫秒 </li>
<li><strong>public ValueAnimator clone();</strong>   //完全克隆一个ValueAnimator实例，包括它所有的设置以及所有对监听器代码的处理</li>
</ul>

<h4 id="toc_44">5、插值器</h4>

<p>控制动画的加速变化<br/><br/>
<code>animator.setInterpolator(new BounceInterpolator());   //简单使用</code></p>

<h4 id="toc_45">6、自定义插值器</h4>

<pre><code class="language-java">public class LinearInterpolator implements TimeInterpolator {

    public LinearInterpolator() {
    }

    public LinearInterpolator(Context context, AttributeSet attrs) {
    }

    /**
    *主要重写该方法，对动画的进度从0到1进行调节
    **/
    public float getInterpolation(float input) {
        return input;
    }
}
</code></pre>

<h4 id="toc_46">7、Evaluator</h4>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702084563420160120104933467.png" alt="201702084563420160120104933467.png"/></p>

<p>这幅图讲述了从定义动画的数字区间到通过AnimatorUpdateListener中得到当前动画所对应数值的整个过程。下面我们对这四个步骤具体讲解一下： <br/>
(1)、ofInt(0,400)表示指定动画的数字区间，是从0运动到400； <br/>
(2)、加速器：上面我们讲了，在动画开始后，通过加速器会返回当前动画进度所对应的数字进度，但这个数字进度是百分制的，以小数表示，如0.2 <br/>
(3)、Evaluator:我们知道我们通过监听器拿到的是当前动画所对应的具体数值，而不是百分制的进度。那么就必须有一个地方会根据当前的数字进度，将其转化为对应的数值，这个地方就是Evaluator；Evaluator就是将从加速器返回的数字进度转成对应的数字值。所以上部分中，我们讲到的公式：</p>

<p>当前的值 = 100 + （400 - 100）* 显示进度<br/>
这个公式就是在Evaluator计算的；在拿到当前数字进度所对应的值以后，将其返回 <br/>
（4）、监听器：我们通过在AnimatorUpdateListener监听器使用animation.getAnimatedValue()函数拿到Evaluator中返回的数字值。</p>

<p>ofInt和ofFloat都是系统直接提供的函数，所以在使用时都会有默认的加速器和Evaluator来使用的，不指定则使用默认的；对于Evaluator而言，ofInt()的默认Evaluator当然是IntEvaluator;而FloatEvalutar默认的则是FloatEvalutor; Evalutor一般来讲不能通用，会报强转错误，也就是说，只有在数值类型相同的情况下，Evalutor才能共用。 <br/>
<strong>Evaluator其实就是一个转换器，他能把小数进度转换成对应的数值位置</strong></p>

<h4 id="toc_47">8、自定义Evaluator</h4>

<pre><code class="language-java">public class MyEvaluator implements TypeEvaluator&lt;Integer&gt; {
    @Override
    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
        int startInt = startValue;
        return (int)(200+startInt + fraction * (endValue - startInt));
    }
}
</code></pre>

<p><strong>我们可以通过重写加速器改变数值进度来改变数值位置，也可以通过改变Evaluator中进度所对应的数值来改变数值位置。</strong></p>

<h4 id="toc_48">9、ArgbEvalutor</h4>

<p>ArgbEvalutor是用来做颜色值过渡转换的。</p>

<pre><code class="language-java">ValueAnimator animator = ValueAnimator.ofInt(0xffffff00,0xff0000ff);
animator.setEvaluator(new ArgbEvaluator());
animator.setDuration(3000);
</code></pre>

<h4 id="toc_49">10、ofInt(),ofFloat(),ofObject()</h4>

<p>ofInt()只能传入Integer类型的值,而ofFloat（）则只能传入Float类型的值,ofObject(),可以传进去任何类型的变量.</p>

<p><strong>ofObject()示例</strong>  </p>

<h5 id="toc_50">1、简单示例</h5>

<pre><code class="language-java">
ValueAnimator animator = ValueAnimator.ofObject(new CharEvaluator(),new Character(&#39;A&#39;),new Character(&#39;Z&#39;));  
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {  
    @Override  
    public void onAnimationUpdate(ValueAnimator animation) {  
        char text = (char)animation.getAnimatedValue();  
        tv.setText(String.valueOf(text));  
    }  
});  
animator.setDuration(10000);  
animator.setInterpolator(new AccelerateInterpolator());  
animator.start(); 

</code></pre>

<h5 id="toc_51">2、自定义示例</h5>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702082067420160120165531838.gif" alt="201702082067420160120165531838.gif"/><br/>
在这里，我们自定义了一个View，在这个view上画一个圆，但这个圆是有动画效果的。从效果中可以看出使用的插值器应该是回弹插值器(BounceInterpolator)。下面就来看看这个动画是怎么做出来的。   </p>

<p><strong>首先，我们自定义一个类Point</strong></p>

<pre><code class="language-java">public class Point {  
    private int radius;  
  
    public Point(int radius){  
        this.radius = radius;  
    }  
  
    public int getRadius() {  
        return radius;  
    }  
  
    public void setRadius(int radius) {  
        this.radius = radius;  
    }  
}
</code></pre>

<p><strong>然后我们自定义一个View:MyPointView</strong></p>

<pre><code class="language-java">public class MyPointView extends View {  
    private Point mCurPoint;  
    public MyPointView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        super.onDraw(canvas);  
        if (mCurPoint != null){  
            Paint paint = new Paint();  
            paint.setAntiAlias(true);  
            paint.setColor(Color.RED);  
            paint.setStyle(Paint.Style.FILL);  
            canvas.drawCircle(300,300,mCurPoint.getRadius(),paint);  
        }  
    }  
  
    public void doPointAnim(){  
        ValueAnimator animator = ValueAnimator.ofObject(new PointEvaluator(),new Point(20),new Point(200));  
        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {  
            @Override  
            public void onAnimationUpdate(ValueAnimator animation) {  
                mCurPoint = (Point)animation.getAnimatedValue();  
                invalidate();  
            }  
        });  
        animator.setDuration(1000);  
        animator.setInterpolator(new BounceInterpolator());  
        animator.start();  
    }  
}
</code></pre>

<p><strong>在布局中添加入自定义View，然后在主界面中调用</strong></p>

<pre><code class="language-java">public class MyActivity extends Activity {  
    private Button btnStart;  
    private MyPointView mPointView;  
  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
  
        btnStart = (Button) findViewById(R.id.btn);  
        mPointView = (MyPointView)findViewById(R.id.pointview);  
  
        btnStart.setOnClickListener(new View.OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                mPointView.doPointAnim();  
            }  
        });  
    }  
} 
</code></pre>

<h3 id="toc_52">(三)ObjectAnimator基础使用</h3>

<p>为了能让动画直接与对应控件相关联，以使我们从监听动画过程中解放出来，谷歌的开发人员在ValueAnimator的基础上，又派生了一个类ObjectAnimator; 由于ObjectAnimator是派生自ValueAnimator的，所以ValueAnimator中所能使用的方法，在ObjectAnimator中都可以正常使用。但ObjectAnimator也重写了几个方法，比如ofInt(),ofFloat()等。</p>

<h4 id="toc_53">改变透明度示例</h4>

<pre><code class="language-java">ObjectAnimator animator = ObjectAnimator.ofFloat(tv,&quot;alpha&quot;,1,0,1);  
animator.setDuration(2000);
animator.start();
</code></pre>

<h4 id="toc_54">构造函数</h4>

<p><code>public static ObjectAnimator ofFloat(Object target, String propertyName, float... values)</code></p>

<ul>
<li>第一个参数用于指定这个动画要操作的是哪个控件</li>
<li>第二个参数用于指定这个动画要操作这个控件的哪个属性(rotationX-围绕X轴，rotationY-围绕Y轴，rotation围绕Z轴，translationX-在X轴上水平移动，translationY-在Y轴上水平移动，scaleX-在X轴上缩放倍数，scaleY-在Y轴上缩放倍数)</li>
<li>第三个参数是可变长参数，这个就跟ValueAnimator中的可变长参数的意义一样了，就是指这个属性值是从哪变到哪</li>
</ul>

<h4 id="toc_55">自定义ObjectAnimator属性</h4>

<p><strong>1、保存圆形信息类——Point</strong></p>

<pre><code class="language-java">public class Point {  
    private int mRadius;  
  
    public Point(int radius){  
        mRadius = radius;  
    }  
  
    public int getRadius() {  
        return mRadius;  
    }  
  
    public void setRadius(int radius) {  
        mRadius = radius;  
    }  
}
</code></pre>

<p><strong>2、自定义控件——MyPointView</strong></p>

<pre><code class="language-java">public class MyPointView extends View {  
    private Point mPoint = new Point(100);  
  
    public MyPointView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        if (mPoint != null){  
            Paint paint = new Paint();  
            paint.setAntiAlias(true);  
            paint.setColor(Color.RED);  
            paint.setStyle(Paint.Style.FILL);  
            canvas.drawCircle(300,300,mPoint.getRadius(),paint);  
        }  
        super.onDraw(canvas);  
    }  
  
    void setPointRadius(int radius){  
        mPoint.setRadius(radius);  
        invalidate();  
    }  
}
</code></pre>

<p><strong>3、MyActivity</strong></p>

<pre><code class="language-java">
public class MyActivity extends Activity {  
    private Button btnStart;  
    private MyPointView mPointView;  
  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
  
        btnStart = (Button) findViewById(R.id.btn);  
        mPointView = (MyPointView)findViewById(R.id.pointview);  
  
        btnStart.setOnClickListener(new View.OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                doPointViewAnimation();  
            }  
        });  
    }  
    private void doPointViewAnimation(){  
     ObjectAnimator animator = ObjectAnimator.ofInt(mPointView, &quot;pointRadius&quot;, 0, 300, 100);  
     animator.setDuration(2000);  
     animator.start();  
    }
} 
</code></pre>

<h2 id="toc_56">五、PropertyValuesHolder与Keyframe</h2>

<p>ValueAnimator和ObjectAnimator除了通过ofInt(),ofFloat(),ofObject()创建实例外，还都有一个ofPropertyValuesHolder()方法来创建实例。通常ValueAnimator使用ofPropertyValuesHolder()的机会不多，所以只讲ObjectAnimator中ofPropertyValuesHolder()的用法。对于ValueAnimator的ofPropertyValuesHolder()使用是差不多的。</p>

<h3 id="toc_57">(一)PropertyValuesHolder</h3>

<h4 id="toc_58">1、概述</h4>

<p>PropertyValuesHolder这个类的意义就是，它其中保存了动画过程中所需要操作的属性和对应的值。我们通过ofFloat(Object target, String propertyName, float… values)构造的动画，ofFloat()的内部实现其实就是将传进来的参数封装成PropertyValuesHolder实例来保存动画状态。在封装成PropertyValuesHolder实例以后，后期的各种操作也是以PropertyValuesHolder为主的。 </p>

<p><strong>创建实例的函数</strong></p>

<pre><code class="language-java">public static PropertyValuesHolder ofFloat(String propertyName, float... values)  
public static PropertyValuesHolder ofInt(String propertyName, int... values)   
public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,Object... values)  
public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)
</code></pre>

<p>这里总共有四个创建实例的方法，这一段我们着重讲ofFloat、ofInt和ofObject的用法，ofKeyframe我们单独讲。</p>

<h4 id="toc_59">2、PropertyValuesHolder之ofFloat()、ofInt()</h4>

<h5 id="toc_60">（1）ofFloat()、ofInt()</h5>

<p><strong>构造函数</strong>  </p>

<pre><code class="language-text">public static PropertyValuesHolder ofFloat(String propertyName, float... values)  
public static PropertyValuesHolder ofInt(String propertyName, int... values)
</code></pre>

<ul>
<li>propertyName：表示ObjectAnimator需要操作的属性名。即ObjectAnimator需要通过反射查找对应属性的setProperty()函数的那个property.</li>
<li>values：属性所对应的参数，同样是可变长参数，可以指定多个，还记得我们在ObjectAnimator中讲过，如果只指定了一个，那么ObjectAnimator会通过查找getProperty()方法来获得初始值。</li>
</ul>

<h5 id="toc_61">（2）、ObjectAnimator.ofPropertyValuesHolder()</h5>

<p>ObjectAnimator提供了一个设置PropertyValuesHolder实例的入口：</p>

<pre><code class="language-text">public static ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values);
</code></pre>

<ul>
<li>target：指需要执行动画的控件</li>
<li>values：是一个可变长参数，可以传进去多个PropertyValuesHolder实例，由于每个PropertyValuesHolder实例都会针对一个属性做动画，所以如果传进去多个PropertyValuesHolder实例，将会对控件的多个属性同时做动画操作。 </li>
</ul>

<p><strong>示例</strong>  </p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702096229820160226223929399.gif" alt="201702096229820160226223929399.gif"/></p>

<pre><code class="language-java">PropertyValuesHolder rotationHolder = PropertyValuesHolder.ofFloat(&quot;Rotation&quot;, 60f, -60f, 40f, -40f, -20f, 20f, 10f, -10f, 0f);  
PropertyValuesHolder colorHolder = PropertyValuesHolder.ofInt(&quot;BackgroundColor&quot;, 0xffffffff, 0xffff00ff, 0xffffff00, 0xffffffff);  
ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mTextView, rotationHolder, colorHolder);  
animator.setDuration(3000);  
animator.setInterpolator(new AccelerateInterpolator());  
animator.start();
</code></pre>

<h4 id="toc_62">3、PropertyValuesHolder之ofObject()</h4>

<h5 id="toc_63">ofObject的构造函数</h5>

<pre><code class="language-text">public static PropertyValuesHolder ofObject(String propertyName, TypeEvaluator evaluator,Object... values);
</code></pre>

<ul>
<li>propertyName:ObjectAnimator动画操作的属性名;</li>
<li>evaluator:Evaluator实例，Evaluator是将当前动画进度计算出当前值的类，可以使用系统自带的IntEvaluator、FloatEvaluator也可以自定义。</li>
<li>values：可变长参数，表示操作动画属性的值。</li>
</ul>

<h5 id="toc_64">示例</h5>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702094808220160226224343549.gif" alt="201702094808220160226224343549.gif"/></p>

<p>通过自字义的CharEvaluator来自动实现字母的改变与计算。</p>

<ul>
<li><p>首先是自定义一个CharEvaluator,通过进度值来自动计算出当前的字母:</p>
<pre><code class="language-java">public class CharEvaluator implements TypeEvaluator&lt;Character&gt; {  
    @Override  <br/>
    public Character evaluate(float fraction, Character startValue, Character endValue) {  <br/>
        int startInt  = (int)startValue;  <br/>
        int endInt = (int)endValue;  <br/>
        int curInt = (int)(startInt + fraction *(endInt - startInt));  <br/>
        char result = (char)curInt;  <br/>
        return result;  <br/>
    }  <br/>
}
</code></pre></li>
<li><p>从CharEvaluator中可以看出，从CharEvaluator中产出的动画中间值类型为Character类型。TextView中虽然有setText(CharSequence text) 函数，但这个函数的参数类型是CharSequence，而不是Character类型。所以我们要自定义一个类派生自TextView来改变TextView的字符</p>
<pre><code class="language-java">public class MyTextView extends TextView {  
    public MyTextView(Context context, AttributeSet attrs) {  <br/>
        super(context, attrs);  <br/>
    }  <br/>
    public void setCharText(Character character){  <br/>
        setText(String.valueOf(character));  <br/>
    }  <br/>
}
</code></pre></li>
<li><p>最后MyActivity,在点击按钮的时候开始动画，核心代码为:</p>
<pre><code class="language-java">public class MyActivity extends Activity {  
    private Button btn;  <br/>
    private TextView mTextView;  <br/>
    private MyTextView mMyTv;  <br/>
    @Override  <br/>
    public void onCreate(Bundle savedInstanceState) {  <br/>
        super.onCreate(savedInstanceState);  <br/>
        setContentView(R.layout.main);  <br/>
        mMyTv = (MyTextView)findViewById(R.id.mytv);  <br/>
        btn = (Button) findViewById(R.id.btn);  <br/>
        btn.setOnClickListener(new View.OnClickListener() {  <br/>
            @Override  <br/>
            public void onClick(View v) {  <br/>
                doOfObjectAnim();  <br/>
            }  <br/>
        });  <br/>
    }  <br/>
    private void doOfObjectAnim(){  <br/>
        PropertyValuesHolder charHolder = PropertyValuesHolder.ofObject(&quot;CharText&quot;,new CharEvaluator(),new Character(&#39;A&#39;),new Character(&#39;Z&#39;));  <br/>
        ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(mMyTv, charHolder);  <br/>
        animator.setDuration(3000);  <br/>
        animator.setInterpolator(new AccelerateInterpolator());  <br/>
        animator.start();  <br/>
    }  <br/>
}
</code></pre></li>
</ul>

<h4 id="toc_65">3、Keyframe</h4>

<h5 id="toc_66">(1) 概述</h5>

<p>----我们知道如果要控制动画速率的变化，我们可以通过自定义插值器，也可以通过自定义Evaluator来实现。但如果真的让我们为了速率变化效果而自定义插值器或者Evaluator的话，恐怕大部分同学会有一万头草泥马在眼前奔过，因为大部分的同学的数学知识已经还给老师了。<br/><br/>
----为了解决方便的控制动画速率的问题，谷歌为了我等屁民定义了一个KeyFrame的类，KeyFrame直译过来就是关键帧。<br/><br/>
----关键帧这个概念是从动画里学来的，我们知道视频里，一秒要播放24帧图片，对于制作flash动画的同学来讲，是不是每一帧都要画出来呢？当然不是了，如果每一帧都画出来，那估计做出来一个动画片都得要一年时间；比如我们要让一个球在30秒时间内，从（0,0）点运动到（300，200）点，那flash是怎么来做的呢，在flash中，我们只需要定义两个关键帧，在动画开始时定义一个，把球的位置放在(0,0)点；在30秒后，再定义一个关键帧，把球的位置放在（300，200）点。在动画 开始时，球初始在是（0，0）点，30秒时间内就adobe flash就会自动填充，把球平滑移动到第二个关键帧的位置（300，200）点；<br/><br/>
----通过上面分析flash动画的制作原理，我们知道，一个关键帧必须包含两个原素，第一时间点，第二位置。即这个关键帧是表示的是某个物体在哪个时间点应该在哪个位置上。<br/><br/>
----所以谷歌的KeyFrame也不例外，KeyFrame的生成方式为：</p>

<pre><code class="language-text">public static Keyframe ofFloat(float fraction, float value);
</code></pre>

<ul>
<li>fraction：表示当前的显示进度，即从加速器中getInterpolation()函数的返回值；</li>
<li>value：表示当前应该在的位置</li>
</ul>

<p>比如Keyframe.ofFloat(0, 0)表示动画进度为0时，动画所在的数值位置为0；Keyframe.ofFloat(0.25f, -20f)表示动画进度为25%时，动画所在的数值位置为-20；Keyframe.ofFloat(1f,0)表示动画结束时，动画所在的数值位置为0；在理解了KeyFrame.ofFloat()的参数以后，我们来看看PropertyValuesHolder是如何使用KeyFrame对象的：</p>

<pre><code class="language-text">public static PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values);
</code></pre>

<ul>
<li>propertyName：动画所要操作的属性名</li>
<li>values：Keyframe的列表，PropertyValuesHolder会根据每个Keyframe的设定，定时将指定的值输出给动画。</li>
</ul>

<p><strong>完整的KeyFrame使用代码：</strong></p>

<pre><code class="language-java">Keyframe frame0 = Keyframe.ofFloat(0f, 0);  
Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);  
Keyframe frame2 = Keyframe.ofFloat(1, 0);  
PropertyValuesHolder frameHolder = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;,frame0,frame1,frame2);  
 Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage,frameHolder);  
animator.setDuration(1000);  
animator.start();
</code></pre>

<p><strong>第一步：</strong>生成Keyframe对象；<br/><br/>
<strong>第二步：</strong>利用PropertyValuesHolder.ofKeyframe()生成PropertyValuesHolder对象<br/><br/>
<strong>第三步：</strong>ObjectAnimator.ofPropertyValuesHolder()生成对应的Animator   </p>

<h5 id="toc_67">(2)示例</h5>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702093773320160227110743594.gif" alt="201702093773320160227110743594.gif"/></p>

<pre><code class="language-java">public class MyActivity extends Activity {  
    private ImageView mImage;  
    private Button mBtn;  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
        mImage = (ImageView)findViewById(R.id.img);  
        mBtn = (Button)findViewById(R.id.btn);  
        mBtn.setOnClickListener(new View.OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                doOfFloatAnim();  
            }  
        });  
    }  
  
    private void doOfFloatAnim(){  
        /** 
          * 左右震动效果 
          */  
        Keyframe frame0 = Keyframe.ofFloat(0f, 0);  
        Keyframe frame1 = Keyframe.ofFloat(0.1f, -20f);  
        Keyframe frame2 = Keyframe.ofFloat(0.2f, 20f);  
        Keyframe frame3 = Keyframe.ofFloat(0.3f, -20f);  
        Keyframe frame4 = Keyframe.ofFloat(0.4f, 20f);  
        Keyframe frame5 = Keyframe.ofFloat(0.5f, -20f);  
        Keyframe frame6 = Keyframe.ofFloat(0.6f, 20f);  
        Keyframe frame7 = Keyframe.ofFloat(0.7f, -20f);  
        Keyframe frame8 = Keyframe.ofFloat(0.8f, 20f);  
        Keyframe frame9 = Keyframe.ofFloat(0.9f, -20f);  
        Keyframe frame10 = Keyframe.ofFloat(1, 0);  
        PropertyValuesHolder frameHolder1 = PropertyValuesHolder.ofKeyframe(&quot;rotation&quot;, frame0, frame1, frame2, frame3, frame4,frame5, frame6, frame7, frame8, frame9, frame10);  
  
  
        /** 
         * scaleX放大1.1倍 
         */  
        Keyframe scaleXframe0 = Keyframe.ofFloat(0f, 1);  
        Keyframe scaleXframe1 = Keyframe.ofFloat(0.1f, 1.1f);  
        Keyframe scaleXframe2 = Keyframe.ofFloat(0.2f, 1.1f);  
        Keyframe scaleXframe3 = Keyframe.ofFloat(0.3f, 1.1f);  
        Keyframe scaleXframe4 = Keyframe.ofFloat(0.4f, 1.1f);  
        Keyframe scaleXframe5 = Keyframe.ofFloat(0.5f, 1.1f);  
        Keyframe scaleXframe6 = Keyframe.ofFloat(0.6f, 1.1f);  
        Keyframe scaleXframe7 = Keyframe.ofFloat(0.7f, 1.1f);  
        Keyframe scaleXframe8 = Keyframe.ofFloat(0.8f, 1.1f);  
        Keyframe scaleXframe9 = Keyframe.ofFloat(0.9f, 1.1f);  
        Keyframe scaleXframe10 = Keyframe.ofFloat(1, 1);  
        PropertyValuesHolder frameHolder2 = PropertyValuesHolder.ofKeyframe(&quot;ScaleX&quot;,scaleXframe0,scaleXframe1,scaleXframe2,scaleXframe3,scaleXframe4,scaleXframe5,scaleXframe6,scaleXframe7,scaleXframe8,scaleXframe9,scaleXframe10);  
  
  
        /** 
         * scaleY放大1.1倍 
         */  
        Keyframe scaleYframe0 = Keyframe.ofFloat(0f, 1);  
        Keyframe scaleYframe1 = Keyframe.ofFloat(0.1f, 1.1f);  
        Keyframe scaleYframe2 = Keyframe.ofFloat(0.2f, 1.1f);  
        Keyframe scaleYframe3 = Keyframe.ofFloat(0.3f, 1.1f);  
        Keyframe scaleYframe4 = Keyframe.ofFloat(0.4f, 1.1f);  
        Keyframe scaleYframe5 = Keyframe.ofFloat(0.5f, 1.1f);  
        Keyframe scaleYframe6 = Keyframe.ofFloat(0.6f, 1.1f);  
        Keyframe scaleYframe7 = Keyframe.ofFloat(0.7f, 1.1f);  
        Keyframe scaleYframe8 = Keyframe.ofFloat(0.8f, 1.1f);  
        Keyframe scaleYframe9 = Keyframe.ofFloat(0.9f, 1.1f);  
        Keyframe scaleYframe10 = Keyframe.ofFloat(1, 1);  
        PropertyValuesHolder frameHolder3 = PropertyValuesHolder.ofKeyframe(&quot;ScaleY&quot;,scaleYframe0,scaleYframe1,scaleYframe2,scaleYframe3,scaleYframe4,scaleYframe5,scaleYframe6,scaleYframe7,scaleYframe8,scaleYframe9,scaleYframe10);  
  
        /** 
         * 构建动画 
         */  
        Animator animator = ObjectAnimator.ofPropertyValuesHolder(mImage, frameHolder1,frameHolder2,frameHolder3);  
        animator.setDuration(1000);  
        animator.start();  
    }  
}
</code></pre>

<h5 id="toc_68">(3)常用函数</h5>

<pre><code class="language-java">/** 
 * ofFloat 
 */  
public static Keyframe ofFloat(float fraction)   
public static Keyframe ofFloat(float fraction, float value)  
/** 
 * ofInt 
 */  
public static Keyframe ofInt(float fraction)  
public static Keyframe ofInt(float fraction, int value)  
/** 
 * ofObject 
 */ 
public static Keyframe ofObject(float fraction)  
public static Keyframe ofObject(float fraction, Object value)  
/** 
 * 设置fraction参数，即Keyframe所对应的进度 
 */  
public void setFraction(float fraction)   
/** 
 * 设置当前Keyframe所对应的值 
 */  
public void setValue(Object value)  
/** 
 * 设置Keyframe动作期间所对应的插值器 
 */  
public void setInterpolator(TimeInterpolator interpolator)
</code></pre>

<h4 id="toc_69">PropertyValuesHolder之其它函数</h4>

<p>PropertyValuesHolder除了上面的讲到的ofInt,ofFloat,ofObject,ofKeyframe以外，api 11的还有几个函数：</p>

<pre><code class="language-java">/** 
 * 设置动画的Evaluator 
 */  
public void setEvaluator(TypeEvaluator evaluator)  
/** 
 * 用于设置ofFloat所对应的动画值列表 
 */  
public void setFloatValues(float... values)  
/** 
 * 用于设置ofInt所对应的动画值列表 
 */  
public void setIntValues(int... values)  
/** 
 * 用于设置ofKeyframe所对应的动画值列表 
 */  
public void setKeyframes(Keyframe... values)  
/** 
 * 用于设置ofObject所对应的动画值列表 
 */  
public void setObjectValues(Object... values)  
/** 
 * 设置动画属性名 
 */  
public void setPropertyName(String propertyName)
</code></pre>

<h2 id="toc_70">六、联合动画的代码实现</h2>

<p>上几篇给大家分别讲了ValueAnimator和ObjectAnimator,相比而言ObjectAnimator更为方便而且由于set函数是在控件类内部实现，所以封装性更好。而且在现实使用中一般而言都是使用ObjectAnimator的机率比较大。 <br/>
但ValueAnimator和ObjectAnimator都只能单单实现一个动画，那如果我们想要使用一个组合动画，比如边放大，边移动，边改变alpha值，要怎么办。对于这种组合型的动画，谷歌给我们提供了一个类AnimatorSet;这篇我们就着重来看看组合动画的实现方法吧。</p>

<h3 id="toc_71">(一)AnimatorSet——playSequentially,playTogether</h3>

<p>首先，AnimatorSet针对ValueAnimator和ObjectAnimator都是适用的，但一般而言，我们不会用到ValueAnimator的组合动画，所以我们这篇仅讲解ObjectAnimator下的组合动画实现。 <br/>
在AnimatorSet中直接给为我们提供了两个方法playSequentially和playTogether，playSequentially表示所有动画依次播放，playTogether表示所有动画一起开始。</p>

<h4 id="toc_72">1、playSequentially</h4>

<pre><code class="language-text">public void playSequentially(Animator... items);
public void playSequentially(List&lt;Animator&gt; items);
</code></pre>

<p>这里有两种声明，第一个是我们最常用的，它的参数是可变长参数，也就是说我们可以传进去任意多个Animator对象。这些对象的动画会逐个播放。第二个构造函数，是传进去一个List&lt; Animator&gt;的列表。原理一样，也是逐个去取List中的动画对象，然后逐个播放。但使用起来稍微麻烦一些。 </p>

<h5 id="toc_73">示例</h5>

<pre><code class="language-java">public class MyActivity extends Activity {
    private Button mButton;
    private TextView mTv1, mTv2;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        mButton = (Button) findViewById(R.id.btn);
        mTv1 = (TextView) findViewById(R.id.tv_1);
        mTv2 = (TextView) findViewById(R.id.tv_2);

        mButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                doPlaySequentiallyAnimator();
            }
        });
    }
    private void doPlaySequentiallyAnimator(){
    ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;,  0xffff00ff, 0xffffff00, 0xffff00ff);
    ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 300, 0);
    ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);

    AnimatorSet animatorSet = new AnimatorSet();
    animatorSet.playSequentially(tv1BgAnimator,tv1TranslateY,tv2TranslateY);
    animatorSet.setDuration(1000);
    animatorSet.start();
    }
}
</code></pre>

<h4 id="toc_74">2、playTogether</h4>

<pre><code class="language-text">public void playTogether(Animator... items);
public void playTogether(Collection&lt;Animator&gt; items);
</code></pre>

<p>同样这里也是有两个构造函数，他们两个的意义是一样的，只是传入的参数不一样，第一个依然是传可变长参数列表，第二个则是需要传一个组装好的Collection<Animator>对象。</p>

<h5 id="toc_75">示例</h5>

<pre><code class="language-java">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;,  0xffff00ff, 0xffffff00, 0xffff00ff);
ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 400, 0);
ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);

AnimatorSet animatorSet = new AnimatorSet();
animatorSet.playTogether(tv1BgAnimator,tv1TranslateY,tv2TranslateY);
animatorSet.setDuration(1000);
animatorSet.start();
</code></pre>

<h4 id="toc_76">3、自由设置动画顺序——AnimatorSet.Builder</h4>

<p>上面我们讲了playTogether和playSequentially，分别能实现一起开始动画和逐个开始动画。但并不是非常自由的组合动画，比如我们有三个动画A,B,C我们想先播放C然后同时播放A和B。利用playTogether和playSequentially是没办法实现的，所以为了更方便的组合动画，谷歌的开发人员另外给我们提供一个类AnimatorSet.Builder。</p>

<h5 id="toc_77">示例</h5>

<pre><code class="language-java">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;,  0xffff00ff, 0xffffff00, 0xffff00ff);
ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 400, 0);

AnimatorSet animatorSet = new AnimatorSet();
AnimatorSet.Builder builder = animatorSet.play(tv1BgAnimator);
builder.with(tv1TranslateY);
animatorSet.start();
</code></pre>

<h4 id="toc_78">4、AnimatorSet.Builder函数</h4>

<pre><code class="language-java">//调用AnimatorSet中的play方法是获取AnimatorSet.Builder对象的唯一途径
//表示要播放哪个动画
public Builder play(Animator anim)
//和前面动画一起执行
public Builder with(Animator anim)
//执行前面的动画后才执行该动画
public Builder before(Animator anim)
//执行先执行这个动画再执行前面动画
public Builder after(Animator anim)
//延迟n毫秒之后执行动画
public Builder after(long delay)
</code></pre>

<h5 id="toc_79">使用示例</h5>

<pre><code class="language-java">ObjectAnimator tv1BgAnimator = ObjectAnimator.ofInt(mTv1, &quot;BackgroundColor&quot;,  0xffff00ff, 0xffffff00, 0xffff00ff);
ObjectAnimator tv1TranslateY = ObjectAnimator.ofFloat(mTv1, &quot;translationY&quot;, 0, 400, 0);
ObjectAnimator tv2TranslateY = ObjectAnimator.ofFloat(mTv2, &quot;translationY&quot;, 0, 400, 0);

AnimatorSet animatorSet = new AnimatorSet();
animatorSet.play(tv1TranslateY).with(tv2TranslateY).after(tv1BgAnimator);
animatorSet.setDuration(2000);
animatorSet.start();
</code></pre>

<h4 id="toc_80">5、AnimatorSet监听器</h4>

<ul>
<li>1、AnimatorSet的监听函数也只是用来监听AnimatorSet的状态的，与其中的动画无关； </li>
<li>2、AnimatorSet中没有设置循环的函数，所以AnimatorSet监听器中永远无法运行到onAnimationRepeat()中！ </li>
</ul>

<h5 id="toc_81">通用函数逐个设置与AnimatorSet设置的区别</h5>

<pre><code class="language-java">//设置单次动画时长
public AnimatorSet setDuration(long duration);
//设置加速器
public void setInterpolator(TimeInterpolator interpolator)
//设置ObjectAnimator动画目标控件
public void setTarget(Object target)
</code></pre>

<p><strong>区别就是：</strong>在AnimatorSet中设置以后，会覆盖单个ObjectAnimator中的设置；即如果AnimatorSet中没有设置，那么就以ObjectAnimator中的设置为准。如果AnimatorSet中设置以后，ObjectAnimator中的设置就会无效。</p>

<h2 id="toc_82">七、联合动画的XML实现与使用示例</h2>

<h3 id="toc_83">(一)联合动画的XML实现</h3>

<p>在xml中对应animator总共有三个标签，分别是</p>

<pre><code class="language-text">&lt;animator /&gt;:对应ValueAnimator
&lt;objectAnimator /&gt;:对应ObjectAnimator
&lt;set /&gt;:对应AnimatorSet
</code></pre>

<h4 id="toc_84">1、animator</h4>

<h5 id="toc_85">(1)下面是完整的animator所有的字段及取值范围：</h5>

<pre><code class="language-markup">&lt;animator
    android:duration=&quot;int&quot;
    android:valueFrom=&quot;float | int | color&quot;
    android:valueTo=&quot;float | int | color&quot;
    android:startOffset=&quot;int&quot;
    android:repeatCount=&quot;int&quot;
    android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]
    android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]
    android:interpolator=[&quot;@android:interpolator/XXX&quot;]/&gt;
</code></pre>

<ul>
<li><strong>android:duration</strong>:每次动画播放的时长</li>
<li><strong>android:valueFrom</strong>:初始动化值；取值范围为float,int和color，如果取值为float对应的值样式应该为89.0，取值为Int时，对应的值样式为：89;当取值为clolor时，对应的值样式为 #333333;</li>
<li><strong>android:valueTo</strong>：动画结束值；取值范围同样是float,int和color这三种类型的值；</li>
<li><strong>android:startOffset</strong>：动画激活延时；对应代码中的startDelay(long delay)函数；</li>
<li><strong>android:repeatCount</strong>：动画重复次数</li>
<li><strong>android:repeatMode</strong>：动画重复模式，取值为repeat和reverse；repeat表示正序重播，reverse表示倒序重播</li>
<li><strong>android:valueType</strong>：表示参数值类型，取值为intType和floatType；与android:valueFrom、android:valueTo相对应。如果这里的取值为intType，那么android:valueFrom、android:valueTo的值也就要对应的是int类型的数值。如果这里的数值是floatType，那么android:valueFrom、android:valueTo的值也要对应的设置为float类型的值。非常注意的是，如果android:valueFrom、android:valueTo的值设置为color类型的值，那么不需要设置这个参数；</li>
<li><strong>android:interpolator</strong>:设置加速器；有关系统加速器所对应的xml值对照表如下：
<img src="http://ohtrrgyyd.bkt.clouddn.com/201702108384320160301085204774.jpg" alt="201702108384320160301085204774.jpg"/></li>
</ul>

<h5 id="toc_86">(2)将xml加载到程序中</h5>

<p>在定义了一个xml后，我们需要将其加载到程序中，使用的方法如下：</p>

<pre><code class="language-text">ValueAnimator valueAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(MyActivity.this,R.animator.animator);
valueAnimator.start();
</code></pre>

<h4 id="toc_87">2、objectAnimator</h4>

<h5 id="toc_88">(1)字段意义及使用方法</h5>

<pre><code class="language-markup">&lt;objectAnimator
    android:propertyName=&quot;string&quot;
    android:duration=&quot;int&quot;
    android:valueFrom=&quot;float | int | color&quot;
    android:valueTo=&quot;float | int | color&quot;
    android:startOffset=&quot;int&quot;
    android:repeatCount=&quot;int&quot;
    android:repeatMode=[&quot;repeat&quot; | &quot;reverse&quot;]
    android:valueType=[&quot;intType&quot; | &quot;floatType&quot;]
    android:interpolator=[&quot;@android:interpolator/XXX&quot;]/&gt;
</code></pre>

<ul>
<li>android:propertyName：对应属性名，即ObjectAnimator所需要操作的属性名。 <br/>
其它字段的意义与animator的意义与取值是一样的，下面再重新列举一下。 </li>
<li>android:duration:每次动画播放的时长 </li>
<li>android:valueFrom:初始动化值；取值范围为float,int和color； </li>
<li>android:valueTo：动画结束值；取值范围同样是float,int和color这三种类型的值； </li>
<li>android:startOffset：动画激活延时；对应代码中的startDelay(long delay)函数； </li>
<li>android:repeatCount：动画重复次数 </li>
<li>android:repeatMode：动画重复模式，取值为repeat和reverse；repeat表示正序重播，reverse表示倒序重播 </li>
<li>android:valueType：表示参数值类型，取值为intType和floatType；与android:valueFrom、android:valueTo相对应。如果这里的取值为intType，那么android:valueFrom、android:valueTo的值也就要对应的是int类型的数值。如果这里的数值是floatType，那么android:valueFrom、android:valueTo的值也要对应的设置为float类型的值。非常注意的是，如果android:valueFrom、android:valueTo的值设置为color类型的值，那么不需要设置这个参数； </li>
<li>android:interpolator:设置加速器。</li>
</ul>

<h5 id="toc_89">(2)将xml加载到程序中</h5>

<pre><code class="language-text">ObjectAnimator animator = (ObjectAnimator) AnimatorInflater.loadAnimator(MyActivity.this,
    R.animator.object_animator);
animator.setTarget(mTv1);
animator.start();
</code></pre>

<h4 id="toc_90">3、set</h4>

<h5 id="toc_91">(1)字段意义及使用方法</h5>

<pre><code class="language-markup">&lt;set
  android:ordering=[&quot;together&quot; | &quot;sequentially&quot;]&gt;
</code></pre>

<p>android:ordering：表示动画开始顺序。together表示同时开始动画，sequentially表示逐个开始动画； </p>

<h5 id="toc_92">(2)将xml加载到程序中</h5>

<pre><code class="language-text">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(MyActivity.this,
    R.animator.set_animator);
set.setTarget(mTv1);
set.start();
</code></pre>

<h3 id="toc_93">(二)AnimatorSet应用</h3>

<p>应用AnimatorSet例子效果：<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/201702102971920160301085911065.gif" alt="201702102971920160301085911065.gif"/></p>

<p>我们先来分析下这个效果，在用户点击按钮时，把菜单弹出来；弹出来的时候，动画一点从小变到大，一边透明度从0变到1.关键问题是，怎么样实现各个菜单以当前点击按钮为圆心排列在圆形上；</p>

<p><strong>布局代码：</strong></p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
             android:layout_width=&quot;match_parent&quot;
             android:layout_height=&quot;match_parent&quot;
             android:layout_marginBottom=&quot;10dp&quot;
             android:layout_marginRight=&quot;10dp&quot;&gt;

    &lt;Button
            android:id=&quot;@+id/menu&quot;
            style=&quot;@style/MenuStyle&quot;
            android:background=&quot;@drawable/menu&quot;/&gt;

    &lt;Button
            android:id=&quot;@+id/item1&quot;
            style=&quot;@style/MenuItemStyle&quot;
            android:background=&quot;@drawable/circle1&quot;
            android:visibility=&quot;gone&quot;/&gt;

    &lt;Button
            android:id=&quot;@+id/item2&quot;
            style=&quot;@style/MenuItemStyle&quot;
            android:background=&quot;@drawable/circle2&quot;
            android:visibility=&quot;gone&quot;/&gt;

    &lt;Button
            android:id=&quot;@+id/item3&quot;
            style=&quot;@style/MenuItemStyle&quot;
            android:background=&quot;@drawable/circle3&quot;
            android:visibility=&quot;gone&quot;/&gt;

    &lt;Button
            android:id=&quot;@+id/item4&quot;
            style=&quot;@style/MenuItemStyle&quot;
            android:background=&quot;@drawable/circle4&quot;
            android:visibility=&quot;gone&quot;/&gt;

    &lt;Button
            android:id=&quot;@+id/item5&quot;
            style=&quot;@style/MenuItemStyle&quot;
            android:background=&quot;@drawable/circle5&quot;
            android:visibility=&quot;gone&quot;/&gt;

&lt;/FrameLayout&gt;
</code></pre>

<p><strong>其中的style代码为：</strong></p>

<pre><code class="language-markup">&lt;resources&gt;
    &lt;style name=&quot;MenuStyle&quot;&gt;
        &lt;item name=&quot;android:layout_width&quot;&gt;50dp&lt;/item&gt;
        &lt;item name=&quot;android:layout_height&quot;&gt;50dp&lt;/item&gt;
        &lt;item name=&quot;android:layout_gravity&quot;&gt;right|bottom&lt;/item&gt;
    &lt;/style&gt;

    &lt;style name=&quot;MenuItemStyle&quot;&gt;
        &lt;item name=&quot;android:layout_width&quot;&gt;45dp&lt;/item&gt;
        &lt;item name=&quot;android:layout_height&quot;&gt;45dp&lt;/item&gt;
        &lt;item name=&quot;android:layout_gravity&quot;&gt;right|bottom&lt;/item&gt;
    &lt;/style&gt;
&lt;/resources&gt;
</code></pre>

<p><strong>MyActivity.java</strong></p>

<pre><code class="language-java">public class MyActivity extends Activity implements View.OnClickListener{
    private static final String TAG = &quot;MainActivity&quot;;

    private Button mMenuButton;
    private Button mItemButton1;
    private Button mItemButton2;
    private Button mItemButton3;
    private Button mItemButton4;
    private Button mItemButton5;

    private boolean mIsMenuOpen = false;
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        initView();
    }

    private void initView() {
        mMenuButton = (Button) findViewById(R.id.menu);
        mMenuButton.setOnClickListener(this);

        mItemButton1 = (Button) findViewById(R.id.item1);
        mItemButton1.setOnClickListener(this);

        mItemButton2 = (Button) findViewById(R.id.item2);
        mItemButton2.setOnClickListener(this);

        mItemButton3 = (Button) findViewById(R.id.item3);
        mItemButton3.setOnClickListener(this);

        mItemButton4 = (Button) findViewById(R.id.item4);
        mItemButton4.setOnClickListener(this);

        mItemButton5 = (Button) findViewById(R.id.item5);
        mItemButton5.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        if (v == mMenuButton) {
            if (!mIsMenuOpen) {
                mIsMenuOpen = true;
                doAnimateOpen(mItemButton1, 0, 5, 300);
                doAnimateOpen(mItemButton2, 1, 5, 300);
                doAnimateOpen(mItemButton3, 2, 5, 300);
                doAnimateOpen(mItemButton4, 3, 5, 300);
                doAnimateOpen(mItemButton5, 4, 5, 300);
            } else {
                mIsMenuOpen = false;
                doAnimateClose(mItemButton1, 0, 5, 300);
                doAnimateClose(mItemButton2, 1, 5, 300);
                doAnimateClose(mItemButton3, 2, 5, 300);
                doAnimateClose(mItemButton4, 3, 5, 300);
                doAnimateClose(mItemButton5, 4, 5, 300);
            }
        } else {
            Toast.makeText(this, &quot;你点击了&quot; + v, Toast.LENGTH_SHORT).show();
        }
    }
    private void doAnimateOpen(View view, int index, int total, int radius) {
    if (view.getVisibility() != View.VISIBLE) {
        view.setVisibility(View.VISIBLE);
    }
    double degree = Math.toRadians(90)/(total - 1) * index;
    int translationX = -(int) (radius * Math.sin(degree));
    int translationY = -(int) (radius * Math.cos(degree));

    AnimatorSet set = new AnimatorSet();
    //包含平移、缩放和透明度动画
    set.playTogether(
            ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0, translationX),
            ObjectAnimator.ofFloat(view, &quot;translationY&quot;, 0, translationY),
            ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 0f, 1f),
            ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 0f, 1f),
            ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 0f, 1));
    //动画周期为500ms
    set.setDuration(1 * 500).start();
    }
    private void doAnimateClose(final View view, int index, int total,int radius) {
        if (view.getVisibility() != View.VISIBLE) {
        view.setVisibility(View.VISIBLE);
        }
        double degree = Math.PI * index / ((total - 1) * 2);
        int translationX = -(int) (radius * Math.sin(degree));
        int translationY = -(int) (radius * Math.cos(degree));
        AnimatorSet set = new AnimatorSet();
        //包含平移、缩放和透明度动画
        set.playTogether(
           ObjectAnimator.ofFloat(view, &quot;translationX&quot;, translationX, 0),
           ObjectAnimator.ofFloat(view, &quot;translationY&quot;, translationY, 0),
           ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 0.1f),
           ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 0.1f),
           ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 1f, 0f));

            set.setDuration(1 * 500).start();
        }
}
</code></pre>

<h3 id="toc_94">(一)LayoutAnimation的xml实现——layoutAnimation标签</h3>

<h4 id="toc_95">1、概述</h4>

<p>这部分，我们就来看看layoutAnimation标签的用法，要使用layoutAnimation只需要两步： <br/>
<strong>第一：定义一个layoutAnimation的animation文件，如：(anim/layout_animation.xml)</strong></p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
                 android:delay=&quot;1&quot;
                 android:animationOrder=&quot;normal&quot;
                 android:animation=&quot;@anim/slide_in_left&quot;/&gt;
</code></pre>

<p><strong>第二步：在viewGroup类型的控件中，添加Android:layoutAnimation=”@anim/layout_animation”，如：</strong></p>

<pre><code class="language-markup">&lt;ListView
        android:id=&quot;@+id/listview&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layoutAnimation=&quot;@anim/layout_animation&quot;
        /&gt;
</code></pre>

<p><strong>注意</strong>我们可以知道最重要的一点：android:layoutAnimation只在viewGroup创建的时候，才会对其中的item添加动画。在创建成功以后，再向其中添加item将不会再有动画。</p>

<h4 id="toc_96">2、layoutAnimation各字段意义</h4>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
                 android:delay=&quot;1&quot;
                 android:animationOrder=&quot;normal&quot;
                 android:animation=&quot;@anim/slide_in_left&quot;/&gt;
</code></pre>

<ul>
<li>delay:指每个Item的动画开始延时，取值是android:animation所指定动画时长的倍数，取值类型可以是float类型，也可以是百分数，默认是0.5;比如我们这里指定的动画是@anim/slide_in_left，而在slide_in_left.xml中指定android:duration=”1000”，即单次动画的时长是1000毫秒，而我们在这里的指定android:delay=”1”，即一个Item的动画会在上一个item动画完成后延时单次动画时长的一倍时间开始，即延时1000毫秒后开始。</li>
<li>animationOrder:指viewGroup中的控件动画开始顺序，取值有normal(正序)、reverse(倒序)、random(随机)</li>
<li>animation：指定每个item入场所要应用的动画。仅能指定res/aim文件夹下的animation定义的动画，不可使用animator动画。</li>
</ul>

<h3 id="toc_97">(二）LayoutAnimation的代码实现——LayoutAnimationController</h3>

<h4 id="toc_98">1、构造函数</h4>

<pre><code class="language-text">public LayoutAnimationController(Animation animation)
public LayoutAnimationController(Animation animation, float delay)
</code></pre>

<h4 id="toc_99">2、基本函数</h4>

<pre><code class="language-java">/**
 * 设置animation动画
 */
public void setAnimation(Animation animation)
/**
 * 设置单个item开始动画延时
 */
public void setDelay(float delay)
/**
 * 设置viewGroup中控件开始动画顺序，取值为ORDER_NORMAL、ORDER_REVERSE、ORDER_RANDOM
 */
public void setOrder(int order)
</code></pre>

<h4 id="toc_100">3、示例</h4>

<p>同样以上面的例子为例，把xml实现改成代码实现。由于我们要代码实现layoutAnimation，所以我们不再需要写layoutAnimation的xml了，只需要一个动画的animation:(slide_in_left.xml)</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot;&gt;
    &lt;translate android:fromXDelta=&quot;-50%p&quot; android:toXDelta=&quot;0&quot;/&gt;
    &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot;/&gt;
&lt;/set&gt;
</code></pre>

<p>然后是主布局（main.xml）</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot;
              android:orientation=&quot;vertical&quot;&gt;


    &lt;Button
            android:id=&quot;@+id/addlist&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;添加list数据&quot;/&gt;

    &lt;ListView
            android:id=&quot;@+id/listview&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>最后我们来看看代码(MyActivity.Java)</p>

<pre><code class="language-java">public class MyActivity extends Activity {

    private ListView mListView;
    private ArrayAdapter mAdapter;

    private Button mAddListBtn;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        mListView = (ListView) findViewById(R.id.listview);
        mAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_expandable_list_item_1, getData());
        mListView.setAdapter(mAdapter);

        mAddListBtn = (Button)findViewById(R.id.addlist);
        mAddListBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mAdapter.addAll(getData());
            }
        });


        //代码设置通过加载XML动画设置文件来创建一个Animation对象；
        Animation animation= AnimationUtils.loadAnimation(this,R.anim.slide_in_left);   //得到一个LayoutAnimationController对象；
        LayoutAnimationController controller = new LayoutAnimationController(animation);   //设置控件显示的顺序；
        controller.setOrder(LayoutAnimationController.ORDER_REVERSE);   //设置控件显示间隔时间；
        controller.setDelay(0.3f);   //为ListView设置LayoutAnimationController属性；
        mListView.setLayoutAnimation(controller);
        mListView.startLayoutAnimation();
    }

    private List&lt;String&gt; getData() {

        List&lt;String&gt; data = new ArrayList&lt;String&gt;();
        data.add(&quot;测试数据1&quot;);
        data.add(&quot;测试数据2&quot;);
        data.add(&quot;测试数据3&quot;);
        data.add(&quot;测试数据4&quot;);

        return data;
    }
}
</code></pre>

<h3 id="toc_101">（三)GridLayoutAnimation的XML实现——gridLayoutAnimation</h3>

<p>这部分将给大家讲解有关gridview给内部子控件添加创建动画的内容。<br/><br/>
<img src="http://ohtrrgyyd.bkt.clouddn.com/201702101476120160303084028875.gif" alt="201702101476120160303084028875.gif"/></p>

<h4 id="toc_102">1、标签属性</h4>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;gridLayoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
                     android:rowDelay=&quot;75%&quot;
                     android:columnDelay=&quot;60%&quot;
                     android:directionPriority=&quot;none&quot;
                     android:direction=&quot;bottom_to_top|right_to_left&quot;
                     android:animation=&quot;@android:anim/slide_in_left&quot;/&gt;
</code></pre>

<ul>
<li><strong>rowDelay</strong>:每一行动画开始的延迟。与LayoutAnimation一样，可以取百分数，也可以取浮点数。取值意义为，当前android:animation所指动画时长的倍数。 </li>
<li><strong>columnDelay</strong>：每一列动画开始的延迟。取值类型及意义与rowDelay相同。 </li>
<li><strong>directionPriority</strong>：方向优先级。取值为row,collumn,none，意义分别为：行优先，列优先，和无优先级（同时进行）;具体意义，后面会细讲 </li>
<li><strong>direction</strong>：gridview动画方向。 
取值有四个：left_to_right：列，从左向右开始动画 <br/>
right_to_left ：列，从右向左开始动画 <br/>
top_to_bottom：行，从上向下开始动画 <br/>
bottom_to_top：行，从下向上开始动画 <br/>
这四个值之间可以通过“|”连接，从而可以取多个值。很显然left_to_right和right_to_left是互斥的，top_to_bottom和bottom_to_top是互斥的。如果不指定 direction字段，默认值为left_to_right | top_to_bottom；即从上往下，从左往右。 </li>
<li><strong>animation</strong>: gridview内部元素所使用的动画。</li>
</ul>

<h4 id="toc_103">2、示例</h4>

<h5 id="toc_104">(1)、首先是gride_animation.xml</h5>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;gridLayoutAnimation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
                     android:rowDelay=&quot;75%&quot;
                     android:columnDelay=&quot;60%&quot;
                     android:directionPriority=&quot;none&quot;
                     android:animation=&quot;@anim/slide_in_left&quot;/&gt;
</code></pre>

<p><strong>这里没有设置android:direction属性，采用默认值：left_to_right|top_to_bottom；然后是对应的animation动画slide_in_left.xml:</strong></p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot;&gt;
    &lt;translate android:fromXDelta=&quot;-50%p&quot; android:toXDelta=&quot;0&quot;/&gt;
    &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; /&gt;
&lt;/set&gt;
</code></pre>

<h5 id="toc_105">(2)、程序布局main.xml</h5>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot;
              android:orientation=&quot;vertical&quot;&gt;


    &lt;Button
            android:id=&quot;@+id/add_data&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;添加grid数据&quot;/&gt;


    &lt;GridView
            android:id=&quot;@+id/grid&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:columnWidth=&quot;60dp&quot;
            android:gravity=&quot;center&quot;
            android:horizontalSpacing=&quot;10dp&quot;
            android:layoutAnimation=&quot;@anim/gride_animation&quot;
            android:numColumns=&quot;auto_fit&quot;
            android:stretchMode=&quot;columnWidth&quot;
            android:verticalSpacing=&quot;10dp&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre>

<h5 id="toc_106">(3)、代码处理</h5>

<pre><code class="language-java">public class MyActivity extends Activity {
    private GridAdapter mGrideAdapter;
    private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;();

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        /**
         * 填充gridview
         */
        GridView grid = (GridView) findViewById(R.id.grid);
        mDatas.addAll(getData());
        mGrideAdapter = new GridAdapter();
        grid.setAdapter(mGrideAdapter);

        /**
         * 按钮点击响应
         */
        Button addData = (Button)findViewById(R.id.add_data);
        addData.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                addData();
            }
        });
    }


    private List&lt;String&gt; getData() {

        List&lt;String&gt; data = new ArrayList&lt;String&gt;();
        for (int i = 1;i&lt;35;i++){
            data.add(&quot;DATA &quot;+i);
        }
        return data;
    }


    public void addData(){
        mDatas.addAll(mDatas);
        mGrideAdapter.notifyDataSetChanged();
    }


    public class GridAdapter extends BaseAdapter {
        public View getView(int position, View convertView, ViewGroup parent) {
            TextView i = new TextView(MyActivity.this);
            i.setText(mDatas.get(position));
            i.setLayoutParams(new GridView.LayoutParams(GridView.LayoutParams.WRAP_CONTENT, GridView.LayoutParams.WRAP_CONTENT));
            return i;
        }

        public final int getCount() {
            return mDatas.size();
        }

        public final Object getItem(int position) {
            return null;
        }

        public final long getItemId(int position) {
            return position;
        }
    }
}
</code></pre>

<h3 id="toc_107">(四）GridLayoutAnimation的代码实现——GridLayoutAnimationController</h3>

<h4 id="toc_108">1、构造函数</h4>

<pre><code class="language-text">public GridLayoutAnimationController(Animation animation)
public GridLayoutAnimationController(Animation animation, float columnDelay, float rowDelay)
</code></pre>

<h4 id="toc_109">2、其他方法</h4>

<pre><code class="language-java">/**
 * 设置列动画开始延迟
 */
public void setColumnDelay(float columnDelay)
/**
 * 设置行动画开始延迟
 */
 public void setRowDelay(float rowDelay)
 /**
 * 设置gridview动画的入场方向。取值有：DIRECTION_BOTTOM_TO_TOP、DIRECTION_TOP_TO_BOTTOM、DIRECTION_LEFT_TO_RIGHT、DIRECTION_RIGHT_TO_LEFT
 */
 public void setDirection(int direction)
 /**
 * 动画开始优先级，取值有PRIORITY_COLUMN、PRIORITY_NONE、PRIORITY_ROW
 */
 public void setDirectionPriority(int directionPriority)
</code></pre>

<h4 id="toc_110">3、示例</h4>

<p>创建一个slide_in_left.xml文件</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot;&gt;
    &lt;translate android:fromXDelta=&quot;-50%p&quot; android:toXDelta=&quot;0&quot;/&gt;
    &lt;alpha android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; /&gt;
&lt;/set&gt;
</code></pre>

<p>然后是布局文件main.xml:</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot;
              android:orientation=&quot;vertical&quot;&gt;


    &lt;GridView
            android:id=&quot;@+id/grid&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:columnWidth=&quot;60dp&quot;
            android:gravity=&quot;center&quot;
            android:horizontalSpacing=&quot;10dp&quot;
            android:numColumns=&quot;auto_fit&quot;
            android:stretchMode=&quot;columnWidth&quot;
            android:verticalSpacing=&quot;10dp&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>最后是MyActivity中的填充部分：</p>

<pre><code class="language-java">public class MyActivity extends Activity {
    private GridAdapter mGrideAdapter;
    private List&lt;String&gt; mDatas = new ArrayList&lt;&gt;();
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        /**
         * 填充gridview
         */
        GridView grid = (GridView) findViewById(R.id.grid);
        mDatas.addAll(getData());
        mGrideAdapter = new GridAdapter();
        grid.setAdapter(mGrideAdapter);

        Animation animation = AnimationUtils.loadAnimation(MyActivity.this,R.anim.slide_in_left);
        GridLayoutAnimationController controller = new GridLayoutAnimationController(animation);
        controller.setColumnDelay(0.75f);
        controller.setRowDelay(0.5f);
        controller.setDirection(GridLayoutAnimationController.DIRECTION_BOTTOM_TO_TOP|GridLayoutAnimationController.DIRECTION_LEFT_TO_RIGHT);
        controller.setDirectionPriority(GridLayoutAnimationController.PRIORITY_NONE);
        grid.setLayoutAnimation(controller);
        grid.startLayoutAnimation();
    }

    private List&lt;String&gt; getData() {

        List&lt;String&gt; data = new ArrayList&lt;String&gt;();
        for (int i = 1;i&lt;35;i++){
            data.add(&quot;DATA &quot;+i);
        }
        return data;
    }


    public void addData(){
        mDatas.addAll(mDatas);
        mGrideAdapter.notifyDataSetChanged();
    }


    public class GridAdapter extends BaseAdapter {
        public View getView(int position, View convertView, ViewGroup parent) {
            TextView i = new TextView(MyActivity.this);
            i.setText(mDatas.get(position));
            i.setLayoutParams(new GridView.LayoutParams(GridView.LayoutParams.WRAP_CONTENT, GridView.LayoutParams.WRAP_CONTENT));
            return i;
        }

        public final int getCount() {
            return mDatas.size();
        }

        public final Object getItem(int position) {
            return null;
        }

        public final long getItemId(int position) {
            return position;
        }
    }
}
</code></pre>

<h2 id="toc_111">八、animateLayoutChanges与LayoutTransition</h2>

<p>之前说的LayoutAnimation虽能实现ViewGroup的进入动画，但只能在创建时有效。在创建后，再往里添加控件就不会再有动画。在API 11后，又添加了两个能实现在创建后添加控件仍能应用动画的方法，分别是Android:animateLayoutChanges属性和LayoutTransition类。</p>

<h3 id="toc_112">(一)android:animateLayoutChanges属性</h3>

<p>所有派生自ViewGroup的控件都具有此属性，只要在XML中添加上这个属性，就能实现添加/删除其中控件时，带有默认动画了。</p>

<p><img src="http://ohtrrgyyd.bkt.clouddn.com/201702101887320160326102726242.gif" alt="201702101887320160326102726242.gif"/></p>

<h4 id="toc_113">1、简单示例</h4>

<h5 id="toc_114">(1)main.xml布局代码</h5>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
              android:layout_width=&quot;match_parent&quot;  
              android:layout_height=&quot;match_parent&quot;  
              android:orientation=&quot;vertical&quot;&gt;  
  
    &lt;LinearLayout  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:orientation=&quot;horizontal&quot;&gt;  
  
        &lt;Button  
                android:id=&quot;@+id/add_btn&quot;  
                android:layout_width=&quot;wrap_content&quot;  
                android:layout_height=&quot;wrap_content&quot;  
                android:text=&quot;添加控件&quot;/&gt;  
  
        &lt;Button  
                android:id=&quot;@+id/remove_btn&quot;  
                android:layout_width=&quot;wrap_content&quot;  
                android:layout_height=&quot;wrap_content&quot;  
                android:text=&quot;移除控件&quot;/&gt;  
    &lt;/LinearLayout&gt;  
  
  
    &lt;LinearLayout  
            android:id=&quot;@+id/layoutTransitionGroup&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:animateLayoutChanges=&quot;true&quot;  
            android:orientation=&quot;vertical&quot;/&gt;  
  
&lt;/LinearLayout&gt;
</code></pre>

<h5 id="toc_115">(2)MyActivity代码</h5>

<pre><code class="language-java">public class MyActivity extends Activity implements View.OnClickListener {  
    private LinearLayout layoutTransitionGroup;  
  
    private int i = 0;  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
  
        layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup);  
        findViewById(R.id.add_btn).setOnClickListener(this);  
        findViewById(R.id.remove_btn).setOnClickListener(this);  
    }  
  
    private void addButtonView() {  
        i++;  
        Button button = new Button(this);  
        button.setText(&quot;button&quot; + i);  
        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,  
                ViewGroup.LayoutParams.WRAP_CONTENT);  
        button.setLayoutParams(params);  
        layoutTransitionGroup.addView(button, 0);  
    }  
  
    private void removeButtonView() {  
        if (i &gt; 0) {  
            layoutTransitionGroup.removeViewAt(0);  
        }  
        i--;  
    }  
  
    @Override  
    public void onClick(View v) {  
        if (v.getId() == R.id.add_btn) {  
            addButtonView();  
        }  
        if (v.getId() == R.id.remove_btn) {  
            removeButtonView();  
        }  
  
    }  
}
</code></pre>

<h3 id="toc_116">(二）LayoutTransaction</h3>

<h4 id="toc_117">1、概述</h4>

<p>上面虽然在ViewGroup类控件XML中仅添加一行android:animateLayoutChanges=[true]即可实现内部控件添加删除时都加上动画效果。但却只能使用默认动画效果，而无法自定义动画。 <br/>
为了能让我们自定义动画，谷歌在API 11时，同时为我们引入了一个类LayoutTransaction。 <br/>
要使用LayoutTransaction是非常容易的，只需要三步：</p>

<h5 id="toc_118">第一步：创建实例</h5>

<pre><code class="language-text">LayoutTransaction transitioner = new LayoutTransition();
</code></pre>

<h5 id="toc_119">第二步：创建动画并设置</h5>

<pre><code class="language-text">ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);  
transitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);
</code></pre>

<h5 id="toc_120">第三步：将LayoutTransaction设置进ViewGroup</h5>

<pre><code class="language-text">linearLayout.setLayoutTransition(mTransitioner); 
</code></pre>

<p>在第二步中，transitioner.setAnimator设置动画的函数声明为：</p>

<pre><code class="language-text">public void setAnimator(int transitionType, Animator animator)
</code></pre>

<p>第一个参数int transitionType：表示当前应用动画的对象范围，取值有：</p>

<ul>
<li>APPEARING —— 元素在容器中出现时所定义的动画。</li>
<li>DISAPPEARING —— 元素在容器中消失时所定义的动画。</li>
<li>CHANGE_APPEARING —— 由于容器中要显现一个新的元素，其它需要变化的元素所应用的动画</li>
<li>CHANGE_DISAPPEARING —— 当容器中某个元素消失，其它需要变化的元素所应用的动画 </li>
</ul>

<h4 id="toc_121">2、LayoutTransition.CHANGE_APPEARING与LayoutTransition.CHANGE_DISAPPEARING</h4>

<p>在添加控件时，除了被添加控件本身的入场动画以外，其它需要移动位置的控件，在移动位置时，也被添加上了动画（left点位移动画），这些除了被添加控件以外的其它需要移动位置的控件组合，所对应的动画就是LayoutTransition.CHANGE_APPEARING <br/>
同样，在移除一个控件时，因为移除了一个控件，而其它所有需要改变位置的控件组合所对应的动画就是LayoutTransition.CHANGE_DISAPPEARING</p>

<h5 id="toc_122">LayoutTransition.CHANGE_APPEARING实现</h5>

<pre><code class="language-java">public void onCreate(Bundle savedInstanceState) {  
    super.onCreate(savedInstanceState);  
    setContentView(R.layout.main);  
  
    layoutTransitionGroup = (LinearLayout) findViewById(R.id.layoutTransitionGroup);  
    findViewById(R.id.add_btn).setOnClickListener(this);  
    findViewById(R.id.remove_btn).setOnClickListener(this);  
  
    mTransitioner = new LayoutTransition();  
    //入场动画:view在这个容器中消失时触发的动画  
    ObjectAnimator animIn = ObjectAnimator.ofFloat(null, &quot;rotationY&quot;, 0f, 360f,0f);  
    mTransitioner.setAnimator(LayoutTransition.APPEARING, animIn);  
  
    //出场动画:view显示时的动画  
    ObjectAnimator animOut = ObjectAnimator.ofFloat(null, &quot;rotation&quot;, 0f, 90f, 0f);  
    mTransitioner.setAnimator(LayoutTransition.DISAPPEARING, animOut);  
  
    PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt(&quot;left&quot;,0,100,0);  
    PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt(&quot;top&quot;,1,1);  
    Animator changeAppearAnimator  
            = ObjectAnimator.ofPropertyValuesHolder(layoutTransitionGroup, pvhLeft,pvhBottom,pvhTop,pvhRight);  
    mTransitioner.setAnimator(LayoutTransition.CHANGE_APPEARING,changeAppearAnimator);  
  
    layoutTransitionGroup.setLayoutTransition(mTransitioner);  
}
</code></pre>

<p><strong>注意</strong>  </p>

<ul>
<li>LayoutTransition.CHANGE_APPEARING和LayoutTransition.CHANGE_DISAPPEARING必须使用PropertyValuesHolder所构造的动画才会有效果，不然无效！也就是说使用ObjectAnimator构造的动画，在这里是不会有效果的！ </li>
<li>在构造PropertyValuesHolder动画时，”left”、”top”属性的变动是必写的。如果不需要变动，则直接写为：</li>
<li>在构造PropertyValuesHolder时，所使用的ofInt,ofFloat中的参数值，第一个值和最后一个值必须相同，不然此属性所对应的的动画将被放弃，在此属性值上将不会有效果；</li>
<li>在构造PropertyValuesHolder时，所使用的ofInt,ofFloat中，如果所有参数值都相同，也将不会有动画效果。 </li>
</ul>

<h2 id="toc_123">九、实现ListView Item进入动画</h2>

<pre><code class="language-java">public class ListAdapter extends BaseAdapter {  
    private List&lt;Drawable&gt; mDrawableList = new ArrayList&lt;&gt;();  
    private int mLength = 0;  
    private LayoutInflater mInflater;  
    private Context mContext;  
    private ListView mListView;  
    private Animation animation;  
  
    AbsListView.OnScrollListener mOnScrollListener = new AbsListView.OnScrollListener() {  
        @Override  
        public void onScrollStateChanged(AbsListView view, int scrollState) {  
  
        }  
  
        @Override  
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {  
            View firstChild = view.getChildAt(0);  
            if (firstChild == null) return;  
            int top = firstChild.getTop();  
            /** 
             * firstVisibleItem &gt; mFirstPosition表示向下滑动一整个Item 
             * mFirstTop &gt; top表示在当前这个item中滑动 
             */  
            isScrollDown = firstVisibleItem &gt; mFirstPosition || mFirstTop &gt; top;  
            mFirstTop = top;  
            mFirstPosition = firstVisibleItem; 
        }  
    };

    public ListAdapter(Context context, ListView listView, List&lt;Drawable&gt; drawables, int length) {  
        mDrawableList.addAll(drawables);  
        mLength = length;  
        mInflater = LayoutInflater.from(context);  
        mContext = context;  
        mListView = listView;  
        animation = AnimationUtils.loadAnimation(mContext,R.anim.bottom_in_anim);  
    }  
  
    @Override  
    public int getCount() {  
        return mLength;  
    }  
  
    @Override  
    public Object getItem(int position) {  
        return mDrawableList.get(position % mDrawableList.size());  
    }  
  
    @Override  
    public long getItemId(int position) {  
        return position;  
    }  
  
    @Override  
    public View getView(int position, View convertView, ViewGroup parent) {  
        ViewHolder holder = null;  
  
        if (convertView == null) {  
  
            holder = new ViewHolder();  
            convertView = mInflater.inflate(R.layout.item_layout, null);  
            holder.mImageView = (ImageView) convertView.findViewById(R.id.img);  
            holder.mTextView = (TextView) convertView.findViewById(R.id.text);  
        } else {  
            holder = (ViewHolder) convertView.getTag();  
        } 
        //清除当前显示区域中所有item的动画  
         for (int i=0;i&lt;mListView.getChildCount();i++){  
            View view = mListView.getChildAt(i);  
            view.clearAnimation();  
         } 
        if (isScrollDown) {  
        convertView.startAnimation(animation);  
         }  
        convertView.setTag(holder);  
  
        holder.mImageView.setImageDrawable(mDrawableList.get(position % mDrawableList.size()));  
        holder.mTextView.setText(position+&quot;&quot;);  
  
        return convertView;  
    }  
  
    public class ViewHolder {  
        public ImageView mImageView;  
        public TextView mTextView;  
    }  
}
</code></pre>

<p><strong>摘记自<a href="http://blog.csdn.net/harvic880925/article/details/50995268">Android自定义控件三部曲文章索引</a></strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502773142.html">
                
                  <h1>常用color</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>因为有许多颜色是常用的，避免以后查找，记录在这里进行比对</p>

<p><code>&lt;color name=&quot;white&quot;&gt;#FFFFFF&lt;/color&gt;&lt;!--白色 --&gt;</code><font color="#FFFFFF"> 白色 </font><br/><br/>
<code>&lt;color name=&quot;ivory&quot;&gt;#FFFFF0&lt;/color&gt;&lt;!--象牙色 --&gt;</code><font color="#FFFFF0"> 象牙色 </font><br/><br/>
<code>&lt;color name=&quot;lightyellow&quot;&gt;#FFFFE0&lt;/color&gt;&lt;!--亮黄色--&gt;</code><font color="#FFFFE0"> 亮黄色 </font><br/><br/>
<code>&lt;color name=&quot;yellow&quot;&gt;#FFFF00&lt;/color&gt;&lt;!--黄色 --&gt;</code><font color="#FFFF00"> 黄色 </font><br/><br/>
<code>&lt;color name=&quot;snow&quot;&gt;#FFFAFA&lt;/color&gt;&lt;!--雪白色 --&gt;</code><font color="#FFFAFA"> 雪白色 </font><br/><br/>
<code>&lt;color name=&quot;floralwhite&quot;&gt;#FFFAF0&lt;/color&gt;&lt;!--花白色 --&gt;</code><font color="#FFFAF0"> 花白色 </font><br/><br/>
<code>&lt;color name=&quot;lemonchiffon&quot;&gt;#FFFACD&lt;/color&gt;&lt;!--柠檬绸色 --&gt;</code><font color="#FFFACD">柠檬绸色</font><br/><br/>
<code>&lt;color name=&quot;cornsilk&quot;&gt;#FFF8DC&lt;/color&gt;&lt;!--米绸色 --&gt;</code><font color="#FFF8DC"> 米绸色 </font><br/><br/>
<code>&lt;color name=&quot;seashell&quot;&gt;#FFF5EE&lt;/color&gt;&lt;!--海贝色 --&gt;</code><font color="#FFF5EE"> 海贝色 </font><br/><br/>
<code>&lt;color name=&quot;lavenderblush&quot;&gt;#FFF0F5&lt;/color&gt;&lt;!--淡紫红 --&gt;</code><font color="#FFF0F5"> 淡紫红 </font><br/><br/>
<code>&lt;color name=&quot;papayawhip&quot;&gt;#FFEFD5&lt;/color&gt;&lt;!--番木色 --&gt;</code><font color="#FFEFD5"> 番木色 </font><br/><br/>
<code>&lt;color name=&quot;blanchedalmond&quot;&gt;#FFEBCD&lt;/color&gt;&lt;!--白杏色 --&gt;</code><font color="#FFEBCD"> 白杏色 </font><br/><br/>
<code>&lt;color name=&quot;mistyrose&quot;&gt;#FFE4E1&lt;/color&gt;&lt;!--浅玫瑰色 --&gt;</code><font color="#FFE4E1"> 浅玫瑰色 </font><br/><br/>
<code>&lt;color name=&quot;bisque&quot;&gt;#FFE4C4&lt;/color&gt;&lt;!--桔黄色 --&gt;</code><font color="#FFE4C4"> 桔黄色 </font><br/><br/>
<code>&lt;color name=&quot;moccasin&quot;&gt;#FFE4B5&lt;/color&gt;&lt;!--鹿皮色 --&gt;</code><font color="#FFE4B5"> 鹿皮色 </font><br/><br/>
<code>&lt;color name=&quot;navajowhite&quot;&gt;#FFDEAD&lt;/color&gt;&lt;!--纳瓦白 --&gt;</code><font color="#FFDEAD"> 纳瓦白 </font><br/><br/>
<code>&lt;color name=&quot;peachpuff&quot;&gt;#FFDAB9&lt;/color&gt;&lt;!--桃色 --&gt;</code><font color="#FFDAB9"> 桃色 </font><br/><br/>
<code>&lt;color name=&quot;gold&quot;&gt;#FFD700&lt;/color&gt;&lt;!--金色 --&gt;</code><font color="#FFD700"> 金色 </font><br/><br/>
<code>&lt;color name=&quot;pink&quot;&gt;#FFC0CB&lt;/color&gt;&lt;!--粉红色 --&gt;</code><font color="#FFC0CB"> 粉红色 </font><br/><br/>
<code>&lt;color name=&quot;lightpink&quot;&gt;#FFB6C1&lt;/color&gt;&lt;!--亮粉红色--&gt;</code><font color="#FFB6C1"> 亮粉红色 </font><br/><br/>
<code>&lt;color name=&quot;orange&quot;&gt;#FFA500&lt;/color&gt;&lt;!--橙色 --&gt;</code><font color="#FFA500"> 橙色 </font><br/><br/>
<code>&lt;color name=&quot;lightsalmon&quot;&gt;#FFA07A&lt;/color&gt;&lt;!--亮肉色 --&gt;</code><font color="#FFA07A"> 亮肉色 </font><br/><br/>
<code>&lt;color name=&quot;darkorange&quot;&gt;#FF8C00&lt;/color&gt;&lt;!--暗桔黄色 --&gt;</code><font color="#FF8C00"> 暗桔黄色 </font><br/><br/>
<code>&lt;color name=&quot;coral&quot;&gt;#FF7F50&lt;/color&gt;&lt;!--珊瑚色 --&gt;</code><font color="#FF7F50"> 珊瑚色 </font><br/><br/>
<code>&lt;color name=&quot;hotpink&quot;&gt;#FF69B4&lt;/color&gt;&lt;!--热粉红色 --&gt;</code><font color="#FF69B4"> 热粉红色 </font><br/><br/>
<code>&lt;color name=&quot;tomato&quot;&gt;#FF6347&lt;/color&gt;&lt;!--西红柿色 --&gt;</code><font color="#FF6347"> 西红柿色 </font><br/><br/>
<code>&lt;color name=&quot;orangered&quot;&gt;#FF4500&lt;/color&gt;&lt;!--红橙色 --&gt;</code><font color="#FF4500"> 红橙色 </font><br/><br/>
<code>&lt;color name=&quot;deeppink&quot;&gt;#FF1493&lt;/color&gt;&lt;!--深粉红色 --&gt;</code><font color="#FF1493"> 深粉红色 </font><br/><br/>
<code>&lt;color name=&quot;fuchsia&quot;&gt;#FF00FF&lt;/color&gt;&lt;!--紫红色 --&gt;</code><font color="#FF00FF"> 紫红色 </font><br/><br/>
<code>&lt;color name=&quot;magenta&quot;&gt;#FF00FF&lt;/color&gt;&lt;!--红紫色 --&gt;</code><font color="#FF00FF"> 红紫色 </font><br/><br/>
<code>&lt;color name=&quot;red&quot;&gt;#FF0000&lt;/color&gt;&lt;!--红色 --&gt;</code><font color="#FF0000"> 红色 </font><br/><br/>
<code>&lt;color name=&quot;oldlace&quot;&gt;#FDF5E6&lt;/color&gt;&lt;!--老花色 --&gt;</code><font color="#FDF5E6"> 老花色 </font><br/><br/>
<code>&lt;color name=&quot;lightgoldenrodyellow&quot;&gt;#FAFAD2&lt;/color&gt;&lt;!--亮金黄色 --&gt;</code><font color="#FAFAD2"> 亮金黄 </font><br/><br/>
<code>&lt;color name=&quot;linen&quot;&gt;#FAF0E6&lt;/color&gt;&lt;!--亚麻色 --&gt;</code><font color="#FAF0E6"> 亚麻色 </font><br/><br/>
<code>&lt;color name=&quot;antiquewhite&quot;&gt;#FAEBD7&lt;/color&gt;&lt;!--古董白 --&gt;</code><font color="#FAEBD7"> 古董白 </font><br/><br/>
<code>&lt;color name=&quot;salmon&quot;&gt;#FA8072&lt;/color&gt;&lt;!--鲜肉色 --&gt;</code><font color="#FA8072"> 鲜肉色 </font><br/><br/>
<code>&lt;color name=&quot;ghostwhite&quot;&gt;#F8F8FF&lt;/color&gt;&lt;!--幽灵白 --&gt;</code><font color="#F8F8FF"> 幽灵白 </font><br/><br/>
<code>&lt;color name=&quot;mintcream&quot;&gt;#F5FFFA&lt;/color&gt;&lt;!--薄荷色 --&gt;</code><font color="#F5FFFA"> 薄荷色 </font><br/><br/>
<code>&lt;color name=&quot;whitesmoke&quot;&gt;#F5F5F5&lt;/color&gt;&lt;!--烟白色 --&gt;</code><font color="#F5F5F5"> 烟白色 </font><br/><br/>
<code>&lt;color name=&quot;beige&quot;&gt;#F5F5DC&lt;/color&gt;&lt;!--米色 --&gt;</code><font color="#F5F5DC"> 米色 </font><br/><br/>
<code>&lt;color name=&quot;wheat&quot;&gt;#F5DEB3&lt;/color&gt;&lt;!--浅黄色 --&gt;</code><font color="#F5DEB3"> 浅黄色 </font><br/><br/>
<code>&lt;color name=&quot;sandybrown&quot;&gt;#F4A460&lt;/color&gt;&lt;!--沙褐色--&gt;</code><font color="#F4A460"> 沙褐色 </font><br/><br/>
<code>&lt;color name=&quot;azure&quot;&gt;#F0FFFF&lt;/color&gt;&lt;!--天蓝色 --&gt;</code><font color="#F0FFFF"> 天蓝色 </font><br/><br/>
<code>&lt;color name=&quot;honeydew&quot;&gt;#F0FFF0&lt;/color&gt;&lt;!--蜜色 --&gt;</code><font color="#F0FFF0"> 蜜色 </font><br/><br/>
<code>&lt;color name=&quot;aliceblue&quot;&gt;#F0F8FF&lt;/color&gt;&lt;!--艾利斯兰 --&gt;</code><font color="#F0F8FF"> 艾利斯兰 </font><br/><br/>
<code>&lt;color name=&quot;khaki&quot;&gt;#F0E68C&lt;/color&gt;&lt;!--黄褐色 --&gt;</code><font color="#F0E68C"> 黄褐色 </font><br/><br/>
<code>&lt;color name=&quot;lightcoral&quot;&gt;#F08080&lt;/color&gt;&lt;!--亮珊瑚色 --&gt;</code><font color="#F08080"> 亮珊瑚色 </font><br/><br/>
<code>&lt;color name=&quot;palegoldenrod&quot;&gt;#EEE8AA&lt;/color&gt;&lt;!--苍麒麟色 --&gt;</code><font color="#EEE8AA"> 苍麒麟色 </font><br/><br/>
<code>&lt;color name=&quot;violet&quot;&gt;#EE82EE&lt;/color&gt;&lt;!--紫罗兰色 --&gt;</code><font color="#EE82EE"> 紫罗兰色 </font><br/><br/>
<code>&lt;color name=&quot;darksalmon&quot;&gt;#E9967A&lt;/color&gt;&lt;!--暗肉色 --&gt;</code><font color="#E9967A"> 暗肉色 </font><br/><br/>
<code>&lt;color name=&quot;lavender&quot;&gt;#E6E6FA&lt;/color&gt;&lt;!--淡紫色 --&gt;</code><font color="#E6E6FA"> 淡紫色 </font><br/><br/>
<code>&lt;color name=&quot;lightcyan&quot;&gt;#E0FFFF&lt;/color&gt;&lt;!--亮青色 --&gt;</code><font color="#E0FFFF"> 亮青色 </font><br/><br/>
<code>&lt;color name=&quot;burlywood&quot;&gt;#DEB887&lt;/color&gt;&lt;!--实木色 --&gt;</code><font color="#DEB887"> 实木色 </font><br/><br/>
<code>&lt;color name=&quot;plum&quot;&gt;#DDA0DD&lt;/color&gt;&lt;!--洋李色 --&gt;</code><font color="#DDA0DD"> 洋李色 </font><br/><br/>
<code>&lt;color name=&quot;gainsboro&quot;&gt;#DCDCDC&lt;/color&gt;&lt;!--淡灰色 --&gt;</code><font color="#DCDCDC"> 淡灰色 </font><br/><br/>
<code>&lt;color name=&quot;crimson&quot;&gt;#DC143C&lt;/color&gt;&lt;!--暗深红色 --&gt;</code><font color="#DC143C"> 暗深红色 </font><br/><br/>
<code>&lt;color name=&quot;palevioletred&quot;&gt;#DB7093&lt;/color&gt;&lt;!--苍紫罗兰色 --&gt;</code><font color="#DB7093"> 苍紫罗兰色 </font><br/><br/>
<code>&lt;color name=&quot;goldenrod&quot;&gt;#DAA520&lt;/color&gt;&lt;!--金麒麟色 --&gt;</code><font color="#DAA520"> 金麒麟色 </font><br/><br/>
<code>&lt;color name=&quot;orchid&quot;&gt;#DA70D6&lt;/color&gt;&lt;!--淡紫色 --&gt;</code><font color="#DA70D6"> 淡紫色 </font><br/><br/>
<code>&lt;color name=&quot;thistle&quot;&gt;#D8BFD8&lt;/color&gt;&lt;!--蓟色 --&gt;</code><font color="#D8BFD8"> 蓟色 </font><br/><br/>
<code>&lt;color name=&quot;lightgray&quot;&gt;#D3D3D3&lt;/color&gt;&lt;!--亮灰色 --&gt;</code><font color="#D3D3D3"> 亮灰色 </font><br/><br/>
<code>&lt;color name=&quot;tan&quot;&gt;#D2B48C&lt;/color&gt;&lt;!--茶色 --&gt;</code><font color="#D2B48C"> 茶色 </font><br/><br/>
<code>&lt;color name=&quot;chocolate&quot;&gt;#D2691E&lt;/color&gt;&lt;!--巧可力色 --&gt;</code><font color="#D2691E"> 巧可力色 </font><br/><br/>
<code>&lt;color name=&quot;peru&quot;&gt;#CD853F&lt;/color&gt;&lt;!--秘鲁色 --&gt;</code><font color="#CD853F"> 秘鲁色 </font><br/><br/>
<code>&lt;color name=&quot;indianred&quot;&gt;#CD5C5C&lt;/color&gt;&lt;!--印第安红 --&gt;</code><font color="#CD5C5C"> 印第安红 </font><br/><br/>
<code>&lt;color name=&quot;mediumvioletred&quot;&gt;#C71585&lt;/color&gt;&lt;!--中紫罗兰色 --&gt;</code><font color="#C71585"> 中紫罗兰色 </font><br/><br/>
<code>&lt;color name=&quot;silver&quot;&gt;#C0C0C0&lt;/color&gt;&lt;!--银色 --&gt;</code><font color="#C0C0C0"> 银色 </font><br/><br/>
<code>&lt;color name=&quot;darkkhaki&quot;&gt;#BDB76B&lt;/color&gt;&lt;!--暗黄褐色 --&gt;</code><font color="#BDB76B"> 暗黄褐色 </font><br/><br/>
<code>&lt;color name=&quot;rosybrown&quot;&gt;#BC8F8F&lt;/color&gt; &lt;!--褐玫瑰红 --&gt;</code><font color="#BC8F8F"> 褐玫瑰红 </font><br/><br/>
<code>&lt;color name=&quot;mediumorchid&quot;&gt;#BA55D3&lt;/color&gt;&lt;!--中粉紫色 --&gt;</code><font color="#BA55D3"> 中粉紫色 </font><br/><br/>
<code>&lt;color name=&quot;darkgoldenrod&quot;&gt;#B8860B&lt;/color&gt;&lt;!--暗金黄色 --&gt;</code><font color="#B8860B"> 暗金黄色 </font><br/><br/>
<code>&lt;color name=&quot;firebrick&quot;&gt;#B22222&lt;/color&gt;&lt;!--火砖色 --&gt;</code><font color="#B22222"> 火砖色 </font><br/><br/>
<code>&lt;color name=&quot;powderblue&quot;&gt;#B0E0E6&lt;/color&gt;&lt;!--粉蓝色 --&gt;</code><font color="#B0E0E6"> 粉蓝色 </font><br/><br/>
<code>&lt;color name=&quot;lightsteelblue&quot;&gt;#B0C4DE&lt;/color&gt;&lt;!--亮钢兰色 --&gt;</code><font color="#B0C4DE"> 亮钢兰色 </font><br/><br/>
<code>&lt;color name=&quot;paleturquoise&quot;&gt;#AFEEEE&lt;/color&gt;&lt;!--苍宝石绿 --&gt;</code><font color="#AFEEEE"> 苍宝石绿 </font><br/><br/>
<code>&lt;color name=&quot;greenyellow&quot;&gt;#ADFF2F&lt;/color&gt;&lt;!--黄绿色 --&gt;</code><font color="#ADFF2F"> 黄绿色 </font><br/><br/>
<code>&lt;color name=&quot;lightblue&quot;&gt;#ADD8E6&lt;/color&gt;&lt;!--亮蓝色 --&gt;</code><font color="#ADD8E6"> 亮蓝色 </font><br/><br/>
<code>&lt;color name=&quot;darkgray&quot;&gt;#A9A9A9&lt;/color&gt;&lt;!--暗灰色 --&gt;</code><font color="#A9A9A9"> 暗灰色 </font><br/><br/>
<code>&lt;color name=&quot;brown&quot;&gt;#A52A2A&lt;/color&gt;&lt;!--褐色 --&gt;</code><font color="#A52A2A"> 褐色 </font><br/><br/>
<code>&lt;color name=&quot;sienna&quot;&gt;#A0522D&lt;/color&gt;&lt;!--赭色 --&gt;</code><font color="#A0522D"> 赭色 </font><br/><br/>
<code>&lt;color name=&quot;darkorchid&quot;&gt;#9932CC&lt;/color&gt;&lt;!--暗紫色--&gt;</code><font color="#9932CC"> 暗紫色 </font><br/><br/>
<code>&lt;color name=&quot;palegreen&quot;&gt;#98FB98&lt;/color&gt;&lt;!--苍绿色 --&gt;</code><font color="#98FB98"> 苍绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkviolet&quot;&gt;#9400D3&lt;/color&gt;&lt;!--暗紫罗兰色 --&gt;</code><font color="#9400D3"> 暗紫罗兰色 </font><br/><br/>
<code>&lt;color name=&quot;mediumpurple&quot;&gt;#9370DB&lt;/color&gt;&lt;!--中紫色 --&gt;</code><font color="#9370DB"> 中紫色 </font><br/><br/>
<code>&lt;color name=&quot;lightgreen&quot;&gt;#90EE90&lt;/color&gt;&lt;!--亮绿色 --&gt;</code><font color="#90EE90"> 亮绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkseagreen&quot;&gt;#8FBC8F&lt;/color&gt;&lt;!--暗海兰色 --&gt;</code><font color="#8FBC8F"> 暗海兰色 </font><br/><br/>
<code>&lt;color name=&quot;saddlebrown&quot;&gt;#8B4513&lt;/color&gt;&lt;!--重褐色 --&gt;</code><font color="#8B4513"> 重褐色 </font><br/><br/>
<code>&lt;color name=&quot;darkmagenta&quot;&gt;#8B008B&lt;/color&gt;&lt;!--暗洋红 --&gt;</code><font color="#8B008B"> 暗洋红 </font><br/><br/>
<code>&lt;color name=&quot;darkred&quot;&gt;#8B0000&lt;/color&gt;&lt;!--暗红色 --&gt;</code><font color="#8B0000"> 暗红色 </font><br/><br/>
<code>&lt;color name=&quot;blueviolet&quot;&gt;#8A2BE2&lt;/color&gt;&lt;!--紫罗兰蓝色 --&gt;</code><font color="#8A2BE2"> 紫罗兰蓝色 </font><br/><br/>
<code>&lt;color name=&quot;lightskyblue&quot;&gt;#87CEFA&lt;/color&gt;&lt;!--亮天蓝色 --&gt;</code><font color="#87CEFA"> 亮天蓝色 </font><br/><br/>
<code>&lt;color name=&quot;skyblue&quot;&gt;#87CEEB&lt;/color&gt;&lt;!--天蓝色 --&gt;</code><font color="#87CEEB"> 天蓝色 </font><br/><br/>
<code>&lt;color name=&quot;gray&quot;&gt;#808080&lt;/color&gt;&lt;!--灰色 --&gt;</code><font color="#808080"> 灰色 </font><br/><br/>
<code>&lt;color name=&quot;olive&quot;&gt;#808000&lt;/color&gt;&lt;!--橄榄色 --&gt;</code><font color="#808000">橄榄色</font><br/><br/>
<code>&lt;color name=&quot;purple&quot;&gt;#800080&lt;/color&gt;&lt;!--紫色 --&gt;</code><font color="#800080"> 紫色 </font><br/><br/>
<code>&lt;color name=&quot;maroon&quot;&gt;#800000&lt;/color&gt;&lt;!--粟色 --&gt;</code><font color="#800000"> 粟色 </font><br/><br/>
<code>&lt;color name=&quot;aquamarine&quot;&gt;#7FFFD4&lt;/color&gt;&lt;!--碧绿色--&gt;</code><font color="#7FFFD4"> 碧绿色 </font><br/><br/>
<code>&lt;color name=&quot;chartreuse&quot;&gt;#7FFF00&lt;/color&gt;&lt;!--黄绿色 --&gt;</code><font color="#7FFF00"> 黄绿色 </font><br/><br/>
<code>&lt;color name=&quot;lawngreen&quot;&gt;#7CFC00&lt;/color&gt;&lt;!--草绿色 --&gt;</code><font color="#7CFC00"> 草绿色 </font><br/><br/>
<code>&lt;color name=&quot;mediumslateblue&quot;&gt;#7B68EE&lt;/color&gt;&lt;!--中暗蓝色 --&gt;</code><font color="#7B68EE"> 中暗蓝色 </font><br/><br/>
<code>&lt;color name=&quot;lightslategray&quot;&gt;#778899&lt;/color&gt;&lt;!--亮蓝灰 --&gt;</code><font color="#778899"> 亮蓝灰 </font><br/><br/>
<code>&lt;color name=&quot;slategrey&quot;&gt;#708090&lt;/color&gt;&lt;!--灰石色 --&gt;</code><font color="#708090"> 灰石色 </font><br/><br/>
<code>&lt;color name=&quot;olivedrab&quot;&gt;#6B8E23&lt;/color&gt;&lt;!--深绿褐色 --&gt;</code><font color="#6B8E23"> 深绿褐色 </font><br/><br/>
<code>&lt;color name=&quot;slateblue&quot;&gt;#6A5ACD&lt;/color&gt;&lt;!--石蓝色 --&gt;</code><font color="#6A5ACD"> 石蓝色 </font><br/><br/>
<code>&lt;color name=&quot;dimgray&quot;&gt;#696969&lt;/color&gt;&lt;!--暗灰色 --&gt;</code><font color="#696969"> 暗灰色 </font><br/><br/>
<code>&lt;color name=&quot;mediumaquamarine&quot;&gt;#66CDAA&lt;/color&gt;&lt;!--中绿色 --&gt;</code><font color="#66CDAA"> 中绿色 </font><br/><br/>
<code>&lt;color name=&quot;cornflowerblue&quot;&gt;#6495ED&lt;/color&gt;&lt;!--菊兰色 --&gt;</code><font color="#6495ED"> 菊兰色 </font><br/><br/>
<code>&lt;color name=&quot;cadetblue&quot;&gt;#5F9EA0&lt;/color&gt;&lt;!--军兰色 --&gt;</code><font color="#5F9EA0"> 军兰色 </font><br/><br/>
<code>&lt;color name=&quot;darkolivegreen&quot;&gt;#556B2F&lt;/color&gt;&lt;!--暗橄榄绿  --&gt;</code><font color="#556B2F"> 暗橄榄绿 </font><br/><br/>
<code>&lt;color name=&quot;indigo&quot;&gt;#4B0082&lt;/color&gt;&lt;!--靛青色 --&gt;</code><font color="#4B0082"> 靛青色 </font><br/><br/>
<code>&lt;color name=&quot;mediumturquoise&quot;&gt;#48D1CC&lt;/color&gt;&lt;!--中绿宝石 --&gt;</code><font color="#48D1CC"> 中绿宝石 </font><br/><br/>
<code>&lt;color name=&quot;darkslateblue&quot;&gt;#483D8B&lt;/color&gt;&lt;!--暗灰蓝色 --&gt;</code><font color="#483D8B"> 暗灰蓝色 </font><br/><br/>
<code>&lt;color name=&quot;steelblue&quot;&gt;#4682B4&lt;/color&gt;&lt;!--钢兰色 --&gt;</code><font color="#4682B4"> 钢兰色 </font><br/><br/>
<code>&lt;color name=&quot;royalblue&quot;&gt;#4169E1&lt;/color&gt;&lt;!--皇家蓝 --&gt;</code><font color="#4169E1"> 皇家蓝 </font><br/><br/>
<code>&lt;color name=&quot;turquoise&quot;&gt;#40E0D0&lt;/color&gt;&lt;!--青绿色 --&gt;</code><font color="#40E0D0"> 青绿色 </font><br/><br/>
<code>&lt;color name=&quot;mediumseagreen&quot;&gt;#3CB371&lt;/color&gt;&lt;!--中海蓝 --&gt;</code><font color="#3CB371"> 中海蓝 </font><br/><br/>
<code>&lt;color name=&quot;limegreen&quot;&gt;#32CD32&lt;/color&gt;&lt;!--橙绿色 --&gt;</code><font color="#32CD32"> 橙绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkslategray&quot;&gt;#2F4F4F&lt;/color&gt;&lt;!--暗瓦灰色 --&gt;</code><font color="#2F4F4F"> 暗瓦灰色 </font><br/><br/>
<code>&lt;color name=&quot;seagreen&quot;&gt;#2E8B57&lt;/color&gt;&lt;!--海绿色 --&gt;</code><font color="#2E8B57"> 海绿色 </font><br/><br/>
<code>&lt;color name=&quot;forestgreen&quot;&gt;#228B22&lt;/color&gt;&lt;!--森林绿 --&gt;</code><font color="#228B22"> 森林绿 </font><br/><br/>
<code>&lt;color name=&quot;lightseagreen&quot;&gt;#20B2AA&lt;/color&gt;&lt;!--亮海蓝色 --&gt;</code><font color="#20B2AA"> 亮海蓝色 </font><br/><br/>
<code>&lt;color name=&quot;dodgerblue&quot;&gt;#1E90FF&lt;/color&gt;&lt;!--闪兰色 --&gt;</code><font color="#1E90FF"> 闪兰色 </font><br/><br/>
<code>&lt;color name=&quot;midnightblue&quot;&gt;#191970&lt;/color&gt;&lt;!--中灰兰色 --&gt;</code><font color="#191970"> 中灰兰色 </font><br/><br/>
<code>&lt;color name=&quot;aqua&quot;&gt;#00FFFF&lt;/color&gt;&lt;!--浅绿色 --&gt;</code><font color="#00FFFF"> 浅绿色 </font><br/><br/>
<code>&lt;color name=&quot;cyan&quot;&gt;#00FFFF&lt;/color&gt;&lt;!--青色 --&gt;</code><font color="#00FFFF"> 青色 </font><br/><br/>
<code>&lt;color name=&quot;springgreen&quot;&gt;#00FF7F&lt;/color&gt;&lt;!--春绿色--&gt;</code><font color="#00FF7F"> 春绿色 </font><br/><br/>
<code>&lt;color name=&quot;lime&quot;&gt;#00FF00&lt;/color&gt;&lt;!--酸橙色 --&gt;</code><font color="#00FF00"> 酸橙色 </font><br/><br/>
<code>&lt;color name=&quot;mediumspringgreen&quot;&gt;#00FA9A&lt;/color&gt;&lt;!--中春绿色 --&gt;</code><font color="#00FA9A"> 中春绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkturquoise&quot;&gt;#00CED1&lt;/color&gt;&lt;!--暗宝石绿 --&gt;</code><font color="#00CED1"> 暗宝石绿 </font><br/><br/>
<code>&lt;color name=&quot;deepskyblue&quot;&gt;#00BFFF&lt;/color&gt;&lt;!--深天蓝色 --&gt;</code><font color="#00BFFF"> 深天蓝色 </font><br/><br/>
<code>&lt;color name=&quot;darkcyan&quot;&gt;#008B8B&lt;/color&gt;&lt;!--暗青色 --&gt;</code><font color="#008B8B"> 暗青色 </font><br/><br/>
<code>&lt;color name=&quot;teal&quot;&gt;#008080&lt;/color&gt;&lt;!--水鸭色 --&gt;</code><font color="#008080"> 水鸭色 </font><br/><br/>
<code>&lt;color name=&quot;green&quot;&gt;#008000&lt;/color&gt;&lt;!--绿色 --&gt;</code><font color="#008000"> 绿色 </font><br/><br/>
<code>&lt;color name=&quot;darkgreen&quot;&gt;#006400&lt;/color&gt;&lt;!--暗绿色 --&gt;</code><font color="#006400"> 暗绿色 </font><br/><br/>
<code>&lt;color name=&quot;blue&quot;&gt;#0000FF&lt;/color&gt;&lt;!--蓝色 --&gt;</code><font color="#0000FF"> 蓝色 </font><br/><br/>
<code>&lt;color name=&quot;mediumblue&quot;&gt;#0000CD&lt;/color&gt;&lt;!--中兰色 --&gt;</code><font color="#0000CD"> 中兰色 </font><br/><br/>
<code>&lt;color name=&quot;darkblue&quot;&gt;#00008B&lt;/color&gt;&lt;!--暗蓝色 --&gt;</code><font color="#00008B"> 暗蓝色 </font><br/><br/>
<code>&lt;color name=&quot;navy&quot;&gt;#000080&lt;/color&gt;&lt;!--海军色 --&gt;</code><font color="#000080"> 海军色 </font><br/><br/>
<code>&lt;color name=&quot;black&quot;&gt;#000000&lt;/color&gt;&lt;!--黑色 --&gt;</code><font color="#000000"> 黑色 </font>  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15626502773559.html">
                
                  <h1>Android-拍照获取缩略图以及完整图片(适配androidN)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">调用系统相机拍照获取缩照片略图</h2>

<blockquote>
<p>调用系统相机拍照时，如果不传路径，图片默认返回缩略图，不需要权限</p>
</blockquote>

<pre><code class="language-java">Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
    startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
}
</code></pre>

<p><code>takePictureIntent.resolveActivity(getPackageManager()) != null</code></p>

<p>在官方文档中有描述：startActivityForResult（）方法受到调用resolveActivity（）的条件的保护，该方法返回可处理该意图的第一个活动组件，执行此检查很重要，因为如果您使用没有应用程序可以处理的意图调用startActivityForResult（），则您的应用程序将崩溃。所以只要结果不为空，就可以安全的使用意图，大概意思是检测手机中有没有相机。</p>

<p>另外一种检测相机的方法是</p>

<pre><code class="language-text">&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera&quot;
                  android:required=&quot;true&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>

<p>required=true表示要安装该应用，手机必须有摄像头该硬件。要不然不允许安装</p>

<p><strong>处理回调</strong></p>

<pre><code class="language-java">@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) {
        Bundle extras = data.getExtras();
        Bitmap imageBitmap = (Bitmap) extras.get(&quot;data&quot;);
        mImageView.setImageBitmap(imageBitmap);
    }
}
</code></pre>

<h2 id="toc_1">调用系统相机拍照获取全尺寸照片</h2>

<blockquote>
<p>如果要保存一个全尺寸的照片，必须提供一个完整的文件名，当照片需要保存到公有目录时，那么需要一个写入的权限(写入权限已经隐含的允许读取[READ_EXTERNAL_STORAGE]，这样子就可以将app拍的照片写入到外部存储,该外部存储的链接是<code>getExternalStoragePublicDirectory()</code></p>
</blockquote>

<pre><code class="language-text">&lt;manifest ...&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>

<blockquote>
<p>当需要将得到的照片保存到私有目录时，使用该链接<code>getExternalFilesDir(),getFilesDir()</code>，这两个目录下的文件在应用删除的时候就自动删掉了，在android4.4以下需要权限，4.4以上应用之间不能被其他程序访问，因此该权限只要在4.4以下加入</p>
</blockquote>

<pre><code class="language-text">&lt;manifest ...&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;
                     android:maxSdkVersion=&quot;18&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>

<ul>
<li>提供一个不会冲突的文件名，例如按时间来起名</li>
</ul>

<pre><code class="language-java">String mCurrentPhotoPath;

private File createImageFile() throws IOException {
    // Create an image file name
    String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date());
    String imageFileName = &quot;JPEG_&quot; + timeStamp + &quot;_&quot;;
    File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
    File image = File.createTempFile(
        imageFileName,  /* prefix */
        &quot;.jpg&quot;,         /* suffix */
        storageDir      /* directory */
    );

    // Save a file: path for use with ACTION_VIEW intents
    mCurrentPhotoPath = image.getAbsolutePath();
    return image;
}
</code></pre>

<ul>
<li>构造拍照intent，适配7.0以及4.0</li>
</ul>

<pre><code class="language-java">static final int REQUEST_TAKE_PHOTO = 1;

    private void camera2() {
        Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        // Ensure that there&#39;s a camera activity to handle the intent
        if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
            // Create the File where the photo should go
            File photoFile = null;

            try {
                photoFile = createImageFile();
            } catch (IOException ex) {
                // Error occurred while creating the File
            }
            // Continue only if the File was successfully created
            if (photoFile != null) {
                Uri photoURI = FileProvider.getUriForFile(this,
                        &quot;lsp.com.ipctest.fileprovider&quot;,
                        photoFile);

                //解决4.0
                List&lt;ResolveInfo&gt; resInfoList = getPackageManager()
                        .queryIntentActivities(takePictureIntent, PackageManager.MATCH_DEFAULT_ONLY);
                for (ResolveInfo resolveInfo : resInfoList) {
                    String packageName = resolveInfo.activityInfo.packageName;
                    grantUriPermission(packageName, photoURI, Intent.FLAG_GRANT_READ_URI_PERMISSION
                            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
                }


                takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);
                startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO);
            }
        }
    }
</code></pre>

<blockquote>
<p><code>FileProvider.getUriForFile()</code>用来返回一个content：// URI。对于最新的针对Android 7.0（API级别24）的应用程序，通过一个包边界传递一个文件：// URI会导致FileUriExposedException<br/>
鸿洋的博客关于android7.0 以及 4.0 拍照封装的处理(点击跳转)</p>
</blockquote>

<ul>
<li>取得结果</li>
</ul>

<pre><code class="language-java">if (requestCode == REQUEST_TAKE_PHOTO &amp;&amp; resultCode == RESULT_OK) {
    Bitmap imageBitmap = BitmapFactory.decodeFile(mCurrentPhotoPath);
    Log.e(TAG, &quot;文件大小&quot; + imageBitmap.getByteCount() / 1024 + &quot;kb&quot;);
    ((ImageView) findViewById(R.id.img)).setImageBitmap(imageBitmap);
}
</code></pre>

<ul>
<li>将照片保存到相册如果你保存图片的路径是getExternalFilesDir() 媒体扫描器访问不到，只有你自己的应用可以访问，因此一下方法可以将图片保存到相册</li>
</ul>

<pre><code class="language-java">private void galleryAddPic() {
    Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
    File f = new File(mCurrentPhotoPath);
    Uri contentUri = Uri.fromFile(f);
    mediaScanIntent.setData(contentUri);
    this.sendBroadcast(mediaScanIntent);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/10/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_1.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_3.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16066640335833.html">Jetpack学习 - WorkManager</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
