<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207872300.html">
                
                  <h1>Android-事件分发机制详解：史上最全面、最易懂</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<ul>
<li>Android事件分发机制是Android开发者必须了解的基础</li>
<li>网上有大量关于Android事件分发机制的文章，但存在一些问题：内容不全、思路不清晰、无源码分析、简单问题复杂化等等</li>
<li>今天，我将全面总结Android的事件分发机制，我能保证这是市面上的最全面、最清晰、最易懂的</li>
</ul>

<blockquote>
<p>本文秉着“结论先行、详细分析在后”的原则，即先让大家感性认识，再通过理性分析从而理解问题；<br/>
所以，请各位读者先记住结论，再往下继续看分析；</p>
</blockquote>

<h2 id="toc_1">目录</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014991957405.png" alt="20171108151014991957405.png"/><figcaption>20171108151014991957405.png</figcaption></figure></p>

<h2 id="toc_2">基础认知</h2>

<h3 id="toc_3">事件分发的对象是谁？</h3>

<p><strong>答：事件</strong></p>

<ul>
<li>当用户触摸屏幕时（View或ViewGroup派生的控件），将产生点击事件（Touch事件）。</li>
</ul>

<blockquote>
<p>Touch事件相关细节（发生触摸的位置、时间、历史记录、手势动作等）被封装成MotionEvent对象</p>
</blockquote>

<ul>
<li>主要发生的Touch事件有如下四种：
<ul>
<li>MotionEvent.ACTION_DOWN：按下View（所有事件的开始）</li>
<li>MotionEvent.ACTION_MOVE：滑动View</li>
<li>MotionEvent.ACTION_CANCEL：非人为原因结束本次事件</li>
<li>MotionEvent.ACTION_UP：抬起View（与DOWN对应）</li>
</ul></li>
<li>事件列：从手指接触屏幕至手指离开屏幕，这个过程产生的一系列事件<br/>
任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014998211742.png" alt="20171108151014998211742.png"/><figcaption>20171108151014998211742.png</figcaption></figure></p>

<p>即当一个MotionEvent 产生后，系统需要把这个事件传递给一个具体的 View 去处理,</p>

<h3 id="toc_4">事件分发的本质</h3>

<p><strong>答：将点击事件（MotionEvent）向某个View进行传递并最终得到处理</strong></p>

<blockquote>
<p>即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。这个事件传递的过程就是分发过程。</p>
</blockquote>

<h3 id="toc_5">事件在哪些对象之间进行传递？</h3>

<p><strong>答：Activity、ViewGroup、View</strong></p>

<blockquote>
<p>一个点击事件产生后，传递顺序是：Activity（Window） -&gt; ViewGroup -&gt; View</p>
</blockquote>

<ul>
<li>Android的UI界面是由Activity、ViewGroup、View及其派生类组合而成的</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015003038387.png" alt="20171108151015003038387.png"/><figcaption>20171108151015003038387.png</figcaption></figure></p>

<ul>
<li>View是所有UI组件的基类</li>
</ul>

<blockquote>
<p>一般Button、ImageView、TextView等控件都是继承父类View</p>
</blockquote>

<ul>
<li>ViewGroup是容纳UI组件的容器，即一组View的集合（包含很多子View和子VewGroup），</li>
</ul>

<blockquote>
<ol>
<li>其本身也是从View派生的，即ViewGroup是View的子类<br/></li>
<li>是Android所有布局的父类或间接父类：项目用到的布局（LinearLayout、RelativeLayout等），都继承自ViewGroup，即属于ViewGroup子类。<br/></li>
<li>与普通View的区别：ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。<br/></li>
</ol>
</blockquote>

<h3 id="toc_6">事件分发过程由哪些方法协作完成？</h3>

<p><strong>答：dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()</strong></p>

<table>
<thead>
<tr>
<th style="text-align: center">方法</th>
<th style="text-align: center">作用</th>
<th style="text-align: center">调用时刻</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">dispatchTouchEvent()</td>
<td style="text-align: center">分发（传递）点击事件</td>
<td style="text-align: center">当点击事件能够传递给当前View时，该方法就会被调用</td>
</tr>
<tr>
<td style="text-align: center">onInterceptTouchEvent()</td>
<td style="text-align: center">判断是否拦截了某个事件（只存在于ViewGroup，普通的View没有这个方法）</td>
<td style="text-align: center">在dispatchTouchEvent()内存调用</td>
</tr>
<tr>
<td style="text-align: center">onTouchEvent()</td>
<td style="text-align: center">处理点击事件</td>
<td style="text-align: center">在dispatchTouchEvent()内部调用</td>
</tr>
</tbody>
</table>

<blockquote>
<p>下文会对这3个方法进行详细介绍</p>
</blockquote>

<h3 id="toc_7">总结</h3>

<ul>
<li>Android事件分发机制的本质是要解决：点击事件由哪个对象发出，经过哪些对象，最终达到哪个对象并最终得到处理。</li>
</ul>

<blockquote>
<p>这里的对象是指Activity、ViewGroup、View</p>
</blockquote>

<ul>
<li>Android中事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View</li>
<li>事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成</li>
</ul>

<p>经过上述3个问题，相信大家已经对Android的事件分发有了感性的认知，接下来，我将详细介绍Android事件分发机制。</p>

<h2 id="toc_8">事件分发机制方法&amp;流程介绍</h2>

<ul>
<li>事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成，如下图：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110815101507201948.png" alt="2017110815101507201948.png"/><figcaption>2017110815101507201948.png</figcaption></figure></p>

<ul>
<li>Android事件分发流程如下：（必须熟记）</li>
</ul>

<blockquote>
<p>Android事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View</p>
</blockquote>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015083272246.png" alt="20171108151015083272246.png"/><figcaption>20171108151015083272246.png</figcaption></figure></p>

<p>其中：</p>

<ul>
<li>super：调用父类方法</li>
<li>true：消费事件，即事件不继续往下传递</li>
<li>false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理</li>
</ul>

<p>接下来，我将详细介绍这3个方法及相关流程。</p>

<h3 id="toc_9">dispatchTouchEvent()</h3>

<table>
<thead>
<tr>
<th style="text-align: center">属性</th>
<th style="text-align: center">介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">使用对象</td>
<td style="text-align: center">Activity、ViewGroup、View</td>
</tr>
<tr>
<td style="text-align: center">作用</td>
<td style="text-align: center">分发点击事件</td>
</tr>
<tr>
<td style="text-align: center">调用时刻</td>
<td style="text-align: center">当点击事件能够传递给当前View时，该方法就会被调用</td>
</tr>
<tr>
<td style="text-align: center">返回结果</td>
<td style="text-align: center">是否消费当前事件，详细情况如下：</td>
</tr>
</tbody>
</table>

<p><strong>1. 默认情况：根据当前对象的不同而返回方法不同</strong></p>

<table>
<thead>
<tr>
<th style="text-align: center">对象</th>
<th style="text-align: center">返回方法</th>
<th style="text-align: center">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Activity</td>
<td style="text-align: center">super.dispatchTouchEvent()</td>
<td style="text-align: center">即调用父类ViewGroup的dispatchTouchEvent()</td>
</tr>
<tr>
<td style="text-align: center">ViewGroup</td>
<td style="text-align: center">onIntercepTouchEvent()</td>
<td style="text-align: center">即调用自身的onIntercepTouchEvent()</td>
</tr>
<tr>
<td style="text-align: center">View</td>
<td style="text-align: center">onTouchEvent（）</td>
<td style="text-align: center">即调用自身的onTouchEvent（）</td>
</tr>
</tbody>
</table>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015093015508.png" alt="20171108151015093015508.png"/><figcaption>20171108151015093015508.png</figcaption></figure></p>

<p><strong>2. 返回true</strong></p>

<ul>
<li>消费事件</li>
<li>事件不会往下传递</li>
<li>后续事件（Move、Up）会继续分发到该View</li>
<li>流程图如下：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015097713612.png" alt="20171108151015097713612.png"/><figcaption>20171108151015097713612.png</figcaption></figure></p>

<p><strong>3. 返回false</strong></p>

<ul>
<li>不消费事件</li>
<li>事件不会往下传递</li>
<li>将事件回传给父控件的onTouchEvent()处理</li>
</ul>

<blockquote>
<p>Activity例外：返回false=消费事件</p>
</blockquote>

<ul>
<li>后续事件（Move、Up）会继续分发到该View(与onTouchEvent()区别）</li>
<li>流程图如下</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015100669361.png" alt="20171108151015100669361.png"/><figcaption>20171108151015100669361.png</figcaption></figure></p>

<h3 id="toc_10">onTouchEvent()</h3>

<table>
<thead>
<tr>
<th style="text-align: center">属性</th>
<th style="text-align: center">介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">使用对象</td>
<td style="text-align: center">Activity、ViewGroup、View</td>
</tr>
<tr>
<td style="text-align: center">作用</td>
<td style="text-align: center">处理点击事件</td>
</tr>
<tr>
<td style="text-align: center">调用时刻</td>
<td style="text-align: center">在dispatchTouchEvent()内部调用</td>
</tr>
<tr>
<td style="text-align: center">返回结果</td>
<td style="text-align: center">是否消费（处理）当前事件，详细情况如下：</td>
</tr>
</tbody>
</table>

<blockquote>
<p>与dispatchTouchEvent()类似</p>
</blockquote>

<p><strong>1. 返回true</strong></p>

<ul>
<li>自己处理（消费）该事情</li>
<li>事件停止传递</li>
<li>该事件序列的后续事件（Move、Up）让其处理；</li>
<li>流程图如下：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015113258049.png" alt="20171108151015113258049.png"/><figcaption>20171108151015113258049.png</figcaption></figure></p>

<p><strong>2. 返回false（同默认实现：调用父类onTouchEvent()）</strong></p>

<ul>
<li>不处理（消费）该事件</li>
<li>事件往上传递给父控件的onTouchEvent()处理</li>
<li>当前View不再接受此事件列的其他事件（Move、Up）；</li>
<li>流程图如下：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110815101512068918.png" alt="2017110815101512068918.png"/><figcaption>2017110815101512068918.png</figcaption></figure></p>

<h3 id="toc_11">onInterceptTouchEvent()</h3>

<table>
<thead>
<tr>
<th style="text-align: center">属性</th>
<th style="text-align: center">介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">使用对象</td>
<td style="text-align: center">ViewGroup（注：Activity、View都没该方法）</td>
</tr>
<tr>
<td style="text-align: center">作用</td>
<td style="text-align: center">拦截事件，即自己处理该事件</td>
</tr>
<tr>
<td style="text-align: center">调用时刻</td>
<td style="text-align: center">在ViewGroup的dispatchTouchEvent()内部调用</td>
</tr>
<tr>
<td style="text-align: center">返回结果</td>
<td style="text-align: center">是否拦截当前事件，详细情况如下：</td>
</tr>
</tbody>
</table>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015127727353.png" alt="20171108151015127727353.png"/><figcaption>20171108151015127727353.png</figcaption></figure></p>

<ul>
<li>流程图如下：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110815101512935807.png" alt="2017110815101512935807.png"/><figcaption>2017110815101512935807.png</figcaption></figure></p>

<h3 id="toc_12">三者关系</h3>

<p>下面将用一段伪代码来阐述上述三个方法的关系和点击事件传递规则</p>

<pre class="line-numbers"><code class="language-java">// 点击事件产生后，会直接调用dispatchTouchEvent（）方法
public boolean dispatchTouchEvent(MotionEvent ev) {

    //代表是否消耗事件
    boolean consume = false;


    if (onInterceptTouchEvent(ev)) {
    //如果onInterceptTouchEvent()返回true则代表当前View拦截了点击事件
    //则该点击事件则会交给当前View进行处理
    //即调用onTouchEvent (）方法去处理点击事件
      consume = onTouchEvent (ev) ;

    } else {
      //如果onInterceptTouchEvent()返回false则代表当前View不拦截点击事件
      //则该点击事件则会继续传递给它的子元素
      //子元素的dispatchTouchEvent（）就会被调用，重复上述过程
      //直到点击事件被最终处理为止
      consume = child.dispatchTouchEvent (ev) ;
    }

    return consume;
   }
</code></pre>

<h3 id="toc_13">总结</h3>

<p>对于事件分发的3个方法，你应该清楚了解<br/>
接下来，我将开始介绍Android事件分发的常见流程</p>

<h2 id="toc_14">事件分发场景介绍</h2>

<p>下面我将利用例子来说明常见的点击事件传递情况</p>

<h3 id="toc_15">背景描述</h3>

<p>我们将要讨论的布局层次如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015134286239.png" alt="20171108151015134286239.png"/><figcaption>20171108151015134286239.png</figcaption></figure></p>

<ul>
<li>最外层：Activiy A，包含两个子View：ViewGroup B、View C</li>
<li>中间层：ViewGroup B，包含一个子View：View C</li>
<li>最内层：View C</li>
</ul>

<p>假设用户首先触摸到屏幕上View C上的某个点（如图中黄色区域），那么Action_DOWN事件就在该点产生，然后用户移动手指并最后离开屏幕。</p>

<h3 id="toc_16">一般的事件传递情况</h3>

<p>一般的事件传递场景有：</p>

<ul>
<li>默认情况</li>
<li>处理事件</li>
<li>拦截DOWN事件</li>
<li>拦截后续事件（MOVE、UP）</li>
</ul>

<h4 id="toc_17">默认情况</h4>

<ul>
<li>即不对控件里的方法(dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent())进行重写或更改返回值</li>
<li>那么调用的是这3个方法的默认实现：调用父类的方法</li>
<li>事件传递情况：（如图下所示）
<ul>
<li>从Activity A----&gt;ViewGroup B---&gt;View C，从上往下调用dispatchTouchEvent()</li>
<li>再由View C---&gt;ViewGroup B ---&gt;Activity A，从下往上调用onTouchEvent()</li>
</ul></li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015141723712.png" alt="20171108151015141723712.png"/><figcaption>20171108151015141723712.png</figcaption></figure></p>

<p>注：虽然ViewGroup B的onInterceptTouchEvent方法对DOWN事件返回了false，后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent()</p>

<blockquote>
<p>这一点与onTouchEvent的行为是不一样的。</p>
</blockquote>

<h4 id="toc_18">处理事件</h4>

<p>假设View C希望处理这个点击事件，即C被设置成可点击的（Clickable）或者覆写了C的onTouchEvent方法返回true。</p>

<blockquote>
<p>最常见的：设置Button按钮来响应点击事件</p>
</blockquote>

<p>事件传递情况：（如下图）</p>

<ul>
<li>DOWN事件被传递给C的onTouchEvent方法，该方法返回true，表示处理这个事件</li>
<li>因为C正在处理这个事件，那么DOWN事件将不再往上传递给B和A的onTouchEvent()；</li>
<li>该事件列的其他事件（Move、Up）也将传递给C的onTouchEvent()</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015145961494.png" alt="20171108151015145961494.png"/><figcaption>20171108151015145961494.png</figcaption></figure></p>

<h4 id="toc_19">拦截DOWN事件</h4>

<p>假设ViewGroup B希望处理这个点击事件，即B覆写了onInterceptTouchEvent()返回true、onTouchEvent()返回true。<br/>
事件传递情况：（如下图）</p>

<ul>
<li>DOWN事件被传递给B的onInterceptTouchEvent()方法，该方法返回true，表示拦截这个事件，即自己处理这个事件（不再往下传递）</li>
<li>调用onTouchEvent()处理事件（DOWN事件将不再往上传递给A的onTouchEvent()）</li>
<li>该事件列的其他事件（Move、Up）将直接传递给B的onTouchEvent()</li>
</ul>

<blockquote>
<p>该事件列的其他事件（Move、Up）将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。</p>
</blockquote>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015149359935.png" alt="20171108151015149359935.png"/><figcaption>20171108151015149359935.png</figcaption></figure></p>

<h4 id="toc_20">拦截DOWN的后续事件</h4>

<p>假设ViewGroup B没有拦截DOWN事件（还是View C来处理DOWN事件），但它拦截了接下来的MOVE事件。</p>

<ul>
<li>DOWN事件传递到C的onTouchEvent方法，返回了true。</li>
<li>在后续到来的MOVE事件，B的onInterceptTouchEvent方法返回true拦截该MOVE事件，但该事件并没有传递给B；这个MOVE事件将会被系统变成一个CANCEL事件传递给C的onTouchEvent方法</li>
<li>后续又来了一个MOVE事件，该MOVE事件才会直接传递给B的onTouchEvent()</li>
</ul>

<blockquote>
<ol>
<li>后续事件将直接传递给B的onTouchEvent()处理<br/></li>
<li>后续事件将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。</li>
</ol>
</blockquote>

<ul>
<li>C再也不会收到该事件列产生的后续事件。</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015153662988.png" alt="20171108151015153662988.png"/><figcaption>20171108151015153662988.png</figcaption></figure></p>

<p>特别注意：</p>

<ul>
<li>如果ViewGroup A 拦截了一个半路的事件（如MOVE），这个事件将会被系统变成一个CANCEL事件并传递给之前处理该事件的子View；</li>
<li>该事件不会再传递给ViewGroup A的onTouchEvent()</li>
<li>只有再到来的事件才会传递到ViewGroup A的onTouchEvent()</li>
</ul>

<h3 id="toc_21">总结</h3>

<ul>
<li>对于Android的事件分发机制，你应该已经非常清楚了</li>
<li>如果你只是希望了解Android事件分发机制而不想深入了解，那么你可以离开这篇文章了</li>
<li>对于程序猿来说，知其然还需要知其所以然，接下来，我将通过源码分析来深入了解Android事件分发机制</li>
</ul>

<h2 id="toc_22">Android事件分发机制源码分析</h2>

<ul>
<li>Android中事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View，再次贴出下图：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015158646492.png" alt="20171108151015158646492.png"/><figcaption>20171108151015158646492.png</figcaption></figure></p>

<p>其中：</p>

<ul>
<li>super：调用父类方法</li>
<li>true：消费事件，即事件不继续往下传递</li>
<li>false：不消费事件，事件继续往下传递 / 交由给父控件onTouchEvent（）处理</li>
</ul>

<p>所以，要想充分理解Android分发机制，本质上是要理解：</p>

<ul>
<li>Activity对点击事件的分发机制</li>
<li>ViewGroup对点击事件的分发机制</li>
<li>View对点击事件的分发机制</li>
</ul>

<p>接下来，我将通过源码分析详细介绍Activity、View和ViewGroup的事件分发机制</p>

<h3 id="toc_23">Activity的事件分发机制</h3>

<h4 id="toc_24">源码分析</h4>

<ul>
<li>当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发</li>
</ul>

<blockquote>
<p>具体是由Activity的Window来完成</p>
</blockquote>

<ul>
<li>我们来看下Activity的dispatchTouchEvent()的源码</li>
</ul>

<pre class="line-numbers"><code class="language-java">public boolean dispatchTouchEvent(MotionEvent ev) {
        //关注点1
        //一般事件列开始都是DOWN，所以这里基本是true
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            //关注点2
            onUserInteraction();
        }
        //关注点3
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
</code></pre>

<p><strong>关注点1</strong><br/>
一般事件列开始都是DOWN（按下按钮），所以这里返回true，执行onUserInteraction()</p>

<p><strong>关注点2</strong><br/>
先来看下onUserInteraction()源码</p>

<pre class="line-numbers"><code class="language-java">  /**
     * Called whenever a key, touch, or trackball event is dispatched to the
     * activity.  Implement this method if you wish to know that the user has
     * interacted with the device in some way while your activity is running.
     * This callback and {@link #onUserLeaveHint} are intended to help
     * activities manage status bar notifications intelligently; specifically,
     * for helping activities determine the proper time to cancel a notfication.
     *
     * &lt;p&gt;All calls to your activity&#39;s {@link #onUserLeaveHint} callback will
     * be accompanied by calls to {@link #onUserInteraction}.  This
     * ensures that your activity will be told of relevant user activity such
     * as pulling down the notification pane and touching an item there.
     *
     * &lt;p&gt;Note that this callback will be invoked for the touch down action
     * that begins a touch gesture, but may not be invoked for the touch-moved
     * and touch-up actions that follow.
     *
     * @see #onUserLeaveHint()
     */
public void onUserInteraction() { 
}
</code></pre>

<p>从源码可以看出：</p>

<ul>
<li>该方法为空方法</li>
<li>从注释得知：当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法</li>
<li>所以onUserInteraction()主要用于屏保</li>
</ul>

<p><strong>关注点3</strong></p>

<ul>
<li>Window类是抽象类，且PhoneWindow是Window类的唯一实现类</li>
<li>superDispatchTouchEvent(ev)是抽象方法，返回的是一个Window对象</li>
<li>通过PhoneWindow类中看一下superDispatchTouchEvent()的作用</li>
</ul>

<pre class="line-numbers"><code class="language-java">@Override
public boolean superDispatchTouchEvent(MotionEvent event) {
  return mDecor.superDispatchTouchEvent(event);
//mDecor是DecorView的实例
//DecorView是视图的顶层view，继承自FrameLayout，是所有界面的父类
}
</code></pre>

<ul>
<li>接下来我们看mDecor.superDispatchTouchEvent(event)：</li>
</ul>

<pre class="line-numbers"><code class="language-java">public boolean superDispatchTouchEvent(MotionEvent event) {
    return super.dispatchTouchEvent(event);
//DecorView继承自FrameLayout
//那么它的父类就是ViewGroup
而super.dispatchTouchEvent(event)方法，其实就应该是ViewGroup的dispatchTouchEvent()

}
</code></pre>

<p>所以：</p>

<ul>
<li>执行getWindow().superDispatchTouchEvent(ev)实际上是执行了ViewGroup.dispatchTouchEvent(event)</li>
<li>再回到最初的代码：</li>
</ul>

<pre class="line-numbers"><code class="language-java">public boolean dispatchTouchEvent(MotionEvent ev) {

      if (ev.getAction() == MotionEvent.ACTION_DOWN) {
          //关注点2
          onUserInteraction();
      }
      //关注点3
      if (getWindow().superDispatchTouchEvent(ev)) {
          return true;
      }
      return onTouchEvent(ev);
  }
</code></pre>

<p>由于一般事件列开始都是DOWN，所以这里返回true，基本上都会进入<code>getWindow().superDispatchTouchEvent(ev)</code>的判断</p>

<ul>
<li>所以，执行<code>Activity.dispatchTouchEvent(ev)</code>实际上是执行了<code>ViewGroup.dispatchTouchEvent(event)</code></li>
<li>这样事件就从 Activity 传递到了 ViewGroup</li>
</ul>

<h4 id="toc_25">汇总</h4>

<p>当一个点击事件发生时，调用顺序如下</p>

<ol>
<li>事件最先传到Activity的dispatchTouchEvent()进行事件分发</li>
<li>调用Window类实现类PhoneWindow的superDispatchTouchEvent()</li>
<li>调用DecorView的superDispatchTouchEvent()</li>
<li>最终调用DecorView父类的dispatchTouchEvent()，即ViewGroup的dispatchTouchEvent()</li>
</ol>

<h4 id="toc_26">结论</h4>

<ul>
<li>当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发，最终是调用了ViewGroup的dispatchTouchEvent()方法</li>
</ul>

<blockquote>
<p>如果ViewGroup的dispatchTouchEvent()返回true就不执行Activity的onTouchEvent()方法；如果返回false，就执行。<br/>
这样事件就从 Activity 传递到了 ViewGroup</p>
</blockquote>

<h4 id="toc_27">疑问</h4>

<p>那么，ViewGroup的dispatchTouchEvent()什么时候返回true，什么时候返回false？<br/>
答：请继续往下看ViewGroup事件的分发机制</p>

<h3 id="toc_28">ViewGroup事件的分发机制</h3>

<p>在讲解ViewGroup事件的分发机制之前我们先来看个Demo</p>

<h4 id="toc_29">Demo讲解</h4>

<p>布局如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015184560280.png" alt="20171108151015184560280.png"/><figcaption>20171108151015184560280.png</figcaption></figure></p>

<p>结果测试：<br/><br/>
只点击Button  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015186085331.png" alt="20171108151015186085331.png"/><figcaption>20171108151015186085331.png</figcaption></figure></p>

<p>再点击空白处</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015186956039.png" alt="20171108151015186956039.png"/><figcaption>20171108151015186956039.png</figcaption></figure></p>

<p>从上面的测试结果发现：</p>

<ul>
<li>当点击Button时，执行Button的onClick()，但ViewGroupLayout注册的onTouch（）不会执行</li>
<li>只有点击空白区域时才会执行ViewGroupLayout的onTouch（）;</li>
<li>结论：Button的onClick()将事件消费掉了，因此事件不会再继续向下传递。</li>
</ul>

<p>接下来，我们开始进行ViewGroup事件分发的源码分析</p>

<h4 id="toc_30">源码分析</h4>

<p>ViewGroup的dispatchTouchEvent()源码分析</p>

<blockquote>
<ol>
<li>详情请看注释<br/></li>
<li>Android 5.0后ViewGroup的dispatchTouchEvent()的源码发生了变化（更加复杂），但原理相同；<br/></li>
<li>本文为了让读者更好理解dispatchTouchEvent()源码分析，所以采用Android 5.0前的版本<br/></li>
</ol>
</blockquote>

<pre class="line-numbers"><code class="language-java">public boolean dispatchTouchEvent(MotionEvent ev) {  
    final int action = ev.getAction();  
    final float xf = ev.getX();  
    final float yf = ev.getY();  
    final float scrolledXFloat = xf + mScrollX;  
    final float scrolledYFloat = yf + mScrollY;  
    final Rect frame = mTempRect;  
    boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;  
    if (action == MotionEvent.ACTION_DOWN) {  
        if (mMotionTarget != null) {  
            mMotionTarget = null;  
        }  

//看这个If判断语句
//第一个判断值disallowIntercept：是否禁用事件拦截的功能(默认是false)
//可以通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改。
//第二个判断值： !onInterceptTouchEvent(ev)：对onInterceptTouchEvent()返回值取反

//如果我们在onInterceptTouchEvent()中返回false，就会让第二个值为true，从而进入到条件判断的内部
//如果我们在onInterceptTouchEvent()中返回true，就会让第二个值为false，从而跳出了这个条件判断。
//关于onInterceptTouchEvent()请看下面分析（关注点1）
        if (disallowIntercept || !onInterceptTouchEvent(ev)) {  
            ev.setAction(MotionEvent.ACTION_DOWN);  
            final int scrolledXInt = (int) scrolledXFloat;  
            final int scrolledYInt = (int) scrolledYFloat;  
            final View[] children = mChildren;  
            final int count = mChildrenCount;  

          //通过for循环，遍历了当前ViewGroup下的所有子View
            for (int i = count - 1; i &gt;= 0; i--) {  
                final View child = children[i];  
                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE  
                        || child.getAnimation() != null) {  
                    child.getHitRect(frame);  

                    //判断当前遍历的View是不是正在点击的View
                    //如果是，则进入条件判断内部
                    if (frame.contains(scrolledXInt, scrolledYInt)) {  
                        final float xc = scrolledXFloat - child.mLeft;  
                        final float yc = scrolledYFloat - child.mTop;  
                        ev.setLocation(xc, yc);  
                        child.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  

                    //关注点2

                    //条件判断的内部调用了该View的dispatchTouchEvent()方法（具体请看下面的View事件分发机制）
                    //实现了点击事件从ViewGroup到View的传递
                        if (child.dispatchTouchEvent(ev))  { 

        //调用子View的dispatchTouchEvent后是有返回值的
        //如果这个控件是可点击的话，那么点击该控件时，dispatchTouchEvent的返回值必定是true
        //因此会导致条件判断成立
                            mMotionTarget = child;  
        //于是给ViewGroup的dispatchTouchEvent方法直接返回了true，这样就导致后面的代码无法执行，直接跳出
        //即把ViewGroup的touch事件拦截掉
                            return true;  
                        }  
                    }  
                }  
            }  
        }  
    }  
    boolean isUpOrCancel = (action == MotionEvent.ACTION_UP) ||  
            (action == MotionEvent.ACTION_CANCEL);  
    if (isUpOrCancel) {  
        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;  
    }  
    final View target = mMotionTarget;  

//关注点3
//没有任何View接收事件的情况，即点击空白处情况
    if (target == null) {  
        ev.setLocation(xf, yf);  
        if ((mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
            ev.setAction(MotionEvent.ACTION_CANCEL);  
            mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
        }  
//调用ViewGroup的父类View的dispatchTouchEvent()
//因此会执行ViewGroup的onTouch()、onTouchEvent()
//实现了点击事件从ViewGroup到View的传递
        return super.dispatchTouchEvent(ev);  
    }  


//之后的代码在一般情况下是走不到的了，我们也就不再继续往下分析。
    if (!disallowIntercept &amp;&amp; onInterceptTouchEvent(ev)) {  
        final float xc = scrolledXFloat - (float) target.mLeft;  
        final float yc = scrolledYFloat - (float) target.mTop;  
        mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
        ev.setAction(MotionEvent.ACTION_CANCEL);  
        ev.setLocation(xc, yc);  
        if (!target.dispatchTouchEvent(ev)) {  
        }  
        mMotionTarget = null;  
        return true;  
    }  
    if (isUpOrCancel) {  
        mMotionTarget = null;  
    }  
    final float xc = scrolledXFloat - (float) target.mLeft;  
    final float yc = scrolledYFloat - (float) target.mTop;  
    ev.setLocation(xc, yc);  
    if ((target.mPrivateFlags &amp; CANCEL_NEXT_UP_EVENT) != 0) {  
        ev.setAction(MotionEvent.ACTION_CANCEL);  
        target.mPrivateFlags &amp;= ~CANCEL_NEXT_UP_EVENT;  
        mMotionTarget = null;  
    }  
    return target.dispatchTouchEvent(ev);  
}
</code></pre>

<h5 id="toc_31">关注点1（onInterceptTouchEvent()源码分析）</h5>

<p>ViewGroup每次在做分发时，需要调用onInterceptTouchEvent()是否拦截事件；源码分析如下：</p>

<pre class="line-numbers"><code class="language-java">public boolean onInterceptTouchEvent(MotionEvent ev) {  
    return false;  
}
</code></pre>

<ul>
<li>返回false =不拦截（默认），允许事件继续往下传递(向子View传递)；</li>
</ul>

<blockquote>
<p>因为子View也需要该事件，所以onInterceptTouchEvent拦截器return super.onInterceptTouchEvent()和return false是一样的 = 不会拦截</p>
</blockquote>

<ul>
<li>返回true = 拦截（手动设置），即自己处理该事件（执行自己的onTouchEvent()），事件不会继续往下传递</li>
</ul>

<h5 id="toc_32">关注点2</h5>

<p>当点击了某个控件：</p>

<ol>
<li>调用该控件所在布局（ViewGroup）的dispatchTouchEvent()</li>
<li>在布局的dispatchTouchEvent()中找到被点击的相应控件</li>
<li>再去调用该控件的dispatchTouchEvent()</li>
</ol>

<blockquote>
<ol>
<li>实现了点击事件从ViewGroup到View的传递<br/></li>
<li>此处是关于View.dispatchTouchEvent()的分析，详情请看下面的View事件分发机制。<br/></li>
</ol>
</blockquote>

<h2 id="toc_33">结论</h2>

<ul>
<li>Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View</li>
<li>在ViewGroup中通过onInterceptTouchEvent()对事件传递进行拦截</li>
</ul>

<blockquote>
<ol>
<li>onInterceptTouchEvent方法返回true代表拦截事件，即不允许事件继续向子View传递；<br/></li>
<li>返回false代表不拦截事件，即允许事件继续向子View传递；（默认返回false）<br/></li>
<li>子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。<br/></li>
</ol>
</blockquote>

<h3 id="toc_34">View事件的分发机制</h3>

<p>View中dispatchTouchEvent()的源码分析</p>

<pre class="line-numbers"><code class="language-java">public boolean dispatchTouchEvent(MotionEvent event) {  
    if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  
            mOnTouchListener.onTouch(this, event)) {  
        return true;  
    }  
    return onTouchEvent(event);  
}
</code></pre>

<p>从上面可以看出：</p>

<ul>
<li>只有以下三个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent(event)方法</li>
</ul>

<pre class="line-numbers"><code class="language-java">第一个条件：mOnTouchListener != null；
第二个条件：(mViewFlags &amp; ENABLED_MASK) == ENABLED；
第三个条件：mOnTouchListener.onTouch(this, event)；
</code></pre>

<ul>
<li>下面，我们来看看下这三个判断条件：</li>
</ul>

<p><strong>第一个条件：mOnTouchListener!= null</strong></p>

<pre class="line-numbers"><code class="language-text">//mOnTouchListener是在View类下setOnTouchListener方法里赋值的
public void setOnTouchListener(OnTouchListener l) { 

//即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空）
    mOnTouchListener = l;  
}
</code></pre>

<p><strong>第二个条件：(mViewFlags &amp; ENABLED_MASK) == ENABLED</strong></p>

<ul>
<li>该条件是判断当前点击的控件是否enable</li>
<li>由于很多View默认是enable的，因此该条件恒定为true</li>
</ul>

<p><strong>第三个条件：mOnTouchListener.onTouch(this, event)</strong></p>

<ul>
<li>回调控件注册Touch事件时的onTouch方法</li>
</ul>

<pre class="line-numbers"><code class="language-text">//手动调用设置
button.setOnTouchListener(new OnTouchListener() {  

  @Override  
  public boolean onTouch(View v, MotionEvent event) {  

      return false;  
  }  
});
</code></pre>

<ul>
<li>如果在onTouch方法返回true，就会让上述三个条件全部成立，从而整个方法直接返回true。</li>
<li>如果在onTouch方法里返回false，就会去执行onTouchEvent(event)方法。</li>
</ul>

<p>接下来，我们继续看：onTouchEvent(event)的源码分析</p>

<blockquote>
<ol>
<li>详情请看注释<br/></li>
<li>Android 5.0后View的onTouchEvent()的源码发生了变化（更加复杂），但原理相同；<br/></li>
<li>本文为了让读者更好理解onTouchEvent()源码分析，所以采用Android 5.0前的版本<br/></li>
</ol>
</blockquote>

<pre class="line-numbers"><code class="language-java">public boolean onTouchEvent(MotionEvent event) {  
    final int viewFlags = mViewFlags;  
    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {  
        // A disabled view that is clickable still consumes the touch  
        // events, it just doesn&#39;t respond to them.  
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
                (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));  
    }  
    if (mTouchDelegate != null) {  
        if (mTouchDelegate.onTouchEvent(event)) {  
            return true;  
        }  
    }  
     //如果该控件是可以点击的就会进入到下两行的switch判断中去；

    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||  
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) {  
    //如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。

        switch (event.getAction()) {  
            case MotionEvent.ACTION_UP:  
                boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0;  
               // 在经过种种判断之后，会执行到关注点1的performClick()方法。
               //请往下看关注点1
                if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) {  
                    // take focus if we don&#39;t have it already and we should in  
                    // touch mode.  
                    boolean focusTaken = false;  
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {  
                        focusTaken = requestFocus();  
                    }  
                    if (!mHasPerformedLongPress) {  
                        // This is a tap, so remove the longpress check  
                        removeLongPressCallback();  
                        // Only perform take click actions if we were in the pressed state  
                        if (!focusTaken) {  
                            // Use a Runnable and post this rather than calling  
                            // performClick directly. This lets other visual state  
                            // of the view update before click actions start.  
                            if (mPerformClick == null) {  
                                mPerformClick = new PerformClick();  
                            }  
                            if (!post(mPerformClick)) {  
            //关注点1
            //请往下看performClick()的源码分析
                                performClick();  
                            }  
                        }  
                    }  
                    if (mUnsetPressedState == null) {  
                        mUnsetPressedState = new UnsetPressedState();  
                    }  
                    if (prepressed) {  
                        mPrivateFlags |= PRESSED;  
                        refreshDrawableState();  
                        postDelayed(mUnsetPressedState,  
                                ViewConfiguration.getPressedStateDuration());  
                    } else if (!post(mUnsetPressedState)) {  
                        // If the post failed, unpress right now  
                        mUnsetPressedState.run();  
                    }  
                    removeTapCallback();  
                }  
                break;  
            case MotionEvent.ACTION_DOWN:  
                if (mPendingCheckForTap == null) {  
                    mPendingCheckForTap = new CheckForTap();  
                }  
                mPrivateFlags |= PREPRESSED;  
                mHasPerformedLongPress = false;  
                postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  
                break;  
            case MotionEvent.ACTION_CANCEL:  
                mPrivateFlags &amp;= ~PRESSED;  
                refreshDrawableState();  
                removeTapCallback();  
                break;  
            case MotionEvent.ACTION_MOVE:  
                final int x = (int) event.getX();  
                final int y = (int) event.getY();  
                // Be lenient about moving outside of buttons  
                int slop = mTouchSlop;  
                if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) ||  
                        (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) {  
                    // Outside button  
                    removeTapCallback();  
                    if ((mPrivateFlags &amp; PRESSED) != 0) {  
                        // Remove any future long press/tap checks  
                        removeLongPressCallback();  
                        // Need to switch from pressed to not pressed  
                        mPrivateFlags &amp;= ~PRESSED;  
                        refreshDrawableState();  
                    }  
                }  
                break;  
        }  
//如果该控件是可以点击的，就一定会返回true
        return true;  
    }  
//如果该控件是可以点击的，就一定会返回false
    return false;  
}
</code></pre>

<p><strong>关注点1：</strong></p>

<p>performClick()的源码分析</p>

<pre class="line-numbers"><code class="language-java">public boolean performClick() {  
    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);  

    if (mOnClickListener != null) {  
        playSoundEffect(SoundEffectConstants.CLICK);  
        mOnClickListener.onClick(this);  
        return true;  
    }  
    return false;  
}
</code></pre>

<ul>
<li>只要mOnClickListener不为null，就会去调用onClick方法；</li>
<li>那么，mOnClickListener又是在哪里赋值的呢？请继续看：</li>
</ul>

<pre class="line-numbers"><code class="language-java">public void setOnClickListener(OnClickListener l) {  
    if (!isClickable()) {  
        setClickable(true);  
    }  
    mOnClickListener = l;  
}
</code></pre>

<ul>
<li>当我们通过调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值（不为空），即会回调onClick（）。</li>
</ul>

<h2 id="toc_35">结论</h2>

<ol>
<li>onTouch（）的执行高于onClick（）</li>
<li><p>每当控件被点击时：</p>
<ul>
<li>如果在回调onTouch()里返回false，就会让dispatchTouchEvent方法返回false，那么就会执行onTouchEvent()；如果回调了setOnClickListener()来给控件注册点击事件的话，最后会在performClick()方法里回调onClick()。</li>
</ul>
<blockquote>
<p>onTouch()返回false（该事件没被onTouch()消费掉） = dispatchTouchEvent()返回false（继续向下传递） = 执行onTouchEvent() = 执行OnClick()</p>
</blockquote>
<ul>
<li>如果在回调onTouch()里返回true，就会让dispatchTouchEvent方法返回true，那么将不会执行onTouchEvent()，即onClick()也不会执行；</li>
</ul>
<blockquote>
<p>onTouch()返回true（该事件被onTouch()消费掉） = dispatchTouchEvent()返回true（不会再继续向下传递） = 不会执行onTouchEvent() = 不会执行OnClick()</p>
</blockquote></li>
</ol>

<p><strong>下面我将用Demo验证上述的结论</strong></p>

<h2 id="toc_36">Demo论证</h2>

<p><strong>1. Demo1：在回调onTouch()里返回true</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015406386889.png" alt="20171108151015406386889.png"/><figcaption>20171108151015406386889.png</figcaption></figure></p>

<pre class="line-numbers"><code class="language-java">//设置OnTouchListener()
   button.setOnTouchListener(new View.OnTouchListener() {

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                System.out.println(&quot;执行了onTouch(), 动作是:&quot; + event.getAction());

                return true;
            }
        });

//设置OnClickListener
    button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                System.out.println(&quot;执行了onClick()&quot;);
            }
        });
</code></pre>

<p>点击Button，测试结果如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015413223556.png" alt="20171108151015413223556.png"/><figcaption>20171108151015413223556.png</figcaption></figure></p>

<p><strong>2. Demo2：在回调onTouch()里返回false</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015417140463.png" alt="20171108151015417140463.png"/><figcaption>20171108151015417140463.png</figcaption></figure></p>

<pre class="line-numbers"><code class="language-java">//设置OnTouchListener()
   button.setOnTouchListener(new View.OnTouchListener() {

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                System.out.println(&quot;执行了onTouch(), 动作是:&quot; + event.getAction());

                return false;
            }
        });

//设置OnClickListener
    button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                System.out.println(&quot;执行了onClick()&quot;);
            }
        });
</code></pre>

<p>点击Button，测试结果如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015420062579.png" alt="20171108151015420062579.png"/><figcaption>20171108151015420062579.png</figcaption></figure></p>

<p>总结：onTouch()返回true就认为该事件被onTouch()消费掉，因而不会再继续向下传递，即不会执行OnClick()。</p>

<p>如果你看到此处，那么恭喜你，你已经能非常熟悉掌握Android的事件分发机制了（Activity、ViewGroup、View的事件分发机制）</p>

<h2 id="toc_37">思考点</h2>

<h3 id="toc_38">onTouch()和onTouchEvent()的区别</h3>

<ul>
<li>这两个方法都是在View的dispatchTouchEvent中调用，但onTouch优先于onTouchEvent执行。</li>
<li><p>如果在onTouch方法中返回true将事件消费掉，onTouchEvent()将不会再执行。</p></li>
<li><p>特别注意：请看下面代码</p></li>
</ul>

<pre class="line-numbers"><code class="language-text">//&amp;&amp;为短路与，即如果前面条件为false，将不再往下执行
//所以，onTouch能够得到执行需要两个前提条件：
//1. mOnTouchListener的值不能为空
//2. 当前点击的控件必须是enable的。
mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  
          mOnTouchListener.onTouch(this, event)
</code></pre>

<ul>
<li>因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。</li>
</ul>

<h3 id="toc_39">Touch事件的后续事件（MOVE、UP）层级传递</h3>

<ul>
<li>如果给控件注册了Touch事件，每次点击都会触发一系列action事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP等）</li>
<li>当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP）</li>
</ul>

<blockquote>
<p>即如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE和ACTION_UP事件都不会执行</p>
</blockquote>

<p>从上面对事件分发机制分析知：</p>

<ul>
<li>dispatchTouchEvent()和 onTouchEvent()消费事件、终结事件传递（返回true）</li>
<li>而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用</li>
</ul>

<blockquote>
<p>请记住：接收了ACTION_DOWN事件的函数不一定能收到后续事件（ACTION_MOVE、ACTION_UP）</p>
</blockquote>

<p><strong>这里给出ACTION_MOVE和ACTION_UP事件的传递结论：</strong></p>

<ul>
<li>如果在某个对象（Activity、ViewGroup、View）的dispatchTouchEvent()消费事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP</li>
</ul>

<blockquote>
<p>黑线：ACTION_DOWN事件传递方向<br/>
红线：ACTION_MOVE和ACTION_UP事件传递方向</p>
</blockquote>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015430075078.png" alt="20171108151015430075078.png"/><figcaption>20171108151015430075078.png</figcaption></figure></p>

<ul>
<li>如果在某个对象（Activity、ViewGroup、View）的onTouchEvent()消费事件（返回true），那么ACTION_MOVE和ACTION_UP的事件从上往下传到这个View后就不再往下传递了，而直接传给自己的onTouchEvent()并结束本次事件传递过程。</li>
</ul>

<blockquote>
<p>黑线：ACTION_DOWN事件传递方向<br/>
红线：ACTION_MOVE和ACTION_UP事件传递方向</p>
</blockquote>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151015431870363.png" alt="20171108151015431870363.png"/><figcaption>20171108151015431870363.png</figcaption></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872263.html">
                
                  <h1>Android-史上最全解析Android消息推送解决方案</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>消息推送在Android开发中应用的场景是越来越多了，比如说电商产品进行活动宣传、资讯类产品进行新闻推送等等。</p>

<p>本文将介绍Android中实现消息推送的7种主流解决方案。</p>

<h2 id="toc_1">目录</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014893328998.png" alt="20171108151014893328998.png"/><figcaption>20171108151014893328998.png</figcaption></figure></p>

<h2 id="toc_2">定义</h2>

<p>在用户未打开App时，App主动向用户推送服务器最新消息。如下图：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014897092874.png" alt="20171108151014897092874.png"/><figcaption>20171108151014897092874.png</figcaption></figure></p>

<p>消息推送的本质是：App将服务器更新的信息推送给用户</p>

<h2 id="toc_3">作用</h2>

<ul>
<li>产品的角度：功能需要，比如说资讯类产品的新闻推送、工具类产品的公告推送等等</li>
<li>运营的角度：活动运营需要，比如说电商类产品的促销活动；召回用户 / 提高活跃度等等</li>
</ul>

<blockquote>
<p>作为开发者，不要有需求就接，应该多思考、多理解用户 / 功能的使用场景，有助于我们更好地去选择合适的开发方式</p>
</blockquote>

<h2 id="toc_4">储备知识</h2>

<h3 id="toc_5">操作系统有自身的消息推送功能（系统级别）</h3>

<ul>
<li>系统级别：任何时候都可以推送给用户，且不会被系统杀死</li>
<li>Android的消息推送服务称为：C2DM（Cloudto Device Messaging）</li>
</ul>

<blockquote>
<p>将在下面详细描述</p>
</blockquote>

<h3 id="toc_6">推送的本质与原理</h3>

<ul>
<li>消息推送的本质是：App将服务器更新的信息推送给用户，即App获取服务器信息，再推送给用户</li>
<li>App从服务器获取最新消息的基本方式（原理）有3种：Push、Pull 和 SMS</li>
<li>具体如下</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014908561018.png" alt="20171108151014908561018.png"/><figcaption>20171108151014908561018.png</figcaption></figure></p>

<h2 id="toc_7">解决方案</h2>

<p>经总结，Android中实现消息推送的有7种主流解决方案，接下来将一一介绍。</p>

<h3 id="toc_8">C2DM</h3>

<ul>
<li>定义：Cloud to Device Messaging，云端推送</li>
</ul>

<blockquote>
<p>Android系统级别的消息推送服务-Google出品</p>
</blockquote>

<ul>
<li>原理：基于Push方式，C2DM服务负责处理诸如消息排队等事务，并向运行于目标设备上的应用程序分发这些消息。如下图：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014911731014.png" alt="20171108151014911731014.png"/><figcaption>20171108151014911731014.png</figcaption></figure></p>

<ul>
<li>优点：C2DM提供了一个简单的、轻量级的机制，允许服务器可以通知移动应用程序直接与服务器进行通信，以便于从服务器获取应用程序更新和用户数据。</li>
<li>缺点：
<ol>
<li>依赖于Google官方提供的C2DM服务器，但在国内使用Google服务需要翻墙，成本较大；</li>
<li>需要用户手机安装Google服务。但由于Android机型、系统的碎片化 &amp; 国内环境，国内的Android系统都自动去除Google服务，假如要使用C2DM服务，这意味着用户还得去安装Google服务，成本较大。</li>
</ol></li>
</ul>

<h3 id="toc_9">轮询</h3>

<ul>
<li>原理：基于Pull方式，应用程序隔固定时间主动与服务器进行连接并查询是否有新的消息</li>
<li>缺点：
<ol>
<li>成本大，需要自己实现与服务器之间的通信，例如消息排队等；</li>
<li>到达率不确定，考虑轮询的频率：太低可能导致消息的延迟；太高，更费客户端的资源（CPU资源、网络流量、系统电量）和服务器资源（网络带宽）</li>
</ol></li>
</ul>

<h3 id="toc_10">SMS</h3>

<ul>
<li>定义：短信发送</li>
<li>原理：基于Push方式，通过拦截SMS消息并且解析消息内容来了解服务器的意图，并获取其显示内容进行处理。</li>
<li>优点：可实现完全的实时操作</li>
<li>缺点：成本相对较高。因为目前来说，很难找到免费的短消息发送网关来实现这种方案，只能通过向运营商缴纳相应的短信费用</li>
</ul>

<h3 id="toc_11">MQTT协议</h3>

<ul>
<li>定义：轻量级的消息发布/订阅协议</li>
<li>原理：基于Push方式，wmqtt.jar 是IBM提供的MQTT协议的实现，原理如下图：</li>
</ul>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014921455838.png" alt="20171108151014921455838.png"/><figcaption>20171108151014921455838.png</figcaption></figure></p>

<blockquote>
<p>更多关于MQTT协议：  </p>

<ol>
<li><a href="https://github.com/tokudu/AndroidPushNotificationsDemo">项目实例源</a><br/></li>
<li><a href="https://github.com/tokudu/PhpMQTTClient">一个采用PHP书写的服务器端</a><br/></li>
<li><a href="http://www-01.ibm.com/support/docview.wss?rs=171&amp;uid=swg24006006">Jar包下载地址</a>，并加入自己的Android应用程序中。<br/></li>
<li>拓展：RSMB是从MQTT协议引申出来的另外一种解决方案：简单的MQTT代理，详情<a href="http://www.alphaworks.ibm.com/tech/rsmb">请点击</a><br/></li>
</ol>
</blockquote>

<h3 id="toc_12">XMPP协议</h3>

<ul>
<li>定义：Extensible Messageing and Presence Protocol，可扩展消息与存在协议，是基于可扩展标记语言（XML）的协议，是目前主流的四种IM协议之一</li>
</ul>

<blockquote>
<p>其他三种：</p>
</blockquote>

<ul>
<li>即时信息和空间协议（IMPP）</li>
<li>空间和即时信息协议（PRIM）</li>
<li>即时通讯和空间平衡扩充的进程开始协议SIP（SIMPLE）</li>
<li>原理：XMPP中定义了三个角色，分别是客户端、服务器和网关</li>
</ul>

<p><strong>客户端</strong></p>

<ol>
<li>通过 TCP/IP与XMPP 服务器连接，然后在之上传输与即时通讯相关的指令（XML）；</li>
<li>解析组织好的 XML 信息包；</li>
<li>理解消息数据类型。</li>
</ol>

<blockquote>
<p>XMPP的核心：XML流传输协议（在网络上分片断发送XML的流协议），也是即时通讯指令的传递基础，即XMPP用TCP传的是XML流<br/><br/>
与即时通讯相关的指令，在以前要么用2进制的形式发送（比如QQ），要么用纯文本指令加空格加参数加换行符的方式发送（比如MSN）。<br/><br/>
XMPP传输的即时通讯指令的逻辑与以往相仿，只是协议的形式变成了XML格式的纯文本。  </p>
</blockquote>

<p><strong>服务器</strong></p>

<ol>
<li>监听客户端连接，并直接与客户端应用程序通信（客户端信息记录）</li>
<li>与其他 XMPP 服务器通信；</li>
</ol>

<p><strong>网关</strong>：与异构即时通信系统进行通信</p>

<blockquote>
<p>异构系统包括SMS（短信），MSN，ICQ等</p>
</blockquote>

<p>通信能够在这三者的任意两个之间双向发生。</p>

<p><strong>原理流程</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110815101494469135.png" alt="2017110815101494469135.png"/><figcaption>2017110815101494469135.png</figcaption></figure></p>

<ul>
<li>优点：
<ol>
<li>开源：可通过修改其源代码来适应我们的应用程序。</li>
<li>简单：XML易于解析和阅读；将复杂性从客户端转移到了服务器端</li>
<li>可拓展性强：继承了在XML环境中灵活的发展性，可进一步对协议进行扩展，实现更为完善的功能。</li>
</ol></li>
</ul>

<blockquote>
<p>GTalk、QQ、IM等都用这个协议</p>
</blockquote>

<ul>
<li>缺点：如果将消息从服务器上推送出去，则不管消息是否成功到达客户端手机上。</li>
<li>源码实例：有一个很棒的基于XMPP协议的java开源Android push notification：Androidpn<a href="http://sourceforge.net/projects/androidpn/">项目地址</a>，大家有兴趣可以去看看</li>
</ul>

<blockquote>
<p>更多关于XMPP协议更加详细<a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/04/2378956.html">请点击</a></p>
</blockquote>

<h3 id="toc_13">使用第三方平台</h3>

<p>现今主流的推送平台分为</p>

<ol>
<li>手机厂商类：小米推送、华为推送。</li>
<li>第三方平台类：友盟推送、极光推送、云巴（基于MQTT）</li>
<li>BAT大厂的平台推送：阿里云移动推送、腾讯信鸽推送、百度云推送</li>
</ol>

<p>具体各推送平台的优缺点请看我写的文章：<a href="http://www.jianshu.com/p/d77eaca4e52a">Android推送：第三方消息推送平台详细解析</a></p>

<h3 id="toc_14">自己搭建</h3>

<p>如果你的产品对于消息推送具备较高的功能和性能要求，同时对安全性要求非常高的话，自己搭建可能是最好的方式，但这种方式无疑成本是最高的。</p>

<h2 id="toc_15">总结</h2>

<ul>
<li>经过上面的详细讲解，相信大家现在对Android中消息推送的解决方案已经非常了解</li>
<li>解决方案没有优劣，要具具体使用场景而定。但一般来说，个人建议使用第三方平台推送，成本低+抵达率高</li>
<li>关于Android消息推送的其他知识，具体请看：<br/>
<a href="http://www.jianshu.com/p/b1134bebc2d4">Android消息推送：手把手教你集成小米推送</a><br/>
<a href="http://www.jianshu.com/p/d77eaca4e52a">Android推送：第三方消息推送平台详细解析</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872230.html">
                
                  <h1>Android-RecyclerView自定义ItemDecoration从入门到实现吸顶效果</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>RecyclerView性能和自由度相比ListView强大很多,但很恼人的是它没有像ListView一样默认提供分割线.</p>

<p>刚接触RecyclerView,用过才发现RecyclerView没有分割线过后,遂到网上搜解决办法才发现自定义一个ItemDecoration只要一条黑线还要写代码,好麻烦,不知道有没像我一样懒得折腾上网搜现成的,粘贴到项目直接用.</p>

<p>拖了很久才去解决这个问题,上网大致看了一下教程,其实不难而且自定义功能很强大.</p>

<p>首先新建一个类覆写ItemDecoration里面有三个方法:</p>

<pre class="line-numbers"><code class="language-java">public class SimpleItemDecoration extends RecyclerView.ItemDecoration {

    public SimpleItemDecoration(Context context) {

    }

    
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        super.onDraw(c, parent, state);
    }

    
    public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
        super.onDrawOver(c, parent, state);

    }


    @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
        super.getItemOffsets(outRect, view, parent, state);
    }
}
</code></pre>

<ul>
<li>onDraw名字很熟悉吧,和View中的onDraw一样,是用来画东西的, 在item上画分割线就靠这个方法了.</li>
<li>onDrawOver 英文Over的意思在...的上面 ,可以理解成是图层关系,item的内容和分割线是第一层(要在第一层画东西要调用onDraw),而onDrawOver是第二层,位于onDraw的上面</li>
<li>getItemOffsets 看名字可以知道是设置item的偏移值,其实效果和padding一样.</li>
</ul>

<p>以上三个方法都是在RecylerView发生滑动的时候触发.</p>

<p>需要注意的是三个方法的都有一个RecyclerView parent,通过这个参数我们可以获取到RecyclerView的属性,例如 parent.getChildCount();获取子View的个数,但是这个并不是获取RecyclerView所有的item个数,而是当前屏幕可见的item个数.</p>

<p>所以画一条分割线需要的代码是这样的:</p>

<pre class="line-numbers"><code class="language-java">    private int wight;
    private int height;
    private int item_height;
    private int item_padding;
    private Paint paint;

public SimpleItemDecoration(Context context) {

        wight=context.getResources().getDisplayMetrics().widthPixels;
        height=context.getResources().getDisplayMetrics().heightPixels;
        paint=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG);
        paint.setColor(Color.BLACK);
        item_height=DensityUtil.dip2px(context, 1);
        item_padding=DensityUtil.dip2px(context, 10);
    }

    @Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        super.onDraw(c, parent, state);
        int count=parent.getChildCount();
        for (int i = 0; i &lt; count; i++) {
            View view=parent.getChildAt(i);
            int top=view.getTop();
            int bottom=top+item_height;
            c.drawRect(0,top,wight,bottom,paint);

        }

         .....
    }
</code></pre>

<p>运行后得到如下图的效果.</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014780724646.png" alt="20171108151014780724646.png"/><figcaption>20171108151014780724646.png</figcaption></figure></p>

<p>接着把<code>item_height=DensityUtil.dip2px(context, 1);</code>的1改成30,你会发现item的内容和黑色的分割线重合了</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014785773153.png" alt="20171108151014785773153.png"/><figcaption>20171108151014785773153.png</figcaption></figure></p>

<p>因为上面说了item和内容和onDraw中画的内容在同一图层,当然会被出现重合的情况.这个时候getItemOffsets就能派上用场了.只要在原来的item的加个偏移值(效果和在Adpater中为item设置padding的效果是一样的,只是在ItemDecoration统一处理比较合适)onDraw中画的分割线有多高,我就paddingBottom多少.</p>

<p>所以代码是是这样的:</p>

<pre class="line-numbers"><code class="language-java">  public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
        super.getItemOffsets(outRect, view, parent, state);
        outRect.bottom=item_height;
    }
</code></pre>

<p>再次运行代码item被挡住的问题就解决了,RecyclerView的自定义ItemDecoration就是这么简单.有点自定义View经验的人理解起来都不会难</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014788332810.png" alt="20171108151014788332810.png"/><figcaption>20171108151014788332810.png</figcaption></figure></p>

<p>分割线不要占满,要有和Left,Right有间距啊?</p>

<p>添加如下代码:</p>

<pre class="line-numbers"><code class="language-java">    private int wight;
    private int height;
    private int item_height;
    private Paint paint;
    private float item_padding;

    public SimpleItemDecoration(Context context) {

        wight=context.getResources().getDisplayMetrics().widthPixels;
        height=context.getResources().getDisplayMetrics().heightPixels;
        paint=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG);
        paint.setColor(Color.BLACK);
        item_height=DensityUtil.dip2px(context, 1);
        item_padding=DensityUtil.dip2px(context, 10);
    }

    @Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        super.onDraw(c, parent, state);
        int count=parent.getChildCount();
        for (int i = 0; i &lt; count; i++) {
            View view=parent.getChildAt(i);
            int top=view.getBottom();
            int bottom=top+item_height;
            //这里把left和right的值分别增加item_padding,和减去item_padding.
            c.drawRect(item_padding,top,wight-item_padding,bottom,paint);

        }
          ....
    }
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014792933867.png" alt="20171108151014792933867.png"/><figcaption>20171108151014792933867.png</figcaption></figure></p>

<p>一般用到的分割线根据以上的代码再自己的按照需求稍微修改一下基本都能满足需求了.</p>

<p>之前在网上看到通过自定义ItemDecoration实现仿照旧版的instagram吸顶效果,感觉那种效果很好看,研究了一下发现只要理解了上面文章所说的几个方法实现起来并不难.</p>

<p>先来看最终效果图:</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110815101479719495.gif" alt="2017110815101479719495.gif"/><figcaption>2017110815101479719495.gif</figcaption></figure></p>

<p>要实现吸顶的效果需要完成这些步骤:</p>

<ul>
<li>首先需要画一条高度足够容下文字和图片的分割线.</li>
<li>因为是吸顶效果,所以分割线和传统的分割线一样应该是在每个item的上方而不是下方</li>
<li>当前屏幕可见的第一个item的Bottom&lt;=item_height(分割线的高度) 说明可见的第一个item的底部已经超出了分割线的高度,这个时候就应该让第一条分割线随着RecyclerView向上滑动直到滑出屏幕,这个时候第二个item就取代了第一个item变成了第一个item,否则分割线一直固定不动.</li>
<li>判断当前屏幕的第一个可见的item是哪个</li>
<li>把当前屏幕可见的item进行对比,如果item的内容第一个字相同,则把它们归为一组,用一条分割线显示即可.</li>
</ul>

<p>先来实现1和2的要求,主要代码部分如下:</p>

<pre class="line-numbers"><code class="language-java">private int wight;
    private int height;
    private int item_height;
    private Paint paint;
    private float item_padding;

    public SimpleItemDecoration(Context context) {

        wight=context.getResources().getDisplayMetrics().widthPixels;
        height=context.getResources().getDisplayMetrics().heightPixels;
        paint=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG);
        //更改画笔颜色为自定义的颜色
        paint.setColor(context.getResources().getColor(R.color.itemColor));
        item_height=DensityUtil.dip2px(context, 30);
        item_padding=DensityUtil.dip2px(context, 10);
    }


@Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
        super.getItemOffsets(outRect, view, parent, state);
        //因为分割线是在item的上方,所以需要为每个item腾出一条分割线的高度
        outRect.top=item_height;

    }

@Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        super.onDraw(c, parent, state);
        int count=parent.getChildCount();
        for (int i = 0; i &lt; count; i++) {
            View view=parent.getChildAt(i);
            //分割线不能和item的内容重叠,所以把分割线画在getItemOffsets为item腾出来的位置上.
            //所以top需要上移item_height
            int top=view.getTop()-item_height;
            //bottom同理
            int bottom=top+item_height;
            c.drawRect(0,top,wight,bottom,paint);
        }
    }

....
</code></pre>

<p>最终实现的效果如图:</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014809478336.png" alt="20171108151014809478336.png"/><figcaption>20171108151014809478336.png</figcaption></figure></p>

<p>注意看陈奕迅这个item的分割线是在item的上面的,并且分割线的高度已经足够容下我们稍后要绘制的内容了.</p>

<p>接着来实现3,怎么样才能让分割线在满足条件的时候动,不满足的时候固定?</p>

<p>这个时候就需要用到代码中一直没覆写的onDrawOver方法了,先来实现固定不动的分割线,代码也是非常的简单,在原来的代码上覆写onDrawOver方法<br/>
(这里new了新的画笔paint2,把固定的分割线用半透明红色来作为背景,方便理解效果):</p>

<pre class="line-numbers"><code class="language-java">paint2=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG);
paint2.setColor(Color.parseColor(&quot;#52ff0000&quot;));
  
@Override
public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
    super.onDrawOver(c, parent, state);
}
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014817074489.gif" alt="20171108151014817074489.gif"/><figcaption>20171108151014817074489.gif</figcaption></figure></p>

<p>接着来实现实现: 当前屏幕可见的第一个item的Bottom&lt;=item_height(分割线的高度)让第一条分割线随着RecyclerView向上滑动直到滑出屏幕,代码如下:</p>

<pre class="line-numbers"><code class="language-java">@Override
    public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
        super.onDrawOver(c, parent, state);
        View child0 = parent.getChildAt(0);

        //如果第一个item的Bottom&lt;=分割线的高度
        if (child0.getBottom() &lt;= item_height) {
            //随着RecyclerView滑动 分割线的top=固定为0不动,bottom则赋值为child0的bottom值.
            c.drawRect(0, 0, wight,child0.getBottom() , paint2);
        } else {
            //固定不动
            c.drawRect(0, 0, wight, item_height, paint2);

        }
    }
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151014821936037.gif" alt="20171108151014821936037.gif"/><figcaption>20171108151014821936037.gif</figcaption></figure></p>

<p>可以看到滑动时当第二item的顶部和第一个item的底部相互接触到后继续滑动的话第一个item就会慢慢向上滑动,直到第一个item完全画出屏幕,固定分割线立马回到最开始的位置和item2分割线重叠了在一起<br/>
,现在可以把paint2换回paint效果会更直观,不上效果图了,可以自己去测试.</p>

<p>对第一次接触ItemDecoration的人来说,难点都已经讲完了,剩下的就是在分割线范围计算出合适的位置调动drawText和drawBitmap画下文字和图片,直接贴上完整的源码:</p>

<p>(在源码注释里面已经把没有讲到的方法大致提了一下实现的原理)</p>

<p>自定义ItemDecoration的代码:</p>

<pre class="line-numbers"><code class="language-java">/**
 * Created by Lipt0n on 2017/8/26.
 */

public class SimpleItemDecoration extends RecyclerView.ItemDecoration {


    private Bitmap bitmap;
    private Paint.FontMetrics fontMetrics;
    private int wight;
    private int itemDecorationHeight;
    private Paint paint;
    private ObtainTextCallback callback;
    private float itemDecorationPadding;
    private TextPaint textPaint;
    private Rect text_rect=new Rect();
    public SimpleItemDecoration(Context context, ObtainTextCallback callback) {

        wight=context.getResources().getDisplayMetrics().widthPixels;
        paint=new Paint(Paint.ANTI_ALIAS_FLAG|Paint.DITHER_FLAG);
        paint.setColor(context.getResources().getColor(R.color.itemColor));
        itemDecorationHeight=DensityUtil.dip2px(context, 30);
        itemDecorationPadding=DensityUtil.dip2px(context, 10);
        this.callback = callback;



        textPaint = new TextPaint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
        textPaint.setColor(Color.WHITE);
        textPaint.setTextAlign(Paint.Align.LEFT);
        textPaint.setTextSize(DensityUtil.dip2px(context, 25));
        fontMetrics = new Paint.FontMetrics();
        textPaint.getFontMetrics(fontMetrics);

        bitmap= BitmapFactory.decodeResource(context.getResources(), R.mipmap.ic_launcher_round);
        ScaleBitmap();
    }

    //bitmap的大小和itemDecorationHeight进行比较对图片进行缩放操作(对性能有追求可以在加载到内存的时候进行压缩)
    private void ScaleBitmap() {
        Matrix matrix=new Matrix();
        float scale=bitmap.getWidth()&gt;itemDecorationHeight?Float.valueOf(itemDecorationHeight)/Float.valueOf(bitmap.getHeight()):Float.valueOf(bitmap.getHeight())/Float.valueOf(itemDecorationHeight);
        matrix.postScale(scale,scale);
        bitmap= Bitmap.createBitmap(bitmap,0,0,bitmap.getWidth(),bitmap.getHeight(),matrix,false);
    }



    @Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        super.onDraw(c, parent, state);
        int count=parent.getChildCount();
        for (int i = 0; i &lt; count; i++) {
            View view=parent.getChildAt(i);
            int top=view.getTop()-itemDecorationHeight;
            int bottom=top+itemDecorationHeight;


            int position = parent.getChildAdapterPosition(view);
            String content = callback.getText(position);
            textPaint.getTextBounds(content,0, content.length(),text_rect);

            if(isFirstInGroup(position)) {
                c.drawRect(0,top,wight,bottom,paint);
                c.drawText(content, itemDecorationPadding+bitmap.getWidth(), bottom-fontMetrics.descent, textPaint);
                c.drawBitmap(bitmap,itemDecorationPadding,bottom-bitmap.getHeight(),paint);
            }
        }
    }

    @Override
    public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
        super.onDrawOver(c, parent, state);

        View child0=parent.getChildAt(0);
        int position = parent.getChildAdapterPosition(child0);
        String content = callback.getText(position);
        if(child0.getBottom()&lt;=itemDecorationHeight&amp;&amp;isFirstInGroup(position+1)){
            c.drawRect(0, 0, wight, child0.getBottom(), paint);
            c.drawText(content, itemDecorationPadding+bitmap.getWidth(), child0.getBottom()-fontMetrics.descent, textPaint);
            c.drawBitmap(bitmap,itemDecorationPadding,child0.getBottom()-bitmap.getHeight(),paint);
        }
        else {
            c.drawRect(0, 0, wight, itemDecorationHeight, paint);
            c.drawText(content, itemDecorationPadding+bitmap.getWidth(), itemDecorationHeight-fontMetrics.descent, textPaint);
            c.drawBitmap(bitmap,itemDecorationPadding,itemDecorationHeight-bitmap.getHeight(),paint);
        }
    }


    @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
        super.getItemOffsets(outRect, view, parent, state);
        int position= parent.getChildAdapterPosition(view);
        //如果不是在同一组就腾出分割线需要的高度
        if(isFirstInGroup(position)){
            outRect.top=itemDecorationHeight;
        }

    }

    //回调接口,通过该回调获取item的内容的第一个文字
    public interface ObtainTextCallback {
        String getText(int position);
    }

    //判断当前item和下一个item的第一个文字是否相同,如果相同说明是同一组,不需要画分割线
    private boolean isFirstInGroup(int pos) {
       //如果是adapter的第一个position直接return,因为第一个item必须有分割线
        if (pos == 0) {
            return true;
        } else {
             //否者判断前一个item的字符串 与 当前item字符串 是否相同
            String prevGroupId = callback.getText(pos - 1);
            String groupId = callback.getText(pos);          
            if (prevGroupId.equals(groupId)) {
                return false;
            } else {
                return true;
            }
        }
    }
}
</code></pre>

<p><strong>Activity中调用的代码:</strong></p>

<pre class="line-numbers"><code class="language-java">recyclerView.addItemDecoration(new SimpleItemDecoration(this, new SimpleItemDecoration.ObtainTextCallback() {
    @Override
    public String getText(int position) {
        return dataList.get(position).substring(0,1);
    }
}));
</code></pre>

<p>只要理解了最开始提到的ItemDecoration 的3个主要方法,再处理一下文字分组的逻辑实现起来不会太难,花点耐心还是能写出来的.</p>

<p>贴上<a href="https://github.com/granden/RecyclerViewDemo">github源码地址</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/26</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872196.html">
                
                  <h1>Android-拍照获取缩略图以及完整图片(适配androidN)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">调用系统相机拍照获取缩照片略图</h2>

<blockquote>
<p>调用系统相机拍照时，如果不传路径，图片默认返回缩略图，不需要权限</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
    startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
}
</code></pre>

<p><code>takePictureIntent.resolveActivity(getPackageManager()) != null</code></p>

<p>在官方文档中有描述：startActivityForResult（）方法受到调用resolveActivity（）的条件的保护，该方法返回可处理该意图的第一个活动组件，执行此检查很重要，因为如果您使用没有应用程序可以处理的意图调用startActivityForResult（），则您的应用程序将崩溃。所以只要结果不为空，就可以安全的使用意图，大概意思是检测手机中有没有相机。</p>

<p>另外一种检测相机的方法是</p>

<pre class="line-numbers"><code class="language-text">&lt;manifest ... &gt;
    &lt;uses-feature android:name=&quot;android.hardware.camera&quot;
                  android:required=&quot;true&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>

<p>required=true表示要安装该应用，手机必须有摄像头该硬件。要不然不允许安装</p>

<p><strong>处理回调</strong></p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) {
        Bundle extras = data.getExtras();
        Bitmap imageBitmap = (Bitmap) extras.get(&quot;data&quot;);
        mImageView.setImageBitmap(imageBitmap);
    }
}
</code></pre>

<h2 id="toc_1">调用系统相机拍照获取全尺寸照片</h2>

<blockquote>
<p>如果要保存一个全尺寸的照片，必须提供一个完整的文件名，当照片需要保存到公有目录时，那么需要一个写入的权限(写入权限已经隐含的允许读取[READ_EXTERNAL_STORAGE]，这样子就可以将app拍的照片写入到外部存储,该外部存储的链接是<code>getExternalStoragePublicDirectory()</code></p>
</blockquote>

<pre class="line-numbers"><code class="language-text">&lt;manifest ...&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>

<blockquote>
<p>当需要将得到的照片保存到私有目录时，使用该链接<code>getExternalFilesDir(),getFilesDir()</code>，这两个目录下的文件在应用删除的时候就自动删掉了，在android4.4以下需要权限，4.4以上应用之间不能被其他程序访问，因此该权限只要在4.4以下加入</p>
</blockquote>

<pre class="line-numbers"><code class="language-text">&lt;manifest ...&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;
                     android:maxSdkVersion=&quot;18&quot; /&gt;
    ...
&lt;/manifest&gt;
</code></pre>

<ul>
<li>提供一个不会冲突的文件名，例如按时间来起名</li>
</ul>

<pre class="line-numbers"><code class="language-java">String mCurrentPhotoPath;

private File createImageFile() throws IOException {
    // Create an image file name
    String timeStamp = new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(new Date());
    String imageFileName = &quot;JPEG_&quot; + timeStamp + &quot;_&quot;;
    File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
    File image = File.createTempFile(
        imageFileName,  /* prefix */
        &quot;.jpg&quot;,         /* suffix */
        storageDir      /* directory */
    );

    // Save a file: path for use with ACTION_VIEW intents
    mCurrentPhotoPath = image.getAbsolutePath();
    return image;
}
</code></pre>

<ul>
<li>构造拍照intent，适配7.0以及4.0</li>
</ul>

<pre class="line-numbers"><code class="language-java">static final int REQUEST_TAKE_PHOTO = 1;

    private void camera2() {
        Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
        // Ensure that there&#39;s a camera activity to handle the intent
        if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
            // Create the File where the photo should go
            File photoFile = null;

            try {
                photoFile = createImageFile();
            } catch (IOException ex) {
                // Error occurred while creating the File
            }
            // Continue only if the File was successfully created
            if (photoFile != null) {
                Uri photoURI = FileProvider.getUriForFile(this,
                        &quot;lsp.com.ipctest.fileprovider&quot;,
                        photoFile);

                //解决4.0
                List&lt;ResolveInfo&gt; resInfoList = getPackageManager()
                        .queryIntentActivities(takePictureIntent, PackageManager.MATCH_DEFAULT_ONLY);
                for (ResolveInfo resolveInfo : resInfoList) {
                    String packageName = resolveInfo.activityInfo.packageName;
                    grantUriPermission(packageName, photoURI, Intent.FLAG_GRANT_READ_URI_PERMISSION
                            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
                }


                takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);
                startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO);
            }
        }
    }
</code></pre>

<blockquote>
<p><code>FileProvider.getUriForFile()</code>用来返回一个content：// URI。对于最新的针对Android 7.0（API级别24）的应用程序，通过一个包边界传递一个文件：// URI会导致FileUriExposedException<br/>
鸿洋的博客关于android7.0 以及 4.0 拍照封装的处理(点击跳转)</p>
</blockquote>

<ul>
<li>取得结果</li>
</ul>

<pre class="line-numbers"><code class="language-java">if (requestCode == REQUEST_TAKE_PHOTO &amp;&amp; resultCode == RESULT_OK) {
    Bitmap imageBitmap = BitmapFactory.decodeFile(mCurrentPhotoPath);
    Log.e(TAG, &quot;文件大小&quot; + imageBitmap.getByteCount() / 1024 + &quot;kb&quot;);
    ((ImageView) findViewById(R.id.img)).setImageBitmap(imageBitmap);
}
</code></pre>

<ul>
<li>将照片保存到相册如果你保存图片的路径是getExternalFilesDir() 媒体扫描器访问不到，只有你自己的应用可以访问，因此一下方法可以将图片保存到相册</li>
</ul>

<pre class="line-numbers"><code class="language-java">private void galleryAddPic() {
    Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
    File f = new File(mCurrentPhotoPath);
    Uri contentUri = Uri.fromFile(f);
    mediaScanIntent.setData(contentUri);
    this.sendBroadcast(mediaScanIntent);
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872163.html">
                
                  <h1>Android-关于android UI适配的一些思考</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">关于xml中写死dp的思考</h2>

<p>首先我们应该先把问题抛出，如果我们在xml把控件的宽度和高度写死，比如</p>

<pre class="line-numbers"><code class="language-text"> &lt;TextView
            android:layout_width=&quot;100dp&quot;
            android:layout_height=&quot;50dp&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;asdasdasd&quot;
            /&gt;
</code></pre>

<p>相信大多时候都可以这么写，因为Android dp这个单位就是为了适配屏幕而出现的控件长度单位，它会让100dp在不同的手机不同的屏幕尺寸都有相似的表现。 <br/>
为什么是相似的表现而不是绝对的表现呢？因为不同的设备，横向和纵向所拥有的dp很可能是不同的，一般手机横向dp在360dp左右，也就是说，如果你写了一个宽度为180dp的控件，在一些手机可能有屏幕的一般宽，有一些手机超过一般，有一些手机不到一半。</p>

<p>我们写这样的一段代码，然后看一下xml的预览效果：</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:background=&quot;#123333&quot;
    android:id=&quot;@+id/container&quot;
    android:layout_width=&quot;360dp&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151007149290806.png" alt="20171108151007149290806.png"/><figcaption>20171108151007149290806.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151007150182264.png" alt="20171108151007150182264.png"/><figcaption>20171108151007150182264.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151007150657381.png" alt="20171108151007150657381.png"/><figcaption>20171108151007150657381.png</figcaption></figure></p>

<h2 id="toc_1">关于java动态写控件大小的思考</h2>

<p>我们看到360dp在不同设备的所表现的占屏比是不同的。如果我们写数值比较小的dp相信直接写死的问题不大。但是如果设计稿上某个控件的宽度你换算完刚好是340dp怎么，肯定不能写340dp。其实我们可以用match_parent然后用padding margin之类的东西，在左右留一个小数值dp的距离，来实现效果。但是如果这个控件要求是高度和宽度的比例是固定的，比如展示一个广告浮层的图片，那么xml估计就无法锁定宽高比了，我们就必须借助java代码来决定这个控件高度：</p>

<pre class="line-numbers"><code class="language-java">RelativeLayout.LayoutParams mLayoutParams = 
new RelativeLayout.LayoutParams (mHeight,mWidth);
mLayoutParams.addRule(RelativeLayout.ALIGN_TOP, R.id.supernatant);
mLayoutParams.addRule(RelativeLayout.ALIGN_LEFT, R.id.supernatant);
bigSupernatantImgLayoutParams.setMargins(DPIUtil.dip2px(9f), 0, 0, 0);
bigImg.setLayoutParams(mLayoutParams);
</code></pre>

<p>类似这样宽度和高度都是活的，我们可以通过获取屏幕的实际宽高像素，来通过等比，相似等一些算法，转换出比例和UI设计图一样的UI，但是最大的弊端应该就是，这么书写会让java代码比较多，比较乱。因此会有一些百分百布局框架等，其实思路都类似，等比缩放就是很核心思路。 <br/>
有个轻量的方法也就是写个工具类算出设计图到手机屏幕的转换关系：</p>

<pre class="line-numbers"><code class="language-java">public static int getHeightByValue720(int mValue) {
return (int) ((float) (DPITools.getHeight() * nDesignValue) / (float) 1280);
    }

public static int getWidthByValue720(int mValue) {
return (int) ((float) (DPITools.getWidth() * nDesignValue) / (float) 720);
    }
</code></pre>

<p>这个方法就是如果是720的设计稿，我们将设计稿的值转换为在所用设备下同比例的大小。这似乎很完美。 <br/>
如果设计给的控件大小是 100X200 ，那么如果运行在1080p的设配上。我们动态得到控件的大小是150X300.很开心，1080的横向纵向像素是720的1.5倍，控件也大了1.5倍这，的确没毛病。但是我们可能低估了安卓阵营了。</p>

<h2 id="toc_2">关于动态宽高写布局的一些思考。</h2>

<p>三星Galaxy S8分辨率： 2960*1440 (570 ppi)</p>

<p>如果按照上述方式我们在三星Galaxy S8上运行效果会是如何呢？结果是200X462。控件已经倍拉伸了，原因就是S8的屏幕比例不是16比9所以，按照原来的方式缩放，就会造成拉伸，为此市面上也有解决方案：</p>

<pre class="line-numbers"><code class="language-java">public static int getValueByValue720(int mValue) {
return (int) ((float) (DPITools.getWidth() * nDesignValue) / (float) 720);
    }
</code></pre>

<p>就是无论宽度还是高度，都是用宽度缩放，那么刚才控件在S8上得到的数值就是200X400.控件不会被拉伸，由于现在大多界面都是可以Scroll的，那么就算高度不标准问题也不大，我们比如一个listview我们保证在16比9的手机上，能正好展示4个item，在16比10的手机上展示3个半item，在18.5比9的设备上展示4个半item，这个设计产品还是用户都是可以接受的。</p>

<h2 id="toc_3">关于动态宽度为基准写布局的一些思考。</h2>

<p>然而关于方法三又存在一些问题，设想下面一个场景，页面里展示的是一个cardview，cardview的背景是一张图片，所以cardview宽高必须固定，这个cardview又是不允许上下滑动的，里面又有很多控件，在16比9的设计稿上，cardview里面的控件，排列整齐，最后也没什么太大的边界。</p>

<p>这样面临一个问题，如果在16比10的手机上，其实每次计算出的高度都是大于手机比例的，因此cardview后面的几个控件可能无法正常显示，或被拉伸。在18.5比9的手机上，cardview下面可能有空余，或者根据不同layout方式，可能其他地方有空余。我认为这还是可以接受的，比较这种手机是少数，但是控件被挤压就难以接受了。归纳起来也就说，如果这种不能上下滑动的view，可以让它有空余，但是不能让它挤压。我们可以使用一个保守的方法，判断手机是否是大于16比9，如果大于就说明手机比较瘦高，如果小于就说明手机比较胖。我们就可以用相对充裕的方法计算控件宽高，来保证控件不被挤压。</p>

<pre class="line-numbers"><code class="language-java">public static boolean bigThan169() {
        float h = DPIUtil.getHeight();
        float w = DPIUtil.getWidth();
        if ((h / w) &gt; 1.78f) return true;
        else return false;
    }
</code></pre>

<pre class="line-numbers"><code class="language-java">if (bigThan169())
newWidth = DPIUtil.getWidthByDesignValue720(DesignWidth);（以宽度为基准）
else newWidth = DPIUtil.getHeightByDesignValue720(DesignWidth);（以高度为基准 从而保证控件上下高度够用）
</code></pre>

<p>总之就这就是一个保守，保证控件装得下的思路，若果是控件横向被挤压也是一样的。我们为了保证显示的下，缩小了控件。</p>

<p>总结：UI适配愈走愈远，有时也要和设计师产品经理协调，不要设计一些容易触发适配问题的页面，减少安卓端的适配压力，但是如果场景真的无法避免，我们就只能有更优雅的方式去解决适配问题。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872093.html">
                
                  <h1>Android-爱奇艺APK瘦身经验</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">APK瘦身的价值</h2>

<p>用户常常避免下载太大的APP，尤其是使用移动流量的情况，而且太大的APP也会占用更多的内存并消耗更多的资源，导致安装速度和加载速度变慢，在低配手机上，这些情况尤其严重。</p>

<p>作为中国互联网领先的手机APP，爱奇艺非常重视APP客户端的用户体验，始终关注APK的体积，并持续的跟进优化。</p>

<p>目前爱奇艺Android APK大小指标在视频行业甚至整个移动互联网已经处于领先地位，下面是我们在APK瘦身之路上的一些经验分享。</p>

<h2 id="toc_1">APK组成结构</h2>

<p>在使用一些很酷的方法，来减少应用程序的大小之前，必须先了解实际的APK文件格式。</p>

<p>简单地说，APK是一个包含文件/文件夹的压缩文件。作为一个开发者，我们可以很容易的通过打开压缩文件的方式查看到APK里面的内容。</p>

<h3 id="toc_2">7zip打开APK后的视图</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006945474877.png" alt="20171107151006945474877.png"/><figcaption>20171107151006945474877.png</figcaption></figure></p>

<h3 id="toc_3">各个文件或文件夹的功能</h3>

<table>
<thead>
<tr>
<th style="text-align: center">文件/文件夹</th>
<th style="text-align: center">作用/功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">res</td>
<td style="text-align: center">包含所有没有被编译到.arsc里面的资源文件</td>
</tr>
<tr>
<td style="text-align: center">lib</td>
<td style="text-align: center">引用库的文件夹</td>
</tr>
<tr>
<td style="text-align: center">assets</td>
<td style="text-align: center">assets文件夹相比于res文件夹，还有可能放字体文件、预置数据和web页面等,通过AssetManager访问</td>
</tr>
<tr>
<td style="text-align: center">META_INF</td>
<td style="text-align: center">存放的是签名信息，用来保证apk包的完整性和系统的安全。在生成一个APK的时候，会对所有的打包文件做一个校验计算，并把结果放在该目录下面</td>
</tr>
<tr>
<td style="text-align: center">classes.dex</td>
<td style="text-align: center">包含编译后的应用程序源码转化成的dex字节码。APK里面，可能会存在多个dex文件</td>
</tr>
<tr>
<td style="text-align: center">resources.arsc</td>
<td style="text-align: center">一些资源和标识符被编译和写入这个文件</td>
</tr>
<tr>
<td style="text-align: center">Androidmanifest.xml</td>
<td style="text-align: center">编译时，应用程序的AndroidManifest.xml被转化成二进制格式</td>
</tr>
</tbody>
</table>

<h3 id="toc_4">爱奇艺 APK各组成部分的占比情况</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006957888426.png" alt="20171107151006957888426.png"/><figcaption>20171107151006957888426.png</figcaption></figure></p>

<p>通过爱奇艺Android客户端APK组成的饼状图可以看出，APK里面占较大比重的是libs,res,dex这三块。</p>

<h2 id="toc_5">APK瘦身方案</h2>

<p>通过上面的分析，已经了解了APK的基本构成。下面我们就采用多种手段进行APK瘦身</p>

<h3 id="toc_6">针对整体优化</h3>

<h4 id="toc_7">插件化</h4>

<p>从应用功能扩张的角度看，APK包体积的增大是必然的，然而插件技术的出现很好的解决了这个问题。</p>

<p>通过分离应用中比较独立的模块，然后以插件的形式进行加载，比如爱奇艺Android客户端有很多的相对独立的功能，游戏，漫画，文学，电影票，应用商店等，都是通过插件的方式，从服务器下载，然后以插件的方式加载到我们的主工程。</p>

<h4 id="toc_8">7ZIP压缩</h4>

<p>一般情况下面，AS直接编译生成的APK里面，.arsc文件是没有进行任何压缩的，前文中APK组成部分的第一张图就可以看出。</p>

<p>下面，我们来解压APK，重新用7zip进行压缩，就会发现几乎所有文件都变小了，特别是.arsc文件，减小的比较多。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006967981234.png" alt="20171107151006967981234.png"/><figcaption>20171107151006967981234.png</figcaption></figure></p>

<p>对比7zip压缩前和压缩后APK里面文件的变化，可以看出通过7zip压缩，.arsc文件大概减小了2M多，其它文件/文件夹体积也减小了5%左右。</p>

<h4 id="toc_9">签名方式</h4>

<p>Google在Android7.0系统提供了新的apksigner签名工具，相比使用java提供的jarsigner签名工具，APK体积可以减小约5%（依赖文件数量）。</p>

<p>我们来看一下两种不同签名方式所带来的APK体积变化</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006973045110.png" alt="20171107151006973045110.png"/><figcaption>20171107151006973045110.png</figcaption></figure></p>

<p>第一个APK是未签名的，第二个是使用jarsigner签名的，第三个是使用apksigner签名生成。可以看出，使用apksigner签名比使用jarsigner签名生成的APK减小了1.1M。</p>

<p>那么再来看一下这两种APK签名后的文件大小差异在哪里</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006976254798.png" alt="20171107151006976254798.png"/><figcaption>20171107151006976254798.png</figcaption></figure></p>

<p>上图中间是未签名的APK,左边是jarsigner签名的,右边是apksigner签名的。</p>

<p>对比未签名的APK，用jarsigner签名工具签名，APK里面所有压缩后的文件和文件夹体积都增大了；而apksigner签名工具签名，除了META_INF文件夹增大了以外，其它文件和文件夹的大小都没有改变。</p>

<p>产生上述变化的原因是：jarsigner是针对每个文件进行了签名，然后针对签名后的文件计算摘要，并写入到META-INF文件夹下的MANIFEST.MF文件里面；而apksigner直接计算所有文件的摘要，写入MANIFEST.MF文件。</p>

<p>新的apksigner工具，已经集成到Android 7.0 SDK中了，使用方法可以参考<a href="https://developer.android.com/studio/command-line/apksigner.html">官方文档</a></p>

<h4 id="toc_10">瘦身前后APK对比</h4>

<p>在不同的版本通过不同方式进行APK瘦身的详情图，如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006982752667.png" alt="20171107151006982752667.png"/><figcaption>20171107151006982752667.png</figcaption></figure></p>

<p>插件化是2年前所做的优化，7zip压缩和签名方式都是最近的优化方案，并且通过jenkins自动化脚本实现的。</p>

<h3 id="toc_11">针对资源优化</h3>

<h4 id="toc_12">移除重复的资源</h4>

<h5 id="toc_13">一套资源</h5>

<p>Android在适配图片资源的时候，如果只有一套资源，低密度手机会缩放图片，高密度手机会拉伸图片。我们利用这个特性，存放一套资源图就可以供所有密度的手机使用。</p>

<p>综合考虑图片清晰度，静态大小和内存占用情况，一般采用xhdpi下的资源图片。</p>

<h5 id="toc_14">重复资源</h5>

<p>很多时候，随着工程的增大，以及开发人员的变动，有些资源文件名字不同，但是内容却完全相同。我们可以通过扫描文件的MD5值，找出名字不同，内容相同的图片并删除，做到图片不重复。</p>

<h4 id="toc_15">移除无用的资源</h4>

<p>由于项目的迭代以及UI改版等各种因素，会导致工程项目里面有许多无用的资源的存在，定期扫描处理无用资源。</p>

<h5 id="toc_16">通过Lint工具扫描工程资源</h5>

<p>当Lint工具扫描发现无用资源的时候，会输出如下的信息，就可以删除这种资源。</p>

<pre class="line-numbers"><code class="language-text">res/layout/preferences.xml: Warning: The resource R.layout.preferences appears
    to be unused [UnusedResources]
</code></pre>

<p>需要特别注意的是，需要确保不存在反射，资源拼接等访问这些资源，才可以安全的删除掉这些资源，从而减小资源个数。</p>

<h5 id="toc_17">通过Gradle参数配置</h5>

<p>如果工程比较大，由主工程和多个子工程组成的话，子工程里面也可能包含很多的无用资源。可以通过设置shrinkResources=true让Gradle移走无用的资源，否则默认情况下，Gradle编译只会移除无用代码，而不会关心无用资源。</p>

<pre class="line-numbers"><code class="language-text">android {
    // Other settings
 
    buildTypes {
            release {
                    minifyEnabled true
                    shrinkResources true
                    proguardFiles
getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}
</code></pre>

<p>需要特别注意的是shrinkResources依赖于minifyEnabled，必须和minifyEnabled一起用，即打开shrinkResources也必须打开minifyEnabled。</p>

<h5 id="toc_18">通过开源扫描工具</h5>

<p>大家可能会发现Lint不是非常好用，当工程里面存在反射，过滤结果非常麻烦。</p>

<p>所以我们实现了一个资源扫描的工具(<a href="https://github.com/zhuzhumouse/ScanUnusedResouce">https://github.com/zhuzhumouse/ScanUnusedResouce</a> )，可以过滤掉通过反射调用的资源。</p>

<p>原理就是把所有java和xml文件以字符串扫描到内存，然后拿到资源文件（xml,png,jpg等）名称做匹配查找，如果没有匹配到，该资源就是无用资源，可以直接删除。</p>

<p>该扫描工具可以解决反射调用的问题，但是不能解决资源拼接的问题，还有就是不能处理存在很多资源前缀相同的情况。</p>

<h4 id="toc_19">png图片压缩</h4>

<p>可以通过使用图片压缩工具对png图片进行压缩,压缩效果比较好的工具有：pngcrush,pngquant,zopflipng等，可以在保持图片质量的前提下，缩减图片的大小。</p>

<p>还可以通过网站对图片进行压缩，如比较有名的www.tinypng.com，该网站对上传的图片自动选择合适的压缩算法，压缩比比较高，但是只支持500张免费图片，更多图片处理是要收费的。</p>

<h4 id="toc_20">采用WebP格式</h4>

<p>WebP分为有损压缩，无损压缩以及包含透明度的有损压缩。</p>

<p>有损WebP是基于VP8视频编码中的预测编码方法来压缩图像数据；无损WebP基于使用不同的技术对图像数据进行转换；有损WebP(支持透明度)区别于有损WebP和无损WebP，这种编码允许对RGB频道的有损编码同时可对透明度频道进行无损编码。</p>

<p>目前4.2及以上的手机系统已经支持WebP的无损和有损压缩，但是4.0,4.1的手机系统只支持不含透明度的有损压缩。如果应用支持的最低版本(minSdkVersion)是4.0，那么就只能针对不含透明度的图片进行WebP转换了。</p>

<p>在Android Studio 2.3版本及以上，我们可以选中 drawable 和 mipmap 文件夹，右键后选择 convert to webp，将图片转为 WebP 格式。如果Android Stuido版本比较低的话，可以直接通过官方提供的cwebp工具，将png转换为WebP。</p>

<p><strong>下面是两张png转WebP的详情对比图</strong></p>

<table>
<thead>
<tr>
<th style="text-align: center">png (KB)</th>
<th style="text-align: center">WebP 75 (KB)</th>
<th style="text-align: center">WebP 90 (KB)</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">120</td>
<td style="text-align: center">2.7</td>
<td style="text-align: center">5.78</td>
</tr>
<tr>
<td style="text-align: center">10</td>
<td style="text-align: center">15</td>
<td style="text-align: center">27</td>
</tr>
</tbody>
</table>

<p>从以上两张样图的转换结果看，不是所有的图片都有高压缩比，有些图片压缩后反而会增大，比如第二张样图。WebP对色差比较小的图片，压缩比会比较高，任何一种压缩算法只能针对具有某种特点的图片进行压缩，没用万能压缩方法。</p>

<h4 id="toc_21">大背景图处理</h4>

<p>对清晰度要求高的大图片，采用单纯的压缩方法就不能满足UE的要求了，需要找到一种非压缩方式来解决这个问题。</p>

<p>纯色图+后台下载的方式很好的解决了这个问题，客户端先使用纯色图片，然后大图从后端下载，这样只是启动的前几次使用纯色图，以后都会使用大图。</p>

<h4 id="toc_22">Lottie动画库的使用</h4>

<p>动画，尤其是帧动画，一直都是相当占用资源的。现在可以通过Airbnb公司开源的Lottie动画库，直接用json文件来描述动画，然后直接加载绘制出来。</p>

<p><a href="https://github.com/airbnb/lottie-android">具体使用参考</a></p>

<h4 id="toc_23">其它资源策略</h4>

<ol>
<li>首先考虑能否不用图片，比如使用shape代码实现。</li>
<li>其次如果用图片的话，能否优先使用.9图来简化图片。</li>
<li>采用svg矢量图和VectorDrawable类来替换传统的图片。</li>
<li>如果图片只是旋转角度或者颜色不同，可以用代码实现变换。</li>
</ol>

<h4 id="toc_24">资源瘦身前后APK对比</h4>

<p>爱奇艺客户端使用到的资源优化方案详情如图所示</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151007036555517.png" alt="20171107151007036555517.png"/><figcaption>20171107151007036555517.png</figcaption></figure></p>

<p>目前爱奇艺客户端使用了这四种资源优化方式。</p>

<p>原来客户端xhdpi和xxhdpi下面有一部分重叠的资源，删除后包体积缩减了1M；移除无用资源是通过自己的扫描工具，获取无用资源列表，然后确认处理；pngquart压缩是打包过程中通过gradle自动化脚本实现的；WebP格式是通过python脚本，遍历查找不含透明度的图片，然后进行WebP转化替换原图片的。</p>

<h3 id="toc_25">针对代码优化</h3>

<p>上面已经详细的介绍了资源文件的优化方法，通过这些优化，包体积得到明显的缩减，下面我们再来讨论一下代码的优化。</p>

<h4 id="toc_26">代码混淆</h4>

<p>在gradle使用minifyEnabled进行Proguard混淆的配置，可大大减小APP大小：</p>

<pre class="line-numbers"><code class="language-text">android {
    buildTypes {
        release {
            minifyEnabled true
            proguardFile(&#39;groguard.cfg&#39;)
        }
    }
</code></pre>

<p>下面是代码混淆前后APK的详情</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151007057113444.png" alt="20171108151007057113444.png"/><figcaption>20171108151007057113444.png</figcaption></figure></p>

<p>尤其需要注意的是：在proguard中，是否保留符号表对APP的大小是有显著的影响的，可酌情不保留，但是建议尽量保留用于调试。</p>

<h4 id="toc_27">无用代码扫描</h4>

<p>同无用资源扫描方式一样，可以针对无用的代码进行扫描，这里需要关注的一点就是在插件里面通过反射的方法调用的主应用的一些类和方法是不能删除的。</p>

<p>也可以使用SonarQube扫描无用类，以及不同类里面的重复代码。</p>

<p><a href="https://github.com/SonarSource/sonarqube">详情请参考</a></p>

<h4 id="toc_28">剔除R文件</h4>

<p>随着项目中资源的增加，会发现生成的dex文件里面R.class文件越来越大。我们知道真正使用资源的地方都是以R.xxx.xxx这种方式访问的，而R.xxx.xx是对应于.arsc文件里面的一个常量值。arsc里面的内容具体如下：</p>

<h5 id="toc_29">字符串资源在.arsc文件里面的存储方式</h5>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151007068485270.png" alt="20171108151007068485270.png"/><figcaption>20171108151007068485270.png</figcaption></figure></p>

<h5 id="toc_30">Layout下面的Xml资源文件在.arsc文件里面的存储方式</h5>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151007070585423.png" alt="20171108151007070585423.png"/><figcaption>20171108151007070585423.png</figcaption></figure></p>

<p>通过这两张截图我们可以看出，直接用ID替换资源访问代码R.XXX.XXX，这样R.class文件就没有任何作用了，可以删除它，并且代码里面的资源访问字符串也变成了常量，两个方面都减小了dex的大小。</p>

<p>剔除R文件可以参考<a href="https://github.com/meili/ThinRPlugin">开源工具</a></p>

<h4 id="toc_31">注解替代枚举</h4>

<p>谷歌官方一直强烈推荐用注解替代枚举，一方面可以缩减包体积，另一方便可以节省内存开销。我们来对比一下，在使用注解和使用枚举两种情况下，生成的class文件内容。</p>

<p>枚举类型源码</p>

<pre class="line-numbers"><code class="language-java">public enum MarkViewType3{
    SIMPLE_TEXT_MARK,
    DO_LIKE_MARK,
    BOTTOM_BANNER1,
    BOTTOM_BANNER2,
    TL_GREY_BACKGROUND_RANK,
    /**
     *服务导航mark
     */
    SERVICENAVIRIGHTMARK,
    /**
     *搜索页热点事件，标题、评论、事件
     */
    BOTTOM_COMPOUND_TEXT_BANNER
}
</code></pre>

<p>编译生成dex后的class文件</p>

<pre class="line-numbers"><code class="language-java">public enum MarkViewType3
{
  static
  {
    DO_LIKE_MARK = new MarkViewType3(&quot;DO_LIKE_MARK&quot;, 1);
    BOTTOM_BANNER1 = new MarkViewType3(&quot;BOTTOM_BANNER1&quot;, 2);
    BOTTOM_BANNER2 = new MarkViewType3(&quot;BOTTOM_BANNER2&quot;, 3);
    TL_GREY_BACKGROUND_RANK = new MarkViewType3(&quot;TL_GREY_BACKGROUND_RANK&quot;, 4);
    SERVICENAVIRIGHTMARK = new MarkViewType3(&quot;SERVICENAVIRIGHTMARK&quot;, 5);
    BOTTOM_COMPOUND_TEXT_BANNER = new MarkViewType3(&quot;BOTTOM_COMPOUND_TEXT_BANNER&quot;, 6);
    $VALUES = new MarkViewType3[] { SIMPLE_TEXT_MARK, DO_LIKE_MARK, BOTTOM_BANNER1, BOTTOM_BANNER2, TL_GREY_BACKGROUND_RANK, SERVICENAVIRIGHTMARK, BOTTOM_COMPOUND_TEXT_BANNER };
  }
}
</code></pre>

<p>通过对比可以看到生成的class文件里面，每个变量都是一个对象，并且还有一个value对象数组。</p>

<p>注解的实现源码</p>

<pre class="line-numbers"><code class="language-java">public class MarkViewType1{
    public static final int SIMPLE_TEXT_MARK = 0;
    public static final int DO_LIKE_MARK = 1;
    public static final int BOTTOM_BANNER1 = 2;
    public static final int BOTTOM_BANNER2 = 3;
    public static final int TL_GREY_BACKGROUND_RANK = 4;
    /**
     *服务导航mark
     */
    public static final int SERVICENAVIRIGHTMARK = 5;
    /**
     *搜索页热点事件，标题、评论、事件
     */
    public static final int BOTTOM_COMPOUND_TEXT_BANNER = 6;
    @IntDef ({SIMPLE_TEXT_MARK, DO_LIKE_MARK, BOTTOM_BANNER1, BOTTOM_BANNER2, TL_GREY_BACKGROUND_RANK
            , SERVICENAVIRIGHTMARK, BOTTOM_COMPOUND_TEXT_BANNER})
    @Retention(RetentionPolicy.SOURCE)
    public @interface MarkViewType1Anno{
    }
}
</code></pre>

<p>生成的class文件</p>

<pre class="line-numbers"><code class="language-java">public class MarkViewType1
{
  public static final int BOTTOM_BANNER1 = 2;
  public static final int BOTTOM_BANNER2 = 3;
  public static final int BOTTOM_COMPOUND_TEXT_BANNER = 6;
  public static final int DO_LIKE_MARK = 1;
  public static final int SERVICENAVIRIGHTMARK = 5;
  public static final int SIMPLE_TEXT_MARK = 0;
  public static final int TL_GREY_BACKGROUND_RANK = 4;
 
  @Retention(RetentionPolicy.SOURCE)
  public static @interface MarkViewType1Anno
  {
  }
}
</code></pre>

<p>注解生成的class文件只是一些常量。</p>

<p>通过上面的代码对比可以看出，常量+注解的形式，一方面可以减小生成的class文件的字节数，另一方面可以减小内存开销。</p>

<h4 id="toc_32">代码瘦身前和瘦身后APK对比</h4>

<p>爱奇艺客户端代码优化详情如图所示</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151007085241950.png" alt="20171108151007085241950.png"/><figcaption>20171108151007085241950.png</figcaption></figure></p>

<p>由上图可以看出，代码混淆可以很大程度的减小包体积，尤其是引入了比较多点的第三方库的情况。所以打包的时候，应该开启代码混淆，以及资源混淆。</p>

<p>注解替代枚举，经过尝试，发现大量修改之后，对缩减包体积帮助不大，所以爱奇艺客户端没有采用该方案。</p>

<h3 id="toc_33">arsc文件优化</h3>

<p>在剔除R文件小节中，大家已经看到了.arsc文件内容格式。在整体优化小节中，已经对.arsc进行了比较大的优化，接下来分析一下其它优化方式。</p>

<p>可以采用混淆来缩减资源文件的名称，以及移除未使用的备用资源等方式来优化.arsc文件。如何移除未使用的备用资源，gradle里面</p>

<p>增加如下配置：</p>

<pre class="line-numbers"><code class="language-text">android {
    defaultConfig {
        ...
            resConfigs &quot;zh&quot;, &quot;zh_CN&quot;, &quot;zh_HK&quot;, &quot;zh_MO&quot;, &quot;zh_TW&quot;, &quot;en&quot;
    }
}
</code></pre>

<p>通过该方式，爱奇艺客户端包体积可以缩减100多KB。</p>

<h3 id="toc_34">lib目录优化</h3>

<p>只提供对主流架构的支持，比如arm，对于mips和x86架构可以考虑不提供支持，系统会自动提供相应的兼容。爱奇艺客户端只在armeabi下面放置了一套so库文件。</p>

<p>除了插件化，客户端还是用了RN的方案，从而引入了RN的so库。由于RN的so库资源比较大，有2M多，进而引入了RN的so库的插件化。通过so库的插件化，来缩减包体积。RN库的插件化，包体积就缩减了1M多。</p>

<h3 id="toc_35">包瘦身详情总结</h3>

<p>通过上面所有方式进行瘦身，APK变化详情，如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171108151007094932891.png" alt="20171108151007094932891.png"/><figcaption>20171108151007094932891.png</figcaption></figure></p>

<p>由上图可以看出，经过代码优化，资源优化，lib库优化，.arsc文件优化，及整体优化，包体积由54.2M缩减到28.2M。</p>

<h2 id="toc_36">瘦身过程中遇到的问题</h2>

<h3 id="toc_37">WebP支持问题</h3>

<p>WebP图片的转化过程中，一定要注意资源拼接的情况。</p>

<p>比如如果存在vip_1,vip_2,vip_3,vip_4,vip_5等五个资源，要么都转化成WebP,要么都不转，不能处理其中的一部分。</p>

<p>替换一些引导图的时候，一定要打包工具和客户端同时替换。如果客户端把引导图替换成了WebP格式，而打包的时候，由于不同步，该图片又被替换成png格式，就会导致资源加载不成功，进而程序崩溃。</p>

<h3 id="toc_38">签名方式</h3>

<p>使用apksigner签名工具前，必须先执行zipalign操作；而使用jarsigner签名工具则是先签名，然后再用zipalign优化。</p>

<h2 id="toc_39">小结</h2>

<p>目前爱奇艺Android客户端主要通过插件化、RN、签名方式、7zip压缩、保留一套资源、代码资源混淆、无用资源处理、剔除R文件、图片压缩等方式来缩减包体积，包体积整体缩减了20M多。</p>

<p>缩减包体积是一个长期的任务，未来还有很多事情需要做，比如定期扫描无用代码和资源资源、图片持续优化、矢量图、Lottie动画的大量使用等等，随着新技术的涌现，我们会有更多的方法去缩小包体积，使得应用更轻盈运行速度更快。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872129.html">
                
                  <h1>Android-轻松自制flyme悬浮球</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>去年用了一整年的MX4Pro，魅族留给我最大的印象就是悬浮球了（质量问题我就不说了），左右滑动切换应用、上拉返回桌面、下拉打开通知栏、轻触返回…，一切都那么丝滑。然而自从上半年换成了s7dege，我感觉怎么也习惯不了没有悬浮球的生活了。</p>

<p>三星自己也有一个类似于悬浮球的功能，不过太过复杂，不易用，悬浮球本来就该是一个一步操作的产品，看来三星在软件设计方面还是任重而道远。于是乎我便在各大应用市场上找悬浮球，把所有排名靠前的悬浮球应用都安装试了一下，最后终于让我找到了一款几乎和flyme悬浮球相仿的app。</p>

<p>这款app在我手机里呆了好几个月，是我手机里除了微信之外，唯一允许自启动的应用了。很感谢这款app的开发者，不仅没有任何广告，还非常好用，完美移植了flyme自带的悬浮球功能。</p>

<p>然而渐渐的，我便感觉到了一丝不舒服，那就是我每次安装了一个新app，打开后提示要赋予权限（存储、拍照）的时候，6.0的系统总会温馨的弹出一个框：</p>

<p>然后我就必须到设置页面，花半天找到悬浮球，关掉它的“可出现在顶部的应用程”权限，然后才能回到app，授予权限。最后，我还得再次跑到设置页面，再花半天找到悬浮球，打开它的“可出现在顶部的应用程”权限。朋友啊朋友，这种体验，一次就够了，然而硬是让我体验了N次啊！</p>

<p>然而有什么能难得倒程序员的呢？刚好这个周末在家无事，我决定按照自己的习惯，打造一个心目中最易用的悬浮球。</p>

<h2 id="toc_1">设计</h2>

<h3 id="toc_2">UI</h3>

<p>UI很简单，直接用sketch切了三个圆，一个是作为背景的灰色半透明的圆，一个是中心的小圆，另外还有一个默认隐藏的大圆。</p>

<h3 id="toc_3">功能</h3>

<p>因为自己的操作习惯是固定的，所以也就不需要给悬浮球添加自定义操作的功能了，直接将操作对应的功能写死即可。</p>

<ol>
<li>单击：返回</li>
<li>长按：移动悬浮球</li>
<li>左滑右滑：打开最近应用程序</li>
<li>上拉：返回桌面</li>
<li>下拉：</li>
</ol>

<p>这块我最先开始定义的很简单，就是下拉通知栏，但是经过一天的使用，我又给它加了一个功能，就是保持下拉状态1.5秒，将移除悬浮球。这样你便可以很简单的移除掉悬浮球了。</p>

<h2 id="toc_4">实现</h2>

<h3 id="toc_5">如何添加悬浮球到桌面</h3>

<p>这里首先要感谢郭霖大神的 《 Android桌面悬浮窗效果实现，仿360手机卫士悬浮窗效果》，这部分我参考了这篇文章，成功的将悬浮球添加到了桌面。</p>

<pre class="line-numbers"><code class="language-java">public static void addBallView(Context context) {
    if (mBallView == null) {
        WindowManager windowManager = getWindowManager(context);
        int screenWidth = windowManager.getDefaultDisplay().getWidth();
        int screenHeight = windowManager.getDefaultDisplay().getHeight();
        mBallView = new FloatBallView(context);
        LayoutParams params = new LayoutParams();
        params.x = screenWidth;
        params.y = screenHeight / 2;
        params.width = WindowManager.LayoutParams.WRAP_CONTENT;
        params.height = WindowManager.LayoutParams.WRAP_CONTENT;
        params.gravity = Gravity.LEFT | Gravity.TOP;
        params.type = LayoutParams.TYPE_PHONE;
        params.format = PixelFormat.RGBA_8888;
        params.flags = LayoutParams.FLAG_NOT_TOUCH_MODAL
                | LayoutParams.FLAG_NOT_FOCUSABLE;
        mBallView.setLayoutParams(params);
        windowManager.addView(mBallView, params);
    }
}
</code></pre>

<h3 id="toc_6">手势判断</h3>

<p>这是最重要的部分了，承担着悬浮球的主要功能。</p>

<h4 id="toc_7">手指按下时</h4>

<p>按下时，隐藏小球，展现大球，并记录按下位置和按下时间。</p>

<pre class="line-numbers"><code class="language-java">case MotionEvent.ACTION_DOWN:
       mIsTouching = true;
       mImgBall.setVisibility(INVISIBLE);
       mImgBigBall.setVisibility(VISIBLE);
       mLastDownTime = System.currentTimeMillis();
       mLastDownX = event.getX();
       mLastDownY = event.getY();
       postDelayed(new Runnable() {
               @Override
               public void run() {
                   if (isLongTouch()) {
                       mIsLongTouch = true;
                       mVibrator.vibrate(mPattern, -1);
                   }
             }
       }, LONG_CLICK_LIMIT);
       break;
</code></pre>

<p>代码最后的postDealy时干嘛使的呢？就是通过延迟300毫秒，判断是否是长按模式。如果目前还没有处于其他模式，则可判断为长按，并震动提醒。</p>

<h4 id="toc_8">手指移动时</h4>

<p>这时要判断是否是处于长按状态，如果是，那么进入MOVE模式，移动悬浮球，如果不是，则判断操作手势，即下拉还是上拉等其他手势。</p>

<pre class="line-numbers"><code class="language-java">case MotionEvent.ACTION_MOVE:
      if (!mIsLongTouch &amp;&amp; isTouchSlop(event)) {
              return true;
      }
      if (mIsLongTouch &amp;&amp; (mCurrentMode == MODE_NONE || mCurrentMode == MODE_MOVE)) {
              mLayoutParams.x = (int) (event.getRawX() - mOffsetToParent);
              mLayoutParams.y = (int) (event.getRawY() - mOffsetToParentY);
              mWindowManager.updateViewLayout(FloatBallView.this, mLayoutParams);
              mBigBallX = mImgBigBall.getX();
              mBigBallY = mImgBigBall.getY();
              mCurrentMode = MODE_MOVE;
      } else {
              doGesture(event);
      }
      break;
</code></pre>

<p>进行手势操作的代码如下，主要是根据当前坐标与按下时记录的坐标进行计算，判断手势，并更新大球位置。</p>

<pre class="line-numbers"><code class="language-java">private void doGesture(MotionEvent event) {
    float offsetX = event.getX() - mLastDownX;
    float offsetY = event.getY() - mLastDownY;

    if (Math.abs(offsetX) &lt; mTouchSlop &amp;&amp; Math.abs(offsetY) &lt; mTouchSlop) {
        return;
    }
    if (Math.abs(offsetX) &gt; Math.abs(offsetY)) {
        if (offsetX &gt; 0) {
            if (mCurrentMode == MODE_RIGHT) {
                return;
            }
            mCurrentMode = MODE_RIGHT;
            mImgBigBall.setX(mBigBallX + OFFSET);
            mImgBigBall.setY(mBigBallY);
        } else {
            if (mCurrentMode == MODE_LEFT) {
                return;
            }
            mCurrentMode = MODE_LEFT;
            mImgBigBall.setX(mBigBallX - OFFSET);
            mImgBigBall.setY(mBigBallY);
        }
    } else {
        if (offsetY &gt; 0) {
            if (mCurrentMode == MODE_DOWN || mCurrentMode == MODE_GONE) {
                return;
            }
            mCurrentMode = MODE_DOWN;
            mImgBigBall.setX(mBigBallX);
            mImgBigBall.setY(mBigBallY + OFFSET);

            //如果长时间保持下拉状态，将会触发移除悬浮球功能
            postDelayed(new Runnable() {
                @Override
                public void run() {
                    if (mCurrentMode == MODE_DOWN &amp;&amp; mIsTouching) {
                        toRemove();
                        mCurrentMode = MODE_GONE;
                    }
                }
            }, TO_APP_INDEX_LIMIT);
        } else {
            if (mCurrentMode == MODE_UP) {
                return;
            }
            mCurrentMode = MODE_UP;
            mImgBigBall.setX(mBigBallX);
            mImgBigBall.setY(mBigBallY - OFFSET);
        }
    }
}
</code></pre>

<h4 id="toc_9">手指抬起时</h4>

<p>手指抬起后，先要判断是否是长按模式，不是的话再判断是否是单击，都不是的话就根据当前状态触发对应功能。</p>

<pre class="line-numbers"><code class="language-java">case MotionEvent.ACTION_CANCEL:
case MotionEvent.ACTION_UP:
       mIsTouching = false;
       if (mIsLongTouch) {
           mIsLongTouch = false;
       } else if (isClick(event)) {
           AccessibilityUtil.doBack(mService);
       } else {
           doUp();
       }
       mImgBall.setVisibility(VISIBLE);
       mImgBigBall.setVisibility(INVISIBLE);
       mCurrentMode = MODE_NONE;
       break;
</code></pre>

<p>魅族小米请注意！试了魅族pro5，先点击start-&gt;进入辅助功能界面-&gt;点击无障碍-&gt;开启FloatBall辅助功能。接着还要干一件事，就是魅族自己给悬浮窗加了权限，必须进入设置-&gt;应用管理-&gt;已安装中找到floatball-&gt;权限管理-&gt;开启悬浮窗权限，小米应该也是。此处不想吐槽国产ROM</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872056.html">
                
                  <h1>Android-OOM案例分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在Android（Java）开发中，基本都会遇到java.lang.OutOfMemoryError（本文简称OOM），这种错误解决起来相对于一般的Exception或者Error都要难一些，主要是由于错误产生的root cause不是很显而易见。由于没有办法能够直接拿到用户的内存dump文件，如果错误发生在线上的版本，分析起来就会更加困难。本文从一个具体的案例切入，介绍OOM分析的思路及相关工具的使用。</p>

<h2 id="toc_0">案例背景</h2>

<p>在美团App 7.4~7.7版本期间，美食业务的OOM数量居高不下，远高于历史水平，主要都是DECODE本地的资源出错。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006844360459.png" alt="20171107151006844360459.png"/><figcaption>20171107151006844360459.png</figcaption></figure></p>

<p>图中OOM数量为各版本发版后第一个月的统计量，包含新发版本及历史版本。对比了同时期其他业务的情况，也有类似OOM。由于美食业务的访问量占美团App的比重较大，因此，OOM的数量相对其他业务也多一些。</p>

<p>思路方案</p>

<p>在问题较为严重的7.6~7.7版本期间，团队对OOM频现的原因有过各种猜测。笔者怀疑过是否是业务上某些修改引起的，例如头图尺寸变大，或者是由页面模块加载方式引起的等等。但这些与OOM问题出现的时间并不吻合。其次也怀疑过是否由某些ROM的Bug导致，但此推断缺乏有力的证据支撑。因此，要找到OOM的root cause，根本途径还是找到谁占的内存最多，然后再根据具体case具体分析，为什么占了这么多。</p>

<p>采集用户手机内存信息</p>

<p>要分析内存的占用，需要内存的dump文件，但是dump文件一般都比较大，让用户配合上传dump文件不合适。所以希望能够运行时采集一些内存的特征然后随着crash日志上报上来。当用户发生OOM时，dump出用户的内存，然后基于com.squareup.haha:haha:2.0.3分析，得到一些关键数据（内存占用最多的实例及所占比例等）。但这个方案很快就被证明是不可行的。主要基于下面几个原因：</p>

<p>需要引入新的库。<br/>
dump和分析内存都很耗时，效率难以接受。<br/>
OOM时内存已经几乎耗尽，再加载内存dump文件并分析会导致二次OOM，得不偿失。<br/>
模拟复现OOM</p>

<p>采集用户手机内存信息的方案不可行，那么只能采取复现用户场景的方式。由于发生OOM时，用户操作路径的不确定性，无法精确复现线上的OOM，因此采取模拟复现的方式，最终发生OOM时的栈信息基本一致即可。为了能够尽量模拟用户发生OOM的场景，需要基本条件基本一致，即用户使用的手机的各种相关参数。</p>

<p>挖掘OOM特征</p>

<p>分析7.4以来的OOM，列出发生OOM的机器的特征，主要是内存和分辨率，适当考虑其它因素例如系统版本。</p>

<table>
<thead>
<tr>
<th style="text-align: center">机型</th>
<th style="text-align: center">内存</th>
<th style="text-align: center">分辨率</th>
<th style="text-align: center">OS</th>
<th style="text-align: center">stack log</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">OPPO N1(T/W)</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.2.2</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">HM 2LTE-CMCC</td>
<td style="text-align: center">1G</td>
<td style="text-align: center">1280 * 720</td>
<td style="text-align: center">4.4.4</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Newman CM810</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.4.4</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">LGL22</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1830 * 1080</td>
<td style="text-align: center">4.2.2</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">OPPO X909</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.2.2</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Lenovo K900</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.2.2</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">GiONEE E6</td>
<td style="text-align: center">2G</td>
<td style="text-align: center">1920 * 1080</td>
<td style="text-align: center">4.2.1</td>
<td style="text-align: center">java.lang.OutOfMemoryError</td>
</tr>
<tr>
<td style="text-align: center">at android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
</tbody>
</table>

<p>这些特征可以总结为：内存一般，分辨率偏高，OOM的堆栈log基本一致。其中，OPPO N1(T/W)上所发生的OOM比重较高，约为65%，因此选定这款机器作为复现OOM的机器。</p>

<h3 id="toc_1">关键数据（内存dump文件）</h3>

<p>需要复现OOM然后获取内存dump。思路是采取内存压力测试，让问题暴露的快速且充分。具体方案为：</p>

<ul>
<li>选取图片资源多且较为复杂的页面，比如美食的POI详情页。</li>
<li>加载30次该页面，为了增加OOM的几率，30个POI页面的ID是不同的。</li>
</ul>

<p>OOM发生后，使用Android Studio自带的Android Monitor dump出HPROF文件，然后使用SDK中的hprof-conv（位于sdk_root/platform-tools）工具转换为标准的Java堆转储文件格式，这样可以使用MAT（Eclipse Memory Analyzer）继续分析。</p>

<p>切到histogram视图，按shadow heap降序排列。</p>

<p>选取byte数组，右击-&gt;list objects-&gt;with incoming references，降序排列可以看到有很多大小一致的byte[]实例。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006883926615.png" alt="20171107151006883926615.png"/><figcaption>20171107151006883926615.png</figcaption></figure></p>

<p>右击其中一个数组-&gt;Path to GC Roots-&gt; exclude xxx references</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006888292386.png" alt="20171107151006888292386.png"/><figcaption>20171107151006888292386.png</figcaption></figure></p>

<p>如上图所示，这些byte[]都是系统的EdgeEffect的drawable所持有，drawable对应的bitmap占用的空间为1566 * 406 * 4 = 2543184，与byte数组的大小一致。</p>

<p>再看另外一个：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006892587007.png" alt="20171107151006892587007.png"/><figcaption>20171107151006892587007.png</figcaption></figure></p>

<p>这些byte[]是被App的一个背景图所持有，如下图：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006895888632.png" alt="20171107151006895888632.png"/><figcaption>20171107151006895888632.png</figcaption></figure></p>

<p>通过ImageView的ID（如图）及build目录下的R.txt反查可知该ImageView的ID名称，即可知其设置的背景图的大小为720 * 200（xhdpi），加载到内存并考虑density，size刚好是1080 * 300 * 4 = 1296000，与byte数组大小一致。</p>

<h3 id="toc_2">数据分析</h3>

<p>为什么会出现这些大小一致的byte数组，或者说，为什么会创建多份EdgeEffect的drawable？查看EdgeEffect的源码（4.2.2）可知，其drawable成员也是通过<code>Resources.getDrawable</code>系统调用获取的。</p>

<pre class="line-numbers"><code class="language-java">/**
 * Construct a new EdgeEffect with a theme appropriate for the provided context.
 * @param context Context used to provide theming and resource information for the EdgeEffect
 */
public EdgeEffect(Context context) {
    final Resources res = context.getResources();
    mEdge = res.getDrawable(R.drawable.overscroll_edge);
    mGlow = res.getDrawable(R.drawable.overscroll_glow);

        ******

    mMinWidth = (int) (res.getDisplayMetrics().density * MIN_WIDTH + 0.5f);
    mInterpolator = new DecelerateInterpolator();
}
</code></pre>

<p>ImageView(View)获取background对应的drawable的过程类似。</p>

<pre class="line-numbers"><code class="language-text">for (int i = 0; i &lt; N; i++) {
    int attr = a.getIndex(i);
    switch (attr) {
        case com.android.internal.R.styleable.View_background:
            background = a.getDrawable(attr); // TypedArray.getDrawable
            break;
        ******
    }
}
</code></pre>

<p>不论是Resources.getDrawable还是TypedArray.getDrawable，最终都会调用Resources.loadDrawable。继续看<code>Resources.loadDrawable</code>的源码，发现的确是使用了缓存。对于同一个drawable资源，系统只会加载一次，之后都会从缓存去取。</p>

<p>既然drawable的加载机制并没有问题，那么drawable所在的缓存实例或者获取drawable的Resources实例是否是同一个呢？通过下面的代码，打印出每个Activity的Resources实例及Resources实例的drawable cache。</p>

<pre class="line-numbers"><code class="language-java">//noinspection unchecked
LongSparseArray&lt;WeakReference&lt;Drawable.ConstantState&gt;&gt; cache = (LongSparseArray&lt;WeakReference&lt;Drawable.ConstantState&gt;&gt;) Hack.into(Resources.class).field(&quot;mDrawableCache&quot;).get(getResources());
Object appCache = Hack.into(Resources.class).field(&quot;mDrawableCache&quot;).get(getApplication().getResources());
Log.e(&quot;oom&quot;, &quot;Resources: {application=&quot; + getApplication().getResources() + &quot;, activity=&quot; + getResources() + &quot;}&quot;);
Log.e(&quot;oom&quot;, &quot;Resources.mDrawableCache: {application=&quot; + appCache + &quot;, activity=&quot; + cache + &quot;}&quot;);
</code></pre>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006910770075.png" alt="20171107151006910770075.png"/><figcaption>20171107151006910770075.png</figcaption></figure></p>

<p>这也进一步解释了另外一个现象，即这些大小相同的数组的个数基本和启动Activity的数量成正比。</p>

<p>通过数据分析可知，这些drawable之所以存在多份，是因为其所在的Resources实例并不是同一个。进一步debug可知，Resources实例存在多个的原因是开启了标志位<code>sCompatVectorFromResourcesEnabled</code>。<br/>
虽然最终造成OOM突然增多的原因只是开启一个标志位，但是这也告诫大家阅读API文档的重要性，其实很多时候API的使用说明已经明确告知了使用的限制条件甚至风险。</p>

<p>7.8版本关闭了此标志，发版后第一个月的OOM数量（包含历史版本）为153，如下图。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171107151006915714253.png" alt="20171107151006915714253.png"/><figcaption>20171107151006915714253.png</figcaption></figure></p>

<p>其中新版本发生的OOM数量为22。</p>

<h2 id="toc_3">总结</h2>

<p>对于线上出现的OOM，如何分析和解决可以大致分为三个步骤：</p>

<ol>
<li>充分挖掘特征。在挖掘特征时，需要多方面考虑，此过程更多的是猜测怀疑，所以可能的方面都要考虑到，包括但不限于代码改动、机器特征、时间特征等，必要时还需要做一定的统计分析。</li>
<li>根据掌握的特征寻找稳定的复现的途径。一般需要做内存压力测试，这样比较容易达到OOM的临界值，只是简单的一些正常操作难以触发OOM。</li>
<li>获取可分析的数据（内存dump文件）。利用MAT分析dump文件，MAT可以方便的按照大小排序实例，可以查看某些实例到GC ROOT的路径。</li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872019.html">
                
                  <h1>Android-全面解析 Application类</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Applicaiton类在 Android开发中非常常见，可是你真的了解Applicaiton类吗？<br/><br/>
本文将全面解析Applicaiton类，包括特点、方法介绍、应用场景和具体使用，希望你们会喜欢。</p>

<h2 id="toc_1">目录</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171106150989787899330.png" alt="20171106150989787899330.png"/><figcaption>20171106150989787899330.png</figcaption></figure></p>

<h2 id="toc_2">定义</h2>

<ul>
<li>代表应用程序（即 Android App）的类，也属于Android中的一个系统组件</li>
<li>继承关系：继承自 ContextWarpper 类</li>
</ul>

<h2 id="toc_3">特点</h2>

<h3 id="toc_4">实例创建方式：单例模式</h3>

<ul>
<li>每个Android App运行时，会首先自动创建Application 类并实例化 Application 对象，且只有一个</li>
</ul>

<blockquote>
<p>即 Application类 是单例模式（singleton）类</p>
</blockquote>

<ul>
<li>也可通过 继承 Application 类自定义Application 类和实例</li>
</ul>

<h3 id="toc_5">实例形式：全局实例</h3>

<p>即不同的组件（如Activity、Service）都可获得Application对象且都是同一个对象</p>

<h3 id="toc_6">生命周期：等于 Android App 的生命周期</h3>

<p>Application 对象的生命周期是整个程序中最长的，即等于Android App的生命周期</p>

<h2 id="toc_7">方法介绍</h2>

<p>那么，该 Application 类有什么作用呢？下面，我将介绍Application 类的方法使用</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171106150989812673960.png" alt="20171106150989812673960.png"/><figcaption>20171106150989812673960.png</figcaption></figure></p>

<h3 id="toc_8">onCreate（）</h3>

<ul>
<li>调用时刻： Application 实例创建时调用</li>
</ul>

<blockquote>
<p>Android系统的入口是Application类的 onCreate（），默认为空实现</p>
</blockquote>

<ul>
<li>作用
<ul>
<li>初始化 应用程序级别 的资源，如全局对象、环境配置变量、图片资源初始化、推送服务的注册等<br/>
&gt; 注：请不要执行耗时操作，否则会拖慢应用程序启动速度</li>
<li>数据共享、数据缓存<br/>
设置全局共享数据，如全局共享变量、方法等</li>
</ul></li>
</ul>

<blockquote>
<p>注：这些共享数据只在应用程序的生命周期内有效，当该应用程序被杀死，这些数据也会被清空，所以只能存储一些具备 临时性的共享数据</p>
</blockquote>

<ul>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">// 复写方法需要在Application子类里实现

private static final String VALUE = &quot;Carson&quot;;
    // 初始化全局变量
    @Override
    public void onCreate()
    {
        super.onCreate();  
        VALUE = 1;
    }
}
</code></pre>

<h3 id="toc_9">registerComponentCallbacks（） &amp; unregisterComponentCallbacks（）</h3>

<ul>
<li>作用：注册和注销 ComponentCallbacks2回调接口</li>
</ul>

<blockquote>
<p>本质上是复写 ComponentCallbacks2回调接口里的方法从而实现更多的操作，具体下面会详细介绍</p>
</blockquote>

<ul>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">registerComponentCallbacks(new ComponentCallbacks2() {
// 接口里方法下面会继续介绍
            @Override
            public void onTrimMemory(int level) {

            }

            @Override
            public void onLowMemory() {

            }

            @Override
            public void onConfigurationChanged(Configuration newConfig) {

            }
        });
</code></pre>

<h3 id="toc_10">onTrimMemory（）</h3>

<ul>
<li>作用：通知 应用程序 当前内存使用情况（以内存级别进行识别）</li>
</ul>

<blockquote>
<p>Android 4.0 后提供的一个API</p>
</blockquote>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171106150989834178917.png" alt="20171106150989834178917.png"/><figcaption>20171106150989834178917.png</figcaption></figure></p>

<ul>
<li>应用场景：根据当前内存使用情况进行自身的内存资源的不同程度释放，以避免被系统直接杀掉 &amp; 优化应用程序的性能体验</li>
</ul>

<blockquote>
<ol>
<li>系统在内存不足时会按照LRU Cache中从低到高杀死进程；优先杀死占用内存较高的应用<br/></li>
<li>若应用占用内存较小 = 被杀死几率降低，从而快速启动（即热启动 = 启动速度快）</li>
<li>可回收的资源包括：
<ol>
<li>缓存，如文件缓存，图片缓存</li>
<li>动态生成 &amp; 添加的View</li>
</ol></li>
</ol>
</blockquote>

<p>典型的应用场景有两个：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017110615098984255098.png" alt="2017110615098984255098.png"/><figcaption>2017110615098984255098.png</figcaption></figure></p>

<ul>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">registerComponentCallbacks(new ComponentCallbacks2() {

@Override
  public void onTrimMemory(int level) {

  // Android系统会根据当前内存使用的情况，传入对应的级别
  // 下面以清除缓存为例子介绍
    super.onTrimMemory(level);
  .   if (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) {

        mPendingRequests.clear();
        mBitmapHolderCache.evictAll();
        mBitmapCache.evictAll();
    }

        });
</code></pre>

<ul>
<li>可回调对象 &amp; 对应方法</li>
</ul>

<pre class="line-numbers"><code class="language-java">Application.onTrimMemory()
Activity.onTrimMemory()
Fragment.OnTrimMemory()
Service.onTrimMemory()
ContentProvider.OnTrimMemory()
</code></pre>

<p><strong>特别注意</strong>：<code>onTrimMemory()</code>中的TRIM_MEMORY_UI_HIDDEN与onStop（）的关系</p>

<ul>
<li>onTrimMemory()中的TRIM_MEMORY_UI_HIDDEN的回调时刻：当应用程序中的所有UI组件全部不可见时</li>
<li>Activity的onStop（）回调时刻：当一个Activity完全不可见的时候</li>
<li>使用建议：
<ul>
<li>在 onStop（）中释放与 Activity相关的资源，如取消网络连接或者注销广播接收器等</li>
<li>在onTrimMemory()中的TRIM_MEMORY_UI_HIDDEN中释放与UI相关的资源，从而保证用户在使用应用程序过程中，UI相关的资源不需要重新加载，从而提升响应速度</li>
</ul></li>
</ul>

<blockquote>
<p>注：onTrimMemory的TRIM_MEMORY_UI_HIDDEN等级是在onStop（）方法之前调用的</p>
</blockquote>

<h3 id="toc_11">onLowMemory（）</h3>

<ul>
<li>作用：监听 Android系统整体内存较低时刻</li>
<li>调用时刻：Android系统整体内存较低时</li>
</ul>

<pre class="line-numbers"><code class="language-java">registerComponentCallbacks(new ComponentCallbacks2() {

  @Override
            public void onLowMemory() {

            }

        });
</code></pre>

<ul>
<li>应用场景：Android 4.0前 检测内存使用情况，从而避免被系统直接杀掉 &amp; 优化应用程序的性能体验</li>
</ul>

<blockquote>
<p>类似于 OnTrimMemory（）</p>
</blockquote>

<ul>
<li>特别注意：OnTrimMemory（） &amp; OnLowMemory（） 关系
<ol>
<li>OnTrimMemory（）是 OnLowMemory（） Android 4.0后的替代 API</li>
<li>OnLowMemory（） = OnTrimMemory（）中的TRIM_MEMORY_COMPLETE级别</li>
<li>若想兼容Android 4.0前，请使用OnLowMemory（）；否则直接使用OnTrimMemory（）即可</li>
</ol></li>
</ul>

<h3 id="toc_12">onConfigurationChanged（）</h3>

<ul>
<li>作用：监听 应用程序 配置信息的改变，如屏幕旋转等</li>
<li>调用时刻：应用程序配置信息 改变时调用</li>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">registerComponentCallbacks(new ComponentCallbacks2() {

            @Override
            public void onConfigurationChanged(Configuration newConfig) {
              ...
            }

        });
</code></pre>

<ul>
<li>该配置信息是指 ：Manifest.xml文件下的 Activity标签属性android:configChanges的值，如下：</li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;activity android:name=&quot;.MainActivity&quot;&gt;
      android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;
// 设置该配置属性会使 Activity在配置改变时不重启，只执行onConfigurationChanged（）
// 上述语句表明，设置该配置属性可使 Activity 在屏幕旋转时不重启
 &lt;/activity&gt;
</code></pre>

<h3 id="toc_13">registerActivityLifecycleCallbacks（） &amp; unregisterActivityLifecycleCallbacks（）</h3>

<ul>
<li>作用：注册 / 注销对 应用程序内 所有Activity的生命周期监听</li>
<li>调用时刻：当应用程序内 Activity生命周期发生变化时就会调用</li>
</ul>

<blockquote>
<p>实际上是调用registerActivityLifecycleCallbacks（）里 ActivityLifecycleCallbacks接口里的方法</p>
</blockquote>

<ul>
<li>具体使用</li>
</ul>

<pre class="line-numbers"><code class="language-java">// 实际上需要复写的是ActivityLifecycleCallbacks接口里的方法
registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {
            @Override
            public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
                Log.d(TAG,&quot;onActivityCreated: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivityStarted(Activity activity) {
                Log.d(TAG,&quot;onActivityStarted: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivityResumed(Activity activity) {
                Log.d(TAG,&quot;onActivityResumed: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivityPaused(Activity activity) {
                Log.d(TAG,&quot;onActivityPaused: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivityStopped(Activity activity) {
                Log.d(TAG, &quot;onActivityStopped: &quot; + activity.getLocalClassName());
            }

            @Override
            public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
            }

            @Override
            public void onActivityDestroyed(Activity activity) {
                Log.d(TAG,&quot;onActivityDestroyed: &quot; + activity.getLocalClassName());
            }
        });

&lt;-- 测试：把应用程序从前台切到后台再打开，看Activcity的变化 --&gt;
 onActivityPaused: MainActivity
 onActivityStopped: MainActivity
 onActivityStarted: MainActivity
 onActivityResumed: MainActivity
</code></pre>

<h3 id="toc_14">onTerminate（）</h3>

<p>调用时刻：应用程序结束时调用</p>

<blockquote>
<p>但该方法只用于Android仿真机测试，在Android产品机是不会调用的</p>
</blockquote>

<h2 id="toc_15">应用场景</h2>

<p>从Applicaiton类的方法可以看出，Applicaiton类的应用场景有：（已按优先级排序）</p>

<ul>
<li>初始化 应用程序级别 的资源，如全局对象、环境配置变量等</li>
<li>数据共享、数据缓存，如设置全局共享变量、方法等</li>
<li>获取应用程序当前的内存使用情况，及时释放资源，从而避免被系统杀死</li>
<li>监听 应用程序 配置信息的改变，如屏幕旋转等</li>
<li>监听应用程序内 所有Activity的生命周期</li>
</ul>

<h2 id="toc_16">具体使用</h2>

<ul>
<li>若需要复写实现上述方法，则需要自定义 Application类</li>
<li>具体过程如下</li>
</ul>

<p><strong>步骤1：新建Application子类</strong></p>

<p>即继承 Application 类</p>

<pre class="line-numbers"><code class="language-java">public class CarsonApplication extends Application
  {
    ...
    // 根据自身需求，并结合上述介绍的方法进行方法复写实现

    // 下面以onCreate()为例
  private static final String VALUE = &quot;Carson&quot;;
    // 初始化全局变量
    @Override
    public void onCreate()
    {
        super.onCreate();

        VALUE = 1;

    }

  }
</code></pre>

<p><strong>步骤2：配置自定义的Application子类</strong></p>

<p>在Manifest.xml文件中 <application>标签里进行配置</p>

<p>Manifest.xml</p>

<pre class="line-numbers"><code class="language-text">&lt;application

        android:name=&quot;.CarsonApplication&quot;
        // 此处自定义Application子类的名字 = CarsonApplication
    
&lt;/application&gt;
</code></pre>

<p><strong>步骤3：使用自定义的Application类实例</strong></p>

<pre class="line-numbers"><code class="language-java">private CarsonApplicaiton app;

// 只需要调用Activity.getApplication（） 或Context.getApplicationContext（）就可以获得一个Application对象
app = (CarsonApplication) getApplication();

// 然后再得到相应的成员变量 或方法 即可
app.exitApp();
</code></pre>

<p>至此，关于 Applicaiton 类已经讲解完毕。</p>

<h2 id="toc_17">总结</h2>

<p>我用一张图总结上述文章</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171106150989846698587.png" alt="20171106150989846698587.png"/><figcaption>20171106150989846698587.png</figcaption></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871939.html">
                
                  <h1>Android-底部Tab菜单栏</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android开发中使用底部菜单栏的频次非常高，主要的实现手段有以下：</p>

<ul>
<li>TabWidget</li>
<li>隐藏TabWidget，使用RadioGroup和RadioButton</li>
<li>FragmentTabHost</li>
<li>5.0以后的TabLayout</li>
<li>最近推出的 Bottom navigation</li>
</ul>

<p>今天带大家来探索下如何用Fragment+FragmentTabHost++ViewPager<br/>
实现底部菜单栏</p>

<h2 id="toc_1">总体设计思路</h2>

<ul>
<li>Fragment：存放不同选项的页面内容</li>
<li>FragmentTabHost：点击切换选项卡</li>
<li>ViewPager：实现页面的左右滑动效果</li>
</ul>

<h2 id="toc_2">概念介绍</h2>

<h3 id="toc_3">FragmentTabHost</h3>

<p>用于实现点击选项进行切换选项卡的自定义效果</p>

<blockquote>
<p>使用FragmentTabHost，就是先用TabHost“装着”Fragment，然后放进MainActivity里面</p>
</blockquote>

<h3 id="toc_4">ViewPager</h3>

<ul>
<li>定义<br/>
ViewPager是android扩展包v4包中的类</li>
</ul>

<p><code>android.support.v4.view.ViewPager</code></p>

<ul>
<li>作用<br/>
左右切换当前的view，实现滑动切换的效果。</li>
</ul>

<blockquote>
<p>注：<br/><br/>
1.ViewPager类直接继承了ViewGroup类，和LinearLayout等布局一样，都是一个容器，需要在里面添加我们想要显示的内容。<br/><br/>
2.ViewPager类需要PagerAdapter适配器类提供数据，与ListView类似<br/><br/>
3.Google官方建议ViewPager配合Fragment使用   </p>
</blockquote>

<h3 id="toc_5">Fragment</h3>

<ul>
<li>定义<br/>
Fragment是activity的界面中的一部分或一种行为</li>
</ul>

<blockquote>
<p>1.把Fragment认为模块化的一段activity<br/><br/>
2.它具有自己的生命周期，接收它自己的事件，并可以在activity运行时被添加或删除<br/><br/>
3.Fragment不能独立存在，它必须嵌入到activity中，而且Fragment的生命周期直接受所在的activity的影响。例如：当activity暂停时，它拥有的所有的Fragment们都暂停了，当activity销毁时，它拥有的所有Fragment们都被销毁。  </p>
</blockquote>

<ul>
<li>作用<br/>
主要是为了支持更动态、更灵活的界面设计（从3.0开始引入）</li>
</ul>

<h2 id="toc_6">实现步骤</h2>

<ol>
<li>在主xml布局里面定义一个FragmentTabHost控件</li>
<li>定义底部菜单栏布局</li>
<li>定义每个Fragment布局</li>
<li>定义每个Fragment的Java类</li>
<li>定义适配器以关联页卡和ViewPage</li>
<li>定义MainActivity（具体实现请看注释）</li>
</ol>

<h2 id="toc_7">工程文件目录</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171105150989723658930.png" alt="20171105150989723658930.png"/><figcaption>20171105150989723658930.png</figcaption></figure></p>

<h2 id="toc_8">具体实现实例</h2>

<h3 id="toc_9">步骤1：在主xml布局里面定义一个FragmentTabHost控件</h3>

<p>主xml布局：<strong>Main_tab_layout.xml</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;fill_parent&quot;
    android:layout_height=&quot;fill_parent&quot;
    android:orientation=&quot;vertical&quot; &gt;

    &lt;include layout=&quot;@layout/main_top&quot; /&gt;

    &lt;android.support.v4.view.ViewPager
        android:id=&quot;@+id/pager&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot; /&gt;&lt;!--装4个Fragment--&gt;

    &lt;FrameLayout
        android:visibility=&quot;gone&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;0dp&quot;
        android:layout_weight=&quot;1&quot; /&gt;

    &lt;!--定义FragmentTabHost控件--&gt;
    &lt;android.support.v4.app.FragmentTabHost
        android:id=&quot;@android:id/tabhost&quot;
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:background=&quot;@android:color/black&quot; &gt;&lt;!--装4个Fragment--&gt;

        &lt;FrameLayout
            android:id=&quot;@android:id/tabcontent&quot;
            android:layout_width=&quot;0dp&quot;
            android:layout_height=&quot;0dp&quot;
            android:layout_weight=&quot;0&quot; /&gt;&lt;!--装Tab的内容--&gt;
    &lt;/android.support.v4.app.FragmentTabHost&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<h3 id="toc_10">步骤2：定义底部菜单栏布局</h3>

<p><strong>tab_content.xml</strong></p>

<p>一般是图片在上，文字在下</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    
android:layout_width=&quot;match_parent&quot;    
android:layout_height=&quot;match_parent&quot;    
android:gravity=&quot;center&quot;   
android:orientation=&quot;vertical&quot;    
android:background=&quot;#ffffff&quot;&gt;    
&lt;ImageView        
android:id=&quot;@+id/tab_imageview&quot;        
android:layout_width=&quot;wrap_content&quot;        
android:layout_height=&quot;wrap_content&quot;        
/&gt;    
&lt;TextView        
android:id=&quot;@+id/tab_textview&quot;        
android:layout_width=&quot;wrap_content&quot;        
android:layout_height=&quot;wrap_content&quot;        
android:text=&quot;&quot;        
android:textColor=&quot;@drawable/selector_text_background&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<h3 id="toc_11">步骤3：定义Fragment布局</h3>

<p>fragment_item1.xml&amp;fragment_item2.xml</p>

<blockquote>
<p>这里使用两个选项，由于fragment_item1.xml与fragment_item2.xml相同，这里只贴出一个</p>
</blockquote>

<p><strong>fragment_item1.xml</strong></p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/textView1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;fragment1&quot;
        android:textSize=&quot;20sp&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre>

<h3 id="toc_12">步骤4： 定义每个Fragment的Java类</h3>

<blockquote>
<p>1.这里使用两个选项：Fragment1.java&amp;fragmen2.java<br/><br/>
2.由于Fragment1.java&amp;fragmen2.java相同，这里只贴出一个</p>
</blockquote>

<p><strong>Fragment1.java</strong></p>

<pre class="line-numbers"><code class="language-java">package com.example.carson_ho.tab_menu_demo;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

/**
 * Created by Carson_Ho on 16/5/23.
 */
public class Fragment1 extends Fragment

    {
        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_item1, null);
        return view;
    }
}
</code></pre>

<h3 id="toc_13">步骤5： 定义适配器关联页卡和ViewPage</h3>

<p><strong>MyFragmentAdapter.java</strong></p>

<pre class="line-numbers"><code class="language-java">package com.example.carson_ho.tab_menu_demo;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;

import java.util.List;

/**
 * Created by Carson_Ho on 16/5/23.
 */
public class MyFragmentAdapter {extends FragmentPagerAdapter

    {

        List&lt;Fragment&gt; list;



        public MyFragmentAdapter(FragmentManager fm,List&lt;Fragment&gt; list) {
        super(fm);
        this.list=list;
    }//写构造方法，方便赋值调用
        @Override
        public Fragment getItem(int arg0) {
        return list.get(arg0);
    }//根据Item的位置返回对应位置的Fragment，绑定item和Fragment

        @Override
        public int getCount() {
        return list.size();
    }//设置Item的数量

    }
</code></pre>

<h3 id="toc_14">步骤6： 定义MainActivity</h3>

<p>具体实现看注释<br/><br/>
<strong>MainActivity.java</strong></p>

<pre class="line-numbers"><code class="language-text">package com.example.carson_ho.tab_menu_demo;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentTabHost;
import android.support.v4.view.ViewPager;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TabHost;
import android.widget.TabWidget;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.List;

public class MainActivity extends FragmentActivity implements
        ViewPager.OnPageChangeListener, TabHost.OnTabChangeListener {

    private FragmentTabHost mTabHost;
    private LayoutInflater layoutInflater;
    private Class fragmentArray[] = { Fragment1.class, Fragment2.class };
    private int imageViewArray[] = { R.drawable.tab_home_btn, R.drawable.tab_view_btn };
    private String textViewArray[] = { &quot;首页&quot;, &quot;分类&quot;};
    private List&lt;Fragment&gt; list = new ArrayList&lt;Fragment&gt;();
    private ViewPager vp;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();//初始化控件
        initPage();//初始化页面
    }

    //    控件初始化控件
    private void initView() {
        vp = (ViewPager) findViewById(R.id.pager);

        /*实现OnPageChangeListener接口,目的是监听Tab选项卡的变化，然后通知ViewPager适配器切换界面*/
        /*简单来说,是为了让ViewPager滑动的时候能够带着底部菜单联动*/

        vp.addOnPageChangeListener(this);//设置页面切换时的监听器
        layoutInflater = LayoutInflater.from(this);//加载布局管理器

        /*实例化FragmentTabHost对象并进行绑定*/
        mTabHost = (FragmentTabHost) findViewById(android.R.id.tabhost);//绑定tahost
        mTabHost.setup(this, getSupportFragmentManager(), R.id.pager);//绑定viewpager

        /*实现setOnTabChangedListener接口,目的是为监听界面切换），然后实现TabHost里面图片文字的选中状态切换*/
        /*简单来说,是为了当点击下面菜单时,上面的ViewPager能滑动到对应的Fragment*/
        mTabHost.setOnTabChangedListener(this);

        int count = textViewArray.length;

        /*新建Tabspec选项卡并设置Tab菜单栏的内容和绑定对应的Fragment*/
        for (int i = 0; i &lt; count; i++) {
            // 给每个Tab按钮设置标签、图标和文字
            TabHost.TabSpec tabSpec = mTabHost.newTabSpec(textViewArray[i])
                    .setIndicator(getTabItemView(i));
            // 将Tab按钮添加进Tab选项卡中，并绑定Fragment
            mTabHost.addTab(tabSpec, fragmentArray[i], null);
            mTabHost.setTag(i);
            mTabHost.getTabWidget().getChildAt(i)
                    .setBackgroundResource(R.drawable.selector_tab_background);//设置Tab被选中的时候颜色改变
        }
    }

    /*初始化Fragment*/
    private void initPage() {
        Fragment1 fragment1 = new Fragment1();
        Fragment2 fragment2 = new Fragment2();

        list.add(fragment1);
        list.add(fragment2);

        //绑定Fragment适配器
        vp.setAdapter(new MyFragmentAdapter(getSupportFragmentManager(), list));
        mTabHost.getTabWidget().setDividerDrawable(null);
    }

    private View getTabItemView(int i) {
        //将xml布局转换为view对象
        View view = layoutInflater.inflate(R.layout.tab_content, null);
        //利用view对象，找到布局中的组件,并设置内容，然后返回视图
        ImageView mImageView = (ImageView) view
                .findViewById(R.id.tab_imageview);
        TextView mTextView = (TextView) view.findViewById(R.id.tab_textview);
        mImageView.setBackgroundResource(imageViewArray[i]);
        mTextView.setText(textViewArray[i]);
        return view;
    }


    @Override
    public void onPageScrollStateChanged(int arg0) {

    }//arg0 ==1的时候表示正在滑动，arg0==2的时候表示滑动完毕了，arg0==0的时候表示什么都没做，就是停在那。

    @Override
    public void onPageScrolled(int arg0, float arg1, int arg2) {

    }//表示在前一个页面滑动到后一个页面的时候，在前一个页面滑动前调用的方法

    @Override
    public void onPageSelected(int arg0) {//arg0是表示你当前选中的页面位置Postion，这事件是在你页面跳转完毕的时候调用的。
        TabWidget widget = mTabHost.getTabWidget();
        int oldFocusability = widget.getDescendantFocusability();
        widget.setDescendantFocusability(ViewGroup.FOCUS_BLOCK_DESCENDANTS);//设置View覆盖子类控件而直接获得焦点
        mTabHost.setCurrentTab(arg0);//根据位置Postion设置当前的Tab
        widget.setDescendantFocusability(oldFocusability);//设置取消分割线

    }

    @Override
    public void onTabChanged(String tabId) {//Tab改变的时候调用
        int position = mTabHost.getCurrentTab();
        vp.setCurrentItem(position);//把选中的Tab的位置赋给适配器，让它控制页面切换
    }

}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_1.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_3.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15580646892750.html">发布Android库至JCenter仓库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576631048737.html">单例模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576630121534.html">23种设计模式全面解析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873148.html">Android RecyclerView性能优化</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873102.html">Android 基础复习</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
