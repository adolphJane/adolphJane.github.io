<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15580646892750.html">
                
                  <h1>发布Android库至JCenter仓库</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">注册bintray账号</h2>

<p>此账号就是我们用来管理maven或者jcenter的控制台，注册地址为：<a href="https://bintray.com/signup/oss">https://bintray.com/signup/oss</a><br/>
注册地址一定要为这个，如果从官网进行注册，所找到的不是个人申请入口，而是组织申请入口。</p>

<h2 id="toc_1">创建Maven仓库</h2>

<p><figure><img src="media/15580646892750/15580770002473.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580770120071.jpg" alt="创建仓库"/><figcaption>创建仓库</figcaption></figure></p>

<h2 id="toc_2">创建库</h2>

<p>在对应仓库中创建一个包<br/>
<figure><img src="media/15580646892750/15580771556713.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580771660186.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580771781151.jpg" alt=""/></figure></p>

<h2 id="toc_3">创建library工程</h2>

<p><strong>注意：只有library工程才能上传成功</strong><br/>
建好之后，配置项目的build.gradle文件和module的build.gradle,项目的build.gradle文件配置如下，添加蓝色部分<code>classpath &#39;com.novoda:bintray-release:+&#39;</code><br/>
<figure><img src="media/15580646892750/15580653502262.jpg" alt=""/></figure></p>

<p>module的build.gradle文件配置如下，同样添加蓝色部分，其中publish部分，只有userOrg需要严格按照注册的bintray的用户名，其他的都是自己随意指定的</p>

<pre class="line-numbers"><code class="language-java">apply plugin: &#39;com.novoda.bintray-release&#39;
</code></pre>

<pre class="line-numbers"><code class="language-java">lintOptions {
    abortOnError false
}
</code></pre>

<pre class="line-numbers"><code class="language-java">publish {
    repoName = &#39;test&#39;           //远程仓库名字,不指明，默认是上传到maven
    userOrg = &#39;&#39;                //bintrary注册的用户名
    groupId = &#39;&#39;                //compile引用时的第一部分groupId
    artifactId = &#39;&#39;             //compile引用时的第二部分项目名
    publishVersion = &#39;&#39;         //compile引用时的第三部分版本号
    uploadName = &#39;&#39;             //展示名字
    desc = &#39;&#39;                   //项目描述
    website = &#39;&#39;                //项目网址，填写自己的github 项目网址，【验证时会用，填写能打开的项目网址】
    licences = [&#39;Apache-2.0&#39;]   //描述，填写licences
}
</code></pre>

<p><figure><img src="media/15580646892750/15580654925418.jpg" alt=""/></figure></p>

<p>配置部分基本完成，剩下的就是在命令行或gradlew命令来上传libray工程，命令如下</p>

<pre class="line-numbers"><code class="language-java">./gradlew clean build bintrayUpload -PbintrayUser=用户名 -PbintrayKey=API-Key -PdryRun=false
</code></pre>

<p>其中用户名就是bintray注册的用户名，API-Key在如下图示获取<br/>
<figure><img src="media/15580646892750/15580656233555.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580656377202.jpg" alt=""/></figure><br/>
之后就是等待执行结束，成功后AS控制台如下提示BUILD SUCCESSFUL in ...</p>

<h2 id="toc_4">查看bintray页面</h2>

<p>刷新bintray页面，就会发现在maven页面多了你的库了，此处表示已经上传到maven仓库了<br/>
<figure><img src="media/15580646892750/15580657436779.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580657539240.jpg" alt=""/></figure></p>

<h2 id="toc_5">如何使用Maven仓库的库</h2>

<p>点击进入自己的一个package<br/>
<figure><img src="media/15580646892750/15580657872626.jpg" alt=""/></figure></p>

<p>实战配置如下，我在其他工程处需要引用时，如果时maven方式，则如下<br/>
项目的根build.gradle<br/>
<figure><img src="media/15580646892750/15580658181998.jpg" alt=""/></figure></p>

<p>具体的module工程，需要添加compile，就是上图中的选择的Gradle方式，复制过来直接配置build.gradle就可以<br/>
<figure><img src="media/15580646892750/15580658387938.jpg" alt=""/></figure><br/>
重新同步下工程，就可以用你自己的库了。此处，大功告成！</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/5/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15576631048737.html">
                
                  <h1>单例模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">单例模式的意义</h2>

<p>单例模式是最简单的设计模式之一，属于创建模式，它提供了一种创建对象的方式，确保只有单个对象被创建。这种设计模式主要目的是使整个系统中只能出现一个类的实例，即一个类只有一个对象。</p>

<ul>
<li>优点
<ul>
<li>由于频繁使用对象，可以省略创建对象所花费的时间，尤其是对于重量级的对象而言，是很重要的。</li>
<li>由于不需要频繁的创建对象，所以GC的压力变轻了，不需要频繁的分配资源和释放资源。</li>
</ul></li>
<li>缺点
<ul>
<li>简单的单例模式设计都很简单，但是复杂的单例模式需要考虑线程安全等并发问题，引入了部分复杂度</li>
</ul></li>
</ul>

<h2 id="toc_1">单例模式的设计</h2>

<p>设计单例模式的时候需要考虑的集中因素</p>

<ul>
<li>线程安全</li>
<li>延迟加载</li>
<li>代码安全(防止序列化攻击，防止反射攻击)</li>
<li>性能因素</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">线程安全</th>
<th style="text-align: center">并发性能好</th>
<th style="text-align: center">可以延迟加载</th>
<th style="text-align: center">序列化/反序列化安全</th>
<th style="text-align: center">能抵御反射攻击</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">饿汉式</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">懒汉式-不加锁</td>
<td style="text-align: center"></td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">懒汉式-加锁的</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">DCL</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">静态内部类</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">枚举</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">饿汉模式</h2>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/5/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15576630121534.html">
                
                  <h1>23种设计模式全面解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	
                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2019/5/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207873148.html">
                
                  <h1>Android RecyclerView性能优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>近期由于项目中使用RecyclerView加载的数据数量较大，所以必须对RecyclerView进行优化。</p>

<h2 id="toc_1">数据处理和视图加载分离</h2>

<p>数据加载一般都是异步加载，有时候可能加载完数据就直接丢给VH进行处理。其实，数据的处理逻辑我们也应该放在异步处理，这样Adapter在notify change后，ViewHolder就可以简单无压力地做数据与视图的绑定逻辑。将数据处理逻辑与网络异步线程放在一起，粘在用户角度，最多就是网络刷新时间稍长一点。</p>

<h2 id="toc_2">数据优化</h2>

<ul>
<li>远端数据量较大时，我们采取分页拉取的方式，并对其进行缓存，提升二次加载熟读。</li>
<li>对于新增或者删除数据，通过<code>DiffUtil</code>来进行局部刷新数据，而不是一味地全局刷新数据。</li>
</ul>

<pre class="line-numbers"><code class="language-text">void onNewDataArrived(List&lt;News&gt; news) {
    List&lt;News&gt; oldNews = myAdapter.getItems();
    DiffResult result = DiffUtil.calculateDiff(new MyCallback(oldNews, news));
    myAdapter.setNews(news);
    result.dispatchUpdatesTo(myAdapter);
}
</code></pre>

<h2 id="toc_3">布局优化</h2>

<h3 id="toc_4">减少过渡绘制</h3>

<p>减少布局层级，可以考虑使用自定义 <code>View</code> 来减少层级，或者更合理地设置布局来减少层级</p>

<h3 id="toc_5">减少 xml 文件 inflate 时间</h3>

<p>这里的 <code>xml</code> 文件不仅包括 <code>layout</code> 的 <code>xml</code>，还包括 <code>drawable</code> 的 <code>xml</code>，<code>xml</code> 文件 <code>inflate</code> 出 <code>ItemView</code> 是通过耗时的 IO 操作，尤其当 <code>Item</code> 的复用几率很低的情况下，随着 <code>Type</code> 的增多，这种 <code>inflate</code> 带来的损耗是相当大的，此时我们可以用代码去生成布局，即 <code>new View()</code> 的方式，只要搞清楚 <code>xml</code> 中每个节点的属性对应的 <code>API</code> 即可。使用StaticLayout和DynamicLayout代替TextView，使用自定义View代替LayoutInflater.inflate(xml)文件</p>

<h3 id="toc_6">减少 View 对象的创建</h3>

<p>一个稍微复杂的 <code>Item</code> 会包含大量的 <code>View</code>，而大量的 <code>View</code> 的创建也会消耗大量时间，所以要尽可能简化 <code>ItemView</code>；设计 <code>ItemType</code> 时，对多 <code>ViewType</code> 能够共用的部分尽量设计成自定义 <code>View</code>，减少 <code>View</code> 的构造和嵌套。</p>

<h3 id="toc_7">Bitmap传递</h3>

<p>Android以OpenGL Texture的形式来展示bitmap，当bitmap第一次展示时，它会以width * height大小的Texture形式传递到GPU上，所以要保证bitmap的大小不会大于其展示大小，要知道上传过程是阻塞主线程的。一般传递一张1920 * 1080的Texture不会超过10ms。</p>

<h3 id="toc_8">对象分配和垃圾回收</h3>

<p>虽然Android 5.0上使用ART来减少GC停顿时间，但仍然会造成卡顿。尽量避免在循环内创建对象导致GC。要知道，创建对象需要分配内存，而这个时机会检查内存是否足够来决定需不需要进行GC。</p>

<h2 id="toc_9">预加载</h2>

<pre class="line-numbers"><code class="language-text">// 通过复写指定预加载的像素值。
LinearLayoutManager.getExtraLayoutSpace();
和

// 设置预加载itemview数目。
RecycleView.setItemViewCacheSize(size);
</code></pre>

<h2 id="toc_10">其他</h2>

<ul>
<li>升级 <code>RecycleView</code> 版本到 <code>25.1.0</code> 及以上使用 <code>Prefetch</code> 功能</li>
<li>如果 <code>Item</code> 高度是固定的话，可以使用 <code>RecyclerView.setHasFixedSize(true);</code> 来避免 <code>requestLayout</code> 浪费资源</li>
<li>设置 <code>RecyclerView.addOnScrollListener(listener);</code> 来对滑动过程中停止加载的操作</li>
<li>如果不要求动画，可以通过 <code>((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false);</code> 把默认动画关闭来提升效率</li>
<li>对 <code>TextView</code> 使用 <code>String.toUpperCase</code> 来替代 <code>android:textAllCaps=&quot;true&quot;</code></li>
<li>通过重写 <code>RecyclerView.onViewRecycled(holder)</code> 来回收资源</li>
<li>通过 <code>RecycleView.setItemViewCacheSize(size);</code> 来加大 <code>RecyclerView</code> 的缓存，用空间换时间来提高滚动的流畅性</li>
<li>如果多个 <code>RecycledView</code> 的 Adapter 是一样的，比如嵌套的 <code>RecyclerView</code> 中存在一样的 <code>Adapter</code>，可以通过设置 <code>RecyclerView.setRecycledViewPool(pool);</code> 来共用一个 <code>RecycledViewPool</code></li>
<li>对 <code>ItemView</code> 设置监听器，不要对每个 <code>Item</code> 都调用 <code>addXxListener</code>，应该大家公用一个 <code>XxListener</code>，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗</li>
<li>值相同避免再次刷新,TextView的text相同，就不需要再调用setText方法，对比的损耗往往小于绘制</li>
<li>通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示：</li>
</ul>

<pre class="line-numbers"><code class="language-text">new LinearLayoutManager(this) {
    @Override
    protected int getExtraLayoutSpace(RecyclerView.State state) {
        return size;
    }
};
</code></pre>

<h2 id="toc_11">参考</h2>

<p><a href="https://juejin.im/post/5baedbf05188255c596714ab?utm_source=gold_browser_extension">《RecyclerView 性能优化》</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207873102.html">
                
                  <h1>Android 基础复习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">AndroidManifest</h2>

<ul>
<li>uses-sdk 这个节点用于定义要想正确地运行应用程序，设备上必须具有的最低和最高SDK版本。</li>
<li>uses-configuration 指定应用程序支持的每个输入机制的组合。一般不需要，适合有特殊输入控制的游戏。</li>
<li>uses-feature Android可以在各种各样的硬件平台上运行。可以使用多个uses-feature节点来指定应用程序需要的每个硬件功能。这可以避免将应用程序安装到不包含必要的硬件功能的设备上。<uses-feature android:name="android.hardware.nfc">
<ul>
<li>音频 用于要求低延迟音频管道的应用程序</li>
<li>蓝牙 用于需要蓝牙传输的应用程序</li>
<li>摄像头 用于要求有摄像头的应用程序。还可以要求具有自动聚焦功能、闪光灯或前摄像头</li>
<li>位置 用于需要基于位置的服务的应用程序。还可以显式指定要求网络或GPS支持</li>
<li>麦克风 用于需要音频输入的应用程序</li>
<li>NFC 要求NFC支持</li>
<li>传感器 指定对任何潜在可用的硬件传感器的要求</li>
<li>电话服务 指定需要一般性的电话服务</li>
<li>触摸屏 指定应用程序需要的触摸屏类型</li>
<li>USB 用于需要支持USB host或accessory模式的应用程序</li>
<li>Wi-Fi 用于需要支持Wi-Fi网络的应用程序</li>
</ul></li>
<li>supports-screens 应用程序支持的屏幕</li>
<li>smallScreens 分辨率比传统的HVGA小的屏幕</li>
<li>normalScreens 用于指定典型的手机屏幕</li>
<li>largeScrees 比普通屏幕大的屏幕</li>
<li>xlargeScreens 比普通大屏幕更大的屏幕</li>
<li>requiresSmallestWidthDp 允许使用设备无关的像素指定支持的最小屏幕宽度</li>
<li>compatibleWidthLimitDp 指定一个上限，超出此值后应用程序可能无法扩展。使用该属性可以使系统在屏幕分辨率大于你指定的值得设备上启动兼容模式</li>
<li>largestWidthLimitDp 指定一个绝对上限。在屏幕分辨率大于你指定的值得设备上，这回导致系统强制应用程序在兼容模式下运行。</li>
<li>supports-texture 用于声明应用程序能够提供以一种特定的GL纹理压缩格式压缩的纹理资源。</li>
<li>uses-permission 声明应用程序所需要的权限，并告诉给用户。</li>
<li>permission 应用程序组件也可以创建权限来限制对共享应用程序组件的访问</li>
<li>instrumentation instrumentation类提供一个测试框架，用来在应用程序运行时测试应用程序组件。对于应用程序所创建的每一个测试类，都需要创建一个新的节点。</li>
<li>application 一个Manifest只能包含一个application节点。它使用各种属性来指定应用程序的各种元数据。包含了Activity、Service、Content Provider和Broadcst Receiver节点的容器。
<ul>
<li>activity 应用程序内的每一个Activity都要求有一个activity标签
<ul>
<li>运行时配置更改添加(android:configChanges属性)，添加该属性可以阻止由于特定配置改变而造成的重启，并会触发Activity中的<code>onConfigurationChanged</code>处理程序。可以通过重写这个方法来处理配置的改变，并使用传入Configuration对象来确定新的配置值。
<ul>
<li>mcc和mnc 检测到SIM，并且预支关联的国家或网络的代码发生了变化</li>
<li>locale 用于改变了设备的语言设置</li>
<li>keyboardHidden 显示或者隐藏了键盘、d-pad或其他输入设置</li>
<li>keyboard 对键盘的类型进行了更改。</li>
<li>fontScale 用户修改了首选的字体大小</li>
<li>uiMode 整体UI模式发生了变化。</li>
<li>orientation 屏幕在纵向和横向之间进行了旋转</li>
<li>screenLayout 屏幕布局发生了变化，比如激活了另外一个屏幕</li>
<li>screenSize 当可用屏幕尺寸改变</li>
<li>smallestScreenSize当物理屏幕尺寸改变</li>
</ul></li>
</ul></li>
<li>service</li>
<li>provider 指定应用程序中的每一个Content Provider。</li>
<li>receiver 注册Broadcast Receiver。</li>
<li>uses-library 用于指定应用程序需要的共享库。</li>
</ul></li>
</ul>

<h2 id="toc_1">应用程序的进程</h2>

<ul>
<li>Active 进程 指那些有组件正在和用户进行交互的应用程序的进程。只有在最后关头才会被系统终止回收。
<ul>
<li>处于活动状态的Activity</li>
<li>正在执行onReceive事件处理程序的Broadcast Receiver</li>
<li>正在执行onStart、onCreate或者onDestroy事件处理程序的Service</li>
<li>正在运行、且已被标记为在前台运行的Service</li>
</ul></li>
<li>可见进程 当一个Activity被部分遮挡时就会出现这种情况</li>
<li>启动Service进程 已经启动的Service进程。因为后台Service没有直接和用户交互，所以优先级比可见Activity或前台Service低一些。当系统终止一个运行的Service后，会在资源可用时尝试重新启动Service</li>
<li>后台进程 不可见、并且没有任何正在运行的Service的Activity进程。</li>
<li>空进程 为了提高系统整体性能。Android经常在应用程序的生存期结束之后仍然把它们保存在内存中。Android通过维护这个缓存来减少应用程序被再次启动时的启动时间。通常这些进程会根据需要被定期终止</li>
</ul>

<h2 id="toc_2">Application</h2>

<p>每次应用程序运行时，应用程序的Application类都保持实例化状态。与Activity不同，配置改变并不会导致应用程序重启。</p>

<p>扩展Application类，可以完成以下3项工作</p>

<ul>
<li>在Android运行时广播的应用程序级事件做出响应</li>
<li>在应用程序组件之间传递对象</li>
<li>管理和维护多个应用程序组件使用的资源</li>
</ul>

<h3 id="toc_3">重写应用程序的生命周期事件</h3>

<ul>
<li>onCreate 在创建应用程序时调用。可以重写这个方法来实例化应用程序单态，以及创建和实例化任何应用程序状态变量或共享资源</li>
<li>onLowMemory 当系统处于资源匮乏的状态时，具有良好行为的应用程序可以释放额外的内存。这个方法一般只会在后台进程已经终止，但是前台应用程序仍然缺少内存时调用。可以重写这个处理程序来清空缓存或释放不必要的资源</li>
<li>onTrimMemory 当运行时决定当前应用程序应该尝试减少其内存开销时(通常在它进入后台时)调用</li>
<li>onConfigurationChanged 与Activity不同，在配置改变时，应用程序对象不会被终止或重启个。如果应用程序使用的值依赖于特定的配置，则重写这个方法来重新加载这些值，或者在应用程序级别处理配置改变</li>
</ul>

<h2 id="toc_4">Activity</h2>

<h3 id="toc_5">生命周期</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20180813153414769138796.png" alt="20180813153414769138796.png"/><figcaption>20180813153414769138796.png</figcaption></figure></p>

<ul>
<li>onCreate() ———— 当活动首次被创建时调用。此时Activity还在后台，不可见。用于创建和实例化将在应用程序中使用的对象。</li>
<li>onRestoreInstanceState() ———— 用于恢复UI状态</li>
<li>onStart() ———— 当活动对用户可见时调用，启动动画、线程、传感器监听器、GPS查找、定时器、Service或其他用于更新用户界面的进程，注册Broadcast Receiver。</li>
<li>onResume() ————  当活动与用户开始交互时调用。启动当活动位于前台时需要运行的任何服务或代码。</li>
<li>onSaveInstanceState() ———— 把UI状态改变保存到savedInstanceState</li>
<li>onPause() ———— 当当前活动被暂停并恢复以前的活动时调用。停止当活动不在前台时不需要运行的任何服务或代码。</li>
<li>onStop() ———— 当活动不再对用户可见时调用，用来暂停或停止动画、线程、传感器监听器、GPS查找、定时器、Service或其他用于更新用户界面的进程，注销Broadcast Receiver。</li>
<li>onDestroy() ———— 当活动被系统销毁时调用。在活动销毁前释放资源。</li>
<li>onRestart() ———— 在活动已停止并要再次启动时调用。</li>
</ul>

<h4 id="toc_6">Activity的状态</h4>

<ul>
<li>活动状态 当一个Activity位于栈顶的时候，它是可见的、具有焦点的前台Activity，这时它可以接收用户输入。Android将会不惜一切代价来保持它处于活动状态，并根据需要来销毁栈下面部分的Activity，以保证这个Activity拥有它所需要的资源。</li>
<li>暂停状态 当Activity是可见的，但是没有获得焦点，此时它就处于暂停状态。</li>
<li>停止状态 当一个Activity不可见的时候，它就处于停止状态。此时，Activity仍然会停留在内存中，保存所有的状态信息，然而当系统的其他地方要求使用内存的时候，它们就会成为被终止的首要候选对象。</li>
<li>非活动状态 当一个Activity被终止之后，在启动之前它就处于非活动状态。处于非活动状态的Activity已经从Activity栈中移除了。<br/>
### 管理屏幕发生变化<br/>
当设备的屏幕方向发生改变时，会把活动销毁，并重建。所以需要确保采取必要的措施来保持方向改变之前活动的状态。在包含视图的活动被销毁时，只有那些在活动中被命名的视图(android:id属性)才能保持它们的状态。(例:命名过id的EditText视图中的任何文本都会在活动创建时自动恢复，而没有命名id的EditText视图，不会保持视图中当前所含文本)</li>
</ul>

<p>当终止一个活动，将在以下两个方法中保存数据:</p>

<ul>
<li>onPause() ———— 利用数据库、内部或外部的文件存储器存储持久化数据。</li>
<li>onSaveInstanceState() ———— 提供Bundle对象作为一个参数，可以用它保存活动的状态。可以在onCreate或随后的onRestoreInstanceState()方法中恢复Bundle中保存的状态。但通过Bundle对象保存状态信息具有局限性，无法保存更复杂的数据结构。</li>
<li>onRetainNonConfigurationInstance()方法。当一个活动由于配置改变将要销毁时会触发这一方法。可以在方法中返回保存当前的数据。并在onCreate()使用getLastNonCOnfigurationInstance()方法进行提取。</li>
</ul>

<h4 id="toc_7">检测方向改变</h4>

<pre class="line-numbers"><code class="language-text">WindowManager wm = getWindowManager();
Display dp = wm.getDefaultDisplay();
if (dp.getWidth() &gt; dp.getHeight()) {
    Log.d(&quot;Orientation&quot;,&quot;Landscape mode&quot;);
} else {
    Log.d(&quot;Orientation&quot;,&quot;Portrait mode&quot;);
}
</code></pre>

<h4 id="toc_8">控制活动方向</h4>

<ul>
<li>Activity类 <code>setRequestOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE/ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)</code></li>
<li>AndroidManifest.xml中<activity>元素上使用<code>android:screenOrientation</code>属性。</li>
</ul>

<h3 id="toc_9">侦听用户界面通知</h3>

<ul>
<li>onKeyDown 当一个按键按下并且没有被活动中的任何视图处理时调用</li>
<li>onKeyUp 当一个键被释放并且没有被活动中的任何视图处理时调用</li>
<li>onMenuItemSelected 当用户选择了面板的菜单时调用</li>
<li>onMenuOpened 当用户打开了面板的菜单时调用</li>
</ul>

<h2 id="toc_10">Fragment</h2>

<h3 id="toc_11">生命周期</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20180813153415635189141.png" alt="20180813153415635189141.png"/><figcaption>20180813153415635189141.png</figcaption></figure></p>

<ul>
<li>onAttached() ———— 当碎片与活动建立关联时调用</li>
<li>onCreateView() ———— 用于创建碎片的视图</li>
<li>onActivityCreated() ———— 当活动的onCreate()方法被返回时调用</li>
<li>onDestroyView() ———— 当碎片的视图被移除时调用</li>
<li>onDetach() ———— 当碎片与活动的关联被移除时调用</li>
</ul>

<h2 id="toc_12">Intent</h2>

<p>Intent是一种消息传递机制，可以在应用程序内使用，也可以在应用程序间使用。</p>

<ul>
<li>使用类名显式启动一个特定的Service或Activity</li>
<li>启动Activity或Service来执行一个动作的Intent，通常需要使用特定的数据，或者对特定的数据执行动作</li>
<li>广播某个事件已经发生</li>
</ul>

<h3 id="toc_13">显式启动新Activity</h3>

<p>要显式地选择要启动的Activity类，可以创建一个新的Intent来指定当前Activity的上下文以及要启动的Activity的类，然后把这个Intent传递给startActivity</p>

<pre class="line-numbers"><code class="language-text">Intent intent = new Intent(MyActivity.this,MyOtherActivity.class);
startActivity(intent);
</code></pre>

<p>在调用startActivity之后，新的Activity将会被创建、启动和恢复运行，他会移动到Activity栈的顶部<br/><br/>
调用新的Activity的finish或按下设备的返回按钮将关闭该Activity，并把它从栈中移除。开发人员可以通过调用startActivity导航到其他Activity。每次调用startActivity时，会有一个新的Activity添加到栈中，而按下后退按钮则依次删除每个Activity。</p>

<h3 id="toc_14">隐式的Intent</h3>

<p>隐式的Intent提供了一种机制，可以让匿名的应用程序组件响应动作请求。这意味着可以要求系统启动一个可执行给定动作的Activity，而不必知道需要启动哪个应用程序或Activity。<br/><br/>
当构建一个新的隐式的Intent时，需要指定一个要执行的动作，也可以提供执行那个动作需要的数据的URI。还可以通过向Intent添加extra来向目标Activity发送额外的数据。<br/><br/>
Extra是一种向Intent附加基本类型值得机制。可以在热河Intent上使用重载后的putExtra方法来附加一个新的名称/值对，以后在启动的Activity中使用对应的getExtra方法来检索它。Extra作为一个Bundle对象存储在Intent中，可以使用getExtras方法检索。如果多个Activity都能够执行指定的动作，则会向用户呈现各种选项。</p>

<h3 id="toc_15">使用Intent调用内置应用程序</h3>

<p><strong>打开Web浏览器</strong>  </p>

<pre class="line-numbers"><code class="language-text">Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(&quot;http://www.amazon.com&quot;));
startActivity(i);
</code></pre>

<p><strong>打开拨号界面</strong></p>

<pre class="line-numbers"><code class="language-text">Intent i = new Intent(android.content.Intent.ACTION_DIAL,Uri.parse(&quot;tel:+651234567&quot;));
startActivity(i);
</code></pre>

<p><strong>打开Maps应用</strong></p>

<pre class="line-numbers"><code class="language-text">Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(&quot;geo:37.827500,-122.481670&quot;));
startActivity(i);
</code></pre>

<p><strong>打开联系人列表</strong></p>

<pre class="line-numbers"><code class="language-text">Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(&quot;content://contacts&quot;));
startActivity(i);
</code></pre>

<p><strong>选择联系人</strong></p>

<pre class="line-numbers"><code class="language-text">Intent i = new Intent(android.content.Intent.ACTION_PICK,Uri.parse(&quot;content://contacts&quot;));
startActivity(i);
</code></pre>

<p><strong>注意</strong>: 当有多个活动匹配Intent对象时会出现Complete action using对话框，通过使用Intent类的createChooser()方法来对该对话框进行自定义。</p>

<pre class="line-numbers"><code class="language-text">Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(&quot;http://www.amazon&quot;));
startActivity(Intent.createChooser(i,&quot;Open URL Using...&quot;));
</code></pre>

<p>使用了createChooser()方法将对话框的标题改为“Open URL using...”，没有Use by default for this action选项，的另一个好处是当没有活动与您的Intent对象匹配时，不会崩溃。</p>

<h3 id="toc_16">确定Intent能否解析</h3>

<p>通过调用Intent的resolveActivity方法，并向该方法传入包管理器，可以对包管理器进行查询，确定是否有Activity能够启动以响应该Intent。</p>

<pre class="line-numbers"><code class="language-text">//Create the impliciy Intent to use to start a new Activity
Intent intent = new Intent(Intent.ACTION_DIAL,Uri.parse(&quot;tel:555-2368&quot;));

//Check if an Activity exists to perform this action
PackageManager pm = getPackageManager();
ComponentName cn = intent.resolveActivity(pm);
if (cn == null) {
    //If there is no Activity available to perform the action
    //Check to see if the Google Play Store is available
    Uri marketUri = Uri.parse(&quot;market://search?q=pname:com.myapp.packagename&quot;);
    Intent marketIntent = new Intent(Intent.ACTION_VIEW).setData(marketUri);
    
    //If the Google Play Store is available,use it to download an application
    //capable of performing the required action.Otherwise log an error.
    if (marketIntent.resolveActivity(pm) != null) {
        startActivity(marketIntent);
    } else {
        Log.d(TAG,&quot;Market client not available&quot;);
    }
} else {
    startActivity(intent);
}

</code></pre>

<p>如果没有找到Activity，可以选择禁用相关的功能，也可以引导用户找到Google Play Store中合适的应用程序。要注意Google Play并不是在所有的设备和模拟器上都可用的，所以最好也对此进行检查。</p>

<h3 id="toc_17">原生Android动作</h3>

<table>
<thead>
<tr>
<th style="text-align: left">Action</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">输入</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">ACTION_ALL_APPS</td>
<td style="text-align: left">打开一个列出所有已安装应用程序的Activity。通常，此操作由启动器处理</td>
<td style="text-align: left">无</td>
</tr>
<tr>
<td style="text-align: left">ACTION_ANSWER</td>
<td style="text-align: left">打开一个处理来电的Activity，通常这个动作是由本地电话拨号程序进行处理的。</td>
<td style="text-align: left">无</td>
</tr>
<tr>
<td style="text-align: left">ACTION_BUG_REPORT</td>
<td style="text-align: left">显示一个可以报告BUG的Activity，通常由本地bug报告机制处理。</td>
<td style="text-align: left">无</td>
</tr>
<tr>
<td style="text-align: left">ACTION_CALL</td>
<td style="text-align: left">打开一个电话拨号程序，并立即使用Intent的数据URI所提供的号码拨打一个电话,直接进入系统拨打电话界面，开始拨打电话。此动作只应用于替代本地拨号程序的Activity。大多数情况下，使用ACTION_DIAL是一种更好的方式。</td>
<td style="text-align: left">tel:// +phone number</td>
</tr>
<tr>
<td style="text-align: left">ACTION_CALL_BUTTON</td>
<td style="text-align: left">当用户按下硬件的“拨打按钮”时触发，通常会调用拨号Activity</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_DELETE</td>
<td style="text-align: left">启动一个Activity，允许删除Intent的数据URI中指定的数据</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_DIAL</td>
<td style="text-align: left">打开一个拨号程序，要拨打的号码由Intent的数据URI预先提供,直接进入系统拨号界面。默认情况下，这是由本地Android电话拨号程序进行处理的。拨号程序可以规范化大部分号码样式。</td>
<td style="text-align: left">tel: +phone number</td>
</tr>
<tr>
<td style="text-align: left">ACTION_EDIT</td>
<td style="text-align: left">请求一个Activity，要求该Activity可以编辑Intent的数据URI中的数据</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_INSERT</td>
<td style="text-align: left">打开一个能够在Intent的数据URI指定的游标处插入新项的Activity，当作为子Activity调用的时候，它应该返回一个指向新插入项的URI</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_PICK</td>
<td style="text-align: left">启动一个子Activity，它可以让你从Intent的数据URI指定的Content Provider中选择一个项。当关闭的时候，它应该返回所选择的项的URI。启动的Activity与选择的数据有关，例如，传递 content://contacts/people将会调用本地联系人列表</td>
<td style="text-align: left">content://contacts/people</td>
</tr>
<tr>
<td style="text-align: left">ACTION_SEARCH</td>
<td style="text-align: left">通常用于启动特定的搜索Activity。如果没有在特定的Activity上触发它，就会提示用户从所有支持搜索的应用程序中做出选择。可以使用SearchManager.QUERY键把搜索词作为一个Intent的extra中的字符串来提供</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_SEARCH_LONG_PRESS</td>
<td style="text-align: left">允许截获对硬件搜索键的长按操作。通常由系统处理，以提供语音搜索的快捷方式。</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_SENDTO</td>
<td style="text-align: left">启动一个Activity来向Intent的数据URI所指定的联系人发送一条信息</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_SEND</td>
<td style="text-align: left">启动一个Activity,该Activity会发送Intent中指定的数据。接收人需要由解析的Activity来选择。使用setType可以设置要传输的数据的MIME类型。数据本身应该根据它的类型，使用EXTRA_TEXT或者EXTRA_STREAM存储为extra。对于E-mail，本地应用程序也可以使用EXTRA_EMAIL、EXTRA_CC、EXTRA_BCC和EXTRA_SUBJECT键来接收extra。应该只使用ACTION_SEND动作向远程接收人发送数据</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_VIEW</td>
<td style="text-align: left">这是最常用的通用动作。视图要求以最合适的方式查看Intent的数据URI中提供的数据。不同的应用程序将会根据所提供的数据的URI模式来处理视图请求。一般情况下，http:地址将会打开浏览器，tel:地址将会打开拨号程序以拨打该号码，geo:地址会在Google地图应用程序中显示出来，而联系人将会在联系人管理器中显示出来</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ACTION_WEB_SEARCH</td>
<td style="text-align: left">打开一个浏览器，根据SearchManager.QUERY键提供的查询执行Web搜索</td>
<td style="text-align: left"></td>
</tr>
</tbody>
</table>

<h3 id="toc_18">使用Intent广播事件</h3>

<p>Broadcast Intent用于向监听器通知系统的应用程序或应用程序事件，从而可以扩展应用程序间的事件驱动的编程模型。<br/><br/>
Broadcast Intent可以使应用程序更加开放，通过使用Intent来广播一个事件，可以在不用修改原始的应用程序的情况下，让你和第三方开发人员对事件作出反应。在应用程序中，可以通过监听Broadcast Intent来对设备状态变化和第三方应用程序事件作出反应。</p>

<h3 id="toc_19">intent-filter</h3>

<p>使用Intent Filter，应用程序组件可以声明它们支持的动作和数据。</p>

<h4 id="toc_20">action</h4>

<p>使用android:name属性指定要为之服务的动作的名称。每个Intent Filter必须要有至少一个action标签。Action应该是一个描述性的唯一的字符串。所以最好的做法使用基于Java的包命名约定的命名系统。</p>

<h4 id="toc_21">category</h4>

<p>使用android:name属性来指定应该在哪种情况下为action提供服务。每个Intent Filter标签可以包含多个category标签。既可以指定自己的category也可以使用以下Android提供的标准值:</p>

<ul>
<li>ALTERNATIVE 可以把这个动作指定为在特定数据类型上执行的默认动作的可选项。</li>
<li>SELECTED_ALTERNATIVE 与ALTERNATIVE相似，但是ALTERNATIVE总是使用后面将描述的intent resolution解析为一个动作，而当要求有很多可能性的时候，则可以使用SELECTED_ALTERNATIVE</li>
<li>BROWSABLE 指定一个在浏览器内部可用的动作。如果想让应用程序相应浏览器内触发的动作，那么必须包含BROWSABLE类别。</li>
<li>DEFAULT 通过设置这个类型可以使一个组件成为Intent Filter内指定的数据类型的默认动作。对于那些使用一个显式的Intent启动的Activity，这个类别是很有必要的。</li>
<li>HOME 通过讲一个Intent Filter的类别设置为HOME，而不指定一个action，就可以把它作为本地屏幕的可选项。</li>
<li>LAUNCHER 使用这个类别会让一个Activity出现在应用程序的启动器中。</li>
</ul>

<h4 id="toc_22">data</h4>

<p>data标签允许指定组件可以执行的数据类型；根据情况，也可以包含多个数据标签。可以使用以下属性的任意组合来指定你的组件所支持的数据:</p>

<ul>
<li>android:host 指定一个幼小的主机名</li>
<li>android:mimetype 指定组件可以执行的数据类型</li>
<li>android:path 指定URI的有效路径值</li>
<li>android:port 指定主机的有效端口</li>
<li>android:scheme 指定一种特定的模式</li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;intent-filter&gt;
    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;
    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;
    &lt;data android:scheme=&quot;http&quot;
            android:host=&quot;bolg.radioactiveyak.com&quot;/&gt;
&lt;/intent-filter&gt;
</code></pre>

<p>在Android设备上点击YouTubu视频的链接时，会提示使用YouTube应用。这是通过在Intent Filter的data标签下指定scheme、host和path属性来实现。</p>

<h4 id="toc_23">Android 如何解析 Intent Filter</h4>

<ul>
<li>Android将已安装包的可用的Intent Filter放到一个列表中</li>
<li>那些鱼解析Intent时相关联的动作或者类别不匹配的Intent Filter将会从列表中移除
<ul>
<li>如果Intent Filter包含了指定的动作，那么就认为动作匹配了。</li>
<li>对于category匹配来说，Intent Filter必须包含待解析的Intent中的所有category，但可以包含Intent中所不包含的其他的category。一个没有指定的category的Intent Filter只能和没有任何category的Intent相匹配。</li>
</ul></li>
<li>Intent的数据URI的每一个部分都和Intent Filter的data标签进行比较。如果Intent Filter指定了scheme、host/authority、path或者MIME类型，呢么这些值都要和Intent的URI比较。任意一个不匹配都会把Intent Filter从列表中衣橱。没有指定数据值的Intent Filter将会和所有的Intent数据值匹配。
<ul>
<li>MIME类型是指要匹配的数据的数据类型。如果不指定数据类型，它会和所有的Intent匹配。</li>
<li>scheme是URI的“协议”部分(例如，http: mailto: 或者 tel:)</li>
<li>hostname 或者 data authority是URI位于scheme和path之间的部分</li>
<li>数据path是authority之后的内容。只有数据的scheme和hostname都匹配的时候，path才匹配。</li>
</ul></li>
<li>当隐式启动一个Activity时，如果这个进程解析出多个组件，那么所有可能匹配的组件都会呈现给用户。对于Broadcast Receiver，每个匹配的接收器将接收Broadcast Intent。</li>
</ul>

<h4 id="toc_24">使用Intent Filter作为插件和扩展</h4>

<p>Android 提供一个插件模型，可以让你的应用程序利用由你自己或者第三方应用程序组件所匿名提供的功能。</p>

<h5 id="toc_25">想应用程序提供匿名的动作</h5>

<p>Category 必须是ALTERNATIVE 或者 SELECTED_ALETERNATIVE</p>

<pre class="line-numbers"><code class="language-text">&lt;activity android:name=&quot;.NOstromoController&quot;&gt;
    &lt;intent-filter
        android:label=&quot;@string/Nuke_From_Orbit&quot;&gt;
        &lt;action android:name=&quot;com.pad.nostromo.NUMKE_FROM_ORBIT&quot;/&gt;
        &lt;data android:mimeType=&quot;vnd.moonbase.cursor.item/*&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category. ALTERNATIVE&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category. SELECTED_ALETERNATIVE&quot;/&gt;
&lt;/activity&gt;
</code></pre>

<h5 id="toc_26">从第三方Intent Receiver中发现新的动作</h5>

<p>通过Package Manager，可以创建一个指定了数据类型和action类别的Intent，让系统能返回一个能够在该数据上执行该动作的Activity的列表。</p>

<pre class="line-numbers"><code class="language-text">PackageManager packageManager = getPackageManager();

//创建一个Intent用来解析哪个动作应该出现在菜单中
Intent intent = new Intent();
intent.setData(MoonBaseProvider.CONTENT_URI);
intent.addCategory(Intent.CATEGORY_SELECTED_SLTERNSTIVE);

//指定标识。
int flags = PackageManager.MATCH_DEFAULT_ONLY;

//生成列表
List&lt;ResolveInfo&gt; actions;
actions = packageManager.queryIntentActivities(intent,flags);

//获取动作名称的列表
ArrayList&lt;String&gt; labels = new ArrayList&lt;String&gt;();
Resources r = getResources();
for (ResolveInfo action : actions) {
    labels.add(r.getString(action.labelRes));
}
</code></pre>

<h5 id="toc_27">把匿名的动作作为菜单项集成</h5>

<p>Menu类中可用的addIntentOptions方法可以指定一个描述了在Activity中所操作的数据的Intent。然而，和只简单地返回一个可用的Receiver的列表不同，会为每个动作创建一个新的菜单项，并使用匹配的Intent Filter的标签填充其文本。</p>

<pre class="line-numbers"><code class="language-text">@Override
public boolean onCreateOptionMenu(Menu menu) {
    super.onCreateOptionsMenu(menu);
    
    //创建一个Intent用来解析哪个动作应该出现在菜单中
    Intent intent = new Intent();
    intent.setData(MoonBaseProvider.CONTENT_URI);
    intent.addCategory(Intent.CATEGORY_SELECTED_ALTERNATIVE);
    
    //正常的菜单选项用来为要添加的菜单项设置group和ID值
    int menuGroup = 0;
    int menuItemId = 0;
    int menuItemOrder = Menu.NONE;
    
    //提供调用动作的组建的名称————通常为当前的Activity
    ComponentName caller = getComponentName();
    
    //首先定义应该添加的一些Intent
    Intent[] specificIntents = null;
    
    //通过前面Intent创建的菜单项将填充这个数组
    MenuItem[] outSpecificItems = null;
    
    //填充菜单
    menu.addIntentOptions(menuGroup,menuItemId,menuItemOrder,caller,specificIntents,intent,flags,outSpecificItems);
    return true;
}
</code></pre>

<h3 id="toc_28">Pending Intent</h3>

<p>PendingIntent类提供了一种创建可由其他应用程序在稍晚的时候触发的Intent的机制。<br/><br/>
Pending Intent通常用于包装在响应将来的事件时触发的Intent。</p>

<pre class="line-numbers"><code class="language-text">int requestCode = 0;
int flags = 0;

//启动一个Activity
Intent startActivityIntent = new Intent(this,MyOtherActivity.class);
PendingIntent.getActivity(this,requestCode,startActivityIntent,flags);

//启动一个Service
Intent startServiceIntent = new Intent(this,MyService.class);
PendingIntent.getService(this, requestCode, startServiceIntent,flags);

//广播一个Intent
Intent broadcastIntent = new Intent(NEW_LIFEORM_DETECTED);
PendingIntent.getBroadcast(this, requestCode, broadcastIntent,flags);
</code></pre>

<h2 id="toc_29">显示通知Notification</h2>

<h2 id="toc_30">视图</h2>

<h3 id="toc_31">基础视图</h3>

<h4 id="toc_32">Chronometer</h4>

<p>一个TextView的扩展，实现了一个简单的计时器</p>

<h4 id="toc_33">ViewFlipper</h4>

<p>允许将一组View定义为一个水平行的ViewGroup，其中任意时刻只有一个View可见，并且可见View之间切换会通过动画形式表现出来，可以自动切换</p>

<h4 id="toc_34">QuickContactBadge</h4>

<p>显示一个徽标，该徽标显示了一个图片，该图片关联了通过电话号码、姓名、电子邮件或URI所指定的联系人信息。单击图片会显示一个快速联系人栏，它提供了联系选中的联系人的多种快捷方式————包括打电话和发送短消息、电子邮件及IM等。</p>

<h3 id="toc_35">复合控件</h3>

<p>复合控件即是指不可分割的，自包含的视图组，其中包含了多个排列和连接在一起的子视图。当创建复合控件时，必须对它包含的视图的布局、外观和交互进行定义。复合控件时通过扩展一个ViewGroup来创建。</p>

<pre class="line-numbers"><code class="language-text">&lt;LinearLayout xmlns:android=&quot;http:/schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;
    &lt;EditText
        android:id=&quot;@+id/editText&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;/&gt;
    &lt;Button
        android:id=&quot;@+id/clearButton&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Clear&quot;/&gt;
&lt;/LinearLayout&gt;


public class ClearableEditText extends LinearLayout {
    EditText editText;
    Button clearButton;
    
    public ClearableEditText(Context context) {
        super(context);
        
        LayoutInflater.inflate(R.layout.clearable_edit_text,this,true);
        
        //获得对子控件的引用
        editText = (EditText) findViewById(R.id.editText);
        clearButton = (Button) findViewById(R.id.clearButton);
    }
}
</code></pre>

<h3 id="toc_36">自定义视图</h3>

<p>一般分别对onMeasure和onDraw方法进行重写</p>

<pre class="line-numbers"><code class="language-text">public class MyView extends View {
    public MyView(Context context) {
        super(context);
    }
    
    public MyView(Context context,AttributeSet ats,int defaultStyle) {
        super(context,ats,defaultStyle);
    }
    
    public MyView(Context context,AttributeSet attrs) {
        super(context,attrs);
    }
    
    @Override
    protected void onMeasure(int wMeasureSpec,int hMeasureSpec) {
        int measuredHeight = measureHeight(hMeasureSpec);
        int measuredWidth = measureWidth(wMeasureSpec);
        
        //必须调用setMeasuredDimension
        //否则在布局控件的时候
        //会造成运行时异常
        setMeasuredDimension(measuredWidth, measuredHeight);
    }
    
    private int measureHeight(int measureSpec) {
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);
        
        //如果不指定限制，就是默认大小
        int result = 500;
        
        if (specMode == MeasureSpec.AT_MOST) {
            //Calculate the ideal size of your
            //计算控件在这个最大尺寸范围内的理想大小
            //如果控件填充了可用空间，则返回外边界
            result = specSize;
        } else if (specMode == MeasureSpec.EXCATLY) {
            //如果控件可以放置在这个边界内，则返回该值
            result = specSize;
        }
        
        return specSize;
    }
    
    private int measureWidth(int measureSpec) {
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);
        
        //如果不指定限制，就是默认大小
        int result = 500;
        
        if (specMode == MeasureSpec.AT_MOST) {
            //Calculate the ideal size of your
            //计算控件在这个最大尺寸范围内的理想大小
            //如果控件填充了可用空间，则返回外边界
            result = specSize;
        } else if (specMode == MeasureSpec.EXCATLY) {
            //如果控件可以放置在这个边界内，则返回该值
            result = specSize;
        }
        
        return specSize;
    }
    
    @Override
    protected void onDraw(Canvas canvas) {
        //绘制背景
        super(canvas)
        //绘制表面内容
    }
}
</code></pre>

<h4 id="toc_37">处理用户交互事件</h4>

<ul>
<li>onKeyDown 当任何设备按键被按下时，就会调用它</li>
<li>onKeyUp 当用户释放一个按键时调用</li>
<li>onTrackballEvent 当设备的轨迹球被移动的时候调用</li>
<li>onTouchEvent 当触摸屏被按下或者释放时调用，或者当检测到运动时调用</li>
</ul>

<pre class="line-numbers"><code class="language-text">@Override
public boolean onKeyDown(int keyCode,KeyEvent keyEvent) {
    //如果事件得到处理，返回true
    return true;
}

@Override
public boolean onKeyUp(int keyCode,KeyEvent keyEvent) {
    //如果事件得到处理，返回true
    return true;
}

@Override
public boolean onTrackballEvent(MotionEvent event) {
    //获得这个事件代表的动作类型
    int actionPerformed = event.getAction();
    //如果事件得到处理，返回true
    return true;
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    //获得这个事件代表的动作类型
    int actionPerformed = event.getAction();
    //如果事件得到处理，返回true
    return true;
}
</code></pre>

<h2 id="toc_38">Broadcast Receiver</h2>

<h3 id="toc_39">广播事件</h3>

<p>在应用程序组件中，可以构建希望广播的Intent，然后使用sendBroadcast方法来发送它。<br/><br/>
可以对Intent的动作、数据和分类进行设置，从而使Broadcast Receiver能够精确地确定它们的需求。在这种方案中，Intent动作字符串可以用来标识要广播的事件，所以它应该是能够标识事件的唯一的字符串。习惯上，动作字符串使用于Java包名相同的构建方式。<code>public static final String NEW_LIFEFORM_DETECTED = &quot;com.paad.action.NEW_LIFEFORM&quot;;</code><br/><br/>
如果希望在Intent中包含数据，那么可以使用Intent的data属性指定一个URI，也可以包含extras来添加额外的基本值。</p>

<pre class="line-numbers"><code class="language-text">Intent intent = new Intent(LifeformDetectedReceiver.NEW_LIFEFORM);
intent.putExtra(LifeformDetectedReceiver.EXTRA_LIFEFORM_NAME,detectedLifeform);
intent.putExtra(LifeformDetectedReceiver.EXTRA_LONGTUDE,currentLongitude);
intent.putExtra(LifeformDetectedReceiver.EXTRA_LATITUDE,currentLatitude);
sendBroadcast(intent);
</code></pre>

<h3 id="toc_40">监听广播</h3>

<p>Boradcast Receiver 可以用来监听Broadcast Intent。要使Broadcast Receiver能够接收广播，就需要对其进行注册，既可以使用diamante，也可以在应用程序的manifest文件中注册。但无论怎么注册，都需要使用一个Intent Filter来指定它要监听哪些Intent和数据。<br/><br/>
对于包含manifest接收器的应用程序，在Intent被广播出去的时候，应用程序不一定非要处于运行状态才能执行接收。当匹配的Intent被广播出去的时候，它们会被自动地启动。即使被关闭或销毁了，也仍然能够对广播事件作出响应。<br/><br/>
要创建一个新的Brocast Receiver，需要扩展BroadcastReceiver类并重写onReceive事件处理程序。</p>

<pre class="line-numbers"><code class="language-text">public class MyBoradcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context,Intent intent) {
        //响应接收到的Intent
    }
}
</code></pre>

<p>当接收到一个与在注册接收器时使用的Intent Filter相匹配的Broadcast Intent的时候，就会执行onReceive方法。<strong>onReceive处理程序必须在5秒钟内完成，否则就会显示Force Close对话框</strong>。<br/><br/>
Broadcast Receiver将会更新内容、启动Service、更新Activity UI，或者使用Notification Manager来通知用户。</p>

<pre class="line-numbers"><code class="language-text">public class LifeformDetectedReceiver extends BroadcastReceiver {
    public final static String EXTRA_LIFEFORM_NAME = “EXTRA_LIFEFORM_NAME”；
    public final static String EXTRA_LATITUDE = &quot;EXTRA_LATITUDE&quot;;
    public final static String EXTRA_LONGTUDE = &quot;EXTRA_LONGTUDE&quot;;
    public final static String ACTION_BURN = &quot;com.paad.alien.action.BURN_IT_WITH_FIRE&quot;;
    public final static String NEW_LIFEFORM = &quot;com.paad.alien.action.NEW_LIFEFORM&quot;;
    
    @Override
    public void onReceive(Context context,Intent intent) {
        //从Intent获得lifeform的细节
        Uri data = intent.getData();
        String type = intent.getStringExtra(EXTRA_LIFEFORM_NAME);
        double lat = intent.getDoubleExtra(EXTRA_LATITUDE,0);
        double lng = intent.getDoubleExtra(EXTRA_LONGTUDE,0);
        Location loc = new Location(&quot;gps&quot;);
        loc.setLatitude(lat);
        loc.setLongitude(lng);
        if (type.equals(&quot;facehugger&quot;)) {
            Intent startIntent = new Intent(ACTION_BURN,data);
            startIntent.putExtra(EXTRA_LATITUDE,lat);
            startIntent.putExtra(EXTRA_LONGTUDE,lng);
            
            context.startService(startIntent);
        }
    }
}
</code></pre>

<h4 id="toc_41">在manifest中注册Broadcast Receiver</h4>

<p>在application节点中添加一个receiver标签，以指定要注册的Broadcast Receiver的类名。接收器节点需要包含一个intent-filter标签来指定要监听的动作字符串。</p>

<pre class="line-numbers"><code class="language-text">&lt;receiver android:name=&quot;.LifeformDetectedReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.paad.alien.action.NEW_LIFEFORM&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>

<p>通过这种方式注册的Broadcast Receiver总是活动的，并且即时当应用程序被终止或未启动时，也可以接收Broadcast Receiver。</p>

<h4 id="toc_42">在代码中注册Broadcast Receiver</h4>

<p>影响特定Activity的UI的Broadcast Receiver通常在代码中注册。在代码中注册的接收器只会在包含它的应用程序组件运行时响应Broadcast Intent。<br/><br/>
在接收器用来更新一个Activity中的UI元素时，这样做很有帮助。在这种情况下，在onResume处理程序中注册接收器，并在onPause中注销它。</p>

<pre class="line-numbers"><code class="language-text">private IntentFilter filter = new IntentFilter(LifeformDetectedReceiver.NEW_LIFEFORM);
private LifeformDetectedReceiver receiver = new LifeformDetectedReceiver();

@Override
public void onResume() {
    super.onResume();
    //注册Broadcast Receiver
    registerReceiver(receiver,filter);
}

@Override
public void onPause() {
    //注销Broadcast Receiver
    unregisterReceiver(receiver);
    super.onPause();
}
</code></pre>

<h4 id="toc_43">广播有序的Intent</h4>

<p>当Broadcast Receiver接收Intent的顺序十分重要时，特别是当需要接收器能够影响将来的接收器收到的Broadcast Intent时，可以使用sendOrderedBroadcast方法。</p>

<pre class="line-numbers"><code class="language-text">String requiredPermission = &quot;com.paad.MY_BROADCAST_PERMISSION&quot;;
sendOrderedBroadcast(intent,requiredPermission);
</code></pre>

<p>使用这个方法时，Intent将会按照优先级顺序被传递给所有具有合适权限的已注册的接收器，可以在Broadcast Recevier的Intent Filter manifest节点中使用android:priority属性指定其权限，值越大，优先级越高。</p>

<pre class="line-numbers"><code class="language-text">&lt;receiver
    android:name=&quot;.MyOrderedReceiver&quot;
    android:permission=&quot;com.paad.MY_BROADCAST_PERMISSION&quot;&gt;
    &lt;intent-filter
        android:priority=&quot;100&quot;&gt;
        &lt;action android:name=&quot;com.paad.action.ORDERED_BROADCAST&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt; 
</code></pre>

<h4 id="toc_44">广播Sticky Intent</h4>

<p>Sticky Intent是Broadcast Intent的有用变体，可以保存它们最后一次广播的值，并且当有一个新的接收器被注册为接收该广播时，它们会把这些值作为Intent返回。<br/><br/>
当调用registerReceiver来指定一个匹配Sticky Broadcast Intent的Intent Filter时，返回值将是最后一次Intent广播，例如电池电量变化的广播:</p>

<pre class="line-numbers"><code class="language-text">IntentFilter battery = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
Intent currentBatteryCharge = registerReceiver(null,battery);
</code></pre>

<p>不是必须指定一个接收器来获得Sticky Intent当前值。要广播自己的Sticky Intent，应用程序必须具有BROADCAST_STICKY用户权限，然后需要调用sendStickyBroadcast并传入相关的Intent:<br/>
<code>sendStickyBroadcast(intent);</code><br/><br/>
要删除一个Sticky Intent，可以调用removeStickyBroadcast，并传入要删除的Sticky Intent:<br/><br/>
<code>removeStickyBroadcast(intent);</code></p>

<h3 id="toc_45">监听本地Broadcast Intent</h3>

<p>很多的系统Service都会广播Intent来指示一种变化。可以使用这些信息来向自己的项目中添加基于系统事件的功能。下列动作用来跟踪设备状态的变化:</p>

<ul>
<li>ACTION_BOOT_COMPLETED 一旦系统完成了它的启动序列之后，就会触发这个动作。要想接收这个广播，应用程序需要具有RECEIVE_BOOT_COMPLETED权限</li>
<li>ACTION_CAMERA_BUTTON 当单机拍照按键的时候触发</li>
<li>ACTION_DATE_CHANGED 和 ACTION_TIME_CHANGED 如果设备的日期和时间被手动修改了，这些动作就会被广播。</li>
<li>ACTION_MEDIA_MOUNTED 和 ACTION_MEDIA_UNMOUNTED 任何时候，当新的外部存储介质被成功地添加或者从设备移除的时候，都会触发这两个事件。</li>
<li>ACTION_NEW_OUTGOING_CALL 当将要向外拨打电话的时候就会进行广播。监听这个广播可以截获播出的电话呼叫。拨打的电话号码存储在EXTRA_PHONE_NUMBER extra中，而返回的Intent中的resultData则是实际拨打的号码。要为这个动作注册一个Broadcast Receiver，应用程序必须声明PROCESS_OUTGOING_CALLS使用权限。</li>
<li>ACTION_SCREEN_OFF 和 ACTION_SCREEN_ON 当屏幕关闭或者打开时就分别对其广播。</li>
<li>ACTION_TIMEZONE_CHANGED 当手机当前的时区发生改变的时候就会广播这个动作。</li>
</ul>

<h4 id="toc_46">使用Broadcast Intent监控设备的状态变化</h4>

<p>监控设备状态是创建高效和动态的应用程序的重要的一部分，该应用程序的行为根据连接性、电量状态和dock状态发生变化。</p>

<h5 id="toc_47">监听电量变化</h5>

<pre class="line-numbers"><code class="language-text">IntentFilter batIntentFilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
Intent battery = context.registerReceiver(null,batIntentFilter);
int status = battery.getIntExtra(BatteryManager.EXTRA_STATUS,-1);
boolean is Charging = status == BatteryManager.BATTERY_STATUS_CHANGING || status == BatteryManager.BATTERY_STATUS_FULL;
</code></pre>

<p>不能再manifest文件的Receiver中注册电量变化的动作。然而可以使用下面的动作字符串监控和电源的连接情况以及低电量情况。</p>

<ul>
<li>ACTION_BATTERY_LOW</li>
<li>ACTION_BATTERY_OKAY</li>
<li>ACTION_POWER_CONNECTED</li>
<li>ACTION_POWER_DISCONNECTED</li>
</ul>

<h5 id="toc_48">监听连接变化</h5>

<p>连接的变化，包括贷款、延迟和Intent连接是否可用等信息。想要监听连接的变化，注册一个Broadcast Receiver用来监听 android.net.conn.CONNECTIVITY_CHANGE(ConnectivityManager.CONNECTIVITY_ACTION)动作。<br/><br/>
连接变化的广播不是sticky的而且也不包含任何和变化相关的额外信息。想要获得当前连接状态的详细信息，需要使用Connectivity Manager。</p>

<pre class="line-numbers"><code class="language-text">String svcName = Context.CONNECTIVITY_SERVICE;
ConnectivityManager cm = (ConnectivityManager)context.getSystemService(svcName);

NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
boolean isConnected = activeNetwork.isConnectedOrConnecting();
boolean isMobile = activeNetwork.getType() == ConnectivityManager.TYPE_MOBILE;
</code></pre>

<h5 id="toc_49">监听Dock变化</h5>

<p>通过注册一个Receiver来监听Intent.ACTION_DOCK_EVENT，可以确定docking的状态和类型。<br/><br/>
和电池状态一样，dock事件的Broadcast Intent也是sticky的。</p>

<pre class="line-numbers"><code class="language-text">IntentFilter dockIntentFilter = new IntentFilter(Intent.ACTION_DOCK_EVENT);
Intent dock = registerReceiver(null,dockIntentFilter);
int dockState = dock.getIntExtra(Intent.EXTRA_DOCK_STATE,Intent.EXTRA_DOCK_STATE_UNDOCKED);
boolean isDocked = dockState != Intent.EXTRA_DOCK_STATE_UNDOCKED;
</code></pre>

<h5 id="toc_50">在运行时管理Manifest Receiver</h5>

<p>使用Package Manager的setComponentEnabledSetting方法，可以在运行时启用和禁用应用程序的manifest Receiver。<br/><br/>
想要减少应用程序的开销，当应用程序不需要响应一些系统事件时，最好禁用监听这些常见系统事件的manifest Receiver。这项技术也能够让你定时执行一个基于系统事件的动作，如当设备连接到Wi-Fi时去下载一个大文件。</p>

<pre class="line-numbers"><code class="language-text">ComponentName myReceiverName = new ComponentName(this,MyReceiver.class);
PackageManager pm = getPackageManager();

//启用一个manifest receiver
pm.setComponentEnabledSetting(myReceiverName,PackageManager.COMPONENT_ENABLED_STATE_ENABLED,PackageManager.DONT_KILL_APP);

//禁用一个manifest receiver
pm.setComponentEnabledSetting(myReceiverName,PackageManager.COMPONENT_ENABLED_STATE_DISABLED,PackageManager.DONT_KILL_APP);
</code></pre>

<h3 id="toc_51">Local Broadcast Manager</h3>

<p>用于简化注册Broadcast Intent，以及在应用程序内的组件之间发送Broadcast Intent的工作。因为局部广播的作用域要小一些，所以使用Local Broadcast Manager比发送全局广播更加高效。而且使用Local Broadcast Manager也确保了应用程序外部的任何组件都收不到你广播的Intent，所以不会有私人数据或敏感数据泄露出去的风险。<br/><br/>
<code>LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(this);</code></p>

<p>要注册一个局部Broadcast Receiver，与注册全局接收器时类似。需要使用Local Broadcast Manager的registerReceiver方法，并传入一个Broadcast Receiver 和一个 Intent Filter</p>

<pre class="line-numbers"><code class="language-text">lbm.registerReceiver(new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        
    }
}, new IntentFilter(LOCAL_ACTION));
</code></pre>

<p>要发送一个局部Broadcast Intent，可以使用Local Broadcast Manager的sendBroadcast方法，并传入要广播的Intent:<code>lbm.sendBroadcast(new Intent(LOCAL_ACTION));</code></p>

<h2 id="toc_52">Content Provider</h2>

<p>在Android中推荐使用Content Provider来实现跨包的数据共享。其行为方式和数据库很像，可以进行增删改查等操作。但是其可以将数据存储在数据库、文件甚至是网络上。<br/><br/>
Content Provider提供了一个接口用来发布数据，通过Content Resolver来使用数据。它们允许将使用数据的应用程序组件和底层的数据源分离开来，并提供了一种通用的机制来允许一个应用程序共享它们的数据或者使用其他应用程序提供的数据。<br/><br/>
Android附带了许多有用的Content Provider</p>

<ul>
<li>Browser ———— 存储诸如浏览器书签、浏览器历史记录等数据</li>
<li>CallLog ———— 存储诸如未接电话、通话详细信息等数据</li>
<li>Contacts ———— 存储联系人详细信息</li>
<li>MediaStore ———— 存储媒体文件，如音频、视频和图像</li>
<li>Settings ———— 存储设备的设置和首选项</li>
</ul>

<p>查询URL的格式: <standard_prefix>://<authority>/<data_path>/<id></p>

<ul>
<li>standard_prefix始终是content://</li>
<li>authority 指定了Provider的名称，如内置的Contacts 内容提供者的名称为contacts。对于第三方内容提供者，将采用其完全限定的名称。</li>
<li>data path 指定了请求数据的类型。如果从Contacts获取联系人，那么data path就是people</li>
<li>id 指定了请求的特定记录。 如果从Contacts获取二号联系人，那么id值为2</li>
</ul>

<p><strong>代码实现</strong></p>

<pre class="line-numbers"><code class="language-text">Uri allContacts = Uri.parse(&quot;content://contacts/people&quot;);
Cursor c;
CursorLoader cursorLoader = new CursorLoader (
    this,allContacts,null,null,null,null
);
c = cursorLoader.loadInBackground();
if (c.moveToFirst) {
    do {
        String contactID = c.getString(c.getColumnIndex(ContactsContract.Contacts._ID));
        String contactDisplayName = c.getString(c.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME));
    } while (c.moveToNext());
}
</code></pre>

<h3 id="toc_53">创建自己的ContentProvider</h3>

<p>扩展ContentProvider抽象类<code>public class MyContentProvider extends ContentProvider</code></p>

<h4 id="toc_54">注册Content Provider</h4>

<p>同Activity和Service一样，Content Resolver必须在应用程序清单文件中进行注册，注册是通过provider标记实现的。使用authorities标记来设定Content Provider的基本URI，找到想要交互的数据库。每个Content Resolver的授权必须是唯一的，因此最好用包名作为URI的基本路径<code>com.{CompanyName}.provider.&lt;ApplicationName&gt;</code></p>

<h4 id="toc_55">发布Content Provider的URI地址</h4>

<p>每个Content Provider都应该使用一个公有的静态CONTENT_URI属性来公开他们的授权。这个CONTENT_URI应该包含一个主要内容的数据路径。<code>public static final Uri CONTENT_URI = Uri.parse(&quot;content://com.paad.skeletondatabaseprovider/elements&quot;);</code>直接使用这种形式的查询表示请求所有行，而在结尾附加/<rownumber>的查询请求表示请求一条记录。最好同时支持使用这两种形式的提供程序，可以通过UriMatcher实现。</p>

<h4 id="toc_56">Content Provider的实现框架</h4>

<pre class="line-numbers"><code class="language-text">public class MyContentProvider extends ContentProvider {
    public static final Uri CONTENT_URI = Uri.parse(&quot;content://com.paad.skeletondatabaseprovider/elements&quot;)
    
    //创建两个常量来区分不同的URI请求
    private static final int ALLROWS = 1;
    private static final int SINGLE_ROW = 2;
    
    private static final UriMatcher uriMatcher;
    
    //填充UriMatcher对象，以&#39;element&#39;结尾的URI对应请求全部数据
    //以&#39;elements/[rowID]&#39;结尾的URI代表请求单行数据
    static {
        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
        uriMatcher.addURI(&quot;com.paad.skeletondatabaseprovider&quot;,&quot;elements&quot;,ALLROWS);
        uriMatcher.addURI(&quot;com.paad.skeletondatabaseprovider&quot;,&quot;elements/#&quot;,SINGLE_ROW);
    }
    
    //where 子句中使用的索引列的名称
    public static final String KEY_ID = &quot;_id&quot;;
    
    //数据库中每个列的列名和索引。这些内容应该是描述性的。
    public static final String KEY_COLUMN_1_NAME = &quot;KEY_COLUMN_1_NAME&quot;;
    
    //SQLiteOpenHelper变量
    private MySQLiteOpenHelper myOpenHelper;
    
    @Override
    public boolean onCreate() {
        //构造底层的数据库
        //延迟打开数据库，直到需要执行一个查询或者事务时再打开
        myOpenHelper = new MySQLiteOpenHelper(getContext(),MySQLiteOpenHelper.DATABASE_NAME,null, MySQLiteOpenHelper.DATABASE_VERSION);
        return true;
    }
    
    @Override
    public Cursor query(Uri uri,String[] projection,String selection,String[] selectionArgs,String sortOrder) {
        //打开数据库
        SQLiteDatabase db = myOpenHelper.getWriteableDatabase();
        
        //必要的话，使用有效的SQL语句替换这些语句
        String groupBy = null;
        String having = null;
        
        SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();
        queryBuilder.setTables(MySQLiteOpenHelper.DATABASE_TABLE);
        
        //如果是行查询，用传入的行限制结果
        switch(uriMatcher.match(uri)) {
            case SINGLE_ROW:
                String rowID = uri.getPathSegments().get(1);
                queryBuilder.appendWhere(KEY_ID + &quot;=&quot; + rowID);
                break;
            default:
                break;
        }
        
        Cursor cursor = queryBuilder.query(db,projection,selection,selectionArgs,groupBy,having,sortOrder);
        return cursor;
    }
    
    @Override
    public int delete(Uri uri,String selection,String[] selectionArgs) {
        //打开一个可读/可写的数据库来支持事务
        SQLiteDatabase db = myOpenHelper.getWritableDatabase();
        
        //如果是行URI，限定删除的行为指定的行
        switch(uriMatcher.match(uri)) {
            case SINGLE_ROW:
                String rowID = uri.getPathSegments().get(1);
                selection = KEY_ID + &quot;=&quot; + rowID + (!TextUtils.isEmpty(selection) ? &quot;AND (&quot; + selection + &#39;)&#39; : &quot;&quot;);
                break;
            default:
                break;
        }
        
        //想要返回删除的项的数量，必须指定一条where子句。删除所有的行并返回一个值，同时传入&quot;1&quot;。
        if (selection == null) {
            selection = &quot;1&quot;;
        }
        
        int deleteCount = db.delete(MySQLiteOpenHelper.DATABASE_TABLE,selection,selectionArgs);
        
        //通知所有观察者，数据集已经改变
        getContext().getContentResolver().notifyChange(uri,null);
        return deleteCount;
    }
    
    @Override
    public Uri insert(Uri uri,ContentValues values) {
        //打开一个可读/可写的数据库来支持事务
        SQLiteDatabase db = myOpenHelper.getWritableDatabase();
        
        //要想通过传入一个空Content Value对象的方式向数据库中添加一个空行
        //必须使用nullColumnHack参数来指定可以设置为null的列名
        String nullColumnHack = null;
        
        long id = db.insert(MySQLiteOpenHelper.DATABASE_TABLE,nullColumnHack,values);
        
        //构造并返回新插入行的URI
        if (id &gt; -1) {
            //构造并返回新插入行的URI
            Uri insertedId = ContentUris.withAppendedId(CONTENT_URI,id);
            
            //通知所有的观察者，数据集已经改变
            getContext().getContentResolver().notifyChange(insertId,null);
            return insertedId;
        } else {
            return null;
        }
    }
    
    @Override
    public int update(Uri uri,ContentValues values,String selection,String[] selectionArgs) {
        //打开一个可读/可写的数据库来支持事务
        switch(uriMatcher.match(uri)) {
            case SINGLE_ROW:
                String rowID = uri.getPathSegments().get(1);
                selection = KEY_ID + &quot;=&quot; + rowID + (!TextUtils.isEmpty(selection) ? &quot;AND (&quot; + selection + &#39;)&#39; : &quot;&quot;);
                break;
            defalut:
                break;
        }
        
        //执行更新
        int updateCount = db.update(MySQLiteOpenHelper.DATABASE_TABLE,values,selection,selectionArgs);
        
        //通知所有的观察者，数据集已经改变
        getContext().getContentResolver().notifyChange(uri,null);
        
        return updateCount;
    }
    
    @Override
    public ParcelFileDescriptor openFile(Uri uri,String mode) throws FileNotFoundException{
        //找到行ID并把它作为一个文件名使用
        String rowID = uri.getPathSegments().get(1);
        
        //在应用程序的外部文件目录中创建一个文件对象
        String picsDir = Environment.DIRECTORY_PICTURES;
        File file = new File(getContext().getExternalFilesDir(picsDir),rowID);
        
        //如果文件不存在，则直接创建它
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                Log.d(TAG,&quot;File creation failed:&quot; + e.getMessage());
            }
        }
        
        //将mode参数转换为对应的ParcelFileDescriptor打开模式
        int fileMode = 0;
        if (mode.contains(&quot;w&quot;)) {
            fileMode |= ParcelFileDescriptor.MODE_WRITE_ONLY;
        }
        if (mode.contains(&quot;r&quot;)) {
            fileMode |= ParcelFileDescriptor.MODE_READ_ONLY;
        }
        if (mode.contains(&quot;+&quot;)) {
            fileMode |= ParcelFileDescriptor.MODE_APPEND;
        }
        
        //返回一个代表了文件的ParcelFileDescriptor
        return ParcelFileDescriptor.open(file,fileMode);
    }
    
    @Override
    public String getType(Uri uri) {
        //为一个Content Provider URI返回一个字符串，它标识了MIME类型
        switch(uriMatcher.match(uri)) {
            case ALLROWS:
                return &quot;vnd.android.cursor.dir/vnd.paad.elemental&quot;;
            case SINGLE_ROW:
                return &quot;vnd.android.cursor.item/vnd.paad.elemental&quot;;
            default:
                throw new IllegalArgumentException(&quot;Unsupported URI:&quot; + uri);
        }
    }
    
    private static class MySQLiteOpenHelper extends SQLiteOpenHelper {
    
    }
}
</code></pre>

<h3 id="toc_57">使用Content Provider</h3>

<h4 id="toc_58">Content Resolver简介</h4>

<p>每一个程序都有一个ContentResolver实例，可以使用getContentResolver方法来对其进行访问。当使用Content Provider公开数据时，Content Resolver是用来在这些Content Provider上进行查询和执行事务的对应类。Content Resolver包含了一些查询和事务方法，它们与Content Provider中定义的查询和事务方法相对应。</p>

<h4 id="toc_59">查询Content Provider</h4>

<p>查询结果是作为结果集的Cursor返回的。对ContentResolver对象使用query方法并传递给它以下参数:</p>

<ul>
<li>希望查询的Content Provider的URI</li>
<li>一个投影，列出了希望包含在结果集中的列</li>
<li>一条where子句，定义了要返回的行。可以在其中包含&quot;?&quot;通配符，它将会被传入选择参数的值代替</li>
<li>将代替where子句中&quot;?&quot;通配符的选择参数字符串数组</li>
<li>一个字符串，用来描述返回的行的顺序</li>
</ul>

<p>查询特定行可以使用ContentUris类的withAppendedId</p>

<pre class="line-numbers"><code class="language-text">//获得Content Resolver
ContentResolver cr = getContentResolver();

//指定结果列投影
//返回满足要求所需的最小列表
String[] result_columns = new String[] {
    MyHoardContentProvider.KEY_ID,
    MyHoardContentProvider.KEY_GOLD_HOARD_NAME_COLUMN,
    MyHoardContentProvider.KEY_GOLD_HOARD_COLUMN,
}

//将一个行ID附加到URI以定位特定的行
Uri rowAddress = ContentUris.withAppendedId(MyHoardContentProvider.CONTENT_URI,rowId);

//由于我们在请求单独的一行，因此下列变量的取值都为null
String where = null;
String whereArgs[] = null;
String order = null;

//返回指定的行
Cursor resultCursor = cr.query(rowAddress,result_columns,where,whereArgs,order);
</code></pre>

<p>数据库查询的执行时间很长。默认，Content Resolver将在应用程序主线程上执行查询和其他一些事务。可以使用Cursor Loader异步查询内容</p>

<h5 id="toc_60">使用Cursor Loader异步查询内容</h5>

<p>Cursor Loader能够处理在Activity或者Fragment中使用Cursor所需的所有管理任务。</p>

<p><strong>实现 Cursor Loader Callback</strong><br/><br/>
要使用Cursor Loader，可创建一个新的LoaderManager.LoaderCallbacks实现。<br/><br/>
<code>LoaderManager.LoaderCallbacks&lt;Cursor&gt; loaderCallback = new LoaderManager.LoaderCallbacks&lt;Cursor&gt;(){}</code></p>

<p>如果需要在Fragment或者Activity中实现一个Loader，通常通过让该组件实现LoaderCallback接口来实现</p>

<ul>
<li>onCreateLoader 当Loader被初始化后，调用onCreateLoader，该处理程序应该创建并返回一个新的Cursor Loader对象。Cursor Loader构造函数的参数与使用Content Resolver执行查询所需的参数是相同的。</li>
<li>onLoadFinished 当Loader Manager已经完成了异步查询后，onLoadFinished处理程序会被调用，并把结果Cursor作为参数传入。使用这个Cursor来更新适配器和其他UI元素。</li>
<li>onLoaderReset 当Loader Manager重置Cursor Loader的时候，会调用onLoaderReset处理程序。</li>
</ul>

<pre class="line-numbers"><code class="language-text">public Loader&lt;Cursor&gt; onCreateLoader(int id,Bundle args) {
    String[] projection = null;
    String where = null;
    String[] whereArgs = null;
    String sortOrder = null;
    
    Uri queryUri = MyContentProvider.CONTENT_URI;
    
    return new CursorLoader(DatabaseSkeletonActivity.this,queryUri,projection,where,whereArgs,sortOrder);
}

public void onLoadFinished(Loader&lt;Cursor&gt; loader,Cursor cursor) {
    
}

public void onLoadReset(Loader&lt;Cursor&gt; loader) {
    
}
</code></pre>

<p><strong>初始化和重新启动Cursor Loader</strong><br/><br/>
每个Activity和Fragment都提供了getLoaderManager方法 ，可以调用该方法来访问Loader Manager。<br/><br/>
<code>LoaderManager loaderManager = getLoaderManager();</code><br/><br/>
初始化新的Loader  </p>

<pre class="line-numbers"><code class="language-text">Bundle args = null;
loaderManager.initLoader(LOADER_ID,args,myLoaderCallbacks);
</code></pre>

<p>这个过程通常是在Activity的onCreate方法或者Fragment中的onActivityCreated中完成的。</p>

<p><strong>添加、删除和更新内容Cursor Loader</strong><br/><br/>
要在Content Provider上执行事务操作，需要使用Content Resolver的insert、delete和update方法。与查询一样，Content Provider的事务会在应用程序主线程上执行，除非把它们移动到一个工作线程。</p>

<h3 id="toc_61">本地Android Content Provider</h3>

<ul>
<li>Media Store 对设备上的多媒体信息、包括音频、视频和图像提供了集中、托管的访问。</li>
<li>Browser 读取或者修改浏览器和浏览器搜索历史记录</li>
<li>Contacts Contract 检索、修改或者存储联系人的详细信息以及相关的社交流更新</li>
<li>Call Log 查看或者更新通话记录</li>
<li>Calender 创建新事件，删除或更新现有的日历项。</li>
</ul>

<h4 id="toc_62">使用Media Store Content Provider</h4>

<p>要从Media Store访问媒体文件，可以使用MediaStore类包含的Audio，Video和Images子类，这些子类有分别包含它们的子类，用来为每个媒体提供程序提供列名和内容URI。</p>

<pre class="line-numbers"><code class="language-text">//获得外部卷上每一个音频的Cursor，并提取歌曲名称和专辑名称
String[] projection = new String[] {
    MediaStore.Audio.AudioColumns.ALBUM,
    MediaStore.Audio.AudioColumns.TITLE
}

Uri contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;

Cursor cursor = getContentResolver().query(contentUri,projection,null,null,null);

//获得所需列的索引
int albumIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.AudioColumns.ALBUM);
int titleIdx = cursor.getColumnIndexOrThrow(MediaStore.Audio.AudioColumns.TITLE);

//创建一个数组来存储结果集
String[] result = new String[cursor.getCount()];

//迭代Cursor,提取每个专辑名称和歌曲名称
while(cursor.moveToNext()) {
    //提取歌曲的名称
    String title = cursor.getString(titleIdx);
    //提取专辑的名称
    String album = cursor.getString(albumIdx);
    
    result[cursor.getPosition()] = title + &quot; (&quot; + album + &quot;)&quot;;
}

//关闭Cursor
cursor.close();
</code></pre>

<h4 id="toc_63">使用 Contacts Contract Content Provider</h4>

<p>Android 向所有被赋予READ_CONTACTS权限的应用程序提供了联系人信息数据库的完全访问权限。<br/><br/>
其使用了一个三层数据模型来存储数据，将数据与联系人关联起来，并把同一个人的数据聚集起来，这是通过使用下面的ContactsContract 子类实现的</p>

<ul>
<li>Data 在底层的表中，每个行定义了一组个人数据，并使用MIME类型分离这些数据</li>
<li>RawContacts 用户可以为设备指定多个联系人账户提供程序。RawContacts表中的每一行定义了一个账户，可以向这个账户关联一组Data值。</li>
<li>Contacts 可以将RawContacts中描述同一个人的行聚集起来。</li>
</ul>

<h5 id="toc_64">读取联系人详情</h5>

<p>找到联系人姓名的联系信息</p>

<pre class="line-numbers"><code class="language-text">ContentResolver cr = getContentResolver();
String[] result = null;

//使用部分姓名匹配找到联系人
String searchName = &quot;andy&quot;;
Uri lookupUri = Uri.withAppendedPath(ContactsContract.Contacts.CONTENT_FILTER_URI,searchName);

//创建所需列名的投影
String[] projection = new String[] {
    ContactsContract.Contacts._ID
}

//获得一个Cursor，用于返回匹配的名称的ID
Cursor IdCursor = cr.query(lookupUri,projection,null,null,null);

//如果有匹配的ID，则提取第一个匹配的ID
String id = null;
if (idCursor.moveToFirst()) {
    int idIdx = idCursor.getColumnIndexOrThrow(ContactsContract.Contacts._ID);
    id = idCursor.getString(idIdx);
}

//关闭Cursor
idCursor.close();

//创建一个新Cursor,搜索与返回的联系人ID关联的数据
if (id != null) {
    //返回该联系人的所有PHONE数据
    String where = ContactsContract.Data.CONTACT_ID + &quot; = &quot; + id + &quot; AND&quot; + ContactsContract.Data.MIMETYPE + &quot; = &#39;&quot; + ContactsContract.CommonDataKinds.Phone.CONTENT_ITEM_TYPE + &quot;&#39;&quot;;
    
    projection = new String[] {
        ContactsContract.Data.DISPLAY_NAME,
        ContactsContract.CommonDataKinds.Phone.NUMBER
    }
    
    Cursor dataCursor = getContentResolver().query(ContactsContract.Data.CONTENT_URI,projection,where,null,null);
    
    //获得所需列的索引
    int nameIdx = dataCursor.getColumnIndexOrThrow(ContactsContract.Data.DISPLAY_NAME);
    int phoneIdx = dataCursor.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER);
    
    result = new String[dataCursor.getCount()];
    
    while(dataCursor.moveToNext()) {
        //提取姓名
        String name = dataCursor.getString(nameIdx);
        //提取电话号码
        String number = dataCursor.getString(phoneIdx);
        
        result[dataCursor.getPosition()] = name + &quot; (&quot; + number + &quot;)&quot;;
    }
    
    dataCursor.close();
}
</code></pre>

<p>找到联系人联系号码的联系信息</p>

<pre class="line-numbers"><code class="language-text">String incomingNumber = &quot;(650)253-0000&quot;;
String result = &quot;Not Found&quot;;

Uri lookupUri = Uri.withAppendedPath(ContactsContract.PhoneLookup.CONTENT_FILTER_URI,incomingNumber);

String[] projection = new String[] {
    ContactsContract.Contacts.DISPLAY_NAME
};

Cursor cursor = getContentResolver().query(lookupUri,projection,null,null,null);

if(cursor.moveToFirst()) {
    int nameIdx = cursor.getColumnIndexOrThrow(ContactsContract.Contacts.DISPLAY_NAME);
    result = cursor.getString(nameIdx);
}

cursor.close();
</code></pre>

<h5 id="toc_65">使用Intent创建和选择纤细人</h5>

<p>选择一个联系人</p>

<pre class="line-numbers"><code class="language-text">private static int PICK_CONTACT = 0;
private void pickContact() {
    Intent intent = new Intent(Intent.ACTION_PICK,ContactsContract.Contacts.CONTENT_URI);
    startActivityForResult(intent,PICK_CONTACT);
}

@Override
protected void onActivityResult(int requestCode,int resultCode,Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if ((requestCode == PICK_CONTACT) &amp;&amp; (resultCode == RESULT_OK)) {
        resultTextView.setText(data.getData().toString());
    }
}
</code></pre>

<p>插入一个新联系人</p>

<pre class="line-numbers"><code class="language-text">Intent intent = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT,ContactsContract.Contacts.CONTENT_URI);
intent.setData(Uri.parse(&quot;tel:(650)253-0000&quot;));

intent.putExtra(ContactsContract.Intents.Insert.COMPANY,&quot;Google&quot;);
intent.putExtra(ContactsContract.Intents.Insert.POSTAL,&quot;1600 Amphitheatre Parkway,Mountain View,California&quot;);
startActivity(intent);
</code></pre>

<h4 id="toc_66">使用Calendar Content Provider</h4>

<h5 id="toc_67">查询日历</h5>

<p>必须在应用程序的清单文件中包含 READ_CALENDAR 权限。<uses-permission android:name="android.permission.READ_CALENDAR"/></p>

<ul>
<li>Calendars Calendar应用程序可以显示多个日历，这些日历关联多个账户。该表存储每个可显示的日历，以及日历的详情，如日历的显示名称/时区和颜色。</li>
<li>Events 为每个调度的日历事件包含一项，内容包括名称、描述、地点和开始/结束时间</li>
<li>Instances 每个事件都有一个或多个实例。</li>
<li>Attendees 表中每一项表示一个给定事件的单个参与者。每个参与者可以包含姓名、电子邮件地址和出席状态</li>
<li>Reminders 描述了事件提醒，每一行代表一个特定事件的提醒</li>
</ul>

<p>查询Events表</p>

<pre class="line-numbers"><code class="language-text">//创建一个限制结果Cursor为所需列的投影
String[] projection = {
    CalendarContract.Events._ID,
    CalendarContract.Events.TITLE
};

//获取Events提供程序上的Cursor
Cursor cursor = getContentResolver().query(CalendarContract.Events.CONTENT_URI,projection,null,null,null);

//获取列的索引
int nameIdx = cursor.getColumnIndexOrThrow(CalendarContract.Events.TITLE);
int idIdx = cursor.getColumnIndexOrThrow(CalendarContract.Events._ID);

//初始化结果集
String[] result = new String[cursor.getCount()];

//迭代结果Cursor
while(cursor.moveToNext()) {
    //提取名称
    String name = cursor.getString(nameIdx);
    //提取唯一的ID
    String id = cursor.getString(idIdx);
    
    result[cursor.getPosition()] = name + &quot; (&quot; + id + &quot;)&quot;;
}

//关闭Cursor
cursor.close();
</code></pre>

<h5 id="toc_68">使用Intent创建和查询日历项</h5>

<p>Calendar Content Provider包含基于Intent的机制，该机制允许你使用Calendar应用程序执行常见的操作，而不需要特殊的权限。使用Intent，可以再指定的时间打开Calendar应用程序，查看事件的而详细信息，插入一个新的事件，或编辑现有的事件。</p>

<p>创建新的日历事件</p>

<pre class="line-numbers"><code class="language-text">//创建一个新的插入Intent
Intent intent = new Intent(Intent.ACTION_INSERT,CalendarContract.Events.CONTENT_URI);

//添加日历事件的详细信息
intent.putExtra(CalendarContract.Events.TITLE,&quot;Launch!&quot;);
intent.putExtra(CalendarContract.Events.DESCRIPTION,&quot;Professional Android 4 &quot; + &quot;Application Development release!&quot;);
intent.putExtra(CalendarContract.Events.EVENT_LOCATION,&quot;Wrox.com&quot;);

Calendar startTime = Calendar.getInstance();
startTime.set(2012,2,13,0,30);
intent.putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME,startTime.getTimeInMillis());
intent.putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY,true);

//使用Calendar应用程序添加新的事件
startActivity(intent);
</code></pre>

<p>编辑日历事件</p>

<pre class="line-numbers"><code class="language-text">//创建一个URI，通过行ID来访问指定的事件
//使用它来创建一个新的编辑Intent
long rowID = 760;
Uri uri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI,rowID);

Intent intent = new Intent(Intent.ACTION_EDIT,uri);

//修改日历事件的详细信息
Calendar startTime = Calendar.getInstance();
startTime.set(2012,2,13,0,30);
intent.putExtra(ClendarContract.EXTRA_EVENT_BEGIN_TIME,startTime.getTimeInMillis());
intent.putExtra(CalendarContract.EXTRA_EVENT_ALL_DAY,true);

//使用Calendar应用程序来编辑事件
startActivity(intent);
</code></pre>

<p>显示日历和日历事件</p>

<pre class="line-numbers"><code class="language-text">//创建一个URI来指定要查看的特定时间的日历事件
Calendar startTime = Calendar.getInstance();
startTime.set(2012,2,13,0,30);
Uri uri = Uri.parse(&quot;content:??com.android.calendar/time/&quot; + String.valueOf(startTime.getTimeInMillis()));
//使用Calendar应用程序查看时间
startActivity(intent);
</code></pre>

<h3 id="toc_69">Cursor</h3>

<p>Content Value用来向数据库的表中插入新的行。每一个ContentValues对象都将一个表行表示为列名到值得映射。<br/><br/>
数据库查询作为Cursor对象返回。Cursor是底层数据中的结果集的指针。</p>

<ul>
<li>moveToFirst 把游标移动到查询结果中的第一行</li>
<li>moveToNext 把游标移动到下一行</li>
<li>moveToPrevious 把游标移动到前一行</li>
<li>getCount 返回结果集中的行数</li>
<li>getColumnIndexOrThrow 返回具有指定名称的列的索引(如果不存在拥有该名称的列，就会抛出异常)，索引从0开始计数。</li>
<li>getColumnName 返回指定列索引的名称</li>
<li>getColumnNames 返回当前Cursor中的所有列名的字符串数组</li>
<li>moveToPosition 将游标移动到指定行</li>
<li>getPosition 返回当前的游标位置</li>
</ul>

<p>结束使用Cursor后，关闭它非常重要。这样可以防止内存泄漏，并降低应用程序的资源负载。<code>cursor.close();</code></p>

<h2 id="toc_70">消息传递</h2>

<h3 id="toc_71">发送SMS消息</h3>

<p>需添加权限<code>&lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot;&gt;</code></p>

<pre class="line-numbers"><code class="language-text">SmsManager sms = SmsManager.getDefault();
sms.sendTextMessage(destinationAddress:phoneNumber,scAddress:null,text:message,sentIntent:null,delivertyIntent:null);
</code></pre>

<ul>
<li>destinationAddress: 收件人的电话号码</li>
<li>scAddress: 服务中心地址，null代表默认的SMSC</li>
<li>text: SMS消息的内容</li>
<li>sentIntent: 发送消息后调用的挂起的意图</li>
<li>delivertyIntent: 消息递送后调用的挂起的意图</li>
</ul>

<p>在onCreate() 方法中创建两个PendingIntent对象。</p>

<pre class="line-numbers"><code class="language-text">sentPI = PendingIntent.getBroadcast(this,0,new Intent(SENT),0);
deliveredPI = PendingIntent.getBroadcast(this,0,new Intent(DELIVERED),0);
</code></pre>

<p>两个PendingIntent对象被传递给sendTextMessage()方法的最后两个参数</p>

<pre class="line-numbers"><code class="language-text">registerReceiver(smsDeliveredReceiver,new IntentFilter(DELIVERED));
registerReceiver(smsSentReceiver,new IntentFilter(SENT));
sms.sendTextMessage(phoneNumber,null,message,sentPI,deliveredPI);
</code></pre>

<h3 id="toc_72">使用意图发送SMS消息</h3>

<pre class="line-numbers"><code class="language-text">Intent i = new Intent(android.content.Intent.ACTION_VIEW);
i.putExtra(&quot;address&quot;,&quot;5556;5558;5560&quot;);
i.putExtra(&quot;sms_body&quot;,&quot;Hello my friends!&quot;);
i.setType(&quot;vnd.android-dir/mms-sms&quot;);
startActivity(i);
</code></pre>

<h3 id="toc_73">接收SMS消息</h3>

<p>可以使用BroadcastReceiver对象接收传入的SMS消息。如果希望应用程序在接收到一条特定的SMS消息时执行一个动作，就很有用了。</p>

<p>在AndroidManifest.xml文件中申明  </p>

<pre class="line-numbers"><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;
&lt;receiver android:name=&quot;.SMSReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>

<p>创建SMSReceiver文件</p>

<pre class="line-numbers"><code class="language-java">public class SMSReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context,Intent intent) {
        Bundle bundle = intent.getExtras();
        SmsMessage[] msgs = null;
        String str = &quot;SMS from&quot;;
        if (bundle != null) {
            Object[] pdus = (Object[]) bundle.get(&quot;pdus&quot;);
            msgs = new SmsMessage[puds.length];
            for (int i = 0;i &lt; msgs.length;i++) {
                msgs[i] = SmsMessage.createFromPdu((byte[])pdus[i]);
                if (i == 0) {
                    str += msgs[i].getOriginatingAddress();
                    str += &quot;: &quot;;
                }
                str += msgs[i].getMessageBody().toString();
            }
            Toast.makeText(context,str,Toast.LENGTH_SHORT).show();
        }
    }
}
</code></pre>

<h4 id="toc_74">阻止Messaging应用程序接收消息</h4>

<p>在AndroidManifest.xml中BroadcastReceiver的intent-filter中添加android:priority属性，数字越大，Android就会越早执行。并且在onReceive()方法中调用 <code>abortBroadcast()</code> 方法，停止广播。</p>

<h3 id="toc_75">发送邮件</h3>

<pre class="line-numbers"><code class="language-text">private void sendEmail(String[] emailAddresses,String[] carbonCpies,String subject,String message) {
    Intent emailIntent = new Intent(Intent.ACTION_SEND);
    emailIntent.setData(Uri.parse(&quot;mailto:&quot;));
    String[] to = emailAddresses;
    String[] cc = carbonCopies;
    emailIntent.putExtra(Intent.EXTRA_EMAIL,to);
    emailIntent.putExtra(Intent.EXTRA_CC,cc);
    emailIntent.putExtra(Intent.EXTRA_SUBJECT,subject);
    emailIntent.putExtra(Intent.EXTRA_TEXT,message);
    emailIntent.setType(&quot;message/rfc822&quot;);
    startActivity(Intent.createChooser(emailIntent, &quot;Email&quot;));
}
</code></pre>

<h2 id="toc_76">定位</h2>

<h3 id="toc_77">使用基于位置的服务</h3>

<p>基于位置的服务(LBS)是一个很宽泛的概念，描述了用来查找设备当前位置的不同技术。主要的两个LBS元素是</p>

<ul>
<li>位置管理器 提供基于位置的服务的挂钩</li>
<li>位置提供器 每一个位置提供器都表示不同的位置查找技术，这些技术用来确定设备的当前位置</li>
</ul>

<p>使用位置管理器可以</p>

<ul>
<li>获得当前的位置</li>
<li>追踪移动</li>
<li>设置近距离提醒，在检测到进入或者离开一个指定的区域时发出提醒</li>
<li>找到可用的位置提供器</li>
<li>监视GPS接收器的状态</li>
</ul>

<p><code>LocationManager locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);</code></p>

<p>并且需要在manifest文件中申请fine权限和coarse权限</p>

<pre class="line-numbers"><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;
</code></pre>

<h3 id="toc_78">选择一个位置提供器</h3>

<p>LocationManager类包含了一些静态字符串常量，这些常量将返回以下三种位置提供其的名称</p>

<ul>
<li>LocationManager.GPS_PROVIDER</li>
<li>LocationManager.NETWORK_PROVIDER</li>
<li>LocationManager.PASSIVE_PROVIDER</li>
</ul>

<h4 id="toc_79">通过指定条件查找位置提供器</h4>

<p>在大部分情况下都不太可能去显式地选择要使用的位置提供器。更常见的情况是指定你的要求。让Android去确定要使用的最优的技术。使用Criteria类来说明对提供器的要求，包括精度、能耗、花费以及返回海拔、速度和朝向的能力。</p>

<p>传入setAccuracy的coarse/fine 值代表一个主管的精确，其中fine代表GPS或更好的技术，而coarse则代表精度低很多的任何技术。</p>

<pre class="line-numbers"><code class="language-text">Criteria criteria = new Criteria();
criteria.setAccuracy(Criteria.ACCURACY_COARSE);
criteria.setPowerRequirement(Criteria.POWER_LOW);
criteria.setAltitudeRequired(false);
criteria.setBearingRequired(false);
criteria.setSpeedRequired(false);
criteria.setCostAllowed(true);
criteria.setHorizontalAccuracy(Criteria.ACCURACY_HIGH);
criteria.setVerticalAccuracy(Criteria.ACCURACY_MEDIA);
criteria.setBearingAccuracy(Criteria.ACCURACY_LOW);
criteria.setSpeedAccuracy(Criteria.ACCURACY_LOW);

List&lt;String&gt; matchingProviders = locationManager.getProviders(criteria,false);
</code></pre>

<h3 id="toc_80">确定当前位置</h3>

<h4 id="toc_81">找出上一次确定的位置</h4>

<p>通过使用getLastKnownLocation方法并传入某个Location Provider的名称作为参数</p>

<p><code>Location location = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);</code></p>

<h4 id="toc_82">刷新当前位置</h4>

<p>通过requestLocationUpdates方法使用LocationListener，可以请求定期更新位置变化。LocationListener还包含一些回调方法，可用于监听提供器的状态和可用性的变化。在为requestLocationUpdates方法指定参数时，可以使用特定Location Provider的名称，也可以提供一组条件来确定应该使用的提供器。为了提高效率并降低花费和电源消耗，还可以指定两次位置更新相隔的最短时间和最短距离。</p>

<pre class="line-numbers"><code class="language-text">String provider = LocationManager.GPS_PROVIDER;
int t = 5000;       //毫秒
int distance = 5;   //米
LocationListener myLocationListener = new LocationListener() {
    public void onLocationChanaged(Location location) {
        //基于新位置更新应用程序
    }
    
    public void onProviderDisabled(String provider) {
        //如果提供器被禁用，则更新应用程序
    }
    
    public void onProviderEnabled(String provider) {
        //如果提供器被启用，则更新应用程序
    }
    
    public void onStatusChanged(String provider,int status,Bundle extras) {
        //如果提供器硬件状态改变，则更新应用程序
    }
};
locationManager.requestLocationUpdates(provider,t,distance,myLocationListener);
</code></pre>

<p>同样，你可以指定一个Pending Intent，每当位置发生变化，或者Location Provider的状态或可用性发生变化，该Pending Intent就会被广播。新位置存储在一个extra钟，其key为KEY_LOCATION_CHANGED。如果有多个Activity或Service需要使用位置更新，可以通过这种方式监听相同的广播Intent。</p>

<pre class="line-numbers"><code class="language-text">String provider = LocationManager.GPS_PROVIDER;
int t = 5000;       //毫秒
int distance = 5;   //米
final int locationUpdateRC = 0;
int flags = PendingIntent.FLAG_UPDATE_CURRENT;

Intent intent = new Intent(this,MyLocationUpdateReceiver.class);
PendingIntent pendingIntent = PendingIntent.getBroadcast(this,locationUpdateRC,intent,flags);
locationManager.requestLocationUpdates(provider,t,distance,pendingIntent);
</code></pre>

<p>使用Passive Location Provider可以在其他应用程序请求位置更新的时候接收更新，但是无法控制更新何时发生。</p>

<h3 id="toc_83">请求单独一次位置更新</h3>

<p>并不是每个应用程序都需要定期的位置更新才能保持有用。很多时候，只要确定一次位置就可以为它们提供的功能或显示的信息提供足够的上下文。</p>

<pre class="line-numbers"><code class="language-text">Looper looper = null;
locationManager.requestSingleUpdate(criteria,myLocationListener,looper);
</code></pre>

<p>当使用Location Listener时，可以指定一个Looper参数，该参数允许你在特定的线程上来定时回调————将该参数设为null将强制在当前调用线程上返回。</p>

<h3 id="toc_84">位置更新优化</h3>

<ul>
<li>耗电量和精度 Location Provider的精度越高，耗电量越大</li>
<li>启动时间 在移动环境中，得到最初位置所用的时间对用户体验有显著的影响</li>
<li>更新频率 更新越频繁，电源消耗越大</li>
<li>提供器可用性 用户可以切换提供器的可用性，所以应用程序需要检测提供器状态的变化</li>
</ul>

<h3 id="toc_85">近距离提醒</h3>

<p>可以使用近距离设置一些Pending Intent，当设备移动到为某个固定位置指定的区域内或从该区域移出时他们就会触发。为了针对特定区域设置近距离提醒，需要选择一个中心点，绕该点的半径以及该提醒的超时时间。</p>

<pre class="line-numbers"><code class="language-text">private static final String TREASURE_PROXIMITY_ALERT = &quot;com.paad.treasurealert&quot;;

private void setProximityAlert() {
    String locDervice = Context.LOCATION_SERVICE;
    LocationManager locationManager = (LocationManager)getSystemService(locService);
    
    double lat = 73.147536;
    double lng = 0.510638;
    float radius = 100f;
    long expiration = -1;   //不会过期
    
    Intent intent = new Intent(TREASURE_PROXIMITY_ALERT);
    PendingIntent proximityIntent = PendingIntent.getBroadcast(this,-1,intent,0);
    locationManager.addProximityAlert(lat,lng,radius,expriation,proximityIntent);
}
</code></pre>

<h2 id="toc_86">Download Manager</h2>

<p>作为一个Service来优化长时间下载操作的处理。Download Manager通过处理HTTP连接、监控连接的变化和系统重新启动来确保每一次下载都能成功完成。<br/><br/>
要想访问Download Manager，可以使用getSystemService方法请求DOWNLOAD_SERVICE:  </p>

<pre class="line-numbers"><code class="language-text">String serviceString = Context.DOWNLOAD_SERVICE;
DownloadManager downloadManager = (DownloadManager)getSystemService(serviceString);
</code></pre>

<h3 id="toc_87">下载文件</h3>

<p>要想请求一个下载，需要创建一个新的DownloadManager.Request，指定要下载的文件的URI并把它传给Download Manager的enqueue。</p>

<pre class="line-numbers"><code class="language-text">String serviceString = Context.DOWNLOAD_SERVICE;
DownloadManager downloadManager = (DownloadManager)getSystemService(serviceString);
Uri uri = Uri.parse(&quot;http://developer.android.com/shareables/icon_templates-v4.0.zip&quot;);
DownloadManager.Request request = new Request(uri);
long reference = downloadManager.enqueue(request);
</code></pre>

<p>根据返回的引用值，可以对某个下载进行进一步的操作或者查询，包括查看状态或者取消下载。<br/><br/>
在Request对象中，可以通过分别调用</p>

<ul>
<li>addRequestHeader() 给请求添加HTTP报头</li>
<li>setMimeType() 重写服务器返回的MIME类型。</li>
<li>setAllowedNetworkTypes 可以限制下载类型为Wi-Fi或者移动网络</li>
<li>getReommendedMaxBytesOverMobile 它会返回一个在移动数据连接上传输时推荐的最大字节数来确定是否应该限制下载类型为Wi-Fi</li>
<li>enqueue 一旦连接可用且Download Manager空闲，就会开始下载</li>
</ul>

<p>要想在下载完成后收到一个通知，需要注册一个Receiver来接收ACTION_DOWNLOAD_COMPLETE广播，它将包含一个EXTRA_DOWNLOAD_ID extra，其中包含了已经完成下载的引用ID。</p>

<pre class="line-numbers"><code class="language-text">IntentFilter filter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
BroadcastReceiver receiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        long reference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);
        if (myDownloadReference == reference) {
            //对下载的文件进行一些操作
        }
    }
};
registerReceiver(receiver,filter);
</code></pre>

<p>通过调用Download Manager的openDownloadFile方法，可以获得文件的Parcel File Descriptor，查询Download Manager来得到文件的位置，或者如果已经指定了文件名和位置，那么直接操作这个文件。<br/><br/>
最好为ACTION_NOTIFICATION_CLICKED操作注册一个Receiver。每当用户从Notification任务栏或者Downloads应用中选择一个下载，那么这个Intent就会被广播。</p>

<pre class="line-numbers"><code class="language-text">IntentFilter filter = new IntentFilter(DownloadManager.ACTION_NOTIFICATION_CLICKED);
BroadcastReceiver receiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        String exrtaID = DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS;
        long[] references = intent.getLongArrayExtra(extraID);
        for (long reference : references) {
            if (myDownloadReference == reference) {
            //对下载的文件进行一些操作
            }       
        }
    }
};
registerReceiver(receiver,filter);
</code></pre>

<h3 id="toc_88">自定义Download Manager Notification</h3>

<p>默认情况下，会为Download Manager管理的每一个下载显示一个持续的Notification。每一个Notification都会显示当亲的下载进度和文件名。<br/><br/>
Download Manager可以为每个下载请求自定义Notification，包括把它完全隐藏。</p>

<ul>
<li>request.setTitle(&quot;&quot;) 设置通知标题</li>
<li>request.setDescription(&quot;&quot;) 设置通知文本</li>
</ul>

<p>通过setNotificationVisibility方法并使用下面的标识之一来控制何时以及是否应该为请求显示一个Notification:  </p>

<ul>
<li>Request.VISIBILITY_VISIBLE 当一个下载正在进行时，将显示一个持续的Notification标识持续时间。下载完成后，Notification将被移除。默认。</li>
<li>Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED 在下载期间会显示一个持续的Notification，即使下载完成也会继续显示(直到被选择或取消)</li>
<li>Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION 只有下载完成，Notification 才会显示</li>
<li>Request.VISIBILITY_HIDDEN 不为此下载显示Notification。为了设置这个标识，必须在manifest中添加DOWNLOAD_WITHOUT_NOTIFICATION权限。</li>
</ul>

<h3 id="toc_89">指定下载位置</h3>

<p>默认，Download Manager会把下载的文件保存到共享下载缓存中，而且使用系统生成的文件名。每一个请求对象都可以指定一个下载位置，但是所有的下载都必须存储到外部存储器中的某一个地方，而且应用程序必须在其清单中WRITE_EXTERNAL_STORAGE权限。</p>

<p><code>request.setDestinationUri(Uri.fromFile(f));</code></p>

<p>如果下载的文件用于你的应用程序，你可能希望把它放在应用程序的外部存储文件夹下。</p>

<p><code>request.setDestinationInExternalFilesDir(this,Environment.DIRECTORY_DOWNLOADS,&quot;Bugdroid.png&quot;);</code></p>

<p>对于那些都能够或者应该与其他应用程序共享的文件——特别是希望使用媒体扫描器扫描的文件，可以再外部存储器的公共目录下制定一个文件夹来存储该文件。</p>

<p><code>request.setDestinationInExternalPublicDir(Environment.DIRECTORY_MUSIC,&quot;Android_Rock.mp3&quot;);</code></p>

<p><strong>注意</strong>: 默认情况下Download Manager下载的文件不会被媒体扫描器扫描，因此它们可能不会显示在Gallery和Music Player等应用中。为了使下载的文件可以被扫描，可以再Request对象中调用allowScaningByMediaScanner。如果使你的文件对系统的Downloads应用是可见和可管理的，那么需要调用setVisibleInDownloadsUi，并传入true</p>

<h3 id="toc_90">取消和删除下载</h3>

<p>使用remove方法取消一个正在等待的下载，终止一个正在进行的下载，或者删除一个完成的下载。并且允许指定一个或者多个要取消的下载。</p>

<h3 id="toc_91">查询Download Manager</h3>

<p>可以通过query方法查询Download Manager来得到下载请求的状态、进度和详细信息。该方法会返回下载的Curosr对象。</p>

<p>query方法接收DownloadManager.Query对象作为参数，使用setFilterById方法给Query对象指定一个下载引用ID的序列，或者使用setFilterStatus方法来过滤下载的状态，该方法使用某个DownloadManager.STATUS_*常量来指定下载的运行、暂停、失败或成功。</p>

<p>Download Manager包含了很多COLUMN_*静态字符串常量，可以用它们来查询结果Cursor，可以得到每个下载的详细信息，包括状态、文件大小、目前下载的字节数、标题、描述、URI、本地文件名、媒体类型等。</p>

<pre class="line-numbers"><code class="language-text">@Override
public void onReceive(Context context,Intent intent) {
    long reference = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID,-1); if (myDownloadReference == reference) {
        Query myDownloadQuery = new Query();
        myDownloadQuery.setFilterById(reference);
        
        Cursor myDownload = downloadManager.query(myDownloadQuery);
        if (myDownload.moveToFirst()) {
            int fileNameIdx = myDownload.getColumnIndex(DownloadManager.COLUMN_LOCAL_FILENANE);
            int fileUriIDX = myDownload.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI);
            String fileName = myDownload.getString(fileNameIdx);
            String fileUri = myDownload.getString(fileUriIdx);
        
            //对下载文件进行一些操作
        }
        myDownload.close();
    }
}
</code></pre>

<p>针对下载暂停或失败的情形，可以通过查询COLUNMN_REASON列来得到其原因，该原因是由一个整数值来表示的。</p>

<ul>
<li>STATUS_PAUSED 通过使用DownloadManager.PAUSED_* 静态变量之一来解释原因。<br/></li>
<li>STATUS_FAILED 通过DownloadManager.ERROR_* 来确定失败的原因</li>
</ul>

<pre class="line-numbers"><code class="language-text">//获得Download Manager Service
String serviceString = Context.DOWNLOAD_SERVICE;
DownloadManager downloadManager = (DownloadManager)getSystemService(serviceString);

//为暂停的下载创建一个查询
Query pausedDownloadQuery = new Query();
pausedDownloadQuery.setFilterByStatus(DownloadManager.STATUS_PAUSED);

//查询Download Manager中暂停的下载
Cursor pausedDownloads = downloadManager.query(pasusedDownloadQuery);

//获得我们需要的数据的列索引
int reasonIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUNMN_REASON);
int titleIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_TITLE);
int fileSizeIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_TOTAL_SIZE_BYTES);
int bytesDLIdx = pausedDownloads.getColumnIndex(DownloadManager.COLUMN_BYTES_DOWNLOADS_SO_FAR);

//遍历结果Cursor
while(pausedDownloads.moveToNext()) {
    //从Cursor中提取需要的数据
    String title = pausedDownloads.getString(titleIdx);
    int fileSize = pausedDownloads.getInt(fileSizeIdx);
    int bytesDL = pausedDownloads.getInt(bytesDLIdx);
    
    //将暂停原因转化为友好的文本
    int reason = pausedDownloads.getInt(reasonIdx);
    String reasonString = &quot;Unknown&quot;;
    switch(reason) {
        case DownloadManager.PAUSEDD_QUEUED_FOR_WIFI:
            reasonString = &quot;Waiting for WiFi&quot;;
            break;
        case DownloadManager.PAUSEDD_WAITING_FOR_NETWORK:
            reasonString = &quot;Waiting for connectivity&quot;;
            break;
        case DownloadManager.PAUSEDD_WAITING_TO_RETRY:
            reasonString = &quot;Waiting to retry&quot;;
            break;
        default:
            break;
    }
    
    //构造一个状态概要
    StringBuilder sb = new StringBuilder();
    sb.append(title).append(&quot;\n&quot;);
    sb.append(reasonString).append(&quot;\n&quot;);
    sb.append(&quot;Downloaded&quot;).append(bytesDL).append(&quot; / &quot;).append(fileSize);
    
    //显示状态
    Log.d(&quot;DOWNLOAD&quot;,sb.toString());
}

//关闭结果Cursor
pausedDownloads.close();
</code></pre>

<h2 id="toc_92">文件保存</h2>

<p>Android在应用程序的上下文中提供了一些专门的实用工具文件管理</p>

<ul>
<li>deleteFile 使用户能够删除由当前应用程序所创建的文件</li>
<li>fileList 返回一个字符串数组，其中包含了由当前应用程序所创建的所有应用程序</li>
</ul>

<p>如果应用程序崩溃或者被意外终止，那么这些方法对于清理遗留的临时文件尤为有用。</p>

<h3 id="toc_93">特定于应用程序的文件夹存储文件</h3>

<ul>
<li>getDir 返回一个指向内部的应用程序文件存储目录路径的File对象</li>
<li>getExternalFilesDir 返回一个指向外部的应用程序文件存储目录路径的File对象(Environment.getExternalStorageDirectory)</li>
</ul>

<p>存储在应用程序文件夹中的文件应该是特定于父应用程序的而且通常不会被媒体扫描仪所侦测到，因此这些文件不会被自动添加到媒体库中。如果应用程序下载或者创建了应该添加到媒体库中的文件或者想要这些文件对其他应用程序也是可用的，可以放到公共的外部存储目录中。</p>

<h3 id="toc_94">创建私有的应用程序文件</h3>

<p>Android提供了openFileInput和openFileOutput方法来简化从应用程序沙箱中的文件读取数据流和向应用程序沙箱中的文件写入数据流的过程。<br/><br/>
这些方法只支持那些当前应用程序文件夹中的文件，指定路径分隔符将会导致抛出一个异常。<br/><br/>
在创建FileOoutputStream时，如果你指定的文件名不存在，Android会为你创建。对于已经存在的文件的默认行为就是覆盖它；想要在已经存在的文件末尾添加内容，可以指定其模式为Context.MODE_APPEND。默认情况下，使用openFileOutput方法创建的文件对于调用应用程序是私有的————其他应用程序会被拒绝访问。在不同应用程序间共享文件的标准方式是使用一个Content Provider。另外，当创建输出文件时，可以通过指定Context.MODE_WORLD_READABLE 或者 Context.MODE_WORLD_WRITEABLE 让它在其他应用程序中也是可用的。<br/><br/>
通过 getFilesDir 可以找到存储在你的沙箱中的文件的位置，这个方法将会返回使用openFileOutput所创建的文件的绝对路径。</p>

<h3 id="toc_95">使用应用程序文件缓存</h3>

<p>Android提供了一个可管理的内存缓存和一个不能管理的外部缓存。分别调用getCacheDir 和 getExternalCacheDir 方法可以从当前的上下文中访问它们。<br/><br/>
存储在任何一个该缓存位置中的文件在应用程序被卸载之后都会被删除。当系统运行在低可用存储空间的时候，存储在内部缓存中的文件可能会被系统所删除；存储在外部缓存中的文件则不会被删除，因为系统不会跟踪外部媒介的可用存储空间。</p>

<h3 id="toc_96">存储公共可读文件</h3>

<p>Environment.getExternalStoragePublicDirectory可以用来找到存储应用程序文件的路径。返回的位置为用户通常存放和管理他们自己的各种类型的文件的位置。  </p>

<pre class="line-numbers"><code class="language-text">File path = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC);
File file = new File(path,FILE_NAME);
try {
    path.mkdirs();
} catch (IOException e) {
    
}
</code></pre>

<ul>
<li>DIRECTORY_ALARMS 作为用户可选择的警示音的可用的声音文件</li>
<li>DIRECTORY_DCIM 设备拍到的图片和视频</li>
<li>DIRECTORY_DOWNLOADS 设备下载的文件</li>
<li>DIRECTORY_MOVIES 电影</li>
<li>DIRECTORY_MUSIC 代表音乐的音频文件</li>
<li>DIRECTORY_NOTIFICATIONS 作为用户可选择的通知音的可用的音频文件</li>
<li>DIRECTORY_PICTURES 图片</li>
<li>DIRECTORY_PODCASTS 代表播客的音频文件</li>
<li>DIRECTORY_RINGTONES作为用户可选择的铃声的可用的音频文件</li>
</ul>

<h2 id="toc_97">Service</h2>

<p>Android 提供Service类来专门创建用来处理生命周期操作的应用程序组件以及包括不需要用户界面的功能。Android赋予Service比处于非活动状态的Activity更高的优先级，因此当系统请求资源时，它们被终止的可能性更小。如果用户运行过早结束了一个已经启动Service，只要有足够的资源可用，则运行时就会重新启动它。必要的时候，一个Service的优先级可以提升到和前台Activity的优先级一样高。这是为了应对一些终止Service会显著影响用户体验的极端情况，如终止正在播放的音乐。通过使用Service，即使在UI不可见的时候也可以保证应用程序的持续运行。</p>

<h3 id="toc_98">Service简介</h3>

<h4 id="toc_99">创建和控制Service</h4>

<h5 id="toc_100">创建Service</h5>

<p>要定义一个Service，需要创建一个扩展Service的新类，需要重写onCreate和onBind方法。</p>

<pre class="line-numbers"><code class="language-text">public class MyService extends Service {
    @Override
    public void onCreate() {
        super.onCreate();
    }
    
    @Override
    public void onBind(Intent intent) {
        return null;
    }
}
</code></pre>

<p>创建一个新的Service后，必须将这个Service在应用程序的清单文件中进行注册，需要在application节点中包含一个service标记。</p>

<p><code>service android:enabled=&quot;true&quot; android:name=&quot;.MyService&quot;/&gt;</code></p>

<p>为了确保你的Service只能由自己的应用程序启动和停止，所需要在它的Service节点下添加一个permission属性</p>

<pre class="line-numbers"><code class="language-text">&lt;service 
    android:enabled=&quot;true&quot;
    android:name=&quot;.MyService&quot;
    android:permission=&quot;com.paad.MY_SERVICE_PERMISSION&quot;/&gt;
</code></pre>

<h5 id="toc_101">执行一个Service并控制它的重新启动行为</h5>

<p>重写onStartCommand事件处理程序以执行一个由Service封装的任务。在这个处理程序中，也可以指定Service的重新启动行为。当一个Service通过startService启动时，就会调用onStartCommand方法，所以这个方法可能在Service生命周期内被执行很多次。</p>

<p>Service是在应用程序的主线程中启动的，这意味着在onStartCommand处理程序中完成的任何处理都是运行在GUI主线程中的。实现Service的标准模式是从onStartCommand中创建和运行一个新线程，用来在后台执行处理，并在该线程完成后终止这个Service。</p>

<pre class="line-numbers"><code class="language-text">@Override
public int onStartCommand(Intent intent,int flags,int startId) {
    startBackgroundTask(intent,startId);
    return Service.START_STICKY;
}
</code></pre>

<p>通过以下的Service常量可以控制重新启动行为</p>

<ul>
<li>START_STICKY 描述了标准的重新启动行为。如果返回了这个值，那么在运行时终止Service后，当重新启动Service时，将会调用onStartCommand。注意，当重新启动Service后，传入onStartCommand的Intent参数将是null。这种模式通常用于处理自身状态的Service，以及根据需要通过startService和stopService显式地启动和终止的Service。这些Service包括播放音乐的Service或者处理其他持续进行的后台任务的Service。</li>
<li>START_NOT_STICKY 这种模式用于启动以处理特殊的操作和命令的Service。通常当命令完成后，这些Service会调用stopSelf终止自己。当被运行时终止后，只有当存在未处理的启动调用时，设为这个模式的Service才回重新启动。如果在终止Service后没有进行startService调用，那么Service将停止运行，而不会调用onStartCommand。对于处理特殊请求，尤其是诸如更新或者网络轮询这样的定期处理。</li>
<li>START_REDELIVER_INTENT 需要确保从Service中请求的命令得以完成。这种模式是前两种模式的组合。如果Service被运行时终止，那么只有当存在未处理的启动调用或进程在调用stopSelf之前被终止时，才会重新启动Service。后一种情况中，将会调用onStartCommand，冰纯如没有正常完成处理的Intent。</li>
</ul>

<p>由于对startService的调用不能嵌套，因此不管startService被调用了多少次，对stopService的一次调用就会终止它所匹配的运行中的Service。</p>

<h5 id="toc_102">自终止Service</h5>

<p>由于Service具有高优先级，它们通常不会被运行时终止，因此自终止可以显著地改善应用程序中的资源占用情况。通过在处理完成后显示地停止Service，可以避免系统仍然为使该Service继续运行而保留资源。当Service完成操作或处理后，应该调用stopSelf终止它。此时可以不传递参数，从而强制停止Service。也可以传入startId值，确保已经为目前调用的每个startService实例完成了处理。</p>

<h4 id="toc_103">将Service绑定到Activity</h4>

<p>Service可以和Activity绑定，后者会维持一个对前者实例的引用，此引用允许你像对待其他实例化的类那样，对正在运行的Service进行方法调用。允许Service和Activity绑定，这样能够获得更加详细的接口。要让一个Service支持绑定，需要实现onBind方法，并返回被绑定Service的当前实例。</p>

<pre class="line-numbers"><code class="language-text">@Override
public IBinder onBind(Intent intent) {
    return binder;
}

public class MyBinder extends Binder {
    MyMusicService getService() {
        return MyMusicService.this;
    }
}

private final IBinder binder = new MyBinder();
</code></pre>

<p>Servie和其他组件之间的连接表示为一个ServiceConnection。要想将一个Service和其他组件进行绑定，需要实现一个新的ServiceConnection，建立了一个连接之后，就可以通过重写onServiceConnected和onServiceDisconnected方法来获得对Service实例的引用。</p>

<pre class="line-numbers"><code class="language-text">//Service的引用
private MyMusicService serviceRef;

//处理Servie和Activity之间的连接
private ServiceConnection mConnection = new ServiceConnection() {
    public void onServiceConnected(ComponentName className,IBinder service) {
        //当建立连接时调用
        serviceRef = ((MyMusicService.MyBinder)service).getService();
    }
    
    public void onServiceDisconnected(ComponentName className) {
        //当Service意外断开时接收
        serviceRef = null;
    }
}
</code></pre>

<p>要执行绑定，需要在Activity中调用bindService，并传递给它一个用于选择要绑定到的Service的Intent以及一个ServiceConnection实现的实例。还可以指定很多的绑定标识。</p>

<pre class="line-numbers"><code class="language-text">//绑定一个Service
Intent bindIntent = new Intent(MyActivity.this,MyMusicService.class);
bindService(bindIntent,mConnection,Context.BIND_AUTO_CREATE);
</code></pre>

<ul>
<li>BIND_ADJUST_WITH_ACTIVITY 系统可以根据一个Service所绑定的Activity的相对重要重读来调整这个Service的优先级。因此，当Activity处于前台时，系统会提高Service的优先级。</li>
<li>BIND_IMPORTANT 和 BIND_ABOVE_CLIENT 对于正在绑定一个Service的客户端来说，这个Service非常重要。以至于客户端处于前台时，Service也应该变为前台进程。BIND_ABOVE_CLENT指定在内存很低的情况下，运行时会在终止绑定的Service之前先终止Activity。</li>
<li>BIND_NOT_FOREGROUND 确保绑定的Service永远不会拥有运行于前台的优先级。默认，绑定一个Service会提高它的优先级。</li>
<li>BIND_WAIVE_PRIORITY 表示绑定一个指定的Service不应该改变该Service的优先级。一旦Service被绑定，就可以通过从onServiceConnected处理程序获得的serviceBind对象来使用Service所有的共有方法和属性。</li>
</ul>

<p>如果你想和运行在不同进程中的Service进行通信，可以使用广播Intent的方式或者在启动Service的Intent中添加额外的Bundle数据。如果需要耦合更加紧密的连接，可以使用Android Interface Definition Language(AIDL),使Service可以跨应用绑定。</p>

<h4 id="toc_104">创建前台Service</h4>

<p>在Service需要直接和用户进行交互的情况下，把Service的优先级提升到与前台一样高，可以通过调用Service的startForeground方法以设置该Service在前台运行。由于需要直接进行交互，所以必须指定一个持续工作的Notification。</p>

<pre class="line-numbers"><code class="language-text">private void startPlayback(String album,String artist) {
    int NOTIFICATION_ID = 1;
    
    //创建一个当单机通知时将打开主Activity的Intent
    Intent intent = new Intent(this,MyActivity.class);
    PendingIntent pi = PendingIntent.getActivity(this,1,intent,0);
    
    //设置Notification UI参数
    Notificatin notification = new Notification(R.drawable.icon,&quot;Start Playback&quot;,System.cureentTimeMillis());
    notification.setLatestEventInfo(this,album,artis,pi);
    
    //设置Notification为持续显示
    notification.flags = notification.flags | Notification.FLAG_ONGOING_EVENT;
    
    //将Service移到前台
    startForeground(NOTIFICATION_ID, notification);
}
</code></pre>

<p>当Service不再需要前台运行的优先级时，可以使用stopForeground方法，把它移到后台，并可以选择是否移除通知。</p>

<pre class="line-numbers"><code class="language-text">public void pausePlayback() {
    //移到后台并移除Notification
    stopForeground(true);
}
</code></pre>

<h3 id="toc_105">使用后台线程</h3>

<p>Android中所有的应用程序组件包括Activity、Servie、Broadcast Receiver都在应用程序的主线程中运行，因此，任何组件中的费时处理都可能阻塞所有其他的组件，包括Service和可见Activity，我们需要避免出现未响应(Activity对一个输入事件在5秒的时间内没有响应，或者Broadcast Receiver在10秒内没有完成它的onReceive处理程序)。所以对于任何不用直接与用户界面进行交互的重要处理，使用后台线程技术是很重要的。将文件操作、网络查找、数据库事务、复杂计算调度到后台线程中完成尤其重要。</p>

<h4 id="toc_106">使用AsyncTask运行异步任务</h4>

<p>AsyncTask类为将耗时的操作移到后台线程并在操作完成后同步更新UI线程实现了最佳实践模式。它有助于将事件处理程序与GUI线程进行同步，允许通过更新视图和其他UI元素来报告进度，或者在任务完成后发布结果。AsyncTask处理线程创建、管理和同步等全部工作，它可以用来创建、管理和同步等全部工作，他可用来创建一个异步任务，该任务由两个部分完成:将在后台执行的处理以及在处理完成后执行的UI更新。<br/><br/>
AsyncTask对于生命周期较短且需要在UI上显示进度和结果的后台操作是很好的解决方案。然而当Activity重新启动的时候，这种操作将不会持续进行。AsyncTask在设备的方向变化而导致Activity被销毁和重新创建时会被取消。对于生命周期较长的后台操作，如从Internet下载数据，使用Service组件是更好的选择。</p>

<h5 id="toc_107">创建新的异步任务</h5>

<p>要创建一个新的异步任务，需要扩展AsyncTask类</p>

<pre class="line-numbers"><code class="language-text">private class MyAsyncTask extends AsyncTask&lt;String,Integer,String&gt; {
    @Override
    protected String doInBackground(String... parameter) {
        //移动到后台线程
        String result = &quot;&quot;;
        int myProgress = 0;
        int inputLength = parameter[0].length();
        
        //执行后台处理任务，更新myProgress
        for (int i = 1; i &lt;= inputLength;i++) {
            myProgress = i;
            result = result + parameter[0].charAt(inputLength - i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
            publishProgress(myProgress);
        }
        
        //返回一个值，它将传递给onPostExecute
        return result;
    }
    
    @Override
    protected void onProgressUpdate(Integer... progress) {
        //和UI线程同步
        //更新进度条、Notification或者其他UI元素
        asyncProgress.setProgress(progress[0]);
    }
    
    @Override
    protected void onPostExecute(String result) {
        //和UI线程同步
        //通过UI更新，Dialog或者Notification报告结果
        asyncTextView.setText(result);
    }
}
</code></pre>

<ul>
<li>doInBackground 这个方法将会在后台线程上执行，所以应该把运行时间较长的代码放到这里，而且不能视图再次处理程序中与UI对象交互。可以在本处理程序中调用publishProgress方法以传递参数值给onProgressUpdate处理程序，当后台任务完成后，可以返回最终的结果并作为参数传递给onPostExecute处理程序。</li>
<li>onProgressUpdate 当中间进度更新变化时更新UI。</li>
<li>onPostExecute 后台任务结束，更新UI</li>
</ul>

<h5 id="toc_108">运行异步任务</h5>

<p>调用execute来执行它，每个AsyncTask实例只能执行一次。如果试图第二次调用execute，则会抛出一个异常。</p>

<pre class="line-numbers"><code class="language-text">String input = &quot;redrum ... redrum&quot;;
new MyAsyncTask().execute(input);
</code></pre>

<h4 id="toc_109">Intent Service简介</h4>

<p>Intent Service是一个非常方便的包装类，根据需求执行一组任务的后台Service实现了最佳实践模式。如Internet的循环更新或者数据处理。其他应用程序组件要想通过Intent Service完成一个任务，需要启动Service并传递给它一个包含完成该任务所需的参数的Intent。<br/><br/>
Intent Service会将收到的所有请求Intent放到队列中，并在异步后台线程中逐个地处理它们。当处理完每个收到的Intent后，Intent Service就会终止它自己。Intent Service处理所有的复杂工作，如将多个请求放入队列，后台线程的创建、UI线程的同步。</p>

<pre class="line-numbers"><code class="language-text">public class MyIntentService  extends IntentService {
    public MyIntentService(String name) {
        super(name);
        //完成任何需要的构造函数任务
    }
    
    @Override
    public void onCreate() {
        super.onCreate();
        //创建Service时要执行的操作
    }
    
    @Override
    protected void onHandleIntent(Intent intent) {
        //这个处理程序发生在一个后台线程中
        //耗时任务应该在此实现
        //传入这个IntentService的每个Intent将被逐个处理，当所有传入的Intent都被处理后，该Service会终止自己。
    }
}
</code></pre>

<p>一旦收到Intent请求，onHandleIntent处理程序就会在一个工作线程中执行。对于按需或者固定时间间隔执行一组任务，Intent Service是创建这种Service的最佳方法。</p>

<h4 id="toc_110">Loader简介</h4>

<p>它封装用于在UI元素中进行异步数据加载的最佳实践技术。如果想要创建一个自己的Loader实现，通常最佳实践是扩展AsyncTaskLoader而不是直接扩展Loader</p>

<ul>
<li>异步加载数据</li>
<li>监控要加载的数据源并自动提供更新结果</li>
</ul>

<h4 id="toc_111">手动创建线程和GUI线程同步</h4>

<h5 id="toc_112">Thread</h5>

<pre class="line-numbers"><code class="language-text">Thread thread = new Thread(null,new Runnable() {
    public void run() {
    }
},&quot;Background&quot;);
thread.start();
</code></pre>

<pre class="line-numbers"><code class="language-text">runOnUiThread(new Runnable() {
    public void run() {
        //更新一个View或者其他Activity UI元素
    }
});
</code></pre>

<h5 id="toc_113">Handler</h5>

<p>使用Handler类的post方法将更新从后台线程发布到用户界面上。</p>

<pre class="line-numbers"><code class="language-text">//在主线程上初始化一个handler
private Handler handler = new Handler();
//在主UI线程上使用Handler发布doUpdateGUI Runnable
handle.post(doUpdateGUI)
//执行更新UI的Runnable
private Runnable doUpdateUI = new Runnable() {
    public void run() {
        updateGUI();
    }
}
</code></pre>

<h3 id="toc_114">使用Alarm</h3>

<p>Alarm是一种在预先确定的时间或时间间隔内激活Intent的方法。和Timer不同，Alarm是在应用程序之外操作的，所以即使应用程序关闭，它们也仍然能够用来激活应用程序事件或操作。当它们和Broadcast Receiver一起使用时会更加强大，允许设置能够激活广播Intent、启动Service、甚至启动Activity的Alarm，而不需要打开或者运行应用程序。<br/><br/>
Alarm是降低应用程序资源需求的一种极为有效的方式。可以使用Alarm实现基于网络查找的定时更新，或者把费时的或者成本受约束的操作安排在“非高峰”时期运行，又或者对失败的操作调度重试。Alarm在设备处于休眠状态时依然保持活动状态，可以有选择地设置Alarm来唤醒设备。无论何时重启设备，所有的Alarm都会被取消。</p>

<h4 id="toc_115">创建、设置和取消Alarm</h4>

<p>要创建一个新的只激活一次的Alarm，可以使用set方法指定一个Alarm类型、触发时间和一个要激活的Pending Intent。如果把Alarm的触发时间设置为过去的时间，那么它将会被立即触发。</p>

<ul>
<li>RTC_WAKEUP 在指定的时间唤醒设备，并激活Pending Intent。</li>
<li>RTC 在指定的时间点激活Pending Intent,但是不会唤醒设备。</li>
<li>ELAPSED_REALTIME 根据设备启动之后经过的时间激活Pending Intent，但是不会唤醒设备。经过的时间包含设备休眠的所有时间。</li>
<li>ELAPSED_REALTIME_WAKEUP 在设备启动并经过指定的时间之后唤醒设备和激活Pending Intent。</li>
</ul>

<pre class="line-numbers"><code class="language-text">//获取一个Alarm Manager的引用
AlarmManager alarmManager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);

//如果设备处于休眠状态，设置Alarm来唤醒设备
int alarmType = AlarmManager.ELAPSED_REALTIME_WAKEUP;

//10秒钟后触发设备
long timeOrLengthofwait = 10000;

//创建能够广播和操作的Pending Intent
String ALARM_ACTION = &quot;ALARM_ACTION&quot;;
Intent intentToFire = new Intent(ALARM_ACTION);
PendingIntent alarmIntent = PendingIntent.getBroadcast(this,0,intentToFire,0);

//设置Alarm
alarmManager.set(alarmType,timeOrLengthofWait,alarmIntent);
</code></pre>

<p>当触发Alarm时，就会广播指定的Pending Intent。因此，使用相同的Pending Intent设置第二个Alarm会替代已经存在的Alarm。<br/><br/>
要取消一个Alarm，需要调用Alarm Manager的cancel方法，并传递给它不再想触发的Pending Intent。</p>

<h4 id="toc_116">设置重复Alarm</h4>

<p>重复Alarm和一次性的Alarm具有相同的工作方式，不过会在指定的时间间隔内重复触发。<br/><br/>
因为Alarm是在应用程序生命周期之外设置的，所以它们十分适合于调度定时更新或者数据查找，从而避免了在后台持续运行Service。<br/><br/>
当需要对重复Alarm的精确时间间隔进行细粒度控制时，可以使用setReating方法。传入这个方法的时间间隔可以用于指定Alarm的确切时间间隔，最多可以精确到毫秒。<br/><br/>
当按照计划定时唤醒设备来执行更新时会消耗电池的电量，setInexactRepeating方法能够帮助减少这种电量消耗。在运行时，Android会同步多个没有精确指定时间间隔的重复Alarm，并同时触发它们。</p>

<ul>
<li>INTERVAL_FIFTEEN_MINUTES</li>
<li>INTERVAL_HALF_HOUR</li>
<li>INTERVAL_HOUR</li>
<li>INTERVAL_HALF_DAY</li>
<li>INTERVAL_DAY</li>
</ul>

<pre class="line-numbers"><code class="language-text">//获取一个Alarm Manager的引用
AlarmManager alarmManager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);

//如果设备处于休眠状态，设置Alarm来唤醒设备
int alarmType = AlarmManager.ELAPSED_REALTIME_WAKEUP;

//调度Alarm以每半小时重复一次
long timeOrLengthofWait = AlarmManager.INTERVAL_HAL_HOUR;

//创建能够广播和操作的Pending Intent
String ALARM_ACTION = &quot;ALARM_ACTION&quot;
Intent intentToFire = new Intent(ALARM_ACTION);
PendingIntent alarmIntent = PendiingIntent.getBroadcast(this,0,intentToFire,0);

//每半小时唤醒设备以激活一个Alarm
alarmManager.steInexactRepeating(alarmType,timeOrLengthofWait,timeOrLengthofWait,alarmIntent);
</code></pre>

<blockquote>
<p>设置定期重复Alarm会对电池电量产生显著的影响。最好将Alarm频率限制为 最低可接受频率，只在必要时唤醒设备。</p>
</blockquote>

<h2 id="toc_117">硬件传感器</h2>

<h3 id="toc_118">受支持的传感器</h3>

<ul>
<li>Sensor.TYPE_AMBIENT_TEMPERATURE 这是一个温度计，返回以摄氏度表示的温度。返回的温度表示的是环境的室温。</li>
<li>Sensor.TYPE_ACCELEROMETER 一个三轴的加速计传感器，返回三个坐标轴的当前加速度，单位为m/s2</li>
<li>Sensor.TYPE_GRAVITY 一个三轴的重力传感器，返回当前的方向和三个坐标轴上的重力分量，单位为m/s2。通常，重力传感器是通过对加速计传感器的结果应用一个低通过滤器，作为一个虚拟传感器实现。</li>
<li>Sensor.TYPE_LINEAR_ACCELERATION 一个三轴的线性加速度传感器，返回三个坐标轴上不包括重力的加速度，单位为m/s2。与重力传感器一样，线性加速度通常是加速计输出，作为一个虚拟传感器实现的。只是为了得到线性加速，对加速计输出应用了高通过滤器。</li>
<li>Sensor.TYPE_GYROSCOPE 一个陀螺仪传感器，以弧度/秒返回了三个坐标轴上的设备旋转速度。可以对一段时间内的旋转速率求积分，以确定设备的当前方向，但是更好的做法是结合其他传感器来使用这个传感器以得到更加平滑和校正后的结果。</li>
<li>Sensor.TYPE_ROTATION_VECTOR 返回设备的方向，表示为三个轴的角度的组合。通常用作传感器管理器的getRotationMatrixFormVector方向的输入，以便将返回的旋转向量转换为旋转矩阵。旋转向量传感器一般被实现为一个虚拟传感器，它可以组合并校正多个传感器得到的结果，以提供更加平滑的矩阵。</li>
<li>Sensor.TYPE_MAGNETIC_FIELD 一个磁力传感器，返回三个坐标轴上的当前磁场，单位为microteslas。</li>
<li>Sensor.TYPE_PRESSURE 一个气压传感器，返回当前的大气压力，单位为millibars。通过使用传感器管理器的getAltitude方法来比较两个位置的气压值，可以把气压传感器用于确定海拔高度。</li>
<li>Sensor.TYPE_RELATIVE_HUMIDITY 一个相对湿度传感器，以百分比的形式返回当前的相对湿度</li>
<li>Sensor.TYPE_PROXIMITY 一个近距离传感器，以厘米为单位返回设备和目标对象之间的距离。</li>
<li>Sensor.TYPE_LIGHT 一个环境光传感器，返回一个以lux为单位的值，用于描述环境光的亮度。</li>
</ul>

<h3 id="toc_119">查找传感器</h3>

<p>//查找所有传感器</p>

<pre class="line-numbers"><code class="language-text">SensorManager sensorManager = (SensorManager)getSystemService(service_name);
List&lt;Sensor&gt; allSensor = sensorManager.getSensorList(Sensor.TYPE_ALL);
</code></pre>

<p>查找可用的特定类型传感器,可以传入指定所需要的传感器类型。如果指定的传感器类型有多个传感器实现，可以通过查询每个返回的Sensor对象来决定使用哪个传感器。每个Sensor对象都会报告其名称、用电量、最小延迟、最大工作范围、分辨率和供应商的类型。</p>

<p>如何选择一个工作范围最大并且耗电量最低的光传感器，以及校正过的陀螺仪</p>

<pre class="line-numbers"><code class="language-text">List&lt;Sensor&gt; lightSensors = sensorManager.getSensorList(Sensor.TYPE_LIGHT);
List&lt;Sensor&gt; gyroscopes = sensorManager.getSensorList(Sensor.TYPE_GYROSCOPE);

Sensor bestLightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
Sensor correctedGyro = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);

if (bestLightSensor != null) {
    for (Sensor lightSensor : lightSensors) {
        float range = lighSensor.getMaximumRnage();
        float power = lightSensor.getPower();
        
        if (range &gt;= bestLightSensor.getMaximumRange()) {
            if (power &lt; bestLightSensor.getPower() || range &gt; bestLightSensor.getMaximumRange()) {
                bestLightSensor = lightSensor;
            }
        }
    }
}

if (gyroscope != null &amp;&amp; gyroscopes.size() &gt; 1) {
    correctedGyro = gyroscopes.get(gyroscopes.size() - 1);
}
</code></pre>

<h3 id="toc_120">监视传感器</h3>

<p>为监视传感器，需要实现一个SensorEventListener，使用onSensorChanged方法监视传感器值，使用onAccuracyChanged方法响应传感器精确度的变化。</p>

<pre class="line-numbers"><code class="language-text">final SensorEventListener mySensorEventListener = new SensorEventListener() {
    public void onSensorChanged(SensorEvent sensorEvent) {
        //监视传感器改变
    }
    
    public void onAccuracyChanged(Sensor sensor,int accuracy) {
        //对传感器精确度的改变做出反应
    }
}
</code></pre>

<p>onSensorChanged方法中的SensorEvent参数包含以下4中用于描述一个传感器事件的属性</p>

<ul>
<li>sensor 触发该事件的Sensor对象</li>
<li>accuracy 当事件发生时传感器的精确度(low,medium,high 或 unreliable)</li>
<li>values 包含了已检测到的新值得浮点型数组</li>
<li>timestamp 传感器事件发生的时间</li>
</ul>

<p>onAccuracyChanged方法单独监视传感器精确度的变化，accuracy传感器精确度，表示的常量</p>

<ul>
<li>SensorManager.SENSOR_STATUS_ACCURACY_LOW 表示传感器的精确度很低并且需要校准</li>
<li>SensorManager.SENSOR_STATUS_ACCURACY_MEDIUM 表示传感器数据具有平均精确度，并且校准可能会改善报告的结果</li>
<li>SensorManager.SENSOR_STATUS_ACCURACY_HIGH 表示传感器使用的是最高精确度</li>
<li>SensorManager.SENSOR_STATUS_UNRELIABLE 表示传感器数据不可靠，这意味着需要校准该传感器或者当前不能读数</li>
</ul>

<pre class="line-numbers"><code class="language-text">Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
sensorManager.register(mySensorEventListener,sensor,SensorManager.SENSOR_DELAY_NORMAL);
</code></pre>

<ul>
<li>SENSOR_DELAY_FASTEST 指定可以实现的最快更新速率</li>
<li>SENSOR_DELAY_GAME 指定适合控制游戏的更新速率</li>
<li>SENSOR_DELAY_NORMAL 指定默认的更新速率</li>
<li>SENSOR_DELAY_UI 指定适合更新UI的速率</li>
</ul>

<h3 id="toc_121">应用</h3>

<ul>
<li>使用指南针和加速计确定用户的朝向和设备方向。将它们与地图、摄像头和基于位置的服务一起使用，可以创建出增强现实UI，这种UI可以使用基于位置的数据叠加在摄像头实时播放的画面之上。</li>
<li>创建能够动态调整以适应用户设备的方向的UI。</li>
<li>通过监视快速的加速度来检测设备是否已经在掉落或者被抛掉</li>
<li>测量移动或者振动。</li>
<li>创建能够使用物理动作和移动作为输入的UI控件</li>
</ul>

<h4 id="toc_122">找到当前的屏幕旋转方向</h4>

<pre class="line-numbers"><code class="language-text">WindowManager wm = (WindowManager)getSystemService(Context.WINDOW_SERVICE);
Display display = wm.getDefaultDisplay();
int rotation = display.getRotation();
switch(rotation) {
    case (Surface.ROTATION_0) : break;  //Natural
    case (Surface.ROTATION_90) : break; //On its left side
    case (Surface.ROTATION_180) : break;    //Upside down
    case (Surface.ROTATION_270) : break; //On its right side
    default: break;
}
</code></pre>

<h4 id="toc_123">计算方向</h4>

<pre class="line-numbers"><code class="language-text">private float[] accelerometerValues;
private float[] magneticFieldValues;

final SensorEventListener myAccelerometerListener = new SensorEventListener() {
    public void onSensorChanged(SensorEvent sensorEvent) {
        if (sensorEvent.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
            accelerometerValues = sensorEvent.values;
        }
    }
    
    public void onAccuracyChanged(Sensor sensor,int accuracy);
};

final SensorEventListener myMagneticFieldListener = new SensorEventListener() {
    public void onSensorChanged(SensorEvent sensorEvent) {
        if (sensorEvent.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) {
            magneticFieldValues = sensorEvent.values;
        }
    }
    public void onAccuracyChanged(Sensor sensor,int accuracy) {}
}

SensorManager sm = (SensorManager)getSystemService(Context.SENSOR_SERVICE);
Sensor aSensor = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
Sensor mfSensor = sm.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);

sm.registerListener(myAccelerometerListener,aSensor,SensorManager.SEENSOR_DELAY_UI);
sm.registerListener(myMagneticFieldListener,mfSensor,SensorManager.SENSOR_DELAY_UI);

float[] values = new float[3];
float[] R = new float[9];
SensorManager.getRotationMatrix(R,null,accelerometerValues,magneticFieldValues);
SensorManager.getOrientation(R,values);

//Convert from radians to degrees if preferred
values[0] = (float) Math.toDegrees(values[0]);
values[1] = (float) Math.toDegrees(values[1]);
values[2] = (float) Math.toDegrees(values[2]);
</code></pre>

<ul>
<li>values[0] 当设备朝向磁北时，方位角为0</li>
<li>values[1] 俯仰角，即绕x轴的旋转</li>
<li>values[2] 横滚角，即绕y轴的旋转</li>
</ul>

<h2 id="toc_124">个性化屏幕</h2>

<h3 id="toc_125">主屏幕Widget</h3>

<p>Widget可以使我们的应用程序直接在用户主屏幕上拥有一块交互式的屏幕面板以及一个入口点。一个好的App Widget可以用最少的资源开销提供有用的、精确的和及时的信息。<br/><br/>
App Widgets作为BroadcastReceivers实现，它们使用RemoteViews来创建和更新寄存在另一个应用程序进程中的视图层次结构。为了创建一个应用程序的Widget，我们需要建立以下三个组件</p>

<ul>
<li>一个定义了该WidgetUI的XML布局资源</li>
<li>一个描述了与该Widget相关联的元数据的XML文件</li>
<li>一个定义并控制该Widget的Intent接收器</li>
</ul>

<h4 id="toc_126">创建Widget的XML布局资源</h4>

<p>最佳做法是使用XML将自己的Widget布局定义为一个外部布局资源，但是在Broadcast Receiver的onCreate方法中通过编程方式布局自己的UI也是同样可行的。<br/><br/>
Widget完成支持透明背景，并允许使用NinePatches和部分透明的Drawable资源。</p>

<p><strong>受支持的Widget视图和布局</strong></p>

<ul>
<li>所有的自定义视图</li>
<li>由允许的视图所派生的视图</li>
<li>EditText</li>
<li>FrameLayout</li>
<li>LinearLayout</li>
<li>RelativeLayout</li>
<li>GridLayout</li>
<li>AnalogClock</li>
<li>Button</li>
<li>ImageButton</li>
<li>ImageView</li>
<li>ProgressBar</li>
<li>TextView</li>
<li>ViewFlipper</li>
</ul>

<h4 id="toc_127">定义Widget设置</h4>

<p>Widget定义资源作为XML存储在项目的res/xml文件夹中，appwidget-provider标签使我们能够描述Widget元数据。</p>

<ul>
<li>initialLayout 创建Widget UI 时用到的布局资源</li>
<li>minWidth/minHeight 分别表示Widget的最小宽度和最小高度</li>
<li>resizeMode 通过使用horizontal和vertical的组合来设置resizeMode允许你指定Widget在哪个方向上进行调整。将它设置为none则会禁止调整Widget的大小。</li>
<li>label 在Widget选取器中用户Widget所用到的标题</li>
<li>updatePreiodMillis 以毫秒为单位表示的Widget更新的最小周期。Android将会以这个速率唤醒设备以便更新用户Widget，，因此应当将其指定为至少一个小时。App Widget Manger最快不能以每30分钟一次的速率进行更新。</li>
<li>configure 当将用户Widget添加到主屏幕中时，可以有选择地指定启动一个完全限定的Activity。</li>
<li>icon 默认情况下，Android在Widget选取器中呈现Widget时，会使用应用程序的图标。通过指定一个Drawable资源，可以使用一个不同的图标。</li>
<li>previewImage 用于显示Widget的预览，而不是显示其图标。</li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;appwidget-provider
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:initialLayout=&quot;@layout/my_widget_layout&quot;
    android:minWidth=&quot;110dp&quot;
    android:minHeight=&quot;110dp&quot;
    android:label=&quot;@string/widget_label&quot;
    android:updatePeriodMillis=&quot;360000&quot;
    android:resizeMode=&quot;horizontal|vertical&quot;
    android:previewImage=“@drawable/widget_preview”&gt;
</code></pre>

<h4 id="toc_128">创建Widget Broadcast Receiver并将其添加到应用程序的manifest文件中</h4>

<p>Widget是作为Broadcast Receiver实现的。每个Widget的Broadcast Receiver都指定Intent Filter，用于监听使用AppWidget.ACTION_APPWIDGET_UPDATE、DELETED、ENABLED以及DISABLED动作请求更新的Broadcast Intent</p>

<pre class="line-numbers"><code class="language-text">public class SkeletonAppWidget extends AppWidgetProvider {
    @Override
    public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds) {
        //更新Widget UI
    }
    
    @Override
    public void onDeleted(Context context,int[] appWidgetIds) {
        //处理删除Widget的操作
        super.onDeleted(context,appWidgetIds);
    }
    
    @Override
    public void onDisabled(Context context) {
        //Widget已被禁用
        super.onDisabled(context);
    }
    
    @Override
    public void onEnabled(Context context) {
        //Widget已被启用
        super.onEnabled(context);
    }
}
</code></pre>

<p>Widget必须被添加到应用程序的manifest文件中，像其他Broadcast Receiver一样使用一个receiver标签。为了将一个Broadcast Receiver指定为一个App Widget，需要下面两个标签添加到它的manifest文件节点中。</p>

<ul>
<li>一个用于android.appwidget.action.APPWIDGET_UPDATE动作的Intent Filter</li>
<li>一个对appwidget-provider 元数据XML资源的引用。</li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;receiver android:name=&quot;.MyAppWidget&quot; android:label=&quot;@string/widget_label&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;/&gt;
    &lt;/intent-filter&gt;
    &lt;meta-data
        android:name=&quot;android.appwidget.provider&quot;
        android:resource=&quot;@xml/widget_provider_info&quot;/&gt;
&lt;/receiver&gt;
</code></pre>

<h4 id="toc_129">AppWidgetManager 和 RemoteView</h4>

<p>AppWidgetManager类用于更新App Widget和提供App Widget的相关信息<br/><br/>
RemoteView类用于在另一个应用程序的进程中托管的View层次的代理，从而允许修改运行在另一个应用程序中的View的属性。</p>

<h5 id="toc_130">RemoteView</h5>

<pre class="line-numbers"><code class="language-text">RemoteViews views = new RemoteViews(context.getPackageName(),R.layout.my_widget_layout);
views.setInt(R.id.widget_image_view,&quot;setImageLevel&quot;,2);    //设置ImageView的image level
views.setBoolean(R.id.widget_text_view,&quot;setCursorVisible&quot;,true);    //显示TextView的光标
views.setBitmap(R.id.widget_image_button,&quot;setImageBitmap&quot;,myBitmap);  //将一个位图分配给一个ImageButton
views.setTextViewText(R.id.widget_text,&quot;Updated Text&quot;);
views.setTextColor(R.id.widget_text,Color.BLUE);
views.setImageViewResource(R.id.widget_image,R.drawable.icon);
views.setProgressBar(R.id.widget_progressbar,100,50,false);
views.setChronometer(R.id.widget_chronometer,SystemClock.elapsedRealtime,null,true);
views.setViewVisibility(R.id.widget_text,View.INVISIBLE);
</code></pre>

<h5 id="toc_131">将RemoteView应用到运行中的App Widget</h5>

<p>要将对RemoteView所做的修改应用到处于活动状态的Widget，需要使用AppWidgetManager的updateAppWidget方法，并传入一个或更多个要更新的Widget的标识符和要应用的RemoteView作为其参数。</p>

<p><code>appWidgetManager.updateAppWidget(appWidgetIds,remoteViews);</code></p>

<pre class="line-numbers"><code class="language-text">@Override
public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds) {
    //在迭代每个widget的过程中，创建一个RemoteViews对象并将修改后的RemoteViews应用到每个Widget
    final int N = appWidgetIds.length;
    for(int i = 0;i &lt; N;i++) {
        int appWidgetId = appWidgetIds[i];
        
        //创建一个RemoteViews对象
        RemoteViews views = new RemoteViews(context.getPackageName(),R.layout.my_widget_layout);
        
        //更新UI,通知AppWidgetManager使用修改后的过程view更新widget
        appWidgetManager.updateAppWidget(appWidgetId,views);
    }
}
</code></pre>

<p>也可以直接从一个Service、Activity或Broadcast Receiver更新Widget。为此，需要调用AppWidgetManager的getInstance静态方法并传入当前上下文，以获得AppWidgetManager的引用</p>

<pre class="line-numbers"><code class="language-text">//获得AppWidgetManager
AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
//获得所选的Widget的每个实例的标识符
ComponentName thisWidget = new ComponentName(context,MyAppWidget.class);
int[] appWidgetIds = appWidgetManager.getAppWidgetIds(thisWidget);
//迭代每个Widget的过程中，创建一个RemoteViews对象并将修改后的RemoteViews应用到每个Widget
for (int i = 0;i &lt; N;i++) {
    int appWidgetId = appWidgetIds[i];
    //创建一个RemoteViews对象
    RemoteViews views = new RemoteViews(context.getPackageName(),R.layout.my_widget_layout);
    
    //使用views对象更新Widget的UI
    //通知AppWidgetManager使用修改后的远程View更新Widget
    appWidgetManager.updateAppWidget(appWidgetId,views);
}
</code></pre>

<h5 id="toc_132">使用RemoteViews为Widget添加交互性</h5>

<p>因为大多数主屏幕应用程序都在完整权限下运行，所以潜在的安全风险变得十分严峻。因而，Widget的交互性是被严格控制的。</p>

<ul>
<li>添加监听一个或更多个View的Click Listener</li>
<li>根据所选项变化改变UI</li>
<li>在Collection View Widget中的View之间过滤</li>
</ul>

<blockquote>
<p>Android不支持直接在App Widget中输入文本。如果需要在Widget中输入文本，最佳实践是添加该Widget的一个Click Listener，让它显示一个用于接受输入的Activity。</p>
</blockquote>

<p>使用Click Listener，要向Widget添加交互性，最简单、最强大的方法是添加其View的Click Listener。</p>

<pre class="line-numbers"><code class="language-text">Intent intent = new Intent(context,MyActivity.class);
PendingIntent pendingIntent = PendingIntent.getActivity(context,0,intent,0);
views.setOnClickPendingIntent(R.id.widget_text,pendingIntent);
</code></pre>

<h3 id="toc_133">Collection View Widget简介</h3>

<p>这是一种新型的Widget，用于将数据集合显示为列表、网格或层叠卡片样式</p>

<ul>
<li>StackView 一个卡片View，以层叠方式显示其子View。这叠“卡片将从集合的头至尾自动循环。用户可以向上或向下滑动手指，进行切换”</li>
<li>ListView 集合中的每个项目都作为垂直列表中的一行进行显示</li>
<li>GridView 一个二维的可滚动列表，每个项目都显示在网格的一个单元格中。</li>
</ul>

<h4 id="toc_134">创建 RemoteViewsService</h4>

<p>RemoteViewsService用作一个实例化和管理RemoteViewsFactory的包装器，而RemoteViewsFactory则用来提供在Collection View Widget中显示的每个View。为创建RemoteViewsService需要扩展RemoteViewsService类，并通过重写onGetViewFactory处理程序来返回RemoteViewsFactory的一个新实例。和任何Service一样，需要使用一个service标签把RemoteViewsService添加到应用程序的manifest文件中。为防止其他应用程序访问你的Widget，必须指定android.permission.BIND_REMOTEVIEWS权限。</p>

<h4 id="toc_135">创建一个RemoteViewsFactory</h4>

<p>RemoteViewsFactory是Adapter类的一个包装器，用于创建和填充将在Collection View Widget中显示的View ———— 实际上是将它们与底层的数据集合绑定到一起。</p>

<pre class="line-numbers"><code class="language-text">class MyRemoteViewsFactory implements RemoteViewsFactory {
    private ArrayList&lt;String&gt; myWidgetText = new ArrayList&lt;String&gt;();
    private Context context;
    private Intent intent;
    private int widgetId;
    
    public MyRemoteViewsFactory(Context context,Intent intent) {
        this.context = context;
        this.intent = intent;
        widgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,AppWidgetManager.INVALID_APPWIDGET_ID);
    }
    
    //设置数据源的任何连接，繁重的工作，例如下载数据，应该推迟到onDataSetChanged()或getViewAt()中执行这个调用的时间超过20秒会导致一个ANR
    public void onCreate() {
        myWidgetText.add(&quot;The&quot;);
        myWidgetText.add(&quot;quick&quot;);
        myWidgetText.add(&quot;brown&quot;);
        myWidgetText.add(&quot;fox&quot;);
        myWidgetText.add(&quot;jumps&quot;);
        myWidgetText.add(&quot;over&quot;);
        myWidgetText.add(&quot;the&quot;);
        myWidgetText.add(&quot;lazy&quot;);
        myWidgetText.add(&quot;droid&quot;);
    }
    
    //当显示的底层数据集合被修改时调用。可以使用AppWidgetManager的notifyAppWidgetViewDataChanged()方法来触发这个处理程序
    public void onDataSetChanged() {
        //底层数据改变时进行处理
    }
    
    //返回正在显示的集合中的项数
    public int getCount() {
        return myWidgetText.size();
    }
    
    //如果每个项提供的唯一ID是稳定的————即它们不会在运行时改变，就返回true
    public boolean hasStableIds() {
        return false;
    }
    
    //返回与位于指定索引位置的项目关联的唯一ID
    public long getItemId(int index) {
        return index;
    }
    
    //不同View定义的数量
    public int getViewTypeCount() {
        return 1;
    }
    
    //可选地制定一个“加载”View进行显示
    public RemoteViews getLoadingView() {
        return null;
    }
    
    //创建并填充将在指定索引位置显示的View
    public RemoteViews getViewAt(int index) {
        //创建将在所需索引位置显示的View
        RemoteViews rv = new RemoteViews(context.getPackageName,R.layout.my_stack_widget_item_layout);
        
        //使用底层数据填充View
        rv.setTextViewText(R.id.widget_title_text,myWidgetText.get(index));
        rv.setTextViewText(R.id.widget_text,&quot;View Number: &quot; + String.valueOf(index));
        
        //创建一个特定于项的填充Intent，用于填充在App Widget Provider中创建的Pending
        Intent filInIntent = new Intent();
        fillInIntent.putExtra(Intent.EXTRA_TEXT,myWidgetText.get(index));
        rv.setOnClickFillInIntent(R.id.widget_title_text,fillInIntent);
        return rv;
    }
    
    //关闭连接、游标或者onCreate中创建的其他任何持久状态
    public void onDestroy() {
        myWidgetText.clear();
    }
}
</code></pre>

<h4 id="toc_136">使用RemoteViewsService填充CollectionViewWidget</h4>

<p><code>Intent intent = new Intent(context,MyRemoteViewsService.class);</code></p>

<p>RemoteViewsService内的onGetViewFactory处理程序会收到这个Intent，从而使你能够向Service和它包含的Factory传递额外的参数。还需要指定要绑定的Widget的ID，这样可以为不同的Widget实例指定不同的Service。通过使用setEmptyView方法，可以指定一个当且仅当底层数据集合为空时显示的View。在完成绑定之后，使用App Widget Manager的updateAppWidget方法将绑定应用到指定的Widget上</p>

<pre class="line-numbers"><code class="language-text">Intent intent = new Intent(context,MyRemoteViewsService.class);
intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetId);
views.setRemoteAdapter(appWidgetId,R.id.widget_stack_view,intent);
</code></pre>

<h4 id="toc_137">向Collection View Widget中的项添加交互性</h4>

<p>出于效率原因，无法向作为Collection View Widget一部分显示的每个项分配唯一的onClickPendingIntent。需要使用setPendingIntentTemplate向Widget分配一个模板Intent</p>

<pre class="line-numbers"><code class="language-text">Intent templateIntent = new Intent(Intent.ACTION_VIEW);
templateIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,appWidgetId);
PendingIntent templatePendingIntent = PendingIntent.getActivity(context,0,templateIntent,PendingIntent.FLAG_UPDATE_CURRENT);
views.setPendingIntentTemplate(R.id.widget_stack_view,templatePendingIntent);
</code></pre>

<h4 id="toc_138">将Collection View Widget绑定到Content Provider</h4>

<p>Collection View Widget最强大的用途之一就是将Content Provider中的数据呈现到主屏幕上。</p>

<pre class="line-numbers"><code class="language-text">class MyRemoteViewsFactory implements RemoteViewsFactory {
    private Context context;
    private ContentResolver cr;
    private Cursor c;
    
    public MyRemoteViewsFactory(Context context) {
        //获得对应程序上下文机器Content Resolver的引用
        this.context = context;
        cr = context.getContextResolver();
    }
    
    public void onCreate() {
        //执行一个查询来返回将要显示的数据的游标，任何辅助的查找或解码操作应在onDataSetChanged处理程序中完成
        c = cr.query(MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,null,null,null,null);
    }
    
    public void onDataSetChanged() {
        // 任何辅助的查找、处理或解码可以在这里同步完成，只有这个方法完成后，Widget才回被更新
    }
    
    public int getCount() {
        //返回游标中的项数
        if (c != null) {
            return c.getCount();
        } else {
            return 0;
        }
    }
    
    public long getItemId(int index) {
        //返回与特定项关联的唯一ID
        if (c != null) {
            return c.getInt(c.getColumnIndex(MediaStore.Images.Thumbnails._ID));
        } else {
            return index;
        }
    }
    
    public RemoteViews getViewAt(int index) {
        //将游标移动到请求的行位置
        c.moveToPosition(index);
        
        //从需要的项中提取数据
        int idIdx = c.getColumnIndex(MediaStore.Images.Thumbnails._ID);
        String id = c.getString(idIdx);
        Uri uri = Uri.withAppendedPath(MediaStore.Images.Thumbnails.EXTERNAL_CONTENT_URI,&quot;&quot; + id);
        
        //使用合适的项布局创建一个新的RemoteViews对象
        RemoteViews rv = new RemoteViews(context.getPackageName(),R.layout.my_media_widget_item_layout);
        //将从游标中提取的值赋给RemoteViews
        rv.setImageViewUri(R.id.widget_media_thumbnail,uri);
        
        //分配一个特定于项的填充Intent，用于填充在App Widget Provider中指定的Pending Intent模板。在这里，模板指定了一个ACTION_VIEW动作
        Intent fillInIntent = new Intent();
        fillInIntent.setData(uri);
        rv.setOnClickFillInIntent(R.id.widget_media_thumbnail,fillInIntent);
        return rv;
    }
    
    public int getViewTypeCount() {
        //要使用的不同View定义的数量
        //对于Content Provider，这个值几乎总是1
        return 1;
    }
    
    public boolean hasStableIds() {
        //Content Provider的ID应该是唯一并且永久的
        return true;
    }
    
    public void onDestroy() {
        //关闭结果游标
        c.close();
    }
    
    public RemoteViews getLoadingView() {
        //使用默认的加载View
        return null;
    }
}
</code></pre>

<h4 id="toc_139">刷新Collection View Widget</h4>

<p>App Widget Manager中包含的notifyAppWidgetViewDataChanged方法允许指定一个要更新的Widget ID(或ID数组)，以及该Widget中底层数据源已经发生变化的集合View的资源ID</p>

<p><code>appWidgetManager.norifyAppWidgetViewDataChanged(appWidgetIds,R.id.widget_stack_view);</code></p>

<p>这将会导致相关的RemoteViewsFactory的onDataSetChanged处理程序执行，然后进行元数据调用，最后再重新创建每个View。</p>

<h2 id="toc_140">Media Palyer</h2>

<p>Android中的音频和视频的播放通常由MediaPlayer类进行处理。使用Media Player，我们能够播放存储在应用程序资源、本地文件、Content Provider或者来自网络URL的流式传输中的媒体。</p>

<h3 id="toc_141">准备音频播放</h3>

<p>为了使用Media Player播放音频内容，需要创建一个新的Media Player对象，并设置该音频的数据源。为此，可以使用静态create方法，并传入Activity的上下文以及下列音频源中的一种:</p>

<ul>
<li>一个资源标识符(通常用于存储在res/raw文件夹中的音频文件)</li>
<li>一个本地文件的URI(使用file://模式)</li>
<li>一个在线音频资源的URI(URI格式)</li>
<li>一个本地Content Provider(它应该返回一个音频文件)的行的URI</li>
</ul>

<pre class="line-numbers"><code class="language-text">//从一个包资源加载音频资源
MediaPlayer resourcePlayer = MediaPlayer.create(this,R.raw.my_audio);

//从一个本地文件加载音频资源
MediaPlayer filePlayer = MediaPlayer.create(this,Uri.parse(&quot;file:///sdcard/localfile.mp3&quot;));

//从一个在线资源加载音频资源
MediaPlayer urlPlayer = MediaPlayer.create(this,Uri.parse(&quot;http://site.com/audio/audio.mp3&quot;));

//从一个Content Provider加载音频资源
MediaPlayer contentPlayer = MediaPlayer.create(this,Settings.System.DEFAULT_RINGTONE_URI);
</code></pre>

<p>通过create方法返回的Media Player对象已经调用了prepare。也可以使用现有的MediaPlayer实例的setDataSource方法，必须在开始播放之前调用prepare方法。</p>

<pre class="line-numbers"><code class="language-text">MediaPlayer mediaPlayer = new MediaPlayer();
mediaPlayer.setDataSource(&quot;/sdcard/mydopetunes.mp3&quot;);
mediaPlayer.perpare();
</code></pre>

<h3 id="toc_142">准备视频播放</h3>

<p>视频内容的播放比音频播放稍微复杂一些。为了显示一个视频，首先必须为该视频指定一个Surface。</p>

<h4 id="toc_143">使用VideoView播放视频</h4>

<p>播放视频最简单的方法是使用VideoView类。VideoView包含了一个Surface，用于显示视频，以及封装和管理Media Player以控制视频的播放。</p>

<pre class="line-numbers"><code class="language-text">//分配本地文件以进行播放
videoView.setVideoPath(&quot;/sdcard/mycatvideo.3gp&quot;);
//分配一个远程视频流的URI
videoView.setVideoUri(myAwesomeStreamingSource);
</code></pre>

<p>当视频初始化完成后，可以使用start、stopPlayback、pause和seekTo方法控制播放，还可以使用setKeepScreenOn方法以应用一个屏幕Wake Lock。</p>

<pre class="line-numbers"><code class="language-text">//配置VideoView并分配一个视频来源
videoView.setKeepScreenOn(true);
videoView.setVideoPath(&quot;/sdcard/mycatvideo.3gp&quot;);

//附加一个Media Controller
MediaController mediaController = new MediaController(this);
videoView.setMediaController(mediaController);
</code></pre>

<h4 id="toc_144">使用Media Player播放</h4>

<p>使用Media Player直接查看视频内容首先使用一个SurfaceView对象显示视频。SurfaceView类是SufaceHolder对象的包装器，后者是Surface的包装器，而Surface用于支持来自后台线程的可视化更新。<br/><br/>
SurfaceHolder是异步创建的，因此必须等到surfaceCreated处理程序被触发，然后再通过实现SurfaceHolder.Callback接口将返回的SurfaceHolder对象分配给Media Player。<br/><br/>
在创建和分配SurfaceHolder给Media Player之前，使用setDataSource方法来指定要播放的视频资源的路径、URI或Content Provider URI。<br/><br/>
在选择了媒体资源后，调用prepare来初始化Media Player，以准备进行播放。</p>

<pre class="line-numbers"><code class="language-text">public class SurfaceViewVideoViewActivity extends Activity implements SurfaceHolder.Callback {
    static final String TAG = &quot;SurfaceViewVideoViewActivity&quot;;
    
    private MediaPlayer mediaPlayer;
    
    public void surfaceCreated(SurfaceHolder holder) {
        try {
            //创建Surface后，将其作为显示表面，并分配和准备一个数据源
            mediaPlayer.setDisplay(holder);
            mediaPlayer.setDataSource(&quot;/sdcard/test2.3gp&quot;);
            mediaPlayer.prepare();
        } catch (IllegalArgumentException e) {
            Log.e(TAG,&quot;Illegal Argument Exception&quot;, e);
        } catch (IllegalStateException e) {
            Log.e(TAG,&quot;Illegal State Exception&quot;, e);
        } catch (SecurityException e) {
            Log.e(TAG,&quot;Security Exception&quot;, e);
        } catch (IOException e) {
            Log.e(TAG,&quot;IO Exception&quot;, e);
        }
    }
    
    public void surfaceDestroyed(SurfaceHolder holder) {
        mediaPlayer.release();
    }
    
    public void surfaceChanged(SurfaceHolder holder,int format,int width,int height) {
        
    }
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        setContentView(R.layout.surfaceviewvideoviewer);
        
        //创建一个新的Media Player
        mediaPlayer = new MediaPlayer();
        
        //获得对SurfaceView的引用
        final SurfaceView surfaceView = (SurfaceView) findViewById(R.id.surfaceView);
        
        //配置SurfaceView
        surfaceView.setKeepScreenOn(true);
        
        //配置SurfaceHolder并注册回调
        SurfaceHolder holder = surfaceView.getHolder();
        holder.addCallback(this);
        holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
        holder.setFixedSize(400,300);
        
        //连接播放按钮
        Button playButton = (Button) findViewById(R.id.buttonPlay);
        playButton.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                mediaPlayer.start();
            }
        });
        
        //连接暂停按钮
        Button pauseButton = (Button) findViewById(R.id.buttonPause);
        pauseButton.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                mediaPlayer.pause();
            }
        });
        
        //添加跳过按钮按钮
        Button skipButton = (Button) findViewById(R.id.buttonSkip);
        skipButton.setOnClickListener(new OnClickListener() {
            public void onClick(View v) {
                mediaPlayer.skip();
            }
        });
    }
}
</code></pre>

<p>MediaPlayer提供了getDuration方法以查找所播放媒体的长度，以及getCurrentPosition方法以查找当前的播放位置。可以使用seekTo方法跳转到媒体中的某个特定位置。为了保持一致的媒体控制体验，Android包含了一个MediaController。这是一个标准的控件，提供了常用的媒体控制按钮。</p>

<pre class="line-numbers"><code class="language-text">MediaController mediaController = new MediaController(this);
mediaController.setMediaPlayer(new MediaPlayerController() {
    public boolean canPause() {
        return true;
    }
    
    public boolean canSeekBackward() {
        return true;
    }
    
    public boolean canSeekForward() {
        return true;
    }
    
    public int getBufferPercentage() {
        return 0;
    }
    
    public int getCurrentPosition() {
        return mediaPlayer.getCurrentPosition();
    }
    
    public int getDuration() {
        return mediaPlayer.getDuration();
    }
    
    public boolean isPlaying() {
        return mediaPalyer.isPalying();
    }
    
    public void pause() {
        mediaPlayer.pause();
    }
    
    public void seekTo(int pos) {
        mediaPlayer.seekTo(pos);
    }
    
    public void start() {
        mediaPlayer.start();
    }
})

meidaController.setAnchorView(myView);    //设置当MediaController可见时包含在哪个视图
mediaController.show();    //显示
mediaController.hide();     //隐藏
</code></pre>

<h4 id="toc_145">管理媒体播放输出</h4>

<p>MediaPlayer提供了一些方法以控制输出音量、锁定播放期间的屏幕亮度以及设置循环状态。</p>

<ul>
<li>setVolum(0.5f,0.5f);  控制播放过程中的每个声道的音量。左右声道采用了一个0到1之间的标量浮点数值</li>
<li>setScreenOnWhilePlaying(true);  强制屏幕在视频播放期间不变暗</li>
<li>isLooping();  确定当前的循环状态</li>
<li>setLooping(true);  指定所播放的媒体在播放完成时是否应当继续循环播放</li>
</ul>

<h4 id="toc_146">响应Media播放控件。</h4>

<p>一些设备带有播放、停止、暂停、下一首和前一首媒体播放按键。用户按下这些按键时，系统会广播一个带有ACTION_MEDIA_BUTTON动作的Intent。</p>

<pre class="line-numbers"><code class="language-text">&lt;receiver android:name=&quot;.MediaControlReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MEDIA_BUTTON&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>

<p>这个BroadcastReceiver在接收到媒体按键被按下的动作时，会创建一个包含相同extra的新Intent，并把该Intent广播给播放音频的Activity</p>

<pre class="line-numbers"><code class="language-text">public class MediaControlReceiver extends BroadcastReceiver {
    public static final String ACTION_MEDIA_BUTTON = &quot;com.paad.ACTION_MEDIA_BUTTON&quot;;
    
    @Override
    public void onReceive(Context context,Intent intent) {
        if (Intent.ACTION_MEDIA_BUTTON.equals(intent.getAction())) {
            Intent internalIntent = new Intent(ACTION_MEDIA_BUTTON);
            internalIntent.putExtra(intent.getExtras());
            context.sendBroadcast(internalIntent);
        }
    }
}
</code></pre>

<p>被按下的媒体按键的代码存储在接收到的Intent的EXTRA_KEY_EVENT extra中</p>

<pre class="line-numbers"><code class="language-text">public class ActivityMediaControlReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context,Intent intent) {
        if (MediaControlReceiver.ACTION_MEDIA_BUTTON.equals(intent.getAction())) {
            KeyEvent event = (KeyEvent) intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
            switch(event.getKeyCode()) {
                case (KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) :
                    if (mediaPlayer.isPlaying()) {
                        pause();
                    }
                    break;
                case (KeyEvent.KEYCODE_MEDIA_PLAY) :
                    play();
                    break;
                case (KeyEvent.KEYCODE_MEDIA_PAUSE) :
                    pause();
                    break;
                case (KeyEvent.KEYCODE_MEDIA_NEXT) :
                    skip();
                    break;
                case (KeyEvent.KEYCODE_MEDIA_PREVIOUS) :
                    previous();
                    break;
                case (KeyEvent.KEYCODE_MEDIA_STOP) :
                    stop();
                    break;
                default:
                    break;
            }
        }
    }
}
</code></pre>

<p>如果应用程序希望在Activity不可见时仍在后台播放音频，让Media Player在Service保持运行，并使用Intent来控制媒体播放。<br/><br/>
给定的设备上可能安装了多个应用程序，每个应用程序都被配置为接收媒体按键按下动作，因此必须使用AudioManager的registerMediaButtonEventReceiver放阿飞将接收者注册为媒体按键按下动作的唯一处理程序。</p>

<pre class="line-numbers"><code class="language-text">//注册媒体按键事件Receiver来监听媒体按钮按下动作
AudioManager am = (AudioManager)getSystemService(Context.AUDIO_SERVICE);
ComponentName component = new ComponentName(this,MediaControlReceiver.class);

am.registerMediaButtonEventReceiver(component);

//注册一个本地Intent Receiver，用于接收在manifest文件中注册的Receiver，媒体按键按下动作。
activityMediaControlReceiver = new ActivityMediaControlReceiver();
IntentFilter filter = new IntentFilter(MediaControlReceiver.ACTION_MEDIA_BUTTON);
registerReceiver(activityMediaControlReceiver,filter);
</code></pre>

<h4 id="toc_147">请求和管理音频焦点</h4>

<p>用户的设备上可能有多个媒体播放器，因此当另一个媒体应用程序获得焦点时，让你的应用程序暂停播放并交出媒体按键的控制权。</p>

<p><strong>显示了一个请求音乐流永久占有音频焦点</strong></p>

<pre class="line-numbers"><code class="language-text">AudioManager am = (AudioManager)getSystemService(Context.AUDIO_SERVICE);
//请求音频焦点
int result = am.requestAudioFocus(focusChangeListener,AudioManager.STREAM_MUSIC,AudioManager.AUDIOFOCUS_GAIN);
if (result == AduioManager.AUDIOFOCUS_REQUEST_GRANTED) {
    mediaPlayer.start();
}
</code></pre>

<p>音频焦点将依次分配给每个请求音频焦点的应用程序。这意味着如果另一个应用程序请求音频焦点，你的应用程序就会失去音频焦点。你在请求音频焦点时注册的Audio Focus Change Listener的onAudioFocusChange处理程序将会通知你焦点丢失的情况。</p>

<pre class="line-numbers"><code class="language-text">private OnAudioFocusChangeListener focusChangeListener = new OnAudioFocusChangeListener() {
    public void onAudioFocusChange(int focusChange) {
        AudioManager am = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
        switch(focusChange) {
            case (AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK):
                //降低音量
                mediaPlayer.setVolume(0.2f,0.2f);
                break;
            case (AudioManager.AUDIOFOCUS_LOSS_TRANSIENT):
                pause();
                break;
            case (AudioManager.AUDIOFOCUS_LOSS):
                stop();
                ComponentName component = new ComponentName(AudioPlayerActivity.this,MeidaControlReceiver.class);
                am.unregisterMediaButtonEventReceiver(component);
                break;
            case (AudioManager.AUDIOFOCUS_GAIN):
                //将音量恢复到正常大小，并且如果音频流已被暂停，则恢复音频流
                mediaPlayer.setVolume(1f,1f);
                mediaPlayer.start();
                break;
            default:
                break;
        }
    }
}
</code></pre>

<p>完成音频播放后，可以选择放弃音频焦点</p>

<p><code>am.abandonAudioFocus(focusChangeListener);</code></p>

<p>如果当前的输出流在入耳式耳机上播放，那么拔出耳机时，系统会自动将输出切换到设备的扬声器。这种情况下，暂停音频输出或者减小音量是一个很好的做法。</p>

<pre class="line-numbers"><code class="language-text">private class NoisyAudioStreamReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context,Intent intent) {
        if(AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())){
            pause();
        }
    }
}
</code></pre>

<h4 id="toc_148">Remote Control Client</h4>

<p>应用程序可以向能够显示元数据、图片和媒体传输控制按键的远程控件提供数据，并响应这些远程控件。</p>

<pre class="line-numbers"><code class="language-text">AudioManager am = (AudioManager)getSystemService(Context.AUDIO_SERVICE);
//创建一个将会广播媒体按键按下动作的Pending Intent。将目标组件设为你的Broadcast Receiver
Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
ComponentName component = new ComponentName(this,MediaControlReceiver.class);
mediaButtonIntent.setComponent(component);
PendingIntent mediaPendingIntent = PendingIntent.getBroadcast(getApplicationContext(),0,meidaButtonIntent,0);
//使用PendingIntent创建一个新的Remote Control Client，并把它注册到Audio Manager中
myRemoteControlClient = new RemoteControlClient(mediaPendingInent);
am.registerRemoteControlClient(myRemoteControlClient);
</code></pre>

<h2 id="toc_149">操纵原始音频</h2>

<p>使用AudioTrack和AudioRecord类可以直接从音频输入硬件录制音频，以及直接将PCM音频缓冲区中的音频流输出到音频硬件来进行播放。使用Audio Track流式传输时，可以接近实时地处理和播放传入的音频，这就允许你操纵传入或传出的音频，以及对原始音频进行信号处理。</p>

<h3 id="toc_150">使用AudioRecord录制声音</h3>

<pre class="line-numbers"><code class="language-text">int frequency = 11025;
int channelConfiguration = AudioFromat.CHANNEL_CONFIGURATION_MONO;
int audioEncoding = AudioFromat.ENCODING_PCM_16BIT;

File file = new File(Environment.getExternalStorageDirectory(),&quot;raw.pcm&quot;);

//创建新文件
try {
    file.createNewFile();
} catch (IOException e) {
    Log.d(TAG,&quot;IO Exception&quot;, e);
}

try {
    OutputStream os = new FileOutputStream(file);
    BufferedOutputStream bos = new BufferedOutputStream(os);
    DataOutputStream dos = new DataOutputStream(bos);
    
    int bufferSize = AudioRecord.getMinBufferSize(frequency,channelConfiguration,audioEncoding);
    short[] buffer = new short[bufferSize];
    
    //创建一个新的AudioRecord对象来录制音频
    AudioRecord audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC,frequency,channelConfiguration,audioEncoding,bufferSize);
    audioRecord.startRecording();
    
    while(isRecording) {
        int bufferReadResult = audioRecord.read(buffer,0,bufferSize);
        for (int i = 0;i &lt; bufferReadResult;i++) {
            dos.writeShort(buffer[i]);
        }
    }
    
    audioRecord.stop();
    dos.close();
} catcg (Throwable t) {
    Log.d(TAG,&quot;An error occurred during recording&quot;,t);
}
</code></pre>

<h3 id="toc_151">使用AudioTrack播放音频</h3>

<p>使用AudioTrack类可以将原始音频直接播放到硬件缓冲区中。</p>

<pre class="line-numbers"><code class="language-text">int frequency = 11025 / 2;
int channelConfiguration = AudioFromat.CHANNEL_CONFIGURATION_MONO;
int audioEncoding = AudioFormat.ENCODING_PCM_16BIT;

File file = new File(Environment.getExternalStorageDirectory(),&quot;raw.pom&quot;);

//用于存储音轨的short数组
int audioLength = (int)(file.length() / 2);
short[] audio = new short[audioLength];

try {
    InputStream is = new FileInputStream(file);
    BufferedInputStream bis = new BufferedInputStream(is);
    DataInputStream dis = new DataInputStream(bis);
    
    int i = 0;
    while(dis.available() &gt; 0) {
        audio[i] = dis.readShort();
        i++;
    }
    
    //关闭输入流
    dis.close();
    
    //创建和播放新的AudioTrack对象
    AudioTrack audioTrack = new AudioTrack(AudioManager.STREAM_MUSIC,frequency,channelConfiguration,audioEncoding,audioLength,AudioTrack.MODE_STREAM);
    audioTrack.play();
    audioTrack.write(audio,0,audioLength);
} catch (Throable t) {
    Log.d(TAG,&quot;An error occurred during playback&quot;,t);
}
</code></pre>

<h2 id="toc_152">使用Sound Pool</h2>

<p>当应用程序需要低音频延迟并且将同时播放多个音频流时，可以使用SoundPool类来管理音频。创建一个SoundPool会预加载应用程序试用的音轨，并优化它们的资源管理。<br/><br/>
创建SoundPool时，可以指定要播放的最大并发流数。当达到这个值时，SoundPool就会自动停止池内最老的、优先级最低的流，从而将音频混合的影响降到最低。</p>

<pre class="line-numbers"><code class="language-text">int maxStreams = 10;
SoundPool sp = new SoundPool(maxStreams,AudioManager.STREAM_MUSIC,0);

int strack1 = sp.load(R.raw.track1,0);
int strack2 = sp.load(R.raw.track2,0);
int strack3 = sp.load(R.raw.track3,0);
</code></pre>

<h3 id="toc_153">使用音效</h3>

<p>可以修改效果设置和参数，以改变在应用程序内输出的音频的效果。</p>

<ul>
<li>Equalizer 可以修改音频输出的频率响应。使用setBandLevel方法可以为特定的频带指定一个增益值。</li>
<li>Virtualizer 使音频的立体声效果更强。它的实现会随输出的设备的配置而发生变化。使用setStrength方法可以将音效的强度设置为0 - 1000</li>
<li>BassBoost 增强音频输出的低音音频。使用setStrength方法可以将音效的强度设置为0 - 1000</li>
<li>PresetReverb 允许指定多个混声预设值之一。</li>
<li>EnvironmentalIReverb 允许通过控制音频输出来模拟不同环境的效果。</li>
</ul>

<h2 id="toc_154">摄像头</h2>

<h3 id="toc_155">使用Intent拍摄照片</h3>

<p><code>startActivityForResult(new Intent(MediaStore.ACTION_IMAGE_CAPTURE), TAKE_PICTURE);</code></p>

<p>这将启动一个Camera应用程序来拍摄照片，不需要你重写原生Camera应用程序，就可以为用户提供全套的摄像头功能。用户对拍摄的照片感到满意后，该照片就会通过onActivityResult处理程序收到的Intent返回给应用程序。默认情况下，拍摄的照片将作为一个缩略图返回。</p>

<pre class="line-numbers"><code class="language-text">//创建输出文件
File file = new File(Environment.getExternalStorageDirectory(),&quot;test.jpg&quot;);
Uri outputFileUri = Uri.fromFile(file);
//生成Intent
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
intent.putExtra(MediaStore.EXTRA_OUTPUT,outputFileUri);
//启动摄像头应用程序
startActivityForResult(intent,TAKE_PICTURE);

@Override
protected void onActivityResult(int requestCode, int resultCode,Intent data) {
    if (requestCode == TAKE_PICTURE) {
        //检查结果是否包含缩略图
        if (data != null) {
            if (data.hasExtra(&quot;data&quot;)) {
                Bitmap thumbnail = data.getParcelableExtra(&quot;data&quot;);
                imageView.setImageBitmap(thumbnail);
            }
        } else {
            //如果没有缩略图数据，则说明图像存储在目标输出URI中
            int width = imgaeView.getWidth();
            int height = imageView.getHeight();
            
            BitmapFactory.Options factoryOptions = new BitmapFactory.Options();
            factoryOptions.inJustDecodeBounds = true;
            BitmapFactory.decodeFile(outputFileUri.getPath(),factoryOptions);
            int imageWidth = factoryOptions.outWidth;
            int imageHeight = factoryOptions.outHeight;
            
            //确定将图像缩小多少
            int scaleFactor = Math.min(imageWidth / width,imageHeight / height);
            
            //将图像文件解码为图像大小以填充视图
            factoryOptions.inJustDecodeBounds = false;
            factoryOptions.inSampleSize = scaleFactor;
            factoryOptions.inPurgeable = true;
            
            Bitmap bitmap = BitmapFactory.decodeFile(outputFileUri.getPath(), factoryOptions);
            imageView.setImageBitmap(bitmap);
        }
    }
}
</code></pre>

<h3 id="toc_156">直接控制摄像头</h3>

<p>为了直接访问摄像头硬件，添加权限<code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</code></p>

<pre class="line-numbers"><code class="language-text">Camera camera = Camera.open();
camera.release();
</code></pre>

<h4 id="toc_157">摄像头属性</h4>

<p>使用Camera对象的getParameters方法可以得到Camera.Parameters对象，然后可以使用该对象存储摄像头设置，可以获得摄像头的许多属性和当前对焦的场景。</p>

<ul>
<li>SceneMode 使用一个SCENE_MODE_* 静态常量返回或设置所拍摄的场景的类型。每个场景模式都为特定的场景类型(聚会、海滩、日落等)优化了摄像头参数的配置。</li>
<li>FlashMode 使用一个FLASH_MODE_*静态常量返回或设置当前的闪光模式(打开、关闭、红眼消减、闪光灯)</li>
<li>WhiteBalance 使用一个WHITE_BALANCE_*静态常量返回或设置白平衡校正来校正场景。</li>
<li>AutoWhiteBalanceLock 当使用自动白平衡时，启用自动白平衡锁会暂停颜色校正算法，从而确保连续拍摄的多张照片使用相同的颜色平衡设置。当拍摄全景照片或者为高动态光照渲染图像使用包围曝光时，这种做法特别有用，使用<code>isAutoWhiteBalanceLockSupported</code>方法可以确认设备是否支持这种功能。</li>
<li>ColorEffect 使用一个EFFECT_*静态常量返回或设置应用到图像的特殊颜色效果。使用<code>getSupportedColorEffects</code>方法可以找出可用的颜色效果</li>
<li>FocusMode 使用一个<code>FOCUS_MODE_*</code>静态常量返回或设置摄像头尝试对焦的方式。使用<code>getSupportedFocusModes</code>方法可以找出可用的模式</li>
<li>Antibanding 使用一个<code>ANTIBANDING_*</code>静态常量返回或设置用来降低条带效果的屏幕刷新频率。使用<code>getSupportedAntibanding</code>方法可以找出可用的频率</li>
</ul>

<p>使用CameraParameters来读取或指定图像、缩略图和摄像头预览的大小、质量和格式参数</p>

<ul>
<li>JPEG和缩略图质量 使用<code>setJpegQuality</code>和<code>setJpegThumbnailQuality</code>方法，并传入0到100之间的整型数值</li>
<li>图像、预览和缩略图大小 分别使用<code>setPictureSize</code>、<code>setPreviewSize</code>和<code>setJpegThumbnailSize</code>参数指定图像、预览和缩略图的高度和宽度。</li>
<li>图像和预览像素格式 使用<code>PixelFormat</code>类中的一个静态常量调用<code>setPictureFormat</code>和<code>setPreviewFormat</code>可以设置图像的格式</li>
<li>预览帧速率 <code>setPreviewFpsRange</code>方法可以用来指定预览的首选帧率范围。使用<code>getSupportedPreviewFpsRange</code>方法可以找出所支持的最低和最高帧率</li>
</ul>

<h4 id="toc_158">使用摄像头预览</h4>

<p>在实现自己的摄像头时，需要显示摄像头捕获的内容的一个预览，以便用户可以选择拍摄什么样的照片。显示摄像头的流式传输视频还意味着我们能够将实时视频融入到应用程序中，例如实现增强现实。摄像头预览是使用SurfaceHoder显示的，所以要在应用程序中查看实时摄像头流，必须在UI层次中包含一个Surface View，需要实现一个SurfaceHolder.Callback来监听有效表面的构建，然后该表面传递给Camera对象的setPreviewDisplay方法。</p>

<pre class="line-numbers"><code class="language-text">public class CameraActivity extends Activity implements SurfaceHolder.Callback {
    private static final String TAG = &quot;CameraActivity&quot;;
    private Camera camera;
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        
        SurfaceView surface = (SurfaceView)findViewById(R.id.surfaceView);
        SurfaceHolder holder = surface.getHolder();
        holder.addCallback(this);
        holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
        holder.setFixedSize(400,300);
    }
    
    public void surfaceCreated(SurfaceHolder holder) {
        try {
            camera.setPreviewDisplay(holder);
            camera.startPreview();
            //必要时在预览上进行绘制
        } catch (IOException e) {
            Log.d (TAG,&quot;IO Exception&quot;, e);
        }
    }
    
    public void surfaceDestroyed(SurfaceHolder holder) {
        camera.stopPreview();
    }
    
    public void surfaceChanged(SurfaceHolder holder,int format,int width,int height) {
        
    }
    
    @Override
    protected void onPause() {
        super.onPause();
        camera.release();
    }
    
    @Override
    protected void onResume() {
        super.onResume();
        camera = Camera.open();
    }
}
</code></pre>

<p>还可以分配一个PreviewCallback，使其在每个预览中触发，以便可以实时操纵或者分析每个预览帧。需要调用Camera对象的setPreviewCallback方法，并传入一个重写了onPreviewFrame方法的新的PreviewCallback实现。</p>

<pre class="line-numbers"><code class="language-text">camera.setPreviewCallback(new PreviewCallback() {
    public void onPreviewFrame(byte[] data,Camera camera) {
        int quality = 60;
        Size previewSize = camera.getParameters().getPreviewSize();
        YuvImage image = new YuvImage(data,ImageFormat.NV21,previewSize.width,previewSize.height,null);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        
        image.compressToJpeg (new Rect(0 ,0,previewSize.width,previewSize.height),quality,outputStream);
        //对预览图像执行一些操作
    }
})
</code></pre>

<h4 id="toc_159">面部检测和面部特征</h4>

<p>在拍摄以人为主的照片时调整对焦区域、测光区域和确定白平衡，但是它们也可以用来制作一些创造性的效果。</p>

<p>为了确认设备支持面部检测功能，需要使用Camera对象的getMaxNumDetectedFaces方法<code>int facesDetectable = camera.getParameters().getMaxNumDetectedFaces();</code>该方法返回设备的摄像头能够检测的最大人脸数目。如果返回值为0，则说明设备不支持面部检测。  </p>

<p>在开始使用摄像头检测人脸之前，需要分配一个新的FaceDetectionListener，使其重写onFaceDetection方法。你将得到一个Face对象的数组，每个Face对相对应在场景中检测到一个人脸。</p>

<pre class="line-numbers"><code class="language-text">camera.setFaceDetectionListener(new FaceDetectionListener() {
    public void onFaceDetection(Face[] faces,Camera camera) {
        if (faces.length &gt; 0) {
            Log.d(&quot;FaceDetection&quot;,&quot;face detected:&quot; + faces.length + &quot; Face 1 Location X:&quot; + faces[0].rect.centerX() + “Y: ” + faces[0].rect.centerY());
        }
    }
})

public void surfaceCreated(SurfaceHolder holder) {
    try {
        camera.setPreviewDisplay(holder);
        camera.startPreview();
        camera.startFaceDetection();
    } catch (IOException e) {
        Log.d(TAG, &quot;IO Exception&quot;, e);
    }
}

public void surfaceDestroyed(SurfaceHolder holder) {
    camera.stopFaceDetection();
    camera.stopPreview();
}
</code></pre>

<h4 id="toc_160">拍摄照片</h4>

<p>在配置好摄像头的设置并看到预览后，就可以拍摄照片了。调用Camera对象的takePicture，并传入一个ShutterCallback和两个PictureCallback实现(一个用于RAW图像，一个用于JPEG编码的图像)。每个图像回调都会收到一个以相应格式表示图像的字节数组，而快门回调则在快门关闭后立即触发。</p>

<pre class="line-numbers"><code class="language-text">private void takePicture() {
    camera.takePicture(shutterCallback,rawCallback,jpegCallback);
}

ShutterCallback shutterCallback = new ShutterCallback() {
    public void onShutter() {
        //快门关闭时执行一些操作
    }
}

PictureCallback rawCallback = new PictureCallback() {
    public void onPictureTaken(byte[] data,Camera camera) {
        //对图像的原始数据做一些处理
    }
}

PictureCallback jpegCallback = new PictureCallback() {
    public void onPictureTaken(byte[] data, Camera camera) {
        //将图像的JPEG数据保存到SD卡
        FileOutputStream outStream = null;
        try {
            String path = Environment.getExternalStorageDirectory() + &quot;\test.jpg&quot;;
            outStream = new FileOutputStream(path);
            outStream.write(data);
            outStream.close();
        } catch (FileNotFoundException e) {
            Log.e(TAG,&quot;File Not Found&quot;,e);
        } catch (IOException e) {
            Log.e(TAG, &quot;IO Exception&quot;, e);
        }
    }
}
</code></pre>

<h4 id="toc_161">读取并写入JPEG EXIF图像详细信息</h4>

<p>ExifInterface类为读取并修改存储在JPEG文件中的EXIF(可交换图像文件格式)数据提供了一种机制。通过将目标JPEG图像的完整文件名传入ExifInterface构造函数来创建一个新的ExifInterface实例。EXIF数据用于为照片存储各种不同的元数据，包括拍摄日期和时间、摄像头设置(如制造商和型号)、图像设置(如光圈和快门速度)以及图像描述和位置。为了读取EXIF属性，需要调用ExifInterface对象的getAttribute方法，并传入将要读取的属性名。</p>

<pre class="line-numbers"><code class="language-text">File file = new File(Environment.getExternalStorageDirectory(),&quot;test.jpg&quot;);

try {
    ExifInterface exif = new ExifInterface(file.getCanonicalPath());
    //读取摄像头模型和位置属性
    String model = exif.getAttribute(ExifInterface.TAG_MODEL);
    Log.d(TAG,&quot;Model: &quot; + model);
    //设置摄像头的品牌
    exif.setAttribute(ExifInterface.TAG_MAKE, &quot;My Phone&quot;);
} catch (IOException e) {
    Log.e(TAG,&quot;IO Exception&quot;, e);
}
</code></pre>

<h3 id="toc_162">录制视频</h3>

<h4 id="toc_163">使用Intent录制视频</h4>

<p>使用此Intent启动新Activity将会启动本机视频录制器，允许用户开始、停止、浏览并重新拍摄视频。已录制视频的URI作为返回Intent的数据参数提供给Activity。</p>

<ul>
<li>MediaStore.EXTRA_OUTPUT 默认，由视频捕获操作录制的视频将存储在默认媒体库中。</li>
<li>MediaStore.EXTRA_VIDEO_QUALITY 视频捕获操作允许使用一个整型值指定某个图像的质量。</li>
<li>MeidaStore.EXTRA_DURATION_LIMIT 所录制视频的最大长度，单位为秒。</li>
</ul>

<pre class="line-numbers"><code class="language-text">private static final int RECORD_VIDEO = 0;

private void startRecording() {
    //生成Intent
    Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
    
    //启动摄像头应用程序
    startActivityForResult(intent,RECORD_VIDEO);
}

@Override
protected void onActivityResult(int requestCode,int resultCode,Intent intent) {
    if (requestCode == RECORD_VIDEO) {
        VideoView videoView = (VideoView)findViewById(R.id.videoView);
        videoView.setVideoURI(data.getData());
        videoView.start();
    }
}
</code></pre>

<h4 id="toc_164">使用MediaRecorder录制视频</h4>

<p>可以使用MediaRecorder类录制音频和视频文件，然后在自己的应用程序中使用它们，或者把它们添加到媒体库中。需要添加权限</p>

<pre class="line-numbers"><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.RECORD_VIDEO&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;
</code></pre>

<h5 id="toc_165">配置Video Recorder</h5>

<p>首先解锁摄像头，并使用setCamera方法将其分配给Media Recorder。<code>setAudioSource</code>和<code>setVideoSource</code>方法可以指定MediaRecorder.AudioSource.* 或者Media Recorder.VideoSource.* 静态常量，它们分别定义了音频和视频源。</p>

<pre class="line-numbers"><code class="language-text">//解锁摄像头以允许Meida Recorder拥有它
camera.unlock();

//将摄像头分配给Media Recorder
mediaRecorder.setCamera(camera);

//配置输入源
mediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);

//设置录制配置文件
CamcorderProfile profile = null;

if (CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_1080P)) {
    profile = CamcorderProfile.get(CamcorderProfile.QUALITY_1080P);
} else if (CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_720P)) {
    profile = CamcorderProfile.get(CamcorderProfile.QUALITY_720P);
} else if (CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_480P)) {
    profile = CamcorderProfile.get(CamcorderProfile.QUALITY_480P);
} else if (CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_HIGH)) {
    profile = CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH);
}

if (profile != null) {
    mediaRecorder.setProfile(profile);
}

//指定输出文件
mediaRecorder.setOutputFile(&quot;/sdcard/myvideorecording.mp4&quot;);

//准备录制
mediaRecorder.prepare();
</code></pre>

<p>缩短Media Recorder的启动时间来提高效率。当Activity只是用于录制音频/视频而不是静态图片，可以使用Camera.Parameters.setRecordHint方法告诉摄像头你只想录制音频/视频</p>

<pre class="line-numbers"><code class="language-text">Camera.Parameters parameters = camera.getParameters();
parameters.setRecordingHint(true);
camera.setParameters(parameters);
</code></pre>

<h5 id="toc_166">预览视频流</h5>

<p>当录制视频时，实时显示传入所录制视频的预览是一种好的做法。与摄像头预览一样，可以使用MediaRecorder对象的setPreviewDisplay方法分配一个Surface来显示视频流。</p>

<pre class="line-numbers"><code class="language-text">mediaRecorder.setPreviewDisplay(holder.getSurface());

mediaRecorder.prepare();
</code></pre>

<h5 id="toc_167">控制录制</h5>

<pre class="line-numbers"><code class="language-text">mediaRecorder.stop();
//重置和释放Meida Recorder
mediaRecorder.reset();
mediaRecorder.release();
camera.lock();
</code></pre>

<p>可以使用<code>setVideoStabilization</code>方法修改摄像头参数，并不是所有的摄像头硬件都支持影像稳定，所以一定要用<code>isVideoStabilizationSupported</code>方法进行检查</p>

<pre class="line-numbers"><code class="language-text">Camera.Parameters parameters = camera.getParameters();
if (parameters.isVideoStabilizationSupported()) {
    parameters.setVideoStabilization(true);
}
camera.setParameters(parameters);
</code></pre>

<h5 id="toc_168">创建缩时视频</h5>

<pre class="line-numbers"><code class="language-text">每隔30秒捕获一副图片
mediaRecorder.setCaptureRate(0.03);
</code></pre>

<h3 id="toc_169">使用媒体效果</h3>

<p>使用GPU和OpenGL纹理对视频内容应用大量实时的视觉效果。可以将媒体效果应用到位图、视频或实时的摄像头预览，只要源图像绑定到一个GL_TEXTURE_2D纹理图片，并且包含至少一个mipmap级别即可。一般来说，要对图片或视频帧应用一种效果，需要使用OPenGL ES2.0上下文中的EffectContext.createWithCurrentContext创建一个新的EffectContext.媒体效果是使用EffectFactory创建的，而EffectFactory可以通过调用EffectContext的getFactory方法创建。要创建特定的效果，可以调用createEffect方法，并传入一个EffectFactory.EFFECT_*常量，每种效果支持不同的参数，可以调用setParameter 并传入要更改的设置的名称和要应用的值来进行配置。</p>

<h3 id="toc_170">向媒体库中添加新媒体</h3>

<h4 id="toc_171">使用媒体扫描仪插入媒体</h4>

<p>如果已经录制了任何一种媒体，MediaScannerConnection类提供了一个scanFile方法，作为将该媒体添加到媒体库中的一种简单方法，而不需要为媒体库Content Provider创建完整记录。在使用scanFile方法开始扫描文件之前，必须调用connect方法并等待它完成与媒体扫描仪的连接。这个调用是异步的，因此需要实现一个MediaScannerConnectionClient以便在连接建立时进行通知。</p>

<pre class="line-numbers"><code class="language-text">private void mediaScan(final String filePath) {
    MediaScannerConnectionClient mediaScannerClient = new MediaScannerConnectionClient() {
        private MediaScannerConnection msc = null;
        msc = new MediaScannerConnection(VideoCameraActivity.this,this);
        msc.connect();
        
        public void onMediaScannerConnected() {
            //可以指定一个MINE类型，或者让Media Scanner根据文件名自己假定一种类型
            String memeType = null;
            msc.scanFile(filePath,mimeType);
        }
        
        public void onScanCompleted(String path,Uri uri) {
            msc.disconnect();
            Log.d(TAG,&quot;File Added at: &quot; + uri.toString());
        }
    };
}
</code></pre>

<h4 id="toc_172">手动插入媒体</h4>

<p>通过创建一个新的ContentValues对象并手动将其插入到适当的媒体库Content Provider中，可以将新媒体添加到媒体库中，而不需要依赖媒体扫描仪。</p>

<pre class="line-numbers"><code class="language-text">ContentValues content = new ContentValues(3);
content.put(Audio.AudioColumns.TITLE,&quot;TheSoundandtheFury&quot;);
content.put(Audio.AudioColumns.DATE_ADDED,System.currentTimeMillis() / 1000);
content.put(Audio.Media.MIME_TYPE,&quot;audio/amr&quot;);
content.put(MediaStore.Audio.Media.DATA,&quot;/sdcard/myoutputfile.mp4&quot;);

ContentResolver resolver = getContentResolver();
Uri uri = resolver.insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI,content);
sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE,uri));
</code></pre>

<h2 id="toc_173">蓝牙</h2>

<p>蓝牙是一种用于短距离、低带宽点对点通信的通信协议。使用蓝牙API可以搜索并连接到一定范围之内的其他设备。</p>

<h3 id="toc_174">管理本地蓝牙设备适配器</h3>

<p>通过BluetoothAdapter 类来控制本地蓝牙设备，该类代表运行应用程序的Android设备。</p>

<pre class="line-numbers"><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;   //读取任何一种本地Bluetooth Adapter属性、启动发现过程或者找到绑定的设备
&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;   //修改任何一种本地设备属性
</code></pre>

<pre class="line-numbers"><code class="language-text">BluetoothAdater bluetooth = BluetoothAdapter.getDefaultAdapter();
if (bluetooth.isEnabled()) {
    String address = bluetooth.getAddress();
    String name = bluetooth.getName();
}

bluetooth.setName(&quot;BlackFang&quot;);
</code></pre>

<p>为了查找关于当前Bluetooth Adapter状态对的更详细描述，可以使用getState方法</p>

<ul>
<li>STATE_TURNING_ON</li>
<li>STATE_ON</li>
<li>STATE_TURNING_OFF</li>
<li>STATE_OFF</li>
</ul>

<p>启用蓝牙</p>

<pre class="line-numbers"><code class="language-text">private static final int ENABLE_BLUETOOTH = 1;
private void initBluetooth() {
    if (!bluetooth.isEnabled()) {
        //如果蓝牙未启用，提示用户打开它
        Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(intent, ENABLE_BLUETOOTH);
    } else {
        //蓝牙已启用，初始化其UI
        initBluetoothUI();
    }
}

protected void onActivityResult(int requestCode,int resultCode,Intent data) {
    if (requestCode == ENABLE_BLUETOOTH) {
        if (resultCode == RESULT_OK) {
            initBluetoothUI();
        }
    }
}
</code></pre>

<p>启用和禁用Bluetooth Adapter是比较耗时的异步操作。应用程序不应轮询Bluetooth Adapter，而是应当注册一个Broadcast Receiver用于监听ACTION_STATE_CHANGED。Broadcast Receiver包含两个extra，EXTRA_STATE和EXTRA_PREVIOUS_STATE，它们分别指示了当前和先前的Bluetooth Adapter状态。</p>

<pre class="line-numbers"><code class="language-text">BroadcastReceiver bluetoothState = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        String prevStateExtra = BluetoothAdapter.EXTRA_PREVIOUS_STATE;
        String stateExtra = BluetoothAdapter.EXTRA_STATE;
        int state = intent.getIntExtra(stateExtra, -1);
        int previousState = intent.getIntExtra(prevStateExtra, -1);
        
        String tt = &quot;&quot;;
        switch(state) {
            case (BluetoothAdapter.STATE_TURNING_ON) :
                tt = &quot;Bluetooth turning on&quot;;
                break;
            case (BluetoothAdapter.STATE_ON) :
                tt = &quot;Bluetooth on&quot;;
                break;
            case (BluetoothAdapter.STATE_TURNING_OFF) :
                tt = &quot;Bluetooth turning off&quot;;
                break;
            case (BluetoothAdapter.STATE_OFF) :
                tt = &quot;Bluetooth off&quot;;
                break;
            default:
                break;
        }
        Log.d(TAG,tt);
    }
};

String actionStateChanged = BluetoothAdapter.ACTION_STATE_CHANGED;
registerReceiver(bluetoothState,new IntentFilter(actionStateChanged));
</code></pre>

<h3 id="toc_175">可发现性和远程设备发现</h3>

<p>两个设备相互查找以进行连接的过程叫做发现。</p>

<h4 id="toc_176">管理设备的可发现性</h4>

<p>为了使远程Android设备能够在发现扫描中找到你的本地Bluetooth Adapter，需要确保它是可发现的。可以通过调用getScanMode来找出它的扫描模式</p>

<ul>
<li>SCAN_MODE_CONNECTABLE_DISCOVERABLE 启用查询扫描和页面扫描，意味着该设备可被执行发现扫描的蓝牙设备发现</li>
<li>SCAN_MODE_CONNECTABLE 启用页面扫描但是禁用查询扫描。这意味着先前连接并绑定到本地设备的设备可以在发现过程中找到，但找不到新设备。</li>
<li>SCAN_MODE_NONE 可发现性被关闭。在发现过程中没有一个远程设备能够找到本地Bluetooth Adapter。</li>
</ul>

<pre class="line-numbers"><code class="language-text">startActivityForResult (new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE),DISCOVETY_REQUEST);
@Override
protected void onActivityResult(int requestCode,int resultCode,Intent data) {
    if (requestCode == DISCOVETY_REQUEST) {
        if (resultCode == RESULT_CANCELED) {
            Log.d(TAG,&quot;Discovery canceled by user&quot;);
        }
    }
}

registerReceiver(new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        String prevScanMode = BluetoothAdapter.EXTRA_PREVIOUS_SCAN_MODE;
        String scanMode = BluetoothAdapter.EXTRA_SCAN_MODE;
        
        int currentScanMode = intent.getIntExtra(scanMode, -1);
        int prevMode = intent.getIntExtra(prevScanMode, -1);
        
        Log.d (TAG, &quot;Scan Mode: &quot; + currentScanMode + &quot;. Previous:&quot; + prevMode);
    }
},new IntentFilter(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED));
</code></pre>

<h4 id="toc_177">发现远程设备</h4>

<p>通过使用isDiscovering方法可以检查本地Bluetooth Adapter是否正在执行一次发现扫描。启动发现，调用startDiscovery。取消发现，调用cancelDiscovery。Android使用Broadcast Intent来通知发现过程的启动和结束以及在扫描过程中发现的远程设备。</p>

<pre class="line-numbers"><code class="language-text">BroadcastReceiver discoveryMonitor = new BroadcastReceiver() {
    String dStarted = BluetoothAdapter.ACTION_DISCOVER_STARTED;
    String dFinished = BluetoothAdapter.ACTION_DISCOVERY_FINISHED;
    
    @Override
    public void onReceive(Context context,Intent intent) {
        if (dStarted.equals(intent.getAction())) {
            //启动发现过程
            Log.d(TAG,&quot;Discovery Started...&quot;);
        } else if (dFinished.equals(intent.getAction())) {
            //发现过程完成
            Log.d(TAG,&quot;Discovery Complete.&quot;);
        }
        
        String remoteDeviceName = intent.getStringExtra(BluetoothDevice.EXTRA_NAME);
        BluetoothDevice remoteDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        deviceList.add(remoteDevice);
    }
};

registerReceiver(discoverMonitor,new IntentFilter(dStarted));
registerReceiver(discoverMonitor,new IntentFilter(dFinished));
</code></pre>

<h3 id="toc_178">蓝牙通信</h3>

<ul>
<li>BluetoothServerSocket 用于建立一个监听套接字以启动设备之间的链路。为建立“握手”，需要将其中一台设备充当服务器以监听和接受传入的连接请求。</li>
<li>BluetoothSocket 用于创建一个新的客户端来连接到正在监听的BluetoothServerSocket。一旦连接之后，就在服务器和客户端上使用Bluetooth Sockets来传输数据流。</li>
</ul>

<p>为使Bluetooth Adapter作为服务器，需要调用其listenUsingRfcommWithServiceRecord方法来监听传入的连接请求，并传入用来标识服务器的名称和以UUID。该方法将会返回一个BluetoothServerSocket对象。为了开始监听连接，需要调用该ServerSocket的accept的方法，并可以选择传入一个超时时间。ServerSocket将会保持阻塞，直到具有匹配UUID的远程BluetoothSocket客户端尝试进行连接。</p>

<pre class="line-numbers"><code class="language-text">private BluetoothSocket transferSocket;
private UUID startServerSocket(BlurtoothAdapter adapter) {
    UUID uuid = UUID.fromString(&quot;ssss&quot;);
    String name = &quot;bluetoothserver&quot;;
    
    try {
        final BluetoothServerSocket btserver = bluetooth.listenUsingRfcommWithServiceRecord(name,uuid);
        
        Thread acceptThread = new Thread(new Runnable() 「
            public void run() {
                try {
                    //在客户端连接建立以前保持阻塞
                    BluetoothSocket serverSocket = btserver.accept();
                    //开始监听消息
                    listenForMessages(serverSocket);
                    //添加对用来发送消息的套接字的引用
                    transferSocket = serverSocket;
                } catch (IOException e) {
                    Log.e(&quot;BLUETOOTH&quot;,&quot;Server connection IO Exception&quot;,e);
                }
            }
        });
        acceptThread.start();
    } catch(IOException e) {
        Log.e(&quot;BLUETOOTH&quot;,&quot;Socket listener IO Exception&quot;,e)
    }
    return uuid;
}
</code></pre>

<h4 id="toc_179">选择远程蓝牙设备进行通信</h4>

<p>可以在客户端设备上使用BluetoothSocket类，在应用程序中启动与长在监听的Server的通信信道。</p>

<p>蓝牙设备连接需求</p>

<ul>
<li>远程设备必须是可发现的</li>
<li>远程设备必须使用一个Bluetooth Server Socket接受连接</li>
<li>本地和远程设备必须经过配对。如果设备没有配对，那么当启动连接请求时将提示用户进行配对。</li>
</ul>

<p>可以使用本地BluetoothAdapter的getRemoteDevice，并指定你想要连接到的远程蓝牙设备的硬件地址。为了查找当前已配对的设备集合，可以调用本地Bluetooth Adapter的getBondedDevices方法。可以通过查询所返回的集合以发现目标蓝牙设备是否与本地BluetoothAdapter进行配对。</p>

<pre class="line-numbers"><code class="language-text">final BluetoothDevice knownDevice = bluetooth.getRemoteDevice(&quot;01:23:77:35:2F:AA&quot;);
Set&lt;BluetoothDevice&gt; bondedDevices = bluetooth.getBondedDevices();
if (bondedDevices.contains(knownDevice)) {
    //目标设备已经与本地设备绑定/配对
}
</code></pre>

<h4 id="toc_180">打开一个客户端BluetoothSocket连接</h4>

<p>调用connect方法，使用所返回的Bluetooth Socket来启动连接</p>

<pre class="line-numbers"><code class="language-text">private void connectToServerSocket(BluetoothDevice device,UUID uuid) {
    try {
        BluetoothSocket clientSocket = device.createRfcommSocketToServiceRecord(uuid);
        
        //阻塞，直到服务器接受连接
        clientSocket.connect();
        
        //开始监听消息
        listenForMessages(clientSocket);
        
        //添加对用于发送消息的套接字的引用
        transferSocket = clientSocket;
    } catch(IOException e) {
        Log.e(&quot;BLUETOOTH&quot;,&quot;Bluetooth client I/O Wxception&quot;,e);
    }
}
</code></pre>

<h4 id="toc_181">使用Bluetooth Socket传输数据</h4>

<p>一旦建立连接后，客户端和服务端设备上都会有Bluetooth Socket。两者之间没有显著区别。通过InputStram和OutputStream对象来处理。</p>

<pre class="line-numbers"><code class="language-text">private void sendMessage(BluetootnSocket socket,String message) {
    OutputStream outStream;
    try {
        outStream = socket.getOutputStream();
        
        byte[] byteArray = (message + &quot;&quot;).getBytes();
        byteArray[byteArray.length - 1] = 0;
        outStream.write(byteArray);
    } catch(IOException e) {
        Log.e(TAG,&quot;Message send failed&quot;,e);
    }
}

private boolean listening = false;

private void listenForMessages(BluetoothSocket socket,StringBuilder incoming) {
    listening = true;
    int buggerSize = 1024;
    byte[] buffer = new byte[bufferSize];
    
    try {
        InputStream instream = socket.getInputStream();
        int bytesRead = -1;
        while (listening) {
            bytesRead = instream.read(buffer);
            if (bytesRead != -1) {
                String result = &quot;&quot;;
                while((bytesRead == bufferSize) &amp;&amp; (buffer[bufferSize - 1] ！= 0)) {
                    result = result + new String(buffer,0,bytesRead - 1);
                    bytesRead = instream.read(buffer);
                }
                result = result + new String(buffer,0,bytesRead - 1);
                incoming.qppend(result);
            }
            socket.close();
        }
    } catch (IOException e) {
        Log.e(TAG,&quot;Message received failed.&quot;,e);
    }
    finally {
    }
}
</code></pre>

<h2 id="toc_182">管理网络</h2>

<p>Android 网络主要是通过ConnectivityManager来处理的，该服务使你可以监视连接状态、设置自己的首选网络连接以及管理连接失败转接。</p>

<h3 id="toc_183">Connectivity Manager</h3>

<p>用于监视网络连接状态、配置故障转移设置以及控制网络无线电。需要权限。</p>

<pre class="line-numbers"><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot;/&gt;
</code></pre>

<h4 id="toc_184">查找和监视网络连接</h4>

<pre class="line-numbers"><code class="language-text">ConnectivityManager connectivity = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
//获得活动网络信息
NetworkInfo activeNetwork = connectivity.getActiveNetworkInfo();
boolean isConnected = ((activeNetwork != null) &amp;&amp; (activeNetwork.isConnectedOrConnecting()));
boolean isWiFi = activeNetwork.getType() == ConnectivityManager.TYPE_WIFI;
</code></pre>

<p>通过查询连接状态和网络类型，可以根据可用的带宽暂时性地禁用下载和更新，修改刷新频率，或者推迟大文件的下载。</p>

<p>为了监视网络连接，可以创建一个Broadcast Receiver来监听ConnectivityManager.CONNECTIVITY_ACTION</p>

<pre class="line-numbers"><code class="language-text">&lt;receiver android:name=&quot;.ConnectivityChangedReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre>

<p>这些Intent包含了一些extra，它们提供了关于连接状态变化的额外详细信息。可以使用ConnectivityManager类中可用的静态常量访问每个extra。</p>

<p>EXTRA_NO_CONNECTIVITY 布尔类型，当设备未连接到任何网络时返回true。当有连接时，使用getActiveNetworkInfo来获得新连接状态的更多详细信息并根据情况修改下载计划。</p>

<h3 id="toc_185">管理WiFi</h3>

<p>WifiManager代表Android Wi-Fi连接服务。它能够配置Wi-Fi网络连接，管理当前的Wi-Fi连接、扫描接入点以及监视Wi-Fi连接的变化。添加权限</p>

<pre class="line-numbers"><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;/&gt;
</code></pre>

<pre class="line-numbers"><code class="language-text">WifiManager wifi = (WifiManager)getSystemService(Context.WIFI_SERVICE);
if (!wifi.isWifiEnabled()) {
    if (wifi.getWifiState() != WifiManager.WIFI_STATE_ENABLING) {
        wifi.setWifiEnabled(true);
    }
}
</code></pre>

<h4 id="toc_186">监视Wi-Fi连接</h4>

<p>大多数情况下，使用ConnectivityManager监视Wi-Fi连接的变化是一种最佳实践。不过，每当Wi-Fi 网络连接状态发生变化时，Wi-Fi Manager会广播Intent，它会使用在WifiManager类中定义的常量。</p>

<ul>
<li>WIFI_STATE_CHANGED_ACTION 指示Wi-Fi硬件状态已经发生变化，包括enabling、enabled、disabling、disabled和unknown几种状态。
<ul>
<li>EXTRA_WIFI_STATE 新的Wi-Fi状态</li>
<li>EXTRA_PREVIOUS_STATE 前一次的Wi-Fi状态。</li>
</ul></li>
<li>SUPPLICANT_CONNECTION_CHANGE_ACTION 每当与活动的请求方之间的连接状态发生变化时广播该Intent。当新连接建立或者现有连接丢失时就使用EXTRA_NEW_STATE触发它，并且在建立新连接时，该布尔值返回true</li>
<li>NETWORK_STATE_CHANGED_ACTION 每当Wi-Fi连接状态发生变化时被触发。
<ul>
<li>EXTRA_NETWORK_INFO 其中包含详细描述了当前网络状态的NetworkInfo对</li>
<li>EXTRA_BSSID 包含所连接的接入点的BSSID</li>
</ul></li>
<li>RSSI_CHANGED_ACTION 通过监听RSSI_CHANGED_ACTION Intent来监视已连接Wi-Fi网络的当前信号强度。
<ul>
<li>EXTRA_NEW_RSSI 保存了当前的信号强度，可以通过使用Wi-Fi Manager的calculateSignalLevel静态方法，以便按照你指定的范围将该信号强度转换成一个整型数值。</li>
</ul></li>
</ul>

<h4 id="toc_187">监视活动的Wi-Fi连接的相信信息</h4>

<p>当建立了一个活动的Wi-Fi连接，就可以使用Wi-Fi Manager的getConnectionInfo方法找出连接的状态信息。所返回的WiFiInfo对象包含当前接入点的SSID、BSSID、Mac地址、IP地址，以及当前的链路速度和信号强度。</p>

<pre class="line-numbers"><code class="language-text">WifiInfo info = wifi.getConnectionInfo();
if (info.getBSSID() != null) {
    int strength = WifiManager.calculateSingalLevel(info.getRssi(),5);
    int speed = info.getLinkSpeed();
    String units = WifiInfo.LINK_SPEED_UNITS;
    String ssid = info.getSSID();
    String cSummary = String.format(&quot;Connected to %s at %s%s. Strength %s/5&quot;,ssid,speed,units,strength);
    Log.d(TAG,cSummary);
}
</code></pre>

<h4 id="toc_188">扫描热点</h4>

<p>可以使用Wi-Fi Manager的startScan方法进行接入点扫描。一个带有SCAN_RESULTS_AVAILABLE_ACTION动作的Intent将被广播以便异步宣布扫描完成并且结果可用。</p>

<pre class="line-numbers"><code class="language-text">//注册用于监听扫描结果的BroadcastReceiver
registerReceiver(new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        List&lt;ScanResult&gt; results = wifi.getScanResults();
        ScanResult bestSingal = null;
        for (ScanResult result : results) {
            if (bestSignal == null || WifiManager.compareSignalLevel(bestSignal.level,result.level) &lt; 0) {
                bestSignal = result;
            }
        }
        
        String connSummary = String.format(&quot;%s networks found. %s is the strongest.&quot;,results.size(),bestSignal.SSID);
        Toast.makeText(MyActivity.this,connSummary,Toast.LENGTH_LONG).show();
    }
},new IntentFilter(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION));

//开始扫描
wifi.startScan();
</code></pre>

<h4 id="toc_189">管理Wi-Fi配置</h4>

<p>可以使用Wi-Fi Manager管理已配置的网络设置并控制将要连接到哪个网络。一旦连接建立，就可以通过查询可用网络连接来获得其配置和设置的更多详细信息。</p>

<ul>
<li>getConfiguredNetworks 可以获得当前网络配置的列表。返回的WifiConfiguration对象列表包含每个配置的网络ID、SSID和其他详细信息</li>
<li>enableNetwork 使用某个特定的网络配置</li>
</ul>

<pre class="line-numbers"><code class="language-text">//获得可用配置的一个列表
List&lt;WifiConfiguration&gt; configurations = wifi.getConfiguredNetworks();
//获得第一个配置的网络ID
if (configurations.size() &gt; 0) {
    int netID = configurations.get(0).networkId;
    //启用网络
    boolean disableAllOthers = true;
    wifi.enableNetwork(netID,disableAllOthers);
}
</code></pre>

<h4 id="toc_190">创建Wi-Fi网络配置</h4>

<p>为了连接到一个Wi-Fi网络，需要创建并注册一个配置。一般，用户将使用本地Wi-Fi配置设置进行该操作，但是也可以在自己的应用程序中提供相同的功能。网络配置作为WifiConfiguration对象进行存储。</p>

<ul>
<li>BSSID 每个接入点的BSSID</li>
<li>SSID 特定网络的SSID</li>
<li>networkId 用于在当前设备上标识这个网络配置的唯一标识符</li>
<li>priority 当对要连接到的潜在接入点的列表进行排序时用到的网络配置优先级</li>
<li>status 该网络连接的当前状态。</li>
</ul>

<p>addNetwork方法可以指定一个新的配置并将其添加到当前列表中。updateNetworks可以传入只包含一个网络ID和想要更改的值得WifiConfiguration对象来更新网络配置。</p>

<h3 id="toc_191">使用Wi-Fi Direct传输数据</h3>

<p>Wi-Fi Direct是一种通信协议，用于中等距离、高带宽的点对点通信。与蓝牙技术相比，Wi-Fi Direct更加快速可靠，而且工作距离更远。特别适合媒体共享和接收实时媒体流等操作。</p>

<h4 id="toc_192">初始化Wi-Fi Direct框架</h4>

<p>为使用Wi-Fi Direct，必须添加权限。</p>

<pre class="line-numbers"><code class="language-text">&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;
</code></pre>

<p>Wi-Fi Direct连接是使用Wifi2pManager系统服务建立和管理的。</p>

<pre class="line-numbers"><code class="language-text">private Wifi2pManager wifiP2pManager;
private Channel wifiDirectChannel;

private void initializeWiFiDirect() {
    wifiP2pManager = (Wifi2pManager)getSystemService(Context.WIFI_P2P_SERVICE);
    wifiDirectChannel = wifiP2pManager.initialize(this,getMainLooper(),new ChannelListener() {
        public void onChannelDisconnected() {
            initializeWiFiDirect();
        }
    })
}
</code></pre>

<p>将会使用这个通道与Wi-Fi Direct框架进行交互，因此WiFi P2P Manager的初始化操作通常是在Activity的onCreate处理程序内完成的。使用WiFi P2P Manager执行的大多数动作会使用一个ActionListener立即指出它们是否成功。</p>

<pre class="line-numbers"><code class="language-text">private ActionListener actionListener = new ActionListener() {
    public void onFailure(int reason) {
        String errorMessage = &quot;WiFi Direct Failed.&quot;;
        switch(reason) {
            case WifiP2pManager.BUSY:
                errorMessage += &quot;Framework busy.&quot;;
                break;
            case WifiP2pManager.ERROR:
                errorMessage += &quot;Framework error.&quot;;
                break;
            case WifiP2pManager.P2P_UNSUPPORTED:
                errorMessage += &quot;Unsupported.&quot;;
                break;
            default:
                errorMessage += &quot;Unknown error.&quot;;
                break;
        }
    }
    
    public void onSuccess() {
        //成功，返回值通过一个Broadcast Intent返回
    }
}
</code></pre>

<h4 id="toc_193">启用Wi-Fi Direct并监视其状态</h4>

<p>为使一个Android是被能够发现其他Wi-Fi Direct设备或被其他Wi-Fi Direct设备发现，用户首先必须启用Wi-Fi Direct。</p>

<p><code>startActivity(new Intent(android.provider.Settings.ACTION_WIRELES_SETTINGS));</code></p>

<p>只有建立连接并传输数据时，Wi-Fi Direct才回一直保持启用状态。如果短时间不用，它就会自动禁用。只有设备上启用了Wi-Fi Direct时，才能够执行Wi-Fi Direct操作。因此，监听Wi-Fi Direct的状态变化，并通过修改UI来禁用不可行操作非常重要。</p>

<pre class="line-numbers"><code class="language-text">BroadcastReceiver p2pStatusReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE,WifiP2pManager.WIFI_P2P_STATE_DISABLED);
        
        switch(state) {
            case (WifiP2pManager.WIFI_P2P_STATE_ENABLED):
                buttonDiscover.setEnabled(true);
                break;
            default:
                buttonDiscover.setEnabled(false);
        }
    }
}
</code></pre>

<p>在创建了连接到Wi-Fi Direct框架的通道并启用设备及其对等设备上的Wi-Fi Direct后，就可以开始搜索和连接对等设备。</p>

<h4 id="toc_194">发现对等设备</h4>

<p>为扫描对等设备，需要调用WiFi P2P Manager的discoverPeers方法，并传入一个处于活动状态的通道和一个Action Listener。对等设备列表的变化将作为一个Intent，通过使用WifiP2pManager，WIFI_P2P_PEERS_CHANGED_ACTION 动作广播出去。在建立一个连接或者创建一个组之前，对等设备的搜索过程会一直进行。</p>

<pre class="line-numbers"><code class="language-text">private void discoverPeers() {
    wifiP2pManager.discoverPeers(wifiDirectChannel,actionListener);
}

BroadcastReceiver peerDiscoveryReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        wifiP2pManager.requestPeers(wifiDirectChannel,new PeerListListener() {
            public void onPeersAvailable(WifiP2pDeveiceList peers) {
                deviceList.clear();
                deviceList.addAll(peers.getDeviceList());
                aa.notifyDataSetChanged();
            }
        })
    }
}
</code></pre>

<h4 id="toc_195">连接对等设备</h4>

<p>为了与对等设备建立Wi-Fi Direct连接，需要使用WiFi P2P Manager的connect方法，并传入活动的通道，一个Action Listener以及一个指定了要连接的对等设备的地址的WifiP2pConfig对象</p>

<pre class="line-numbers"><code class="language-text">private void connectTo(WifiP2pDevice device) {
    WifiP2pConfig config = new WifiP2pConfig();
    config.deviceAddress = device.deviceAddress();
    wifiP2pManager.connect(wifiDirectChannel,config,actionListener);
}
</code></pre>

<p>当尝试建立一个连接时，远程设备就会被提示接受连接请求。如果远程设备接受了建立连接的请求，成功的连接将使用WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION Intent动作在两个设备上广播。</p>

<pre class="line-numbers"><code class="language-text">BroadcastReceiver connectionChangedReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context,Intent intent) {
        //提取NetworkInfo
        NetworkInfo networkInfo = (NetworkInfo)intent.getParcelableExtra(WifiP2pManager.EXTRA_NETWORK_INFO);
        
        //检查是否已经连接
        if (networkInfo.isConnected()) {
            wifiP2pManager.requestConnectionInfo(wifiDirectChannel,new ConnectionInfoListener() {
                public void onConnectionInfoAvailable(WifiP2pInfo info) {
                    //如果建立了连接
                    if (info.groupFormed) {
                        //如果这个设备是服务器
                        if (info.isGroupOwner) {
                            //启动Server Socket
                        }
                        //如果这个设备是客户机
                        else if (info.groupFormed) {
                            //启动Client Socket
                        }
                    }
                }
            });
        } else {
            Log.d(TAG, &quot;Wi-Fi Direct Disconnected&quot;);
        }
    }
}
</code></pre>

<p>当连接信息可用时，ConnectionInfoListener会触发其onConnectionInfoAvailable处理程序，并传入一个包含这些详细信息的WifiP2pInfo对象。</p>

<h2 id="toc_196">辅助</h2>

<h3 id="toc_197">Linkify</h3>

<p>Linkify会自动地在TextView类中通过RegEx模式匹配来创建超链接。那些匹配一个指定的RegEx模式的文本都将会被转化为一个可以单击的超链接，这些超链接可以隐式使用匹配的文本作为目标URI来出发<code>startActivity(new Intent(Intent.ACTION_VIEW,uri))</code>。</p>

<h4 id="toc_198">原生Linkify链接类型</h4>

<p>添加 WEB_URLS、EMAIL_ADDRESSES、PHONE_NUMBERS和ALL 预设值</p>

<pre class="line-numbers"><code class="language-text">TextView textView = findViewById(R.id.myTextView);
Linkify.addLinks(textView,Linkify.WEB_URLS|Linkify.EMAIL_ADDRESSES);

xml 文件中autoLink属性包含(none、web、email、phone、all)
</code></pre>

<h4 id="toc_199">创建定制的链接字符串</h4>

<p>传入RegEx模式</p>

<pre class="line-numbers"><code class="language-text">Pattern p = Pattern.compile(&quot;\\bquake[\\s]?[0-9]+\\b&quot;,Pattern.CASE_INSENSITIVE);
Linkify.addLinks(myTextView,p,baseUri);
</code></pre>

<p>使用<code>Match Filter</code>和<code>Transform Filter</code>,通过实现Match Filter 的 acceptMatch 方法来向RegEx模式匹配添加额外的条件。Transform Filter允许修改匹配的链接文本生成的隐式URI。把链接文本和目标URI分开，你能够更自由地决定如何把数据字符串显示给用户。</p>

<pre class="line-numbers"><code class="language-text">Linkify.addLinks(myTextView,p,baseUri,new MyMatchFilter(),new MyTransformFilter());

class MyMatchFilter implements MatchFilter {
    public boolean acceptMatch(CharSequence s,int start,int end) {
        return (start == 0 || s.charAt(start - 1) != &#39;!&#39;);
    }
}

class MyTransformFilter implements TransformFilter {
    public String transformUrl(Matcher match,String url) {
        return url.toLowerCase().replace(&quot; &quot;,&quot;&quot;);
    }
}
</code></pre>

<h3 id="toc_200">全屏显示</h3>

<p>要想控制手机上导航栏的可见性或者平板电脑上系统栏的外观，可以对Activity层次结构中任何可见的View使用setSystemUiVisibility方法。</p>

<ul>
<li>SYSTEM_UI_FLAG_LOW_PROFILE 和 STATUS_BAR_HIDDEN 一样会遮挡导航按钮。</li>
<li>SYSTEM_UI_FLAG_HIDE_NAVIGATION 在手机上移除导航栏，并遮挡平板电脑的系统栏中使用的导航按钮。</li>
</ul>

<p>当导航的可见性变化时，最好能够和UI中其他变化同步。例如，在进入或者退出”全屏模式“时，可能需要隐藏或者显示操作栏和其他导航操作。  </p>

<pre class="line-numbers"><code class="language-text">myView.setOnSystemUiVisibilityChangeListener (
    new OnSystemUiVisibilityChangeListener() {
        public void onSystemUiVisibilityChange(int visibility) [
            if (visibility == View.SYSTEM_UI_FLAG_VISIBLE) {
                //显示操作栏和状态栏
            } else {
                //隐藏操作栏和状态栏
            }
        }
    }
)
</code></pre>

<p>要想隐藏状态栏，可以向Window中添加LayoutParams.FLAG_FULLSCREEN标志</p>

<pre class="line-numbers"><code class="language-text">myView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
</code></pre>

<h3 id="toc_201">为每个屏幕尺寸和分辨率做设计</h3>

<p>当使用不能很好地动态缩放的Drawable资源时，应该创建和包含针对每种像素密度类别进行优化的图像资源</p>

<ul>
<li>res/drawable-ldpi 为120dpi左右的屏幕提供低密度资源</li>
<li>res/drawable-mdpi 为160dpi左右的屏幕提供中密度资源</li>
<li>res/drawable-hdpi 为240dpi左右的屏幕提供高密度资源</li>
<li>res/drawable-xhdpi 为320dpi左右的屏幕提供超高密度资源</li>
<li><p>res/drawable-nodpi 用于不管宿主屏幕密度如何都不能缩放的资源</p></li>
<li><p>宽屏优化</p>
<ul>
<li>long 宽屏修饰符</li>
<li>notlong 非宽屏修饰符</li>
</ul></li>
<li><p>横竖屏优化</p>
<ul>
<li>land 横屏修饰符</li>
<li>port 竖屏修饰符</li>
</ul></li>
<li><p>宽度优化</p>
<ul>
<li>w600dp 宽度修饰符</li>
<li>h720dp 高度修饰符</li>
<li>sw320dp 最小的可用屏幕宽度</li>
</ul></li>
<li><p>设备大小</p>
<ul>
<li>small 小</li>
<li>normal 普通</li>
<li>large 大</li>
<li>xlarge 超大</li>
</ul></li>
</ul>

<h3 id="toc_202">指定支持的屏幕尺寸</h3>

<p>对于一些应用程序，可能无法通过优化UI来使其支持所有可能的屏幕尺寸。可以通过在清单文件中使用supports-screens元素来指定应用程序可以运行在哪些屏幕上</p>

<pre class="line-numbers"><code class="language-text">&lt;supports-screens android:smallScreens=&quot;false&quot;
    android:normalScreens=&quot;true&quot;
    android:largeScreens=&quot;true&quot;
    android:xlargeScreens=&quot;true&quot;&gt;
</code></pre>

<h3 id="toc_203">复制、粘贴和剪贴板</h3>

<p><code>ClipboardManager clipboard = (ClipboardManager)getSystemService(CLIPBOARD_SERVICE);</code></p>

<p>剪贴板支持文本字符串、URI和Intent。要想向剪贴板复制一个对象，可以创建一个新的ClipData对象，它包括一个描述了与待复制对象相关的元数据的ClipDescription、任意数量的ClipData.Item对象。使用setPrimaryClip方法把ClipData添加到剪贴板上。<br/><br/>
<code>clipboard.setPrimaryClip(newClip);</code><br/><br/>
在任意时刻，剪贴板中只能包含一个ClipData对象。复制一个新的对象会替换之前持有的剪贴板对象。</p>

<h4 id="toc_204">向剪贴板中复制数据</h4>

<p>ClipData类提供了大量方便的静态方法来简化一个标准的ClipData对象的创建过程。使用newPlainText方法创建一个新的ClipData对象。或使用newUri方法，指定一个Content Resolver、标签和待粘贴数据的URI。</p>

<p><code>ClipData newClip = ClipData.newPlainText(&quot;copied text&quot;,&quot;Hello, Android!&quot;);</code><br/><br/>
<code>ClipData newClip = ClipData.newUri(getContentResolver(),&quot;URI&quot;,myUri);</code></p>

<h4 id="toc_205">粘贴剪贴板数据</h4>

<p>可以判断剪贴板上是否已经复制了数据，从而在UI上启用和禁用粘贴选项。</p>

<p><code>if (!(clipboard.hasPrimaryClip())){}</code></p>

<p>当然，还可以查询当前剪贴板中的Clip Data对象的数据类型。使用getPrimaryClipDescription方法获得剪贴板数据中的元数据，并使用它的hasMimeTypes方法指定应用程序粘贴所支持的MIME类型:</p>

<pre class="line-numbers"><code class="language-text">if (!(clipboard.getPrimaryClipDescription().hasMimeType(MIMETYPE_TEXT_PLAIN))) {
    //如果剪贴板中的内容是一个不支持的类型，就禁用粘贴UI选项
} else {
    //如果剪贴板中的内容是一个支持的类型，就启用粘贴UI选项
}
</code></pre>

<p>要想访问数据本身，可以使用getItemAt方法，传入你要遍历的项的索引值</p>

<p><code>ClipDate.Item item = clipboard.getPrimaryCclip().getItemAt(0);</code></p>

<p>通过分别使用getText、getUri和getIntent方法，可以获取文本、URI和Intent。使用coerceToText方法，可以将ClipData.Item对象的内容转化为一个字符串。<code>CharSequence pasteText = item.coerceToText(this);</code></p>

<h3 id="toc_206">使用Wake Lock</h3>

<p>为了延长电池的使用寿命，Android设备会在闲置一段时间后使屏幕变暗，然后关闭屏幕显示，最后停止CPU。WakeLock是一个电源管理系统服务功能，应用程序可以使用它来控制主机设备的电源状态。可以保持CPU运行，避免屏幕变暗和关闭，以及避免键盘背光灯熄灭。但是它会显著影响电池寿命，所以在创建它之前，需要请求权限</p>

<p><code>&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;</code></p>

<p>为创建一个WakeLock，需要调用Power Manager的newWakeLock方法，并指定下面一种WakeLock类型</p>

<ul>
<li>FULL_WAKE_LOCK 保持屏幕最大亮度、键盘背光灯点亮以及CPU运行</li>
<li>SCREEN_BRIGHT_WAKE_LOCK 保持屏幕最大亮度和CPU运行</li>
<li>SCREEN_DIM_WAKE_LOCK 保持屏幕亮起和CPU运行(通常用于在用户观看屏幕但是很少与屏幕进行交互期间防止屏幕变暗)</li>
<li>PARTIAL_WAKE_LOCK 保持CPU运行</li>
</ul>

<p>创建WakeLock后，可以通过acquire来获取它。可以有选择地指定一个超时值来确保将在尽可能长时间内保持使用Wake Lock。动作完成后，需要调用release来让系统管理电源状态。</p>

<pre class="line-numbers"><code class="language-text">WakeLock wakeLock;
private class MyAsyncTask extends AsyncTask&lt;Void,Void,Void&gt; {
    @Override
    protected Void doInBackground(Void... parameters) {
        PowerManager pm = (PowerManager)getSystemService(Context.POWER_SERVICE);
        wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,&quot;MyWakeLock&quot;);
        wakeLock.acquire();
        
        //Do things in the background
        
        return null;
    }
    
    @Override
    protected void onPostExecute(Void parameters) {
        wakeLock.release();
    }
}
</code></pre>

<h2 id="toc_207">参考资料</h2>

<p>《Android4 编程入门经典》</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/5/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207873035.html">
                
                  <h1>Android Studio整体学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>开发Android也有一年多的时间了，一直使用Android Studio。虽然一直都能正常开发，但是在开发过程中，对IDE的不熟悉还是会导致各种各样的问题，也会拉低开发效率去网上搜索。所以我想整体学习了解下Android Studio的使用，记录方便日后查询。</p>

<h2 id="toc_1">偏好设置</h2>

<h3 id="toc_2">基础配置</h3>

<h4 id="toc_3">编码方式</h4>

<p>操作步骤: Preferences -&gt; Editor -&gt; File Encodings</p>

<h3 id="toc_4">个性化配置</h3>

<h4 id="toc_5">字体和大小</h4>

<p><strong>操作步骤</strong>: Preferences -&gt; Appearance &amp; Behavior -&gt; Appearance -&gt; 勾选【Override default fonts by (not recommended)】 -&gt; 选择所要的字体和字号<br/><br/>
<strong>设置的是IDE的操作界面的字体和字号</strong></p>

<h2 id="toc_6">工作台</h2>

<h3 id="toc_7">菜单栏</h3>

<h4 id="toc_8">文件（File）</h4>

<h4 id="toc_9">编辑（Edit）</h4>

<h4 id="toc_10">视图（View）</h4>

<h4 id="toc_11">Navigate（导航）</h4>

<h4 id="toc_12">代码（Code）</h4>

<h4 id="toc_13">分析（Analyze）</h4>

<h4 id="toc_14">重构（Refactor）</h4>

<h4 id="toc_15">构建（Build）</h4>

<h4 id="toc_16">运行（Run）</h4>

<h4 id="toc_17">工具（Tools）</h4>

<h4 id="toc_18">版本控制系统（VCS）</h4>

<h4 id="toc_19">窗口（Window）</h4>

<h4 id="toc_20">帮助（Help）</h4>

<h3 id="toc_21">导航条</h3>

<p><strong>菜单栏中View -&gt; 勾选Navigation Bar可以显示导航条</strong><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20180802153319475218722.png" alt="20180802153319475218722.png"/><figcaption>20180802153319475218722.png</figcaption></figure></p>

<h3 id="toc_22">工具条</h3>

<p>Android Studio的工具条分布在主界面的左右两边和底部。可以通过<strong>菜单栏-&gt;View-&gt;Tool Windows -&gt; 查看Android Studio支持的所有工具列表</strong></p>

<h3 id="toc_23">工具窗口</h3>

<h4 id="toc_24">项目工具窗口（Project）</h4>

<p>提供多种视图模式来查看项目结构</p>

<h4 id="toc_25">收藏夹工具窗口（Favorite）</h4>

<p>可以添加经常查看或使用的文件和代码片段，以便快速查看</p>

<h4 id="toc_26">结构工具窗口（Structure）</h4>

<p>以树状形式展示文件中元素的层次结构。单击元素可以跳转到编辑器中对应代码的位置</p>

<h4 id="toc_27">待处理任务工具窗口（TODO）</h4>

<p>在Android Studio中待处理的任务可以注释使用TODO标识，该窗口显示所有待处理的任务</p>

<h4 id="toc_28">Android监控工具窗口（Android Profiler）</h4>

<h5 id="toc_29">CPU监控</h5>

<h5 id="toc_30">内存监控</h5>

<h5 id="toc_31">网络监控</h5>

<h4 id="toc_32">Logcat日志输出面板</h4>

<h4 id="toc_33">快照工具窗口（Captures）</h4>

<p>存放Android Monitor的dump处的heap、allocation、系统信息、布局解析等文件</p>

<h4 id="toc_34">构建变体工具窗口（Build Variants）</h4>

<p>用来选择当前多渠道版本的构建，执行Build APK会构建出选中的渠道版本</p>

<h4 id="toc_35">Gradle工具窗口（Gradle project）</h4>

<p>列出了当前项目和模块中支持的所有Gradle任务和运行配置，以便快速操作</p>

<h2 id="toc_36">项目</h2>

<table>
<thead>
<tr>
<th style="text-align: left">文件/目录名</th>
<th style="text-align: left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">NewProject</td>
<td style="text-align: left">项目</td>
</tr>
<tr>
<td style="text-align: left">NewProject</td>
<td style="text-align: left">自动生成的用于存放Android Studio配置文件的目录，包括版权、检查配置、jar包信息、项目名、编译、编码、gradle、模块等</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app</td>
<td style="text-align: left">项目中的模块</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/build</td>
<td style="text-align: left">模块编译后的文件存放目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/libs</td>
<td style="text-align: left">模块依赖的jar包存放目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/androidTest</td>
<td style="text-align: left">Android单元测试代码存放目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/test</td>
<td style="text-align: left">本地单元测试代码存放目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main</td>
<td style="text-align: left">代码和资源存放目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/java</td>
<td style="text-align: left">代码目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res</td>
<td style="text-align: left">资源目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/drawable</td>
<td style="text-align: left">存放能转化为绘制资源的位图文件或定义了绘制资源的XML文件(后缀为.png,.9.png,.jpg,.gif的图像文件)</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/layout</td>
<td style="text-align: left">存放定义了用户界面布局的XML布局</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/anim</td>
<td style="text-align: left">存放定义了补间动画或逐帧动画的XML文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/animator</td>
<td style="text-align: left">存放定义了属性动画的XML文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/transition</td>
<td style="text-align: left">存放定义了场景过渡动画的XML文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/menu</td>
<td style="text-align: left">存放定义了应用程序菜单资源的XML文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/mipmap</td>
<td style="text-align: left">存放启动图标目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/mipmap-mdpi</td>
<td style="text-align: left">中密度，适用于屏幕密度为160的手机屏幕</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/mipmap-hdpi</td>
<td style="text-align: left">高密度，适用于屏幕密度为240的手机屏幕</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/mipmap-xhdpi</td>
<td style="text-align: left">超高密度，适用于屏幕密度为320的手机屏幕</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/mipmap-xxhdpi</td>
<td style="text-align: left">超超高密度，适用于屏幕密度为480的手机屏幕</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/mipmap-xxxhdpi</td>
<td style="text-align: left">超超超高密度，适用于屏幕密度为640的手机屏幕</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/values</td>
<td style="text-align: left">存放定义了多种类型资源的XML文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/values/color</td>
<td style="text-align: left">存放定义了颜色状态列表资源的XML文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/jniLibs</td>
<td style="text-align: left">so文件存放目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/assets</td>
<td style="text-align: left">附加的资源文件存放目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/src/main/res/AndroidManifest.xml</td>
<td style="text-align: left">应用程序配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/.gitignore</td>
<td style="text-align: left">模块中Git忽略配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/app.iml</td>
<td style="text-align: left">模块配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/build.gradle</td>
<td style="text-align: left">模块构建配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/app/proguard-rules.pro</td>
<td style="text-align: left">代码混淆配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/build</td>
<td style="text-align: left">项目编译目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/gradle</td>
<td style="text-align: left">gradle目录</td>
</tr>
<tr>
<td style="text-align: left">NewProject/.gitignore</td>
<td style="text-align: left">项目中Git的忽略配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/build.gradle</td>
<td style="text-align: left">项目构建配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/gradle.properties</td>
<td style="text-align: left">gradle配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/gradlew</td>
<td style="text-align: left">gradlew配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/gradlew.bat</td>
<td style="text-align: left">Windows上的gradlew配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/local.preperties</td>
<td style="text-align: left">属性配置文件</td>
</tr>
<tr>
<td style="text-align: left">NewProject/settings.gradle</td>
<td style="text-align: left">全局配置文件</td>
</tr>
<tr>
<td style="text-align: left">External Libraries</td>
<td style="text-align: left">项目中使用到的依赖库存放目录</td>
</tr>
<tr>
<td style="text-align: left">External Libraries/&lt; Andriod API 23 Platform &gt;</td>
<td style="text-align: left">Android SDK版本和存放路径</td>
</tr>
<tr>
<td style="text-align: left">External Libraries/&lt; 1.7 &gt;</td>
<td style="text-align: left">JDK版本和存放路径</td>
</tr>
</tbody>
</table>

<h3 id="toc_37">创建可编译的资源文件</h3>

<p><strong>操作步骤</strong>: File -&gt; 右击module -&gt; New -&gt; Android resource file -&gt; 弹出【New Resource File】</p>

<ul>
<li>File Name: 新建的资源文件名</li>
<li>Resource type: 资源类型</li>
<li>Root element: XML文件的根属性</li>
<li>Source set: 编译时引用的资源文件的来源设置，默认的是main,debug,release</li>
<li>Directory name: 资源文件的目录名与资源类型一一对应，不可更改</li>
<li>Available aualifiers: 可用的资源限定符
<ul>
<li>Country Code: 移动设备国家代码，唯一识别移动用户所属国家</li>
<li>Network Code: 移动设备网络代码，与Country Code相结合，用来表示唯一一个移动设备的网络运营商</li>
<li>Local: 国际化(多语言)</li>
<li>Layout Direction: 布局方向</li>
<li>Smallest Screen Width: 最小屏幕宽度。这个值是布局支持的最小宽度，而不管屏幕的当前方向</li>
<li>Screen Width: 最小的可用屏幕宽度。当方向在横向和纵向之间改变时，这个值会跟当前的实际宽度相匹配</li>
<li>Screen Height: 最小的可用屏幕高度</li>
<li>Size: 屏幕尺寸
<ul>
<li>Small: 小屏幕尺寸，320 * 426dp</li>
<li>Normal: 中等屏幕尺寸，320 * 470dp</li>
<li>Large: 大屏幕尺寸，480 * 640dp</li>
<li>X-large: 超大屏幕尺寸，720 * 960dp</li>
</ul></li>
<li>Ratio: 宽高比率，指的是实际的物理尺寸宽高比率，分为Long和NotLong</li>
<li>Orientation: 限制横竖屏切换
<ul>
<li>Portrait: 竖屏</li>
<li>Landscape: 横屏</li>
<li>Square: 正方形</li>
</ul></li>
<li>UI Mode: UI模式
<ul>
<li>Car Dock: 车座</li>
<li>Desk Dock: 桌座</li>
<li>Television: 电视上</li>
<li>Application: 装置</li>
<li>Watch: 手表</li>
</ul></li>
<li>Night Mode: 夜间模式
<ul>
<li>Not Night: 白天</li>
<li>Night: 夜间</li>
</ul></li>
<li>Density: 密度,指定不同密度的手机使用不同的资源</li>
<li>Touch Screen: 触屏类型
<ul>
<li>No Touch: 非触屏</li>
<li>Stylus: 触控笔</li>
<li>Finger: 手指</li>
</ul></li>
<li>Keyboard: 键盘类型
<ul>
<li>Exposed: 设备有可用的键盘</li>
<li>Hidden: 设备有可用的硬键盘</li>
<li>Soft: 设备有可用的软键盘</li>
</ul></li>
<li>Text Input: 文本输入法
<ul>
<li>No Keys: 设备没有用于文本输入的硬键盘</li>
<li>Qwerty: 设备有标准的硬键盘</li>
<li>12Key: 设备有12个键的硬键盘</li>
</ul></li>
<li>Navigation State: 导航键的状态
<ul>
<li>Exposed: 导航键可用</li>
<li>Hidden: 导航键不可用</li>
</ul></li>
<li>Navigation Method: 导航方法
<ul>
<li>None: 除了使用触屏以外，设备没有其他导航设施</li>
<li>D-pad: 设备有用于导航的定向板</li>
<li>Trackball: 设备有用于导航的轨迹球</li>
<li>Wheel: 设备有用于导航的定向滚轮</li>
</ul></li>
<li>Dimension: 自定义屏幕尺寸</li>
<li>Version: 版本,设备支持的API级别</li>
</ul></li>
</ul>

<h3 id="toc_38">创建不同分辨率图标</h3>

<p><strong>操作步骤</strong>: File -&gt; 右击Module -&gt; New -&gt; Image Asset -&gt; Asset Studio对话框</p>

<ul>
<li>Icon Type: 图标类型
<ul>
<li>Launcher Icons(Adaptive and Legacy): 自适应和传统的图标</li>
<li>Launcher Icons(Legacy Only): 传统图标</li>
<li>Action Bar and Tab Icons: 标题栏和选项卡图标</li>
<li>Notification Icons: 通知图标</li>
</ul></li>
<li>Asset Type: 资源类型
<ul>
<li>Image: 本地图片，自动生成不同分辨率的图标</li>
<li>Clip Art: 剪贴画，Android Icon</li>
<li>Text: 文字图标</li>
</ul></li>
<li>Trim: 去除图标周围多余的空白</li>
<li>Scaling: 图标缩放</li>
<li>Shape: 图标形状</li>
<li>Effect: 设置文件折叠特效</li>
</ul>

<h3 id="toc_39">创建矢量图</h3>

<p><strong>操作步骤</strong>: File -&gt; 右击Module -&gt; New -&gt; Vector Asset -&gt; Configure Image Asset对话框</p>

<p>可以同时使用Android提供的和本地的svg图片<br/>
可以设置颜色，大小和透明度</p>

<h3 id="toc_40">创建AIDL文件</h3>

<p><strong>操作步骤</strong>: File -&gt; 右击Module -&gt; New -&gt; AIDL -&gt; AIDL File</p>

<h3 id="toc_41">创建Android文件夹</h3>

<table>
<thead>
<tr>
<th style="text-align: left">文件夹</th>
<th style="text-align: left">作用</th>
<th style="text-align: left">默认位置</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">AIDL Folder</td>
<td style="text-align: left">用于存放AIDL文件</td>
<td style="text-align: left">src/main/aidl/</td>
</tr>
<tr>
<td style="text-align: left">Assets Folder</td>
<td style="text-align: left">用于存放原生资源文件</td>
<td style="text-align: left">src/main/assets/</td>
</tr>
<tr>
<td style="text-align: left">JNI Folder</td>
<td style="text-align: left">用于存放JNI文件</td>
<td style="text-align: left">src/main/jni/</td>
</tr>
<tr>
<td style="text-align: left">Java Folder</td>
<td style="text-align: left">用于存放Java文件</td>
<td style="text-align: left">src/main/java/</td>
</tr>
<tr>
<td style="text-align: left">Java Resources Folder</td>
<td style="text-align: left">用于存放Java资源文件</td>
<td style="text-align: left">src/main/resources/</td>
</tr>
<tr>
<td style="text-align: left">RenderScript Folder</td>
<td style="text-align: left">用于存放RenderScript文件</td>
<td style="text-align: left">src/main/rs/</td>
</tr>
<tr>
<td style="text-align: left">Res Folder</td>
<td style="text-align: left">用于存放Android资源文件</td>
<td style="text-align: left">src/main/res/</td>
</tr>
</tbody>
</table>

<h3 id="toc_42">创建Resource Bundle文件</h3>

<p>ResourceBundle(资源绑定)最大好处是可以使程序国际化，在bundle文件名后加上国家、语言关键字，系统就会自动载入相应的bundle文件。<br/>
properties文件一般的命名规范是: 自定义名_语言代码_国别代码.properties</p>

<p><strong>操作步骤</strong>: File -&gt; 右击Module -&gt; New -&gt; Resource Bundle -&gt; 输入文件名&quot;success&quot; -&gt; 添加语言代码 -&gt; 双击打开properties -&gt; 切换到Resource Bundle -&gt; 点击+ -&gt; 输入主键 -&gt; 可以同时编辑不同语言的值</p>

<h2 id="toc_43">管理</h2>

<h3 id="toc_44">项目窗口</h3>

<p>Android Studio中支持好多种视图模式，要学会在适合的时候用适合的视图，提高开发效率</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20180806153357044143471.png" alt="20180806153357044143471.png"/><figcaption>20180806153357044143471.png</figcaption></figure></p>

<h4 id="toc_45">视图模式</h4>

<h5 id="toc_46">Project视图模式</h5>

<p>Project视图模式展示全部文件信息，文件的位置是真实的物理结构。因此在查看文件的时候建议切换到Project模式。</p>

<h5 id="toc_47">Packages视图模式</h5>

<p>Packages视图模式仅显示项目本身的代码和资源，其他的信息被隐藏了，代码和资源都以层级文件的形式显示。</p>

<h5 id="toc_48">Scratches视图模式</h5>

<p>Scratches视图模式只显示草稿文件。</p>

<p>Scratch Files(草稿文件)是一个非常方便的功能，可以帮助我们快速实验和建立原型，可以在不修改项目和创建任何文件的情况下快速画出草图。</p>

<h5 id="toc_49">Android视图模式</h5>

<p>Android视图模式会把一些我们不关心的文件和目录隐藏起来，以一种扁平化的方式显示项目结构，文件和目录通过类型进行分类，可以非常方便的查看文件。</p>

<h5 id="toc_50">Project Files视图模式</h5>

<p>Project Files视图模式是类似Eclipse的项目结构类型。</p>

<h5 id="toc_51">Problems视图模式</h5>

<p>Problems模式仅显示报错的文件结构。</p>

<h5 id="toc_52">Production视图模式</h5>

<p>Production模式仅显示生产文件结构。</p>

<h5 id="toc_53">Tests视图模式</h5>

<p>Tests模式仅显示测试文件结构。</p>

<h4 id="toc_54">常用设置和操作</h4>

<h5 id="toc_55">展开和收缩窗口</h5>

<p><strong>展开窗口</strong>: shift + command + -&gt; 每操作一次窗口向右扩展一下<br/><br/>
<strong>收缩窗口</strong>: shift + command + &lt;- 每操作一次窗口向左收缩一下<br/><br/>
<strong>最大化窗口</strong>: shift + command + &quot;&#39;&quot;  </p>

<h5 id="toc_56">定位文件在项目中的位置</h5>

<p>Scroll from Source按钮</p>

<h5 id="toc_57">收起所有项目</h5>

<p>Collapse All按钮</p>

<p>command + &quot;-&quot;</p>

<h5 id="toc_58">扁平化显示包名</h5>

<p>选中 Flatten Packages，所有包名都会显示在同一级目录下，不会有层次结构</p>

<h5 id="toc_59">隐藏空的中间包名</h5>

<p>选中 Hide Empty Middle Packages。项目窗口中的含有空文件夹的包名将会被隐藏。</p>

<h5 id="toc_60">缩写限定包名</h5>

<p>选中 Abbreviate Qualified Package Names。项目缩写包名</p>

<h5 id="toc_61">显示成员</h5>

<p>选中 Show Members。让项目窗口中的文件显示其他成员(字段、方法)</p>

<h5 id="toc_62">按类型排序</h5>

<p>选中 Sort By Type。让文件按类型排序，否则项目窗口中的文件按字母排序。</p>

<h5 id="toc_63">文件夹显示在文件之前</h5>

<p>选中 Folder Always on Top。让所有文件夹始终在文件之前，否则所有的文件和文件夹都会混在一起，按字母排序。</p>

<h5 id="toc_64">单击文件打开源码</h5>

<p>选中 Autoscroll to Source。项目窗口中单击文件就能够在编辑器中自动打开。</p>

<h5 id="toc_65">从源码定位到文件</h5>

<p>选中 Autoscroll from Source。打开源码后自动定位到该文件在项目窗口中的位置。</p>

<h3 id="toc_66">项目管理</h3>

<h4 id="toc_67">管理最近打开的项目</h4>

<h5 id="toc_68">为最近打开的项目进行分组</h5>

<p>方便管理多个项目</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; File -&gt; Open Recent -&gt; Manager Projects。<br/>
新建分组: 右击项目名称 -&gt; New Project Group -&gt; 输入分组名 -&gt; OK。<br/>
添加分组: 右击项目名称 -&gt; Move To Group —&gt; 在列出的项目分组中选择目标分组。</p>

<h5 id="toc_69">改变目标默认图标</h5>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; File -&gt; Open Recent -&gt; Manager Projects —&gt; 右击项目名称 -&gt; Change Icon。</p>

<h5 id="toc_70">从欢迎界面移除</h5>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; File -&gt; Open Recent -&gt; Manager Projects —&gt; 右击项目名称 -&gt; Remove Selected from  Welcome Screen。</p>

<h5 id="toc_71">设置记录最近打开项目的个数</h5>

<p>Android Studio默认记录最新的50个项目。<br/>
<strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; 单击General -&gt; 在Limits中调整Recent files limit个数。</p>

<h4 id="toc_72">清除缓存/重启Android Studio</h4>

<p>当我们直接修改Android Studio的配置文件时，配置没有生效或者遇到一些莫名其妙的错误时，可以尝试清除缓存再重启Android Studio来解决问题</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; File -&gt; Invalidate Caches/Restart(清除缓存/重启) -&gt; 进入确认界面。</p>

<h3 id="toc_73">收藏夹</h3>

<p>在Android Studio的日常编码中，如果某个文件或某段代码使我们经常需要查看或试用的，就可以把它添加到收藏夹中，以便快速查看。</p>

<h4 id="toc_74">添加</h4>

<p><strong>添加文件</strong>: 右击文件 -&gt; Add to Favorites -&gt; 选中已存在的收藏夹中的收藏列表或添加到一个新建的收藏列表。<br/><br/>
<strong>添加方法</strong>: 将光标放在方法名上 -&gt; 菜单栏 -&gt; File -&gt; Add to Favorites -&gt; Add New Favorites List -&gt; 选中已存在的收藏夹中的收藏列表或添加到一个新建的收藏列表。<br/><br/>
<strong>添加断点</strong>: 打上断点，断点会自动被添加到收藏夹。</p>

<h3 id="toc_75">TODO</h3>

<p>在Android Studio中待处理的任务可以再注释中使用TODO来标识，以表明这个地方是需要注意的，既有可能是未完成的功能，也有可能是需要解决的BUG或者是需要优化的代码。</p>

<h4 id="toc_76">添加TODO任务</h4>

<p>在注释中输入TODO关键字</p>

<h4 id="toc_77">功能键</h4>

<ul>
<li>Expand All 展开所有</li>
<li>Collapse All 收起所有</li>
<li>Group By Modules 按模块分组</li>
<li>Group By Packages 按包名分组</li>
<li>Flatten Packages 扁平化显示包名</li>
<li>Autoscroll to Source 自动打开源码</li>
<li>Preview Source 自动预览源码</li>
<li>Previous TODO 向上跳转任务</li>
<li>Next TODO 向下跳转任务</li>
<li>Filter TODO items 过滤任务</li>
</ul>

<p>可以在偏好设置 -&gt; Editor -&gt; TODO 中进行设置</p>

<h4 id="toc_78">自定义TODO关键字</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; TODO -&gt; 添加按钮 -&gt; 输入匹配表达式 -&gt; 选择icon -&gt; 设置颜色</p>

<h2 id="toc_79">编辑</h2>

<h3 id="toc_80">合并两行内容</h3>

<p>通常我们要合并两行内容都是狂按删除键来删除两行之间的空格，然后对代码的格式进行调整。Android Studio给我们提供了一个自动合并两行内容的功能，可以智能地合并字符串、注释、声明和赋值，一键完成以上操作。</p>

<p>菜单栏: Edit -&gt; Join Lines<br/><br/>
快捷键: control + Shift + J</p>

<h3 id="toc_81">选择技巧</h3>

<h4 id="toc_82">扩大缩小选择范围</h4>

<h5 id="toc_83">扩大</h5>

<p>菜单栏: Edit -&gt; Extend Selection<br/><br/>
快捷键: option + 向上箭头</p>

<h5 id="toc_84">缩小</h5>

<p>菜单栏: Edit -&gt; Shrink Selection<br/><br/>
快捷键: option + 向下箭头</p>

<h4 id="toc_85">列选择模式</h4>

<p>菜单栏: Edit -&gt; Column Selection Mode<br/><br/>
快捷键: Shift + command + 8</p>

<h3 id="toc_86">自动补全当前的语句</h3>

<p>菜单栏: Edit -&gt; Complete Current Statement<br/><br/>
快捷键: Shift + command + 回车</p>

<h3 id="toc_87">一键切换大小写</h3>

<p>菜单栏: Edit -&gt; Toggle Case<br/>
快捷键: Shift + command + U</p>

<h3 id="toc_88">查找工具栏</h3>

<h4 id="toc_89">打开查找工具栏</h4>

<p>快捷键: command + F</p>

<h4 id="toc_90">查找范围设置</h4>

<ul>
<li>In Comments Only: 仅在注释中搜索</li>
<li>In Literals Only: 仅在文本中搜索</li>
<li>Except Comments: 注释除外</li>
<li>Except Literals: 文本除外</li>
<li>Except Comments and Literals: 注释和文本除外</li>
</ul>

<h3 id="toc_91">指定查找路径</h3>

<p>除了在当前文件中查找以外，还可以在其他路径中查找，另外，还可以设置很多查找条件，以方便更加精确和快速地得到查找结果。</p>

<p>菜单栏: Edit -&gt; Find -&gt; Find in Path...<br/><br/>
快捷键: shift + command + F</p>

<h3 id="toc_92">指定替换路径</h3>

<p>菜单栏: Edit -&gt; Find -&gt; Replace in Path...<br/><br/>
快捷键: shift + command + R</p>

<ul>
<li>单击【Replace】: 一个个替换</li>
<li>单击【Skip】: 会跳过当前匹配结果</li>
<li>单击【Replace All in This File】: 替换当前文件中所有的匹配结果</li>
<li>单击【Skip To Next File】: 会跳跳到下一个文件</li>
<li>单击【All Files】: 全部替换</li>
<li>单击【Review】: 在工具栏显示查找结果，单击结果可以查看详情</li>
</ul>

<h3 id="toc_93">在结构中查找和替换</h3>

<p>Android Studio提供了一个使用代码模板查找和替换的方式，可以方便地定义代码模板</p>

<p><strong>操作步骤</strong>:菜单栏 -&gt; Edit -&gt; Find -&gt; Search Structurally/Replace Structurally -&gt; 打开【Structural Search】</p>

<h3 id="toc_94">查找用法</h3>

<p>想看方法或者变量在哪些地方进行调用</p>

<p>菜单栏: Edit -&gt; Find -&gt; Find Usages<br/><br/>
右键菜单: Find Usages<br/><br/>
快捷键: fn + option + F7</p>

<ul>
<li>Skip results tab with one usage: 当搜索的数据只有一个地方使用时，不显示搜索结果标签，光标会直接跳到使用的地方。</li>
<li>Scope: 设置查找范围，使查找更加快速和精确</li>
<li>Open in new tab: 如果勾选了此项，每一次查找都会打开一个新的标签，如果不勾选此项，那么每次新的查找结果将会覆盖上一次的查找结果</li>
</ul>

<h3 id="toc_95">显示用法</h3>

<p>显示用法功能不会另外打开一个工具窗口来显示查找结果，而是直接弹出提示框显示数据在何处被使用。</p>

<p>菜单栏: Edit -&gt; Find -&gt; Show Usages<br/>
快捷键: fn + option + command + F7</p>

<h4 id="toc_96">功能</h4>

<ul>
<li>合并相同行</li>
<li>显示读取访问权限</li>
<li>显示写访问权限</li>
<li>显示import语句</li>
<li>按文件结构分组</li>
</ul>

<h3 id="toc_97">查看在当前文件中的用法</h3>

<p>菜单栏: Edit -&gt; Find -&gt; Find Usages in File<br/>
快捷键: command + F7</p>

<h3 id="toc_98">Macros(宏)</h3>

<p>宏是一种批处理的称谓，由一些命令组织在一起，作为一个单独的命令来完成一个特定任务。</p>

<h4 id="toc_99">录制回放宏</h4>

<ol>
<li>选择Eidt -&gt; Macros -&gt; Start Macros Recording -&gt; Android Studio右下角显示开始录制提示</li>
<li>按快捷键command + s保存文件</li>
<li>按快捷键control + s运行代码</li>
<li>选择Eidt -&gt; Macros -&gt; Stop Macros Recording -&gt; 在输入框中输入已录制宏的名字</li>
<li>定义快捷键。选择Android Studio -&gt; Keymap -&gt; Macros -&gt; 找到刚才录制的宏【AutoSaveAndRun】</li>
</ol>

<h2 id="toc_100">视图</h2>

<h3 id="toc_101">工具窗口</h3>

<h4 id="toc_102">显示/隐藏工具窗口</h4>

<ul>
<li>打开/隐藏 项目工具窗口: command + 1</li>
<li>打开/隐藏 收藏工具窗口: command + 2</li>
<li>打开/隐藏 运行窗口: command + 4</li>
<li>打开/隐藏 调试窗口: command + 5</li>
<li>打开/隐藏 Android Monitor工具窗口: command + 6</li>
<li>打开/隐藏 项目结构窗口: command + 7</li>
<li>打开/隐藏 版本控制工具窗口: command + 9</li>
<li>打开/隐藏 终端工具窗口: fn + option + F12</li>
</ul>

<h4 id="toc_103">快速切换工具窗口</h4>

<p>快捷键: control + Tab</p>

<h3 id="toc_104">查看同胞元素</h3>

<p>快速查看同胞元素是指查看跟当前类一样继承自同一个父类的所有元素<br/><br/>
<strong>操作步骤</strong>:菜单栏 -&gt; View -&gt; Show Siblings</p>

<h3 id="toc_105">查看文档</h3>

<p>菜单栏: View -&gt; Quick Documentation<br/><br/>
快捷键: fn + F1</p>

<h4 id="toc_106">设置鼠标悬停在元素上会显示文档提示</h4>

<p><strong>操作步骤</strong>:偏好设置 -&gt; Editor -&gt; General -&gt; Other -&gt; 勾选【Show quick documentation on mouse move】</p>

<h3 id="toc_107">查看方法的参数信息</h3>

<p>菜单栏: View -&gt; Parameter Info<br/><br/>
快捷键: command + P</p>

<h3 id="toc_108">查看上下文信息</h3>

<p>菜单栏: View -&gt; Context Info<br/><br/>
快捷键: control + shift + Q</p>

<h3 id="toc_109">查看源码</h3>

<p>菜单栏: View -&gt; Jump to Source<br/><br/>
快捷键: command + 向下箭头<br/><br/>
鼠标: 按住command键，再用鼠标单击对应的方法或类</p>

<h3 id="toc_110">查看最近打开过的文件</h3>

<p>菜单栏: View -&gt; Recent Files<br/><br/>
快捷键: command + E  </p>

<h3 id="toc_111">查看最近改动过的文件</h3>

<p>菜单栏: View -&gt; Recently Changed Files<br/><br/>
快捷键: shift + command + E  </p>

<h3 id="toc_112">查看最近的改动</h3>

<p>菜单栏: View -&gt; Recently Changed<br/><br/>
快捷键: shift + control + C</p>

<h3 id="toc_113">对比任意文件</h3>

<p>菜单栏: View -&gt; Compare With<br/><br/>
快捷键: command + D</p>

<p>将光标放在文件上，按快捷键command + D，选择要对比的文件。</p>

<ul>
<li>Do not ignore: 不忽略空格</li>
<li>Trim whitespaces: 删掉空格</li>
<li>Ignore whitespaces: 忽略空格</li>
<li><p>Ignore whitespaces and empty lines: 忽略空格和空行</p></li>
<li><p>Highlight lines: 高亮行</p></li>
<li><p>Highlight words: 高亮字</p></li>
<li><p>Highlight split changes: 高亮拆分的变动</p></li>
<li><p>collapse unchanged fragment: 折叠没有变动的代码片段</p></li>
<li><p>Show Whitespaces: 显示空格</p></li>
<li><p>Show Line Numbers: 显示行号</p></li>
<li><p>Show Indent Guides: 显示缩进向导</p></li>
<li><p>Use Soft Wraps: 使用自动换行</p></li>
</ul>

<h3 id="toc_114">将选中的文件和正在编辑的文件进行对比</h3>

<p>菜单栏: View -&gt; Compare File with Editor</p>

<h3 id="toc_115">将选中的文件和剪贴板上的内容进行对比</h3>

<p>菜单栏: View -&gt; Compare with Clipboard</p>

<h3 id="toc_116">设置编辑器是否显示空格</h3>

<p>默认编辑器是不会显示空格的</p>

<h4 id="toc_117">设置当前编辑器是否显示空格</h4>

<p>只对当前打开的文件进行临时设置，可以通过<br/><br/>
菜单栏: View -&gt; Active Editor -&gt; Show Whitespaces</p>

<h4 id="toc_118">设置整个编辑器显示空格</h4>

<p><strong>操作步骤</strong>:偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show whitespaces】</p>

<ul>
<li>Leading: 开头</li>
<li>Inner: 中间</li>
<li>Trailing: 结尾</li>
</ul>

<h3 id="toc_119">设置编辑器是否显示行号</h3>

<p>默认编辑器是不会显示空格的</p>

<h4 id="toc_120">设置当前编辑器是否显示行号</h4>

<p>只对当前打开的文件进行临时设置，可以通过<br/><br/>
菜单栏: View -&gt; Active Editor -&gt; Show line number<br/><br/>
快捷键: 右击编辑器窗口左边栏 -&gt; Show Line Numbers</p>

<h4 id="toc_121">设置整个编辑器显示行号</h4>

<p><strong>操作步骤</strong>:偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show line numbers】</p>

<h3 id="toc_122">设置编辑器是否显示缩进向导</h3>

<p>默认编辑器是显示的</p>

<h4 id="toc_123">设置当前编辑器是否显示缩进向导</h4>

<p>只对当前打开的文件进行临时设置，可以通过<br/><br/>
菜单栏: View -&gt; Active Editor -&gt; Show Indent Guides<br/><br/>
快捷键: 右击编辑器窗口左边栏 -&gt; Show Indent Guides</p>

<h4 id="toc_124">设置整个编辑器显示缩进向导</h4>

<p><strong>操作步骤</strong>:偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show vertical indent guides】</p>

<h4 id="toc_125">设置整个编辑器显示行号</h4>

<p><strong>操作步骤</strong>:偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show line numbers】</p>

<h3 id="toc_126">设置编辑器是否使用自动换行</h3>

<h4 id="toc_127">设置当前编辑器使用自动换行</h4>

<p>只对当前打开的文件进行临时设置，可以通过<br/><br/>
菜单栏: View -&gt; Active Editor -&gt; Use Soft Wraps<br/><br/>
快捷键: 右击编辑器窗口左边栏 -&gt; Use Soft Wraps</p>

<h4 id="toc_128">设置整个编辑器使用自动换行</h4>

<p><strong>操作步骤</strong>:偏好设置 -&gt; Editor -&gt; General -&gt; 查看Soft Wraps -&gt; 勾选【Use soft wraps in editor】</p>

<h4 id="toc_129">让换行符一直显示</h4>

<p>如果想显示所有的换行符，就不要勾选【show soft wrap indicators for current line only】，该项只会显示当前正在编辑行的换行符</p>

<h4 id="toc_130">设置换行后的缩进字符</h4>

<p>默认换行第二行的缩进是从第0个字符开始的，如果想自定义换行后第二行的缩进，可以勾选【Use original line`s intent for wrapped parts】,设置Additional shift。</p>

<h3 id="toc_131">设置编辑器是否弹出导入提示</h3>

<p>默认编辑器是显示的</p>

<h4 id="toc_132">设置当前编辑器弹出导入提示</h4>

<p>只对当前打开的文件进行临时设置，可以通过<br/><br/>
<strong>操作步骤</strong>:菜单栏 -&gt; View -&gt; Active Editor -&gt; Show Import Popups</p>

<h4 id="toc_133">设置整个编辑器弹出导入提示</h4>

<p><strong>操作步骤</strong>:偏好设置 -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Show Import Popup</p>

<h3 id="toc_134">使用演示模式</h3>

<p><strong>操作步骤</strong>:菜单栏 -&gt; View -&gt; Enter Presentation Mode</p>

<h4 id="toc_135">设置演示模式的字体大小</h4>

<p>使用演示模式会默认进入免打扰模式和全屏模式，如果不想进入免打扰模式和全屏模式可以单独退出<br/>
<strong>操作步骤</strong>:偏好设置 -&gt; Appearance&amp;Behavior -&gt; Appearance -&gt; Presentation Mode</p>

<h3 id="toc_136">使用免打扰模式</h3>

<p>如果不想界面上有其他多余的东西干扰，会隐藏菜单栏、工具栏<br/><br/>
<strong>操作步骤</strong>:菜单栏 -&gt; View -&gt; Enter Distraction Free Mode</p>

<h3 id="toc_137">使用全屏模式</h3>

<p><strong>操作步骤</strong>:菜单栏 -&gt; View -&gt; Enter Full Mode</p>

<h2 id="toc_138">导航</h2>

<h3 id="toc_139">搜索并打开类文件</h3>

<p>如果想在项目中搜索某个类文件  </p>

<p>菜单栏: Navigate -&gt; Class<br/><br/>
快捷键: command + N  </p>

<h3 id="toc_140">搜索并打开文件</h3>

<p>如果想在项目中搜索其他文件</p>

<p>菜单栏: Navigate -&gt; File<br/><br/>
快捷键: shift + command + N  </p>

<h3 id="toc_141">搜索并打开某个文件或方法</h3>

<p>如果想在项目中搜索文件和方法</p>

<p>菜单栏: Navigate -&gt; Symbol<br/><br/>
快捷键: option + shift + command + N  </p>

<h3 id="toc_142">自定义代码块</h3>

<p>选中自定义的代码片段 -&gt; 菜单栏: Code -&gt; Surround With 或 按快捷键option + command + T</p>

<p>可以修改代码块描述，并且可以和普通代码块一样对这段代码进行展开和折叠</p>

<h4 id="toc_143">在自定义代码块之间选择和跳转</h4>

<p>菜单栏: Navigate -&gt; Custom Folding<br/><br/>
快捷键: option + command + &quot;.&quot;</p>

<h3 id="toc_144">快速跳到某一行代码</h3>

<p>菜单栏: Navigate -&gt; Line<br/><br/>
快捷键: command + G</p>

<h3 id="toc_145">快速跳转到光标的历史位置</h3>

<p>菜单栏: Navigate -&gt; Back/Forward<br/><br/>
快捷键: command + &quot;[&quot; / &quot;]&quot;</p>

<h3 id="toc_146">快速跳转到编辑过的历史位置</h3>

<p>菜单栏: Navigate -&gt; Last Edit Location / Next Edit Location<br/><br/>
快捷键: shift + command + delete</p>

<h3 id="toc_147">标记书签</h3>

<p>对代码进行标记，标记我们阅读的位置</p>

<ul>
<li>Toggle Bookmark: 标记书签</li>
<li>Toggle Bookmark with Mnemonic: 使用助记符标记书签</li>
<li>Show Bookmark: 显示书签</li>
<li>Next Bookmark: 下一个书签</li>
<li>Previous Bookmark: 上一个书签</li>
</ul>

<p>菜单栏: Navigate -&gt; Bookmarks -&gt; Toggle Bookmark<br/>
快捷键: fn + F3</p>

<h3 id="toc_148">快速跳到声明</h3>

<p>在写代码或者阅读代码时，想快速查看一个引用首次被声明的位置<br/><br/>
菜单栏: Navigate -&gt; Declaration<br/><br/>
鼠标: 按住command + 单击类、变量或方法  </p>

<h3 id="toc_149">快速跳到实现</h3>

<p>菜单栏: Navigate -&gt; Implementation<br/><br/>
鼠标: option + command + B</p>

<h3 id="toc_150">快速跳到类型声明</h3>

<p>菜单栏: Navigate -&gt; Type Declaration<br/><br/>
快捷键: shift + command + B<br/><br/>
鼠标: 按住command + shift + B</p>

<h3 id="toc_151">快速跳转到父类</h3>

<p>菜单栏: Navigate -&gt; Super Method<br/><br/>
快捷键: command + U<br/><br/>
鼠标: 按住command + shift + B</p>

<h3 id="toc_152">类和测试类之间快速跳转</h3>

<h4 id="toc_153">快速跳转到测试类</h4>

<p>前提条件: 光标定位在类文件编辑界面<br/><br/>
菜单栏: Navigate -&gt; Test<br/><br/>
快捷键: shift + command + T</p>

<h3 id="toc_154">查看相关联的文件</h3>

<p>菜单栏: Navigate -&gt; Related Symbol<br/><br/>
快捷键: control + command + ↑</p>

<h3 id="toc_155">查看文件结构</h3>

<p>快速调出当前文件的结构，并通过模糊匹配快速跳转到指定的方法</p>

<p>菜单栏: Navigate -&gt; File Structure<br/><br/>
快捷键: fn + command + F12</p>

<h4 id="toc_156">显示匿名内部类</h4>

<p>在文件结构中显示匿名内部类，需要勾选【Show Anonymous Classes】</p>

<h4 id="toc_157">显示所有继承的方法</h4>

<p>在文件结构中显示匿名内部类，需要勾选【Show inherited members】</p>

<h4 id="toc_158">输入时缩小</h4>

<p>输入时缩小是指在输入搜索关键字时搜索结果会自动过滤，不匹配的会被过滤掉。勾选【Narrow down on tying】</p>

<h3 id="toc_159">查看类的层次结构图</h3>

<p>菜单栏: Navigate -&gt; Type Hierarchy<br/><br/>
快捷键: control + H</p>

<p>还可以切换类结构的显示方式、排序、筛选范围等</p>

<h3 id="toc_160">查看方法类型的层次结构</h3>

<p>菜单栏: Navigate -&gt; Type Method<br/><br/>
快捷键: shift + command + H</p>

<h3 id="toc_161">查看方法调用层次结构</h3>

<p>菜单栏: Navigate -&gt; Call Hierarchy<br/><br/>
快捷键: control + option + H</p>

<h3 id="toc_162">快速跳转到错误代码的位置</h3>

<h4 id="toc_163">跳转到下一个错误位置</h4>

<p>菜单栏: Navigate -&gt; Next Highlighted Error<br/><br/>
快捷键: fn + F12</p>

<h4 id="toc_164">跳转到上一个错误位置</h4>

<p>菜单栏: Navigate -&gt; Previous Highlighted Error<br/><br/>
快捷键: fn + Shift + F12</p>

<h3 id="toc_165">在方法间前后跳转</h3>

<h4 id="toc_166">跳转到下一个方法</h4>

<p>菜单栏: Navigate -&gt; Next Method<br/><br/>
快捷键: control + ↑</p>

<h4 id="toc_167">跳转到上一个方法</h4>

<p>菜单栏: Navigate -&gt; Previous Method<br/><br/>
快捷键: control + ↓</p>

<h3 id="toc_168">翻页功能</h3>

<p>向上翻页: fn + ↑<br/>
向下翻页: fn + ↓</p>

<h3 id="toc_169">选择当前功能在哪里显示</h3>

<p>菜单栏: Navigate -&gt; Select in<br/><br/>
快捷键: fn + option + F1</p>

<h3 id="toc_170">光标快速跳转到页首/页尾</h3>

<p>页首: fn + command + ←<br/>
页尾: fn + command + →</p>

<h2 id="toc_171">编码</h2>

<h3 id="toc_172">覆写或实现方法</h3>

<p>菜单栏: Code -&gt; Override Method<br/><br/>
快捷键: control + O</p>

<h3 id="toc_173">实现接口方法</h3>

<p>菜单栏: Code -&gt; Implement Methods<br/><br/>
快捷键: control + L</p>

<h3 id="toc_174">实现代理方法</h3>

<p>菜单栏: Code -&gt; Delegate Methods<br/><br/>
右键菜单: 右击 -&gt; Generate -&gt; Delegate Methods<br/>
快捷键: command + N</p>

<h3 id="toc_175">生成构造函数/生成Getter和Setter方法/覆写equals和hashcode方法/覆写toString方法/插入版权信息</h3>

<p>菜单栏: Code -&gt; Generate -&gt; Constructor/Getter and Setter/equals() and hashCode()/toString()/Copyright<br/><br/>
快捷键: command + N</p>

<h4 id="toc_176">配置版权信息</h4>

<p>菜单栏: Android Studio -&gt; Preferences -&gt; Copyright -&gt; Copyright Profiles  </p>

<h4 id="toc_177">共享版权信息配置</h4>

<p>我们创建的copyright文件放在项目根目录/.idea/copyright下，直接把copyright这个目录复制给团队中的其他人即可实现共享。</p>

<h3 id="toc_178">提取或删除代码</h3>

<p>如果我们想从for、foreach、if...elseif...else、try...catch...finally、while...do、do...while中快速提取或删除代码。</p>

<p>菜单栏: Code -&gt; Unwrap/Remove<br/><br/>
快捷键: command + shift + delete</p>

<h3 id="toc_179">自动补全提示</h3>

<p>菜单栏: Code -&gt; Completion -&gt; Basic<br/>
快捷键: control + 空格</p>

<h4 id="toc_180">智能自动补全提示</h4>

<p>该项会把不适用的条目过滤掉，只显示可用的类、变量、属性或方法</p>

<p>菜单栏: Code -&gt; Completion -&gt; SmartType<br/>
快捷键: control + Shift + 空格</p>

<h3 id="toc_181">代码补全</h3>

<h3 id="toc_182">补全后不删除后面的代码</h3>

<p><strong>操作步骤</strong>:弹出代码补全提示 -&gt; 选中补全代码 -&gt; 鼠标/Enter</p>

<h3 id="toc_183">补全后删除后面的代码</h3>

<p><strong>操作步骤</strong>:弹出代码补全提示 -&gt; 选中补全代码 -&gt; Tab</p>

<h4 id="toc_184">布尔值取反补全</h4>

<p><strong>操作步骤</strong>:弹出代码补全提示 -&gt; 选中补全代码 -&gt; 叹号(!)</p>

<h4 id="toc_185">点和分号补全</h4>

<p><strong>操作步骤</strong>:弹出代码补全提示 -&gt; 选中补全代码 -&gt; 点(.)或分号(;)</p>

<h3 id="toc_186">展开或折叠代码</h3>

<h4 id="toc_187">展开或折叠当前代码</h4>

<p>此功能仅会展开或折叠当前光标所在处的一段代码</p>

<p>菜单栏: Code -&gt; Folding -&gt; Expand/Collapse<br/><br/>
快捷键: command + &quot;+&quot;/&quot;-&quot;</p>

<h4 id="toc_188">展开或折叠当前代码块中的所有子模块</h4>

<p>菜单栏: Code -&gt; Folding -&gt; Expand Recursively/Collapse Recursively<br/><br/>
快捷键: option + command + &quot;+&quot;/&quot;-&quot;</p>

<h4 id="toc_189">展开或折叠全部代码块</h4>

<p>菜单栏: Code -&gt; Folding -&gt; Expand All/Collapse All<br/><br/>
快捷键: shift + command + &quot;+&quot;/&quot;-&quot;</p>

<h4 id="toc_190">展开或折叠当前文件中的所有注释</h4>

<p>菜单栏: Code -&gt; Folding -&gt; Expand doc comments/Collapse doc comments</p>

<h4 id="toc_191">指定展开层级</h4>

<p>指定展开代码层级: Code -&gt; Folding -&gt; Expand to level<br/><br/>
指定全部展开代码的层级: Code -&gt; Folding -&gt; Expand all to level</p>

<h4 id="toc_192">展开和折叠选中区域</h4>

<p>菜单栏: Code -&gt; Folding -&gt; Fold Selection/Remove regio<br/><br/>
快捷键: command + &quot;.&quot;</p>

<h4 id="toc_193">折叠代码片段</h4>

<p>此功能来折叠{}中的代码片】= + &quot;.&quot;</p>

<h3 id="toc_194">插入代码块</h3>

<p>Live Template就是把常用的代码提取成一个模板，在编写代码的时候可以通过非常少的字幕调出这个模板，达到快速输入，提高效率的目的。</p>

<p>菜单栏: Code -&gt; Insert Live Template<br/><br/>
快捷键: shift + command + &quot;.&quot;</p>

<h4 id="toc_195">类中常用的缩写</h4>

<ul>
<li><code>geti + tab //插入单例方法</code></li>
<li><code>psf + tab //插入public static final</code></li>
<li><code>psfi + tab //插入public static final int</code></li>
<li><code>psfs + tab //插入public static final String</code></li>
<li><code>psvm + tab //插入main方法声明</code></li>
<li><code>St + tab //插入String</code></li>
</ul>

<h4 id="toc_196">方法中常用的缩写</h4>

<h5 id="toc_197">常用代码模板</h5>

<ul>
<li><code>ifn + tab //null判断</code> <code>if(变量 == null){}</code></li>
<li><code>inn + tab //非空判断</code> <code>if(变量 != null){}</code></li>
<li><code>lazy + tab //延迟初始化</code> <code>if(对象 == null){ 对象 == new String();}</code></li>
<li><code>mn + tab //得到2个变量中较小的</code> <code>变量 = Math.min(变量1,变量2);</code></li>
<li><code>mx + tab //得到2个变量中较大的</code> <code>变量 = Math.max(变量1,变量2);</code></li>
<li><code>inst + tab //判断变量是否是某个对象的实例</code> <code>if(变量 instanceof Object){ Object = (Object)变量;}</code></li>
<li><code>toar + tab //把collection的对象存储到一个数组里</code> <code>.toArray(new Object[.size()])</code></li>
<li><code>thr + tab //抛出异常</code> <code>throw new</code></li>
</ul>

<h5 id="toc_198">循环遍历代码模板</h5>

<ul>
<li><code>fori + tab //for循环</code> <code>for(int i = 0; i &lt; ;i++){}</code></li>
<li><code>itar + tab //遍历数组</code> <code>for(int i = 0;i &lt; array.length;i++){=array[i];}</code></li>
<li><code>itco + tab //迭代器循环</code> <code>for(Iterator = collection.iterator();.hasNext();){Object = .next();}</code></li>
<li><code>iten + tab //遍历枚举内容</code> <code>while(enumeration.hasMoreElements()){Object = enumeration.nextElement();}</code></li>
<li><code>iter + tab //for each循环</code> <code>for(Onject :){}</code></li>
<li><code>itit + tab //遍历迭代器</code> <code>while(iterator.hasNext()){Object = iterator.next()}</code></li>
<li><code>itli + tab //遍历list</code> <code>for(int i = 0;i &lt; list.size();i++){Object o = list.get(i);}</code></li>
<li><code>ritar + tab //倒叙遍历数组</code> <code>for(int i = array.length - 1;i &gt;= 0;i--){ = array[i]}</code></li>
</ul>

<h5 id="toc_199">打印代码模板</h5>

<ul>
<li><code>serr + tab: System.err.println(&quot;&quot;);</code></li>
<li><code>souf + tab: System.out.printf(&quot;&quot;);</code></li>
<li><code>sout + tab: System.out.println(&quot;&quot;);</code></li>
<li><code>soutm + tab: //打印当前类名和方法名</code></li>
<li><code>soutp + tab: //打印出当前方法的所有参数列表及其值</code></li>
<li><code>soutv + tab: //打印一个变量值</code></li>
</ul>

<h3 id="toc_200">使用代码模板包裹代码</h3>

<p>菜单栏: Code -&gt; Surround with Live Template<br/><br/>
快捷键: option + command + J</p>

<ul>
<li>C.Surround with Callable: 使用Callable包围选中的代码</li>
<li>RL.Surround with ReadWriteLock.readLock: 使用ReadWriteLock读锁包围选中的代码</li>
<li>WL.Surround with ReadWriteLock.writeLock: 使用ReadWriteLock写锁包围选中的代码</li>
<li>I.Iterator Iterable | Array in J2SDK 5.0 syntax: 使用遍历包围选中的代码</li>
<li>TR.Surround with try-with-resource: 使用try-with-resource语句包围选中的代码</li>
</ul>

<h3 id="toc_201">查看和编辑代码模板</h3>

<p>菜单栏: Preferences -&gt; Editor -&gt; Live Templates<br/><br/>
快捷键: option + command + T</p>

<h3 id="toc_202">使用常用代码模板包裹代码</h3>

<p>菜单栏: Code -&gt; Surround with<br/><br/>
快捷键: option + command + T</p>

<h3 id="toc_203">注释代码</h3>

<h4 id="toc_204">注释行</h4>

<p>菜单栏: Code -&gt; Comment with Line Comment<br/><br/>
快捷键: command + /</p>

<h4 id="toc_205">注释代码块</h4>

<p>菜单栏: Code -&gt; Comment with Block<br/><br/>
快捷键: option + command + /</p>

<h3 id="toc_206">格式化代码</h3>

<p>菜单栏: Code -&gt; Reformat Code<br/><br/>
快捷键: option + command + L</p>

<h3 id="toc_207">自动缩进行</h3>

<p>菜单栏: Code -&gt; Auto-Intent Lines<br/><br/>
快捷键: option + command + I</p>

<h3 id="toc_208">优化导入</h3>

<p>优化导入，去除代码中无效的代码<br/>
菜单栏: Code -&gt; Optimize Imports<br/><br/>
快捷键: option + command + O</p>

<h3 id="toc_209">重新排列代码</h3>

<p>使用使用预设的代码规则重新排列代码<br/>
菜单栏: Code -&gt; Rearrange Code</p>

<h3 id="toc_210">移动一段代码</h3>

<h4 id="toc_211">向上移动代码</h4>

<p>菜单栏: Code -&gt; Move Statement Up<br/><br/>
快捷键: shift + command + ↑</p>

<h4 id="toc_212">向下移动代码</h4>

<p>菜单栏: Code -&gt; Move Statement Down<br/><br/>
快捷键: shift + command + ↓</p>

<h3 id="toc_213">移动一行代码</h3>

<h4 id="toc_214">向上移动代码</h4>

<p>菜单栏: Code -&gt; Move Line Up<br/><br/>
快捷键: option + command + ↑</p>

<h4 id="toc_215">向下移动代码</h4>

<p>菜单栏: Code -&gt; Move Line Down<br/><br/>
快捷键: option + command + ↓</p>

<h3 id="toc_216">正则表达式操作意图提示</h3>

<p>快捷键: option + Enter</p>

<p>快捷键弹出选择列表 -&gt; 单击Check RegExp -&gt; 弹出对话框，输入正则表达式和匹配样本</p>

<h2 id="toc_217">检查</h2>

<h3 id="toc_218">代码检查工具</h3>

<p>Android Studio提供了功能强大、快速、灵活的代码检查工具，能够检测出编译器和运行时的错误，在编译之前建议修正和改进。</p>

<p>Android Studio代码检查不仅能检查出编译错误，还会检查出一些效率低下的代码，支持一些代码规范、编程指南、最佳实践，还有一些无法访问，未使用的代码内存泄漏都能检查出来。  </p>

<p>目前支持的语言有Android、Java、XML、HTML</p>

<p><strong>代码检查所涵盖的最常见的任务</strong>:  </p>

<ul>
<li>发现可能的错误</li>
<li>定位死代码</li>
<li>检测性能问题</li>
<li>改进可维护性和代码结构</li>
<li>与编码准则和标准一致</li>
<li>符合规范</li>
</ul>

<h3 id="toc_219">全面了解Lint</h3>

<p>Lint是谷歌从Android 4.1版本开始提供的代码分析工具，可以再不执行应用或测试用例的情况下检查出代码结构和质量问题。</p>

<p>Android Lint主要用于检查以下错误</p>

<ul>
<li>缺少转义</li>
<li>布局性能问题</li>
<li>未使用的冗余资源</li>
<li>在数组中定义多个配置时，数组大小不一致</li>
<li>可访问行问题和国际化的问题</li>
<li>图标问题</li>
<li>可用性问题</li>
<li>配置文件错误</li>
</ul>

<h4 id="toc_220">报告中的Issue 和 Category</h4>

<h5 id="toc_221">Issue</h5>

<p>Lint检查出的所有问题都是以Issue来描述的。Issue以一个文本短语来作为id，对Issue的定制等操作都是基于id的。Issue以Severity来标识危害程度。</p>

<h5 id="toc_222">Category</h5>

<ul>
<li>Accessibility(可访问性)</li>
<li>Correctness(正确性)</li>
<li>Correctness &gt; Messages(正确性:信息)</li>
<li>Internationalization(国际化)</li>
<li>Internationalization &gt; Bidirectional Text(双向文本)</li>
<li>Performance(性能)</li>
<li>Security(安全)</li>
<li>Usability(可用性)</li>
<li>Usability:Icons(可用性:图标)</li>
<li>Usability:Typography(可用性:字体)</li>
</ul>

<h4 id="toc_223">Lint使用场景</h4>

<p>lint检查范围</p>

<ul>
<li>整个项目</li>
<li>项目中的每个模块</li>
<li>项目中的每个产品模块</li>
<li>项目中的每个测试模块</li>
<li>每个打开状态的文件</li>
<li>每个类结构</li>
<li>每个版本控制系统范围</li>
</ul>

<p>配置Lint方法</p>

<ul>
<li>在Android Studio偏好设置中配置</li>
<li>在lint.xml文件中配置</li>
<li>在build.gradle文件中配置</li>
<li>在Java和XML源码中配置</li>
</ul>

<h4 id="toc_224">Lint命令行用法介绍</h4>

<p>Usage:<br/><br/>
<code>lint [flags] &lt;project directories&gt;</code></p>

<p>Flags:</p>

<pre class="line-numbers"><code class="language-text">--help                   显示帮助命令
--help &lt;topic&gt;           有关特定主题的帮助
--list                   列出可用的问题id，然后退出
--version                输出版本信息，然后退出
--exitcode               如果发现错误，将退出代码设置为1
--show                   提供问题列表以及完整的解释
--show &lt;ids&gt;             针对指定的问题id显示完整的解释
</code></pre>

<p>启用检查:</p>

<pre class="line-numbers"><code class="language-text">--disable &lt;list&gt;         禁用类别列表或特定问题id,列表应该是以逗号分隔的问题id或类别
--enable &lt;list&gt;          启用特定问题列表,将检查所有默认问题和指定启用的问题，列表中应该是以逗号分隔的问题id或类别
--check &lt;list&gt;           只检查特定问题列表，会先禁用一切，然后重新启用给定的列表问题。列表中应该是以逗号分隔的问题id或类别。
-w, --nowarn             仅检查errors
-Wall                    检查所有的warnings，包括那些默认关闭的
-Werror                  将所有警告视为错误
--config &lt;filename&gt;      使用给定的配置文件来确定问题是启用还是禁用，如果项目包含一个lint.xml文件，那么这个配置文件作为备用
</code></pre>

<p>输出选项</p>

<pre class="line-numbers"><code class="language-text">--quiet                  不显示进展
--fullpath               错误输出使用完整路径
--showall                不截断长消息，显示完整的消息
--nolines                输出信息中不包括错误所在源文件中的行，默认情况下是显示的，但这个参数可以关闭
--html &lt;filename&gt;        创建一个HTML报告，如果文件名是个目录，lint将会为每个被扫描的项目创建一个报告
--url filepath=url       添加链接到HTML报告中，使用URL前缀取代本地路径前缀。映射可以是一个逗号分隔的路径前缀对应URL前缀的列表。
--simplehtml &lt;filename&gt;  创建一个简单的HTML报告
--xml &lt;filename&gt;         创建一个XML文件报告
</code></pre>

<p>项目选项</p>

<pre class="line-numbers"><code class="language-text">--resources &lt;dir&gt;        添加一个指定的文件夹作为项目的资源目录
--sources &lt;dir&gt;          添加一个指定的文件夹作为项目的资源目录，只有在一个单独项目中运行lint时才有效
--classpath &lt;dir&gt;        添加文件夹作为项目的工程类目录，只有在一个单独项目中运行lint时才有效
--libraries &lt;dir&gt;        添加文件夹作为项目的类库，只有在一个单独项目中运行lint时才有效
</code></pre>

<h4 id="toc_225">Lint命令行用法举例</h4>

<ul>
<li>如何查看哪些id和类别是可用的 <code>~$ lint --list</code></li>
<li>如何禁用某项检查 <code>~$ lint --disable MissingTranslation, UnusesdIds,Usability:Icons 项目路径</code></li>
<li>如何启用某项检查(某些检查默认是禁用的) <code>~$ lint --enable MissingTranslation, UnusesdIds,Usability:Icons 项目路径</code></li>
<li>如何对项目只做某项检查 <code>~$ lint --check MissingPrefix 项目路径</code></li>
<li>如何查看某个id的说明 <code>~$ lint --show id</code></li>
<li>如何以html格式输出Lint检查结果 <code>~$ lint 项目地址 --html test.html</code></li>
<li>检查本地项目 <code>~$ lint &lt;本地项目地址&gt; --html &lt;输出的html文件名.html&gt;</code></li>
<li>检查网络项目 <code>~$ lint --html /tmp/report.html --url</code></li>
</ul>

<h3 id="toc_226">执行一次代码检查</h3>

<p><strong>操作步骤</strong>: 菜单栏 | 右击文件夹/文件 -&gt; Analyze -&gt; Inspect Code -&gt; 指定检查范围 -&gt; OK</p>

<h3 id="toc_227">详解代码检查结果辅助工具</h3>

<h4 id="toc_228">重新执行代码检查(Rerun Inspection)</h4>

<p>重新执行会覆盖上一次的执行结果</p>

<h4 id="toc_229">全部展开或折叠结果(Expand All/Collapse All)</h4>

<p>展开折叠结果<br/><br/>
快捷键: command + &#39;+&#39; / &#39;-&#39;</p>

<h4 id="toc_230">在检查结果中快速上下跳转(Go Pre Problem/Go Next Problem)</h4>

<p>上下跳转的时候会同时定位到源码</p>

<h4 id="toc_231">自动定位到问题的源码(Autoscroll to Source)</h4>

<p>单击的时候自动定位到源码</p>

<h4 id="toc_232">导出代码检查结果(Export)</h4>

<p>导出代码检查结果</p>

<h4 id="toc_233">按严重程度分组排查问题(Group by Severity)</h4>

<p>按严重程度分组会更有目的性，通常我们需要重点关注Error的问题</p>

<h4 id="toc_234">按目录分组排查问题(Group by Directory)</h4>

<p>可以更直观地通过路径来排查问题</p>

<h4 id="toc_235">过滤已解决的问题(Filter resolved items)</h4>

<p>过滤掉已经解决的问题</p>

<h4 id="toc_236">快速解决问题(Apply a quickfix)</h4>

<p>只有在检查出的问题有相应的解决方案时才使用，否则是不可用的。</p>

<h3 id="toc_237">禁用和启用某项检查</h3>

<p>在检查结果中使用了Disable inspection选项时，这个检查项将会被禁用，也就是说你再执行代码检查时，被金庸的检查项就不会被检查了。</p>

<h4 id="toc_238">禁用某项检查</h4>

<ol>
<li>在检查结果中单击Android -&gt; 选中【Android Resource Validation】或具体问题</li>
<li>右击或单击左边工具栏的操作选项 -&gt; 单击【Disable inspection】，右击Android的问题分类或具体问题</li>
<li>禁用【Android Resource Validation】检查的效果。单击【Disable inspection】后并没有任何显示上的效果，再一次执行代码检查后效果就出来了</li>
<li>重新执行一次代码检查</li>
</ol>

<h4 id="toc_239">启用某项检查</h4>

<ol>
<li>在检查结果中单击设置</li>
<li>在设置中查看被禁用的检查项。被禁用的检查项会高亮显示，所以能够很容易找到哪些检查项被我们禁用了。</li>
<li>勾选要启用的检查项</li>
</ol>

<h4 id="toc_240">在偏好设置中禁用和启用某项检查</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Inspections</p>

<h3 id="toc_241">忽略检查</h3>

<ul>
<li>忽略Android资源验证: Android Resources Validation检查
<ul>
<li>和禁用操作相同，单击【Suppress for tag】: 忽略【Android Resources Validation】对这个标签的检查,在要忽略的标签上添加<code>&lt;!--suppress AndroidDomInspection --&gt;</code></li>
<li>和禁用操作相同，单击【Suppress for file】: 忽略【Android Resources Validation】对这个文件的检查,在要忽略的文件上添加<code>&lt;!--suppress AndroidDomInspection --&gt;</code></li>
<li>和禁用操作相同，单击【Suppress all for file】: 忽略这个文件的所有检查项,在要忽略的标签上添加<code>&lt;!--suppress ALL --&gt;</code></li>
</ul></li>
<li>忽略使用了过时的API: Deprecate API usage检查
<ul>
<li>单击【Suppress for statement】: 忽略【Deprecate API usage】对这个语句的检查,在要忽略的标签上添加<code>//noinspection deprecation</code></li>
<li>单击【Suppress for member】: 忽略【Deprecate API usage】对这个成员的检查,在要忽略的标签上添加<code>@SuppressWarnings(&quot;deprecation&quot;)</code></li>
<li>单击【Suppress for class】: 忽略【Deprecate API usage】对这个类的检查,在要忽略的标签上添加<code>@SuppressWarnings(&quot;ALL&quot;)</code></li>
</ul></li>
</ul>

<h3 id="toc_242">在指定范围内执行某项检查</h3>

<p><strong>操作步骤</strong>: 在检查结果中选中一个检查项 -&gt; 右击，执行【Run Inspection on...】-&gt; 选择检查范围 -&gt; 执行检查</p>

<h3 id="toc_243">解决检查出的问题</h3>

<p>选中具体问题 -&gt; 查看问题详情</p>

<ul>
<li>Name: 显示了有问题的方法名是一个公共方法</li>
<li>Location: 这个方法的位置，单击可打开这个类</li>
<li>Problem synopsis: 问题摘要，这个方法从未使用</li>
<li>Problem resolution: 问题解决方案，单击可快速解决</li>
<li>Safe delete: 安全删除</li>
<li>Comment out: 注释掉</li>
<li>Add as Entry Point: 添加为入口点</li>
<li>Suppress: 忽略检查</li>
<li>Suppress for member: 忽略成员</li>
<li>Suppress for class: 忽略类</li>
<li>Suppress all inspections for class: 忽略类的所有检查</li>
</ul>

<h3 id="toc_244">管理代码检查配置文件</h3>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Android Studio -&gt; Editor -&gt; Preferences -&gt; Inspections -&gt; Manage</p>

<h3 id="toc_245">配置代码检查规则</h3>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Android Studio -&gt; Editor -&gt; Preferences -&gt; Inspections</p>

<ul>
<li>快速搜索某个检查项</li>
<li>过滤某一类检查项(【Show Only Cleanup Inspections】过滤出所有代码清理时用到的检查项)</li>
<li>清空所有选中的检查项</li>
<li>默认禁用新的检查和恢复默认设置</li>
<li>设置检查项的严重级别
<ul>
<li>Typo: 拼写错误</li>
<li>Server Problem: 服务端问题</li>
<li>Info: 详情</li>
<li>Weak Warning: 弱警告</li>
<li>Warning: 警告</li>
<li>Error: 严重错误</li>
</ul></li>
</ul>

<h3 id="toc_246">Android类目的所有检查项</h3>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Android Studio -&gt; Editor -&gt; Preferences -&gt; Inspections -&gt; 展开Android类目</p>

<ul>
<li>Android Resources Validation: 验证Android XML中的资源引用</li>
<li>Android XML element is not allowed: 验证Android Resource文件和AndroidManifest.xml中不允许的标签</li>
<li>Constant and Resource Type Mismatches: 常量和资源类型不匹配</li>
<li>Missing JNI function: 报告项目中的native方法声明在项目中没有找到相应的JNI函数</li>
<li>Non-constant resource ID in a switch statement: 检查在Andorid Library模块中的switch语句是否使用了Resource IDs</li>
<li>onClick handler is missing in the related activity: 检查相关的activity是否声明了XML的onClick属性中指定的方法</li>
<li>Unknow Android XML attribute: 检查并高亮显示Android Resource文件和AndroidManifest.xml中未知的XML属性</li>
</ul>

<h3 id="toc_247">Android Lint类目的检查项</h3>

<h4 id="toc_248">Accessibility(可访问性)</h4>

<h5 id="toc_249">Image without contentDescription:图片没有contentDescription属性</h5>

<p>ImageView和ImageButton这样的非文本控件应该使用contentDescription属性来描述控件。这样可访问工具就可以更好的理解控件的用途，从而更加充分的分析用户界面<br/><br/>
禁用这个警告: <code>ignore=&quot;ContentDescription&quot;</code></p>

<h5 id="toc_250">Missing labelFor attribute: labelFor 属性缺失</h5>

<p>如果minSDKVersion &gt;= 17，文本字段应该标有labelFor属性</p>

<h4 id="toc_251">Correctness(正确性)</h4>

<ul>
<li>Accidental Octal: 意外的八进制;在Groovy中，以证书0开始的数字通常会被理解为一个八进制数</li>
<li>Activity registered more than once: Activity注册了不止一次</li>
<li>AdapterViews cannot have children in XML: 在XML中AdapterViews不能有子对象</li>
<li>Calling new methods on older versions: 在老版本中调用新方法</li>
<li>Custom views in libraries should use res-auto-namespace: 库中自定义的view应该使用res-auto-namespace</li>
<li>Cycle in resuorce definitions: 资源循环定义</li>
<li>Duplicate definitions of resources: 资源重复定义</li>
<li>Duplicate ids within a single layout: 在一个单独的layout中有重复id</li>
<li>Fragment not instantiatable: Fragment没有实例化</li>
<li>Invalid ID declaration: 无效的ID声明</li>
<li>Manifest Resource References: Manifest资源引用</li>
<li>Reference to an unknown id: 引用了一个未知的id</li>
<li>WebViews in wrap_content parents: WebView的父视图是wrap_content</li>
</ul>

<h4 id="toc_252">Correctness &gt; Messages(正确性 &gt; 信息)</h4>

<ul>
<li>Extra translation: 多余的翻译(如果一个字符串出现在一个特定的语言翻译文件中，但在默认的local中没有相应的字符串，那么这个字符串是未被使用的)</li>
<li>Incomplete translation: 翻译不完全</li>
<li>Invalid format string: 无效格式的字符串</li>
<li>Missing quantity translation: 数量的翻译缺失</li>
<li>String.format string doesn`t match the XML format string: String.format 字符串不匹配XML格式的字符串</li>
</ul>

<h4 id="toc_253">Internationalization(国际化)</h4>

<ul>
<li>Byte order mark inside files: 字节顺序在文件中的标记</li>
<li>Encoding used in resource files is not UTF-8: 资源文件不是UTF-8格式</li>
<li>Hardcode text: 硬编码文件</li>
</ul>

<h4 id="toc_254">Internationalization &gt; Bidirectional Text(国际化 &gt; 双向文本)</h4>

<p>Right-to-left text compatibility issues: Right-to-left文件兼容性问题</p>

<h4 id="toc_255">Performance(性能)</h4>

<ul>
<li>Obsolete layout params: 过时的布局参数</li>
<li>Using FloatMath instead of Math: 使用FloatMath替代Math</li>
<li>Nested layout weights: 嵌套布局weights</li>
<li>Unused resources: 未被使用的资源</li>
<li>Overdraw: 过度绘制</li>
</ul>

<h4 id="toc_256">Security(安全)</h4>

<ul>
<li>Hardcoded value of android: debuggable in the manifest(最好不要在manifest中设置android: debuggable属性)</li>
<li>Pakaged private key: 打包私钥(不应该在APP中打包私钥文件)</li>
</ul>

<h4 id="toc_257">Usability(可用性)</h4>

<ul>
<li>Missing menu title: 缺失菜单标题</li>
<li>URL not supported by app for Google App Indexing:URl 不支持Google的App索引要确保应用支持URL，以便从Google搜索中获得安装和流量</li>
</ul>

<h4 id="toc_258">Usability &gt; Icons(可用性 &gt; 图标)</h4>

<ul>
<li>Clashing PNG and 9-PNG files: PNG和9-PNG文件冲突</li>
<li>Duplicated icons under different names: 在不同的名字下有重复的图标</li>
<li>Missing application icon: 应用程序图标缺失</li>
<li>Missing density folder: 密度文件夹缺失</li>
</ul>

<h4 id="toc_259">Usability &gt; Typography(可用性 &gt; 字体)</h4>

<ul>
<li>Ellipsis string can be replaced with ellipsis character: 省略号字符可以用省略号代替</li>
<li>Fraction string can be replaced with fraction character: 分数字符串可以用分数字符代替</li>
<li>Hyphen can be replaced with dash: 连字符可以用破折号代替</li>
</ul>

<h3 id="toc_260">在lint.xml文件中配置Lint检查</h3>

<p>在Android Studio的偏好设置中可以修改Lint的配置，lint.xml文件会被自动添加到Android项目中</p>

<pre class="line-numbers"><code class="language-text">&lt;?xml version&quot;UTF-8&quot;?&gt;
&lt;!-- Ignore the ObsoleteLayoutParam issue in the specified files --&gt;
&lt;lint&gt;
    &lt;issue id=&quot;ObsoleteLayoutParam&quot;&gt;
        &lt;ignore path=&quot;res/layout/activation.xml&quot; /&gt;
        &lt;ignore path=&quot;res/layout-xlarge/activation.xml&quot; /&gt;
    &lt;/issue&gt;

    &lt;!-- Ignore the UselessLeaf issue in the specified file --&gt;
    &lt;issue id=&quot;UselessLeaf&quot;&gt;
        &lt;ignore path=&quot;res/layout/main.xml&quot; /&gt;
    &lt;/issue&gt;

    &lt;!-- Change the severity of hardcoded strings to &quot;error&quot; --&gt;
    &lt;issue id&quot;error&quot; /&gt;
&lt;/lint&gt;
</code></pre>

<h3 id="toc_261">在Gradle中配置Lint检查</h3>

<p>在build.gradle文件中添加lintOptions的配置</p>

<pre class="line-numbers"><code class="language-text">android {
    lintOptions {
        //出现error时是否停止进程
        abortOnError true
        //关闭检查项，参数是issue id
        disable &#39;TypographyFractions&#39;, &#39;TypographyQuotes&#39;
        
        //开启检查项，参数是issue id
        enable &#39;RtlHardcoded&#39;, &#39;RtlCompat&#39;, &#39;RtlEnabled&#39;
        //仅检查指定的检查项，参数是issue id
        check &#39;NewApi&#39;, &#39;InlinedApi&#39;
        //设置检查项的严重等级为可忽略，参数是issue id
        ignore &#39;NewApi&#39;, &#39;InlinedApi&#39;
    }
}
</code></pre>

<h3 id="toc_262">使用Gradle执行Lint检查</h3>

<h4 id="toc_263">命令行执行Lint检查</h4>

<p><code>./gradlew lint</code><br/><br/>
<code>./gradlew lintRelease</code><br/>
<code>./gradlew lintDebug</code></p>

<h4 id="toc_264">Gradle工具窗口执行Lint检查</h4>

<p>打开Gradle工具窗口中指定模块的任务目录，在verification下面找到对应的lint任务</p>

<ul>
<li>双击lint</li>
<li>双击lintDebug</li>
<li>双击lintRelease</li>
</ul>

<h3 id="toc_265">在Java和XML源码中配置Lint检查</h3>

<h4 id="toc_266">在Java源码中配置Lint配置</h4>

<ul>
<li>在Java源码中使用注解@SuppressLint(&quot;issue id&quot;)来禁用检查</li>
<li>禁用多项检查的参数为一个字符串数组，如@SuppressLint({&quot;issue id&quot;},{&quot;issue id&quot;})</li>
<li>禁用所有检查的参数为all,如@SuppressLint(&quot;all&quot;)</li>
</ul>

<h4 id="toc_267">在XML源码中配置Lint检查</h4>

<p>在XML源码中使用属性tools:ignore = &quot;issue id&quot;来禁用检查</p>

<ul>
<li>禁用多项检查: tools:ignore = &quot;issue id, issue id&quot;</li>
<li>禁用所有检查: tools:ignore = &quot;all&quot;</li>
</ul>

<h3 id="toc_268">代码清理</h3>

<p>通过代码扫描检查出好多问题，Android Studio恰好提供了Code Cleanup(代码清理)这个功能。</p>

<h4 id="toc_269">清理代码</h4>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Analyze -&gt; Code cleanup</p>

<h4 id="toc_270">配置代码清理规则</h4>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Analyze -&gt; Code cleanup -&gt; 单击Inspection profile右边的...可以打开代码清理检查配置界面</p>

<h3 id="toc_271">通过名字来指定代码检查项</h3>

<p>菜单栏或右击文件 -&gt; Analyze -&gt; Run Inspection by name -&gt; 弹出规则输入框<br/>
快捷键: option + command + shift + I</p>

<h3 id="toc_272">配置当前文件自动检查的规则</h3>

<p>Android Studio会对当前文件自动进行代码检查，检查出问题后相关的代码会被高亮显示。</p>

<p>菜单栏或右击文件 -&gt; Analyze -&gt; Configure Current File Analysis<br/>
快捷键: option + command + shift + H</p>

<h3 id="toc_273">导入并查看离线检查结果</h3>

<p>Android Studio还支持代码检查结果的导入</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Analyze -&gt; View Offline Inspection Results</p>

<h3 id="toc_274">自动添加是否可为空注解</h3>

<ul>
<li>@NotNull 变量或参数不能为null<br/></li>
<li>@Nullable 变量或参数可以为null</li>
</ul>

<h3 id="toc_275">分析依赖</h3>

<p>菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Dependences<br/>
快捷键: command + shift + A</p>

<h4 id="toc_276">结果分析</h4>

<ul>
<li>选中被分析的类文件 -&gt; 在右边会显示这个类文件所依赖的文件，包括项目中的文件和外部文件</li>
<li>单击右边依赖的文件会在下面显示这个文件在左边类文件中的用法</li>
<li>查看依赖文件的用法，更好地理解文件结构</li>
</ul>

<h3 id="toc_277">分析反向依赖</h3>

<p>反向依赖就是分析出当前文件被哪些文件所依赖</p>

<p><strong>操作步骤</strong>: 菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Backward Dependences -&gt; 然后弹出分析范围对话框</p>

<h3 id="toc_278">分析模块依赖</h3>

<p>模块依赖分析显示指定范围内存在的所有模块和它们之间的关系</p>

<p><strong>操作步骤</strong>: 菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Module Dependences -&gt; 然后弹出指定分析范围对话框</p>

<h3 id="toc_279">分析循环依赖</h3>

<p>循环依赖就是循环引用，是两个或多个类相互持有对方</p>

<p><strong>操作步骤</strong>: 菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Cyclic Dependences -&gt; 然后弹出指定分析范围对话框</p>

<h3 id="toc_280">分析数据流</h3>

<p><strong>操作步骤</strong>: 菜单栏或右击文件 -&gt; Analyze -&gt; Analyze Data Flow to here -&gt; 然后弹出分析范围选择对话框</p>

<h3 id="toc_281">分析堆栈信息</h3>

<p>向更加方便和专注地分析堆栈信息的时候可以使用此功能</p>

<p>菜单栏: Analyze -&gt; Analyze StackTrace<br/><br/>
快捷键: command + shift + A</p>

<h2 id="toc_282">重构</h2>

<p>重构是指在不改变外部行为的条件下，对现有的代码进行改善，以增加可读性，使设计和逻辑更加清晰。</p>

<h3 id="toc_283">重命名</h3>

<p>对类、方法、字段、变量、包或其他文件进行重命名</p>

<p>菜单栏: Refactor -&gt; Rename<br/><br/>
快捷键: fn + shift + F6</p>

<h3 id="toc_284">更改方法签名</h3>

<p>方法签名由方法名称和一个参数列表组成。更改方法签名可以改变方法的名称、改变函数的可访问性，对参数进行添加、删除、重命名和重新排序。</p>

<p>菜单栏: Refactor -&gt; Change Signature<br/><br/>
快捷键: fn + command + F6</p>

<h3 id="toc_285">迁移变量类型</h3>

<p>迁移类型(Type Migration) 就是改变变量的类型</p>

<p>菜单栏: Refactor -&gt; Type Migration<br/><br/>
快捷键: fn + shift + command + F6</p>

<h3 id="toc_286">转成静态方法</h3>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Make Static</p>

<h3 id="toc_287">静态方法转为实例方法</h3>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Convert to Instance Method</p>

<h3 id="toc_288">提取变量</h3>

<p>提取变量重构是将一个表达式提取为一个变量，并使用变量替换原来的表达式</p>

<p>菜单栏: Refactor -&gt; Extract -&gt; Variable<br/><br/>
快捷键: option + command + V</p>

<h3 id="toc_289">提取常量</h3>

<p>提取常量是从临时变量快速提取出静态常量</p>

<p>菜单栏: Refactor -&gt; Extract -&gt; Constant...<br/><br/>
快捷键: option + command + C</p>

<h3 id="toc_290">提取字段</h3>

<p>提取字段重构是将选中的表达式赋值给一个新声明的字段，原来的表达式使用这个新的字段来代替。</p>

<p>菜单栏: Refactor -&gt; Extract -&gt; Field...<br/><br/>
快捷键: option + command + F</p>

<h3 id="toc_291">提取参数</h3>

<p>提取参数重构是将A中的值提取为方法A的新参数，调用方法A的地方传入参数的值，这个值为之前提取的参数值</p>

<p>菜单栏: Refactor -&gt; Extract -&gt; Parameter...<br/><br/>
快捷键: option + command + P</p>

<h3 id="toc_292">提取函数式参数</h3>

<p>菜单栏: Refactor -&gt; Extract -&gt; Functional Parameter...<br/><br/>
快捷键: option + shift + command + P</p>

<h3 id="toc_293">提取参数对象</h3>

<p>菜单栏: Refactor -&gt; Extract -&gt; Parameter Object  </p>

<h3 id="toc_294">提取方法</h3>

<p>在重构代码时我们经常把复杂方法中的一段代码提取出来作为一个单独的方法使用，这种重构方法叫Extra Method</p>

<p>菜单栏: Refactor -&gt; Extract -&gt; Method<br/><br/>
快捷键: option + command + M</p>

<h3 id="toc_295">提取方法对象</h3>

<p>可以把一段代码提取为方法对象使用</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Extrat -&gt; Method Object...</p>

<h3 id="toc_296">提取委托</h3>

<p>委托是有两个对象参与同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Extrat -&gt; Delegate...</p>

<h3 id="toc_297">提取接口</h3>

<p>提取接口重构是从一个已存在的类中提取接口，可以从某个类中选择方法，把选中的方法提取到一个单独的接口中。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Extrat -&gt; Interface...</p>

<h3 id="toc_298">提取父类</h3>

<p>菜单栏 -&gt; Refector -&gt; Extract -&gt; Superclass...</p>

<h3 id="toc_299">内联方法</h3>

<p>当一个方法的本体与方法名同样清除易懂时，就没有必要使用单独的方法了，直接把方法换成方法体即可，也就是使用内联方法进行重构。</p>

<p>菜单栏: Refactor -&gt; Inline<br/><br/>
快捷键: option + command + N</p>

<h3 id="toc_300">内联临时变量</h3>

<p>当一个临时变量只被简单地引用一次，而且会影响其他重构时，就要使用内联变量进行重构。</p>

<p>菜单栏: Refactor -&gt; Inline<br/><br/>
快捷键: option + command + N</p>

<h3 id="toc_301">查找并替换重复代码</h3>

<p>查找并替换重复代码重构时查找和赵中方法或常量字段重复或类似的代码，并通过调用此方法或常量来替换他们。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; File and Replace Code Duplicates...</p>

<h3 id="toc_302">反转布尔值</h3>

<p>反转布尔值重构是把一个Boolean方法或变量改变为相反的意义，也就是原来是true的变为false，原来是false变为true</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Invert Boolean</p>

<h3 id="toc_303">把成员拉到父类</h3>

<p>把成员拉到父类重构是把当前类的方法和属性移动到它的父类中去。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Pull Members Up...</p>

<h3 id="toc_304">把成员推到子类</h3>

<p>把成员推到子类重构是把父类的方法和属性移动到所有子类中，弗雷德方法可以选择性地保留抽象方法。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Push Members Down...</p>

<h3 id="toc_305">尽可能使用接口</h3>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Use Interface Where Possible...</p>

<h3 id="toc_306">使用委托替换继承</h3>

<p>使用委托替换继承重构是移除当前子类继承的父类，但同时又能够保留并使用父类中的一些功能。</p>

<h4 id="toc_307">什么时候用委托替换继承</h4>

<p>当某个子类只使用了父类的一部分功能时，或者根本就不需要继承来的数据时，就要考虑用委托替换继承。</p>

<h4 id="toc_308">如何使用委托替换继承</h4>

<p>Android Studio 会先在子类中创建一个私有的内部类，用来继承超类或接口。然后在子类中新建一个字段来实例化这个内部类，再委托子类中的方法来调用父类的方法。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Replace Inheritance with Delegation...</p>

<h3 id="toc_309">移除中间人</h3>

<p>移除中间人重构是让你不使用委托方法而直接调用受委托的类</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Remove Middleman...</p>

<h3 id="toc_310">包装方法返回值</h3>

<p>包装方法返回值重构是使用一个新建的包装类来替换一个方法的返回值，这个类也可以是已存在的类。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Wrap Return Value...</p>

<h3 id="toc_311">将匿名类转成内部类</h3>

<p>匿名类转成内部类重构可以把一个匿名类转成内部类，这样一来这个类的其他部分就可以共享此类。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Convert Anonymous to Inner...</p>

<h3 id="toc_312">封装字段</h3>

<p>封装字段重构可以隐藏数据，然后创建访问器来访问。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Encapsulate Field...</p>

<h3 id="toc_313">使用查询替换临时变量</h3>

<p>如果一个临时变量保存了一个表达式，使用查询替换临时变量重构就是将这个表达式提炼到一个独立的方法中，并将这个临时变量的所有引用点替换为新的方法的调用。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Replace Temp with Query...</p>

<h3 id="toc_314">使用工厂方法替换构造方法</h3>

<p>使用工厂方法替换构造方法重构是使用一个静态方法返回一个实例化的类来替换原来的构造方法。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Replace Constructor with Factory Method ...</p>

<h3 id="toc_315">使用构造器替换构造方法</h3>

<p>当创建一个对象需要传入多个参数的时候我们通常会根据参数的数量写多个不同的构造方法，但是这种方法不够灵活，可读性也不高。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Replace Constructor with Builder...</p>

<h3 id="toc_316">泛型化</h3>

<p>泛型化重构用来将那些没有使用泛型的代码转化为泛型可识别的代码</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Gentrify...</p>

<p>配置对话框</p>

<ul>
<li>Drop obsolete casts: 删除过时的转换</li>
<li>Leave Object-parameterized types raw: 保留对象参数化类型</li>
<li>Preserve raw arrays: 保留原始队列</li>
<li>Perform exhaustive search: 执行穷举搜索</li>
<li>Generify Objects: 泛型化对象</li>
<li>Produce wildcard types: 产生通配符类型</li>
</ul>

<h3 id="toc_317">国际化</h3>

<p>国际化重构就是从源代码中提取字符串，并将它们作为属性写入属性文件中，再通过生成的表达式来读取Resource Bundle中的属性来获得多语言的字符串。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Refactor -&gt; Internationalize...</p>

<h2 id="toc_318">构建</h2>

<p>Android Studio默认使用Gradle来进行项目构建，Gradle是一个自动化构建工具，采用Groovy的Domain Specific Language来描述和控制构建逻辑。</p>

<h3 id="toc_319">认识Gradle</h3>

<p>Gradle是一个自动化构建工具。<br/><br/>
特点：</p>

<ul>
<li>Gradle支持多工程构建和局部构建</li>
<li>Gradle支持远程或本地依赖管理：支持从远程maven仓库，nexus私服，ivy仓库以及本地仓库获取依赖</li>
<li>Gradle与Ant、Maven兼容</li>
<li>Gradle可轻松迁移：Gradle适用于任何结构的工程，可以在同一个开发平台平行构建原工程和Gradle工程</li>
<li>Gradle使用灵活：Gradle的整体设计是以作为一种语言为向导的，而非成为一个严格死板的框架</li>
<li>Gradle免费开源</li>
<li>Gradle跟IDE集成得非常好</li>
<li>Gradle可以更容易地集成到自动化构建系统</li>
</ul>

<h4 id="toc_320">Gradle的Project、Task、和Plugin</h4>

<p><strong>项目</strong>是指构建产物或部署的产物。每个项目包含一个或多个任务。<br/>
<strong>任务</strong>是指不可分的最小工作单元，代表一个逻辑上较为独立的执行过程。</p>

<h4 id="toc_321">Gradle中依赖的仓库</h4>

<p>在build.gradle中添加仓库的声明，从Maven仓库中获取依赖</p>

<pre class="line-numbers"><code class="language-text">repositories {
    #1.从指定的远程Maven仓库中获取依赖
    maven {
        url &quot;http://maven.helloword.net/repo&quot;
    }
    
    #2.从指定的本地Maven仓库中获取依赖
    maven {
        url &quot;file:///Users/bixiaopeng/mvn&quot;
    }
    
    #3.从中央Maven仓库中获取依赖
    mavenCenter()
    
    #4.从新的中央远程仓库中获取依赖
    jcenter()
    
    #5.从本地仓库中获取依赖
    mavenLocal()
    
    #6.需要认证的库
    maven {
        credentials {
            username &#39;user&#39;
            password &#39;password&#39;
        }
        url &quot;http://repo.helloword.com/maven2&quot;
    }
}
</code></pre>

<h4 id="toc_322">Maven仓库的别名</h4>

<ul>
<li>mavenCentral(): 表示从Maven中央仓库中获取依赖</li>
<li>jcenter(): 一个新的远程中央仓库，兼容Maven中央仓库，而且性能更优。Gradle默认使用jcenter作为仓库。</li>
<li>mavenLocal(): 表示从本地Maven仓库中获取依赖</li>
</ul>

<h4 id="toc_323">从平级目录仓库中获取依赖</h4>

<p>从本地目录中获取依赖，在build.gradle中添加</p>

<pre class="line-numbers"><code class="language-text">repositories {
    //从当前项目的平级目录lib中获取依赖
    flatDir(dir: &#39;lib&#39;,name: &#39;libs directory&#39;)
    //从当前项目的平级目录libA 和 libB中获取依赖
    flatDir {
        dirs &#39;libA&#39;,&#39;libB&#39;
        name = &#39;All dependency directories&#39;
    }
}
</code></pre>

<h3 id="toc_324">配置Gradle环境</h3>

<ul>
<li>编辑.bash_profile <code>vim ~/.bash_profile</code></li>
<li>配置环境变量 <code>export GRADLE_HOME=grale路径 export PATH = $PATH: $GRADLE_HOME/bin</code></li>
<li>使配置立即生效 <code>source ~/.bash_profile</code></li>
<li>查看配置是否生效 <code>gradle -v</code></li>
</ul>

<h3 id="toc_325">Gradle Wrapper</h3>

<h4 id="toc_326">认识Gradle Wrapper</h4>

<p>Gradle Wrapper可以理解为Gradle的一层封装，使用它可以在没有安装Gradle的系统上使用Gradle来构建项目。</p>

<p>在gradle/wrapper目录下有两个文件:gradle-wrapper.jar和gradle-wrapper.properties</p>

<h3 id="toc_327">查看和执行Gradle任务</h3>

<h4 id="toc_328">查看当前项目支持的Gradle任务</h4>

<p>使用./gradlew task 来查看单签项目支持哪些Gradle任务</p>

<p>想查看所有任务和更多详情 <code>gradlew tasks -all</code></p>

<p>想查看一个任务的更多详情 <code>gradlew help --task &lt;task&gt;</code></p>

<h4 id="toc_329">执行Gradle任务</h4>

<p>执行命令: &quot;gradle + 任务名称&quot; 或者 &quot;./gradlew + 任务名称&quot;</p>

<h4 id="toc_330">常用Gradle任务</h4>

<ul>
<li>查看gradle版本 <code>./gradlew -v</code></li>
<li>编译并打出Debug版本的包 <code>./gradlew assembleDebug</code></li>
<li>编译并打开Release版本的包 <code>./gradlew assembleRelease</code></li>
<li>执行检查并编译打包,打出所有Release和Debug的包 <code>./gradlew build</code></li>
<li>删除build目录，会把app下面的build目录删掉 <code>./gradlew clean</code></li>
<li>编译打包并安装Debug版本的包: <code>./gradlew installDebug</code></li>
<li>卸载Debug版本的包: <code>./gradlew uninstallDebug</code></li>
<li>使用-info查看任务详情: <code>./gradlew uninstallDebug -info</code></li>
</ul>

<h4 id="toc_331">Gradle工具窗口</h4>

<p>Gradle工具窗口列出了当前项目和模块中支持的所有Gradle任务和运行配置，以便我们快速操作。</p>

<h5 id="toc_332">Tasks</h5>

<p>Tasks列表里的任务跟我们执行./gradlew task得到的任务列表是一样的。把光标放在某个任务上面会显示任务的描述信息。双击任务即可执行。</p>

<h5 id="toc_333">Run Configurations</h5>

<p>Run Configurations列表中列出了项目中执行过的任务配置，这些配置都是执行任务时自动生成的。想再次执行的时候可以在配置列表中直接选择。</p>

<h3 id="toc_334">构建项目和模块</h3>

<h4 id="toc_335">编译项目</h4>

<p>当我们只想对修改过的文件进行编译时就会使用Make进行编译，可以指定对项目或者模块进行编译</p>

<p>菜单栏: Build -&gt; Make Project<br/><br/>
快捷键: command + F9</p>

<h4 id="toc_336">编译模块</h4>

<p>前提条件: 选中某个模块<br/>
操作步骤: 菜单栏 -&gt; Build -&gt; Make Module&#39;模块名&#39;</p>

<h4 id="toc_337">设置自动编译项目</h4>

<p>操作步骤: Android Studio -&gt; Preferences... -&gt; 搜索Compiler -&gt; 勾选Make project automatically</p>

<h4 id="toc_338">重新构建项目</h4>

<p>操作步骤: 菜单栏 -&gt; Build -&gt; Rebuild Project(重新构建项目)</p>

<h4 id="toc_339">Make Project跟Rebuild Project的区别</h4>

<p>Make Project是对新产生变化的文件进行一次编译，已经编译过的文件就不用重新编译，Rebuild Project是对整个项目重新编译，用时更久。</p>

<h4 id="toc_340">清理项目</h4>

<p>清理项目会清空output目录下的文件，并重新编译项目<br/><br/>
操作步骤: 菜单栏 -&gt; Build -&gt; Clean Project</p>

<h3 id="toc_341">Gradle Script</h3>

<p>Gradle Scripts列表: </p>

<ul>
<li>build.gradle: 项目构建配置文件</li>
<li>build.gradle: 模块构建配置文件</li>
<li>gradle-wrapper.properties: gradle wrapper配置文件</li>
<li>proguard-rules.pro: 混淆规则配置文件</li>
<li>graddle.properties: gradle配置文件</li>
<li>setting.gradle: 项目全局配置文件</li>
<li>local.properties: SDK、NDK配置文件</li>
</ul>

<h4 id="toc_342">Gradlew配置文件gradle-wrapper.properties</h4>

<p>这个文件一般是不动的，除非想手动指定Gradle的版本，可以修改distributionUrl。也可以在Project Structure -&gt; Project中设置Gradle version</p>

<h4 id="toc_343">项目全局配置文件setting.gradle</h4>

<p>主要声明一些需要加入构建的模块</p>

<h4 id="toc_344">本地属性配置文件local.properties</h4>

<p>在Project Structure -&gt; SDK Location 中设置SDK和NDK的路径，修改后会同步到local.properties文件中。</p>

<h4 id="toc_345">Gradle配置文件gradle.properties</h4>

<p>gradle.properties是Gradle的配置文件，build.gradle通过独缺这个文件配置的参数来进行相应的构建。</p>

<h4 id="toc_346">代码混淆规则配置文件proguard-rules.pro</h4>

<p>如果想在打包的时候进行代码混淆，就需要在proguard-rules.pro中配置代码混淆规则。</p>

<h4 id="toc_347">项目构建配置文件build.gradle</h4>

<pre class="line-numbers"><code class="language-text">//项目构建文件，可以到各子项目/模块添加常用的配置选项
buildscript {
    //Android插件从这个仓库中下载
    repositories {
        jcenter() //依赖仓库源的别名，兼容maven的远程中央仓库
    }
    
    //依赖
    dependencies {
        //android gradle插件
        classpath &#39;com.android.tools.build:gradle:2.2.0-alpha1&#39;
        
        //提示
        //请不要在此处添加应用程序依赖；他们应该在单个Module build.gradle文件中添加
        //这里添加的应该只是Project的依赖
    }
    
    //此处配置Project中默认的仓库员，包括每个module的依赖
    //这样每个module就不用单独配置仓库了
    allprojects {
        repositories {
            jecnter()
        }
    }
    
    //打包前执行clean任务
    //任务类型是Delete
    //clean任务就是删除项目根目录下的build目录
    task clean(type: Delete) {
        delete rootProject.buildDir
    }
}
</code></pre>

<h4 id="toc_348">模块构建配置文件build.gradle</h4>

<p>Module: build.gradle用来配置模块的构建任务</p>

<h3 id="toc_349">在项目结构中配置模块构建</h3>

<p>Project Structure用来配置项目和模块的各种构建参数和属性</p>

<h4 id="toc_350">配置应用程序属性</h4>

<ul>
<li>Compile Sdk Version: 指定Android的编译版本</li>
<li>Build Tools Version: 指定构建工具的版本</li>
<li>Library Repository: 指定依赖的仓库源</li>
<li>Ignore Assets Pattern: 指定构建打包时要忽略的文件</li>
<li>Incremental Dex: 增量Dex打包，开启此功能可以提升编译打包的速度</li>
<li>Source Compatibility: 指定资源版本</li>
<li>Target Compatibility: 指定目标版本</li>
</ul>

<h4 id="toc_351">配置应用程序签名</h4>

<p>在这里配置了签名，相应地在module app的build.gradle文件中会自动添加下面的配置</p>

<pre class="line-numbers"><code class="language-text">//签名配置
signingConfigs {
    MySigning {
        keyAlias &#39;myandroid&#39;
        keyPassword &#39;123456&#39;
        storeFile file(&#39;钥匙库路径&#39;)
        storePassword &#39;123456&#39;
    }
}
</code></pre>

<h4 id="toc_352">配置应用程序特性</h4>

<p>多渠道打包要在Flavors配置相应的属性</p>

<ul>
<li>Name: Flavor的名字，如我们常用的渠道xiaomi,baidu</li>
<li>Min Sdk Version: 向下兼容的最小SDK版本</li>
<li>Application Id: 应用程序的包名</li>
<li>Proguard File: 指定混淆文件路径，如果不指定会使用默认的</li>
<li>Signing Config: 指定签名文件。签名的文件在Signing中设置</li>
<li>Target Sdk Version: 目标SDK版本</li>
<li>Test Instrumentation Runner: 指定Test Runner</li>
<li>Test Application Id: 测试应用的ID</li>
<li>Version Code: 应用程序的版本号，用于升级</li>
<li>Version Name: 应用程序的版本名称</li>
<li>Version Name Suffix: 应用程序版本名称的后缀</li>
</ul>

<h4 id="toc_353">配置应用程序的构建类型</h4>

<p>构建类型Build Types非常重要，默认两个构建版本: debug 和 release</p>

<ul>
<li>Name: 构建类型名称</li>
<li>Debuggable: 是否可以调试</li>
<li>Jni Debuggable: Jni是否可以调试</li>
<li>Proguard File: 指定混淆文件路径，如果不指定会使用默认的</li>
<li>Signing Config: 指定签名。签名的文件在Signing中设置，若为空则不签名，打出来的包也是未签过名的</li>
<li>Renderscript Debuggable: 是否使用渲染脚本</li>
<li>Renderscript Optim Level: Rendescript版本</li>
<li>Minify Enabled: 是否混淆</li>
<li>Target Sdk Version: 目标SDK版本</li>
<li>Pseudo Locales Enabled: 是否支持本地化整理</li>
<li>Application Id Suffix: 应用程序Id后缀</li>
<li>Version Name Suffix: 应用程序版本名称的后缀</li>
<li>Zip Align Enabled: 是否支持Zip Align</li>
</ul>

<p>Project Structure没有的配置，但buildTypes支持的属性如下</p>

<ul>
<li><code>buildConfigField &quot;boolean&quot;,&quot;LOG_DEBUG&quot;,&quot;true&quot;</code>   显示Log</li>
<li><code>shrinkResources true</code>    移除无用的resource文件，minifyEnabled必须为true</li>
</ul>

<h3 id="toc_354">签名和打包</h3>

<p>Android系统要求应用程序必须经过签名才能够安装到系统中，签名就是在应用程序特定的字段中些人标识信息，Android系统通过签名判断你是否是这个应用程序的开发者。</p>

<p>签名相同的应用程序: </p>

<ul>
<li>能够正常地覆盖安装旧版本</li>
<li>能够允许代码和数据共享</li>
</ul>

<p><strong>默认签名证书</strong><br/><br/>
Android SDK工具会自动生成一个调试用的签名证书debug.keystore</p>

<p>当我们打debug包时，默认使用debug.keystore进行签名。debug包可以在真机和模拟器上运行和调试，但不能发布到应用市场。对外发布时要使用统一的签名。</p>

<h4 id="toc_355">自动打包和签名</h4>

<ul>
<li>配置签名证书。打开Project Structure窗口
<ul>
<li>选择app模块</li>
<li>单击Signing标签</li>
<li>新增一个签名证书的配置</li>
<li>选择证书，填入相关信息</li>
</ul></li>
<li>配置构建类型
<ul>
<li>单击Build Types标签</li>
<li>选择release</li>
<li>Signing Config这一项选择刚才我们配置的签名</li>
</ul></li>
<li>自动打包和签名
<ul>
<li>./gradlew assembleRelease</li>
</ul></li>
</ul>

<h4 id="toc_356">混淆打包</h4>

<p>为了防止反编译，增加反编译成本，使用ProGuard进行混淆，通过删除从未使用的代码和使用晦涩名字来重命名类、字段和方法，从而对代码进行压缩、优化和混淆。<br/><br/>
在build.gradle中打开混淆开关，minifyEnabled设置为true</p>

<h4 id="toc_357">多渠道打包</h4>

<p>国内Android应用程序有360、小米、豌豆荚、百度等非常多的下载渠道，想统计每个渠道的下载量和活跃度，就需要使用统计平台。<br/>
以友盟统计为例，配置渠道信息并执行自动化打包</p>

<h5 id="toc_358">在AndroidMainfest.xml配置可动态替换的渠道参数</h5>

<pre class="line-numbers"><code class="language-text">&lt;meta-data
    android: name = &quot;UMENG_CHANNEL&quot;
    android: value = &quot;${CHANNEL_ID}&quot;
</code></pre>

<h5 id="toc_359">在build.gradle中配置渠道信息和自动替换脚本</h5>

<pre class="line-numbers"><code class="language-text">//多渠道打包
productFlavors {
    xiaomi()            //渠道名为xiaomi
    baidu()
    wandoujia()
    
    //自动替换AndroidManifest.xml中的渠道号
    productFlavors.all { flavor -&gt; 
        flavor.manifestPlaceHolders = [CHANNEL_ID: name]
    }
}
</code></pre>

<h5 id="toc_360">打包后自动修改apk的名字</h5>

<pre class="line-numbers"><code class="language-text">//打包后自动修改apk的名字
//release包的命名格式为: 产品名_版本号_渠道号.apk
//debug包的命名格式为: 产品名_版本号_渠道号_Debug_打包时间.apk
applicationVariants.all { variant -&gt;
    variant.outputs.each { output -&gt;
        def outputFile = output.outputFile
        if (null != outpoutFile &amp;&amp; outputFile.name.endsWith(&#39;.apk&#39;)) {
            File outputDir = new File(outputFile.parent);
            def baseName = PRODUCT_NAME + &quot;${defaultConfig.versionName}&quot; + &quot;_&quot; + variant.productFlavors[0].name
            def newApkName
            if (variant.buildType.name.equals(&#39;release&#39;)) {
                newApkName = baseName + &#39;.apk&#39;
            } else if (variant.buildType.name.equals(&#39;debug&#39;)) {
                newApkName = baseName + &quot;_Debug_${packageTime()}.apk&quot;
            }
            output.outputFile = new File(outputDir,newApkName)
        }
    }
}
</code></pre>

<h5 id="toc_361">自动化打包</h5>

<p>方法一: 命令行<br/><br/>
<code>./gradlew assembleRelease</code></p>

<p>方法二: Gradle工具窗口<br/><br/>
方法三: 菜单栏 -&gt; Build -&gt; Generate Signed APK -&gt; 一步步下去 -&gt; 在Flavors中全选 -&gt; Finish</p>

<h5 id="toc_362">查看渠道号是否被正确替换</h5>

<p>单击apk后，Android Studio会自动解析apk，这样就可以在Android Studio中直接查看apk的信息了。</p>

<h2 id="toc_363">运行和调试</h2>

<h3 id="toc_364">运行和配置调试</h3>

<p>菜单栏: Run -&gt; Edit Configurations...<br/><br/>
快捷键: control + alt + R</p>

<h4 id="toc_365">Android应用程序配置</h4>

<h5 id="toc_366">Name</h5>

<p>在这里输入配置的名字，会在工具栏运行应用程序配置的下拉列表中看到</p>

<h5 id="toc_367">General</h5>

<p>在这里配置安装、启动、部署应用程序选项</p>

<p>1、 Module: 列表中列出了当前项目中的所有模块，可以指定相应的模块来运行<br/><br/>
2、 Installation Options: 安装选项  </p>

<ul>
<li>Deploy: 下拉列表中列出了应用程序运行时的部署模式
<ul>
<li>Default APK: 部署默认的APK，运行时会先打包安装，再启动APK</li>
<li>Custom Artifact: 部署自定义的APK，会根据所选择的模块来选择相应的配置</li>
<li>Nothing: 不做任何部署，运行时直接启动应用，如果应用已经安装了会直接启动，没有安装就会报错。</li>
</ul></li>
<li>Install Flags: 给adb shell pm install 添加运行参数</li>
<li>Launch Options: 启动选项
<ul>
<li>Default Activity: 启动默认Activity，运行时会启动默认的MainActivity，如果没有就会报错。</li>
<li>Specified Activity: 指定启动的Activity</li>
<li>Nothing: 运行时不会启动任何Activity</li>
<li>URL: 在这里可以指定启动的scheme</li>
<li>Launch Flags: 给sdb shell am 添加运行参数，参数添加在命令的最后面</li>
</ul></li>
<li>Deployment Target Options: 部署目标选项
<ul>
<li>Target
<ul>
<li>Show Device CHooser Dialog: 每次运行弹出选择设备对话框</li>
<li>USB Device: 使用USB连接的设备</li>
<li>Emulator: 使用模拟器</li>
</ul></li>
<li>Use same selection for future launches: 以后每次运行都是用同样的选择。</li>
</ul></li>
</ul>

<h5 id="toc_368">Miscellaneous</h5>

<p>在这里配置日志和安装选项</p>

<p>1、Logcat  </p>

<ul>
<li>Show logcat automatically: 运行时自动显示logcat日志</li>
<li>Clear log before launch: 启动前清空日志</li>
</ul>

<p>2、Installation Options  </p>

<ul>
<li>Skip installation if APK has not changed: 如果代码没有变更，运行时跳过安装</li>
<li>Force stop running application before launching activity: 启动Activity前强制关闭运行的应用程序。</li>
</ul>

<h5 id="toc_369">Debugger</h5>

<p>在这里配置调试类型</p>

<h5 id="toc_370">Profiling</h5>

<p>在这里配置图形跟踪选项</p>

<p>Disable precompiled shaders and programs: 禁用预编译着色器和程序</p>

<h5 id="toc_371">Before launch</h5>

<p>在这里可以配置运行之前需要执行的任务，默认会执行Make</p>

<h6 id="toc_372">添加任务</h6>

<table>
<thead>
<tr>
<th style="text-align: left">任务</th>
<th style="text-align: left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Run External tool</td>
<td style="text-align: left">运行外部工具，如果有的话可以直接选择，如果没有可以去新建</td>
</tr>
<tr>
<td style="text-align: left">Make</td>
<td style="text-align: left">编译选择的模块</td>
</tr>
<tr>
<td style="text-align: left">Make Project</td>
<td style="text-align: left">编译项目</td>
</tr>
<tr>
<td style="text-align: left">Make,no error check</td>
<td style="text-align: left">编译选择的模块，但不进行错误校验</td>
</tr>
<tr>
<td style="text-align: left">Build Artifacts</td>
<td style="text-align: left">构建构件，如果有的话可以选择对应的构件</td>
</tr>
<tr>
<td style="text-align: left">Run Gradle task</td>
<td style="text-align: left">运行Gradle任务</td>
</tr>
<tr>
<td style="text-align: left">Gradle-aware Make</td>
<td style="text-align: left">执行Gradlew任务</td>
</tr>
</tbody>
</table>

<h3 id="toc_373">运行应用程序</h3>

<h4 id="toc_374">运行应用程序</h4>

<p>菜单栏: Run -&gt; Run...<br/><br/>
快捷键: control + alt + R</p>

<h4 id="toc_375">清理后重新运行应用程序</h4>

<p>菜单栏: Run -&gt; Clean and Return&#39;配置名&#39;<br/><br/>
快捷键: command + alt + R</p>

<h4 id="toc_376">停止应用程序运行</h4>

<p>菜单栏: Run -&gt; Stop&#39;配置名&#39;<br/><br/>
快捷键: command + fn + F2</p>

<h3 id="toc_377">调试应用程序</h3>

<h4 id="toc_378">断点</h4>

<h5 id="toc_379">行断点</h5>

<p>行断点是我们最常用到的断点，被用于对代码特定的行进行调试</p>

<p><strong>菜单栏</strong>: Run -&gt; Toggle Line Breakpoint <br/>
<strong>快捷键</strong>: command + F8</p>

<p>单击某行左边栏即可设置断点<br/><br/>
取消断点和添加行断点的方法相同</p>

<p><strong>属性设置</strong>: 右击行断点，弹出属性设置对话框</p>

<ul>
<li>Enabled: 断点启用和禁用</li>
<li>Suspend: 勾选All,执行到断点时所有线程都会被挂起。勾选Thread，执行到断点时只有当前断点所在的线程会被挂起。</li>
<li>Condition: 设置断点暂停条件</li>
</ul>

<h5 id="toc_380">方法断点</h5>

<p>方法断点主要用来检查方法的输入和输出</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Run -&gt; Toggle Method Breakpoint -&gt; 单击方法名所在行的左边栏</p>

<p><strong>属性设置</strong>: 右击行断点，弹出属性设置对话框。和行断点相比属性多了一个Watch，Method entry 和 Method exit表示调用此方法开始的时候和结束的时候断点都会被触发。</p>

<h5 id="toc_381">字段观察点</h5>

<p>当我们对程序运行的过程不太关心，只关心某个变量的变化时可以使用字段观察断点</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Run -&gt; Toggle Field Watchpoint -&gt; 单击字段所在行的左边栏</p>

<p><strong>属性设置</strong>: 右击行断点，弹出属性设置对话框。和行断点相比属性多了一个Java Field Watchpoints。Field access(当字段被访问的时候触发断点)和Field modification(当字段被修改时触发断点)</p>

<h5 id="toc_382">条件断点</h5>

<p>条件断点用来设置断点被触发的条件，如果条件不满足断点是不会被触发的。</p>

<p><strong>操作步骤</strong>: 右击左边栏的断点图标 -&gt; 勾选Condition -&gt; 设置暂停条件</p>

<h5 id="toc_383">临时断点</h5>

<p>当我们想某个断点只被触发一次后就自动删除的时候，可以使用临时断点</p>

<p><strong>菜单栏</strong>: Run -&gt; Toggle Temporary Line Breakpoint <br/>
<strong>快捷键</strong>: fn + command + option + shift + F8</p>

<p>如果想把临时断点变为普通断点，可以在属性中取消勾选【Remove once hit】</p>

<h5 id="toc_384">异常断点</h5>

<p>异常断点会在某个异常发生时触发断点，我们就可以第一时间得到异常信息，方便排查问题</p>

<p><strong>菜单栏</strong>: Run -&gt; View Breakpoints <br/>
<strong>快捷键</strong>: fn + command + shift + F8</p>

<p>在打开的断点窗口单击左上角的加号，选择Java Exception Breakpoints，然后在弹出的【Enter Exception Class】窗口中输入要调试的异常。</p>

<h5 id="toc_385">日志断点</h5>

<p>在调试的时候，我们想临时多加一些日志但又不想重新构建应用程序的时候，可以使用日志断点</p>

<p><strong>操作步骤</strong>: 右击左边栏的断点图标 -&gt; 取消勾选【Suspend】 -&gt; 在展开的选项中勾选【Log evaluated expression】 -&gt; 输入日志信息表达式。</p>

<p>因为取消了Suspend，所以执行到断点出不会停下，而是会打印日志。</p>

<h5 id="toc_386">禁用断点</h5>

<p>当某个断点暂时不需要但又不想删除时可以先禁用</p>

<p><strong>菜单栏</strong>: Run -&gt; Toggle Breakpoint Enable<br/><br/>
<strong>快捷键</strong>: option + 单击断点</p>

<h5 id="toc_387">断点设置</h5>

<p>打开属性配置窗口<br/><br/>
<strong>菜单栏</strong>: Run -&gt; View Breakpoints<br/><br/>
<strong>快捷键</strong>: fn + shift + command + F8<br/><br/>
<strong>调试工具窗口</strong>: 单击左边工具栏的View Breakpoints<br/><br/>
<strong>右击断点的图标</strong>: 单击More</p>

<ul>
<li>断点管理: 断点按类型进行分组，在这里可以新建和删除断点</li>
<li>常用设置: 在编辑器窗口中右击断点图标就能够设置这些属性</li>
<li>日志断点设置: 在这里可以设置日志断点的属性</li>
<li>其他设置: 设置临时断点，以及选中的断点被执行后是禁用还是丢弃当前断点</li>
<li>过滤: 设置断点的一些限制，如作用于实例的ID，指定类以及有效次数</li>
<li>预览窗口: 在这里查看断点所在的代码位置</li>
</ul>

<h3 id="toc_388">帧调试窗口</h3>

<p>帧调试窗口显示了当前断点所在的线程以及执行到该断点所调用过的方法。</p>

<h4 id="toc_389">堆栈帧</h4>

<p>堆栈帧是用来存储数据和不服你过程结果的数据结果，同时也用来处理动态链接、方法返回值和异常分派。每一次调用方法在队长总都会占用一部分内存，单位是帧。堆栈帧随着方法调用而创建，随着方法结束而销毁。每个堆栈帧中都包括传入的参数、返回地址、方法存储在堆栈上的局部变量以及对程序调试提供支持的信息。一个线程包括多个堆栈帧。</p>

<h4 id="toc_390">当前堆栈帧</h4>

<p>一个线程在执行过程中，执行到断点处暂停，如果只有当前正在执行的那个方法的堆栈帧是活动的，这个堆栈帧就是当前堆栈帧。</p>

<p><strong>帧调试窗口</strong>:</p>

<ul>
<li>显示当前断点所在的线程</li>
<li>显示执行过的方法，也可以说是执行到当前堆栈帧这个过程中所创建过的堆栈帧</li>
<li>查看工具: 查看执行过的帧和过滤当前应用的帧</li>
</ul>

<p><strong>内容菜单</strong>: 右击堆栈帧，显示可操作菜单  </p>

<ul>
<li>Add Stepping Filter(添加步进过滤器): 使用此命令再打开的对话框中添加一个步进过滤器</li>
<li>Export Threads(导出线程)</li>
<li>Customize Threads View(自定义线程显示)</li>
</ul>

<h4 id="toc_391">变量调试窗口</h4>

<p>我们可以再变量调试窗口中检查应用程序中对象值得存储，当选择堆栈帧的时候，变量调试窗口就会显示范围内的所有数据(方法的参数、本地变量和实例变量)</p>

<h5 id="toc_392">Inspect</h5>

<p>检查功能用来检查字段、局部变量和表达式的引用，既可以打开一个非模式检查窗口，也可以按照需求打开多个检查窗口</p>

<p><strong>操作步骤</strong>: 右击要检查的字段 -&gt; 局部变量或表达式 -&gt; Inspect -&gt;弹出一个非模式检查窗口</p>

<h5 id="toc_393">Mark Object</h5>

<p>标记对象功能可以给对象添加标签，看起来更加直观</p>

<p><strong>操作步骤</strong>: 右击要标记的对象 -&gt; 选择Mark Object或按快捷键fn+F3 -&gt; 然后在弹出的窗口输入对象的标签</p>

<h5 id="toc_394">Set Value</h5>

<p>用来更改运行时字段或变量的值</p>

<h5 id="toc_395">Copy Value</h5>

<p>用来复制变量或结构。当选中一个变量来复制时可以复制变量的值，当选择多项时会复制整个结构</p>

<h5 id="toc_396">Compare Value with Clipboard</h5>

<p>跟剪切板中的值比较</p>

<h5 id="toc_397">Copy Name</h5>

<p>复制变量的名字</p>

<h5 id="toc_398">Evaluate Expression</h5>

<p>计算表达式</p>

<h5 id="toc_399">Add to Watches</h5>

<p>添加到见识窗口会把选择的变量或表达式添加到监视窗口，在我们调试应用程序的时候监视窗口会显示对应的表达式或变量的值。</p>

<h5 id="toc_400">Show Referring Objects</h5>

<p>显示选中变量引用的对象列表</p>

<h5 id="toc_401">Jump to Source</h5>

<p>跳转到所选变量或字段的源码</p>

<h5 id="toc_402">Jump to Type Source</h5>

<p>打开源代码中所选变量或字段的类型</p>

<h5 id="toc_403">View Text</h5>

<p>用来显示所选变量的文本</p>

<h5 id="toc_404">Customize Data Views</h5>

<p>自定义数据显示</p>

<h3 id="toc_405">监视窗口</h3>

<p>监视窗口用来计算当前堆栈帧范围内的变量或表达式，在调试的过程中通过监视窗口来监视变量或表达式的值</p>

<h4 id="toc_406">添加变量或表达式到监视窗口</h4>

<h5 id="toc_407">监视变量</h5>

<ul>
<li>在Variables窗口中点击变量 -&gt; Add to Watches，然后在右边的监视窗口将会出现变量</li>
<li>在Watches窗口中单击左下角的+按钮 -&gt; 输入变量名，会弹出智能联想，选中后添加成功。每当程序执行到包含a变量的时候，监视窗口的值会随着a变量值的变化而变化，达到监视的目的</li>
</ul>

<h5 id="toc_408">监视表达式</h5>

<ul>
<li>按快捷键fn+option+F8，进入计算表达式窗口，输入所要监视的表达式</li>
<li>在Watches窗口中单击左下角的+按钮 -&gt; 输入表达式</li>
</ul>

<h4 id="toc_409">快捷工具</h4>

<p>利用监视窗口底部的工具栏可以快速方便地进行新建、删除、移动、复制操作。</p>

<h3 id="toc_410">调试控制工具</h3>

<p>调试控制工具常用功能</p>

<ul>
<li>暂停、恢复程序运行</li>
<li>终止进程</li>
<li>查看、禁用断点</li>
<li>获取线程堆栈</li>
</ul>

<h4 id="toc_411">View Breakpoints(查看断点)</h4>

<p>打开断点对话框、配置断点属性</p>

<h4 id="toc_412">Mute Breakpoints(禁用断点)</h4>

<p>禁用断点功能可以切换断点状态。</p>

<h4 id="toc_413">Get thread dump(获取线程堆栈)</h4>

<p>显示线程堆栈面板</p>

<h4 id="toc_414">Restore Layout(恢复布局)</h4>

<p>恢复布局功能可以恢复到原始的布局，当前所有的布局变更都会被放弃</p>

<h4 id="toc_415">(Settings)设置</h4>

<ul>
<li>Show Values Inline: 选中后启动内联调试功能，允许在编辑器中观察执行过的变量的值</li>
<li>Show Method Return Values: 选中后会显示上次执行方法的返回值</li>
<li>Auto-Variables Mode: 选中后调试器可以自动评估某些变量</li>
<li>Sort Values Alphabetically: 选中后窗口中的变量值按字母的顺序排列</li>
<li>Unmute Breakpoints on Session Finish: 选中后当一个调试回话完成就会重新启用所有禁用的断点</li>
</ul>

<h3 id="toc_416">步进调试工具</h3>

<h4 id="toc_417">Show Execution Point(显示执行点)</h4>

<p>当我们需要查看当前的执行点时，光标会立刻定位到当前执行到的断点<br/><br/>
<strong>快捷键</strong>: fn + option + F10</p>

<h4 id="toc_418">Step Over(单步跳过)</h4>

<p>执行单步跳过，就会执行下一行。如果下一行是一个方法，就不会进入方法体，而是会执行完此方法，然后跳到下一行。<br/><br/>
<strong>快捷键</strong>: fn + F8</p>

<h4 id="toc_419">Step Into(单步进入)</h4>

<p>执行单布进入，会执行下一行。如果下一行是一个方法，且该方法如果是自定义的方法，则会进入方法内，如果是官方类库的则不会进入。<br/>
<strong>快捷键</strong>: fn + F7</p>

<h4 id="toc_420">Force Step Into(强制进入)</h4>

<p>执行强制进入，会进入任何方法，不管该方法是自定义的还是官方类库的<br/><br/>
<strong>快捷键</strong>: fn option + shift + F7</p>

<h4 id="toc_421">Force Step Out(单步跳出)</h4>

<p>执行单步跳出，会跳出当前进入的方法，返回该方法被调用处的下一行。<br/><br/>
<strong>快捷键</strong>: fn + shift + F8</p>

<h4 id="toc_422">Drop frame(丢弃帧)</h4>

<p>如果你已经进入了某个方法内，执行丢弃帧，当前方法会被中断，并返回当前方法被调用的地方。另外，变量的值也会回到最初。</p>

<h4 id="toc_423">Run to Cursor(运行到光标处)</h4>

<p>在调试时，光标可以放在任意一行。程序会运行到光标所在行暂停。</p>

<h4 id="toc_424">Evaluate Expression(计算表达式)</h4>

<p>会打开计算表达式窗口<br/><br/>
<strong>快捷键</strong>: fn + option + F8</p>

<h3 id="toc_425">计算表达式</h3>

<p>当我们想临时修改某个变量的值或查看其内部方法返回值的时候，可以使用计算表达式功能。</p>

<ul>
<li>Expression Mode: 计算单行表达式</li>
<li>Code Fragment Mode: 计算代码片段，可以对声明、赋值、循环和if/else进行计算</li>
</ul>

<p>使用表达式计算功能时需要注意一下两点</p>

<ul>
<li>只有在调试并且断点被触发的时候，才可以使用计算表达式功能，也就是说如果不是在调试的住鞥太，计算表达式功能是不可用的</li>
<li>如果计算表达式调用一个方法，方法内又恰好有断点，那么该断点会被忽略，直接计算出表达式的值。</li>
</ul>

<h4 id="toc_426">在堆栈帧中计算表达式或代码片段</h4>

<p><strong>菜单栏</strong>: Run -&gt; Evaluate Expression<br/><br/>
<strong>快捷键</strong>: fn + option + F8</p>

<ul>
<li>在帧调试窗口中，选择想要计算表达式的堆栈帧</li>
<li>调用计算表达式功能</li>
<li>选择计算模式</li>
<li>输入表达式或语句</li>
<li>执行计算</li>
</ul>

<h4 id="toc_427">计算任意表达式</h4>

<p>在变量调试窗口中右击变量 -&gt; Evaluate Expression -&gt; 之前选中的变量会显示在表达式输入框中。在这里我们可以切换计算模式、查看计算过的历史、输入表达式。</p>

<h4 id="toc_428">快速计算表达式的值</h4>

<p>前提条件: 将光标放在表达式上或选中表达式<br/><br/>
<strong>菜单栏</strong>: Run -&gt; Quick Evaluate Expression<br/><br/>
<strong>快捷键</strong>: fn + option + command + F8</p>

<h4 id="toc_429">选中表达式立即显示表达式的值</h4>

<p>在调试工具栏上单击设置按钮，勾选【show value on selection change】，然后选中表达式，会在表达式的上面显示计算出来的结果。</p>

<h3 id="toc_430">关联调试到Android进程</h3>

<p>通常我们调试应用程序时，需要先添加断点，再运行调试。这样做会比较慢，因为需要重新部署应用程序。<br/><br/>
Android Studio提供了一种方法可以随时调试应用程序，不管当前应用程序是否以调试模式运行。  </p>

<p><strong>前提条件</strong>: 应用程序已经在设备上运行，已添加断点<br/><br/>
<strong>操作步骤</strong>: 菜单栏 -&gt; Run -&gt; Attach Debugger to Android Process或在工具栏中单击按钮</p>

<h3 id="toc_431">配置和运行单元测试</h3>

<h4 id="toc_432">配置和运行本地单元测试</h4>

<p>本地单元测试用来执行那些对Android没有依赖或Android依赖容易mock的单元测试<br/><br/>
本地单元测试运行在自己电脑上，测试用例在本地虚拟机上编译运行，执行速度快。<br/><br/>
本地单元测试写在app/src/test/java目录下<br/><br/>
本地单元测试使用JUnit或TestNG测试框架</p>

<p>在项目窗口中的类名上右击 -&gt; Run 测试类</p>

<h5 id="toc_433">保存临时配置</h5>

<p>通过上面的方法运行完测试之后，在工具栏的运行配置列表中显示了刚才运行的测试类。这个配置是自动生成的，如果需要保存，单击【Save ’测试类名‘ Configuration】</p>

<h5 id="toc_434">配置本地单元测试</h5>

<p>需要自定义本地单元测试配置时，可以打开Run/Debug Configurations对话框 -&gt; 单击左上角的+号 -&gt; JUnit，然后新增一个JUnit配置窗口</p>

<ul>
<li>Name: 输入配置名</li>
<li>Use classpath of module: 选择测试模块，下拉列表中会列出项目所有的模块，选择我们需要测试的。</li>
<li>Test kind: 选择一种测试范围，本例中选择的是Class
<ul>
<li>Class: 显示测试类的配置项</li>
<li>Method: 显示测试类和方法的配置项</li>
</ul></li>
<li>测试用例配置:Class，选择测试类</li>
<li>Fork mode: 用来指定是为每个测试用例都创建一个进程还是所有测试用例在一个进程中执行。
<ul>
<li>none: 在一个进程中执行所有测试</li>
<li>method: 每个测试用例都会创建一个测试进程，这种方式会比较慢</li>
</ul></li>
<li>Repeat
<ul>
<li>Once: 所有用例只执行一次</li>
<li>N Times: 自定义用例执行次数</li>
<li>Until Failure: 不断重复执行，直到用例失败</li>
<li>Until Stopped: 不断重复执行，直到手动停止</li>
</ul></li>
<li>VM options: 默认值为-ea，用来设置jvm是否启动断言机制</li>
<li>JER: 使用默认的设置即可</li>
</ul>

<h4 id="toc_435">使用命令行运行单元测试</h4>

<p><code>./gradlew test</code><br/><br/>
执行Gradle测试任务所有的测试用例都会被运行，然后会产生测试报告。测试报告存放在app/build/reports/debug/index.html里</p>

<h4 id="toc_436">配置Android单元测试</h4>

<h5 id="toc_437">Android单元测试</h5>

<p>Android单元测试用来执行那些有Android依赖或Android依赖不好mock的单元测试<br/><br/>
Android单元测试运行在真机或模拟器上<br/><br/>
Android单元测试写在app/src/androidTest/java目录下<br/><br/>
Android单元测试使用Android Tests测试框架</p>

<h5 id="toc_438">配置Android单元测试</h5>

<p>需要自定义本地单元测试配置，可以打开Run/Debug Configurations对话框 -&gt; 单击左上角的+号 -&gt; Android Tests，新增一个Android Tests配置窗口</p>

<ul>
<li>Name: 输入配置名</li>
<li>Module: 选择需要测试的模块</li>
<li>Test: 指定测试范围</li>
<li>指定instrumentation runner</li>
<li>指定目标设备</li>
</ul>

<h2 id="toc_439">工具</h2>

<p>Android Studio中集成了很多非常好用的工具，除了IntelliJ IDEA 自带任务管理、生成Java Doc等工具，还集成了以前放在SDK目录中可以独立运行的Android开发工具，如Android Monitor、Android SDK Manager、模拟器等，现在他们已经被全部集成到了Android Studio当中，而且变得更好用。</p>

<h3 id="toc_440">任务</h3>

<p>Android Studio支持与很多任务跟踪管理系统进行集成，只要配置一个任务跟踪管理系统并与我们的账号进行绑定，就可以方便地创建、跟踪、处理分配给自己的任务。<br/><br/>
一个任务可以对应多个changelist，changelist就是我们修改过的文件。我们可以给每一个changelist起名字，当完成一项任务后，可以选择提交相应的changelist。</p>

<h4 id="toc_441">配置任务</h4>

<h5 id="toc_442">进入配置界面</h5>

<ul>
<li>偏好设置 -&gt; Tools -&gt; Tasks -&gt; Servers</li>
<li>Tools - &gt; Tasks &amp; Contents -&gt; Configure Servers</li>
<li>open task 右上角的setting</li>
</ul>

<h5 id="toc_443">配置JIRA</h5>

<p>JIRA是集项目计划、任务分配、需求管理、错误跟踪于一体的商业软件。</p>

<ol>
<li>进入服务器配置界面: 偏好设置 -&gt; Tools -&gt; Tasks -&gt; Servers</li>
<li>添加JIRA服务器: 单击【+】按钮，选择JIRA</li>
<li>输入URL和账号: 输入JIRA的URL地址，再输入用户名和密码</li>
</ol>

<h5 id="toc_444">配置GitHub</h5>

<ol>
<li>进入服务器配置界面: 偏好设置 -&gt; Tools -&gt; Tasks -&gt; Servers</li>
<li>添加JIRA服务器: 单击【+】按钮，选择GitHub</li>
<li>输入URL和账号: 输入相关信息</li>
</ol>

<h5 id="toc_445">配置Gitlab</h5>

<ol>
<li>进入服务器配置界面: 偏好设置 -&gt; Tools -&gt; Tasks -&gt; Servers</li>
<li>添加JIRA服务器: 单击【+】按钮，选择Gitlab</li>
<li>输入UR和Token并选择对应项目</li>
</ol>

<h4 id="toc_446">打开任务</h4>

<h5 id="toc_447">直接打开任务</h5>

<p><strong>菜单栏</strong>: Tools -&gt; Tasks &amp; Contents -&gt; Open Tasks<br/><br/>
<strong>快捷键</strong>: option + shift + N</p>

<h5 id="toc_448">搜索任务</h5>

<p>如果任务太多需要搜索，通过输入任务名会进行相关的匹配</p>

<h5 id="toc_449">包括已关闭的任务</h5>

<p>默认显示的任务都是未关闭状态的，如果想查看已关闭的任务，需要勾选【Include closed tasks】</p>

<h5 id="toc_450">查看任务的描述和注释信息</h5>

<p>使用fn + F1键可以查看任务的描述和注释信息</p>

<h5 id="toc_451">切换任务并合并上下文</h5>

<p>在Open Task界面，选中一个任务，按Shift + 回车键会切换到选中的任务，上下文会合并。</p>

<h4 id="toc_452">创建新任务</h4>

<p>在Open Task界面输入新任务的名字，按回车键就会开始创建</p>

<p>新建一个任务的时候会新建一个分支，分支的名字默认为任务名，可以随意修改，它会跟任务相对应。默认情况下，新建一个任务时会清空前一个任务的上下文。如果不想清空，需要取消勾选【Clear current context】</p>

<h4 id="toc_453">任务变更列表</h4>

<h5 id="toc_454">新建changelist</h5>

<p>输入新的changelist的名字。</p>

<h5 id="toc_455">提交change list</h5>

<p><strong>菜单栏</strong>: VCS -&gt; Commit Changes<br/><br/>
<strong>快捷键</strong>: command + K</p>

<h4 id="toc_456">切换/关闭任务</h4>

<h5 id="toc_457">切换任务</h5>

<p><strong>操作步骤</strong>: 工具栏 -&gt; 打开任务列表 -&gt; 双击切换<br/><br/>
切换任务以后，之前任务的上下文会被关闭</p>

<h5 id="toc_458">关闭任务</h5>

<p>当一个任务完成以后，可以通过菜单栏: Tools -&gt; Tasks&amp;Contexts -&gt; Close Active Task或者快捷键option + shift + W 来关闭任务</p>

<h4 id="toc_459">管理上下文</h4>

<h5 id="toc_460">上下文是什么</h5>

<p>上下文(Context)是指与一个任务(Task)相关的在在编辑器中被打开的文件，包括变更列表、编辑器、项目查看状态、运行配置和断点。上下文与任务是密切相关的，新建一个任务，上一个任务的上下文是要被清空的，表现就是工作去已打开的文件全部被关闭，然后新的上下文就开始被建立。</p>

<h5 id="toc_461">保存上下文</h5>

<p><strong>菜单栏</strong>: Tools -&gt; Tasks&amp;Contexts -&gt; Save Context -&gt; 弹出之前保存过的context list</p>

<p>在这个列表里加载、合并、移除上下文。</p>

<h5 id="toc_462">清除上下文</h5>

<p>清除上下文功能会把所有上下文信息全部清除。<br/><br/>
<strong>菜单栏</strong>: Tools -&gt; Tasks&amp;Contexts -&gt; Clear Context</p>

<h3 id="toc_463">JavaDoc</h3>

<p>JavaDoc是Sun公司提供的一个技术，从源代码中抽取类、方法、成员等主食形成一个和源代码配套的API帮助文档。也就是说，只要在编写程序时以一套特定的标签做注释，在程序编写完成后，通过JavaDoc就可以同时形成程序的开发文档了。</p>

<h4 id="toc_464">配置JavaDoc</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; JavaDoc</p>

<h4 id="toc_465">生成JavaDoc</h4>

<p><strong>菜单栏</strong>: Tools -&gt; Generate JavaDoc 来指定生成JavaDoc的范围和参数。在这里可以指定生成JavaDoc的范围、输出目录、输出内容和参数。  </p>

<p>特备注意Other command arguments的配置，如果项目中使用的是UTF8有编码格式，在这里要指定参数: -encoding utf-8 -charset utf-8，否则生成的JavaDoc中文会出现乱码。</p>

<p>生成JavaDoc时会先执行Gradle构建任务</p>

<blockquote>
<blockquote>
<blockquote>
<p>如果生成JavaDoc时报错说 android.jar 找不到，就需要在 Dependencies 中添加 android.jar</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="toc_466">将当前文件保存为模板</h3>

<p><strong>前提条件</strong>: 光标定位在编辑界面<br/><br/>
<strong>操作步骤</strong>: 菜单栏 -&gt; Tools -&gt; Save File as Template -&gt; 弹出模板配置窗口 -&gt; 单击【OK】按钮后模板被创建</p>

<p>当新建一个文件时，可以看到刚才创建的模板选项。</p>

<p>如果想删除或重新编辑模板，就单击删除按钮或在菜单栏中单击File -&gt; New -&gt; 【Edit File Templates】</p>

<h3 id="toc_467">IDE Scripting Console</h3>

<p>使用 IDE Scripting Console 可以测试Groovy的代码片段<br/><br/>
<strong>操作步骤</strong>: 菜单栏 -&gt; Tools -&gt; IDE Scripting Console</p>

<h3 id="toc_468">管理Android SDK</h3>

<p>Android SDK 管理Android Studio中使用的SDK和工具，我们可以在这里查看、安装、启动、删除SDK。</p>

<p><strong>菜单栏</strong>: Tools -&gt; Android -&gt; SDK Manager<br/><br/>
<strong>偏好设置</strong>: Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK</p>

<h4 id="toc_469">管理Android SDK平台</h4>

<p>每个Android SDK平台的安装包都默认包含了与API级别对应的Android平台和相关的源码。</p>

<h4 id="toc_470">管理SDK开发工具和更新站点</h4>

<p>SDK Tools选项卡中显示了Android SDK的开发工具，安装后可自动检测更新，勾选【Show Package Details】会显示所有可用的SDK版本</p>

<p>SDKUpdate Sites选项卡用来管理Android SDK工具更新的站点。如果站点没有被勾选，Android Studio SDK Manager就不会去检测更新。</p>

<h3 id="toc_471">管理Android模拟器</h3>

<p>内容简单，跳过</p>

<h3 id="toc_472">即时运行</h3>

<p>Instant Run会让我们的开发过程变得快速流畅,Instant Run会分析我们修改的内容，然后决定以最快的方式部署新的代码</p>

<ul>
<li>热交换: 能够在APP运行时处理变更方法的具体实现</li>
<li>暖交换: 能够在APP运行时把资源文件注入应用中</li>
<li>冷交换: 能够在APP运行时处理一些结构性的变更。</li>
</ul>

<h4 id="toc_473">启用即时运行</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Instant Run -&gt; 勾选【Enable Instant Run to hot swap code/resource changes on deploy】</p>

<ul>
<li>Restart activity on code changes: 代码变更时重启activity</li>
<li>Show toasts in the running app when changes are applied: 每次变更应用时都显示toast提示</li>
<li>Show Instant Run status notifications: 显示即时运行状态通知</li>
</ul>

<h4 id="toc_474">使用即时运行之前需要知道的事情</h4>

<ul>
<li>即时运行只支持Android 4.0</li>
<li>即时运行只支持Debug版本</li>
</ul>

<h4 id="toc_475">如何判断是否已开启即时运行</h4>

<p>有闪电标识说明已经开启即时运行</p>

<h4 id="toc_476">即时运行是如何工作的</h4>

<p>即时运行被设计用来加快应用的构建和部署，通过执行“热交换”，“暖交换”，“冷交换”把变更的代码和资源推送到设备上</p>

<table>
<thead>
<tr>
<th style="text-align: left">代码变更</th>
<th style="text-align: left">即时运行行为</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">改变现有方法的实现代码</td>
<td style="text-align: left">支持“热交换”: APP保持正常运行，待下次方法被调用时会使用新的实现</td>
</tr>
<tr>
<td style="text-align: left">添加/删除或改变现有的资源</td>
<td style="text-align: left">支持&quot;暖交换&quot;: 变更的资源会被推送到设备上，然后Activity会自动重启</td>
</tr>
<tr>
<td style="text-align: left">结构代码变更(添加、删除或改变[-注解-实例字段-静态字段-静态方法签名-实例方法签名],改变当前类继承的父类,改变实现的接口列表,改变类的静态初始值设定,利用动态的资源ID重新布局元素)</td>
<td style="text-align: left">支持“冷交换”: 结构代码变更被推送到目标设备，然后整个应用重启</td>
</tr>
<tr>
<td style="text-align: left">改变应用的manifest,应用的manifest中改变了资源的引用</td>
<td style="text-align: left">不支持。即时运行不支持改变Android manifest或manifest中资源的引用，这是因为API中包含的某些信息是从Android manifest中确定的。当APK被安装到设备上时，如果改变了manifest就必须重装APK。由于热、暖、冷交互是为了避免重新安装APK，为了加快速度，如果改变了Android manifest，Android Studio会自动部署一个新的构建</td>
</tr>
</tbody>
</table>

<h3 id="toc_477">Android监视器</h3>

<p>Android Studio集成了非常丰富的工具来对APP进行监控和调试，我们可以在Android 监视器查看日志、截图、录像、解析布局、实时查看性能。</p>

<h4 id="toc_478">启用ADB集成</h4>

<p><strong>菜单栏</strong>: Tools -&gt; Android -&gt; 勾选Enable ADB Integration  </p>

<h4 id="toc_479">打开/隐藏 Android Monitor 工具窗口</h4>

<p><strong>快捷键</strong>: command + 6</p>

<ul>
<li>显示已连接到电脑上的设备列表，在这里选择需要使用的设备</li>
<li>显示手机上运行的APP进程列表</li>
<li>针对手机操作的工具栏，从上到下依次是截图、录像、系统信息、终止应用、布局解析、帮助工具。</li>
<li>Locat日志过滤工具栏，从左到右依次是日志级别、关键字、是否使用正则匹配、过滤配置</li>
<li>Logcat日志输出面板</li>
<li>Locat日志工具栏</li>
</ul>

<h3 id="toc_480">截图</h3>

<ul>
<li>Android Studio支持对真机和模拟器截图</li>
<li>图片格式为PNG</li>
<li>Android Studio支持对截图做一些修饰</li>
<li>截图是针对真机或模拟器的</li>
</ul>

<h3 id="toc_481">录像</h3>

<ul>
<li>视频格式为MP4</li>
<li>最长可以录制三分钟</li>
<li>仅支持真机，模拟器不能录像</li>
<li>录像是针对手机的</li>
</ul>

<h3 id="toc_482">捕获系统信息</h3>

<p>通常我们想查看系统信息都是使用adb shell dumpsys命令，如查看某个进程的内存信息:<br/><br/>
<code>~$ adb -s 设备序列号 shell dumpsys meminfo 进程名</code></p>

<h3 id="toc_483">布局解析</h3>

<p>可以分析出当前界面的布局结构以及每个组件的属性</p>

<p><strong>菜单栏</strong>: Tools -&gt; Layout Inspector  </p>

<h3 id="toc_484">Logcat监视器</h3>

<p>Logcat监视器主要用来对APP进行监控和调试，能够实时显示APP和系统输出的日志信息。当异常发生时会显示相关的堆栈信息和代码链接，我们可以单击链接跟踪到代码</p>

<p>Android 中支持6中日志类型</p>

<ul>
<li>Verbose(Log.v()): 详细，用于打印所有不重要的、一般的日志信息</li>
<li>Debug(Log.d()): 调试，用于打印调试用的日志信息</li>
<li>Info(Log.i()): 信息，用于打印正常使用时需要关注的日志信息</li>
<li>Warn(Log.w()): 警告，用于打印可能会有问题但还没发生错误的日志信息</li>
<li>Error(Log.e()): 错误，用于打印运行时出现的严重错误的日志信息</li>
<li>Assert(Log.wrf()): 断言，用于打印运行时出现的致命错误和日志信息</li>
</ul>

<p>1、日志没有显示: 在工具栏单击【Restart】重新启动日志<br/><br/>
2、设置日志头信息的显示: 在工具栏单击【Logcat Header】设置日志头信息的显示内容。<br/><br/>
3、过滤日志</p>

<ul>
<li>过滤日志类型，输出级别为 Verbose &gt; Debug &gt; Info &gt; Warn &gt; Error &gt; Assert。默认显示Verbose级别的日志。</li>
<li>过滤输出的日志信息，支持正则匹配</li>
<li>过滤器
<ul>
<li>Show only selected application: 仅显示当前选中的APP的日志</li>
<li>Firebase: 仅显示Firebase的日志信息</li>
<li>No Filters: 显示设备上所有的日志信息</li>
<li>Edit Filter Configuration: 编辑过滤器配置</li>
<li>创建一个Logcat过滤器
<ul>
<li>Filter Name: 过滤器的名字</li>
<li>Log Tag: 设置过滤Tag参数，支持正则匹配</li>
<li>Log Message: 设置过滤日志信息参数，支持正则匹配</li>
<li>Package Name: 设置过滤包名参数，支持正则匹配</li>
<li>PID: 设置过滤的作用</li>
<li>Log Level: 设置过滤的日志类型</li>
</ul></li>
</ul></li>
</ul>

<p><strong>自定义Logcat的颜色</strong>  </p>

<ul>
<li><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Android Logcat</li>
<li>设置颜色
<ul>
<li>新建一个Scheme</li>
<li>选择要设置的日志类型</li>
<li>取消勾选【Use inherited attributes】</li>
<li>设置颜色</li>
</ul></li>
</ul>

<h3 id="toc_485">内存监视器</h3>

<p>内存监视器可以实时观察应用程序的内存使用情况。</p>

<p>要想查看应用程序的内存，首先要选择设备和应用程序的进程，其次要确定内存监视器是启用状态。<br/><br/>
我们可以一边操作APP一边观察内存的变化，如果发现操作APP的过程中突然出现一个意料之外内存峰值或内存GC后不断增长，那就有可能会发生OOM或内存泄漏。<br/><br/>
我们可以主动发起GC(垃圾回收),清除无用或不再被其他对象引用的那些对象所占用的内存空间。<br/><br/>
GC后内存应该稳定在一个值附近才对，如果还在不断增长，那一定是内存泄漏了。</p>

<h4 id="toc_486">Dump Java Heap</h4>

<h5 id="toc_487">使用HPROF查看器分析内存泄漏</h5>

<ul>
<li>单击【Dump Java Heap】按钮，得到当前内存的快照(HPROF)文件。文件被存放在Captures/Heap Snapshot目录下，并使用HPROF查看器自动打开。</li>
<li><p>使用HPROF查看器分析内存泄漏(HPROF查看器显示了APP的内存分配情况，包括APP为哪些类分配了内存空间、类的对象个数以及占用的内存大小。我们可以通过这些信息确认是否发生了内存泄漏)</p>
<ul>
<li>Captrues/Heap Snapshot: 用于存放HPROF文件</li>
<li><p>显示APP占用内存空间的类和类的属性</p></li>
<li><table>
<thead>
<tr>
<th style="text-align: left">属性</th>
<th style="text-align: left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">Class Name</td>
<td style="text-align: left">内存中的类名</td>
</tr>
<tr>
<td style="text-align: left">Total Count</td>
<td style="text-align: left">内存中该类的对象个数</td>
</tr>
<tr>
<td style="text-align: left">Heap Count</td>
<td style="text-align: left">选中的堆内存中该类的对象个数</td>
</tr>
<tr>
<td style="text-align: left">Sizeof</td>
<td style="text-align: left">该对象的大小</td>
</tr>
<tr>
<td style="text-align: left">Shallow Size</td>
<td style="text-align: left">选中的堆内存中所有对象浅堆大小总和(浅堆是指一个对象直接占用的内存大小，不包含对其他对象的引用)，Shallow Size = Sizeof * Heap Count</td>
</tr>
<tr>
<td style="text-align: left">Retained Size</td>
<td style="text-align: left">选中的堆内存中所有对象保留堆大小总和(保留堆是指一个对象自己占用的浅堆加上从该对象能直接或间接访问到对象的浅堆之和)，Retained Size等于所有Dominating Size相加</td>
</tr>
</tbody>
</table></li>
<li><p>显示选中类的所有实例和属性</p></li>
<li><table>
<thead>
<tr>
<th style="text-align: left">属性</th>
<th style="text-align: left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left">Instance</td>
<td style="text-align: left">类的具体对象</td>
</tr>
<tr>
<td style="text-align: left">Depth</td>
<td style="text-align: left">从GC root到选中对象最短的跳跃数</td>
</tr>
<tr>
<td style="text-align: left">Shallow Size</td>
<td style="text-align: left">该对象的浅堆大小</td>
</tr>
<tr>
<td style="text-align: left">Dominating Size</td>
<td style="text-align: left">该对象的保留堆大小</td>
</tr>
</tbody>
</table></li>
<li><p>Reference Tree: 指向所选对象的引用，以及引用的引用，其他属性同上</p></li>
<li><p>Analyzer Tasks: 分析任务，使用这个功能可能分析出发生内存泄漏的Activity和重复的字符串</p>
<ul>
<li>Detect Leaked Activities: 检测内存泄漏的Activity</li>
<li>Find Duplicate String: 找出重复的字符串</li>
</ul></li>
<li><p>Analysis Results: 分析结果</p></li>
</ul></li>
</ul>

<h5 id="toc_488">使用MAT分析内存泄漏</h5>

<p>如果还是习惯于使用MAT分析，也可以导出标准的hprof文件</p>

<ul>
<li>Captures/Heap Snapshot -&gt; 右击.hprof文件 -&gt; Export to standard .hprof</li>
<li>选择文件的存储路径</li>
<li>单击【OK】按钮文件保存成功</li>
<li>接下来就可以直接使用MAT打开这个文件进行分析了。</li>
</ul>

<h4 id="toc_489">Allocation Tracking</h4>

<p>Allocation Tracking(内存分配追踪器)用来监视内存分配更详细的信息。我们可以监视在执行某些操作一段时间内的内存分配情况。知道这些分配，可以更加有针对性地优化相关方法。</p>

<ul>
<li>可以查看何时、何处分配了对象，以及对象的大小、分配的线程和堆栈跟踪信息</li>
<li>可以通过分配/释放模式复现内存抖动的情况</li>
<li>可以配合HPROF查看器一起使用，追踪内存泄漏的问题。例如，当我们使用HPROF查看器发现了一个bitmap驻留在堆中的时候，可以使用Allocation Tracking 找到它的分配位置。</li>
</ul>

<p>单击【Start Allocation Tracking】开始追踪内存分配，这时我们对APP进行一些操作，然后单击【Stop Allocation Tracking】</p>

<ul>
<li>停止追踪后.alloc文件被保存在Capture/Allocation Tracting目录下，并且被自动打开。</li>
<li>显示内存分配信息。默认以方法来分类内存分配信息，还可以切换成以分配器来分类内存分配信息。</li>
<li>|属性|说明|<br/>
|:--|:--|<br/>
|Method|负责内存分配的方法|<br/>
|Count|分配对象的个数|<br/>
|Size|分配的内存总大小(Byte)|</li>
</ul>

<p>单击这些属性可以进行相应的排序，我们可以通过内存分配的次数和大小来找出那些占用过多的内存、引发过多的GC且又非常耗时的方法。</p>

<ul>
<li>内存分配的图标。通过这个漂亮的图表，我们可以看出哪些方法或类拥有最多的对象</li>
<li>显示图标指定的线程或方法的分配次数和内存大小
<ul>
<li>将光标放在中心点会显示图表中占比最大的线程信息，如线程名、分配次数和内存大小</li>
<li>这个圆圈是所有线程的占比，一些占比较小的线程双击后可展开</li>
<li>显示线程名/方法名、分配次数和内存大小</li>
</ul></li>
</ul>

<h3 id="toc_490">CPU监视器</h3>

<p>CPU监视器实时显示用户和内核模式下CPU使用率的综合，可以让我们很轻松地查看操作APP时的CPU使用率</p>

<h4 id="toc_491">模式</h4>

<p>在用户(User)模式下，代码必须通过系统API访问硬盘或内存，并且只能访问虚拟内存地址，崩溃通常是可回收的。在内核(Kernel)模式下，代码可以直接访问硬件，包括物理内存地址，崩溃会导致设备停止。</p>

<h4 id="toc_492">方法追踪</h4>

<p>Method Tacking用来追踪一段时间内系统的运行情况，可以查看APP中的调用堆栈和时间信息</p>

<ul>
<li>单击左上角的Start Method Tracking</li>
<li>操作APP一段时间后再单击一次</li>
<li>trace文件被保存在Captures/Method Tracking目录下，并且自动打开
<ul>
<li>Inclusive Time: 包含时间(ms)，方法占用的CPU时间，包含内部调用其他方法占用的CPU时间</li>
<li>Exclusive Time: 独占时间(ms)，方法占用的CPU时间，但不含内部调用其他方法所占用的CPU时间</li>
</ul></li>
</ul>

<p>常用判断方法</p>

<ul>
<li>方法调用次数不多，但每次调用却需要花费很长时间，可能会有问题</li>
<li>自身占用时间不长，但调用却非常频繁的方法也可能会有问题</li>
</ul>

<h3 id="toc_493">网络监视器</h3>

<p>网络监视器用来查看APP的网络请求情况，可以实时监控到APP的数据传输，使用它可以帮助我们扎到一些不必要的或不规范的网络请求。<br/><br/>
流量测试是专项测试中非常重要的一个测试项，我们需要保证APP不会有不必要的数据加载、不会有过大的数据加载</p>

<h3 id="toc_494">GPU监视器</h3>

<p>GPU监视器用来查看UI界面渲染帧需要花多少时间，可以实时查看每一帧渲染所花费的时间。</p>

<p>GPU监视器能帮我们快速查看UI界面的渲染执行、确认渲染路径是否花了较长的处理时间、寻找帧渲染的时间峰值与用户或程序操作相关联。要想使用GPU监视器，首先要打开GPU呈现模式分析。</p>

<p>手机 -&gt; 设置 -&gt; 应用程序 -&gt; 开发者选项 -&gt; GPU呈现模式分析 -&gt; 勾选【在adb shell dumpsys gfxinfo中】 -&gt; 选中需要测试的APP进程，开启GPU监视器。</p>

<p>帧渲染的过程分成了四个不同的阶段</p>

<ul>
<li>蓝色: Draw(绘制)，表示创建/刷新DisplayList(包含需要GPU绘制到屏幕上的数据信息)所花费的时间</li>
<li>紫色: Prepare(准备)，表示UI线程将所有资源传递给渲染线程所花费的时间</li>
<li>橙色: Process(过程)，表示执行DisplayList并创建OpenGL命令所花费的时间</li>
<li>黄色: Execute(执行)，表示CPU发送OpenGL命令给GPU，等待GPU渲染完成的时间。</li>
</ul>

<p>GPU监视器的组成包括渲染帧的不同阶段，显示渲染帧耗时曲线图。绿色的线表示60FPS，即每一帧渲染时间大概是16ms。红色的线表示30FPS，即每一帧渲染时间大概是33ms</p>

<h3 id="toc_495">APK分析器</h3>

<p>能反编译APK，可以帮助我们非常方便地分析APK当中的内容。我们可以用它来分析APK当中的混淆文件，一方面可以参考别人家的APK是如何配置混淆文件的，另一方面也可以排查自己家的APK是否有相关的配置问题，我们还可以用它来查看自己编译的资源文件，找出一些比较大的文件进行具体分析，确认是否需要保留、减小包大小。右上角的【Compare with...】功能可以对比两个APK文件，找出差异性，方便分析不同版本APK之间的区别。</p>

<p><strong>菜单栏</strong>: Build -&gt; Analyze APK -&gt; 选择要分析的APK -&gt; OK</p>

<p>以微信APK为例</p>

<ul>
<li>com.tencent.mm: 微信的包名</li>
<li>version 6.1.0.73_rl097298: 版本号</li>
<li>Raw File Size: 34.2MB: 分析出来的APK文件总大小</li>
<li>Download Size: 27.6MB: 下载下来的APK的总大小</li>
<li>File: 分析出来的文件列表</li>
<li>Raw File Size: 分析出来的文件对应的原始大小(未压缩过的)</li>
<li>Download Size: 分析出来的文件对应的压缩过的大小</li>
<li>% of Total Download size: 分析出来的文件对应的压缩过的大小/下载下来的APK的总大小</li>
</ul>

<p>在APK分析结果界面，按文件大小从高到低排序，可以很清楚的看出哪些是大文件，然后查看大文件内容。如果想减少包大小，需要先从大文件入手。我们可以查看合并后的AndroidManifest.xml是否正确，还可以混淆文件，看看微信是如何进行混淆配置的。</p>

<h3 id="toc_496">主题编辑器</h3>

<p>主题编辑器支持实时预览主题效果，支持横竖屏、UI模式、虚拟机、Android版本和多语言预览。  </p>

<p><strong>菜单栏</strong>: Tools -&gt; Android -&gt; Theme Editor 或者打开 res/values/styles.xml -&gt; 单击右上角Open editor</p>

<ul>
<li>colorPrimaryDark: 状态栏颜色</li>
<li>colorPrimary: 标题栏颜色</li>
<li>textColorPrimary: 标题栏字体颜色</li>
<li>windowBackground: 窗口背景颜色</li>
<li>naigationBarColor: 虚拟导航栏背景颜色</li>
</ul>

<h2 id="toc_497">版本控制</h2>

<p>版本控制是项目开发过程中必不可少的部分，不管是个人还是团队，灵活地使用版本控制将会使项目开发变得更加轻松。</p>

<ul>
<li>菜单栏 -&gt; VCS 可以看到版本控制系统的所有功能</li>
<li>右键 -&gt; 菜单 可以看到版本控制系统的选项，只包含对应的版本控制系统特有的功能</li>
<li>底部工具栏 -&gt; Version Control(很多功能和菜单栏VCS相同，但是这里的操作更加有针对性，还可以批量操作)</li>
<li>顶部工具栏 -&gt; 常用功能(更新项目、提交变更、跟远程仓库中的文件进行对比、显示历史、撤销操作)</li>
<li>状态栏 -&gt; 分支操作(对本地、远程分支进行各种操作，比如检出、创建新的分支、对比、合并、删除等)</li>
</ul>

<h3 id="toc_498">Git偏好设置</h3>

<p><strong>设置步骤</strong>: 偏好设置 -&gt; Version Control -&gt; Git</p>

<ul>
<li>Path to Git executable: Git执行路径</li>
<li>SSH executable: 执行SSH，默认使用Android Studio内建的</li>
<li>commit automatically on cherry-pick: 在cherry-pick时是否自动提交</li>
<li>Warn if Crlf Line separators are about to be committed: 如果回车换行符被提交是否警告</li>
<li>Warn when committing in detached HEAD or during rebase: 提交detached HEAD 或 rebase 时是否警告</li>
<li>Update method: 选择代码更新方式，包括Branch defaut，merge，rebase</li>
<li>Auto-update if push of the current branch was rejected: push当前分析被拒绝是否自动更新</li>
<li>Allow force push: 是否允许强制push</li>
</ul>

<h3 id="toc_499">配置GitHub账户信息</h3>

<p><strong>设置步骤</strong>: 偏好设置 -&gt; Version Control -&gt; GitHub</p>

<p>输入账号信息</p>

<h3 id="toc_500">从GitHub克隆代码</h3>

<ul>
<li>进入GitHub克隆界面
<ul>
<li>欢迎界面: Check out project from Version Control -&gt; GitHub</li>
<li>菜单栏: File -&gt; New -&gt; Project from Version Control -&gt; GitHub</li>
<li>菜单栏: VCS -&gt; Check out from Version Control -&gt; GitHub</li>
</ul></li>
<li>配置克隆地址</li>
<li>下载并打开项目。单击【Clone】按钮开始从给定的仓库地址克隆项目到本地，完成后会弹出一个【Import Project from Gradle】确认对话框。</li>
</ul>

<h3 id="toc_501">将本地项目共享到GitHub</h3>

<ul>
<li>单价【Share Project on GitHub】。打开本地项目 -&gt; 菜单栏 -&gt; Import into Version Control -&gt; Share Project on GitHub</li>
<li>确定是本地项目。如果此项目已经在GitHub上，在Android Studio右上角会有相应的提示信息，单击GitHub可以跳转到项目主页。如果此项目没有在GitHub上，就会弹出一个新建仓库的对话框。</li>
<li>指定首次提交的文件和提交的备注。单击【OK】按钮以后在状态栏会显示进度。</li>
<li>确认分享成功。分享成功后在Android Studio的状态栏和右上角会显示成功提示。如果想查看GitHub上到底有没有分享成功，可以单击【SecondAPP】到项目主页查看。</li>
</ul>

<h3 id="toc_502">查看本地变更历史</h3>

<h4 id="toc_503">查看某个文件的本地变更历史</h4>

<p><strong>前提条件</strong>: 在文件列表中选中此文件或打开此文件，光标在文件中。<br/><br/>
<strong>操作步骤</strong>: 右击 -&gt; 在弹出的操作选项中单击Local History -&gt; Show History</p>

<p><strong>显示变更历史</strong>: 如果两个文件不同就会提示不同的个数，窗口底部列出了不同颜色表示的变更操作<br/><br/>
<strong>查看某段代码的本地变更历史</strong>: 如果想查看某段代码本地的变更，需要先选中这段代码，然后再Local History列出的选项中选择【Show History for Selection】<br/><br/>
<strong>查看某个文件夹的本地变更历史</strong>: 如果想要查看某个文件夹的本地变更，只需要选中这个文件夹，然后右击选择Local History -&gt; Show History。我们还可以为每次变更贴上一个标签，只要在Local HIstory中选择Put Label，然后输入标签内容就可以了。</p>

<h3 id="toc_504">Git添加文件</h3>

<ul>
<li>未跟踪是指没有被纳入版本控制的文件，Git就不会跟踪文件的变更</li>
<li>已跟踪是指已被纳入版本控制的文件，在上一次的快照中有它们的记录，在工作一段时间后，这些文件的状态可能是未修改，已修改或已放入暂存区。</li>
</ul>

<p>本地文件提交到远程仓库一般的流程为: 添加文件跟踪 -&gt; 暂存已修改的文件 -&gt; 提交到本地仓库 -&gt; 推送到远程仓库。</p>

<h4 id="toc_505">添加文件跟踪</h4>

<p>如果我们新建了一个文件，默认是没有被跟踪的，Git就不会跟踪文件的变更。未跟踪的文件显示为红色。</p>

<ul>
<li>右击文件 -&gt; Git -&gt; Add</li>
<li>VCS-&gt; Git -&gt; Add</li>
<li>option + command + A</li>
</ul>

<p>添加完成后，文件颜色变为绿色，即已跟踪<br/><br/>
提交到本地仓库/远程仓库的文件颜色显示为白色</p>

<h4 id="toc_506">暂存已修改的文件</h4>

<p>暂存已修改的文件方法同添加文件跟踪</p>

<h3 id="toc_507">Git提交变更</h3>

<p>当本地文件变更之后，我们需要提交变更</p>

<p><strong>菜单栏</strong>: VCS -&gt; Git -&gt; Commit File<br/>
<strong>快捷键</strong>: command + K</p>

<h4 id="toc_508">配置提交信息</h4>

<p>在提交变更窗口中可以选择Change list，也可以选择要提交的变更文件。在Author中选择或输入作者名字。选择Amend commit(修订提交)会在Commit Message中添加上一次的提交信息。<br/><br/>
还可以选择做一些代码优化的工作。</p>

<ul>
<li>Reformat code(格式化代码)</li>
<li>Rearrange code(重新排列代码)</li>
<li>Optimize imports(优化导入)</li>
<li>Perform code analysis(执行代码分析)</li>
<li>Check TODO(检查待办事项)</li>
<li>Cleanup(清理)</li>
<li>Update copyright(更新版权声明)</li>
</ul>

<h4 id="toc_509">提交变更</h4>

<ul>
<li>Commit and Push: 将本地变更的文件提交到本地仓库，然后推送到远程仓库</li>
<li>Create Patch: 将本地变更的文件作为补丁创建</li>
<li>Commit: 将本地变更的文件提交到本地仓库</li>
</ul>

<h3 id="toc_510">Git文件逐行追溯</h3>

<p>如果想查看某个文件的某一行是谁修改的，就需要使用文件逐行追溯功能<br/><br/>
执行文件逐行追溯操作，会显示某个文件每一行的详细改动信息，也可以说是每一行的注释，包括修订版本号、提交者、提交日期以及提交次数。</p>

<p><strong>如何进行文件逐行追溯</strong><br/><br/>
其实就是执行git annotate命令，同git blame  </p>

<ul>
<li><strong>菜单栏</strong>: 单击VCS -&gt; 选择Annotate</li>
<li>右击文件编辑区域 -&gt; 单击Git -&gt; 选择Annotate</li>
<li>右击文件左边栏 -&gt; 选择Annotate</li>
</ul>

<h3 id="toc_511">显示当前修订版本</h3>

<p>修订版本号是一组SHA-1值，可以通过SHA-1 值来获取对应的那一次提交。SHA-1是散列函数加密算法，输出的散列值为40位十六进制数字串，可用于验证信息的一致性，防止被篡改。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; VCS，右击某一个文件或文件编辑区 -&gt; Git -&gt; Show Current Revision</p>

<h3 id="toc_512">Git文件比较</h3>

<p>Android Studio集成的Git提供了非常好用的文件比较功能，可以将本地文件与远程仓库中的、某次提交的或其他分支的文件进行比较。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; 右击某一个文件或文件的编辑区 -&gt; VCS -&gt; Git,或者底部工具栏 -&gt; Version Control -&gt; 右击有变更的文件 -&gt; Git</p>

<ul>
<li>Compare with the Same Repository Version: 比较本地文件与远程仓库的文件</li>
<li>Compare with Last Repository Version: 本地文件与最近的一次提交比较</li>
<li>Compare with: 本地文件与某一次提交比较</li>
<li>Compare with Branch: 本地的文件或文件夹与某个分支上的进行比较</li>
</ul>

<h3 id="toc_513">Git撤销操作</h3>

<p>如果我们对某个或某几个文件进行了修改，现在想撤销这些修改，可以使用Git提供的撤销操作功能。单击【Revert】按钮，被选中的文件就恢复到了改动之前的状态。</p>

<h3 id="toc_514">Git版本回退</h3>

<p>Git版本回退的意思就是讲本地代码会退到某一个指定的版本，此版本之前的所有内容都会被重置。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; VCS -&gt; Git -&gt; Reset HEAD -&gt; 然后弹出Reset Head对话框</p>

<ul>
<li>Reset Type: 回退类型
<ul>
<li>Mixed: 回退到某个版本，本地源码不会回退，会回退commit和index信息</li>
<li>Soft: 回退到某个版本，本地远吗和index信息不会回退，只回退了commit的信息，如果还要提交，直接commit即可。</li>
<li>Hard: 彻底回退到某个版本，本地的源码也会变为某个版本的内容</li>
</ul></li>
<li>To Commit: 回退版本。
<ul>
<li>HEAD: 回退到最近一个提交版本</li>
<li>HEAD<sup>:</sup> 会退到上一个提交版本</li>
<li>HEAD<sup><sup>:</sup></sup> 会退到上上一个提交版本</li>
<li>...</li>
<li>HEAD~0: 会退到最近一个提交版本</li>
<li>HEAD~1: 会退到最近一个提交版本</li>
<li>HEAD~2: 会退到最近一个提交版本</li>
</ul></li>
<li>Validate: 版本验证。在指定会退到某个版本之前也可以先验证一下是否是想回退的版本</li>
</ul>

<h3 id="toc_515">Git查看提交历史</h3>

<p>Git查看提交历史记录也都有查看文件、文件夹和代码段的历史记录功能，不同点在于【查看本地变更历史】仅能查看本地的变更，远程的改动是无法看到的，【Git查看历史记录】可以查看所有commit以后的历史</p>

<h4 id="toc_516">查看某个文件的提交历史</h4>

<p><strong>操作步骤</strong>: 右击 -&gt; 在弹出的操作选项中单击Git -&gt; Show History -&gt; 在Version Control中显示Hitory</p>

<h4 id="toc_517">查看某段代码的提交历史</h4>

<p>选中这段代码，然后在Git操作列表中选择【Show History for Selection】</p>

<h3 id="toc_518">Git分支管理</h3>

<p>当我们在进行软件开发时，同一个软件多个人协同开发，因此要有不同的分工。如果想让彼此的代码不受影响，就需要在不同的分支上进行开发，开发完成后再进行合并。  </p>

<h4 id="toc_519">新建分支</h4>

<p>单击【New Branch】 -&gt; 输入分支的名字 -&gt; OK</p>

<h4 id="toc_520">检出分支</h4>

<p>检出分支作为新的本地分支，可以把一个远程分支checkout下来，可以起不同的名字，可以是多个本地分支，但是提交时都是向同一个远程分支进行提交。</p>

<p><strong>操作步骤</strong>: 选择一个分支 -&gt; 单击【checkout as new local branch】 -&gt; 输入新的分支名 -&gt; OK -&gt; 成功检出</p>

<p>如果是对本地分支进行【Checkout as new local branch】操作，就会直接弹出一个【Checkout New Branch】输入框，不会有默认的分支名</p>

<h4 id="toc_521">检出分支/标签/修订版本</h4>

<p>如果想检出某个分支/标签/修订版本，只需要知道对应的名字就可以了。在Git Branches操作列表中选择【Checkout Tag or Revision】 -&gt; 弹出的输入框中输入分支名 -&gt; OK后会检出对应的分支。<br/><br/>
检出tag也只需要输入tag名就可以了。如果检出当前分支的某个修订版本，就需要输入对应的修订版本号</p>

<h4 id="toc_522">切换分支</h4>

<p>切换分支需要选择切换的分支，单击【Checkout】。如果原来的分支没有变更，checkout后会切换到新的分支:如果有变更且有冲突，就会先解决冲突再切换。</p>

<h4 id="toc_523">分支对比</h4>

<p>分支对比是拿当前分支与另外一个分支进行对比。</p>

<h4 id="toc_524">对比两个分支的提交日志</h4>

<h4 id="toc_525">对比两个分支的不同</h4>

<h4 id="toc_526">合并分支</h4>

<p>合并分支只将选中的分支与当前的分支进行合并，如果有冲突就会弹出冲突列表，解决冲突合并成功。</p>

<h4 id="toc_527">删除冲突</h4>

<ul>
<li>删除本地分支: 本地分支会被直接删除</li>
<li>删除远程分支: 删除远程分支会有确认是否删除，确认删除后状态栏会有正在删除的信息显示，删除成功后Version Control上会有删除陈宫地提示。Remote Branches列表中此分支也会消失</li>
</ul>

<h3 id="toc_528">Git创建标签</h3>

<p>Git可以给历史中的某一个修订版本打上标签，通常我们会使用标签来标识一个版本的发布。</p>

<p><strong>操作步骤</strong>: 菜单栏-&gt; VCS -&gt; Git -&gt; Tag</p>

<ul>
<li>Git Root:项目地址</li>
<li>Current Branch: 显示当前的分支</li>
<li>Tag Name: 标签名</li>
<li>Force: 如果相同的Tag名已经存在，是否强制创建</li>
<li>Commit: 通过输入的修订版本号、Tag名来打标签。如果空白，默认对HEAD打标签</li>
<li>Create Tag: 创建标签</li>
</ul>

<h3 id="toc_529">Git合并分支</h3>

<ul>
<li>选择合并变更(右击项目 -&gt; 在弹出的操作列表中选择 Git -&gt; Repository -&gt; Merge Changes -&gt; 弹出合并分支对话框)</li>
<li>配置合并信息
<ul>
<li>Current Branch: 显示了当前的分支</li>
<li>Branches to merge: 显示了仓库中所有的分支，选择一个或多个要合并过来的分支</li>
<li>Strategy: 提供了可选择的合并策略，请按需选择</li>
<li>Commit Message: 添加本次合并的注释</li>
</ul></li>
<li>合并分支: 配置好合并信息后单击【Merge】按钮开始合并代码。</li>
</ul>

<h3 id="toc_530">解决Git合并中的冲突</h3>

<p><strong>问题1</strong>: 合并分支为什么会有冲突？<br/><br/>
因为在项目开发的过程中，可能大家会同时改动某个文件，当同一个文件在远程分支和本地分支按不同的方式被修改时，在合并分支的时候就会出现冲突。</p>

<p><strong>问题2</strong>: 文件冲突会导致什么样的后果？<br/><br/>
合并过程中如果文件冲突，合并就会失败，Git会在索引和工作树里设置一个特殊的状态，提示你如何解决冲突。我们必须解决完冲突并且更新索引后才能够将文件提交。</p>

<h4 id="toc_531">打开文件冲突列表</h4>

<p><strong>操作步骤</strong>: Git -&gt; Resolve Conflicts<br/><br/>
合并过程中如果有冲突也会突出文件冲突列表</p>

<h4 id="toc_532">解决冲突的方法</h4>

<ul>
<li>如果想放弃本地的改动，而完全使用远程分支的改动，可选择【Accept Theirs】，此文件冲突解决</li>
<li>如果想放弃远程的改动，而完全使用本地的改动，可选择【Accept Youts】，此文件冲突解决</li>
<li>如果想详细解决冲突，单击【Merge】 -&gt; 会打开文件比较窗口。左边是本地变更，邮编是远程分支上的变更，中间是合并结果。如果把右边远程分支的变更用作合并结果，单击‘&lt;&lt;’远程的变更就回到合并结果中。同理，也可将本地变更合并到结果中。</li>
</ul>

<p>如果觉得改错了要恢复，可单击【Revert】。如果确定了合并结果，就单机【Apply】。</p>

<h3 id="toc_533">Git使用Rebase合并分支</h3>

<p><strong>Git Rebase是什么</strong><br/><br/>
Rebase顾名思义是‘变基’的意思，即合并时重新定义分支的根基或节点，让提交记录按时间线排列。</p>

<p><strong>Git Rebase和Merge的区别是什么</strong><br/>
Rebase跟Merge一样，都是用来合并分支的，但是Merge操作会生成一个新的节点，与之前的提交分开显示: Rebase操作不会生成新的节点，而是将两个分支融合成一个线性的提交。</p>

<p><strong>什么时候使用Git Rebase</strong><br/><br/>
使用Rebase合并分支会使提交记录看起来非常清晰，因为它是时间线线性的现实记录，所以打你想线性地查看分支的提交记录时，可以使用Git Rebase来合并分支</p>

<p>对每个提交定义rebase行为。默认为pick</p>

<ul>
<li>pick: 以同样的提交信息保存提交</li>
<li>edit: 在对下一提交进行操作之前，会让你对提交进行修正</li>
<li>skip: 遇到冲突暂停时，跳过这个提交</li>
<li>squash: 把这个提交和前一个提交合并成为一个新的提交</li>
<li>reword: 提交时要编辑提交信息</li>
<li>fixup: 和squash类似，但是要放弃提交信息</li>
</ul>

<h3 id="toc_534">Git暂存/恢复暂存变更</h3>

<h4 id="toc_535">暂存是什么意思</h4>

<p>Git暂存就是从最近一次提交中读取相关内容，让工作区保证和上次提交的内容一致，相当于清空本地的所有改动。只不过这些改动进行了备份，我们可以选择性地进行恢复。</p>

<h4 id="toc_536">什么时候使用暂存</h4>

<p>将写到一半的代码暂存，然后切换到其他分支修复BUG，BUG修复完成后再切回当前分支，然后恢复之前咱村的代码继续编写</p>

<h4 id="toc_537">暂存和恢复暂存怎么用</h4>

<p>在Dev分支单击【Create Stash】创建暂存，IDE消除了本地的改动，恢复到上次提交的内容。切换到Master分支，改好代码返回Dev分支。此时会弹出暂存列表，选择之前暂存的代码，单击【Apply Stash】按钮进行恢复</p>

<h3 id="toc_538">Git获取最新内容</h3>

<p>从远程仓库获取项目中最新的内容，包括远程仓库中分支的状态，可以通过菜单栏 -&gt; VCS -&gt; Git -&gt; Fetch完成。Git会去拉取远程仓库最新的内容，并清除远程服务器上删掉的分支。</p>

<h3 id="toc_539">Git合并最新内容</h3>

<p>要从远程仓库获取最新的内容，然后和本地的内容自动进行合并，可以通过菜单栏 -&gt; VCS -&gt; Git -&gt; Pull。</p>

<p>Git会先执行Fetch去拉取远程仓库最新的内容，再执行Merge把远程仓库中的代码和本地代码合并。执行Pull以后在Version Control中会显示更新的详情。</p>

<h3 id="toc_540">Git更新项目</h3>

<ul>
<li>菜单栏: VCS -&gt; Update Project</li>
<li>快捷键: Command + T</li>
<li><p>工具栏</p></li>
<li><p>Update Type(更新类型): 提供了3种类型来进行同步</p>
<ul>
<li>Merge: 更新后合并，相当于执行git fetch命令，再执行git merge或git pull——no-rebase</li>
<li>Rebase: 更新后变基，相当于执行git fetch命令，再执行git rebase或git pull--rebase</li>
<li>Branch Default: 更新后使用分支默认命令</li>
</ul></li>
<li><p>Clean working tree before update(更新之前先清理工具目录): 可选择在清空工作目录之前以什么样的方式来保存你的更改，当更新完成后，可以恢复之前的更改。</p>
<ul>
<li>Using Stash: 使用暂存</li>
<li>Using Shelve: 使用搁置</li>
</ul></li>
</ul>

<h3 id="toc_541">刷新文件状态</h3>

<p>如果我们想刷新本地文件的状态，可以使用此功能。</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; VCS -&gt; Refresh File Status,或者Version Control工具窗口 -&gt; Local Changes -&gt; Refresh</p>

<h3 id="toc_542">Git 补丁</h3>

<p><strong>什么是补丁</strong><br/><br/>
Git当中的补丁是一个文本文件，包含了对源代码的修改。你可以创建一个项目中的补丁，然后把它发给需要的人，拿到补丁文件的人可以为自己的项目打上这个补丁。</p>

<p><strong>创建补丁</strong><br/><br/>
假设你修改了项目中的一个BUG，然后需要创建一个补丁</p>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; VCS -&gt; Create Patch... -&gt; 弹出Create Patch配置对话框</p>

<p><strong>应用补丁</strong><br/><br/>
当我们拿到补丁后，可以通过菜单栏 -&gt; VCS -&gt; Apply Patch... -&gt; 选择补丁文件 -&gt; 单击【OK】</p>

<h3 id="toc_543">Git搁置变更</h3>

<p>类似Git的暂存命令，等想恢复的时候再来恢复搁置。与暂存不同的是，搁置功能相当于是本地打了个补丁，把补丁文件保存在本地，等想要恢复的时候给项目打上个补丁就可以了。</p>

<h4 id="toc_544">搁置变更</h4>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; VCS -&gt; Shelve Changes -&gt; 在弹出的对话框中选择要暂时搁置的变更 -&gt; 单击【Shelve Changes】</p>

<h4 id="toc_545">恢复搁置</h4>

<p>当我们修改完BUG，回到之前的分支准备继续写代码，需要恢复之前搁置的变更</p>

<ul>
<li>Unshelve Changes: 默认恢复搁置到新建的变更列表(<strong>操作步骤</strong>: Version Control工具窗口 -&gt; Shelf -&gt; 右击之前搁置的文件 -&gt; Unshelve Changes -&gt; 默认新建一个Changelist -&gt; 输入Name后单击【OK】按钮)</li>
<li>Unshelve: 默认恢复搁置到默认的变更列表(<strong>操作步骤</strong>: Version Control工具窗口 -&gt; Shelf -&gt; 右击之前搁置的文件 -&gt; Unshelve -&gt; 弹出恢复搁置的对话框 -&gt; 单击【OK】按钮后搁置恢复)</li>
</ul>

<h3 id="toc_546">查看Git项目的提交信息</h3>

<h4 id="toc_547">查看本地Git项目提交信息</h4>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; VCS -&gt; Browse VCS Repository -&gt; Show Git Repository Log -&gt; 弹出选择对话框 -&gt; 选择一个要浏览日志的项目</p>

<h4 id="toc_548">查看当前项目的提交信息</h4>

<p>在Version Control工具窗口的Log查看当前项目的分支信息及提交信息</p>

<h4 id="toc_549">过滤信息</h4>

<ul>
<li>过滤提交信息</li>
<li>过滤分支/用户/日期/路径</li>
</ul>

<h2 id="toc_550">窗口</h2>

<h3 id="toc_551">最小化和最大化窗口</h3>

<h4 id="toc_552">最小化窗口</h4>

<p><strong>菜单栏</strong>: Window -&gt; Minimize<br/><br/>
<strong>快捷键</strong>: command + M</p>

<h4 id="toc_553">最大化窗口</h4>

<p><strong>菜单栏</strong>: Window -&gt; Zoom<br/><br/>
<strong>快捷键</strong>: options + command + “=”</p>

<h3 id="toc_554">保存和恢复窗口布局</h3>

<h4 id="toc_555">保存当前布局为默认布局</h4>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Window -&gt; Store Current Layout as Default</p>

<h4 id="toc_556">恢复默认的布局</h4>

<p><strong>菜单栏</strong>: Window -&gt; ReStore Default Layout<br/><br/>
<strong>快捷键</strong>: fn + shift + F12</p>

<h3 id="toc_557">工具窗口的显示和隐藏</h3>

<p><strong>通过Tool Windows显示/隐藏工具窗口</strong><br/><br/>
<strong>操作步骤</strong>: 菜单栏 -&gt; View -&gt; Tools Windows -&gt; 显示Android Studio支持的所有工具列表</p>

<p><strong>通过工具窗口都可以通过工具条上的Tab来显示和隐藏</strong>  </p>

<h3 id="toc_558">工具窗口的隐藏技巧</h3>

<h4 id="toc_559">隐藏活动的工具窗口</h4>

<p>当有多个窗口被打开的时候，之隐藏活动的那一个工具窗口<br/><br/>
<strong>菜单栏</strong>: Window -&gt; Active Tool Window -&gt; Hide Ative Tool Window | Close Active Tab</p>

<h4 id="toc_560">挨个隐藏工具窗口</h4>

<p>当有多个窗口被打开的时候，使用此功能可以按打开的顺序逆向隐藏工具窗口<br/><br/>
<strong>菜单栏</strong>: Window -&gt; Active Tool Window -&gt; Hide side tool Window</p>

<h4 id="toc_561">隐藏所有工具窗口</h4>

<p>当编辑器和工具窗口都打开的时候，界面会显得比较乱。如果我们只想专注地编写代码，就可以一键把所有工具窗口隐藏<br/><br/>
<strong>菜单栏</strong>: Window -&gt; Active Tool Window -&gt; Hide All Windows<br/><br/>
<strong>快捷键</strong>: fn + shift + command + F12</p>

<h4 id="toc_562">恢复隐藏的所有工具窗口</h4>

<p><strong>菜单栏</strong>: Window -&gt; Active Tool Window -&gt; Restore Windows<br/><br/>
<strong>快捷键</strong>: fn + shift + command + F12</p>

<h3 id="toc_563">工具窗口调整技巧</h3>

<h4 id="toc_564">跳转到上一个</h4>

<p>我们经常会在工具窗口和编辑器之间跳转，可以让光标快速跳转到上一个工具窗口</p>

<p><strong>菜单栏</strong>: Window -&gt; Active Tool Window -&gt; Jump to Last Tool Window<br/><br/>
<strong>快捷键</strong>: fn + F12</p>

<h4 id="toc_565">最大化工具窗口</h4>

<p><strong>菜单栏</strong>: Window -&gt; Active Tool Window -&gt; Maximize tool Window<br/><br/>
<strong>快捷键</strong>: shift + command + “‘”</p>

<h4 id="toc_566">恢复最大化工具窗口</h4>

<p>原来的【Maximize tool Window】变为【Restore tool window size】</p>

<h4 id="toc_567">逐渐调整工具窗口大小</h4>

<p>最快的调整方式使用鼠标长按托拖动</p>

<p>激活工具窗口 -&gt; 菜单栏 -&gt; Window -&gt; Active Tool Window -&gt; Resize -&gt; Stretch to Top/Bottom/Right/Left</p>

<h3 id="toc_568">移动工具窗口的位置</h3>

<p>右击工具窗口 -&gt; Move To -&gt; 选择要移动到的位置</p>

<h3 id="toc_569">工具窗口的查看模式</h3>

<h4 id="toc_570">停驻和浮动模式</h4>

<h4 id="toc_571">停靠和脱开模式</h4>

<h4 id="toc_572">固定和非固定模式</h4>

<h4 id="toc_573">分离模式</h4>

<p>在同一个工具条上最多可以同时显示两个工具窗口</p>

<h4 id="toc_574">作为标签显示</h4>

<h3 id="toc_575">编辑器标签设置</h3>

<p>任一时刻打开一个文件都会以标签页的形式在编辑窗口出现</p>

<p>设置编辑器标签: 偏好设置 -&gt; Editor -&gt; Editor Tabs</p>

<h3 id="toc_576">快速切换编辑器标签</h3>

<h4 id="toc_577">上一个/下一个标签</h4>

<p><strong>前提条件</strong>: 光标在编辑器中<br/><br/>
<strong>菜单栏</strong>: Window -&gt; Editor Tabs -&gt; Select Next Tab 或 Select Previous Tab<br/><br/>
<strong>快捷键</strong>: shift + command + ←/→</p>

<h4 id="toc_578">快速切换已打开的文件</h4>

<p>快捷键control + tab 调出switcher</p>

<h4 id="toc_579">快速切换工具窗口</h4>

<p>使用快捷键control + tab 调出switcher，默认选中的是文件，如果想默认选中的是工具，则使用快捷键control + shift + tab。长按control + shift，通过按tab来切换工具。</p>

<h3 id="toc_580">关闭编辑器标签</h3>

<p>对标签右击，来选择性关闭标签页</p>

<h3 id="toc_581">管理编辑器标签</h3>

<h4 id="toc_582">重新打开关闭的标签</h4>

<p><strong>操作步骤</strong>: 右击编辑器标签 -&gt; Reopen Closed Tab -&gt; 最后被关闭的标签会被打开</p>

<h4 id="toc_583">在最后打开新标签</h4>

<p><strong>操作步骤</strong>: 右击编辑器标签 -&gt; 选中Open New Tabs At The End -&gt; 再打开新的文件标签时就会在已打开的标签最后打开</p>

<h4 id="toc_584">通过文件名排序标签</h4>

<p><strong>操作步骤</strong>: 右击编辑器标签 -&gt; Sort Tabs By Filename</p>

<h3 id="toc_585">标签显示位置</h3>

<p>默认标签是显示在编辑器窗口最上面，我么也可以自定义显示的位置</p>

<p><strong>操作步骤</strong>: 右击标签 -&gt; Tabs Placement -&gt; 选择显示位置</p>

<h3 id="toc_586">拆分编辑器窗口</h3>

<h4 id="toc_587">拆分一个标签窗口</h4>

<ul>
<li>右击标签 -&gt; Split Vertically/Horizontal(垂直拆分/水平拆分)</li>
<li>右击标签 -&gt; Move Right 或 Move Down。相当于水平拆分和垂直拆分，不同点是Move会把当前的标签页移到拆分的一边，而Split不会</li>
</ul>

<h4 id="toc_588">改变拆分窗口的摆放方式</h4>

<p><strong>操作步骤</strong>: 右击标签 -&gt; Change Splitter Orientation</p>

<p>改变拆分窗口的摆放方式</p>

<h4 id="toc_589">标签组</h4>

<p>Android Studio可以通过将标签页分组的方式支持多文件同时编辑，组的数量没有限制</p>

<p><strong>操作步骤</strong>: 右击标签 -&gt; Move to Opposite Group。如果想把当前文件在另外一个标签组打开可以选择Open In Opposite Group</p>

<h4 id="toc_590">撤销拆分</h4>

<p><strong>操作步骤</strong>: 右击标签 -&gt; Unsplit 或 Unsplit All</p>

<h3 id="toc_591">多个项目之前切换</h3>

<h4 id="toc_592">打开后面一个项目</h4>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Window -&gt; Next Project Window</p>

<h4 id="toc_593">打开前面一个项目</h4>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Window -&gt; Previous Project Window</p>

<h4 id="toc_594">选择某个已打开项目</h4>

<p>菜单 -&gt; Window 子菜单来完成</p>

<h2 id="toc_595">偏好设置</h2>

<h3 id="toc_596">外观与行为</h3>

<h4 id="toc_597">设置工具提示的延迟时间</h4>

<p>当我们把鼠标停在工具栏上的工具或编辑器中的项目会出现提示</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; Appearance -&gt; 滑动设置【Tooltip initial delay】</p>

<h4 id="toc_598">设置在状态栏显示内存状态</h4>

<p>如果想实时显示内存的使用情况</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; Appearance -&gt; 勾选【Show memory indicator】</p>

<h4 id="toc_599">对菜单选项和工具栏上的工具进行增删改</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; Menus and Toolbars -&gt; 选择需要操作的选项</p>

<h3 id="toc_600">系统设置</h3>

<h4 id="toc_601">设置启动Android Studio时是否自动打开项目</h4>

<p>当我们打开Android Stuio时默认会打开上次最后关闭的项目，如果不想自动打开上次关闭的项目</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 不勾选【Reopen last project on startup】</p>

<h4 id="toc_602">设置退出Android Studio时是否弹出确认提示</h4>

<p>当我们关闭Android Studio时默认会弹出确认提示，如果不想每次都确认</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 不勾选【Confirm application exit】</p>

<h4 id="toc_603">设置打开一个项目时的打开方式</h4>

<p>当我们打开一个新项目时默认会弹出一个确认提示，让我们确认是在新窗口打开还是在当前窗口打开。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 设置Project Opening</p>

<ul>
<li>Open project in new window: 在一个新窗口打开项目</li>
<li>Open project in the same window: 在同一个窗口打开项目</li>
<li>Confirm window to open project in: 弹出确认对话框，可选择在新窗口或原窗口打开</li>
</ul>

<h4 id="toc_604">设置文件定期自动保存</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 勾选【Save files automatically if application is idle for [] sec】</p>

<h4 id="toc_605">设置编辑窗口失活时文件自动保存</h4>

<p>编辑窗口失活的意思是可理解为从编辑窗口切换到其他窗口。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; 勾选【Save files on frame deactivation】</p>

<h4 id="toc_606">设置密码存储策略</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Passwords -&gt; 设置Password storage policy</p>

<ul>
<li>Do not remember passwords: 不记住密码，每次都要输入密码</li>
<li>Remember passwords until the application is closed: 记住密码，直到应用程序被关闭</li>
<li>Save on disk with master password protection: 密码保存到磁盘，使用master password来保护</li>
</ul>

<h4 id="toc_607">设置是否让Google统计使用信息</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Usage Statistics -&gt; Send usage statistics to Google</p>

<p>此功能统计Android Studio的使用情况(功能，资源的使用情况和插件的配置信息)，然后发送给Google</p>

<h3 id="toc_608">键盘映射</h3>

<h4 id="toc_609">在Android Studio中如何使用Eclipse的快捷键</h4>

<p>在Keymaps中选择</p>

<h4 id="toc_610">如何自定义一份属于自己的keymap</h4>

<p>复制一份keymap，在复制的keymap中修改</p>

<h3 id="toc_611">编辑器常规设置</h3>

<h4 id="toc_612">设置单击编辑器光标定位在一行的结尾或定位在单击的位置</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Virtual Space -&gt; 勾选【Allow placement of caret after end of line】</p>

<ul>
<li>勾选，在空白位置单击，光标会定位在一行的结尾</li>
<li>不勾选，在空白位置单击，光标会定位在单击的地方</li>
</ul>

<h4 id="toc_613">设置鼠标悬停在元素上会显示文档提示</h4>

<p>如果想让鼠标悬停在某个变量、类或方法上直接显示它的文档。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Other -&gt; 勾选【Show quick documentation on mouse move】</p>

<h4 id="toc_614">设置是否自动换行</h4>

<p>当一行的内容超过编辑器的宽度时，它会自动换行。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; 查看Soft Wraps -&gt; 勾选【Use soft wraps in editor】</p>

<h5 id="toc_615">让换行符一直显示</h5>

<p>如果向现实所有的换行符，就不要勾选【show soft wrap indicators for current line only】</p>

<h5 id="toc_616">设置换行后的缩进字符</h5>

<p>如果想自定义换行后第二行的缩进，可以勾选【Use original line`s indent for wrapped parts】 -&gt; 设置 Additional shift</p>

<h4 id="toc_617">设置使用command + 鼠标控制代码的缩放</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; 勾选【Change font size with Command + Mouse Wheel】</p>

<h4 id="toc_618">开启使用驼峰单词</h4>

<p>移动光标或选择单词时可以识别驼峰</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Smart Keys -&gt; 勾选【Use &quot;CamelHumps&quot; words】</p>

<h4 id="toc_619">关闭单词拼写检查</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Inspections -&gt; 取消勾选【Spelling】</p>

<h4 id="toc_620">设置代码折叠规则</h4>

<p>自定义代码折叠的规则</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Folding</p>

<h3 id="toc_621">设置自动导入</h3>

<h4 id="toc_622">设置粘贴时自动导入包</h4>

<p>从其他地方复制一段代码粘贴到Android Studio文件中时，默认Android Studio会询问你是否导入引用的包。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Insert imports on paste</p>

<ul>
<li>All: 全部自动导入</li>
<li>Ask: 询问是否自动导入</li>
<li>None: 不自动导入</li>
</ul>

<h4 id="toc_623">设置自动导入需要的包</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Auto Import -&gt; 勾选【Optimize imports on the fly】 和 【Add unambiguous imports on the fly】</p>

<h4 id="toc_624">设置是否弹出导入提示</h4>

<p>当你输入的类的声明没有被导入时，会弹出一个导入提示</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Auto Import -&gt; Show import popup</p>

<h3 id="toc_625">编辑器外观</h3>

<h4 id="toc_626">设置编辑器一直显示行号</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show line number】</p>

<h4 id="toc_627">设置编辑器显示方法分隔符</h4>

<p>如果你想让每个方法区分得更明显，可以显示方法分隔符</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show method separators】</p>

<h4 id="toc_628">设置编辑器显示空格</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show whitespace】</p>

<h4 id="toc_629">设置编辑器显示缩进向导</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Appearance -&gt; 勾选【Show vertical indent guides】</p>

<h3 id="toc_630">代码补全</h3>

<h4 id="toc_631">设置自动补全时是否区分大小写</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Completion</p>

<p>Case sensitive completion: </p>

<ul>
<li>First letter: 区分首字母大小写</li>
<li>All: 区分全部大小写</li>
<li>None: 不区分大小写</li>
</ul>

<h4 id="toc_632">加快自动弹出代码补全提示的速度</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Completion -&gt; 将【Autopopup decumentation in】设置为0，在Parameter Info将【Autopopup in】中设置为0</p>

<h4 id="toc_633">关闭自动弹出代码补全提示</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Completion -&gt; 不勾选【Autopopup decumentation in】，在Parameter Info不勾选【Autopopup in】</p>

<h4 id="toc_634">设置查看方法参数信息的时候显示方法签名</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Code Completion -&gt; Show full signatures</p>

<h3 id="toc_635">文件标签</h3>

<h4 id="toc_636">设置用星号标记修改过的文件标签</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Editor Tabs -&gt; 勾选【Mark modified tabs with asterisk】</p>

<h4 id="toc_637">设置打开的文件标签可以多行显示</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Editor Tabs -&gt; 取消勾选【Show tabs in single row】，即可让标签不隐藏，并且全部显示出来</p>

<h4 id="toc_638">设置文件标签的显示位置</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Editor Tabs -&gt; Placement -&gt; 选择显示位置</p>

<h4 id="toc_639">设置文件标签超过一定数量时的关闭规则</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; General -&gt; Editor Tabs -&gt; Tab Closing Policy -&gt; 配置关闭规则</p>

<ul>
<li>打开文件标签限制数量</li>
<li>当打开的文件标签超过10个时关闭使用频率较少的</li>
<li>当关闭标签时，激活左边相邻的标签</li>
</ul>

<h3 id="toc_640">编辑器颜色</h3>

<h4 id="toc_641">设置是否显示条标和条标的显示颜色</h4>

<p>当编辑器中有报错的时候，在右边框上会显示一个红色的条，即条标</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; General -&gt; 勾选【Error stripe mark】</p>

<h4 id="toc_642">设置控制台的颜色</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Console Colors</p>

<h4 id="toc_643">设置控制台的字体</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Console Font</p>

<h4 id="toc_644">自定义代码的颜色</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Colors &amp; Fonts -&gt; Java -&gt; 新建一个Scheme</p>

<h3 id="toc_645">代码风格</h3>

<h4 id="toc_646">设置Java注释按缩进显示</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Wrapping and Braces -&gt; Keep when reformatting -&gt; 取消勾选【Comment at first column】</p>

<h4 id="toc_647">设置语句不要都显示在一行</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Wrapping and Braces -&gt; Keep when reformatting -&gt; 取消勾选【Control statement in one line】</p>

<h4 id="toc_648">设置Java简单的类合并为一行</h4>

<p>Android Studio中的默认设置是代码格式化后不会把简单的类合并为一行</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Wrapping and Braces -&gt; Keep when reformatting -&gt; 勾选【Simple classes in one line】</p>

<h4 id="toc_649">设置Java字段和变量列对齐</h4>

<p>Android Studio中默认是没有列对齐的。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Wrapping and Braces -&gt; Group declarations -&gt; 勾选【Align fields in columns】 和 【Align variables in columns】</p>

<h4 id="toc_650">设置自动生成字段名称时添加前缀</h4>

<p>默认自动生成字段名称是不会有任何前缀的。不过在Android Studio中提供了自动添加自定义前缀或后缀的功能，以便统一编码规范。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Code Style -&gt; Java -&gt; Code Generation -&gt; 输入需要添加的前缀或后缀</p>

<h3 id="toc_651">文件和代码模板</h3>

<h4 id="toc_652">设置新建文件的注释模板</h4>

<p>当我们新建一个文件时会自动插入这个注释</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; File and Code Templates -&gt; Includes -&gt; File Header -&gt; 输入自定义的注释模板</p>

<h4 id="toc_653">模板中内置的变量</h4>

<ul>
<li>￥{PACKAGE_NAME}: 包名</li>
<li>￥{USER}: 系统的登录名</li>
<li>￥{DATE}: 系统日期</li>
<li>￥{TIME}: 系统时间</li>
<li>￥{YEAR}: 年份</li>
<li>￥{MONTH}: 月份</li>
<li>￥{MONTH_NAME_SHORT}: 月份的前三个字符</li>
<li>￥{MONTH_NAME_FULL}: 月份的全名</li>
<li>￥{DAY}: 天</li>
<li>￥{HOUR}: 时</li>
<li>￥{MINUTE}: 分钟</li>
<li>￥{PROJECT_NAME}: 项目名</li>
</ul>

<h4 id="toc_654">设置新建类文件模板</h4>

<p>在类文件中可以引用头文件的注释模板<br/><br/>
如果我们想在新建类文件时自动添加某段代码<br/><br/>
加了一段代码以后我们再新建一个类文件<br/><br/>
每次新建类文件时，这段代码模板都会被应用，效率会提高很多</p>

<h4 id="toc_655">设置IDE和项目的编码</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; File Encodings</p>

<p>为了防止中文乱码，一般都会勾选Transparent native-to-ascii conversion</p>

<h4 id="toc_656">对动态模板进行增删改查</h4>

<p>Android Studio中提供了快速插入常用代码的功能Live Templates</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; Live Templates -&gt; 对动态模板进行增删改查</p>

<ul>
<li>查看动态模板分组</li>
<li>新增/删除/复制一个模板</li>
<li>查看具体模板</li>
</ul>

<h4 id="toc_657">设置展开代码的按键</h4>

<p>当我们要插入动态模板的时候，输完代码片段的缩写以后默认按Tab键就可以展开diamante。当然也可以自定义展开按键。</p>

<h4 id="toc_658">给一个文件类型添加匹配规则</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; File Types -&gt; 在Recognized File Types列表中选中一个文件类型 -&gt; 在Registered Patterns中单击+，添加一个文件类型的匹配规则</p>

<h4 id="toc_659">添加一个自定义的文件类型</h4>

<p>如果Android Studio可识别的文件类型不能满足需求，可以自定义一个。Android Studio中支持自定义文件类型，可以对这个文件类型设置一些特性，如关键字、注释、高亮显示，还可以设置一些模板，提高操作效率。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; File Types -&gt; 在Recognized File Types中单击+ -&gt; 设置新的文件类型</p>

<h4 id="toc_660">设置忽略某类文件或文件夹</h4>

<p>如果我们不想让某个文件或某类型的文件在编辑器中显示，就可以将其忽略</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Editor -&gt; File Types -&gt; 在Ignore files and folders中添加文件类型</p>

<h3 id="toc_661">插件</h3>

<p>Android Studio是基于IntelliJ IDEA开发的，自然继承了IntelliJ IDEA优秀的插件系统。我们可以通过安装插件来扩展Android Studio的功能，这会极大地方便我们日常的开发工作。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Plugins</p>

<ul>
<li>All plugins: 所有插件</li>
<li>Enabled: 所有已启用的插件</li>
<li>Disabled: 所有已禁用的插件</li>
<li>Bundled: 所有IDEA自带的插件</li>
<li>Custom: 所有我们自己安装的插件</li>
</ul>

<h4 id="toc_662">安装插件</h4>

<h5 id="toc_663">Install JetBrains plugins(安装JetBrains插件)</h5>

<p>单击【Install JetBrains plugin】，然后弹出插件列表</p>

<ul>
<li>插件排序: 插件列表默认按name排序，同时允许添加排序条件(多选)</li>
<li>插件分类</li>
<li>安装插件
<ul>
<li>选中插件 -&gt; 在插件简介中单击【Install】按钮</li>
<li>下载插件</li>
<li>下载完成后重启Android Studio，插件安装成功</li>
</ul></li>
<li>设置代理</li>
</ul>

<h5 id="toc_664">Browse Repositories(浏览插件仓库)</h5>

<p>我们想查看插件仓库中所有的插件，可以单击【Browse repositories】，然后弹出插件列表，这里的操作跟安装JetBrains插件是一样的。</p>

<h5 id="toc_665">Install plugin from disk(从本地磁盘安装插件)</h5>

<ul>
<li>下载插件到本地。到Android Studio插件官网(<a href="https://plugins.jetbrains.com/?androidstudio)%E6%89%BE%E5%88%B0%E8%87%AA%E5%B7%B1%E6%83%B3%E8%A6%81%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82">https://plugins.jetbrains.com/?androidstudio)找到自己想要的插件，下载到本地。</a></li>
<li>单击【Install plugin from disk】 -&gt; 选择下载的插件</li>
<li>重启Android Studio</li>
</ul>

<h4 id="toc_666">禁用插件</h4>

<p>Android Studio中默认安装了一些根本用不到的插件，可以禁用这些插件</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Plugins -&gt; 取消勾选想禁用的插件 -&gt; 重启 -&gt; 生效</p>

<h4 id="toc_667">卸载插件</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Plugins -&gt; 选中插件 -&gt; Uninstall</p>

<h4 id="toc_668">常用插件</h4>

<h5 id="toc_669">编辑器插件</h5>

<table>
<thead>
<tr>
<th style="text-align: left">插件名</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Key promoter</td>
<td style="text-align: left">用于生成快捷键提示</td>
</tr>
<tr>
<td style="text-align: left">CodeGlance</td>
<td style="text-align: left">用于生成代码缩略图，方便快速定位</td>
</tr>
<tr>
<td style="text-align: left">Eclipse Code Formatter</td>
<td style="text-align: left">用于使用Eclipse的代码格式化风格</td>
</tr>
<tr>
<td style="text-align: left">BashSupport</td>
<td style="text-align: left">用于支持Bash语言</td>
</tr>
<tr>
<td style="text-align: left">IdeaVim</td>
<td style="text-align: left">用于支持VIM</td>
</tr>
<tr>
<td style="text-align: left">Grep Console</td>
<td style="text-align: left">用于自定义控制台输出颜色</td>
</tr>
<tr>
<td style="text-align: left">Maven Helper</td>
<td style="text-align: left">用于查看Maven依赖树</td>
</tr>
</tbody>
</table>

<h5 id="toc_670">代码工具插件</h5>

<table>
<thead>
<tr>
<th style="text-align: left">插件名</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">String Manipulation</td>
<td style="text-align: left">用于快速切换驼峰式命名和下划线命名</td>
</tr>
<tr>
<td style="text-align: left">GsonFormat</td>
<td style="text-align: left">用于快速格式化json数据，自动生成实体类参数</td>
</tr>
<tr>
<td style="text-align: left">Android ButterKnife Zelezny</td>
<td style="text-align: left">用于快速添加Butterknife注解</td>
</tr>
<tr>
<td style="text-align: left">Android Drawable Importer</td>
<td style="text-align: left">用于快速导入缩放图标到Android项目中</td>
</tr>
<tr>
<td style="text-align: left">Android Parcelable code generator</td>
<td style="text-align: left">用于快速实现Parcelable 接口</td>
</tr>
<tr>
<td style="text-align: left">Android Postfix completion</td>
<td style="text-align: left">用于根据后缀快速完成代码</td>
</tr>
<tr>
<td style="text-align: left">AndroidAccessors</td>
<td style="text-align: left">用于快速实现get和set方法的插件</td>
</tr>
<tr>
<td style="text-align: left">Android Postfix Completion</td>
<td style="text-align: left">用于快速编写Toast，Log，isEmpty,FindView等代码</td>
</tr>
<tr>
<td style="text-align: left">JavaDoc</td>
<td style="text-align: left">用于快速生成Java注释，可自定义模板</td>
</tr>
</tbody>
</table>

<h5 id="toc_671">检查工具插件</h5>

<table>
<thead>
<tr>
<th style="text-align: left">插件名</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">CheckStyle-IDEA</td>
<td style="text-align: left">用于检查Java源代码是否符合编码规则</td>
</tr>
<tr>
<td style="text-align: left">FindBugs-IDEA</td>
<td style="text-align: left">用于检查Java代码中潜在的问题</td>
</tr>
<tr>
<td style="text-align: left">MetricsReloaded</td>
<td style="text-align: left">用于检查代码复杂度</td>
</tr>
</tbody>
</table>

<h5 id="toc_672">其他常用插件</h5>

<table>
<thead>
<tr>
<th style="text-align: left">插件名</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Android WiFi Adb</td>
<td style="text-align: left">用于通过WIFI连接ADB，不需要root</td>
</tr>
<tr>
<td style="text-align: left">ADB Idea</td>
<td style="text-align: left">用于在Android Studio中可视化使用ADB命令</td>
</tr>
<tr>
<td style="text-align: left">RESTClient</td>
<td style="text-align: left">用于测试RESTful web services</td>
</tr>
<tr>
<td style="text-align: left">JSONOnlineViewer</td>
<td style="text-align: left">用于直接在Android Studio中调试接口数据</td>
</tr>
<tr>
<td style="text-align: left">jimu Mirror</td>
<td style="text-align: left">用于在真机上快速测试布局</td>
</tr>
<tr>
<td style="text-align: left">Codota</td>
<td style="text-align: left">用于搜索Android代码实例</td>
</tr>
<tr>
<td style="text-align: left">Genymotion</td>
<td style="text-align: left">用于使用Genymotion运行和调试应用</td>
</tr>
</tbody>
</table>

<h3 id="toc_673">编译和构建</h3>

<h4 id="toc_674">设置Android Studio的内存参数</h4>

<p><strong>操作步骤</strong>: 菜单栏 -&gt; Help -&gt; Edit Custom VM Options</p>

<h4 id="toc_675">设置自动编译项目</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Compiler -&gt; 勾选【Make project automatically】</p>

<h4 id="toc_676">设置并行编译</h4>

<p>想提升编译速度，可开启并行编译，这样会比单线程一次编译快很多。</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Compiler -&gt; 勾选【Compile independent modules in parallel】</p>

<h4 id="toc_677">调整编译内存大小</h4>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Compiler -&gt; 在【Command-line Options】中输入调整的内存参数</p>

<h4 id="toc_678">Gradle离线工作</h4>

<p>每次打开项目或者导入项目，Android Studio总会联网检查依赖的文件是否已经下载，是否有新版本，这样会导致速度很慢。如果我们清楚依赖的文件已经下载且不想更新到最新版本，可以使用Gradle离线工作模式</p>

<p><strong>操作步骤</strong>: 偏好设置 -&gt; Build,Execution,Deployment -&gt; Build Tools -&gt; Gradle -&gt; 勾选【Offline work】</p>

<p>如果使用离线工作模式可能导致项目报错，这时可以单击同步项目: Sync Project with Gradle Files</p>

<h2 id="toc_679">参考资料</h2>

<p>《精通Android Studio》</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/4/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872930.html">
                
                  <h1>第三方库使用笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>项目开发中总是使用以及接入第三方库，记录一下使用过程，以及其中所遇到的问题，方便以后更加有效率的开发。</p>

<h2 id="toc_1">Bugly</h2>

<h3 id="toc_2">简介</h3>

<p>Bugly，属于腾讯，为移动开发者提供专业的异常上报和运营统计，帮助开发者快速发现并解决异常，同时掌握产品运营动态，及时跟进用户反馈。主要用来处理Bug反馈以及轻量运营管理。<a href="https://bugly.qq.com/v2/index">地址</a></p>

<h3 id="toc_3">集成操作</h3>

<p><a href="https://bugly.qq.com/v2/sdkDownload">SDK</a><br/><br/>
<a href="https://bugly.qq.com/docs">文档</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/3/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872872.html">
                
                  <h1>Kotlin学习笔记</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Kotlin语言从问世到现在已经有很久的时间了，2017年终于Google将Kotlin列为开发Android应用的一级语言。而且Kotlin和Java具有高度可互操作性，并且相较于Java更加简单，精炼，还添加了Java在Android中尚不支持的一些必备功能。学习Kotlin与时俱进是必须的。</p>

<h2 id="toc_1">Kotlin语言基础</h2>

<h3 id="toc_2">变量</h3>

<ul>
<li>var是可写的，在其生命周期中可以被多次赋值</li>
<li>val是只读的，仅能赋值一次</li>
<li>变量类型在大部分情况下无需申明</li>
<li>is 运算符可以对变量的类型进行判断，并且检测之后的分支中可以直接当做该类型使用，无需显式转换</li>
<li>三重引号内可以完整的输出原生字符串的格式</li>
<li>流程控制语句
<ul>
<li>分支语句（if,when）
<ul>
<li>if是一个表达式，可以将代码块的最后一行作为其返回值</li>
<li>如果if表达式只有一个分支，或者分支的结果是Unit，它的值就是Unit</li>
<li>when表达式类似switch-case表达式，可以用任意表达式作为判断条件，也可以检测（in）或者（!in）在一个区间中</li>
</ul></li>
<li>循环语句（for,while）
<ul>
<li>for循环可以对任何提供迭代器的对象进行遍历</li>
<li>for循环通过索引遍历一个数组或者一个list，可以<code>for(i in array.indices) print(array[i])</code></li>
<li>for循环可以使用库函数withIndux操作<code>for((index,value) in array.withIndex()) println(&quot;the element at $index is $value&quot;)</code></li>
</ul></li>
<li>跳转语句（break,continue,return,throw）
<ul>
<li>标签(abc@)可以定义跳转语句，直接跳转到标签位置</li>
</ul></li>
</ul></li>
</ul>

<h3 id="toc_3">修饰符</h3>

<ul>
<li>modifiers
<ul>
<li>(modifier | annotations)*</li>
</ul></li>
<li>typeModifiers
<ul>
<li>(suspendModifier | annotations)*</li>
</ul></li>
<li>modifier
<ul>
<li>classModifier</li>
<li>accessModifier</li>
<li>varianceAnnotation</li>
<li>memberModifier</li>
<li>parameterModifier</li>
<li>typeParameterModifier</li>
<li>functionModifier</li>
<li>propertyModifier</li>
</ul></li>
<li>classModifier 类修饰符
<ul>
<li>abstract 抽象类</li>
<li>final 不可被继承final类</li>
<li>enum 枚举类</li>
<li>open 可继承open类</li>
<li>annotation 注解类</li>
<li>sealed 密封类</li>
<li>data 数据类</li>
</ul></li>
<li>memberModifier
<ul>
<li>override 重写函数</li>
<li>open 可被重写</li>
<li>final 不可被重写</li>
<li>abstract 抽象函数</li>
<li>lateinit 后期初始化</li>
</ul></li>
<li>accessModifier 访问权限控制，默认是public
<ul>
<li>private</li>
<li>protected</li>
<li>public</li>
<li>internal</li>
</ul></li>
<li>varianceAnnotation 泛型可变类
<ul>
<li>in</li>
<li>out</li>
</ul></li>
<li>parameterModifier
<ul>
<li>noinline</li>
<li>crossinline</li>
<li>vararg 变长参数</li>
</ul></li>
<li>typeParameterModifier
<ul>
<li>reified</li>
</ul></li>
<li>functionModifier
<ul>
<li>tailrec 尾递归</li>
<li>operator</li>
<li>infix</li>
<li>inline</li>
<li>external</li>
<li>suspendModifier</li>
</ul></li>
<li>propertyModifier
<ul>
<li>const</li>
</ul></li>
<li>suspendModifier
<ul>
<li>suspend</li>
</ul></li>
</ul>

<h3 id="toc_4">关键字</h3>

<h4 id="toc_5">this关键字</h4>

<ul>
<li>在类的成员中，this指的是该类的对象</li>
<li>在扩展函数或者带接收者的函数字面值中，this表示在点左侧传递的接收者参数</li>
<li>在内部类中，它指的是最内层的包含它的作用域，如果我们想要引用其他作用域中的this，可以使用this@lable标签</li>
</ul>

<h4 id="toc_6">super关键字</h4>

<ul>
<li>super关键字持有指向其父类的引用</li>
</ul>

<h3 id="toc_7">操作符</h3>

<ul>
<li><p>重载操作符</p>
<ul>
<li>重载操作符的函数需要用operator修饰符标记</li>
<li>中缀操作符的函数使用infix修饰符标记 </li>
</ul></li>
<li><p>相等与不相等操作符</p>
<ul>
<li>引用相等 === !== ( 两个引用指向同一个对象 ) 如果a和b指向同一个对象，则a===b为true</li>
<li>结构相等 == != （ 使用equals()判断 ）<code>a==b --&gt; a?.equals(b)?:(b===null)</code></li>
</ul></li>
<li><p>Elvis操作符?:（二元运算符）</p>
<ul>
<li>Elvis操作符特定是跟null比较，主要用来作null安全检查。</li>
<li>Kotlin没有<code>true?1:0</code>三元运算符，取而代之是<code>if(true) 1 else 0</code></li>
</ul></li>
</ul>

<h3 id="toc_8">扩展函数和扩展属性</h3>

<ul>
<li>扩展函数
<ul>
<li><code>fun String.notEmpty():Boolean { return !this.isEmpty()}</code></li>
<li>this关键字在扩展函数内部对应到接收者对象</li>
</ul></li>
<li>扩展属性
<ul>
<li>扩展没有实际的将成员插入类中，它的行为只能由显式提供的getters/setters表示</li>
</ul></li>
</ul>

<h3 id="toc_9">空指针安全</h3>

<ul>
<li><code>?.</code>安全调用
<ul>
<li>如果变量为null，则返回null。</li>
</ul></li>
<li><code>!!.</code>非空断言调用
<ul>
<li>如果变量为null，则抛出kotlin.KotlinNullPointerException异常</li>
</ul></li>
</ul>

<h3 id="toc_10">标准库API</h3>

<h4 id="toc_11">Java和JS共用的公共库</h4>

<table>
<thead>
<tr>
<th style="text-align: left">包名</th>
<th style="text-align: left">功能说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">kotlin</td>
<td style="text-align: left">核心函数和数据类型，支持所有平台</td>
</tr>
<tr>
<td style="text-align: left">kotlin.annotation</td>
<td style="text-align: left">为kotlin注解功能提供支持</td>
</tr>
<tr>
<td style="text-align: left">kotlin.collections</td>
<td style="text-align: left">集合类型，入Iterable、Collection、List、Set、Map等</td>
</tr>
<tr>
<td style="text-align: left">kotlin.comparisons</td>
<td style="text-align: left">帮助函数用于创建Comparator比较器实例</td>
</tr>
<tr>
<td style="text-align: left">kotlin.coroutines.experimental(1.1)</td>
<td style="text-align: left">支持协程，包括支持延迟序列(lazy sequence)等</td>
</tr>
<tr>
<td style="text-align: left">kotlin.coroutines.experimental.intrinsics(1.1)</td>
<td style="text-align: left">基于协程的API库的底层构建块</td>
</tr>
<tr>
<td style="text-align: left">kotlin.experimental(1.1)</td>
<td style="text-align: left">实验API，将来版本可能会改变</td>
</tr>
<tr>
<td style="text-align: left">kotlin.io</td>
<td style="text-align: left">IO API用于处理文件和流</td>
</tr>
<tr>
<td style="text-align: left">kotlin.properties</td>
<td style="text-align: left">代理/委托属性的标准实现，帮助函数实现自定义代理/委托</td>
</tr>
<tr>
<td style="text-align: left">kotlin.ranges</td>
<td style="text-align: left">范围/区间，数列Progressions和相关扩展功能</td>
</tr>
<tr>
<td style="text-align: left">kotlin.reflect</td>
<td style="text-align: left">Kotlin反射的运行时API</td>
</tr>
<tr>
<td style="text-align: left">kotlin.sequences</td>
<td style="text-align: left">序列类型表示延迟求值的集合、实例化序列和扩展函数</td>
</tr>
<tr>
<td style="text-align: left">kotlin.text</td>
<td style="text-align: left">处理文本和正则表达式的函数</td>
</tr>
</tbody>
</table>

<h4 id="toc_12">Java平台的Kotlin库</h4>

<table>
<thead>
<tr>
<th style="text-align: left">包名</th>
<th style="text-align: left">功能说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">kotlin.concurrent</td>
<td style="text-align: left">并发（concurrent）编程Kotlin函数库</td>
</tr>
<tr>
<td style="text-align: left">kotlin.jvm</td>
<td style="text-align: left">Java平台特有的函数和注解</td>
</tr>
<tr>
<td style="text-align: left">kotlin.reflect.full(1.1)</td>
<td style="text-align: left">Kotlin反射库的扩展Extensions</td>
</tr>
<tr>
<td style="text-align: left">kotlin.reflect.jvm</td>
<td style="text-align: left">Kotlin与Java反射的互操作运行时API</td>
</tr>
<tr>
<td style="text-align: left">kotlin.streams(1.1,JRE8)</td>
<td style="text-align: left">处理Java8流的Kotlin函数库</td>
</tr>
<tr>
<td style="text-align: left">kotlin.system</td>
<td style="text-align: left">与系统相关的Kotlin函数库</td>
</tr>
</tbody>
</table>

<h4 id="toc_13">JavaScript平台的Kotlin库</h4>

<table>
<thead>
<tr>
<th style="text-align: left">包名</th>
<th style="text-align: left">功能说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">kotlin.browser</td>
<td style="text-align: left">在浏览器环境下访问顶层属性（如document、Window等）</td>
</tr>
<tr>
<td style="text-align: left">kotlin.dom</td>
<td style="text-align: left">处理浏览器DOM的Kotlin函数库</td>
</tr>
<tr>
<td style="text-align: left">kotlin.js</td>
<td style="text-align: left">JavaScript平台特有的一些函数和API</td>
</tr>
<tr>
<td style="text-align: left">org.khronos.webgl</td>
<td style="text-align: left">WebGL API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom</td>
<td style="text-align: left">DOM API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.css</td>
<td style="text-align: left">DOM CSS API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.events</td>
<td style="text-align: left">DOM events API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.parsing</td>
<td style="text-align: left">DOM parsing API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.svg</td>
<td style="text-align: left">DOM SVG API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.dom.url</td>
<td style="text-align: left">DOM URL API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.xhr</td>
<td style="text-align: left">XML HttpRequest API 的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.files</td>
<td style="text-align: left">W3C file API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.notifications</td>
<td style="text-align: left">Web Notification API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.performance</td>
<td style="text-align: left">Navigation Timing API的Kotlin包装器</td>
</tr>
<tr>
<td style="text-align: left">org.w3c.workers</td>
<td style="text-align: left">Web Workers API的Kotlin包装器</td>
</tr>
</tbody>
</table>

<h2 id="toc_14">基本数据类型与类型系统</h2>

<p>Kotlin是一门强类型、静态类型、支持隐士类型的显式类型语言。</p>

<ul>
<li>强类型：在运行时确保不会发生未经明确转换的类型转换。（一个语言的编译器引入越多的类型检查的限制，就可以称这个语言的类型检查越强）</li>
<li>静态类型：静态类型检查能让很多bug在编码早期就被捕捉到，并且它也能优化运行。（类型检查可发生在编译时期（静态检查）或运行时期（动态检查））</li>
<li>显式类型：定义变量时显式给出变量的类型（根据变量名是否需要显式给出类型的声明，分为显式类型语言和隐式类型语言）</li>
</ul>

<h3 id="toc_15">根类型 Any</h3>

<p>Kotlin中所有类都有一个共同的超类Any，同Java中java.lang.Object</p>

<h3 id="toc_16">基本类型</h3>

<p>Kotlin中一切皆是对象，所有类型都是引用类型。</p>

<h4 id="toc_17">数字类型（Number）</h4>

<table>
<thead>
<tr>
<th style="text-align: left">类型</th>
<th style="text-align: left">宽度(Bit)</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Double</td>
<td style="text-align: left">64</td>
</tr>
<tr>
<td style="text-align: left">Float</td>
<td style="text-align: left">32</td>
</tr>
<tr>
<td style="text-align: left">Long</td>
<td style="text-align: left">64</td>
</tr>
<tr>
<td style="text-align: left">Int</td>
<td style="text-align: left">32</td>
</tr>
<tr>
<td style="text-align: left">Short</td>
<td style="text-align: left">16</td>
</tr>
<tr>
<td style="text-align: left">Byte</td>
<td style="text-align: left">8</td>
</tr>
</tbody>
</table>

<ul>
<li>这些内置的数据类型，都继承了Number和Comparable类。</li>
<li>Kotlin的数字类型与Java基本相同。但Kotlin对于数字没有隐式拓宽转换（如Java中int可以隐式转换为long），因为值范围较小类型并不是较大类型的子类型。</li>
<li>val i: Int = b.toInt()
<ul>
<li>toDouble() : Double</li>
<li>toFloat() : Float</li>
<li>toLong() : Long</li>
<li>toInt() : Int</li>
<li>toChar() : Char</li>
<li>toShort() : Short</li>
<li>toByte() : Byte</li>
</ul></li>
<li>位运算，没有特殊字符来表示，只可用中缀方式调用命名函数</li>
</ul>

<p>位运算列表（只用于Int和Long）</p>

<ul>
<li>shl(bits)————有符号左移（Java的&lt;&lt;）</li>
<li>shr(bits)————有符号右移（Java的&gt;&gt;）</li>
<li>ushr(bits)————无符号右移（Java的&gt;&gt;&gt;）</li>
<li>and(bits)————位与</li>
<li>or(bits)————位或</li>
<li>xor(bits)————位异或</li>
<li>inv()————位非</li>
</ul>

<h4 id="toc_18">布尔类型</h4>

<ul>
<li>！逻辑非：not()</li>
<li>&amp;&amp;短路逻辑与：and()</li>
<li>||短路逻辑或：or()</li>
<li>异或（相同false，不同true）：xor</li>
</ul>

<h4 id="toc_19">字符串类型</h4>

<ul>
<li>索引运算符s[i]： 字符串元素————字符可以使用索引运算符s[i]来访问</li>
<li>for循环迭代字符串</li>
<li>字符串类重载了+操作符，作用对象可以是任何对象，包括null</li>
<li>截取字符串的子串（subSequence(0,1)）</li>
<li>trimMargin(marginPrefix:String = &quot;|&quot;):去除默认为边界字符为&quot;|&quot;的前导空格</li>
<li>trimIndent():把字符串行左边空白对齐切割</li>
<li>以美元符(\()开头做字符串模板:`val str = &quot;\)s.length is ${s.length}&quot;`</li>
</ul>

<h4 id="toc_20">数组类型</h4>

<ul>
<li>数组在Kotlin中使用Array类表示，定义了get和set函数以及size属性。<br/></li>
<li>可以使用arrayOf()来创建一个数组并传递元素值给Array</li>
<li>Kotlin还允许不同类型元素放到一个数组中</li>
<li>arrayOfNulls()可以用于创建一个指定大小、元素都为空的数组。这个特殊的空数组在创建时，需要指定元素的类型。<code>arrayOfNulls&lt;Int&gt;(10)</code></li>
<li>数组Array类还提供了一个构造函数<code>public inline constructor(size:Int,init:(Int) -&gt; T)</code>  例：<code>val square = Array(10,{i -&gt; (i*i)})</code></li>
<li>[]运算符代表调用成员函数get()和set()</li>
<li>原生数组类型
<ul>
<li>BooleanArray ———— booleanArrayOf(vararg elements: Boolean)</li>
<li>ByteArray ———— byteArrayOf(vararg elements: Byte)</li>
<li>CharArray ———— charArrayOf(vararg elements: Char)</li>
<li>ShortArray ———— shortArrayOf(vararg elements: Short)</li>
<li>IntArray ———— intArrayOf(vararg elements: Int)</li>
<li>LongArray ———— longArrayOf(vararg elements: Long)</li>
<li>FloatArray ———— floatArrayOf(vararg elements: Float)</li>
<li>DoubleArray ———— doubleArrayOf(vararg elements: Double)</li>
</ul></li>
</ul>

<h3 id="toc_21">可空类型</h3>

<ul>
<li>null 是 Nothing? 类型的</li>
<li>Any?是Kotlin的类型层次结构的最顶端</li>
</ul>

<h3 id="toc_22">Kotlin.Unit类型</h3>

<p>Kotlin中的Unit类型实现了与Java中的void一样的功能。当一个函数没有返回值时，我们用Unit来实现这个特征，而不是null</p>

<h3 id="toc_23">kotlin.Nothing类型</h3>

<p>在Kotlin类型层次结构的最底层就是类型Nothing</p>

<h3 id="toc_24">类型检测与类型转换</h3>

<h4 id="toc_25">is与!is运算符</h4>

<ul>
<li>is运算符类似于Java的instanceOf，用来检查对象是否属于某数据类型</li>
<li>is会自动对对象的数据类型进行安全的转换</li>
</ul>

<h4 id="toc_26">as运算符</h4>

<ul>
<li>as运算符用于执行引用类型的显式类型转换。如果兼容则转换成功，否则as?运算符返回null，as抛出异常</li>
</ul>

<h2 id="toc_27">集合类</h2>

<p>世间本无集合；<br/><br/>
有人想要，于是就用数组创造了集合类；<br/><br/>
有人想要可以自动扩展容量的数组，于是有了List；<br/><br/>
有人想要元素不重复的数组，于是有了Set；<br/><br/>
有人想要有序的数组，于是有了TreeSet，TreeList；<br/><br/>
有人想要通过复杂对象来查找另一个对象的关联数组，于是有了Map；</p>

<ul>
<li>几乎所有集合都是基于数组来实现的，所以数组比集合要快</li>
<li>集合是数组的高层次的抽象封装，集合的功能比数组要多</li>
<li>Kotlin集合类分为：可变集合类(Mutable)和不可变集合类(Immutable)</li>
<li>集合类型主要有3种：list(列表)、set(集)、map(映射)</li>
</ul>

<h3 id="toc_28">List</h3>

<p>List接口继承与Collectio接口，元素以线性方式存储，集合中可以存放重复对象。</p>

<ul>
<li><strong>不可变集合类List(ReadOnly,Immutable)</strong>:
<ul>
<li>使用listOf()函数来创建没有元素的空List</li>
<li>使用listOf(element: T)函数来创建只有一个元素的List</li>
<li>使用listOf(vararg elements: T)函数来创建有多个元素的List</li>
<li>asList()是Array的扩展函数</li>
<li>arrayListOf()函数可以直接创建一个Java中的ArrayList对象实例</li>
</ul></li>
<li><strong>可变集合MutableList</strong>
<ul>
<li>新增了add/addAll,remove/removeAll/removeAt,set,clear,retainAll</li>
<li>mutableListOf()函数来创建</li>
<li>mutableListOf()函数和直接使用arrayListOf()函数一样都是创建了一个ArrayList类</li>
<li>不可变的List可以通过调用转换函数toMutableList()来将其转换成可变的List</li>
</ul></li>
<li><strong>遍历List元素</strong>
<ul>
<li>使用Iterator迭代器（Kotlin中的Iterator功能比较简单，并且只能单向移动）
<ul>
<li>调用iterator()函数，容器返回一个Iterator实例</li>
<li>调用hasNext()函数检查序列中是否还有元素</li>
<li>第一次调用next()函数，返回序列的第一个元素，依次向后递推   - 使用forEach遍历List元素</li>
<li><code>list.forEach({println(it)})</code> </li>
</ul></li>
</ul></li>
<li><strong>List元素操作函数</strong>
<ul>
<li>add/remove 是MutableList的
<ul>
<li>添加一个元素<code>mutableList.add(4)</code></li>
<li>在下标为0的位置添加元素0<code>mutableList.add(0,0)</code></li>
<li>删除元素1<code>mutableList.remove(1)</code></li>
<li>删除下标为1的元素<code>mutableList.removeAt(1)</code></li>
<li>删除子集合<code>mutableList.removeAll(listOf(3,4))</code></li>
<li>添加子集合<code>mutableList.addAll(listOf(1,2,3))</code></li>
</ul></li>
<li>set/clear操作
<ul>
<li>更新设置下标为0的元素值为100<code>mutableList.set(0,100)</code></li>
<li>清空集合<code>mutableList.clear()</code></li>
<li>把可变集合转为不可变集合<code>mutableList.toList()</code></li>
</ul></li>
<li><code>retainAll</code>
<ul>
<li>取两个集合交集<code>mList1.retainAll(mList2)</code></li>
</ul></li>
<li><code>contains(element:T) Boolean</code>
<ul>
<li>判断集合中是否有指定元素<code>list.contains(1)</code></li>
</ul></li>
<li><code>elementAt(index: Int): T</code>
<ul>
<li>查找下标对应的元素<code>list.elementAt(6)</code></li>
<li>查找下标对应元素，如果越界根据方法返回默认值<code>list.elementAtOrElse(7,{0})</code></li>
<li>查找下标对应元素，如果越界就返回null<code>list.elementAtOrNull(7)</code></li>
</ul></li>
<li><code>first()</code>
<ul>
<li>返回集合第一个元素，如果是空集，抛出异常 <code>list.first()</code></li>
<li>对应的有针对异常处理的函数firstOrNull():T? <code>emptyList.firstOrNull()</code></li>
<li>返回符合条件的第一个元素，没有则抛出异常 <code>list.first(it % 2 == 0)</code></li>
<li>对应的有针对异常处理的函数firstOrNull(oerducate:(T)-&gt;Boolean):T?返回符合条件的第一个元素，没有就返回nul<code>list.firstOrNull({it &gt; 100})</code></li>
</ul></li>
<li><code>indexOf(element: T): Int</code>
<ul>
<li>返回指定下标的元素，没有就返回-1 <code>list.indexOf(&quot;c&quot;)</code></li>
</ul></li>
<li><code>indexOfFirst(predicate:(T) -&gt; Boolean):Int</code>
<ul>
<li>返回第一个符合条件的元素下标，没有就返回-1 <code>list.indexOfFirst({it.contains(&quot;x&quot;)})</code></li>
</ul></li>
<li><code>indexOfLast(predicate:(T) -&gt; Boolean):Int</code>
<ul>
<li>返回最后一个符合条件的元素下标，没有就返回-1 <code>list.indexOfLast(it.contains(&quot;k&quot;))</code></li>
</ul></li>
<li><code>last()</code>
<ul>
<li>返回集合最后一个元素，空集抛出异常 <code>list.last()</code></li>
</ul></li>
<li><code>last(predicate:(T) -&gt; Boolean): T</code>
<ul>
<li>返回符合条件的最后一个元素，没有就抛出异常 <code>list.last({it &gt; 10})</code></li>
<li>对应的针对越界处理的lastOrNull函数，返回符合条件的最后一个元素，没有则返回null <code>list.lastOrNull({it &gt; 10})</code></li>
</ul></li>
<li><code>lastIndexOf(element: T): Int</code>
<ul>
<li>返回符合条件的最后一个元素，没有就返回-1 <code>list.lastIndexOf(&quot;abc&quot;)</code></li>
</ul></li>
<li><code>single(): T</code>
<ul>
<li>该集合如果只剩下一个元素，则返回该元素，否则抛出异常 <code>list.single()</code></li>
</ul></li>
<li><code>single(predicate: (T) -&gt; Boolean): T</code>
<ul>
<li>返回符合条件的单个元素，否则抛出异常，或超过一个的抛异常 <code>list.single({it == 1})</code></li>
<li>对应的针对越界处理的singleOrNull函数，返回符合条件的单个元素，否则返回null <code>list.singleOrNull({it == 7})</code></li>
</ul></li>
</ul></li>
<li><strong>List集合的基本运算函数</strong>
<ul>
<li><code>any()</code>
<ul>
<li>判断该元素至少有一个元素 <code>list.any()</code></li>
</ul></li>
<li><code>any(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>判断集合中是否有满足条件的元素 <code>list.any({list &gt; 4})</code></li>
</ul></li>
<li><code>all(predicate: (T) -&gt; Boolean)</code>
<ul>
<li>判断集合中的元素是否都满足条件，当且仅当该集合中的所有元素都满足条件时，返回true。 <code>list.all({it &gt; 2})</code></li>
</ul></li>
<li><code>none()</code>
<ul>
<li>判断集合无元素，该集合没有任何元素，返回true <code>list.none()</code></li>
</ul></li>
<li><code>none(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>判断集合中所有元素都不满足条件 <code>list.none({it % 2 == 1})</code></li>
</ul></li>
<li><code>count()</code>
<ul>
<li>计算集合中的元素的个数 <code>list.count()</code></li>
</ul></li>
<li><code>count(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>计算集合中满足条件的元素的个数 <code>list.count({it % 2 == 0})</code></li>
</ul></li>
<li><code>reduce</code>
<ul>
<li>从第一想到最后一项进行累计运算，首先把第一个元素赋值给累加子accumulator,然后逐次向后取元素累加，新值继续赋值给累加子accumulator = operation(accumulator,iterator.next())，依次类推，最后返回累加子的值 <code>list.reduce({total,s -&gt; total + s})</code></li>
</ul></li>
<li><code>reduceRight</code>
<ul>
<li>从最后一项到第一项进行累计运算，从右边累计运算的累加子是放在后面的 <code>list.reduceRight({total,s -&gt; s + total})</code></li>
</ul></li>
<li><code>fold(initial:R,operation:(acc:R,T)-&gt;R):R</code>
<ul>
<li>是带初始值的reduce，fold函数给累加子赋了初始值initial <code>list.fold(100,{total,next -&gt; next + total})</code></li>
<li>foldRight 和 reduceRight类似，有初始值</li>
</ul></li>
<li><code>forEach(action:(T) -&gt; Unit):Unit</code>
<ul>
<li>循环遍历元素，元素是it <code>list.forEach{value -&gt; if (value &gt; 7) println(value)}</code></li>
</ul></li>
<li><code>forEachIndexed</code>
<ul>
<li>带index(下标)的元素遍历 <code>list.forEachIndexed(index,value -&gt; if(value &gt; 8) println(&quot;value of index $index is $value,greater than 8&quot;))</code></li>
</ul></li>
<li><code>max</code>、<code>min</code>
<ul>
<li>查询最大、最小的元素，空集返回null <code>list.max()</code></li>
</ul></li>
<li><code>maxBy(selector:(T)-&gt;R):T?、minBy(selector:(T)-&gt;R):T?</code>
<ul>
<li>获取函数映射结果的最大值、最小值对应的那个元素的值，如果没有则返回null。是通过selector函数的返回值来比较大小，获取最终的最大值和最小值。 <code>list.maxBy({it * (1 - it)})</code></li>
</ul></li>
<li><code>sumBy(selector:(T) -&gt; Int):Int</code>
<ul>
<li>获取函数映射值的总和 <code>list.sumBy({it * it})</code></li>
</ul></li>
</ul></li>
<li>过滤操作函数
<ul>
<li><code>take(n:Int):List&lt;T&gt;</code>
<ul>
<li>挑出该集合前n个元素的子集合，如果n=0，返回空集，如果n大于集合size，返回该集合。<code>list.take(10)</code></li>
</ul></li>
<li><code>takeWhile(predicate:(T) -&gt; Boolean):List&lt;T&gt;</code>
<ul>
<li>挑出满足条件的元素的子集合，从第一个元素开始，判断是否满足predicate为true，如果满足条件的元素就丢到返回ArrayList中，只要遇到任何一个不满足条件，就结束循环，返回list。 <code>list.takeWhile({it % 2 == 0})</code></li>
<li><code>takeLast</code>
<ul>
<li>挑出最后n个元素的子集合，从集合倒数n个元素起，取出到最后一个元素的子集合。如果传入0，返回空集。如果传入n大于集合size，返回整个集合。如果传入负数，抛出异常。<code>list.takeLast(2)</code></li>
</ul></li>
</ul></li>
<li><code>takeLastWhile(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>从最后开始挑出满足条件元素的子集合。反向取满足条件的元素，遇到不满足的元素，直接终止循环，并返回子集合。 <code>list.takeLastWhile({it % 2 == 0})</code></li>
</ul></li>
<li><code>drop(n:Int)</code>
<ul>
<li>去除前n个元素返回剩下的元素的子集合 <code>list.drop(5)</code></li>
</ul></li>
<li><code>dropWhile(predicate:(T)-&gt;Boolean)</code>
<ul>
<li>去除满足条件的元素返回剩下的元素的子集合。去除满足条件的元素，当遇到一个不满足条件的元素时，中止操作，返回剩下的元素子集合。 <code>list.dropWhile({it % 2 == 0})</code></li>
</ul></li>
<li><code>dropLast(n:Int)</code>
<ul>
<li>从最后去除n个元素 <code>list.dropLast(3)</code></li>
</ul></li>
<li><code>dropLastWhile(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>从最后去除满足条件的元素 <code>list.dropLastWhile({it % 2 == 0})</code></li>
</ul></li>
<li><code>slice(indices:IntRange)</code>
<ul>
<li>取开始下标至结束下标元素子集合 <code>list.slice(1..3)</code></li>
</ul></li>
<li><code>slice(indices:Iterable&lt;Int&gt;)</code>
<ul>
<li>返回指定下标的元素子集合 <code>list.slice(listOf(2,4,6))</code></li>
</ul></li>
<li><code>filterTo(destination:C,predicate:(T) -&gt; Boolean)</code>
<ul>
<li>过滤出满足条件的元素并赋值给destination。把满足过滤条件的元素组成的子集合赋值给入参destination。 <code>list.filterTo(dest,{it &gt; 3})</code></li>
</ul></li>
<li><code>filter(predicate:(T)-&gt;Boolean)</code>
<ul>
<li>过滤出满足条件的元素组成的子集合。相对于filterTo函数，filter函数更加简单易用。 <code>list.filter({it &gt; 3})</code></li>
</ul></li>
<li><code>filterNot(predicate:(T) -&gt; Boolean)</code>
<ul>
<li>用来过滤所有不满足条件的元素</li>
</ul></li>
<li><code>filterNotNull()</code>
<ul>
<li>过滤掉null元素</li>
</ul></li>
</ul></li>
<li><strong>映射操作函数</strong>
<ul>
<li><code>map(transform:(T)-&gt;R):List&lt;R&gt;</code>
<ul>
<li>将集合中的元素通过转换函数transform映射后的结果，存到一个集合中返回。 <code>list.map({it * it})</code></li>
</ul></li>
<li><code>mapIndexed(transform:(kotlin.Int,T) -&gt; R)</code>
<ul>
<li>转换函数transform中带有下标参数。可以同时使用下标和元素的值来进行转换。 <code>list.mapIndexed({index,it -&gt; index * it})</code></li>
</ul></li>
<li><code>mapNotNull(transform:(T) -&gt; R?)</code>
<ul>
<li>遍历集合每个元素，得到通过函数算子transform映射之后的值，剔除掉这些值中的null，返回一个无null元素的集合。 <code>list.mapNotNull({it})</code> </li>
</ul></li>
<li><code>flatmap(transform:(T)-&gt;Iterable&lt;R&gt;):List&lt;R&gt;</code>
<ul>
<li>在原始集合的每个元素上调用transform转换函数，得到的映射结果组成的单个列表。与map相比，使用map是把list中的每一个元素都映射成一个List-n,然后以这些List-n为元素，组成一个大的嵌套的List返回。而使用flatMap则是把list中的第一个元素映射成一个List1，然后把第二个元素映射成的List2跟List1合并，最终返回一个扁平的List。</li>
</ul></li>
</ul></li>
<li><strong>分组操作函数</strong>
<ul>
<li>groupBy(keySelector:(T) -&gt; K):Map<K,List<T>&gt;
<ul>
<li>将集合中的元素按照条件选择器keySelector分组，并返回Map。<code>words.groupBy({it.length},{it.contains(&quot;b&quot;)})</code></li>
</ul></li>
<li>groupingBy(crossinline keySelector:(T)-&gt;K):Grouping<T,K>
<ul>
<li>可以通过该函数来创建一个Grouping,然后调用计数函数eachCount统计分组 <code>words.groupingBy({it.first()}).eachCount()</code></li>
</ul></li>
</ul></li>
<li><strong>排序操作符</strong>
<ul>
<li><code>reversed():List&lt;T&gt;</code>
<ul>
<li>倒序排列集合元素 <code>list.reversed()</code></li>
</ul></li>
<li><code>sorted</code>和<code>sortedDescending</code>
<ul>
<li>升序排序和降序排序 <code>list.sorted</code></li>
</ul></li>
<li><code>sortedBy</code>和<code>sortedByDescending</code>
<ul>
<li>可变集合MutableList的排序操作，根据函数映射的结果进行升序排序和降序排序 <code>mlist.sortBy({it.length})</code></li>
</ul></li>
</ul></li>
<li><strong>生产操作符</strong>
<ul>
<li><code>zip(other:Iterable&lt;R&gt;):List&lt;Pair&lt;T,R&gt;&gt;</code>
<ul>
<li>两个集合按照下标配对，组合成的每个Pair作为新的List集合中的元素，并返回。如果两个集合长度不一样，取短的长度。 <code>list1.zip(list2)</code></li>
</ul></li>
<li><code>partition(predicate:(T)-&gt;Boolean:Pair&lt;List&lt;T&gt;,List&lt;T&gt;&gt;)</code>
<ul>
<li>根据判断条件是否成立，将集合拆分成两个子集合组成的Pair。 <code>list.partition({it &gt; 5})</code></li>
</ul></li>
<li><code>plus(elements:Iterable&lt;T&gt;):List&lt;T&gt;</code>
<ul>
<li>合并两个List，这是一个操作符函数，可以用“+”代替。 <code>list.plus(list2)</code> , <code>list1+list2</code></li>
</ul></li>
<li><code>list.plusElement(element:T):List&lt;T&gt;</code>
<ul>
<li>在集合中添加一个元素。 <code>list.plusElement(10)</code> , <code>list.plus(10)</code></li>
</ul></li>
</ul></li>
</ul>

<h3 id="toc_29">Set</h3>

<p>含有不可变Set和可变MutableSet(支持添加和删除)</p>

<ul>
<li><strong>空集</strong>
<ul>
<li>空集继承了Serializable，表明是可被序列化的。它的size是0，isEmpty()返回true，hashCode()是0。</li>
</ul></li>
<li><strong>创建Set</strong>
<ul>
<li><code>setOf(vararg elements:T):Set&lt;T&gt;</code> 
<ul>
<li>使用元素elements创建一个Set。Set中的元素是不可重复的。<code>toSet()</code>是Array类的扩展函数，可以将Array类转变为Set。</li>
<li>使用<code>toSet()</code>可以对List去重。</li>
<li>使用<code>emptySet&lt;Int&gt;()</code>和<code>setOf()</code>来创建空集</li>
</ul></li>
<li><code>mutableSetOf():MutableSet&lt;T&gt;</code>
<ul>
<li>创建一个可变的Set</li>
</ul></li>
</ul></li>
<li><strong>使用Java中的Set类</strong>
<ul>
<li><code>hashSetOf</code>       ——  java.util.HashSet 该类按照哈希算法来存取集合中的对象，存取速度较快</li>
<li><code>linkedSetOf()</code>   ——  java.util.LinkedHashSet </li>
<li><code>mutableSetOf()</code>  ——  java.util.LinkedHashSet 具有HashSet的查询速度，且内部使用链表维护元素的顺序，在对Set元素进行频繁插入，删除的场景中使用</li>
<li><code>sortedSetOf()</code>   ——  java.util.TreeSet 该类实现了SortedSet接口，能够对集合中的对象进行排序</li>
</ul></li>
<li><strong>Set元素中的加减操作plus minus</strong>
<ul>
<li>针对Set做了一些加减运算的扩展函数。 <code>val ms = mutableSetOf(1,3,4,7)</code> , <code>ms + 10</code> , <code>ms - 1</code></li>
</ul></li>
</ul>

<h3 id="toc_30">Map</h3>

<p>Map是一种把键对象Key和值对象Value映射的集合。它的每一个元素都包含一对键对象和值对象。  Key可以看成是Value的索引，作为key的对象在集合中不可重复。<br/><br/>
Map和Set、List一样，Map也分为只读Map和可变的MutableMap。  </p>

<ul>
<li><strong>创建Map</strong>
<ul>
<li>HashMap HashMap是基于哈希表的Map接口的实现，系统会根据hash算法来计算key-value的存储位置，可以通过key快速地存取value。它允许使用null值和null键。</li>
<li>TreeMap 使用红黑二叉树的Map接口</li>
<li>LinkedHashMap 使用链表实现，保存了记录的插入顺序。</li>
<li><code>mapOf()</code>
<ul>
<li>创建一个只读空Map <code>mapOf&lt;String,Int&gt;()</code> 和 <code>emptyMap&lt;String,Int&gt;()</code>。</li>
</ul></li>
<li><code>mapOf(pair:Pair&lt;K,V&gt;):Map&lt;K,V&gt;</code>
<ul>
<li>使用二元组Pair创建一个只读Map <code>mapOf(1 to &quot;x&quot;,2 to &quot;y&quot;,3 to &quot;z&quot;)</code></li>
<li><code>map.get(1)</code></li>
<li><code>map.size</code></li>
<li><code>map.entries</code></li>
</ul></li>
<li><code>mutableMapOf()</code>
<ul>
<li>创建一个空的可变的Map，该函数是直接调用的LinkedHashMap()构造函数</li>
</ul></li>
<li><code>mutableMapOf(vararg pairs:Pair&lt;K,V&gt;):MutableMap&lt;K,V&gt;</code>
<ul>
<li>创建一个可编辑的MutableMap对象。如果有重复的key键，后面的会直接覆盖掉前面的</li>
</ul></li>
<li><code>hashMapOf():HashMap&lt;K,V&gt;</code>
<ul>
<li>创建HashMap对象</li>
</ul></li>
<li><code>linkedMapOf():LinkedHashMap&lt;K,V&gt;</code>
<ul>
<li>创建空对象LinkedHashMap</li>
</ul></li>
<li><code>linkedMapOf(vararg pairs:Pair&lt;K,V&gt;):LinkedHashMap&lt;K,V&gt;</code>
<ul>
<li>创建带二元组Pair元素的LinkedHashMap对象</li>
</ul></li>
<li><code>sortedMapOf(vararg pairs:Pair&lt;K,V&gt;):SortedMap&lt;K,V&gt;</code>
<ul>
<li>创建一个根据Key升序排序好的TreeMap</li>
</ul></li>
</ul></li>
<li><strong>访问Map的元素</strong>
<ul>
<li>Map的元素包含的属性有entries、keys、values size，还有一个操作符Map.get(key),等同于使用Map[Key]
<ul>
<li>entries属性 可直接访问entries属性</li>
<li>keys 属性</li>
<li>values 属性</li>
<li>size 属性</li>
<li>get(key:K)——对应的操作符的<code>[]</code>。如果这个key不在Map中，就返回null。如果不想返回null，可以使用<code>getOrDefault</code>函数</li>
</ul></li>
</ul></li>
<li><strong>Map操作函数</strong>
<ul>
<li><code>containsKey(key:K):Boolean</code>
<ul>
<li>是否包含该key</li>
</ul></li>
<li><code>containsValue(value:V):Boolean</code>
<ul>
<li>是否包含该value</li>
</ul></li>
<li><code>component1() component2()</code>
<ul>
<li>Map.Entry<K,V>的操作符函数，分别用来直接访问key和value</li>
</ul></li>
<li><code>Map.Entry&lt;K,V&gt;.toPair():Pair&lt;K,V&gt;</code>
<ul>
<li>把Map的Entry转换为Pair</li>
</ul></li>
<li><code>getOrElse(key:K,defaultValue:()-&gt;V):V</code>
<ul>
<li>通过key获取值，当没有值可以设置默认值</li>
</ul></li>
<li><code>getValue(key:K):V</code>
<ul>
<li>当Map中不存在这个key，调用get函数，如果不想返回null，直接抛出异常</li>
</ul></li>
<li><code>getOrPut(key:K,defaultValue:()-&gt;V):V</code>
<ul>
<li>如果不存在这个key，就添加这个key到Map中，对应的value是defaultValue</li>
</ul></li>
<li><code>iterator():Iterator&lt;Map.Entry&lt;K,V&gt;&gt;</code>
<ul>
<li>这个函数返回的是entries.iterator()</li>
</ul></li>
<li><code>mapKeys(transform:(Map.Entry&lt;K,V&gt;)-&gt;R):Map&lt;R,V&gt;</code>
<ul>
<li>把Map的Key设置为通过转换函数transform映射之后的值 <code>map.mapKeys{it.key * 10}</code></li>
</ul></li>
<li><code>mapValues(transform:(Map.Entry&lt;K,V&gt;)-&gt;R):Map&lt;K,R&gt;</code>
<ul>
<li>对应的这个函数是把Map的value设置为通过转换函数transform转换之后的新值。 <code>map.mapValues({it.value + &quot;$&quot;})</code></li>
</ul></li>
<li><code>filterKeys(predicate:(K) -&gt; Boolean):Map&lt;K,V&gt;</code>
<ul>
<li>返回过滤出满足key判断条件的元素组成的新Map。 <code>map.filterKeys({it &gt; 0})</code></li>
</ul></li>
<li><code>filterValues(predicate:(V)-&gt;Boolean):Map&lt;K,V&gt;</code>
<ul>
<li>返回过滤出满足value判断条件的元素组成的元素组成的新Map。 <code>map.filterValues({it &gt; &quot;b&quot;})</code></li>
</ul></li>
<li><code>filter(predicate:(Map.Entry&lt;K,V&gt;)-&gt;Boolean):Map&lt;K,V&gt;</code>
<ul>
<li>返回过滤出满足Entry判断条件的元素组成的新Map。 <code>map.filter({it.key &gt; 0 &amp;&amp; it.value &gt; &quot;b&quot;})</code></li>
</ul></li>
<li><code>Iterable&lt;Pair&lt;K,V&gt;&gt;.toMap(destination:M):M</code>
<ul>
<li>把持有Pair的Iterable集合转换为Map。 <code>pairList.toMap()</code></li>
</ul></li>
<li><code>Map&lt;out K,V&gt;.toMutableMap():MutableMap&lt;K,V&gt;</code>
<ul>
<li>把一个只读的Map转换为可编辑的MutableMap。 <code>map.toMutableMap()</code></li>
</ul></li>
<li><code>put(key:K,value:V):V?</code>
<ul>
<li>根据key设置元素的value。如果该key存在就更新value，不存在就添加，但是put的返回值是null</li>
</ul></li>
<li><code>MutableMap&lt;out K,V&gt;.remove(key:K):V?</code>
<ul>
<li>根据键值key来删除元素 <code>map.remove(-1)</code></li>
</ul></li>
<li><code>MutableMap&lt;K,V&gt;.clear():Unit</code>
<ul>
<li>清空MutableMap</li>
</ul></li>
</ul></li>
</ul>

<h2 id="toc_31">泛型</h2>

<p>Java中泛型PECS(Producer Extends Consumer Super)原则。</p>

<ul>
<li>频繁往外读取内容的，适合用上界Extends —— (? extends T)</li>
<li>经常往里插入的，适合用下界Super    —— (? super T)</li>
</ul>

<h3 id="toc_32">Kotlin中的泛型</h3>

<ul>
<li>out T与in T<br/>
out T 等价于 &lt;? extends T&gt; 和 in T 等价于 &lt;? super T&gt;</li>
<li>声明处型变</li>
<li>类型投影</li>
</ul>

<h3 id="toc_33">泛型类</h3>

<pre class="line-numbers"><code class="language-text">class Box&lt;T&gt;(t:T) {
    var value = t
}
</code></pre>

<h2 id="toc_34">面向对象编程</h2>

<h3 id="toc_35">类与构造函数</h3>

<h4 id="toc_36">构造函数</h4>

<ul>
<li>主构造函数（是类头的一部分，直接放在类后面。如果没有注解或者可见性修饰符，可以省略。主构造函数不能包含任何代码，初始化代码可以放到以init关键字作为前缀的初始化）</li>
<li>次构造函数（前缀用constructor声明）</li>
<li>私有主构造函数（<code>class DontCreateMe private constructor(){}</code>）</li>
</ul>

<h4 id="toc_37">类的属性</h4>

<p>类的属性必须要初始化或者具有抽象属性，并且kotlin中类的字段自动带有getter方法和setter方法。</p>

<h3 id="toc_38">接口</h3>

<p>使用interface作为接口的关键词</p>

<h4 id="toc_39">实现接口</h4>

<p>接口是没有构造函数的。使用冒号：语法来实现一个接口，如果有多个用逗号隔开</p>

<h4 id="toc_40">覆盖冲突</h4>

<p>如果一个类从他的直接父类继承了同一个函数的多个实现，那么它必须重写这个函数并且提供自己的实现。为表示使用父类中提供的方法，我们用super关键字实现。在重写print()时，比如我们实现的ProjectService、MilestoneService都有一个print()函数，当我们直接使用super.print()时，编译器是无法知道想要调用的是哪个里面的print函数，这个我们叫做<strong>覆盖冲突</strong>。这个时候，我们使用以下语法来调用<code>super&lt;ProjectService&gt;.print()</code> 或者 <code>super&lt;MilestoneService&gt;.print()</code>。</p>

<h3 id="toc_41">抽象类和接口的差异</h3>

<h4 id="toc_42">概念上的区别</h4>

<p>接口主要是对动作的抽象，定义了行为特性的规约。<br/><br/>
抽象类是对根源的抽象。<br/><br/>
当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>

<h4 id="toc_43">语法层面上的区别</h4>

<p>接口不能保存状态，可以有属性但必须是抽象的。<br/><br/>
一个类只能继承一个抽象类，而一个类却可以实现多个接口。<br/><br/>
类如果要实现一个接口，它必须实现接口声明的所有方法。但类不可以实现抽象类声明的所有方法。<br/><br/>
接口中的所有方法隐含的都是抽象的。而抽象类则可以包含抽象和非抽象的方法。</p>

<h4 id="toc_44">设计层面上的区别</h4>

<p>抽象类是对一种事物的抽象。而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为。而接口却是对类局部行为进行抽象。</p>

<h3 id="toc_45">继承</h3>

<p>在Kotlin中，所有的类会默认继承Any整个父类，但Any并不完全等同于Java中的Object类，因为它只有equals()、hashCode()、toString()这三个方法。</p>

<h4 id="toc_46">open类</h4>

<p>除了抽象类、接口默认可以被继承，我们也可以把一个类声明为open，这样我们就可以继承这个open类。<br/><br/>
当我们想定义一个父类时，需要使用open关键字：<code>open class Base{}</code><br/><br/>
当然，抽象类是默认open的，然后在子类中使用冒号进行继承： <code>class SubClass : Base() {}</code><br/><br/>
如果父类有构造函数，那么必须在子类的主构造函数中进行继承，没有的话可以选择主构造函数或者二级构造函数。  </p>

<pre class="line-numbers"><code class="language-text">//父类
open class Base(type:String) {}
//子类
class SubClass(type:String) : Base(type) {}
</code></pre>

<p>Kotlin中的override()和Java中也有所不同，因为Kotlin提倡所有的操作都是明确的，因此需要将希望被重写的函数设为<code>open</code>,然后通过<code>override</code>标记实现重写。重写的函数也是open的，如果希望它不被重写， 可以再前面增加<code>final</code>:  </p>

<pre class="line-numbers"><code class="language-text">open class SubClass : Base {
    constructor(type:String) : super(type) {}
    final override fun doSomething() {
        super.doSomething()
    }
}
</code></pre>

<h3 id="toc_47">枚举类</h3>

<h4 id="toc_48">枚举类的基本用法</h4>

<pre class="line-numbers"><code class="language-text">enum class Direction {
    NORTH,SOUTH,WEST,EAST
}

&gt;&gt;&gt; val north = Direction.NORTH
</code></pre>

<p>每个枚举常量都是一个对象。枚举常量用逗号分隔。</p>

<h4 id="toc_49">初始化枚举值</h4>

<pre class="line-numbers"><code class="language-text">enum class Color(val rgb:Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}
</code></pre>

<p>另外，枚举常量也可以声明自己的匿名类：</p>

<pre class="line-numbers"><code class="language-text">enum class ActivityLifeState {
    onCreate {
        override fun signal() = onStart
    },
    
    onStart {
        override fun signal = onStop
    },
    
    onStop {
        override fun signal() = onStart
    },
    
    onDestroy {
        override fun signal() = onDestroy
    }
    
    abstract fun signal() : ActivityLifeState
}
</code></pre>

<h4 id="toc_50">使用枚举常量</h4>

<p>每个枚举常量，默认都有name 和 ordinal 的属性。</p>

<pre class="line-numbers"><code class="language-text">enum class RGB {RED,GREEN,BLUE}

&gt;&gt;&gt; val rgbs = enumValue&lt;RGB&gt;().joinToString {&quot;${it.name} : ${it.ordinal}&quot;}
&gt;&gt;&gt; rgbs
RED : 0 , GREEN : 1 , BLUE : 2
</code></pre>

<h3 id="toc_51">注解类</h3>

<h4 id="toc_52">元注解</h4>

<ul>
<li><code>@Target(AnnotationTarget.CLASS,AnnotationTarget.FUNCTION,AnnotationTarget.EXPRESSION,AnnotationTarget.FIELD,AnnotationTarget.LOCAL_VARIALBE,AnnotationTarget.TYPE,AnnotationTarget.TYPEALIAS,AnnotationTarget.TYPE_PARAMETER,AnnotationTarget.VALUE_PARAMETER,AnnotationTarget.CONSTRUCTOR)</code> 指定这个注解可用于哪些元素（类、函数、属性、表达式等等）</li>
<li><code>@Retention(AnnotationTarget.SOURCE)</code> 指定这个注解的信息是否被保存到编译后的class文件中，以及在运行时是否可以通过反射访问到它。</li>
<li><code>@Repeatable</code> 允许在单个元素上多次使用同一个注解</li>
<li><code>@MustBeDocumented</code> 表示这个注解是公开API的一部分，在自动产生的API文档中的类或者函数签名中，应该包含这个注解的信息</li>
</ul>

<h3 id="toc_53">单例模式</h3>

<p>Kotlin中没有“静态属性和方法”，但是也提供了实现类似于“单例”的功能</p>

<ul>
<li><code>object</code> 单例模式</li>
<li>匿名object 有时候需要的仅仅是一个简单对象，这个时候可以直接使用<code>val Porigin = object{var x = 0.0 var y = 0.0}</code></li>
<li><code>companion object</code> 伴生对象，一个类只能有一个伴生对象，伴生对象的初始化是在相应的类被加载解析时</li>
<li>如果想使用Java中的静态成员和静态方法
<ul>
<li>@JvmField注解： 生成与该属性相同的静态字段</li>
<li>@JvmStatic注解： 在单例对象和伴生对象中生成对应的静态方法</li>
</ul></li>
</ul>

<pre class="line-numbers"><code class="language-text">object User {
    val username : String = &quot;admin&quot;
    val password : String = &quot;admin&quot;
}

&gt;&gt;&gt; User.username
&gt;&gt;&gt; User.password
</code></pre>

<h3 id="toc_54">密封类</h3>

<p>sealed类是枚举类的扩展，枚举类型的值集合也是受限的，但每个枚举常量只存在一个实例，而密封类的一个子类可以有可包含状态的多个实例。要声明一个密封类，需要在类名前面添加sealed修饰符。密封类的所有子类都必须与密封类在同一个文件中声明。</p>

<p>使用密封类的主要场景是在使用when表达式的时候，能够验证语句覆盖了所有情况，而无需再添加一个else子句。</p>

<h3 id="toc_55">数据类</h3>

<p>我们写Java代码时，会经常创建一些只保存数据的类。</p>

<ul>
<li>POJO类：普通Java类，具有一部分getter/setter方法就可以被称为POJO</li>
<li>DTO类：数据传输类，泛指用于展示层与服务层之间的数据传输对象</li>
<li>VO类：ViewObject</li>
<li>PO类：持久对象，是由一组属性和属性的get和set方法组成。用来封装原始数据。</li>
<li>BO类：业务对象层，表示应用程序领域内“事物”的所有实体类。</li>
<li>DO类：领域对象，从现实世界中抽象出来的有形或无形的业务实体</li>
</ul>

<p>Kotlin中使用data前缀来构建数据类，数据类有以下限制：</p>

<ul>
<li>主构造函数需要至少有一个参数</li>
<li>主构造函数的所有参数需要标记为val或var</li>
<li>数据类不能是抽象、开放、密封或者内部的(不能用abstract、open、sealed、inner作为前缀修饰)，只能是final的</li>
</ul>

<h4 id="toc_56">数据类的解构</h4>

<p>解构相当于Component函数的逆向映射</p>

<pre class="line-numbers"><code class="language-text">val helen = User(&quot;Helen&quot;,&quot;Female&quot;,15)
val (name,gender,age) = helen 
println(&quot;$name,$gender,$age years of age&quot;)
</code></pre>

<p>输出</p>

<pre class="line-numbers"><code class="language-text">Helen,Female,15 years of age
</code></pre>

<h3 id="toc_57">嵌套类</h3>

<p>类可以嵌套在其他类中，可以嵌套多层。<br/><br/>
访问嵌套类对的方式是直接使用“类名.”，有多少层嵌套，就用多少层类名加点号来访问。<br/><br/>
普通的嵌套类，没有持有外部类的引用，所以是无法访问外部类的变量的。  </p>

<h4 id="toc_58">内部类</h4>

<p>类可以标记为inner以便能访问外部类的成员，这样的类叫内部类。内部类会带有一个对外部类的对象的引用。</p>

<h4 id="toc_59">匿名内部类</h4>

<p>匿名内部类就是没有名字的内部类。既然是内部类，那么它自然也可以访问外部类的变量。比如Thread()、Runnable()。</p>

<pre class="line-numbers"><code class="language-text">//first
Thread({
    printlin(&quot;test&quot;)
}).start()

//second
val wait = Runnable {
    println(&quot;test2&quot;)
}
Thread(wait).start()

//third
val wait = {
    println(&quot;test3&quot;)
}

Thread(wait).start()
</code></pre>

<h3 id="toc_60">委托</h3>

<h4 id="toc_61">代理模式</h4>

<p>代理模式(Proxy Pattern) 也称为委托模式。在代理模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托（Delegation）给另一个对象来处理。代理模式使得我们可以通过聚合来替代继承，它还使我们可以模拟mixin（混合类型）。委托模式的作用是将委托者与实际实现代码分离出来，以达成解耦的目的。</p>

<h4 id="toc_62">暂时不理解</h4>

<h2 id="toc_63">函数式编程</h2>

<h3 id="toc_64">函数式编程概述</h3>

<p>“函数式编程” 又称泛函编程，是一种“编程范式”，也就是如何编写程序的方法论。它的基础是λ演算。函数式编程的主要思想是把问题的解决方案写成一系列嵌套的函数调用。</p>

<h3 id="toc_65">在Kotlin中使用函数式编程</h3>

<h4 id="toc_66">Kotlin中的函数</h4>

<p>在Kotlin中的函数使用<code>fun</code>关键字声明</p>

<pre class="line-numbers"><code class="language-text">fun double(x: Int): Int {
    return 2 * x
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/1/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872828.html">
                
                  <h1>Android-项目架构</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>写完一个小项目，接着写下一个的时候，总是会发现，有些必要的工具库或者代码库，要回过头去寻找。又或者一些库的名字有所遗忘，版本有更新，再去寻找的时候，总是会浪费很多时间。所以在这篇文章中，记录一下日后项目构建所需要的代码库的地址和配置，以及一些简单必要的代码。</p>

<h2 id="toc_1">工具库</h2>

<h3 id="toc_2">RxLifecycle</h3>

<h4 id="toc_3">Installation</h4>

<pre class="line-numbers"><code class="language-text">compile &#39;com.trello.rxlifecycle2:rxlifecycle:2.2.1&#39;

// If you want to bind to Android-specific lifecycles
compile &#39;com.trello.rxlifecycle2:rxlifecycle-android:2.2.1&#39;

// If you want pre-written Activities and Fragments you can subclass as providers
compile &#39;com.trello.rxlifecycle2:rxlifecycle-components:2.2.1&#39;

// If you want pre-written support preference Fragments you can subclass as providers
compile &#39;com.trello.rxlifecycle2:rxlifecycle-components-preference:2.2.1&#39;

// If you want to use Navi for providers
compile &#39;com.trello.rxlifecycle2:rxlifecycle-navi:2.2.1&#39;

// If you want to use Android Lifecycle for providers
compile &#39;com.trello.rxlifecycle2:rxlifecycle-android-lifecycle:2.2.1&#39;

// If you want to use Kotlin syntax
compile &#39;com.trello.rxlifecycle2:rxlifecycle-kotlin:2.2.1&#39;

// If you want to use Kotlin syntax with Android Lifecycle
compile &#39;com.trello.rxlifecycle2:rxlifecycle-android-lifecycle-kotlin:2.2.1&#39;
</code></pre>

<h4 id="toc_4">地址</h4>

<p><a href="https://github.com/trello/RxLifecycle">Github</a></p>

<h3 id="toc_5">Gson</h3>

<h4 id="toc_6">地址</h4>

<p><a href="https://github.com/google/gson">Github</a></p>

<h3 id="toc_7">RxPicker</h3>

<h4 id="toc_8">Installation</h4>

<p><code>compile &#39;com.caimuhao:rxpicker:1.1.5&#39;</code></p>

<h4 id="toc_9">地址</h4>

<p><a href="https://github.com/imuhao/RxPicker">Github</a></p>

<h3 id="toc_10">MNCrashMonitor</h3>

<p>CrashMonitor 监听程序崩溃日志,直接页面展示崩溃日志列表</p>

<h4 id="toc_11">Installation</h4>

<ul>
<li>在Project的build.gradle中添加仓库地址</li>
</ul>

<pre class="line-numbers"><code class="language-text">allprojects {
        repositories {
            ...
            maven { url &quot;https://jitpack.io&quot; }
        }
    }
</code></pre>

<ul>
<li>在app目录下的build.gradle中添加依赖</li>
</ul>

<pre class="line-numbers"><code class="language-text">    dependencies {
         compile &#39;com.github.maning0303:MNCrashMonitor:V1.0.5&#39;
    }
</code></pre>

<h4 id="toc_12">地址</h4>

<p><a href="https://github.com/maning0303/MNCrashMonitor">Github</a></p>

<h3 id="toc_13">Logger</h3>

<h4 id="toc_14">Installation</h4>

<p><code>compile &#39;com.orhanobut:logger:2.1.1&#39;</code></p>

<h4 id="toc_15">地址</h4>

<p><a href="https://github.com/orhanobut/logger">Github</a></p>

<h3 id="toc_16">ASimpleCache</h3>

<h4 id="toc_17">地址</h4>

<p><a href="https://github.com/yangfuhai/ASimpleCache">Github</a></p>

<h3 id="toc_18">Android Studio Plugins</h3>

<h4 id="toc_19">地址</h4>

<p><a href="https://github.com/balsikandar/Android-Studio-Plugins">Github</a></p>

<h3 id="toc_20">RxGps</h3>

<h4 id="toc_21">Installation</h4>

<p><code>compile &#39;com.github.florent37:rxgps:(last version)&#39;</code></p>

<h4 id="toc_22">地址</h4>

<p><a href="https://github.com/florent37/RxGps">Github</a></p>

<h3 id="toc_23">ObjectBox</h3>

<h4 id="toc_24">Installation</h4>

<p>Add this to your root build.gradle (project level):</p>

<pre class="line-numbers"><code class="language-text">buildscript {
    ext.objectboxVersion = &#39;1.3.4&#39;
    repositories {
        maven { url &quot;http://objectbox.net/beta-repo/&quot; }
    }
    dependencies {
        classpath &quot;io.objectbox:objectbox-gradle-plugin:$objectboxVersion&quot;
    }
    
}

allprojects {
    repositories {
        maven { url &quot;http://objectbox.net/beta-repo/&quot; }
    }
}
</code></pre>

<p>And this to our app&#39;s build.gradle (module level):</p>

<p><code>apply plugin: &#39;io.objectbox&#39; // after applying Android plugin</code></p>

<h4 id="toc_25">地址</h4>

<p><a href="https://github.com/objectbox/objectbox-java">Github</a></p>

<h3 id="toc_26">ARouter</h3>

<h4 id="toc_27">Installation</h4>

<pre class="line-numbers"><code class="language-text">android {
    defaultConfig {
    ...
    javaCompileOptions {
        annotationProcessorOptions {
        arguments = [ moduleName : project.getName() ]
        }
    }
    }
}

dependencies {
    // 替换成最新版本, 需要注意的是api
    // 要与compiler匹配使用，均使用最新版可以保证兼容
    compile &#39;com.alibaba:arouter-api:x.x.x&#39;
    annotationProcessor &#39;com.alibaba:arouter-compiler:x.x.x&#39;
    ...
}
</code></pre>

<h4 id="toc_28">地址</h4>

<p><a href="https://github.com/alibaba/ARouter">Github</a></p>

<h3 id="toc_29">RxFile</h3>

<h4 id="toc_30">Installation</h4>

<p><code>compile &#39;com.github.pavlospt:rxfile:1.7&#39;</code></p>

<h4 id="toc_31">地址</h4>

<p><a href="https://github.com/pavlospt/RxFile">Github</a></p>

<h3 id="toc_32">Matisse</h3>

<h4 id="toc_33">Installation</h4>

<pre class="line-numbers"><code class="language-text">repositories {
    jcenter()
}

dependencies {
    compile &#39;com.zhihu.android:matisse:0.4.3&#39;
}
</code></pre>

<h4 id="toc_34">地址</h4>

<p><a href="https://github.com/zhihu/Matisse">Github</a></p>

<h3 id="toc_35">JKeyboardPanelSwitch</h3>

<h4 id="toc_36">Installation</h4>

<p><code>compile &#39;cn.dreamtobe.kpswitch:library:1.6.0&#39;</code></p>

<h4 id="toc_37">地址</h4>

<p><a href="https://github.com/Jacksgong/JKeyboardPanelSwitch">Github</a></p>

<h3 id="toc_38">Phoenix</h3>

<h4 id="toc_39">Installation</h4>

<pre class="line-numbers"><code class="language-text">//图片/视频选择、预览、编辑与拍照
compile &#39;com.github.guoxiaoxing:phoenix:x&#39;

//选填 - 图片压缩，开启功能：Phoenix.with().enableCompress(true)，获取结果：MediaEntity.getCompressPath()
compile &#39;com.github.guoxiaoxing:phoenix-compress-picture:1.0.11&#39;

//选填 - 视频压缩，开启功能：Phoenix.with().enableCompress(true)，获取结果：MediaEntity.getCompressPath()
compile &#39;com.github.guoxiaoxing:phoenix-compress-video:1.0.11&#39;
</code></pre>

<h4 id="toc_40">地址</h4>

<p><a href="https://github.com/guoxiaoxing/phoenix">Github</a></p>

<h3 id="toc_41">AndroidPerformanceMonitor</h3>

<h4 id="toc_42">Installation</h4>

<pre class="line-numbers"><code class="language-text">dependencies {
    // most often used way, enable notification to notify block event
    compile &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;

    // this way you only enable BlockCanary in debug package
    // debugCompile &#39;com.github.markzhai:blockcanary-android:1.5.0&#39;
    // releaseCompile &#39;com.github.markzhai:blockcanary-no-op:1.5.0&#39;
}
</code></pre>

<h4 id="toc_43">地址</h4>

<p><a href="https://github.com/markzhai/AndroidPerformanceMonitor">Github</a></p>

<h3 id="toc_44">drawable-optimizer</h3>

<h4 id="toc_45">Installation</h4>

<p>In build.gradle</p>

<pre class="line-numbers"><code class="language-text">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;org.fabiomsr:drawable-optimizer-gradle-plugin:1.0.4&#39;
    }
}
</code></pre>

<p>And in app\build.gradle</p>

<pre class="line-numbers"><code class="language-text">// Make sure this line comes *after* you apply the Android plugin (apply plugin: &#39;com.android.application&#39;)
apply plugin: &#39;org.fabiomsr.drawableoptimizer&#39;
</code></pre>

<h3 id="toc_46">Android-Debug-Database</h3>

<h4 id="toc_47">Installation</h4>

<p><code>debugCompile &#39;com.amitshekhar.android:debug-db:1.0.1&#39;</code></p>

<h4 id="toc_48">地址</h4>

<p><a href="https://github.com/amitshekhariitbhu/Android-Debug-Database">Github</a></p>

<h3 id="toc_49">RxAndroid</h3>

<h4 id="toc_50">Installation</h4>

<pre class="line-numbers"><code class="language-text">compile &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39;
// Because RxAndroid releases are few and far between, it is recommended you also
// explicitly depend on RxJava&#39;s latest version for bug fixes and new features.
compile &#39;io.reactivex.rxjava2:rxjava:2.1.7&#39;
</code></pre>

<h4 id="toc_51">地址</h4>

<p><a href="https://github.com/ReactiveX/RxAndroid">Github</a></p>

<h3 id="toc_52">RxPermissions</h3>

<h4 id="toc_53">Installation</h4>

<p><code>compile &#39;com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar&#39;</code></p>

<h4 id="toc_54">地址</h4>

<p><a href="https://github.com/tbruyelle/RxPermissions">Github</a></p>

<h2 id="toc_55">UI库</h2>

<h3 id="toc_56">android-Ultra-Pull-To-Refresh</h3>

<h4 id="toc_57">Installation</h4>

<p><code>compile &#39;in.srain.cube:ultra-ptr:1.0.11&#39;</code></p>

<h4 id="toc_58">地址</h4>

<p><a href="https://github.com/liaohuqiu/android-Ultra-Pull-To-Refresh">Github</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/4</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207872754.html">
                
                  <h1>Android-性能优化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>性能检测与分析，一直在 APP 开发中相当重要，但又被我们常常忽略。很多 APP 或者开发者总是急功近利，总想着快速充实 APP 的相关功能，把开发进度放在首位没有问题，可很多时候就没有然后了，这在整个开发界屡见不鲜。<br/>
在这样的大背景下，加之我之前写的 RxJava 2.0 系列 收到较好的反馈，诱导我想出这么一个性能优化系列。</p>

<h2 id="toc_1">一些你可能需要知道的</h2>

<p>了解我的知道，我出的系列基本都是比较基础，而且侧重于常见必备。所以不一定全面，也不一定深入，所以希望理解。<br/>
性能优化大概可以概括为：</p>

<ul>
<li>性能优化说起来很简单，但做起来难。</li>
<li>性能优化点多并且繁杂，需要耐心和经验。也许每个优化点很小，但积累起来会从量变变成质的飞跃。</li>
<li>性能优化必须建立在产品设计之上，不能为了追求性能而忽略了产品设计。</li>
</ul>

<h2 id="toc_2">提供一些资源 ( 你可能需要梯子 )</h2>

<ul>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fdeveloper.android.com%2Fintl%2Fzh-cn%2Ftraining%2Fbest-performance.html">性能优化最佳实践</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fdeveloper.android.com%2Fintl.zh-cn%2Ftools%2Fperformance%2Findex.html">性能优化工具</a></li>
</ul>

<h2 id="toc_3">善用 ArrayMap</h2>

<p>程序内存的管理是否合理高效对应用的性能有着很大的影响，有时候对容器的使用不当也会导致内存管理效率低下。想必已经有很多童鞋知道了 SparseArray，但它只是用于替代 List。<br/>
我们经常会在程序中用到 HashMap，它非常好用，这毋庸置疑。但它却非常耗内存。HashMap 的工作原理这里我们就不讲了，有兴趣的自行科普。</p>

<h3 id="toc_4">更高效的 ArrayMap 容器</h3>

<p>为了解决 HashMap 更占内存的弊端，Android 提供了内存效率更高的 ArrayMap。它内部使用两个数组进行工作，其中一个数组记录 key hash 过后的顺序列表，另外一个数组按 key 的顺序记录 Key - Value 的值。如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047249478577.png" alt="20171112151047249478577.png"/><figcaption>20171112151047249478577.png</figcaption></figure></p>

<p>当你想获取某个 Value 的时候，<code>ArrayMap</code> 会计算输入 key 转换过后的 hash 值，然后对 hash 数组使用二分查找法寻找到对应的 index，然后我们可以通过这个 index 在另外一个数组中直接访问到需要的键值对。如果在第二个数组键值对中的 key 和前面输入的查询 key 不一致，那么就认为是发生了碰撞冲突。为了解决这个问题，我们会以该 key 为中心点，分别上下展开，逐个去对比查找，直到找到匹配的值。如下图所示：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047254836245.png" alt="20171112151047254836245.png"/><figcaption>20171112151047254836245.png</figcaption></figure></p>

<p>随着数组中的对象越来越多，查找访问单个对象的花费也会跟着增长，这是在内存占用与访问时间之间做权衡交换。<br/>
既然ArrayMap中的内存占用是连续不间断的，那么它是如何处理插入与删除操作的呢？请看下图所示，演示了Array的特性：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047290144965.png" alt="20171112151047290144965.png"/><figcaption>20171112151047290144965.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047306821392.png" alt="20171112151047306821392.png"/><figcaption>20171112151047306821392.png</figcaption></figure></p>

<p>很明显，ArrayMap 的插入与删除的效率是不够高的，但是如果数组的列表只是在一百这个数量级上，则完全不用担心这些插入与删除的效率问题。HashMap 与 ArrayMap 之间的内存占用效率对比图如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047311164769.png" alt="20171112151047311164769.png"/><figcaption>20171112151047311164769.png</figcaption></figure></p>

<p>与 <code>HashMap</code> 想必，<code>ArrayMap</code> 在循环遍历的时候也更加简单高效，因为其采用的是 fori 循环，而 <code>HashMap</code> 却使用的是糟糕的 <code>Iterator</code>。</p>

<h3 id="toc_5">并不是所有情况下都用 ArrayMap</h3>

<p><code>ArrayMap</code> 这么优秀，但并不是所有情况下都适合使用 <code>ArrayMap</code>，我们应该在满足下面两个条件的时候才考虑使用 <code>ArrayMap</code>：</p>

<ul>
<li>对象个数的数量级最好在 1000 以内。</li>
<li>数据组织形式包含 Map 结构。</li>
</ul>

<p>所以我们需要学会在特定清醒下选择相对更加高效的实现方式。</p>

<h2 id="toc_6">UI 性能确实很重要</h2>

<p>UI 界面是整个 APP 性能的最前端展示，也是最容易看出性能问题的地方。可以毫不夸张地说，UI 性能的好坏直接影响这用户的体验和留存。UI 性能的目标是：</p>

<ul>
<li>减少绘图的等待时间。</li>
<li>使帧率更加平稳、连贯。</li>
</ul>

<h3 id="toc_7">UI 布局的核心原则</h3>

<p>核心原则一句话，尽可能地减少 View 的数量！<br/><br/>
我们可以通过 <code>include</code>、<code>merge</code>、<code>viewstub</code> 进行布局复用，通过控件属性 DrawableLeft、DrawableRight 等方式进行控件整合。  </p>

<h3 id="toc_8">听说我们要尽可能地用 RelativeLayout ?</h3>

<p>想必一些资历较老的 Android 开发者都知道，一开始系统默认创建的布局是 LinearLayout，后面替换成了 RelativeLayout，现在又变成了 ConstraintLayout 。由于我对 ConstraintLayout 不是特别了解，所以这里我着重说说 RelativeLayout 和 LinearLayout 。<br/><br/>
我不知道在什么时候听说过，<code>如果我们能用 RelativeLayout 的地方，尽量不要用 LinearLayout</code> 。<br/><br/>
这种说法是不对的，实际开发中，决不能简单地说 RelativeLayout 和 LinearLayout 谁的性能更好，必须结合实际使用来进行分析。<br/><br/>
基本可以总结为：一般情况下，如果使用 LinearLayout，则一定要保证层级不能太深；如果使用 RelativeLayout，则需要尽量避免嵌套。  </p>

<h2 id="toc_9">正文</h2>

<p>提高 APP 的启动速度对我们意义深远，很显然，APP 的启动时间越短，使用它的用户越有耐心等待打开这个 APP 进行使用。反之，启动时间太长，用户则有可能还没等到 APP 打开就已经切换到其他 APP 了。</p>

<p>程序启动过程中那些复杂错误的操作很有可能导致严重的性能问题。Android 系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android 系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他 APP 界面切换回来）。</p>

<p>那么关键的问题是，<strong>用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他 APP 了。更严重的是，如果启动时间过长，可能导致程序出现 ANR。我们应该避免出现这两种糟糕的情况。</strong></p>

<p>从技术角度来说，当用户点击桌面图标开始，系统会立即为这个 APP 创建独立的专属进程，然后显示启动窗口，直到 APP 在自己的进程里面完成了程序的创建以及主线程完成了 Activity 的初始化显示操作，再然后系统进程就会把启动窗口替换成 APP 的显示窗口。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047382978489.png" alt="20171112151047382978489.png"/><figcaption>20171112151047382978489.png</figcaption></figure></p>

<p>上述流程里面的绝大多数步骤都是由系统控制的，一般来说不会出现什么问题，可是对于启动速度，我们能够控制并且需要特别关注的地方主要有三处：</p>

<ul>
<li>Activity 的 onCreate 流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题。</li>
<li>Application 的 onCreate 流程，对于大型的 APP 来说，通常会在这里做大量的通用组件的初始化操作。</li>
<li>目前有部分 APP 会提供自定义的启动窗口，这里可以做成品牌宣传界面或者是给用户提供一种程序已经启动的视觉效果。</li>
</ul>

<p>在正式着手解决问题之前，我们需要掌握一套正确测量评估启动性能的方法。所幸的是，Android 系统有提供一些工具来帮助我们定位问题。</p>

<h2 id="toc_10">有趣的启动时长定位</h2>

<h3 id="toc_11">display time</h3>

<p>从 Android KitKat 版本开始，Logcat 中会输出从程序启动到某个 Activity 显示到画面上所花费的时间。这个方法比较适合测量程序的启动时间。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017111215104739066103.png" alt="2017111215104739066103.png"/><figcaption>2017111215104739066103.png</figcaption></figure></p>

<h3 id="toc_12">reportFullyDrawn()</h3>

<p>我们通常来说会使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异步加载完毕之后调用 <code>activity.reportFullyDrawn()</code> 方法来告诉系统此时的状态，以便获取整个加载的耗时。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047399580505.png" alt="20171112151047399580505.png"/><figcaption>20171112151047399580505.png</figcaption></figure></p>

<h3 id="toc_13">Method Tracing</h3>

<p>前面两个方法提供了启动耗时的总时间，可是却无法提供具体的耗时细节。为了获取具体的耗时分布情况，我们可以使用 Method Tracing 工具来进行详细的测量。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047401087421.png" alt="20171112151047401087421.png"/><figcaption>20171112151047401087421.png</figcaption></figure></p>

<h3 id="toc_14">Systrace</h3>

<p>我们可以在 <code>onCreate()</code> 方法里面添加 <code>trace.beginSection()</code> 与 <code>trace.endSection()</code> 方法来声明需要跟踪的起止位置，系统会帮忙统计中间经历过的函数调用耗时，并输出报表。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017111215104740573026.png" alt="2017111215104740573026.png"/><figcaption>2017111215104740573026.png</figcaption></figure></p>

<h2 id="toc_15">如果优化 APP 启动速度？</h2>

<h3 id="toc_16">提升 Activity 的创建速度</h3>

<p>提升 Activity 的创建速度是优化 APP 启动速度的首要关注目标。从桌面点击 APP 图标启动应用开始，程序会显示一个启动窗口等待 Activity 的创建加载完毕再进行显示。在 Activity 的创建加载过程中，会执行很多的操作，例如设置页面的主题，初始化页面的布局，加载图片，获取网络数据，读写 Preference 等等。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047407664811.png" alt="20171112151047407664811.png"/><figcaption>20171112151047407664811.png</figcaption></figure></p>

<p>上述操作的任何一个环节出现性能问题都可能导致画面不能及时显示，影响了程序的启动速度。上一个段落我们介绍了使用 Method Tracing 来发现那些耗时占比相对较多的方法。假设我们发现某个方法执行时间过长，接下去就可以使用 Systrace 来帮忙定位到底是什么原因导致那个方法执行时间过长。</p>

<p>除了使用工具进行具体定位分析性能问题之外，以下两点经验可以帮助我们对 Activity 启动做性能优化：</p>

<ul>
<li>优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！</li>
<li>异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。</li>
</ul>

<h3 id="toc_17">别让 Application 初始化不必要的东西</h3>

<p>在 Application 初始化的地方做太多繁重的事情是可能导致严重启动性能问题的元凶之一。Application 里面的初始化操作不结束，其他任意的程序操作都无法进行。</p>

<p>有时候，我们会一股脑的把绝大多数全局组件的初始化操作都放在 Application 的 onCreate() 里面，但其实很多组件是需要做区队对待的，有些可以做延迟加载，有些可以放到其他的地方做初始化操作，特别需要留意包含 Disk IO 操作，网络访问等严重耗时的任务，他们会严重阻塞程序的启动。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047411112263.png" alt="20171112151047411112263.png"/><figcaption>20171112151047411112263.png</figcaption></figure></p>

<p>优化这些问题的解决方案是做延迟加载，可以在 Application 里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047412041394.png" alt="20171112151047412041394.png"/><figcaption>20171112151047412041394.png</figcaption></figure></p>

<h3 id="toc_18">恰当地使用闪屏</h3>

<p>启动闪屏不仅仅可以作为品牌宣传页，还能够减轻用户对启动耗时的感知，但是如果使用不恰当，将适得其反。前面介绍过当点击桌面图标启动 APP 的时候，程序会显示一个启动窗口，一直到页面的渲染加载完毕。如果程序的启动速度足够快，我们看的闪屏窗口停留显示的时间则会很短，但是当程序启动速度偏慢的时候，这个启动闪屏可以一定程度上减轻用户等待的焦虑感，避免用户过于轻易的关闭应用。</p>

<p>目前大多数开发者都会通过设置启动窗口主题的方式来替换系统默认的启动窗口，通过这种方式只是使用『障眼法』弱化了用户对启动时间的感知，但本质上并没有对启动速度做什么优化。也有些 APP 通过关闭启动窗口属性 android:windowDisablePreview 的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，这样的用户体验是十分糟糕的！</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047413813045.png" alt="20171112151047413813045.png"/><figcaption>20171112151047413813045.png</figcaption></figure></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047415075230.png" alt="20171112151047415075230.png"/><figcaption>20171112151047415075230.png</figcaption></figure></p>

<p>对于启动闪屏，正确的使用方法是自定义一张图片，把这张图片通过设置主题的方式显示为启动闪屏，代码执行到主页面的 <code>onCreate()</code> 的时候设置为程序正常的主题。</p>

<h2 id="toc_19">前言</h2>

<p>内存泄漏从来都是我们老生常谈的话题，无论是 Android Studio 自带的内存泄漏分析工具还是专业的 Eclipse MAT 抑或是备受青睐的第三方插件 <a href="https://github.com/square/leakcanary">LeakCanary</a>，都为我们的内存泄漏检测提供了便利。如果从根源上解决内存泄漏，内存优化必不可少。所以本章节我们参考扔物线胡凯的内存优化策略，直接拿出一章节来谈内存优化。</p>

<p>内存优化基本可以分为下面几个方面</p>

<ul>
<li>减少对象的内存占用</li>
<li>对内存对象进行复用</li>
<li>避免对象的内存泄漏</li>
<li>内存使用策略优化</li>
</ul>

<h2 id="toc_20">减少对象的内存占用</h2>

<h3 id="toc_21">避免在 Android 里面使用 Enum</h3>

<p>Enum 是 Java 中包含固定常量的数据类型，当需要知道预先定制的几个值，这几个值表示一些数据类，我们都可以使用 Enum。我们一般用 Enum 做一些编译时检查，以避免传入不合法的参数。</p>

<p>但 Enum 的每个对象都是 Object，在 Android 官网上就早已明确指出应该在 Android 开发中避免使用 Enum，因为与静态常量想必，它对内存的占用是要大很多的。</p>

<p>因此在实际开发中，我更加倾向于接口变量，因为接口会自动把成员变量设置为 static 和 final 的，这一点可以防止某些情况下错误地添加新的常量，这也使得代码看起来更加简单和清晰。</p>

<h3 id="toc_22">使用更加轻量的数据结构</h3>

<p>前面第一节已经说过，我们应该更加倾向于考虑使用 <code>ArrayMap</code> 和 <code>SparseArray</code> 而不是 <code>HashMap</code> 等传统数据结果，前面已经用图示演示了 <code>HashMap</code> 的简要工作原理，相比起 <code>Android</code> 系统专门为移动操作系统编写的 <code>ArrayMap</code> 容器，在大多数情况下，都显示效率低下，更占内存。通常的 <code>HashMap</code> 的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录 <code>Mapping</code> 操作。另外，<code>SparseArray</code> 更加高效在于他们避免了对 <code>key</code> 和 <code>value</code> 的 <code>autobox</code> 自动装箱，并且避免了装箱后的解箱。</p>

<h3 id="toc_23">使用更小的图片</h3>

<p>在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的 <code>InflationException</code>。假设有一张很大的图片被 XML 文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生 <code>InflationException</code>，这个问题的根本原因其实是发生了 OOM。</p>

<h3 id="toc_24">减少 Bitmap 对象的内存占用</h3>

<p>Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用是很重要的，通常来说有下面2个措施：</p>

<ul>
<li>inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</li>
<li>decode format：解码格式，选择 ARGB_8888 / RBG_565 / ARGB_4444 / ALPHA_8，存在很大差异。</li>
</ul>

<h3 id="toc_25">尽量地采用 int 类型</h3>

<p>Android 系统中 float 类型的数据存取速度是 int 类型的一半，尽量优先采用 int 类型。而同样能作为整数的代名词，采用 int 替换 Integer 会让你的内存开销更小。</p>

<h2 id="toc_26">对内存对象进行复用</h2>

<h3 id="toc_27">复用系统自带的资源</h3>

<p>Android 系统本身内置了很多的资源，例如字符串 / 颜色 / 图片 / 动画 / 样式以及简单布局等等，这些资源都可以在应用程序中直接引用。这样做不仅仅可以减少应用程序的自身负重，减小 APK 的大小，另外还可以一定程度上减少内存的开销，复用性更好。但是也有必要留意 Android 系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p>

<h3 id="toc_28">注意 ListView / GridView 的 Adapter 对 ConvertView 进行复用</h3>

<p>这个貌似没啥好说的，太基础了，而且我们可能现在更加青睐于 RecyclerView。</p>

<h3 id="toc_29">尽量的采用 StringBuilder</h3>

<p>这个也特别基础，我们点到为止。大概就是尽量的采用 StringBuilder / StringBuffer 来替换我们频繁的字符串拼接。</p>

<h3 id="toc_30">尽量使用原字符串的 subString</h3>

<p>当从已经存在的数据集中抽取出 String 的时候，尝试返回原数据的 subString 对象，而不要创建一个重复的对象。</p>

<h3 id="toc_31">避免在 onDraw() 里面执行对象的创建</h3>

<p>类似 onDraw() 等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的 gc，甚至是内存抖动。</p>

<h2 id="toc_32">避免对象的内存泄漏</h2>

<p>内存对象的泄漏，会导致一些不再使用的对象无法及时释放，这样一方面占用了宝贵的内存空间，很容易导致后续需要分配内存的时候，空闲空间不足而出现 OOM。显然，这还使得每级 Generation 的内存区域可用空间变小，gc 就会更容易被触发，容易出现内存抖动，从而引起性能问题。</p>

<h3 id="toc_33">注意 Activity 的泄漏</h3>

<p>通常来说，Activity 的泄漏是内存泄漏里面最严重的问题，它占用的内存多，影响面广，我们需要特别注意以下两种情况导致的 Activity 泄漏：</p>

<ul>
<li><p>内部类引用导致 Activity 的泄漏<br/><br/>
最典型的场景是 Handler 导致的 Activity 泄漏，如果 Handler 中有延迟的任务或者是等待执行的任务队列过长，都有可能因为 Handler 继续执行而导致 Activity 发生泄漏。此时的引用关系链是 Looper -&gt; MessageQueue -&gt; Message -&gt; Handler -&gt; Activity。为了解决这个问题，可以在 UI 退出之前，执行 remove Handler 消息队列中的消息与 runnable 对象。或者是使用 Static + WeakReference 的方式来达到断开 Handler 与 Activity 之间存在引用关系的目的。</p></li>
<li><p>Activity Context 被传递到其他实例中，这可能导致自身被引用而发生泄漏。<br/><br/>
内部类引起的泄漏不仅仅会发生在 Activity 上，其他任何内部类出现的地方，都需要特别留意！我们可以考虑尽量使用 static 类型的内部类，同时使用 WeakReference 的机制来避免因为互相引用而出现的泄露。</p></li>
</ul>

<h3 id="toc_34">尽量地采用 Application Context</h3>

<p>对于大部分非必须使用 Activity Context 的情况（Dialog 的 Context 就必须是Activity Context），我们都可以考虑使用 Application Context 而不是 Activity 的 Context，这样可以避免不经意的 Activity 泄露。</p>

<p>而且如果习惯 Glide 的童鞋可能会发现，<strong>Glide 需要传递的 Context 如果是 Activity 的 Context ，那么在 Activity 被销毁后还没加载出来的话还会引发崩溃。</strong>所以，请在使用 Glide 或者 Toast 等的时候，直接传递 Application Context 吧。</p>

<h3 id="toc_35">注意 Cursor 对象是否及时关闭</h3>

<p>在程序中我们经常会进行查询数据库的操作，但时常会存在不小心使用 Cursor 之后没有及时关闭的情况。这些 Cursor 的泄露，反复多次出现的话会对内存管理产生很大的负面影响，我们需要谨记对 Cursor 对象的及时关闭。</p>

<h3 id="toc_36">注意 WebView 的泄漏</h3>

<p>Android中 的 WebView 存在很大的兼容性问题，不仅仅是 Android 系统版本的不同对 WebView 产生很大的差异，另外不同的厂商出货的 ROM 里面 WebView 也存在着很大的差异。更严重的是标准的 WebView 存在内存泄露的问题，看这里。所以通常根治这个问题的办法是为 WebView 开启另外一个进程，通过 AIDL 与主进程进行通信，WebView 所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>

<h3 id="toc_37">注意临时 Bitmap 对象的及时回收</h3>

<p>虽然在大多数情况下，我们会对 Bitmap 增加缓存机制，但是在某些时候，部分 Bitmap 是需要及时回收的。例如临时创建的某个相对比较大的 Bitmap 对象，在经过变换得到新的 Bitmap 对象之后，应该尽快回收原始的 Bitmap，这样能够更快释放原始 Bitmap 所占用的空间。</p>

<p>需要特别留意的是 Bitmap 类里面提供的 createBitmap() 方法：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20171112151047477494165.png" alt="20171112151047477494165.png"/><figcaption>20171112151047477494165.png</figcaption></figure></p>

<p>这个函数返回的 Bitmap 有可能和 source bitmap 是同一个，在回收的时候，需要特别检查 source bitmap 与 return bitmap 的引用是否相同，只有在不等的情况下，才能够执行 source bitmap 的 recycle() 方法。</p>

<h3 id="toc_38">注意监听器的注销</h3>

<p>在 Android 程序里面存在很多需要 register 与 unregister 的监听器，我们需要确保在合适的时候及时 unregister 那些监听器。自己手动 add 的 listener，需要记得及时 remove 这个 listener。</p>

<h2 id="toc_39">内存使用策略优化</h2>

<h3 id="toc_40">谨慎使用 large heap</h3>

<p>Android 设备根据硬件与软件的设置差异而存在不同大小的内存空间，他们为应用程序设置了不同大小的 Heap 限制阈值。你可以通过调用 getMemoryClass() 来获取应用的可用 Heap 大小。在一些特殊的情景下，你可以通过在 manifest 的 application 标签下添加 <code>largeHeap = true</code> 的属性来为应用声明一个更大的 heap 空间。然后，你可以通过 <code>getLargeMemoryClass()</code> 来获取到这个更大的 <code>heap size</code> 阈值。然而，声明得到更大 Heap 阈值的本意是为了一小部分会消耗大量 RAM 的应用 ( 例如一个大图片的编辑应用 ) 。不要轻易的因为你需要使用更多的内存而去请求一个大的 Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用 large heap。因此请谨慎使用 large heap 属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次 gc 的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap 并不一定能够获取到更大的 heap。在某些有严格限制的机器上，large heap 的大小和通常的 heap size 是一样的。因此即使你申请了 large heap，你还是应该通过执行 <code>getMemoryClass()</code> 来检查实际获取到的 heap 大小。</p>

<h3 id="toc_41">资源文件需要选择合适的文件夹进行存放</h3>

<p>我们知道 hdpi / xhdpi / xxhdpi 等等不同 dpi 的文件夹下的图片在不同的设备上会经过 scale 的处理。例如我们只在 hdpi 的目录下放置了一张 100 x 100 的图片，那么根据换算关系，xxhdpi 的手机去引用那张图片就会被拉伸到 200 x 200。需要注意到在这种情况下，内存占用是会显著提高的。对于不希望被拉伸的图片，需要放到 assets 或者 nodpi 的目录下。</p>

<h3 id="toc_42">Try catch某些大内存分配的操作</h3>

<p>在某些情况下，我们需要事先评估那些可能发生 OOM 的代码，对于这些可能发生 OOM 的代码，加入 catch 机制，可以考虑在 catch 里面尝试一次降级的内存分配操作。例如 decode bitmap 的时候，catch 到 OOM，可以尝试把采样比例再增加一倍之后，再次尝试 decode。</p>

<h3 id="toc_43">谨慎使用 static 对象</h3>

<p>因为 static 的生命周期过长，和应用的进程保持一致，使用不当很可能导致对象泄漏，在 Android 中应该谨慎使用 static 对象。</p>

<h3 id="toc_44">特别留意单例对象中不合理的持有</h3>

<p>虽然单例模式简单实用，提供了很多便利性，但是因为单例的生命周期和应用保持一致，使用不合理很容易出现持有对象的泄漏。特别是持有 Context 的引用，需要谨慎对待。</p>

<h3 id="toc_45">优化布局层次，减少内存消耗</h3>

<p>越扁平化的视图布局，占用的内存就越少，效率越高。我们需要尽量保证布局足够扁平化，当使用系统提供的 View 无法实现足够扁平的时候考虑使用自定义 View 来达到目的。</p>

<h3 id="toc_46">谨慎使用多进程</h3>

<p>使用多进程可以把应用中的部分组件运行在单独的进程当中，这样可以扩大应用的内存占用范围，但是这个技术必须谨慎使用，绝大多数应用都不应该贸然使用多进程，一方面是因为使用多进程会使得代码逻辑更加复杂，另外如果使用不当，它可能反而会导致显著增加内存。当你的应用需要运行一个常驻后台的任务，而且这个任务并不轻量，可以考虑使用这个技术。</p>

<p>一个典型的例子是创建一个可以长时间后台播放的 Music Player。如果整个应用都运行在一个进程中，当后台播放的时候，前台的那些 UI 资源也没有办法得到释放。类似这样的应用可以切分成 2 个进程：一个用来操作 UI，另外一个给后台的 Service。</p>

<h2 id="toc_47">写在最后</h2>

<p>内存优化并不就是说程序占用的内存越少就越好，如果因为想要保持更低的内存占用，而频繁触发执行 gc 操作，在某种程度上反而会导致应用性能整体有所下降，这里需要综合考虑做一定的权衡。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/11/3</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15580646892750.html">发布Android库至JCenter仓库</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576631048737.html">单例模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15576630121534.html">23种设计模式全面解析</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873148.html">Android RecyclerView性能优化</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15561207873102.html">Android 基础复习</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
