<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MagicalRice的Blog]]></title>
  <link href="http://adolph.cc/atom.xml" rel="self"/>
  <link href="http://adolph.cc/"/>
  <updated>2019-10-10T16:31:49+08:00</updated>
  <id>http://adolph.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[代理模式]]></title>
    <link href="http://adolph.cc/15712984956484.html"/>
    <updated>2019-10-17T15:48:15+08:00</updated>
    <id>http://adolph.cc/15712984956484.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">代理模式介绍</h2>

<p>代理模式(Proxy Pattern)也称为委托模式，在我们日常生活中也不少见，对于程序员来说最常接触的莫过于代理上网，连上代理服务器地址，就可以轻松畅游全世界的网络；还有每天吃饭时赶进度是常事，叫公司的同事帮忙买饭也是一种代理；如果你碰到辞职老板不给你发工资，那么你还得请个律师帮你打官司，这也是一种代理。总而言之，也许你并不留意，但是代理的确无处不在，现实生活中如此，我们的Code世界也是如此。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">代理模式的定义</h2>

<p>为其他对象提供一种代理以控制对这个对象的访问</p>

<h2 id="toc_2">代理模式的使用场景</h2>

<p>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。</p>

<h2 id="toc_3">代理模式的简单实现</h2>

<p>就以请律师进行诉讼来举例子</p>

<p><strong>诉讼接口类</strong></p>

<pre class="line-numbers"><code class="language-java">public interface ILawsuit {
    //提交申请
    void submit();
    
    //进行举证
    void burden();
    
    //开始辩护
    void defend();
    
    //诉讼完成
    void finish();
}
</code></pre>

<p><strong>具体诉讼人</strong></p>

<pre class="line-numbers"><code class="language-java">public class XiaoTian implements ILawsuit {
    @Override
    public void submit() {
        //老板欠小天工资，小天只好申请仲裁
        System.out.println(&quot;老板拖欠工资！特此申请仲裁！&quot;);
    }
    
    @Override
    public void burden() {
        //小天证据充足，不怕告不赢
        System.out.println(&quot;这是合同书和过去一年的银行工资流水!&quot;);
    }
    
    @Override
    public void defend() {
        //铁证如山，辩护也没什么好说的
        System.out.println(&quot;证据确凿!不需要再说什么了!&quot;);
    }
    
    @Override
    public void finish() {
        //结果也是肯定的，必赢
        System.out.println(&quot;诉讼成功!判决老板即日起七天内结算工资&quot;);
    }
}
</code></pre>

<p>当然小天是不会自己去打官司的，于是请了个代理律师代替自己诉讼</p>

<p><strong>代理律师</strong></p>

<pre class="line-numbers"><code class="language-java">public class Lawyer implements ILawsuit {
    private ILawsuit mLawsuit;  //持有一个具体被代理者的引用
    
    public Lawyer(ILawsuit lawsuit) {
        mLawsuit = lawsuit;
    }
    
    @Override
    public void submit() {
        mLawsuit.submit();
    }
    
    @Override
    public void burden() {
        mLawsuit.burden();
    }
    
    @Override
    public void defend() {
        mLawsuit.defend();
    }
    
    @Override
    public void finish() {
        mLawsuit.finish();
    }
}
</code></pre>

<p>律师类表示代理者律师，在该类里面会持有一个被代理者的引用，律师所执行的方法实质就是简单地调用被代理者中的方法</p>

<p><strong>客户类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Client {
    public static void main(String[] args) {
        //构造一个小天...
        ILawsuit xiaotian = new XiaoTian();
        
        //构造一个代理律师将小天作为构造参数传进去
        ILawsuit lawyer = new Lawyer(xiaotian);
        
        //律师提交诉讼申请
        lawyer.submit();
        
        //律师进行举证
        lawyer.burden();
        
        //律师代理小天进行辩护
        lawyer.defend();
        
        //完成诉讼
        lawyer.finish();
    }
}
</code></pre>

<p>上诉例子使用的是静态代理模式，也可以代理多个类，同时代理多个人进行打官司。静态代理，代理者的代码由程序员自己或通过一些自动化工具生成固定的代码在对其进行编译，也就是说在我们的代码运行前代理类的class编译文件就已存在；而动态代理则与静态代理相反，通过反射机制动态地生成代理者的对象，也就是说我们再code阶段压根就不需要知道代理谁，代理谁我们将会在执行阶段决定。而Java也给我们提供了一个便捷的动态代理接口InvocationHandler，实现该接口需要重写其调用方法invoke。</p>

<p>我们主要通过invoke方法来调用具体的被代理方法，也就是真实的方法。动态代理可以使我们的代码逻辑更简洁，不过在这之间我们得首先完善动态代理类。</p>

<pre class="line-numbers"><code class="language-java">public class DynamicProxy implements InvocationHandler {
    private Objcet obj;  //被代理的类引用
    
    public DynamicProxy(Object obj) {
        this.obj = obj;
    }
    
    @Override
    public Object invoke(Object arg0, Method arg1, Object[] arg2) throws Throwable {
        //调用被代理类对象的方法
        Object result = method.invoke(obj.args);
        return result;
    }
}
</code></pre>

<p>如上代码所述，我们声明一个Object的引用，该引用指向被代理类，而我们调用被代理类的具体方法则在invoke方法中执行。也就是说我们原来由代理类所做的工作现在由InvocationHandler来处理，不再需要关心到底代理谁。</p>

<p><strong>修改后的客户类</strong></p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    //构造一个小天
    ILawsuit xiaotian = new XiaoTian();
    
    //构建一个动态代理
    DynamicProxy proxy = new DynamicProxy(xiaotian);
    
    //获取被代理类小天的ClassLoader
    ClassLoader loader = xiaotian.getClass().getClassLoader();
    
    //动态构造一个代理律师
    ILawsuit lawyer = (ILawsuit) Proxy.newProxyInstance(loader, new Class[] {ILawsuit.class}, proxy);
    
    //律师提交诉讼申请
    lawyer.submit();
    
    //律师进行举证
    lawyer.burden();
    
    //律师代替小天进行辩护
    lawyer.defend();
    
    //完成诉讼
    lawyer.finish();
}
</code></pre>

<p>由此可见动态代理通过一个代理类来代理N个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的耦合关系。相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂，但是静态代理更符合面向对象原则。</p>

<h2 id="toc_4">总结</h2>

<p>其他结构型模式中，都可以看到代理模式的影子，有些模式单独作为一种设计模式，倒不如说是对代理模式的一种针对性优化。而且代理模式几乎没有什么缺点可言，它是细分化至很小的一种模式。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[备忘录模式]]></title>
    <link href="http://adolph.cc/15712937841703.html"/>
    <updated>2019-10-17T14:29:44+08:00</updated>
    <id>http://adolph.cc/15712937841703.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">备忘录模式介绍</h2>

<p>备忘录模式是一种行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态，这有点像我们平时说的“后悔药”。备忘录模式实现的方式需要保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保护的这些对象状态的完整性以及内部实现不向外暴露。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">备忘录模式的定义</h2>

<p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可以将该对象恢复到原先保存的状态。</p>

<h2 id="toc_2">备忘录模式的使用场景</h2>

<ol>
<li>需要保存一个对象在某个时刻的状态或部分状态</li>
<li>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。</li>
</ol>

<h2 id="toc_3">备忘录模式的简单示例</h2>

<p>对备忘录模式来说，比较贴切的场景应该是游戏中的存档功能，该功能就是将游戏进度存储到本地文件系统或者数据库中，下次再次进入时从本地加载进度，使得玩家能够继续上一次的游戏之旅，这里我们就以“使命召唤”这款游戏为例来简单演示一下备忘录模式的实现。<br/>
首先我们建立游戏类、备忘录类、Caretaker类，玩游戏到某个节点对游戏进行存档，然后退出游戏，再重新进入时从存档中读取进度，并且进入存档时的进度。</p>

<p><strong>游戏类</strong></p>

<pre class="line-numbers"><code class="language-java">/**
 * 使命召唤游戏(数据模型可能不太合理，这里我们只是简单演示)
 */
public class CallOfDuty {
    private int mCheckpoint = 1;
    private int mLifeValue = 100;
    private String mWeapon = &quot;沙漠之鹰&quot;;
    
    //玩游戏
    public void play() {
        System.out.println(&quot;玩游戏：&quot; + String.format(&quot;第%d关&quot;, mCheckpoint) + &quot; 奋战杀敌中&quot;);
        mLifeValue -= 10;
        System.out.println(&quot;进度升级啦&quot;);
        mCheckpoint++;
        System.out.println(&quot;到达&quot; + String.format(&quot;第%d关&quot;, mCheckpoint));
    }
    
    //退出游戏
    public void quit() {
        System.out.println(&quot;----------&quot;);
        System.out.println(&quot;退出前的游戏属性：&quot; + this.toString());
        System.out.println(&quot;退出游戏&quot;);
        System.out.println(&quot;----------&quot;);
    }
    
    //创建备忘录
    public Memoto createMemoto() {
        Memoto memoto = new Memoto();
        memoto.mCheckpoint = mCheckpoint;
        memoto.mLifeValue = mLifeValue;
        memoto.mWeapon = mWeapon;
        return memoto;
    }
    
    //恢复游戏
    public void restore(Memoto memoto) {
        this.mCheckpoint = memoto.mCheckpoint;
        this.mLifeValue = memoto.mLifeValue;
        this.mWeapon = memoto.mWeapon;
        System.out.println(&quot;恢复后的游戏属性：&quot; + this.toString());
    }
    
    @Override
    public String toString() {
        return &quot;CallOfDuty [mCheckpoint = &quot; + mCheckpoint + &quot;, mLifeValue=&quot; + mLifeValue + &quot;, Weapon=&quot; + mWeapon + &quot;]&quot;;
    }
}
</code></pre>

<p>在CallOfDuty游戏类中，我们存储了几个关键字段，关卡、人物的生命值、武器，当调用play函数玩游戏时，我们对关卡和人物的生命值进行修改。在该类中可以通过createMemoto函数来创建该用户的备忘录对象，也就是将自身的状态保存到一个Memoto对象中。外部可以通过restore函数将CallOfDuty对象的状态从备忘录对象中恢复。</p>

<p><strong>备忘录类</strong></p>

<pre class="line-numbers"><code class="language-java">/**
 * 备忘录
 */
public class Memoto {
    public int mCheckpoint;
    public int mLifeValue;
    public String mWeapon;
    
    @Override
    public String toString() {
        return &quot;Memoto [mCheckpoint=&quot; + mCheckpoint + &quot;, mLifeValue=&quot; + mLifeValue + &quot;, mWeapon=&quot; + mWeapon + &quot;]&quot;;
    }
} 
</code></pre>

<p>这是一个无状态、无操作的实体类，只负责用来存储Originator角色的一些数据，房子外部直接访问Originator。</p>

<p>而备忘录的操作者则是Caretaker角色</p>

<p><strong>Caretaker</strong></p>

<pre class="line-numbers"><code class="language-java">/**
 * Caretaker，负责管理Memoto
 */
public class Caretaker {
    Memoto mMemoto; //备忘录
    
    /**
     * 存档
     */
    public void archive(Memoto memoto) {
        this.mMemoto = memoto;
    } 
    
    /**
     * 获取存档
     */
    public Memoto getMemoto() {
        return mMemoto;
    } 
} 
</code></pre>

<p>Caretaker类的职责很简单，就是负责管理Memoto对象</p>

<p><strong>客户端</strong></p>

<pre class="line-numbers"><code class="language-java">public class Client {
    public static void main(String[] args) {
        //构建游戏对象
        CallOfDuty game = new CallOfDuty();
        //打游戏
        game.play();
        
        Caretaker caretaker = new Caretaker();
        //游戏存档
        caretaker.archive(game.createMemoto());
        //退出游戏
        game.quit();
        //恢复游戏
        CallOfDuty newGame = new CallOfDuty();
        newGame.restore(caretaker.getMemoto());
    }
}
</code></pre>

<p>CallOfDuty是需要存储数据的对象，在这里并没有直接存储CallOfDuty的对象，而是通过Memoto对CallOfDuty对象的数据进行存储，然后再存储Memoto对象，最终对Memoto的存取操作则交给Caretaker对象。在这个过程中，各个角色职责清晰、单一，代码也比较简单，即对外屏蔽了对CallOfDuty角色的直接访问，在满足了对象状态存取功能的同时也使得该模块的结构保持清晰、整洁。</p>

<h2 id="toc_4">总结</h2>

<p>备忘录模式是在不破坏封装的条件下，通过备忘录对象存储另外一个对象内部状态的快照，在将来合适的时候把这个对象还原到存储起来的状态。</p>

<p><strong>优点</strong></p>

<ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节</li>
</ul>

<p><strong>缺点</strong></p>

<p>消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[观察者模式]]></title>
    <link href="http://adolph.cc/15711947460528.html"/>
    <updated>2019-10-16T10:59:06+08:00</updated>
    <id>http://adolph.cc/15711947460528.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">观察者模式介绍</h2>

<p>观察者模式是一个使用率非常高的模式，它最常用的地方是GUI系统、订阅 —— 发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小，甚至做到毫无依赖。以GUI系统来说，应用的UI具有易变性，尤其是前期随着业务的改变或者产品的需求修改，应用界面也会经常性变化，但是业务逻辑基本变化不大，此时，GUI系统需要一套机制来应对这种情况，使得UI层与具体的业务逻辑解耦，观察者模式此时就派上用场了。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">观察者模式的定义</h2>

<p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>

<h2 id="toc_2">观察者模式的使用场景</h2>

<ul>
<li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制</li>
</ul>

<h2 id="toc_3">观察者模式的简单实现</h2>

<p>下面就我们来简单模拟一下开发技术前线的发布——订阅过程</p>

<pre class="line-numbers"><code class="language-java">//程序员是观察者
public class Coder implements Observer {
    public String name;
    
    public Coder(String aName) {
        name = aName;
    }
    
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;Hi, &quot; + name + &quot;, DevTechFrontier更新啦，内容：&quot; + arg);
    }
    
    @Override
    public String toString() {
        return &quot;码农： &quot; + name;
    }
}

//DevTechFrontier即开发技术前线，这个网站是被观察者角色，当它有更新时所有的观察者(程序员)，都会接到相应的通知
public class DevTechFrontier extends Observable {
    public void postNewPublication(String content) {
        //标识状态或者内容发生变化
        setChanged();
        //通知所有观察者
        notifyObservers(content);
    }
}

//测试代码
public class Test {
    public static void main(String[] args) {
        //被观察者的角色
        DevTechFrontier frontier = new DevTechFrontier();
        //观察者
        Coder mrsimple = new Coder(&quot;mr.simple&quot;);
        Coder coder1 = new Coder(&quot;coder-1&quot;);
        Coder coder2 = new Coder(&quot;coder-2&quot;);
        Coder coder3 = new Coder(&quot;coder-3&quot;);
        
        //将观察者注册到可观察对象的观察者列表中
        DevTechFrontier.addObserver(mrsimple);
        DevTechFrontier.addObserver(coder1);
        DevTechFrontier.addObserver(coder2);
        DevTechFrontier.addObserver(coder3);
        
        //发布消息
        DevTechFrontier.postNewPublication(&quot;新的一期开发技术前线周报发布啦!&quot;);
    }
}
</code></pre>

<p>Observer 和 Observable是JDK中的内置类型，可见观察者模式是非常重要的，这里Observer是抽象的观察者角色，Coder扮演的是具体观察者的角色；Observable对应的是抽象主题角色，DevTecFrontier则是具体的主题角色。Coder订阅了DevTechFrontier，当DevTechFrontier有更新时，会遍历所有观察者，然后给这些观察者发布一个更新的消息，即调用Coder中的update方法，这样就达到了一对多的通知功能。</p>

<h2 id="toc_4">总结</h2>

<p>观察者模式主要的作用就是对象解耦，将观察者和被观察者完全隔离，只依赖于Observer和Observable抽象。例如，ListView就是运用了Adapter和观察者模式使得它的可扩展性、灵活性非常强，而耦合度很低，这是设计模式在Android源码中优秀运用的典范。</p>

<p><strong>优点</strong></p>

<ul>
<li>观察者和被观察者之间是抽象耦合，应对业务变化</li>
<li>增强系统灵活性、可扩展性</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>在应用观察者模式时需要考虑下开发效率和运行效率问题，程序中包括一个被观察者、多个观察者、开发和调试等内容会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[策略模式]]></title>
    <link href="http://adolph.cc/15711314242192.html"/>
    <updated>2019-10-15T17:23:44+08:00</updated>
    <id>http://adolph.cc/15711314242192.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">策略模式介绍</h2>

<p>在软件开发中也常常遇到这样的情况：实现某一个功能可以有多种算法或策略，我们根绝实际情况选择不同的算法或者策略来完成该功能。<br/>
针对这种情况，一种常规的方法是将多种算法写在一个类中。但是当多个算法集中在一个类中时，这个类就会变得臃肿，这个类的维护成本会变高，在维护时也更容易引发错误。如果我们需要增加一种新的排序算法，需要修改封装算法类的源代码。这就明显违反了我们所说的OCP原则和单一职责原则。<br/>
如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性、可维护性也就更高，这就是策略模式。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">策略模式的定义</h2>

<p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>

<h2 id="toc_2">策略模式的使用场景</h2>

<ul>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全地封装多种同一类型的操作时。</li>
<li>出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。</li>
</ul>

<h2 id="toc_3">策略模式的简单实现</h2>

<p>通常如果一个问题有多个解决方案时，最简单的方式就是利用if-else或者switch-case方式，但是耦合性太高、代码臃肿、难以维护。应用策略模式就能很好地解决这类问题，它将各种方案分离开来，让程序客户端根据具体的需求来动态地选择不同的策略方案。</p>

<p>示例中需要计算不同出行工具的成本，下面是我们第一个版本的代码</p>

<pre class="line-numbers"><code class="language-java">public class PriceCalculator {
    //公交车类型
    private static final int BUS = 1;
    //地铁类型
    private static final int SUBWAY = 2;
    
    public static void main(String[] args) {
        PriceCalculator calculator = new PriceCalculator();
        System.out.println(&quot;坐16公里的公交车票价为：&quot; + calculator.calculatePrice(16, BUS));
        System.out.println(&quot;坐16公里的地铁票价为：&quot; + calculator.calculatePrice(16, SUBWAY));
    }
}

/**
 * 北京公交车，十公里之内一元钱，超过十公里之后没加一元钱可以乘5公里
 * @param km 公里
 * @return
 */
 private int busPrice(int km) {
    //超过十公里的总距离
    int extraTotal = km - 10;
    //超过的距离是5公里的距离
    int extraFactor = extraTotal / 5;
    //超过的距离对5公里取余
    int fraction = extraTotal % 5;
    //价格计算
    int price = 1 + extraFactor * 1;
    return fraction &gt; 0 ? ++price : price;
 }
 
 /**
  * 6公里(含)内3元；6~12公里(含)4元；12~22公里(含)5元；22~32公里(含)6元
  * @param km 公里
  * @return
  */
  private int subwayPrice(int km) {
    if(km &lt;= 6) {
        return 3;
    } else if(km &gt; 6 &amp;&amp; km &lt;= 12) {
        return 4;
    } else if(km &gt; 12 &amp;&amp; km &lt;= 22) {
        return 5;
    } else if(km &gt; 22 &amp;&amp; km &lt;= 32) {
        return 6;
    }
    //其他距离我们简化为7元
    return 7;
  }
  
  int calculatePrice(int km, int type) {
    if (type == BUS) {
        return busPrice(km);
    } else if (type == SUBWAY) {
        return subwayPrice(km);
    }
    return 0;
  }
}
</code></pre>

<p>PriceCalculator类很明显的问题就是并不是单一职责，承担了公交车、地铁计费职责。当我们增加一种出行方式就需要在PriceCalculator中增加一个方法来计算出租车出行的价格，并且在calculatePrice函数中增加一个判断</p>

<pre class="line-numbers"><code class="language-java">public class PriceCalculator {
    //公交车类型
    private static final int BUS = 1;
    //地铁类型
    private static final int SUBWAY = 2;
    //出租车类型
    private static final int TAXI = 3;
    
    /**
     * 简单计算为每公里2元
     * @param km 公里
     * @return
     */
    private int taxiPrice(int km) {
        return km * 2;
    }
    
    int calculatePrice(int km, int type) {
        if (type == BUS) {
            return busPrice(km);
        } else if (type == SUBWAY) {
            return subwayPrice(km);
        } else if (type == TAXI) {
            return taxiPrice(km);
        }
        return 0;
    }
}
</code></pre>

<p>增加出行方式时，我们又需要在calculatePrice中添加if-else，此时很有可能就是复制上一个if-else，然后手动进行修改，手动复制代码也是很容易引入错误的做法之一，这样会使代码变得越来越臃肿，难以维护。</p>

<p>用策略模式进行重构</p>

<p>首先我们需要定义一个抽象的价格计算接口</p>

<pre class="line-numbers"><code class="language-java">/**
 * 计算接口
 */
public interface CalculateStrategy {
    /**
     * 按距离来计算价格
     * @param km 公里
     * @return 返回价格
     */
     int calculatePrice(int km);
}
</code></pre>

<p>对于每一种出行方式我们都有一个独立的计算策略类，这些策略类都实现了CalculateStrategy接口，例如下面是公交车和地铁的计算策略类:</p>

<pre class="line-numbers"><code class="language-java">//公交车价格计算策略
public class BusStrategy implements CalculateStrategy {
    /**
     * 北京公交车，十公里之内一元钱，超过十公里之后每加一元钱可以乘5公里
     * @param km 公里
     * @return
     */
     @Override
     public int calculatePrice(int km) {
        //超过十公里的总距离
        int extraTotal = km - 10;
        //超过的距离是5公里的距离
        int extraFactor = extraTotal / 5;
        //超过的距离对5公里取余
        int fraction = extraTotal % 5;
        //价格计算
        int price = 1 + extraFactor * 1;
        return fraction &gt; 0 ? ++price : price;
     }
}

//地铁价格计算策略
public class SubwayStrategy implements CalculateStrategy {
    /**
     * 6公里(含)内3元；6~12公里(含)4元；12~22公里(含)5元；22~32公里(含)6元
     * @param km 公里
     * @return
     */
    private int calculatePrice(int km) {
        if(km &lt;= 6) {
            return 3;
        } else if(km &gt; 6 &amp;&amp; km &lt;= 12) {
            return 4;
        } else if(km &gt; 12 &amp;&amp; km &lt;= 22) {
            return 5;
        } else if(km &gt; 22 &amp;&amp; km &lt;= 32) {
            return 6;
        }
        //其他距离我们简化为7元
        return 7;
    }
}
</code></pre>

<p>我们再创建一个TranficCalculator</p>

<pre class="line-numbers"><code class="language-java">//公交出行价格计算器
public class TranficCalculator {
    public static void main(String[] args) {
        TranficCalculator calculator = new TranficCalculator();
        //设置计算策略
        calculator.setStrategy(new BusStrategy());
        //计算价格
        System.out.println(&quot;公交车乘16公里的价格：&quot; + calculator.calculatePrice(16));
    }
    
    CalculateStrategy mStrategy;
    
    public void setStrategy(CalculateStrategy strategy) {
        this.mStrategy = strategy;
    }
    
    public int calculatePrice(int km) {
        return mStrategy.calculatePrice(km);
    }
}
</code></pre>

<p>通过策略模式添加出租车的计算策略，只需要添加一个出租车计算策略类，然后将该策略设置给TranficCalculator,最好直接通过TranficCalculator对象的计算方法。</p>

<pre class="line-numbers"><code class="language-java">//出租车计算策略
public class TaxiStrategy implements CalculateStrategy {
    //价格我们简单计算为公里数*2
    @Override
    public int calculatePrice(int km) {
        return km * 2;
    }
}
</code></pre>

<p>将策略注册到TranficCalculator中</p>

<pre class="line-numbers"><code class="language-java">//公交出行价格计算器
public class TranficCalculator {
    public static void main(String[] args) {
        TranficCalculator calculator = new TranficCalculator();
        //设置计算策略
        calculator.setStrategy(new TaxiStrategy());
        //计算价格
        System.out.println(&quot;出租车乘16公里的价格：&quot; + calculator.calculatePrice(16));
    }
    
    CalculateStrategy mStrategy;
    
    public void setStrategy(CalculateStrategy strategy) {
        this.mStrategy = strategy;
    }
    
    public int calculatePrice(int km) {
        return mStrategy.calculatePrice(km);
    }
}
</code></pre>

<p>上述示例清晰展示了二者的区别。前者通过if-else来解决问题，虽然实现较为简单，类型层级单一，但暴露的问题非常明显，即代码臃肿，逻辑复杂，难以升级和维护，没有结构可言；后者则是通过建立抽象，将不同的策略构建成一个具体的策略实现，通过不同的策略实现算法替换。在简化逻辑、结构的同时，增强了系统的可读性、稳定性、可扩展性，这对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。</p>

<h2 id="toc_4">总结</h2>

<p>策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。这个模式很好地演示了开闭原则，也就是定义抽象，注入不同的实现，从而达到很好地可扩展性。</p>

<p><strong>优点</strong></p>

<ul>
<li>结构清晰明了、使用简单直观</li>
<li>耦合度相对而言较低，扩展方便</li>
<li>操作封装也更为彻底，数据更为安全</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>随着策略的增加，子类也会变得繁多</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[适配器模式]]></title>
    <link href="http://adolph.cc/15711233221322.html"/>
    <updated>2019-10-15T15:08:42+08:00</updated>
    <id>http://adolph.cc/15711233221322.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">适配器模式介绍</h2>

<p>适配器模式在我们的开发中使用率极高，从代码中随处可见的Adapter就可以判断出来。从最早的ListView、GridView到现在最新的RecyclerView都需要使用Adapter，并且在开发中我们遇到的优化问题、出错概率较大的地方也基本出自Adapter。</p>

<p>说到底，适配器是将两个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。例如，经常碰到要在两个没有关系的类型之间进行交互，第一个解决方案就是修改各自类的接口，但是如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时我们往往会使用一个Adapter，在这两种接口之间创建一个“混血儿”接口，这个Adapter会将这两个接口进行兼容，在不修改原有代码的情况下满足需求。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">适配器模式的定义</h2>

<p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>

<h2 id="toc_2">适配器模式的使用场景</h2>

<ol>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
<li>需要一个统一的输出接口，而输入端的类型不可预知。</li>
</ol>

<h2 id="toc_3">适配器模式应用的简单示例</h2>

<p>用电源接口做例子，笔记本电脑的电源一般都是用5V电压，但是我们生活中的电线电压一般都是220V。这个时候就出现了不匹配的状况，在软件开发中我们称之为接口不兼容，此时就需要适配器来进行一个接口转换。在软件开发中有一句话正好体现了这点：任何问题都可以加一个中间层来解决。这个层我们可以理解为这里的Adapter层，通过这层来进行一个接口转换就达到了兼容的目的。</p>

<p>在上述电源接口这个示例中，5V电压就是Target接口，220V电压就是Adapter类，而将电压从220V转换到5V就是Adapter。</p>

<h3 id="toc_4">类适配器模式</h3>

<pre class="line-numbers"><code class="language-java">//Target角色
public interface FiveVolt {
    public int getVolt5();
}

//Adapter角色，需要被转换的对象
public class Volt220 {
    public int getVolt220() {
        return 220;
    }
}

//Adapter角色，将220V的电压转换为5V的电压
public class VoltAdapter extends Volt220 implements FiveVolt {
    @Override
    public int getVolt5() {
        return 5;
    }
}
</code></pre>

<p>Target角色给出了需要的目标接口，而Adapter类则需要被转换的对象。Adapter则是将Volt220转换成Target的接口。对应的Target的目标是要获取5V的输出电压，而Adapter正常输出电压是220V，此时就需要电源适配器类将220V的电压转换为5V电压，解决接口不兼容的问题。</p>

<pre class="line-numbers"><code class="language-java">public class Test {
    public static void main(String[] args) {
        VoltAdapter adapter = new VoltAdapter();
        System.out.println(&quot;输出电压：&quot; + adapter.getVolt5());
    }
}
</code></pre>

<h3 id="toc_5">对象适配器模式</h3>

<p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adapter类，而使用代理关系连接到Adapter类。</p>

<pre class="line-numbers"><code class="language-java">/**
 * Target角色
 */
public interface FiveVolt {
    public int getVolt5();
}

/**
 * Adapter角色，需要被转换的对象
 */ 
public class Volt220 {
    public int getVolt220() {
        return 220;
    }
}

/**
 * 对象适配器模式
 */
public class VoltAdapter implements FiveVolt {
    Volt220 mVolt220;
    
    public VoltAdapter(Volt220 adapter) {
        mVolt220 = adapter;
    }
    
    public int getVolt220() {
        return mVolt220.getVolt220();
    }
    
    @Override
    public int getVolt5() {
        return 5;
    }
} 

public class Test {
    public static void main(String[] args) {
        VoltAdapter adapter = new VoltAdapter(new Volt220());
        System.out.println(&quot;输出电压：&quot; + adapter.getVolt5());
    }
}
</code></pre>

<p>这种实现方式直接将要被适配的对象传递到Adapter中，使用组合的形式实现接口兼容的效果。这比类适配器方式更为灵活，它的另一个好处是被适配对象中的方法不会暴露出来，而类适配器由于继承了被适配对象，因此，被适配对象类的函数在Adapter类中也都含有，这使得Adapter类出现一些奇怪的接口，用户使用成本较高。因此，对象适配器模式更加灵活、实用。<br/>
在实际开发中Adapter通常应用于进行不兼容的类型转换的场景，还有一种就是输入有无数种情况，但是输出类型是统一的，我们可以通过Adapter返回一个统一的输出，而具体的输入留给用户处理，内部只需知道输出的是符合要求的类型即可。在使用Adapter模式的过程中建议尽量使用对象适配器的实现方式，多用合成或者聚合，少用继承。</p>

<h2 id="toc_6">总结</h2>

<p>Adapter模式的经典实现在于将原本不兼容的接口融合在一起，使之能够很好地进行合作。但是，在实际开发中，Adapter模式也有一些灵活的实现。例如ListView中的隔离变化，使得整个UI架构变得更灵活，能够拥抱变化。Adapter模式在开发中运用非常广泛。因此，掌握Adapter模式是非常必要的。</p>

<p><strong>优点</strong></p>

<ul>
<li>更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>更好的扩展性: 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>过多地使用适配器，会让系统非常凌乱，不易整体把握。例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果出现太多这种情况，无异于一场灾难。因此，如果不是很有必要，可以不适用适配器，而是直接对系统进行重构。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[外观模式(门面模式)]]></title>
    <link href="http://adolph.cc/15711208032276.html"/>
    <updated>2019-10-15T14:26:43+08:00</updated>
    <id>http://adolph.cc/15711208032276.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">外观模式介绍</h2>

<p>外观模式(Facade)在开发过程中的运用频率非常高，尤其是在现阶段各种第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装API的常用手段，例如网络模块、ImageLoader模块等。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">外观模式定义</h2>

<p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p>

<h2 id="toc_2">外观模式的使用场景</h2>

<ol>
<li>为一个复杂子系统提供一个简单接口。子系统往往因为不断演化而变得越来越复杂，甚至可能被替换。大多数模式使用时都会产生更多、更小的类，在这使子系统更具可重用性的同时也更容易对子系统进行定制、修改，这种易变性使得隐藏子系统的具体实现变得尤为重要。Facade可以提供一个简单统一的接口，对外隐藏子系统的具体实现、隔离变化。</li>
<li>当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade接口进行通信，从而简化它们之间的依赖关系。</li>
</ol>

<h2 id="toc_3">外观模式的简单示例</h2>

<p>生活中使用外观模式的例子非常多，任何一个类似中央调度结构的组织都类似外观模式。</p>

<p>简单模拟一下手机的外观模式实现，首先我们建立一个MobilePhone类</p>

<pre class="line-numbers"><code class="language-java">public class MobilePhone {
    private Phone mPhone = new PhoneImpl();
    private Camera mCamera = new SamsungCamera();
    
    public void dail() {
        mPhone.dail();
    }
    
    public void voideoChat() {
        System.out.println(&quot;--&gt; 视频聊天接通中&quot;);
        mCamera.open();
        mPhone.dail();
    }
    
    public void hangup() {
        mPhone.hangup();
    }
    
    public void takePicture() {
        mCamera.open();
        mCamera.takePicture();
    }
    
    public void closeCamera() {
        mCamera.close();
    }
}
</code></pre>

<p>MobilePhone类中含有两个子系统，也就是拨号系统和拍照系统，MobilePhone将这两个系统封装起来，为用户提供一个统一的操作接口，也就是说用户只需要通过MobilePhone这个类就可以操作打电话和拍照这两个功能。用户不需要知道有Phone这个接口以及它的实现类是PhoneImpl，同样不需要知道Camera相关的信息，通过MobilePhone就可以包揽一切。</p>

<p>看看Phone接口和PhoneImpl</p>

<pre class="line-numbers"><code class="language-java">public interface Phone {
    //打电话
    public void dail();
    //挂断
    public void hangup();
}

class PhoneImpl implements Phone {
    @Override
    public void dail() {
        System.out.println(&quot;打电话&quot;);
    }
    
    @Override
    public void hangup() {
        System.out.println(&quot;挂断&quot;);
    }
}
</code></pre>

<p>Camera也是类似的实现</p>

<pre class="line-numbers"><code class="language-java">public interface Camera {
    public void open();
    public void takePicture();
    public void close();
}

class SamsungCamera implements Camera {
    @Override
    public void open() {
        System.out.println(&quot;打开相机&quot;);
    }
    
    @Override
    public void takePicture() {
        System.out.println(&quot;拍照&quot;);
    }
    
    @Override
    public void close() {
        System.out.println(&quot;关闭相机&quot;);
    }
}
</code></pre>

<p>测试代码</p>

<pre class="line-numbers"><code class="language-java">public class Test {
    public static void main(String[] args) {
        MobilePhone nexus6 = new MobilePhone();
        //拍照
        nexus6.takePicture();
        //视频聊天
        nexus6.videoChat();
    }
}
</code></pre>

<p>从上述代码中可以看到，外观模式就是统一接口封装。将子系统的逻辑、交互隐藏起来，为用户提供一个高层次的接口，使得系统更加易用，同时也对外隐藏了具体的实现，这样即使具体的子系统发生了变化，用户也不会感知到，因为用户使用的是Facade高层接口，内部的变化对于用户来说并不可见。这样一来就将变化隔离开来，使得系统也更为灵活。</p>

<h2 id="toc_4">总结</h2>

<p>外观模式是一个高频率使用的设计模式，它的精髓就在于封装二字。通过一个高层次结构为用户提供统一的API入口，使得用户通过一个类型就基本能够操作整个系统，这样减少了用户的使用成本，也能够提升系统的灵活性。</p>

<p><strong>优点</strong></p>

<ul>
<li>对客户程序隐藏子系统细节，因而减少了客户对于系统的耦合，能够拥抱变化</li>
<li>外观类对子系统的接口封装，使得系统更易于使用</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>外观类接口膨胀。由于子系统的接口都由外观类统一对外暴露，使得外观类的API接口较多，在一定程度上增加了用户使用成本</li>
<li>外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰模式]]></title>
    <link href="http://adolph.cc/15711023020774.html"/>
    <updated>2019-10-15T09:18:22+08:00</updated>
    <id>http://adolph.cc/15711023020774.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">装饰模式简介</h2>

<p>装饰模式(Decorator Pattern)也称为包装模式(Wrapper Pattern)，结构性设计模式之一，其使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">装饰模式的定义</h2>

<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。</p>

<h2 id="toc_2">装饰模式的使用场景</h2>

<p>需要透明且动态地扩展类的功能时。</p>

<h2 id="toc_3">模式的简单实现</h2>

<p>人总是要穿衣服的，我们将人定义为一个抽象类，将其穿衣的行为定义为一个抽象方法。</p>

<pre class="line-numbers"><code class="language-java">public abstract class Person {
    /**
     *  Person 下有一个穿着的抽象方法
     */
     public abstract void dressed(); 
}
</code></pre>

<p>该类就是抽象组件类，也就是我们需要装饰的原始对象，接下里实现一个具体的实现类。</p>

<pre class="line-numbers"><code class="language-java">public class Boy extends Person {
    @Override
    public void dressed() {
        // Boy类下dressed方法的基本逻辑
        System.out.println(&quot;穿了内衣内裤&quot;);
    }
}
</code></pre>

<p>Boy类继承于Person类，该类仅对Person中的dressed方法作了具体的实现，而Boy类则是我们所要装饰的具体对象，现在需要一个装饰者来装饰我们的这个Boy对象，这里定义一个PersonCloth类来表示人所穿着的衣服。</p>

<pre class="line-numbers"><code class="language-java">public abstract class PersonCloth extends Person {
    protected Person mPerson; //保持一个Person类的引用
    
    public PersonCloth(Person mPerson) {
        this.mPerson = mPerson;
    }
    
    @Override
    public void dressed() {
        //调用Person类中的dressed方法
        mPerson.dressed();
    }
}
</code></pre>

<p>在PersonCloth类中我们保持了一个对Person类的引用，可以方便地调用具体被装饰对象中的方法，这也是为什么我们可以在不破坏原类层次结构的情况下为类增加一些功能，我们只需要在被装饰对象的相应方法前或后增加相应的功能逻辑即可。</p>

<p>使用一个类ExpensiveCloth表示高档衣服</p>

<pre class="line-numbers"><code class="language-java">public class ExpensiveCloth extends PersonCloth {
    public ExpensiveCloth(Person person) {
        super(person);
    }
    
    /**
     * 穿短袖
     */
     private void dressShirt() {
        System.out.println(&quot;穿件短袖&quot;);
     } 
     
     /**
     * 穿皮衣
     */
     private void dressLeather() {
        System.out.println(&quot;穿件皮衣&quot;);
     }
     
     /**
     * 穿牛仔裤
     */
     private void dressJean() {
        System.out.println(&quot;穿条牛仔裤&quot;);
     }
     
     @Override
     public void dressed() {
        super.dressed();
        dressShirt();
        dressLeather();
        dressJean();
     }
}
</code></pre>

<p>使用CheapCloth表示便宜的衣服</p>

<pre class="line-numbers"><code class="language-java">public class CheapCloth extends PersonCloth {
    public CheapCloth(Person person) {
        super(person);
    }
    
    /**
     * 穿短裤
     */
     private void dressShorts() {
        System.out.println(&quot;穿条短裤&quot;);
     } 
        
     @Override
     public void dressed() {
        super.dressed();
        dressShorts();
     }
}
</code></pre>

<p>这两个类本质上没有区别，都是为Boy类中的dressed方法提供功能扩展，不过这个扩展并非是直接修改原有的方法逻辑或结构，更恰当地说，仅仅是在另一个类中将原有的方法和新逻辑进行封装整合。</p>

<p>在客户端中调用</p>

<pre class="line-numbers"><code class="language-java">public class Main {
    public static void main(String[] args) {
        //首先我们要有一个Person男孩
        Person person = new Boy();
        
        //然后为他穿上便宜的衣服
        PersonCloth clothCheap = new CheapCloth(person);
        clothCheap.dressed();
        
        //或穿上比较上档次的衣服
        PersonCloth clothExpensive = new ExpensiveCloth(person);
        clothExpensive.dressed();
    }
}
</code></pre>

<h2 id="toc_4">总结</h2>

<p>装饰模式和代理模式有点类似，容易把装饰看作时代理。装饰模式是以对客户端透明的方法扩展对象的功能，是继承关系的一个替代方案；而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[享元模式]]></title>
    <link href="http://adolph.cc/15710570199030.html"/>
    <updated>2019-10-14T20:43:39+08:00</updated>
    <id>http://adolph.cc/15710570199030.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">享元模式介绍</h2>

<p>享元模式是对象池的一种实现，它的英文名称叫做Flyweight,代表轻量级的意思。享元模式用来尽可能减少内存使用，它适合用于存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能，避免内存溢出等。</p>

<p>享元对象中的部分状态是可以共享，可以共享的状态称为内部状态，内部状态不会随着环境变化；不可共享的状态称为外部状态，它们会随着环境的改变而改变。在享元模式中会创建一个对象容器，在经典的享元模式中该容器为一个Map，它的键是享元对象的内部状态，它的值就是享元对象本身。客户端程序通过这个内部状态从享元工厂中获取享元对象，如果有缓存则使用缓存对象，否则创建一个享元对象并且存入容器中，这样一来就避免创建过多对象的问题。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">享元模式定义</h2>

<p>使用共享对象可有效地支持大量的细粒度的对象</p>

<h2 id="toc_2">享元模式的使用场景</h2>

<ol>
<li>系统中存在大量的相似对象</li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要缓冲池的场景</li>
</ol>

<h2 id="toc_3">享元模式的简单示例</h2>

<p>过年回家买火车票是一件很困难的事，无数人用刷票插件软件在向服务端发出请求，对于每一个请求服务器都必须做出应答。在用户设置好出发地和目的地之后，每次请求都返回一个查询的车票结果。当数以万计的人不间断在请求数据时，如果每次都重新创建一个查询的车票结果，那么必然会造成大量重复对象的创建、销毁，使得GC任务繁重、内存占用率居高不下。但是通过享元模式，我们将这些可以公用的对象缓存起来，在用户查询时优先使用缓存，如果没有缓存则重新创建。</p>

<p><strong>首先创建一个Ticket接口，该接口定义展示车票信息的函数</strong></p>

<pre class="line-numbers"><code class="language-java">public interface Ticket {
    public void showTicketInfo(String bunk);
}
</code></pre>

<p><strong>具体实现类TrainTicket</strong></p>

<pre class="line-numbers"><code class="language-java">class TrainTicket implements Ticket {
    public String from; //始发地
    public String to; //目的地
    public String bunk; //铺位
    public int price;
    
    TrainTicket(String from, String to) {
        this.from = from;
        this.to = to;
    }
    
    @Override
    public void showTicketInfo(String bunk) {
        price = new Random().nextInt(300);
        System.out.println(&quot;购买从&quot; + from + &quot;到&quot; + to + &quot;的&quot; + bunk + &quot;火车票,价格: &quot; + price);
    }
}
</code></pre>

<p><strong>返回车票数据的接口</strong></p>

<pre class="line-numbers"><code class="language-java">public class TicketFactory {
    public static Ticket getTicket(String from, String to) {
        return new TrainTicket(from, to);
    }
}
</code></pre>

<p>当遇到大量的请求时，这样的代码会造成大量的重复对象存在内存中，GC对这些对象的回收也会非常消耗资源。如果用户的请求量很大可能导致系统变得极其缓慢，设置可能导致OOM。</p>

<p>使用享元模式进行优化</p>

<pre class="line-numbers"><code class="language-java">//车票工厂，以出发地和目的地为key缓存车票
public class TicketFactory {
    static Map&lt;String, Ticket&gt; sTicketMap = new ConcurrentHashMap&lt;String, Ticket&gt;();
    
    public static Ticket getTicket(String from, String to) {
        String key = from + &quot;-&quot; + to;
        if (sTicketMap.containsKey(key)) {
            System.out.println(&quot;使用缓存 ==&gt;&quot; + key);
            return sTicketMap.get(key);
        } else {
            System.out.println(&quot;创建对象 ==&gt; &quot; + key);
            Ticket ticket = new TrainTicket(from, to);
            sTicketMap.put(key,ticket);
            return ticket;
        }
    }
}
</code></pre>

<p>这个map的键就是我们说的内部状态。如果没有缓存则创建一个对象，并且将这个对象缓存到map中，下次再有这类请求时直接从缓存中获取。</p>

<h2 id="toc_4">总结</h2>

<p>享元模式实现比较简单，但是它的作用在某些场景确实极其重要的。它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固话的特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>

<ul>
<li>享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li>
<li>享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android性能优化]]></title>
    <link href="http://adolph.cc/15705014806732.html"/>
    <updated>2019-10-08T10:24:40+08:00</updated>
    <id>http://adolph.cc/15705014806732.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Profile GPU Rendering</h2>

<p>这是手机开发的一个辅助工具。</p>

<p>功能特点：</p>

<ul>
<li>它是一个图形检测工具，能实时反应当前绘制的耗时。</li>
<li>横轴表示时间，纵轴表示每一帧的耗时。</li>
<li>随着时间推移，从左到右的刷新呈现。</li>
<li>提供了一个标准的耗时，如果高于标准耗时，表示当前这一帧丢失。</li>
</ul>

<p>打开Profile GPU Rendering后可以看到实时刷新的彩色图，每一根竖线表示一帧，由多个颜色组成。</p>

<span id="more"></span><!-- more -->

<ul>
<li>每一条柱状图都由4中颜色组成： 红、黄、蓝、紫，这些线对应每一帧在不同阶段的实际耗时。</li>
<li>蓝色代表测量绘制的时间，它代表需要多长时间去创建和更新DisplayList。蓝线很高时，有可能是因为需要重新绘制，或者自定义视图的onDraw函数处理事情太多。</li>
<li>红色代表执行时间，这部分时Android进行2D渲染Display List的时间，为了绘制到屏幕上，Android需要使用OpenGl ES的API接口来绘制Display List，这些API有效地将数据发送到GPU，最终在屏幕上显示出来。当红线非常高时，可能是重新提交了视图导致的。</li>
<li>橙色部分表示处理时间，或者是CPU告诉GPU渲染一帧的地方，是一个阻塞调用，因为CPU会一直等待GPU发出接到命令的回复。如果橙线很高，意味着GPU太繁忙。</li>
<li>紫色代表资源转移到渲染线程的时间。</li>
</ul>

<p>Profile GPU Rendering工具能很好地帮助你找到渲染相关的问题，但是要修复这些问题需要结合另一个耗时工具和代码来具体分析，找到性能瓶颈，并优化。</p>

<h2 id="toc_1">TraceView</h2>

<p>TraceView是AndroidSDK自带的工具，用来分析函数调用过程，可以对Android的应用程序及Framework层的代码进行性能分析。它是一个图形化的工具，最终会产生一个图表，用于对性能分析进行说明，可以分析到应用具体每一个方法的执行时间，使用可以非常直观简单，分析性能问题很方便。</p>

<h3 id="toc_2">使用方法</h3>

<p>在使用TraceView分析问题之前需要得到一个*.trace的文件，然后通过TraceView来分析trace文件的信息。</p>

<ul>
<li>在DDMS中使用(这种方法使用方便，但监控范围不够精确)
<ul>
<li>单击Start Method Profiling按钮</li>
<li>在应用中操作需要监控的点，比如进入一个Activity或者滑动一个列表，完成后单击Stop Method Profiling按钮</li>
<li>结束会自动跳转到TraceView视图</li>
</ul></li>
<li>代码中加入调试语句保存trace文件(要在应用中打开write to external storage权限)
<ul>
<li>在需要开始监控的地方调用Debug.startMethodTracing()</li>
<li>在需要结束监控的地方调用Debug.stopMethodTracing()</li>
<li>系统会在SD卡中创建<trace-name>.trace文件</li>
<li>使用traceview打开该文件进行分析。</li>
</ul></li>
</ul>

<h3 id="toc_3">TraceView视图说明</h3>

<p>上半部分为时间片面板，下半部分为分析面板。</p>

<ul>
<li>时间片面板
<ul>
<li>X轴表示时间消耗，单位为毫秒，Y轴表示各个线程，每个线程中的不同方法使用了不同的颜色来表示，颜色占用面积越宽，表示该方法占用CPU时间越长。</li>
<li>时间片面板可以放大/缩小，也可以指定区域放到最大，方便查看具体的过程，一半优先选择放大耗时严重的区域。</li>
</ul></li>
<li>分析面板</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: left">列名</th>
<th style="text-align: left">意义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Name</td>
<td style="text-align: left">所有的调用项，展开可以看到有的有Parent和Children子项，指被调用和调用</td>
</tr>
<tr>
<td style="text-align: left">Inclusive</td>
<td style="text-align: left">统计函数本身运行的时间 + 调用子函数运行的时间</td>
</tr>
<tr>
<td style="text-align: left">incl</td>
<td style="text-align: left">inclusive时间占总时间的百分比</td>
</tr>
<tr>
<td style="text-align: left">Exclusive</td>
<td style="text-align: left">统计函数本身运行的时间</td>
</tr>
<tr>
<td style="text-align: left">Excl</td>
<td style="text-align: left">执行占总时间的百分比</td>
</tr>
<tr>
<td style="text-align: left">Calls + Recur Calls/Total</td>
<td style="text-align: left">该方法调用次数 + 递归次数</td>
</tr>
<tr>
<td style="text-align: left">Cpu Time/Call</td>
<td style="text-align: left">该方法耗时</td>
</tr>
<tr>
<td style="text-align: left">Real Time/Call</td>
<td style="text-align: left">实际时长(包含了CPU的上下文切换、阻塞、GC等)</td>
</tr>
</tbody>
</table>

<p>使用TraceView查看耗时，主要关注Calls + Recur Calls / Total 和 Cpu Time / Call这两个值，也就是关注调用次数多和耗时久的方法，然后优化这些方法的逻辑和调用次数，减少耗时。</p>

<h2 id="toc_4">Systrace UI性能分析</h2>

<p>Systrace工具可以跟踪、收集、检查定时信息，可以很直观地查看CPU周期消耗的具体时间，显示每个线程和进程的跟踪信息，使用不同颜色来突出问题的严重性，并提供如何解决这些问题的建议。</p>

<h3 id="toc_5">Systrace的使用方法</h3>

<ul>
<li>在DDMS上使用
<ul>
<li>打开Android Device Monitor，连接手机并准备需要抓取的界面</li>
<li>单击Systrace按钮进入抓取前的设置，选择需要跟踪的内容</li>
<li>手机上开始操作需要跟踪的过程</li>
<li>到了设定好的时间后，生成Trace文件</li>
<li>使用Chrome打开文件即可分析</li>
</ul></li>
<li>使用命令行(使用命令行更灵活，速度更快，并且配置好后再使用能快速得到结果)
<ul>
<li><code>python systrace.py --time=10 -o mynewtrace.html sched gfx view wm</code></li>
</ul></li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: left">参数名</th>
<th style="text-align: left">意义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">-h, --help</td>
<td style="text-align: left">帮助信息</td>
</tr>
<tr>
<td style="text-align: left">-o <File></td>
<td style="text-align: left">保存的文件名</td>
</tr>
<tr>
<td style="text-align: left">-t N, --time=N</td>
<td style="text-align: left">多少秒内的数据，默认为5秒，以当前时间点往后倒N秒时间</td>
</tr>
<tr>
<td style="text-align: left">-b N, --buf-size=N</td>
<td style="text-align: left">单位为千字节，限制数据大小</td>
</tr>
<tr>
<td style="text-align: left">-k <KFUNCS>, --ktrace=<KFUNCS></td>
<td style="text-align: left">追踪特殊的方法</td>
</tr>
<tr>
<td style="text-align: left">-l, --list-categories</td>
<td style="text-align: left">设置需要追踪的标签</td>
</tr>
<tr>
<td style="text-align: left">-a <APP_NAME>, --app=<APP_NAME></td>
<td style="text-align: left">包名</td>
</tr>
<tr>
<td style="text-align: left">--from-file=<FROM_FILE></td>
<td style="text-align: left">创建报告的来源trace文件</td>
</tr>
<tr>
<td style="text-align: left">-e <DEVICE_SERIAL>, --serial=<DEVICE_SERIAL></td>
<td style="text-align: left">设备号</td>
</tr>
</tbody>
</table>

<p>category可取值：</p>

<table>
<thead>
<tr>
<th style="text-align: left">category</th>
<th style="text-align: left">解释</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">gfx</td>
<td style="text-align: left">Graphic系统的相关信息，包括SerfaceFlinger，VSYNC消息，Texture，RenderThread等；分析卡顿非常依赖这个。</td>
</tr>
<tr>
<td style="text-align: left">input</td>
<td style="text-align: left">Input</td>
</tr>
<tr>
<td style="text-align: left">view</td>
<td style="text-align: left">View绘制系统的相关信息，比如onMeasure，onLayout等。。</td>
</tr>
<tr>
<td style="text-align: left">webview</td>
<td style="text-align: left">WebView</td>
</tr>
<tr>
<td style="text-align: left">wm</td>
<td style="text-align: left">Window Manager</td>
</tr>
<tr>
<td style="text-align: left">am</td>
<td style="text-align: left">ActivityManager调用的相关信息；用来分析Activity的启动过程比较有效。</td>
</tr>
<tr>
<td style="text-align: left">sm</td>
<td style="text-align: left">Sync Manager</td>
</tr>
<tr>
<td style="text-align: left">audio</td>
<td style="text-align: left">Audio</td>
</tr>
<tr>
<td style="text-align: left">video</td>
<td style="text-align: left">Video</td>
</tr>
<tr>
<td style="text-align: left">camera</td>
<td style="text-align: left">Camera</td>
</tr>
<tr>
<td style="text-align: left">hal</td>
<td style="text-align: left">Hardware Modules</td>
</tr>
<tr>
<td style="text-align: left">app</td>
<td style="text-align: left">Application</td>
</tr>
<tr>
<td style="text-align: left">res</td>
<td style="text-align: left">Resource Loading</td>
</tr>
<tr>
<td style="text-align: left">dalvik</td>
<td style="text-align: left">虚拟机相关信息，比如GC停顿等。</td>
</tr>
<tr>
<td style="text-align: left">rs</td>
<td style="text-align: left">RenderScript</td>
</tr>
<tr>
<td style="text-align: left">bionic</td>
<td style="text-align: left">Bionic C Library</td>
</tr>
<tr>
<td style="text-align: left">power</td>
<td style="text-align: left">Power Management</td>
</tr>
<tr>
<td style="text-align: left">sched</td>
<td style="text-align: left">CPU调度的信息，非常重要；你能看到CPU在每个时间段在运行什么线程；线程调度情况，比如锁信息。</td>
</tr>
<tr>
<td style="text-align: left">binder_driver</td>
<td style="text-align: left">Binder驱动的相关信息，如果你怀疑是Binder IPC的问题，不妨打开这个。</td>
</tr>
<tr>
<td style="text-align: left">core_services</td>
<td style="text-align: left">SystemServer中系统核心Service的相关信息，分析特定问题用。</td>
</tr>
<tr>
<td style="text-align: left">irq</td>
<td style="text-align: left">IRQ Events</td>
</tr>
<tr>
<td style="text-align: left">freq</td>
<td style="text-align: left">CPU Frequency</td>
</tr>
<tr>
<td style="text-align: left">idle</td>
<td style="text-align: left">CPU Idle</td>
</tr>
<tr>
<td style="text-align: left">disk</td>
<td style="text-align: left">Disk I/O</td>
</tr>
<tr>
<td style="text-align: left">mmc</td>
<td style="text-align: left">eMMC commands</td>
</tr>
<tr>
<td style="text-align: left">load</td>
<td style="text-align: left">CPU Load</td>
</tr>
<tr>
<td style="text-align: left">sync</td>
<td style="text-align: left">Synchronization</td>
</tr>
<tr>
<td style="text-align: left">workq</td>
<td style="text-align: left">Kernel Workqueues</td>
</tr>
<tr>
<td style="text-align: left">memreclaim</td>
<td style="text-align: left">Kernel Memory Reclaim</td>
</tr>
<tr>
<td style="text-align: left">regulators</td>
<td style="text-align: left">Voltage and Current Regulators</td>
</tr>
</tbody>
</table>

<ul>
<li>应用中获取(通过Trace类来实现,Trace.beginSection()和Trace.endSection()之间的代码工作会一直被追踪)
<ul>
<li>在Trace被嵌套在另一个Trace中时，endSection()方法只会结束离它最近的一个beginSection()。所以要保证endSection()和beginSection()调用次数匹配。</li>
<li>Trace的begin和end必须在同一线程中执行。</li>
</ul></li>
</ul>

<h3 id="toc_6">分析Systrace报告</h3>

<p>获取到的trace.html文件，需要使用Chrome打开。</p>

<table>
<thead>
<tr>
<th style="text-align: center">快捷键</th>
<th style="text-align: center">功能</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">W</td>
<td style="text-align: center">放大</td>
</tr>
<tr>
<td style="text-align: center">S</td>
<td style="text-align: center">缩小</td>
</tr>
<tr>
<td style="text-align: center">A</td>
<td style="text-align: center">左移</td>
</tr>
<tr>
<td style="text-align: center">D</td>
<td style="text-align: center">右移</td>
</tr>
</tbody>
</table>

<p><figure><img src="media/15705014806732/15705059372276.jpg" alt=""/></figure></p>

<p>图表中和UI绘制关系最密切的是Alerts和Frame两个数据。</p>

<h4 id="toc_7">Alerts</h4>

<p>Alerts一栏标记了性能有问题的点，单击该点可以查看详细信息，在右边栏还有一个Alerts框，单击可以查看每个类型的Alerts的数量，单击某一个Alert卡伊看到问题的详细描述</p>

<h4 id="toc_8">Frame</h4>

<p>每个应用都有一行专门显示frame，每一帧就显示为一个绿色的圆圈。当显示为黄色或者红色时，它的渲染时间超过了16.6ms。使用W键放大，看看这一阵的渲染过程中系统到底做了什么。</p>

<h4 id="toc_9">小结</h4>

<p>如果想知道UI线程怎么会花费这么多时间的话，就需要用到TraceView来分析具体哪些函数在消耗时间。</p>

<h2 id="toc_10">Hierarchy Viewer</h2>

<p>Hierarchy Viewer是AndroidSDK自带的一款可视化调试工具，用来检查Layout嵌套及绘制时间，以可视化的布局角度直观获取Layout布局设计和各种属性信息，开发者在调试和布局UI界面时可以方便地使用，提高用户的开发效率。</p>

<h3 id="toc_11">打开Hierarchy Viewer</h3>

<ul>
<li>打开Android Device Monitor，直接打开Hierarchy Viewer。</li>
<li>从AndroidSDK工具包中，通过命令行的方式启动。</li>
</ul>

<h3 id="toc_12">使用Hierarchy Viewer查看层级和耗时</h3>

<p><figure><img src="media/15705014806732/15705080160712.jpg" alt=""/></figure></p>

<ul>
<li>1view 表示当前节点下的子View和其本身。1表示只有一个View，就是其自身。</li>
<li>Measure、Layout、Draw代表三个阶段的耗时。最后一个框有不同色的三个指示灯，分别对应当前控件在测量、布局以及画视图三个阶段，颜色表示这个控件占用时间的百分比。
<ul>
<li>绿色： 该控件在该阶段比其他50%的控件的速度要快</li>
<li>黄色： 该控件在该阶段比其他50%的控件的速度要慢</li>
<li>红色： 该控件在该阶段的处理速度最慢</li>
</ul></li>
</ul>

<p>由于一个应用的界面非常多，如果一个个这样分析的话效率非常低，所以通过检查所有页面的层级，并把深度高于N的界面输出，然后通过Hierarchy Viewer工具来仔细分析。</p>

<p>使用Lint扫描前，先配置需要检查的项目，只需要检查Layout层级深度。进入File -&gt; Settings -&gt; Inspections -&gt; Android Lint配置只扫描Layout的层级和View的个数。</p>

<ul>
<li>TooDeepLayout: 表示布局太深，默认层级超过10层会提示该问题，可以自定义环境变量ANDROID_LINT_MAX_DEPTH来修改。布局深度增加会导致内存消耗也随之增加，因此布局尽可能浅而宽。</li>
<li>TooManyViews: 表示控件太多，默认超过80个控件会提示该问题。</li>
</ul>

<h2 id="toc_13">布局优化方法</h2>

<p>优化的目的就是减少层级，让布局扁平化，以提高绘制的时间，提高布局的复用性节省开发和维护成本。</p>

<h3 id="toc_14">减少层级</h3>

<p>层级越少，测试和绘制的时间就越短</p>

<ul>
<li>合理使用RelativeLayout和LinearLayout
<ul>
<li>在布局中，RelativeLayout不如LinearLayout快。RelativeLayout会对子View做两次测量，导致性能偏低。</li>
<li>LinearLayout在使用weight属性的情况下，也会对自身进行两次测量，但因为没有更多的依赖关系，所以仍会比RelativeLayout的效率高。</li>
<li>LinearLayout可能会导致布局过深。布局层次深会增加内存消耗，甚至引出栈溢出等问题。</li>
<li>小结
<ul>
<li>尽量使用RelativeLayout和LinearLayout。</li>
<li>在布局层级相同的情况下，使用LinearLayout。</li>
<li>用LinearLayout有时会使嵌套层级变多，应该使用RelativeLayout，使界面尽量扁平化。</li>
</ul></li>
</ul></li>
<li>合理使用Merge
<ul>
<li>在自定义View中，父元素尽量是FrameLayout或者LinearLayout</li>
<li>Merge只能用在布局XML文件的根元素</li>
<li>使用merge来加载一个布局时，必须指定一个ViewGroup作为其父元素，并且要设置加载的attachToRoot参数为true</li>
<li>不能在ViewStub中使用Merge标签</li>
</ul></li>
</ul>

<h3 id="toc_15">提高显示速度</h3>

<p>ViewStub是一个轻量级的View，它是一个看不见的，并且不占布局位置，占用资源非常小的视图对象。可以为ViewStub指定一个布局，加载布局时，只有ViewStub会被初始化，然后当ViewStub被设置为可见时，或是调用了ViewStub.inflate()时，ViewStub所指向的布局会被加载和实例化，然后ViewStub的布局属性都会传给他指向的布局。</p>

<p><strong>注意点：</strong></p>

<ul>
<li>ViewStub只能加载一次，之后ViewStub对象会被置为空。</li>
<li>ViewStub只能用来加载一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</li>
<li><p>ViewStub不能嵌套Merge标签</p>
<p><strong>主要使用场景：</strong></p></li>
<li><p>在程序运行期间，某个布局在加载后，就不会有变化，除非销毁该页面再重新加载。</p></li>
<li><p>想要控制显示和隐藏的是一个布局文件，而非某个View。</p></li>
</ul>

<h3 id="toc_16">布局复用</h3>

<p>将代码公用部分提取出来，在使用的时候用<include>添加进去。</p>

<h3 id="toc_17">小结</h3>

<p>影响布局效率</p>

<ul>
<li>布局的层级越少，加载速度越快</li>
<li>减少同一层级控件的数量，加载速度会变快</li>
<li>一个控件的属性越少，解析越快</li>
</ul>

<p>优化总结</p>

<ul>
<li>尽量多使用RelativeLayout或LinearLayout，不要使用绝对布局AbsoluteLayout</li>
<li>将可复用的组件抽取出来并通过<include/>标签使用</li>
<li>使用<ViewStub/>标签加载一些不常用的布局</li>
<li>使用<merge/>标签减少布局的嵌套层次</li>
<li>尽可能少用wrap_content, wrap_content会增加布局measure时的计算成本，已知宽高为固定值时，不用wrap_content</li>
<li>删除控件中的无用属性</li>
</ul>

<h2 id="toc_18">过度绘制</h2>

<p>过度绘制(Overdraw)是指在屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的UI结构中，如果不可见的UI也在做绘制的操作，就会导致某些像素区域被绘制了多次，从而浪费多余的CPU以及GPU资源。</p>

<p>导致过度绘制的主要原因</p>

<ul>
<li>XML布局 -&gt; 控件有重叠且都有设置背景</li>
<li>View自绘 -&gt; View.onDraw里面同一个区域被绘制多次</li>
</ul>

<h3 id="toc_19">检测工具</h3>

<p>打开手机开发者模式中的Show GPU Overdraw选项，打开后会有不同的颜色区域表示不同的过度绘制次数。</p>

<ul>
<li>无色： 没有过度绘制，每个像素绘制了1次</li>
<li>蓝色： 每个像素多绘制了一次。</li>
<li>绿色： 每个像素多绘制了两次。</li>
<li>淡红： 每个像素多绘制了3次。一般来说，这个区域不超过屏幕的1/4是可以接受的。</li>
<li>深红： 每个像素多绘制了4次或者更多。严重影响性能，需要优化，避免深红色区域。</li>
</ul>

<h3 id="toc_20">如何避免过度绘制</h3>

<h4 id="toc_21">布局上优化</h4>

<ul>
<li>移除XML中非必须的背景，或根据条件设置</li>
<li>移除Window默认的背景</li>
<li>按需显示占位背景图片</li>
</ul>

<p>在Android自带的一些主题时，activity往往会被设置一个默认的背景，这个背景由DecorView持有，当自定义布局有一个全屏的背景时，比如设置了这个界面的全屏黑色背景，DecorView的背景此时对我们来说是无用的，但是它会产生一次Overdraw。因此没有必要的话，也可以移除。<code>this.getWindow().setBackgroundDrawable(null);</code>这段代码放到setContentView()之后</p>

<h4 id="toc_22">自定义View优化</h4>

<p>虽然自定义View减少了Layout的层级，但在实际绘制时也是会过度绘制的。可以通过canvas.clipRect()来帮助系统识别那些可见区域，这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。</p>

<h2 id="toc_23">启动优化</h2>

<p>借助ADB得到准确的启动时间。</p>

<p><code>adb shell am start -W [packageName]/[packageName.AppstartActivity]</code></p>

<p>执行后可以得到三个时间</p>

<ul>
<li>ThisTime: 一般和TotalTime时间一样。</li>
<li>TotalTime: 应用的启动时间，包括创建进程 + Application初始化 + Activity初始化到界面显示</li>
<li>WaitTime: 一般比TotalTime大些，包括系统影响的耗时</li>
</ul>

<p>也可以使用代码进行打点获得方法执行，以及生命周期的准确时间。</p>

<h3 id="toc_24">启动优化方案</h3>

<ol>
<li>UI布局： 优化第一个Activity的布局，检查是否掉帧，以及优化布局结构，避免过度绘制</li>
<li>启动加载逻辑优化： 采取分步加载、异步加载、延期加载策略</li>
</ol>

<h2 id="toc_25">合理的刷新机制</h2>

<ul>
<li>尽量减少刷新次数</li>
<li>尽量避免后台有高CPU线程运行</li>
<li>缩小刷新区域</li>
</ul>

<h3 id="toc_26">减少刷新次数</h3>

<ul>
<li>控制刷新频率(避免频繁的刷新)</li>
<li>避免没有必要的刷新</li>
</ul>

<h3 id="toc_27">避免后台线程的影响</h3>

<p>后台线程虽然不会直接影响主线程，但如果后台线程开销很大，占用CPU过高，导致系统GC频繁和CPU时间片资源紧张，还是可能会导致页面卡顿。比如ListView滚动过程中可以监听onScrollStateChanged事件，在滚动时暂停图片下载线程工作，结束后再开始，可以提高ListView的滚动平滑度。</p>

<h3 id="toc_28">缩小刷新区域</h3>

<p>采用局部刷新</p>

<ul>
<li>使用<code>invalidate(Rect dirty);</code> <code>invalidate(int left, int top, int right, int bottom);</code></li>
<li>刷新List中单个Item</li>
</ul>

<h2 id="toc_29">提升动画性能</h2>

<ul>
<li>使用属性动画比补间动画重绘次数更少</li>
<li>对可以开启硬件加速的控件，开启硬件加速，会大幅提升动画流畅度。</li>
</ul>

<h2 id="toc_30">Memory Monitor</h2>

<p>Memory Monitor 是一款使用非常简单的图形化工具，可以很好地监控系统或应用的内存使用情况。</p>

<ul>
<li>显示可用和已用内存，并且以时间为维度实时反映内存分配和回收情况。</li>
<li>快速判断应用程序的运行缓慢是否是由于过度的内存回收导致。</li>
<li>快速判断应用是否是由于内存不足导致程序崩溃</li>
</ul>

<p>使用场景</p>

<ul>
<li>内存分配与释放： 观察是否触发了系统GC之后，迅速释放了一大块内存，判断是否为合理分配内存。</li>
<li>大内存申请与内存抖动： 内存抖动一般在很短时间内发生了多次的内存分配和释放，并且通常在发生严重内存抖动时，也能感觉到应用卡顿。</li>
</ul>

<h2 id="toc_31">Allocation Tracker</h2>

<p>Memory Monitor可以很直观且实时地监控内存使用情况，还能发现内存问题，但发现内存问题后不能再进一步找到原因。这个时候就需要Allocation Tracker进行更详细的分析， Allocation Tracker可以分配跟踪记录应用程序的内存分配，并列出它们的调用堆栈，可以查看所有对象内存分配的周期。</p>

<p><strong>主要功能：</strong></p>

<ul>
<li>在一段时间内以对象类型为纬度，跟踪在此时间内的内存分配和释放情况。</li>
<li>寻找代码中内存使用不合理的地方。</li>
</ul>

<h3 id="toc_32">使用</h3>

<ul>
<li>在Memory Monitor视图中单击启动追踪按钮(Start Allocation Tracking)</li>
<li>操作应用，怀疑有内存泄漏或者内存变化较大的操作</li>
<li>单击结束追踪按钮</li>
<li>自动生成一个alloc结尾的文件，这个文件记录了这次追踪到的所有内存数据，并且在AndroidStudio中自动打开一个数据面板，显示当前生成alloc文件的内存数据。</li>
</ul>

<h3 id="toc_33">查看面板数据</h3>

<p>整个面板分为两个区域，上面是内存对象列表，下面是对象引用堆栈。</p>

<p><strong>内存对象列表</strong></p>

<table>
<thead>
<tr>
<th style="text-align: center">列名</th>
<th style="text-align: center">数据意义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Allocation Order</td>
<td style="text-align: center">内存分配序列</td>
</tr>
<tr>
<td style="text-align: center">Allocation Class</td>
<td style="text-align: center">被分配的内存对象</td>
</tr>
<tr>
<td style="text-align: center">Allocation Size</td>
<td style="text-align: center">分配的内存大小</td>
</tr>
<tr>
<td style="text-align: center">Thread ID</td>
<td style="text-align: center">分配该内存的线程ID</td>
</tr>
<tr>
<td style="text-align: center">Allocation Site</td>
<td style="text-align: center">分配该对象的方法</td>
</tr>
</tbody>
</table>

<p><strong>对象引用堆栈</strong><br/>
在内存对象列表中，选中某一个对象后，在下面的窗口显示调用堆栈，单击具体的堆栈可以进入具体的代码行。</p>

<h2 id="toc_34">Memory Analyzer Tool(MAT)</h2>

<h3 id="toc_35">使用步骤</h3>

<p><strong>下载MAT</strong><br/>
下载地址为<a href="https://eclipse.org/mat/downloads.php">MAT</a></p>

<p><strong>获取HPROF文件</strong><br/>
在Android Studio的Memory Monitor工具中，单击Dump Java Heap按钮，在左侧的Capture栏中的Heap Snapshot列表中看到Dump下来的HPROF文件，右击文件，在弹出的菜单中选择Export to standard.hprof选择项，即可转换成标准的HPROF文件，再使用MAT打开</p>

<h3 id="toc_36">MAT视图</h3>

<p><figure><img src="media/15705014806732/15705260859637.jpg" alt=""/></figure></p>

<p>在MAT窗口上，OverView是一个总体概览，显示总体的内存消耗情况和疑似问题。MAT提供了多种分析维度，其中Histogram、Dominator Tree、Top Consumers和Leak Suspects的分析维度不同。分析内存最常用的是Histogram、Dominator Tree。</p>

<ul>
<li>Histogram(列出内存中的所有实例类型对象、对象的个数以及大小，并支持正则表达式查找)</li>
<li>Dominator Tree(列出最大的对象及其依赖存活的Object。分析流程和Histogram大同小异，但Dominator Tree能更方便地看出引用关系)</li>
<li>Top Consumers(通过图形列出最大的Object)</li>
<li>Leak Suspects(通过MAT自动分析泄漏的原因和泄漏的一份总体报告)</li>
</ul>

<p>一般在Histogram、Dominator Tree视图中分析内存是否异常。</p>

<ul>
<li>Class Name: 类名</li>
<li>Objects: 对象实例个数</li>
<li>Shallow Heap: 对象自身占用的内存大小，不包括它引用的对象。对分析内存泄漏意义不是很大。</li>
<li>Retained Heap: 是当前对象大小与当前对象可直接或间接引用到的对象的大小综合，包括被递归释放的。Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存大小。</li>
</ul>

<h3 id="toc_37">常见内存泄漏场景</h3>

<ol>
<li>资源性对象未关闭： 资源型对象(如Cursor，File文件)往往都用了一些缓冲，在不使用时，应该及时关闭它们，以便它们的缓存数据能够及时回收。</li>
<li>注册对象未注销： 如果事件注册后未注销，会导致观察者列表中维持着对象的引用，阻止垃圾回收，一般发生在注册广播接收器、注册观察者等。</li>
<li>类的静态变量持有大数据对象</li>
<li>非静态内部类的静态实例</li>
<li>Handler临时性内存泄漏</li>
<li>容器中的对象没清理造成的内存泄漏(集合、队列)</li>
<li>WebView</li>
</ol>

<h2 id="toc_38">优化内存空间</h2>

<p>Android系统对每个应用进程也都分配了有限的堆内存，因此使用最小内存的对象或者资源可以减少内存开销，同时让GC能更高效地回收不再需要使用的对象，让应用堆内保持充足的可用内存，使应用更稳定高效地运行。</p>

<h3 id="toc_39">对象引用</h3>

<h4 id="toc_40">强引用</h4>

<p>强引用是使用最普遍的引用。如果一个对象具有强引用，垃圾回收器就绝不会回收它。因此，如果强引用对象在应用的生命周期中不再需要使用，一定要记得释放或转成弱引用，以便让系统回收。</p>

<h4 id="toc_41">软引用</h4>

<p>软引用在保持引用对象的同时，保证在虚拟机报告内存不足的情况之前，清除所有的软引用。垃圾收集器在运行时可能会(也可能不会)释放软引用对象。对象是否被释放取决于垃圾收集器的算法以及垃圾收集器运行时可用的内存数量。软引用可用来实现内存敏感的高速缓存。</p>

<h4 id="toc_42">弱引用</h4>

<p>弱引用类的一个典型用途就是规范化映射。对于那些生存期相对较长，而且重新创建的开销也不高的对象来说，弱引用也比较有用。<br/>
弱引用和软引用的区别在于： 只具有弱引用的对象拥有更短暂的生命周期。</p>

<h4 id="toc_43">虚引用</h4>

<p>虚引用类只用于跟踪即将被引用对象进行的收集。必须和ReferenceQueue类联合使用。</p>

<h3 id="toc_44">减少不必要的内存开销</h3>

<h4 id="toc_45">AutoBoxing</h4>

<p>避免AutoBoxing带来的效率问题，使用TraceView查看耗时，如果发现调用了大量的integer.value，就说明发生了AutoBoxing，需要立即优化代码。</p>

<h4 id="toc_46">内存复用</h4>

<h5 id="toc_47">有效利用系统自带的资源</h5>

<p>Android系统本身内置了大量的资源，比如一些通用的字符串，颜色自定义，常用Icon图片，还有些动画和页面的样式以及简单布局。直接使用系统资源不仅可以在一定程度上减少内存的开销，还可以减少应用程序的自身负重，减小APK的大小，并且复用性更好。</p>

<h5 id="toc_48">视图复用</h5>

<p>出现大量重复子组件，而子组件是大量重复的，可以使用ViewHolder实现ConvertView复用。</p>

<h5 id="toc_49">对象池</h5>

<p>可以在设计程序时显示地在程序中创建对象池，然后实现复用逻辑，对相同的类型数据使用同一块内存空间，也可以利用系统框架既有的具有复用特性的组件减少对象的重复创建，从而减少内存的分配与回收。</p>

<h5 id="toc_50">Bitmap对象的复用</h5>

<p>利用Bitmap的inBitmap的高级特性，提高Android系统在Bitmap的分配与释放效率，不仅可以达到内存复用，还提高了读写速度。</p>

<h4 id="toc_51">使用最优的数据类型</h4>

<p>Android应用开发，大部分使用Java语言编程，其中的很多数据结构和类型不一定是最省内存的。Android针对移动开发提出了一系列的数据类容器结构优化。</p>

<h5 id="toc_52">HashMap与ArrayMap</h5>

<p>虽然HashMap非常有用，但它并不是最节约的容器，会占用大量内存。ArrayMap虽然性能相比更差，但是占用空间方面有很大优势。</p>

<ul>
<li>当对象的数目非常小(1000以内)， 但是访问特别多，或者删除和插入频率不高时</li>
<li>当有映射容器，有映射发生，并且所有映射的容器也是ArrayMap时。</li>
</ul>

<h5 id="toc_53">枚举类型</h5>

<p>使用注解的方式检查类型安全代替枚举类型。IntDef和StringDef，用来提供编译期的类型检查。</p>

<h5 id="toc_54">LruCache</h5>

<p>LruCache，可以翻译为最近最少使用缓存，它用强引用保存需要缓存的对象，内部维护一个队列。</p>

<p><strong>比较重要的几个方法</strong></p>

<ul>
<li><code>public final V get (K key)</code>返回cache中key对应的值，调用这个方法后，被访问的值会移动到队列的尾部</li>
<li><code>public final V put (K key, V value)</code>根据key存放value，存放的value会移动到队列的尾部</li>
<li><code>protected int sizeOf(K key, V value)</code>返回每个缓存对象的大小，用来判断缓存是否快要满了，这个方法必须重写</li>
<li><code>protected void entryRemoved (boolean evicted, K key, V oldValue, V newValue)</code>当一个缓存对象被丢弃时调用该方法，这是个空方法，可以重写。第一个参数为true， 缓存对象是为了腾出空间而被清理。第一个参数为false，缓存对象的entry被remove移除或者被put覆盖时。</li>
</ul>

<p>使用LruCache时注意Lruache的容量，既不能太大，太大会造成其他可用内存变小，容易导致OOM，但又不能太小，否则起不到缓存的作用。</p>

<p>分配LruCache大小时考虑应用剩余内存有多大</p>

<ul>
<li>一次屏幕显示多少张图片，有多少张图片是缓存起来准备显示地。</li>
<li>考虑设备的分辨率和尺寸，缓存相同的图片数，收集的dpi越大，需要的内存也越大。</li>
<li>图片分辨率和像素质量决定了占用内存的大小。</li>
<li>图片访问的频繁程度是多少，如果存在多个不同要求的图片类型，可以考虑用多个LruCache来做缓存，案遭访问的频率分配到不同的LruCache中。</li>
</ul>

<h4 id="toc_55">图片内存优化</h4>

<p>Android中显示图片和图片文件的大小无关，在Android设备上显示前需要把图片解码成位图格式，而位图格式只和位图的属性相关，压缩格式仅仅是减小了文件大小。</p>

<p>一张图片占用的内存 = 图片长度 * 图片宽度 * 单位像素占用的字节数</p>

<h5 id="toc_56">设置位图规格</h5>

<table>
<thead>
<tr>
<th style="text-align: center">Format</th>
<th style="text-align: center">Bits Per Pixel</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">ARGB_8888</td>
<td style="text-align: center">32</td>
</tr>
<tr>
<td style="text-align: center">RGB_565</td>
<td style="text-align: center">16</td>
</tr>
<tr>
<td style="text-align: center">ARGB_4444</td>
<td style="text-align: center">16</td>
</tr>
<tr>
<td style="text-align: center">ALPHA_8</td>
<td style="text-align: center">8</td>
</tr>
</tbody>
</table>

<p>Alpha_8格式主要用于Alpha通道模板，相当于做一个染色。图像要渲染两次，虽然减少内存，但增加了绘制的开销。</p>

<pre class="line-numbers"><code class="language-java">BitmapFactory.Options options = new BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.RGB_565;
BitmapFactory.decodeStream(is,null,options);
</code></pre>

<h5 id="toc_57">inSampleSize</h5>

<p>如果内存中的图片大于屏幕显示出的图片大小，或者大于指定屏幕区域的大小，这些高分辨率图片会导致严重的性能问题。使用inSampleSize可以重置这些图片大小，让它们符合实际显示的大小，既能减小内存的开销，也能提高显示的效率。</p>

<pre class="line-numbers"><code class="language-java">BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 4;
BitmapFactory.decodeStream(is,null,options);
</code></pre>

<p>inSampleSize为2时获得只有1/2大小的图片，设置为4就是1/4大小的图片。图片总会比原始图片小一倍以上。</p>

<h5 id="toc_58">inScaled,inDensity和inTargetDensity</h5>

<p>虽然inSampleSize可以实现图片的缩放，都是指数幂的缩放。如果想要更细地缩放图片，就需要使用位图的inScaled,inDensity和inTargetDensity功能。</p>

<pre class="line-numbers"><code class="language-java">BitmapFactory.Options options = new BitmapFactory.Options();
options.inScaled = true;
options.inDensity = srcWidth;
options.inTargetDensity = dstWidth;
BitmapFactory.decodeStream(is,null,options);
</code></pre>

<p>当inScaled设置为true时，系统会按照现有的密度来划分目标密度。当这些属性的设置会因为使用过多的算法，导致更多的时间开销。所以最好结合使用，达到最佳的性能结合。</p>

<pre class="line-numbers"><code class="language-java">BitmapFactory.Options options = new BitmapFactory.Options();
options.inJustDecodeBounds = true;
BitmapFactory.decodeStream(is, null, options);
options.inScaled = true;
options.inDensity = options.outWidth;
options.inSampleSize = 4;
options.inTargetDensity = dstWidth * options.inSampleSize;
options.inJustDecodeBounds = false;
BitmapFactory.decodeStream(is,null,options);
</code></pre>

<h5 id="toc_59">inBitmap</h5>

<p>如果设置了该属性，那么当使用了该带有Options参数的decode方法加载内容时，decode方法会尝试重用一个已存在的位图。</p>

<h2 id="toc_60">Crash监控</h2>

<p>Crash是由于代码异常而导致App非正常退出，导致应用程序无法继续使用，所有工作都停止的现象。<br/>
要降低Crash发生的概率，需要Crash监控和发生Crash时的堆栈信息，开发者拿到这些信息后分析导致Crash的原因并修复。</p>

<h3 id="toc_61">Java层Crash监控</h3>

<p>在Android中，Java虚拟机为每个进程都设置了一个默认UncaughtExceptionHandler，用于处理本进程中未被try catch的Exception。因此只要实现了UncaughtExceptionHandler接口，并在进程启动时调用Thread.setDefaultUncaughtExceptionHandler()传入自定义UncaughtExceptionHandler。当出现没被catch的异常时，就会回调uncaughtException(Thread thread, Throwable ex)方法，可以在这里记录crash日志，并上报给服务器，也可以执行一些个性化的异常处理操作。</p>

<h3 id="toc_62">Crash上报机制</h3>

<p>不管是Java层，还是Native导致了Crash，因为应用已经异常了，所以放生Crash后，尽量先保存日志到本地，在下一次网络正常时再上传日志。</p>

<h2 id="toc_63">ANR剖析</h2>

<p>ANR也是Android应用程序无法继续运行的一种异常，一般是应用处理长时间没有结果响应导致主进程不能处理下一件事情。</p>

<ol>
<li>KeyDispathTimeout: 最常见的ANR类型是对输入事件5s内无响应。</li>
<li>BroadcastTimeout: BroadcastReceiver在指定时间(原生系统默认是10s)内无法处理完成，并且没有结束执行onReceive。</li>
<li>ServiceTimeout: 这种类型在Android应用中出现的概率很小，是指Service在特定的时间(原生系统是20s)内无法处理完成。</li>
</ol>

<h3 id="toc_64">ANR分析</h3>

<p>在Android系统上，如果发生ANR，Logcat会产生对应的日志和一个trace文件。</p>

<p><strong>Logcat信息</strong></p>

<ul>
<li>ANR IN: 发生ANR的具体类</li>
<li>PID: 发生ANR的进程，系统在此时会生成trace文件，当前的时间点也是发生ANR的具体时间，以及生成trace文件的时间</li>
<li>Reason: 当前ANR的类型以及导致ANR的原因</li>
<li>CPU usage: CPU的使用情况，在日志中CPU usage有两个时间点，第一个是发生ANR前的CPU使用情况，第二个是发生ANR后的CPU使用情况。</li>
</ul>

<p><strong>trace文件</strong></p>

<p>在Android Studio上使用Analyze Stacktrace对trace文件进行分析。</p>

<p><strong>使用方法</strong></p>

<ol>
<li>在Android Studio的工具栏中，选择Analyze -&gt; Analyze Stacktrace， 打开Analyze Stacktrace工具窗口</li>
<li>将traces.txt中的内容复制到窗口，单击Normalize按钮，生成Thread Dump列表</li>
<li>如果某个线程被标红，说明此线程被堵塞了，然后在右边的详细信息中查看堵塞的具体原因。</li>
</ol>

<h3 id="toc_65">ANR监控</h3>

<p>卡顿监控可以通过一个子线程向主线程发消息，通过时间差来判断是否发生卡顿。</p>

<h2 id="toc_66">提高后台进程存活率</h2>

<p>在Android系统中，应用进程停止运行有以下几个原因：</p>

<ul>
<li>用户主动退出</li>
<li>Crash异常退出</li>
<li>系统通过杀掉进程回收内存</li>
</ul>

<p>虽然系统通过杀掉进程回收内存能更好的为其他应用提供内存，但对体验会有一点影响。</p>

<h3 id="toc_67">应用进程优先级</h3>

<ul>
<li><strong>NATIVE_ADJ = -17:</strong> 系统创建的Native进程</li>
<li><strong>SYSTEM_ADJ = -16:</strong> 系统进程，在运行的过程中永远不会杀掉</li>
<li><strong>PERSISTENT_PROC_ADJ = -12:</strong> 核心进程，系统不会杀掉这类进程，但即使杀掉，影响面也没有SYSTEM_ADJ进程那么严重</li>
<li><strong>PERSISTENT_SERVICE_ADJ = -11:</strong> 正在运行的服务进程，一般不会杀掉</li>
<li><strong>FOREGROUND_APP_ADJ = 0:</strong> 前台进程，是指正在前台运行的应用，被杀概率不大</li>
<li><strong>VISIBLE_APP_ADJ = 1:</strong> 可见进程，用户正在使用，或者有界面在显示，除非出现异常，否则系统不会杀掉这类进程</li>
<li><strong>PERCEPTIBLE_APP_ADJ = 2:</strong> 可感知的进程，虽然不在前台，但应用进程还在状态，系统除非到内存非常紧张才会杀掉这类进程，比如播放音乐的应用</li>
<li><strong>BACKUP_APP_ADJ = 3:</strong> 正在备份的进程</li>
<li><strong>HEAVY_WEIGHT_APP_ADJ = 4:</strong> 高权重进程</li>
<li><strong>SERVICE_ADJ = 5:</strong> 有Service进程</li>
<li><strong>HOME_APP_ADJ = 6:</strong> 与Home有交互进程。比如widget小挂件之类，一般尽量避免杀掉此类进程</li>
<li><strong>PREVIOUS_APP_ADJ = 7:</strong> 切换进程，可以理解为从可见进程切换过来的进程的状态</li>
<li><strong>CACHED_APP_ADJ = 8:</strong> 缓存进程，也就是空进程</li>
<li><strong>SERVICE_B_ADJ = 9:</strong> 不活跃的进程</li>
<li><strong>HIDDEN_APP_MIN_ADJ = 15:</strong> 缓存进程，空进程，在内存不足的情况下会被优先杀掉</li>
<li><strong>UNKNOWN_ADJ = 16:</strong> 最低级别进程，只有缓存的进程，才有可能设置这个级别</li>
</ul>

<p>当内存不足时，进程优先级低的、占内存大的App进程将会被优先杀掉，系统杀进程的规则如下：</p>

<ul>
<li>进程优先级设置为PERSISTENT_PROC_ADJ被杀概率较低</li>
<li>进程优先级HEAVY_WEIGHT_APP_ADJ，这种是Activity仅次于主进程，系统认为是高权重进程</li>
<li>前台进程FOREGROUND_APP_ADJ不会被杀掉</li>
<li>当Activity、Service的生命周期发生变化时都会调整进程的优先级</li>
<li>进程中没有任何Activity存在会优先被杀</li>
<li>空进程最容易被杀</li>
</ul>

<h3 id="toc_68">提高进程优先级</h3>

<ul>
<li><strong>网络连接:</strong> 通过长连接和进程保持通信，使进程保持活动状态，但是如果系统内存非常紧张，也有可能被杀。</li>
<li><strong>利用系统现有机制:</strong> 一般可以注册系统消息，通过系统消息响应挂起进程</li>
<li><strong>SyncAdapter:</strong> 利用Android系统提供的账号同步机制实现进程优先级提高</li>
</ul>

<h2 id="toc_69">耗电优化</h2>

<h3 id="toc_70">耗电检测工具</h3>

<p>Android5.0引入了一个专门获取设备电量消耗信息的API: Battery Historian</p>

<p>Battery Historian是一款由Google提供的Android系统电量分析工具，和Systrace一样，是一款图形化数据分析工具，直观地展示出手机的电量消耗过程，通过输入电量分析文件，显示消耗情况，最后提供一些可供参考电量优化的方法。</p>

<h4 id="toc_71">Battery Historian使用步骤</h4>

<ol>
<li><strong>初始化Battery Historian</strong>使用以下两个adb命令<code>adb shell dumpsys batterystats --enable full-wake-history</code>, <code>shell dumpsys batterystats --reset</code></li>
<li>初始化完成后，操作需要测试电量的一些场景</li>
<li><strong>保存数据</strong> 运行以下命令将bugreport信息保存为bugreport.txt文件 <code>adb bugreport &gt; bugreport.txt</code> 成功后打开bugreport.txt，可以看到应用的耗电数据。(虽然数据很详细，但可读性差，因此需要生成可读性更高的html格式)</li>
<li><strong>生成HTML报告</strong> <code>python historian.py -a bugreport.txt &gt; battery.html</code> historian.py脚本可以从Github上下载，<a href="https://github.com/google/battery-historian">下载地址</a></li>
<li>使用Chrome打开生成的HTML文件，即可查看详细的报告</li>
</ol>

<h4 id="toc_72">报告参数解析</h4>

<p>横坐标表示时间周期，以60s为一个时间周期，刻度上的时间单位是秒。其中起始时间就是前面初始化的时间，结束时间是获取bugreport的时间，而纵坐标就是各项具体的指标。</p>

<p>Android5.0 Battery Historian属性</p>

<table>
<thead>
<tr>
<th style="text-align: left">属性</th>
<th style="text-align: left">意义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">battery-level</td>
<td style="text-align: left">电量，显示出电量的变化。</td>
</tr>
<tr>
<td style="text-align: left">plugged</td>
<td style="text-align: left">充电状态，是否进行了充电，以及充电的时间范围</td>
</tr>
<tr>
<td style="text-align: left">screen</td>
<td style="text-align: left">屏幕状态，屏幕是否点亮</td>
</tr>
<tr>
<td style="text-align: left">top</td>
<td style="text-align: left">处于最上层的应用，可以通过此栏信息来判断是哪个应用程序对手机电量的影响，同时也得到该应用的耗电量信息。同时也记录了应用启动和运行的时间</td>
</tr>
<tr>
<td style="text-align: left">wake_lock</td>
<td style="text-align: left">记录wake_lock模块的工作时间</td>
</tr>
<tr>
<td style="text-align: left">running</td>
<td style="text-align: left">界面的状态，可以判断应用在无操作状态下电量的消耗</td>
</tr>
<tr>
<td style="text-align: left">wake_lock_in</td>
<td style="text-align: left">记录模块开始工作以及工作的时间</td>
</tr>
<tr>
<td style="text-align: left">data_conn</td>
<td style="text-align: left">数据连接方式的改变，比如2G/3G和Wi-Fi之间的切换</td>
</tr>
<tr>
<td style="text-align: left">status</td>
<td style="text-align: left">电池状态，如充电、放电和已充满等</td>
</tr>
<tr>
<td style="text-align: left">phone_signal_strength</td>
<td style="text-align: left">手机信号状态</td>
</tr>
<tr>
<td style="text-align: left">plug</td>
<td style="text-align: left">充电方式</td>
</tr>
</tbody>
</table>

<p>Android 6.0 新增属性</p>

<table>
<thead>
<tr>
<th style="text-align: center">属性</th>
<th style="text-align: center">意义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Gps</td>
<td style="text-align: center">是否开启GPS</td>
</tr>
<tr>
<td style="text-align: center">Sync</td>
<td style="text-align: center">是否和后台同步</td>
</tr>
<tr>
<td style="text-align: center">Mobile_radio</td>
<td style="text-align: center">是否开启Radio</td>
</tr>
<tr>
<td style="text-align: center">Wake_reason</td>
<td style="text-align: center">被唤醒的原因</td>
</tr>
<tr>
<td style="text-align: center">Phone_in_call</td>
<td style="text-align: center">是否进行通话</td>
</tr>
</tbody>
</table>

<h3 id="toc_73">三大模块省电优化</h3>

<h4 id="toc_74">显示</h4>

<p>一般屏幕材质分为LCD和OLED，LCD和OLED这两种屏幕从发光方式上有着本质的区别，一种是靠外部光源照亮，一种是自发光。LCD当亮度一定，不论什么颜色耗电相同；OLED显示深色比浅色更省电。</p>

<h4 id="toc_75">网络</h4>

<p>移动设备的网络连接方式分为移动运营网络和Wi-Fi，一般使用Wi-Fi比移动网络功耗低。</p>

<p><strong>优化网络方案</strong></p>

<ul>
<li>使用Wi-Fi传输数据时，应尽可能增大每个包的大小，并降低发包的频率。</li>
<li>在蜂窝移动网络下，最好做到批量执行网络请求，尽量避免频繁的间隔网络请求。</li>
<li>尽量在Wi-Fi环境下使用数据传输</li>
<li>使用效率高的数据格式和解析方法，尽可能使用Protobuf。</li>
<li>压缩数据格式，比如采用GZIP压缩，虽然解压缩需要消耗更多的CPU，但可以明显提高下载速度，使网络传输更快结束，可以节省更多的电量，并提高数据的获取速度。</li>
</ul>

<h4 id="toc_76">CPU</h4>

<p>减少CPU的开销</p>

<h3 id="toc_77">应用常用优化方案</h3>

<h4 id="toc_78">计算优化</h4>

<p>避开浮点运算的优化方法</p>

<ul>
<li>除法变乘法</li>
<li>充分利用移位</li>
<li>查表发，直接使用映射关系，但这会增加内存开销</li>
<li>利用arm neon指令集做并行运算</li>
</ul>

<h4 id="toc_79">避免WakeLock使用不当</h4>

<p>合理使用PowerManager的WakeLock，避免导致严重的耗电问题</p>

<ul>
<li><strong>PARTIAL_WAKE_LOCK</strong>: 保持CPU正常运转，屏幕和键盘灯有可能会关闭</li>
<li><strong>SCREEN_DIM_WAKE_LOCK</strong>: 保持CPU运转，允许保持屏幕显示但有可能变暗，允许关闭键盘灯。</li>
<li><strong>SCREEN_BRIGHT_WAKE_LOCK</strong>: 保持CPU运转，允许保持屏幕高亮显示，允许关闭键盘灯</li>
<li><strong>FULL_WAKE_LOCK</strong>: 保持CPU运转，保持屏幕高亮显示，键盘灯也保持亮度</li>
<li><strong>ACQUIRE_CAUSES_WAKEUP</strong>: 强制使屏幕亮起，这种锁主要用于一些必要通知用户的操作</li>
<li><strong>ON_AFTER_RELEASE</strong>: 当锁被释放时，保持屏幕亮起一段时间</li>
</ul>

<h4 id="toc_80">使用Job Scheduler</h4>

<p>Job Scheduler只有一系列的预置条件满足时，才执行对应的操作，这样既能省电，又保证了功能的完整性。</p>

<p><strong>使用场景</strong></p>

<ul>
<li>重要不紧急的任务，可以延迟执行，如定期数据库数据更新和数据上报</li>
<li>耗电量较大的任务，比如充电时才希望执行的备份数据操作</li>
<li>不紧急可以不执行的网络任务，如在Wi-Fi环境预加载数据</li>
<li>可以批量执行的任务</li>
</ul>

<h3 id="toc_81">Doze模式</h3>

<p>Doze模式是通过限制应用访问网络以及其他一些操作的频率，来减少CPU的开销，达到省电的目的。Android6.0系统只要满足(未连接电源和屏幕关闭)这两个条件就会进入Doze模式。</p>

<p>同时为了保证应用正常工作，系统会周期性地退出休眠模式，在退出休眠模式这个时间里去执行那些在休眠模式下挂起的任务，这个时间窗口被称作维护窗口。同时随着系统处于Doze模式时长的增长，进入维护窗口的频率会逐步降低。</p>

<p><strong>Doze模式状态机</strong></p>

<ul>
<li>ACTIVE: 手机设备处于激活活动状态，设备在使用或者在充电中</li>
<li>INACTIVE: 刚脱离ACTIVE状态，进入非活动状态，关闭屏幕并没有充电</li>
<li>IDLE_PENDING: IDLE预备态，准备进入IDLE态，在每隔30分钟让应用进入等待空闲预备状态</li>
<li>IDLE: 设备进入空闲状态</li>
<li>IDLE_MAINTENANCE: 处理挂起任务，在此状态可以执行在INACTIVE态挂起的任务</li>
</ul>

<p><strong>在Doze模式中的状态进入IDLE时，有以下行为会受到限制</strong></p>

<ul>
<li>断开网络连接</li>
<li>系统忽略Wake Lock</li>
<li>标准闹钟AlarmManager定时任务延迟到下一个maintenance window进行处理。</li>
<li>系统不会扫描热点Wi-Fi</li>
<li>禁止同步工作</li>
<li>停止JobScheduler任务调度</li>
</ul>

<h2 id="toc_82">安装包大小优化</h2>

<h3 id="toc_83">应用装包的构成</h3>

<h4 id="toc_84">assets</h4>

<p>assets目录可以根据应用需求存放任何文件夹架构，如配置文件、资源文件，这些文件的内容在程序运行过程中可以通过AssetManager类获得。</p>

<h4 id="toc_85">lib</h4>

<p>该目录存放应用程序依赖的C/C++编写的native库文件。一般包含ARM、ARM-v7a、MIPS、X86文件夹。<br/>
由于X86和MIPS架构的易懂智能终端比较少，并且X86的设备基本都兼容了ARM指令集。所以一般只需包含ARM和ARM-V7a的so，如果不需要用到neon指令集，就只需要包含ARM架构下编译的so即可。</p>

<h4 id="toc_86">res</h4>

<p>这个目录存放资源文件，在这个文件夹下的所有文件都会生成对应的ID映射到Android工程的.R文件中。</p>

<h4 id="toc_87">META-INF</h4>

<p>保存应用的签名信息，签名信息可以验证APK文件的完整性。有利于确保Android应用的完整性和系统的安全性。META-INF目录下包含的文件有CERT.RSA、CERT.DSA、CERT.SF和MANIFEST.MF。其中CERT.RSA是开发者利用私钥对APK进行签名的签名文件，CERT.SF和MANIFEST.MF记录了文件中文件的SHA-1哈希值</p>

<h4 id="toc_88">AndroidManifest.xml</h4>

<p>用来描述Android应用的配置文件。</p>

<h4 id="toc_89">classes.dex</h4>

<p>Java可执行程序，需要先把Java文件编译成class文件，字节码都保存在class文件中，Java虚拟机可以通过解释并执行这些class文件。AndroidSDK中的dx工具可以对多个class文件进行合并重组、优化，达到减小体积，缩短运行时间的目的。</p>

<h4 id="toc_90">projuard.cfg</h4>

<p>代码混淆配置文件</p>

<h4 id="toc_91">resources.arsc</h4>

<p>记录资源文件和资源ID之间的映射关系，用来根据资源ID寻找资源。</p>

<h3 id="toc_92">减少安装包大小的常用方案</h3>

<h4 id="toc_93">代码混淆</h4>

<p>ProGuard是一个开源的Java代码混淆器，并且默认集成到Android SDK中。</p>

<ul>
<li>压缩: 移除无效的类、属性、方法</li>
<li>优化: 移除无用的结构</li>
<li>混淆: 把类名、属性名、方法名替换为一到两个字母</li>
</ul>

<h5 id="toc_94">ProGuard常用参数</h5>

<h6 id="toc_95">ProGuard配置</h6>

<p>-include {filename}: 从给定的文件中读取配置参数<br/>
-basedirectory {directoryname}: 指定基础目录为以后对应的档案名称<br/>
-injars {class_path}: 指定要处理的应用程序jar、war、ear和目录<br/>
-outjars {class_path}: 指定处理完后要输出的jar、war、ear和目录名称<br/>
-libaryjars {classpath}: 指定要处理的应用程序jar、war、ear和目录所需的程序库文件<br/>
-dontskipnonpubliclibraryclasses: 指定不忽略非公共的库类<br/>
-dontskipnonpubliclibraryclassmembers: 指定不忽略包可见的库类的成员</p>

<h6 id="toc_96">保留选项</h6>

<p>-keep {Modifier} {class_specification}: 保护指定的类文件和类的成员<br/>
-keepclassmembers {modifier} {class_specification}: 保护指定类的成员<br/>
-keepclasseswithmembers {class_specification}: 保护指定的类和类的成员，但条件是所有指定的类和类成员要存在<br/>
-keepnames {class_specification}: 保护指定的类和类的成员名称<br/>
-keepclassmemebernames {class_specification}: 保护指定的类的成员名称<br/>
-keepclasswithmembernames {class_specification}: 保护指定的类和类的成员名称<br/>
-printseeds {filename}: 列出类和类的成员 -keep选项的清单，标准输出到给定的文件</p>

<h6 id="toc_97">压缩</h6>

<p>-dontsshrink: 不压缩输入的类文件<br/>
-printusage {filename}: 输入无用文件</p>

<h6 id="toc_98">优化</h6>

<p>-dontoptimize: 不优化输入的类文件<br/>
-assumenosideeffects {class_specification}: 优化时假设指定的方法，没有任何副作用<br/>
-allowaccessmodification: 优化时允许访问并修改有修饰符的类和类的成员</p>

<h6 id="toc_99">混淆</h6>

<p>-dontobfuscate: 不混淆输入的类文件<br/>
-printmapping {filename}: 输出映射表<br/>
-applymapping {filename}: 重用映射增加混淆<br/>
-obfuscationdictionary {filename}: 使用给定文件中的关键字作为要混淆方法的名称<br/>
-overloadaggressively: 混淆时应用侵入式重载<br/>
-useuniqueclassmembernames: 确定统一的混淆类的成员名称来增加混淆<br/>
-renamesourcefileattribute {string}: 设置源文件中给定的字符串常量</p>

<h4 id="toc_100">资源优化</h4>

<h5 id="toc_101">使用Android Lint删除冗余资源</h5>

<ol>
<li>单击菜单栏中的Analyze -&gt; Run Inspection by Name，弹出工具选择框</li>
<li>在弹出的输入框中Unused resources，回车进入扫描前目录设置对话框</li>
<li>选择需要扫描的目录或整个工程，单击OK按钮开始扫描</li>
<li>扫描完成后生成报告，可在Android Studio中直接查看并删除确认无用的资源文件</li>
</ol>

<h5 id="toc_102">资源文件最少化</h5>

<ul>
<li>尽量使用一套图片资源，遇到一些图片在不同分辨率手机上变化差异过大的情况时，再考虑在相应文件夹下放入这个特定的图片</li>
<li>使用一套图、一套布局、多套dimens.xml文件，在使用最小资源的情况下，解决多分辨率适配。</li>
<li>使用轻量级的第三方库</li>
<li>减少项目中的预置图片，预置图片改成由服务器下发，尽可能地将程序与资源分离。</li>
</ul>

<h5 id="toc_103">图片优化</h5>

<p>JPG支持最高级别的压缩，但这种压缩有损耗，并且没有透明通道。<br/>
资源打包工具AAPT在应用打包过程中会自动对PNG图片做压缩处理，但减小的大小比较有限.除了靠工具自动打包，一般还可以采用降低图片色彩位数和PNG图片压缩工具来减少图片大小。<br/>
对于非透明的大图，JPG文件会比PNG文件小很多，通常会减小到一半以上。一半用于应用中一些闪屏介绍页、全图背景等。</p>

<h4 id="toc_104">其他优化</h4>

<ul>
<li>避免重复功能的库(建议选择性价比更高、更适合当前应用业务需求的一个库，在这个基础上增加相应的功能，扩展当前的库，而非引入新的开源库)</li>
<li>使用WebP格式图片(WebP是一种新的图片格式，它支持透明度，压缩比比JPG更好，但效果不比JPG差，但只有Android4.2.2才很好地支持WebP格式)</li>
<li>插件化(建议在用户使用率不高的功能模块上使用，或者使用预加载)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iTerm2工具学习使用]]></title>
    <link href="http://adolph.cc/15704556102016.html"/>
    <updated>2019-10-07T21:40:10+08:00</updated>
    <id>http://adolph.cc/15704556102016.html</id>
    <content type="html"><![CDATA[
<p>之前也简单使用过iTerm2，但是没感觉到和Mac系统终端有太大的区别。所以现在决定好好了解，系统的学习下iTerm2来提供自身的开发效率。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">下载iTerm2</h2>

<p>官网下载: <a href="https://www.iterm2.com/">https://www.iterm2.com/</a><br/>
Mac系统默认使用bash作为终端(可以通过<code>echo $SHELL</code>命令进行查看)，可以使用命令修改默认使用zsh：</p>

<pre class="line-numbers"><code class="language-text">chsh -s /bin/zsh
</code></pre>

<h2 id="toc_1">替换背景图片</h2>

<pre class="line-numbers"><code class="language-text">打开路径iterm2 -&gt; Preferences -&gt; Profiles -&gt; window -&gt; Background Image
</code></pre>

<p>选择一张自己喜欢的壁纸即可</p>

<p>可以通过Blending调节壁纸的透明度: 透明度为0的时候,背景变为纯色(黑色)</p>

<h2 id="toc_2">安装Oh my zsh</h2>

<p>zsh的功能极其强大，只是配置过于复杂,通过Oh my zsh可以很快配置zsh。<br/>
安装方法有两种，可以使用curl或wget，看自己环境或喜好：</p>

<pre class="line-numbers"><code class="language-shell"># curl 安装方式
sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>

<pre class="line-numbers"><code class="language-shell"># wget 安装方式
sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;
</code></pre>

<p>oh-my-zsh开源地址：<a href="https://github.com/robbyrussell/oh-my-zsh">《oh-my-zsh》</a></p>

<h2 id="toc_3">安装PowerLine</h2>

<p>首先先安装pip命令</p>

<pre class="line-numbers"><code class="language-shell">sudo easy_install pip
</code></pre>

<p>安装powerline</p>

<pre class="line-numbers"><code class="language-shell">pip install powerline-status --user
</code></pre>

<h2 id="toc_4">安装PowerFonts</h2>

<p>在常用的位置新建一个文件夹，如：/Users/**/Development/OpenSource</p>

<p>在OpenSource文件夹下下载PorweFonts:</p>

<pre class="line-numbers"><code class="language-shell"># git clone
git clone https://github.com/powerline/fonts.git --depth=1

# cd to folder
cd fonts

# run install shell
./install.sh
</code></pre>

<p>安装好字体库之后，我们来设置iTerm2的字体，具体的操作是</p>

<pre class="line-numbers"><code class="language-text">iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text
</code></pre>

<p>在Font区域选中Change Font，然后找到Meslo LG字体。</p>

<p><figure><img src="media/15704556102016/15704572147711.jpg" alt=""/></figure></p>

<h2 id="toc_5">安装主题</h2>

<p>用<code>vim ~/.zshrc</code>打开隐藏文件，修改主题为<code>agnoster</code></p>

<h2 id="toc_6">设置配色方案</h2>

<p>通过oh-my-zsh设置完主题后，使用ITerm2自带的几个背景色显示看得不舒服，下载其他的颜色方案较美观。我选用的是solarized，效果还不错。点开官网，下载，解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors。之后在Color Presets中选中Solarized Dark配色。</p>

<h2 id="toc_7">自动提示命令</h2>

<p>当我们输入命令时，终端会自动提示你接下来可能要输入的命令，这时按 → 便可输出这些命令，非常方便。</p>

<ul>
<li>克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下</li>
</ul>

<pre class="line-numbers"><code class="language-text">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
</code></pre>

<ul>
<li>用 vim  ~/.zshrc 打开文件，下滑找到插件设置命令，默认是 plugins=(git) ，我们把它修改为</li>
</ul>

<pre class="line-numbers"><code class="language-text">plugins=(zsh-autosuggestions git)
</code></pre>

<ul>
<li>重新打开终端窗口。</li>
</ul>

<p>有时候因为自动填充的颜色和背景颜色很相似，以至于自动填充没有效果，我们可以手动更改下自动填充的颜色配置。Preferences -&gt; Profiles -&gt; Colors -&gt; ANSI Colors -&gt; Bright</p>

<h2 id="toc_8">语法高亮</h2>

<ol>
<li>使用homebrew安装zsh-syntax-highlighting 插件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">brew install zsh-syntax-highlighting
</code></pre>

<ol>
<li>vim ~/.zshrc配置文件，插入一行，保存退出。</li>
</ol>

<pre class="line-numbers"><code class="language-text">source  /usr/local/Cellar/zsh-syntax-highlighting/0.6.0/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
</code></pre>

<p>PS：上面的路径是brew安装插件成功后的路径，安装成功会有显示，复制记录一下。</p>

<ol>
<li>输入命令。
<code>
source ~/.zshrc
</code></li>
</ol>

<h2 id="toc_9">给ITerm中Vim配色</h2>

<p>Vim 的配色最好和终端的配色保持一致，不然在 Terminal/iTerm2 里使用命令行 Vim 会很别扭。</p>

<pre class="line-numbers"><code class="language-text">$ cd solarized

$ cd vim-colors-solarized/colors

$ mkdir -p ~/.vim/colors 

$ cp solarized.vim ~/.vim/colors/

$ vi ~/.vimrc

加入下面三行设置即可

syntax enable

set background=dark

colorscheme solarized
</code></pre>

<p>重启iTerm2</p>

<h2 id="toc_10">左右键跳转</h2>

<p>主要是按住<code>option + → or ←键</code>，在命令的开始和结尾跳转切换，原本是不生效的，需要手动开启下。</p>

<p>打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后<code>Profiles → Keys → Load Preset... → Natural Text Editing</code>，就可以了。</p>

<h2 id="toc_11">iTerm2 隐藏用户名和主机名</h2>

<p>有时候我们的用户名和主机名太长，比如我的adolph@adolphdeMacBook-Pro，终端显示的时候会很不好看，我们可以手动去除。</p>

<p>编辑<code>vim ~/.zshrc文件</code>，增加<code>DEFAULT_USER=&quot;adolph&quot;</code>配置。</p>

<p>我们可以通过whoami命令，查看当前用户。</p>

<h2 id="toc_12">iTerm2 快捷命令</h2>

<p>快捷命令说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">command + t</td>
<td style="text-align: left">新建标签</td>
</tr>
<tr>
<td style="text-align: left">command + w</td>
<td style="text-align: left">关闭标签</td>
</tr>
<tr>
<td style="text-align: left">command + 数字 command + 左右方向键</td>
<td style="text-align: left">切换标签</td>
</tr>
<tr>
<td style="text-align: left">command + enter</td>
<td style="text-align: left">切换全屏</td>
</tr>
<tr>
<td style="text-align: left">command + f</td>
<td style="text-align: left">查找</td>
</tr>
<tr>
<td style="text-align: left">command + d</td>
<td style="text-align: left">垂直分屏</td>
</tr>
<tr>
<td style="text-align: left">command + shift + d</td>
<td style="text-align: left">水平分屏</td>
</tr>
<tr>
<td style="text-align: left">command + option + 方向键 command + [ 或command + ]</td>
<td style="text-align: left">切换屏幕</td>
</tr>
<tr>
<td style="text-align: left">command + ;</td>
<td style="text-align: left">查看历史命令</td>
</tr>
<tr>
<td style="text-align: left">command + shift + h</td>
<td style="text-align: left">查看剪贴板历史</td>
</tr>
<tr>
<td style="text-align: left">ctrl + u</td>
<td style="text-align: left">清除当前行</td>
</tr>
<tr>
<td style="text-align: left">ctrl + l</td>
<td style="text-align: left">清屏</td>
</tr>
<tr>
<td style="text-align: left">ctrl + a</td>
<td style="text-align: left">到行首</td>
</tr>
<tr>
<td style="text-align: left">ctrl + e</td>
<td style="text-align: left">到行尾</td>
</tr>
<tr>
<td style="text-align: left">ctrl + f/b</td>
<td style="text-align: left">前进后退</td>
</tr>
<tr>
<td style="text-align: left">ctrl + p</td>
<td style="text-align: left">上一条命令</td>
</tr>
<tr>
<td style="text-align: left">ctrl + r</td>
<td style="text-align: left">搜索命令历史</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homebrew学习]]></title>
    <link href="http://adolph.cc/15704404393204.html"/>
    <updated>2019-10-07T17:27:19+08:00</updated>
    <id>http://adolph.cc/15704404393204.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">简介</h2>

<p>Homebrew是Mac OSX常见的包管理器(命令brew用于命令行工具, brew cask管理带UI软件), 类似 ubuntu下apt-get, centOS的yum. 推荐日常Mac下安装卸载软件使用.</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">安装Homebrew</h2>

<pre class="line-numbers"><code class="language-text">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<h2 id="toc_2">使用Homebrew</h2>

<ul>
<li>帮助信息: brew help(-h)</li>
<li>基本使用</li>
</ul>

<pre class="line-numbers"><code class="language-shell"># 更新所有软件
brew update
# 安装应用, 例如wget, 安装到/usr/local/Cellar/wget, ln到/usr/local/bin目录下
brew install wget
# 安装带UI app, 插件, 字体(fonts)及其他非开源应用
brew cask install firefox
# 更新具体软件
brew upgrade git
# 诊断依赖冲突等
brew doctor
# 搜索app
brew search xxx
# 卸载xxx.app
brew uninstall xxx
# 列出安装的包
brew list
</code></pre>

<ul>
<li>其他命令</li>
</ul>

<pre class="line-numbers"><code class="language-shell"># 打开包主页
brew home git
# 查看包信息
brew info git
# 查看包依赖
brew deps wget  #结果显示gettext libidn2  libunistring openssl
# 清理旧版本
brew cleanup git
brew cleanup
# 显示是否有新版本可用
brew outdated
</code></pre>

<h2 id="toc_3">卸载Homebrew</h2>

<pre class="line-numbers"><code class="language-shell">cd `brew –prefix`
rm -rf Cellar
brew cleanup
rm -rf Homebrew
rm -rf ~/Library/Caches/Homebrew
</code></pre>

<h2 id="toc_4">Homebrew Cask</h2>

<p>Homebrew Cask 是 Homebrew 的扩展，借助它可以方便地在 macOS 上安装图形界面程序，即我们常用的各类应用。</p>

<h3 id="toc_5">安装</h3>

<pre class="line-numbers"><code class="language-shell">brew tap phinze/homebrew-cask
brew install brew-cask
</code></pre>

<h4 id="toc_6">可视化Homebrew安装工具</h4>

<p><code>brew cask install cakebrew</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker学习]]></title>
    <link href="http://adolph.cc/15663678647312.html"/>
    <updated>2019-08-21T14:11:04+08:00</updated>
    <id>http://adolph.cc/15663678647312.html</id>
    <content type="html"><![CDATA[
<p>最近要搞微服务，学习了很多，发现网上对使用Docker进行部署推崇备至，而且之前也用过Docker来搭建Maven私有仓库和Redis，觉得学习下整理一篇博客还是蛮有必要的哈哈。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">应用场景</h2>

<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>

<h2 id="toc_1">CentOs安装Docker</h2>

<p>看了网上很多教程，发现没有说的那么麻烦，还是很传统的下载安装方式。</p>

<ul>
<li>先进行yum更新<code>yum update</code></li>
<li>使用yum命令进行安装<code>yum install -y docker</code>(备注：-y 表示不询问 使用默认配置进行安装，等待提示  完毕！)</li>
<li>查看是否安装成功<code>yum list installed | grep docker</code>(备注：命令为 查看yum安装完成文件列表 并 筛选docker安装信息)</li>
<li>启动docker服务<code>systemctl start docker</code></li>
<li>查看是否启动成功<code>systemctl status docker</code></li>
<li>使用docker命令 <code>docker images</code>(备注：查看docker已经安装的镜像 裸机状态下为空)</li>
</ul>

<h2 id="toc_2">Docker常用命令</h2>

<h3 id="toc_3">从docker仓库搜索镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker search [镜像名称]
</code></pre>

<h3 id="toc_4">拉取镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker image pull 镜像名称:版本号 # 不指定版本默认为最新版
</code></pre>

<h3 id="toc_5">删除镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker image rm 镜像名称/镜像ID
</code></pre>

<h3 id="toc_6">查看本地镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker images
</code></pre>

<h3 id="toc_7">重命名镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker tag [old_name] [new_name]
</code></pre>

<h3 id="toc_8">创建容器</h3>

<pre class="line-numbers"><code class="language-bash">docker run [option] 镜像名 [向启动容器中传入的命令]
</code></pre>

<p>[option]常用可选参数说明：</p>

<ul>
<li>-i 表示以“交互模式”运行容器,与容器交互</li>
<li>-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</li>
<li>–name 为创建的容器命名</li>
<li>-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</li>
<li>-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</li>
<li>-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</li>
<li>-e 为容器设置环境变量</li>
<li>–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同 </li>
<li>-rm 在容器退出时，自动删除其缓存</li>
</ul>

<pre class="line-numbers"><code class="language-bash">sudo docker run -it –name=ubuntu1 113a43faa138 /bin/bash

# -it 创建一个伪终端交互界面，name指定容器名称，否则随机一个名字 113a43faa138 镜像id /bin/bash 创建后执行的命令 
</code></pre>

<pre class="line-numbers"><code class="language-bash">sudo docker run -dit --name=ubuntu -v ~/Desktop/ceshi:/ceshi ubuntu
# -v &lt;本机目录:容器目录&gt;创建一个共享目录，左边是本机的目录，右边是容器中的目录，在本机修改内容对应的容器中的目录内容也会改变, 目录不存在会自动创建
</code></pre>

<h3 id="toc_9">查看所有容器</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker container ls #查看所有正在运行的容器
sudo docker container ls --all # 查看所有已创建的容器
</code></pre>

<ul>
<li>container id 容器id</li>
<li>image 镜像名称</li>
<li>command 创建后运行的命令</li>
<li>created 创建时间</li>
<li>status 关闭时间</li>
<li>ports 绑定的端口</li>
<li>names 容器名称</li>
</ul>

<h3 id="toc_10">运行已经开启的容器</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker container exec -it &lt;容器名/id&gt; &lt;运行后使用的第一个命令&gt;
# 运行使用的第一个命令一般默认为 /bin/bash 否则无法进入交互界面
</code></pre>

<h3 id="toc_11">停止与启动容器</h3>

<pre class="line-numbers"><code class="language-bash"># 停止一个已经在运行的容器
sudo docker container stop [容器名或容器id]

# 启动一个已经停止的容器
sudo docker container start [容器名或容器id]

# kill掉一个已经在运行的容器
sudo docker container kill [容器名]
</code></pre>

<h3 id="toc_12">删除容器</h3>

<pre class="line-numbers"><code class="language-bash">docker container rm [容器名或容器id]
</code></pre>

<h3 id="toc_13">容器保存为镜像</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker commit [容器名] [镜像]名
sudo docker commit ubuntu1 myubuntu  # 将容器名为ubuntu1的容器转换为叫myuntu的镜像，原本的容器并不会删除
</code></pre>

<h4 id="toc_14">镜像打包成文件</h4>

<pre class="line-numbers"><code class="language-bash">sudo docker save -o 保存的文件名 镜像名
sudo docker save -o ./ubuntu.tar ubuntu
</code></pre>

<h4 id="toc_15">将镜像加载到本地</h4>

<pre class="line-numbers"><code class="language-bash">sudo docker load -i  &lt;文件名&gt;
sudo docker load -i ./ubuntu.tar
</code></pre>

<h2 id="toc_16">Dockerfile</h2>

<p>Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。</p>

<h3 id="toc_17">Dockerfile的格式</h3>

<ol>
<li>#用来表示注释。</li>
<li>指令大小写不敏感，一般大写，参数小写。</li>
<li>Docker顺序执行Dockerfile中的指令来构建image。</li>
<li>第一个指令以&quot;From&quot;开始。</li>
<li>Dockerfile文件名首字母必须大写。</li>
</ol>

<h3 id="toc_18">工作目录</h3>

<p>Dockerfile在制作过程中，所有相关的文件都需要在一个文件夹中，这个文件夹叫做工作目录，Dockerfile所在的目录及其子目录。</p>

<pre class="line-numbers"><code class="language-text">mkdir /tmp/image1
cd /tmp/image1
</code></pre>

<h3 id="toc_19">Dockerfile指令</h3>

<h4 id="toc_20">FROM命令</h4>

<p>除了注释行外，Dockerfile的第一个命令。</p>

<pre class="line-numbers"><code class="language-text">FROM &lt;repository&gt;[:&lt;tag&gt;]
FROM &lt;repository&gt;@&lt;digest&gt;
  repository:指定base image的名称
  tag: 指定base image的标签
  digest：image的hashcode
</code></pre>

<h4 id="toc_21">LABLE命令</h4>

<p>用于提供Dockerfile制作者的信息，这个命令可以出现在任何位置，一般建议在FROM指令之后。用key value的形式来描述一个image的metadata。</p>

<pre class="line-numbers"><code class="language-text">LABLE &lt;key&gt;=&lt;value&gt;
例如：
LABLE maintainer=&quot;leveldc&lt;leveldc@126.com&gt;&quot;
</code></pre>

<h4 id="toc_22">COPY命令</h4>

<p>用于从宿主机复制文件到镜像文件。</p>

<pre class="line-numbers"><code class="language-text">COPY &lt;src&gt;...&lt;dist&gt;
COPY [&quot;&lt;src&gt;&quot;,...&quot;&lt;dist&gt;&quot;]
  src:  复制文件的源文件或目录，支持通配符
  dist: 目标路径
说明：
1. &lt;src&gt;必须是build的上下文中的路径，不能是其父目录的文件。
2. 如果&lt;src&gt;是目录，其内部文件及子目录会被递归复制，&lt;src&gt;本身不会被复制。
3. 如果指定了多个&lt;src&gt;或在&lt;src&gt;中使用了通配符，则&lt;dist&gt;必须是一个目录，且以/结束。
4. 如果&lt;dist&gt;不存在，会被自动创建，包括其父目录。
例如：
COPY index.html /data/web/html
</code></pre>

<h4 id="toc_23">ADD命令</h4>

<p>类似COPY命令， 支持TAR文件或者TAR.gz和URL路径。<br/>
TAR:拷贝本地的tar文件会自动解压缩到docker镜像中。<br/>
URL:拷贝服务器地址上的文件并将文件添加到docker 镜像中。</p>

<pre class="line-numbers"><code class="language-text">ADD &lt;src&gt;...&lt;dist&gt;
ADD [&quot;&lt;src&gt;&quot;,...&quot;&lt;dist&gt;&quot;]
  src:  添加文件的源文件或目录，支持通配符
  dist: 目标路径
说明：
1. 如果&lt;src&gt;为URL且&lt;dist&gt;不以/结尾则&lt;src&gt;指定的文件将被直接下载并创建为&lt;dist&gt;;如果以/结尾，则文件被拷贝至&lt;dist&gt;/&lt;filename&gt;
2. 如果&lt;src&gt;是本地tar文件，则被展开为一个目录，如果是一个URL的tar文件，则不会自动展开。
3. 如果&lt;src&gt;有多个，则dist需要以/结尾，否则将会把src的内容直接写进&lt;dist&gt;。
例如：
ADD http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.37/bin/apache-tomcat-8.5.37.tar.gz /usr/local/src/
ADD apache-tomcat-8.5.37.tar.gz /usr/local/src/
</code></pre>

<h4 id="toc_24">WORKDIR命令</h4>

<p>指定Docker镜像中的工作路径，可以定义多次，命令执行的时候以最新定义的一次为准。<br/>
例如:<code>WORKDIR /usr/local/</code></p>

<h4 id="toc_25">VOLUME命令</h4>

<p>Dockerfile中的卷只能设置容器中的挂载点目录，只能设置docker管理的卷。<br/>
例如:<code>VOLUME /data/mysql</code></p>

<h4 id="toc_26">EXPOSE命令</h4>

<p>为容器打开指定要监听的端口来和外部通信。</p>

<pre class="line-numbers"><code class="language-text">EXPOSE &lt;port&gt;[/&lt;protocol&gt;][&lt;port&gt;[&lt;/protocol&gt;]]
protocol:传输协议，tcp/udp, 默认tcp.
可以一次指定多个端口,例如:
`EXPOSE 32332/udp 32332/tcp`

这里的端口并不会直接暴露给宿主机，而是以启动docker容器时候的参数来决定。
docker run -p/-P
</code></pre>

<h4 id="toc_27">ENV命令</h4>

<p>定义Dockerfile的环境变量，可以被在Dockfile ENV命令后面的其他命令引用。</p>

<pre class="line-numbers"><code class="language-text"> ENV &lt;key&gt; &lt;value&gt;
  ENV &lt;key&gt;=&lt;value&gt; ...
  说明:
  1.第一种格式key后面的所有内容都被认为是value，只可以定义一个
  2.第二种格式可以定义多个&lt;key&gt;=&lt;value&gt;, 如果value中有空格，需要加&quot;\&quot;进行转义，也可以对value加双引号。另外反斜杠可以用来表示续行。
  建议使用第二种。
  3.Dockerfile中定义的ENV可以在启动容器以后直接使用，在运行为容器的时候通过-e参数可以重新给变量赋值。要分清什么参数是在build阶段的，什么是在容器启动阶段。
</code></pre>

<h4 id="toc_28">RUN命令</h4>

<p>RUN命令时基于基础镜像所提供的命令来运行，发生在创建镜像的过程中。目的是为了创建镜像。<br/>
RUN 命令如果执行了yum，需要在安装完成后删除缓存以减小镜像大小。</p>

<pre class="line-numbers"><code class="language-text">RUN &lt;command&gt;
RUN [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]

说明:
第一种默认启动为/bin/sh 子进程。
第二种执行方式是由linux直接来执行，没有/bin/sh,所以不支持shell的语法，如果需要可以使用:
RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;]来执行。
例如:
RUN cd /usr/local/src/ &amp;&amp; \
    tar -xf  ${WEB_SERVER_VERSION}
</code></pre>

<h4 id="toc_29">CMD命令</h4>

<p>CMD命令发生在容器启动时,当一个镜像文件被创建为容器的时候执行,一个容器默认只启动一个进程，所以一个Dockerfile中只可以有一个CMD,如果有多个，则最后一个生效用来指定容器启动时默认执行的程。</p>

<pre class="line-numbers"><code class="language-text">CMD &lt;command&gt;
CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
说明:
在执行docker run命令的时候，可以指定新的命来来覆盖CMD的内容。如果docker在启动的时候不希望接受命令行输入的命令，可以使用ENTRYPOINT.
</code></pre>

<h4 id="toc_30">ENTRYPOINT命令</h4>

<p>和CMD功能类似，但是不接受在docker run的时候修改启动命令，docker run的参数只能以变量的形式传给ENTRYPOINT定义的启动程序。</p>

<p>如果需要改变，需要在docker run的时候指定 --entrypoints参数。</p>

<p>ENTRYPOINT用来支持多环境</p>

<h4 id="toc_31">USER命令</h4>

<p>用于指定运行image或运行Dockerfile中的RUN CMD ENTRYPOINT指令指定的程序时的用户名或者UID。</p>

<pre class="line-numbers"><code class="language-text">USER &lt;UID&gt;|&lt;UserName&gt;
CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
</code></pre>

<h4 id="toc_32">HEALTHCHECK命令</h4>

<p>容器健康检测</p>

<pre class="line-numbers"><code class="language-text">HEALTHCHECK [OPTIONS] CMD command
OPTIONS：
  --interval=DURATION(间隔多久检测)
  --timeout=DURATION(检测超时)
  --start-period=DURATION(等待多久开始检测，default=0)
  --retries=N(default=3)
  returns:
  0:success
  1:unhealthy
  2:reserved
  例如:
  HEALTHCHECK --interval=5m --timeout=30s CMD curl -f http://localhost/ || exit 1
</code></pre>

<h4 id="toc_33">SHELL命令</h4>

<p>镜像默认的shell</p>

<pre class="line-numbers"><code class="language-text">SHELL [&quot;executable&quot;,&quot;parameters&quot;]
</code></pre>

<h4 id="toc_34">STOPSIGNAL命令</h4>

<p>进程为1的命令可以接受docker stop命令,主进程停止，容器就停止。</p>

<h4 id="toc_35">ARG命令</h4>

<p>在build的过程中起作用，使一个dockerfile可以适用多个环境，用法和ENV类似，但是起作用的时间不一样。该变量可以通过 build --arg参数修改。</p>

<h4 id="toc_36">ONBUILD命令</h4>

<p>在Dockerfile中定义一个并发器，当别的镜像是基于有ONBUILD的镜像构建新的镜像的时候，会触发ONBOUILD指令</p>

<pre class="line-numbers"><code class="language-text">ONBUILD&lt;INSTRUCTION&gt;
</code></pre>

<h4 id="toc_37">docker buld</h4>

<p>创建docker镜像</p>

<pre class="line-numbers"><code class="language-text">docker build [OPTIONS] PATH | URL | -
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android GRPC接入]]></title>
    <link href="http://adolph.cc/15662718181666.html"/>
    <updated>2019-08-20T11:30:18+08:00</updated>
    <id>http://adolph.cc/15662718181666.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装Protobuf插件</h2>

<p>Protobuf Support插件可以支持Protobuf文件高亮语法显示</p>

<p><figure><img src="media/15662718181666/15662727464652.png" alt="" style="width:582px;"/></figure></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">添加Grpc依赖</h2>

<ul>
<li>项目根目录build.gradle添加</li>
</ul>

<pre class="line-numbers"><code class="language-groovy">buildscript {
    ext.kotlin_version = &#39;1.3.41&#39;
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.4.2&#39;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
        //添加这句
        classpath &quot;com.google.protobuf:protobuf-gradle-plugin:0.8.10&quot;
    }
}
</code></pre>

<ul>
<li>在Module下build.gradle添加<code>apply plugin: &#39;com.google.protobuf&#39;</code></li>
<li>设置proto文件位置(src/main/proto):</li>
</ul>

<pre class="line-numbers"><code class="language-groovy">android {
    sourceSets {
        main {
            proto {
                srcDir &#39;src/main/proto&#39;
            }
            java {
                srcDir &#39;src/main/java&#39;
            }
        }
    }
}
</code></pre>

<ul>
<li>自定义Protobuf编译项</li>
</ul>

<pre class="line-numbers"><code class="language-groovy">protobuf {
    protoc { artifact = &#39;com.google.protobuf:protoc:3.9.1&#39; }
    plugins {
        javalite { artifact = &quot;com.google.protobuf:protoc-gen-javalite:3.0.0&quot; }
        grpc { artifact = &#39;io.grpc:protoc-gen-grpc-java:1.22.1&#39; }
    }
    generateProtoTasks {
        all().each { task -&gt;
            task.plugins {
                javalite {}
                grpc { option &#39;lite&#39; }
            }
        }
    }
    generatedFilesBaseDir = &quot;$projectDir/src/generated&quot;
}

clean {
    delete &quot;${projectDir}/src/main/generated-proto&quot;
}
</code></pre>

<ul>
<li>加入grpc依赖</li>
</ul>

<pre class="line-numbers"><code class="language-groovy">implementation &#39;io.grpc:grpc-okhttp:1.22.1&#39;
implementation &#39;io.grpc:grpc-protobuf-lite:1.22.1&#39;
implementation &#39;io.grpc:grpc-stub:1.22.1&#39;
implementation &#39;javax.annotation:javax.annotation-api:1.3.2&#39;
</code></pre>

<ul>
<li>Rebuild Project之后就会自动生成代码</li>
</ul>

<h2 id="toc_2">Protobuf语法</h2>

<h3 id="toc_3">关键字</h3>

<ul>
<li>syntax：声明版本。例如上面syntax=&quot;proto3&quot;，如果没有声明，则默认是proto2。</li>
<li>package：声明包名.</li>
<li>import：导入包。类似于java，例如上面导入了timestamp.proto包。</li>
<li>java_package：指定生成的类应该放在什么Java包名下。如果你没有显式地指定这个值，则它简单地匹配由package 声明给出的Java包名，但这些名字通常都不是合适的Java包名 (由于它们通常不以一个域名打头)。</li>
<li>java_outer_classname：定义应该包含这个文件中所有类的类名。如果你没有显式地给定java_outer_classname ，则将通过把文件名转换为首字母大写来生成。例如上面例子编译生成的文件名和类名是AddressBookProtos。</li>
<li>message：类似于java中的class关键字。</li>
<li>repeated：用于修饰属性，表示对应的属性是个array。</li>
</ul>

<h3 id="toc_4">Android中使用</h3>

<p>创建Proto文件</p>

<pre class="line-numbers"><code class="language-protobuf">syntax = &quot;proto3&quot;;

option java_multiple_files = true;
option java_package = &quot;com.ifantastic.helloworld&quot;;
option java_outer_classname = &quot;HelloWorldProto&quot;;

package helloworld;

message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
}

service Greeter {
    rpc SayHello(HelloRequest) returns (HelloReply);
}
</code></pre>

<p>Rebuild之后开始调用</p>

<ul>
<li><p>创建连接通道</p>
<pre class="line-numbers"><code class="language-kotlin">val connectionChannel: ManagedChannel by lazy {
    OkHttpChannelBuilder.forAddress(&quot;192.168.6.104&quot;, 9090)<br/>
        .usePlaintext()<br/>
        .build()<br/>
}
</code></pre></li>
<li><p>声明Service</p>
<pre class="line-numbers"><code class="language-kotlin">val service = GreeterGrpc.newBlockingStub(connectionChannel)
</code></pre></li>
<li><p>Grpc请求</p>
<pre class="line-numbers"><code class="language-kotlin">val requestMessage = HelloRequest.newBuilder()
        .setName(name)<br/>
        .build()      <br/>
val response = service.sayHello(requestMessage)
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker搭建Maven私服]]></title>
    <link href="http://adolph.cc/15662693410122.html"/>
    <updated>2019-08-20T10:49:01+08:00</updated>
    <id>http://adolph.cc/15662693410122.html</id>
    <content type="html"><![CDATA[
<p>由于Gradle和Maven依赖方式不一样，没法进行本地项目依赖，所以需要把Gradle项目打包发布到Maven仓库。发布到公共仓库又不太好，所以决定搭建个私有仓库，刚好家里有群辉Synology DS918+，可以通过Docker来搭建Maven私服。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">安装Nexus</h2>

<p>群辉上的Docker通过图形化的界面进行操控，所以不需要进行命令行操作。</p>

<ul>
<li><p>在注册表中搜索Nexus，对sonatype/nexus3项目进行双击下载映像。<br/>
<figure><img src="media/15662693410122/66FBF341-A2A8-43AC-8920-82E09879443C.png" alt=""/></figure></p></li>
<li><p>在映像中双击sonatype/nexus3创建容器，编辑nexus设置，启用自动重新启动和创建桌面快捷方式<figure><img src="media/15662693410122/07013229-CA0A-45AB-9035-DF3A95145BE2.png" alt=""/></figure></p></li>
<li><p>在卷中添加映射文件夹 本地文件路径 / 装载路径(/var/nexus-data)<br/>
<figure><img src="media/15662693410122/3E47DC7A-E1E8-4E8B-8325-5E482631797E.png" alt=""/></figure></p></li>
<li><p>进行端口映射,将本地端口映射到容器端口.<figure><img src="media/15662693410122/96660F1B-0E55-4DEB-AF78-BC29526F79E8.png" alt=""/></figure></p></li>
<li><p>启动Nexus，点击桌面的Nexus快捷启动或者通过<code>http://ip:8081</code>，打开Nexus网址。<br/>
<figure><img src="media/15662693410122/15662707547156.png" alt=""/></figure></p></li>
<li><p>点击右上方的Sign in进行登录，初始账号为admin，初始密码通过容器的详情里终端查看admin.password里的密码.登录后修改密码<br/>
<figure><img src="media/15662693410122/15662707441848.jpg" alt=""/></figure></p></li>
<li><p>可以看到默认情况下<code>Nexus</code>会帮我们创建了几个仓库，仔细观察红色框住的地方，里面有几种仓库的类型，解释如下：</p>
<ul>
<li><code>proxy</code>远程仓库的代理，比如说<code>nexus</code>配置了一个<code>central repository</code>的<code>proxy</code>,当用户向这个proxy请求一个<code>artifact</code>的时候，会现在本地查找，如果找不到，则会从远程仓库下载，然后返回给用户。</li>
<li><code>hosted</code>宿主仓库，用户可以把自己的一些仓库<code>deploy</code>到这个仓库中</li>
<li><code>group</code>仓库组，是<code>nexus</code>特有的概念，目的是将多个仓库整合，对用户暴露统一的地址，这样就不需要配置多个仓库地址。</li>
</ul></li>
<li><p>下面我们仔细看一下里面的一些仓库。点击<code>maven-central</code>仓库: <br/>
<figure><img src="media/15662693410122/15662710138140.jpg" alt=""/></figure><br/>
可以看到是一个<code>proxy</code>类型的仓库，他代理的远程仓库地址是<code>https://repo1.maven.org/maven2/</code>。</p></li>
<li><p>后退，在进入<code>maven-public</code>查看: <br/>
<figure><img src="media/15662693410122/15662710448726.png" alt=""/></figure><br/>
可以看到这是一个<code>group</code>类型的仓库，里面包含了<code>maven-releases/maven-snapshots/maven-central</code>仓库，意思是我们只需要在本地添加这个仓库，则可以依赖到上述3个仓库中的库了。</p></li>
</ul>

<h2 id="toc_1">创建仓库</h2>

<ul>
<li><p><strong>创建仓库</strong><br/>
点击<code>Create repository</code>,然后选择<code>maven2(hosted)</code>然后输入仓库名称<code>（test-release）</code>。在<code>version policy</code>中选择这个仓库的类型，这里选择<code>release</code>,在<code>Deployment policy</code>中选择<code>Allow redeploy</code><br/>
<figure><img src="media/15662693410122/15662711396304.png" alt=""/></figure></p></li>
<li><p><strong>创建用户</strong><br/>
点击左侧菜单栏的Users菜单，然后点击Create local user.我这里创建了一个用户，账号密码都是：wangjianfeng <br/>
<figure><img src="media/15662693410122/15662712072619.jpg" alt=""/></figure></p></li>
</ul>

<h2 id="toc_2">Java Gradle项目上传</h2>

<p>在build.gradle中添加<code>maven-publish</code>插件</p>

<pre class="line-numbers"><code class="language-groovy">plugins {
    id &quot;maven-publish&quot;
}
</code></pre>

<p>设置插件参数</p>

<pre class="line-numbers"><code class="language-groovy">//打包源码
task sourceJar(type: Jar) {
    from sourceSets.main.allSource
}

publishing {
    publications {
        maven(MavenPublication) {
            //指定group/artifact/version信息，可以不填。默认使用项目group/name/version作为groupId/artifactId/version
            groupId project.group
            artifactId project.name
            version project.version
            //如果是war包填写components.web，如果是jar包填写components.java
            from components.java

            //配置上传源码
            artifact sourceJar {
                classifier &quot;sources&quot;
            }

        }
    }
    repositories {
        maven {
            //指定要上传的maven私服仓库
            url = &quot;http://你的maven私服地址/repository/maxrocky/&quot;
            //认证用户和密码
            credentials {
                username &#39;admin&#39;
                password &#39;admin123&#39;
            }
        }
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin为序列化类生成serialVersionUID]]></title>
    <link href="http://adolph.cc/15639522586909.html"/>
    <updated>2019-07-24T15:10:58+08:00</updated>
    <id>http://adolph.cc/15639522586909.html</id>
    <content type="html"><![CDATA[
<p>一般在Intellij Idea使用过程中，为Java序列化类自动生成serialVersionUID可以通过Inspections配置来完成</p>

<span id="more"></span><!-- more -->

<p><figure><img src="media/15639522586909/15639527631359.jpg" alt=""/></figure></p>

<pre class="line-numbers"><code class="language-text">Preferences -&gt; Inspections -&gt; Serialization issues -&gt; Serialization class without &#39;serialVersionUID&#39;
</code></pre>

<p>将光标放到类名上，按<code>atl＋enter</code>键，就会提示生成serialVersionUID了</p>

<p><figure><img src="media/15639522586909/15639527944558.jpg" alt=""/></figure></p>

<p>或者使用插件<strong>GenerateSerialVersionUID</strong>就能通过快捷键快速生成serialVersionUID</p>

<p>然而在Kotlin环境下，以上配置无效</p>

<p><strong>解决方案如下：</strong><br/>
利用serialver命令生成serialVersionUID</p>

<ul>
<li>Preferences -&gt; Tools -&gt; External Tools</li>
<li>添加新的tools</li>
<li>Name就设置为serialver</li>
<li>Program中选择serialver命令所在的路径，macOS下一般为<code>/usr/bin/serialver</code></li>
<li>Arguments设置为 <code>-classpath$OutputPath$:$Classpath$ $FileFQPackage$.$FileNameWithoutAllExtensions$</code></li>
<li>点击保存以上配置</li>
</ul>

<p>Ok,现在就可以生成serialVersionUID了。首先编译一下，让要生成serialVersionUID的类生成对应的class文件，然后在类的编辑窗口中右键选择external tools &gt; serialver，这时console窗口出就生成了这个类的serialVersionUID了。</p>

<blockquote>
<p>另：kotlin中没有Java的static关键字，所以serialVersionUID属性是以伴生对象属性存在的</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xposed开发]]></title>
    <link href="http://adolph.cc/15620327900428.html"/>
    <updated>2019-07-02T09:59:50+08:00</updated>
    <id>http://adolph.cc/15620327900428.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Xposed SDK下载</h2>

<p><a href="http://dl-xda.xposed.info/framework/sdk21/x86/">地址</a></p>

<h2 id="toc_1">Xposed API</h2>

<p><a href="https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html">地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Genymotion-ARM-Translation.zip各安卓版本合集]]></title>
    <link href="http://adolph.cc/15620314685082.html"/>
    <updated>2019-07-02T09:37:48+08:00</updated>
    <id>http://adolph.cc/15620314685082.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th style="text-align: left">安卓版本</th>
<th style="text-align: left">代号</th>
<th style="text-align: left">Genymotion-ARM-Translation</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">8.0 – 8.1</td>
<td style="text-align: left">Oreo奥利奥</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Oreo8.0-8.1/ARM_Translation_Oreo.zip">ARM_Translation_Oreo.zip</a></td>
</tr>
<tr>
<td style="text-align: left">7.0 – 7.1.2</td>
<td style="text-align: left">Nougat牛轧糖</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">6.0 – 6.0.1</td>
<td style="text-align: left">Marshmallow棉花糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Marshmallow6.0-6.0.1/ARM_Translation_Marshmallow.zip">ARM_Translation_Marshmallow.zip</a></td>
</tr>
<tr>
<td style="text-align: left">5.0 – 5.1.1</td>
<td style="text-align: left">Lollipop棒棒糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Lollipop5.0-5.1.1/ARM_Translation_Lollipop_20160402.zip">ARM_Translation_Lollipop_20160402.zip</a></td>
</tr>
<tr>
<td style="text-align: left">5.0 – 5.1.1</td>
<td style="text-align: left">Lollipop棒棒糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Lollipop5.0-5.1.1/ARM_Translation_Lollipop.zip">ARM_Translation_Lollipop.zip</a></td>
</tr>
<tr>
<td style="text-align: left">4.4 – 4.4.4</td>
<td style="text-align: left">KitKat奇巧巧克力</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/KitKat4.4-4.4.4/ARM-4.4-libhoudini.zip">ARM-4.4-libhoudini.zip</a></td>
</tr>
<tr>
<td style="text-align: left">4.1 – 4.3.1</td>
<td style="text-align: left">Jelly Bean果冻豆</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/JellyBean4.1-4.3.1/Genymotion-ARM-Translation_v1.1.zip">Genymotion-ARM-Translation_v1.1.zip</a></td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactNative打包与发布]]></title>
    <link href="http://adolph.cc/15615956474579.html"/>
    <updated>2019-06-27T08:34:07+08:00</updated>
    <id>http://adolph.cc/15615956474579.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">iOS</h2>

<h3 id="toc_1">生成bundle文件</h3>

<pre class="line-numbers"><code class="language-text">react-native bundle --entry-file index.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CodePush集成与热更新]]></title>
    <link href="http://adolph.cc/15615956237705.html"/>
    <updated>2019-06-27T08:33:43+08:00</updated>
    <id>http://adolph.cc/15615956237705.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">前言</h2>

<p>CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。<br/>
CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。CodePush 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">安装与使用</h2>

<p>使用CodePush之前首先要安装CodePush客户端。</p>

<h3 id="toc_2">安装 CodePush CLI</h3>

<ul>
<li>安装客户端<code>npm install -g code-push-cli</code></li>
<li>查看版本号<code>code-push -v</code></li>
<li>注册CodePush账号<code>code-push register</code>授权通过之后，CodePush会告诉你“access key”，复制此key到终端即可完成注册。</li>
<li>登录<code>code-push login</code>登陆成功后，你的session文件将会写在 /Users/你的用户名/.code-push.config。</li>
</ul>

<p>PS.相关命令</p>

<ul>
<li><code>code-push login</code> 登陆</li>
<li><code>code-push logout</code> 注销</li>
<li><code>code-push access-key ls</code> 列出登陆的token</li>
<li><code>code-push access-key rm &lt;accessKye&gt;</code> 删除某个 access-key</li>
</ul>

<h3 id="toc_3">在CodePush服务器注册app</h3>

<p>为了让CodePush服务器知道你的app，我们需要向它注册app</p>

<ul>
<li>添加应用平台<code>code-push app add &lt;app_name&gt; &lt;os&gt; &lt;platform&gt;</code></li>
<li>添加部署环境<code>code-push deployment add &lt;app_name&gt; test</code></li>
</ul>

<p>PS.相关命令</p>

<ul>
<li><code>code-push app add</code> 在账号里面添加一个新的app</li>
<li><code>code-push app remove</code> 或者 <code>rm</code> 在账号里移除一个app</li>
<li><code>code-push app rename</code> 重命名一个存在app</li>
<li><code>code-push app list</code> 或者 <code>ls</code> 列出账号下面的所有app</li>
<li><code>code-push app transfer</code> 把app的所有权转移到另外一个账号</li>
<li><code>code-push deployment list &lt;app_name&gt; --format json</code> 查看APP的环境信息</li>
<li><code>code-push deployment clear &lt;app-name&gt;</code> 部署环境</li>
</ul>

<h4 id="toc_4">发布CodePush更新包</h4>

<p><code>code-push release-react &lt;Appname&gt; &lt;Platform&gt; --t &lt;本更新包面向的旧版本号&gt; --des &lt;本次更新说明&gt;</code></p>

<blockquote>
<p>注意： CodePush默认是更新Staging 环境的，如果发布生产环境的更新包，需要指定--d参数：--d Production，如果发布的是强制更新包，需要加上 --m true强制更新</p>
</blockquote>

<p><code>$ code-push release-react iOSRNHybrid ios --t 1.0.0 --dev false --d Production --des &quot;这是第一个更新包&quot; --m true<br/>
</code></p>

<ul>
<li>发布更新包命令中的 -- t 对应的参数是和我们项目中的版本号一致的，这个不要误理解为是更新包的版本号，例如项目中的版本号为1.0.0， 这时如果我们需要对这个1.0.0 版本的项目进行第一次热更新，那么命令中的 -- t 也为1.0.0，第二次热更新任然为1.0.0, --dev为是否启用开发者模式(默认为false), --d是要发布更新的环境分Production与Staging(默认为Staging)；--des为更新说明；--m 是强制更新。</li>
<li>项目的版本号需要改为三位的，默认是两位的，但是CodePush需要三位数的版本号</li>
<li>发布更新应用时，应用的名称必须要和之前注册过的应用名称一致</li>
</ul>

<h5 id="toc_5">查询Production</h5>

<p><code>code-push deployment history projectName Production</code></p>

<h5 id="toc_6">查询Staging</h5>

<p><code>code-push deployment history projectName Staging</code></p>

<h3 id="toc_7">ReactNative集成code-push</h3>

<h4 id="toc_8">安装组件</h4>

<p>项目根目录下 <code>yarn add react-native-code-push</code></p>

<h4 id="toc_9">添加依赖</h4>

<p><code>react-native react-native-code-push</code></p>

<h4 id="toc_10">RN端代码</h4>

<pre class="line-numbers"><code class="language-text">import CodePush from &quot;react-native-code-push&quot;;
let codePushOptions = { checkFrequency: CodePush.CheckFrequency.ON_APP_RESUME };
const deploymentKey = Platform.select({
    ios: &#39;XgBtruRnRtJKOjkwEZub2Q60mFys4ksvOXqog&#39;,
    android: &#39;fmrp3d8KiGKSyp23cXe26a9xEkHF4ksvOXqog&#39;,
});

class App extends Component&lt;Props&gt; {

    componentWillMount() {
        CodePush.disallowRestart();//禁止重启
        this.syncImmediate(); //开始检查更新
    }

    componentDidMount() {
        CodePush.allowRestart();//在加载完了，允许重启
    }

    //如果有更新的提示
    syncImmediate() {
        CodePush.sync( {
                //安装模式
                //ON_NEXT_RESUME 下次恢复到前台时
                //ON_NEXT_RESTART 下一次重启时
                //IMMEDIATE 马上更新
                installMode : CodePush.InstallMode.ON_NEXT_RESUME ,
                //对话框
                updateDialog : {
                    //是否显示更新描述
                    appendReleaseDescription : true ,
                    //更新描述的前缀。 默认为&quot;Description&quot;
                    descriptionPrefix : &quot;更新内容：&quot; ,
                    //强制更新按钮文字，默认为continue
                    mandatoryContinueButtonLabel : &quot;立即更新&quot; ,
                    //强制更新时的信息. 默认为&quot;An update is available that must be installed.&quot;
                    mandatoryUpdateMessage : &quot;必须更新后才能使用&quot; ,
                    //非强制更新时，按钮文字,默认为&quot;ignore&quot;
                    optionalIgnoreButtonLabel : &#39;稍后&#39; ,
                    //非强制更新时，确认按钮文字. 默认为&quot;Install&quot;
                    optionalInstallButtonLabel : &#39;后台更新&#39; ,
                    //非强制更新时，检查到更新的消息文本
                    optionalUpdateMessage : &#39;有新版本了，是否更新？&#39; ,
                    //Alert窗口的标题
                    title : &#39;更新提示&#39;
                } ,
                deploymentKey: deploymentKey,
            } ,
        );
    }
}

App = CodePush(codePushOptions)(App);

export default App;
</code></pre>

<h5 id="toc_11">更新是否要求即时</h5>

<p>在更新配置中通过指定installMode来决定安装完成的重启时机，亦即更新生效时机</p>

<ul>
<li><code>codePush.InstallMode.IMMEDIATE</code> ：安装完成立即重启更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESTART</code> ：安装完成后会在下次重启后进行更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESUME</code> ：安装完成后会在应用进入后台后重启更新</li>
</ul>

<h4 id="toc_12">原生端配置</h4>

<p>通过之前的ReactNative添加依赖配置<code>react-native react-native-code-push</code>,原生代码会自动生成。<br/><br/>
无需手动配置。</p>

<h2 id="toc_13">私有化配置</h2>

<h3 id="toc_14">服务端</h3>

<p>参照文档进行配置<br/>
<a href="https://github.com/lisong/code-push-server">code-push-server</a></p>

<h3 id="toc_15">客户端</h3>

<ul>
<li>登录私有化服务器访问地址，端口号3000,输入账号密码(默认为admin,123456),获取token，登陆之后输入</li>
<li><code>code-push login http://api.code-push.com</code> login后面跟上服务端访问地址</li>
<li>Android配置(<code>MyApplication</code>类中<code>getPackages</code>方法中<code>CodePush</code>实例化的时候前面不变，自动从RN端获取deploymentKey,加上第四个参数，私有化服务器的访问地址)</li>
<li>iOS配置(info.plist文件中有<code>CodePushDeploymentKey</code>是<code>deploymentKey</code>，再添加一个参数<code>CodePushServerURL</code>，填上私有化服务器的访问地址)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 开发小记]]></title>
    <link href="http://adolph.cc/15597152983017.html"/>
    <updated>2019-06-05T14:14:58+08:00</updated>
    <id>http://adolph.cc/15597152983017.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">应用签名查看</h2>

<h3 id="toc_1">查询keystore的MD5</h3>

<pre class="line-numbers"><code class="language-text">keytool -list -v -keystore ***.jks
</code></pre>

<p><figure><img src="media/15597152983017/15597154233468.jpg" alt="" style="width:570px;"/></figure><br/>
MD5值就是所要的应用签名，只是比下面提到的签名生成工具生成的多出了中间的冒号</p>

<h3 id="toc_2">通过APK工具进行查看</h3>

<p><a href="media/15597152983017/GenSignature.apk">GenSignature</a><br/>
在该手机上安装正式打包的APK并运行，通过签名生成工具输入包名get signature获取应用签名，copy to clipboard即可。<br/>
<figure><img src="media/15597152983017/15597160146245.jpg" alt=""/></figure></p>

]]></content>
  </entry>
  
</feed>
