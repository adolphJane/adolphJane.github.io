<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MagicalRice的Blog]]></title>
  <link href="http://adolph.cc/atom.xml" rel="self"/>
  <link href="http://adolph.cc/"/>
  <updated>2020-02-16T22:07:44+08:00</updated>
  <id>http://adolph.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[个人信息]]></title>
    <link href="http://adolph.cc/15826122642335.html"/>
    <updated>2020-02-25T14:31:04+08:00</updated>
    <id>http://adolph.cc/15826122642335.html</id>
    <content type="html"><![CDATA[
<ul>
<li><strong>姓名:</strong>江若铭</li>
<li><strong>应聘职位:</strong>Android开发</li>
<li><strong>联系电话:</strong>180-6979-4073</li>
<li><strong>个人博客:</strong><a href="http://adolph.cc/">http://adolph.cc/</a></li>
<li><strong>GitHub:</strong><a href="https://github.com/adolphJane">https://github.com/adolphJane</a></li>
</ul>

<h2 id="toc_0">技能清单</h2>

<ul>
<li>3年移动开发设计经验，具有多前端（Android App，微信小程序，ReactNative，Flutter）开发能力</li>
<li>熟悉SpringBoot开发</li>
<li>掌握多种计算机语言：Java，Kotlin，Python，JS， Dart</li>
<li>熟悉常用Android系统源码及开源框架</li>
<li>熟悉Android自定义UI的实现</li>
<li>熟悉性能优化，插件化，热更新等常用开发策略</li>
<li>熟悉NDK开发</li>
<li>熟悉程序反编译及破解</li>
<li>熟悉产品设计研发上线以及版本迭代流程和项目管理流程</li>
</ul>

<h2 id="toc_1">工作经历</h2>

<h3 id="toc_2">Android工程师 杭州电鲸网络科技有限公司</h3>

<p><em>2017/03 - 2018/08</em></p>

<h4 id="toc_3">直播应用Android端</h4>

<ul>
<li>在Android客户端的基础架构之下进行业务开发以及代码优化</li>
<li>参与多个业务的用户界面设计，可灵活运用原⽣组件，以及自定义UI，追求良好的⽤户体验 </li>
<li>参与公共组件的封装，提升组件复用性，从⽽提升团队开发效率 </li>
<li>负责搭建以及维护客户端数据库</li>
<li>负责直播间礼物动画以及飘屏设计 </li>
<li>参与直播间游戏设计开发 </li>
<li>参与应⽤IM设计开发 </li>
<li>参与代码优化，内存管理等⼯作</li>
<li>负责部分项目文档填写</li>
</ul>

<h4 id="toc_4">直播小程序开发</h4>

<ul>
<li>参与小程序基础功能架构搭建</li>
<li>负责直播间游戏区部分功能模块实现</li>
<li>负责部分功能页面及逻辑实现</li>
</ul>

<h4 id="toc_5">自动化构建及测试</h4>

<ul>
<li>参与Android自动化构建系统(Jenkins)搭建</li>
<li>负责移动端自动化测试系统(Appium)搭建</li>
<li>使用Python编写自动化测试脚本</li>
</ul>

<h3 id="toc_6">Android工程师 杭州细叶科技有限公司</h3>

<p><em>2018/10 - 2019/10</em></p>

<p>核心开发组</p>

<h4 id="toc_7">商城应用</h4>

<p>独立开发</p>

<ul>
<li>采用MVVM模式作为架构</li>
<li>采用Kotlin语言进行开发</li>
<li>项目使用组件化形式进行开发</li>
<li>使用Rxjava+retrofit+OkHttp进行项目的数据传输和处理</li>
<li>集成支付宝支付功能</li>
<li>集成极光推送</li>
<li>部分功能原生与JS相互调用</li>
<li>原生实现简单IM通讯</li>
<li>集成Bugly的热修复功能</li>
<li>不断重构优化代码封装、调优</li>
</ul>

<h4 id="toc_8">混合App壳开发</h4>

<p>独立开发</p>

<ul>
<li>确定开发接口，来实现不同web端与原生交互功能</li>
<li>原生与WebView进行交互</li>
</ul>

<h4 id="toc_9">售卖机应用</h4>

<p>后期维护</p>

<ul>
<li>修复Bug，更新售卖机重启机制</li>
<li>部分代码优化</li>
</ul>

<h4 id="toc_10">咖啡机应用</h4>

<p>独立开发</p>

<ul>
<li>对接咖啡机硬件接口文档</li>
<li>采用Kotlin语言进行开发</li>
<li>采用MVP架构</li>
<li>基于OkHttp封装Socket网络模块</li>
</ul>

<h4 id="toc_11">借款应用</h4>

<p>独立开发</p>

<ul>
<li>采用Kotlin语言进行开发</li>
<li>采用MVVM模式作为架构</li>
<li>自定义View绘制可滑动圆形表盘</li>
<li>使用Rxjava+retrofit+OkHttp进行项目的数据传输和处理</li>
</ul>

<h4 id="toc_12">小说应用Android端</h4>

<p>独立开发</p>

<ul>
<li>采用Kotlin语言进行开发</li>
<li>采用MVVM模式作为架构</li>
<li>自定义阅读器页面，支持仿真，平移等翻页效果</li>
<li>设计阅读器章节缓存及广告申请显示的管理模式</li>
<li>使用Rxjava+retrofit+OkHttp进行项目的数据传输和处理</li>
</ul>

<h4 id="toc_13">小说应用ReactNative端</h4>

<p>独立开发</p>

<ul>
<li>项目的整体架构搭建</li>
<li>自定义View以及网络、本地存储模块的实现</li>
<li>实现小说阅读器模块功能</li>
<li>设计阅读器章节缓存及广告申请显示的管理模式</li>
<li>搭建热更新系统</li>
<li>使用Redux作为项目的状态管理工具</li>
</ul>

<h4 id="toc_14">信用卡应用ReactNative端</h4>

<p>合作开发</p>

<ul>
<li>自定义View模块的实现</li>
<li>部分功能模块的设计实现</li>
<li>使用Mobx作为项目的状态管理工具</li>
<li>搭建热更新系统</li>
<li>集成极光推送</li>
</ul>

<h4 id="toc_15">客服系统Android端SDK</h4>

<p>独立开发<br/>
提供给其他项目组接入实现客服系统功能</p>

<ul>
<li>采用Kotlin语言进行开发</li>
<li>采用MVP模式作为架构</li>
<li>使用跨进程方式开发，提高程序稳定性</li>
<li>实现聊天功能界面逻辑</li>
<li>基于OkHttp封装Socket网络模块</li>
<li>基于Fragment开发，方便自定义显示效果</li>
</ul>

<h4 id="toc_16">破解SDK</h4>

<p>独立开发</p>

<ul>
<li>通过网络抓包获取关键信息</li>
<li>反编译应用，分析混淆代码及Smail代码</li>
<li>使用Xposed框架hook应用方法，达到破解SDK的目的</li>
</ul>

<h4 id="toc_17">商城应用ReactNative端</h4>

<p>独立开发<br/>
复刻商城应用Android端</p>

<ul>
<li>项目的整体架构搭建</li>
<li>搭建热更新系统</li>
<li>使用Redux作为项目的状态管理工具</li>
<li>优化程序运行逻辑，提高渲染速度</li>
</ul>

<h2 id="toc_18">个人项目</h2>

<h3 id="toc_19">电影资讯APP</h3>

<p>使用TMDB提供的API，显示电影资讯</p>

<ul>
<li>采用Java语言进行开发</li>
<li>使用Dagger+MVVM+RxJava模式进行开发</li>
</ul>

<h3 id="toc_20">壁纸APP</h3>

<ul>
<li>使用jsoup库爬取网页信息并解析</li>
<li>采用Kotlin语言进行开发</li>
<li>采用MVVM模式作为架构</li>
<li>使用Room操作数据库</li>
<li>动画效果使用lottie动画</li>
</ul>

<h2 id="toc_21">教育经历</h2>

<p>2013 - 2017 厦⻔⼤学嘉庚学院 软件工程</p>

<h2 id="toc_22">个⼈人荣誉</h2>

<ul>
<li>大学⽣创新创业训练计划项⽬校级奖</li>
<li>多次获得一等、二等校级奖学金 </li>
<li>优秀三好学⽣</li>
<li>电鲸公司年终黑马奖</li>
</ul>

<h2 id="toc_23">个人证书</h2>

<ul>
<li>中级软件设计师 </li>
<li>英语六级</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IDEA 远程一键部署Spring Boot到Docker]]></title>
    <link href="http://adolph.cc/15818619982581.html"/>
    <updated>2020-02-16T22:06:38+08:00</updated>
    <id>http://adolph.cc/15818619982581.html</id>
    <content type="html"><![CDATA[
<p><a href="https://blog.csdn.net/qq_42914528/article/details/100029421?utm_source=distribute.pc_relevant.none-task">参考地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flutter VsCode插件]]></title>
    <link href="http://adolph.cc/15813395132789.html"/>
    <updated>2020-02-10T20:58:33+08:00</updated>
    <id>http://adolph.cc/15813395132789.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">1、Flutter 与 Dart</h2>

<p>这两个语法和开发插件，是必装的，装了Flutter，dart会自动被装上</p>

<blockquote>
<p><strong>Flutter</strong></p>
</blockquote>

<p><figure><img src="media/15813395132789/15813395929924.jpg" alt=""/></figure></p>

<blockquote>
<p><strong>Dart</strong></p>
</blockquote>

<p><figure><img src="media/15813395132789/15813396304666.jpg" alt=""/></figure></p>

<h2 id="toc_1">2、模版神器</h2>

<blockquote>
<p><strong>Awesome Flutter Snippets</strong><br/>
块模版快速生成</p>
</blockquote>

<p><figure><img src="media/15813395132789/15813396587504.jpg" alt=""/></figure></p>

<blockquote>
<p><strong>Flutter Widget Snippets</strong><br/>
块模版快速生成</p>
</blockquote>

<p><figure><img src="media/15813395132789/15813396703330.jpg" alt=""/></figure></p>

<blockquote>
<p><strong>flutter-stylizer</strong><br/>
可解决api不提示问题</p>
</blockquote>

<p><figure><img src="media/15813395132789/15813396931070.jpg" alt=""/></figure></p>

<h2 id="toc_2">3、对Dart语法有帮助的神器</h2>

<blockquote>
<p><strong>Bracket Pair Colorizer</strong><br/>
都知道Dart与Python不同，走了截然不同的道路，Py语法尽量剔除括号，而Dart中处处存在括号，这个插件有效的帮你识别括号囊括的范围，并在括号结尾自动注释对应api</p>
</blockquote>

<p><figure><img src="media/15813395132789/15813397706573.jpg" alt=""/></figure></p>

<p><figure><img src="media/15813395132789/15813398235612.jpg" alt=""/></figure></p>

<h2 id="toc_3">4、对项目开发有帮助的插件</h2>

<blockquote>
<p><strong>Material Icon Theme</strong><br/>
用于分清主题各个不同类型文件，做的很详细，推荐</p>
</blockquote>

<p><figure><img src="media/15813395132789/15813398151900.jpg" alt=""/></figure><br/>
<figure><img src="media/15813395132789/15813398318514.jpg" alt=""/></figure></p>

<blockquote>
<p><strong>GitLens</strong><br/>
VSCode 中强大的 Git 工具，VSCode 必装插件之一。堪称神器，用了完全离不开了。</p>

<p><strong>IntelliJ IDEA Key Bindings for Visual Studio Code</strong><br/>
如果你是从别的代码工具中转过来的，对 vscode 的快捷键不喜欢，可以安装你熟悉的编辑器快捷键插件。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flutter 组件小记]]></title>
    <link href="http://adolph.cc/15809146907844.html"/>
    <updated>2020-02-05T22:58:10+08:00</updated>
    <id>http://adolph.cc/15809146907844.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Offstage组件</h2>

<p>控制child是否显示。</p>

<p>当<code>offstage</code>为<code>true</code>，控件隐藏； 当<code>offstage</code>为<code>false</code>，显示。</p>

<blockquote>
<p>当<code>Offstage</code>不可见的时候，如果<code>child</code>有动画等，需要手动停掉，<code>Offstage</code>并不会停掉动画等操作。</p>
</blockquote>

<h2 id="toc_1">WillPopScope组件</h2>

<p>双击返回与界面退出提示</p>

<p><code>onWillPop</code> 就表示当前页面将退出。 值类型是一个函数 <code>typedef Future&lt;bool&gt; WillPopCallback();</code>返回 <code>Future.value(false);</code> 表示不退出.返回 <code>Future.value(true);</code> 表示退出.</p>

<h2 id="toc_2">SafeArea组件</h2>

<p>大部分情况下，使用SafeArea能很好的解决刘海，不规则屏幕的显示问题。</p>

<h2 id="toc_3">InkWell组件</h2>

<p>产生水波纹效果。</p>

<p>使用场景是给一些无点击事件的部件添加点击事件时使用（也支持长按、双击等事件），同时你也可以去修改它的颜色和形状。</p>

<h2 id="toc_4">AutomaticKeepAliveClientMixin组件</h2>

<p>AutomaticKeepAliveClientMixin 这个 Mixin 是 Flutter 为了保持页面设置的。哪个页面需要保持页面状态，就在这个页面进行混入。</p>

<p>不过使用使用这个 Mixin 是有几个先决条件的：</p>

<p>使用的页面必须是 StatefulWidget，如果是 StatelessWidget 是没办法办法使用的。<br/>
其实只有两个前置组件才能保持页面状态：PageView 和 IndexedStack。<br/>
重写 wantKeepAlive 方法，如果不重写也是实现不了的。</p>

<h2 id="toc_5">PageView 相当于ViewPager</h2>

<ul>
<li>PageView - 创建一个可滚动列表。</li>
<li>PageView.builder - 创建一个滚动列表，指定数量。</li>
<li>PageView.custom - 创建一个可滚动的列表，自定义子项。</li>
</ul>

<p>常用属性: </p>

<ul>
<li>childrenDelegate → SliverChildDelegate - 子项列表。</li>
<li>controller → PageController - 控制器。</li>
<li>onPageChanged → ValueChanged - 索引改变时触发。</li>
<li>pageSnapping → bool - 设置为 false 以禁用页面捕捉，对自定义滚动行为很有用。</li>
<li>physics → ScrollPhysics - 页面视图如何响应用户输入，即滚动的动画表现。</li>
<li>reverse → bool - 是否反方向。</li>
<li>scrollDirection → Axis - 视图滚动的方向。</li>
</ul>

<h2 id="toc_6">MediaQuery.removePadding</h2>

<p>可以移除元素的pandding，需要注意要指定移除哪个方向的padding。</p>

<pre class="line-numbers"><code class="language-dart">MediaQuery.removePadding(
            removeTop: true,
            context: context,
            child: ,
)
</code></pre>

<h2 id="toc_7">ValueListenableBuilder</h2>

<p>配合ValueNotifier<T>使用,修改状态可以不用setState()。</p>

<h2 id="toc_8">SearchDelegate 系统的搜索界面</h2>

<p>继承<code>SearchDelegate&lt;String&gt;</code>之后需要重写一些方法，这里给定的<code>String</code>类型是指搜索query的类型为<code>String</code>。</p>

<pre class="line-numbers"><code class="language-text">class searchBarDelegate extends SearchDelegate&lt;String&gt; {
  @override
  List&lt;Widget&gt; buildActions(BuildContext context) {
    return null;
  }

  @override
  Widget buildLeading(BuildContext context) {
    return null;
  }

  @override
  Widget buildResults(BuildContext context) {
    return null;
  }

  @override
  Widget buildSuggestions(BuildContext context) {
    return null;
  }


  @override
  ThemeData appBarTheme(BuildContext context) {
    // TODO: implement appBarTheme
    return super.appBarTheme(context);
  }
}
</code></pre>

<ul>
<li><code>List&lt;Widget&gt; buildActions(BuildContext context)</code>:这个方法返回一个控件列表，显示为搜索框右边的图标按钮，这里设置为一个清除按钮,并且在搜索内容为空的时候显示建议搜索内容，使用的是<code>showSuggestions(context)</code>方法。</li>
<li><code>showSuggestions(context)</code>：这个方法显示建议的搜索内容，也就是<code>Widget buildSuggestions(BuildContext context)</code>方法的的调用。</li>
<li><code>Widget buildLeading(BuildContext context)</code>:这个方法返回一个控件，显示为搜索框左侧的按钮，一般设置为返回，这里返回一个具有动态效果的返回按钮。</li>
<li><code>Widget buildSuggestions(BuildContext context)</code>:这个方法返回一个控件，显示为搜索内容区域的建议内容。</li>
<li><code>Widget buildResults(BuildContext context)</code>:这个方法返回一个控件，显示为搜索内容区域的搜索结果内容。</li>
<li><code>ThemeData appBarTheme(BuildContext context)</code>：这个方法返回一个主题，也就是可以自定义搜索界面的主题样式。</li>
<li>调用<code>showSearch(context: context, delegate: searchBarDelegate())</code>方法跳转到搜索界面</li>
</ul>

<h2 id="toc_9">SizedBox</h2>

<ul>
<li>一般的<code>SizeBox()</code>构造方法:传width、height、child,SizedBox会强制设置它的孩子的宽度或者高度为指定值</li>
<li><code>SizeBox.expand()</code>:可以使SizedBox的大小充满parent的布局，相当于设置了SizedBox的宽度和高度为double.infinity(无穷大)。</li>
<li><code>SizedBox.shrink()</code>: 创建一个尽可能小的SizedBox。</li>
<li><code>SizeBox.fromSize()</code>:创建一个指定Size的SizedBox</li>
<li><code>FractionallySizedBox()</code>:可以用百分比来控制sizebox的大小。 widthFactor，heightFactor参数就是相对于父控件的比例。 alignment：可以设置sizebox在父控件里面的相对位置。</li>
<li><code>SizedOverflowBox()</code>:通过设置Size，允许它的child控件，溢出它的父控件，进行绘制，不会报OverFlow的错误。</li>
<li><code>OverflowBox()</code>：通过设置最大最小的宽高，OverflowBox允许它的child控件，溢出它的父控件，进行绘制，不会报OverFlow的错误。</li>
<li><code>LimtedBox()</code>:一个可以限制子控件的最大宽高的控件，child只能在这区域内进行绘制</li>
</ul>

<h2 id="toc_10">CustomScrollView</h2>

<p>可以使用各种sliver来实现各种酷炫的滚动效果,它的slivers属性里可以放置各种sliver组件。</p>

<h2 id="toc_11">SliverToBoxAdapter</h2>

<p>child属性可以加载普通widget组件</p>

<h2 id="toc_12">SliverPadding</h2>

<p>可以设置padding，子widget为sliver</p>

<h2 id="toc_13">SliverGrid</h2>

<p>SliverGrid 可以设置固定一行显示几个SliverGridDelegateWithFixedCrossAxisCount，也可以SliverGridDelegateWithMaxCrossAxisExtent设置子元素最大宽度，让flutter决定一行几个。count和extent就是封装方法。</p>

<ul>
<li><code>SliverGrid.count()</code> 指定了一行展示多少个item，下面的例子表示一行展示4个</li>
<li><code>SliverGrid.extent()</code> 可以指定item的最大宽度，然后让Flutter自己决定一行展示多少个item</li>
<li><code>SliverGrid()</code> 则是需要指定一个gridDelegate，它提供给了 程序员 一个自定义Delegate的入口，你可以自己决定每一个item怎么排列</li>
</ul>

<h2 id="toc_14">SliverList</h2>

<p>类似ListView，他有两种表现形式：SliverChildBuilderDelegate和SliverChildListDelegate，两者区别在于SliverChildBuilderDelegate可以加载不确定数量的列表，而SliverChildListDelegate只能加载固定已知数量。</p>

<h2 id="toc_15">SliverFixedExtentList</h2>

<p>SliverFixedExtentList与SliverList类似，唯一区别是SliverFixedExtentList可以设置固定高度。</p>

<h2 id="toc_16">SliverPersistentHeader</h2>

<p>有点类似<code>SliverAppBar</code>，同样可以收起和展开，可以放置到<code>slivers</code>任何一个位置。</p>

<ul>
<li><code>floating</code>: 为 <code>true</code> 时，与<code>SliverAppBar</code>用法一致</li>
<li><code>pinned</code>：与<code>SliverAppBar</code>用法一致，且与<code>floating</code>不能同时为true</li>
<li><code>delegate</code>: 构建一个<code>SliverPersistentHeader</code>需要传入一个<code>delegate</code>，这个<code>delegate</code>是<code>SliverPersistentHeaderDelegate</code>类型的，而<code>SliverPersistentHeaderDelegate</code>是一个<code>abstract</code>类，我们不能直接<code>new</code>一个<code>SliverPersistentHeaderDelegate</code>出来，因此，我们需要自定义一个<code>delegate</code>来实现<code>SliverPersistentHeaderDelegate</code>类</li>
</ul>

<p>写一个自定义<code>SliverPersistentHeaderDelegate</code>很简单，只需重写<code>build()</code>、<code>get maxExtent</code>、<code>get minExtent</code>和<code>shouldRebuild()</code>这四个方法，上面就是一个最简单的<code>SliverPersistentHeaderDelegate</code>的实现。其中，<code>maxExtent</code>表示<code>header</code>完全展开时的高度，<code>minExtent</code>表示<code>header</code>在收起时的最小高度。因此，对于我们上面的那个自定义<code>Delegate</code>，如果将<code>minHeight</code>和<code>maxHeight</code>的值设置为相同时，<code>header</code>就不会收缩了，这样的Header跟我们平常理解的Header更像。</p>

<h2 id="toc_17">SliverAppBar</h2>

<p>可伸缩的头部，可以实现上拉收起，下拉展开效果</p>

<ul>
<li><code>expandedHeight</code>: 最大扩展高度</li>
<li><code>flexibleSpace</code>: 扩展内容区域</li>
<li><code>floating</code>: 为<code>true</code>则在滚动时优先滚动，有下拉动作先<code>appbar</code>后<code>flexibleSpace</code>，反之亦然</li>
<li><code>snap</code>: 为<code>true</code>时没有变化，正在查证</li>
<li><code>pinned</code>：为<code>true</code>则<code>appbar</code>不消失，在下拉时会多划出一段距离<code>SliverAppBar</code>才开始滚动</li>
</ul>

<h2 id="toc_18">FlexibleSpaceBar 可折叠的应用栏</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flutter常用第三方库]]></title>
    <link href="http://adolph.cc/15808782889824.html"/>
    <updated>2020-02-05T12:51:28+08:00</updated>
    <id>http://adolph.cc/15808782889824.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">provider 状态管理</h2>

<p><a href="https://pub.dev/packages/provider">pub.dev</a><br/>
<a href="https://github.com/rrousselGit/provider">Github</a><br/>
<a href="https://pub.dev/documentation/provider/latest/provider/provider-library.html">API</a></p>

<h2 id="toc_1">shared_preferences 本地存储</h2>

<p><a href="https://pub.dev/packages/shared_preferences">pub.dev</a><br/>
<a href="https://github.com/flutter/plugins/tree/master/packages/shared_preferences">Github</a><br/>
<a href="https://pub.dev/documentation/shared_preferences/latest/index.html">API</a></p>

<h2 id="toc_2">localstorage 本地json对象存储</h2>

<p><a href="https://pub.flutter-io.cn/packages/localstorage">pub.dev</a><br/>
<a href="https://github.com/lesnitsky/flutter_localstorage">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/localstorage/latest/">API</a></p>

<h2 id="toc_3">oktoast Toast消息提示控件</h2>

<p><a href="https://pub.flutter-io.cn/packages/oktoast">pub.dev</a><br/>
<a href="https://github.com/OpenFlutter/flutter_oktoast">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/oktoast/latest/">API</a></p>

<h2 id="toc_4">pull_to_refresh 下拉刷新控件</h2>

<p><a href="https://pub.flutter-io.cn/packages/pull_to_refresh">pub.dev</a><br/>
<a href="https://github.com/peng8350/flutter_pulltorefresh">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/pull_to_refresh/latest/">API</a></p>

<h2 id="toc_5">path_provider 获取应用文件系统目录</h2>

<p><a href="https://pub.flutter-io.cn/packages/path_provider">pub.dev</a><br/>
<a href="https://github.com/flutter/plugins/tree/master/packages/path_provider">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/path_provider/latest/">API</a></p>

<h2 id="toc_6">flutter_swiper 轮播组件</h2>

<p><a href="https://pub.flutter-io.cn/packages/flutter_swiper">pub.dev</a><br/>
<a href="https://github.com/best-flutter/flutter_swiper">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/flutter_swiper/latest/">API</a></p>

<h2 id="toc_7">dio 网络请求组件</h2>

<p><a href="https://pub.flutter-io.cn/packages/dio">pub.dev</a><br/>
<a href="https://github.com/flutterchina/dio">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/dio/latest/">API</a></p>

<h2 id="toc_8">flutter_screenutil 屏幕适配组件</h2>

<p><a href="https://pub.flutter-io.cn/packages/flutter_screenutil">pub.dev</a><br/>
<a href="https://github.com/OpenFlutter/flutter_screenutil">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/flutter_screenutil/latest/">API</a></p>

<h2 id="toc_9">package_info 获取应用信息(appName/buildNumber/packageName/version)</h2>

<p><a href="https://pub.flutter-io.cn/packages/package_info">pub.dev</a><br/>
<a href="https://github.com/flutter/plugins/tree/master/packages/package_info">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/package_info/latest/">API</a></p>

<h2 id="toc_10">device_info 获取设备信息</h2>

<p><a href="https://pub.flutter-io.cn/packages/device_info">pub.dev</a><br/>
<a href="https://github.com/flutter/plugins/tree/master/packages/device_info">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/device_info/latest/">API</a></p>

<h2 id="toc_11">crypto 加密解密工具库(SHA-1/SHA-224/SHA-256/SHA-384/SHA-512/MD5/HMAC)</h2>

<p><a href="https://pub.flutter-io.cn/packages/crypto">pub.dev</a><br/>
<a href="https://pub.flutter-io.cn/documentation/crypto/latest/">API</a></p>

<h2 id="toc_12">html_unescape 反转义HTML</h2>

<p><a href="https://pub.flutter-io.cn/packages/html_unescape">pub.dev</a><br/>
<a href="https://github.com/filiph/html_unescape">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/html_unescape/latest/">API</a></p>

<h2 id="toc_13">dio_cookie_manager Cookie管理工具</h2>

<p><a href="https://pub.flutter-io.cn/packages/dio_cookie_manager">pub.dev</a><br/>
<a href="https://github.com/flutterchina/dio">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/dio_cookie_manager/latest/">API</a></p>

<h2 id="toc_14">Shimmer 骨架屏特效</h2>

<p><a href="https://pub.flutter-io.cn/packages/shimmer">pub.dev</a><br/>
<a href="https://github.com/hnvn/flutter_shimmer">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/shimmer/latest/">API</a></p>

<h2 id="toc_15">webview_flutter 官方WebView插件，可以内嵌</h2>

<p><a href="https://pub.flutter-io.cn/packages/webview_flutter">pub.dev</a><br/>
<a href="https://github.com/flutter/plugins/tree/master/packages/webview_flutter">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/webview_flutter/latest/">API</a></p>

<h2 id="toc_16">flutter_webview_plugin 社区WebView插件，跳转到新的页面</h2>

<p><a href="https://pub.flutter-io.cn/packages/flutter_webview_plugin">pub.dev</a><br/>
<a href="https://github.com/dart-flitter/flutter_webview_plugin">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/flutter_webview_plugin/latest/">API</a></p>

<h2 id="toc_17">cached_network_image 图片加载框架</h2>

<p><a href="https://pub.flutter-io.cn/packages/cached_network_image">pub.dev</a><br/>
<a href="https://github.com/renefloor/flutter_cached_network_image">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/cached_network_image/latest/">API</a></p>

<h2 id="toc_18">flutter_html 解析HTML标签</h2>

<p><a href="https://pub.flutter-io.cn/packages/flutter_html">pub.dev</a><br/>
<a href="https://github.com/Sub6Resources/flutter_html">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/flutter_html/latest/">API</a></p>

<h2 id="toc_19">flare_flutter flare动画插件</h2>

<p><a href="https://pub.flutter-io.cn/packages/flare_flutter">pub.dev</a><br/>
<a href="https://github.com/2d-inc/Flare-Flutter">Github</a><br/>
<a href="https://pub.flutter-io.cn/documentation/flare_flutter/latest/">API</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[添加环境变量]]></title>
    <link href="http://adolph.cc/15767453112302.html"/>
    <updated>2019-12-19T16:48:31+08:00</updated>
    <id>http://adolph.cc/15767453112302.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">bash shell</h2>

<p>Mac默认是bash shell 配置变量在跟目录中，编辑：</p>

<pre class="line-numbers"><code class="language-text">vi ~/.bash_profile
</code></pre>

<p>通过export将变量导出去</p>

<pre class="line-numbers"><code class="language-text">export ANDROID_HOME=~/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
</code></pre>

<p><strong>注意:</strong>变量与变量之间用:分割</p>

<h2 id="toc_1">zsh shell</h2>

<pre class="line-numbers"><code class="language-text">vi ~/.zshrc
// 如果跟目录没有.zshrc的话，执行下面的命令
cash  ~/.zshrc
vi ~/.zshrc
</code></pre>

<p>在最下面添加</p>

<pre class="line-numbers"><code class="language-text">export ANDROID_HOME=~/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代理模式]]></title>
    <link href="http://adolph.cc/15712984956484.html"/>
    <updated>2019-10-17T15:48:15+08:00</updated>
    <id>http://adolph.cc/15712984956484.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">代理模式介绍</h2>

<p>代理模式(Proxy Pattern)也称为委托模式，在我们日常生活中也不少见，对于程序员来说最常接触的莫过于代理上网，连上代理服务器地址，就可以轻松畅游全世界的网络；还有每天吃饭时赶进度是常事，叫公司的同事帮忙买饭也是一种代理；如果你碰到辞职老板不给你发工资，那么你还得请个律师帮你打官司，这也是一种代理。总而言之，也许你并不留意，但是代理的确无处不在，现实生活中如此，我们的Code世界也是如此。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">代理模式的定义</h2>

<p>为其他对象提供一种代理以控制对这个对象的访问</p>

<h2 id="toc_2">代理模式的使用场景</h2>

<p>当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，委托对象与代理对象需要实现相同的接口。</p>

<h2 id="toc_3">代理模式的简单实现</h2>

<p>就以请律师进行诉讼来举例子</p>

<p><strong>诉讼接口类</strong></p>

<pre class="line-numbers"><code class="language-java">public interface ILawsuit {
    //提交申请
    void submit();
    
    //进行举证
    void burden();
    
    //开始辩护
    void defend();
    
    //诉讼完成
    void finish();
}
</code></pre>

<p><strong>具体诉讼人</strong></p>

<pre class="line-numbers"><code class="language-java">public class XiaoTian implements ILawsuit {
    @Override
    public void submit() {
        //老板欠小天工资，小天只好申请仲裁
        System.out.println(&quot;老板拖欠工资！特此申请仲裁！&quot;);
    }
    
    @Override
    public void burden() {
        //小天证据充足，不怕告不赢
        System.out.println(&quot;这是合同书和过去一年的银行工资流水!&quot;);
    }
    
    @Override
    public void defend() {
        //铁证如山，辩护也没什么好说的
        System.out.println(&quot;证据确凿!不需要再说什么了!&quot;);
    }
    
    @Override
    public void finish() {
        //结果也是肯定的，必赢
        System.out.println(&quot;诉讼成功!判决老板即日起七天内结算工资&quot;);
    }
}
</code></pre>

<p>当然小天是不会自己去打官司的，于是请了个代理律师代替自己诉讼</p>

<p><strong>代理律师</strong></p>

<pre class="line-numbers"><code class="language-java">public class Lawyer implements ILawsuit {
    private ILawsuit mLawsuit;  //持有一个具体被代理者的引用
    
    public Lawyer(ILawsuit lawsuit) {
        mLawsuit = lawsuit;
    }
    
    @Override
    public void submit() {
        mLawsuit.submit();
    }
    
    @Override
    public void burden() {
        mLawsuit.burden();
    }
    
    @Override
    public void defend() {
        mLawsuit.defend();
    }
    
    @Override
    public void finish() {
        mLawsuit.finish();
    }
}
</code></pre>

<p>律师类表示代理者律师，在该类里面会持有一个被代理者的引用，律师所执行的方法实质就是简单地调用被代理者中的方法</p>

<p><strong>客户类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Client {
    public static void main(String[] args) {
        //构造一个小天...
        ILawsuit xiaotian = new XiaoTian();
        
        //构造一个代理律师将小天作为构造参数传进去
        ILawsuit lawyer = new Lawyer(xiaotian);
        
        //律师提交诉讼申请
        lawyer.submit();
        
        //律师进行举证
        lawyer.burden();
        
        //律师代理小天进行辩护
        lawyer.defend();
        
        //完成诉讼
        lawyer.finish();
    }
}
</code></pre>

<p>上诉例子使用的是静态代理模式，也可以代理多个类，同时代理多个人进行打官司。静态代理，代理者的代码由程序员自己或通过一些自动化工具生成固定的代码在对其进行编译，也就是说在我们的代码运行前代理类的class编译文件就已存在；而动态代理则与静态代理相反，通过反射机制动态地生成代理者的对象，也就是说我们再code阶段压根就不需要知道代理谁，代理谁我们将会在执行阶段决定。而Java也给我们提供了一个便捷的动态代理接口InvocationHandler，实现该接口需要重写其调用方法invoke。</p>

<p>我们主要通过invoke方法来调用具体的被代理方法，也就是真实的方法。动态代理可以使我们的代码逻辑更简洁，不过在这之间我们得首先完善动态代理类。</p>

<pre class="line-numbers"><code class="language-java">public class DynamicProxy implements InvocationHandler {
    private Objcet obj;  //被代理的类引用
    
    public DynamicProxy(Object obj) {
        this.obj = obj;
    }
    
    @Override
    public Object invoke(Object arg0, Method arg1, Object[] arg2) throws Throwable {
        //调用被代理类对象的方法
        Object result = method.invoke(obj.args);
        return result;
    }
}
</code></pre>

<p>如上代码所述，我们声明一个Object的引用，该引用指向被代理类，而我们调用被代理类的具体方法则在invoke方法中执行。也就是说我们原来由代理类所做的工作现在由InvocationHandler来处理，不再需要关心到底代理谁。</p>

<p><strong>修改后的客户类</strong></p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    //构造一个小天
    ILawsuit xiaotian = new XiaoTian();
    
    //构建一个动态代理
    DynamicProxy proxy = new DynamicProxy(xiaotian);
    
    //获取被代理类小天的ClassLoader
    ClassLoader loader = xiaotian.getClass().getClassLoader();
    
    //动态构造一个代理律师
    ILawsuit lawyer = (ILawsuit) Proxy.newProxyInstance(loader, new Class[] {ILawsuit.class}, proxy);
    
    //律师提交诉讼申请
    lawyer.submit();
    
    //律师进行举证
    lawyer.burden();
    
    //律师代替小天进行辩护
    lawyer.defend();
    
    //完成诉讼
    lawyer.finish();
}
</code></pre>

<p>由此可见动态代理通过一个代理类来代理N个被代理类，其实质是对代理者与被代理者进行解耦，使两者之间没有直接的耦合关系。相对而言静态代理则只能为给定接口下的实现类做代理，如果接口不同那么就需要重新定义不同代理类，较为复杂，但是静态代理更符合面向对象原则。</p>

<h2 id="toc_4">总结</h2>

<p>其他结构型模式中，都可以看到代理模式的影子，有些模式单独作为一种设计模式，倒不如说是对代理模式的一种针对性优化。而且代理模式几乎没有什么缺点可言，它是细分化至很小的一种模式。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[备忘录模式]]></title>
    <link href="http://adolph.cc/15712937841703.html"/>
    <updated>2019-10-17T14:29:44+08:00</updated>
    <id>http://adolph.cc/15712937841703.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">备忘录模式介绍</h2>

<p>备忘录模式是一种行为模式，该模式用于保存对象当前状态，并且在之后可以再次恢复到此状态，这有点像我们平时说的“后悔药”。备忘录模式实现的方式需要保证被保存的对象状态不能被对象从外部访问，目的是为了保护好被保护的这些对象状态的完整性以及内部实现不向外暴露。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">备忘录模式的定义</h2>

<p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样，以后就可以将该对象恢复到原先保存的状态。</p>

<h2 id="toc_2">备忘录模式的使用场景</h2>

<ol>
<li>需要保存一个对象在某个时刻的状态或部分状态</li>
<li>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以间接访问其内部状态。</li>
</ol>

<h2 id="toc_3">备忘录模式的简单示例</h2>

<p>对备忘录模式来说，比较贴切的场景应该是游戏中的存档功能，该功能就是将游戏进度存储到本地文件系统或者数据库中，下次再次进入时从本地加载进度，使得玩家能够继续上一次的游戏之旅，这里我们就以“使命召唤”这款游戏为例来简单演示一下备忘录模式的实现。<br/>
首先我们建立游戏类、备忘录类、Caretaker类，玩游戏到某个节点对游戏进行存档，然后退出游戏，再重新进入时从存档中读取进度，并且进入存档时的进度。</p>

<p><strong>游戏类</strong></p>

<pre class="line-numbers"><code class="language-java">/**
 * 使命召唤游戏(数据模型可能不太合理，这里我们只是简单演示)
 */
public class CallOfDuty {
    private int mCheckpoint = 1;
    private int mLifeValue = 100;
    private String mWeapon = &quot;沙漠之鹰&quot;;
    
    //玩游戏
    public void play() {
        System.out.println(&quot;玩游戏：&quot; + String.format(&quot;第%d关&quot;, mCheckpoint) + &quot; 奋战杀敌中&quot;);
        mLifeValue -= 10;
        System.out.println(&quot;进度升级啦&quot;);
        mCheckpoint++;
        System.out.println(&quot;到达&quot; + String.format(&quot;第%d关&quot;, mCheckpoint));
    }
    
    //退出游戏
    public void quit() {
        System.out.println(&quot;----------&quot;);
        System.out.println(&quot;退出前的游戏属性：&quot; + this.toString());
        System.out.println(&quot;退出游戏&quot;);
        System.out.println(&quot;----------&quot;);
    }
    
    //创建备忘录
    public Memoto createMemoto() {
        Memoto memoto = new Memoto();
        memoto.mCheckpoint = mCheckpoint;
        memoto.mLifeValue = mLifeValue;
        memoto.mWeapon = mWeapon;
        return memoto;
    }
    
    //恢复游戏
    public void restore(Memoto memoto) {
        this.mCheckpoint = memoto.mCheckpoint;
        this.mLifeValue = memoto.mLifeValue;
        this.mWeapon = memoto.mWeapon;
        System.out.println(&quot;恢复后的游戏属性：&quot; + this.toString());
    }
    
    @Override
    public String toString() {
        return &quot;CallOfDuty [mCheckpoint = &quot; + mCheckpoint + &quot;, mLifeValue=&quot; + mLifeValue + &quot;, Weapon=&quot; + mWeapon + &quot;]&quot;;
    }
}
</code></pre>

<p>在CallOfDuty游戏类中，我们存储了几个关键字段，关卡、人物的生命值、武器，当调用play函数玩游戏时，我们对关卡和人物的生命值进行修改。在该类中可以通过createMemoto函数来创建该用户的备忘录对象，也就是将自身的状态保存到一个Memoto对象中。外部可以通过restore函数将CallOfDuty对象的状态从备忘录对象中恢复。</p>

<p><strong>备忘录类</strong></p>

<pre class="line-numbers"><code class="language-java">/**
 * 备忘录
 */
public class Memoto {
    public int mCheckpoint;
    public int mLifeValue;
    public String mWeapon;
    
    @Override
    public String toString() {
        return &quot;Memoto [mCheckpoint=&quot; + mCheckpoint + &quot;, mLifeValue=&quot; + mLifeValue + &quot;, mWeapon=&quot; + mWeapon + &quot;]&quot;;
    }
} 
</code></pre>

<p>这是一个无状态、无操作的实体类，只负责用来存储Originator角色的一些数据，房子外部直接访问Originator。</p>

<p>而备忘录的操作者则是Caretaker角色</p>

<p><strong>Caretaker</strong></p>

<pre class="line-numbers"><code class="language-java">/**
 * Caretaker，负责管理Memoto
 */
public class Caretaker {
    Memoto mMemoto; //备忘录
    
    /**
     * 存档
     */
    public void archive(Memoto memoto) {
        this.mMemoto = memoto;
    } 
    
    /**
     * 获取存档
     */
    public Memoto getMemoto() {
        return mMemoto;
    } 
} 
</code></pre>

<p>Caretaker类的职责很简单，就是负责管理Memoto对象</p>

<p><strong>客户端</strong></p>

<pre class="line-numbers"><code class="language-java">public class Client {
    public static void main(String[] args) {
        //构建游戏对象
        CallOfDuty game = new CallOfDuty();
        //打游戏
        game.play();
        
        Caretaker caretaker = new Caretaker();
        //游戏存档
        caretaker.archive(game.createMemoto());
        //退出游戏
        game.quit();
        //恢复游戏
        CallOfDuty newGame = new CallOfDuty();
        newGame.restore(caretaker.getMemoto());
    }
}
</code></pre>

<p>CallOfDuty是需要存储数据的对象，在这里并没有直接存储CallOfDuty的对象，而是通过Memoto对CallOfDuty对象的数据进行存储，然后再存储Memoto对象，最终对Memoto的存取操作则交给Caretaker对象。在这个过程中，各个角色职责清晰、单一，代码也比较简单，即对外屏蔽了对CallOfDuty角色的直接访问，在满足了对象状态存取功能的同时也使得该模块的结构保持清晰、整洁。</p>

<h2 id="toc_4">总结</h2>

<p>备忘录模式是在不破坏封装的条件下，通过备忘录对象存储另外一个对象内部状态的快照，在将来合适的时候把这个对象还原到存储起来的状态。</p>

<p><strong>优点</strong></p>

<ul>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节</li>
</ul>

<p><strong>缺点</strong></p>

<p>消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[观察者模式]]></title>
    <link href="http://adolph.cc/15711947460528.html"/>
    <updated>2019-10-16T10:59:06+08:00</updated>
    <id>http://adolph.cc/15711947460528.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">观察者模式介绍</h2>

<p>观察者模式是一个使用率非常高的模式，它最常用的地方是GUI系统、订阅 —— 发布系统。因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小，甚至做到毫无依赖。以GUI系统来说，应用的UI具有易变性，尤其是前期随着业务的改变或者产品的需求修改，应用界面也会经常性变化，但是业务逻辑基本变化不大，此时，GUI系统需要一套机制来应对这种情况，使得UI层与具体的业务逻辑解耦，观察者模式此时就派上用场了。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">观察者模式的定义</h2>

<p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>

<h2 id="toc_2">观察者模式的使用场景</h2>

<ul>
<li>关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系</li>
<li>事件多级触发场景</li>
<li>跨系统的消息交换场景，如消息队列、事件总线的处理机制</li>
</ul>

<h2 id="toc_3">观察者模式的简单实现</h2>

<p>下面就我们来简单模拟一下开发技术前线的发布——订阅过程</p>

<pre class="line-numbers"><code class="language-java">//程序员是观察者
public class Coder implements Observer {
    public String name;
    
    public Coder(String aName) {
        name = aName;
    }
    
    @Override
    public void update(Observable o, Object arg) {
        System.out.println(&quot;Hi, &quot; + name + &quot;, DevTechFrontier更新啦，内容：&quot; + arg);
    }
    
    @Override
    public String toString() {
        return &quot;码农： &quot; + name;
    }
}

//DevTechFrontier即开发技术前线，这个网站是被观察者角色，当它有更新时所有的观察者(程序员)，都会接到相应的通知
public class DevTechFrontier extends Observable {
    public void postNewPublication(String content) {
        //标识状态或者内容发生变化
        setChanged();
        //通知所有观察者
        notifyObservers(content);
    }
}

//测试代码
public class Test {
    public static void main(String[] args) {
        //被观察者的角色
        DevTechFrontier frontier = new DevTechFrontier();
        //观察者
        Coder mrsimple = new Coder(&quot;mr.simple&quot;);
        Coder coder1 = new Coder(&quot;coder-1&quot;);
        Coder coder2 = new Coder(&quot;coder-2&quot;);
        Coder coder3 = new Coder(&quot;coder-3&quot;);
        
        //将观察者注册到可观察对象的观察者列表中
        DevTechFrontier.addObserver(mrsimple);
        DevTechFrontier.addObserver(coder1);
        DevTechFrontier.addObserver(coder2);
        DevTechFrontier.addObserver(coder3);
        
        //发布消息
        DevTechFrontier.postNewPublication(&quot;新的一期开发技术前线周报发布啦!&quot;);
    }
}
</code></pre>

<p>Observer 和 Observable是JDK中的内置类型，可见观察者模式是非常重要的，这里Observer是抽象的观察者角色，Coder扮演的是具体观察者的角色；Observable对应的是抽象主题角色，DevTecFrontier则是具体的主题角色。Coder订阅了DevTechFrontier，当DevTechFrontier有更新时，会遍历所有观察者，然后给这些观察者发布一个更新的消息，即调用Coder中的update方法，这样就达到了一对多的通知功能。</p>

<h2 id="toc_4">总结</h2>

<p>观察者模式主要的作用就是对象解耦，将观察者和被观察者完全隔离，只依赖于Observer和Observable抽象。例如，ListView就是运用了Adapter和观察者模式使得它的可扩展性、灵活性非常强，而耦合度很低，这是设计模式在Android源码中优秀运用的典范。</p>

<p><strong>优点</strong></p>

<ul>
<li>观察者和被观察者之间是抽象耦合，应对业务变化</li>
<li>增强系统灵活性、可扩展性</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>在应用观察者模式时需要考虑下开发效率和运行效率问题，程序中包括一个被观察者、多个观察者、开发和调试等内容会比较复杂，而且在Java中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[策略模式]]></title>
    <link href="http://adolph.cc/15711314242192.html"/>
    <updated>2019-10-15T17:23:44+08:00</updated>
    <id>http://adolph.cc/15711314242192.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">策略模式介绍</h2>

<p>在软件开发中也常常遇到这样的情况：实现某一个功能可以有多种算法或策略，我们根绝实际情况选择不同的算法或者策略来完成该功能。<br/>
针对这种情况，一种常规的方法是将多种算法写在一个类中。但是当多个算法集中在一个类中时，这个类就会变得臃肿，这个类的维护成本会变高，在维护时也更容易引发错误。如果我们需要增加一种新的排序算法，需要修改封装算法类的源代码。这就明显违反了我们所说的OCP原则和单一职责原则。<br/>
如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换，这种模式的可扩展性、可维护性也就更高，这就是策略模式。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">策略模式的定义</h2>

<p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p>

<h2 id="toc_2">策略模式的使用场景</h2>

<ul>
<li>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全地封装多种同一类型的操作时。</li>
<li>出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。</li>
</ul>

<h2 id="toc_3">策略模式的简单实现</h2>

<p>通常如果一个问题有多个解决方案时，最简单的方式就是利用if-else或者switch-case方式，但是耦合性太高、代码臃肿、难以维护。应用策略模式就能很好地解决这类问题，它将各种方案分离开来，让程序客户端根据具体的需求来动态地选择不同的策略方案。</p>

<p>示例中需要计算不同出行工具的成本，下面是我们第一个版本的代码</p>

<pre class="line-numbers"><code class="language-java">public class PriceCalculator {
    //公交车类型
    private static final int BUS = 1;
    //地铁类型
    private static final int SUBWAY = 2;
    
    public static void main(String[] args) {
        PriceCalculator calculator = new PriceCalculator();
        System.out.println(&quot;坐16公里的公交车票价为：&quot; + calculator.calculatePrice(16, BUS));
        System.out.println(&quot;坐16公里的地铁票价为：&quot; + calculator.calculatePrice(16, SUBWAY));
    }
}

/**
 * 北京公交车，十公里之内一元钱，超过十公里之后没加一元钱可以乘5公里
 * @param km 公里
 * @return
 */
 private int busPrice(int km) {
    //超过十公里的总距离
    int extraTotal = km - 10;
    //超过的距离是5公里的距离
    int extraFactor = extraTotal / 5;
    //超过的距离对5公里取余
    int fraction = extraTotal % 5;
    //价格计算
    int price = 1 + extraFactor * 1;
    return fraction &gt; 0 ? ++price : price;
 }
 
 /**
  * 6公里(含)内3元；6~12公里(含)4元；12~22公里(含)5元；22~32公里(含)6元
  * @param km 公里
  * @return
  */
  private int subwayPrice(int km) {
    if(km &lt;= 6) {
        return 3;
    } else if(km &gt; 6 &amp;&amp; km &lt;= 12) {
        return 4;
    } else if(km &gt; 12 &amp;&amp; km &lt;= 22) {
        return 5;
    } else if(km &gt; 22 &amp;&amp; km &lt;= 32) {
        return 6;
    }
    //其他距离我们简化为7元
    return 7;
  }
  
  int calculatePrice(int km, int type) {
    if (type == BUS) {
        return busPrice(km);
    } else if (type == SUBWAY) {
        return subwayPrice(km);
    }
    return 0;
  }
}
</code></pre>

<p>PriceCalculator类很明显的问题就是并不是单一职责，承担了公交车、地铁计费职责。当我们增加一种出行方式就需要在PriceCalculator中增加一个方法来计算出租车出行的价格，并且在calculatePrice函数中增加一个判断</p>

<pre class="line-numbers"><code class="language-java">public class PriceCalculator {
    //公交车类型
    private static final int BUS = 1;
    //地铁类型
    private static final int SUBWAY = 2;
    //出租车类型
    private static final int TAXI = 3;
    
    /**
     * 简单计算为每公里2元
     * @param km 公里
     * @return
     */
    private int taxiPrice(int km) {
        return km * 2;
    }
    
    int calculatePrice(int km, int type) {
        if (type == BUS) {
            return busPrice(km);
        } else if (type == SUBWAY) {
            return subwayPrice(km);
        } else if (type == TAXI) {
            return taxiPrice(km);
        }
        return 0;
    }
}
</code></pre>

<p>增加出行方式时，我们又需要在calculatePrice中添加if-else，此时很有可能就是复制上一个if-else，然后手动进行修改，手动复制代码也是很容易引入错误的做法之一，这样会使代码变得越来越臃肿，难以维护。</p>

<p>用策略模式进行重构</p>

<p>首先我们需要定义一个抽象的价格计算接口</p>

<pre class="line-numbers"><code class="language-java">/**
 * 计算接口
 */
public interface CalculateStrategy {
    /**
     * 按距离来计算价格
     * @param km 公里
     * @return 返回价格
     */
     int calculatePrice(int km);
}
</code></pre>

<p>对于每一种出行方式我们都有一个独立的计算策略类，这些策略类都实现了CalculateStrategy接口，例如下面是公交车和地铁的计算策略类:</p>

<pre class="line-numbers"><code class="language-java">//公交车价格计算策略
public class BusStrategy implements CalculateStrategy {
    /**
     * 北京公交车，十公里之内一元钱，超过十公里之后每加一元钱可以乘5公里
     * @param km 公里
     * @return
     */
     @Override
     public int calculatePrice(int km) {
        //超过十公里的总距离
        int extraTotal = km - 10;
        //超过的距离是5公里的距离
        int extraFactor = extraTotal / 5;
        //超过的距离对5公里取余
        int fraction = extraTotal % 5;
        //价格计算
        int price = 1 + extraFactor * 1;
        return fraction &gt; 0 ? ++price : price;
     }
}

//地铁价格计算策略
public class SubwayStrategy implements CalculateStrategy {
    /**
     * 6公里(含)内3元；6~12公里(含)4元；12~22公里(含)5元；22~32公里(含)6元
     * @param km 公里
     * @return
     */
    private int calculatePrice(int km) {
        if(km &lt;= 6) {
            return 3;
        } else if(km &gt; 6 &amp;&amp; km &lt;= 12) {
            return 4;
        } else if(km &gt; 12 &amp;&amp; km &lt;= 22) {
            return 5;
        } else if(km &gt; 22 &amp;&amp; km &lt;= 32) {
            return 6;
        }
        //其他距离我们简化为7元
        return 7;
    }
}
</code></pre>

<p>我们再创建一个TranficCalculator</p>

<pre class="line-numbers"><code class="language-java">//公交出行价格计算器
public class TranficCalculator {
    public static void main(String[] args) {
        TranficCalculator calculator = new TranficCalculator();
        //设置计算策略
        calculator.setStrategy(new BusStrategy());
        //计算价格
        System.out.println(&quot;公交车乘16公里的价格：&quot; + calculator.calculatePrice(16));
    }
    
    CalculateStrategy mStrategy;
    
    public void setStrategy(CalculateStrategy strategy) {
        this.mStrategy = strategy;
    }
    
    public int calculatePrice(int km) {
        return mStrategy.calculatePrice(km);
    }
}
</code></pre>

<p>通过策略模式添加出租车的计算策略，只需要添加一个出租车计算策略类，然后将该策略设置给TranficCalculator,最好直接通过TranficCalculator对象的计算方法。</p>

<pre class="line-numbers"><code class="language-java">//出租车计算策略
public class TaxiStrategy implements CalculateStrategy {
    //价格我们简单计算为公里数*2
    @Override
    public int calculatePrice(int km) {
        return km * 2;
    }
}
</code></pre>

<p>将策略注册到TranficCalculator中</p>

<pre class="line-numbers"><code class="language-java">//公交出行价格计算器
public class TranficCalculator {
    public static void main(String[] args) {
        TranficCalculator calculator = new TranficCalculator();
        //设置计算策略
        calculator.setStrategy(new TaxiStrategy());
        //计算价格
        System.out.println(&quot;出租车乘16公里的价格：&quot; + calculator.calculatePrice(16));
    }
    
    CalculateStrategy mStrategy;
    
    public void setStrategy(CalculateStrategy strategy) {
        this.mStrategy = strategy;
    }
    
    public int calculatePrice(int km) {
        return mStrategy.calculatePrice(km);
    }
}
</code></pre>

<p>上述示例清晰展示了二者的区别。前者通过if-else来解决问题，虽然实现较为简单，类型层级单一，但暴露的问题非常明显，即代码臃肿，逻辑复杂，难以升级和维护，没有结构可言；后者则是通过建立抽象，将不同的策略构建成一个具体的策略实现，通过不同的策略实现算法替换。在简化逻辑、结构的同时，增强了系统的可读性、稳定性、可扩展性，这对于较为复杂的业务逻辑显得更为直观，扩展也更为方便。</p>

<h2 id="toc_4">总结</h2>

<p>策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。这个模式很好地演示了开闭原则，也就是定义抽象，注入不同的实现，从而达到很好地可扩展性。</p>

<p><strong>优点</strong></p>

<ul>
<li>结构清晰明了、使用简单直观</li>
<li>耦合度相对而言较低，扩展方便</li>
<li>操作封装也更为彻底，数据更为安全</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>随着策略的增加，子类也会变得繁多</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[适配器模式]]></title>
    <link href="http://adolph.cc/15711233221322.html"/>
    <updated>2019-10-15T15:08:42+08:00</updated>
    <id>http://adolph.cc/15711233221322.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">适配器模式介绍</h2>

<p>适配器模式在我们的开发中使用率极高，从代码中随处可见的Adapter就可以判断出来。从最早的ListView、GridView到现在最新的RecyclerView都需要使用Adapter，并且在开发中我们遇到的优化问题、出错概率较大的地方也基本出自Adapter。</p>

<p>说到底，适配器是将两个不兼容的类融合在一起，它有点像粘合剂，将不同的东西通过一种转换使得它们能够协作起来。例如，经常碰到要在两个没有关系的类型之间进行交互，第一个解决方案就是修改各自类的接口，但是如果没有源代码或者我们不愿意为了一个应用而修改各自的接口，此时我们往往会使用一个Adapter，在这两种接口之间创建一个“混血儿”接口，这个Adapter会将这两个接口进行兼容，在不修改原有代码的情况下满足需求。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">适配器模式的定义</h2>

<p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>

<h2 id="toc_2">适配器模式的使用场景</h2>

<ol>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
<li>需要一个统一的输出接口，而输入端的类型不可预知。</li>
</ol>

<h2 id="toc_3">适配器模式应用的简单示例</h2>

<p>用电源接口做例子，笔记本电脑的电源一般都是用5V电压，但是我们生活中的电线电压一般都是220V。这个时候就出现了不匹配的状况，在软件开发中我们称之为接口不兼容，此时就需要适配器来进行一个接口转换。在软件开发中有一句话正好体现了这点：任何问题都可以加一个中间层来解决。这个层我们可以理解为这里的Adapter层，通过这层来进行一个接口转换就达到了兼容的目的。</p>

<p>在上述电源接口这个示例中，5V电压就是Target接口，220V电压就是Adapter类，而将电压从220V转换到5V就是Adapter。</p>

<h3 id="toc_4">类适配器模式</h3>

<pre class="line-numbers"><code class="language-java">//Target角色
public interface FiveVolt {
    public int getVolt5();
}

//Adapter角色，需要被转换的对象
public class Volt220 {
    public int getVolt220() {
        return 220;
    }
}

//Adapter角色，将220V的电压转换为5V的电压
public class VoltAdapter extends Volt220 implements FiveVolt {
    @Override
    public int getVolt5() {
        return 5;
    }
}
</code></pre>

<p>Target角色给出了需要的目标接口，而Adapter类则需要被转换的对象。Adapter则是将Volt220转换成Target的接口。对应的Target的目标是要获取5V的输出电压，而Adapter正常输出电压是220V，此时就需要电源适配器类将220V的电压转换为5V电压，解决接口不兼容的问题。</p>

<pre class="line-numbers"><code class="language-java">public class Test {
    public static void main(String[] args) {
        VoltAdapter adapter = new VoltAdapter();
        System.out.println(&quot;输出电压：&quot; + adapter.getVolt5());
    }
}
</code></pre>

<h3 id="toc_5">对象适配器模式</h3>

<p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adapter类，而使用代理关系连接到Adapter类。</p>

<pre class="line-numbers"><code class="language-java">/**
 * Target角色
 */
public interface FiveVolt {
    public int getVolt5();
}

/**
 * Adapter角色，需要被转换的对象
 */ 
public class Volt220 {
    public int getVolt220() {
        return 220;
    }
}

/**
 * 对象适配器模式
 */
public class VoltAdapter implements FiveVolt {
    Volt220 mVolt220;
    
    public VoltAdapter(Volt220 adapter) {
        mVolt220 = adapter;
    }
    
    public int getVolt220() {
        return mVolt220.getVolt220();
    }
    
    @Override
    public int getVolt5() {
        return 5;
    }
} 

public class Test {
    public static void main(String[] args) {
        VoltAdapter adapter = new VoltAdapter(new Volt220());
        System.out.println(&quot;输出电压：&quot; + adapter.getVolt5());
    }
}
</code></pre>

<p>这种实现方式直接将要被适配的对象传递到Adapter中，使用组合的形式实现接口兼容的效果。这比类适配器方式更为灵活，它的另一个好处是被适配对象中的方法不会暴露出来，而类适配器由于继承了被适配对象，因此，被适配对象类的函数在Adapter类中也都含有，这使得Adapter类出现一些奇怪的接口，用户使用成本较高。因此，对象适配器模式更加灵活、实用。<br/>
在实际开发中Adapter通常应用于进行不兼容的类型转换的场景，还有一种就是输入有无数种情况，但是输出类型是统一的，我们可以通过Adapter返回一个统一的输出，而具体的输入留给用户处理，内部只需知道输出的是符合要求的类型即可。在使用Adapter模式的过程中建议尽量使用对象适配器的实现方式，多用合成或者聚合，少用继承。</p>

<h2 id="toc_6">总结</h2>

<p>Adapter模式的经典实现在于将原本不兼容的接口融合在一起，使之能够很好地进行合作。但是，在实际开发中，Adapter模式也有一些灵活的实现。例如ListView中的隔离变化，使得整个UI架构变得更灵活，能够拥抱变化。Adapter模式在开发中运用非常广泛。因此，掌握Adapter模式是非常必要的。</p>

<p><strong>优点</strong></p>

<ul>
<li>更好的复用性: 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>更好的扩展性: 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>过多地使用适配器，会让系统非常凌乱，不易整体把握。例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果出现太多这种情况，无异于一场灾难。因此，如果不是很有必要，可以不适用适配器，而是直接对系统进行重构。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[外观模式(门面模式)]]></title>
    <link href="http://adolph.cc/15711208032276.html"/>
    <updated>2019-10-15T14:26:43+08:00</updated>
    <id>http://adolph.cc/15711208032276.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">外观模式介绍</h2>

<p>外观模式(Facade)在开发过程中的运用频率非常高，尤其是在现阶段各种第三方SDK充斥在我们的周边，而这些SDK很大概率会使用外观模式。通过一个外观类使得整个系统的接口只有一个统一的高层接口，这样能够降低用户的使用成本，也对用户屏蔽了很多实现细节。当然，在我们的开发过程中，外观模式也是我们封装API的常用手段，例如网络模块、ImageLoader模块等。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">外观模式定义</h2>

<p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p>

<h2 id="toc_2">外观模式的使用场景</h2>

<ol>
<li>为一个复杂子系统提供一个简单接口。子系统往往因为不断演化而变得越来越复杂，甚至可能被替换。大多数模式使用时都会产生更多、更小的类，在这使子系统更具可重用性的同时也更容易对子系统进行定制、修改，这种易变性使得隐藏子系统的具体实现变得尤为重要。Facade可以提供一个简单统一的接口，对外隐藏子系统的具体实现、隔离变化。</li>
<li>当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过Facade接口进行通信，从而简化它们之间的依赖关系。</li>
</ol>

<h2 id="toc_3">外观模式的简单示例</h2>

<p>生活中使用外观模式的例子非常多，任何一个类似中央调度结构的组织都类似外观模式。</p>

<p>简单模拟一下手机的外观模式实现，首先我们建立一个MobilePhone类</p>

<pre class="line-numbers"><code class="language-java">public class MobilePhone {
    private Phone mPhone = new PhoneImpl();
    private Camera mCamera = new SamsungCamera();
    
    public void dail() {
        mPhone.dail();
    }
    
    public void voideoChat() {
        System.out.println(&quot;--&gt; 视频聊天接通中&quot;);
        mCamera.open();
        mPhone.dail();
    }
    
    public void hangup() {
        mPhone.hangup();
    }
    
    public void takePicture() {
        mCamera.open();
        mCamera.takePicture();
    }
    
    public void closeCamera() {
        mCamera.close();
    }
}
</code></pre>

<p>MobilePhone类中含有两个子系统，也就是拨号系统和拍照系统，MobilePhone将这两个系统封装起来，为用户提供一个统一的操作接口，也就是说用户只需要通过MobilePhone这个类就可以操作打电话和拍照这两个功能。用户不需要知道有Phone这个接口以及它的实现类是PhoneImpl，同样不需要知道Camera相关的信息，通过MobilePhone就可以包揽一切。</p>

<p>看看Phone接口和PhoneImpl</p>

<pre class="line-numbers"><code class="language-java">public interface Phone {
    //打电话
    public void dail();
    //挂断
    public void hangup();
}

class PhoneImpl implements Phone {
    @Override
    public void dail() {
        System.out.println(&quot;打电话&quot;);
    }
    
    @Override
    public void hangup() {
        System.out.println(&quot;挂断&quot;);
    }
}
</code></pre>

<p>Camera也是类似的实现</p>

<pre class="line-numbers"><code class="language-java">public interface Camera {
    public void open();
    public void takePicture();
    public void close();
}

class SamsungCamera implements Camera {
    @Override
    public void open() {
        System.out.println(&quot;打开相机&quot;);
    }
    
    @Override
    public void takePicture() {
        System.out.println(&quot;拍照&quot;);
    }
    
    @Override
    public void close() {
        System.out.println(&quot;关闭相机&quot;);
    }
}
</code></pre>

<p>测试代码</p>

<pre class="line-numbers"><code class="language-java">public class Test {
    public static void main(String[] args) {
        MobilePhone nexus6 = new MobilePhone();
        //拍照
        nexus6.takePicture();
        //视频聊天
        nexus6.videoChat();
    }
}
</code></pre>

<p>从上述代码中可以看到，外观模式就是统一接口封装。将子系统的逻辑、交互隐藏起来，为用户提供一个高层次的接口，使得系统更加易用，同时也对外隐藏了具体的实现，这样即使具体的子系统发生了变化，用户也不会感知到，因为用户使用的是Facade高层接口，内部的变化对于用户来说并不可见。这样一来就将变化隔离开来，使得系统也更为灵活。</p>

<h2 id="toc_4">总结</h2>

<p>外观模式是一个高频率使用的设计模式，它的精髓就在于封装二字。通过一个高层次结构为用户提供统一的API入口，使得用户通过一个类型就基本能够操作整个系统，这样减少了用户的使用成本，也能够提升系统的灵活性。</p>

<p><strong>优点</strong></p>

<ul>
<li>对客户程序隐藏子系统细节，因而减少了客户对于系统的耦合，能够拥抱变化</li>
<li>外观类对子系统的接口封装，使得系统更易于使用</li>
</ul>

<p><strong>缺点</strong></p>

<ul>
<li>外观类接口膨胀。由于子系统的接口都由外观类统一对外暴露，使得外观类的API接口较多，在一定程度上增加了用户使用成本</li>
<li>外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰模式]]></title>
    <link href="http://adolph.cc/15711023020774.html"/>
    <updated>2019-10-15T09:18:22+08:00</updated>
    <id>http://adolph.cc/15711023020774.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">装饰模式简介</h2>

<p>装饰模式(Decorator Pattern)也称为包装模式(Wrapper Pattern)，结构性设计模式之一，其使用一种对客户端透明的方式来动态地扩展对象的功能，同时它也是继承关系的一种替代方案之一。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">装饰模式的定义</h2>

<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。</p>

<h2 id="toc_2">装饰模式的使用场景</h2>

<p>需要透明且动态地扩展类的功能时。</p>

<h2 id="toc_3">模式的简单实现</h2>

<p>人总是要穿衣服的，我们将人定义为一个抽象类，将其穿衣的行为定义为一个抽象方法。</p>

<pre class="line-numbers"><code class="language-java">public abstract class Person {
    /**
     *  Person 下有一个穿着的抽象方法
     */
     public abstract void dressed(); 
}
</code></pre>

<p>该类就是抽象组件类，也就是我们需要装饰的原始对象，接下里实现一个具体的实现类。</p>

<pre class="line-numbers"><code class="language-java">public class Boy extends Person {
    @Override
    public void dressed() {
        // Boy类下dressed方法的基本逻辑
        System.out.println(&quot;穿了内衣内裤&quot;);
    }
}
</code></pre>

<p>Boy类继承于Person类，该类仅对Person中的dressed方法作了具体的实现，而Boy类则是我们所要装饰的具体对象，现在需要一个装饰者来装饰我们的这个Boy对象，这里定义一个PersonCloth类来表示人所穿着的衣服。</p>

<pre class="line-numbers"><code class="language-java">public abstract class PersonCloth extends Person {
    protected Person mPerson; //保持一个Person类的引用
    
    public PersonCloth(Person mPerson) {
        this.mPerson = mPerson;
    }
    
    @Override
    public void dressed() {
        //调用Person类中的dressed方法
        mPerson.dressed();
    }
}
</code></pre>

<p>在PersonCloth类中我们保持了一个对Person类的引用，可以方便地调用具体被装饰对象中的方法，这也是为什么我们可以在不破坏原类层次结构的情况下为类增加一些功能，我们只需要在被装饰对象的相应方法前或后增加相应的功能逻辑即可。</p>

<p>使用一个类ExpensiveCloth表示高档衣服</p>

<pre class="line-numbers"><code class="language-java">public class ExpensiveCloth extends PersonCloth {
    public ExpensiveCloth(Person person) {
        super(person);
    }
    
    /**
     * 穿短袖
     */
     private void dressShirt() {
        System.out.println(&quot;穿件短袖&quot;);
     } 
     
     /**
     * 穿皮衣
     */
     private void dressLeather() {
        System.out.println(&quot;穿件皮衣&quot;);
     }
     
     /**
     * 穿牛仔裤
     */
     private void dressJean() {
        System.out.println(&quot;穿条牛仔裤&quot;);
     }
     
     @Override
     public void dressed() {
        super.dressed();
        dressShirt();
        dressLeather();
        dressJean();
     }
}
</code></pre>

<p>使用CheapCloth表示便宜的衣服</p>

<pre class="line-numbers"><code class="language-java">public class CheapCloth extends PersonCloth {
    public CheapCloth(Person person) {
        super(person);
    }
    
    /**
     * 穿短裤
     */
     private void dressShorts() {
        System.out.println(&quot;穿条短裤&quot;);
     } 
        
     @Override
     public void dressed() {
        super.dressed();
        dressShorts();
     }
}
</code></pre>

<p>这两个类本质上没有区别，都是为Boy类中的dressed方法提供功能扩展，不过这个扩展并非是直接修改原有的方法逻辑或结构，更恰当地说，仅仅是在另一个类中将原有的方法和新逻辑进行封装整合。</p>

<p>在客户端中调用</p>

<pre class="line-numbers"><code class="language-java">public class Main {
    public static void main(String[] args) {
        //首先我们要有一个Person男孩
        Person person = new Boy();
        
        //然后为他穿上便宜的衣服
        PersonCloth clothCheap = new CheapCloth(person);
        clothCheap.dressed();
        
        //或穿上比较上档次的衣服
        PersonCloth clothExpensive = new ExpensiveCloth(person);
        clothExpensive.dressed();
    }
}
</code></pre>

<h2 id="toc_4">总结</h2>

<p>装饰模式和代理模式有点类似，容易把装饰看作时代理。装饰模式是以对客户端透明的方法扩展对象的功能，是继承关系的一个替代方案；而代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用。装饰模式应该为所装饰的对象增强功能；代理模式对代理的对象施加控制，但不对对象本身的功能进行增强。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[享元模式]]></title>
    <link href="http://adolph.cc/15710570199030.html"/>
    <updated>2019-10-14T20:43:39+08:00</updated>
    <id>http://adolph.cc/15710570199030.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">享元模式介绍</h2>

<p>享元模式是对象池的一种实现，它的英文名称叫做Flyweight,代表轻量级的意思。享元模式用来尽可能减少内存使用，它适合用于存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，这样一来就可以提升性能，避免内存溢出等。</p>

<p>享元对象中的部分状态是可以共享，可以共享的状态称为内部状态，内部状态不会随着环境变化；不可共享的状态称为外部状态，它们会随着环境的改变而改变。在享元模式中会创建一个对象容器，在经典的享元模式中该容器为一个Map，它的键是享元对象的内部状态，它的值就是享元对象本身。客户端程序通过这个内部状态从享元工厂中获取享元对象，如果有缓存则使用缓存对象，否则创建一个享元对象并且存入容器中，这样一来就避免创建过多对象的问题。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">享元模式定义</h2>

<p>使用共享对象可有效地支持大量的细粒度的对象</p>

<h2 id="toc_2">享元模式的使用场景</h2>

<ol>
<li>系统中存在大量的相似对象</li>
<li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</li>
<li>需要缓冲池的场景</li>
</ol>

<h2 id="toc_3">享元模式的简单示例</h2>

<p>过年回家买火车票是一件很困难的事，无数人用刷票插件软件在向服务端发出请求，对于每一个请求服务器都必须做出应答。在用户设置好出发地和目的地之后，每次请求都返回一个查询的车票结果。当数以万计的人不间断在请求数据时，如果每次都重新创建一个查询的车票结果，那么必然会造成大量重复对象的创建、销毁，使得GC任务繁重、内存占用率居高不下。但是通过享元模式，我们将这些可以公用的对象缓存起来，在用户查询时优先使用缓存，如果没有缓存则重新创建。</p>

<p><strong>首先创建一个Ticket接口，该接口定义展示车票信息的函数</strong></p>

<pre class="line-numbers"><code class="language-java">public interface Ticket {
    public void showTicketInfo(String bunk);
}
</code></pre>

<p><strong>具体实现类TrainTicket</strong></p>

<pre class="line-numbers"><code class="language-java">class TrainTicket implements Ticket {
    public String from; //始发地
    public String to; //目的地
    public String bunk; //铺位
    public int price;
    
    TrainTicket(String from, String to) {
        this.from = from;
        this.to = to;
    }
    
    @Override
    public void showTicketInfo(String bunk) {
        price = new Random().nextInt(300);
        System.out.println(&quot;购买从&quot; + from + &quot;到&quot; + to + &quot;的&quot; + bunk + &quot;火车票,价格: &quot; + price);
    }
}
</code></pre>

<p><strong>返回车票数据的接口</strong></p>

<pre class="line-numbers"><code class="language-java">public class TicketFactory {
    public static Ticket getTicket(String from, String to) {
        return new TrainTicket(from, to);
    }
}
</code></pre>

<p>当遇到大量的请求时，这样的代码会造成大量的重复对象存在内存中，GC对这些对象的回收也会非常消耗资源。如果用户的请求量很大可能导致系统变得极其缓慢，设置可能导致OOM。</p>

<p>使用享元模式进行优化</p>

<pre class="line-numbers"><code class="language-java">//车票工厂，以出发地和目的地为key缓存车票
public class TicketFactory {
    static Map&lt;String, Ticket&gt; sTicketMap = new ConcurrentHashMap&lt;String, Ticket&gt;();
    
    public static Ticket getTicket(String from, String to) {
        String key = from + &quot;-&quot; + to;
        if (sTicketMap.containsKey(key)) {
            System.out.println(&quot;使用缓存 ==&gt;&quot; + key);
            return sTicketMap.get(key);
        } else {
            System.out.println(&quot;创建对象 ==&gt; &quot; + key);
            Ticket ticket = new TrainTicket(from, to);
            sTicketMap.put(key,ticket);
            return ticket;
        }
    }
}
</code></pre>

<p>这个map的键就是我们说的内部状态。如果没有缓存则创建一个对象，并且将这个对象缓存到map中，下次再有这类请求时直接从缓存中获取。</p>

<h2 id="toc_4">总结</h2>

<p>享元模式实现比较简单，但是它的作用在某些场景确实极其重要的。它可以大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能，但它同时也提高了系统的复杂性，需要分离出外部状态和内部状态，而且外部状态具有固话的特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱。</p>

<ul>
<li>享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li>
<li>享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iTerm2工具学习使用]]></title>
    <link href="http://adolph.cc/15704556102016.html"/>
    <updated>2019-10-07T21:40:10+08:00</updated>
    <id>http://adolph.cc/15704556102016.html</id>
    <content type="html"><![CDATA[
<p>之前也简单使用过iTerm2，但是没感觉到和Mac系统终端有太大的区别。所以现在决定好好了解，系统的学习下iTerm2来提供自身的开发效率。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">下载iTerm2</h2>

<p>官网下载: <a href="https://www.iterm2.com/">https://www.iterm2.com/</a><br/>
Mac系统默认使用bash作为终端(可以通过<code>echo $SHELL</code>命令进行查看)，可以使用命令修改默认使用zsh：</p>

<pre class="line-numbers"><code class="language-text">chsh -s /bin/zsh
</code></pre>

<h2 id="toc_1">替换背景图片</h2>

<pre class="line-numbers"><code class="language-text">打开路径iterm2 -&gt; Preferences -&gt; Profiles -&gt; window -&gt; Background Image
</code></pre>

<p>选择一张自己喜欢的壁纸即可</p>

<p>可以通过Blending调节壁纸的透明度: 透明度为0的时候,背景变为纯色(黑色)</p>

<h2 id="toc_2">安装Oh my zsh</h2>

<p>zsh的功能极其强大，只是配置过于复杂,通过Oh my zsh可以很快配置zsh。<br/>
安装方法有两种，可以使用curl或wget，看自己环境或喜好：</p>

<pre class="line-numbers"><code class="language-shell"># curl 安装方式
sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>

<pre class="line-numbers"><code class="language-shell"># wget 安装方式
sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;
</code></pre>

<p>oh-my-zsh开源地址：<a href="https://github.com/robbyrussell/oh-my-zsh">《oh-my-zsh》</a></p>

<h2 id="toc_3">安装PowerLine</h2>

<p>首先先安装pip命令</p>

<pre class="line-numbers"><code class="language-shell">sudo easy_install pip
</code></pre>

<p>安装powerline</p>

<pre class="line-numbers"><code class="language-shell">pip install powerline-status --user
</code></pre>

<h2 id="toc_4">安装PowerFonts</h2>

<p>在常用的位置新建一个文件夹，如：/Users/**/Development/OpenSource</p>

<p>在OpenSource文件夹下下载PorweFonts:</p>

<pre class="line-numbers"><code class="language-shell"># git clone
git clone https://github.com/powerline/fonts.git --depth=1

# cd to folder
cd fonts

# run install shell
./install.sh
</code></pre>

<p>安装好字体库之后，我们来设置iTerm2的字体，具体的操作是</p>

<pre class="line-numbers"><code class="language-text">iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text
</code></pre>

<p>在Font区域选中Change Font，然后找到Meslo LG字体。</p>

<p><figure><img src="media/15704556102016/15704572147711.jpg" alt=""/></figure></p>

<h2 id="toc_5">安装主题</h2>

<p>用<code>vim ~/.zshrc</code>打开隐藏文件，修改主题为<code>agnoster</code></p>

<h2 id="toc_6">设置配色方案</h2>

<p>通过oh-my-zsh设置完主题后，使用ITerm2自带的几个背景色显示看得不舒服，下载其他的颜色方案较美观。我选用的是solarized，效果还不错。点开官网，下载，解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors。之后在Color Presets中选中Solarized Dark配色。</p>

<h2 id="toc_7">自动提示命令</h2>

<p>当我们输入命令时，终端会自动提示你接下来可能要输入的命令，这时按 → 便可输出这些命令，非常方便。</p>

<ul>
<li>克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下</li>
</ul>

<pre class="line-numbers"><code class="language-text">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
</code></pre>

<ul>
<li>用 vim  ~/.zshrc 打开文件，下滑找到插件设置命令，默认是 plugins=(git) ，我们把它修改为</li>
</ul>

<pre class="line-numbers"><code class="language-text">plugins=(zsh-autosuggestions git)
</code></pre>

<ul>
<li>重新打开终端窗口。</li>
</ul>

<p>有时候因为自动填充的颜色和背景颜色很相似，以至于自动填充没有效果，我们可以手动更改下自动填充的颜色配置。Preferences -&gt; Profiles -&gt; Colors -&gt; ANSI Colors -&gt; Bright</p>

<h2 id="toc_8">语法高亮</h2>

<ol>
<li>使用homebrew安装zsh-syntax-highlighting 插件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">brew install zsh-syntax-highlighting
</code></pre>

<ol>
<li>vim ~/.zshrc配置文件，插入一行，保存退出。</li>
</ol>

<pre class="line-numbers"><code class="language-text">source  /usr/local/Cellar/zsh-syntax-highlighting/0.6.0/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
</code></pre>

<p>PS：上面的路径是brew安装插件成功后的路径，安装成功会有显示，复制记录一下。</p>

<ol>
<li>输入命令。
<code>
source ~/.zshrc
</code></li>
</ol>

<h2 id="toc_9">给ITerm中Vim配色</h2>

<p>Vim 的配色最好和终端的配色保持一致，不然在 Terminal/iTerm2 里使用命令行 Vim 会很别扭。</p>

<pre class="line-numbers"><code class="language-text">$ cd solarized

$ cd vim-colors-solarized/colors

$ mkdir -p ~/.vim/colors 

$ cp solarized.vim ~/.vim/colors/

$ vi ~/.vimrc

加入下面三行设置即可

syntax enable

set background=dark

colorscheme solarized
</code></pre>

<p>重启iTerm2</p>

<h2 id="toc_10">左右键跳转</h2>

<p>主要是按住<code>option + → or ←键</code>，在命令的开始和结尾跳转切换，原本是不生效的，需要手动开启下。</p>

<p>打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后<code>Profiles → Keys → Load Preset... → Natural Text Editing</code>，就可以了。</p>

<h2 id="toc_11">iTerm2 隐藏用户名和主机名</h2>

<p>有时候我们的用户名和主机名太长，比如我的adolph@adolphdeMacBook-Pro，终端显示的时候会很不好看，我们可以手动去除。</p>

<p>编辑<code>vim ~/.zshrc文件</code>，增加<code>DEFAULT_USER=&quot;adolph&quot;</code>配置。</p>

<p>我们可以通过whoami命令，查看当前用户。</p>

<h2 id="toc_12">iTerm2 快捷命令</h2>

<p>快捷命令说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">command + t</td>
<td style="text-align: left">新建标签</td>
</tr>
<tr>
<td style="text-align: left">command + w</td>
<td style="text-align: left">关闭标签</td>
</tr>
<tr>
<td style="text-align: left">command + 数字 command + 左右方向键</td>
<td style="text-align: left">切换标签</td>
</tr>
<tr>
<td style="text-align: left">command + enter</td>
<td style="text-align: left">切换全屏</td>
</tr>
<tr>
<td style="text-align: left">command + f</td>
<td style="text-align: left">查找</td>
</tr>
<tr>
<td style="text-align: left">command + d</td>
<td style="text-align: left">垂直分屏</td>
</tr>
<tr>
<td style="text-align: left">command + shift + d</td>
<td style="text-align: left">水平分屏</td>
</tr>
<tr>
<td style="text-align: left">command + option + 方向键 command + [ 或command + ]</td>
<td style="text-align: left">切换屏幕</td>
</tr>
<tr>
<td style="text-align: left">command + ;</td>
<td style="text-align: left">查看历史命令</td>
</tr>
<tr>
<td style="text-align: left">command + shift + h</td>
<td style="text-align: left">查看剪贴板历史</td>
</tr>
<tr>
<td style="text-align: left">ctrl + u</td>
<td style="text-align: left">清除当前行</td>
</tr>
<tr>
<td style="text-align: left">ctrl + l</td>
<td style="text-align: left">清屏</td>
</tr>
<tr>
<td style="text-align: left">ctrl + a</td>
<td style="text-align: left">到行首</td>
</tr>
<tr>
<td style="text-align: left">ctrl + e</td>
<td style="text-align: left">到行尾</td>
</tr>
<tr>
<td style="text-align: left">ctrl + f/b</td>
<td style="text-align: left">前进后退</td>
</tr>
<tr>
<td style="text-align: left">ctrl + p</td>
<td style="text-align: left">上一条命令</td>
</tr>
<tr>
<td style="text-align: left">ctrl + r</td>
<td style="text-align: left">搜索命令历史</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homebrew学习]]></title>
    <link href="http://adolph.cc/15704404393204.html"/>
    <updated>2019-10-07T17:27:19+08:00</updated>
    <id>http://adolph.cc/15704404393204.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">简介</h2>

<p>Homebrew是Mac OSX常见的包管理器(命令brew用于命令行工具, brew cask管理带UI软件), 类似 ubuntu下apt-get, centOS的yum. 推荐日常Mac下安装卸载软件使用.</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">安装Homebrew</h2>

<pre class="line-numbers"><code class="language-text">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<h2 id="toc_2">使用Homebrew</h2>

<ul>
<li>帮助信息: brew help(-h)</li>
<li>基本使用</li>
</ul>

<pre class="line-numbers"><code class="language-shell"># 更新所有软件
brew update
# 安装应用, 例如wget, 安装到/usr/local/Cellar/wget, ln到/usr/local/bin目录下
brew install wget
# 安装带UI app, 插件, 字体(fonts)及其他非开源应用
brew cask install firefox
# 更新具体软件
brew upgrade git
# 诊断依赖冲突等
brew doctor
# 搜索app
brew search xxx
# 卸载xxx.app
brew uninstall xxx
# 列出安装的包
brew list
</code></pre>

<ul>
<li>其他命令</li>
</ul>

<pre class="line-numbers"><code class="language-shell"># 打开包主页
brew home git
# 查看包信息
brew info git
# 查看包依赖
brew deps wget  #结果显示gettext libidn2  libunistring openssl
# 清理旧版本
brew cleanup git
brew cleanup
# 显示是否有新版本可用
brew outdated
</code></pre>

<h2 id="toc_3">卸载Homebrew</h2>

<pre class="line-numbers"><code class="language-shell">cd `brew –prefix`
rm -rf Cellar
brew cleanup
rm -rf Homebrew
rm -rf ~/Library/Caches/Homebrew
</code></pre>

<h2 id="toc_4">Homebrew Cask</h2>

<p>Homebrew Cask 是 Homebrew 的扩展，借助它可以方便地在 macOS 上安装图形界面程序，即我们常用的各类应用。</p>

<h3 id="toc_5">安装</h3>

<pre class="line-numbers"><code class="language-shell">brew tap phinze/homebrew-cask
brew install brew-cask
</code></pre>

<h4 id="toc_6">可视化Homebrew安装工具</h4>

<p><code>brew cask install cakebrew</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker学习]]></title>
    <link href="http://adolph.cc/15663678647312.html"/>
    <updated>2019-08-21T14:11:04+08:00</updated>
    <id>http://adolph.cc/15663678647312.html</id>
    <content type="html"><![CDATA[
<p>最近要搞微服务，学习了很多，发现网上对使用Docker进行部署推崇备至，而且之前也用过Docker来搭建Maven私有仓库和Redis，觉得学习下整理一篇博客还是蛮有必要的哈哈。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">应用场景</h2>

<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>

<h2 id="toc_1">CentOs安装Docker</h2>

<p>看了网上很多教程，发现没有说的那么麻烦，还是很传统的下载安装方式。</p>

<ul>
<li>先进行yum更新<code>yum update</code></li>
<li>使用yum命令进行安装<code>yum install -y docker</code>(备注：-y 表示不询问 使用默认配置进行安装，等待提示  完毕！)</li>
<li>查看是否安装成功<code>yum list installed | grep docker</code>(备注：命令为 查看yum安装完成文件列表 并 筛选docker安装信息)</li>
<li>启动docker服务<code>systemctl start docker</code></li>
<li>查看是否启动成功<code>systemctl status docker</code></li>
<li>使用docker命令 <code>docker images</code>(备注：查看docker已经安装的镜像 裸机状态下为空)</li>
</ul>

<h2 id="toc_2">Docker常用命令</h2>

<h3 id="toc_3">从docker仓库搜索镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker search [镜像名称]
</code></pre>

<h3 id="toc_4">拉取镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker image pull 镜像名称:版本号 # 不指定版本默认为最新版
</code></pre>

<h3 id="toc_5">删除镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker image rm 镜像名称/镜像ID
</code></pre>

<h3 id="toc_6">查看本地镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker images
</code></pre>

<h3 id="toc_7">重命名镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker tag [old_name] [new_name]
</code></pre>

<h3 id="toc_8">创建容器</h3>

<pre class="line-numbers"><code class="language-bash">docker run [option] 镜像名 [向启动容器中传入的命令]
</code></pre>

<p>[option]常用可选参数说明：</p>

<ul>
<li>-i 表示以“交互模式”运行容器,与容器交互</li>
<li>-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</li>
<li>–name 为创建的容器命名</li>
<li>-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</li>
<li>-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</li>
<li>-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</li>
<li>-e 为容器设置环境变量</li>
<li>–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同 </li>
<li>-rm 在容器退出时，自动删除其缓存</li>
</ul>

<pre class="line-numbers"><code class="language-bash">sudo docker run -it –name=ubuntu1 113a43faa138 /bin/bash

# -it 创建一个伪终端交互界面，name指定容器名称，否则随机一个名字 113a43faa138 镜像id /bin/bash 创建后执行的命令 
</code></pre>

<pre class="line-numbers"><code class="language-bash">sudo docker run -dit --name=ubuntu -v ~/Desktop/ceshi:/ceshi ubuntu
# -v &lt;本机目录:容器目录&gt;创建一个共享目录，左边是本机的目录，右边是容器中的目录，在本机修改内容对应的容器中的目录内容也会改变, 目录不存在会自动创建
</code></pre>

<h3 id="toc_9">查看所有容器</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker container ls #查看所有正在运行的容器
sudo docker container ls --all # 查看所有已创建的容器
</code></pre>

<ul>
<li>container id 容器id</li>
<li>image 镜像名称</li>
<li>command 创建后运行的命令</li>
<li>created 创建时间</li>
<li>status 关闭时间</li>
<li>ports 绑定的端口</li>
<li>names 容器名称</li>
</ul>

<h3 id="toc_10">运行已经开启的容器</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker container exec -it &lt;容器名/id&gt; &lt;运行后使用的第一个命令&gt;
# 运行使用的第一个命令一般默认为 /bin/bash 否则无法进入交互界面
</code></pre>

<h3 id="toc_11">停止与启动容器</h3>

<pre class="line-numbers"><code class="language-bash"># 停止一个已经在运行的容器
sudo docker container stop [容器名或容器id]

# 启动一个已经停止的容器
sudo docker container start [容器名或容器id]

# kill掉一个已经在运行的容器
sudo docker container kill [容器名]
</code></pre>

<h3 id="toc_12">删除容器</h3>

<pre class="line-numbers"><code class="language-bash">docker container rm [容器名或容器id]
</code></pre>

<h3 id="toc_13">容器保存为镜像</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker commit [容器名] [镜像]名
sudo docker commit ubuntu1 myubuntu  # 将容器名为ubuntu1的容器转换为叫myuntu的镜像，原本的容器并不会删除
</code></pre>

<h4 id="toc_14">镜像打包成文件</h4>

<pre class="line-numbers"><code class="language-bash">sudo docker save -o 保存的文件名 镜像名
sudo docker save -o ./ubuntu.tar ubuntu
</code></pre>

<h4 id="toc_15">将镜像加载到本地</h4>

<pre class="line-numbers"><code class="language-bash">sudo docker load -i  &lt;文件名&gt;
sudo docker load -i ./ubuntu.tar
</code></pre>

<h2 id="toc_16">Dockerfile</h2>

<p>Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。</p>

<h3 id="toc_17">Dockerfile的格式</h3>

<ol>
<li>#用来表示注释。</li>
<li>指令大小写不敏感，一般大写，参数小写。</li>
<li>Docker顺序执行Dockerfile中的指令来构建image。</li>
<li>第一个指令以&quot;From&quot;开始。</li>
<li>Dockerfile文件名首字母必须大写。</li>
</ol>

<h3 id="toc_18">工作目录</h3>

<p>Dockerfile在制作过程中，所有相关的文件都需要在一个文件夹中，这个文件夹叫做工作目录，Dockerfile所在的目录及其子目录。</p>

<pre class="line-numbers"><code class="language-text">mkdir /tmp/image1
cd /tmp/image1
</code></pre>

<h3 id="toc_19">Dockerfile指令</h3>

<h4 id="toc_20">FROM命令</h4>

<p>除了注释行外，Dockerfile的第一个命令。<br/>
基础镜像必要，代表你的项目将构建在这个基础上面</p>

<pre class="line-numbers"><code class="language-text">FROM &lt;repository&gt;[:&lt;tag&gt;]
FROM &lt;repository&gt;@&lt;digest&gt;
  repository:指定base image的名称
  tag: 指定base image的标签
  digest：image的hashcode
</code></pre>

<h4 id="toc_21">LABLE命令</h4>

<p>用于提供Dockerfile制作者的信息，这个命令可以出现在任何位置，一般建议在FROM指令之后。用key value的形式来描述一个image的metadata。</p>

<pre class="line-numbers"><code class="language-text">LABLE &lt;key&gt;=&lt;value&gt;
例如：
LABLE maintainer=&quot;leveldc&lt;leveldc@126.com&gt;&quot;
</code></pre>

<h4 id="toc_22">COPY命令</h4>

<p>用于从宿主机复制文件到镜像文件。</p>

<pre class="line-numbers"><code class="language-text">COPY &lt;src&gt;...&lt;dist&gt;
COPY [&quot;&lt;src&gt;&quot;,...&quot;&lt;dist&gt;&quot;]
  src:  复制文件的源文件或目录，支持通配符
  dist: 目标路径
说明：
1. &lt;src&gt;必须是build的上下文中的路径，不能是其父目录的文件。
2. 如果&lt;src&gt;是目录，其内部文件及子目录会被递归复制，&lt;src&gt;本身不会被复制。
3. 如果指定了多个&lt;src&gt;或在&lt;src&gt;中使用了通配符，则&lt;dist&gt;必须是一个目录，且以/结束。
4. 如果&lt;dist&gt;不存在，会被自动创建，包括其父目录。
例如：
COPY index.html /data/web/html
</code></pre>

<h4 id="toc_23">ADD命令</h4>

<p>类似COPY命令， 支持TAR文件或者TAR.gz和URL路径。<br/>
TAR:拷贝本地的tar文件会自动解压缩到docker镜像中。<br/>
URL:拷贝服务器地址上的文件并将文件添加到docker 镜像中。</p>

<pre class="line-numbers"><code class="language-text">ADD &lt;src&gt;...&lt;dist&gt;
ADD [&quot;&lt;src&gt;&quot;,...&quot;&lt;dist&gt;&quot;]
  src:  添加文件的源文件或目录，支持通配符
  dist: 目标路径
说明：
1. 如果&lt;src&gt;为URL且&lt;dist&gt;不以/结尾则&lt;src&gt;指定的文件将被直接下载并创建为&lt;dist&gt;;如果以/结尾，则文件被拷贝至&lt;dist&gt;/&lt;filename&gt;
2. 如果&lt;src&gt;是本地tar文件，则被展开为一个目录，如果是一个URL的tar文件，则不会自动展开。
3. 如果&lt;src&gt;有多个，则dist需要以/结尾，否则将会把src的内容直接写进&lt;dist&gt;。
例如：
ADD http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.37/bin/apache-tomcat-8.5.37.tar.gz /usr/local/src/
ADD apache-tomcat-8.5.37.tar.gz /usr/local/src/
</code></pre>

<h4 id="toc_24">WORKDIR命令</h4>

<p>指定Docker镜像中的工作路径，可以定义多次，命令执行的时候以最新定义的一次为准。<br/>
例如:<code>WORKDIR /usr/local/</code></p>

<h4 id="toc_25">VOLUME命令</h4>

<p>Dockerfile中的卷只能设置容器中的挂载点目录，只能设置docker管理的卷。<br/>
例如:<code>VOLUME /data/mysql</code></p>

<h4 id="toc_26">EXPOSE命令</h4>

<p>为容器打开指定要监听的端口来和外部通信。</p>

<pre class="line-numbers"><code class="language-text">EXPOSE &lt;port&gt;[/&lt;protocol&gt;][&lt;port&gt;[&lt;/protocol&gt;]]
protocol:传输协议，tcp/udp, 默认tcp.
可以一次指定多个端口,例如:
`EXPOSE 32332/udp 32332/tcp`

这里的端口并不会直接暴露给宿主机，而是以启动docker容器时候的参数来决定。
docker run -p/-P
</code></pre>

<h4 id="toc_27">ENV命令</h4>

<p>定义Dockerfile的环境变量，可以被在Dockfile ENV命令后面的其他命令引用。</p>

<pre class="line-numbers"><code class="language-text"> ENV &lt;key&gt; &lt;value&gt;
  ENV &lt;key&gt;=&lt;value&gt; ...
  说明:
  1.第一种格式key后面的所有内容都被认为是value，只可以定义一个
  2.第二种格式可以定义多个&lt;key&gt;=&lt;value&gt;, 如果value中有空格，需要加&quot;\&quot;进行转义，也可以对value加双引号。另外反斜杠可以用来表示续行。
  建议使用第二种。
  3.Dockerfile中定义的ENV可以在启动容器以后直接使用，在运行为容器的时候通过-e参数可以重新给变量赋值。要分清什么参数是在build阶段的，什么是在容器启动阶段。
</code></pre>

<h4 id="toc_28">RUN命令</h4>

<p>RUN命令时基于基础镜像所提供的命令来运行，发生在创建镜像的过程中。目的是为了创建镜像。<br/>
RUN 命令如果执行了yum，需要在安装完成后删除缓存以减小镜像大小。</p>

<pre class="line-numbers"><code class="language-text">RUN &lt;command&gt;
RUN [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]

说明:
第一种默认启动为/bin/sh 子进程。
第二种执行方式是由linux直接来执行，没有/bin/sh,所以不支持shell的语法，如果需要可以使用:
RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;]来执行。
例如:
RUN cd /usr/local/src/ &amp;&amp; \
    tar -xf  ${WEB_SERVER_VERSION}
</code></pre>

<h4 id="toc_29">CMD命令</h4>

<p>CMD命令发生在容器启动时,当一个镜像文件被创建为容器的时候执行,一个容器默认只启动一个进程，所以一个Dockerfile中只可以有一个CMD,如果有多个，则最后一个生效用来指定容器启动时默认执行的程。</p>

<pre class="line-numbers"><code class="language-text">CMD &lt;command&gt;
CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
说明:
在执行docker run命令的时候，可以指定新的命来来覆盖CMD的内容。如果docker在启动的时候不希望接受命令行输入的命令，可以使用ENTRYPOINT.
</code></pre>

<h4 id="toc_30">ENTRYPOINT命令</h4>

<p>和CMD功能类似，但是不接受在docker run的时候修改启动命令，docker run的参数只能以变量的形式传给ENTRYPOINT定义的启动程序。</p>

<p>如果需要改变，需要在docker run的时候指定 --entrypoints参数。</p>

<p>ENTRYPOINT用来支持多环境</p>

<h4 id="toc_31">USER命令</h4>

<p>用于指定运行image或运行Dockerfile中的RUN CMD ENTRYPOINT指令指定的程序时的用户名或者UID。</p>

<pre class="line-numbers"><code class="language-text">USER &lt;UID&gt;|&lt;UserName&gt;
CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
</code></pre>

<h4 id="toc_32">HEALTHCHECK命令</h4>

<p>容器健康检测</p>

<pre class="line-numbers"><code class="language-text">HEALTHCHECK [OPTIONS] CMD command
OPTIONS：
  --interval=DURATION(间隔多久检测)
  --timeout=DURATION(检测超时)
  --start-period=DURATION(等待多久开始检测，default=0)
  --retries=N(default=3)
  returns:
  0:success
  1:unhealthy
  2:reserved
  例如:
  HEALTHCHECK --interval=5m --timeout=30s CMD curl -f http://localhost/ || exit 1
</code></pre>

<h4 id="toc_33">SHELL命令</h4>

<p>镜像默认的shell</p>

<pre class="line-numbers"><code class="language-text">SHELL [&quot;executable&quot;,&quot;parameters&quot;]
</code></pre>

<h4 id="toc_34">STOPSIGNAL命令</h4>

<p>进程为1的命令可以接受docker stop命令,主进程停止，容器就停止。</p>

<h4 id="toc_35">ARG命令</h4>

<p>在build的过程中起作用，使一个dockerfile可以适用多个环境，用法和ENV类似，但是起作用的时间不一样。该变量可以通过 build --arg参数修改。</p>

<h4 id="toc_36">ONBUILD命令</h4>

<p>在Dockerfile中定义一个并发器，当别的镜像是基于有ONBUILD的镜像构建新的镜像的时候，会触发ONBOUILD指令</p>

<pre class="line-numbers"><code class="language-text">ONBUILD&lt;INSTRUCTION&gt;
</code></pre>

<h4 id="toc_37">docker buld</h4>

<p>创建docker镜像</p>

<pre class="line-numbers"><code class="language-text">docker build [OPTIONS] PATH | URL | -
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker搭建Maven私服]]></title>
    <link href="http://adolph.cc/15662693410122.html"/>
    <updated>2019-08-20T10:49:01+08:00</updated>
    <id>http://adolph.cc/15662693410122.html</id>
    <content type="html"><![CDATA[
<p>由于Gradle和Maven依赖方式不一样，没法进行本地项目依赖，所以需要把Gradle项目打包发布到Maven仓库。发布到公共仓库又不太好，所以决定搭建个私有仓库，刚好家里有群辉Synology DS918+，可以通过Docker来搭建Maven私服。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">安装Nexus</h2>

<p>群辉上的Docker通过图形化的界面进行操控，所以不需要进行命令行操作。</p>

<ul>
<li><p>在注册表中搜索Nexus，对sonatype/nexus3项目进行双击下载映像。<br/>
<figure><img src="media/15662693410122/66FBF341-A2A8-43AC-8920-82E09879443C.png" alt=""/></figure></p></li>
<li><p>在映像中双击sonatype/nexus3创建容器，编辑nexus设置，启用自动重新启动和创建桌面快捷方式<figure><img src="media/15662693410122/07013229-CA0A-45AB-9035-DF3A95145BE2.png" alt=""/></figure></p></li>
<li><p>在卷中添加映射文件夹 本地文件路径 / 装载路径(/var/nexus-data)<br/>
<figure><img src="media/15662693410122/3E47DC7A-E1E8-4E8B-8325-5E482631797E.png" alt=""/></figure></p></li>
<li><p>进行端口映射,将本地端口映射到容器端口.<figure><img src="media/15662693410122/96660F1B-0E55-4DEB-AF78-BC29526F79E8.png" alt=""/></figure></p></li>
<li><p>启动Nexus，点击桌面的Nexus快捷启动或者通过<code>http://ip:8081</code>，打开Nexus网址。<br/>
<figure><img src="media/15662693410122/15662707547156.png" alt=""/></figure></p></li>
<li><p>点击右上方的Sign in进行登录，初始账号为admin，初始密码通过容器的详情里终端查看admin.password里的密码.登录后修改密码<br/>
<figure><img src="media/15662693410122/15662707441848.jpg" alt=""/></figure></p></li>
<li><p>可以看到默认情况下<code>Nexus</code>会帮我们创建了几个仓库，仔细观察红色框住的地方，里面有几种仓库的类型，解释如下：</p>
<ul>
<li><code>proxy</code>远程仓库的代理，比如说<code>nexus</code>配置了一个<code>central repository</code>的<code>proxy</code>,当用户向这个proxy请求一个<code>artifact</code>的时候，会现在本地查找，如果找不到，则会从远程仓库下载，然后返回给用户。</li>
<li><code>hosted</code>宿主仓库，用户可以把自己的一些仓库<code>deploy</code>到这个仓库中</li>
<li><code>group</code>仓库组，是<code>nexus</code>特有的概念，目的是将多个仓库整合，对用户暴露统一的地址，这样就不需要配置多个仓库地址。</li>
</ul></li>
<li><p>下面我们仔细看一下里面的一些仓库。点击<code>maven-central</code>仓库: <br/>
<figure><img src="media/15662693410122/15662710138140.jpg" alt=""/></figure><br/>
可以看到是一个<code>proxy</code>类型的仓库，他代理的远程仓库地址是<code>https://repo1.maven.org/maven2/</code>。</p></li>
<li><p>后退，在进入<code>maven-public</code>查看: <br/>
<figure><img src="media/15662693410122/15662710448726.png" alt=""/></figure><br/>
可以看到这是一个<code>group</code>类型的仓库，里面包含了<code>maven-releases/maven-snapshots/maven-central</code>仓库，意思是我们只需要在本地添加这个仓库，则可以依赖到上述3个仓库中的库了。</p></li>
</ul>

<h2 id="toc_1">创建仓库</h2>

<ul>
<li><p><strong>创建仓库</strong><br/>
点击<code>Create repository</code>,然后选择<code>maven2(hosted)</code>然后输入仓库名称<code>（test-release）</code>。在<code>version policy</code>中选择这个仓库的类型，这里选择<code>release</code>,在<code>Deployment policy</code>中选择<code>Allow redeploy</code><br/>
<figure><img src="media/15662693410122/15662711396304.png" alt=""/></figure></p></li>
<li><p><strong>创建用户</strong><br/>
点击左侧菜单栏的Users菜单，然后点击Create local user.我这里创建了一个用户，账号密码都是：wangjianfeng <br/>
<figure><img src="media/15662693410122/15662712072619.jpg" alt=""/></figure></p></li>
</ul>

<h2 id="toc_2">Java Gradle项目上传</h2>

<p>在build.gradle中添加<code>maven-publish</code>插件</p>

<pre class="line-numbers"><code class="language-groovy">plugins {
    id &quot;maven-publish&quot;
}
</code></pre>

<p>设置插件参数</p>

<pre class="line-numbers"><code class="language-groovy">//打包源码
task sourceJar(type: Jar) {
    from sourceSets.main.allSource
}

publishing {
    publications {
        maven(MavenPublication) {
            //指定group/artifact/version信息，可以不填。默认使用项目group/name/version作为groupId/artifactId/version
            groupId project.group
            artifactId project.name
            version project.version
            //如果是war包填写components.web，如果是jar包填写components.java
            from components.java

            //配置上传源码
            artifact sourceJar {
                classifier &quot;sources&quot;
            }

        }
    }
    repositories {
        maven {
            //指定要上传的maven私服仓库
            url = &quot;http://你的maven私服地址/repository/maxrocky/&quot;
            //认证用户和密码
            credentials {
                username &#39;admin&#39;
                password &#39;admin123&#39;
            }
        }
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin为序列化类生成serialVersionUID]]></title>
    <link href="http://adolph.cc/15639522586909.html"/>
    <updated>2019-07-24T15:10:58+08:00</updated>
    <id>http://adolph.cc/15639522586909.html</id>
    <content type="html"><![CDATA[
<p>一般在Intellij Idea使用过程中，为Java序列化类自动生成serialVersionUID可以通过Inspections配置来完成</p>

<span id="more"></span><!-- more -->

<p><figure><img src="media/15639522586909/15639527631359.jpg" alt=""/></figure></p>

<pre class="line-numbers"><code class="language-text">Preferences -&gt; Inspections -&gt; Serialization issues -&gt; Serialization class without &#39;serialVersionUID&#39;
</code></pre>

<p>将光标放到类名上，按<code>atl＋enter</code>键，就会提示生成serialVersionUID了</p>

<p><figure><img src="media/15639522586909/15639527944558.jpg" alt=""/></figure></p>

<p>或者使用插件<strong>GenerateSerialVersionUID</strong>就能通过快捷键快速生成serialVersionUID</p>

<p>然而在Kotlin环境下，以上配置无效</p>

<p><strong>解决方案如下：</strong><br/>
利用serialver命令生成serialVersionUID</p>

<ul>
<li>Preferences -&gt; Tools -&gt; External Tools</li>
<li>添加新的tools</li>
<li>Name就设置为serialver</li>
<li>Program中选择serialver命令所在的路径，macOS下一般为<code>/usr/bin/serialver</code></li>
<li>Arguments设置为 <code>-classpath$OutputPath$:$Classpath$ $FileFQPackage$.$FileNameWithoutAllExtensions$</code></li>
<li>点击保存以上配置</li>
</ul>

<p>Ok,现在就可以生成serialVersionUID了。首先编译一下，让要生成serialVersionUID的类生成对应的class文件，然后在类的编辑窗口中右键选择external tools &gt; serialver，这时console窗口出就生成了这个类的serialVersionUID了。</p>

<blockquote>
<p>另：kotlin中没有Java的static关键字，所以serialVersionUID属性是以伴生对象属性存在的</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactNative打包与发布]]></title>
    <link href="http://adolph.cc/15615956474579.html"/>
    <updated>2019-06-27T08:34:07+08:00</updated>
    <id>http://adolph.cc/15615956474579.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">iOS</h2>

<h3 id="toc_1">生成bundle文件</h3>

<pre class="line-numbers"><code class="language-text">react-native bundle --entry-file index.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/
</code></pre>

]]></content>
  </entry>
  
</feed>
