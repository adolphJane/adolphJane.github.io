<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MagicalRice的Blog]]></title>
  <link href="http://adolph.cc/atom.xml" rel="self"/>
  <link href="http://adolph.cc/"/>
  <updated>2021-02-25T10:44:39+08:00</updated>
  <id>http://adolph.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[继承]]></title>
    <link href="http://adolph.cc/16136612078589.html"/>
    <updated>2021-02-18T23:13:27+08:00</updated>
    <id>http://adolph.cc/16136612078589.html</id>
    <content type="html"><![CDATA[
<p>继承是面向对象的三个基本特征之一。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">继承的意义</h2>

<p>继承在汉语词典中的意思有两个</p>

<ol>
<li>按照法律或遵照遗嘱接受死者的财产、职务、头衔、地位等</li>
<li>继续做前人未完成的事业</li>
</ol>

<p>在我看来，面向对象中继承这一基本特征同样具备以上两种意思。子类继承父类的特征和行为，使得子类对象具有父类的属性和方法；子类可以覆盖父类的属性，重载父类的方法，开拓属于自身的属性和方法，拓展更多的功能。</p>

<p>第二点更多属于多态的概念，但我觉得继承和多态这两个概念是密不可分的。三大基本特征，我认为继承在其中有着承上启下的作用。父类进行了封装，继承给子类，子类通过多态实现再次进行封装。</p>

<h2 id="toc_1">继承的具体表现</h2>

<p>在Java代码中，继承主要体现在类与类，接口与接口之间。当然，一个类只能继承另一个类，但可以实现多个接口。同时，有final修饰符的类、方法或者属性，表示不能被改变或重写。</p>

<p>简单打个比方，现在有一处楼盘出售，依山傍水，坐拥豪华地段，享五星级物业服务。我买到了其中一套房，那我的房子便拥有了这处楼盘所有的优势，毛坯房也是楼盘所提供的户型所建。为了打造自己的家，我会通过打墙，装修墙面等各种方式来美化。同时也会按照楼盘提供的硬装规划来设计实现电线以及水管的排布位置。但同时，装修的过程中也不是所有都能随意修改的，像涉及到承重墙的位置，面积属性都是在刚开始就已经固定了，无法对其进行修改。</p>

<h2 id="toc_2">继承在Java中的实现</h2>

<p>Java中除了可以对一个普通父类进行继承，还定义了abstract(抽象类)和interface(接口)。</p>

<h3 id="toc_3">抽象类</h3>

<p>在面向对象的概念中，我们知道所有的对象都是通过类来描绘的，但是反过来却不是这样。并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。</p>

<p>在面向对象领域，抽象类主要用来进行类型隐藏。我们可以构造出一个固定的一组行为的抽象描述，但是这组行为却能够有任意个可能的具体实现方式。为了能够实现面向对象设计的一个最核心的原则OCP(Open-Closed Principle)，抽象类是其中的关键所在。</p>

<h3 id="toc_4">接口</h3>

<p>接口本质上是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现。abstarct class在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在&quot;is a&quot;关系，即父类和派生类在概念本质上应该是相同的。对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。</p>

<h3 id="toc_5">示例</h3>

<p>假设在我们的问题领域中有一个关于Door的抽象概念，该Door具有执行两个动作open和close。</p>

<p><strong>使用abstract class方式定义Door</strong></p>

<pre><code class="language-java">abstract class Door {  
 abstract void open();  
 abstract void close()；  
}
</code></pre>

<p><strong>使用interface方式定义Door</strong></p>

<pre><code class="language-java">interface Door {  
 void open();  
 void close();  
}
</code></pre>

<p>这样两种方式看起来没什么太大的区别,但如果要求Door还需要有报警功能，那我们该如何定义继承关系。</p>

<pre><code class="language-java">abstract class Door {  
 abstract void open();  
 abstract void close()；  
 abstract void alarm();  
}  
</code></pre>

<p>或者</p>

<pre><code class="language-java">interface Door {  
 void open();  
 void close();  
 void alarm();  
}  
</code></pre>

<p>那么具有报警功能的AlarmDoor的定义方式如下：  </p>

<pre><code class="language-java">class AlarmDoor extends Door {  
 void open() { … }  
 void close() { … }  
 void alarm() { … }  
}  
</code></pre>

<p>或者  </p>

<pre><code class="language-java">class AlarmDoor implements Door ｛  
 void open() { … }  
 void close() { … }  
 void alarm() { … }  
｝  
</code></pre>

<p>这种方法违反了面向对象设计中的一个核心原则ISP（Interface Segregation Priciple），在Door的定义中把Door概念本身固有的行为方法和另外一个概念&quot;报警器&quot;的行为方法混在了一起。</p>

<p>所以需要分析所处理问题的本质，以及关联属性。AlarmDoor在概念本质上是Door，同时它有具有报警的功能。所以对于Door这个概念，我们应该使用abstarct class方式来定义。另外，AlarmDoor又具有报警功能，说明它又能够完成报警概念中定义的行为，所以报警概念可以通过interface方式定义。</p>

<pre><code class="language-java">abstract class Door {  
 abstract void open();  
 abstract void close()；  
}  
interface Alarm {  
 void alarm();  
}  
class AlarmDoor extends Door implements Alarm {  
 void open() { … }  
 void close() { … }  
 void alarm() { … }  
}  
</code></pre>

<p>这种实现方式基本上能够明确的反映出我们对于问题领域的理解，正确的揭示我们的设计意图。其实abstract class表示的是&quot;is a&quot;关系，interface表示的是&quot;like a&quot;关系。</p>

<p><a href="http://www.blogjava.net/chunkyo/archive/2007/01/21/95093.html">Java抽象类和接口的区别</a></p>

<h2 id="toc_6">继承的作用(有什么用)</h2>

<p>对于代码来说:</p>

<ul>
<li>提高了代码的复用性</li>
<li>子类能自动继承父类的接口与属性方法。</li>
</ul>

<p>对于面向对象而言:</p>

<ul>
<li>继承的出现让类与类之间产生了关系</li>
<li>加强了耦合度</li>
<li>同时为多态提供了前提。</li>
<li>让代码更加易于理解</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[封装]]></title>
    <link href="http://adolph.cc/16127020620600.html"/>
    <updated>2021-02-07T20:47:42+08:00</updated>
    <id>http://adolph.cc/16127020620600.html</id>
    <content type="html"><![CDATA[
<p>封装是面向对象的三个基本特征之一。</p>

<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>

<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>

<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>

<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>

<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">封装的优点</h2>

<ol>
<li><p>良好的封装能够减少耦合</p></li>
<li><p>便于修改，提高代码的可维护性</p></li>
<li><p>可以对成员变量进行更精确的控制</p></li>
<li><p>可以隐藏实现的细节</p></li>
<li><p>方便数据检查，有利于于保护对象信息的完整性</p></li>
<li><p>让使用者只能通过实现写好的访问方法来访问这些字段，这样一来我们只需要在这些方法中增加逻辑控制，限制对数据的不合理访问</p></li>
</ol>

<h2 id="toc_1">封装原则</h2>

<ol>
<li><p>将不需要对外提供的内容都隐藏起来, 修改属性的可见性来限制对属性的访问（一般限制为private）</p></li>
<li><p>对每个值属性提供对外的公共方法访问，也就是创建一对赋值取值方法，用于对私有属性的访问</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GitHub搜索技巧]]></title>
    <link href="http://adolph.cc/16106747969027.html"/>
    <updated>2021-01-15T09:39:56+08:00</updated>
    <id>http://adolph.cc/16106747969027.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">搜索名字</h2>

<blockquote>
<p><strong>in : name ××××</strong></p>
</blockquote>

<p><img src="media/16106747969027/16106748188582.jpg" alt=""/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">搜索项目描述</h2>

<blockquote>
<p><strong>in : description ××××</strong></p>
</blockquote>

<p><img src="media/16106747969027/16106749305238.jpg" alt=""/></p>

<h2 id="toc_2">搜索readme</h2>

<blockquote>
<p><strong>in: readme ××××</strong></p>
</blockquote>

<p><img src="media/16106747969027/16106749707361.jpg" alt=""/></p>

<h2 id="toc_3">利用star,fork搜索</h2>

<blockquote>
<p><strong>stars : &gt;300 ×××× 和 fork : &gt;300 ××××</strong></p>
</blockquote>

<p><img src="media/16106747969027/16106750364902.jpg" alt=""/></p>

<h2 id="toc_4">利用仓库大小搜索</h2>

<blockquote>
<p><strong>size : &gt;= 3000 ××××</strong></p>
</blockquote>

<p>备注：数字的单位是k,3000表示3M</p>

<p><img src="media/16106747969027/16106750923372.jpg" alt=""/></p>

<h2 id="toc_5">判断仓库是否还在更新维护</h2>

<blockquote>
<p><strong>pushed : &gt; 2019-01-19 ××××</strong></p>
</blockquote>

<p><img src="media/16106747969027/16106751416211.jpg" alt=""/></p>

<h2 id="toc_6">利用语言\地区搜索</h2>

<blockquote>
<p><strong>language : [语言] location: [地区] ××××</strong></p>
</blockquote>

<p><img src="media/16106747969027/16106752929090.jpg" alt=""/></p>

<h2 id="toc_7">关注者</h2>

<blockquote>
<p><strong>followers : &gt;= 1000 ××××</strong> (匹配拥有超过1000名关注者的开发者)</p>
</blockquote>

<h2 id="toc_8">利用全名查找</h2>

<blockquote>
<p><strong>[名字] in : fullname</strong> (匹配用户全名的开发者)</p>
</blockquote>

<h2 id="toc_9">按文件名搜索</h2>

<blockquote>
<p><strong>filename : [name]</strong> (搜索包含该文件的所有仓库)</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intellij IDEA插件开发入门]]></title>
    <link href="http://adolph.cc/16104540799826.html"/>
    <updated>2021-01-12T20:21:19+08:00</updated>
    <id>http://adolph.cc/16104540799826.html</id>
    <content type="html"><![CDATA[
<p>提升代码开发效率，让自己的编程环境更加强大易用。</p>

<h2 id="toc_0">开发环境</h2>

<p>开发IDEA插件有以下这些依赖：</p>

<ul>
<li>IntelliJ IDEA Community Edition</li>
<li>IntelliJ IDEA Community Edition 源码</li>
<li>Plugin DevKit 插件</li>
<li>IntelliJ Platform SDK</li>
</ul>

<span id="more"></span><!-- more -->

<h3 id="toc_1">安装IntelliJ IDEA Community Edition</h3>

<p>你可能已经安装了Ultimate版本，但是你还是需要安装IDEA的社区版本。因为商业版是闭源的，所以在调试时无法调试核心代码。</p>

<h3 id="toc_2">下载IntelliJ IDEA Community Edition源码</h3>

<p>社区版的安装包里是不包含源码的，所以我们需要手动从github上clone一份：</p>

<pre><code class="language-text">git clone --depth 1 git://git.jetbrains.org/idea/community.git idea
</code></pre>

<h2 id="toc_3">新建项目</h2>

<h3 id="toc_4">配置项目类型</h3>

<p><img src="media/16104540799826/16104548250513.jpg" alt=""/></p>

<ul>
<li>在左侧的项目类型窗格中，选择<code>Gradle</code>。</li>
<li>指定基于Java 8 JDK的Project SDK。该SDK将是用于运行Gradle的默认JRE，并且是用于编译插件Java源代码的JDK版本。</li>
<li>在 Additional Libraries and Frameworks 面板中，选择Java和IntelliJ Platform Plugin。</li>
<li>配置Kotlin
<ul>
<li>要在插件中包含对Kotlin语言的支持，请选中Kotlin / JVM框。</li>
<li>要将build.gradle文件创建为Kotlin构建脚本（build.gradle.kts）而不是Groovy，请选中Kotlin DSL构建脚本框。</li>
<li>点击下一步</li>
</ul></li>
</ul>

<h3 id="toc_5">项目命名/配置ArtifactId和版本</h3>

<ul>
<li><code>GroupId</code>通常是Java包名称，它用于项目<code>build.gradle</code>文件中的<code>project.group</code>属性值。</li>
<li><code>ArtifactId</code>是项目JAR文件的默认名称（无版本）。它也用于项目settings.gradle文件中的<code>rootProject.name</code>属性值。</li>
<li>版本用于build.gradle文件中的<code>project.version</code>值。</li>
</ul>

<p>在“位置”中指定新项目的路径，然后单击“完成”以继续并生成项目。</p>

<h3 id="toc_6">项目结构</h3>

<pre><code class="language-text">my_gradle_plugin
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── settings.gradle
└── src
    ├── main
    │   ├── java
    │   └── resources
    │       └── META-INF
    │           └── plugin.xml
    └── test
        ├── java
        └── resources
</code></pre>

<ul>
<li>Gradle Wrapper文件，<code>gradle-wrapper.properties</code>文件指定用于构建插件的Gradle版本。如果需要，IntelliJ IDEA Gradle插件将下载此文件中指定的Gradle版本。</li>
<li>settings.gradle文件，包含的定义rootProject.name。</li>
<li>在META-INF默认目录下main来源集包含插件配置文件。</li>
</ul>

<h4 id="toc_7">build.gradle</h4>

<pre><code class="language-gradle">plugins {
    id &#39;java&#39;
    id &#39;org.jetbrains.intellij&#39; version &#39;0.6.5&#39;
}

group &#39;com.your.company&#39;
version &#39;1.0&#39;
sourceCompatibility = 1.8

repositories {
    mavenCentral()
}
dependencies {
    testImplementation group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.12&#39;
}

// See https://github.com/JetBrains/gradle-intellij-plugin/
intellij {
    version &#39;2020.1&#39;
}
patchPluginXml {
    changeNotes &quot;&quot;&quot;
      Add change notes here.&lt;br&gt;
      &lt;em&gt;most HTML tags may be used&lt;/em&gt;&quot;&quot;&quot;
}
</code></pre>

<ul>
<li>显式声明了Gradle的两个插件：
<ul>
<li>Java Gradle插件。</li>
<li>gradle-intellij-plugin 插件。</li>
</ul></li>
<li>GroupId就是之前项目创建向导中的project.group值</li>
<li>Version就是之前项目创建向导中的project.version值。</li>
<li>sourceCompatibility行被注入以使用Java 8 JDK来编译Java源代码。</li>
<li>设置intellij.version指定用于构建插件的IntelliJ平台的版本。它默认为用于运行“新建项目向导”的IntelliJ IDEA版本。</li>
<li>patchPluginXml.changeNotes值设置为占位符文本。</li>
</ul>

<h3 id="toc_8">执行插件</h3>

<p>打开Gradle工具窗口找到并运行<code>runIde</code>任务</p>

<p><img src="media/16104540799826/16104558761244.jpg" alt=""/></p>

<p><a href="https://github.com/JetBrains/gradle-intellij-plugin#setup-dsl">org.jetbrains.intellij的Gradle配置</a><br/>
<a href="https://github.com/JetBrains/intellij-sdk-code-samples">Intellij IDEA官方DEMO</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack学习 - WorkManager]]></title>
    <link href="http://adolph.cc/16066640335833.html"/>
    <updated>2020-11-29T23:33:53+08:00</updated>
    <id>http://adolph.cc/16066640335833.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">WorkManager 是什么</a>
</li>
<li>
<a href="#toc_1">核心类</a>
</li>
<li>
<a href="#toc_2">使用WorkManger</a>
<ul>
<li>
<a href="#toc_3">定义Work</a>
</li>
<li>
<a href="#toc_4">定义WorkRequest</a>
<ul>
<li>
<a href="#toc_5">调度一次性任务</a>
</li>
<li>
<a href="#toc_6">调度定期工作</a>
<ul>
<li>
<a href="#toc_7">灵活的运行间隔</a>
</li>
<li>
<a href="#toc_8">约束对定期工作的影响</a>
</li>
</ul>
</li>
<li>
<a href="#toc_9">工作约束</a>
</li>
<li>
<a href="#toc_10">延迟工作</a>
</li>
<li>
<a href="#toc_11">重试和退避策略</a>
</li>
<li>
<a href="#toc_12">标记工作</a>
</li>
<li>
<a href="#toc_13">分配输入数据</a>
</li>
</ul>
</li>
<li>
<a href="#toc_14">WorkManager</a>
<ul>
<li>
<a href="#toc_15">唯一工作</a>
</li>
<li>
<a href="#toc_16">冲突解决政策</a>
</li>
<li>
<a href="#toc_17">观察您的工作</a>
</li>
<li>
<a href="#toc_18">复杂的工作查询</a>
</li>
<li>
<a href="#toc_19">取消和停止工作</a>
</li>
<li>
<a href="#toc_20">停止正在运行的工作器</a>
</li>
<li>
<a href="#toc_21">onStopped() 回调</a>
</li>
</ul>
</li>
<li>
<a href="#toc_22">链接工作</a>
</li>
<li>
<a href="#toc_23">观察工作器的中间进度</a>
<ul>
<li>
<a href="#toc_24">更新进度</a>
</li>
<li>
<a href="#toc_25">观察进度</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">WorkManager 是什么</h2>

<p>作为Android Jetpack中的新组件，WorkManager负责用来管理后台任务，可以轻松调度即使在应用退出或设备重启时仍应运行的可延迟异步任务，不适用于应用进程结束时能够安全终止的运行中的后台工作，也不适用于需要立即执行的任务。</p>

<span id="more"></span><!-- more --> 

<p><img src="media/16066640335833/16066691224038.jpg" alt=""/></p>

<p>当应用正在运行时，它会在当前的进程中启用一个子线程执行。应用没有运行的情况下启用，它则会自己选择一种合适的方式在后台运行。具体是什么方式和 Android 的版本和依赖环境有关：</p>

<p><img src="media/16066640335833/16066687850496.png" alt=""/></p>

<p><strong>优点</strong></p>

<ul>
<li>使用方便，内部会根据不同系统选择合适方案</li>
<li>能链式调度，让各任务按指定顺序执行</li>
<li>能配置各种执行状态，如有无网络、是否在充电</li>
<li>任务被存储进数据库，关机仍可执行</li>
<li>遵循低电耗模式等省电功能</li>
<li>监控和管理计划任务</li>
</ul>

<h2 id="toc_1">核心类</h2>

<p>WorkManager中涉及到的相关类</p>

<ul>
<li><p>Worker<br/>
任务的执行者，是一个抽象类，需要继承它实现要执行的任务。</p></li>
<li><p>WorkRequest<br/>
指定让哪个 Woker 执行任务，指定执行的环境，执行的顺序等。<br/>
要使用它的子类 OneTimeWorkRequest 或 PeriodicWorkRequest。</p></li>
<li><p>WorkManager<br/>
管理任务请求和任务队列，发起的 WorkRequest 会进入它的任务队列。</p></li>
<li><p>WorkStatus<br/>
包含有任务的状态和任务的信息，以 LiveData 的形式提供给观察者，更新相关UI</p></li>
</ul>

<h2 id="toc_2">使用WorkManger</h2>

<p>在build.gradle中添加依赖:</p>

<pre><code class="language-text">dependencies {
  def work_version = &quot;2.4.0&quot;

    // (Java only)
    implementation &quot;androidx.work:work-runtime:$work_version&quot;

    // Kotlin + coroutines
    implementation &quot;androidx.work:work-runtime-ktx:$work_version&quot;

    // optional - RxJava2 support
    implementation &quot;androidx.work:work-rxjava2:$work_version&quot;

    // optional - GCMNetworkManager support
    implementation &quot;androidx.work:work-gcm:$work_version&quot;

    // optional - Test helpers
    androidTestImplementation &quot;androidx.work:work-testing:$work_version&quot;
  }
</code></pre>

<p>添加依赖项并同步 Gradle 项目</p>

<h3 id="toc_3">定义Work</h3>

<p>自定义Work类，继承Worker类。<code>doWork()</code> 方法在 <code>WorkManager</code> 提供的后台线程上同步运行。</p>

<pre><code class="language-kotlin">class UploadWorker(appContext: Context, workerParams: WorkerParameters):
       Worker(appContext, workerParams) {
   override fun doWork(): Result {

       // Do the work here--in this case, upload the images.
       uploadImages()

       // Indicate whether the work finished successfully with the Result
       return Result.success()
   }
}
</code></pre>

<p>从 <code>doWork()</code> 返回的 <code>Result</code> 会通知 <code>WorkManager</code> 服务工作是否成功，以及工作失败时是否应重试工作。</p>

<ul>
<li><code>Result.success()</code>：工作成功完成。</li>
<li><code>Result.failure()</code>：工作失败。</li>
<li><code>Result.retry()</code>：工作失败，应根据其重试策略在其他时间尝试。</li>
</ul>

<h3 id="toc_4">定义WorkRequest</h3>

<p>定义Work后，必须使用 <code>WorkManager</code> 服务进行调度该工作才能运行。对于如何调度Work，<code>WorkManager</code> 提供了很大的灵活性。您可以将其安排为在某段时间内定期运行，也可以将其安排为仅运行一次。</p>

<p><code>Worker</code> 定义工作单元，<code>WorkRequest</code>（及其子类）则定义工作运行方式和时间,包含 <code>WorkManager</code> 调度和运行工作所需的所有信息,其中包括运行工作必须满足的约束、调度信息（例如延迟或重复间隔）、重试配置，并且可能包含输入数据。</p>

<p><code>WorkRequest</code> 本身是抽象基类。该类有两个派生实现，可用于创建 <code>OneTimeWorkRequest</code> 和 <code>PeriodicWorkRequest</code> 请求。顾名思义，<code>OneTimeWorkRequest</code> 适用于调度非重复性工作，而 <code>PeriodicWorkRequest</code> 则更适合调度以一定间隔重复执行的工作。</p>

<pre><code class="language-java">Constraints constraints = new Constraints();
//设备存储空间充足的时候 才能执行 ,&gt;15%
constraints.setRequiresStorageNotLow(true);
//必须在执行的网络条件下才能好执行,不计流量 ,wifi
constraints.setRequiredNetworkType(NetworkType.UNMETERED);
//设备的充电量充足的才能执行 &gt;15%
constraints.setRequiresBatteryNotLow(true);
//只有设备在充电的情况下 才能允许执行
constraints.setRequiresCharging(true);
//只有设备在空闲的情况下才能被执行 比如息屏，cpu利用率不高
constraints.setRequiresDeviceIdle(true);
//workmanager利用contentObserver监控传递进来的这个uri对应的内容是否发生变化,当且仅当它发生变化了
//我们的任务才会被触发执行，以下三个api是关联的
constraints.setContentUriTriggers(null);
//设置从content变化到被执行中间的延迟时间，如果在这期间。content发生了变化，延迟时间会被重新计算
//这个content就是指 我们设置的setContentUriTriggers uri对应的内容
constraints.setTriggerContentUpdateDelay(0);
//设置从content变化到被执行中间的最大延迟时间  这个content就是指 我们设置的constraints.setContentUriTriggers uri对应的内容
constraints.setTriggerMaxContentDelay(0);
</code></pre>

<p>通过创建Constraints ，设置具体的约束条件，在创建Request的时候，调用.setConstraints(constraints)即可。</p>

<pre><code class="language-java"> OneTimeWorkRequest request = new OneTimeWorkRequest
                .Builder(UploadFileWorker.class)
                .setInputData(inputData)
                .setConstraints(constraints)
//                .setConstraints(constraints)
//                //设置一个拦截器，在任务执行之前 可以做一次拦截，去修改入参的数据然后返回新的数据交由worker使用
//                .setInputMerger(null)
//                //当一个任务被调度失败后，所要采取的重试策略，可以通过BackoffPolicy来执行具体的策略
//                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 10, TimeUnit.SECONDS)
//                //任务被调度执行的延迟时间
//                .setInitialDelay(10, TimeUnit.SECONDS)
//                //设置该任务尝试执行的最大次数
//                .setInitialRunAttemptCount(2)
//                //设置这个任务开始执行的时间
//                //System.currentTimeMillis()
//                .setPeriodStartTime(0, TimeUnit.SECONDS)
//                //指定该任务被调度的时间
//                .setScheduleRequestedAt(0, TimeUnit.SECONDS)
//                //当一个任务执行状态编程finish时，又没有后续的观察者来消费这个结果，难么workamnager会在
//                //内存中保留一段时间的该任务的结果。超过这个时间，这个结果就会被存储到数据库中
//                //下次想要查询该任务的结果时，会触发workmanager的数据库查询操作，可以通过uuid来查询任务的状态
//                .keepResultsForAtLeast(10, TimeUnit.SECONDS)
                .build();
</code></pre>

<h4 id="toc_5">调度一次性任务</h4>

<p>对于无需额外配置的简单工作，请使用静态方法 from：</p>

<pre><code class="language-kotlin">val myWorkRequest = OneTimeWorkRequest.from(MyWork::class.java)
</code></pre>

<p>对于更复杂的工作，可以使用构建器。</p>

<pre><code class="language-kotlin">val uploadWorkRequest: WorkRequest =
   OneTimeWorkRequestBuilder&lt;MyWork&gt;()
       // Additional configuration
       .build()
</code></pre>

<h4 id="toc_6">调度定期工作</h4>

<p>应用有时可能需要定期运行某些工作。例如，定期备份数据、定期下载应用中的新鲜内容或者定期上传日志到服务器。</p>

<p>使用 <code>PeriodicWorkRequest</code> 创建定期执行的 <code>WorkRequest</code> 对象</p>

<pre><code class="language-kotlin">val saveRequest =
       PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(1, TimeUnit.HOURS)
    // Additional configuration
           .build()
</code></pre>

<p>在此示例中，工作的运行时间间隔定为一小时。</p>

<p>时间间隔定义为两次重复执行之间的最短时间。工作器的确切执行时间取决于您在 <code>WorkRequest</code> 对象中设置的约束以及系统执行的优化。</p>

<h5 id="toc_7">灵活的运行间隔</h5>

<p>如果您的工作的性质致使其对运行时间敏感，您可以将 <code>PeriodicWorkRequest</code> 配置为在每个时间间隔的灵活时间段内运行。</p>

<p><img src="media/16066640335833/16066662472408.png" alt=""/></p>

<p>如需定义具有灵活时间段的定期工作，请在创建 <code>PeriodicWorkRequest</code> 时传递 <code>flexInterval</code> 以及 <code>repeatInterval</code>。灵活时间段从 <code>repeatInterval - flexInterval</code> 开始，一直到间隔结束。</p>

<p>以下是可在每小时的最后 15 分钟内运行的定期工作的示例。</p>

<pre><code class="language-kotlin">val myUploadWork = PeriodicWorkRequestBuilder&lt;SaveImageToFileWorker&gt;(
       1, TimeUnit.HOURS, // repeatInterval (the period cycle)
       15, TimeUnit.MINUTES) // flexInterval
    .build()
</code></pre>

<p>重复间隔必须大于或等于 <code>PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS</code>，而灵活间隔必须大于或等于 <code>PeriodicWorkRequest.MIN_PERIODIC_FLEX_MILLIS</code>。</p>

<h5 id="toc_8">约束对定期工作的影响</h5>

<p>您可以对定期工作设置约束。例如，您可以为工作请求添加约束，以便工作仅在用户设备充电时运行。在这种情况下，除非满足约束条件，否则即使过了定义的重复间隔，PeriodicWorkRequest 也不会运行。这可能会导致工作在某次运行时出现延迟，甚至会因在相应间隔内未满足条件而被跳过。</p>

<h4 id="toc_9">工作约束</h4>

<p>约束可确保将工作延迟到满足最佳条件时运行。以下约束适用于 WorkManager。</p>

<table>
<thead>
<tr>
<th style="text-align: left">约束类型</th>
<th style="text-align: left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">NetworkType</td>
<td style="text-align: left">约束运行工作所需的网络类型。例如 Wi-Fi (UNMETERED)。</td>
</tr>
<tr>
<td style="text-align: left">BatteryNotLow</td>
<td style="text-align: left">如果设置为 true，那么当设备处于“电量不足模式”时，工作不会运行。</td>
</tr>
<tr>
<td style="text-align: left">RequiresCharging</td>
<td style="text-align: left">如果设置为 true，那么工作只能在设备充电时运行。</td>
</tr>
<tr>
<td style="text-align: left">DeviceIdle</td>
<td style="text-align: left">如果设置为 true，则要求用户的设备必须处于空闲状态，才能运行工作。如果您要运行批量操作，否则可能会降低用户设备上正在积极运行的其他应用的性能，建议您使用此约束。</td>
</tr>
<tr>
<td style="text-align: left">StorageNotLow</td>
<td style="text-align: left">如果设置为 true，那么当用户设备上的存储空间不足时，工作不会运行。</td>
</tr>
</tbody>
</table>

<p>如需创建一组约束并将其与某项工作相关联，请使用一个 Contraints.Builder() 创建 Constraints 实例，并将该实例分配给 WorkRequest.Builder()。</p>

<p>例如，以下代码会构建了一个工作请求，该工作请求仅在用户设备正在充电且连接到 Wi-Fi 网络时才会运行：</p>

<pre><code class="language-kotlin">val constraints = Constraints.Builder()
   .setRequiredNetworkType(NetworkType.UNMETERED)
   .setRequiresCharging(true)
   .build()

val myWorkRequest: WorkRequest =
   OneTimeWorkRequestBuilder&lt;MyWork&gt;()
       .setConstraints(constraints)
       .build()
</code></pre>

<p>如果指定了多个约束，工作将仅在满足所有约束时才会运行。</p>

<h4 id="toc_10">延迟工作</h4>

<p>如果工作没有约束，或者当工作加入队列时所有约束都得到了满足，那么系统可能会选择立即运行该工作。如果您不希望工作立即运行，可以将工作指定为在经过一段最短初始延迟时间后再启动。</p>

<p>下面举例说明了如何将工作设置为在加入队列后至少经过 10 分钟后再运行。</p>

<pre><code class="language-kotlin">val myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()
   .setInitialDelay(10, TimeUnit.MINUTES)
   .build()
</code></pre>

<p>定期工作只有首次运行时会延迟。</p>

<h4 id="toc_11">重试和退避策略</h4>

<p>如果需要让 <code>WorkManager</code> 重试工作，可以从工作器返回 <code>Result.retry()</code>。然后，系统将根据退避延迟时间和退避政策重新调度工作。</p>

<p>退避延迟时间指定了首次尝试后重试工作前的最短等待时间。此值不能超过 10 秒（或 MIN_BACKOFF_MILLIS）。<br/>
退避政策定义了在后续重试过程中，退避延迟时间随时间以怎样的方式增长。<code>WorkManager</code> 支持 2 个退避政策，即 <code>LINEAR</code> 和 <code>EXPONENTIAL</code>。<br/>
每个工作请求都有退避政策和退避延迟时间。默认政策是 EXPONENTIAL，延迟时间为 10 秒，但您可以在工作请求配置中替换此设置。</p>

<p>以下是自定义退避延迟时间和政策的示例。</p>

<pre><code class="language-kotlin">val myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()
   .setBackoffCriteria(
       BackoffPolicy.LINEAR,
       OneTimeWorkRequest.MIN_BACKOFF_MILLIS,
       TimeUnit.MILLISECONDS)
   .build()
</code></pre>

<p>在本示例中，最短退避延迟时间设置为允许的最小值，即 10 秒。由于政策为 LINEAR，每次尝试重试时，重试间隔都会增加约 10 秒。例如，第一次运行以 Result.retry() 结束并在 10 秒后重试；然后，如果工作在后续尝试后继续返回 Result.retry()，那么接下来会在 20 秒、30 秒、40 秒后重试，以此类推。如果退避政策设置为 EXPONENTIAL，那么重试时长序列将接近 20、40、80 秒，以此类推。</p>

<blockquote>
<p>注意：退避延迟时间不精确，在两次重试之间可能会有几秒钟的差异，但绝不会低于配置中指定的初始退避延迟时间。</p>
</blockquote>

<h4 id="toc_12">标记工作</h4>

<p>每个工作请求都有一个唯一标识符，该标识符可用于在以后标识该工作，以便取消工作或观察其进度。</p>

<p>如果有一组在逻辑上相关的工作，对这些工作项进行标记可能也会很有帮助。通过标记，您一起处理一组工作请求。</p>

<p>例如，WorkManager.cancelAllWorkByTag(String) 会取消带有特定标记的所有工作请求，WorkManager.getWorkInfosByTag(String) 会返回一个 WorkInfo 对象列表，该列表可用于确定当前工作状态。</p>

<p>以下代码展示了如何向工作添加“cleanup”标记：</p>

<pre><code class="language-kotlin">val myWorkRequest = OneTimeWorkRequestBuilder&lt;MyWork&gt;()
   .addTag(&quot;cleanup&quot;)
   .build()
</code></pre>

<p>最后，可以向单个工作请求添加多个标记。这些标记在内部以一组字符串的形式进行存储。对于工作请求，您可以通过 WorkRequest.getTags() 检索其标记集。</p>

<h4 id="toc_13">分配输入数据</h4>

<p>您的工作可能需要输入数据才能正常运行。例如，处理图片上传的工作可能需要使用待上传图片的 URI 作为输入数据。</p>

<p>输入值以键值对的形式存储在 Data 对象中，并且可以在工作请求中设置。WorkManager 会在执行工作时将输入 Data 传递给工作。Worker 类可通过调用 Worker.getInputData() 访问输入参数。以下代码展示了如何创建需要输入数据的 Worker 实例，以及如何在工作请求中发送该实例。</p>

<pre><code class="language-kotlin">// Define the Worker requiring input
class UploadWork(appContext: Context, workerParams: WorkerParameters)
   : Worker(appContext, workerParams) {

   override fun doWork(): Result {
       val imageUriInput =
           inputData.getString(&quot;IMAGE_URI&quot;) ?: return Result.failure()

       uploadFile(imageUriInput)
       return Result.success()
   }
   ...
}

// Create a WorkRequest for your Worker and sending it input
val myUploadWork = OneTimeWorkRequestBuilder&lt;UploadWork&gt;()
   .setInputData(workDataOf(
       &quot;IMAGE_URI&quot; to &quot;http://...&quot;
   ))
   .build()
</code></pre>

<h3 id="toc_14">WorkManager</h3>

<p>定义 <code>Worker</code> 和 <code>WorkRequest</code> 后，最后一步是将工作加入队列。将工作加入队列的最简单方法是调用 <code>WorkManager enqueue()</code> 方法，然后传递要运行的 <code>WorkRequest</code>。</p>

<pre><code class="language-kotlin">val myWork: WorkRequest = // ... OneTime or PeriodicWork
WorkManager.getInstance(requireContext()).enqueue(myWork)
</code></pre>

<p>在将工作加入队列时请小心谨慎，以避免重复。例如，应用可能会每 24 小时尝试将其日志上传到后端服务。如果不谨慎，即使作业只需运行一次，您最终也可能会多次将同一作业加入队列。为了实现此目标，您可以将工作调度为唯一工作。</p>

<h4 id="toc_15">唯一工作</h4>

<p>唯一工作是一个很实用的概念，可确保同一时刻只有一个具有特定名称的工作实例。</p>

<p>唯一工作既可用于一次性工作，也可用于定期工作。您可以通过调用以下方法之一创建唯一工作序列，具体取决于您是调度重复工作还是一次性工作。</p>

<ul>
<li><code>WorkManager.enqueueUniqueWork()</code>（用于一次性工作）</li>
<li><code>WorkManager.enqueueUniquePeriodicWork()</code>（用于定期工作）</li>
</ul>

<p>这两种方法都接受 3 个参数：</p>

<ul>
<li><em>uniqueWorkName</em> 用于唯一标识工作请求的 String。</li>
<li><em>existingWorkPolicy</em> 此 enum 可告知 WorkManager 如果已有使用该名称且尚未完成的唯一工作链，应执行什么操作。</li>
<li><em>work</em> 要调度的 <code>WorkRequest</code>。</li>
</ul>

<p>借助唯一工作，我们可以解决前面提到的重复调度问题。</p>

<pre><code class="language-kotiln">val sendLogsWorkRequest =
       PeriodicWorkRequestBuilder&lt;SendLogsWorker&gt;(24, TimeUnit.HOURS)
           .setConstraints(Constraints.Builder()
               .setRequiresCharging(true)
               .build()
            )
           .build()
WorkManager.getInstance(this).enqueueUniquePeriodicWork(
           &quot;sendLogs&quot;,
           ExistingPeriodicWorkPolicy.KEEP,
           sendLogsWorkRequest
)
</code></pre>

<p>现在，如果上述代码在 sendLogs 作业已处于队列中的情况下运行，系统会保留现有的作业，并且不会添加新的作业。</p>

<p>当您需要逐步构建一个长任务链时，也可以利用唯一工作序列。例如，照片编辑应用可能允许用户撤消一长串操作。其中的每一项撤消操作可能都需要一些时间来完成，但必须按正确的顺序执行。在这种情况下，应用可以创建一个“撤消”链，并根据需要将每个撤消操作附加到该链上。</p>

<h4 id="toc_16">冲突解决政策</h4>

<p>调度唯一工作时，您必须告知 WorkManager 在发生冲突时要执行的操作。您可以通过在将工作加入队列时传递一个枚举来实现此目的。</p>

<p>对于一次性工作，您需要提供一个 ExistingWorkPolicy，它支持用于处理冲突的 4 个选项。</p>

<ul>
<li><strong><code>REPLACE</code></strong>：用新工作替换现有工作。此选项将取消现有工作。</li>
<li><strong><code>KEEP</code></strong>：保留现有工作，并忽略新工作。</li>
<li><p><strong><code>APPEND</code></strong>：将新工作附加到现有工作的末尾，在现有工作完成后运行。<br/>
现有工作将成为新工作的先决条件。如果现有工作变为 <code>CANCELLED</code> 或 <code>FAILED</code> 状态，新工作也会变为 <code>CANCELLED</code> 或 <code>FAILED</code>。如果您希望无论现有工作的状态如何都运行新工作，请改用 <code>APPEND_OR_REPLACE</code>。</p></li>
<li><p><strong><code>APPEND_OR_REPLACE</code></strong> 功能类似于 <code>APPEND</code>，不过它并不依赖于先决条件工作状态。即使现有工作变为 <code>CANCELLED</code> 或 <code>FAILED</code> 状态，新工作仍会运行。<br/>
对于定期工作，您需要提供一个 <code>ExistingPeriodicWorkPolicy</code>，它支持 <code>REPLACE</code> 和 <code>KEEP</code> 这两个选项。这些选项的功能与其对应的 <code>ExistingWorkPolicy</code> 功能相同。</p></li>
</ul>

<h4 id="toc_17">观察您的工作</h4>

<p>在将工作加入队列后，您可以随时按其 <code>name</code>、<code>id</code> 或与其关联的 <code>tag</code> 在 <code>WorkManager</code> 中进行查询，以检查其状态。</p>

<pre><code class="language-kotlin">
// by id
workManager.getWorkInfoById(syncWorker.id) // ListenableFuture&lt;WorkInfo&gt;

// by name
workManager.getWorkInfosForUniqueWork(&quot;sync&quot;) // ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;

// by tag
workManager.getWorkInfosByTag(&quot;syncTag&quot;) // ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;
</code></pre>

<p>该查询会返回 WorkInfo 对象的 ListenableFuture，该值包含工作的 id、其标记、其当前的 State 以及通过 Result.success(outputData) 设置的任何输出数据。</p>

<p>利用每个方法的 LiveData 变种，您可以通过注册监听器来观察 WorkInfo 的变化。例如，如果您想要在某项工作成功完成后向用户显示消息，您可以进行如下设置：</p>

<pre><code class="language-kotlin">workManager.getWorkInfoByIdLiveData(syncWorker.id)
               .observe(viewLifecycleOwner) { workInfo -&gt;
   if(workInfo?.state == WorkInfo.State.SUCCEEDED) {
       Snackbar.make(requireView(),
      R.string.work_completed, Snackbar.LENGTH_SHORT)
           .show()
   }
}
</code></pre>

<h4 id="toc_18">复杂的工作查询</h4>

<p>使用 WorkQuery 对象对已加入队列的作业进行复杂查询。WorkQuery 支持按工作的标记、状态和唯一工作名称的组合进行查询。</p>

<p>以下示例说明了如何查找带有“syncTag”标记、处于 FAILED 或 CANCELLED 状态，且唯一工作名称为“preProcess”或“sync”的所有工作。</p>

<pre><code class="language-kotlin">val workQuery = WorkQuery.Builder
       .fromTags(listOf(&quot;syncTag&quot;))
       .addStates(listOf(WorkInfo.State.FAILED, WorkInfo.State.CANCELLED))
       .addUniqueWorkNames(listOf(&quot;preProcess&quot;, &quot;sync&quot;)
    )
   .build()

val workInfos: ListenableFuture&lt;List&lt;WorkInfo&gt;&gt; = workManager.getWorkInfos(workQuery)
</code></pre>

<h4 id="toc_19">取消和停止工作</h4>

<p>如果您不再需要运行先前加入队列的工作，则可以要求将其取消。您可以按工作的 name、id 或与其关联的 tag 取消工作。</p>

<pre><code class="language-kotlin">// by id
workManager.cancelWorkById(syncWorker.id)

// by name
workManager.cancelUniqueWork(&quot;sync&quot;)

// by tag
workManager.cancelAllWorkByTag(&quot;syncTag&quot;)
</code></pre>

<p><code>WorkManager</code> 会在后台检查工作的 <code>State</code>。如果工作已经完成，系统不会执行任何操作。否则，工作的状态会更改为 <code>CANCELLED</code>，之后就不会运行这个工作。任何依赖于此工作的 <code>WorkRequest</code> 作业也将变为 <code>CANCELLED</code>。</p>

<h4 id="toc_20">停止正在运行的工作器</h4>

<p>正在运行的 Worker 可能会由于以下几种原因而停止运行：</p>

<ul>
<li>您明确要求取消它（例如，通过调用 WorkManager.cancelWorkById(UUID) 取消）。</li>
<li>如果是唯一工作，您明确地将 ExistingWorkPolicy 为 REPLACE 的新 WorkRequest 加入到了队列中。旧的 WorkRequest 会立即被视为已取消。</li>
<li>您的工作约束条件已不再满足。</li>
<li>系统出于某种原因指示您的应用停止工作。如果超过 10 分钟的执行期限，可能会发生这种情况。该工作会调度为在稍后重试。</li>
</ul>

<p>在这些情况下，您的工作器会停止。</p>

<p>您应该合作地取消正在进行的任何工作，并释放您的工作器保留的所有资源。例如，此时应该关闭所打开的数据库和文件句柄。有两种机制可让您了解工作器何时停止。</p>

<h4 id="toc_21">onStopped() 回调</h4>

<p>在您的工作器停止后，WorkManager 会立即调用 ListenableWorker.onStopped()。替换此方法可关闭您可能保留的所有资源。</p>

<p><strong>isStopped() 属性</strong><br/>
您可以调用 ListenableWorker.isStopped() 方法以检查工作器是否已停止。如果您在工作器中执行长时间运行的操作或重复操作，您应经常检查此属性，并尽快将其用作停止工作的信号。</p>

<h3 id="toc_22">链接工作</h3>

<p>使用 WorkManager 创建工作链并将其加入队列。工作链用于指定多个依存任务并定义这些任务的运行顺序。当您需要以特定顺序运行多个任务时，此功能尤其有用。</p>

<p>如需创建工作链，您可以使用 WorkManager.beginWith(OneTimeWorkRequest) 或 WorkManager.beginWith(List<OneTimeWorkRequest>)，这会返回 WorkContinuation 实例。</p>

<p>然后，可以使用 WorkContinuation 通过 then(OneTimeWorkRequest) 或 then(List<OneTimeWorkRequest>) 添加依存 OneTimeWorkRequest。 .</p>

<p>每次调用 WorkContinuation.then(...) 都会返回一个新的 WorkContinuation 实例。如果添加了 OneTimeWorkRequest 实例的 List，这些请求可能会并行运行。</p>

<p>最后，您可以使用 WorkContinuation.enqueue() 方法对 WorkContinuation 工作链执行 enqueue() 操作。</p>

<p>WorkManager 允许我们按照一定的顺序执行任务，比如我想 A、B、C 三个任务按先后顺序执行：</p>

<p><img src="media/16066640335833/16066686325006.png" alt=""/></p>

<pre><code class="language-java"> OneTimeWorkRequest requestA = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
        OneTimeWorkRequest requestB = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
        OneTimeWorkRequest requestC = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
        WorkManager.getInstance(PublishActivity.this).beginWith(requestA).then(requestB).then(requestC).enqueue();
</code></pre>

<p>这样的话，上一个任务的 outputData 会成为下一个任务的 inputData。</p>

<p>更复杂一点<br/>
<img src="media/16066640335833/16066686969137.png" alt=""/></p>

<pre><code class="language-java">OneTimeWorkRequest requestA = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
OneTimeWorkRequest requestB = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
OneTimeWorkRequest requestC = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
OneTimeWorkRequest requestD = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();
OneTimeWorkRequest requestE = new OneTimeWorkRequest.Builder(UploadFileWorker.class)
                .build();

WorkContinuation chainA = WorkManager.getInstance(PublishActivity.this).beginWith(requestA).then(requestB);
WorkContinuation chainB = WorkManager.getInstance(PublishActivity.this).beginWith(requestC).then(requestD);

List&lt;WorkContinuation&gt; chains =new ArrayList&lt;&gt;();
        chains.add(chainA);
        chains.add(chainB);
        
WorkContinuation.combine(chains).then(requestE).enqueue();
</code></pre>

<h3 id="toc_23">观察工作器的中间进度</h3>

<p>如果应用在前台运行时，工作器保持运行状态，也可以使用返回 WorkInfo 的 LiveData 的 API 向用户显示此信息。</p>

<h4 id="toc_24">更新进度</h4>

<p>对于使用 ListenableWorker 或 Worker 的 Java 开发者，setProgressAsync() API 会返回 ListenableFuture<Void>；更新进度是异步过程，因为更新过程包括将进度信息存储在数据库中。在 Kotlin 中，您可以使用 CoroutineWorker 对象的 setProgress() 扩展函数来更新进度信息。</p>

<p>此示例展示了一个简单的 ProgressWorker。该 Worker 启动时将进度设置为 0，完成时将进度值更新为 100。</p>

<pre><code class="language-kotlin">    import android.content.Context
    import androidx.work.CoroutineWorker
    import androidx.work.Data
    import androidx.work.WorkerParameters
    import kotlinx.coroutines.delay

    class ProgressWorker(context: Context, parameters: WorkerParameters) :
        CoroutineWorker(context, parameters) {

        companion object {
            const val Progress = &quot;Progress&quot;
            private const val delayDuration = 1L
        }

        override suspend fun doWork(): Result {
            val firstUpdate = workDataOf(Progress to 0)
            val lastUpdate = workDataOf(Progress to 100)
            setProgress(firstUpdate)
            delay(delayDuration)
            setProgress(lastUpdate)
            return Result.success()
        }
    }
</code></pre>

<h4 id="toc_25">观察进度</h4>

<p>观察进度信息也很简单。您可以使用 getWorkInfoBy…() 或 getWorkInfoBy…LiveData() 方法，并引用 WorkInfo。</p>

<pre><code class="language-kotlin"> WorkManager.getInstance(applicationContext)
        // requestId is the WorkRequest id
        .getWorkInfoByIdLiveData(requestId)
        .observe(observer, Observer { workInfo: WorkInfo? -&gt;
                if (workInfo != null) {
                    val progress = workInfo.progress
                    val value = progress.getInt(Progress, 0)
                    // Do something with progress information
                }
        })
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS服务器维护]]></title>
    <link href="http://adolph.cc/16039421034043.html"/>
    <updated>2020-10-29T11:28:23+08:00</updated>
    <id>http://adolph.cc/16039421034043.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">关闭系统休眠</h2>

<p>系统安装的是 无桌面 centos 7，可能是自动更新的原因，系统会无故休眠，远程 ssh 登录不了，网络 ping 不通，键盘操作无反应。</p>

<p>进入系统，etc 下多出了 x11 文件夹，新增 xorg.conf 文件，关闭自动休眠</p>

<p><code>vim /etc/X11/xorg.conf</code></p>

<p><em>添加以下内容</em></p>

<pre><code class="language-text">Section &quot;ServerFlags&quot;
        Option &quot;BlankTime&quot;   &quot;0&quot;
        Option &quot;StandbyTime&quot; &quot;0&quot;
        Option &quot;SuspendTime&quot; &quot;0&quot;
        Option &quot;OffTime&quot;     &quot;0&quot;
EndSection
 
Section &quot;Monitor&quot;
        Option &quot;DPMS&quot; &quot;false&quot;
EndSection
</code></pre>

<p>重启系统，即可。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker部署服务]]></title>
    <link href="http://adolph.cc/16039359320346.html"/>
    <updated>2020-10-29T09:45:32+08:00</updated>
    <id>http://adolph.cc/16039359320346.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">服务自启动</h2>

<p><strong>设置Docker服务自启动</strong></p>

<pre><code class="language-text">systemctl enable docker.service
</code></pre>

<span id="more"></span><!-- more -->

<h2 id="toc_1">部署MariaDB</h2>

<ol>
<li><code>docker search mariadb</code> 查看mariadb数据源</li>
<li><code>docker pull mariadb</code> 拉取mariadb数据库</li>
<li><code>mkdir -p /data/mariadb/data</code> 创建msyql到本地的数据文件夹映射路径</li>
<li><code>docker run --name mariadb -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -v /data/mariadb/data:/var/lib/mysql -d mariadb</code> 启动mariadb容器</li>
<li><code>docker ps -a</code> 查看mysql容器启动情况</li>
<li><code>docker container update --restart=always d72e7e910ab6</code> 设置容器自启动随docker的启动而启动</li>
<li><code>docker exec -it d72e7e910ab6 bash</code> 进入容器的终端，用来登录mysql客户端</li>
<li><code>docker rm d72e7e910ab6</code> 移除容器id为d72e7e910ab6的容器</li>
</ol>

<h2 id="toc_2">部署Redis</h2>

<ol>
<li><code>docker pull redis</code>  下载镜像</li>
<li><code>docker images</code>  查看下载</li>
<li><code>docker run --name curieApiRedis -p 6379:6379 -d --restart=always redis:latest redis-server --appendonly yes --requirepass 110120</code>
<ol>
<li>--name curieApiRedis 设置实例别名</li>
<li>-p 6379:6379 是映射宿主机的端口</li>
<li>--restart=always 是随Docker启动</li>
<li>redis:latest 是redis版本最新</li>
<li>redis-server --appendonly yes 是启动时执行命令设置持久化</li>
<li>--requirepass 110120 是设置连接密码为110120</li>
</ol></li>
</ol>

<h2 id="toc_3">部署Nacos</h2>

<ol>
<li><code>docker search nacos</code> 搜索nacos镜像</li>
<li><code>docker pull nacos/nacos-server</code> 下载镜像</li>
<li><code>docker images</code> 查看本地镜像，看看拉到本地没有</li>
<li><code>docker run -d -p 8848:8848 --env MODE=standalone  --name nacos  nacos/nacos-server</code> 启动镜像 <a href="https://nacos.io/zh-cn/docs/quick-start-docker.html">nacos官方文档</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flutter中的滚动布局]]></title>
    <link href="http://adolph.cc/16000203391559.html"/>
    <updated>2020-09-14T02:05:39+08:00</updated>
    <id>http://adolph.cc/16000203391559.html</id>
    <content type="html"><![CDATA[
<p>可滚动组件都直接或间接包含一个Scrollable组件，其中包含ViewPort的概念。又由于通常可滚动布局子组件过多，占用高度过大，Flutter提出了Sliver概念。Flutter的布局可以分为两种</p>

<ul>
<li>Box ( RenderBox ): 2D 绘制布局</li>
<li>Sliver ( RenderSliver )：滚动布局</li>
</ul>

<span id="more"></span><!-- more -->

<p>可滚动组件的ListView、GridView、CustomScrollView都继承自ScrollView，ScrollView 是一个滚动视图的抽象类，由底下三部分组成</p>

<ul>
<li><code>Scrollable</code> - 它监听各种用户手势并实现滚动的交互设计。</li>
<li><code>Viewport</code> - 它通过在滚动视图内仅显示一部分小部件来实现滚动的可视化设计。</li>
<li><code>Slider</code> - 它们是可以组合以创建各种滚动效果的小部件，如列表，网格和扩展标题。</li>
</ul>

<h2 id="toc_0">Scrollable</h2>

<p>可滚动组件都直接或间接包含一个Scrollable组件</p>

<ul>
<li>监听用户的手势，计算滚动状态发出 Notification</li>
<li>计算 offset 通知 listeners</li>
</ul>

<p>Scrollable 本身不具有绘制内容的能力，它通过构造注入的 viewportBuilder 来创建一个 Viewport 来显示内容，当滚动状态变化的时候，Scrollable 就会不断的更新 Viewport 的 offset ，Viewport 就会不断的更新显示内容。</p>

<ul>
<li>axisDirection: 滚动方向。</li>
<li>physics：此属性接受一个ScrollPhysics类型的对象，它决定可滚动组件如何响应用户操作，比如用户滑动完抬起手指后，继续执行动画；或者滑动到边界时，如何显示。默认情况下，Flutter会根据具体平台分别使用不同的ScrollPhysics对象，应用不同的显示效果，如当滑动到边界时，继续拖动的话，在iOS上会出现弹性效果，而在Android上会出现微光效果。如果你想在所有平台下使用同一种效果，可以显式指定一个固定的ScrollPhysics，Flutter SDK中包含了两个ScrollPhysics的子类，他们可以直接使用：
<ul>
<li>ClampingScrollPhysics：Android下微光效果。</li>
<li>BouncingScrollPhysics：iOS下弹性效果。</li>
</ul></li>
<li>controller：此属性接受一个ScrollController对象。ScrollController的主要作用是控制滚动位置和监听滚动事件。默认情况下，Widget树中会有一个默认的PrimaryScrollController，如果子树中的可滚动组件没有显式的指定controller，并且primary属性值为true时（默认就为true），可滚动组件会使用这个默认的PrimaryScrollController。这种机制带来的好处是父组件可以控制子树中可滚动组件的滚动行为.</li>
</ul>

<h2 id="toc_1">ViewPort视口</h2>

<ul>
<li>ViewPort 是一个显示窗口，它内部可包含多个 Sliver。</li>
<li>ViewPort 的宽高是确定的，它内部 Slivers 的宽高之和是可以大于自身的宽高的。</li>
<li>ViewPort 为了提高性能采用懒加载机制，它只会绘制可视区域内容 Widget。</li>
</ul>

<p>ViewPort 有一些重要属性</p>

<ul>
<li>axisDirection: 主轴方向</li>
<li>crossAxisDirection: 纵轴方向</li>
<li>anchor: 锚点，取值[0,1]，和 zero 的相对位置，比如 0.5 代表 zero 被放到了 Viewport.height / 2 处</li>
<li>offset: 滚动的累计值，确切的说是 viewport 从什么地方开始显示</li>
<li>cacheExtent: 缓存区域，也就是相对有头尾需要预加载的高度</li>
<li>slivers: children widget</li>
</ul>

<h2 id="toc_2">SliverConstraints</h2>

<p>和 Box 布局使用 BoxConstraints 作为约束类似，Sliver 布局采用 SliverConstraints 作为约束，但相对于 Box 要复杂的多，可以理解为 SliverConstraints 描述了 Viewport 和它内部的 Slivers 之间的布局信息</p>

<pre><code class="language-dart">class SliverConstraints extends Constraints {
  // 主轴方向
  final AxisDirection axisDirection;
  // 窗口增长方向
  final GrowthDirection growthDirection;
  // 如果 Direction 是 AxisDirection.down,scrollOffset 代表 sliver 的 top 滑过 viewport 的 top 的值，没滑过 viewport 的 top 时 scrollOffset 为 0。
  final double scrollOffset;
  // 上一个 sliver 覆盖下一个 sliver 的大小（只有上一个 sliver 是 pinned/floating 才有效）
  final double overlap;
  // 轮到当前 sliver 开始绘制了，需要 viewport 告诉 sliver 当前还剩下多少区域可以绘制，受 viewport 的 size 影响
  final double remainingPaintExtent;
  // viewport 主轴上的大小
  final double viewportMainAxisExtent;
  // 缓存区起点（相对于 scrolloffset），如果 cacheExtent 设置为 0，那么 cacheOrigin 一直为 0
  final double cacheOrigin;
  // 剩余的缓存区大小
  final double remainingCacheExtent;

  ...
}
</code></pre>

<h2 id="toc_3">SliverGeometry</h2>

<p>Viewport 通过 SliverConstraints 告知它内部的 sliver 自己的约束信息，比如还有多少空间可用、offset 等，那么Sliver 则通过 SliverGeometry 反馈给 Viewport 需要占用多少空间量。</p>

<pre><code class="language-dart">class SliverGeometry extends Diagnosticable {
  // sliver 可以滚动的范围，可以认为是 sliver 的高度（如果是 AxisDierction.Down） 
  final double scrollExtent;
  // 绘制起点（默认是 0.0），是相对于 sliver 开始 layout 的起点而言的，不会影响下一个 sliver 的 layoutExtent，会影响下一个 sliver 的paintExtent
  final double paintOrigin;
  // 绘制范围
  final double paintExtent;
  // 布局范围，当前 sliver 的 top 到下一个 sliver 的 top 的距离，范围是[0,paintExtent],默认是 paintExtent，会影响下一个 sliver 的 layout 位置
  final double layoutExtent;
  // 最大绘制大小，必须 &gt;= paintExtent
  final double maxPaintExtent;
  // 如果 sliver 被 pinned 在边界的时候，这个大小为 Sliver 的自身的高度,其他情况为0,比如 pinned app bar
  final double maxScrollObstructionExtent;
  // 点击有效区域的大小，默认为paintExtent
  final double hitTestExtent;
  // 是否可见，visible = (paintExtent &gt; 0)
  final bool visible;
  // 是否需要做clip，免得chidren溢出
  final bool hasVisualOverflow;
  // 当前 sliver 占用了 SliverConstraints.remainingCacheExtent 多少像素值
  final double cacheExtent;
  ...
}
</code></pre>

<h2 id="toc_4">ScrollPostion</h2>

<p>ScrollPosition 决定了 Viewport 哪些区域是可见的，它包含了Viewport 的滚动信息。</p>

<pre><code class="language-dart">abstract class ScrollPosition extends ViewportOffset with ScrollMetrics {
  // 滚动偏移量
  double _pixels;
  // 设置滚动响应效果，比如滑动停止后的动画
  final ScrollPhysics physics;
  // 保存当前的滚动偏移量到 PageStore 中，当 Scrollable 重建后可以恢复到当前偏移量
  final bool keepScrollOffset;
  // 最小滚动值
  double _minScrollExtent;
  // 最大滚动值
  double _maxScrollExtent;
  ...
}
</code></pre>

<p>ScrollPosition 的类继承关系如下</p>

<pre><code class="language-text">|-- Listenable
|---- ChangeNotifier
|------ ScrollPosition
|-------- ScrollPositionWithSingleContext
</code></pre>

<p>所以 ScrollPosition 可以作为被观察者，当数据改变的时候可以通知观察者。</p>

<h2 id="toc_5">Sliver 布局过程</h2>

<p>RenderViewport 在 layout 它内部的 slivers 的过程如下：</p>

<p><img src="media/16000203391559/16000648579393.jpg" alt=""/></p>

<p>这个 layout 过程是一个自上而下的线性过程：</p>

<ul>
<li>给 sliver1 输入 SliverConstrains1 并且得到输出结果（SliverGeometry1） ，</li>
<li>根据 SliverGeometry1 重新生成一个新的 SliverConstrains2 输入给 sliver2 得到 SliverGeometry2</li>
<li>…</li>
<li>直至最后一个 sliver</li>
<li>具体的过程可以查看 RenderViewport 的 layoutChildSequence 方法。</li>
</ul>

<h2 id="toc_6">ScrollView</h2>

<p>ScrollView 有以下常用属性：</p>

<ul>
<li><code>cacheExtent</code> → double - 视口在可见区域之前和之后有一个区域，用于缓存用户滚动时即将可见的项目。</li>
<li><code>controller</code> → ScrollController - 一个可用于控制滚动视图滚动到的位置的对象。</li>
<li><code>physics</code> → ScrollPhysics - 滚动视图应如何响应用户输入。</li>
<li><code>primary</code> → bool - 是否是与父级关联的主滚动视图。</li>
<li><code>reverse</code> → bool - 滚动视图是否在阅读方向上滚动。</li>
<li><code>scrollDirection</code> → Axis - 滚动视图滚动的轴。</li>
<li><code>shrinkWrap</code> → bool - 应该根据正在查看的内容确定滚动视图的范围。</li>
</ul>

<p>通过ScrollView串联上面介绍的几个 Widget 之间的关系。 先来看 ScrollView 的 build 方法：</p>

<pre><code class="language-dart">  @override
  Widget build(BuildContext context) {
    final List&lt;Widget&gt; slivers = buildSlivers(context);
    final AxisDirection axisDirection = getDirection(context);

    final ScrollController scrollController = primary
      ? PrimaryScrollController.of(context)
      : controller;
    final Scrollable scrollable = Scrollable(
      ...
      controller: scrollController,
      viewportBuilder: (BuildContext context, ViewportOffset offset) {
        return buildViewport(context, offset, axisDirection, slivers);
      },
    );
    return primary &amp;&amp; scrollController != null
      ? PrimaryScrollController.none(child: scrollable)
      : scrollable;
  }
</code></pre>

<p>可以看到 ScrollView 创建了一个 Scrollable，并传入了构造 ViewPort 的 buildViewPort 方法。<br/>
上面讲过 Scrollable 负责手势监听，通过 buildViewPort 创建视图，在手势变化的时候不停的更新 ViewPort，大概流程如下：</p>

<p><img src="media/16000203391559/16000671831906.jpg" alt=""/></p>

<h2 id="toc_7">列表的构建和复用</h2>

<p><img src="media/16000203391559/%E6%88%AA%E5%B1%8F2020-09-14%20%E4%B8%8B%E5%8D%884.35.02.png" alt="截屏2020-09-14 下午4.35.02"/></p>

<p>ListView和GridView的共同父类BoxScrollView和CustomScrollView都继承于ScrollView。</p>

<p>ScrollView的build方法中调用了buildSlivers和Scrollable实例化以及buildViewport。</p>

<p>buildViewport中如果属性shrinkWrap为true则返回ShrinkWrappingViewport视口对象，否则返回Viewport视口对象。</p>

<p>buildSlivers构建Slivers，BoxScrollView中调用buildChildLayout生成sliver子控件，而buildChildLayout又在ListView和GridView中使用SliverFixedExtentList、SliverList或SliverGrid单独实现。</p>

<p>childrenDelegate使用SliverChildDelegate的子类SliverChildListDelegate或SliverChildBuilderDelegate。SliverChildBuilderDelegate通过在build中调用builder生成child，<br/>
SliverChildListDelegate则是直接使用传入的children获取child。</p>

<p>Sliver组件所创建的RenderObject都是RenderSliver。在CustomScrollView如果使用的不是RenderSliver进行渲染则会报错。</p>

<h2 id="toc_8">滚动视图渲染逻辑</h2>

<p>Flutter视图树中包含了以下三种树 Widget、Element、RenderObject<br/>
<img src="media/16000203391559/16000685718840.jpg" alt=""/></p>

<ul>
<li>Widget树(配置信息的树)
<ul>
<li>Widget使用配置和状态，描述这个View（界面）应该长什么样子。</li>
<li>当一个Widget发生改变时，Widget就会重新build它的描述，框架会和之前的描述进行对比，来决定使用最小的改变（minimal changes）在渲染树中，从一个状态到另一个状态。</li>
</ul></li>
<li>Element树(管理着将 Widget 生成 RenderObject和一些更新操作。)
<ul>
<li>Element是一个Widget的实例，在树中详细的位置。</li>
<li>Widget描述和配置子树的样子，而Element实际去配置在Element树中特定的位置。</li>
<li>Element同时持有Widget和RenderObject(BuilderOwner)</li>
</ul></li>
<li>RenderObject树(渲染树，负责计算布局，绘制)
<ul>
<li>渲染树上的一个对象</li>
<li>RenderObject层是渲染库的核心</li>
</ul></li>
</ul>

<p>RenderObject的子类除了RenderBox，还有3 个 Mixin 以及 RenderAbstractViewport 和 RenderSliver。</p>

<ul>
<li>RenderAbstractViewport 和 RenderSliver 主要处理滑动相关的控件展示，如 ListView 和 ScrollView。</li>
<li>DebugOverflowIndicatorMixin 用于在 debug 下提示绘制是否溢出，该类仅用于 debug，自定义控件时一般用不到。</li>
<li>RenderObjectWithChildMixin 用于为只有 1 个 child 的 RenderObject 提供 child 管理模型。</li>
<li>ContainerRenderObjectMixin 用于为有多个 child 的 RenderObject 提供 child 管理模型。</li>
</ul>

<h2 id="toc_9">Scrolling Widget</h2>

<p>常用的 List 如下，我们按照它包裹的内容分成了 3 类：</p>

<p><img src="media/16000203391559/16000672865363.jpg" alt=""/></p>

<h3 id="toc_10">ListView</h3>

<pre><code class="language-dart">    ListView.builder(
        itemCount: 50,
        itemBuilder: (context,index) {
          return Container(
            color: ColorUtils.randomColor(),
            height: 50,
          );
        }

</code></pre>

<h3 id="toc_11">CustomScrollView</h3>

<pre><code class="language-dart">CustomScrollView(
      slivers: &lt;Widget&gt;[
        SliverAppBar(...),
        SliverToBoxAdapter(
          child:ListView(...),
        ),
        SliverList(...),
        SliverGrid(...),
      ],
    )
</code></pre>

<h3 id="toc_12">NestedScrollView</h3>

<p>NestedScrollView 其实里面是一个CustomScrollView，它的 headers 是 Sliver 的数组，body是被包裹在 SliverFillRemaining 中的，body 可以接受 Box。</p>

<pre><code class="language-dart">
NestedScrollView(
      headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) {
        return &lt;Widget&gt;[
          SliverAppBar(
            expandedHeight: 100,
            pinned: true,
            title: Text(&quot;Nest&quot;),
          ),
          SliverToBoxAdapter(
            child: Text(&quot;second bar&quot;),
          )
        ];
      },
      body: ListView.builder(
          itemCount: 20,
          itemBuilder: (BuildContext context, int index) {
            return Text(&quot;item: $index&quot;);
          }),
    );
</code></pre>

<h2 id="toc_13">Sliver组件成员</h2>

<p>Flutter 提供了很多的 Sliver 组件，下面我们主要说一下它们的作用是什么：</p>

<h3 id="toc_14"><a href="http://laomengit.com/flutter/widgets/SliverAppBar.html">SliverAppBar</a></h3>

<p>类似于 android 中 CollapsingToolbarLayout，可以根据滑动做伸缩布局，并提供了 actions，bottom 等提高效率的属性。</p>

<p><img src="media/16000203391559/16000674699418.jpg" alt=""/></p>

<h3 id="toc_15"><a href="http://laomengit.com/flutter/widgets/SliverList.html#slivergrid">SliverList / SliverGrid</a></h3>

<p>用法和 ListView / GridView 基本一致。 此外，ListView = SliverList + Scrollable，也就是说 SliverList 不具备处理滑动事件的能力，所以它必须配合 CustomScrollView 来使用。</p>

<h3 id="toc_16"><a href="http://laomengit.com/flutter/widgets/SliverFixedExtentList.html">SliverFixedExtentList</a></h3>

<p>它比 SliverList 多了修饰词 FixedExtent，意思是它的 item 在主轴方向上具有固定的高度/宽度。<br/>
设计它的原因是在 item 高度/宽度全都一样的场景下使用，它的效率比 SliverList 高，因为它不用通过 item 的 layout 过程就可以知道每个 item 的范围。<br/>
在使用的时候必须传入 itemExtent：</p>

<pre><code class="language-dart">SliverFixedExtentList(
  itemExtent: 50.0,
  delegate: SliverChildBuilderDelegate(
    ...
        );
    },
  ),
)
</code></pre>

<h3 id="toc_17"><a href="http://laomengit.com/flutter/widgets/SliverPersistentHeader.html">SliverPersistentHeader</a></h3>

<p><img src="media/16000203391559/16000675333675.jpg" alt=""/></p>

<p>SliverPersistentHeader 是一个可以固定/悬浮的 header，它可以设置在列表的任意位置，显示的内容需要设置 SliverPersistentHeaderDelegate。</p>

<h3 id="toc_18"><a href="http://laomengit.com/flutter/widgets/SliverToBoxAdapter.html">SliverToBoxAdapter</a></h3>

<p>将 BoxWidget 转变为 Sliver：由于 CustomScrollView 只能接受 Sliver 类型的 child，所以很多常用的 Widget 无法直接添加到 CustomScrollView 中，此时只需要将 Widget 用 SliverToBoxAdapter 包裹一下就可以了。<br/>
最常见的使用就是 SliverList 不支持横向模式，但是又无法直接将 ListView 直接添加到 CustomScrollView 中，此时用 SliverToBoxAdapter 包裹一下：</p>

<pre><code class="language-dart">
 CustomScrollView(
      slivers: &lt;Widget&gt;[
        SliverToBoxAdapter(
          child: _buildHorizonScrollView(),
        ),
      ],
    ));

 Widget _buildHorizonScrollView() {
    return Container(
      height: 50,
      child: ListView.builder(
          scrollDirection: Axis.horizontal,
          primary: false,
          shrinkWrap: true,
          itemCount: 15,
          itemBuilder: (context, index) {
            return Container(
              color: ColorUtils.randomColor(),
              width: 50,
              height: 50,
            );
          }),
    );
  } 
</code></pre>

<h3 id="toc_19"><a href="http://laomengit.com/flutter/widgets/SliverPadding.html">SliverPadding</a></h3>

<p>可以用在 CustomScrollView 中的 Padding。<br/>
需要注意的是不要用它来包裹 SliverPersistentHeader ，因为它会使 SliverPersistentHeader 的 pinned 失效，如果 SliverPersistentHeader 非要使用 Padding 效果，可以在 delegate 内部使用 Padding。</p>

<h3 id="toc_20"><a href="http://laomengit.com/flutter/widgets/SafeArea.html">SliverSafeArea</a></h3>

<p>用法和 SafeArea 一致。</p>

<h3 id="toc_21"><a href="http://laomengit.com/flutter/widgets/SliverFillRemaining.html">SliverFillRemaining</a></h3>

<p>可以填充屏幕剩余控件的 Sliver。</p>

<h3 id="toc_22"><a href="http://laomengit.com/flutter/widgets/SliverAnimatedList.html">SliverAnimatedList</a></h3>

<h3 id="toc_23"><a href="http://laomengit.com/flutter/widgets/SliverFillViewport.html">SliverFillViewport</a></h3>

<h3 id="toc_24"><a href="http://laomengit.com/flutter/widgets/SliverLayoutBuilder.html">SliverLayoutBuilder</a></h3>

<h3 id="toc_25"><a href="http://laomengit.com/flutter/widgets/SliverOpacity.html">SliverOpacity</a></h3>

<h3 id="toc_26"><a href="http://laomengit.com/flutter/widgets/SliverPrototypeExtentList.html">SliverPrototypeExtentList</a></h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RecyclerView 源码解析流程]]></title>
    <link href="http://adolph.cc/15952095055711.html"/>
    <updated>2020-07-20T09:45:05+08:00</updated>
    <id>http://adolph.cc/15952095055711.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">主要方法</h2>

<h3 id="toc_1">构造函数</h3>

<ul>
<li>进行View相关配置属性设置，触摸范围、滑动速度等</li>
<li>设置Item动画监听器</li>
<li>初始化AdapterManager，创建AdapterHelper（负责Adapter里的数据集发生变化时的预处理操作）</li>
<li>初始化ChildHelper（负责管理和访问 RecyclerView 的子视图）</li>
<li>如果配置了LayoutManager 则通过反射方法创建它</li>
</ul>

<span id="more"></span><!-- more -->

<pre><code class="language-java">    public RecyclerView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        //设置为滚动容器
        setScrollContainer(true);
        setFocusableInTouchMode(true);

        //View配置相关属性设置
        final ViewConfiguration vc = ViewConfiguration.get(context);
        mTouchSlop = vc.getScaledTouchSlop();
        mScaledHorizontalScrollFactor =
                ViewConfigurationCompat.getScaledHorizontalScrollFactor(vc, context);
        mScaledVerticalScrollFactor =
                ViewConfigurationCompat.getScaledVerticalScrollFactor(vc, context);
        mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
        mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
        setWillNotDraw(getOverScrollMode() == View.OVER_SCROLL_NEVER);

        // 设置Item动画监听器
        mItemAnimator.setListener(mItemAnimatorListener);
        // 设置 AdapterManager
        initAdapterManager();
        // 设置 ChildrenHelper 
        initChildrenHelper();
        initAutofill();
        // If not explicitly specified this view is important for accessibility.
        // 硬件加速相关属性设置
        if (ViewCompat.getImportantForAccessibility(this)
                == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            ViewCompat.setImportantForAccessibility(this,
                    ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        mAccessibilityManager = (AccessibilityManager) getContext()
                .getSystemService(Context.ACCESSIBILITY_SERVICE);
        setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));

        //初始化attrs
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,
                defStyleAttr, 0);
        if (Build.VERSION.SDK_INT &gt;= 29) {
            saveAttributeDataForStyleable(context, R.styleable.RecyclerView, attrs, a,
                    defStyleAttr, 0);
        }
        String layoutManagerName = a.getString(R.styleable.RecyclerView_layoutManager);
        int descendantFocusability = a.getInt(
                R.styleable.RecyclerView_android_descendantFocusability, -1);
        if (descendantFocusability == -1) {
            setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
        }
        mClipToPadding = a.getBoolean(R.styleable.RecyclerView_android_clipToPadding, true);
        mEnableFastScroller = a.getBoolean(R.styleable.RecyclerView_fastScrollEnabled, false);
        if (mEnableFastScroller) {
            StateListDrawable verticalThumbDrawable = (StateListDrawable) a
                    .getDrawable(R.styleable.RecyclerView_fastScrollVerticalThumbDrawable);
            Drawable verticalTrackDrawable = a
                    .getDrawable(R.styleable.RecyclerView_fastScrollVerticalTrackDrawable);
            StateListDrawable horizontalThumbDrawable = (StateListDrawable) a
                    .getDrawable(R.styleable.RecyclerView_fastScrollHorizontalThumbDrawable);
            Drawable horizontalTrackDrawable = a
                    .getDrawable(R.styleable.RecyclerView_fastScrollHorizontalTrackDrawable);
            initFastScroller(verticalThumbDrawable, verticalTrackDrawable,
                    horizontalThumbDrawable, horizontalTrackDrawable);
        }
        a.recycle();

        // 反射方法创建 LayoutManager
        // Create the layoutManager if specified.
        createLayoutManager(context, layoutManagerName, attrs, defStyleAttr, 0);

        boolean nestedScrollingEnabled = true;
        if (Build.VERSION.SDK_INT &gt;= 21) {
            // SDK &gt;=21下 ，nestedScrollingEnabled状态支持变更
            a = context.obtainStyledAttributes(attrs, NESTED_SCROLLING_ATTRS,
                    defStyleAttr, 0);
            if (Build.VERSION.SDK_INT &gt;= 29) {
                saveAttributeDataForStyleable(
                        context, NESTED_SCROLLING_ATTRS, attrs, a, defStyleAttr, 0);
            }
            nestedScrollingEnabled = a.getBoolean(0, true);
            a.recycle();
        }
        // 重置nestedScrollingEnabled状态 SDK 21以下默认true
        setNestedScrollingEnabled(nestedScrollingEnabled);
    }
</code></pre>

<h3 id="toc_2">setLayoutManager</h3>

<ul>
<li>处理重新设置一个新的LayoutManager的一些逻辑</li>
<li>设置this给到LayoutManager，并如果attach了则执行LayoutManger的attach分发实践</li>
<li>更新缓存大小，并请求重新布局</li>
</ul>

<pre><code class="language-java">    public void setLayoutManager(@Nullable LayoutManager layout) {
        //过滤LayoutManager
        if (layout == mLayout) {
            return;
        }
        //停止滚动
        stopScroll();
        
        //mLayout有值，则进行mLayout的解除关联、销毁操作
        if (mLayout != null) {
            // end all running animations
            if (mItemAnimator != null) {
                mItemAnimator.endAnimations();
            }
            mLayout.removeAndRecycleAllViews(mRecycler);
            mLayout.removeAndRecycleScrapInt(mRecycler);
            mRecycler.clear();

            if (mIsAttached) {
                mLayout.dispatchDetachedFromWindow(this, mRecycler);
            }
            mLayout.setRecyclerView(null);
            mLayout = null;
        } else {
            mRecycler.clear();
        }
        // 对有缺陷的item animator一个防御措施
        mChildHelper.removeAllViewsUnfiltered();
        // 重新赋值
        mLayout = layout;
        if (layout != null) {
            //如果layout已经关联一个Recyclerview对象，则抛出异常
            if (layout.mRecyclerView != null) {
                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout
                        + &quot; is already attached to a RecyclerView:&quot;
                        + layout.mRecyclerView.exceptionLabel());
            }
            //LayoutManager关联当前RecyclerView
            mLayout.setRecyclerView(this);
            if (mIsAttached) {
                mLayout.dispatchAttachedToWindow(this);
            }
        }
        
        //重置Recycler的mCachedViews中的ViewHolder，并把其加入RecycledViewPool
        mRecycler.updateViewCacheSize();
        //请求刷新Layout
        requestLayout();
    }
</code></pre>

<h3 id="toc_3">setAdapter</h3>

<ul>
<li>解除frozen状态</li>
<li>设置新的Adapter，并触发一系列监听事件</li>
</ul>

<pre><code class="language-java">    public void setAdapter(@Nullable Adapter adapter) {
        // bail out if layout is frozen
        setLayoutFrozen(false);
        setAdapterInternal(adapter, false, true);
        processDataSetCompletelyChanged(false);
        requestLayout();
    }
</code></pre>

<p>setAdapter和swapAdapter实现方法相同，传的参数不同。<br/>
看看setAdapterInternal方法的传参</p>

<ul>
<li>compatibleWithPrevious: 设置为true则表示新的Adapter和老的Adapter使用相同的ViewHolder和itemType(可以避免缓存失效)</li>
<li>removeAndRecycleViews: 如果为true，将会删除并回收所有现有的视图。如果compatibleWithPrevious为false，则忽略此参数。</li>
</ul>

<pre><code class="language-java">    private void setAdapterInternal(@Nullable Adapter adapter, boolean compatibleWithPrevious,boolean removeAndRecycleViews) {
        //如果原先Adapter不为null，则解除关联
        if (mAdapter != null) {
            mAdapter.unregisterAdapterDataObserver(mObserver);
            mAdapter.onDetachedFromRecyclerView(this);
        }
        //compatibleWithPrevious为false或者removeAndRecycleViewstruetrue则移除所有View
        if (!compatibleWithPrevious || removeAndRecycleViews) {
            removeAndRecycleViews();
        }
        //AdapterHelper类reset
        mAdapterHelper.reset();
        //重新赋值新的Adapter给mAdapter并建立关联
        final Adapter oldAdapter = mAdapter;
        mAdapter = adapter;
        if (adapter != null) {
            adapter.registerAdapterDataObserver(mObserver);
            adapter.onAttachedToRecyclerView(this);
        }
        //LayoutManager进行Adapter更换
        if (mLayout != null) {
            mLayout.onAdapterChanged(oldAdapter, mAdapter);
        }
        //Recycler进行Adapter更换，并传入compatibleWithPrevious
        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);
        mState.mStructureChanged = true;
    }
</code></pre>

<p><code>processDataSetCompletelyChanged</code>方法 -&gt; <code>markKnownViewsInvalid</code>(将所有已知ViewHolder标志为无效) -&gt; <code>markItemDecorInsetsDirty</code>(将当前的ChildView以及Recycler中的ChildView的mInsetsDirty设置为true)、<code>mRecycler.markKnownViewsInvalid</code>(从Recycler的mCachedViews中的ViewHolder标志位无效) -&gt; <code>recycleAndClearCachedViews</code>(从mCachedViews中的ViewHolder移除添加进RecycledViewPool)</p>

<h2 id="toc_4">扩展方法</h2>

<h3 id="toc_5">addOnChildAttachStateChangeListener、removeOnChildAttachStateChangeListener、clearOnChildAttachStateChangeListeners</h3>

<p>监听子View的添加和释放，官方推荐使用过重的View资源可以在这个监听器里进行释放</p>

<pre><code class="language-java">    public interface OnChildAttachStateChangeListener {
        void onChildViewAttachedToWindow(@NonNull View view);

        void onChildViewDetachedFromWindow(@NonNull View view);
    }
</code></pre>

<h3 id="toc_6">setOnFlingListener、getOnFlingListener</h3>

<p>监听RecyclerView的快速滑动的事件，可以获取横向滑动或者纵向滑动的速度，并且可以进行拦截处理。</p>

<pre><code class="language-java">    public abstract static class OnFlingListener {
        public abstract boolean onFling(int velocityX, int velocityY);
    }
</code></pre>

<h3 id="toc_7">setRecycledViewPool(@Nullable RecycledViewPool pool)、getRecycledViewPool</h3>

<p>如果有多个相同数据类型的Adapter，可以设置RecycledViewPool共享池。</p>

<h3 id="toc_8">setViewCacheExtension(@Nullable ViewCacheExtension extension)</h3>

<p>自定义ViewCacheExtension</p>

<h3 id="toc_9">setItemViewCacheSize(int size)</h3>

<p>设置加入RecycledViewPool之前可缓存的数量</p>

<h3 id="toc_10">addItemDecoration(@NonNull ItemDecoration decor, int index)、addItemDecoration(@NonNull ItemDecoration decor)、getItemDecorationAt(int index)、getItemDecorationCount()、removeItemDecorationAt(int index)、removeItemDecoration(@NonNull ItemDecoration decor)</h3>

<p>添加ItemDecoration， ItemDecoration有层级关系， index值会影响ItemDecoration所在层级。index为-1，则添加到最后。</p>

<h3 id="toc_11">setChildDrawingOrderCallback(@Nullable ChildDrawingOrderCallback childDrawingOrderCallback)</h3>

<p>可用来更改RecyclerView子项的绘制顺序</p>

<pre><code class="language-java">    public interface ChildDrawingOrderCallback {
        int onGetChildDrawingOrder(int childCount, int i);
    }
</code></pre>

<h3 id="toc_12">addOnScrollListener(@NonNull OnScrollListener listener)、removeOnScrollListener(@NonNull OnScrollListener listener)、clearOnScrollListeners()</h3>

<p>用来监听RecyclerView的滚动状态和滚动距离</p>

<pre><code class="language-java">    public abstract static class OnScrollListener {
        
        public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState){}

        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy){}
    }
</code></pre>

<h3 id="toc_13">scrollToPosition(int position)</h3>

<p>滚动到指定位置</p>

<h3 id="toc_14">smoothScrollToPosition(int position)</h3>

<p>带动画滚动到指定位置</p>

<h3 id="toc_15">setEdgeEffectFactory(@NonNull EdgeEffectFactory edgeEffectFactory)、getEdgeEffectFactory()</h3>

<p>自定义边界UI</p>

<h3 id="toc_16">addOnItemTouchListener(@NonNull OnItemTouchListener listener)、removeOnItemTouchListener(@NonNull OnItemTouchListener listener)</h3>

<p>处理Item触摸事件</p>

<pre><code class="language-java">public interface OnItemTouchListener {
    
        boolean onInterceptTouchEvent(@NonNull RecyclerView rv, @NonNull MotionEvent e);

        void onTouchEvent(@NonNull RecyclerView rv, @NonNull MotionEvent e);

        void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept);
    }
</code></pre>

<h2 id="toc_17">View绘制三大流程</h2>

<h3 id="toc_18">measure</h3>

<pre><code class="language-java">    @Override
    protected void onMeasure(int widthSpec, int heightSpec) {
        //第一种情况当前LayoutManager为null
        if (mLayout == null) {
            defaultOnMeasure(widthSpec, heightSpec);
            return;
        }
        //第二种情况LayoutManager开启了自动测量
        if (mLayout.isAutoMeasureEnabled()) {
            final int widthMode = MeasureSpec.getMode(widthSpec);
            final int heightMode = MeasureSpec.getMode(heightSpec);

            //调用LayoutManager的onMeasure方法进行测量。
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);

            final boolean measureSpecModeIsExactly =
                    widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;
            if (measureSpecModeIsExactly || mAdapter == null) {
                return;
            }

            //mLayoutStep为State.STEP_START执行dispatchLayoutStep1
            if (mState.mLayoutStep == State.STEP_START) {
                dispatchLayoutStep1();
            }
            
            mLayout.setMeasureSpecs(widthSpec, heightSpec);
            mState.mIsMeasuring = true;
            //执行dispatchLayoutStep2
            dispatchLayoutStep2();

            // now we can get the width and height from the children.
            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);

            // if RecyclerView has non-exact width and height and if there is at least one child
            // which also has non-exact width &amp; height, we have to re-measure.
            if (mLayout.shouldMeasureTwice()) {
                mLayout.setMeasureSpecs(
                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
                mState.mIsMeasuring = true;
                dispatchLayoutStep2();
                // now we can get the width and height from the children.
                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);
            }
        } else {
            //第三种情况 LayoutManager没有开启自动测量
            if (mHasFixedSize) {
                mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
                return;
            }
            // custom onMeasure
            if (mAdapterUpdateDuringMeasure) {
                startInterceptRequestLayout();
                onEnterLayoutOrScroll();
                processAdapterUpdatesAndSetAnimationFlags();
                onExitLayoutOrScroll();

                if (mState.mRunPredictiveAnimations) {
                    mState.mInPreLayout = true;
                } else {
                    // consume remaining updates to provide a consistent state with the layout pass.
                    mAdapterHelper.consumeUpdatesInOnePass();
                    mState.mInPreLayout = false;
                }
                mAdapterUpdateDuringMeasure = false;
                stopInterceptRequestLayout(false);
            } else if (mState.mRunPredictiveAnimations) {
                // If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true:
                // this means there is already an onMeasure() call performed to handle the pending
                // adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout
                // with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time
                // because getViewForPosition() will crash when LM uses a child to measure.
                setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());
                return;
            }

            if (mAdapter != null) {
                mState.mItemCount = mAdapter.getItemCount();
            } else {
                mState.mItemCount = 0;
            }
            startInterceptRequestLayout();
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);
            stopInterceptRequestLayout(false);
            mState.mInPreLayout = false; // clear
        }
    }
</code></pre>

<h4 id="toc_19">第一种情况</h4>

<p>直接调用defaultOnMeasure方法</p>

<pre><code class="language-java">    void defaultOnMeasure(int widthSpec, int heightSpec) {
        // calling LayoutManager here is not pretty but that API is already public and it is better
        // than creating another method since this is internal.
        final int width = LayoutManager.chooseSize(widthSpec,
                getPaddingLeft() + getPaddingRight(),
                ViewCompat.getMinimumWidth(this));
        final int height = LayoutManager.chooseSize(heightSpec,
                getPaddingTop() + getPaddingBottom(),
                ViewCompat.getMinimumHeight(this));

        setMeasuredDimension(width, height);
    }
</code></pre>

<p>直接调用LayoutManager.chooseSize来获取宽高，然后直接setMeasuredDimension</p>

<pre><code class="language-java">        //通过RecyclerView的测量mode来获取不同的值
        public static int chooseSize(int spec, int desired, int min) {
            final int mode = View.MeasureSpec.getMode(spec);
            final int size = View.MeasureSpec.getSize(spec);
            switch (mode) {
                case View.MeasureSpec.EXACTLY:
                    return size;
                case View.MeasureSpec.AT_MOST:
                    return Math.min(size, Math.max(desired, min));
                case View.MeasureSpec.UNSPECIFIED:
                default:
                    return Math.max(desired, min);
            }
        }
</code></pre>

<h4 id="toc_20">第二种情况 当LayoutManager开启了自动测量</h4>

<table>
<thead>
<tr>
<th style="text-align: left">取值</th>
<th style="text-align: left">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">State.STEP_START</td>
<td style="text-align: left">mState.mLayoutStep的默认值，这种情况下，表示RecyclerView还未经历dispatchLayoutStep1，因为dispatchLayoutStep1调用之后mState.mLayoutStep会变为State.STEP_LAYOUT。</td>
</tr>
<tr>
<td style="text-align: left">State.STEP_LAYOUT</td>
<td style="text-align: left">当mState.mLayoutStep为State.STEP_LAYOUT时，表示此时处于layout阶段，这个阶段会调用dispatchLayoutStep2方法layout RecyclerView的children。调用dispatchLayoutStep2方法之后，此时mState.mLayoutStep变为了State.STEP_ANIMATIONS。</td>
</tr>
<tr>
<td style="text-align: left">State.STEP_ANIMATIONS</td>
<td style="text-align: left">当mState.mLayoutStep为State.STEP_ANIMATIONS时，表示RecyclerView处于第三个阶段，也就是执行动画的阶段，也就是调用dispatchLayoutStep3方法。当dispatchLayoutStep3方法执行完毕之后，mState.mLayoutStep又变为了State.STEP_START。</td>
</tr>
</tbody>
</table>

<h5 id="toc_21">dispatchLayoutStep1</h5>

<ul>
<li>第一步layout方法</li>
<li>处理adapter变更</li>
<li>确定需要执行的动画</li>
<li>针对当前的Views进行信息缓存</li>
<li>如有必要，则进行预布局并缓存信息</li>
</ul>

<pre><code class="language-java">    private void dispatchLayoutStep1() {
        mState.assertLayoutStep(State.STEP_START);
        fillRemainingScrollValues(mState);
        mState.mIsMeasuring = false;
        startInterceptRequestLayout();
        mViewInfoStore.clear();
        onEnterLayoutOrScroll();
        processAdapterUpdatesAndSetAnimationFlags();
        saveFocusInfo();
        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;
        mItemsAddedOrRemoved = mItemsChanged = false;
        mState.mInPreLayout = mState.mRunPredictiveAnimations;
        mState.mItemCount = mAdapter.getItemCount();
        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);

        if (mState.mRunSimpleAnimations) {
            // Step 0: Find out where all non-removed items are, pre-layout
            int count = mChildHelper.getChildCount();
            for (int i = 0; i &lt; count; ++i) {
                final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
                if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) {
                    continue;
                }
                final ItemHolderInfo animationInfo = mItemAnimator
                        .recordPreLayoutInformation(mState, holder,
                                ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),
                                holder.getUnmodifiedPayloads());
                mViewInfoStore.addToPreLayout(holder, animationInfo);
                if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()
                        &amp;&amp; !holder.shouldIgnore() &amp;&amp; !holder.isInvalid()) {
                    long key = getChangedHolderKey(holder);
                    // This is NOT the only place where a ViewHolder is added to old change holders
                    // list. There is another case where:
                    //    * A VH is currently hidden but not deleted
                    //    * The hidden item is changed in the adapter
                    //    * Layout manager decides to layout the item in the pre-Layout pass (step1)
                    // When this case is detected, RV will un-hide that view and add to the old
                    // change holders list.
                    mViewInfoStore.addToOldChangeHolders(key, holder);
                }
            }
        }
        if (mState.mRunPredictiveAnimations) {
            // Step 1: run prelayout: This will use the old positions of items. The layout manager
            // is expected to layout everything, even removed items (though not to add removed
            // items back to the container). This gives the pre-layout position of APPEARING views
            // which come into existence as part of the real layout.

            // Save old positions so that LayoutManager can run its mapping logic.
            saveOldPositions();
            final boolean didStructureChange = mState.mStructureChanged;
            mState.mStructureChanged = false;
            // temporarily disable flag because we are asking for previous layout
            mLayout.onLayoutChildren(mRecycler, mState);
            mState.mStructureChanged = didStructureChange;

            for (int i = 0; i &lt; mChildHelper.getChildCount(); ++i) {
                final View child = mChildHelper.getChildAt(i);
                final ViewHolder viewHolder = getChildViewHolderInt(child);
                if (viewHolder.shouldIgnore()) {
                    continue;
                }
                if (!mViewInfoStore.isInPreLayout(viewHolder)) {
                    int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder);
                    boolean wasHidden = viewHolder
                            .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                    if (!wasHidden) {
                        flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                    }
                    final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation(
                            mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads());
                    if (wasHidden) {
                        recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo);
                    } else {
                        mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo);
                    }
                }
            }
            // we don&#39;t process disappearing list because they may re-appear in post layout pass.
            clearOldPositions();
        } else {
            clearOldPositions();
        }
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(false);
        mState.mLayoutStep = State.STEP_LAYOUT;
    }
</code></pre>

<pre><code class="language-java">    private void processAdapterUpdatesAndSetAnimationFlags() {
        if (mDataSetHasChangedAfterLayout) {
            // Processing these items have no value since data set changed unexpectedly.
            // Instead, we just reset it.
            mAdapterHelper.reset();
            if (mDispatchItemsChangedEvent) {
                mLayout.onItemsChanged(this);
            }
        }
        // simple animations are a subset of advanced animations (which will cause a
        // pre-layout step)
        // If layout supports predictive animations, pre-process to decide if we want to run them
        if (predictiveItemAnimationsEnabled()) {
            mAdapterHelper.preProcess();
        } else {
            mAdapterHelper.consumeUpdatesInOnePass();
        }
        boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged;
        //判断是否是第一次加载布局
        mState.mRunSimpleAnimations = mFirstLayoutComplete
                &amp;&amp; mItemAnimator != null
                &amp;&amp; (mDataSetHasChangedAfterLayout
                || animationTypeSupported
                || mLayout.mRequestedSimpleAnimations)
                &amp;&amp; (!mDataSetHasChangedAfterLayout
                || mAdapter.hasStableIds());
        mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations
                &amp;&amp; animationTypeSupported
                &amp;&amp; !mDataSetHasChangedAfterLayout
                &amp;&amp; predictiveItemAnimationsEnabled();
    }
</code></pre>

<h5 id="toc_22">dispatchLayoutStep2</h5>

<pre><code class="language-java">    private void dispatchLayoutStep2() {
        startInterceptRequestLayout();
        onEnterLayoutOrScroll();
        mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);
        mAdapterHelper.consumeUpdatesInOnePass();
        mState.mItemCount = mAdapter.getItemCount();
        mState.mDeletedInvisibleItemCountSincePreviousLayout = 0;

        mState.mInPreLayout = false;
        //调用LayoutManager的onLayoutChildren对children进行测量和布局
        mLayout.onLayoutChildren(mRecycler, mState);

        mState.mStructureChanged = false;
        mPendingSavedState = null;

        // onLayoutChildren may have caused client code to disable item animations; re-check
        mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null;
        //设置mLayoutStep为State.STEP_ANIMATIONS
        mState.mLayoutStep = State.STEP_ANIMATIONS;
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(false);
    }
</code></pre>

<h4 id="toc_23">没有开启自动测量</h4>

<ul>
<li>如果mHasFixedSize为true(也就是调用了setHasFixedSize方法)，将直接调用LayoutManager的onMeasure方法进行测量。</li>
<li>如果mHasFixedSize为false，同时此时如果有数据更新，先处理数据更新的事务，然后调用LayoutManager的onMeasure方法进行测量</li>
</ul>

<h3 id="toc_24">layout</h3>

<pre><code class="language-java">    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);
        dispatchLayout();
        TraceCompat.endSection();
        mFirstLayoutComplete = true;
    }
</code></pre>

<h4 id="toc_25">dispatchLayout</h4>

<p>这个方法保证RecyclerView必须经历三个过程--dispatchLayoutStep1、dispatchLayoutStep2、dispatchLayoutStep3。</p>

<pre><code class="language-java">    void dispatchLayout() {
        //这边如果mAdapter为null，就不进行展示了
        if (mAdapter == null) {
            Log.e(TAG, &quot;No adapter attached; skipping layout&quot;);
            // leave the state in START
            return;
        }
        //这边如果mLayout为null，就不进行展示了
        if (mLayout == null) {
            Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;);
            // leave the state in START
            return;
        }
        //更改mState.mIsMeasuring
        mState.mIsMeasuring = false;
        //如果mState.mLayoutStep为State.STEP_START再次调用dispatchLayoutStep1和dispatchLayoutStep2
        if (mState.mLayoutStep == State.STEP_START) {
            dispatchLayoutStep1();
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()
                || mLayout.getHeight() != getHeight()) {
            // First 2 steps are done in onMeasure but looks like we have to run again due to
            // changed size.
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else {
            // always make sure we sync them (to ensure mode is exact)
            mLayout.setExactMeasureSpecsFrom(this);
        }
        //执行dispatchLayoutStep3
        dispatchLayoutStep3();
    }
</code></pre>

<h4 id="toc_26">dispatchLayoutStep3</h4>

<p>这是最后一步</p>

<pre><code class="language-java">    private void dispatchLayoutStep3() {
        mState.assertLayoutStep(State.STEP_ANIMATIONS);
        startInterceptRequestLayout();
        onEnterLayoutOrScroll();
        //重新将mState.mLayoutStep的值赋值为State.STEP_START，保证下次dispatchLayout继续走3步
        mState.mLayoutStep = State.STEP_START;
        if (mState.mRunSimpleAnimations) {
            // Step 3: Find out where things are now, and process change animations.
            // traverse list in reverse because we may call animateChange in the loop which may
            // remove the target view holder.
            for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) {
                ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
                if (holder.shouldIgnore()) {
                    continue;
                }
                long key = getChangedHolderKey(holder);
                final ItemHolderInfo animationInfo = mItemAnimator
                        .recordPostLayoutInformation(mState, holder);
                ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key);
                if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) {
                    // run a change animation

                    // If an Item is CHANGED but the updated version is disappearing, it creates
                    // a conflicting case.
                    // Since a view that is marked as disappearing is likely to be going out of
                    // bounds, we run a change animation. Both views will be cleaned automatically
                    // once their animations finish.
                    // On the other hand, if it is the same view holder instance, we run a
                    // disappearing animation instead because we are not going to rebind the updated
                    // VH unless it is enforced by the layout manager.
                    final boolean oldDisappearing = mViewInfoStore.isDisappearing(
                            oldChangeViewHolder);
                    final boolean newDisappearing = mViewInfoStore.isDisappearing(holder);
                    if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) {
                        // run disappear animation instead of change
                        mViewInfoStore.addToPostLayout(holder, animationInfo);
                    } else {
                        //ItemHolderInfo中保存ItemView的位置信息
                        final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout(
                                oldChangeViewHolder);
                        // we add and remove so that any post info is merged.
                        mViewInfoStore.addToPostLayout(holder, animationInfo);
                        ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder);
                        if (preInfo == null) {
                            handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);
                        } else {
                            animateChange(oldChangeViewHolder, holder, preInfo, postInfo,
                                    oldDisappearing, newDisappearing);
                        }
                    }
                } else {
                    mViewInfoStore.addToPostLayout(holder, animationInfo);
                }
            }

            // 执行动画
            // Step 4: Process view info lists and trigger animations
            mViewInfoStore.process(mViewInfoProcessCallback);
        }

        mLayout.removeAndRecycleScrapInt(mRecycler);
        mState.mPreviousLayoutItemCount = mState.mItemCount;
        mDataSetHasChangedAfterLayout = false;
        mDispatchItemsChangedEvent = false;
        mState.mRunSimpleAnimations = false;

        mState.mRunPredictiveAnimations = false;
        mLayout.mRequestedSimpleAnimations = false;
        if (mRecycler.mChangedScrap != null) {
            mRecycler.mChangedScrap.clear();
        }
        if (mLayout.mPrefetchMaxObservedInInitialPrefetch) {
            // Initial prefetch has expanded cache, so reset until next prefetch.
            // This prevents initial prefetches from expanding the cache permanently.
            mLayout.mPrefetchMaxCountObserved = 0;
            mLayout.mPrefetchMaxObservedInInitialPrefetch = false;
            mRecycler.updateViewCacheSize();
        }

        mLayout.onLayoutCompleted(mState);
        onExitLayoutOrScroll();
        stopInterceptRequestLayout(false);
        mViewInfoStore.clear();
        if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) {
            dispatchOnScrolled(0, 0);
        }
        recoverFocusFromState();
        resetFocusInfo();
    }
</code></pre>

<p>RecyclerView跟其他ViewGroup不同的地方在于，如果开启了自动测量，在measure阶段，已经将Children布局完成了；如果没有开启自动测量，则在layout阶段才布局Children</p>

<h3 id="toc_27">在LayoutManager中的绘制</h3>

<h4 id="toc_28">LinearLayoutManager#onLayoutChildren</h4>

<pre><code class="language-java">@Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // ...
        // 找到锚点（具体过程等到分析 layout 时再说）
        // （1）
        detachAndScrapAttachedViews(recycler);
        
        if (mAnchorInfo.mLayoutFromEnd) {
            // ...
        } else {
            // （2）
            fill(recycler, mLayoutState, state, false);
            // ...
        }   
        // ...
    }
</code></pre>

<p>首先看（1）处，detachAndScrapAttachedViews 方法会根据情况将子 View 回收到相应缓存，具体过程之后再看，由于现在是第一次 layout，RecyclerView 中没有子 View，所以现在该方法没啥用。</p>

<p>接下来看（2）处，这里的 fill 方法比较重要，它的作用是填充布局。看一下该方法</p>

<h4 id="toc_29">LinearLayoutManager#fill</h4>

<pre><code class="language-java">    int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {

        // 进行 layout 时 layoutState.mScrollingOffset 的值被设置为
        // LayoutState.SCROLLING_OFFSET_NaN，不会进入此 if 块
        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            // ...
            recycleByLayoutState(recycler, layoutState);
        }
        
        // 需要填充的空间
        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
        // 还有需要填充的空间并且 item 数未满
        while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) {
            // ...
            
            // （1）
            layoutChunk(recycler, state, layoutState, layoutChunkResult);

            // 计算剩余空间

            // 同上，在 layout 时不会进入 if 块中
            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
                // ...
                recycleByLayoutState(recycler, layoutState);
            }
            
            // ...
        }
    }
</code></pre>

<h4 id="toc_30">LinearLayoutManager#layoutChunk</h4>

<pre><code class="language-java">    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
            LayoutState layoutState, LayoutChunkResult result) {
        // （1）
        View view = layoutState.next(recycler);

        // ...
        
        // 默认情况下，layoutState.mScrapList 等于 null
        if (layoutState.mScrapList == null) {
            if (mShouldReverseLayout == (layoutState.mLayoutDirection
                    == LayoutState.LAYOUT_START)) {
                // （2）
                addView(view);
            } else {
                addView(view, 0);
            }
        } else {
            // ...
        }
    }
</code></pre>

<p>（2）处的 addView 方法就不多说了，该方法将得到的子 View 添加到 RecyclerView 中。主要看（1）处，看看子 View 从何而来</p>

<pre><code class="language-java">    View next(RecyclerView.Recycler recycler) {
        // ...
        
        final View view = recycler.getViewForPosition(mCurrentPosition);

        return view;
    }
</code></pre>

<p>这个方法是不是很熟悉呢？没错，它就是之前分析的 Recycler 的 getViewForPosition 方法。</p>

<p>不过由于现在没有任何缓存，所以第一次 layout 的时候是通过 Adapter 的 createViewHolder 来创建子 View的，并且没有添加任何缓存。</p>

<h3 id="toc_31">draw</h3>

<ul>
<li>调用super.draw方法。这里主要做了两件事：
<ul>
<li>将Children的绘制分发给ViewGroup;</li>
<li>将分割线的绘制分发给ItemDecoration。</li>
</ul></li>
<li>如果需要的话，调用ItemDecoration的onDrawOver方法。通过这个方法，我们在每个ItemView上面画上很多东西。</li>
<li>如果RecyclerView调用了setClipToPadding,会实现一种特殊的滑动效果--每个ItemView可以滑动到padding区域。</li>
</ul>

<pre><code class="language-java">    @Override
    public void draw(Canvas c) {
        //第一步
        super.draw(c);

        //第二步
        final int count = mItemDecorations.size();
        for (int i = 0; i &lt; count; i++) {
            mItemDecorations.get(i).onDrawOver(c, this, mState);
        }
        // 第三步
        // TODO If padding is not 0 and clipChildrenToPadding is false, to draw glows properly, we
        // need find children closest to edges. Not sure if it is worth the effort.
        boolean needsInvalidate = false;
        if (mLeftGlow != null &amp;&amp; !mLeftGlow.isFinished()) {
            final int restore = c.save();
            final int padding = mClipToPadding ? getPaddingBottom() : 0;
            c.rotate(270);
            c.translate(-getHeight() + padding, 0);
            needsInvalidate = mLeftGlow != null &amp;&amp; mLeftGlow.draw(c);
            c.restoreToCount(restore);
        }
        if (mTopGlow != null &amp;&amp; !mTopGlow.isFinished()) {
            final int restore = c.save();
            if (mClipToPadding) {
                c.translate(getPaddingLeft(), getPaddingTop());
            }
            needsInvalidate |= mTopGlow != null &amp;&amp; mTopGlow.draw(c);
            c.restoreToCount(restore);
        }
        if (mRightGlow != null &amp;&amp; !mRightGlow.isFinished()) {
            final int restore = c.save();
            final int width = getWidth();
            final int padding = mClipToPadding ? getPaddingTop() : 0;
            c.rotate(90);
            c.translate(-padding, -width);
            needsInvalidate |= mRightGlow != null &amp;&amp; mRightGlow.draw(c);
            c.restoreToCount(restore);
        }
        if (mBottomGlow != null &amp;&amp; !mBottomGlow.isFinished()) {
            final int restore = c.save();
            c.rotate(180);
            if (mClipToPadding) {
                c.translate(-getWidth() + getPaddingRight(), -getHeight() + getPaddingBottom());
            } else {
                c.translate(-getWidth(), -getHeight());
            }
            needsInvalidate |= mBottomGlow != null &amp;&amp; mBottomGlow.draw(c);
            c.restoreToCount(restore);
        }

        // If some views are animating, ItemDecorators are likely to move/change with them.
        // Invalidate RecyclerView to re-draw decorators. This is still efficient because children&#39;s
        // display lists are not invalidated.
        if (!needsInvalidate &amp;&amp; mItemAnimator != null &amp;&amp; mItemDecorations.size() &gt; 0
                &amp;&amp; mItemAnimator.isRunning()) {
            needsInvalidate = true;
        }

        if (needsInvalidate) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }
</code></pre>

<p>关于Children的绘制和ItemDecoration的绘制，是在onDraw方法里面</p>

<pre><code class="language-java">    @Override
    public void onDraw(Canvas c) {
        super.onDraw(c);

        final int count = mItemDecorations.size();
        for (int i = 0; i &lt; count; i++) {
            mItemDecorations.get(i).onDraw(c, this, mState);
        }
    }
</code></pre>

<h2 id="toc_32">缓存机制</h2>

<h3 id="toc_33">四级缓存</h3>

<table>
<thead>
<tr>
<th style="text-align: left">缓存级别</th>
<th style="text-align: left">实际变量</th>
<th style="text-align: left">含义</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">一级缓存</td>
<td style="text-align: left">mAttachedScrap和mChangedScrap</td>
<td style="text-align: left">这是优先级最高的缓存，RecyclerView在获取ViewHolder时,优先会到这两个缓存来找。其中mAttachedScrap存储的是当前还在屏幕中的ViewHolder，mChangedScrap存储的是数据被更新的ViewHolder,比如说调用了Adapter的notifyItemChanged方法。</td>
</tr>
<tr>
<td style="text-align: left">二级缓存</td>
<td style="text-align: left">mCachedViews</td>
<td style="text-align: left">默认大小为2，通常用来存储预取的ViewHolder，同时在回收ViewHolder时，也会可能存储一部分的ViewHolder，这部分的ViewHolder通常来说，意义跟一级缓存差不多。</td>
</tr>
<tr>
<td style="text-align: left">三级缓存</td>
<td style="text-align: left">ViewCacheExtension</td>
<td style="text-align: left">自定义缓存,通常用不到，在本文中先忽略</td>
</tr>
<tr>
<td style="text-align: left">四级缓存</td>
<td style="text-align: left">RecyclerViewPool</td>
<td style="text-align: left">根据ViewType来缓存ViewHolder，每个ViewType的数组大小为5，可以动态的改变。</td>
</tr>
</tbody>
</table>

<h3 id="toc_34">ViewHolder的几个状态值</h3>

<table>
<thead>
<tr>
<th style="text-align: left">方法名</th>
<th style="text-align: left">对应的Flag</th>
<th style="text-align: left">含义或者状态设置的时机</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">isInvalid</td>
<td style="text-align: left">FLAG_INVALID</td>
<td style="text-align: left">表示当前ViewHolder是否已经失效。通常来说，在3种情况下会出现这种情况：1.调用了Adapter的notifyDataSetChanged方法；2. 手动调用RecyclerView的invalidateItemDecorations方法；3. 调用RecyclerView的setAdapter方法或者swapAdapter方法。</td>
</tr>
<tr>
<td style="text-align: left">isRemoved</td>
<td style="text-align: left">FLAG_REMOVED</td>
<td style="text-align: left">表示当前的ViewHolder是否被移除。通常来说，数据源被移除了部分数据，然后调用Adapter的notifyItemRemoved方法。</td>
</tr>
<tr>
<td style="text-align: left">isBound</td>
<td style="text-align: left">FLAG_BOUND</td>
<td style="text-align: left">表示当前ViewHolder是否已经调用了onBindViewHolder。</td>
</tr>
<tr>
<td style="text-align: left">isTmpDetached</td>
<td style="text-align: left">FLAG_TMP_DETACHED</td>
<td style="text-align: left">表示当前的ItemView是否从RecyclerView(即父View)detach掉。通常来说有两种情况下会出现这种情况：1.手动了RecyclerView的detachView相关方法；2. 在从mHideViews里面获取ViewHolder,会先detach掉这个ViewHolder关联的ItemView。这里又多出来一个mHideViews，待会我会详细的解释它是什么。</td>
</tr>
<tr>
<td style="text-align: left">isScrap</td>
<td style="text-align: left">无Flag来表示该状态，用mScrapContainer是否为null来判断</td>
<td style="text-align: left">表示是否在mAttachedScrap或者mChangedScrap数组里面，进而表示当前ViewHolder是否被废弃。</td>
</tr>
<tr>
<td style="text-align: left">isUpdated</td>
<td style="text-align: left">FLAG_UPDATE</td>
<td style="text-align: left">表示当前ViewHolder是否已经更新。通常来说，在3种情况下会出现情况：1.isInvalid方法存在的三种情况；2.调用了Adapter的onBindViewHolder方法；3. 调用了Adapter的notifyItemChanged方法</td>
</tr>
</tbody>
</table>

<h3 id="toc_35">mChangedScrap和mAttachedScrap的区别</h3>

<p>首先，如果调用了Adapter的notifyItemChanged方法，会重新回调到LayoutManager的onLayoutChildren方法里面,而在onLayoutChildren方法里面，会将屏幕上所有的ViewHolder回收到mAttachedScrap和mChangedScrap。这个过程就是将ViewHolder分别放到mAttachedScrap和mChangedScrap，而什么条件下放在mAttachedScrap，什么条件放在mChangedScrap，这个就是他们俩的区别。</p>

<pre><code class="language-java">    void scrapView(View view) {
            final ViewHolder holder = getChildViewHolderInt(view);
            //1.被同时标记为remove或invalid；2.完全没有改变的ViewHolder。这里还有第三个判断，这个跟RecyclerView的ItemAnimator有关，如果ItemAnimator为空或者ItemAnimator的canReuseUpdatedViewHolder方法为true，也会放入到mAttachedScrap。
            if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
                    || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
                if (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) {
                    throw new IllegalArgumentException(&quot;Called scrap view with an invalid view.&quot;
                            + &quot; Invalid views cannot be reused from scrap, they should rebound from&quot;
                            + &quot; recycler pool.&quot; + exceptionLabel());
                }
                holder.setScrapContainer(this, false);
                mAttachedScrap.add(holder);
            } else {
                //ViewHolder的isUpdated方法返回为true时，会放入到mChangedScrap里面去。
                if (mChangedScrap == null) {
                    mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
                }
                holder.setScrapContainer(this, true);
                mChangedScrap.add(holder);
            }
        }
</code></pre>

<h3 id="toc_36">复用</h3>

<p>RecyclerView对ViewHolder的复用，我们得从LayoutState的next方法开始。LayoutManager在布局itemView时，需要获取一个ViewHolder对象，就是通过这个方法来获取，具体的复用逻辑也是在这个方面开始调用的。</p>

<pre><code class="language-java">    View next(RecyclerView.Recycler recycler) {
        final View view = recycler.getViewForPosition(mCurrentPosition);
        mCurrentPosition += mItemDirection;
        return view;
    }
</code></pre>

<p>再来看Recycler的getViewForPosition</p>

<pre><code class="language-java">    View getViewForPosition(int position, boolean dryRun) {
        return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;
    }
</code></pre>

<p>最后走到tryGetViewHolderForPositionByDeadline这个方法，RecyclerView真正复用的核心就在这个方法</p>

<pre><code class="language-java">        @Nullable
        ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
            //position和mState.getItemCount对不上就会抛出异常
            if (position &lt; 0 || position &gt;= mState.getItemCount()) {
                throw new IndexOutOfBoundsException(&quot;Invalid item position &quot; + position
                        + &quot;(&quot; + position + &quot;). Item count:&quot; + mState.getItemCount()
                        + exceptionLabel());
            }
            boolean fromScrapOrHiddenOrCache = false;
            ViewHolder holder = null;
            // 0) If there is a changed scrap, try to find from there
            //如果当前是预布局阶段，那么就从mChangedScrap里面去获取ViewHolder
            if (mState.isPreLayout()) {
                holder = getChangedScrapViewForPosition(position);
                fromScrapOrHiddenOrCache = holder != null;
            }
            // 1) Find by position from scrap/hidden list/cache
            //如果holder为null，分别从mAttachedScrap、 mHiddenViews、mCachedViews获取ViewHolder
            if (holder == null) {
                holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
                if (holder != null) {
                    //检查ViewHolder是否有效
                    if (!validateViewHolderForOffsetPosition(holder)) {
                        // recycle holder (and unscrap if relevant) since it can&#39;t be used
                        //做一些清理操作，然后重新放入到缓存里面
                        if (!dryRun) {
                            // we would like to recycle this but need to make sure it is not used by
                            // animation logic etc.
                            holder.addFlags(ViewHolder.FLAG_INVALID);
                            if (holder.isScrap()) {
                                removeDetachedView(holder.itemView, false);
                                holder.unScrap();
                            } else if (holder.wasReturnedFromScrap()) {
                                holder.clearReturnedFromScrapFlag();
                            }
                            //做回收操作
                            recycleViewHolderInternal(holder);
                        }
                        holder = null;
                    } else {
                        fromScrapOrHiddenOrCache = true;
                    }
                }
            }
            
            //1. 如果Adapter的hasStableIds方法返回为true，优先通过ViewType和id两个条件来寻找。如果没有找到，那么就进行第2步。
            //2. 如果Adapter的hasStableIds方法返回为false，在这种情况下，首先会在ViewCacheExtension里面找，如果还没有找到的话，最后会在RecyclerViewPool里面来获取ViewHolder。
            //3. 如果以上的复用步骤都没有找到合适的ViewHolder，最后就会调用Adapter的onCreateViewHolder方法来创建一个新的ViewHolder。
            if (holder == null) {
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                //校验offsetPosition
                if (offsetPosition &lt; 0 || offsetPosition &gt;= mAdapter.getItemCount()) {
                    throw new IndexOutOfBoundsException(&quot;Inconsistency detected. Invalid item &quot;
                            + &quot;position &quot; + position + &quot;(offset:&quot; + offsetPosition + &quot;).&quot;
                            + &quot;state:&quot; + mState.getItemCount() + exceptionLabel());
                }

                final int type = mAdapter.getItemViewType(offsetPosition);
                // 2) Find from scrap/cache via stable ids, if exists
                //通过ViewType和Id来查找
                if (mAdapter.hasStableIds()) {
                    //分别从mAttachedScrap和mCachedViews数组寻找合适的ViewHolder
                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                            type, dryRun);
                    if (holder != null) {
                        // update position
                        holder.mPosition = offsetPosition;
                        fromScrapOrHiddenOrCache = true;
                    }
                }
                //如果存在ViewCacheExtension，则从ViewCacheExtension中查找                这个玩意需要用户自定义，很少使用
                if (holder == null &amp;&amp; mViewCacheExtension != null) {
                    // We are NOT sending the offsetPosition because LayoutManager does not
                    // know it.
                    final View view = mViewCacheExtension
                            .getViewForPositionAndType(this, position, type);
                    if (view != null) {
                        holder = getChildViewHolder(view);
                        if (holder == null) {
                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;
                                    + &quot; a view which does not have a ViewHolder&quot;
                                    + exceptionLabel());
                        } else if (holder.shouldIgnore()) {
                            throw new IllegalArgumentException(&quot;getViewForPositionAndType returned&quot;
                                    + &quot; a view that is ignored. You must call stopIgnoring before&quot;
                                    + &quot; returning this view.&quot; + exceptionLabel());
                        }
                    }
                }
                //还没找到再到RecycledViewPool中进行查找
                if (holder == null) { // fallback to pool
                    if (DEBUG) {
                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline(&quot;
                                + position + &quot;) fetching from shared pool&quot;);
                    }
                    holder = getRecycledViewPool().getRecycledView(type);
                    if (holder != null) {
                        holder.resetInternal();
                        if (FORCE_INVALIDATE_DISPLAY_LIST) {
                            invalidateDisplayListInt(holder);
                        }
                    }
                }
                //实在没有只能通过createViewHolder进行创建
                if (holder == null) {
                    long start = getNanoTime();
                    if (deadlineNs != FOREVER_NS
                            &amp;&amp; !mRecyclerPool.willCreateInTime(type, start, deadlineNs)) {
                        // abort - we have a deadline we can&#39;t meet
                        return null;
                    }
                    holder = mAdapter.createViewHolder(RecyclerView.this, type);
                    if (ALLOW_THREAD_GAP_WORK) {
                        // only bother finding nested RV if prefetching
                        RecyclerView innerView = findNestedRecyclerView(holder.itemView);
                        if (innerView != null) {
                            holder.mNestedRecyclerView = new WeakReference&lt;&gt;(innerView);
                        }
                    }

                    long end = getNanoTime();
                    mRecyclerPool.factorInCreateTime(type, end - start);
                    if (DEBUG) {
                        Log.d(TAG, &quot;tryGetViewHolderForPositionByDeadline created new ViewHolder&quot;);
                    }
                }
            }

            // This is very ugly but the only place we can grab this information
            // before the View is rebound and returned to the LayoutManager for post layout ops.
            // We don&#39;t need this in pre-layout since the VH is not updated by the LM.
            if (fromScrapOrHiddenOrCache &amp;&amp; !mState.isPreLayout() &amp;&amp; holder
                    .hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST)) {
                holder.setFlags(0, ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
                if (mState.mRunSimpleAnimations) {
                    int changeFlags = ItemAnimator
                            .buildAdapterChangeFlagsForAnimations(holder);
                    changeFlags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT;
                    final ItemHolderInfo info = mItemAnimator.recordPreLayoutInformation(mState,
                            holder, changeFlags, holder.getUnmodifiedPayloads());
                    recordAnimationInfoIfBouncedHiddenView(holder, info);
                }
            }

            boolean bound = false;
            if (mState.isPreLayout() &amp;&amp; holder.isBound()) {
                // do not update unless we absolutely have to.
                holder.mPreLayoutPosition = position;
            } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
                if (DEBUG &amp;&amp; holder.isRemoved()) {
                    throw new IllegalStateException(&quot;Removed holder should be bound and it should&quot;
                            + &quot; come here only in pre-layout. Holder: &quot; + holder
                            + exceptionLabel());
                }
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
            }

            final ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();
            final LayoutParams rvLayoutParams;
            if (lp == null) {
                rvLayoutParams = (LayoutParams) generateDefaultLayoutParams();
                holder.itemView.setLayoutParams(rvLayoutParams);
            } else if (!checkLayoutParams(lp)) {
                rvLayoutParams = (LayoutParams) generateLayoutParams(lp);
                holder.itemView.setLayoutParams(rvLayoutParams);
            } else {
                rvLayoutParams = (LayoutParams) lp;
            }
            rvLayoutParams.mViewHolder = holder;
            rvLayoutParams.mPendingInvalidate = fromScrapOrHiddenOrCache &amp;&amp; bound;
            return holder;
        }
</code></pre>

<h4 id="toc_37">从RecyclerViewPool里面获取ViewHolder</h4>

<p>在RecyclerViewPool的内部，使用SparseArray来存储每个ViewType对应的ViewHolder数组，其中每个数组的最大size为5。</p>

<pre><code class="language-java">        static class ScrapData {
            final ArrayList&lt;ViewHolder&gt; mScrapHeap = new ArrayList&lt;&gt;();
            int mMaxScrap = DEFAULT_MAX_SCRAP;
            long mCreateRunningAverageNs = 0;
            long mBindRunningAverageNs = 0;
        }
        SparseArray&lt;ScrapData&gt; mScrap = new SparseArray&lt;&gt;();
</code></pre>

<h3 id="toc_38">回收</h3>

<h4 id="toc_39">scrap数组</h4>

<p>关于ViewHolder回收到scrap数组里面，其实我在前面已经简单的分析了，重点就在于Recycler的scrapView方法里面。我们来看看scrapView在哪里被调用了。有如下两个地方:</p>

<ul>
<li>在getScrapOrHiddenOrCachedHolderForPosition方法里面，如果从mHiddenViews获得一个ViewHolder的话，会先将这个ViewHolder从mHiddenViews数组里面移除，然后调用Recycler的scrapView方法将这个ViewHolder放入到scrap数组里面，并且标记FLAG_RETURNED_FROM_SCRAP和FLAG_BOUNCED_FROM_HIDDEN_LIST两个flag。</li>
<li>在LayoutManager里面的scrapOrRecycleView方法也会调用Recycler的scrapView方法。而有两种情形下会出现如此情况：1. 手动调用了LayoutManager相关的方法;2. RecyclerView进行了一次布局(调用了requestLayout方法)</li>
</ul>

<h4 id="toc_40">mCacheViews数组</h4>

<p>  mCacheViews数组作为二级缓存，回收的路径相较于一级缓存要多。关于mCacheViews数组，重点在于Recycler的recycleViewHolderInternal方法里面。<br/>
  </p>

<h4 id="toc_41">mHiddenViews数组</h4>

<p>一个ViewHolder回收到mHiddenView数组里面的条件比较简单，如果当前操作支持动画，就会调用到RecyclerView的addAnimatingView方法，在这个方法里面会将做动画的那个View添加到mHiddenView数组里面去。通常就是动画期间可以会进行复用，因为mHiddenViews只在动画期间才会有元素。</p>

<h4 id="toc_42">RecyclerViewPool</h4>

<p>RecyclerViewPool跟mCacheViews,都是通过recycleViewHolderInternal方法来进行回收，所以情景与mCacheViews差不多，只不过当不满足放入mCacheViews时，才会放入到RecyclerViewPool里面去。</p>

<h4 id="toc_43">为什么hasStableIds方法返回true会提高效率呢？</h4>

<p>了解了RecyclerView的复用和回收机制之后，这个问题就变得很简单了。我从两个方面来解释原因。</p>

<h5 id="toc_44">A. 复用方面</h5>

<pre><code class="language-java">                if (mAdapter.hasStableIds()) {
                    holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                            type, dryRun);
                    if (holder != null) {
                        // update position
                        holder.mPosition = offsetPosition;
                        fromScrapOrHiddenOrCache = true;
                    }
                }
</code></pre>

<p>在前面通过Position方式来获取一个ViewHolder失败之后，如果Adapter的hasStableIds方法返回为true，在进行通过ViewType方式来获取ViewHolder时，会优先到1级或者二级缓存里面去寻找，而不是直接去RecyclerViewPool里面去寻找。从这里，我们可以看到,在复用方面，hasStableIds方法提高了效率。</p>

<h5 id="toc_45">B. 回收方面</h5>

<pre><code class="language-java">        private void scrapOrRecycleView(Recycler recycler, int index, View view) {
            final ViewHolder viewHolder = getChildViewHolderInt(view);
            if (viewHolder.shouldIgnore()) {
                if (DEBUG) {
                    Log.d(TAG, &quot;ignoring view &quot; + viewHolder);
                }
                return;
            }
            if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                    &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
                removeViewAt(index);
                recycler.recycleViewHolderInternal(viewHolder);
            } else {
                detachViewAt(index);
                recycler.scrapView(view);
                mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);
            }
        }
</code></pre>

<p>从上面的代码中，我们可以看出，如果hasStableIds方法返回为true的话，这里所有的回收都进入scrap数组里面。这刚好与前面对应了。</p>

<h2 id="toc_46">Adapter源码解析</h2>

<p>先看Adapter源码</p>

<pre><code class="language-java">    public abstract static class Adapter&lt;VH extends ViewHolder&gt; {
        private final AdapterDataObservable mObservable = new AdapterDataObservable();
        private boolean mHasStableIds = false;

        //创建一个ViewHolder对象，主要作用是将数据保存在ViewHolder，以供后面bind操作使用
        @NonNull
        public abstract VH onCreateViewHolder(@NonNull ViewGroup parent, int viewType);

        //数据绑定方法
        public abstract void onBindViewHolder(@NonNull VH holder, int position);

        public void onBindViewHolder(@NonNull VH holder, int position,
                @NonNull List&lt;Object&gt; payloads) {
            onBindViewHolder(holder, position);
        }

        @NonNull
        public final VH createViewHolder(@NonNull ViewGroup parent, int viewType) {
            try {
                TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG);
                final VH holder = onCreateViewHolder(parent, viewType);
                if (holder.itemView.getParent() != null) {
                    throw new IllegalStateException(&quot;ViewHolder views must not be attached when&quot;
                            + &quot; created. Ensure that you are not passing &#39;true&#39; to the attachToRoot&quot;
                            + &quot; parameter of LayoutInflater.inflate(..., boolean attachToRoot)&quot;);
                }
                holder.mItemViewType = viewType;
                return holder;
            } finally {
                TraceCompat.endSection();
            }
        }

        public final void bindViewHolder(@NonNull VH holder, int position) {
            holder.mPosition = position;
            if (hasStableIds()) {
                holder.mItemId = getItemId(position);
            }
            holder.setFlags(ViewHolder.FLAG_BOUND,
                    ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID
                            | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);
            TraceCompat.beginSection(TRACE_BIND_VIEW_TAG);
            onBindViewHolder(holder, position, holder.getUnmodifiedPayloads());
            holder.clearPayload();
            final ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
            if (layoutParams instanceof RecyclerView.LayoutParams) {
                ((LayoutParams) layoutParams).mInsetsDirty = true;
            }
            TraceCompat.endSection();
        }

        //该方法带一个Position，主要是返回当前位置的ViewType。这个方法通常用于一个RecyclerView需要加载不同的布局。
        public int getItemViewType(int position) {
            return 0;
        }

        //设置当前RecyclerView的ItemView是否拥有固定id,跟getItemId方法一起使用。如果设置为true，会提高RecyclerView的缓存效率。
        public void setHasStableIds(boolean hasStableIds) {
            if (hasObservers()) {
                throw new IllegalStateException(&quot;Cannot change whether this adapter has &quot;
                        + &quot;stable IDs while the adapter has registered observers.&quot;);
            }
            mHasStableIds = hasStableIds;
        }

        //该方法表示的意思是返回当前位置Item的id，此方法只在setHasStableIds设置为true才会生效
        public long getItemId(int position) {
            return NO_ID;
        }

        //当前Adapter拥有数据的数量，该方法必须被重写，否则RecyclerView展示不了任何数据
        public abstract int getItemCount();

        public final boolean hasStableIds() {
            return mHasStableIds;
        }

        public void onViewRecycled(@NonNull VH holder) {
        }

        public boolean onFailedToRecycleView(@NonNull VH holder) {
            return false;
        }

        public void onViewAttachedToWindow(@NonNull VH holder) {
        }

        public void onViewDetachedFromWindow(@NonNull VH holder) {
        }

        public final boolean hasObservers() {
            return mObservable.hasObservers();
        }

        public void registerAdapterDataObserver(@NonNull AdapterDataObserver observer) {
            mObservable.registerObserver(observer);
        }

        public void unregisterAdapterDataObserver(@NonNull AdapterDataObserver observer) {
            mObservable.unregisterObserver(observer);
        }

        public void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) {
        }

        public void onDetachedFromRecyclerView(@NonNull RecyclerView recyclerView) {
        }

        public final void notifyDataSetChanged() {
            mObservable.notifyChanged();
        }

        public final void notifyItemChanged(int position) {
            mObservable.notifyItemRangeChanged(position, 1);
        }

        public final void notifyItemChanged(int position, @Nullable Object payload) {
            mObservable.notifyItemRangeChanged(position, 1, payload);
        }

        public final void notifyItemRangeChanged(int positionStart, int itemCount) {
            mObservable.notifyItemRangeChanged(positionStart, itemCount);
        }

        public final void notifyItemRangeChanged(int positionStart, int itemCount,
                @Nullable Object payload) {
            mObservable.notifyItemRangeChanged(positionStart, itemCount, payload);
        }

        public final void notifyItemInserted(int position) {
            mObservable.notifyItemRangeInserted(position, 1);
        }

        public final void notifyItemMoved(int fromPosition, int toPosition) {
            mObservable.notifyItemMoved(fromPosition, toPosition);
        }
        
        public final void notifyItemRangeInserted(int positionStart, int itemCount) {
            mObservable.notifyItemRangeInserted(positionStart, itemCount);
        }

        public final void notifyItemRemoved(int position) {
            mObservable.notifyItemRangeRemoved(position, 1);
        }

        public final void notifyItemRangeRemoved(int positionStart, int itemCount) {
            mObservable.notifyItemRangeRemoved(positionStart, itemCount);
        }
    }
</code></pre>

<h3 id="toc_47">onCreateViewHolder</h3>

<p>首先，我们来看一下onCreateViewHolder方法，从它的调用时机入手。</p>

<ul>
<li>一级缓存：scrap数组</li>
<li>二级缓存：CachedView</li>
<li>三级缓存：ViewCacheExtension</li>
<li>四级缓存：RecyclerViewPool</li>
</ul>

<p>LayoutManager会获取ViewHolder时，如果4级缓存都没有命中，就会调用Adapter的onCreateViewHolder方法来创建一个新的ViewHolder。</p>

<h3 id="toc_48">onBindViewHolder</h3>

<p>在之前的tryGetViewHolderForPositionByDeadline方法中</p>

<pre><code class="language-java">            boolean bound = false;
            if (mState.isPreLayout() &amp;&amp; holder.isBound()) {
                // do not update unless we absolutely have to.
                holder.mPreLayoutPosition = position;
            } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
                if (DEBUG &amp;&amp; holder.isRemoved()) {
                    throw new IllegalStateException(&quot;Removed holder should be bound and it should&quot;
                            + &quot; come here only in pre-layout. Holder: &quot; + holder
                            + exceptionLabel());
                }
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
            }
</code></pre>

<p>在tryBindViewHolderByDeadline中调用Adapter的bindViewHolder</p>

<pre><code class="language-java">            private boolean tryBindViewHolderByDeadline(@NonNull ViewHolder holder, int offsetPosition,
                int position, long deadlineNs) {
            //...
            mAdapter.bindViewHolder(holder, offsetPosition);
            //...
            return true;
        }
</code></pre>

<p>在执行onBindViewHolder方法前后，各自做了一些不同的操作。比如，在执行onBindViewHolder方法之前，更新了ViewHolder的mPosition属性和给ViewHolder设置了一些flag；在执行onBindViewHolder方法之后，清理了ViewHolder的payload，并且还是给ItemView的LayoutParams的mInsetsDirty属性设置为true。</p>

<pre><code class="language-java">            public final void bindViewHolder(@NonNull VH holder, int position) {
            holder.mPosition = position;
            if (hasStableIds()) {
                holder.mItemId = getItemId(position);
            }
            holder.setFlags(ViewHolder.FLAG_BOUND,
                    ViewHolder.FLAG_BOUND | ViewHolder.FLAG_UPDATE | ViewHolder.FLAG_INVALID
                            | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN);
            TraceCompat.beginSection(TRACE_BIND_VIEW_TAG);
            onBindViewHolder(holder, position, holder.getUnmodifiedPayloads());
            holder.clearPayload();
            final ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();
            if (layoutParams instanceof RecyclerView.LayoutParams) {
                ((LayoutParams) layoutParams).mInsetsDirty = true;
            }
            TraceCompat.endSection();
        }
</code></pre>

<h3 id="toc_49">ViewHolder的position</h3>

<p>这里主要分析两个方法，分别是getAdapterPosition和getLayoutPosition，对应着ViewHolder内部两个成员变量mPosition和mPreLayoutPosition两个属性。</p>

<p><strong>先来看下getAdapterPosition方法</strong></p>

<pre><code class="language-java">        public final int getAdapterPosition() {
            if (mOwnerRecyclerView == null) {
                return NO_POSITION;
            }
            return mOwnerRecyclerView.getAdapterPositionFor(this);
        }
</code></pre>

<p>别看getAdapterPosition方法比较麻烦，还调用了RecyclerView的getAdapterPositionFor方法进行位置的计算。但是它表达的意思是非常简单的，就是获取当前ViewHolder所绑定ItemView的真实位置。这里的真实位置说的比较笼统，这样来解释吧，当我们remove掉为position为0的item，正常来说，后面ViewHolder的position应该都减1。但是RecyclerView处理Adapter的更新采用的延迟处理策略，所以在正式处理之前获取ViewHolder的位置可能会出现误差，介于这个原因，getAdapterPosition方法就出现了。<br/>
  getAdapterPosition方法是怎样保证每次计算都是正确的呢？包括在正式处理之前呢？我们知道，在RecyclerView中，延迟处理的实现是在notify阶段往一个叫mPendingUpdates数组里面添加Operation，分别在dispatchLayoutStep1阶段或者dispatchLayoutStep2阶段进行处理。通过追踪getAdapterPositionFor方法，我们知道getAdapterPosition方法在计算位置时，考虑到mPendingUpdates数组的存在，所以在notify阶段和dispatchLayoutStep1阶段之间(这里假设dispatchLayoutStep1就会处理)，getAdapterPosition方法返回正确的位置。</p>

<p><strong>再来看看getLayoutPosition方法</strong></p>

<pre><code class="language-java">        public final int getLayoutPosition() {
            return mPreLayoutPosition == NO_POSITION ? mPosition : mPreLayoutPosition;
        }
</code></pre>

<p>getLayoutPosition方法返回的是mPosition或者mPreLayoutPosition,但是在dispatchLayoutStep1阶段之前，还未更新每个ViewHolder的position，所以获得不一定的是正确(只有在处理mPendingUpdates的操作时，position才会被更新，对应着的代码就是执行AdapterHelper$Callback接口的方法)。<br/>
  但是getLayoutPosition方法为什么还有存在的必要呢？我们发现getLayoutPosition方法不会每次都计算，也就是说，getLayoutPosition方法的效率比getAdapterPosition方法高。当我们在Adapter这种调用方法来获取ViewHolder的位置时，可以优先考虑getLayoutPosition方法，因为Adapter的方法回调阶段不在mPendingUpdates处理之前，所以此时getLayoutPosition方法跟getAdapterPosition方法没有任何区别了。<br/>
  但是需要注意，如果我们在其他地方获取ViewHolder的position，要特别注意这种情况，因为其他地方不能保证与RecyclerView状态同步，这种情况为了保证结果的正确性，我们应该优先考虑getAdapterPosition方法。</p>

<h3 id="toc_50">notifyDataSetChanged</h3>

<p>该方法最终调用了 RecyclerViewDataObserver 的 onChanged 方法</p>

<pre><code class="language-java">    @Override
    public void onChanged() {
        // ...

        // 该方法主要做了这两件事
        // 1. 给所有 ViewHolder 添加了 FLAG_UPDATE 和 FLAG_INVALID
        // 2. 默认情况下（mHasStableIds 为 false）清空 CacheViews
        processDataSetCompletelyChanged(true);
        
        if (!mAdapterHelper.hasPendingUpdates()) {
            // 进行视图重绘
            requestLayout();
        }
    }
</code></pre>

<p>该方法会进行视图重绘，又来到了 layout 过程，继续以 LinearLayoutManager 为例，从它的 onLayoutChildren 方法看起，由于分析第一次 layout 时已经看过一遍了，这次主要看下不同之处：</p>

<pre><code class="language-java">    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // ...
        
        detachAndScrapAttachedViews(recycler);
        
        // ...
    }
</code></pre>

<p>主要区别在于 detachAndScrapAttachedViews 方法，这次它开始起作用了，该方法在 RecyclerView 的 LayoutManager 中定义，看下它的实现：</p>

<h4 id="toc_51">LayoutManager#detachAndScrapAttachedViews</h4>

<pre><code class="language-java">    public void detachAndScrapAttachedViews(@NonNull Recycler recycler) {
        final int childCount = getChildCount();
        for (int i = childCount - 1; i &gt;= 0; i--) {
            final View v = getChildAt(i);
            scrapOrRecycleView(recycler, i, v);
        }
    }
</code></pre>

<p>由于不是第一次 layout，RecyclerView 这时已经有子 View 了，该方法遍历子 View，调用 scrapOrRecycleView 方法：</p>

<pre><code class="language-java">    private void scrapOrRecycleView(Recycler recycler, int index, View view) {
        final ViewHolder viewHolder = getChildViewHolderInt(view);
        // 不能回收添加了 FLAG_IGNORE 标记的 ViewHolder
        // 可通过 LayoutManager 的 ignoreView 为相应的 View 添加该标记
        if (viewHolder.shouldIgnore()) {
            return;
        }
        // 这些条件都满足，进入 if 块
        if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
            removeViewAt(index);
            recycler.recycleViewHolderInternal(viewHolder);
        } else {
            // ...
        }
    }
</code></pre>

<p>这里将子 View 移除并通过 Recycler 的 recycleViewHolderInternal 方法进行回收</p>

<h4 id="toc_52">Recycler#recycleViewHolderInternal</h4>

<pre><code class="language-java">        void recycleViewHolderInternal(ViewHolder holder) {
            // ...
            boolean cached = false;
            boolean recycled = false;

            if (forceRecycle || holder.isRecyclable()) {
                // 由于此时的 ViewHolder 有 FLAG_INVALID 标记，不会进入此 if 块
                if (mViewCacheMax &gt; 0
                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                        | ViewHolder.FLAG_REMOVED
                        | ViewHolder.FLAG_UPDATE
                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
                    //...
                }
                // cached 仍为 false，进入此 if 块
                if (!cached) {
                    // 通过 RecycledViewPool 的 putRecycledView 方法缓存该 ViewHolder
                    addViewHolderToRecycledViewPool(holder, true);
                    recycled = true;
                }
            } 
            
            // ...
        }
</code></pre>

<p>最终被移除的子 View 缓存到了 RecycledViewPool 中。</p>

<p>后面在调用 fill 方法进行布局填充时，就可以从 RecycledViewPool 中拿取缓存的 View。</p>

<h3 id="toc_53">notifyItemChanged</h3>

<p>该方法传入一个 int 参数，表示要数据有更新的 item 的 position。</p>

<pre><code class="language-java">    public final void notifyItemChanged(int position) {
        mObservable.notifyItemRangeChanged(position, 1);
    }
</code></pre>

<p>最终调用 RecyclerViewDataObserver 的 onItemRangeChanged 方法</p>

<pre><code class="language-java">    @Override
    public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {
        // 会在 mAdapterHelper 中创建一个 UpdateOp，将信息保存起来
        if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) {
            // 如果可以进行更新操作，执行该方法
            triggerUpdateProcessor();
        }
    }
</code></pre>

<p>继续看 triggerUpdateProcessor 方法</p>

<pre><code class="language-java">    void triggerUpdateProcessor() {
        // 判断条件默认为 false，执行 else 块
        if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) {
            // ...
        } else {
            mAdapterUpdateDuringMeasure = true;
            requestLayout();
        }
    }
</code></pre>

<p>在保存了一些信息后，还是进行视图重绘。来到了 layout 过程后，还是以 LinearLayoutManager 为例，这次先看下布局过程的 step1，也就是 dispatchLayoutStep1 方法</p>

<pre><code class="language-java">    private void dispatchLayoutStep1() {
        // ...
        
        processAdapterUpdatesAndSetAnimationFlags();
        
        // ...
    }
</code></pre>

<p>主要看 processAdapterUpdatesAndSetAnimationFlags 方法，从名字也可以看出，它负责更新 adapter 的信息</p>

<pre><code class="language-java">    private void processAdapterUpdatesAndSetAnimationFlags() {
        // ...

        if (predictiveItemAnimationsEnabled()) {
            mAdapterHelper.preProcess();
        } else {
            mAdapterHelper.consumeUpdatesInOnePass();
        }

        // ...
    }
</code></pre>

<p>这里借助了 mAdapterHelper，它最终又通过接口回调（回调了 markViewHoldersUpdated 方法）调用了 RecyclerView 的 viewRangeUpdate 方法</p>

<pre><code class="language-java">    void viewRangeUpdate(int positionStart, int itemCount, Object payload) {
        // ...

        for (int i = 0; i &lt; childCount; i++) {
            // ...
            
            if (holder.mPosition &gt;= positionStart &amp;&amp; holder.mPosition &lt; positionEnd) {
                // （1）
                holder.addFlags(ViewHolder.FLAG_UPDATE);
                // ...
            }
        }
    }
</code></pre>

<p>该方法就是遍历所有子 View，找到所有发生了改变的子 View，进行相关操作。这里重点看注释（1），为改变的 ViewHolder 添加了 FLAG_UPDATE 标记。先记住这点，在后面会用到。</p>

<p>接下来看 onLayoutChildren 方法，和 notifyDataSetChanged 一样，主要的不同之处也是在于 detachAndScrapAttachedViews 方法，该方法遍历子 View，调用 scrapOrRecycleView 方法，下面看一下该方法</p>

<h4 id="toc_54">LayoutManager#scrapOrRecycleView</h4>

<pre><code class="language-java">    private void scrapOrRecycleView(Recycler recycler, int index, View view) {
        final ViewHolder viewHolder = getChildViewHolderInt(view);
        // ...
        
        // 这次 ViewHolder 没有添加 FLAG_INVALID 标记，进入 else 块
        if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
            // ...
        } else {
            detachViewAt(index);
            recycler.scrapView(view);
            mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);
        }
    }
</code></pre>

<p>这里就和 notifyDataSetChanged 时不一样了，由于在视图重绘前没有给 ViewHolder 添加 FLAG_INVALID 标记，这次进入的是 else 块。</p>

<p>首先将 View 从 RecyclerView 中 detach 掉（而不是 remove 掉）。然后在回收时，调用的是 Recycler 的 scrapView 方法。该方法在前面也分析过了，这里再看一次</p>

<pre><code class="language-java">    void scrapView(View view) {
        final ViewHolder holder = getChildViewHolderInt(view);
        
        // 满足这几个条件中的一个就可以进入 if 循环
        // 1. ViewHolder 设置了 FLAG_REMOVED 或 FLAG_INVALID 
        // 2. ViewHolder 没有设置 FLAG_UPDATE 
        // 3. 没有设置动画或者动画可以重用该 ViewHolder 
        if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
            // ...
            
            mAttachedScrap.add(holder);
        } 
        // 不满足上述任意一个条件时，将 View 缓存到 mChangedScrap 中
        else {
            if (mChangedScrap == null) {
                mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
            }
            holder.setScrapContainer(this, true);
            mChangedScrap.add(holder);
        }
    }
</code></pre>

<p>重点看判断里面的条件 2，从前面的分析可以得知，对于发生改变的 ViewHolder，给它设置了 FLAG_UPDATE，所以它现在三个条件都不满足，进入 else 块，而对于其他的 ViewHolder，由于没有设置 FLAG_UPDATE，所以满足条件 2，进入 if 循环。</p>

<p>所以通过 notifyItemChanged 方法更新列表时，发生了改变的子 View 将被缓存到 ChangedScrap 中，而没有发生改变的子 View 则缓存到 AttachedScrap 中，之后通过填充布局的时候对于不同 item 就可以从相应的 Scrap 缓存中得到子 View。</p>

<p>另外，Scrap 缓存只作用于布局阶段，在 layout 的 step3 中将会清空 mAttachedScrap 和 mChangedScrap。</p>

<h2 id="toc_55">动画机制</h2>

<h2 id="toc_56">滑动机制</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL学习笔记]]></title>
    <link href="http://adolph.cc/15941201495783.html"/>
    <updated>2020-07-07T19:09:09+08:00</updated>
    <id>http://adolph.cc/15941201495783.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">数据表的基本操作</h2>

<p><strong>创建数据库</strong></p>

<pre><code class="language-text">create database aa;
</code></pre>

<span id="more"></span><!-- more -->

<p><strong>选择数据库</strong></p>

<pre><code class="language-text">use aa;
</code></pre>

<p><strong>创建表</strong></p>

<pre><code class="language-text">create table tb_emp1 
(
    id int(11),
    name varchar(25),
    deptId int(11),
    saiary float
);
</code></pre>

<p><strong>查看数据表</strong></p>

<pre><code class="language-text">show tables
</code></pre>

<h2 id="toc_1">约束</h2>

<h3 id="toc_2">主键约束</h3>

<p>主键，又称主码，是表中一列或多列的组合。主键约束（Primary Key Constraint）要求主键列的数据唯一，并且不允许为空。主键能够唯一标识表中的一条记录，可以结合外键来定义不同数据表之间的关系，并且可以加快数据库查询的速度。主键和记录之间的关系如同身份证和人之间的关系，它们之间是一一对应的。主键分为两种类型：单字段主键和多字段联合主键。</p>

<h4 id="toc_3">1．单字段主键</h4>

<p>在定义列的同时指定主键<br/>
<code>字段名 数据类型PRIMARY KEY[默认值]</code></p>

<p>在定义完所有列之后指定主键<br/>
<code>[constraint&lt;约束名&gt;] primary key [字段名]</code></p>

<h4 id="toc_4">2．多字段联合主键</h4>

<p>多字段联合主键是指主键由多个字段联合组成<br/>
<code>primary key [字段1，字段2 ... 字段n]</code></p>

<h3 id="toc_5">外键约束</h3>

<p>外键用来在两个表的数据之间建立连接，它可以是一列或者多列。一个表可以有一个或者多个外键。外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键值必须等于另一个表中主键的某个值。外键：下面介绍几个概念。是表中的一个字段，它可以不是本表的主键，但对应另外一个表的主键。外键的主要作用是保证数据引用的完整性，定义外键后，不允许删除在另一个表中具有关联关系的行。</p>

<p><code>[constraint&lt;外键名&gt;] foreign key [字段名1、字段名2...] references &lt;主表名&gt; [主键列1、主键列2...]</code></p>

<h3 id="toc_6">非空约束</h3>

<p>非空约束（NOT NULL Constraint）是指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统会报错。</p>

<p><code>字段名 数据类型 not null</code></p>

<h3 id="toc_7">唯一性约束</h3>

<p>唯一性约束（Unique Constraint）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列都不出现重复值。</p>

<h4 id="toc_8">在定义完列之后直接指定唯一约束</h4>

<p><code>字段名 数据类型 unique</code></p>

<h4 id="toc_9">在定义完所有列之后指定唯一约束</h4>

<p><code>[constraint &lt;约束名&gt;] unique (&lt;字段名&gt;)</code></p>

<h3 id="toc_10">默认约束</h3>

<p>默认约束（Default Constraint）指定某列的默认值。如男性同学较多，性别就可以默认为“男”。如果插入一条新的记录时没有为这个字段赋值，那么系统会自动为这个字段赋值为“男”。</p>

<p><code>字段名 数据类型 default 默认值</code></p>

<h3 id="toc_11">自动增加</h3>

<p>在数据库应用中，经常希望在每次插入新记录时，系统自动生成字段的主键值。可以通过为表主键添加AUTO_INCREMENT关键字来实现。在MySQL中，默认情况下AUTO_INCREMENT初始值为1，每新增一条记录，字段自动加1。一个表只能有一个字段使用AUTO_INCREMENT约束，且该字段必须为主键的一部分。AUTO_INCREMENT约束的字段可以是任何整数类型（TINYINT、SMALLINT、INT、BIGINT）。</p>

<p><code>字段名 数据类型 auto_increment</code></p>

<h2 id="toc_12">查看表结构</h2>

<h3 id="toc_13">查看表基本结构</h3>

<p>DESCRIBE/DESC语句可以查看表字段信息，其中包括：字段名、字段数据类型、是否为主键、是否有默认值。</p>

<pre><code class="language-text">describe 表名
或者 desc 表名
</code></pre>

<h3 id="toc_14">查看表详细结构</h3>

<p>SHOW CREATE TABLE语句可以用来显示创建表时的CREATE TABLE语句</p>

<p><code>show create table &lt;表名\G&gt;</code></p>

<p>如果不加“\G”参数，显示的结果可能非常混乱，加上参数“\G”之后，可使显示结果更加直观，易于查看。</p>

<h2 id="toc_15">修改数据表</h2>

<p>修改表指的是修改数据库中已经存在的数据表的结构。MySQL使用ALTER TABLE语句修改表。常用的修改表的操作有：修改表名，修改字段数据类型或字段名，增加和删除字段，修改字段的排列位置，更改表的存储引擎，删除表的外键约束等。</p>

<h3 id="toc_16">修改表名</h3>

<p>MySQL是通过ALTER TABLE语句来实现表名的修改的</p>

<p><code>alter table &lt;旧表名&gt; rename &lt;新表名&gt;</code></p>

<h3 id="toc_17">修改字段数据类型</h3>

<p>修改字段的数据类型，就是把字段的数据类型转换成另一种数据类型。</p>

<p><code>alter table &lt;表名&gt; modify &lt;字段名&gt; &lt;数据类型&gt;;</code></p>

<h3 id="toc_18">修改字段名</h3>

<p><code>alter table &lt;表名&gt; change &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;;</code></p>

<p>其中，“旧字段名”指修改前的字段名；“新字段名”指修改后的字段名；“新数据类型”指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样即可，但数据类型不能为空。</p>

<h3 id="toc_19">添加字段</h3>

<p><code>alter table &lt;表名&gt; add &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [first|after已经存在的字段名]</code></p>

<p>其中，“新字段名”为需要添加的字段名称；“FIRST”为可选参数，其作用是将新添加的字段设置为表的第一个字段；“AFTER”为可选参数，其作用是将新添加的字段添加到指定的“已存在字段名”的后面。</p>

<h3 id="toc_20">删除字段</h3>

<p><code>alter table &lt;表名&gt; drop &lt;字段名&gt;;</code></p>

<h3 id="toc_21">修改字段排序</h3>

<p>对于一个数据表来说，在创建的时候，字段在表中的排列顺序就已经确定了。但表的结构并不是完全不可以改变的，可以通过ALTER TABLE来改变表中字段的相对位置。<br/>
<code>alter table &lt;表名&gt; modify &lt;字段1&gt; &lt;数据类型&gt; first/after &lt;字段2&gt;</code></p>

<p>其中，“字段1”指要修改位置的字段；“数据类型”指“字段1”的数据类型；“FIRST”为可选参数，指将“字段1”修改为表的第一个字段；“AFTER&lt;字段2&gt;”指将“字段1”插入到“字段2”后面。</p>

<h3 id="toc_22">更改表的存储引擎</h3>

<p>存储引擎是MySQL中的数据存储在文件或内存中时采用的不同技术实现。可以根据自己的需要，选择不同的引擎，甚至可以为每一张表选择不同的存储引擎。</p>

<p><code>alter table &lt;表名&gt; engine = &lt;更改后的存储引擎名&gt;</code></p>

<h3 id="toc_23">删除表的外键约束</h3>

<p>对于数据库中定义的外键，如果不再需要，可以将其删除。外键一旦删除，就会解除主表和从表间的关联关系。</p>

<p><code>alter table &lt;表名&gt; drop foreign key &lt;外键约束名&gt;;</code></p>

<h2 id="toc_24">删除数据表</h2>

<p>删除数据表就是将数据库中已经存在的表从数据库中删除。注意，在删除表的同时，表的定义和表中所有的数据均会被删除。因此，在进行删除操作前，最好对表中的数据做个备份，以免造成无法挽回的后果。</p>

<h3 id="toc_25">删除没有被关联的表</h3>

<p>使用DROP TABLE可以一次删除一个或多个没有被其他表关联的数据表</p>

<p><code>drop table [if exists] 表1、表2...表n</code></p>

<p>其中，“表n”指要删除的表的名称，后面可以同时删除多个表，只需将删除的表名一起写在后面，相互之间用逗号隔开。如果要删除的数据表不存在，则MySQL会提示一条错误信息，“ERROR 1051（42S02）:Unknown table ‘表名’”。参数“IF EXISTS”用于在删除前判断删除的表是否存在，加上该参数后，再删除表的时候，如果表不存在，SQL语句可以顺利执行，但是会发出警告（Warning）。</p>

<h3 id="toc_26">删除被其他表关联的主表</h3>

<p>在数据表之间存在外键关联的情况下，如果直接删除父表，结果会显示失败。原因是直接删除，将破坏表的参照完整性。如果必须要删除，可以先删除与它关联的子表，再删除父表，只是这样同时删除了两个表中的数据。但有的情况下可能要保留子表，这时如要单独删除父表，只需将关联的表的外键约束条件取消，然后就可以删除父表</p>

<h2 id="toc_27">数据类型</h2>

<h3 id="toc_28">整数类型</h3>

<table>
<thead>
<tr>
<th style="text-align: left">类型名称</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">存储需求</th>
<th style="text-align: left">有符号数取值范围</th>
<th style="text-align: left">无符号数取值范围</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">TINYINT</td>
<td style="text-align: left">很小的整数</td>
<td style="text-align: left">1个字节</td>
<td style="text-align: left">-128~127</td>
<td style="text-align: left">0~255</td>
</tr>
<tr>
<td style="text-align: left">SMALLINT</td>
<td style="text-align: left">小的整数</td>
<td style="text-align: left">2个字节</td>
<td style="text-align: left">-32768~32767</td>
<td style="text-align: left">0~65535</td>
</tr>
<tr>
<td style="text-align: left">MEDIUMINT</td>
<td style="text-align: left">中等大小的整数</td>
<td style="text-align: left">3个字节</td>
<td style="text-align: left">-8388608~8388607</td>
<td style="text-align: left">0~16777215</td>
</tr>
<tr>
<td style="text-align: left">INT（INTEGER）</td>
<td style="text-align: left">普通大小的整数</td>
<td style="text-align: left">4个字节</td>
<td style="text-align: left">-2147483648~2147483647</td>
<td style="text-align: left">0~4294967295</td>
</tr>
<tr>
<td style="text-align: left">BIGINT</td>
<td style="text-align: left">大整数</td>
<td style="text-align: left">8个字节</td>
<td style="text-align: left">-9223372036854775808~9223372036854775807</td>
<td style="text-align: left">0~18446744073709551615</td>
</tr>
</tbody>
</table>

<p>MySQL支持选择在该类型关键字后面的括号内指定整数值的显示宽度，可使用INT（M）进行设置。其中，M指示最大显示宽度，例如，INT（4）表示最大有效显示宽度为4。需要注意的是：显示宽度与存储大小或类型包含的值的范围无关。该可选显示宽度规定用于显示宽度小于指定的字段宽度的值时从左侧填满宽度。显示宽度只是指明MySQL最大可能显示的数值个数，数值的个数如果小于指定的宽度时，显示会由空格填充；如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数据依然可以插入，而且显示无误。</p>

<h3 id="toc_29">浮点数类型和定点数类型</h3>

<p>浮点类型有两种：单精度浮点类型（FLOAT）和双精度浮点类型（DOUBLE）。定点类型只有一种：DECIMAL。浮点类型和定点类型都可以用（M,D）来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。浮点类型取值范围为：M（1～255）和D（1～30，且不能大于M-2）。分别表示显示宽度和小数位数。M和D在FLOAT和DOUBLE中是可选的</p>

<table>
<thead>
<tr>
<th style="text-align: left">类型名称</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">存储需求</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">float</td>
<td style="text-align: left">单精度浮点数</td>
<td style="text-align: left">4个字节</td>
</tr>
<tr>
<td style="text-align: left">double</td>
<td style="text-align: left">双精度浮点数</td>
<td style="text-align: left">8个字节</td>
</tr>
<tr>
<td style="text-align: left">decimal(M,D), dec</td>
<td style="text-align: left">压缩的”严格“定点数</td>
<td style="text-align: left">M+2个字节</td>
</tr>
</tbody>
</table>

<p>DECIMAL类型不同于FLOAT和DECIMAL，其中DECIMAL实际是以字符串存储的。DECIMAL可能的最大取值范围与DOUBLE一样，但是其有效的取值范围由M和D的值决定。如果改变M而固定D，则其取值范围将随M的变大而变大。如果固定M而改变D，则其取值范围将随D的变大而变小（但精度增加）。由MySQL中的小数类型表可以看出，DECIMAL的存储空间并不是固定的，而是由其精度值M决定，占用M+2个字节。</p>

<h3 id="toc_30">日期与时间类型</h3>

<p>MySQL中有多种表示日期的数据类型，主要有：YEAR、TIME、DATE、DATETIME、TIMESTAMP。例如：只需记录年份信息时，可以只用YEAR类型，而没有必要使用DATE。每一个类型都有合法的取值范围，当插入不合法的值时，系统会将“0”值插入到字段中。下表列出了MySQL中的日期与时间类型。</p>

<table>
<thead>
<tr>
<th style="text-align: left">类型名称</th>
<th style="text-align: left">日期格式</th>
<th style="text-align: left">日期范围</th>
<th style="text-align: left">存储需求</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">year</td>
<td style="text-align: left">YYYY</td>
<td style="text-align: left">1901~2155</td>
<td style="text-align: left">1个字节</td>
</tr>
<tr>
<td style="text-align: left">time</td>
<td style="text-align: left">HH:MM:SS</td>
<td style="text-align: left">-838:59:59~838:59:59</td>
<td style="text-align: left">3个字节</td>
</tr>
<tr>
<td style="text-align: left">date</td>
<td style="text-align: left">YYYY-MM-DD</td>
<td style="text-align: left">1000-01-01 ~ 9999-12-31</td>
<td style="text-align: left">3个字节</td>
</tr>
<tr>
<td style="text-align: left">datetime</td>
<td style="text-align: left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align: left">1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td style="text-align: left">8个字节</td>
</tr>
<tr>
<td style="text-align: left">timestamp</td>
<td style="text-align: left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align: left">1970-01-01 00:00:001 ~ 2038-01-19 03:14:07</td>
<td style="text-align: left">4个字节</td>
</tr>
</tbody>
</table>

<h3 id="toc_31">字符串类型</h3>

<p>字符串类型用于存储字符串数据，MySQL支持两类字符串数据：文本字符串和二进制字符串。</p>

<table>
<thead>
<tr>
<th style="text-align: center">类型名称</th>
<th style="text-align: center">说明</th>
<th style="text-align: center">存储需求</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">char(M)</td>
<td style="text-align: center">固定长度非二进制字符串</td>
<td style="text-align: center">M字节，1&lt;=M&lt;=255</td>
</tr>
<tr>
<td style="text-align: center">varchar(M)</td>
<td style="text-align: center">变长非二进制字符串</td>
<td style="text-align: center">L+1字节，在此L&lt;=M且1&lt;=M&lt;=255</td>
</tr>
<tr>
<td style="text-align: center">tinytext</td>
<td style="text-align: center">非常小的非二进制字符串</td>
<td style="text-align: center">L+1字节，在此L&lt;28</td>
</tr>
<tr>
<td style="text-align: center">text</td>
<td style="text-align: center">小的非二进制字符串</td>
<td style="text-align: center">L+2字节，在此L&lt;216</td>
</tr>
<tr>
<td style="text-align: center">mediumtext</td>
<td style="text-align: center">中等大小的非二进制字符串</td>
<td style="text-align: center">L+3字节，在此L&lt;224</td>
</tr>
<tr>
<td style="text-align: center">longtext</td>
<td style="text-align: center">大的非二进制字符串</td>
<td style="text-align: center">L+4字节，在此L&lt;232</td>
</tr>
<tr>
<td style="text-align: center">enum</td>
<td style="text-align: center">枚举类型，只能有一个枚举字符串值</td>
<td style="text-align: center">1或2个字节，取决于枚举值的数目</td>
</tr>
<tr>
<td style="text-align: center">set</td>
<td style="text-align: center">一个集合，字符串对象可以有零个或多个set成员</td>
<td style="text-align: center">1，2，3，4或8个字节，取决于集合成员的数量</td>
</tr>
</tbody>
</table>

<p>VARCHAR和TEXT类型是变长类型，它们的存储需求取决于值得实际长度（上表中用L表示），而不是取决于类型的最大可能长度。</p>

<h4 id="toc_32">1．CHAR和VARCHAR类型</h4>

<p>CHAR（M）为固定长度字符串，在定义时指定字符串长度，当保存时在右侧填充空格以达到指定的长度。M表示字符串长度，M的取值范围是0～255。</p>

<p>VARCHAR（M）是长度可变的字符串，M表示最大的字段长度。M的取值范围是0～65535。VARCHAR的最大实际长度由最长字段的大小和使用的字符集确定，而其实际占用的空间为字符串的实际长度加1。</p>

<h4 id="toc_33">2．TEXT类型</h4>

<p>TEXT字段保存非二进制字符串，如文章内容、评论和留言等。当保存或查询TEXT字段的值时，不删除尾部空格。TEXT类型分为4种：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT。不同的TEXT类型所需存储空间和数据长度不同。</p>

<ul>
<li>（1）TINYTEXT最大长度为255（28-1）字符。</li>
<li>（2）TEXT最大长度为65535（216-1）字符。</li>
<li>（3）MEDIUMTEXT最大长度为16777215（224-1）字符。</li>
<li>（4）LONGTEXT最大长度为4294967295或4GB（232-1）字符。</li>
</ul>

<h4 id="toc_34">3．ENUM类型</h4>

<p>ENUM是一个字符串对象，其值为表创建时在字段规定中枚举的一列值</p>

<h4 id="toc_35">4．SET类型</h4>

<p>SET类型是一个字符串对象，可以有零或多个值，SET字段最大可以有64个成员，其值为表创建时规定的一列值。指定包括多个SET成员的SET字段值时，各成员之间用逗号隔开。</p>

<p>与ENUM类型相同，SET值在内部用整数表示，列表中每一个值都有一个索引编号。当创建表时，SET成员值的尾部空格将自动被删除。但与ENUM类型不同的是，ENUM类型的字段只能从定义的字段值中选择一个值插入，而SET类型的字段可从定义的列值中选择多个字符的联合。如果插入SET字段中的值有重复，则MySQL自动删除重复的值；插入SET字段的值的顺序不重要，MySQL会在存入数据库的时候，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL将忽视这些值，并给出相应警告。</p>

<h3 id="toc_36">二进制类型</h3>

<p>MySQL中的二进制数据类型有：BIT、BINARY、VARBINARY, TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB</p>

<table>
<thead>
<tr>
<th style="text-align: center">类型名称</th>
<th style="text-align: center">说明</th>
<th style="text-align: center">存储需求</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">BIT(M)</td>
<td style="text-align: center">位字段类型</td>
<td style="text-align: center">大约(M+7)/8个字节</td>
</tr>
<tr>
<td style="text-align: center">BINARY(M)</td>
<td style="text-align: center">固定长度的二进制字符串</td>
<td style="text-align: center">M个字节</td>
</tr>
<tr>
<td style="text-align: center">VARBINARY(M)</td>
<td style="text-align: center">可变长度的二进制字符串</td>
<td style="text-align: center">M+1个字节</td>
</tr>
<tr>
<td style="text-align: center">TINYBLOB(M)</td>
<td style="text-align: center">非常小的BLOB</td>
<td style="text-align: center">L+1个字节，此处L&lt;28</td>
</tr>
<tr>
<td style="text-align: center">BLOB(M)</td>
<td style="text-align: center">小BLOB</td>
<td style="text-align: center">L+2个字节，此处L&lt;216</td>
</tr>
<tr>
<td style="text-align: center">MEDIUMBLOB(M)</td>
<td style="text-align: center">中等大小的BLOB</td>
<td style="text-align: center">L+3个字节，此处L&lt;224</td>
</tr>
<tr>
<td style="text-align: center">LONGBLOB(M)</td>
<td style="text-align: center">非常大的BLOB</td>
<td style="text-align: center">L+4个字节，此处L&lt;232</td>
</tr>
</tbody>
</table>

<h4 id="toc_37">BIT类型</h4>

<p>上表中，BIT（M）为位字段类型，M表示每个值的位数，取值范围为1～64。如果M被省略，默认为1。如果为BIT（M）字段分配的值的长度小于M位，在值的左边用0填充。例如，为BIT（6）字段分配一个值b‘101&#39;，其效果与分配b‘000101’相同。BIT数据类型用来保存位字段值，例如，以二进制的形式保存十进制数据12,12的二进制形式为1100，在这里需要位数至少为4位的BIT类型，即可以定义字段类型BIT（4）。大于二进制1111的数据不能插入BIT（4）类型的字段中。</p>

<blockquote>
<p>提示<br/>
默认情况下，MySQL不可以插入超出该字段类型允许范围的值，如十进制数16，超出了BIT(4)的取值范围，系统报错。</p>
</blockquote>

<h4 id="toc_38">BINARY和VARBINARY类型</h4>

<p>BINARY和VARBINARY类型类似于CHAR和VARCHAR，不同的是它们包含二进制字符串。</p>

<p>其中，BINARY类型的长度是固定的，指定长度后，不足最大长度的，将在右边填充‘\0’补齐以达到指定长度。例如：指定字段数据类型为BINARY（4），当插入‘a’时，存储的内容实际为‘a\0\0\0&#39;,当插入‘ab’时，实际存储的内容为‘ab\0\0&#39;，不管存储的内容是否达到指定的长度，其存储空间均为指定的值M。</p>

<p>VARBINARY类型的长度是可变的，指定好长度后，其长度可以在0到最大值之间。例如，指定字段数据类型为VARBINARY（30），如果插入的值的长度只有20，则实际存储空间为20+1，即其实际占用的空间为字符串的实际长度加1。</p>

<h4 id="toc_39">BLOB类型</h4>

<p>BLOB类型是一个二进制大对象，用来存储可变数量的数据。BLOB类型分为4种：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB</p>

<table>
<thead>
<tr>
<th style="text-align: left">数据类型</th>
<th style="text-align: left">存储范围</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">TINYBLOB</td>
<td style="text-align: left">最大长度为255(2<sup>8</sup> - 1)个字节</td>
</tr>
<tr>
<td style="text-align: left">BLOB</td>
<td style="text-align: left">最大长度为65535(2<sup>16</sup> -1)字节</td>
</tr>
<tr>
<td style="text-align: left">MEDIUMBLOB</td>
<td style="text-align: left">最大长度为16777215(2<sup>24</sup> - 1)字节</td>
</tr>
<tr>
<td style="text-align: left">LONGBLOB</td>
<td style="text-align: left">最大长度为4294967295或4GB(2<sup>32</sup> - 1)字节</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RecyclerView源码解析]]></title>
    <link href="http://adolph.cc/15941143181398.html"/>
    <updated>2020-07-07T17:31:58+08:00</updated>
    <id>http://adolph.cc/15941143181398.html</id>
    <content type="html"><![CDATA[
<p>Recyclerview是一个功能强大、好用，但复杂的控件。虽然其功能高度解耦，但所有的代码放在一个RecyclerView文件里也有高达1W3千多行代码。按模块分析源码，可以提高我们理解和阅读源码的效率。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">RecyclerView类图</h2>

<p><img src="media/15941143181398/15951790156416.jpg" alt=""/></p>

<h2 id="toc_1">RecyclerView绘制流程图</h2>

<p><img src="media/15941143181398/15951790392948.jpg" alt=""/></p>

<h2 id="toc_2">RecyclerView滑动流程图</h2>

<p><img src="media/15941143181398/15951790559208.jpg" alt=""/></p>

<h2 id="toc_3">RecyclerView缓存介绍图</h2>

<p><img src="media/15941143181398/15951790783646.jpg" alt=""/></p>

<h2 id="toc_4">RecyclerView</h2>

<h3 id="toc_5">构造方法</h3>

<ul>
<li>进行View相关配置属性设置，触摸范围、滑动速度等</li>
<li>设置Item动画监听器</li>
<li>初始化AdapterManager，创建AdapterHelper（负责Adapter里的数据集发生变化时的预处理操作）</li>
<li>初始化ChildHelper（负责管理和访问 RecyclerView 的子视图）</li>
<li>如果配置了LayoutManager 则通过反射方法创建它</li>
</ul>

<pre><code class="language-java"> public RecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        ...
        // View配置相关属性设置
        final ViewConfiguration vc = ViewConfiguration.get(context);
        mTouchSlop = vc.getScaledTouchSlop();
        mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
        mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
        setWillNotDraw(getOverScrollMode() == View.OVER_SCROLL_NEVER);
        
        // 设置Item动画监听器
        mItemAnimator.setListener(mItemAnimatorListener);
        // 设置 AdapterManager
        initAdapterManager();
        // 设置 ChildrenHelper 
        initChildrenHelper();
        // 硬件加速相关属性设置
        if (ViewCompat.getImportantForAccessibility(this)
                == ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            ViewCompat.setImportantForAccessibility(this,
                    ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        mAccessibilityManager = (AccessibilityManager) getContext()
                .getSystemService(Context.ACCESSIBILITY_SERVICE);
        setAccessibilityDelegateCompat(new RecyclerViewAccessibilityDelegate(this));
        
        // 如果attrs指定了LayoutManager，则创建LayoutManager
        boolean nestedScrollingEnabled = true;
        
        if (attrs != null) {
            int defStyleRes = 0;
            TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,
                    defStyle, defStyleRes);
            String layoutManagerName = a.getString(R.styleable.RecyclerView_layoutManager);
            int descendantFocusability = a.getInt(
                    R.styleable.RecyclerView_android_descendantFocusability, -1);
            if (descendantFocusability == -1) {
                setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            }
            a.recycle();
            // 反射方法创建 LayoutManager
            createLayoutManager(context, layoutManagerName, attrs, defStyle, defStyleRes);

            if (Build.VERSION.SDK_INT &gt;= 21) {
                // SDK &gt;=21下 ，nestedScrollingEnabled状态支持变更
                a = context.obtainStyledAttributes(attrs, NESTED_SCROLLING_ATTRS,
                        defStyle, defStyleRes);
                nestedScrollingEnabled = a.getBoolean(0, true);
                a.recycle();
            }
        } else {
            setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
        }

        // 重置nestedScrollingEnabled状态 SDK 21以下默认true
        setNestedScrollingEnabled(nestedScrollingEnabled);
    }
</code></pre>

<h3 id="toc_6">setLayoutManager</h3>

<ul>
<li>处理重新设置一个新的LayoutManager的一些逻辑</li>
<li>设置this给到LayoutManager，并如果attach了则执行LayoutManger的attach分发实践</li>
<li>更新缓存大小，并请求重新布局</li>
</ul>

<pre><code class="language-java">public void setLayoutManager(LayoutManager layout) {
        if (layout == mLayout) {
            return;
        }
        stopScroll();
        // 设置新的layout情况下的一些处理逻辑
        ... 
        
        mChildHelper.removeAllViewsUnfiltered();
        mLayout = layout;
        if (layout != null) {
            // layout只能绑定一个mRecyclerView 
            if (layout.mRecyclerView != null) {
                throw new IllegalArgumentException(&quot;LayoutManager &quot; + layout +
                        &quot; is already attached to a RecyclerView: &quot; + layout.mRecyclerView);
            }
            // 设置this引用给LayoutManager
            mLayout.setRecyclerView(this);
            if (mIsAttached) {
                // 分发attach事件
                mLayout.dispatchAttachedToWindow(this);
            }
        }
        // 重新更新缓存大小 及请求重新布局
        mRecycler.updateViewCacheSize();
        requestLayout();
    }
</code></pre>

<h3 id="toc_7">setAdapter</h3>

<ul>
<li>接触frozen状态</li>
<li>设置新的Adapter，并触发一系列监听事件</li>
</ul>

<pre><code class="language-java">public void setAdapter(Adapter adapter) {
   // 解除frozen状态
   setLayoutFrozen(false);
   // 替换到当前Adapter，并触发监听
   setAdapterInternal(adapter, false, true);
   requestLayout();
}

private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious,
            boolean removeAndRecycleViews) {
        // 旧Adapter进行解绑数据监听 和 RecyclerView的引用
        if (mAdapter != null) {
            mAdapter.unregisterAdapterDataObserver(mObserver);
            mAdapter.onDetachedFromRecyclerView(this);
        }
        if (!compatibleWithPrevious || removeAndRecycleViews) {
            removeAndRecycleViews(); // 移除缓存的View
        }
        mAdapterHelper.reset();
        final Adapter oldAdapter = mAdapter;
        mAdapter = adapter;
        if (adapter != null) {
            // 处理新设置的Adapter的关联监听和RecyclerView
            adapter.registerAdapterDataObserver(mObserver);
            adapter.onAttachedToRecyclerView(this);
        }
        // 通知LayoutManager Adapter变更
        if (mLayout != null) {
            mLayout.onAdapterChanged(oldAdapter, mAdapter);
        }
        // 触发Recycler Adapter变更事件
        mRecycler.onAdapterChanged(oldAdapter, mAdapter, compatibleWithPrevious);
        // 状态置为 mStructureChanged 
        mState.mStructureChanged = true;
        markKnownViewsInvalid();
    }
</code></pre>

<h3 id="toc_8">onMeasure</h3>

<ul>
<li>未赋值layoutManager情况下，走默认measure，结果是无展示</li>
<li>系统提供的LayoutManager默认AutoMeasure。执行LayoutManger的onMeasure方法</li>
<li>如果未指定确定宽高的尺寸规格，则会进行布局，继而获得子View的大小。此过程可能执行两次</li>
</ul>

<pre><code class="language-java">   @Override
    protected void onMeasure(int widthSpec, int heightSpec) {
        // mLayout 是 LayoutManager，通过 setLayoutManager 方法设置，没有设置则为空
        if (mLayout == null) {
            defaultOnMeasure(widthSpec, heightSpec);
            return;
        }
        // 是否开启自动测量（RV 提供的几种 LM 都开启了自动测量）
        if (mLayout.isAutoMeasureEnabled()) {
            final int widthMode = MeasureSpec.getMode(widthSpec);
            final int heightMode = MeasureSpec.getMode(heightSpec);
            
            // 执行LayoutManager的onMeasure方法
            mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);

            final boolean measureSpecModeIsExactly =
                    widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY;
            // 如果测量模式是 EXACTLY，退出
            if (measureSpecModeIsExactly || mAdapter == null) {
                return;
            }

            // 布局状态为 STEP_START 时，进行 step1
            if (mState.mLayoutStep == State.STEP_START) {
                dispatchLayoutStep1();
            }

            mLayout.setMeasureSpecs(widthSpec, heightSpec);
            mState.mIsMeasuring = true;
            // 进行 step2
            dispatchLayoutStep2();

            mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);

            // 判断是否要测量两次
            if (mLayout.shouldMeasureTwice()) {
                mLayout.setMeasureSpecs(
                        MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY),
                        MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY));
                mState.mIsMeasuring = true;
                dispatchLayoutStep2();
                mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);
            }
        } else {
            // ...
        }
    }
</code></pre>

<p>RecyclerView 重写了 onMeasure 方法。该方法中，先判断是否有设置 LayoutManager，没有设置就执行 defaultOnMeasure。</p>

<p>设置了 LayoutManager 的话，就要判断 LayoutManager 是否开启了自动测量，开启的话就会使用默认的测量机制，否则就需要通过 LayoutManager 的 onMeasure 方法来完成测量工作。系统提供的几个 LayoutManager 都开启了自动测量。</p>

<p>自动测量时，涉及到一个重要的类：RecyclerView.State，这个类封装了当前 RecyclerView 的状态信息。其 mLayoutStep 变量表示当前 RecyclerView 的布局状态，状态有三种：</p>

<p>STEP_START<br/>
STEP_LAYOUT<br/>
STEP_ANIMATIONS<br/>
一开始的状态为 STEP_START，调用完 dispatchLayoutStep1 方法后，状态变为 STEP_LAYOUT，表示接下来要进行布局，调用完 dispatchLayoutStep2 方法后，状态变为 State.STEP_ANIMATIONS，等待之后在 layout 时执行 dispatchLayoutStep3</p>

<p>这三个 step 负责不同的工作，step1 负责更新和记录状态，step2 真正进行布局，step3 执行动画并进行清理工作。</p>

<p>可以看到，在开启自动测量时，RecyclerView 如果是 WRAP_CONTENT 状态，就要根据子 View 所占空间大小动态调整自己的大小，这时它就将子 View 的 measure 和 layout 提前到 onMeasure 中，因为它需要确定子 View 的大小和位置后，再来设置自己的大小。所以就会在 onMeasure 中执行 step1 和 step2。</p>

<p>接下来看一下 RecyclerView 的 layout 过程</p>

<h3 id="toc_9">onLayout</h3>

<ul>
<li>执行DispatchLayout方法</li>
<li>根据不同State状态，分别执行Step1、Step2、Step3方法</li>
</ul>

<pre><code class="language-java">    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);
        dispatchLayout();
        TraceCompat.endSection();
        mFirstLayoutComplete = true;
    }
</code></pre>

<p>调用 dispatchLayout</p>

<pre><code class="language-java">    void dispatchLayout() {
        // ...
        
        mState.mIsMeasuring = false;
        // 如果已经在 onMeasure 执行了 step1 和 step2，就不再执行 step1
        // 至于 step2，如果发现尺寸发生了改变，将会再执行一次
        if (mState.mLayoutStep == State.STEP_START) {
            dispatchLayoutStep1();
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth()
                || mLayout.getHeight() != getHeight()) {
            mLayout.setExactMeasureSpecsFrom(this);
            dispatchLayoutStep2();
        } else {
            mLayout.setExactMeasureSpecsFrom(this);
        }
        dispatchLayoutStep3();
    }
</code></pre>

<p>可以看到，如果已经在 onMeasure 执行了 step1 和 step2，就不再执行 step1，至于 step2，如果发现尺寸发生了改变，将会再执行一次，否则也不会执行。最后执行 step3。</p>

<p>下面分别看下这 3 个 step，首先看 step1</p>

<h4 id="toc_10">RecyclerView#dispatchLayoutStep1</h4>

<ul>
<li>第一步layout方法</li>
<li>处理adapter变更</li>
<li>确定需要执行的动画</li>
<li>针对当前的Views进行信息缓存</li>
<li>如有必要，则进行预布局并缓存信息</li>
</ul>

<pre><code class="language-java">    private void dispatchLayoutStep1() {
        //  State状态断言 
        mState.assertLayoutStep(State.STEP_START);
        mState.mIsMeasuring = false;
        // 是否过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1
        eatRequestLayout();
        // 清楚 ViewInfo 所有状态和其存在的数据
        mViewInfoStore.clear();
        // 执行进入 layout或者scroll行为标志
        onEnterLayoutOrScroll();        
        // （1）执行Adapter变更及计算那些需要执行的动画
        processAdapterUpdatesAndSetAnimationFlags();
        // 存储焦点信息
        saveFocusInfo();
        // state状态信息设置
        mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations &amp;&amp; mItemsChanged;
        mItemsAddedOrRemoved = mItemsChanged = false;
        mState.mInPreLayout = mState.mRunPredictiveAnimations;
        mState.mItemCount = mAdapter.getItemCount();
        // 寻找 layout过程中position的最大和最小值
        findMinMaxChildLayoutPositions(mMinMaxLayoutPositions);
        // （2）
        if (mState.mRunSimpleAnimations) {
            // ...
            int count = mChildHelper.getChildCount();
            for (int i = 0; i &lt; count; ++i) {
            // 遍历VieHolder
           final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));
           if (holder.shouldIgnore() || (holder.isInvalid() &amp;&amp; !mAdapter.hasStableIds())) {
               continue;
           }
           // 创建 ItemHolderInfo
           final ItemHolderInfo animationInfo = mItemAnimator
                   .recordPreLayoutInformation(mState, holder,
                           ItemAnimator.buildAdapterChangeFlagsForAnimations(holder),
                           holder.getUnmodifiedPayloads());
           // mViewInfoStore存储 holder及其对应animation信息
           mViewInfoStore.addToPreLayout(holder, animationInfo);
           if (mState.mTrackOldChangeHolders &amp;&amp; holder.isUpdated() &amp;&amp; !holder.isRemoved()
               // 如果holder确定要更新，就把它添加到 oldChangeHolders 集合中
               mViewInfoStore.addToOldChangeHolders(key, holder);
           }  
        }
        if (mState.mRunPredictiveAnimations) {
            // 运行预布局
            // ...
        }
        // 执行退出 layout或者scroll行为标志
        onExitLayoutOrScroll();
        // 对应 mEatRequestLayout -1
        resumeRequestLayout(false);
        // 状态进入 State.STEP_LAYOUT
        mState.mLayoutStep = State.STEP_LAYOUT;
    }
</code></pre>

<p>先看注释（2），这里会根据 mRunSimpleAnimations 和 mRunPredictiveAnimations 的值来决定是否运行简单动画和预动画。这两个值是在哪里设置的呢？答案是在注释（1）的 processAdapterUpdatesAndSetAnimationFlags 方法处</p>

<h4 id="toc_11">RecyclerView#processAdapterUpdatesAndSetAnimationFlags</h4>

<pre><code class="language-java">    private void processAdapterUpdatesAndSetAnimationFlags() {
        // ...
        
        // mItemsAddedOrRemoved：当有 item 添加或删除的时候设置为 ture
        // mItemsChanged：当有 item 的数据更新时设置为 true
        boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged;
        
        // 1. mFirstLayoutComplete：第一次 layout 完成后，设置为 true
        // 2. mItemAnimator：默认为 DefaultItemAnimator，可通过 RecyclerView 的 setItemAnimator 方法设置
        // 3. mDataSetHasChangedAfterLayout：调用 setAdapter、swapAdapter 或 notifyDateSetChanged 
        // 后设置为 true，在 layout 过程的 step3 中设置为 false
        // 4. mLayout.mRequestedSimpleAnimations：默认为 false，
        // 可以通过调用 LayoutManager 的 requestSimpleAnimationsInNextLayout 方法将该值设置为 true
        // 5. mAdapter.hasStableIds：默认为 false，可通过 Adapter 的 setHasStableIds 方法设置
        mState.mRunSimpleAnimations = mFirstLayoutComplete
                &amp;&amp; mItemAnimator != null
                &amp;&amp; (mDataSetHasChangedAfterLayout
                || animationTypeSupported
                || mLayout.mRequestedSimpleAnimations)
                &amp;&amp; (!mDataSetHasChangedAfterLayout
                || mAdapter.hasStableIds());
                
        // predictiveItemAnimationsEnabled：LinearLayoutManager 默认支持预动画，返回 true
        mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations
                &amp;&amp; animationTypeSupported
                &amp;&amp; !mDataSetHasChangedAfterLayout
                &amp;&amp; predictiveItemAnimationsEnabled();
    }
</code></pre>

<p>里面的一些属性在注释中已经有说明。这里以第一次 layout 为例，此时由于第一次 layout 过程还未完成，mFirstLayoutComplete 为 false，mRunSimpleAnimations 也就为 false，进而 mRunPredictiveAnimations 也为 false。</p>

<p>所以在第一次 layout 中，并不会进行简单动画和预动画。这里就先不分析了，详细过程在分析动画的时候再说。</p>

<p>下面重点看一下 step2</p>

<h4 id="toc_12">RecyclerView#dispatchLayoutStep2</h4>

<ul>
<li>执行最终的View布局操作，该过程由LayoutManager完成</li>
<li>该方法可能会被多次执行</li>
</ul>

<pre><code class="language-java">private void dispatchLayoutStep2() {
   // 过滤掉 RequestLayout执行，需要过滤的时候 执行该方法，会使过滤次数+1。对应resumeRequestLayout方法进行消费
   eatRequestLayout();
   // 对应 onExitLayoutOrScroll
   onEnterLayoutOrScroll();
   mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS);
   // 跳过预处理过程，一次性执行完所有的update
   mAdapterHelper.consumeUpdatesInOnePass();
   mState.mItemCount = mAdapter.getItemCount(); // 赋值 itemCOunt
   mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; 

   
   mState.mInPreLayout = false;
   // 执行 layout （执行 LayoutManager 布局）
   mLayout.onLayoutChildren(mRecycler, mState);

   mState.mStructureChanged = false;
   mPendingSavedState = null;
   mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null;
   // State状态进入 State.STEP_ANIMATIONS
   mState.mLayoutStep = State.STEP_ANIMATIONS;
   // 对应 onExitLayoutOrScroll
   onExitLayoutOrScroll();
   // 对应eatRequestLayout方法
   resumeRequestLayout(false);
}
</code></pre>

<p>step2 进行真正的布局，布局任务交由 LayoutManager 负责，调用其 onLayoutChildren 方法为所有子 View 布局。该方法交由具体的 LayoutManager 实现，这里以 LinearLayoutManager 为例，看一下它的 onLayoutChildren 实现</p>

<h4 id="toc_13">LinearLayoutManager#onLayoutChildren</h4>

<ul>
<li>Child布局执行核心方法</li>
<li>布局方式，通过确定锚点，首先以锚点为基准上到下布局，在以锚点为基准从下往上布局。如果还有空间，继续从上到下布局。最后确认整个间隙是正确的。（反向布局及横向反之则可）</li>
<li>该方法为LayoutManager布局核心执行方法，Child的测量和添加工作在fill这个重要方法执行，接下来会阐述</li>
</ul>

<pre><code class="language-java">    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // 确定是否需要反向布局
        // 确定锚点及偏移量 (1. 优先焦点child 2. 如果是反向布局，则找recycler里面最最接近尾部的child 3. 如果是正向，则找最接近头部的child)
        // 计算额外的偏移量（RecyclerView padding） 
        // ...

        // AnchorInfo 的 mValid 属性默认为 false 
        if (!mAnchorInfo.mValid || mPendingScrollPosition != RecyclerView.NO_POSITION
                || mPendingSavedState != null) {
            mAnchorInfo.reset();
            // mShouldReverseLayout 和 mStackFromEnd 默认都为 false
            // 异或操作后结果仍为 false
            mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
            // 找到锚点的位置，保存到 AnchorInfo 的 mPosition 中
            updateAnchorInfoForLayout(recycler, state, mAnchorInfo);
            mAnchorInfo.mValid = true;
        }

        // ...
        
        // 锚点准备ready        
       onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
        // （1）临时 detach和回收当前的view 第一次 measure 的时候不会产生效果，因为此时 RecyclerView 还没有子 View。 而在第二第三次 layout 时，它会把子 View 从 RecyclerView 中 remove 或 detach ，并缓存子 View，以便之后重新 add 回来或 attach 回来，避免重复加载相同的子 View
        detachAndScrapAttachedViews(recycler);
        mLayoutState.mInfinite = resolveIsInfinite(); 
        mLayoutState.mIsPreLayout = state.isPreLayout();        
        
        // 开始填充view
        if (mAnchorInfo.mLayoutFromEnd) {
            // 反向填充
            // ...
        } else {
            // 正向填充
            // （基于锚点位置先 由上到下||由左到右）更新锚点信息
            updateLayoutStateToFillEnd(mAnchorInfo);
            // 额外的尾部偏移量
            mLayoutState.mExtra = extraForEnd;
            // 开始填充 View布局主要方法
            fill(recycler, mLayoutState, state, false);
            // 尾部位移
           endOffset = mLayoutState.mOffset;
           final int lastElement = mLayoutState.mCurrentPosition;
           if (mLayoutState.mAvailable &gt; 0) {
               extraForStart += mLayoutState.mAvailable;
           }

            // （基于锚点位置 由下到上||由右到左）更新锚点信息
            updateLayoutStateToFillStart(mAnchorInfo);
            mLayoutState.mExtra = extraForStart;
            mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
            // 二次填充
            fill(recycler, mLayoutState, state, false);
            startOffset = mLayoutState.mOffset;
           // 仍有可用空间
           if (mLayoutState.mAvailable &gt; 0) {
               extraForEnd = mLayoutState.mAvailable;
               // 继续 （基于锚点位置先 由上到下||由左到右）更新信息并填充View
               updateLayoutStateToFillEnd(lastElement, endOffset);
               mLayoutState.mExtra = extraForEnd;
               fill(recycler, mLayoutState, state, false);
               endOffset = mLayoutState.mOffset;
           }
        }
        // 有滑动位置导致的gap间隙修复处理
       ...
       // 预布局动画处理
       ...
    }
</code></pre>

<p>注释（1）处调用了 detachAndScrapAttachedViews 方法，该方法会将子 View 移除并根据情况添加到相应缓存中。所以如果不是第一次 layout，RecyclerView 已经存在子 View 的话，在重新填充布局前，会将旧的子 View 添加到缓存中，这样之后填充布局时就可以直接从缓存中拿，不用再次创建子 View。</p>

<p>下面看下布局过程，主要分两步</p>

<h5 id="toc_14">1. 找到锚点（auchor 点）</h5>

<p>该过程通过 updateAnchorInfoForLayout 方法实现</p>

<h6 id="toc_15">updateAnchorInfoForLayout</h6>

<pre><code class="language-java">    private void updateAnchorInfoForLayout(RecyclerView.Recycler recycler, RecyclerView.State state,
            AnchorInfo anchorInfo) {
        // 一般这里都是返回 false
        if (updateAnchorFromPendingData(state, anchorInfo)) {
            return;
        }
        
        // 首先从子 View 中获取锚点
        if (updateAnchorFromChildren(recycler, state, anchorInfo)) {
            return;
        }

        // 没有从子 View 得到锚点，就将头或尾设置为锚点（默认将头设置为锚点）
        anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - 1 : 0;
    }
</code></pre>

<p>继续看下 updateAnchorFromChildren 方法，该方法从子 View 中获取锚点</p>

<h6 id="toc_16">updateAnchorFromChildren</h6>

<pre><code class="language-java">    private boolean updateAnchorFromChildren(RecyclerView.Recycler recycler,
            RecyclerView.State state, AnchorInfo anchorInfo) {
        if (getChildCount() == 0) {
            return false;
        }
        // 将被 focus 的子 View 作为锚点
        final View focused = getFocusedChild();
        if (focused != null &amp;&amp; anchorInfo.isViewValidAsAnchor(focused, state)) {
            anchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
            return true;
        }
        
        if (mLastStackFromEnd != mStackFromEnd) {
            return false;
        }
        
        // 根据 layout 的方向决定锚点，默认从上往下，所以锚点在头部
        View referenceChild = anchorInfo.mLayoutFromEnd
                ? findReferenceChildClosestToEnd(recycler, state)
                : findReferenceChildClosestToStart(recycler, state);
        if (referenceChild != null) {
            anchorInfo.assignFromView(referenceChild, getPosition(referenceChild));
            // ...
            return true;
        }
        return false;
    }
</code></pre>

<p>可以看到，优先选择被 focus 的子 View 作为锚点，没有的话就根据布局方向决定锚点，默认从上往下布局，所以锚点选取头部。</p>

<p>如果想要从下往上布局，可以这样设置</p>

<pre><code class="language-java">    linearLayoutManager.setStackFromEnd(true);
</code></pre>

<p>这样的话，锚点会在尾部，数据加载完后首先显示的是底部的数据。</p>

<h5 id="toc_17">2. 填充布局</h5>

<p>根据布局方向，先后填充满锚点上方和下方的所有区域</p>

<p>填充的过程调用 fill 方法</p>

<h6 id="toc_18">fill</h6>

<ul>
<li>如果是滑动流程，则根据情况进行回收流程</li>
<li>LayoutState中部分成员变量含义，mOffset：填充起始坐标，mCurrentPosition：填充起始数据的position，mAvailable：本次滑动可填充的距离，mScrollingOffset：滑动过的总量循环依次加载子View</li>
<li>确定可布局大小，直至布局大小消费完成</li>
<li>加载子View在 layoutChunk 中执行</li>
</ul>

<pre><code class="language-java">    int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {
        // ...
        // 可布局的位移
        final int start = layoutState.mAvailable;
        // 滑动偏移的情况下        
        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            if (layoutState.mAvailable &lt; 0) {
                layoutState.mScrollingOffset += layoutState.mAvailable;
            }
            // 进行回收工作
            recycleByLayoutState(recycler, layoutState);
        }
        // 余量大小
        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
        // 每次布局结果中间记录 方便运算  
        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
        while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) {
            // ...
            layoutChunkResult.resetInternal();
            // （1）加载子View
            layoutChunk(recycler, state, layoutState, layoutChunkResult);

            if (layoutChunkResult.mFinished) {
                break;
            }
       
            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;
            // 计算布局使用过的大小值
            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null
               || !state.isPreLayout()) {
                layoutState.mAvailable -= layoutChunkResult.mConsumed;
                remainingSpace -= layoutChunkResult.mConsumed;
            }
            // 如果当前正在滚动屏幕
            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;
                if (layoutState.mAvailable &lt; 0) {
                    layoutState.mScrollingOffset += layoutState.mAvailable;
                }
                // 把移出屏幕的 View 缓存到 mCachedViews 里面
                recycleByLayoutState(recycler, layoutState);
            }
            if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) {
                break;
            }
        }
        return start - layoutState.mAvailable;
    }
</code></pre>

<p>看注释（1）处，在 while 循环里有一个 layoutChunk 方法，只要还有剩余空间，就不会不断执行该方法</p>

<h6 id="toc_19">layoutChunk</h6>

<ul>
<li>通过layoutState.next(recycler)获取目标布局View</li>
<li>获取目标View完毕后，进行含装饰的Margin计算，并执行布局</li>
</ul>

<pre><code class="language-java">    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,LayoutState layoutState, LayoutChunkResult result) {
        // （1） 获取下一个布局View （核心方法）
        View view = layoutState.next(recycler);

        // ...
        
        // 除非特殊指定，否则mScrapList为null
        LayoutParams params = (LayoutParams) view.getLayoutParams();
        if (layoutState.mScrapList == null) {
            // mShouldReverseLayout 默认为 false，可通过 LLM 的 setReverseLayout 方法设置
            // 从上往下填充布局时，layoutState.mLayoutDirection 为 LayoutState.LAYOUT_END
            // 默认情况下，从上往下布局时进入 if 块
            if (mShouldReverseLayout == (layoutState.mLayoutDirection
                    == LayoutState.LAYOUT_START)) {
                // （2）添加到末尾
                addView(view);
            } else {
                // 添加到第一个位置
                addView(view, 0);
            }
        } else {
            // ...
        }

        measureChildWithMargins(view, 0, 0); // 测量子View的Margins
        // 计算 含装饰的Margin值的大小
        result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);
        int left, top, right, bottom;
        // 计算 r、l、t、b的值
        if (mOrientation == VERTICAL) {
            if (isLayoutRTL()) {
                right = getWidth() - getPaddingRight();
                left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);
            } else {
                left = getPaddingLeft();
                right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);
            }
            if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
                bottom = layoutState.mOffset;
                top = layoutState.mOffset - result.mConsumed;
            } else {
                top = layoutState.mOffset;
                bottom = layoutState.mOffset + result.mConsumed;
            }
        } else {
            ...
        }
        
        // 对View进行布局
        layoutDecoratedWithMargins(view, left, top, right, bottom);
        // 部分状态改变 
        if (params.isItemRemoved() || params.isItemChanged()) {
            result.mIgnoreConsumed = true;
        }
        result.mFocusable = view.hasFocusable();
    }
</code></pre>

<p>先看注释（1）处，这里返回下一个要填充的 View，来看下具体过程</p>

<pre><code class="language-java">    View next(RecyclerView.Recycler recycler) {
        // ...
        // 除非定制View，不然为null
        if (mScrapList != null) { 
            return nextViewFromScrapList();
        }
        //通过RecyclerView.Recycler 获取目标position对应的View
        final View view = recycler.getViewForPosition(mCurrentPosition);
        // 当前pos 增加
        mCurrentPosition += mItemDirection;
        return view;
    }
</code></pre>

<p>可以看到，获取 View 的工作也是交给了 Recycler，通过 Recycler 的 getViewForPosition 来获取一个指定位置的子 View，该方法在 Recycler 已经分析过了。</p>

<p>继续看注释（2）处的 addView 方法</p>

<pre><code class="language-java">    private void addViewInt(View child, int index, boolean disappearing) {
        final ViewHolder holder = getChildViewHolderInt(child);
        
        // ...
        
        // 该 ViewHolder 从 ChangedScrap、AttachedScrap、HiddenViews 中得到
        // 或者该 ViewHolder 曾经通过 scrapView 方法缓存到 Scrap 缓存中 
        if (holder.wasReturnedFromScrap() || holder.isScrap()) {
            // 做些清理工作：删除 Scrap 缓存、清除标记等
            if (holder.isScrap()) {
                holder.unScrap();
            } else {
                holder.clearReturnedFromScrapFlag();
            }
            // 子 View 重新 attach 到 RecyclerView 中
            mChildHelper.attachViewToParent(child, index, child.getLayoutParams(), false);
            // DISPATCH_TEMP_DETACH：该值默认为 false，且没看到有地方将其设置为 true
            if (DISPATCH_TEMP_DETACH) {
                ViewCompat.dispatchFinishTemporaryDetach(child);
            }
        } 
        // 该子 View 一直是有效的，只是可能要移动下位置（对应滑动时没有滑出屏幕的子 View）
        else if (child.getParent() == mRecyclerView) {
            int currentIndex = mChildHelper.indexOfChild(child);
            if (index == -1) {
                index = mChildHelper.getChildCount();
            }
            // 将该子 View 移动到正确位置
            if (currentIndex != index) {
                mRecyclerView.mLayout.moveView(currentIndex, index);
            }
        } 
        // 其他情况，例如从 CahcedView 或 RecycledViewPool 得到的缓存 View，或者是新创建的 View
        else {
            mChildHelper.addView(child, index, false);
            lp.mInsetsDirty = true;
            if (mSmoothScroller != null &amp;&amp; mSmoothScroller.isRunning()) {
                mSmoothScroller.onChildAttachedToWindow(child);
            }
        }
        
        // ...
    }
</code></pre>

<p>该方法通过判断 View 的来源，利用不同的方式将子 View 添加到 RecyclerView 中，填充完布局。</p>

<p>最后看一下 step3</p>

<h4 id="toc_20">dispatchLayoutStep3</h4>

<p>layout过程最后一步，执行相关动画和一些清理事项</p>

<pre><code class="language-java">    private void dispatchLayoutStep3() {
        // ...
        
        // 将 layout 状态重置回 State.STEP_START
        mState.mLayoutStep = State.STEP_START;
        
        // 执行动画
        if (mState.mRunSimpleAnimations) {
            // ...
        }

        // 清空 attachedScrap
        mLayout.removeAndRecycleScrapInt(mRecycler);
        // 重置一系列的变量
        mState.mPreviousLayoutItemCount = mState.mItemCount;
        mDataSetHasChangedAfterLayout = false;
        mDispatchItemsChangedEvent = false;
        mState.mRunSimpleAnimations = false;

        mState.mRunPredictiveAnimations = false;
        mLayout.mRequestedSimpleAnimations = false;
        // 清空 changedScrao
        if (mRecycler.mChangedScrap != null) {
            mRecycler.mChangedScrap.clear();
        }

        // 其它清理工作
    }
</code></pre>

<p>step3 主要是执行动画和进行一系列的清理工作，例如重置 layout 状态，清理 Scrap 缓存等等。由于在第一次布局时，mState.mRunSimpleAnimations 为 false，不会执行动画，动画部分就先不分析了。</p>

<h4 id="toc_21">小结</h4>

<p>前面说了这么多，这里小结一下 onLayout 的过程：</p>

<p>layout 过程分为 3 个 step，step1 负责更新和记录状态，step2 真正进行布局，step 执行动画并进行清理工作。如果 RecyclerView 的宽高为 WRAP_CONTENT 模式，那么需要在 measure 过程提前进行 step1 和 step2，先获得子 View 的大小，才能确定自己的大小。而 step3 肯定是在 layout 过程执行。<br/>
step2 真正进行布局，布局任务由 LayoutManager 负责，通过它的 onLayoutChildren 方法对子 View 进行布局。布局过程分两步：<br/>
找到锚点，优先选择被 focus 的子 View 作为锚点，没有的话就根据布局方向决定锚点，默认头部为锚点。<br/>
根据布局方向，先后填充满锚点上方和下方的区域，填充所需的 View 交由 Recycler 提供。</p>

<h3 id="toc_22">draw</h3>

<ul>
<li>绘制ItemDecoration的onDraw部分</li>
<li>绘制Children</li>
<li>绘制ItemDecoration的drawOver部分</li>
<li>根据mClipToPadding的值来判断是否进行特殊绘制。</li>
</ul>

<p>主要涉及Item装饰的绘制和动画</p>

<pre><code class="language-java">public void draw(Canvas c) {
   super.draw(c);

   final int count = mItemDecorations.size();
   for (int i = 0; i &lt; count; i++) {
       mItemDecorations.get(i).onDrawOver(c, this, mState);
   }
  
   boolean needsInvalidate = false;
   ...
   if (!needsInvalidate &amp;&amp; mItemAnimator != null &amp;&amp; mItemDecorations.size() &gt; 0 &amp;&amp;
           mItemAnimator.isRunning()) {
       needsInvalidate = true;
   }

   if (needsInvalidate) {
       ViewCompat.postInvalidateOnAnimation(this);
   }
}
    
public void onDraw(Canvas c) {
   super.onDraw(c);

   final int count = mItemDecorations.size();
   for (int i = 0; i &lt; count; i++) {
       mItemDecorations.get(i).onDraw(c, this, mState);
   }
}
</code></pre>

<h2 id="toc_23">Recycler</h2>

<blockquote>
<p>A Recycler is responsible for managing scrapped or detached item views for reuse.</p>
</blockquote>

<p>意思就是 Recycler 负责管理废弃或被 detached 的 item 视图，以便重复利用。</p>

<h3 id="toc_24">主要成员变量</h3>

<pre><code class="language-java">final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();

ArrayList&lt;ViewHolder&gt; mChangedScrap = null;

final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();

RecycledViewPool mRecyclerPool;

private ViewCacheExtension mViewCacheExtension;
</code></pre>

<p>这几个成员变量都和 RecyclerView 的缓存相关，如果按照四级缓存的话，它们可以这样划分:</p>

<blockquote>
<p>第一级缓存：mAttachedScrap、mChangedScrap<br/>
第二级缓存：mCachedViews<br/>
第三级缓存：ViewCacheExtension<br/>
第四级缓存：RecycledViewPool</p>
</blockquote>

<h4 id="toc_25">RecycledViewPool</h4>

<blockquote>
<p>RecycledViewPool lets you share Views between multiple RecyclerViews.</p>
</blockquote>

<p>RecycledViewPool 用于在多个 RecyclerView 间共享 View。</p>

<p>在使用时，只需创建 RecycledViewPool 实例，然后调用 RecyclerView 的 setRecycledViewPool(RecycledViewPool) 方法即可。</p>

<p>RecycledViewPool 存储在 Recycler 中，通过 Recycler 存取。</p>

<h5 id="toc_26">成员变量</h5>

<p>RecycledViewPool 有一个重要的成员变量</p>

<pre><code class="language-java">// SparseArray 类似于 key 为 int 类型 的 HashMap
SparseArray&lt;ScrapData&gt; mScrap = new SparseArray&lt;&gt;();
</code></pre>

<pre><code class="language-java">static class ScrapData {
    final ArrayList&lt;ViewHolder&gt; mScrapHeap = new ArrayList&lt;&gt;();
    int mMaxScrap = DEFAULT_MAX_SCRAP;
    long mCreateRunningAverageNs = 0;
    long mBindRunningAverageNs = 0;
}
</code></pre>

<p>mScrap 是一个 <int, ScrapData> 的映射，其中 int 代表了 viewType，ScrapData 则存储了一个 ViewHolder 集合。</p>

<h5 id="toc_27">主要方法</h5>

<p><code>getScrapDataForType</code>: 该方法根据 viewType 获取相应的 ScrapData，如果该 viewType 还没有绑定 ScrapData，就新创建一个 ScrapData 并绑定到该 viewType。</p>

<pre><code class="language-java">private ScrapData getScrapDataForType(int viewType) {
    ScrapData scrapData = mScrap.get(viewType);
    if (scrapData == null) {
        scrapData = new ScrapData();
        mScrap.put(viewType, scrapData);
    }
    return scrapData;
}
</code></pre>

<p><code>setMaxRecycledViews</code>: 该方法可以设置相应 viewType 的 View 容量，超出容量时，从后面开始删除，直到满足新的容量。</p>

<pre><code class="language-java">public void setMaxRecycledViews(int viewType, int max) {
    ScrapData scrapData = getScrapDataForType(viewType);
    scrapData.mMaxScrap = max;
    final ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;
    // 从后面开始删除，直到满足新的容量
    while (scrapHeap.size() &gt; max) {
        scrapHeap.remove(scrapHeap.size() - 1);
    }
}
</code></pre>

<p><code>getRecycledView</code>: 该方法根据 viewType 获取一个 ViewHolder，获取到的 ViewHolder 将会被移除出 Scrap 堆。获取不到则返回 null。</p>

<pre><code class="language-java">@Nullable
public ViewHolder getRecycledView(int viewType) {
    final ScrapData scrapData = mScrap.get(viewType);
    if (scrapData != null &amp;&amp; !scrapData.mScrapHeap.isEmpty()) {
        final ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap;
        for (int i = scrapHeap.size() - 1; i &gt;= 0; i--) {
            if (!scrapHeap.get(i).isAttachedToTransitionOverlay()) {
                return scrapHeap.remove(i);
            }
        }
    }
    return null;
}
</code></pre>

<p><code>putRecycledView</code>: 该方法也很好理解，根据 ViewHolder 的 viewType 放入 RecycledViewPool 的相应集合中，如果集合已满，不再添加。</p>

<pre><code class="language-java">public void putRecycledView(ViewHolder scrap) {
    final int viewType = scrap.getItemViewType();
    final ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap;
    if (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) {
        return;
    }
    if (DEBUG &amp;&amp; scrapHeap.contains(scrap)) {
        throw new IllegalArgumentException(&quot;this scrap item already exists&quot;);
    }
    scrap.resetInternal();
    scrapHeap.add(scrap);
}
</code></pre>

<h4 id="toc_28">ViewCacheExtension</h4>

<p>ViewCacheExtension 是一个由开发者控制的 View 缓存帮助类</p>

<pre><code class="language-java">public abstract static class ViewCacheExtension {
    /**
      * Returns a View that can be binded to the given Adapter position.
      */
    @Nullable
    public abstract View getViewForPositionAndType(@NonNull Recycler recycler, int position,int type);
}
</code></pre>

<p>开发者可以实现这个抽象类，通过调用 RecyclerView 的 setViewCacheExtension(ViewCacheExtension) 方法设置，最终将 ViewCacheExtension 存储在 Recycler 中。</p>

<p>当调用 Recycler 的 getViewForPosition 方法时，如果 attached scrap 和 已经缓存都没有找到合适的 View，就会调用 ViewCacheExtension 的 getViewForPositionAndType 方法来获取 View。</p>

<p>需要注意的是，Recycler 不会对这个类做任何缓存处理，是否需要缓存 View 由开发者自己控制。</p>

<h3 id="toc_29">主要方法</h3>

<h4 id="toc_30">getViewForPosition</h4>

<p>getViewForPosition 方法比较重要，用于获取某个位置需要展示的 View,最终执行tryGetViewHolderForPositionByDeadline获取View</p>

<pre><code class="language-java">public View getViewForPosition(int position) {
    return getViewForPosition(position, false);
}
    
View getViewForPosition(int position, boolean dryRun) {
    return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;
}
</code></pre>

<p>继续看 tryGetViewHolderForPositionByDeadline 方法，该方法会依次从几个缓存中获取</p>

<h4 id="toc_31">tryGetViewHolderForPositionByDeadline</h4>

<ul>
<li>获取ViewHolder方法</li>
<li>如果是预布局，线通过ChangeScrap中获取</li>
<li>第一次尝试获取VH，依次从Scrap、Hidden、Cache中获取VH</li>
<li>第二次尝试获取VH，针对具有StableId的Adapter，根据id依次从Scrap和Cache获取</li>
<li>第三次尝试从自定义缓存中获取VH</li>
<li>第四次尝试从Recycler获取VH</li>
<li>最后直接创建VH</li>
</ul>

<pre><code class="language-java">ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
    boolean fromScrapOrHiddenOrCache = false;
    ViewHolder holder = null;
    // 0) 如果是预布局， 从mChangedScrap中获取 
    if (mState.isPreLayout()) {
        holder = getChangedScrapViewForPosition(position);
        fromScrapOrHiddenOrCache = holder != null;
    }
    // 1) 第一次尝试获取，依次从Scrap、Hidden、Cache中获取VH
    if (holder == null) {
        // 依次从Scrap、Hidden、Cache中获取VH
        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
        //... 
    }
    if (holder == null) {
        final int offsetPosition = mAdapterHelper.findPositionOffset(position);
        final int type = mAdapter.getItemViewType(offsetPosition);
        // 2) 第二次尝试获取，当Adapter具备StableIds情况
        if (mAdapter.hasStableIds()) {
            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                  type, dryRun);
            if (holder != null) {
                // update position
                holder.mPosition = offsetPosition;
                fromScrapOrHiddenOrCache = true;
            }
        }
        // 3) 第三次尝试从 自定义缓存获取
        if (holder == null &amp;&amp; mViewCacheExtension != null) {
            final View view = mViewCacheExtension
                  .getViewForPositionAndType(this, position, type);
            if (view != null) {
                holder = getChildViewHolder(view);
                //...
            }
        }
        // 4) 第四次尝试 从 RecyclerPool中获取
        if (holder == null) { // fallback to pool
            holder = getRecycledViewPool().getRecycledView(type);
            //...
        }
        // 5) 开始创建
        if (holder == null) {
            long start = getNanoTime();
            // 创建VH
            holder = mAdapter.createViewHolder(RecyclerView.this, type);
            //... 
        }
      
        boolean bound = false;
        if (mState.isPreLayout() &amp;&amp; holder.isBound()) {
            holder.mPreLayoutPosition = position;
        } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
            // 为bind过，执行bind方法
            final int offsetPosition = mAdapterHelper.findPositionOffset(position);
            bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
       }
    }

    private boolean tryBindViewHolderByDeadline(ViewHolder holder, int offsetPosition, int position, long deadlineNs) {
        //...
        // 执行Adapter bindViewHolder方法
        mAdapter.bindViewHolder(holder, offsetPosition);
        //...
        return true;
    }
</code></pre>

<pre><code class="language-java">    // 如果是处于预布局阶段（先简单理解为执行 dispatchLayoutStep1 方法）
    // （其实下面方法要返回 ture 还需要开启“预处理动画”，这跟动画有关，先不多说）
    if (mState.isPreLayout()) {
        holder = getChangedScrapViewForPosition(position);
        fromScrapOrHiddenOrCache = holder != null;
    }
</code></pre>

<h5 id="toc_32">第一步 从 mChangedScrap 中获取，获取不到就返回 null。</h5>

<p>针对的是预布局状态，从mChangedScrap中获取目标ViewHolder<br/>
ScrapView：View仍然attach在其父RecyclerView上且可以被重复绑定数据及重复使用。将View标记为Scrap过程中分为两大类mAttachedScrap 和 mChangedScrap。<br/>
mAttachedScrap：VH有ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID这两个Flag，或者VH是没有被更新过的，或者是可以被重新更新的VH。<br/>
其它则是mChangedScrap</p>

<pre><code class="language-java">ViewHolder getChangedScrapViewForPosition(int position) {
  // 必须是预布局状态，取mChangedScrap中的ViewHolder
  final int changedScrapSize;
  if (mChangedScrap == null || (changedScrapSize = mChangedScrap.size()) == 0) {
      return null;
  }
  // 通过position获取
  for (int i = 0; i &lt; changedScrapSize; i++) {
      final ViewHolder holder = mChangedScrap.get(i);
      if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position) {
          holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
          return holder;
      }
  }
  // 如果Adapter是固定id，尝试从Adapter获取
  if (mAdapter.hasStableIds()) {
      final int offsetPosition = mAdapterHelper.findPositionOffset(position);
      if (offsetPosition &gt; 0 &amp;&amp; offsetPosition &lt; mAdapter.getItemCount()) {
          final long id = mAdapter.getItemId(offsetPosition);
          for (int i = 0; i &lt; changedScrapSize; i++) {
              final ViewHolder holder = mChangedScrap.get(i);
              if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getItemId() == id) {
                  holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
                  return holder;
              }
          }
      }
  }
  return null;
}

// Mark an attached view as scrap.
void scrapView(View view) {
       final ViewHolder holder = getChildViewHolderInt(view);
       if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
               || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
           holder.setScrapContainer(this, false);
           mAttachedScrap.add(holder);
       } else {
           if (mChangedScrap == null) {
               mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
           }
           holder.setScrapContainer(this, true);
           mChangedScrap.add(holder);
       }
}
</code></pre>

<h5 id="toc_33">第二步 第一次尝试获取VH（AttachScrap、Hidden、CacheView）</h5>

<p>根据 position 依次从 mAttachedScrap、mHiddenViews（存储在 ChildHelper 类）、mCachedViews 中获取缓存的 ViewHolder。</p>

<p>可以从 mHiddenViews 获取到缓存的话，就将其从 mHiddenViews 移除并添加到 Scrap 缓存（根据情况添加到 mAttachedScrap 或 mChangedScrap）。可以从 mCacheViews 中获取到缓存的话，就将其从 mCacheViews 移除。</p>

<p>获取到后，发现无效的话，将对获取到的 ViewHolder 进行清理并回收（放入 mCachedViews 或 RecycledViewPool）。</p>

<ul>
<li>先从 mAttachedScrap中获取VH</li>
<li>从隐藏且未移出的View中获取 View</li>
<li>从一级缓存CacheView中获取</li>
</ul>

<pre><code class="language-java">ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) {
       final int scrapCount = mAttachedScrap.size();

       // 先从 mAttachedScrap中获取VH
       for (int i = 0; i &lt; scrapCount; i++) {
           final ViewHolder holder = mAttachedScrap.get(i);
           // 验证VH是否可用，若可用，则直接返回该VH
           if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position
                   &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved())) {
               holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP);
               return holder;
           }
       }
       // dryRun 传递是false（代表VH在scrap、cache中可以被Removed）
       if (!dryRun) {
           // 从隐藏且未移出的View中获取 View
           View view = mChildHelper.findHiddenNonRemovedView(position);
           if (view != null) {
               // View可用，则进行可视、detach、scrap缓存
               final ViewHolder vh = getChildViewHolderInt(view);
               mChildHelper.unhide(view);
               int layoutIndex = mChildHelper.indexOfChild(view);
               mChildHelper.detachViewFromParent(layoutIndex);
               scrapView(view);
               vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP
                       | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST);
               return vh;
           }
       }

       // 从第一级缓存View中获取
       final int cacheSize = mCachedViews.size();
       for (int i = 0; i &lt; cacheSize; i++) {
           final ViewHolder holder = mCachedViews.get(i);
           // VH是有效的
           if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) {
               if (!dryRun) {
                   mCachedViews.remove(i); // 移出获取的cache
               }
               return holder; // 返回VH
           }
       }
       return null;
}
</code></pre>

<h5 id="toc_34">第三步 第二次尝试获取VH（Adapter有稳定id情况）</h5>

<ul>
<li>Adapter配置的id是稳定的，稳定指数据集变化的时候，对于同一数据对应的id是唯一的</li>
<li>先尝试从Scrap获取VH，非dryRun下，将未命中的从Scrap中移出，并加入到Cache或Pool缓存</li>
<li>在尝试从Cache获取VH，将未命中的从Cache中移出，并加入到Pool缓存</li>
</ul>

<pre><code class="language-java">    // 如果用户设置了 ViewCacheExtension
    if (holder == null &amp;&amp; mViewCacheExtension != null) {
        // We are NOT sending the offsetPosition because LayoutManager does not
        // know it.
        final View view = mViewCacheExtension
                .getViewForPositionAndType(this, position, type);
        if (view != null) {
            holder = getChildViewHolder(view);
            // ...
        }
    }
</code></pre>

<h5 id="toc_35">第四步 从用户设置的 ViewCacheExtension 中获取缓存，没有获取到就继续往下：</h5>

<pre><code class="language-java">    if (holder == null) { // fallback to pool
        holder = getRecycledViewPool().getRecycledView(type);
        // ...
    }
</code></pre>

<h5 id="toc_36">第五步 根据 viewType 从 RecycledViewPool 中得到缓存。</h5>

<p>RecycledViewPool 已经是最后一级缓存了，如果这里也没有获取到，只能通过 Adapter 的 createViewHolder 方法创建一个 ViewHolder：</p>

<pre><code class="language-java">    if (holder == null) {
        holder = mAdapter.createViewHolder(RecyclerView.this, type);
        // ...
    }
</code></pre>

<h5 id="toc_37">小结</h5>

<p>获取某个位置的View的过程</p>

<ol>
<li>先后根据 position 或 id 从 mChangedScrap 中获取缓存</li>
<li>根据 position 依次从 mAttachedScrap、mHiddenViews（存储在 ChildHelper 类）、mCachedViews 中获取缓存</li>
<li>根据 id 依次从 mAttachedScrap、mCachedViews 中获取缓存</li>
<li>从用户设置的 ViewCacheExtension 中获取缓存</li>
<li>从 RecycledViewPool 中得到缓存的废弃 ViewHolder</li>
<li>通过 Adapter 的 createViewHolder 方法创建一个 ViewHolder</li>
</ol>

<h4 id="toc_38">recycleView</h4>

<p>既然叫 Recycler，那肯定要做回收工作了，recycleView 方法就完成了这些工作，下面看一下该方法的实现：</p>

<pre><code class="language-java">    public void recycleView(@NonNull View view) {
        ViewHolder holder = getChildViewHolderInt(view);
        // ...
        recycleViewHolderInternal(holder);
    }
</code></pre>

<p>继续看 recycleViewHolderInternal：</p>

<pre><code class="language-java">    void recycleViewHolderInternal(ViewHolder holder) {
        // ...

        if (forceRecycle || holder.isRecyclable()) {
            if (mViewCacheMax &gt; 0
                    &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                    | ViewHolder.FLAG_REMOVED
                    | ViewHolder.FLAG_UPDATE
                    | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
                        
                int cachedViewSize = mCachedViews.size();
                // 若 CacheViews 达到最大容量（2），将最老的缓存从 CacheViews 移除，并添加到 RecycledViewPool 中
                if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) {
                    recycleCachedViewAt(0);
                    cachedViewSize--;
                }

                // ...
                
                // 将 View 缓存到 mCachedViews 中
                mCachedViews.add(targetCacheIndex, holder);
                cached = true;
            }
            if (!cached) {
                // 没有添加到 mCachedViews 的话，就添加到 RecycledViewPool 中
                addViewHolderToRecycledViewPool(holder, true);
                recycled = true;
            }
        }

        // ...
    }
</code></pre>

<p>可以看到，回收过程主要涉及到两层缓存，第一层缓存是 CacheViews，在添加时，如果发现原来的 CacheViews 已经达到最大容量，就将最老的缓存从 CacheViews 移除，并添加到 RecycledViewPool。第二层缓存是 RecycledViewPool，如果不能添加到 mCacheViews，就会添加到 RecycledViewPool 中。</p>

<h4 id="toc_39">mChangedScrap 和 mAttachedScrap 中的 View 从何而来</h4>

<p>在执行 Recycler 的 recycleView 方法时，会将回收的 View 缓存到 mCahceViews 或 recycledViewPool 中，那么另外两个 Scrap 缓存（mChangedScrap 和 mAttachedScrap）中的 View 是何时添加进来的呢？</p>

<p>无论是 mAttachedScrap 还是 mChangedScrap ，它们获得 View 的途径都只有一个，那就是通过 Recycler 的 scrapView 方法。先看下该方法：</p>

<h4 id="toc_40">scrapView</h4>

<pre><code class="language-java">    void scrapView(View view) {
        final ViewHolder holder = getChildViewHolderInt(view);
        
        // 满足这几个条件中的一个就可以进入 if 循环，有机会将 View 缓存到 mAttachedScrap
        // 1. ViewHolder 设置了 FLAG_REMOVED 或 FLAG_INVALID
        // 2. ViewHolder 没有设置 FLAG_UPDATE
        // 3. 没有设置动画或者动画可以重用该 ViewHolder
        if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
            if (holder.isInvalid() &amp;&amp; !holder.isRemoved() &amp;&amp; !mAdapter.hasStableIds()) {
                throw new IllegalArgumentException(&quot;Called scrap view with an invalid view.&quot;
                        + &quot; Invalid views cannot be reused from scrap, they should rebound from&quot;
                        + &quot; recycler pool.&quot; + exceptionLabel());
            }
            // 给 ViewHolder 绑定 Recycler
            holder.setScrapContainer(this, false);
            mAttachedScrap.add(holder);
        } 
        // 不满足上述任意一个条件时，将 View 缓存到 mChangedScrap 中
        else {
            if (mChangedScrap == null) {
                mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
            }
            holder.setScrapContainer(this, true);
            mChangedScrap.add(holder);
        }
    }
</code></pre>

<p>该方法通过判断 ViewHolder 的 flag 以及是否设置 ItemAnimator 等，决定将 View 缓存到 mAttachedScrap 还是 mChangedScrap。</p>

<p>那么该方法在何时调用呢？有两种情况：</p>

<ul>
<li>以 LinearLayoutManager 为例，在它的 onLayoutChildren 方法中，会调用<code>detachAndScrapAttachedViews(recycler);</code>该方法定义在 RecyclerView 的 LayoutManager 中，它继续调用 scrapOrRecycleView 方法，如果在该方法符合条件就调用 Recycler 的 scrapView 方法。</li>
<li>通过 mHiddenViews 获取到缓存时，也会调用 scrapView 方法。</li>
</ul>

<h2 id="toc_41">场景分析</h2>

<p>根据一些场景来分析下 Recycler 是如何进行回收和复用的。</p>

<h3 id="toc_42">第一次 layout</h3>

<p>由于这里不是专门分析 layout 过程的，就不从 onLayout 开始说了，中间的过程省略掉，它最终会调用到 LayoutManager 的 onLayoutChildren。</p>

<h4 id="toc_43">LinearLayoutManager#onLayoutChildren</h4>

<pre><code class="language-java">@Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // ...
        // 找到锚点（具体过程等到分析 layout 时再说）
        // （1）
        detachAndScrapAttachedViews(recycler);
        
        if (mAnchorInfo.mLayoutFromEnd) {
            // ...
        } else {
            // （2）
            fill(recycler, mLayoutState, state, false);
            // ...
        }   
        // ...
    }
</code></pre>

<p>首先看（1）处，detachAndScrapAttachedViews 方法会根据情况将子 View 回收到相应缓存，具体过程之后再看，由于现在是第一次 layout，RecyclerView 中没有子 View，所以现在该方法没啥用。</p>

<p>接下来看（2）处，这里的 fill 方法比较重要，它的作用是填充布局。看一下该方法</p>

<h4 id="toc_44">LinearLayoutManager#fill</h4>

<pre><code class="language-java">    int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {

        // 进行 layout 时 layoutState.mScrollingOffset 的值被设置为
        // LayoutState.SCROLLING_OFFSET_NaN，不会进入此 if 块
        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            // ...
            recycleByLayoutState(recycler, layoutState);
        }
        
        // 需要填充的空间
        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
        // 还有需要填充的空间并且 item 数未满
        while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) {
            // ...
            
            // （1）
            layoutChunk(recycler, state, layoutState, layoutChunkResult);

            // 计算剩余空间

            // 同上，在 layout 时不会进入 if 块中
            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
                // ...
                recycleByLayoutState(recycler, layoutState);
            }
            
            // ...
        }
    }
</code></pre>

<h4 id="toc_45">LinearLayoutManager#layoutChunk</h4>

<pre><code class="language-java">    void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
            LayoutState layoutState, LayoutChunkResult result) {
        // （1）
        View view = layoutState.next(recycler);

        // ...
        
        // 默认情况下，layoutState.mScrapList 等于 null
        if (layoutState.mScrapList == null) {
            if (mShouldReverseLayout == (layoutState.mLayoutDirection
                    == LayoutState.LAYOUT_START)) {
                // （2）
                addView(view);
            } else {
                addView(view, 0);
            }
        } else {
            // ...
        }
    }
</code></pre>

<p>（2）处的 addView 方法就不多说了，该方法将得到的子 View 添加到 RecyclerView 中。主要看（1）处，看看子 View 从何而来</p>

<pre><code class="language-java">    View next(RecyclerView.Recycler recycler) {
        // ...
        
        final View view = recycler.getViewForPosition(mCurrentPosition);

        return view;
    }
</code></pre>

<p>这个方法是不是很熟悉呢？没错，它就是之前分析的 Recycler 的 getViewForPosition 方法。</p>

<p>不过由于现在没有任何缓存，所以第一次 layout 的时候是通过 Adapter 的 createViewHolder 来创建子 View的，并且没有添加任何缓存。</p>

<h3 id="toc_46">更新列表</h3>

<p>更新列表可以使用 Adapter 的一系列 notify 方法，这里分析其中两个方法：notifyDataSetChanged 和 notifyItemChanged(int)。</p>

<h4 id="toc_47">Adapter#notifyDataSetChanged</h4>

<p>该方法最终调用了 RecyclerViewDataObserver 的 onChanged 方法</p>

<pre><code class="language-java">    @Override
    public void onChanged() {
        // ...

        // 该方法主要做了这两件事
        // 1. 给所有 ViewHolder 添加了 FLAG_UPDATE 和 FLAG_INVALID
        // 2. 默认情况下（mHasStableIds 为 false）清空 CacheViews
        processDataSetCompletelyChanged(true);
        
        if (!mAdapterHelper.hasPendingUpdates()) {
            // 进行视图重绘
            requestLayout();
        }
    }
</code></pre>

<p>该方法会进行视图重绘，又来到了 layout 过程，继续以 LinearLayoutManager 为例，从它的 onLayoutChildren 方法看起，由于分析第一次 layout 时已经看过一遍了，这次主要看下不同之处：</p>

<pre><code class="language-java">    @Override
    public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
        // ...
        
        detachAndScrapAttachedViews(recycler);
        
        // ...
    }
</code></pre>

<p>主要区别在于 detachAndScrapAttachedViews 方法，这次它开始起作用了，该方法在 RecyclerView 的 LayoutManager 中定义，看下它的实现：</p>

<h4 id="toc_48">LayoutManager#detachAndScrapAttachedViews</h4>

<pre><code class="language-java">    public void detachAndScrapAttachedViews(@NonNull Recycler recycler) {
        final int childCount = getChildCount();
        for (int i = childCount - 1; i &gt;= 0; i--) {
            final View v = getChildAt(i);
            scrapOrRecycleView(recycler, i, v);
        }
    }
</code></pre>

<p>由于不是第一次 layout，RecyclerView 这时已经有子 View 了，该方法遍历子 View，调用 scrapOrRecycleView 方法：</p>

<pre><code class="language-java">    private void scrapOrRecycleView(Recycler recycler, int index, View view) {
        final ViewHolder viewHolder = getChildViewHolderInt(view);
        // 不能回收添加了 FLAG_IGNORE 标记的 ViewHolder
        // 可通过 LayoutManager 的 ignoreView 为相应的 View 添加该标记
        if (viewHolder.shouldIgnore()) {
            return;
        }
        // 这些条件都满足，进入 if 块
        if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
            removeViewAt(index);
            recycler.recycleViewHolderInternal(viewHolder);
        } else {
            // ...
        }
    }
</code></pre>

<p>这里将子 View 移除并通过 Recycler 的 recycleViewHolderInternal 方法进行回收</p>

<h4 id="toc_49">Recycler#recycleViewHolderInternal</h4>

<pre><code class="language-java">        void recycleViewHolderInternal(ViewHolder holder) {
            // ...
            boolean cached = false;
            boolean recycled = false;

            if (forceRecycle || holder.isRecyclable()) {
                // 由于此时的 ViewHolder 有 FLAG_INVALID 标记，不会进入此 if 块
                if (mViewCacheMax &gt; 0
                        &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
                        | ViewHolder.FLAG_REMOVED
                        | ViewHolder.FLAG_UPDATE
                        | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
                    //...
                }
                // cached 仍为 false，进入此 if 块
                if (!cached) {
                    // 通过 RecycledViewPool 的 putRecycledView 方法缓存该 ViewHolder
                    addViewHolderToRecycledViewPool(holder, true);
                    recycled = true;
                }
            } 
            
            // ...
        }
</code></pre>

<p>最终被移除的子 View 缓存到了 RecycledViewPool 中。</p>

<p>后面在调用 fill 方法进行布局填充时，就可以从 RecycledViewPool 中拿取缓存的 View。</p>

<h4 id="toc_50">Adapter#notifyItemChanged</h4>

<p>该方法传入一个 int 参数，表示要数据有更新的 item 的 position。</p>

<pre><code class="language-java">    public final void notifyItemChanged(int position) {
        mObservable.notifyItemRangeChanged(position, 1);
    }
</code></pre>

<p>最终调用 RecyclerViewDataObserver 的 onItemRangeChanged 方法</p>

<pre><code class="language-java">    @Override
    public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {
        // 会在 mAdapterHelper 中创建一个 UpdateOp，将信息保存起来
        if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) {
            // 如果可以进行更新操作，执行该方法
            triggerUpdateProcessor();
        }
    }
</code></pre>

<p>继续看 triggerUpdateProcessor 方法</p>

<pre><code class="language-java">    void triggerUpdateProcessor() {
        // 判断条件默认为 false，执行 else 块
        if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) {
            // ...
        } else {
            mAdapterUpdateDuringMeasure = true;
            requestLayout();
        }
    }
</code></pre>

<p>在保存了一些信息后，还是进行视图重绘。来到了 layout 过程后，还是以 LinearLayoutManager 为例，这次先看下布局过程的 step1，也就是 dispatchLayoutStep1 方法</p>

<pre><code class="language-java">    private void dispatchLayoutStep1() {
        // ...
        
        processAdapterUpdatesAndSetAnimationFlags();
        
        // ...
    }
</code></pre>

<p>主要看 processAdapterUpdatesAndSetAnimationFlags 方法，从名字也可以看出，它负责更新 adapter 的信息</p>

<pre><code class="language-java">    private void processAdapterUpdatesAndSetAnimationFlags() {
        // ...

        if (predictiveItemAnimationsEnabled()) {
            mAdapterHelper.preProcess();
        } else {
            mAdapterHelper.consumeUpdatesInOnePass();
        }

        // ...
    }
</code></pre>

<p>这里借助了 mAdapterHelper，它最终又通过接口回调（回调了 markViewHoldersUpdated 方法）调用了 RecyclerView 的 viewRangeUpdate 方法</p>

<pre><code class="language-java">    void viewRangeUpdate(int positionStart, int itemCount, Object payload) {
        // ...

        for (int i = 0; i &lt; childCount; i++) {
            // ...
            
            if (holder.mPosition &gt;= positionStart &amp;&amp; holder.mPosition &lt; positionEnd) {
                // （1）
                holder.addFlags(ViewHolder.FLAG_UPDATE);
                // ...
            }
        }
    }
</code></pre>

<p>该方法就是遍历所有子 View，找到所有发生了改变的子 View，进行相关操作。这里重点看注释（1），为改变的 ViewHolder 添加了 FLAG_UPDATE 标记。先记住这点，在后面会用到。</p>

<p>接下来看 onLayoutChildren 方法，和 notifyDataSetChanged 一样，主要的不同之处也是在于 detachAndScrapAttachedViews 方法，该方法遍历子 View，调用 scrapOrRecycleView 方法，下面看一下该方法</p>

<h4 id="toc_51">LayoutManager#scrapOrRecycleView</h4>

<pre><code class="language-java">    private void scrapOrRecycleView(Recycler recycler, int index, View view) {
        final ViewHolder viewHolder = getChildViewHolderInt(view);
        // ...
        
        // 这次 ViewHolder 没有添加 FLAG_INVALID 标记，进入 else 块
        if (viewHolder.isInvalid() &amp;&amp; !viewHolder.isRemoved()
                &amp;&amp; !mRecyclerView.mAdapter.hasStableIds()) {
            // ...
        } else {
            detachViewAt(index);
            recycler.scrapView(view);
            mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);
        }
    }
</code></pre>

<p>这里就和 notifyDataSetChanged 时不一样了，由于在视图重绘前没有给 ViewHolder 添加 FLAG_INVALID 标记，这次进入的是 else 块。</p>

<p>首先将 View 从 RecyclerView 中 detach 掉（而不是 remove 掉）。然后在回收时，调用的是 Recycler 的 scrapView 方法。该方法在前面也分析过了，这里再看一次</p>

<pre><code class="language-java">    void scrapView(View view) {
        final ViewHolder holder = getChildViewHolderInt(view);
        
        // 满足这几个条件中的一个就可以进入 if 循环
        // 1. ViewHolder 设置了 FLAG_REMOVED 或 FLAG_INVALID 
        // 2. ViewHolder 没有设置 FLAG_UPDATE 
        // 3. 没有设置动画或者动画可以重用该 ViewHolder 
        if (holder.hasAnyOfTheFlags(ViewHolder.FLAG_REMOVED | ViewHolder.FLAG_INVALID)
                || !holder.isUpdated() || canReuseUpdatedViewHolder(holder)) {
            // ...
            
            mAttachedScrap.add(holder);
        } 
        // 不满足上述任意一个条件时，将 View 缓存到 mChangedScrap 中
        else {
            if (mChangedScrap == null) {
                mChangedScrap = new ArrayList&lt;ViewHolder&gt;();
            }
            holder.setScrapContainer(this, true);
            mChangedScrap.add(holder);
        }
    }
</code></pre>

<p>重点看判断里面的条件 2，从前面的分析可以得知，对于发生改变的 ViewHolder，给它设置了 FLAG_UPDATE，所以它现在三个条件都不满足，进入 else 块，而对于其他的 ViewHolder，由于没有设置 FLAG_UPDATE，所以满足条件 2，进入 if 循环。</p>

<p>所以通过 notifyItemChanged 方法更新列表时，发生了改变的子 View 将被缓存到 ChangedScrap 中，而没有发生改变的子 View 则缓存到 AttachedScrap 中，之后通过填充布局的时候对于不同 item 就可以从相应的 Scrap 缓存中得到子 View。</p>

<p>另外，Scrap 缓存只作用于布局阶段，在 layout 的 step3 中将会清空 mAttachedScrap 和 mChangedScrap。</p>

<h3 id="toc_52">RecyclerView滑动机制分析</h3>

<p>根据View事件机制可以直接来看onTouchEvent方法。<br/>
重点查看move事件。move事件执行了scrollByInternal方法。该方法最后会执行LayoutManager的Scroll方法，以LinearLayoutManager为例，它的ScrollBy方法最终执行到fill方法。也就是上文提到的ItemView填充方法，滑动过程中会不断执行获取对应位置的ViewHolder，然后进行View的展示。从而实现RecyclerView的滑动</p>

<pre><code class="language-java">public boolean onTouchEvent(MotionEvent e) {
   ...

   switch (action) {
       case MotionEvent.ACTION_DOWN: {
          ...
       case MotionEventCompat.ACTION_POINTER_DOWN: 
          ...

       case MotionEvent.ACTION_MOVE: { // 触摸时间-move
           ...
           if (mScrollState == SCROLL_STATE_DRAGGING) {
               mLastTouchX = x - mScrollOffset[0];
               mLastTouchY = y - mScrollOffset[1];
                // 执行内部滑动方法
               if (scrollByInternal(
                       canScrollHorizontally ? dx : 0,
                       canScrollVertically ? dy : 0,
                       vtev)) {
                   getParent().requestDisallowInterceptTouchEvent(true);
               }
               ...           }
       } break;

       case MotionEventCompat.ACTION_POINTER_UP: {
           onPointerUp(e);
       } break;

       case MotionEvent.ACTION_UP: { // 触摸事件-up
           // 执行 fling方法 ，主要做一些item和scroller动画等操作
           if (!((xvel != 0 || yvel != 0) &amp;&amp; fling((int) xvel, (int) yvel))) {
               setScrollState(SCROLL_STATE_IDLE);
           }
           resetTouch();
       } break;

       case MotionEvent.ACTION_CANCEL: {
           cancelTouch();
       } break;
   }
   ...
   return true;
}
</code></pre>

<h4 id="toc_53">scrollByInternal</h4>

<ul>
<li>内部Scroll执行方法，此处会执行LayoutManager的Scroll方法</li>
<li>其它处罚Nested、OnScroll等事件</li>
</ul>

<pre><code class="language-java">
boolean scrollByInternal(int x, int y, MotionEvent ev) {
   int unconsumedX = 0, unconsumedY = 0;
   int consumedX = 0, consumedY = 0;

   consumePendingUpdateOperations();
   if (mAdapter != null) {
       eatRequestLayout();
       onEnterLayoutOrScroll();
       TraceCompat.beginSection(TRACE_SCROLL_TAG);
       if (x != 0) {
           consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);
           unconsumedX = x - consumedX;
       }
       if (y != 0) {
            // LinearLayout 竖向布局为例，走LayoutManager滑动放啊放
           consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);
           unconsumedY = y - consumedY;
       }
       TraceCompat.endSection();
       repositionShadowingViews();
       onExitLayoutOrScroll();
       resumeRequestLayout(false);
   }
   if (!mItemDecorations.isEmpty()) {
       invalidate();
   }
    // 分发 NestedScroll事件
   if (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) {
    ...
   }
   if (consumedX != 0 || consumedY != 0) {
       dispatchOnScrolled(consumedX, consumedY); // 分发onScrolled事件
   }
   if (!awakenScrollBars()) {
       invalidate();
   }
   return consumedX != 0 || consumedY != 0;
}
</code></pre>

<h4 id="toc_54">LinearLayoutManager执行滑动处理</h4>

<ul>
<li>执行scrollBy方法</li>
<li>scrollBy方法最终走到 fill方法（上面提到的填充子View方法）</li>
<li>该方法则会进行 ItemView的填充。从而完成Recycler滑动时，View的重新创建或者重新绑定一系列过程</li>
<li>平移整个View的child，实现滑动效果</li>
</ul>

<pre><code class="language-java">public int scrollVerticallyBy(int dy, RecyclerView.Recycler recycler,
       RecyclerView.State state) {
   if (mOrientation == HORIZONTAL) {
       return 0;
   }
   return scrollBy(dy, recycler, state);
}


int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {
   ...
   mLayoutState.mRecycle = true;
   ensureLayoutState();
   final int layoutDirection = dy &gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;
   final int absDy = Math.abs(dy);
   // 更新LayoutState，布局方向和偏移值。目的是让LayoutManager知道从开始还是末尾进行回收和填充
   updateLayoutState(layoutDirection, absDy, true, state);
   
   // 执行 LinearLayout的fill 方法
   final int consumed = mLayoutState.mScrollingOffset
           + fill(recycler, mLayoutState, state, false);
   ...
   // 平移整个view的child
   mOrientationHelper.offsetChildren(-scrolled);
   
   return scrolled;
}
</code></pre>

<pre><code class="language-java">int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
            RecyclerView.State state, boolean stopOnFocusable) {
    ...
    // 执行回收流程
    recycleByLayoutState(recycler, layoutState);
    ...
    // 执行填充流程（参考上面layoutChunk方法）
    layoutChunk(recycler, state, layoutState,layoutChunkResult);
}
</code></pre>

<h3 id="toc_55">LinearLayoutManager回收流程</h3>

<ul>
<li>根据不同的布局方向进行不同方向的回收。以Start为例介绍</li>
<li>计算位移limit值，根据limit</li>
</ul>

<pre><code class="language-java">private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {
   // 假设是 初始方向布局，则开始末尾View回收。反之亦然
   if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
       recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);
   } else {
       recycleViewsFromStart(recycler, layoutState.mScrollingOffset);
   }
}

private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) {
   final int limit = dt;
   final int childCount = getChildCount();
   if (mShouldReverseLayout) {
       ...
   } else {
        for (int i = 0; i &lt; childCount; i++) {
           View child = getChildAt(i);
           // 遍历child，当超过限制大小时候，开始回收
           if (mOrientationHelper.getDecoratedEnd(child) &gt; limit
                   || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) {
               recycleChildren(recycler, 0, i); // 执行Children回收流程
               return;
           }
       }        }
}
    
private void recycleChildren(RecyclerView.Recycler recycler, int startIndex, int endIndex) {
   if (endIndex &gt; startIndex) {
       for (int i = endIndex - 1; i &gt;= startIndex; i--) {
           removeAndRecycleViewAt(i, recycler); // 执行RecyclerView的移出和回收方法
       }
   } else {
       for (int i = startIndex; i &gt; endIndex; i--) {
           removeAndRecycleViewAt(i, recycler);
       }
   }
}
</code></pre>

<h4 id="toc_56">RecyclerView.removeAndRecycleViewAt</h4>

<ul>
<li>移出和回收View方法</li>
<li>执行ChildHelper的移出View方法。内部Bucket移出和回掉CallBack进行View移出</li>
<li>执行Recycler回收方法</li>
</ul>

<pre><code class="language-java">public void removeAndRecycleViewAt(int index, Recycler recycler) {
  final View view = getChildAt(index); // 获取目标View
  removeViewAt(index); // 执行ChildHelper移出
  recycler.recycleView(view); // 回收View
}

public void removeViewAt(int index) {
  final View child = getChildAt(index); 
  if (child != null) {
      mChildHelper.removeViewAt(index); // 执行ChildHelper移出
  }
}

public void recycleView(View view) {
  ViewHolder holder = getChildViewHolderInt(view); // 获取VH
  // ViewHolder 回收前，需要完全detach、且不是Scrap
  if (holder.isTmpDetached()) {
      removeDetachedView(view, false); 
  }
  if (holder.isScrap()) {
      holder.unScrap();
  } else if (holder.wasReturnedFromScrap()){
      holder.clearReturnedFromScrapFlag();
  }
  recycleViewHolderInternal(holder); // 执行回收
}
</code></pre>

<h4 id="toc_57">RecyclerView.recycleViewHolderInternal</h4>

<ul>
<li>内部缓存VH方法</li>
<li>如果CacheView满了，则移出一个Cache到Pool中</li>
<li>将目标VH缓存到Cache末尾</li>
<li>如果没有Cache成功，则直接缓存到Pool中</li>
</ul>

<pre><code class="language-java"> void recycleViewHolderInternal(ViewHolder holder) {  
      if (mViewCacheMax &gt; 0
              &amp;&amp; !holder.hasAnyOfTheFlags(ViewHolder.FLAG_INVALID
              | ViewHolder.FLAG_REMOVED
              | ViewHolder.FLAG_UPDATE
              | ViewHolder.FLAG_ADAPTER_POSITION_UNKNOWN)) {
          // Cache缓存个数超了，则直接回收CacheView到RecyclerPool
          int cachedViewSize = mCachedViews.size();
          if (cachedViewSize &gt;= mViewCacheMax &amp;&amp; cachedViewSize &gt; 0) {
              recycleCachedViewAt(0);
              cachedViewSize--;
          }

          int targetCacheIndex = cachedViewSize;
          // 将VH缓存到CacheView中
          mCachedViews.add(targetCacheIndex, holder);
          cached = true;
      }
      // 如果未CacheView缓存，则直接缓存RecyclerViewPool中
      if (!cached) {
          addViewHolderToRecycledViewPool(holder, true);
          recycled = true;
      }
      //...
}
</code></pre>

<h3 id="toc_58">局部刷新</h3>

<h4 id="toc_59">Adapter数据操作对外API</h4>

<p>RecyclerView.Adapter提供局部数据变化通知方法，然后执行到RecyclerViewDataObserver对应的各种数据操作方法上。</p>

<h4 id="toc_60">RecyclerViewDataObserver</h4>

<ul>
<li>通过mAdapterHelper进行数据变化处理操作</li>
<li>然后触发更新处理</li>
<li>下面介绍下 ItemChanged操作</li>
</ul>

<pre><code class="language-java">   public void onItemRangeChanged(int positionStart, int itemCount, Object payload) {
       assertNotInLayoutOrScroll(null);
       if (mAdapterHelper.onItemRangeChanged(positionStart, itemCount, payload)) {
           triggerUpdateProcessor();
       }
   }

   public void onItemRangeInserted(int positionStart, int itemCount) {
       assertNotInLayoutOrScroll(null);
       if (mAdapterHelper.onItemRangeInserted(positionStart, itemCount)) {
           triggerUpdateProcessor();
       }
   }

   public void onItemRangeRemoved(int positionStart, int itemCount) {
       assertNotInLayoutOrScroll(null);
       if (mAdapterHelper.onItemRangeRemoved(positionStart, itemCount)) {
           triggerUpdateProcessor();
       }
   }
</code></pre>

<h4 id="toc_61">AdapterHelper.onItemRangeChanged</h4>

<pre><code class="language-java">boolean onItemRangeChanged(int positionStart, int itemCount, Object payload) {
   // 添加一个更新操作 ，标志为update、记录pos、item相关信息
   mPendingUpdates.add(obtainUpdateOp(UpdateOp.UPDATE, positionStart, itemCount, payload));
   mExistingUpdateTypes |= UpdateOp.UPDATE;
   // 如果只有一个待处理操作则为true，true则执行后续更新处理。如果是多个，则会忽略，因为在第一次出发后，就会集中处理
   return mPendingUpdates.size() == 1;
}
</code></pre>

<h4 id="toc_62">RecyclerViewDataObserver.triggerUpdateProcessor</h4>

<ul>
<li>当RecyclerView有固定大小，且已经Attached了。则走Runnable更新</li>
<li>否则直接走requestLayout方式更新，即重新走绘制流程 onMeasure、onLayout等</li>
</ul>

<pre><code class="language-java">void triggerUpdateProcessor() {
  if (POST_UPDATES_ON_ANIMATION &amp;&amp; mHasFixedSize &amp;&amp; mIsAttached) {
      // RecyclerView有固定大小的时候 会执行mUpdateChildViewsRunnable 来处理更新
      ViewCompat.postOnAnimation(RecyclerView.this, mUpdateChildViewsRunnable);
  } else {
      // 直接走 requestLayout方式来处理
      mAdapterUpdateDuringMeasure = true;
      requestLayout();
  }
}
</code></pre>

<h4 id="toc_63">triggerUpdateProcessor下requestLayout</h4>

<p>requestLayout下 onMeasure -&gt; dispatchLayout -&gt; dispatchLayoutStep2 -&gt; layoutChildren -&gt; fill -&gt; layoutChunk -&gt; next -&gt; tryGetViewHolderForPositionByDeadline<br/>
最终对Item进行重新绑定 实现局部刷新逻辑</p>

<pre><code class="language-java">ViewHolder tryGetViewHolderForPositionByDeadline(int position,
                boolean dryRun, long deadlineNs) {
                
           if (mState.isPreLayout() &amp;&amp; holder.isBound()) {
                holder.mPreLayoutPosition = position;
            } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) {
                // 执行数据变化的Holder的重新bind，从而实现局部刷新              
                final int offsetPosition = mAdapterHelper.findPositionOffset(position);
                bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs);
            }               
}
</code></pre>

<h4 id="toc_64">triggerUpdateProcessor下mUpdateChildViewsRunnable</h4>

<p>当RecyclerView有固定大小时，则不需要Measure，直接走dispatchLayout方法进行刷新操作</p>

<pre><code class="language-java">final Runnable mUpdateChildViewsRunnable = new Runnable() {
   @Override
   public void run() {
        ...
        // 消费 等待执行的操作 
        consumePendingUpdateOperations();
   }
}

void consumePendingUpdateOperations() {
        
      if (mAdapterHelper.hasAnyUpdateTypes(AdapterHelper.UpdateOp.UPDATE) &amp;&amp; !mAdapterHelper
           .hasAnyUpdateTypes(AdapterHelper.UpdateOp.ADD | AdapterHelper.UpdateOp.REMOVE
                   | AdapterHelper.UpdateOp.MOVE)) {
        // update 情况下 逻辑
       
       eatRequestLayout();
       onEnterLayoutOrScroll();
       // 数据预处理 
       mAdapterHelper.preProcess();
       if (!mLayoutRequestEaten) {
            // 执行 dispatchLayout 进行局部刷新处理
           if (hasUpdatedView()) {
               dispatchLayout();
           } else {
               // no need to layout, clean state
               mAdapterHelper.consumePostponedUpdates();
           }
       }
       ...
   } else if (mAdapterHelper.hasPendingUpdates()) {
       // add、remove等操作，直接执行dispatchLayout
       dispatchLayout();
       TraceCompat.endSection();
   }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Centos7 Docker配置TLS认证的远程端口的证书生成教程（shell脚本一键生成）]]></title>
    <link href="http://adolph.cc/15917531926388.html"/>
    <updated>2020-06-10T09:39:52+08:00</updated>
    <id>http://adolph.cc/15917531926388.html</id>
    <content type="html"><![CDATA[
<p>远程访问Docker的2375端口不安全，很容易被检测到并入侵。我们需要在远程 docker 服务器（运行 docker 守护进程的服务器）生成 CA 证书，服务器证书，服务器密钥，然后自签名，再颁发给需要连接远程 docker 容器的服务器。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">生成SSL证书</h2>

<p>只需要三个步骤</p>

<h3 id="toc_1">生成ca密钥和证书</h3>

<pre><code class="language-text">#生成ca私钥(使用aes256加密)
read -s PASSWORD
openssl genrsa -aes256 -passout pass:$PASSWORD  -out ca-key.pem 2048
#生成ca证书，填写配置信息
openssl req -new -x509 -passin &quot;pass:$PASSWORD&quot; -days 365 -key ca-key.pem -sha256 -out ca.pem
</code></pre>

<h3 id="toc_2">生成server密钥和证书</h3>

<pre><code class="language-text">#生成server证书私钥文件
openssl genrsa -out server-key.pem 2048
#生成server证书请求文件
openssl req -subj &quot;/CN=$SERVER&quot; -new -key server-key.pem -out server.csr
#使用CA证书及CA密钥以及上面的server证书请求文件进行签发，生成server自签证书
openssl x509 -req -days 365 -in server.csr -CA ca.pem -CAkey ca-key.pem -passin &quot;pass:$PASSWORD&quot; -CAcreateserial  -out server-cert.pem
</code></pre>

<h3 id="toc_3">生成client密钥和证书</h3>

<pre><code class="language-text">#生成client证书RSA私钥文件
openssl genrsa -out key.pem 2048
#生成client证书请求文件
openssl req -subj &#39;/CN=client&#39; -new -key key.pem -out client.csr

sh -c &#39;echo &quot;extendedKeyUsage=clientAuth&quot; &gt; extfile.cnf&#39;
#生成client自签证书（根据上面的client私钥文件、client证书请求文件生成）
openssl x509 -req -days 365 -in client.csr -CA ca.pem -CAkey ca-key.pem  -passin &quot;pass:$PASSWORD&quot; -CAcreateserial -out cert.pem  -extfile extfile.cnf
</code></pre>

<h3 id="toc_4">使用Shell脚本一键生成</h3>

<p>上面大概介绍了一下，下面直接上代码比较容易懂，在服务器上创建一个create_tls_certs.sh的文件，执行sh create_tls_certs.sh即可</p>

<pre><code class="language-text">#创建 Docker TLS 证书
#!/bin/bash

#相关配置信息
SERVER=&quot;192.168.33.76&quot;
PASSWORD=&quot;pass123456&quot;
COUNTRY=&quot;CN&quot;
STATE=&quot;广州省&quot;
CITY=&quot;广州市&quot;
ORGANIZATION=&quot;公司名称&quot;
ORGANIZATIONAL_UNIT=&quot;Dev&quot;
EMAIL=&quot;492376344@qq.com&quot;

###开始生成文件###
echo &quot;开始生成文件&quot;

#切换到生产密钥的目录
cd /etc/docker   
#生成ca私钥(使用aes256加密)
openssl genrsa -aes256 -passout pass:$PASSWORD  -out ca-key.pem 2048
#生成ca证书，填写配置信息
openssl req -new -x509 -passin &quot;pass:$PASSWORD&quot; -days 3650 -key ca-key.pem -sha256 -out ca.pem -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$SERVER/emailAddress=$EMAIL&quot;

#生成server证书私钥文件
openssl genrsa -out server-key.pem 2048
#生成server证书请求文件
openssl req -subj &quot;/CN=$SERVER&quot; -new -key server-key.pem -out server.csr
#使用CA证书及CA密钥以及上面的server证书请求文件进行签发，生成server自签证书
openssl x509 -req -days 3650 -in server.csr -CA ca.pem -CAkey ca-key.pem -passin &quot;pass:$PASSWORD&quot; -CAcreateserial  -out server-cert.pem

#生成client证书RSA私钥文件
openssl genrsa -out key.pem 2048
#生成client证书请求文件
openssl req -subj &#39;/CN=client&#39; -new -key key.pem -out client.csr

sh -c &#39;echo &quot;extendedKeyUsage=clientAuth&quot; &gt; extfile.cnf&#39;
#生成client自签证书（根据上面的client私钥文件、client证书请求文件生成）
openssl x509 -req -days 3650 -in client.csr -CA ca.pem -CAkey ca-key.pem  -passin &quot;pass:$PASSWORD&quot; -CAcreateserial -out cert.pem  -extfile extfile.cnf

#更改密钥权限
chmod 0400 ca-key.pem key.pem server-key.pem
#更改密钥权限
chmod 0444 ca.pem server-cert.pem cert.pem
#删除无用文件
rm client.csr server.csr

echo &quot;生成文件完成&quot;
###生成结束###
</code></pre>

<p>执行结束我们可以在/etc/docker 目录下看到相应的证书文件</p>

<p><img src="media/15917531926388/15917534392105.jpg" alt=""/></p>

<p><img src="media/15917531926388/15917534462818.jpg" alt=""/></p>

<blockquote>
<p>注：req指令 new/x509<br/>
当使用-new选取的时候，说明是要生成证书请求，当使用x509选项的时候，说明是要生成自签名证书</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AspectJ在Android中应用]]></title>
    <link href="http://adolph.cc/15867044458821.html"/>
    <updated>2020-04-12T23:14:05+08:00</updated>
    <id>http://adolph.cc/15867044458821.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">什么是AOP(编程思想)</h2>

<p>AOP是Aspect Oriented Programming的缩写，即『面向切面编程』，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。和我们平时开发的OOP(面向对象)是不同的编程思想。<br/>
OOP提倡的是将功能模块化，对象化，每个模块专心干自己的事情，模块之间通过设计好的接口交互。开发中，针对业务处理过程的实体及其属性和行为进行抽象封装，以获得更加清晰高效的逻辑单元划分。但是也有它的缺点，最明显的就是关注点聚焦时，面向对象无法简单的解决这个问题，一个关注点是面向所有而不是单一的类，不受类的边界的约束，因此OOP无法将关注点聚焦来解决，只能分散到各个类中。</p>

<span id="more"></span><!-- more -->

<p>AOP（面向切面编程）则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。这两种设计思想在目标上有着本质的差异。<br/>
在OOP中有些功能是横跨并嵌入众多模块中的，比如日志埋点，动态权限检查等。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>

<p><img src="media/15867044458821/24F447C6FF8E994CC48F26899110086D.png" alt="24F447C6FF8E994CC48F26899110086D"/></p>

<h3 id="toc_1">OOP和AOP对比</h3>

<p><img src="media/15867044458821/15867670275659.jpg" alt=""/></p>

<p><img src="media/15867044458821/15867670461523.jpg" alt=""/></p>

<p><img src="media/15867044458821/15867670530094.jpg" alt=""/></p>

<h2 id="toc_2">AspectJ</h2>

<p>AspectJ 意思就是Java的Aspect，Java的AOP。是对AOP编程思想的一个技术实践，除了AspectJ以外，还有很多其它的AOP实现。它的核心是ajc(编译器)\weaver(织入器)。</p>

<blockquote>
<p><strong>ajc编译器</strong>：基于Java编译器之上的，它是用来编译.aj文件，aspectj在Java编译器的基础上增加了一些它自己的关键字和方法。因此，ajc也可以编译Java代码。<br/>
<strong>weaver织入器</strong>：为了在java编译器上使用AspectJ而不依赖于Ajc编译器，aspectJ 5出现了@AspectJ，使用注释的方式编写AspectJ代码，可以在任何Java编译器上使用。</p>
</blockquote>

<p>由于AndroidStudio默认是没有ajc编译器的，所以在Android中使用@AspectJ来编写（包括SpringAOP也是如此）。它在代码的编译期间扫描目标程序，根据切点（PointCut）匹配,将开发者编写的Aspect程序编织（Weave）到目标程序的.class文件中，对目标程序作了重构（重构单位是JoinPoint），目的就是建立目标程序与Aspect程序的连接（获得执行的对象、方法、参数等上下文信息），从而达到AOP的目的。</p>

<h3 id="toc_3">AspectJ集成</h3>

<p>AOP的用处非常广，从Spring到Android，各个地方都有使用，特别是在后端，Spring中已经使用的非常方便了，而且功能非常强大，但是在Android中，AspectJ的实现是略阉割的版本，并不是所有功能都支持，但对于一般的客户端开发来说，已经完全足够用了。</p>

<p>在Android上集成AspectJ实际上是比较复杂的，可以使用GitHub上已经封装好的Gradle插件进行开发。<a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx">GitHub</a></p>

<h4 id="toc_4">插件引用</h4>

<ul>
<li>在项目的根目录的<code>build.gradle</code>文件中添加依赖，修改后文件如下</li>
</ul>

<pre><code class="language-text">repositories {
    jcenter()
}
dependencies {
    classpath &#39;com.android.tools.build:gradle:3.4.1&#39;
    classpath &#39;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.8&#39;
}
</code></pre>

<ul>
<li>在项目或者库的build.gradle文件中添加AspectJ的依赖</li>
</ul>

<pre><code class="language-text">implementation &#39;org.aspectj:aspectjrt:1.8.9&#39;    //注意不能直接引用最新的AspectJ
</code></pre>

<ul>
<li>同时在该文件中加入AspectJX模块</li>
</ul>

<pre><code class="language-text">apply plugin: &#39;android-aspectjx&#39;
</code></pre>

<ul>
<li>AspectJX配置</li>
</ul>

<p>AspectJX默认会处理所有的二进制代码文件和库，为了提升编译效率及规避部分第三方库出现的编译兼容性问题，AspectJX提供include,exclude命令来过滤需要处理的文件及排除某些文件(包括class文件及jar文件)。</p>

<pre><code class="language-text">aspectjx {
    //排除所有package路径中包含`android.support`的class文件及库（jar文件）
    exclude &#39;android.support&#39;
    //忽略所有的class文件及jar文件，相当于AspectJX不生效
    exclude &#39;*&#39;
    //关闭AspectJX功能
    enabled false
}
</code></pre>

<h3 id="toc_5">AspectJ语法</h3>

<p>这里只是介绍简单的一些概念，如果想要去了解深入的用法，可参考文后的链接，去官网查看。</p>

<h4 id="toc_6">Aspect 切面</h4>

<p>实现了Cross­Cutting功能，是针对切面的模块。最常见的是logging模块、方法执行耗时模块，这样，程序按功能被分为好几层，如果按传统的继承的话，商业模型继承日志模块的话需要插入修改的地方太多，而通过创建一个切面就可以使用AOP来实现相同的功能了，我们可以针对不同的需求做出不同的切面。</p>

<h4 id="toc_7">JoinPoint 连接点</h4>

<p>JoinPoint: A particular point in a program that might be the target of code injection. JoinPoint 简单一点说就是程序运行时要执行一些动作的点。</p>

<table>
<thead>
<tr>
<th style="text-align: left">JoinPoint</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">示例</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">method call</td>
<td style="text-align: left">函数调用</td>
<td style="text-align: left">例如调用 Log.e( )</td>
</tr>
<tr>
<td style="text-align: left">method execution</td>
<td style="text-align: left">函数执行</td>
<td style="text-align: left">例如 Log.e( ) 的执行内部。</td>
</tr>
<tr>
<td style="text-align: left">constructor call</td>
<td style="text-align: left">构造函数调用</td>
<td style="text-align: left">和 method call 类似</td>
</tr>
<tr>
<td style="text-align: left">constructor execution</td>
<td style="text-align: left">构造函数执行</td>
<td style="text-align: left">和 method execution 类似</td>
</tr>
<tr>
<td style="text-align: left">field get</td>
<td style="text-align: left">获取某个变量</td>
<td style="text-align: left">例如读取 MainActivity.mTest 成员</td>
</tr>
<tr>
<td style="text-align: left">field set</td>
<td style="text-align: left">设置某个变量</td>
<td style="text-align: left">例如设置 MainActivity.mTest 成员</td>
</tr>
<tr>
<td style="text-align: left">pre-initialization</td>
<td style="text-align: left">Object 在构造函数中做的一些工作</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">initialization</td>
<td style="text-align: left">Object 在构造函数中做的工作</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">static initialization</td>
<td style="text-align: left">类初始化</td>
<td style="text-align: left">例如类的 static{}</td>
</tr>
<tr>
<td style="text-align: left">handler</td>
<td style="text-align: left">异常处理</td>
<td style="text-align: left">例如 try catch(xxx) 中，对应 catch 内的执行</td>
</tr>
<tr>
<td style="text-align: left">advice execution</td>
<td style="text-align: left">AspectJ 的内容</td>
<td style="text-align: left"></td>
</tr>
</tbody>
</table>

<p>JoinPoint 的选择要结合下面的 Pointcuts 表达式来看</p>

<h4 id="toc_8">Pointcut 切点</h4>

<p>Pointcut: An expression which tell a code injection tool where to inject a particular piece of code Pointcut 简单的说就是从一堆的 JoinPoint 中挑选感兴趣的 JoinPoint 的表达式。</p>

<p>例如</p>

<pre><code class="language-text">pointcut anyCall(): call(* *.println(..)) &amp;&amp; !within(TestAspect);
</code></pre>

<p>在 AspectJ 的语言中定义一个 Pointcout 需要用关键词 pointcut . 上面的这里是</p>

<ul>
<li><strong>pointcut</strong>: 是定一个 Pointcut 的关键词</li>
<li><strong>anyCall()</strong>: 是 Pointcut 的名称</li>
<li><strong>call</strong> : 表示 JoinPoint 的类型为 call</li>
<li>第一个 &#39;<em>&#39; 号是返回值， ‘</em>’ 代表是任意返回值； 第二个 ‘<em>’ 号代表是包名，‘</em>’ 代表是任意包名,这边表明我们是选择任意包名下的 println 函数；在 （..） 中指定参数类型，‘..’ 通配符表示任意类型；</li>
<li>&amp;&amp;！ 表示组合条件，有 &amp;&amp;， || 以及 ！</li>
<li>within(TestAspect): within 是 JoinPoint 间接选择过滤的一个方法，后面会讲到。 ！within(TestAspect) 表示调用者的类型不是 TestAspect.</li>
</ul>

<h4 id="toc_9">JointPoint 的选择</h4>

<p>JointPoint 的选择有分成直接选择和间接选择两种方式</p>

<ul>
<li>JointPoint 的直接选择就是通过和 Pointcut 的语法一一对应关系中选择；</li>
<li>JointPoint 的间接选择就是通过一些通配符进行筛选过滤的选择，上面例子中的 within 就是间接选择的一种。</li>
</ul>

<h5 id="toc_10">JointPoint 直接选择</h5>

<p>JoinPoint 的选择策略和 Pointcut 的语法对应关系</p>

<table>
<thead>
<tr>
<th style="text-align: left">JoinPoint Category</th>
<th style="text-align: left">Pointcut Syntax</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">Method execution</td>
<td style="text-align: left">execution(MethodSignature)</td>
</tr>
<tr>
<td style="text-align: left">Method call</td>
<td style="text-align: left">call(MethodSignature)</td>
</tr>
<tr>
<td style="text-align: left">Constructor execution</td>
<td style="text-align: left">execution(ConstructorSignature)</td>
</tr>
<tr>
<td style="text-align: left">Constructor call</td>
<td style="text-align: left">call(ConstructorSignature)</td>
</tr>
<tr>
<td style="text-align: left">Class initialization</td>
<td style="text-align: left">staticinitialization(TypeSignature)</td>
</tr>
<tr>
<td style="text-align: left">Field read access</td>
<td style="text-align: left">get(FieldSignature)</td>
</tr>
<tr>
<td style="text-align: left">Field write access</td>
<td style="text-align: left">set(FieldSignature)</td>
</tr>
<tr>
<td style="text-align: left">Exception handler execution</td>
<td style="text-align: left">handler(TypeSignature)</td>
</tr>
<tr>
<td style="text-align: left">Object initialization</td>
<td style="text-align: left">initialization(ConstructorSignature)</td>
</tr>
<tr>
<td style="text-align: left">Object pre-initialization</td>
<td style="text-align: left">preinitialization(ConstructorSignature)</td>
</tr>
<tr>
<td style="text-align: left">Advice execution</td>
<td style="text-align: left">adviceexecution()</td>
</tr>
</tbody>
</table>

<p>JoinPoint 不同策略的选择对应着不同 Pointcut，特别是 Pointcut 里面有着不同的 Signature。</p>

<p><strong>Method Signature 表达式语法</strong></p>

<blockquote>
<p>@注解 访问权限 返回值的类型 包名.函数名(参数) 例子： @before(&quot;execution(* android.app.Activity.on**(..))&quot;);</p>
</blockquote>

<ul>
<li><strong>注解</strong>： 是可选项; 这里是 @before,关于注解的在后面 Adivce 中有更详细的说明</li>
<li><strong>访问权限</strong>: 可选项; 有 public, private, protected 类型；例子没有设置</li>
<li><strong>返回值的类型</strong>: 与普通函数的返回值类型是一样的，如果不限定类型，用通配符 * 表示。例子中是 *</li>
<li><strong>包名.函数名</strong>：用于查找匹配的函数，可以使用通配符
<ul>
<li>通配符的类型
<ul>
<li>&#39;*&#39;表示用于匹配处 . 号之外的任意字符；</li>
<li>&#39;..&#39; 表示任意子 package</li>
<li>&#39;+&#39;号表示子类</li>
</ul></li>
<li>例子：
<ul>
<li>java.*.Data: 可以表示 java.sql.Data ，也可以表示 java.util.Date;</li>
<li>Test* : 表示Test开头的函数，可以表示 TestBase, 也可以表示 TestDervied</li>
<li>java..* : 表示 java 任意子类</li>
<li>java..*Model+: 表示 Java 任意 package 中名字以 Model 结尾的子类，比如 TabelModel, TreeModel 等</li>
</ul></li>
</ul></li>
<li>函数参数 参数有不同的型式
<ul>
<li>(int, char): 表示参数只有两个， 并且第一个参数是 int, 第二个参数是 char;</li>
<li>(String, ..): 表示参数至少有一个。并且第一个参数是 String, 后面参数类型不限。在参数匹配中， .. 代表任意参数个数和类型；</li>
<li>(Oject ...): 表示不定个数的参数，并且类型都是 Object, 这里的 ... 不是通配符，而是 java 中不定参数的意思；</li>
</ul></li>
</ul>

<p><strong>Constructor Signature 表达式</strong> 和 Method Signature 类似 不同点： 构造函数没有返回值，并且函数名必须叫 new 例子：</p>

<blockquote>
<p>public *..TestDeived.new(..)</p>
</blockquote>

<ul>
<li>public: 表示选择 public 访问权限的</li>
<li>*.. : 代表任意包名</li>
<li>TestDeived.new: 代表 TestDerived 的构造函数</li>
<li>(..): 代表参数个数和类型都是任意的</li>
</ul>

<p><strong>Field Signature表达式语法</strong></p>

<blockquote>
<p>@注解 访问权限 类型 类名.成员变量名</p>
</blockquote>

<ul>
<li>@注解和访问权限是可选的</li>
<li>类型：成员变量类型， * 表示任意类型</li>
<li>类名.成员变量名： 成员变量名可以是*， 代表任意成员变量</li>
</ul>

<p>例子, 用 AspectJ 打印成员变量赋值前后的值</p>

<pre><code class="language-java">// TraceAspect.java　set field 的切面
private static final String POINTCUT_FILEED =
        &quot;set(int org.android10.viewgroupperformance.activity.MainActivity.mTest) &amp;&amp; args(newValue) &amp;&amp; target(t)&quot;;

@Before(POINTCUT_FILEED)
public void onFiled(JoinPoint joinPoint, Object newValue, Object t) throws IllegalAccessException {
    Object object = joinPoint.getThis();

    FieldSignature fieldSignature = (FieldSignature) joinPoint.getSignature();
    String fileName = fieldSignature.getName();
    Field field = fieldSignature.getField();
    field.setAccessible(true);
    Class clazz = fieldSignature.getFieldType();
    String clazzName = clazz.getSimpleName();

    Object oldValue = field.get(t);

    Log.i(&quot;MainActivity&quot;, &quot;\nonFiled value = &quot; + newValue.toString() + &quot;\n fieldSignature =&quot; + fieldSignature.toString()
                + &quot;\nfield = &quot; + field.toString() + &quot; +  \nFileName = &quot; + fileName
                + &quot;\nclazzName = &quot; + clazzName + &quot; \noldValue = &quot; + oldValue.toString() );
}

// 在 MainActivity.java 中
@Override
protected void onResume() {
        super.onResume();
        mTest = 100;
}
</code></pre>

<p>打印结果</p>

<pre><code class="language-text">onFiled value = 100 fieldSignature =int org.android10.viewgroupperformance.activity.MainActivity.mTest field = private int org.android10.viewgroupperformance.activity.MainActivity.mTest +
FileName = mTest clazzName = int oldValue = -1
</code></pre>

<p><strong>TypeSignature表达式</strong> </p>

<p>例子：staticinitlization(test..TestBase): </p>

<p>表示 TestBase 类的 static block </p>

<p>例子：handler(NullPointException): </p>

<p>表示 catch 到 NullPointerException 的 JointPoint</p>

<h5 id="toc_11">JointPoint 间接选择</h5>

<p>JointPoint 的直接选择是通过 Signature 信息匹配的，除此之外还有其他的方式，这些方式都可以归类到间接选择</p>

<table>
<thead>
<tr>
<th style="text-align: left">关键词</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">实例</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">within(TypePattern)</td>
<td style="text-align: left"><code>TypePattern</code> 表示 package 或者类, <code>TypePattern</code> 可以使用通配符</td>
<td style="text-align: left">表示某个 Package 或者类中的 Point, within(Test): Test　类中（包括内部类）所有的 JointPoint</td>
</tr>
<tr>
<td style="text-align: left">withcode(Constructor Signature | Method Signature)</td>
<td style="text-align: left">表示某个构造函数或其他函数执行过程涉及到的 JointPoint</td>
<td style="text-align: left">withinCode(* Test.testMethod(..)) 表示 testMethod 涉及的 JointPoint, withinCode(*.Test.new(..)) 表示 Test 的构造函数涉及的 JointPoint</td>
</tr>
<tr>
<td style="text-align: left">cflow(pointcuts)</td>
<td style="text-align: left">cflow 表示 call flow, cflow 的条件是一个 pointcut</td>
<td style="text-align: left">cflow(call Test.testMethod), 表示调用 Test.testMethod 函数是所包含的JointPoint,包含 testMethod 的 call 这个 JointPoint 本身</td>
</tr>
<tr>
<td style="text-align: left">cflowbelow(pointcuts)</td>
<td style="text-align: left">cflowbelow 表示不包含自身的 cflow</td>
<td style="text-align: left">cflowbelow(call Test.testMethod) 表示调用 Test.testMethod 函数是所包含的 JointPoint, 不包含 testMethod 的 call 这个 JointPoint 本身</td>
</tr>
<tr>
<td style="text-align: left">this(Type)</td>
<td style="text-align: left">JointPoint 的 this 对象是 Type 类型</td>
<td style="text-align: left">JPoint是代码段（不论是函数，异常处理，static block），从语法上说，它都属于一个类。如果这个类的类型是Type标示的类型，则和它相关的JPoint将全部被选中。</td>
</tr>
<tr>
<td style="text-align: left">target(Type)</td>
<td style="text-align: left">JoinPoint 的 target 对象是 Type 类型</td>
<td style="text-align: left">和this相对的是target。不过target一般用在call的情况。call一个函数，这个函数可能定义在其他类。比如testMethod是TestDerived类定义的。那么target(TestDerived)就会搜索到调用testMethod的地方。但是不包括testMethod的execution JointPoint</td>
</tr>
<tr>
<td style="text-align: left">args(TypeSignature)</td>
<td style="text-align: left">用来对 JointPoint 的参数进行条件搜索</td>
<td style="text-align: left">例如 arg(int, ..) 表示第一个参数是 int, 后面参数个数和类型不限的 JointPoint</td>
</tr>
</tbody>
</table>

<h5 id="toc_12">call 与 execution 区别</h5>

<p>当 call 捕获 joinPoint 时，捕获的签名方法的调用点;execution 捕获 joinPoint 时，捕获的则是执行点。 两个的区别在于一个是 ”调用点“， 一个是 ”执行点“</p>

<p>对于 call 来讲</p>

<pre><code class="language-text">call(Before)
Pointcut {
    Pointcut Method
}
call(After)
</code></pre>

<p>对于 execution 来说</p>

<pre><code class="language-text">Pointcut {
   Execution(Before)
   Pointcut Method
   Execution(After)
}
</code></pre>

<h5 id="toc_13">获取参数</h5>

<ul>
<li>通过声明参数语法arg()显示获取参数</li>
</ul>

<pre><code class="language-text">@Around(value = &quot;execution(* BitmapFacade.picasso.init(java.lang.String,java.lang.String)) &amp;&amp; args(arg1,arg2)&quot;
public Object aroundArgs(String arg1,String arg2,ProceedingJoinPoint joinPoint){
   System.out.println(&quot;aspects arg = &quot; + arg1.toString()+&quot; &quot; + arg2);
   Object resutObject = null;
   try {
      resutObject = joinPoint.proceed(new Object[]{arg1,arg2});
   } catch (Throwable e) {
      e.printStackTrace();
   }
   return resutObject;
}
</code></pre>

<ul>
<li>通过joinPoint.getArg()获取参数列表</li>
</ul>

<pre><code class="language-text">@Around(&quot;execution(static * tBitmapFacade.picasso.init(..)) &amp;&amp; !within(aspectj.*) &quot;)
public void pointCutAround(ProceedingJoinPoint joinPoint){
   Object resutObject = null;
   try {
      //获取参数列表
      Object[] args = joinPoint.getArgs();
      resutObject = joinPoint.proceed(args);
   } catch (Throwable e) {
      e.printStackTrace();
   }
   return resutObject;
}
</code></pre>

<h5 id="toc_14">异常匹配</h5>

<pre><code class="language-text">/**
* 截获Exception及其子类报出的异常。
* @param e 异常参数
*/
@Pointcut(&quot;handler(java.lang.Exception+)&amp;&amp;args(e)&quot;)
public void handle(Exception e) {}
</code></pre>

<h4 id="toc_15">Advice 通知</h4>

<p>Advice: Advice defines pieces of aspect implementation that execute at well-defined points in the execution of the program.</p>

<p>通过前面的 Pointcuts 找到了相应的 JointPoint, 需要对这些 JointPoint 最一些事情，相当于对 JointPoint 进行 hook, 这就是 advice 要做的事。</p>

<p><strong>advice 的分类</strong></p>

<table>
<thead>
<tr>
<th style="text-align: left">关键词</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">示例</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">before()</td>
<td style="text-align: left">before advice</td>
<td style="text-align: left">表示在 JointPoint 执行之前要干 的事</td>
</tr>
<tr>
<td style="text-align: left">after()</td>
<td style="text-align: left">after advice</td>
<td style="text-align: left">表示在 JointPoint 执行之后要干的事</td>
</tr>
<tr>
<td style="text-align: left">after(): returning(返回值类型) after():throwing(异常类型)</td>
<td style="text-align: left">returning 和 throwing 后面都可以指定具体的类型，如果不指定则匹配类型不限制</td>
<td style="text-align: left">假设 JointPoint 是一个函数调用那么函数调用执行完有两种方式退出.一个是正常的 return, 另一个是抛异常after() 默认包括 returing 和 throwing 两种情况</td>
</tr>
<tr>
<td style="text-align: left">返回值类型around()</td>
<td style="text-align: left">around 替代原来的 JointPoint</td>
<td style="text-align: left">around 替代了原来的 JointPoint，如果要执行原 JointPoint 的话，需要调用 procced</td>
</tr>
</tbody>
</table>

<p>例子： 我们需要在 Activity 中的 onResume 方法调用前后输出</p>

<pre><code class="language-java">// MainActivity.java
@Override
protected void onResume() {
    super.onResume();
    Log.i(TAG, &quot;--- onResume---&quot;);
}

// TraceAspect.java
private static final String POINTCUT_ONMETHOD =
        &quot;execution(* android.app.Activity.on**(..))&quot;;

@Before(POINTCUT_ONMETHOD)
public void beforeOnMethod(JoinPoint joinPoint) {
    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
    String className = methodSignature.getDeclaringType().getSimpleName();
    String methodName = methodSignature.getName();
    Log.i(className, &quot;before &quot; + methodName + &quot; log&quot;);

}

@After(POINTCUT_ONMETHOD)
public void onMethLog(JoinPoint joinPoint){
    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
    String className = methodSignature.getDeclaringType().getSimpleName();
    String methodName = methodSignature.getName();
    Log.i(className, &quot;after &quot; + methodName + &quot; log&quot;);
}
</code></pre>

<p>改成 Around 的方式</p>

<pre><code class="language-java">// TraceAspect.java
private static final String POINTCUT_ONMETHOD =
        &quot;execution(* android.app.Activity.on**(..))&quot;;
@Pointcut(POINTCUT_ONMETHOD)
public void annotationOnMethodTrace(){

}

@Around(&quot;annotationOnMethodTrace()&quot;)
public Object weaveOnMethodJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {

  MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
  String className = methodSignature.getDeclaringType().getSimpleName();
  String methodName = methodSignature.getName();

  Log.i(&quot;MainActivity&quot;, &quot;before joinPoint proceed className = &quot; + className + &quot; methodName = &quot; + methodName);

  Object result  = joinPoint.proceed();
  Log.i(&quot;MainActivity&quot;, &quot;after joinPoint proceed className = &quot; + className + &quot; methodName = &quot; + methodName);

  return result;
}
</code></pre>

<p>从上面例子的输出我们可以看到 around 等价于 before + after, 另外 JointPoint#proceed 是原来的 JointPoint，在这里是 onResume 方法， 输出中的 “--- onResume---” 就是在 onResume 中打印的。</p>

<h4 id="toc_16">参数传递和 JointPoint 信息</h4>

<p>经过前面的几个步骤，我们已经拿到了 JointPoint,但是我们经常需要对一些 advice 传入参数，然后进行处理的。例如如果传入的参数不合法，就不用调 JointPoint#proceed 方法处理了。</p>

<p><strong>参数传递</strong></p>

<p>advice 参数的方法由 this, target(), args()</p>

<ul>
<li>this(Type or Id): 捕获当前对象（被绑定 this）实例执行的连接点 -- 实例由 Type 或者 Id 描述</li>
<li>target(Type or Id): 捕获目标对象（被应用与对象上的调用和属性操作）实例的连接点 -- 实例由 Type 和 Id 描述（必须绑定和封装后放入通知或者切点定义）。它不匹配任何静态的调用、应用和设置成员。</li>
<li>args(Type or Id): 捕获具有适当类型样式的实例连接点</li>
</ul>

<p>下面是例子说明 我们在 MainActivity 定义一个成员变量 mTest, 初始值为 -1，在 OnResume() 方法对它进行赋值，用 target 和 args 对 mTest 赋值前后的值进行监听</p>

<pre><code class="language-java">// MainActivity.java
private int mTest = -1;
@Override
protected void onResume() {
    super.onResume();
    Log.i(TAG, &quot;--- onResume---&quot;);
    mTest = 100;
}

// TraceAspect.java
//　set field 的切面
private static final String POINTCUT_FILEED =
        &quot;set(int org.android10.viewgroupperformance.activity.MainActivity.mTest) &amp;&amp; args(newValue) &amp;&amp; target(t)&quot;;

@Before(POINTCUT_FILEED)
public void onFiled(JoinPoint joinPoint, Object newValue, Object t) throws IllegalAccessException {

    FieldSignature fieldSignature = (FieldSignature) joinPoint.getSignature();
    String fileName = fieldSignature.getName();
    Field field = fieldSignature.getField();
    field.setAccessible(true);
    Class clazz = fieldSignature.getFieldType();
    String clazzName = clazz.getSimpleName();

    Object oldValue = field.get(t);

    Log.i(&quot;MainActivity&quot;,
               &quot;\nonFiled value = &quot; + newValue.toString()
                    + &quot;\ntarget = &quot; + t.toString()
                    + &quot;\n fieldSignature =&quot; + fieldSignature.toString()
                    + &quot;\nfield = &quot; + field.toString()
                    + &quot;\nFileName = &quot; + fileName
                    + &quot;\nclazzName = &quot; + clazzName
                    + &quot; \noldValue = &quot; + oldValue.toString() );
}
</code></pre>

<p>定义切面表达式使用 args(newValue) &amp;&amp; target(t) 它们的参数值 newValue, t,必须要和方法中的定义的对的上</p>

<blockquote>
<p>public void onFiled(JoinPoint joinPoint, Object newValue, Object t)</p>
</blockquote>

<p><strong>JointPoint信息</strong> 在 advice 中我们可以拿到 JointPoint 的信息，一般包含</p>

<ul>
<li>JointPoint 对象信息：例如参数、前面之类的</li>
</ul>

<blockquote>
<p>JoinPoint.getSignature() 包含有</p>

<ol>
<li>MethodSignature 方法的签名</li>
<li>FieldSignature 成员变量的签名</li>
<li>ConstructorSignature 构造函数的签名</li>
<li>InitializerSignature 初始化的签名</li>
</ol>
</blockquote>

<p>不同的签名对应不同的场景</p>

<ul>
<li>JointPoint 源代码部分的信息，例如类型、所处的位置</li>
<li>JointPoint 静态部分信息</li>
</ul>

<p><strong>例子：</strong></p>

<pre><code class="language-java">@Around(&quot;methodAnnotatedWithDebugTrace() || constructorAnnotatedDebugTrace()&quot;)
public Object weaveJoinPoint(ProceedingJoinPoint joinPoint) throws Throwable {
    // joint 对象信息
    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
    String className = methodSignature.getDeclaringType().getSimpleName();
    String methodName = methodSignature.getName();
    
    // 源代码部分信息
    SourceLocation sourceLocation = joinPoint.getSourceLocation();
    String fileName = sourceLocation.getFileName();
    int line = sourceLocation.getLine();
    String soucreClassName = sourceLocation.getWithinType().getName();
    DebugLog.log(className, &quot;\nfileName = &quot; + fileName + &quot;\nline = &quot; + line + &quot;\nsoucreClassName = &quot; + soucreClassName);
        
    // 静态部分
    JoinPoint.StaticPart staticPart = joinPoint.getStaticPart();
        
    return result;
}
</code></pre>

<p><strong>截获某类异常例子</strong></p>

<pre><code class="language-java">/**
* 异常处理
*/
@Aspect
public class ExceptionHandleAspect {
    private static final String TAG = &quot;ExceptionHandleAspect&quot;;
    /**
    * 截获空指针异常
    * @param e
    */
    @Pointcut(&quot;handler(java.lang.NullPointerException)&amp;&amp;args(e)&quot;)
    public void handle(NullPointerException e){
    }
    /**
    * 在catch代码执行之前做一些处理
    * @param joinPoint
    * @param e 异常参数
    */
    @Before(value = &quot;handle(e)&quot;,argNames = &quot;e&quot;)
    public void handleBefore(JoinPoint joinPoint,NullPointerException e){
        Log.e(TAG,joinPoint.getSignature().toLongString()+&quot; handleBefore() :&quot;+e.toString());
        //汇总处理
    }
}
</code></pre>

<p><strong>截获指定方法的异常例子</strong></p>

<pre><code class="language-java">/**
* 异常处理
*/
@Aspect
public class ExceptionHandleAspect {
    private static final String TAG = &quot;ExceptionHandleAspect&quot;;
    /**
    * 截获某一个方法抛出的异常
    */
    @Pointcut(&quot;call(* com.meituan.hotel.roadmap.*.initTabLayout(..))&quot;)
    public void afterThrow(){}
    /**
    * 在异常抛出后，该操作优先于下一个切点的@Before()
    * @param joinPoint
    * @param e 异常参数
    */
    @AfterThrowing(pointcut = &quot;afterThrow()&quot;,throwing = &quot;e&quot;)
    public void afterThrowing(JoinPoint joinPoint,Exception e){
        Log.e(TAG,joinPoint.getTarget().getClass().getSimpleName() + &quot; afterThrowing() :&quot; + e.toString());
    }
}
</code></pre>

<p>更详细的信息参考文档 <a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/index.html">https://www.eclipse.org/aspectj/doc/released/runtime-api/index.html</a></p>

<h3 id="toc_17">总结</h3>

<p><strong>使用 AspectJ 的步骤</strong></p>

<blockquote>
<ol>
<li>设置 Pointcut 的表达式</li>
<li>选择相应的 advice</li>
<li>对 JointPoint 或参数进行相应的处理</li>
</ol>
</blockquote>

<p><strong>使用特点</strong></p>

<blockquote>
<ol>
<li>关注点具有普遍性需求，代码散乱分布在工程各处，可以抽出共同的代码。</li>
<li>访问控制，例如：字段、方法的访问前做一些验证，访问之后做一些处理。</li>
<li>代码约束，例如：限制某些方法只能在特定的地方使用，否则在编译期间抛出Error错误或者Warning。</li>
<li>项目中需要临时插入一些方法、逻辑，但是不希望影响到原工程，易插易拔。</li>
</ol>
</blockquote>

<h2 id="toc_18">相关问题</h2>

<ol>
<li>编织速度
<ol>
<li>尽量使用精确的匹配规则,降低匹配时间。</li>
<li>排除不需要扫描的包。</li>
</ol></li>
<li>调试工具</li>
</ol>

<h2 id="toc_19">参考</h2>

<p><a href="https://github.com/yxhuangCH/CSLearn/blob/master/android/Aspectj%20%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8.md">Aspectj 在Android中的使用</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用清华源AOSP镜像下载Android源码]]></title>
    <link href="http://adolph.cc/15765647907369.html"/>
    <updated>2019-12-17T14:39:50+08:00</updated>
    <id>http://adolph.cc/15765647907369.html</id>
    <content type="html"><![CDATA[
<p>为了方便使用，准备了一个移动硬盘，将其格式化为ExFAT格式。使用清华源AOSP镜像，可以更方便快捷同步AOSP源代码</p>

<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/">清华源AOSP</a></p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">过程摘录</h2>

<p><strong>下载 repo 工具</strong></p>

<pre><code class="language-text">mkdir ~/bin
PATH=~/bin:$PATH
curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo
chmod a+x ~/bin/repo
</code></pre>

<p><strong>使用每月更新的初始化包</strong></p>

<blockquote>
<p>由于首次同步需要下载约 30GB 数据，过程中任何网络故障都可能造成同步失败，我们强烈建议您使用初始化包进行初始化。下载 <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar">aosp-latest</a>，下载完成后记得根据 checksum.txt 的内容校验一下。由于所有代码都是从隐藏的 .repo 目录中 checkout 出来的，所以我们只保留了 .repo 目录，下载后解压 再 repo sync 一遍即可得到完整的目录。</p>
</blockquote>

<p>使用方法如下:</p>

<pre><code class="language-text">wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包
tar xf aosp-latest.tar
cd AOSP   # 解压得到的 AOSP 工程目录
# 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录
repo sync # 正常同步一遍即可得到完整目录
# 或 repo sync -l 仅checkout代码
</code></pre>

<p>此后，每次只需运行 repo sync 即可保持同步。 我们强烈建议您保持每天同步，并尽量选择凌晨等低峰时间</p>

<h2 id="toc_1">一些源码常用目录</h2>

<p><strong>应用程序层</strong> 目录<code>/aosp/packages/apps/</code><br/>
<strong>框架层</strong> 目录<code>/aosp/frameworks/</code></p>

<h2 id="toc_2">FAQ</h2>

<p><strong>1、error: .repo/manifests/: contains uncommitted changes</strong></p>

<p>在终端输入<code>git config core.filemode false</code>(加入忽略文件权限的配置)<br/>
再输入<code>repo sync</code>就能成功同步了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[添加环境变量]]></title>
    <link href="http://adolph.cc/15767453112302.html"/>
    <updated>2019-12-19T16:48:31+08:00</updated>
    <id>http://adolph.cc/15767453112302.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">bash shell</h2>

<p>Mac默认是bash shell 配置变量在跟目录中，编辑：</p>

<pre><code class="language-text">vi ~/.bash_profile
</code></pre>

<p>通过export将变量导出去</p>

<pre><code class="language-text">export ANDROID_HOME=~/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
</code></pre>

<span id="more"></span><!-- more -->

<p><strong>注意:</strong>变量与变量之间用:分割</p>

<h2 id="toc_1">zsh shell</h2>

<pre><code class="language-text">vi ~/.zshrc
// 如果跟目录没有.zshrc的话，执行下面的命令
cash  ~/.zshrc
vi ~/.zshrc
</code></pre>

<p>在最下面添加</p>

<pre><code class="language-text">export ANDROID_HOME=~/Library/Android/sdk
export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio自定义工程模板]]></title>
    <link href="http://adolph.cc/15777558791342.html"/>
    <updated>2019-12-31T09:31:19+08:00</updated>
    <id>http://adolph.cc/15777558791342.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">前言</h2>

<p>一直以来开发业务，总是要创建一批相同的初始代码，每次先写一个页面总是要创建新的Activity，新的xml，新的ViewModel或者新的Presenter，这样既麻烦又影响开发效率。Android Studio提供的代码模板可帮助我们减少重复编写同一段代码的负担，而且可以遵循优化后的设计和标准。AS采用的是Apache FreeMarker模板引擎。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">工程模板路径</h2>

<p>Mac版Android Studio的模板路径位于<code>/Applications/Android\ Studio.app/Contents/plugins/android/lib/templates/</code></p>

<h2 id="toc_2">模板目录结构</h2>

<p>以比较简单的EmptyActivity为例</p>

<p><img src="media/15777558791342/15777850172541.jpg" alt=""/></p>

<p>每一个模板存在于root文件夹下，其中：</p>

<ul>
<li>root: 存放模板文件及引入资源的目录，模板文件可以是.xml、.java、.gradle等任何一个文本格式的文件，资源一般是我们引入的.png资源文件</li>
<li>src:代码文件</li>
<li>globals.xml.ftl: 可存储全局变量以供其他模板文件统一引用</li>
<li>recipe.xml.ftl: 用于组合生成我们实际需要的代码文件和布局文件等。</li>
<li>template.xml: 面向模板引擎的配置文件</li>
</ul>

<p>真正核心的部分就是<code>root</code>、<code>recipe.xml.ftl</code>和<code>template.xml</code></p>

<p>打开 root 目录，能够看到里面的文件除了图片资源文件都是以<code>.ftl</code>结尾的，而<code>.ftl</code>是标准的 FreeMarker的文件。FreeMarker 是类似于 Velocity 的一种模板框架，据说对于多文件处理时它具有更好的性能，大概也是 Android Studio 选择 Velocity 作为单文件模板，选择 <a href="http://freemarker.org/">FreeMarker</a> 作为文件组模板的原因吧。有兴趣的可以去 FreeMarker 官网学习一下，它的自定义标签功能还是很强大的，个人感觉比 Velocity 的更加接地气。</p>

<p>globals文件中可以看到每一个变量的定义形式，id作为唯一标识，type标识变量类型，value表示变量值。<br/>
<img src="media/15777558791342/15777871331393.jpg" alt=""/></p>

<p>recipe.xml.ftl文件即使不懂freemarker引擎应该也可以大概看懂，</p>

<ul>
<li><strong>copy</strong> 就是简单的 copy，把模板 root 目录下的某个文件 copy 到目标工程的某个目录下</li>
<li><strong>instantiate</strong> 跟 copy 很类似，唯一多的一点功能就是并不只简单的走 IO 流进行 copy，而是通过 FreeMarker 框架按照模板中的 FreeMarker 能识别的逻辑判断和数据引入来生成最终的目标文件</li>
<li><strong>merge</strong> 目标项目中有了某文件，而我们还要想该文件合并一些我们的模板的部分时，就选用 merge，例如我们添加一个 Activity 时需要 mergeAndroidManifest.xml的配置。目前支持的 merge 格式有.xml和.gradle，但是对.gradle支持的不怎么好，不过不影响该模板的开发，对于这套模板引擎的开发者来说，这可能是最麻烦的部分了，但是对于我们使用者就不用考那么多了，直接使用吧</li>
<li><strong>open</strong> 这个很简单，就是指定模板引入之后要 IDE 打开的文件</li>
</ul>

<p>这里if判断可以轻松看出是根据用户选择生成的文件类型来生成Java文件或者kotlin文件。<br/>
<img src="media/15777558791342/15777871999672.jpg" alt=""/></p>

<p><code>template.xml</code>文件就是模板界面了，主要由<code>parameter</code>标签获取用户输入的参数：</p>

<ul>
<li><code>template标签</code>
<ul>
<li><code>name</code> 引入模板时的模板名称，就是根据他选择哪个模板的</li>
<li><code>description</code> 弹出 Dialog 的标题</li>
</ul></li>
<li><code>category</code> 表示该模板属于哪种分类，在引入的时候会有个分类的选择</li>
<li><code>parameter</code> 每个该标签就对应 Dialog 界面的一个输入项
<ul>
<li><code>id</code>：唯一标识符，也用于其他文件变量查找引用(也是我们在.ftl中引入的值，例如定义的 id 为username，引用时就是$username)</li>
<li><code>name</code>：该标签的名称，同时将展示给用户</li>
<li><code>type</code>：参数类型，如boolean 、string等</li>
<li><code>constraints</code> 对应该参数的约束，如果有多个要用|分割开</li>
<li><code>suggest</code> 建议值，这个输入部分是由级联效应的，可能你改了 A 参数，B 参数也会跟着改变，就是根据这个参数决定的</li>
<li><code>default</code> 参数的默认值</li>
<li><code>visibility</code> 可见性，要配置一个 boolean 类型的参数，一般指向另一个输入源</li>
<li><code>help</code> 当焦点在某个输入源上面时，弹框下部显示限制的内容</li>
</ul></li>
</ul>

<p><img src="media/15777558791342/15777873288052.jpg" alt=""/></p>

<p><img src="media/15777558791342/15777873353828.jpg" alt=""/></p>

<p>如果了解FreeMarker模板引擎，看过template目录下的官方模板代码，基本就能写出基础的模板代码。</p>

<h2 id="toc_3">TemplateBuilder快速创建模板引擎</h2>

<p>通过TemplateBuilder就可以一键支持创建模板，但是目前只支持Java，Kotlin需要对文件进行手动修改。</p>

<h3 id="toc_4">安装</h3>

<p>打开 Android Studio，<code>Preferences</code> – <code>Plugins</code> – <code>Brown Repositories</code>, 搜索<code>TemplateBuilder</code>并下载，下载之后重启 IDE 即可使用。<br/>
<img src="media/15777558791342/15777877567549.jpg" alt=""/></p>

<h3 id="toc_5">使用</h3>

<p><code>导出：</code> 选择待导出的文件或文件夹，按下<code>ALT + T</code>，在弹出界面中更改模板名称（MVP Test）和描述后直接<code>Finish</code>，然后重启 IDE；<br/>
<img src="media/15777558791342/img2.gif" alt="img2"/></p>

<p><code>导入：</code> 选择一个包，按下<code>Command + N</code>键，输入模板分类名（默认为电脑用户名），选择MVP Test模板进行导入。<br/>
<img src="media/15777558791342/img7.gif" alt="img7"/></p>

<h3 id="toc_6">快速制作</h3>

<p>这里我们拿对一个 MVP 模板的抽取来举例，首先选中需要制作为模板的类文件（如果需要选中某个文件夹里的全部文件，可以直接选中该文件夹），然后按下启动改插件的快捷键ALT + T，便能看到如下界面<br/>
<img src="media/15777558791342/15777879209820.jpg" alt=""/></p>

<ul>
<li><code>Template Category</code> 对应模板的分类，对应选择导入模板时的模板分类，这里默认值是电脑的用户名。</li>
<li><code>Template Name</code> 对应模板名称，对应选择导入模板时的模板名称，默认值是当前的 Project 名称。</li>
<li><code>Template Description</code> 对应模板描述信息，对应导入模板时弹出的导入界面的文字描述，默认为空。</li>
<li><code>Template Folder</code> 对应生成模板所存放的位置，如果是 Mac 操作系统则默认为<code>/Applications/Android Studio.app/Contents/plugins/android/lib/templates</code>， Windows 系统的话由于差异比较大，就默认为空了，可以自行配置<code>[Android Studio安装目录]/plugins/android/lib/templates</code>（这里只需要配置一次即可，插件将自动保存该位置）。</li>
<li><code>Input data区域</code> （见下图）
<img src="media/15777558791342/15777888673006.jpg" alt=""/></li>
</ul>

<p>如果你只是想简单抽取你写的这个模板，你只需要输入下<code>Template Name</code>和<code>Template Description</code>即可，当然如果你不想输入的话这也可以省略掉。接下来直接点击<code>Finish</code>，就能在 IDE 底部看到弹出如下图所示的提示，此时你已经制作成功，重启 IDE 即可使用该模板。<br/>
<img src="media/15777558791342/15777880379810.jpg" alt=""/></p>

<p>到这里，如果你了解<code>Android Studio Template</code>制作流程的话，你可能觉得相对于完全自己手动去做这样固然简单，但是灵活性上降低了不少。例如模板中有组价依赖关系的时候，你需要在<code>build.gradle.ftl</code>中去添加对应的依赖；导入模板之后你想自动打开某个文件时，你需要编辑<code>recipe.xml.ftl</code>；选择模板适用于哪个版本时，你需要编辑<code>template.xml</code>等等。如果你有这方面的需求，可以点击<code>Next</code>来代替<code>Finish</code>，点击之后你就能看到如下界面，在这里提供了所有你需要关注的配置文件的编辑，编辑完成直接点击OK开始自动生成。<br/>
<img src="media/15777558791342/15777881050138.jpg" alt=""/></p>

<h3 id="toc_7">配置模板变量</h3>

<p>在上面的界面中可以看到<code>Input data</code>区域，它对应着导入模板时的变量输入，如果你想增强模板的可配性将会用到它，它就对应着 AS 模板中<code>template.xml</code>的<code>&lt;parameter /&gt;</code>标签，也就是下面的每一个配置项。</p>

<p>关于<code>Input data</code>的使用，先解释下每个属性对应的含义</p>

<ul>
<li><code>id</code> 变量名，必须和模板中使用的变量名对应，必填</li>
<li><code>name</code> 变量简介，必填</li>
<li><code>type</code> 变量类型，string 和 boolean 两种，通过下拉框选择，必填</li>
<li><code>default</code> 变量对应的默认值，选填</li>
<li><code>help</code> 添加该变量时的提示信息，选填</li>
</ul>

<h4 id="toc_8">示例</h4>

<p>假设待导出的模板文件是<code>UserActivity</code>类，代码如下：</p>

<pre><code class="language-java">public class UserActivity extends Activity {
    
    private TextView mUserName;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_user);
      mUserName = (TextView) findViewById(R.id.user_name);
    }
}
</code></pre>

<p>代码很简单，假设我们想让引入模板时<code>mUserName</code>属性名是可配的，并且在 <code>Activity</code> 中是否调用 <code>setContentView</code> 方法也是可配的，那我们就需要这样改写该类：</p>

<pre><code class="language-java">public class UserActivity extends Activity {

    private TextView ${textViewName};

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        &lt;#if setContentView&gt;
        setContentView(R.layout.activity_user);
        ${textViewName} = (TextView) findViewById(R.id.user_name);
        &lt;/#if&gt;
    }
}
</code></pre>

<p>我们用到了<code>textViewName</code>和<code>setContentView</code>两个变量，所以当我们按下<code>ALT + T</code>时就要在对应的 <code>Input data</code> 区域点击Add来添加两个对应的变量。</p>

<table>
<thead>
<tr>
<th style="text-align: center">Input data</th>
<th style="text-align: center">textViewName</th>
<th style="text-align: center">setContentView</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">id</td>
<td style="text-align: center">textViewName</td>
<td style="text-align: center">setContentView</td>
</tr>
<tr>
<td style="text-align: center">type</td>
<td style="text-align: center">string</td>
<td style="text-align: center">boolean</td>
</tr>
<tr>
<td style="text-align: center">name</td>
<td style="text-align: center">TextView 属性名</td>
<td style="text-align: center">是否设置布局</td>
</tr>
<tr>
<td style="text-align: center">default</td>
<td style="text-align: center">mUserName</td>
<td style="text-align: center">false</td>
</tr>
<tr>
<td style="text-align: center">help</td>
<td style="text-align: center">输入TextView对应的属性名</td>
<td style="text-align: center">勾选则设置布局文件，反之不设置</td>
</tr>
</tbody>
</table>

<p>添加完模板变量后导出，重启 IDE 选择导入该模板，此时便能看到刚才配置的两个变量，你可以输入不同的值来验证模板的正确性。</p>

<p><img src="media/15777558791342/15777884999670.jpg" alt=""/></p>

<h3 id="toc_9">添加模板依赖</h3>

<p>模板中需要添加 <code>gradle</code> 依赖时，点击Next在第二个页面中<code>build.gradle.ftl</code>添加如下所示对应的仓库和依赖即可。</p>

<pre><code class="language-text">repositories {
    // 如果仓库是jcenter()，则可省略
    jcenter()
}

dependencies {
    compile &#39;io.reactivex.rxjava2:rxjava:2.0.6&#39;
    compile &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39;
}
</code></pre>

<h3 id="toc_10">修改template.xml文件</h3>

<p>template.xml这个是模板配置文件，打开可以看到:</p>

<pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;template
    format=&quot;5&quot;
    revision=&quot;6&quot;
    name=&quot;Login Activity&quot;
    description=&quot;Creates a new login activity, allowing users to optionally sign in with Google+ or enter an email address and password to log in to or register with your application.&quot;
    requireAppTheme=&quot;true&quot;
    minApi=&quot;8&quot;
    minBuildApi=&quot;14&quot;&gt;

    &lt;dependency name=&quot;android-support-v4&quot; revision=&quot;8&quot; /&gt;

    &lt;category value=&quot;Activity&quot; /&gt;
    &lt;formfactor value=&quot;Mobile&quot; /&gt;

    &lt;parameter
        id=&quot;activityClass&quot;
        name=&quot;Activity Name&quot;
        type=&quot;string&quot;
        constraints=&quot;class|unique|nonempty&quot;
        default=&quot;LoginActivity&quot;
        help=&quot;The name of the activity class to create&quot; /&gt;

    &lt;parameter
        id=&quot;layoutName&quot;
        name=&quot;Layout Name&quot;
        type=&quot;string&quot;
        constraints=&quot;layout|unique|nonempty&quot;
        suggest=&quot;${activityToLayout(activityClass)}&quot;
        default=&quot;activity_login&quot;
        help=&quot;The name of the layout to create for the activity&quot; /&gt;

    &lt;parameter
        id=&quot;activityTitle&quot;
        name=&quot;Title&quot;
        type=&quot;string&quot;
        constraints=&quot;nonempty&quot;
        default=&quot;Sign in&quot;
        help=&quot;The name of the activity.&quot; /&gt;

    &lt;parameter
        id=&quot;parentActivityClass&quot;
        name=&quot;Hierarchical Parent&quot;
        type=&quot;string&quot;
        constraints=&quot;activity|exists|empty&quot;
        default=&quot;&quot;
        help=&quot;The hierarchical parent activity, used to provide a default implementation for the &#39;Up&#39; button&quot; /&gt;

    &lt;parameter
        id=&quot;packageName&quot;
        name=&quot;Package name&quot;
        type=&quot;string&quot;
        constraints=&quot;package&quot;
        default=&quot;com.mycompany.myapp&quot; /&gt;

    &lt;thumbs&gt;
        &lt;thumb&gt;template_login_activity.png&lt;/thumb&gt;
    &lt;/thumbs&gt;

    &lt;globals file=&quot;globals.xml.ftl&quot; /&gt;
    &lt;execute file=&quot;recipe.xml.ftl&quot; /&gt;

&lt;/template&gt;
</code></pre>

<ol>
<li>外面的template标签写的是基本的配置：包括模板名，描述，是否请求系统主题等等。我们可以将其修改为中文。<br/>
<code>
&lt;template<br/>
format=&quot;5&quot;<br/>
revision=&quot;6&quot;<br/>
name=&quot;登陆界面&quot;<br/>
description=&quot;创建一个新的登陆界面&quot;<br/>
requireAppTheme=&quot;true&quot;<br/>
minApi=&quot;8&quot;<br/>
minBuildApi=&quot;14&quot;&gt;
</code></li>
<li>parameter标签<br/>
参数，也就是要在创建的时候自己设置的东西。每一个 parameter标签对应一个参数。这些参数会显示在创建页面上。也修改为中文。</li>
</ol>

<blockquote>
<ul>
<li>id ：唯一标识，最终通过该属性的值，获取用户输入值（文本框内容，是否选中）</li>
<li>name：界面上的类似label的提示语</li>
<li>type : 输入值类型</li>
<li>constraints：填写值的约束</li>
<li>suggest：建议值，比如填写ActivityName的时候，会给出一个布局文件的建议值。</li>
<li>default:默认值</li>
<li>help:底部显示的提升语</li>
</ul>
</blockquote>

<p>为方便用户输入Activity名称或Layout名称，自动提示Layout或Activity名称，需要在parameter中添加两个属性：  </p>

<pre><code class="language-text">constraints=&quot;class|unique|nonempty&quot;
suggest=&quot;${layoutToActivity(layoutName)}&quot;
suggest=&quot;${activityToLayout(activityClass)}&quot;
</code></pre>

<p><strong>示例</strong></p>

<pre><code class="language-markup">&lt;parameter
        id=&quot;activityClass&quot;
        name=&quot;活动类名&quot;
        type=&quot;string&quot;
        constraints=&quot;class|unique|nonempty&quot;
        default=&quot;LoginActivity&quot;
        help=&quot;填写所创建的活动类的名称&quot; /&gt;

    &lt;parameter
        id=&quot;layoutName&quot;
        name=&quot;布局文件名&quot;
        type=&quot;string&quot;
        constraints=&quot;layout|unique|nonempty&quot;
        suggest=&quot;${activityToLayout(activityClass)}&quot;
        default=&quot;activity_login&quot;
        help=&quot;填写所创建的布局文件的名称&quot; /&gt;

    &lt;parameter
        id=&quot;activityTitle&quot;
        name=&quot;标题栏标题&quot;
        type=&quot;string&quot;
        constraints=&quot;nonempty&quot;
        default=&quot;Sign in&quot;
        help=&quot;The name of the activity.&quot; /&gt;

    &lt;parameter
        id=&quot;parentActivityClass&quot;
        name=&quot;父活动类&quot;
        type=&quot;string&quot;
        constraints=&quot;activity|exists|empty&quot;
        default=&quot;&quot;
        help=&quot;配置父活动类，用于返回上一级按钮&quot; /&gt;

    &lt;parameter
        id=&quot;packageName&quot;
        name=&quot;包名&quot;
        type=&quot;string&quot;
        constraints=&quot;package&quot;
        default=&quot;com.mycompany.myapp&quot; /&gt;
</code></pre>

<h3 id="toc_11">thumbs</h3>

<p>里面放置了样例图,可以尝试更换。</p>

<h3 id="toc_12">globals.xml.ftl</h3>

<p>还要引入的依赖和包。<br/>
定义了全局变量，并引用了一个内置的通用globals.xml.ftl</p>

<pre><code class="language-text">&lt;globals&gt;
    &lt;global id=&quot;hasNoActionBar&quot; type=&quot;boolean&quot; value=&quot;false&quot; /&gt;
    &lt;global id=&quot;isLauncher&quot; type=&quot;boolean&quot; value=&quot;${isNewProject?string}&quot; /&gt;
    &lt;global id=&quot;includePermissionCheck&quot; type=&quot;boolean&quot; value=&quot;${(targetApi gte 23)?string}&quot; /&gt;
    &lt;global id=&quot;GenericStringArgument&quot; type=&quot;string&quot; value=&quot;&lt;#if buildApi lt 19&gt;String&lt;/#if&gt;&quot; /&gt;
    &lt;#include &quot;../common/common_globals.xml.ftl&quot; /&gt;
&lt;/globals&gt;
</code></pre>

<h3 id="toc_13">recipe.xml.ftl</h3>

<p>指定资源文件的路径并相应的生成到我们的项目目录去：</p>

<pre><code class="language-text">&lt;recipe&gt;
   &lt;#if appCompat &amp;&amp; !(hasDependency(&#39;com.android.support:appcompat-v7&#39;))&gt;
       &lt;dependency mavenUrl=&quot;com.android.support:appcompat-v7:${buildApi}.+&quot; /&gt;
    &lt;/#if&gt;

    &lt;#if (buildApi gte 22) &amp;&amp; appCompat &amp;&amp; !(hasDependency(&#39;com.android.support:design&#39;))&gt;
        &lt;dependency mavenUrl=&quot;com.android.support:design:${buildApi}.+&quot; /&gt;
    &lt;/#if&gt;

    &lt;merge from=&quot;root/AndroidManifest.xml.ftl&quot;
             to=&quot;${escapeXmlAttribute(manifestOut)}/AndroidManifest.xml&quot; /&gt;

    &lt;merge from=&quot;root/res/values/dimens.xml&quot;
             to=&quot;${escapeXmlAttribute(resOut)}/values/dimens.xml&quot; /&gt;

    &lt;merge from=&quot;root/res/values/strings.xml.ftl&quot;
             to=&quot;${escapeXmlAttribute(resOut)}/values/strings.xml&quot; /&gt;

    &lt;instantiate from=&quot;root/res/layout/activity_login.xml.ftl&quot;
                   to=&quot;${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml&quot; /&gt;

    &lt;instantiate from=&quot;root/src/app_package/LoginActivity.java.ftl&quot;
                   to=&quot;${escapeXmlAttribute(srcOut)}/${activityClass}.java&quot; /&gt;

    &lt;open file=&quot;${escapeXmlAttribute(srcOut)}/${activityClass}.java&quot; /&gt;

&lt;/recipe&gt;
</code></pre>

<blockquote>
<ul>
<li><strong>copy :</strong>从root中copy文件到我们的目标目录，比如我们的模板Activity需要使用一些图标，那么可能就需要使用copy标签将这些图标拷贝到我们的项目对应文件夹。</li>
<li><strong>merge :</strong> 合并的意思，比如将我们使用到的strings.xml合并到我们的项目的stirngs.xml中</li>
<li><strong>instantiate :</strong> 和copy类似，但是可以看到上例试将ftl-&gt;java文件的，也就是说中间会通过一个步骤，将ftl中的变量都换成对应的值，那么完整的流程是ftl-&gt;freemarker process -&gt; java。</li>
<li><strong>open:</strong>在代码生成后，打开指定的文件，比如我们新建一个Activity后，默认就会将该Activity打开。</li>
</ul>
</blockquote>

<h3 id="toc_14">增加kotlin模板</h3>

<p><strong>1. 创建Kotlin模板</strong></p>

<p>在创建的Java模板下直接创建kotlin模板，根据Java模板文件进行修改</p>

<p><strong>2. 修改recipe.xml.ftl</strong><br/>
打开recipe.xml.ftl将<code>java</code>改为<code>${ktOrJavaExt}</code>变量。</p>

<pre><code class="language-text">&lt;recipe&gt;
    &lt;instantiate from=&quot;root/src/app_package/LinActivity.${ktOrJavaExt}.ftl&quot;
        to=&quot;${escapeXmlAttribute(srcOut)}/${activityClass}.${ktOrJavaExt}&quot; /&gt;

    &lt;instantiate from=&quot;root/res/layout/activity_lin.xml.ftl&quot;
        to=&quot;${escapeXmlAttribute(resOut)}/layout/${layoutName}.xml&quot; /&gt;
&lt;/recipe&gt;
</code></pre>

<p><strong>3. 修改globals.xml.ftl</strong><br/>
打开<code>globals.xml.ftl</code>添加<code>ktOrJavaExt</code>变量声明：</p>

<pre><code class="language-text">&lt;#assign generateKotlin=(((includeKotlinSupport!false) ||(language!&#39;Java&#39;)?string == &#39;Kotlin&#39;))&gt;
&lt;global id=&quot;generateKotlin&quot; type=&quot;boolean&quot; value=&quot;${generateKotlin?string}&quot; /&gt;
&lt;global id=&quot;ktOrJavaExt&quot; type=&quot;string&quot; value=&quot;${generateKotlin?string(&#39;kt&#39;,&#39;java&#39;)}&quot; /&gt;
</code></pre>

<p>接着重启就可以创建Kotlin模板文件</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio之Debug: 运行期代码植入]]></title>
    <link href="http://adolph.cc/15779319049745.html"/>
    <updated>2020-01-02T10:25:04+08:00</updated>
    <id>http://adolph.cc/15779319049745.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">普通断点</h2>

<p>开发过程中普通断点在 Debug 过程中使用的算是最频繁的，只要在代码处添加该类型的断点，在 Debug 模式下，一旦代码执行到改行，程序将进入挂起状态，此时我们能查看到当前的运行状态，如图<br/>
<img src="media/15779319049745/15779319732376.jpg" alt=""/></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">条件断点</h2>

<p>当添加断点的方法会被多次执行到，而我们只希望程序在特定的一些特定的地方（如只有在当前的 user 是黑寡妇时）断下来，此时我们可以借助条件断点，如下<br/>
<img src="media/15779319049745/condition_breakpoint.gif" alt="condition_breakpoint"/><br/>
<strong>注意看一下Condition部分，此处需要返回一个boolean类型的值，该值就是为了告诉程序当执行到该行代码时是否进行断点，true 表示进行断点，false 反之。</strong>上面只需要对黑寡妇进行断点，所以添加的Condition是&quot;黑寡妇&quot;.equals(user.getName())。</p>

<h2 id="toc_2">改变变量状态</h2>

<p>有时需要对断点时的变量赋值操作，已更改此时变量的值，这时可以使用<code>Set Value</code>方式，如下<br/>
<img src="media/15779319049745/set_value.gif" alt="set_value"/></p>

<p>除了<code>Set Value</code>，还可以通过估值器进行改变值状态，如下<br/>
<img src="media/15779319049745/evaluate.gif" alt="evaluate"/></p>

<h2 id="toc_3">条件断点 + 代码植入</h2>

<p>改变变量状态能够动态地设置变量值，条件断点可以控制断点是能在此处挂起，那将两者结合就能达到在程序不挂起的情况下进行动态代码植入的效果。<br/>
<img src="media/15779319049745/insert_code.gif" alt="insert_code"/></p>

<p><code>Condition</code>里插入的代码如下</p>

<pre><code class="language-java">if (&quot;黑寡妇&quot;.equals(user.getName())) {
    user.setSex(&quot;女&quot;);
}
// 此处返回false为了告诉IDE在该断点出不对程序执行挂起操作
return false;
</code></pre>

<p>这就相当于提供了运行期代码的动态植入功能，而且可以通过Enable/Disable断点的状态来进行开启 / 关闭该部分动态代码是否执行。我们可以通过这种方式添加任何希望添加的代码，比如在每个 user 对象 print 之前添加自定一段 print<br/>
<img src="media/15779319049745/insert_print.gif" alt="insert_print"/></p>

<h2 id="toc_4">应用场景</h2>

<p>Debug 期间动态植入的应用场景其实有很多的，对应 Android 端，有时候只需要改变一个变量，添加一行代码就需要重新 run 整个 Project，需要花费整个 compile 和 install 的时间才能看出改动之后的效果，如果当前这次更改无效的话，甚至需要再次修改再次运行，而通过 debug 方式，可以直接对其进行操作。对于后端每次改动之后的重新部署也一样（不考虑动态部署的情况）。</p>

<p>以 Android 场景为例，如下的代码，接收一个<code>imageUrl</code>参数并加载出来</p>

<pre><code class="language-java">public class ImageActivity extends Activity {

    private static final String KEY_CONTENT = &quot;imageUrl&quot;;

    public static void open(Context context, String content) {
        Intent intent = new Intent(context, ImageActivity.class);
        intent.putExtra(KEY_CONTENT, content);
        context.startActivity(intent);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ImageView imageView = findViewById(R.id.image);
        // 取出参数内容
        String imageUrl = getIntent().getStringExtra(KEY_CONTENT);
        Glide.with(this).load(imageUrl).into(imageView);
    }
}
</code></pre>

<p>未植入代码之前，跳转到当前页面是这样的</p>

<p><img src="media/15779319049745/15779322770179.jpg" alt=""/></p>

<p>此时如果需要动态改变当前的<code>imageUrl</code>参数，可以进行 Debug 模式，并通过动态代码植入方式进行<code>imageUrl</code>变量的重赋值，如下<br/>
<img src="media/15779319049745/insert_image_url.gif" alt="insert_image_ur"/></p>

<p>添加植入的复制代码之后，进入 Debug 模式，然后重新进入该页面，显示的图片便替换为修改后的了。</p>

<p><img src="media/15779319049745/15779323353887.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio 代码块打标]]></title>
    <link href="http://adolph.cc/15779324219058.html"/>
    <updated>2020-01-02T10:33:41+08:00</updated>
    <id>http://adolph.cc/15779324219058.html</id>
    <content type="html"><![CDATA[
<p>Android Studio 代码块打标，让我们迅速定位到代码逻辑块。当我们开发中写的某些类的代码量相对比较庞大时，就会遇到维护这个类变得困难的问题，抛开对于该类的设计层面的因素，只从代码量的角度来看这个问题。基于 IntelliJ 的 IDE 给我们提供了一种能够给我们的代码块进行归纳的标签（以下称为<code>代码块打标</code>），如下</p>

<span id="more"></span><!-- more -->

<pre><code class="language-text">// &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;[A]&quot;&gt;
[B]
// &lt;/editor-fold&gt;
</code></pre>

<p>其中，<code>[A]</code>对应打标的描述语言，<code>[B]</code>对应待打标代码块。</p>

<p>根据上述规则我们来对MainActivity进行打标操作，代码如下</p>

<pre><code class="language-java">/**
 * @author zijiao
 * @version 17/3/21
 */
public class MainActivity extends Activity {

    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;成员变量&quot;&gt;
    private Button button;
    // &lt;/editor-fold&gt;

    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;onCreate逻辑&quot;&gt;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
        initListener();
    }
    // &lt;/editor-fold&gt;

    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findView逻辑&quot;&gt;
    private void initView() {
        button = (Button) findViewById(R.id.button);
    }
    // &lt;/editor-fold&gt;

    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;点击事件处理逻辑&quot;&gt;
    private void initListener() {
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Toast.makeText(MainActivity.this, &quot;Click button&quot;, Toast.LENGTH_SHORT).show();
            }
        });
    }
    // &lt;/editor-fold&gt;
}
</code></pre>

<p>可以看到我们将各个代码块按照逻辑进行分类并添加对应的描述标签，当我们下次再打开该类时，查看或修改某部分代码就会一目了然（当代码庞大时，其优点将会尤为明显），参见下图<br/>
<img src="media/15779324219058/img1.gif" alt="img1"/></p>

<p>可以看到代码块打标是很方便，但是有一点不好，就是当我们需要给某一个代码块打标时我们总是要在代码块之前添加</p>

<pre><code class="language-text">// &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;[A]&quot;&gt;
</code></pre>

<p>然后在代码块之后添加</p>

<pre><code class="language-text">// &lt;/editor-fold&gt;
</code></pre>

<p>这个步骤很繁琐，但好消息是我们可以结合 AS 提供给我们的<code>LiveTempalte</code>，将这个过程封装成一个打标模板，来看看具体操作</p>

<ol>
<li>打开 Android Studio，进入<code>Preferences</code> — <code>Editor</code> — <code>Live Templates</code> ，新建一个<code>Live Template</code></li>
<li><code>Abbreviation</code>处填写<code>Mark Code Block</code>，<code>Template text</code>处填写
<code>
// &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;$description$&quot;&gt;<br/>
$SELECTION$<br/>
// &lt;/editor-fold&gt;
</code></li>
<li>点击<code>Define</code>，勾选<code>Java</code>复选框</li>
<li>点击<code>Apply</code></li>
</ol>

<p>这个时候你的界面应该是这样，可以核对下</p>

<p><img src="media/15779324219058/15779326947038.jpg" alt=""/></p>

<p>到这里，打标模板已经完成了，你可以随便找一个类进行测试，选中一个代码块，按下快捷键<code>Command + Option + J</code>（Windows 系统可以在Preferences — Keymap 中搜索<code>Surround with Live Template...</code>对应的快捷键）来选择<code>Mark Code Block</code>模板，此时我们就可以快速进行代码块打标操作了，如下图<br/>
<img src="media/15779324219058/img3.gif" alt="img3"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio 模板之文件]]></title>
    <link href="http://adolph.cc/15779341495897.html"/>
    <updated>2020-01-02T11:02:29+08:00</updated>
    <id>http://adolph.cc/15779341495897.html</id>
    <content type="html"><![CDATA[
<p>文件模板是指以一个文件为基础的模板，这种形式的模板比代码片段级别的模板要复杂一些，模板中设计到 VTL(Velocity Template Language) 语法。文件级别比代码级别能够存储更多的代码内容，而且能够通过 VTL 很大程度上提高模板的灵活度，让模板不再是一个不变的文本字符串。</p>

<span id="more"></span><!-- more -->

<p>我们开发的过程中可能会遇到有些类在不同的工程下都需要使用，单独抽成 jar 包可能又有点小题大做了，而且还得在下次使用的时候去依赖它，这个时候我们 AS 中的 FileTemplate 便派上用场了。<br/>
<img src="media/15779341495897/fileTemplate1.gif" alt="fileTemplate1"/></p>

<p>我们开发中可能经常去写一个继承 BaseAdapter 的子 Adapter，而且里面有一大串无脑代码，于是我写了这个 DataAdapter 的模板。</p>

<p>Android Studio 给我提供了创建模板的快捷方式，我们可以打开任意一个类，然后选择顶部的 <code>Tools</code> — <code>Save File As Template</code> 便可以快速创建一个当前类的模板文件</p>

<p><img src="media/15779341495897/fileTemplate2.gif" alt="fileTemplate2"/></p>

<p>或者直接通过 <code>Preferences</code> — <code>Editor</code> — <code>File and Code Templates</code>右边的加号创建</p>

<p><img src="media/15779341495897/15779342797674.jpg" alt=""/></p>

<p>然后 IDE 会自动打开这个界面</p>

<p><img src="media/15779341495897/15779343035255.jpg" alt=""/></p>

<p>大致说下这几个区域</p>

<ul>
<li>区域 1：模板的名称，唯一标识一个文件模板</li>
<li>区域 2：模板的后缀名，填写当前属于哪种文件的模板</li>
<li>区域 3：模板编辑区</li>
<li>区域 4：一些可选配置</li>
<li>区域 5：官方对 FileTemplate 的简单描述，往下滑我们可以看到系统的预设变量（类似于上一章中的预设变量），这里的内容不是很多但营养价值很高，建议看一下<br/>
接下来我们编辑模板，把这段模板内容直接粘贴到编辑区，然后给模板命名为 User 即保存关闭该弹窗</li>
</ul>

<pre><code class="language-text">#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME};#end

/**
 * @author ${USER}
 * @version ${DATE}
 */
public class ${NAME} {
    public String[] name = {};
}
</code></pre>

<p>现在我们来引入刚写的模板，<code>右键选择待添加模板的包</code> — <code>New</code> — <code>User</code></p>

<p><img src="media/15779341495897/15779343664551.jpg" alt=""/></p>

<p>也可以 New 一个 Java Class 然后在弹窗中通过上下方向键或者下拉列表来选择找到创建的 User 模板</p>

<p><img src="media/15779341495897/15779343806654.jpg" alt=""/></p>

<p>还可以直接在 New 下面选择</p>

<p><img src="media/15779341495897/fileTemplate4.gif" alt="fileTemplate4"/></p>

<p>创建模板之后的引入方式有很多，我们可以使用自己比较喜欢的方式去引入。最终输入文件名点确定，代码直接生成出来。</p>

<p>上面说的是最基本的文件模板需求，当我们的文件需要多个参数时，例如 User 这个模板的 name 属性名可能是多边的，只有引入模板时才能确定下来，这时我们可以用自定义变量来表示，如下</p>

<pre><code class="language-text">#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME};#end

/**
 * @author ${USER}
 * @version ${DATE}
 */
public class ${NAME} {
    public String[] ${fieldName} = {};
}
</code></pre>

<p>这个时候我们再引入模板时，IDE 会扫描有没有自定义变量，如果有的并且没有被初始化赋值的话就在弹出的对话框中多一个可编辑的区域，如下图</p>

<p><img src="media/15779341495897/15779344367462.jpg" alt=""/></p>

<p>这便支持自定义参数的场景，到这一步为止，一般的文件模板需求我们都可以自己满足了。下面介绍一些相对深一点的使用方式，有兴趣的可以看看。</p>

<p>Android Studio 的 FileTemplate 使用 Velocity Template Language（简称 VTL）进行逻辑判断和流程控制，有兴趣的可以直接看下 Velocity 的<a href="http://velocity.apache.org/engine/devel/user-guide.html#Velocity_Template_Language_VTL:_An_Introduction">官方文档</a>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio 模板之代码片段]]></title>
    <link href="http://adolph.cc/15779345043093.html"/>
    <updated>2020-01-02T11:08:24+08:00</updated>
    <id>http://adolph.cc/15779345043093.html</id>
    <content type="html"><![CDATA[
<p>代码片段是 Template 上的最小单位，因此它也具有最大的灵活性，支持多参数配置、TAB 切换、代码块包装等多种特性（IDEA 同样适用）。</p>

<p>创建一个单例类<br/>
<img src="media/15779345043093/LiveTemplate1.gif" alt="LiveTemplate1"/></p>

<span id="more"></span><!-- more -->

<p>自定义具体位置我们可以进入 IDE，<code>Preserences</code> - <code>Editor</code> - <code>Live Templates</code>，我们可以在右边栏看到一些列 IDE 预设的 template，如下图</p>

<p><img src="media/15779345043093/15779345903837.jpg" alt=""/></p>

<p>这里我们展开 Android，可以看到下图</p>

<p><img src="media/15779345043093/15779346084021.jpg" alt=""/></p>

<p>这里面所有的我们都可以使用，括号后面的内容是为了描述该模板的，你也可以取消前面的勾选来取消该模板。</p>

<p>其实系统预设的有很多都是很实用的，有兴趣的可以去试一试，不多说。这里主要看一下如何自定义模板，把一些常用的代码片段 DIY 到自己的模板库中，当下次再需要同样代码的时候只需要一个标识符就能迅速自动生成。</p>

<p>我们点击右上角的加号，我们可以看到两个选项一个是 Live Template，这个表示一个模板，另一个是 Template Group，这个表示一个模板所属的分组，就像上面看到的 Android，它就属于一个分组。</p>

<p><img src="media/15779345043093/15779346294137.jpg" alt=""/></p>

<p>接下来我们先创建一个自己的 Template Group，名称随便取，不要与已有的分组重名就行，这里就取为 Custom。然后我们选中新建的这个 Custom 分组再创建 Live Template，会看到如下界面</p>

<p><img src="media/15779345043093/15779346544960.jpg" alt=""/></p>

<p>我对这个界面做了数字标志，大致说下每个区域代表的含义</p>

<ul>
<li>区域 1：表示模板的缩写，也是我们最终使用时在编辑区输入的指令</li>
<li>区域 2：表示模板的提示，当输入对应缩写时，就会弹出这个提示</li>
<li>区域 3：这里就是最关键的模板区了，模板区包含两部分，一个是模板内容，它可以是任意字符串，另一个是模板变量，它有自己特殊的含义并且格式固定，首尾都是”\(” 符。模板变量又包含预设变量和自定义变量，比如”\)END$” 就是一个预设变量，它指定了模板导入结束后鼠标光标最终要停留的位置，而自定义变量则表示模板中一些动态性的部分，比如类名，它在不同的类中引入的结果是不同的。在多个自定义变量的情况下引入模板时，默认按 TAB 键切换至下个自定义变量位置。</li>
<li>区域 4：自定义变量的配置入口，可以给我们的自定义变量添加一些约束条件</li>
<li>区域 5：指定该模板的作用域，例如指定用于 Java 还是 groovy 等等</li>
<li>区域 6：提供一些引入模板的可选操作<br/>
这里我们来写一个生成单例的模板，我们按照下图定义好缩写，描述与模板内容</li>
</ul>

<p><img src="media/15779345043093/15779346837212.jpg" alt=""/></p>

<p>模板内容的代码如下</p>

<pre><code class="language-text">private static final byte[] sInstanceLock = new byte[0];
private static $className$ sInstance;

private $className$() {
}

public static $className$ instance() {
    if (sInstance == null) {
        synchronized (sInstanceLock) {
            if (sInstance == null) {
                sInstance = new $className$();
            }
        }
    }
    return sInstance;
}
</code></pre>

<p>然后我们选择区域 4 来编辑我们的自定义变量，我们进去后可以看到如下弹窗</p>

<p><img src="media/15779345043093/15779347128525.jpg" alt=""/></p>

<ul>
<li>Name 为自定义的变量名称</li>
<li>Expression 表示系统提供的一些方法</li>
<li>Default value 为改变量的默认值</li>
<li>Skip if define 勾选后，如果该变量被赋值则跳过，相当于引入过程中一次手动的 TAB<br/>
接着我们在 Expression 中选择 className()，并勾选 Skip if define，并点击确定</li>
</ul>

<p><img src="media/15779345043093/15779347348794.jpg" alt=""/></p>

<p>最后我们点击区域 5 来选择模板的作用域，我们选择 <code>Java</code> — <code>Declaration</code></p>

<p><img src="media/15779345043093/15779347538507.jpg" alt=""/></p>

<p>然后保存，我们的单例模板便生成成功了。测试下，在 IDE 中新建个 Java 类，在类的内部输入 single 便出现最上面的那个 UserManager 的效果。</p>

<p>当然除此之外还有使用”\(SELECTION\)” 来包装代码块的模板，这个使用场景相对较少这里就不举例了，主要使用的就是这种直接的模板模式。感觉一些常用的，特别是工具类中静态方法相关的，我们都可以抽取成模板，提高开发效率。</p>

]]></content>
  </entry>
  
</feed>
