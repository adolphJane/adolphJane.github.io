<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MagicalRice的Blog]]></title>
  <link href="http://adolph.cc/atom.xml" rel="self"/>
  <link href="http://adolph.cc/"/>
  <updated>2019-10-07T09:39:16+08:00</updated>
  <id>http://adolph.cc/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[iTerm2工具学习使用]]></title>
    <link href="http://adolph.cc/15704556102016.html"/>
    <updated>2019-10-07T21:40:10+08:00</updated>
    <id>http://adolph.cc/15704556102016.html</id>
    <content type="html"><![CDATA[
<p>之前也简单使用过iTerm2，但是没感觉到和Mac系统终端有太大的区别。所以现在决定好好了解，系统的学习下iTerm2来提供自身的开发效率。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">下载iTerm2</h2>

<p>官网下载: <a href="https://www.iterm2.com/">https://www.iterm2.com/</a><br/>
Mac系统默认使用bash作为终端(可以通过<code>echo $SHELL</code>命令进行查看)，可以使用命令修改默认使用zsh：</p>

<pre class="line-numbers"><code class="language-text">chsh -s /bin/zsh
</code></pre>

<h2 id="toc_1">替换背景图片</h2>

<pre class="line-numbers"><code class="language-text">打开路径iterm2 -&gt; Preferences -&gt; Profiles -&gt; window -&gt; Background Image
</code></pre>

<p>选择一张自己喜欢的壁纸即可</p>

<p>可以通过Blending调节壁纸的透明度: 透明度为0的时候,背景变为纯色(黑色)</p>

<h2 id="toc_2">安装Oh my zsh</h2>

<p>zsh的功能极其强大，只是配置过于复杂,通过Oh my zsh可以很快配置zsh。<br/>
安装方法有两种，可以使用curl或wget，看自己环境或喜好：</p>

<pre class="line-numbers"><code class="language-shell"># curl 安装方式
sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;
</code></pre>

<pre class="line-numbers"><code class="language-shell"># wget 安装方式
sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;
</code></pre>

<p>oh-my-zsh开源地址：<a href="https://github.com/robbyrussell/oh-my-zsh">《oh-my-zsh》</a></p>

<h2 id="toc_3">安装PowerLine</h2>

<p>首先先安装pip命令</p>

<pre class="line-numbers"><code class="language-shell">sudo easy_install pip
</code></pre>

<p>安装powerline</p>

<pre class="line-numbers"><code class="language-shell">pip install powerline-status --user
</code></pre>

<h2 id="toc_4">安装PowerFonts</h2>

<p>在常用的位置新建一个文件夹，如：/Users/**/Development/OpenSource</p>

<p>在OpenSource文件夹下下载PorweFonts:</p>

<pre class="line-numbers"><code class="language-shell"># git clone
git clone https://github.com/powerline/fonts.git --depth=1

# cd to folder
cd fonts

# run install shell
./install.sh
</code></pre>

<p>安装好字体库之后，我们来设置iTerm2的字体，具体的操作是</p>

<pre class="line-numbers"><code class="language-text">iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text
</code></pre>

<p>在Font区域选中Change Font，然后找到Meslo LG字体。</p>

<p><figure><img src="media/15704556102016/15704572147711.jpg" alt=""/></figure></p>

<h2 id="toc_5">安装主题</h2>

<p>用<code>vim ~/.zshrc</code>打开隐藏文件，修改主题为<code>agnoster</code></p>

<h2 id="toc_6">设置配色方案</h2>

<p>通过oh-my-zsh设置完主题后，使用ITerm2自带的几个背景色显示看得不舒服，下载其他的颜色方案较美观。我选用的是solarized，效果还不错。点开官网，下载，解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors。之后在Color Presets中选中Solarized Dark配色。</p>

<h2 id="toc_7">自动提示命令</h2>

<p>当我们输入命令时，终端会自动提示你接下来可能要输入的命令，这时按 → 便可输出这些命令，非常方便。</p>

<ul>
<li>克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下</li>
</ul>

<pre class="line-numbers"><code class="language-text">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions
</code></pre>

<ul>
<li>用 vim  ~/.zshrc 打开文件，下滑找到插件设置命令，默认是 plugins=(git) ，我们把它修改为</li>
</ul>

<pre class="line-numbers"><code class="language-text">plugins=(zsh-autosuggestions git)
</code></pre>

<ul>
<li>重新打开终端窗口。</li>
</ul>

<p>有时候因为自动填充的颜色和背景颜色很相似，以至于自动填充没有效果，我们可以手动更改下自动填充的颜色配置。Preferences -&gt; Profiles -&gt; Colors -&gt; ANSI Colors -&gt; Bright</p>

<h2 id="toc_8">语法高亮</h2>

<ol>
<li>使用homebrew安装zsh-syntax-highlighting 插件。</li>
</ol>

<pre class="line-numbers"><code class="language-text">brew install zsh-syntax-highlighting
</code></pre>

<ol>
<li>vim ~/.zshrc配置文件，插入一行，保存退出。</li>
</ol>

<pre class="line-numbers"><code class="language-text">source  /usr/local/Cellar/zsh-syntax-highlighting/0.6.0/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
</code></pre>

<p>PS：上面的路径是brew安装插件成功后的路径，安装成功会有显示，复制记录一下。</p>

<ol>
<li>输入命令。
<code>
source ~/.zshrc
</code></li>
</ol>

<h2 id="toc_9">给ITerm中Vim配色</h2>

<p>Vim 的配色最好和终端的配色保持一致，不然在 Terminal/iTerm2 里使用命令行 Vim 会很别扭。</p>

<pre class="line-numbers"><code class="language-text">$ cd solarized

$ cd vim-colors-solarized/colors

$ mkdir -p ~/.vim/colors 

$ cp solarized.vim ~/.vim/colors/

$ vi ~/.vimrc

加入下面三行设置即可

syntax enable

set background=dark

colorscheme solarized
</code></pre>

<p>重启iTerm2</p>

<h2 id="toc_10">左右键跳转</h2>

<p>主要是按住<code>option + → or ←键</code>，在命令的开始和结尾跳转切换，原本是不生效的，需要手动开启下。</p>

<p>打开 iTerm2，按<code>Command + ,</code>键，打开 Preferences 配置界面，然后<code>Profiles → Keys → Load Preset... → Natural Text Editing</code>，就可以了。</p>

<h2 id="toc_11">iTerm2 隐藏用户名和主机名</h2>

<p>有时候我们的用户名和主机名太长，比如我的adolph@adolphdeMacBook-Pro，终端显示的时候会很不好看，我们可以手动去除。</p>

<p>编辑<code>vim ~/.zshrc文件</code>，增加<code>DEFAULT_USER=&quot;adolph&quot;</code>配置。</p>

<p>我们可以通过whoami命令，查看当前用户。</p>

<h2 id="toc_12">iTerm2 快捷命令</h2>

<p>快捷命令说明：</p>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">command + t</td>
<td style="text-align: left">新建标签</td>
</tr>
<tr>
<td style="text-align: left">command + w</td>
<td style="text-align: left">关闭标签</td>
</tr>
<tr>
<td style="text-align: left">command + 数字 command + 左右方向键</td>
<td style="text-align: left">切换标签</td>
</tr>
<tr>
<td style="text-align: left">command + enter</td>
<td style="text-align: left">切换全屏</td>
</tr>
<tr>
<td style="text-align: left">command + f</td>
<td style="text-align: left">查找</td>
</tr>
<tr>
<td style="text-align: left">command + d</td>
<td style="text-align: left">垂直分屏</td>
</tr>
<tr>
<td style="text-align: left">command + shift + d</td>
<td style="text-align: left">水平分屏</td>
</tr>
<tr>
<td style="text-align: left">command + option + 方向键 command + [ 或command + ]</td>
<td style="text-align: left">切换屏幕</td>
</tr>
<tr>
<td style="text-align: left">command + ;</td>
<td style="text-align: left">查看历史命令</td>
</tr>
<tr>
<td style="text-align: left">command + shift + h</td>
<td style="text-align: left">查看剪贴板历史</td>
</tr>
<tr>
<td style="text-align: left">ctrl + u</td>
<td style="text-align: left">清除当前行</td>
</tr>
<tr>
<td style="text-align: left">ctrl + l</td>
<td style="text-align: left">清屏</td>
</tr>
<tr>
<td style="text-align: left">ctrl + a</td>
<td style="text-align: left">到行首</td>
</tr>
<tr>
<td style="text-align: left">ctrl + e</td>
<td style="text-align: left">到行尾</td>
</tr>
<tr>
<td style="text-align: left">ctrl + f/b</td>
<td style="text-align: left">前进后退</td>
</tr>
<tr>
<td style="text-align: left">ctrl + p</td>
<td style="text-align: left">上一条命令</td>
</tr>
<tr>
<td style="text-align: left">ctrl + r</td>
<td style="text-align: left">搜索命令历史</td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Homebrew学习]]></title>
    <link href="http://adolph.cc/15704404393204.html"/>
    <updated>2019-10-07T17:27:19+08:00</updated>
    <id>http://adolph.cc/15704404393204.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">简介</h2>

<p>Homebrew是Mac OSX常见的包管理器(命令brew用于命令行工具, brew cask管理带UI软件), 类似 ubuntu下apt-get, centOS的yum. 推荐日常Mac下安装卸载软件使用.</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">安装Homebrew</h2>

<pre class="line-numbers"><code class="language-text">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre>

<h2 id="toc_2">使用Homebrew</h2>

<ul>
<li>帮助信息: brew help(-h)</li>
<li>基本使用</li>
</ul>

<pre class="line-numbers"><code class="language-shell"># 更新所有软件
brew update
# 安装应用, 例如wget, 安装到/usr/local/Cellar/wget, ln到/usr/local/bin目录下
brew install wget
# 安装带UI app, 插件, 字体(fonts)及其他非开源应用
brew cask install firefox
# 更新具体软件
brew upgrade git
# 诊断依赖冲突等
brew doctor
# 搜索app
brew search xxx
# 卸载xxx.app
brew uninstall xxx
# 列出安装的包
brew list
</code></pre>

<ul>
<li>其他命令</li>
</ul>

<pre class="line-numbers"><code class="language-shell"># 打开包主页
brew home git
# 查看包信息
brew info git
# 查看包依赖
brew deps wget  #结果显示gettext libidn2  libunistring openssl
# 清理旧版本
brew cleanup git
brew cleanup
# 显示是否有新版本可用
brew outdated
</code></pre>

<h2 id="toc_3">卸载Homebrew</h2>

<pre class="line-numbers"><code class="language-shell">cd `brew –prefix`
rm -rf Cellar
brew cleanup
rm -rf Homebrew
rm -rf ~/Library/Caches/Homebrew
</code></pre>

<h2 id="toc_4">Homebrew Cask</h2>

<p>Homebrew Cask 是 Homebrew 的扩展，借助它可以方便地在 macOS 上安装图形界面程序，即我们常用的各类应用。</p>

<h3 id="toc_5">安装</h3>

<pre class="line-numbers"><code class="language-shell">brew tap phinze/homebrew-cask
brew install brew-cask
</code></pre>

<h4 id="toc_6">可视化Homebrew安装工具</h4>

<p><code>brew cask install cakebrew</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker学习]]></title>
    <link href="http://adolph.cc/15663678647312.html"/>
    <updated>2019-08-21T14:11:04+08:00</updated>
    <id>http://adolph.cc/15663678647312.html</id>
    <content type="html"><![CDATA[
<p>最近要搞微服务，学习了很多，发现网上对使用Docker进行部署推崇备至，而且之前也用过Docker来搭建Maven私有仓库和Redis，觉得学习下整理一篇博客还是蛮有必要的哈哈。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">应用场景</h2>

<ul>
<li>Web 应用的自动化打包和发布。</li>
<li>自动化测试和持续集成、发布。</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用。</li>
<li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li>
</ul>

<h2 id="toc_1">CentOs安装Docker</h2>

<p>看了网上很多教程，发现没有说的那么麻烦，还是很传统的下载安装方式。</p>

<ul>
<li>先进行yum更新<code>yum update</code></li>
<li>使用yum命令进行安装<code>yum install -y docker</code>(备注：-y 表示不询问 使用默认配置进行安装，等待提示  完毕！)</li>
<li>查看是否安装成功<code>yum list installed | grep docker</code>(备注：命令为 查看yum安装完成文件列表 并 筛选docker安装信息)</li>
<li>启动docker服务<code>systemctl start docker</code></li>
<li>查看是否启动成功<code>systemctl status docker</code></li>
<li>使用docker命令 <code>docker images</code>(备注：查看docker已经安装的镜像 裸机状态下为空)</li>
</ul>

<h2 id="toc_2">Docker常用命令</h2>

<h3 id="toc_3">从docker仓库搜索镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker search [镜像名称]
</code></pre>

<h3 id="toc_4">拉取镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker image pull 镜像名称:版本号 # 不指定版本默认为最新版
</code></pre>

<h3 id="toc_5">删除镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker image rm 镜像名称/镜像ID
</code></pre>

<h3 id="toc_6">查看本地镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker images
</code></pre>

<h3 id="toc_7">重命名镜像</h3>

<pre class="line-numbers"><code class="language-bash">docker tag [old_name] [new_name]
</code></pre>

<h3 id="toc_8">创建容器</h3>

<pre class="line-numbers"><code class="language-bash">docker run [option] 镜像名 [向启动容器中传入的命令]
</code></pre>

<p>[option]常用可选参数说明：</p>

<ul>
<li>-i 表示以“交互模式”运行容器,与容器交互</li>
<li>-t 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即 分配一个伪终端。</li>
<li>–name 为创建的容器命名</li>
<li>-v 表示目录映射关系(前者是宿主机目录，后者是映射到宿主机上的目录，即 宿主机目录:容器中目录)，可以使 用多个-v 做多个目录或文件映射。注意:最好做目录映射，在宿主机上做修改，然后 共享到容器上。</li>
<li>-d 在run后面加上-d参数,则会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器，如果只加-i -t 两个参数，创建后就会自动进去容器)。</li>
<li>-p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p 做多个端口映射</li>
<li>-e 为容器设置环境变量</li>
<li>–network=host 表示将主机的网络环境映射到容器中，容器的网络与主机相同 </li>
<li>-rm 在容器退出时，自动删除其缓存</li>
</ul>

<pre class="line-numbers"><code class="language-bash">sudo docker run -it –name=ubuntu1 113a43faa138 /bin/bash

# -it 创建一个伪终端交互界面，name指定容器名称，否则随机一个名字 113a43faa138 镜像id /bin/bash 创建后执行的命令 
</code></pre>

<pre class="line-numbers"><code class="language-bash">sudo docker run -dit --name=ubuntu -v ~/Desktop/ceshi:/ceshi ubuntu
# -v &lt;本机目录:容器目录&gt;创建一个共享目录，左边是本机的目录，右边是容器中的目录，在本机修改内容对应的容器中的目录内容也会改变, 目录不存在会自动创建
</code></pre>

<h3 id="toc_9">查看所有容器</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker container ls #查看所有正在运行的容器
sudo docker container ls --all # 查看所有已创建的容器
</code></pre>

<ul>
<li>container id 容器id</li>
<li>image 镜像名称</li>
<li>command 创建后运行的命令</li>
<li>created 创建时间</li>
<li>status 关闭时间</li>
<li>ports 绑定的端口</li>
<li>names 容器名称</li>
</ul>

<h3 id="toc_10">运行已经开启的容器</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker container exec -it &lt;容器名/id&gt; &lt;运行后使用的第一个命令&gt;
# 运行使用的第一个命令一般默认为 /bin/bash 否则无法进入交互界面
</code></pre>

<h3 id="toc_11">停止与启动容器</h3>

<pre class="line-numbers"><code class="language-bash"># 停止一个已经在运行的容器
sudo docker container stop [容器名或容器id]

# 启动一个已经停止的容器
sudo docker container start [容器名或容器id]

# kill掉一个已经在运行的容器
sudo docker container kill [容器名]
</code></pre>

<h3 id="toc_12">删除容器</h3>

<pre class="line-numbers"><code class="language-bash">docker container rm [容器名或容器id]
</code></pre>

<h3 id="toc_13">容器保存为镜像</h3>

<pre class="line-numbers"><code class="language-bash">sudo docker commit [容器名] [镜像]名
sudo docker commit ubuntu1 myubuntu  # 将容器名为ubuntu1的容器转换为叫myuntu的镜像，原本的容器并不会删除
</code></pre>

<h4 id="toc_14">镜像打包成文件</h4>

<pre class="line-numbers"><code class="language-bash">sudo docker save -o 保存的文件名 镜像名
sudo docker save -o ./ubuntu.tar ubuntu
</code></pre>

<h4 id="toc_15">将镜像加载到本地</h4>

<pre class="line-numbers"><code class="language-bash">sudo docker load -i  &lt;文件名&gt;
sudo docker load -i ./ubuntu.tar
</code></pre>

<h2 id="toc_16">Dockerfile</h2>

<p>Dockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。</p>

<h3 id="toc_17">Dockerfile的格式</h3>

<ol>
<li>#用来表示注释。</li>
<li>指令大小写不敏感，一般大写，参数小写。</li>
<li>Docker顺序执行Dockerfile中的指令来构建image。</li>
<li>第一个指令以&quot;From&quot;开始。</li>
<li>Dockerfile文件名首字母必须大写。</li>
</ol>

<h3 id="toc_18">工作目录</h3>

<p>Dockerfile在制作过程中，所有相关的文件都需要在一个文件夹中，这个文件夹叫做工作目录，Dockerfile所在的目录及其子目录。</p>

<pre class="line-numbers"><code class="language-text">mkdir /tmp/image1
cd /tmp/image1
</code></pre>

<h3 id="toc_19">Dockerfile指令</h3>

<h4 id="toc_20">FROM命令</h4>

<p>除了注释行外，Dockerfile的第一个命令。</p>

<pre class="line-numbers"><code class="language-text">FROM &lt;repository&gt;[:&lt;tag&gt;]
FROM &lt;repository&gt;@&lt;digest&gt;
  repository:指定base image的名称
  tag: 指定base image的标签
  digest：image的hashcode
</code></pre>

<h4 id="toc_21">LABLE命令</h4>

<p>用于提供Dockerfile制作者的信息，这个命令可以出现在任何位置，一般建议在FROM指令之后。用key value的形式来描述一个image的metadata。</p>

<pre class="line-numbers"><code class="language-text">LABLE &lt;key&gt;=&lt;value&gt;
例如：
LABLE maintainer=&quot;leveldc&lt;leveldc@126.com&gt;&quot;
</code></pre>

<h4 id="toc_22">COPY命令</h4>

<p>用于从宿主机复制文件到镜像文件。</p>

<pre class="line-numbers"><code class="language-text">COPY &lt;src&gt;...&lt;dist&gt;
COPY [&quot;&lt;src&gt;&quot;,...&quot;&lt;dist&gt;&quot;]
  src:  复制文件的源文件或目录，支持通配符
  dist: 目标路径
说明：
1. &lt;src&gt;必须是build的上下文中的路径，不能是其父目录的文件。
2. 如果&lt;src&gt;是目录，其内部文件及子目录会被递归复制，&lt;src&gt;本身不会被复制。
3. 如果指定了多个&lt;src&gt;或在&lt;src&gt;中使用了通配符，则&lt;dist&gt;必须是一个目录，且以/结束。
4. 如果&lt;dist&gt;不存在，会被自动创建，包括其父目录。
例如：
COPY index.html /data/web/html
</code></pre>

<h4 id="toc_23">ADD命令</h4>

<p>类似COPY命令， 支持TAR文件或者TAR.gz和URL路径。<br/>
TAR:拷贝本地的tar文件会自动解压缩到docker镜像中。<br/>
URL:拷贝服务器地址上的文件并将文件添加到docker 镜像中。</p>

<pre class="line-numbers"><code class="language-text">ADD &lt;src&gt;...&lt;dist&gt;
ADD [&quot;&lt;src&gt;&quot;,...&quot;&lt;dist&gt;&quot;]
  src:  添加文件的源文件或目录，支持通配符
  dist: 目标路径
说明：
1. 如果&lt;src&gt;为URL且&lt;dist&gt;不以/结尾则&lt;src&gt;指定的文件将被直接下载并创建为&lt;dist&gt;;如果以/结尾，则文件被拷贝至&lt;dist&gt;/&lt;filename&gt;
2. 如果&lt;src&gt;是本地tar文件，则被展开为一个目录，如果是一个URL的tar文件，则不会自动展开。
3. 如果&lt;src&gt;有多个，则dist需要以/结尾，否则将会把src的内容直接写进&lt;dist&gt;。
例如：
ADD http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.37/bin/apache-tomcat-8.5.37.tar.gz /usr/local/src/
ADD apache-tomcat-8.5.37.tar.gz /usr/local/src/
</code></pre>

<h4 id="toc_24">WORKDIR命令</h4>

<p>指定Docker镜像中的工作路径，可以定义多次，命令执行的时候以最新定义的一次为准。<br/>
例如:<code>WORKDIR /usr/local/</code></p>

<h4 id="toc_25">VOLUME命令</h4>

<p>Dockerfile中的卷只能设置容器中的挂载点目录，只能设置docker管理的卷。<br/>
例如:<code>VOLUME /data/mysql</code></p>

<h4 id="toc_26">EXPOSE命令</h4>

<p>为容器打开指定要监听的端口来和外部通信。</p>

<pre class="line-numbers"><code class="language-text">EXPOSE &lt;port&gt;[/&lt;protocol&gt;][&lt;port&gt;[&lt;/protocol&gt;]]
protocol:传输协议，tcp/udp, 默认tcp.
可以一次指定多个端口,例如:
`EXPOSE 32332/udp 32332/tcp`

这里的端口并不会直接暴露给宿主机，而是以启动docker容器时候的参数来决定。
docker run -p/-P
</code></pre>

<h4 id="toc_27">ENV命令</h4>

<p>定义Dockerfile的环境变量，可以被在Dockfile ENV命令后面的其他命令引用。</p>

<pre class="line-numbers"><code class="language-text"> ENV &lt;key&gt; &lt;value&gt;
  ENV &lt;key&gt;=&lt;value&gt; ...
  说明:
  1.第一种格式key后面的所有内容都被认为是value，只可以定义一个
  2.第二种格式可以定义多个&lt;key&gt;=&lt;value&gt;, 如果value中有空格，需要加&quot;\&quot;进行转义，也可以对value加双引号。另外反斜杠可以用来表示续行。
  建议使用第二种。
  3.Dockerfile中定义的ENV可以在启动容器以后直接使用，在运行为容器的时候通过-e参数可以重新给变量赋值。要分清什么参数是在build阶段的，什么是在容器启动阶段。
</code></pre>

<h4 id="toc_28">RUN命令</h4>

<p>RUN命令时基于基础镜像所提供的命令来运行，发生在创建镜像的过程中。目的是为了创建镜像。<br/>
RUN 命令如果执行了yum，需要在安装完成后删除缓存以减小镜像大小。</p>

<pre class="line-numbers"><code class="language-text">RUN &lt;command&gt;
RUN [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]

说明:
第一种默认启动为/bin/sh 子进程。
第二种执行方式是由linux直接来执行，没有/bin/sh,所以不支持shell的语法，如果需要可以使用:
RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;]来执行。
例如:
RUN cd /usr/local/src/ &amp;&amp; \
    tar -xf  ${WEB_SERVER_VERSION}
</code></pre>

<h4 id="toc_29">CMD命令</h4>

<p>CMD命令发生在容器启动时,当一个镜像文件被创建为容器的时候执行,一个容器默认只启动一个进程，所以一个Dockerfile中只可以有一个CMD,如果有多个，则最后一个生效用来指定容器启动时默认执行的程。</p>

<pre class="line-numbers"><code class="language-text">CMD &lt;command&gt;
CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
说明:
在执行docker run命令的时候，可以指定新的命来来覆盖CMD的内容。如果docker在启动的时候不希望接受命令行输入的命令，可以使用ENTRYPOINT.
</code></pre>

<h4 id="toc_30">ENTRYPOINT命令</h4>

<p>和CMD功能类似，但是不接受在docker run的时候修改启动命令，docker run的参数只能以变量的形式传给ENTRYPOINT定义的启动程序。</p>

<p>如果需要改变，需要在docker run的时候指定 --entrypoints参数。</p>

<p>ENTRYPOINT用来支持多环境</p>

<h4 id="toc_31">USER命令</h4>

<p>用于指定运行image或运行Dockerfile中的RUN CMD ENTRYPOINT指令指定的程序时的用户名或者UID。</p>

<pre class="line-numbers"><code class="language-text">USER &lt;UID&gt;|&lt;UserName&gt;
CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;parm2&gt;&quot;]
</code></pre>

<h4 id="toc_32">HEALTHCHECK命令</h4>

<p>容器健康检测</p>

<pre class="line-numbers"><code class="language-text">HEALTHCHECK [OPTIONS] CMD command
OPTIONS：
  --interval=DURATION(间隔多久检测)
  --timeout=DURATION(检测超时)
  --start-period=DURATION(等待多久开始检测，default=0)
  --retries=N(default=3)
  returns:
  0:success
  1:unhealthy
  2:reserved
  例如:
  HEALTHCHECK --interval=5m --timeout=30s CMD curl -f http://localhost/ || exit 1
</code></pre>

<h4 id="toc_33">SHELL命令</h4>

<p>镜像默认的shell</p>

<pre class="line-numbers"><code class="language-text">SHELL [&quot;executable&quot;,&quot;parameters&quot;]
</code></pre>

<h4 id="toc_34">STOPSIGNAL命令</h4>

<p>进程为1的命令可以接受docker stop命令,主进程停止，容器就停止。</p>

<h4 id="toc_35">ARG命令</h4>

<p>在build的过程中起作用，使一个dockerfile可以适用多个环境，用法和ENV类似，但是起作用的时间不一样。该变量可以通过 build --arg参数修改。</p>

<h4 id="toc_36">ONBUILD命令</h4>

<p>在Dockerfile中定义一个并发器，当别的镜像是基于有ONBUILD的镜像构建新的镜像的时候，会触发ONBOUILD指令</p>

<pre class="line-numbers"><code class="language-text">ONBUILD&lt;INSTRUCTION&gt;
</code></pre>

<h4 id="toc_37">docker buld</h4>

<p>创建docker镜像</p>

<pre class="line-numbers"><code class="language-text">docker build [OPTIONS] PATH | URL | -
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android GRPC接入]]></title>
    <link href="http://adolph.cc/15662718181666.html"/>
    <updated>2019-08-20T11:30:18+08:00</updated>
    <id>http://adolph.cc/15662718181666.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">安装Protobuf插件</h2>

<p>Protobuf Support插件可以支持Protobuf文件高亮语法显示</p>

<p><figure><img src="media/15662718181666/15662727464652.png" alt="" style="width:582px;"/></figure></p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">添加Grpc依赖</h2>

<ul>
<li>项目根目录build.gradle添加</li>
</ul>

<pre class="line-numbers"><code class="language-groovy">buildscript {
    ext.kotlin_version = &#39;1.3.41&#39;
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:3.4.2&#39;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
        //添加这句
        classpath &quot;com.google.protobuf:protobuf-gradle-plugin:0.8.10&quot;
    }
}
</code></pre>

<ul>
<li>在Module下build.gradle添加<code>apply plugin: &#39;com.google.protobuf&#39;</code></li>
<li>设置proto文件位置(src/main/proto):</li>
</ul>

<pre class="line-numbers"><code class="language-groovy">android {
    sourceSets {
        main {
            proto {
                srcDir &#39;src/main/proto&#39;
            }
            java {
                srcDir &#39;src/main/java&#39;
            }
        }
    }
}
</code></pre>

<ul>
<li>自定义Protobuf编译项</li>
</ul>

<pre class="line-numbers"><code class="language-groovy">protobuf {
    protoc { artifact = &#39;com.google.protobuf:protoc:3.9.1&#39; }
    plugins {
        javalite { artifact = &quot;com.google.protobuf:protoc-gen-javalite:3.0.0&quot; }
        grpc { artifact = &#39;io.grpc:protoc-gen-grpc-java:1.22.1&#39; }
    }
    generateProtoTasks {
        all().each { task -&gt;
            task.plugins {
                javalite {}
                grpc { option &#39;lite&#39; }
            }
        }
    }
    generatedFilesBaseDir = &quot;$projectDir/src/generated&quot;
}

clean {
    delete &quot;${projectDir}/src/main/generated-proto&quot;
}
</code></pre>

<ul>
<li>加入grpc依赖</li>
</ul>

<pre class="line-numbers"><code class="language-groovy">implementation &#39;io.grpc:grpc-okhttp:1.22.1&#39;
implementation &#39;io.grpc:grpc-protobuf-lite:1.22.1&#39;
implementation &#39;io.grpc:grpc-stub:1.22.1&#39;
implementation &#39;javax.annotation:javax.annotation-api:1.3.2&#39;
</code></pre>

<ul>
<li>Rebuild Project之后就会自动生成代码</li>
</ul>

<h2 id="toc_2">Protobuf语法</h2>

<h3 id="toc_3">关键字</h3>

<ul>
<li>syntax：声明版本。例如上面syntax=&quot;proto3&quot;，如果没有声明，则默认是proto2。</li>
<li>package：声明包名.</li>
<li>import：导入包。类似于java，例如上面导入了timestamp.proto包。</li>
<li>java_package：指定生成的类应该放在什么Java包名下。如果你没有显式地指定这个值，则它简单地匹配由package 声明给出的Java包名，但这些名字通常都不是合适的Java包名 (由于它们通常不以一个域名打头)。</li>
<li>java_outer_classname：定义应该包含这个文件中所有类的类名。如果你没有显式地给定java_outer_classname ，则将通过把文件名转换为首字母大写来生成。例如上面例子编译生成的文件名和类名是AddressBookProtos。</li>
<li>message：类似于java中的class关键字。</li>
<li>repeated：用于修饰属性，表示对应的属性是个array。</li>
</ul>

<h3 id="toc_4">Android中使用</h3>

<p>创建Proto文件</p>

<pre class="line-numbers"><code class="language-protobuf">syntax = &quot;proto3&quot;;

option java_multiple_files = true;
option java_package = &quot;com.ifantastic.helloworld&quot;;
option java_outer_classname = &quot;HelloWorldProto&quot;;

package helloworld;

message HelloRequest {
    string name = 1;
}

message HelloReply {
    string message = 1;
}

service Greeter {
    rpc SayHello(HelloRequest) returns (HelloReply);
}
</code></pre>

<p>Rebuild之后开始调用</p>

<ul>
<li><p>创建连接通道</p>
<pre class="line-numbers"><code class="language-kotlin">val connectionChannel: ManagedChannel by lazy {
    OkHttpChannelBuilder.forAddress(&quot;192.168.6.104&quot;, 9090)<br/>
        .usePlaintext()<br/>
        .build()<br/>
}
</code></pre></li>
<li><p>声明Service</p>
<pre class="line-numbers"><code class="language-kotlin">val service = GreeterGrpc.newBlockingStub(connectionChannel)
</code></pre></li>
<li><p>Grpc请求</p>
<pre class="line-numbers"><code class="language-kotlin">val requestMessage = HelloRequest.newBuilder()
        .setName(name)<br/>
        .build()      <br/>
val response = service.sayHello(requestMessage)
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker搭建Maven私服]]></title>
    <link href="http://adolph.cc/15662693410122.html"/>
    <updated>2019-08-20T10:49:01+08:00</updated>
    <id>http://adolph.cc/15662693410122.html</id>
    <content type="html"><![CDATA[
<p>由于Gradle和Maven依赖方式不一样，没法进行本地项目依赖，所以需要把Gradle项目打包发布到Maven仓库。发布到公共仓库又不太好，所以决定搭建个私有仓库，刚好家里有群辉Synology DS918+，可以通过Docker来搭建Maven私服。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_0">安装Nexus</h2>

<p>群辉上的Docker通过图形化的界面进行操控，所以不需要进行命令行操作。</p>

<ul>
<li><p>在注册表中搜索Nexus，对sonatype/nexus3项目进行双击下载映像。<br/>
<figure><img src="media/15662693410122/66FBF341-A2A8-43AC-8920-82E09879443C.png" alt=""/></figure></p></li>
<li><p>在映像中双击sonatype/nexus3创建容器，编辑nexus设置，启用自动重新启动和创建桌面快捷方式<figure><img src="media/15662693410122/07013229-CA0A-45AB-9035-DF3A95145BE2.png" alt=""/></figure></p></li>
<li><p>在卷中添加映射文件夹 本地文件路径 / 装载路径(/var/nexus-data)<br/>
<figure><img src="media/15662693410122/3E47DC7A-E1E8-4E8B-8325-5E482631797E.png" alt=""/></figure></p></li>
<li><p>进行端口映射,将本地端口映射到容器端口.<figure><img src="media/15662693410122/96660F1B-0E55-4DEB-AF78-BC29526F79E8.png" alt=""/></figure></p></li>
<li><p>启动Nexus，点击桌面的Nexus快捷启动或者通过<code>http://ip:8081</code>，打开Nexus网址。<br/>
<figure><img src="media/15662693410122/15662707547156.png" alt=""/></figure></p></li>
<li><p>点击右上方的Sign in进行登录，初始账号为admin，初始密码通过容器的详情里终端查看admin.password里的密码.登录后修改密码<br/>
<figure><img src="media/15662693410122/15662707441848.jpg" alt=""/></figure></p></li>
<li><p>可以看到默认情况下<code>Nexus</code>会帮我们创建了几个仓库，仔细观察红色框住的地方，里面有几种仓库的类型，解释如下：</p>
<ul>
<li><code>proxy</code>远程仓库的代理，比如说<code>nexus</code>配置了一个<code>central repository</code>的<code>proxy</code>,当用户向这个proxy请求一个<code>artifact</code>的时候，会现在本地查找，如果找不到，则会从远程仓库下载，然后返回给用户。</li>
<li><code>hosted</code>宿主仓库，用户可以把自己的一些仓库<code>deploy</code>到这个仓库中</li>
<li><code>group</code>仓库组，是<code>nexus</code>特有的概念，目的是将多个仓库整合，对用户暴露统一的地址，这样就不需要配置多个仓库地址。</li>
</ul></li>
<li><p>下面我们仔细看一下里面的一些仓库。点击<code>maven-central</code>仓库: <br/>
<figure><img src="media/15662693410122/15662710138140.jpg" alt=""/></figure><br/>
可以看到是一个<code>proxy</code>类型的仓库，他代理的远程仓库地址是<code>https://repo1.maven.org/maven2/</code>。</p></li>
<li><p>后退，在进入<code>maven-public</code>查看: <br/>
<figure><img src="media/15662693410122/15662710448726.png" alt=""/></figure><br/>
可以看到这是一个<code>group</code>类型的仓库，里面包含了<code>maven-releases/maven-snapshots/maven-central</code>仓库，意思是我们只需要在本地添加这个仓库，则可以依赖到上述3个仓库中的库了。</p></li>
</ul>

<h2 id="toc_1">创建仓库</h2>

<ul>
<li><p><strong>创建仓库</strong><br/>
点击<code>Create repository</code>,然后选择<code>maven2(hosted)</code>然后输入仓库名称<code>（test-release）</code>。在<code>version policy</code>中选择这个仓库的类型，这里选择<code>release</code>,在<code>Deployment policy</code>中选择<code>Allow redeploy</code><br/>
<figure><img src="media/15662693410122/15662711396304.png" alt=""/></figure></p></li>
<li><p><strong>创建用户</strong><br/>
点击左侧菜单栏的Users菜单，然后点击Create local user.我这里创建了一个用户，账号密码都是：wangjianfeng <br/>
<figure><img src="media/15662693410122/15662712072619.jpg" alt=""/></figure></p></li>
</ul>

<h2 id="toc_2">Java Gradle项目上传</h2>

<p>在build.gradle中添加<code>maven-publish</code>插件</p>

<pre class="line-numbers"><code class="language-groovy">plugins {
    id &quot;maven-publish&quot;
}
</code></pre>

<p>设置插件参数</p>

<pre class="line-numbers"><code class="language-groovy">//打包源码
task sourceJar(type: Jar) {
    from sourceSets.main.allSource
}

publishing {
    publications {
        maven(MavenPublication) {
            //指定group/artifact/version信息，可以不填。默认使用项目group/name/version作为groupId/artifactId/version
            groupId project.group
            artifactId project.name
            version project.version
            //如果是war包填写components.web，如果是jar包填写components.java
            from components.java

            //配置上传源码
            artifact sourceJar {
                classifier &quot;sources&quot;
            }

        }
    }
    repositories {
        maven {
            //指定要上传的maven私服仓库
            url = &quot;http://你的maven私服地址/repository/maxrocky/&quot;
            //认证用户和密码
            credentials {
                username &#39;admin&#39;
                password &#39;admin123&#39;
            }
        }
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin为序列化类生成serialVersionUID]]></title>
    <link href="http://adolph.cc/15639522586909.html"/>
    <updated>2019-07-24T15:10:58+08:00</updated>
    <id>http://adolph.cc/15639522586909.html</id>
    <content type="html"><![CDATA[
<p>一般在Intellij Idea使用过程中，为Java序列化类自动生成serialVersionUID可以通过Inspections配置来完成</p>

<span id="more"></span><!-- more -->

<p><figure><img src="media/15639522586909/15639527631359.jpg" alt=""/></figure></p>

<pre class="line-numbers"><code class="language-text">Preferences -&gt; Inspections -&gt; Serialization issues -&gt; Serialization class without &#39;serialVersionUID&#39;
</code></pre>

<p>将光标放到类名上，按<code>atl＋enter</code>键，就会提示生成serialVersionUID了</p>

<p><figure><img src="media/15639522586909/15639527944558.jpg" alt=""/></figure></p>

<p>或者使用插件<strong>GenerateSerialVersionUID</strong>就能通过快捷键快速生成serialVersionUID</p>

<p>然而在Kotlin环境下，以上配置无效</p>

<p><strong>解决方案如下：</strong><br/>
利用serialver命令生成serialVersionUID</p>

<ul>
<li>Preferences -&gt; Tools -&gt; External Tools</li>
<li>添加新的tools</li>
<li>Name就设置为serialver</li>
<li>Program中选择serialver命令所在的路径，macOS下一般为<code>/usr/bin/serialver</code></li>
<li>Arguments设置为 <code>-classpath$OutputPath$:$Classpath$ $FileFQPackage$.$FileNameWithoutAllExtensions$</code></li>
<li>点击保存以上配置</li>
</ul>

<p>Ok,现在就可以生成serialVersionUID了。首先编译一下，让要生成serialVersionUID的类生成对应的class文件，然后在类的编辑窗口中右键选择external tools &gt; serialver，这时console窗口出就生成了这个类的serialVersionUID了。</p>

<blockquote>
<p>另：kotlin中没有Java的static关键字，所以serialVersionUID属性是以伴生对象属性存在的</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xposed开发]]></title>
    <link href="http://adolph.cc/15620327900428.html"/>
    <updated>2019-07-02T09:59:50+08:00</updated>
    <id>http://adolph.cc/15620327900428.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Xposed SDK下载</h2>

<p><a href="http://dl-xda.xposed.info/framework/sdk21/x86/">地址</a></p>

<h2 id="toc_1">Xposed API</h2>

<p><a href="https://api.xposed.info/reference/de/robv/android/xposed/XposedHelpers.html">地址</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Genymotion-ARM-Translation.zip各安卓版本合集]]></title>
    <link href="http://adolph.cc/15620314685082.html"/>
    <updated>2019-07-02T09:37:48+08:00</updated>
    <id>http://adolph.cc/15620314685082.html</id>
    <content type="html"><![CDATA[
<table>
<thead>
<tr>
<th style="text-align: left">安卓版本</th>
<th style="text-align: left">代号</th>
<th style="text-align: left">Genymotion-ARM-Translation</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">8.0 – 8.1</td>
<td style="text-align: left">Oreo奥利奥</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Oreo8.0-8.1/ARM_Translation_Oreo.zip">ARM_Translation_Oreo.zip</a></td>
</tr>
<tr>
<td style="text-align: left">7.0 – 7.1.2</td>
<td style="text-align: left">Nougat牛轧糖</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">6.0 – 6.0.1</td>
<td style="text-align: left">Marshmallow棉花糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Marshmallow6.0-6.0.1/ARM_Translation_Marshmallow.zip">ARM_Translation_Marshmallow.zip</a></td>
</tr>
<tr>
<td style="text-align: left">5.0 – 5.1.1</td>
<td style="text-align: left">Lollipop棒棒糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Lollipop5.0-5.1.1/ARM_Translation_Lollipop_20160402.zip">ARM_Translation_Lollipop_20160402.zip</a></td>
</tr>
<tr>
<td style="text-align: left">5.0 – 5.1.1</td>
<td style="text-align: left">Lollipop棒棒糖</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/Lollipop5.0-5.1.1/ARM_Translation_Lollipop.zip">ARM_Translation_Lollipop.zip</a></td>
</tr>
<tr>
<td style="text-align: left">4.4 – 4.4.4</td>
<td style="text-align: left">KitKat奇巧巧克力</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/KitKat4.4-4.4.4/ARM-4.4-libhoudini.zip">ARM-4.4-libhoudini.zip</a></td>
</tr>
<tr>
<td style="text-align: left">4.1 – 4.3.1</td>
<td style="text-align: left">Jelly Bean果冻豆</td>
<td style="text-align: left"><a href="https://github.com/adolphJane/GenymotionARMTranslations/blob/master/JellyBean4.1-4.3.1/Genymotion-ARM-Translation_v1.1.zip">Genymotion-ARM-Translation_v1.1.zip</a></td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactNative打包与发布]]></title>
    <link href="http://adolph.cc/15615956474579.html"/>
    <updated>2019-06-27T08:34:07+08:00</updated>
    <id>http://adolph.cc/15615956474579.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">iOS</h2>

<h3 id="toc_1">生成bundle文件</h3>

<pre class="line-numbers"><code class="language-text">react-native bundle --entry-file index.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CodePush集成与热更新]]></title>
    <link href="http://adolph.cc/15615956237705.html"/>
    <updated>2019-06-27T08:33:43+08:00</updated>
    <id>http://adolph.cc/15615956237705.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">前言</h2>

<p>CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。<br/>
CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。CodePush 可以让应用有更多的可确定性，也可以让你直接接触用户群。在修复一些小问题和添加新特性的时候，不需要经过二进制打包，可以直接推送代码进行实时更新。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">安装与使用</h2>

<p>使用CodePush之前首先要安装CodePush客户端。</p>

<h3 id="toc_2">安装 CodePush CLI</h3>

<ul>
<li>安装客户端<code>npm install -g code-push-cli</code></li>
<li>查看版本号<code>code-push -v</code></li>
<li>注册CodePush账号<code>code-push register</code>授权通过之后，CodePush会告诉你“access key”，复制此key到终端即可完成注册。</li>
<li>登录<code>code-push login</code>登陆成功后，你的session文件将会写在 /Users/你的用户名/.code-push.config。</li>
</ul>

<p>PS.相关命令</p>

<ul>
<li><code>code-push login</code> 登陆</li>
<li><code>code-push logout</code> 注销</li>
<li><code>code-push access-key ls</code> 列出登陆的token</li>
<li><code>code-push access-key rm &lt;accessKye&gt;</code> 删除某个 access-key</li>
</ul>

<h3 id="toc_3">在CodePush服务器注册app</h3>

<p>为了让CodePush服务器知道你的app，我们需要向它注册app</p>

<ul>
<li>添加应用平台<code>code-push app add &lt;app_name&gt; &lt;os&gt; &lt;platform&gt;</code></li>
<li>添加部署环境<code>code-push deployment add &lt;app_name&gt; test</code></li>
</ul>

<p>PS.相关命令</p>

<ul>
<li><code>code-push app add</code> 在账号里面添加一个新的app</li>
<li><code>code-push app remove</code> 或者 <code>rm</code> 在账号里移除一个app</li>
<li><code>code-push app rename</code> 重命名一个存在app</li>
<li><code>code-push app list</code> 或者 <code>ls</code> 列出账号下面的所有app</li>
<li><code>code-push app transfer</code> 把app的所有权转移到另外一个账号</li>
<li><code>code-push deployment list &lt;app_name&gt; --format json</code> 查看APP的环境信息</li>
<li><code>code-push deployment clear &lt;app-name&gt;</code> 部署环境</li>
</ul>

<h4 id="toc_4">发布CodePush更新包</h4>

<p><code>code-push release-react &lt;Appname&gt; &lt;Platform&gt; --t &lt;本更新包面向的旧版本号&gt; --des &lt;本次更新说明&gt;</code></p>

<blockquote>
<p>注意： CodePush默认是更新Staging 环境的，如果发布生产环境的更新包，需要指定--d参数：--d Production，如果发布的是强制更新包，需要加上 --m true强制更新</p>
</blockquote>

<p><code>$ code-push release-react iOSRNHybrid ios --t 1.0.0 --dev false --d Production --des &quot;这是第一个更新包&quot; --m true<br/>
</code></p>

<ul>
<li>发布更新包命令中的 -- t 对应的参数是和我们项目中的版本号一致的，这个不要误理解为是更新包的版本号，例如项目中的版本号为1.0.0， 这时如果我们需要对这个1.0.0 版本的项目进行第一次热更新，那么命令中的 -- t 也为1.0.0，第二次热更新任然为1.0.0, --dev为是否启用开发者模式(默认为false), --d是要发布更新的环境分Production与Staging(默认为Staging)；--des为更新说明；--m 是强制更新。</li>
<li>项目的版本号需要改为三位的，默认是两位的，但是CodePush需要三位数的版本号</li>
<li>发布更新应用时，应用的名称必须要和之前注册过的应用名称一致</li>
</ul>

<h5 id="toc_5">查询Production</h5>

<p><code>code-push deployment history projectName Production</code></p>

<h5 id="toc_6">查询Staging</h5>

<p><code>code-push deployment history projectName Staging</code></p>

<h3 id="toc_7">ReactNative集成code-push</h3>

<h4 id="toc_8">安装组件</h4>

<p>项目根目录下 <code>yarn add react-native-code-push</code></p>

<h4 id="toc_9">添加依赖</h4>

<p><code>react-native react-native-code-push</code></p>

<h4 id="toc_10">RN端代码</h4>

<pre class="line-numbers"><code class="language-text">import CodePush from &quot;react-native-code-push&quot;;
let codePushOptions = { checkFrequency: CodePush.CheckFrequency.ON_APP_RESUME };
const deploymentKey = Platform.select({
    ios: &#39;XgBtruRnRtJKOjkwEZub2Q60mFys4ksvOXqog&#39;,
    android: &#39;fmrp3d8KiGKSyp23cXe26a9xEkHF4ksvOXqog&#39;,
});

class App extends Component&lt;Props&gt; {

    componentWillMount() {
        CodePush.disallowRestart();//禁止重启
        this.syncImmediate(); //开始检查更新
    }

    componentDidMount() {
        CodePush.allowRestart();//在加载完了，允许重启
    }

    //如果有更新的提示
    syncImmediate() {
        CodePush.sync( {
                //安装模式
                //ON_NEXT_RESUME 下次恢复到前台时
                //ON_NEXT_RESTART 下一次重启时
                //IMMEDIATE 马上更新
                installMode : CodePush.InstallMode.ON_NEXT_RESUME ,
                //对话框
                updateDialog : {
                    //是否显示更新描述
                    appendReleaseDescription : true ,
                    //更新描述的前缀。 默认为&quot;Description&quot;
                    descriptionPrefix : &quot;更新内容：&quot; ,
                    //强制更新按钮文字，默认为continue
                    mandatoryContinueButtonLabel : &quot;立即更新&quot; ,
                    //强制更新时的信息. 默认为&quot;An update is available that must be installed.&quot;
                    mandatoryUpdateMessage : &quot;必须更新后才能使用&quot; ,
                    //非强制更新时，按钮文字,默认为&quot;ignore&quot;
                    optionalIgnoreButtonLabel : &#39;稍后&#39; ,
                    //非强制更新时，确认按钮文字. 默认为&quot;Install&quot;
                    optionalInstallButtonLabel : &#39;后台更新&#39; ,
                    //非强制更新时，检查到更新的消息文本
                    optionalUpdateMessage : &#39;有新版本了，是否更新？&#39; ,
                    //Alert窗口的标题
                    title : &#39;更新提示&#39;
                } ,
                deploymentKey: deploymentKey,
            } ,
        );
    }
}

App = CodePush(codePushOptions)(App);

export default App;
</code></pre>

<h5 id="toc_11">更新是否要求即时</h5>

<p>在更新配置中通过指定installMode来决定安装完成的重启时机，亦即更新生效时机</p>

<ul>
<li><code>codePush.InstallMode.IMMEDIATE</code> ：安装完成立即重启更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESTART</code> ：安装完成后会在下次重启后进行更新</li>
<li><code>codePush.InstallMode.ON_NEXT_RESUME</code> ：安装完成后会在应用进入后台后重启更新</li>
</ul>

<h4 id="toc_12">原生端配置</h4>

<p>通过之前的ReactNative添加依赖配置<code>react-native react-native-code-push</code>,原生代码会自动生成。<br/><br/>
无需手动配置。</p>

<h2 id="toc_13">私有化配置</h2>

<h3 id="toc_14">服务端</h3>

<p>参照文档进行配置<br/>
<a href="https://github.com/lisong/code-push-server">code-push-server</a></p>

<h3 id="toc_15">客户端</h3>

<ul>
<li>登录私有化服务器访问地址，端口号3000,输入账号密码(默认为admin,123456),获取token，登陆之后输入</li>
<li><code>code-push login http://api.code-push.com</code> login后面跟上服务端访问地址</li>
<li>Android配置(<code>MyApplication</code>类中<code>getPackages</code>方法中<code>CodePush</code>实例化的时候前面不变，自动从RN端获取deploymentKey,加上第四个参数，私有化服务器的访问地址)</li>
<li>iOS配置(info.plist文件中有<code>CodePushDeploymentKey</code>是<code>deploymentKey</code>，再添加一个参数<code>CodePushServerURL</code>，填上私有化服务器的访问地址)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android 开发小记]]></title>
    <link href="http://adolph.cc/15597152983017.html"/>
    <updated>2019-06-05T14:14:58+08:00</updated>
    <id>http://adolph.cc/15597152983017.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">应用签名查看</h2>

<h3 id="toc_1">查询keystore的MD5</h3>

<pre class="line-numbers"><code class="language-text">keytool -list -v -keystore ***.jks
</code></pre>

<p><figure><img src="media/15597152983017/15597154233468.jpg" alt="" style="width:570px;"/></figure><br/>
MD5值就是所要的应用签名，只是比下面提到的签名生成工具生成的多出了中间的冒号</p>

<h3 id="toc_2">通过APK工具进行查看</h3>

<p><a href="media/15597152983017/GenSignature.apk">GenSignature</a><br/>
在该手机上安装正式打包的APK并运行，通过签名生成工具输入包名get signature获取应用签名，copy to clipboard即可。<br/>
<figure><img src="media/15597152983017/15597160146245.jpg" alt=""/></figure></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveNative开发历程]]></title>
    <link href="http://adolph.cc/15590521983066.html"/>
    <updated>2019-05-28T22:03:18+08:00</updated>
    <id>http://adolph.cc/15590521983066.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">搭建环境</h2>

<h3 id="toc_1">安装环境必备软件</h3>

<p>官方推荐使用Homebrew来安装node和Watchman</p>

<pre class="line-numbers"><code class="language-text">brew install node
brew install watchman
</code></pre>

<p>设置npm镜像来加速后面的过程</p>

<pre class="line-numbers"><code class="language-text">npm config set registry https://registry.npm.taobao.org --global
npm config set disturl https://npm.taobao.org/dist --global
</code></pre>

<p>Watchman则是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager 可以快速捕捉文件的变化从而实现实时刷新）。<br/>
Yarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载。React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。</p>

<pre class="line-numbers"><code class="language-text">npm install -g yarn react-native-cli
</code></pre>

<p>安装完 yarn 后同理也要设置镜像源：</p>

<pre class="line-numbers"><code class="language-text">yarn config set registry https://registry.npm.taobao.org --global
yarn config set disturl https://npm.taobao.org/dist --global
</code></pre>

<p>安装完 yarn 之后就可以用 yarn 代替 npm 了，例如用yarn代替npm install命令，用yarn add 某第三方库名代替npm install 某第三方库名。</p>

<h3 id="toc_2">创建新项目</h3>

<p>使用 React Native 命令行工具来创建一个为&quot;AwesomeProject&quot;的新项目：</p>

<pre class="line-numbers"><code class="language-text">react-native init AwesomeProject
</code></pre>

<h3 id="toc_3">运行项目</h3>

<pre class="line-numbers"><code class="language-text">cd AwesomeProject
react-native run-android
</code></pre>

<h2 id="toc_4">开发NovelProject</h2>

<h3 id="toc_5">使用第三方库</h3>

<h4 id="toc_6">React-navigation</h4>

<h5 id="toc_7">导入依赖库</h5>

<p>在项目Terminal中输入命令行：</p>

<pre class="line-numbers"><code class="language-text">yarn add react-navigation
</code></pre>

<p>然后在package.json文件中就可以看到，依赖库已经导入完毕：</p>

<pre class="line-numbers"><code class="language-text">&quot;react-native-tab-navigator&quot;: &quot;^0.3.4&quot;,
</code></pre>

<p><strong>注意</strong>适配IOS要导入<code>react-native-gesture-handler</code>库，并进行关联</p>

<pre class="line-numbers"><code class="language-text">yarn add react-native-gesture-handler
react-native link
</code></pre>

<h5 id="toc_8">配置Navigator</h5>

<p>在项目的入口中直接配置StackNavigator，StackNavigator中注册所有需要跳转的界面，在这个项目中还有注册登录功能，在效果图中没有展示，这里不作探讨。首先是入口文件：</p>

<pre class="line-numbers"><code class="language-text">import React from &#39;react&#39;;
import {StackNavigator} from &#39;react-navigation&#39;;
import {TabNav} from &quot;./RootPage&quot;;
import LoginPage from &quot;./page/Login/loginPage&quot;;
import RegPage from &quot;./page/Login/regPage&quot;;
import {FindAccountPage} from &quot;./page/Login/findAccountPage&quot;; // 路由导航

const App = StackNavigator({
        Login: {screen: LoginPage}, // 登录页
        Reg: {screen: RegPage}, // 注册页
        FindAccount: {screen: FindAccountPage}, // 找回密码页
        Main: {
            screen: TabNav,
            navigationOptions: ({navigation}) =&gt; ({
                header: null
            })
        }
    },
    {
        initialRouteName: &#39;Login&#39;,
        headerMode: &#39;screen&#39;
    });

export default App;
</code></pre>

<p>上面可以注意到TabNav，也就是TabNavigator，是作为一个screen参数的值传入到StackNavigator中，在上面提到的navigationOptions的配置中，我们将header设置为null，也就是不要标题栏。</p>

<p>接着进入到配置TabNavigator的RootPage中：</p>

<pre class="line-numbers"><code class="language-text">import React from &#39;react&#39;;
import {TabNavigator} from &#39;react-navigation&#39;;

import HomePage from &#39;./page/Home/HomePage&#39;;
import FriendPage from &#39;./page/Friend/FriendPage&#39;;
import TaskPage from &#39;./page/Task/TaskPage&#39;;
import MinePage from &#39;./page/Mine/MinePage&#39;;
import DealPage from &#39;./page/Deal/DealPage&#39;;

export const TabNav = TabNavigator(
    {
        Home: {
            screen: HomePage,
        },
        Task: {
            screen: TaskPage,
        },
        Friend: {
            screen: FriendPage,
        },
        Deal: {
            screen: DealPage,
        },
        Mine: {
            screen: MinePage,
        }
    },
    {
        tabBarOptions: {
            //当前选中的tab bar的文本颜色和图标颜色
            activeTintColor: &#39;#4BC1D2&#39;,
            //当前未选中的tab bar的文本颜色和图标颜色
            inactiveTintColor: &#39;#000&#39;,
            //是否显示tab bar的图标，默认是false
            showIcon: true,
            //showLabel - 是否显示tab bar的文本，默认是true
            showLabel: true,
            //是否将文本转换为大小，默认是true
            upperCaseLabel: false,
            //material design中的波纹颜色(仅支持Android &gt;= 5.0)
            pressColor: &#39;#788493&#39;,
            //按下tab bar时的不透明度(仅支持iOS和Android &lt; 5.0).
            pressOpacity: 0.8,
            //tab bar的样式
            style: {
                backgroundColor: &#39;#fff&#39;,
                paddingBottom: 1,
                borderTopWidth: 0.2,
                paddingTop:1,
                borderTopColor: &#39;#ccc&#39;,
            },
            //tab bar的文本样式
            labelStyle: {
                fontSize: 11,
                margin: 1
            },
            //tab 页指示符的样式 (tab页下面的一条线).
            indicatorStyle: {height: 0},
        },
        //tab bar的位置, 可选值： &#39;top&#39; or &#39;bottom&#39;
        tabBarPosition: &#39;bottom&#39;,
        //是否允许滑动切换tab页
        swipeEnabled: true,
        //是否在切换tab页时使用动画
        animationEnabled: false,
        //是否懒加载
        lazy: true,
        //返回按钮是否会导致tab切换到初始tab页？ 如果是，则设置为initialRoute，否则为none。 缺省为initialRoute。
        backBehavior: &#39;none&#39;,
    });
</code></pre>

<p>在这里我们可以看到，我们将底部导航的属性基本都用上了，这是为了方便大家在使用时作适合自己的选择，毕竟需求不一样，不过这个效果是可以接受的了~</p>

<p>在这个界面中导入了其他五个子界面，每个子界面效果可以设置成差不多，例如下面这样：</p>

<pre class="line-numbers"><code class="language-text">import React, {Component} from &#39;react&#39;;
import {
    View,
    Text,
    Image,
    StyleSheet,
} from &#39;react-native&#39;;

export default class FriendPage extends Component {
    static navigationOptions = {
        tabBarLabel: &#39;好友&#39;,
        tabBarIcon: ({focused}) =&gt; {
            if (focused) {
                return (
                    &lt;Image style={styles.tabBarIcon} source={require(&#39;../../img/fri_sel.png&#39;)}/&gt;
                );
            }
            return (
                &lt;Image style={styles.tabBarIcon} source={require(&#39;../../img/fri_nor.png&#39;)}/&gt;
            );
        },
    };

    render() {
        return (
            &lt;View style={styles.container}&gt;
                &lt;Text&gt;这是好友&lt;/Text&gt;
            &lt;/View&gt;
        );
    }
}
const styles = StyleSheet.create({
    container: {
        flex: 1,
        flexDirection: &#39;column&#39;,
        justifyContent: &#39;center&#39;,
        alignItems: &#39;center&#39;,
    },
    tabBarIcon: {
        width: 21,
        height: 21,
    }
});
</code></pre>

<p>在子界面中可以设置icon图标样式，表示在点击前后颜色的改变，效果如下：<br/>
<figure><img src="media/15590521983066/15590527801185.jpg" alt=""/></figure><br/>
<figure><img src="media/15590521983066/15590527846918.jpg" alt=""/></figure></p>

<p>当然，我们也可以设置标题栏，只需要在下面代码中添加headerTitle属性：</p>

<pre class="line-numbers"><code class="language-text">export default class FriendPage extends Component {
    static navigationOptions = {
        tabBarLabel: &#39;好友&#39;,
        headerTitle: &#39;好友&#39;,
        tabBarIcon: ({focused}) =&gt; { ...
</code></pre>

<p>别忘了，在StackNavigator配置TabNavigator时不要设置header为null即可。</p>

<pre class="line-numbers"><code class="language-text">Main: {
            screen: TabNav,
            navigationOptions: ({navigation}) =&gt; ({
             // header: null
            })
        }
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[策略模式]]></title>
    <link href="http://adolph.cc/15589748690799.html"/>
    <updated>2019-05-28T00:34:29+08:00</updated>
    <id>http://adolph.cc/15589748690799.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">策略模式介绍</h2>

<p>​策略模式也叫政策模式，是一种行为型设计模式，是一种比较简单的设计模式。策略模式采用了面向对象的继承和多态机制<br/>
​<br/>
​<span id="more"></span><!-- more --><br/>
​</p>

<h2 id="toc_1">策略模式定义</h2>

<p>​定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。​</p>

<h2 id="toc_2">策略模式使用场景</h2>

<ul>
<li>多个类只有在算法或行为上稍有不同的场景。</li>
<li>算法需要自由切换的场景。</li>
<li>需要屏蔽算法规则的场景</li>
</ul>

<h2 id="toc_3">策略模式通用UML类图</h2>

<p><figure><img src="media/15589748690799/15589749981154.jpg" alt=""/></figure></p>

<p>​</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抽象工厂模式]]></title>
    <link href="http://adolph.cc/15589713437033.html"/>
    <updated>2019-05-27T23:35:43+08:00</updated>
    <id>http://adolph.cc/15589713437033.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">抽象工厂模式定义</h2>

<p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。</p>

<span id="more"></span><!-- more -->

<p><figure><img src="media/15589713437033/15589726153378.jpg" alt=""/></figure></p>

<h2 id="toc_1">抽象工厂模式与工厂方法模式的区别</h2>

<p>工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构，所以有个产品族的概念。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式中的所有产品都是来自同一个接口或抽象类，而抽象工厂模式中的产品则是来自不同的接口或抽象类。<br/>
抽象工厂模式是工厂方法模式的升级版本，在有多个业务，或者多个分类的情况下，抽象工厂模式比较适合。</p>

<h2 id="toc_2">抽象工厂模式的优缺点</h2>

<ol>
<li>优点
<ul>
<li>隔离了具体类(从调用类的代码可以看出)，非公开。</li>
<li>增加产品下的系列也就是增加具体的实现工厂类很方便，符合“开闭原则”(比如上面的例子中我在两种手机下又新增了一个5.0英寸的，直接加一个新的具体工厂类就可以了)</li>
</ul></li>
<li>缺点
<ul>
<li>抽象工厂模式的产品族扩展是很难的，拿上面的手机举例，如果我增加个一个手机品牌OPPO，那么由两个品牌变成三个品牌，试试改一下会发现：首先要更改抽象工厂类，然后会发现所有的类基本上都跟着动了。改变了抽象类和接口，这是大忌！</li>
<li>类文件增加过快</li>
</ul></li>
</ol>

<h2 id="toc_3">抽象工厂方法模式使用实例</h2>

<h3 id="toc_4">1.两种手机的抽象产品类：</h3>

<pre class="line-numbers"><code class="language-java">public abstract class AbstractHUAWEI {
   //华为手机共同的方法，比如品牌
     public void commonMethod(){

     }
//相同的方法，不同的实现。比如尺寸，型号等等
     public abstract  void  dosomething();
}
</code></pre>

<pre class="line-numbers"><code class="language-java">public abstract class AbstractMI {
   //小米手机共同的方法，比如品牌
   public void commonMethod(){

   }
   //相同的方法，不同的实现。比如尺寸，型号等等
   public abstract  void  dosomething();
}
</code></pre>

<h3 id="toc_5">2.两种手机对应的产品实现类</h3>

<pre class="line-numbers"><code class="language-java">public class HUAWEI_A1 extends AbstractHUAWEI{
   @Override
   public void dosomething() {
       Log.i(&quot;qzs&quot;,&quot;我是6.0英寸的华为手机A1&quot;);
   }
}

public class HUAWEI_A2 extends AbstractHUAWEI {
   @Override
   public void dosomething() {
       Log.i(&quot;qzs&quot;,&quot;我是5.5英寸的华为手机A2&quot;);
   }
}

public class MI_B1 extends AbstractMI {
   @Override
   public void dosomething() {
       Log.i(&quot;qzs&quot;,&quot;我是6.0英寸的小米手机B1&quot;);
   }
}

public class MI_B2 extends AbstractMI {
   @Override
   public void dosomething() {
       Log.i(&quot;qzs&quot;,&quot;我是5.5英寸的小米手机B1&quot;);
   }
}
</code></pre>

<h3 id="toc_6">3.抽象工厂类</h3>

<pre class="line-numbers"><code class="language-java">public abstract class AbstractFactory  {
   //6.0英寸手机
     public abstract  AbstractHUAWEI createSize1();

   //5.5英寸手机
     public abstract  AbstractMI createSize2();
}
</code></pre>

<h3 id="toc_7">4.两个工厂实现类</h3>

<pre class="line-numbers"><code class="language-java">public class Factory1 extends AbstractFactory {
   @Override
   public AbstractHUAWEI createSize1() {
       return new HUAWEI_A1();
   }

   @Override
   public AbstractMI createSize2() {
       return new MI_B1();
   }
}
</code></pre>

<pre class="line-numbers"><code class="language-java">public class Factory2 extends AbstractFactory {
   @Override
   public AbstractHUAWEI createSize1() {
       return new HUAWEI_A2();
   }

   @Override
   public AbstractMI createSize2() {
       return new MI_B2();
   }
}
</code></pre>

<h3 id="toc_8">5.调用</h3>

<pre class="line-numbers"><code class="language-java">AbstractFactory factory1=new Factory1();
AbstractFactory factory2=new Factory2();
//生产A1
AbstractHUAWEI a1=factory1.createHUAWEI();
//   a1.dosomething();
//生产A2
AbstractHUAWEI a2=factory2.createHUAWEI();
// a2.dosomething();
//生产B1
AbstractMI b1=factory1.createMI();
//  b1.dosomething();
//生产B2
AbstractMI b2=factory2.createMI();
//   b2.dosomething();
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[工厂方法模式]]></title>
    <link href="http://adolph.cc/15586237778330.html"/>
    <updated>2019-05-23T23:02:57+08:00</updated>
    <id>http://adolph.cc/15586237778330.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">工厂方法模式介绍</h2>

<p>工厂方法模式（Factory Pattern）是一种创建型设计模式，是日常开发中使用频率较高的一种设计模式。下面就要我们一起去了解一下工厂方法设计模式。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">工厂方法设计模式定义</h2>

<p>​定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使<br/>
​一个类的实例化延迟到其子类。</p>

<h2 id="toc_2">工厂方法设计模式使用场景</h2>

<ul>
<li>工厂方法模式是new一个对象的替代品，所以在有需要生成对象的地方都可以使用，但是要慎重的考虑当前任务是不是需要增加一个工厂类进行管理，避免使自己的代码更加复杂。</li>
<li>需要灵活、可扩展的框架时，可以考虑采用工厂方法模式。</li>
</ul>

<h2 id="toc_3">工厂方法设计模式通用UML类图</h2>

<p><figure><img src="media/15586237778330/15586246560603.jpg" alt=""/></figure></p>

<p><strong>说明</strong></p>

<ul>
<li><strong>Product</strong>
产品类的抽象方法，由具体的产品类去实现。</li>
<li><strong>ConcreateProduct</strong>
具体的产品类，可以有多个。继承于Product</li>
<li><strong>Creator</strong>
抽象工厂类，负责定义产品对象的产生。</li>
<li><strong>ConcreateCreator</strong>
具体的工厂实现类，继承于Creator。</li>
</ul>

<h2 id="toc_4">工厂方法模式的优缺点</h2>

<h3 id="toc_5">优点</h3>

<ul>
<li><strong>良好的封装性，代码结构清晰</strong>
不需要知道对象的创建过程，降低模块间的耦合。</li>
<li><strong>工厂方法模式的拓展性非常优秀</strong>
在增加产品类的情况下，只要适当修改具体的工厂类或者拓展一个工厂类，就可以拥抱变化。例如在我们的例子中需要生产一个装radHat的系统的电脑，则只需要增加一个RedHatSoftware类，工厂类不需要做任何修改就可以完成系统拓展。</li>
<li><strong>屏蔽产品类</strong>
产品类的任何变化，调用者都无需关心，它只要关心产品的接口。</li>
<li><strong>典型的解耦框架</strong>
高层模块只需要知道产品的抽象类，其他的实现类无需关心，符合迪米特原则，我们不需要的就不要去交流，符合依赖倒置原则，只依赖产品的抽象，符合里氏替换原则，使用产品子类替换产品父类，当然也没有问题。</li>
</ul>

<h3 id="toc_6">缺点</h3>

<ul>
<li><strong>类结构的复杂化</strong>
每次为工厂方法模式添加新的产品时就要编写一个新的产品类，还要引入抽象层。</li>
</ul>

<h2 id="toc_7">工厂方法模式使用实例</h2>

<p><strong>抽象产品类</strong></p>

<pre class="line-numbers"><code class="language-java">public abstract class InstallSoftware {
   /**
    * 安装系统
    *
    * @param systemOs 系统
    */
   public abstract void installSystem(String systemOs);

   /**
    * 安装显卡驱动
    *
    * @param GPUType 显卡型号
    */
   public abstract void installGPUDriver(String GPUType);

   /**
    * 安装主板驱动
    *
    * @param mainBoxType 主板型号
    */
   public abstract void installMainBoxdriver(String mainBoxType);

   /**
    * 安装网卡驱动
    *
    * @param netCardType 网卡型号
    */
   public abstract void installNetCardDriver(String netCardType);

   /**
    * 安装声卡驱动
    *
    * @param audioType 声卡型号
    */
   public abstract void installAudioDriver(String audioType);

   /**
    * 安装USB驱动
    * @param usbDriverType(3.0,2.0,...)
    */
   public abstract void installUSBDriver(String usbDriverType);

   /**
    * 安装键盘驱动
    * @param keyBoardType 键盘型号
    */
   public abstract void installKeyBoardDriver(String keyBoardType);

   /**
    * 安装鼠标驱动
    * @param mouseType 鼠标型号
    */
   public abstract void installMouseDriver(String mouseType);
   /**
    * 软件系统安装完成
    * @return
    */
   public abstract String finish();
}
</code></pre>

<p><strong>具体的产品Windows系统的电脑</strong></p>

<pre class="line-numbers"><code class="language-java">public class WindowsSoftware extends InstallSoftware {
       @Override
       public void installSystem(String systemOs) {
           //系统下载安装处理
       }

       @Override
       public void installGPUDriver(String GPUType) {
           //显卡驱动下载安装处理
       }

       @Override
       public void installMainBoxdriver(String mainBoxType) {
           //主板驱动下载安装处理
       }

       @Override
       public void installNetCardDriver(String netCardType) {
           //网卡驱动下载安装处理
       }

       @Override
       public void installAudioDriver(String audioType) {
           //声卡驱动下载安装处理
       }

       @Override
       public void installUSBDriver(String usbDriverType) {
           //USB驱动下载安装处理
       }

       @Override
       public void installKeyBoardDriver(String keyBoardType) {
           //键盘驱动下载安装处理
       }

       @Override
       public void installMouseDriver(String mouseType) {
           //鼠标驱动下载安装处理
       }
     
       @Override
       public String finish() {
           return &quot;You can use normal Windows PC&quot;;
       }
   }
</code></pre>

<p><strong>具体的产品类，Ubuntu系统的电脑</strong></p>

<pre class="line-numbers"><code class="language-java">public class UbuntuSoftware extends InstallSoftware {
   @Override
   public void installSystem(String systemOs) {
       //系统下载安装处理
   }

   @Override
   public void installGPUDriver(String GPUType) {
       //显卡驱动下载安装处理
   }

   @Override
   public void installMainBoxdriver(String mainBoxType) {
       //主板驱动下载安装处理
   }

   @Override
   public void installNetCardDriver(String netCardType) {
       //网卡驱动下载安装处理
   }

   @Override
   public void installAudioDriver(String audioType) {
       //声卡驱动下载安装处理
   }

   @Override
   public void installUSBDriver(String usbDriverType) {
       //USB驱动下载安装处理
   }

   @Override
   public void installKeyBoardDriver(String keyBoardType) {
       //键盘驱动下载安装处理
   }

   @Override
   public void installMouseDriver(String mouseType) {
       //鼠标驱动下载安装处理
   }
 
   @Override
   public String finish() {
       return &quot;You can use normal Ubuntu PC&quot;;
   }
}
</code></pre>

<p><strong>具体的产品类，Mac 系统的电脑</strong></p>

<pre class="line-numbers"><code class="language-java">public class MacSoftware extends InstallSoftware {
   @Override
   public void installSystem(String systemOs) {
       //系统下载安装处理
   }

   @Override
   public void installGPUDriver(String GPUType) {
       //显卡驱动下载安装处理
   }

   @Override
   public void installMainBoxdriver(String mainBoxType) {
       //主板驱动下载安装处理
   }

   @Override
   public void installNetCardDriver(String netCardType) {
       //网卡驱动下载安装处理
   }

   @Override
   public void installAudioDriver(String audioType) {
       //声卡驱动下载安装处理
   }

   @Override
   public void installUSBDriver(String usbDriverType) {
       //USB驱动下载安装处理
   }

   @Override
   public void installKeyBoardDriver(String keyBoardType) {
       //键盘驱动下载安装处理
   }

   @Override
   public void installMouseDriver(String mouseType) {
       //鼠标驱动下载安装处理
   }
 
   @Override
   public String finish() {
       return &quot;You can use normal MacOs PC&quot;;
   }
}
</code></pre>

<p><strong>抽象工厂类</strong></p>

<pre class="line-numbers"><code class="language-java">public abstract class Factory {
   abstract &lt;T extends InstallSoftware&gt; T getComputer(Class&lt;T&gt; clz);
}
</code></pre>

<p><strong>工厂类的具体实现</strong></p>

<pre class="line-numbers"><code class="language-java">public class ComputerFactory extends Factory {

   /**
    * 利用反射方式生产具体的产品对象
    *
    * @param clz
    * @param &lt;T&gt;
    * @return
    */
   public &lt;T extends InstallSoftware&gt; T getComputer(Class&lt;T&gt; clz) {
       InstallSoftware installSoftware = null;
       try {
           installSoftware = (InstallSoftware) Class.forName(clz.getName()).newInstance();
       } catch (InstantiationException e) {
           e.printStackTrace();
       } catch (IllegalAccessException e) {
           e.printStackTrace();
       } catch (ClassNotFoundException e) {
           e.printStackTrace();
       }
       return (T) installSoftware;
   }
}
</code></pre>

<p><strong>场景类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Client {
   public static void main(String[] args) {
       //现在生产一批windows系统的电脑
       //这里举例子说明,具体驱动就不一一列举了.
       ComputerFactory computerFactory = new ComputerFactory();
       WindowsSoftware windowsSoftware = computerFactory.getComputer(WindowsSoftware.class);
       windowsSoftware.installSystem(&quot;Windows 10&quot;);
       windowsSoftware.installAudioDriver(&quot;Windows AudioDriver&quot;);
       windowsSoftware.installGPUDriver(&quot;Windows GPUDriver&quot;);
       windowsSoftware.installKeyBoardDriver(&quot;Windows KeyBoardDriver&quot;);
       windowsSoftware.installMainBoxdriver(&quot;Windows MainBoxdrive&quot;);
       windowsSoftware.installMouseDriver(&quot;Windows MouseDriver&quot;);
       windowsSoftware.installNetCardDriver(&quot;Windows NetCardDriver&quot;);
       windowsSoftware.installUSBDriver(&quot;Windows USBDriver&quot;);
       System.out.println(windowsSoftware.finish());

       //现在要生产一批Ubuntu系统的电脑
       UbuntuSoftware ubuntuSoftware = computerFactory.getComputer(UbuntuSoftware.class);
       //Ubuntu系统一般只要安装好系统就可以
       ubuntuSoftware.installSystem(&quot;Ubuntu 14.04&quot;);
       System.out.println(ubuntuSoftware.finish());

       //现在又要生产一批Mac(黑苹果)系统的电脑
       MacSoftware macSoftware = computerFactory.getComputer(MacSoftware.class);
       //黑苹果安装就有点繁琐了,首先要找驱动什么的,替换原有驱动等等,如果对黑苹果有兴趣,可去远景论坛爬贴学习.
       //黑苹果应该是先把找好的驱动什么的融入到安装系统中,然后才开始安装mac系统
       macSoftware.installAudioDriver(&quot;Mac AudioDriver&quot;);
       macSoftware.installGPUDriver(&quot;Mac GPUDriver&quot;);
       macSoftware.installKeyBoardDriver(&quot;Mac KeyBoardDriver&quot;);
       macSoftware.installMainBoxdriver(&quot;Mac MainBoxdriver&quot;);
       macSoftware.installMouseDriver(&quot;Mac MouseDriver&quot;);
       macSoftware.installNetCardDriver(&quot;Mac NetCardDriver&quot;);
       macSoftware.installUSBDriver(&quot;Mac USBDriver&quot;);
       macSoftware.installSystem(&quot;Mac Os 10.11.6&quot;);
       System.out.println(macSoftware.finish());
   }
}
</code></pre>

<h2 id="toc_8">工厂方法模式的拓展</h2>

<p>​工厂方法模式一般有4种拓展，分别为简单工厂模式、升级为多个工厂类、替换单例模式、延迟初始化。</p>

<p>​下面我们详细说明这4个拓展。</p>

<h3 id="toc_9">简单工厂模式（静态工厂模式）</h3>

<p>如果一个模块仅需要一个工厂类，使用静态方法就可以，所有我们把上诉工厂类的具体实现（ComputerFactory）里的方法改为静态就可以了:</p>

<pre class="line-numbers"><code class="language-java">public class ComputerFactory{

   /**
    * 利用反射方式生产具体的产品对象
    *
    * @param clz
    * @param &lt;T&gt;
    * @return
    */
   public static  &lt;T extends InstallSoftware&gt; T getComputer(Class&lt;T&gt; clz) {
       InstallSoftware installSoftware = null;
       try {
           installSoftware = (InstallSoftware) Class.forName(clz.getName()).newInstance();
       } catch (InstantiationException e) {
           e.printStackTrace();
       } catch (IllegalAccessException e) {
           e.printStackTrace();
       } catch (ClassNotFoundException e) {
           e.printStackTrace();
       }
       return (T) installSoftware;
   }
}
</code></pre>

<p><strong>说明</strong></p>

<p>上诉代码与原有相比，有2处变化，一处是去掉了Factory抽象类,一处是把getComputer设为静态方法。</p>

<p>场景类也要做一些适当变化:</p>

<pre class="line-numbers"><code class="language-java">public class Client {
       public static void main(String[] args) {
           //现在生产一批windows系统的电脑
           //这里举例子说明,具体驱动就不一一列举了.
          
           WindowsSoftware windowsSoftware = ComputerFactory.getComputer(WindowsSoftware.class);
           windowsSoftware.installSystem(&quot;Windows 10&quot;);
           windowsSoftware.installAudioDriver(&quot;Windows AudioDriver&quot;);
           windowsSoftware.installGPUDriver(&quot;Windows GPUDriver&quot;);
           windowsSoftware.installKeyBoardDriver(&quot;Windows KeyBoardDriver&quot;);
           windowsSoftware.installMainBoxdriver(&quot;Windows MainBoxdrive&quot;);
           windowsSoftware.installMouseDriver(&quot;Windows MouseDriver&quot;);
           windowsSoftware.installNetCardDriver(&quot;Windows NetCardDriver&quot;);
           windowsSoftware.installUSBDriver(&quot;Windows USBDriver&quot;);
           System.out.println(windowsSoftware.finish());

           //现在要生产一批Ubuntu系统的电脑
           UbuntuSoftware ubuntuSoftware = ComputerFactory.getComputer(UbuntuSoftware.class);
           //Ubuntu系统一般只要安装好系统就可以
           ubuntuSoftware.installSystem(&quot;Ubuntu 14.04&quot;);
           System.out.println(ubuntuSoftware.finish());

           //现在又要生产一批Mac(黑苹果)系统的电脑
           MacSoftware macSoftware = ComputerFactory.getComputer(MacSoftware.class);
           //黑苹果安装就有点繁琐了,首先要找驱动什么的,替换原有驱动等等,如果对黑苹果有兴趣,可去远景论坛爬贴学习.
           //黑苹果应该是先把找好的驱动什么的融入到安装系统中,然后才开始安装mac系统
           macSoftware.installAudioDriver(&quot;Mac AudioDriver&quot;);
           macSoftware.installGPUDriver(&quot;Mac GPUDriver&quot;);
           macSoftware.installKeyBoardDriver(&quot;Mac KeyBoardDriver&quot;);
           macSoftware.installMainBoxdriver(&quot;Mac MainBoxdriver&quot;);
           macSoftware.installMouseDriver(&quot;Mac MouseDriver&quot;);
           macSoftware.installNetCardDriver(&quot;Mac NetCardDriver&quot;);
           macSoftware.installUSBDriver(&quot;Mac USBDriver&quot;);
           macSoftware.installSystem(&quot;Mac Os 10.11.6&quot;);
           System.out.println(macSoftware.finish());
         
              }
}
</code></pre>

<p><strong>说明</strong></p>

<p>运行结果没有发生变化，而且调用者比较简单，缺点是工厂类的拓展比较困难，不符合开闭原则，但是它仍然是一个非常实用的设计模式。</p>

<h3 id="toc_10">升级为多个工厂类</h3>

<p>我们在做一个比较复杂的项目的时候，所有产品类都放到一个工厂方法中进行初始化会使代码结构不清晰。例如：一个产品类有5个具体实现。每个实现类的初始化（不仅仅是new，初始化包括new一个对象，并对对象设置一定的初始值）方法都不相同，如果写在一个工厂方法中，势必会导致该方法巨大无比，这时我们把工厂方法模式升级为多个工厂类就可以解决这个问题，下面我们还是以上述案例为例，但是每个电脑安装的驱动版本不同。下面是修改后的简单的UML类图(方法全部省略了)</p>

<p><figure><img src="media/15586237778330/15586253207702.jpg" alt=""/></figure><br/>
我们以生产不同软件/系统版本的windows电脑为例，其他2种实现方式一致。</p>

<p>其实就是在文章最开始的例子中把一个工厂类分成了3个工厂类，使其各个工厂各司其职，提升工厂产量。</p>

<p><strong>Factory修改为</strong></p>

<pre class="line-numbers"><code class="language-java">public abstract class Factory {
   public abstract  InstallSoftware getComputer();
}
</code></pre>

<p><strong>增加WindowsFactory</strong></p>

<pre class="line-numbers"><code class="language-java">public class WindowsFactory extends Factory {

   @Override
  public InstallSoftware getComputer() {
       return new WindowsSoftware();
   }
}
</code></pre>

<p><strong>场景类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Client2 {

   public static void main(String[] args) {
       //这里举例子说明,具体驱动就不一一列举了.
       WindowsFactory windowsFactory = new WindowsFactory();
       WindowsSoftware windowsSoftware = (WindowsSoftware) windowsFactory.getComputer();
       windowsSoftware.installSystem(&quot;Windows 10&quot;);
       windowsSoftware.installAudioDriver(&quot;Windows AudioDriver&quot;);
       windowsSoftware.installGPUDriver(&quot;Windows GPUDriver&quot;);
       windowsSoftware.installKeyBoardDriver(&quot;Windows KeyBoardDriver&quot;);
       windowsSoftware.installMainBoxdriver(&quot;Windows MainBoxdrive&quot;);
       windowsSoftware.installMouseDriver(&quot;Windows MouseDriver&quot;);
       windowsSoftware.installNetCardDriver(&quot;Windows NetCardDriver&quot;);
       windowsSoftware.installUSBDriver(&quot;Windows USBDriver&quot;);
       System.out.println(windowsSoftware.finish());
   }
}
</code></pre>

<p><strong>说明:</strong>其他2种就不举例了，实现方式类似。实现各自的Factory使其继承自Factory抽象类。</p>

<h3 id="toc_11">替换单例模式</h3>

<p>通过反射实现，下面举个例子：</p>

<p><strong>单例类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Singleton {
    //不允许通过new产生一个对象
   private Singleton() {
   }
   
   public void doSomething() {
        //业务处理       
    }
}
</code></pre>

<p><strong>负责生成单例的工厂类</strong></p>

<pre class="line-numbers"><code class="language-java">public class SingletonFactory {
       private static Singleton singleton;
       static {
           try {
               Class c1=Class.forName(Singleton.class.getName());
               //获得无参构造
               Constructor constructor=c1.getDeclaredConstructor();
               //设置无参构造是可以访问的
               constructor.setAccessible(true);
               //产生一个实体对象
               singleton=(Singleton)constructor.newInstance();
           } catch (ClassNotFoundException e) {
               e.printStackTrace();
           } catch (NoSuchMethodException e) {
               e.printStackTrace();
           } catch (IllegalAccessException e) {
               e.printStackTrace();
           } catch (InstantiationException e) {
               e.printStackTrace();
           } catch (InvocationTargetException e) {
               e.printStackTrace();
           }
       }

       public static Singleton getSingleton() {
           return singleton;
       }
}
</code></pre>

<h3 id="toc_12">延迟初始化</h3>

<p>何为延迟初始化（Lazy initialization）？一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。延迟初始化是工厂方法模式的一个扩展应用，其通用类图如图如下所示。</p>

<p><figure><img src="media/15586237778330/15586255890375.jpg" alt=""/></figure><br/>
ProductFactory负责产品类对象的创建工作，并且通过prMap变量产生一个缓存，对需要再次被重用的对象保留，Product和ConcreteProduct是一个示例代码。ProductFactory如代码清单如下所示</p>

<pre class="line-numbers"><code class="language-java">public class ProductFactory {
        private static final Map&lt;String, Product&gt; prMap = new HashMap();

        public static synchronized Product createProduct(String type)
                throws Exception {
            Product product = null;
            // 如果Map中已经有这个对象
            if (prMap.containsKey(type)) {
                product = prMap.get(type);
            } else {
                if (type.equals(&quot;Product1&quot;)) {
                    product = new ConcreteProduct1();
                } else {
                    product = new ConcreteProduct2();
                }
                // 同时把对象放到缓存容器中
                prMap.put(type, product);
            }
            return product;
        }
    }
</code></pre>

<p>通过定义一个Map容器，容纳所有产生的对象，如果在Map容器中已经有的对象，则直接取出返回；如果没有，则根据需要的类型产生一个对象并放入到Map容器中，以方便下次调用。</p>

<p>延迟加载框架是可以扩展的，例如限制某一个产品类的最大实例化数量，可以通过判断Map中已有的对象数量来实现，这样的处理是非常有意义的，例如JDBC连接数据库，都会 要求设置一个MaxConnections最大连接数量，该数量就是内存中最大实例化的数量。 延迟加载还可以用在对象初始化比较复杂的情况下，例如硬件访问，涉及多方面的交互，则可以通过延迟加载降低对象的产生和销毁带来的复杂性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[原型模式]]></title>
    <link href="http://adolph.cc/15586227773925.html"/>
    <updated>2019-05-23T22:46:17+08:00</updated>
    <id>http://adolph.cc/15586227773925.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">原型模式介绍</h2>

<p>原型模式是一个创建型的模式。原型二字即可表明该模式有一个样板实例，用户可以从这个样板的对象中复制一个与该对象内部属性一致的对象，也就是我们所说的克隆。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">原型模式使用场景</h2>

<ul>
<li><p><strong>资源优化场景</strong><br/>
类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等。</p></li>
<li><p><strong>性能和安全要求的场景</strong><br/>
通过new产生一个对象需要非常繁琐的数据准备或访问权限。</p></li>
<li><p><strong>一个对象多个修改者的场景</strong><br/>
一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</p></li>
</ul>

<h2 id="toc_2">原型模式通用UML类图</h2>

<p><figure><img src="media/15586227773925/15586230034058.jpg" alt=""/></figure></p>

<h3 id="toc_3">角色介绍</h3>

<ul>
<li>client: 客户端用户</li>
<li>Prototype: 抽象类或者接口，声明具备clone能力</li>
<li>ConcretePrototype: 具体的原型类</li>
</ul>

<h2 id="toc_4">原型模式的优缺点</h2>

<h3 id="toc_5">优点</h3>

<ul>
<li><strong>性能优良</strong>
原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是在一个循环体内产生大量的对象时，原型模式可以更好的体现其优点。</li>
</ul>

<h3 id="toc_6">缺点</h3>

<p>​ 这既是优点也是缺点，直接在内存中拷贝，构造函数不会执行。优点是减少了约束，缺点也是减少了约束，大家在实际应用中应该需要考虑这一点。</p>

<h2 id="toc_7">原型模式使用实例</h2>

<p>原型模式一般是要实现cloneable接口，并且重写clone方法，现在我们以文档拷贝来演示一个原型模式的实现。</p>

<p><strong>注意:</strong> clone 方法并不是Cloneable中的，而是Object中的方法，Cloneable 是一个标识接口，它表明这个类的对象是可以拷贝的。如果没有实现Cloneable接口却调用了clone()函数将抛出异常。</p>

<p><strong>1、ConcretePrototype 角色</strong></p>

<pre class="line-numbers"><code class="language-java">/**
* 文档类型,扮演的是ConCretePrototype角色,而cloneable是代表prototype角色
*/
public class WordDocument implements Cloneable {
   //文本
   private String mText;
   //图片列表
   private ArrayList mImages = new ArrayList&lt;&gt;();
   private HashMap hashMap = new HashMap&lt;&gt;();

   public WordDocument() {
       System.out.println(&quot;---------------WordDocument构造函数--------------------&quot;);
   }

   @Override
   protected WordDocument clone() {
       try {
           WordDocument document = (WordDocument) super.clone();
           document.mText = this.mText;
           document.mImages = this.mImages;
           document.hashMap = this.hashMap;
           return document;
       } catch (Exception e) {

       }

       return null;
   }

   public HashMap getHashMap() {
       return hashMap;
   }

   public void setHashMap(HashMap hashMap) {
       this.hashMap = hashMap;
   }

   public void addMap(String key, String value) {
       hashMap.put(key, value);
   }

   public String getmText() {
       return mText;
   }

   public void setmText(String mText) {
       this.mText = mText;
   }

   public ArrayList getmImages() {
       return mImages;
   }

   public void setmImages(ArrayList mImages) {
       this.mImages = mImages;
   }

   public void addImages(String image) {
       this.mImages.add(image);
   }

   //打印文档内容
   public void showDocument() {
       System.out.println(&quot;---------Word Content Start---------------&quot;);
       System.out.println(&quot;Text:&quot; + mText);
       System.out.println(&quot;Images List:&quot;);
       for (String imgName : mImages) {
           System.out.println(&quot;image name :&quot; + imgName);
       }
       System.out.println(&quot;hashMap:&quot;);
       for (String key : hashMap.keySet()) {
           System.out.println(key + &quot;:&quot; + hashMap.get(key));

       }

       System.out.println(&quot;---------Word Content End---------------&quot;);


   }
}
</code></pre>

<p><strong>2、测试Client类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Client {
   public static void main(String[] args) {
       //构建文档对象
       WordDocument originDoc = new WordDocument();
       originDoc.setmText(&quot;这是一篇文档&quot;);
       originDoc.addImages(&quot;图片1&quot;);
       originDoc.addImages(&quot;图片2&quot;);
       originDoc.addImages(&quot;图片3&quot;);
       originDoc.addMap(&quot;yi&quot;, &quot;ui&quot;);
       originDoc.showDocument();

       //一万原始文档为模板,拷贝一份副本
       WordDocument doc2 = originDoc.clone();
       originDoc.showDocument();
       //修改文档副本,不会影响原始文档
       doc2.setmText(&quot;这是修改过的文本&quot;);
       doc2.showDocument();

       originDoc.showDocument();
   }
}
</code></pre>

<p><strong>3、运行结果</strong><br/>
<figure><img src="media/15586227773925/15586232946510.jpg" alt=""/></figure></p>

<h2 id="toc_8">原型模式的深拷贝和浅拷贝</h2>

<h3 id="toc_9">浅拷贝</h3>

<p>上述原型模式的实例其实是一个浅拷贝，也叫影子拷贝，这种拷贝实际上并不是将原始文档的所有字段都重新构造一份，而是将副本文档的字段引用原始文档的字段。</p>

<p>比如改变上述client类中Image List的值：</p>

<pre class="line-numbers"><code class="language-java">public class Client {
    public static void main(String[] args) {
        //构建文档对象
        WordDocument originDoc = new WordDocument();
        originDoc.setmText(&quot;这是一篇文档&quot;);
        originDoc.addImages(&quot;图片1&quot;);
        originDoc.addImages(&quot;图片2&quot;);
        originDoc.addImages(&quot;图片3&quot;);
        originDoc.addMap(&quot;yi&quot;, &quot;ui&quot;);
        originDoc.showDocument();

        //一万原始文档为模板,拷贝一份副本
        WordDocument doc2 = originDoc.clone();
        originDoc.showDocument();
        //修改文档副本,不会影响原始文档
        doc2.setmText(&quot;这是修改过的文本&quot;);
        //doc2 新增自己的图片
        doc2.addImages(&quot;这是doc2添加的图片&quot;);
        doc2.showDocument();

        originDoc.showDocument();
    }
}
</code></pre>

<p>执行结果为：</p>

<p><figure><img src="media/15586227773925/15586233532546.jpg" alt=""/></figure><br/>
从图中可以看到doc2新增的图片，originDoc 也新增了同样的一张图片，那么如何解决这个问题呢，那就需要深拷贝。</p>

<h3 id="toc_10">深拷贝</h3>

<p>那什么是深拷贝呢，两个对象之间没有任何瓜葛，你修改你的，我修改我的，不相互影响，对于引用类型的字段也要采用拷贝的形式，而不是单纯引用的形式，这才叫深拷贝。</p>

<p>下面我们只需修改上述例子的ConcretePrototype 角色WordDocument类中的clone方法，以实现深拷贝:</p>

<pre class="line-numbers"><code class="language-java"> @Override
    protected WordDocument clone() {
        try {
            WordDocument document = (WordDocument) super.clone();
            document.mText = this.mText;
//            document.mImages=this.mImages;
//            document.hashMap=this.hashMap;
            //对MImages对象也调用clone对象,进行深拷贝
            document.mImages = (ArrayList) this.mImages.clone();
            document.hashMap = (HashMap) this.hashMap.clone();
            return document;
        } catch (Exception e) {

        }

        return null;
    }
</code></pre>

<p>client不动，运行后的结果为：</p>

<p><figure><img src="media/15586227773925/15586234169780.jpg" alt=""/></figure><br/>
从上述图片可以看到doc2添加了图片，originDoc并没有受到影响，doc2新增的图片在originDoc中并没有找到。</p>

<p>建议: 在开发过程中，为了减少错误，建议大家使用深拷贝，避免因操作副本影响原始对象。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Builder模式(建造者模式)]]></title>
    <link href="http://adolph.cc/15586211809529.html"/>
    <updated>2019-05-23T22:19:40+08:00</updated>
    <id>http://adolph.cc/15586211809529.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">Builder模式介绍</h2>

<ul>
<li>建造者模式（Builder Pattern）也叫做生成器模式，Builder Design pattern 是一种创造型模式，Builder模式所解决的问题与对象的创建有关。它允许用户在不知道内部构建细节的情况下，可以更精细的控制对象的构造流程，Builder模式是为了将构造复杂对象的过程和他的部件解耦。Android 中我们最常用的Builder模式是AlterDialog.Builder。</li>
<li>Builder 模式通常是以静态内部类的形式实现。</li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_1">Builder模式使用场景</h2>

<ul>
<li>需要太多的构造函数。</li>
<li>当初始化一个对象特别复杂，如参数多，并且很多参数具有默认值时。</li>
<li>配置类的构造器的构建，将配置与目标类隔离出来。</li>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时。</li>
<li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果不同时。</li>
<li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能。</li>
</ul>

<h2 id="toc_2">Builder模式通用UML类图</h2>

<p><figure><img src="media/15586211809529/15586214879539.jpg" alt=""/></figure></p>

<p><strong>说明</strong></p>

<ul>
<li><strong>Product产品类</strong>
ConcreateBuilder 创建该产品的内部表示，并定义它的装配过程。</li>
<li><strong>Builder抽象建造者</strong>
规范产品的组建，一般是由子类实现。</li>
<li><strong>ConcreateBuilder 具体建造者</strong>
实现抽象类定义的所有方法，并且返回一个组建好的对象。</li>
<li><strong>Director导演类</strong>
负责安排已有模块的顺序，然后告诉Builder开始建造。</li>
</ul>

<h2 id="toc_3">Builder模式的优缺点</h2>

<h3 id="toc_4">优点</h3>

<ul>
<li>封装性,使用建造者模式客户端不必知道产品内部的组成的细节,将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>建造者独立，容易拓展</li>
<li>增加新的具体建造者无须修改原有类库的代码，创建者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”<br/>
### 缺点</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，会导致具体建造者数量变得很多。</li>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
</ul>

<h2 id="toc_5">使用实例</h2>

<h3 id="toc_6">标准化的建造者（Builder）模式使用实例</h3>

<p>我们以组建一台自己心仪的台式机电脑为例</p>

<p><strong>电脑抽象类</strong></p>

<pre class="line-numbers"><code class="language-java">  /**
  * Created by iuni.life on 16/8/2.
  * 组建一台简单的台式机电脑,电脑抽象类 即Product角色
  */
  public class Computer {
     //cpu
     protected String mCpu = &quot;intel i3-4150&quot;;
     //显示器
     protected String mDisplay = &quot;21寸&quot;;
     //主板
     protected String mBoard = &quot;华硕 B85&quot;;
     //电源
     protected String mPower = &quot;安钛克 220V&quot;;
     //系统
     protected String mSysOs = &quot;Dos&quot;;
     //主机箱
     protected String mMainBox = &quot;先马&quot;;
     //鼠标
     protected String mMouse = &quot;贱驴&quot;;
     //键盘
     protected String mKeyBoard = &quot;cherry&quot;;
     //内存条
     protected String mSimm = &quot;2*4G&quot;;
     //硬盘
     protected String mHardDisk = &quot;希捷 1T&quot;;

     protected ComputerStant() {
     }

     public abstract void setSimm(String simm);

     public abstract void setHardDisk(String hardDisk);

     public abstract void setCpu(String cpu);

     public abstract void setDisplay(String display);

     public abstract void setBoard(String board);

     public abstract void setPower(String power);

     public abstract void setSysOs(String sysOs);

     public abstract void setMainBox(String mainBox);

     public abstract void setMouse(String mouse);

     public abstract void setKeyBoard(String keyBoard);

     @Override
     public String toString() {
         return &quot;ComputerStant{&quot; +
                 &quot;mCpu=&#39;&quot; + mCpu + &#39;\&#39;&#39; +
                 &quot;, mDisplay=&#39;&quot; + mDisplay + &#39;\&#39;&#39; +
                 &quot;, mBoard=&#39;&quot; + mBoard + &#39;\&#39;&#39; +
                 &quot;, mPower=&#39;&quot; + mPower + &#39;\&#39;&#39; +
                 &quot;, mSysOs=&#39;&quot; + mSysOs + &#39;\&#39;&#39; +
                 &quot;, mMainBox=&#39;&quot; + mMainBox + &#39;\&#39;&#39; +
                 &quot;, mMouse=&#39;&quot; + mMouse + &#39;\&#39;&#39; +
                 &quot;, mKeyBoard=&#39;&quot; + mKeyBoard + &#39;\&#39;&#39; +
                 &quot;, mSimm=&#39;&quot; + mSimm + &#39;\&#39;&#39; +
                 &quot;, mHardDisk=&#39;&quot; + mHardDisk + &#39;\&#39;&#39; +
                 &#39;}&#39;;
     }
  }
</code></pre>

<p><strong>电脑抽象类的具体实现，我们以Mac电脑为例</strong></p>

<pre class="line-numbers"><code class="language-java">/**
  * Created by iuni.life on 16/8/2.
  *
  */
  public class MacComputer extends Computer {

     protected MacComputer() {
     }

     @Override
     public void setSimm(String simm) {
         mSimm = simm;
     }

     @Override
     public void setHardDisk(String hardDisk) {
         mHardDisk = hardDisk;
     }

     @Override
     public void setCpu(String cpu) {
         mCpu = cpu;
     }

     @Override
     public void setDisplay(String display) {
         mDisplay = display;
     }

     @Override
     public void setBoard(String board) {
         mBoard = board;
     }

     @Override
     public void setPower(String power) {
         mPower = power;
     }

     @Override
     public void setSysOs(String sysOs) {
         mSysOs = sysOs;
     }

     @Override
     public void setMainBox(String mainBox) {
         mMainBox = mainBox;
     }

     @Override
     public void setMouse(String mouse) {
         mMouse = mouse;
     }

     @Override
     public void setKeyBoard(String keyBoard) {
         mKeyBoard = keyBoard;
     }
}
</code></pre>

<p><strong>Builder抽象类</strong></p>

<pre class="line-numbers"><code class="language-java">/**
  * Created by iuni.life on 16/8/2.
  * builder 抽象类
  */
  public abstract class Builder {
     //创建显示器
     public abstract Builder buildDisplay(String display);

     //创建主板
     public abstract Builder buildBoard(String board);

     //创建电源
     public abstract Builder buildPower(String power);

     //创建cpu
     public abstract Builder buildCpu(String cpu);

     //创建系统
     public abstract Builder buildSysOs(String sysOs);

     //创建主机箱
     public abstract Builder buildMainBox(String mainBox);

     //创建鼠标
     public abstract Builder buildMouse(String mouse);

     //创建键盘
     public abstract Builder buildKeyBoard(String keyBoard);

     //创建内存条
     public abstract Builder buildSimm(String simm);

     //创建硬盘
     public abstract Builder buildHardDisk(String hardDisk);

     //创建Computer
     public abstract ComputerStant create();
}
</code></pre>

<p><strong>Builder 的具体实现，因为我们是要组装一个Mac 电脑，所以需要MacBuilder</strong></p>

<pre class="line-numbers"><code class="language-java">/**
  * Created by iuni.life on 16/8/2.
  */
   public class MacBuilder extends Builder {
       MacComputer macComputer = new MacComputer();

       @Override
       public Builder buildDisplay(String display) {
           macComputer.setDisplay(display);
           return this;
       }

       @Override
       public Builder buildBoard(String board) {
           macComputer.setBoard(board);
           return this;
       }

       @Override
       public Builder buildPower(String power) {
           macComputer.setPower(power);
           return this;
       }

       @Override
       public Builder buildCpu(String cpu) {
           macComputer.setCpu(cpu);
           return this;
       }

       @Override
       public Builder buildSysOs(String sysOs) {
           macComputer.setSysOs(sysOs);
           return this;
       }

       @Override
       public Builder buildMainBox(String mainBox) {
           macComputer.setMainBox(mainBox);
           return this;
       }

       @Override
       public Builder buildMouse(String mouse) {
           macComputer.setMouse(mouse);
           return this;
       }

       @Override
       public Builder buildKeyBoard(String keyBoard) {
           macComputer.setKeyBoard(keyBoard);
           return this;
       }

       @Override
       public Builder buildSimm(String simm) {
           macComputer.setSimm(simm);
           return this;
       }

       @Override
       public Builder buildHardDisk(String hardDisk) {
           macComputer.setHardDisk(hardDisk);
           return this;
       }

       @Override
       public ComputerStant create() {
           return macComputer;
       }
   }
</code></pre>

<p><strong>Director 导演类</strong></p>

<pre class="line-numbers"><code class="language-java">/**
  * Created by iuni.life on 16/8/2.
  */
public class Director {
        Builder mBuilder = null;

      public Director(Builder mBuilder) {
           this.mBuilder = mBuilder;
       }

       //构建对象
       public void constract(String mCpu, String mDisplay, String mBoard, String mPower, String mSysOs, String mMainBox, String mMouse, String mKeyBoard, String mSimm, String mHardDisk) {
           mBuilder.buildCpu(mCpu);
           mBuilder.buildDisplay(mDisplay);
           mBuilder.buildBoard(mBoard);
           mBuilder.buildPower(mPower);
           mBuilder.buildSysOs(mSysOs);
           mBuilder.buildMainBox(mMainBox);
           mBuilder.buildMouse(mMouse);
           mBuilder.buildKeyBoard(mKeyBoard);
           mBuilder.buildSimm(mSimm);
           mBuilder.buildHardDisk(mHardDisk);
           //也可链式
    //        mBuilder.buildMouse(mMouse).buildCpu(mCpu).buildPower(mPower);
       }
}
</code></pre>

<p><strong>测试类Test</strong></p>

<pre class="line-numbers"><code class="language-java">/**
  * Created by iuni.life on 16/8/2.
  * 经典的Builder模式实现较为繁琐,文章后面会列举一个简单的
  */
public class Test {
       public static void main(String[] args) {
           //构造器
           Builder builder = new MacBuilder();
           //Director
           Director director = new Director(builder);

           //封装构建过程
           director.constract(&quot;intel i7&quot;, &quot;25寸&quot;, &quot;华硕 B85&quot;, &quot;安钛克220V&quot;, &quot;Mac Os&quot;, &quot;先马&quot;, &quot;精灵 X5&quot;, &quot;cherry&quot;, &quot;2*8G&quot;, &quot;希捷500G&quot;);

           //构建电脑,输出相关信息

           System.out.println(&quot;My Mac Computer Info:&quot;+builder.create().toString());
   //        通过Builder来构建产品对象, 而Director封装了构建复杂产品对象对象的过程，对外隐藏构建细节。
       }
}
</code></pre>

<p><strong>说明</strong><br/>
通过Builder来构建产品对象, 而Director封装了构建复杂产品对象对象的过程，对外隐藏构建细节。但是这种经典的写法有点小烦，有点繁琐，在要求不是很苛刻的情况下，我们可以用下面的方式进行实现。</p>

<h3 id="toc_7">一种简单的方式实现Builder模式</h3>

<ul>
<li>这种方式以Builder为静态内部类的方式实现，我们还是以组装一台自己的电脑为例</li>
</ul>

<pre class="line-numbers"><code class="language-java">/**
* Created by iuni.life on 16/8/2.
* 组建一台简单的台式机电脑,电脑抽象类 即Product角色
*/
public class Computer {
  //cpu
  private String cpu;
  //显示器
  private String display;
  //主板
  private String board;
  //电源
  private String power;
  //系统
  private String sysOs;
  //主机箱
  private String mainBox;
  //鼠标
  private String mouse;
  //键盘
  private String keyBoard;

  //私有化构造函数 使之不能从外部创建实例
  private Computer() {
  }

  private void setCpu(String cpu) {
      this.cpu = cpu;
  }

  private void setDisplay(String display) {
      this.display = display;
  }

  private void setBoard(String board) {
      this.board = board;
  }

  private void setPower(String power) {
      this.power = power;
  }

  private void setSysOs(String sysOs) {
      this.sysOs = sysOs;
  }

  private void setMainBox(String mainBox) {
      this.mainBox = mainBox;
  }

  private void setMouse(String mouse) {
      this.mouse = mouse;
  }

  private void setKeyBoard(String keyBoard) {
      this.keyBoard = keyBoard;
  }

  @Override
  public String toString() {
      return &quot;Computer{&quot; +
              &quot;cpu=&#39;&quot; + cpu + &#39;\&#39;&#39; +
              &quot;, display=&#39;&quot; + display + &#39;\&#39;&#39; +
              &quot;, board=&#39;&quot; + board + &#39;\&#39;&#39; +
              &quot;, power=&#39;&quot; + power + &#39;\&#39;&#39; +
              &quot;, sysOs=&#39;&quot; + sysOs + &#39;\&#39;&#39; +
              &quot;, mainBox=&#39;&quot; + mainBox + &#39;\&#39;&#39; +
              &quot;, mouse=&#39;&quot; + mouse + &#39;\&#39;&#39; +
              &quot;, keyBoard=&#39;&quot; + keyBoard + &#39;\&#39;&#39; +
              &#39;}&#39;;
  }
//Builder 静态内部类
  public static class ComputerBuilder {
      //创建computer实例
      private Computer computer = new Computer();

      //创建Cpu
      public ComputerBuilder buildCpu(String cpu) {
          computer.setCpu(cpu);
          return this;
      }

    //创建显示器
      public ComputerBuilder buildDisplay(String display) {
          computer.setDisplay(display);
          return this;

      }
    //创建主板
      public ComputerBuilder buildBoard(String board) {
          computer.setBoard(board);
          return this;
      }

        //创建电源
      public ComputerBuilder buildPower(String power) {
          computer.setPower(power);
          return this;
      }

      //创建系统
      public ComputerBuilder buildSysOs(String sysOs) {
          computer.setSysOs(sysOs);
          return this;
      }

      //创建主机箱
      public ComputerBuilder buildMainBox(String mainBox) {
          computer.setMainBox(mainBox);
          return this;
      }

      //创建鼠标
      public ComputerBuilder buildMouse(String mouse) {
          computer.setMouse(mouse);
          return this;
      }

      //创建键盘
      public ComputerBuilder buildKeyBoard(String keyBoard) {
          computer.setKeyBoard(keyBoard);
          return this;
      }
    //组装电脑，并返回创建好的电脑
      public Computer create() {
          //这里可以做一些初始化操作以及一些逻辑判断
          if (computer==null){
              throw  new IllegalStateException(&quot;computer is null&quot;);
          }
          return computer;
      }
  }
}
</code></pre>

<ul>
<li>测试类</li>
</ul>

<pre class="line-numbers"><code class="language-java">/**
* Created by iuni.life on 16/8/2.
*/
public class main {
  public static void main(String[] args) {
      //创建Builder对象
      Computer.ComputerBuilder computerBuilder = new Computer.ComputerBuilder();
      //组装电脑,构建组装顺序
      computerBuilder.buildBoard(&quot;华硕&quot;);
      computerBuilder.buildCpu(&quot;intel i7&quot;);
      computerBuilder.buildDisplay(&quot;三星&quot;);
      computerBuilder.buildKeyBoard(&quot;cherry&quot;);
      computerBuilder.buildMainBox(&quot;杀神&quot;).buildMouse(&quot;贱驴&quot;).buildPower(&quot;安钛克&quot;).buildSysOs(&quot;Windoes 10&quot;);
      //组装成一个自己想要的的电脑。
      // computerBuilder  只需要知道客户想组装成什么样的电脑,并对客户不关心的如何安装进行了隐藏。
      Computer computer = computerBuilder.create();
      System.out.printf(computer.toString());
  }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis学习记录]]></title>
    <link href="http://adolph.cc/15586033218679.html"/>
    <updated>2019-05-23T17:22:01+08:00</updated>
    <id>http://adolph.cc/15586033218679.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">什么是Redis</h2>

<p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如<br/>
下：</p>

<ul>
<li>字符串类型(String)</li>
<li>散列类型(Hash)</li>
<li>列表类型(List)</li>
<li>集合类型(Set)</li>
<li>有序集合类型(Sorted Set)</li>
</ul>

<!-- More -->

<p>Redis具备LRU淘汰、事务实现、以及不同级别的硬盘持久化等能力，并且支持副本集和通过Redis Sentinel实现的高可用方案，同时还支持通过Redis Cluster实现的数据自动分片能力。<br/>
Redis的主要功能都基于单线程模型实现，也就是说Redis使用一个线程来服务所有的客户端请求，同时Redis采用了非阻塞式IO，并精细地优化各种命令的算法时间复杂度，这些信息意味着：</p>

<ul>
<li>Redis是线程安全的（因为只有一个线程），其所有操作都是原子的，不会因并发产生数据异常Redis的速度非常快（因为使用非阻塞式IO，且大部分命令的算法时间复杂度都是O(1))</li>
<li>使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）</li>
</ul>

<h2 id="toc_1">Redis特性</h2>

<h3 id="toc_2">特性1：速度快</h3>

<p>10w QPS</p>

<h4 id="toc_3">原因</h4>

<ul>
<li>数据存在内存</li>
<li>c语言编写</li>
<li>单线程编写</li>
</ul>

<p><figure><img src="media/15586033218679/15586045813341.jpg" alt=""/></figure><br/>
<figure><img src="media/15586033218679/15586045962154.jpg" alt=""/></figure></p>

<h3 id="toc_4">特性2：持久化</h3>

<p>redis所有的数据保存在内存中，对数据的更新将异步地保存到磁盘上</p>

<h3 id="toc_5">特性3：数据结构</h3>

<p><figure><img src="media/15586033218679/15586046729099.jpg" alt=""/></figure></p>

<h3 id="toc_6">特性4：多语言客户端</h3>

<ul>
<li>java</li>
<li>php</li>
<li>python</li>
<li>ruby</li>
<li>lua</li>
<li>nodejs</li>
</ul>

<h3 id="toc_7">特性5：功能丰富</h3>

<ul>
<li>发布订阅</li>
<li>lua脚本</li>
<li>事务</li>
<li>pipeline</li>
</ul>

<h3 id="toc_8">特性6：简单</h3>

<ul>
<li>23000行代码实现核心功能</li>
<li>不依赖外部库</li>
<li>单线程模型</li>
</ul>

<h3 id="toc_9">特性7：复制</h3>

<p><figure><img src="media/15586033218679/15586048274124.jpg" alt=""/></figure></p>

<h3 id="toc_10">特性8：高可用</h3>

<ul>
<li>redis-sentinel支持高可用</li>
<li>分布式 redis-cluster支持分布式</li>
</ul>

<h2 id="toc_11">典型使用场景</h2>

<h3 id="toc_12">缓存系统</h3>

<p><figure><img src="media/15586033218679/15586048982283.jpg" alt=""/></figure><br/>
缓存一些热点数据，例如，PC版本文件更新内容、资讯标签和分类信息、生日祝福寿星列表。</p>

<h3 id="toc_13">计数器</h3>

<p>数据统计的需求非常普遍，通过原子递增保持计数。例如，点赞数、收藏数、分享数等。</p>

<h3 id="toc_14">排行榜</h3>

<p>排行榜按照得分进行排序，例如，展示最近、最热、点击率最高、活跃度最高等等条件的top list。</p>

<h3 id="toc_15">用于存储时间戳</h3>

<p>类似排行榜，使用redis的zset用于存储时间戳，时间会不断变化。例如，按照用户关注用户的最新动态列表。</p>

<h3 id="toc_16">记录用户判定信息</h3>

<p>记录用户判定信息的需求也非常普遍，可以知道一个用户是否进行了某个操作。例如，用户是否点赞、用户是否收藏、用户是否分享等。</p>

<h3 id="toc_17">社交列表</h3>

<p>社交属性相关的列表信息，例如，用户点赞列表、用户收藏列表、用户关注列表等。</p>

<h3 id="toc_18">队列</h3>

<p>Redis能作为一个很好的消息队列来使用，通过list的lpop及lpush接口进行队列的写入和消费，本身性能较好能解决大部分问题。但是，不提倡使用，更加建议使用rabbitmq等服务，作为消息中间件。</p>

<h3 id="toc_19">会话缓存</h3>

<p>使用Redis进行会话缓存。例如，将web session存放在Redis中。</p>

<h2 id="toc_20">Redis安装与启动</h2>

<h3 id="toc_21">Redis安装(mac&amp;linux)</h3>

<pre class="line-numbers"><code class="language-text">$ wget http://download.redis.io/releases/redis-4.0.8.tar.gz
$ tar xzf redis-4.0.8.tar.gz
$ cd redis-4.0.8
$ make
</code></pre>

<h3 id="toc_22">Redis可执行文件说明</h3>

<table>
<thead>
<tr>
<th style="text-align: center">命令名</th>
<th style="text-align: center">命令说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">redis-server</td>
<td style="text-align: center">redis服务器</td>
</tr>
<tr>
<td style="text-align: center">redis-cli</td>
<td style="text-align: center">redis命令行客户端</td>
</tr>
<tr>
<td style="text-align: center">redis-benchmark</td>
<td style="text-align: center">redis性能测试工具</td>
</tr>
<tr>
<td style="text-align: center">redis-check-aof</td>
<td style="text-align: center">aof文件修复工具</td>
</tr>
<tr>
<td style="text-align: center">redis-check-dump</td>
<td style="text-align: center">RDB文件检查工具</td>
</tr>
<tr>
<td style="text-align: center">redis-sentinel</td>
<td style="text-align: center">sentinel服务器(2.8以后)</td>
</tr>
</tbody>
</table>

<h3 id="toc_23">Redis三种启动方式</h3>

<h4 id="toc_24">最简启动(采用默认配置文件启动）</h4>

<pre class="line-numbers"><code class="language-text">redis-server
</code></pre>

<p><strong>验证</strong></p>

<pre class="line-numbers"><code class="language-text">ps aux | grep redis
redis-cli -h 127.0.0.1 -p 6379 ping 
</code></pre>

<h4 id="toc_25">配置文件启动 (将需要配置的参数写入文件）</h4>

<pre class="line-numbers"><code class="language-text">redis-server configPath
</code></pre>

<h4 id="toc_26">动态参数启动</h4>

<pre class="line-numbers"><code class="language-text">redis-server --port 6380
</code></pre>

<h4 id="toc_27">三种启动方式比较</h4>

<ul>
<li>生产环境选择配置启动</li>
<li>单机多实例配置文件可以用端口区分开</li>
</ul>

<h3 id="toc_28">Redis客户端连接</h3>

<pre class="line-numbers"><code class="language-text">redis-cli -h 127.0.0.1 -p 6379
</code></pre>

<h3 id="toc_29">Redis常用配置</h3>

<table>
<thead>
<tr>
<th style="text-align: center">配置名</th>
<th style="text-align: center">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">daemonize yes</td>
<td style="text-align: center">是否以后台进程&lt;守护进程&gt;运行</td>
</tr>
<tr>
<td style="text-align: center">port 6379</td>
<td style="text-align: center">redis对外端口号,默认访问地址 6379</td>
</tr>
<tr>
<td style="text-align: center">logfile</td>
<td style="text-align: center">redis系统日志</td>
</tr>
<tr>
<td style="text-align: center">dir ./.</td>
<td style="text-align: center">redis工作目录,存储数据的文件所在路径</td>
</tr>
<tr>
<td style="text-align: center">dbfilename dump.rdb</td>
<td style="text-align: center">存储数据的文件</td>
</tr>
<tr>
<td style="text-align: center">bind 127.0.0.1</td>
<td style="text-align: center">绑定ip地址，远程访问请注释</td>
</tr>
</tbody>
</table>

<h3 id="toc_30">Redis安装启动(配置文件方式)</h3>

<h4 id="toc_31">配置方式</h4>

<h5 id="toc_32">配置文件</h5>

<pre class="line-numbers"><code class="language-text">vim redis-6382.conf

port 6382
daemonize yes
logfile &quot;6382.log&quot;
dir ./workdata/
</code></pre>

<h5 id="toc_33">启动</h5>

<pre class="line-numbers"><code class="language-text">redis-server redis-6382.conf 
</code></pre>

<h5 id="toc_34">检查</h5>

<pre class="line-numbers"><code class="language-text">ps -aux | grep -v redis-server | grep 6382
</code></pre>

<h5 id="toc_35">日志文件</h5>

<pre class="line-numbers"><code class="language-text">vim workdata/6382.log
</code></pre>

<h5 id="toc_36">启动和关闭Redis服务</h5>

<pre class="line-numbers"><code class="language-text">#启动redis服务
./redis-server redis.conf 

#查看redis服务进程 是否启动成功
ps -ef | grep redis
ps -A | grep redis

#redis客户端启动
redis-cli

#关闭redis服务
ps -A | grep redis
</code></pre>

<h2 id="toc_37">API理解与使用</h2>

<h3 id="toc_38">通用命令</h3>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">时间复杂度</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">keys [pattern]</td>
<td style="text-align: left">遍历所有key</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">dbsize</td>
<td style="text-align: left">遍历所有key</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">exists</td>
<td style="text-align: left">检查key是否存在</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">del [key]</td>
<td style="text-align: left">删除指定的key-value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">expire [key] seconds</td>
<td style="text-align: left">key在seconds秒后过期</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">ttl [key]</td>
<td style="text-align: left">查看key剩余的过期时间</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">persist [key]</td>
<td style="text-align: left">去掉key的过期时间</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">type [key]</td>
<td style="text-align: left">返回key的类型</td>
<td style="text-align: left">O(1)</td>
</tr>
</tbody>
</table>

<p><strong>注意</strong> keys命令一般不再生产环境使用</p>

<pre class="line-numbers"><code class="language-text">redis-4.0.8 redis-cli -h 127.0.0.1 -p 6382
127.0.0.1:6382&gt; set hello word
OK
127.0.0.1:6382&gt; set php good
OK
127.0.0.1:6382&gt; set java best
OK
127.0.0.1:6382&gt; keys *
1) &quot;java&quot;
2) &quot;hello&quot;
3) &quot;php&quot;
127.0.0.1:6382&gt; dbsize
(integer) 3
127.0.0.1:6382&gt; exists php
(integer) 1
127.0.0.1:6382&gt; del php java
(integer) 2
127.0.0.1:6382&gt; keys *
1) &quot;hello&quot;
127.0.0.1:6382&gt; expire hello 20
(integer) 1
127.0.0.1:6382&gt; ttl hello
(integer) 16
127.0.0.1:6382&gt; ttl hello
(integer) 12
127.0.0.1:6382&gt; persist hello
(integer) 1
127.0.0.1:6382&gt; ttl hello
(integer) -1
127.0.0.1:6382&gt; type hello
string
</code></pre>

<h3 id="toc_39">单线程</h3>

<h4 id="toc_40">定义</h4>

<blockquote>
<p>单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。</p>
</blockquote>

<h4 id="toc_41">单线程为什么这么快</h4>

<ul>
<li>纯内存</li>
<li>非阻塞IO</li>
<li>避免线程切换和竞态消耗</li>
</ul>

<h4 id="toc_42">使用单线程要注意什么</h4>

<ul>
<li>一次只能运行一条命令</li>
<li>拒绝长（慢）命令
<ul>
<li>keys</li>
<li>flushall</li>
<li>flushdb</li>
<li>slow lua script</li>
<li>mutil/exec</li>
<li>operate big value(collection)</li>
</ul></li>
</ul>

<h3 id="toc_43">String</h3>

<h4 id="toc_44">结构</h4>

<p>可以是字符串（json);数字，以及二进制</p>

<h4 id="toc_45">使用场景</h4>

<ul>
<li>缓存</li>
<li>计数器</li>
<li>分布式锁</li>
</ul>

<h4 id="toc_46">API</h4>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">时间复杂度</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">get [key]</td>
<td style="text-align: left">获取key对应的value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">set [key] [value]</td>
<td style="text-align: left">设置key value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">del [key]</td>
<td style="text-align: left">删除key-value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">incr</td>
<td style="text-align: left">key自增1， 如果key不存在，自增后get(key) = 1</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">decr</td>
<td style="text-align: left">key自减1， 如果key不存在，自增后get(key) = -1</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">incrby [key] k</td>
<td style="text-align: left">key自增k， 如果key不存在，自增后get(key) = k</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">decr [key] k</td>
<td style="text-align: left">key自减k， 如果key不存在，自增后get(key) = -k</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">set [key] [value]</td>
<td style="text-align: left">不管可以是否存在</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">setnx [key] [value]</td>
<td style="text-align: left">key不存在，才设置</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">set [key] [value] xx</td>
<td style="text-align: left">key存在，才设置</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">mget [key1] [key2] [key3]</td>
<td style="text-align: left">批量获取key，原子操作</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">mset [key1] [value1] [key2] [value2]</td>
<td style="text-align: left">批量设置key-value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">getset [key] [newvalue]</td>
<td style="text-align: left">set key newvalue并返回旧的value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">append [key] [value]</td>
<td style="text-align: left">将value追加到旧的value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">strlen [key]</td>
<td style="text-align: left">返回字符串的长度（注意中文，utf8下一个中文占用3个字符）</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">incrbyfloat [key] 3.5</td>
<td style="text-align: left">增加key对应的值3.5</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">getrange [key] [start] [end]</td>
<td style="text-align: left">获取字符串指定下标所有的值</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">setrange [key] [index] [value]</td>
<td style="text-align: left">设置指定下标所有对应的值</td>
<td style="text-align: left">O(1)</td>
</tr>
</tbody>
</table>

<h4 id="toc_47">练习</h4>

<pre class="line-numbers"><code class="language-text">127.0.0.1:6382&gt; set hello &quot;world&quot;
OK
127.0.0.1:6382&gt; get hell
(nil)
127.0.0.1:6382&gt; get hello
&quot;world&quot;
127.0.0.1:6382&gt; del hello
(integer) 1
127.0.0.1:6382&gt; get hello
(nil)
127.0.0.1:6382&gt; get counter
(nil)
127.0.0.1:6382&gt; incr counter
(integer) 1
127.0.0.1:6382&gt; get counter
&quot;1&quot;
127.0.0.1:6382&gt; incrby counter 99
(integer) 100
127.0.0.1:6382&gt; get counter 
&quot;100&quot;
127.0.0.1:6382&gt; decr counter
(integer) 99
127.0.0.1:6382&gt; get counter
&quot;99&quot;
127.0.0.1:6382&gt; decrby counter 100
(integer) -1
127.0.0.1:6382&gt; get counter
&quot;-1&quot;
127.0.0.1:6382&gt; exists php
(integer) 0
127.0.0.1:6382&gt; set php good
OK
127.0.0.1:6382&gt; setnx php bad
(integer) 0
127.0.0.1:6382&gt; set php best xx
OK
127.0.0.1:6382&gt; get php
&quot;best&quot;
127.0.0.1:6382&gt; exists java
(integer) 0
127.0.0.1:6382&gt; setnx java best
(integer) 1
127.0.0.1:6382&gt; set java easy xx
OK
127.0.0.1:6382&gt; get java
&quot;easy&quot;
127.0.0.1:6382&gt; set hello world
OK
127.0.0.1:6382&gt; getset hello php
&quot;world&quot;
127.0.0.1:6382&gt; get hello
&quot;php&quot;
127.0.0.1:6382&gt; append hell &quot;,php&quot;
(integer) 4
127.0.0.1:6382&gt; get hello
&quot;php&quot;
127.0.0.1:6382&gt; append hello &quot;,php&quot;
(integer) 7
127.0.0.1:6382&gt; get hello
&quot;php,php&quot;
127.0.0.1:6382&gt; strlen hello
(integer) 7
127.0.0.1:6382&gt; set hello &quot;吴军旗&quot;
OK
127.0.0.1:6382&gt; strlen hello
(integer) 9
</code></pre>

<p><strong>n次get操作</strong><br/>
<figure><img src="media/15586033218679/15586134618087.jpg" alt=""/></figure><br/>
<strong>1次mget操作</strong><br/>
<figure><img src="media/15586033218679/15586134797648.jpg" alt=""/></figure></p>

<h4 id="toc_48">实战</h4>

<ul>
<li>记录网站每个用户个人主页的访问量</li>
</ul>

<pre class="line-numbers"><code class="language-redis">incr userid: pageview (**主要的是：单线程，所以无竞争）**）
</code></pre>

<ul>
<li>缓存视频的基本信息（数据源在mysql中)伪代码</li>
</ul>

<p><figure><img src="media/15586033218679/15586135558230.jpg" alt=""/></figure></p>

<ul>
<li>分布式id生成器（单线程的好处）</li>
</ul>

<p><figure><img src="media/15586033218679/15586135727820.jpg" alt=""/></figure></p>

<pre class="line-numbers"><code class="language-redis">incr id
</code></pre>

<h3 id="toc_49">Hash</h3>

<h4 id="toc_50">哈希键值结构</h4>

<p><figure><img src="media/15586033218679/15586136177348.jpg" alt=""/></figure></p>

<h4 id="toc_51">特点</h4>

<ul>
<li>mapmap</li>
<li>small redis</li>
<li>field不能相同，value可以相同</li>
</ul>

<h4 id="toc_52">API</h4>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">时间复杂度</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">hget [key] [field]</td>
<td style="text-align: left">获取hash key对应field的value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">hset [key] [field] [value]</td>
<td style="text-align: left">设置has key 对应的field的value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">hexists [key] [field]</td>
<td style="text-align: left">判断hash key 是否有field</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">hlen [key]</td>
<td style="text-align: left">获取hash key field的数量</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">hmget [key] [field1] [field2...fieldN]</td>
<td style="text-align: left">批量获取hash key的一批field对应的值</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">hset [key] [field1] [value1] [field2] [value2...fieldN] [valueN]</td>
<td style="text-align: left">批量设置hash key的一批field value</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">hgetall [key]</td>
<td style="text-align: left">返回hash key对应所有的field和value</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">hvals [key]</td>
<td style="text-align: left">返回hash key对应所有的field的value</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">hkeys [key]</td>
<td style="text-align: left">返回hash key对应所有的field</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">hsetnx [key] [field] [value]</td>
<td style="text-align: left">设置has key 对应的field的value(如果field已经存在，则失败）</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">hincrby [key] [field] [intCounter]</td>
<td style="text-align: left">hash key对应的field的value自增intCounter</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">hincrbyfloat [key] [field] [floatCounter]</td>
<td style="text-align: left">浮点数版本</td>
<td style="text-align: left">O(1)</td>
</tr>
</tbody>
</table>

<p><strong>注意</strong> 小心使用hgetall（牢记单线程）</p>

<h4 id="toc_53">练习</h4>

<pre class="line-numbers"><code class="language-redis">127.0.0.1:6382&gt; hset user1 age 26
(integer) 1
127.0.0.1:6382&gt; hset user1 name wujunqi
(integer) 1
127.0.0.1:6382&gt; hget all user1
(nil)
127.0.0.1:6382&gt; hgetall user1
1) &quot;age&quot;
2) &quot;26&quot;
3) &quot;name&quot;
4) &quot;wujunqi&quot;
127.0.0.1:6382&gt; hdel user1 age
(integer) 1
127.0.0.1:6382&gt; hgetall user1
1) &quot;name&quot;
2) &quot;wujunqi&quot;
127.0.0.1:6382&gt; hget user1 name
&quot;wujunqi&quot;
127.0.0.1:6382&gt; hexists user1 name
(integer) 1
127.0.0.1:6382&gt; hlen user1
(integer) 1
127.0.0.1:6382&gt; hmset user2 name xiaofang age 26
OK
127.0.0.1:6382&gt; hmget user2 name age
1) &quot;xiaofang&quot;
2) &quot;26&quot;
127.0.0.1:6382&gt; hgetall user2
1) &quot;name&quot;
2) &quot;xiaofang&quot;
3) &quot;age&quot;
4) &quot;26&quot;
127.0.0.1:6382&gt; hvals user2
1) &quot;xiaofang&quot;
2) &quot;26&quot;
127.0.0.1:6382&gt; hkeys user2
1) &quot;name&quot;
2) &quot;age&quot;
127.0.0.1:6382&gt; hincrby user age 2
(integer) 2
127.0.0.1:6382&gt; hgetall user2
1) &quot;name&quot;
2) &quot;xiaofang&quot;
3) &quot;age&quot;
4) &quot;26&quot;
127.0.0.1:6382&gt; hincrby user2 age 2
(integer) 28
127.0.0.1:6382&gt; hgetall user2
1) &quot;name&quot;
2) &quot;xiaofang&quot;
3) &quot;age&quot;
4) &quot;28&quot;
127.0.0.1:6382&gt; hincrbyfloat user2 age 2.0
&quot;30&quot;
127.0.0.1:6382&gt; hincrbyfloat user2 age 2.5
&quot;32.5&quot;
127.0.0.1:6382&gt; hgetall user2
1) &quot;name&quot;
2) &quot;xiaofang&quot;
3) &quot;age&quot;
4) &quot;32.5&quot;
</code></pre>

<h3 id="toc_54">List</h3>

<h4 id="toc_55">列表结构</h4>

<p><figure><img src="media/15586033218679/15586139967130.jpg" alt=""/></figure></p>

<h4 id="toc_56">特点</h4>

<ul>
<li>有序</li>
<li>可以重复</li>
<li>左右两边插入弹出</li>
</ul>

<h4 id="toc_57">API</h4>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">时间复杂度</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">rpush [key] [value1 value2...valueN]</td>
<td style="text-align: left">从列表右边插入（1-N）个</td>
<td style="text-align: left">O(1-N)</td>
</tr>
<tr>
<td style="text-align: left">lpush [key] [value1 value2...valueN]</td>
<td style="text-align: left">从列表左边插入（1-N）个</td>
<td style="text-align: left">O(1-N)</td>
</tr>
<tr>
<td style="text-align: left">linsert [key] before/after [value] [newValue]</td>
<td style="text-align: left">在list指定的值前、后插入newValue</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">lpop key</td>
<td style="text-align: left">从列表左侧弹出一个item</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">rpop key</td>
<td style="text-align: left">从列表右侧弹出一个item</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">lrem key count value</td>
<td style="text-align: left">(1)count&gt;0,从左到右，删除最多count个value相等的项;(2)count&lt;0,从右到左，删除最多count个value相等的项;(3)count=0,从右到左，删除所有value相等的项;</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">ltrim key start end</td>
<td style="text-align: left">按照索引范围修剪列表</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">lindex key start end(包含end)</td>
<td style="text-align: left">获取列表指定索引范围所有item</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">lindex key index</td>
<td style="text-align: left">获取列表指定索引的item</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">llen key</td>
<td style="text-align: left">获取列表长度</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">lset key index newValue</td>
<td style="text-align: left">设置列表指定索引值为newValue</td>
<td style="text-align: left">O(N)</td>
</tr>
<tr>
<td style="text-align: left">blpop key timeout</td>
<td style="text-align: left">lpop阻塞版本，timeout是阻塞超时时间，timeout=0为永远阻塞</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">broop key timeout</td>
<td style="text-align: left">rpop阻塞版本，timeout是阻塞超时时间，timeout=0为永远阻塞</td>
<td style="text-align: left">O(1)</td>
</tr>
</tbody>
</table>

<h4 id="toc_58">练习</h4>

<pre class="line-numbers"><code class="language-redis">127.0.0.1:6382&gt; rpush list1 a b c d
(integer) 4
127.0.0.1:6382&gt; lpush list1 e f g h i
(integer) 9
127.0.0.1:6382&gt; lrange list1 0 -1
1) &quot;i&quot;
2) &quot;h&quot;
3) &quot;g&quot;
4) &quot;f&quot;
5) &quot;e&quot;
6) &quot;a&quot;
7) &quot;b&quot;
8) &quot;c&quot;
9) &quot;d&quot;
127.0.0.1:6382&gt; linsert list1 before i wu
(integer) 10
127.0.0.1:6382&gt; lrange list1 0 -1
 1) &quot;wu&quot;
 2) &quot;i&quot;
 3) &quot;h&quot;
 4) &quot;g&quot;
 5) &quot;f&quot;
 6) &quot;e&quot;
 7) &quot;a&quot;
 8) &quot;b&quot;
 9) &quot;c&quot;
10) &quot;d&quot;
127.0.0.1:6382&gt; linsert list1 after i jun
(integer) 11
127.0.0.1:6382&gt; lrange list1 0 -1
 1) &quot;wu&quot;
 2) &quot;i&quot;
 3) &quot;jun&quot;
 4) &quot;h&quot;
 5) &quot;g&quot;
 6) &quot;f&quot;
 7) &quot;e&quot;
 8) &quot;a&quot;
 9) &quot;b&quot;
10) &quot;c&quot;
11) &quot;d&quot;
127.0.0.1:6382&gt; lpop list1
&quot;wu&quot;
127.0.0.1:6382&gt; rpop list1
&quot;d&quot;
127.0.0.1:6382&gt; lrange list1 0 -1
1) &quot;i&quot;
2) &quot;jun&quot;
3) &quot;h&quot;
4) &quot;g&quot;
5) &quot;f&quot;
6) &quot;e&quot;
7) &quot;a&quot;
8) &quot;b&quot;
9) &quot;c&quot;
127.0.0.1:6382&gt; lrem list1 1 i
(integer) 1
127.0.0.1:6382&gt; lrange list1 0 -1
1) &quot;jun&quot;
2) &quot;h&quot;
3) &quot;g&quot;
4) &quot;f&quot;
5) &quot;e&quot;
6) &quot;a&quot;
7) &quot;b&quot;
8) &quot;c&quot;
127.0.0.1:6382&gt; rpush list1 c c c c c
(integer) 13
127.0.0.1:6382&gt; ltrem list1 -3 c
(error) ERR unknown command &#39;ltrem&#39;
127.0.0.1:6382&gt; lrem list1 -3 c
(integer) 3
127.0.0.1:6382&gt; lrange list1 0 -1
 1) &quot;jun&quot;
 2) &quot;h&quot;
 3) &quot;g&quot;
 4) &quot;f&quot;
 5) &quot;e&quot;
 6) &quot;a&quot;
 7) &quot;b&quot;
 8) &quot;c&quot;
 9) &quot;c&quot;
10) &quot;c&quot;
127.0.0.1:6382&gt; lindex list 0
(nil)
127.0.0.1:6382&gt; lindex list1 0
&quot;jun&quot;
127.0.0.1:6382&gt; llen list1
(integer) 10
127.0.0.1:6382&gt; lset list 0 wu
(error) ERR no such key
127.0.0.1:6382&gt; lset list1 0 wu
OK
127.0.0.1:6382&gt; lrange list1 0 -1
 1) &quot;wu&quot;
 2) &quot;h&quot;
 3) &quot;g&quot;
 4) &quot;f&quot;
 5) &quot;e&quot;
 6) &quot;a&quot;
 7) &quot;b&quot;
 8) &quot;c&quot;
 9) &quot;c&quot;
10) &quot;c&quot;
</code></pre>

<h4 id="toc_59">应用</h4>

<p><figure><img src="media/15586033218679/15586150101651.jpg" alt=""/></figure></p>

<p><figure><img src="media/15586033218679/15586149963862.jpg" alt=""/></figure></p>

<h3 id="toc_60">Set</h3>

<h4 id="toc_61">定义</h4>

<blockquote>
<p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p>
</blockquote>

<h4 id="toc_62">特点</h4>

<ul>
<li>无序</li>
<li>无重复</li>
<li>集合间操作</li>
</ul>

<h4 id="toc_63">API</h4>

<ul>
<li>集合内的操作</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">时间复杂度</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">sadd key element</td>
<td style="text-align: left">向集合key添加element(如果element已经存在，添加失败）</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">srem key element</td>
<td style="text-align: left">将集合key中的element移除掉</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">scard key</td>
<td style="text-align: left">计算集合大小</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">sismember key element</td>
<td style="text-align: left">判断element 是否在集合中</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">srandmember key count</td>
<td style="text-align: left">从集合中随机挑count个元素</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">spop key</td>
<td style="text-align: left">从集合中随机弹出一个元素</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">smembers key</td>
<td style="text-align: left">获取集合所有元素</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">srem key element</td>
<td style="text-align: left">将集合key中的element移除掉</td>
<td style="text-align: left">O(1)</td>
</tr>
</tbody>
</table>

<ul>
<li>集合间的操作</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">时间复杂度</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">sdiff key1 key2</td>
<td style="text-align: left">差集</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">sinter key1 key2</td>
<td style="text-align: left">交集</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">sunion key1 key2</td>
<td style="text-align: left">并集</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">sidff/sinter/suion + store destkey</td>
<td style="text-align: left">将差集、交集、并集保存在destkey中</td>
<td style="text-align: left">O(1)</td>
</tr>
</tbody>
</table>

<p><strong>注意</strong></p>

<ul>
<li>srandmember不会破坏集合</li>
<li>spop会破会</li>
<li>smembers 返回的是无序集合，并且要注意量很大的时候回阻塞</li>
</ul>

<h4 id="toc_64">练习</h4>

<pre class="line-numbers"><code class="language-redis">127.0.0.1:6382&gt; sadd set1 a b c d 
(integer) 4
127.0.0.1:6382&gt; srem set1 a
(integer) 1
127.0.0.1:6382&gt; smembers set1
1) &quot;d&quot;
2) &quot;c&quot;
3) &quot;b&quot;
127.0.0.1:6382&gt; scard set1
(integer) 3
127.0.0.1:6382&gt; sismember set1 d
(integer) 1
127.0.0.1:6382&gt; srandmember set1 2
1) &quot;d&quot;
2) &quot;b&quot;
127.0.0.1:6382&gt; srandmember set1 2
1) &quot;b&quot;
2) &quot;c&quot;
127.0.0.1:6382&gt; spop set1
&quot;c&quot;
127.0.0.1:6382&gt; smembers set1
1) &quot;d&quot;
2) &quot;b&quot;
127.0.0.1:6382&gt; srem set1 d
(integer) 1
127.0.0.1:6382&gt; smembers set1
1) &quot;b&quot;
127.0.0.1:6382&gt; sadd set1 1 2 3 4 5
(integer) 5
127.0.0.1:6382&gt; sadd set2 a b c 12 8 9 1 2 
(integer) 8
127.0.0.1:6382&gt; sdiff set1 set2
1) &quot;3&quot;
2) &quot;4&quot;
3) &quot;5&quot;
127.0.0.1:6382&gt; sinter set1 set2
1) &quot;2&quot;
2) &quot;b&quot;
3) &quot;1&quot;
127.0.0.1:6382&gt; sunion set1 set2
 1) &quot;5&quot;
 2) &quot;2&quot;
 3) &quot;4&quot;
 4) &quot;1&quot;
 5) &quot;a&quot;
 6) &quot;8&quot;
 7) &quot;3&quot;
 8) &quot;b&quot;
 9) &quot;9&quot;
10) &quot;12&quot;
11) &quot;c&quot;
127.0.0.1:6382&gt; 
</code></pre>

<h4 id="toc_65">实战</h4>

<ul>
<li>抽奖系统， 用spop</li>
</ul>

<p><figure><img src="media/15586033218679/15586153311831.jpg" alt=""/></figure></p>

<ul>
<li>赞过的文章，收藏过的文章等</li>
</ul>

<p><figure><img src="media/15586033218679/15586153559735.jpg" alt=""/></figure></p>

<ul>
<li>标签</li>
</ul>

<p><figure><img src="media/15586033218679/15586153700013.jpg" alt=""/></figure></p>

<ul>
<li>共同关注</li>
</ul>

<h3 id="toc_66">Zset</h3>

<h4 id="toc_67">定义</h4>

<blockquote>
<p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>
</blockquote>

<h4 id="toc_68">API</h4>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">时间复杂度</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">zadd key score element</td>
<td style="text-align: left">添加score和element</td>
<td style="text-align: left">O(logN)</td>
</tr>
<tr>
<td style="text-align: left">zrem key element(可以是多个)</td>
<td style="text-align: left">将集合key中的element移除掉</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">zscore key element</td>
<td style="text-align: left">返回元素的分数</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">zincrby key increScore element</td>
<td style="text-align: left">增加或减少元素的分数</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">zcard key</td>
<td style="text-align: left">返回元素的总个数</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">zrank(zrevrank) key member</td>
<td style="text-align: left">返回元素的排名</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">zrange(zrevrank) key start end [WITHSCORES]</td>
<td style="text-align: left">返回指定索引范围内的升序元素[分值]</td>
<td style="text-align: left">O(logN + m)</td>
</tr>
<tr>
<td style="text-align: left">zrangebyscore(zrevrangebyscore) key minScore maxScore</td>
<td style="text-align: left">返回指定分数范围内的升序元素</td>
<td style="text-align: left">O(logN + m)</td>
</tr>
<tr>
<td style="text-align: left">zcount key minScore maxScore</td>
<td style="text-align: left">返回有序集合内在指定分数范围内的个数</td>
<td style="text-align: left">O(logN + m)</td>
</tr>
<tr>
<td style="text-align: left">zremrangebyrank key start end</td>
<td style="text-align: left">删除指定排名内的升序元素</td>
<td style="text-align: left">O(logN + m)</td>
</tr>
<tr>
<td style="text-align: left">zremrangebyscore key minScore maxScore</td>
<td style="text-align: left">删除指定分数内的升序元素</td>
<td style="text-align: left">O(logN + m)</td>
</tr>
<tr>
<td style="text-align: left">ZINTERSTORE destination numkeys(表示key的个数) key [key ...]</td>
<td style="text-align: left">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
<td style="text-align: left"></td>
</tr>
<tr>
<td style="text-align: left">ZUNIONSTORE destination numkeys key [key ...]</td>
<td style="text-align: left">计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
<td style="text-align: left"></td>
</tr>
</tbody>
</table>

<h4 id="toc_69">实战</h4>

<ul>
<li>各种榜单（score:timestamp, saleCount, followCount)</li>
</ul>

<p><figure><img src="media/15586033218679/15586156365859.jpg" alt=""/></figure></p>

<h2 id="toc_70">Redis客户端的使用</h2>

<p>推荐一款Mac的Redis客户端-Medis<br/>
Medis是基于electron开发的免费开源的Redis桌面客户端，在Mac上相比于Redis Desktop Manager软件安装简单，运行稳定，很少出现崩溃重启的现象，最重要的是免费。</p>

<p><strong>相关信息：</strong><br/>
代码地址：<a href="https://github.com/luin/medis">https://github.com/luin/medis</a><br/>
安装步骤：</p>

<pre class="line-numbers"><code class="language-命令行">$ git clone https://github.com/luin/medis
$ cd medis
$ npm install
$ npm run build
$ npm start
</code></pre>

<p>具体请参考官方说明文档。</p>

<h2 id="toc_71">Redis的其他功能</h2>

<h3 id="toc_72">慢查询</h3>

<h4 id="toc_73">生命周期</h4>

<p><figure><img src="media/15586033218679/15586158155873.jpg" alt=""/></figure></p>

<p><strong>两点说明</strong><br/>
慢查询发生在第3阶段<br/>
客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</p>

<h4 id="toc_74">两个配置</h4>

<ul>
<li>slowlog-max-len</li>
</ul>

<p><figure><img src="media/15586033218679/15586158819171.jpg" alt=""/></figure></p>

<ul>
<li>slowlog-log-slower-than</li>
</ul>

<p><figure><img src="media/15586033218679/15586159001113.jpg" alt=""/></figure></p>

<h4 id="toc_75">如何配置</h4>

<p><figure><img src="media/15586033218679/15586159228093.jpg" alt=""/></figure></p>

<h4 id="toc_76">慢查询命令</h4>

<ul>
<li>slowlog get [n] : 获取慢查询队列</li>
<li>slowlog len: 获取慢查询队列长度</li>
<li>slowlog reset: 清空慢查询队列</li>
</ul>

<h4 id="toc_77">运维经验</h4>

<p><figure><img src="media/15586033218679/15586159537971.jpg" alt=""/></figure></p>

<h3 id="toc_78">pipeline:流水线</h3>

<h4 id="toc_79">流水线</h4>

<ul>
<li>1次网络命令通信模型</li>
</ul>

<p><figure><img src="media/15586033218679/15586160103077.jpg" alt=""/></figure></p>

<ul>
<li>批量网络命令通信模型</li>
</ul>

<p><figure><img src="media/15586033218679/15586160280674.jpg" alt=""/></figure></p>

<h5 id="toc_80">什么是流水线</h5>

<p><figure><img src="media/15586033218679/15586160642195.jpg" alt=""/></figure></p>

<h5 id="toc_81">流水线的作用</h5>

<p><figure><img src="media/15586033218679/15586160789961.jpg" alt=""/></figure></p>

<h5 id="toc_82">两点注意</h5>

<ul>
<li>redis的命令时间是微秒级别</li>
<li>pipeline每次条数要控制（网络）</li>
</ul>

<h5 id="toc_83">与原生操作对比</h5>

<ul>
<li>M操作</li>
</ul>

<p><figure><img src="media/15586033218679/15586161168132.jpg" alt=""/></figure></p>

<ul>
<li>pipeline</li>
</ul>

<p><figure><img src="media/15586033218679/15586161287952.jpg" alt=""/></figure></p>

<h5 id="toc_84">使用建议</h5>

<ul>
<li>注意每次pipeline携带数据量</li>
<li>pipeline每次只能作用在一个redis节点上</li>
<li>M操作与pipeline区别</li>
</ul>

<h3 id="toc_85">发布订阅</h3>

<h4 id="toc_86">角色</h4>

<ul>
<li>发布者</li>
<li>订阅者</li>
<li><p>频道</p></li>
<li><p>发布者不是计划发送消息给特定的接收者（订阅者），而是发布的消息分到不同的频道，不需要知道什么样的订阅者订阅</p></li>
<li><p>订阅者对一个或多个频道感兴趣，只需接收感兴趣的消息，不需要知道什么样的发布者发布的</p></li>
<li><p>发布者和订阅者的解耦合可以带来更大的扩展性和更加动态的网络拓扑</p></li>
<li><p>客户端发到频道的消息，将会被推送到所有订阅此频道的客户端</p></li>
<li><p>客户端不需要主动去获取消息，只需要订阅频道，这个频道的内容就会被推送过来</p></li>
</ul>

<h4 id="toc_87">模型</h4>

<p><figure><img src="media/15586033218679/15586161795781.jpg" alt=""/></figure><br/>
<figure><img src="media/15586033218679/15586161854467.jpg" alt=""/></figure></p>

<h4 id="toc_88">消息的格式</h4>

<p>推送消息的格式包含三部分</p>

<ul>
<li>part1:消息类型，包含三种类型
<ul>
<li>subscribe，表示订阅成功</li>
<li>unsubscribe，表示取消订阅成功</li>
<li>message，表示其它终端发布消息</li>
</ul></li>
<li>如果第一部分的值为subscribe，则第二部分是频道，第三部分是现在订阅的频道的数量</li>
<li>如果第一部分的值为unsubscribe，则第二部分是频道，第三部分是现在订阅的频道的数量，如果为0则表示当前没有订阅任何频道，当在Pub/Sub以外状态，客户端可以发出任何redis命令</li>
<li>如果第一部分的值为message，则第二部分是来源频道的名称，第三部分是消息的内容</li>
</ul>

<pre class="line-numbers"><code class="language-text"> subscribe 频道名称 [频道名称]：订阅多个频道
 unsubscribe  频道名称 [频道名称]：取消多个频道的订阅
 publish 频道 消息：向指定的频道推送消息
</code></pre>

<h4 id="toc_89">API</h4>

<ul>
<li>publish channel message</li>
<li>subscribe [channel] 一个或者多个</li>
<li>unsubscribe [channel] 一个或者多个</li>
</ul>

<h4 id="toc_90">练习</h4>

<pre class="line-numbers"><code class="language-redis">127.0.0.1:6382&gt; publish weibomovie &quot;hello world&quot;
(integer) 1
127.0.0.1:6382&gt; publish weibomovie &quot;hello world2&quot;
(integer) 1
</code></pre>

<p>复制代码另外一个cli</p>

<pre class="line-numbers"><code class="language-redis">127.0.0.1:6382&gt; SUBSCRIBE weibomovie
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;weibomovie&quot;
3) (integer) 1
1) &quot;message&quot;
2) &quot;weibomovie&quot;
3) &quot;hello world&quot;
1) &quot;message&quot;
2) &quot;weibomovie&quot;
3) &quot;hello world2&quot;
</code></pre>

<h4 id="toc_91">发布订阅与消息队列</h4>

<p><figure><img src="media/15586033218679/15586162746404.jpg" alt=""/></figure></p>

<h3 id="toc_92">Bitmap</h3>

<h4 id="toc_93">位图</h4>

<p><figure><img src="media/15586033218679/15586162996347.jpg" alt=""/></figure><br/>
<figure><img src="media/15586033218679/15586163055536.jpg" alt=""/></figure></p>

<h4 id="toc_94">API</h4>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
<th style="text-align: left">时间复杂度</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">setbit key offset value</td>
<td style="text-align: left">给位图指定索引设置值</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">getbit key offset</td>
<td style="text-align: left">获取位图指定索引的值</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">bitcount key start end</td>
<td style="text-align: left">获取位图指定范围（start 到end，单位为字节，如果不指定就获取全部）位值为1的个数</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">bitop op destkey key [key...]</td>
<td style="text-align: left">做多个bitmap的and，or，not，xor操作并将结果保存在destkey中</td>
<td style="text-align: left">O(1)</td>
</tr>
<tr>
<td style="text-align: left">bitpos key targetBit [start][end</td>
<td style="text-align: left">计算位图指定范围（start到end，单位为字节，如果不指定就是获取全部）第一个偏移量对应的值等于targetBit的位置</td>
<td style="text-align: left">O(1)</td>
</tr>
</tbody>
</table>

<h5 id="toc_95">练习</h5>

<pre class="line-numbers"><code class="language-redis">127.0.0.1:6382&gt; set hello big
OK
127.0.0.1:6382&gt; getbit hello 
(error) ERR wrong number of arguments for &#39;getbit&#39; command
127.0.0.1:6382&gt; getbit hello 0
(integer) 0
127.0.0.1:6382&gt; setbit hello 0 1
(integer) 0
127.0.0.1:6382&gt; get hello
&quot;\xe2ig&quot;
127.0.0.1:6382&gt; set hell a
OK
127.0.0.1:6382&gt; bitcount hell
(integer) 3
127.0.0.1:6382&gt; bitop and hell hello
(integer) 3
127.0.0.1:6382&gt; set a a
OK
127.0.0.1:6382&gt; set b b
OK
127.0.0.1:6382&gt; bitop and c a b
(integer) 1
127.0.0.1:6382&gt; get c
&quot;`&quot;
127.0.0.1:6382&gt; bitpos a 1
(integer) 1
127.0.0.1:6382&gt; bitpos a 0
(integer) 0
127.0.0.1:6382&gt; set user2 100
OK
</code></pre>

<h4 id="toc_96">代码独立用户统计</h4>

<p><strong>重要理解</strong>使用位图去记录用户uid，其实就是记录索引值，比如userid=100代表位图下标100的值为1</p>

<p><figure><img src="media/15586033218679/15586164498738.jpg" alt=""/></figure><br/>
<figure><img src="media/15586033218679/15586164555162.jpg" alt=""/></figure></p>

<h4 id="toc_97">使用经验</h4>

<ul>
<li>type=string,最大512MB</li>
<li>注意setbit时的偏移量，可能有较大耗时</li>
<li>位图不是绝对好</li>
</ul>

<h3 id="toc_98">HyperLogLog</h3>

<h4 id="toc_99">新的数据结构</h4>

<p><figure><img src="media/15586033218679/15586164914997.jpg" alt=""/></figure></p>

<h4 id="toc_100">API</h4>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">pfaddd key element [element...]</td>
<td style="text-align: left">向hyperloglog添加元素</td>
</tr>
<tr>
<td style="text-align: left">pfcount key [key...]</td>
<td style="text-align: left">计算hyperloglog的独立总数</td>
</tr>
<tr>
<td style="text-align: left">pfmerge destkey sourceKey [sourcekey...]</td>
<td style="text-align: left">合并多个hyperloglog</td>
</tr>
</tbody>
</table>

<h5 id="toc_101">练习</h5>

<pre class="line-numbers"><code class="language-redis">127.0.0.1:6382&gt; pfadd puser1 &quot;u1&quot; &quot;u2&quot; &quot;u3&quot;
(integer) 1
127.0.0.1:6382&gt; pfcount puser1
(integer) 3
127.0.0.1:6382&gt; pfadd puser2 &quot;u3&quot; &quot;u4&quot; &quot;u5&quot;
(integer) 1
127.0.0.1:6382&gt; pfmerge puser puser1 puser2
OK
127.0.0.1:6382&gt; pfcount puser
(integer) 5
</code></pre>

<h4 id="toc_102">内存消耗</h4>

<p><figure><img src="media/15586033218679/15586165725826.jpg" alt=""/></figure></p>

<h4 id="toc_103">使用经验</h4>

<ul>
<li>是否能容忍错误（错误率：0.81%）</li>
<li>是否需要单条数据（没有办法取出）</li>
</ul>

<h3 id="toc_104">GEO</h3>

<h4 id="toc_105">GEO是什么</h4>

<p><figure><img src="media/15586033218679/15586626246982.jpg" alt=""/></figure></p>

<h4 id="toc_106">5个城市经纬度</h4>

<p><figure><img src="media/15586033218679/15586626409328.jpg" alt=""/></figure></p>

<h4 id="toc_107">API</h4>

<table>
<thead>
<tr>
<th style="text-align: left">命令</th>
<th style="text-align: left">说明</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">geoadd key longitude latitude member [longitude latitude member ...]</td>
<td style="text-align: left">增加地理位置信息</td>
</tr>
<tr>
<td style="text-align: left">geopos key member[member...]</td>
<td style="text-align: left">获取地理位置信息</td>
</tr>
<tr>
<td style="text-align: left">geodist key member1 member2[unit]</td>
<td style="text-align: left">获取两个地理位置的距离，unit:m,km,mi,ft</td>
</tr>
<tr>
<td style="text-align: left">georadius</td>
<td style="text-align: left">获取指定位置范围内的地理位置信息集合</td>
</tr>
</tbody>
</table>

<h5 id="toc_108">练习</h5>

<pre class="line-numbers"><code class="language-java">127.0.0.1:6382&gt; geoadd beijing 116.28 39.55
(error) ERR wrong number of arguments for &#39;geoadd&#39; command
127.0.0.1:6382&gt; geoadd geo 116.28 39.55 beijing 117.12 39.08 tianjin
(integer) 2
127.0.0.1:6382&gt; geopos geo beijing
1) 1) &quot;116.28000229597091675&quot;
   2) &quot;39.5500007245470826&quot;
127.0.0.1:6382&gt; geodist geo beijing tianjin
&quot;89206.0576&quot;
127.0.0.1:6382&gt; 
</code></pre>

<h5 id="toc_109">相关说明</h5>

<ul>
<li>since 3.2+</li>
<li>type geoKey = zset</li>
<li>没有删除API：zrem key member</li>
</ul>

<h2 id="toc_110">Redis持久化的取舍和选择</h2>

<h3 id="toc_111">持久化的作用</h3>

<h4 id="toc_112">什么是持久化</h4>

<p>redis所有数据保存在内存中， 对数据的更新将异步地保存到磁盘上<br/>
<figure><img src="media/15586033218679/15586629377378.jpg" alt=""/></figure></p>

<h4 id="toc_113">持久化的实现方式</h4>

<ul>
<li>快照
<ul>
<li>mysql dump</li>
<li>redis RDB</li>
</ul></li>
<li>写日志
<ul>
<li>mysql binlog</li>
<li>hbase hLog</li>
<li>redis AOF</li>
</ul></li>
</ul>

<h3 id="toc_114">RDB</h3>

<h4 id="toc_115">什么是RDB</h4>

<p><figure><img src="media/15586033218679/15586630149517.jpg" alt=""/></figure></p>

<h4 id="toc_116">触发机制-主要三种方式</h4>

<p><strong>save（同步）</strong><br/>
<figure><img src="media/15586033218679/15586630390083.jpg" alt=""/></figure></p>

<pre class="line-numbers"><code class="language-text">* 文件策略：如存在老的RDB文件，新替换老
* 复杂度：O(N)
</code></pre>

<p><strong>bgsave(异步）</strong><br/>
<figure><img src="media/15586033218679/15586630760355.jpg" alt=""/></figure></p>

<p><strong>自动配置</strong><br/>
<figure><img src="media/15586033218679/15586630963507.jpg" alt=""/></figure></p>

<p><strong>相关配置</strong></p>

<table>
<thead>
<tr>
<th style="text-align: left">配置参数</th>
<th style="text-align: left">值</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left">save</td>
<td style="text-align: left">900 1</td>
</tr>
<tr>
<td style="text-align: left">save</td>
<td style="text-align: left">300 10</td>
</tr>
<tr>
<td style="text-align: left">save</td>
<td style="text-align: left">60 10000</td>
</tr>
<tr>
<td style="text-align: left">dbfilename</td>
<td style="text-align: left">dump-${port}.rdb</td>
</tr>
<tr>
<td style="text-align: left">dir</td>
<td style="text-align: left">/bigdishpath</td>
</tr>
<tr>
<td style="text-align: left">stop-writes-on-bgsav-error</td>
<td style="text-align: left">yes</td>
</tr>
<tr>
<td style="text-align: left">rdbcompression</td>
<td style="text-align: left">yes</td>
</tr>
</tbody>
</table>

<h4 id="toc_117">save与bgsave</h4>

<p><figure><img src="media/15586033218679/15586634779145.jpg" alt=""/></figure></p>

<h4 id="toc_118">触发机制-不容忽略的方式</h4>

<p>其他的方式也会触发生成RDB文件</p>

<ul>
<li>全量复制</li>
<li>debug reload</li>
<li>shutdown</li>
</ul>

<h4 id="toc_119">总结</h4>

<ul>
<li>RDB是Redis内存到硬盘的快照，用于持久化</li>
<li>save通常会阻塞Redis</li>
<li>bgsave不会阻塞redis，但是会fork新进程</li>
<li>save自动配置满足任一就会被执行</li>
<li>有些触发机制不容忽视</li>
</ul>

<h3 id="toc_120">AOF</h3>

<h4 id="toc_121">RDB现存问题</h4>

<ul>
<li>耗时，好性能
<figure><img src="media/15586033218679/15586635461544.jpg" alt=""/></figure></li>
<li>不可控，丢失数据
<figure><img src="media/15586033218679/15586635719513.jpg" alt=""/></figure>
#### 什么是AOF</li>
<li>创建
<figure><img src="media/15586033218679/15586635944951.jpg" alt=""/></figure></li>
<li>恢复
<figure><img src="media/15586033218679/15586636108767.jpg" alt=""/></figure></li>
</ul>

<h4 id="toc_122">AOF三种策略</h4>

<ul>
<li>always
<figure><img src="media/15586033218679/15586636320232.jpg" alt=""/></figure></li>
<li>everysec
<figure><img src="media/15586033218679/15586636441535.jpg" alt=""/></figure></li>
<li>no
<figure><img src="media/15586033218679/15586636536677.jpg" alt=""/></figure></li>
</ul>

<p><strong>三种策略比较</strong><br/>
<figure><img src="media/15586033218679/15586636764730.jpg" alt=""/></figure></p>

<h4 id="toc_123">AOF重写</h4>

<p><figure><img src="media/15586033218679/15586636949383.jpg" alt=""/></figure></p>

<h4 id="toc_124">AOF重写的作用</h4>

<ul>
<li>减少硬盘占用量</li>
<li>加速恢复速度<br/>
#### AOF重写实现的两种方式</li>
<li>bgrewriteaof
<figure><img src="media/15586033218679/15586637297923.jpg" alt=""/></figure></li>
<li>aof重写配置
<figure><img src="media/15586033218679/15586637468517.jpg" alt=""/></figure>
<figure><img src="media/15586033218679/15586637564996.jpg" alt=""/></figure></li>
</ul>

<h4 id="toc_125">AOF重写流程</h4>

<p><figure><img src="media/15586033218679/15586637760187.jpg" alt=""/></figure></p>

<h5 id="toc_126">配置</h5>

<p><figure><img src="media/15586033218679/15586637958927.jpg" alt=""/></figure></p>

<h3 id="toc_127">RDB与AOF的选择</h3>

<p><figure><img src="media/15586033218679/15586638202748.jpg" alt=""/></figure></p>

<h4 id="toc_128">RDB最佳策略</h4>

<ul>
<li>关</li>
<li>集中管理</li>
<li>主从，从开<br/>
#### AOF最佳策略</li>
<li>开，缓存和存储</li>
<li>AOF重写集中管理</li>
<li>everysec</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[发布Android库至JCenter仓库]]></title>
    <link href="http://adolph.cc/15580646892750.html"/>
    <updated>2019-05-17T11:44:49+08:00</updated>
    <id>http://adolph.cc/15580646892750.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">注册bintray账号</h2>

<p>此账号就是我们用来管理maven或者jcenter的控制台，注册地址为：<a href="https://bintray.com/signup/oss">https://bintray.com/signup/oss</a><br/>
注册地址一定要为这个，如果从官网进行注册，所找到的不是个人申请入口，而是组织申请入口。</p>

<span id="more"></span><!-- more -->

<h2 id="toc_1">创建Maven仓库</h2>

<p><figure><img src="media/15580646892750/15580770002473.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580770120071.jpg" alt="创建仓库"/><figcaption>创建仓库</figcaption></figure></p>

<h2 id="toc_2">创建库</h2>

<p>在对应仓库中创建一个包<br/>
<figure><img src="media/15580646892750/15580771556713.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580771660186.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580771781151.jpg" alt=""/></figure></p>

<h2 id="toc_3">创建library工程</h2>

<p><strong>注意：只有library工程才能上传成功</strong><br/>
建好之后，配置项目的build.gradle文件和module的build.gradle,项目的build.gradle文件配置如下，添加蓝色部分<code>classpath &#39;com.novoda:bintray-release:+&#39;</code><br/>
<figure><img src="media/15580646892750/15580653502262.jpg" alt=""/></figure></p>

<p>module的build.gradle文件配置如下，同样添加蓝色部分，其中publish部分，只有userOrg需要严格按照注册的bintray的用户名，其他的都是自己随意指定的</p>

<pre class="line-numbers"><code class="language-java">apply plugin: &#39;com.novoda.bintray-release&#39;
</code></pre>

<pre class="line-numbers"><code class="language-java">lintOptions {
    abortOnError false
}
</code></pre>

<pre class="line-numbers"><code class="language-java">publish {
    repoName = &#39;test&#39;           //远程仓库名字,不指明，默认是上传到maven
    userOrg = &#39;&#39;                //bintrary注册的用户名
    groupId = &#39;&#39;                //compile引用时的第一部分groupId
    artifactId = &#39;&#39;             //compile引用时的第二部分项目名
    publishVersion = &#39;&#39;         //compile引用时的第三部分版本号
    uploadName = &#39;&#39;             //展示名字
    desc = &#39;&#39;                   //项目描述
    website = &#39;&#39;                //项目网址，填写自己的github 项目网址，【验证时会用，填写能打开的项目网址】
    licences = [&#39;Apache-2.0&#39;]   //描述，填写licences
}
</code></pre>

<p><figure><img src="media/15580646892750/15580940647458.jpg" alt=""/></figure><br/>
上图3个红框 分别为userOrg、repoName、uploadName。</p>

<p><figure><img src="media/15580646892750/15580654925418.jpg" alt=""/></figure></p>

<p>配置部分基本完成，剩下的就是在命令行或gradlew命令来上传libray工程，命令如下</p>

<pre class="line-numbers"><code class="language-java">./gradlew clean generatePomFileForReleasePublication build bintrayUpload -PbintrayUser=*** -PbintrayKey=******** -PdryRun=false
</code></pre>

<p>其中用户名就是bintray注册的用户名，API-Key在如下图示获取<br/>
<figure><img src="media/15580646892750/15580656233555.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580656377202.jpg" alt=""/></figure><br/>
之后就是等待执行结束，成功后AS控制台如下提示BUILD SUCCESSFUL in ...</p>

<h2 id="toc_4">查看bintray页面</h2>

<p>刷新bintray页面，就会发现在maven页面多了你的库了，此处表示已经上传到maven仓库了<br/>
<figure><img src="media/15580646892750/15580657436779.jpg" alt=""/></figure><br/>
<figure><img src="media/15580646892750/15580657539240.jpg" alt=""/></figure></p>

<h2 id="toc_5">如何使用Maven仓库的库</h2>

<p>点击进入自己的一个package<br/>
<figure><img src="media/15580646892750/15580657872626.jpg" alt=""/></figure></p>

<p>实战配置如下，我在其他工程处需要引用时，如果时maven方式，则如下<br/>
项目的根build.gradle<br/>
<figure><img src="media/15580646892750/15580658181998.jpg" alt=""/></figure></p>

<p>具体的module工程，需要添加compile，就是上图中的选择的Gradle方式，复制过来直接配置build.gradle就可以<br/>
<figure><img src="media/15580646892750/15580658387938.jpg" alt=""/></figure><br/>
重新同步下工程，就可以用你自己的库了。此处，大功告成！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单例模式]]></title>
    <link href="http://adolph.cc/15576631048737.html"/>
    <updated>2019-05-12T20:11:44+08:00</updated>
    <id>http://adolph.cc/15576631048737.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">单例模式的意义</h2>

<p>单例模式是最简单的设计模式之一，属于创建模式，它提供了一种创建对象的方式，确保只有单个对象被创建。这种设计模式主要目的是使整个系统中只能出现一个类的实例，即一个类只有一个对象。如果某个类，创建时需要消耗很多资源，即new出这个类的代价很大；或者是这个类占用很多内存，如果创建太多这个类实例会导致内存占用太多，就需要使用单例模式。</p>

<ul>
<li>优点
<ul>
<li>由于频繁使用对象，可以省略创建对象所花费的时间，尤其是对于重量级的对象而言，是很重要的。</li>
<li>由于不需要频繁的创建对象，所以GC的压力变轻了，不需要频繁的分配资源和释放资源。</li>
</ul></li>
<li>缺点
<ul>
<li>简单的单例模式设计都很简单，但是复杂的单例模式需要考虑线程安全等并发问题，引入了部分复杂度</li>
</ul></li>
</ul>

<span id="more"></span><!-- more -->

<h2 id="toc_1">单例模式的设计</h2>

<p>设计单例模式的时候需要考虑的集中因素</p>

<ul>
<li>线程安全</li>
<li>延迟加载</li>
<li>代码安全(防止序列化攻击，防止反射攻击)</li>
<li>性能因素</li>
</ul>

<table>
<thead>
<tr>
<th style="text-align: center"></th>
<th style="text-align: center">线程安全</th>
<th style="text-align: center">并发性能好</th>
<th style="text-align: center">可以延迟加载</th>
<th style="text-align: center">序列化/反序列化安全</th>
<th style="text-align: center">能抵御反射攻击</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">饿汉式</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">懒汉式-不加锁</td>
<td style="text-align: center"></td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">懒汉式-加锁的</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">DCL</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">静态内部类</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">枚举</td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
<td style="text-align: center"></td>
<td style="text-align: center">Y</td>
<td style="text-align: center">Y</td>
</tr>
</tbody>
</table>

<h2 id="toc_2">饿汉模式</h2>

<pre class="line-numbers"><code class="language-java">public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return instance;
    }
}
</code></pre>

<p>饿汉模式代码比较简单，对象在类中被定义为private static，通过getInstance()，通过java的classLoader机制保证了单例对象唯一。</p>

<h3 id="toc_3">扩展</h3>

<h4 id="toc_4">有可能会问instance什么时候被初始化？</h4>

<p>Singleton类被加载的时候就会被初始化，java虚拟机规范虽然没有强制性约束在什么时候开始类加载过程，但是对于类的初始化，虚拟机规范则严格规定了有且只有四种情况必须立即对类进行初始化，遇到new、getStatic、putStatic或invokeStatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这4条指令最常见的java代码场景是：</p>

<ol>
<li>使用new关键字实例化对象</li>
<li>读取一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）</li>
<li>设置一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）</li>
<li>调用一个类的静态方法</li>
</ol>

<h4 id="toc_5">class的生命周期?</h4>

<p>class的生命周期一般来说会经历加载、连接、初始化、使用、和卸载五个阶段</p>

<h4 id="toc_6">class的加载机制</h4>

<p>classloader的双亲委派模型。</p>

<h2 id="toc_7">双重检查DCL</h2>

<pre class="line-numbers"><code class="language-java">public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                    singleton = new Singleton();  
                }  
            }  
        }  
        return singleton;  
    }  
}  
</code></pre>

<p>synchronized同步块里面能够保证只创建一个对象。但是通过在synchronized的外面增加一层判断，就可以在对象一经创建以后，不再进入synchronized同步块。这种方案不仅减小了锁的粒度，保证了线程安全，性能方面也得到了大幅提升。<br/>
同时这里要注意一定要说volatile，这个很关键，volatile一般用于多线程的可见性，但是这里是用来防止指令重排序的。</p>

<h3 id="toc_8">扩展</h3>

<h4 id="toc_9">为什么需要volatile？volatile有什么用？</h4>

<ul>
<li>首先要回答可见性，这个是毋庸质疑的，然后可能又会考到java内存模型。</li>
<li>防止指令重排序: 防止new Singleton时指令重排序导致其他线程获取到未初始化完的对象。instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。1. 给 instance 分配内存。2. 调用 Singleton 的构造函数来初始化成员变量。3. 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后报错。</li>
<li>顺便也可以说下volatie原理用内存屏障</li>
</ul>

<h4 id="toc_10">synchronized和volatile的区别</h4>

<p>这里可以从synchroized能保证原子性，volatile不能保证说起，以及讲下synchroized是重量级锁，甚至可以所以下他和Lock的区别等等。</p>

<h4 id="toc_11">线程安全一般怎么实现的?</h4>

<ul>
<li>互斥同步。如lock,synchroized</li>
<li>非阻塞同步。如cas。</li>
<li>不同步。如threadLocal,局部变量。</li>
</ul>

<h2 id="toc_12">枚举类</h2>

<pre class="line-numbers"><code class="language-java">public enum Singleton{
    INSTANCE;
}
</code></pre>

<p>默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。同时他也是《Effective Java》中推荐的模式。最后通过枚举类，他能自动避免序列化/反序列化攻击，以及反射攻击(枚举类不能通过反射生成)。</p>

]]></content>
  </entry>
  
</feed>
