<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  RenderBox 使用详解 - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.ifantastic.ink ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>RenderBox 使用详解</h1>
     
        <div class="read-more clearfix">
          <span class="date">2023/06/28</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Flutter.html'>Flutter</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <span id="more"></span><!-- more -->
<h2><a id="renderbox%E7%9A%84%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RenderBox的用法</h2>
<h3><a id="renderbox%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RenderBox的使用基本流程</h3>
<p>在flutter中，我们最常接触的，莫过于各种各样的<code>widget</code>了，但是，实际负责渲染的<code>RenderObject</code>是很少接触的。而作为一名天天向上的程序员，我们自然要去学习一下它的原理，做到知其然且知其所以然。本文会先来看看<code>RenderBox</code>的用法，以此抛砖引玉，便于后面继续深入flutter的绘制原理。</p>
<p>使用<code>RenderBox</code>进行绘制，我们需要做三件事：</p>
<h4><a id="%E6%B5%8B%E9%87%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>测量</h4>
<p>第一步，我们需要确定视图大小，并赋值给父类的<code>size</code>属性。测量有两种情况，第一种是<code>size</code>由自身决定，第二种是由<code>parent</code>决定。</p>
<p>首先，由自身决定<code>size</code>的情况，需要在<code>performLayout</code>方法中完成测量，通过父类的<code>constraints</code>可得到满足约束的值：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void performLayout() {
    size = Size(
      constraints.constrainWidth(200),
      constraints.constrainHeight(200),
    );
  }
</code></pre>
<p>第二种情况，<code>size</code>由<code>parent</code>决定，这种情况下视图大小应该完全通过<code>parent</code>提供的<code>constraints</code>测量，不存在其它因素。这种情况下，只要<code>parent</code>的约束不发生变化，就不会重新测量。</p>
<p>这种情况需要重写<code>sizedByParent</code>并返回<code>true</code>，然后在<code>performResize</code>中完成测量。</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void performResize() {
    size = constraints.biggest;
  }

  @override
  bool get sizedByParent =&gt; true;
</code></pre>
<p>看到这里，你可能会疑惑了，这两个方法什么时候会被调用？顺序是怎样的？答案在<code>RenderObject</code>的<code>layout</code>方法中：</p>
<pre class="line-numbers"><code class="language-dart">  void layout(Constraints constraints, { bool parentUsesSize = false }) {
    //计算relayoutBoundary
    ......
    //layout
    _constraints = constraints;
    if (sizedByParent) {
        performResize();
    }
    performLayout();
    ......
  }
}
</code></pre>
<h4><a id="%E7%BB%98%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>绘制</h4>
<p><code>RenderBox</code>的绘制与android原生的view绘制非常相似，同样是Paint+Canvas的组合，而且api也非常接近，会非常容易上手。</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void paint(PaintingContext context, Offset offset) {
    Paint paint = Paint()
      ..color = _color
      ..style = PaintingStyle.fill;
    context.canvas.drawRect(
        Rect.fromLTRB(
          0,
          0,
          size.width,
          size.height,
        ),
        paint);
  }
</code></pre>
<p>这样是不是就万事大吉了呢？如果通过上面的代码进行绘制，你会发现，不管在外层怎么设置位置，绘制出来的矩形都是固定在屏幕左上角的！怎么回事？</p>
<p>这里就是flutter中绘制与android的最大不同：在这里绘制的坐标系是全局坐标系，即原点在屏幕左上角，而非视图左上角。</p>
<p>细心的同学可能已经发现，<code>paint</code>方法中还有一个<code>offset</code>参数，这就是经过<code>parent</code>的约束后，当前视图的偏移量，绘制时应该将它考虑进去：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void paint(PaintingContext context, Offset offset) {
    Paint paint = Paint()
      ..color = _color
      ..style = PaintingStyle.fill;
    context.canvas.drawRect(
        Rect.fromLTRB(
          offset.dx,
          offset.dy,
          offset.dx + size.width,
          offset.dy + size.height,
        ),
        paint);
  }
</code></pre>
<h4><a id="%E6%9B%B4%E6%96%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>更新</h4>
<p>在flutter中，是由Widget的配置发生变更而引起的<code>rebuild</code>，而这就是我们要实现的第三步：当视图属性发生变更时，标记重新布局或重新绘制，当屏幕刷新时就会做相应的刷新。</p>
<p>这里涉及到两个方法：<code>markNeedsLayout</code>、<code>markNeedsPaint</code>。顾名思义，前者标记重布局，后者标记重绘。</p>
<p>我们需要做的，就是根据属性的影响范围，在更新属性时，调用合适的标记方法，例如color变化时调用<code>markNeedsPaint</code>，<code>width</code>变化时调用<code>markNeedsLayout</code>。另外，两者都需要更新的情况下，只调用<code>markNeedsLayout</code>即可，不需要两个方法都调。</p>
<pre class="line-numbers"><code class="language-dart">  set width(double width) {
    if (width != _width) {
      _width = width;
      markNeedsLayout();
    }
  }

  set color(Color color) {
    if (color != _color) {
      _color = color;
      markNeedsPaint();
    }
  }
</code></pre>
<h3><a id="renderobjectwidget" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RenderObjectWidget</h3>
<h4><a id="%E7%AE%80%E4%BB%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简介</h4>
<p>上面讲了一大堆RenderBox的用法，但是，这玩意儿怎么用到我们熟知的Widget里面去？</p>
<p>按照正常流程，我们得实现一个<code>Element</code>和一个<code>Widget</code>，然后在<code>Widget</code>中创建<code>Element</code>，在<code>Element</code>中创建和更新<code>RenderObject</code>，另外还得管理一大堆状态，处理非常繁琐。所幸flutter为我们封装了这一套逻辑，即<code>RenderObjectWidget</code>。</p>
<p>相信看到这里的同学都对<code>StatelessWidget</code>和<code>StatefulWidget</code>不会陌生，但其实，<code>StatelessWidget</code>和<code>StatefulWidget</code>仅负责属性、生命周期等的管理，在它们的build方法实现中都会创建<code>RenderObjectWidget</code>，通过它来实现与<code>RenderObject</code>的关联。</p>
<p>举个栗子，我们经常使用的<code>Image</code>是个<code>StatefulWidget</code>，对应的<code>state</code>的<code>build</code>方法中实际返回了一个<code>RawImage</code>对象，而这个RawImage是继承自<code>LeafRenderObjectWidget</code>的，这正是<code>RenderObjectWidget</code>的一个子类；再比如<code>Text</code>，它<code>build</code>方法中创建的<code>RichText</code>是继承自<code>MultiChildRenderObjectWidget</code>，这同样是<code>RenderObjectWidget</code>的一个子类。</p>
<p>我们再看看<code>RenderObjectWidget</code>顶部的注释即可明白：</p>
<blockquote>
<p>RenderObjectWidgets provide the configuration for [RenderObjectElement]s,<br />
which wrap [RenderObject]s, which provide the actual rendering of the<br />
application.</p>
</blockquote>
<p>大概意思就是<code>RenderObject</code>才是实际负责渲染应用的，而<code>RenderObjectWidget</code>提供包装了<code>RenderObject</code>的配置，方便我们使用。</p>
<p>另外，flutter还分别实现了几个子类，进一步封装了<code>RenderObjectWidget</code>，它们分别是<code>LeafRenderObjectWidget</code>、<code>SingleChildRenderObjectWidget</code>、<code>MultiChildRenderObjectWidget</code>。其中，<code>LeafRenderObjectWidget</code>是叶节点，不含子<code>Widget</code>；<code>SingleChildRenderObjectWidget</code>仅有一个<code>child</code>；而<code>MultiChildRenderObjectWidget</code>则是含有<code>children</code>列表。这几个子类根据<code>child</code>的情况分别创建了对应的<code>Element</code>，所以通过这几个子类，我们只需要关注<code>RenderObject</code>的创建和更新。</p>
<h4><a id="%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>用法</h4>
<p>以最简单的<code>LeafRenderObjectWidget</code>为例，我们需要实现<code>createRenderObject</code>、<code>updateRenderObject</code>两个方法：</p>
<pre class="line-numbers"><code class="language-dart">  class CustomRenderWidget extends LeafRenderObjectWidget {
  CustomRenderWidget({
    this.width = 0,
    this.height = 0,
    this.color,
  });

  final double width;
  final double height;
  final Color color;

  @override
  RenderObject createRenderObject(BuildContext context) {
    return CustomRenderBox(width, height, color);
  }

  @override
  void updateRenderObject(BuildContext context, RenderObject renderObject) {
    CustomRenderBox renderBox = renderObject as CustomRenderBox;
    renderBox
      ..width = width
      ..height = height
      ..color = color;
  }
}
</code></pre>
<h3><a id="%E9%9D%9E%E5%AE%B9%E5%99%A8%E6%8E%A7%E4%BB%B6%E7%9A%84hittest" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>非容器控件的hitTest</h3>
<p>通过上面的内容，我们已经可以实现自定义控件并用到界面开发中，但是距离一个完整的控件还差最后一步：命中测试。当用户使用手势，flutter会将手势信息交由控件进行检查是否命中。</p>
<p>RenderBox中命中测试的方法有仨：<code>hitTest</code>、<code>hitTestSelf</code>、<code>hitTestChildren</code>，其中<code>hitTest</code>默认实现是调用另外两个方法的：</p>
<pre class="line-numbers"><code class="language-dart">  bool hitTest(BoxHitTestResult result, { @required Offset position }) {
    if (_size.contains(position)) {
      // 从这里也能看到，当命中children时，不会再进行自身的命中测试
      if (hitTestChildren(result, position: position) || hitTestSelf(position)) {
        result.add(BoxHitTestEntry(this, position));
        return true;
      }
    }
    return false;
  }
</code></pre>
<p>所以重写命中测试方法有两个方案，一是重写<code>hitTest</code>，这种方法需要将命中测试的信息加到<code>BoxHitTestResult</code>中；二是重写<code>hitTestSelf</code>和<code>hitTestChildren</code>，这种方法就简单地返回是否命中即可。</p>
<p>非容器类型的控件，只需要重写<code>hitTestSelf</code>，返回<code>true</code>即命中，例如RawImage中：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  bool hitTestSelf(Offset position) =&gt; true;
</code></pre>
<h2><a id="%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E7%9A%84renderbox" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>容器类型的RenderBox</h2>
<h3><a id="%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>介绍</h3>
<p>在绘制篇中，我们已经了解到如何使用<code>RenderObjectWidget</code>和<code>RenderBox</code>进行基础的绘制，在本篇中，我们将继续学习<code>RenderBox</code>如何管理子对象。首先，我们来看看<code>RenderBox</code>顶部的一段注释：</p>
<pre class="line-numbers"><code class="language-plain_text">For render objects with children, there are four possible scenarios:
* A single [RenderBox] child. In this scenario, consider inheriting from
  [RenderProxyBox] (if the render object sizes itself to match the child) or
  [RenderShiftedBox] (if the child will be smaller than the box and the box
  will align the child inside itself).
* A single child, but it isn't a [RenderBox]. Use the
  [RenderObjectWithChildMixin] mixin.
* A single list of children. Use the [ContainerRenderObjectMixin] mixin.
* A more complicated child model.
</code></pre>
<p>从上面我们可以了解到，带有子对象的情况有四种：</p>
<ol>
<li>子对象只有一个，并且是<code>RenderBox</code>的子类。如果当前视图需要根据子对象调整大小，则继承<code>RenderProxyBox</code>；如果子对象小于当前视图，且在当前视图内部对齐，则继承<code>RenderShiftedBox</code>（想一下Align会好理解一点）；</li>
<li>子对象只有一个，且非RenderBox子类，这种情况使用<code>RenderObjectWithChildMixin</code>；</li>
<li>有多个子对象则使用<code>ContainerRenderObjectMixin</code>；</li>
<li>更复杂的情况。</li>
</ol>
<p>第四种情况是要用非链表的<code>children</code>结构时需要考虑的，比如<code>children</code>要用<code>map</code>或<code>list</code>等结构，这种情况需要继承<code>RenderObject</code>去实现一套绘制协议，我们这里暂且先不讨论。</p>
<p>而前三种情况其实注释里的描述不够明确，其实情况只有两种，第一是带有单一的<code>child</code>，第二是带有一个<code>children</code>列表，上面的第一第二两种情况其实可以合并为一种，为什么这么说呢？看下去吧~</p>
<h3><a id="%E5%8D%95%E4%B8%AA%E5%AD%90%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单个子对象</h3>
<h4><a id="renderproxybox" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RenderProxyBox</h4>
<p>这种情况其实就是当前容器没有跟大小相关的属性，<code>size</code>由子类决定，具体逻辑flutter已经在<code>RenderProxyBoxMixin</code>实现了，我们来看看：</p>
<pre class="line-numbers"><code class="language-dart">  void performLayout() {
    if (child != null) {
      child.layout(constraints, parentUsesSize: true);
      size = child.size;
    } else {
      performResize();
    }
  }
</code></pre>
<p>逻辑非常简单，如果有<code>child</code>，则直接使用<code>child</code>的<code>size</code>；如果没有，就走<code>performResize</code>，而这里并没有实现<code>performResize</code>，即走<code>RenderBox</code>的默认实现，取约束的最小值：</p>
<pre class="line-numbers"><code class="language-dart">  void performResize() {
    size = constraints.smallest;
    assert(size.isFinite);
  }
</code></pre>
<p>而绘制方法中，通过<code>PaintingContext</code>的<code>paintChild</code>方法，即可绘制<code>child</code>：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void paint(PaintingContext context, Offset offset) {
    if (child != null)
      context.paintChild(child, offset);
  }
</code></pre>
<h4><a id="rendershiftedbox" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RenderShiftedBox</h4>
<p>这种情况则与<code>RenderProxyBox</code>相反，即当前容器有跟大小相关的属性，比如<code>padding</code>。接下来就以非常常见的<code>Padding</code>为例，看看<code>RenderPadding</code>的布局方法：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void performLayout() {
    // 将padding的值按照语言方向解析
    _resolve();
    assert(_resolvedPadding != null);
    if (child == null) {
      // 如果没有child，就按照垂直、水平方向的padding值计算得出size
      size = constraints.constrain(Size(
        _resolvedPadding.left + _resolvedPadding.right,
        _resolvedPadding.top + _resolvedPadding.bottom,
      ));
      return;
    }
    // 如果有child，则将当前约束减去padding值以后，再传给child进行测量
    final BoxConstraints innerConstraints = constraints.deflate(_resolvedPadding);
    child.layout(innerConstraints, parentUsesSize: true);
    
    // 测量完毕以后，计算出坐标偏移量，提供给child绘制时使用
    // parentData是RenderObject的属性，提供给父布局使用，用来存取child在父布局中的一些信息，包括位置等
    final BoxParentData childParentData = child.parentData;
    childParentData.offset = Offset(_resolvedPadding.left, _resolvedPadding.top);
    
    // 最后得出大小是padding加上child的大小
    size = constraints.constrain(Size(
      _resolvedPadding.left + child.size.width + _resolvedPadding.right,
      _resolvedPadding.top + child.size.height + _resolvedPadding.bottom,
    ));
  }
</code></pre>
<p>可以看到，这里有三个关键步骤：第一，根据属性将约束减去需要额外占用的宽高，然后传给<code>child</code>进行测量；第二，测量完毕后计算出<code>child</code>需要用到的绘制偏移量；第三，根据属性和<code>child</code>的<code>size</code>得出总宽高。</p>
<p>另外，<code>RenderShiftedBox</code>的<code>paint</code>方法逻辑与<code>RenderProxyBox</code>稍微有点不同，会对offset进行处理：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void paint(PaintingContext context, Offset offset) {
    if (child != null) {
      final BoxParentData childParentData = child.parentData;
      context.paintChild(child, childParentData.offset + offset);
    }
  }
</code></pre>
<h4><a id="renderobjectwithchildmixin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RenderObjectWithChildMixin</h4>
<p>回到上面的问题，为什么说<code>RenderBox</code>和非<code>RenderBox</code>的单一子对象是一样的呢？其实，<code>RenderProxyBox</code>和<code>RenderShiftedBox</code>是专门为<code>RenderBox</code>的子类再封装了一层便于使用，它们本身还是<code>with</code>了<code>RenderObjectWithChildMixin</code>：</p>
<pre class="line-numbers"><code class="language-dart">class RenderProxyBox extends RenderBox with RenderObjectWithChildMixin&lt;RenderBox&gt;, RenderProxyBoxMixin&lt;RenderBox&gt; {
  /// 略
}

abstract class RenderShiftedBox extends RenderBox with RenderObjectWithChildMixin&lt;RenderBox&gt; {
  /// 略
}
</code></pre>
<p>经过前面的分析，我们知道<code>RenderProxyBox</code>和<code>RenderShiftedBox</code>只负责测量和绘制，那么<code>RenderObjectWithChildMixin</code>是做什么的呢？借助Android Studio的Structure窗口，我们可以看到：</p>
<p><figure><img src="media/16879538975586/16879553074761.jpg" alt="" /></figure></p>
<p>除去debug的方法以外，这个类方法并不多。以attach为例：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void attach(PipelineOwner owner) {
    super.attach(owner);
    if (_child != null)
      _child.attach(owner);
  }
</code></pre>
<p>代码很少，就是在上层<code>attach</code>过来时，再<code>attach</code>自己的<code>child</code>，这里就涉及到渲染树的知识点，这又是另一个话题了，现在我也还没看到这里，后续我们再来分析这玩意儿~</p>
<p>一言蔽之，<code>RenderObjectWithChildMixin</code>实现了与渲染树相关的<code>child</code>的管理。</p>
<h4><a id="singlechildrenderobjectwidget" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SingleChildRenderObjectWidget</h4>
<p>同样，定义完<code>RenderBox</code>以后，需要在一个<code>Widget</code>中进行创建，单个<code>child</code>的情况我们可以使用<code>SingleChildRenderObjectWidget</code>，与<code>LeafRenderObjectWidget</code>不同的地方在于需要在构造函数将<code>child</code>传入：</p>
<pre class="line-numbers"><code class="language-dart">class CustomRenderWidget extends SingleChildRenderObjectWidget {
  CustomRenderWidget(Widget child) : super(child: child);
}
</code></pre>
<h3><a id="%E5%A4%9A%E4%B8%AA%E5%AD%90%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多个子对象</h3>
<h4><a id="containerrenderobjectmixin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ContainerRenderObjectMixin</h4>
<p>相对于上面只有单个<code>child</code>的情况，多个子对象的情况稍微复杂一点，但也只是一点，其实区别不太大。同样，关于与渲染树相关的子对象管理，flutter也是提供了一个<code>ContainerRenderObjectMixin</code>，这里我们就不再分析它的原理了，只需要注意一个地方，当<code>RenderBox</code>被创建时，需要调一下<code>addAll</code>方法将<code>children</code>加入：</p>
<pre class="line-numbers"><code class="language-dart">  RenderListBody({
    List&lt;RenderBox&gt; children,
    AxisDirection axisDirection = AxisDirection.down,
  }) : assert(axisDirection != null),
       _axisDirection = axisDirection {
    // 把children交给ContainerRenderObjectMixin管理
    addAll(children);
  }
</code></pre>
<h4><a id="containerparentdatamixin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ContainerParentDataMixin</h4>
<p>另外，<code>ContainerDefaultsMixin</code>指定了使用的<code>ParentData</code>必须是<code>ContainerParentDataMixin</code>的子类。<code>ContainerParentDataMixin</code>并不复杂，它的作用仅仅是实现了双向链表结构的<code>ParentData</code>：</p>
<pre class="line-numbers"><code class="language-dart">mixin ContainerParentDataMixin&lt;ChildType extends RenderObject&gt; on ParentData {
  ChildType previousSibling;
  ChildType nextSibling;
}
</code></pre>
<p>指定了<code>ParentData</code>的类型后，还需要在<code>RenderBox</code>的<code>setupParentData</code>检查<code>child</code>使用的<code>data</code>类型是否符合，不符合则重新创建并替换：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void setupParentData(RenderObject child) {
    super.setupParentData(child);
    if (child.parentData is! MultiChildLayoutParentData) {
      child.parentData = MultiChildLayoutParentData();
    }
  }
</code></pre>
<h4><a id="%E6%A1%88%E4%BE%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>案例源码分析</h4>
<p>下面我们再以<code>RenderStack</code>为例，看看它的测量(函数写得有点长，但分段看挺容易理解的)：</p>
<pre class="line-numbers"><code class="language-dart">  @override
  void performLayout() {
    // 根据textDirection解析alignment
    _resolve();
    assert(_resolvedAlignment != null);
    _hasVisualOverflow = false;
    bool hasNonPositionedChildren = false;
    
    // 如果没有子对象，stack会充满父布局
    if (childCount == 0) {
      size = constraints.biggest;
      assert(size.isFinite);
      return;
    }

    double width = constraints.minWidth;
    double height = constraints.minHeight;

    // 根据fit属性调整约束
    BoxConstraints nonPositionedConstraints;
    assert(fit != null);
    switch (fit) {
      case StackFit.loose:
        nonPositionedConstraints = constraints.loosen();
        break;
      case StackFit.expand:
        nonPositionedConstraints = BoxConstraints.tight(constraints.biggest);
        break;
      case StackFit.passthrough:
        nonPositionedConstraints = constraints;
        break;
    }
    assert(nonPositionedConstraints != null);

    // 遍历所有没有通过Positioned指定位置或大小的子对象，进行布局
    RenderBox child = firstChild;
    while (child != null) {
      final StackParentData childParentData = child.parentData;

      if (!childParentData.isPositioned) {
        hasNonPositionedChildren = true;

        // 这种情况通过根据fit转换后的约束测量子对象
        child.layout(nonPositionedConstraints, parentUsesSize: true);

        // 测量完以后对比大小取最大值
        final Size childSize = child.size;
        width = math.max(width, childSize.width);
        height = math.max(height, childSize.height);
      }

      child = childParentData.nextSibling;
    }

    if (hasNonPositionedChildren) {
      // 如果存在没用Positioned指定位置或大小的子对象，则取这些子对象的最大size（上面测量后得到的）
      size = Size(width, height);
      assert(size.width == constraints.constrainWidth(width));
      assert(size.height == constraints.constrainHeight(height));
    } else {
      // 否则充满父布局
      size = constraints.biggest;
    }

    assert(size.isFinite);

    // 遍历计算约束、offset
    child = firstChild;
    while (child != null) {
      final StackParentData childParentData = child.parentData;

      if (!childParentData.isPositioned) {
      
        // 没指定位置或大小，则根据alignment来计算offset
        childParentData.offset = _resolvedAlignment.alongOffset(size - child.size);
        
      } else {
        BoxConstraints childConstraints = const BoxConstraints();

        if (childParentData.left != null &amp;&amp; childParentData.right != null)
          // 指定了left和right，根据stack的宽度算出child的宽度
          childConstraints = childConstraints.tighten(width: size.width - childParentData.right - childParentData.left);
        else if (childParentData.width != null)
          // 这里直接指定了宽度
          childConstraints = childConstraints.tighten(width: childParentData.width);

        // 跟上面逻辑一样
        if (childParentData.top != null &amp;&amp; childParentData.bottom != null)
          childConstraints = childConstraints.tighten(height: size.height - childParentData.bottom - childParentData.top);
        else if (childParentData.height != null)
          childConstraints = childConstraints.tighten(height: childParentData.height);

        // 测量child
        child.layout(childConstraints, parentUsesSize: true);

        // 计算offset
        double x;
        if (childParentData.left != null) {
          x = childParentData.left;
        } else if (childParentData.right != null) {
          x = size.width - childParentData.right - child.size.width;
        } else {
          x = _resolvedAlignment.alongOffset(size - child.size).dx;
        }

        if (x &lt; 0.0 || x + child.size.width &gt; size.width)
          // 标记溢出，在paint的时候会用
          _hasVisualOverflow = true;

        double y;
        if (childParentData.top != null) {
          y = childParentData.top;
        } else if (childParentData.bottom != null) {
          y = size.height - childParentData.bottom - child.size.height;
        } else {
          y = _resolvedAlignment.alongOffset(size - child.size).dy;
        }

        if (y &lt; 0.0 || y + child.size.height &gt; size.height)
          _hasVisualOverflow = true;

        childParentData.offset = Offset(x, y);
      }

      assert(child.parentData == childParentData);
      child = childParentData.nextSibling;
    }
  }
</code></pre>
<p>抽丝剥茧以后，不难理解，其实多个子对象和单个子对象本质上是一样的，提供子对象约束让它进行测量，然后根据测量结果决定自己的<code>size</code>，最后再计算子对象绘制的<code>offset</code>。就这样~</p>
<p>最后再看看绘制方法：</p>
<pre class="line-numbers"><code class="language-dart">  @protected
  void paintStack(PaintingContext context, Offset offset) {
    // 其它情况则直接使用RenderBoxContainerDefaultsMixin提供的默认绘制方法
    defaultPaint(context, offset);
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    // 处理方式为clip时，溢出部分裁减掉，_hasVisualOverflow在上面计算offset时进行了标记
    if (_overflow == Overflow.clip &amp;&amp; _hasVisualOverflow) {
      context.pushClipRect(needsCompositing, offset, Offset.zero &amp; size, paintStack);
    } else {
      paintStack(context, offset);
    }
  }
</code></pre>
<h3><a id="getxxxintrinsicxxx%E5%92%8C-computexxxintrinsicxxx%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>getXxxIntrinsicXxx</code>和<code>computeXxxIntrinsicXxx</code>的作用、用法</h3>
<p>细心的同学可能会发现，实现了<code>performLayout</code>的类中都重写了一系列<code>compute</code>开头的方法，另外也会有些地方调用了<code>getMaxIntrinsicWidth</code>等几个&quot;get系列&quot;的方法。从名字上看，这几个方法分别是用来计算和获取最大最小宽高的，但按照我们前面的说法，直接在<code>performLayout</code>或<code>performResize</code>中通过<code>constrains</code>计算宽高也可以，那么这几个方法有什么作用？跟我们前面的做法又有什么区别呢？别着急，接下来我们就来解开这些疑惑。</p>
<p>根据<code>getMinIntrinsicWidth</code>方法的注释，可以得出几个要点：</p>
<ol>
<li><code>getMinIntrinsicWidth</code>用来获取能够完整绘制所有内容的最小宽度；</li>
<li>这个方法是给父布局使用的，如果父布局调用了某个<code>child</code>的这个方法，当<code>child</code>调用<code>markNeedsLayout</code>时，父布局也会被通知刷新；</li>
<li>这个方法的算法复杂的是O(N^2)，所以非必要的情况不要用它；</li>
<li>不要重写这个方法，有需要的话重写<code>computeMinIntrinsicWidth</code>。</li>
</ol>
<p>结合这些说明，情况基本明确了。<code>compute</code>系列的方法是需要重写，并计算返回相应的大小；而get系列的方法则是提供给父布局使用，让父布局能够在<code>child</code>测量前就知道<code>child</code>的<code>size</code>。这么实现的原因是规避android原生那种measure两次的问题，详情可以看看<a href="https://zhuanlan.zhihu.com/p/90195812">闲鱼这篇文章</a></p>
<h3><a id="%E5%AE%B9%E5%99%A8%E7%B1%BB%E6%8E%A7%E4%BB%B6%E7%9A%84hittest" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>容器类控件的hitTest</h3>
<p>相对于非容器类的控件，容器控件的命中测试需要额外考虑<code>child</code>的命中情况，结合上述内容，我们只需要实现<code>hitTestChildren</code>即可，不过需要注意一点，这个方法接收的<code>postion</code>需要是相对于当前控件的（即原点在当前控件左上角），在对<code>child</code>进行命中测试前，我们需要把<code>position</code>转成原点在<code>child</code>左上角的相对坐标位置。 <code>HitTestResult</code>类提供的一些方法会帮助我们完成这个转换。我们来看看<code>RenderBoxContainerDefaultsMixin</code>中的默认实现：</p>
<pre class="line-numbers"><code class="language-dart">  bool defaultHitTestChildren(BoxHitTestResult result, { Offset position }) {
    ChildType child = lastChild;
    while (child != null) {
      final ParentDataType childParentData = child.parentData;
      
      // addWithPaintOffset会将根据offset将position转换成child的相对位置
      final bool isHit = result.addWithPaintOffset(
        offset: childParentData.offset,
        position: position,
        hitTest: (BoxHitTestResult result, Offset transformed) {
          // 这里的offset已经经过转换
          return child.hitTest(result, position: transformed);
        },
      );
      if (isHit)
        return true;
      child = childParentData.previousSibling;
    }
    return false;
  }
</code></pre>
<p>举个栗子，一个宽高为200的正方形容器中，装有一个宽高为100的小正方形，小正方形位于容器右下角：</p>
<p><figure><img src="media/16879538975586/16879559737315.jpg" alt="" /></figure></p>
<p>这个时候<code>childParentData</code>中<code>offset</code>是(100,100)，假设点击到正方形容器的左上角，那么容器的<code>hitTestChildren</code>方法拿到的<code>position</code>为(0,0)，经过转换后，小正方形的<code>hitTest</code>方法中拿到的<code>postion</code>就应该是(-100, -100)。</p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16880177694288.html" 
          title="Previous Post: Flutter 自定义布局实战">&laquo; Flutter 自定义布局实战</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="16879529945481.html" 
          title="Next Post: Flutter框架分析（十）-- InheritedWidget">Flutter框架分析（十）-- InheritedWidget &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/17043409056338/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/adolphJane" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:adolphdeveloper@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
