<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  深入理解Handler - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>深入理解Handler</h1>
     
        <div class="read-more clearfix">
          <span class="date">2022/05/24</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html'>Android源码分析</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <p><strong>Handler</strong>，一个面试中常问的高频词汇。</p>
<span id="more"></span><!-- more -->
<p>面试中一般会问：</p>
<blockquote>
<p>我们知道在Handler中，存在一个方法叫 sendMessageDelay , 作用是延时发送消息，请解释一下Handler是如何实现延时发送消息的？<br />
Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？</p>
</blockquote>
<h2><a id="handler" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Handler</h2>
<p>我们先从Handler的定义来认识它，先上谷歌原文:</p>
<pre class="line-numbers"><code class="language-java">/**
 * A Handler allows you to send and process {@link Message} and Runnable
 * objects associated with a thread's {@link MessageQueue}.  Each Handler
 * instance is associated with a single thread and that thread's message
 * queue.  When you create a new Handler, it is bound to the thread /
 * message queue of the thread that is creating it -- from that point on,
 * it will deliver messages and runnables to that message queue and execute
 * them as they come out of the message queue.
 * 
 * &lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and
 * runnables to be executed at some point in the future; and (2) to enqueue
 * an action to be performed on a different thread than your own.
 * 
 * &lt;p&gt;Scheduling messages is accomplished with the
 * {@link #post}, {@link #postAtTime(Runnable, long)},
 * {@link #postDelayed}, {@link #sendEmptyMessage},
 * {@link #sendMessage}, {@link #sendMessageAtTime}, and
 * {@link #sendMessageDelayed} methods.  The &lt;em&gt;post&lt;/em&gt; versions allow
 * you to enqueue Runnable objects to be called by the message queue when
 * they are received; the &lt;em&gt;sendMessage&lt;/em&gt; versions allow you to enqueue
 * a {@link Message} object containing a bundle of data that will be
 * processed by the Handler's {@link #handleMessage} method (requiring that
 * you implement a subclass of Handler).
 * 
 * &lt;p&gt;When posting or sending to a Handler, you can either
 * allow the item to be processed as soon as the message queue is ready
 * to do so, or specify a delay before it gets processed or absolute time for
 * it to be processed.  The latter two allow you to implement timeouts,
 * ticks, and other timing-based behavior.
 * 
 * &lt;p&gt;When a
 * process is created for your application, its main thread is dedicated to
 * running a message queue that takes care of managing the top-level
 * application objects (activities, broadcast receivers, etc) and any windows
 * they create.  You can create your own threads, and communicate back with
 * the main application thread through a Handler.  This is done by calling
 * the same &lt;em&gt;post&lt;/em&gt; or &lt;em&gt;sendMessage&lt;/em&gt; methods as before, but from
 * your new thread.  The given Runnable or Message will then be scheduled
 * in the Handler's message queue and processed when appropriate.
 */
</code></pre>
<p>简单翻译一下：</p>
<ol>
<li>Handler是用来结合线程的消息队列来发送、处理Message对象和Runnable对象的工具。每一个Handler实例化之后会关联一个线程和该线程的消息队列。当你创建一个Handler的时候，它就会自动绑定到到所在的线程或线程的消息队列，并陆续把Message/Runnable分发到消息队列，然后在它们出队的时候去执行。</li>
<li>Handler主要有两个用途:  (1) 调度在将来某个时候执行的Message和Runnable。（2）把需要在另一个线程执行的操作加入到消息队列中去。</li>
<li>当post runnable或send message到handler时，您可以在消息队列准备就绪后立即处理该事务。也可以延迟一段时间执行，或者指定某个特定时间去执行。</li>
</ol>
<p>我们先从Handler的构造方法来认识一下它：</p>
<pre class="line-numbers"><code class="language-java">public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) 
</code></pre>
<p>Handler的构造方法有很多个，但最终调用的就是上述构造方法。</p>
<pre class="line-numbers"><code class="language-plain_text">* Use the provided {@link Looper} instead of the default one and take a callback
* interface in which to handle messages.  Also set whether the handler
* should be asynchronous.
*
* Handlers are synchronous by default unless this constructor is used to make
* one that is strictly asynchronous.
*
* Asynchronous messages represent interrupts or events that do not require global ordering
* with respect to synchronous messages.  Asynchronous messages are not subject to
* the synchronization barriers introduced by conditions such as display vsync.
</code></pre>
<ol>
<li>使用提供的Looper而不是默认的Looper，并使用回调接口来处理消息。还设置处理程序是否应该是异步的。</li>
<li>默认情况下，Handler是同步的，除非此构造函数用于生成严格异步的Handler。</li>
<li>异步消息指的是不需要进行全局排序的中断或事件。异步消息不受同步障碍(比如display vsync)的影响。</li>
</ol>
<hr />
<p>Handler中的方法主要分为以下两类：</p>
<p>获取及查询消息，比如 obtainMessage(int what),hasMessages(int what)。</p>
<p>将message或runnable添加/移出消息队列,比如 postAtTime(@NonNull Runnable r, long uptimeMillis),sendEmptyMessageDelayed(int what, long delayMillis)。</p>
<p>在这些方法中，我们重点需要关注一下enqueueMessage这个方法。</p>
<p>为什么呢?</p>
<p>无论是 <code>postAtTime</code>、<code>sendMessageDelayed</code>还是其他的<code>post</code>、<code>send</code>方法，它们最终都会调到<code>enqueueMessage</code>这个方法里去。</p>
<p>比如：</p>
<pre class="line-numbers"><code class="language-java">public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {
    if (delayMillis &lt; 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}
</code></pre>
<p>可以看到，sendMessageDelayed方法里将延迟时间转换为消息触发的绝对时间，最终调用的是sendMessageAtTime方法。</p>
<pre class="line-numbers"><code class="language-java">public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
</code></pre>
<p>而sendMessageAtTime方法调用了enqueueMessage方法。</p>
<pre class="line-numbers"><code class="language-java">private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,
        long uptimeMillis) {
    msg.target = this;
    msg.workSourceUid = ThreadLocalWorkSource.getUid();

    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre>
<h2><a id="message" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Message</h2>
<p>在分析<code>MessageQueue</code>之前，我们应该先来认识一下<code>Message</code>这个消息载体类。</p>
<p>老规矩，先从定义看起：</p>
<pre class="line-numbers"><code class="language-plain_text">* Defines a message containing a description and arbitrary data object that can be
* sent to a {@link Handler}.  This object contains two extra int fields and an
* extra object field that allow you to not do allocations in many cases.
*
* &lt;p class=&quot;note&quot;&gt;While the constructor of Message is public, the best way to get
* one of these is to call {@link #obtain Message.obtain()} or one of the
* {@link Handler#obtainMessage Handler.obtainMessage()} methods, which will pull
* them from a pool of recycled objects.&lt;/p&gt;
</code></pre>
<ol>
<li>定义一条包含描述和任意数据对象的消息，该对象可以发送到<code>Handler</code>。此对象包含两个额外的int字段和一个额外的object字段。</li>
<li>尽管<code>Message</code>的构造方法是public,但获取一个<code>Message</code>的最好的方法是调用<code>Message.obtain</code>或者<code>Handler.obtainMessage</code>方法，这些方法会从可回收的线程池中获取<code>Message</code>对象。</li>
</ol>
<p>我们来认识一下Message里的字段：</p>
<pre class="line-numbers"><code class="language-java">public final class Message implements Parcelable {
    //用户定义的标识码，以便接收者能够识别这条消息是关于什么的。
    //每个Handler都有自己的命名空间，因此不需要担心标识码与其他Handler的冲突。
    public int what;

    //如果只需要存储几个整数值，则arg1和arg2是使用setData(Bundle) setData()的低成本替代方案。
    public int arg1;
    
    public int arg2;

    //要发送给接收者的任意对象
    public Object obj;

    //通常在跨进程通讯中使用，让服务端能够得到客户端的信使对象,给客户端发消息
    public Messenger replyTo;

    //可选字段，指示发送消息的uid，仅对Messenger发布的消息有效，否则默认为-1
    public int sendingUid = UID_NONE;

    //可选字段，指示导致此消息排队的uid。
    public int workSourceUid = UID_NONE;

     //此标识在消息入队时设置，在创建或者获取新消息时清除
     //尝试入队或回收已在使用的消息会发送错误
    /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0;

    //设置是否是异步消息
    /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;

    //copyFrom方法中要清除的标志
    /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE;

    @UnsupportedAppUsage
    /*package*/ int flags;

    //Message发送的时间，基于SystemClock#uptimeMillis
    @UnsupportedAppUsage
    @VisibleForTesting(visibility = VisibleForTesting.Visibility.PACKAGE)
    public long when;

    /*package*/ Bundle data;
    
    //目标handler
    @UnsupportedAppUsage
    /*package*/ Handler target;

    @UnsupportedAppUsage
    /*package*/ Runnable callback;

    //使用单向链表储存下一个消息
    @UnsupportedAppUsage
    /*package*/ Message next;
}
</code></pre>
<p>在Message中，我们需要关注一下Message的回收机制。</p>
<p>先来看下<code>recyclerUnchecked</code>方法：</p>
<pre class="line-numbers"><code class="language-java">void recycleUnchecked() {
    // Mark the message as in use while it remains in the recycled object pool.
    // Clear out all other details.
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = UID_NONE;
    workSourceUid = UID_NONE;
    when = 0;
    target = null;
    callback = null;
    data = null;

    synchronized (sPoolSync) {
        if (sPoolSize &lt; MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}
</code></pre>
<p>在这个方法中，有三个关键变量。</p>
<ol>
<li><code>sPoolSync</code> ：主要是给Message加一个对象锁，不允许多个线程同时访问Message类和recycleUnchecked方法。</li>
<li><code>sPool</code>：存储我们循环利用Message的单链表。这里sPool只是链表的头节点。</li>
<li><code>sPoolSize</code>：单链表的链表的长度，即存储的Message对象的个数。</li>
</ol>
<p>当我们调用recycleUnchecked方法时，首先会将当前Message对象的属性清空。然后判断Message是否已到达缓存的上限（50个），如果没有，将当前的Message对象置于链表的头部。</p>
<p>那么取缓存的操作呢？</p>
<p>我们来看下<code>obtain</code>方法：</p>
<pre class="line-numbers"><code class="language-java">public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            m.flags = 0; // clear in-use flag
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}
</code></pre>
<p>可以看出，Message会尝试取出sPool链表的第一个元素，并将sPool的头元素往后移动一位。如果sPool链表为空，将会返回一个新的Message对象。</p>
<p>Message里提供obtain方法获取Message对象，使得Message到了重复的利用，减少了每次获取Message时去申请空间的时间。同时，这样也不会永无止境的去创建新对象，减小了Jvm垃圾回收的压力，提高了效率。</p>
<h2><a id="messagequeue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MessageQueue</h2>
<p><code>MessageQueue</code>用于保存由<code>Looper</code>发送的消息的列表。消息不会直接添加到消息队列，而是通过<code>Handler</code>对象中关联的<code>Looper</code>里的<code>MessageQueue</code>完成添加的动作。</p>
<p>您可以使用<code>Looper.myQueue()</code>检索当前线程的<code>MessageQueue</code>。</p>
<p>我们先来看看<code>MessageQueue</code>如何实现添加一个Message的操作。</p>
<pre class="line-numbers"><code class="language-java">boolean enqueueMessage(Message msg, long when) {
    //判断msg是否有target属性以及是否正在使用中
    if (msg.target == null) {
        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);
    }
    if (msg.isInUse()) {
        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);
    }

    synchronized (this) {
        if (mQuitting) {
            IllegalStateException e = new IllegalStateException(
                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);
            Log.w(TAG, e.getMessage(), e);
            msg.recycle();
            return false;
        }
        //将msg标识为正在使用
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when &lt; p.when) {
            // 如果队列为空，或者when==0,表示需要立即执行，或者执行时间早于链表第一个元素时间
            //将新的msg加入mMessage链表的第一位
            msg.next = p;
            mMessages = msg;
            //如果处于阻塞状态，需要唤醒队列
            needWake = mBlocked;
        } else {
            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
            Message prev;
            //此消息是一条延时消息，根据消息的when，通过for循环找到消息的插入点
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &lt; p.when) {
                    break;
                }
                if (needWake &amp;&amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            //插入消息
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            //唤醒消息
            nativeWake(mPtr);
        }
    }
    return true;
}
</code></pre>
<p><code>mMessages</code>是一个按照消息实际触发时间<code>msg.when</code>排序的链表，越往后的越晚触发。<code>enqueueMessage</code>方法根据新插入消息的when，将msg插入到链表中合适的位置。如果是及时消息，还需要唤醒<code>MessageQueue</code>。</p>
<p>我们接着来看看<code>nativeWake</code>方法，<code>nativeWake</code>方法的源码位于 <strong>\frameworks\base\core\jni\android_os_MessageQueue.cpp</strong> 。</p>
<pre class="line-numbers"><code class="language-java">static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) {
    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);
    nativeMessageQueue-&gt;wake();
}
</code></pre>
<p>继续看<code>NativeMessageQueue</code>里的wake函数。</p>
<pre class="line-numbers"><code class="language-java">void NativeMessageQueue::wake() {
    mLooper-&gt;wake();
}
</code></pre>
<p>它又转交给了Looper（源码位置 <strong>/system/core/libutils/Looper.cpp</strong>）去处理。</p>
<pre class="line-numbers"><code class="language-java">void Looper::wake() {
#if DEBUG_POLL_AND_WAKE
    ALOGD(&quot;%p ~ wake&quot;, this);
#endif

    uint64_t inc = 1;
    ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t)));
    if (nWrite != sizeof(uint64_t)) {
        if (errno != EAGAIN) {
            LOG_ALWAYS_FATAL(&quot;Could not write wake signal to fd %d (returned %zd): %s&quot;,
                             mWakeEventFd.get(), nWrite, strerror(errno));
        }
    }
}
</code></pre>
<p><code>Looper</code>里的<code>wake</code>函数很简单，它只是向<code>mWakeEventFd</code>里写入了一个 <strong>1</strong> 值。</p>
<p>上述的<code>mWakeEventFd</code>又是什么呢？</p>
<pre class="line-numbers"><code class="language-c">Looper::Looper(bool allowNonCallbacks)
    : mAllowNonCallbacks(allowNonCallbacks),
      mSendingMessage(false),
      mPolling(false),
      mEpollRebuildRequired(false),
      mNextRequestSeq(0),
      mResponseIndex(0),
      mNextMessageUptime(LLONG_MAX) {
      
    mWakeEventFd.reset(eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC));
 
     ...
}
</code></pre>
<p>从<code>Looper</code>的构造函数里可以找到答案，<code>mWakeEventFd</code>本质上是一个<code>eventfd</code>。至于什么是<code>eventfd</code>，这里只能说是<code>eventfd</code>是Linux 2.6提供的一种系统调用，它可以用来实现事件通知，更具体的内容需要各位读者自行查阅资料了。</p>
<p>既然有发送端，那么必然有接收端。接收端在哪呢？</p>
<pre class="line-numbers"><code class="language-c">void Looper::awoken() {
#if DEBUG_POLL_AND_WAKE
    ALOGD(&quot;%p ~ awoken&quot;, this);
#endif

    uint64_t counter;
    TEMP_FAILURE_RETRY(read(mWakeEventFd.get(), &amp;counter, sizeof(uint64_t)));
}
</code></pre>
<p>可以看到，<code>awoken</code>函数里的内容很简单，只是做了一个读取的动作，它并不关系读到的具体值是啥。为什么要这样设计呢，我们得结合<code>awoken</code>函数在哪里调用去分析。</p>
<p>awoken函数在<code>Looper</code>的<code>pollInner</code>函数里调用。<code>pollInner</code>函数里有一条语句</p>
<pre class="line-numbers"><code class="language-plain_text">int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);
</code></pre>
<p>它在这里起到阻塞的作用，如果没有调用nativeWake函数，epoll_wait将一直等待写入事件，直到超时为止。</p>
<p>如此，便回到我们文章一开始提出的问题了。</p>
<blockquote>
<p>Looper.loop是一个死循环，拿不到需要处理的Message就会阻塞，那在UI线程中为什么不会导致ANR？</p>
</blockquote>
<p>首先，我们需要明确一点，Handler中到底有没有阻塞?</p>
<p>答案是有！！！那它为什么不会导致ANR呢？</p>
<p>这得从ANR产生的原理说起。</p>
<p>ANR的本质也是一个Message,这一点很关键。我们拿前台服务的创建来举例，前台服务创建时，会发送一个<br />
<code>what</code>值为<code>ActivityManagerService.SERVICE_TIMEOUT_MSG</code>的延时20s的Message，如果Service的创建 工作在上述消息的延时时间内完成，则会移除该消息，否则，在Handler正常收到这个消息后，就会进行服务超时处理，即弹出ANR对话框。</p>
<p>为什么不会ANR，现在各位读者清楚了吗?ANR消息本身就是通过Handler去派发的，Handler阻塞与否与ANR并没有必然关系。</p>
<p>我们看了<code>MessageQueue</code>是如何加入一条消息的，接下来，我们来看看它是如何取出一条消息的。</p>
<pre class="line-numbers"><code class="language-java">Message next() {
    //如果消息循环已退出并已被释放，则return
    //如果应用程序在退出后尝试重新启动looper，则可能发生这种情况
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
        //将当前线程中挂起的所有Binder命令刷新到内核驱动程序。
        //在执行可能会阻塞很长时间的操作之前调用此函数非常有用，以确保已释放任何挂起的对象引用，
        //从而防止进程保留对象的时间超过需要的时间。
            Binder.flushPendingCommands();
        }

        //用于等待下一条可用消息,使用了linux epoll机制阻塞，不会占用cpu时间
        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // 尝试寻找下一条message
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null &amp;&amp; msg.target == null) {
                // 被障碍阻挡。查找队列中的下一条异步消息
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null &amp;&amp; !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now &lt; msg.when) {
                    //下一条消息尚未准备好。设置超时，以便在准备就绪时唤醒，超时时间为下一条消息触发时间和当前时间的时间差
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // 移出并返回链表第一条消息
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            //处理完所有挂起的消息后，立即处理退出消息
            if (mQuitting) {
                dispose();
                return null;
            }

            // 下面都是IdleHandler逻辑
            if (pendingIdleHandlerCount &lt; 0
                    &amp;&amp; (mMessages == null || now &lt; mMessages.when)) {
                pendingIdleHandlerCount = mIdleHandlers.size();
            }
            if (pendingIdleHandlerCount &lt;= 0) {
                // No idle handlers to run.  Loop and wait some more.
                mBlocked = true;
                continue;
            }

            if (mPendingIdleHandlers == null) {
                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];
            }
            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);
        }

        // Run the idle handlers.
        // We only ever reach this code block during the first iteration.
        for (int i = 0; i &lt; pendingIdleHandlerCount; i++) {
            final IdleHandler idler = mPendingIdleHandlers[i];
            mPendingIdleHandlers[i] = null; // release the reference to the handler

            boolean keep = false;
            try {
                keep = idler.queueIdle();
            } catch (Throwable t) {
                Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);
            }

            if (!keep) {
                synchronized (this) {
                    mIdleHandlers.remove(idler);
                }
            }
        }

        // Reset the idle handler count to 0 so we do not run them again.
        pendingIdleHandlerCount = 0;

        // While calling an idle handler, a new message could have been delivered
        // so go back and look again for a pending message without waiting.
        nextPollTimeoutMillis = 0;
    }
}
</code></pre>
<p><code>next</code>方法里主要做了三件事，</p>
<ol>
<li>使用<code>nativePollOnce</code>阻塞指定时间，等待下一条消息的执行。</li>
<li>获取下一条消息，并返回此消息。</li>
<li>如果消息队列为空，则执行IdleHandler。</li>
</ol>
<p>这里有个新名词<code>IdleHandler</code>，<code>IdleHandler</code>是可以在 Looper 事件循环的过程中，当出现空闲的时候，允许我们执行任务的一种机制。</p>
<p>MessageQueue中提供了<code>addIdleHandler</code>和<code>removeIdleHandler</code>去添加删除<code>IdleHandler</code>。</p>
<hr />
<p><code>next</code>方法的第一行有个<code>ptr</code>变量，这个<code>ptr</code>变量是什么含义呢？</p>
<pre class="line-numbers"><code class="language-java">MessageQueue(boolean quitAllowed) {
    mQuitAllowed = quitAllowed;
    mPtr = nativeInit();
}
</code></pre>
<p><code>mPtr</code>是一个<code>long</code>型变量，它是在<code>MessageQueue</code>的构造方法中，通过<code>nativeInit</code>方法初始化的。</p>
<pre class="line-numbers"><code class="language-java">static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) {
    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue();
    if (!nativeMessageQueue) {
        jniThrowRuntimeException(env, &quot;Unable to allocate native queue&quot;);
        return 0;
    }

    nativeMessageQueue-&gt;incStrong(env);
    return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);
}
</code></pre>
<p>可以看到，<code>ptr</code>的本质是对<code>jni</code>层的<code>NativeMessageQueue</code>对象的指针的引用。</p>
<p>我们重点来看下<code>nativePollOnce</code>方法，探寻一下<code>Handler</code>中的阻塞机制。<code>nativePollOnce</code>方法最终调用的是<code>Looper.cpp</code>中的<code>pollOnce</code>函数。</p>
<pre class="line-numbers"><code class="language-c">int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) {
    int result = 0;
    for (;;) { //一个死循环
        while (mResponseIndex &lt; mResponses.size()) {
            const Response&amp; response = mResponses.itemAt(mResponseIndex++);
            int ident = response.request.ident;
            if (ident &gt;= 0) {
                int fd = response.request.fd;
                int events = response.events;
                void* data = response.request.data;
#if DEBUG_POLL_AND_WAKE
                ALOGD(&quot;%p ~ pollOnce - returning signalled identifier %d: &quot;
                        &quot;fd=%d, events=0x%x, data=%p&quot;,
                        this, ident, fd, events, data);
#endif
                if (outFd != nullptr) *outFd = fd;
                if (outEvents != nullptr) *outEvents = events;
                if (outData != nullptr) *outData = data;
                return ident;
            }
        }

        if (result != 0) {
#if DEBUG_POLL_AND_WAKE
            ALOGD(&quot;%p ~ pollOnce - returning result %d&quot;, this, result);
#endif
            if (outFd != nullptr) *outFd = 0;
            if (outEvents != nullptr) *outEvents = 0;
            if (outData != nullptr) *outData = nullptr;
            return result;
        }

        result = pollInner(timeoutMillis);
    }
}
</code></pre>
<p>函数里有个关于<code>mResponses</code>的<code>while</code>循环，我们从java层调用的暂时不用管它，它是ndk的<code>handler</code>处理逻辑。我们重点来看<code>pollInner</code>函数。</p>
<pre class="line-numbers"><code class="language-c">int Looper::pollInner(int timeoutMillis) {
    // 根据下一条消息的到期时间调整超时。
    if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) {
        nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC);
        int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime);
        if (messageTimeoutMillis &gt;= 0
                &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) {
            timeoutMillis = messageTimeoutMillis;
        }
    }

    // 默认触发唤醒事件,POLL_WAKE == -1
    int result = POLL_WAKE;
    mResponses.clear();
    mResponseIndex = 0;

    // We are about to idle.
    mPolling = true;

    struct epoll_event eventItems[EPOLL_MAX_EVENTS];
    //等待写入事件，写入事件由awoken函数触发。timeoutMillis为超时时间，0立即返回，-1一直等待
    int eventCount = epoll_wait(mEpollFd.get(), eventItems, EPOLL_MAX_EVENTS, timeoutMillis);

    // No longer idling.
    mPolling = false;

    // Acquire lock.
    mLock.lock();

   ...

    // Check for poll error.
    if (eventCount &lt; 0) {
        if (errno == EINTR) {
            goto Done;
        }
        ALOGW(&quot;Poll failed with an unexpected error: %s&quot;, strerror(errno));
       //POLL_ERROR == -4
        result = POLL_ERROR;
        goto Done;
    }

    // Check for poll timeout.
    if (eventCount == 0) {
        //POLL_TIMEOUT == -3，epoll超时会走此分支
        result = POLL_TIMEOUT;
        goto Done;
    }

    // Handle all events.
    for (int i = 0; i &lt; eventCount; i++) {
        int fd = eventItems[i].data.fd;
        uint32_t epollEvents = eventItems[i].events;
        if (fd == mWakeEventFd.get()) {
            if (epollEvents &amp; EPOLLIN) {
                //将eventfd里的数值取出，无实际含义，只是为了清空epoll事件和eventfd里的数据
                awoken();
            } else {
                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on wake event fd.&quot;, epollEvents);
            }
        } else {
            //不会走到此分支，忽略它
            ssize_t requestIndex = mRequests.indexOfKey(fd);
            if (requestIndex &gt;= 0) {
                int events = 0;
                if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;
                if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;
                if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;
                if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;
                pushResponse(events, mRequests.valueAt(requestIndex));
            } else {
                ALOGW(&quot;Ignoring unexpected epoll events 0x%x on fd %d that is &quot;
                        &quot;no longer registered.&quot;, epollEvents, fd);
            }
        }
    }
Done: ;

    // 中间省略的代码不做探究，和ndk的handler实现有关
     ...
    return result;
}
</code></pre>
<p>可以看到，<code>pollInner</code>函数主要的逻辑是使用<code>epoll_wait</code>去读取唤醒事件，它有一个最大的等待时长，其最大等待时长和下一条消息的触发时间有关。</p>
<p>需要注意一下<code>pollInner</code>的返回值<code>result</code>,它有三种状态。进入方法默认为<code>POLL_WAKE</code>，表示触发唤醒事件。<br />
接下来通过对<code>epoll_wait</code>返回值的判断，它可能会变更为另两种状态。<code>epoll_wait</code>返回值为0，表示<code>epoll_wait</code>因超时而结束等待，<code>result</code>值设为<code>POLL_TIMEOUT</code>；<code>epoll_wait</code>返回值为-1，表示<code>epoll_wait</code>因系统中断等原因而结束等待，<code>result</code>值设为<code>POLL_ERROR</code>。但不管<code>result</code>值设为哪一个，都会导致<code>pollOnce</code>退出死循环，然代码流程回到java层的<code>next</code>方法中，去取得下一个<code>Message</code>对象。</p>
<p>因此，<code>nativePollOnce</code>简单意义上的理解，它就是一个阻断器，可以将当前线程阻塞，直到超时或者因需立即执行的新消息入队才结束阻塞。</p>
<h2><a id="looper" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Looper</h2>
<p>Handler 机制中，我们还剩最后一个一个模块没有分析———— Looper。我们先从官方定义来看起：</p>
<pre class="line-numbers"><code class="language-plain_text">* Class used to run a message loop for a thread.  Threads by default do
* not have a message loop associated with them; to create one, call
* {@link #prepare} in the thread that is to run the loop, and then
* {@link #loop} to have it process messages until the loop is stopped.
</code></pre>
<p>概括一下：</p>
<p>Looper是一个用于在线程中循环遍历消息的类。默认情况下，线程没有与之关联的消息循环；如果要创建一个，请在运行Looper的线程中调用Looper.prepare()，然后使用Looper.loop()让它处理消息直到循环停止。</p>
<p>上面的定义提到了两个比较关键的方法，我们一个一个来看。</p>
<h3><a id="looper-prepare" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Looper.prepare()</h3>
<pre class="line-numbers"><code class="language-java">private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}
</code></pre>
<p><code>prepare</code>的方法内容非常简单，创建一个<code>Looper</code>对象，并把它放到<code>sThreadLocal</code>里，其中<code>sThreadLocal</code>是一个<code>ThreadLocal</code>类。</p>
<p><code>ThreadLocal</code>类又是什么呢？</p>
<p>多线程访问同一个共享变量的时候容易出现并发问题，特别是多个线程对一个变量进行写入的时候，为了保证线程安全，一般使用者在访问共享变量的时候需要进行额外的同步措施才能保证线程安全性。<code>ThreadLocal</code>是除了加锁这种同步方式之外的一种保证一种规避多线程访问出现线程不安全的方法，当我们在创建一个变量后，如果每个线程对其进行访问的时候访问的都是线程自己的变量，这样就不会存在线程不安全问题。</p>
<p>因此，使用<code>ThreadLocal</code>能够保证不同线程的<code>Looper</code>对象都有一个独立的副本，它们彼此独立，互不干扰。</p>
<hr />
<h3><a id="looper-looper" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Looper.looper()</h3>
<pre class="line-numbers"><code class="language-java">public static void loop() {
    //获取当前线程的Looper对象
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
    }
    //获取与Looper关联的messagequeue
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'
    final int thresholdOverride =
            SystemProperties.getInt(&quot;log.looper.&quot;
                    + Process.myUid() + &quot;.&quot;
                    + Thread.currentThread().getName()
                    + &quot;.slow&quot;, 0);

    boolean slowDeliveryDetected = false;

    for (;;) {
        //进入死循环，不断去从MessageQueue中去拉取Message
        Message msg = queue.next(); // next方法我们已经在MessageQueue中做了分析
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

       
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;

        ...

        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            //注意这里,msg.target是一个handler对象，这个方法最终调用了handler的dispatchMessage
            //去做消息分发
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        
        //回收Message，上文中有做过分析
        msg.recycleUnchecked();
    }
}
</code></pre>
<p><code>loop</code>方法主要的工作是：建立一个死循环，不断的通过调用<code>MessageQueue</code>中的<code>next</code>方法获取下一个消息，并最终通过取得的消息关联的<code>handler</code>去完成消息的分发。</p>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<p>最后，我们再来理一理 <code>Handler</code>、<code>Message</code>、<code>MessageQueue</code>、<code>Looper</code>四者的关系和职责。</p>
<ul>
<li><strong>Handler</strong> : 消息分发的管理者。负责获取消息、封装消息、派发消息以及处理消息。</li>
<li><strong>Message</strong> ：消息的载体类。</li>
<li><strong>MessageQueue</strong> ：消息的容器。负责按消息的触发时间对消息入队出队，以及在合适的时间唤醒或休眠消息队列。</li>
<li><strong>Looper</strong> : 消息分发的执行者。负责从消息队列中拉去消息并交给handler去执行。</li>
</ul>
<p>为了更好的理解它们的关系，拿现实生活中的场景来举个例子：</p>
<blockquote>
<p>Handler是快递员，负责收快递，取快递，查快递以及退回快递。</p>
<p>Message是快递包裹，message的target属性就是收件地址，而延时消息就是收件人预约了派送时间，<br />
希望在指定的时间上门派送。</p>
<p>MessageQueue是菜鸟驿站，要对快递进行整理并摆放在合适的位置。</p>
<p>Looper是一个24小时不休息的资本家，他总是不停的在看菜鸟驿站有没有需要派送的快递，一有快递就立马取<br />
出然后压榨快递员去派送</p>
</blockquote>
<p>最后，我们用一张四者之间的流程图来结束整篇文章：</p>
<p><figure><img src="media/16533574488445/16533945926652.jpg" alt="" /></figure></p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="16534454393078.html" 
          title="Previous Post: Android APK安装流程解析 - PackageInstaller">&laquo; Android APK安装流程解析 - PackageInstaller</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="16533552753839.html" 
          title="Next Post: 深入理解Context">深入理解Context &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/16898402251241/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
