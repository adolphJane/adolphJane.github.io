<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207868790.html">
                
                  <h1>Android Thread</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">一、线程简介</h2>

<p>现在操作系统在运行一个程序时，会自动为其创建一个进程，不论是 PC 还是 Android。</p>

<p>一个进程内可以有多个线程，这些线程作为操作系统调度的最小单元，负责执行各种各样的任务，这些线程都拥有各自的计数器、堆栈、局部变量等属性，并且可以访问共享内存。</p>

<p>想象一下，如果你的电脑里只有一条线程在执行任务，一旦遇到 I/O 密集的任务，CPU 只能长时等待，效率很低。</p>

<p>如果把一个进程比作一个外卖公司，CPU 就是外卖公司拥有的主要资源（可以当做电动车），那线程（Thread）就是外卖公司中的一位送餐员，Runnable 就是送餐员要执行的任务（一般情况下都是送饭）。</p>

<h2 id="toc_1">二、线程创建的三种方式</h2>

<p>送餐员最重要的任务就是送餐，我们以代码来演示创建一个送餐员的三种方式：</p>

<h3 id="toc_2">(一) 实现 Runnable 接口</h3>

<pre class="line-numbers"><code class="language-java">public class ThreadTest0 {

    /**
     * 1.实现 Runnable 接口，在 run() 方法中写要执行的任务
     */
    static class Task implements Runnable{
        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
            Thread shixinzhang = new Thread(new Task(), &quot;外卖任务 &quot; + i);
            //3.命令送餐员出发！
            shixinzhang.start();
        }
    }
}
</code></pre>

<p>注意，上述代码中调用的是送餐员线程的 start() 方法，然后线程会调用 Task 对象的 run() 方法执行任务。运行结果如下：</p>

<p><code>外卖任务 3: 您的外卖已送达</code><br/><br/>
<code>外卖任务 1: 您的外卖已送达</code><br/><br/>
<code>外卖任务 0: 您的外卖已送达</code><br/><br/>
<code>外卖任务 2: 您的外卖已送达</code>  </p>

<p>可以看到执行任务的是各个线程。如果在 main() 方法中直接调用 run 方法，就相当于主线程直接执行任务，没有在子线程中进行。</p>

<p>直接在 main 中调用 run()：</p>

<pre class="line-numbers"><code class="language-java">public static void main(String[] args) {
    for (int i = 0; i &lt; 4; i++) {
        //2.创建一个送餐员线程，然后将任务传递给他，同时起个名
        Task task = new Task();
        Thread shixinzhang = new Thread(task, &quot;外卖任务 &quot; + i);
        //3.直接执行任务
        task.run();
    }
}
</code></pre>

<p>运行结果：</p>

<p><code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code><br/><br/>
<code>main: 您的外卖已送达</code>  </p>

<h3 id="toc_3">(二) 继承 Thread，重写其 run 方法</h3>

<pre class="line-numbers"><code class="language-java">public class ThreadTest1 {
    /**
     * 继承 Thread，重写 run 方法，在 run 方法中写要执行的任务
     */
    static class DeliverThread extends Thread{

        public DeliverThread(String name) {
            super(name);
        }

        @Override
        public void run() {
            try {
                Thread.sleep(new Random().nextInt(300
                ));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;: 您的外卖已送达&quot;);
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i &lt; 4; i++) {
            //2.创建一个送餐员线程，同时起个名
            DeliverThread shixinzhang = new DeliverThread(&quot;外卖任务&quot; + i);
            shixinzhang.start();
        }
    }
}
</code></pre>

<p>运行结果：</p>

<p><code>外卖任务1: 您的外卖已送达</code><br/><br/>
<code>外卖任务3: 您的外卖已送达</code><br/><br/>
<code>外卖任务0: 您的外卖已送达</code><br/><br/>
<code>外卖任务2: 您的外卖已送达</code>  </p>

<p>为什么直接继承 Thread 也可以在子线程中执行任务呢？</p>

<p>从 Thread 源码中我们可以看到， Thread 其实也实现了 Runnable ：<br/><br/>
<code>public class Thread implements Runnable</code>  </p>

<p>它内部也有一个 Runnable 的引用，我们调用 start() 方法后送餐员小张就蓄势以待准备出发了，之所以没说“立即出发送餐”，是因为此时可能电动车（CPU）正在被别人使用。</p>

<p>线程 start() 后操作系统会给他分配相关的资源，包括单独的程序计数器（可以理解为送餐员的任务本，上面记录了当前送餐任务的地址和下一个任务的地址）和栈，操作系统会把这个线程作为一个独立的个体进行调度，分配时间片让它执行。</p>

<p>等线程被 CPU 调度后就会执行线程中的 run() 方法，因此我们通过重写 Thread 的 run() 方法就可以达到在子线程执行任务的目的。</p>

<h3 id="toc_4">(三) 实现 Callable 接口，重写 call() 方法，用 FutureTask 获得结果</h3>

<pre class="line-numbers"><code class="language-java">public class CallableTest {
    /**
     * 实现 Callable 接口
     */
    static class DeliverCallable implements Callable&lt;String&gt; {
        /**
         * 执行方法，相当于 Runnable 的 run, 不过可以有返回值和抛出异常
         * @return
         * @throws Exception
         */
        @Override
        public String call() throws Exception {
            Thread.sleep(new Random().nextInt(10000));
            System.out.println(Thread.currentThread().getName() + &quot;：您的外卖已送达&quot;);
            return Thread.currentThread().getName() + &quot; 送达时间：&quot; + System.currentTimeMillis() + &quot;\n&quot;;
        }
    }

    /**
     * Callable 作为参数传递给 FutureTask，FutureTask 再作为参数传递给 Thread（类似 Runnable），然后就可以在子线程执行
     * @param args
     */
    public static void main(String[] args) {
        List&lt;FutureTask&lt;String&gt;&gt; futureTasks = new ArrayList&lt;&gt;(4);
        for (int i = 0; i &lt; 4; i++) {
            DeliverCallable callable = new DeliverCallable();
            FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(callable);
            futureTasks.add(futureTask);

            Thread thread = new Thread(futureTask, &quot;送餐员 &quot; + i);
            thread.start();
        }

        StringBuilder results = new StringBuilder();
        futureTasks.forEach(futureTask -&gt; {
            try {
                //获取线程返回结果，没返回就会阻塞
                results.append(futureTask.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        System.out.println(System.currentTimeMillis() + &quot; 得到结果：\n&quot; + results);
    }
}
</code></pre>

<p>第三种创建线程的方式与前两种的不同之处在于，以 Callable 作为任务，而不是 Runnable，这种方式的好处是可以获得结果和响应中断。</p>

<p>运行结果：  </p>

<pre class="line-numbers"><code class="language-text">送餐员 3：您的外卖已送达  
送餐员 1：您的外卖已送达  
送餐员 0：您的外卖已送达  
送餐员 2：您的外卖已送达  
1487998155430 得到结果： 
送餐员 0 送达时间：1487998155076 
送餐员 1 送达时间：1487998150453 
送餐员 2 送达时间：1487998155430 
送餐员 3 送达时间：1487998149779
</code></pre>

<h2 id="toc_5">三、线程的基本属性</h2>

<h3 id="toc_6">(一) 优先级</h3>

<p>Thread 有个优先级字段：private int priority</p>

<p>操作系统采用时间片（CPU 单次执行某线程的时间）的形式来调度线程的运行，线程被 CPU 调用的时间超过它的时间片后，就会发生线程调度。</p>

<p>线程的优先级可以在一定程度上影响它得到时间片的多少，也就是被处理的机会。</p>

<p>Java 中 Thread 的优先级为从 1 到 10 逐渐提高，默认为 5。</p>

<p>有长耗时操作的线程，一般建议设置低优先级，确保处理器不会被独占太久； <br/>
频繁阻塞（休眠或者 I/O）的线程建议设置高优先级。  </p>

<pre class="line-numbers"><code class="language-java"> public final static int MIN_PRIORITY = 1;

 //线程的默认优先级
 public final static int NORM_PRIORITY = 5;

 public final static int MAX_PRIORITY = 10;
</code></pre>

<blockquote>
<p>线程优先级只是对操作系统分配时间片的建议。 <br/>
虽然 Java 提供了 10 个优先级别，但不同的操作系统的优先级并不相同，不能很好的和 Java 的 10 个优先级别对应。&gt;所以我们应该使用 MAX_PRIORITY、MIN_PRIORITY 和 NORM_PRIORITY 三个静态常量来设定优先级，这样才能保证程序最好的可移植性。</p>
</blockquote>

<h3 id="toc_7">(二) 守护线程</h3>

<p>Java 中，线程也分三六九等。守护线程相当于小弟，做一些后台调度、支持性工作,比如 JVM 的垃圾回收、内存管理等线程都是守护线程。</p>

<p>Thread 中有个布尔值标识当前线程是否为守护线程：</p>

<p><code>private boolean     daemon = false;</code></p>

<p>同时也提供了设置和查看当前线程是否为守护线程的方法：</p>

<pre class="line-numbers"><code class="language-java">public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        throw new IllegalThreadStateException();
    }
    daemon = on;
}

public final boolean isDaemon() {
    return daemon;
}
</code></pre>

<blockquote>
<p>Daemon 属性需要在调用线程的 start() 方法之前调用。</p>
</blockquote>

<p>一个进程中，如果所有线程都退出了，Java 虚拟机就会退出。注意了，这里的“所有”就不包括守护线程，也就是说，当除守护线程外的其他线程都结束后，Java 虚拟机就会退出，然后将守护进程终止。</p>

<p><strong>这里需要注意的是，由于上述特性，Java 虚拟机退出后，在守护线程中的 finally 块中的代码不一定执行。</strong></p>

<p>举个例子：</p>

<pre class="line-numbers"><code class="language-java">public class DaemonTreadTest0 {
    static class DaemonThread extends Thread{
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                System.out.println(Thread.currentThread().getName() + &quot; finally is called!&quot;);
            }
        }
    }

    public static void main(String[] args) {
        DaemonThread thread = new DaemonThread();
        thread.setDaemon(true);
        thread.start();
    }
}
</code></pre>

<p>上述代码中将线程设置为守护线程，由于 main 线程启动 DaemonThread 后就结束，此时虚拟机中没有非守护线程，虚拟机也会退出，守护进程被终止，但是它的 finally 块中的内容却没有被调用。</p>

<p>如果将setDaemon方法注释掉，就会发现有运行结果:</p>

<p><code>Thread-0 finally is called!</code></p>

<p>因此，守护线程中不能依靠 finally 块进行资源关闭和清理。</p>

<h2 id="toc_8">四、线程的生命周期</h2>

<p>线程具有如下几个状态：</p>

<table>
<thead>
<tr>
<th>线程状态</th>
<th style="text-align: center">介绍</th>
<th style="text-align: left">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td>NEW</td>
<td style="text-align: center">新创建</td>
<td style="text-align: left">还未调用 start() 方法；还不是活着的 (alive)</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td style="text-align: center">就绪的</td>
<td style="text-align: left">调用了 start() ，此时线程已经准备好被执行，处于就绪队列；是活着的(alive)</td>
</tr>
<tr>
<td>RUNNING</td>
<td style="text-align: center">运行中</td>
<td style="text-align: left">线程获得 CPU 资源，正在执行任务；活着的</td>
</tr>
<tr>
<td>BLOCKED</td>
<td style="text-align: center">阻塞的</td>
<td style="text-align: left">线程阻塞于锁或者调用了 sleep；活着的</td>
</tr>
<tr>
<td>WAITING</td>
<td style="text-align: center">等待中</td>
<td style="text-align: left">线程由于某种原因等待其他线程；或者的</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td style="text-align: center">超时等待</td>
<td style="text-align: left">与 WAITING 的区别是可以在特定时间后自动返回；活着的</td>
</tr>
<tr>
<td>TERMINATED</td>
<td style="text-align: center">终止</td>
<td style="text-align: left">执行完毕或者被其他线程杀死；不是活着的</td>
</tr>
</tbody>
</table>

<p>有几点注意：</p>

<ul>
<li>Java 中的 Thread 运行状态没有 RUNNING 这一步，运行中的线程状态是 RUNNABLE</li>
<li>三个让线程进入 WAITING 状态的方法 
<ul>
<li>Object.wait()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
<li>Lock.lock()</li>
</ul></li>
</ul>

<p><strong>Java 中关于“线程是否活着”的定义</strong></p>

<p>Thread 中有个判断是否为活着的方法：<br/><br/>
<code>public final native boolean isAlive()</code></p>

<p>Java 中线程除了 NEW 和 TERMINITED 状态，其他状态下调用 isAlive() 方法均返回 true，也就是活着的。</p>

<h2 id="toc_9">五、线程的关键方法</h2>

<h3 id="toc_10">(一) Thread.sleep()</h3>

<p>Thread.sleep() 是一个静态方法：</p>

<p><code>public static native void sleep(long millis) throws InterruptedException;</code></p>

<p>sleep() 方法：</p>

<ul>
<li>使当前所在线程进入阻塞</li>
<li>只是让出 CPU ，并没有释放对象锁</li>
<li>由于休眠时间结束后不一定会立即被 CPU 调度，因此线程休眠的时间可能大于传入参数</li>
<li>如果被中断会抛出 InterruptedException</li>
</ul>

<p><strong>注意上面的第一条！由于 sleep 是静态方法，它的作用时使当前所在线程祖舍。因此最好在线程内部直接调用 Thread.sleep()，如果你在主线程调用某个线程的 sleep() 方法，其实阻塞的是主线程！</strong></p>

<h3 id="toc_11">(二) Object.wait()</h3>

<p>与 Thread.sleep() 容易混淆的是 Object.wait() 方法。</p>

<p>Object.wait() 方法：</p>

<ul>
<li>让出 CPU，释放对象锁</li>
<li>在调用前需要先拥有某对象的锁，所以一般在 synchronized 同步块中使用</li>
<li>使该线程进入该对象监视器的等待队列</li>
</ul>

<h3 id="toc_12">(三) Thread.yield()</h3>

<p>Thread. yield() 也是一个静态方法：</p>

<p><code>public static native void yield();</code></p>

<p>“Thread.yield() 表示暂停当前线程，让出 CPU 给优先级与当前线程相同，或者优先级比当前线程更高的就绪状态的线程。</p>

<ul>
<li>和 sleep() 方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。</li>
<li>yield() 方法只是让当前线程暂停一下，重新进入就绪的线程池中。</li>
</ul>

<blockquote>
<p>yield() 一般使用较少。</p>
</blockquote>

<h3 id="toc_13">(四) Thread.join()</h3>

<p>Thread.join() 表示线程合并，调用线程会进入阻塞状态，需要等待被调用线程结束后才可以执行。</p>

<blockquote>
<p>线程的合并的含义就是将几个并发执行线程的线程合并为一个单线程执行。</p>
</blockquote>

<p>比如下述代码：</p>

<pre class="line-numbers"><code class="language-java">Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;thread is running!&quot;);
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
});
thread.start();
thread.join();
System.out.println(&quot;main thread &quot;);
</code></pre>

<p>我们在主线程调用了 thread.join() 方法，该线程会在输出一句话后休眠 5 秒，等该线程结束后主线程才可以继续执行，输出最后一句结果：</p>

<blockquote>
<p>thread is running! <br/>
main thread</p>
</blockquote>

<p>Thread.join 源码：</p>

<pre class="line-numbers"><code class="language-java">//无参方法
public final void join() throws InterruptedException {
    join(0);
}
//有参方法，表示等待 millis 毫秒后自动返回
public final synchronized void join(long millis)
throws InterruptedException {
    long base = System.currentTimeMillis();
    long now = 0;

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (millis == 0) {
        while (isAlive()) {
            wait(0);
        }
    } else {
        while (isAlive()) {
            long delay = millis - now;
            if (delay &lt;= 0) {
                break;
            }
            wait(delay);
            now = System.currentTimeMillis() - base;
        }
    }
}
//有参方法，表示等待 millis + (nanos - 50000) 毫秒后结束
public final synchronized void join(long millis, int nanos)
throws InterruptedException {

    if (millis &lt; 0) {
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    }

    if (nanos &lt; 0 || nanos &gt; 999999) {
        throw new IllegalArgumentException(
                            &quot;nanosecond timeout value out of range&quot;);
    }

    if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) {
        millis++;
    }

    join(millis);
}
</code></pre>

<p>通过源码可以发现，Thread.join 是通过 synchronized + Object.wait() 实现的。</p>

<p>Thread.join 的应用场景是：当一个线程必须等待其他线程执行完毕才能继续执行，比如合并计算。</p>

<h2 id="toc_14">六、线程的中断</h2>

<p>有时候我们需要中断一个正在运行的线程，一种很容易想到的方法是在线程的 run() 方法中加一个循环条件：</p>

<pre class="line-numbers"><code class="language-java">public class ThreadInterruptTest1 {
    static class InterruptThread extends Thread{
        private boolean running;

        public InterruptThread(boolean running) {
            this.running = running;
        }

        public boolean isRunning() {
            return running;
        }

        public void setRunning(boolean running) {
            this.running = running;
        }

        @Override
        public void run() {
            while (running){
                System.out.println(Thread.currentThread().getName() + &quot; is running&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        InterruptThread thread = new InterruptThread(true);
        thread.start();

        Thread.sleep(5000);
        thread.setRunning(false);
    }
}
</code></pre>

<p>上面的代码中线程 InterruptThread 有一个标志位 running，当这个标志位为 true 时才可以运行。 <br/>
因此我们可以通过修改这个标志位为 false 来中断该线程。</p>

<p>其实 Thread 内部也为我们提供了同样的机制 ：</p>

<table>
<thead>
<tr>
<th>方法名</th>
<th style="text-align: center">方法介绍</th>
</tr>
</thead>

<tbody>
<tr>
<td>public void interrupt()</td>
<td style="text-align: center">试图中断调用线程，设置中断标志位为 false</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td style="text-align: center">返回调用线程是否被中断</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td style="text-align: center">返回当前线程是否被中断的状态值，同时将中断标志位复位（设为 false）</td>
</tr>
</tbody>
</table>

<h3 id="toc_15">(一) public void interrupt()</h3>

<p>它的作用是设置标志位为 false，能否达到中断调用线程的效果，还取决于该线程是否可以响应中断（说直白些就是吃不吃这套），比如 Runnable 的 run() 方法就无法响应中断。</p>

<p>因此我们对执行 Runnable 任务的线程调用 interrupt() 方法后，该线程也不会中断，举个例子：</p>

<pre class="line-numbers"><code class="language-java">public class ThreadInterruptTest2 {

    static class UnInterruptThread extends Thread{
        public UnInterruptThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    static class  UnInterruptRunnable implements Runnable{

        @Override
        public void run() {
            while (true) {
                System.out.println(Thread.currentThread().getName() + &quot; is running!&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        UnInterruptThread thread = new UnInterruptThread(&quot;无法中断的线程&quot;);
//        Thread thread = new Thread(new UnInterruptRunnable(), &quot;无法中断&quot;);
        thread.start();

        //先让它执行一秒
        Thread.sleep(1000);

        thread.interrupt();

        //不立即退出
        Thread.sleep(3000);
    }
}
</code></pre>

<p>这两种方式创建的线程，在调用 thread.interrupt() 方法后仍然会继续执行！</p>

<p>这时就需要用到上面 Thread 提供的第二个关于中断的方法 isInterrupted() 了。</p>

<h3 id="toc_16">(二) public boolean isInterrupted()</h3>

<p>我们可以通过 isInterrupted() 知道调用线程是否被中断，以此来作为线程是否运行的判断标志。</p>

<blockquote>
<p>isInterrupted() 在刚创建时默认为 false 不用多说； <br/>
线程有许多方法可以响应中断（比如 Thread.sleep()，Thread.wait()），这些方法在收到中断请求、抛出 InterruptedException 之前，JVM 会先把该线程的中断标志位复位，这时调用 isInterrupted 将会返回 false； <br/>
线程结束后，线程的中断标志位也会复位为 false。</p>
</blockquote>

<p>举个例子：</p>

<pre class="line-numbers"><code class="language-java">/**
 * 线程中断练习
 * Created by zhangshixin on 17/2/25.
 * http://blog.csdn.net/u011240877
 */
public class ThreadInterruptTest {
    /**
     * 调用 Thread.sleep() 方法的线程，线程如果在 sleep 时被中断，会抛出 InterruptedException
     * 我们在代码中进行捕获，并且查看 JVM 是否将中断标志位重置
     */
    static class SleepThread extends Thread{
        public SleepThread(String s) {
            setName(s);
        }
        @Override
        public void run() {
            while (!isInterrupted()){
                try {
                    Thread.sleep(500);
                    System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    System.out.println(&quot;SleepRunner 在 sleep 时被中断了，此时中断标志位为：&quot; + isInterrupted());
                }
            }
        }
    }

    /**
     * 希望通过这个线程了解：线程运行结束后，中断标志位会重置
     */
    static class BusyThread extends Thread{

        public BusyThread(String s) {
            setName(s);
        }

        @Override
        public void run() {
            while (!isInterrupted()){
                System.out.println(Thread.currentThread().getName() + System.currentTimeMillis());
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SleepThread sleepThread = new SleepThread(&quot;SleepRunner：&quot;);
        BusyThread busyThread = new BusyThread(&quot;BusyRunner：&quot;);
        //新创建的线程 中断标志为 false
        System.out.println(&quot;SleepThread 新创建时的中断标志位：&quot; + sleepThread.isInterrupted());

        Thread.sleep(2000);
        //启动两个线程
        sleepThread.start();
        busyThread.start();
        //让它们运行一秒
        Thread.sleep(1000);
        //分别中断两个线程
        sleepThread.interrupt();
        busyThread.interrupt();
        //查看线程的中断标志位
        Thread.sleep(2000);
        System.out.println(&quot;由于中断标志位变为 true 导致运行结束的线程，中断标志位为: &quot; + busyThread.isInterrupted());

        Thread.sleep(1000);
    }
}
</code></pre>

<p>上述代码中 两个线程都使用 isInterrupted 作为循环执行任务的条件，其中 SleepThread 方法调用了 Thread.sleep，这个方法的会响应中断，抛出异常。</p>

<p>运行结果如下：</p>

<p><figure><img src="media/15561207868790/15713244513325.png" alt=""/></figure></p>

<p>可以看到：</p>

<ul>
<li>线程中，在抛出 InterruptedException 前 JVM 的确会重置中断标志位为 false</li>
<li>这将导致以 isInterrupted 方法作为循环执行任务的线程无法正确中断</li>
</ul>

<h3 id="toc_17">(三) public static boolean interrupted()</h3>

<p><code>Thread.interrupted()</code> 方法是一个静态方法，它会返回调用线程（而不是被调用线程）的中断标志位，返回后重置中断标志位。</p>

<p>因此 <code>Thread.interrupted()</code> 第二次调用永远返回 false。</p>

<p>源码：</p>

<pre class="line-numbers"><code class="language-java">public static boolean interrupted() {
    return currentThread().isInterrupted(true);
}
</code></pre>

<h2 id="toc_18">七、总结</h2>

<p>这篇文章总结了 线程的基本概念和关键方法，还有一些不建议使用的方法没有介绍，是因为它们有很多副作用，比如 suspend() 方法在调用后虽然线程会进入休眠状态，却不会释放资源，很容易引发死锁问题；同样，stop() 方法终结一个线程时无法保证这个线程有机会释放资源，也会导致一些不确定问题。</p>

<p>我们可以通过下面的图片整体分析线程的生命周期和主要方法：<br/><br/>
<figure><img src="media/15561207868790/15713244633003.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868717.html">
                
                  <h1>Android Wi-Fi 直连</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Wi-Fi直连是Android 4.0(API level 14)或更高的版本的才加入的新功能，使用Wi-Fi直连相关的API可以发现并连接支持Wi-Fi直连的设备，连接之后设备之间可以通信，传输的距离比蓝牙的传输距离要远很多</p>

<h2 id="toc_0">API 概述</h2>

<ul>
<li>Wi-Fi直连的方法<br/>
类WifiP2pManager提供了一些方法来使用Wi-Fi直连的相关的接口来发现连接设备<br/></li>
</ul>

<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>initialize()</td>
<td style="text-align: center">在Wi-Fi框架中注册，必须在其他方法之前调用</td>
</tr>
<tr>
<td>connect()</td>
<td style="text-align: center">和另外的直连设备连接</td>
</tr>
<tr>
<td>cancelConnect()</td>
<td style="text-align: center">取消正在连接的动作</td>
</tr>
<tr>
<td>requestConnectInfo()</td>
<td style="text-align: center">请求已经连接的信息</td>
</tr>
<tr>
<td>createGroup()</td>
<td style="text-align: center">创建直连的设备组</td>
</tr>
<tr>
<td>removeGroup()</td>
<td style="text-align: center">删除当前的设置组</td>
</tr>
<tr>
<td>requestGroupInfo()</td>
<td style="text-align: center">请求当前组的信息</td>
</tr>
<tr>
<td>discoverPeers()</td>
<td style="text-align: center">初始化搜索</td>
</tr>
<tr>
<td>requestPeers()</td>
<td style="text-align: center">请求已经发现的设备的列表</td>
</tr>
</tbody>
</table>

<ul>
<li>Wi-Fi直连的监听<br/>
类WifiP2pManager中也提供了很多的监听接口，计时的通知当前的 activity相关的搜索和连接的<br/>
结果</li>
</ul>

<table>
<thead>
<tr>
<th>接口</th>
<th style="text-align: center">相关的操作</th>
</tr>
</thead>

<tbody>
<tr>
<td>WifiP2pManager.ActionListener</td>
<td style="text-align: center">相关的操作：connect(), cancelConnect(), createGroup(), removeGroup(), and discoverPeers()</td>
</tr>
<tr>
<td>WifiP2pManager.ChannelListener</td>
<td style="text-align: center">相关的操作：initialize()</td>
</tr>
<tr>
<td>WifiP2pManager.ConnectionInfoListener</td>
<td style="text-align: center">相关的操作：requestConnectInfo()</td>
</tr>
<tr>
<td>WifiP2pManager.GroupInfoListener</td>
<td style="text-align: center">相关的操作：requestGroupInfo()</td>
</tr>
<tr>
<td>WifiP2pManager.PeerListListener</td>
<td style="text-align: center">相关的操作：requestPeers()</td>
</tr>
</tbody>
</table>

<ul>
<li>Wi-Fi直连的Intent</li>
</ul>

<table>
<thead>
<tr>
<th>Intent</th>
<th style="text-align: center">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>WIFI_P2P_CONNECTION_CHANGED_ACTION</td>
<td style="text-align: center">当设备的Wi-Fi的连接状态发生变化时触发</td>
</tr>
<tr>
<td>WIFI_P2P_PEERS_CHANGED_ACTION</td>
<td style="text-align: center">在调用discoverPeers()时触发，可以调用requestPeers()方法更新设备列表</td>
</tr>
<tr>
<td>WIFI_P2P_STATE_CHANGED_ACTION</td>
<td style="text-align: center">Wi-Fi直连的状态发生变化时触发</td>
</tr>
<tr>
<td>WIFI_P2P_THIS_DEVICE_CHANGED_ACTION</td>
<td style="text-align: center">Wi-Fi直连的设备的详细信息发生变化时触发</td>
</tr>
</tbody>
</table>

<h2 id="toc_1">创建Wi-Fi直连的应用</h2>

<ul>
<li>初始化设置<br/>
首先要保证设置支持Wi-Fi直连相关的协议，如果支持，我们就可以获得WifiP2pManager的实例，创建并注册相关的广播，使用相关的<br/>
api<br/>
在AndroidManifest中必须声明相关的权限,Wi-Fi直连是在api level 14及更高的版本才能使用，还要声明<code>android:minSdkVersion=&quot;14&quot;</code></li>
</ul>

<pre class="line-numbers"><code class="language-text">&lt;uses-sdk android:minSdkVersion=&quot;14&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
</code></pre>

<ul>
<li>初始化WifiP2pManager的实例，并注册相关的广播，监听Wi-Fi直连的状态<br/>
``` java<br/>
private WifiP2pManager mManager;<br/>
private Channel mChannel;<br/>
private IntentFilter directFilter;<br/>
private WiFiDirectReceiver directReceiver ;</li>
</ul>

<p>@Override<br/>
protected void onCreate(Bundle savedInstanceState) {<br/>
  super.onCreate(savedInstanceState);<br/>
  setContentView(R.layout.activity_main);</p>

<p>mManager = (WifiP2pManager)this.getSystemService(Context.WIFI_P2P_SERVICE);<br/>
  mChannel = mManager.initialize(this, this.getMainLooper(), null);<br/>
  directReceiver = new WiFiDirectReceiver(mManager, mChannel, this);</p>

<p>directFilter = new IntentFilter();<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);<br/>
  directFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);</p>

<p>}</p>

<p>//注册广播监听<br/>
@Override<br/>
protected void onResume() {<br/>
  super.onResume();<br/>
  this.registerReceiver(directReceiver, directFilter);<br/>
}</p>

<p>//取消注册<br/>
@Override<br/>
protected void onPause() {<br/>
  super.onPause();<br/>
  this.unregisterReceiver(directReceiver);<br/>
}</p>

<pre class="line-numbers"><code class="language-text">
- 广播接受

``` java
public class WiFiDirectReceiver extends BroadcastReceiver{

    private WifiP2pManager mManager;
    private Channel mChannel;
    private MainActivity mActivity;
    private PeerListListener mListener;
    private WifiP2pConfig mConfig = new WifiP2pConfig();

    public WiFiDirectReceiver(){}

    public WiFiDirectReceiver(WifiP2pManager manager,Channel channel,MainActivity activity){
        this.mManager = manager;
        this.mChannel = channel;
        this.mActivity = activity;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        Log.e(&quot;tag&quot;, &quot;===============wifi direct action: &quot;+action);
        if(action.equals(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)){
            int state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1);
            if(state == WifiP2pManager.WIFI_P2P_STATE_ENABLED){
                //打开
            }else if(state == WifiP2pManager.WIFI_P2P_STATE_DISABLED){
                //关闭
            }
        }else if(action.equals(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)){

        }else if(action.equals(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)){

        }else if(action.equals(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)){

        }
    }
}
</code></pre>

<ul>
<li>发现设备</li>
</ul>

<p>在调用之后initialize()方法之后，会触发<code>WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION</code>的广播，在BroadcastReceiver<br/>
中，如果WifiP2pManager.WIFI_P2P_STATE_ENABLED的状态已经打开，在BroadcastReceiver调用discoverPeers方法,如果发现设备.</p>

<p>会回调onSuccess方法  </p>

<pre class="line-numbers"><code class="language-java">mManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() {
@Override
                    public void onSuccess() {
                        Log.e(&quot;tag&quot;, &quot;===================discovery success&quot;);
                    }

                    @Override
                    public void onFailure(int reason) {
                        Log.e(&quot;tag&quot;, &quot;===================discovery failed&quot;);
                    }
});
</code></pre>

<p>如果发现设备，系统会触发WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION这个广播，在这个广播中可以调用requestPeers方法可以列出所有的设备</p>

<pre class="line-numbers"><code class="language-java">if(null != mManager){
    mManager.requestPeers(mChannel, new WifiP2pManager.PeerListListener() {
        @Override
        public void onPeersAvailable(WifiP2pDeviceList peers) {
            Log.e(&quot;tag&quot;, &quot;==================peers list size: &quot;+peers.getDeviceList().size());
            for(WifiP2pDevice device: peers.getDeviceList()){
                Log.e(&quot;tag&quot;, &quot;==================device addr: &quot;+device.deviceName+&quot; name: &quot;+device.deviceName);
            }
        }
    });
}
</code></pre>

<ul>
<li>连接设备<br/>
对于已经发现的设备我们可以调用connect()方法连接，需要初始化WifiP2pConfig,并设置config的deviceAddress</li>
</ul>

<pre class="line-numbers"><code class="language-java">private WifiP2pConfig mConfig = new WifiP2pConfig();  
mConfig.deviceAddress = device.deviceAddress;
mManager.connect(mChannel, mConfig, new WifiP2pManager.ActionListener() {
    @Override
    public void onSuccess() {
        Log.e(&quot;tag&quot;, &quot;==============connnect success&quot;);
    }
    @Override
    public void onFailure(int reason) {
        Log.e(&quot;tag&quot;, &quot;=================connect failed&quot;);
    }
});
</code></pre>

<p>连接成功会回调onSuccess方法</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/02/02</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868648.html">
                
                  <h1>Android 权限机制</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><figure><img src="media/15561207868648/15713243037328.png" alt=""/></figure></p>

<h2 id="toc_0">一、概要</h2>

<p>Android M已经发布一段时间了，市面上很多应用都已经适配Android M。权限机制，作为Android M的一大特性，受到了很多开发者的关注。本文主要分享了以下几个知识点的内容，1、Android权限机制关键知识点；2、QQ音乐对于权限的适配经验；3、近段时间以来遇到的一些Android权限方面的问题。OK，下面进入主题。</p>

<h2 id="toc_1">二、Android权限机制</h2>

<p>已经了解过基本知识的，建议直接跳到第三点（QQ音乐的权限适配经验）。</p>

<p>Android6.0以前，Android的权限机制比较简单，开发者在AndroidManifest文件中声明需要的权限，APP安装时，系统提示用户APP将获取的权限，需要用户同意授权才能继续安装，从此APP便永久的获得了授权。然而，同期的iOS对于权限的处理会更加灵活，权限的授予并不是在安装时，而是在APP运行时，用户可以根据自身的需要，决定是否授予APP某一权限，同时，用户也可以很方便回收授予的权限。显然，动态权限管理的机制，对于用户的隐私保护是更加适用的，Android过于简单的权限机制也受到了不少人的吐槽。终于，Android6.0也发布了动态权限的机制。</p>

<h3 id="toc_2">(一) 开始适配和如何兼容</h3>

<p>APP要适配Android6.0非常简单，只需要将targetSdkVersion和compileSdkVersion都升级到23及以上，同时加入权限检查申请等代码逻辑即可。这里很多人会有一些疑惑，如果针对旧版本的APP在Android6.0机型上运行或者针对Android6.0适配了的APP在Android6.0以下机型上运行，会有什么表现呢？是如何兼容的呢？</p>

<p>1、首先，旧版本APP（targetSdkVersion低于23），因为没有适配权限的申请相关逻辑，在Android6.0以上机型运行的时候，仍然采用安装时授权的方案。</p>

<p>2、适配了Android6.0的APP，在低版本Android系统上运行的时候，仍然采用安装时授权的方案，但是开发者需要注意的是，权限申请的代码逻辑只应该在Android6.0及以上的机型被执行。</p>

<h3 id="toc_3">(二) 危险权限与普通权限</h3>

<p>一开始，听到要加入权限判断和申请代码逻辑的程序员内心可能是崩溃的：正常的一个有一定规模的APP，很容易就七七八八的声明了很多权限，如果每个权限都申请岂不是非常麻烦？</p>

<p>好歹，Google还算比较明智，并不是所有的权限都需要运行时申请才能使用。Google对每个权限的隐私危害性进行了评估。将权限分为了两大类：普通权限和危险权限。举个例子，控制手机震动的权限对于用户并没有什么危害，只要开发者声明了这个权限，安装后就可以一直被授权，也不能被回收，但是，像读取sd卡数据这类权限，很显然就是危险权限了，APP必须向用户申请这个权限。</p>

<p>Google还是很体贴我们开发者的，为了进一步减少开发的工作量和申请权限对用户的骚扰，对危险权限根据各自的属性进行了分组。举个例子，读sd卡和写sd卡，这两个权限通常都是成对声明和使用的，因此，它们被分为一组，而且，只要我们获取了这个权限组里面的任意一个权限，就可以获取整个权限组的权限。Google对于危险权限的定义和分组见下图。<br/><br/>
<figure><img src="media/15561207868648/15713243171181.png" alt=""/></figure></p>

<h3 id="toc_4">(三) 权限相关API说明</h3>

<p>首先，在动态权限申请的流程中，开发者主要关注流程和API如下：</p>

<h4 id="toc_5">1、检查权限是否授予。</h4>

<p>Activity.java<br/>
<code>public int checkSelfPermission(permission)</code></p>

<h4 id="toc_6">2、申请权限。</h4>

<p>Activity.java<br/><br/>
<code>public final void requestPermissions( new String[permission1,permission2,...], requestCode)</code></p>

<p>这个时候，会弹出系统授权弹窗<strong>（授权弹窗是不支持自定义的，原因理所当然）</strong>。</p>

<h4 id="toc_7">3、权限回调。</h4>

<p>用户在系统弹窗里面选择后，结果会通过Activity的<code>onRequestPermissionsResult</code>方法回调APP。</p>

<pre class="line-numbers"><code class="language-text">public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    //继续执行逻辑或者提示权限获取失败
}
</code></pre>

<h4 id="toc_8">4、权限说明。</h4>

<p>用户如果选择了拒绝，下一次在需要声明该权限的时候，Google建议APP开发者给予用户更多的说明，因此提供了下面这个API,<strong>这个方法返回值在使用过程中会发现有点纠结（具体解析见下面代码块说明）。</strong>  </p>

<pre class="line-numbers"><code class="language-java">public boolean shouldShowRequestPermissionRationale(permission)
{
    1、APP没有申请这个权限的话，返回false
    2、用户拒绝时，勾选了不再提示的话，返回false
    3、用户拒绝，但是没有勾选不再提示的话，返回true
    因此如果想在第一次就给用户提示，需要记录权限是否申请过，没有申请过的话，强制弹窗提示，而不能根据这个方法的返回值来。
}
</code></pre>

<h2 id="toc_9">三、QQ音乐的权限适配经验</h2>

<h3 id="toc_10">(一) 不同权限，申请的时机不同</h3>

<p>QQ音乐作为一个比较复杂的流媒体应用，也需要不少权限，但是究竟在什么时候来申请这些权限就成了适配6.0时首当其冲问题。针对这个问题，我们也对需要的权限进行了思考，大致认为申请权限需要分为两个时机。</p>

<p><strong>用户触发：</strong>这个很好理解，有些和特性相关的权限，比如说听歌识曲的录音权限、自建歌单封面拍照权限等，这类权限平时APP运行时并不需要，那么我们选择在用户触发或者进入该功能的时候，进行授权受阻逻辑。</p>

<p><strong>应用启动时：</strong>我们在梳理的时候发现，有些权限（读取设备信息，读写sd卡等）并不是由用户或者特性触发的，而是网络免流，登录安全，日志系统这些底层逻辑无时不刻触发的。对于这些权限，就比较纠结了。不过回过头来看，这些权限通常是开发者或者APP不能妥协的权限，因为如果用户不授权的话，将会影响整个APP的功能和数据。所以，我们选择比较暴力的方式，在应用启动的时候，就受阻。这也是Google建议的一种方式。</p>

<p>但是需要注意的是，一开始就申请授权也不要冷冰冰地直接拉起系统弹窗授权，建议先用APP自己的弹窗向用户礼貌地说明为什么需要这几个权限，比如，读取不到设备信息无法联通免流，无法保证登录安全，读取不到SD卡无法播放歌曲等，避免太生硬引起用户的反感。特别是，因为本地化翻译的原因，Google对于权限的弹窗说明很不local，例如我们申请读取设备信息的权限时，系统的弹窗是“电话权限”，这里很容易引起用户的误解，所以，合理的引导和解释是必不可少的。</p>

<h3 id="toc_11">(二) 应用启动授权，需要一个壳</h3>

<p>刚刚已经说到了，很多隐形的权限和特性无关。那么，如果我们直接启动APP，用户又还没有授权的情况下，很多初始化逻辑很容易就因为没有权限crash了，即使没有crash，后面也可能会有或多或少其他的问题。因此，我们需要在这些权限完全授予前，禁止这些逻辑的执行。</p>

<p>做过启动相关的同学都知道，拦截一个APP正常的启动后面再恢复，是很复杂的一件事情，往往我们需要一个外壳来把业务逻辑的内壳隔绝开。就QQ音乐而言，我们很容易的就想到了dex加载的壳，需求也很类似，dex加载也需要优先于业务来做。顺着这个思路，很自然地，我们就选择了在dex的壳里面做权限的受阻逻辑，而且也很快很好的达到了预期的效果。相信现在大部分APP都是分dex的了，因此建议按照这个方式来做，可以节省很多的工作量。</p>

<h2 id="toc_12">四、Android权限机制“乱象”</h2>

<p>这里要说的乱象，其实是和Android严重的碎片化有一定的关系。随着国产ROM越来越个性，很多ROM在尝试建立自己的权限机制，有些甚至基于Android5.x就开放了原生的或者开发了自己的权限机制。而面对这些情况，我们往往能做的非常有限，举几个例子。</p>

<h3 id="toc_13">(一) 读取运动数据权限</h3>

<p>开发QQ音乐跑步电台的过程中发现，在某国产ROM的一些机型上会提示“应用读取运动数据权限”的系统弹窗。可是，反复查阅相关API发现，我们使用的计步相关的Sensor并不需要申请什么权限。可如果用户选择了拒绝，即使APP注册了Sensor，也收不到系统的回调。后来联系该厂商的相关人员后，给出的答复是，第三方APP无法检查和申请这个权限，这个权限本身也属于该厂商ROM自己的权限机制。</p>

<p>类似的案例还有一个，就是在某厂商的手机管家，会一直提示QQ音乐尝试读取应用程序列表。其实，我们并没有读取应用程序列表，只是调用了PackageManager相关的一些API，就是触发这个告警。</p>

<p>对于这类问题，我们怀疑，第三方ROM是在运行时检测到了APP调用了相关的API后，进行权限阻断。这里开发同学需要注意的是，被阻断的API不一定会导致crash，但是可能导致我们获取不到正确的返回值或者收不到系统的一些消息回调。</p>

<h3 id="toc_14">(二) 无法添加快捷方式</h3>

<p>本来<code>&lt;uses-permission android:name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot;/&gt;</code>声明后，我们就可以在桌面上创建快捷方式了，而且这个权限也不是危险权限。可是某些国产ROM，对于APP添加快捷方式限制的比较严，必须要用户在设置里面手动允许添加快捷方式后，APP才能最终成功的添加。这种情况，APP也不能知道是否能添加快捷方式，只能默默的添加失败了。不过好在这里受影响并不是主快捷方式，而且某些功能的快捷方式入口。</p>

<h3 id="toc_15">(三) 消失的桌面歌词，悬浮窗权限</h3>

<p>QQ音乐桌面歌词采用了向WindowManager里面添加View的方式实现。可是很多国产ROM很早就具备了悬浮窗权限。一开始，我们将type改为LayoutParams.TYPE_TOAST同时声明<code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;</code>这个普通权限，躲避了大多数系统的问题。可是，2016年底，随着某ROM系统的升级，这一招也没用了，大批用户反馈爆发。</p>

<p>我们继续尝试检测悬浮窗权限，发现<code>checkPermission（&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;）</code>返回的结果永远是true，因此这条路也走不通。</p>

<p>最终，经过各种查阅，发现这个悬浮窗权限并不在Android6.0标准的权限机制内，而是AppOpsManager里面已经被隐藏了的一个开关位，对应于第24个开关。需要注意的是，AppOpsManager这个类很早就有了，但是很多ROM隐藏了checkOp的方法，好在最后发现通过反射仍旧可以调用这个方法检测权限是否打开。  </p>

<pre class="line-numbers"><code class="language-java"> AppOpsManager manager = (AppOpsManager) context.getSystemService(&quot;appops&quot;);
try {
    Object object = invokeMethod(manager, &quot;checkOp&quot;, op, Binder.getCallingUid(), getPackageName(context));
    return AppOpsManager.MODE_ALLOWED == (Integer) object;
} catch (Exception e) {
    MLog.e(TAG, &quot;CheckPermission &quot; + e.toString());
}
</code></pre>

<p>不过，要打开悬浮窗权限，不同ROM的路径还不一样，有的是在设置里面，有的是在系统自带的管家里面，最后我们只能根据不同的ROM，给予用户不同的引导，终于将反馈量降了下去。</p>

<p><strong>转载自<a href="http://mp.weixin.qq.com/s/YL-NooJmsqbGSUlpNmpqbw">Android权限机制与适配经验</a></strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868683.html">
                
                  <h1>Android 存储方式以及路径API</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>首先说一句,平时说的存储分成了内部存储和外部存储。注意内部存储又叫做机身内存，而且内存又包含了两个部分RAM(运行时内存,这个和运行速度有关系，是手机运行时存储数据和指令的地方)、ROM(这个才算是真正存储东西的内部存储范围，是应用配置和其他数据的地方);而外部存储就很明确了,用户的外部挂载存储设备,如SD卡,手机的内部存储卡。</p>

<p>来介绍几个概念:</p>

<h2 id="toc_0">一、内存</h2>

<p>全称内部存储,英文名(InternalStorage)。当我们在打开DDMS下的File Explorer面板的时候，/data目录就是所谓的内部存储 (ROM )。<br/><br/>
但是注意，当手机没有root的时候不能打开此文件夹。<br/><br/>
当打开data文件夹的时候，目录结构如下:<br/><br/>
<figure><img src="media/15561207868683/15713243301697.png" alt=""/></figure></p>

<p>这里一般都是关注两个最重要的文件夹: </p>

<ul>
<li>app文件夹里存放着我们所有安装的app的apk文件，并且当我们调试一个app的时候，可以看到控制台输出的内容，有一项是uploading …..就是上传我们的apk到这个文件夹，上传成功之后才开始安装。 <br/>
这里写图片描述 </li>
<li>第二个文件夹是data,也就是我们常说的/data/data目录(存储包私有数据)。此目录下将每一个APP的存储内容按照包名分类存放好。 <br/>
比如: 
<ul>
<li>data/data/包名/shared_prefs 存放该APP内的SP信息 </li>
<li>data/data/包名/databases 存放该APP的数据库信息 </li>
<li>data/data/包名/files 将APP的文件信息存放在files文件夹 </li>
<li>data/data/包名/cache 存放的是APP的缓存信息 </li>
</ul></li>
</ul>

<p>多扯一句,下面的代码就会在files文件夹先创建一个hello_file文件并写入了数据:</p>

<pre class="line-numbers"><code class="language-java">String FILENAME = &quot;hello_file&quot;;
String string = &quot;hello world!&quot;;
FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_APPEND|Context.MODE_WORLD_READABLE);
fos.write(string.getBytes());
fos.close();
</code></pre>

<h2 id="toc_1">二、外存</h2>

<p>/storage/sdcard/Android/data目录或者说/storage/emulated/0/Android/data包目录属于外部存储。比如我们的内部存储卡。 <br/>
注意,Google官方建议开发者将App的数据存储在私有目录即/storage/emulated/0/Android/data包下，这样卸载App时数据会随之被系统清除，不会造成数据残留。 </p>

<h2 id="toc_2">三、除了/data之外的存储目录</h2>

<ol>
<li><strong>/mnt</strong>:这个目录专门用来当作挂载点(MountPoint)。通俗点说,/mnt就是来挂载外部存储设备的(如sdcard),我们的sdcard将会被手机系统视作一个文件夹,这个文件夹将会被系统嵌入到收集系统的mnt目录 </li>
<li><strong>/dev包</strong>:Linux系统的常规文件夹。 </li>
<li><p><strong>/system包</strong>:系统配置的文件夹，比如Android系统框架（framework）、底层类库（lib）、字体（font）等。 </p></li>
</ol>

<ul>
<li>1、下面说一下路径API和对以上的文件的操作:<br/>
<code>context.getFilesDir().getAbsolutePath()</code><br/>
<code>context.getFilesDir().getPath()</code><br/></li>
</ul>

<p>上面的两个API都是得到应用程序私有目录下的文件路径:<br/><br/>
<code>/data/data/包名/files</code></p>

<ul>
<li><p>2、<code>context.getCacheDir().getPath()</code><br/><br/>
取得应用程序的缓存文件在内部存储上的存储路径<br/><br/>
<code>/data/data/包名/cache</code>  </p></li>
<li><p>3、<code>context.getExternalCacheDir().getAbsolutePath()</code>和<code>context.getExternalCacheDir().getCanonicalPath()</code><br/>
取得应用程序的缓存文件在外部存储上的存储路径<br/><br/>
<code>/storage/sdcard/Android/data/包名/cache</code></p></li>
<li><p>4、<code>context.getObbDir().getAbsolutePath()</code><br/>
取得外部存储obb目录的根路径<br/><br/>
<code>/storage/sdcard/Android/obb/包名</code></p></li>
<li><p>5、<code>Environment.getExternalStorageState()</code><br/><br/>
得到外部存储卡(sdcard)的存储状态<br/><br/>
<code>mounted</code>  </p></li>
<li><p>6、<code>Environment.getExternalStorageDirectory().getAbsolutePath()</code><br/><br/>
得到外部存储的整个根路径<br/><br/>
<code>/storage/sdcard</code>  </p></li>
<li><p>7、<code>Environment.getDownloadCacheDirectory().getAbsolutePath()</code><br/><br/>
得到外部存储的下载文件的缓存路径<br/>
<code>/cache</code></p></li>
<li><p>8、<code>Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getAbsolutePath()</code><br/><br/>
得到外部存储的图片的根路径<br/><br/>
<code>/storage/sdcard/Pictures</code></p></li>
<li><p>9、<code>Environment.getRootDirectory().getAbsolutePath()</code><br/><br/>
<code>/system</code></p></li>
<li><p>10、<code>Environment.getDataDirectory().getAbsolutePath()</code></p></li>
</ul>

<p><code>/data</code></p>

<h2 id="toc_3">最后总结一下:</h2>

<ul>
<li>内部数据：/data/data/包名/XXX </li>
<li>外部私有数据：/storage/emulated/0/Android/data/包名/XXX </li>
<li>外部公有数据：/storage/emulated/0/包名/XXX</li>
</ul>

<p>当用应用管理来清除数据的时候: </p>

<ul>
<li>清除缓存：将外部私有数据下的cache包（/storage/emulated/0/Android/data/包名/cache）清除，将内部数据下的cache包下的内容（/data/data/包名/cache/XXX）清除 。 </li>
<li>清楚数据：将外部私有数据包（/storage/emulated/0/Android/data/包名）清除，将内部数据下的所有内容（/data/data/包名/XXX）清除；</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/31</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868614.html">
                
                  <h1>Android 响应式编程的应用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">响应式编程简介</h2>

<ul>
<li>响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</li>
<li>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们更改电子表（变化的传播）中的一些数值时，我们需要更新整个表格或者我们的机器人碰到墙时会转弯（响应事件）。</li>
<li>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</li>
</ul>

<h2 id="toc_1">响应式编程的具体实现-RxJava</h2>

<h3 id="toc_2">基本概念</h3>

<h4 id="toc_3">RxJava的四种角色</h4>

<ul>
<li>Observable</li>
<li>Observer</li>
<li>Subscriber</li>
<li>Subject</li>
<li>Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。</li>
</ul>

<h4 id="toc_4">热Observable和冷Observable</h4>

<p>从发射物的角度来看，有两种不同的Observable:热的和冷的。一个”热”的Observable典型的只要一创建完就开始发射数据，因此所有后续订阅它的观察者可能从序列中间的某个位置开始接受数据（有一些数据错过了）。一个”冷”的Observable会一直等待，直到有观察者订阅它才开始发射数据，因此这个观察者可以确保会收到整个数据序列。</p>

<h4 id="toc_5">Observable创建符</h4>

<ul>
<li>Observable.create()</li>
</ul>

<pre class="line-numbers"><code class="language-java">Observable.create(new Observable.OnSubscribe&lt;Object&gt;(){
    @Override
    public void call(Subscriber&lt;? super Object&gt; subscriber{
    }
});
</code></pre>

<ul>
<li>Observable.from()<br/>
from() 创建符可以从一个列表/数组来创建Observable,并一个接一个的从列表/数组中发射出来每一个对象，或者也可以从Java Future 类来创建Observable，并发射Future对象的 .get() 方法返回的结果值。传入 Future 作为参数时，我们可以指定一个超时的值。Observable将等待来自 Future 的结果；如果在超时之前仍然没有结果返回，Observable将会触发 onError() 方法通知观察者有错误发生了。</li>
</ul>

<pre class="line-numbers"><code class="language-java">List&lt;Integer&gt; items = new ArrayList&lt;Integer&gt;();
items.add(1);
items.add(10);
items.add(100);
items.add(200);

Observable&lt;Integer&gt; observableString = Observable.from(items);
Subscription subscriptionPrint = observableString.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onCompleted() {
    System.out.println(&quot;Observable completed&quot;);
    }
    @Override
    public void onError(Throwable e) {
    System.out.println(&quot;Oh,no! Something wrong happened！&quot;);
    }
    @Override
    public void onNext(Integer item) {
    System.out.println(&quot;Item is &quot; + item);
    }
});
</code></pre>

<ul>
<li>Observable.just()<br/>
just() 方法可以传入一到九个参数，它们会按照传入的参数的顺序来发射它们。 just() 方法也可以接受列表或数组，就像 from() 方法，但是它不会迭代列表发射每个值,它将会发射整个列表。通常，当我们想发射一组已经定义好的值时会用到它。但是如果我们的函数不是时变性的，我们可以用just来创建一个更有组织性和可测性的代码库。</li>
</ul>

<pre class="line-numbers"><code class="language-java">Observable&lt;String&gt; observableString = Observable.just(helloWorld
());
Subscription subscriptionPrint = observableString.subscribe(new
Observer&lt;String&gt;() {
    @Override
    public void onCompleted() {
    System.out.println(&quot;Observable completed&quot;);
    }
    @Override
    public void onError(Throwable e) {
    System.out.println(&quot;Oh,no! Something wrong happened!&quot;);
    }
    @Override
    public void onNext(String message) {
    System.out.println(message);
    }
});
</code></pre>

<p>helloWorld() 方法比较简单，像这样：</p>

<pre class="line-numbers"><code class="language-java">private String helloWorld(){
    return &quot;Hello World&quot;;
}
</code></pre>

<h3 id="toc_6">Subject</h3>

<p>Subject 既可以是 Observable，也可以是 Observer。 <br/>
RxJava 提供四种不同的 Subject :</p>

<ul>
<li>PublishSubject</li>
<li>BehaviorSubject<br/>
BehaviorSubject会首先向他的订阅者发送截至订阅前最新的一个数据对象（或初始值）,然后正常发送订阅后的数据流。<br/></li>
</ul>

<p><code>BehaviorSubject&lt;Integer&gt; behaviorSubject = BehaviorSubject.create(1);</code>  </p>

<p>在这个短例子中，我们创建了一个能发射整形(Integer)的BehaviorSubject。由于每当Observes订阅它时就会发射最新的数据，所以它需要一个初始值。</p>

<ul>
<li>ReplaySubject<br/>
ReplaySubject 会缓存它所订阅的所有数据,向任意一个订阅它的观察者重发:<br/></li>
</ul>

<p><code>ReplaySubject&lt;Integer&gt; replaySubject = ReplaySubject.create();</code></p>

<ul>
<li>AsyncSubject<br/>
当Observable完成时AsyncSubject只会发布最后一个数据给已经订阅的每一个观察者。<br/></li>
</ul>

<p><code>AsyncSubject&lt;Integer&gt; asyncSubject = AsyncSubject.create();</code></p>

<h3 id="toc_7">直接创建 Observable</h3>

<p>在我们的第一个列子里，我们将检索安装的应用列表并填充RecycleView的item来展示它们。我们也设想一个下拉刷新的功能和一个进度条来告知用户当前任务正在执行。</p>

<p>首先，我们创建Observable。我们需要一个函数来检索安装的应用程序列表并把它提供给我们的观察者。我们一个接一个的发射这些应用程序数据，将它们分组到一个单独的列表中，以此来展示响应式方法的灵活性。</p>

<pre class="line-numbers"><code class="language-java">private Observable&lt;AppInfo&gt; getApps(){
    return Observable.create(subscriber -&gt; {
        List&lt;AppInfoRich&gt; apps = new ArrayList&lt;AppInfoRich&gt;();
        final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
        mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        List&lt;ResolveInfo&gt; infos = getActivity().queryIntentActivities(mainIntent, 0);
        for(ResolveInfo info : infos){
            apps.add(new AppInfoRich(getActivity(),info));
        }
        for (AppInfoRich appInfo:apps) {
            Bitmap icon = Utils.drawableToBitmap(appInfo.getIcon());
            String name = appInfo.getName();
            String iconPath = mFilesDir + &quot;/&quot; + name;
            Utils.storeBitmap(App.instance, icon,name);
            if (subscriber.isUnsubscribed()){
                return;
            }
            subscriber.onNext(new AppInfo(name, iconPath, appInfo.getLastUpdateTime()));
        }
        if (!subscriber.isUnsubscribed()){
            subscriber.onCompleted();
        }
    });
}
</code></pre>

<p>AppInfo为App信息的实体类，包括上次更新时间、图标、名字三个属性，此处省略。</p>

<p><strong>需要重点注意的是在发射新的数据或者完成序列之前要检测观察者的订阅情况。这样的话代码会更高效，因为如果没有观察者等待时我们就不生成没有必要的数据项。</strong></p>

<p>接下来，我们来定义下拉刷新的方法：  </p>

<pre class="line-numbers"><code class="language-java">private void refreshTheList() {
    getApps().toSortedList()
    .subscribe(new Observer&lt;List&lt;AppInfo&gt;&gt;() {
    @Override
    public void onCompleted() {
        Toast.makeText(getActivity(), &quot;Here is the list!&quot;, Toast.LENGTH_LONG).show();
    }
    @Override
    public void onError(Throwable e) {
        Toast.makeText(getActivity(), &quot;Something went wrong!&quot;, Toast.LENGTH_SHORT).show();
        mSwipeRefreshLayout.setRefreshing(false);
    }
    @Override
    public void onNext(List&lt;AppInfo&gt; appInfos) {
        mRecyclerView.setVisibility(View.VISIBLE);
        mAdapter.addApplications(appInfos);
        mSwipeRefreshLayout.setRefreshing(false);
    }
    });
}
</code></pre>

<h3 id="toc_8">从列表创建 Observable</h3>

<p>在这个例子中，我们将引入 from() 函数。使用这个特殊的“创建”函数，我们可以从一个列表中创建一个Observable。Observable将发射出列表中的每一个元素，我们可以通过订阅它们来对这些发出的元素做出响应。  </p>

<pre class="line-numbers"><code class="language-java">private void loadList(List&lt;AppInfo&gt; apps) {
    mRecyclerView.setVisibility(View.VISIBLE);
    Observable.from(apps).subscribe(new Observer&lt;AppInfo&gt;() {
        @Override
        public void onCompleted() {
            mSwipeRefreshLayout.setRefreshing(false);
            Toast.makeText(getActivity(), &quot;Here is the list!&quot;, Toast.LENGTH_LONG).show();
        }
        @Override
        public void onError(Throwable e) {
            Toast.makeText(getActivity(), &quot;Something went wrong!&quot;, Toast.LENGTH_SHORT).show();
            mSwipeRefreshLayout.setRefreshing(false);
        }
        @Override
        public void onNext(AppInfo appInfo) {
            mAddedApps.add(appInfo);
            mAdapter.addApplication(mAddedApps.size() - 1, appInfo);
        }
    });
}
</code></pre>

<p>和第一个例子一个主要的不同是我们在 onCompleted() 函数中停掉进度条是因为我们一个一个的发射元素；<br/><br/>
第一个例子中的Observable发射的是整个list,因此在 onNext() 函数中停掉进度条的做法是安全的。  </p>

<h3 id="toc_9">具有特殊功能的创建符</h3>

<ul>
<li>just()<br/>
你可以将一个函数作为参数传给 just() 方法，你将会得到一个已存在代码的原始Observable版本。在一个新的响应式架构的基础上迁移已存在的代码，这个方法可能是一个有用的开始点。</li>
<li>repeat()<br/>
假如你想对一个Observable重复发射三次数据 :
<code>java
Observable.just(appOne,appTwo,appThree)<br/>
.repeat(3)<br/>
.subscribe();
</code></li>
</ul>

<p>我们在 just() 创建Observable后追加了 repeat(3) ，它将会创建9个元素的序列，每一个都单独发射。</p>

<ul>
<li>defer()<br/>
有这样一个场景，你想在这声明一个Observable但是你又想推迟这个Observable的创建直到观察者订阅时。看下面的 getInt() 函数：
<code>java
private Observable&lt;Integer&gt; getInt(){<br/>
return Observable.create(subscriber -&gt; {<br/>
    if(subscriber.isUnsubscribed()){<br/>
        return;<br/>
    }<br/>
    App.L.debug(&quot;GETINT&quot;);<br/>
    subscriber.onNext(42);<br/>
    subscriber.onCompleted();<br/>
});<br/>
}
</code></li>
</ul>

<p>这比较简单，并且它没有做太多事情，但是它正好为我们服务。现在，我们可以创建一个新的Observable并且应用 defer() :</p>

<p><code>Observable&lt;Integer&gt; deferred = Observable.defer(this::getInt);</code>  </p>

<p>这次， deferred 存在，但是 getInt() create() 方法还没有调用 : logcat日志也没有“GETINT”打印出来 :</p>

<pre class="line-numbers"><code class="language-java">deferred.subscribe(number -&gt; {
    App.L.debug(String.valueOf(number));
});
</code></pre>

<p>但是一旦我们订阅了， create() 方法就会被调用并且我们也可以在logcat日志中打印出两个值：GETINT 和 42。</p>

<ul>
<li><p>range()<br/><br/>
从一个指定的数字X开始发射N个数字。range() 函数用两个数字作为参数：第一个是起始点，第二个是我们想发射数字的个数。</p></li>
<li><p>interval()<br/><br/>
interval() 函数在你需要创建一个轮询程序时非常好用。interval() 函数的两个参数：一个指定两次发射的时间间隔，另一个是用到的时间单位。</p></li>
<li><p>timer()<br/><br/>
如果你需要一个一段时间之后才发射的Observable，你可以使用 timer()。</p></li>
</ul>

<h2 id="toc_10">过滤Observables</h2>

<h3 id="toc_11">过滤序列</h3>

<p>RxJava让我们使用 filter() 方法来过滤我们观测序列中不想要的值。</p>

<p>我们从发出的每个元素中过滤掉开头字母不是C的 :</p>

<pre class="line-numbers"><code class="language-java">.filter(new Func1&lt;AppInfo,Boolean&gt;(){
    @Override
    public Boolean call(AppInfo appInfo){
        return appInfo.getName().startsWith(&quot;C&quot;);
    }
})
</code></pre>

<p>我们传一个新的 Func1 对象给 filter() 函数，即只有一个参数的函数。 Func1 有一个 AppInfo 对象来作为它的参数类型并且返回 Boolean 对象。只要条件符合 filter() 函数就会返回 true 。此时，值会发射出去并且所有的观察者都会接收到。</p>

<p>filter() 函数最常用的用法之一时过滤 null 对象：</p>

<pre class="line-numbers"><code class="language-java">.filter(new Func1&lt;AppInfo,Boolean&gt;(){
    @Override
    public Boolean call(AppInfo appInfo){
        return appInfo != null;
    }
})
</code></pre>

<p>它帮我们免去了在 onNext() 函数调用中再去检测 null 值，让我们把注意力集中在应用业务逻辑上。</p>

<h3 id="toc_12">获取我们需要的数据</h3>

<p>当我们不需要整个序列时，而是只想取开头或结尾的几个元素，我们可以用 take() 或 takeLast() 。</p>

<ul>
<li><p>take()<br/><br/>
take() 函数用整数N来作为一个参数，从原始的序列中发射前N个元素，然后完成：</p>
<pre class="line-numbers"><code class="language-java">Observable.from(apps)
.take(3)<br/>
.subscribe(...);
</code></pre></li>
<li><p>takeLast()<br/><br/>
如果我们想要最后N个元素，我们只需使用 takeLast() 函数：</p>
<pre class="line-numbers"><code class="language-java">Observable.from(apps)
.takeLast(3)<br/>
.subscribe(...);
</code></pre></li>
</ul>

<h3 id="toc_13">有且仅有一次</h3>

<ul>
<li>distinct()<br/>
就像 takeLast() 一样， distinct() 作用于一个完整的序列，然后得到重复的过滤项，它需要记录每一个发射的值。如果你在处理一大堆序列或者大的数据记得关注内存使用情况。</li>
</ul>

<pre class="line-numbers"><code class="language-java">Observable&lt;AppInfo&gt; fullOfDuplicates = Observable.from(apps)
    .take(3)
    .repeat(3);
fullOfDuplicates.distinct()
    .subscribe(...);
</code></pre>

<ul>
<li>ditinctUntilChanged()<br/>
如果在一个可观测序列发射一个不同于之前的一个新值时让我们得到通知这时候该怎么做？ditinctUntilChanged() 过滤函数能做到这一点。它能轻易的忽略掉所有的重复并且只发射出新的值。</li>
</ul>

<h3 id="toc_14">First and last</h3>

<p>first() 方法和 last() 方法很容易弄明白。它们从Observable中只发射第一个元素或者最后一个元素。这两个都可以传 Func1 作为参数。 <br/>
与 first() 和 last() 相似的变量有： firstOrDefault() 和 lastOrDefault() 。这两个函数当可观测序列完成时不再发射任何值时用得上。在这种场景下，如果Observable不再发射任何值时我们可以指定发射一个默认的值。</p>

<h3 id="toc_15">Skip and SkipLast</h3>

<p>skip() 和 skipLast() 函数与 take() 和 takeLast() 相对应。它们用整数N作参数，从本质上来说，它们不让Observable发射前N个或者后N个值。</p>

<h3 id="toc_16">ElementAt</h3>

<p>如果我们只想要可观测序列发射的第五个元素该怎么办？ elementAt() 函数仅从一个序列中发射第n个元素然后就完成了。 <br/>
如果我们想查找第五个元素但是可观测序列只有三个元素可供发射时该怎么办？我们可以使用 elementAtOrDefault() 。</p>

<h3 id="toc_17">Sampling</h3>

<p>在Observable后面加一个 sample() ，我们将创建一个新的可观测序列，它将在一个指定的时间间隔里由Observable发射最近一次的数值： </p>

<pre class="line-numbers"><code class="language-java">Observable&lt;Integer&gt; sensor = [...]
sensor.sample(30,TimeUnit.SECONDS)
    .subscribe(...);
</code></pre>

<p>如果我们想让它定时发射第一个元素而不是最近的一个元素，我们可以使用 throttleFirst() 。</p>

<h3 id="toc_18">Timeout</h3>

<p>我们可以使用 timeout() 函数来监听源可观测序列,就是在我们设定的时间间隔内如果没有得到一个值则发射一个错误。我们可以认为 timeout() 为一个Observable的限时的副本。如果在指定的时间间隔内Observable不发射值的话，它监听的原始的Observable时就会触发 onError() 函数。</p>

<pre class="line-numbers"><code class="language-java">Subscription subscription = getCurrentTemperature()
    .timeout(2,TimeUnit.SECONDS)
    .subscribe(...);
</code></pre>

<h3 id="toc_19">Debounce</h3>

<p>debounce() 函数过滤掉由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。  </p>

<p>下图展示了多久从Observable发射一次新的数据， debounce() 函数开启一个内部定时器，如果在这个时间间隔内没有新的据发射，则新的Observable发射出最后一个数据：  </p>

<p><figure><img src="media/15561207868614/15713241823890.png" alt=""/></figure></p>

<h2 id="toc_20">变换Observables</h2>

<h3 id="toc_21">*map家族</h3>

<p>RxJava提供了几个mapping函数： map() , flatMap() , concatMap() , flatMapIterable() 以及 switchMap() .所有这些函数都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。</p>

<ul>
<li>Map<br/>
RxJava的 map 函数接收一个指定的 Func 对象然后将它应用到每一个由Observable发射的值上。</li>
</ul>

<pre class="line-numbers"><code class="language-java">Observable.from(apps)
    .map(new Func1&lt;AppInfo,AppInfo&gt;(){
        @Override
        public Appinfo call(AppInfo appInfo){
            String currentName = appInfo.getName();
            String lowerCaseName = currentName.toLowerCase();
            appInfo.setName(lowerCaseName);
            return appInfo;
        }
    })
    .subscribe(...);
</code></pre>

<p>正如你看到的，像往常一样创建我们发射的Observable之后，我们追加一个 map 调用，我们创建一个简单的函数来更新 AppInfo对象并提供一个名字小写的新版本给观察者。</p>

<ul>
<li>FlatMap<br/>
在复杂的场景中，我们有一个这样的Observable：它发射一个数据序列，这些数据本身也可以发射Observable。RxJava的 flatMap() 函数提供一种铺平序列的方式，然后合并这些Observables发射的数据，最后将合并后的结果作为最终的Observable。<br/>
<figure><img src="media/15561207868614/15713242041015.png" alt=""/></figure></li>
</ul>

<p>当我们在处理可能有大量的Observables时，重要是记住任何一个Observables发生错误的情况， flatMap() 将会触发它自己的 onError() 函数并放弃整个链。重要的一点提示是关于合并部分：它允许交叉。正如上图所示，这意味着 flatMap() 不能够保证在最终生成的Observable中源Observables确切的发射顺序。</p>

<ul>
<li><p>ConcatMap<br/><br/>
RxJava的 concatMap() 函数解决了 flatMap() 的交叉问题，提供了一种能够把发射的值连续在一起的铺平函数，而不是合并它们，如下图所示：<br/><br/>
<figure><img src="media/15561207868614/15713242157322.png" alt=""/></figure></p></li>
<li><p>FlatMapIterable<br/><br/>
作为*map家族的一员， flatMapInterable() 和 flatMap() 很像。仅有的本质不同是它将源数据两两结成对并生成Iterable，而不是原始数据项和生成的Observables。</p></li>
<li><p>SwitchMap<br/><br/>
switchMap() 和 flatMap() 很像，除了一点：每当源Observable发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的Observable，并开始监视当前发射的这一个。</p></li>
<li><p>Scan<br/><br/>
RxJava的 scan() 函数可以看做是一个累积函数。 scan() 函数对原始Observable发射的每一项数据都应用一个函数，计算出函数的结果值，并将该值填充回可观测序列，等待和下一次发射的数据一起使用。</p></li>
</ul>

<p>作为一个通用的例子，给出一个累加器：</p>

<pre class="line-numbers"><code class="language-java">Observable.just(1,2,3,4,5)
    .scan((sum,item) -&gt; sum + item)
    .subscribe(new Subscriber&lt;Integer&gt;() {
        @Override
        public void onCompleted() {
            Log.d(&quot;RXJAVA&quot;, &quot;Sequence completed.&quot;);
        }
        @Override
        public void onError(Throwable e) {
            Log.e(&quot;RXJAVA&quot;, &quot;Something went south!&quot;);
        }
        @Override
        public void onNext(Integer item) {
            Log.d(&quot;RXJAVA&quot;, &quot;item is: &quot; + item);
        }
    });
</code></pre>

<p>我们得到的结果是：</p>

<p><code>RXJAVA: item is: 1</code><br/><br/>
<code>RXJAVA: item is: 3</code><br/><br/>
<code>RXJAVA: item is: 6</code><br/><br/>
<code>RXJAVA: item is: 10</code><br/><br/>
<code>RXJAVA: item is: 15</code><br/><br/>
<code>RXJAVA: Sequence completed.</code>  </p>

<h3 id="toc_22">GroupBy</h3>

<p>RxJava提供了一个有用的函数从列表中按照指定的规则： groupBy() 来分组元素。下图中的例子展示了 groupBy() 如何将发射的值根据他们的形状来进行分组。</p>

<p><figure><img src="media/15561207868614/15713242370442.png" alt=""/></figure></p>

<p>这个函数将源Observable变换成一个发射Observables的新的Observable。它们中的每一个新的Observable都发射一组指定的数据。</p>

<p>为了创建一个分组了的已安装应用列表，我们在 loadList() 函数中引入了一个新的元素：</p>

<pre class="line-numbers"><code class="language-java">Observable&lt;GroupedObservable&lt;String,AppInfo&gt;&gt; groupedItems = Observable.from(apps)
            .groupBy(new Func1&lt;AppInfo,String&gt;(){
                @Override
                public String call(AppInfo appInfo){
                    SimpleDateFormat formatter = new SimpleDateFormat(&quot;MM/yyyy&quot;);
                    return formatter.format(new Date(appInfo.getLastUpdateTime()));
                }
            });
</code></pre>

<p>现在我们创建了一个新的Observable， groupedItems ，它将会发射一个带有 GroupedObservable 的序列。 GroupedObservable 是一个特殊的Observable，它源自一个分组的key。在这个例子中，key就是 String ，代表的意思是 Month/Year 格式化的最近更新日期。</p>

<h3 id="toc_23">Buffer</h3>

<p>RxJava中的 buffer() 函数将源Observable变换一个新的Observable，这个新的Observable每次发射一组列表值而不是一个一个发射。</p>

<p>buffer() 函数有几种变体。其中有一个是允许你指定一个 skip 值：此后每 skip 项数据，用count项数据填充缓冲区。另一个是buffer() 带一个 timespan 的参数，会创建一个每隔timespan时间段就会发射一个列表的Observable。</p>

<h3 id="toc_24">Window</h3>

<p>RxJava的 window() 函数和 buffer() 很像，但是它发射的是Observable而不是列表。</p>

<p>正如 buffer() 一样, window() 也有一个 skip 变体。</p>

<h3 id="toc_25">Cast</h3>

<p>cast() 函数是 map() 操作符的特殊版本。它将源Observable中的每一项数据都转换为新的类型，把它变成了不同的 Class 。</p>

<h2 id="toc_26">组合Observables</h2>

<h3 id="toc_27">Merge</h3>

<p>在”异步的世界“中经常会创建这样的场景，我们有多个来源但是又只想有一个结果：多输入，单输出。RxJava的 merge() 方法将帮助你把两个甚至更多的Observables合并到他们发射的数据项里。下图给出了把两个序列合并在一个最终发射的Observable。</p>

<p><figure><img src="media/15561207868614/15713242485369.png" alt=""/></figure></p>

<p>正如你看到的那样，发射的数据被交叉合并到一个Observable里面。注意如果你同步的合并Observable，它们将连接在一起并且不会交叉。</p>

<pre class="line-numbers"><code class="language-java">Observable&lt;AppInfo&gt; mergedObserbable = Observable.merge(observableApps,observableReversedApps);
mergedObserbable.subscribe(...);
</code></pre>

<p>注意错误时的toast消息，你可以认为每个Observable抛出的错误都将会打断合并。如果你需要避免这种情况，RxJava提供了 mergeDelayError() ，它能从一个Observable中继续发射数据即便是其中有一个抛出了错误。当所有的Observables都完成时， mergeDelayError() 将会发射 onError()。</p>

<h3 id="toc_28">ZIP</h3>

<p>在一种新的可能场景中处理多个数据来源时会带来：多从个Observables接收数据，处理它们，然后将它们合并成一个新的可观测序列来使用。RxJava有一个特殊的方法可以完成： zip() 合并两个或者多个Observables发射出的数据项，根据指定的函数Func* 变换它们，并发射一个新值。下图展示了 zip() 方法如何处理发射的“numbers”和“letters”然后将它们合并一个新的数据项：</p>

<p><figure><img src="media/15561207868614/15713242603739.png" alt=""/></figure></p>

<pre class="line-numbers"><code class="language-java">Observable.zip(observableApp, tictoc, (AppInfo appInfo, Long time) -&gt; updateTitle(appInfo, time))
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(...);
</code></pre>

<p>zip() 函数有三个参数：两个Observables和一个 Func2 。</p>

<h3 id="toc_29">Join</h3>

<p>前面两个方法， zip() 和 merge() 方法作用在发射数据的范畴内，在决定如何操作值之前有些场景我们需要考虑时间的。RxJava的 join() 函数基于时间窗口将两个Observables发射的数据结合在一起。</p>

<p><figure><img src="media/15561207868614/15713242707235.png" alt=""/></figure></p>

<p>为了正确的理解上一张图，我们解释下 join() 需要的参数：</p>

<ul>
<li>第二个Observable和源Observable结合。</li>
<li>Func1 参数：在指定的由时间窗口定义时间间隔内，源Observable发射的数据和从第二个Observable发射的数据相互配合返回的Observable。</li>
<li>Func1 参数：在指定的由时间窗口定义时间间隔内，第二个Observable发射的数据和从源Observable发射的数据相互配合返回的Observable。</li>
<li>Func2 参数：定义已发射的数据如何与新发射的数据项相结合。</li>
</ul>

<h3 id="toc_30">combineLatest</h3>

<p>RxJava的 combineLatest() 函数有点像 zip() 函数的特殊形式。正如我们已经学习的， zip() 作用于最近未打包的两个Observables。相反， combineLatest() 作用于最近发射的数据项：如果 Observable1 发射了A并且 Observable2 发射了B和C， combineLatest() 将会分组处理AB和AC，如下图所示：</p>

<p><figure><img src="media/15561207868614/15713242799691.png" alt=""/></figure></p>

<h3 id="toc_31">And,Then和When</h3>

<p>在将来还有一些 zip() 满足不了的场景。如复杂的架构，或者是仅仅为了个人爱好，你可以使用And/Then/When解决方案。它们在RxJava的joins包下，使用Pattern和Plan作为中介，将发射的数据集合并到一起。</p>

<p><figure><img src="media/15561207868614/15713242911755.png" alt=""/></figure></p>

<h3 id="toc_32">Switch</h3>

<p>给出一个发射多个Observables序列的源Observable， switch() 订阅到源Observable然后开始发射由第一个发射的Observable发射的一样的数据。当源Observable发射一个新的Observable时， switch() 立即取消订阅前一个发射数 <br/>
据的Observable（因此打断了从它那里发射的数据流）然后订阅一个新的Observable，并开始发射它的数据。</p>

<h3 id="toc_33">StartWith</h3>

<p>RxJava的 startWith() 是 concat() 的对应部分。正如 concat() 向发射数据的Observable追加数据那样，在Observable开始发射他们的数据之前，startWith() 通过传递一个参数来先发射一个数据序列。</p>

<h2 id="toc_34">Schedulers-解决Android主线程问题</h2>

<h3 id="toc_35">Schedulers</h3>

<p>调度器以一种最简单的方式将多线程用在你的Apps的中。它们时RxJava重要的一部分并能很好地与Observables协同工作。它们无需处理实现、同步、线程、平台限制、平台变化而可以提供一种灵活的方式来创建并发程序。</p>

<p>RxJava提供了5种调度器：</p>

<ul>
<li>.io()</li>
<li>.computation()</li>
<li>.immediate()</li>
<li>.newThread()</li>
<li>.trampoline()</li>
</ul>

<h4 id="toc_36">Schedulers.io()</h4>

<p>这个调度器时用于I/O操作。它基于根据需要，增长或缩减来自适应的线程池。我们将使用它来修复我们之前看到的 StrictMode 违规做法。由于它专用于I/O操作，所以并不是RxJava的默认方法；正确的使用它是由开发者决定的。</p>

<p><strong>重点需要注意的是线程池是无限制的，大量的I/O调度操作将创建许多个线程并占用内存。一如既往的是，我们需要在性能和简捷两者之间找到一个有效的平衡点。</strong></p>

<h4 id="toc_37">Schedulers.computation()</h4>

<p>这个是计算工作默认的调度器，它与I/O操作无关。它也是许多RxJava方法的默认调度器： buffer() , debounce() , delay() , interval() , sample() , skip()。</p>

<h4 id="toc_38">Schedulers.immediate()</h4>

<p>这个调度器允许你立即在当前线程执行你指定的工作。它是 timeout() , timeInterval() ,以及 timestamp() 方法默认的调度器。</p>

<h4 id="toc_39">Schedulers.newThread()</h4>

<p>这个调度器正如它所看起来的那样：它为指定任务启动一个新的线程。</p>

<h4 id="toc_40">Schedulers.trampoline()</h4>

<p>当我们想在当前线程执行一个任务时，并不是立即，我们可以用 .trampoline() 将它入队。这个调度器将会处理它的队列并且按序运行队列中每一个任务。它是 repeat() 和 retry() 方法默认的调度器。</p>

<h3 id="toc_41">非阻塞I/O操作</h3>

<p>使用 Schedulers.io() 创建非阻塞的版本：</p>

<pre class="line-numbers"><code class="language-java">public static void storeBitmap(Context context, Bitmap bitmap, String filename) {
    Schedulers.io().createWorker().schedule(() -&gt; {
        blockingStoreBitmap(context, bitmap, filename);
    });
}
</code></pre>

<h3 id="toc_42">SubscribeOn and ObserveOn</h3>

<p>我们学到了如何在一个调度器上运行一个任务。但是我们如何利用它来和Observables一起工作呢？RxJava提供了 subscribeOn() 方法来用于每个Observable对象。 subscribeOn() 方法用 Scheduler 来作为参数并在这个Scheduler上执行Observable调用。</p>

<p>首先，我们需要一个新的 getApps() 方法来检索已安装的应用列表：</p>

<pre class="line-numbers"><code class="language-java">private Observable&lt;AppInfo&gt; getApps() {
    return Observable.create(subscriber -&gt; {
        List&lt;AppInfo&gt; apps = new ArrayList&lt;&gt;();
        SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);
        Type appInfoType = new TypeToken&lt;List&lt;AppInfo&gt;&gt;(){}.getType();
        String serializedApps = sharedPref.getString(&quot;APPS&quot;, &quot;&quot;);
        if (!&quot;&quot;.equals(serializedApps)) {
            apps = new Gson().fromJson(serializedApps,appInfoType);
        }
        for (AppInfo app : apps) {
            subscriber.onNext(app);
        }
        subscriber.onCompleted();
    });
}
</code></pre>

<p>然后，我们所需要做的是指定 getApps() 需要在调度器上执行：</p>

<pre class="line-numbers"><code class="language-java">getApps().subscribeOn(Schedulers.io())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<p>最后，我们只需在 loadList() 函数添加几行代码，那么每一项就都准备好了：</p>

<pre class="line-numbers"><code class="language-java">getApps()
    .onBackpressureBuffer()
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<p>observeOn() 方法将会在指定的调度器上返回结果：如例子中的UI线程。 onBackpressureBuffer() 方法将告诉Observable发射的数据如果比观察者消费的数据要更快的话，它必须把它们存储在缓存中并提供一个合适的时间给它们。</p>

<h3 id="toc_43">处理耗时的任务</h3>

<p>一个与I/O无关的耗时的任务： </p>

<pre class="line-numbers"><code class="language-java">getObservableApps(apps)
    .onBackpressureBuffer()
    .subscribeOn(Schedulers.computation())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;AppInfo&gt;() { [...]
</code></pre>

<h1 id="toc_44">总结</h1>

<p>RxJava提供了一种以面向时序的方式考虑数据的机会：所有事情都是持续变化的，数据在更新，事件在触发，然后你就可以创建事件响应式的、灵活的、运行流畅的App。</p>

<p><strong>转载自<a href="http://blog.csdn.net/cmder1000/article/details/54848060">响应式编程在Android中的应用</a></strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868578.html">
                
                  <h1>Android 图片加载框架－Picasso的使用指南</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android 中有几个比较有名的图片加载框架，Universal ImageLoader、Picasso、Glide和Fresco。它们各有优点，以前一直用的是ImageLoader 做项目中的图片加载，由于作者宣布ImageLoader 不会在更新了，因此新的项目打算换一个图片加载框架－Picasso, Picasso 是Square 公司开源的Android 端的图片加载和缓存框架。<strong>Square</strong> 真是一家良心公司啊，为我们Android开发者贡献了很多优秀的开源项目有木有！像什么Rerefoit 、OkHttp、LeakCanary、Picasso等等都是非常火的开源项目。扯远了，回到正题，除了使用简单方便，Picasso还能自动帮我们做以下事情：</p>

<ul>
<li>处理Adapter 中ImageView的回收和取消下载。</li>
<li>使用最小的内存 来做复杂的图片变换。比如高斯模糊，圆角、圆形等处理。</li>
<li>自动帮我们缓存图片。内存和磁盘缓存。<br/>
以上只是列出了Picasso 比较核心的几点，其实它的优点远远不止这些，接下来就看一下如何使用Picasso。</li>
</ul>

<p><figure><img src="media/15561207868578/15713237941280.png" alt=""/></figure></p>

<h2 id="toc_1">一、添加依赖</h2>

<p>要使用Picasso,首先我们要添加版本依赖，去官网或者Github 看一下当前的最新版本(截止本文最新版本为2.5.2)，然后在build.gradle中添加依赖：</p>

<pre class="line-numbers"><code class="language-text">compile &#39;com.squareup.picasso:picasso:2.5.2&#39;
</code></pre>

<h2 id="toc_2">二、加载显示图片</h2>

<p>将Picasso添加到项目之后，我们就可以用它来加载图片了，使用方法非常简单：</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this)
        .load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;)
        .into(mImageView);
</code></pre>

<p>只需要一行代码就完成了加载图片到显示的整个过程，链式调用，非常简洁，其实有三步，一次调用了三个方法：</p>

<ul>
<li>with(Context) 获取一个Picasso单例，参数是一个Context上下文</li>
<li>load(String) 调用load 方法加载图片</li>
<li>into (ImageView) 将图片显示在对应的View上，可以是ImageView，也可以是实现了Target j接口的自定义View。<br/>
上面演示了加载一张网络图片，它还支持其它形式的图片加载，加载文件图片，加载本地资源图片，加载一个Uri 路径给的图片，提供了几个重载的方法：</li>
</ul>

<h3 id="toc_3">(一) load(Uri uri) 加载一个以Uri路径给的图片</h3>

<pre class="line-numbers"><code class="language-java">Uri uri = Uri.parse(ANDROID_RESOURCE + context.getPackageName() + FOREWARD_SLASH + resourceId)
Picasso.with(this).load(uri).into(mImageView);
</code></pre>

<h3 id="toc_4">(二) load(File file) 加载File中的图片</h3>

<p><code>Picasso.with(this).load(file).into(mImageView);</code></p>

<h3 id="toc_5">(三) load(int resourceId) 加载本地资源图片</h3>

<p><code>Picasso.with(this).load(R.mipmap.ic_launcher).into(mImageView);</code></p>

<blockquote>
<p>提醒：上面介绍了load的几个重载方法，加载不同资源的图片，另外提醒注意一下load(String path)接受String 参数的这个方法，参数String 可以是一个网络图片url,也可以是file 路径、content资源 和Android Resource。看一下源码的注释。</p>

<pre class="line-numbers"><code class="language-java">/**
   * Start an image request using the specified path. This is a convenience method for calling
   * {@link #load(Uri)}.
   * &lt;p&gt;
   * This path may be a remote URL, file resource (prefixed with {@code file:}), content resource
   * (prefixed with {@code content:}), or android resource (prefixed with {@code
   * android.resource:}.
   * &lt;p&gt;
   * Passing {@code null} as a {@code path} will not trigger any request but will set a
   * placeholder, if one is specified.
   *
   * @see #load(Uri)
   * @see #load(File)
   * @see #load(int)
   * @throws IllegalArgumentException if {@code path} is empty or blank string.
   */
  public RequestCreator load(String path) {
    if (path == null) {
      return new RequestCreator(this, null, 0);
    }
    if (path.trim().length() == 0) {
      throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);
    }
    return load(Uri.parse(path));
  }
</code></pre>

<p>要使用string 参数加载上面的几种资源，除了网络url,其它几种需要加上对应前缀，file文件路径前缀：file: , content 添加前缀：content: ,Android Resource 添加：android.resource:</p>
</blockquote>

<h2 id="toc_6">三、placeholder&amp; error &amp; noPlaceholder &amp; noFade</h2>

<p>通过上面的第一步我们就可以通过Picasso 加载图片了，我们的项目中通常最常用的就是加载网络图片，但是由于网络环境的差异，有时侯加载网络图片的过程有点慢，这样界面上就会显示空ImageView什么也看不见，用户体验非常不好。其实以前用过ImageLoader的同学都知道，ImageLoader 是可以设置加载中显示默认图片的，Picasso当然也给我们提供了这个功能，这就是我们要说的placeholder(占位图)。</p>

<h3 id="toc_7">(一) placeholder</h3>

<p>placeholder提供一张在网络请求还没有完成时显示的图片，它必须是本地图片，代码如下：</p>

<pre class="line-numbers"><code class="language-java"> Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .into(mImageView);
</code></pre>

<p>设置placeholder之后，在加载图片的时候，就可以显示设置的默认图了，提升用户体验。</p>

<h3 id="toc_8">(二) error</h3>

<p>和placeholder 的用法一样，error 提供一张在加载图片出错的情况下显示的默认图</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .into(mImageView);
</code></pre>

<h3 id="toc_9">(三) noPlaceholder</h3>

<p>这个方法的意思就是：在调用into的时候明确告诉你没有占位图设置。根据这个方法签名的解释是阻止View被回收的时候Picasso清空target或者设置一个应用的占位图。需要注意的是placeholder和noPlaceholder 不能同时应用在同一个请求上，会抛异常。</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .noPlaceholder()
                .error(R.drawable.error_iamge)
                .into(mImageView);
</code></pre>

<h3 id="toc_10">(四) noFade</h3>

<p>无论你是否设置了占位图，Picasso 从磁盘或者网络加载图片时，into 显示到ImageView 都会有一个简单的渐入过度效果，让你的UI视觉效果更柔顺丝滑一点，如果你不要这个渐入的效果（没有这么坑爹的需求吧！！！），就调用noFade方法。</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .noFade()
                .into(mImageView);
</code></pre>

<h2 id="toc_11">四、设置图片尺寸(Resize)、缩放(Scale)和裁剪(Crop)</h2>

<h3 id="toc_12">(一) Resize(int w,int h)</h3>

<p>在项目中，为了带宽、内存使用和下载速度等考虑，服务端给我们的图片的size 应该和我们View 实际的size一样的，但是实际情况并非如此，服务端可能给我们一些奇怪的尺寸的图片，我们可以使用resize(int w,int hei) 来重新设置尺寸。  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .into(mImageView);
</code></pre>

<p>resize()方法接受的参数的单位是pixels,还有一个可以设置dp单位的方法，将你的尺寸写在dimens.xml文件中，然后用<code>resizeDimen(int targetWidthResId, int targetHeightResId)</code>方法   </p>

<pre class="line-numbers"><code class="language-markup">&lt;dimen name=&quot;image_width&quot;&gt;300dp&lt;/dimen&gt;
&lt;dimen name=&quot;image_height&quot;&gt;200dp&lt;/dimen&gt;
</code></pre>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resizeDimen(R.dimen.image_width,R.dimen.image_height)
                .into(mImageView);
</code></pre>

<h3 id="toc_13">(二) onlyScaleDown</h3>

<p>当调用了resize 方法重新设置图片尺寸的时候，调用onlyScaleDown 方法，只有当原始图片的尺寸大于我们指定的尺寸时，resize才起作用,如：  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(4000,2000)
                .onlyScaleDown()
                .into(mImageView);
</code></pre>

<p>只有当原来的图片尺寸大于4000 x 2000的时候，resize 才起作用。</p>

<h3 id="toc_14">(三) 图片裁剪 centerCrop()</h3>

<p>这个属性应该不陌生吧！ImageView 的ScaleType 就有这个属性。当我们使用resize 来重新设置图片的尺寸的时候，你会发现有些图片拉伸或者扭曲了（使用ImageView的时候碰到过吧），我要避免这种情况，Picasso 同样给我们提供了一个方法，centerCrop，<strong>充满ImageView 的边界，居中裁剪</strong>。</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .centerCrop()
                .into(mImageView);
</code></pre>

<h3 id="toc_15">(四) centerInside</h3>

<p>上面的centerCrop是可能看不到全部图片的，如果你想让View将图片展示完全，可以用centerInside，但是如果图片尺寸小于View尺寸的话，是不能充满View边界的。</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .resize(400,200)
                .centerInside()
                .into(mImageView);
</code></pre>

<h3 id="toc_16">(五) fit</h3>

<p>fit 是干什的呢？上面我们需要用resize()来指定我们需要的图片的尺寸，那就是说在程序中需要我们计算我们需要的尺寸（固定大小的除外），这样很麻烦，fit 方法就帮我们解决了这个问题。fit 它会自动测量我们的View的大小，然后内部调用reszie方法把图片裁剪到View的大小，这就帮我们做了计算size和调用resize 这2步。非常方便。代码如下：</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .into(mImageView);
</code></pre>

<p>使用fit 还是会出现拉伸扭曲的情况，因此最好配合前面的centerCrop使用，代码如下：</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .centerCrop()
                .into(mImageView);
</code></pre>

<p>看一下对比图:<br/><br/>
<strong>fit(会拉伸):</strong><br/><br/>
<figure><img src="media/15561207868578/15713238082013.png" alt=""/></figure></p>

<p><strong>fit &amp; centerCrop (不会拉伸):</strong><br/><br/>
<figure><img src="media/15561207868578/15713238181812.png" alt=""/></figure></p>

<blockquote>
<p>注意：特别注意，  </p>

<ol>
<li>fit 只对ImageView 有效<br/></li>
<li>使用fit时，ImageView 宽和高不能为wrap_content,很好理解，因为它要测量宽高。</li>
</ol>
</blockquote>

<h2 id="toc_17">五、图片旋转Rotation()</h2>

<p>在图片显示到ImageView 之前，还可以对图片做一些旋转操作，调用<code>rotate(int degree)</code>方法  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .rotate(180)
                .into(mImageView);
</code></pre>

<p>这个方法它是以（0，0）点旋转，但是有些时候我们并不想以（0,0）点旋转，还提供了另外一个方法可以指定原点：</p>

<ul>
<li>rotate(float degrees, float pivotX, float pivotY) 以(pivotX, pivotY)为原点旋转</li>
</ul>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .rotate(180,200,100)
                .into(mImageView);
</code></pre>

<h2 id="toc_18">六、转换器Transformation</h2>

<p>Transformation 这就是Picasso的一个非常强大的功能了，它允许你在load图片 -&gt; into ImageView 中间这个过成对图片做一系列的变换。比如你要做图片高斯模糊、添加圆角、做度灰处理、圆形图片等等都可以通过Transformation来完成。</p>

<p>来看一个高斯模糊的例子：</p>

<h3 id="toc_19">(一) 首先定义一个转换器继承 Transformation</h3>

<pre class="line-numbers"><code class="language-java">public static class BlurTransformation implements Transformation{

        RenderScript rs;

        public BlurTransformation(Context context) {
            super();
            rs = RenderScript.create(context);
        }

        @Override
        public Bitmap transform(Bitmap bitmap) {
            // Create another bitmap that will hold the results of the filter.
            Bitmap blurredBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true);

            // Allocate memory for Renderscript to work with
            Allocation input = Allocation.createFromBitmap(rs, blurredBitmap, Allocation.MipmapControl.MIPMAP_FULL, Allocation.USAGE_SHARED);
            Allocation output = Allocation.createTyped(rs, input.getType());

            // Load up an instance of the specific script that we want to use.
            ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));
            script.setInput(input);

            // Set the blur radius
            script.setRadius(25);

            // Start the ScriptIntrinisicBlur
            script.forEach(output);

            // Copy the output to the blurred bitmap
            output.copyTo(blurredBitmap);

            bitmap.recycle();

            return blurredBitmap;
        }

        @Override
        public String key() {
            return &quot;blur&quot;;
        }
    }
</code></pre>

<h3 id="toc_20">(二) 加载图片的时候，在into 方法前面调用 transform方法 应用Transformation</h3>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .transform(new BlurTransformation(this))
                .into(mBlurImage);
</code></pre>

<p>看一下效果图：<br/><br/>
<figure><img src="media/15561207868578/15713238282149.png" alt=""/></figure> </p>

<p>上面为原图，下面为高斯模糊图<br/><br/>
是不是很强大，任何复杂的变换都可以通过Transformation 来做。<br/><br/>
还不止于此，还有更强大的功能。可以在一个请求上应用多个Transformation<br/><br/>
比如：我想先做个灰度处理然后在做一个高斯模糊图：  </p>

<h4 id="toc_21">1.灰度的Transformation</h4>

<pre class="line-numbers"><code class="language-java">public static class GrayTransformation implements Transformation{

        @Override
        public Bitmap transform(Bitmap source) {
            int width, height;
            height = source.getHeight();
            width = source.getWidth();

            Bitmap bmpGrayscale = Bitmap.createBitmap(width, height, Bitmap.Config.RGB_565);
            Canvas c = new Canvas(bmpGrayscale);
            Paint paint = new Paint();
            ColorMatrix cm = new ColorMatrix();
            cm.setSaturation(0);
            ColorMatrixColorFilter f = new ColorMatrixColorFilter(cm);
            paint.setColorFilter(f);
            c.drawBitmap(source, 0, 0, paint);

            if(source!=null &amp;&amp; source!=bmpGrayscale){
                source.recycle();
            }
            return bmpGrayscale;
        }

        @Override
        public String key() {
            return &quot;gray&quot;;
        }
    }
</code></pre>

<h4 id="toc_22">2.如果是多个Transformation操作，有2种方式应用</h4>

<p><strong>方式一：直接调用多次transform 方法，不会覆盖的。它只是保存到了一个List 里面</strong></p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .fit()
                .centerCrop()
                .transform(new GrayTransformation())//度灰处理
                .transform(new BlurTransformation(this))//高斯模糊
                .into(mBlurImage);
</code></pre>

<p>需要注意调用的顺序<br/>
<strong>方式二：接受一个List，将Transformation 放大list 里</strong></p>

<pre class="line-numbers"><code class="language-java">List&lt;Transformation&gt; transformations = new ArrayList&lt;&gt;();
transformations.add(new GrayTransformation());
transformations.add(new BlurTransformation(this));
Picasso.with(this).load(URL)
        .placeholder(R.drawable.default_bg)
        .error(R.drawable.error_iamge)
        .fit()
        .centerCrop()
        .transform(transformations)
        .into(mBlurImage);
</code></pre>

<p>效果图：<br/><br/>
<figure><img src="media/15561207868578/15713238380282.png" alt=""/></figure></p>

<p>如上图，第一张为灰度操作，第二张为 灰度＋高斯模糊<br/><br/>
另外发现了一个开源库，专门写了很多好玩的Transformation，有兴趣的可以看一下：<br/>
<a href="https://github.com/wasabeef/picasso-transformations">picasso-transformations</a></p>

<h2 id="toc_23">七、请求优先级</h2>

<p>Picasso 为请求设置有优先级，有三种优先级，LOW、NORMAL、HIGH。默认情况下都是NORMAL，除了调用fetch 方法，fetch 方法的优先级是LOW。</p>

<pre class="line-numbers"><code class="language-java">public enum Priority {
    LOW,
    NORMAL,
    HIGH
}
</code></pre>

<p>可以通过priority方法设置请求的优先级，这会影响请求的执行顺序，但是这是不能保证的，它只会往高的优先级靠拢。代码如下：</p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL)
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .priority(Picasso.Priority.HIGH)
               // .priority(Picasso.Priority.LOW)
                .into(mImageView);
</code></pre>

<h2 id="toc_24">八、Tag管理请求</h2>

<p>Picasso 允许我们为一个请求设置tag来管理请求，看一下对应的几个方法：<br/><br/>
下面3个方法是Picasso这个类的：  </p>

<ul>
<li>cancelTag(Object tag) 取消设置了给定tag的所有请求</li>
<li>pauseTag(Object tag) 暂停设置了给定tag 的所有请求</li>
<li>resumeTag(Object tag) resume 被暂停的给定tag的所有请求<br/></li>
</ul>

<p>还有一个方法是RequestCreator的:</p>

<ul>
<li>tag(Object tag) 为请求设置tag</li>
</ul>

<p>几个方法的意思也很明确，就是我们可以暂停、resume、和取消请求，可以用在哪些场景呢？</p>

<p><strong>场景一：</strong> 比如一个照片流列表，当我们快速滑动列表浏览照片的时候，后台会一直发起请求加载照片的，这可能会导致卡顿，那么我们就可以为每个请求设置一个相同的Tag，在快速滑动的时候，调用pauseTag暂停请求，当滑动停止的时候，调用resumeTag恢复请求，这样的体验是不是就会更好一些呢。</p>

<p><strong>Adapter中添加如下代码：</strong>  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(mData.get(position))
                .placeholder(R.drawable.default_bg)
                .error(R.drawable.error_iamge)
                .tag(&quot;PhotoTag&quot;)
                .into(holder.mImageView);
</code></pre>

<p><strong>Activity中为RecyclerView添加滑动监听：</strong>  </p>

<pre class="line-numbers"><code class="language-java">mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
            @Override
            public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
                final Picasso picasso = Picasso.with(MainActivity.this);

                if (newState == SCROLL_STATE_IDLE) {
                    picasso.resumeTag(&quot;PhotoTag&quot;);
                } else {
                    picasso.pauseTag(&quot;PhotoTag&quot;);
                }
            }
        });
</code></pre>

<p><strong>场景二</strong>： 比如一个照片流列表界面，在弱网环境下，加载很慢，退出这个界面时可能会有很多请求没有完成，这个时候我们就可 以通过tag 来取消请求了。</p>

<h2 id="toc_25">九、同步／异步加载图片</h2>

<p>Picasso 加载图片也有同步／异步两种方式</p>

<h3 id="toc_26">(一) get() 同步</h3>

<p>很简单，同步加载使用get() 方法，返回一个Bitmap 对象，代码如下：</p>

<pre class="line-numbers"><code class="language-java">try {
    Bitmap bitmap =  Picasso.with(this).load(URL).get();
    } catch (IOException e) {
    e.printStackTrace();
}
</code></pre>

<blockquote>
<p>注意：使用同步方式加载，不能放在主线程来做。</p>
</blockquote>

<h3 id="toc_27">(二) 异步的方式加载图片，fetch()</h3>

<p>一般直接加载图片通过into显示到ImageView 是异步的方式，除此之外，还提供了2个异步的方法：</p>

<ul>
<li>fetch() 异步方式加载图片</li>
<li>fetch(Callback callback) 异步方式加载图片并给一个回调接口。</li>
</ul>

<pre class="line-numbers"><code class="language-java">Picasso.with(this).load(URL).fetch(new Callback() {
    @Override
    public void onSuccess() {
    //加载成功
    }

    @Override
    public void onError() {
    //加载失败
    }
});
</code></pre>

<p>这里就要吐槽一下接口设计了，回调并没有返回Bitmap, 不知道作者是怎么考虑的，只是一个通知效果，知道请求失败还是成功。<br/>
fetch 方法异步加载图片并没有返回Bitmap，这个方法在请求成功之后，将结果存到了缓存，包括磁盘和内存缓存。所以使用这种方式加载图片适用于这种场景：知道稍后会加载图片，使用fetch 先加载缓存，起到一个预加载的效果。</p>

<h2 id="toc_28">十、缓存（Disk 和 Memory）</h2>

<p>Picasso 有内存缓存(Memory)和磁盘缓存（ Disk）, 首先来看一下源码中对于缓存的介绍：</p>

<ul>
<li>LRU memory cache of 15% the available application RAM</li>
<li>Disk cache of 2% storage space up to 50MB but no less than 5MB. (Note: this is only<br/>
available on API 14+ or if you are using a standalone library that provides a disk cache on all API levels like OkHttp)</li>
<li>Three download threads for disk and network access.</li>
</ul>

<p>可以看出，内存缓存是使用的LRU 策略的缓存实现，它的大小是内存大小的15%,可以自定义它的大小，最后在扩展那一章节再讲，磁盘缓存是磁盘容量的2%但是不超过50M,不少于5M。处理一个请求的时候，按照这个顺讯检查：memory-&gt;disk-&gt;network 。先检查有木有内存缓存，如果命中，直接返回结果，否则检查磁盘缓存，命中则返回结果，没有命中则从网上获取。</p>

<p><strong>默认情况下，Picasso 内存缓存和磁盘缓存都开启了的，也就是加载图片的时候，内存和磁盘都缓存了，但是有些时候，我们并不需要缓存，比如说：加载一张大图片的时候，如果再内存中保存一份，很容易造成OOM,这时候我们只希望有磁盘缓存，而不希望缓存到内存，因此就需要我们设置缓存策略了。Picasso 提供了这样的方法。</strong></p>

<h3 id="toc_29">(一) memoryPolicy 设置内存缓存策略</h3>

<p>就像上面所说的，有时候我们不希望有内存缓存，我们可以通过 memoryPolicy 来设置。MemoryPolicy是一个枚举，有两个值</p>

<p><strong>NO_CACHE</strong>：表示处理请求的时候跳过检查内存缓存<br/>
<strong>NO_STORE</strong>: 表示请求成功之后，不将最终的结果存到内存。</p>

<p>示例代码如下：  </p>

<pre class="line-numbers"><code class="language-java">with(this).load(URL)
    .placeholder(R.drawable.default_bg)
    .error(R.drawable.error_iamge)
    .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE) //静止内存缓存
    .into(mBlurImage);
</code></pre>

<h3 id="toc_30">(二) networkPolicy 设置磁盘缓存策略</h3>

<p>和内存缓存一样，加载一张图片的时候，你也可以跳过磁盘缓存，和内存缓存策略的控制方式一样，磁盘缓存调用方法networkPolicy(NetworkPolicy policy, NetworkPolicy... additional) , NetworkPolicy是一个枚举类型，有三个值：</p>

<ul>
<li>NO_CACHE: 表示处理请求的时候跳过处理磁盘缓存</li>
<li>NO_STORE: 表示请求成功后，不将结果缓存到Disk,但是这个只对OkHttp有效。</li>
<li>OFFLINE: 这个就跟 上面两个不一样了，如果networkPolicy方法用的是这个参数，那么Picasso会强制这次请求从缓存中获取结果，不会发起网络请求，不管缓存中能否获取到结果。</li>
</ul>

<p>使用示例： </p>

<pre class="line-numbers"><code class="language-java">with(this).load(URL)
            .placeholder(R.drawable.default_bg)
            .error(R.drawable.error_iamge)
            .memoryPolicy(MemoryPolicy.NO_CACHE,MemoryPolicy.NO_STORE)//跳过内存缓存
            .networkPolicy(NetworkPolicy.NO_CACHE)//跳过磁盘缓存
            .into(mBlurImage);
</code></pre>

<p>强制从缓存获取：  </p>

<pre class="line-numbers"><code class="language-java">with(this).load(URL)
            .placeholder(R.drawable.default_bg)
            .error(R.drawable.error_iamge)
            .networkPolicy(NetworkPolicy.OFFLINE)//强制从缓存获取结果
            .into(mBlurImage);
</code></pre>

<h2 id="toc_31">十一、Debug 和日志</h2>

<h3 id="toc_32">(一) 缓存指示器</h3>

<p>上一节说了，Picasso 有内存缓存和磁盘缓存，先从内存获取，没有再去磁盘缓存获取，都有就从网络加载，网络加载是比较昂贵和耗时的。因此，作为一个开发者，我们往往需要加载的图片是从哪儿来的（内存、Disk还是网络），Picasso让我们很容易就实现了。只需要调用一个方法setIndicatorsEnabled(boolean)就可以了,它会在图片的左上角出现一个带色块的三角形标示，有3种颜色，绿色表示从内存加载、蓝色表示从磁盘加载、红色表示从网络加载。<br/><br/>
<code>Picasso.with(this).setIndicatorsEnabled(true);//显示指示器</code><br/><br/>
效果图：<br/><br/>
<figure><img src="media/15561207868578/15713238477229.png" alt=""/></figure></p>

<p>如上图所示，第一张图从网络获取，第二张从磁盘获取，第三张图从内存获取。<br/><br/>
看一下源码中定义指示器的颜色：  </p>

<pre class="line-numbers"><code class="language-java">/** Describes where the image was loaded from. */
public enum LoadedFrom {
    MEMORY(Color.GREEN),
   DISK(Color.BLUE),
   NETWORK(Color.RED);

    final int debugColor;

    private LoadedFrom(int debugColor) {
        this.debugColor = debugColor;
    }
}
</code></pre>

<p>可以很清楚看出，对应三种颜色代表着图片的来源。</p>

<h3 id="toc_33">(二) 日志</h3>

<p>上面的指示器能够很好的帮助我们看出图片的来源，但是有时候我们需要更详细的信息，Picasso,可以打印一些日志，比如一些关键方法的执行时间等等，我们只需要调用setLoggingEnabled(true)方法，然后App在加载图片的过程中，我们就可以从logcat 看到一些关键的日志信息。<br/><br/>
<code>Picasso.with(this).setLoggingEnabled(true);//开启日志打印</code>  </p>

<h2 id="toc_34">十二、Picasso 扩展</h2>

<p>到目前为止，Picasso的基本使用已经讲得差不多了，但是在实际项目中我们这可能还满足不了我们的需求，我们需要对它做一些自己的扩展，比如我们需要换缓存的位置、我们需要扩大缓存、自定义线程池、自定义下载器等等。这些都是可以的，接下来我们来看一下可以做哪些方面的扩展。  </p>

<h3 id="toc_35">(一) 用Builder 自己构造一个Picasso Instance</h3>

<p>我们来回顾一下前面是怎么用Picasso加载图片的：  </p>

<pre class="line-numbers"><code class="language-java">Picasso.with(this)
       .load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;)
       .into(mImageView);
</code></pre>

<p><strong>总共3步：</strong></p>

<ol>
<li>用with方法获取一个Picasso 示例</li>
<li>用load方法加载图片</li>
<li>用into 放法显示图片</li>
</ol>

<p>首先Picasso是一个单例模式，我们每一次获取的示例都是默认提供给我们的实例。但是也可以不用它给的Instance,我们直接用builder来构造一个Picasso:  </p>

<pre class="line-numbers"><code class="language-java">Picasso.Builder builder = new Picasso.Builder(this);
//构造一个Picasso
Picasso picasso = builder.build();
//加载图片
picasso.load(URL)
.into(mImageView);
</code></pre>

<p>这样我们就构造了一个局部的Picasso实例，当然了，我们直接用new 了一个builder，然后build()生成了一个Picasso。这跟默认的通过with方法获取的实例是一样的。那么现在我们就可以配置一些自定义的功能了。</p>

<h3 id="toc_36">(二) 配置自定义下载器 downLoader</h3>

<p>如果我们不想用默认提供的Downloader,那么我们可以自定义一个下载器然后配置进去。举个例子：</p>

<h4 id="toc_37">1、先自定义一个Downloader(只是举个例子，并没有实现):</h4>

<pre class="line-numbers"><code class="language-java">/**
 * Created by zhouwei on 17/2/26.
 */

public class CustomDownloader implements Downloader {

    @Override
    public Response load(Uri uri, int networkPolicy) throws IOException {
        return null;
    }

    @Override
    public void shutdown() {

    }
}
</code></pre>

<h4 id="toc_38">2、然后通过builder配置：</h4>

<pre class="line-numbers"><code class="language-java"> //配置下载器
builder.downloader(new CustomDownloader());
//构造一个Picasso
Picasso picasso = builder.build();
</code></pre>

<p>这样配置后，我们用build()生成的Picasso 实例来加载图片就会使用自定义的下载器来下载图片了。</p>

<h3 id="toc_39">(三) 配置缓存</h3>

<p>前面说过，内存缓存是用的LRU Cahce ,大小是手机内存的15% ，如果你想缓存大小更大一点或者更小一点，可以自定义，然后配置。</p>

<pre class="line-numbers"><code class="language-java">//配置缓存
LruCache cache = new LruCache(5 * 1024 * 1024);// 设置缓存大小
builder.memoryCache(cache);
</code></pre>

<p>上面只是一个简单的举例，当然了你可以自定义，也可以使用LRUCache,改变大小，改变存储路径等等。</p>

<blockquote>
<p>提示： 很遗憾，好像没有提供改变磁盘缓存的接口，那就只能用默认的了。</p>
</blockquote>

<h3 id="toc_40">(四) 配置线程池</h3>

<p>Picasso 默认的线程池的核心线程数为3，如果你觉得不够用的话，可以配置自己需要的线程池，举个列子：  </p>

<pre class="line-numbers"><code class="language-java">//配置线程池
ExecutorService executorService = Executors.newFixedThreadPool(8);
builder.executor(executorService);
</code></pre>

<h3 id="toc_41">(五) 配置全局的 Picasso Instance</h3>

<p>上面说的这些自定义配置项目都是应用在一个局部的Picasso instance 上的，我们不可能每一次使用都要重新配置一下，这样就太麻烦了。我们希望我们的这些自定义配置能在整个项目都应用上，并且只配置一次。其实Picasso 给我们提供了这样的方法。可以调用<code>setSingletonInstance(Picasso picasso)</code>就可以了，看一下这个方法的源码：  </p>

<pre class="line-numbers"><code class="language-java">/**
  * Set the global instance returned from {@link #with}.
  * &lt;p&gt;
  * This method must be called before any calls to {@link #with} and may only be called once.
  */
public static void setSingletonInstance(Picasso picasso) {
    synchronized (Picasso.class) {
        if (singleton != null) {
            throw new IllegalStateException(&quot;Singleton instance already exists.&quot;);
        }
        singleton = picasso;
    }
}
</code></pre>

<p>设置一个通过with方法返回的全局instance。我们只希望配置一次，所以，我们应该在Application 的onCreate方法中做全局配置就可以了。app一启动就配置好，然后直接和前面的使用方法一样，调用with方法获取Picasso instance 加载图片就OK了。</p>

<p>因此在Application 中添加如下代码：</p>

<pre class="line-numbers"><code class="language-java">@Override
public void onCreate() {
    super.onCreate();

    // 配置全局的Picasso instance 

    Picasso.Builder builder = new Picasso.Builder(this);
    //配置下载器
    builder.downloader(new CustomDownloader());
    //配置缓存
    LruCache cache = new LruCache(5*1024*1024);// 设置缓存大小
    builder.memoryCache(cache);
    //配置线程池
    ExecutorService executorService = Executors.newFixedThreadPool(8);
    builder.executor(executorService);

    //构造一个Picasso
    Picasso picasso = builder.build();
    // 设置全局单列instance 
    Picasso.setSingletonInstance(picasso);
}
</code></pre>

<p>然后应用这些自定义配置加载图片  </p>

<p><code>Picasso.with(this).load(&quot;http://ww3.sinaimg.cn/large/610dc034jw1fasakfvqe1j20u00mhgn2.jpg&quot;).into(mImageView);</code><br/><br/>
用法和以前的一样，但是我们已经将我们的自定义配置应用上了。</p>

<h2 id="toc_42">结尾</h2>

<p>以上就是对Picasso 用法的全部总结，如有什么问题，欢迎留言指正。Picasso真的是一个强大的图片加载缓存库，API 简单好用，而且是链式调用的（这点我特别喜欢）。官方文档写的比较简单，很多用法都要看源码和注释才知道。希望本文能给才开始使用Picasso 的同学一点帮助。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868540.html">
                
                  <h1>Android 界面性能调优</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>界面是 Android 应用中直接影响用户体验最关键的部分。如果代码实现得不好，界面容易发生卡顿且导致应用占用大量内存。又卡又慢的应用体验，会影响客户或用户对产品的信心和评价，所以不可忽视。</p>

<h2 id="toc_1">一、 Android渲染知识</h2>

<h3 id="toc_2">(一) 绘制原理</h3>

<p>Android系统要求每一帧都要在 16ms 内绘制完成，平滑的完成一帧意味着任何特殊的帧需要执行所有的渲染代码（包括 framework 发送给 GPU 和 CPU 绘制到缓冲区的命令）都要在 16ms 内完成，保持流畅的体验。这个速度允许系统在动画和输入事件的过程中以约 60 帧每秒(1秒 / 0.016帧每秒 = 62.5帧/秒)的平滑帧率来渲染。<br/>
<figure><img src="media/15561207868540/15713234372552.png" alt=""/></figure></p>

<p>如果你的应用没有在 16ms 内完成这一帧的绘制，假设你花了 24ms 来绘制这一帧，那么就会出现掉帧的情况。<br/>
<figure><img src="media/15561207868540/15713234438260.png" alt=""/></figure></p>

<p>系统准备将新的一帧绘制到屏幕上，但是这一帧并没有准备好，所有就不会有绘制操作，画面也就不会刷新。反馈到用户身上，就是用户盯着同一张图看了 32ms 而不是 16ms ，也就是说掉帧发生了。</p>

<h3 id="toc_3">(二) 掉帧</h3>

<p>掉帧是用户体验中一个非常核心的问题。丢弃了当前帧，并且之后不能够延续之前的帧率，这种不连续的间隔会容易会引起用户的注意，也就是我们常说的卡顿、不流畅。  </p>

<p>引起掉帧的原因非常多，比如：  </p>

<ul>
<li><p>花了非常多时间重新绘制界面中的大部分东西，这样非常浪费CPU周期.<br/>
<figure><img src="media/15561207868540/15713234543583.png" alt=""/></figure></p></li>
<li><p>过度绘制严重，在绘制用户看不到的对象上花费了太多的时间.<br/>
<figure><img src="media/15561207868540/15713234666222.png" alt=""/></figure></p></li>
<li><p>有一大堆动画重复了一遍又一遍，消耗 CPU 、 GPU 资源<br/>
<figure><img src="media/15561207868540/15713234755965.png" alt=""/></figure></p></li>
<li><p>频繁的触发垃圾回收</p></li>
</ul>

<h3 id="toc_4">(三) 为什么是60Fps？</h3>

<p>Android系统要求每一帧都要在 16ms 内绘制完成，那么1秒的帧率就是约 60 帧每秒（ 1秒 / 0.016帧每秒 = 62.5帧/秒 ），那为什么要以 60 Fps来作为 App 性能的衡量标准呢？这是因为人眼和大脑之间的协作无法感知到超过 60 Fps的画面更新。<br/><br/>
市面上绝大多数Android设备的屏幕刷新频率是 60 HZ。当然，超过 60 Fps 是没有意义的，人眼感知不到区别。24 Fps 是人眼能感知的连续线性的运动，所以是电影胶圈的常用帧率，因为这个帧率已经足够支撑大部分电影画面所要表达的内容，同时能最大限度地减少费用支出。但是，低于 30 Fps 是无法顺畅表现绚丽的画面内容的，此时就需要用到 60 Fps 来达到想要表达的效果。了解更多Fps知识详见「Wiki」。<br/><br/>
应用的界面性能目标就是保持 60 Fps，这意味着每一帧你只有 16 ms（1秒 / 60帧率）的时间来处理所有的任务。  </p>

<h3 id="toc_5">(四) 垃圾回收</h3>

<p>垃圾回收器是一个在应用运行期间自动释放那些不再引用的内存的机制，常称 GC 。频繁的 GC 也是导致严重性能问题的罪魁祸首之一。<br/><br/>
前面提到，平滑的完成一帧意味着所有渲染代码都必须在 16ms 内完成。频繁的 GC 会严重限制一帧时间内的剩余时间，如果 GC 所做的工作超过了那些必须的工作，那么留给应用平滑的帧率的时间就越少。越接近 16ms ，在垃圾回收事件触发的时候，就越容易导致卡顿。<br/><br/>
注意，Android4.4 引进了新的 ART 虚拟机来取代 Dalvik 虚拟机。它们的机制大有不同，简单而言：  </p>

<ul>
<li>Dalvik 虚拟机的 GC 是非常耗资源的，并且在正常的情况下一个硬件性能不错的Android设备也会很容易耗费掉 10 - 20 ms 的时间；</li>
<li>ART 虚拟机的GC会动态提升垃圾回收的效率，在 ART 中的中断，通常在 2 - 3 ms 间。 比 Dalvik 虚拟机有很大的性能提升；<br/>
ART 虚拟机相对于 Dalvik 虚拟机来说的垃圾回收来说有一个很大的性能提升，但 2 - 3 ms 的回收时间对于超过16ms帧率的界限也是足够的。因此，尽管垃圾回收在 Android 5.0 之后不再是耗资源的行为，但也是始终需要尽可能避免的，特别是在执行动画的情况下，可能会导致一些让用户明显感觉的丢帧。</li>
</ul>

<p>想了解更多详细的 ART 和 Dalvik 虚拟机垃圾回收机制，可<a href="http://blog.csdn.net/luoshengyang/article/details/41338251">「戳我」</a>和<a href="http://blog.csdn.net/luoshengyang/article/details/42072975">「我」</a>进行深入了解。</p>

<h3 id="toc_6">(五) UI 线程</h3>

<p>UI 线程是应用的主线程，很多的性能和卡顿问题是由于我们在主线程中做了大量的工作。<br/><br/>
所以，所有耗资源的操作，比如 IO 操作、网络操作、SQL 操作、列表刷新等，都应该用后台进程去实现，不能占用主线程，主线程是 UI 线程，是保持程序流畅的关键；<br/><br/>
在 Android 5.0 版本里，Android 框架层引入了 “ Render Thread ” ，用于向 GPU 发送实际渲染的操作。这个线程减轻了一些 UI 线程减少的操作。但是输入、滚动和动画仍然在 UI thread，因为 Thread 必须能够响应操作。  </p>

<h3 id="toc_7">(六) 垂直同步</h3>

<p>垂直同步是 Android4.1 通过 Project Butter 在 UI 架构中引入的新技术，同期引入的还有 Triple Buffer 和 HWComposer 等技术，都是为提高 UI 的流畅性而生。<br/><br/>
举个例子，你拍了一张照片，然后旋转5度再拍另外一张照片，将两照片的中间剪开并拼接在一起，得到下图：<br/><br/>
<figure><img src="media/15561207868540/15713234978012.png" alt=""/></figure></p>

<p>中间这部分有明显区别的部分，等价于设备刷新率和帧速率不一致的结果。<br/><br/>
一般而言， GPU 的帧速率应高于刷新率，才不会卡顿或掉帧。如果屏幕刷新率比帧速率还快，屏幕会在两帧中显示同一个画面，这种断断续续情况持续发生时，用户将会很明显地感觉到动画的卡顿或者掉帧，然后又恢复正常，我们常称之为闪屏、跳帧、延迟。<br/><br/>
应用应避免这些帧率下降的情况，以确保 GPU 能在屏幕刷新之前完成数据的获取及写入，保证动画流畅。  </p>

<h3 id="toc_8">(七) UI 绘制机制与栅格化</h3>

<p>绝大多数渲染操作都依赖两个硬件： CPU 、 GPU 。 CPU 负责 Measure 、 layout 、 Record 、 Execute 的计算操作， GPU 负责栅格化（ Rasterization ）操作。 非必需的视图组件会带来多余的 CPU 计算操作，还会占用多余的 GPU 资源。<br/>
<figure><img src="media/15561207868540/15713235105653.png" alt=""/></figure></p>

<p>栅格化（ Rasterization ）能将 Button 、 Shape 、 Path 、 Bitmap 等资源组件拆分到不同的像素上进行显示。这个操作很费时，所以引入了 GPU 来加快栅格化的操作。<br/>
<figure><img src="media/15561207868540/15713235264231.png" alt=""/></figure></p>

<p>CPU 负责把 UI 组件计算成多边形（ Polygons ），纹理（ Texture ），然后交给 GPU 进行栅格化渲染，再将处理结果传到屏幕上显示。<br/>
<figure><img src="media/15561207868540/15713235374268.png" alt=""/></figure></p>

<p>在 Android 里的那些资源组件的显示（比如 Bitmaps 、 Drawable ），都是一起打包到统一的纹理（ Texture ）当中，然后再传递到 GPU 里面。<br/><br/>
图片的显示，则是先经过 CPU 的计算加载到内存中，再传给 GPU 进行渲染。<br/><br/>
文字的显示，则是先经过 CPU 换算成纹理（ Texture ），再传给 GPU 进行渲染，返回到 CPU 绘制单个字符的时候，再重新引用经过 GPU 渲染的内容。<br/><br/>
动画的显示更加复杂，我们需要在 16 ms 内处理完所有 CPU 和 GPU 的计算、绘制、渲染等操作，才能获得应用的流畅体验。</p>

<h2 id="toc_9">二、To检测和解决</h2>

<h3 id="toc_10">(一) 检测维度</h3>

<p>根据业务的不同与所需要的测试粒度的不同，就会有不同的检测维度。目前我所在业务所需的界面性能检测维度如下：</p>

<ul>
<li>界面过度绘制；（检测过度绘制）</li>
<li>渲染性能；（检测严格模式下的UI渲染性能呈现）</li>
<li>布局边界合理性；（检测元素显示的合理性）</li>
</ul>

<p>还有专项测试中某些用户场景可能还包含着另外一些隐形的检测维度，比如：</p>

<ul>
<li>OpenGL 跟踪分析；</li>
<li>GPU 视图更新合理性；</li>
<li>Flash 硬件层更新合理性；</li>
<li>动画加 / 减速状态问题点检测；</li>
<li>……</li>
</ul>

<h3 id="toc_11">(二) 调试工具</h3>

<p>检测和解决界面性能问题很大程度上依赖于你的应用程序架构，幸运的是，Andorid 提供了很多调试工具，知道并学会使用这些工具很重要，它们可以帮助我们调试和分析界面性能问题，以让应用拥有更好的性能体验。下面列举Android常见的界面性能调试工具：</p>

<h4 id="toc_12">1、Hierarchy View</h4>

<p><figure><img src="media/15561207868540/15713235536937.png" alt=""/></figure></p>

<p>Hierarchy View 在Android SDK里自带，常用来查看界面的视图结构是否过于复杂，用于了解哪些视图过度绘制，又该如何进行改进。详见官方使用教程（需要翻墙）:<a href="https://www.youtube.com/watch?v=URyoiAt8098">「戳我」</a>，官方介绍<a href="http://developer.android.com/tools/performance/hierarchy-viewer/index.html">「戳我」</a>。</p>

<h4 id="toc_13">2、Lint</h4>

<p>Lint 是 ADT 自带的静态代码扫描工具，可以给 XML 布局文件和 项目代码中不合理的或存在风险的模块提出改善性建议。官方关于 Lint 的实际使用的提示，列举几点如下：</p>

<ul>
<li>包含无用的分支，建议去除；</li>
<li>包含无用的父控件，建议去除；</li>
<li>警告该布局深度过深；</li>
<li>建议使用 compound drawables ；</li>
<li>建议使用 merge 标签；</li>
<li>……<br/>
更多 Lint 的官方介绍<a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html">「戳我」</a>。</li>
</ul>

<h4 id="toc_14">3、Systrace</h4>

<p><figure><img src="media/15561207868540/15713235708167.png" alt=""/></figure></p>

<p>Systrace 在Android DDMS 里自带，可以用来跟踪 graphics 、view 和 window 的信息，发现一些深层次的问题。很麻烦，限制大，实际调试中我基本用不到。官方介绍 <a href="http://developer.android.com/tools/help/systrace.html">「戳我」</a>和 <a href="http://developer.android.com/tools/debugging/systrace.html">「我」</a>。</p>

<h4 id="toc_15">4、Track</h4>

<p><figure><img src="media/15561207868540/15713235823132.png" alt=""/></figure></p>

<p>Track 在 Android DDMS里自带，是个很棒的用来跟踪构造视图的时候哪些方法费时，精确到每一个函数，无论是应用函数还是系统函数，我们可以很容易地看到掉帧的地方以及那一帧所有函数的调用情况，找出问题点进行优化。官方介绍 <a href="http://android-developers.blogspot.com/2009/02/track-memory-allocations.html">「戳我」</a>。</p>

<h4 id="toc_16">5、OverDraw</h4>

<p><figure><img src="media/15561207868540/15713235954296.png" alt=""/></figure></p>

<p>通过在 Android 设备的设置 APP 的开发者选项里打开 “ 调试 GPU 过度绘制 ” ，来查看应用所有界面及分支界面下的过度绘制情况，方便进行优化。官方介绍 <a href="http://developer.android.com/tools/performance/debug-gpu-overdraw/index.html">「戳我」</a>。</p>

<h4 id="toc_17">6、GPU 呈现模式分析</h4>

<p><figure><img src="media/15561207868540/15713236087507.png" alt=""/></figure></p>

<p>通过在 Android 设备的设置 APP 的开发者选项里启动 “ GPU 呈现模式分析 ” ，可以得到最近 128 帧 每一帧渲染的时间，分析性能渲染的性能及性能瓶颈。官方介绍 <a href="http://developer.android.com/tools/performance/profile-gpu-rendering/index.html">「戳我」</a>。</p>

<h4 id="toc_18">7、StrictMode</h4>

<p>通过在 Android 设备的设置 APP 的开发者选项里启动 “ 严格模式 ” ，来查看应用哪些操作在主线程上执行时间过长。当一些操作违背了严格模式时屏幕的四周边界会闪烁红色，同时输出 StrictMode 的相关信息到 LOGCAT 日志中。</p>

<h4 id="toc_19">8、Animator duration scale</h4>

<p>通过在 Android 设备的设置 APP 的开发者选项里打开 “ 窗口动画缩放 ” / “ 过渡动画缩放 ” / “ 动画程序时长缩放 ”，来加速或减慢动画的时间，以查看加速或减慢状态下的动画是否会有问题。</p>

<h4 id="toc_20">9、Show hardware layer updates</h4>

<p>通过在 Android 设备的设置 APP 的开发者选项里启动 “ 显示硬件层更新 ”，当 Flash 硬件层在进行更新时会显示为绿色。使用这个工具可以让你查看在动画期间哪些不期望更新的布局有更新，方便你进行优化，以获得应用更好的性能。实例《 Optimizing Android Hardware Layers 》（需要翻墙）:<a href="https://www.youtube.com/watch?v=aLjHu9l7qhc">「戳我」</a>。</p>

<h3 id="toc_21">(三) 如何解决</h3>

<p>前面提到过我司的目前所需的测试维度如下：</p>

<ul>
<li>界面过度绘制；（检测过度绘制）</li>
<li>渲染性能；（检测严格模式下的UI渲染性能呈现）</li>
<li>布局边界合理性；（检测元素显示的合理性） </li>
</ul>

<p>故接下来将围绕这三两点，分别从概念、追踪、挖掘根源以及排查的工具来具体讲述如何解决，以及给开发的优化建议。</p>

<h2 id="toc_22">三、界面过度绘制（OverDraw）</h2>

<h3 id="toc_23">(一) 过度绘制概念</h3>

<p>过度绘制是一个术语，表示某些组件在屏幕上的一个像素点的绘制次数超过 1 次。  </p>

<p>通俗来讲，绘制界面可以类比成一个涂鸦客涂鸦墙壁，涂鸦是一件工作量很大的事情，墙面的每个点在涂鸦过程中可能被涂了各种各样的颜色，但最终呈现的颜色却只可能是 1 种。这意味着我们花大力气涂鸦过程中那些非最终呈现的颜色对路人是不可见的，是一种对时间、精力和资源的浪费，存在很大的改善空间。绘制界面同理，花了太多的时间去绘制那些堆叠在下面的、用户看不到的东西，这样是在浪费CPU周期和渲染时间！<br/><br/>
<figure><img src="media/15561207868540/15713236220717.png" alt=""/></figure></p>

<blockquote>
<p>官方例子，被用户激活的卡片在最上面,而那些没有激活的卡片在下面，在绘制用户看不到的对象上花费了太多的时间。</p>
</blockquote>

<h3 id="toc_24">(二) 追踪过度绘制</h3>

<p>通过在 Android 设备的设置 APP 的开发者选项里打开 “ 调试 GPU 过度绘制 ” ，来查看应用所有界面及分支界面下的过度绘制情况，方便进行优化。<br/>
<figure><img src="media/15561207868540/15713236377748.png" alt=""/></figure></p>

<p>Android 会在屏幕上显示不同深浅的颜色来表示过度绘制：</p>

<ul>
<li>没颜色：没有过度绘制，即一个像素点绘制了 1 次，显示应用本来的颜色；</li>
<li>蓝色：1倍过度绘制，即一个像素点绘制了 2 次；</li>
<li>绿色：2倍过度绘制，即一个像素点绘制了 3 次；</li>
<li>浅红色：3倍过度绘制，即一个像素点绘制了 4 次；</li>
<li>深红色：4倍过度绘制及以上，即一个像素点绘制了 5 次及以上。</li>
</ul>

<p><figure><img src="media/15561207868540/15713236519068.png" alt=""/></figure></p>

<p>设备的硬件性能是有限的，当过度绘制导致应用需要消耗更多资源（超过了可用资源）的时候性能就会降低，表现为卡顿、不流畅、ANR 等。为了最大限度地提高应用的性能和体验，就需要尽可能地减少过度绘制，即更多的蓝色色块而不是红色色块。</p>

<p><figure><img src="media/15561207868540/15713236632943.png" alt=""/></figure></p>

<p>实际测试，常用以下两点来作为过度绘制的测试指标，将过度绘制控制在一个约定好的合理范围内：</p>

<ul>
<li>应用所有界面以及分支界面均不存在超过4X过度绘制（深红色区域）；</li>
<li>应用所有界面以及分支界面下，3X过度绘制总面积（浅红色区域）不超过屏幕可视区域的1/4；</li>
</ul>

<h3 id="toc_25">(三) 过度绘制的根源</h3>

<p>过度绘制很大程度上来自于视图相互重叠的问题，其次还有不必要的背景重叠。</p>

<p><figure><img src="media/15561207868540/15713236763184.png" alt=""/></figure></p>

<blockquote>
<p>官方例子，比如一个应用所有的View都有背景的话，就会看起来像第一张图中那样，而在去除这些不必要的背景之后（指的是Window的默认背景、Layout的背景、文字以及图片的可能存在的背景），效果就像第二张图那样，基本没有过度绘制的情况。</p>
</blockquote>

<h3 id="toc_26">(四) 不合理的xml布局对绘制的影响</h3>

<p>当布局文件的节点树的深度越深，XML 中的标签和属性设置越多，对界面的显示有灾难性影响。</p>

<p>一个界面要显示出来，第一步会进行解析布局，在 requestLayout 之后还要进行一系列的 measure 、 layout 、 draw 操作，若布局文件嵌套过深、拥有的标签属性过于臃肿，每一步的执行时间都会受到影响，而界面的显示是进行完这些操作后才会显示的，所以每一步操作的时间增长，最终显示的时间就会越长。  </p>

<h3 id="toc_27">(五) 源码相关</h3>

<p>有能力且有兴趣看源码的童鞋，过度绘制的源码位置在: /frameworks/base/libs/hwui/OpenGLRenderer.cpp ，有兴趣的可以去研究查看。</p>

<pre class="line-numbers"><code class="language-java">if (Properties::debugOverdraw &amp;&amp; getTargetFbo() == 0) {
        const Rect* clip = &amp;mTilingClip;
        mRenderState.scissor().setEnabled(true);
        mRenderState.scissor().set(clip-&gt;left,
                mState.firstSnapshot()-&gt;getViewportHeight() - clip-&gt;bottom,
                clip-&gt;right - clip-&gt;left,
                clip-&gt;bottom - clip-&gt;top);

        // 1x overdraw
        mRenderState.stencil().enableDebugTest(2);
        drawColor(mCaches.getOverdrawColor(1), SkXfermode::kdata-urlOver_Mode);

        // 2x overdraw
        mRenderState.stencil().enableDebugTest(3);
        drawColor(mCaches.getOverdrawColor(2), SkXfermode::kdata-urlOver_Mode);

        // 3x overdraw
        mRenderState.stencil().enableDebugTest(4);
        drawColor(mCaches.getOverdrawColor(3), SkXfermode::kdata-urlOver_Mode);

        // 4x overdraw and higher
        mRenderState.stencil().enableDebugTest(4, true);
        drawColor(mCaches.getOverdrawColor(4), SkXfermode::kdata-urlOver_Mode);

        mRenderState.stencil().disable();
    }
}
</code></pre>

<h2 id="toc_28">四、 渲染性能（Rendering）</h2>

<h3 id="toc_29">(一) 渲染性能概念</h3>

<p>渲染性能往往是掉帧的罪魁祸首，这种问题很常见，让人头疼。好在 Android 给我们提供了一个强大的工具，帮助我们非常容易追踪性能渲染问题，看到究竟是什么导致你的应用出现卡顿、掉帧。</p>

<h3 id="toc_30">(二) 追踪渲染性能</h3>

<p>通过在 Android 设备的设置 APP 的开发者选项里打开 “ GPU 呈现模式分析 ” 选项，选择 ” 在屏幕上显示为条形图 “。<br/>
<figure><img src="media/15561207868540/15713236940947.png" alt=""/></figure></p>

<p>这个工具会在Android 设备的屏幕上实时显示当前界面的最近 128 帧 的 GPU 绘制图形数据，包括 StatusBar 、 NavBar 、 当前界面的 GPU 绘制图形柱状图数据。我们一般只需关心当前界面的 GPU 绘制图形数据即可。<br/>
<figure><img src="media/15561207868540/15713237110152.png" alt=""/></figure></p>

<p>界面上一共有 128 个小柱状图，代表的是当前界面最近的 128 帧 GPU 绘制图形数据。一个小柱状图代表的这一帧画面渲染的耗时，柱状图越高代表耗时越长。随着界面的刷新，柱状图信息也会实时滚动刷新。<br/><br/>
中间有一条绿线，代表 16 ms ，保持动画流畅的关键就在于让这些垂直的柱状条尽可能地保持在绿线下面,任何时候超过绿线,你就有可能丢失一帧的内容。<br/><br/>
<figure><img src="media/15561207868540/15713237228265.png" alt=""/></figure></p>

<p>每一个柱状图都是由三种颜色构成：蓝、红、黄。</p>

<ul>
<li>蓝色代表的是这一帧绘制 Display List 的时间。通俗来说，就是记录了需要花费多长时间在屏幕上更新视图。用代码语言来说，就是执行视图的 onDraw 方法，创建或更新每一个视图的 Display List 的时间。</li>
<li>红色代表的是这一帧 OpenGL 渲染 Display List 所需要的时间。通俗来说，就是记录了执行视图绘制的耗时。用代码语言来说，就是 Android 用 OpenGL ES 的 API 接口进行 2D 渲染 Display List 的时间。</li>
<li>黄色代表的是这一帧 CPU 等待 GPU 处理的时间。通俗来说，就是 CPU 等待 GPU 发出接到命令的回复的等待时间。用代码语言来说，就是这是一个阻塞调用。</li>
</ul>

<p><figure><img src="media/15561207868540/15713237318281.png" alt=""/></figure></p>

<p>实际测试，常用以下两点来作为渲染性能的测试指标，将渲染性能控制在一个约定好的合理范围内：</p>

<ul>
<li>执行应用的所有功能及分支功能，操作过程中涉及的柱状条区域应至少 90 % 保持到绿线下面；</li>
<li>从用户体检的角度主观判断应用在 512 M 内存的 Android 设备下所有操作过程中的卡顿感是否能接受，不会感觉突兀怪异；</li>
</ul>

<h3 id="toc_31">(三) 渲染性能差的根源</h3>

<p>当你看到蓝色的线较高的时候，可能是由于你的视图突然无效了需要重新绘制，或者是自定义的视图过于复杂耗时过长。<br/>
<figure><img src="media/15561207868540/15713237413638.png" alt=""/></figure></p>

<p>当你看到红色的线较高的时候，可能是由于你的视图重新提交了需要重新绘制导致的（比如屏幕从竖屏旋转成横屏后当前界面重新创建），或者是自定义的视图很复杂，绘制起来很麻烦，导致耗时过长。比如下面这种视图：<br/>
<figure><img src="media/15561207868540/15713237577663.png" alt=""/></figure></p>

<p>当你看到黄色的线较高的时候，那就意味着你给 GPU 太多的工作，太多的负责视图需要 OpenGL 命令去绘制和处理，导致 CPU 迟迟没等到 GPU 发出接到命令的回复。</p>

<h3 id="toc_32">(四) 检测说明</h3>

<p>这个工具能够很好地帮助你找到渲染相关的问题，帮助你找到卡顿的性能瓶颈，追踪究竟是什么导致被测应用出现卡顿、变慢的情况，以便在代码层面进行优化。甚至让负责产品设计的人去改善他的设计，以获得良好的用户体验。</p>

<p>检测渲染性能时，常伴随着开启“ 严格模式 ” 查看应用哪些情景在 UI 线程（主线程）上执行时间过长。</p>

<p>另外有些强大但可能少用的工具在测试性能渲染时辅助分析，比如：</p>

<ul>
<li>HierarchyViewer：这个工具常用来查看界面的视图结构是否过于复杂，用于了解哪些视图过度绘制，又该如何进行改进；</li>
<li>Tracer for OpenGL：这个工具收集了所有UI界面发给GPU的绘制命令。常用于辅助开发人员 DEBUG 、定位一些 HierarchyViewer 工具定位不了的疑难渲染细节问题。</li>
</ul>

<h3 id="toc_33">(五) UI绘制机制的补充说明</h3>

<p>如上面所说，布局和 UI 组件等都会先经过 CPU 计算成 GPU 能够识别并绘制的多边形（ Polygons ），纹理（ Texture ），然后交给 GPU 进行栅格化渲染，再将处理结果传到屏幕上显示。 “ CPU 计算成 GPU 能够识别并绘制的对象 ” 这个操作是在 DisplayList 的帮助下完成的。DisplayList 拥有要交给 GPU 栅格化渲染到屏幕上的数据信息。</p>

<p><figure><img src="media/15561207868540/15713237734752.png" alt=""/></figure> </p>

<p>DisplayList 会在某个视图第一次需要渲染时创建。当该视图有类似位置被移动等变化而需要重新渲染这个视图的时候，则只需 GPU 额外执行一次渲染指令冰更新到屏幕上就够了。但如果视图中的绘制内容发生变化时（比如不可见了），那之间的 DisplayList 就无法继续使用了，这时系统就会重新执行一次重新创建 DisplayList 、渲染DisplayList 并更新到屏幕上。这个流程的表现性能取决于该视图的复杂程度。</p>

<h2 id="toc_34">五、给开发的界面优化 Advice</h2>

<h3 id="toc_35">(一) 优化布局的结构</h3>

<p>布局结构太复杂，会减慢渲染的速度，造成性能瓶颈。我们可以通过以下这些惯用、有效的布局原则来优化：</p>

<ul>
<li>避免复杂的View层级。布局越复杂就越臃肿，就越容易出现性能问题，寻找最节省资源的方式去展示嵌套的内容；</li>
<li>尽量避免在视图层级的顶层使用相对布局 RelativeLayout 。相对布局 RelativeLayout 比较耗资源，因为一个相对布局 RelativeLayout 需要两次度量来确保自己处理了所有的布局关系，而且这个问题会伴随着视图层级中的相对布局 RelativeLayout 的增多，而变得更严重；</li>
<li>布局层级一样的情况建议使用线性布局 LinearLayout 代替相对布局 RelativeLayout，因为线性布局 LinearLayout 性能要更高一些；确实需要对分支进行相对布局 RelativeLayout 的时候，可以考虑更优化的网格布局 GridLayout ，它已经预处理了分支视图的关系，可以避免两次度量的问题；</li>
<li>相对复杂的布局建议采用相对布局 RelativeLayout ，相对布局 RelativeLayout 可以简单实现线性布局 LinearLayout 嵌套才能实现的布局；</li>
<li>不要使用绝对布局 AbsoluteLayout ；</li>
<li>将可重复使用的组件抽取出来并用 </include> 标签进行重用。如果应用多个地方的 UI 用到某个布局，就将其写成一个布局部件，便于各个 UI 重用。官方详解 「 戳我 」</li>
<li>使用 merge 标签减少布局的嵌套层次，官方详解 「 戳我 」；<br/>
去掉多余的不可见背景。有多层背景颜色的布局，只留最上层的对用户可见的颜色即可，其他用户不可见的底层颜色可以去掉，减少无效的绘制操作；</li>
<li>尽量避免使用 layoutweight 属性。使用包含 layoutweight 属性的线性布局 LinearLayout 每一个子组件都需要被测量两次，会消耗过多的系统资源。在使用 ListView 标签与 GridView 标签的时候，这个问题显的尤其重要，因为子组件会重复被创建。平分布局可以使用相对布局 RelativeLayout 里一个 0dp 的 view 做分割线来搞定，如果不行，那就……；</li>
<li>合理的界面的布局结构应是宽而浅，而不是窄而深；</li>
</ul>

<h3 id="toc_36">(二) 优化处理逻辑</h3>

<ul>
<li>按需载入视图。某些不怎么重用的耗资源视图，可以等到需要的时候再加载，提高UI渲染速度；</li>
<li>使用 ViewStub 标签来加载一些不常用的布局；</li>
<li>动态地 inflation view 性能要比用 ViewStub 标签的 setVisiblity 性能要好，当然某些功能的实现采用 ViewStub 标签更合适；</li>
<li>尽量避免不必要的耗资源操作，节省宝贵的运算时间；</li>
<li>避免在 UI 线程进行繁重的操作。耗资源的操作（比如 IO 操作、网络操作、SQL 操作、列表刷新等）耗资源的操作应用后台进程去实现，不能占用 UI 线程，UI 线程是主线程，主线程是保持程序流畅的关键，应该只操作那些核心的 UI 操作，比如处理视图的属性和绘制；</li>
<li>最小化唤醒机制。我们常用广播来接收那些期望响应的消息和事件，但过多的响应超过本身需求的话，会消耗多余的 Android 设备性能和资源。所以应该最小化唤醒机制，当应用不关心这些消失和事件时，就关闭广播，并慎重选择那些要响应的 Intent 。</li>
<li>为低端设备考虑，比如 512M 内存、双核 CPU 、低分辨率，确保你的应用可以满足不同水平的设备。</li>
<li>优化应用的启动速度。当应用启动一个应用时，界面的尽快反馈显示可以给用户一个良好的体验。为了启动更快，可以延迟加载一些 UI 以及避免在应用 Application 层级初始化代码。</li>
</ul>

<h3 id="toc_37">(三) 善用 DEBUG 工具</h3>

<ul>
<li>多使用Android提供的一些调试工具去追踪应用主要功能的性能情况；</li>
<li>多使用Android提供的一些调试工具去追踪应用主要功能的内存分配情况；</li>
</ul>

<p><strong>转载自<a href="https://androidtest.org/android-graphics-performance-pattens/">Android界面性能调优手册</a></strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868469.html">
                
                  <h1>Android View的工作流程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>写了那么多自定义View，但是对于其中的原理以及工作流程还不是很了解，所以这篇博文来总结和回顾一下Android开发中的View的工作流程，view的工作流程主要包含measure、layout和draw三大流程，在进入主题之前，先要理解一下几个概念，以便更好的理解view的三大流程。<br/><br/>
<strong>转载自<a href="http://blog.csdn.net/lin_t_s/article/details/56668085">《安卓复习之旅——View的工作流程》</a></strong></p>

<h2 id="toc_1">了解ViewRoot和DecorView</h2>

<p>ViewRoot对应ViewRootImpl类，实现了ViewParent接口，它是连接WindowManager和DecorView的桥梁，WindowManager的实现类是WindowManagerImpl类:</p>

<pre class="line-numbers"><code class="language-java">public final class WindowManagerImpl implements WindowManager {
    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
    private final Context mContext;
    private final Window mParentWindow;

    private IBinder mDefaultToken;
</code></pre>

<p>其中WindowManagerGlobal相当与一个代理类，WindowManagerImpl 中的实现的方法都是通过WindowManagerGlobal来具体实现的，我们来看看WindowManagerImpl 中的addView()方法：</p>

<pre class="line-numbers"><code class="language-java">@Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }
</code></pre>

<p>可以看出确实是通过WindowManagerGlobal的addView()方法来具体实现的，进入WindowManagerGlobal的addView()方法：</p>

<pre class="line-numbers"><code class="language-java">    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
      ...
        final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;
        ViewRootImpl root;
        View panelParentView = null;

        synchronized (mLock) {
            int index = findViewLocked(view, false);
            if (index &gt;= 0) {
                if (mDyingViews.contains(view)) {
                    // Don&#39;t wait for MSG_DIE to make it&#39;s way through root&#39;s queue.
                    mRoots.get(index).doDie();
                } else {
                    throw new IllegalStateException(&quot;View &quot; + view
                            + &quot; has already been added to the window manager.&quot;);
                }
                // The previous removeView() had not completed executing. Now it has.
            }

            // If this is a panel window, then find the window it is being
            // attached to for future reference.
            if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;
                    wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                final int count = mViews.size();
                for (int i = 0; i &lt; count; i++) {
                    if (mRoots.get(i).mWindow.asBinder() == wparams.token) {
                        panelParentView = mViews.get(i);
                    }
                }
            }
            //实例化ViewRootImpl
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);

            // do this last because it fires off messages to start doing things
            try {
                //连接WindowManager和DecorView
                root.setView(view, wparams, panelParentView);
            } catch (RuntimeException e) {
                // BadTokenException or InvalidDisplayException, clean up.
                if (index &gt;= 0) {
                    removeViewLocked(index, true);
                }
                throw e;
            }
        }
    }
</code></pre>

<p>由上面注释的代码可以看出ViewRootImpl是连接WindowManager和DecorView的桥梁。</p>

<p>DecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分（具体情况和Android版本及主体有关），上面的是标题栏，下面的是内容栏。在Activity中通过setContentView所设置的布局文件其实就是被加到内容栏之中的，而内容栏的id是content，在代码中可以通过ViewGroup content = （ViewGroup)findViewById(R.android.id.content)来得到content对应的layout。 <br/>
DecorView的结构图： <br/>
<figure><img src="media/15561207868469/15713234121230.png" alt=""/></figure></p>

<h2 id="toc_2">View的绘制流程</h2>

<p>View的绘制流程是从ViewRootImpl的performTraversals()方法开始的，它经过measure、layout和draw三个流程才能最终将view绘制出来，其中measure测量view的宽高，layout确定view在父容器中的位置，draw负责将view绘制在屏幕上。<br/><br/>
view的绘制流程图：<br/><br/>
<figure><img src="media/15561207868469/15713234196147.png" alt=""/></figure></p>

<p><strong>performTraversals()</strong>方法源码比较长，就不贴出来了，有兴趣可以去查看一下，从上面的流程图可以看出<strong>performTraversals</strong>会依次调用 <strong>performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</strong> -  <strong>performLayout(lp, mWidth, mHeight);</strong> - <strong>performDraw();</strong>三个方法，这三个方法顶级view的三个流程，在 <strong>performMeasure()</strong>中会调用<strong>mView.measure()</strong>方法，<strong>mView.measure()</strong>又会调用<strong>onMeasure()</strong>方法对所有子元素进行测量，这个时候measure流程就从父容器传递到了子元素中，这样就完成了依次measure过程，<strong>performLayout()</strong>和<strong>performDraw()</strong>与<strong>performMeasure()</strong>过程是类似的，唯一的不同是<strong>performDraw()</strong>过程在draw方法中是通过<strong>dispatchDraw(canvas)</strong>方法来完成绘制的;</p>

<h2 id="toc_3">理解MeasureSpec</h2>

<p>MeasureSpec是一个32位的int值，高2位代表SpecMode,低30位代表SpecSize，SpecMode是指测量模式，SpecSize是指某种测量模式下的规格大小； <br/>
MeasureSpec内部的一些常量：</p>

<pre class="line-numbers"><code class="language-java">        private static final int MODE_SHIFT = 30;
        private static final int MODE_MASK  = 0x3 &lt;&lt; MODE_SHIFT;      
        public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;       
        public static final int EXACTLY     = 1 &lt;&lt; MODE_SHIFT;        
        public static final int AT_MOST     = 2 &lt;&lt; MODE_SHIFT;

 public static int makeMeasureSpec(int size,int mode) {
            if (sUseBrokenMakeMeasureSpec) {
                return size + mode;
            } else {
                return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);
            }
        }
public static int getMode(int measureSpec) {
            //noinspection ResourceType
            return (measureSpec &amp; MODE_MASK);
        }

 public static int getSize(int measureSpec) {
            return (measureSpec &amp; ~MODE_MASK);
        }
</code></pre>

<p>measureSpec 将SpecMode和SpecSize打包成一个int值，一组SpecMode和SpecSize也可以打包成一个measureSpec 通过getMode和getSize可以得到对应的值； <br/>
SpecMode有三种类型：</p>

<ul>
<li>UNSPECIFIED <br/>
父容器没有对view有任何限制，要多大给多大；</li>
<li>EXACTLY <br/>
父容器已经检测出view所需要的精确大小，view的大小就是SpecSize所指定的值，它对应于LayoutParams中的match_parent和具体的数值两种模式；</li>
<li>AT_MOST <br/>
父容器指定一个可用的大小即SpecSize，view的大小不能超过这个大小，对应于layoutParams中的wrap——content；</li>
</ul>

<p>measureSpec 与LayoutParams有什么关系呢？当我们给view设置了LayoutParams后，系统会将LayoutParams在父容器的约束下转换成对应的measureSpec ；<br/><br/>
对于DecorView来说，在ViewRootImpl中的measureHierarchy方法中进行了measureSpec 的创建过程，desiredWindowWidth为屏幕宽度，desiredWindowHeight为屏幕高度；  </p>

<pre class="line-numbers"><code class="language-java"> childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);
            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
</code></pre>

<p>进入getRootMeasureSpec方法：</p>

<pre class="line-numbers"><code class="language-java">    private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can&#39;t resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
    }
</code></pre>

<p>这个方法是根据DecorView自身的LayoutParams来计算出对应的measureSpec ； <br/>
对于普通view的measure过程是有viewgroup传递下来的，先看看viewgroup的measureChildWithMargins方法：</p>

<pre class="line-numbers"><code class="language-java">    protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                        + widthUsed, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
                        + heightUsed, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
</code></pre>

<p>measureChildWithMargins方法会通过getChildMeasureSpec方法计算出子元素的MeasureSpec然后子元素进行measure，从代码可以看出子元素的MeasureSpec与父容器的MeasureSpec与自身的LayoutParams有关，此外，还与view的margin和padding有关，下面进入getChildMeasureSpec方法：  </p>

<pre class="line-numbers"><code class="language-java">    public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension &gt;= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can&#39;t be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension &gt;= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can&#39;t be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension &gt;= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }
</code></pre>

<p>这个方法主要作用是根据父容器的MeasureSpec与view自身的LayoutParams来确定子元素的MeasureSpec，参数中的padding指父容器已占用的大小。</p>

<h2 id="toc_4">View的三大流程</h2>

<h3 id="toc_5">measure过程</h3>

<p>measure过程要分两种情况，一种是普通view，一种是viewgroup：</p>

<ul>
<li><p>1.view的measure <br/>
view的measure方法是一个final类型的方法，意味着不能重写这个方法，在这个方法中调用了onMeasure方法，我们可以重写onMeasure方法。</p>
<pre class="line-numbers"><code class="language-java">public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
  ...<br/>
        if (cacheIndex &lt; 0 || sIgnoreMeasureCache) {<br/>
            // measure ourselves, this should set the measured dimension flag back<br/>
            onMeasure(widthMeasureSpec, heightMeasureSpec);<br/>
            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br/>
        } else {<br/>
            long value = mMeasureCache.valueAt(cacheIndex);<br/>
            // Casting a long to int drops the high 32 bits, no mask needed<br/>
            setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);<br/>
            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br/>
        }<br/>
      ...<br/>
}
</code></pre></li>
</ul>

<p>看看onMeasure方法的实现：</p>

<pre class="line-numbers"><code class="language-java">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }
</code></pre>

<p>调用setMeasuredDimension方法设置view的测量值，其中getSuggestedMinimumWidth()是系统默认提供的值，这里就不深究了，下面看看getDefaultSize方法：</p>

<pre class="line-numbers"><code class="language-java">    public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
    }
</code></pre>

<p>在UNSPECIFIED模式下，返回系统默认值，EXACTLY和AT_MOST模式下，返回measureSpec中的值；这里也可以得到一个结论：当我们直接继承一个view的自定义控件需要重写onMeasure方法去设置wrap_content时的自身大小，否则在布局中使用wrap_content的效果与match_parent一样，原因是当view设置为wrap_content时，模式是AT_MOST，通过前一篇文章中的getChildMeasureSpec方法可以知道，view的specSize就是parentSize；重写onMeasure的代码思路如下：</p>

<pre class="line-numbers"><code class="language-java">         int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);


        if (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode == MeasureSpec.AT_MOST) {
            setMeasuredDimension(viewWidth, viewHeight);
        }
        else if(widthMode == MeasureSpec.AT_MOST ){
            setMeasuredDimension(viewWidth, heightSize);

        }
        else if(heightMode == MeasureSpec.AT_MOST ){
            setMeasuredDimension(widthSize, viewHeight);

        }
</code></pre>

<ul>
<li>2.viewgroup的measure<br/>
对于viewgroup来说，出了完成自己的measure过程，还要遍历子view的measure方法，各个子view完成对自身的measure过程，与view不同的是，viewgroup是一个抽象类，它是通过measureChildren（）方法开始measure，先看看measureChildren方法的代码：
<code>java
protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {<br/>
    final int size = mChildrenCount;<br/>
    final View[] children = mChildren;<br/>
    for (int i = 0; i &lt; size; ++i) {<br/>
        final View child = children[i];<br/>
        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {<br/>
            measureChild(child, widthMeasureSpec, heightMeasureSpec);<br/>
        }<br/>
    }<br/>
}
</code></li>
</ul>

<p>从以上代码可以看出，确实是会通过measureChild方法对每一个子view进行measure，</p>

<pre class="line-numbers"><code class="language-java">    protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) {
        final LayoutParams lp = child.getLayoutParams();

        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
</code></pre>

<p>measureChild方法先得到子view的MeasureSpec，然后再调用子view的measure方法；</p>

<p>view的measure过程是三大流程中最复杂的一个，measure完成以后，通过getMeasuredHeight()和getMeasuredWeight()可以得到view的测量高宽，但是在某些极端情况下，系统可能会多次measure才能得到最终的值，在这种情况下，在onMeasure中可能得到的值不是准确的。我们最好在onLayout中获取；还有一个需要注意的是，我们在onCreate、onStart和onResume中均得不到view的宽高，因为measure过程与activity的生命周期不是同步的；</p>

<h3 id="toc_6">layout过程</h3>

<p>layout过程的作用是viewgroup来确定子元素的位置，当viewgroup的位置确定后，会遍历所有子元素并调用其layout方法，在layout方法中又会调用onLayout方法。<br/><br/>
先看viewgroup的layout方法：</p>

<pre class="line-numbers"><code class="language-java">@Override
    public final void layout(int l, int t, int r, int b) {
        if (!mSuppressLayout &amp;&amp; (mTransition == null || !mTransition.isChangingLayout())) {
            if (mTransition != null) {
                mTransition.layoutChange(this);
            }
            super.layout(l, t, r, b);
        } else {
            // record the fact that we noop&#39;d it; request layout when transition finishes
            mLayoutCalledWhileSuppressed = true;
        }
    }
</code></pre>

<p>可以看出是调用父类的layout方法：</p>

<pre class="line-numbers"><code class="language-java">public void layout(int l, int t, int r, int b) {
    if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
    }

    int oldL = mLeft;
    int oldT = mTop;
    int oldB = mBottom;
    int oldR = mRight;

    boolean changed = isLayoutModeOptical(mParent) ?
    setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);

    if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
        onLayout(changed, l, t, r, b);

        if (shouldDrawRoundScrollbar()) {
            if(mRoundScrollbarRenderer == null) {
                mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);
            }
        } else {
            mRoundScrollbarRenderer = null;
        }

        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;

        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) {
            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();
            int numListeners = listenersCopy.size();
            for (int i = 0; i &lt; numListeners; ++i) {
                listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB);
            }
        }
    }

    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;
    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;
}
</code></pre>

<p>首先通过setFrame确定view的四个顶点位置，此时父容器的位置也就确定了，接下来就会调用onLayout方法确定子元素的位置；</p>

<p><code>protected void onLayout(boolean changed, int left, int top, int right, int bottom) {}</code></p>

<p>onLayout方法并没有给出具体的实现，当继承特定的组件时，不需要我们重写onLayout方法，继承viewgroup时则需要重写onLayout方法。</p>

<h3 id="toc_7">draw过程</h3>

<p>draw的作用是将view绘制到屏幕上，view的绘制流程遵循以下几步：</p>

<ul>
<li>绘制背景drawBackground(canvas);</li>
<li>绘制自己onDraw(canvas);</li>
<li>绘制子元素dispatchDraw(canvas);</li>
<li>绘制装饰onDrawForeground(canvas);</li>
</ul>

<p>看看draw源码：</p>

<pre class="line-numbers"><code class="language-java">    public void draw(Canvas canvas) {
        final int privateFlags = mPrivateFlags;
        final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;
                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
        mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;

        /*
         * Draw traversal performs several drawing steps which must be executed
         * in the appropriate order:
         *
         *      1. Draw the background
         *      2. If necessary, save the canvas&#39; layers to prepare for fading
         *      3. Draw view&#39;s content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */

        // Step 1, draw the background, if needed
        int saveCount;

        if (!dirtyOpaque) {
            drawBackground(canvas);
        }

        // skip step 2 &amp; 5 if possible (common case)
        final int viewFlags = mViewFlags;
        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
        if (!verticalEdges &amp;&amp; !horizontalEdges) {
            // Step 3, draw the content
            if (!dirtyOpaque) onDraw(canvas);

            // Step 4, draw the children
            dispatchDraw(canvas);

            // Overlay is part of the content and draws beneath Foreground
            if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) {
                mOverlay.getOverlayView().dispatchDraw(canvas);
            }

            // Step 6, draw decorations (foreground, scrollbars)
            onDrawForeground(canvas);

            // we&#39;re done...
            return;
        }

       ...
    }
</code></pre>

<p>view绘制过程的传递是通过 dispatchDraw(canvas)来实现的， dispatchDraw(canvas);会遍历所有的子元素的draw方法，view有一个特殊的方法：setWillNotDraw，先看一下源码;</p>

<pre class="line-numbers"><code class="language-java">/**
     * If this view doesn&#39;t do any drawing on its own, set this flag to
     * allow further optimizations. By default, this flag is not set on
     * View, but could be set on some View subclasses such as ViewGroup.
     *
     * Typically, if you override {@link #onDraw(android.graphics.Canvas)}
     * you should clear this flag.
     *
     * @param willNotDraw whether or not this View draw on its own
     */
    public void setWillNotDraw(boolean willNotDraw) {
        setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);
    }
</code></pre>

<p>意思是如果一个view不需要绘制任何内容，那么设置这个标记位为TRUE后，系统会进行优化，默认情况下标记位为FALSE。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868433.html">
                
                  <h1>Android 高效开发工具库</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>这篇文章介绍开发者如何学习提高以构建更好的app，我将分享一些自己受益过的教程和资料。</p>

<h2 id="toc_1">一. 使用Android studio的快捷键</h2>

<h3 id="toc_2">(1) tips</h3>

<p>这里是一个<a href="https://plus.google.com/u/0/collection/wtO0PB">使用Android studio的小建议集合</a>，大家可以在里边找到不少提高效率的点子。</p>

<h3 id="toc_3">(2) template</h3>

<p>使用Live templates可以节省coding时间：使用缩写快速输入方法或者循环<br/><br/>
<strong>eg:</strong> 输入 fbc 则快速速入了findViewById  </p>

<ul>
<li>template入门：<em>Android Studio Live Templates</em><br/></li>
<li>值得试用的live template 集合：<em>keyboardsurfer/idea-live-templates</em><br/></li>
<li>自定义template，这里是Reto Meier写的一篇非常好的教程<em>Writing More Code by Writing Less Code with Android Studio Live Templates</em>，当然也可以从<em>IntelliJ IDEA documentation</em>获取更多细节。</li>
</ul>

<h2 id="toc_4">二. Debugging App时用到的工具</h2>

<ul>
<li><p><strong><em>Library methods count</em></strong> Android 的 library非常有用，但是太多的库也会是的app中方法数目快速增加，这个工具可以显示各个依赖库的方法数。<br/>
<figure><img src="media/15561207868433/15713233585498.png" alt=""/></figure></p></li>
<li><p><strong><em>Stetho</em></strong>  使用Stetho，可以非常方便地监控app，尤其是网络流量。还可以监测并编辑SQLite，和Shared Preferences。<br/>
<figure><img src="media/15561207868433/15713233694428.png" alt=""/></figure></p></li>
<li><p><strong><em>LeakCanary</em></strong>  Android和java工程中可以的内存泄露监测工具。<br/>
<figure><img src="media/15561207868433/15713233799021.png" alt=""/></figure></p></li>
<li><p><strong><em>Gradle, Please  Chris broadFoot</em></strong>做的一个非常酷的一个library，只需要输入一个Library 的名字，就可以得到这个Library 的gradle依赖code，并且是该Library的最新版本，不要错过这个网站：<br/>
<figure><img src="media/15561207868433/15713233889472.png" alt=""/></figure></p></li>
<li><p><strong><em>Android Arsenal</em></strong>  这是一个分类查看Android Library、工具、工程的网站，很赞！</p></li>
<li><p><strong><em>Android Tool</em></strong>  Mac上的Android工具，可以进行录屏、截屏、安装apk，记录bug。</p></li>
<li><p><strong><em>Butterknife Zelezny</em></strong>，可以根据选择的xml文件自动生成butterknife的注入代码。</p></li>
<li><p><strong><em>ADB Idea</em></strong>  Android和Intellij IDEA中可用的插件，卸载App、killApp、启动App、重启App、清除App数据、清除App数据并重启。</p></li>
<li><p><strong><em>Another Adb tool</em></strong> 另一个可用adb工具。</p></li>
<li><p><strong><em>Google Developers India , Android Developers</em></strong> 获取最新的Android信息</p></li>
<li><p><strong><em>Android Dev weekly</em></strong>  订阅最新的Android资讯。</p></li>
</ul>

<h2 id="toc_5">三. 向其它开发者学习</h2>

<p>从开源代码中，我们可以学习到不少技巧。</p>

<ul>
<li><p><strong><em>Google I/O</em></strong>  Google I/O是谷歌每年举行的为期两天的开发者大会，会上会展示数百个程序示例。这个工程是会议上的应用程序。应用支持Android 4.0以及更高版本的设备，并针对各种形状和尺寸手机和平板进行优化。</p></li>
<li><p><strong><em>Android App MVP Architecture</em></strong> 这个工程提供了一个比较详细的MVP框架的demo，并且使用了Dagger2、GreenDao、Rxjava、FastAndroidNetworking、PlaceHolderView、AndroidDebugDatabase。</p></li>
<li><p><strong><em>Google Android Architecture Blueprints</em></strong>  在构建应用程序时，我们可能会碰到各种各样的问题，使得我们在测试、维护、扩展应用程序时比较困难。Google Android Architecture Blueprints提供了避免这些常见问题的演示程序，这个项目使用不同的架构和和工具实现了相同的app。</p></li>
<li><p><strong><em>Plaid</em></strong>  提供了设计资讯和灵感，非常好的实践了material design。</p></li>
<li><p><strong><em>Kickstarter</em></strong>  kickstarter是一个全球性的社区，把创造力融入生活中，探索艺术、设计、电影、游戏、音乐等等相关的项目，并且可以把这些项目加入到收藏夹。</p></li>
</ul>

<h2 id="toc_6">四. 其它</h2>

<ul>
<li>开源协议介绍：<strong><em>Developer’s Guide to Open Source Licenses</em></strong></li>
<li>测试入门：<strong><em>Testing Guide</em></strong></li>
<li><p>Android 优化实践：<strong><em>Best Practices for Performance | Android Developers</em></strong></p></li>
<li><p>依赖注入：<br/><br/>
<strong><em>Dagger 2 Dependency Injection for Android Developers</em></strong>  </p></li>
</ul>

<p><strong><em>Introduction to Dagger 2, Using Dependency Injection in Android: Part 1</em></strong>  </p>

<p><strong><em>Fragmented Podcast</em></strong>:Donn Felker 和 Kaushik Gopal在这里介绍Android开发者如何进阶，构建更好的软件。</p>

<p><strong><em>Playbook for Developers：</em></strong><br/>
<figure><img src="media/15561207868433/15713233986674.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/01/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207868399.html">
                
                  <h1>Android 屏幕适配</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Android手机由于厂家未统一，以及某些厂家的标新立异，导致目前Android手机的分辨率和尺寸千奇百怪，无所不有。所以对Android手机的屏幕适配一直开发是一个大问题。要学习这方面的知识，并且掌握是Android开发的一个重头。</p>

<h2 id="toc_1">一、关于屏幕适配的dp、dpi、px</h2>

<h3 id="toc_2">(一) 分辨率,屏幕大小,密度</h3>

<h4 id="toc_3">1、分辨率。</h4>

<p>分辨率就是手机屏幕的像素点数，一般描述成屏幕的“宽×高”，安卓手机屏幕常见的分辨率有480×800、720×1280、1080×1920、1440x2560的2K屏等。720×1280表示此屏幕在宽度方向有720个像素，在高度方向有1280个像素。 </p>

<h4 id="toc_4">2、屏幕大小。</h4>

<p>屏幕大小是手机对角线的物理尺寸，以英寸（inch）为单位。比如某某手机为“5寸大屏手机”，就是指对角线的尺寸，5寸×2.54厘米/寸=12.7厘米。 </p>

<h4 id="toc_5">3、密度（dpi，dots per inch；或PPI，pixels per inch）。</h4>

<p>从英文顾名思义，就是每英寸的像素点数，数值越高当然显示越细腻。假如我们知道一部手机的分辨率是1080×1920，屏幕大小是5英寸，你能否算出此屏幕的密度呢？中学的勾股定理派上用场啦！通过宽1080和高1920，根据勾股定理，我们得出对角线的像素数大约是2203，那么用2203除以5就是此屏幕的密度了，计算结果是440。440dpi的屏幕已经相当细腻了。<br/>
<figure><img src="media/15561207868399/15713276888634.png" alt=""/></figure></p>

<h3 id="toc_6">(二) 实际密度与系统密度</h3>

<p>“实际密度”就是我们自己算出来的密度，这个密度代表了屏幕真实的细腻程度，如上述例子中的440dpi就是实际密度，说明这块屏幕每寸有440个像素。5英寸1080×1920的屏幕密度是440，而相同分辨率的4.5英寸屏幕密度是490。如此看来，屏幕密度将会出现很多数值，呈现严重的碎片化。而密度又是安卓屏幕将界面进行缩放显示的依据，那么安卓是如何适配这么多屏幕的呢？<br/><br/>
其实，每部安卓手机屏幕都有一个初始的固定密度，这些数值是120、160、240、320、480，我们权且称为“系统密度”也称为“广义密度”。大家发现规律没有？相隔数值之间是2倍的关系。一般情况下，240×320的屏幕是低密度120dpi，即ldpi；320×480的屏幕是中密度160dpi，即mdpi；480×800的屏幕是高密度240dpi，即hdpi；720×1280的屏幕是超高密度320dpi，即xhdpi；1080×1920的屏幕是超超高密度480dpi，即xxhdpi。<br/><br/>
安卓对界面元素进行缩放的比例依据正是系统密度，而不是实际密度。<br/><br/>
将一定范围的屏幕密度的设备视为一个特定的密度，比如屏幕密度在240左右的设备视为高密度（hdpi），在320左右的视为超高密度（xhdpi）等。<br/><br/>
<figure><img src="media/15561207868399/15713276988757.png" alt=""/></figure></p>

<h3 id="toc_7">(三) dp、sp、px的区别</h3>

<p>px：即像素，1px代表屏幕上一个物理的像素点；px单位不被建议使用，因为同样100px的图片，在不同手机上显示的实际大小可能不同，偶尔用到px的情况，是需要画1像素表格线或阴影线的时候，用其他单位如dp会显得模糊。<br/><br/>
dp也可写为dip，即density-independent pixel。你可以想象dp更类似一个物理尺寸，比如一张宽和高均为100dp的图片在320×480和480×800的手机上“看起来”一样大。而实际上，它们的像素值并不一样。dp正是这样一个尺寸，不管这个屏幕的密度是多少，屏幕上相同dp大小的元素看起来始终差不多大。<br/><br/>
sp：sp和dp很类似但唯一的区别是，Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），所以目前主流应用字体大小已经改用dp，不用sp，省去用户手动调整字体适配的麻烦。<br/><br/>
<figure><img src="media/15561207868399/15713277097458.png" alt=""/></figure></p>

<h3 id="toc_8">(四) 常规的安卓手机分辨率及其dpi和density的计算</h3>

<p>查看一下现在Android Studio自带的模拟器设备：<br/><br/>
<figure><img src="media/15561207868399/15713277193517.png" alt=""/></figure></p>

<p>手机屏幕的dpi和density的计算：<br/><br/>
以Nexus5X为例：<br/><br/>
<figure><img src="media/15561207868399/15713277290244.png" alt=""/></figure></p>

<p>手机大小5.2英寸，分辨率为1080×1920，那么该手机屏幕的：<br/><br/>
物理宽度：(1080/√￣(1080×1080+1920×1920))*5.2=2.55<br/><br/>
像素密度dpi：1080/2.55=420px/英寸<br/><br/>
密度density：420/160=2.625</p>

<h3 id="toc_9">(五) 转换公式</h3>

<p>dp和px之间的换算：<br/><br/>
dp=px * density<br/><br/>
dp与px的换算要以系统密度为准<br/><br/>
在安卓中，系统密度为160dpi的中密度手机屏幕为基准屏幕，即320×480的手机屏幕。在这个屏幕中，1dp=1px。<br/><br/>
100dp在320×480（mdpi，160dpi）中是100px。那么100dp在480×800（hdpi，240dpi）的手机上是多少px呢？我们知道100dp在两个手机上看起来差不多大，根据160与240的比例关系，我们可以知道，在480×800中，100dp实际覆盖了150px。<br/><br/>
中密度和高密度的缩放比例，720×1280的系统密度为320，320×480的系统密度为160，320/160=2，那么在720×1280中，1dp=2px。同理，在1080×1920中，1dp=3px。<br/><br/>
ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12，我们发现，相隔数字之间还是2倍的关系。计算的时候，以mdpi为基准。比如在720×1280（xhdpi）中，1dp等于多少px呢？mdpi是4，xhdpi是8，2倍的关系，即1dp=2px。反着计算更重要，比如你用PhotoShop在720×1280的画布中制作了界面效果图，两个元素的间距是20px，那开发是多少dp呢？2倍的关系，那就是10dp！<br/><br/>
实际程序中根据不同机型，可以用代码计算相应的转换。<br/><br/>
当安卓系统字号设为“普通”时，sp与px的尺寸换算和dp与px是一样的。比如某个文字大小在720×1280的PS画布中是24px，那么告诉工程师，这个文字大小是12sp。<br/><br/>
实际开发过程中，常规用到的转换公式是：    </p>

<p><figure><img src="media/15561207868399/15713277421619.png" alt=""/></figure></p>

<pre class="line-numbers"><code class="language-java">/**
     *
     * @param context 上下文
     * @param values dp值
     * @return
     */
   public static int dp2px(Context context, int values) {
        float scale = context.getResources().getDisplayMetrics().density;
        return (int) (values * scale + 0.5f);
    }

    public static int px2dip(Context context, float pxValue) {  
        float scale = context.getResources().getDisplayMetrics().density;  
        return (int) (pxValue / scale + 0.5f);  
   } 

     public static int px2sp(Context context, float pxValue) {  
         float fontScale = context.getResources().getDisplayMetrics().scaledDensity;  
         return (int) (pxValue / fontScale + 0.5f);  
   }  

     public static int sp2px(Context context, float spValue) {  
         final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;  
          return (int) (spValue * fontScale + 0.5f);  
   }
</code></pre>

<p>以dp2px为例，这里有一个小细节，根据上面的推导，return的结果应该是 (int) (values * density)，而结果会+0.5f再强转，原因是浮点型强转整型过程直接回去除小数部分，+0.5f相当于四舍五入的过程（小数部分大与0.5的+0.5f后会进一位）,结果显得更加精确。</p>

<h2 id="toc_10">二、资源文件夹之间的关系</h2>

<p>Android开发中，UI一般会制作多种图片素材，根据素材的分辨率大小，放在如下几个文件夹中：<br/><br/>
ldpi（120dpi）<br/><br/>
mdpi（160dpi）<br/><br/>
hdpi（240dpi）<br/><br/>
xdpi（320dpi）<br/><br/>
xxdpi（480dpi）<br/><br/>
xxxdpi（640dpi）<br/><br/>
以mdpi（160dpi）为基准<br/><br/>
可以看出系数比例关系：0.75：1：1.5：2：3：4  </p>

<h3 id="toc_11">(一) 资源文件的加载</h3>

<p>很明显420dpi不属于上述文件分类中的任何一个，安卓手机分辨率千奇百怪，因此，上述文件夹不是指定具体的分辨率，而是一个范围，如ldpi（value&lt;120dpi），mdpi（120dpi&lt;value&lt;160dpi），以此类推，420dpi会加载xxdpi中的资源文件<br/><br/>
验证一下：<br/><br/>
这里有两张图片<br/><br/>
<figure><img src="media/15561207868399/15713277549184.png" alt=""/></figure></p>

<p>将171×171放入xxdpi中，64×64放入xdpi中，用Nexus5X进行测试，应该加载哪个文件夹中的资源呢？</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;ImageView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_centerInParent=&quot;true&quot;
        android:src=&quot;@mipmap/icon_life&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre>

<p>结果如图：<br/><br/>
<figure><img src="media/15561207868399/15713277822314.png" alt=""/></figure> </p>

<p>这个到底是加载的哪个文件夹的图片呢，加载的是171还是64？我也不知道。那么我调换一下，将171×171放入xdpi中，64×64放入xxdpi中，如果图片变小了，那么证明，必然加载的是xxdpi文件夹的图片了。<br/><br/>
结果如图：<br/><br/>
<figure><img src="media/15561207868399/15713277965428.png" alt=""/></figure></p>

<h3 id="toc_12">(二) 建议在xdhpi中作图</h3>

<p>安卓手机有这么多屏幕，我到底依据哪种屏幕作图呢？没有必要为不同密度的手机都提供一套素材，大部分情况下，一套就够了。<br/><br/>
现在手机比较高的分辨率是1080×1920，你可以选择这个尺寸作图，但是图片素材将会增大应用安装包的大小。并且尺寸越大的图片占用的内存也就越高。如果你不是设计ROM，而是做一款应用，我建议大家用PS在720×1280的画布中作图。这个尺寸兼顾了美观性、经济性和计算的简单。美观性是指，以这个尺寸做出来的应用，在720×1280中显示完美，在1080×1920中看起来也比较清晰；经济性是指，这个分辨率下导出的图片尺寸适中，内存消耗不会过高，并且图片文件大小适中，安装包也不会过大；计算的简单，就是1dp=2px啊，多好计算啊！<br/><br/>
做出来的图片，记着让界面工程师放进drawable-xhdpi的资源文件夹中。<br/><br/>
xhdpi (320dpi, 2x) 同iOS @2x 750x1334<br/><br/>
xxdpi (480dpi, 3x) 同iOS @3x 1242x2208（除以1.15，则等比缩放到android的1080*1920)<br/><br/>
淘宝选择2x标注，3x切图，具体讲解如下：<a href="http://blog.csdn.net/zx_android/article/details/51150156">http://blog.csdn.net/zx_android/article/details/51150156</a></p>

<h3 id="toc_13">(三) 屏幕的宽高差异</h3>

<p>在720×1280中作图，要考虑向下兼容不同的屏幕。通过计算我们可以知道，320×480和480×800的屏幕宽度都是320dp，而720×1280和1080×1920的屏幕宽度都是360dp。它们之间有40dp的差距，这40dp在设计中影响还是很大的。如下图蝴蝶图片距离屏幕的左右边距在320dp宽的屏幕和360dp宽的屏幕中就不一样。<br/><br/>
<figure><img src="media/15561207868399/15713278094167.png" alt=""/></figure> <br/>
如果想消除这些比例差异，可以通过添加布局文件来实现。一般情况下，布局文件放在layout文件夹中，如果要单独对360dp的屏幕进行调整，你可以单做做一个布局文件放在layout-w360dp中；不过，最好是默认针对360dp的屏幕布局（较为主流），然后对320dp的屏幕单独布局，将布局文件放到layout-w320dp中；如果你想对某个特殊的分辨率进行调整，那么你可以将布局文件放在标有分辨率的文件夹中，如layout-854×480。</p>

<h3 id="toc_14">(四) 几个资源的文件夹</h3>

<p>在720×1280中做了图片，要让开发人员放到drawable-xhdpi的资源文件夹中，这样才可以显示正确。个人认为仅提供一套素材就可以了，可以测试一下应用在低端手机上运行是否流畅，如果比较卡顿，可以根据需要提供部分mdpi的图片素材，因为xhdpi中的图片运行在mdpi的手机上会比较占内存。<br/><br/>
以应用图标为例，xhdpi中的图标大小是96px，如果要单独给mdpi提供图标，那么这个图标大小是48px，放到drawable-mdpi的资源文件夹中。各个资源文件夹中的图片尺寸同样符合ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12的规律。<br/><br/>
<figure><img src="media/15561207868399/15713278237441.png" alt=""/></figure></p>

<p>如果你把一个高2px的分割线素材做成了9.png图片，你想让细线在不同密度中都是2px，而不被安卓根据密度进行缩放，怎么办？你可以把这个分割线素材放到drawable-nodpi中，这个资源文件夹中的图片，将按照实际像素大小进行显示，而不会被安卓根据密度进行缩放。即在mdpi中细线是2px（2dp），在xhdpi中细线是2px（1dp）。</p>

<h3 id="toc_15">(五) 资源加载优先级</h3>

<p>Google官方文档显示如下：<br/><br/>
如果有最匹配的资源（e.g. 设备是HDPI，存在hdpi的资源），则删除其他的资源。<br/><br/>
如果没有最佳匹配资源，优先匹配更高dpi的资源，缩小合适的比例以后使用（e.g. 设备是HDPI，未能找到hdpi的资源，但是有xhdpi的资源，则把XHDPI的资源缩小的3/4以后使用），并排除其他的资源（Google解释说，因为执行缩小操作比执行放大操作更加方便，所以高dpi资源优先与低dpi资源，不过，个人认为对于大部分图片来说，大图缩小造成的失真应该是小于小图放大造成的失真）。<br/><br/>
如果没最佳匹配的资源，也不存在更高dpi的资源，则使用dpi更低的资源，并放大合适的比例以后使用（e.g. 设备为HDPI，未能找到hdpi以及更高的资源，单存在mdpi的资源，则把mdpi的资源放大到3/2以后使用），并删排除其他资源。<br/><br/>
原则上来说，dalvik优先使用符合设备dpi的资源，其次是dpi较低的高dpi资源，再次是dpi较高的高dpi资源，最后采用nodpi的资源，由此，根据设备自身的dpi的不同，不同dpi资源的优先级是有差异的（忽略mdpi&amp;hdpi）:  </p>

<p><strong>设备dpi优先级顺序</strong>（由高到低）<br/><br/>
tvdpi tvdpi&gt;hdpi&gt;xhdpi&gt;xxhdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpi<br/><br/>
hdpi hdpi&gt;xhdpi&gt;xxhdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpi<br/><br/>
xhdpi xhdpi&gt;xxhdpi&gt;hdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpi<br/><br/>
xxhdpi xxhdpi&gt;xhdpi&gt;hdpi&gt;tvdpi&gt;mdpi&gt;default&gt;ldpi&gt;nodpi<br/><br/>
另外，除了nodpi以外，使用其他dpi资源前，还需要根据缩放比进行缩小/放大操作。</p>

<h3 id="toc_16">(六) 项目实战</h3>

<p><figure><img src="media/15561207868399/15713278416518.png" alt=""/></figure></p>

<p>类似上图是美工标注后的高保真图，分辨率为640*1136，对应到安卓为720p（会有细微偏差），ios为2@，安卓开发同学拿到图，下面的工作就比较简单了。</p>

<ol>
<li>单位换算：只需要将上面的px/2，则得到代码中距离需要的dp，字体大小需要的sp。 </li>
<li>切图处理：美工的切图一律放入xhdpi文件即可</li>
</ol>

<p>这里我举两个适配的例子帮助大家更好的理解。<br/>
<figure><img src="media/15561207868399/15713278544553.png" alt=""/></figure></p>

<ol>
<li><p><strong>【代码适配】</strong>上图大家觉得怎么布局比较好？<br/><br/>
解答：【我加入的圈子】左边空出固定距离，右边【&gt;】空出固定距离，中间铺满屏幕，这样可以让360dp甚至更大的手机，不至于让页面内容缩在中间一小块。再看下下面的布局：<br/>
<figure><img src="media/15561207868399/15713278789378.png" alt=""/></figure></p></li>
<li><p><strong>【动态布局适配】</strong>上图又怎么布局呢？做到各种机型适配。<br/><br/>
我在项目中的做法是，用（屏幕的宽度（像素）-两边的间距-中间间距）/3，这样得到每个图片的宽度，然后图片的高度设置成高图片的宽度相等（当然也可以重写view，自动设置宽等于高） <br/>
代码如下：   </p>
<pre class="line-numbers"><code class="language-java">LinearLayout.LayoutParams linearParams = (LinearLayout.LayoutParams)pic.getLayoutParams(); 
linearParams.width =(context.getResources().getDisplayMetrics().widthPixels-DisplayUtil.dip2px(context, 44)) / 3; <br/>
linearParams.height = linearParams.width; <br/>
pic.setLayoutParams(linearParams); //使设置好的布局参数应用到控件
</code></pre></li>
<li><p><strong>【比重适配】</strong>weight也可以搞定了！的确，可以用比重去做，三个图片各占比为1，再调整下边距，但是高度怎么办，前面说过上，可以重写view,让这个view的高跟宽度相等，这种方式也可以。</p></li>
<li><p><strong>【另类适配】</strong> 应该大家有看到有人提到过纯代码适配，就在在Java代码中动态设置每个view的宽跟高，宽跟高是通过计算得出的。比如设计图是640 * 1136，这个view的宽在640的设计图上是20px。所以有同学会通过DisplayMetrics metrics = res.getDisplayMetrics();screenWidth = metrics.widthPixels screenHeight = metrics.heightPixels;拿到当前屏幕的宽跟高，如果当前手机屏幕是720 * 1280，及screenWidth =720，screenHeight =1280，那么当前的view的宽度等于screenWidth /640 * view的宽度，这样的确非常完美，每部手机都可以等比的缩放。但是代码维护跟开发难度就是成倍的增加，不建议使用。</p></li>
<li><p><strong>【不同的layout适配】</strong> 在res目录下创建不同的layout文件夹，比如：layout-640x360、layout-800x480……所有的layout文件在编译之后都会写入R.java里，而系统会根据屏幕的大小自己选择合适的layout进行使用。这种现在基本不会有人这么适配，不展开讨论。</p></li>
<li><p><strong>【dimen尺寸资源文件的使用】</strong>dimen.xml在values文件夹下面</p>
<pre class="line-numbers"><code class="language-markup">&lt;resources&gt;
&lt;!-- Default screen margins, per the Android Design guidelines. --&gt;<br/>
&lt;dimen name=&quot;btn_width&quot;&gt;16dp&lt;/dimen&gt;<br/>
&lt;dimen name=&quot;btn_height&quot;&gt;16dp&lt;/dimen&gt;<br/>
&lt;/resources&gt;
</code></pre></li>
</ol>

<p><strong>布局中的使用：</strong></p>

<pre class="line-numbers"><code class="language-java">&lt;Button   
android:text=&quot;@string/test_dimen1&quot;   
android:id=&quot;@+id/Button01&quot;   
android:layout_width=&quot;@dimen/btn_width&quot;   
android:layout_height=&quot;@dimen/btn_height&quot;/&gt;
</code></pre>

<p><strong>文件夹含义：</strong> <br/>
values-v11 ——-API 11+代表android 3.0 +，意思是在API11设备上，该目录下的dimens.xml代替res/values/dimens.xml<br/><br/>
values-480x320、values-800x480等 ————意思是在不同分辨率下，该目录下的dimens.xml代替res/values/dimens.xml</p>

<p><figure><img src="media/15561207868399/15713278904773.png" alt=""/></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2016/08/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_17.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_19.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16155265432695.html">混入（mixin）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16145671673295.html">多态</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
