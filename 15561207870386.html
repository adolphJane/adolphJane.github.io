<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android-DataBinding详细学习 - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>Android-DataBinding详细学习</h1>
     
        <div class="read-more clearfix">
          <span class="date">2017/8/8</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Android.html'>Android</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <h2 id="toc_0">前言</h2>

<p>谷歌开发了一个非常厉害的新框架DataBinding， 数据绑定框架给我们带来了很大的方便，以前我们可能需要在每个Activity里写很多的findViewById，不仅麻烦，还增加了代码的耦合性，如果我们使用DataBinding，就可以抛弃那么多的findViewById，省时省力。说到这里，其实网上也有很多快速的注解框架，但是注解框架与DataBinding想比还是不好用，而且官网文档说DataBinding还能提高解析XML的速度，其实DataBinding的好用，不仅仅体现在可以省去使用很多啰嗦findViewById，还有很多。往下看你就会明白的。</p>

<p>在介绍DataBinding之前，肯定要先学会搭建使用它的环境。在Android Studio上Databinding的使用还是很简单的。</p>

<h2 id="toc_1">环境搭建</h2>

<p>Android 的 Gradle 插件版本不低于 1.5.0-alpha1：classpath &#39;com.android.tools.build:gradle:1.5.0&#39;然后修改对应模块（Module）的 build.grade：</p>

<pre class="line-numbers"><code class="language-java">android {
    ....
    dataBinding {
        enabled = true
    }
}
</code></pre>

<p>注意：Android stuido 的版本一定要大于1.3，而且Android Studio目前对binding对象没有自动代码提示，只会在编译时进行检查。<br/>
就是这么简单，但是1.3及以前的版本，对于环境的搭建，可能就会麻烦一点（没事1.3的环境搭建方法，网上多得是）。</p>

<h2 id="toc_2">基础展示</h2>

<p>我们在具体的讲解之前，先用一个简单的小例子来学习一下基础并展现一下DataBinding的巨大魅力，估计你会被其简单的特性所吸引哦。<br/><br/>
首先我们先建立一个java bean，就是一个非常简单的用户类吧。</p>

<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding.bean;
/**
 * Created by loongggdroid on 2016/3/14.
 */
public class User {
    private String name;
    private String age;
    public User(String name, String age) {
        this.name = name;
        this.age = age;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(String age) {
        this.age = age;
    }
    public String getName() {
        return this.name;
    }
    public String getAge() {
        return this.age;
    }
}
</code></pre>

<p>其次，来看看使用了DataBinding之后的布局文件是什么样子的呢？主要的变化是在layout布局文件之中。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.name}&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.age}&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p>看到这里，可能有的人就开始有点迷糊了，没有给控件定义id，而是用了@{ }的方法，到底是怎么回事？先不忙，一会再给你解释，我们再来看看怎么把值传进去的，在Activity中是如何使用的。</p>

<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding;

import android.app.Activity;
import android.databinding.DataBindingUtil;
import android.os.Bundle;

import loonggg.net.databinding.bean.User;
import loonggg.net.databinding.databinding.ActivityMainBinding;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
        User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
        binding.setUser(user);
    }

}
</code></pre>

<p>看到Activity是不是感觉很简洁，很清爽，没有了控件的初始化findViewById，然后再去setText(), 就仅仅只添加了两行代码。运行结果，不用说，显而易见，肯定会显示loonggg和23。</p>

<h2 id="toc_3">基础用法</h2>

<h3 id="toc_4">布局生命</h3>

<p>例子我们介绍完了，对于例子中出现的一些新东西，有必要解释一下，java bean那里就不解释了，大家肯定都懂，我们就从布局文件讲起。相比以前使用的xml，根节点由具体的某个layout（比如LinearLayout ）变成了layout，里面包括了data节点和传统的视图。这里的data节点就像是连接 View 和 Modle 的桥梁。在这个data节点中声明一个variable变量，那值就可以轻松传到布局文件中来了。</p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;!--type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user--&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt; 
    &lt;LinearLayout&gt;
     ……
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p>变量名为user变量类型为&quot;loonggg.net.databinding.bean.User &quot;</p>

<p>type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user，TextView中的@{user.name}就是把这个user中的名字展示出来，age同样如此。</p>

<h3 id="toc_5">绑定Variable</h3>

<p>虽然在布局文件中对应上了，但是值是怎么传进去的呢？这就是我们要将的Activity中的那两行代码了，它把实体类和布局文件进行了绑定。修改MainActivity中的onCreate，用 DatabindingUtil.setContentView() 来替换掉 setContentView()，然后创建一个 user 对象，通过 binding.setUser(user) 与 variable 进行绑定。</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
    binding.setUser(user);
}
</code></pre>

<p>ActivityLayoutDetailBinding这个类是自动生成的和你的布局文件名字一样，如果你想要去改变名字的话</p>

<pre class="line-numbers"><code class="language-markup">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;  
  
    &lt;!--这里你也可以为Binding类进行命名，有三种形式  
        1、Custom:会在databinding包下  
        2、.Custom:会在当前的包名下创建  
        3、com.andly.Custom:会在指定的包名下进行创建--&gt;  
    &lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt; //在app_package/databinding下生成CustomBinding；
    &lt;data class=&quot;.CustomBinding&quot;&gt;&lt;/data&gt; //在app_package下生成CustomBinding；
    &lt;data class=&quot;com.example.CustomBinding&quot;&gt;&lt;/data&gt; // 明确指定包名和类名。
</code></pre>

<h2 id="toc_6">高级用法</h2>

<h3 id="toc_7">import用法</h3>

<p>其实data节点也是支持import用法的，比如：</p>

<pre class="line-numbers"><code class="language-java">&lt;data&gt;
     &lt;import type=&quot;loonggg.net.databinding.bean.User &quot;/&gt;
     &lt;variablename=&quot;user&quot;type=&quot;User&quot; /&gt;
&lt;/data&gt;
</code></pre>

<p>这里需要注意的是：<code>import</code>并不能像java 一样可以 <code>import xx.xxx.*</code>，必须具体到写清楚每个要导入的类名。</p>

<h3 id="toc_8">类名相同</h3>

<p>到这里你可能会问如果import了两个相同名称的类咋办？别怕，人家想的很周到，可以起个别名或者昵称嘛！例如：</p>

<pre class="line-numbers"><code class="language-java">···
&lt;data&gt; 
  &lt;import type=&quot;xxx.User&quot; alias=&quot;MyUser&quot;&gt; 
  &lt;import type=&quot;xxx.xx.User&quot;&gt; 

   &lt;variable 
            name=&quot;user&quot; 
            type=&quot;User&quot; /&gt; 
    &lt;variable 
            name=&quot;myUser&quot; 
            type=&quot;MyUser&quot;/&gt; 
&lt;/data&gt; 
&lt;TextView xxx:@{myUser.getName()}&gt; 
&lt;TextView xxx:@{user.getName()}&gt;
···
</code></pre>

<h3 id="toc_9">变量定义的高级用法</h3>

<p>在上面，我们学会了如何去在xml中定义一些简单的变量。我们没有定义像List、Map等这样的集合变量。那这种集合变量该如何定义呢？其实定义的方式和我们上面的基本一致，区别就在于我们还需要为它定义key的变量，例如：</p>

<pre class="line-numbers"><code class="language-markup">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; 
    &lt;data&gt; 
        &lt;import type=&quot;android.graphics.Bitmap&quot; /&gt; 
        &lt;import type=&quot;java.util.ArrayList&quot; /&gt; 
        &lt;import type=&quot;java.util.HashMap&quot; /&gt;  
        &lt;!-- 集合的定义 --&gt;
        &lt;variable 
            name=&quot;list&quot; 
            type=&quot;ArrayList&amp;lt;String&gt;&quot; /&gt; // 左尖括号需要转义
        &lt;variable 
            name=&quot;map&quot; 
            type=&quot;HashMap&amp;lt;String, String&gt;&quot; /&gt; 
        &lt;variable 
            name=&quot;array&quot; 
            type=&quot;String[]&quot; /&gt; 
        &lt;!-- 为集合定义对应的索引 --&gt;
        &lt;variable 
            name=&quot;listKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;variable 
            name=&quot;mapKey&quot; 
            type=&quot;String&quot; /&gt; 
        &lt;variable 
            name=&quot;arrayKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;!-- 字符串，布尔值和int的用法--&gt;
        &lt;variable 
            name=&quot;str&quot; 
            type=&quot;String&quot;/&gt; 
        &lt;variable 
            name=&quot;error&quot; 
            type=&quot;boolean&quot;/&gt; 
        &lt;variable 
            name=&quot;num&quot; 
            type=&quot;int&quot; /&gt; 
    &lt;/data&gt; 
    &lt;LinearLayout 
        android:orientation=&quot;vertical&quot; 
        android:layout_width=&quot;match_parent&quot; 
        android:layout_height=&quot;wrap_content&quot;&gt; 

        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{list[listKey]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{map[`name`]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{array[0]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{str}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{String.valueOf(num)}&quot;/&gt; 
    &lt;/LinearLayout&gt; 
&lt;/layout&gt;
</code></pre>

<p>在引用的同时也可以加上简单的逻辑运算</p>

<pre class="line-numbers"><code class="language-markup">&lt;!--数据绑定将自动检测null异常，如果你的表达式为null，它将会给它赋值为(null)  
 如果为int类型则默认为0--&gt;  
 &lt;!--之前都是写三元运算符的形式，当然在数据绑定中也能够使用，但更推荐下面那种--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{boo?note:null}&quot; /&gt;  
 &lt;!--?? :null合并运算符，当左边为null会显示右边--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{note??null}&quot;  
     android:textColor=&quot;#00FF00&quot;  
     android:textSize=&quot;18sp&quot; /&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;!--引用资源文件--&gt;  
&lt;ImageView  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:paddingLeft=&quot;@{boo?@dimen/large_padding:@dimen/small_padding}&quot;  
    android:src=&quot;@{image}&quot; /&gt; 
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;TextView  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&#39;@{String.valueOf(map[`one`])}&#39;/&gt;  
</code></pre>

<h3 id="toc_10">Observable数据改变自动更新</h3>

<p><code>Observable</code>是一个接口，它的子类有<code>BaseObservable</code>,<code>ObservableField</code>,<code>ObservableBoolean</code>,<code>ObservableByte</code>, <code>ObservableChar</code>, <code>ObservableShort</code>, <code>ObservableInt</code>, <code>ObservableLong</code>, <code>ObservableFloat</code>, <code>ObservableDouble</code>, and <code>ObservableParcelable</code>，<code>ObservableArrayList</code>,<code>ObservableArrayMap</code><br/>
现在我们来看看 如何在数据改变时，不手动设置，让其自动改变：</p>

<p><strong>布局文件</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Person&quot; /&gt;
        &lt;variable
            name=&quot;person&quot;
            type=&quot;Person&quot; /&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`firstName:`+person.firstName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`lastName:`+person.lastName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`age:`+person.age}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/second_btn1&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;改变数据&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>Person类</strong></p>

<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding.model;

import android.databinding.BaseObservable;
import android.databinding.Bindable;

import www.zhang.com.databinding.BR;

public class Person extends BaseObservable {
    private String firstName;
    private String lastName;
    private int age;
    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    @Bindable
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
        notifyPropertyChanged(BR.firstName);
    }
    @Bindable
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
        notifyPropertyChanged(BR.lastName);
    }
    @Bindable
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
        notifyPropertyChanged(BR.age);
    }
}
</code></pre>

<p>Model类继承BaseObservable,BaseObservable实现 Android.databinding.Observable接口，Observable接口可以允许附加一个监听器到model对象以便监听对象上的所有属性的变化。<br/><br/>
Observable接口有一个机制来添加和删除监听器，但通知与否由开发人员管理。为了使开发更容易，BaseObservable实现了监听器注册机制。DataBinding实现类依然负责通知当属性改变时。这是通过指定一个Bindable注解给getter以及setter内通知来完成的。<br/><br/>
notifyPropertyChanged(BR.参数名)通知更新这一个参数，需要与@Bindable注解配合使用。notifyChange()通知更新所有参数，可以不用和@Bindable注解配合使用</p>

<p><strong>SecondActivity</strong></p>

<pre class="line-numbers"><code class="language-java">public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivitySecondBinding binding = DataBindingUtil.setContentView(SecondActivity.this, R.layout.activity_second);

        final Person person = new Person(&quot;zhang&quot;,&quot;san&quot;,38);
        binding.setPerson(person);

        binding.secondBtn1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                person.setFirstName(&quot;li&quot;);
                person.setLastName(&quot;si&quot;);
                person.setAge(40);
            }
        });
    }
}
</code></pre>

<h4 id="toc_11">示例</h4>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Animal&quot;/&gt;
        &lt;variable
            name=&quot;animal&quot;
            type=&quot;Animal&quot;/&gt;
        &lt;variable
            name=&quot;list&quot;
            type=&quot;android.databinding.ObservableArrayList&amp;lt;String&amp;gt;&quot;/&gt;
        &lt;variable
            name=&quot;map&quot;
            type=&quot;android.databinding.ObservableArrayMap&amp;lt;String,String&amp;gt;&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{animal.field}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{String.valueOf(animal.age)}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[0]}&quot; /&gt;
        &lt;!--Map集合既可以通过map[key]的方式，也可以通过调用API--&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[1]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`name`]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`age`]}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/four_btn&quot;
            android:layout_width=&quot;match_parent&quot;
            android:text=&quot;改变数据&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>Animal类</strong></p>

<pre class="line-numbers"><code class="language-java">public class Animal {
    public final ObservableField&lt;String&gt; field = new ObservableField&lt;&gt;();
    public final ObservableInt age = new ObservableInt();
}
</code></pre>

<p><strong>FourActivity</strong></p>

<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding;

public class FourActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityFourBinding binding = DataBindingUtil.setContentView(FourActivity.this, R.layout.activity_four);
        final Animal animal = new Animal();

        animal.field.set(&quot;cat&quot;);
        animal.age.set(2);
        binding.setAnimal(animal);

        final ObservableArrayList&lt;String&gt; list = new ObservableArrayList&lt;&gt;();
        list.add(&quot;dog&quot;);
        list.add(&quot;mouse&quot;);
        binding.setList(list);

        final ObservableArrayMap&lt;String, String&gt; map = new ObservableArrayMap&lt;&gt;();
        map.put(&quot;name&quot;,&quot;Tom&quot;);
        map.put(&quot;age&quot;,&quot;4&quot;);
        binding.setMap(map);

        binding.fourBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                animal.field.set(&quot;dog&quot;);
                animal.age.set(4);
                list.set(0,&quot;cat&quot;);
                list.set(1,&quot;dog&quot;);
                map.put(&quot;name&quot;,&quot;Sam&quot;);
                map.put(&quot;age&quot;,&quot;5&quot;);
            }
        });

    }
}
</code></pre>

<p>当Animal属性数据改变，list/map集合数据改变，会自动更新数据，我们不需要自己手动设置，省去了一个操作，让我们更专注于业务逻辑。</p>

<h3 id="toc_12">事件的绑定</h3>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
    绑定事件的格式有两种：    
    1、方法引用：直接用handle.Click或者handle::Click  推荐后者  
--&gt;  
&lt;Button  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&quot;@{user.name}&quot;  
    android:onClick=&quot;@{handle::Click}&quot;/&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
     2、监听绑定：使用()组，括号里面所填的是你为参数起的名字，这样你就可以在后面的括号进行引用  
        如果你监听的事件需要返回值，那么你的方法也要返回一个相同类型  
 --&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{()-&gt;handle.eventHandler(user)}&quot;  
     android:text=&quot;传入布局文件中的数据&quot; /&gt;  
  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(thisView)-&gt;handle.eventHandlerView(thisView,user)}&quot;  
     android:text=&quot;传入此View&quot; /&gt;  
 &lt;!--如果你需要为一个点击事件设置一个断言，那么使用void作为一个标志,表示什么也不做--&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.isVisible(v)?handle.doSomething():void}&quot;  
     android:text=&quot;判断是否为visible&quot; /&gt;  
  
 &lt;!--对于一些控件有自己专门的单击事件，需要创建下面的属性进行避免  
    SearchView    android:onSearchClick  
    ZoomControls  android:onZoomIn  
    ZoomControls  android:onZoomOut--&gt;  
 &lt;SearchView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.searchClick(v)}&quot;  
     android:onSearchClick=&quot;@{(v)-&gt;handle.onSearchClick(v)}&quot;&gt;  
  
 &lt;/SearchView&gt;  
</code></pre>

<p>实现监听方法，保证参数个数、类型、返回值都要保证和你使用set时监听一样，不然就出报错。</p>

<pre class="line-numbers"><code class="language-java">public void checkChanged(View view, boolean isCheck) {  
    System.out.println(&quot;checkChanged:&quot; + view + &quot;    &quot; + isCheck);  
}  
  
public boolean longClick(View view) {  
    System.out.println(&quot;longClick:&quot; + view);  
    return true;  
}  
</code></pre>

<p>可以直接在 xml 导入android.view.View.OnClickListener，并制定其点击事件。</p>

<pre class="line-numbers"><code class="language-java">&lt;variable
    name=&quot;clickListener&quot;
    type=&quot;android.view.View.OnClickListener&quot; /&gt;
...
  android:onClick=&quot;@{clickListener}&quot;
...
</code></pre>

<pre class="line-numbers"><code class="language-java">holder.binding.setClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               //do something
        });
</code></pre>

<h3 id="toc_13">表达式</h3>

<p>其实在xml文件中还是支持表达式的，比如说如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&#39;@{error ? &quot;error&quot; : &quot;ok&quot;}&#39;/&gt;
</code></pre>

<p>这是一个布尔值的使用。</p>

<p><strong>下面我们就来看看表达式支持的一下语法和不支持的语法支持的表达式：</strong></p>

<ul>
<li>Mathematical + - / * %<br/></li>
<li>String concatenation +<br/></li>
<li>Logical &amp;&amp; ||<br/></li>
<li>Binary &amp; | ^<br/></li>
<li>Unary + - ! ~<br/></li>
<li>Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt;<br/></li>
<li>Comparison == &gt; &lt; &gt;= &lt;=<br/></li>
<li>instanceof<br/></li>
<li>Grouping ()<br/></li>
<li>Literals - character, String, numeric, null<br/></li>
<li>Cast<br/></li>
<li>Method calls</li>
<li>Field access</li>
<li>Array access []</li>
<li>Ternary operator ?:</li>
</ul>

<p><strong>不支持的表达式：</strong></p>

<ul>
<li>this</li>
<li>super</li>
<li>new</li>
<li>Explicit generic invocation</li>
</ul>

<h3 id="toc_14">在布局中使用include</h3>

<p>如果你需要用到从xml传过来的数据需要去使用bind:user属性，这里的user是你定义的实体类名</p>

<pre class="line-numbers"><code class="language-markup">&lt;!--当你使用include的时候，你可以使用命名空间和属性中的变量名  
来将数据传送到另一个布局中去,值得注意的是当include的父节点为merge时将不支持--&gt;  
&lt;include  
    layout=&quot;@layout/detail_include&quot;  
    bind:user=&quot;@{user}&quot; /&gt; 
</code></pre>

<p>然后只需要在include布局里面声明之后便可以直接使用了。</p>

<h4 id="toc_15">示例</h4>

<p><strong>activity_five.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
 &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;TextView
                android:text=&quot;@string/app_name&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>toolbar.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout &gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
      &lt;variable
          name=&quot;content&quot;
          type=&quot;Content&quot;/&gt;
    &lt;/data&gt;

&lt;android.support.v7.widget.Toolbar
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/toolbar&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_height=&quot;56dp&quot;
    android:layout_width=&quot;match_parent&quot;
    app:title=&quot;@{content.title}&quot;
    app:subtitle=&quot;@{content.subTitle}&quot;
    android:background=&quot;@color/colorPrimary&quot;
    app:titleTextColor=&quot;@android:color/white&quot;
    app:subtitleTextColor=&quot;@android:color/white&quot; /&gt;
&lt;/layout&gt;
</code></pre>

<p>在activity_five.xml中的include属性中定义了一个id,同时又在toolbar.xml中的Toolbar标签中又定义了一个id,其作用是通过binding.toolbar.toolbar等同于Toolbar控件，可以方便做一些操作等(不加id，同样能将变量参数传进去)<br/>
FiveActivity中</p>

<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        ActivityFiveBinding binding =DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;); 
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>

<p><strong>Content</strong></p>

<pre class="line-numbers"><code class="language-java">public class Content extends BaseObservable {
    private String title;
    private String subTitle;

    public Content(String title, String subTitle) {
        this.title = title;
        this.subTitle = subTitle;
    }

    @Bindable public String getSubTitle() {
        return subTitle;
    }

    public void setSubTitle(String subTitle) {
        this.subTitle = subTitle;
        notifyPropertyChanged(BR.subTitle);
    }

    @Bindable public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
        notifyPropertyChanged(BR.title);
    }
}
</code></pre>

<h3 id="toc_16">带id的控件的赋值方式</h3>

<p>对于xml文件中控件的赋值，其实也是可以在java文件中，用java来实现的。我就以最上面那个简单的小例子来说，假如给一个TextView设置的id如下：</p>

<pre class="line-numbers"><code class="language-markup">&lt;TextView
    android:id=&quot;@+id/name&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    /&gt;
</code></pre>

<p>在Activity中这样赋值：</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    binding.name.setText(&quot;非著名程序员&quot;);
}
</code></pre>

<h3 id="toc_17">在布局中使用ViewStub</h3>

<pre class="line-numbers"><code class="language-java">/** 
 * 为ViewStub设置监听，当显示的时候为它绑定数据，因为当不显示的ViewStub会在视图中消失 
 */  
vs = (ViewStub) findViewById(R.id.viewstub);  
vs.setOnInflateListener(new ViewStub.OnInflateListener() {  
    @Override  
    public void onInflate(ViewStub stub, View inflated) {  
        ViewstubBinding viewstubBinding = ViewstubBinding.bind(inflated);  
        Info info = new Info();  
        info.setInfo(&quot;Andly Info&quot;);  
        viewstubBinding.setInfo(info);  
        Drawable d = getResources().getDrawable(R.mipmap.ic_launcher);  
        viewstubBinding.setDrawable(d);  
    }  
});  
  
public void toggleViewStub(View view) {  
    vs.inflate();  
}  
</code></pre>

<h3 id="toc_18">在布局中使用RecycleView控件</h3>

<h4 id="toc_19">1、添加RecycleView控件</h4>

<pre class="line-numbers"><code class="language-markup">&lt;!--  
    这里使用到了自定义属性，因为RecycleView里面有setAdapter方法，所以这里可以直接用app:adapter  
--&gt;  
&lt;android.support.v7.widget.RecyclerView  
    android:id=&quot;@+id/rv&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    app:adapter=&quot;@{adapter}&quot; /&gt;  
</code></pre>

<h4 id="toc_20">2、为RecycleView定义适配器</h4>

<pre class="line-numbers"><code class="language-java">@Override  
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  
    ViewDataBinding viewDataBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), layoutId, parent, false);  
    return new ViewHolder(viewDataBinding);  
}  
@Override  
public void onBindViewHolder(ViewHolder holder, int position) {  
    holder.binding.setVariable(variable, list.get(position));  
    holder.binding.executePendingBindings();  
    //当然这里你也可以为其设置点击如：  
    //holder.binding.getRoot.setOnclickListener()  
}  
@Override  
public int getItemCount() {  
    return list.size();  
}  
  
class ViewHolder extends RecyclerView.ViewHolder {  
    ViewDataBinding binding;  
  
    public ViewHolder(ViewDataBinding binding) {  
        super(binding.getRoot());  
        this.binding = binding;  
    }  
}  
</code></pre>

<h4 id="toc_21">3、为RecycleView设置Adapter</h4>

<pre class="line-numbers"><code class="language-java">//这里注意的是一定要是BR.dataInfo不能是其它的常数  
MyAdapter adapter = new MyAdapter(list, R.layout.rv_item, BR.dataInfo);  
binding.setAdapter(adapter);  
binding.rv.setLayoutManager(new LinearLayoutManager(this));
</code></pre>

<p>这样就大功告成，然而在很多情况我们都需要去对每个Item进行处理，如显示网络图片等等，这里我们就需要使用数据绑定自定义属性的功能，看代码</p>

<pre class="line-numbers"><code class="language-markup">&lt;ImageView  
    android:layout_width=&quot;150dp&quot;  
    android:layout_height=&quot;90dp&quot;  
    app:imageError=&quot;@{@drawable/android}&quot;  
    app:imagePath=&quot;@{dataInfo.imageUrl}&quot; /&gt;  
</code></pre>

<pre class="line-numbers"><code class="language-java">//当你在一个方法只需要一个参数的时候可以使用@BindingAdapter(&quot;imageUrlStr&quot;)，加上之后就可以在布局文件中直接使用imageUrlStr  
//运行之后就会调用loadImage方法  
@BindingAdapter(&quot;imageUrlStr&quot;)  
public static void loadImage(ImageView iv, String url) {  
    Glide.with(iv.getContext()).load(url).into(iv);//这里使用Glide库  
}  
  
//上面是为loadImage传入一个参数，当传入两个或多个参数的时候应使用@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
//这个的ImageView自定义了两个属性一个是imagePath传入的是url,一个是imageError为Drawable  
@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
public static void downloadImage(ImageView iv, String url, Drawable error) {  
    Glide.with(iv.getContext()).load(url).error(error).into(iv);  
}  
</code></pre>

<p>上面的方法使用的是静态方法，如果你不想使用静态方法你需要重写一个数据绑定组件类去实现DataBindingComponent</p>

<pre class="line-numbers"><code class="language-java">public class MyComponent implements android.databinding.DataBindingComponent {  
    private Utils utils;  
    @Override  
    public Utils getUtils() {  
        if (utils == null) {  
            utils = new Utils();  
        }  
        return utils;  
    }  
}  
</code></pre>

<p>然后你需要在Activity为其进行设置</p>

<pre class="line-numbers"><code class="language-java">//第一种方式  
DataBindingUtil.setDefaultComponent(new MyComponent());  
//第二种方式  
ActivityMyListViewBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_my_list_view,new MyComponent());  
//第三种方式  
DataBindingUtil.bind(root,new MyComponent());  
</code></pre>

<p>最后有个不起眼的小功能，就是当使用数据绑定的时候在预览界面不能看到显示的内容，这时你可以为你的控件设置默认显示内容<code>android:text=&quot;@{placeName,default=PLACEHOLDER}&quot;</code></p>

<h5 id="toc_22">示例</h5>

<p><strong>activity_five.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
        &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;android.support.v7.widget.RecyclerView
                android:id=&quot;@+id/recycler&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>recycler_item.xml</strong></p>

<pre class="line-numbers"><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;str&quot;
            type=&quot;String&quot;/&gt;
    &lt;/data&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:text=&quot;@{str}&quot;
            android:gravity=&quot;center_vertical&quot;
            android:textColor=&quot;@android:color/black&quot;
            android:textSize=&quot;16sp&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;48dp&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>

<p><strong>FiveActivity</strong></p>

<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {

    private ActivityFiveBinding binding;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        binding = DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        initToolbar();
        initRecyclerView();
    }

    private void initRecyclerView() {
        LinearLayoutManager manager = new LinearLayoutManager(FiveActivity.this);
        binding.recycler.setLayoutManager(manager);
        binding.recycler.setHasFixedSize(true);
        MyAdapter adapter = new MyAdapter(getApplicationContext());
        binding.recycler.setAdapter(adapter);
    }

    private void initToolbar() {
        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;);
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>

<p><strong>MyAdapter</strong></p>

<pre class="line-numbers"><code class="language-java">public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {

    private Context mContext;
    String[] datas;

    public MyAdapter(Context context) {
        mContext = context;
        datas = context.getResources().getStringArray(R.array.item_list);
    }

    @Override
    public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        RecyclerItemBinding binding = DataBindingUtil.inflate(LayoutInflater.from(mContext), R.layout.recycler_item, parent, false);
        return new MyViewHolder(binding);
    }

    @Override
    public void onBindViewHolder(MyAdapter.MyViewHolder holder, int position) {
        String name = datas[position];
        holder.getBinding().setVariable(www.zhang.com.databinding.BR.str,name);
        //holder.getBinding().setStr(name); //两者都可以

        //executePendingBindings()方法说明
        // When a variable or observable changes, the binding will be scheduled to change before the next frame. 
        // There are times, however, when binding must be executed immediately. 
        // To force execution, use the executePendingBindings() method.
        holder.getBinding().executePendingBindings();//此方法必须执行在UI线程，当绑定的数据修改时更新视图（不知道翻译的准不准）
    }

    @Override
    public int getItemCount() {
        return datas.length;
    }

    public class MyViewHolder extends RecyclerView.ViewHolder {
        private RecyclerItemBinding binding;

        public MyViewHolder(ViewDataBinding binding) {
            super(binding.getRoot());
            this.binding = (RecyclerItemBinding) binding;
        }

        public RecyclerItemBinding getBinding() {
            return binding;
        }

        public void setBinding(RecyclerItemBinding binding) {
            this.binding = binding;
        }
    }
}
</code></pre>

<h3 id="toc_23">@BindingAdapter</h3>

<p>@BindingAdapter用于修饰方法。<br/><br/>
一些属性需要定制绑定逻辑，一个用@BindingAdapter修饰的静态方法可以自定义属性的setter操作。<br/><br/>
android自身实现了大量的Adapter，你可以在项目module的android.databinding.adapters包下找到这些代码。</p>

<pre class="line-numbers"><code class="language-java">public class CardViewBindingAdapter {
    @BindingAdapter(&quot;contentPadding&quot;)
    public static void setContentPadding(CardView view, int padding) {
        view.setContentPadding(padding, padding, padding, padding);
    }
}
</code></pre>

<p><strong>方法内的参数可以设置多个，参数的传递在布局文件中使用自定义命名空间的属性传入。</strong></p>

<ul>
<li>1、默认的你的自定义的命名空间，在匹配时会被忽略。</li>
</ul>

<pre class="line-numbers"><code class="language-text">@BindingAdapter(&quot;contentPadding&quot;)
</code></pre>

<ul>
<li>2、允许重写android的命名空间。</li>
</ul>

<pre class="line-numbers"><code class="language-text"> @BindingAdapter(&quot;android:contentPadding&quot;)
</code></pre>

<p><code>app:contentPadding</code>与<code>android:contentPadding</code>处理行为可以不一样。<br/>
<code>app:contentPadding</code>与<code>custom:contentPadding</code>处理行为是一致的。（仅android是特殊的命名空间）。</p>

<h4 id="toc_24">示例</h4>

<pre class="line-numbers"><code class="language-java">@BindingAdapter({&quot;imageUrl&quot;, &quot;type&quot;, &quot;position&quot;, &quot;debrisfly&quot;, &quot;width&quot;, &quot;height&quot;})
public static void setImageUrl(SimpleDraweeView view, String url, int type, int position, boolean debrisfly, int width, int height) {
    if (url == null) {
        url = &quot;&quot;;
    }
    Uri uri = null;
    switch (type) {
        case 1:
            uri = Util.parse7(url, BocaiApplication.getInstance());
            break;
        case 2:
            uri = Util.parse2(url, BocaiApplication.getInstance());
            break;
        case 3:
            uri = Util.parse3(url, BocaiApplication.getInstance());
            break;

        case 8:
            uri = Util.parse(url, BocaiApplication.getInstance());
            break;
        case 10:
            uri = Util.parseUrlBy230(url, BocaiApplication.getInstance());
            break;
    }
    ControllerListener controllerListener = new BaseControllerListener&lt;ImageInfo&gt;() {
        @Override
        public void onFinalImageSet(
                String id,
                @Nullable ImageInfo imageInfo,
                @Nullable Animatable anim) {
            if (imageInfo == null) {
                return;
            }
            if (anim != null) {
                anim.start();
            }
        }

        @Override
        public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {
        }

        @Override
        public void onFailure(String id, Throwable throwable) {
        }
    };

    DraweeController controller = Fresco.newDraweeControllerBuilder()
            .setControllerListener(controllerListener)
            .setUri(uri)
            .setOldController(view.getController())
            // other setters
            .build();
    view.setController(controller);
    debrisflys(debrisfly, position,view,width,height);
}
</code></pre>

<p>需要注意，当你创建的适配器属性与系统默认的产生冲突时，你的自定义适配器将会覆盖掉系统原先定义的注解，这将会产生一些意外的问题。<br/>
假设需要对下面接口，做适配。</p>

<pre class="line-numbers"><code class="language-java">public interface ILogAction{
      void login();
      void logout();
}
</code></pre>

<p>则需要一个方法一个接口，这么做的原因是避免<code>login()</code>的修改影响到<code>logout()</code>。所以根据业务需要，可能需要排列组合适配这两个接口。</p>

<blockquote>
<p>1、适配 login<br/>
2、适配 logout<br/>
3、适配 login + logout</p>
</blockquote>

<h3 id="toc_25">@BindingBuildInfo</h3>

<pre class="line-numbers"><code class="language-java">@BindingBuildInfo(
buildId=&quot;3fefc6ba-1e95-4dcf-8ffa-278fe0f449bd&quot;,
modulePackage=&quot;com.ipudong.library&quot;,
sdkRoot=&quot;/Users/robert/Library/Android/sdk&quot;,
layoutInfoDir=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug&quot;,
exportClassListTo=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug/_generated.txt&quot;,
isLibrary=true,
minSdk=14,
enableDebugLogs=false,
printEncodedError=true
)
public class DataBindingInfo {}
</code></pre>

<p>在SOURCE阶段会自动生成DataBindingInfo.class，并标记注解如上。</p>

<h3 id="toc_26">@BindingConversion</h3>

<blockquote>
<p>Annotate methods that are used to automatically convert from the expression type to the value used in the setter.<br/><br/>
有时候会遇到类型不匹配的问题，比如<code>R.color.white</code>是<code>int</code>，但是通过Data Binding赋值给<code>android:background</code>属性后，需要把<code>int</code>转换为<code>ColorDrawable</code>。</p>
</blockquote>

<pre class="line-numbers"><code class="language-java">@BindingConversion
public static Drawable convertColorToDrawable(int drawable) {
  return new ColorDrawable(drawable);
}
</code></pre>

<h3 id="toc_27">@BindingMethod &amp;&amp; @BindingMethods</h3>

<blockquote>
<p>Used within an BindingMethods annotation to describe a renaming of an attribute to the setter used to set that attribute.Used to enumerate attribute-to-setter renaming.</p>
</blockquote>

<p><strong>@BindingMethods用于修饰类。</strong></p>

<p>一些属性虽然拥有setters但是并不与名字相匹配，这些方法的属性可以通过 @BindingMethod &amp;&amp; @BindingMethods 注释 setters。</p>

<pre class="line-numbers"><code class="language-java">@BindingMethods({
       @BindingMethod(type = &quot;android.widget.ImageView&quot;,
                      attribute = &quot;android:tint&quot;,
                      method = &quot;setImageTintList&quot;),
})
</code></pre>

<p>开发人员不太可能需要重命名 setters ，因为android框架属性已经实现了这一部分。<br/><br/>
事件的默认值是带有<code>AttrChanged</code>的属性名称。在上面的例子中，默认值是<code>android:textAttrChanged</code>，即使它没有提供。<br/><br/>
事件属性用于通知数据绑定系统值已更改。开发人员通常会创建一个<code>BindingAdapter</code>来分配事件。比如：  </p>

<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>

<p>如同<code>BindingAdapters</code>一样， <code>InverseBindingAdapter</code>方法 也可以将 <code>DataBindingComponent</code>作为第一个参数，可以是具有从<code>DataBindingComponent</code>检索的实例的实例方法。<br/><br/>
<code>InverseBindingListener</code>非常有用。  </p>

<p><a href="https://developer.android.com/reference/android/databinding/InverseBindingListener.html">参考 InverseBindingListener</a></p>

<h3 id="toc_28">@InverseBindingMethod</h3>

<p><code>InverseBindingMethod</code>用于标识如何监听对<code>View</code>属性的更改以及要调用的<code>getter</code>方法。<code>InverseBindingMethod</code> 应该与<code>InverseBindingMethods</code>的部分方法相关联。  </p>

<pre class="line-numbers"><code class="language-java">@InverseBindingMethods({@InverseBindingMethod(
     type = android.widget.TextView.class,
     attribute = &quot;android:text&quot;,
     event = &quot;android:textAttrChanged&quot;,
     method = &quot;getText&quot;)})
 public class MyTextViewBindingAdapters { ... }
</code></pre>

<p>@InverseBindingMethods中的属性method 是可选的。</p>

<blockquote>
<p>如果其没有提供， 属性名称会查找如下几种可能性：方法名称，前缀为is或者get的方法名称。 如属性android:text, 数据绑定框架会在TextView中搜索public CharSequence getText() 方法。</p>
</blockquote>

<p>@InverseBindingMethods中的属性event是可选的。</p>

<blockquote>
<p>如果其没有提供，默认会使用属性名+AttrChanged后缀。如属性android:text, 默认的事件名称android:textAttrChanged。</p>
</blockquote>

<p>这个事件也需要配置相关的<code>@BindingAdapter</code>，如下：</p>

<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>

<h3 id="toc_29">@InverseBindingMethods</h3>

<blockquote>
<p>用于枚举属性，<code>getter</code>和事件关联。</p>
</blockquote>

<h3 id="toc_30">@Untaggable</h3>

<p>Data Binding相关的jar包由四部分组成，</p>

<ol>
<li>baseLibrary-2.1.0-rc1.jar<br/>
    作为运行时类库被打进APK中；</li>
<li>DataBinderPlugin（gradle plugin）<br/>
    在编译期使用，利用gradle-api（之前叫transform-api，1.5生，2.0改名）处理xml文件，生成DataBindingInfo.java；</li>
<li>compiler-2.1.0-rc1.jar<br/>
    在编译器使用，入口类继承自AbstractProcessor，用于处理注解，并生成Binding类，DataBindingCompoent.java，DataBinderMapper.java类；</li>
<li>compilerCommon-2.1.0-rc1.jar<br/>
    被DataBinderPlugin和compiler-2.1.0-rc1.jar所依赖</li>
</ol>

<h3 id="toc_31">改变监听</h3>

<p><code>addOnPropertyChangedCallback： Model</code>属性改变时回调发生 <br/>
<code>OnRebindCallback: view</code>发生改变重复绑定时触发</p>

<pre class="line-numbers"><code class="language-java">mModel.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() {
    @Override
    public void onPropertyChanged(Observable observable, int i) {
        if (i == BR.name) {
            Toast.makeText(TwoWayActivity.this, &quot;name changed&quot;,
                    Toast.LENGTH_SHORT).show();
        } else if (i == BR.password) {
            Toast.makeText(TwoWayActivity.this, &quot;password changed&quot;,
                    Toast.LENGTH_SHORT).show();
        }
    }
});
</code></pre>

<h3 id="toc_32">Component</h3>

<p>通过<code>DataBindingUtil.setDefaultComponent</code>来设置不同环境下不同的<code>Component</code>， <br/>
设置之后就可以使用该<code>Component</code>提供的<code>Adapter</code>方法，默认不设置是全局使用，可以理解为作用域。</p>

<pre class="line-numbers"><code class="language-java">public interface TestableAdapter {
    @BindingAdapter(&quot;android:src&quot;)
    void setImageUrl(ImageView imageView, String url);
}

public interface DataBindingComponent {
    TestableAdapter getTestableAdapter();
}

DataBindingUtil.setDefaultComponent(myComponent); 
 ‐ or ‐
binding = MyLayoutBinding.inflate(layoutInflater, myComponent);
</code></pre>

<h2 id="toc_33">相关编译流程</h2>

<h3 id="toc_34">STEP1 资源处理</h3>

<p><code>aapt</code>或者<code>gradle</code>执行时，都会触发资源处理。在资源处理过程中，<code>DataBinding</code>都会扫描一遍现有的资源，生成不包含<code>&lt;layout&gt;</code>的<code>data-binding-layout-out</code>以及<code>DataBinding</code>所需要的<code>data-binding-info</code>；</p>

<h3 id="toc_35">STEP2 DataBindingInfo.class生成</h3>

<p>在完成资源处理后，<code>aapt</code>或者<code>gradle-api</code>都会去执行<code>DataBindingInfo.class</code>生成操作，把相关的信息写入<code>DataBindingInfo.class</code>的@BindingBuildInfo注解中；</p>

<h3 id="toc_36">STEP3 监听到注解变化</h3>

<p>生成<code>@BindingBuildInfo</code>注解，或者code中发现有新的注解写入，<code>AbstractProcessor</code>注解处理器就开始执行注解处理。<code>DataBinding</code>中有一个<code>ProcessDataBinding.jav</code>a类专门来处理<code>DataBinding</code>相关的注解；</p>

<h3 id="toc_37">STEP4 ProcessDataBinding处理注解，生成bin</h3>

<p><code>ProcessDataBinding</code>中处理注解永远会按顺执行3步，<code>ProcessMethodAdapter</code>，<code>ProcessExpressions</code>，<code>ProcessBindable</code>。每次执行都会从磁盘反序列化对应的bin文件，然后往bin中写入新的，完成后再序列化到磁盘；</p>

<h3 id="toc_38">STEP5 生成最终产物</h3>

<p>执行<code>ProcessMethodAdapter</code>生成<code>DataBindingComponents.class</code>；执行<code>ProcessExpressions</code>生成<code>ViewDataBinding.class</code>子类（ActivityDetail2Binding.class），并触发<code>DataBindingMapper.class</code>更新；执行<code>ProcessBindable</code>生成<code>BR.class</code>，并触发<code>DataBindingMapper.class</code>更新。</p>

<h2 id="toc_39">注意：</h2>

<p>不允许使用混合类型</p>

<pre class="line-numbers"><code class="language-java">&lt;!--值得注意的是  
    android:background=&quot;@{boo?@color/red:@drawable/background}&quot;  
    这么写将会发生错误，因为在BindingConversion默认实现为：  
    @BindingConversion  
    public static ColorDrawable convertColorToDrawable(int color) {  
            return new ColorDrawable(color);  
        }  
--&gt;  
&lt;ImageView  
    android:layout_width=&quot;100dp&quot;  
    android:layout_height=&quot;100dp&quot;  
    android:layout_marginTop=&quot;20dp&quot;  
    android:background=&quot;@{boo?@color/red:@color/green}&quot; /&gt;  
</code></pre>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15561207870348.html" 
          title="Previous Post: Android-ViewStub详细学习">&laquo; Android-ViewStub详细学习</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15561207870315.html" 
          title="Next Post: Android-android:windowSoftInputMode属性详解">Android-android:windowSoftInputMode属性详解 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15712984956484.html">代理模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15712937841703.html">备忘录模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711947460528.html">观察者模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711314242192.html">策略模式</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15711233221322.html">适配器模式</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
