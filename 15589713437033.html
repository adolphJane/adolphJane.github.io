<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	抽象工厂模式 - MagicalRice的Blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">MagicalRice的Blog</a></h1>
					<p class="subtitle">技术博客</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">抽象工厂模式</h1>
		<div class="entry-content" itemprop="articleBody">
			<h2 id="toc_0">抽象工厂模式定义</h2>

<p>抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。</p>

<span id="more"></span><!-- more -->

<p><figure><img src="media/15589713437033/15589726153378.jpg" alt=""/></figure></p>

<h2 id="toc_1">抽象工厂模式与工厂方法模式的区别</h2>

<p>工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构，所以有个产品族的概念。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式中的所有产品都是来自同一个接口或抽象类，而抽象工厂模式中的产品则是来自不同的接口或抽象类。<br/>
抽象工厂模式是工厂方法模式的升级版本，在有多个业务，或者多个分类的情况下，抽象工厂模式比较适合。</p>

<h2 id="toc_2">抽象工厂模式的优缺点</h2>

<ol>
<li>优点
<ul>
<li>隔离了具体类(从调用类的代码可以看出)，非公开。</li>
<li>增加产品下的系列也就是增加具体的实现工厂类很方便，符合“开闭原则”(比如上面的例子中我在两种手机下又新增了一个5.0英寸的，直接加一个新的具体工厂类就可以了)</li>
</ul></li>
<li>缺点
<ul>
<li>抽象工厂模式的产品族扩展是很难的，拿上面的手机举例，如果我增加个一个手机品牌OPPO，那么由两个品牌变成三个品牌，试试改一下会发现：首先要更改抽象工厂类，然后会发现所有的类基本上都跟着动了。改变了抽象类和接口，这是大忌！</li>
<li>类文件增加过快</li>
</ul></li>
</ol>

<h2 id="toc_3">抽象工厂方法模式使用实例</h2>

<h3 id="toc_4">1.两种手机的抽象产品类：</h3>

<pre class="line-numbers"><code class="language-java">public abstract class AbstractHUAWEI {
   //华为手机共同的方法，比如品牌
     public void commonMethod(){

     }
//相同的方法，不同的实现。比如尺寸，型号等等
     public abstract  void  dosomething();
}
</code></pre>

<pre class="line-numbers"><code class="language-java">public abstract class AbstractMI {
   //小米手机共同的方法，比如品牌
   public void commonMethod(){

   }
   //相同的方法，不同的实现。比如尺寸，型号等等
   public abstract  void  dosomething();
}
</code></pre>

<h3 id="toc_5">2.两种手机对应的产品实现类</h3>

<pre class="line-numbers"><code class="language-java">public class HUAWEI_A1 extends AbstractHUAWEI{
   @Override
   public void dosomething() {
       Log.i(&quot;qzs&quot;,&quot;我是6.0英寸的华为手机A1&quot;);
   }
}

public class HUAWEI_A2 extends AbstractHUAWEI {
   @Override
   public void dosomething() {
       Log.i(&quot;qzs&quot;,&quot;我是5.5英寸的华为手机A2&quot;);
   }
}

public class MI_B1 extends AbstractMI {
   @Override
   public void dosomething() {
       Log.i(&quot;qzs&quot;,&quot;我是6.0英寸的小米手机B1&quot;);
   }
}

public class MI_B2 extends AbstractMI {
   @Override
   public void dosomething() {
       Log.i(&quot;qzs&quot;,&quot;我是5.5英寸的小米手机B1&quot;);
   }
}
</code></pre>

<h3 id="toc_6">3.抽象工厂类</h3>

<pre class="line-numbers"><code class="language-java">public abstract class AbstractFactory  {
   //6.0英寸手机
     public abstract  AbstractHUAWEI createSize1();

   //5.5英寸手机
     public abstract  AbstractMI createSize2();
}
</code></pre>

<h3 id="toc_7">4.两个工厂实现类</h3>

<pre class="line-numbers"><code class="language-java">public class Factory1 extends AbstractFactory {
   @Override
   public AbstractHUAWEI createSize1() {
       return new HUAWEI_A1();
   }

   @Override
   public AbstractMI createSize2() {
       return new MI_B1();
   }
}
</code></pre>

<pre class="line-numbers"><code class="language-java">public class Factory2 extends AbstractFactory {
   @Override
   public AbstractHUAWEI createSize1() {
       return new HUAWEI_A2();
   }

   @Override
   public AbstractMI createSize2() {
       return new MI_B2();
   }
}
</code></pre>

<h3 id="toc_8">5.调用</h3>

<pre class="line-numbers"><code class="language-java">AbstractFactory factory1=new Factory1();
AbstractFactory factory2=new Factory2();
//生产A1
AbstractHUAWEI a1=factory1.createHUAWEI();
//   a1.dosomething();
//生产A2
AbstractHUAWEI a2=factory2.createHUAWEI();
// a2.dosomething();
//生产B1
AbstractMI b1=factory1.createMI();
//  b1.dosomething();
//生产B2
AbstractMI b2=factory2.createMI();
//   b2.dosomething();
</code></pre>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>