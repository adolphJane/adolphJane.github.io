<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Android - MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:www.ifantastic.ink ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html">代码之美</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
        
            <li><a href="Flutter.html">Flutter</a></li>
        
            <li><a href="ReactNative.html">ReactNative</a></li>
        
            <li><a href="Java.html">Java</a></li>
        
            <li><a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html">音视频开发</a></li>
        
            <li><a href="%E7%BD%91%E7%BB%9C.html">网络</a></li>
        
            <li><a href="%E7%BD%91%E9%A1%B5.html">网页</a></li>
        
            <li><a href="%E5%B7%A5%E5%85%B7-1-2.html">工具</a></li>
        
            <li><a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html">人工智能</a></li>
        
            <li><a href="%E5%88%9B%E4%B8%9A.html">创业</a></li>
        
            <li><a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html">思维提升</a></li>
        
            <li><a href="GPU%E6%B8%B2%E6%9F%93.html">GPU渲染</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207870497.html">
                
                  <h1>Android-Xfermode详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="xfermode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Xfermode</h2>
<p>Xfermode具体怎么翻译，说实话，我也不知道，我习惯叫它图片混合模式，随便了，管它叫什么，不妨碍我们使用它。关于Xfermode的说明，可以在Google文档中找到这样的描述：Xfermode是在绘图通道中自定义“传输模式”的基类。静态函数创建可以调用或者返回任意作为模式枚举指定的预定义子类实例。当Xfermode分配给Paint，然后绘制对象与Paint就具备了所添加的xfermode。读起来比较拗口，下面直接看Xfermode的源码：</p>
<pre class="line-numbers"><code class="language-java">public class Xfermode {  
    protected void finalize() throws Throwable {  
        try {  
            finalizer(native_instance);  
        } finally {  
            super.finalize();  
        }  
    }  
    private static native void finalizer(long native_instance);  
    long native_instance;  
}  
</code></pre>
<p>看，Xfermode就这么点代码，经验告诉我们，其下必有子类，擦，变元芳了~~~</p>
<p><figure><img src="media/15561207870497/15713323572183.png" alt="" /></figure></p>
<p>查看一下文档发现Xfermode确实有AvoidXfermode、PixelXorXfermode、PorterDuffXfermode，下面来继续学习一下3个子类的用法。</p>
<h2><a id="avoidxfermode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AvoidXfermode</h2>
<p>看这个子类之前告诉大家一个不幸的消息，AvoidXfermode不支持硬件加速，在高于API16的机器上不会适用，如果想测试这个子类。</p>
<ul>
<li>1，可以关闭手机的硬件加速模块；</li>
<li>2，在AndroidManifest.xml中Application节点上设置硬件加速为false。<br />
<code>android:hardwareAccelerated=&quot;false&quot;</code></li>
</ul>
<p>在Android Studio下点击查看一下AvoidXfermode的构造方法：<br />
<code>public AvoidXfermode(int opColor, int tolerance, Mode mode)</code></p>
<p><code>AvoidXfermode</code>的构造方法也特别简单，一共接收3个参数：第一个参数opColor是一个16进制的带透明度通道的颜色值，如0X12345678。第二个参数<code>tolerance</code>表示容差值，什么是容差值呢？可以理解成一个表示“精确”和“模糊”的概念，下面会解释一下。第三个参数是<code>AvoidXfermode</code>的模式，<code>AvoidXfermode</code>的模式一共有两种：<code>AvoidXfermode.Mode.TARGET</code>和<code>AvoidXfermode.Mode.AVOID</code>。</p>
<h2><a id="avoidxfermode-mode-target" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AvoidXfermode.Mode.TARGET</h2>
<p>在该模式下Android会判断画布上的颜色是否会有跟opColor不一样的颜色，比如我opColor是红色，那么在TARGET模式下就会去判断我们的画布上是否有存在红色的地方，如果有，则把该区域“染”上一层我们画笔定义的颜色，否则不“染”色，而tolerance容差值则表示画布上的像素和我们定义的红色之间的差别该是多少的时候才去“染”的，比如当前画布有一个像素的色值是(200, 20, 13)，而我们的红色值为(255, 0, 0)，当tolerance容差值为255时，即便(200, 20, 13)并不等于红色值也会被“染”色，容差值越大“染”色范围越广反之则反，空说无凭我们来看看具体的实现和效果：</p>
<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private AvoidXfermode avoidXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        avoidXfermode = new AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        mPaint.setARGB(255, 211, 53, 243);  
        mPaint.setXfermode(avoidXfermode);  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>
<p>下面来运行看效果，首先确定一下开启的模拟器是API16以下的，或者Application节点下设置了关闭“硬件加速”：</p>
<p><figure><img src="media/15561207870497/15713323776932.png" alt="" /></figure></p>
<p><code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.TARGET)：</code><br />
大家可以看到，在我们的模式为TARGET容差值为0的时候此时只有当图片中像色颜色值为0XFFFFFFFF的地方才会被染色，而其他地方不会有改变</p>
<p>下面我们来修改一下容差值，将容差值改成255：</p>
<p><figure><img src="media/15561207870497/15713323877972.png" alt="" /></figure></p>
<p><code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.TARGET)</code><br />
而当容差值为255的时候只要是跟0XFFFFFFFF有点接近的地方都会被染色</p>
<h2><a id="avoidxfermode-mode-avoid" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AvoidXfermode.Mode.AVOID</h2>
<p>则与TARGET恰恰相反，TARGET是我们指定的颜色是否与画布的颜色一样，而AVOID是我们指定的颜色是否与画布不一样，其他的都与TARGET类似<code>AvoidXfermode(0XFFFFFFFF, 0, AvoidXfermode.Mode.AVOID)：</code></p>
<p><figure><img src="media/15561207870497/15713323978095.png" alt="" /></figure></p>
<p>当模式为AVOID容差值为0时，只有当图片中像素颜色值与0XFFFFFFFF完全不一样的地方才会被染色<code>AvoidXfermode(0XFFFFFFFF, 255, AvoidXfermode.Mode.AVOID)：</code></p>
<p><figure><img src="media/15561207870497/15713324061116.png" alt="" /></figure></p>
<p>当容差值为255时，只要与0XFFFFFFFF稍微有点不一样的地方就会被染色</p>
<p>那么这玩意究竟有什么用呢？比如说当我们只想在白色的区域画点东西或者想把白色区域的地方替换为另一张图片的时候就可以采取这种方式！</p>
<h2><a id="pixelxorxfermode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PixelXorXfermode</h2>
<p>PixelXorXfermode是Xfermode下的另外一种图像混排模式，该类特别简单，不过呢，也很不幸的，在API16中已经过时了。我们来做一个简单的了解，先看PixelXorXfermode的构造方法：<br />
<code>public PixelXorXfermode(int opColor)   </code></p>
<p>构造方法很简单，只要传递一个16进制带透明通道的颜色值即可，那么这个参数有什么用呢？我在Google文档中，找到了这样的一个算法：实际上PixelXorXfermode内部是按照“opColor ^ src ^ dst”这个异或算法运算的，得到一个不透明的(alpha = 255)的色彩值，设置到图像中，下面我们接着上面用到的图片Demo写个PixelXorXfermode的Demo：</p>
<pre class="line-numbers"><code class="language-java">public class CustomView3 extends View {  
  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private Context mContext;  
    private int x, y, w, h;  
    private PixelXorXfermode pixelXorXfermode;  
  
    public CustomView3(Context context) {  
        this(context, null);  
    }  
  
    public CustomView3(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
  
    }  
  
    private void initRes() {  
        //加载bitmap  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取bitmap的展示起始布局  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
        w = ScreenUtil.getScreenW(mContext) / 2 + mBitmap.getWidth() / 2;  
        h = ScreenUtil.getScreenH(mContext) / 2 + mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        pixelXorXfermode = new PixelXorXfermode(0XFFFF0000);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //先绘制Bitmap，src  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
        //随便设置一个纯色测试  
        mPaint.setARGB(255, 211, 53, 243);  
        //设置Xfermode  
        mPaint.setXfermode(pixelXorXfermode);  
        //在bitmap上混排一个纯色的矩形（dst）  
        canvas.drawRect(x, y, w, h, mPaint);  
    }  
}  
</code></pre>
<p>混排后的图像是：</p>
<p><figure><img src="media/15561207870497/15713324266322.png" alt="" /></figure></p>
<p>PixelXorXfermode在底层已经取出src，dst每个像素点与opColor进行了opColor ^ src ^ dst运算了，结果输出就是上图所示的那样！好了，我只学这么多了，因为它已经过时了，同样上面的AvoidXfermode也是，过时了，了解即可。下面是对Xfermode的第三个子类，也是唯一一个还没有过时的，非常重要的子类PorterDuffXfermode的学习。</p>
<h2><a id="porterduffxfermode" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PorterDuffXfermode</h2>
<p>同样PorterDuffXfermode也是Xfermode的子类，我们先看看它的构造方法：<code>public PorterDuffXfermode(PorterDuff.Mode mode)</code></p>
<p><code>PorterDuffXfermode</code>的构造方法很简单，构造方法中需要传递一个<code>PorterDuff.Mode</code>参数，关于<code>PorterDuff.Mode</code>，我们在上篇博客中已经学习完了，其实跟<code>ColorFilter</code>的子类<code>PorterDuffColorFilter</code>的混排模式是一样的。Android系统一共提供了18种混排模式，在模拟器的<code>ApiDemos/Graphics/XferModes</code>，有张效果图：</p>
<p><figure><img src="media/15561207870497/15713324389852.png" alt="" /></figure></p>
<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式已经算法，其中比上图多了ADD和OVERLAY两种模式：</p>
<p><figure><img src="media/15561207870497/15713324526708.png" alt="" /></figure></p>
<p>Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面将会对照ApiDemos/Graphics/XferModes的程序进行修改，来测试各个模块的效果，测试程序如下：</p>
<pre class="line-numbers"><code class="language-java">public class XfermodeView extends View {  
  
    //PorterDuff模式常量 可以在此更改不同的模式测试  
    private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;  
    private PorterDuffXfermode porterDuffXfermode;  
    private int screenW, screenH; //屏幕宽高  
    private Bitmap srcBitmap, dstBitmap;  
    //源图和目标图宽高  
    private int width = 120;  
    private int height = 120;  
  
    public XfermodeView(Context context) {  
        this(context, null);  
    }  
  
    public XfermodeView(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        screenW = ScreenUtil.getScreenW((Activity) context);  
        screenH = ScreenUtil.getScreenH((Activity) context);  
        //创建一个PorterDuffXfermode对象  
        porterDuffXfermode = new PorterDuffXfermode(MODE);  
        //创建原图和目标图  
        srcBitmap = makeSrc(width, height);  
        dstBitmap = makeDst(width, height);  
    }  
  
    //创建一个圆形bitmap，作为dst图  
    private Bitmap makeDst(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFFFFCC44);  
        c.drawOval(new RectF(0, 0, w  3 / 4, h  3 / 4), p);  
        return bm;  
    }  
  
    // 创建一个矩形bitmap，作为src图  
    private Bitmap makeSrc(int w, int h) {  
        Bitmap bm = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);  
        Canvas c = new Canvas(bm);  
        Paint p = new Paint(Paint.ANTI_ALIAS_FLAG);  
        p.setColor(0xFF66AAFF);  
        c.drawRect(w / 3, h / 3, w  19 / 20, h  19 / 20, p);  
        return bm;  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        Paint paint = new Paint();  
        paint.setFilterBitmap(false);  
        paint.setStyle(Paint.Style.FILL);  
        //绘制“src”蓝色矩形原图  
        canvas.drawBitmap(srcBitmap, screenW / 8 - width / 4, screenH / 12 - height / 4, paint);  
        //绘制“dst”黄色圆形原图  
        canvas.drawBitmap(dstBitmap, screenW / 2, screenH / 12, paint);  
  
        //创建一个图层，在图层上演示图形混合后的效果  
        int sc = canvas.saveLayer(0, 0, screenW, screenH, null, Canvas.MATRIX_SAVE_FLAG |  
                Canvas.CLIP_SAVE_FLAG |  
                Canvas.HAS_ALPHA_LAYER_SAVE_FLAG |  
                Canvas.FULL_COLOR_LAYER_SAVE_FLAG |  
                Canvas.CLIP_TO_LAYER_SAVE_FLAG);  
  
        //先绘制“dst”黄色圆形  
        canvas.drawBitmap(dstBitmap, screenW / 4, screenH / 3, paint);  
        //设置Paint的Xfermode  
        paint.setXfermode(porterDuffXfermode);  
        canvas.drawBitmap(srcBitmap, screenW / 4, screenH / 3, paint);  
        paint.setXfermode(null);  
        // 还原画布  
        canvas.restoreToCount(sc);  
    }  
}  
</code></pre>
<p>为了方便观察，需要将Activity_main.xml的背景色设置为黑色。</p>
<p><strong>1.PorterDuff.Mode.CLEAR</strong>。中文描述：所绘制源图像不会提交到画布上。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.CLEAR;</code></p>
<p><figure><img src="media/15561207870497/15713324799406.png" alt="" /></figure></p>
<p><strong>2.PorterDuff.Mode.SRC</strong>。中文描述：只显示源图像。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC;</code></p>
<p><figure><img src="media/15561207870497/15713324920855.png" alt="" /></figure></p>
<p><strong>3.PorterDuff.Mode.DST</strong>。中文描述：只显示目标图像。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST;</code></p>
<p><figure><img src="media/15561207870497/15713325038512.png" alt="" /></figure></p>
<p><strong>4.PorterDuff.Mode.SRC_OVER</strong>。中文描述：正常绘制显示，源图像居上显示。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OVER;</code></p>
<p><figure><img src="media/15561207870497/15713325195114.png" alt="" /></figure></p>
<p><strong>5.PorterDuff.Mode.DST_OVER</strong>。中文描述： 上下层都显示。目标图像居上显示。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OVER;</code></p>
<p><figure><img src="media/15561207870497/15713325338664.png" alt="" /></figure></p>
<p><strong>6.PorterDuff.Mode.SRC_IN</strong>。中文描述： 取两层绘制交集中的源图像。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_IN;</code></p>
<p><figure><img src="media/15561207870497/15713325520933.png" alt="" /></figure></p>
<p><strong>7.PorterDuff.Mode.DST_IN</strong>。中文描述：取两层绘制交集中的目标图像。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_IN;</code></p>
<p><figure><img src="media/15561207870497/15713325672134.png" alt="" /></figure></p>
<p><strong>8.PorterDuff.Mode.SRC_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制源图像。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_OUT;</code></p>
<p><figure><img src="media/15561207870497/15713325797909.png" alt="" /></figure></p>
<p><strong>9.PorterDuff.Mode.DST_OUT</strong>。中文描述：只在源图像和目标图像不相交的地方绘制目标图像。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_OUT;</code></p>
<p><figure><img src="media/15561207870497/15713325970254.png" alt="" /></figure></p>
<p><strong>10.PorterDuff.Mode.SRC_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SRC_ATOP;</code></p>
<p><figure><img src="media/15561207870497/15713326104118.png" alt="" /></figure></p>
<p><strong>11.PorterDuff.Mode.DST_ATOP</strong>。中文描述：在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DST_ATOP;</code></p>
<p><figure><img src="media/15561207870497/15713326227426.png" alt="" /></figure></p>
<p><strong>12.PorterDuff.Mode.XOR</strong>。中文描述：异或：去除两图层交集部分<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.XOR;</code></p>
<p><figure><img src="media/15561207870497/15713326370757.png" alt="" /></figure></p>
<p><strong>13.PorterDuff.Mode.DARKEN</strong>。中文描述：取两图层全部区域，交集部分颜色加深<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.DARKEN;</code></p>
<p><figure><img src="media/15561207870497/15713326508491.png" alt="" /></figure></p>
<p><strong>14.PorterDuff.Mode.LIGHTEN</strong>。中文描述：取两图层全部，点亮交集部分颜色<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.LIGHTEN;</code></p>
<p><figure><img src="media/15561207870497/15713326673606.png" alt="" /></figure></p>
<p><strong>15.PorterDuff.Mode.MULTIPLY</strong>。中文描述：取两图层交集部分叠加后颜色<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.MULTIPLY;</code></p>
<p><figure><img src="media/15561207870497/15713326778042.png" alt="" /></figure></p>
<p><strong>16.PorterDuff.Mode.SCREEN</strong>。中文描述：滤色。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.SCREEN;</code></p>
<p><figure><img src="media/15561207870497/15713326858545.png" alt="" /></figure></p>
<p>以下是<a href="http://lib.csdn.net/base/android">android</a>中新加的两种模式：</p>
<p><strong>17.ADD</strong>。中文描述：饱和度相加。<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.ADD;</code></p>
<p><figure><img src="media/15561207870497/15713326949445.png" alt="" /></figure></p>
<p><strong>18.OVERLAY</strong>。中文描述：叠加<br />
<code>private static final PorterDuff.Mode MODE = PorterDuff.Mode.OVERLAY;</code></p>
<p><figure><img src="media/15561207870497/15713327034956.png" alt="" /></figure></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/15</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870461.html">
                
                  <h1>Android-Paint详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>的确平时开发中，用到画笔的地方还是不多的。但是一遇到自定义View，就会发现这玩意还真是不能不好好掌握，毕竟绘出我们想要的图形界面就靠它了。很多开发人员对画笔Paint的了解知之甚少，包括我自己在内，所以在今天在这里总结一下Paint的在 android图像处理中起到的作用和用法。</p>
<h2><a id="paint%E7%9A%84%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Paint的简单了解</h2>
<p>同样，我们学习Paint之前，首先查看一下Paint类的API，其中，我们最需要关注的地方就是Paint类给我们提供了很多的setter方法，可以通过调用setter方法来设置自己的偏好。下面是在Android Studio中查到的Paint类的部分setter：</p>
<p><figure><img src="media/15561207870461/15713327196078.png" alt="" /></figure></p>
<ul>
<li><code>Paint(int flags)</code>：构建Paint实例，常用的flags是ANTI_ALIAS_FLAG，消除锯齿。</li>
<li><code>set(Paint src)</code>：将另一个Paint复制给当前Paint实例，不多说了。</li>
<li><code>setColor(int color)</code>：设置画笔的颜色。</li>
<li><code>setColorFilter(ColorFilter filter)</code>：设置色彩过滤器，很重要，后面还会有一些总结。</li>
<li><code>setStyle(Paint.Style style)</code>：设置Paint的风格。 画笔样式分三种：1.Paint.Style.STROKE：描边 。2.Paint.Style.FILL_AND_STROKE：描边并填充 。3.Paint.Style.FILL：填充 。</li>
<li><code>setAlpha(int a)</code> : 设置绘制图形的透明度。</li>
<li><code>setAntiAlias(boolean aa)</code>：是否消除锯齿。</li>
<li><code>setARGB(int a,int r,int g,int b)</code> : 设置绘制的颜色，a代表透明度，r，g，b代表颜色值。</li>
<li><code>setStrokeWidth(float width)</code>：设置Paint划线的宽度。</li>
<li><code>setDither(boolean dither)</code> : 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰</li>
<li><code>setElegantTextHeight(boolean elegant)</code> : //设置优雅的文字高度，这个设置可能会对FontMetrics产生影响</li>
<li><code>setFakeBoldText(boolean fakeBoldText)</code> : //设置文本粗体</li>
<li><code>setFilterBitmap(boolean filter)</code> : //对位图进行滤波处理，如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示</li>
<li><code>setFlags(int flags)</code> : //设置一些标志，比如抗锯齿，下划线等等。</li>
<li><code>setFontFeatureSettings(String settings)</code> : //设置字体样式，可以设置CSS样式</li>
<li><code>setHinting(int mode)</code> : 设置画笔的隐藏模式。可以是 <code>HINTING_OFF</code> or <code>HINTING_ON</code>之一。</li>
<li><code>setLetterSpacing(float letterSpacing)</code> : //设置行的间距，默认值是0，负值行间距会收缩</li>
<li><code>setLinearText(boolean linearText)</code> : //这个是文本缓存，设置线性文本，如果设置为true就不需要缓存</li>
<li><code>setMaskFilter(MaskFilter maskfilter)</code> : //对图像进行一定的处理，实现滤镜的效果，如滤化，立体等,有BlurMaskFilter，EmbossMaskFilter几种</li>
<li><code>setPathEffect(PathEffect effect)</code> : //设置绘制路径的效果，有ComposePathEffect，CornerPathEffect，DashPathEffect，DiscretePathEffect，PathDashPathEffect，SumPathEffect几种</li>
<li><code>setShader(Shader shader)</code> : //设置着色器，用来给图像着色的，绘制出各种渐变效果，有BitmapShader，ComposeShader，LinearGradient，RadialGradient，SweepGradient几种</li>
<li><code>setShadowLayer(float radius, float dx, float dy, int shadowColor)</code> : //设置阴影效果，radius为阴影角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 ，看一下演示效果，其中第一个是没有阴影的，第二个设置了黑色的阴影</li>
<li><code>setStrikeThruText(boolean strikeThruText)</code> : //设置文本的删除线</li>
<li><code>setStrokeCap(Cap cap)</code> : //设置线条末端形状<code>Paint.Cap.BUTT</code>、<code>Paint.Cap.ROUND</code>、<code>Paint.Cap.SQUARE</code></li>
<li><code>setStrokeJoin(Join join)</code> : //设置矩形连接时的效果<code>Paint.Join.BEVEL</code>、<code>Paint.Join.MITER</code>、<code>Paint.Join.ROUND</code></li>
<li><code>setStrokeMiter(float miter)</code> : //当style为Stroke或StrokeAndFill时设置连接处的倾斜度，这个值必须大于0</li>
<li><code>setSubpixelText(boolean subpixelText)</code> : //设置亚像素，是对文本的一种优化设置，可以让文字看起来更加清晰明显，可以参考一下PC端的控制面板-外观和个性化-调整ClearType文本</li>
<li><code>setTextAlign(Align align)</code> : //设置文本对齐<code>Paint.Align.CENTER</code>、<code>Paint.Align.LEFT</code>、<code>Paint.Align.RIGHT</code></li>
<li><code>setTextLocale(Locale locale)</code> ： //设置地理位置，比如显示中文，日文，韩文等，默认的显示Locale.getDefault()即可</li>
<li><code>setTextScaleX(float scaleX)</code> : //设置字体的水平方向的缩放因子，默认值为1，大于1时会沿X轴水平放大，小于1时会沿X轴水平缩小</li>
<li><code>setTextSize(float textSize)</code> : //设置字体大小</li>
<li><code>setTextSkewX(float skewX)</code> : //设置文本在水平方向上的倾斜，默认值为0，推荐的值为-0.25</li>
<li><code>setTypeface(Typeface typeface)</code> : //设置字体样式，可以是Typeface设置的样式，也可以通过Typeface的createFromAsset(AssetManager mgr, String path)方法加载样式</li>
<li><code>setUnderlineText(boolean underlineText)</code> : //设置文本的下划线</li>
<li><code>setXfermode(Xfermode xfermode)</code>：设置Paint的模式，后面有详细点的说明，很重要。</li>
<li><code>reset()</code> : //重置Paint</li>
<li><code>measureText(char[] text, int index, int count)</code>，<code>measureText(String text, int start, int end)</code>，<code>measureText(String text)</code>，<code>measureText(CharSequence text, int start, int end)</code> : //测量字体的长度</li>
<li><code>breakText(char[] text, int index, int count,float maxWidth, float[] measuredWidth)</code>，<code>breakText(CharSequence text, int start, int end,boolean measureForwards,  floatmaxWidth, float[] measuredWidth)</code>，<code>breakText(String text, boolean measureForwards,float maxWidth, float[] measuredWidth)</code> : //剪切显示，就是大于maxWidth的时候只截取指定长度的显示</li>
<li><code>getTextWidths(char[] text, int index, int count,float[] widths)</code>，<code>getTextWidths(CharSequence text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, int start, int end, float[] widths)</code>，<code>getTextWidths(String text, float[] widths)</code> : //提取指定范围内的字符串，保存到widths中</li>
<li><code>getTextPath(char[] text, int index, int count, float x, float y, Path path)</code>，<code>getTextPath(String text, int start, int end, float x, float y, Path path)</code> : //获取文本绘制的路径，提取到Path中</li>
<li><code>getTextBounds(String text, int start, int end, Rect bounds) </code>，<code>getTextBounds(char[] text, int index, int count, Rect bounds)</code> : //得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870430.html">
                
                  <h1>Android-ColorFilter详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>在Android Studio中点击进去看一下源码，可以看到ColorFilter里的代码量很少</p>
<pre class="line-numbers"><code class="language-java">public class ColorFilter {  
    /** 
     * Holds the pointer to the native SkColorFilter instance. 
     * 
     * @hide 
     */  
    public long native_instance;  
  
    @Override  
    protected void finalize() throws Throwable {  
        try {  
            super.finalize();  
        } finally {  
            destroyFilter(native_instance);  
        }  
    }  
  
    static native void destroyFilter(long native_instance);  
}
</code></pre>
<p>由此根据我们的经验，判断ColorFilter可能是个父类，具体实现可能下面还有子类完成的，于是再看Google的文档：</p>
<p><figure><img src="media/15561207870430/15713327420386.png" alt="" /></figure></p>
<p>一目了然了，ColorFilter下有3个子类ColorMatrixColorFilter, LightingColorFilter, PorterDuffColorFilter ，下面逐一学习一下。</p>
<h2><a id="colormatrixcolorfilter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ColorMatrixColorFilter</h2>
<p><code>ColorMatrixColorFilter</code>翻译为颜色矩阵过滤器，神马是颜色矩阵？实际上， 安卓中管理色彩矩阵是以RGBA像素点的方式加载到内存的，这些点统一使用<code>ColorMatrix</code>的矩阵来统一管理，矩阵定义为4*5的排列形式。那好，首先来看看<code>ColorMatrixColorFilter</code>的两个构造器：</p>
<pre class="line-numbers"><code class="language-java">public ColorMatrixColorFilter(ColorMatrix matrix) {  
        mMatrix.set(matrix);  
        update();  
}  
  
public ColorMatrixColorFilter(float[] array) {  
        if (array.length &lt; 20) {  
            throw new ArrayIndexOutOfBoundsException();  
        }  
        mMatrix.set(array);  
        update();  
}  
</code></pre>
<p>ColorMatrixColorFilter中一个构造器需要接收ColorMatrix对象，另一个需要接收一个4*5的float型数组，我们再打开Android Studio追踪一下mMatrix.set()方法，可以看到以上两个构造器里面调的set方法各自实现的方式</p>
<pre class="line-numbers"><code class="language-java">public void set(ColorMatrix src) {  
        System.arraycopy(src.mArray, 0, mArray, 0, 20);  
}  
  
public void set(float[] src) {  
        System.arraycopy(src, 0, mArray, 0, 20);  
}  
</code></pre>
<p>再追踪一下System.arraycopy()方法：</p>
<pre class="line-numbers"><code class="language-java">public static void arraycopy(float[] src, int srcPos, float[] dst, int dstPos, int length)
</code></pre>
<p>好了，到这里，其实已经很明白了，ColorMatrixColorFilter构造器中接收的两个不同的参数，实际上底层实现方式都是一样的，都是同样调用System.arraycopy()中带float数组参数的方法。所以我们不必再考虑怎么样去写一个ColorMatrix对象传递给ColorMatrixColorFilter了，实际上我们使用第二个构造器，传递一个float数组，会显得程序更加直观易懂，那么我们就尝试写一个ColorMatrixColorFilter，并且设置给Paint吧.</p>
<pre class="line-numbers"><code class="language-java">public class CustomView1 extends View {  
    private Paint mPaint;  
    private Context mContext;  
    public CustomView1(Context context) {  
        this(context, null);  
    }  
  
    public CustomView1(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initPaint();  
    }  
    private void initPaint() {  
        //初始化Paint，并且设置消除锯齿。  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        //设置画笔样式为描边  
        mPaint.setStyle(Paint.Style.FILL);  
        //设置描边的粗细，单位：像素px 注意：当setStrokeWidth(0)的时候描边宽度并不为0而是只占一个像素  
        mPaint.setStrokeWidth(20);  
        //设置画笔颜色为自定义颜色  
        mPaint.setColor(Color.argb(255, 255, 128, 102));  
        ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1, 0, 0, 0, 0,  
                0, 1, 0, 0, 0,  
                0, 0, 1, 0, 0,  
                0, 0, 0, 1, 0  
        });  
        mPaint.setColorFilter(colorFilter);  
    }  
    @Override  
    protected void onDraw(Canvas canvas) {  
        //画一个圆形，取屏幕中心点为圆心  
        canvas.drawCircle(ScreenUtil.getScreenW(mContext) / 2,  
                ScreenUtil.getScreenH(mContext) / 2, 100, mPaint);  
    }  
}
</code></pre>
<p>看上面的例子程序，首先创建了一个ColorMatrixColorFilter对象，并且传递进去一个float型的4*5排列的数组，然后调用Paint的setColorFilter方法将ColorMatrixColorFilter对象传入，我们在模拟器上运行一下，duang~~，我去，什么变化都没有，还是岛国的旗帜。这是怎么回事？下面有必要在学习一下了：</p>
<p>其实一个4*5的float数组中分别对应的是RGBA的向量值，第一行代表的是R(红色)的向量值，第二行代表G(绿色)的向量值，第三行代表B(蓝色)的向量值，第四行代表A(透明度)的向量值，这4行分别代表不同的RGBA的向量值，并且值的取值范围是[0.0F , 2.0F]，当值为1.0F的时候，表示保持原有的色彩，不发生色彩便宜。so，如果我们想要将上面的红色的圈圈颜色变掉，就不能像上面的代码一样，将所有的向量值都设置为1.0F，下面我们修改一个：</p>
<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.5F, 0, 0, 0, 0,  
                0, 0.5F, 0, 0, 0,  
                0, 0, 0.5F, 0, 0,  
                0, 0, 0, 1, 0  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>
<p>将上面的ColorMatrixColorFilter中的float数组替换成这样的<br />
哎哟呵~颜色变深了，看起来神奇很多。那么，这个色彩矩阵以及这个float数组是怎样做到的呢？或者说是怎样通过计算后得到另外一个色彩值的呢？下面作图来说明一下，我们顶一个ColorMatrix的4*5的float型数组，然后定义一个我们自己MyColor，分别代表RGBA的值：</p>
<p><figure><img src="media/15561207870430/15713327557838.jpg" alt="" /></figure></p>
<p>实际上，安卓系统计算色彩值是用矩阵相乘的方式得出的，如上图的样子。这里的MyColor的各项值都要转换到[0,1]之间的值，下面就是我们实际转换的计算方式和结果了。</p>
<p><figure><img src="media/15561207870430/15713327650356.jpg" alt="" /></figure></p>
<p>通过上面的计算，我们得到了最终的RGBA的值是（0.5,0.25,0.2,1），说明RGB色彩值都发生了便宜，只有A未偏移，然后我们将这些值乘以255后还原一下看看，是不是跟上图的圈圈的色彩值是一致的呢，好吧，别看了，肯定必须一定是一样的。那么了解色彩矩阵有什么用呢？上面简单的更换一下色彩值而已，Paint类下也提供了setColor()方法，直接将色彩值设置上去，都TMD的方便，还搞什么玩意的矩阵，显得自己牛逼+蛋疼是不是？解释一下，上面的例子不过是个例子而已啊，真正开发的时候肯定是setColor比较简便嘛。问题来了，我们有可能处理的不是一个纯色彩的东西，而是一直图片呢？一张图片是有几十万中色彩值的，这时候setColor()就不可能让他们变色了吧，还是得用色彩矩阵来搞这玩意。下面我们从drawable目录下加载一张图片吧！</p>
<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>
<p><figure><img src="media/15561207870430/15713327784421.png" alt="" /></figure></p>
<p>好了图片加载完毕，代码没有难度，上面的Paint没有做任何的处理，下面我们为Paint设置色彩过滤器吧！</p>
<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0.33F, 0.59F, 0.11F, 0, 0,  
                0, 0, 0, 1, 0,  
});  
mPaint.setColorFilter(colorFilter);  
</code></pre>
<p><figure><img src="media/15561207870430/15713327887731.png" alt="" /></figure></p>
<p>好吧图片变成黑白的了，难道setColor()也可以办吗？再改一个试试：</p>
<pre class="line-numbers"><code class="language-java">ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(new float[]{  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                1.5F, 1.5F, 1.5F, 0, -1,  
                0, 0, 0, 1, 0,  
        });  
mPaint.setColorFilter(colorFilter);  
</code></pre>
<p><figure><img src="media/15561207870430/15713328018868.png" alt="" /></figure></p>
<p>这样的效果是不是有点像负片效果啊！好了，反正我也不懂图像学，ColorMatrixColorFilter想设置什么样的就改改矩阵就行了，到底需要什么效果，效果的值要设置成多少，我也不知道，问问美工吧！我们只负责写程序！呵呵~~</p>
<h2><a id="lightingcolorfilter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LightingColorFilter</h2>
<p>LightingColorFilter顾名思义就是“光照色彩过滤器”，就是模拟一个光照照过图像所产生的效果，构造器是这样的：<br />
<code>public LightingColorFilter(int mul, int add)</code><br />
查看一下Google文档，是这样介绍滴：</p>
<p>光照色彩滤光片，可以用来模拟简单的照明效果。一个lightingcolorfilter定义了两个参数，一个用于与源颜色相乘（称为colormultiply）和一个用于添加到源颜色（称为coloradd）。alpha通道是原封不动的彩色滤光片。给定一个源颜色的RGB，由此产生的特定颜色计算如下：</p>
<pre class="line-numbers"><code class="language-plain_text">R' = R * colorMultiply.R + colorAdd.R
G' = G * colorMultiply.G + colorAdd.G
B' = B * colorMultiply.B + colorAdd.B
</code></pre>
<p>每个通道值的结果范围是0~255。上面的介绍写的比较明白， 算法也很简单，我们以上面的原图为例，看见蓝天了吗，我们现在去掉这个蓝色的天。根据这个短发描述呢，我们仅仅去掉蓝色，就要将蓝色的通道值改变，将B计算为其它值，这时候colorMultiply.B = 00，colorAdd.B =00，计算得到的B = 00，其它的通道R和G均不变，那么,colorAdd.R=0，colorAdd.G =0；colorMultiply.R = FF，colorMultiply.G =FF，Alpha通道A是忽略的，所以随便设置什么都不会有变化的。</p>
<pre class="line-numbers"><code class="language-java">LightingColorFilter colorFilter = new LightingColorFilter(0xFFFFFF00, 0x00000000);  
mPaint.setColorFilter(colorFilter);
</code></pre>
<p>运行之后的结果，蓝天没了。</p>
<p><figure><img src="media/15561207870430/15713328128205.png" alt="" /></figure></p>
<h2><a id="porterduffcolorfilter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PorterDuffColorFilter</h2>
<p>ColorFilter下还有最后一个子类，PorterDuff混合模式的色彩过滤器，下面是其构造器：<br />
<code>public PorterDuffColorFilter(int color, PorterDuff.Mode mode)</code></p>
<p>Google文档：PorterDuff滤光器可以用于点源像素使用一个单一的颜色和一个特定的波特达夫复合模式。</p>
<p>PorterDuffColorFilter的构造器也很简单，其中第一个参数表示一个16进制的色彩值，第二个参数是一个枚举值PorterDuff.Mode，表示图片混排的模式，PorterDuff.Mode在Android下一共有16种。下面我们先写一个小例子看一下，这里我们还是使用上面的图片，为原图添加图片混排模式，颜色值设置为红色0XFFFF0000，混排模式设置为PorterDuff.Mode.DARKEN。</p>
<pre class="line-numbers"><code class="language-java">public class CustomView2 extends View {  
  
    private Context mContext;  
    private Paint mPaint;  
    private Bitmap mBitmap;  
    private int x, y;  
  
    public CustomView2(Context context) {  
        this(context, null);  
    }  
  
    public CustomView2(Context context, AttributeSet attrs) {  
        super(context, attrs);  
        mContext = context;  
        initRes();  
        initPaint();  
    }  
  
    private void initRes() {  
        //获取图片  
        mBitmap = BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.image);  
        //获取图片显示起始位置  
        x = ScreenUtil.getScreenW(mContext) / 2 - mBitmap.getWidth() / 2;  
        y = ScreenUtil.getScreenH(mContext) / 2 - mBitmap.getHeight() / 2;  
    }  
  
    private void initPaint() {  
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);  
        PorterDuffColorFilter colorFilter = new PorterDuffColorFilter(0XFFFF0000, PorterDuff.Mode.DARKEN);  
        mPaint.setColorFilter(colorFilter);  
    }  
  
    @Override  
    protected void onDraw(Canvas canvas) {  
        canvas.drawBitmap(mBitmap, x, y, mPaint);  
    }  
}  
</code></pre>
<p>上面的图片就是运行之后的效果了，原图不仅变红了，而且还变暗了。其实我们这里将PorterDuffColorFilter的构造器参数拆开来分析一下，首先我们传递进去一个红色的颜色值0XFFFF0000，这里相当于创建了一张新的图层，图层的颜色就是0XFFFF0000，而我们的原图可以看作是第二张图层，我们先把这2个图片重叠放在一起，就会发现得到一个原图上很红的图片，然后我们看一下PorterDuff.Mode是DARKEN模式，表示在之前得到的“原图+很红”的图片上进一步将色调调成暗色，最终得到了如上所示的图片。</p>
<p>关于PorterDuff.Mode，Android系统一共提供了18种混排模式，在模拟器的ApiDemos/Graphics/XferModes，有张效果图：</p>
<p><figure><img src="media/15561207870430/15713328265702.png" alt="" /></figure></p>
<p>这张图可以很形象的说明图片各种混排模式下的效果。其中Src代表原图，Dst代表目标图，两张图片使用不同的混排方式后，得到的图像是如上图所示的。  PorterDuff.Mode也提供了18种混排模式算法，其中比上图多了ADD和OVERLAY两种模式：</p>
<p><figure><img src="media/15561207870430/15713328371456.png" alt="" /></figure></p>
<p>其中Sa全称为Source alpha表示源图的Alpha通道；Sc全称为Source color表示源图的颜色；Da全称为Destination alpha表示目标图的Alpha通道；Dc全称为Destination color表示目标图的颜色，[...,..]前半部分计算的是结果图像的Alpha通道值，“,”后半部分计算的是结果图像的颜色值。图像混排后是依靠这两个值来重新计算ARGB值的，具体计算算法，抱歉，我也不知道，不过不要紧，不了解计算算法也不影响我们程序员写程序的。我们只要对照上面的apiDemo中提供的图片就能推测出混排后的结果的，下面是在网上找到的汉字语言描述，感谢这位作者的总结。</p>
<p>注意：先绘制dst，再绘制src。</p>
<ul>
<li><strong>1.PorterDuff.Mode.CLEAR</strong>    所绘制源图像不会提交到画布上。</li>
<li><strong>2.PorterDuff.Mode.SRC</strong>    只显示源图像。</li>
<li><strong>3.PorterDuff.Mode.DST</strong>    只显示目标图像。</li>
<li><strong>4.PorterDuff.Mode.SRC_OVER</strong>    正常绘制显示，源图像居上显示。</li>
<li><strong>5.PorterDuff.Mode.DST_OVER</strong>    上下层都显示。目标图像居上显示。</li>
<li><strong>6.PorterDuff.Mode.SRC_IN</strong>    取两层绘制交集中的源图像。</li>
<li><strong>7.PorterDuff.Mode.DST_IN</strong>     取两层绘制交集中的目标图像。</li>
<li><strong>8.PorterDuff.Mode.SRC_OUT</strong>    只在源图像和目标图像不相交的地方绘制源图像。</li>
<li><strong>9.PorterDuff.Mode.DST_OUT</strong>    只在源图像和目标图像不相交的地方绘制目标图像。</li>
<li><strong>10.PorterDuff.Mode.SRC_ATOP</strong>    在源图像和目标图像相交的地方绘制源图像，在不相交的地方绘制目标图像。</li>
<li><strong>11.PorterDuff.Mode.DST_ATOP</strong>   在源图像和目标图像相交的地方绘制目标图像而在不相交的地方绘制源图像。</li>
<li><strong>12.PorterDuff.Mode.XOR</strong>    异或：去除两图层交集部分</li>
<li><strong>13.PorterDuff.Mode.DARKEN</strong>     取两图层全部区域，交集部分颜色加深</li>
<li><strong>14.PorterDuff.Mode.LIGHTEN</strong>   取两图层全部，点亮交集部分颜色</li>
<li><strong>15.PorterDuff.Mode.MULTIPLY</strong>    取两图层交集部分叠加后颜色</li>
<li><strong>16.PorterDuff.Mode.SCREEN</strong>    滤色。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/13</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870348.html">
                
                  <h1>Android-ViewStub详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>在开发应用程序的时候，经常会遇到这样的情况，会在运行时动态根据条件来决定显示哪个View或某个布局。那么最通常的想法就是把可能用到的View都写在上面，先把它们的可见性都设为<code>View.GONE</code>，然后在代码中动态的更改它的可见性。这样的做法的优点是逻辑简单而且控制起来比较灵活。但是它的缺点就是，耗费资源。虽然把View的初始可见<code>View.GONE</code>但是在Inflate布局的时候View仍然会被Inflate，也就是说仍然会创建对象，会被实例化，会被设置属性。也就是说，会耗费内存等资源。</p>
<h2><a id="viewstub" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ViewStub</h2>
<p>上面的问题，推荐的做法是使用 Android.view.ViewStub，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。可以为ViewStub指定一个布局，在Inflate布局的时候，只有ViewStub会被初始化，然后当ViewStub被设置为可见的时候，或是调用了<code>ViewStub.inflate()</code>的时候，ViewStub所向的布局就会被Inflate和实例化，然后ViewStub的布局属性都会传给它所指向的布局。这样，就可以使用ViewStub来方便的在运行时，要还是不要显示某个布局。<br />
但ViewStub也不是万能的，下面总结下ViewStub能做的事儿和什么时候该用ViewStub，什么时候该用可见性的控制。</p>
<h2><a id="%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>特点</h2>
<ul>
<li>ViewStub只能Inflate一次，之后ViewStub对象会被置为空。按句话说，某个被ViewStub指定的布局被Inflate后，就不能够再通过ViewStub来控制它了。</li>
<li>ViewStub只能用来Inflate一个布局文件，而不是某个具体的View，当然也可以把View写在某个布局文件中。</li>
</ul>
<h2><a id="%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8viewstub%E7%9A%84%E6%83%85%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可以考虑使用ViewStub的情况</h2>
<ul>
<li>在程序的运行期间，某个布局在Inflate后，就不会有变化，除非重新启动。因为ViewStub只能Inflate一次，之后会被置空，所以无法指望后面接着使用ViewStub来控制布局。所以当需要<em>在运行时不止一次的显示和隐藏某个布局</em>，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。</li>
<li>想要控制显示与隐藏的是一个布局文件，而非某个View。因为设置给ViewStub的只能是某个布局文件的Id，所以无法让它来控制某个View。所以，如果想要控制某个View(如Button或TextView)的显示与隐藏，或者想要在运行时不断的显示与隐藏某个布局或View，只能使用View的可见性来控制。</li>
</ul>
<h2><a id="%E4%B8%8B%E9%9D%A2%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>下面来看一个实例</h2>
<p>在这个例子中，要显示二种不同的布局，一个是用TextView显示一段文字，另一个则是用ImageView显示一个图片。这二个是在onCreate()时决定是显示哪一个，这里就是应用ViewStub的最佳地点。</p>
<p>先来看看布局，一个是主布局，里面只定义二个ViewStub，一个用来控制TextView一个用来控制ImageView，另外就是一个是为显示文字的做的TextView布局，一个是为ImageView而做的布局：</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;fill_parent&quot;  
  android:layout_height=&quot;fill_parent&quot;  
  android:gravity=&quot;center_horizontal&quot;&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_text&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout_marginTop=&quot;10dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_text_layout&quot;/&gt;  
  &lt;ViewStub   
    android:id=&quot;@+id/viewstub_demo_image&quot;  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:layout_marginLeft=&quot;5dip&quot;  
    android:layout_marginRight=&quot;5dip&quot;  
    android:layout=&quot;@layout/viewstub_demo_image_layout&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>
<p>为TextView的布局：</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;TextView  
        android:id=&quot;@+id/viewstub_demo_textview&quot;  
        android:layout_width=&quot;fill_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:background=&quot;#aa664411&quot;  
        android:textSize=&quot;16sp&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>
<p>为ImageView的布局：</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;LinearLayout  
  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
  android:orientation=&quot;vertical&quot;  
  android:layout_width=&quot;wrap_content&quot;  
  android:layout_height=&quot;wrap_content&quot;&gt;  
    &lt;ImageView  
        android:id=&quot;@+id/viewstub_demo_imageview&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot;/&gt;  
&lt;/LinearLayout&gt;
</code></pre>
<p>下面来看代码，决定来显示哪一个，只需要找到相应的ViewStub然后调用其infalte()就可以获得相应想要的布局：</p>
<pre class="line-numbers"><code class="language-java">public class ViewStubDemoActivity extends Activity {  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.viewstub_demo_activity);  
        if ((((int) (Math.random() * 100)) &amp; 0x01) == 0) {  
            // to show text  
            // all you have to do is inflate the ViewStub for textview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_text);  
            stub.inflate();  
            TextView text = (TextView) findViewById(R.id.viewstub_demo_textview);  
            text.setText(&quot;The tree of liberty must be refreshed from time to time&quot; +  
                    &quot; with the blood of patroits and tyrants! Freedom is nothing but &quot; +  
                    &quot;a chance to be better!&quot;);  
        } else {  
            // to show image  
            // all you have to do is inflate the ViewStub for imageview  
            ViewStub stub = (ViewStub) findViewById(R.id.viewstub_demo_image);  
            stub.inflate();  
            ImageView image = (ImageView) findViewById(R.id.viewstub_demo_imageview);  
            image.setImageResource(R.drawable.happy_running_dog);  
        }  
    }  
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870386.html">
                
                  <h1>Android-DataBinding详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>谷歌开发了一个非常厉害的新框架DataBinding， 数据绑定框架给我们带来了很大的方便，以前我们可能需要在每个Activity里写很多的findViewById，不仅麻烦，还增加了代码的耦合性，如果我们使用DataBinding，就可以抛弃那么多的findViewById，省时省力。说到这里，其实网上也有很多快速的注解框架，但是注解框架与DataBinding想比还是不好用，而且官网文档说DataBinding还能提高解析XML的速度，其实DataBinding的好用，不仅仅体现在可以省去使用很多啰嗦findViewById，还有很多。往下看你就会明白的。</p>
<p>在介绍DataBinding之前，肯定要先学会搭建使用它的环境。在Android Studio上Databinding的使用还是很简单的。</p>
<h2><a id="%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>环境搭建</h2>
<p>Android 的 Gradle 插件版本不低于 1.5.0-alpha1：classpath 'com.android.tools.build:gradle:1.5.0'然后修改对应模块（Module）的 build.grade：</p>
<pre class="line-numbers"><code class="language-java">android {
    ....
    dataBinding {
        enabled = true
    }
}
</code></pre>
<p>注意：Android stuido 的版本一定要大于1.3，而且Android Studio目前对binding对象没有自动代码提示，只会在编译时进行检查。<br />
就是这么简单，但是1.3及以前的版本，对于环境的搭建，可能就会麻烦一点（没事1.3的环境搭建方法，网上多得是）。</p>
<h2><a id="%E5%9F%BA%E7%A1%80%E5%B1%95%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础展示</h2>
<p>我们在具体的讲解之前，先用一个简单的小例子来学习一下基础并展现一下DataBinding的巨大魅力，估计你会被其简单的特性所吸引哦。<br />
首先我们先建立一个java bean，就是一个非常简单的用户类吧。</p>
<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding.bean;
/**
 * Created by loongggdroid on 2016/3/14.
 */
public class User {
    private String name;
    private String age;
    public User(String name, String age) {
        this.name = name;
        this.age = age;
    }
    public void setName(String name) {
        this.name = name;
    }
    public void setAge(String age) {
        this.age = age;
    }
    public String getName() {
        return this.name;
    }
    public String getAge() {
        return this.age;
    }
}
</code></pre>
<p>其次，来看看使用了DataBinding之后的布局文件是什么样子的呢？主要的变化是在layout布局文件之中。</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.name}&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{user.age}&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p>看到这里，可能有的人就开始有点迷糊了，没有给控件定义id，而是用了@{ }的方法，到底是怎么回事？先不忙，一会再给你解释，我们再来看看怎么把值传进去的，在Activity中是如何使用的。</p>
<pre class="line-numbers"><code class="language-java">package loonggg.net.databinding;

import android.app.Activity;
import android.databinding.DataBindingUtil;
import android.os.Bundle;

import loonggg.net.databinding.bean.User;
import loonggg.net.databinding.databinding.ActivityMainBinding;

public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
        User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
        binding.setUser(user);
    }

}
</code></pre>
<p>看到Activity是不是感觉很简洁，很清爽，没有了控件的初始化findViewById，然后再去setText(), 就仅仅只添加了两行代码。运行结果，不用说，显而易见，肯定会显示loonggg和23。</p>
<h2><a id="%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基础用法</h2>
<h3><a id="%E5%B8%83%E5%B1%80%E7%94%9F%E5%91%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>布局生命</h3>
<p>例子我们介绍完了，对于例子中出现的一些新东西，有必要解释一下，java bean那里就不解释了，大家肯定都懂，我们就从布局文件讲起。相比以前使用的xml，根节点由具体的某个layout（比如LinearLayout ）变成了layout，里面包括了data节点和传统的视图。这里的data节点就像是连接 View 和 Modle 的桥梁。在这个data节点中声明一个variable变量，那值就可以轻松传到布局文件中来了。</p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

&lt;!--type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user--&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;user&quot;
            type=&quot;loonggg.net.databinding.bean.User&quot; /&gt;
    &lt;/data&gt; 
    &lt;LinearLayout&gt;
     ……
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p>变量名为user变量类型为&quot;loonggg.net.databinding.bean.User &quot;</p>
<p>type中声明的就是我们的用户实体类User，一定要写全，带着包名，我们给这个实体类命名为user，TextView中的@{user.name}就是把这个user中的名字展示出来，age同样如此。</p>
<h3><a id="%E7%BB%91%E5%AE%9Avariable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>绑定Variable</h3>
<p>虽然在布局文件中对应上了，但是值是怎么传进去的呢？这就是我们要将的Activity中的那两行代码了，它把实体类和布局文件进行了绑定。修改MainActivity中的onCreate，用 DatabindingUtil.setContentView() 来替换掉 setContentView()，然后创建一个 user 对象，通过 binding.setUser(user) 与 variable 进行绑定。</p>
<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    User user = new User(&quot;loonggg&quot;, &quot;23&quot;);
    binding.setUser(user);
}
</code></pre>
<p>ActivityLayoutDetailBinding这个类是自动生成的和你的布局文件名字一样，如果你想要去改变名字的话</p>
<pre class="line-numbers"><code class="language-xml">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;  
  
    &lt;!--这里你也可以为Binding类进行命名，有三种形式  
        1、Custom:会在databinding包下  
        2、.Custom:会在当前的包名下创建  
        3、com.andly.Custom:会在指定的包名下进行创建--&gt;  
    &lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt; //在app_package/databinding下生成CustomBinding；
    &lt;data class=&quot;.CustomBinding&quot;&gt;&lt;/data&gt; //在app_package下生成CustomBinding；
    &lt;data class=&quot;com.example.CustomBinding&quot;&gt;&lt;/data&gt; // 明确指定包名和类名。
</code></pre>
<h2><a id="%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>高级用法</h2>
<h3><a id="import%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>import用法</h3>
<p>其实data节点也是支持import用法的，比如：</p>
<pre class="line-numbers"><code class="language-java">&lt;data&gt;
     &lt;import type=&quot;loonggg.net.databinding.bean.User &quot;/&gt;
     &lt;variablename=&quot;user&quot;type=&quot;User&quot; /&gt;
&lt;/data&gt;
</code></pre>
<p>这里需要注意的是：<code>import</code>并不能像java 一样可以 <code>import xx.xxx.*</code>，必须具体到写清楚每个要导入的类名。</p>
<h3><a id="%E7%B1%BB%E5%90%8D%E7%9B%B8%E5%90%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类名相同</h3>
<p>到这里你可能会问如果import了两个相同名称的类咋办？别怕，人家想的很周到，可以起个别名或者昵称嘛！例如：</p>
<pre class="line-numbers"><code class="language-java">···
&lt;data&gt; 
  &lt;import type=&quot;xxx.User&quot; alias=&quot;MyUser&quot;&gt; 
  &lt;import type=&quot;xxx.xx.User&quot;&gt; 

   &lt;variable 
            name=&quot;user&quot; 
            type=&quot;User&quot; /&gt; 
    &lt;variable 
            name=&quot;myUser&quot; 
            type=&quot;MyUser&quot;/&gt; 
&lt;/data&gt; 
&lt;TextView xxx:@{myUser.getName()}&gt; 
&lt;TextView xxx:@{user.getName()}&gt;
···
</code></pre>
<h3><a id="%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变量定义的高级用法</h3>
<p>在上面，我们学会了如何去在xml中定义一些简单的变量。我们没有定义像List、Map等这样的集合变量。那这种集合变量该如何定义呢？其实定义的方式和我们上面的基本一致，区别就在于我们还需要为它定义key的变量，例如：</p>
<pre class="line-numbers"><code class="language-xml">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; 
    &lt;data&gt; 
        &lt;import type=&quot;android.graphics.Bitmap&quot; /&gt; 
        &lt;import type=&quot;java.util.ArrayList&quot; /&gt; 
        &lt;import type=&quot;java.util.HashMap&quot; /&gt;  
        &lt;!-- 集合的定义 --&gt;
        &lt;variable 
            name=&quot;list&quot; 
            type=&quot;ArrayList&amp;lt;String&gt;&quot; /&gt; // 左尖括号需要转义
        &lt;variable 
            name=&quot;map&quot; 
            type=&quot;HashMap&amp;lt;String, String&gt;&quot; /&gt; 
        &lt;variable 
            name=&quot;array&quot; 
            type=&quot;String[]&quot; /&gt; 
        &lt;!-- 为集合定义对应的索引 --&gt;
        &lt;variable 
            name=&quot;listKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;variable 
            name=&quot;mapKey&quot; 
            type=&quot;String&quot; /&gt; 
        &lt;variable 
            name=&quot;arrayKey&quot; 
            type=&quot;int&quot; /&gt; 
        &lt;!-- 字符串，布尔值和int的用法--&gt;
        &lt;variable 
            name=&quot;str&quot; 
            type=&quot;String&quot;/&gt; 
        &lt;variable 
            name=&quot;error&quot; 
            type=&quot;boolean&quot;/&gt; 
        &lt;variable 
            name=&quot;num&quot; 
            type=&quot;int&quot; /&gt; 
    &lt;/data&gt; 
    &lt;LinearLayout 
        android:orientation=&quot;vertical&quot; 
        android:layout_width=&quot;match_parent&quot; 
        android:layout_height=&quot;wrap_content&quot;&gt; 

        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{list[listKey]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{map[`name`]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{array[0]}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{str}&quot;/&gt; 
        &lt;TextView 
            android:layout_width=&quot;wrap_content&quot; 
            android:layout_height=&quot;wrap_content&quot; 
            android:text=&quot;@{String.valueOf(num)}&quot;/&gt; 
    &lt;/LinearLayout&gt; 
&lt;/layout&gt;
</code></pre>
<p>在引用的同时也可以加上简单的逻辑运算</p>
<pre class="line-numbers"><code class="language-xml">&lt;!--数据绑定将自动检测null异常，如果你的表达式为null，它将会给它赋值为(null)  
 如果为int类型则默认为0--&gt;  
 &lt;!--之前都是写三元运算符的形式，当然在数据绑定中也能够使用，但更推荐下面那种--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{boo?note:null}&quot; /&gt;  
 &lt;!--?? :null合并运算符，当左边为null会显示右边--&gt;  
 &lt;TextView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:text=&quot;@{note??null}&quot;  
     android:textColor=&quot;#00FF00&quot;  
     android:textSize=&quot;18sp&quot; /&gt;  
</code></pre>
<pre class="line-numbers"><code class="language-xml">&lt;!--引用资源文件--&gt;  
&lt;ImageView  
    android:layout_width=&quot;wrap_content&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:paddingLeft=&quot;@{boo?@dimen/large_padding:@dimen/small_padding}&quot;  
    android:src=&quot;@{image}&quot; /&gt; 
</code></pre>
<pre class="line-numbers"><code class="language-xml">&lt;TextView  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text='@{String.valueOf(map[`one`])}'/&gt;  
</code></pre>
<h3><a id="observable%E6%95%B0%E6%8D%AE%E6%94%B9%E5%8F%98%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Observable数据改变自动更新</h3>
<p><code>Observable</code>是一个接口，它的子类有<code>BaseObservable</code>,<code>ObservableField</code>,<code>ObservableBoolean</code>,<code>ObservableByte</code>, <code>ObservableChar</code>, <code>ObservableShort</code>, <code>ObservableInt</code>, <code>ObservableLong</code>, <code>ObservableFloat</code>, <code>ObservableDouble</code>, and <code>ObservableParcelable</code>，<code>ObservableArrayList</code>,<code>ObservableArrayMap</code><br />
现在我们来看看 如何在数据改变时，不手动设置，让其自动改变：</p>
<p><strong>布局文件</strong></p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Person&quot; /&gt;
        &lt;variable
            name=&quot;person&quot;
            type=&quot;Person&quot; /&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`firstName:`+person.firstName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`lastName:`+person.lastName}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{`age:`+person.age}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/second_btn1&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;改变数据&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>Person类</strong></p>
<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding.model;

import android.databinding.BaseObservable;
import android.databinding.Bindable;

import www.zhang.com.databinding.BR;

public class Person extends BaseObservable {
    private String firstName;
    private String lastName;
    private int age;
    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    @Bindable
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
        notifyPropertyChanged(BR.firstName);
    }
    @Bindable
    public String getLastName() {
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
        notifyPropertyChanged(BR.lastName);
    }
    @Bindable
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
        notifyPropertyChanged(BR.age);
    }
}
</code></pre>
<p>Model类继承BaseObservable,BaseObservable实现 Android.databinding.Observable接口，Observable接口可以允许附加一个监听器到model对象以便监听对象上的所有属性的变化。<br />
Observable接口有一个机制来添加和删除监听器，但通知与否由开发人员管理。为了使开发更容易，BaseObservable实现了监听器注册机制。DataBinding实现类依然负责通知当属性改变时。这是通过指定一个Bindable注解给getter以及setter内通知来完成的。<br />
notifyPropertyChanged(BR.参数名)通知更新这一个参数，需要与@Bindable注解配合使用。notifyChange()通知更新所有参数，可以不用和@Bindable注解配合使用</p>
<p><strong>SecondActivity</strong></p>
<pre class="line-numbers"><code class="language-java">public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivitySecondBinding binding = DataBindingUtil.setContentView(SecondActivity.this, R.layout.activity_second);

        final Person person = new Person(&quot;zhang&quot;,&quot;san&quot;,38);
        binding.setPerson(person);

        binding.secondBtn1.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                person.setFirstName(&quot;li&quot;);
                person.setLastName(&quot;si&quot;);
                person.setAge(40);
            }
        });
    }
}
</code></pre>
<h4><a id="%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例</h4>
<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Animal&quot;/&gt;
        &lt;variable
            name=&quot;animal&quot;
            type=&quot;Animal&quot;/&gt;
        &lt;variable
            name=&quot;list&quot;
            type=&quot;android.databinding.ObservableArrayList&amp;lt;String&amp;gt;&quot;/&gt;
        &lt;variable
            name=&quot;map&quot;
            type=&quot;android.databinding.ObservableArrayMap&amp;lt;String,String&amp;gt;&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{animal.field}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{String.valueOf(animal.age)}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[0]}&quot; /&gt;
        &lt;!--Map集合既可以通过map[key]的方式，也可以通过调用API--&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{list[1]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`name`]}&quot; /&gt;
        &lt;TextView
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;56dp&quot;
            android:text=&quot;@{map[`age`]}&quot; /&gt;
        &lt;Button
            android:id=&quot;@+id/four_btn&quot;
            android:layout_width=&quot;match_parent&quot;
            android:text=&quot;改变数据&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>Animal类</strong></p>
<pre class="line-numbers"><code class="language-java">public class Animal {
    public final ObservableField&lt;String&gt; field = new ObservableField&lt;&gt;();
    public final ObservableInt age = new ObservableInt();
}
</code></pre>
<p><strong>FourActivity</strong></p>
<pre class="line-numbers"><code class="language-java">package www.zhang.com.databinding;

public class FourActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityFourBinding binding = DataBindingUtil.setContentView(FourActivity.this, R.layout.activity_four);
        final Animal animal = new Animal();

        animal.field.set(&quot;cat&quot;);
        animal.age.set(2);
        binding.setAnimal(animal);

        final ObservableArrayList&lt;String&gt; list = new ObservableArrayList&lt;&gt;();
        list.add(&quot;dog&quot;);
        list.add(&quot;mouse&quot;);
        binding.setList(list);

        final ObservableArrayMap&lt;String, String&gt; map = new ObservableArrayMap&lt;&gt;();
        map.put(&quot;name&quot;,&quot;Tom&quot;);
        map.put(&quot;age&quot;,&quot;4&quot;);
        binding.setMap(map);

        binding.fourBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                animal.field.set(&quot;dog&quot;);
                animal.age.set(4);
                list.set(0,&quot;cat&quot;);
                list.set(1,&quot;dog&quot;);
                map.put(&quot;name&quot;,&quot;Sam&quot;);
                map.put(&quot;age&quot;,&quot;5&quot;);
            }
        });

    }
}
</code></pre>
<p>当Animal属性数据改变，list/map集合数据改变，会自动更新数据，我们不需要自己手动设置，省去了一个操作，让我们更专注于业务逻辑。</p>
<h3><a id="%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%91%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>事件的绑定</h3>
<pre class="line-numbers"><code class="language-xml">&lt;!--  
    绑定事件的格式有两种：    
    1、方法引用：直接用handle.Click或者handle::Click  推荐后者  
--&gt;  
&lt;Button  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot;  
    android:text=&quot;@{user.name}&quot;  
    android:onClick=&quot;@{handle::Click}&quot;/&gt;  
</code></pre>
<pre class="line-numbers"><code class="language-xml">&lt;!--  
     2、监听绑定：使用()组，括号里面所填的是你为参数起的名字，这样你就可以在后面的括号进行引用  
        如果你监听的事件需要返回值，那么你的方法也要返回一个相同类型  
 --&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{()-&gt;handle.eventHandler(user)}&quot;  
     android:text=&quot;传入布局文件中的数据&quot; /&gt;  
  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(thisView)-&gt;handle.eventHandlerView(thisView,user)}&quot;  
     android:text=&quot;传入此View&quot; /&gt;  
 &lt;!--如果你需要为一个点击事件设置一个断言，那么使用void作为一个标志,表示什么也不做--&gt;  
 &lt;Button  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.isVisible(v)?handle.doSomething():void}&quot;  
     android:text=&quot;判断是否为visible&quot; /&gt;  
  
 &lt;!--对于一些控件有自己专门的单击事件，需要创建下面的属性进行避免  
    SearchView    android:onSearchClick  
    ZoomControls  android:onZoomIn  
    ZoomControls  android:onZoomOut--&gt;  
 &lt;SearchView  
     android:layout_width=&quot;match_parent&quot;  
     android:layout_height=&quot;wrap_content&quot;  
     android:onClick=&quot;@{(v)-&gt;handle.searchClick(v)}&quot;  
     android:onSearchClick=&quot;@{(v)-&gt;handle.onSearchClick(v)}&quot;&gt;  
  
 &lt;/SearchView&gt;  
</code></pre>
<p>实现监听方法，保证参数个数、类型、返回值都要保证和你使用set时监听一样，不然就出报错。</p>
<pre class="line-numbers"><code class="language-java">public void checkChanged(View view, boolean isCheck) {  
    System.out.println(&quot;checkChanged:&quot; + view + &quot;    &quot; + isCheck);  
}  
  
public boolean longClick(View view) {  
    System.out.println(&quot;longClick:&quot; + view);  
    return true;  
}  
</code></pre>
<p>可以直接在 xml 导入android.view.View.OnClickListener，并制定其点击事件。</p>
<pre class="line-numbers"><code class="language-java">&lt;variable
    name=&quot;clickListener&quot;
    type=&quot;android.view.View.OnClickListener&quot; /&gt;
...
  android:onClick=&quot;@{clickListener}&quot;
...
</code></pre>
<pre class="line-numbers"><code class="language-java">holder.binding.setClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
               //do something
        });
</code></pre>
<h3><a id="%E8%A1%A8%E8%BE%BE%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>表达式</h3>
<p>其实在xml文件中还是支持表达式的，比如说如下：</p>
<pre class="line-numbers"><code class="language-xml">&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text='@{error ? &quot;error&quot; : &quot;ok&quot;}'/&gt;
</code></pre>
<p>这是一个布尔值的使用。</p>
<p><strong>下面我们就来看看表达式支持的一下语法和不支持的语法支持的表达式：</strong></p>
<ul>
<li>Mathematical + - / * %</li>
<li>String concatenation +</li>
<li>Logical &amp;&amp; ||</li>
<li>Binary &amp; | ^</li>
<li>Unary + - ! ~</li>
<li>Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>
<li>Comparison == &gt; &lt; &gt;= &lt;=</li>
<li>instanceof</li>
<li>Grouping ()</li>
<li>Literals - character, String, numeric, null</li>
<li>Cast</li>
<li>Method calls</li>
<li>Field access</li>
<li>Array access []</li>
<li>Ternary operator ?:</li>
</ul>
<p><strong>不支持的表达式：</strong></p>
<ul>
<li>this</li>
<li>super</li>
<li>new</li>
<li>Explicit generic invocation</li>
</ul>
<h3><a id="%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E4%BD%BF%E7%94%A8include" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在布局中使用include</h3>
<p>如果你需要用到从xml传过来的数据需要去使用bind:user属性，这里的user是你定义的实体类名</p>
<pre class="line-numbers"><code class="language-xml">&lt;!--当你使用include的时候，你可以使用命名空间和属性中的变量名  
来将数据传送到另一个布局中去,值得注意的是当include的父节点为merge时将不支持--&gt;  
&lt;include  
    layout=&quot;@layout/detail_include&quot;  
    bind:user=&quot;@{user}&quot; /&gt; 
</code></pre>
<p>然后只需要在include布局里面声明之后便可以直接使用了。</p>
<h4><a id="%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例</h4>
<p><strong>activity_five.xml</strong></p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
 &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;TextView
                android:text=&quot;@string/app_name&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>toolbar.xml</strong></p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout &gt;
    &lt;data&gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
      &lt;variable
          name=&quot;content&quot;
          type=&quot;Content&quot;/&gt;
    &lt;/data&gt;

&lt;android.support.v7.widget.Toolbar
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/toolbar&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_height=&quot;56dp&quot;
    android:layout_width=&quot;match_parent&quot;
    app:title=&quot;@{content.title}&quot;
    app:subtitle=&quot;@{content.subTitle}&quot;
    android:background=&quot;@color/colorPrimary&quot;
    app:titleTextColor=&quot;@android:color/white&quot;
    app:subtitleTextColor=&quot;@android:color/white&quot; /&gt;
&lt;/layout&gt;
</code></pre>
<p>在activity_five.xml中的include属性中定义了一个id,同时又在toolbar.xml中的Toolbar标签中又定义了一个id,其作用是通过binding.toolbar.toolbar等同于Toolbar控件，可以方便做一些操作等(不加id，同样能将变量参数传进去)<br />
FiveActivity中</p>
<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        ActivityFiveBinding binding =DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;); 
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>
<p><strong>Content</strong></p>
<pre class="line-numbers"><code class="language-java">public class Content extends BaseObservable {
    private String title;
    private String subTitle;

    public Content(String title, String subTitle) {
        this.title = title;
        this.subTitle = subTitle;
    }

    @Bindable public String getSubTitle() {
        return subTitle;
    }

    public void setSubTitle(String subTitle) {
        this.subTitle = subTitle;
        notifyPropertyChanged(BR.subTitle);
    }

    @Bindable public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
        notifyPropertyChanged(BR.title);
    }
}
</code></pre>
<h3><a id="%E5%B8%A6id%E7%9A%84%E6%8E%A7%E4%BB%B6%E7%9A%84%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>带id的控件的赋值方式</h3>
<p>对于xml文件中控件的赋值，其实也是可以在java文件中，用java来实现的。我就以最上面那个简单的小例子来说，假如给一个TextView设置的id如下：</p>
<pre class="line-numbers"><code class="language-xml">&lt;TextView
    android:id=&quot;@+id/name&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    /&gt;
</code></pre>
<p>在Activity中这样赋值：</p>
<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    binding.name.setText(&quot;非著名程序员&quot;);
}
</code></pre>
<h3><a id="%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E4%BD%BF%E7%94%A8viewstub" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在布局中使用ViewStub</h3>
<pre class="line-numbers"><code class="language-java">/** 
 * 为ViewStub设置监听，当显示的时候为它绑定数据，因为当不显示的ViewStub会在视图中消失 
 */  
vs = (ViewStub) findViewById(R.id.viewstub);  
vs.setOnInflateListener(new ViewStub.OnInflateListener() {  
    @Override  
    public void onInflate(ViewStub stub, View inflated) {  
        ViewstubBinding viewstubBinding = ViewstubBinding.bind(inflated);  
        Info info = new Info();  
        info.setInfo(&quot;Andly Info&quot;);  
        viewstubBinding.setInfo(info);  
        Drawable d = getResources().getDrawable(R.mipmap.ic_launcher);  
        viewstubBinding.setDrawable(d);  
    }  
});  
  
public void toggleViewStub(View view) {  
    vs.inflate();  
}  
</code></pre>
<h3><a id="%E5%9C%A8%E5%B8%83%E5%B1%80%E4%B8%AD%E4%BD%BF%E7%94%A8recycleview%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在布局中使用RecycleView控件</h3>
<h4><a id="1%E3%80%81%E6%B7%BB%E5%8A%A0recycleview%E6%8E%A7%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>1、添加RecycleView控件</h4>
<pre class="line-numbers"><code class="language-xml">&lt;!--  
    这里使用到了自定义属性，因为RecycleView里面有setAdapter方法，所以这里可以直接用app:adapter  
--&gt;  
&lt;android.support.v7.widget.RecyclerView  
    android:id=&quot;@+id/rv&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    app:adapter=&quot;@{adapter}&quot; /&gt;  
</code></pre>
<h4><a id="2%E3%80%81%E4%B8%BArecycleview%E5%AE%9A%E4%B9%89%E9%80%82%E9%85%8D%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>2、为RecycleView定义适配器</h4>
<pre class="line-numbers"><code class="language-java">@Override  
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {  
    ViewDataBinding viewDataBinding = DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()), layoutId, parent, false);  
    return new ViewHolder(viewDataBinding);  
}  
@Override  
public void onBindViewHolder(ViewHolder holder, int position) {  
    holder.binding.setVariable(variable, list.get(position));  
    holder.binding.executePendingBindings();  
    //当然这里你也可以为其设置点击如：  
    //holder.binding.getRoot.setOnclickListener()  
}  
@Override  
public int getItemCount() {  
    return list.size();  
}  
  
class ViewHolder extends RecyclerView.ViewHolder {  
    ViewDataBinding binding;  
  
    public ViewHolder(ViewDataBinding binding) {  
        super(binding.getRoot());  
        this.binding = binding;  
    }  
}  
</code></pre>
<h4><a id="3%E3%80%81%E4%B8%BArecycleview%E8%AE%BE%E7%BD%AEadapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>3、为RecycleView设置Adapter</h4>
<pre class="line-numbers"><code class="language-java">//这里注意的是一定要是BR.dataInfo不能是其它的常数  
MyAdapter adapter = new MyAdapter(list, R.layout.rv_item, BR.dataInfo);  
binding.setAdapter(adapter);  
binding.rv.setLayoutManager(new LinearLayoutManager(this));
</code></pre>
<p>这样就大功告成，然而在很多情况我们都需要去对每个Item进行处理，如显示网络图片等等，这里我们就需要使用数据绑定自定义属性的功能，看代码</p>
<pre class="line-numbers"><code class="language-xml">&lt;ImageView  
    android:layout_width=&quot;150dp&quot;  
    android:layout_height=&quot;90dp&quot;  
    app:imageError=&quot;@{@drawable/android}&quot;  
    app:imagePath=&quot;@{dataInfo.imageUrl}&quot; /&gt;  
</code></pre>
<pre class="line-numbers"><code class="language-java">//当你在一个方法只需要一个参数的时候可以使用@BindingAdapter(&quot;imageUrlStr&quot;)，加上之后就可以在布局文件中直接使用imageUrlStr  
//运行之后就会调用loadImage方法  
@BindingAdapter(&quot;imageUrlStr&quot;)  
public static void loadImage(ImageView iv, String url) {  
    Glide.with(iv.getContext()).load(url).into(iv);//这里使用Glide库  
}  
  
//上面是为loadImage传入一个参数，当传入两个或多个参数的时候应使用@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
//这个的ImageView自定义了两个属性一个是imagePath传入的是url,一个是imageError为Drawable  
@BindingAdapter({&quot;imagePath&quot;, &quot;imageError&quot;})  
public static void downloadImage(ImageView iv, String url, Drawable error) {  
    Glide.with(iv.getContext()).load(url).error(error).into(iv);  
}  
</code></pre>
<p>上面的方法使用的是静态方法，如果你不想使用静态方法你需要重写一个数据绑定组件类去实现DataBindingComponent</p>
<pre class="line-numbers"><code class="language-java">public class MyComponent implements android.databinding.DataBindingComponent {  
    private Utils utils;  
    @Override  
    public Utils getUtils() {  
        if (utils == null) {  
            utils = new Utils();  
        }  
        return utils;  
    }  
}  
</code></pre>
<p>然后你需要在Activity为其进行设置</p>
<pre class="line-numbers"><code class="language-java">//第一种方式  
DataBindingUtil.setDefaultComponent(new MyComponent());  
//第二种方式  
ActivityMyListViewBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_my_list_view,new MyComponent());  
//第三种方式  
DataBindingUtil.bind(root,new MyComponent());  
</code></pre>
<p>最后有个不起眼的小功能，就是当使用数据绑定的时候在预览界面不能看到显示的内容，这时你可以为你的控件设置默认显示内容<code>android:text=&quot;@{placeName,default=PLACEHOLDER}&quot;</code></p>
<h5><a id="%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例</h5>
<p><strong>activity_five.xml</strong></p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!--布局以layout作为根布局--&gt;
&lt;layout&gt;

    &lt;data &gt;
        &lt;import type=&quot;www.zhang.com.databinding.model.Content&quot;/&gt;
        &lt;variable
            name=&quot;con&quot;
            type=&quot;Content&quot;/&gt;
    &lt;/data&gt;
    &lt;!--我们需要展示的布局--&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:orientation=&quot;vertical&quot;&gt;
        &lt;include
            android:id=&quot;@+id/toolbar&quot;
            layout=&quot;@layout/toolbar&quot;
            android:layout_height=&quot;56dp&quot;
            android:layout_width=&quot;match_parent&quot;
            bind:content=&quot;@{con}&quot; /&gt;
        &lt;!--通过命名空间将写有toolbar的xml文件中定义的content对象作为属性绑定con对象，这2个对象是同一个类--&gt;
            &lt;android.support.v7.widget.RecyclerView
                android:id=&quot;@+id/recycler&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>recycler_item.xml</strong></p>
<pre class="line-numbers"><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layout&gt;
    &lt;data&gt;
        &lt;variable
            name=&quot;str&quot;
            type=&quot;String&quot;/&gt;
    &lt;/data&gt;
    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;
        android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;
        android:orientation=&quot;vertical&quot;&gt;

        &lt;TextView
            android:text=&quot;@{str}&quot;
            android:gravity=&quot;center_vertical&quot;
            android:textColor=&quot;@android:color/black&quot;
            android:textSize=&quot;16sp&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;48dp&quot; /&gt;
    &lt;/LinearLayout&gt;
&lt;/layout&gt;
</code></pre>
<p><strong>FiveActivity</strong></p>
<pre class="line-numbers"><code class="language-java">public class FiveActivity extends AppCompatActivity {

    private ActivityFiveBinding binding;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);

        binding = DataBindingUtil.setContentView(FiveActivity.this, R.layout.activity_five);

        initToolbar();
        initRecyclerView();
    }

    private void initRecyclerView() {
        LinearLayoutManager manager = new LinearLayoutManager(FiveActivity.this);
        binding.recycler.setLayoutManager(manager);
        binding.recycler.setHasFixedSize(true);
        MyAdapter adapter = new MyAdapter(getApplicationContext());
        binding.recycler.setAdapter(adapter);
    }

    private void initToolbar() {
        Content con = new Content(&quot;Title&quot;,&quot;SubTitle&quot;);
        binding.setCon(con);

//        binding.toolbar.setContent(con);  //这个测试没有效果，不会显示toolbar的title/subTitle
//        binding.toolbar.toolbar.setTitle(&quot;&quot;);
//        binding.toolbar.toolbar.setSubtitle(&quot;&quot;);

        //下面的代码也可以通过DataBinding绑定数据
        binding.toolbar.toolbar.setNavigationIcon(R.mipmap.ic_launcher);
        setSupportActionBar(binding.toolbar.toolbar);
        binding.toolbar.toolbar.setNavigationOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });
    }
}
</code></pre>
<p><strong>MyAdapter</strong></p>
<pre class="line-numbers"><code class="language-java">public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {

    private Context mContext;
    String[] datas;

    public MyAdapter(Context context) {
        mContext = context;
        datas = context.getResources().getStringArray(R.array.item_list);
    }

    @Override
    public MyAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        RecyclerItemBinding binding = DataBindingUtil.inflate(LayoutInflater.from(mContext), R.layout.recycler_item, parent, false);
        return new MyViewHolder(binding);
    }

    @Override
    public void onBindViewHolder(MyAdapter.MyViewHolder holder, int position) {
        String name = datas[position];
        holder.getBinding().setVariable(www.zhang.com.databinding.BR.str,name);
        //holder.getBinding().setStr(name); //两者都可以

        //executePendingBindings()方法说明
        // When a variable or observable changes, the binding will be scheduled to change before the next frame. 
        // There are times, however, when binding must be executed immediately. 
        // To force execution, use the executePendingBindings() method.
        holder.getBinding().executePendingBindings();//此方法必须执行在UI线程，当绑定的数据修改时更新视图（不知道翻译的准不准）
    }

    @Override
    public int getItemCount() {
        return datas.length;
    }

    public class MyViewHolder extends RecyclerView.ViewHolder {
        private RecyclerItemBinding binding;

        public MyViewHolder(ViewDataBinding binding) {
            super(binding.getRoot());
            this.binding = (RecyclerItemBinding) binding;
        }

        public RecyclerItemBinding getBinding() {
            return binding;
        }

        public void setBinding(RecyclerItemBinding binding) {
            this.binding = binding;
        }
    }
}
</code></pre>
<h3><a id="bindingadapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@BindingAdapter</h3>
<p>@BindingAdapter用于修饰方法。<br />
一些属性需要定制绑定逻辑，一个用@BindingAdapter修饰的静态方法可以自定义属性的setter操作。<br />
android自身实现了大量的Adapter，你可以在项目module的android.databinding.adapters包下找到这些代码。</p>
<pre class="line-numbers"><code class="language-java">public class CardViewBindingAdapter {
    @BindingAdapter(&quot;contentPadding&quot;)
    public static void setContentPadding(CardView view, int padding) {
        view.setContentPadding(padding, padding, padding, padding);
    }
}
</code></pre>
<p><strong>方法内的参数可以设置多个，参数的传递在布局文件中使用自定义命名空间的属性传入。</strong></p>
<ul>
<li>1、默认的你的自定义的命名空间，在匹配时会被忽略。</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text">@BindingAdapter(&quot;contentPadding&quot;)
</code></pre>
<ul>
<li>2、允许重写android的命名空间。</li>
</ul>
<pre class="line-numbers"><code class="language-plain_text"> @BindingAdapter(&quot;android:contentPadding&quot;)
</code></pre>
<p><code>app:contentPadding</code>与<code>android:contentPadding</code>处理行为可以不一样。<br />
<code>app:contentPadding</code>与<code>custom:contentPadding</code>处理行为是一致的。（仅android是特殊的命名空间）。</p>
<h4><a id="%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>示例</h4>
<pre class="line-numbers"><code class="language-java">@BindingAdapter({&quot;imageUrl&quot;, &quot;type&quot;, &quot;position&quot;, &quot;debrisfly&quot;, &quot;width&quot;, &quot;height&quot;})
public static void setImageUrl(SimpleDraweeView view, String url, int type, int position, boolean debrisfly, int width, int height) {
    if (url == null) {
        url = &quot;&quot;;
    }
    Uri uri = null;
    switch (type) {
        case 1:
            uri = Util.parse7(url, BocaiApplication.getInstance());
            break;
        case 2:
            uri = Util.parse2(url, BocaiApplication.getInstance());
            break;
        case 3:
            uri = Util.parse3(url, BocaiApplication.getInstance());
            break;

        case 8:
            uri = Util.parse(url, BocaiApplication.getInstance());
            break;
        case 10:
            uri = Util.parseUrlBy230(url, BocaiApplication.getInstance());
            break;
    }
    ControllerListener controllerListener = new BaseControllerListener&lt;ImageInfo&gt;() {
        @Override
        public void onFinalImageSet(
                String id,
                @Nullable ImageInfo imageInfo,
                @Nullable Animatable anim) {
            if (imageInfo == null) {
                return;
            }
            if (anim != null) {
                anim.start();
            }
        }

        @Override
        public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) {
        }

        @Override
        public void onFailure(String id, Throwable throwable) {
        }
    };

    DraweeController controller = Fresco.newDraweeControllerBuilder()
            .setControllerListener(controllerListener)
            .setUri(uri)
            .setOldController(view.getController())
            // other setters
            .build();
    view.setController(controller);
    debrisflys(debrisfly, position,view,width,height);
}
</code></pre>
<p>需要注意，当你创建的适配器属性与系统默认的产生冲突时，你的自定义适配器将会覆盖掉系统原先定义的注解，这将会产生一些意外的问题。<br />
假设需要对下面接口，做适配。</p>
<pre class="line-numbers"><code class="language-java">public interface ILogAction{
      void login();
      void logout();
}
</code></pre>
<p>则需要一个方法一个接口，这么做的原因是避免<code>login()</code>的修改影响到<code>logout()</code>。所以根据业务需要，可能需要排列组合适配这两个接口。</p>
<blockquote>
<p>1、适配 login<br />
2、适配 logout<br />
3、适配 login + logout</p>
</blockquote>
<h3><a id="bindingbuildinfo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@BindingBuildInfo</h3>
<pre class="line-numbers"><code class="language-java">@BindingBuildInfo(
buildId=&quot;3fefc6ba-1e95-4dcf-8ffa-278fe0f449bd&quot;,
modulePackage=&quot;com.ipudong.library&quot;,
sdkRoot=&quot;/Users/robert/Library/Android/sdk&quot;,
layoutInfoDir=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug&quot;,
exportClassListTo=&quot;/Users/robert/android/develops/pudong-d-android/lib_basic/build/intermediates/data-binding-info/debug/_generated.txt&quot;,
isLibrary=true,
minSdk=14,
enableDebugLogs=false,
printEncodedError=true
)
public class DataBindingInfo {}
</code></pre>
<p>在SOURCE阶段会自动生成DataBindingInfo.class，并标记注解如上。</p>
<h3><a id="bindingconversion" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@BindingConversion</h3>
<blockquote>
<p>Annotate methods that are used to automatically convert from the expression type to the value used in the setter.<br />
有时候会遇到类型不匹配的问题，比如<code>R.color.white</code>是<code>int</code>，但是通过Data Binding赋值给<code>android:background</code>属性后，需要把<code>int</code>转换为<code>ColorDrawable</code>。</p>
</blockquote>
<pre class="line-numbers"><code class="language-java">@BindingConversion
public static Drawable convertColorToDrawable(int drawable) {
  return new ColorDrawable(drawable);
}
</code></pre>
<h3><a id="bindingmethod-bindingmethods" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@BindingMethod &amp;&amp; @BindingMethods</h3>
<blockquote>
<p>Used within an BindingMethods annotation to describe a renaming of an attribute to the setter used to set that attribute.Used to enumerate attribute-to-setter renaming.</p>
</blockquote>
<p><strong>@BindingMethods用于修饰类。</strong></p>
<p>一些属性虽然拥有setters但是并不与名字相匹配，这些方法的属性可以通过 @BindingMethod &amp;&amp; @BindingMethods 注释 setters。</p>
<pre class="line-numbers"><code class="language-java">@BindingMethods({
       @BindingMethod(type = &quot;android.widget.ImageView&quot;,
                      attribute = &quot;android:tint&quot;,
                      method = &quot;setImageTintList&quot;),
})
</code></pre>
<p>开发人员不太可能需要重命名 setters ，因为android框架属性已经实现了这一部分。<br />
事件的默认值是带有<code>AttrChanged</code>的属性名称。在上面的例子中，默认值是<code>android:textAttrChanged</code>，即使它没有提供。<br />
事件属性用于通知数据绑定系统值已更改。开发人员通常会创建一个<code>BindingAdapter</code>来分配事件。比如：</p>
<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>
<p>如同<code>BindingAdapters</code>一样， <code>InverseBindingAdapter</code>方法 也可以将 <code>DataBindingComponent</code>作为第一个参数，可以是具有从<code>DataBindingComponent</code>检索的实例的实例方法。<br />
<code>InverseBindingListener</code>非常有用。</p>
<p><a href="https://developer.android.com/reference/android/databinding/InverseBindingListener.html">参考 InverseBindingListener</a></p>
<h3><a id="inversebindingmethod" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@InverseBindingMethod</h3>
<p><code>InverseBindingMethod</code>用于标识如何监听对<code>View</code>属性的更改以及要调用的<code>getter</code>方法。<code> InverseBindingMethod</code> 应该与<code>InverseBindingMethods</code>的部分方法相关联。</p>
<pre class="line-numbers"><code class="language-java">@InverseBindingMethods({@InverseBindingMethod(
     type = android.widget.TextView.class,
     attribute = &quot;android:text&quot;,
     event = &quot;android:textAttrChanged&quot;,
     method = &quot;getText&quot;)})
 public class MyTextViewBindingAdapters { ... }
</code></pre>
<p>@InverseBindingMethods中的属性method 是可选的。</p>
<blockquote>
<p>如果其没有提供， 属性名称会查找如下几种可能性：方法名称，前缀为is或者get的方法名称。 如属性android:text, 数据绑定框架会在TextView中搜索public CharSequence getText() 方法。</p>
</blockquote>
<p>@InverseBindingMethods中的属性event是可选的。</p>
<blockquote>
<p>如果其没有提供，默认会使用属性名+AttrChanged后缀。如属性android:text, 默认的事件名称android:textAttrChanged。</p>
</blockquote>
<p>这个事件也需要配置相关的<code>@BindingAdapter</code>，如下：</p>
<pre class="line-numbers"><code class="language-java">@BindingAdapter(value = {&quot;android:beforeTextChanged&quot;, &quot;android:onTextChanged&quot;,
                          &quot;android:afterTextChanged&quot;, &quot;android:textAttrChanged&quot;},
                          requireAll = false)
 public static void setTextWatcher(TextView view, final BeforeTextChanged before,
                                   final OnTextChanged on, final AfterTextChanged after,
                                   final InverseBindingListener textAttrChanged) {
     TextWatcher newValue = new TextWatcher() {
         ...
         @Override
         public void onTextChanged(CharSequence s, int start, int before, int count) {
             if (on != null) {
                 on.onTextChanged(s, start, before, count);
             }
             if (textAttrChanged != null) {
                 textAttrChanged.onChange();
             }
         }
     }
     TextWatcher oldValue = ListenerUtil.trackListener(view, newValue, R.id.textWatcher);
     if (oldValue != null) {
         view.removeTextChangedListener(oldValue);
     }
     view.addTextChangedListener(newValue);
 }
</code></pre>
<h3><a id="inversebindingmethods" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@InverseBindingMethods</h3>
<blockquote>
<p>用于枚举属性，<code>getter</code>和事件关联。</p>
</blockquote>
<h3><a id="untaggable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@Untaggable</h3>
<p>Data Binding相关的jar包由四部分组成，</p>
<ol>
<li>baseLibrary-2.1.0-rc1.jar<br />
作为运行时类库被打进APK中；</li>
<li>DataBinderPlugin（gradle plugin）<br />
在编译期使用，利用gradle-api（之前叫transform-api，1.5生，2.0改名）处理xml文件，生成DataBindingInfo.java；</li>
<li>compiler-2.1.0-rc1.jar<br />
在编译器使用，入口类继承自AbstractProcessor，用于处理注解，并生成Binding类，DataBindingCompoent.java，DataBinderMapper.java类；</li>
<li>compilerCommon-2.1.0-rc1.jar<br />
被DataBinderPlugin和compiler-2.1.0-rc1.jar所依赖</li>
</ol>
<h3><a id="%E6%94%B9%E5%8F%98%E7%9B%91%E5%90%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>改变监听</h3>
<p><code>addOnPropertyChangedCallback： Model</code>属性改变时回调发生 <br />
<code>OnRebindCallback: view</code>发生改变重复绑定时触发</p>
<pre class="line-numbers"><code class="language-java">mModel.addOnPropertyChangedCallback(new Observable.OnPropertyChangedCallback() {
    @Override
    public void onPropertyChanged(Observable observable, int i) {
        if (i == BR.name) {
            Toast.makeText(TwoWayActivity.this, &quot;name changed&quot;,
                    Toast.LENGTH_SHORT).show();
        } else if (i == BR.password) {
            Toast.makeText(TwoWayActivity.this, &quot;password changed&quot;,
                    Toast.LENGTH_SHORT).show();
        }
    }
});
</code></pre>
<h3><a id="component" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Component</h3>
<p>通过<code>DataBindingUtil.setDefaultComponent</code>来设置不同环境下不同的<code>Component</code>，<br />
设置之后就可以使用该<code>Component</code>提供的<code>Adapter</code>方法，默认不设置是全局使用，可以理解为作用域。</p>
<pre class="line-numbers"><code class="language-java">public interface TestableAdapter {
    @BindingAdapter(&quot;android:src&quot;)
    void setImageUrl(ImageView imageView, String url);
}

public interface DataBindingComponent {
    TestableAdapter getTestableAdapter();
}

DataBindingUtil.setDefaultComponent(myComponent); 
 ‐ or ‐
binding = MyLayoutBinding.inflate(layoutInflater, myComponent);
</code></pre>
<h2><a id="%E7%9B%B8%E5%85%B3%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关编译流程</h2>
<h3><a id="step1%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>STEP1 资源处理</h3>
<p><code>aapt</code>或者<code>gradle</code>执行时，都会触发资源处理。在资源处理过程中，<code>DataBinding</code>都会扫描一遍现有的资源，生成不包含<code>&lt;layout&gt;</code>的<code>data-binding-layout-out</code>以及<code>DataBinding</code>所需要的<code>data-binding-info</code>；</p>
<h3><a id="step2-databindinginfo-class%E7%94%9F%E6%88%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>STEP2 DataBindingInfo.class生成</h3>
<p>在完成资源处理后，<code>aapt</code>或者<code>gradle-api</code>都会去执行<code>DataBindingInfo.class</code>生成操作，把相关的信息写入<code>DataBindingInfo.class</code>的@BindingBuildInfo注解中；</p>
<h3><a id="step3%E7%9B%91%E5%90%AC%E5%88%B0%E6%B3%A8%E8%A7%A3%E5%8F%98%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>STEP3 监听到注解变化</h3>
<p>生成<code>@BindingBuildInfo</code>注解，或者code中发现有新的注解写入，<code>AbstractProcessor</code>注解处理器就开始执行注解处理。<code>DataBinding</code>中有一个<code>ProcessDataBinding.jav</code>a类专门来处理<code>DataBinding</code>相关的注解；</p>
<h3><a id="step4-processdatabinding%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%94%9F%E6%88%90bin" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>STEP4 ProcessDataBinding处理注解，生成bin</h3>
<p><code>ProcessDataBinding</code>中处理注解永远会按顺执行3步，<code>ProcessMethodAdapter</code>，<code>ProcessExpressions</code>，<code>ProcessBindable</code>。每次执行都会从磁盘反序列化对应的bin文件，然后往bin中写入新的，完成后再序列化到磁盘；</p>
<h3><a id="step5%E7%94%9F%E6%88%90%E6%9C%80%E7%BB%88%E4%BA%A7%E7%89%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>STEP5 生成最终产物</h3>
<p>执行<code>ProcessMethodAdapter</code>生成<code>DataBindingComponents.class</code>；执行<code>ProcessExpressions</code>生成<code>ViewDataBinding.class</code>子类（ActivityDetail2Binding.class），并触发<code>DataBindingMapper.class</code>更新；执行<code>ProcessBindable</code>生成<code>BR.class</code>，并触发<code>DataBindingMapper.class</code>更新。</p>
<h2><a id="%E6%B3%A8%E6%84%8F%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注意：</h2>
<p>不允许使用混合类型</p>
<pre class="line-numbers"><code class="language-java">&lt;!--值得注意的是  
    android:background=&quot;@{boo?@color/red:@drawable/background}&quot;  
    这么写将会发生错误，因为在BindingConversion默认实现为：  
    @BindingConversion  
    public static ColorDrawable convertColorToDrawable(int color) {  
            return new ColorDrawable(color);  
        }  
--&gt;  
&lt;ImageView  
    android:layout_width=&quot;100dp&quot;  
    android:layout_height=&quot;100dp&quot;  
    android:layout_marginTop=&quot;20dp&quot;  
    android:background=&quot;@{boo?@color/red:@color/green}&quot; /&gt;  
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/08</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870279.html">
                
                  <h1>Android-getViewTreeObserver()</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>我们知道在<code>oncreate</code>中<code>View.getWidth</code>和<code>View.getHeight</code>无法获得一个view的高度和宽度，这是因为View组件布局要在<code>onResume</code>回调后完成。所以现在需要使用<code>getViewTreeObserver().addOnGlobalLayoutListener()</code>来获得宽度或者高度。这是获得一个view的宽度和高度的方法之一。</p>
<h2><a id="ongloballayoutlistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>OnGlobalLayoutListener</h2>
<p><code>OnGlobalLayoutListener</code> 是<code>ViewTreeObserver</code>的内部类，当一个视图树的布局发生改变时，可以被<code>ViewTreeObserver</code>监听到，这是一个注册监听视图树的观察者(observer)，在视图树的全局事件改变时得到通知。<code>ViewTreeObserver</code>不能直接实例化，而是通过<code>getViewTreeObserver()</code>获得。</p>
<h2><a id="%E5%85%B6%E4%BB%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其他</h2>
<p>除了<code>OnGlobalLayoutListener</code> ，<code>ViewTreeObserver</code>还有如下内部类：</p>
<h3><a id="interface%C2%A0-viewtreeobserver-onglobalfocuschangelistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>interface <code>ViewTreeObserver.OnGlobalFocusChangeListener</code></h3>
<p>当在一个视图树中的焦点状态发生改变时，所要调用的回调函数的接口类</p>
<h3><a id="interface%C2%A0-viewtreeobserver-ongloballayoutlistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>interface <code>ViewTreeObserver.OnGlobalLayoutListener</code></h3>
<p>当在一个视图树中全局布局发生改变或者视图树中的某个视图的可视状态发生改变时，所要调用的回调函数的接口类</p>
<h3><a id="interface%C2%A0-viewtreeobserver-onpredrawlistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>interface <code>ViewTreeObserver.OnPreDrawListener</code></h3>
<p>当一个视图树将要绘制时，所要调用的回调函数的接口类</p>
<h3><a id="interface%C2%A0-viewtreeobserver-onscrollchangedlistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>interface <code>ViewTreeObserver.OnScrollChangedListener</code></h3>
<p>当一个视图树中的一些组件发生滚动时，所要调用的回调函数的接口类</p>
<h3><a id="interface%C2%A0-viewtreeobserver-ontouchmodechangelistener" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>interface <code>ViewTreeObserver.OnTouchModeChangeListener</code></h3>
<p>当一个视图树的触摸模式发生改变时，所要调用的回调函数的接口类</p>
<h2><a id="%E5%AE%9E%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实例</h2>
<p>其中，我们可以利用<code>OnGlobalLayoutListener</code>来获得一个视图的真实高度。</p>
<pre class="line-numbers"><code class="language-java">int mHeaderViewHeight;  
mHeaderView.getViewTreeObserver().addOnGlobalLayoutListener(  
    new OnGlobalLayoutListener() {  
    @Override  
    public void onGlobalLayout() {  
                                                                                                                                                                                                                                        m    HeaderViewHeight = mHeaderView.getHeight();  
    getViewTreeObserver().removeGlobalOnLayoutListener(this);  
    }  
});
</code></pre>
<p><strong>但是需要注意的是OnGlobalLayoutListener可能会被多次触发，因此在得到了高度之后，要将OnGlobalLayoutListener注销掉。另外mHeaderViewHeight和mHeaderView都需要写在当前java文件类（比如Activity）的成员变量中。不能直接在onCreate中定义否则会编译不通过：</strong></p>
<p><code>Cannot refer to a non-final variable sHeight inside an inner class defined in a different method</code></p>
<p>有时候需要在<code>onCreate</code>方法中知道某个View组件的宽度和高度等信息，而直接调用View组件的<code>getWidth()</code>、<code>getHeight()</code>、<code>getMeasuredWidth()</code>、<code>getMeasuredHeight()</code>、<code>getTop()</code>、<code>getLeft()</code>等方法是无法获取到真实值的，只会得到0。这是因为View组件布局要在onResume回调后完成。下面提供实现方法，onGlobalLayout回调会在view布局完成时自动调用:</p>
<pre class="line-numbers"><code class="language-java">// This listener is used to get the final width of the GridView and then calculate the  
// number of columns and the width of each column. The width of each column is variable  
// as the GridView has stretchMode=columnWidth. The column width is used to set the height  
// of each view so we get nice square thumbnails.  
mGridView.getViewTreeObserver().addOnGlobalLayoutListener( //view 布局完成时调用，每次view改变时都会调用  
    new ViewTreeObserver.OnGlobalLayoutListener() {  
    @Override  
    public void onGlobalLayout() {  
        if (mAdapter.getNumColumns() == 0) {  
            final int numColumns = (int) Math.floor(mGridView.getWidth() / (mImageThumbSize + mImageThumbSpacing));  
            if (numColumns &gt; 0) {  
                final int columnWidth = (mGridView.getWidth() / numColumns) - mImageThumbSpacing;  
                mAdapter.setNumColumns(numColumns);   //设置 列数  
                mAdapter.setItemHeight(columnWidth);  //设置 高度  
            }  
        } 
    }  
});
</code></pre>
<p><strong>在gridview布局完成后，根据girdview的宽和高设置adapter列数和每个item高度</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/08/05</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870240.html">
                
                  <h1>Android-Retrofit详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="retrofit%E5%85%A5%E9%97%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Retrofit入门</h2>
<p>Retrofit 其实相当简单，简单到源码只有37个文件，其中22个文件是注解还都和HTTP有关，真正暴露给用户的类并不多。</p>
<h3><a id="%E5%88%9B%E5%BB%BAretrofit%E5%AE%9E%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建Retrofit实例</h3>
<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;http://localhost:4567/&quot;)
        .build();
</code></pre>
<p>创建Retrofit实例时需要通过<code>Retrofit.Builder</code>,并调用<code>baseUrl</code>方法设置URL。注： Retrofit2 的baseUlr 必须以 /（斜线） 结束，不然会抛出一个<code>IllegalArgumentException</code>。</p>
<h3><a id="%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口定义</h3>
<p>以获取指定id的Blog为例:</p>
<pre class="line-numbers"><code class="language-java">public interface BlogService {
    @GET(&quot;blog/{id}&quot;)
    Call&lt;ResponseBody&gt; getBlog(@Path(&quot;id&quot;) int id);
}
</code></pre>
<p>注意，这里是<code>interface</code>不是<code>class</code>，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个<code>BlogService</code>的代理对象。<br />
<code>BlogService service = retrofit.create(BlogService.class);</code><br />
拿到代理对象之后，就可以调用该方法啦。</p>
<h3><a id="%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口调用</h3>
<pre class="line-numbers"><code class="language-java">Call&lt;ResponseBody&gt; call = service.getBlog(2);
// 用法和OkHttp的call如出一辙,
// 不同的是如果是Android系统回调方法执行在主线程
call.enqueue(new Callback&lt;ResponseBody&gt;() {
    @Override
    public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
        try {
            System.out.println(response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
        t.printStackTrace();
    }
});
</code></pre>
<p>打印结果:</p>
<p><code>{&quot;code&quot;:200,&quot;msg&quot;:&quot;OK&quot;,&quot;data&quot;:{&quot;id&quot;:2,&quot;date&quot;:&quot;2016-04-15 03:17:50&quot;,&quot;author&quot;:&quot;怪盗kidou&quot;,&quot;title&quot;:&quot;Retrofit2 测试2&quot;,&quot;content&quot;:&quot;这里是 Retrofit2 Demo 测试服务器2&quot;},&quot;count&quot;:0,&quot;page&quot;:0}</code></p>
<h2><a id="retrofit%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Retrofit注解详解</h2>
<p>上面提到Retrofit 共22个注解，这节就专门介绍这22个注解，为帮助大家更好理解我将这22个注解分为三类，并用表格的形式展现出来,表格上说得并不完整，具体的见源码上的例子注释。</p>
<h3><a id="%E7%AC%AC%E4%B8%80%E7%B1%BB%EF%BC%9Ahttp%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一类：HTTP请求方法</h3>
<p><figure><img src="media/15561207870240/15713328600715.png" alt="" /></figure></p>
<p>以上表格中的除HTTP以外都对应了HTTP标准中的请求方法，而HTTP注解则可以代替以上方法中的任意一个注解,有3个属性：<code>method</code>、<code>path</code>、<code>hasBody</code></p>
<pre class="line-numbers"><code class="language-java">public interface BlogService {
    /**
     * method 表示请求的方法，区分大小写
     * path表示路径
     * hasBody表示是否有请求体
     */
    @HTTP(method = &quot;GET&quot;, path = &quot;blog/{id}&quot;, hasBody = false)
    Call&lt;ResponseBody&gt; getBlog(@Path(&quot;id&quot;) int id);
}
public static void main(String[] args){
    Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;http://localhost:4567/&quot;)
        .build();
    BlogService service = retrofit.create(BlogService.class);
    Call&lt;ResponseBody&gt; call = service.getBlog(2);
    ResponseBodyPrinter.printResponseBody(call);
}
</code></pre>
<h3><a id="%E7%AC%AC%E4%BA%8C%E7%B1%BB%EF%BC%9A%E6%A0%87%E8%AE%B0%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二类：标记类</h3>
<p><figure><img src="media/15561207870240/15713328762764.png" alt="" /></figure></p>
<p>Field、FieldMap、Part和PartMap 示例</p>
<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap/Multipart/Part/PartMap注解]源码
 */
public class Example03 {
    public interface BlogService {

        /**
         * {@link FormUrlEncoded} 表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）
         * &lt;code&gt;Field(&quot;username&quot;)&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值
         */
        @POST(&quot;/form&quot;)
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded1(@Field(&quot;username&quot;) String name, @Field(&quot;age&quot;) int age);

        /**
         * Map的key作为表单的键
         */
        @POST(&quot;/form&quot;)
        @FormUrlEncoded
        Call&lt;ResponseBody&gt; testFormUrlEncoded2(@FieldMap Map&lt;String, Object&gt; map);


        /**
         * {@link Part} 后面支持三种类型，{@link RequestBody}、{@link okhttp3.MultipartBody.Part} 、任意类型
         * 除 {@link okhttp3.MultipartBody.Part} 以外，其它类型都必须带上表单字段({@link okhttp3.MultipartBody.Part} 中已经包含了表单字段的信息)，
         */
        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload1(@Part(&quot;name&quot;) RequestBody name, @Part(&quot;age&quot;) RequestBody age, @Part MultipartBody.Part file);

        /**
         * PartMap 注解支持一个Map作为参数，支持 {@link RequestBody } 类型，
         * 如果有其它的类型，会被{@link retrofit2.Converter}转换，如后面会介绍的 使用{@link com.google.gson.Gson} 的 {@link retrofit2.converter.gson.GsonRequestBodyConverter}
         * 所以{@link MultipartBody.Part} 就不适用了,所以文件只能用&lt;b&gt; @Part MultipartBody.Part &lt;/b&gt;
         */
        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload2(@PartMap Map&lt;String, RequestBody&gt; args, @Part MultipartBody.Part file);

        @POST(&quot;/form&quot;)
        @Multipart
        Call&lt;ResponseBody&gt; testFileUpload3(@PartMap Map&lt;String, RequestBody&gt; args);
    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);


        // 演示 @FormUrlEncoded 和 @Field
        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(&quot;怪盗kidou&quot;, 24);
        ResponseBodyPrinter.printResponseBody(call1);


        //===================================================

        // 演示 @FormUrlEncoded 和 @FieldMap
        // 实现的效果与上面想同
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;username&quot;, &quot;怪盗kidou&quot;);
        map.put(&quot;age&quot;, 24);
        Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map);
        ResponseBodyPrinter.printResponseBody(call2);


        //===================================================


        MediaType textType = MediaType.parse(&quot;text/plain&quot;);
        RequestBody name = RequestBody.create(textType, &quot;怪盗kidou&quot;);
        RequestBody age = RequestBody.create(textType, &quot;24&quot;);
        RequestBody file = RequestBody.create(MediaType.parse(&quot;application/octet-stream&quot;), &quot;这里是模拟文件的内容&quot;);

        // 演示 @Multipart 和 @Part
        MultipartBody.Part filePart = MultipartBody.Part.createFormData(&quot;file&quot;, &quot;test.txt&quot;, file);
        Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart);
        ResponseBodyPrinter.printResponseBody(call3);

        //===================================================
        // 演示 @Multipart 和 @PartMap
        // 实现和上面同样的效果
        Map&lt;String, RequestBody&gt; fileUpload2Args = new HashMap&lt;&gt;();
        fileUpload2Args.put(&quot;name&quot;, name);
        fileUpload2Args.put(&quot;age&quot;, age);
        //这里并不会被当成文件，因为没有文件名(包含在Content-Disposition请求头中)，但上面的 filePart 有
        //fileUpload2Args.put(&quot;file&quot;, file);
        Call&lt;ResponseBody&gt; call4 = service.testFileUpload2(fileUpload2Args, filePart); //单独处理文件
        ResponseBodyPrinter.printResponseBody(call4);

        //===================================================
        // 还有一种比较hack的方式可以实现文件上传，
        // 上面说过被当成文件上传的必要条件就是 Content-Disposition 请求头中必须要有 filename=&quot;xxx&quot; 才会被当成文件
        // 所有我们在写文件名的时候可以拼把 filename=&quot;XXX&quot; 也拼接上去，
        // 即文件名变成  表单键名&quot;; filename=&quot;文件名  （两端的引号会自动加，所以这里不加）也可以实现，但是不推荐方式

        Map&lt;String, RequestBody&gt; fileUpload3Args = new HashMap&lt;&gt;();
        fileUpload3Args.put(&quot;name&quot;,name);
        fileUpload3Args.put(&quot;age&quot;,age);
        fileUpload3Args.put(&quot;file\&quot;; filename=\&quot;test.txt&quot;,file);
        Call&lt;ResponseBody&gt; testFileUpload3 = service.testFileUpload3(fileUpload3Args);
        ResponseBodyPrinter.printResponseBody(testFileUpload3);
    }
}
</code></pre>
<h3><a id="%E7%AC%AC%E4%B8%89%E7%B1%BB%EF%BC%9A%E5%8F%82%E6%95%B0%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三类：参数类</h3>
<p><figure><img src="media/15561207870240/15713328860835.png" alt="" /></figure></p>
<p>注1：{占位符}和<code>PATH</code>尽量只用在URL的path部分，url中的参数使用<code>Query</code>和<code>QueryMap</code> 代替，保证接口定义的简洁注2：<code>Query</code>、<code>Field</code>和<code>Part</code>这三者都支持数组和实现了<code>Iterable</code>接口的类型，如<code>List</code>，<code>Set</code>等，方便向后台传递数组。</p>
<pre class="line-numbers"><code class="language-java">Call&lt;ResponseBody&gt; foo(@Query(&quot;ids[]&quot;) List&lt;Integer&gt; ids);
//结果：ids[]=0&amp;ids[]=1&amp;ids[]=2
</code></pre>
<p>Header和Headers例子</p>
<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap注解]源码
 */
public class Example04 {
    public interface BlogService {
        @GET(&quot;/headers?showAll=true&quot;)
        @Headers({&quot;CustomHeader1: customHeaderValue1&quot;, &quot;CustomHeader2: customHeaderValue2&quot;})
        Call&lt;ResponseBody&gt; testHeader(@Header(&quot;CustomHeader3&quot;) String customHeaderValue3);

    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);

        //演示 @Headers 和 @Header
        Call&lt;ResponseBody&gt; call1 = service.testHeader(&quot;ikidou&quot;);
        ResponseBodyPrinter.printResponseBody(call1);
    }
}
</code></pre>
<p>Query、QueryMap、Url 示例</p>
<pre class="line-numbers"><code class="language-java">/**
 * [Retrofit注解详解 之 FormUrlEncoded/Field/FieldMap注解]源码
 */
public class Example05 {
    public interface BlogService {
        /**
         * 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供
         * 对于Query和QueryMap，如果不是String（或Map的第二个泛型参数不是String）时
         * 会被默认会调用toString转换成String类型
         * Url支持的类型有 okhttp3.HttpUrl, String, java.net.URI, android.net.Uri
         * {@link retrofit2.http.QueryMap} 用法和{@link retrofit2.http.FieldMap} 用法一样，不再说明
         */
        @GET //当有URL注解时，这里的URL就省略了
        Call&lt;ResponseBody&gt; testUrlAndQuery(@Url String url, @Query(&quot;showAll&quot;) boolean showAll);

    }

    public static void main(String[] args) {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(&quot;http://localhost:4567/&quot;)
                .build();

        BlogService service = retrofit.create(BlogService.class);

        //演示 @Headers 和 @Header
        Call&lt;ResponseBody&gt; call1 = service.testUrlAndQuery(&quot;headers&quot;,false);
        ResponseBodyPrinter.printResponseBody(call1);
    }
}
</code></pre>
<h2><a id="gson%E4%B8%8Econverter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson与Converter</h2>
<p>在默认情况下Retrofit只支持将HTTP的响应体转换换为<code>ResponseBody</code>,这也是什么我在前面的例子接口的返回值都是 <code>Call&lt;ResponseBody&gt;</code>，但如果响应体只是支持转换为<code>ResponseBody</code>的话何必要引用泛型呢，返回值直接用一个<code>Call</code>就行了嘛，既然支持泛型，那说明泛型参数可以是其它类型的，而<code>Converter</code>就是Retrofit为我们提供用于将<code>ResponseBody</code>转换为我们想要的类型，有了<code>Converter</code>之后我们就可以写把我们的第一个例子的接口写成这个样子了：</p>
<pre class="line-numbers"><code class="language-java">public interface BlogService {
  @GET(&quot;blog/{id}&quot;)
  Call&lt;Result&lt;Blog&gt;&gt; getBlog(@Path(&quot;id&quot;) int id);
}
</code></pre>
<p>当然只改变泛型的类型是不行的，我们在创建Retrofit时需要明确告知用于将<code>ResponseBody</code>转换我们泛型中的类型时需要使用的<code>Converter</code>引入Gson支持:<br />
<code>compile 'com.squareup.retrofit2:converter-gson:2.0.2'</code></p>
<p>通过<code>GsonConverterFactory</code>为<code>Retrofit</code>添加<code>Gson</code>支持：</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
      //配置你的Gson
      .setDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)
      .create();

Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      //可以接收自定义的Gson，当然也可以不传
      .addConverterFactory(GsonConverterFactory.create(gson))
      .build();
</code></pre>
<p>这样Retrofit就会使用Gson将<code>ResponseBody</code>转换我们想要的类型。这是时候我们终于可以演示如使创建一个Blog了！</p>
<pre class="line-numbers"><code class="language-java">@POST(&quot;blog&quot;)
Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog);
</code></pre>
<p>被<code>@Body</code>注解的的Blog将会被Gson转换成RequestBody发送到服务器。</p>
<pre class="line-numbers"><code class="language-java">BlogService service = retrofit.create(BlogService.class);
Blog blog = new Blog();
blog.content = &quot;新建的Blog&quot;;
blog.title = &quot;测试&quot;;
blog.author = &quot;怪盗kidou&quot;;
Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog);
</code></pre>
<p>结果：</p>
<p><code>Result{code=200, msg='OK', data=Blog{id=20, date='2016-04-21 05:29:58', author='怪盗kidou', title='测试', content='新建的Blog'}, count=0, page=0}</code></p>
<h2><a id="rxjava%E4%B8%8Ecalladapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RxJava与CallAdapter</h2>
<p>说到Retrofit就不得说到另一个火到不行的库<code>RxJava</code>，网上已经不少文章讲如何与Retrofit结合，但这里还是会有一个RxJava的例子，不过这里主要目的是介绍使用<code>CallAdapter</code>所带来的效果。</p>
<p>第3节介绍的<code>Converter</code>是对于<code>Call&lt;T&gt;</code>中<code>T</code>的转换，而<code>CallAdapter</code>则可以对<code>Call</code>转换，这样的话<code>Call&lt;T&gt;</code>中的<code>Call</code>也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个<code>CallAdapter</code>，这里以<code>RxJava</code>的为例，用<code>Observable</code>代替<code>Call</code>：</p>
<p>引入RxJava支持:</p>
<pre class="line-numbers"><code class="language-java">compile 'com.squareup.retrofit2:adapter-rxjava:2.0.2'
// 针对rxjava2.x（adapter-rxjava2的版本要 &gt;= 2.2.0）
compile 'com.squareup.retrofit2:adapter-rxjava2:2.3.0'
</code></pre>
<p>通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：</p>
<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
      // 针对rxjava2.x
      .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) 
      .build();
</code></pre>
<p>接口设计：</p>
<pre class="line-numbers"><code class="language-java">public interface BlogService {
  @POST(&quot;/blog&quot;)
  Observable&lt;Result&lt;List&lt;Blog&gt;&gt;&gt; getBlogs();
}
</code></pre>
<p>使用：</p>
<pre class="line-numbers"><code class="language-java">BlogService service = retrofit.create(BlogService.class);
service.getBlogs(1)
  .subscribeOn(Schedulers.io())
  .subscribe(new Subscriber&lt;Result&lt;List&lt;Blog&gt;&gt;&gt;() {
      @Override
      public void onCompleted() {
        System.out.println(&quot;onCompleted&quot;);
      }

      @Override
      public void onError(Throwable e) {
        System.err.println(&quot;onError&quot;);
      }

      @Override
      public void onNext(Result&lt;List&lt;Blog&gt;&gt; blogsResult) {
        System.out.println(blogsResult);
      }
  });
</code></pre>
<p>结果：</p>
<p><code>Result{code=200, msg='OK', data=[Blog{id=1, date='2016-04-15 03:17:50', author='怪盗kidou', title='Retrofit2 测试1', content='这里是 Retrofit2 Demo 测试服务器1'},.....], count=20, page=1}</code></p>
<p>像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：</p>
<ol>
<li>用<code>Observable&lt;Response&lt;T&gt;&gt;</code> 代替 <code>Observable&lt;T&gt;</code> ,这里的<code>Response</code>指<code>retrofit2.Response</code></li>
<li>用<code>Observable&lt;Result&lt;T&gt;&gt;</code> 代替 <code>Observable&lt;T&gt;</code>，这里的<code>Result</code>是指<code>retrofit2.adapter.rxjava.Result</code>,这个Result中包含了<code>Response</code>的实例。</li>
</ol>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89converter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义Converter</h2>
<p>本节的内容是教大家实现在一简易的Converter，这里以返回格式为<code>Call&lt;String&gt;</code>为例。<br />
在此之前先了解一下Converter接口及其作用：</p>
<pre class="line-numbers"><code class="language-java">public interface Converter&lt;F, T&gt; {
  // 实现从 F(rom) 到 T(o)的转换
  T convert(F value) throws IOException;

  // 用于向Retrofit提供相应Converter的工厂
  abstract class Factory {
    // 这里创建从ResponseBody其它类型的Converter，如果不能处理返回null
    // 主要用于对响应体的处理
    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) {
      return null;
    }

    // 在这里创建 从自定类型到ResponseBody 的Converter,不能处理就返回null，
    // 主要用于对Part、PartMap、Body注解的处理
    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,
    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
      return null;
    }

    // 这里用于对Field、FieldMap、Header、Path、Query、QueryMap注解的处理
    // Retrfofit对于上面的几个注解默认使用的是调用toString方法
    public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) {
      return null;
    }

  }
}
</code></pre>
<p>我们要想从<code>Call&lt;ResponseBody&gt;</code> 转换为 <code>Call&lt;String&gt;</code> 那么对应的F和T则分别对应<code>ResponseBody</code>和<code>String</code>，我们定义一个<code>StringConverter</code>并实现Converter接口。</p>
<pre class="line-numbers"><code class="language-java">public static class StringConverter implements Converter&lt;ResponseBody, String&gt; {

  public static final StringConverter INSTANCE = new StringConverter();

  @Override
  public String convert(ResponseBody value) throws IOException {
    return value.string();
  }
}
</code></pre>
<p>我们需要一个<code>Fractory</code>来向Retrofit注册<code>StringConverter</code></p>
<pre class="line-numbers"><code class="language-java">public static class StringConverterFactory extends Converter.Factory {

  public static final StringConverterFactory INSTANCE = new StringConverterFactory();

  public static StringConverterFactory create() {
    return INSTANCE;
  }

  // 我们只关实现从ResponseBody 到 String 的转换，所以其它方法可不覆盖
  @Override
  public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {
    if (type == String.class) {
      return StringConverter.INSTANCE;
    }
    //其它类型我们不处理，返回null就行
    return null;
  }
}
</code></pre>
<p>使用<code>Retrofit.Builder.addConverterFactory</code>向Retrofit注册我们<code>StringConverterFactory</code>：</p>
<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      // 如是有Gson这类的Converter 一定要放在其它前面
      .addConverterFactory(StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .build();
</code></pre>
<p>注：<code>addConverterFactory</code>是有先后顺序的，如果有多个ConverterFactory都支持同一种类型，那么就是只有第一个才会被使用，而<code>GsonConverterFactory</code>是不判断是否支持的，所以这里交换了顺序还会有一个异常抛出，原因是类型不匹配。</p>
<p>只要返回值类型的泛型参数就会由我们的<code>StringConverter</code>处理,不管是<code>Call&lt;String&gt;</code>还是<code>Observable&lt;String&gt;</code>有没有很简单?如果你有其它的需求处理的就自己实现吧。</p>
<h2><a id="%E8%87%AA%E5%AE%9A%E4%B9%89calladapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义CallAdapter</h2>
<p>本节将介绍如何自定一个<code>CallAdapter</code>，并验证是否所有的String都会使用我们第5节中自定义的Converter。</p>
<p>先看一下CallAdapter接口定义及各方法的作用：</p>
<pre class="line-numbers"><code class="language-java">public interface CallAdapter&lt;T&gt; {

  // 直正数据的类型 如Call&lt;T&gt; 中的 T
  // 这个 T 会作为Converter.Factory.responseBodyConverter 的第一个参数
  // 可以参照上面的自定义Converter
  Type responseType();

  &lt;R&gt; T adapt(Call&lt;R&gt; call);

  // 用于向Retrofit提供CallAdapter的工厂类
  abstract class Factory {
    // 在这个方法中判断是否是我们支持的类型，returnType 即Call&lt;Requestbody&gt;和`Observable&lt;Requestbody&gt;`
    // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型
    // 不支持时返回null
    public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations,
    Retrofit retrofit);

    // 用于获取泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody
    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
      return Utils.getParameterUpperBound(index, type);
    }

    // 用于获取泛型的原始类型 如 Call&lt;Requestbody&gt; 中的 Call
    // 上面的get方法需要使用该方法。
    protected static Class&lt;?&gt; getRawType(Type type) {
      return Utils.getRawType(type);
    }
  }
}
</code></pre>
<p>了解了<code>CallAdapter</code>的结构和其作用之后，我们就可以开始自定义我们的<code>CallAdapter</code>了，本节以<code>CustomCall&lt;String&gt;</code>为例。<br />
在此我们需要定义一个<code>CustomCall</code>，不过这里的<code>CustomCall</code>作为演示只是对<code>Call</code>的一个包装，并没有实际的用途。</p>
<pre class="line-numbers"><code class="language-java">public static class CustomCall&lt;R&gt; {

  public final Call&lt;R&gt; call;

  public CustomCall(Call&lt;R&gt; call) {
    this.call = call;
  }

  public R get() throws IOException {
    return call.execute().body();
  }
}
</code></pre>
<p>有了<code>CustomCall</code>，我们还需要一个<code>CustomCallAdapter</code>来实现 <code>Call&lt;T&gt;</code> 到 <code>CustomCall&lt;T&gt;</code>的转换，这里需要注意的是最后的泛型，是我们要返回的类型。</p>
<pre class="line-numbers"><code class="language-java">public static class CustomCallAdapter implements CallAdapter&lt;CustomCall&lt;?&gt;&gt; {

  private final Type responseType;

  // 下面的 responseType 方法需要数据的类型
  CustomCallAdapter(Type responseType) {
    this.responseType = responseType;
  }

  @Override
  public Type responseType() {
    return responseType;
  }

  @Override
  public &lt;R&gt; CustomCall&lt;R&gt; adapt(Call&lt;R&gt; call) {
    // 由 CustomCall 决定如何使用
    return new CustomCall&lt;&gt;(call);
  }
}
</code></pre>
<p>提供一个<code>CustomCallAdapterFactory</code>用于向Retrofit提供<code>CustomCallAdapter</code>：</p>
<pre class="line-numbers"><code class="language-java">public static class CustomCallAdapterFactory extends CallAdapter.Factory {
  public static final CustomCallAdapterFactory INSTANCE = new CustomCallAdapterFactory();

  @Override
  public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
    // 获取原始类型
    Class&lt;?&gt; rawType = getRawType(returnType);
    // 返回值必须是CustomCall并且带有泛型
    if (rawType == CustomCall.class &amp;&amp; returnType instanceof ParameterizedType) {
      Type callReturnType = getParameterUpperBound(0, (ParameterizedType) returnType);
      return new CustomCallAdapter(callReturnType);
    }
    return null;
  }
}
</code></pre>
<p>使用<code>addCallAdapterFactory</code>向Retrofit注册<code>CustomCallAdapterFactory</code>。</p>
<pre class="line-numbers"><code class="language-java">Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(Example09.StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(CustomCallAdapterFactory.INSTANCE)
      .build();
</code></pre>
<p>注： <code>addCallAdapterFactory</code>与<code>addConverterFactory</code>同理，也有先后顺序。</p>
<h2><a id="%E5%85%B6%E5%AE%83%E8%AF%B4%E6%98%8E" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>其它说明</h2>
<h3><a id="retrofit-builder" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Retrofit.Builder</h3>
<p>前面用到了 <code>Retrofit.Builder</code> 中的<code>baseUrl</code>、<code>addCallAdapterFactory</code>、<code>addConverterFactory</code>、<code>build</code>方法，还有<code>callbackExecutor</code>、<code>callFactory</code>、<code>client</code>、<code>validateEagerly</code>这四个方法没有用到，这里简单的介绍一下。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>callbackExecutor(Executor)</td>
<td>指定<code>Call.enqueue</code>时使用的<code>Executor</code>，所以该设置只对返回值为<code>Call</code>的方法有效</td>
</tr>
<tr>
<td>callFactory(Factory)</td>
<td>设置一个自定义的<code>okhttp3.Call.Factory</code>，那什么是Factory呢?<code>OkHttpClient</code>就实现了<code>okhttp3.Call.Factory</code>接口，下面的<code>client(OkHttpClient)</code>最终也是调用了该方法，也就是说两者不能共用</td>
</tr>
<tr>
<td>client(OkHttpClient)</td>
<td>设置自定义的<code>OkHttpClient</code>,以前的Retrofit版本中不同的<code>Retrofit</code>对象共用同<code>OkHttpClient</code>,在2.0各对象各自持有不同的<code>OkHttpClient</code>实例，所以当你需要共用<code>OkHttpClient</code>或需要自定义时则可以使用该方法，如：处理Cookie、使用 stetho  调式等<br/></td>
</tr>
<tr>
<td>validateEagerly(boolean)</td>
<td>是否在调用<code>create(Class)</code>时检测接口定义是否正确，而不是在调用方法才检测，适合在开发、测试时使用</td>
</tr>
</tbody>
</table>
<h3><a id="retrofit%E7%9A%84url%E7%BB%84%E5%90%88%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Retrofit的Url组合规则</h3>
<table>
<thead>
<tr>
<th>BaseUrl</th>
<th>和URL有关的注解中提供的值</th>
<th>最后结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td>/post</td>
<td><a href="http://localhost:4567/post">http://localhost:4567/post</a></td>
</tr>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td>post</td>
<td><a href="http://localhost:4567/path/to/other/post">http://localhost:4567/path/to/other/post</a></td>
</tr>
<tr>
<td><a href="http://localhost:4567/path/to/other/">http://localhost:4567/path/to/other/</a></td>
<td><a href="https://github.com/ikidou">https://github.com/ikidou</a></td>
<td><a href="https://github.com/ikidou">https://github.com/ikidou</a></td>
</tr>
</tbody>
</table>
<p>从上面不能难看出以下规则：</p>
<ul>
<li>如果你在注解中提供的url是完整的url，则url将作为请求的url。</li>
<li>如果你在注解中提供的url是不完整的url，且不以 / 开头，则请求的url为baseUrl+注解中提供的值</li>
<li>如果你在注解中提供的url是不完整的url，且以 / 开头，则请求的url为baseUrl的主机部分+注解中提供的值</li>
</ul>
<h3><a id="retrofit%E6%8F%90%E4%BE%9B%E7%9A%84converter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Retrofit提供的Converter</h3>
<table>
<thead>
<tr>
<th>Converter</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gson</td>
<td>com.squareup.retrofit2:converter-gson:2.0.2</td>
</tr>
<tr>
<td>Jackson</td>
<td>com.squareup.retrofit2:converter-jackson:2.0.2</td>
</tr>
<tr>
<td>Moshi</td>
<td>com.squareup.retrofit2:converter-moshi:2.0.2</td>
</tr>
<tr>
<td>Protobuf</td>
<td>com.squareup.retrofit2:converter-protobuf:2.0.2</td>
</tr>
<tr>
<td>Wire</td>
<td>com.squareup.retrofit2:converter-wire:2.0.2</td>
</tr>
<tr>
<td>Simple XML</td>
<td>com.squareup.retrofit2:converter-simplexml:2.0.2</td>
</tr>
<tr>
<td>Scalars</td>
<td>com.squareup.retrofit2:converter-scalars:2.0.2</td>
</tr>
</tbody>
</table>
<h3><a id="retrofit%E6%8F%90%E4%BE%9B%E7%9A%84calladapter%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Retrofit提供的CallAdapter：</h3>
<table>
<thead>
<tr>
<th>CallAdapter</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td>guava</td>
<td>com.squareup.retrofit2:adapter-guava:2.0.2</td>
</tr>
<tr>
<td>Java8</td>
<td>com.squareup.retrofit2:adapter-java8:2.0.2</td>
</tr>
<tr>
<td>rxjava</td>
<td>com.squareup.retrofit2:adapter-rxjava:2.0.2</td>
</tr>
</tbody>
</table>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/07/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870200.html">
                
                  <h1>Android-Gson详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>最近在项目中发现网络请求回来的Json数据都用Gson进行解析，以前没有对其进行一个系统的了解，所以这里做一个知识点的归纳整理。</p>
<p>Gson（又称Google Gson）是Google公司发布的一个开放源代码的Java库，主要用途为序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。而JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，广泛应用于各种数据的交互中，尤其是服务器与客户端的交互。</p>
<h2><a id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本概念</h2>
<ul>
<li>Serialization:序列化，使Java对象到Json字符串的过程。</li>
<li>Deserialization：反序列化，字符串转换成Java对象。</li>
<li>JSON数据中的<code>JsonElement</code>有下面这四种类型：  JsonPrimitive —— 例如一个字符串或整型JsonObject—— 一个以 JsonElement 名字（类型为           String）作为索引的集合。也就是说可以把 JsonObject 看作值为 JsonElement 的键值对集合。JsonArray—— JsonElement 的集合。注意数组的元素可以是四种类型中的任意一种，或者混合类型都支持。JsonNull—— 值为null</li>
</ul>
<h2><a id="gson%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson解决的问题</h2>
<ul>
<li>提供一种像toString()和构造方法的很简单的机制，来实现Java 对象和Json之间的互相转换。</li>
<li>允许已经存在的无法改变的对象，转换成Json，或者Json转换成已存在的对象。</li>
<li>允许自定义对象的表现形式</li>
<li>支持任意的复杂对象</li>
<li>能够生成可压缩和可读的Json的字符串输出。</li>
</ul>
<h2><a id="gson%E5%A4%84%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson处理对象的几个重要点</h2>
<ul>
<li>推荐把成员变量都声明称<code>private</code>的</li>
<li>没有必要用注解（<code>@Expose</code> 注解）指明某个字段是否会被序列化或者反序列化，所有包含在当前类（包括父类）中的字段都应该默认被序列化或者反序列化</li>
<li>如果某个字段被 <code>transient</code> 这个Java关键词修饰，就不会被序列化或者反序列化</li>
<li>下面的实现方式能够正确的处理<code>null</code>
<ul>
<li>当序列化的时候，如果对象的某个字段为<code>null</code>，是不会输出到Json字符串中的。</li>
<li>当反序列化的时候，某个字段在<code>Json</code>字符串中找不到对应的值，就会被赋值为<code>null</code></li>
</ul>
</li>
<li>如果一个字段是 <code>synthetic</code>的,他会被忽视，也即是不应该被序列化或者反序列化</li>
<li>内部类（或者<code>anonymous class</code>（匿名类），或者<code>local class</code>(局部类，可以理解为在方法内部声明的类)）的某个字段和外部类的某个字段一样的话，就会被忽视，不会被序列化或者反序列化</li>
</ul>
<h2><a id="gson%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson的基本用法</h2>
<p>Gson提供了<code>fromJson()</code> 和<code>toJson()</code>两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。</p>
<p>基本数据类型的解析</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
int i = gson.fromJson(&quot;100&quot;, int.class);              //100
double d = gson.fromJson(&quot;\&quot;99.99\&quot;&quot;, double.class);  //99.99
boolean b = gson.fromJson(&quot;true&quot;, boolean.class);     // true
String str = gson.fromJson(&quot;String&quot;, String.class);   // String
</code></pre>
<p><strong>注：不知道你是否注意到了第2、3行有什么不一样没</strong></p>
<p>基本数据类型的生成</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
String jsonNumber = gson.toJson(100);       // 100
String jsonBoolean = gson.toJson(false);    // false
String jsonString = gson.toJson(&quot;String&quot;); //&quot;String&quot;
</code></pre>
<p>POJO类的生成与解析</p>
<pre class="line-numbers"><code class="language-java">public class User {
    //省略其它
    public String name;
    public int age;
    public String emailAddress;
}
</code></pre>
<p>生成JSON：</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24);
String jsonObject = gson.toJson(user); // {&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24}
</code></pre>
<p>解析JSON：</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
String jsonString = &quot;{\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:24}&quot;;
User user = gson.fromJson(jsonString, User.class);
</code></pre>
<h3><a id="gson%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson中使用泛型</h3>
<p>上面了解的JSON中的Number、boolean、Object和String，现在说一下Array。<br />
例：JSON字符串数组</p>
<pre class="line-numbers"><code class="language-java">[&quot;Android&quot;,&quot;Java&quot;,&quot;PHP&quot;]
</code></pre>
<p>当我们要通过Gson解析这个json时，一般有两种方式：使用数组，使用List。而List对于增删都是比较方便的，所以实际使用是还是List比较多。</p>
<p>数组比较简单</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
String jsonArray = &quot;[\&quot;Android\&quot;,\&quot;Java\&quot;,\&quot;PHP\&quot;]&quot;;
String[] strings = gson.fromJson(jsonArray, String[].class);
</code></pre>
<p>但对于List将上面的代码中的 <code>String[].class</code> 直接改为 <code>List&lt;String&gt;.class</code> 是行不通的。对于Java来说<code>List&lt;String&gt;</code> 和<code>List&lt;User&gt;</code> 这俩个的字节码文件只一个那就是<code>List.class</code>，这是Java泛型使用时要注意的问题 泛型擦除。<br />
为了解决的上面的问题，Gson为我们提供了<code>TypeToken</code>来实现对泛型的支持，所以当我们希望使用将以上的数据解析<code>List&lt;String&gt;</code>时需要这样写。</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
String jsonArray = &quot;[\&quot;Android\&quot;,\&quot;Java\&quot;,\&quot;PHP\&quot;]&quot;;
String[] strings = gson.fromJson(jsonArray, String[].class);
List&lt;String&gt; stringList = gson.fromJson(jsonArray, new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType());
</code></pre>
<p>注：<code>TypeToken</code>的构造方法是<code>protected</code>修饰的,所以上面才会写成<code>new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType()</code> 而不是  <code>new TypeToken&lt;List&lt;String&gt;&gt;().getType()</code>泛型解析对接口POJO的设计影响泛型的引入可以减少无关的代码，如我现在所在公司接口返回的数据分为两类：</p>
<pre class="line-numbers"><code class="language-json">{&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:{}}
</code></pre>
<pre class="line-numbers"><code class="language-json">{&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:[]}
</code></pre>
<p>我们真正需要的<code>data</code>所包含的数据，而<code>code</code>只使用一次，<code>message</code>则几乎不用。如果Gson不支持泛型或不知道Gson支持泛型的同学一定会这么定义POJO。</p>
<pre class="line-numbers"><code class="language-java">public class UserResponse {
    public int code;
    public String message;
    public User data;
}
</code></pre>
<p>当其它接口的时候又重新定义一个<code>XXResponse</code>将<code>data</code>的类型改成XX，很明显<code>code</code>，和<code>message</code>被重复定义了多次，通过泛型的话我们可以将<code>code</code>和<code>message</code>字段抽取到一个<code>Result</code>的类中，这样我们只需要编写<code>data</code>字段所对应的POJO即可，更专注于我们的业务逻辑。如：</p>
<pre class="line-numbers"><code class="language-java">public class Result&lt;T&gt; {
    public int code;
    public String message;
    public T data;
}
</code></pre>
<p>那么对于<code>data</code>字段是<code>User</code>时则可以写为 <code>Result&lt;User&gt;</code> ,当是个列表的时候为 <code>Result&lt;List&lt;User&gt;&gt;</code>，其它同理。</p>
<h3><a id="%E6%89%8B%E5%8A%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手动方式</h3>
<p>手动的方式就是使用<code>stream</code>包下的<code>JsonReader</code>类来手动实现反序列化，和Android中使用pull解析XML是比较类似的。</p>
<pre class="line-numbers"><code class="language-java">String json = &quot;{\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:\&quot;24\&quot;}&quot;;
User user = new User();
JsonReader reader = new JsonReader(new StringReader(json));
reader.beginObject(); // throws IOException
while (reader.hasNext()) {
    String s = reader.nextName();
    switch (s) {
        case &quot;name&quot;:
            user.name = reader.nextString();
            break;
        case &quot;age&quot;:
            user.age = reader.nextInt(); //自动转换
            break;
        case &quot;email&quot;:
            user.email = reader.nextString();
            break;
    }
}
reader.endObject(); // throws IOException
System.out.println(user.name);  // 怪盗kidou
System.out.println(user.age);   // 24
System.out.println(user.email); // ikidou@example.com
</code></pre>
<p>其实自动方式最终都是通过<code>JsonReader</code>来实现的，如果第一个参数是<code>String</code>类型，那么Gson会创建一个<code>StringReader</code>转换成流操作。</p>
<p><figure><img src="media/15561207870200/15713055100739.jpg" alt="" /></figure></p>
<h3><a id="gson%E7%9A%84%E6%B5%81%E5%BC%8F%E5%BA%8F%E5%88%97%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson的流式序列化</h3>
<h4><a id="%E8%87%AA%E5%8A%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自动方式</h4>
<p><figure><img src="media/15561207870200/15713055221921.jpg" alt="" /></figure></p>
<p>所以啊，学会利用IDE的自动完成是多么重要这下知道了吧！<br />
可以看出用红框选中的部分就是我们要找的东西。<br />
提示：<code>PrintStream</code>(System.out) 、<code>StringBuilder</code>、<code>StringBuffer</code>和<code>*Writer</code>都实现了<code>Appendable</code>接口。</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24,&quot;ikidou@example.com&quot;);
gson.toJson(user,System.out); // 写到控制台
</code></pre>
<h4><a id="%E6%89%8B%E5%8A%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>手动方式</h4>
<pre class="line-numbers"><code class="language-java">JsonWriter writer = new JsonWriter(new OutputStreamWriter(System.out));
writer.beginObject() // throws IOException
        .name(&quot;name&quot;).value(&quot;怪盗kidou&quot;)
        .name(&quot;age&quot;).value(24)
        .name(&quot;email&quot;).nullValue() //演示null
        .endObject(); // throws IOException
writer.flush(); // throws IOException
//{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:null}
</code></pre>
<p>提示：除了<code>beginObject</code>、<code>endObject</code>还有<code>beginArray</code>和<code>endArray</code>，两者可以相互嵌套，注意配对即可。<code>beginArray</code>后不可以调用<code>name</code>方法，同样<code>beginObject</code>后在调用<code>value</code>之前必须要调用<code>name</code>方法。</p>
<h3><a id="%E4%BD%BF%E7%94%A8gsonbuilder%E5%AF%BC%E5%87%BAnull%E5%80%BC%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E3%80%81%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用GsonBuilder导出null值、格式化输出、日期时间</h3>
<p>一般情况下<code>Gson</code>类提供的 API已经能满足大部分的使用场景，但我们需要更多更特殊、更强大的功能时，这时候就引入一个新的类 <code>GsonBuilder</code>。<br />
<code>GsonBuilder</code>从名上也能知道是用于构建Gson实例的一个类，要想改变Gson默认的设置必须使用该类配置Gson。</p>
<h4><a id="gsonbuilder%E7%94%A8%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a><strong>GsonBuilder用法</strong></h4>
<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
               //各种配置
               .create(); //生成配置好的Gson
</code></pre>
<p>Gson在默认情况下是不动导出值<code>null</code>的键的，如：</p>
<pre class="line-numbers"><code class="language-java">public class User {
    //省略其它
    public String name;
    public int age;
    public String email;
}
</code></pre>
<pre class="line-numbers"><code class="language-java">Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24);
System.out.println(gson.toJson(user)); //{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24}
</code></pre>
<p>可以看出，<code>email</code>字段是没有在json中出现的，当我们在调试是、需要导出完整的json串时或API接中要求没有值必须用Null时，就会比较有用。</p>
<p>使用方法：</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
        .serializeNulls()
        .create();
User user = new User(&quot;怪盗kidou&quot;, 24);
System.out.println(gson.toJson(user)); //{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:null}
</code></pre>
<h4><a id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E3%80%81%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%8F%8A%E5%85%B6%E5%AE%83%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>格式化输出、日期时间及其它：</h4>
<p>这些都比较简单就不一一分开写了。</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
        //序列化null
        .serializeNulls()
        // 设置日期时间格式，另有2个重载方法
        // 在序列化和反序化时均生效
        .setDateFormat(&quot;yyyy-MM-dd&quot;)
        // 禁此序列化内部类
        .disableInnerClassSerialization()
        //生成不可执行的Json（多了 )]}' 这4个字符）
        .generateNonExecutableJson()
        //禁止转义html标签
        .disableHtmlEscaping()
        //格式化输出
        .setPrettyPrinting()
        .create();
</code></pre>
<p>注意：内部类(Inner Class)和嵌套类(Nested Class)的区别</p>
<h2><a id="gson%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson中的一些注解</h2>
<h3><a id="serializedname%E6%B3%A8%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@SerializedName注解</h3>
<p>该注解能指定该字段在JSON中对应的字段名称</p>
<pre class="line-numbers"><code class="language-java">public class Box {

  @SerializedName(&quot;w&quot;)
  private int width;

  @SerializedName(&quot;h&quot;)
  private int height;

  @SerializedName(&quot;d&quot;)
  private int depth;

  // Methods removed for brevity
}
</code></pre>
<p>也就是说<code>{&quot;w&quot;:10,&quot;h&quot;:20,&quot;d&quot;:30}</code> 这个JSON 字符串能够被解析到上面的width，height和depth字段中。</p>
<h3><a id="expose%E6%B3%A8%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@Expose注解</h3>
<p>该注解能够指定该字段是否能够序列化或者反序列化，默认的是都支持（true）。简单说来就是需要导出的字段上加上@Expose 注解，不导出的字段不加。注意是不导出的不加。</p>
<pre class="line-numbers"><code class="language-java">public class Account {

  @Expose(deserialize = false)
  private String accountNumber;

  @Expose
  private String iban;

  @Expose(serialize = false)
  private String owner;

  @Expose(serialize = false, deserialize = false)
  private String address;

  private String pin;
}
</code></pre>
<p>该注解在使用<code>new Gson()</code> 时是不会发生作用。毕竟最常用的API要最简单，所以该注解必须和<code>GsonBuilder</code>配合使用。需要注意的通过 <code>builder.excludeFieldsWithoutExposeAnnotation()</code>方法使该注解生效。</p>
<pre class="line-numbers"><code class="language-java">final GsonBuilder builder = new GsonBuilder();
builder.excludeFieldsWithoutExposeAnnotation();
final Gson gson = builder.create();
</code></pre>
<h3><a id="since%E5%92%8C-until%E6%B3%A8%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>@Since和@Until注解</h3>
<p>Since代表“自从”，Until 代表”一直到”。它们都是针对该字段生效的版本。比如说<code>@Since(1.2)</code>代表从版本1.2之后才生效，<code>@Until(0.9)</code>代表着在0.9版本之前都是生效的。</p>
<pre class="line-numbers"><code class="language-java">public class SoccerPlayer {

  private String name;

  @Since(1.2)
  private int shirtNumber;

  @Until(0.9)
  private String country;

  private String teamName;

  // Methods removed for brevity
}
</code></pre>
<p>也就是说我们利用方法<code>builder.setVersion(1.0)</code>定义版本1.0，如下：</p>
<pre class="line-numbers"><code class="language-java">final GsonBuilder builder = new GsonBuilder();
    builder.setVersion(1.0);

    final Gson gson = builder.create();

    final SoccerPlayer account = new SoccerPlayer();
    account.setName(&quot;Albert Attard&quot;);
    account.setShirtNumber(10); // Since version 1.2
    account.setTeamName(&quot;Zejtun Corinthians&quot;);
    account.setCountry(&quot;Malta&quot;); // Until version 0.9

    final String json = gson.toJson(account);
    System.out.printf(&quot;Serialised (version 1.0)%n  %s%n&quot;, json);
</code></pre>
<p>由于<code>shirtNumber</code>和<code>country</code>作用版本分别是1.2之后，和0.9之前，所以在这里都不会得到序列化，所以输出结果是：</p>
<pre class="line-numbers"><code class="language-java">Serialised (version 1.0)
  {&quot;name&quot;:&quot;Albert Attard&quot;,&quot;teamName&quot;:&quot;Zejtun Corinthians&quot;}
</code></pre>
<h4><a id="%E5%9F%BA%E4%BA%8E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于访问修饰符</h4>
<p>什么是修饰符? <code>public</code>、<code>static</code> 、<code>final</code>、<code>private</code>、<code>protected</code> 这些就是，所以这种方式也是比较特殊的。使用方式：</p>
<pre class="line-numbers"><code class="language-java">class ModifierSample {
    final String finalField = &quot;final&quot;;
    static String staticField = &quot;static&quot;;
    public String publicField = &quot;public&quot;;
    protected String protectedField = &quot;protected&quot;;
    String defaultField = &quot;default&quot;;
    private String privateField = &quot;private&quot;;
}
</code></pre>
<p>使用<code>GsonBuilder.excludeFieldsWithModifiers</code>构建gson,支持<code>int</code>形的可变参数，值由<code>java.lang.reflect.Modifier</code>提供，下面的程序排除了<code>privateField</code> 、 <code>finalField</code> 和<code>staticField</code> 三个字段。</p>
<pre class="line-numbers"><code class="language-java">ModifierSample modifierSample = new ModifierSample();
Gson gson = new GsonBuilder()
        .excludeFieldsWithModifiers(Modifier.FINAL, Modifier.STATIC, Modifier.PRIVATE)
        .create();
System.out.println(gson.toJson(modifierSample));
// 结果：{&quot;publicField&quot;:&quot;public&quot;,&quot;protectedField&quot;:&quot;protected&quot;,&quot;defaultField&quot;:&quot;default&quot;}
</code></pre>
<p>到此为止，Gson提供的所有注解就还有一个<code>@JsonAdapter</code>没有介绍了，而<code>@JsonAdapter</code>将和<code>TypeAdapter</code>将作为该系列第4篇也是最后一篇文章的主要内容。</p>
<h4><a id="%E5%9F%BA%E4%BA%8E%E7%AD%96%E7%95%A5%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基于策略（自定义规则）</h4>
<p>上面介绍的了3种排除字段的方法，说实话我除了@Expose以外，其它的都是只在Demo用上过，用得最多的就是马上要介绍的自定义规则，好处是功能强大、灵活，缺点是相比其它3种方法稍麻烦一点，但也仅仅只是想对其它3种稍麻烦一点而已。</p>
<p>基于策略是利用Gson提供的<code>ExclusionStrategy</code>接口，同样需要使用<code>GsonBuilder</code>,相关API 2个，分别是<code>addSerializationExclusionStrategy</code> 和<code>addDeserializationExclusionStrategy</code> 分别针对序列化和反序化时。这里以序列化为例。<br />
例如：</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
        .addSerializationExclusionStrategy(new ExclusionStrategy() {
            @Override
            public boolean shouldSkipField(FieldAttributes f) {
                // 这里作判断，决定要不要排除该字段,return true为排除
                if (&quot;finalField&quot;.equals(f.getName())) return true; //按字段名排除
                Expose expose = f.getAnnotation(Expose.class); 
                if (expose != null &amp;&amp; expose.deserialize() == false) return true; //按注解排除
                return false;
            }
            @Override
            public boolean shouldSkipClass(Class&lt;?&gt; clazz) {
                // 直接排除某个类 ，return true为排除
                return (clazz == int.class || clazz == Integer.class);
            }
        })
        .create();
</code></pre>
<h2><a id="pojo%E4%B8%8Ejson%E7%9A%84%E5%AD%97%E6%AE%B5%E6%98%A0%E5%B0%84%E8%A7%84%E5%88%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>POJO与JSON的字段映射规则</h2>
<p>还是之前User的例子，已经去除所有注解：</p>
<pre class="line-numbers"><code class="language-java">User user = new User(&quot;怪盗kidou&quot;, 24);
user.emailAddress = &quot;ikidou@example.com&quot;;
</code></pre>
<p><code>GsonBuilder</code>提供了<code>FieldNamingStrategy</code>接口和<code>setFieldNamingPolicy</code>和<code>setFieldNamingStrategy</code> 两个方法。</p>
<p><strong>默认实现</strong><br />
<code>GsonBuilder.setFieldNamingPolicy</code> 方法与Gson提供的另一个枚举类<code>FieldNamingPolicy</code>配合使用，该枚举类提供了5种实现方式分别为：</p>
<table>
<thead>
<tr>
<th>FieldNamingPolicy</th>
<th>结果（仅输出emailAddress字段）</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDENTITY</td>
<td>{&quot;emailAddress&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
<tr>
<td>LOWER_CASE_WITH_DASHES</td>
<td>{&quot;email-address&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
<tr>
<td>LOWER_CASE_WITH_UNDERSCORES</td>
<td>{&quot;email_address&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
<tr>
<td>UPPER_CAMEL_CASE</td>
<td>{&quot;EmailAddress&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
<tr>
<td>UPPER_CAMEL_CASE_WITH_SPACES</td>
<td>{&quot;Email Address&quot;:&quot;<a href="mailto:ikidou@example.com">ikidou@example.com</a>&quot;}</td>
</tr>
</tbody>
</table>
<p><strong>自定义实现</strong><br />
<code>GsonBuilder.setFieldNamingStrategy</code> 方法需要与Gson提供的<code>FieldNamingStrategy</code>接口配合使用，用于实现将POJO的字段与JSON的字段相对应。上面的<code>FieldNamingPolicy</code>实际上也实现了<code>FieldNamingStrategy</code>接口，也就是说<code>FieldNamingPolicy</code>也可以使用<code>setFieldNamingStrategy</code>方法。</p>
<p>用法：</p>
<pre class="line-numbers"><code class="language-java">Gson gson = new GsonBuilder()
        .setFieldNamingStrategy(new FieldNamingStrategy() {
            @Override
            public String translateName(Field f) {
                //实现自己的规则
                return null;
            }
        })
        .create();
</code></pre>
<p><strong>注意：</strong> <code>@SerializedName</code>注解拥有最高优先级，在加有<code>@SerializedName</code>注解的字段上<code>FieldNamingStrategy</code>不生效！</p>
<h2><a id="gson%E5%BA%8F%E5%88%97%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson 序列化</h2>
<p>英文Serialize和format都对应序列化，这是一个Java对象到JSON字符串的过程。接着看一个例子,下面分别是java类和以及我们期望的JSON数据：</p>
<pre class="line-numbers"><code class="language-java">public class Book {
  private String[] authors;
  private String isbn10;
  private String isbn13;
  private String title;
  //为了代码简洁，这里移除getter和setter方法等
}
</code></pre>
<pre class="line-numbers"><code class="language-json">{
  &quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,
  &quot;isbn-10&quot;: &quot;032133678X&quot;,
  &quot;isbn-13&quot;: &quot;978-0321336781&quot;,
  &quot;authors&quot;: [
    &quot;Joshua Bloch&quot;,
    &quot;Neal Gafter&quot;
  ]
}
</code></pre>
<p>你肯定能发现JSON数据中出现了<code>isbn-10</code>和<code>isbn-13</code>, 我们怎么把字段数据<code>isbn10</code>和<code>isbn13</code>转化为JSON数据需要的<code>isbn-10</code>和<code>isbn-13</code>,Gson当然为我们提供了对应的解决方案</p>
<h3><a id="%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%881" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>序列化方案1</h3>
<p>采用上面提到的<code>@SerializedName</code>注解。</p>
<pre class="line-numbers"><code class="language-java">public class Book {
  private String[] authors;

  @SerializedName(&quot;isbn-10&quot;)
  private String isbn10;

  @SerializedName(&quot;isbn-13&quot;)
  private String isbn13;
  private String title;
  //为了代码简洁，这里移除getter和setter方法等
}
</code></pre>
<h3><a id="%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%882" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>序列化方案2</h3>
<p>利用<code>JsonSerializer</code>类</p>
<pre class="line-numbers"><code class="language-java">public class BookSerialiser implements JsonSerializer {
    @Override
    public JsonElement serialize(final Book book, final Type typeOfSrc, final JsonSerializationContext context) {

        final JsonObject jsonObject = new JsonObject();
        jsonObject.addProperty(&quot;title&quot;, book.getTitle());
        jsonObject.addProperty(&quot;isbn-10&quot;, book.getIsbn10());
        jsonObject.addProperty(&quot;isbn-13&quot;, book.getIsbn13());

        final JsonArray jsonAuthorsArray = new JsonArray();
        for (final String author : book.getAuthors()) {
            final JsonPrimitive jsonAuthor = new JsonPrimitive(author);
            jsonAuthorsArray.add(jsonAuthor);
        }
        jsonObject.add(&quot;authors&quot;, jsonAuthorsArray);

        return jsonObject;
    }
}
</code></pre>
<p>下面对序列化过程进行大致的分析：</p>
<ul>
<li>JsonSerializer是一个接口，我们需要提供自己的实现，来满足自己的序列化要求。</li>
</ul>
<pre class="line-numbers"><code class="language-java">public interface JsonSerializer&lt;T&gt; {

/**
 *Gson 会在解析指定类型T数据的时候触发当前回调方法进行序列化
 *
 * @param T 需要转化为Json数据的类型，对应上面的Book
 * @return 返回T指定的类对应JsonElement
 */
public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context);
}
</code></pre>
<ul>
<li>首先在上面的代码中，我们需要创建的是一个JsonElement对象，这里对应Book是一个对象，所以创建一个JsonObject类型。<br />
<code>final JsonObject jsonObject = new JsonObject();</code></li>
<li>然后我们将相应字段里面的数据填充到jsonObject里面。</li>
</ul>
<pre class="line-numbers"><code class="language-java">jsonObject.addProperty...
jsonObject.add...
</code></pre>
<ul>
<li>下面是jsonObject中的添加方法：<code>jsonObj.add(String property,JsonElement value)</code></li>
<li>所以最后返回的还是一个JsonElement 类型，这里对应的是jsonObject。完成了javaBean-&gt;JSON数据的转化。</li>
<li>同样需要配置,</li>
</ul>
<pre class="line-numbers"><code class="language-java">// Configure GSON
  final GsonBuilder gsonBuilder = new GsonBuilder();
  gsonBuilder.registerTypeAdapter(Book.class, new BookSerialiser());
  gsonBuilder.setPrettyPrinting();
  final Gson gson = gsonBuilder.create();

  final Book javaPuzzlers = new Book();
  javaPuzzlers.setTitle(&quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;);
  javaPuzzlers.setIsbn10(&quot;032133678X&quot;);
  javaPuzzlers.setIsbn13(&quot;978-0321336781&quot;);
  javaPuzzlers.setAuthors(new String[] { &quot;Joshua Bloch&quot;, &quot;Neal Gafter&quot; });

  // Format to JSON
  final String json = gson.toJson(javaPuzzlers);
  System.out.println(json);
</code></pre>
<p>，这里对应的是<code>gsonBuilder.registerTypeAdapter(Book.class, new BookSerialiser())</code>方法进行JsonSerializer的配置。在上面例子中，通过调用<code>gsonBuilder.setPrettyPrinting();</code>方法还告诉了 Gson 对生成的 JSON 对象进行格式化</p>
<h2><a id="gson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson 反序列化</h2>
<p>英文<code>parse</code>和<code>deserialise</code>对应反序列化，这是一个字符串转换成Java对象的过程。我们同样采用上面一小节的代码片段，只不过现在我们需要做的是将：</p>
<pre class="line-numbers"><code class="language-json">{
  &quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,
  &quot;isbn-10&quot;: &quot;032133678X&quot;,
  &quot;isbn-13&quot;: &quot;978-0321336781&quot;,
  &quot;authors&quot;: [
    &quot;Joshua Bloch&quot;,
    &quot;Neal Gafter&quot;
  ]
}
</code></pre>
<p>转化为对应的Book实体类。</p>
<h3><a id="%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%881" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>反序列化方案1</h3>
<p>利用<code>@SerializedName</code> 注解也就是说我们的实体类Book.java可以这么写：</p>
<pre class="line-numbers"><code class="language-java">public class Book {
  private String[] authors;

  @SerializedName(&quot;isbn-10&quot;)
  private String isbn10;

  @SerializedName(value = &quot;isbn-13&quot;, alternate = {&quot;isbn13&quot;,&quot;isbn.13&quot;})
  private String isbn13;
  private String title;
  //为了代码简洁，这里移除getter和setter方法等
}
</code></pre>
<blockquote>
<p>可以看到这里我们在<code>@SerializedName</code>  注解使用了一个<code>value</code>, <code>alternate</code>字段,<code>value</code>也就是默认的字段，对序列化和反序列化都有效，<code>alternate</code>只有反序列化才有效果。也就是说一般服务器返回给我们JSON数据的时候可能同样的一个图片，表示&quot;image&quot;,&quot;img&quot;,&quot;icon&quot;等备选属性名，我们利用<code>@SerializedName</code>  中的<code>alternate</code>字段就能解决这个问题，全部转化为我们实体类中的图片字段。</p>
</blockquote>
<h3><a id="%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%A1%882" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>反序列化方案2</h3>
<p>我们在序列化的时候使用的是<code>JsonSerialize</code> ,这里对应使用<code>JsonDeserializer</code>我们将解析到的json数据传递给Book的setter方法即可。</p>
<pre class="line-numbers"><code class="language-java">public class BookDeserializer implements JsonDeserializer&lt;Book&gt; {

  @Override
  public Book deserialize(final JsonElement json, final Type typeOfT, final JsonDeserializationContext context)
      throws JsonParseException {
    final JsonObject jsonObject = json.getAsJsonObject();

    final JsonElement jsonTitle = jsonObject.get(&quot;title&quot;);
    final String title = jsonTitle.getAsString();

    final String isbn10 = jsonObject.get(&quot;isbn-10&quot;).getAsString();
    final String isbn13 = jsonObject.get(&quot;isbn-13&quot;).getAsString();

    final JsonArray jsonAuthorsArray = jsonObject.get(&quot;authors&quot;).getAsJsonArray();
    final String[] authors = new String[jsonAuthorsArray.size()];
    for (int i = 0; i &lt; authors.length; i++) {
      final JsonElement jsonAuthor = jsonAuthorsArray.get(i);
      authors[i] = jsonAuthor.getAsString();
    }

    final Book book = new Book();
    book.setTitle(title);
    book.setIsbn10(isbn10);
    book.setIsbn13(isbn13);
    book.setAuthors(authors);
    return book;
  }
}
</code></pre>
<p>和Gson序列化章节一样，我们这里接着分析我们是怎么将JSON数据解析（反序列化）为实体类的：</p>
<ul>
<li>因为我们可以发现上面的JSON数据是一个<code>{}</code>大括号包围的，也就意味着这是一个Json对象。所以首先我们通过<code>final JsonObject jsonObject = json.getAsJsonObject();</code>将我们的JsonElement转化为JsonObject</li>
<li>通过<code>jsonObject.get(&quot;xxx&quot;).getAsString()</code>的形式获取相应String的值</li>
<li>通过<code>jsonObject.get(&quot;xx&quot;).getAsJsonArray();</code>获取相应的json数组，并遍历出其中的相应字段值</li>
<li>通过setter方法，将获取到的值设置给Book类。</li>
<li>最终返回的是 Book的对象实例。完成了JSON-&gt;javaBean的转化</li>
<li>同样需要配置</li>
<li>关于从本地流中读取Json数据可以使用  <code>InputStreamReader</code>完成</li>
</ul>
<pre class="line-numbers"><code class="language-java">// Configure Gson
  GsonBuilder gsonBuilder = new GsonBuilder();
  gsonBuilder.registerTypeAdapter(Book.class, new BookDeserializer());
  Gson gson = gsonBuilder.create();

  // The JSON data
  try(Reader reader = new InputStreamReader(Main.class.getResourceAsStream(&quot;/part1/sample.json&quot;), &quot;UTF-8&quot;)){

    // Parse JSON to Java
    Book book = gson.fromJson(reader, Book.class);
    System.out.println(book);
  }
</code></pre>
<h2><a id="typeadapter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeAdapter</h2>
<h3><a id="typeadapter%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeAdapter介绍</h3>
<p>之前在上一篇文中提到的<code>JsonSerializer</code>和<code>JsonDeserializer</code>解析的时候都利用到了一个中间件-<code>JsonElement</code>，比如下方的序列化过程。可以看到我们在把Java对象转化为JSON字符串的时候都会用到这个中间件<code>JsonElement</code></p>
<p><figure><img src="media/15561207870200/15713055343313.jpg" alt="" /></figure></p>
<p>而<code>TypeAdapter</code>的使用正是去掉了这个中间层，直接用流来解析数据，极大程度上提高了解析效率。</p>
<blockquote>
<p>New applications should prefer TypeAdapter, whose streaming API is more efficient than this interface’s tree API.应用中应当尽量使用<code>TypeAdapter</code>，它流式的API相比于之前的树形解析API将会更加高效。<br />
<code>TypeAdapter</code>作为一个抽象类提供两个抽象方法。分别是<code>write()</code>和<code>read()</code>方法,也对应着序列化和反序列化,其它的方法都是<code>final</code>方法并最终调用这两个抽象方法。</p>
</blockquote>
<p>如下图所示：</p>
<p><figure><img src="media/15561207870200/15713055475704.jpg" alt="" /></figure></p>
<p>下面就让我们来一起使用和了解TypeAdapter吧。</p>
<h3><a id="typeadapter%E5%AE%9E%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeAdapter实例</h3>
<p>为了便于理解，这里还是统 一 一 下，采用和上面一篇文章同样的例子。<br />
<code>Book.java</code>实体类：</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;

public class Book {

  private String[] authors;
  private String isbn;
  private String title;

//为了代码简洁，这里移除getter和setter方法等
}
</code></pre>
<p>直接贴代码，具体序列化和反序列化的<code>TypeAdapter</code>类，这里是<code>BookTypeAdapter.java</code>：</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;
import java.io.IOException;
import org.apache.commons.lang3.StringUtils;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

public class BookTypeAdapter extends TypeAdapter {

  @Override
  public Book read(final JsonReader in) throws IOException {
    final Book book = new Book();

    in.beginObject();
    while (in.hasNext()) {
      switch (in.nextName()) {
      case &quot;isbn&quot;:
        book.setIsbn(in.nextString());
        break;
      case &quot;title&quot;:
        book.setTitle(in.nextString());
        break;
      case &quot;authors&quot;:
        book.setAuthors(in.nextString().split(&quot;;&quot;));
        break;
      }
    }
    in.endObject();

    return book;
  }

  @Override
  public void write(final JsonWriter out, final Book book) throws IOException {
    out.beginObject();
    out.name(&quot;isbn&quot;).value(book.getIsbn());
    out.name(&quot;title&quot;).value(book.getTitle());
    out.name(&quot;authors&quot;).value(StringUtils.join(book.getAuthors(), &quot;;&quot;));
    out.endObject();
  }
}
</code></pre>
<p>同样这里设置<code>TypeAdapter</code>之后还是需要配置（注册）,可以注意到的是<code>gsonBuilder.registerTypeAdapter(xxx)</code>方法进行注册在我们之前的<code>JsonSerializer</code>和<code>JsonDeserializer</code>中也有使用：</p>
<pre class="line-numbers"><code class="language-java">final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(Book.class, new BookTypeAdapter());
    final Gson gson = gsonBuilder.create();
</code></pre>
<p>下面对两个write方法和read方法进行分别的阐述：</p>
<h4><a id="typeadapter%E4%B8%AD%E7%9A%84write%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeAdapter中的write方法</h4>
<p><code>write()</code>方法中会传入<code>JsonWriter</code>，和需要被序列化的<code>Book</code>对象的实例，采用和<code>PrintStream</code>类似的方式 写入到<code>JsonWriter</code>中。</p>
<pre class="line-numbers"><code class="language-java">  @Override
  public void write(final JsonWriter out, final Book book) throws IOException {
    out.beginObject();
    out.name(&quot;isbn&quot;).value(book.getIsbn());
    out.name(&quot;title&quot;).value(book.getTitle());
    out.name(&quot;authors&quot;).value(StringUtils.join(book.getAuthors(), &quot;;&quot;));
    out.endObject();
  }
</code></pre>
<p>下面是上面代码的步骤：</p>
<ul>
<li><code>out.beginObject()</code>产生<code>{</code>,如果我们希望产生的是一个数组对象，对应的使用<code>beginArray()</code></li>
<li><code>out.name(&quot;isbn&quot;).value(book.getIsbn()); out.name(&quot;title&quot;).value(book.getTitle());</code>分别获取book中的isbn和title字段并且设置给Json对象中的isbn和title。也就是说上面这段代码，会在json对象中产生：<code>&quot;isbn&quot;: &quot;978-0321336781&quot;,&quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,</code></li>
<li><code>out.name(&quot;authors&quot;).value(StringUtils.join(book.getAuthors(), &quot;;&quot;));</code>则会对应着：<code>&quot;authors&quot;: &quot;Joshua Bloch;Neal Gafter&quot;</code></li>
<li>同理  <code>out.endObject()</code>则对应着<code>}</code></li>
<li>那么整个上面的代码也就会产生JSON对象：<code>{&quot;isbn&quot;: &quot;978-0321336781&quot;,&quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,&quot;authors&quot;: &quot;Joshua Bloch;Neal Gafter&quot;}</code></li>
</ul>
<blockquote>
<p>这里需要注意的是，如果没有调用 <code>out.endObject()</code>产生<code>}</code>,那么你的项目会报出</p>
</blockquote>
<pre class="line-numbers"><code class="language-java">JsonSyntaxException`错误`Exception in thread &quot;main&quot; com.google.gson.JsonSyntaxException: java.io.EOFException: End of input at line 4 column 40  at com.google.gson.Gson.fromJson(Gson.java:813)  at com.google.gson.Gson.fromJson(Gson.java:768)  at com.google.gson.Gson.fromJson(Gson.java:717)  at com.google.gson.Gson.fromJson(Gson.java:689)  at com.javacreed.examples.gson.part1.Main.main(Main.java:41)Caused by: java.io.EOFException: End of input at line 4 column 40  at com.google.gson.stream.JsonReader.nextNonWhitespace(JsonReader.java:1377)  at com.google.gson.stream.JsonReader.doPeek(JsonReader.java:471)  at com.google.gson.stream.JsonReader.hasNext(JsonReader.java:403)  at com.javacreed.examples.gson.part1.BookTypeAdapter.read(BookTypeAdapter.java:33)  at com.javacreed.examples.gson.part1.BookTypeAdapter.read(BookTypeAdapter.java:1)  at com.google.gson.Gson.fromJson(Gson.java:803)  ... 4 more
</code></pre>
<h4><a id="typeadapter%E4%B8%AD%E7%9A%84read%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeAdapter中的read方法</h4>
<p><code>read()</code>方法将会传入一个<code>JsonReader</code>对象实例并返回反序列化的对象。</p>
<pre class="line-numbers"><code class="language-java">  @Override
  public Book read(final JsonReader in) throws IOException {
    final Book book = new Book();

    in.beginObject();
    while (in.hasNext()) {
      switch (in.nextName()) {
      case &quot;isbn&quot;:
        book.setIsbn(in.nextString());
        break;
      case &quot;title&quot;:
        book.setTitle(in.nextString());
        break;
      case &quot;authors&quot;:
        book.setAuthors(in.nextString().split(&quot;;&quot;));
        break;
      }
    }
    in.endObject();

    return book;
  }
</code></pre>
<p>下面是这段代码的步骤：<br />
同样是通过<code>in.beginObject();</code>和<code>in.endObject();</code>对应解析<code>{</code>,<code>}</code><br />
通过<code>while (in.hasNext()) {switch (in.nextName()) {}}</code>来完成每个<code>JsonElement</code>的遍历,并且通过<code>switch...case</code>的方法获取Json对象中的键值对。并通过我们<code>Book实体类</code>的<code>Setter</code>方法进行设置。</p>
<pre class="line-numbers"><code class="language-java">while (in.hasNext()) {    
    switch (in.nextName()) {    
        case &quot;isbn&quot;:      
            book.setIsbn(in.nextString());      
            break;    
        case &quot;title&quot;:      
            book.setTitle(in.nextString());      
            break;    
        case &quot;authors&quot;:      
            book.setAuthors(in.nextString().split(&quot;;&quot;));      
            break;    
    }  
}
</code></pre>
<blockquote>
<p>同样需要注意的是,如果没有执行<code>in.endObject()</code>，将会出现<code>JsonIOException</code>的错误：</p>
</blockquote>
<pre class="line-numbers"><code class="language-java">Exception in thread &quot;main&quot; com.google.gson.JsonIOException: JSON document was not fully consumed.  at   com.google.gson.Gson.assertFullConsumption(Gson.java:776)  at com.google.gson.Gson.fromJson(Gson.java:769)  at com.google.gson.Gson.fromJson(Gson.java:717)  at com.google.gson.Gson.fromJson(Gson.java:689)  at com.javacreed.examples.gson.part1.Main.main(Main.java:41)
</code></pre>
<p>下面给出使用<code>TypeAdapter</code>的完整代码：</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;

import java.io.IOException;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(Book.class, new BookTypeAdapter());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final Book book = new Book();
    book.setAuthors(new String[] { &quot;Joshua Bloch&quot;, &quot;Neal Gafter&quot; });
    book.setTitle(&quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;);
    book.setIsbn(&quot;978-0321336781&quot;);

    final String json = gson.toJson(book);
    System.out.println(&quot;Serialised&quot;);
    System.out.println(json);

    final Book parsedBook = gson.fromJson(json, Book.class);
    System.out.println(&quot;\nDeserialised&quot;);
    System.out.println(parsedBook);
  }
}
</code></pre>
<p>对应的编译结果为：</p>
<pre class="line-numbers"><code class="language-java">Serialised
{
  &quot;isbn&quot;: &quot;978-0321336781&quot;,
  &quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,
  &quot;authors&quot;: &quot;Joshua Bloch;Neal Gafter&quot;
}

Deserialised
Java Puzzlers: Traps, Pitfalls, and Corner Cases [978-0321336781]
Written by:
  &gt;&gt; Joshua Bloch
  &gt;&gt; Neal Gafter
</code></pre>
<h3><a id="typeadapter%E5%A4%84%E7%90%86%E7%AE%80%E6%B4%81%E7%9A%84json%E6%95%B0%E6%8D%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeAdapter处理简洁的JSON数据</h3>
<p>为了简化JSON数据，其实我们上面的JSON数据可以这么写：</p>
<pre class="line-numbers"><code class="language-json">[&quot;978-0321336781&quot;,&quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,&quot;Joshua Bloch&quot;,&quot;Neal Gafter&quot;]
</code></pre>
<p>可以看到的是，这样采用的直接是值的形式。当然这样操作简化了JSON数据但是可能就让整个数据的稳定性下降了许多的，你需要按照一定的顺序来解析这个数据。对应的<code>write</code>和<code>read</code>方法如下：</p>
<pre class="line-numbers"><code class="language-java">  @Override
  public void write(final JsonWriter out, final Book book) throws IOException {
    out.beginArray();
    out.value(book.getIsbn());
    out.value(book.getTitle());
    for (final String author : book.getAuthors()) {
      out.value(author);
    }
    out.endArray();
  }
</code></pre>
<pre class="line-numbers"><code class="language-java">  @Override
  public Book read(final JsonReader in) throws IOException {
    final Book book = new Book();

    in.beginArray();
    book.setIsbn(in.nextString());
    book.setTitle(in.nextString());
    final List authors = new ArrayList&lt;&gt;();
    while (in.hasNext()) {
      authors.add(in.nextString());
    }
    book.setAuthors(authors.toArray(new String[authors.size()]));
    in.endArray();

    return book;
  }
</code></pre>
<p>这里的解析原理和上面一致，不再赘述。</p>
<h3><a id="typeadapter%E8%A7%A3%E6%9E%90%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TypeAdapter解析内置对象</h3>
<p>（这里将nested objects翻译为内置对象，其实就是在Book类）<br />
这里对上面的Book实体类进行修改如下，添加Author作者类，每本书可以有多个作者。</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part3;

public class Book {

  private Author[] authors;
  private String isbn;
  private String title;

class Author {

  private int id;
  private String name;

//为了代码简洁，这里移除getter和setter方法等
}
//为了代码简洁，这里移除getter和setter方法等
}
</code></pre>
<p>这里提供JSON对象，</p>
<pre class="line-numbers"><code class="language-java">{
  &quot;isbn&quot;: &quot;978-0321336781&quot;,
  &quot;title&quot;: &quot;Java Puzzlers: Traps, Pitfalls, and Corner Cases&quot;,
  &quot;authors&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;name&quot;: &quot;Joshua Bloch&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;Neal Gafter&quot;
    }
  ]
}
</code></pre>
<p>下面分别展示write和read方法：</p>
<pre class="line-numbers"><code class="language-java">  @Override
  public void write(final JsonWriter out, final Book book) throws IOException {
    out.beginObject();
    out.name(&quot;isbn&quot;).value(book.getIsbn());
    out.name(&quot;title&quot;).value(book.getTitle());
    out.name(&quot;authors&quot;).beginArray();
    for (final Author author : book.getAuthors()) {
      out.beginObject();
      out.name(&quot;id&quot;).value(author.getId());
      out.name(&quot;name&quot;).value(author.getName());
      out.endObject();
    }
    out.endArray();
    out.endObject();
  }
</code></pre>
<pre class="line-numbers"><code class="language-java"> @Override
  public Book read(final JsonReader in) throws IOException {
    final Book book = new Book();

    in.beginObject();
    while (in.hasNext()) {
      switch (in.nextName()) {
      case &quot;isbn&quot;:
        book.setIsbn(in.nextString());
        break;
      case &quot;title&quot;:
        book.setTitle(in.nextString());
        break;
      case &quot;authors&quot;:
        in.beginArray();
        final List authors = new ArrayList&lt;&gt;();
        while (in.hasNext()) {
          in.beginObject();
          final Author author = new Author();
          while (in.hasNext()) {
            switch (in.nextName()) {
            case &quot;id&quot;:
              author.setId(in.nextInt());
              break;
            case &quot;name&quot;:
              author.setName(in.nextString());
              break;
            }
          }
          authors.add(author);
          in.endObject();
        }
        book.setAuthors(authors.toArray(new Author[authors.size()]));
        in.endArray();
        break;
      }
    }
    in.endObject();

    return book;
  }
</code></pre>
<h2><a id="gson%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Gson性能分析</h2>
<p>首先来看看我们提供一个大一点的数据来论证下面一些方法的优缺点。 这里提供类<code>LargeData.java</code>,并分为四个部分进行内存消耗的分析：</p>
<pre class="line-numbers"><code class="language-java">public class LargeData {

  private long[] numbers;

  public void create(final int length) {
    numbers = new long[length];
    for (int i = 0; i &lt; length; i++) {
      numbers[i] = i;
    }
  }

  public long[] getNumbers() {
    return numbers;
  }

}
</code></pre>
<h3><a id="%E7%AC%AC1%E9%83%A8%E5%88%86-jsonserializer%E7%9A%84%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第1部分 JsonSerializer的直接使用</h3>
<p>看看下面的<code>JsonSerializer</code>:</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;

import java.lang.reflect.Type;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class LargeDataSerialiser implements JsonSerializer&lt;LargeData&gt; {

  @Override
  public JsonElement serialize(final LargeData data, final Type typeOfSrc, final JsonSerializationContext context) {
    final JsonArray jsonNumbers = new JsonArray();
    for (final long number : data.getNumbers()) {
      jsonNumbers.add(new JsonPrimitive(number));
    }

    final JsonObject jsonObject = new JsonObject();
    jsonObject.add(&quot;numbers&quot;, jsonNumbers);
    return jsonObject;
  }
}
</code></pre>
<p>上面的代码实现了从<strong>java对象&gt;转化&gt;JSON数组</strong>的序列化过程。下面的代码实现了配置和初始化的过程，被写入文件。这里可以看到的是对<code>LargeData</code>初始化了<code>10485760</code>个元素：</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part1;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final String json = gson.toJson(data);

    final File dir = new File(&quot;target/part1&quot;);
    dir.mkdirs();

    try (PrintStream out = new PrintStream(new File(dir, &quot;output.json&quot;), &quot;UTF-8&quot;)) {
      out.println(json);
    }

    System.out.println(&quot;Done&quot;);
  }
}
</code></pre>
<p>这个例子实现了创建java对象并且转化为JSON字符串并写入文件的整个过程。下面的图标展示了内存的消耗情况：</p>
<p><figure><img src="media/15561207870200/15713055592610.jpg" alt="" /></figure></p>
<p>上面的的LargeData在这里会消耗89MB的内存，从java对象转化为JSON字符串的过程将会消耗大概16s的时间并且需要超过1GB的内存。也就是说，序列化1MB的数据我们需要大约11MB的工作空间。1：11的确实是一个不小的比列。下面的 图片会展示整个过程的几个阶段。</p>
<p><figure><img src="media/15561207870200/15713055723682.jpg" alt="" /></figure></p>
<p>可以看到的是，这里有四个方块分别代表不同的阶段，（但是IO 缓冲区并没有在这里得到使用，所以以灰色进行标注。）整个过程从java对象（蓝色方块），然后由<code>LargeDataSerialiser</code>类创建的JSONElement对象（红色方块），然后这些临时的对象又被转化为JSON 字符串（绿色方块），上面的示例代码使用<code>PrintStream</code>将内容输出到文件中并没有使用任何缓冲区。<br />
完成了第1部分的分析，接下来下面的分析流程是一样的：</p>
<h3><a id="%E7%AC%AC2%E9%83%A8%E5%88%86-typeadapter%E7%9A%84%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第2 部分 TypeAdapter的直接使用</h3>
<p>之前的系列文章中都对Gson基础的使用进行了很好的讲解，可以回顾一下。<br />
<code>TypeAdapter</code>相比 于上面的方法，并没有使用JSONElement对象，而是直接将Java对象啊转化为了JSON对象。</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part2;

import java.io.IOException;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

public class LargeDataTypeAdapter extends TypeAdapter&lt;LargeData&gt; {

  @Override
  public LargeData read(final JsonReader in) throws IOException {
    throw new UnsupportedOperationException(&quot;Coming soon&quot;);
  }

  @Override
  public void write(final JsonWriter out, final LargeData data) throws IOException {
    out.beginObject();
    out.name(&quot;numbers&quot;);
    out.beginArray();
    for (final long number : data.getNumbers()) {
      out.value(number);
    }
    out.endArray();
    out.endObject();
  }
}
</code></pre>
<p>同样会需要配置，这里主要使用的方法是<code>gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());</code>：</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part2;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final String json = gson.toJson(data);

    final File dir = new File(&quot;target/part2&quot;);
    dir.mkdirs();

    try (PrintStream out = new PrintStream(new File(dir, &quot;output.json&quot;), &quot;UTF-8&quot;)) {
      out.println(json);
    }

    System.out.println(&quot;Done&quot;);
  }
}
</code></pre>
<p>上面的代码完成的是从<strong>java对象 &gt;转化&gt;JSON 字符串</strong>并最终写入文件的过程。看看下面的性能分析图表：</p>
<p><figure><img src="media/15561207870200/15713055833702.jpg" alt="" /></figure></p>
<p>和最初的那个方法一样，这里的LargeData对象将会需要89MB的内存，从java对象转化为JSON字符串的过程需要消耗4s的时间，大概650MB的内存。也就是说，序列化1MB的数据，大概需要7.5MB的内存空间。相比于之前的第一种JsonSerializer方法，这里减少了接近一半的内存消耗。同样的，来看看这个方法的几个过程：</p>
<p><figure><img src="media/15561207870200/15713055920153.jpg" alt="" /></figure></p>
<p>这里的序列化过程主要有两个阶段，相比于之前的<code>JSONSerializer</code>的序列化过程，这里没有了转化为JSONElement的过程，也就完成了内存消耗的减少。</p>
<h3><a id="%E7%AC%AC3%E9%83%A8%E5%88%86-typeadapter%E7%9A%84%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第3部分 TypeAdapter的流式处理</h3>
<p>下面的代码，我们使用上面同样的TypeAdapter，只不过我们直接在main()方法中修改Gson的用法，以流的形式进行输出。</p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part3;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataTypeAdapter());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final File dir = new File(&quot;target/part3&quot;);
    dir.mkdirs();

    try (BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(dir,
        &quot;output.json&quot;)), &quot;UTF-8&quot;))) {
      gson.toJson(data, out);
    }

    System.out.println(&quot;Done&quot;);
  }
}
</code></pre>
<p>这个例子同样是将java对象转化为JSON字符串并且输出，也来看看下面的性能分析图表：</p>
<p><figure><img src="media/15561207870200/15713056023643.jpg" alt="" /></figure></p>
<p>可以看到的是同样的最初产生的数据是89MB,序列化过程将java对象转化为JSON字符串花了大概三秒钟的时间，消耗大概160MB的内存。也就是说序列化1MB的数据我们需要大概2MB的内存空间。相比于之前的两种方法，有了很大的改进。</p>
<p><figure><img src="media/15561207870200/15713056123242.jpg" alt="" /></figure></p>
<p>这个方法同样的是使用了两个阶段。不过在上面一个示例中的绿色方块部分在这里没有使用，这里直接完成了java对象到IO 缓冲区的转化并写入文件。<br />
虽然这里并不是Gson的关系，但是我们使用Gson的方法极大的减少了内存消耗，所以说在使用开源库的时候，能够正确高效的使用API也显得尤为重要。</p>
<h3><a id="%E7%AC%AC4%E9%83%A8%E5%88%86-jsonserializer%E7%9A%84%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第4部分 JsonSerializer 的流式处理</h3>
<p>同样的使用第一个例子中的JsonSerializer，这里的配置需要注意的是<code>gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser());</code></p>
<pre class="line-numbers"><code class="language-java">package com.javacreed.examples.gson.part4;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

public class Main {
  public static void main(final String[] args) throws IOException {
    // Configure GSON
    final GsonBuilder gsonBuilder = new GsonBuilder();
    gsonBuilder.registerTypeAdapter(LargeData.class, new LargeDataSerialiser());
    gsonBuilder.setPrettyPrinting();

    final Gson gson = gsonBuilder.create();

    final LargeData data = new LargeData();
    data.create(10485760);

    final File dir = new File(&quot;target/part4&quot;);
    dir.mkdirs();

    try (BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(dir,
        &quot;output.json&quot;)), &quot;UTF-8&quot;))) {
      gson.toJson(data, out);
    }

    System.out.println(&quot;Done&quot;);
  }
}
</code></pre>
<p>经过前面的分析，我们这里也可以这道这里主要分为三个阶段，下面提供性能分析图和JSONSerializer的阶段流程图：</p>
<p><figure><img src="media/15561207870200/15713056224094.jpg" alt="" /></figure></p>
<p><figure><img src="media/15561207870200/15713056309096.jpg" alt="" /></figure></p>
<p>这里可以看到三个阶段完成的工作消耗了11s的时间，730MB的内存空间。也就是说1：8的比例。可以相比上面的例子，知道这里使用JSONSerializer产生了JSONElement对象消耗了很多的内存。</p>
<h3><a id="%E7%BB%93%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>结论</h3>
<p>在上面的分析过程中，我们采用了GSON的两种不同的方然完成了序列化一个大数据的过程，并且比较了不同的方法之间的差异。上面的第三种方法（TypeAdapter的流式处理）被论证为最合适的，消耗最少内存的一种方法。<br />
Gson主要分成两部分,一个就是数据拆解,一个是数据封装。</p>
<h2><a id="%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考</h2>
<p><a href="http://www.jianshu.com/p/e740196225a4"> 你真的会用Gson吗?Gson使用指南（一）</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/07/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870161.html">
                
                  <h1>Android-SpannableString设置复合文本</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>TextView通常用来显示普通文本，但是有时候需要对其中某些文本进行样式、事件方面的设置。 Android系统通过SpannableString类来对指定文本进行相关处理，具体有以下功能：</p>
<ul>
<li><code>BackgroundColorSpan</code> 背景色 </li>
<li><code>ClickableSpan</code> 文本可点击，有点击事件</li>
<li><code>ForegroundColorSpan</code> 文本颜色（前景色）</li>
<li><code>MaskFilterSpan</code> 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)</li>
<li><code>MetricAffectingSpan</code> 父类，一般不用</li>
<li><code>RasterizerSpan</code> 光栅效果</li>
<li><code>StrikethroughSpan</code> 删除线（中划线）</li>
<li><code>SuggestionSpan</code> 相当于占位符</li>
<li><code>UnderlineSpan</code> 下划线</li>
<li><code>AbsoluteSizeSpan</code> 绝对大小（文本字体）</li>
<li><code>DynamicDrawableSpan</code> 设置图片，基于文本基线或底部对齐。</li>
<li><code>ImageSpan</code> 图片</li>
<li><code>RelativeSizeSpan</code> 相对大小（文本字体）</li>
<li><code>ReplacementSpan</code> 父类，一般不用</li>
<li><code>ScaleXSpan</code> 基于x轴缩放</li>
<li><code>StyleSpan</code> 字体样式：粗体、斜体等</li>
<li><code>SubscriptSpan</code> 下标（数学公式会用到）</li>
<li><code>SuperscriptSpan</code> 上标（数学公式会用到）</li>
<li><code>TextAppearanceSpan</code> 文本外貌（包括字体、大小、样式和颜色）</li>
<li><code>TypefaceSpan</code> 文本字体</li>
<li><code>URLSpan</code> 文本超链接</li>
</ul>
<h2><a id="%E4%B8%80%E3%80%81backgroundcolorspan%E8%83%8C%E6%99%AF%E8%89%B2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>一、BackgroundColorSpan 背景色</h2>
<pre class="line-numbers"><code class="language-java">SpannableString spanText = new SpannableString(&quot;萝卜白菜的博客 -- http://orgcent.com&quot;);
spanText.setSpan(new BackgroundColorSpan(Color.GREEN), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText); 
</code></pre>
<h2><a id="%E4%BA%8C%E3%80%81clickablespan%E6%96%87%E6%9C%AC%E5%8F%AF%E7%82%B9%E5%87%BB%EF%BC%8C%E6%9C%89%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二、ClickableSpan 文本可点击，有点击事件</h2>
<h2><a id="%E4%B8%89%E3%80%81foregroundcolorspan%E6%96%87%E6%9C%AC%E9%A2%9C%E8%89%B2%EF%BC%88%E5%89%8D%E6%99%AF%E8%89%B2%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>三、ForegroundColorSpan 文本颜色（前景色）</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;萝卜白菜的博客 -- http://orgcent.com&quot;);
spanText.setSpan(new ForegroundColorSpan(Color.BLUE), 6, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<h2><a id="%E5%9B%9B%E3%80%81maskfilterspan%E4%BF%AE%E9%A5%B0%E6%95%88%E6%9E%9C%EF%BC%8C%E5%A6%82%E6%A8%A1%E7%B3%8A-blurmaskfilter%E3%80%81%E6%B5%AE%E9%9B%95-embossmaskfilter" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>四、MaskFilterSpan 修饰效果，如模糊(BlurMaskFilter)、浮雕(EmbossMaskFilter)</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;MaskFilterSpan -- http://orgcent.com&quot;);
int length = spanText.length();
//模糊(BlurMaskFilter)
MaskFilterSpan maskFilterSpan = new MaskFilterSpan(new BlurMaskFilter(3, Blur.OUTER));
spanText.setSpan(maskFilterSpan, 0, length - 10, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
//浮雕(EmbossMaskFilter)
maskFilterSpan = new MaskFilterSpan(new EmbossMaskFilter(new float[]{1,1,3}, 1.5f, 8, 3));
spanText.setSpan(maskFilterSpan, length - 10, length, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<p><strong>PS:从上图看，浮雕效果不明显。把字体设置大点后可以看得清晰些。需要其他效果可以继承MaskFilter来自定义。</strong></p>
<h2><a id="%E5%85%AD%E3%80%81rasterizerspan%E5%85%89%E6%A0%85%E6%95%88%E6%9E%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>六、RasterizerSpan 光栅效果</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;StrikethroughSpan&quot;);
spanText.setSpan(new StrikethroughSpan(), 0, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<p><strong>PS:暂不清楚，效果不明显。</strong></p>
<h2><a id="%E4%B8%83%E3%80%81strikethroughspan%E5%88%A0%E9%99%A4%E7%BA%BF%EF%BC%88%E4%B8%AD%E5%88%92%E7%BA%BF%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>七、StrikethroughSpan 删除线（中划线）</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;StrikethroughSpan&quot;);
spanText.setSpan(new StrikethroughSpan(), 0, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<h2><a id="%E5%85%AB%E3%80%81suggestionspan" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>八、SuggestionSpan</h2>
<p>相当于占位符，一般用在EditText输入框中。当双击此文本时，会弹出提示框选择一些建议（推荐的）文字，选中的文本将替换此占位符。在输入法上用的较多。</p>
<p><strong>PS：API 14新增，暂无示例。</strong></p>
<h2><a id="%E4%B9%9D%E3%80%81underlinespan%E4%B8%8B%E5%88%92%E7%BA%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>九、UnderlineSpan 下划线</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;UnderlineSpan&quot;);
spanText.setSpan(new UnderlineSpan(), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<h2><a id="%E5%8D%81%E3%80%81absolutesizespan%E7%BB%9D%E5%AF%B9%E5%A4%A7%E5%B0%8F%EF%BC%88%E6%96%87%E6%9C%AC%E5%AD%97%E4%BD%93%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十、AbsoluteSizeSpan 绝对大小（文本字体）</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;AbsoluteSizeSpan&quot;);
spanText.setSpan(new AbsoluteSizeSpan(20, true), 0, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<p><strong>PS:把字体大小设置大点，效果硬朗。</strong></p>
<h2><a id="%E5%8D%81%E4%B8%80%E3%80%81dynamicdrawablespan%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%EF%BC%8C%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%9F%BA%E7%BA%BF%E6%88%96%E5%BA%95%E9%83%A8%E5%AF%B9%E9%BD%90%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十一、DynamicDrawableSpan 设置图片，基于文本基线或底部对齐。</h2>
<pre class="line-numbers"><code class="language-java">DynamicDrawableSpan drawableSpan = new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BASELINE) {
    @Override    
    public Drawable getDrawable() {        
        Drawable d = getResources().getDrawable(R.drawable.ic_launcher);
        d.setBounds(0, 0, 50, 50);
        return d;
    }
};
DynamicDrawableSpan drawableSpan2 = new DynamicDrawableSpan(DynamicDrawableSpan.ALIGN_BOTTOM) {
    @Override
    public Drawable getDrawable() {
        Drawable d = getResources().getDrawable(R.drawable.ic_launcher);
        d.setBounds(0, 0, 50, 50);
        return d;
    }
};
spanText.setSpan(drawableSpan, 3, 4, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
spanText.setSpan(drawableSpan2, 7, 8, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<p><strong>PS:左边图片基于基线对齐，右边图片基于底部对齐</strong></p>
<h2><a id="%E5%8D%81%E4%BA%8C%E3%80%81imagespan%E5%9B%BE%E7%89%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十二、ImageSpan 图片</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;ImageSpan&quot;);
Drawable d = getResources().getDrawable(R.drawable.ic_launcher);
d.setBounds(0, 0, 50, 50);
spanText.setSpan(new ImageSpan(d), 3, 4, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<p><strong>PS:和DynamicDrawableSpan差别不大</strong></p>
<h2><a id="%E5%8D%81%E4%B8%89%E3%80%81relativesizespan%E7%9B%B8%E5%AF%B9%E5%A4%A7%E5%B0%8F%EF%BC%88%E6%96%87%E6%9C%AC%E5%AD%97%E4%BD%93%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十三、RelativeSizeSpan 相对大小（文本字体）</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;RelativeSizeSpan&quot;);
//参数proportion:比例大小
spanText.setSpan(new RelativeSizeSpan(2.5f), 3, 4,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<p><strong>PS:相对大小的比例是基于当前文本字体大小</strong></p>
<h2><a id="%E5%8D%81%E5%9B%9B%E3%80%81scalexspan%E5%9F%BA%E4%BA%8E-x%E8%BD%B4%E7%BC%A9%E6%94%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十四、ScaleXSpan 基于x轴缩放</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;ScaleXSpan -- 萝卜白菜的博客&quot;);
//参数proportion:比例大小
spanText.setSpan(new ScaleXSpan(3.8f), 3, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<h2><a id="%E5%8D%81%E4%BA%94%E3%80%81stylespan%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F%EF%BC%9A%E7%B2%97%E4%BD%93%E3%80%81%E6%96%9C%E4%BD%93%E7%AD%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十五、StyleSpan 字体样式：粗体、斜体等</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;StyleSpan -- 萝卜白菜的博客&quot;);
//Typeface.BOLD_ITALIC:粗体+斜体
spanText.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 3, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<h2><a id="%E5%8D%81%E5%85%AD%E3%80%81subscriptspan%E4%B8%8B%E6%A0%87%EF%BC%88%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%BC%9A%E7%94%A8%E5%88%B0%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十六、SubscriptSpan 下标（数学公式会用到）</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;SubscriptSpan -- 萝卜白菜的博客&quot;);
spanText.setSpan(new SubscriptSpan(), 6, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<h2><a id="%E5%8D%81%E4%B8%83%E3%80%81superscriptspan%E4%B8%8A%E6%A0%87%EF%BC%88%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%BC%9A%E7%94%A8%E5%88%B0%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十七、SuperscriptSpan 上标（数学公式会用到）</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;SuperscriptSpan -- 萝卜白菜的博客&quot;);
spanText.setSpan(new SuperscriptSpan(), 6, 7,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<h2><a id="%E5%8D%81%E5%85%AB%E3%80%81textappearancespan%E6%96%87%E6%9C%AC%E5%A4%96%E8%B2%8C%EF%BC%88%E5%8C%85%E6%8B%AC%E5%AD%97%E4%BD%93%E3%80%81%E5%A4%A7%E5%B0%8F%E3%80%81%E6%A0%B7%E5%BC%8F%E5%92%8C%E9%A2%9C%E8%89%B2%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十八、TextAppearanceSpan 文本外貌（包括字体、大小、样式和颜色）</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;TextAppearanceSpan -- 萝卜白菜的博客&quot;);
//若需自定义TextAppearance，可以在系统样式上进行修改
spanText.setSpan(new TextAppearanceSpan(this, android.R.style.TextAppearance_Medium),6, 7, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
</code></pre>
<p><strong>PS:系统还提供了相关值TextAppearance_Small, TextAppearance_Large等。如有需要可在以上样式基础上修改。</strong></p>
<h2><a id="%E5%8D%81%E4%B9%9D%E3%80%81typefacespan%E6%96%87%E6%9C%AC%E5%AD%97%E4%BD%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十九、TypefaceSpan 文本字体</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;TypefaceSpan -- 萝卜白菜的博客&quot;);
//若需使用自定义字体，可能要重写类
TypefaceSpanspanText.setSpan(new TypefaceSpan(&quot;monospace&quot;), 3, 10,Spannable.SPAN_INCLUSIVE_EXCLUSIVE);mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);;
</code></pre>
<h2><a id="%E4%BA%8C%E5%8D%81%E3%80%81urlspan%E6%96%87%E6%9C%AC%E8%B6%85%E9%93%BE%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>二十、URLSpan 文本超链接</h2>
<pre class="line-numbers"><code class="language-java">spanText = new SpannableString(&quot;URLSpan -- 萝卜白菜的博客&quot;);
spanText.setSpan(new URLSpan(&quot;http://orgcent.com&quot;), 10, spanText.length(),Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
mTVText.append(&quot;\n&quot;);
mTVText.append(spanText);
//让URLSpan可以点击
mTVText.setMovementMethod(new LinkMovementMethod());
</code></pre>
<p><a href="https://juejin.im/post/59bf91476fb9a00a583178d3">https://juejin.im/post/59bf91476fb9a00a583178d3</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/07/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207870123.html">
                
                  <h1>Android-RxJava详细学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>Android开发已经进行了蛮久的一段时间了，基础部分都掌握的差不多了。所以需要跟进时代需要学习一直以来很火的RxJava来提升自己的开发效率以及代码的规范。</p>
<h2><a id="rxjava%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RxJava 到底是什么</h2>
<p>一个词：异步。</p>
<blockquote>
<p>a library for composing asynchronous and event-based programs using observable sequences for the Java VM解释：一个对于构成使用的Java虚拟机观察序列<code>异步</code>和基于事件的程序库</p>
</blockquote>
<p>RxJava 是一个非常著名的开源库，是ReactiveX响应式编程框架的一种Java实现，采用观察者设计模式。所以自然少不了 Observable 和 Subscriber 这两个东东了。<br />
RxJava 是一个开源项目，地址： <a href="https://github.com/ReactiveX/RxJava">https://github.com/ReactiveX/RxJava</a><br />
RxAndroid，用于 Android 开发，添加了 Android 用的接口。地址：  <a href="https://github.com/ReactiveX/RxAndroid">https://github.com/ReactiveX/RxAndroid</a><br />
其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。</p>
<h2><a id="rxjava%E5%A5%BD%E5%9C%A8%E5%93%AA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RxJava 好在哪</h2>
<p>换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / ... ？』</p>
<p>一个词：简洁。</p>
<p>异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 <code>AsyncTask</code> 和<code>Handler</code> ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。</p>
<p>假设有这样一个需求：界面上有一个自定义的视图 <code>imageCollectorView</code> ，它的作用是显示多张图片，并能使用 <code>addImage(Bitmap)</code> 方法来任意增加显示的图片。现在需要程序将一个给出的目录数组 <code>File[] folders</code> 中每个目录下的 png 图片都加载出来并显示在 <code>imageCollectorView</code> 中。需要注意的是，由于读取图片的这一过程较为耗时，需要放在后台执行，而图片的显示则必须在 UI 线程执行。常用的实现方式有多种，我这里贴出其中一种：</p>
<pre class="line-numbers"><code class="language-java">new Thread() {
    @Override
    public void run() {
        super.run();
        for (File folder : folders) {
            File[] files = folder.listFiles();
            for (File file : files) {
                if (file.getName().endsWith(&quot;.png&quot;)) {
                    final Bitmap bitmap = getBitmapFromFile(file);
                    getActivity().runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            imageCollectorView.addImage(bitmap);
                        }
                    });
                }
            }
        }
    }
}.start();
</code></pre>
<p>而如果使用 RxJava ，实现方式是这样的：</p>
<pre class="line-numbers"><code class="language-java">Observable.from(folders)
    .flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() {
        @Override
        public Observable&lt;File&gt; call(File file) {
            return Observable.from(file.listFiles());
        }
    })
    .filter(new Func1&lt;File, Boolean&gt;() {
        @Override
        public Boolean call(File file) {
            return file.getName().endsWith(&quot;.png&quot;);
        }
    })
    .map(new Func1&lt;File, Bitmap&gt;() {
        @Override
        public Bitmap call(File file) {
            return getBitmapFromFile(file);
        }
    })
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Action1&lt;Bitmap&gt;() {
        @Override
        public void call(Bitmap bitmap) {
            imageCollectorView.addImage(bitmap);
        }
});
</code></pre>
<p>虽然代码看起来更多了，但观察一下你会发现， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显（试想如果还要求只选取前 10 张图片，常规方式要怎么办？如果有更多这样那样的要求呢？再试想，在这一大堆需求实现完两个月之后需要改功能，当你翻回这里看到自己当初写下的那一片迷之缩进，你能保证自己将迅速看懂，而不是对着代码重新捋一遍思路？）。</p>
<p>另外，如果你的 IDE 是 Android Studio ，其实每次打开某个 Java 文件的时候，你会看到被自动 Lambda 化的预览，这将让你更加清晰地看到程序逻辑：</p>
<pre class="line-numbers"><code class="language-java">Observable.from(folders)
    .flatMap((Func1) (folder) -&gt; { Observable.from(file.listFiles()) })
    .filter((Func1) (file) -&gt; { file.getName().endsWith(&quot;.png&quot;) })
    .map((Func1) (file) -&gt; { getBitmapFromFile(file) })
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe((Action1) (bitmap) -&gt; { imageCollectorView.addImage(bitmap) });
</code></pre>
<h2><a id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本概念</h2>
<p><strong>Observable</strong>：发射源，英文释义“可观察的”，在观察者模式中称为“被观察者”或“可观察对象”；<br />
<strong>Observer</strong>：接收源，英文释义“观察者”，没错！就是观察者模式中的“观察者”，可接收Observable、Subject发射的数据；<br />
<strong>Subject</strong>：Subject是一个比较特殊的对象，既可充当发射源，也可充当接收源，为避免初学者被混淆，本章将不对Subject做过多的解释和使用，重点放在Observable和Observer上，先把最基本方法的使用学会，后面再学其他的都不是什么问题；<br />
<strong>Subscriber</strong>：“订阅者”，也是接收源，那它跟Observer有什么区别呢？Subscriber实现了Observer接口，比Observer多了一个最重要的方法<code>unsubscribe( )</code>，用来取消订阅，当你不再想接收数据了，可以调用<code>unsubscribe( )</code>方法停止接收，Observer 在 <code>subscribe()</code> 过程中,最终也会被转换成 Subscriber 对象，一般情况下，建议使用Subscriber作为接收源；<br />
<strong>Subscription</strong> ：Observable调用<code>subscribe( )</code>方法返回的对象，同样有<code>unsubscribe( )</code>方法，可以用来取消订阅事件；<br />
<strong>Action0</strong>：RxJava中的一个接口，它只有一个无参call（）方法，且无返回值，同样还有Action1，Action2...Action9等，Action1封装了含有 1 个参的call（）方法，即call（T t），Action2封装了含有 2 个参数的call方法，即call（T1 t1，T2 t2），以此类推；<br />
<strong>Func0</strong>：与Action0非常相似，也有call（）方法，但是它是有返回值的，同样也有Func0、Func1...Func9;</p>
<h2><a id="api%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API 介绍和原理简析</h2>
<h3><a id="rxjava%E7%9A%84%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RxJava 的观察者模式</h3>
<p>RxJava 有四个基本概念：<code>Observable</code><br />
 (可观察者，即被观察者)、 <code>Observer</code> (观察者)、 <code>subscribe</code> (订阅)、事件。<code>Observable</code> 和 <code>Observer</code> 通过 <code>subscribe()</code> 方法实现订阅关系，从而 <code>Observable</code> 可以在需要的时候发出事件来通知 <code>Observer</code>。</p>
<p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 <code>onNext()</code> （相当于 <code>onClick()</code> / <code>onEvent()</code>）之外，还定义了两个特殊的事件：<code>onCompleted()</code> 和 <code>onError()</code>。</p>
<ul>
<li><code>onCompleted()</code>: 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 <code>onNext()</code> 发出时，需要触发 <code>onCompleted()</code>方法作为标志。</li>
<li><code>onError()</code>: 事件队列异常。在事件处理过程中出异常时，<code>onError()</code>会被触发，同时队列自动终止，不允许再有事件发出。</li>
<li>在一个正确运行的事件序列中, <code>onCompleted()</code>和<code>onError()</code> 有且只有一个，并且是事件序列中的最后一个。需要注意的是，<code>onCompleted()</code> 和 <code>onError()</code> 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。<br />
RxJava 的观察者模式大致如下图：</li>
</ul>
<p><figure><img src="media/15561207870123/15713053119606.jpg" alt="" /></figure></p>
<h3><a id="%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本实现</h3>
<p>基于以上的概念， RxJava 的基本实现主要有三点：</p>
<h4><a id="%E5%88%9B%E5%BB%BAobserver" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建 Observer</h4>
<p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 <code>Observer</code> 接口的实现方式：</p>
<pre class="line-numbers"><code class="language-java">Observer&lt;String&gt; observer = new Observer&lt;String&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }

    @Override
    public void onCompleted() {
        Log.d(tag, &quot;Completed!&quot;);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(tag, &quot;Error!&quot;);
    }
};
</code></pre>
<p>除了 <code>Observer</code> 接口之外，RxJava 还内置了一个实现了 <code>Observer</code> 的抽象类：<code>Subscriber</code>。 <code>Subscriber</code> 对 <code>Observer</code> 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>
<pre class="line-numbers"><code class="language-java">Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {
    @Override
    public void onNext(String s) {
        Log.d(tag, &quot;Item: &quot; + s);
    }

    @Override
    public void onCompleted() {
        Log.d(tag, &quot;Completed!&quot;);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(tag, &quot;Error!&quot;);
    }
};
</code></pre>
<p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，<code>Observer</code> 也总是会先被转换成一个 <code>Subscriber</code><br />
 再使用。所以如果你只想使用基本功能，选择 <code>Observer</code> 和 <code>Subscriber</code> 是完全一样的。它们的区别对于使用者来说主要有两点：</p>
<ul>
<li><code>onStart()</code>: 这是 <code>Subscriber</code> 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， <code>onStart()</code>就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使<code>doOnSubscribe()</code>方法，具体可以在后面的文中看到。</li>
<li><code>unsubscribe()</code>: 这是 <code>Subscriber</code> 所实现的另一个接口 <code>Subscription</code>的方法，用于取消订阅。在这个方法被调用后，<code>Subscriber</code>将不再接收事件。一般在这个方法调用前，可以使用 <code>isUnsubscribed()</code> 先判断一下状态。 <code>unsubscribe()</code> 这个方法很重要，因为在 <code>subscribe()</code> 之后， <code>Observable</code> 会持有 <code>Subscriber</code>的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 <code>onPause()``onStop()</code> 等方法中）调用 <code>unsubscribe()</code> 来解除引用关系，以避免内存泄露的发生。</li>
</ul>
<h4><a id="%E5%88%9B%E5%BB%BAobservable" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建 Observable</h4>
<p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 <code>create()</code> 方法来创建一个 Observable ，并为它定义事件触发规则：</p>
<pre class="line-numbers"><code class="language-java">Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
    @Override
    public void call(Subscriber&lt;? super String&gt; subscriber) {
        subscriber.onNext(&quot;Hello&quot;);
        subscriber.onNext(&quot;Hi&quot;);
        subscriber.onNext(&quot;Aloha&quot;);
        subscriber.onCompleted();
    }
});
</code></pre>
<p>可以看到，这里传入了一个 <code>OnSubscribe</code> 对象作为参数。<code>OnSubscribe</code> 会被存储在返回的 <code>Observable</code> 对象中，它的作用相当于一个计划表，当 <code>Observable</code> 被订阅的时候，<code>OnSubscribe</code> 的 <code>call()</code> 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者<code>Subscriber</code> 将会被调用三次 <code>onNext()</code> 和一次 <code>onCompleted()</code>）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>
<ul>
<li>
<p><code>create()</code> 方法是 RxJava 最基本的创造事件序列的方法。</p>
</li>
<li>
<p><code>just(T...)</code>: 将传入的参数依次发送出来。</p>
</li>
</ul>
<pre class="line-numbers"><code class="language-java">Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
</code></pre>
<ul>
<li><code>from(T[])</code>/ <code>from(Iterable&lt;? extends T&gt;)</code>: 将传入的数组或 <code>Iterable</code> 拆分成具体对象后，依次发送出来。</li>
</ul>
<pre class="line-numbers"><code class="language-java">String[] words = {&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;};
Observable observable = Observable.from(words);
// 将会依次调用：
// onNext(&quot;Hello&quot;);
// onNext(&quot;Hi&quot;);
// onNext(&quot;Aloha&quot;);
// onCompleted();
</code></pre>
<ul>
<li><code>defer( )</code>:有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable：</li>
</ul>
<pre class="line-numbers"><code class="language-java">deferObservable = Observable.defer(new Func0&lt;Observable&lt;String&gt;&gt;() {
  @Override
  //注意此处的call方法没有Subscriber参数
  public Observable&lt;String&gt; call() {
      return Observable.just(&quot;deferObservable&quot;);
  }});
</code></pre>
<ul>
<li><code>interval( )</code>:创建一个按固定时间间隔发射整数序列的Observable，可用作定时器：</li>
</ul>
<pre class="line-numbers"><code class="language-java">intervalObservable = Observable.interval(1, TimeUnit.SECONDS);//每隔一秒发送一次
</code></pre>
<ul>
<li><code>range( )</code>:创建一个发射特定整数序列的Observable，第一个参数为起始值，第二个为发送的个数，如果为0则不发送，负数则抛异常：</li>
</ul>
<pre class="line-numbers"><code class="language-java">rangeObservable = Observable.range(10, 5);//将发送整数10，11，12，13，14
</code></pre>
<ul>
<li><code>timer( )</code>:创建一个Observable，它在一个给定的延迟后发射一个特殊的值，等同于Android中Handler的postDelay( )方法：</li>
</ul>
<pre class="line-numbers"><code class="language-java">timeObservable = Observable.timer(3, TimeUnit.SECONDS);  //3秒后发射一个值
</code></pre>
<ul>
<li><code>repeat( )</code>:创建一个重复发射特定数据的Observable:</li>
</ul>
<pre class="line-numbers"><code class="language-java">repeatObservable = Observable.just(&quot;repeatObservable&quot;).repeat(3);//重复发射3次
</code></pre>
<h4><a id="subscribe%E8%AE%A2%E9%98%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subscribe (订阅)</h4>
<p>创建了 <code>Observable</code> 和 <code>Observer</code> 之后，再用 <code>subscribe()</code> 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p>
<pre class="line-numbers"><code class="language-java">observable.subscribe(observer);
// 或者：
observable.subscribe(subscriber);
</code></pre>
<p><code>subscriber()</code> 做了3件事：</p>
<ul>
<li>调用 <code>Subscriber.onStart()</code>。这个方法在前面已经介绍过，是一个可选的准备方法。</li>
<li>调用 <code>Observable</code> 中的 <code>OnSubscribe.call(Subscriber)</code>。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， <code>Observable</code> 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 <code>subscribe()</code>方法执行的时候。</li>
<li>将传入的 <code>Subscriber</code> 作为 <code>Subscription</code> 返回。这是为了方便 <code>unsubscribe()</code>.</li>
</ul>
<p>整个过程中对象间的关系如下图：</p>
<p><figure><img src="media/15561207870123/15713053244741.jpg" alt="" /></figure></p>
<p>或者可以看动图：</p>
<p><figure><img src="media/15561207870123/20171011150768262032561.gif" alt="" /></figure></p>
<p>除了 <code>subscribe(Observer)</code> 和<code>subscribe(Subscriber)</code> ，<code>subscribe()</code> 还支持不完整定义的回调，RxJava 会自动根据定义创建出 <code>Subscriber</code> 。形式如下：</p>
<pre class="line-numbers"><code class="language-java">Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() {
    // onNext()
    @Override
    public void call(String s) {
        Log.d(tag, s);
    }
};
Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() {
    // onError()
    @Override
    public void call(Throwable throwable) {
        // Error handling
    }
};
Action0 onCompletedAction = new Action0() {
    // onCompleted()
    @Override
    public void call() {
        Log.d(tag, &quot;completed&quot;);
    }
};

// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()
observable.subscribe(onNextAction);
// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()
observable.subscribe(onNextAction, onErrorAction);
// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()
observable.subscribe(onNextAction, onErrorAction, onCompletedAction);
</code></pre>
<p>简单解释一下这段代码中出现的 <code>Action1</code> 和 <code>Action0</code>。 <code>Action0</code> 是 RxJava 的一个接口，它只有一个方法 <code>call()</code>，这个方法是无参无返回值的；由于 <code>onCompleted()</code> 方法也是无参无返回值的，因此 <code>Action0</code> 可以被当成一个包装对象，将 <code>onCompleted()</code> 的内容打包起来将自己作为一个参数传入 <code>subscribe()</code> 以实现不完整定义的回调。这样其实也可以看做将 <code>onCompleted()</code> 方法作为参数传进了 <code>subscribe()</code>，相当于其他某些语言中的『闭包』。 <br />
<code>Action1</code> 也是一个接口，它同样只有一个方法 <code>call(T param)</code>，这个方法也无返回值，但有一个参数；与 <code>Action0</code> 同理，由于 <code>onNext(T obj)</code> 和 <code>onError(Throwable error)</code> 也是单参数无返回值的，因此 <code>Action1</code>可以将 <code>onNext(obj)</code> 和 <code>onError(error)</code> 打包起来传入 <code>subscribe()</code> 以实现不完整定义的回调。事实上，虽然 <code>Action0</code> 和 <code>Action1</code>在 API 中使用最广泛，但 RxJava 是提供了多个 <code>ActionX</code> 形式的接口 (例如 <code>Action2</code>, <code>Action3</code>) 的，它们可以被用以包装不同的无返回值的方法。</p>
<h4><a id="subscriptions%E8%AE%A2%E9%98%85%E8%80%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subscriptions(订阅者)</h4>
<p>当调用<code>Observable.subscribe()</code>，会返回一个<code>Subscription</code>对象。这个对象代表了被观察者和订阅者之间的联系。</p>
<pre class="line-numbers"><code class="language-java">Subscription subscription = Observable.just(&quot;Hello, World!&quot;)
.subscribe(s -&gt; System.out.println(s)); 
</code></pre>
<p>你可以在后面使用这个<code>Subscription</code>对象来操作被观察者和订阅者之间的联系.</p>
<pre class="line-numbers"><code class="language-java">subscription.unsubscribe();//接触订阅关系
System.out.println(&quot;Unsubscribed=&quot; + subscription.isUnsubscribed());
// Outputs &quot;Unsubscribed=true&quot; 
</code></pre>
<p>RxJava的另外一个好处就是它处理<code>unsubscribing</code>的时候，会停止整个调用链。如果你使用了一串很复杂的操作符，调用<code>unsubscribe</code>将会在他当前执行的地方终止。不需要做任何额外的工作！</p>
<h4><a id="%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>场景示例</h4>
<h5><a id="%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>打印字符串数组</h5>
<p>将字符串数组 <code>names</code> 中的所有字符串依次打印出来：</p>
<pre class="line-numbers"><code class="language-java">String[] names = ...;
Observable.from(names)
    .subscribe(new Action1&lt;String&gt;() {
        @Override
        public void call(String name) {
            Log.d(tag, name);
        }
});
</code></pre>
<h5><a id="%E7%94%B1id%E5%8F%96%E5%BE%97%E5%9B%BE%E7%89%87%E5%B9%B6%E6%98%BE%E7%A4%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>由 id 取得图片并显示</h5>
<p>由指定的一个 drawable 文件 id <code>drawableRes</code> 取得图片，并显示在 <code>ImageView</code> 中，并在出现异常的时候打印 Toast 报错：</p>
<pre class="line-numbers"><code class="language-java">int drawableRes = ...;
ImageView imageView = ...;
Observable.create(new OnSubscribe&lt;Drawable&gt;() {
    @Override
    public void call(Subscriber&lt;? super Drawable&gt; subscriber) {
        Drawable drawable = getTheme().getDrawable(drawableRes));
        subscriber.onNext(drawable);
        subscriber.onCompleted();
    }
}).subscribe(new Observer&lt;Drawable&gt;() {
    @Override
    public void onNext(Drawable drawable) {
        imageView.setImageDrawable(drawable);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
        Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();
    }
});
</code></pre>
<p>正如上面两个例子这样，创建出 <code>Observable</code> 和 <code>Subscriber</code> ，再用 <code>subscribe()</code> 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。<br />
然而，在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： <code>Scheduler</code> 。</p>
<h3><a id="%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E2%80%94%E2%80%94scheduler%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程控制 —— Scheduler (一)</h3>
<p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 <code>subscribe()</code>，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 <code>Scheduler</code> （调度器）。</p>
<h4><a id="scheduler%E7%9A%84-api%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scheduler 的 API (一)</h4>
<p>在RxJava 中，<code>Scheduler</code> ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 <code>Scheduler</code> ，它们已经适合大多数的使用场景：</p>
<ul>
<li><code>Schedulers.trampoline( )</code>:当其它排队的任务完成后，在当前线程排队开始执行。</li>
<li><code>Schedulers.from(executor)</code>:使用指定的Executor作为调度器。</li>
<li><code>Schedulers.immediate()</code>: 直接在当前线程运行，相当于不指定线程。这是默认的 <code>Scheduler</code>。</li>
<li><code>Schedulers.newThread()</code>: 总是启用新线程，并在新线程执行操作。</li>
<li><code>Schedulers.io()</code>: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 <code>Scheduler</code>。行为模式和 <code>newThread()</code> 差不多，区别在于 <code>io()</code>的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 <code>io()</code> 比 <code>newThread()</code> 更有效率。不要把计算工作放在 <code>io()</code> 中，可以避免创建不必要的线程。</li>
<li><code>Schedulers.computation()</code>: 计算所使用的 <code>Scheduler</code>。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 <code>Scheduler</code>使用的固定的线程池，默认线程数等于处理器的数量。不要把 I/O 操作放在 <code>computation()</code> 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li>另外， Android 还有一个专用的 <code>AndroidSchedulers.mainThread()</code>，它指定的操作将在 Android 主线程运行。</li>
</ul>
<p>有了这几个 <code>Scheduler</code> ，就可以使用 <code>subscribeOn()</code> 和 <code>observeOn()</code> 两个方法来对线程进行控制了。 <code>subscribeOn()</code>: 指定 <code>subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程。或者叫做事件产生的线程。<code>observeOn()</code>: 指定 <code>Subscriber</code> 所运行在的线程。或者叫做事件消费的线程。<br />
文字叙述总归难理解，上代码：</p>
<pre class="line-numbers"><code class="language-java">Observable.just(1, 2, 3, 4)
    .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
    .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
    .subscribe(new Action1&lt;Integer&gt;() {
        @Override
        public void call(Integer number) {
            Log.d(tag, &quot;number:&quot; + number);
        }
});
</code></pre>
<p>上面这段代码中，由于 <code>subscribeOn(Schedulers.io())</code> 的指定，被创建的事件的内容 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 将会在 IO 线程发出；而由于 <code>observeOn(AndroidScheculers.mainThread()</code>) 的指定，因此 <code>subscriber</code> 数字的打印将发生在主线程 。事实上，这种在 <code>subscribe()</code> 之前写上两句 <code>subscribeOn(Scheduler.io())</code> 和 <code>observeOn(AndroidSchedulers.mainThread())</code> 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。<br />
而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句：</p>
<pre class="line-numbers"><code class="language-java">int drawableRes = ...;
ImageView imageView = ...;
Observable.create(new OnSubscribe&lt;Drawable&gt;() {
    @Override
    public void call(Subscriber&lt;? super Drawable&gt; subscriber) {
        Drawable drawable = getTheme().getDrawable(drawableRes));
        subscriber.onNext(drawable);
        subscriber.onCompleted();
    }
})
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程
.subscribe(new Observer&lt;Drawable&gt;() {
    @Override
    public void onNext(Drawable drawable) {
        imageView.setImageDrawable(drawable);
    }

    @Override
    public void onCompleted() {
    }

    @Override
    public void onError(Throwable e) {
        Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();
    }
});
</code></pre>
<p>那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p>
<h4><a id="scheduler%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scheduler 的原理 (一)</h4>
<p>RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 <code>subscribe()</code> 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。</p>
<h3><a id="%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变换</h3>
<p>终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。</p>
<p>RxJava 提供了<em>对事件序列进行变换</em>的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。概念说着总是模糊难懂的，来看 API。</p>
<h4><a id="api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>API</h4>
<p>首先看一个 <code>map()</code> 的例一：</p>
<pre class="line-numbers"><code class="language-java">Observable.just(&quot;images/logo.png&quot;) // 输入类型 String
    .map(new Func1&lt;String, Bitmap&gt;() {
        @Override
        public Bitmap call(String filePath) { // 参数类型 String
            return getBitmapFromPath(filePath); // 返回类型 Bitmap
        }
    })
    .subscribe(new Action1&lt;Bitmap&gt;() {
        @Override
        public void call(Bitmap bitmap) { // 参数类型 Bitmap
            showBitmap(bitmap);
        }
    });
</code></pre>
<p>这里出现了一个叫做 <code>Func1</code> 的类。它和 <code>Action1</code> 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 <code>Func1</code> 和 <code>Action</code> 的区别在于， <code>Func1</code> 包装的是有返回值的方法。另外，和 <code>ActionX</code> 一样， <code>FuncX</code> 也有多个，用于不同参数个数的方法。<code>FuncX</code>和 <code>ActionX</code>的区别在 <code>FuncX</code>包装的是有返回值的方法。<br />
可以看到，<code>map()</code>方法将参数中的 <code>String</code>对象转换成一个 <code>Bitmap</code> 对象后返回，而在经过<code>map()</code>方法后，事件的参数类型也由 <code>String</code>转为了 <code>Bitmap</code>。这种直接变换对象并返回的，是最常见的也最容易理解的变换,将对象转换成另一个对象发射出去，应用范围非常广，如数据的转换，数据的预处理等。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换：</p>
<p>例二：对数据进行预处理，最后得到理想型数据。实际开发过程中，从后台接口获取到的数据也许不符合我们想要的，这时候可以在获取过程中对得到的数据进行预处理（结合Retrofit）。</p>
<pre class="line-numbers"><code class="language-java">Observable.just(&quot;12345678&quot;).map(new Func1&lt;String, String&gt;() {
  @Override
  public String call(String s) {
      return s.substring(0,4);//只要前四位
  }})
.subscribe(new Action1&lt;String&gt;() {
  @Override
  public void call(String s) {
      Log.i(&quot;mytag&quot;,s);
  }});
</code></pre>
<ul>
<li><code>map()</code>: 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 <code>map()</code> 的示意图：</li>
</ul>
<p><figure><img src="media/15561207870123/15713053605523.jpg" alt="" /></figure></p>
<ul>
<li><code>flatMap()</code>: 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</li>
</ul>
<pre class="line-numbers"><code class="language-java">Student[] students = ...;
Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {
    @Override
    public void onNext(String name) {
        Log.d(tag, name);
    }
    ...
};
Observable.from(students)
    .map(new Func1&lt;Student, String&gt;() {
        @Override
        public String call(Student student) {
            return student.getName();
        }
    })
    .subscribe(subscriber);
</code></pre>
<p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：</p>
<pre class="line-numbers"><code class="language-java">Student[] students = ...;
Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() {
    @Override
    public void onNext(Student student) {
        List&lt;Course&gt; courses = student.getCourses();
        for (int i = 0; i &lt; courses.size(); i++) {
            Course course = courses.get(i);
            Log.d(tag, course.getName());
        }
    }
    ...
};
Observable.from(students)
    .subscribe(subscriber);
</code></pre>
<p>依然很简单。那么如果我不想在 <code>Subscriber</code> 中使用 for 循环，而是希望 <code>Subscriber</code> 中直接传入单个的 <code>Course</code> 对象呢（这对于代码复用很重要）？用 <code>map()</code> 显然是不行的，因为 <code>map()</code> 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？</p>
<p>这个时候，就需要用 <code>flatMap()</code> 了：</p>
<pre class="line-numbers"><code class="language-java">Student[] students = ...;
Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() {
    @Override
    public void onNext(Course course) {
        Log.d(tag, course.getName());
    }
    ...
};
Observable.from(students)
    .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() {
        @Override
        public Observable&lt;Course&gt; call(Student student) {
            return Observable.from(student.getCourses());
        }
    })
    .subscribe(subscriber);
</code></pre>
<p>从上面的代码可以看出， <code>flatMap()</code> 和 <code>map()</code> 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 <code>map()</code>不同的是， <code>flatMap()</code> 中返回的是个 <code>Observable</code> 对象，并且这个 <code>Observable</code> 对象并不是被直接发送到了 <code>Subscriber</code> 的回调方法中。 <code>flatMap()</code> 的原理是这样的：1. 使用传入的事件对象创建一个 <code>Observable</code> 对象；2. 并不发送这个 <code>Observable</code>, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 <code>Observable</code> 发送的事件，都被汇入同一个 <code>Observable</code> ，而这个 <code>Observable</code> 负责将这些事件统一交给 <code>Subscriber</code> 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 <code>Observable</code> 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 <code>flatMap()</code>所谓的 flat。<br />
<code>flatMap()</code>示意图：</p>
<p><figure><img src="media/15561207870123/15713053760755.jpg" alt="" /></figure></p>
<p>扩展：由于可以在嵌套的 <code>Observable</code> 中添加异步代码， <code>flatMap()</code> 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）：</p>
<pre class="line-numbers"><code class="language-java">networkClient.token() // 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token
    .flatMap(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() {
        @Override
        public Observable&lt;Messages&gt; call(String token) {
            // 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表
            return networkClient.messages();
        }
    })
    .subscribe(new Action1&lt;Messages&gt;() {
        @Override
        public void call(Messages messages) {
            // 处理显示消息列表
            showMessages(messages);
        }
    });
</code></pre>
<p>传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 <code>flatMap()</code> ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。</p>
<ul>
<li><code>throttleFirst()</code>: 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器<code>RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber);</code>妈妈再也不怕我的用户手抖点开两个重复的界面啦。<br />
此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。</li>
</ul>
<h4><a id="%E5%8F%98%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9Alift" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>变换的原理：lift()</h4>
<p>这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： <code>lift(Operator)</code>。首先看一下 <code>lift()</code> 的内部实现（仅核心代码）：</p>
<pre class="line-numbers"><code class="language-java">// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。
// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。
public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) {
    return Observable.create(new OnSubscribe&lt;R&gt;() {
        @Override
        public void call(Subscriber subscriber) {
            Subscriber newSubscriber = operator.call(subscriber);
            newSubscriber.onStart();
            onSubscribe.call(newSubscriber);
        }
    });
}
</code></pre>
<p>这段代码很有意思：它生成了一个新的 <code>Observable</code> 并返回，而且创建新 <code>Observable</code> 所用的参数 <code>OnSubscribe</code> 的回调方法 <code>call()</code> 中的实现竟然看起来和前面讲过的 <code>Observable.subscribe()</code> 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 <code>onSubscribe.call(subscriber)</code> 中的 <code>onSubscribe</code> 所指代的对象不同（高能预警：接下来的几句话可能会导致身体的严重不适）</p>
<ul>
<li><code>subscribe()</code> 中这句话的 <code>onSubscribe</code> 指的是 <code>Observable</code> 中的 <code>onSubscribe</code> 对象，这个没有问题，但是 <code>lift()</code> 之后的情况就复杂了点。</li>
<li>当含有 <code>lift()</code> 时： 
<ul>
<li>1.<code>lift()</code> 创建了一个 <code>Observable</code> 后，加上之前的原始 <code>Observable</code>，已经有两个 <code>Observable</code> 了； </li>
<li>2.而同样地，新 <code>Observable</code> 里的新 <code>OnSubscribe</code> 加上之前的原始 <code>Observable</code> 中的原始 <code>OnSubscribe</code>，也就有了两个 <code>OnSubscribe</code>； </li>
<li>3.当用户调用经过 <code>lift()</code> 后的 <code>Observable</code> 的 <code>subscribe()</code> 的时候，使用的是 <code>lift()</code> 所返回的新的 <code>Observable</code> ，于是它所触发的 <code>onSubscribe.call(subscriber)</code>，也是用的新 <code>Observable</code> 中的新 <code>OnSubscribe</code>，即在 <code>lift()</code> 中生成的那个 <code>OnSubscribe</code>； </li>
<li>4.而这个新 <code>OnSubscribe</code> 的 <code>call()</code> 方法中的 <code>onSubscribe</code> ，就是指的原始 <code>Observable</code> 中的原始 <code>OnSubscribe</code> ，在这个 <code>call()</code>方法里，新 <code>OnSubscribe</code> 利用 <code>operator.call(subscriber)</code> 生成了一个新的 <code>Subscriber</code>（<code>Operator</code> 就是在这里，通过自己的 <code>call()</code>方法将新 <code>Subscriber</code>和原始 <code>Subscriber</code> 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 <code>Subscriber</code> 向原始 <code>Observable</code> 进行订阅。 这样就实现了 <code>lift()</code>过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。</li>
</ul>
</li>
</ul>
<p>精简掉细节的话，也可以这么说：在 <code>Observable</code> 执行了 <code>lift(Operator)</code> 方法之后，会返回一个新的 <code>Observable</code>，这个新的 <code>Observable</code> 会像一个代理一样，负责接收原始的 <code>Observable</code> 发出的事件，并在处理后发送给 <code>Subscriber</code>。<br />
如果你更喜欢具象思维，可以看图：</p>
<p><figure><img src="media/15561207870123/15713053962421.jpg" alt="" /></figure></p>
<p>或者可以看动图：</p>
<p><figure><img src="media/15561207870123/20171011150768288754019.gif" alt="" /></figure></p>
<p>两次和多次的 <code>lift()</code> 同理，如下图：</p>
<p><figure><img src="media/15561207870123/15713054269632.jpg" alt="" /></figure></p>
<p>举一个具体的 <code>Operator</code> 的实现。下面这是一个将事件中的 <code>Integer</code> 对象转换成 <code>String</code> 的例子，仅供参考：</p>
<pre class="line-numbers"><code class="language-java">observable.lift(new Observable.Operator&lt;String, Integer&gt;() {
    @Override
    public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) {
        // 将事件序列中的 Integer 对象转换为 String 对象
        return new Subscriber&lt;Integer&gt;() {
            @Override
            public void onNext(Integer integer) {
                subscriber.onNext(&quot;&quot; + integer);
            }

            @Override
            public void onCompleted() {
                subscriber.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                subscriber.onError(e);
            }
        };
    }
});
</code></pre>
<h4><a id="compose%E5%AF%B9-observable%E6%95%B4%E4%BD%93%E7%9A%84%E5%8F%98%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>compose: 对 Observable 整体的变换</h4>
<p>除了 <code>lift()</code> 之外， <code>Observable</code> 还有一个变换方法叫做 <code>compose(Transformer)</code>。它和 <code>lift()</code> 的区别在于， <code>lift()</code> 是针对事件项和事件序列的，而 <code>compose()</code> 是针对 <code>Observable</code> 自身进行变换。举个例子，假设在程序中有多个 <code>Observable</code>，并且他们都需要应用一组相同的 <code>lift()</code> 变换。你可以这么写：</p>
<pre class="line-numbers"><code class="language-java">observable1
    .lift1()
    .lift2()
    .lift3()
    .lift4()
    .subscribe(subscriber1);
observable2
    .lift1()
    .lift2()
    .lift3()
    .lift4()
    .subscribe(subscriber2);
observable3
    .lift1()
    .lift2()
    .lift3()
    .lift4()
    .subscribe(subscriber3);
observable4
    .lift1()
    .lift2()
    .lift3()
    .lift4()
    .subscribe(subscriber1);
</code></pre>
<p>你觉得这样太不软件工程了，于是你改成了这样：</p>
<pre class="line-numbers"><code class="language-java">private Observable liftAll(Observable observable) {
    return observable
        .lift1()
        .lift2()
        .lift3()
        .lift4();
}
...
liftAll(observable1).subscribe(subscriber1);
liftAll(observable2).subscribe(subscriber2);
liftAll(observable3).subscribe(subscriber3);
liftAll(observable4).subscribe(subscriber4);
</code></pre>
<p>可读性、可维护性都提高了。可是 <code>Observable</code> 被一个方法包起来，这种方式对于 <code>Observale</code> 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 <code>compose()</code> 来解决了：</p>
<pre class="line-numbers"><code class="language-java">public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; {
    @Override
    public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) {
        return observable
            .lift1()
            .lift2()
            .lift3()
            .lift4();
    }
}
...
Transformer liftAll = new LiftAllTransformer();
observable1.compose(liftAll).subscribe(subscriber1);
observable2.compose(liftAll).subscribe(subscriber2);
observable3.compose(liftAll).subscribe(subscriber3);
observable4.compose(liftAll).subscribe(subscriber4);
</code></pre>
<p>像上面这样，使用 <code>compose()</code> 方法，<code>Observable</code> 可以利用传入的 <code>Transformer</code> 对象的 <code>call</code> 方法直接对自身进行处理，也就不必被包在方法的里面了。<code>compose()</code> 的原理比较简单，不附图喽。</p>
<h4><a id="buffer%EF%BC%9A%E7%BC%93%E5%AD%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Buffer：缓存</h4>
<p>可以设置缓存大小，缓存满后，以list的方式将数据发送出去；例：</p>
<pre class="line-numbers"><code class="language-java">Observable
.just(1,2,3)
.buffer(2)
.subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {  
    @Override  
    public void call(List&lt;Integer&gt; list) {      
        Log.i(&quot;mytag&quot;,&quot;size:&quot;+list.size());  
    }
});
</code></pre>
<p>运行打印结果如下：</p>
<pre class="line-numbers"><code class="language-plain_text">11-02 20:49:58.370 23392-23392/? I/mytag: size:211-02 20:49:58.370 23392-23392/? I/mytag: size:1
</code></pre>
<p>在开发当中，个人经常将Buffer和Map一起使用，常发生在从后台取完数据，对一个List中的数据进行预处理后，再用Buffer缓存后一起发送，保证最后数据接收还是一个List，如下：</p>
<pre class="line-numbers"><code class="language-java">List&lt;School&gt; schoolList = new ArrayList&lt;&gt;();
Observable.from(schoolList).map(new Func1&lt;School, School&gt;() {  
    @Override  
    public School call(School school) {      
        school.setName(&quot;NB大学&quot;);  //将所有学校改名      
        return school;  
    }
}).buffer(schoolList.size())  //缓存起来，最后一起发送
.subscribe(new Action1&lt;List&lt;School&gt;&gt;() {  
    @Override  
    public void call(List&lt;School&gt; schools) {}
});
</code></pre>
<h4><a id="take" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Take</h4>
<p>发射前n项数据，还是用上面的例子，假设不要改所有学校的名称了，就改前四个学校的名称：</p>
<pre class="line-numbers"><code class="language-java">Observable.from(schoolList).take(4).map(new Func1&lt;School, School&gt;() {  
    @Override  
    public School call(School school) {      
        school.setName(&quot;NB大学&quot;);      
        return school;  
    }}).buffer(4).subscribe(new Action1&lt;List&lt;School&gt;&gt;() {  
    @Override  
    public void call(List&lt;School&gt; schools) {}
});
</code></pre>
<h4><a id="distinct" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Distinct</h4>
<p>去掉重复的项，比较好理解：</p>
<pre class="line-numbers"><code class="language-java">Observable.just(1, 2, 1, 1, 2, 3).distinct().subscribe(new Action1&lt;Integer&gt;() {          
    @Override          
    public void call(Integer item) {              
        System.out.println(&quot;Next: &quot; + item);          
    }      
});
</code></pre>
<p>输出</p>
<pre class="line-numbers"><code class="language-java">Next: 1Next: 2Next: 3
</code></pre>
<h4><a id="filter%EF%BC%9A%E8%BF%87%E6%BB%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Filter：过滤</h4>
<p>通过谓词判断的项才会被发射，例如，发射小于4的数据：</p>
<pre class="line-numbers"><code class="language-java">Observable.just(1, 2, 3, 4, 5).filter(new Func1&lt;Integer, Boolean&gt;() {          
    @Override          
    public Boolean call(Integer item) {              
        return( item &lt; 4 );          
    }      
}).subscribe(new Action1&lt;Integer&gt;() {        
    @Override        
    public void call(Integer item) {              
        System.out.println(&quot;Next: &quot; + item);    
    }
});
</code></pre>
<p>输出：</p>
<pre class="line-numbers"><code class="language-java">Next: 1Next: 2Next: 3
</code></pre>
<h3><a id="%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%9Ascheduler%E4%BA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程控制：Scheduler (二)</h3>
<p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p>
<h4><a id="scheduler%E7%9A%84-api%E4%BA%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scheduler 的 API (二)</h4>
<p>前面讲到了，可以利用 <code>subscribeOn()</code> 结合 <code>observeOn()</code> 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 <code>map()``flatMap()</code>等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</p>
<p>答案是：能。因为 <code>observeOn()</code> 指定的是 <code>Subscriber</code> 的线程，而这个 <code>Subscriber</code> 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）<code>subscribe()</code> 参数中的 <code>Subscriber</code> ，而是 <code>observeOn()</code> 执行时的当前 <code>Observable</code> 所对应的 <code>Subscriber</code> ，即它的直接下级 <code>Subscriber</code> 。换句话说，<code>observeOn()</code> 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 <code>observeOn()</code> 即可。上代码：</p>
<pre class="line-numbers"><code class="language-java">Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
    .subscribeOn(Schedulers.io())
    .observeOn(Schedulers.newThread())
    .map(mapOperator) // 新线程，由 observeOn() 指定
    .observeOn(Schedulers.io())
    .map(mapOperator2) // IO 线程，由 observeOn() 指定
    .observeOn(AndroidSchedulers.mainThread) 
    .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定
</code></pre>
<p>如上，通过 <code>observeOn()</code> 的多次调用，程序实现了线程的多次切换。<br />
不过，不同于 <code>observeOn()</code> ， <code>subscribeOn()</code> 的位置放在哪里都可以，但它是只能调用一次的。<br />
又有好事的（其实还是当初的我）问了：如果我非要调用多次 <code>subscribeOn()</code> 呢？会有什么效果？<br />
这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。</p>
<h4><a id="scheduler%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scheduler 的原理（二）</h4>
<p>其实， <code>subscribeOn()</code> 和 <code>observeOn()</code> 的内部实现，也是用的 <code>lift()</code>。具体看图（不同颜色的箭头表示不同的线程）：<br />
<code>subscribeOn()</code> 原理图：</p>
<p><figure><img src="media/15561207870123/15713054408629.jpg" alt="" /></figure></p>
<p><code>observeOn()</code> 原理图：</p>
<p><figure><img src="media/15561207870123/15713054500040.jpg" alt="" /></figure></p>
<p>从图中可以看出，<code>subscribeOn()</code> 和 <code>observeOn()</code> 都做了线程切换的工作（图中的 &quot;schedule...&quot; 部位）。不同的是， <code>subscribeOn()</code>的线程切换发生在 <code>OnSubscribe</code> 中，即在它通知上一级 <code>OnSubscribe</code> 时，这时事件还没有开始发送，因此 <code>subscribeOn()</code> 的线程控制可以从事件发出的开端就造成影响；  而 <code>observeOn()</code> 的线程切换则发生在它内建的 <code>Subscriber</code> 中，即发生在它即将给下一级 <code>Subscriber</code> 发送事件时，因此 <code>observeOn()</code> 控制的是它后面的线程。</p>
<p>最后，我用一张图来解释当多个 <code>subscribeOn()</code> 和 <code>observeOn()</code> 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）：</p>
<p><figure><img src="media/15561207870123/15713054782891.jpg" alt="" /></figure></p>
<p>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 <code>subscribeOn()</code> 影响，运行在红色线程；③和④处受第一个 <code>observeOn()</code> 的影响，运行在绿色线程；⑤处受第二个 <code>onserveOn()</code> 影响，运行在紫色线程；而第二个 <code>subscribeOn()</code> ，由于在通知过程中线程就被第一个 <code>subscribeOn()</code> 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 <code>subscribeOn()</code> 的时候，只有第一个 <code>subscribeOn()</code> 起作用。</p>
<h4><a id="%E5%BB%B6%E4%BC%B8%EF%BC%9Adoonsubscribe" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>延伸：doOnSubscribe()</h4>
<p>然而，虽然超过一个的 <code>subscribeOn()</code> 对事件处理的流程没有影响，但在流程之前却是可以利用的。</p>
<p>在前面讲 <code>Subscriber</code> 的时候，提到过 <code>Subscriber</code> 的 <code>onStart()</code> 可以用作流程开始前的初始化。然而 <code>onStart()</code> 由于在 <code>subscribe()</code> 发生时就被调用了，因此不能指定线程，而是只能执行在 <code>subscribe()</code> 被调用时的线程。这就导致如果 <code>onStart()</code> 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 <code>subscribe()</code> 将会在什么线程执行。</p>
<p>而与 <code>Subscriber.onStart()</code> 相对应的，有一个方法 <code>Observable.doOnSubscribe()</code> 。它和 <code>Subscriber.onStart()</code> 同样是在 <code>subscribe()</code> 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， <code>doOnSubscribe()</code> 执行在 <code>subscribe()</code> 发生的线程；而如果在 <code>doOnSubscribe()</code> 之后有 <code>subscribeOn()</code> 的话，它将执行在离它最近的 <code>subscribeOn()</code> 所指定的线程。</p>
<p>示例代码：</p>
<pre class="line-numbers"><code class="language-java">Observable.create(onSubscribe)
    .subscribeOn(Schedulers.io())
    .doOnSubscribe(new Action0() {
        @Override
        public void call() {
            progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行
        }
    })
    .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(subscriber);
</code></pre>
<p>如上，在 <code>doOnSubscribe()</code>的后面跟一个 <code>subscribeOn()</code> ，就能指定准备工作的线程了。</p>
<h2><a id="subject" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subject</h2>
<p>关于Subject，官方文档的解释是这样的：Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中（如RxJava），它同时充当了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个Observable；又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射新的数据。从官方解释中，我提取出三个要点：</p>
<ul>
<li>它可以充当Observable；</li>
<li>它可以充当Observer；</li>
<li>它是Observable和Observer之间的桥梁；</li>
</ul>
<p>接下来对这三个要点解释一下，但在解释之前，要先介绍一下Subject的种类， Subject是一个抽象类，不能通过new来实例化Subject，所以Subject有四个实现类，分别为AsyncSubject、BehaviorSubject、PublishSubject和ReplaySubject，每个实现类都有特定的“技能”，下面结合代码来介绍一下它们各自的“技能”。注意，所有的实现类都由<code>create()</code>方法实例化，无需new,所有的实现类调用<code>onCompleted()</code>或<code>onError()</code>,它的Observer将不再接收数据；</p>
<h2><a id="asyncsubject" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>AsyncSubject</h2>
<p>Observer会接收AsyncSubject的<code>onComplete()</code>之前的最后一个数据，如果因异常而终止，AsyncSubject将不会释放任何数据，但是会向Observer传递一个异常通知。示例代码如下：</p>
<pre class="line-numbers"><code class="language-java">AsyncSubject&lt;String&gt; asyncSubject = AsyncSubject.create();      asyncSubject.onNext(&quot;asyncSubject1&quot;);      
asyncSubject.onNext(&quot;asyncSubject2&quot;);      
asyncSubject.onNext(&quot;asyncSubject3&quot;);        
asyncSubject.onCompleted();      
asyncSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {              
        LogUtil.log(&quot;asyncSubject onCompleted&quot;);  //输出 asyncSubject onCompleted          
    }          
    @Override          
    public void onError(Throwable e) {              
        LogUtil.log(&quot;asyncSubject onError&quot;);  //不输出（异常才会输出）          
    }          
    @Override          
    public void onNext(String s) {              
        LogUtil.log(&quot;asyncSubject:&quot;+s);  //输出asyncSubject:asyncSubject3          
    }      
});
</code></pre>
<p>以上代码，Observer只会接收asyncSubject的onCompleted()被调用前的最后一个数据，即“asyncSubject3”，如果不调用onCompleted()，Subscriber将不接收任何数据。</p>
<h2><a id="behaviorsubject" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>BehaviorSubject</h2>
<p>Observer会接收到BehaviorSubject被订阅之前的最后一个数据，再接收其他发射过来的数据，如果BehaviorSubject被订阅之前没有发送任何数据，则会发送一个默认数据。（注意跟AsyncSubject的区别，AsyncSubject要手动调用onCompleted()，且它的Observer会接收到onCompleted()前发送的最后一个数据，之后不会再接收数据，而BehaviorSubject不需手动调用onCompleted()，它的Observer接收的是BehaviorSubject被订阅前发送的最后一个数据，两个的分界点不一样，且之后还会继续接收数据。）示例代码如下：</p>
<pre class="line-numbers"><code class="language-java">BehaviorSubject&lt;String&gt; behaviorSubject = BehaviorSubject.create(&quot;default&quot;);  behaviorSubject.onNext(&quot;behaviorSubject1&quot;);  
behaviorSubject.onNext(&quot;behaviorSubject2&quot;);      
behaviorSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {              
        LogUtil.log(&quot;behaviorSubject:complete&quot;);          
    }          
    @Override          
    public void onError(Throwable e) {              
        LogUtil.log(&quot;behaviorSubject:error&quot;);          
    }          
    @Override          
    public void onNext(String s) {              
        LogUtil.log(&quot;behaviorSubject:&quot;+s);          
    }
});      
behaviorSubject.onNext(&quot;behaviorSubject3&quot;);      
behaviorSubject.onNext(&quot;behaviorSubject4&quot;);
</code></pre>
<p>以上代码，Observer会接收到behaviorSubject2、behaviorSubject3、behaviorSubject4，如果在<code>behaviorSubject.subscribe()</code>之前不发送behaviorSubject1、behaviorSubject2，则Observer会先接收到default,再接收behaviorSubject3、behaviorSubject4。</p>
<h2><a id="publishsubject" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>PublishSubject</h2>
<p>PublishSubject比较容易理解，相对比其他Subject常用，它的Observer只会接收到PublishSubject被订阅之后发送的数据。示例代码如下：</p>
<pre class="line-numbers"><code class="language-java">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();  
publishSubject.onNext(&quot;publishSubject1&quot;);  
publishSubject.onNext(&quot;publishSubject2&quot;);  
publishSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {          }          
    @Override          
    public void onError(Throwable e) {          }          
    @Override          
    public void onNext(String s) {              
        LogUtil.log(&quot;publishSubject observer1:&quot;+s);          
    }      
});  
publishSubject.onNext(&quot;publishSubject3&quot;);  
publishSubject.onNext(&quot;publishSubject4&quot;);
</code></pre>
<p>以上代码，Observer只会接收到&quot;behaviorSubject3&quot;、&quot;behaviorSubject4&quot;。</p>
<h2><a id="replaysubject" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ReplaySubject</h2>
<p>ReplaySubject会发射所有数据给观察者，无论它们是何时订阅的。也有其它版本的ReplaySubject，在重放缓存增长到一定大小的时候或过了一段时间后会丢弃旧的数据。示例代码如下：</p>
<pre class="line-numbers"><code class="language-java">ReplaySubject&lt;String&gt;replaySubject = ReplaySubject.create(); //创建默认初始缓存容量大小为16的ReplaySubject，当数据条目超过16会重新分配内存空间，使用这种方式，不论ReplaySubject何时被订阅，Observer都能接收到数据
//replaySubject = ReplaySubject.create(100);//创建指定初始缓存容量大小为100的ReplaySubject
//replaySubject = ReplaySubject.createWithSize(2);//只缓存订阅前最后发送的2条数据 
//replaySubject=ReplaySubject.createWithTime(1,TimeUnit.SECONDS,Schedulers.computation());  
//replaySubject被订阅前的前1秒内发送的数据才能被接收     
replaySubject.onNext(&quot;replaySubject:pre1&quot;);
replaySubject.onNext(&quot;replaySubject:pre2&quot;);
replaySubject.onNext(&quot;replaySubject:pre3&quot;);
replaySubject.subscribe(new Action1&lt;String&gt;() {      
    @Override      
    public void call(String s) {              
        LogUtil.log(&quot;replaySubject:&quot; + s);      
    }  
});
replaySubject.onNext(&quot;replaySubject:after1&quot;);
replaySubject.onNext(&quot;replaySubject:after2&quot;);
</code></pre>
<p>以上代码，由于情况比较多，注释也已解释的相当清楚，就不对输出结果一一表述了，有疑问的自行copy代码去测试一下。至此，四种Subject类型已经介绍完毕，但是需要注意，如果你把 Subject 当作一个 Subscriber 使用，不要从多个线程中调用它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，这会违反Observable协议，给Subject的结果增加了不确定性。要避免此类问题，官方提出了“串行化”，你可以将 Subject 转换为一个 SerializedSubject ，类似于这样：<code>SerializedSubject&lt;String, Integer&gt; ser = new SerializedSubject(publishSubject);</code></p>
<h2><a id="subject%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subject总结</h2>
<p>为什么说Subject既可充当Observable，又可充当Observer，是它们两个之间的桥梁呢？经过前面的例子，也许有些人已经大概理解了，不理解的且听我细细道来。首先，从理论上讲，Subject继承了Observable，又实现了Observer接口，所以说它既是Observable又是Observer，完全合理。从实际应用上讲，Subject也能实现Observable和Observer相同的功能，口说无凭，我们还是通过代码来证实比较有说服力。</p>
<h3><a id="%E5%88%9B%E5%BB%BAobservable%E5%B9%B6%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建Observable并发射数据：</h3>
<pre class="line-numbers"><code class="language-java">Observable.create(new Observable.OnSubscribe&lt;String&gt;() {          @Override          public void call(Subscriber&lt;? super String&gt; subscriber) {              subscriber.onNext(&quot;I'm Observable&quot;);              subscriber.onCompleted();          }      });
</code></pre>
<p><em>用Subject实现为</em>：</p>
<pre class="line-numbers"><code class="language-java">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();publishSubject.onNext(&quot;as Observable&quot;);publishSubject.onCompleted();```

### 创建Observer订阅Observable并接收数据：

```java
mObservable.subscribe(new Observer&lt;String&gt;() {      
    @Override       
    public void onCompleted() {}      
    @Override      
    public void onError(Throwable e) {}      
    @Override      
    public void onNext(String s) {//接收数据      
    }
});
</code></pre>
<p><em>用Subject实现为</em>：</p>
<pre class="line-numbers"><code class="language-java">publishSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {}          
    @Override          
    public void onError(Throwable e) {}          
    @Override          
    public void onNext(String s) {}      
});
</code></pre>
<p>也许有人会问，不是说Subject也可以作为Observer，不能把Subject当作Observer传入subscribe()中吗？回答是：当然可以！就象这样：</p>
<pre class="line-numbers"><code class="language-java">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();
Observable.create(new Observable.OnSubscribe&lt;String&gt;() {      
    @Override      
    public void call(Subscriber&lt;? super String&gt; subscriber) {          
        subscriber.onNext(&quot;as Observer&quot;);           
        subscriber.onCompleted();      
    }
}).subscribe(publishSubject);
</code></pre>
<p>有没有发现问题？publishSubject没有重写onNext()方法啊，在哪接收的数据？这就是前面说的“桥梁”的问题了，尽管把Subject作为Observer传入<code>subscribe()</code>，但接收数据还是要通过Observer来接收，借用Subject来连接Observable和Observer，整体代码如下：</p>
<pre class="line-numbers"><code class="language-java">PublishSubject&lt;String&gt; publishSubject = PublishSubject.create();   
Observable.create(new Observable.OnSubscribe&lt;String&gt;() {          
    @Override          
    public void call(Subscriber&lt;? super String&gt; subscriber) {              
        subscriber.onNext(&quot;as Bridge&quot;);              
        subscriber.onCompleted();          
    }      
}).subscribe(publishSubject);      
publishSubject.subscribe(new Observer&lt;String&gt;() {          
    @Override          
    public void onCompleted() {}          
    @Override          
    public void onError(Throwable e) {}          
    @Override          
    public void onNext(String s) {              
        LogUtil.log(&quot;subject:&quot;+s); //接收到 as Bridge          
    }      
});
</code></pre>
<h2><a id="rxjava%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RxJava 的适用场景和使用方式</h2>
<h3><a id="%E4%B8%8Eretrofit%E7%9A%84%E7%BB%93%E5%90%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与 Retrofit 的结合</h3>
<p>Retrofit 除了提供了传统的 <code>Callback</code> 形式的 API，还有 RxJava 版本的 <code>Observable</code> 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。<br />
以获取一个 <code>User</code>对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求：</p>
<pre class="line-numbers"><code class="language-java">@GET(&quot;/user&quot;)
public void getUser(@Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);
</code></pre>
<p>在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应：</p>
<pre class="line-numbers"><code class="language-java">getUser(userId, new Callback&lt;User&gt;() {
    @Override
    public void success(User user) {
        userView.setUser(user);
    }

    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
};
</code></pre>
<p>而使用 RxJava 形式的 API，定义同样的请求是这样的：</p>
<pre class="line-numbers"><code class="language-java">@GET(&quot;/user&quot;)
public Observable&lt;User&gt; getUser(@Query(&quot;userId&quot;) String userId);
</code></pre>
<p>使用的时候是这样的：</p>
<pre class="line-numbers"><code class="language-java">getUser(userId)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;User&gt;() {
        @Override
        public void onNext(User user) {
            userView.setUser(user);
        }

        @Override
        public void onCompleted() {
        }

        @Override
        public void onError(Throwable error) {
            // Error handling
            ...
        }
    });
</code></pre>
<p>看到区别了吗？</p>
<p>当 RxJava 形式的时候，Retrofit 把请求封装进 <code>Observable</code> ，在请求结束后调用 <code>onNext()</code> 或在请求失败后调用 <code>onError()</code>。</p>
<p>对比来看， <code>Callback</code> 形式和 <code>Observable</code> 形式长得不太一样，但本质都差不多，而且在细节上 <code>Observable</code> 形式似乎还比 <code>Callback</code>形式要差点。那 Retrofit 为什么还要提供 RxJava 的支持呢？</p>
<p>因为它好用啊！从这个例子看不出来是因为这只是最简单的情况。而一旦情景复杂起来， <code>Callback</code> 形式马上就会开始让人头疼。比如：<br />
假设这么一种情况：你的程序取到的 <code>User</code> 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 <code>Callback</code>方式大概可以这么写：</p>
<pre class="line-numbers"><code class="language-java">getUser(userId, new Callback&lt;User&gt;() {
    @Override
    public void success(User user) {
        processUser(user); // 尝试修正 User 数据
        userView.setUser(user);
    }

    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
};
</code></pre>
<p>有问题吗？</p>
<p>很简便，但不要这样做。为什么？因为这样做会影响性能。数据库的操作很重，一次读写操作花费 10~20ms 是很常见的，这样的耗时很容易造成界面的卡顿。所以通常情况下，如果可以的话一定要避免在主线程中处理数据库。所以为了提升性能，这段代码可以优化一下：</p>
<pre class="line-numbers"><code class="language-java">getUser(userId, new Callback&lt;User&gt;() {
    @Override
    public void success(User user) {
        new Thread() {
            @Override
            public void run() {
                processUser(user); // 尝试修正 User 数据
                runOnUiThread(new Runnable() { // 切回 UI 线程
                    @Override
                    public void run() {
                        userView.setUser(user);
                    }
                });
            }).start();
    }

    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
};
</code></pre>
<p>性能问题解决，但……这代码实在是太乱了，迷之缩进啊！杂乱的代码往往不仅仅是美观问题，因为代码越乱往往就越难读懂，而如果项目中充斥着杂乱的代码，无疑会降低代码的可读性，造成团队开发效率的降低和出错率的升高。</p>
<p>这时候，如果用 RxJava 的形式，就好办多了。 RxJava 形式的代码是这样的：</p>
<pre class="line-numbers"><code class="language-java">getUser(userId)
    .doOnNext(new Action1&lt;User&gt;() {
        @Override
        public void call(User user) {
            processUser(user);
        })
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;User&gt;() {
        @Override
        public void onNext(User user) {
            userView.setUser(user);
        }

        @Override
        public void onCompleted() {
        }

        @Override
        public void onError(Throwable error) {
            // Error handling
            ...
        }
    });
</code></pre>
<p>后台代码和前台代码全都写在一条链中，明显清晰了很多。</p>
<p>再举一个例子：假设 <code>/user</code> 接口并不能直接访问，而需要填入一个在线获取的 <code>token</code>，代码应该怎么写？<br />
<code>Callback</code> 方式，可以使用嵌套的 <code>Callback</code>：</p>
<pre class="line-numbers"><code class="language-java">@GET(&quot;/token&quot;)
public void getToken(Callback&lt;String&gt; callback);

@GET(&quot;/user&quot;)
public void getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);

...

getToken(new Callback&lt;String&gt;() {
    @Override
    public void success(String token) {
        getUser(token, userId, new Callback&lt;User&gt;() {
            @Override
            public void success(User user) {
                userView.setUser(user);
            }

            @Override
            public void failure(RetrofitError error) {
                // Error handling
                ...
            }
        };
    }

    @Override
    public void failure(RetrofitError error) {
        // Error handling
        ...
    }
});
</code></pre>
<p>倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。<br />
而使用 RxJava 的话，代码是这样的：</p>
<pre class="line-numbers"><code class="language-java">@GET(&quot;/token&quot;)
public Observable&lt;String&gt; getToken();

@GET(&quot;/user&quot;)
public Observable&lt;User&gt; getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId);

...

getToken()
    .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() {
        @Override
        public Observable&lt;User&gt; onNext(String token) {
            return getUser(token, userId);
        })
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(new Observer&lt;User&gt;() {
        @Override
        public void onNext(User user) {
            userView.setUser(user);
        }

        @Override
        public void onCompleted() {
        }

        @Override
        public void onError(Throwable error) {
            // Error handling
            ...
        }
    });
</code></pre>
<p>用一个 <code>flatMap()</code> 就搞定了逻辑，依然是一条链。看着就很爽，是吧？</p>
<h3><a id="rxbinding" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RxBinding</h3>
<p><a href="https://github.com/JakeWharton/RxBinding">RxBinding</a>  是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 <code>OnClickListener</code> 、设置 <code>TextWatcher</code> 这样的注册绑定对象的 API。</p>
<p>举个设置点击监听的例子。使用 <code>RxBinding</code> ，可以把事件监听用这样的方法来设置：</p>
<pre class="line-numbers"><code class="language-java">Button button = ...;
RxView.clickEvents(button) // 以 Observable 形式来反馈点击事件
    .subscribe(new Action1&lt;ViewClickEvent&gt;() {
        @Override
        public void call(ViewClickEvent event) {
            // Click handling
        }
    });
</code></pre>
<p>看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 <code>setOnClickListener()</code> 来实现的。然而，仅仅这一个形式的改变，却恰好就是 <code>RxBinding</code> 的目的：扩展性。通过 <code>RxBinding</code> 把点击监听转换成 <code>Observable</code> 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 <code>throttleFirst()</code> ，用于去抖动，也就是消除手抖导致的快速连环点击：</p>
<pre class="line-numbers"><code class="language-java">RxView.clickEvents(button)
    .throttleFirst(500, TimeUnit.MILLISECONDS)
    .subscribe(clickAction);
</code></pre>
<p>如果想对 <code>RxBinding</code> 有更多了解，可以去它的  <a href="https://github.com/JakeWharton/RxBinding">GitHub 项目</a>  下面看看。</p>
<h3><a id="%E5%90%84%E7%A7%8D%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>各种异步操作</h3>
<p>前面举的 <code>Retrofit</code> 和 <code>RxBinding</code> 的例子，是两个可以提供现成的 <code>Observable</code> 的库。而如果你有某些异步操作无法用这些库来自动生成 <code>Observable</code>，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现，有了之前几章的例子，这里应该不用再举例了。</p>
<h3><a id="rxbus" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RxBus</h3>
<p>RxBus 名字看起来像一个库，但它并不是一个库，而是一种模式，它的思想是使用 RxJava 来实现了 EventBus ，而让你不再需要使用 <code>Otto</code> 或者 GreenRobot 的 <code>EventBus</code>。至于什么是 RxBus，可以看 <a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/">这篇文章</a> 。顺便说一句，Flipboard 已经用 RxBus 替换掉了 <code>Otto</code> ，目前为止没有不良反应。</p>
<h2><a id="%E5%8F%82%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参考</h2>
<p><a href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/07/17</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Android_14.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Android_16.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="media/17043409056338/logo.jpeg" /></div>
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/adolphJane" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:adolphdeveloper@gmail.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="%E4%BB%A3%E7%A0%81%E4%B9%8B%E7%BE%8E.html"><strong>代码之美</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
        
            <a href="Flutter.html"><strong>Flutter</strong></a>
        
            <a href="ReactNative.html"><strong>ReactNative</strong></a>
        
            <a href="Java.html"><strong>Java</strong></a>
        
            <a href="%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91.html"><strong>音视频开发</strong></a>
        
            <a href="%E7%BD%91%E7%BB%9C.html"><strong>网络</strong></a>
        
            <a href="%E7%BD%91%E9%A1%B5.html"><strong>网页</strong></a>
        
            <a href="%E5%B7%A5%E5%85%B7-1-2.html"><strong>工具</strong></a>
        
            <a href="%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD.html"><strong>人工智能</strong></a>
        
            <a href="%E5%88%9B%E4%B8%9A.html"><strong>创业</strong></a>
        
            <a href="%E6%80%9D%E7%BB%B4%E6%8F%90%E5%8D%87.html"><strong>思维提升</strong></a>
        
            <a href="GPU%E6%B8%B2%E6%9F%93.html"><strong>GPU渲染</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16946950953153.html">Debian 关闭休眠</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16946000122919.html">Debian 查看 Linux 硬盘大小、类型和硬件信息</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945997927114.html">Debian 查看硬件温度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945994928906.html">Debian 查看Linux版本</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16945989810086.html">Debian 查看CPU和内存</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

<style>.mweb-charts{background:#fff;}
body{ box-sizing: border-box;
    margin: 0 auto;}
@media print{
    pre, code, pre code {
     overflow: visible !important;
     white-space: pre-wrap !important;       /* css-3 */
     white-space: -moz-pre-wrap !important;  /* Mozilla, since 1999 */
     white-space: -pre-wrap !important;      /* Opera 4-6 */
     white-space: -o-pre-wrap !important;    /* Opera 7 */
     word-wrap: break-word !important;       /* Internet Explorer 5.5+ */
    }
    html,body{margin:0;padding:4px;}
}



div.code-toolbar {
  position: relative;
}

div.code-toolbar > .toolbar {
  position: absolute;
  z-index: 10;
  top: .3em;
  right: .2em;
  transition: opacity 0.3s ease-in-out;
  opacity: 0;
}

div.code-toolbar:hover > .toolbar {
  opacity: 1;
}

/* Separate line b/c rules are thrown out if selector is invalid.
   IE11 and old Edge versions don't support :focus-within. */
div.code-toolbar:focus-within > .toolbar {
  opacity: 1;
}

div.code-toolbar > .toolbar > .toolbar-item {
  display: inline-block;
}

div.code-toolbar > .toolbar > .toolbar-item > a {
  cursor: pointer;
}

div.code-toolbar > .toolbar > .toolbar-item > button {
  background: none;
  border: 0;
  color: inherit;
  font: inherit;
  line-height: normal;
  overflow: visible;
  padding: 0;
  -webkit-user-select: none; /* for button */
  -moz-user-select: none;
  -ms-user-select: none;
}

div.code-toolbar > .toolbar > .toolbar-item > a,
div.code-toolbar > .toolbar > .toolbar-item > button,
div.code-toolbar > .toolbar > .toolbar-item > span {
  color: inherit;
  font-size: .8em;
  padding: 4px .5em;
  background: #f5f2f0;
  background: rgba(224, 224, 224, 0.4);
  box-shadow: 0 2px 0 0 rgba(0,0,0,0.2);
  border-radius: .5em;
}

div.code-toolbar > .toolbar > .toolbar-item > a:hover,
div.code-toolbar > .toolbar > .toolbar-item > a:focus,
div.code-toolbar > .toolbar > .toolbar-item > button:hover,
div.code-toolbar > .toolbar > .toolbar-item > button:focus,
div.code-toolbar > .toolbar > .toolbar-item > span:hover,
div.code-toolbar > .toolbar > .toolbar-item > span:focus {
  color: inherit;
  text-decoration: none;
}
</style><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script><script>!function(){if("undefined"!=typeof Prism&&"undefined"!=typeof document){var e=[],t={},n=function(){};Prism.plugins.toolbar={};var a=Prism.plugins.toolbar.registerButton=function(n,a){var r;r="function"==typeof a?a:function(e){var t;return"function"==typeof a.onClick?((t=document.createElement("button")).type="button",t.addEventListener("click",(function(){a.onClick.call(this,e)}))):"string"==typeof a.url?(t=document.createElement("a")).href=a.url:t=document.createElement("span"),a.className&&t.classList.add(a.className),t.textContent=a.text,t},n in t?console.warn('There is a button with the key "'+n+'" registered already.'):e.push(t[n]=r)},r=Prism.plugins.toolbar.hook=function(a){var r=a.element.parentNode;var l=a.element.classList;if(l.contains('language-mermaid') || l.contains('language-echarts') || l.contains('language-plantuml')){return;} if(r&&/pre/i.test(r.nodeName)&&!r.parentNode.classList.contains("code-toolbar")){var o=document.createElement("div");o.classList.add("code-toolbar"),r.parentNode.insertBefore(o,r),o.appendChild(r);var i=document.createElement("div");i.classList.add("toolbar");var l=e,d=function(e){for(;e;){var t=e.getAttribute("data-toolbar-order");if(null!=t)return(t=t.trim()).length?t.split(/\s*,\s*/g):[];e=e.parentElement}}(a.element);d&&(l=d.map((function(e){return t[e]||n}))),l.forEach((function(e){var t=e(a);if(t){var n=document.createElement("div");n.classList.add("toolbar-item"),n.appendChild(t),i.appendChild(n)}})),o.appendChild(i)}};a("label",(function(e){var t=e.element.parentNode;if(t&&/pre/i.test(t.nodeName)&&t.hasAttribute("data-label")){var n,a,r=t.getAttribute("data-label");try{a=document.querySelector("template#"+r)}catch(e){}return a?n=a.content:(t.hasAttribute("data-url")?(n=document.createElement("a")).href=t.getAttribute("data-url"):n=document.createElement("span"),n.textContent=r),n}})),Prism.hooks.add("complete",r)}}();</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.css"><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script><script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script><style>div.code-toolbar > .toolbar > .toolbar-item > a, div.code-toolbar > .toolbar > .toolbar-item > button, div.code-toolbar > .toolbar > .toolbar-item > span {padding: 4px .5em; background: #f5f2f0; background: rgba(224, 224, 224, 0.4);}</style><script>window.MathJax = {     tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } ,     startup: {     pageReady() {       return MathJax.startup.defaultPageReady().then(function () {          window.mweb_mathjax_ready_val = 'yes';          if(window.mweb_mathjax_ready !== undefined){ mweb_mathjax_ready(); }       });     }   }};document.addEventListener('DOMContentLoaded', function(event) {    if (typeof Prism != 'undefined') {         Prism.highlightAll();     }});window.mweb_mathjax_ready_val = '';function theMWebMathJaxRenderIsReady(key){ return window.mweb_mathjax_ready_val; }</script><script>window.MathJax = { tex: { tags: 'ams', inlineMath: [ ['$','$'], ['\\(','\\)'] ] } }; </script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>

<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
