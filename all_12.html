<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  MagicalRice的Blog
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
 
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:adolph.cc ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="https://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; MagicalRice的Blog</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Android.html">Android</a></li>
        
            <li><a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html">随手记</a></li>
        
            <li><a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html">服务器</a></li>
        
            <li><a href="C++.html">C++</a></li>
        
            <li><a href="UI.html">UI</a></li>
        
            <li><a href="MySQL.html">MySQL</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95.html">算法</a></li>
        
            <li><a href="Game.html">Game</a></li>
        
            <li><a href="Python.html">Python</a></li>
        
            <li><a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html">跨平台开发</a></li>
        
            <li><a href="Mac.html">Mac</a></li>
        
            <li><a href="%E5%85%B6%E4%BB%96.html">其他</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15561207871831.html">
                
                  <h1>Android-LayoutInflater（布局加载器）</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>对于LayoutInflater之前一直只会用，却不知道LayoutInflater的加载原理，每次直接</p>

<pre><code class="language-java">LayoutInflater.from(context).inflate(R.layout.activity_test, root, false);

//不行就这样，反正有一种能实现我要的效果
LayoutInflater.from(context).inflate(R.layout.activity_test, null);
</code></pre>

<p>所以，想要趁这个整理博客的机会，顺便把LayoutInflater的内容好好学习学习。</p>

<h2 id="toc_1">概述</h2>

<ul>
<li>LayoutInflater的常见使用场景</li>
<li>LayoutInflater的介绍</li>
<li>LayoutInflater相关介绍中的相关概念分析</li>
</ul>

<h2 id="toc_2">LayoutInflater的常见使用场景</h2>

<p>在介绍之前，我们先回一下，我们在哪些地方都使用过LayoutInflater：</p>

<h3 id="toc_3">在Activity中</h3>

<pre><code class="language-java">LayoutInflater inflater = getLayoutInflater();
View view = inflater.inflate(R.layout.activity_main, null);
</code></pre>

<h3 id="toc_4">在Fragment中</h3>

<pre><code class="language-java">View view = inflater.inflate(R.layout.fragment_guide_one, container, false);
return view;
</code></pre>

<h3 id="toc_5">在Adapter中</h3>

<pre><code class="language-java">@Override
public View getView(int position, View convertView, ViewGroup parent) {
    View view = LayoutInflater.from(convertView.getContext()).inflate(R.layout.activity_main, parent, false);
    return view;
}
</code></pre>

<h3 id="toc_6">在某些特殊情况下，需要使用LayoutInflater，我们是这样获得它的</h3>

<p><code>LayoutInflater inflater  =(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</code></p>

<p>上述的使用，是我们平常常见的使用方式，而这些场景都有一个特点，因为这些场景都需要将一个XML布局文件转化成View，所以准确的说<strong>LayoutInflater</strong>的主要功能来说就是布局加载。</p>

<p>其实<strong>LayoutInflater</strong>还有一些扩展操作，可以通过我们自定义的方式来实现，在后面的实战篇会介绍。</p>

<h2 id="toc_7">LayoutInflater的介绍</h2>

<p>对于LayoutInflater的介绍性质的内容，博主认为，在网上查的任何内容，都不如查阅源码，API来的靠谱一些，因为API才是第一手的介绍资料，而且Android的源码中介绍的也比较完善。</p>

<p>LayoutInflater属于 android.view包下，在LayoutInflater的头部有一段关于LayoutInflater的介绍：</p>

<p><img src="media/15561207871831/15713348568693.png" alt=""/></p>

<p>由于篇幅原因，这里只截取了一部分图片，总结一下：</p>

<ul>
<li>LayoutInflater的主要作用将XML文件实例化成相应的View对象</li>
<li>LayoutInflater在Android开发过程中，获取的方式不是直接new出来的，都是经过这两个方法得到的关联上下文的LayoutInflater：</li>
</ul>

<pre><code class="language-java">//在Activity中
LayoutInflater inflater = Activity#getLayoutInflater()
//其他情况
LayoutInflater inflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)
</code></pre>

<ul>
<li>如果想使用新的LayoutInflater来加载View，需要使用cloneInContext()，而在新的LayoutInflater需要调用setFactory()设置<strong>视图处理器</strong></li>
<li>由于性能的原因，XML文件的预处理是在Build过程中进行的。</li>
<li>LayoutInflater不能加载未编译的XML文件，而且LayoutInflater只能加载，通过XmlPullParser解析的R文件资源。</li>
</ul>

<h2 id="toc_8">LayoutInflater介绍相应的解释</h2>

<p>经过上面的总结，大家对LayoutInflater有一个大致的认识，为了大家不是太懵逼，让我一一解释一波。</p>

<h3 id="toc_9">LayoutInflater的主要作用将XML文件实例化成相应的对象</h3>

<p>其实，大家在使用LayoutInflater时，也会注意到无非就是将布局资源通过LayoutInflater转换为相对应的View，然后在进行一些其他操作,就是<strong>LayoutInflater常见场景</strong>中的几种情况：</p>

<pre><code class="language-java">View view = inflater.inflate(R.layout.fragment_guide_one, container, false);
return view;
</code></pre>

<h3 id="toc_10">LayoutInflater在Android开发过程中，不是通过new出来获取到的？</h3>

<p>在上述场景中，除了介绍的两种方式Activity#getLayoutInflater()，以及getSystemService()，大家发现常见场景中还使用了</p>

<p><code>LayoutInflater inflater =LayoutInflater.from(convertView.getContext())；</code></p>

<p>其实LayoutInflater.from()这个方法是官方帮我们封装了一层而已，底层还是调用getSystemService()方法，目的是使LayoutInflater与Context对象相绑定：</p>

<pre><code class="language-java">public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre>

<h3 id="toc_11">如果想使用新的LayoutInflater来加载，需要使用cloneInContext()，而在新的LayoutInflater需要调用setFactory()设置视图处理器</h3>

<p>正常来说，这种使用方式的使用场景现在也是比较多的，比如：</p>

<ol>
<li>批量获取XML中自定义的属性</li>
<li>动态换肤的效果</li>
<li>动态改变布局中的元素</li>
</ol>

<p>这些都是通过LayoutInflater中的Factory来实现的，而介绍这部分内容会在实战篇来介绍。</p>

<h3 id="toc_12">由于性能的原因，XML文件的预处理是在Build过程中进行的</h3>

<p>举个例子，在编写XML布局资源时，如果漏写了结束符号，或者一些奇怪的操作，在运行程序之前的Build（构建阶段），就会弹出报错。</p>

<p>这里故意将结束符，写错</p>

<pre><code class="language-markup">&lt;TextView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;center_horizontal&quot;
    android:textSize=&quot;20sp&quot; /
</code></pre>

<p>这里就会收到报错信息提示，每个XML都会有一个预编译的过程，这个过程发生在构建阶段（Build），而不是运行时。</p>

<p><img src="media/15561207871831/15713348644088.png" alt=""/></p>

<h3 id="toc_13">LayoutInflater只能加载通过XmlPullParser解析的R文件资源</h3>

<p>这里的R文件资源就是指这些资源文件<br/><br/>
例如：</p>

<pre><code class="language-text">R.layout.xxxx
R.drawable.xxxx
R.color.xxx
R.string.xxx
</code></pre>

<h2 id="toc_14">二级概述</h2>

<ul>
<li>Activity 的 getSystemService的实现过程</li>
<li>LayoutInflater 如果将布局资源转换为 View 的过程</li>
<li>LayoutInflater的 Factory，Factory2是什么，在解析过程中的作用是什么？</li>
<li>LayoutInflater 的 inflater 方法的各个参数的含义，不同的情况的含义</li>
</ul>

<h2 id="toc_15">LayoutInflater的构造方法</h2>

<pre><code class="language-java">protected LayoutInflater(Context context) {
    mContext = context;
}
</code></pre>

<p>这种是LayoutInflater常规的构造方法，将Context传入，最后生成的LayoutInflater与对应的Context相绑定。</p>

<pre><code class="language-java">protected LayoutInflater(LayoutInflater original, Context newContext) {
    mContext = newContext;
    mFactory = original.mFactory;
    mFactory2 = original.mFactory2;
    mPrivateFactory = original.mPrivateFactory;
    setFilter(original.mFilter);
}
</code></pre>

<p>而这种构造方法来说，只是复制原LayoutInflater的内容，然后将Context对象替换，一般来说只会在cloneInContext()方法中使用。</p>

<h2 id="toc_16">LayoutInflater#form()方法分析</h2>

<p>根据介绍篇的内容，LayoutInflater在Android开发中一般是通过</p>

<pre><code class="language-java">context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

LayoutInflater.from(context);
</code></pre>

<p>因为第一种方式，已经是LayoutInflater介绍中声明获取的方式之一，那么这里我们看一下LayoutInflater#form的方法。</p>

<pre><code class="language-java">public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre>

<p>从源码上看，LayoutInflater#form()方法内部也是通过getSystemService()方法获得，那么接下来我们看一下context#getSystemService()这个方法：</p>

<p><code>public abstract Object getSystemService(@ServiceName @NonNull String name);</code></p>

<p>发现这个只是一个抽象方法，而我们知道Activity也是Context的一个实现。</p>

<p>Activity#getSystemService()这个方法：</p>

<pre><code class="language-java">@Override
public Object getSystemService(@ServiceName @NonNull String name) {
    if (getBaseContext() == null) {
        throw new IllegalStateException(
            &quot;System services not available to Activities before onCreate()&quot;);
    }
    //获取WindowManager
    if (WINDOW_SERVICE.equals(name)) {
        return mWindowManager;
        //系统的搜索框SearchManager
    } else if (SEARCH_SERVICE.equals(name)) {
        ensureSearchManager();
        return mSearchManager;
    }
    return super.getSystemService(name);
}
</code></pre>

<p>从上面看到，在Activity中只处理了两种类型的服务，分别是获取WindowManager、获取SearchManager，那我们接着看其父类的SystemService()方法：</p>

<pre><code class="language-java">@Override
public Object getSystemService(String name) {
    //找到我们要的东西，注意这是个单例
    if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        if (mInflater == null) {
            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);
        }
        return mInflater;
    }
    return getBaseContext().getSystemService(name);
}
</code></pre>

<p>在Activity的父类即ContextThemeWrapper的getSystemService()方法中，我们发现了LayoutInflater的创建过程，从上面的代码我们可以看出：</p>

<p>每个Activity内包含的LayoutInflater是一个单例。</p>

<p>Activity创建LayoutInflater时，是先使用最原始的BaseContext创建，然后在将Activity的父类ContextThemeWrapper的信息通过cloneInContext()方法与其绑定。</p>

<p>然后我们在看下LayoutInflater的cloneInContext的实现：</p>

<p><code>public abstract LayoutInflater cloneInContext(Context newContext);</code></p>

<p>先看下，这个方法的介绍：</p>

<p><img src="media/15561207871831/15713349011719.png" alt=""/></p>

<p>这个方法通过现有的LayoutInflater创建一个新的LayoutInflater副本，唯一变化的地方是指向不同的上下文对象。</p>

<p>在ContextThemeWrapper通过这个方法创建的新的LayoutInflater还包含了主题的信息。</p>

<p>在ContextThemeWrapper中使用cloneInContext是想将更多的信息，赋予LayoutInflater中，与其相互绑定。</p>

<h1 id="toc_17">Activity中LayoutInflater创建</h1>

<p>对于Activity的LayoutInflater，其实在Activity创建之时就已经创建完成，但是这一块内容属于FrameWork层的内容，博主道行太浅了，只想带大家看下from这个方法的实现过程。</p>

<p>这里如果大家想了解可以参考下这篇文章</p>

<p><a href="http://blog.csdn.net/u014486880/article/details/50707672">LayoutInflater源码解析</a></p>

<p>而Activity#getLayoutInflater方法：</p>

<pre><code class="language-java">@NonNull
public LayoutInflater getLayoutInflater() {
    return getWindow().getLayoutInflater();
}
</code></pre>

<p>这个Window对象即PhoneWindow，此时创建出来的LayoutInflater即PhoneLayoutInflater。</p>

<p>这里给大家看下PhoneLayoutInflater的cloneInContext()方法：</p>

<pre><code class="language-java">public LayoutInflater cloneInContext(Context newContext) {
    return new PhoneLayoutInflater(this, newContext);
}

protected PhoneLayoutInflater(LayoutInflater original, Context newContext) {
    super(original, newContext);
}
</code></pre>

<p>可以发现PhoneLayoutInflater中cloneInContext()的实现，调用了第二个构造方法。</p>

<p>这里在Android Studio是无法查阅的，有条件的可以下载源码，如果下载源码麻烦，可以在这里查阅。</p>

<p><a href="http://androidxref.com/">Android源码查看网址</a></p>

<h2 id="toc_18">将R.layout.xxx转换为View的过程分析</h2>

<p>其实这个过程即LayoutInflater.inflater()这个过程：</p>

<pre><code class="language-java">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {

    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre>

<p>在这个方法中，只是先拿到XmlResourceParser，用于后续节点的解析，我们接着往下看：</p>

<p>这里只看一些关键的信息，具体代码大家自行查看</p>

<pre><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {

    //》》》》》》》》》》》》》》》》》第一部分》》》》》》》》》》》》》》》》》》》
    try {
        while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
        // Empty
        }

        if (type != XmlPullParser.START_TAG) {
            throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;);
        }

        final String name = parser.getName()
        //》》》》》》》》》》》》》》》》》第二部分》》》》》》》》》》》》》》》》》》》
        if (TAG_MERGE.equals(name)) {
            if (root == null || !attachToRoot) {
                throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;);
            }

            rInflate(parser, root, inflaterContext, attrs, false);
        } else {
            //》》》》》》》》》》》》》》》》》第三部分》》》》》》》》》》》》》》》》》》》
            final View temp = createViewFromTag(root, name, inflaterContext, attrs);

            ViewGroup.LayoutParams params = null;

            if (root != null) {
                params = root.generateLayoutParams(attrs);
                if (!attachToRoot) {
                    temp.setLayoutParams(params);
                }
            }

            rInflateChildren(parser, temp, attrs, true);

            if (root != null &amp;&amp; attachToRoot) {
                root.addView(temp, params);
            }

            if (root == null || !attachToRoot) {
                result = temp;
            }
        }
        return result;
    }
}
</code></pre>

<h3 id="toc_19">第一部分：</h3>

<p>这里第一部分的内容，主要是一个XML文件的读取过程，这里有两个判断：</p>

<ul>
<li>遍历XML内容寻找XML标签的开始的标志或者文档结尾的标志才可以跳出循环。</li>
<li>如果该XML没有开始的标识，则抛出异常。</li>
</ul>

<p>下面给大家介绍下，几种常见的解析标识：</p>

<pre><code class="language-text">XmlPullParser.START_DOCUMENT                                    文档开始

XmlPullParser.END_DOCUMENT                                      文档结束

XmlPullParser.START_TAG                                         XML标签的开始

XmlPullParser.END_TAG                                           XML标签的结束

XmlPullParser.TEXT                                              XML标签的内容
</code></pre>

<h3 id="toc_20">第二部分</h3>

<p>这部分的一开始先进行了Merge标签的检验，如果发现该节点是Merge，必须满足父View存在，并且与父View绑定的状态。</p>

<p>转换为代码:</p>

<p><code>root ！= null &amp;&amp; attachToRoot ==true</code></p>

<p>这里Merge是减少布局层级存在的标签，通常和include标签一起使用，所以其必须存在父View，而且merge标签的内容必须与父View绑定。</p>

<p>这里调用rInflate()方法去解析Merge的标签，而rInflate()方法，在另一篇文章已经单独分析。</p>

<p><a href="http://blog.csdn.net/l540675759/article/details/78017065">Android 中LayoutInflater（布局加载器）源码篇之rInflate方法</a></p>

<h3 id="toc_21">第三部分</h3>

<p>我们再看一下第三部分的代码，代码中会有一些简要的说明：</p>

<pre><code class="language-java">//》》》》》》》》》》》》》》》》》第三部分》》》》》》》》》》》》》》》》》》》
//createViewFromTag是一个根据name来创建View的方法
                    final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                    ViewGroup.LayoutParams params = null;

                    if (root != null) {
                        params = root.generateLayoutParams(attrs);
                        if (!attachToRoot) {
                            temp.setLayoutParams(params);
                        }
                    }
                    //解析子标签
                    rInflateChildren(parser, temp, attrs, true);

                    if (root != null &amp;&amp; attachToRoot) {
                        root.addView(temp, params);
                    }

                    if (root == null || !attachToRoot) {
                        result = temp;
                    }
                }
            return result;
        }

</code></pre>

<p>将第三部分内容分拆一下主要分为以下几块内容：</p>

<ul>
<li>排除标签为include，或者merge之后，就会通过createViewFromTag()方法来创建View</li>
<li>root是inflater()方法的第二个参数，而attachToRoot是第三个参数，最后会根据这两个参数来决定返回的View</li>
</ul>

<p>在这部分中，<code>createViewFromTag()</code>是根据name（名称），来创建View的一个方法。</p>

<p>接下来，我们要介绍的是inflater()方法中的参数，到底有什么作用？</p>

<pre><code class="language-java">
                    ViewGroup.LayoutParams params = null;
                    //当Root存在
                    if (root != null) {
                        params = root.generateLayoutParams(attrs);
                        if (!attachToRoot) {
                            //设置View在父布局下Params
                            temp.setLayoutParams(params);
                        }
                    }
                    //遍历子节点
                    rInflateChildren(parser, temp, attrs, true);

                    //如果Root存在并且attachToRoot为true，即与父View绑定
                    //这里在解析的同时，就会将其添加至父View上
                    if (root != null &amp;&amp; attachToRoot) {
                        root.addView(temp, params);
                    }

                    //如果父Viewwe为null或者没有绑定父View都会将当前解析的View返回，否则返回父View
                    if (root == null || !attachToRoot) {
                        result = temp;
                    }
                }
</code></pre>

<p>仔细分析上述代码，可以得出如下结论：</p>

<p>从这段代码中，得出以下几个结论：</p>

<ol>
<li>当root为null时，attachToRoot参数无效，而解析出的View作为一个独立的View存在（不存在LayoutParams）。</li>
<li>当root不为null时，attactToRoot为false，那么会给该View设置一个父View的约束（LayoutParams），然后将其返回。</li>
<li>当root不为null时，attactToRoot为true，那么该View会被直接addView进父View，然后会将父View返回。</li>
<li>当root不为null的话，attactToRoot的默认值是true。</li>
</ol>

<pre><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root) {
    return inflate(parser, root, root != null);
}
</code></pre>

<p>上面的代码中，我们还少分析了一处代码rInflateChildren()，即解析子类：</p>

<pre><code class="language-java">final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,boolean finishInflate) throws XmlPullParserException, IOException {
    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);
}
</code></pre>

<p>如果你之前没看过这段代码，其实你会像博主之前一样，一直在试，而不知道这段代码正确的含义，但是有时候源码会是一个很好的老师，通过它能够得到你想要的。</p>

<h2 id="toc_22">流程图</h2>

<p><img src="media/15561207871831/15713349276858.png" alt=""/></p>

<h2 id="toc_23">CreateViewFromTag源码解析</h2>

<pre><code class="language-java">private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) {
    return createViewFromTag(parent, name, context, attrs, false);
}
</code></pre>

<p>createViewFromTag在LayoutInflater中存在重载，最终还是会调用5个参数的createViewFromTag方法。</p>

<pre><code class="language-java">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,boolean ignoreThemeAttr) {

    //解析view标签
    if (name.equals(&quot;view&quot;)) {
        name = attrs.getAttributeValue(null, &quot;class&quot;);
    }

    //如果需要该标签与主题相关，需要对context进行包装，将主题信息加入context包装类ContextWrapper
    if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
            ta.recycle();
        }

        //BlinkLayout是一种闪烁的FrameLayout，它包裹的内容会一直闪烁，类似QQ提示消息那种。
        if (name.equals(TAG_1995)) {
            return new BlinkLayout(context, attrs);
        }

        //设置Factory，来对View做额外的拓展，这块属于可定制的内容
        try {
            View view;
            if (mFactory2 != null) {
                view = mFactory2.onCreateView(parent, name, context, attrs);
            } else if (mFactory != null) {
                view = mFactory.onCreateView(name, context, attrs);
            } else {
                view = null;
            }
            if (view == null &amp;&amp; mPrivateFactory != null) {
                view = mPrivateFactory.onCreateView(parent, name, context, attrs);
            }

            //如果此时不存在Factory，不管Factory还是Factory2，还是mPrivateFactory都不存在，那么会直接对name直接进行解析
            if (view == null) {
                final Object lastContext = mConstructorArgs[0];
                mConstructorArgs[0] = context;
                try {
                    //如果name中包含.即为自定义View，否则为原生的View控件
                    if (-1 == name.indexOf(&#39;.&#39;)) {
                        view = onCreateView(parent, name, attrs);
                    } else {
                        view = createView(name, null, attrs);
                    }
                } finally {
                    mConstructorArgs[0] = lastContext;
                }
            }

        return view;
</code></pre>

<p>根据源码可以将createViewFromTag分为三个流程：</p>

<ul>
<li>对一些特殊标签，做分别处理，例如：view，TAG_1995(blink)</li>
<li>进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View</li>
<li>如果没有设置Factory或Factory2，那么就会使用LayoutInflater默认的生成方式，进行View的生成</li>
</ul>

<h3 id="toc_24">createViewFromTag分析过程：</h3>

<h4 id="toc_25">处理view标签</h4>

<p>如果标签的名称是view，注意是小写的view，这个标签一般大家不太常用，具体的使用情况如下：</p>

<pre><code class="language-text">&lt;view
    class=&quot;RelativeLayout&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;&lt;/view&gt;
</code></pre>

<p>在使用时，相当于所有控件标签的父类一样，可以设置class属性，这个属性会决定view这个节点会变成什么控件。</p>

<h4 id="toc_26">如果该节点与主题相关，则需要特殊处理</h4>

<p>如果该节点与主题（Theme）相关，需要将context与theme信息包装至ContextWrapper类。</p>

<h4 id="toc_27">处理TAG_1995标签</h4>

<p>这就有意思了，TAG_1995指的是blink这个标签，这个标签感觉使用的很少，以至于大家根本不知道。</p>

<p>这个标签最后会被解析成BlinkLayout，BlinkLayout其实就是一个FrameLayout，这个控件最后会将包裹内容一直闪烁(就和电脑版QQ消息提示一样)，有空大家可以自行尝试下，很简单，下面贴一下用法：</p>

<pre><code class="language-text">&lt;blink
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;这个标签会一直闪烁&quot;/&gt;
&lt;/blink&gt;
</code></pre>

<h4 id="toc_28">判断其是否存在Factory或者Factory2</h4>

<p>在这里先对Factory进行判空，这里不管Factory还是Factory2（mPrivateFactory 就是Factory2），本质上都是一种扩展操作，提前解析name，然后直接将解析后的View返回。</p>

<h5 id="toc_29">Factory</h5>

<pre><code class="language-java">public interface Factory {
    public View onCreateView(String name, Context context, AttributeSet attrs);
}
</code></pre>

<h5 id="toc_30">Factory2</h5>

<pre><code class="language-java">public interface Factory2 extends Factory {
    public View onCreateView(View parent, String name, Context context, AttributeSet attrs);
}
</code></pre>

<p>从这里可以看出，Factory2和Factory都是一个接口，需要自己实现，而Factory2和Factory的区别是Factory2继承Factory，从而扩展出一个参数，就是增加了该节点的父View。</p>

<p>这里我自定义了一个Factory，下面自定义解析View的过程：</p>

<pre><code class="language-java">@Override
public View onCreateView(String name, Context context, AttributeSet attrs) {
    View view = null;
    try {
        if (-1 == name.lastIndexOf(&quot;.&quot;)) {
            if (name.equals(&quot;View&quot;) || name.equals(&quot;ViewGroup&quot;)) {
                view = mInflater.createView(name, &quot;android.view.&quot;, attrs);
            } else {
                view = mInflater.createView(name, &quot;android.widget.&quot;, attrs);
            }
        } else {
            if (name.contains(&quot;.&quot;)) {
                String checkName = name.substring(name.lastIndexOf(&quot;.&quot;));
                String prefix = name.substring(0, name.lastIndexOf(&quot;.&quot;));
                view = mInflater.createView(checkName, prefix, attrs);
            }
        }

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }

        if(view != null){
            //在这里可以对View做一些额外的操作，并且能够获得View的属性集，可以做一些自定义操作。
            view.xxxxxx
        }

        return view;
}
</code></pre>

<p>从上面可以看出，Factory和Factory2其实LayoutInflater解析View时的一种扩展实现，在这里可以额外的对View处理，设置Factory和Factory2需要通过setFactory()或者setFactory2()来实现。</p>

<p><strong>setFactory()</strong></p>

<pre><code class="language-java">public void setFactory(Factory factory) {
    //如果已经设置Factory，不可以继续设置Factory
    if (mFactorySet) {
        throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;);
    }
    if (factory == null) {
        throw new NullPointerException(&quot;Given factory can not be null&quot;);
    }
    //设置Factory会添加一个标记
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = factory;
    } else {
        mFactory = new FactoryMerger(factory, null, mFactory, mFactory2);
    }
}
</code></pre>

<p><strong>setFactory2()</strong></p>

<pre><code class="language-java">public void setFactory2(Factory2 factory) {
    if (mFactorySet) {
        throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;);
    }
    if (factory == null) {
        throw new NullPointerException(&quot;Given factory can not be null&quot;);
    }
    //注意设置Factory和Factory2的标记是共用的
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = mFactory2 = factory;
    } else {
        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);
    }
}
</code></pre>

<p>通过上面代码可以看出，Factory和Factory2只能够设置一次，并且Factory和Factory2二者互斥，只能存在一个。</p>

<p>所以一般setFactory()或者setFactory2()，一般在cloneInContext()之后设置，这样生成一个新的LayoutInflater，标记默认是false，才能够设置。</p>

<h4 id="toc_31">LayoutInflater内置的解析过程</h4>

<p>如果Factory或者Factory2没有设置，或者返回View为null，才会使用默认解析方式。</p>

<pre><code class="language-text">if (-1 == name.indexOf(&#39;.&#39;)) {
    view = onCreateView(parent, name, attrs);
} else {
    view = createView(name, null, attrs);
}
</code></pre>

<p>这段就是对自定义View和原生的控件进行判断，这里给大家说明下原生控件和自定义View的name区别：</p>

<pre><code class="language-text">原生 ：  RelativeLayout
自定义View ： com.demo.guidepagedemo.customview.CustomImageView
</code></pre>

<p>原生控件的解析方式 onCreateView ：</p>

<pre><code class="language-java">protected View onCreateView(View parent, String name, AttributeSet attrs) throws ClassNotFoundException {
    return onCreateView(name, attrs);
}
</code></pre>

<p>然后调用的还是2个参数的onCreateView()方法</p>

<pre><code class="language-java">protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {
    return createView(name, &quot;android.view.&quot;, attrs);
}
</code></pre>

<p>可以看到最终方法的指向还是调用createView方法：</p>

<pre><code class="language-java">public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException {
    //判断构造器是否存在    
    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);
    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class&lt;? extends View&gt; clazz = null;

    try {
        //如果构造器不存在，这个就相当于Class之前是否被加载过，sConstructorMap就是缓存这些Class的Map
        if (constructor == null) {
            //通过前缀+name的方式去加载
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            //通过过滤去设置一些不需要加载的对象
            if (mFilter != null &amp;&amp; clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            //缓存Class
            sConstructorMap.put(name, constructor);
        } else {
            //如果Class存在，并且加载Class的ClassLoader合法
            //这里先判断该Class是否应该被过滤
            if (mFilter != null) {
                //过滤器也有缓存之前的Class是否被允许加载，判断这个Class的过滤状态
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    //加载Class对象操作
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    //判断Class是否可被加载
                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }

        Object[] args = mConstructorArgs;
        args[1] = attrs;

        //如果过滤器不存在，直接实例化该View
        final View view = constructor.newInstance(args);
        //如果View属于ViewStub那么需要给ViewStub设置一个克隆过的LayoutInflater
        if (view instanceof ViewStub) {
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    }
}
</code></pre>

<p>上面代码有点长，就直接在代码里面加注释了，这里额外说一下这个方法：</p>

<p>判断ClassLoader是否安全的verifyClassLoader ：</p>

<pre><code class="language-java">private final boolean verifyClassLoader(Constructor&lt;? extends View&gt; constructor) {
    final ClassLoader constructorLoader = constructor.getDeclaringClass().getClassLoader();
    if (constructorLoader == BOOT_CLASS_LOADER) {
        //这里注意BootClassLoader是相当于所有派生出来的ClassLoader的原始基类，所有的ClassLoader都是根据其衍生的。
        return true;
    }
    //这里是一个遍历操作，一直在遍历加载mContext的ClassLoader的继承树，一直在往上寻找，如果
    //constructor的ClassLoader与继承树中某个ClassLoader相同就说明这个ClassLoader是安全的
    ClassLoader cl = mContext.getClassLoader();
    do {
        if (constructorLoader == cl) {
            return true;
        }
        cl = cl.getParent();
    } while (cl != null);
        return false;
    }
}
</code></pre>

<p>这里简单说明下，几种ClassLoader的作用：</p>

<ul>
<li>BootClassLoader 加载Android FrameWork层的一些字节码文件</li>
<li>PathClassLoader 加载已经安装到系统上的应用App（apk）上的字节码文件</li>
<li>DexClassLoader 加载指定目录中的Class字节码文件</li>
<li>BaseDexClassLoader 是PathClassloader和DexClassLoader的父类</li>
</ul>

<p>一般的App刚启动的时候，就会有两个ClassLoader被加载，分别是PathClassLoader、DexClassLoader而这两个ClassLoader都是继承BaseDexClassLoader.</p>

<p>而BaseDexClassLoader继承的是ClassLoader，但是在ClassLoader中getParent()方法赋予其Parent为BootClassLoader，这个如果大家感兴趣，可以自行查阅ClassLoader。</p>

<h2 id="toc_32">流程图</h2>

<p><img src="media/15561207871831/15713350767455.jpg" alt=""/></p>

<h2 id="toc_33">rInflate()的源码分析</h2>

<pre><code class="language-java">void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {

    //获取该标签的深度
    final int depth = parser.getDepth();
    int type;

    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {

        if (type != XmlPullParser.START_TAG) {
            continue;
        }

        final String name = parser.getName();

        //如果该节点为requestFocus
        if (TAG_REQUEST_FOCUS.equals(name)) {
            parseRequestFocus(parser, parent);
            //如果该节点为tag
        } else if (TAG_TAG.equals(name)) {
            parseViewTag(parser, parent, attrs);
            //如果该节点为include标签
        } else if (TAG_INCLUDE.equals(name)) {
            if (parser.getDepth() == 0) {
                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
            }
            //解析include标签
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
            //如果该节点为Merge
            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);
        } else {
            //否则属于正常的View
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            //接下来解析子View
            rInflateChildren(parser, view, attrs, true);
            //注意这里直接进行addView操作
            viewGroup.addView(view, params);
        }
    }

    //如果解析完成，需要通知父View，解析完成。
    if (finishInflate) {
        parent.onFinishInflate();
    }
}
</code></pre>

<p>在rInflate这里做的操作，就是识别这些节点，然后对应解析形成响应的元素，下面我们会根据代码，一段一段分析rInflate都做了什么.</p>

<ul>
<li>如果发现requestFocus标签，则调用父View的requestFocus()方法。</li>
</ul>

<p><strong>requestFocus标签使用</strong>：</p>

<pre><code class="language-text">&lt;EditText  
    android:id=&quot;@+id/text&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;wrap_content&quot; &gt;  
    &lt;!-- 当前控件处于焦点状态 --&gt;  
&lt;requestFocus /&gt;  
</code></pre>

<p><strong>parseRequestFocus方法</strong>：</p>

<pre><code class="language-java">private void parseRequestFocus(XmlPullParser parser, View view) throws XmlPullParserException, IOException {
    //调用其父View的requestFocus（）方法
    view.requestFocus();
    consumeChildElements(parser);
}
</code></pre>

<ul>
<li>如果发现tag标签，为其设置（key，value）模式的tag。</li>
</ul>

<p><strong>tag标签使用</strong>：</p>

<pre><code class="language-text">&lt;Button
    android:id=&quot;@+id/tag_btn&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:onClick=&quot;openClickNotification&quot;
    android:text=&quot;自定义带监听事件的通知&quot;&gt;

    &lt;tag
        android:id=&quot;@+id/tag_id&quot;
        android:value=&quot;@string/app_name&quot; /&gt;
&lt;/Button&gt;
</code></pre>

<p><strong>parseViewTag</strong>方法 ：</p>

<pre><code class="language-java">private void parseViewTag(XmlPullParser parser, View view, AttributeSet attrs) throws XmlPullParserException, IOException {
    final Context context = view.getContext();
    final TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.ViewTag);
    //这里设置tag的key
    final int key = ta.getResourceId(R.styleable.ViewTag_id, 0);
    //这里设置tag的value
    final CharSequence value = ta.getText(R.styleable.ViewTag_value);
    view.setTag(key, value);
    ta.recycle();
    consumeChildElements(parser);
}
</code></pre>

<p>在parseViewTag()方法中，会把（key，value）形式的tag赋予View。</p>

<p>Key指的是R.id.tag_id对应的int类型数据；</p>

<p>Value指的是R.string.app_name的String类型数据；</p>

<ul>
<li>如果是Include标签，这里开始先获取了Include的深度</li>
</ul>

<p><code>final int depth = parser.getDepth();</code></p>

<p>所谓深度就是XML的层级关系，例如这样：</p>

<pre><code class="language-text">&lt;!-- outside --&gt;     
&lt;root&gt;                     
   sometext                
   &lt;foobar&gt;                    
    &lt;/foobar&gt;                  
&lt;/root&gt;                    
&lt;!-- outside --&gt;     
</code></pre>

<p>判断该Include标签的深度是否是0，如果为0，则抛出异常，因为include不能为根元素。</p>

<ul>
<li><p>如果是Merge标签，那么会直接抛出异常，因为Merge必须为根元素，也就是深度为0的节点。</p></li>
<li><p>最后是其他标签，例如View，一起其他的一些标签</p></li>
</ul>

<pre><code class="language-java">final View view = createViewFromTag(parent, name, context, attrs);
final ViewGroup viewGroup = (ViewGroup) parent;
final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
rInflateChildren(parser, view, attrs, true);
viewGroup.addView(view, params);
</code></pre>

<p>在加载View的过程，大致分为三个阶段：</p>

<ul>
<li>createViewFromTag() 见名知意，根据节点名称创建View</li>
<li>rInflateChildren() 加载该节点内子类</li>
<li>parent.addView() 最后将该View添加进Parent布局</li>
</ul>

<h3 id="toc_34">第一阶段 : createViewFromTag()</h3>

<p>createViewFromTag()是根据name(节点名称)来解析出View的一个方法</p>

<h3 id="toc_35">第二阶段 ：rInflateChildren()</h3>

<pre><code class="language-java">final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,boolean finishInflate) throws XmlPullParserException, IOException {
    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);
}
</code></pre>

<p>这里可以看到，这里会将解析出来的View作为Root(父View)，继续进行子节点的解析，会继续调用，直到无法解析。</p>

<p>这里的无法解析是指：</p>

<ul>
<li>当前解析的标识为XmlPullParser.END_TAG（节点结束的标识符），并且深度不在父节点的标签内。</li>
<li>或者type 为 XmlPullParser.END_DOCUMENT（文档结束的标识符）。</li>
</ul>

<h3 id="toc_36">第三阶段 parent.addView()将View添加进父View中</h3>

<p><code>viewGroup.addView(view, params);</code></p>

<p>这段话，不难理解，就是将解析出的View，添加到父View中。</p>

<h2 id="toc_37">流程图</h2>

<p><img src="media/15561207871831/15713350890413.jpg" alt=""/></p>

<h2 id="toc_38">parseInclude()是在哪里使用的？</h2>

<pre><code class="language-java">void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {
    //----------------省略部分代码--------------------//

} else if (TAG_INCLUDE.equals(name)) {
    if (parser.getDepth() == 0) {
        throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
    }
    parseInclude(parser, context, parent, attrs);
}
//----------------省略部分代码--------------------//
}
</code></pre>

<p>从上来代码中，可以发现parseInclude()是在rInflate()中出现，作用是处理当前节点是Include标签时的状况。</p>

<h2 id="toc_39">parseInclude()源码解析</h2>

<pre><code class="language-java"> //参数说明：
 // parser      解析布局的解析器
 // context     当前加载布局的上下文对象
 // parent      父容器
 // attrs       属性集合（XML该节点的属性集合）
 private void parseInclude(XmlPullParser parser, Context context, View parent,
            AttributeSet attrs) throws XmlPullParserException, IOException {
        int type;

        // 判断 Include标签是否在 ViewGroup容器之内，因为 include 标签只能存在于 ViewGroup 容器之内。

        if (parent instanceof ViewGroup) {

            //------------------&lt;第一部分&gt;-------------------//

            //当开发者设置 include 主题属性时，可以覆盖被 include 包裹View的主题属性。
            //但是这种操作很少会使用。
            //所以如果被包裹 View 设置主题属性，我们在设置就会出现覆盖效果。
            //以 include 标签的主题属性为最终的主题属性

            //提取出 include 的 thme 属性，如果设置了 them 属性，那么include 包裹的View 设置的 theme 将会无效
            final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
            final int themeResId = ta.getResourceId(0, 0);
            final boolean hasThemeOverride = themeResId != 0;
            if (hasThemeOverride) {
                context = new ContextThemeWrapper(context, themeResId);
            }
            ta.recycle();


            //------------------&lt;第二部分&gt;-------------------//

            //如果这个属性是指向主题中的某个属性，我们必须设法得到主题中layout 的资源标识符
            //先获取 layout 属性（资源 id）是否设置
            int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
            if (layout == 0) {
            //如果没直接设置布局的资源 id，那么就检索?attr/name这一类的 layout 属性
                final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
                if (value == null || value.length() &lt;= 0) {
                    throw new InflateException(&quot;You must specify a layout in the&quot;
                            + &quot; include tag: &lt;include layout=\&quot;@layout/layoutID\&quot; /&gt;&quot;);
                }

                //从  ?attr/name 这一类的属性中，获取布局属性  
                layout = context.getResources().getIdentifier(value.substring(1), null, null);
            }

            //这个布局资源也许存在主题属性中，所以需要去主题属性中解析
            if (mTempValue == null) {
                mTempValue = new TypedValue();
            }
            if (layout != 0 &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, true)) {
                layout = mTempValue.resourceId;
            }


            //------------------&lt;第三部分&gt;-------------------//

            if (layout == 0) {
                final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
                throw new InflateException(&quot;You must specify a valid layout &quot;
                        + &quot;reference. The layout ID &quot; + value + &quot; is not valid.&quot;);
            } else {
                final XmlResourceParser childParser = context.getResources().getLayout(layout);

                try {
                    final AttributeSet childAttrs = Xml.asAttributeSet(childParser);

                    while ((type = childParser.next()) != XmlPullParser.START_TAG &amp;&amp;
                            type != XmlPullParser.END_DOCUMENT) {
                        // Empty.
                    }

                    if (type != XmlPullParser.START_TAG) {
                        throw new InflateException(childParser.getPositionDescription() +
                                &quot;: No start tag found!&quot;);
                    }

                    final String childName = childParser.getName();

                    if (TAG_MERGE.equals(childName)) {
                        //解析 Meger 标签
                        rInflate(childParser, parent, context, childAttrs, false);
                    } else {
                        //根据 name名称来创建View
                        final View view = createViewFromTag(parent, childName,
                                context, childAttrs, hasThemeOverride);
                        final ViewGroup group = (ViewGroup) parent;


                        //获取 View 的 id 和其 Visiable 属性
                        final TypedArray a = context.obtainStyledAttributes(
                                attrs, R.styleable.Include);
                        final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);
                        final int visibility = a.getInt(R.styleable.Include_visibility, -1);
                        a.recycle();

                        //需要将 Parent中的 LayoutParams 设置为其 Params 属性。
                        //如果 Parent 没有通用的 Params，那么就会抛出Runtime 异常

                        //然后会为其设置 include 包裹内容的通用 Params，

                        ViewGroup.LayoutParams params = null;
                        try {
                            params = group.generateLayoutParams(attrs);
                        } catch (RuntimeException e) {
                            // Ignore, just fail over to child attrs.
                        }
                        if (params == null) {
                            params = group.generateLayoutParams(childAttrs);
                        }
                        view.setLayoutParams(params);

                        // 解析子标签
                        rInflateChildren(childParser, view, childAttrs, true);

                        if (id != View.NO_ID) {
                            view.setId(id);
                        }

                        // 加载include内容时，需要直接设置其 可见性
                        switch (visibility) {
                            case 0:
                                view.setVisibility(View.VISIBLE);
                                break;
                            case 1:
                                view.setVisibility(View.INVISIBLE);
                                break;
                            case 2:
                                view.setVisibility(View.GONE);
                                break;
                        }
                        //添加至父容器中
                        group.addView(view);
                    }
                } finally {
                    childParser.close();
                }
            }
        } else {
            throw new InflateException(&quot;&lt;include /&gt; can only be used inside of a ViewGroup&quot;);
        }

LayoutInflater.consumeChildElements(parser);
    }
</code></pre>

<p>先把parseInclude()这个方法全景先看下，然后我们在进行分拆，一部分一部分分析。</p>

<h2 id="toc_40">parseInclude()参数解读</h2>

<p>parseInclude()中分别含义四个参数：</p>

<h3 id="toc_41">解析器 -&gt; XmlPullParser parser</h3>

<p>用来解析XML文件的解析器，通过解析器可以得到当前节点的相对应的AttributeSet（属性集）</p>

<h3 id="toc_42">上下文对象 - &gt; Context context</h3>

<p>当前加载该XML的上下文对象，并且这个Context与LayoutInflater属于相互绑定关系（一一对应）</p>

<h3 id="toc_43">父容器 - &gt; View parent</h3>

<p>包裹该节点的父容器，一般来说都是继承ViewGroup实现的视图组</p>

<h3 id="toc_44">属性集 -&gt; AttributeSet attrs</h3>

<p>该节点的属性集，包括所有该节点的相关属性</p>

<h2 id="toc_45">Include中的theme属性</h2>

<p>这里大家先了解一个相关的问题，关于include标签设置theme属性的情况：</p>

<p>一般来说theme（主题）一般出现在Activtiy的AndroidManifest文件下，来给Activity设置统一的布局效果，而且可以使用如下的操作来进行主题属性的使用。</p>

<pre><code class="language-text">//  ?attr这样的形式，使用主题中的设置参数
android:background=&quot;?attr/colorPrimary&quot;
</code></pre>

<p>如果Include标签下设置了新的theme，那么Include中的内容在使用主题属性时，使用的theme主题就是（include）设置的内容，而不是Activity默认下的主题，形成了一种覆盖效果。</p>

<p>也就是说Include标签设置的主题可以覆盖Activity设置的根主题，但是Include设置的主题只作用与Include内部。</p>

<h3 id="toc_46">举个栗子：</h3>

<p><strong>style.xml</strong></p>

<p>先定义好两个基础Theme，一个是作为App的基础主题，另一个是include中的主题。</p>

<pre><code class="language-text">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;!-- BaseApplication theme --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
&lt;/style&gt;


&lt;style name=&quot;IncludeTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;!-- Include Theme --&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorAccent&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p><strong>AndroidManifest.xml</strong></p>

<p>设置Activity的基础主题为AppTheme</p>

<pre><code class="language-text">&lt;activity
    android:name=&quot;com.demo.MainActivity&quot;
    android:theme=&quot;@style/AppTheme&quot;&gt;&lt;/activity&gt;
</code></pre>

<p><strong>activity_main.xml</strong></p>

<pre><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;!-- 这里是使用基础Theme的Toolbar --&gt;
    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/activity_theme_tb&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;?attr/colorPrimary&quot; /&gt;

    &lt;!-- 这里是自带Theme Include的Toolbar --&gt;
    &lt;include
        layout=&quot;@layout/test_toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:theme=&quot;@style/IncludeTheme&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>接下来，我们在看一下Include包裹的布局 </p>

<p><strong>test_toolbar.xml</strong></p>

<pre><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;android.support.v7.widget.Toolbar
        android:id=&quot;@+id/include_toolbar&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;?attr/colorPrimary&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>

<p>从上面的XML文件我们可以看出两个Toolbar调用的background都指向theme的colorPrimary属性，接下来看一下显示效果：</p>

<p><img src="media/15561207871831/15713351026853.jpg" alt=""/></p>

<p>从效果图可以发现，Include Toolbar显示的颜色是粉色的，也就是Include额外设置的theme，这里也是从正面证明了这个概念。</p>

<h2 id="toc_47">第一部分：Include Theme主题的设置</h2>

<pre><code class="language-java">//------------------&lt;第一部分&gt;-------------------//
//提取出Theme属性
final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
final int themeResId = ta.getResourceId(0, 0);
final boolean hasThemeOverride = themeResId != 0;
//如果存在Theme属性，那么Include包含的子标签都会使用该主题
if (hasThemeOverride) {
    context = new ContextThemeWrapper(context, themeResId);
}
ta.recycle();
</code></pre>

<p>通过上面的介绍，很明显这段代码含义，就是检测是否给Include标签设置了Theme属性，如果设置theme，就创建相应的ContextThemeWrapper，用于之后子标签的解析时theme的使用。</p>

<h2 id="toc_48">第二部分：Include 内容布局的设置</h2>

<pre><code class="language-java">//------------------&lt;第二部分&gt;-------------------//
//先获取 layout 属性（资源 id）是否设置
int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);
if (layout == 0) {
    //如果没直接设置布局的资源 id，那么就检索?attr/name这一类的 layout 属性
    final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
    if (value == null || value.length() &lt;= 0) {
        throw new InflateException(&quot;You must specify a layout in the&quot; + &quot; include tag: &lt;include layout=\&quot;@layout/layoutID\&quot; /&gt;&quot;);
    }

    //从?attr/name 这一类的属性中，获取布局属性  
    layout = context.getResources().getIdentifier(value.substring(1), null, null);
}

//这个布局资源也许存在主题属性中，所以需要去主题属性中解析
if (mTempValue == null) {
    mTempValue = new TypedValue();
}
if (layout != 0 &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, true)) {
    layout = mTempValue.resourceId;
}
</code></pre>

<p>这部分的内容主要是提取Include的内容布局的提取，Include的内容布局的设置有两种：</p>

<h3 id="toc_49">第一种 ： 直接@layout 后面设置布局的XML</h3>

<p><code>layout=&quot;@layout/test_toolbar&quot;</code></p>

<h3 id="toc_50">第二种：通过引入theme的item设置的layout属性</h3>

<h4 id="toc_51">Include标签下：</h4>

<p><code>layout=&quot;?attr/theme_layout&quot;</code></p>

<h4 id="toc_52">包裹Include标签的布局Theme（注意：这里不是Include设置的主题）：</h4>

<pre><code class="language-text">&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;
    &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;
    //重点在这里！！！！！
    &lt;item name=&quot;theme_layout&quot;&gt;@layout/test_toolbar&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>而上面的代码的作用是检索layout属性，如果layout已经以第一种方式引入，就不需要在去theme中检索，如果layout第一种方式检索不到资源ID，那么就会去以第二种方式进行检索。</p>

<h3 id="toc_53">第三部分： Include标签的View处理</h3>

<pre><code class="language-text">            //------------------&lt;第三部分&gt;-------------------//
            //如果此时还找不到layout，那么必然异常~，会报找不到资源ID的layout异常
            if (layout == 0) {
                final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);
                throw new InflateException(&quot;You must specify a valid layout &quot;
                        + &quot;reference. The layout ID &quot; + value + &quot; is not valid.&quot;);
            } else {
            //生成子解析器
                final XmlResourceParser childParser = context.getResources().getLayout(layout);

                try {
                    final AttributeSet childAttrs = Xml.asAttributeSet(childParser);
                    //----------------省略了XML一些规则的判断----------------//
                    //获取子节点的名称
                    final String childName = childParser.getName();
                    if (TAG_MERGE.equals(childName)) {
                        //解析 Meger 标签
                        rInflate(childParser, parent, context, childAttrs, false);
                    } else {
                        //根据 name名称来创建View
                        final View view = createViewFromTag(parent, childName,
                                context, childAttrs, hasThemeOverride);
                        final ViewGroup group = (ViewGroup) parent;
                        //获取 View 的 id 和其 Visiable 属性
                        final TypedArray a = context.obtainStyledAttributes(
                                attrs, R.styleable.Include);
                        final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);
                        final int visibility = a.getInt(R.styleable.Include_visibility, -1);
                        a.recycle();

                        //需要将 Parent中的 LayoutParams 设置为其 Params 属性。
                        //如果 Parent 没有通用的 Params，那么就会抛出Runtime 异常

                        //然后会为其设置 include 包裹内容的通用 Params，

                        ViewGroup.LayoutParams params = null;
                        try {
                            params = group.generateLayoutParams(attrs);
                        } catch (RuntimeException e) {
                            // Ignore, just fail over to child attrs.
                        }
                        if (params == null) {
                            params = group.generateLayoutParams(childAttrs);
                        }
                        view.setLayoutParams(params);

                        // 解析子标签
                        rInflateChildren(childParser, view, childAttrs, true);

                        if (id != View.NO_ID) {
                            view.setId(id);
                        }

                        // 加载include内容时，需要直接设置其 可见性
                        switch (visibility) {
                            case 0:
                                view.setVisibility(View.VISIBLE);
                                break;
                            case 1:
                                view.setVisibility(View.INVISIBLE);
                                break;
                            case 2:
                                view.setVisibility(View.GONE);
                                break;
                        }
                        //添加至父容器中
                        group.addView(view);
                    }
                } finally {
                    childParser.close();
                }
            }
        } else {
            throw new InflateException(&quot;&lt;include /&gt; can only be used inside of a ViewGroup&quot;);
        }
</code></pre>

<p>这部分主要的作用是解析Include包裹layout的根标签：</p>

<h4 id="toc_54">（1）先特别处理Merge标签 ：</h4>

<p>如果子节点是Merge标签，那么直接进行内容的解析，调用rInflater()方法。</p>

<p>而rInflater()这个方法的作用是，解析某个节点，根据节点的不同类型从而进行不同的处理</p>

<h4 id="toc_55">（2）解析Include的内容：</h4>

<p>在这之前先通过createViewFromTag()方法，根据名称来生成相对应的View</p>

<p>这里分成两块内容<br/><br/>
<strong>第一块是设置LayoutParams</strong>：</p>

<pre><code class="language-text">ViewGroup.LayoutParams params = null;
try {
    //加载Include的父ViewGroup的LayoutParams
    params = group.generateLayoutParams(attrs);
} catch (RuntimeException e) {
    // Ignore, just fail over to child attrs.
}
if (params == null) {
    //加载Include的子ViewGroup的LayoutParams
    params = group.generateLayoutParams(childAttrs);
}
view.setLayoutParams(params);
</code></pre>

<p>这段的作用是为Include的包裹的根View设置LayoutParams，使用的LayoutParams默认是Include外层的ViewGroup。</p>

<p>如果此时Params加载失败，那就会使用Include包裹的ViewGroup的LayoutParams，反正怎么都得设置一个。</p>

<p><strong>第二块是在这里设置子ViewGroup的显隐性</strong>：</p>

<pre><code class="language-java">// 加载include内容时，需要直接设置其 可见性
switch (visibility) {
    case 0:
        view.setVisibility(View.VISIBLE);
        break;
    case 1:
        view.setVisibility(View.INVISIBLE);
        break;
    case 2:
        view.setVisibility(View.GONE);
        break;
}
//添加至父容器中
group.addView(view);
</code></pre>

<p>设置ViewGroup的显隐性，之后就将其添加至父View中，至此parseInclude的分析就到此结束。</p>

<h2 id="toc_56">流程图</h2>

<p><img src="media/15561207871831/15713351149148.jpg" alt=""/></p>

<h2 id="toc_57">效果</h2>

<p><img src="media/15561207871831/15713351244735.jpg" alt=""/></p>

<p><img src="media/15561207871831/20171105150982283383132.gif" alt=""/></p>

<h2 id="toc_58">分析</h2>

<p>这个效果属于视觉差的效果，原理是根据ViewPager的滑动方向，页面内物理做同向偏移，只要偏移距离大于页面的偏移，就会产生速度差，那么就会实现该效果。</p>

<p>实现速度差，我们需要一个滑动的比例系数：</p>

<p>在页面进入时：</p>

<p><code>页面物体的移动距离 = (页面长度 - 滑动距离) * 滑动系数</code></p>

<p>在页面滑出时：</p>

<p><code>页面物体的移动距离 = （0 - 滑动距离 ） * 滑动系数</code></p>

<p>同时考虑第二张Gif上，发现物体Y轴也存在移动，所以也得需要考虑Y轴方向的滑动，整理下：</p>

<pre><code class="language-text">//进入时：
view.setTranslateX((vpWidth - positionOffsetPixels) * xIn);
view.setTranslateY((vpWidth - positionOffsetPixels) * yIn);

//退出时
view.setTranslateX((0 - positionOffsetPixels) * xOut);
view.setTranslateY((0 - positionOffsetPixels) * yOut);
</code></pre>

<p>这样就可以实现出：</p>

<ul>
<li>进入该界面时，界面上的物品快速飞进来。</li>
<li>退出该界面时，界面上的物理快速飞出去。</li>
</ul>

<h2 id="toc_59">实现思路</h2>

<p>对于上述的分析，这里的实现思路存在两种：</p>

<ol>
<li>自定义View，自定义xIn、yIn、xOut、yOut四个属性的系数，所有界面上的物体继承这个自定义View。</li>
<li>自定义LayoutInflater.Factory在解析时，将这些自定义属性提取，以Tag方式储存起来。</li>
</ol>

<h2 id="toc_60">优缺点分析</h2>

<p><strong>自定义View</strong>：</p>

<p>优点：可以对物体做更多层面的扩展，这个自定义LayoutInflater.Factory是不具备的。</p>

<p>缺点：由于界面的物体数量过多，在findViewById时需要处理的View元素过多，极大的增加代码量。</p>

<p><strong>自定义LayoutInflater.Factory</strong> :</p>

<p>优点：可以在解析过程中对View做统一操作，当出现大量的View时，能够缩减大量代码。</p>

<p>缺点：在解析时预处理View，但是就不能动态的改变View的属性，要对View进行扩展性操作，自定义LayoutInflater.Factory不具备这样的功能。</p>

<p><strong>自定义LayoutInflater.Factory</strong></p>

<p>上述的两种方案的优缺点已经分析完毕，但是本文作为实战篇，所以只会介绍自定义LayoutInflater.Factory这种方式。</p>

<p>在实际场景中，需要结合自身情况，以及上述的优缺点，进行合理选择。</p>

<p>在介绍之前，先看一段代码：</p>

<pre><code class="language-java">View view;
//如果Factory2存在，就会调用其onCreateView方法
if (mFactory2 != null) {
    view = mFactory2.onCreateView(parent, name, context, attrs);
    //如果Factory存在，就会调用其onCreateView方法，和Factory2不同的时，这里的参数没有父View
} else if (mFactory != null) {
    view = mFactory.onCreateView(name, context, attrs);
} else {
    view = null;
}
//如果没有Factory或者Factory2，就会寻找mPrivateFactory（本质上也是Factory2）
if (view == null &amp;&amp; mPrivateFactory != null) {
    view = mPrivateFactory.onCreateView(parent, name, context, attrs);
}
</code></pre>

<p>这段代码出自LayoutInflater中createViewFromTag()方法，作用是根据View的名称（name参数）来创建View.</p>

<p>在这里就简单描述下，这个方法的主要流程：</p>

<ul>
<li>对一些特殊标签，做分别处理，例如：view，TAG_1995(blink)</li>
<li>进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View</li>
<li>如果没有设置Factory或Factory2，那么就会使用LayoutInflater默认的生成方式，进行View的生成</li>
</ul>

<p>在实战篇中，只有第二部分和我们今天的内容是相关的，我们在看一遍第二条。</p>

<p><code>进行对Factory、Factory2的设置判断，如果设置那么就会通过设置Factory、Factory2进行生成View</code></p>

<p>如果设置了Factory或者Factory2，那么就不会使用LayoutInflater默认的生成方式，那么生成View的过程，就由我们自主把控，这才是我们自定义LayoutInflater.Factory的主要原因。</p>

<h2 id="toc_61">自定义Factory还是Factory2 ？</h2>

<pre><code class="language-java">View view;
//如果Factory2存在，就会调用其onCreateView方法
if (mFactory2 != null) {
    view = mFactory2.onCreateView(parent, name, context, attrs);
    //如果Factory存在，就会调用其onCreateView方法，和Factory2不同的时，这里的参数没有父View
} else if (mFactory != null) {
    view = mFactory.onCreateView(name, context, attrs);
} else {
    view = null;
}
</code></pre>

<p>我们能够从这段代码中得出，Factory2比Factory的优先级要高，即Factory2存在Factory就不可能会被调用，同理可以得出结论：</p>

<pre><code class="language-text">优先级顺序:

mFactory2  &gt; mFactory &gt; mPrivateFactory &gt; LayoutInflater默认处理方式
</code></pre>

<p>而且我们还能够发现mFactory2的onCreateView()方法与mFactory是不相同的：</p>

<pre><code class="language-text">//mFactory2
mFactory2.onCreateView(parent, name, context, attrs);

//mFactory
view = mFactory.onCreateView(name, context, attrs);
</code></pre>

<p>根据上述的分析，我们可以得出结论：</p>

<pre><code class="language-text">(1)Factory2的调用优先级比Factory要高

(2)Factory2的onCreateView()方法，会比Factory多返回一个父View的参数。

(3)Factory2和Factory是互斥的，（如果不通过反射的话）只能设置一个。
</code></pre>

<p>第三条在CreateViewFromTag的那篇文章已经分析过了，这里不做过多的解释了。</p>

<p>实际选择的过程中，一般会选择自定义Factory2，因为Factory2本身也继承了Factory接口，而且Factory2的优先级比较高。</p>

<h2 id="toc_62">注意事项</h2>

<h3 id="toc_63">设置Factory但是发现无响应，是因为本身LayoutInflater中存在Factory2</h3>

<p>因为一般使用方式，是直接调用cloneInContext()方法，我们知道一般的默认解析器都是PhoneLayoutInflater，我们看下其实现方式：</p>

<pre><code class="language-java">protected PhoneLayoutInflater(LayoutInflater original, Context newContext) {
    super(original, newContext);
}
</code></pre>

<p>本质就是调用LayoutInflater的两参构造方法：</p>

<pre><code class="language-java">protected LayoutInflater(LayoutInflater original, Context newContext) {
    mContext = newContext;
    mFactory = original.mFactory;
    mFactory2 = original.mFactory2;
    mPrivateFactory = original.mPrivateFactory;
    setFilter(original.mFilter);
}
</code></pre>

<p>在这里可以看出，cloneInContext会把原LayoutInflater的Factory2和Factory一并复制。</p>

<p>因为Factory比Factory2的优先级低，所以才会不出现效果。</p>

<p><strong>解决方案</strong> ：</p>

<p>（1）自定义LayoutInflater，并且改写cloneInContext，使其不复制原LayoutInflater的Factory2以及Factory。</p>

<pre><code class="language-java">public class CustomLayoutInflater extends LayoutInflater {

    protected CustomLayoutInflater(Context context) {
        super(context);
    }

    @Override
    public LayoutInflater cloneInContext(Context newContext) {
        return new CustomLayoutInflater(newContext);
    }
}
</code></pre>

<p>（2）使用时，直接通过new出实例，然后setFactory</p>

<pre><code class="language-java">CustomLayoutInflater newInflater = new CustomLayoutInflater(getActivity());
newInflater.setFactory2(new CustomAppFactory(newInflater, this));
return newInflater.inflate(layoutId, null);
</code></pre>

<h3 id="toc_64">使用AppCompatActivity直接setFactory2或者setFactory为什么报错？</h3>

<p>这是因为 AppCompatActivity 在初始化的时候，已经设置了 Factory，下面来看下这部分代码</p>

<pre><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    final AppCompatDelegate delegate = getDelegate();
    //注意这个方法
    delegate.installViewFactory();
    delegate.onCreate(savedInstanceState);
    //.....省略多余的代码..........
    super.onCreate(savedInstanceState);
}
</code></pre>

<p>继续查看 installViewFactory（）方法</p>

<pre><code class="language-java">@Override
public void installViewFactory() {
    LayoutInflater layoutInflater = LayoutInflater.from(mContext);
    if (layoutInflater.getFactory() == null) {
        //这句话是设置 Factory 的方法
        LayoutInflaterCompat.setFactory(layoutInflater, this);
    } else {
        //省略部分代码。。。。。。      
    }
}
</code></pre>

<p>可以发现，在onCreate 时 LayoutInflater 已经设置过一次 Factory 了，然后我再来看下 setFactory() 的源码：</p>

<pre><code class="language-java">public void setFactory(Factory factory) {
    if (mFactorySet) {
        //原因就是这一句
        throw new IllegalStateException(&quot;A factory has already been set on this LayoutInflater&quot;);
    }
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = factory;
    } else {
        mFactory = new FactoryMerger(factory, null, mFactory, mFactory2);
    }
}
</code></pre>

<p>根据上面代码，就可以发现报错原因了。</p>

<p><strong>解决方案</strong> ：</p>

<p>在使用前，先使用 cloneInContext()克隆出一个新的 LayoutInflater，然后在进行设置操作。</p>

<pre><code class="language-java">LayoutInflate  newInflater = LayoutInflater.cloneInContext(inflater,context);

newInflater.setFactory(new CustomFactory（）)；
</code></pre>

<p>这样就避开在原 LayoutInflater 设置 Factory 报错了。</p>

<h2 id="toc_65">自定义Factory2的实现 ——&gt; CustomAppFactory</h2>

<p>根据上面的展示效果，我们可以判断出是ViewPager + Fragment的风格，所以我们自定义Factory应该在Fragment的onCreateView中，更改LayoutInflater。</p>

<p>而且根据注意事项，我们一般会自定义优先级较高的Factory2，防止本身cloneInContext的LayoutInflater中已经存在Factory2，我们使用Factory会无效。</p>

<h3 id="toc_66">使用方式</h3>

<pre><code class="language-java">public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
    Bundle bundle = getArguments();
    int layoutId = bundle.getInt(LAYOUT_ID);
    //注意需要调用cloneInContext方法生成新的LayoutInflater
    LayoutInflater newInflater = inflater.cloneInContext(getActivity());
    //调用的是setFactory2而非setFactory
    newInflater.setFactory2(new CustomAppFactory(newInflater, this));
    return newInflater.inflate(layoutId, null);
}
</code></pre>

<h3 id="toc_67">自定义过程</h3>

<p>那么就创建一个类CustomAppFactory来实现Factory2的接口，复写onCreateView的方法。</p>

<pre><code class="language-java">@Override
public View onCreateView(String name, Context context, AttributeSet attrs) {
    View view = null;
    //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;第一部分&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
    try {
        if (name.contains(&quot;.&quot;)) {
            String checkName = name.substring(name.lastIndexOf(&quot;.&quot;));
            String prefix = name.substring(0, name.lastIndexOf(&quot;.&quot;));
            view = defaultInflater(checkName, prefix, attrs);
        }
        if (name.equals(&quot;View&quot;) || name.equals(&quot;ViewGroup&quot;)) {
            view = defaultInflater(name, sClassPrefix[1], attrs);
        } else {
            view = defaultInflater(name, sClassPrefix[0], attrs);
        }
        //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;第二部分&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
        //实例化完成
        if (view != null) {
            //获取自定义属性,通过标签关联到视图上
            setViewTag(view, context, attrs);
            mInflaterView.addView(view);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return view;
}

@Override
public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
    View view = onCreateView(name, context, attrs);
    return view;
}
</code></pre>

<p>其实如果我们采取自定义的方式，这里只会调用onCreateView()四位参数的方法，因为在比较Factory2和Factory的代码也介绍过了。</p>

<p>我们实现的逻辑是在onCreateView()三位逻辑里面，因为需要实现的效果不需要Parent（父View），所以这里逻辑实现全在三位参数的onCreateView()中。</p>

<p>在这里我们将onCreateView()中，分成2部分内容：</p>

<ul>
<li>根据名称解析出View</li>
<li>扩展操作，将额外的属性，提取出来储存在Tag中</li>
</ul>

<h2 id="toc_68">onCreateView第一部分内容</h2>

<pre><code class="language-java">if (name.contains(&quot;.&quot;)) {
    String checkName = name.substring(name.lastIndexOf(&quot;.&quot;));
    String prefix = name.substring(0, name.lastIndexOf(&quot;.&quot;));
    view = defaultInflater(checkName, prefix, attrs);
}
if (name.equals(&quot;View&quot;) || name.equals(&quot;ViewGroup&quot;)) {
    view = defaultInflater(name, sClassPrefix[1], attrs);
} else {
    view = defaultInflater(name, sClassPrefix[0], attrs);
}
</code></pre>

<p>这里判断了name中是否包含“.”，是用来判断生成的View是否是自定义View，下面来看下自定义View和Android自带的组件的区别：</p>

<pre><code class="language-text">//原生的组件
RelativeLayout
//自定义View
com.demo.guidepagedemo.customview.CustomImageView
</code></pre>

<p>可以发现区别为原生的View不带前缀，而自定义View是包括前缀的，所以会用name.contains(“.”)来区分。</p>

<p>而原生组件中View和ViewGroup是属于android.view包下，其他的例如：RelativeLayout，LinearLayout是属于android.widget包下。</p>

<pre><code class="language-text">private final String[] sClassPrefix = {
    &quot;android.widget.&quot;,
    &quot;android.view.&quot;
};
</code></pre>

<p>所以在之后会对View和ViewGroup作区分，上面把sClassPrefix贴出来了。</p>

<p>而这里真正的解析过程最后还是交给LayoutInflater，调用LayoutInflater的onCreateView方法：</p>

<pre><code class="language-java">private View defaultInflater(String name, String prefix, AttributeSet attrs) {
    View view = null;
    try {
        view = mInflater.createView(name, prefix, attrs);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
    return view;
}
</code></pre>

<h2 id="toc_69">onCreateView第二部分内容</h2>

<pre><code class="language-java">//实例化完成
if (view != null) {
    //获取自定义属性,通过标签关联到视图上
    setViewTag(view, context, attrs);
    mInflaterView.addView(view);
}
</code></pre>

<p>在这里做拓展处理的，setViewTag方法是处理View的自定义属性，然后将这些属性包装成类，给View设置Tag</p>

<p><strong>setViewTag方法</strong></p>

<pre><code class="language-java">/**
 * 将View的属性信息存储在Tag中
 */
private void setViewTag(View view, Context context, AttributeSet attrs) {
    //解析自定义的属性
    TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.CustomImageView);
    if (attrs != null &amp;&amp; array.length() &gt; 0) {
        AttrTagBean bean = new AttrTagBean();
        bean.xIn = array.getFloat(R.styleable.CustomImageView_in_value_x, 0f);
        bean.xOut = array.getFloat(R.styleable.CustomImageView_out_value_x, 0f);
        bean.yIn = array.getFloat(R.styleable.CustomImageView_in_value_y, 0f);
        bean.yOut = array.getFloat(R.styleable.CustomImageView_out_value_y, 0f);
        //index
        view.setTag(bean);
    }
    array.recycle();
}
</code></pre>

<p>上面对应的是本文我们开始设置的4个系数：</p>

<pre><code class="language-java">R.styleable.CustomImageView_in_value_x              --&gt;   进入时 x方向的系数

R.styleable.CustomImageView_out_value_x             --&gt;   退出时 x方向的系数

R.styleable.CustomImageView_in_value_y              --&gt;   进入时 y方向的系数

R.styleable.CustomImageView_out_value_y             --&gt;   退出时 y方向的系数
</code></pre>

<p>而这里的mInflaterView是一个抽象接口，让Fragment来实现的，通过在Fragment中内置一个List《View》，到时候可以遍历统一操作这些View，下面是实现过程：</p>

<pre><code class="language-java">public interface InflaterViewImpl {

    /**
     * 获取View集合
     *
     * @return
     */
    List&lt;View&gt; getViews();


    /**
     * 添加元素
     */
    void addView(View view);
}
</code></pre>

<p><strong>Fragment中的实现过程</strong>：</p>

<pre><code class="language-java">public class PageFragment extends Fragment implements InflaterViewImpl {

    private List&lt;View&gt; views = new ArrayList&lt;&gt;();

    //**************篇幅原因省略了部分方法************************//

    @Override
    public List&lt;View&gt; getViews() {
        return views;
    }

    @Override
    public void addView(View view) {
        if (views.contains(view)) {
            return;
        }
        views.add(view);
    }
}
</code></pre>

<h2 id="toc_70">处理ViewPager的滑动</h2>

<p>这是实战篇的最后一部分内容，主要介绍的是ViewPager的滑动监听相关的处理，因为所有效果是基于ViewPager的滑动监听来显示的。</p>

<p>因为本文主要介绍内容是自定义LayoutInflater.Factory，所以这里会简单叙述下：</p>

<pre><code class="language-java">mInflaterVp.addOnPageChangeListener(new 
ViewPager.OnPageChangeListener() {
    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        //获取ViewPager的宽度
        int vpWidth = mInflaterVp.getWidth();
        //获取正在进入的界面
        PageFragment inFragment = getPosition(position - 1);
        if (inFragment != null) {
            List&lt;View&gt; views = inFragment.getViews();
            if (views != null &amp;&amp; views.size() &gt; 0) {
            for (View view : views) {
                AttrTagBean tag = (AttrTagBean) view.getTag();
                if (tag != null) {
                    view.setTranslationX((vpWidth - positionOffsetPixels) * tag.xIn);
                    view.setTranslationY((vpWidth - positionOffsetPixels) * tag.yIn);
                }
            }
        }
    }

    //当前正在滑动的界面
    PageFragment outFragment = getPosition(position);
    if (outFragment != null) {
        List&lt;View&gt; views = outFragment.getViews();
        if (views != null &amp;&amp; views.size() &gt; 0) {
            for (View view : views) {
                AttrTagBean tag = (AttrTagBean) view.getTag();
                if (tag != null) {
                    view.setTranslationX((0 - positionOffsetPixels) * tag.xOut);
                    view.setTranslationY((0 - positionOffsetPixels) * tag.yOut);
                }
            }
        }
    }


    @Override
    public void onPageSelected(int position) {
        //当划到最后一页时，小人的图标消失
        if (position == fragments.size() - 1) {
            mInflaterIv.setVisibility(View.GONE);
        } else {
            mInflaterIv.setVisibility(View.VISIBLE);
        }
    }

    @Override
    public void onPageScrollStateChanged(int state) {
        //这里是处理图中的小人的帧动画过程
        Drawable anim = mInflaterIv.getBackground();
        if (!(anim instanceof AnimationDrawable)) {
            return;
        }
        AnimationDrawable animation = (AnimationDrawable) anim;
        Log.d(&quot;滑动状态&quot;, state + &quot;&quot;);
        switch (state) {
            //空闲状态
            case ViewPager.SCROLL_STATE_IDLE:
                animation.stop();
                break;
            //拖动状态
            case ViewPager.SCROLL_STATE_DRAGGING:
                animation.start();
                break;
            //惯性滑动状态
            case ViewPager.SCROLL_STATE_SETTLING:
                break;
        }
    }
});
</code></pre>

<p><strong>小红书引导页</strong></p>

<p><img src="media/15561207871831/20171105150982288981203.gif" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/14</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871789.html">
                
                  <h1>Android-Camera和Matrix实现真正的3D(WheelView)日期,地址选择滚轮控件</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Camera和Matrix实现真正的3D(WheelView)日期,地址选择滚轮控件</p>

<h2 id="toc_1">先看效果图</h2>

<p><img src="media/15561207871789/2017110515098153104205.gif" alt=""/></p>

<p>垂直方向的3D旋转</p>

<p><img src="media/15561207871789/2017110515098153351203.gif" alt=""/></p>

<p>水平方向的3D旋转</p>

<h2 id="toc_2">功能分析</h2>

<h3 id="toc_3">3D旋转效果</h3>

<p>WheelView的实现方式已经有很多种方式, 而且网上也有实现好的旋转效果,不过只是2D的旋转,而且要处理滑动与单击item事件比较复杂,真正的旋转是要通过Matrix, Camera类来实现,这里的Camera不是照相机里的API,Camera可以实现x,y,z轴的旋转,不清楚的可以去也解这些API的使用, 这里不详细介绍, 配合RecyclerView.ItemDecoration,在每个item中将Canvas进行3D旋转并平移,产生3D视觉效果</p>

<p>这里拿垂直布局的一种状态来做示例</p>

<pre><code class="language-java">    /**
     * 画垂直布局时的item
     * @param c
     * @param rect
     * @param position
     * @param parentCenterX RecyclerView的中心X点
     * @param parentCenterY RecyclerView的中心Y点
     */
    void drawVerticalItem(Canvas c, Rect rect, int position, float parentCenterX, float parentCenterY) {
        int realPosition = position - itemCount;//数据中的实际位置
        float itemCenterY = rect.exactCenterY();
        float scrollOffY = itemCenterY - parentCenterY;
        float rotateDegreeX = scrollOffY * itemDegree / itemSize;//垂直布局时要以X轴为中心旋转
        int alpha = degreeAlpha(rotateDegreeX);
        if (alpha &lt;= 0) return;
        float rotateSinX = (float) Math.sin(Math.toRadians(rotateDegreeX));
        float rotateOffY = scrollOffY - wheelRadio * rotateSinX;//因旋转导致界面视角的偏移
        //Log.i(&quot;you&quot;, &quot;drawVerticalItem degree &quot; + rotateDegreeX);
        //计算中心item, 优先最靠近中心区域的为中心点
        boolean isCenterItem = false;
        if (!hasCenterItem) {
            isCenterItem = Math.abs(scrollOffY) &lt;= halfItemHeight;
            if (isCenterItem) {
                centerItemPosition = realPosition;
                hasCenterItem = true;
            }
        }
        //这里是旋转操作的核心,每个item在旋转成弧时，都要将item的中心在旋转后给人的视觉上的偏移计算好
        c.save();
        c.translate(0.0f, -rotateOffY);
        camera.save();
        camera.rotateX(-rotateDegreeX);
        camera.getMatrix(matrix);
        camera.restore();
        matrix.preTranslate(-parentCenterX, -itemCenterY);
        matrix.postTranslate(parentCenterX, itemCenterY);
        c.concat(matrix);
        drawItem(c, rect, realPosition, alpha, isCenterItem, true);
        c.restore();
    }
</code></pre>

<p>到这里基本已经实现了每个item距离中心点的旋转效果,接下来就是添加WheelView显示的数量在RecyclerView头与尾部的空的item</p>

<h3 id="toc_4">适配器定义</h3>

<p>滑动的时候,item要能滑动距中心点以上,也可以滑动到中心点以下,所以适配器中的item数量也要对应改变,直接上代码</p>

<pre><code class="language-java">class WheelViewAdapter extends RecyclerView.Adapter&lt;WheelViewHolder&gt; {

    ...伪代码

    @Override
    public void onBindViewHolder(WheelViewHolder holder, int position) {
    //由于里面的文本全是画的,这里只是绑定最原始的View
    }

    @Override
    public int getItemCount() {
      //  这里的totalItemCount就是滑轮控件距离中心点显示的item个数 乘2
        return totalItemCount + (adapter == null ? 0 : adapter.getItemCount());
    }

    @Override
    public WheelViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        //适配器里根据垂直或水平布局显示
        View view = new View(parent.getContext());
        view.setLayoutParams(WheelUtils.createLayoutParams(orientation, itemSize));
        return new WheelViewHolder(view);
    }
}
</code></pre>

<h2 id="toc_5">总结：</h2>

<p>WheelView具体使用方法,示例代码中都有详细介绍,由于工作忙没有时间详细介绍里面的内容，源码里都有适当的注释，也可以一起讨论更佳的效果</p>

<p>后面有空再加上item点击与左右偏移时的立体效果,还有封装日期选择等...</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871715.html">
                
                  <h1>Android-SpannableString与SpannableStringBuilder</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">概述</h2>

<h3 id="toc_1">SpannableString、SpannableStringBuilder与String的关系</h3>

<p>首先SpannableString、SpannableStringBuilder基本上与String差不多，也是用来存储字符串，但它们俩的特殊就在于有一个SetSpan（）函数，能给这些存储的String添加各种格式或者称样式（Span），将原来的String以不同的样式显示出来，比如在原来String上加下划线、加背景色、改变字体颜色、用图片把指定的文字给替换掉，等等。所以，总而言之，SpannableString、SpannableStringBuilder与String一样， 首先也是传字符串，但SpannableString、SpannableStringBuilder可以对这些字符串添加额外的样式信息，但String则不行。<br/><br/>
注意：如果这些额外信息能被所用的方式支持，比如将SpannableString传给TextView；也有对这些额外信息不支持的，比如前一章讲到的Canvas绘制文字，对于不支持的情况，SpannableString和SpannableStringBuilder就是退化为String类型，直接显示原来的String字符串，而不会再显示这些附加的额外信息。  </p>

<h3 id="toc_2">SpannableString与SpannableStringBuilder区别</h3>

<p>它们的区别在于 SpannableString像一个String一样，构造对象的时候传入一个String，之后再无法更改String的内容，也无法拼接多个 SpannableString；而SpannableStringBuilder则更像是StringBuilder，它可以通过其append()方法来拼接多个String：</p>

<pre><code class="language-java">//使用SpannableString，必须一次传入，构造完成  
SpannableString word = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);  
  
//使用SpannableStringBuilder,可以使用append()再添加  
SpannableStringBuilder multiWord = new SpannableStringBuilder();  
multiWord.append(&quot;欢迎光临&quot;);  
multiWord.append(&quot;Harvic的&quot;);  
multiWord.append(&quot;博客&quot;);  
</code></pre>

<p><img src="media/15561207871715/15713660426208.png" alt=""/></p>

<p>因为Spannable等最终都实现了CharSequence接口，所以可以直接把SpannableString和SpannableStringBuilder通过TextView.setText()设置给TextView。</p>

<h3 id="toc_3">SetSpan（）</h3>

<p><code>void setSpan (Object what, int start, int end, int flags)</code></p>

<p>函数意义：给SpannableString或SpannableStringBuilder特定范围的字符串设定Span样式，可以设置多个（比如同时加上下划线和删除线等），Falg参数标识了当在所标记范围前和标记范围后紧贴着插入新字符时的动作，即是否对新插入的字符应用同样的样式。（这个后面会具体举例说明）</p>

<p><strong>参数说明</strong>：</p>

<ul>
<li>object what ：对应的各种Span，后面会提到；</li>
<li>int start：开始应用指定Span的位置，索引从0开始</li>
<li>int end：结束应用指定Span的位置，特效并不包括这个位置。比如如果这里数为3（即第4个字符），第4个字符不会有任何特效。从下面的例子也可以看出来。</li>
<li>int flags：取值有如下四个</li>
<li>Spannable.SPAN_EXCLUSIVE_EXCLUSIVE：前后都不包括，即在指定范围的前面和后面插入新字符都不会应用新样式 </li>
<li>Spannable.SPAN_EXCLUSIVE_INCLUSIVE    ：前面不包括，后面包括。即仅在范围字符的后面插入新字符时会应用新样式</li>
<li>Spannable.SPAN_INCLUSIVE_EXCLUSIVE    ：前面包括，后面不包括。</li>
<li>Spannable.SPAN_INCLUSIVE_INCLUSIVE    ：前后都包括。</li>
</ul>

<p>举个例子来说明这个前后包括的问题：<br/>
由于Flag的作用是用来指定范围前后输入新的字符时，会不会应用效果的，所以我们利用EditText来显示SpannableString</p>

<p>(1)、布局XML中加入一个EditText控件：</p>

<pre><code class="language-markup">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    tools:context=&quot;com.example.try_spannable_blog.MainActivity&quot; &gt;  
  
    &lt;EditText  
        android:id=&quot;@+id/edit&quot;  
        android:layout_width=&quot;wrap_content&quot;  
        android:layout_height=&quot;wrap_content&quot; /&gt;  
  
&lt;/RelativeLayout&gt;  
</code></pre>

<p>（2）、这里用一个改变字体颜色的Span来做下演示</p>

<pre><code class="language-markup">public class MainActivity extends Activity {  
      
    private EditText editText;    
    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
          
        editText = (EditText)findViewById(R.id.edit);  
          
        //改变字体颜色  
        //先构造SpannableString  
        SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
       //再构造一个改变字体颜色的Span  
        ForegroundColorSpan span = new ForegroundColorSpan(Color.BLUE);    
        //将这个Span应用于指定范围的字体  
        spanString.setSpan(span, 1, 3, Spannable.SPAN_EXCLUSIVE_INCLUSIVE);    
        //设置给EditText显示出来  
        editText.setText(spanString);  
    }  
}  
</code></pre>

<p>初始化效果是这样的：</p>

<p><img src="media/15561207871715/15713660525455.png" alt=""/></p>

<p>分别在设置Span的前面和后面加入新文字，结果是这样的</p>

<p><img src="media/15561207871715/15713660631876.png" alt=""/></p>

<p>在前面和后面都加入虾米两个字，可见，前面的虾米没有任何效果，后面的则不同，添加上相同的Span特效，这是由于我们设置了Spannable.SPAN_EXCLUSIVE_INCLUSIVE的原因，即（前面不应用特效，后面应用特效），其它几个Flags参数的含义想必大家也都清楚了。在此就不再赘述。</p>

<h2 id="toc_4">各种Span设置</h2>

<p>在前面的一个小示例，大家应该也可以看出，要应用一个Span总共分三步：</p>

<ol>
<li>构造String</li>
<li>构造Span</li>
<li>利用SetSpan（）对指定范围的String应用这个Span</li>
</ol>

<h3 id="toc_5">字体颜色设置（ForegroundColorSpan）</h3>

<pre><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
//再构造一个改变字体颜色的Span  
ForegroundColorSpan span = new ForegroundColorSpan(Color.BLUE);    
//将这个Span应用于指定范围的字体  
spanString.setSpan(span, 1, 5, Spannable.SPAN_EXCLUSIVE_INCLUSIVE);    
//设置给EditText显示出来  
editText.setText(spanString);  
</code></pre>

<p>效果：</p>

<p><img src="media/15561207871715/15713660755390.png" alt=""/></p>

<h3 id="toc_6">字体背景颜色（BackgroundColorSpan）</h3>

<pre><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
BackgroundColorSpan span = new BackgroundColorSpan(Color.YELLOW);    
spanString.setSpan(span, 0, 3, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString);    
</code></pre>

<p><img src="media/15561207871715/15713660849900.png" alt=""/></p>

<h3 id="toc_7">字体大小（AbsoluteSizeSpan）</h3>

<pre><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
AbsoluteSizeSpan span = new AbsoluteSizeSpan(16);    
spanString.setSpan(span, 2, 5, Spannable.SPAN_INCLUSIVE_INCLUSIVE);    
editText.setText(spanString); 
</code></pre>

<p><img src="media/15561207871715/15713660949169.png" alt=""/></p>

<h3 id="toc_8">粗体、斜体（StyleSpan）</h3>

<pre><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
StyleSpan span = new StyleSpan(Typeface.BOLD_ITALIC);    
spanString.setSpan(span, 1, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString);   
</code></pre>

<p><img src="media/15561207871715/15713661033289.png" alt=""/></p>

<h3 id="toc_9">删除线（StrikethroughSpan）</h3>

<pre><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
StrikethroughSpan span = new StrikethroughSpan();    
spanString.setSpan(span, 2, 5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString);
</code></pre>

<p><img src="media/15561207871715/15713661144421.png" alt=""/></p>

<h3 id="toc_10">下划线（UnderlineSpan）</h3>

<pre><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
UnderlineSpan span = new UnderlineSpan();    
spanString.setSpan(span, 1, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString); 
</code></pre>

<p><img src="media/15561207871715/15713661239815.png" alt=""/></p>

<h3 id="toc_11">图片置换（ImageSpan）</h3>

<p>ImagSpan有很多构造函数，一般是通过传入Drawableg来构造，详细的构造说明看这里：<a href="http://developer.android.com/reference/android/text/style/ImageSpan.html">http://developer.android.com/reference/android/text/style/ImageSpan.html</a></p>

<pre><code class="language-java">SpannableString spanString = new SpannableString(&quot;欢迎光临Harvic的博客&quot;);    
Drawable d = getResources().getDrawable(R.drawable.ic_launcher);    
d.setBounds(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());    
ImageSpan span = new ImageSpan(d, ImageSpan.ALIGN_BASELINE);    
spanString.setSpan(span, 2, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);    
editText.setText(spanString);  
</code></pre>

<p><img src="media/15561207871715/15713661317230.png" alt=""/></p>

<p>这个函数的不同之处在于，前几都是在原来文字的基础上加上特效，而这里却是利用图片将文字替换。如果遇到不支持显示图片的函数，比如前一篇中的canvas绘图。就会退化成String，即以原来的String字符串来显示。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871674.html">
                
                  <h1>Android 基于开源项目搭建属于自己的技术堆栈</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>这篇博文主要就是针对平常使用到的框架做一个整理和分析其优劣。</p>

<p>为了从整体上进行把握，先来看看一个完整的APP整体架构</p>

<h2 id="toc_0">APP的整体架构</h2>

<p>从较高的层次将，一个APP的整体架构可以分为两层，即应用层和基础框架层。</p>

<ul>
<li>应用层专注于行业领域的实现，例如金融、支付、地图导航、社交等，它直接面向用户，是用户对产品的第一层感知。</li>
<li>基础框架层专注于技术领域的实现，提供APP公有的特性，避免重复制造轮子，它是用户对产品的第二层感知，例如性能、稳定性等。</li>
</ul>

<p>一个理想的APP架构，应该拥有如下特点</p>

<ul>
<li>支持跨平台开发</li>
<li>具有清晰的层次划分，同一层模块间充分解耦，模块内部符合面向对象设计六大原则</li>
<li>在功能、性能、稳定性等方面达到综合最优</li>
</ul>

<p>基于以上设计原则，我们可以看出APP架构图，最上层是应用层，应用层以下都属于基础框架层，基础框架层包括：组件层、基础层和跨平台层。</p>

<p><img src="media/15561207871674/15713659918637.png" alt=""/></p>

<p>我们要讨论的重点是基础层，下面开始一步一步地阐述如何基于开源函数库搭建属于自己的一个基础技术堆栈。</p>

<h2 id="toc_1">技术选型的考量点</h2>

<p>首先要明确的是，我们选择开源函数库或者第三方SDK、一般需要综合考虑一下几个方面</p>

<ul>
<li>特性：提供的特性是否满足项目的需求</li>
<li>可用性，是否提供了简洁便利的API，方便开发者集成使用。</li>
<li>性能：性能不能太差，否则项目后面性能优化会过不去，可能回出现需要替换函数库的情况。</li>
<li>文档：文档应该比较齐全，且可读性高。</li>
<li>技术支持：遇到问题或者发现BUG，是否能够及时得到官方的技术支持是很重要的</li>
<li>大小：引入函数库会增加APK的大小，需要慎重抉择</li>
<li>方法数：如果函数库方法数太多，积累起来会导致你的APP遇到64K问题，应该尽量避免</li>
</ul>

<h2 id="toc_2">日志记录能力</h2>

<p>日志记录无论在服务端开发还是移动端开发，都是一个基础且重要的能力，开发人员在代码调试以及错误定位过程中，大多说都要依赖日志信息，一个简洁灵活的日志记录模块是相当重要的。<br/><br/>
Logger 是基于系统Log类基础上进行的封装，但新增了如下超赞的特性。  </p>

<ul>
<li>在Logcat中完美的格式化输出，再也不用担心和手机其他APP或者系统的日志信息相混淆了</li>
<li>包含线程、类、方法信息，可以清楚地看到日志记录的调用堆栈</li>
<li>支持跳转到源码处</li>
<li>支持格式化输出JSON、XML格式信息</li>
</ul>

<p><strong>Logcat截图</strong></p>

<p><img src="media/15561207871674/15713660030221.png" alt=""/></p>

<p>当然Logger也不是完备的，它虽然支持格式化输出JSON、XML，但并不支持诸如List、Set、Map和数组等常见Java集合类的格式化输出。如何解决呢？可以看下LogUtils 这个开源库，它实现了Logger缺失的上述特性。</p>

<p>再者，Logger只支持输出日志到Logcat，但项目开发中往往还存在将日志保存到磁盘上的需求，如何将两者结合起来呢？这是就遇到了timber 。</p>

<p>timber是JakeWharton开源的一个日志记录库，它的特点是可扩展的框架，开发者可以方便快捷的集成不同类型的日志记录方式，例如，打印日志到Logcat、打印日志到文件、打印日志到网络等，timber通过一行代码就可以同时调用多种方式。</p>

<p>timber的思想很简单，就是维护一个森林对象，它由不同类型的日志树组合而成，例如，Logcat记录树、文件记录树、网络记录树等，森林对象提供对外的接口进行日志打印。每种类型的树都可以通过种植操作把自己添加到森林对象中，或者通过移除操作从森林对象中删除，从而实现该类型日志记录的开启和关闭。</p>

<p>最终我们的日志记录模块将由timber+Logger+LogUtils组成，当然轮子找到了，轮子的兼容合并就得靠我们自己实现了，同时我们还得增加打印到文件的日志树和打印到网络的日志树实现。</p>

<h2 id="toc_3">JSON解析能力</h2>

<p>移动互联网产品与服务器端通信的数据格式，如果没有特殊需求的话，一般都使用JSON格式。Android系统也原生的提供了JSON解析的API，但是它的速度非常慢，而且没有提供简洁方便的接口来提高开发者的效率和降低出错的可能。所以我们就开始找第三方开源库来实现JSON解析，比较优秀的包括如下几种。</p>

<h3 id="toc_4">gson</h3>

<p>gosn是Google出品的JSON解析函数库，可以将JSON字符串反序列化对应的Java对象，或者反过来将Java对象序列化为对应的JSON字符串，免去了开发者手动通过JSONObject和JSONArray将JSON字段逐个进行解析的烦恼，也减少了出错的可能性，增强了代码的质量。使用gson解析时，对应的Java实体类无需使用注解进行标记，支持任意复杂Java对象包括没有源代码的对象。</p>

<h3 id="toc_5">jackson</h3>

<p>jcakson是Java语言的一个流行的JSON函数库，在Android开发中使用时，主要包含三部分。</p>

<ul>
<li>jackson-core：JSON流处理核心库</li>
<li>jackson-databind：数据绑定函数库，实现Java对象和JSON字符串流的相互转换。</li>
<li>jackson-annotations：databind使用的注解函数库</li>
</ul>

<p>由于jackson是针对Java语言通用的JSON函数库，并没有为Android优化定制过，因此函数保重包含很多非必要的API，相比其他的JSON函数库，用于Android平台会更显著的增大最终生成的APK的体积。</p>

<h3 id="toc_6">Fastjson</h3>

<p>Fastjson是阿里巴巴出品的一个Java语言编写的高性能且功能完善的JSON函数库。它采用一种“假定有序快速匹配”的算法，把JSON Parse的性能提升到极致，号称是目前Java语言中最快的JSON库。Fastjson接口简单易用，已经被广泛使用在缓存序列化、协议交互、Web输出、Android客户端等多种应用场景。</p>

<p>由于是Java语言通用的，因此，以前在Android上使用时，Fastjson不可避免的引入了很多对于Android而言冗余的功能，从而增加了包大小，很多人使用的就是标准版的fastjson，但事实上，fastjson还存在一个专门为Android定制的版本---fastjson.android 。和标准版本相比，Android版本去掉了一些Android虚拟机dalvik不支持的功能，使得jar更小。</p>

<h3 id="toc_7">LoganSquare</h3>

<p>LoganSquare是近两年崛起的快速解析和序列化JSON的Android函数库，其底层基于jackson的streaming API，使用APT(Android Annotation Tool)实现编译时注解，从而提高JSON解析和序列化的性能。官网上可以看到LoganSquare和gson、jackson databind的性能对比。</p>

<p><img src="media/15561207871674/15713660205585.jpg" alt=""/></p>

<p>从性能方面看，LoganSquare是完胜gson和jackson的。如果和fastjson相比较，两者应该是不相上下的。</p>

<p>再来看下jar包的大小</p>

<ul>
<li>gson：232KB</li>
<li>jackson：259+47+1229 = 1.5M</li>
<li>Fastjson：417KB</li>
<li>Fastjson.android：256KB</li>
<li>LoganSquare：48+259 = 307KB</li>
</ul>

<p>从性能和包大小综合考虑，最终我们会选择Fastjson.android作为基础技术堆栈中的JSON解析和序列化库。</p>

<h2 id="toc_8">数据库操作能力</h2>

<p>无论是iOS还是Android，底层数据库都是基于开源的SQLite实现，然后在系统层封装成用于应用层的API。虽然直接使用系统的数据库API性能很高，但是这些API接口并不是很方便开发者使用，一不小心就会引入Bug，而且代码的视觉效果也不佳。为了解决这个问题，对象关系映射（ORM）框架出现了，比较好的有ActiveAndroid，ormlite和greenDAO。</p>

<h3 id="toc_9">ActiveAndroid</h3>

<p>ActiveAndroid是一种Active Record风格的ORM框架，Active Record（活动目录）是Yii,Rails等框架中对ORM实现的典型命名方式。它极大的简化数据库的使用，使用面向对象的方式管理数据库，告别手写SQL的历史。每一个数据库表都可以被映射为一个类，开发者只需使用类似save()或者delete()这样的函数即可。</p>

<p>不过ActiveAndroid已经基本上处于维护阶段了，最新的一个Release版本是在2012年发布的。</p>

<h3 id="toc_10">ormlite</h3>

<p>ormlite是Java平台的一个ORM框架，支持JDBC连接、Spring和Android平台。在Android中使用时，它包含两部分。</p>

<ul>
<li>ormlite-core：核心模块，无论在哪个平台使用，都必须基于这个核心库，是实现ORM映射的关键模块。</li>
<li>ormlite-android：基于ormlite-core封装的针对Android平台的适配器模块，Android开发中主要跟这个模块打交道。<br/>
与ActiveAndroid类似，ormlite也已经不是一个活跃的开源库，最近一次Release版本是在2013年发布的。</li>
</ul>

<h3 id="toc_11">greenDAO</h3>

<p>greenDAO是一个轻量级且快速的ORM框架，专门为Android高度优化和定制，它能够支持每秒数千条记录的CRUD操作。官网上给出一张性能对比图</p>

<p><img src="media/15561207871674/15713660291443.png" alt=""/></p>

<p>纵轴表示每秒执行的操作数。而且greenDAO处在高度活跃中，最新Release版本是在2017年3月份发布的</p>

<h3 id="toc_12">Realm</h3>

<p>Realm是一个全新的移动数据库引擎，它既不是基于iOS平台的Core Data，也不是基于SQLite，它拥有自己的数据库存储引擎，并实现了高效快速的数据库构建操作，相比Core Data和SQLite，Realm操作要快很多，跟ORM框架相比就更不用说了。</p>

<p>Realm的好处如下：</p>

<ul>
<li>跨平台：Android和iOS已经是事实上的两大移动互联网操作系统，绝大多数应用都会支持这两个平台。使用Realm，Android和iOS开发者无需考虑内部数据的架构，调用Realm提供的API即可轻松完成数据的交换。</li>
<li>用法简单：相比Core Data和SQLite所需的入门知识，Realm可以极大降低开发者的学习成本，快速实现数据库存储功能。</li>
<li>可视化操作：Realm为开发者提供了一个轻量级的数据库可视化操作工具，开发者可以轻松查看数据库中的内容，并实现简单地插入和删除等操作。</li>
</ul>

<p>我们看下上述四种数据库包大小。</p>

<ul>
<li>activeandroid：40KB</li>
<li>greendao：100KB</li>
<li>ormlite-android：57KB</li>
<li>realm-android：4.2M</li>
</ul>

<p>可以看出，前三个还是正常范围，但Realm的大小一般项目可能无法接受。这是因为不同CPU架构平台的 .so 文件增加了整个包的大小，由于arm平台的so在其他平台上面能够以兼容模式运行的，虽然会损失性能，但是可以极大地减少函数库占用的空间。因此，可以选择只保留armeabi-v7a和x86两个平台的 .so 文件，直接删除无用的 .so 文件，或者通过工程的build.gradle文件中增加 ndk abi 过滤，语句如下：</p>

<pre><code class="language-text">android {
    ...
    defaultConfig {
        ...
        ndk {
            abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;
        } 
    }
}
</code></pre>

<p>因此，综合性能考虑，包大小以及开源库的可持续发展等因素，我们最终选择greenDAO。</p>

<h2 id="toc_13">网络通信能力</h2>

<p>现在的APP几乎都需要从服务器获取数据，不可避免的需要具备网络通信的能力，否则就是一个死界面。</p>

<h3 id="toc_14">android-async-http</h3>

<p>Android最经典的网络异步通信函数库，它对Apache的HttpClient API的封装使得开发者可以简洁优雅地实现网络请求和响应，并且同时支持同步和异步请求。主要特性如下：</p>

<ul>
<li>支持异步HTTP请求，并在匿名回调函数中处理响应</li>
<li>在子线程中发起HTTP请求</li>
<li>内部采用线程池来处理并发请求</li>
<li>通过RequestParams类实现GET/POST参数构造</li>
<li>无需第三方库支持即可实现Multipart文件上传</li>
<li>库的大小只有60KB</li>
<li>支持多种移动网络环境下自动智能的请求重试机制</li>
<li>HTTP响应中实现自动的gzip解码，实现快速请求响应</li>
<li>内置多种形式的响应解析，有原生的字节流、String、JSON对象，甚至可以将response写入到文件中。</li>
<li>可选的永久cookie保存，内部实现使用的是Android的SharedPreferences。</li>
</ul>

<p>但是在6.0之后，系统对开发者隐藏了HttpClient函数库，这显著增大了使用android-async-http的代价。 如果铁了心想继续使用HttpClient，官方推荐的做法是在编译期引入<code>org.apache.http.legacy</code> 这个库，库目录在Android SDK目录下的<code>platforms\android-23\optional</code>中找到，它的作用是确保在编译时不会出现找不到HttpClient相关API的错误，在应用运行时可以不依赖这个库，因为6.0以上的Android系统还没有真正移除HttpClient的代码，只不过API设置为对开发者不可见。我们查看<code>android-async-http</code>源码发现，需要使用下面这个函数库来替换之前的Apache的HttpClient。</p>

<pre><code class="language-text">dependencies {
    compile &#39;cz.msebera.android:httpclient:4.3.6&#39;
}
</code></pre>

<p>这样显著的增加了APP的包的大小，如果想继续使用android-async-http，那么你的APP需要额外增加1.1MB左右的大小。</p>

<h3 id="toc_15">OkHttp</h3>

<p>OkHttp是一个高效的HTTP客户端，具有如下特性。</p>

<ul>
<li>支持HTTP/2和SPDY，对同一台主机的所有请求共享同一个socket。</li>
<li>当SPDY不可用时，使用连接池减少请求的延迟。</li>
<li>透明的GZIP压缩减少下载数据大小</li>
<li>缓存响应避免重复的网络请求</li>
</ul>

<p>OkHttp在网络性能很差的情况下能够很好地工作，它能够避免常见的网络连接问题。如果你的HTTP服务有多个IP地址，OkHttp在第一次连接失败是，会尝试其他可选的地址。这对于IPv4+IPv6以及托管在冗余数据中心的服务来说是必要的。OkHttp使用现代的TLS特性（SNI,ALPN）初始化HTTP连接，当握手失败时，会降低使用TSL1.0初始化连接。</p>

<p>OkHttp依赖于okio，okio作为java.io和java.nio的补充，是square公司开发的一个函数库。okio使得开发者可以更好地访问、存储和处理数据。一开始是作为OkHttp的一个组件存在的，当然我们也可以单独使用它。</p>

<p>使用Okhttp需要引入Jar包，包的大小为：326+66 = 392KB</p>

<h3 id="toc_16">Volley</h3>

<p>Volley是Google在2013年发布的用于Android平台的网络通信库，能使网络通信更快、更简单、更健壮。官网配出一张弓箭发射图来说明Volley特别使用于数据量小等通信频繁的场景。</p>

<p>具体的将，Volley是为了简化网络任务而设计的，用于帮助开发者处理请求、加载、缓存、多线程、同步等任务。Volley设计了一个灵活的网络栈适配器，在Android2.2及之前的版本中，Volley底层使用Apache HttpClient，在Android2.3及以上版本中，它使用HttpURLConnection来发起网络请求，而且开发者也很容易将网络栈切换成使用OkHttp。<br/>
Volley 官方源码托管在Google Source上面，使用时只能直接以Jar包形式引入，如果想在Gradle中使用compile在线引入，可以考虑使用mcxiaoke在Github上面的Volley Mirror，然后再build.gradle中使用如下语句即可。</p>

<p><code>compile &#39;com.mcxiaoke.volley:library:1.0.19&#39;</code></p>

<h3 id="toc_17">Retrofit</h3>

<p>确切的说，Retrofit并不是一个完整的网络请求函数库，而是将REST API转换成Java接口的一个开源函数库，它要求服务器API接口遵循REST规范。基于注解使得代码变得很简洁，Retrofit默认情况下使用GSON作为JSON解析器，使用OkHttp实现网络请求，三者通常配合使用，当然我们也可以将这两者换成其他的函数库。</p>

<p>通过以上分析，HttpURLConnection、Apache HttpClient 和OkHttp封装了底层的网络请求，而android-async-http，Volley和Retrofit是基于前面三者的基础上二次开发而成。</p>

<p>最后看下函数库的大小</p>

<ul>
<li>android-async-http：106KB+1.1MB = 1.2MB</li>
<li>OkHttp：326KB+66KB = 392KB</li>
<li>Volley：94KB</li>
<li>Retrofit：122KB+211KB = 333KB</li>
</ul>

<h2 id="toc_18">图片缓存和显示能力</h2>

<p>图片缓存函数库有很多非常优秀的，开发人员可以根据需求进行选择。传统的图片缓存方案中设置有两级缓存，分别是内存缓存和磁盘缓存。在Facebook推出的Fresco中，它增加了一级缓存，也就是Native缓存，这极大地降低了使用Fresco的APP出现OOM的概率。</p>

<h3 id="toc_19">BitmapFun</h3>

<p>BitmapFun函数库是Android官方教程中的一个图片加载和缓存实例，对于简单的图片加载需求来说，使用BitmapFun就够了，在早期用的多，现在渐渐退出了实际项目开发的舞台。</p>

<h3 id="toc_20">Picasso</h3>

<p>Picasso是著名的square公司众多开源项目中的一个，它除了实现图片的下载和二级缓存功能，还解决了常见的一些问题。</p>

<ul>
<li>在adapter中正常的处理ImageView回收和下载的取消</li>
<li>使用尽量小的内存实现复杂的图像变换</li>
</ul>

<p>在Picasso中，我们使用一行代码即可实现图片下载并渲染到ImageView中。</p>

<p><code>Picasso.with(context).load(url).into(imageView);</code></p>

<h3 id="toc_21">Glide</h3>

<p>Glide是Google推荐的用于Android平台上的图片加载和缓存函数库。这个库被广泛应用在Google的开源项目中，Glide和Picasso有90%的相似度，只是在细节上还是存在不少区别。Glide为包含图片的滚动列表做了尽可能流畅的优化。除了静态图片，Glide也支持GIF格式图片的显示。Glide提供了灵活的API可以让开发者方便地替换下载图片所用的网络函数库，默认情况下，它使用HttpUrlConnection作为网络请求模块，开发者也可以根据自己项目的实际需求灵活使用Google的Volley或者Square的OkHttp等函数库进行替换。</p>

<p>Glide的使用也可以使用一行代码来完成，语句如下</p>

<p><code>Glide.with(context).load(url).into(imageView);</code></p>

<h3 id="toc_22">Fresco</h3>

<p>Fresco是Facebook开源的功能强大的图片加载和缓存函数库，相比其他图片缓存库，Fresco最显著的特点是具有三级缓存：两级内存缓存和一级磁盘缓存。主要特性如下：</p>

<ul>
<li>渐进式地加载JPEG图片</li>
<li>显示GIF和WebP动画</li>
<li>可扩展，可自定义图片加载和显示</li>
<li>在Android 4.X和一下的系统上，将图片放在Android内存一个特殊的区域，从而使得应用运行更流畅，同时极大减低出现OutOfMemoryError的错误。</li>
</ul>

<h3 id="toc_23">Android-Universal-Image-Loader</h3>

<p>Android-Universal-Image-Loader简称UIL，是Android平台老牌的图片下载和缓存函数库，功能强大灵活且高度可自定义，它提供一系列配置选项，并能很好地控制图片加载和缓存的过程。使用者甚多，现在项目仍在使用。UIL也支持二级缓存，特性如下：</p>

<ul>
<li>同步或异步的多线程图片加载</li>
<li>高度可自定义：线程池、下载器、解码器、内存和磁盘缓存、图片显示选项等。</li>
<li>每张图片的显示支持多种自定义选项：默认存根图片、解码选项、Bitmap处理和显示等。</li>
<li>图片可缓存在内存或者磁盘（设备的文件系统或者SD卡）上。</li>
<li>可实时监听图片加载流程，包括下载进度。</li>
</ul>

<p>最后看下几个库的包大小</p>

<ul>
<li>BitmapFun：71KB</li>
<li>Picasso：120KB</li>
<li>Glide：475KB</li>
<li>Fresco：47KB+93KB+93KB+10KB+3MB+62KB+8KB+111KB = 3.4MB</li>
<li>Android-Universal-Image-Loader：162KB</li>
</ul>

<p>图片函数库的选择需要根据APP的具体情况而定，对于严重依赖图片缓存的APP,例如壁纸类，图片社交类APP来说，可以选择最专业的Fresco。对于一般的APP，选择Fresco会显得比较重，毕竟Fresco 3.4MB的体量摆在这。</p>

<p>根据APP对图片显示和缓存的需求从低到高我们可以对以上函数库做一个排序</p>

<p><code>BitmapFun &lt; Picasso &lt; Android-Universal-Image-Loader &lt; Glide &lt; Fresco</code></p>

<p>值得一提的是，如果你的APP计划使用React Native进行部分模块功能的开发的话，那么在基础函数库选择方面需要考虑和React Native的依赖库的复用，这样可以减少引入React Native 所增加的APP的大小，可以复用的函数库有：OkHttp，Fresco,jackson-core.</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/07</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871588.html">
                
                  <h1>Android 自定义 LayoutInflate 实现酷炫引导页</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>今天，我们来搞点事情，自定义一个 LayoutInflate，搞点有意思的东西，实现一个酷炫的动画。<br/><br/>
首先，在自定义 LayoutInflate 之前，我们要先分析一下 LayoutInflate 的源码，了解了源码的实现方式，才能定制嘛~~~~<br/>
好了，怕你们无聊跑了，先放效果图出来镇贴</p>

<p><img src="media/15561207871588/20171104150978927436317.gif" alt=""/></p>

<p>好了，效果看完了，</p>

<p>那就先从LayoutInflate的源码开始吧。</p>

<h2 id="toc_0">LayoutInflate</h2>

<p><img src="media/15561207871588/15713651711430.jpg" alt=""/></p>

<p>还是提取一下关键信息吧。</p>

<ol>
<li><p>LayoutInflate 可以将 xml 文件解析成 View 对象。获取方式有两种getLayoutInflater()和getSystemService(Class)。</p></li>
<li><p>如果要创建一个新的 LayoutInflate去解析你自己的 xml，可以使用 cloneInContext，然后调用 setFactor()。</p></li>
</ol>

<p>好了，我们先来回顾一下平时我们是怎么把 xml 转换成 View 的吧。</p>

<ul>
<li>setContentView（）</li>
</ul>

<p>我们给 Activity 设置 布局 xml 都是调用这个方法，现在我们就来看看这个方法到底干了什么事。</p>

<pre><code class="language-java">public void setContentView(@LayoutRes int layoutResID) {
  getWindow().setContentView(layoutResID);
  initWindowDecorActionBar();
}
-----以上是 Activity 的方法，调用了 Window 的 steContentView
----手机上的 window 都是 PhoneWindow,就不饶弯了，直接看 PhoneWindow
----的setContentView方法。
public void setContentView(int layoutResID) {
    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
    // decor, when theme attributes and the like are crystalized. Do not check the feature
    // before this happens.
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                getContext());
        transitionTo(newScene);
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    mContentParent.requestApplyInsets();
    final Callback cb = getCallback();
    if (cb != null &amp;&amp; !isDestroyed()) {
        cb.onContentChanged();
    }
}
----在构造方法里面找到了mLayoutInflater 的赋值
public PhoneWindow(Context context) {
    super(context);
    mLayoutInflater = LayoutInflater.from(context);
}
</code></pre>

<ul>
<li>View.inflate()</li>
</ul>

<p>同样是调用了LayoutInflate.inflate()方法</p>

<pre><code class="language-java">public static View inflate(Context context, @LayoutRes int resource, ViewGroup root) {
    LayoutInflater factory = LayoutInflater.from(context);
    return factory.inflate(resource, root);
}
</code></pre>

<ul>
<li>LayoutInflate.from(context).inflate()  同上</li>
</ul>

<p>我们项目中所有的 Xml 转 View 都离不开这三个方法吧，这三个方法最终调用的都还是 LayoutInflate 的 inflate 方法。</p>

<p>我们再来看看怎么获取到 LayoutInflate 的实例。<br/>
上面三个xml 解析成 view 的方法都是用LayoutInflate.from(context)来获取 LayoutInflate 实例的。</p>

<pre><code class="language-java">public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
   if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
   }
   return LayoutInflater;
}
</code></pre>

<p>看到这个代码有木有觉得很眼熟啊，我们的 ActivityService、WindowService、NotificationService等等各种 Service 是不是都这样获取的。而我们都知道这些系统服务都是单例的，并且在应用启动的时候系统为其初始化的。好了，撤远了~~</p>

<p>回过头来，我们继续看 LayoutInflate 源码。</p>

<ul>
<li>inflate(@LayoutRes int resource, @Nullable ViewGroup root)<br/>
这个方法就是将xml 文件转换成 View 的方法，我们项目中所有的 xml 解析调用的都是这个方法。第一个参数是 xml 资源 id，第二个方法是解析后的 View 是否要添加到 root view里面去。</li>
</ul>

<p>通过 Resources 获取 xml 解析器XmlResourceParser。</p>

<pre><code class="language-java">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;
                + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre>

<p>XmlResourceParser解析 xml，并且返回 view</p>

<pre><code class="language-java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        //写入跟踪信息，用于 Debug 相关，先不关心这个
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);

        final Context inflaterContext = mContext;
        //用于读取 xml 节点
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
          // Look for the root node.
          int type;
          //空信息直接跳过
            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
                // Empty
            }
            //防错判断
            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;);
            }
            //获取类名，比如说 TextView
          final String name = parser.getName();

          if (DEBUG) {
                System.out.println(&quot;**************************&quot;);
                System.out.println(&quot;Creating root view: &quot; + name);
                System.out.println(&quot;**************************&quot;);
            }
            //如果标签是merge
            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                //merge作为顶级节点的时候必须添加的 rootview
                throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;);
                }
                //递归方法去掉不必要的节点，为什么 merge 可以优化布局
                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp 是根节点
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;
               //如果不添加到 rootView 切 rootView 不等于空，则生成 LayoutParams
                if (root != null) {
                    if (DEBUG) {
                        System.out.println(&quot;Creating params from root: &quot; + root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

             if (DEBUG) {
                    System.out.println(&quot;-----&gt; start inflating children&quot;);
                }

                // 解析子节点
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; done inflating children&quot;);
                }

                // 如果要添加到 rootview。。
                // to root. Do that now.
                if (root != null &amp;&amp; attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }
        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
          ex.initCause(e);
          throw ex;
       } catch (Exception e) {
            InflateException ex = new InflateException(parser.getPositionDescription() + &quot;: &quot; + e.getMessage());
            ex.initCause(e);
            throw ex;
       } finally {
            // Don&#39;t retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        //返回解析结果
        return result;
    }
}
</code></pre>

<p>在这个方法中，判断了是否使用 merge 优化布局，然后通过createViewFromTag解析的顶级 xml 节点的 view，并且处理了是否添加解析的布局到 rootView。调用rInflateChildren方法去解析子 View 并且添加到顶级节点 temp 里面。最后返回解析结果。</p>

<p>我们先来看看 createViewFromTag</p>

<pre><code class="language-java">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,boolean ignoreThemeAttr) {
    //获取命名空间
   if (name.equals(&quot;view&quot;)) {
        name = attrs.getAttributeValue(null, &quot;class&quot;);
   }
   // 给 view 设置主题。现在知道为什么colorPrimary等 theme 属性会影响控件颜色了吧
   if (!ignoreThemeAttr) {
        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);
        final int themeResId = ta.getResourceId(0, 0);
        if (themeResId != 0) {
            context = new ContextThemeWrapper(context, themeResId);
        }
        ta.recycle();
   }
    //让 view 闪烁，可以参考http://blog.csdn.net/qq_22644219/article/details/69367150
    if (name.equals(TAG_1995)) {
        // Let&#39;s party like it&#39;s 1995!
        return new BlinkLayout(context, attrs);
    }

   try {
        View view;
        //优先调用了mFactory2的 oncreateView 方法，创建了 temp View
        if (mFactory2 != null) {
            view = mFactory2.onCreateView(parent, name, context, attrs);
        } else if (mFactory != null) {
            view = mFactory.onCreateView(name, context, attrs);
        } else {
            view = null;
        }

        if (view == null &amp;&amp; mPrivateFactory != null) {
            view = mPrivateFactory.onCreateView(parent, name, context, attrs);
        }

        if (view == null) {
            final Object lastContext = mConstructorArgs[0];
            mConstructorArgs[0] = context;
            try {
                if (-1 == name.indexOf(&#39;.&#39;)) {
                    view = onCreateView(parent, name, attrs);
                } else {
                    view = createView(name, null, attrs);
                }
            } finally {
                mConstructorArgs[0] = lastContext;
            }
        }

        return view;
    } catch (InflateException e) {
        throw e;

    } catch (ClassNotFoundException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + &quot;: Error inflating class &quot; + name);
        ie.initCause(e);
        throw ie;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + &quot;: Error inflating class &quot; + name);
        ie.initCause(e);
        throw ie;
    }
}
</code></pre>

<p>这里我们可以知道，mFactor或者 mFactor 不为 null，则调用mFactor来创建 View，如果mFactor为 null 或者mFactor创建是失败，则最终调用LayoutInflate 的createView方法 来创建 View 的，它传入了 view 的 parent、name、context、 attrs。</p>

<p>接下来继续去看子 View 的解析rInflateChildren</p>

<pre><code class="language-java">void rInflate(XmlPullParser parser, View parent, Context context,AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException {
//获取布局层级
    final int depth = parser.getDepth();
    int type;
    //没看懂没事，我们不是来纠结 xml 解析的
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }

        final String name = parser.getName();
        //requestFocus标签，http://blog.csdn.net/ouyang_peng/article/details/46957281
        if (TAG_REQUEST_FOCUS.equals(name)) {
            parseRequestFocus(parser, parent);
        } else if (TAG_TAG.equals(name)) {
        //tag标签，只能用于 api21以上，给父view 设置一个 tag
            parseViewTag(parser, parent, attrs);
       } else if (TAG_INCLUDE.equals(name)) {
       //include 节点
            if (parser.getDepth() == 0) {
                throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);
            }
            parseInclude(parser, context, parent, attrs);
        } else if (TAG_MERGE.equals(name)) {
        //merge 节点
            throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);
        } else {
        //走了刚刚的那个方法，创建 view 设置 LayoutParams
            final View view = createViewFromTag(parent, name, context, attrs);
            final ViewGroup viewGroup = (ViewGroup) parent;
            final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);
            rInflateChildren(parser, view, attrs, true);
            //添加到付 view
            viewGroup.addView(view, params);
        }
    }

    if (finishInflate) {
        parent.onFinishInflate();
    }
}
</code></pre>

<p>我们来整理一下思路吧，调用步骤</p>

<ol>
<li>LayoutInflater 的静态方法 form 获取LayoutInflater实力</li>
<li>inflate解析 xml 资源</li>
<li>inflate 调用createViewFromTag创建了顶级view</li>
<li>inflate 调用rInflateChildren 创建所有子 view</li>
<li>rInflateChildren递归调用rInflate创建所有子 view。</li>
<li>rInflate通过调用createViewFromTag真正创建一个 view。</li>
<li>createViewFromTag优先使用 mFactory2、mFactory、mPrivateFactory来创建 View，如果创建失败，则最终调用createView方法来创建。创建的过程中用了parent,name,context,attrs等参数，然后运用反射的方法，创建出 View，</li>
</ol>

<p>因此，我们所有的 View 的构造方法都是被 <code>LayoutInflate</code> 的Factory调用创建出来的。<br/>
如果要自定义 <code>LayoutInflate</code> 解析，只需要给调用<code>LayoutInflate</code>的 <code>setFactory</code>设置我们自定义的 <code>Factory</code> 即可。<br/>
但是问题来了，LayoutInflate是系统服务，而且是单例，我们直接调用LayoutInflate的 setFactory 方法，会影响后期所有 view 的创建。</p>

<p>所以我们需要用到<code>LayoutInflate</code>的<code>cloneInContext</code>方法<code>clone</code>一个新的 <code>LayoutInflate</code>，然后再设置自己的 <code>Factory</code>。至于<code>LayoutInflate</code>是一个抽象类，<code>cloneInContext</code>是一个抽象方法，我们根本不用关心，因为我们直接用系统创建好的<code>LayoutInflate</code>即可。</p>

<p>好了，<code>LayoutInflate</code>的源码分析完了，接下来我们来分析动画了。</p>

<h2 id="toc_1">动画分析</h2>

<p>源码看了很久，我们再来重新看一遍动画吧</p>

<p><img src="media/15561207871588/20171104150979091135893.gif" alt=""/></p>

<ol>
<li>翻页</li>
<li>翻页的时候天上的云，地上的建筑物移动速度和翻页速度不一样</li>
<li>不同的背景物移动速度不一样，最后一页背景物上下扩散</li>
<li>翻页的过程中，人一直在走路</li>
<li>最后一页人要消失。</li>
</ol>

<p>解决方案：</p>

<ol>
<li>ViewPager</li>
<li>给 viewPage设置PageChangeListener，在滚动的时候给各种 背景物体设置setTranslation。</li>
<li>不同的背景物设置不同的setTranslation系数。</li>
<li>人物走路用帧动画即可，在viewPage滑动处于SCROLL_STATE_DRAGGING状态的时候开启帧动画。</li>
<li>这个简单，监听onPageSelected，然后再设置人为 View.GONE即可。</li>
</ol>

<p>解决方案的问题：<br/><br/>
粗略数了一下，6个页面大概有50个左右的背景物。如果要一个一个去获取 id，然后再根据不同的 id，设置不同的滑动速度滑动方向，可能你会疯掉。</p>

<p>因此，我们需要想一个办法，去解决这个问题。可能有的童鞋会说，我写一个自定义 View，设置滑动速度系数属性就行了呀。这个方法可以实现，but，你还是需要一个一个去 <code>findViewbyid</code>。</p>

<p>那么，我们是不是可以给 xml 添加自定义标签，然后自定义解析。比如说，天上的云，滑进来的阻尼系数是0.4，滑出去的阻尼系数是0.6，只需要在 xml 里面设置好这两个参数，然后我们再在合适的时使用这两个参数即可啊。</p>

<h2 id="toc_2">自定义LayoutInflater.Factory</h2>

<p>咦，怎么变成自定义<code>LayoutInflater.Factory</code>了，哈哈哈，还记得刚刚<code>LayoutInflater</code>的源码分析么，View 的创建全部在<code>createViewFromTag</code>里面，而<code>createViewFromTag</code>优先使用 Factory 来 创建。然后我们来看看Factory到底是干嘛的。</p>

<p>Hook you can supply that is called when inflating from a LayoutInflater.<br/>
You can use this to customize the tag names available in your XML layout files.</p>

<ul>
<li>当LayoutInflater在解析布局的时候会被调用</li>
<li>可以用来读取 xml 中的自定义标签。</li>
</ul>

<p>这下迷惑都解开了吧，啊哈哈哈哈~~<br/><br/>
现在，我们就来定义这个 Factory<br/><br/>
思路很简单。  </p>

<ol>
<li>继承LayoutInflater.Factory2</li>
<li>实现抽象方法onCreateView</li>
<li>在onCreateView里面使用 LayoutInflate 的 createView方法创建View</li>
<li>创建成功之后，读取 view 的 attrs 属性，作为 tag 保持到 viewTag。</li>
</ol>

<p>关键代码如下：</p>

<pre><code class="language-java">@Override
public View onCreateView(String name, Context context, AttributeSet attrs) {
 //创建一个 View
    View view = createViewOrFailQuietly(name, context, attrs);

    //实例化完成
    if (view != null) {
        //获取自定义属性，通过标签关联到视图上
        setViewTag(view, context, attrs);
        //所有带有自定义属性的 View 保存起来，供动画切换的时候调用
        mParallaxView.getParallaxViews().add(view);
    }
    return view;
}
</code></pre>

<p>创建 view 的方法，这里注意一下，xml 标签里面系统的 view只有类名，自定义 view 是全路径。如：,而可以省略路径的 View 又分为 &quot;android.widget.&quot;和&quot;android.view.&quot;包下，所以对于只写缩写的 view，需要遍历这两个路径。</p>

<pre><code class="language-java">private View createViewOrFailQuietly(String name, Context context,
                                     AttributeSet attrs) {
    //1.自定义控件标签名称带点，所以创建时不需要前缀
    if (name.contains(&quot;.&quot;)) {
        createViewOrFailQuietly(name, null, context, attrs);
    }
    //2.系统视图需要加上前缀
    for (String prefix : sClassPrefix) {
        View view = createViewOrFailQuietly(name, prefix, context, attrs);
        if (view != null) {
            return view;
        }
    }
    return null;
}
private View createViewOrFailQuietly(String name, String prefix, Context context,
                                     AttributeSet attrs) {
    try {
        //通过系统的inflater创建视图，读取系统的属性
        return inflater.createView(name, prefix, attrs);
    } catch (Exception e) {
        return null;
    }
}
</code></pre>

<p>读取 attrs 里面的属性，给含有特点 attrs 属性的 view设置 tag 并保存起来。</p>

<pre><code class="language-java">private void setViewTag(View view, Context context, AttributeSet attrs) {
    //所有自定义的属性
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AnimationView);
    if (a != null &amp;&amp; a.length() &gt; 0) {
        //获取自定义属性的值
        ParallaxViewTag tag = new ParallaxViewTag();
       tag.xIn = a.getFloat(R.styleable.AnimationView_x_in, 0f);
       tag.xOut = a.getFloat(R.styleable.AnimationView_x_out, 0f);
       tag.yIn = a.getFloat(R.styleable.AnimationView_y_in, 0f);
       tag.yOut = a.getFloat(R.styleable.AnimationView_y_in, 0f);

       //index
       view.setTag(view.getId(), tag);
       a.recycle();
   }
}
</code></pre>

<p>好了，我们自定义LayoutInflater.Factory已经结束了，so，我们可以直接调用 LayoutInflate.cloneInContext(context)获取一个新的 LayoutInflate，然后再setFactor(customFactor)就可以了。代码如下：</p>

<pre><code class="language-java">@Override
public View onCreateView(LayoutInflater original, ViewGroup container,
                         Bundle savedInstanceState) {
    Bundle args = getArguments();
    int layoutId = args.getInt(&quot;layoutId&quot;);
    LayoutInflater layoutInflater = original.cloneInContext(getActivity());
    layoutInflater.setFactory(new ParallaxFactory(layoutInflater, this));
    return layoutInflater.inflate(layoutId, null);
}
</code></pre>

<p>接下来的代码就不写了吧，就是监听 ViewPager 的滑动事件，获取当前滑出滑进页面的自定义了 attrs 属性的 View 列表，然后再根据滑出屏幕的比例*属性参数做 view 的 TranslationY/TranslationX 操作。<br/><br/>
这里我贴一下代码仓库地址吧，有兴趣的小伙伴可以把代码跑起来看一下  </p>

<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdiamondlin2016%2FParallaxlayoutinflater">github传送门</a></p>

<p>看起来好像并没有什么卵用，就是秀了一波骚操作。写一个自定义 view，继承 ImageView，设置几个自定义 attrs 属性，再在构造方法里面把属性读出来保存到类变量，对外提供读取方法，然后同样监听 viewpager 的滑动就行了。</p>

<p>哈哈哈哈~~分享这篇文章的最终目的不是为了实现这个动画，就是想看一下 LayoutInflate 的源码，了解一下 xml 文件是怎么解析成 view的过程。。。。</p>

<h2 id="toc_3">已知 bug：</h2>

<p>v4的版本升级到19.1.0之后动画会失效<br/><br/>
引入appcompat包会报 xml 解析错误。  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/04</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871543.html">
                
                  <h1>Android 用贝塞尔曲线绘制酷炫轮廓背景</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15561207871543/15713367433328.png" alt=""/></p>

<p>Github地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FOCNYang%2FContourView">github.com/OCNYang/Con…</a></p>

<p>今天就借助这个开源控件，来为大家梳理一下自定义 View 的整个流程：</p>

<ol>
<li>分析需求、功能，确定实现方法；</li>
<li>总结所需的参数属性以满足可定制性，较明确的属性归纳为自定义属性，不适合自定义属性的（比如传入数据，对象等）提供方法来设置；</li>
<li>有时自定义 View 会提供一种或几种默认及内置的样式，（这时可以根据内置的样式种类补充到自定义属性中），同时分析，使用内置样式或用户定制拓展时的流程；</li>
<li>开始根据分析，按流程依次重写： <code>构造函数（获取自定义属性，设置画笔等）</code> --&gt; <code>onMeasure()(测量大小)</code> --&gt; <code>onSizeChanged()(确定大小，一般我们在这里获取大小)</code> --&gt; <code>（onLayout()自定义View，因为没有子控件，这一步是不需要的）</code> --&gt; <code>onDraw()(按照需求和根据属性绘制实际内容)</code> --&gt; <code>其他</code></li>
</ol>

<p>如果有事件的需求，添加事件相关逻辑。<br/><br/>
那么现在我们就根据上面这个流程一步步来实现 ContourView。  </p>

<h2 id="toc_0">分析</h2>

<p><img src="media/15561207871543/15713367536405.png" alt=""/></p>

<p>根据上面的分析，实现的思路大概都有了。那么我们就开始寻找具体实现方法。<br/>
首先，我们选用三阶贝塞尔曲线，我们都知道三阶曲线的计算公式是：</p>

<pre><code class="language-text">path.moveTo(start.x, start.y);
path.cubicTo(control1.x, control1.y, control2.x,control2.y, end.x, end.y);
</code></pre>

<p><img src="media/15561207871543/20171104150978744638463.gif" alt=""/></p>

<p>也就是说绘制一段曲线，我们需要知道两个锚点的坐标以及两个控制点的坐标，为了保证曲线的弯曲度能够达到理想的状态，控制点的坐标也不能是随意取的，这就要求我们必须通过一种计算方法合理的得出控制点的坐标。Google 了一下，发现先驱们已经找到了很多种方法供我们选择。</p>

<p>最终经过对比我们选用了这样一种方法：</p>

<p><img src="media/15561207871543/15713367665733.png" alt=""/></p>

<p>这种方法大概的形式如上图，利用锚点集合，连续的4个锚点坐标Pi-1、Pi、Pi+1、Pi+2，通过具体公式来计算出中间两个锚点之间曲线的两个控制点坐标。</p>

<blockquote>
<p>详细的计算方法介绍请看 ContourView 的 WiKi：<br/>
<strong>Bézier-求贝塞尔曲线控制点</strong></p>
</blockquote>

<h2 id="toc_1">归纳自定义属性</h2>

<p>通过上面的分析，其实我们大概能总结出需要自定义的属性有哪些了。这里不着急，我们先总结一下自定义属性相关的内容和步骤？</p>

<ul>
<li><strong>创建自定义属性文件</strong></li>
</ul>

<p>在 res/values/ 下新建 attrs.xml 文件（默认新建项目没有这个文件）。文件内容类似如下：</p>

<pre><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;attr name=&quot;custom_color&quot; format=&quot;color&quot;/&gt;

    &lt;declare-styleable name=&quot;ContourView&quot;&gt;
        &lt;attr name=&quot;shader_color&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;smoothness&quot; format=&quot;float&quot;/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre>

<p>其中 attr 和 declare-styleable 节点分别代表的意思如下：</p>

<p><strong>attr</strong>： 定义了一个属性，属性名为 custom_color 这个是可以随意起的，但是要注意不要和其他控件所冲突， format 所定义的是属性的格式，其中格式又分为好多种，下面会细说，这里定义的是颜色 color。</p>

<p><strong>declare-styleable</strong>：定义了一个属性组，在里面我们可以单独写 attr 属性，也可以引用直接在 resources 下定义的 attr，其中的区别就是引用的不用写 format。</p>

<p>需要注意的是，attr 并不依赖与 declare-styleable，declare-styleable 只是方便了 attr 的使用，使属性的使用更加明确。两者在代码中的获取方式并不相同，下面会细说。</p>

<p>在实际开发中，我们一般是采用 declare-styleable 方式，直接定义一组自己所编写的自定义控件需要用到的属性。</p>

<ul>
<li><strong>自定义属性的可以设置哪些属性</strong></li>
</ul>

<p>我们根据需要可以设置的自定义属性的格式一共有一下几种：</p>

<table>
<thead>
<tr>
<th style="text-align: center">format=&quot;格式&quot;</th>
<th style="text-align: center">说明</th>
<th style="text-align: center">app:myattr=&quot;使用值&quot;</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">reference</td>
<td style="text-align: center">参考某一资源ID</td>
<td style="text-align: center">&quot;@drawable/图片ID&quot;</td>
</tr>
<tr>
<td style="text-align: center">color</td>
<td style="text-align: center">颜色值</td>
<td style="text-align: center">&quot;#FFFFFFFF&quot; or &quot;@color/颜色ID&quot;</td>
</tr>
<tr>
<td style="text-align: center">boolean</td>
<td style="text-align: center">布尔值</td>
<td style="text-align: center">&quot;true&quot; or &quot;false&quot;</td>
</tr>
<tr>
<td style="text-align: center">dimension</td>
<td style="text-align: center">尺寸值</td>
<td style="text-align: center">&quot;0dp&quot;</td>
</tr>
<tr>
<td style="text-align: center">float</td>
<td style="text-align: center">浮点型</td>
<td style="text-align: center">&quot;1.2&quot;</td>
</tr>
<tr>
<td style="text-align: center">integer</td>
<td style="text-align: center">整型值</td>
<td style="text-align: center">&quot;10&quot;</td>
</tr>
<tr>
<td style="text-align: center">fraction</td>
<td style="text-align: center">百分数值</td>
<td style="text-align: center">&quot;50%&quot;</td>
</tr>
<tr>
<td style="text-align: center">string</td>
<td style="text-align: center">字符串</td>
<td style="text-align: center">&quot;OCN.Yang&quot;</td>
</tr>
<tr>
<td style="text-align: center">enum</td>
<td style="text-align: center">枚举值（详见下）</td>
<td style="text-align: center">&quot;自定义类型名称&quot;</td>
</tr>
<tr>
<td style="text-align: center">flag</td>
<td style="text-align: center">位或运算</td>
<td style="text-align: center">&quot;center</td>
</tr>
</tbody>
</table>

<blockquote>
<p>附：<br/><br/>
enum 枚举型定义：<br/>
<code>&lt;attr name=&quot;handsomeBoy&quot;&gt;</code><br/><br/>
    <code>&lt;enum name=&quot;OCNYang&quot; value=&quot;0x01&quot;/&gt;</code><br/><br/>
    <code>&lt;enum name=&quot;TFBOYS&quot; value=&quot;0x10&quot;/&gt;</code><br/><br/>
<code>&lt;/attr&gt;</code><br/><br/>
enum 使用：<br/><br/>
<code>app:handsomeBoy=&quot;OCNYang&quot;</code><br/><br/>
flag 定义：<br/><br/>
<code>&lt;attr name=&quot;gravity&quot;&gt;</code><br/><br/>
    <code>&lt;flag name=&quot;top&quot; value=&quot;0&quot;/&gt;</code><br/><br/>
    <code>&lt;flag name=&quot;center&quot; value=&quot;1&quot;/&gt;</code><br/><br/>
    <code>&lt;flag name=&quot;bottom&quot; value=&quot;2&quot;/&gt;</code><br/><br/>
<code>&lt;/attr&gt;</code><br/><br/>
flag 使用：<br/><br/>
<code>app:gravity=&quot;center|bottom&quot;</code><br/><br/>
混搭使用<br/><br/>
<code>&lt;attr name=&quot;background&quot; format=&quot;reference|color&quot;/&gt;</code><br/><br/>
这样，你传入资源ID或颜色值都是可以的了。</p>
</blockquote>

<ul>
<li><strong>获取自定义属性</strong></li>
</ul>

<p>那怎么获取这些自定义的属性呢，只需要在自定义 View 的构造方法（两个参数或两个以上的参数）里通过一下方式就能获取到了：</p>

<pre><code class="language-java">public ContourView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ContourView);
    //注意：获取时自定义的属性名有变动，例如：定义名：contour_style -&gt; 获取名：ContourView_contour_style（即：自定义属性组名_属性名）
    mStyle = typedArray.getInt(R.styleable.ContourView_contour_style, STYLE_SAND);
}
</code></pre>

<p>当然获取时，不同格式的属性需要通过 TypedArray 对应的不同的方法获取，那 TypedArray 都有哪些获取方法呢？如下图：</p>

<p><img src="media/15561207871543/15713368060868.png" alt=""/></p>

<p>通过方法名称，相信你能很轻易的知道，需要哪个对应方法获取了。</p>

<blockquote>
<p>如果你想更详细的了解每个方法的详细介绍，可以点击下面链接查看：<br/>
<a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.android.com%2Freference%2Fandroid%2Fcontent%2Fres%2FTypedArray.html">developer.android.com/reference/a…</a><br/>
另外，比较特殊的 enum 的获取方法：<br/>
由于 enum 的 value 值只能设置 int 型，所以，获取enum的方式是 getInt()。</p>
</blockquote>

<p>好了，关于自定义属性的介绍大概就是这么多内容了，那么回到原题，我们的 ContourView 需要哪几种 自定义属性呢？其实通过分析模块中我们就基本知道我们需要的属性有哪些了：</p>

<ul>
<li>内置轮廓样式： enum 类型，内置多少个 enum 就有多少类型；</li>
<li>绘制颜色：纯色绘制时，我们需要一个颜色值，Color 属性</li>
<li>Shader 相关：
<ol>
<li>采用哪种 Shader，enum 类型，有RadialGradient、SweepGradient、LinearGradient；</li>
<li>Shader 的颜色，Color 类型，需要两个一个startColor，一个endColor；</li>
<li>Shader 填充的控制，enum 类型，我们提供几种填充的方向，比如左上角到右下角，从上到下，然后我们再通过这个方向和传入的秒点集来动态计算起点和终点的坐标</li>
</ol></li>
</ul>

<p>具体如下：</p>

<pre><code class="language-text">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;ContourView&quot;&gt;
        &lt;attr name=&quot;shader_mode&quot;&gt;
            &lt;enum name=&quot;RadialGradient&quot; value=&quot;0x01&quot;/&gt;
            &lt;enum name=&quot;SweepGradient&quot; value=&quot;0x02&quot;/&gt;
            &lt;enum name=&quot;LinearGradient&quot; value=&quot;0x03&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;shader_startcolor&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;shader_endcolor&quot; format=&quot;color&quot;/&gt;
        &lt;attr name=&quot;shader_style&quot;&gt;
            &lt;enum name=&quot;LeftToBottom&quot; value=&quot;0x00&quot;/&gt;
            &lt;enum name=&quot;RightToBottom&quot; value=&quot;0x11&quot;/&gt;
            &lt;enum name=&quot;TopToBottom&quot; value=&quot;0x12&quot;/&gt;
            &lt;enum name=&quot;Center&quot; value=&quot;0x13&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;contour_style&quot;&gt;
            &lt;enum name=&quot;Beach&quot; value=&quot;0x23&quot;/&gt;
            &lt;enum name=&quot;Ripples&quot; value=&quot;0x22&quot;/&gt;
            &lt;enum name=&quot;Clouds&quot; value=&quot;0x21&quot;/&gt;
            &lt;enum name=&quot;Sand&quot; value=&quot;0x00&quot;/&gt;
            &lt;enum name=&quot;Shell&quot; value=&quot;0x25&quot;/&gt;
        &lt;/attr&gt;
        &lt;attr name=&quot;shader_color&quot; format=&quot;color&quot;/&gt;
        &lt;!--弯曲系数，在通过贝塞尔曲线绘制曲线时，来控制弯曲度--&gt;
        &lt;attr name=&quot;smoothness&quot; format=&quot;float&quot;/&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre>

<h2 id="toc_2">内置样式</h2>

<p>既然自定义 View，那我们一定会为它提供一种或几种内置好的样式呀。这样别人在偷懒不想自己定制样式时，可以也有不错的显示效果呀！<br/><br/>
通过上面知道，ContourView 的轮廓样式主要是通过给出的锚点集控制的，所有的锚点围成的闭合曲线就是轮廓的大概样式了。<br/><br/>
所以，这里我们想内置几种样式，就等于内置几个锚点集就行了，这里的我们内置的锚点坐标为了使得不同大小显示效果相同，我们先在 onSizeChanged() 获得了 View 的宽高，然后根据宽高按照百分比来设置坐标。  </p>

<p>设置的内置轮廓有以下几种（丑爆了），只是轮廓，颜色是自己设置的：</p>

<table>
<thead>
<tr>
<th style="text-align: center">样式（contuor_style）</th>
<th style="text-align: center">效果</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">Sand(默认)</td>
<td style="text-align: center"><img src="media/15561207871543/15713368277148.png" alt=""/></td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Clouds</td>
<td style="text-align: center"><img src="media/15561207871543/15713368407348.png" alt=""/></td>
</tr>
<tr>
<td style="text-align: center">Beach</td>
<td style="text-align: center"><img src="media/15561207871543/15713368560128.png" alt=""/></td>
</tr>
<tr>
<td style="text-align: center">Ripples</td>
<td style="text-align: center"><img src="media/15561207871543/15713368665659.png" alt=""/></td>
</tr>
<tr>
<td style="text-align: center"></td>
<td style="text-align: center"></td>
</tr>
<tr>
<td style="text-align: center">Shell</td>
<td style="text-align: center"><img src="media/15561207871543/15713368743740.png" alt=""/></td>
</tr>
</tbody>
</table>

<h2 id="toc_3">重写各方法</h2>

<p>关于自定义 View 重写各方法的介绍，网上已经有太多太多，这里就不再啰嗦了。</p>

<blockquote>
<p>这里推荐一个关于自定义 View 尤其关于绘制方面讲解特别详细的系列博客：<br/>
<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FGcsSloop%2FAndroidNote">github.com/GcsSloop/An…</a><br/>
另外厚脸皮的放上一篇自己的关于讲解“自定义组合控件”的博客地址：<br/>
<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2F4bbc967214c9">www.jianshu.com/p/4bbc96721…</a></p>
</blockquote>

<p>我们知道，在自定义 View 时，必须要有构造函数的，对于4个构造函数，有时可能大家不确定到底该重写哪个，也不知道每个构造函数有什么区别，这里对常用的做法做下说明。</p>

<pre><code class="language-java">//在代码中直接 new 一个 Custom View 实例时,会调用第一个构造函数.这个没有任何争议.
public View(Context context);  
//在 xml 布局文件中使用自定义 View 时,会调用第二个构造函数.这个也没有争议.
public View(Context context, AttributeSet attrs);  
//关于这个构造函数的调用，网上真是众说纷纭，我也不说哪种说法正确，下面提供详解
public View(Context context, AttributeSet attrs, int defStyle);
//4个参数的构造函数这里不做考虑
</code></pre>

<p>关于内部这4个构造函数是怎么调用的，这里直接放源码图片，自己一目了然：</p>

<p><img src="media/15561207871543/15713368833042.png" alt=""/></p>

<p>大家在自定义 View 时，如果没有特别的需求，只要重写前两个构造函数就可以了，我习惯性的写成下面的形式：</p>

<pre><code class="language-java">public class MyView extends View {

    public MyView(Context context) {
        this(context, null);
    }

    public MyView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public MyView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        //初始化画笔，做一些属性的默认赋值等；
        //获取自定义的属性等；
    }
}
</code></pre>

<p>那，说了这么多还是没有提第3个参数到底是干什么的有什么用呀，这里我就不再为大家详细讲解了，这里找到了一片文章，讲解了第3个参数在什么时候怎么使用，大家可以看一下：</p>

<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.cnblogs.com%2Fangeldevil%2Fp%2F3479431.html">www.cnblogs.com/angeldevil/…</a></p>

<p>回归到 ContourView，其实 ContourView 内部很简单，只对 onDraw() 进行了重写，毕竟 ContourView 的主要部分就是绘制。绘制的逻辑，就是遍历锚点集，然后利用上面 WiKi 里提到的公式求出各段曲线的控制点，然后用三阶贝塞尔曲线画出路径。当遍历完锚点集时，闭合曲线的轮廓基本上就得到了，然后就用Shader对路径进行绘制就行。</p>

<p>好了，本次的梳理内容就到这了，感兴趣的可以查看 ContourView 的源码进行分析，同时 ContourView 的这种背景效果还是不错的，需要的时候大家真的可以用到呢!</p>

<p><strong>ContourView GitHub</strong>:<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FOCNYang%2FContourView">github.com/OCNYang/Con…</a></p>

<p>如果大家想看一些高级的自定义 View 的例子可以查看上次开源的 App 的天气模块，其中的天气页面以及天气折线图等等控件都是通过自定义 ViewGroup 或自定义 View 实现的。地址是:<br/>
Qbox Github:<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FOCNYang%2FQBox">github.com/OCNYang/QBo…</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/10/03</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871499.html">
                
                  <h1>Android 带滑动效果的bottomBar</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>看到一个bottomBar的设计,感觉很好看,于是把它实现了出来</p>

<p><img src="media/15561207871499/20171104150978644456283.gif" alt=""/></p>

<p>可以看到这是一个常见的bottomBar<br/>
把它分解一下</p>

<ol>
<li>一共有5个item,每个item的背景颜色不一样</li>
<li>点击item时,item是通过滑动来移动到相应的item上的,这个移动也不是简单的线性移动,而是带有粘性的.</li>
<li>item移动时,item颜色的切换是有item之间过渡的,类似于加了一个遮罩</li>
<li>移到item时,item本身是伴随item的移动是有一个动画的.</li>
</ol>

<p>根据我们的分解,一步一步解决问题<br/><br/>
考虑到这是一个bottomBar,我选择了自定义ViewGroup来实现.因为用ViewGroup添加item会比较方便.</p>

<pre><code class="language-java">public class AnimationBottomBar extends ViewGroup {
    @Override
    protected void onDraw(Canvas canvas) {        
    super.onDraw(canvas);
    }
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
    }
}
</code></pre>

<p>另外item内的小动画我也选择用缩放的形式实现,所以个效果图会有一些出入</p>

<h2 id="toc_0">添加item</h2>

<p>通常来说,一个item会有一个图标和简短的标题.<br/>
举个例子,就像是知乎,即刻下方的bottomBar一样</p>

<p>所以一个item内有也要有一个图标和一个标题<br/><br/>
添加item的时候要足够方便,使用代码添加是个不错的选择,类似于这样<code>mAnimationBottomBar.addItem(item)</code>.<br/><br/>
我创建了一个简单的BottomItem类来包装item  </p>

<pre><code class="language-java">public class BottomItem {
    int drawableRes;//图标资源
    String title;//标题
    public BottomItem(@DrawableRes int drawableRes,String title){
        this.drawableRes=drawableRes;
        this.title=title;
    }
}
</code></pre>

<p>添加item之后,我将添加的BottomItem保存到一个list里</p>

<pre><code class="language-java">public AnimationBottomBar addItem(BottomItem bottomItem) {
    mBottomItemArrayList.add(bottomItem);
    return this;
}
</code></pre>

<p>添加item之后会返会对象本身,就可以继续<code>.addItem()</code>了,就像这样</p>

<pre><code class="language-java">mAnimationBottomBar.addItem(new BottomItem(R.drawable.h, &quot;zero&quot;))
                    .addItem(new BottomItem(R.drawable.h, &quot;one&quot;))
                    .addItem(new BottomItem(R.drawable.h, &quot;two&quot;))
                    .addItem(new BottomItem(R.drawable.h, &quot;four&quot;))
                    .addItem(new BottomItem(R.drawable.h, &quot;five&quot;))
</code></pre>

<p>好了,现在已经添加了item,嗯?球都没得.运行没有显示出来,当然啦添加了之后需要添加到ViewGroup里,在经过onMeasure和onLayout之后才会显示出来</p>

<pre><code class="language-java">public void build()  {
    itemCount = mBottomItemArrayList.size();
    itemWidth=getLayoutParams().width/itemCount;/*获得平均一个item的宽度,这里有个问题,因为这个时候还没有经过OnMeaSure(),width获取不到,在onMeasure里可以再次进行调整*/
    for (BottomItem bottomItem : mBottomItemArrayList) {/*添加图标*/
        ImageView imageView = new ImageView(mContext);
        imageView.setImageResource(bottomItem.drawableRes);
        addView(imageView, itemWidth, 20);
    }
    for (BottomItem bottomItem : mBottomItemArrayList) {/*添加标题/
        TextView textView=new TextView(mContext);
        textView.setTextSize(textSize);
        textView.setText(bottomItem.title);
        textView.setTextColor(textColor);
        textView.setGravity(Gravity.CENTER);
        addView(textView,itemWidth,20);
    }
}
</code></pre>

<p>onMeasure(),遍历刚刚所有添加子View,通知它们测量自己的长宽</p>

<pre><code class="language-java">@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    childCount = getChildCount();/*获得所有子View的数量*/
    barWidth = getSize(300,widthMeasureSpec);//bottombar的宽度
    barHeight =  getSize(300,heightMeasureSpec);//--的高度
    for (int i = 0; i &lt; childCount; i++) {
        View childView = getChildAt(i);
        measureChild(childView, widthMeasureSpec, heightMeasureSpec);
        childView.getLayoutParams().width=itemWidth;/*调整子view的宽度*/
    }
}
</code></pre>

<p>onLayout(),确定所有的子View应该在的位置</p>

<pre><code class="language-java">@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
  
    for (int i = 0; i &lt; itemCount; i++) {/*遍历每一个item,放置item的位置*/
        itemCenterX[i] = (int) (itemWidth * (i + 0.5));/*记录每个item的中心位置*/
        View childImageView = getChildAt(i);
        childImageView.layout(itemWidth * i, 0, itemWidth * (i + 1), 100);//放置图标,
        View childTextView=getChildAt(itemCount+i);
        childTextView.layout(itemWidth * i+childTextView.getWidth()/4,100,itemWidth * (i + 1),barHeight);/*放置标题*/
    }
}
</code></pre>

<p>此时的样子应该是这样的</p>

<p><img src="media/15561207871499/15713659445009.png" alt=""/></p>

<h2 id="toc_1">添加背景颜色</h2>

<p>你可能会想到用<code>setBackGroundColor()</code>来设置背景颜色,不过不要忘了,我们这个是要实现动画效果的,虽然使用<code>setBackGroundColor()</code>也能实现,但是要复杂一些.我决定使用<code>OnDraw()</code>画出来,在ViewGroup里默认是不调用<code>OnDraw()</code>的具体原因见这里解决方法也很简单</p>

<blockquote>
<p>如果我们要重写一个ViweGroup的onDraw方法，有两种方法：<br/>
1.在构造函数里面，给其设置一个颜色，如#00000000。<br/>
2.在构造函数里面，调用setWillNotDraw(false)，去掉其WILL_NOT_DRAW flag。</p>
</blockquote>

<p>我选择了第二个方法,因为我们要自己实现背景.</p>

<pre><code class="language-java">@Override
protected void onDraw(Canvas canvas) {
    /*绘制item颜色*/
    for (int i = 0; i &lt; 5; i++) {
        mPaint.setColor(itemcolors[i]);
        canvas.drawRect(itemWidth * i, 0, itemWidth * (i + 1), barHeight, mPaint);
        canvas.save();
    }
        
    /*画出背景,两个长方形*/
    mPaint.setColor(backGroundColor);
    canvas.drawRect(0, 0, itemMoveLeft, barHeight, mPaint);
    canvas.drawRect(itemMoveRight, 0, itemWidth * 5, barHeight, mPaint);
    canvas.save();
    super.onDraw(canvas);
}
</code></pre>

<p>这里我分了两部分来画,一是每个item的背景颜色,二是整体的背景颜色,注意画的先后顺序哦,我为了实现item的移动,把item部分画在下层,把背景画在了上层,通过改变背景来实现item的移动效果.<br/>
这时候的效果是这样的</p>

<p><img src="media/15561207871499/15713659550522.png" alt=""/></p>

<h2 id="toc_2">实现动画</h2>

<p>注意这里的动画其实分为两个部分,两部分是同时进行的</p>

<ol>
<li>item的移动动画</li>
<li>item的缩放动画</li>
</ol>

<pre><code class="language-java">@Override
protected void onDraw(Canvas canvas) {
    /绘制item颜色*/
    for (int i = 0; i &lt; 5; i++) {
        mPaint.setColor(itemcolors[i]);
        canvas.drawRect(itemWidth * i, 0, itemWidth * (i + 1), barHeight, mPaint);
        canvas.save();
    }
    /*画出背景,两个长方形*/
    mPaint.setColor(backGroundColor);
    canvas.drawRect(0, 0, itemMoveLeft, barHeight, mPaint);
    canvas.drawRect(itemMoveRight, 0, itemWidth * 5, barHeight, mPaint);
    canvas.save();
    /*遍历每个item位置,画出需要移动和缩放的item*/
    for (int i = 0; i &lt; itemCount; i++) {
        int deltaX=Math.abs(itemMoveCenter-itemCenterX[i]);/*获得当前item移动中心点和item固定中心点的距离*/
        if (deltaX&lt;itemWidth){
            itemScale[i]= (float) (-0.5*deltaX/itemWidth+1);/*当距离小于一个item的宽度时调整item的缩放系数*/
        }
        else itemScale[i]=0.5f;/*非选中的item的缩放系数固定为0.5*/
        
        /*对item的大小进行缩放*/
        View childImageView = getChildAt(i);
        childImageView.setScaleX(itemScale[i]);
        childImageView.setScaleY(itemScale[i]);
        View childTextView = getChildAt(itemCount+i);
        childTextView.setScaleX(itemScale[i]);
        childTextView.setScaleY(itemScale[i]);
    }
    super.onDraw(canvas);
}
</code></pre>

<p>我用了几个数组来记录每个item的固定中心位置,每个item的颜色,每个item的缩放系数.<br/>
缩放系数这里,默认的未选中item的缩放系数是0.5,选中的item的缩放系数就是1.0,移动的时候,越靠近选中的item就这个系数就越大.<br/>
既然是动画我们肯定要让她动起来,我继承了Animation类实现了自己的BottomAnimation类</p>

<pre><code class="language-java">private class BottomAnimation extends Animation {
    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        super.applyTransformation(interpolatedTime, t);
        int position = selectIndex - selectLastIndex;
        /*判断不同方向的移动*/
        if (position &lt; 0) {/*向左滑动*/
            itemMoveRight = (int) (itemMoveLastRight + interpolatedTime * itemWidth * position);
            itemMoveLeft = (int) (itemMoveLastLeft + setFirst(interpolatedTime) * itemWidth * position);
            itemMoveCenter = (int) (itemMoveLastRight + interpolatedTime * itemWidth * position) -itemWidth / 2;/*记录中心点移动的位置*/
        } else {/*向右滑动*/
            itemMoveRight = (int) (itemMoveLastRight + setFirst(interpolatedTime) * itemWidth * position);
            itemMoveLeft = (int) (itemMoveLastLeft + interpolatedTime * itemWidth * position);
            itemMoveCenter = (int) (itemMoveLastLeft + interpolatedTime * itemWidth * position) + itemWidth / 2;/*记录中心点移动的位置*/
        }
        postInvalidate();/*更新画面*/
    }
    /*为了实现果冻效果,先移动的一侧要有快速效果*/
    private float setFirst(float interpolatedTime) {
        return (float) Math.sin(interpolatedTime * 0.5 * Math.PI);
    }
}
</code></pre>

<p>在判断到有点击事件之后,启动这个动画就ok了</p>

<pre><code class="language-java">@Override
public boolean dispatchTouchEvent(MotionEvent ev) {
    int action = ev.getAction();
    switch (action) {
        case MotionEvent.ACTION_DOWN:
            touchDownX = ev.getX();
            break;
        case MotionEvent.ACTION_UP:
            if (ev.getX() / itemWidth == touchDownX / itemWidth) {
                selectIndex = (int) (ev.getX() / itemWidth);
                /*点击时开始动画*/
                startAnimation(mBottomAnimation);
            }
            break;
    }
    return true;
}
</code></pre>

<p>最后的效果是这个样子的</p>

<p><img src="media/15561207871499/20171104150978699755982.gif" alt=""/></p>

<p>最后完整的的代码在<a href="https://github.com/Mran/AnimationBottomBar">我的github</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/30</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871413.html">
                
                  <h1>Android Studio 快速创建Activity、Fragment模板</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><img src="media/15561207871413/2017110415097859584759.gif" alt=""/></p>

<blockquote>
<p>自行复制粘贴在<code>Settings</code>&gt;<code>Editor</code>&gt;<code>File and Code Templates</code>新建一个</p>
</blockquote>

<p><img src="media/15561207871413/15713366916509.png" alt=""/></p>

<h2 id="toc_0">Activity</h2>

<p>可以自行将AppCompatActivity换成自己的BaseActivity，不要忘记更改import哦</p>

<pre><code class="language-text">#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME}

#end
import android.os.Bundle
import android.support.v7.app.AppCompatActivity
/**
* description-&gt;&lt;一句话功能简介&gt;
* @author SLJ
* @time ${DATE}
*/
class ${NAME} : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
    }
}
</code></pre>

<h2 id="toc_1">Fragment</h2>

<pre><code class="language-text">#if (${PACKAGE_NAME} &amp;&amp; ${PACKAGE_NAME} != &quot;&quot;)package ${PACKAGE_NAME}

#end
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.app.Fragment
/**
* description-&gt;&lt;一句话功能简介&gt;
* @author SLJ
* @time ${DATE}
*/
class ${NAME} : Fragment() {
    
    override fun onCreateView(inflater: LayoutInflater?, container: ViewGroup?, savedInstanceState: Bundle?): View {
        val view = inflater?.inflate(, container, false)
        return view!!
    }
}
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871451.html">
                
                  <h1>Android 为什么不该使用Timer</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">概述</h2>

<p>在Java开发中，用过定时功能的同学一定不会对Timer感到陌生。不过，除了Timer，在Java 5之后又引入了一个定时工具ScheduledThreadPoolExecutor，那么我们应该如何在这两个定时工具之间进行选择呢？</p>

<p>一般情况下我们都建议使用ScheduledThreadPoolExecutor而不是Timer，主要原因有以下3点：</p>

<ol>
<li>Timer使用的是绝对时间，系统时间的改变会对Timer产生一定的影响；而ScheduledThreadPoolExecutor使用的是相对时间，所以不会有这个问题。</li>
<li>Timer使用单线程来处理任务，长时间运行的任务会导致其他任务的延时处理，而ScheduledThreadPoolExecutor可以自定义线程数量。</li>
<li>Timer没有对运行时异常进行处理，一旦某个任务触发运行时异常，会导致整个Timer崩溃，而ScheduledThreadPoolExecutor对运行时异常做了捕获（可以在afterExecute()回调方法中进行处理），所以更加安全。</li>
</ol>

<p>下面我们就来通过了解Timer与ScheduledThreadPoolExecutor的运行原理来理解上面几个问题出现的原因。</p>

<h2 id="toc_1">Timer的运行机制</h2>

<p><img src="media/15561207871451/15713367067259.jpg" alt=""/></p>

<ul>
<li>TimerTask：任务类。内部持有<code>nextExecutionTime</code>变量，表示任务实际执行时间点，单位为毫秒，使用<code>System.currentTimeMillis()</code> + <code>delay</code>计算得出。</li>
<li><code>TimerQueue</code>：使用小根堆实现的优先队列。按照<code>TimerTask</code>的实际执行时间点由小到大排序。</li>
<li><code>TimerThread</code>：顾名思义，这是实际执行任务的线程。</li>
</ul>

<p><code>TimerThread</code>会在<code>Timer</code>初始化后启动，之后会进入<code>mainLoop()</code>方法，该方法会不断从<code>TimerQueue</code>中取出时间点最小的<code>TimerTask</code>。如果该<code>TimerTask</code>的执行时间点已到，则直接调用<code>TimerTask.run()</code>执行；否则，调用<code>wait()</code>方法，等待相应的时间。</p>

<p>而我们调用<code>Timer.schedule()</code>方法，实际上是通过<code>TimerQueue.add()</code>方法，将TimerTask加入任务等待队列。</p>

<p>这里还有一个需要注意的地方是：当加入任务的执行时间点是优先队列中最小的时，就调用<code>notify()</code>方法唤醒<code>TimerThread</code>，而<code>TimerThread</code>在被唤醒后会重新调用<code>TimerQueue.getMin()</code>方法，再次调用<code>wait()</code>，不过这次的等待时间就变成了新加入任务的时间点。</p>

<h2 id="toc_2">ScheduledThreadPoolExecutor的运行机制</h2>

<p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，对线程池的原理不了解的同学，可以看一下我的这篇文章：<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.jianshu.com%2Fp%2F1fe47a3e8f4c">从零实现ImageLoader（三）—— 线程池详解</a>。</p>

<p>ScheduledThreadPoolExecutor的实现比Timer要复杂一些，不过要是理解了线程池的运行原理，其实也不难。它只不过是在ThreadPoolExecutor的基础上使用自定义的阻塞队列DelayedWorkQueue来实现任务定时功能。所以ScheduledThreadPoolExecutor的运行流程其实和ThreadPoolExecutor是差不多的。</p>

<p><img src="media/15561207871451/15713367175739.jpg" alt=""/></p>

<ul>
<li><strong>ScheduledFutureTask</strong>：任务类。内部持有time变量，单位为纳秒，通过<code>System.nanoTime()</code> + <code>delay</code>计算得出。</li>
<li><strong>DelayedWorkQueue</strong>：使用小根堆实现的优先阻塞队列，将ScheduledFutureTask按照从小到大的顺序排列，同时在take()方法内实现阻塞操作。</li>
<li><strong>WorkerThread</strong>：这里为了简单起见，我将线程池的核心线程和临时线程统一写成WorkerThread，但需要注意的是<code>ScheduledThreadPoolExecutor</code>是线程池的一个子类，所以线程池的那一套东西在<code>ScheduledThreadPoolExecutor</code>里也是有的。</li>
</ul>

<p>光从这两个图上看，好像ScheduledThreadPoolExecutor和Timer的实现都大同小异，不过是换了一些名字，但实际上这两个的实现还是有很大的不同的，不止因为ScheduledThreadPoolExecutor使用的是多线程。</p>

<p>在Timer里定时功能的实现主要依靠TimerThread.mainLoop()的等待，而ScheduledThreadPoolExecutor使用的是多线程，在每个线程里都单独实现定时功能是不现实的，因此，<code>ScheduledThreadPoolExecutor</code>将定时功能放在了<code>DelayedWorkQueue</code>类里，而由于<code>DelayedWorkQueue</code>是阻塞队列，所以定时任务的实现实际上就在<code>DelayedWorkQueue.take()</code>方法中。下面我们就来分析一下<code>DelayedWorkQueue.take()</code>到底做了什么。</p>

<h3 id="toc_3">Leader/Follower模式</h3>

<p>在多线程网络编程中，我们一般使用一个线程监听端口，在接收到事件后再使用其他的线程去完成操作。这种情况下，在两个线程之间的上下文切换开销其实是很大的，于是我们有了Leader/Follower模式：</p>

<p><img src="media/15561207871451/15713367286186.png" alt=""/></p>

<p>在Leader/Follower模式中，不存在一个专门用来监听的线程，所有的线程都是等价的，而这些线程会不断在Leader、Follower和Processor这三个状态之间来回切换。</p>

<p>在程序中会保证每个时刻有且只有一个Leader，这个Leader就暂时充当了之前用来监听端口线程的作用。而当有一个新的事件发生时，Leader不再是重新找一个线程去处理连接，而是自己转化为Processor处理事件，并且重新指定一个Follower作为新的Leader。当事件处理完毕后，Processor又会转化为Follower等待重新成为Leader。</p>

<h3 id="toc_4">take()方法的原理</h3>

<p>这里的<code>take()</code>方法就借助了<code>Leader/Follower</code>模式的思想，同一时刻只有一个<code>Leader</code>线程，不过这里由于任务执行的时间点是已经确定了的，所以不再是等待一个触发事件，而是等待最小任务所对应的延迟时间。其他的<code>Follower</code>线程则处于无限等待的状态，直到当前<code>Leader</code>到达指定时间后转化为<code>Processor</code>去处理任务，这时就会唤醒一个<code>Follower</code>作为下一任的<code>Leader</code>。而Processor在处理完任务后又会重新加入<code>Follower</code>进行等待。</p>

<h2 id="toc_5">绝对时间与相对时间</h2>

<p>了解了Timer与ScheduledThreadPoolExecutor的运行机制，下面我们就来看一下Timer的这些缺陷究竟是怎么回事。</p>

<p>首先是绝对时间与相对时间的问题，可能有人已经发现，不管是TimerTask还是ScheduledFutureTask都是存储的实际执行时间点，只不过一个是毫秒，一个是纳秒，难道时间单位还会对这些有影响？确实，时间单位是不会对任务的执行有影响的，不过这里的玄机就在于这个时间的计算方式：<code>System.currentTimeMillis()</code>与<code>System.nanoTime()</code>。</p>

<p><code>System.currentTimeMillis()</code>大家已经很清楚了，就是当前时间与1970年1月1日午夜的时间差的毫秒数，而<code>System.nanoTime()</code>又是什么呢？官方文档里是这么说的：</p>

<blockquote>
<p>此方法只能用于测量已过的时间，与系统或钟表时间的其他任何时间概念无关。返回值表示从某一固定但任意的时间算起的毫微秒数。<br/>
这就是Timer与ScheduledThreadPoolExecutor一个是基于绝对时间而另一个是基于相对时间的原因。下面我们写个例子来测试一下：</p>
</blockquote>

<pre><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t&quot; + new Date());

    Executors.newSingleThreadScheduledExecutor().schedule(() -&gt; {
        System.out.println(&quot;Executor:\t&quot; + new Date());
    }, 60, TimeUnit.SECONDS);

    new Timer().schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer:\t&quot; + new Date());
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Start:    Sun Oct 08 10:51:44 CST 2017
Executor:    Sun Oct 08 10:51:41 CST 2017
Timer:    Sun Oct 08 10:52:45 CST 2017
</code></pre>

<p>这里，我在启动之后将系统的时钟向后调了一分钟，所以实际的启动时间应该是10:50:44，由于ScheduledThreadPoolExecutor的等待时间与系统无关，所以在一分钟后执行；而Timer是基于绝对时间的所以在10:52:45执行，实际上这时已经过去两分钟了。</p>

<h2 id="toc_6">单线程与多线程</h2>

<p>Timer的第二个缺陷是，由于它使用的是单线程，所以长时间执行的任务会对其他任务产生影响。</p>

<pre><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    ScheduledExecutorService service = Executors.newScheduledThreadPool(3);

    service.schedule(() -&gt; {
        System.out.println(&quot;Executor 任务1:\t&quot; + new Date());
        try {
            Thread.sleep(30000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, 60, TimeUnit.SECONDS);
    service.schedule(() -&gt; {
        System.out.println(&quot;Executor 任务2:\t&quot; + new Date());
        try {
            Thread.sleep(30000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }, 60, TimeUnit.SECONDS);

    Timer timer = new Timer();

    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer 任务1:\t\t&quot; + new Date());
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, 60000);
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            System.out.println(&quot;Timer 任务2:\t\t&quot; + new Date());
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Start:            Sun Oct 08 11:10:34 CST 2017
Executor 任务1:    Sun Oct 08 11:11:34 CST 2017
Executor 任务2:    Sun Oct 08 11:11:34 CST 2017
Timer 任务1:        Sun Oct 08 11:11:34 CST 2017
Timer 任务2:        Sun Oct 08 11:12:04 CST 2017
</code></pre>

<p>可以看到ScheduledThreadPoolExecutor中的两个任务在等待一分钟之后同时执行；而在Timer中的任务2却因任务1长达半分钟的执行时间，总共等了一分半钟才得以执行。</p>

<h2 id="toc_7">异常处理</h2>

<p>最后我们来看一下Timer与ScheduledThreadPoolExecutor对异常的处理情况：</p>

<h3 id="toc_8">Timer</h3>

<p>Timer内部没有对异常做任何处理，如果任务执行发生运行时异常，整个TimerThread都会崩溃：</p>

<pre><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    Timer timer = new Timer();

    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            throw new RuntimeException(&quot;Timer 任务1&quot;);
        }
    }, 60000);
    timer.schedule(new TimerTask() {
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;Timer 任务2:\t\t&quot; + new Date());
        }
    }, 60000);
}
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Start:            Sun Oct 08 11:53:05 CST 2017
Exception in thread &quot;Timer-0&quot; java.lang.RuntimeException: Timer 任务1
    at main.Main$1.run(Main.java:32)
    at java.util.TimerThread.mainLoop(Timer.java:555)
    at java.util.TimerThread.run(Timer.java:505)
</code></pre>

<p>可以看到，任务1抛出的运行时异常导致整个Timer线程崩溃，任务2自然也没有执行。</p>

<h3 id="toc_9">ScheduledThreadPoolExecutor</h3>

<p>ScheduledThreadPoolExecutor中对异常的处理实际上是ThreadPoolExecutor类完成的，ThreadPoolExecutor在任务运行时对异常做了捕获，并且将异常传入了afterExecute()方法：</p>

<pre><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService {
    final void runWorker(Worker w) {
        ...
        Throwable thrown = null;
        try {
            task.run();
        } catch (RuntimeException x) {
            thrown = x; throw x;
        } catch (Error x) {
            thrown = x; throw x;
        } catch (Throwable x) {
            thrown = x; throw new Error(x);
        } finally {
            afterExecute(task, thrown);
        }
        ...
    }
}
</code></pre>

<p>我们来验证一下：</p>

<pre><code class="language-java">public static void main(String[] args) {
    System.out.println(&quot;Start:\t\t\t&quot; + new Date());

    ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();

    service.schedule(() -&gt; {
        throw new RuntimeException(&quot;Executor 任务1&quot;);
    }, 60, TimeUnit.SECONDS);
    service.schedule(() -&gt; {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Executor 任务2:\t&quot; + new Date());
    }, 60, TimeUnit.SECONDS);
}
</code></pre>

<p>输出：</p>

<pre><code class="language-text">Start:            Sun Oct 08 11:33:35 CST 2017
Executor 任务2:    Sun Oct 08 11:34:36 CST 2017
</code></pre>

<p>可以看到这里虽然任务1抛出了运行时异常，但由于线程池内部完善的异常处理机制，任务2得以成功执行。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/29</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15561207871379.html">
                
                  <h1>Android 四种启动模式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>此博文用来介绍一下Activity的四种启动模式和应用的场景。</p>

<p>主要是对于Android Activity启动模式的梳理。</p>

<h2 id="toc_0">返回栈</h2>

<p>首先，在介绍之前，我们需要有一个返回栈的概念。栈，是一种数据结构，遵循的是先进后出的规则，而无论是什么APP，里面的N个Activity最终都会被压入栈（或弹出栈中），而与我们进行交互的就是处于栈顶的Activity，在这里就需要介绍一个返回栈的概念。上一张图。</p>

<p><img src="media/15561207871379/15713366435881.png" alt=""/></p>

<p>相信这张图片很清楚的说明，入栈的方式，所谓先进后出就是现在我们假设栈里面已经有abcd四个Activity了，并且都市默认的standard方式启动的。所谓先进后出就是，当我们不断按下back（返回键）的时候，后进去的d反而是最先谈栈的，a最后弹栈。</p>

<p><strong>压栈</strong>：a-&gt;b-&gt;c-&gt;d(入栈顺序)</p>

<p><strong>弹栈</strong>：b-&gt;c-&gt;b-&gt;a(弹出顺序)</p>

<p>先有一个返回栈的概念才能更好的进行分析。</p>

<h2 id="toc_1">为什么需要启动方式</h2>

<p>比如说，现在栈里面已经有四个activity abcd,这个时候的需求是需要到一个Activity a,如果我们只是使用默认的启动方式，那么就会形成abcda，当用户点击back按键的时候，弹出a，abcd。再按弹出d，abc。以此类推，然后又看到了a，是不是很烦人，而且这样的设计也的确很不人性化，所以设计了四种启动方式，来优化更好的体验，和满足特定场景下的用户需求。</p>

<h2 id="toc_2">四种启动的方式</h2>

<p><strong>(1) standard</strong>: 标准的方式，也是系统默认的方式，每次启动一个activity，都会去创建一个新的activity的实例，并让该实例出于activity的栈顶位置，与用户交互，不管该实例存在不存在。</p>

<pre><code class="language-java">button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Intent intent= new Intent(FirstActivity.this,FirstActivity.class);
        startActivity(intent);
    }
});
</code></pre>

<p>这是一个很典型的例子，就是由FirstActivity，跳转到FirstActivity，我们直观的思维会认为FirstActivity已经存在了，那么直接复用就好了啊，但是事实却不是这样子的。点击button两下，算上本身创建的FirstActivity，现在栈里面相当于有三个FirstActivity的实例，必须要点击三次返回键，才能回到桌面。这就是standard模式。</p>

<p><strong>(2) singleTop</strong> :栈顶复用模式，当一个新的Activity已经处于栈顶的时候，那么再次调用新的Activity将不会创建新的实例，因为新的Activity已经在栈顶了，可以直接复用。比如说是栈的情况是abcd，d的启动方式singleTop，那么当我们再次启动d的时候，并不会创建新的实例，还是abcd，因为栈顶已经是d了，如果是adbc那么创建以后就是adbcd。如果d是默认方式启动的话，得到的就是abcdd。</p>

<p><strong>(3) singleTask</strong> ：栈内复用的模式，只要activity在一个栈中，那么多次启动此activity都不会重新创建实例，比如说只要Activity以singleTask的方式启动，系统首先会去找寻是否有A需要的栈s，来存放A实例。如果没有s，就会创建栈s。然后做判断，如果s中有A，那么就直接把A置于栈顶，并且清空A上面的所有实例。如果A已经在栈顶，那么就直接复用A。如果存在S，就看S中是否有A的实例，没有A的实例就直接创建并且入栈，如果已经有A的实例并且没有处于栈顶，那就清楚A之前的所有实例，让A处于栈顶。举个例子(D都是以singleTask启动)：</p>

<ul>
<li>比如目前S1中的情况为ABC，D以singleTask的启动方式入栈，并且请求的任务栈为S2，那么很显然，并不存在S2，所以就会创建S2，并且把D压入S2中。S1：ABC，S2：D。</li>
<li>另一种情况，S1：ABC ，D请求的是S1，那么直接压入S1中。S1：ABCD.</li>
<li>S1：ADBC ，D请求的是S1，那么最终的S1：AD。因为栈内复用方式默认有一个clearTop的方法，会导致D上所有的实例出栈。让D置为栈顶。</li>
</ul>

<p><strong>(4) singleInstance</strong>: 单实例模式。这是一个加强版本的singleTask模式，它除了具有singleTask模式的所有特性之外，还加强的了一点，就是次方式启动的Activity只能单独的位于一个任务栈中，由于栈复用的特性，后续均不会创建新的Activity，除非这个任务栈被系统的销毁了。</p>

<h2 id="toc_3">特殊情况</h2>

<p>比如说现在有前台任务栈s1：AB(A底，B顶),后台任务栈S2:CD（都是以singleTask的方式启动）。当s1请求D入栈的时候，最终得到的是ABCD，但是如果只是请求C入栈的时候，得到的是ABC.</p>

<h2 id="toc_4">设置启动模式（两种）</h2>

<p><strong>第一种：Xml文件中配置</strong></p>

<pre><code class="language-text">&lt;activity
    android:name=&quot;.FirstActivity&quot;
    android:label=&quot;hello My First Activity&quot;
    android:launchMode=&quot;singleTop&quot;/&gt;
</code></pre>

<p><strong>第二种：设置intent标志位的时候配置</strong></p>

<pre><code class="language-text">Intent intent= new Intent();
intent.setClass(FirstActivity.this,FirstActivity.class);
intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
</code></pre>

<p>第二种的优先级方式是高于第一种的，当两种都存在的时候，以第二种为准。</p>

<h2 id="toc_5">指定栈和获取当前的activity的栈ID</h2>

<p>指定栈就是在设置activity的时候指定taskAffinity的属性，要求一个字符串，用.来分包，如果不写，栈就是默认的包名。在这里我指定为了，yanshui.site.task01配合上singleTask使用</p>

<pre><code class="language-text">&lt;activity
    android:name=&quot;.FirstActivity&quot;
    android:label=&quot;hello My First Activity&quot;
    android:launchMode=&quot;singleTask&quot;
    android:taskAffinity=&quot;yanshui.site.task01&quot;/&gt;
</code></pre>

<pre><code class="language-java">//当你想要知道你当前的activity处于栈的id的时候直接在该activity中调用此方法即可。
Log.d(TAG, &quot;task id is &quot;+getTaskId());
</code></pre>

<h2 id="toc_6">使用场景</h2>

<ul>
<li>Standard 默认启动方式，每次都会创建一个新的实例，如果开发中需要就使用。但应该注意具体的情况，优化设计体验。</li>
<li>singleTop 栈顶复用，适合接受推送消息的展示页。某些本应只展示一个的场景，比如一下子收到一堆推送消息，不能每个都弹出来吧。但凡是这样的都行。优酷的推荐视频，电商app推送一个活动。每次只是显示第一条消息。</li>
<li>singleTask 栈复用模式适合程序入口，不需要启动后activity的是的，只能用在启动页了吧，首页，这种只允许有一个instance，如果有其他就移除掉它顶上的。从这个Activity进入的其他activity都抛弃掉了。用户要再操作一次。</li>
<li>singleInstance 栈单实例模式，需要一个activity提供给多有的应用程序访问的，比如说闹钟，响过一次以后，不再提醒，然后就不会再响了。</li>
</ul>

<h2 id="toc_7">标志位</h2>

<ul>
<li><p>FLAG_ACTIVITY_NEW_TASK(xml中指定为singleTask)</p></li>
<li><p>FLAG_ACTIVITY_SINGLE_TOP(xml中指定为singleTop)</p></li>
</ul>

<p>​</p>

<h2 id="toc_8">简单小结一下</h2>

<h3 id="toc_9">使用方式：</h3>

<p>standard：怎么样都要创建<br/><br/>
singleTop：顶上不是target Activity，new一个<br/><br/>
singleTask：顶上不是target Activity，移除target之上的，把自己变成top。<br/><br/>
singleInstance：开辟私有的task，完全独立于程序的其他activity的task。  </p>

<h3 id="toc_10">使用场景：</h3>

<p>standard：普通activity<br/><br/>
singleTop：要展示推送过来的消息<br/><br/>
singleTask：程序入口等启动页面<br/><br/>
singleInstance：完全独立的，类似闹钟的提示  </p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/09/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Android.html'>Android</a></span>
          				   
                    

                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_11.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_13.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>MagicalRice的Blog</h1>
                <div class="site-des">技术博客</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Android.html"><strong>Android</strong></a>
        
            <a href="%E9%9A%8F%E6%89%8B%E8%AE%B0.html"><strong>随手记</strong></a>
        
            <a href="%E6%9C%8D%E5%8A%A1%E5%99%A8.html"><strong>服务器</strong></a>
        
            <a href="C++.html"><strong>C++</strong></a>
        
            <a href="UI.html"><strong>UI</strong></a>
        
            <a href="MySQL.html"><strong>MySQL</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95.html"><strong>算法</strong></a>
        
            <a href="Game.html"><strong>Game</strong></a>
        
            <a href="Python.html"><strong>Python</strong></a>
        
            <a href="%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91.html"><strong>跨平台开发</strong></a>
        
            <a href="Mac.html"><strong>Mac</strong></a>
        
            <a href="%E5%85%B6%E4%BB%96.html"><strong>其他</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="16136612078589.html">继承</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16127020620600.html">封装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16106747969027.html">GitHub搜索技巧</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16104540799826.html">Intellij IDEA插件开发入门</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="16066640335833.html">Jetpack学习 - WorkManager</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>



  














<style type="text/css">
figure{margin: 0;padding: 0;}
figcaption{text-align:center;}

/* PrismJS 1.14.0
 http://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
    color: black;
    background: none;
    text-shadow: 0 1px white;
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
    text-shadow: none;
    background:#b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
    text-shadow: none;
    background: #b3d4fc;
}

@media print {
    code[class*="language-"],
    pre[class*="language-"] {
        text-shadow: none;
    }
}

/* Code blocks */
pre[class*="language-"] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
    background: #F7F7F7;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
    padding: .1em;
    border-radius: .3em;
    white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
    color: slategray;
}

.token.punctuation {
    color: #999;
}

.namespace {
    opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
    color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
    color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
    color: #9a6e3a;
    background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
    color: #07a;
}

.token.function,
.token.class-name {
    color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
    color: #e90;
}

.token.important,
.token.bold {
    font-weight: bold;
}
.token.italic {
    font-style: italic;
}

.token.entity {
    cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>



  </body>
</html>
