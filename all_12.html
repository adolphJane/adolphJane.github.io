<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	MagicalRice的Blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="MagicalRice的Blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
					
					<h1><a href="index.html">MagicalRice的Blog</a></h1>
					<p class="subtitle">技术博客</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">













								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-27T22:51:26+08:00" itemprop="datePublished">2017/3/27</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207869218.html" itemprop="url">
		Python学习笔记</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">前言</h2>

<p>由于写毕设要搭建后端爬虫的需求，所以开始学习Python语言。由于没有系统的学习，所以笔记可能会记得比较散乱，有时间会一一整理，把一些重要的学习知识点记下来。当然有时间也会整理基础知识。</p>

<h2 id="toc_1">安装 Python</h2>

<h3 id="toc_2">升级pip</h3>

<p><code>pip3 install --upgrade pip</code></p>

<h2 id="toc_3">安装 Python 虚拟环境</h2>

<p><code>(sudo) pip3 install virtualenv virtualenvwrapper</code>  </p>

<p>修改<code>~/.bash_profile</code>,添加以下语句  </p>

<pre class="line-numbers"><code class="language-text">export WORKON_HOME=$HOME/.virtualenvs
export PROJECT_HOME=$HOME/workspace
source /usr/local/bin/virtualenvwrapper.sh
</code></pre>

<p>修改后使之立即生效(也可以重启终端使之生效)：<br/><br/>
<code>source ~/.bash_profile</code>  </p>

<h3 id="toc_4">基本用法</h3>

<h4 id="toc_5">1、创建一个虚拟开发环境</h4>

<p><code>mkvirtualenv zqxt：创建运行环境zqxt</code><br/><br/>
<code>workon zqxt: 工作在 zqxt 环境 或 从其它环境切换到 zqxt 环境</code><br/><br/>
<code>deactivate: 退出终端环境</code><br/><br/>
其它的： <br/>
<code>rmvirtualenv ENV：删除运行环境ENV</code><br/><br/>
<code>mkproject mic：创建mic项目和运行环境mic</code><br/><br/>
<code>mktmpenv：创建临时运行环境</code><br/><br/>
<code>lsvirtualenv: 列出可用的运行环境</code><br/><br/>
<code>lssitepackages: 列出当前环境安装了的包</code><br/><br/>
创建的环境是独立的，互不干扰，无需sudo权限即可使用 pip 来进行包的管理。  </p>

<p>完成后在当前目录会创建一个test_env的文件夹，进入文件夹会发现生成了以下的目录，神奇吧  </p>

<pre class="line-numbers"><code class="language-text">├── bin
├── include
│   └── python2.7
├── lib
│   └── python2.7       //所有的新包会被存在这
│       ├── distutils
│       ├── encodings
│       ├── lib-dynload
│       └── site-packages
├── local
│   ├── bin
│   ├── include
│   └── lib
</code></pre>

<h2 id="toc_6">安装Django</h2>

<p><code>pip3 install Django</code>或者<code>pip install Django==1.10.6</code><br/><br/>
在终端上输入Python,点击Enter,进入Python环境</p>

<pre class="line-numbers"><code class="language-text">&gt;&gt;&gt; import django
&gt;&gt;&gt; django.VERSION
(1, 8, 16, &#39;final&#39;, 0)
&gt;&gt;&gt; 
&gt;&gt;&gt; django.get_version()
&#39;1.8.16&#39;
</code></pre>

<p>这样就可以看见安装的django的版本号</p>

<h3 id="toc_7">安装django-Celery，设置调度计划任务</h3>

<p><code>pip3 install django-celery</code></p>

<h3 id="toc_8">安装PIL（Python Imaging Library）</h3>

<p>图片处理的扩展包:<br/>
<code>brew install jpeg    #安装</code></p>

<h3 id="toc_9">安装Django-Dynamic-Scraper(DDS)</h3>

<p><code>pip3 install django-dynamic-scraper</code><br/><br/>
<code>pip3 install scrapy-splash</code><br/>
<code>pip3 install scrapy-djangoitem</code></p>

<h2 id="toc_10">安装scrapy</h2>

<p><code>pip3 install Scrapy 安装Scrapy</code>或者<code>pip3 install scrapy==1.3.3</code>  </p>

<h2 id="toc_11">安装chardet-检测网页编码</h2>

<p><code>pip3 install chardet  #安装chardet</code>  </p>

<pre class="line-numbers"><code class="language-python">def GetHtml( url):  
    page = urllib.request.urlopen(url)  
    contex = page.read()  
    return contex  

print(sys.getfilesystemencoding())    #本地系统编码
print(&#39;Html is encoding by : %&#39;,chardet.detect(GetHtml(url))) #网页编码
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-25T22:55:26+08:00" itemprop="datePublished">2017/3/25</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207869186.html" itemprop="url">
		Mac命令行整理</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">前言</h2>

<p>命令行是操作Mac和Linux最基础和重要的内容，简单的命令行自然会随时记得。但是碰到配置环境以及安装软件这种活，还是得时不时的上网查询，而且在不同的电脑配置还得重新上网查询，所以在此记录一下，以节省以后使用命令行的时间。</p>

<h2 id="toc_1">查看端口占用情况及杀死进程</h2>

<p><code>sudo lsof -i :9000   #查看端口进程</code><br/>
<code>sudo kill -9 716     #根据PID杀死进程</code></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-17T16:31:26+08:00" itemprop="datePublished">2017/3/17</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207869112.html" itemprop="url">
		Apache简单搭建文件共享服务器</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">前言</h2>

<p>因为公司需求，增加打包测试发布的效率以及方便查看log信息。所以需要搭建一个简单的文件服务器。Mac内置Apache，所以我们可以很方便的搭建起来。</p>

<h2 id="toc_1">启动Apache</h2>

<p>启动：<code>sudo apachectl start</code><br/><br/>
停止：<code>sudo apachectl stop</code><br/><br/>
重启：<code>sudo apachectl restart</code><br/><br/>
查看 Apache 版本 <code>httpd -v</code><br/><br/>
浏览器打开 <a href="http://127.0.0.1">http://127.0.0.1</a> 可以看到 It works! 的页面  </p>

<h2 id="toc_2">文件根目录</h2>

<h3 id="toc_3">系统级的根目录</h3>

<p><code>http://localhosts/</code> 对应的是 <code>/Library/WebServer/Documents/</code>  </p>

<h4 id="toc_4">系统级根目录默认没有开启目录列表，开启方法：</h4>

<p>编辑 <code>/etc/apache2/httpd.conf</code><br/><br/>
文件搜索找到 <code>&lt;Directory &quot;/Library/WebServer/Documents&quot;&gt;</code>将 <code>Options FollowSymLinks Multiviews</code> 修改为<code>Options Indexes FollowSymLinks Multiviews</code></p>

<h3 id="toc_5">用户级根目录</h3>

<p>另一个 Web 根目录默认是 ~/Sites ，10.9 中你需要手动创建这个Sites目录。<br/><br/>
检查<code>/etc/apache2/users/</code>这个目录下是否有 <code>username.conf</code> 文件<br/><br/>
如果没有，则需要新建一个，username 需要是你的账户名字，建议使用终端创建这个文件：<br/><br/>
<code>cd /etc/apache2/users</code><br/><br/>
<code>sudo vi username.conf</code><br/><br/>
贴入以下内容，注意修改 username 为你的账户名字  </p>

<pre class="line-numbers"><code class="language-text">&lt;Directory &quot;/Users/username/Sites/&quot;&gt;
Options Indexes MultiViews FollowSymLinks
AllowOverride All
Order allow,deny
Allow from all
Require all granted
&lt;/Directory&gt;
</code></pre>

<p>这个文件的权限应该是:  </p>

<p><code>-rw-r--r-- 1 root wheel 298 Jun 28 16:47 username.conf</code></p>

<p>如果不是，请修改:  </p>

<p><code>sudo chmod 644 username.conf</code></p>

<p>编辑 <code>/etc/apache2/httpd.conf</code> 文件，删除下列这些代码前的注释符号： <code>#</code></p>

<pre class="line-numbers"><code class="language-text">Include /private/etc/apache2/extra/httpd-userdir.conf
LoadModule authz_core_module libexec/apache2/mod_authz_core.so
LoadModule authz_host_module libexec/apache2/mod_authz_host.so
LoadModule userdir_module libexec/apache2/mod_userdir.so
</code></pre>

<p>编辑 <code>/etc/apache2/extra/httpd-userdir.conf</code>文件，删除下列这些代码前的注释符号： <code>#</code><br/><br/>
<code>Include /private/etc/apache2/users/*.conf</code>  </p>

<p>重启 Apache<br/><br/>
<code>sudo apachectl restart</code><br/><br/>
这时，这个网址应该已经可以用了：<br/><br/>
<code>http://localhost/~username/</code>  </p>

<h2 id="toc_6">想去除/~username/</h2>

<p>~username看着的确比较累赘，所以我们重定向把他给去掉<br/><br/>
进入<code>/Library/WebServer/Documents</code>文件夹中，找到<code>index.html.en</code>文件，在里面添加一行<code>&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;0; URL=/~rainbird&quot;&gt;</code>。最后变成这个样子。  </p>

<pre class="line-numbers"><code class="language-text">&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;0; URL=/~rainbird&quot;&gt;
&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-15T14:04:26+08:00" itemprop="datePublished">2017/3/15</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Python.html'>Python</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207869076.html" itemprop="url">
		Python-Crawler</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">总文件</h2>

<pre class="line-numbers"><code class="language-python">import scrapy
from scrapy.selector import Selector
from scrapy.http import HtmlResponse

class QuotesSpider(scrapy.Spider):
    name = &quot;quotes&quot;

    def start_requests(self):
        urls = [
            &#39;http://www.xujc.com.cn/&#39;,
        ]
        for url in urls:
            yield scrapy.Request(url=url, callback=self.parse)

    def parse(self,response):
        sel = Selector(response)
        sties = sel.xpath(&#39;//table&#39;)
        # for site in sties:
        #   title = site.xpath(&#39;tr/td&#39;).extract()
        #   print(site)
        #   print(title)

        #filename = &#39;school-%s.html&#39; % 1
        #with open(filename, &#39;wb&#39;) as f:
             #f.write(contents)
        #self.log(&#39;Saved file %s&#39; % filename)
</code></pre>

<h2 id="toc_1">重点关注链接and标题</h2>

<pre class="line-numbers"><code class="language-python">import scrapy
from scrapy.selector import Selector
from scrapy.http import HtmlResponse

class QuotesSpider(scrapy.Spider):
    name = &quot;quotes&quot;

    def start_requests(self):
        urls = [
            &#39;http://www.xujc.com.cn/&#39;,
        ]
        for url in urls:
            yield scrapy.Request(url=url, callback=self.parse)

    def parse(self,response):
        sel = Selector(response)
        sties = sel.xpath(&#39;//table&#39;)

        title = sties[16].xpath(&#39;tr/td/a/text() | tr/td/a/@href | tr/td/text()&#39;).extract()
        print(sties[10])
        print(title)
</code></pre>

<h2 id="toc_2">日期时间</h2>

<pre class="line-numbers"><code class="language-python">title = sties[25].xpath(&#39;tr/td/table/tr/td[@id=&quot;zb&quot;]/table/tr/td/span/text()&#39;).extract()
        print(sties[10])
        print(title)
</code></pre>

<h2 id="toc_3">通知公告</h2>

<pre class="line-numbers"><code class="language-python">import scrapy
from scrapy.selector import Selector
from scrapy.http import HtmlResponse

class QuotesSpider(scrapy.Spider):
    name = &quot;quotes&quot;

    def start_requests(self):
        urls = [
            &#39;http://www.xujc.com.cn/index.php?c=Article&amp;a=idxnews&amp;lx=notice&#39;,
        ]
        for url in urls:
            yield scrapy.Request(url=url, callback=self.parse)

    def parse(self,response):
        sel = Selector(response)
        sties = sel.xpath(&#39;/html/body/table/tr&#39;)
        for site in sties:
            title = site.xpath(&#39;td/a/@href | td/a/text()&#39;).extract()
            print(site)
            print(title)
</code></pre>

<h2 id="toc_4">新闻中心</h2>

<pre class="line-numbers"><code class="language-python">import scrapy
from scrapy.selector import Selector
from scrapy.http import HtmlResponse

class QuotesSpider(scrapy.Spider):
    name = &quot;quotes&quot;

    def start_requests(self):
        urls = [
            &#39;http://www.xujc.com.cn/index.php?c=Article&amp;a=idxnews&amp;lx=news&#39;,
        ]
        for url in urls:
            yield scrapy.Request(url=url, callback=self.parse)

    def parse(self,response):
        sel = Selector(response)
        sties = sel.xpath(&#39;/html/body/ul/li&#39;)
        for site in sties:
            title = site.xpath(&#39;a/@href | a/text()&#39;).extract()
            print(site)
            print(title)
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-03-05T09:32:26+08:00" itemprop="datePublished">2017/3/5</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207869044.html" itemprop="url">
		Android ADB 命令</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">查看设备</h2>

<pre class="line-numbers"><code class="language-text">adb devices
</code></pre>

<p>这个命令是查看当前连接的设备, 连接到计算机的android设备或者模拟器将会列出显示</p>

<h2 id="toc_1">安装软件</h2>

<pre class="line-numbers"><code class="language-text">adb install &lt;apk文件路径&gt;
</code></pre>

<p>这个命令将指定的apk文件安装到设备上</p>

<h2 id="toc_2">卸载软件</h2>

<pre class="line-numbers"><code class="language-text">adb uninstall &lt;软件名&gt;
adb uninstall -k &lt;软件名&gt;
</code></pre>

<p>如果加 -k 参数,为卸载软件但是保留配置和缓存文件.</p>

<h2 id="toc_3">进入设备或模拟器的shell</h2>

<pre class="line-numbers"><code class="language-text">adb shell
</code></pre>

<p>通过上面的命令，就可以进入设备或模拟器的shell环境中，在这个Linux Shell中，你可以执行各种Linux的命令，另外如果只想执行一条shell命令，可以采用以下的方式：</p>

<pre class="line-numbers"><code class="language-text">adb shell [command]
</code></pre>

<p>如：adb shell dmesg会打印出内核的调试信息。</p>

<h2 id="toc_4">发布端口</h2>

<pre class="line-numbers"><code class="language-text">adb forward tcp:5555 tcp:8000
</code></pre>

<p>可以设置任意的端口号，做为主机向模拟器或设备的请求端口。如：</p>

<h2 id="toc_5">从电脑上发送文件到设备</h2>

<pre class="line-numbers"><code class="language-text">adb push &lt;本地路径&gt; &lt;远程路径&gt;
</code></pre>

<p>用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机)</p>

<h2 id="toc_6">从设备上下载文件到电脑</h2>

<pre class="line-numbers"><code class="language-text">adb pull &lt;远程路径&gt; &lt;本地路径&gt;
</code></pre>

<p>用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑</p>

<h2 id="toc_7">查看bug报告</h2>

<pre class="line-numbers"><code class="language-text">adb bugreport
</code></pre>

<h2 id="toc_8">记录无线通讯日志</h2>

<pre class="line-numbers"><code class="language-text">adb shell
logcat -b radio
</code></pre>

<p>一般来说，无线通讯的日志非常多，在运行时没必要去记录，但我们还是可以通过命令，设置记录</p>

<h2 id="toc_9">获取设备的ID和序列号</h2>

<pre class="line-numbers"><code class="language-text">adb get-product
adb get-serialno
adb shell
sqlite3 
</code></pre>

<h2 id="toc_10">adb shell后面跟的命令主要来自</h2>

<pre class="line-numbers"><code class="language-text">源码\system\core\toolbox目录和源码\frameworks\base\cmds目录
</code></pre>

<h2 id="toc_11">删除系统应用</h2>

<pre class="line-numbers"><code class="language-text">adb remount （重新挂载系统分区，使系统分区重新可写）。
adb shell
cd system/app
rm *.apk
</code></pre>

<h2 id="toc_12">获取管理员权限</h2>

<pre class="line-numbers"><code class="language-text">adb root
</code></pre>

<h2 id="toc_13">启动Activity</h2>

<pre class="line-numbers"><code class="language-text">adb shell am start -n 包名/包名＋类名（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）。
</code></pre>

<h2 id="toc_14">复制文件</h2>

<pre class="line-numbers"><code class="language-text">你可向一个设备或从一个设备中复制文件,复制一个文件或目录到设备或模拟器上： 
adb push &lt;source&gt; &lt;destination&gt;&lt;/destination&gt;&lt;/source&gt; 
如：adb push test.txt /tmp/test.txt 
从设备或模拟器上复制一个文件或目录： 
adb pull &lt;source&gt; &lt;destination&gt;&lt;/destination&gt;&lt;/source&gt; 
如：adb pull /addroid/lib/libwebcore.so .
</code></pre>

<h2 id="toc_15">搜索模拟器/设备的实例</h2>

<pre class="line-numbers"><code class="language-text">取得当前运行的模拟器/设备的实例的列表及每个实例的状态： 
adb devices
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-02-28T22:44:26+08:00" itemprop="datePublished">2017/2/28</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207869006.html" itemprop="url">
		Mac安装配置appium</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">前言</h2>

<p>因为公司需求，需要安装Appium来实现对手机APP的自动化测试，提升工作效率。所以来学习并记录一下Appium的安装以及使用的步骤，方便自己以后对App测试环境搭建的操作。</p>

<h2 id="toc_1">一、安装Appium</h2>

<h3 id="toc_2">(二) 安装Homebrew</h3>

<ul>
<li><code>$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;  #下载</code></li>
<li><code>$ brew update #更新</code></li>
<li><code>$ brew -v #查看是否安装好，以及其版本号</code></li>
</ul>

<h3 id="toc_3">(三) 安装Node.js</h3>

<p>使用homebrew来安装Node.js </p>

<ul>
<li><code>$ brew install node #安装</code></li>
<li><code>$ node -v #查看是否安装好，以及其版本号</code></li>
</ul>

<h3 id="toc_4">(四) 安装npm</h3>

<ul>
<li><code>$ brew install npm</code></li>
</ul>

<h3 id="toc_5">(五) 安装appium服务端</h3>

<p>推荐使用cnpm来安装：<a href="https://npm.taobao.org/">淘宝 NPM 镜像</a> 10分钟同步npmjs.org镜像，使用方式和npm完全一致</p>

<ul>
<li><code>$ npm install cnpm -g --registry=https://registry.npm.taobao.org</code></li>
<li><code>$ npm view appium versions #查看appium所有的版本号</code></li>
<li><code>$ cnpm install -g appium --no-cache $ cnpm install -g appium $ cnpm install -g appium-doctor</code></li>
</ul>

<h3 id="toc_6">(六) 检查appium环境检测</h3>

<p>在环境监测中打叉的就是没安装成功或者环境没有配置完全的</p>

<ul>
<li><code>appium-doctor</code></li>
</ul>

<h4 id="toc_7">1、appium环境常见问题解决</h4>

<h5 id="toc_8">(1) Xcode Command Line Tools are NOT installed!</h5>

<pre class="line-numbers"><code class="language-text">- `xcode-select --install   #按照提示安装即可`
</code></pre>

<h5 id="toc_9">(2) Carthage was NOT found</h5>

<pre class="line-numbers"><code class="language-text">- `$ brew install carthage       #carthage：类似cocoapods管理第三方代码，自动将工程编译为动态库，所以仅支持iOS8以上`
</code></pre>

<h5 id="toc_10">(3) ANDROID_HOME is NOT set!</h5>

<pre class="line-numbers"><code class="language-text">- 使用最新版本Java
- 修改Mac的开发环境
- `vi .bash_profile`
- `export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk(版本记得改)/Contents/Home`
- `export ANDROID_HOME=/Users/YourMacName/Library/Android/sdk`
- `export PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:${JAVA_HOME}/bin`
- 修改完配置文件记得保存退出，然后`source .bash_profile`
- 如果有问题记得修改在终端的Shall打开方式，调整为命令
</code></pre>

<h3 id="toc_11">(七) 安装appium客户端（Python为例）</h3>

<ul>
<li><code>brew search python   #查看可安装的python版本</code></li>
<li><code>brew install python3     #安装python3</code></li>
<li><code>pip install Appium-Python-Client   #安装python客户端</code>  </li>
</ul>

<h3 id="toc_12">(八) 安装支持iOS测试的插件</h3>

<ul>
<li><code>$ brew install libimobiledevice --HEAD  # install from HEAD to get important updates</code></li>
<li><code>$ brew install ideviceinstaller         # 只是对iOS9有用</code></li>
<li><code>$ npm install -g ios-deploy                # iOS10 以后的版本安装ios-deploy</code></li>
<li><code>$ sudo gem install xcpretty            # 真机需要安装 xcpretty</code></li>
</ul>

<h2 id="toc_13">二、Appium测试</h2>

<h3 id="toc_14">(一) iOS模拟器测试</h3>

<ul>
<li><code>xcodebuild -sdk iphonesimulator   #在xcodeproj项目工程目录下执行，编译生成build文件夹，并在其中生成app文件</code></li>
<li><code>npm install -g authorize-ios   #安装iOS模拟器启动器</code> </li>
<li><code>sudo authorize-ios   #启动iOS模拟器</code> </li>
<li><code>appium &amp;    #启动appium服务器</code> </li>
<li><code>python ***.py     #另开一个终端执行python脚本</code> </li>
<li>iOS模拟器自动开启，安装应用并开始执行测试脚本</li>
</ul>

<h3 id="toc_15">(二) Android模拟器测试</h3>

<ul>
<li><code>appium -a 127.0.0.1 -p 4723 -U db3489d --no-reset</code></li>
</ul>

<h2 id="toc_16">三、Appium命令</h2>

<h3 id="toc_17">(一) 服务端启动命令</h3>

<p><strong>服务器标志</strong><br/>
所有的标志都是可选的，但是有一些标志需要组合在一起才能生效。</p>

<table>
<thead>
<tr>
<th>标志</th>
<th>默认值</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>

<tbody>
<tr>
<td>--shell</td>
<td>null</td>
<td>进入 REPL 模式</td>
<td></td>
</tr>
<tr>
<td>--localizable-strings-dir</td>
<td>en.lproj</td>
<td>IOS only: 定位 .strings所在目录的相对路径</td>
<td>--localizable-strings-dir en.lproj</td>
</tr>
<tr>
<td>--app</td>
<td>null</td>
<td>iOS: 基于模拟器编译的 app 的绝对路径或者设备目标的 bundle_id； Android: apk 文件的绝对路径--app /abs/path/to/my.app</td>
<td></td>
</tr>
<tr>
<td>--ipa</td>
<td>null</td>
<td>(IOS-only) .ipa 文件的绝对路径</td>
<td>--ipa /abs/path/to/my.ipa</td>
</tr>
<tr>
<td>-U, --udid</td>
<td>null</td>
<td>连接物理设备的唯一设备标识符</td>
<td>--udid 1adsf-sdfas-asdf-123sdf</td>
</tr>
<tr>
<td>-a, --address</td>
<td>0.0.0.0</td>
<td>监听的 ip 地址</td>
<td>--address 0.0.0.0</td>
</tr>
<tr>
<td>-p, --port</td>
<td>4723</td>
<td>监听的端口</td>
<td>--port 4723</td>
</tr>
<tr>
<td>-ca, --callback-address</td>
<td>null</td>
<td>回调IP地址 (默认: 相同的IP地址)</td>
<td>--callback-address 127.0.0.1</td>
</tr>
<tr>
<td>-cp, --callback-port</td>
<td>null</td>
<td>回调端口号 (默认: 相同的端口号)</td>
<td>--callback-port 4723</td>
</tr>
<tr>
<td>-bp, --bootstrap-port</td>
<td>4724</td>
<td>(Android-only) 连接设备的端口号</td>
<td>--bootstrap-port 4724</td>
</tr>
<tr>
<td>-k, --keep-artifacts</td>
<td>false</td>
<td>弃用，无效。trace信息现在保留tmp目录下，每次运行前会清除该目录中的信息。 也可以参考 –trace-dir 。</td>
<td></td>
</tr>
<tr>
<td>-r, --backend-retries</td>
<td>3</td>
<td>(iOS-only) 遇到 crash 或者 超时，Instrument 重新启动的次数。</td>
<td>--backend-retries 3</td>
</tr>
<tr>
<td>--session-override</td>
<td>false</td>
<td>允许 session 被覆盖 (冲突的话)</td>
<td></td>
</tr>
<tr>
<td>--full-reset</td>
<td>false</td>
<td>(iOS) 删除整个模拟器目录。 (Android) 通过卸载应用（而不是清除数据）重置应用状态。在 Android 上，session 完成后也会删除应用。</td>
<td></td>
</tr>
<tr>
<td>--no-reset</td>
<td>false</td>
<td>session 之间不重置应用状态 (iOS: 不删除应用的 plist 文件； Android: 在创建一个新的 session 前不删除应用。)</td>
<td></td>
</tr>
<tr>
<td>-l, --pre-launch</td>
<td>false</td>
<td>在第一个 session 前，预启动应用 (iOS 需要 –app 参数，Android 需要 –app-pkg 和 –app-activity)</td>
<td></td>
</tr>
<tr>
<td>-lt, --launch-timeout  90000   (iOS-only) 等待 Instruments 启动的时间</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-g, --log</td>
<td>null</td>
<td>将日志输出到指定文件</td>
<td>--log /path/to/appium.log</td>
</tr>
<tr>
<td>--log-level</td>
<td>debug</td>
<td>日志级别; 默认 (console[:file]): debug[:debug]</td>
<td>--log-level debug</td>
</tr>
<tr>
<td>--log-timestamp</td>
<td>false</td>
<td>在终端输出里显示时间戳</td>
<td></td>
</tr>
<tr>
<td>--local-timezone</td>
<td>false</td>
<td>使用本地时间戳</td>
<td></td>
</tr>
<tr>
<td>--log-no-colors</td>
<td>false</td>
<td>不在终端输出中显示颜色</td>
<td></td>
</tr>
<tr>
<td>-G, --webhook</td>
<td>null</td>
<td>同时发送日志到 HTTP 监听器</td>
<td>--webhook localhost:9876</td>
</tr>
<tr>
<td>--native-instruments-lib</td>
<td>false</td>
<td>(IOS-only) iOS 内建了一个怪异的不可能避免的延迟。我们在 Appium 里修复了它。如果你想用原来的，你可以使用这个参数。</td>
<td></td>
</tr>
<tr>
<td>--app-pkg</td>
<td>null</td>
<td>(Android-only) 你要运行的apk的java包。 (例如， com.example.android.myApp)</td>
<td>--app-pkg com.example.android.myApp</td>
</tr>
<tr>
<td>--app-activity</td>
<td>null</td>
<td>(Android-only) 打开应用时，启动的 Activity 的名字(比如， MainActivity)</td>
<td>--app-activity MainActivity</td>
</tr>
<tr>
<td>--app-wait-package</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 的包名。(比如， com.example.android.myApp)</td>
<td>--app-wait-package com.example.android.myApp</td>
</tr>
<tr>
<td>--app-wait-activity</td>
<td>false</td>
<td>(Android-only) 你想等待的 Activity 名字(比如， SplashActivity)</td>
<td>--app-wait-activity SplashActivity</td>
</tr>
<tr>
<td>--android-coverage</td>
<td>false</td>
<td>(Android-only) 完全符合条件的 instrumentation 类。 作为命令 adb shell am instrument -e coverage true -w 的 -w 的参数</td>
<td>--android-coverage com.my.Pkg/com.my.Pkg.instrumentation.MyInstrumentation</td>
</tr>
<tr>
<td>--avd</td>
<td>null</td>
<td>(Android-only) 要启动的 avd 的名字</td>
<td></td>
</tr>
<tr>
<td>--avd-args</td>
<td>null</td>
<td>(Android-only) 添加额外的参数给要启动avd</td>
<td>--avd-args -no-snapshot-load</td>
</tr>
<tr>
<td>--device-ready-timeout</td>
<td>5</td>
<td>(Android-only) 等待设备准备好的时间，以秒为单位</td>
<td>--device-ready-timeout 5</td>
</tr>
<tr>
<td>--safari</td>
<td>false</td>
<td>(IOS-Only) 使用 Safari 应用</td>
<td></td>
</tr>
<tr>
<td>--device-name</td>
<td>null</td>
<td>待使用的移动设备名字</td>
<td>--device-name iPhone Retina (4-inch), Android Emulator</td>
</tr>
<tr>
<td>--platform-name</td>
<td>null</td>
<td>移动平台的名称: iOS, Android, or FirefoxOS</td>
<td>--platform-name iOS</td>
</tr>
<tr>
<td>--platform-version</td>
<td>null</td>
<td>移动平台的版本</td>
<td>--platform-version 7.1</td>
</tr>
<tr>
<td>--automation-name</td>
<td>null</td>
<td>自动化工具的名称: Appium or Selendroid</td>
<td>--automation-name Appium</td>
</tr>
<tr>
<td>--browser-name</td>
<td>null</td>
<td>移动浏览器的名称: Safari or Chrome</td>
<td>--browser-name Safari</td>
</tr>
<tr>
<td>--default-device, -dd</td>
<td>false</td>
<td>(IOS-Simulator-only) 使用instruments自己启动的默认模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-iphone</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPhone 模拟器</td>
<td></td>
</tr>
<tr>
<td>--force-ipad</td>
<td>false</td>
<td>(IOS-only) 无论应用要用什么模拟器，强制使用 iPad 模拟器</td>
<td></td>
</tr>
<tr>
<td>--language</td>
<td>null</td>
<td>iOS / Android 模拟器的语言</td>
<td>--language en</td>
</tr>
<tr>
<td>--locale</td>
<td>null</td>
<td>Locale for the iOS simulator / Android Emulator</td>
<td>--locale en_US</td>
</tr>
<tr>
<td>--calendar-format</td>
<td>null</td>
<td>(IOS-only) iOS 模拟器的日历格式</td>
<td>--calendar-format gregorian</td>
</tr>
<tr>
<td>--orientation</td>
<td>null</td>
<td>(IOS-only) 初始化请求时，使用 LANDSCAPE (横屏) 或者 PORTRAIT (竖屏)</td>
<td>--orientation LANDSCAPE</td>
</tr>
<tr>
<td>--tracetemplate</td>
<td>null</td>
<td>(IOS-only) 指定 Instruments 使用的 tracetemplate 文件</td>
<td>--tracetemplate /Users/me/Automation.tracetemplate</td>
</tr>
<tr>
<td>--show-sim-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 模拟器的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--show-ios-log</td>
<td>false</td>
<td>(IOS-only) 如果设置了， iOS 系统的日志会写到终端上来</td>
<td></td>
</tr>
<tr>
<td>--nodeconfig</td>
<td>null</td>
<td>指定 JSON 格式的配置文件 ，用来在 selenium grid 里注册 appiumd</td>
<td>--nodeconfig /abs/path/to/nodeconfig.json</td>
</tr>
<tr>
<td>-ra, --robot-address</td>
<td>0.0.0.0</td>
<td>robot 的 ip 地址</td>
<td>--robot-address 0.0.0.0</td>
</tr>
<tr>
<td>-rp, --robot-port</td>
<td>-1</td>
<td>robot 的端口地址</td>
<td>--robot-port 4242</td>
</tr>
<tr>
<td>--selendroid-port</td>
<td>8080</td>
<td>用来和 Selendroid 交互的本地端口</td>
<td>--selendroid-port 8080</td>
</tr>
<tr>
<td>--chromedriver-port</td>
<td>9515</td>
<td>ChromeDriver运行的端口</td>
<td>--chromedriver-port 9515</td>
</tr>
<tr>
<td>--chromedriver-executable</td>
<td>null</td>
<td>ChromeDriver 可执行文件的完整路径</td>
<td></td>
</tr>
<tr>
<td>--use-keystore</td>
<td>false</td>
<td>(Android-only) 设置签名 apk 的 keystore</td>
<td></td>
</tr>
<tr>
<td>--keystore-path</td>
<td>(Android-only) keystore 的路径</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--keystore-password</td>
<td>android</td>
<td>(Android-only) keystore 的密码</td>
<td></td>
</tr>
<tr>
<td>--key-alias</td>
<td>androiddebugkey</td>
<td>(Android-only) Key 的别名</td>
<td></td>
</tr>
<tr>
<td>--key-password</td>
<td>android</td>
<td>(Android-only) Key 的密码</td>
<td></td>
</tr>
<tr>
<td>--show-config</td>
<td>false</td>
<td>打印 Appium 服务器的配置信息，然后退出</td>
<td></td>
</tr>
<tr>
<td>--no-perms-check</td>
<td>false</td>
<td>跳过Appium对是否可以读/写必要文件的检查</td>
<td></td>
</tr>
<tr>
<td>--command-timeout</td>
<td>60</td>
<td>默认所有会话的接收命令超时时间 (在超时时间内没有接收到新命令，自动关闭会话)。 会被新的超时时间覆盖</td>
<td></td>
</tr>
<tr>
<td>--keep-keychains</td>
<td>false</td>
<td>(iOS) 当 Appium 启动或者关闭的时候，是否保留 keychains (Library/Keychains)</td>
<td></td>
</tr>
<tr>
<td>--strict-caps</td>
<td>false</td>
<td>如果所选设备是appium不承认的有效设备，会导致会话失败</td>
<td></td>
</tr>
<tr>
<td>--isolate-sim-device</td>
<td>false  Xcode 6存在一个bug，那就是一些平台上如果其他模拟器设备先被删除时某个特定的模拟器只能在没有任何错误的情况下被建立。这个选项导致了Appium不得不删除除了正在使用设备以外其他所有的设备。请注意这是永久性删除，你可以使用simctl或xcode管理被Appium使用的设备类别。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>--tmp</td>
<td>null</td>
<td>可以被Appium用来管理临时文件的目录（绝对路径），比如存放需要移动的内置iOS应用程序。 默认的变量为 APPIUM_TMP_DIR ，在 *nix/Mac 为 /tmp 在windows上使用环境便令 TEMP 设定的目录。</td>
<td></td>
</tr>
<tr>
<td>--trace-dir</td>
<td>null</td>
<td>用于保存iOS instruments trace的 appium 目录，是绝对路径， 默认为 /appium-instruments</td>
<td></td>
</tr>
<tr>
<td>--intent-action</td>
<td>android.intent.action.MAIN</td>
<td>(Android-only) 用于启动 activity 的intent action</td>
<td>--intent-action android.intent.action.MAIN</td>
</tr>
<tr>
<td>--intent-category</td>
<td>android.intent.category.LAUNCHER</td>
<td>(Android-only) 用于启动 activity 的intent category</td>
<td>--intent-category android.intent.category.APP_CONTACTS</td>
</tr>
<tr>
<td>--intent-flags</td>
<td>0x10200000</td>
<td>(Android-only) 启动 activity 的标志</td>
<td>--intent-flags 0x10200000</td>
</tr>
<tr>
<td>--intent-args</td>
<td>null</td>
<td>(Android-only) 启动 activity 时附带额外的 intent 参数</td>
<td>--intent-args 0x10200000</td>
</tr>
<tr>
<td>--suppress-adb-kill-server</td>
<td>false</td>
<td>(Android-only) 如果被设定，阻止Appium杀掉adb实例。</td>
<td></td>
</tr>
</tbody>
</table>

<h3 id="toc_18">(二) Android测试用例编写</h3>

<h4 id="toc_19">1、例子:</h4>

<pre class="line-numbers"><code class="language-python">import os

import unittest
from appium import webdriver
from time import sleep

PATH = lambda p: os.path.abspath(
    os.path.join(os.path.dirname(__file__),p)
)

class XingQiuAndroidTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps[&#39;deviceName&#39;] = &#39;emulator-5554&#39;  #adb devices查到的设备名
        desired_caps[&#39;platformName&#39;] = &#39;Android&#39;
        desired_caps[&#39;platformVersion&#39;] = &#39;4.4&#39;
        desired_caps[&#39;app&#39;] = PATH(
            &#39;../../../Users/jiangruoming/Desktop/***.apk&#39;
        )
        desired_caps[&#39;appPackage&#39;] = &#39;com.***.***&#39;  #被测App的包名
        desired_caps[&#39;appActivity&#39;] = &#39;.****&#39; #启动时的Activity

        self.driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

    #earDown 方法在每个测试方法执行后调用，这个地方做所有清理工作，如退出
    def tearDown(self):
        self.driver.quit()

    #放置的就是我们的测试脚本了，这部分我们并不陌生；因为我们执行的脚本就在这里。
    def test_add_contacts(self):
        el = self.driver.find_element_by_id(&quot;com.***.***:id/sign_phone&quot;)
        el.click()

        phone_number = self.driver.find_element_by_id(&quot;com.***.***:id/et_user_phone&quot;)
        code = self.driver.find_element_by_id(&quot;com.***.***:id/et_smscode&quot;)
        phone_number.send_keys(&quot;*********&quot;)
        code.send_keys(&quot;****&quot;)

        btn = self.driver.find_element_by_id(&quot;com.***.***:id/btn_finish&quot;)
        btn.click()

if __name__ == &#39;__main__&#39;:
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuAndroidTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>

<h4 id="toc_20">2、测试流程</h4>

<h5 id="toc_21">(1) 启动Appium</h5>

<p><code>appium -a 127.0.0.1 -p 4723 --log /path/to/appium.log</code></p>

<h5 id="toc_22">(2) 启动Android模拟器</h5>

<p>由于测试apk不支持X86平台，所以Genymotion无法支持运行，原生arm模拟器运行过慢(胃都等疼了)。试过多个模拟器后，最终选定了夜神模拟器，效果还是不错的。但是由于其主要用于PC平台运行Android游戏，所以用于开发平台还是需要进行配置。</p>

<h6 id="toc_23">a、adb配置</h6>

<p>在Mac环境中加入adb的环境变量<br/><br/>
<code>vi .bash_profile</code><br/><br/>
<code>export PATH=/Users/Path/To/Android/sdk/platform-tools/:$PATH</code><br/><br/>
<code>source .bash_profile</code>  </p>

<h6 id="toc_24">b、adb连接</h6>

<p>之后进入夜神的包内容中在adb所在文件夹运行adb连接命令<br/><br/>
<code>adb connect 127.0.0.1:62001</code><br/>
这样<code>adb devices</code>就能显示夜神模拟器的Device ID</p>

<h5 id="toc_25">(3) 运行脚本</h5>

<h3 id="toc_26">(三) iOS测试用例编写</h3>

<h4 id="toc_27">1、例子:</h4>

<pre class="line-numbers"><code class="language-python">import unittest
import os
from appium import webdriver
from time import sleep


PATH = lambda p: os.path.abspath(
    os.path.join(os.path.dirname(__file__),p)
)

class XingQiuiOSTests(unittest.TestCase):

    def setUp(self):
        desired_caps = {}
        desired_caps[&#39;platformName&#39;] = &#39;iOS&#39;
        desired_caps[&#39;platformVersion&#39;] = &#39;10.2&#39;
        desired_caps[&#39;deviceName&#39;] = &#39;iPhone Simulator&#39;
        desired_caps[&#39;app&#39;] = PATH(&#39;../../../Users/jiangruoming/Desktop/***.app&#39;)

        self.driver = webdriver.Remote(&#39;http://localhost:4723/wd/hub&#39;, desired_caps)

    #def tearDown(self):
        #self.driver.quit()

    def test_add_contacts(self):

        el2 = self.driver.find_elements_by_accessibility_id(&#39;Allow&#39;)

        if el2:
            el2[0].click()

        el3 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeButton&#39;)[0]
        el3.click()

        el4 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeTextField&#39;)[0]
        el4.send_keys(&quot;15088678313&quot;)

        el5 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeTextField&#39;)[1]
        el5.send_keys(&quot;1234&quot;)

        el6 = self.driver.find_elements_by_class_name(&#39;XCUIElementTypeButton&#39;)[0]
        el6.click()

if __name__ == &#39;__main__&#39;:
    suite = unittest.TestLoader().loadTestsFromTestCase(XingQiuiOSTests)
    unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>

<h4 id="toc_28">2、XCUIElementType</h4>

<pre class="line-numbers"><code class="language-python">XCUIElementTypeAny,
    XCUIElementTypeUnknown,
    XCUIElementTypeApplication,
    XCUIElementTypeGroup,
    XCUIElementTypeWindow,
    XCUIElementTypeSheet,
    XCUIElementTypeDrawer,
    XCUIElementTypeAlert,
    XCUIElementTypeDialog,
    XCUIElementTypeButton,
    XCUIElementTypeRadioButton,
    XCUIElementTypeRadioGroup,
    XCUIElementTypeCheckBox,
    XCUIElementTypeDisclosureTriangle,
    XCUIElementTypePopUpButton,
    XCUIElementTypeComboBox,
    XCUIElementTypeMenuButton,
    XCUIElementTypeToolbarButton,
    XCUIElementTypePopover,
    XCUIElementTypeKeyboard,
    XCUIElementTypeKey,
    XCUIElementTypeNavigationBar,
    XCUIElementTypeTabBar,
    XCUIElementTypeTabGroup,
    XCUIElementTypeToolbar,
    XCUIElementTypeStatusBar,
    XCUIElementTypeTable,
    XCUIElementTypeTableRow,
    XCUIElementTypeTableColumn,
    XCUIElementTypeOutline,
    XCUIElementTypeOutlineRow,
    XCUIElementTypeBrowser,
    XCUIElementTypeCollectionView,
    XCUIElementTypeSlider,
    XCUIElementTypePageIndicator,
    XCUIElementTypeProgressIndicator,
    XCUIElementTypeActivityIndicator,
    XCUIElementTypeSegmentedControl,
    XCUIElementTypePicker,
    XCUIElementTypePickerWheel,
    XCUIElementTypeSwitch,
    XCUIElementTypeToggle,
    XCUIElementTypeLink,
    XCUIElementTypeImage,
    XCUIElementTypeIcon,
    XCUIElementTypeSearchField,
    XCUIElementTypeScrollView,
    XCUIElementTypeScrollBar,
    XCUIElementTypeStaticText,
    XCUIElementTypeTextField,
    XCUIElementTypeDateField,
    XCUIElementTypeTimeField,
    XCUIElementTypeTextView,
    XCUIElementTypeMenu,
    XCUIElementTypeMenuItem,
    XCUIElementTypeMenuBar,
    XCUIElementTypeMenuBarItem,
    XCUIElementTypeMap,
    XCUIElementTypeWebView,
    XCUIElementTypeIncrementArrow,
    XCUIElementTypeDecrementArrow,
    XCUIElementTypeTimeline,
    XCUIElementTypeRatingIndicator,
    XCUIElementTypeValueIndicator,
    XCUIElementTypeSplitGroup,
    XCUIElementTypeSplitter,
    XCUIElementTypeRelevanceIndicator,
    XCUIElementTypeColorWell,
    XCUIElementTypeHelpTag,
    XCUIElementTypeMatte,
    XCUIElementTypeDockItem,
    XCUIElementTypeRuler,
    XCUIElementTypeRulerMarker,
    XCUIElementTypeGrid,
    XCUIElementTypeLevelIndicator,
    XCUIElementTypeCell,
    XCUIElementTypeLayoutArea,
    XCUIElementTypeLayoutItem,
    XCUIElementTypeHandle,
</code></pre>

<h4 id="toc_29">3、Appium Python API</h4>

<h5 id="toc_30">(1) contexts</h5>

<p><code>contexts(self)</code>:<br/><br/>
Returns the contexts within the current session.<br/>
返回当前会话中的上下文，使用后可以识别H5页面的控件<br/>
Usage:<br/><br/>
    <code>driver.contexts</code><br/><br/>
用法:<br/><br/>
    <code>driver.contexts</code></p>

<h5 id="toc_31">(2) current_context</h5>

<p><code>current_context(self)</code>:<br/><br/>
Returns the current context of the current session.<br/><br/>
返回当前会话的当前上下文<br/><br/>
Usage:<br/><br/>
    <code>driver.current_context</code><br/><br/>
用法:<br/><br/>
    <code>driver. current_context</code></p>

<h5 id="toc_32">(3) context</h5>

<p><code>context(self)</code>:<br/><br/>
Returns the current context of the current session.<br/><br/>
返回当前会话的当前上下文。<br/><br/>
Usage:<br/><br/>
    <code>driver.context</code><br/><br/>
用法:<br/><br/>
    <code>driver. Context</code></p>

<h5 id="toc_33">(4) find_element_by_ios_uiautomation</h5>

<p><code>find_element_by_ios_uiautomation(self, uia_string)</code>:<br/><br/>
Finds an element by uiautomation in iOS.<br/><br/>
通过iOS uiautomation查找元素<br/><br/>
Args:  </p>

<ul>
<li>uia_string - The element name in the iOS UIAutomation library<br/>
Usage:<br/>
<code>driver.find_element_by_ios_uiautomation(&#39;.elements()[1].cells()[2]&#39;)</code>
用法:<br/>
<code>dr. find_element_by_ios_uiautomation(‘elements’)</code></li>
</ul>

<h5 id="toc_34">(5) find_element_by_accessibility_id</h5>

<p><code>find_element_by_accessibility_id(self, id)</code>:<br/><br/>
Finds an element by accessibility id.<br/><br/>
通过accessibility id查找元素<br/><br/>
Args:<br/><br/>
    - id - a string corresponding to a recursive element search using the Id/Name that the native Accessibility options utilize<br/><br/>
Usage:<br/><br/>
    <code>driver.find_element_by_accessibility_id()</code><br/><br/>
用法:<br/><br/>
    <code>driver.find_element_by_accessibility_id(‘id’)</code></p>

<h5 id="toc_35">(6) scroll</h5>

<p><code>scroll(self, origin_el, destination_el)</code>:<br/>
Scrolls from one element to another<br/><br/>
从元素origin_el滚动至元素destination_el<br/><br/>
Args:  </p>

<ul>
<li>originalEl - the element from which to being scrolling</li>
<li>destinationEl - the element to scroll to<br/>
Usage:<br/>
<code>driver.scroll(el1, el2)</code>
用法:<br/>
<code>driver.scroll(el1,el2)</code></li>
</ul>

<h5 id="toc_36">(7) drag_and_drop</h5>

<p><code>drag_and_drop(self, origin_el, destination_el)</code>:<br/><br/>
Drag the origin element to the destination element<br/><br/>
将元素origin_el拖到目标元素destination_el<br/><br/>
Args:  </p>

<ul>
<li>originEl - the element to drag</li>
<li>destinationEl - the element to drag to<br/>
用法:<br/>
<code>driver.drag_and_drop(el1,el2)</code></li>
</ul>

<h5 id="toc_37">(8) tap</h5>

<p><code>tap(self, positions, duration=None)</code>:<br/><br/>
Taps on an particular place with up to five fingers, holding for a certain time<br/><br/>
模拟手指点击（最多五个手指），可设置按住时间长度（毫秒）<br/><br/>
Args:</p>

<ul>
<li>positions - an array of tuples representing the x/y coordinates of the fingers to tap. Length can be up to five.</li>
<li>duration - (optional) length of time to tap, in ms<br/>
Usage:<br/>
<code>driver.tap([(100, 20), (100, 60), (100, 100)], 500)</code>
用法:<br/>
<code>driver.tap([(x,y),(x1,y1)],500)</code></li>
</ul>

<h5 id="toc_38">(9) swipe</h5>

<p><code>swipe(self, start_x, start_y, end_x, end_y, duration=None)</code>:<br/><br/>
Swipe from one point to another point, for an optional duration.<br/><br/>
从A点滑动至B点，滑动时间为毫秒<br/><br/>
Args:<br/><br/>
    - start_x - x-coordinate at which to start<br/>
    - start_y - y-coordinate at which to start<br/>
    - end_x - x-coordinate at which to stop<br/>
    - end_y - y-coordinate at which to stop<br/>
    - duration - (optional) time to take the swipe, in ms.  </p>

<p>Usage:<br/><br/>
    <code>driver.swipe(100, 100, 100, 400)</code><br/>
用法:<br/><br/>
    <code>driver.swipe(x1,y1,x2,y2,500)</code></p>

<h5 id="toc_39">(10) flick</h5>

<p><code>flick(self, start_x, start_y, end_x, end_y)</code>:<br/><br/>
Flick from one point to another point.<br/><br/>
按住A点后快速滑动至B点<br/><br/>
Args:<br/><br/>
    - start_x - x-coordinate at which to start<br/>
    - start_y - y-coordinate at which to start<br/>
    - end_x - x-coordinate at which to stop<br/>
    - end_y - y-coordinate at which to stop<br/><br/>
Usage:<br/><br/>
    <code>driver.flick(100, 100, 100, 400)</code><br/>
用法:<br/><br/>
    <code>driver.flick(x1,y1,x2,y2)</code></p>

<h5 id="toc_40">(11) pinch</h5>

<p><code>pinch(self, element=None, percent=200, steps=50)</code>:<br/><br/>
Pinch on an element a certain amount<br/><br/>
在元素上执行模拟双指捏（缩小操作）<br/><br/>
Args:  </p>

<ul>
<li>element - the element to pinch</li>
<li>percent - (optional) amount to pinch. Defaults to 200%</li>
<li>steps - (optional) number of steps in the pinch action</li>
</ul>

<p>Usage:<br/><br/>
    <code>driver.pinch(element)</code><br/>
用法:<br/>
    <code>driver.pinch(element)</code></p>

<h5 id="toc_41">(12) zoom</h5>

<p><code>zoom(self, element=None, percent=200, steps=50)</code>:<br/>
Zooms in on an element a certain amount<br/><br/>
在元素上执行放大操作<br/><br/>
Args:  </p>

<ul>
<li>element - the element to zoom</li>
<li>percent - (optional) amount to zoom. Defaults to 200%</li>
<li>steps - (optional) number of steps in the zoom action</li>
</ul>

<p>Usage:<br/>
    <code>driver.zoom(element)</code><br/>
用法: <br/>
    <code>driver.zoom(element)</code></p>

<h5 id="toc_42">(13) reset</h5>

<p><code>reset(self)</code>:<br/><br/>
Resets the current application on the device.<br/><br/>
重置应用(类似删除应用数据)<br/><br/>
用法:<br/>
<code>driver.reset()</code></p>

<h5 id="toc_43">(14) hide_keyboard</h5>

<p><code>hide_keyboard(self, key_name=None, key=None, strategy=None)</code>:<br/>
Hides the software keyboard on the device. In iOS, use <code>key_name</code> to press a particular key, or <code>strategy</code>. In Android, no parameters are used.<br/>
隐藏键盘,iOS使用key_name隐藏，安卓不使用参数<br/>
Args:  </p>

<ul>
<li>key_name - key to press</li>
<li>strategy - strategy for closing the keyboard (e.g., <code>tapOutside</code>)</li>
</ul>

<p><code>driver.hide_keyboard()</code></p>

<h5 id="toc_44">(15) keyevent</h5>

<p><code>keyevent(self, keycode, metastate=None)</code>:<br/><br/>
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送按键码（安卓仅有），按键码可以上网址中找到<br/><br/>
Args:  </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>

<p>用法:<br/>
<code>dr.keyevent(‘4’)</code></p>

<h5 id="toc_45">(16) press_keycode</h5>

<p><code>press_keycode(self, keycode, metastate=None)</code>:<br/><br/>
Sends a keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送按键码（安卓仅有），按键码可以上网址中找到<br/>
Args:   </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent</li>
</ul>

<p>用法: <br/>
<code>driver.press_ keycode(‘4’)</code>  </p>

<p>dr.keyevent(‘4’)与driver.press_ keycode(‘4’) 功能实现上一样的，都是按了返回键</p>

<h5 id="toc_46">(17) long_press_keycode</h5>

<p><code>long_press_keycode(self, keycode, metastate=None)</code>:<br/><br/>
Sends a long press of keycode to the device. Android only. Possible keycodes can be found in <a href="http://developer.android.com/reference/android/view/KeyEvent.html">http://developer.android.com/reference/android/view/KeyEvent.html</a>.<br/><br/>
发送一个长按的按键码（长按某键）<br/><br/>
Args:   </p>

<ul>
<li>keycode - the keycode to be sent to the device</li>
<li>metastate - meta information about the keycode being sent<br/>
用法:<br/>
<code>driver.long_press_keycode(‘4’)</code></li>
</ul>

<h5 id="toc_47">(18) current_activity</h5>

<p><code>current_activity(self)</code>:<br/><br/>
Retrieves the current activity on the device.<br/><br/>
获取当前的activity<br/><br/>
用法:<br/>
<code>print(driver.current_activity())</code></p>

<h5 id="toc_48">(19) wait_activity</h5>

<p><code>wait_activity(self, activity, timeout, interval=1)</code>:<br/><br/>
Wait for an activity: block until target activity presents or time out.<br/><br/>
This is an Android-only method.<br/><br/>
等待指定的activity出现直到超时，interval为扫描间隔1秒<br/><br/>
即每隔几秒获取一次当前的activity<br/><br/>
返回的True 或 False<br/><br/>
Agrs:</p>

<ul>
<li>activity - target activity</li>
<li>timeout - max wait time, in seconds</li>
<li>interval - sleep interval between retries, in seconds</li>
</ul>

<p>用法:<br/>
    <code>driver.wait_activity(‘.activity.xxx’,5,2)</code></p>

<h5 id="toc_49">(20) background_app</h5>

<p><code>background_app(self, seconds)</code>:<br/>
Puts the application in the background on the device for a certain duration.<br/><br/>
后台运行app多少秒<br/><br/>
Args:  </p>

<ul>
<li>seconds - the duration for the application to remain in the background<br/>
用法:
<code>driver.background_app(5)</code><br/>
置后台5秒后再运行</li>
</ul>

<h5 id="toc_50">(21) is_app_installed</h5>

<p><code>is_app_installed(self, bundle_id)</code>:<br/><br/>
Checks whether the application specified by <code>bundle_id</code> is installed on the device.<br/><br/>
检查app是否有安装<br/><br/>
返回 True or False<br/><br/>
Args:  </p>

<ul>
<li>bundle_id - the id of the application to query<br/></li>
</ul>

<p>用法: <br/>
<code>driver.is_app_installed(“com.xxxx”)</code></p>

<h5 id="toc_51">(22) install_app</h5>

<p><code>install_app(self, app_path)</code>:<br/><br/>
Install the application found at <code>app_path</code> on the device.<br/><br/>
安装app,app_path为安装包路径<br/><br/>
Args:  </p>

<ul>
<li>app_path - the local or remote path to the application to install</li>
</ul>

<p>用法:<br/><br/>
<code>driver.install_app(app_path)</code></p>

<h5 id="toc_52">(23) remove_app</h5>

<p><code>remove_app(self, app_id)</code>:<br/><br/>
Remove the specified application from the device.<br/><br/>
删除app<br/><br/>
Args:  </p>

<ul>
<li>app_id - the application id to be removed<br/></li>
</ul>

<p>用法: <br/>
<code>driver.remove_app(“com.xxx.”)</code></p>

<h5 id="toc_53">(24) launch_app</h5>

<p><code>launch_app(self)</code>:<br/><br/>
Start on the device the application specified in the desired capabilities.<br/><br/>
启动app<br/><br/>
用法:<br/><br/>
<code>driver.launch_app()</code></p>

<h5 id="toc_54">(25) close_app</h5>

<p><code>close_app(self)</code>:<br/><br/>
Stop the running application, specified in the desired capabilities, on the device.<br/><br/>
关闭app<br/><br/>
用法:<br/><br/>
<code>driver.close_app()</code><br/><br/>
启动和关闭app运行好像会出错</p>

<h5 id="toc_55">(26) start_activity</h5>

<p><code>start_activity(self, app_package, app_activity, **opts)</code>:<br/><br/>
Opens an arbitrary activity during a test. If the activity belongs to another application, that application is started and the activity is opened.<br/><br/>
This is an Android-only method.<br/><br/>
在测试过程中打开任意活动。如果活动属于另一个应用程序，该应用程序的启动和活动被打开。<br/><br/>
这是一个安卓的方法<br/><br/>
Args:</p>

<ul>
<li>app_package - The package containing the activity to start.</li>
<li>app_activity - The activity to start.</li>
<li>app_wait_package - Begin automation after this package starts (optional).</li>
<li>app_wait_activity - Begin automation after this activity starts (optional).</li>
<li>intent_action - Intent to start (optional).</li>
<li>intent_category - Intent category to start (optional).</li>
<li>intent_flags - Flags to send to the intent (optional).</li>
<li>optional_intent_arguments - Optional arguments to the intent (optional).</li>
<li>stop_app_on_reset - Should the app be stopped on reset (optional)?</li>
</ul>

<p>用法:<br/><br/>
<code>driver.start_activity(app_package, app_activity)</code></p>

<h5 id="toc_56">(27) lock</h5>

<p><code>lock(self, seconds)</code>:<br/><br/>
Lock the device for a certain period of time. iOS only.<br/><br/>
锁屏一段时间  iOS专有<br/><br/>
Args:  </p>

<ul>
<li>the duration to lock the device, in seconds</li>
</ul>

<p>用法:<br/><br/>
<code>driver.lock()</code></p>

<h5 id="toc_57">(28) shake</h5>

<p><code>shake(self)</code>:<br/><br/>
Shake the device.<br/><br/>
摇一摇手机<br/><br/>
用法:<br/><br/>
<code>driver.shake()</code></p>

<h5 id="toc_58">(29) open_notifications</h5>

<p><code>open_notifications(self)</code>:<br/><br/>
Open notification shade in Android (API Level 18 and above)<br/><br/>
打系统通知栏（仅支持API 18 以上的安卓系统）<br/><br/>
用法:<br/><br/>
<code>driver.open_notifications()</code></p>

<h5 id="toc_59">(30) network_connection</h5>

<p><code>network_connection(self)</code>:<br/><br/>
Returns an integer bitmask specifying the network connection type.<br/><br/>
Android only.<br/><br/>
返回网络类型  数值<br/><br/>
Possible values are available through the enumeration <code>appium.webdriver.ConnectionType</code><br/><br/>
用法:<br/><br/>
<code>driver.network_connection</code>  </p>

<h5 id="toc_60">(31) set_network_connection</h5>

<p><code>set_network_connection(self, connectionType)</code>:<br/><br/>
Sets the network connection type. Android only.<br/><br/>
Possible values:  </p>

<table>
<thead>
<tr>
<th>Value (Alias)</th>
<th>Data</th>
<th>Wifi</th>
<th>Airplane Mode</th>
</tr>
</thead>

<tbody>
<tr>
<td>0 (None)</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1 (Airplane Mode)</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2 (Wifi only)</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4 (Data only)</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6 (All network on)</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>

<p>These are available through the enumeration appium.webdriver.ConnectionType`</p>

<p>设置网络类型<br/><br/>
Args:  </p>

<ul>
<li>connectionType - a member of the enum appium.webdriver.ConnectionType</li>
</ul>

<p>用法:<br/><br/>
先加载from appium.webdriver.connectiontype import ConnectionType<br/><br/>
<code>dr.set_network_connection(ConnectionType.WIFI_ONLY)</code><br/><br/>
ConnectionType的类型有<br/><br/>
NO_CONNECTION = 0<br/><br/>
AIRPLANE_MODE = 1<br/><br/>
WIFI_ONLY = 2<br/><br/>
DATA_ONLY = 4<br/><br/>
ALL_NETWORK_ON = 6  </p>

<h5 id="toc_61">(32) available_ime_engines</h5>

<p><code>available_ime_engines(self)</code>:<br/><br/>
Get the available input methods for an Android device. Package and activity are returned (e.g., [&#39;com.android.inputmethod.latin/.LatinIME&#39;])<br/><br/>
Android only.<br/><br/>
返回安卓设备可用的输入法<br/><br/>
用法:<br/><br/>
<code>print(driver.available_ime_engines)</code></p>

<h5 id="toc_62">(33) is_ime_active</h5>

<p><code>is_ime_active(self)</code>:<br/><br/>
Checks whether the device has IME service active. Returns True/False.<br/><br/>
Android only.<br/><br/>
检查设备是否有输入法服务活动。返回真/假。<br/><br/>
安卓<br/><br/>
用法: <br/>
    <code>print(driver.is_ime_active())</code></p>

<h5 id="toc_63">(34) activate_ime_engine</h5>

<p><code>activate_ime_engine(self, engine)</code>:<br/><br/>
Activates the given IME engine on the device.<br/><br/>
Android only.<br/><br/>
激活安卓设备中的指定输入法，设备可用输入法可以从“available_ime_engines”获取<br/><br/>
Args:  </p>

<ul>
<li>engine - the package and activity of the IME engine to activate (e.g.,&#39;com.android.inputmethod.latin/.LatinIME&#39;)<br/></li>
</ul>

<p>用法:<br/><br/>
    <code>driver.activate_ime_engine(“com.android.inputmethod.latin/.LatinIME”)</code></p>

<h5 id="toc_64">(35) deactivate_ime_engine</h5>

<p><code>deactivate_ime_engine(self)</code>:<br/><br/>
Deactivates the currently active IME engine on the device.<br/><br/>
Android only.<br/><br/>
关闭安卓设备当前的输入法<br/><br/>
用法:<br/>
    <code>driver.deactivate_ime_engine()</code></p>

<h5 id="toc_65">(36) active_ime_engine</h5>

<p><code>active_ime_engine(self)</code>:<br/><br/>
Returns the activity and package of the currently active IME engine (e.g.,&#39;com.android.inputmethod.latin/.LatinIME&#39;).<br/><br/>
Android only.<br/><br/>
返回当前输入法的包名<br/><br/>
用法:<br/><br/>
<code>driver.active_ime_engine</code>  </p>

<h5 id="toc_66">(37) toggle_location_services</h5>

<p><code>toggle_location_services(self)</code>:<br/><br/>
Toggle the location services on the device. Android only.<br/><br/>
打开安卓设备上的位置定位设置<br/><br/>
用法:<br/>
<code>driver.toggle_location_services()</code></p>

<h5 id="toc_67">(38) set_location</h5>

<p><code>set_location(self, latitude, longitude, altitude)</code>:<br/><br/>
Set the location of the device<br/><br/>
设置设备的经纬度<br/><br/>
Args:  </p>

<ul>
<li>latitude纬度 - String or numeric value between -90.0 and 90.00</li>
<li>longitude经度 - String or numeric value between -180.0 and 180.0</li>
<li>altitude海拔高度- String or numeric value</li>
</ul>

<p>用法:<br/><br/>
<code>driver.set_location(纬度，经度，高度)</code></p>

<h5 id="toc_68">(39) tag_name</h5>

<p><code>tag_name(self)</code>:<br/><br/>
This element&#39;s <code>tagName</code> property.<br/><br/>
返回元素的tagName属性<br/><br/>
经实践返回的是class name<br/><br/>
用法:<br/><br/>
<code>element.tag_name()</code></p>

<h5 id="toc_69">(40) text</h5>

<p><code>text(self)</code>:<br/><br/>
The text of the element.<br/><br/>
返回元素的文本值<br/><br/>
用法:<br/><br/>
<code>element.text()</code></p>

<h5 id="toc_70">(41) click</h5>

<p><code>click(self)</code>:<br/><br/>
Clicks the element.<br/><br/>
点击元素<br/><br/>
用法:<br/><br/>
<code>element.click()</code></p>

<h5 id="toc_71">(42) submit</h5>

<p><code>submit(self)</code>:<br/><br/>
Submits a form.<br/><br/>
提交表单<br/><br/>
用法:<br/><br/>
暂无</p>

<h5 id="toc_72">(43) clear</h5>

<p><code>clear(self)</code>:<br/><br/>
Clears the text if it&#39;s a text entry element.<br/><br/>
清除输入的内容<br/><br/>
用法:<br/><br/>
<code>element.clear()</code></p>

<h5 id="toc_73">(44) get_attribute</h5>

<p><code>get_attribute(self, name)</code>:<br/><br/>
详见@chenhengjie123 的超级链接<br/><br/>
Gets the given attribute or property of the element.  </p>

<pre class="line-numbers"><code class="language-text">1. 获取 content-desc 的方法为 get_attribute(&quot;name&quot;) ，而且还不能保证返回的一定是 content-desc （content-desc 为空时会返回 text 属性值）  
2. get_attribute 方法不是我们在 uiautomatorviewer 看到的所有属性都能获取的（此处的名称均为使用 get_attribute 时使用的属性名称)
可获取的：
字符串类型：
    `name(返回 content-desc 或 text)`
    `text(返回 text)`
    `className(返回 class，只有 API=&gt;18 才能支持)`
    `resourceId(返回 resource-id，只有 API=&gt;18 才能支持)`
</code></pre>

<p>This method will first try to return the value of a property with the given name. If a property with that name doesn&#39;t exist, it returns the value of the attribute with the same name. If there&#39;s no attribute with that name, <code>None</code> is returned.Values which are considered truthy, that is equals &quot;true&quot; or &quot;false&quot;,are returned as booleans.  All other non-<code>None</code> values are returned as strings.  For attributes or properties which do not exist, <code>None</code> is returned.</p>

<p>Args:</p>

<ul>
<li>name - Name of the attribute/property to retrieve.</li>
</ul>

<p>Example:<br/>
    # Check if the &quot;active&quot; CSS class is applied to an element.</p>

<p><code>is_active = &quot;active&quot; in target_element.get_attribute(&quot;class&quot;)</code></p>

<p>用法:<br/><br/>
暂无</p>

<h5 id="toc_74">(45) is_selected</h5>

<p><code>is_selected(self)</code>:<br/><br/>
Returns whether the element is selected.<br/><br/>
Can be used to check if a checkbox or radio button is selected.<br/><br/>
返回元素是否选择。<br/><br/>
可以用来检查一个复选框或单选按钮被选中。<br/><br/>
用法:<br/><br/>
<code>element.is_slected()</code></p>

<h5 id="toc_75">(46) is_enabled</h5>

<p><code>is_enabled(self)</code>:<br/><br/>
Returns whether the element is enabled.<br/><br/>
返回元素是否可用True of False<br/><br/>
用法:<br/><br/>
<code>element.is_enabled()</code></p>

<h5 id="toc_76">(47) find_element_by_id</h5>

<p><code>find_element_by_id(self, id_)</code>:<br/><br/>
Finds element within this element&#39;s children by ID.<br/><br/>
通过元素的ID定位元素<br/><br/>
Args:  </p>

<ul>
<li>id_ - ID of child element to locate.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_element_by_id(“id”)</code></p>

<h5 id="toc_77">(48) find_elements_by_id</h5>

<p><code>find_elements_by_id(self, id_)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by ID.<br/><br/>
通过元素ID定位,含有该属性的所有元素<br/><br/>
Args:   </p>

<ul>
<li>id_ - Id of child element to find.</li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_elements_by_id(“id”)</code></p>

<h5 id="toc_78">(49) find_element_by_name</h5>

<p><code>find_element_by_name(self, name)</code>:<br/><br/>
Finds element within this element&#39;s children by name.<br/><br/>
通过元素Name定位（元素的名称属性text）. <br/>
Args:  </p>

<ul>
<li>name - name property of the element to find.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_name(“name”)</code></p>

<h5 id="toc_79">(50) find_elements_by_name</h5>

<p><code>find_elements_by_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by name.<br/><br/>
通过元素Name定位（元素的名称属性text），含有该属性的所有元素. <br/>
Args:  </p>

<ul>
<li>name - name property to search for.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_name(“name”)</code></p>

<h5 id="toc_80">(51) find_element_by_link_text</h5>

<p><code>find_element_by_link_text(self, link_text)</code>:<br/><br/>
Finds element within this element&#39;s children by visible link text.<br/><br/>
通过元素可见链接文本定位. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p>用法:<br/>
<code>driver.find_element_by_link_text(“text”)</code></p>

<h5 id="toc_81">(52) find_elements_by_link_text</h5>

<p><code>find_element_by_link_text(self, link_text)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by visible link text. <br/>
通过元素可见链接文本定位,含有该属性的所有元素. <br/>
Args:    </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p>用法: <br/>
<code>driver.find_elements_by_link_text(“text”)</code></p>

<h5 id="toc_82">(53) find_element_by_partial_link_text</h5>

<p><code>find_element_by_partial_link_text(self, link_text)</code>:<br/><br/>
Finds element within this element&#39;s children by partially visible link text.<br/><br/>
通过元素部分可见链接文本定位. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p><code>driver. find_element_by_partial_link_text(“text”)</code></p>

<h5 id="toc_83">(54) find_elements_by_partial_link_text</h5>

<p><code>find_elements_by_partial_link_text(self, link_text)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by link text.<br/><br/>
通过元素部分可见链接文本定位,含有该属性的所有元素. <br/>
Args:  </p>

<ul>
<li>link_text - Link text string to search for.<br/></li>
</ul>

<p><code>driver. find_elements_by_partial_link_text(“text”)</code></p>

<h5 id="toc_84">(55) find_element_by_tag_name</h5>

<p><code>find_element_by_tag_name(self, name)</code>:<br/>
Finds element within this element&#39;s children by tag name.<br/><br/>
通过查找html的标签名称定位元素<br/><br/>
Args:</p>

<ul>
<li>name - name of html tag (eg: h1, a, span)</li>
</ul>

<p>用法:<br/><br/>
    <code>driver.find_element_by_tag_name(“name”)</code></p>

<h5 id="toc_85">(56) find_elements_by_tag_name</h5>

<p><code>find_elements_by_tag_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by tag name.<br/>
通过查找html的标签名称定位所有元素<br/><br/>
Args:  </p>

<ul>
<li>name - name of html tag (eg: h1, a, span). </li>
</ul>

<p>用法:<br/>
    <code>driver.find_elements_by_tag_name(“name”)</code></p>

<h5 id="toc_86">(57) find_element_by_xpath</h5>

<p><code>find_element_by_xpath(self, xpath)</code>:<br/><br/>
Finds element by xpath.<br/><br/>
通过Xpath定位元素，详细方法可参阅<a href="http://www.w3school.com.cn/xpath/">http://www.w3school.com.cn/xpath/</a><br/>
Args:<br/>
    xpath - xpath of element to locate.  &quot;//input[@class=&#39;myelement&#39;]&quot;<br/>
    Note: The base path will be relative to this element&#39;s location.<br/>
    This will select the first link under this element.<br/>
    <code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code><br/>
    However, this will select the first link on the page.<br/>
    <code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>  </p>

<p>用法 <code>find_element_by_xpath(“//*”)</code></p>

<h5 id="toc_87">(58) find_elements_by_xpath</h5>

<p><code>find_elements_by_xpath(self, xpath)</code>:<br/>
Finds elements within the element by xpath.<br/><br/>
Args:</p>

<ul>
<li>xpath - xpath locator string.</li>
</ul>

<p>Note: The base path will be relative to this element&#39;s location.<br/><br/>
This will select all links under this element.<br/><br/>
<code>myelement.find_elements_by_xpath(&quot;.//a&quot;)</code>. <br/>
However, this will select all links in the page itself.<br/><br/>
<code>myelement.find_elements_by_xpath(&quot;//a&quot;)</code>. </p>

<p>用法:<br/><br/>
<code>find_elements_by_xpath(“//*”)</code></p>

<h5 id="toc_88">(59) find_element_by_class_name</h5>

<p><code>find_element_by_class_name(self, name)</code>:<br/><br/>
Finds element within this element&#39;s children by class name.<br/><br/>
通过元素class name属性定位元素.<br/><br/>
Args:  </p>

<ul>
<li>name - class name to search for.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_element_by_class_name(“android.widget.LinearLayout”)</code></p>

<h5 id="toc_89">(60) find_elements_by_class_name</h5>

<p><code>find_elements_by_class_name(self, name)</code>:<br/><br/>
Finds a list of elements within this element&#39;s children by class name.<br/><br/>
通过元素class name属性定位所有含有该属性的元素. <br/>
Args:  </p>

<ul>
<li>name - class name to search for.<br/></li>
</ul>

<p>用法:<br/><br/>
<code>driver. find_elements_by_class_name(“android.widget.LinearLayout”)</code>. </p>

<h5 id="toc_90">(61) find_element_by_css_selector</h5>

<p><code>find_element_by_css_selector(self, css_selector)</code>:<br/><br/>
Finds element within this element&#39;s children by CSS selector.<br/><br/>
通过CSS选择器定位元素. <br/>
Args:  </p>

<ul>
<li>css_selector - CSS selctor string, ex: &#39;a.nav#home&#39;</li>
</ul>

<h5 id="toc_91">(62) send_keys</h5>

<p><code>send_keys(self, *value)</code>:<br/><br/>
Simulates typing into the element.<br/><br/>
在元素中模拟输入（开启appium自带的输入法并配置了appium输入法后，可以输入中英文）. <br/>
Args:</p>

<ul>
<li>value - A string for typing, or setting form fields.  For setting file inputs, this could be a local file path.Use this to send simple key events or to fill out form fields:<br/>
<code>form_textfield = driver.find_element_by_name(&#39;username&#39;)</code><br/>
<code>form_textfield.send_keys(&quot;admin&quot;)</code><br/>
This can also be used to set file inputs.<br/>
<code>file_input = driver.find_element_by_name(&#39;profilePic&#39;)</code><br/>
<code>file_input.send_keys(&quot;path/to/profilepic.gif&quot;)</code><br/>
<code># Generally it&#39;s better to wrap the file path in one of the methods</code><br/>
<code># in os.path to return the actual path to support cross OS testing.</code><br/>
<code># file_input.send_keys(os.path.abspath(&quot;path/to/profilepic.gif&quot;))</code><br/>
<code>driver.element.send_keys(“中英”)</code></li>
</ul>

<h5 id="toc_92">(63) is_displayed</h5>

<p><code>is_displayed(self)</code>:<br/><br/>
Whether the element is visible to a user.<br/><br/>
此元素用户是否可见。简单地说就是隐藏元素和被控件挡住无法操作的元素（仅限 Selenium，appium是否实现了类似功能不是太确定）这一项都会返回 False. <br/>
用法:<br/><br/>
<code>driver.element.is_displayed()</code></p>

<h5 id="toc_93">(64) location_once_scrolled_into_view</h5>

<p><code>location_once_scrolled_into_view(self)</code>:<br/><br/>
 &quot;&quot;&quot;THIS PROPERTY MAY CHANGE WITHOUT WARNING. Use this to discover. where on the screen an element is so that we can click it. This method should cause the element to be scrolled into view.Returns the top lefthand corner location on the screen, or <code>None</code> if the element is not visible.</p>

<p>暂不知道用法</p>

<h5 id="toc_94">(65) size</h5>

<p><code>size(self)</code>:<br/><br/>
The size of the element.<br/><br/>
获取元素的大小（高和宽）.<br/><br/>
<code>new_size[&quot;height&quot;] = size[&quot;height&quot;]</code><br/><br/>
<code>new_size[&quot;width&quot;] = size[&quot;width&quot;]</code>   </p>

<p>用法:<br/><br/>
<code>driver.element.size</code></p>

<h5 id="toc_95">(66) value_of_css_property</h5>

<p><code>value_of_css_property(self, property_name)</code>:<br/><br/>
The value of a CSS property.<br/><br/>
CSS属性<br/><br/>
用法 暂不知  </p>

<h5 id="toc_96">(67) location</h5>

<p><code>location(self)</code>:<br/><br/>
The location of the element in the renderable canvas.<br/><br/>
获取元素左上角的坐标<br/><br/>
用法:<br/><br/>
<code>driver.element.location</code><br/><br/>
返回element的x坐标, int类型<br/><br/>
<code>driver.element.location.get(&#39;x&#39;)</code><br/><br/>
返回element的y坐标, int类型<br/><br/>
<code>driver.element.location.get(&#39;y&#39;)</code></p>

<h5 id="toc_97">(68) rect</h5>

<p><code>rect(self)</code>:<br/><br/>
A dictionary with the size and location of the element.<br/><br/>
元素的大小和位置的字典  </p>

<h5 id="toc_98">(69) screenshot_as_base64</h5>

<p><code>screenshot_as_base64(self)</code>:<br/><br/>
Gets the screenshot of the current element as a base64 encoded string.<br/><br/>
获取当前元素的截图为Base64编码的字符串<br/><br/>
Usage:<br/><br/>
<code>img_b64 = element.screenshot_as_base64</code></p>

<h5 id="toc_99">(70) execute_script</h5>

<p><code>execute_script(self, script, *args)</code>:<br/><br/>
Synchronously Executes JavaScript in the current window/frame.<br/><br/>
在当前窗口/框架（特指 Html 的 iframe ）同步执行 javascript 代码。你可以理解为如果这段代码是睡眠5秒，这五秒内主线程的 javascript 不会执行<br/><br/>
Args:  </p>

<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.<br/>
Usage:<br/>
<code>driver.execute_script(&#39;document.title&#39;)</code></li>
</ul>

<h5 id="toc_100">(71) execute_async_script</h5>

<p><code>execute_async_script(self, script, *args)</code>:<br/><br/>
Asynchronously Executes JavaScript in the current window/frame.<br/><br/>
插入 javascript 代码，只是这个是异步的，也就是如果你的代码是睡眠5秒，那么你只是自己在睡，页面的其他 javascript 代码还是照常执行<br/><br/>
Args:  </p>

<ul>
<li>script: The JavaScript to execute.</li>
<li>*args: Any applicable arguments for your JavaScript.</li>
</ul>

<p>Usage:<br/><br/>
<code>driver.execute_async_script(&#39;document.title&#39;)</code></p>

<h5 id="toc_101">(72) current_url</h5>

<p><code>current_url(self)</code>:<br/><br/>
Gets the URL of the current page.<br/><br/>
获取当前页面的网址。<br/><br/>
Usage:<br/><br/>
<code>driver.current_url</code><br/>
用法<br/><br/>
<code>driver.current_url</code></p>

<h5 id="toc_102">(73) page_source</h5>

<p><code>page_source(self)</code>:<br/><br/>
Gets the source of the current page.<br/><br/>
获取当前页面的源<br/><br/>
Usage:<br/><br/>
<code>driver.page_source</code></p>

<h5 id="toc_103">(74) close</h5>

<p><code>close(self)</code>:<br/>
Closes the current window.<br/><br/>
关闭当前窗口<br/><br/>
Usage:<br/><br/>
<code>driver.close()</code></p>

<h5 id="toc_104">(75) quit</h5>

<p><code>quit(self)</code>:<br/><br/>
Quits the driver and closes every associated window.<br/><br/>
退出脚本运行并关闭每个相关的窗口连接<br/><br/>
Usage:<br/><br/>
<code>driver.quit()</code></p>

<p>参考资料:<br/><br/>
<a href="http://debugtalk.com/post/build-ideal-app-automation-test-framework/">打造心目中理想的自动化测试框(AppiumBooster)</a>   </p>

<p><a href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/">从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用</a>  </p>

<p><a href="https://github.com/appium/python-client">Python-Client的github文档地址</a></p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-02-18T21:14:26+08:00" itemprop="datePublished">2017/2/18</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207868936.html" itemprop="url">
		LaTeX表示方法</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">一、指数和下标可以用<sup>和_后加相应字符来实现。</sup></h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880615440131.png" alt="20170306148880615440131.png"/><figcaption>20170306148880615440131.png</figcaption></figure></p>

<h2 id="toc_1">二、平方根（square root）的输入命令为：\sqrt，n 次方根相应地为: \sqrt[n]。方根符号的大小由LATEX自动加以调整。也可用\surd 仅给出符号。</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880619510161.png" alt="20170306148880619510161.png"/><figcaption>20170306148880619510161.png</figcaption></figure></p>

<h2 id="toc_2">三、命令\overline 和\underline 在表达式的上、下方画出水平线。</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880622063960.png" alt="20170306148880622063960.png"/><figcaption>20170306148880622063960.png</figcaption></figure></p>

<h2 id="toc_3">四、命令\overbrace 和\underbrace 在表达式的上、下方给出一水平的大括号。</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880624549299.png" alt="20170306148880624549299.png"/><figcaption>20170306148880624549299.png</figcaption></figure></p>

<h2 id="toc_4">五、向量（Vectors）通常用上方有小箭头（arrow symbols）的变量表示。这可由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量时非常有用。</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880626397800.png" alt="20170306148880626397800.png"/><figcaption>20170306148880626397800.png</figcaption></figure></p>

<h2 id="toc_5">六、分数（fraction）使用\frac{...}{...} 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880628370651.png" alt="20170306148880628370651.png"/><figcaption>20170306148880628370651.png</figcaption></figure></p>

<h2 id="toc_6">七、积分运算符（integral operator）用\int 来生成。求和运算符（sum operator）由\sum 生成。乘积运算符（product operator）由\prod 生成。上限和下限用^ 和_来生成，类似于上标和下标。</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880629592819.png" alt="20170306148880629592819.png"/><figcaption>20170306148880629592819.png</figcaption></figure></p>

<h2 id="toc_7">以下提供一些常用符号的表示方法</h2>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880631421528.png" alt="20170306148880631421528.png"/><figcaption>20170306148880631421528.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880632396941.png" alt="20170306148880632396941.png"/><figcaption>20170306148880632396941.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880633957635.png" alt="20170306148880633957635.png"/><figcaption>20170306148880633957635.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880635030831.png" alt="20170306148880635030831.png"/><figcaption>20170306148880635030831.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880635878696.png" alt="20170306148880635878696.png"/><figcaption>20170306148880635878696.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880636951388.png" alt="20170306148880636951388.png"/><figcaption>20170306148880636951388.png</figcaption></figure><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170306148880639426612.png" alt="20170306148880639426612.png"/><figcaption>20170306148880639426612.png</figcaption></figure>  </p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-02-18T21:14:26+08:00" itemprop="datePublished">2017/2/18</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='%E6%9C%8D%E5%8A%A1%E5%99%A8.html'>服务器</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207868967.html" itemprop="url">
		命令行工具使用</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">替换Ruby的源</h2>

<ul>
<li><code>$gem source -r https://rubygems.org/</code></li>
<li><code>$ gem source -a https://ruby.taobao.org</code></li>
<li><code>$ gem sources -l</code>要想验证是否替换成功了，可以执行</li>
<li><code>CURRENT SOURCES　http://ruby.taobao.org/</code>正常的输出结果</li>
</ul>

<h2 id="toc_1">Mac OS X安装Ruby运行环境</h2>

<ul>
<li>先安装 Xcode 开发工具，它将帮你安装好 Unix 环境需要的开发包。</li>
<li>安装 RVM
<ul>
<li><code>$ curl -L https://get.rvm.io | bash -s stable</code>期间可能会问你sudo管理员密码，以及自动通过homebrew安装依赖包，等待一段时间后就可以成功安装好 RVM。</li>
<li><code>$ source ~/.rvm/scripts/rvm</code>载入 RVM 环境</li>
<li><code>rvm -v</code>检查一下是否安装正确</li>
</ul></li>
<li>用 RVM 安装 Ruby 环境
<ul>
<li><code>$ rvm list known</code>列出已知的ruby版本</li>
<li><code>$ rvm install 2.4.0</code>可以选择现有的rvm版本来进行安装</li>
<li><code>$ rvm list</code>查询已经安装的ruby</li>
<li><code>$ rvm remove 1.9.2</code>卸载一个已安装版本</li>
</ul></li>
<li>设置 Ruby 版本
<ul>
<li><code>$ rvm 2.0.0 --default</code>RVM 装好以后，需要执行下面的命令将指定版本的 Ruby 设置为系统默认版本</li>
</ul></li>
</ul>

<h2 id="toc_2">Mac OS X安装cocoapods</h2>

<ul>
<li><code>sudo gem install cocoapods</code></li>
<li>如果速度不行，更换源。</li>
</ul>

<h2 id="toc_3">Mac OS X安装命令行切图工具</h2>

<ul>
<li>由一张1024*1024的图片批量生成applogo
<ul>
<li>brew install imagemagick</li>
<li>配置icon_convert.sh文件</li>
<li>cd 到icon_convert.sh所在文件夹</li>
<li>执行<code>./icon_convert.sh &#39;1024.png&#39;</code></li>
<li>生成对应的appicon
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-03-16%20%E4%B8%8B%E5%8D%883.43.34.png" alt="icon_convert.sh"/><figcaption>icon_convert.sh</figcaption></figure></li>
</ul></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-02-10T21:40:26+08:00" itemprop="datePublished">2017/2/10</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207868901.html" itemprop="url">
		Android Matrix</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">Matrix的数学原理</h2>

<p>在Android中，如果你用Matrix进行过图像处理，那么一定知道Matrix这个类。Android中的Matrix是一个3 x 3的矩阵，其内容如下：  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833750324849.png" alt="1.png"/><figcaption>1.png</figcaption></figure></p>

<p>Matrix的对图像的处理可分为四类基本变换：</p>

<ul>
<li>Translate ————    平移变换</li>
<li>Rotate        ————    旋转变换</li>
<li>Scale     ————    缩放变换</li>
<li>Skew          ————    错切变换</li>
</ul>

<p>从字面上理解，矩阵中的MSCALE用于处理缩放变换，MSKEW用于处理错切变换，MTRANS用于处理平移变换，MPERSP用于处理透视变换。实际中当然不能完全按照字面上的说法去理解Matrix。同时，在Android的文档中，未见到用Matrix进行透视变换的相关说明，所以本文也不讨论这方面的问题。这里需要把矩阵根据他们的作用划分为4块：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616374765871.png" alt="20170923150616374765871.png"/><figcaption>20170923150616374765871.png</figcaption></figure></p>

<p>如上图所示，这四块区域各有作用。后面会详细讲解各个作用，先来看看这个矩阵是如何影响图像的。先看看屏幕的坐标系：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616379323870.png" alt="20170923150616379323870.png"/><figcaption>20170923150616379323870.png</figcaption></figure></p>

<p>看上图，这里表示了屏幕的坐标系，其中的x，y轴是大家所熟知的，但是其实，一个物体他是存在于一个三维空间的，所以必然会有z轴。我们的屏幕，就像是一个窗口，透过它，我们看到了屏幕后面的世界，那里面有各种物体，我们看到的是映射在x，y平面上的一个投射图像。屏幕就像是一个镜头一样，将里面的物体映射到x，y平面上，成为一个二维的图像。那么如果，我们把屏幕这个镜头沿着z轴，拉远或者拉进，那么图像会有什么变化呢，肯定会变小或者变大。就好比坐在飞机上透过窗口看地面的汽车，和在地面上看到的大小是不同的。</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616386136695.png" alt="20170923150616386136695.png"/><figcaption>20170923150616386136695.png</figcaption></figure></p>

<p>x，y分别代表x，y轴上的坐标，而1代表屏幕在z轴上的坐标为默认的。如果将1变大，那么屏幕会拉远， 图形会变小。</p>

<p>针对每种变换，Android提供了pre、set和post三种操作方式。其中</p>

<ul>
<li>set用于设置Matrix中的值。</li>
<li>pre是先乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。先乘相当于矩阵运算中的右乘。</li>
<li>post是后乘，因为矩阵的乘法不满足交换律，因此先乘、后乘必须要严格区分。后乘相当于矩阵运算中的左乘。</li>
</ul>

<p>除平移变换(Translate)外，旋转变换(Rotate)、缩放变换(Scale)和错切变换(Skew)都可以围绕一个中心点来进行，如果不指定，在默认情况下是围绕(0, 0)来进行相应的变换的。</p>

<p>下面我们来看看四种变换的具体情形。由于所有的图形都是有点组成，因此我们只需要考察一个点相关变换即可。</p>

<h3 id="toc_1">平移变换</h3>

<p>假定有一个点的坐标是 P(\(x_{0}\),\(y_{0}\)) ，将其移动到 P(x,y) ，再假定在x轴和y轴方向移动的大小分别为: \(\Delta\)x = x - \(x_{0}\) and \(\Delta\)y = y - \(y_{0}\)   </p>

<p>如下图所示：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833900863943.png" alt="20170301148833900863943.png"/><figcaption>20170301148833900863943.png</figcaption></figure>  </p>

<p>不难知道：<br/><br/>
x = \(x_{0}\) + \(\Delta\)x<br/><br/>
y = \(y_{0}\) + \(\Delta\)y    </p>

<p>如果用矩阵来表示的话，就可以写成：  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833910576102.png" alt="20170301148833910576102.png"/><figcaption>20170301148833910576102.png</figcaption></figure></p>

<h3 id="toc_2">旋转变换</h3>

<h4 id="toc_3">围绕坐标原点旋转：</h4>

<p>假定有一个点 P(\(x_{0}\),\(y_{0}\)) ，相对坐标原点 \(\theta\) 顺时针旋转后的情形，同时假定P点离坐标原点的距离为r，如下图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833915872714.png" alt="20170301148833915872714.png"/><figcaption>20170301148833915872714.png</figcaption></figure></p>

<p>那么，<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833921797142.png" alt="20170301148833921797142.png"/><figcaption>20170301148833921797142.png</figcaption></figure></p>

<p>如果用矩阵，就可以表示为：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833923074578.png" alt="20170301148833923074578.png"/><figcaption>20170301148833923074578.png</figcaption></figure></p>

<h4 id="toc_4">围绕某个点旋转</h4>

<p>如果是围绕某个点 P(\(x_{p}\),\(y_{p}\)) 顺时针旋转 \(\theta\) ，那么可以用矩阵表示为：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883392576953.png" alt="2017030114883392576953.png"/><figcaption>2017030114883392576953.png</figcaption></figure><br/><br/>
可以化为：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833927146486.png" alt="20170301148833927146486.png"/><figcaption>20170301148833927146486.png</figcaption></figure><br/><br/>
很显然<br/><br/>
1、<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833928967061.png" alt="20170301148833928967061.png"/><figcaption>20170301148833928967061.png</figcaption></figure>是将坐标原点移动到点 P(\(x_{p}\),\(y_{p}\)) 后， P(\(x_{0}\),\(y_{0}\)) 的新坐标。  </p>

<p>2、<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833934213059.png" alt="20170301148833934213059.png"/><figcaption>20170301148833934213059.png</figcaption></figure>是将上一步变换后的 P(\(x_{0}\),\(y_{0}\)) ，围绕新的坐标原点顺时针旋转 \(\theta\) 。<br/><br/>
3、<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833940633954.png" alt="20170301148833940633954.png"/><figcaption>20170301148833940633954.png</figcaption></figure><br/><br/>
经过上一步旋转变换后，再将坐标原点移回到原来的坐标原点。<br/><br/>
所以，围绕某一点进行旋转变换，可以分成3个步骤，即首先将坐标原点移至该点，然后围绕新的坐标原点进行旋转变换，再然后将坐标原点移回到原先的坐标原点。  </p>

<p>同时，可以看到，上面的矩阵四块区域的切分也是因为矩阵乘法的操作决定的，由于这里的乘法运算中，左上角的四个值，可以和x，y值做乘法运算，所以可以影响到旋转等操作，而右上角的模块，只能做加法，所以只能影响到平移。右下角的模块主要管z轴，自然就可以进行等比的缩放了，左下角的模块一般不去动他，否则会把x，y值加入到z轴中来，会不可控。</p>

<h3 id="toc_5">缩放变换</h3>

<p>理论上而言，一个点是不存在什么缩放变换的，但考虑到所有图像都是由点组成，因此，如果图像在x轴和y轴方向分别放大k1和k2倍的话，那么图像中的所有点的x坐标和y坐标均会分别放大k1和k2倍，即<br/><br/>
x = \(k_{1}\)\(x_{0}\)<br/><br/>
y = \(k_{2}\)\(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833944726575.png" alt="20170301148833944726575.png"/><figcaption>20170301148833944726575.png</figcaption></figure><br/><br/>
缩放变换比较好理解，就不多说了。 </p>

<h3 id="toc_6">错切变换</h3>

<p>错切变换(skew)在数学上又称为Shear mapping(可译为“剪切变换”)或者Transvection(缩并)，它是一种比较特殊的线性变换。错切变换的效果就是让所有点的x坐标(或者y坐标)保持不变，而对应的y坐标(或者x坐标)则按比例发生平移，且平移的大小和该点到x轴(或y轴)的垂直距离成正比。错切变换，属于等面积变换，即一个形状在错切变换的前后，其面积是相等的。<br/><br/>
比如下图，各点的y坐标保持不变，但其x坐标则按比例发生了平移。这种情况将水平错切。  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833947362086.png" alt="20170301148833947362086.png"/><figcaption>20170301148833947362086.png</figcaption></figure><br/><br/>
下图各点的x坐标保持不变，但其y坐标则按比例发生了平移。这种情况叫垂直错切。  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833948852458.png" alt="20170301148833948852458.png"/><figcaption>20170301148833948852458.png</figcaption></figure>  </p>

<p>假定一个点 P(\(x_{0}\),\(y_{0}\)) 经过错切变换后得到 P(x,y) ，对于水平错切而言，应该有如下关系：<br/><br/>
x = \(x_{0}\) + k\(y_{0}\)<br/><br/>
y = \(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833957987910.png" alt="20170301148833957987910.png"/><figcaption>20170301148833957987910.png</figcaption></figure><br/><br/>
扩展到3 x 3的矩阵就是下面这样的形式：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833959011272.png" alt="20170301148833959011272.png"/><figcaption>20170301148833959011272.png</figcaption></figure><br/><br/>
同理，对于垂直错切，可以有：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833960187699.png" alt="20170301148833960187699.png"/><figcaption>20170301148833960187699.png</figcaption></figure><br/><br/>
在数学上严格的错切变换就是上面这样的。在Android中除了有上面说到的情况外，还可以同时进行水平、垂直错切，那么形式上就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148833961263046.png" alt="20170301148833961263046.png"/><figcaption>20170301148833961263046.png</figcaption></figure></p>

<h3 id="toc_7">对称变换</h3>

<p>除了上面讲到的4中基本变换外，事实上，我们还可以利用Matrix，进行对称变换。所谓对称变换，就是经过变化后的图像和原图像是关于某个对称轴是对称的。比如，某点 P(\(x_{0}\),\(y_{0}\)) 经过对称变换后得到 P(x,y) ，</p>

<p>如果对称轴是x轴，那么，<br/><br/>
x = \(x_{0}\)<br/><br/>
y = -\(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834373561338.png" alt="20170301148834373561338.png"/><figcaption>20170301148834373561338.png</figcaption></figure><br/><br/>
如果对称轴是y轴，那么，<br/><br/>
x = -\(x_{0}\)<br/><br/>
y = \(y_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834375645689.png" alt="20170301148834375645689.png"/><figcaption>20170301148834375645689.png</figcaption></figure><br/><br/>
如果对称轴是y = x，如图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834376584200.png" alt="20170301148834376584200.png"/><figcaption>20170301148834376584200.png</figcaption></figure><br/><br/>
那么，<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834377595408.png" alt="20170301148834377595408.png"/><figcaption>20170301148834377595408.png</figcaption></figure><br/><br/>
很容易可以解得：<br/><br/>
x = \(y_{0}\)<br/><br/>
y = \(x_{0}\)<br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883437925984.png" alt="2017030114883437925984.png"/><figcaption>2017030114883437925984.png</figcaption></figure><br/><br/>
同样的道理，如果对称轴是y = -x，那么用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834380928745.png" alt="20170301148834380928745.png"/><figcaption>20170301148834380928745.png</figcaption></figure><br/><br/>
特殊地，如果对称轴是y = kx，如下图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834381851581.png" alt="20170301148834381851581.png"/><figcaption>20170301148834381851581.png</figcaption></figure><br/><br/>
那么，<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834382842810.png" alt="20170301148834382842810.png"/><figcaption>20170301148834382842810.png</figcaption></figure><br/><br/>
很容易可解得：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834383638888.png" alt="20170301148834383638888.png"/><figcaption>20170301148834383638888.png</figcaption></figure><br/><br/>
用矩阵表示就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201703011488343844739.png" alt="201703011488343844739.png"/><figcaption>201703011488343844739.png</figcaption></figure>  </p>

<p>当k = 0时，即y = 0，也就是对称轴为x轴的情况；当k趋于无穷大时，即x = 0，也就是对称轴为y轴的情况；当k =1时，即y = x，也就是对称轴为y = x的情况；当k = -1时，即y = -x，也就是对称轴为y = -x的情况。不难验证，这和我们前面说到的4中具体情况是相吻合的。<br/><br/>
如果对称轴是y = kx + b这样的情况，只需要在上面的基础上增加两次平移变换即可，即先将坐标原点移动到(0, b)，然后做上面的关于y = kx的对称变换，再然后将坐标原点移回到原来的坐标原点即可。用矩阵表示大致是这样的：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834385747500.png" alt="20170301148834385747500.png"/><figcaption>20170301148834385747500.png</figcaption></figure><br/><br/>
需要特别注意：在实际编程中，我们知道屏幕的y坐标的正向和数学中y坐标的正向刚好是相反的，所以在数学上y = x和屏幕上的y = -x才是真正的同一个东西，反之亦然。也就是说，如果要使图片在屏幕上看起来像按照数学意义上y = x对称，那么需使用这种转换：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834387269783.png" alt="20170301148834387269783.png"/><figcaption>20170301148834387269783.png</figcaption></figure><br/><br/>
要使图片在屏幕上看起来像按照数学意义上y = -x对称，那么需使用这种转换：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883438827302.png" alt="2017030114883438827302.png"/><figcaption>2017030114883438827302.png</figcaption></figure><br/><br/>
关于对称轴为y = kx 或y = kx + b的情况，同样需要考虑这方面的问题。</p>

<h3 id="toc_8">三角函数</h3>

<pre class="line-numbers"><code class="language-text">public void setSinCos(float sinValue, float cosValue, float px, float py)
public void setSinCos(float sinValue, float cosValue)
</code></pre>

<p>这个方法乍一看可能有点蒙，其实在前面的原理中，我们讲解了一个旋转的例子，他最终的矩阵效果是这样的：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616425357007.jpg" alt="20170923150616425357007.jpg"/><figcaption>20170923150616425357007.jpg</figcaption></figure></p>

<p>其实旋转，就是使用了这样的matrix，显而易见，这里的参数就清晰了。<br/><br/>
sinValue：对应图中的sin值<br/><br/>
cosValue：对应cos值<br/><br/>
px:中心的x坐标<br/><br/>
py：中心的y坐标<br/><br/>
看一个示例,我们把图像旋转90度，那么90度对应的sin和cos分别是1和0。  </p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616431122661.png" alt="20170923150616431122661.png"/><figcaption>20170923150616431122661.png</figcaption></figure></p>

<p>看代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrixmatrix = new Matrix();
matrix.setSinCos(1, 0, bitmap.getWidth() / 2, bitmap.getHeight() / 2);
canvas.drawBitmap(bitmap, matrix, paint);123123
</code></pre>

<h3 id="toc_9">数值操作</h3>

<p>数值操作这一组方法可以帮助我们直接控制Matrix里面的数值。</p>

<h4 id="toc_10">set</h4>

<p><code>void set (Matrix src)</code>没有返回值，有一个参数，作用是将参数Matrix的数值复制到当前Matrix中。如果参数为空，则重置当前Matrix，相当于<code>reset()</code></p>

<h4 id="toc_11">reset</h4>

<p><code>void reset ()</code>重置当前Matrix(将当前Matrix重置为单位矩阵)。</p>

<h4 id="toc_12">setValues</h4>

<p><code>void setValues (float[] values)</code>setValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</p>

<h4 id="toc_13">getValues</h4>

<p><code>void getValues (float[] values)</code>很显然，getValues和setValues是一对方法，参数也是浮点型的一维数组，长度需要大于9，将Matrix中的数值拷贝进参数的前9位中。</p>

<h2 id="toc_14">基本方法解析</h2>

<p>讲解完了matrix作用于像素点的原理之后，我们逐个讲解它的方法。</p>

<pre class="line-numbers"><code class="language-java">public Matrix()
public Matrix(Matrix src)
</code></pre>

<p>构造函数有两个，第一个是直接创建一个单位矩阵，第二个是根据提供的矩阵创建一个新的矩阵（采用deep copy）<br/>
单位矩阵如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616404162667.png" alt="20170923150616404162667.png"/><figcaption>20170923150616404162667.png</figcaption></figure></p>

<pre class="line-numbers"><code class="language-java">public boolean isIdentity()//判断是否是单位矩阵
public boolean isAffine()//判断是否是仿射矩阵
</code></pre>

<p>是否是单位矩阵很简单，就不做讲解了，这里是否是仿射矩阵可能大家不好理解。<br/>
首先来看看什么是仿射变换。仿射变换其实就是二维坐标到二维坐标的线性变换，保持二维图形的“平直性”（即变换后直线还是直线不会打弯，圆弧还是圆弧）和“平行性”（指保持二维图形间的相对位置关系不变，平行线还是平行线，而直线上点的位置顺序不变），可以通过一系列的原子变换的复合来实现，原子变换就包括：平移、缩放、翻转、旋转和错切。这里除了透视可以改变z轴以外，其他的变换基本都是上述的原子变换，所以，只要最后一行是0,0,1则是仿射矩阵。<code>public boolean rectStaysRect()</code>判断该矩阵是否可以将一个矩形依然变换为一个矩形。当矩阵是单位矩阵，或者只进行平移，缩放，以及旋转90度的倍数的时候，返回true。<code>public void reset()</code>重置矩阵为单位矩阵。<br/>
<code>public void setTranslate(float dx, float dy)</code>设置平移效果，参数分别是x，y上的平移量。<br/>
效果图如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616415154198.png" alt="20170923150616415154198.png"/><figcaption>20170923150616415154198.png</figcaption></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
canvas.drawBitmap(bitmap, matrix, paint);

matrix.setTranslate(100, 1000);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>

<h2 id="toc_15">代码验证</h2>

<p>在第一部分中讲到的各种图像变换的验证代码如下，一共列出了10种情况。如果要验证其中的某一种情况，只需将相应的代码反注释即可。试验中用到的图片：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883438981398.png" alt="2017030114883438981398.png"/><figcaption>2017030114883438981398.png</figcaption></figure><br/><br/>
其尺寸为162 x 251。  </p>

<p>每种变换的结果，请见代码之后的说明。</p>

<pre class="line-numbers"><code class="language-java">import android.app.Activity;  
import android.content.Context;  
import android.graphics.Bitmap;  
import android.graphics.BitmapFactory;  
import android.graphics.Canvas;  
import android.graphics.Matrix;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.MotionEvent;  
import android.view.View;  
import android.view.Window;  
import android.view.WindowManager;  
import android.view.View.OnTouchListener;  
import android.widget.ImageView;  
  
public class TestTransformMatrixActivity extends Activity  
implements  
OnTouchListener  
{  
    private TransformMatrixView view;  
    @Override  
    public void onCreate(Bundle savedInstanceState)  
    {  
        super.onCreate(savedInstanceState);  
        requestWindowFeature(Window.FEATURE_NO_TITLE);  
        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);  
  
        view = new TransformMatrixView(this);  
        view.setScaleType(ImageView.ScaleType.MATRIX);  
        view.setOnTouchListener(this);  
          
        setContentView(view);  
    }  
      
    class TransformMatrixView extends ImageView  
    {  
        private Bitmap bitmap;  
        private Matrix matrix;  
        public TransformMatrixView(Context context)  
        {  
            super(context);  
            bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.sophie);  
            matrix = new Matrix();  
        }  
  
        @Override  
        protected void onDraw(Canvas canvas)  
        {  
            // 画出原图像  
            canvas.drawBitmap(bitmap, 0, 0, null);  
            // 画出变换后的图像  
            canvas.drawBitmap(bitmap, matrix, null);  
            super.onDraw(canvas);  
        }  
  
        @Override  
        public void setImageMatrix(Matrix matrix)  
        {  
            this.matrix.set(matrix);  
            super.setImageMatrix(matrix);  
        }  
          
        public Bitmap getImageBitmap()  
        {  
            return bitmap;  
        }  
    }  
  
    public boolean onTouch(View v, MotionEvent e)  
    {  
        if(e.getAction() == MotionEvent.ACTION_UP)  
        {  
            Matrix matrix = new Matrix();  
            // 输出图像的宽度和高度(162 x 251)  
            Log.e(&quot;TestTransformMatrixActivity&quot;, &quot;image size: width x height = &quot; +  view.getImageBitmap().getWidth() + &quot; x &quot; + view.getImageBitmap().getHeight());  
            // 1. 平移  
            matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
            // 在x方向平移view.getImageBitmap().getWidth()，在y轴方向view.getImageBitmap().getHeight()  
            view.setImageMatrix(matrix);  
              
            // 下面的代码是为了查看matrix中的元素  
            float[] matrixValues = new float[9];  
            matrix.getValues(matrixValues);  
            for(int i = 0; i &lt; 3; ++i)  
            {  
                String temp = new String();  
                for(int j = 0; j &lt; 3; ++j)  
                {  
                    temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
                }  
                Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
            }  
              
  
//          // 2. 旋转(围绕图像的中心点)  
//          matrix.setRotate(45f, view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
              
//          // 3. 旋转(围绕坐标原点) + 平移(效果同2)  
//          matrix.setRotate(45f);  
//          matrix.preTranslate(-1f * view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight() / 2f);  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() / 2f, (float)view.getImageBitmap().getHeight() / 2f);  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate((float)view.getImageBitmap().getWidth() * 1.5f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 4. 缩放  
//          matrix.setScale(2f, 2f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠  
//          matrix.postTranslate(view.getImageBitmap().getWidth(), view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 5. 错切 - 水平  
//          matrix.setSkew(0.5f, 0f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠           
//          matrix.postTranslate(view.getImageBitmap().getWidth(), 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 6. 错切 - 垂直  
//          matrix.setSkew(0f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          7. 错切 - 水平 + 垂直  
//          matrix.setSkew(0.5f, 0.5f);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
//          // 8. 对称 (水平对称)  
//          float matrix_values[] = {1f, 0f, 0f, 0f, -1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(0f, view.getImageBitmap().getHeight() * 2f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }             
              
//          // 9. 对称 - 垂直  
//          float matrix_values[] = {-1f, 0f, 0f, 0f, 1f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }     
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠   
//          matrix.postTranslate(view.getImageBitmap().getWidth() * 2f, 0f);  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
  
              
//          // 10. 对称(对称轴为直线y = x)  
//          float matrix_values[] = {0f, -1f, 0f, -1f, 0f, 0f, 0f, 0f, 1f};  
//          matrix.setValues(matrix_values);  
//          // 下面的代码是为了查看matrix中的元素  
//          float[] matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
//            
//          // 做下面的平移变换，纯粹是为了让变换后的图像和原图像不重叠               
//          matrix.postTranslate(view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth(),   
//                  view.getImageBitmap().getHeight() + view.getImageBitmap().getWidth());  
//          view.setImageMatrix(matrix);  
//            
//          // 下面的代码是为了查看matrix中的元素  
//          matrixValues = new float[9];  
//          matrix.getValues(matrixValues);  
//          for(int i = 0; i &lt; 3; ++i)  
//          {  
//              String temp = new String();  
//              for(int j = 0; j &lt; 3; ++j)  
//              {  
//                  temp += matrixValues[3 * i + j ] + &quot;\t&quot;;  
//              }  
//              Log.e(&quot;TestTransformMatrixActivity&quot;, temp);  
//          }  
              
            view.invalidate();  
        }  
        return true;  
    }  
}
</code></pre>

<p>下面给出上述代码中，各种变换的具体结果及其对应的相关变换矩阵</p>

<h3 id="toc_16">平移</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834397841218.png" alt="20170301148834397841218.png"/><figcaption>20170301148834397841218.png</figcaption></figure><br/><br/>
输出的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834399578654.png" alt="20170301148834399578654.png"/><figcaption>20170301148834399578654.png</figcaption></figure><br/><br/>
请对照第一部分中的“一、平移变换”所讲的情形，考察上述矩阵的正确性。</p>

<h3 id="toc_17">旋转(围绕图像的中心点)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834401523528.png" alt="20170301148834401523528.png"/><figcaption>20170301148834401523528.png</figcaption></figure><br/>
输出的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834402755650.png" alt="20170301148834402755650.png"/><figcaption>20170301148834402755650.png</figcaption></figure>  </p>

<p><strong>它实际上是</strong> <br/>
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code><br/><br/>
这两条语句综合作用的结果。根据第一部分中“二、旋转变换”里面关于围绕某点旋转的公式,<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
所产生的转换矩阵就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834407336074.png" alt="20170301148834407336074.png"/><figcaption>20170301148834407336074.png</figcaption></figure><br/><br/>
而<code>matrix.postTranslate(view.getImageBitmap().getWidth()* 1.5f, 0f);</code>的意思就是在上述矩阵的左边再乘以下面的矩阵：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883440946965.png" alt="2017030114883440946965.png"/><figcaption>2017030114883440946965.png</figcaption></figure><br/><br/>
关于post是左乘这一点，我们在前面的理论部分曾经提及过，后面我们还会专门讨论这个问题。<br/><br/>
所以它实际上就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834415832436.png" alt="20170301148834415832436.png"/><figcaption>20170301148834415832436.png</figcaption></figure><br/><br/>
出去计算上的精度误差，我们可以看到我们计算出来的结果，和程序直接输出的结果是一致的。</p>

<h3 id="toc_18">旋转(围绕坐标原点旋转，在加上两次平移，效果同2)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834419441235.png" alt="20170301148834419441235.png"/><figcaption>20170301148834419441235.png</figcaption></figure><br/><br/>
根据第一部分中“二、旋转变换”里面关于围绕某点旋转的解释，不难知道：<br/><br/>
<code>matrix.setRotate(45f,view.getImageBitmap().getWidth() / 2f, view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
等价于<br/><br/>
<code>matrix.setRotate(45f);</code><br/><br/>
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
其中matrix.setRotate(45f)对应的矩阵是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834424050901.png" alt="20170301148834424050901.png"/><figcaption>20170301148834424050901.png</figcaption></figure>  </p>

<p>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f * view.getImageBitmap().getHeight()/ 2f)对应的矩阵是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834425298280.png" alt="20170301148834425298280.png"/><figcaption>20170301148834425298280.png</figcaption></figure>  </p>

<p>由于是preTranslate，是先乘，也就是右乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的右侧。  </p>

<p><code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f)</code>对应的矩阵是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834426293354.png" alt="20170301148834426293354.png"/><figcaption>20170301148834426293354.png</figcaption></figure><br/><br/>
这次由于是postTranslate，是后乘，也就是左乘，即它应该出现在matrix.setRotate(45f)所对应矩阵的左侧。  </p>

<p>所以综合起来，  </p>

<p><code>matrix.setRotate(45f);</code><br/><br/>
<code>matrix.preTranslate(-1f* view.getImageBitmap().getWidth() / 2f, -1f *view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
<code>matrix.postTranslate((float)view.getImageBitmap().getWidth()/ 2f, (float)view.getImageBitmap().getHeight() / 2f);</code><br/><br/>
对应的矩阵就是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834427273695.png" alt="20170301148834427273695.png"/><figcaption>20170301148834427273695.png</figcaption></figure><br/><br/>
这和下面这个矩阵(围绕图像中心顺时针旋转45度)其实是一样的：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834428250094.png" alt="20170301148834428250094.png"/><figcaption>20170301148834428250094.png</figcaption></figure><br/><br/>
因此，此处变换后的图像和2中变换后的图像时一样的。  </p>

<h3 id="toc_19">缩放变换</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834429635851.png" alt="20170301148834429635851.png"/><figcaption>20170301148834429635851.png</figcaption></figure><br/><br/>
程序所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443077762.png" alt="2017030114883443077762.png"/><figcaption>2017030114883443077762.png</figcaption></figure><br/><br/>
其中第二个矩阵，其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834431597151.png" alt="20170301148834431597151.png"/><figcaption>20170301148834431597151.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“三、缩放变换”和“一、平移变换”说法，自行验证结果。  </p>

<h3 id="toc_20">错切变换(水平错切)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443394822.png" alt="2017030114883443394822.png"/><figcaption>2017030114883443394822.png</figcaption></figure><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834434942666.png" alt="20170301148834434942666.png"/><figcaption>20170301148834434942666.png</figcaption></figure><br/><br/>
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883443583409.png" alt="2017030114883443583409.png"/><figcaption>2017030114883443583409.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_21">错切变换(垂直错切)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834436740060.png" alt="20170301148834436740060.png"/><figcaption>20170301148834436740060.png</figcaption></figure>  </p>

<p>代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834438464295.png" alt="20170301148834438464295.png"/><figcaption>20170301148834438464295.png</figcaption></figure><br/><br/>
其中，第二个矩阵其实是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834439581151.png" alt="20170301148834439581151.png"/><figcaption>20170301148834439581151.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_22">错切变换(水平+垂直错切)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834440579717.png" alt="20170301148834440579717.png"/><figcaption>20170301148834440579717.png</figcaption></figure><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834441593278.png" alt="20170301148834441593278.png"/><figcaption>20170301148834441593278.png</figcaption></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883444261979.png" alt="2017030114883444261979.png"/><figcaption>2017030114883444261979.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“四、错切变换”和“一、平移变换”的相关说法，自行验证结果。    </p>

<h3 id="toc_23">对称变换(水平对称)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834443981714.png" alt="20170301148834443981714.png"/><figcaption>20170301148834443981714.png</figcaption></figure>  </p>

<p>代码所输出的两个各矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017030114883444616294.png" alt="2017030114883444616294.png"/><figcaption>2017030114883444616294.png</figcaption></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834447285645.png" alt="20170301148834447285645.png"/><figcaption>20170301148834447285645.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_24">对称变换(垂直对称)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834448061705.png" alt="20170301148834448061705.png"/><figcaption>20170301148834448061705.png</figcaption></figure>  </p>

<p>代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834449886306.png" alt="20170301148834449886306.png"/><figcaption>20170301148834449886306.png</figcaption></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834450718549.png" alt="20170301148834450718549.png"/><figcaption>20170301148834450718549.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_25">对称变换(对称轴为直线y = x)</h3>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834451545673.png" alt="20170301148834451545673.png"/><figcaption>20170301148834451545673.png</figcaption></figure><br/><br/>
代码所输出的两个矩阵分别是：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834452594988.png" alt="20170301148834452594988.png"/><figcaption>20170301148834452594988.png</figcaption></figure><br/><br/>
其中，后者是下面两个矩阵相乘的结果：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834453180954.png" alt="20170301148834453180954.png"/><figcaption>20170301148834453180954.png</figcaption></figure><br/><br/>
大家可以对照第一部分中的“五、对称变换”和“一、平移变换”的相关说法，自行验证结果。  </p>

<h3 id="toc_26">关于先乘和后乘的问题</h3>

<p>由于矩阵的乘法运算不满足交换律，我们在前面曾经多次提及先乘、后乘的问题，即先乘就是矩阵运算中右乘，后乘就是矩阵运算中的左乘。其实先乘、后乘的概念是针对变换操作的时间先后而言的，左乘、右乘是针对矩阵运算的左右位置而言的。以第一部分“二、旋转变换”中围绕某点旋转的情况为例：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170301148834454434026.png" alt="20170301148834454434026.png"/><figcaption>20170301148834454434026.png</figcaption></figure><br/><br/>
越靠近原图像中像素的矩阵，越先乘，越远离原图像中像素的矩阵，越后乘。事实上，图像处理时，矩阵的运算是从右边往左边方向进行运算的。这就形成了越在右边的矩阵(右乘)，越先运算(先乘)，反之亦然。  </p>

<p>当然，在实际中，如果首先指定了一个matrix，比如我们先setRotate(\(\theta\))，即指定了上面变换矩阵中，中间的那个矩阵，那么后续的矩阵到底是pre还是post运算，都是相对这个中间矩阵而言的。  </p>

<h2 id="toc_27">进阶方法解析</h2>

<p>上面的基本方法中，有关于变换的set方法都可以带来不同的效果，但是每个set都会把上个效果清除掉，例如依次调用了setSkew,setTranslate，那么最终只有setTranslate会起作用，那么如何才和将两种效果复合呢。Matrix给我们提供了很多方法。但是主要都是2类：<br/>
preXXXX:以pre开头，例如preTranslate<br/>
postXXXX:以post开头，例如postScale<br/>
他们分别代表了前乘，和后乘。看一段代码：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
matrix.setTranslate(100, 1000);
matrix.preScale(0.5f, 0.5f);
</code></pre>

<p>这里matrix前乘了一个scale矩阵，换算成数学式如下：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017092315061645158599.png" alt="2017092315061645158599.png"/><figcaption>2017092315061645158599.png</figcaption></figure></p>

<p>从上面可以看出，最终得出的matrix既包含了缩放信息也有平移信息。<br/>
后乘自然就是matrix在后面，而缩放矩阵在前面，由于矩阵前后乘并不等价，也就导致了他们的效果不同。我们来看看后乘的结果：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616454160642.png" alt="20170923150616454160642.png"/><figcaption>20170923150616454160642.png</figcaption></figure></p>

<p>可以看到，结果跟上面不同，并且这也不是我们想要的结果，这里缩放没有更改，但是平移被减半了，换句话说，平移的距离也被缩放了。所以需要注意前后乘法的关系。<br/>
来看看他们对应的效果图：<br/><br/>
<strong>前乘：</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616460519787.png" alt="20170923150616460519787.png"/><figcaption>20170923150616460519787.png</figcaption></figure></p>

<p><strong>后乘：</strong></p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616463626763.png" alt="20170923150616463626763.png"/><figcaption>20170923150616463626763.png</figcaption></figure></p>

<p>可以明显看到，后乘的平移距离受了影响。<br/>
了解清除了前后乘的意义，在使用的过程中，多个效果的叠加时，一样要注意，否则效果达不到预期。</p>

<h2 id="toc_28">其他方法解析</h2>

<p>matrix除了上面的方法外，还有一些其他的方法，这里依次解析</p>

<h3 id="toc_29">setRectToRect</h3>

<p><code>public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf)</code>将rect变换成rect，上面的rectStaysRect已经说过，要保持rect只能做缩放平移和选择90度的倍数，那么这里其实也是一样，只是这几种变化，这里通过stf参数来控制。<br/><br/>
<code>ScaleToFit</code> 有如下四个值：<br/><br/>
<code>FILL</code>: 可能会变换矩形的长宽比，保证变换和目标矩阵长宽一致。<br/><br/>
<code>START</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。左上对齐。<br/><br/>
<code>CENTER</code>: 保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。<br/><br/>
<code>END</code>:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。右下对齐。<br/><br/>
这里使用谷歌的api demo的图片作为例子：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616472114007.png" alt="20170923150616472114007.png"/><figcaption>20170923150616472114007.png</figcaption></figure></p>

<h3 id="toc_30">setPolyToPoly</h3>

<p><code>public boolean setPolyToPoly(float[] src, int srcIndex,float[] dst, int dstIndex,int pointCount)</code>通过指定的0-4个点，原始坐标以及变化后的坐标，来得到一个变换矩阵。如果指定0个点则没有效果。<br/><br/>
下面通过例子分别说明1到4个点的可以达到的效果：</p>

<h4 id="toc_31">1个点，平移</h4>

<p>只指定一个点，可以达到平移效果：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616478770235.png" alt="20170923150616478770235.png"/><figcaption>20170923150616478770235.png</figcaption></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">float[] src = {0, 0};
int DX = 300;
float[] dst = {0 + DX, 0 + DX};
matrix.setPolyToPoly(src, 0, dst, 0, 1);
canvas.drawBitmap(bitmap, matrix, paint);1234512345
</code></pre>

<h4 id="toc_32">2个点，旋转或者缩放</h4>

<p>两个点，可以达到旋转效果或者缩放效果，缩放比较简单，这里我们来看旋转效果，一个点指定中心，一点指出旋转的效果</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616485313647.png" alt="20170923150616485313647.png"/><figcaption>20170923150616485313647.png</figcaption></figure></p>

<p>代码如下</p>

<pre class="line-numbers"><code class="language-java">int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {bw / 2, bh / 2, bw, 0};
float[] dst = {bw / 2, bh / 2, bw / 2 + bh / 2, bh / 2 + bw / 2};
matrix.setPolyToPoly(src, 0, dst, 0, 2);
canvas.drawBitmap(bitmap, matrix, paint);123456123456
</code></pre>

<p>图片的中心点作为旋转的中心，前后不变，右上角变化到了下方，所以导致图片旋转了90度。</p>

<h4 id="toc_33">3个点，错切</h4>

<p>使用3个点，可以产生错切效果，指定3个顶点，一个固定，另外两个移动。<br/><br/>
看图：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616492474600.png" alt="20170923150616492474600.png"/><figcaption>20170923150616492474600.png</figcaption></figure></p>

<p>代码如下：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0,0, 0, bh,bw,bh};
float[] dst = {0, 0, 200, bh, bw + 200, bh};
matrix.setPolyToPoly(src, 0, dst, 0, 3);
canvas.drawBitmap(bitmap, matrix, paint);12345671234567
</code></pre>

<h4 id="toc_34">4个点，透视</h4>

<p>透视就是观察的角度变化了。导致投射到平面上的二维图像变化了。<br/>
我们看下面的例子，更容易理解：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616497319034.png" alt="20170923150616497319034.png"/><figcaption>20170923150616497319034.png</figcaption></figure></p>

<p>图片看起来好像倾斜了，实现特别简单：</p>

<pre class="line-numbers"><code class="language-java">Matrix matrix = new Matrix();
int bw = bitmap.getWidth();
int bh = bitmap.getHeight();
float[] src = {0, 0, 0, bh, bw, bh, bw, 0};
int DX = 100;
float[] dst = {0 + DX, 0, 0, bh, bw, bh, bw - DX, 0};
matrix.setPolyToPoly(src, 0, dst, 0, 4);
canvas.drawBitmap(bitmap, matrix, paint);1234567812345678
</code></pre>

<p>可以看到，只是把左右两个顶点往里面收拢了，这样就得出了一个有3d效果的透视图。</p>

<h3 id="toc_35">invert</h3>

<p><code>public boolean invert(Matrix inverse)</code>反转当前矩阵，如果能反转就返回true并将反转后的值写入inverse，否则返回false。当前矩阵*inverse=单位矩阵。<br/><br/>
反转前后有什么效果，我们来看看示例：</p>

<p><figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170923150616503373152.png" alt="20170923150616503373152.png"/><figcaption>20170923150616503373152.png</figcaption></figure></p>

<p>可以看到，反转之后，其实是对效果的一种反转。</p>

<h3 id="toc_36">mapPoints</h3>

<pre class="line-numbers"><code class="language-java">public void mapPoints(float[] dst, int dstIndex, float[] src, int srcIndex,int pointCount)
public void mapPoints(float[] dst, float[] src)
public void mapPoints(float[] pts)
</code></pre>

<p>映射点的值到指定的数组中，这个方法可以在矩阵变换以后，给出指定点的值。</p>

<ul>
<li>dst：指定写入的数组<br/></li>
<li>dstIndex：写入的起始索引，x，y两个坐标算作一对，索引的单位是对，也就是经过两个值才加1</li>
<li>src：指定要计算的点</li>
<li>srcIndex：要计算的点的索引</li>
<li>pointCount：需要计算的点的个数，每个点有两个值，x和y。</li>
</ul>

<h3 id="toc_37">mapVectors</h3>

<pre class="line-numbers"><code class="language-java">public void mapVectors(float[] dst, int dstIndex, float[] src, int srcIndex,int vectorCount)
public void mapVectors(float[] dst, float[] src)
public void mapVectors(float[] vecs)

</code></pre>

<p>与上面的mapPoionts基本类似，这里是将一个矩阵作用于一个向量，由于向量的平移前后是相等的，所以这个方法不会对translate相关的方法产生反应，如果只是调用了translate相关的方法，那么得到的值和原本的一致。</p>

<h3 id="toc_38">mapRect</h3>

<pre class="line-numbers"><code class="language-java">public boolean mapRect(RectF dst, RectF src)
public boolean mapRect(RectF rect)
</code></pre>

<p>返回值即是调用的rectStaysRect()，这个方法前面有讲过，这里把src中指定的矩形的左上角和右下角的两个点的坐标，写入dst中。</p>

<h3 id="toc_39">mapRadius</h3>

<p><code>public float mapRadius(float radius)</code>返回一个圆圈半径的平均值，将matrix作用于一个指定radius半径的圆，随后返回的平均半径。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2017-02-09T21:40:26+08:00" itemprop="datePublished">2017/2/9</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Android.html'>Android</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="15561207868826.html" itemprop="url">
		Android 冷启动实现APP秒开</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">前言</h2>

<p>在阅读这篇文章之前，首先需要理解几个东西：  </p>

<ul>
<li>1、什么是Android的冷启动时间？<br/>
冷启动时间是指用户从手机桌面点击APP的那一刻起到启动页面的Activity调用onCreate()方法之间的这个时间段。</li>
<li>2、在冷启动的时间段内发生了什么？<br/>
首先我们要知道当打开一个Activity的时候发生了什么，在一个Activity打开时，如果该Activity所属的Application还没有启动，那么系统会为这个Activity创建一个进程（每创建一个进程都会调用一次Application，所以Application的onCreate()方法可能会被调用多次），在进程的创建和初始化中，势必会消耗一些时间，在这个时间里，WindowManager会先加载APP里的主题样式里的窗口背景（windowBackground）作为预览元素，然后才去真正的加载布局，如果这个时间过长，而默认的背景又是黑色或者白色，这样会给用户造成一种错觉，这个APP很卡，很不流畅，自然也影响了用户体验。<br/></li>
</ul>

<p>来看下效果图：<br/><br/>
<strong>未优化：</strong><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227548242189443-4a70e91b2e124b48.gif" alt="20170227548242189443-4a70e91b2e124b48.gif"/><figcaption>20170227548242189443-4a70e91b2e124b48.gif</figcaption></figure></p>

<p><strong>优化方案一：</strong><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227487382189443-4829eba35492d39b.gif" alt="20170227487382189443-4829eba35492d39b.gif"/><figcaption>20170227487382189443-4829eba35492d39b.gif</figcaption></figure></p>

<p><strong>优化方案二：</strong><br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227662152189443-c861191c8a80cd94.gif" alt="20170227662152189443-c861191c8a80cd94.gif"/><figcaption>20170227662152189443-c861191c8a80cd94.gif</figcaption></figure></p>

<h2 id="toc_1">历史原因</h2>

<p>当系统启动一个APP时，zygote进程会首先创建一个新的进程去运行这个APP，但是进程的创建是需要时间的，在创建完成之前，界面是呈现假死状态的，这就很尴尬了，因为用户会以为没有点到APP而再次点击，这极大的降低用户体验，Android需要及时做出反馈去避免这段迷之尴尬。于是系统根据你的manifest文件设置的主题颜色的不同来展示一个白屏或者黑屏。而这个黑（白）屏正式的称呼应该是<strong>Preview Window</strong>,即预览窗口。</p>

<p>好了，现在我们明白了，Preview Window其实是为了提高用户体验而有意设定的。因此，其实如果不是强迫症，它可能并不是一个问题。</p>

<p>但是我猜大部分小伙伴应该是和我一样的强迫症患者：这么丑的黑屏怎么能出现在我的APP上呢？？？！！！</p>

<p>所以，下面我们就来聊聊这个问题的解决方案。</p>

<h2 id="toc_2">解决方案</h2>

<p>既然决定解决这个问题，那么从哪里入手呢，Android在选择展示黑屏或者白屏的时候，是根据你设定的主题而不同的，也就是说，虽然你的代码没有被执行，你的配置文件却被提前读取了，用来作为展示Preview Window界面的依据。在用户点击手机桌面APP的时候，看到的黑屏或者白屏其实是界面渲染前的第一帧，如果你看懂了文章头的那2个问题，那么解决这个问题就非常轻松了，无非就是将Theme里的windowBackground设置成我们想要让用户看到的画面就可以了</p>

<p>所以，我们的解决方案的切入口就是整个APP的manifest文件，更确切的说应该是主题配置文件。</p>

<h3 id="toc_3">方案一 ：开历史倒车</h3>

<p>这个方案就是禁止加载Preview Window，具体做法如下：</p>

<p>style.xml</p>

<style name="APPTheme" parent="@android:style/Theme.Holo.NoActionBar">
   <item name="android:windowDisablePreview">true</item>
</style>

<p>将APPTheme设定为启动的Activity的主题，即可禁止Preview Window，当然，也有人通过把preview window设置为全透明，也达成了类似的效果。</p>

<p>结果就是，当你点击APP时，界面会无响应一段时间，然后进入APP。</p>

<p>我个人强烈不推荐这么做，因为Android想方设法提升的用户体验一下子被你打回解放前。</p>

<h3 id="toc_4">方案二：自定义Preview Window</h3>

<h4 id="toc_5">1、透明启动</h4>

<p>将背景颜色设置为透明色，这样当用户点击桌面APP图片的时候，并不会&quot;立即&quot;进入APP，而且在桌面上停留一会，其实这时候APP已经是启动的了，只是我们心机的把Theme里的windowBackground的颜色设置成透明的，强行把锅甩给了手机应用厂商（手机反应太慢了啦，哈哈），其实现在微信也是这样做的，不信你可以试试。<br/>
<code>&lt;style name=&quot;Appwelcome&quot; parent=&quot;android:Theme.Translucent.NoTitleBar.Fullscreen&quot;/&gt;</code><br/>
透明化这种做法需要注意的一点，如果直接把Theme引入Activity，在运行的时候可能会出现如下异常：</p>

<blockquote>
<p>java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.</p>
</blockquote>

<p>这个是因为使用了不兼容的Theme，例如我这里的Activity继承了AppCompatActivity，解决方案很简单：</p>

<ul>
<li>1、让其Activity集成Activity而不要集成兼容性的AppCompatActivity</li>
<li>2、在onCreate()方法里的super.onCreate(savedInstanceState)之前设置我们原来APP的Theme</li>
</ul>

<pre class="line-numbers"><code class="language-java">public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
            setTheme(R.style.AppTheme);
            super.onCreate(savedInstanceState);
    }
}
</code></pre>

<h4 id="toc_6">2、Logo图片启动</h4>

<p>将背景图设置成我们APP的Logo图，作为APP启动的引导，现在市面上大部分的APP也是这么做的。<br/><br/>
具体方法如下：</p>

<p>style.xlm</p>

<pre class="line-numbers"><code class="language-markup">&lt;style name=&quot;APPTheme&quot; parent=&quot;@android:style/Theme.Holo.NoActionBar&quot;&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/splash_icon&lt;/item&gt;
&lt;/style&gt;
</code></pre>

<p>同样将主题设置到启动的Activity的主题中，windowBackground就是即将展示的preview window。其中splash_icon可以是一整张图片，网上很多小伙伴也都是这么做的。其实它也可以是一个能解析出图片资源的XML文件，好像只有layer-list这种能做得到,因为它能够将多个drawable叠加起来展示。</p>

<p>splash_icon.xml</p>

<pre class="line-numbers"><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:opacity=&quot;opaque&quot;&gt;
    &lt;item android:drawable=&quot;@color/white&quot;/&gt;
    &lt;item&gt;
        &lt;bitmap
            android:gravity=&quot;center&quot;
            android:src=&quot;@drawable/qq&quot;/&gt;
    &lt;/item&gt;
&lt;/layer-list&gt;
</code></pre>

<p>这样设置之后，当你点击APP，会立马进入你配置的界面，然后启动欢迎页，效果如下<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/2017022724594838b008fdb18f761ede8.gif" alt="2017022724594838b008fdb18f761ede8.gif"/><figcaption>2017022724594838b008fdb18f761ede8.gif</figcaption></figure></p>

<p>上面的2种做法，我们都需要将Theme引入对应的Activity</p>

<pre class="line-numbers"><code class="language-java">&lt;activity
    android:name=&quot;.app.main.MainActivity&quot;
    android:theme=&quot;@style/AppWelcome&quot;
    android:screenOrientation=&quot;portrait&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<p>那么，将preview window直接设置为图片和设置为xml文件有什么区别或者优劣呢？我先卖个关子。先谈谈这种方案的优劣，首先这种方案已经解决了原生preview window的单调难看的问题，在原来的基础上进一步提升了用户体验。可是我们的APP都是有欢（guang）迎（gao）页的，从preview window跳转到欢（guang）迎（gao）页是不可避免的，这样的话，两个界面的切换就会显得很突兀的，</p>

<p>所以强迫症的我们，尝试让这两个界面的切换变成一个界面的变化，从而进一步提升显示效果，怎么样才能让两个界面切换看起来像是在同一个界面里的变化呢？答案就是： 动画。</p>

<p>在这种需求下，图片和xml文件的区别就出来了，因为后者可以帮助我们更准确的实现动画。</p>

<h3 id="toc_7">方案三：自定义Preview Window增强版</h3>

<p>废话少说，我们先来看效果<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/20170227597652f5ba2feffca1ca31a8c.gif" alt="20170227597652f5ba2feffca1ca31a8c.gif"/><figcaption>20170227597652f5ba2feffca1ca31a8c.gif</figcaption></figure></p>

<p>有了动画之后，界面切换顺畅了许多。<br/>
上面的动画实现其实非常简单，无非就是放缩，移动，渐变的组合使用（我仅仅用作范例给大家参考），具体的动画代码细节就不谈了，有兴趣可以去github上看<a href="https://github.com/ladingwu/Splash">本次项目的demo</a>，我们重点来聊一聊思路。</p>

<p>在这里我们需要明确一点的是，<strong>preview window</strong> 只能是静态图，它本身是不展示动画的，我们这里的动画，其实是在进入欢迎页之后的展示的。明确了这一点之后，整个动画效果的实现思路其实就已经摆在我们眼前了，那就是当界面从 <strong>Preview Window</strong> 跳转到 欢迎页 的时候，欢迎页必须首先展示一个和 <strong>Preview Window</strong> 一模一样的界面，让人看起来好像界面还没切换一样，然后再慢慢切换到欢迎页。</p>

<p>然后，我们再来谈谈为什么设置xml的方式可以帮助我们更准确的实现动画，就是因为要保证 <strong>Preview Window</strong> 和欢迎页最开始展示的界面保持绝对一致，只有通过xml的布局才是达到这种效果。</p>

<p>好了，启动页做到这个份儿上，应该就可以交货了，不过还有一个小问题需要大家注意的，那就是我们给Preview Window设置的背景图如果不做处理，图片就会一直存在于内存中，所以，当我们进入到欢迎页的时候，不要忘了把背景图设置为空：</p>

<p>SplashActivity.java</p>

<pre class="line-numbers"><code class="language-java">@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    //将window的背景图设置为空
    getWindow().setBackgroundDrawable(null);
    super.onCreate(savedInstanceState);
}
</code></pre>

<h2 id="toc_8">关于启动优化</h2>

<p>上面的做法其实可以达到&quot;秒开&quot;APP的效果，不过确不是真实的速度，在Activity创建过程中其实是会经过一系列framework层的操作，在日常开发中，我们都会去重写Application类，然后在Application里进行一些初始化操作，比如存放用户标识的静态化TOKEN，第三方SDK的初始化等。<br/><br/>
这里给出几点建议：  </p>

<ul>
<li>1、不要让Application参与业务的操作</li>
<li>2、不要在APPlication进行耗时操作，比如有些开发者会在自己的APP里一系列文件夹或文件（比如我自己），这些I/O操作应该放到&quot;确实该使用的时候再去创建&quot;亦或者是数据库的一些操作。</li>
<li>3、不要以静态变量的方式在Application中保存数据等。</li>
</ul>

<p>当然这是绝对的理想主义，把上面的&quot;不要&quot;2字之前添上&quot;尽量&quot;2字吧，毕竟在实际开发中，这样做确实会让我们方便许多。</p>

<p>对了，补充一点，布局也是很重要的，尽量的去减少布局的复杂性，布局深度，因为在View绘制的过程中，测量也是很耗费性能的。</p>

<h2 id="toc_9">总结</h2>

<p>到这里，关于Android启动页的相关问题就都讲完了。<br/><br/>
最终的高清的效果图：<br/><br/>
<figure><img src="http://ohtrrgyyd.bkt.clouddn.com/201702274812409e2d6cccbbdf90fb06f.gif" alt="201702274812409e2d6cccbbdf90fb06f.gif"/><figcaption>201702274812409e2d6cccbbdf90fb06f.gif</figcaption></figure></p>


			
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 <a class="prev" href="all_11.html">Prev</a>  
	 <a class="next" href="all_13.html">Next</a> 
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  
    

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>